{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/fer/ccr/EF_InternalUtil.c": "/*\n*  This software was developed by the Thermal Modeling and Analysis\n*  Project(TMAP) of the National Oceanographic and Atmospheric\n*  Administration's (NOAA) Pacific Marine Environmental Lab(PMEL),\n*  hereafter referred to as NOAA/PMEL/TMAP.\n*\n*  Access and use of this software shall impose the following\n*  obligations and understandings on the user. The user is granteHd the\n*  right, without any fee or cost, to use, copy, modify, alter, enhance\n*  and distribute this software, and any derivative works thereof, and\n*  its supporting documentation for any purpose whatsoever, provided\n*  that this entire notice appears in all copies of the software,\n*  derivative works and supporting documentation.  Further, the user\n*  agrees to credit NOAA/PMEL/TMAP in any publications that result from\n*  the use of this software or in any product that includes this\n*  software. The names TMAP, NOAA and/or PMEL, however, may not be used\n*  in any advertising or publicity to endorse or promote any products\n*  or commercial entity unless specific written permission is obtained\n*  from NOAA/PMEL/TMAP. The user also understands that NOAA/PMEL/TMAP\n*  is not obligated to provide the user with any support, consulting,\n*  training or assistance of any kind with regard to the use, operation\n*  and performance of this software nor to provide the user with any\n*  updates, revisions, new versions or \"bug fixes\".\n*\n*  THIS SOFTWARE IS PROVIDED BY NOAA/PMEL/TMAP \"AS IS\" AND ANY EXPRESS\n*  OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n*  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n*  ARE DISCLAIMED. IN NO EVENT SHALL NOAA/PMEL/TMAP BE LIABLE FOR ANY SPECIAL,\n*  INDIRECT OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER\n*  RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF\n*  CONTRACT, NEGLIGENCE OR OTHER TORTUOUS ACTION, ARISING OUT OF OR IN\n*  CONNECTION WITH THE ACCESS, USE OR PERFORMANCE OF THIS SOFTWARE.\n*\n*/\n\n\n/* EF_InternalUtil.c\n *\n * Jonathan Callahan\n * Sep 4th 1997\n *\n * This file contains all the utility functions which Ferret\n * needs in order to communicate with an external function.\n */\n\n/* Ansley Manke  March 2000\n *  Additions to allow internally linked external functions.\n *  Source code is in the directory FERRET/fer/efi\n *  In that directory, run the perl script int_dlsym.pl\n *  int_dlsym.pl ./ > intlines.c\n *  The result is lines of C code to be put into this file.\n *  Search for the comment string --------------------\n *\n *  1.  Function declaration lines.  Need to edit these to have\n *      the correct number of arguments for the _compute subroutines.\n *  2.  definition of N_INTEF and structure I_EFnames\n *  3.  internal_dlsym lines at the end\n\n* Jonathan Callahan and Ansley Manke  30-May-2000\n * Fix memory leak:  already_have_internals needs to be tested for when\n * we find the external function in efcn_gather_info  and set TRUE once\n * the internals have been set for the first time, also in efcn_gather_info.\n\n* Ansley Manke  August 2001\n * add EOF_SPACE, EOF_STAT, EOF_TFUNC to the functions that are\n * statically linked\n\n* V5.4 *acm* 10/01 add compress* to the statically linked fcns\n* v6.0 *acm*  5/06 many more functions internally linked.\n* V6.0 *acm*  5/06 string results for external functions\n* v6.0 *acm*  5/06 internal_dlsym was missing the nco functions.\n* V6.03 *acm& 5/07 Add tax_ functions, fill_xy to the statically-linked functions\n* V6.07 *acm* 8/07 remove xunits_data from list of I_EFnames; it should never\n*                  have been there.\n* V6.12 *acm* 8/07 add functions scat2grid_bin_xy and scat2grid_nobs_xy.F\n* V6.2 *acm* 11/08 New functions XCAT_STR, YCAT_STR, ...\n* V6.2 *acm* 11/08 New internally-called function efcn_get_alt_type_fcn to\n*                  get the name of a function to call if the arguments are of\n*                  a different type than defined in the current function. E.g.\n*                  this lets the user reference XCAT with string arguments and\n*                  Ferret will run XCAT_STR\n* V6.6 *acm* 4/10 add functions scat2grid_nbin_xy and scat2grid_nbin_xyt.F\n* V664 *kms*  9/10 Added python-backed external functions via $FER_DIR/lib/libpyefcn.so\n*                  Made external function language check more robust\n*                  Check that GLOBAL_ExternalFunctionsList is not NULL in ef_ptr_from_id_ptr\n*      *kms* 11/10 Check for libpyefcn.so in $FER_LIBS instead of $FER_DIR/lib\n* *acm*  1/12      - Ferret 6.8 ifdef double_p for double-precision ferret, see the\n*                  definition of macro DFTYPE in ferret.h\n*      *kms*  3/12 Add E and F dimensions\n*      *acm*  6/14 New separate function for DSG files\n*      *acm*  9/14 Make DATE1900 accept an array of date strings, returning an array of coordinates\n*      *acm*  2/15 TAX_DATESTRING works on an F or a T axis\n*      *acm*  2/15 new Functions TIME_REFORMAT, FT_TO_ORTHOGONAL\n* V702 *sh*   1/17 added support for FORTRAN90 dynamic memory management\n*                  removing \"memory\" pointer in favor of individual arg ptrs\n* V74  *acm*  2/18 New box_edges function\n*/\n\n\n/* .................... Includes .................... */\n\n#include <sys/types.h>        /* required for some of our prototypes */\n#include <sys/stat.h>\n#include <sys/errno.h>\n\n#include <ctype.h>\n#include <dlfcn.h>\n#include <fcntl.h>\n#include <setjmp.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <unistd.h>\n\n#include \"ferret.h\"\n#include \"FerMem.h\"\n#include \"EF_Util.h\"\n#include \"list.h\"  /* locally added list library */\n\n\n/* ................ Global Variables ................ */\n/*\n * The mr_list_ptr and cx_list_ptr are obtained from Ferret\n * and cached whenever they are passed into one of the \"efcn_\" functions.\n * These pointers can be accessed by the utility functions in efn_ext/.\n * This way the EF writer does not need to see these pointers.\n *\n * 1/17 - c argument pointers (GLOBAL_arg_ptrs) and the result pointer\n *        (GLOBAL_res_ptr)are obtained from FORTRAN later on demand\n *\n * This is the instantiation of these values.\n */\n\nint    *GLOBAL_mr_list_ptr;\nint    *GLOBAL_cx_list_ptr;\nint    *GLOBAL_mres_ptr;\nDFTYPE *GLOBAL_bad_flag_ptr;\n\nDFTYPE *GLOBAL_arg_ptrs[EF_MAX_ARGS];\nDFTYPE *GLOBAL_res_ptr;\n\nstatic LIST *STATIC_ExternalFunctionList;\n\n/*\n * The jumpbuffer is used by setjmp() and longjmp().\n * setjmp() is called by FORTRAN(efcn_compute)() in EF_InternalUtil.c and\n * saves the stack environment in jumpbuffer for later use by longjmp().\n * This allows one to bail out of external functions and still\n * return control to Ferret.\n * Check \"Advanced Progrmming in the UNIX Environment\" by Stevens\n * sections 7.10 and 10.14 to understand what's going on with these.\n */\nstatic jmp_buf jumpbuffer;\nstatic sigjmp_buf sigjumpbuffer;\nstatic volatile sig_atomic_t canjump;\n\n/*\n * Prototype of internal_dlsym defined at end of this module.\n * Accepts a string naming a function and returns a pointer\n * to the function.  Prototyped as return (void *) since the\n * functions returned have different signatures.\n */\nstatic void *internal_dlsym(char *name);\n\n/*\n * libpyefcn.so no longer created; PyFerret has everything\n * wrapped combined in _pyferret.so.  Thus, all the\n * pyefcn_* stuff not used in traditional Ferret.\n */\n\n/* handle returned from dlopen of $FER_LIBS/libpyefcn.so */\nstatic void *pyefcn_handle = NULL;\n\n/*\n * pointer to the function in libpyefcn.so:\n *     void pyefcn_init(int id, char modname[], char errmsg[])\n */\nstatic void (*pyefcn_init_func)(int, char [], char []) = NULL;\n\n/*\n * pointer to the function in libpyefcn.so:\n *     void pyefcn_custom_axes(int id, char modname[], char errmsg[])\n */\nstatic void (*pyefcn_custom_axes_func)(int, char [], char []) = NULL;\n\n/*\n * pointer to the function in libpyefcn.so:\n *     void pyefcn_result_limits(int id, char modname[], char errmsg[])\n */\nstatic void (*pyefcn_result_limits_func)(int, char [], char []) = NULL;\n\n/*\n * pointer to the function in libpyefcn.so:\n *     void pyefcn_compute(int id, char modname[], DFTYPE *arrays[], int numarrays,\n *                         int memlo[][NFERDIMS], int memhi[][NFERDIMS],\n *                         int steplo[][NFERDIMS], int stephi[][NFERDIMS], int incr[][NFERDIMS],\n *                         DFTYPE badvals[], char errmsg[])\n */\nstatic void (*pyefcn_compute_func)(int, char [], DFTYPE *[], int,\n                                   int [][NFERDIMS], int [][NFERDIMS],\n                                   int [][NFERDIMS], int [][NFERDIMS], int [][NFERDIMS],\n                                   DFTYPE [], char []) = NULL;\n\nstatic int I_have_scanned_already = FALSE;\n\n\n/* ............. Function Declarations .............. */\n/*\n * Note that all routines called directly from Ferret,\n * ie. directly from Fortran, should be all lower case,\n * be of type 'void', pass by reference and should end with\n * an underscore.\n */\n\n\n/* .... Functions called by Ferret .... */\n\nint  FORTRAN(efcn_scan)( int * );\nint  FORTRAN(efcn_already_have_internals)( int * );\n\nvoid FORTRAN(create_pyefcn)(char fname[], int *lenfname, char pymod[], int *lenpymod,\n                            char errstring[], int *lenerrstring);\n\nint  FORTRAN(efcn_gather_info)( int * );\nvoid FORTRAN(efcn_get_custom_axes)( int *, int *, int * );\nvoid FORTRAN(efcn_get_result_limits)( int *, int *, int *, int * );\nvoid FORTRAN(efcn_compute)( int *, int *, int *, int *, int *, DFTYPE *, int * );\n\n\nvoid FORTRAN(efcn_get_custom_axis_sub)( int *, int *, double *, double *, double *, char *, int * );\n\nint  FORTRAN(efcn_get_id)( char * );\nint  FORTRAN(efcn_match_template)( int *, char * );\n\nvoid FORTRAN(efcn_get_name)( int *, char * );\nvoid FORTRAN(efcn_get_version)( int *, DFTYPE * );\nvoid FORTRAN(efcn_get_descr)( int *, char * );\nvoid FORTRAN(efcn_get_alt_type_fcn)( int *, char * );\nint  FORTRAN(efcn_get_num_reqd_args)( int * );\nvoid FORTRAN(efcn_get_has_vari_args)( int *, int * );\nvoid FORTRAN(efcn_get_axis_will_be)( int *, int * );\nvoid FORTRAN(efcn_get_axis_reduction)( int *, int * );\nvoid FORTRAN(efcn_get_piecemeal_ok)( int *, int * );\n\nvoid FORTRAN(efcn_get_axis_implied_from)( int *, int *, int * );\nvoid FORTRAN(efcn_get_axis_extend_lo)( int *, int *, int * );\nvoid FORTRAN(efcn_get_axis_extend_hi)( int *, int *, int * );\nvoid FORTRAN(efcn_get_axis_limits)( int *, int *, int *, int * );\nint  FORTRAN(efcn_get_arg_type)( int *, int *);\nvoid FORTRAN(efcn_get_arg_name)( int *, int *, char * );\nvoid FORTRAN(efcn_get_arg_unit)( int *, int *, char * );\nvoid FORTRAN(efcn_get_arg_desc)( int *, int *, char * );\nint  FORTRAN(efcn_get_rtn_type)( int *);\nvoid FORTRAN(efcn_rqst_mr_ptrs)( int *, int *, int * ); // narg, mr_list, mres\nvoid FORTRAN(efcn_pass_arg_ptr)(int *, DFTYPE *);\nvoid FORTRAN(efcn_pass_res_ptr)(DFTYPE *);\n\n\n/* .... Functions called internally .... */\n\n/* Fortran routines from the efn/ directory */\nvoid FORTRAN(efcn_copy_array_dims)(void);\nvoid FORTRAN(efcn_set_work_array_dims)(int *, int *, int *, int *, int *, int *, int *,\n                                              int *, int *, int *, int *, int *, int *);\nvoid FORTRAN(efcn_get_workspace_addr)(DFTYPE *, int *, DFTYPE *);\n\nstatic void EF_signal_handler(int signo);\nstatic void (*fpe_handler)(int);      /* function pointers */\nstatic void (*segv_handler)(int);\nstatic void (*int_handler)(int);\nstatic void (*bus_handler)(int);\nint EF_Util_setsig();\nint EF_Util_ressig();\n\n\nvoid EF_store_globals(int *, int *, int *, DFTYPE *);\n\nExternalFunction *ef_ptr_from_id_ptr(int *);\n\nint  EF_ListTraverse_fprintf( char *, char * );\nint  EF_ListTraverse_FoundName( char *, char * );\nint  EF_ListTraverse_MatchTemplate( char *, char * );\nint  EF_ListTraverse_FoundID( char *, char * );\n\nint  EF_New( ExternalFunction * );\n\n/*  ------------------------------------\n *  Statically linked external functions\n *  Declarations generated by the perl script int_dlsym.pl.\n *  Need to fill out the arguments for the _compute subroutines.\n */\n\nvoid FORTRAN(ffta_init)(int *);\nvoid FORTRAN(ffta_custom_axes)(int *);\nvoid FORTRAN(ffta_result_limits)(int *);\nvoid FORTRAN(ffta_work_size)(int *);\nvoid FORTRAN(ffta_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(fftp_init)(int *);\nvoid FORTRAN(fftp_custom_axes)(int *);\nvoid FORTRAN(fftp_result_limits)(int *);\nvoid FORTRAN(fftp_work_size)(int *);\nvoid FORTRAN(fftp_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(fft_im_init)(int *);\nvoid FORTRAN(fft_im_custom_axes)(int *);\nvoid FORTRAN(fft_im_result_limits)(int *);\nvoid FORTRAN(fft_im_work_size)(int *);\nvoid FORTRAN(fft_im_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(fft_inverse_init)(int *);\nvoid FORTRAN(fft_inverse_result_limits)(int *);\nvoid FORTRAN(fft_inverse_work_size)(int *);\nvoid FORTRAN(fft_inverse_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(fft_re_init)(int *);\nvoid FORTRAN(fft_re_custom_axes)(int *);\nvoid FORTRAN(fft_re_result_limits)(int *);\nvoid FORTRAN(fft_re_work_size)(int *);\nvoid FORTRAN(fft_re_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(sampleij_init)(int *);\nvoid FORTRAN(sampleij_result_limits)(int *);\nvoid FORTRAN(sampleij_work_size)(int *);\nvoid FORTRAN(sampleij_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *,\n       DFTYPE *, DFTYPE *, DFTYPE *);\n\n\nvoid FORTRAN(samplei_multi_init)(int *);\nvoid FORTRAN(samplei_multi_result_limits)(int *);\nvoid FORTRAN(samplei_multi_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(samplej_multi_init)(int *);\nvoid FORTRAN(samplej_multi_result_limits)(int *);\nvoid FORTRAN(samplej_multi_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(samplek_multi_init)(int *);\nvoid FORTRAN(samplek_multi_result_limits)(int *);\nvoid FORTRAN(samplek_multi_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(samplel_multi_init)(int *);\nvoid FORTRAN(samplel_multi_result_limits)(int *);\nvoid FORTRAN(samplel_multi_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(samplem_multi_init)(int *);\nvoid FORTRAN(samplem_multi_result_limits)(int *);\nvoid FORTRAN(samplem_multi_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(samplen_multi_init)(int *);\nvoid FORTRAN(samplen_multi_result_limits)(int *);\nvoid FORTRAN(samplen_multi_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(samplet_date_init)(int *);\nvoid FORTRAN(samplet_date_result_limits)(int *);\nvoid FORTRAN(samplet_date_work_size)(int *);\nvoid FORTRAN(samplet_date_compute)(int *, DFTYPE *, DFTYPE *,\n      DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n      DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(samplef_date_init)(int *);\nvoid FORTRAN(samplef_date_result_limits)(int *);\nvoid FORTRAN(samplef_date_work_size)(int *);\nvoid FORTRAN(samplef_date_compute)(int *, DFTYPE *, DFTYPE *,\n      DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n      DFTYPE *, DFTYPE *);\n\n\nvoid FORTRAN(samplexy_init)(int *);\nvoid FORTRAN(samplexy_result_limits)(int *);\nvoid FORTRAN(samplexy_work_size)(int *);\nvoid FORTRAN(samplexy_compute)(int *, DFTYPE *, DFTYPE *,\n      DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(samplexyt_init)(int *);\nvoid FORTRAN(samplexyt_result_limits)(int *);\nvoid FORTRAN(samplexyt_work_size)(int *);\nvoid FORTRAN(samplexyt_compute)(int *, DFTYPE *, DFTYPE *,\n      DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(samplexyt_nrst_init)(int *);\nvoid FORTRAN(samplexyt_nrst_result_limits)(int *);\nvoid FORTRAN(samplexyt_nrst_work_size)(int *);\nvoid FORTRAN(samplexyt_nrst_compute)(int *, DFTYPE *, DFTYPE *,\n      DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(scat2gridgauss_xy_init)(int *);\nvoid FORTRAN(scat2gridgauss_xy_work_size)(int *);\nvoid FORTRAN(scat2gridgauss_xy_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(scat2gridgauss_xz_init)(int *);\nvoid FORTRAN(scat2gridgauss_xz_work_size)(int *);\nvoid FORTRAN(scat2gridgauss_xz_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(scat2gridgauss_yz_init)(int *);\nvoid FORTRAN(scat2gridgauss_yz_work_size)(int *);\nvoid FORTRAN(scat2gridgauss_yz_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(scat2gridgauss_xt_init)(int *);\nvoid FORTRAN(scat2gridgauss_xt_work_size)(int *);\nvoid FORTRAN(scat2gridgauss_xt_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(scat2gridgauss_yt_init)(int *);\nvoid FORTRAN(scat2gridgauss_yt_work_size)(int *);\nvoid FORTRAN(scat2gridgauss_yt_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(scat2gridgauss_zt_init)(int *);\nvoid FORTRAN(scat2gridgauss_zt_work_size)(int *);\nvoid FORTRAN(scat2gridgauss_zt_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(scat2gridgauss_xy_v0_init)(int *);\nvoid FORTRAN(scat2gridgauss_xy_v0_work_size)(int *);\nvoid FORTRAN(scat2gridgauss_xy_v0_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(scat2gridgauss_xz_v0_init)(int *);\nvoid FORTRAN(scat2gridgauss_xz_v0_work_size)(int *);\nvoid FORTRAN(scat2gridgauss_xz_v0_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(scat2gridgauss_yz_v0_init)(int *);\nvoid FORTRAN(scat2gridgauss_yz_v0_work_size)(int *);\nvoid FORTRAN(scat2gridgauss_yz_v0_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(scat2gridgauss_xt_v0_init)(int *);\nvoid FORTRAN(scat2gridgauss_xt_v0_work_size)(int *);\nvoid FORTRAN(scat2gridgauss_xt_v0_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(scat2gridgauss_yt_v0_init)(int *);\nvoid FORTRAN(scat2gridgauss_yt_v0_work_size)(int *);\nvoid FORTRAN(scat2gridgauss_yt_v0_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(scat2gridgauss_zt_v0_init)(int *);\nvoid FORTRAN(scat2gridgauss_zt_v0_work_size)(int *);\nvoid FORTRAN(scat2gridgauss_zt_v0_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(scat2gridlaplace_xy_init)(int *);\nvoid FORTRAN(scat2gridlaplace_xy_work_size)(int *);\nvoid FORTRAN(scat2gridlaplace_xy_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(scat2gridlaplace_xz_init)(int *);\nvoid FORTRAN(scat2gridlaplace_xz_work_size)(int *);\nvoid FORTRAN(scat2gridlaplace_xz_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(scat2gridlaplace_yz_init)(int *);\nvoid FORTRAN(scat2gridlaplace_yz_work_size)(int *);\nvoid FORTRAN(scat2gridlaplace_yz_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *, DFTYPE *);\n\n\nvoid FORTRAN(scat2gridlaplace_xt_init)(int *);\nvoid FORTRAN(scat2gridlaplace_xt_work_size)(int *);\nvoid FORTRAN(scat2gridlaplace_xt_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(scat2gridlaplace_yt_init)(int *);\nvoid FORTRAN(scat2gridlaplace_yt_work_size)(int *);\nvoid FORTRAN(scat2gridlaplace_yt_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(scat2gridlaplace_zt_init)(int *);\nvoid FORTRAN(scat2gridlaplace_zt_work_size)(int *);\nvoid FORTRAN(scat2gridlaplace_zt_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(sorti_init)(int *);\nvoid FORTRAN(sorti_result_limits)(int *);\nvoid FORTRAN(sorti_work_size)(int *);\nvoid FORTRAN(sorti_compute)(int *, DFTYPE *, DFTYPE *,\n      DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(sorti_str_init)(int *);\nvoid FORTRAN(sorti_str_result_limits)(int *);\nvoid FORTRAN(sorti_str_work_size)(int *);\nvoid FORTRAN(sorti_str_compute)(int *, char *, DFTYPE *,\n      char *, DFTYPE *);\n\nvoid FORTRAN(sortj_init)(int *);\nvoid FORTRAN(sortj_result_limits)(int *);\nvoid FORTRAN(sortj_work_size)(int *);\nvoid FORTRAN(sortj_compute)(int *, DFTYPE *, DFTYPE *,\n      DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(sortj_str_init)(int *);\nvoid FORTRAN(sortj_str_result_limits)(int *);\nvoid FORTRAN(sortj_str_work_size)(int *);\nvoid FORTRAN(sortj_str_compute)(int *, char *, DFTYPE *,\n      char *, DFTYPE *);\n\nvoid FORTRAN(sortk_init)(int *);\nvoid FORTRAN(sortk_result_limits)(int *);\nvoid FORTRAN(sortk_work_size)(int *);\nvoid FORTRAN(sortk_compute)(int *, DFTYPE *, DFTYPE *,\n      DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(sortk_str_init)(int *);\nvoid FORTRAN(sortk_str_result_limits)(int *);\nvoid FORTRAN(sortk_str_work_size)(int *);\nvoid FORTRAN(sortk_str_compute)(int *, char *, DFTYPE *,\n      char *, DFTYPE *);\n\nvoid FORTRAN(sortl_init)(int *);\nvoid FORTRAN(sortl_result_limits)(int *);\nvoid FORTRAN(sortl_work_size)(int *);\nvoid FORTRAN(sortl_compute)(int *, DFTYPE *, DFTYPE *,\n      DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(sortl_str_init)(int *);\nvoid FORTRAN(sortl_str_result_limits)(int *);\nvoid FORTRAN(sortl_str_work_size)(int *);\nvoid FORTRAN(sortl_str_compute)(int *, char *, DFTYPE *,\n      char *, DFTYPE *);\n\n\nvoid FORTRAN(sortm_init)(int *);\nvoid FORTRAN(sortm_result_limits)(int *);\nvoid FORTRAN(sortm_work_size)(int *);\nvoid FORTRAN(sortm_compute)(int *, DFTYPE *, DFTYPE *,\n      DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(sortm_str_init)(int *);\nvoid FORTRAN(sortm_str_result_limits)(int *);\nvoid FORTRAN(sortm_str_work_size)(int *);\nvoid FORTRAN(sortm_str_compute)(int *, char *, DFTYPE *,\n      char *, DFTYPE *);\n\n\nvoid FORTRAN(sortn_init)(int *);\nvoid FORTRAN(sortn_result_limits)(int *);\nvoid FORTRAN(sortn_work_size)(int *);\nvoid FORTRAN(sortn_compute)(int *, DFTYPE *, DFTYPE *,\n      DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(sortn_str_init)(int *);\nvoid FORTRAN(sortn_str_result_limits)(int *);\nvoid FORTRAN(sortn_str_work_size)(int *);\nvoid FORTRAN(sortn_str_compute)(int *, char *, DFTYPE *,\n      char *, DFTYPE *);\n\nvoid FORTRAN(tauto_cor_init)(int *);\nvoid FORTRAN(tauto_cor_result_limits)(int *);\nvoid FORTRAN(tauto_cor_work_size)(int *);\nvoid FORTRAN(tauto_cor_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(xauto_cor_init)(int *);\nvoid FORTRAN(xauto_cor_result_limits)(int *);\nvoid FORTRAN(xauto_cor_work_size)(int *);\nvoid FORTRAN(xauto_cor_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(eof_space_init)(int *);\nvoid FORTRAN(eof_space_result_limits)(int *);\nvoid FORTRAN(eof_space_work_size)(int *);\nvoid FORTRAN(eof_space_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(eof_stat_init)(int *);\nvoid FORTRAN(eof_stat_result_limits)(int *);\nvoid FORTRAN(eof_stat_work_size)(int *);\nvoid FORTRAN(eof_stat_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(eof_tfunc_init)(int *);\nvoid FORTRAN(eof_tfunc_result_limits)(int *);\nvoid FORTRAN(eof_tfunc_work_size)(int *);\nvoid FORTRAN(eof_tfunc_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(eofsvd_space_init)(int *);\nvoid FORTRAN(eofsvd_space_result_limits)(int *);\nvoid FORTRAN(eofsvd_space_work_size)(int *);\nvoid FORTRAN(eofsvd_space_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *);\n\nvoid FORTRAN(eofsvd_stat_init)(int *);\nvoid FORTRAN(eofsvd_stat_result_limits)(int *);\nvoid FORTRAN(eofsvd_stat_work_size)(int *);\nvoid FORTRAN(eofsvd_stat_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *);\n\nvoid FORTRAN(eofsvd_tfunc_init)(int *);\nvoid FORTRAN(eofsvd_tfunc_result_limits)(int *);\nvoid FORTRAN(eofsvd_tfunc_work_size)(int *);\nvoid FORTRAN(eofsvd_tfunc_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n                           DFTYPE *);\n\nvoid FORTRAN(compressi_init)(int *);\nvoid FORTRAN(compressi_result_limits)(int *);\nvoid FORTRAN(compressi_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(compressj_init)(int *);\nvoid FORTRAN(compressj_result_limits)(int *);\nvoid FORTRAN(compressj_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(compressk_init)(int *);\nvoid FORTRAN(compressk_result_limits)(int *);\nvoid FORTRAN(compressk_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(compressl_init)(int *);\nvoid FORTRAN(compressl_result_limits)(int *);\nvoid FORTRAN(compressl_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(compressm_init)(int *);\nvoid FORTRAN(compressm_result_limits)(int *);\nvoid FORTRAN(compressm_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(compressn_init)(int *);\nvoid FORTRAN(compressn_result_limits)(int *);\nvoid FORTRAN(compressn_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(compressi_by_init)(int *);\nvoid FORTRAN(compressi_by_result_limits)(int *);\nvoid FORTRAN(compressi_by_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(compressj_by_init)(int *);\nvoid FORTRAN(compressj_by_result_limits)(int *);\nvoid FORTRAN(compressj_by_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(compressk_by_init)(int *);\nvoid FORTRAN(compressk_by_result_limits)(int *);\nvoid FORTRAN(compressk_by_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(compressl_by_init)(int *);\nvoid FORTRAN(compressl_by_result_limits)(int *);\nvoid FORTRAN(compressl_by_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(compressm_by_init)(int *);\nvoid FORTRAN(compressm_by_result_limits)(int *);\nvoid FORTRAN(compressm_by_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(compressn_by_init)(int *);\nvoid FORTRAN(compressn_by_result_limits)(int *);\nvoid FORTRAN(compressn_by_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(box_edges_init)(int *);\nvoid FORTRAN(box_edges_result_limits)(int *);\nvoid FORTRAN(box_edges_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(labwid_init)(int *);\nvoid FORTRAN(labwid_result_limits)(int *);\nvoid FORTRAN(labwid_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(convolvei_init)(int *);\nvoid FORTRAN(convolvei_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(convolvej_init)(int *);\nvoid FORTRAN(convolvej_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(convolvek_init)(int *);\nvoid FORTRAN(convolvek_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(convolvel_init)(int *);\nvoid FORTRAN(convolvel_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(convolvem_init)(int *);\nvoid FORTRAN(convolvem_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(convolven_init)(int *);\nvoid FORTRAN(convolven_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(curv_range_init)(int *);\nvoid FORTRAN(curv_range_result_limits)(int *);\nvoid FORTRAN(curv_range_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(curv_to_rect_map_init)(int *);\nvoid FORTRAN(curv_to_rect_map_result_limits)(int *);\nvoid FORTRAN(curv_to_rect_map_work_size)(int *);\nvoid FORTRAN(curv_to_rect_map_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n                                       DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\nvoid FORTRAN(curv_to_rect_init)(int *);\nvoid FORTRAN(curv_to_rect_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(curv_to_rect_fsu_init)(int *);\nvoid FORTRAN(curv_to_rect_fsu_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(rect_to_curv_init)(int *);\nvoid FORTRAN(rect_to_curv_work_size)(int *);\nvoid FORTRAN(rect_to_curv_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n                                       DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(date1900_init)(int *);\nvoid FORTRAN(date1900_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(days1900toymdhms_init)(int *);\nvoid FORTRAN(days1900toymdhms_result_limits)(int *);\nvoid FORTRAN(days1900toymdhms_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(minutes24_init)(int *);\nvoid FORTRAN(minutes24_result_limits)(int *);\nvoid FORTRAN(minutes24_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(element_index_init)(int *);\nvoid FORTRAN(element_index_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(element_index_str_init)(int *);\nvoid FORTRAN(element_index_str_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(element_index_str_n_init)(int *);\nvoid FORTRAN(element_index_str_n_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(expnd_by_len_init)(int *);\nvoid FORTRAN(expnd_by_len_result_limits)(int *);\nvoid FORTRAN(expnd_by_len_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(expnd_by_len_str_init)(int *);\nvoid FORTRAN(expnd_by_len_str_result_limits)(int *);\nvoid FORTRAN(expnd_by_len_str_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(expndi_by_init)(int *);\nvoid FORTRAN(expndi_by_result_limits)(int *);\nvoid FORTRAN(expndi_by_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(expndi_by_t_init)(int *);\nvoid FORTRAN(expndi_by_t_result_limits)(int *);\nvoid FORTRAN(expndi_by_t_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(expndi_by_z_init)(int *);\nvoid FORTRAN(expndi_by_z_result_limits)(int *);\nvoid FORTRAN(expndi_by_z_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(expndi_by_z_counts_init)(int *);\nvoid FORTRAN(expndi_by_z_counts_result_limits)(int *);\nvoid FORTRAN(expndi_by_z_counts_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(expndi_id_by_z_counts_init)(int *);\nvoid FORTRAN(expndi_id_by_z_counts_result_limits)(int *);\nvoid FORTRAN(expndi_id_by_z_counts_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(expndi_by_m_counts_init)(int *);\nvoid FORTRAN(expndi_by_m_counts_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(expndi_by_m_counts_str_init)(int *);\nvoid FORTRAN(expndi_by_m_counts_str_compute)(int *, char, DFTYPE *, DFTYPE *, DFTYPE *, char);\n\nvoid FORTRAN(fc_isubset_init)(int *);\nvoid FORTRAN(fc_isubset_result_limits)(int *);\nvoid FORTRAN(fc_isubset_custom_axes)(int *);\nvoid FORTRAN(fc_isubset_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(findhi_init)(int *);\nvoid FORTRAN(findhi_result_limits)(int *);\nvoid FORTRAN(findhi_work_size)(int *);\nvoid FORTRAN(findhi_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n                            DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(findlo_init)(int *);\nvoid FORTRAN(findlo_result_limits)(int *);\nvoid FORTRAN(findlo_work_size)(int *);\nvoid FORTRAN(findlo_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n                            DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(is_element_of_init)(int *);\nvoid FORTRAN(is_element_of_result_limits)(int *);\nvoid FORTRAN(is_element_of_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(is_element_of_str_init)(int *);\nvoid FORTRAN(is_element_of_str_result_limits)(int *);\nvoid FORTRAN(is_element_of_str_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *);\n\n\nvoid FORTRAN(is_element_of_str_n_init)(int *);\nvoid FORTRAN(is_element_of_str_n_result_limits)(int *);\nvoid FORTRAN(is_element_of_str_n_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(lanczos_init)(int *);\nvoid FORTRAN(lanczos_work_size)(int *);\nvoid FORTRAN(lanczos_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n                            DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(lsl_lowpass_init)(int *);\nvoid FORTRAN(lsl_lowpass_work_size)(int *);\nvoid FORTRAN(lsl_lowpass_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n                            DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(samplexy_curv_init)(int *);\nvoid FORTRAN(samplexy_curv_result_limits)(int *);\nvoid FORTRAN(samplexy_curv_work_size)(int *);\nvoid FORTRAN(samplexy_curv_compute)(int *, DFTYPE *, DFTYPE *,\n      DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(samplexy_curv_avg_init)(int *);\nvoid FORTRAN(samplexy_curv_avg_result_limits)(int *);\nvoid FORTRAN(samplexy_curv_avg_work_size)(int *);\nvoid FORTRAN(samplexy_curv_avg_compute)(int *, DFTYPE *, DFTYPE *,\n      DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(samplexy_curv_nrst_init)(int *);\nvoid FORTRAN(samplexy_curv_nrst_result_limits)(int *);\nvoid FORTRAN(samplexy_curv_nrst_work_size)(int *);\nvoid FORTRAN(samplexy_curv_nrst_compute)(int *, DFTYPE *, DFTYPE *,\n      DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(samplexy_closest_init)(int *);\nvoid FORTRAN(samplexy_closest_result_limits)(int *);\nvoid FORTRAN(samplexy_closest_work_size)(int *);\nvoid FORTRAN(samplexy_closest_compute)(int *, DFTYPE *, DFTYPE *,\n      DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(samplexy_nrst_init)(int *);\nvoid FORTRAN(samplexy_nrst_result_limits)(int *);\nvoid FORTRAN(samplexy_nrst_work_size)(int *);\nvoid FORTRAN(samplexy_nrst_compute)(int *, DFTYPE *, DFTYPE *,\n      DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(samplexz_init)(int *);\nvoid FORTRAN(samplexz_result_limits)(int *);\nvoid FORTRAN(samplexz_work_size)(int *);\nvoid FORTRAN(samplexz_compute)(int *, DFTYPE *, DFTYPE *,\n      DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(sampleyz_init)(int *);\nvoid FORTRAN(sampleyz_result_limits)(int *);\nvoid FORTRAN(sampleyz_work_size)(int *);\nvoid FORTRAN(sampleyz_compute)(int *, DFTYPE *, DFTYPE *,\n      DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(scat2ddups_init)(int *);\nvoid FORTRAN(scat2ddups_result_limits)(int *);\nvoid FORTRAN(scat2ddups_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(ave_scat2grid_t_init)(int *);\nvoid FORTRAN(ave_scat2grid_t_work_size)(int *);\nvoid FORTRAN(ave_scat2grid_t_compute)(int *, DFTYPE *, DFTYPE *,\n      DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(scat2grid_t_init)(int *);\nvoid FORTRAN(scat2grid_t_work_size)(int *);\nvoid FORTRAN(scat2grid_t_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(transpose_ef_init)(int *);\nvoid FORTRAN(transpose_ef_result_limits)(int *);\nvoid FORTRAN(transpose_ef_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(transpose_te_init)(int *);\nvoid FORTRAN(transpose_te_result_limits)(int *);\nvoid FORTRAN(transpose_te_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(transpose_tf_init)(int *);\nvoid FORTRAN(transpose_tf_result_limits)(int *);\nvoid FORTRAN(transpose_tf_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(transpose_xe_init)(int *);\nvoid FORTRAN(transpose_xe_result_limits)(int *);\nvoid FORTRAN(transpose_xe_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(transpose_xf_init)(int *);\nvoid FORTRAN(transpose_xf_result_limits)(int *);\nvoid FORTRAN(transpose_xf_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(transpose_xt_init)(int *);\nvoid FORTRAN(transpose_xt_result_limits)(int *);\nvoid FORTRAN(transpose_xt_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(transpose_xy_init)(int *);\nvoid FORTRAN(transpose_xy_result_limits)(int *);\nvoid FORTRAN(transpose_xy_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(transpose_xz_init)(int *);\nvoid FORTRAN(transpose_xz_result_limits)(int *);\nvoid FORTRAN(transpose_xz_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(transpose_ye_init)(int *);\nvoid FORTRAN(transpose_ye_result_limits)(int *);\nvoid FORTRAN(transpose_ye_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(transpose_yf_init)(int *);\nvoid FORTRAN(transpose_yf_result_limits)(int *);\nvoid FORTRAN(transpose_yf_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(transpose_yt_init)(int *);\nvoid FORTRAN(transpose_yt_result_limits)(int *);\nvoid FORTRAN(transpose_yt_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(transpose_yz_init)(int *);\nvoid FORTRAN(transpose_yz_result_limits)(int *);\nvoid FORTRAN(transpose_yz_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(transpose_ze_init)(int *);\nvoid FORTRAN(transpose_ze_result_limits)(int *);\nvoid FORTRAN(transpose_ze_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(transpose_zf_init)(int *);\nvoid FORTRAN(transpose_zf_result_limits)(int *);\nvoid FORTRAN(transpose_zf_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(transpose_zt_init)(int *);\nvoid FORTRAN(transpose_zt_result_limits)(int *);\nvoid FORTRAN(transpose_zt_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(xcat_init)(int *);\nvoid FORTRAN(xcat_result_limits)(int *);\nvoid FORTRAN(xcat_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(xcat_str_init)(int *);\nvoid FORTRAN(xcat_str_result_limits)(int *);\nvoid FORTRAN(xcat_str_compute)(int *, char *, char *, char *);\n\nvoid FORTRAN(ycat_init)(int *);\nvoid FORTRAN(ycat_result_limits)(int *);\nvoid FORTRAN(ycat_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(ycat_str_init)(int *);\nvoid FORTRAN(ycat_str_result_limits)(int *);\nvoid FORTRAN(ycat_str_compute)(int *, char *, char *, char *);\n\nvoid FORTRAN(zcat_init)(int *);\nvoid FORTRAN(zcat_result_limits)(int *);\nvoid FORTRAN(zcat_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(zcat_str_init)(int *);\nvoid FORTRAN(zcat_str_result_limits)(int *);\nvoid FORTRAN(zcat_str_compute)(int *, char *, char *, char *);\n\nvoid FORTRAN(tcat_init)(int *);\nvoid FORTRAN(tcat_result_limits)(int *);\nvoid FORTRAN(tcat_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(tcat_str_init)(int *);\nvoid FORTRAN(tcat_str_result_limits)(int *);\nvoid FORTRAN(tcat_str_compute)(int *, char *, char *, char *);\n\nvoid FORTRAN(ecat_init)(int *);\nvoid FORTRAN(ecat_result_limits)(int *);\nvoid FORTRAN(ecat_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(ecat_str_init)(int *);\nvoid FORTRAN(ecat_str_result_limits)(int *);\nvoid FORTRAN(ecat_str_compute)(int *, char *, char *, char *);\n\nvoid FORTRAN(fcat_init)(int *);\nvoid FORTRAN(fcat_result_limits)(int *);\nvoid FORTRAN(fcat_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(fcat_str_init)(int *);\nvoid FORTRAN(fcat_str_result_limits)(int *);\nvoid FORTRAN(fcat_str_compute)(int *, char *, char *, char *);\n\nvoid FORTRAN(xreverse_init)(int *);\nvoid FORTRAN(xreverse_result_limits)(int *);\nvoid FORTRAN(xreverse_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(yreverse_init)(int *);\nvoid FORTRAN(yreverse_result_limits)(int *);\nvoid FORTRAN(yreverse_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(zreverse_init)(int *);\nvoid FORTRAN(zreverse_result_limits)(int *);\nvoid FORTRAN(zreverse_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(treverse_init)(int *);\nvoid FORTRAN(treverse_result_limits)(int *);\nvoid FORTRAN(treverse_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(ereverse_init)(int *);\nvoid FORTRAN(ereverse_result_limits)(int *);\nvoid FORTRAN(ereverse_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(freverse_init)(int *);\nvoid FORTRAN(freverse_result_limits)(int *);\nvoid FORTRAN(freverse_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(zaxreplace_avg_init)(int *);\nvoid FORTRAN(zaxreplace_avg_work_size)(int *);\nvoid FORTRAN(zaxreplace_avg_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *,\n             DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(zaxreplace_bin_init)(int *);\nvoid FORTRAN(zaxreplace_bin_work_size)(int *);\nvoid FORTRAN(zaxreplace_bin_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *,\n             DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(zaxreplace_rev_init)(int *);\nvoid FORTRAN(zaxreplace_rev_work_size)(int *);\nvoid FORTRAN(zaxreplace_rev_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *,\n             DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(zaxreplace_zlev_init)(int *);\nvoid FORTRAN(zaxreplace_zlev_work_size)(int *);\nvoid FORTRAN(zaxreplace_zlev_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(nco_attr_init)(int *);\nvoid FORTRAN(nco_attr_result_limits)(int *);\nvoid FORTRAN(nco_attr_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(nco_init)(int *);\nvoid FORTRAN(nco_result_limits)(int *);\nvoid FORTRAN(nco_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(tax_datestring_init)(int *);\nvoid FORTRAN(tax_datestring_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(tax_day_init)(int *);\nvoid FORTRAN(tax_day_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(tax_dayfrac_init)(int *);\nvoid FORTRAN(tax_dayfrac_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(tax_jday1900_init)(int *);\nvoid FORTRAN(tax_jday1900_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(tax_jday_init)(int *);\nvoid FORTRAN(tax_jday_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(tax_month_init)(int *);\nvoid FORTRAN(tax_month_work_size)(int *);\nvoid FORTRAN(tax_month_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(tax_times_init)(int *);\nvoid FORTRAN(tax_times_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(tax_tstep_init)(int *);\nvoid FORTRAN(tax_tstep_work_size)(int *);\nvoid FORTRAN(tax_tstep_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(tax_units_init)(int *);\nvoid FORTRAN(tax_units_compute)(int *, DFTYPE *, DFTYPE*);\n\nvoid FORTRAN(tax_year_init)(int *);\nvoid FORTRAN(tax_year_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(tax_yearfrac_init)(int *);\nvoid FORTRAN(tax_yearfrac_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(fill_xy_init)(int *);\nvoid FORTRAN(fill_xy_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(test_opendap_init)(int *);\nvoid FORTRAN(test_opendap_result_limits)(int *);\nvoid FORTRAN(test_opendap_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(scat2grid_bin_xy_init)(int *);\nvoid FORTRAN(scat2grid_bin_xy_work_size)(int *);\nvoid FORTRAN(scat2grid_bin_xy_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(scat2grid_bin_xyt_init)(int *);\nvoid FORTRAN(scat2grid_bin_xyt_work_size)(int *);\nvoid FORTRAN(scat2grid_bin_xyt_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *,\n  DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n  DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(scat2grid_bin_xyz_init)(int *);\nvoid FORTRAN(scat2grid_bin_xyz_work_size)(int *);\nvoid FORTRAN(scat2grid_bin_xyz_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *,\n  DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n  DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(scat2grid_bin_xyzt_init)(int *);\nvoid FORTRAN(scat2grid_bin_xyzt_work_size)(int *);\nvoid FORTRAN(scat2grid_bin_xyzt_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *,\n  DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n  DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(scat2grid_nbin_xy_init)(int *);\nvoid FORTRAN(scat2grid_nbin_xy_work_size)(int *);\nvoid FORTRAN(scat2grid_nbin_xy_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(scat2grid_nbin_xyt_init)(int *);\nvoid FORTRAN(scat2grid_nbin_xyt_work_size)(int *);\nvoid FORTRAN(scat2grid_nbin_xyt_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *,\n  DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n  DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(scat2grid_nobs_xyt_init)(int *);\nvoid FORTRAN(scat2grid_nobs_xyt_work_size)(int *);\nvoid FORTRAN(scat2grid_nobs_xyt_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *,\n  DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n  DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(scat2grid_nobs_xy_init)(int *);\nvoid FORTRAN(scat2grid_nobs_xy_work_size)(int *);\nvoid FORTRAN(scat2grid_nobs_xy_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(unique_str2int_init)(int *);\nvoid FORTRAN(unique_str2int_compute)(char *, int *);\n\nvoid FORTRAN(bin_index_wt_init)(int *);\nvoid FORTRAN(bin_index_wt_result_limits)(int *);\nvoid FORTRAN(bin_index_wt_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(minmax_init)(int *);\nvoid FORTRAN(minmax_result_limits)(int *);\nvoid FORTRAN(minmax_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(floatstr_init)(int *);\nvoid FORTRAN(floatstr_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(pt_in_poly_init)(int *);\nvoid FORTRAN(pt_in_poly_work_size)(int *);\nvoid FORTRAN(pt_in_poly_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *,\n  DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(list_value_xml_init)(int *);\nvoid FORTRAN(list_value_xml_result_limits)(int *);\nvoid FORTRAN(list_value_xml_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(lon_lat_time_string_init)(int *);\nvoid FORTRAN(lon_lat_time_string_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, char *);\n\nvoid FORTRAN(write_webrow_init)(int *);\nvoid FORTRAN(write_webrow_result_limits)(int *);\nvoid FORTRAN(write_webrow_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(str_mask_init)(int *);\nvoid FORTRAN(str_mask_compute)(int *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(separate_init)(int *);\nvoid FORTRAN(separate_result_limits)(int *);\nvoid FORTRAN(separate_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(time_reformat_init)(int *);\nvoid FORTRAN(time_reformat_compute)(int *, char *);\n\nvoid FORTRAN(ft_to_orthogonal_init)(int *);\nvoid FORTRAN(ft_to_orthogonal_work_size)(int *);\nvoid FORTRAN(ft_to_orthogonal_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(separate_str_init)(int *);\nvoid FORTRAN(separate_str_result_limits)(int *);\nvoid FORTRAN(separate_str_compute)(int *, char *, DFTYPE *, DFTYPE *, char *);\n\nvoid FORTRAN(sample_fast_i_init)(int *);\nvoid FORTRAN(sample_fast_i_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(sample_fast_i_str_init)(int *);\nvoid FORTRAN(sample_fast_i_str_compute)(int *, char *, DFTYPE *, char *);\n\nvoid FORTRAN(piecewise3_init)(int *);\nvoid FORTRAN(piecewise3_result_limits)(int *);\nvoid FORTRAN(piecewise3_work_size)(int *);\nvoid FORTRAN(piecewise3_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n  DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n  DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(write_webrow_gwt_init)(int *);\nvoid FORTRAN(write_webrow_gwt_result_limits)(int *);\nvoid FORTRAN(write_webrow_gwt_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(str_noblanks_init)(int *);\nvoid FORTRAN(str_noblanks_compute)(int *, char *, char *);\n\nvoid FORTRAN(str_replace_init)(int *);\nvoid FORTRAN(str_replace_compute)(int *, char *, char *, char *, char *);\n\nvoid FORTRAN(expndi_to_et_init)(int *);\nvoid FORTRAN(expndi_to_et_work_size)(int *);\nvoid FORTRAN(expndi_to_et_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(dot_x_init)(int *);\nvoid FORTRAN(dot_x_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(dot_y_init)(int *);\nvoid FORTRAN(dot_y_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(dot_z_init)(int *);\nvoid FORTRAN(dot_z_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(dot_t_init)(int *);\nvoid FORTRAN(dot_t_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(dot_e_init)(int *);\nvoid FORTRAN(dot_e_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(dot_f_init)(int *);\nvoid FORTRAN(dot_f_compute)(int *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(tracks2grid_mask_ave_xyt_init)(int *);\nvoid FORTRAN(tracks2grid_mask_ave_xyt_work_size)(int *);\nvoid FORTRAN(tracks2grid_mask_ave_xyt_compute)(int *, DFTYPE *,\n  DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n  DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n  DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN( tracks2grid_std_xyt_init)(int *);\nvoid FORTRAN( tracks2grid_std_xyt_work_size)(int *);\nvoid FORTRAN( tracks2grid_std_xyt_compute)(int *,\n  DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n  DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n  DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\nvoid FORTRAN(scat2grid_minmax_xyt_init)(int *);\nvoid FORTRAN(scat2grid_minmax_xyt_result_limits)(int *);\nvoid FORTRAN(scat2grid_minmax_xyt_work_size)(int *);\nvoid FORTRAN(scat2grid_minmax_xyt_compute)(int *, DFTYPE *,\n  DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n  DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n  DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\n\nvoid FORTRAN( scat2grid_std_xyt_init)(int *);\nvoid FORTRAN( scat2grid_std_xyt_work_size)(int *);\nvoid FORTRAN( scat2grid_std_xyt_compute)(int *,\n  DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n  DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n  DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n/*\n *  End of declarations for internally linked external functions\n *  ------------------------------------ */\n\n\n/* .............. Function Definitions .............. */\n\n\n/* .... Functions for use by Ferret (to be called from Fortran) .... */\n\n/*\n * Note that all routines called directly from Ferret,\n * ie. directly from Fortran, should be all lower case,\n * should pass by reference and should end with an underscore.\n */\n\nstatic int continue_efcn_scan(int gfcn_num_internal);\n\n/*\n * Find all of the ~.so files in directories listed in the\n * FER_EXTERNAL_FUNCTIONS environment variable and add all\n * the names and associated directory information to the\n * STATIC_ExternalFunctionList.\n */\nint FORTRAN(efcn_scan)( int *gfcn_num_internal )\n{\n  int return_val;\n\n  /* Called multiple times but only do the setup once. */\n  if ( I_have_scanned_already ) {\n    return_val = list_size(STATIC_ExternalFunctionList);\n    return return_val;\n  }\n\n  return_val = continue_efcn_scan(*gfcn_num_internal);\n  if ( return_val >= 0 )\n      I_have_scanned_already = TRUE;\n  return return_val;\n}\n\n/*\n * Split out as a separate function to minimize cost of calls after scanned.\n */\nstatic int continue_efcn_scan(int gfcn_num_internal) {\n  FILE *file_ptr=NULL;\n  ExternalFunction ef;\n\n  char file[EF_MAX_NAME_LENGTH]=\"\";\n  char *path_ptr=NULL;\n  char path[8192]=\"\";\n  char allpaths[8192]=\"\";\n  char cmd[EF_MAX_DESCRIPTION_LENGTH]=\"\";\n  int  count=0;\n  int  i_intEF;\n  char *extension;\n\n  /* The array of names of the internally defined \"external functions\" defined here. */\n  const char I_EFnames[][EF_MAX_NAME_LENGTH] = {\n     \"ave_scat2grid_t\",\n     \"bin_index_wt\",\n     \"box_edges\",\n     \"compressi\",\n     \"compressi_by\",\n     \"compressj\",\n     \"compressj_by\",\n     \"compressk\",\n     \"compressk_by\",\n     \"compressl\",\n     \"compressl_by\",\n     \"compressm\",\n     \"compressm_by\",\n     \"compressn\",\n     \"compressn_by\",\n     \"convolvei\",\n     \"convolvej\",\n     \"convolvek\",\n     \"convolvel\",\n     \"convolvem\",\n     \"convolven\",\n     \"curv_range\",\n     \"curv_to_rect\",\n     \"curv_to_rect_fsu\",\n     \"curv_to_rect_map\",\n     \"date1900\",\n     \"days1900toymdhms\",\n     \"dot_e\",\n     \"dot_f\",\n     \"dot_t\",\n     \"dot_x\",\n     \"dot_y\",\n     \"dot_z\",\n     \"ecat\",\n     \"ecat_str\",\n     \"element_index\",\n     \"element_index_str\",\n     \"element_index_str_n\",\n     \"eof_space\",\n     \"eof_stat\",\n     \"eofsvd_space\",\n     \"eofsvd_stat\",\n     \"eofsvd_tfunc\",\n     \"eof_tfunc\",\n     \"ereverse\",\n     \"expnd_by_len\",\n     \"expnd_by_len_str\",\n     \"expndi_by\",\n     \"expndi_by_m_counts\",\n     \"expndi_by_m_counts_str\",\n     \"expndi_by_t\",\n     \"expndi_by_z\",\n     \"expndi_by_z_counts\",\n     \"expndi_id_by_z_counts\",\n     \"expndi_to_et\",\n     \"fcat\",\n     \"fcat_str\",\n     \"fc_isubset\",\n     \"ffta\",\n     \"fft_im\",\n     \"fft_inverse\",\n     \"fftp\",\n     \"fft_re\",\n     \"fill_xy\",\n     \"findhi\",\n     \"findlo\",\n     \"floatstr\",\n     \"freverse\",\n     \"ft_to_orthogonal\",\n     \"is_element_of\",\n     \"is_element_of_str\",\n     \"is_element_of_str_n\",\n     \"labwid\",\n     \"lanczos\",\n     \"list_value_xml\",\n     \"lon_lat_time_string\",\n     \"lsl_lowpass\",\n     \"minmax\",\n     \"minutes24\",\n     \"nco\",\n     \"nco_attr\",\n     \"piecewise3\",\n     \"pt_in_poly\",\n     \"rect_to_curv\",\n     \"sample_fast_i\",\n     \"sample_fast_i_str\",\n     \"samplef_date\",\n     \"sampleij\",\n     \"samplei_multi\",\n     \"samplej_multi\",\n     \"samplek_multi\",\n     \"samplel_multi\",\n     \"samplem_multi\",\n     \"samplen_multi\",\n     \"samplet_date\",\n     \"samplexy\",\n     \"samplexy_closest\",\n     \"samplexy_curv\",\n     \"samplexy_curv_avg\",\n     \"samplexy_curv_nrst\",\n     \"samplexy_nrst\",\n     \"samplexyt\",\n     \"samplexyt_nrst\",\n     \"samplexz\",\n     \"sampleyz\",\n     \"scat2ddups\",\n     \"scat2grid_bin_xy\",\n     \"scat2grid_bin_xyt\",\n     \"scat2grid_bin_xyz\",\n     \"scat2grid_bin_xyzt\",\n     \"scat2grid_minmax_xyt\",\n     \"scat2grid_std_xyt\",\n     \"scat2gridgauss_xt\",\n     \"scat2gridgauss_xt_v0\",\n     \"scat2gridgauss_xy\",\n     \"scat2gridgauss_xy_v0\",\n     \"scat2gridgauss_xz\",\n     \"scat2gridgauss_xz_v0\",\n     \"scat2gridgauss_yt\",\n     \"scat2gridgauss_yt_v0\",\n     \"scat2gridgauss_yz\",\n     \"scat2gridgauss_yz_v0\",\n     \"scat2gridgauss_zt\",\n     \"scat2gridgauss_zt_v0\",\n     \"scat2gridlaplace_xt\",\n     \"scat2gridlaplace_xy\",\n     \"scat2gridlaplace_xz\",\n     \"scat2gridlaplace_yt\",\n     \"scat2gridlaplace_yz\",\n     \"scat2gridlaplace_zt\",\n     \"scat2grid_nbin_xy\",\n     \"scat2grid_nbin_xyt\",\n     \"scat2grid_nobs_xy\",\n     \"scat2grid_nobs_xyt\",\n     \"scat2grid_t\",\n     \"separate\",\n     \"separate_str\",\n     \"sorti\",\n     \"sorti_str\",\n     \"sortj\",\n     \"sortj_str\",\n     \"sortk\",\n     \"sortk_str\",\n     \"sortl\",\n     \"sortl_str\",\n     \"sortm\",\n     \"sortm_str\",\n     \"sortn\",\n     \"sortn_str\",\n     \"str_mask\",\n     \"str_noblanks\",\n     \"str_replace\",\n     \"tauto_cor\",\n     \"tax_datestring\",\n     \"tax_day\",\n     \"tax_dayfrac\",\n     \"tax_jday\",\n     \"tax_jday1900\",\n     \"tax_month\",\n     \"tax_times\",\n     \"tax_tstep\",\n     \"tax_units\",\n     \"tax_year\",\n     \"tax_yearfrac\",\n     \"tcat\",\n     \"tcat_str\",\n     \"test_opendap\",\n     \"time_reformat\",\n     \"tracks2grid_mask_ave_xyt\",\n     \"tracks2grid_std_xyt\",\n     \"transpose_ef\",\n     \"transpose_te\",\n     \"transpose_tf\",\n     \"transpose_xe\",\n     \"transpose_xf\",\n     \"transpose_xt\",\n     \"transpose_xy\",\n     \"transpose_xz\",\n     \"transpose_ye\",\n     \"transpose_yf\",\n     \"transpose_yt\",\n     \"transpose_yz\",\n     \"transpose_ze\",\n     \"transpose_zf\",\n     \"transpose_zt\",\n     \"treverse\",\n     \"unique_str2int\",\n     \"write_webrow\",\n     \"write_webrow_gwt\",\n     \"xauto_cor\",\n     \"xcat\",\n     \"xcat_str\",\n     \"xreverse\",\n     \"ycat\",\n     \"ycat_str\",\n     \"yreverse\",\n     \"zaxreplace_avg\",\n     \"zaxreplace_bin\",\n     \"zaxreplace_rev\",\n     \"zaxreplace_zlev\",\n     \"zcat\",\n     \"zcat_str\",\n     \"zreverse\"\n  };\n  /* The number of names in the array above */\n  int N_INTEF = sizeof(I_EFnames) / EF_MAX_NAME_LENGTH;\n\n  if ( (STATIC_ExternalFunctionList = list_init(__FILE__, __LINE__)) == NULL ) {\n    fputs(\"**ERROR: efcn_scan: Unable to initialize STATIC_ExternalFunctionList.\\n\", stderr);\n    return -1;\n  }\n\n  /*\n   * Get internally linked external functions;  and add all\n   * the names and associated directory information to the\n   * STATIC_ExternalFunctionList.\n   */\n  for (i_intEF = 0; i_intEF < N_INTEF; i_intEF++ ) {\n      strcpy(ef.path, \"internally_linked\");\n      strcpy(ef.name, I_EFnames[i_intEF]);\n      ef.id = gfcn_num_internal + ++count; /* pre-increment because F arrays start at 1 */\n      ef.already_have_internals = NO;\n      ef.internals_ptr = NULL;\n      list_insert_after(STATIC_ExternalFunctionList, (char *) &ef, sizeof(ExternalFunction), __FILE__, __LINE__);\n  }\n\n  /*\n   * - Get all the paths from the \"FER_EXTERNAL_FUNCTIONS\" environment variable.\n   *\n   * - While there is another path:\n   *    - get the path;\n   *    - create a pipe for the \"ls -1\" command;\n   *    - read stdout and use each file name to create another external function entry;\n   *\n   */\n\n  path_ptr = getenv(\"FER_EXTERNAL_FUNCTIONS\");\n  if ( path_ptr == NULL ) {\n    /* fprintf(stderr, \"\\nWARNING: environment variable FER_EXTERNAL_FUNCTIONS not defined.\\n\\n\"); */\n    /* *kob* v5.32 - the return val was set to 0 below but that was wrong.\n       That didn't take into account that on any system, the\n       FER_EXTERNAL_FUNCTIONS env variable might not be set.  If that were the\n       case, a core dump occurred on all systems.  Set return_val to count,\n       which was generated above - also have to  note that the ef's\n       have been scanned*/\n    return count;\n  }\n\n  strcpy(allpaths, path_ptr);\n  path_ptr = strtok(allpaths, \" \\t\");\n  if ( path_ptr == NULL ) {\n\n    /* fprintf(stderr, \"\\nWARNING:No paths were found in the environment variable FER_EXTERNAL_FUNCTIONS.\\n\\n\"); */\n    return count;\n\n  } else {\n\n    do {\n      strcpy(path, path_ptr);\n      if (path[strlen(path)-1] != '/')\n        strcat(path, \"/\");\n\n      sprintf(cmd, \"ls -1 %s\", path);\n\n      /* Open a pipe to the \"ls\" command */\n      if ( (file_ptr = popen(cmd, \"r\")) == (FILE *) NULL ) {\n         fputs(\"**ERROR: Cannot open pipe.\\n\", stderr);\n         return -1;\n      }\n\n      /*\n       * Read a line at a time.\n       * Any ~.so files are assumed to be external functions.\n       */\n      while ( fgets(file, EF_MAX_NAME_LENGTH, file_ptr) != NULL ) {\n\n         extension = &(file[strlen(file)-1]);\n         while ( isspace(*extension) ) {\n            *extension = '\\0';   /* chop off the carriage return (or CR-LF) */\n            extension--;\n         }\n         extension--;\n         extension--;\n         if ( strcmp(extension, \".so\") == 0 ) {\n            *extension = '\\0'; /* chop off the \".so\" */\n            strcpy(ef.path, path);\n            strcpy(ef.name, file);\n            ef.id = gfcn_num_internal + ++count; /* pre-increment because F arrays start at 1 */\n            ef.already_have_internals = NO;\n            ef.internals_ptr = NULL;\n            list_insert_after(STATIC_ExternalFunctionList, (char *) &ef, sizeof(ExternalFunction), __FILE__, __LINE__);\n         }\n      }\n\n      pclose(file_ptr);\n\n      path_ptr = strtok(NULL, \" \\t\"); /* get the next directory */\n    } while ( path_ptr != NULL );\n\n  }\n\n  return count;\n}\n\n/*\n * Clears and frees all memory associated with the given ef pointed to by data\n */\nstatic void efcn_dealloc_ef(char *data) {\n  ExternalFunction *ef_ptr = (ExternalFunction *)data;\n  if ( ef_ptr->internals_ptr != NULL ) {\n      /* paranoia */\n      memset(ef_ptr->internals_ptr, 0, sizeof(ExternalFunctionInternals));\n      FerMem_Free(ef_ptr->internals_ptr, __FILE__, __LINE__);\n  }\n  /* paranoia */\n  memset(ef_ptr, 0, sizeof(ExternalFunction));\n  FerMem_Free(ef_ptr, __FILE__, __LINE__);\n}\n\nvoid FORTRAN(efcn_list_clear)(void)\n{\n  if ( STATIC_ExternalFunctionList != NULL ) {\n      /* free all the elements in the list and the list itseld */\n      list_free(STATIC_ExternalFunctionList, efcn_dealloc_ef, __FILE__, __LINE__);\n      STATIC_ExternalFunctionList = NULL;\n  }\n  I_have_scanned_already = FALSE;\n}\n\n/*\n * Determine whether an external function has already\n * had its internals read.\n */\nint FORTRAN(efcn_already_have_internals)( int *id_ptr )\n{\n  ExternalFunction *ef_ptr;\n  int return_val;\n\n  ef_ptr = ef_ptr_from_id_ptr(id_ptr);\n  if ( ef_ptr == NULL ) {\n     return 0;\n  }\n\n  return_val = ef_ptr->already_have_internals;\n  return return_val;\n}\n\n\n\n/*\n * Create a new python-backed external function.  The initialization of\n * this function is done at this time to ensure that the python module is\n * valid and contains suitable functions.  Initialization is accomplished\n * using generic wrapper functions.  These functions are in an external\n * shared-object library $FER_LIBS/libpyefcn.so to avoid requiring\n * a shared-object python library for ferret-users who do not use python-\n * backed external functions.\n * Input arguments:\n *    fname - name for the function\n *    lenfname - actual length of the name in fname\n *    pymod - name of the python module suitable for a python import statement\n *            (eg, \"package.subpackage.module\")\n *    lenpymod - actual length of the name in pymod\n * Output arguments:\n *    errstring - error message if something went wrong\n *    lenerrstring - actual length of the string returned in errstring\n * The value of lenerrstring will be zero if and only if there were no errors\n *\n * Note: this function assume Hollerith strings are passed as character arrays\n *       (and max lengths appended as ints to the end of the argument list -\n *        they are not listed here since unused; also permits saying the strings\n *        are simple arrays in Fortran)\n */\nvoid FORTRAN(create_pyefcn)(char fname[], int *lenfname, char pymod[], int *lenpymod,\n                            char errstring[], int *lenerrstring)\n{\n    ExternalFunction ef;\n    ExternalFunction *ef_ptr;\n    char libname[1024];\n\n    /* Load $FER_LIBS/libpyefcn.so if not already in memory */\n    if ( pyefcn_handle == NULL ) {\n        char *fer_dir;\n\n        fer_dir = getenv(\"FER_LIBS\");\n        if ( fer_dir == NULL ) {\n            strcpy(errstring, \"FER_LIBS not defined\");\n            *lenerrstring = strlen(errstring);\n            return;\n        }\n        strcpy(libname, fer_dir);\n        strcat(libname, \"/libpyefcn.so\");\n        pyefcn_handle = dlopen(libname, RTLD_LAZY);\n        if ( pyefcn_handle == NULL ) {\n            sprintf(errstring, \"Python-backed external functions not supported \\n\"\n                            \"(unable to load $FER_LIBS/libpyefcn.so: %s)\", dlerror());\n            *lenerrstring = strlen(errstring);\n            return;\n        }\n    }\n\n    /* Find the pyefcn_init function in $FER_LIBS/libpyefcn.so */\n    if ( pyefcn_init_func == NULL ) {\n        pyefcn_init_func = (void (*)(int, char [], char []))dlsym(pyefcn_handle, \"pyefcn_init\");\n        if ( pyefcn_init_func == NULL ) {\n            sprintf(errstring, \"Python-backed external functions not supported \\n\"\n                            \"(unable to find pyefcn_init in $FER_LIBS/libpyefcn.so: %s)\", dlerror());\n            *lenerrstring = strlen(errstring);\n            return;\n        }\n    }\n\n    /* Check string lengths since these values might possibly be exceeded */\n    if ( *lenpymod >= EF_MAX_DESCRIPTION_LENGTH ) {\n        sprintf(errstring, \"Module name too long (must be less than %d characters)\", EF_MAX_DESCRIPTION_LENGTH);\n        *lenerrstring = strlen(errstring);\n        return;\n    }\n    if ( *lenfname >= EF_MAX_NAME_LENGTH ) {\n        sprintf(errstring, \"Function name too long (must be less than %d characters)\", EF_MAX_NAME_LENGTH);\n        *lenerrstring = strlen(errstring);\n        return;\n    }\n\n    /*\n     * Assign the local ExternalFunction structure, assigning the module name to the path element\n     * Get the ID for this new function by adding one to the ID of the last element in the list.\n     * (The IDs do not match the size of the list.)\n     */\n    ef.handle = NULL;\n    ef_ptr = (ExternalFunction *) list_rear(STATIC_ExternalFunctionList);\n    ef.id = ef_ptr->id + 1;\n    strncpy(ef.name, fname, *lenfname);\n    ef.name[*lenfname] = '\\0';\n    strncpy(ef.path, pymod, *lenpymod);\n    ef.path[*lenpymod] = '\\0';\n    ef.already_have_internals = FALSE;\n    ef.internals_ptr = NULL;\n\n    /* Add a copy of this ExternalFunction to the end of the global list of external functions */\n    list_mvrear(STATIC_ExternalFunctionList);\n    ef_ptr = (ExternalFunction *)list_insert_after(STATIC_ExternalFunctionList, (char *) &ef, sizeof(ExternalFunction), __FILE__, __LINE__);\n\n    /* Allocate and initialize the internals data for this ExternalFunction in the list */\n    if ( EF_New(ef_ptr) != 0 ) {\n        strcpy(errstring, \"Unable to allocate memory for the internals data in create_pyefcn\");\n        *lenerrstring = strlen(errstring);\n        return;\n    }\n    ef_ptr->internals_ptr->language = EF_PYTHON;\n    ef_ptr->already_have_internals = TRUE;\n\n    /*\n     * Prepare for bailout possibilities by setting a signal handler for\n     * SIGFPE, SIGSEGV, SIGINT and SIGBUS and then by cacheing the stack\n     * environment with sigsetjmp (for the signal handler) and setjmp\n     * (for the \"bail out\" utility function).\n     */\n    if ( EF_Util_setsig(\"create_pyefcn\")) {\n        list_remove_rear(STATIC_ExternalFunctionList, __FILE__, __LINE__);\n        FerMem_Free(ef_ptr->internals_ptr, __FILE__, __LINE__);\n        FerMem_Free(ef_ptr, __FILE__, __LINE__);\n        strcpy(errstring, \"Unable to set signal handlers in create_pyefcn\");\n        *lenerrstring = strlen(errstring);\n        return;\n    }\n    if (sigsetjmp(sigjumpbuffer, 1) != 0) {\n        list_remove_rear(STATIC_ExternalFunctionList, __FILE__, __LINE__);\n        FerMem_Free(ef_ptr->internals_ptr, __FILE__, __LINE__);\n        FerMem_Free(ef_ptr, __FILE__, __LINE__);\n        strcpy(errstring, \"Signal caught in create_pyefcn\");\n        *lenerrstring = strlen(errstring);\n        return;\n    }\n    if (setjmp(jumpbuffer) != 0) {\n        list_remove_rear(STATIC_ExternalFunctionList, __FILE__, __LINE__);\n        FerMem_Free(ef_ptr->internals_ptr, __FILE__, __LINE__);\n        FerMem_Free(ef_ptr, __FILE__, __LINE__);\n        strcpy(errstring, \"ef_bail_out called in create_pyefcn\");\n        *lenerrstring = strlen(errstring);\n        return;\n    }\n    canjump = 1;\n\n    (*pyefcn_init_func)(ef_ptr->id, ef_ptr->path, errstring);\n\n    /* Restore the old signal handlers. */\n    EF_Util_ressig(\"create_pyefcn\");\n\n    *lenerrstring = strlen(errstring);\n    if ( *lenerrstring > 0 ) {\n        list_remove_rear(STATIC_ExternalFunctionList, __FILE__, __LINE__);\n        FerMem_Free(ef_ptr->internals_ptr, __FILE__, __LINE__);\n        FerMem_Free(ef_ptr, __FILE__, __LINE__);\n    }\n    return;\n}\n\n\n\n/*\n * Find an external function based on its integer ID and\n * gather information describing the function.\n *\n * Return values:\n *     -1: error occurred, dynamic linking was unsuccessful\n *      0: success\n */\nint FORTRAN(efcn_gather_info)( int *id_ptr )\n{\n  ExternalFunction *ef_ptr;\n  int internally_linked;\n  char tempText[1024];\n  ExternalFunctionInternals *i_ptr;\n  void (*f_init_ptr)(int *);\n\n   /*\n    * Find the external function.\n    */\n   ef_ptr = ef_ptr_from_id_ptr(id_ptr);\n   if ( ef_ptr == NULL ) {\n      fprintf(stderr, \"**ERROR: No external function of id %d was found.\\n\", *id_ptr);\n      return -1;\n   }\n   /* Check if this has already been done */\n   if (ef_ptr->already_have_internals)  {\n      return 0;\n   }\n   /* Check if this is an internal function */\n   if ( strcmp(ef_ptr->path,\"internally_linked\") == 0 )\n      internally_linked = TRUE;\n   else\n      internally_linked = FALSE;\n\n   /* Get a handle for the shared object if not internally linked */\n   if ( ! internally_linked ) {\n      strcpy(tempText, ef_ptr->path);\n      strcat(tempText, ef_ptr->name);\n      strcat(tempText, \".so\");\n\n      if ( (ef_ptr->handle = dlopen(tempText, RTLD_LAZY)) == NULL ) {\n         fprintf(stderr, \"**ERROR in External Function %s:\\n\"\n                         \"  Dynamic linking call dlopen() returns --\\n\"\n                         \"  \\\"%s\\\".\\n\", ef_ptr->name, dlerror());\n         return -1;\n      }\n   }\n\n   /* Allocate and default initialize the internal information. */\n   if ( EF_New(ef_ptr) != 0 )\n      return -1;\n\n   /* Call the external function initialization routine */\n   i_ptr = ef_ptr->internals_ptr;\n\n   if ( i_ptr->language == EF_F ) {\n\n      /*\n       * Prepare for bailout possibilities by setting a signal handler for\n       * SIGFPE, SIGSEGV, SIGINT and SIGBUS and then by cacheing the stack\n       * environment with sigsetjmp (for the signal handler) and setjmp\n       * (for the \"bail out\" utility function).\n       */\n      if ( EF_Util_setsig(\"efcn_gather_info\")) {\n         return -1;\n      }\n\n      /* Set the signal return location and process jumps */\n      if ( sigsetjmp(sigjumpbuffer, 1) != 0 ) {\n         /* Must have come from bailing out */\n         return -1;\n      }\n      /* Set the bail out return location and process jumps */\n      if ( setjmp(jumpbuffer) != 0 ) {\n         /* Must have come from bailing out */\n         return -1;\n      }\n      canjump = 1;\n\n      /* Get the pointer to external function initialization routine */\n      sprintf(tempText, \"%s_init_\", ef_ptr->name);\n      if ( ! internally_linked ) {\n         f_init_ptr = (void (*)(int *))dlsym(ef_ptr->handle, tempText);\n      } else {\n         f_init_ptr = (void (*)(int *))internal_dlsym(tempText);\n      }\n      if ( f_init_ptr == NULL ) {\n         fprintf(stderr, \"**ERROR in efcn_gather_info(): %s is not found.\\n\", tempText);\n         if ( ! internally_linked )\n            fprintf(stderr, \"  dlerror: \\\"%s\\\"\\n\", dlerror());\n         EF_Util_ressig(\"efcn_gather_info\");\n         return -1;\n      }\n\n      /*\n       * Call the initialization routine.  If it bails out,\n       * this will jump back to one of the setjmp methods, returning non-zero.\n       */\n      (*f_init_ptr)(id_ptr);\n      ef_ptr->already_have_internals = TRUE;\n\n      /* Restore the old signal handlers. */\n      if ( EF_Util_ressig(\"efcn_gather_info\") ) {\n         return -1;\n      }\n\n   }\n   else {\n      /* Note: Python-backed external functions get initialized when added, so no support here for them */\n      fprintf(stderr, \"**ERROR: unsupported language (%d) for efcn_gather_info.\\n\", i_ptr->language);\n      return -1;\n   }\n\n   return 0;\n}\n\n\n/*\n * Find an external function based on its integer ID,\n * Query the function about custom axes. Store the context\n * list information for use by utility functions.\n */\nvoid FORTRAN(efcn_get_custom_axes)( int *id_ptr, int *cx_list_ptr, int *status )\n{\n  ExternalFunction *ef_ptr=NULL;\n  char tempText[EF_MAX_NAME_LENGTH]=\"\";\n  int internally_linked = FALSE;\n\n  void (*fptr)(int *);\n\n  /*\n   * Initialize the status\n   */\n  *status = FERR_OK;\n\n  /*\n   * Store the context list globally.\n   */\n  EF_store_globals(NULL, cx_list_ptr, NULL, NULL);\n\n  /*\n   * Find the external function.\n   */\n  if ( (ef_ptr = ef_ptr_from_id_ptr(id_ptr)) == NULL ) { return; }\n  if ( (!strcmp(ef_ptr->path,\"internally_linked\")) ) {internally_linked = TRUE; }\n\n  if ( ef_ptr->internals_ptr->language == EF_F ) {\n\n    /*\n     * Prepare for bailout possibilities by setting a signal handler for\n     * SIGFPE, SIGSEGV, SIGINT and SIGBUS and then by cacheing the stack\n     * environment with sigsetjmp (for the signal handler) and setjmp\n     * (for the \"bail out\" utility function).\n     */\n\n    if (EF_Util_setsig(\"efcn_get_custom_axes\")) {\n      *status = FERR_EF_ERROR;\n       return;\n    }\n\n    /*\n     * Set the signal return location and process jumps\n     */\n    if (sigsetjmp(sigjumpbuffer, 1) != 0) {\n      *status = FERR_EF_ERROR;\n      return;\n    }\n\n    /*\n     * Set the bail out return location and process jumps\n     */\n    if (setjmp(jumpbuffer) != 0) {\n      *status = FERR_EF_ERROR;\n      return;\n    }\n\n    canjump = 1;\n\n    strcpy(tempText, ef_ptr->name);\n    strcat(tempText, \"_custom_axes_\");\n\n    if (!internally_linked) {\n       fptr  = (void (*)(int *))dlsym(ef_ptr->handle, tempText);\n    } else {\n      fptr  = (void (*)(int *))internal_dlsym(tempText);\n    }\n    (*fptr)( id_ptr );\n\n\n    /*\n     * Restore the old signal handlers.\n     */\n    if ( EF_Util_ressig(\"efcn_get_custom_axes\")) {\n       return;\n    }\n\n    /* end of EF_F */\n  }\n  else if ( ef_ptr->internals_ptr->language == EF_PYTHON ) {\n      char errstring[2048];\n\n      if ( pyefcn_custom_axes_func == NULL ) {\n          /* pyefcn_handle should never be NULL if we got here, but just in case... */\n          if ( pyefcn_handle == NULL ) {\n              fputs(\"**ERROR: Python-backed external functions not supported \\n\"\n                    \"(handle for $FER_LIBS/libpyefcn.so not assigned in efcn_get_custom_axes)\", stderr);\n              *status = FERR_EF_ERROR;\n              return;\n          }\n          pyefcn_custom_axes_func = (void (*)(int, char[], char[])) dlsym(pyefcn_handle, \"pyefcn_custom_axes\");\n          if ( pyefcn_custom_axes_func == NULL ) {\n              fprintf(stderr, \"**ERROR: Python-backed external functions not supported \\n\"\n                              \"(unable to find pyefcn_custom_axes in $FER_LIBS/libpyefcn.so: %s)\", dlerror());\n              *status = FERR_EF_ERROR;\n              return;\n          }\n      }\n\n      /*\n       * Prepare for bailout possibilities by setting a signal handler for\n       * SIGFPE, SIGSEGV, SIGINT and SIGBUS and then by cacheing the stack\n       * environment with sigsetjmp (for the signal handler) and setjmp\n       * (for the \"bail out\" utility function).\n       */\n      if ( EF_Util_setsig(\"efcn_get_custom_axes\")) {\n          *status = FERR_EF_ERROR;\n           return;\n      }\n      if (sigsetjmp(sigjumpbuffer, 1) != 0) {\n          *status = FERR_EF_ERROR;\n          return;\n      }\n      if (setjmp(jumpbuffer) != 0) {\n          *status = FERR_EF_ERROR;\n          return;\n      }\n      canjump = 1;\n\n      /* Call pyefcn_custom_axes which in turn calls the ferret_custom_axes method in the python module */\n      (*pyefcn_custom_axes_func)(*id_ptr, ef_ptr->path, errstring);\n      if ( strlen(errstring) > 0 ) {\n          /* (In effect) call ef_bail_out_ to process the error in a standard way */\n          FORTRAN(ef_err_bail_out)(id_ptr, errstring);\n          /* Should never return - instead jumps to setjmp() returning 1 */\n      }\n\n      /* Restore the old signal handlers. */\n      EF_Util_ressig(\"efcn_get_custom_axes\");\n\n      /* end of EF_PYTHON */\n  }\n  else {\n    *status = FERR_EF_ERROR;\n    fprintf(stderr, \"**ERROR: unsupported language (%d) for efcn_get_custom_axes.\\n\", ef_ptr->internals_ptr->language);\n  }\n\n  return;\n}\n\n\n/*\n * Find an external function based on its integer ID,\n * Query the function about abstract axes. Pass memory,\n * mr_list and cx_list info into the external function.\n * 1/17 *SH* removed argument \"memory\" from the calling arguments\n *           It was never used by the routine, anyway.\n */\nvoid FORTRAN(efcn_get_result_limits)( int *id_ptr, int *mr_list_ptr, int *cx_list_ptr, int *status )\n{\n  ExternalFunction *ef_ptr=NULL;\n  char tempText[EF_MAX_NAME_LENGTH]=\"\";\n  int internally_linked = FALSE;\n\n  void (*fptr)(int *);\n\n  /*\n   * Initialize the status\n   */\n  *status = FERR_OK;\n\n  /*\n   * Store the memory pointer and various lists globally.\n   */\n  EF_store_globals(mr_list_ptr, cx_list_ptr, NULL, NULL);\n\n  /*\n   * Find the external function.\n   */\n\n  if ( (ef_ptr = ef_ptr_from_id_ptr(id_ptr)) == NULL ) { return; }\n\n  if ( (!strcmp(ef_ptr->path,\"internally_linked\")) ) {internally_linked = TRUE; }\n\n  if ( ef_ptr->internals_ptr->language == EF_F ) {\n\n    /*\n     * Prepare for bailout possibilities by setting a signal handler for\n     * SIGFPE, SIGSEGV, SIGINT and SIGBUS and then by cacheing the stack\n     * environment with sigsetjmp (for the signal handler) and setjmp\n     * (for the \"bail out\" utility function).\n     */\n\n\n    if ( EF_Util_setsig(\"efcn_get_result_limits\")) {\n      *status = FERR_EF_ERROR;\n       return;\n    }\n\n    /*\n     * Set the signal return location and process jumps\n     */\n    if (sigsetjmp(sigjumpbuffer, 1) != 0) {\n      *status = FERR_EF_ERROR;\n      return;\n    }\n\n    /*\n     * Set the bail out return location and process jumps\n     */\n    if (setjmp(jumpbuffer) != 0) {\n      *status = FERR_EF_ERROR;\n      return;\n    }\n\n    canjump = 1;\n\n\n    strcpy(tempText, ef_ptr->name);\n    strcat(tempText, \"_result_limits_\");\n\n    if (!internally_linked) {\n      fptr  = (void (*)(int *))dlsym(ef_ptr->handle, tempText);\n    } else {\n      fptr  = (void (*)(int *))internal_dlsym(tempText);\n    }\n\n    (*fptr)( id_ptr);\n\n    /*\n     * Restore the old signal handlers.\n     */\n    if ( EF_Util_ressig(\"efcn_get_result_limits\")) {\n       return;\n    }\n\n    /* end of EF_F */\n  }\n  else if ( ef_ptr->internals_ptr->language == EF_PYTHON ) {\n      char errstring[2048];\n\n      if ( pyefcn_result_limits_func == NULL ) {\n          /* pyefcn_handle should never be NULL if we got here, but just in case... */\n          if ( pyefcn_handle == NULL ) {\n              fputs(\"**ERROR: Python-backed external functions not supported \\n\"\n                    \"(handle for $FER_LIBS/libpyefcn.so not assigned in efcn_get_result_limits)\", stderr);\n              *status = FERR_EF_ERROR;\n              return;\n          }\n          pyefcn_result_limits_func = (void (*)(int, char[], char[])) dlsym(pyefcn_handle, \"pyefcn_result_limits\");\n          if ( pyefcn_result_limits_func == NULL ) {\n              fprintf(stderr, \"**ERROR: Python-backed external functions not supported \\n\"\n                              \"(unable to find pyefcn_result_limits in $FER_LIBS/libpyefcn.so: %s)\", dlerror());\n              *status = FERR_EF_ERROR;\n              return;\n          }\n      }\n\n      /*\n       * Prepare for bailout possibilities by setting a signal handler for\n       * SIGFPE, SIGSEGV, SIGINT and SIGBUS and then by cacheing the stack\n       * environment with sigsetjmp (for the signal handler) and setjmp\n       * (for the \"bail out\" utility function).\n       */\n      if ( EF_Util_setsig(\"efcn_get_result_limits\")) {\n          *status = FERR_EF_ERROR;\n           return;\n      }\n      if (sigsetjmp(sigjumpbuffer, 1) != 0) {\n          *status = FERR_EF_ERROR;\n          return;\n      }\n      if (setjmp(jumpbuffer) != 0) {\n          *status = FERR_EF_ERROR;\n          return;\n      }\n      canjump = 1;\n\n      /* Call pyefcn_result_limits which in turn calls the ferret_result_limits method in the python module */\n      (*pyefcn_result_limits_func)(*id_ptr, ef_ptr->path, errstring);\n      if ( strlen(errstring) > 0 ) {\n          /* (In effect) call ef_bail_out_ to process the error in a standard way */\n          FORTRAN(ef_err_bail_out)(id_ptr, errstring);\n          /* Should never return - instead jumps to setjmp() returning 1 */\n      }\n\n      /* Restore the old signal handlers. */\n      EF_Util_ressig(\"efcn_get_result_limits\");\n\n      /* end of EF_PYTHON */\n  }\n  else {\n    *status = FERR_EF_ERROR;\n    fprintf(stderr, \"**ERROR: unsupported language (%d) for efcn_get_result_limits.\\n\", ef_ptr->internals_ptr->language);\n  }\n\n  return;\n}\n\n\n/*\n * Find an external function based on its integer ID,\n * pass the necessary information and the data and tell\n * the function to calculate the result.\n */\nvoid FORTRAN(efcn_compute)( int *id_ptr, int *narg_ptr, int *cx_list_ptr, int *mr_list_ptr, int *mres_ptr,\n\tDFTYPE *bad_flag_ptr, int *status )\n{\n  /* \n   * The array of work array memory pointers are used in return setjmp/longjmp \n   * and sigsetjmp/siglongjmp blocks so cannot be an normal automatic variable.\n   */\n  static DFTYPE *(work_ptr[EF_MAX_WORK_ARRAYS]);\n\n  ExternalFunction *ef_ptr=NULL;\n  ExternalFunctionInternals *i_ptr=NULL;\n  DFTYPE *arg_ptr[EF_MAX_COMPUTE_ARGS];\n  int i=0, j=0;\n  int size=0;\n  int nargs=0;\n  char tempText[EF_MAX_NAME_LENGTH]=\"\";\n  int internally_linked = FALSE;\n\n  /*\n   * Prototype all the functions needed for varying numbers of\n   * arguments and work arrays.\n   */\n\n  void (*fptr)(int *);\n  void (*f1arg)(int *, DFTYPE *, DFTYPE *);\n  void (*f2arg)(int *, DFTYPE *, DFTYPE *, DFTYPE *);\n  void (*f3arg)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n  void (*f4arg)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n  void (*f5arg)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n  void (*f6arg)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n\t\tDFTYPE *);\n  void (*f7arg)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n\t\tDFTYPE *, DFTYPE *);\n  void (*f8arg)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n\t\tDFTYPE *, DFTYPE *, DFTYPE *);\n  void (*f9arg)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n\t\tDFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n  void (*f10arg)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n\t\tDFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n  void (*f11arg)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n\t\tDFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n  void (*f12arg)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n\t\tDFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n  void (*f13arg)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n\t\tDFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n  void (*f14arg)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n\t\tDFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n        DFTYPE *);\n  void (*f15arg)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n\t\tDFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n        DFTYPE *, DFTYPE *);\n  void (*f16arg)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n\t\tDFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n        DFTYPE *, DFTYPE *, DFTYPE *);\n  void (*f17arg)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n\t\tDFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n        DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n  void (*f18arg)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n\t\tDFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n        DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *);\n\n  /*\n   * Initialize the status\n   */\n  *status = FERR_OK;\n\n  /*\n   * Store the array dimensions for memory resident variables and for working storage.\n   * Store the memory pointer and various lists globally.\n   */\n  FORTRAN(efcn_copy_array_dims)();\n  EF_store_globals(mr_list_ptr, cx_list_ptr, mres_ptr, bad_flag_ptr);\n\n  /*\n   * Find the external function.\n   */\n  if ( (ef_ptr = ef_ptr_from_id_ptr(id_ptr)) == NULL ) {\n    fprintf(stderr, \"**ERROR in efcn_compute() finding external function: id = [%d]\\n\", *id_ptr);\n    *status = FERR_EF_ERROR;\n    return;\n  }\n  if ( (!strcmp(ef_ptr->path,\"internally_linked\")) ) {internally_linked = TRUE; }\n\n  i_ptr = ef_ptr->internals_ptr;\n\n/*\n   1/17 tell FORTRAN to pass the pointers (place them into GLOBALs)\n*/\n  nargs = i_ptr->num_reqd_args;\n  FORTRAN(efcn_rqst_mr_ptrs)(&nargs, mr_list_ptr, mres_ptr);\n\n  if ( i_ptr->language == EF_F ) {\n    /*\n     * Begin assigning the arg_ptrs.\n     */\n\n\n    /* First come the arguments to the function. */\n\n     for (i=0; i<i_ptr->num_reqd_args; i++) {\n       arg_ptr[i] = GLOBAL_arg_ptrs[i];\n     }\n\n    /* Now for the result */\n\n     arg_ptr[i++] = GLOBAL_res_ptr;\n\n    /* Now for the work arrays */\n\n    /*\n     * If this program has requested working storage we need to\n     * ask the function to specify the amount of space needed\n     * and then create the memory here.  Memory will be released\n     * after the external function returns.\n     */\n    if (i_ptr->num_work_arrays > EF_MAX_WORK_ARRAYS) {\n\n\t  fprintf(stderr, \"**ERROR specifying number of work arrays in ~_init subroutine of external function %s\\n\"\n                          \"\\tnum_work_arrays[=%d] exceeds maximum[=%d].\\n\\n\",\n                          ef_ptr->name, i_ptr->num_work_arrays, EF_MAX_WORK_ARRAYS);\n\t  *status = FERR_EF_ERROR;\n\t  return;\n\n    } else if (i_ptr->num_work_arrays < 0) {\n\n\t  fprintf(stderr, \"**ERROR specifying number of work arrays in ~_init subroutine of external function %s\\n\"\n                          \"\\tnum_work_arrays[=%d] must be a positive number.\\n\\n\",\n                          ef_ptr->name, i_ptr->num_work_arrays);\n\t  *status = FERR_EF_ERROR;\n\t  return;\n\n    } else if (i_ptr->num_work_arrays > 0)  {\n\n      strcpy(tempText, ef_ptr->name);\n      strcat(tempText, \"_work_size_\");\n\n      if (!internally_linked) {\n         fptr = (void (*)(int *))dlsym(ef_ptr->handle, tempText);\n      } else {\n         fptr  = (void (*)(int *))internal_dlsym(tempText);\n      }\n\n      if (fptr == NULL) {\n\tfprintf(stderr, \"**ERROR in efcn_compute() accessing %s\\n\", tempText);\n\t*status = FERR_EF_ERROR;\n        return;\n      }\n      (*fptr)( id_ptr );\n\n\n      /* Allocate memory for each individual work array */\n      for (j = 0; j < EF_MAX_WORK_ARRAYS; j++)\n         work_ptr[j] = NULL;\n      for (j=0; j<i_ptr->num_work_arrays; i++, j++) {\n\n        int iarray, xlo, ylo, zlo, tlo, elo, flo,\n                    xhi, yhi, zhi, thi, ehi, fhi;\n        iarray = j+1;\n        xlo = i_ptr->work_array_lo[j][0];\n        ylo = i_ptr->work_array_lo[j][1];\n        zlo = i_ptr->work_array_lo[j][2];\n        tlo = i_ptr->work_array_lo[j][3];\n        elo = i_ptr->work_array_lo[j][4];\n        flo = i_ptr->work_array_lo[j][5];\n        xhi = i_ptr->work_array_hi[j][0];\n        yhi = i_ptr->work_array_hi[j][1];\n        zhi = i_ptr->work_array_hi[j][2];\n        thi = i_ptr->work_array_hi[j][3];\n        ehi = i_ptr->work_array_hi[j][4];\n        fhi = i_ptr->work_array_hi[j][5];\n\n        FORTRAN(efcn_set_work_array_dims)(&iarray, &xlo, &ylo, &zlo, &tlo, &elo, &flo,\n                                                   &xhi, &yhi, &zhi, &thi, &ehi, &fhi);\n\n        size = sizeof(DFTYPE) * (xhi-xlo+1) * (yhi-ylo+1) * (zhi-zlo+1)\n                              * (thi-tlo+1) * (ehi-elo+1) * (fhi-flo+1);\n\n        arg_ptr[i] = (DFTYPE *)FerMem_Malloc(size, __FILE__, __LINE__);\n        if ( arg_ptr[i] == NULL ) {\n          fprintf(stderr, \"**ERROR in efcn_compute() allocating %d bytes of memory\\n\"\n                          \"\\twork array %d:  X=%d:%d, Y=%d:%d, Z=%d:%d, T=%d:%d, E=%d:%d, F=%d:%d\\n\",\n                          size, iarray, xlo, xhi, ylo, yhi, zlo, zhi, tlo, thi, elo, ehi, flo, fhi);\n          while ( j > 0 ) {\n             j--;\n             FerMem_Free(work_ptr[j], __FILE__, __LINE__);\n             work_ptr[j] = NULL;\n          }\n\t  *status = FERR_EF_ERROR;\n\t  return;\n        }\n        work_ptr[j] = arg_ptr[i];\n      }\n\n    }\n\n    /*\n     * Prepare for bailout possibilities by setting a signal handler for\n     * SIGFPE, SIGSEGV, SIGINT and SIGBUS and then by cacheing the stack\n     * environment with sigsetjmp (for the signal handler) and setjmp\n     * (for the \"bail out\" utility function).\n     */\n\n    if ( EF_Util_setsig(\"efcn_compute\")) {\n      for (j = 0; j < EF_MAX_WORK_ARRAYS; j++) {\n        if ( work_ptr[j] == NULL )\n          break;\n        FerMem_Free(work_ptr[j], __FILE__, __LINE__);\n        work_ptr[j] = NULL;\n      }\n      *status = FERR_EF_ERROR;\n      return;\n    }\n\n    /*\n     * Set the signal return location and process jumps\n     */\n    if (sigsetjmp(sigjumpbuffer, 1) != 0) {\n      for (j = 0; j < EF_MAX_WORK_ARRAYS; j++) {\n        if ( work_ptr[j] == NULL )\n          break;\n        FerMem_Free(work_ptr[j], __FILE__, __LINE__);\n        work_ptr[j] = NULL;\n      }\n      *status = FERR_EF_ERROR;\n      return;\n    }\n\n    /*\n     * Set the bail out return location and process jumps\n     */\n    if (setjmp(jumpbuffer) != 0) {\n      for (j = 0; j < EF_MAX_WORK_ARRAYS; j++) {\n        if ( work_ptr[j] == NULL )\n          break;\n        FerMem_Free(work_ptr[j], __FILE__, __LINE__);\n        work_ptr[j] = NULL;\n      }\n      *status = FERR_EF_ERROR;\n      return;\n    }\n\n    canjump = 1;\n\n\n    /*\n     * Now go ahead and call the external function's \"_compute_\" function,\n     * prototyping it for the number of arguments expected.\n     */\n    strcpy(tempText, ef_ptr->name);\n    strcat(tempText, \"_compute_\");\n\n    switch ( i_ptr->num_reqd_args + i_ptr->num_work_arrays ) {\n\n    case 1:\n\t  if (!internally_linked) {\n            f1arg  = (void (*)(int *, DFTYPE *, DFTYPE *))\n             dlsym(ef_ptr->handle, tempText);\n          } else {\n\t    f1arg  = (void (*)(int *, DFTYPE *, DFTYPE *))\n             internal_dlsym(tempText);\n          }\n\t  (*f1arg)( id_ptr, arg_ptr[0], arg_ptr[1] );\n\tbreak;\n\n\n    case 2:\n\t  if (!internally_linked) {\n            f2arg  = (void (*)(int *, DFTYPE *, DFTYPE *, DFTYPE *))\n             dlsym(ef_ptr->handle, tempText);\n          } else {\n            f2arg  = (void (*)(int *, DFTYPE *, DFTYPE *, DFTYPE *))\n             internal_dlsym(tempText);\n          }\n\t  (*f2arg)( id_ptr, arg_ptr[0], arg_ptr[1], arg_ptr[2] );\n\tbreak;\n\n\n    case 3:\n\t  if (!internally_linked) {\n\t     f3arg  = (void (*)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *))\n              dlsym(ef_ptr->handle, tempText);\n          } else {\n\t     f3arg  = (void (*)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *))\n              internal_dlsym(tempText);\n          }\n\t  (*f3arg)( id_ptr, arg_ptr[0], arg_ptr[1], arg_ptr[2], arg_ptr[3] );\n\tbreak;\n\n\n    case 4:\n\t  if (!internally_linked) {\n            f4arg  = (void (*)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *))\n             dlsym(ef_ptr->handle, tempText);\n          } else {\n            f4arg  = (void (*)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *))\n             internal_dlsym(tempText);\n          }\n\t  (*f4arg)( id_ptr, arg_ptr[0], arg_ptr[1], arg_ptr[2], arg_ptr[3], arg_ptr[4] );\n\tbreak;\n\n\n    case 5:\n\t  if (!internally_linked) {\n\t    f5arg  = (void (*)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n             DFTYPE *))\n             dlsym(ef_ptr->handle, tempText);\n          } else {\n\t    f5arg  = (void (*)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n             DFTYPE *))\n             internal_dlsym(tempText);\n          }\n\t  (*f5arg)( id_ptr, arg_ptr[0], arg_ptr[1], arg_ptr[2], arg_ptr[3], arg_ptr[4],\n        arg_ptr[5] );\n\tbreak;\n\n\n    case 6:\n\t  if (!internally_linked) {\n\t    f6arg  = (void (*)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n             DFTYPE *))dlsym(ef_ptr->handle, tempText);\n          } else {\n\t    f6arg  = (void (*)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n             DFTYPE *))internal_dlsym(tempText);\n          }\n\t  (*f6arg)( id_ptr, arg_ptr[0], arg_ptr[1], arg_ptr[2], arg_ptr[3], arg_ptr[4],\n        arg_ptr[5], arg_ptr[6] );\n\tbreak;\n\n\n    case 7:\n\t  if (!internally_linked) {\n\t    f7arg  = (void (*)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n             DFTYPE *, DFTYPE *))dlsym(ef_ptr->handle, tempText);\n          } else {\n\t    f7arg  = (void (*)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n             DFTYPE *, DFTYPE *))internal_dlsym(tempText);\n          }\n\t  (*f7arg)( id_ptr, arg_ptr[0], arg_ptr[1], arg_ptr[2], arg_ptr[3], arg_ptr[4],\n        arg_ptr[5], arg_ptr[6], arg_ptr[7] );\n\tbreak;\n\n\n    case 8:\n\t  if (!internally_linked) {\n\t    f8arg  = (void (*)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n             DFTYPE *, DFTYPE *, DFTYPE *))dlsym(ef_ptr->handle, tempText);\n          } else {\n\t    f8arg  = (void (*)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n             DFTYPE *, DFTYPE *, DFTYPE *))internal_dlsym(tempText);\n          }\n\t  (*f8arg)( id_ptr, arg_ptr[0], arg_ptr[1], arg_ptr[2], arg_ptr[3], arg_ptr[4],\n        arg_ptr[5], arg_ptr[6], arg_ptr[7], arg_ptr[8] );\n\tbreak;\n\n\n    case 9:\n\t  if (!internally_linked) {\n            f9arg  = (void (*)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n             DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *))dlsym(ef_ptr->handle, tempText);\n          } else {\n            f9arg  = (void (*)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n             DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *))internal_dlsym(tempText);\n          }\n\t  (*f9arg)( id_ptr, arg_ptr[0], arg_ptr[1], arg_ptr[2], arg_ptr[3], arg_ptr[4],\n        arg_ptr[5], arg_ptr[6], arg_ptr[7], arg_ptr[8], arg_ptr[9] );\n\tbreak;\n\n\n    case 10:\n\t  if (!internally_linked) {\n\t    f10arg  = (void (*)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n             DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *))dlsym(ef_ptr->handle, tempText);\n          } else {\n\t    f10arg  = (void (*)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n             DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *))internal_dlsym(tempText);\n          }\n\t  (*f10arg)( id_ptr, arg_ptr[0], arg_ptr[1], arg_ptr[2], arg_ptr[3], arg_ptr[4],\n        arg_ptr[5], arg_ptr[6], arg_ptr[7], arg_ptr[8], arg_ptr[9], arg_ptr[10] );\n\tbreak;\n\n\n    case 11:\n\t  if (!internally_linked) {\n            f11arg  = (void (*)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n             DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *))\n             dlsym(ef_ptr->handle, tempText);\n          } else {\n            f11arg  = (void (*)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n             DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *))\n             internal_dlsym(tempText);\n          }\n\t  (*f11arg)( id_ptr, arg_ptr[0], arg_ptr[1], arg_ptr[2], arg_ptr[3], arg_ptr[4],\n        arg_ptr[5], arg_ptr[6], arg_ptr[7], arg_ptr[8], arg_ptr[9], arg_ptr[10],\n        arg_ptr[11] );\n\tbreak;\n\n\n    case 12:\n\t  if (!internally_linked) {\n\t    f12arg  = (void (*)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n             DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *))\n             dlsym(ef_ptr->handle, tempText);\n          } else {\n\t    f12arg  = (void (*)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n             DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *))\n             internal_dlsym(tempText);\n          }\n\t  (*f12arg)( id_ptr, arg_ptr[0], arg_ptr[1], arg_ptr[2], arg_ptr[3], arg_ptr[4],\n        arg_ptr[5], arg_ptr[6], arg_ptr[7], arg_ptr[8], arg_ptr[9], arg_ptr[10],\n        arg_ptr[11], arg_ptr[12] );\n\tbreak;\n\n\n    case 13:\n\t  if (!internally_linked) {\n\t    f13arg  = (void (*)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n             DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *))\n             dlsym(ef_ptr->handle, tempText);\n          } else {\n\t    f13arg  = (void (*)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n             DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *))\n             internal_dlsym(tempText);\n          }\n\t  (*f13arg)( id_ptr, arg_ptr[0], arg_ptr[1], arg_ptr[2], arg_ptr[3], arg_ptr[4],\n        arg_ptr[5], arg_ptr[6], arg_ptr[7], arg_ptr[8], arg_ptr[9], arg_ptr[10],\n        arg_ptr[11], arg_ptr[12], arg_ptr[13] );\n\tbreak;\n\n\n    case 14:\n\t  if (!internally_linked) {\n\t    f14arg  = (void (*)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n             DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n             DFTYPE *))dlsym(ef_ptr->handle, tempText);\n          } else {\n\t    f14arg  = (void (*)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n             DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n             DFTYPE *))internal_dlsym(tempText);\n          }\n\t  (*f14arg)( id_ptr, arg_ptr[0], arg_ptr[1], arg_ptr[2], arg_ptr[3], arg_ptr[4],\n        arg_ptr[5], arg_ptr[6], arg_ptr[7], arg_ptr[8], arg_ptr[9], arg_ptr[10],\n        arg_ptr[11], arg_ptr[12], arg_ptr[13], arg_ptr[14] );\n\tbreak;\n\n\n    case 15:\n\t  if (!internally_linked) {\n\t   f15arg  = (void (*)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n            DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n            DFTYPE *, DFTYPE *))dlsym(ef_ptr->handle, tempText);\n          } else {\n\t   f15arg  = (void (*)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n            DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n            DFTYPE *, DFTYPE *))internal_dlsym(tempText);\n          }\n\t  (*f15arg)( id_ptr, arg_ptr[0], arg_ptr[1], arg_ptr[2], arg_ptr[3], arg_ptr[4],\n        arg_ptr[5], arg_ptr[6], arg_ptr[7], arg_ptr[8], arg_ptr[9], arg_ptr[10],\n        arg_ptr[11], arg_ptr[12], arg_ptr[13], arg_ptr[14], arg_ptr[15] );\n\tbreak;\n\n\n    case 16:\n\t  if (!internally_linked) {\n\t    f16arg  = (void (*)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n             DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n             DFTYPE *, DFTYPE *, DFTYPE *))dlsym(ef_ptr->handle, tempText);\n          } else {\n\t    f16arg  = (void (*)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n             DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n             DFTYPE *, DFTYPE *, DFTYPE *))internal_dlsym(tempText);\n          }\n\t  (*f16arg)( id_ptr, arg_ptr[0], arg_ptr[1], arg_ptr[2], arg_ptr[3], arg_ptr[4],\n        arg_ptr[5], arg_ptr[6], arg_ptr[7], arg_ptr[8], arg_ptr[9], arg_ptr[10],\n        arg_ptr[11], arg_ptr[12], arg_ptr[13], arg_ptr[14], arg_ptr[15], arg_ptr[16] );\n\tbreak;\n\n\n    case 17:\n\t  if (!internally_linked) {\n            f17arg  = (void (*)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n             DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n             DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *))dlsym(ef_ptr->handle, tempText);\n          } else {\n            f17arg  = (void (*)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n             DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n             DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *))internal_dlsym(tempText);\n          }\n\t  (*f17arg)( id_ptr, arg_ptr[0], arg_ptr[1], arg_ptr[2], arg_ptr[3], arg_ptr[4],\n        arg_ptr[5], arg_ptr[6], arg_ptr[7], arg_ptr[8], arg_ptr[9], arg_ptr[10],\n        arg_ptr[11], arg_ptr[12], arg_ptr[13], arg_ptr[14], arg_ptr[15], arg_ptr[16],\n        arg_ptr[17] );\n\tbreak;\n\n\n    case 18:\n\t  if (!internally_linked) {\n\t    f18arg  = (void (*)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n             DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n             DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *))dlsym(ef_ptr->handle, tempText);\n          } else {\n\t    f18arg  = (void (*)(int *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n             DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *,\n             DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *, DFTYPE *))internal_dlsym(tempText);\n          }\n\t  (*f18arg)( id_ptr, arg_ptr[0], arg_ptr[1], arg_ptr[2], arg_ptr[3], arg_ptr[4],\n        arg_ptr[5], arg_ptr[6], arg_ptr[7], arg_ptr[8], arg_ptr[9], arg_ptr[10],\n        arg_ptr[11], arg_ptr[12], arg_ptr[13], arg_ptr[14], arg_ptr[15], arg_ptr[16],\n        arg_ptr[17], arg_ptr[18] );\n\tbreak;\n\n\n    default:\n      for (j = 0; j < EF_MAX_WORK_ARRAYS; j++) {\n        if ( work_ptr[j] == NULL )\n          break;\n        FerMem_Free(work_ptr[j], __FILE__, __LINE__);\n        work_ptr[j] = NULL;\n      }\n      fprintf(stderr, \"**ERROR: External functions with more than %d arguments are not implemented.\\n\",\n                      EF_MAX_ARGS);\n      *status = FERR_EF_ERROR;\n      return;\n      break;\n\n    }\n\n    /* Release the work space. */\n    for (j = 0; j < EF_MAX_WORK_ARRAYS; j++) {\n      if ( work_ptr[j] == NULL )\n        break;\n      FerMem_Free(work_ptr[j], __FILE__, __LINE__);\n      work_ptr[j] = NULL;\n    }\n\n    /*\n     * Restore the old signal handlers.\n     */\n    if ( EF_Util_ressig(\"efcn_compute\")) {\n      *status = FERR_EF_ERROR;\n      return;\n    }\n\n    /* Success for EF_F */\n  }\n  else if ( i_ptr->language == EF_PYTHON ) {\n      int   memlo[EF_MAX_COMPUTE_ARGS][NFERDIMS], memhi[EF_MAX_COMPUTE_ARGS][NFERDIMS],\n            steplo[EF_MAX_COMPUTE_ARGS][NFERDIMS], stephi[EF_MAX_COMPUTE_ARGS][NFERDIMS],\n            incr[EF_MAX_COMPUTE_ARGS][NFERDIMS];\n      DFTYPE badflags[EF_MAX_COMPUTE_ARGS];\n      char  errstring[2048];\n\n      if ( pyefcn_compute_func == NULL ) {\n          /* pyefcn_handle should never be NULL if we got here, but just in case... */\n          if ( pyefcn_handle == NULL ) {\n              fputs(\"**ERROR: Python-backed external functions not supported \\n\"\n                    \"(handle for $FER_LIBS/libpyefcn.so not assigned in efcn_compute)\", stderr);\n              *status = FERR_EF_ERROR;\n              return;\n          }\n          pyefcn_compute_func = (void (*)(int, char [], DFTYPE *[], int,\n                                          int [][NFERDIMS], int [][NFERDIMS],\n                                          int [][NFERDIMS], int [][NFERDIMS], int [][NFERDIMS],\n                                          DFTYPE[], char []))\n                                dlsym(pyefcn_handle, \"pyefcn_compute\");\n          if ( pyefcn_compute_func == NULL ) {\n              fprintf(stderr, \"**ERROR: Python-backed external functions not supported \\n\"\n                              \"(unable to find pyefcn_compute in $FER_LIBS/libpyefcn.so: %s)\", dlerror());\n              *status = FERR_EF_ERROR;\n              return;\n          }\n      }\n\n\n      /* First the results grid array, then the argument grid arrays */\n      arg_ptr[0] = GLOBAL_res_ptr; // 1/17 *sh*\n      for (i = 0; i < i_ptr->num_reqd_args; i++) {\n          arg_ptr[i+1] = GLOBAL_arg_ptrs[i];\n      }\n\n      /* Assign the memory limits, step values, and bad-data-flag values - first result, then arguments */\n      FORTRAN(ef_get_res_mem_subscripts_6d)(id_ptr, memlo[0], memhi[0]);\n      FORTRAN(ef_get_arg_mem_subscripts_6d)(id_ptr, &(memlo[1]), &(memhi[1]));\n      FORTRAN(ef_get_res_subscripts_6d)(id_ptr, steplo[0], stephi[0], incr[0]);\n      FORTRAN(ef_get_arg_subscripts_6d)(id_ptr, &(steplo[1]), &(stephi[1]), &(incr[1]));\n      FORTRAN(ef_get_bad_flags)(id_ptr, &(badflags[1]), &(badflags[0]));\n\n      /* Reset zero increments to +1 or -1 for pyefcn_compute */\n      for (i = 0; i <= i_ptr->num_reqd_args; i++) {\n          for (j = 0; j < NFERDIMS; j++) {\n              if ( incr[i][j] == 0 ) {\n                  if ( steplo[i][j] <= stephi[i][j] )\n                      incr[i][j] = 1;\n                  else\n                      incr[i][j] = -1;\n              }\n          }\n      }\n\n      /*\n       * Prepare for bailout possibilities by setting a signal handler for\n       * SIGFPE, SIGSEGV, SIGINT and SIGBUS and then by cacheing the stack\n       * environment with sigsetjmp (for the signal handler) and setjmp\n       * (for the \"bail out\" utility function).\n       */\n      if ( EF_Util_setsig(\"efcn_compute\")) {\n          *status = FERR_EF_ERROR;\n          return;\n      }\n      if (sigsetjmp(sigjumpbuffer, 1) != 0) {\n          *status = FERR_EF_ERROR;\n          return;\n      }\n      if (setjmp(jumpbuffer) != 0) {\n          *status = FERR_EF_ERROR;\n          return;\n      }\n      canjump = 1;\n\n      /* Call pyefcn_compute which in turn calls the ferret_compute method in the python module */\n      (*pyefcn_compute_func)(*id_ptr, ef_ptr->path, arg_ptr, (i_ptr->num_reqd_args)+1,\n                             memlo, memhi, steplo, stephi, incr, badflags, errstring);\n      if ( strlen(errstring) > 0 ) {\n          /* (In effect) call ef_bail_out_ to process the error in a standard way */\n          FORTRAN(ef_err_bail_out)(id_ptr, errstring);\n          /* Should never return - instead jumps to setjmp() returning 1 */\n      }\n\n      /* Restore the original signal handlers */\n      EF_Util_ressig(\"efcn_compute\");\n\n      /* Success for EF_PYTHON */\n  }\n  else {\n    fprintf(stderr, \"**ERROR: unsupported language (%d) for efcn_compute.\\n\", i_ptr->language);\n    *status = FERR_EF_ERROR;\n  }\n\n  return;\n}\n\n\n/*\n * A signal handler for SIGFPE, SIGSEGV, SIGINT and SIGBUS signals generated\n * while executing an external function.  See \"Advanced Programming\n * in the UNIX Environment\" p. 299 ff for details.\n *\n * This routine should never return since a signal was raised indicating a\n * problem.  The siglongjump rewinds back to where sigsetjmp was called with\n * the current sigjumpbuffer.\n */\nstatic void EF_signal_handler(int signo)\n{\n   if ( canjump == 0 ) {\n      fprintf(stderr, \"EF_signal_handler invoked with signal %d but canjump = 0\", signo);\n      fflush(stderr);\n      abort();\n   }\n\n   /*\n    * Restore the old signal handlers.\n    */\n   if ( EF_Util_ressig(\"efcn_compute\")) {\n      /* error message already printed */\n      fflush(stderr);\n      abort();\n   }\n\n   if (signo == SIGFPE) {\n      fprintf(stderr, \"**ERROR in external function: Floating Point Error\\n\");\n      canjump = 0;\n      siglongjmp(sigjumpbuffer, 1);\n   } else if (signo == SIGSEGV) {\n      fprintf(stderr, \"**ERROR in external function: Segmentation Violation\\n\");\n      canjump = 0;\n      siglongjmp(sigjumpbuffer, 1);\n   } else if (signo == SIGINT) {\n      fprintf(stderr, \"**External function halted with Control-C\\n\");\n      canjump = 0;\n      siglongjmp(sigjumpbuffer, 1);\n   } else if (signo == SIGBUS) {\n      fprintf(stderr, \"**ERROR in external function: Hardware Fault\\n\");\n      canjump = 0;\n      siglongjmp(sigjumpbuffer, 1);\n   } else {\n      fprintf(stderr, \"**ERROR in external function: signo = %d\\n\", signo);\n      canjump = 0;\n      siglongjmp(sigjumpbuffer, 1);\n   }\n\n}\n\n\n/*\n * Find an external function based on its name and\n * return the integer ID associated with that funciton.\n */\nint FORTRAN(efcn_get_id)( char name[] )\n{\n  ExternalFunction *ef_ptr=NULL;\n  int status=LIST_OK;\n\n  static int return_val=0; /* static because it needs to exist after the return statement */\n\n  /*\n   * Find the external function.\n   */\n\n  status = list_traverse(STATIC_ExternalFunctionList, name, EF_ListTraverse_FoundName,\n                         (LIST_FRNT | LIST_FORW | LIST_ALTR));\n\n  /*\n   * If the search failed, set the id_ptr to ATOM_NOT_FOUND.\n   */\n  if ( status != LIST_OK ) {\n    return_val = ATOM_NOT_FOUND;\n    return return_val;\n  }\n\n  ef_ptr=(ExternalFunction *)list_curr(STATIC_ExternalFunctionList);\n\n  return_val = ef_ptr->id;\n\n  return return_val;\n}\n\n\n/*\n * Determine whether a function name matches a template.\n * Return 1 if the name matchs.\n */\nint FORTRAN(efcn_match_template)( int *id_ptr, char template[] )\n{\n  ExternalFunction *ef_ptr=NULL;\n  int EF_LT_MT_return;\n\n  static int return_val=0; /* static because it needs to exist after the return statement */\n\n  if ( (ef_ptr = ef_ptr_from_id_ptr(id_ptr)) == NULL ) { return return_val; }\n\n  EF_LT_MT_return = EF_ListTraverse_MatchTemplate((char *)template, (char *)ef_ptr);\n\n  /* The list package forces 'list traversal' functions to return\n   * 0 whenever a match is found.  We want to return a more reasonable\n   * 1 (=true) if we find a match.\n   */\n  if ( EF_LT_MT_return == FALSE ) {\n\treturn_val = 1;\n  } else {\n    return_val = 0;\n  }\n\n  return return_val;\n}\n\n\n/*\n */\nvoid FORTRAN(efcn_get_custom_axis_sub)( int *id_ptr, int *axis_ptr, double *lo_ptr, double *hi_ptr,\n\t\t\t       double *del_ptr, char *unit, int *modulo_ptr )\n{\n  ExternalFunction *ef_ptr=NULL;\n\n  /*\n   * Find the external function.\n   */\n\n  if ( (ef_ptr = ef_ptr_from_id_ptr(id_ptr)) == NULL ) { return; }\n\n  strcpy(unit, ef_ptr->internals_ptr->axis[*axis_ptr-1].unit);\n  *lo_ptr = ef_ptr->internals_ptr->axis[*axis_ptr-1].ww_lo;\n  *hi_ptr = ef_ptr->internals_ptr->axis[*axis_ptr-1].ww_hi;\n  *del_ptr = ef_ptr->internals_ptr->axis[*axis_ptr-1].ww_del;\n  *modulo_ptr = ef_ptr->internals_ptr->axis[*axis_ptr-1].modulo;\n\n  return;\n}\n\n\n/*\n * Find an external function based on its integer ID and\n * return the name.\n */\nvoid FORTRAN(efcn_get_name)( int *id_ptr, char *name )\n{\n  ExternalFunction *ef_ptr=NULL;\n\n  if ( (ef_ptr = ef_ptr_from_id_ptr(id_ptr)) == NULL ) { return; }\n\n  strcpy(name, ef_ptr->name);\n\n  return;\n}\n\n\n/*\n * Find an external function based on its integer ID and\n * return the version number.\n */\nvoid FORTRAN(efcn_get_version)( int *id_ptr, DFTYPE *version )\n{\n  ExternalFunction *ef_ptr=NULL;\n\n  if ( (ef_ptr = ef_ptr_from_id_ptr(id_ptr)) == NULL ) { return; }\n\n  *version = ef_ptr->internals_ptr->version;\n\n  return;\n}\n\n\n/*\n * Find an external function based on its integer ID and\n * return the description.\n */\nvoid FORTRAN(efcn_get_descr)( int *id_ptr, char *descr )\n{\n  ExternalFunction *ef_ptr=NULL;\n\n  if ( (ef_ptr = ef_ptr_from_id_ptr(id_ptr)) == NULL ) { return; }\n\n  strcpy(descr, ef_ptr->internals_ptr->description);\n\n  return;\n}\n\n/*\n * Find an external function based on its integer ID and\n * return the name of an alternate function that operates\n * with string arguments.\n *\n * *kms* 2/11 - assign blank-terminated (not null-terminated)\n * string since code using this name expects this style.\n * Assumes alt_str_name has been intialized to all-blank.\n */\nvoid FORTRAN(efcn_get_alt_type_fcn)( int *id_ptr, char *alt_str_name )\n{\n  ExternalFunction *ef_ptr=NULL;\n\n  if ( (ef_ptr = ef_ptr_from_id_ptr(id_ptr)) == NULL ) { return; }\n\n  strcpy(alt_str_name, ef_ptr->internals_ptr->alt_fcn_name);\n  alt_str_name[strlen(alt_str_name)] = ' ';\n\n  return;\n}\n\n\n/*\n * Find an external function based on its integer ID and\n * return the number of arguments.\n */\nint FORTRAN(efcn_get_num_reqd_args)( int *id_ptr )\n{\n  ExternalFunction *ef_ptr=NULL;\n\n  static int return_val=0; /* static because it needs to exist after the return statement */\n\n  if ( (ef_ptr = ef_ptr_from_id_ptr(id_ptr)) == NULL ) { return return_val; }\n\n  return_val = ef_ptr->internals_ptr->num_reqd_args;\n\n  return return_val;\n}\n\n\n/*\n * Find an external function based on its integer ID and\n * return the flag stating whether the function has\n * a variable number of arguments.\n */\nvoid FORTRAN(efcn_get_has_vari_args)( int *id_ptr, int *has_vari_args_ptr )\n{\n  ExternalFunction *ef_ptr=NULL;\n\n  if ( (ef_ptr = ef_ptr_from_id_ptr(id_ptr)) == NULL ) { return; }\n\n  *has_vari_args_ptr = ef_ptr->internals_ptr->has_vari_args;\n\n  return;\n}\n\n\n/*\n * Find an external function based on its integer ID and\n * return the axis sources (merged, normal, abstract, custom).\n */\nvoid FORTRAN(efcn_get_axis_will_be)( int *id_ptr, int *array_ptr )\n{\n  ExternalFunction *ef_ptr=NULL;\n\n  if ( (ef_ptr = ef_ptr_from_id_ptr(id_ptr)) == NULL ) { return; }\n\n  array_ptr[X_AXIS] = ef_ptr->internals_ptr->axis_will_be[X_AXIS];\n  array_ptr[Y_AXIS] = ef_ptr->internals_ptr->axis_will_be[Y_AXIS];\n  array_ptr[Z_AXIS] = ef_ptr->internals_ptr->axis_will_be[Z_AXIS];\n  array_ptr[T_AXIS] = ef_ptr->internals_ptr->axis_will_be[T_AXIS];\n  array_ptr[E_AXIS] = ef_ptr->internals_ptr->axis_will_be[E_AXIS];\n  array_ptr[F_AXIS] = ef_ptr->internals_ptr->axis_will_be[F_AXIS];\n\n  return;\n}\n\n\n/*\n * Find an external function based on its integer ID and\n * return the axis_reduction (retained, reduced) information.\n */\nvoid FORTRAN(efcn_get_axis_reduction)( int *id_ptr, int *array_ptr )\n{\n  ExternalFunction *ef_ptr=NULL;\n\n  if ( (ef_ptr = ef_ptr_from_id_ptr(id_ptr)) == NULL ) { return; }\n\n  array_ptr[X_AXIS] = ef_ptr->internals_ptr->axis_reduction[X_AXIS];\n  array_ptr[Y_AXIS] = ef_ptr->internals_ptr->axis_reduction[Y_AXIS];\n  array_ptr[Z_AXIS] = ef_ptr->internals_ptr->axis_reduction[Z_AXIS];\n  array_ptr[T_AXIS] = ef_ptr->internals_ptr->axis_reduction[T_AXIS];\n  array_ptr[E_AXIS] = ef_ptr->internals_ptr->axis_reduction[E_AXIS];\n  array_ptr[F_AXIS] = ef_ptr->internals_ptr->axis_reduction[F_AXIS];\n\n  return;\n}\n\n\n/*\n * Find an external function based on its integer ID and\n * return the piecemeal_ok information.  This lets Ferret\n * know if it's ok to break up a calculation along an axis\n * for memory management reasons.\n */\nvoid FORTRAN(efcn_get_piecemeal_ok)( int *id_ptr, int *array_ptr )\n{\n  ExternalFunction *ef_ptr=NULL;\n\n  if ( (ef_ptr = ef_ptr_from_id_ptr(id_ptr)) == NULL ) { return; }\n\n  array_ptr[X_AXIS] = ef_ptr->internals_ptr->piecemeal_ok[X_AXIS];\n  array_ptr[Y_AXIS] = ef_ptr->internals_ptr->piecemeal_ok[Y_AXIS];\n  array_ptr[Z_AXIS] = ef_ptr->internals_ptr->piecemeal_ok[Z_AXIS];\n  array_ptr[T_AXIS] = ef_ptr->internals_ptr->piecemeal_ok[T_AXIS];\n  array_ptr[E_AXIS] = ef_ptr->internals_ptr->piecemeal_ok[E_AXIS];\n  array_ptr[F_AXIS] = ef_ptr->internals_ptr->piecemeal_ok[F_AXIS];\n\n  return;\n}\n\n\n/*\n * Find an external function based on its integer ID and\n * return the (boolean) 'axis_implied_from' information for\n * a particular argument to find out if its axes should\n * be merged in to the result grid.\n */\nvoid FORTRAN(efcn_get_axis_implied_from)( int *id_ptr, int *iarg_ptr, int *array_ptr )\n{\n  ExternalFunction *ef_ptr=NULL;\n  int index = *iarg_ptr - 1; /* C indices are 1 less than Fortran */\n\n  if ( (ef_ptr = ef_ptr_from_id_ptr(id_ptr)) == NULL ) { return; }\n\n  array_ptr[X_AXIS] = ef_ptr->internals_ptr->axis_implied_from[index][X_AXIS];\n  array_ptr[Y_AXIS] = ef_ptr->internals_ptr->axis_implied_from[index][Y_AXIS];\n  array_ptr[Z_AXIS] = ef_ptr->internals_ptr->axis_implied_from[index][Z_AXIS];\n  array_ptr[T_AXIS] = ef_ptr->internals_ptr->axis_implied_from[index][T_AXIS];\n  array_ptr[E_AXIS] = ef_ptr->internals_ptr->axis_implied_from[index][E_AXIS];\n  array_ptr[F_AXIS] = ef_ptr->internals_ptr->axis_implied_from[index][F_AXIS];\n\n  return;\n}\n\n\n/*\n * Find an external function based on its integer ID and\n * return the 'arg_extend_lo' information for a particular\n * argument which tells Ferret how much to extend axis limits\n * when providing input data (e.g. to compute a derivative).\n */\nvoid FORTRAN(efcn_get_axis_extend_lo)( int *id_ptr, int *iarg_ptr, int *array_ptr )\n{\n  ExternalFunction *ef_ptr=NULL;\n  int index = *iarg_ptr - 1; /* C indices are 1 less than Fortran */\n\n  if ( (ef_ptr = ef_ptr_from_id_ptr(id_ptr)) == NULL ) { return; }\n\n  array_ptr[X_AXIS] = ef_ptr->internals_ptr->axis_extend_lo[index][X_AXIS];\n  array_ptr[Y_AXIS] = ef_ptr->internals_ptr->axis_extend_lo[index][Y_AXIS];\n  array_ptr[Z_AXIS] = ef_ptr->internals_ptr->axis_extend_lo[index][Z_AXIS];\n  array_ptr[T_AXIS] = ef_ptr->internals_ptr->axis_extend_lo[index][T_AXIS];\n  array_ptr[E_AXIS] = ef_ptr->internals_ptr->axis_extend_lo[index][E_AXIS];\n  array_ptr[F_AXIS] = ef_ptr->internals_ptr->axis_extend_lo[index][F_AXIS];\n\n  return;\n}\n\n\n/*\n * Find an external function based on its integer ID and\n * return the 'arg_extend_hi' information for a particular\n * argument which tells Ferret how much to extend axis limits\n * when providing input data (e.g. to compute a derivative).\n */\nvoid FORTRAN(efcn_get_axis_extend_hi)( int *id_ptr, int *iarg_ptr, int *array_ptr )\n{\n  ExternalFunction *ef_ptr=NULL;\n  int index = *iarg_ptr - 1; /* C indices are 1 less than Fortran */\n\n  if ( (ef_ptr = ef_ptr_from_id_ptr(id_ptr)) == NULL ) { return; }\n\n  array_ptr[X_AXIS] = ef_ptr->internals_ptr->axis_extend_hi[index][X_AXIS];\n  array_ptr[Y_AXIS] = ef_ptr->internals_ptr->axis_extend_hi[index][Y_AXIS];\n  array_ptr[Z_AXIS] = ef_ptr->internals_ptr->axis_extend_hi[index][Z_AXIS];\n  array_ptr[T_AXIS] = ef_ptr->internals_ptr->axis_extend_hi[index][T_AXIS];\n  array_ptr[E_AXIS] = ef_ptr->internals_ptr->axis_extend_hi[index][E_AXIS];\n  array_ptr[F_AXIS] = ef_ptr->internals_ptr->axis_extend_hi[index][F_AXIS];\n\n  return;\n}\n\n\n/*\n * Find an external function based on its integer ID and\n * return the 'axis_limits' information for a particular\n * argument.\n */\nvoid FORTRAN(efcn_get_axis_limits)( int *id_ptr, int *axis_ptr, int *lo_ptr, int *hi_ptr )\n{\n  ExternalFunction *ef_ptr=NULL;\n  int index = *axis_ptr - 1; /* C indices are 1 less than Fortran */\n\n  if ( (ef_ptr = ef_ptr_from_id_ptr(id_ptr)) == NULL ) { return; }\n\n  *lo_ptr = ef_ptr->internals_ptr->axis[index].ss_lo;\n  *hi_ptr = ef_ptr->internals_ptr->axis[index].ss_hi;\n\n  return;\n}\n\n\n/*\n * Find an external function based on its integer ID and\n * return the 'arg_type' information for a particular\n * argument which tells Ferret whether an argument is a\n * DFTYPE or a string.\n */\nint FORTRAN(efcn_get_arg_type)( int *id_ptr, int *iarg_ptr )\n{\n  ExternalFunction *ef_ptr=NULL;\n  int return_val=0;\n  int index = *iarg_ptr - 1; /* C indices are 1 less than Fortran */\n\n  if ( (ef_ptr = ef_ptr_from_id_ptr(id_ptr)) == NULL ) { return return_val; }\n\n  return_val = ef_ptr->internals_ptr->arg_type[index];\n\n  return return_val;\n}\n\n\n/*\n * Find an external function based on its integer ID and\n * return the 'rtn_type' information for the result which\n * tells Ferret whether an argument is a DFTYPE or a string.\n */\nint FORTRAN(efcn_get_rtn_type)( int *id_ptr )\n{\n  ExternalFunction *ef_ptr=NULL;\n  static int return_val=0; /* static because it needs to exist after the return statement */\n\n  if ( (ef_ptr = ef_ptr_from_id_ptr(id_ptr)) == NULL ) { return return_val; }\n\n  return_val = ef_ptr->internals_ptr->return_type;\n\n  return return_val;\n}\n\n\n/*\n * Find an external function based on its integer ID and\n * return the name of a particular argument.\n */\nvoid FORTRAN(efcn_get_arg_name)( int *id_ptr, int *iarg_ptr, char *string )\n{\n  ExternalFunction *ef_ptr=NULL;\n  int index = *iarg_ptr - 1; /* C indices are 1 less than Fortran */\n  int i=0, printable=FALSE;\n\n  if ( (ef_ptr = ef_ptr_from_id_ptr(id_ptr)) == NULL ) { return; }\n\n  /*\n   * JC_NOTE: if the argument has no name then memory gets overwritten, corrupting\n   * the address of iarg_ptr and causing a core dump.  I need to catch that case\n   * here.\n   */\n\n  for (i=0;i<strlen(ef_ptr->internals_ptr->arg_name[index]);i++) {\n    if (isgraph(ef_ptr->internals_ptr->arg_name[index][i])) {\n      printable = TRUE;\n      break;\n    }\n  }\n\n  if ( printable ) {\n    strcpy(string, ef_ptr->internals_ptr->arg_name[index]);\n  } else {\n    strcpy(string, \"--\");\n  }\n\n  return;\n}\n\n\n/*\n * Find an external function based on its integer ID and\n * return the units for a particular argument.\n */\nvoid FORTRAN(efcn_get_arg_unit)( int *id_ptr, int *iarg_ptr, char *string )\n{\n  ExternalFunction *ef_ptr=NULL;\n  int index = *iarg_ptr - 1; /* C indices are 1 less than Fortran */\n\n  if ( (ef_ptr = ef_ptr_from_id_ptr(id_ptr)) == NULL ) { return; }\n\n  ef_ptr=(ExternalFunction *)list_curr(STATIC_ExternalFunctionList);\n\n  strcpy(string, ef_ptr->internals_ptr->arg_unit[index]);\n\n  return;\n}\n\n\n/*\n * Find an external function based on its integer ID and\n * return the description of a particular argument.\n */\nvoid FORTRAN(efcn_get_arg_desc)( int *id_ptr, int *iarg_ptr, char *string )\n{\n  ExternalFunction *ef_ptr=NULL;\n  int index = *iarg_ptr - 1; /* C indices are 1 less than Fortran */\n\n  if ( (ef_ptr = ef_ptr_from_id_ptr(id_ptr)) == NULL ) { return; }\n\n  strcpy(string, ef_ptr->internals_ptr->arg_desc[index]);\n\n  return;\n}\n\n\n\n/*\n * This function should never return since there was a user-detected\n * error of some sort.  The call to longjump rewinds back to where\n * setjmp was called with the current jumpbuffer.\n */\nvoid FORTRAN(ef_err_bail_out)(int *id_ptr, char *text)\n{\n   ExternalFunction *ef_ptr=NULL;\n\n   ef_ptr = ef_ptr_from_id_ptr(id_ptr);\n   if ( ef_ptr == NULL ) {\n      fprintf(stderr, \"Unknown external function ID of %d in ef_err_bail_out\", *id_ptr);\n      fflush(stderr);\n      abort();\n   }\n   if ( canjump == 0 ) {\n      fputs(\"ef_err_bail_out called with canjump = 0\", stderr);\n      fflush(stderr);\n      abort();\n   }\n   /*\n    * Restore the old signal handlers.\n    */\n   if ( EF_Util_ressig(\"efcn_compute\")) {\n      /* error message already printed */\n      fflush(stderr);\n      abort();\n   }\n\n   fprintf(stderr, \"\\n\"\n                   \"Bailing out of external function \\\"%s\\\":\\n\"\n                   \"\\t%s\\n\", ef_ptr->name, text);\n\n   longjmp(jumpbuffer, 1);\n}\n\n\n\n/* .... Object Oriented Utility Functions .... */\n\n\n/*\n * Allocate space for and initialize the internal\n * information for an EF.\n *\n * Return values:\n *     -1: error allocating space\n *      0: success\n */\nint EF_New( ExternalFunction *this )\n{\n  ExternalFunctionInternals *i_ptr=NULL;\n  int i=0, j=0;\n\n  static int return_val=0; /* static because it needs to exist after the return statement */\n\n\n  /*\n   * Allocate space for the internals.\n   * If the allocation failed, print a warning message and return.\n   */\n\n  this->internals_ptr = FerMem_Malloc(sizeof(ExternalFunctionInternals), __FILE__, __LINE__);\n  i_ptr = this->internals_ptr;\n\n  if ( i_ptr == NULL ) {\n    fprintf(stderr, \"**ERROR in EF_New(): cannot allocate ExternalFunctionInternals.\\n\");\n    return_val = -1;\n    return return_val;\n  }\n\n\n  /*\n   * Initialize the internals.\n   */\n\n  /* Information about the overall function */\n\n  i_ptr->version = EF_VERSION;\n  strcpy(i_ptr->description, \"\");\n  i_ptr->language = EF_F;\n  i_ptr->num_reqd_args = 1;\n  i_ptr->has_vari_args = NO;\n  i_ptr->num_work_arrays = 0;\n  i_ptr->return_type = FLOAT_RETURN;\n  for (i=0; i<NFERDIMS; i++) {\n    for (j=0; j<EF_MAX_WORK_ARRAYS; j++) {\n      i_ptr->work_array_lo[j][i] = 1;\n      i_ptr->work_array_hi[j][i] = 1;\n    }\n    i_ptr->axis_will_be[i] = IMPLIED_BY_ARGS;\n    i_ptr->axis_reduction[i] = RETAINED;\n    i_ptr->piecemeal_ok[i] = NO;\n  }\n\n  /* Information specific to each argument of the function */\n\n  for (i=0; i<EF_MAX_ARGS; i++) {\n    for (j=0; j<NFERDIMS; j++) {\n      i_ptr->axis_implied_from[i][j] = YES;\n      i_ptr->axis_extend_lo[i][j] = 0;\n      i_ptr->axis_extend_hi[i][j] = 0;\n    }\n    i_ptr->arg_type[i] = FLOAT_ARG;\n    strcpy(i_ptr->arg_name[i], \"\");\n    strcpy(i_ptr->arg_unit[i], \"\");\n    strcpy(i_ptr->arg_desc[i], \"\");\n  }\n\n  return return_val;\n\n}\n\n\n/* .... UtilityFunctions for dealing with STATIC_ExternalFunctionList .... */\n\n/*\n * Store the global values which will be needed by utility routines\n * in EF_ExternalUtil.c\n */\nvoid EF_store_globals(int *mr_list_ptr, int *cx_list_ptr,\n\tint *mres_ptr, DFTYPE *bad_flag_ptr)\n{\n  GLOBAL_mr_list_ptr = mr_list_ptr;\n  GLOBAL_cx_list_ptr = cx_list_ptr;\n  GLOBAL_mres_ptr = mres_ptr;\n  GLOBAL_bad_flag_ptr = bad_flag_ptr;\n}\nvoid FORTRAN(efcn_pass_arg_ptr)(int *iarg, DFTYPE *arg_ptr)\n{\n  int iarg_c = *iarg-1;   // FORTRAN index to c index\n\n  GLOBAL_arg_ptrs[iarg_c] = arg_ptr;\n}\n\nvoid FORTRAN(efcn_pass_res_ptr)(DFTYPE *res_ptr)\n{\n  GLOBAL_res_ptr = res_ptr;\n}\n\n\n/*\n * Find an external function based on an integer id\n * and return the pointer to the function.\n * Returns NULL if it fails.\n */\nExternalFunction *ef_ptr_from_id_ptr(int *id_ptr)\n{\n   ExternalFunction *ef_ptr;\n   int status;\n\n   /* Check if the list has been created to avoid a seg fault if called indiscriminately */\n   if ( STATIC_ExternalFunctionList == NULL ) {\n      return NULL;\n   }\n\n   /* Search the list for the function ID */\n   status = list_traverse(STATIC_ExternalFunctionList, (char *) id_ptr, EF_ListTraverse_FoundID,\n                          (LIST_FRNT | LIST_FORW | LIST_ALTR));\n   if ( status != LIST_OK ) {\n      return NULL;\n   }\n\n   /* Get the pointer to the function from the list */\n   ef_ptr = (ExternalFunction *) list_curr(STATIC_ExternalFunctionList);\n   return ef_ptr;\n}\n\n\nint EF_ListTraverse_fprintf( char *data, char *curr )\n{\n   ExternalFunction *ef_ptr=(ExternalFunction *)curr;\n\n   fprintf(stderr, \"path = \\\"%s\\\", name = \\\"%s\\\", id = %d, internals_ptr = %ld\\n\",\n\t   ef_ptr->path, ef_ptr->name, ef_ptr->id, (long) (ef_ptr->internals_ptr));\n\n   return TRUE;\n}\n\n\n/*\n * Ferret always capitalizes everything so we'd better\n * be case INsensitive.\n */\nint EF_ListTraverse_FoundName( char *data, char *curr )\n{\n  ExternalFunction *ef_ptr=(ExternalFunction *)curr;\n\n  if ( !strcasecmp(data, ef_ptr->name) ) {\n    return FALSE; /* found match */\n  } else\n    return TRUE;\n}\n\n\nint EF_ListTraverse_MatchTemplate( char data[], char *curr )\n{\n  ExternalFunction *ef_ptr=(ExternalFunction *)curr;\n\n  int i=0, star_skip=FALSE;\n  char upname[EF_MAX_DESCRIPTION_LENGTH];\n  char *t, *n;\n\n  for (i=0; i<strlen(ef_ptr->name); i++) {\n    upname[i] = toupper(ef_ptr->name[i]);\n  }\n  upname[i] = '\\0';\n\n  n = upname;\n\n  for (i=0, t=data; i<strlen(data); i++, t++) {\n\n    if ( *t == '*' ) {\n\n      star_skip = TRUE;\n      continue;\n\n    } else if ( *t == '?' ) {\n\n      if ( star_skip ) {\n\tcontinue;\n      } else {\n        n++;\n\tif ( *n == '\\0' ) /* end of name */\n\t  return TRUE; /* no match */\n\telse\n\t  continue;\n      }\n\n    } else if ( star_skip ) {\n\n      if ( (n = strchr(n, *t)) == NULL ) { /* character not found in rest of name */\n\treturn TRUE; /* no match */\n      } else {\n\tstar_skip = FALSE;\n      }\n\n    } else if ( *n == '\\0' ) /* end of name */\n      return TRUE; /* no match */\n\n    else if ( *t == *n ) {\n      n++;\n      continue;\n    }\n\n    else\n      return TRUE; /* no match */\n\n  }\n\n  /* *sh* if any non-wildcard characters remain in the \"curr\" name, then reject\n     probably a bug remains for a regexp ending in \"?\" */\n  if ( *n == '\\0' || star_skip )\n    return FALSE; /* got all the way through: a match */\n  else\n    return TRUE; /* characters remain--e.g. \"xx5\" does not math regexp \"xx\" */\n\n}\n\n\nint EF_ListTraverse_FoundID( char *data, char *curr )\n{\n  ExternalFunction *ef_ptr=(ExternalFunction *)curr;\n  int ID=*((int *)data);\n\n  if ( ID == ef_ptr->id ) {\n    return FALSE; /* found match */\n  } else\n    return TRUE;\n}\n\n\nint EF_Util_setsig(char fcn_name[])\n{\n    /*\n     * Prepare for bailout possibilities by setting a signal handler for\n     * SIGFPE, SIGSEGV, SIGINT and SIGBUS and then by cacheing the stack\n     * environment with sigsetjmp (for the signal handler) and setjmp\n     * (for the \"bail out\" utility function).\n     */\n\n    if ( (fpe_handler = signal(SIGFPE, EF_signal_handler)) == SIG_ERR ) {\n      fprintf(stderr, \"**ERROR in %s() catching SIGFPE.\\n\", fcn_name);\n      return 1;\n    }\n    if ( (segv_handler = signal(SIGSEGV, EF_signal_handler)) == SIG_ERR ) {\n      fprintf(stderr, \"**ERROR in %s() catching SIGSEGV.\\n\", fcn_name);\n      return 1;\n    }\n    if ( (int_handler = signal(SIGINT, EF_signal_handler)) == SIG_ERR ) {\n      fprintf(stderr, \"**ERROR in %s() catching SIGINT.\\n\", fcn_name);\n      return 1;\n    }\n    if ( (bus_handler = signal(SIGBUS, EF_signal_handler)) == SIG_ERR ) {\n      fprintf(stderr, \"**ERROR in %s() catching SIGBUS.\\n\", fcn_name);\n      return 1;\n    }\n\n    /* the setjmp and sigsetjmp code moved to in-line 10/00 --\n     * longjump returns cannot be made reliably into a subroutine that may\n     *no longer be active on the stack\n     */\n\n    return 0;\n}\n\n\nint EF_Util_ressig(char fcn_name[])\n{\n    /*\n     * Restore the old signal handlers.\n     */\n    if (signal(SIGFPE, (*fpe_handler)) == SIG_ERR) {\n      fprintf(stderr, \"**ERROR in %s() restoring default SIGFPE handler.\\n\", fcn_name);\n      return 1;\n    }\n    if (signal(SIGSEGV, (*segv_handler)) == SIG_ERR) {\n      fprintf(stderr, \"**ERROR in %s() restoring default SIGSEGV handler.\\n\", fcn_name);\n      return 1;\n    }\n    if (signal(SIGINT, (*int_handler)) == SIG_ERR) {\n      fprintf(stderr, \"**ERROR in %s() restoring default SIGINT handler.\\n\", fcn_name);\n      return 1;\n    }\n    if (signal(SIGBUS, (*bus_handler)) == SIG_ERR) {\n      fprintf(stderr, \"**ERROR in %s() restoring default SIGBUS handler.\\n\", fcn_name);\n      return 1;\n    }\n    return 0;\n}\n\n\n/*\n *  ------------------------------------\n\n *  internal_dlsym\n *  Accept a string and return the function pointer\n *\n *  The names of all subroutines of internally linked EF's\n *  generated by the perl script int_dlsym.pl.  Check the\n *  first if statement - change else if to if.\n *\n *   ACM 2-25-00 Solaris and OSF both have the trailing\n *   underscore for statically-linked routines. */\n\nstatic void *internal_dlsym(char *name) {\n\n/* ffta.F */\nif ( !strcmp(name,\"ffta_init_\") ) return (void *)FORTRAN(ffta_init);\nelse if ( !strcmp(name,\"ffta_custom_axes_\") ) return (void *)FORTRAN(ffta_custom_axes);\nelse if ( !strcmp(name,\"ffta_result_limits_\") ) return (void *)FORTRAN(ffta_result_limits);\nelse if ( !strcmp(name,\"ffta_work_size_\") ) return (void *)FORTRAN(ffta_work_size);\nelse if ( !strcmp(name,\"ffta_compute_\") ) return (void *)FORTRAN(ffta_compute);\n\n/* fftp.F */\nelse if ( !strcmp(name,\"fftp_init_\") ) return (void *)FORTRAN(fftp_init);\nelse if ( !strcmp(name,\"fftp_custom_axes_\") ) return (void *)FORTRAN(fftp_custom_axes);\nelse if ( !strcmp(name,\"fftp_result_limits_\") ) return (void *)FORTRAN(fftp_result_limits);\nelse if ( !strcmp(name,\"fftp_work_size_\") ) return (void *)FORTRAN(fftp_work_size);\nelse if ( !strcmp(name,\"fftp_compute_\") ) return (void *)FORTRAN(fftp_compute);\n\n/* fft_im.F */\nelse if ( !strcmp(name,\"fft_im_init_\") ) return (void *)FORTRAN(fft_im_init);\nelse if ( !strcmp(name,\"fft_im_custom_axes_\") ) return (void *)FORTRAN(fft_im_custom_axes);\nelse if ( !strcmp(name,\"fft_im_result_limits_\") ) return (void *)FORTRAN(fft_im_result_limits);\nelse if ( !strcmp(name,\"fft_im_work_size_\") ) return (void *)FORTRAN(fft_im_work_size);\nelse if ( !strcmp(name,\"fft_im_compute_\") ) return (void *)FORTRAN(fft_im_compute);\n\n/* fft_inverse.F */\nelse if ( !strcmp(name,\"fft_inverse_init_\") ) return (void *)FORTRAN(fft_inverse_init);\nelse if ( !strcmp(name,\"fft_inverse_result_limits_\") ) return (void *)FORTRAN(fft_inverse_result_limits);\nelse if ( !strcmp(name,\"fft_inverse_work_size_\") ) return (void *)FORTRAN(fft_inverse_work_size);\nelse if ( !strcmp(name,\"fft_inverse_compute_\") ) return (void *)FORTRAN(fft_inverse_compute);\n\n/* fft_re.F */\nelse if ( !strcmp(name,\"fft_re_init_\") ) return (void *)FORTRAN(fft_re_init);\nelse if ( !strcmp(name,\"fft_re_custom_axes_\") ) return (void *)FORTRAN(fft_re_custom_axes);\nelse if ( !strcmp(name,\"fft_re_result_limits_\") ) return (void *)FORTRAN(fft_re_result_limits);\nelse if ( !strcmp(name,\"fft_re_work_size_\") ) return (void *)FORTRAN(fft_re_work_size);\nelse if ( !strcmp(name,\"fft_re_compute_\") ) return (void *)FORTRAN(fft_re_compute);\n\n/* sampleij.F */\nelse if ( !strcmp(name,\"sampleij_init_\") ) return (void *)FORTRAN(sampleij_init);\nelse if ( !strcmp(name,\"sampleij_result_limits_\") ) return (void *)FORTRAN(sampleij_result_limits);\nelse if ( !strcmp(name,\"sampleij_work_size_\") ) return (void *)FORTRAN(sampleij_work_size);\nelse if ( !strcmp(name,\"sampleij_compute_\") ) return (void *)FORTRAN(sampleij_compute);\n\n\n/* samplei_multi.F */\nelse if ( !strcmp(name,\"samplei_multi_init_\") ) return (void *)FORTRAN(samplei_multi_init);\nelse if ( !strcmp(name,\"samplei_multi_result_limits_\") ) return (void *)FORTRAN(samplei_multi_result_limits);\nelse if ( !strcmp(name,\"samplei_multi_compute_\") ) return (void *)FORTRAN(samplei_multi_compute);\n\n/* samplej_multi.F */\nelse if ( !strcmp(name,\"samplej_multi_init_\") ) return (void *)FORTRAN(samplej_multi_init);\nelse if ( !strcmp(name,\"samplej_multi_result_limits_\") ) return (void *)FORTRAN(samplej_multi_result_limits);\nelse if ( !strcmp(name,\"samplej_multi_compute_\") ) return (void *)FORTRAN(samplej_multi_compute);\n\n/* samplek_multi.F */\nelse if ( !strcmp(name,\"samplek_multi_init_\") ) return (void *)FORTRAN(samplek_multi_init);\nelse if ( !strcmp(name,\"samplek_multi_result_limits_\") ) return (void *)FORTRAN(samplek_multi_result_limits);\nelse if ( !strcmp(name,\"samplek_multi_compute_\") ) return (void *)FORTRAN(samplek_multi_compute);\n\n/* samplel_multi.F */\nelse if ( !strcmp(name,\"samplel_multi_init_\") ) return (void *)FORTRAN(samplel_multi_init);\nelse if ( !strcmp(name,\"samplel_multi_result_limits_\") ) return (void *)FORTRAN(samplel_multi_result_limits);\nelse if ( !strcmp(name,\"samplel_multi_compute_\") ) return (void *)FORTRAN(samplel_multi_compute);\n\n/* samplem_multi.F */\nelse if ( !strcmp(name,\"samplem_multi_init_\") ) return (void *)FORTRAN(samplem_multi_init);\nelse if ( !strcmp(name,\"samplem_multi_result_limits_\") ) return (void *)FORTRAN(samplem_multi_result_limits);\nelse if ( !strcmp(name,\"samplem_multi_compute_\") ) return (void *)FORTRAN(samplem_multi_compute);\n\n/* samplen_multi.F */\nelse if ( !strcmp(name,\"samplen_multi_init_\") ) return (void *)FORTRAN(samplen_multi_init);\nelse if ( !strcmp(name,\"samplen_multi_result_limits_\") ) return (void *)FORTRAN(samplen_multi_result_limits);\nelse if ( !strcmp(name,\"samplen_multi_compute_\") ) return (void *)FORTRAN(samplen_multi_compute);\n\n/* samplet_date.F */\nelse if ( !strcmp(name,\"samplet_date_init_\") ) return (void *)FORTRAN(samplet_date_init);\nelse if ( !strcmp(name,\"samplet_date_result_limits_\") ) return (void *)FORTRAN(samplet_date_result_limits);\nelse if ( !strcmp(name,\"samplet_date_work_size_\") ) return (void *)FORTRAN(samplet_date_work_size);\nelse if ( !strcmp(name,\"samplet_date_compute_\") ) return (void *)FORTRAN(samplet_date_compute);\n\n/* samplef_date.F */\nelse if ( !strcmp(name,\"samplef_date_init_\") ) return (void *)FORTRAN(samplef_date_init);\nelse if ( !strcmp(name,\"samplef_date_result_limits_\") ) return (void *)FORTRAN(samplef_date_result_limits);\nelse if ( !strcmp(name,\"samplef_date_work_size_\") ) return (void *)FORTRAN(samplef_date_work_size);\nelse if ( !strcmp(name,\"samplef_date_compute_\") ) return (void *)FORTRAN(samplef_date_compute);\n\n/* samplexy.F */\nelse if ( !strcmp(name,\"samplexy_init_\") ) return (void *)FORTRAN(samplexy_init);\nelse if ( !strcmp(name,\"samplexy_result_limits_\") ) return (void *)FORTRAN(samplexy_result_limits);\nelse if ( !strcmp(name,\"samplexy_work_size_\") ) return (void *)FORTRAN(samplexy_work_size);\nelse if ( !strcmp(name,\"samplexy_compute_\") ) return (void *)FORTRAN(samplexy_compute);\n\n/* samplexyt.F */\nelse if ( !strcmp(name,\"samplexyt_init_\") ) return (void *)FORTRAN(samplexyt_init);\nelse if ( !strcmp(name,\"samplexyt_result_limits_\") ) return (void *)FORTRAN(samplexyt_result_limits);\nelse if ( !strcmp(name,\"samplexyt_work_size_\") ) return (void *)FORTRAN(samplexyt_work_size);\nelse if ( !strcmp(name,\"samplexyt_compute_\") ) return (void *)FORTRAN(samplexyt_compute);\n\n/* samplexyt_nrst.F */\nelse if ( !strcmp(name,\"samplexyt_nrst_init_\") ) return (void *)FORTRAN(samplexyt_nrst_init);\nelse if ( !strcmp(name,\"samplexyt_nrst_result_limits_\") ) return (void *)FORTRAN(samplexyt_nrst_result_limits);\nelse if ( !strcmp(name,\"samplexyt_nrst_work_size_\") ) return (void *)FORTRAN(samplexyt_nrst_work_size);\nelse if ( !strcmp(name,\"samplexyt_nrst_compute_\") ) return (void *)FORTRAN(samplexyt_nrst_compute);\n\n/* samplexy_curv.F */\nelse if ( !strcmp(name,\"samplexy_curv_init_\") ) return (void *)FORTRAN(samplexy_curv_init);\nelse if ( !strcmp(name,\"samplexy_curv_result_limits_\") ) return (void *)FORTRAN(samplexy_curv_result_limits);\nelse if ( !strcmp(name,\"samplexy_curv_work_size_\") ) return (void *)FORTRAN(samplexy_curv_work_size);\nelse if ( !strcmp(name,\"samplexy_curv_compute_\") ) return (void *)FORTRAN(samplexy_curv_compute);\n\n/* samplexy_curv_avg.F */\nelse if ( !strcmp(name,\"samplexy_curv_avg_init_\") ) return (void *)FORTRAN(samplexy_curv_avg_init);\nelse if ( !strcmp(name,\"samplexy_curv_avg_result_limits_\") ) return (void *)FORTRAN(samplexy_curv_avg_result_limits);\nelse if ( !strcmp(name,\"samplexy_curv_avg_work_size_\") ) return (void *)FORTRAN(samplexy_curv_avg_work_size);\nelse if ( !strcmp(name,\"samplexy_curv_avg_compute_\") ) return (void *)FORTRAN(samplexy_curv_avg_compute);\n\n/* samplexy_curv_nrst.F */\nelse if ( !strcmp(name,\"samplexy_curv_nrst_init_\") ) return (void *)FORTRAN(samplexy_curv_nrst_init);\nelse if ( !strcmp(name,\"samplexy_curv_nrst_result_limits_\") ) return (void *)FORTRAN(samplexy_curv_nrst_result_limits);\nelse if ( !strcmp(name,\"samplexy_curv_nrst_work_size_\") ) return (void *)FORTRAN(samplexy_curv_nrst_work_size);\nelse if ( !strcmp(name,\"samplexy_curv_nrst_compute_\") ) return (void *)FORTRAN(samplexy_curv_nrst_compute);\n\n/* samplexy_closest.F */\nelse if ( !strcmp(name,\"samplexy_closest_init_\") ) return (void *)FORTRAN(samplexy_closest_init);\nelse if ( !strcmp(name,\"samplexy_closest_result_limits_\") ) return (void *)FORTRAN(samplexy_closest_result_limits);\nelse if ( !strcmp(name,\"samplexy_closest_work_size_\") ) return (void *)FORTRAN(samplexy_closest_work_size);\nelse if ( !strcmp(name,\"samplexy_closest_compute_\") ) return (void *)FORTRAN(samplexy_closest_compute);\n\n/* samplexy_nrst.F */\nelse if ( !strcmp(name,\"samplexy_nrst_init_\") ) return (void *)FORTRAN(samplexy_nrst_init);\nelse if ( !strcmp(name,\"samplexy_nrst_result_limits_\") ) return (void *)FORTRAN(samplexy_nrst_result_limits);\nelse if ( !strcmp(name,\"samplexy_nrst_work_size_\") ) return (void *)FORTRAN(samplexy_nrst_work_size);\nelse if ( !strcmp(name,\"samplexy_nrst_compute_\") ) return (void *)FORTRAN(samplexy_nrst_compute);\n\n/* samplexz.F */\nelse if ( !strcmp(name,\"samplexz_init_\") ) return (void *)FORTRAN(samplexz_init);\nelse if ( !strcmp(name,\"samplexz_result_limits_\") ) return (void *)FORTRAN(samplexz_result_limits);\nelse if ( !strcmp(name,\"samplexz_work_size_\") ) return (void *)FORTRAN(samplexz_work_size);\nelse if ( !strcmp(name,\"samplexz_compute_\") ) return (void *)FORTRAN(samplexz_compute);\n\n/* sampleyz.F */\nelse if ( !strcmp(name,\"sampleyz_init_\") ) return (void *)FORTRAN(sampleyz_init);\nelse if ( !strcmp(name,\"sampleyz_result_limits_\") ) return (void *)FORTRAN(sampleyz_result_limits);\nelse if ( !strcmp(name,\"sampleyz_work_size_\") ) return (void *)FORTRAN(sampleyz_work_size);\nelse if ( !strcmp(name,\"sampleyz_compute_\") ) return (void *)FORTRAN(sampleyz_compute);\n\n/* scat2grid_bin_xy.F */\nelse if ( !strcmp(name,\"scat2grid_bin_xy_init_\") ) return (void *)FORTRAN(scat2grid_bin_xy_init);\nelse if ( !strcmp(name,\"scat2grid_bin_xy_work_size_\") ) return (void *)FORTRAN(scat2grid_bin_xy_work_size);\nelse if ( !strcmp(name,\"scat2grid_bin_xy_compute_\") ) return (void *)FORTRAN(scat2grid_bin_xy_compute);\n\n/* scat2grid_bin_xyt.F */\nelse if ( !strcmp(name,\"scat2grid_bin_xyt_init_\") ) return (void *)FORTRAN(scat2grid_bin_xyt_init);\nelse if ( !strcmp(name,\"scat2grid_bin_xyt_work_size_\") ) return (void *)FORTRAN(scat2grid_bin_xyt_work_size);\nelse if ( !strcmp(name,\"scat2grid_bin_xyt_compute_\") ) return (void *)FORTRAN(scat2grid_bin_xyt_compute);\n\n/* scat2grid_bin_xyz.F */\nelse if ( !strcmp(name,\"scat2grid_bin_xyz_init_\") ) return (void *)FORTRAN(scat2grid_bin_xyz_init);\nelse if ( !strcmp(name,\"scat2grid_bin_xyz_work_size_\") ) return (void *)FORTRAN(scat2grid_bin_xyz_work_size);\nelse if ( !strcmp(name,\"scat2grid_bin_xyz_compute_\") ) return (void *)FORTRAN(scat2grid_bin_xyz_compute);\n\n/* scat2grid_bin_xyzt.F */\nelse if ( !strcmp(name,\"scat2grid_bin_xyzt_init_\") ) return (void *)FORTRAN(scat2grid_bin_xyzt_init);\nelse if ( !strcmp(name,\"scat2grid_bin_xyzt_work_size_\") ) return (void *)FORTRAN(scat2grid_bin_xyzt_work_size);\nelse if ( !strcmp(name,\"scat2grid_bin_xyzt_compute_\") ) return (void *)FORTRAN(scat2grid_bin_xyzt_compute);\n\n/* scat2grid_nbin_xy.F */\nelse if ( !strcmp(name,\"scat2grid_nbin_xy_init_\") ) return (void *)FORTRAN(scat2grid_nbin_xy_init);\nelse if ( !strcmp(name,\"scat2grid_nbin_xy_work_size_\") ) return (void *)FORTRAN(scat2grid_nbin_xy_work_size);\nelse if ( !strcmp(name,\"scat2grid_nbin_xy_compute_\") ) return (void *)FORTRAN(scat2grid_nbin_xy_compute);\n\n/* scat2grid_nbin_xyt.F */\nelse if ( !strcmp(name,\"scat2grid_nbin_xyt_init_\") ) return (void *)FORTRAN(scat2grid_nbin_xyt_init);\nelse if ( !strcmp(name,\"scat2grid_nbin_xyt_work_size_\") ) return (void *)FORTRAN(scat2grid_nbin_xyt_work_size);\nelse if ( !strcmp(name,\"scat2grid_nbin_xyt_compute_\") ) return (void *)FORTRAN(scat2grid_nbin_xyt_compute);\n\n/* scat2gridgauss_xy.F */\nelse if ( !strcmp(name,\"scat2gridgauss_xy_init_\") ) return (void *)FORTRAN(scat2gridgauss_xy_init);\nelse if ( !strcmp(name,\"scat2gridgauss_xy_work_size_\") ) return (void *)FORTRAN(scat2gridgauss_xy_work_size);\nelse if ( !strcmp(name,\"scat2gridgauss_xy_compute_\") ) return (void *)FORTRAN(scat2gridgauss_xy_compute);\n\n/* scat2gridgauss_xz.F */\nelse if ( !strcmp(name,\"scat2gridgauss_xz_init_\") ) return (void *)FORTRAN(scat2gridgauss_xz_init);\nelse if ( !strcmp(name,\"scat2gridgauss_xz_work_size_\") ) return (void *)FORTRAN(scat2gridgauss_xz_work_size);\nelse if ( !strcmp(name,\"scat2gridgauss_xz_compute_\") ) return (void *)FORTRAN(scat2gridgauss_xz_compute);\n\n/* scat2gridgauss_yz.F */\nelse if ( !strcmp(name,\"scat2gridgauss_yz_init_\") ) return (void *)FORTRAN(scat2gridgauss_yz_init);\nelse if ( !strcmp(name,\"scat2gridgauss_yz_work_size_\") ) return (void *)FORTRAN(scat2gridgauss_yz_work_size);\nelse if ( !strcmp(name,\"scat2gridgauss_yz_compute_\") ) return (void *)FORTRAN(scat2gridgauss_yz_compute);\n\n/* scat2gridgauss_xt.F */\nelse if ( !strcmp(name,\"scat2gridgauss_xt_init_\") ) return (void *)FORTRAN(scat2gridgauss_xt_init);\nelse if ( !strcmp(name,\"scat2gridgauss_xt_work_size_\") ) return (void *)FORTRAN(scat2gridgauss_xt_work_size);\nelse if ( !strcmp(name,\"scat2gridgauss_xt_compute_\") ) return (void *)FORTRAN(scat2gridgauss_xt_compute);\n\n/* scat2gridgauss_yt.F */\nelse if ( !strcmp(name,\"scat2gridgauss_yt_init_\") ) return (void *)FORTRAN(scat2gridgauss_yt_init);\nelse if ( !strcmp(name,\"scat2gridgauss_yt_work_size_\") ) return (void *)FORTRAN(scat2gridgauss_yt_work_size);\nelse if ( !strcmp(name,\"scat2gridgauss_yt_compute_\") ) return (void *)FORTRAN(scat2gridgauss_yt_compute);\n\n/* scat2gridgauss_zt.F */\nelse if ( !strcmp(name,\"scat2gridgauss_zt_init_\") ) return (void *)FORTRAN(scat2gridgauss_zt_init);\nelse if ( !strcmp(name,\"scat2gridgauss_zt_work_size_\") ) return (void *)FORTRAN(scat2gridgauss_zt_work_size);\nelse if ( !strcmp(name,\"scat2gridgauss_zt_compute_\") ) return (void *)FORTRAN(scat2gridgauss_zt_compute);\n\n/* scat2gridgauss_xy_v0.F */\nelse if ( !strcmp(name,\"scat2gridgauss_xy_v0_init_\") ) return (void *)FORTRAN(scat2gridgauss_xy_v0_init);\nelse if ( !strcmp(name,\"scat2gridgauss_xy_v0_work_size_\") ) return (void *)FORTRAN(scat2gridgauss_xy_v0_work_size);\nelse if ( !strcmp(name,\"scat2gridgauss_xy_v0_compute_\") ) return (void *)FORTRAN(scat2gridgauss_xy_v0_compute);\n\n/* scat2gridgauss_xz.F */\nelse if ( !strcmp(name,\"scat2gridgauss_xz_v0_init_\") ) return (void *)FORTRAN(scat2gridgauss_xz_v0_init);\nelse if ( !strcmp(name,\"scat2gridgauss_xz_v0_work_size_\") ) return (void *)FORTRAN(scat2gridgauss_xz_v0_work_size);\nelse if ( !strcmp(name,\"scat2gridgauss_xz_v0_compute_\") ) return (void *)FORTRAN(scat2gridgauss_xz_v0_compute);\n\n/* scat2gridgauss_yz.F */\nelse if ( !strcmp(name,\"scat2gridgauss_yz_v0_init_\") ) return (void *)FORTRAN(scat2gridgauss_yz_v0_init);\nelse if ( !strcmp(name,\"scat2gridgauss_yz_v0_work_size_\") ) return (void *)FORTRAN(scat2gridgauss_yz_v0_work_size);\nelse if ( !strcmp(name,\"scat2gridgauss_yz_v0_compute_\") ) return (void *)FORTRAN(scat2gridgauss_yz_v0_compute);\n\n/* scat2gridgauss_xt.F */\nelse if ( !strcmp(name,\"scat2gridgauss_xt_v0_init_\") ) return (void *)FORTRAN(scat2gridgauss_xt_v0_init);\nelse if ( !strcmp(name,\"scat2gridgauss_xt_v0_work_size_\") ) return (void *)FORTRAN(scat2gridgauss_xt_v0_work_size);\nelse if ( !strcmp(name,\"scat2gridgauss_xt_v0_compute_\") ) return (void *)FORTRAN(scat2gridgauss_xt_v0_compute);\n\n/* scat2gridgauss_yt.F */\nelse if ( !strcmp(name,\"scat2gridgauss_yt_v0_init_\") ) return (void *)FORTRAN(scat2gridgauss_yt_v0_init);\nelse if ( !strcmp(name,\"scat2gridgauss_yt_v0_work_size_\") ) return (void *)FORTRAN(scat2gridgauss_yt_v0_work_size);\nelse if ( !strcmp(name,\"scat2gridgauss_yt_v0_compute_\") ) return (void *)FORTRAN(scat2gridgauss_yt_v0_compute);\n\n/* scat2gridgauss_zt.F */\nelse if ( !strcmp(name,\"scat2gridgauss_zt_v0_init_\") ) return (void *)FORTRAN(scat2gridgauss_zt_v0_init);\nelse if ( !strcmp(name,\"scat2gridgauss_zt_v0_work_size_\") ) return (void *)FORTRAN(scat2gridgauss_zt_v0_work_size);\nelse if ( !strcmp(name,\"scat2gridgauss_zt_v0_compute_\") ) return (void *)FORTRAN(scat2gridgauss_zt_v0_compute);\n\n/* scat2gridlaplace_xy.F */\nelse if ( !strcmp(name,\"scat2gridlaplace_xy_init_\") ) return (void *)FORTRAN(scat2gridlaplace_xy_init);\nelse if ( !strcmp(name,\"scat2gridlaplace_xy_work_size_\") ) return (void *)FORTRAN(scat2gridlaplace_xy_work_size);\nelse if ( !strcmp(name,\"scat2gridlaplace_xy_compute_\") ) return (void *)FORTRAN(scat2gridlaplace_xy_compute);\n\n/* scat2gridlaplace_xz.F */\nelse if ( !strcmp(name,\"scat2gridlaplace_xz_init_\") ) return (void *)FORTRAN(scat2gridlaplace_xz_init);\nelse if ( !strcmp(name,\"scat2gridlaplace_xz_work_size_\") ) return (void *)FORTRAN(scat2gridlaplace_xz_work_size);\nelse if ( !strcmp(name,\"scat2gridlaplace_xz_compute_\") ) return (void *)FORTRAN(scat2gridlaplace_xz_compute);\n\n/* scat2gridlaplace_yz.F */\nelse if ( !strcmp(name,\"scat2gridlaplace_yz_init_\") ) return (void *)FORTRAN(scat2gridlaplace_yz_init);\nelse if ( !strcmp(name,\"scat2gridlaplace_yz_work_size_\") ) return (void *)FORTRAN(scat2gridlaplace_yz_work_size);\nelse if ( !strcmp(name,\"scat2gridlaplace_yz_compute_\") ) return (void *)FORTRAN(scat2gridlaplace_yz_compute);\n\n/* scat2gridlaplace_xt.F */\nelse if ( !strcmp(name,\"scat2gridlaplace_xt_init_\") ) return (void *)FORTRAN(scat2gridlaplace_xt_init);\nelse if ( !strcmp(name,\"scat2gridlaplace_xt_work_size_\") ) return (void *)FORTRAN(scat2gridlaplace_xt_work_size);\nelse if ( !strcmp(name,\"scat2gridlaplace_xt_compute_\") ) return (void *)FORTRAN(scat2gridlaplace_xt_compute);\n\n/* scat2gridlaplace_yt.F */\nelse if ( !strcmp(name,\"scat2gridlaplace_yt_init_\") ) return (void *)FORTRAN(scat2gridlaplace_yt_init);\nelse if ( !strcmp(name,\"scat2gridlaplace_yt_work_size_\") ) return (void *)FORTRAN(scat2gridlaplace_yt_work_size);\nelse if ( !strcmp(name,\"scat2gridlaplace_yt_compute_\") ) return (void *)FORTRAN(scat2gridlaplace_yt_compute);\n\n/* scat2gridlaplace_zt.F */\nelse if ( !strcmp(name,\"scat2gridlaplace_zt_init_\") ) return (void *)FORTRAN(scat2gridlaplace_zt_init);\nelse if ( !strcmp(name,\"scat2gridlaplace_zt_work_size_\") ) return (void *)FORTRAN(scat2gridlaplace_zt_work_size);\nelse if ( !strcmp(name,\"scat2gridlaplace_zt_compute_\") ) return (void *)FORTRAN(scat2gridlaplace_zt_compute);\n\n/* scat2grid_nobs_xy.F */\nelse if ( !strcmp(name,\"scat2grid_nobs_xy_init_\") ) return (void *)FORTRAN(scat2grid_nobs_xy_init);\nelse if ( !strcmp(name,\"scat2grid_nobs_xy_work_size_\") ) return (void *)FORTRAN(scat2grid_nobs_xy_work_size);\nelse if ( !strcmp(name,\"scat2grid_nobs_xy_compute_\") ) return (void *)FORTRAN(scat2grid_nobs_xy_compute);\n\nelse if ( !strcmp(name,\"scat2grid_nobs_xyt_init_\") ) return (void *)FORTRAN(scat2grid_nobs_xyt_init);\nelse if ( !strcmp(name,\"scat2grid_nobs_xyt_work_size_\") ) return (void *)FORTRAN(scat2grid_nobs_xyt_work_size);\nelse if ( !strcmp(name,\"scat2grid_nobs_xyt_compute_\") ) return (void *)FORTRAN(scat2grid_nobs_xyt_compute);\n\n/* sorti.F */\nelse if ( !strcmp(name,\"sorti_init_\") ) return (void *)FORTRAN(sorti_init);\nelse if ( !strcmp(name,\"sorti_result_limits_\") ) return (void *)FORTRAN(sorti_result_limits);\nelse if ( !strcmp(name,\"sorti_work_size_\") ) return (void *)FORTRAN(sorti_work_size);\nelse if ( !strcmp(name,\"sorti_compute_\") ) return (void *)FORTRAN(sorti_compute);\n\n/* sorti_str.F */\nelse if ( !strcmp(name,\"sorti_str_init_\") ) return (void *)FORTRAN(sorti_str_init);\nelse if ( !strcmp(name,\"sorti_str_result_limits_\") ) return (void *)FORTRAN(sorti_str_result_limits);\nelse if ( !strcmp(name,\"sorti_str_work_size_\") ) return (void *)FORTRAN(sorti_str_work_size);\nelse if ( !strcmp(name,\"sorti_str_compute_\") ) return (void *)FORTRAN(sorti_str_compute);\n\n/* sortj.F */\nelse if ( !strcmp(name,\"sortj_init_\") ) return (void *)FORTRAN(sortj_init);\nelse if ( !strcmp(name,\"sortj_result_limits_\") ) return (void *)FORTRAN(sortj_result_limits);\nelse if ( !strcmp(name,\"sortj_work_size_\") ) return (void *)FORTRAN(sortj_work_size);\nelse if ( !strcmp(name,\"sortj_compute_\") ) return (void *)FORTRAN(sortj_compute);\n\n/* sortj_str.F */\nelse if ( !strcmp(name,\"sortj_str_init_\") ) return (void *)FORTRAN(sortj_str_init);\nelse if ( !strcmp(name,\"sortj_str_result_limits_\") ) return (void *)FORTRAN(sortj_str_result_limits);\nelse if ( !strcmp(name,\"sortj_str_work_size_\") ) return (void *)FORTRAN(sortj_str_work_size);\nelse if ( !strcmp(name,\"sortj_str_compute_\") ) return (void *)FORTRAN(sortj_str_compute);\n\n/* sortk.F */\nelse if ( !strcmp(name,\"sortk_init_\") ) return (void *)FORTRAN(sortk_init);\nelse if ( !strcmp(name,\"sortk_result_limits_\") ) return (void *)FORTRAN(sortk_result_limits);\nelse if ( !strcmp(name,\"sortk_work_size_\") ) return (void *)FORTRAN(sortk_work_size);\nelse if ( !strcmp(name,\"sortk_compute_\") ) return (void *)FORTRAN(sortk_compute);\n\n/* sortk_str.F */\nelse if ( !strcmp(name,\"sortk_str_init_\") ) return (void *)FORTRAN(sortk_str_init);\nelse if ( !strcmp(name,\"sortk_str_result_limits_\") ) return (void *)FORTRAN(sortk_str_result_limits);\nelse if ( !strcmp(name,\"sortk_str_work_size_\") ) return (void *)FORTRAN(sortk_str_work_size);\nelse if ( !strcmp(name,\"sortk_str_compute_\") ) return (void *)FORTRAN(sortk_str_compute);\n\n/* sortl.F */\nelse if ( !strcmp(name,\"sortl_init_\") ) return (void *)FORTRAN(sortl_init);\nelse if ( !strcmp(name,\"sortl_result_limits_\") ) return (void *)FORTRAN(sortl_result_limits);\nelse if ( !strcmp(name,\"sortl_work_size_\") ) return (void *)FORTRAN(sortl_work_size);\nelse if ( !strcmp(name,\"sortl_compute_\") ) return (void *)FORTRAN(sortl_compute);\n\n/* sortl_str.F */\nelse if ( !strcmp(name,\"sortl_str_init_\") ) return (void *)FORTRAN(sortl_str_init);\nelse if ( !strcmp(name,\"sortl_str_result_limits_\") ) return (void *)FORTRAN(sortl_str_result_limits);\nelse if ( !strcmp(name,\"sortl_str_work_size_\") ) return (void *)FORTRAN(sortl_str_work_size);\nelse if ( !strcmp(name,\"sortl_str_compute_\") ) return (void *)FORTRAN(sortl_str_compute);\n\n/* sortm.F */\nelse if ( !strcmp(name,\"sortm_init_\") ) return (void *)FORTRAN(sortm_init);\nelse if ( !strcmp(name,\"sortm_result_limits_\") ) return (void *)FORTRAN(sortm_result_limits);\nelse if ( !strcmp(name,\"sortm_work_size_\") ) return (void *)FORTRAN(sortm_work_size);\nelse if ( !strcmp(name,\"sortm_compute_\") ) return (void *)FORTRAN(sortm_compute);\n\n/* sortm_str.F */\nelse if ( !strcmp(name,\"sortm_str_init_\") ) return (void *)FORTRAN(sortm_str_init);\nelse if ( !strcmp(name,\"sortm_str_result_limits_\") ) return (void *)FORTRAN(sortm_str_result_limits);\nelse if ( !strcmp(name,\"sortm_str_work_size_\") ) return (void *)FORTRAN(sortm_str_work_size);\nelse if ( !strcmp(name,\"sortm_str_compute_\") ) return (void *)FORTRAN(sortm_str_compute);\n\n/* sortn.F */\nelse if ( !strcmp(name,\"sortn_init_\") ) return (void *)FORTRAN(sortn_init);\nelse if ( !strcmp(name,\"sortn_result_limits_\") ) return (void *)FORTRAN(sortn_result_limits);\nelse if ( !strcmp(name,\"sortn_work_size_\") ) return (void *)FORTRAN(sortn_work_size);\nelse if ( !strcmp(name,\"sortn_compute_\") ) return (void *)FORTRAN(sortn_compute);\n\n/* sortn_str.F */\nelse if ( !strcmp(name,\"sortn_str_init_\") ) return (void *)FORTRAN(sortn_str_init);\nelse if ( !strcmp(name,\"sortn_str_result_limits_\") ) return (void *)FORTRAN(sortn_str_result_limits);\nelse if ( !strcmp(name,\"sortn_str_work_size_\") ) return (void *)FORTRAN(sortn_str_work_size);\nelse if ( !strcmp(name,\"sortn_str_compute_\") ) return (void *)FORTRAN(sortn_str_compute);\n\n/* tauto_cor.F */\nelse if ( !strcmp(name,\"tauto_cor_init_\") ) return (void *)FORTRAN(tauto_cor_init);\nelse if ( !strcmp(name,\"tauto_cor_result_limits_\") ) return (void *)FORTRAN(tauto_cor_result_limits);\nelse if ( !strcmp(name,\"tauto_cor_work_size_\") ) return (void *)FORTRAN(tauto_cor_work_size);\nelse if ( !strcmp(name,\"tauto_cor_compute_\") ) return (void *)FORTRAN(tauto_cor_compute);\n\n/* xauto_cor.F */\nelse if ( !strcmp(name,\"xauto_cor_init_\") ) return (void *)FORTRAN(xauto_cor_init);\nelse if ( !strcmp(name,\"xauto_cor_result_limits_\") ) return (void *)FORTRAN(xauto_cor_result_limits);\nelse if ( !strcmp(name,\"xauto_cor_work_size_\") ) return (void *)FORTRAN(xauto_cor_work_size);\nelse if ( !strcmp(name,\"xauto_cor_compute_\") ) return (void *)FORTRAN(xauto_cor_compute);\n\n/* eof_space.F */\nelse if ( !strcmp(name,\"eof_space_init_\") ) return (void *)FORTRAN(eof_space_init);\nelse if ( !strcmp(name,\"eof_space_result_limits_\") ) return (void *)FORTRAN(eof_space_result_limits);\nelse if ( !strcmp(name,\"eof_space_work_size_\") ) return (void *)FORTRAN(eof_space_work_size);\nelse if ( !strcmp(name,\"eof_space_compute_\") ) return (void *)FORTRAN(eof_space_compute);\n\n/* eof_stat.F */\nelse if ( !strcmp(name,\"eof_stat_init_\") ) return (void *)FORTRAN(eof_stat_init);\nelse if ( !strcmp(name,\"eof_stat_result_limits_\") ) return (void *)FORTRAN(eof_stat_result_limits);\nelse if ( !strcmp(name,\"eof_stat_work_size_\") ) return (void *)FORTRAN(eof_stat_work_size);\nelse if ( !strcmp(name,\"eof_stat_compute_\") ) return (void *)FORTRAN(eof_stat_compute);\n\n/* eof_tfunc.F */\nelse if ( !strcmp(name,\"eof_tfunc_init_\") ) return (void *)FORTRAN(eof_tfunc_init);\nelse if ( !strcmp(name,\"eof_tfunc_result_limits_\") ) return (void *)FORTRAN(eof_tfunc_result_limits);\nelse if ( !strcmp(name,\"eof_tfunc_work_size_\") ) return (void *)FORTRAN(eof_tfunc_work_size);\nelse if ( !strcmp(name,\"eof_tfunc_compute_\") ) return (void *)FORTRAN(eof_tfunc_compute);\n\n/* eofsvd_space.F */\nelse if ( !strcmp(name,\"eofsvd_space_init_\") ) return (void *)FORTRAN(eofsvd_space_init);\nelse if ( !strcmp(name,\"eofsvd_space_result_limits_\") ) return (void *)FORTRAN(eofsvd_space_result_limits);\nelse if ( !strcmp(name,\"eofsvd_space_work_size_\") ) return (void *)FORTRAN(eofsvd_space_work_size);\nelse if ( !strcmp(name,\"eofsvd_space_compute_\") ) return (void *)FORTRAN(eofsvd_space_compute);\n\n/* eofsvd_stat.F */\nelse if ( !strcmp(name,\"eofsvd_stat_init_\") ) return (void *)FORTRAN(eofsvd_stat_init);\nelse if ( !strcmp(name,\"eofsvd_stat_result_limits_\") ) return (void *)FORTRAN(eofsvd_stat_result_limits);\nelse if ( !strcmp(name,\"eofsvd_stat_work_size_\") ) return (void *)FORTRAN(eofsvd_stat_work_size);\nelse if ( !strcmp(name,\"eofsvd_stat_compute_\") ) return (void *)FORTRAN(eofsvd_stat_compute);\n\n/* eofsvd_tfunc.F */\nelse if ( !strcmp(name,\"eofsvd_tfunc_init_\") ) return (void *)FORTRAN(eofsvd_tfunc_init);\nelse if ( !strcmp(name,\"eofsvd_tfunc_result_limits_\") ) return (void *)FORTRAN(eofsvd_tfunc_result_limits);\nelse if ( !strcmp(name,\"eofsvd_tfunc_work_size_\") ) return (void *)FORTRAN(eofsvd_tfunc_work_size);\nelse if ( !strcmp(name,\"eofsvd_tfunc_compute_\") ) return (void *)FORTRAN(eofsvd_tfunc_compute);\n\n/* compressi.F */\nelse if ( !strcmp(name,\"compressi_init_\") ) return (void *)FORTRAN(compressi_init);\nelse if ( !strcmp(name,\"compressi_result_limits_\") ) return (void *)FORTRAN(compressi_result_limits);\nelse if ( !strcmp(name,\"compressi_compute_\") ) return (void *)FORTRAN(compressi_compute);\n\n/* compressj.F */\nelse if ( !strcmp(name,\"compressj_init_\") ) return (void *)FORTRAN(compressj_init);\nelse if ( !strcmp(name,\"compressj_result_limits_\") ) return (void *)FORTRAN(compressj_result_limits);\nelse if ( !strcmp(name,\"compressj_compute_\") ) return (void *)FORTRAN(compressj_compute);\n\n/* compressk.F */\nelse if ( !strcmp(name,\"compressk_init_\") ) return (void *)FORTRAN(compressk_init);\nelse if ( !strcmp(name,\"compressk_result_limits_\") ) return (void *)FORTRAN(compressk_result_limits);\nelse if ( !strcmp(name,\"compressk_compute_\") ) return (void *)FORTRAN(compressk_compute);\n\n/* compressl.F */\nelse if ( !strcmp(name,\"compressl_init_\") ) return (void *)FORTRAN(compressl_init);\nelse if ( !strcmp(name,\"compressl_result_limits_\") ) return (void *)FORTRAN(compressl_result_limits);\nelse if ( !strcmp(name,\"compressl_compute_\") ) return (void *)FORTRAN(compressl_compute);\n\n/* compressm.F */\nelse if ( !strcmp(name,\"compressm_init_\") ) return (void *)FORTRAN(compressm_init);\nelse if ( !strcmp(name,\"compressm_result_limits_\") ) return (void *)FORTRAN(compressm_result_limits);\nelse if ( !strcmp(name,\"compressm_compute_\") ) return (void *)FORTRAN(compressm_compute);\n\n/* compressn.F */\nelse if ( !strcmp(name,\"compressn_init_\") ) return (void *)FORTRAN(compressn_init);\nelse if ( !strcmp(name,\"compressn_result_limits_\") ) return (void *)FORTRAN(compressn_result_limits);\nelse if ( !strcmp(name,\"compressn_compute_\") ) return (void *)FORTRAN(compressn_compute);\n\n/* compressi_by.F */\nelse if ( !strcmp(name,\"compressi_by_init_\") ) return (void *)FORTRAN(compressi_by_init);\nelse if ( !strcmp(name,\"compressi_by_result_limits_\") ) return (void *)FORTRAN(compressi_by_result_limits);\nelse if ( !strcmp(name,\"compressi_by_compute_\") ) return (void *)FORTRAN(compressi_by_compute);\n\n/* compressj_by.F */\nelse if ( !strcmp(name,\"compressj_by_init_\") ) return (void *)FORTRAN(compressj_by_init);\nelse if ( !strcmp(name,\"compressj_by_result_limits_\") ) return (void *)FORTRAN(compressj_by_result_limits);\nelse if ( !strcmp(name,\"compressj_by_compute_\") ) return (void *)FORTRAN(compressj_by_compute);\n\n/* compressk_by.F */\nelse if ( !strcmp(name,\"compressk_by_init_\") ) return (void *)FORTRAN(compressk_by_init);\nelse if ( !strcmp(name,\"compressk_by_result_limits_\") ) return (void *)FORTRAN(compressk_by_result_limits);\nelse if ( !strcmp(name,\"compressk_by_compute_\") ) return (void *)FORTRAN(compressk_by_compute);\n\n/* compressl_by.F */\nelse if ( !strcmp(name,\"compressl_by_init_\") ) return (void *)FORTRAN(compressl_by_init);\nelse if ( !strcmp(name,\"compressl_by_result_limits_\") ) return (void *)FORTRAN(compressl_by_result_limits);\nelse if ( !strcmp(name,\"compressl_by_compute_\") ) return (void *)FORTRAN(compressl_by_compute);\n\n/* compressm_by.F */\nelse if ( !strcmp(name,\"compressm_by_init_\") ) return (void *)FORTRAN(compressm_by_init);\nelse if ( !strcmp(name,\"compressm_by_result_limits_\") ) return (void *)FORTRAN(compressm_by_result_limits);\nelse if ( !strcmp(name,\"compressm_by_compute_\") ) return (void *)FORTRAN(compressm_by_compute);\n\n/* compressn_by.F */\nelse if ( !strcmp(name,\"compressn_by_init_\") ) return (void *)FORTRAN(compressn_by_init);\nelse if ( !strcmp(name,\"compressn_by_result_limits_\") ) return (void *)FORTRAN(compressn_by_result_limits);\nelse if ( !strcmp(name,\"compressn_by_compute_\") ) return (void *)FORTRAN(compressn_by_compute);\n\n/* box_edges.F */\nelse if ( !strcmp(name,\"box_edges_init_\") ) return (void *)FORTRAN(box_edges_init);\nelse if ( !strcmp(name,\"box_edges_result_limits_\") ) return (void *)FORTRAN(box_edges_result_limits);\nelse if ( !strcmp(name,\"box_edges_compute_\") ) return (void *)FORTRAN(box_edges_compute);\n\n\n/* labwid.F */\nelse if ( !strcmp(name,\"labwid_init_\") ) return (void *)FORTRAN(labwid_init);\nelse if ( !strcmp(name,\"labwid_result_limits_\") ) return (void *)FORTRAN(labwid_result_limits);\nelse if ( !strcmp(name,\"labwid_compute_\") ) return (void *)FORTRAN(labwid_compute);\n\n/* convolvei.F */\nelse if ( !strcmp(name,\"convolvei_init_\") ) return (void *)FORTRAN(convolvei_init);\nelse if ( !strcmp(name,\"convolvei_compute_\") ) return (void *)FORTRAN(convolvei_compute);\n\n/* convolvej.F */\nelse if ( !strcmp(name,\"convolvej_init_\") ) return (void *)FORTRAN(convolvej_init);\nelse if ( !strcmp(name,\"convolvej_compute_\") ) return (void *)FORTRAN(convolvej_compute);\n\n/* convolvek.F */\nelse if ( !strcmp(name,\"convolvek_init_\") ) return (void *)FORTRAN(convolvek_init);\nelse if ( !strcmp(name,\"convolvek_compute_\") ) return (void *)FORTRAN(convolvek_compute);\n\n/* convolvel.F */\nelse if ( !strcmp(name,\"convolvel_init_\") ) return (void *)FORTRAN(convolvel_init);\nelse if ( !strcmp(name,\"convolvel_compute_\") ) return (void *)FORTRAN(convolvel_compute);\n\n/* convolvem.F */\nelse if ( !strcmp(name,\"convolvem_init_\") ) return (void *)FORTRAN(convolvem_init);\nelse if ( !strcmp(name,\"convolvem_compute_\") ) return (void *)FORTRAN(convolvem_compute);\n\n/* convolven.F */\nelse if ( !strcmp(name,\"convolven_init_\") ) return (void *)FORTRAN(convolven_init);\nelse if ( !strcmp(name,\"convolven_compute_\") ) return (void *)FORTRAN(convolven_compute);\n\n/* curv_range.F */\nelse if ( !strcmp(name,\"curv_range_init_\") ) return (void *)FORTRAN(curv_range_init);\nelse if ( !strcmp(name,\"curv_range_result_limits_\") ) return (void *)FORTRAN(curv_range_result_limits);\nelse if ( !strcmp(name,\"curv_range_compute_\") ) return (void *)FORTRAN(curv_range_compute);\n\n/* curv_to_rect_map.F */\nelse if ( !strcmp(name,\"curv_to_rect_map_init_\") ) return (void *)FORTRAN(curv_to_rect_map_init);\nelse if ( !strcmp(name,\"curv_to_rect_map_result_limits_\") ) return (void *)FORTRAN(curv_to_rect_map_result_limits);\nelse if ( !strcmp(name,\"curv_to_rect_map_work_size_\") ) return (void *)FORTRAN(curv_to_rect_map_work_size);\nelse if ( !strcmp(name,\"curv_to_rect_map_compute_\") ) return (void *)FORTRAN(curv_to_rect_map_compute);\n\n/* curv_to_rect.F */\nelse if ( !strcmp(name,\"curv_to_rect_init_\") ) return (void *)FORTRAN(curv_to_rect_init);\nelse if ( !strcmp(name,\"curv_to_rect_compute_\") ) return (void *)FORTRAN(curv_to_rect_compute);\n\n/* curv_to_rect_fsu.F */\nelse if ( !strcmp(name,\"curv_to_rect_fsu_init_\") ) return (void *)FORTRAN(curv_to_rect_fsu_init);\nelse if ( !strcmp(name,\"curv_to_rect_fsu_compute_\") ) return (void *)FORTRAN(curv_to_rect_fsu_compute);\n\n/* rect_to_curv.F */\nelse if ( !strcmp(name,\"rect_to_curv_init_\") ) return (void *)FORTRAN(rect_to_curv_init);\nelse if ( !strcmp(name,\"rect_to_curv_work_size_\") ) return (void *)FORTRAN(rect_to_curv_work_size);\nelse if ( !strcmp(name,\"rect_to_curv_compute_\") ) return (void *)FORTRAN(rect_to_curv_compute);\n\n/* date1900.F */\nelse if ( !strcmp(name,\"date1900_init_\") ) return (void *)FORTRAN(date1900_init);\nelse if ( !strcmp(name,\"date1900_compute_\") ) return (void *)FORTRAN(date1900_compute);\n\n/* days1900toymdhms.F */\nelse if ( !strcmp(name,\"days1900toymdhms_init_\") ) return (void *)FORTRAN(days1900toymdhms_init);\nelse if ( !strcmp(name,\"days1900toymdhms_result_limits_\") ) return (void *)FORTRAN(days1900toymdhms_result_limits);\nelse if ( !strcmp(name,\"days1900toymdhms_compute_\") ) return (void *)FORTRAN(days1900toymdhms_compute);\n\n/* minutes24.F */\nelse if ( !strcmp(name,\"minutes24_init_\") ) return (void *)FORTRAN(minutes24_init);\nelse if ( !strcmp(name,\"minutes24_result_limits_\") ) return (void *)FORTRAN(minutes24_result_limits);\nelse if ( !strcmp(name,\"minutes24_compute_\") ) return (void *)FORTRAN(minutes24_compute);\n\n/* element_index.F */\nelse if ( !strcmp(name,\"element_index_init_\") ) return (void *)FORTRAN(element_index_init);\nelse if ( !strcmp(name,\"element_index_compute_\") ) return (void *)FORTRAN(element_index_compute);\n\n/* element_index_str.F */\nelse if ( !strcmp(name,\"element_index_str_init_\") ) return (void *)FORTRAN(element_index_str_init);\nelse if ( !strcmp(name,\"element_index_str_compute_\") ) return (void *)FORTRAN(element_index_str_compute);\n\n/* element_index_str_n.F */\nelse if ( !strcmp(name,\"element_index_str_n_init_\") ) return (void *)FORTRAN(element_index_str_n_init);\nelse if ( !strcmp(name,\"element_index_str_n_compute_\") ) return (void *)FORTRAN(element_index_str_n_compute);\n\n/* expnd_by_len.F */\nelse if ( !strcmp(name,\"expnd_by_len_init_\") ) return (void *)FORTRAN(expnd_by_len_init);\nelse if ( !strcmp(name,\"expnd_by_len_result_limits_\") ) return (void *)FORTRAN(expnd_by_len_result_limits);\nelse if ( !strcmp(name,\"expnd_by_len_compute_\") ) return (void *)FORTRAN(expnd_by_len_compute);\n\n/* expnd_by_len_str.F */\nelse if ( !strcmp(name,\"expnd_by_len_str_init_\") ) return (void *)FORTRAN(expnd_by_len_str_init);\nelse if ( !strcmp(name,\"expnd_by_len_str_result_limits_\") ) return (void *)FORTRAN(expnd_by_len_str_result_limits);\nelse if ( !strcmp(name,\"expnd_by_len_str_compute_\") ) return (void *)FORTRAN(expnd_by_len_str_compute);\n\n/* expndi_by.F */\nelse if ( !strcmp(name,\"expndi_by_init_\") ) return (void *)FORTRAN(expndi_by_init);\nelse if ( !strcmp(name,\"expndi_by_result_limits_\") ) return (void *)FORTRAN(expndi_by_result_limits);\nelse if ( !strcmp(name,\"expndi_by_compute_\") ) return (void *)FORTRAN(expndi_by_compute);\n\n/* expndi_by_t.F */\nelse if ( !strcmp(name,\"expndi_by_t_init_\") ) return (void *)FORTRAN(expndi_by_t_init);\nelse if ( !strcmp(name,\"expndi_by_t_result_limits_\") ) return (void *)FORTRAN(expndi_by_t_result_limits);\nelse if ( !strcmp(name,\"expndi_by_t_compute_\") ) return (void *)FORTRAN(expndi_by_t_compute);\n\n/* expndi_by_z.F */\nelse if ( !strcmp(name,\"expndi_by_z_init_\") ) return (void *)FORTRAN(expndi_by_z_init);\nelse if ( !strcmp(name,\"expndi_by_z_result_limits_\") ) return (void *)FORTRAN(expndi_by_z_result_limits);\nelse if ( !strcmp(name,\"expndi_by_z_compute_\") ) return (void *)FORTRAN(expndi_by_z_compute);\n\n/* expndi_by_z_counts.F */\nelse if ( !strcmp(name,\"expndi_by_z_counts_init_\") ) return (void *)FORTRAN(expndi_by_z_counts_init);\nelse if ( !strcmp(name,\"expndi_by_z_counts_result_limits_\") ) return (void *)FORTRAN(expndi_by_z_counts_result_limits);\nelse if ( !strcmp(name,\"expndi_by_z_counts_compute_\") ) return (void *)FORTRAN(expndi_by_z_counts_compute);\n\n/* expndi_id_by_z_counts.F */\nelse if ( !strcmp(name,\"expndi_id_by_z_counts_init_\") ) return (void *)FORTRAN(expndi_id_by_z_counts_init);\nelse if ( !strcmp(name,\"expndi_id_by_z_counts_result_limits_\") ) return (void *)FORTRAN(expndi_id_by_z_counts_result_limits);\nelse if ( !strcmp(name,\"expndi_id_by_z_counts_compute_\") ) return (void *)FORTRAN(expndi_id_by_z_counts_compute);\n\n/* expndi_by_m_counts.F */\nelse if ( !strcmp(name,\"expndi_by_m_counts_init_\") ) return (void *)FORTRAN(expndi_by_m_counts_init);\nelse if ( !strcmp(name,\"expndi_by_m_counts_compute_\") ) return (void *)FORTRAN(expndi_by_m_counts_compute);\n\n/* expndi_by_m_counts_str.F */\nelse if ( !strcmp(name,\"expndi_by_m_counts_str_init_\") ) return (void *)FORTRAN(expndi_by_m_counts_str_init);\nelse if ( !strcmp(name,\"expndi_by_m_counts_str_compute_\") ) return (void *)FORTRAN(expndi_by_m_counts_str_compute);\n\n/* fc_isubset.F */\nelse if ( !strcmp(name,\"fc_isubset_init_\") ) return (void *)FORTRAN(fc_isubset_init);\nelse if ( !strcmp(name,\"fc_isubset_result_limits_\") ) return (void *)FORTRAN(fc_isubset_result_limits);\nelse if ( !strcmp(name,\"fc_isubset_custom_axes_\") ) return (void *)FORTRAN(fc_isubset_custom_axes);\nelse if ( !strcmp(name,\"fc_isubset_compute_\") ) return (void *)FORTRAN(fc_isubset_compute);\n\n/* findhi.F */\nelse if ( !strcmp(name,\"findhi_init_\") ) return (void *)FORTRAN(findhi_init);\nelse if ( !strcmp(name,\"findhi_result_limits_\") ) return (void *)FORTRAN(findhi_result_limits);\nelse if ( !strcmp(name,\"findhi_work_size_\") ) return (void *)FORTRAN(findhi_work_size);\nelse if ( !strcmp(name,\"findhi_compute_\") ) return (void *)FORTRAN(findhi_compute);\n\n/* findlo.F */\nelse if ( !strcmp(name,\"findlo_init_\") ) return (void *)FORTRAN(findlo_init);\nelse if ( !strcmp(name,\"findlo_result_limits_\") ) return (void *)FORTRAN(findlo_result_limits);\nelse if ( !strcmp(name,\"findlo_work_size_\") ) return (void *)FORTRAN(findlo_work_size);\nelse if ( !strcmp(name,\"findlo_compute_\") ) return (void *)FORTRAN(findlo_compute);\n\n/* is_element_of.F */\nelse if ( !strcmp(name,\"is_element_of_init_\") ) return (void *)FORTRAN(is_element_of_init);\nelse if ( !strcmp(name,\"is_element_of_result_limits_\") ) return (void *)FORTRAN(is_element_of_result_limits);\nelse if ( !strcmp(name,\"is_element_of_compute_\") ) return (void *)FORTRAN(is_element_of_compute);\n\n/* is_element_of_str.F */\nelse if ( !strcmp(name,\"is_element_of_str_init_\") ) return (void *)FORTRAN(is_element_of_str_init);\nelse if ( !strcmp(name,\"is_element_of_str_result_limits_\") ) return (void *)FORTRAN(is_element_of_str_result_limits);\nelse if ( !strcmp(name,\"is_element_of_str_compute_\") ) return (void *)FORTRAN(is_element_of_str_compute);\n\n/* is_element_of_str_n.F */\nelse if ( !strcmp(name,\"is_element_of_str_n_init_\") ) return (void *)FORTRAN(is_element_of_str_n_init);\nelse if ( !strcmp(name,\"is_element_of_str_n_result_limits_\") ) return (void *)FORTRAN(is_element_of_str_n_result_limits);\nelse if ( !strcmp(name,\"is_element_of_str_n_compute_\") ) return (void *)FORTRAN(is_element_of_str_n_compute);\n\n/* lanczos.F */\nelse if ( !strcmp(name,\"lanczos_init_\") ) return (void *)FORTRAN(lanczos_init);\nelse if ( !strcmp(name,\"lanczos_work_size_\") ) return (void *)FORTRAN(lanczos_work_size);\nelse if ( !strcmp(name,\"lanczos_compute_\") ) return (void *)FORTRAN(lanczos_compute);\n\n/* lsl_lowpass.F */\nelse if ( !strcmp(name,\"lsl_lowpass_init_\") ) return (void *)FORTRAN(lsl_lowpass_init);\nelse if ( !strcmp(name,\"lsl_lowpass_work_size_\") ) return (void *)FORTRAN(lsl_lowpass_work_size);\nelse if ( !strcmp(name,\"lsl_lowpass_compute_\") ) return (void *)FORTRAN(lsl_lowpass_compute);\n\n/* scat2grid_t.F */\nelse if ( !strcmp(name,\"scat2grid_t_init_\") ) return (void *)FORTRAN(scat2grid_t_init);\nelse if ( !strcmp(name,\"scat2grid_t_work_size_\") ) return (void *)FORTRAN(scat2grid_t_work_size);\nelse if ( !strcmp(name,\"scat2grid_t_compute_\") ) return (void *)FORTRAN(scat2grid_t_compute);\n\n/* ave_scat2grid_t.F */\nelse if ( !strcmp(name,\"ave_scat2grid_t_init_\") ) return (void *)FORTRAN(ave_scat2grid_t_init);\nelse if ( !strcmp(name,\"ave_scat2grid_t_work_size_\") ) return (void *)FORTRAN(ave_scat2grid_t_work_size);\nelse if ( !strcmp(name,\"ave_scat2grid_t_compute_\") ) return (void *)FORTRAN(ave_scat2grid_t_compute);\n\n/* scat2ddups.F */\nelse if ( !strcmp(name,\"scat2ddups_init_\") ) return (void *)FORTRAN(scat2ddups_init);\nelse if ( !strcmp(name,\"scat2ddups_result_limits_\") ) return (void *)FORTRAN(scat2ddups_result_limits);\nelse if ( !strcmp(name,\"scat2ddups_compute_\") ) return (void *)FORTRAN(scat2ddups_compute);\n\n/* transpose_ef.F */\nelse if ( !strcmp(name,\"transpose_ef_init_\") ) return (void *)FORTRAN(transpose_ef_init);\nelse if ( !strcmp(name,\"transpose_ef_result_limits_\") ) return (void *)FORTRAN(transpose_ef_result_limits);\nelse if ( !strcmp(name,\"transpose_ef_compute_\") ) return (void *)FORTRAN(transpose_ef_compute);\n\n/* transpose_te.F */\nelse if ( !strcmp(name,\"transpose_te_init_\") ) return (void *)FORTRAN(transpose_te_init);\nelse if ( !strcmp(name,\"transpose_te_result_limits_\") ) return (void *)FORTRAN(transpose_te_result_limits);\nelse if ( !strcmp(name,\"transpose_te_compute_\") ) return (void *)FORTRAN(transpose_te_compute);\n\n/* transpose_tf.F */\nelse if ( !strcmp(name,\"transpose_tf_init_\") ) return (void *)FORTRAN(transpose_tf_init);\nelse if ( !strcmp(name,\"transpose_tf_result_limits_\") ) return (void *)FORTRAN(transpose_tf_result_limits);\nelse if ( !strcmp(name,\"transpose_tf_compute_\") ) return (void *)FORTRAN(transpose_tf_compute);\n\n/* transpose_xe.F */\nelse if ( !strcmp(name,\"transpose_xe_init_\") ) return (void *)FORTRAN(transpose_xe_init);\nelse if ( !strcmp(name,\"transpose_xe_result_limits_\") ) return (void *)FORTRAN(transpose_xe_result_limits);\nelse if ( !strcmp(name,\"transpose_xe_compute_\") ) return (void *)FORTRAN(transpose_xe_compute);\n\n/* transpose_xf.F */\nelse if ( !strcmp(name,\"transpose_xf_init_\") ) return (void *)FORTRAN(transpose_xf_init);\nelse if ( !strcmp(name,\"transpose_xf_result_limits_\") ) return (void *)FORTRAN(transpose_xf_result_limits);\nelse if ( !strcmp(name,\"transpose_xf_compute_\") ) return (void *)FORTRAN(transpose_xf_compute);\n\n/* transpose_xt.F */\nelse if ( !strcmp(name,\"transpose_xt_init_\") ) return (void *)FORTRAN(transpose_xt_init);\nelse if ( !strcmp(name,\"transpose_xt_result_limits_\") ) return (void *)FORTRAN(transpose_xt_result_limits);\nelse if ( !strcmp(name,\"transpose_xt_compute_\") ) return (void *)FORTRAN(transpose_xt_compute);\n\n/* transpose_xy.F */\nelse if ( !strcmp(name,\"transpose_xy_init_\") ) return (void *)FORTRAN(transpose_xy_init);\nelse if ( !strcmp(name,\"transpose_xy_result_limits_\") ) return (void *)FORTRAN(transpose_xy_result_limits);\nelse if ( !strcmp(name,\"transpose_xy_compute_\") ) return (void *)FORTRAN(transpose_xy_compute);\n\n/* transpose_xz.F */\nelse if ( !strcmp(name,\"transpose_xz_init_\") ) return (void *)FORTRAN(transpose_xz_init);\nelse if ( !strcmp(name,\"transpose_xz_result_limits_\") ) return (void *)FORTRAN(transpose_xz_result_limits);\nelse if ( !strcmp(name,\"transpose_xz_compute_\") ) return (void *)FORTRAN(transpose_xz_compute);\n\n/* transpose_ye.F */\nelse if ( !strcmp(name,\"transpose_ye_init_\") ) return (void *)FORTRAN(transpose_ye_init);\nelse if ( !strcmp(name,\"transpose_ye_result_limits_\") ) return (void *)FORTRAN(transpose_ye_result_limits);\nelse if ( !strcmp(name,\"transpose_ye_compute_\") ) return (void *)FORTRAN(transpose_ye_compute);\n\n/* transpose_yf.F */\nelse if ( !strcmp(name,\"transpose_yf_init_\") ) return (void *)FORTRAN(transpose_yf_init);\nelse if ( !strcmp(name,\"transpose_yf_result_limits_\") ) return (void *)FORTRAN(transpose_yf_result_limits);\nelse if ( !strcmp(name,\"transpose_yf_compute_\") ) return (void *)FORTRAN(transpose_yf_compute);\n\n/* transpose_yt.F */\nelse if ( !strcmp(name,\"transpose_yt_init_\") ) return (void *)FORTRAN(transpose_yt_init);\nelse if ( !strcmp(name,\"transpose_yt_result_limits_\") ) return (void *)FORTRAN(transpose_yt_result_limits);\nelse if ( !strcmp(name,\"transpose_yt_compute_\") ) return (void *)FORTRAN(transpose_yt_compute);\n\n/* transpose_yz.F */\nelse if ( !strcmp(name,\"transpose_yz_init_\") ) return (void *)FORTRAN(transpose_yz_init);\nelse if ( !strcmp(name,\"transpose_yz_result_limits_\") ) return (void *)FORTRAN(transpose_yz_result_limits);\nelse if ( !strcmp(name,\"transpose_yz_compute_\") ) return (void *)FORTRAN(transpose_yz_compute);\n\n/* transpose_ze.F */\nelse if ( !strcmp(name,\"transpose_ze_init_\") ) return (void *)FORTRAN(transpose_ze_init);\nelse if ( !strcmp(name,\"transpose_ze_result_limits_\") ) return (void *)FORTRAN(transpose_ze_result_limits);\nelse if ( !strcmp(name,\"transpose_ze_compute_\") ) return (void *)FORTRAN(transpose_ze_compute);\n\n/* transpose_zf.F */\nelse if ( !strcmp(name,\"transpose_zf_init_\") ) return (void *)FORTRAN(transpose_zf_init);\nelse if ( !strcmp(name,\"transpose_zf_result_limits_\") ) return (void *)FORTRAN(transpose_zf_result_limits);\nelse if ( !strcmp(name,\"transpose_zf_compute_\") ) return (void *)FORTRAN(transpose_zf_compute);\n\n/* transpose_zt.F */\nelse if ( !strcmp(name,\"transpose_zt_init_\") ) return (void *)FORTRAN(transpose_zt_init);\nelse if ( !strcmp(name,\"transpose_zt_result_limits_\") ) return (void *)FORTRAN(transpose_zt_result_limits);\nelse if ( !strcmp(name,\"transpose_zt_compute_\") ) return (void *)FORTRAN(transpose_zt_compute);\n\n/* xcat.F */\nelse if ( !strcmp(name,\"xcat_init_\") ) return (void *)FORTRAN(xcat_init);\nelse if ( !strcmp(name,\"xcat_result_limits_\") ) return (void *)FORTRAN(xcat_result_limits);\nelse if ( !strcmp(name,\"xcat_compute_\") ) return (void *)FORTRAN(xcat_compute);\n\n/* xcat_str.F */\nelse if ( !strcmp(name,\"xcat_str_init_\") ) return (void *)FORTRAN(xcat_str_init);\nelse if ( !strcmp(name,\"xcat_str_result_limits_\") ) return (void *)FORTRAN(xcat_str_result_limits);\nelse if ( !strcmp(name,\"xcat_str_compute_\") ) return (void *)FORTRAN(xcat_str_compute);\n\n/* ycat.F */\nelse if ( !strcmp(name,\"ycat_init_\") ) return (void *)FORTRAN(ycat_init);\nelse if ( !strcmp(name,\"ycat_result_limits_\") ) return (void *)FORTRAN(ycat_result_limits);\nelse if ( !strcmp(name,\"ycat_compute_\") ) return (void *)FORTRAN(ycat_compute);\n\n/* ycat_str.F */\nelse if ( !strcmp(name,\"ycat_str_init_\") ) return (void *)FORTRAN(ycat_str_init);\nelse if ( !strcmp(name,\"ycat_str_result_limits_\") ) return (void *)FORTRAN(ycat_str_result_limits);\nelse if ( !strcmp(name,\"ycat_str_compute_\") ) return (void *)FORTRAN(ycat_str_compute);\n\n/* zcat.F */\nelse if ( !strcmp(name,\"zcat_init_\") ) return (void *)FORTRAN(zcat_init);\nelse if ( !strcmp(name,\"zcat_result_limits_\") ) return (void *)FORTRAN(zcat_result_limits);\nelse if ( !strcmp(name,\"zcat_compute_\") ) return (void *)FORTRAN(zcat_compute);\n\n/* zcat_str.F */\nelse if ( !strcmp(name,\"zcat_str_init_\") ) return (void *)FORTRAN(zcat_str_init);\nelse if ( !strcmp(name,\"zcat_str_result_limits_\") ) return (void *)FORTRAN(zcat_str_result_limits);\nelse if ( !strcmp(name,\"zcat_str_compute_\") ) return (void *)FORTRAN(zcat_str_compute);\n\n/* tcat.F */\nelse if ( !strcmp(name,\"tcat_init_\") ) return (void *)FORTRAN(tcat_init);\nelse if ( !strcmp(name,\"tcat_result_limits_\") ) return (void *)FORTRAN(tcat_result_limits);\nelse if ( !strcmp(name,\"tcat_compute_\") ) return (void *)FORTRAN(tcat_compute);\n\n/* tcat_str.F */\nelse if ( !strcmp(name,\"tcat_str_init_\") ) return (void *)FORTRAN(tcat_str_init);\nelse if ( !strcmp(name,\"tcat_str_result_limits_\") ) return (void *)FORTRAN(tcat_str_result_limits);\nelse if ( !strcmp(name,\"tcat_str_compute_\") ) return (void *)FORTRAN(tcat_str_compute);\n\n/* ecat.F */\nelse if ( !strcmp(name,\"ecat_init_\") ) return (void *)FORTRAN(ecat_init);\nelse if ( !strcmp(name,\"ecat_result_limits_\") ) return (void *)FORTRAN(ecat_result_limits);\nelse if ( !strcmp(name,\"ecat_compute_\") ) return (void *)FORTRAN(ecat_compute);\n\n/* ecat_str.F */\nelse if ( !strcmp(name,\"ecat_str_init_\") ) return (void *)FORTRAN(ecat_str_init);\nelse if ( !strcmp(name,\"ecat_str_result_limits_\") ) return (void *)FORTRAN(ecat_str_result_limits);\nelse if ( !strcmp(name,\"ecat_str_compute_\") ) return (void *)FORTRAN(ecat_str_compute);\n\n/* fcat.F */\nelse if ( !strcmp(name,\"fcat_init_\") ) return (void *)FORTRAN(fcat_init);\nelse if ( !strcmp(name,\"fcat_result_limits_\") ) return (void *)FORTRAN(fcat_result_limits);\nelse if ( !strcmp(name,\"fcat_compute_\") ) return (void *)FORTRAN(fcat_compute);\n\n/* fcat_str.F */\nelse if ( !strcmp(name,\"fcat_str_init_\") ) return (void *)FORTRAN(fcat_str_init);\nelse if ( !strcmp(name,\"fcat_str_result_limits_\") ) return (void *)FORTRAN(fcat_str_result_limits);\nelse if ( !strcmp(name,\"fcat_str_compute_\") ) return (void *)FORTRAN(fcat_str_compute);\n\n/* xreverse.F */\nelse if ( !strcmp(name,\"xreverse_init_\") ) return (void *)FORTRAN(xreverse_init);\nelse if ( !strcmp(name,\"xreverse_result_limits_\") ) return (void *)FORTRAN(xreverse_result_limits);\nelse if ( !strcmp(name,\"xreverse_compute_\") ) return (void *)FORTRAN(xreverse_compute);\n\n/* yreverse.F */\nelse if ( !strcmp(name,\"yreverse_init_\") ) return (void *)FORTRAN(yreverse_init);\nelse if ( !strcmp(name,\"yreverse_result_limits_\") ) return (void *)FORTRAN(yreverse_result_limits);\nelse if ( !strcmp(name,\"yreverse_compute_\") ) return (void *)FORTRAN(yreverse_compute);\n\n/* zreverse.F */\nelse if ( !strcmp(name,\"zreverse_init_\") ) return (void *)FORTRAN(zreverse_init);\nelse if ( !strcmp(name,\"zreverse_result_limits_\") ) return (void *)FORTRAN(zreverse_result_limits);\nelse if ( !strcmp(name,\"zreverse_compute_\") ) return (void *)FORTRAN(zreverse_compute);\n\n/* treverse.F */\nelse if ( !strcmp(name,\"treverse_init_\") ) return (void *)FORTRAN(treverse_init);\nelse if ( !strcmp(name,\"treverse_result_limits_\") ) return (void *)FORTRAN(treverse_result_limits);\nelse if ( !strcmp(name,\"treverse_compute_\") ) return (void *)FORTRAN(treverse_compute);\n\n/* ereverse.F */\nelse if ( !strcmp(name,\"ereverse_init_\") ) return (void *)FORTRAN(ereverse_init);\nelse if ( !strcmp(name,\"ereverse_result_limits_\") ) return (void *)FORTRAN(ereverse_result_limits);\nelse if ( !strcmp(name,\"ereverse_compute_\") ) return (void *)FORTRAN(ereverse_compute);\n\n/* freverse.F */\nelse if ( !strcmp(name,\"freverse_init_\") ) return (void *)FORTRAN(freverse_init);\nelse if ( !strcmp(name,\"freverse_result_limits_\") ) return (void *)FORTRAN(freverse_result_limits);\nelse if ( !strcmp(name,\"freverse_compute_\") ) return (void *)FORTRAN(freverse_compute);\n\n/* zaxreplace_avg.F */\nelse if ( !strcmp(name,\"zaxreplace_avg_init_\") ) return (void *)FORTRAN(zaxreplace_avg_init);\nelse if ( !strcmp(name,\"zaxreplace_avg_work_size_\") ) return (void *)FORTRAN(zaxreplace_avg_work_size);\nelse if ( !strcmp(name,\"zaxreplace_avg_compute_\") ) return (void *)FORTRAN(zaxreplace_avg_compute);\n\n/* zaxreplace_bin.F */\nelse if ( !strcmp(name,\"zaxreplace_bin_init_\") ) return (void *)FORTRAN(zaxreplace_bin_init);\nelse if ( !strcmp(name,\"zaxreplace_bin_work_size_\") ) return (void *)FORTRAN(zaxreplace_bin_work_size);\nelse if ( !strcmp(name,\"zaxreplace_bin_compute_\") ) return (void *)FORTRAN(zaxreplace_bin_compute);\n\n/* zaxreplace_rev.F */\nelse if ( !strcmp(name,\"zaxreplace_rev_init_\") ) return (void *)FORTRAN(zaxreplace_rev_init);\nelse if ( !strcmp(name,\"zaxreplace_rev_compute_\") ) return (void *)FORTRAN(zaxreplace_rev_compute);\n\n/* zaxreplace_zlev.F */\nelse if ( !strcmp(name,\"zaxreplace_zlev_init_\") ) return (void *)FORTRAN(zaxreplace_zlev_init);\nelse if ( !strcmp(name,\"zaxreplace_zlev_work_size_\") ) return (void *)FORTRAN(zaxreplace_zlev_work_size);\nelse if ( !strcmp(name,\"zaxreplace_zlev_compute_\") ) return (void *)FORTRAN(zaxreplace_zlev_compute);\n\n/* nco.F */\nelse if ( !strcmp(name,\"nco_init_\") ) return (void *)FORTRAN(nco_init);\nelse if ( !strcmp(name,\"nco_result_limits_\") ) return (void *)FORTRAN(nco_result_limits);\nelse if ( !strcmp(name,\"nco_compute_\") ) return (void *)FORTRAN(nco_compute);\n\n/* nco_attr.F */\nelse if ( !strcmp(name,\"nco_attr_init_\") ) return (void *)FORTRAN(nco_attr_init);\nelse if ( !strcmp(name,\"nco_attr_result_limits_\") ) return (void *)FORTRAN(nco_attr_result_limits);\nelse if ( !strcmp(name,\"nco_attr_compute_\") ) return (void *)FORTRAN(nco_attr_compute);\n\nelse if ( !strcmp(name,\"tax_datestring_init_\") ) return (void *)FORTRAN(tax_datestring_init);\nelse if ( !strcmp(name,\"tax_datestring_compute_\") ) return (void *)FORTRAN(tax_datestring_compute);\n\nelse if ( !strcmp(name,\"tax_day_init_\") ) return (void *)FORTRAN(tax_day_init);\nelse if ( !strcmp(name,\"tax_day_compute_\") ) return (void *)FORTRAN(tax_day_compute);\n\nelse if ( !strcmp(name,\"tax_dayfrac_init_\") ) return (void *)FORTRAN(tax_dayfrac_init);\nelse if ( !strcmp(name,\"tax_dayfrac_compute_\") ) return (void *)FORTRAN(tax_dayfrac_compute);\n\nelse if ( !strcmp(name,\"tax_jday1900_init_\") ) return (void *)FORTRAN(tax_jday1900_init);\nelse if ( !strcmp(name,\"tax_jday1900_compute_\") ) return (void *)FORTRAN(tax_jday1900_compute);\n\nelse if ( !strcmp(name,\"tax_jday_init_\") ) return (void *)FORTRAN(tax_jday_init);\nelse if ( !strcmp(name,\"tax_jday_compute_\") ) return (void *)FORTRAN(tax_jday_compute);\n\nelse if ( !strcmp(name,\"tax_month_init_\") ) return (void *)FORTRAN(tax_month_init);\nelse if ( !strcmp(name,\"tax_month_work_size_\") ) return (void *)FORTRAN(tax_month_work_size);\nelse if ( !strcmp(name,\"tax_month_compute_\") ) return (void *)FORTRAN(tax_month_compute);\n\nelse if ( !strcmp(name,\"tax_times_init_\") ) return (void *)FORTRAN(tax_times_init);\nelse if ( !strcmp(name,\"tax_times_compute_\") ) return (void *)FORTRAN(tax_times_compute);\n\nelse if ( !strcmp(name,\"tax_tstep_init_\") ) return (void *)FORTRAN(tax_tstep_init);\nelse if ( !strcmp(name,\"tax_tstep_work_size_\") ) return (void *)FORTRAN(tax_tstep_work_size);\nelse if ( !strcmp(name,\"tax_tstep_compute_\") ) return (void *)FORTRAN(tax_tstep_compute);\n\nelse if ( !strcmp(name,\"tax_units_init_\") ) return (void *)FORTRAN(tax_units_init);\nelse if ( !strcmp(name,\"tax_units_compute_\") ) return (void *)FORTRAN(tax_units_compute);\n\nelse if ( !strcmp(name,\"tax_year_init_\") ) return (void *)FORTRAN(tax_year_init);\nelse if ( !strcmp(name,\"tax_year_compute_\") ) return (void *)FORTRAN(tax_year_compute);\n\nelse if ( !strcmp(name,\"tax_yearfrac_init_\") ) return (void *)FORTRAN(tax_yearfrac_init);\nelse if ( !strcmp(name,\"tax_yearfrac_compute_\") ) return (void *)FORTRAN(tax_yearfrac_compute);\n\nelse if ( !strcmp(name,\"fill_xy_init_\") ) return (void *)FORTRAN(fill_xy_init);\nelse if ( !strcmp(name,\"fill_xy_compute_\") ) return (void *)FORTRAN(fill_xy_compute);\n\nelse if ( !strcmp(name,\"test_opendap_init_\") ) return (void *)FORTRAN(test_opendap_init);\nelse if ( !strcmp(name,\"test_opendap_result_limits_\") ) return (void *)FORTRAN(test_opendap_result_limits);\nelse if ( !strcmp(name,\"test_opendap_compute_\") ) return (void *)FORTRAN(test_opendap_compute);\n\nelse if ( !strcmp(name,\"unique_str2int_init_\") ) return (void *)FORTRAN(unique_str2int_init);\nelse if ( !strcmp(name,\"unique_str2int_compute_\") ) return (void *)FORTRAN(unique_str2int_compute);\n\nelse if ( !strcmp(name,\"bin_index_wt_init_\") ) return (void *)FORTRAN(bin_index_wt_init);\nelse if ( !strcmp(name,\"bin_index_wt_result_limits_\") ) return (void *)FORTRAN(bin_index_wt_result_limits);\nelse if ( !strcmp(name,\"bin_index_wt_compute_\") ) return (void *)FORTRAN(bin_index_wt_compute);\n\nelse if ( !strcmp(name,\"minmax_init_\") ) return (void *)FORTRAN(minmax_init);\nelse if ( !strcmp(name,\"minmax_result_limits_\") ) return (void *)FORTRAN(minmax_result_limits);\nelse if ( !strcmp(name,\"minmax_compute_\") ) return (void *)FORTRAN(minmax_compute);\n\nelse if ( !strcmp(name,\"floatstr_init_\") ) return (void *)FORTRAN(floatstr_init);\nelse if ( !strcmp(name,\"floatstr_compute_\") ) return (void *)FORTRAN(floatstr_compute);\n\nelse if ( !strcmp(name,\"pt_in_poly_init_\") ) return (void *)FORTRAN(pt_in_poly_init);\nelse if ( !strcmp(name,\"pt_in_poly_work_size_\") ) return (void *)FORTRAN(pt_in_poly_work_size);\nelse if ( !strcmp(name,\"pt_in_poly_compute_\") ) return (void *)FORTRAN(pt_in_poly_compute);\n\nelse if ( !strcmp(name,\"list_value_xml_init_\") ) return (void *)FORTRAN(list_value_xml_init);\nelse if ( !strcmp(name,\"list_value_xml_result_limits_\") ) return (void *)FORTRAN(list_value_xml_result_limits);\nelse if ( !strcmp(name,\"list_value_xml_compute_\") ) return (void *)FORTRAN(list_value_xml_compute);\n\nelse if ( !strcmp(name,\"lon_lat_time_string_init_\") ) return (void *)FORTRAN(lon_lat_time_string_init);\nelse if ( !strcmp(name,\"lon_lat_time_string_compute_\") ) return (void *)FORTRAN(lon_lat_time_string_compute);\n\nelse if ( !strcmp(name,\"write_webrow_init_\") ) return (void *)FORTRAN(write_webrow_init);\nelse if ( !strcmp(name,\"write_webrow_result_limits_\") ) return (void *)FORTRAN(write_webrow_result_limits);\nelse if ( !strcmp(name,\"write_webrow_compute_\") ) return (void *)FORTRAN(write_webrow_compute);\n\nelse if ( !strcmp(name,\"str_mask_init_\") ) return (void *)FORTRAN(str_mask_init);\nelse if ( !strcmp(name,\"str_mask_compute_\") ) return (void *)FORTRAN(str_mask_compute);\n\nelse if ( !strcmp(name,\"separate_init_\") ) return (void *)FORTRAN(separate_init);\nelse if ( !strcmp(name,\"separate_result_limits_\") ) return (void *)FORTRAN(separate_result_limits);\nelse if ( !strcmp(name,\"separate_compute_\") ) return (void *)FORTRAN(separate_compute);\n\nelse if ( !strcmp(name,\"separate_str_init_\") ) return (void *)FORTRAN(separate_str_init);\nelse if ( !strcmp(name,\"separate_str_result_limits_\") ) return (void *)FORTRAN(separate_str_result_limits);\nelse if ( !strcmp(name,\"separate_str_compute_\") ) return (void *)FORTRAN(separate_str_compute);\n\nelse if ( !strcmp(name,\"time_reformat_init_\") ) return (void *)FORTRAN(time_reformat_init);\nelse if ( !strcmp(name,\"time_reformat_compute_\") ) return (void *)FORTRAN(time_reformat_compute);\n\nelse if ( !strcmp(name,\"ft_to_orthogonal_init_\") ) return (void *)FORTRAN(ft_to_orthogonal_init);\nelse if ( !strcmp(name,\"ft_to_orthogonal_work_size_\") ) return (void *)FORTRAN(ft_to_orthogonal_work_size);\nelse if ( !strcmp(name,\"ft_to_orthogonal_compute_\") ) return (void *)FORTRAN(ft_to_orthogonal_compute);\n\nelse if ( !strcmp(name,\"piecewise3_init_\") ) return (void *)FORTRAN(piecewise3_init);\nelse if ( !strcmp(name,\"piecewise3_result_limits_\") ) return (void *)FORTRAN(piecewise3_result_limits);\nelse if ( !strcmp(name,\"piecewise3_work_size_\") ) return (void *)FORTRAN(piecewise3_work_size);\nelse if ( !strcmp(name,\"piecewise3_compute_\") ) return (void *)FORTRAN(piecewise3_compute);\n\nelse if ( !strcmp(name,\"sample_fast_i_init_\") ) return (void *)FORTRAN(sample_fast_i_init);\nelse if ( !strcmp(name,\"sample_fast_i_compute_\") ) return (void *)FORTRAN(sample_fast_i_compute);\n\nelse if ( !strcmp(name,\"sample_fast_i_str_init_\") ) return (void *)FORTRAN(sample_fast_i_str_init);\nelse if ( !strcmp(name,\"sample_fast_i_str_compute_\") ) return (void *)FORTRAN(sample_fast_i_str_compute);\n\nelse if ( !strcmp(name,\"write_webrow_gwt_init_\") ) return (void *)FORTRAN(write_webrow_gwt_init);\nelse if ( !strcmp(name,\"write_webrow_gwt_result_limits_\") ) return (void *)FORTRAN(write_webrow_gwt_result_limits);\nelse if ( !strcmp(name,\"write_webrow_gwt_compute_\") ) return (void *)FORTRAN(write_webrow_gwt_compute);\n\n/* str_noblanks.F */\nelse if ( !strcmp(name,\"str_noblanks_init_\") ) return (void *)FORTRAN(str_noblanks_init);\nelse if ( !strcmp(name,\"str_noblanks_compute_\") ) return (void *)FORTRAN(str_noblanks_compute);\n\n/* str_replace.F */\nelse if ( !strcmp(name,\"str_replace_init_\") ) return (void *)FORTRAN(str_replace_init);\nelse if ( !strcmp(name,\"str_replace_compute_\") ) return (void *)FORTRAN(str_replace_compute);\n\n/* expndi_to_et.F */\nelse if ( !strcmp(name,\"expndi_to_et_init_\") ) return (void *)FORTRAN(expndi_to_et_init);\nelse if ( !strcmp(name,\"expndi_to_et_work_size_\") ) return (void *)FORTRAN(expndi_to_et_work_size);\nelse if ( !strcmp(name,\"expndi_to_et_compute_\") ) return (void *)FORTRAN(expndi_to_et_compute);\n\n/* dot functions*/\nelse if ( !strcmp(name,\"dot_x_init_\") ) return (void *)FORTRAN(dot_x_init);\nelse if ( !strcmp(name,\"dot_x_compute_\") ) return (void *)FORTRAN(dot_x_compute);\n\nelse if ( !strcmp(name,\"dot_y_init_\") ) return (void *)FORTRAN(dot_y_init);\nelse if ( !strcmp(name,\"dot_y_compute_\") ) return (void *)FORTRAN(dot_y_compute);\n\nelse if ( !strcmp(name,\"dot_z_init_\") ) return (void *)FORTRAN(dot_z_init);\nelse if ( !strcmp(name,\"dot_z_compute_\") ) return (void *)FORTRAN(dot_z_compute);\n\nelse if ( !strcmp(name,\"dot_t_init_\") ) return (void *)FORTRAN(dot_t_init);\nelse if ( !strcmp(name,\"dot_t_compute_\") ) return (void *)FORTRAN(dot_t_compute);\n\nelse if ( !strcmp(name,\"dot_e_init_\") ) return (void *)FORTRAN(dot_e_init);\nelse if ( !strcmp(name,\"dot_e_compute_\") ) return (void *)FORTRAN(dot_e_compute);\n\nelse if ( !strcmp(name,\"dot_f_init_\") ) return (void *)FORTRAN(dot_f_init);\nelse if ( !strcmp(name,\"dot_f_compute_\") ) return (void *)FORTRAN(dot_f_compute);\n\n/* tracks2grid_mask_ave_xyt.F */\nelse if ( !strcmp(name,\"tracks2grid_mask_ave_xyt_init_\") ) return (void *)FORTRAN(tracks2grid_mask_ave_xyt_init);\nelse if ( !strcmp(name,\"tracks2grid_mask_ave_xyt_work_size_\") ) return (void *)FORTRAN(tracks2grid_mask_ave_xyt_work_size);\nelse if ( !strcmp(name,\"tracks2grid_mask_ave_xyt_compute_\") ) return (void *)FORTRAN(tracks2grid_mask_ave_xyt_compute);\n\n/*  tracks2grid_std_xyt.F */\nelse if ( !strcmp(name,\"tracks2grid_std_xyt_init_\") ) return (void *)FORTRAN( tracks2grid_std_xyt_init);\nelse if ( !strcmp(name,\"tracks2grid_std_xyt_work_size_\") ) return (void *)FORTRAN( tracks2grid_std_xyt_work_size);\nelse if ( !strcmp(name,\"tracks2grid_std_xyt_compute_\") ) return (void *)FORTRAN( tracks2grid_std_xyt_compute);\n\n/*  scat2grid_minmax_xyt.F */\nelse if ( !strcmp(name,\"scat2grid_minmax_xyt_init_\") ) return (void *)FORTRAN( scat2grid_minmax_xyt_init);\nelse if ( !strcmp(name,\"scat2grid_minmax_xyt_result_limits_\") ) return (void *)FORTRAN( scat2grid_minmax_xyt_result_limits);\nelse if ( !strcmp(name,\"scat2grid_minmax_xyt_work_size_\") ) return (void *)FORTRAN( scat2grid_minmax_xyt_work_size);\nelse if ( !strcmp(name,\"scat2grid_minmax_xyt_compute_\") ) return (void *)FORTRAN( scat2grid_minmax_xyt_compute);\n\n/*  scat2grid_std_xyt.F */\nelse if ( !strcmp(name,\"scat2grid_std_xyt_init_\") ) return (void *)FORTRAN( scat2grid_std_xyt_init);\nelse if ( !strcmp(name,\"scat2grid_std_xyt_work_size_\") ) return (void *)FORTRAN( scat2grid_std_xyt_work_size);\nelse if ( !strcmp(name,\"scat2grid_std_xyt_compute_\") ) return (void *)FORTRAN( scat2grid_std_xyt_compute);\n\nreturn NULL;\n }\n/*  End of function pointer list for internally-linked External Functions\n *  ------------------------------------ */\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_x86_64-linux/fnt07.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_x86_64-linux/fnt10.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_x86_64-linux/fnt25.sym",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_x86_64-linux/fnt03.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_x86_64-linux/fnt15.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_x86_64-linux/fnt09.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_x86_64-linux/fnt08.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_x86_64-linux/fnt16.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_x86_64-linux/fnt04.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_x86_64-linux/fnt27.sym",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_x86_64-linux/fnt06.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_x86_64-linux/fnt11.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_x86_64-linux/fnt22.sym",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_x86_64-linux/fnt17.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_x86_64-linux/fnt12.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_x86_64-linux/fnt21.sym",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_x86_64-linux/fnt20.sym",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_x86_64-linux/fnt18.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_x86_64-linux/fnt05.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_x86_64-linux/fnt24.sym",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_x86_64-linux/fnt31.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_x86_64-linux/fnt33.sym",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_x86_64-linux/fnt30.sym",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_x86_64-linux/fnt19.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_x86_64-linux/fnt02.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_x86_64-linux/fnt13.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_x86_64-linux/fnt29.sym",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_x86_64-linux/fnt32.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_x86_64-linux/fnt28.sym",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_x86_64-linux/fnt14.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_x86_64-linux/fnt23.sym",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_x86_64-linux/fnt26.sym",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_x86_64-linux/fnt01.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_solaris/fnt07.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_solaris/fnt10.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_solaris/fnt25.sym",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_solaris/fnt03.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_solaris/fnt15.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_solaris/fnt09.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_solaris/fnt08.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_solaris/fnt16.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_solaris/fnt04.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_solaris/fnt27.sym",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_solaris/fnt06.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_solaris/fnt11.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_solaris/fnt22.sym",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_solaris/fnt17.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_solaris/fnt12.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_solaris/fnt21.sym",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_solaris/fnt20.sym",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_solaris/fnt18.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_solaris/fnt05.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_solaris/fnt24.sym",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_solaris/fnt31.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_solaris/fnt33.sym",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_solaris/fnt30.sym",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_solaris/fnt19.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_solaris/fnt02.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_solaris/fnt13.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_solaris/fnt29.sym",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_solaris/fnt32.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_solaris/fnt28.sym",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_solaris/fnt14.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_solaris/fnt23.sym",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_solaris/fnt26.sym",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_solaris/fnt01.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/build_fonts/original/unix/test/plot.marks",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/build_fonts/original/vms/fnt31.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/build_fonts/original/vms/fnt32.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_linux/fnt07.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_linux/fnt10.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_linux/fnt25.sym",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_linux/fnt03.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_linux/fnt15.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_linux/fnt09.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_linux/fnt08.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_linux/fnt16.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_linux/fnt04.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_linux/fnt27.sym",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_linux/fnt06.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_linux/fnt11.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_linux/fnt22.sym",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_linux/fnt17.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_linux/fnt12.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_linux/fnt21.sym",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_linux/fnt20.sym",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_linux/fnt18.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_linux/fnt05.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_linux/fnt24.sym",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_linux/fnt31.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_linux/fnt33.sym",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_linux/fnt30.sym",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_linux/fnt19.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_linux/fnt02.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_linux/fnt13.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_linux/fnt29.sym",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_linux/fnt32.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_linux/fnt28.sym",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_linux/fnt14.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_linux/fnt23.sym",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_linux/fnt26.sym",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bin/fonts_linux/fnt01.chr",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/html_docs/old_html_docs/LAS_servers_list.html",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/html_docs/old_html_docs/ferret_pubs_1989_1998.html",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/html_docs/old_html_docs/snap.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/html_docs/old_html_docs/ferret_acknowledgements.html.pre981014",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/html_docs/old_html_docs/Release_Notes/lambert_eqn.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/html_docs/old_html_docs/Release_Notes/v4_tmap_logo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/html_docs/old_html_docs/Release_Notes/v57_gratdash.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/html_docs/old_html_docs/Release_Notes/inf1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/fer/AIX_MODIFICATIONS_SCHMIDT.LOG",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/metafile_masters_64bit_rh6/forecast_actual.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/metafile_masters_64bit_rh6/time_plot_precision_vector.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/metafile_masters_64bit_rh6/bn_labels_on_taxis.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/metafile_masters_64bit_rh6/bn_vs_const_value.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/metafile_masters_64bit_rh6/levels_one_level.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/metafile_masters_64bit_rh6/bnplot_3.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/metafile_masters_64bit_rh6/forecast_leadview.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/metafile_masters_64bit_rh6/legend_1d_plots.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/metafile_masters_64bit_rh6/time_plot_precision_hovmuller.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/metafile_masters_64bit_rh6/forecast_diagview.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/metafile_masters_64bit_rh6/bn_contour_conset.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/metafile_masters_64bit_rh6/bnplot_1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/metafile_masters_64bit_rh6/time_plot_precision_2doverlay.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/metafile_masters_64bit_rh6/time_plot_precision_fill.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/metafile_masters_64bit_rh6/mp_poly_vec.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/metafile_masters_64bit_rh6/dashbug.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/metafile_masters_64bit_rh6/abcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxy.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/metafile_masters_64bit_rh6/bnplot_2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/metafile_masters_64bit_rh6/gif_dashbug.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/metafile_masters_64bit_rh6/err700_key.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/metafile_masters_64bit_rh6/bnplot-1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/metafile_masters_64bit_rh6/bn_hovmuller_overlays.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/metafile_masters_64bit_rh6/lon_lat_label_controls.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/metafile_masters_64bit_rh6/curvi_set.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/metafile_masters_64bit_rh6/bn_subspan_mod_strides.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/metafile_masters_64bit_rh6/extra_digit_contourlab.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/metafile_masters_64bit_rh6/go_box.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/metafile_masters_64bit_rh6/time_plot_precision_shade.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/metafile_masters_64bit_rh6/vector_lats.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/metafile_masters_64bit_rh6/bn_ribbon_vlog.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/metafile_masters_64bit_rh6/vs_lon_over.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/metafile_masters_64bit_rh6/center_key_lab.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/metafile_masters_64bit_rh6/bn_axis_vs.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/metafile_masters_64bit_rh6/testbackground.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/metafile_masters_64bit/bnplot-2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/metafile_masters_64bit/abcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxyabcdefghijklmnopqrstuvwxy.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/metafile_masters_64bit/gif_dashbug.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/metafile_masters_64bit/bnplot-1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/metafile_masters_64bit/bnplot.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/metafile_masters_64bit/testbackground.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/coads_climatology.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/err608_bug1556.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/numstring.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/b1478.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/stream10by5_i386-apple-darwin.unf",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/bad_taxis.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/timemissing.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/aggT_5d2.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/err62_string_write.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/latestOb.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/clim_airt_lev.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/ens4.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/stream10by5_ia64-linux.unf",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/492C19881104.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/aggT_5d1.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/lev_rev_up.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/ens3.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/timesec.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/duplicate.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/append_pack.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/coads_uw.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/err693_save_packed.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/err600_upcase.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/non_COARDS.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/err700_vs_data.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/gtsa056_1_ef.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/err67_axis_order.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/run4.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/bn_strides.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/global.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/doubleSwapped.dat",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/dsg.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/stream10by5_x86_64-linux.unf",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/run2.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/weird_name1.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/modulo_lon_time.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/geo_borders.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/gappy_bounds.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/cc_irreg.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/bug1845.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/ft_cal_one.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/xsz.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/axes_subspan.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/varyscale_1.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/bounds_overlapping.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/err684_packed_output.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/clim_axes_julian.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/sstok_short.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/forecast27.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/floatSwapped.dat",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/clim_axes_gregorian.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/dims_not_coord.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/co_emac.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/forecast25.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/stream10by5_ia64-sles9.unf",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/repeat_t_coord.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/maize_1.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/shorttemp.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/maize_3.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/badbounds_even.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/write_int_att.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/coads_slice.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/coads_clim.1001",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/tripolar_subset.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/edge.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/gt4d011.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/ocean_atlas_temp.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/maize_2.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/coads_clim.001",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/123456789000101_100101_test_numeric.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/test0.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/bounds_noenclose.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/duplicate.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/run1.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/test_nan.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/noglobalhistory.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/longtitle1000.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/WestCoastCarbon_9d9c_f562_77b5_5f8e_5d19_7b1d.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/adouble.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/finale.dat",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/hourst.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/err682_scale_no_offset.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/stream10by5_x86_64-darwin.unf",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/6dfile.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/sstnok_short.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/heat_01.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/coads_vwnd.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/varyscale_2.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/conventions_history_in.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/fill_and_miss.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/ft_cal_mixed.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/bug1421_b.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/stream10by5_linux.unf",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/lev_v_bug.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/modfalse.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/twoType.dat",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/grads_bug_file.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/time_axis_seconds.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/uncentered.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/coads_clim.003",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/coads_clim.002",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/mylon.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/proleptic_gregorian.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/nodim.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/heat_0b.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/navy_uw.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/xyfile.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/heat_00.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/bug_save_subset.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/ens1.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/bn_set_axis_regular.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/strdimfile.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/nan_missing.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/clim_axes_noleap.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/run3.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/err542_poly_over_calendar.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/bug2445.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/climatological_axes.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/adouble_2D.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/TAO_SST_clim.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/ss_small.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/levitus_3d_subset.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/err64_packed_data.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/float.dat",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/coads_clim.999",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/illeg_axname.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/a1478.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/xz_nozattrib.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/sstok_jul.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/gtsa056_2.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/err700_coords.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/err_calendar.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/coads_clim.1000",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/gtsa056_1.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/fine_x_axis.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/truemonth.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/modax.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/test_axes.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/dstitle.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/nc5d.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/z_wide_variation.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/twodtime.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/err64_small_latlon.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/trajectory_trajectory_name.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/badbounds_non_enclose.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/levitus_climatology.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/epic_formatted_file.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/degrees.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/heat_0a.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/bug1421_a.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/a_cartesian_bug1179.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/badbounds.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/string5d.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/missing_scale_off.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/double.dat",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/reverse_z_bnds.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/skip.dat",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/lowercaseTime.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/test_save_dsg_in.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/fill_value_int.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/reverse_axes.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/err721_dup_labels.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/toolong.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/scat2grid.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/gtbc011.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/forecast26.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/no_miss_att.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/39839D6273F1749BABAD6C1441B2BBDD_netcdf.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/coads_clim.003b",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/badbounds_uneven.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/forecast24.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/err491_attval.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/data/ens2.nc",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/metafile_masters_32bit/bn_labels_on_taxis.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/metafile_masters_32bit/bnplot_3.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/metafile_masters_32bit/bn_contour_conset.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/metafile_masters_32bit/bnplot_1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/metafile_masters_32bit/bnplot-2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/metafile_masters_32bit/bnplot_2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/metafile_masters_32bit/bnplot-1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/metafile_masters_32bit/bn_hovmuller_overlays.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/metafile_masters_32bit/bn_subspan_mod_strides.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/metafile_masters_32bit/bnplot.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/metafile_masters_32bit/bn_ribbon_vlog.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/metafile_masters_32bit/bn_axis_vs.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/unused/NORM_CDF.DAT",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/test_results/forecast_actual.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/test_results/time_plot_precision_vector.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/test_results/bn_labels_on_taxis.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/test_results/bn_vs_const_value.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/test_results/levels_one_level.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/test_results/bnplot_3.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/test_results/forecast_leadview.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/test_results/legend_1d_plots.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/test_results/time_plot_precision_hovmuller.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/test_results/forecast_diagview.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/test_results/bn_contour_conset.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/test_results/bnplot_1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/test_results/time_plot_precision_2doverlay.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/test_results/time_plot_precision_fill.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/test_results/mp_poly_vec.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/test_results/dashbug.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/test_results/bnplot_2.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/test_results/gif_dashbug.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/test_results/err700_key.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/test_results/bn_hovmuller_overlays.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/test_results/lon_lat_label_controls.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/test_results/curvi_set.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/test_results/bn_subspan_mod_strides.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/test_results/extra_digit_contourlab.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/test_results/go_box.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/test_results/time_plot_precision_shade.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/test_results/vector_lats.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/test_results/bn_ribbon_vlog.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/test_results/vs_lon_over.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/test_results/center_key_lab.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/test_results/bn_axis_vs.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/bench/test_results/testbackground.gif",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/jnls/go/unf_tlandr.dat_sun",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/jnls/go/climatological_axes.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/jnls/go/unf_tlandr.dat_dec",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/jnls/examples/polydata.cdf",
        "/tmp/vanessa/spack-stage/spack-stage-ferret-7.4-6lf4sjnxu2da6idutoeoo6ogjq3jbdnp/spack-src/jnls/contrib/bias_zonalanommap.nc"
    ],
    "total_files": 5174
}