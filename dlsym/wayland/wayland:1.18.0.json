{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-wayland-1.18.0-6v6qglaw2utv7glyjk2wdgbnkqpo3v6t/spack-src/configure.ac": "AC_PREREQ([2.64])\n\nm4_define([wayland_major_version],  [1])\nm4_define([wayland_minor_version], [18])\nm4_define([wayland_micro_version], [0])\nm4_define([wayland_version],\n          [wayland_major_version.wayland_minor_version.wayland_micro_version])\n\nAC_INIT([wayland],\n        [wayland_version],\n\t[https://gitlab.freedesktop.org/wayland/wayland/issues/],\n        [wayland],\n        [https://wayland.freedesktop.org/])\n\nAC_SUBST([WAYLAND_VERSION_MAJOR], [wayland_major_version])\nAC_SUBST([WAYLAND_VERSION_MINOR], [wayland_minor_version])\nAC_SUBST([WAYLAND_VERSION_MICRO], [wayland_micro_version])\nAC_SUBST([WAYLAND_VERSION], [wayland_version])\n\nAC_CONFIG_HEADERS([config.h])\nAC_CONFIG_MACRO_DIR([m4])\n\nAM_INIT_AUTOMAKE([1.11 foreign no-dist-gzip dist-xz subdir-objects])\n\nAM_SILENT_RULES([yes])\n\n# Check for programs\nAC_PROG_CC\nAC_PROG_CXX\nAC_PROG_GREP\nAM_PROG_AS\nAC_PROG_NM\n\n# check if we have C++ compiler. This is hacky workaround,\n# for a reason why it is this way see\n# http://lists.gnu.org/archive/html/bug-autoconf/2010-05/msg00001.html\nhave_cpp_compiler=yes\n\nif ! which \"$CXX\" &>/dev/null; then\n\thave_cpp_compiler=no\nfi\n\nAM_CONDITIONAL(ENABLE_CPP_TEST, test \"x$have_cpp_compiler\" = \"xyes\")\n\n# Initialize libtool\nLT_PREREQ([2.2])\nLT_INIT([disable-static])\n\nPKG_PROG_PKG_CONFIG()\n\nAC_ARG_ENABLE([fatal-warnings],\n\t      AC_HELP_STRING([--enable-fatal-warnings],\n\t\t\t     [Build with -Werror]),\n\t      [enable_fatal_warnings=$enableval],\n\t      [enable_fatal_warnings=no])\nAS_IF([test x\"$enable_fatal_warnings\" != \"xno\"], [\n      WERROR_CFLAGS=\"-Werror\"\n])\n\nif test \"x$GCC\" = \"xyes\"; then\n\tGCC_CFLAGS=\"$WERROR_CFLAGS -Wall -Wextra -Wno-unused-parameter -g -Wstrict-prototypes -Wmissing-prototypes -fvisibility=hidden\"\nfi\nAC_SUBST(GCC_CFLAGS)\n\nAC_CHECK_HEADERS([sys/prctl.h])\nAC_CHECK_FUNCS([accept4 mkostemp posix_fallocate prctl memfd_create strndup])\n\n# *BSD don't have libdl, but they have its functions in libc\nWESTON_SEARCH_LIBS([DL], [dl], [dlsym])\n\n# OpenBSD doesn't have librt, but it has its functions in libc\nWESTON_SEARCH_LIBS([RT], [rt], [clock_gettime])\n\nAC_ARG_ENABLE([libraries],\n\t      [AC_HELP_STRING([--disable-libraries],\n\t\t\t      [Disable compilation of wayland libraries])],\n\t      [],\n\t      [enable_libraries=yes])\n\nAC_ARG_WITH([host-scanner],\n              [AC_HELP_STRING([--with-host-scanner],\n                              [Use installed wayland-scanner from host PATH during build])],\n              [],\n              [with_host_scanner=no])\n\nAC_ARG_ENABLE([documentation],\n\t      [AC_HELP_STRING([--disable-documentation],\n\t\t              [Disable building the documentation])],\n\t      [],\n\t      [enable_documentation=yes])\n\nAC_ARG_ENABLE([dtd-validation],\n\t      [AC_HELP_STRING([--disable-dtd-validation],\n\t\t\t      [Disable DTD validation of the protocol])],\n\t      [],\n\t      [enable_dtd_validation=yes])\n\nAM_CONDITIONAL(USE_HOST_SCANNER, test \"x$with_host_scanner\" = xyes)\n\nAM_CONDITIONAL(ENABLE_LIBRARIES, test \"x$enable_libraries\" = xyes)\n\nAC_ARG_WITH(icondir, [  --with-icondir=<dir>    Look for cursor icons here],\n\t\t     [  ICONDIR=$withval],\n\t\t     [  ICONDIR=${datadir}/icons])\nAC_SUBST([ICONDIR])\n\nif test \"x$enable_libraries\" = \"xyes\"; then\n\tPKG_CHECK_MODULES(FFI, [libffi])\n\tAC_CHECK_DECL(SFD_CLOEXEC,[],\n\t\t      [AC_MSG_ERROR(\"SFD_CLOEXEC is needed to compile wayland libraries\")],\n\t\t      [[#include <sys/signalfd.h>]])\n\tAC_CHECK_DECL(TFD_CLOEXEC,[],\n\t\t      [AC_MSG_ERROR(\"TFD_CLOEXEC is needed to compile wayland libraries\")],\n\t\t      [[#include <sys/timerfd.h>]])\n\tAC_CHECK_DECL(CLOCK_MONOTONIC,[],\n\t\t      [AC_MSG_ERROR(\"CLOCK_MONOTONIC is needed to compile wayland libraries\")],\n\t\t      [[#include <time.h>]])\nfi\n\nPKG_CHECK_MODULES(EXPAT, [expat])\n\nAM_CONDITIONAL([DTD_VALIDATION], [test \"x$enable_dtd_validation\" = \"xyes\"])\nif test \"x$enable_dtd_validation\" = \"xyes\"; then\n\tPKG_CHECK_MODULES(LIBXML, [libxml-2.0])\n\tAC_DEFINE(HAVE_LIBXML, 1, [libxml-2.0 is available])\n\tAC_CONFIG_LINKS([src/wayland.dtd.embed:protocol/wayland.dtd])\nfi\n\nAC_PATH_PROG(XSLTPROC, xsltproc)\nAM_CONDITIONAL([HAVE_XSLTPROC], [test \"x$XSLTPROC\" != \"x\"])\n\n\nAM_CONDITIONAL(BUILD_DOCS, [test x$enable_documentation = xyes])\nif test \"x$enable_documentation\" = \"xyes\"; then\n\tAC_PATH_PROG(DOXYGEN, doxygen)\n\n\tif test \"x$DOXYGEN\" = \"x\"; then\n\t\tAC_MSG_ERROR([Documentation build requested but doxygen not found. Install doxygen or disable the documentation using --disable-documentation])\n\tfi\n\n\tAC_MSG_CHECKING([for compatible doxygen version])\n\tdoxygen_version=`$DOXYGEN --version`\n\tAS_VERSION_COMPARE([$doxygen_version], [1.6.0],\n\t                   [AC_MSG_RESULT([no])\n\t                    AC_MSG_ERROR([Doxygen $doxygen_version too old. Doxygen 1.6+ required for documentation build. Install required doxygen version or disable the documentation using --disable-documentation])],\n\t                   [AC_MSG_RESULT([yes])],\n\t                   [AC_MSG_RESULT([yes])])\n\n\tAC_PATH_PROG(XMLTO, xmlto)\n\n\tif test \"x$XMLTO\" = \"x\"; then\n\t\tAC_MSG_ERROR([Documentation build requested but xmlto not found. Install xmlto or disable the documentation using --disable-documentation])\n\tfi\n\n\tAC_PATH_PROG(DOT, dot)\n\tif test \"x$DOT\" = \"x\"; then\n\t\tAC_MSG_ERROR([Documentation build requested but graphviz's dot not found. Install graphviz or disable the documentation using --disable-documentation])\n\tfi\n\tAC_MSG_CHECKING([for compatible dot version])\n\tdot_version=`$DOT -V 2>&1|$GREP -o ['[0-9]*\\.[0-9]*\\.[0-9]*']`\n\tAS_VERSION_COMPARE([$dot_version], [2.26.0],\n\t                   [AC_MSG_RESULT([no])\n\t                    AC_MSG_ERROR([Graphviz dot $dot_version too old. Graphviz 2.26+ required for documentation build. Install required graphviz version or disable the documentation using --disable-documentation])],\n\t                   [AC_MSG_RESULT([yes])],\n\t                   [AC_MSG_RESULT([yes])])\n\n\tAC_MSG_CHECKING([for docbook stylesheets])\n\tDOCS_STYLESHEET=http://docbook.sourceforge.net/release/xsl/current/manpages/docbook.xsl\n\tAC_PATH_PROGS_FEATURE_CHECK([XSLTPROC_TMP], [xsltproc],\n\t\t\t\t    AS_IF([`\"$ac_path_XSLTPROC_TMP\" --nonet \"$DOCS_STYLESHEET\" > /dev/null 2>&1`],\n\t\t\t\t\t  [HAVE_DOCS_STYLESHEET=yes]))\n\tif test \"x$HAVE_DOCS_STYLESHEET\" != \"xyes\"; then\n\t\tAC_MSG_RESULT([no])\n\t\tAC_MSG_ERROR([Documentation build requested but docbook-xsl stylesheets are not found. Install the docbook-xsl package or disable the documentation using --disable-documentation])\n\tfi\n\n\tAC_MSG_RESULT([yes])\n\tAC_SUBST(DOCS_STYLESHEET)\n\n\tAC_CONFIG_FILES([\n\tdoc/doxygen/wayland.doxygen\n\t])\n\nfi\nAM_CONDITIONAL([HAVE_XMLTO], [test \"x$XMLTO\" != \"x\"])\n\nAC_CONFIG_FILES([Makefile\n\t\t cursor/wayland-cursor.pc\n\t\t cursor/wayland-cursor-uninstalled.pc\n\t\t doc/Makefile\n\t\t doc/publican/Makefile\n\t\t doc/doxygen/Makefile\n\t\t doc/man/Makefile\n\t\t egl/wayland-egl.pc\n\t\t egl/wayland-egl-backend.pc\n\t\t src/wayland-server-uninstalled.pc\n\t\t src/wayland-client-uninstalled.pc\n\t\t src/wayland-scanner-uninstalled.pc\n\t\t src/wayland-server.pc\n\t\t src/wayland-client.pc\n\t\t src/wayland-scanner.pc\n\t\t src/wayland-version.h])\nAC_OUTPUT\n",
        "/tmp/vanessa/spack-stage/spack-stage-wayland-1.18.0-6v6qglaw2utv7glyjk2wdgbnkqpo3v6t/spack-src/tests/os-wrappers-test.c": "/*\n * Copyright \u00a9 2012 Collabora, Ltd.\n * Copyright \u00a9 2012 Intel Corporation\n *\n * Permission is hereby granted, free of charge, to any person obtaining\n * a copy of this software and associated documentation files (the\n * \"Software\"), to deal in the Software without restriction, including\n * without limitation the rights to use, copy, modify, merge, publish,\n * distribute, sublicense, and/or sell copies of the Software, and to\n * permit persons to whom the Software is furnished to do so, subject to\n * the following conditions:\n *\n * The above copyright notice and this permission notice (including the\n * next paragraph) shall be included in all copies or substantial\n * portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n#define _GNU_SOURCE\n\n#include <stdlib.h>\n#include <stdint.h>\n#include <assert.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <unistd.h>\n#include <dlfcn.h>\n#include <errno.h>\n#include <stdarg.h>\n#include <fcntl.h>\n#include <stdio.h>\n#include <sys/epoll.h>\n\n#include \"wayland-private.h\"\n#include \"test-runner.h\"\n#include \"wayland-os.h\"\n\nstatic int fall_back;\n\nstatic int (*real_socket)(int, int, int);\nstatic int wrapped_calls_socket;\n\nstatic int (*real_fcntl)(int, int, ...);\nstatic int wrapped_calls_fcntl;\n\nstatic ssize_t (*real_recvmsg)(int, struct msghdr *, int);\nstatic int wrapped_calls_recvmsg;\n\nstatic int (*real_epoll_create1)(int);\nstatic int wrapped_calls_epoll_create1;\n\nstatic void\ninit_fallbacks(int do_fallbacks)\n{\n\tfall_back = do_fallbacks;\n\treal_socket = dlsym(RTLD_NEXT, \"socket\");\n\treal_fcntl = dlsym(RTLD_NEXT, \"fcntl\");\n\treal_recvmsg = dlsym(RTLD_NEXT, \"recvmsg\");\n\treal_epoll_create1 = dlsym(RTLD_NEXT, \"epoll_create1\");\n}\n\n__attribute__ ((visibility(\"default\"))) int\nsocket(int domain, int type, int protocol)\n{\n\twrapped_calls_socket++;\n\n\tif (fall_back && (type & SOCK_CLOEXEC)) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\treturn real_socket(domain, type, protocol);\n}\n\n__attribute__ ((visibility(\"default\"))) int\nfcntl(int fd, int cmd, ...)\n{\n\tva_list ap;\n\tvoid *arg;\n\n\twrapped_calls_fcntl++;\n\n\tif (fall_back && (cmd == F_DUPFD_CLOEXEC)) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\tva_start(ap, cmd);\n\targ = va_arg(ap, void*);\n\tva_end(ap);\n\n\treturn real_fcntl(fd, cmd, arg);\n}\n\n__attribute__ ((visibility(\"default\"))) ssize_t\nrecvmsg(int sockfd, struct msghdr *msg, int flags)\n{\n\twrapped_calls_recvmsg++;\n\n\tif (fall_back && (flags & MSG_CMSG_CLOEXEC)) {\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\treturn real_recvmsg(sockfd, msg, flags);\n}\n\n__attribute__ ((visibility(\"default\"))) int\nepoll_create1(int flags)\n{\n\twrapped_calls_epoll_create1++;\n\n\tif (fall_back) {\n\t\twrapped_calls_epoll_create1++; /* epoll_create() not wrapped */\n\t\terrno = EINVAL;\n\t\treturn -1;\n\t}\n\n\treturn real_epoll_create1(flags);\n}\n\nstatic void\ndo_os_wrappers_socket_cloexec(int n)\n{\n\tint fd;\n\tint nr_fds;\n\n\tnr_fds = count_open_fds();\n\n\t/* simply create a socket that closes on exec */\n\tfd = wl_os_socket_cloexec(PF_LOCAL, SOCK_STREAM, 0);\n\tassert(fd >= 0);\n\n\t/*\n\t * Must have 2 calls if falling back, but must also allow\n\t * falling back without a forced fallback.\n\t */\n\tassert(wrapped_calls_socket > n);\n\n\texec_fd_leak_check(nr_fds);\n}\n\nTEST(os_wrappers_socket_cloexec)\n{\n\t/* normal case */\n\tinit_fallbacks(0);\n\tdo_os_wrappers_socket_cloexec(0);\n}\n\nTEST(os_wrappers_socket_cloexec_fallback)\n{\n\t/* forced fallback */\n\tinit_fallbacks(1);\n\tdo_os_wrappers_socket_cloexec(1);\n}\n\nstatic void\ndo_os_wrappers_dupfd_cloexec(int n)\n{\n\tint base_fd;\n\tint fd;\n\tint nr_fds;\n\n\tnr_fds = count_open_fds();\n\n\tbase_fd = socket(PF_LOCAL, SOCK_STREAM, 0);\n\tassert(base_fd >= 0);\n\n\tfd = wl_os_dupfd_cloexec(base_fd, 13);\n\tassert(fd >= 13);\n\n\tclose(base_fd);\n\n\t/*\n\t * Must have 4 calls if falling back, but must also allow\n\t * falling back without a forced fallback.\n\t */\n\tassert(wrapped_calls_fcntl > n);\n\n\texec_fd_leak_check(nr_fds);\n}\n\nTEST(os_wrappers_dupfd_cloexec)\n{\n\tinit_fallbacks(0);\n\tdo_os_wrappers_dupfd_cloexec(0);\n}\n\nTEST(os_wrappers_dupfd_cloexec_fallback)\n{\n\tinit_fallbacks(1);\n\tdo_os_wrappers_dupfd_cloexec(3);\n}\n\nstruct marshal_data {\n\tstruct wl_connection *read_connection;\n\tstruct wl_connection *write_connection;\n\tint s[2];\n\tuint32_t read_mask;\n\tuint32_t write_mask;\n\tunion {\n\t\tint h[3];\n\t} value;\n\tint nr_fds_begin;\n\tint nr_fds_conn;\n\tint wrapped_calls;\n};\n\nstatic void\nsetup_marshal_data(struct marshal_data *data)\n{\n\tassert(socketpair(AF_UNIX,\n\t\t\t  SOCK_STREAM | SOCK_CLOEXEC, 0, data->s) == 0);\n\n\tdata->read_connection = wl_connection_create(data->s[0]);\n\tassert(data->read_connection);\n\n\tdata->write_connection = wl_connection_create(data->s[1]);\n\tassert(data->write_connection);\n}\n\nstatic void\nmarshal_demarshal(struct marshal_data *data,\n\t\t  void (*func)(void), int size, const char *format, ...)\n{\n\tstruct wl_closure *closure;\n\tstatic const int opcode = 4444;\n\tstatic struct wl_object sender = { NULL, NULL, 1234 };\n\tstruct wl_message message = { \"test\", format, NULL };\n\tstruct wl_map objects;\n\tstruct wl_object object = { NULL, &func, 1234 };\n\tva_list ap;\n\tuint32_t msg[1] = { 1234 };\n\n\tva_start(ap, format);\n\tclosure = wl_closure_vmarshal(&sender, opcode, ap, &message);\n\tva_end(ap);\n\n\tassert(closure);\n\tassert(wl_closure_send(closure, data->write_connection) == 0);\n\twl_closure_destroy(closure);\n\tassert(wl_connection_flush(data->write_connection) == size);\n\n\tassert(wl_connection_read(data->read_connection) == size);\n\n\twl_map_init(&objects, WL_MAP_SERVER_SIDE);\n\tobject.id = msg[0];\n\tclosure = wl_connection_demarshal(data->read_connection,\n\t\t\t\t\t  size, &objects, &message);\n\tassert(closure);\n\twl_closure_invoke(closure, WL_CLOSURE_INVOKE_SERVER, &object, 0, data);\n\twl_closure_destroy(closure);\n}\n\nstatic void\nvalidate_recvmsg_h(struct marshal_data *data,\n\t\t   struct wl_object *object, int fd1, int fd2, int fd3)\n{\n\tstruct stat buf1, buf2;\n\n\tassert(fd1 >= 0);\n\tassert(fd2 >= 0);\n\tassert(fd3 >= 0);\n\n\tassert(fd1 != data->value.h[0]);\n\tassert(fd2 != data->value.h[1]);\n\tassert(fd3 != data->value.h[2]);\n\n\tassert(fstat(fd3, &buf1) == 0);\n\tassert(fstat(data->value.h[2], &buf2) == 0);\n\tassert(buf1.st_dev == buf2.st_dev);\n\tassert(buf1.st_ino == buf2.st_ino);\n\n\t/* close the original file descriptors */\n\tclose(data->value.h[0]);\n\tclose(data->value.h[1]);\n\tclose(data->value.h[2]);\n\n\t/* the dup'd (received) fds should still be open */\n\tassert(count_open_fds() == data->nr_fds_conn + 3);\n\n\t/*\n\t * Must have 2 calls if falling back, but must also allow\n\t * falling back without a forced fallback.\n\t */\n\tassert(wrapped_calls_recvmsg > data->wrapped_calls);\n\n\tif (data->wrapped_calls == 0 && wrapped_calls_recvmsg > 1)\n\t\tprintf(\"recvmsg fell back unforced.\\n\");\n\n\t/* all fds opened during the test in any way should be gone on exec */\n\texec_fd_leak_check(data->nr_fds_begin);\n}\n\nstatic void\ndo_os_wrappers_recvmsg_cloexec(int n)\n{\n\tstruct marshal_data data;\n\n\tdata.nr_fds_begin = count_open_fds();\n\tdata.wrapped_calls = n;\n\n\tsetup_marshal_data(&data);\n\tdata.nr_fds_conn = count_open_fds();\n\n\tassert(pipe(data.value.h) >= 0);\n\n\tdata.value.h[2] = open(\"/dev/zero\", O_RDONLY);\n\tassert(data.value.h[2] >= 0);\n\n\tmarshal_demarshal(&data, (void *) validate_recvmsg_h,\n\t\t\t  8, \"hhh\", data.value.h[0], data.value.h[1],\n\t\t\t  data.value.h[2]);\n}\n\nTEST(os_wrappers_recvmsg_cloexec)\n{\n\tinit_fallbacks(0);\n\tdo_os_wrappers_recvmsg_cloexec(0);\n}\n\nTEST(os_wrappers_recvmsg_cloexec_fallback)\n{\n\tinit_fallbacks(1);\n\tdo_os_wrappers_recvmsg_cloexec(1);\n}\n\nstatic void\ndo_os_wrappers_epoll_create_cloexec(int n)\n{\n\tint fd;\n\tint nr_fds;\n\n\tnr_fds = count_open_fds();\n\n\tfd = wl_os_epoll_create_cloexec();\n\tassert(fd >= 0);\n\n#ifdef EPOLL_CLOEXEC\n\tassert(wrapped_calls_epoll_create1 == n);\n#else\n\tprintf(\"No epoll_create1.\\n\");\n#endif\n\n\texec_fd_leak_check(nr_fds);\n}\n\nTEST(os_wrappers_epoll_create_cloexec)\n{\n\tinit_fallbacks(0);\n\tdo_os_wrappers_epoll_create_cloexec(1);\n}\n\nTEST(os_wrappers_epoll_create_cloexec_fallback)\n{\n\tinit_fallbacks(1);\n\tdo_os_wrappers_epoll_create_cloexec(2);\n}\n\n/* FIXME: add tests for wl_os_accept_cloexec() */\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-wayland-1.18.0-6v6qglaw2utv7glyjk2wdgbnkqpo3v6t/spack-src/src/dtddata.S",
        "/tmp/vanessa/spack-stage/spack-stage-wayland-1.18.0-6v6qglaw2utv7glyjk2wdgbnkqpo3v6t/spack-src/cursor/cursor.pcf",
        "/tmp/vanessa/spack-stage/spack-stage-wayland-1.18.0-6v6qglaw2utv7glyjk2wdgbnkqpo3v6t/spack-src/doc/publican/sources/images/xwayland-architecture.png",
        "/tmp/vanessa/spack-stage/spack-stage-wayland-1.18.0-6v6qglaw2utv7glyjk2wdgbnkqpo3v6t/spack-src/doc/publican/sources/images/wayland.png"
    ],
    "total_files": 163
}