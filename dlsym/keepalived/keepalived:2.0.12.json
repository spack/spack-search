{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-keepalived-2.0.12-hqbu65pccond3zcjeitk4jaih4fahmth/spack-src/keepalived/vrrp/vrrp_ipset.c": "/*\n * Soft:        Keepalived is a failover program for the LVS project\n *              <www.linuxvirtualserver.org>. It monitor & manipulate\n *              a loadbalanced server pool using multi-layer checks.\n *\n * Part:        ipset manipulation used in conjunction with iptables\n *\n * Author:      Quentin Armitage, <quentin@armitage.org.uk>\n *\n *              This program is distributed in the hope that it will be useful,\n *              but WITHOUT ANY WARRANTY; without even the implied warranty of\n *              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n *              See the GNU General Public License for more details.\n *\n *              This program is free software; you can redistribute it and/or\n *              modify it under the terms of the GNU General Public License\n *              as published by the Free Software Foundation; either version\n *              2 of the License, or (at your option) any later version.\n *\n * Copyright (C) 2001-2017 Alexandre Cassen, <acassen@gmail.com>\n */\n\n/* We dynamically attempt to load the library \"by hand\", since keepalived\n * may have been built on a system with ipsets, but the target system may\n * not have the ipset libraries installed.\n *\n * If the ipset libraries are not installed, keepalived will fallback to\n * adding entries into iptables.\n */\n\n#include \"config.h\"\n\n#include <net/if.h>\t\t/* Force inclusion of net/if.h before linux/if.h */\n#define LIBIPSET_NFPROTO_H\n#define LIBIPSET_NF_INET_ADDR_H\n#if defined LIBIPSET_H_ADD_UAPI_IP_SET_H_GUARD || defined LIBIPSET_H_ADD_IP_SET_H_GUARD\n#include <linux/netfilter/ipset/ip_set.h>\n#if defined LIBIPSET_H_ADD_UAPI_IP_SET_H_GUARD\n#define _UAPI_IP_SET_H\n#else\n#define _IP_SET_H\n#endif\n#endif\n#include <libipset/session.h>\n#include <libipset/types.h>\n#ifndef LIBIPSET_PRE_V7_COMPAT\n#include <libipset/ipset.h>\n#endif\n#include <netinet/in.h>\n#include <linux/types.h>\t/* For __beXX types in userland */\n#include <linux/netfilter.h>\t/* For nf_inet_addr */\n#include <stdint.h>\n\n#include \"logger.h\"\n#include \"global_data.h\"\n#include \"vrrp_ipset.h\"\n#include \"vrrp_firewall.h\"\n#include \"vrrp_iptables_calls.h\"\n#include \"main.h\"\n\n#ifdef _LIBIPSET_DYNAMIC_\n#include <dlfcn.h>\n\n/* The addresses of the functions we want */\n#ifdef LIBIPSET_PRE_V7_COMPAT\nstruct ipset_session* (*ipset_session_init_addr)(ipset_outfn outfn);\n#else\nstruct ipset_session* (*ipset_session_init_addr)(ipset_print_outfn outfn, void *p);\n#endif\nint (*ipset_session_fini_addr)(struct ipset_session *session);\nstruct ipset_data* (*ipset_session_data_addr)(const struct ipset_session *session);\n#ifdef LIBIPSET_PRE_V7_COMPAT\nint (*ipset_envopt_parse_addr)(struct ipset_session *session, int env, const char *str);\n#else\nvoid (*ipset_envopt_set_addr)(struct ipset_session *session, int env);\n#endif\nconst struct ipset_type* (*ipset_type_get_addr)(struct ipset_session *session, enum ipset_cmd cmd);\nint (*ipset_data_set_addr)(struct ipset_data *data, enum ipset_opt opt, const void *value);\nint (*ipset_cmd_addr)(struct ipset_session *session, enum ipset_cmd cmd, uint32_t lineno);\nvoid (*ipset_load_types_addr)(void);\n\n/* We can (almost) make it look as though normal linking is being used */\n#define ipset_session_init (*ipset_session_init_addr)\n#define ipset_session_fini (*ipset_session_fini_addr)\n#define ipset_session_data (*ipset_session_data_addr)\n#ifdef LIBIPSET_PRE_V7_COMPAT\n#define ipset_envopt_parse (*ipset_envopt_parse_addr)\n#else\n#define ipset_envopt_set (*ipset_envopt_set_addr)\n#endif\n#define ipset_type_get (*ipset_type_get_addr)\n#define ipset_data_set (*ipset_data_set_addr)\n/* Unfortunately ipset_cmd conflicts with struct ipset_cmd */\n#define ipset_cmd1 (*ipset_cmd_addr)\n#define ipset_load_types (*ipset_load_types_addr)\n\nstatic void* libipset_handle;\n#else\n#define ipset_cmd1 ipset_cmd\n#endif\n\nstatic int\n#ifdef LIBIPSET_PRE_V7_COMPAT\nipset_printf(const char *fmt, ...)\n#else\nipset_printf(__attribute ((__unused__)) struct ipset_session *session, void *p, const char *fmt, ...)\n#endif\n{\n\tva_list args;\n\n#ifndef LIBIPSET_PRE_V7_COMPAT\n\tlog_message(LOG_INFO, \"libipset message from %s\", (const char *)p);\n#endif\n\n\tva_start(args, fmt);\n\tvlog_message(LOG_INFO, fmt, args);\n\tva_end(args);\n\n\treturn 0;\n}\n\nstatic bool\ndo_ipset_cmd(struct ipset_session* session, enum ipset_cmd cmd, const char *setname,\n\t\tconst ip_address_t *addr, uint32_t timeout, const char* iface)\n{\n\tconst struct ipset_type *type;\n\tuint8_t family;\n\tint r;\n\n\tipset_session_data_set(session, IPSET_SETNAME, setname);\n\n\ttype = ipset_type_get(session, cmd);\n\tif (type == NULL) {\n\t\t/* possible reasons for failure: set name does not exist */\n\t\treturn false;\n\t}\n\n\tfamily = (addr->ifa.ifa_family == AF_INET) ? NFPROTO_IPV4 : NFPROTO_IPV6;\n\tipset_session_data_set(session, IPSET_OPT_FAMILY, &family);\n\tipset_session_data_set(session, IPSET_OPT_IP, &addr->u);\n\tif (timeout)\n\t\tipset_session_data_set(session, IPSET_OPT_TIMEOUT, &timeout);\n\tif (iface)\n\t\tipset_session_data_set(session, IPSET_OPT_IFACE, iface);\n\n\tr = ipset_cmd1(session, cmd, 0);\n\n\treturn r == 0;\n}\n\nstatic bool\nipset_create(struct ipset_session* session, const char *setname, const char *typename, uint8_t family)\n{\n\tconst struct ipset_type *type;\n\tint r;\n\n\tipset_session_data_set(session, IPSET_SETNAME, setname);\n\n\tipset_session_data_set(session, IPSET_OPT_TYPENAME, typename);\n\n\ttype = ipset_type_get(session, IPSET_CMD_CREATE);\n\tif (type == NULL)\n\t\treturn false;\n\n\tipset_session_data_set(session, IPSET_OPT_TYPE, type);\n\tipset_session_data_set(session, IPSET_OPT_FAMILY, &family);\n\n\tr = ipset_cmd1(session, IPSET_CMD_CREATE, 0);\n\treturn r == 0;\n}\n\nstatic bool\nipset_destroy(struct ipset_session* session, const char *setname)\n{\n\tint r;\n\n\tipset_session_data_set(session, IPSET_SETNAME, setname);\n\n\tr = ipset_cmd1(session, IPSET_CMD_DESTROY, 0);\n\treturn r == 0;\n}\n\nbool\nhas_ipset_setname(void* vsession, const char *setname)\n{\n\tstruct ipset_session *session = vsession;\n\n\tipset_session_data_set(session, IPSET_SETNAME, setname);\n\n\treturn ipset_cmd1(session, IPSET_CMD_HEADER, 0) == 0;\n}\n\nstatic bool create_sets(const char* addr4, const char* addr6, const char* addr_if6, bool reload)\n{\n\tstruct ipset_session *session;\n\n#ifdef LIBIPSET_PRE_V7_COMPAT\n\tsession = ipset_session_init(ipset_printf);\n#else\n\tsession = ipset_session_init(ipset_printf, \"create_sets\");\n#endif\n\tif (!session) {\n\t\tlog_message(LOG_INFO, \"Cannot initialize ipset session.\");\n\t\treturn false;\n\t}\n\n\t/* If we aren't reloading, don't worry if sets already exists. With the\n\t * IPSET_ENV_EXIST option set, any existing entries in the set are removed. */\n\tif (!reload)\n#ifdef LIBIPSET_PRE_V7_COMPAT\n\t\tipset_envopt_parse(session, IPSET_ENV_EXIST, NULL);\n#else\n\t\tipset_envopt_set(session, IPSET_ENV_EXIST);\n#endif\n\n\tif (block_ipv4) {\n\t\tif (!reload || !has_ipset_setname(session, addr4))\n\t\t\tipset_create(session, addr4, \"hash:ip\", NFPROTO_IPV4);\n\t}\n\n\tif (block_ipv6) {\n\t\tif (!reload || !has_ipset_setname(session, addr6))\n\t\t\tipset_create(session, addr6, \"hash:ip\", NFPROTO_IPV6);\n\t\tif (!reload || !has_ipset_setname(session, addr_if6)) {\n#ifdef HAVE_IPSET_ATTR_IFACE\n\t\t\t/* hash:net,iface was introduced in Linux 3.1 */\n\t\t\tipset_create(session, addr_if6, \"hash:net,iface\", NFPROTO_IPV6);\n#else\n\t\t\tipset_create(session, addr_if6, \"hash:ip\", NFPROTO_IPV6);\n#endif\n\t\t}\n\t}\n\n\tipset_session_fini(session);\n\n\treturn true;\n}\n\nstatic\nbool set_match_loaded(void)\n{\n\tchar buf[XT_FUNCTION_MAXNAMELEN+1];\n\tFILE *fp;\n\tbool found = false;\n\n\tfp = fopen( \"/proc/net/ip_tables_matches\", \"r\");\n\tif (!fp)\n\t\treturn false;\n\n\twhile (fgets(buf, sizeof(buf), fp)) {\n\t\tif ((buf[3] == '\\0' || buf[3] == '\\n') &&\n\t\t    !strncmp(buf, \"set\", 3)) {\n\t\t\tfound = true;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tfclose(fp);\n\n\treturn found;\n}\n\nbool ipset_initialise(void)\n{\n#ifdef _LIBIPSET_DYNAMIC_\n\tif (libipset_handle)\n\t\treturn true;\n#endif\n\n#if HAVE_DECL_CLONE_NEWNET\n\t/* Don't attempt to use ipsets if running in a namespace and the default\n\t * set names have not been overridden and the kernel version is less\n\t * than Linux 3.13, since ipsets didn't understand namespaces prior to that. */\n\tif (global_data->network_namespace &&\n\t    !global_data->namespace_with_ipsets &&\n\t    !strcmp(global_data->vrrp_ipset_address, DEFAULT_IPSET_NAME) &&\n\t    (os_major <= 2 ||\n\t     (os_major == 3 && os_minor < 13))) {\n\t\tlog_message(LOG_INFO, \"Not using ipsets with network namespace since not supported with kernel version < 3.13\");\n\t\treturn false;\n\t}\n#endif\n\n#ifdef _LIBIPSET_DYNAMIC_\n\t/* Attempt to open the ipset library */\n\tif (!(libipset_handle = dlopen(\"libipset.so\", RTLD_NOW)) &&\n\t    !(libipset_handle = dlopen(IPSET_LIB_NAME, RTLD_NOW))) {\n\t\tlog_message(LOG_INFO, \"Unable to load ipset library - %s\", dlerror());\n\t\treturn false;\n\t}\n\n\tif (!(ipset_session_init_addr = dlsym(libipset_handle, \"ipset_session_init\")) ||\n\t    !(ipset_session_fini_addr = dlsym(libipset_handle, \"ipset_session_fini\")) ||\n\t    !(ipset_session_data_addr = dlsym(libipset_handle,\"ipset_session_data\")) ||\n#ifdef LIBIPSET_PRE_V7_COMPAT\n\t    !(ipset_envopt_parse_addr = dlsym(libipset_handle,\"ipset_envopt_parse\")) ||\n#else\n\t    !(ipset_envopt_set_addr = dlsym(libipset_handle,\"ipset_envopt_set\")) ||\n#endif\n\t    !(ipset_type_get_addr = dlsym(libipset_handle,\"ipset_type_get\")) ||\n\t    !(ipset_data_set_addr = dlsym(libipset_handle,\"ipset_data_set\")) ||\n\t    !(ipset_cmd_addr = dlsym(libipset_handle,\"ipset_cmd\")) ||\n\t    !(ipset_load_types_addr = dlsym(libipset_handle,\"ipset_load_types\"))) {\n\t\tlog_message(LOG_INFO, \"Failed to dynamic link an ipset function - %s\", dlerror());\n\t\treturn false;\n\t}\n#endif\n\n\tipset_load_types();\n\n\tif (!set_match_loaded() && !load_xtables_module(\"xt_set\", \"ipsets\")) {\n\t\tlog_message(LOG_INFO, \"Unable to load module xt_set - not using ipsets\");\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nbool remove_ipsets(void)\n{\n\tstruct ipset_session *session;\n\n\tif (!global_data->using_ipsets)\n\t\treturn true;\n\n#ifdef _LIBIPSET_DYNAMIC_\n\tif (!libipset_handle)\n\t\treturn true;\n#endif\n\n#ifdef LIBIPSET_PRE_V7_COMPAT\n\tsession = ipset_session_init(ipset_printf);\n#else\n\tsession = ipset_session_init(ipset_printf, \"remove_ipsets\");\n#endif\n\tif (!session) {\n\t\tlog_message(LOG_INFO, \"Cannot initialize ipset session.\");\n\t\treturn false;\n\t}\n\n\tif (block_ipv4)\n\t\tipset_destroy(session, global_data->vrrp_ipset_address);\n\n\tif (block_ipv6) {\n\t\tipset_destroy(session, global_data->vrrp_ipset_address6);\n\t\tipset_destroy(session, global_data->vrrp_ipset_address_iface6);\n\t}\n\n\tipset_session_fini(session);\n\n\treturn true;\n}\n\nbool add_ipsets(bool reload)\n{\n\treturn create_sets(global_data->vrrp_ipset_address, global_data->vrrp_ipset_address6, global_data->vrrp_ipset_address_iface6, reload);\n}\n\nvoid* ipset_session_start(void)\n{\n#ifdef LIBIPSET_PRE_V7_COMPAT\n\treturn ipset_session_init(ipset_printf);\n#else\n\treturn ipset_session_init(ipset_printf, \"session_start\");\n#endif\n}\n\nvoid ipset_session_end(void* vsession)\n{\n\tstruct ipset_session *session = vsession;\n\n\tipset_session_fini(session);\n}\n\nvoid ipset_entry(void* vsession, int cmd, const ip_address_t* addr)\n{\n\tconst char* set;\n\tchar *iface = NULL;\n\tstruct ipset_session *session = vsession;\n\n\n\tif (addr->ifa.ifa_family == AF_INET) {\n\t\tif (!block_ipv4)\n\t\t\treturn;\n\t\tset = global_data->vrrp_ipset_address;\n\t}\n\telse if (IN6_IS_ADDR_LINKLOCAL(&addr->u.sin6_addr)) {\n\t\tif (!block_ipv6)\n\t\t\treturn;\n\n\t\tset = global_data->vrrp_ipset_address_iface6;\n#ifdef HAVE_IPSET_ATTR_IFACE\n\t\tiface = addr->ifp->ifname;\n#endif\n\t}\n\telse\n\t\tset = global_data->vrrp_ipset_address6;\n\n\tdo_ipset_cmd(session, (cmd == IPADDRESS_DEL) ? IPSET_CMD_DEL : IPSET_CMD_ADD, set, addr, 0, iface);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-keepalived-2.0.12-hqbu65pccond3zcjeitk4jaih4fahmth/spack-src/keepalived/vrrp/vrrp_iptables_calls.c": "/*\n * Soft:        Keepalived is a failover program for the LVS project\n *              <www.linuxvirtualserver.org>. It monitor & manipulate\n *              a loadbalanced server pool using multi-layer checks.\n *\n * Part:        iptables manipulation.\n *\n * Author:      Quentin Armitage, <quentin@armitage.org.uk>\n *\n *              This program is distributed in the hope that it will be useful,\n *              but WITHOUT ANY WARRANTY; without even the implied warranty of\n *              MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n *              See the GNU General Public License for more details.\n *\n *              This program is free software; you can redistribute it and/or\n *              modify it under the terms of the GNU General Public License\n *              as published by the Free Software Foundation; either version\n *              2 of the License, or (at your option) any later version.\n *\n * Copyright (C) 2001-2017 Alexandre Cassen, <acassen@gmail.com>\n */\n\n#include \"config.h\"\n\n#ifdef _HAVE_LIBIPTC_LINUX_NET_IF_H_COLLISION_\n/* Linux 4.5 introduced a namespace collision when including\n * libiptc/libiptc.h due to both net/if.h and linux/if.h\n * being included.\n *\n * See: http://bugzilla.netfilter.org/show_bug.cgi?id=1067\n *\n * Including net/if.h first stops the problem occuring.\n */\n#include <net/if.h>\n#endif\n\n#include <xtables.h>\n#include <libiptc/libiptc.h>\n#include <libiptc/libip6tc.h>\n#ifdef _HAVE_LIBIPSET_\n#ifdef USE_LIBIPSET_LINUX_IP_SET_H\n#include <libipset/linux_ip_set.h>\n#else\n#include <linux/netfilter/ipset/ip_set.h>\n#endif\n#include <linux/netfilter/xt_set.h>\n#endif\n#include <unistd.h>\n#include <signal.h>\n#include <errno.h>\n#include <stdint.h>\n\n#include \"vrrp_iptables_calls.h\"\n#include \"memory.h\"\n#include \"logger.h\"\n#if !HAVE_DECL_SOCK_CLOEXEC\n#include \"old_socket.h\"\n#endif\n#ifdef _LIBIPTC_DYNAMIC_\n#include \"global_data.h\"\n#endif\n#include \"vrrp_iptables_lib.h\"\n#include \"vrrp_firewall.h\"\n\n/* We sometimes get a resource_busy on iptc_commit. This appears to happen\n * when someone else is also updating it.\n * Tests show that the EAGAIN error is generated if someone else did an\n * update via iptc_commit between us doing iptc_init and iptc_commit, i.e.\n * if there had been an update since out init prior to our commit.\n *\n * Documentation seems to suggest that iptc_init takes a snapshot of the\n * state of iptables. This fits with the tests, but also means that we could\n * be interferred with by anyone else doing an update.\n */\n\n#ifdef _LIBIPTC_DYNAMIC_\n#include <dlfcn.h>\n\n/* The addresses of the functions we want */\nstruct iptc_handle *(*iptc_init_addr)(const char *tablename);\nvoid (*iptc_free_addr)(struct iptc_handle *h);\nint (*iptc_is_chain_addr)(const char *chain, struct iptc_handle *const handle);\nint (*iptc_insert_entry_addr)(const ipt_chainlabel chain, const struct ipt_entry *e, unsigned int rulenum, struct iptc_handle *handle);\nint (*iptc_append_entry_addr)(const ipt_chainlabel chain, const struct ipt_entry *e, struct iptc_handle *handle);\nint (*iptc_delete_entry_addr)(const ipt_chainlabel chain, const struct ipt_entry *origfw, unsigned char *matchmask, struct iptc_handle *handle);\nint (*iptc_commit_addr)(struct iptc_handle *handle);\nconst char *(*iptc_strerror_addr)(int err);\n\nstruct ip6tc_handle *(*ip6tc_init_addr)(const char *tablename);\nvoid (*ip6tc_free_addr)(struct ip6tc_handle *h);\nint (*ip6tc_is_chain_addr)(const char *chain, struct ip6tc_handle *const handle);\nint (*ip6tc_insert_entry_addr)(const ip6t_chainlabel chain, const struct ip6t_entry *e, unsigned int rulenum, struct ip6tc_handle *handle);\nint (*ip6tc_append_entry_addr)(const ip6t_chainlabel chain, const struct ip6t_entry *e, struct ip6tc_handle *handle);\nint (*ip6tc_delete_entry_addr)(const ip6t_chainlabel chain, const struct ip6t_entry *origfw, unsigned char *matchmask, struct ip6tc_handle *handle);\nint (*ip6tc_commit_addr)(struct ip6tc_handle *handle);\nconst char *(*ip6tc_strerror_addr)(int err);\n\n/* We can make it look as though normal linking is being used */\n#define iptc_init (*iptc_init_addr)\n#define iptc_free (*iptc_free_addr)\n#define iptc_is_chain (*iptc_is_chain_addr)\n#define iptc_insert_entry (*iptc_insert_entry_addr)\n#define iptc_append_entry (*iptc_append_entry_addr)\n#define iptc_delete_entry (*iptc_delete_entry_addr)\n#define iptc_commit (*iptc_commit_addr)\n#define iptc_strerror (*iptc_strerror_addr)\n\n#define ip6tc_init (*ip6tc_init_addr)\n#define ip6tc_free (*ip6tc_free_addr)\n#define ip6tc_is_chain (*ip6tc_is_chain_addr)\n#define ip6tc_insert_entry (*ip6tc_insert_entry_addr)\n#define ip6tc_append_entry (*ip6tc_append_entry_addr)\n#define ip6tc_delete_entry (*ip6tc_delete_entry_addr)\n#define ip6tc_commit (*ip6tc_commit_addr)\n#define ip6tc_strerror (*ip6tc_strerror_addr)\n\nstatic void* libip4tc_handle;\nstatic void* libip6tc_handle;\n#endif\n\n#ifdef _LIBXTABLES_DYNAMIC_\n#include <dlfcn.h>\n\n/* The addresses of the functions we want */\nint (*xtables_insmod_addr)(const char *, const char *, bool);\n\n/* We can make it look as though normal linking is being used */\n#define xtables_insmod (*xtables_insmod_addr)\n\nstatic void *libxtables_handle;\n#endif\n\nstatic void\nset_iface(char *vianame, unsigned char *mask, const char *iface)\n{\n\tsize_t vialen = strlen(iface);\n\n\tmemset(vianame, 0, IFNAMSIZ);\n\tmemset(mask, 0, IFNAMSIZ);\n\n\tstrcpy(vianame, iface);\n\tif (!vialen)\n\t\treturn;\n\n\tmemset(mask, 0xFF, vialen + 1);\n}\n\n/* Initializes a new iptables instance and returns an iptables resource associated with the new iptables table */\nstruct iptc_handle* ip4tables_open ( const char* tablename )\n{\n\tstruct iptc_handle *h ;\n\n\tif ( !( h = iptc_init ( tablename ) ) )\n\t\treturn NULL ;\n\n\treturn h ;\n}\n\nint ip4tables_close ( struct iptc_handle* handle, int updated )\n{\n\tint res = 1;\n\tint sav_errno ;\n\n\tif (updated) {\n\t\tif ( ( res = iptc_commit ( handle ) ) != 1 )\n\t\t{\n\t\t\tsav_errno = errno ;\n\t\t\tlog_message(LOG_INFO, \"iptc_commit returned %d: %s\", res, iptc_strerror (sav_errno) );\n\t\t}\n\t}\n\n\tiptc_free ( handle ) ;\n\n\tif ( res == 1 )\n\t\treturn 0 ;\n\telse\n\t\treturn ( sav_errno ) ;\n}\n\nint ip4tables_is_chain(struct iptc_handle* handle, const char* chain_name)\n{\n\treturn iptc_is_chain(chain_name, handle);\n}\n\nint ip4tables_process_entry( struct iptc_handle* handle, const char* chain_name, unsigned int rulenum, const char* target_name, const ip_address_t* src_ip_address, const ip_address_t* dst_ip_address, const char* in_iface, const char* out_iface, uint16_t protocol, uint8_t type, int cmd, bool force)\n{\n\tsize_t size;\n\tstruct ipt_entry *fw;\n\tstruct xt_entry_target *target;\n\tstruct xt_entry_match *match ;\n\tipt_chainlabel chain;\n\tint res;\n\tint sav_errno;\n\n\t/* Add an entry */\n\n\tmemset (chain, 0, sizeof (chain));\n\n\tsize = XT_ALIGN (sizeof (struct ipt_entry)) +\n\t\t\tXT_ALIGN (sizeof (struct xt_entry_target) + 1);\n\n\tif ( protocol == IPPROTO_ICMP )\n\t\tsize += XT_ALIGN ( sizeof(struct xt_entry_match) ) + XT_ALIGN ( sizeof(struct ipt_icmp) ) ;\n\n\tfw = (struct ipt_entry*)MALLOC(size);\n\n\tfw->target_offset = XT_ALIGN ( sizeof ( struct ipt_entry ) ) ;\n\n\tif ( src_ip_address && src_ip_address->ifa.ifa_family != AF_UNSPEC )\n\t{\n\t\tmemcpy(&fw->ip.src, &src_ip_address->u.sin.sin_addr, sizeof ( src_ip_address->u.sin.sin_addr ) );\n\t\tmemset ( &fw->ip.smsk, 0xff, sizeof(fw->ip.smsk));\n\t}\n\n\tif ( dst_ip_address && dst_ip_address->ifa.ifa_family != AF_UNSPEC )\n\t{\n\t\tmemcpy(&fw->ip.dst, &dst_ip_address->u.sin.sin_addr, sizeof ( dst_ip_address->u.sin.sin_addr ) );\n\t\tmemset ( &fw->ip.dmsk, 0xff, sizeof(fw->ip.dmsk));\n\t}\n\n\tif (in_iface)\n\t\tset_iface(fw->ip.iniface, fw->ip.iniface_mask, in_iface);\n\tif (out_iface)\n\t\tset_iface(fw->ip.outiface, fw->ip.outiface_mask, out_iface);\n\n\tif ( protocol != IPPROTO_NONE ) {\n\t\tfw->ip.proto = protocol ;\n\n//\t\tfw->ip.flags |= IP6T_F_PROTO ;\t\t// IPv6 only\n\n\t\tif ( protocol == IPPROTO_ICMP )\n\t\t{\n\t\t\tmatch = (struct xt_entry_match*)((char*)fw + fw->target_offset);\n\t\t\tmatch->u.match_size = XT_ALIGN(sizeof (struct xt_entry_match)) + XT_ALIGN(sizeof(struct ipt_icmp));\n\t\t\tmatch->u.user.revision = 0;\n\t\t\tfw->target_offset = (uint16_t)(fw->target_offset + match->u.match_size);\n\t\t\tstrcpy ( match->u.user.name, \"icmp\" ) ;\n\n\t\t\tstruct ipt_icmp *icmpinfo = (struct ipt_icmp *) match->data;\n\t\t\ticmpinfo->type = type ;\t\t// type to match\n\t\t\ticmpinfo->code[0] = 0 ;\t\t// code lower\n\t\t\ticmpinfo->code[1] = 0xff ;\t// code upper\n\t\t\ticmpinfo->invflags = 0 ;\t// don't invert\n\t\t}\n\t}\n\n// target is XTC_LABEL_DROP/XTC_LABEL_ACCEPT\n\tfw->next_offset = (uint16_t)size;\n\ttarget = ipt_get_target ( fw ) ;\n\ttarget->u.user.target_size = XT_ALIGN (sizeof (struct xt_entry_target) + 1);\n\tstrcpy (target->u.user.name, target_name );\n//\tfw->ip.flags |= IPT_F_GOTO;\n\tstrcpy (chain, chain_name);\n\t// Use iptc_append_entry to add to the chain\n\tif (cmd == IPADDRESS_DEL) {\n\t\tunsigned char matchmask[fw->next_offset];\n\t\tmemset(matchmask, 0xff, fw->next_offset);\n\t\tres = iptc_delete_entry(chain, fw, matchmask, handle);\n\t}\n\telse if (rulenum == APPEND_RULE)\n\t\tres = iptc_append_entry (chain, fw, handle ) ;\n\telse\n\t\tres = iptc_insert_entry (chain, fw, rulenum, handle ) ;\n\n\tsav_errno = errno ;\n\n\tFREE(fw);\n\n\tif (res !=  1 && (!force || sav_errno != ENOENT))\n\t{\n\t\tlog_message(LOG_INFO, \"ip4tables_process_entry for chain %s returned %d: %s\", chain, res, iptc_strerror (sav_errno) ) ;\n\n\t\treturn sav_errno ;\n\t}\n\n\treturn 0 ;\n}\n\n/* Initializes a new iptables instance and returns an iptables resource associated with the new iptables table */\nstruct ip6tc_handle* ip6tables_open ( const char* tablename )\n{\n\tstruct ip6tc_handle *h ;\n\n\tif ( !( h = ip6tc_init ( tablename ) ) )\n\t\treturn NULL ;\n\n\treturn h ;\n}\n\nint ip6tables_close ( struct ip6tc_handle* handle, int updated )\n{\n\tint res = 1;\n\tint sav_errno ;\n\n\tif (updated) {\n\t\tif ( ( res = ip6tc_commit ( handle ) ) != 1 )\n\t\t{\n\t\t\tsav_errno = errno ;\n\t\t\tlog_message(LOG_INFO, \"iptc_commit returned %d: %s\", res, ip6tc_strerror (sav_errno) );\n\t\t}\n\t}\n\n\tip6tc_free ( handle ) ;\n\n\tif ( res == 1 )\n\t\treturn 0 ;\n\telse\n\t\treturn ( sav_errno ) ;\n}\n\nint ip6tables_is_chain(struct ip6tc_handle* handle, const char* chain_name)\n{\n\treturn ip6tc_is_chain(chain_name, handle);\n}\n\nint ip6tables_process_entry( struct ip6tc_handle* handle, const char* chain_name, unsigned int rulenum, const char* target_name, const ip_address_t* src_ip_address, const ip_address_t* dst_ip_address, const char* in_iface, const char* out_iface, uint16_t protocol, uint8_t type, int cmd, bool force)\n{\n\tsize_t size;\n\tstruct ip6t_entry *fw;\n\tstruct xt_entry_target *target;\n\tstruct xt_entry_match *match ;\n\tip6t_chainlabel chain;\n\tint res;\n\tint sav_errno;\n\n\t/* Add an entry */\n\n\tmemset (chain, 0, sizeof (chain));\n\n\tsize = XT_ALIGN (sizeof (struct ip6t_entry)) +\n\t\t\tXT_ALIGN (sizeof (struct xt_entry_target) + 1);\n\n\tif ( protocol == IPPROTO_ICMPV6 )\n\t\tsize += XT_ALIGN ( sizeof(struct xt_entry_match) ) + XT_ALIGN ( sizeof(struct ip6t_icmp) ) ;\n\n\tfw = (struct ip6t_entry*)MALLOC(size);\n\n\tfw->target_offset = XT_ALIGN ( sizeof ( struct ip6t_entry ) ) ;\n\n\tif ( src_ip_address && src_ip_address->ifa.ifa_family != AF_UNSPEC ) {\n\t\tmemcpy(&fw->ipv6.src, &src_ip_address->u.sin6_addr, sizeof ( src_ip_address->u.sin6_addr ) );\n\t\tmemset ( &fw->ipv6.smsk, 0xff, sizeof(fw->ipv6.smsk));\n\t}\n\n\tif ( dst_ip_address && dst_ip_address->ifa.ifa_family != AF_UNSPEC ) {\n\t\tmemcpy(&fw->ipv6.dst, &dst_ip_address->u.sin6_addr, sizeof ( dst_ip_address->u.sin6_addr ) );\n\t\tmemset ( &fw->ipv6.dmsk, 0xff, sizeof(fw->ipv6.smsk));\n\t}\n\n\tif (in_iface)\n\t\tset_iface(fw->ipv6.iniface, fw->ipv6.iniface_mask, in_iface);\n\tif (out_iface)\n\t\tset_iface(fw->ipv6.outiface, fw->ipv6.outiface_mask, out_iface);\n\n\tif ( protocol != IPPROTO_NONE ) {\n\t\tfw->ipv6.proto = protocol ;\n\n\t\tfw->ipv6.flags |= IP6T_F_PROTO ;\t\t// IPv6 only\n\n\t\tif ( protocol == IPPROTO_ICMPV6 )\n\t\t{\n\t\t\tmatch = (struct xt_entry_match*)((char*)fw + fw->target_offset);\n\t\t\tmatch->u.match_size = XT_ALIGN ( sizeof (struct xt_entry_match) ) + XT_ALIGN ( sizeof (struct ip6t_icmp) ) ;\n\t\t\tmatch->u.user.revision = 0;\n\t\t\tfw->target_offset = (uint16_t)(fw->target_offset + match->u.match_size);\n\t\t\tstrcpy ( match->u.user.name, \"icmp6\" ) ;\n\n\t\t\tstruct ip6t_icmp *icmpinfo = (struct ip6t_icmp *) match->data;\n\t\t\ticmpinfo->type = type ;\t\t// type to match\n\t\t\ticmpinfo->code[0] = 0 ;\t\t// code lower\n\t\t\ticmpinfo->code[1] = 0xff ;\t// code upper\n\t\t\ticmpinfo->invflags = 0 ;\t// don't invert\n\t\t}\n\t}\n\n// target is XTC_LABEL_DROP/XTC_LABEL_ACCEPT\n\tfw->next_offset = (uint16_t)size;\n\ttarget = ip6t_get_target ( fw ) ;\n\ttarget->u.user.target_size = XT_ALIGN (sizeof (struct xt_entry_target) + 1);\n\tstrcpy (target->u.user.name, target_name );\n//\tfw->ip.flags |= IPT_F_GOTO;\n\tstrcpy (chain, chain_name);\n\n\t// Use iptc_append_entry to add to the chain\n\tif (cmd == IPADDRESS_DEL) {\n\t\tunsigned char matchmask[fw->next_offset];\n\t\tmemset(matchmask, 0xff, fw->next_offset);\n\t\tres = ip6tc_delete_entry ( chain, fw, matchmask, handle);\n\t}\n\telse if (rulenum == APPEND_RULE)\n\t\tres = ip6tc_append_entry (chain, fw, handle ) ;\n\telse\n\t\tres = ip6tc_insert_entry (chain, fw, rulenum, handle ) ;\n\n\tsav_errno = errno ;\n\n\tFREE(fw);\n\n\tif (res !=  1 && (!force || sav_errno != ENOENT))\n\t{\n\t\tlog_message(LOG_INFO, \"ip6tables_process_entry for chain %s returned %d: %s\", chain, res, ip6tc_strerror (sav_errno) ) ;\n\n\t\treturn sav_errno ;\n\t}\n\n\treturn 0 ;\n}\n\n#ifdef _HAVE_LIBIPTC_\n#ifdef _LIBXTABLES_DYNAMIC_\nstatic\nbool xtables_load(void)\n{\n\tif (libxtables_handle)\n\t\treturn true;\n\n\tif (!(libxtables_handle = dlopen(\"libxtables.so\", RTLD_NOW)) &&\n\t    !(libxtables_handle = dlopen(XTABLES_LIB_NAME, RTLD_NOW))) {\n\t\tlog_message(LOG_INFO, \"Unable to load xtables library - %s\", dlerror());\n\t\treturn false;\n\t}\n\n\tif (!(xtables_insmod_addr = dlsym(libxtables_handle, \"xtables_insmod\"))) {\n\t\tlog_message(LOG_INFO, \"Failed to dynamic link xtables_insmod - %s\", dlerror());\n\t\tdlclose(libxtables_handle);\n\t\tlibxtables_handle = NULL;\n\n\t\treturn false;\n\t}\n\n\treturn true;\n}\n\nvoid xtables_unload(void)\n{\n\tif (!libxtables_handle)\n\t\treturn;\n\n\tdlclose(libxtables_handle);\n\tlibxtables_handle = NULL;\n}\n#endif\n\nbool\nload_xtables_module(const char *module,\n#ifndef _LIBXTABLES_DYNAMIC_\n\t\t\t\t\t__attribute__((unused))\n#endif\n\t\t\t\t\t\t\t\tconst char *function)\n{\n\tstruct sigaction act, old_act;\n\tbool res = true;\n\n#ifdef _LIBXTABLES_DYNAMIC_\n\tif (!libxtables_handle && !xtables_load()) {\n\t\tlog_message(LOG_INFO, \"Module %s cannot be loaded; not using %s\", module, function);\n\t\treturn false;\n\t}\n#endif\n\n\t/* Enable SIGCHLD since xtables_insmod forks/execs modprobe */\n\tact.sa_handler = SIG_DFL;\n\tsigemptyset(&act.sa_mask);\n\tact.sa_flags = 0;\n\n\tsigaction(SIGCHLD, &act, &old_act);\n\n\tif (xtables_insmod(module, NULL, true))\n\t\tres = false;\n\n\tsigaction(SIGCHLD, &old_act, NULL);\n\n\treturn res;\n}\n#endif\n\n#ifdef _HAVE_LIBIPSET_\n#ifndef IP_SET_OP_VERSION\t/* Exposed to userspace from Linux 3.4 */\n\t\t\t\t/* Copied from <linux/netfilter/ipset/ip_set.h> */\n#define SO_IP_SET\t83\nunion ip_set_name_index {\n char name[IPSET_MAXNAMELEN];\n ip_set_id_t index;\n};\n\n#define IP_SET_OP_GET_BYNAME 0x00000006 /* Get set index by name */\nstruct ip_set_req_get_set {\n unsigned op;\n unsigned version;\n union ip_set_name_index set;\n};\n\n#define IP_SET_OP_GET_BYINDEX 0x00000007 /* Get set name by index */\n/* Uses ip_set_req_get_set */\n\n#define IP_SET_OP_VERSION 0x00000100 /* Ask kernel version */\nstruct ip_set_req_version {\n unsigned op;\n unsigned version;\n};\n#endif\n\nstatic int\nget_version(unsigned int* version)\n{\n\tint sockfd = socket(AF_INET, SOCK_RAW | SOCK_CLOEXEC, IPPROTO_RAW);\n\tstruct ip_set_req_version req_version;\n\tsocklen_t size = sizeof(req_version);\n\tint res;\n\n\tif (sockfd < 0) {\n\t\tlog_message(LOG_INFO, \"Can't open socket to ipset.\");\n\t\treturn -1;\n\t}\n\n#if !HAVE_DECL_SOCK_CLOEXEC\n\tif (fcntl(sockfd, F_SETFD, FD_CLOEXEC) == -1) {\n\t\tlog_message(LOG_INFO, \"Could not set close on exec: %s\",\n\t\t\t      strerror(errno));\n\t}\n#endif\n\n\treq_version.op = IP_SET_OP_VERSION;\n\tres = getsockopt(sockfd, SOL_IP, SO_IP_SET, &req_version, &size);\n\tif (res != 0)\n\t\tlog_message(LOG_INFO, \"Kernel module xt_set is not loaded in.\");\n\n\t*version = req_version.version;\n\n\treturn sockfd;\n}\n\nstatic void\nget_set_byname_only(const char *setname, struct xt_set_info *info,\n\t\t    int sockfd, unsigned int version, bool ignore_errors)\n{\n\tstruct ip_set_req_get_set req = { .version = version };\n\tsocklen_t size = sizeof(struct ip_set_req_get_set);\n\tint res;\n\n\treq.op = IP_SET_OP_GET_BYNAME;\n\tstrncpy(req.set.name, setname, IPSET_MAXNAMELEN);\n\treq.set.name[IPSET_MAXNAMELEN - 1] = '\\0';\n\tres = getsockopt(sockfd, SOL_IP, SO_IP_SET, &req, &size);\n\n\tif (res != 0) {\n\t\tif (!ignore_errors)\n\t\t\tlog_message(LOG_INFO, \"Problem when communicating with ipset, errno=%d.\",\n\t\t\t\terrno);\n\t}\n\telse if (size != sizeof(struct ip_set_req_get_set)) {\n\t\tif (!ignore_errors)\n\t\t\tlog_message(LOG_INFO, \"Incorrect return size from kernel during ipset lookup, \"\n\t\t\t\t\"(want %zu, got %zu)\",\n\t\t\t\tsizeof(struct ip_set_req_get_set), (size_t)size);\n\t}\n\telse if (req.set.index == IPSET_INVALID_ID) {\n\t\tif (!ignore_errors)\n\t\t\tlog_message(LOG_INFO, \"Set %s doesn't exist.\", setname);\n\t}\n\telse\n\t\tinfo->index = req.set.index;\n}\n\nstatic void\nget_set_byname(const char *setname, struct xt_set_info *info, unsigned family, bool ignore_errors)\n{\n#if defined IP_SET_OP_GET_FNAME\n\tstruct ip_set_req_get_set_family req;\n\tsocklen_t size = sizeof(struct ip_set_req_get_set_family);\n\tint res;\n#else\n\tif (family) {};\t\t/* Avoid compiler warning */\n#endif\n\tint sockfd;\n\tunsigned int version;\n\n\tinfo->index = IPSET_INVALID_ID;\n\n\tif ((sockfd = get_version(&version)) == -1) {\n\t\tinfo->index = IPSET_INVALID_ID;\n\t\treturn;\n\t}\n\n#if defined IP_SET_OP_GET_FNAME\t\t/* Since Linux 3.13 */\n\treq.version = version;\n\treq.op = IP_SET_OP_GET_FNAME;\n\tstrncpy(req.set.name, setname, IPSET_MAXNAMELEN);\n\treq.set.name[IPSET_MAXNAMELEN - 1] = '\\0';\n\tres = getsockopt(sockfd, SOL_IP, SO_IP_SET, &req, &size);\n\n\tif (res != 0 && errno == EBADMSG)\n#endif\n\t{\n\t\t/* Backward compatibility */\n\t\tget_set_byname_only(setname, info, sockfd, version, ignore_errors);\n\n\t\tclose(sockfd);\n\t\treturn;\n\t}\n\n#if defined IP_SET_OP_GET_FNAME\n\tclose(sockfd);\n\tif (res != 0) {\n\t\tif (!ignore_errors)\n\t\t\tlog_message(LOG_INFO, \"Problem when communicating with ipset, errno=%d.\",\n\t\t\t\terrno);\n\t}\n\telse if (size != sizeof(struct ip_set_req_get_set_family)) {\n\t\tif (!ignore_errors)\n\t\t\tlog_message(LOG_INFO, \"Incorrect return size from kernel during ipset lookup, \"\n\t\t\t\t\"(want %zu, got %zu)\",\n\t\t\t\tsizeof(struct ip_set_req_get_set_family),\n\t\t\t\t(size_t)size);\n\t}\n\telse if (req.set.index == IPSET_INVALID_ID) {\n\t\tif (!ignore_errors)\n\t\t\tlog_message(LOG_INFO, \"Set %s doesn't exist.\", setname);\n\t}\n\telse if (!(req.family == family ||\n\t      req.family == NFPROTO_UNSPEC)) {\n\t\tif (!ignore_errors)\n\t\t\tlog_message(LOG_INFO, \"The protocol family of set %s is %s, \"\n\t\t\t\t      \"which is not applicable.\",\n\t\t\t\t      setname,\n\t\t\t\t      req.family == NFPROTO_IPV4 ? \"IPv4\" : \"IPv6\");\n\t}\n\telse\n\t\tinfo->index = req.set.index;\n#endif\n}\n\nint ip4tables_add_rules(struct iptc_handle* handle, const char* chain_name, unsigned int rulenum, uint8_t dim, uint8_t src_dst, const char* target_name, const char* set_name, uint16_t protocol, uint8_t param, int cmd, bool ignore_errors)\n{\n\tsize_t size;\n\tstruct ipt_entry *fw;\n\tstruct xt_entry_target *target;\n\tstruct xt_entry_match *match;\n#ifdef HAVE_XT_SET_INFO_MATCH_V4\n\tstruct xt_set_info_match_v4 *setinfo;\n#elif defined HAVE_XT_SET_INFO_MATCH_V3\n\tstruct xt_set_info_match_v3 *setinfo;\n#elif defined HAVE_XT_SET_INFO_MATCH_V1\n\tstruct xt_set_info_match_v1 *setinfo;\n#else\n\tstruct xt_set_info_match *setinfo;\n#endif\n\tipt_chainlabel chain;\n\tint res;\n\tint sav_errno;\n\n\t/* Add an entry */\n\n\tmemset(chain, 0, sizeof(chain));\n\n\tsize = XT_ALIGN(sizeof (struct ipt_entry)) +\n\t\t\tXT_ALIGN(sizeof(struct xt_entry_match)) +\n\t\t\tXT_ALIGN(sizeof(struct xt_entry_target) + 1) +\n\t\t\tXT_ALIGN(sizeof(*setinfo));\n\n\tif (protocol == IPPROTO_ICMP)\n\t\tsize += XT_ALIGN(sizeof(struct xt_entry_match)) + XT_ALIGN(sizeof(struct ipt_icmp));\n\n\tfw = (struct ipt_entry*)MALLOC(size);\n\n\tfw->target_offset = XT_ALIGN(sizeof(struct ipt_entry));\n\n\t// set\n\tmatch = (struct xt_entry_match*)((char*)fw + fw->target_offset);\n\tmatch->u.match_size = XT_ALIGN(sizeof(struct xt_entry_match)) + XT_ALIGN(sizeof(*setinfo));\n#ifdef HAVE_XT_SET_INFO_MATCH_V4\n\tmatch->u.user.revision = 4;\n#elif defined HAVE_XT_SET_INFO_MATCH_V3\n\tmatch->u.user.revision = 3;\n#elif defined HAVE_XT_SET_INFO_MATCH_V1\n\tmatch->u.user.revision = 1;\n#else\n\tmatch->u.user.revision = 0;\n#endif\n\tfw->target_offset = (uint16_t)(fw->target_offset + match->u.match_size);\n\tstrcpy(match->u.user.name, \"set\");\n\n#ifdef HAVE_XT_SET_INFO_MATCH_V4\n\tsetinfo = (struct xt_set_info_match_v4 *)match->data;\n#elif defined HAVE_XT_SET_INFO_MATCH_V3\n\tsetinfo = (struct xt_set_info_match_v3 *)match->data;\n#elif defined HAVE_XT_SET_INFO_MATCH_V1\n\tsetinfo = (struct xt_set_info_match_v1 *)match->data;\n#else\n\tsetinfo = (struct xt_set_info_match *)match->data;\n#endif\n\tmemset(setinfo, 0, sizeof (*setinfo));\n\n\tget_set_byname(set_name, &setinfo->match_set, NFPROTO_IPV4, ignore_errors);\n\tif (setinfo->match_set.index == IPSET_INVALID_ID) {\n\t\tFREE(fw);\n\t\treturn -1;\n\t}\n\n\tsetinfo->match_set.dim = dim;\n\tsetinfo->match_set.flags = src_dst;\n\n\tif (protocol != IPPROTO_NONE) {\n\t\tfw->ip.proto = protocol;\n\n//\t\tfw->ip.flags |= IP6T_F_PROTO ;\t\t// IPv6 only\n\n\t\tif (protocol == IPPROTO_ICMP)\n\t\t{\n\t\t\tmatch = (struct xt_entry_match*)((char*)fw + fw->target_offset);\n\t\t\tmatch->u.match_size = XT_ALIGN(sizeof(struct xt_entry_match)) + XT_ALIGN(sizeof(struct ipt_icmp));\n\t\t\tmatch->u.user.revision = 0;\n\t\t\tfw->target_offset = (uint16_t)(fw->target_offset + match->u.match_size);\n\t\t\tstrcpy(match->u.user.name, \"icmp\");\n\n\t\t\tstruct ipt_icmp *icmpinfo = (struct ipt_icmp *)match->data;\n\t\t\ticmpinfo->type = param;\t\t// type to match\n\t\t\ticmpinfo->code[0] = 0;\t\t// code lower\n\t\t\ticmpinfo->code[1] = 0xff;\t// code upper\n\t\t\ticmpinfo->invflags = 0;\t\t// don't invert\n\t\t}\n\t}\n\n// target is XTC_LABEL_DROP/XTC_LABEL_ACCEPT\n\tfw->next_offset = (uint16_t)size;\n\ttarget = ipt_get_target(fw);\n\ttarget->u.user.target_size = XT_ALIGN(sizeof(struct xt_entry_target) + 1);\n\tstrcpy(target->u.user.name, target_name);\n//\tfw->ip.flags |= IPT_F_GOTO;\n\tstrcpy(chain, chain_name);\n\n\t// Use iptc_append_entry to add to the chain\n\tif (cmd == IPADDRESS_DEL) {\n\t\tunsigned char matchmask[fw->next_offset];\n\t\tmemset(matchmask, 0xff, fw->next_offset);\n\t\tres = iptc_delete_entry(chain, fw, matchmask, handle);\n\t}\n\telse if (rulenum == APPEND_RULE)\n\t\tres = iptc_append_entry(chain, fw, handle) ;\n\telse\n\t\tres = iptc_insert_entry(chain, fw, rulenum, handle) ;\n\n\tsav_errno = errno;\n\n\tFREE(fw);\n\n\tif (res!= 1)\n\t{\n\t\tif (!ignore_errors)\n\t\t\tlog_message(LOG_INFO, \"iptc_insert_entry for chain %s returned %d: %s\", chain, res, iptc_strerror(sav_errno)) ;\n\n\t\treturn sav_errno;\n\t}\n\n\treturn 0;\n}\n\nint ip6tables_add_rules(struct ip6tc_handle* handle, const char* chain_name, unsigned int rulenum, uint8_t dim, uint8_t src_dst, const char* target_name, const char* set_name, uint16_t protocol, uint8_t param, int cmd, bool ignore_errors)\n{\n\tsize_t size;\n\tstruct ip6t_entry *fw;\n\tstruct xt_entry_target *target;\n\tstruct xt_entry_match *match;\n#ifdef HAVE_XT_SET_INFO_MATCH_V4\n\tstruct xt_set_info_match_v4 *setinfo;\n#elif defined HAVE_XT_SET_INFO_MATCH_V3\n\tstruct xt_set_info_match_v3 *setinfo;\n#elif defined HAVE_XT_SET_INFO_MATCH_V1\n\tstruct xt_set_info_match_v1 *setinfo;\n#else\n\tstruct xt_set_info_match *setinfo;\n#endif\n\tip6t_chainlabel chain;\n\tint res;\n\tint sav_errno;\n\n\t/* Add an entry */\n\n\tmemset(chain, 0, sizeof(chain));\n\n\tsize = XT_ALIGN(sizeof (struct ip6t_entry)) +\n\t\t\tXT_ALIGN(sizeof(struct xt_entry_match)) +\n\t\t\tXT_ALIGN(sizeof(struct xt_entry_target) + 1) +\n\t\t\tXT_ALIGN(sizeof(*setinfo));\n\n\tif (protocol == IPPROTO_ICMPV6)\n\t\tsize += XT_ALIGN(sizeof(struct xt_entry_match)) + XT_ALIGN(sizeof(struct ip6t_icmp));\n\n\tfw = (struct ip6t_entry*)MALLOC(size);\n\n\tfw->target_offset = XT_ALIGN(sizeof(struct ip6t_entry));\n\n\t// set\n\tmatch = (struct xt_entry_match*)((char*)fw + fw->target_offset);\n\tmatch->u.match_size = XT_ALIGN(sizeof(struct xt_entry_match)) + XT_ALIGN(sizeof(*setinfo));\n#ifdef HAVE_XT_SET_INFO_MATCH_V4\n\tmatch->u.user.revision = 4;\n#elif defined HAVE_XT_SET_INFO_MATCH_V3\n\tmatch->u.user.revision = 3;\n#elif defined HAVE_XT_SET_INFO_MATCH_V1\n\tmatch->u.user.revision = 1;\n#else\n\tmatch->u.user.revision = 0;\n#endif\n\tfw->target_offset = (uint16_t)(fw->target_offset + match->u.match_size);\n\tstrcpy(match->u.user.name, \"set\");\n\n#ifdef HAVE_XT_SET_INFO_MATCH_V4\n\tsetinfo = (struct xt_set_info_match_v4 *)match->data;\n#elif defined HAVE_XT_SET_INFO_MATCH_V3\n\tsetinfo = (struct xt_set_info_match_v3 *)match->data;\n#elif defined HAVE_XT_SET_INFO_MATCH_V1\n\tsetinfo = (struct xt_set_info_match_v1 *)match->data;\n#else\n\tsetinfo = (struct xt_set_info_match *)match->data;\n#endif\n\tmemset(setinfo, 0, sizeof(*setinfo));\n\n\tget_set_byname (set_name, &setinfo->match_set, NFPROTO_IPV6, ignore_errors);\n\tif (setinfo->match_set.index == IPSET_INVALID_ID) {\n\t\tFREE(fw);\n\t\treturn -1;\n\t}\n\n\tsetinfo->match_set.dim = dim;\n\tsetinfo->match_set.flags = src_dst;\n\n\tif (protocol != IPPROTO_NONE) {\n\t\tfw->ipv6.proto = protocol;\n\n\t\tfw->ipv6.flags |= IP6T_F_PROTO ;\t\t// IPv6 only\n\n\t\tif (protocol == IPPROTO_ICMPV6)\n\t\t{\n\t\t\tmatch = (struct xt_entry_match*)((char*)fw + fw->target_offset);\n\t\t\tmatch->u.match_size = XT_ALIGN(sizeof(struct xt_entry_match)) + XT_ALIGN(sizeof(struct ip6t_icmp));\n\t\t\tmatch->u.user.revision = 0;\n\t\t\tfw->target_offset = (uint16_t)(fw->target_offset + match->u.match_size);\n\t\t\tstrcpy(match->u.user.name, \"icmp6\");\n\n\t\t\tstruct ip6t_icmp *icmpinfo = (struct ip6t_icmp *)match->data;\n\t\t\ticmpinfo->type = param;\t\t// type to match\n\t\t\ticmpinfo->code[0] = 0;\t\t// code lower\n\t\t\ticmpinfo->code[1] = 0xff;\t// code upper\n\t\t\ticmpinfo->invflags = 0;\t\t// don't invert\n\t\t}\n\t}\n\n// target is XTC_LABEL_DROP/XTC_LABEL_ACCEPT\n\tfw->next_offset = (uint16_t)size;\n\ttarget = ip6t_get_target(fw);\n\ttarget->u.user.target_size = XT_ALIGN(sizeof(struct xt_entry_target) + 1);\n\tstrcpy(target->u.user.name, target_name);\n//\tfw->ip.flags |= IP6T_F_GOTO;\n\tstrcpy(chain, chain_name);\n\n\t// Use iptc_append_entry to add to the chain\n\tif (cmd == IPADDRESS_DEL) {\n\t\tunsigned char matchmask[fw->next_offset];\n\t\tmemset(matchmask, 0xff, fw->next_offset);\n\t\tres = ip6tc_delete_entry(chain, fw, matchmask, handle);\n\t}\n\telse if (rulenum == APPEND_RULE)\n\t\tres = ip6tc_append_entry(chain, fw, handle) ;\n\telse\n\t\tres = ip6tc_insert_entry(chain, fw, rulenum, handle) ;\n\n\tsav_errno = errno;\n\n\tFREE(fw);\n\n\tif (res!= 1)\n\t{\n\t\tif (!ignore_errors)\n\t\t\tlog_message(LOG_INFO, \"ip6tc_insert_entry for chain %s returned %d: %s\", chain, res, ip6tc_strerror(sav_errno)) ;\n\n\t\treturn sav_errno;\n\t}\n\n\treturn 0;\n}\n#endif\n\n#ifdef _LIBIPTC_DYNAMIC_\nbool iptables_lib_init(void)\n{\n\tif (!libip4tc_handle && block_ipv4) {\n\t\t/* Attempt to open the ip4tc library */\n\t\tif (!(libip4tc_handle = dlopen(\"libip4tc.so\", RTLD_NOW)) &&\n\t\t    !(libip4tc_handle = dlopen(IP4TC_LIB_NAME, RTLD_NOW))) {\n\t\t\tlog_message(LOG_INFO, \"Unable to load ip4tc library - %s\", dlerror());\n\t\t\tusing_libip4tc = false;\n\t\t}\n\t\telse if (!(iptc_init_addr = dlsym(libip4tc_handle, \"iptc_init\")) ||\n\t\t\t !(iptc_free_addr = dlsym(libip4tc_handle, \"iptc_free\")) ||\n\t\t\t !(iptc_is_chain_addr = dlsym(libip4tc_handle,\"iptc_is_chain\")) ||\n\t\t\t !(iptc_insert_entry_addr = dlsym(libip4tc_handle,\"iptc_insert_entry\")) ||\n\t\t\t !(iptc_append_entry_addr = dlsym(libip4tc_handle,\"iptc_append_entry\")) ||\n\t\t\t !(iptc_delete_entry_addr = dlsym(libip4tc_handle,\"iptc_delete_entry\")) ||\n\t\t\t !(iptc_commit_addr = dlsym(libip4tc_handle,\"iptc_commit\")) ||\n\t\t\t !(iptc_strerror_addr = dlsym(libip4tc_handle,\"iptc_strerror\"))) {\n\t\t\tlog_message(LOG_INFO, \"Failed to dynamic link an iptc function - %s\", dlerror());\n\t\t\tusing_libip4tc = false;\n\t\t\tdlclose(libip4tc_handle);\n\t\t\tlibip4tc_handle = NULL;\n\t\t}\n\t}\n\n\tif (!libip6tc_handle && block_ipv6) {\n\t\t/* Attempt to open the ip6tc library */\n\t\tif (!(libip6tc_handle = dlopen(\"libip6tc.so\", RTLD_NOW)) &&\n\t\t    !(libip6tc_handle = dlopen(IP6TC_LIB_NAME, RTLD_NOW))) {\n\t\t\tlog_message(LOG_INFO, \"Unable to load ip6tc library - %s\", dlerror());\n\t\t\tusing_libip6tc = false;\n\t\t}\n\t\telse if (!(ip6tc_init_addr = dlsym(libip6tc_handle, \"ip6tc_init\")) ||\n\t\t\t !(ip6tc_free_addr = dlsym(libip6tc_handle, \"ip6tc_free\")) ||\n\t\t\t !(ip6tc_is_chain_addr = dlsym(libip6tc_handle,\"ip6tc_is_chain\")) ||\n\t\t\t !(ip6tc_insert_entry_addr = dlsym(libip6tc_handle,\"ip6tc_insert_entry\")) ||\n\t\t\t !(ip6tc_append_entry_addr = dlsym(libip6tc_handle,\"ip6tc_append_entry\")) ||\n\t\t\t !(ip6tc_delete_entry_addr = dlsym(libip6tc_handle,\"ip6tc_delete_entry\")) ||\n\t\t\t !(ip6tc_commit_addr = dlsym(libip6tc_handle,\"ip6tc_commit\")) ||\n\t\t\t !(ip6tc_strerror_addr = dlsym(libip6tc_handle,\"ip6tc_strerror\"))) {\n\t\t\tlog_message(LOG_INFO, \"Failed to dynamic link an ip6tc function - %s\", dlerror());\n\t\t\tusing_libip6tc = false;\n\t\t\tdlclose(libip6tc_handle);\n\t\t\tlibip6tc_handle = NULL;\n\t\t}\n\t}\n\n\treturn libip4tc_handle || libip6tc_handle;\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-keepalived-2.0.12-hqbu65pccond3zcjeitk4jaih4fahmth/spack-src/keepalived/core/libnl_link.c": "/*\n * libnl_link:\tHandle dynamic linking to netlink libraries\n *\n * Authors:\tP. Quentin Armitage <Quentin@Armitage.org.uk>\n *\n *\t\tThis program is free software; you can redistribute it and/or\n *\t\tmodify it under the terms of the GNU General Public License\n *\t\tas published by the Free Software Foundation; either version\n *\t\t2 of the License, or (at your option) any later version.\n *\n *  Copyright (C) 2017-2017 Alexandre Cassen, <acassen@gmail.com>\n */\n\n#include \"config.h\"\n\n#ifdef _LIBNL_DYNAMIC_\n\n#include <stdbool.h>\n\n#include <dlfcn.h>\n#include <netlink/netlink.h>\n#include <netlink/socket.h>\n\n#ifdef LIBIPVS_USE_NL\n#include <netlink/genl/genl.h>\n#include <netlink/genl/ctrl.h>\n#endif\n\n#include \"libnl_link.h\"\n#include \"logger.h\"\n\n\n/* The addresses of the functions we want */\nstruct nl_sock * (*nl_socket_alloc_addr)(void);\nvoid (*nl_socket_free_addr)(struct nl_sock *);\n#ifdef LIBIPVS_USE_NL\nint (*genl_connect_addr)(struct nl_sock *);\nint (*genl_ctrl_resolve_addr)(struct nl_sock *, const char *);\nint (*genlmsg_parse_addr)(struct nlmsghdr *, int, struct nlattr **, int, struct nla_policy *);\nvoid * (*genlmsg_put_addr)(struct nl_msg *, uint32_t, uint32_t, int, int, int, uint8_t, uint8_t);\nint (*nla_nest_end_addr)(struct nl_msg *, struct nlattr *);\nstruct nlattr * (*nla_nest_start_addr)(struct nl_msg *, int);\nint (*nla_put_daddr)(struct nl_msg *, int, int, const void *);\nstruct nl_msg * (*nlmsg_alloc_addr)(void);\nvoid (*nlmsg_free_addr)(struct nl_msg *);\nstruct nlmsghdr * (*nlmsg_hdr_addr)(struct nl_msg *);\nint (*nl_recvmsgs_default_addr)(struct nl_sock *);\nint (*nl_send_auto_complete_addr)(struct nl_sock *,  struct nl_msg *);\nint (*nl_socket_modify_cb_addr)(struct nl_sock *, enum nl_cb_type, enum nl_cb_kind, nl_recvmsg_msg_cb_t, void *);\n#ifdef _HAVE_LIBNL3_\nvoid * (*nla_data_addr)(const struct nlattr *);\nint32_t (*nla_get_s32_addr)(const struct nlattr *);\nchar * (*nla_get_string_addr)(const struct nlattr *);\nuint16_t (*nla_get_u16_addr)(const struct nlattr *);\nuint32_t (*nla_get_u32_addr)(const struct nlattr *);\nuint64_t (*nla_get_u64_addr)(const struct nlattr *);\nint (*nla_memcpy_addr)(void *, const struct nlattr *, int);\nint (*nla_parse_nested_addr)(struct nlattr **, int, struct nlattr *, struct nla_policy *);\n#endif\n#endif\n\n\nstatic void* libnl_handle;\n#ifdef LIBIPVS_USE_NL\nstatic void* libnl_genl_handle;\n#endif\n\nbool\nlibnl_init(void)\n{\n\tif (libnl_handle)\n\t\treturn true;\n\n\t/* Attempt to open the necessary libraries */\n#ifdef _HAVE_LIBNL1_\n#ifdef _WITH_LVS_\n\tif (!(libnl_handle = dlopen(\"libnl.so\", RTLD_NOW)) &&\n\t    !(libnl_handle = dlopen(NL_LIB_NAME, RTLD_NOW))) {\n\t\tlog_message(LOG_INFO, \"Unable to load nl library - %s\", dlerror());\n\t\treturn false;\n\t}\n\tlibnl_genl_handle = libnl_handle;\n#endif\n#else\n\tif (!(libnl_handle = dlopen(\"libnl-3.so\", RTLD_NOW)) &&\n\t    !(libnl_handle = dlopen(NL3_LIB_NAME, RTLD_NOW))) {\n\t\tlog_message(LOG_INFO, \"Unable to load nl-3 library - %s\", dlerror());\n\t\treturn false;\n\t}\n#ifdef _WITH_LVS_\n\tif (!(libnl_genl_handle = dlopen(\"libnl-genl-3.so\", RTLD_NOW)) &&\n\t    !(libnl_genl_handle = dlopen(NL3_GENL_LIB_NAME, RTLD_NOW))) {\n\t\tlog_message(LOG_INFO, \"Unable to load nl-genl-3 library - %s\", dlerror());\n\t\treturn false;\n\t}\n#endif\n#endif\n\n\tif (\n#ifdef _HAVE_LIBNL1_\n\t    !(nl_socket_alloc_addr = dlsym(libnl_handle, \"nl_handle_alloc\")) ||\n\t    !(nl_socket_free_addr = dlsym(libnl_handle, \"nl_handle_destroy\")) ||\n#else\n\t    !(nl_socket_alloc_addr = dlsym(libnl_handle, \"nl_socket_alloc\")) ||\n\t    !(nl_socket_free_addr = dlsym(libnl_handle, \"nl_socket_free\")) ||\n#endif\n#ifdef _WITH_LVS_\n\t    !(genl_connect_addr = dlsym(libnl_genl_handle, \"genl_connect\")) ||\n\t    !(genl_ctrl_resolve_addr = dlsym(libnl_genl_handle, \"genl_ctrl_resolve\")) ||\n\t    !(genlmsg_parse_addr = dlsym(libnl_genl_handle, \"genlmsg_parse\")) ||\n\t    !(genlmsg_put_addr = dlsym(libnl_genl_handle, \"genlmsg_put\")) ||\n\t    !(nla_nest_end_addr = dlsym(libnl_handle, \"nla_nest_end\")) ||\n\t    !(nla_nest_start_addr = dlsym(libnl_handle, \"nla_nest_start\")) ||\n\t    !(nla_put_daddr = dlsym(libnl_handle, \"nla_put\")) ||\n\t    !(nlmsg_alloc_addr = dlsym(libnl_handle, \"nlmsg_alloc\")) ||\n\t    !(nlmsg_free_addr = dlsym(libnl_handle, \"nlmsg_free\")) ||\n\t    !(nlmsg_hdr_addr = dlsym(libnl_handle, \"nlmsg_hdr\")) ||\n\t    !(nl_recvmsgs_default_addr = dlsym(libnl_handle, \"nl_recvmsgs_default\")) ||\n\t    !(nl_send_auto_complete_addr = dlsym(libnl_handle, \"nl_send_auto_complete\")) ||\n\t    !(nl_socket_modify_cb_addr = dlsym(libnl_handle, \"nl_socket_modify_cb\")) ||\n#ifdef _HAVE_LIBNL3_\n\t    !(nla_data_addr = dlsym(libnl_handle, \"nla_data\")) ||\n\t    !(nla_get_s32_addr = dlsym(libnl_handle, \"nla_get_s32\")) ||\n\t    !(nla_get_string_addr = dlsym(libnl_handle, \"nla_get_string\")) ||\n\t    !(nla_get_u16_addr = dlsym(libnl_handle, \"nla_get_u16\")) ||\n\t    !(nla_get_u32_addr = dlsym(libnl_handle, \"nla_get_u32\")) ||\n\t    !(nla_get_u64_addr = dlsym(libnl_handle, \"nla_get_u64\")) ||\n\t    !(nla_memcpy_addr = dlsym(libnl_handle, \"nla_memcpy\")) ||\n\t    !(nla_parse_nested_addr = dlsym(libnl_handle, \"nla_parse_nested\")) ||\n#endif\n#endif\n\t    false)\n\t\tlog_message(LOG_INFO, \"Failed to dynamic link a libnli/libnl-3 function\");\n\n\treturn true;\n}\n#endif\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-keepalived-2.0.12-hqbu65pccond3zcjeitk4jaih4fahmth/spack-src/doc/source/images/software_design.png"
    ],
    "total_files": 286
}