{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.64.1-zay2ciepa5k35t7jfrw2hn5i52snsdx2/spack-src/NEWS.pre-1-3": "Overview of Changes in GLib 1.2.1:\n\n* g_realloc() fix for SunOS (please report further problems).\n* Continued the never ending fix vendetta regarding getpwuid(),\n  this time AIX has been the culprit.\n* Upgrade to libtool 1.2f\n* Miscellaneous other buglets fixed.\n\nWhat's new in GLib 1.2.0 (since GLib 1.0.x):\n\n* GLib is distributed seperatedly from Gtk+\n* Win32 Portability\n* Threading support\n* GModule mechanism (implemented in an extra library) which wraps dynamic\n  object code loading facilities in a portable manner\n* GIOChannel structure to encapsulate the IPC mechanism\n* GQuarks and datasets\n* GRelations for n-way mapping of certain data\n* An n-way tree implementation\n* GDate functionality for calendar date manipulations\n* GAllocator type and associated functions\n* Added generic callback maintenance functions (ghook)\n* Generic functions for TAB completions\n* Endian defines (G_*_ENDIAN)\n* g_log() mechanism for logging of messages at different log levels\n* Generic main-loop mechanism\n* New glib-config helper script\n* Many more API extensions\n\nOverview of Changes in GLib 1.1.16:\n\n* Allocate smaller pools of memory for glists, gslists, gnodes\n* Bug Fixes\n\nOverview of Changes in GLib 1.1.15:\n\n* HPUX 11 thread system detection should now work\n* Release the main loop lock around calls to prepare() and\n  check() so it is not held over user code\n* A few Win32 fixups\n\nOverview of Changes in GLib 1.1.14:\n\n* Check for dlsym() in system libraries and -dl\n* FreeBSD portability fixes\n* Random bug fixes and autoconf/automake changes\n\nOverview of Changes in GLib 1.1.13:\n\n* Removed alloca() based function and macro variants again.\n* Improved thread related configure tests.\n* GSource destruction fixups.\n* Fixed up idle function removal based on user_data pointer.\n* Advanced Win32 portability.\n* Enforced GSource's check(), prepare() and dispatch() constrains,\n  loop recursions may only happen from dispatch(), and check() as well\n  as prepare() are called while the main_loop lock is being held.\n* GLib development now requires GNU autoconf 2.13, GNU automake 1.4\n  and GNU libtool 1.2d.\n* Lots of random portability and bug fixes.\n\nOverview of Changes in GLib 1.1.12:\n\n* Added alloca functions/macros: g_strdup_a, g_strconcat3_a, g_alloca,\n  g_new_a, g_new0_a\n* New tests structure.  Type 'make check' on your system to run them.\n* Avoid unnecessary extra hook referencing in g_hook_list_marshal\n\nOverview of Changes in GLib 1.1.11:\n\n* provide defaults for POLL sysdefs\n* g_main_is_running: new function to check whether a main loop has been quitted\n* a few other enhancement/fixes\n\nOverview of Changes in GLib 1.1.9:\n\n* Check for pthread_attr_init in all cases, Digital Unix 4 requires this\n* For G_LOCK_DECLARE_*, if !G_THREADS_ENABLED, eat trailing semicolon better\n* Changed g_main_poll_(add|remove) to g_main_(add|remove)_poll\n\nOverview of Changes in GLib 1.1.8:\n\n* Added threading support\n  - The ability to specify a set of functions to be used for\n    locking at runtime.\n  - Default implementations of locking functions for pthreads,\n    Solaris threads, and (experimentally) NSPR.\n  - All static variables should now properly locked.\n  - Enhancements to the generic main-loop mechanism to be thread-safe.\n    (It is used for the main-loop in GTK+ as of GTK+-1.1.8)\n* Portability fixes.\n\nOverview of Changes in GLib 1.1.7:\n\n* Removed multiple define from glibconfig.h\n\nOverview of Changes in GLib 1.1.6:\n\n* New GDate functionality for calendar date manipulations (g_date_*)\n* New GAllocator type and associated functions\n* New functions g_slist_copy and g_list_copy to duplicate a list with all\n  its data pointers.\n* New function g_array_insert_vals and new macro g_array_insert_val to\n  insert elements at an arbitrary index\n* GAllocators used for glist, gslist, gnode node allocations\n* Incremental freezing in ghash\n* New function g_hook_list_marshal_check to eventually destroy hooks after\n  they got marshalled\n* Revised GIOChannel to provide generic virtual-function based interface\n* Added generic main-loop abstraction\n* Removed GListAllocator type and its g_*_allocator_*() function variants\n* Bug fixes\n\nOverview of Changes in GLib 1.1.5:\n\n* Win32 portability\n* GIOChannel structure to encapsulate the IPC mechanism \n* Reimplemented endian stuff, using inline asm for x86\n* New functions:\n  - g_strescape: escapes backslashes\n  - g_path_is_absolute and g_path_skip_root\n  - g_getenv: expands environment variables that contain references \n    to other environment variables\n  - g_scanner_sync_file_offset: rewind the filedescriptor to the current\n    buffer position and blow the file read ahead buffer\n  - g_array_remove_index: remove an entry, preserving the order\n  - g_array_remove_index_fast: remove an entry, order might be distorted\n  - g_ptr_array_remove: remove an entry, preserving the order \n  - g_ptr_array_remove_fast: remove an entry, order might be distorted\n  - g_byte_array_remove_index: wrapper for g_array_remove_index\n  - g_byte_array_remove_index_fast: wrapper for g_array_remove_index_fast\n  - g_strncasecmp: modeled closely after g_strcasecmp\n  - g_list_sort, g_slist_sort: to merge sort GLists and GSLists\n* New macros:\n  - G_DIR_SEPARATOR, G_DIR_SEPARATOR_S: platform-dependant file name\n    syntax elements\n  - G_SEARCHPATH_SEPARATOR, G_SEARCHPATH_SEPARATOR_S: platform-dependant\n    search path syntax conventions\n  - G_STRUCT_OFFSET, G_STRUCT_MEMBER_P, G_STRUCT_MEMBER: for handling\n    structure fields through their offsets\n* Removed G_ENUM, G_FLAGS, G_NV, and G_SV macros\n* Bug fixes\n\nOverview of Changes in GLib 1.1.4:\n\n* Added generic callback maintenance functions (ghook)\n* New endian defines (G_*_ENDIAN)\n* New string join/split/free routines \n* Fixes\n\nOverview of Changes in GLib 1.1.3:\n\n* New GModule mechanism (implemented in an extra library) which wraps dynamic\n  object code loading facilities in a portable manner.\n* glib-config features extra \"glib\" (old behaviour remains) and \"gmodule\"\n  (add libgmodule.so to the --libs output) arguments now. this can also\n  be specified as fourth argument to the AM_PATH_GLIB() macro.\n* Overhaul of the `inline' autoconfiguration stuff, so inlining should be\n  sufficiently supported on all systems that allow inlining now.\n* New g_log() mechanism for logging of messages at different log levels,\n  associated with certain log domains (define -DG_LOG_DOMAIN for your library).\n* New inline functions for bit masks tests.\n* GNode macros (and functions) now return the newly allocated node.\n* New macro G_VA_COPY() to work around va_list copying oddities on some\n  platforms. the non-static g_vsprintf() function vanished in favour of\n  a publically exported g_strdup_vprintf().\n  People that used the former g_vsprintf() would definitely want to read the\n  associated ChangeLog entries (grep for printf).\n* New utility functions:\n  g_strndup(), g_on_error_query(), g_on_error_stack_trace(), g_strdup_printf(),\n  g_strdup_vprintf(), g_printf_string_upper_bound(), g_spaced_primes_closest(),\n  g_strnfill(), g_memdup(). \n* Overhaul of the array implementations, this contains some source incompatible\n  changes. Again, the ChangeLog is much more informative (grep for garray.c).\n* The internals of the g_dataset mechanism are now exported through the\n  new g_datalist_* API (this is also the underlying implementation for the\n  keyed data of GtkObjects).\n* New function g_atexit(), use of the ATEXIT() macro is discouraged.\n* Better configure checks for ansi compliance.\n* Libtool update to version 1.2b.\n* Lotsa bug fixes and cleanups as always ;)\n\nOverview of Changes in GLib 1.1.2:\n\n* Fixed packaging mistake which occured in 1.1.1\n* fix 64-bitness in g_prints in glibtest\n\nWhat is new in GLib 1.1.1:\n\n* An n-way tree implementation is provided now, based on the GNode structure.\n* Bugfix for pointer arrays.\n\nWhat is new in GLib 1.1.0:\n\n* GLib is distributed seperatedly from Gtk+ now and uses a sophisticated\n  shared library versioning scheme to deal with interface and binary\n  incompatibilities.\n* There is a glib-config helper script installed now.\n* Fixups all over the place.\n* gboolean is now a gint, not a gchar anymore.\n* API extensions for GList and GSList.\n* New g_str*() functions for simple string handling.\n* GScanner extensions for scope, warning and error handling.\n* Minor performance improvements for GMemChunks.\n* Implementations of GQuarks and datasets (similar to GtkObjects data\n  mechansim, but works for generic memory locations).\n* More convenience macros for GNU C function arguments.\n* Const correction all over the place, including a new pointer type\n  gconstpointer.\n* Generic functions for TAB completions.\n* GRelations for n-way mapping of certain data.\n",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.64.1-zay2ciepa5k35t7jfrw2hn5i52snsdx2/spack-src/meson.build": "project('glib', 'c', 'cpp',\n  version : '2.64.1',\n  # NOTE: We keep this pinned at 0.49 because that's what Debian 10 ships\n  meson_version : '>= 0.49.2',\n  default_options : [\n    'buildtype=debugoptimized',\n    'warning_level=1',\n    'c_std=gnu99'\n  ]\n)\n\ncc = meson.get_compiler('c')\ncxx = meson.get_compiler('cpp')\n\ncc_can_run = not meson.is_cross_build() or meson.has_exe_wrapper()\n\nif cc.get_id() == 'msvc'\n  # Ignore several spurious warnings for things glib does very commonly\n  # If a warning is completely useless and spammy, use '/wdXXXX' to suppress it\n  # If a warning is harmless but hard to fix, use '/woXXXX' so it's shown once\n  # NOTE: Only add warnings here if you are sure they're spurious\n  add_project_arguments('/wd4035', '/wd4715', '/wd4116',\n    '/wd4046', '/wd4068', '/wo4090', '/FImsvc_recommended_pragmas.h',language : 'c')\n  # Disable SAFESEH with MSVC for plugins and libs that use external deps that\n  # are built with MinGW\n  noseh_link_args = ['/SAFESEH:NO']\n  # Set the input and exec encoding to utf-8, like is the default with GCC\n  add_project_arguments(cc.get_supported_arguments(['/utf-8']), language: 'c')\nelse\n  noseh_link_args = []\n  # -mms-bitfields vs -fnative-struct ?\nendif\n\nhost_system = host_machine.system()\n\nglib_version = meson.project_version()\nglib_api_version = '2.0'\nversion_arr = glib_version.split('.')\nmajor_version = version_arr[0].to_int()\nminor_version = version_arr[1].to_int()\nmicro_version = version_arr[2].to_int()\n\ninterface_age = minor_version.is_odd() ? 0 : micro_version\nbinary_age = 100 * minor_version + micro_version\n\nsoversion = 0\n# Maintain compatibility with previous libtool versioning\n# current = minor * 100 + micro\ncurrent = binary_age - interface_age\nlibrary_version = '@0@.@1@.@2@'.format(soversion, current, interface_age)\ndarwin_versions = [current + 1, '@0@.@1@'.format(current + 1, interface_age)]\n\nconfiginc = include_directories('.')\nglibinc = include_directories('glib')\ngobjectinc = include_directories('gobject')\ngmoduleinc = include_directories('gmodule')\ngioinc = include_directories('gio')\n\nglib_prefix = get_option('prefix')\nglib_bindir = join_paths(glib_prefix, get_option('bindir'))\nglib_libdir = join_paths(glib_prefix, get_option('libdir'))\nglib_libexecdir = join_paths(glib_prefix, get_option('libexecdir'))\nglib_datadir = join_paths(glib_prefix, get_option('datadir'))\nglib_pkgdatadir = join_paths(glib_datadir, 'glib-2.0')\nglib_includedir = join_paths(glib_prefix, get_option('includedir'))\nif get_option('gio_module_dir') != ''\n  glib_giomodulesdir = join_paths(glib_prefix, get_option('gio_module_dir'))\nelse\n  glib_giomodulesdir = join_paths(glib_libdir, 'gio', 'modules')\nendif\n\nglib_pkgconfigreldir = join_paths(glib_libdir, 'pkgconfig')\n\nif get_option('charsetalias_dir') != ''\n  glib_charsetaliasdir = join_paths(glib_prefix, get_option('charsetalias_dir'))\nelse\n  glib_charsetaliasdir = glib_libdir\nendif\n\ninstalled_tests_metadir = join_paths(glib_datadir, 'installed-tests', meson.project_name())\ninstalled_tests_execdir = join_paths(glib_libexecdir, 'installed-tests', meson.project_name())\ninstalled_tests_enabled = get_option('installed_tests')\ninstalled_tests_template = files('template.test.in')\ninstalled_tests_template_tap = files('template-tap.test.in')\n\n# Don\u2019t build the tests unless we can run them (either natively, in an exe wrapper, or by installing them for later use)\nbuild_tests = not meson.is_cross_build() or (meson.is_cross_build() and meson.has_exe_wrapper()) or installed_tests_enabled\n\nadd_project_arguments('-D_GNU_SOURCE', language: 'c')\n\n# Disable strict aliasing;\n# see https://bugzilla.gnome.org/show_bug.cgi?id=791622\nif cc.has_argument('-fno-strict-aliasing')\n  add_project_arguments('-fno-strict-aliasing', language: 'c')\nendif\n\n########################\n# Configuration begins #\n########################\nglib_conf = configuration_data()\nglibconfig_conf = configuration_data()\n\n# accumulated list of defines as we check for them, so we can easily\n# use them later in test programs (autoconf does this automatically)\nglib_conf_prefix = ''\n\nglib_conf.set('GLIB_MAJOR_VERSION', major_version)\nglib_conf.set('GLIB_MINOR_VERSION', minor_version)\nglib_conf.set('GLIB_MICRO_VERSION', micro_version)\nglib_conf.set('GLIB_INTERFACE_AGE', interface_age)\nglib_conf.set('GLIB_BINARY_AGE', binary_age)\nglib_conf.set_quoted('GETTEXT_PACKAGE', 'glib20')\nglib_conf.set_quoted('PACKAGE_BUGREPORT', 'https://gitlab.gnome.org/GNOME/glib/issues/new')\nglib_conf.set_quoted('PACKAGE_NAME', 'glib')\nglib_conf.set_quoted('PACKAGE_STRING', 'glib @0@'.format(meson.project_version()))\nglib_conf.set_quoted('PACKAGE_TARNAME', 'glib')\nglib_conf.set_quoted('PACKAGE_URL', '')\nglib_conf.set_quoted('PACKAGE_VERSION', meson.project_version())\nglib_conf.set('ENABLE_NLS', 1)\n\n# used by the .rc.in files\nglibconfig_conf.set('LT_CURRENT_MINUS_AGE', soversion)\n\nglib_conf.set('_GNU_SOURCE', 1)\n\nif host_system == 'windows'\n  # Poll doesn't work on devices on Windows\n  glib_conf.set('BROKEN_POLL', true)\nendif\n\nif host_system == 'windows' and cc.get_id() != 'msvc' and cc.get_id() != 'clang-cl'\n  # FIXME: Ideally we shouldn't depend on this on Windows and should use\n  # 64 bit capable Windows API that also works with MSVC.\n  # The autotools build did set this for mingw and while meson sets it\n  # for gcc/clang by default, it doesn't do so on Windows.\n  glib_conf.set('_FILE_OFFSET_BITS', 64)\nendif\n\n# Check for GNU visibility attributes\ng_have_gnuc_visibility = cc.compiles('''\n  void\n  __attribute__ ((visibility (\"hidden\")))\n       f_hidden (void)\n  {\n  }\n  void\n  __attribute__ ((visibility (\"internal\")))\n       f_internal (void)\n  {\n  }\n  void\n  __attribute__ ((visibility (\"default\")))\n       f_default (void)\n  {\n  }\n  int main (void)\n  {\n    f_hidden();\n    f_internal();\n    f_default();\n    return 0;\n  }\n  ''',\n  # Not supported by MSVC, but MSVC also won't support visibility,\n  # so it's OK to pass -Werror explicitly. Replace with\n  # override_options : 'werror=true' once that is supported\n  args: ['-Werror'],\n  name : 'GNU C visibility attributes test')\n\nif g_have_gnuc_visibility\n  glibconfig_conf.set('G_HAVE_GNUC_VISIBILITY', '1')\nendif\n\n# Detect and set symbol visibility\nglib_hidden_visibility_args = []\nif get_option('default_library') != 'static'\n  if host_system == 'windows' or host_system == 'cygwin'\n    glib_conf.set('DLL_EXPORT', true)\n    if cc.get_id() == 'msvc' or cc.get_id() == 'clang-cl'\n      glib_conf.set('_GLIB_EXTERN', '__declspec(dllexport) extern')\n    elif cc.has_argument('-fvisibility=hidden')\n      glib_conf.set('_GLIB_EXTERN', '__attribute__((visibility(\"default\"))) __declspec(dllexport) extern')\n      glib_hidden_visibility_args = ['-fvisibility=hidden']\n    endif\n  elif cc.has_argument('-fvisibility=hidden')\n    glib_conf.set('_GLIB_EXTERN', '__attribute__((visibility(\"default\"))) extern')\n    glib_hidden_visibility_args = ['-fvisibility=hidden']\n  endif\nendif\n\nif get_option('default_library') == 'static'\n    glibconfig_conf.set('GLIB_STATIC_COMPILATION', '1')\n    glibconfig_conf.set('GOBJECT_STATIC_COMPILATION', '1')\nendif\n\n# Cygwin glib port maintainers made it clear\n# (via the patches they apply) that they want no\n# part of glib W32 code, therefore we do not define\n# G_PLATFORM_WIN32 for host_system == 'cygwin'.\n# This makes G_PLATFORM_WIN32 a synonym for\n# G_OS_WIN32.\nif host_system == 'windows'\n  glib_os = '''#define G_OS_WIN32\n#define G_PLATFORM_WIN32'''\nelif host_system == 'cygwin'\n  glib_os = '''#define G_OS_UNIX\n#define G_WITH_CYGWIN'''\nelse\n  glib_os = '#define G_OS_UNIX'\nendif\nglibconfig_conf.set('glib_os', glib_os)\n\n# We need to know the build type to determine what .lib files we need on Visual Studio\n# for dependencies that don't normally come with pkg-config files for Visual Studio builds\nbuildtype = get_option('buildtype')\n\nglib_debug_cflags = []\nif buildtype.startswith('debug')\n  glib_debug_cflags += ['-DG_ENABLE_DEBUG']\nelif buildtype == 'release'\n  glib_debug_cflags += ['-DG_DISABLE_CAST_CHECKS']\nendif\n\nadd_project_arguments(glib_debug_cflags, language: 'c')\n\n# check for header files\n\nheaders = [\n  'alloca.h',\n  'crt_externs.h',\n  'dirent.h', # MSC does not come with this by default\n  'float.h',\n  'fstab.h',\n  'grp.h',\n  'inttypes.h',\n  'limits.h',\n  'linux/magic.h',\n  'locale.h',\n  'mach/mach_time.h',\n  'memory.h',\n  'mntent.h',\n  'poll.h',\n  'pwd.h',\n  'sched.h',\n  'spawn.h',\n  'stdint.h',\n  'stdlib.h',\n  'string.h',\n  'strings.h',\n  'sys/auxv.h',\n  'sys/event.h',\n  'sys/filio.h',\n  'sys/inotify.h',\n  'sys/mkdev.h',\n  'sys/mntctl.h',\n  'sys/mnttab.h',\n  'sys/mount.h',\n  'sys/param.h',\n  'sys/resource.h',\n  'sys/select.h',\n  'sys/statfs.h',\n  'sys/stat.h',\n  'sys/statvfs.h',\n  'sys/sysctl.h',\n  'sys/time.h', # MSC does not come with this by default\n  'sys/times.h',\n  'sys/types.h',\n  'sys/uio.h',\n  'sys/vfs.h',\n  'sys/vfstab.h',\n  'sys/vmount.h',\n  'sys/wait.h',\n  'termios.h',\n  'unistd.h',\n  'values.h',\n  'wchar.h',\n  'xlocale.h',\n]\n\nforeach h : headers\n  if cc.has_header(h)\n    define = 'HAVE_' + h.underscorify().to_upper()\n    glib_conf.set(define, 1)\n    glib_conf_prefix = glib_conf_prefix + '#define @0@ 1\\n'.format(define)\n  endif\nendforeach\n\n# FIXME: Use cc.check_header from Meson 0.47.\n# FreeBSD includes a malloc.h which always throw compilation error.\nif cc.compiles('#include <malloc.h>', name : 'malloc.h')\n  glib_conf.set('HAVE_MALLOC_H', 1)\n  glib_conf_prefix = glib_conf_prefix + '#define HAVE_MALLOC_H 1\\n'\nendif\n\nif cc.has_header('linux/netlink.h')\n  glib_conf.set('HAVE_NETLINK', 1)\nendif\n\nif glib_conf.has('HAVE_LOCALE_H')\n  if cc.has_header_symbol('locale.h', 'LC_MESSAGES')\n    glib_conf.set('HAVE_LC_MESSAGES', 1)\n  endif\nendif\n\nstruct_stat_blkprefix = '''\n#include <sys/types.h>\n#include <sys/stat.h>\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n#ifdef HAVE_SYS_STATFS_H\n#include <sys/statfs.h>\n#endif\n#ifdef HAVE_SYS_PARAM_H\n#include <sys/param.h>\n#endif\n#ifdef HAVE_SYS_MOUNT_H\n#include <sys/mount.h>\n#endif\n'''\n\nstruct_members = [\n  [ 'stat', 'st_mtimensec' ],\n  [ 'stat', 'st_mtim.tv_nsec' ],\n  [ 'stat', 'st_atimensec' ],\n  [ 'stat', 'st_atim.tv_nsec' ],\n  [ 'stat', 'st_ctimensec' ],\n  [ 'stat', 'st_ctim.tv_nsec' ],\n  [ 'stat', 'st_birthtime' ],\n  [ 'stat', 'st_birthtimensec' ],\n  [ 'stat', 'st_birthtim' ],\n  [ 'stat', 'st_birthtim.tv_nsec' ],\n  [ 'stat', 'st_blksize', struct_stat_blkprefix ],\n  [ 'stat', 'st_blocks', struct_stat_blkprefix ],\n  [ 'statfs', 'f_fstypename', struct_stat_blkprefix ],\n  [ 'statfs', 'f_bavail', struct_stat_blkprefix ],\n  [ 'dirent', 'd_type', '''#include <sys/types.h>\n                           #include <dirent.h>''' ],\n  [ 'statvfs', 'f_basetype', '#include <sys/statvfs.h>' ],\n  [ 'statvfs', 'f_fstypename', '#include <sys/statvfs.h>' ],\n  [ 'tm', 'tm_gmtoff', '#include <time.h>' ],\n  [ 'tm', '__tm_gmtoff', '#include <time.h>' ],\n]\n\nforeach m : struct_members\n  header_check_prefix = glib_conf_prefix\n  if m.length() == 3\n    header_check_prefix = header_check_prefix + m[2]\n  else\n    header_check_prefix = header_check_prefix + '#include <sys/stat.h>'\n  endif\n  if cc.has_member('struct ' + m[0], m[1], prefix : header_check_prefix)\n    define = 'HAVE_STRUCT_@0@_@1@'.format(m[0].to_upper(), m[1].underscorify().to_upper())\n    glib_conf.set(define, 1)\n    glib_conf_prefix = glib_conf_prefix + '#define @0@ 1\\n'.format(define)\n  else\n  endif\nendforeach\n\n# Compiler flags\nif cc.get_id() == 'gcc' or cc.get_id() == 'clang'\n  warning_c_args = [\n    '-Wduplicated-branches',\n    '-Wimplicit-fallthrough',\n    '-Wmisleading-indentation',\n    '-Wstrict-prototypes',\n    '-Wunused',\n    # Due to maintained deprecated code, we do not want to see unused parameters\n    '-Wno-unused-parameter',\n    # Due to pervasive use of things like GPOINTER_TO_UINT(), we do not support\n    # building with -Wbad-function-cast.\n    '-Wno-bad-function-cast',\n    '-Wno-cast-function-type',\n    # Due to function casts through (void*) we cannot support -Wpedantic:\n    # https://wiki.gnome.org/Projects/GLib/CompilerRequirements#Function_pointer_conversions.\n    '-Wno-pedantic',\n    '-Werror=declaration-after-statement',\n    '-Werror=format=2',\n    '-Werror=implicit-function-declaration',\n    '-Werror=init-self',\n    '-Werror=missing-include-dirs',\n    '-Werror=missing-prototypes',\n    '-Werror=pointer-arith',\n  ]\n  warning_c_link_args = [\n    '-Wl,-z,nodelete',\n  ]\n  if get_option('bsymbolic_functions')\n    warning_c_link_args += ['-Wl,-Bsymbolic-functions']\n  endif\nelse\n  warning_c_args = []\n  warning_c_link_args = []\nendif\n\nadd_project_arguments(cc.get_supported_arguments(warning_c_args), language: 'c')\n\n# FIXME: We cannot build some of the GResource tests with -z nodelete, which\n# means we cannot use that flag in add_project_link_arguments(), and must add\n# it to the relevant targets manually. We do the same with -Bsymbolic-functions\n# because that is what the autotools build did.\n# See https://github.com/mesonbuild/meson/pull/3520 for a way to eventually\n# improve this.\nglib_link_flags = cc.get_supported_link_arguments(warning_c_link_args)\n\n# Windows SDK requirements and checks\nif host_system == 'windows'\n  # Check whether we're building for UWP apps\n  code = '''\n  #include <windows.h>\n  #if !(WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP) && !WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP))\n  #error \"Not building for UWP\"\n  #endif'''\n  if cc.compiles(code, name : 'building for UWP')\n    glib_conf.set('G_WINAPI_ONLY_APP', true)\n    # We require Windows 10+ on WinRT\n    glib_conf.set('_WIN32_WINNT', '0x0A00')\n  else\n    # We require Windows 7+ on Win32\n    glib_conf.set('_WIN32_WINNT', '0x0601')\n  endif\nendif\n\nfunctions = [\n  'endmntent',\n  'endservent',\n  'fallocate',\n  'fchmod',\n  'fchown',\n  'fdwalk',\n  'fsync',\n  'getauxval',\n  'getc_unlocked',\n  'getfsstat',\n  'getgrgid_r',\n  'getmntent_r',\n  'getpwuid_r',\n  'getresuid',\n  'getvfsstat',\n  'gmtime_r',\n  'hasmntopt',\n  'inotify_init1',\n  'issetugid',\n  'kevent',\n  'kqueue',\n  'lchmod',\n  'lchown',\n  'link',\n  'localtime_r',\n  'lstat',\n  'mbrtowc',\n  'memalign',\n  'mmap',\n  'newlocale',\n  'pipe2',\n  'poll',\n  'prlimit',\n  'readlink',\n  'recvmmsg',\n  'sendmmsg',\n  'setenv',\n  'setmntent',\n  'strerror_r',\n  'strnlen',\n  'strsignal',\n  'strtod_l',\n  'strtoll_l',\n  'strtoull_l',\n  'symlink',\n  'timegm',\n  'unsetenv',\n  'uselocale',\n  'utimes',\n  'valloc',\n  'vasprintf',\n  'vsnprintf',\n  'wcrtomb',\n  'wcslen',\n  'wcsnlen',\n  'sysctlbyname',\n  '_NSGetEnviron',\n]\n\nif glib_conf.has('HAVE_SYS_STATVFS_H')\n  functions += ['statvfs']\nelse\n  have_func_statvfs = false\nendif\nif glib_conf.has('HAVE_SYS_STATFS_H') or glib_conf.has('HAVE_SYS_MOUNT_H')\n  functions += ['statfs']\nelse\n  have_func_statfs = false\nendif\n\nif host_system == 'windows'\n  iphlpapi_dep = cc.find_library('iphlpapi')\n  iphlpapi_funcs = ['if_nametoindex', 'if_indextoname']\n  foreach ifunc : iphlpapi_funcs\n    iphl_prefix =  '''#define _WIN32_WINNT @0@\n      #include <winsock2.h>\n      #include <iphlpapi.h>'''.format(glib_conf.get('_WIN32_WINNT'))\n    if cc.has_function(ifunc,\n                       prefix : iphl_prefix,\n                       dependencies : iphlpapi_dep)\n      idefine = 'HAVE_' + ifunc.underscorify().to_upper()\n      glib_conf.set(idefine, 1)\n      glib_conf_prefix = glib_conf_prefix + '#define @0@ 1\\n'.format(idefine)\n      set_variable('have_func_' + ifunc, true)\n    else\n      set_variable('have_func_' + ifunc, false)\n    endif\n  endforeach\nelse\n  functions += ['if_indextoname', 'if_nametoindex']\nendif\n\n# AIX splice is something else\nif host_system != 'aix'\n  functions += ['splice']\nendif\n\nforeach f : functions\n  if cc.has_function(f)\n    define = 'HAVE_' + f.underscorify().to_upper()\n    glib_conf.set(define, 1)\n    glib_conf_prefix = glib_conf_prefix + '#define @0@ 1\\n'.format(define)\n    set_variable('have_func_' + f, true)\n  else\n    set_variable('have_func_' + f, false)\n  endif\nendforeach\n\n# Check that stpcpy() is usable; must use header\nif cc.has_function('stpcpy', prefix : '#include <string.h>')\n  glib_conf.set('HAVE_STPCPY', 1)\nendif\n\n# Check that posix_memalign() is usable; must use header\nif cc.has_function('posix_memalign', prefix : '#include <stdlib.h>')\n  glib_conf.set('HAVE_POSIX_MEMALIGN', 1)\nendif\n\n# Check that posix_spawn() is usable; must use header\nif cc.has_function('posix_spawn', prefix : '#include <spawn.h>')\n  glib_conf.set('HAVE_POSIX_SPAWN', 1)\nendif\n\n# Check whether strerror_r returns char *\nif have_func_strerror_r\n  if cc.compiles('''#define _GNU_SOURCE\n                    #include <string.h>\n                    int func (void) {\n                      char error_string[256];\n                      char *ptr = strerror_r (-2, error_string, 256);\n                      char c = *strerror_r (-2, error_string, 256);\n                      return c != 0 && ptr != (void*) 0L;\n                    }\n                 ''',\n                 name : 'strerror_r() returns char *')\n    glib_conf.set('STRERROR_R_CHAR_P', 1,\n                  description: 'Defined if strerror_r returns char *')\n  endif\nendif\n\n# Special-case these functions that have alternative names on Windows/MSVC\nif cc.has_function('snprintf') or cc.has_header_symbol('stdio.h', 'snprintf')\n  glib_conf.set('HAVE_SNPRINTF', 1)\n  glib_conf_prefix = glib_conf_prefix + '#define HAVE_SNPRINTF 1\\n'\nelif cc.has_function('_snprintf') or cc.has_header_symbol('stdio.h', '_snprintf')\n  hack_define = '1\\n#define snprintf _snprintf'\n  glib_conf.set('HAVE_SNPRINTF', hack_define)\n  glib_conf_prefix = glib_conf_prefix + '#define HAVE_SNPRINTF ' + hack_define\nendif\n\nif cc.has_function('strcasecmp')\n  glib_conf.set('HAVE_STRCASECMP', 1)\n  glib_conf_prefix = glib_conf_prefix + '#define HAVE_STRCASECMP 1\\n'\nelif cc.has_function('_stricmp')\n  hack_define = '1\\n#define strcasecmp _stricmp'\n  glib_conf.set('HAVE_STRCASECMP', hack_define)\n  glib_conf_prefix = glib_conf_prefix + '#define HAVE_STRCASECMP ' + hack_define\nendif\n\nif cc.has_function('strncasecmp')\n  glib_conf.set('HAVE_STRNCASECMP', 1)\n  glib_conf_prefix = glib_conf_prefix + '#define HAVE_STRNCASECMP 1\\n'\nelif cc.has_function('_strnicmp')\n  hack_define = '1\\n#define strncasecmp _strnicmp'\n  glib_conf.set('HAVE_STRNCASECMP', hack_define)\n  glib_conf_prefix = glib_conf_prefix + '#define HAVE_STRNCASECMP ' + hack_define\nendif\n\nif cc.has_header_symbol('sys/sysmacros.h', 'major')\n  glib_conf.set('MAJOR_IN_SYSMACROS', 1)\nelif cc.has_header_symbol('sys/mkdev.h', 'major')\n  glib_conf.set('MAJOR_IN_MKDEV', 1)\nelif cc.has_header_symbol('sys/types.h', 'major')\n  glib_conf.set('MAJOR_IN_TYPES', 1)\nendif\n\nif cc.has_header_symbol('dlfcn.h', 'RTLD_LAZY')\n  glib_conf.set('HAVE_RTLD_LAZY', 1)\nendif\n\nif cc.has_header_symbol('dlfcn.h', 'RTLD_NOW')\n  glib_conf.set('HAVE_RTLD_NOW', 1)\nendif\n\nif cc.has_header_symbol('dlfcn.h', 'RTLD_GLOBAL')\n  glib_conf.set('HAVE_RTLD_GLOBAL', 1)\nendif\n\nhave_rtld_next = false\nif cc.has_header_symbol('dlfcn.h', 'RTLD_NEXT', args: '-D_GNU_SOURCE')\n  have_rtld_next = true\n  glib_conf.set('HAVE_RTLD_NEXT', 1)\nendif\n\n# Check whether to use statfs or statvfs\n# Some systems have both statfs and statvfs, pick the most \"native\" for these\nif have_func_statfs and have_func_statvfs\n  # on solaris and irix, statfs doesn't even have the f_bavail field\n  if not glib_conf.has('HAVE_STRUCT_STATFS_F_BAVAIL')\n    have_func_statfs = false\n  else\n    # at least on linux, statfs is the actual syscall\n    have_func_statvfs = false\n  endif\nendif\nif have_func_statfs\n  glib_conf.set('USE_STATFS', 1)\n  stat_func_to_use = 'statfs'\nelif have_func_statvfs\n  glib_conf.set('USE_STATVFS', 1)\n  stat_func_to_use = 'statvfs'\nelse\n  stat_func_to_use = 'neither'\nendif\nmessage('Checking whether to use statfs or statvfs .. ' + stat_func_to_use)\n\nif host_system == 'linux'\n  if cc.has_function('mkostemp',\n                     prefix: '''#define _GNU_SOURCE\n                                #include <stdlib.h>''')\n    glib_conf.set('HAVE_MKOSTEMP', 1)\n  endif\nendif\n\nosx_ldflags = []\nglib_have_os_x_9_or_later = false\nglib_have_carbon = false\nglib_have_cocoa = false\nif host_system == 'darwin'\n  add_languages('objc')\n  objcc = meson.get_compiler('objc')\n\n  osx_ldflags += ['-Wl,-framework,CoreFoundation']\n\n  # Mac OS X Carbon support\n  glib_have_carbon = objcc.compiles('''#include <Carbon/Carbon.h>\n                                       #include <CoreServices/CoreServices.h>''',\n                                    name : 'Mac OS X Carbon support')\n\n  if glib_have_carbon\n    glib_conf.set('HAVE_CARBON', true)\n    osx_ldflags += '-Wl,-framework,Carbon'\n    glib_have_os_x_9_or_later = objcc.compiles('''#include <AvailabilityMacros.h>\n                                                  #if MAC_OS_X_VERSION_MIN_REQUIRED < 1090\n                                                  #error Compiling for minimum OS X version before 10.9\n                                                  #endif''',\n                                               name : 'OS X 9 or later')\n  endif\n\n  # Mac OS X Cocoa support\n  glib_have_cocoa = objcc.compiles('''#include <Cocoa/Cocoa.h>\n                                      #ifdef GNUSTEP_BASE_VERSION\n                                      #error \"Detected GNUstep, not Cocoa\"\n                                      #endif''',\n                                   name : 'Mac OS X Cocoa support')\n\n  if glib_have_cocoa\n    glib_conf.set('HAVE_COCOA', true)\n    osx_ldflags += ['-Wl,-framework,Foundation', '-Wl,-framework,AppKit']\n  endif\n\n  # FIXME: libgio mix C and objC source files and there is no way to reliably\n  # know which language flags it's going to use to link. Add to both languages\n  # for now. See https://github.com/mesonbuild/meson/issues/3585.\n  add_project_link_arguments(osx_ldflags, language : ['objc', 'c'])\nendif\n\n# Check for futex(2)\nif cc.links('''#include <linux/futex.h>\n               #include <sys/syscall.h>\n               #include <unistd.h>\n               int main (int argc, char ** argv) {\n                 syscall (__NR_futex, NULL, FUTEX_WAKE, FUTEX_WAIT);\n                 return 0;\n               }''', name : 'futex(2) system call')\n  glib_conf.set('HAVE_FUTEX', 1)\nendif\n\n# Check for eventfd(2)\nif cc.links('''#include <sys/eventfd.h>\n               #include <unistd.h>\n               int main (int argc, char ** argv) {\n                 eventfd (0, EFD_CLOEXEC);\n                 return 0;\n               }''', name : 'eventfd(2) system call')\n  glib_conf.set('HAVE_EVENTFD', 1)\nendif\n\nclock_gettime_test_code = '''\n  #include <time.h>\n  struct timespec t;\n  int main (int argc, char ** argv) {\n    return clock_gettime(CLOCK_REALTIME, &t);\n  }'''\nlibrt = []\nif cc.links(clock_gettime_test_code, name : 'clock_gettime')\n  glib_conf.set('HAVE_CLOCK_GETTIME', 1)\nelif cc.links(clock_gettime_test_code, args : '-lrt', name : 'clock_gettime in librt')\n  glib_conf.set('HAVE_CLOCK_GETTIME', 1)\n  librt = cc.find_library('rt')\nendif\n\ndlopen_dlsym_test_code = '''\n#include <dlfcn.h>\nint glib_underscore_test (void) { return 42; }\nint main (int argc, char ** argv) {\n  void *f1 = (void*)0, *f2 = (void*)0, *handle;\n  handle = dlopen ((void*)0, 0);\n  if (handle) {\n    f1 = dlsym (handle, \"glib_underscore_test\");\n    f2 = dlsym (handle, \"_glib_underscore_test\");\n  }\n  return (!f2 || f1);\n}'''\nlibdl_dep = []\nif cc.links(dlopen_dlsym_test_code, name : 'dlopen() and dlsym() in system libraries')\n  have_dlopen_dlsym = true\nelif cc.links(dlopen_dlsym_test_code, args : '-ldl', name : 'dlopen() and dlsym() in libdl')\n  have_dlopen_dlsym = true\n  libdl_dep = cc.find_library('dl')\nelse\n  have_dlopen_dlsym = false\nendif\n\n# if statfs() takes 2 arguments (Posix) or 4 (Solaris)\nif have_func_statfs\n  if cc.compiles(glib_conf_prefix + '''\n                 #include <unistd.h>\n                        #ifdef HAVE_SYS_PARAM_H\n                        #include <sys/param.h>\n                        #endif\n                        #ifdef HAVE_SYS_VFS_H\n                        #include <sys/vfs.h>\n                        #endif\n                        #ifdef HAVE_SYS_MOUNT_H\n                        #include <sys/mount.h>\n                        #endif\n                        #ifdef HAVE_SYS_STATFS_H\n                        #include <sys/statfs.h>\n                        #endif\n                        void some_func (void) {\n                          struct statfs st;\n                          statfs(\"/\", &st);\n                        }''', name : 'number of arguments to statfs() (n=2)')\n    glib_conf.set('STATFS_ARGS', 2)\n  elif cc.compiles(glib_conf_prefix + '''\n                   #include <unistd.h>\n                          #ifdef HAVE_SYS_PARAM_H\n                          #include <sys/param.h>\n                          #endif\n                          #ifdef HAVE_SYS_VFS_H\n                          #include <sys/vfs.h>\n                          #endif\n                          #ifdef HAVE_SYS_MOUNT_H\n                          #include <sys/mount.h>\n                          #endif\n                          #ifdef HAVE_SYS_STATFS_H\n                          #include <sys/statfs.h>\n                          #endif\n                          void some_func (void) {\n                            struct statfs st;\n                            statfs(\"/\", &st, sizeof (st), 0);\n                          }''', name : 'number of arguments to statfs() (n=4)')\n    glib_conf.set('STATFS_ARGS', 4)\n  else\n    error('Unable to determine number of arguments to statfs()')\n  endif\nendif\n\n# open takes O_DIRECTORY as an option\n#AC_MSG_CHECKING([])\nif cc.compiles('''#include <fcntl.h>\n                  #include <sys/types.h>\n                  #include <sys/stat.h>],\n                  void some_func (void) {\n                    open(0, O_DIRECTORY, 0);\n                  }''', name : 'open() option O_DIRECTORY')\n  glib_conf.set('HAVE_OPEN_O_DIRECTORY', 1)\nendif\n\n# Check whether there is a vsnprintf() function with C99 semantics installed.\n# (similar tests to AC_FUNC_VSNPRINTF_C99)\n# Check whether there is a snprintf() function with C99 semantics installed.\n# (similar tests to AC_FUNC_SNPRINTF_C99)\n# Check whether there is a printf() function with Unix98 semantics installed.\n# (similar tests to AC_FUNC_PRINTF_UNIX98)\nhave_good_vsnprintf = false\nhave_good_snprintf = false\nhave_good_printf = false\n\nif host_system == 'windows' and (cc.get_id() == 'msvc' or cc.get_id() == 'clang-cl')\n  # Unfortunately the Visual Studio 2015+ implementations of C99-style\n  # snprintf and vsnprintf don't seem to be quite good enough.\n  # (Sorry, I don't know exactly what is the problem,\n  # but it is related to floating point formatting and decimal point vs. comma.)\n  # The simple tests in AC_FUNC_VSNPRINTF_C99 and AC_FUNC_SNPRINTF_C99 aren't\n  # rigorous enough to notice, though.\n  glib_conf.set('HAVE_C99_SNPRINTF', false)\n  glib_conf.set('HAVE_C99_VSNPRINTF', false)\n  glib_conf.set('HAVE_UNIX98_PRINTF', false)\nelse\n  vsnprintf_c99_test_code = '''\n#include <stdio.h>\n#include <stdarg.h>\n\nint\ndoit(char * s, ...)\n{\n  char buffer[32];\n  va_list args;\n  int r;\n\n  va_start(args, s);\n  r = vsnprintf(buffer, 5, s, args);\n  va_end(args);\n\n  if (r != 7)\n    exit(1);\n\n  /* AIX 5.1 and Solaris seems to have a half-baked vsnprintf()\n     implementation. The above will return 7 but if you replace\n     the size of the buffer with 0, it borks! */\n  va_start(args, s);\n  r = vsnprintf(buffer, 0, s, args);\n  va_end(args);\n\n  if (r != 7)\n    exit(1);\n\n  exit(0);\n}\n\nint\nmain(void)\n{\n  doit(\"1234567\");\n  exit(1);\n}'''\n\n  if cc_can_run\n    rres = cc.run(vsnprintf_c99_test_code, name : 'C99 vsnprintf')\n    if rres.compiled() and rres.returncode() == 0\n      glib_conf.set('HAVE_C99_VSNPRINTF', 1)\n      have_good_vsnprintf = true\n    endif\n  else\n      have_good_vsnprintf = meson.get_cross_property('have_c99_vsnprintf', false)\n      glib_conf.set('HAVE_C99_VSNPRINTF', have_good_vsnprintf)\n  endif\n\n  snprintf_c99_test_code = '''\n#include <stdio.h>\n#include <stdarg.h>\n\nint\ndoit()\n{\n  char buffer[32];\n  va_list args;\n  int r;\n\n  r = snprintf(buffer, 5, \"1234567\");\n\n  if (r != 7)\n    exit(1);\n\n  r = snprintf(buffer, 0, \"1234567\");\n\n  if (r != 7)\n    exit(1);\n\n  r = snprintf(NULL, 0, \"1234567\");\n\n  if (r != 7)\n    exit(1);\n\n  exit(0);\n}\n\nint\nmain(void)\n{\n  doit();\n  exit(1);\n}'''\n\n  if cc_can_run\n    rres = cc.run(snprintf_c99_test_code, name : 'C99 snprintf')\n    if rres.compiled() and rres.returncode() == 0\n      glib_conf.set('HAVE_C99_SNPRINTF', 1)\n      have_good_snprintf = true\n    endif\n  else\n      have_good_snprintf = meson.get_cross_property('have_c99_snprintf', false)\n      glib_conf.set('HAVE_C99_SNPRINTF', have_good_snprintf)\n  endif\n\n  printf_unix98_test_code = '''\n#include <stdio.h>\n\nint\nmain (void)\n{\n  char buffer[128];\n\n  sprintf (buffer, \"%2\\$d %3\\$d %1\\$d\", 1, 2, 3);\n  if (strcmp (\"2 3 1\", buffer) == 0)\n    exit (0);\n  exit (1);\n}'''\n\n  if cc_can_run\n    rres = cc.run(printf_unix98_test_code, name : 'Unix98 printf positional parameters')\n    if rres.compiled() and rres.returncode() == 0\n      glib_conf.set('HAVE_UNIX98_PRINTF', 1)\n      have_good_printf = true\n    endif\n  else\n      have_good_printf = meson.get_cross_property('have_unix98_printf', false)\n      glib_conf.set('HAVE_UNIX98_PRINTF', have_good_printf)\n  endif\nendif\n\nif host_system == 'windows'\n  glib_conf.set_quoted('EXEEXT', '.exe')\nelse\n  glib_conf.set('EXEEXT', '')\nendif\n\n# Our printf is 'good' only if vsnpintf()/snprintf()/printf() supports C99 well enough\nuse_system_printf = have_good_vsnprintf and have_good_snprintf and have_good_printf\nglib_conf.set('USE_SYSTEM_PRINTF', use_system_printf)\nglibconfig_conf.set('GLIB_USING_SYSTEM_PRINTF', use_system_printf)\n\nif not use_system_printf\n  # gnulib has vasprintf so override the previous check\n  glib_conf.set('HAVE_VASPRINTF', 1)\nendif\n\n# Check for nl_langinfo and CODESET\nif cc.links('''#include <langinfo.h>\n               int main (int argc, char ** argv) {\n                 char *codeset = nl_langinfo (CODESET);\n                 return 0;\n               }''', name : 'nl_langinfo and CODESET')\n  glib_conf.set('HAVE_LANGINFO_CODESET', 1)\n  glib_conf.set('HAVE_CODESET', 1)\nendif\n\n# Check for nl_langinfo and LC_TIME parts that are needed in gdatetime.c\nif cc.links('''#include <langinfo.h>\n               int main (int argc, char ** argv) {\n                 char *str;\n                 str = nl_langinfo (PM_STR);\n                 str = nl_langinfo (D_T_FMT);\n                 str = nl_langinfo (D_FMT);\n                 str = nl_langinfo (T_FMT);\n                 str = nl_langinfo (T_FMT_AMPM);\n                 str = nl_langinfo (MON_1);\n                 str = nl_langinfo (ABMON_12);\n                 str = nl_langinfo (DAY_1);\n                 str = nl_langinfo (ABDAY_7);\n                 return 0;\n               }''', name : 'nl_langinfo (PM_STR)')\n  glib_conf.set('HAVE_LANGINFO_TIME', 1)\nendif\nif cc.links('''#include <langinfo.h>\n               int main (int argc, char ** argv) {\n                 char *str;\n                 str = nl_langinfo (_NL_CTYPE_OUTDIGIT0_MB);\n                 str = nl_langinfo (_NL_CTYPE_OUTDIGIT1_MB);\n                 str = nl_langinfo (_NL_CTYPE_OUTDIGIT2_MB);\n                 str = nl_langinfo (_NL_CTYPE_OUTDIGIT3_MB);\n                 str = nl_langinfo (_NL_CTYPE_OUTDIGIT4_MB);\n                 str = nl_langinfo (_NL_CTYPE_OUTDIGIT5_MB);\n                 str = nl_langinfo (_NL_CTYPE_OUTDIGIT6_MB);\n                 str = nl_langinfo (_NL_CTYPE_OUTDIGIT7_MB);\n                 str = nl_langinfo (_NL_CTYPE_OUTDIGIT8_MB);\n                 str = nl_langinfo (_NL_CTYPE_OUTDIGIT9_MB);\n                 return 0;\n               }''', name : 'nl_langinfo (_NL_CTYPE_OUTDIGITn_MB)')\n  glib_conf.set('HAVE_LANGINFO_OUTDIGIT', 1)\nendif\n\n# Check for nl_langinfo and alternative month names\nif cc.links('''#ifndef _GNU_SOURCE\n              # define _GNU_SOURCE\n              #endif\n              #include <langinfo.h>\n               int main (int argc, char ** argv) {\n                 char *str;\n                 str = nl_langinfo (ALTMON_1);\n                 str = nl_langinfo (ALTMON_2);\n                 str = nl_langinfo (ALTMON_3);\n                 str = nl_langinfo (ALTMON_4);\n                 str = nl_langinfo (ALTMON_5);\n                 str = nl_langinfo (ALTMON_6);\n                 str = nl_langinfo (ALTMON_7);\n                 str = nl_langinfo (ALTMON_8);\n                 str = nl_langinfo (ALTMON_9);\n                 str = nl_langinfo (ALTMON_10);\n                 str = nl_langinfo (ALTMON_11);\n                 str = nl_langinfo (ALTMON_12);\n                 return 0;\n               }''', name : 'nl_langinfo (ALTMON_n)')\n  glib_conf.set('HAVE_LANGINFO_ALTMON', 1)\nendif\n\n# Check for nl_langinfo and abbreviated alternative month names\nif cc.links('''#ifndef _GNU_SOURCE\n              # define _GNU_SOURCE\n              #endif\n              #include <langinfo.h>\n               int main (int argc, char ** argv) {\n                 char *str;\n                 str = nl_langinfo (_NL_ABALTMON_1);\n                 str = nl_langinfo (_NL_ABALTMON_2);\n                 str = nl_langinfo (_NL_ABALTMON_3);\n                 str = nl_langinfo (_NL_ABALTMON_4);\n                 str = nl_langinfo (_NL_ABALTMON_5);\n                 str = nl_langinfo (_NL_ABALTMON_6);\n                 str = nl_langinfo (_NL_ABALTMON_7);\n                 str = nl_langinfo (_NL_ABALTMON_8);\n                 str = nl_langinfo (_NL_ABALTMON_9);\n                 str = nl_langinfo (_NL_ABALTMON_10);\n                 str = nl_langinfo (_NL_ABALTMON_11);\n                 str = nl_langinfo (_NL_ABALTMON_12);\n                 return 0;\n               }''', name : 'nl_langinfo (_NL_ABALTMON_n)')\n  glib_conf.set('HAVE_LANGINFO_ABALTMON', 1)\nendif\n\n# Check if C compiler supports the 'signed' keyword\nif not cc.compiles('''signed char x;''', name : 'signed')\n  glib_conf.set('signed', '/* NOOP */')\nendif\n\n# Check if the ptrdiff_t type exists\nif cc.has_header_symbol('stddef.h', 'ptrdiff_t')\n  glib_conf.set('HAVE_PTRDIFF_T', 1)\nendif\n\n# Check for sig_atomic_t type\nif cc.links('''#include <signal.h>\n               #include <sys/types.h>\n               sig_atomic_t val = 42;\n               int main (int argc, char ** argv) {\n                 return val == 42 ? 0 : 1;\n               }''', name : 'sig_atomic_t')\n  glib_conf.set('HAVE_SIG_ATOMIC_T', 1)\nendif\n\n# Check if 'long long' works\n# jm_AC_TYPE_LONG_LONG\nif cc.compiles('''long long ll = 1LL;\n                  int i = 63;\n                  int some_func (void) {\n                    long long llmax = (long long) -1;\n                    return ll << i | ll >> i | llmax / ll | llmax % ll;\n                  }''', name : 'long long')\n  glib_conf.set('HAVE_LONG_LONG', 1)\n  have_long_long = true\nelse\n  have_long_long = false\nendif\n\n# Test whether the compiler supports the 'long double' type.\nif cc.compiles('''/* The Stardent Vistra knows sizeof(long double), but does not support it.  */\n                  long double foo = 0.0;\n                  /* On Ultrix 4.3 cc, long double is 4 and double is 8.  */\n                  int array [2*(sizeof(long double) >= sizeof(double)) - 1];''',\n               name : 'long double')\n  glib_conf.set('HAVE_LONG_DOUBLE', 1)\nendif\n\n# Test whether <stddef.h> has the 'wchar_t' type.\nif cc.has_header_symbol('stddef.h', 'wchar_t')\n  glib_conf.set('HAVE_WCHAR_T', 1)\nendif\n\n# Test whether <wchar.h> has the 'wint_t' type.\nif cc.has_header_symbol('wchar.h', 'wint_t')\n  glib_conf.set('HAVE_WINT_T', 1)\nendif\n\nfound_uintmax_t = false\n\n# Define HAVE_INTTYPES_H_WITH_UINTMAX if <inttypes.h> exists,\n# doesn't clash with <sys/types.h>, and declares uintmax_t.\n# jm_AC_HEADER_INTTYPES_H\nif cc.compiles('''#include <sys/types.h>\n                  #include <inttypes.h>\n                  void some_func (void) {\n                    uintmax_t i = (uintmax_t) -1;\n                  }''', name : 'uintmax_t in inttypes.h')\n  glib_conf.set('HAVE_INTTYPES_H_WITH_UINTMAX', 1)\n  found_uintmax_t = true\nendif\n\n# Define HAVE_STDINT_H_WITH_UINTMAX if <stdint.h> exists,\n# doesn't clash with <sys/types.h>, and declares uintmax_t.\n# jm_AC_HEADER_STDINT_H\nif cc.compiles('''#include <sys/types.h>\n                  #include <stdint.h>\n                  void some_func (void) {\n                    uintmax_t i = (uintmax_t) -1;\n                  }''', name : 'uintmax_t in stdint.h')\n  glib_conf.set('HAVE_STDINT_H_WITH_UINTMAX', 1)\n  found_uintmax_t = true\nendif\n\n# Define intmax_t to 'long' or 'long long'\n# if it is not already defined in <stdint.h> or <inttypes.h>.\n# For simplicity, we assume that a header file defines 'intmax_t' if and\n# only if it defines 'uintmax_t'.\nif found_uintmax_t\n  glib_conf.set('HAVE_INTMAX_T', 1)\nelif have_long_long\n  glib_conf.set('intmax_t', 'long long')\nelse\n  glib_conf.set('intmax_t', 'long')\nendif\n\nchar_size = cc.sizeof('char')\nshort_size = cc.sizeof('short')\nint_size = cc.sizeof('int')\nvoidp_size = cc.sizeof('void*')\nlong_size = cc.sizeof('long')\nif have_long_long\n  long_long_size = cc.sizeof('long long')\nelse\n  long_long_size = 0\nendif\nsizet_size = cc.sizeof('size_t')\nif cc.get_id() == 'msvc' or cc.get_id() == 'clang-cl'\n  ssizet_size = cc.sizeof('SSIZE_T', prefix : '#include <BaseTsd.h>')\nelse\n  ssizet_size = cc.sizeof('ssize_t')\nendif\n\n# Some platforms (Apple) hard-code int64_t to long long instead of\n# using long on 64-bit architectures. This can cause type mismatch\n# warnings when trying to interface with code using the standard\n# library type. Test for the warnings and set gint64 to whichever\n# works.\nif long_long_size == long_size\n  if cc.compiles('''#if defined(_AIX) && !defined(__GNUC__)\n                    #pragma options langlvl=stdc99\n                    #endif\n                    #pragma GCC diagnostic error \"-Wincompatible-pointer-types\"\n                    #include <stdint.h>\n                    #include <stdio.h>\n                    int main () {\n                      int64_t i1 = 1;\n                      long *i2 = &i1;\n                      return 1;\n                    }''', name : 'int64_t is long')\n    int64_t_typedef = 'long'\n  elif cc.compiles('''#if defined(_AIX) && !defined(__GNUC__)\n                      #pragma options langlvl=stdc99\n                      #endif\n                      #pragma GCC diagnostic error \"-Wincompatible-pointer-types\"\n                      #include <stdint.h>\n                      #include <stdio.h>\n                      int main () {\n                        int64_t i1 = 1;\n                        long long *i2 = &i1;\n                        return 1;\n                      }''', name : 'int64_t is long long')\n    int64_t_typedef = 'long long'\n  endif\nendif\n\nint64_m = 'll'\nchar_align = cc.alignment('char')\nshort_align = cc.alignment('short')\nint_align = cc.alignment('int')\nvoidp_align = cc.alignment('void*')\nlong_align = cc.alignment('long')\nlong_long_align = cc.alignment('long long')\n# NOTE: We don't check for size of __int64 because long long is guaranteed to\n# be 64-bit in C99, and it is available on all supported compilers\nsizet_align = cc.alignment('size_t')\n\nglib_conf.set('ALIGNOF_UNSIGNED_LONG', long_align)\n\nglib_conf.set('SIZEOF_CHAR', char_size)\nglib_conf.set('SIZEOF_INT', int_size)\nglib_conf.set('SIZEOF_SHORT', short_size)\nglib_conf.set('SIZEOF_LONG', long_size)\nglib_conf.set('SIZEOF_LONG_LONG', long_long_size)\nglib_conf.set('SIZEOF_SIZE_T', sizet_size)\nglib_conf.set('SIZEOF_SSIZE_T', ssizet_size)\nglib_conf.set('SIZEOF_VOID_P', voidp_size)\nglib_conf.set('SIZEOF_WCHAR_T', cc.sizeof('wchar_t', prefix: '#include <stddef.h>'))\n\nif short_size == 2\n  gint16 = 'short'\n  gint16_modifier='h'\n  gint16_format='hi'\n  guint16_format='hu'\nelif int_size == 2\n  gint16 = 'int'\n  gint16_modifier=''\n  gint16_format='i'\n  guint16_format='u'\nelse\n  error('Compiler provides no native 16-bit integer type')\nendif\nglibconfig_conf.set('gint16', gint16)\nglibconfig_conf.set_quoted('gint16_modifier', gint16_modifier)\nglibconfig_conf.set_quoted('gint16_format', gint16_format)\nglibconfig_conf.set_quoted('guint16_format', guint16_format)\n\nif short_size == 4\n  gint32 = 'short'\n  gint32_modifier='h'\n  gint32_format='hi'\n  guint32_format='hu'\n  guint32_align = short_align\nelif int_size == 4\n  gint32 = 'int'\n  gint32_modifier=''\n  gint32_format='i'\n  guint32_format='u'\n  guint32_align = int_align\nelif long_size == 4\n  gint32 = 'long'\n  gint32_modifier='l'\n  gint32_format='li'\n  guint32_format='lu'\n  guint32_align = long_align\nelse\n  error('Compiler provides no native 32-bit integer type')\nendif\nglibconfig_conf.set('gint32', gint32)\nglibconfig_conf.set_quoted('gint32_modifier', gint32_modifier)\nglibconfig_conf.set_quoted('gint32_format', gint32_format)\nglibconfig_conf.set_quoted('guint32_format', guint32_format)\nglib_conf.set('ALIGNOF_GUINT32', guint32_align)\n\nif int_size == 8\n  gint64 = 'int'\n  gint64_modifier=''\n  gint64_format='i'\n  guint64_format='u'\n  glib_extension=''\n  gint64_constant='(val)'\n  guint64_constant='(val)'\n  guint64_align = int_align\nelif long_size == 8 and (long_long_size != long_size or int64_t_typedef == 'long')\n  gint64 = 'long'\n  glib_extension=''\n  gint64_modifier='l'\n  gint64_format='li'\n  guint64_format='lu'\n  gint64_constant='(val##L)'\n  guint64_constant='(val##UL)'\n  guint64_align = long_align\nelif long_long_size == 8 and (long_long_size != long_size or int64_t_typedef == 'long long')\n  gint64 = 'long long'\n  glib_extension='G_GNUC_EXTENSION '\n  gint64_modifier=int64_m\n  gint64_format=int64_m + 'i'\n  guint64_format=int64_m + 'u'\n  gint64_constant='(G_GNUC_EXTENSION (val##LL))'\n  guint64_constant='(G_GNUC_EXTENSION (val##ULL))'\n  guint64_align = long_long_align\nelse\n  error('Compiler provides no native 64-bit integer type')\nendif\nglibconfig_conf.set('glib_extension', glib_extension)\nglibconfig_conf.set('gint64', gint64)\nglibconfig_conf.set_quoted('gint64_modifier', gint64_modifier)\nglibconfig_conf.set_quoted('gint64_format', gint64_format)\nglibconfig_conf.set_quoted('guint64_format', guint64_format)\nglibconfig_conf.set('gint64_constant', gint64_constant)\nglibconfig_conf.set('guint64_constant', guint64_constant)\nglib_conf.set('ALIGNOF_GUINT64', guint64_align)\n\nif host_system == 'windows'\n  glibconfig_conf.set('g_pid_type', 'void*')\n  glibconfig_conf.set_quoted('g_pid_format', 'p')\n  if host_machine.cpu_family() == 'x86_64'\n    glibconfig_conf.set_quoted('g_pollfd_format', '%#' + int64_m + 'x')\n  else\n    glibconfig_conf.set_quoted('g_pollfd_format', '%#x')\n  endif\n  glibconfig_conf.set('g_dir_separator', '\\\\\\\\')\n  glibconfig_conf.set('g_searchpath_separator', ';')\nelse\n  glibconfig_conf.set('g_pid_type', 'int')\n  glibconfig_conf.set_quoted('g_pid_format', 'i')\n  glibconfig_conf.set_quoted('g_pollfd_format', '%d')\n  glibconfig_conf.set('g_dir_separator', '/')\n  glibconfig_conf.set('g_searchpath_separator', ':')\nendif\n\ng_sizet_compatibility = {\n  'short': sizet_size == short_size,\n  'int': sizet_size == int_size,\n  'long': sizet_size == long_size,\n  'long long': sizet_size == long_long_size,\n}\n\n# Do separate checks for gcc/clang (and ignore other compilers for now), since\n# we need to explicitly pass -Werror to the compilers.\n# FIXME: https://github.com/mesonbuild/meson/issues/5399\n# We can\u2019t simplify these checks using a foreach loop because dictionary keys\n# have to be string literals.\n# FIXME: https://github.com/mesonbuild/meson/issues/5231\nif cc.get_id() == 'gcc' or cc.get_id() == 'clang'\n  g_sizet_compatibility += {\n    'short': g_sizet_compatibility['short'] and cc.compiles(\n        '''#include <stddef.h>\n        size_t f (size_t *i) { return *i + 1; }\n        int main (void) {\n          unsigned short i = 0;\n          f (&i);\n          return 0;\n        }''',\n        args: ['-Werror'],\n        name : 'GCC size_t typedef is short'),\n    'int': g_sizet_compatibility['int'] and cc.compiles(\n        '''#include <stddef.h>\n        size_t f (size_t *i) { return *i + 1; }\n        int main (void) {\n          unsigned int i = 0;\n          f (&i);\n          return 0;\n        }''',\n        args: ['-Werror'],\n        name : 'GCC size_t typedef is int'),\n    'long': g_sizet_compatibility['long'] and cc.compiles(\n        '''#include <stddef.h>\n        size_t f (size_t *i) { return *i + 1; }\n        int main (void) {\n          unsigned long i = 0;\n          f (&i);\n          return 0;\n        }''',\n        args: ['-Werror'],\n        name : 'GCC size_t typedef is long'),\n    'long long': g_sizet_compatibility['long long'] and cc.compiles(\n        '''#include <stddef.h>\n        size_t f (size_t *i) { return *i + 1; }\n        int main (void) {\n          unsigned long long i = 0;\n          f (&i);\n          return 0;\n        }''',\n        args: ['-Werror'],\n        name : 'GCC size_t typedef is long long'),\n  }\nendif\n\nif g_sizet_compatibility['short']\n  glibconfig_conf.set('glib_size_type_define', 'short')\n  glibconfig_conf.set_quoted('gsize_modifier', 'h')\n  glibconfig_conf.set_quoted('gssize_modifier', 'h')\n  glibconfig_conf.set_quoted('gsize_format', 'hu')\n  glibconfig_conf.set_quoted('gssize_format', 'hi')\n  glibconfig_conf.set('glib_msize_type', 'SHRT')\nelif g_sizet_compatibility['int']\n  glibconfig_conf.set('glib_size_type_define', 'int')\n  glibconfig_conf.set_quoted('gsize_modifier', '')\n  glibconfig_conf.set_quoted('gssize_modifier', '')\n  glibconfig_conf.set_quoted('gsize_format', 'u')\n  glibconfig_conf.set_quoted('gssize_format', 'i')\n  glibconfig_conf.set('glib_msize_type', 'INT')\nelif g_sizet_compatibility['long']\n  glibconfig_conf.set('glib_size_type_define', 'long')\n  glibconfig_conf.set_quoted('gsize_modifier', 'l')\n  glibconfig_conf.set_quoted('gssize_modifier', 'l')\n  glibconfig_conf.set_quoted('gsize_format', 'lu')\n  glibconfig_conf.set_quoted('gssize_format', 'li')\n  glibconfig_conf.set('glib_msize_type', 'LONG')\nelif g_sizet_compatibility['long long']\n  glibconfig_conf.set('glib_size_type_define', 'long long')\n  glibconfig_conf.set_quoted('gsize_modifier', int64_m)\n  glibconfig_conf.set_quoted('gssize_modifier', int64_m)\n  glibconfig_conf.set_quoted('gsize_format', int64_m + 'u')\n  glibconfig_conf.set_quoted('gssize_format', int64_m + 'i')\n  glibconfig_conf.set('glib_msize_type', 'INT64')\nelse\n  error('Could not determine size of size_t.')\nendif\n\nif voidp_size == int_size\n  glibconfig_conf.set('glib_intptr_type_define', 'int')\n  glibconfig_conf.set_quoted('gintptr_modifier', '')\n  glibconfig_conf.set_quoted('gintptr_format', 'i')\n  glibconfig_conf.set_quoted('guintptr_format', 'u')\n  glibconfig_conf.set('glib_gpi_cast', '(gint)')\n  glibconfig_conf.set('glib_gpui_cast', '(guint)')\nelif voidp_size == long_size\n  glibconfig_conf.set('glib_intptr_type_define', 'long')\n  glibconfig_conf.set_quoted('gintptr_modifier', 'l')\n  glibconfig_conf.set_quoted('gintptr_format', 'li')\n  glibconfig_conf.set_quoted('guintptr_format', 'lu')\n  glibconfig_conf.set('glib_gpi_cast', '(glong)')\n  glibconfig_conf.set('glib_gpui_cast', '(gulong)')\nelif voidp_size == long_long_size\n  glibconfig_conf.set('glib_intptr_type_define', 'long long')\n  glibconfig_conf.set_quoted('gintptr_modifier', int64_m)\n  glibconfig_conf.set_quoted('gintptr_format', int64_m + 'i')\n  glibconfig_conf.set_quoted('guintptr_format', int64_m + 'u')\n  glibconfig_conf.set('glib_gpi_cast', '(gint64)')\n  glibconfig_conf.set('glib_gpui_cast', '(guint64)')\nelse\n  error('Could not determine size of void *')\nendif\n\nif long_size != 8 and long_long_size != 8 and int_size != 8\n  error('GLib requires a 64-bit type. You might want to consider using the GNU C compiler.')\nendif\n\nglibconfig_conf.set('gintbits', int_size * 8)\nglibconfig_conf.set('glongbits', long_size * 8)\nglibconfig_conf.set('gsizebits', sizet_size * 8)\nglibconfig_conf.set('gssizebits', ssizet_size * 8)\n\n# XXX: https://gitlab.gnome.org/GNOME/glib/issues/1413\nif host_system == 'windows'\n  g_module_suffix = 'dll'\nelse\n  g_module_suffix = 'so'\nendif\nglibconfig_conf.set('g_module_suffix', g_module_suffix)\n\nglibconfig_conf.set('GLIB_MAJOR_VERSION', major_version)\nglibconfig_conf.set('GLIB_MINOR_VERSION', minor_version)\nglibconfig_conf.set('GLIB_MICRO_VERSION', micro_version)\nglibconfig_conf.set('GLIB_VERSION', glib_version)\n\nglibconfig_conf.set('glib_void_p', voidp_size)\nglibconfig_conf.set('glib_long', long_size)\nglibconfig_conf.set('glib_size_t', sizet_size)\nglibconfig_conf.set('glib_ssize_t', ssizet_size)\nif host_machine.endian() == 'big'\n  glibconfig_conf.set('g_byte_order', 'G_BIG_ENDIAN')\n  glibconfig_conf.set('g_bs_native', 'BE')\n  glibconfig_conf.set('g_bs_alien', 'LE')\nelse\n  glibconfig_conf.set('g_byte_order', 'G_LITTLE_ENDIAN')\n  glibconfig_conf.set('g_bs_native', 'LE')\n  glibconfig_conf.set('g_bs_alien', 'BE')\nendif\n\n# === va_copy checks ===\n# we currently check for all three va_copy possibilities, so we get\n# all results in config.log for bug reports.\n\nva_copy_func = ''\nforeach try_func : [ '__va_copy', 'va_copy' ]\n  if cc.compiles('''#include <stdarg.h>\n                    #include <stdlib.h>\n                    #ifdef _MSC_VER\n                    # include \"msvc_recommended_pragmas.h\"\n                    #endif\n                    void f (int i, ...) {\n                    va_list args1, args2;\n                    va_start (args1, i);\n                    @0@ (args2, args1);\n                    if (va_arg (args2, int) != 42 || va_arg (args1, int) != 42)\n                      exit (1);\n                    va_end (args1); va_end (args2);\n                    }\n                    int main() {\n                      f (0, 42);\n                      return 0;\n                    }'''.format(try_func),\n                    name : try_func + ' check')\n    va_copy_func = try_func\n  endif\nendforeach\nif va_copy_func != ''\n  glib_conf.set('G_VA_COPY', va_copy_func)\n  glib_vacopy = '#define G_VA_COPY ' + va_copy_func\nelse\n  glib_vacopy = '/* #undef G_VA_COPY */'\nendif\n\nva_list_val_copy_prog = '''\n  #include <stdarg.h>\n  #include <stdlib.h>\n  void f (int i, ...) {\n    va_list args1, args2;\n    va_start (args1, i);\n    args2 = args1;\n    if (va_arg (args2, int) != 42 || va_arg (args1, int) != 42)\n      exit (1);\n    va_end (args1); va_end (args2);\n  }\n  int main() {\n    f (0, 42);\n    return 0;\n  }'''\n\nif cc_can_run\n  rres = cc.run(va_list_val_copy_prog, name : 'va_lists can be copied as values')\n  glib_va_val_copy = rres.returncode() == 0\nelse\n  glib_va_val_copy = meson.get_cross_property('va_val_copy', true)\nendif\nif not glib_va_val_copy\n  glib_vacopy = glib_vacopy + '\\n#define G_VA_COPY_AS_ARRAY 1'\n  glib_conf.set('G_VA_COPY_AS_ARRAY', 1)\nendif\nglibconfig_conf.set('glib_vacopy', glib_vacopy)\n\n# check for flavours of varargs macros\ng_have_iso_c_varargs = cc.compiles('''\n  void some_func (void) {\n    int a(int p1, int p2, int p3);\n    #define call_a(...) a(1,__VA_ARGS__)\n    call_a(2,3);\n  }''', name : 'ISO C99 varargs macros in C')\n\nif g_have_iso_c_varargs\n  glibconfig_conf.set('g_have_iso_c_varargs', '''\n#ifndef __cplusplus\n# define G_HAVE_ISO_VARARGS 1\n#endif''')\nendif\n\ng_have_iso_cxx_varargs = cxx.compiles('''\n  void some_func (void) {\n    int a(int p1, int p2, int p3);\n    #define call_a(...) a(1,__VA_ARGS__)\n    call_a(2,3);\n  }''', name : 'ISO C99 varargs macros in C++')\n\nif g_have_iso_cxx_varargs\n  glibconfig_conf.set('g_have_iso_cxx_varargs', '''\n#ifdef __cplusplus\n# define G_HAVE_ISO_VARARGS 1\n#endif''')\nendif\n\ng_have_gnuc_varargs = cc.compiles('''\n  void some_func (void) {\n    int a(int p1, int p2, int p3);\n    #define call_a(params...) a(1,params)\n    call_a(2,3);\n  }''', name : 'GNUC varargs macros')\n\nif cc.has_header('alloca.h')\n  glibconfig_conf.set('GLIB_HAVE_ALLOCA_H', true)\nendif\nhas_syspoll = cc.has_header('sys/poll.h')\nhas_systypes = cc.has_header('sys/types.h')\nif has_syspoll\n  glibconfig_conf.set('GLIB_HAVE_SYS_POLL_H', true)\nendif\nhas_winsock2 = cc.has_header('winsock2.h')\n\nif has_syspoll and has_systypes\n  poll_includes = '''\n      #include<sys/poll.h>\n      #include<sys/types.h>'''\nelif has_winsock2\n  poll_includes = '''\n      #define _WIN32_WINNT @0@\n      #include <winsock2.h>'''.format(glib_conf.get('_WIN32_WINNT'))\nelse\n  # FIXME?\n  error('FIX POLL* defines')\nendif\n\npoll_defines = [\n  [ 'POLLIN', 'g_pollin', 1 ],\n  [ 'POLLOUT', 'g_pollout', 4 ],\n  [ 'POLLPRI', 'g_pollpri', 2 ],\n  [ 'POLLERR', 'g_pollerr', 8 ],\n  [ 'POLLHUP', 'g_pollhup', 16 ],\n  [ 'POLLNVAL', 'g_pollnval', 32 ],\n]\n\nif has_syspoll and has_systypes\n  foreach d : poll_defines\n    val = cc.compute_int(d[0], prefix: poll_includes)\n    glibconfig_conf.set(d[1], val)\n  endforeach\nelif has_winsock2\n  # Due to a missed bug in configure.ac the poll test\n  # never succeeded on Windows and used some pre-defined\n  # values as a fallback. Keep using them to maintain\n  # ABI compatibility with autotools builds of glibs\n  # and with *any* glib-using code compiled against them,\n  # since these values end up in a public header glibconfig.h.\n  foreach d : poll_defines\n    glibconfig_conf.set(d[1], d[2])\n  endforeach\nendif\n\n# Internet address families\n# FIXME: what about Cygwin (G_WITH_CYGWIN)\nif host_system == 'windows'\n  inet_includes = '''\n      #include <winsock2.h>'''\nelse\n  inet_includes = '''\n      #include <sys/types.h>\n      #include <sys/socket.h>'''\nendif\n\ninet_defines = [\n  [ 'AF_UNIX', 'g_af_unix' ],\n  [ 'AF_INET', 'g_af_inet' ],\n  [ 'AF_INET6', 'g_af_inet6' ],\n  [ 'MSG_OOB', 'g_msg_oob' ],\n  [ 'MSG_PEEK', 'g_msg_peek' ],\n  [ 'MSG_DONTROUTE', 'g_msg_dontroute' ],\n]\nforeach d : inet_defines\n  val = cc.compute_int(d[0], prefix: inet_includes)\n  glibconfig_conf.set(d[1], val)\nendforeach\n\n# We need a more robust approach here...\nhost_cpu_family = host_machine.cpu_family()\nif host_cpu_family == 'x86' or host_cpu_family == 'x86_64' or host_cpu_family == 's390' or host_cpu_family == 's390x' or host_cpu_family.startswith('arm') or host_cpu_family == 'aarch64' or host_cpu_family.startswith('crisv32') or host_cpu_family.startswith('etrax')\n  glib_memory_barrier_needed = false\nelif host_cpu_family.startswith('sparc') or host_cpu_family.startswith('alpha') or host_cpu_family.startswith('powerpc') or host_cpu_family == 'ia64'\n  glib_memory_barrier_needed = true\nelse\n  warning('Unknown host cpu: ' + host_cpu_family)\n  glib_memory_barrier_needed = true\nendif\nglibconfig_conf.set('G_ATOMIC_OP_MEMORY_BARRIER_NEEDED', glib_memory_barrier_needed)\n\n# We need to decide at configure time if GLib will use real atomic\n# operations (\"lock free\") or emulated ones with a mutex.  This is\n# because we must put this information in glibconfig.h so we know if\n# it is safe or not to inline using compiler intrinsics directly from\n# the header.\n#\n# We also publish the information via G_ATOMIC_LOCK_FREE in case the\n# user is interested in knowing if they can use the atomic ops across\n# processes.\n#\n# We can currently support the atomic ops natively when building GLib\n# with recent versions of GCC or MSVC.\n#\n# Note that the atomic ops are only available with GCC on x86 when\n# using -march=i486 or higher.  If we detect that the atomic ops are\n# not available but would be available given the right flags, we want\n# to abort and advise the user to fix their CFLAGS.  It's better to do\n# that then to silently fall back on emulated atomic ops just because\n# the user had the wrong build environment.\natomictest = '''int main() {\n  volatile int atomic = 2;\n  __sync_bool_compare_and_swap (&atomic, 2, 3);\n  return 0;\n}\n'''\n\natomicdefine = '''\n#ifndef __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4\n#error \"compiler has atomic ops, but doesn't define __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4\"\n#endif\n'''\n\n# We know that we can always use real (\"lock free\") atomic operations with MSVC\nif cc.get_id() == 'msvc' or cc.get_id() == 'clang-cl' or cc.links(atomictest, name : 'atomic ops')\n  have_atomic_lock_free = true\n  if cc.get_id() == 'gcc' and not cc.compiles(atomicdefine, name : 'atomic ops define')\n    # Old gcc release may provide\n    # __sync_bool_compare_and_swap but doesn't define\n    # __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4\n    glib_conf.set('__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4', true)\n  endif\nelse\n  have_atomic_lock_free = false\n  if host_machine.cpu_family() == 'x86' and cc.links(atomictest, args : '-march=i486')\n    error('GLib must be built with -march=i486 or later.')\n  endif\nendif\nglibconfig_conf.set('G_ATOMIC_LOCK_FREE', have_atomic_lock_free)\n\n# === Threads ===\n\n# Determination of thread implementation\nif host_system == 'windows' and not get_option('force_posix_threads')\n  thread_dep = []\n  threads_implementation = 'win32'\n  glibconfig_conf.set('g_threads_impl_def', 'WIN32')\n  glib_conf.set('THREADS_WIN32', 1)\nelse\n  thread_dep = dependency('threads')\n  threads_implementation = 'posix'\n  pthread_prefix = '''\n      #ifndef _GNU_SOURCE\n      # define _GNU_SOURCE\n      #endif\n      #include <pthread.h>'''\n  glibconfig_conf.set('g_threads_impl_def', 'POSIX')\n  glib_conf.set('THREADS_POSIX', 1)\n  if cc.has_header_symbol('pthread.h', 'pthread_attr_setstacksize')\n    glib_conf.set('HAVE_PTHREAD_ATTR_SETSTACKSIZE', 1)\n  endif\n  if cc.has_header_symbol('pthread.h', 'pthread_attr_setinheritsched')\n    glib_conf.set('HAVE_PTHREAD_ATTR_SETINHERITSCHED', 1)\n  endif\n  if cc.has_header_symbol('pthread.h', 'pthread_condattr_setclock')\n    glib_conf.set('HAVE_PTHREAD_CONDATTR_SETCLOCK', 1)\n  endif\n  if cc.has_header_symbol('pthread.h', 'pthread_cond_timedwait_relative_np')\n    glib_conf.set('HAVE_PTHREAD_COND_TIMEDWAIT_RELATIVE_NP', 1)\n  endif\n  if cc.has_header_symbol('pthread.h', 'pthread_getname_np', prefix : pthread_prefix)\n    glib_conf.set('HAVE_PTHREAD_GETNAME_NP', 1)\n  endif\n\n  if cc.has_header_symbol('sys/syscall.h', 'SYS_sched_getattr')\n    glib_conf.set('HAVE_SYS_SCHED_GETATTR', 1)\n  endif\n\n  # Assume that pthread_setname_np is available in some form; same as configure\n  if cc.links(pthread_prefix + '''\n              int main() {\n                pthread_setname_np(\"example\");\n                return 0;\n              }''',\n              name : 'pthread_setname_np(const char*)',\n              dependencies : thread_dep)\n    # macOS and iOS\n    glib_conf.set('HAVE_PTHREAD_SETNAME_NP_WITHOUT_TID', 1)\n  elif cc.links(pthread_prefix + '''\n                int main() {\n                  pthread_setname_np(pthread_self(), \"example\");\n                  return 0;\n                }''',\n                name : 'pthread_setname_np(pthread_t, const char*)',\n                dependencies : thread_dep)\n    # Linux, Solaris, etc.\n    glib_conf.set('HAVE_PTHREAD_SETNAME_NP_WITH_TID', 1)\n  elif cc.links(pthread_prefix + '''\n                int main() {\n                  pthread_setname_np(pthread_self(), \"%s\", \"example\");\n                  return 0;\n                }''',\n                name : 'pthread_setname_np(pthread_t, const char*, void*)',\n                dependencies : thread_dep)\n    # NetBSD\n    glib_conf.set('HAVE_PTHREAD_SETNAME_NP_WITH_TID_AND_ARG', 1)\n  elif cc.links(pthread_prefix + '''\n                #include <pthread_np.h>\n                int main() {\n                  pthread_set_name_np(pthread_self(), \"example\");\n                  return 0;\n                }''',\n                name : 'pthread_set_name_np(pthread_t, const char*)',\n                dependencies : thread_dep)\n    # FreeBSD, DragonFlyBSD, OpenBSD, etc.\n    glib_conf.set('HAVE_PTHREAD_SET_NAME_NP', 1)\n  endif\nendif\n\n# FIXME: we should make it print the result and always return 0, so that\n# the output in meson shows up as green\nstack_grows_check_prog = '''\n  volatile int *a = 0, *b = 0;\n  void f (int i) {\n    volatile int x = 5;\n    if (i == 0)\n      b = &x;\n    else\n      f (i - 1);\n  }\n  int main () {\n    volatile int y = 7;\n    a = &y;\n    f (100);\n    return b > a ? 0 : 1;\n  }'''\n\nif cc_can_run\n  rres = cc.run(stack_grows_check_prog, name : 'stack grows check')\n  growing_stack = rres.returncode() == 0\nelse\n  growing_stack = meson.get_cross_property('growing_stack', false)\nendif\n\nglibconfig_conf.set10('G_HAVE_GROWING_STACK', growing_stack)\n\n# Tests for iconv\n#\n# We should never use the MinGW C library's iconv because it may not be\n# available in the actual runtime environment. On Windows, we always use\n# the built-in implementation\niconv_opt = get_option('iconv')\nif host_system == 'windows'\n  libiconv = []\n  # We have a #include \"win_iconv.c\" in gconvert.c on Windows, so we don't need\n  # any external library for it\n  if iconv_opt != 'auto'\n    warning('-Diconv was set to @0@, which was ignored')\n  endif\nelse\n  found_iconv = false\n  if ['auto', 'libc'].contains(iconv_opt) and cc.has_function('iconv_open')\n    libiconv = []\n    found_iconv = true\n  endif\n  if not found_iconv and ['auto', 'external'].contains(iconv_opt) and cc.has_header_symbol('iconv.h', 'iconv_open')\n    libiconv = [cc.find_library('iconv')]\n    found_iconv = true\n  endif\n\n  if not found_iconv\n    error('iconv implementation \"@0@\" not found'.format(iconv_opt))\n  endif\nendif\n\nif get_option('internal_pcre')\n  pcre = []\n  use_system_pcre = false\nelse\n  pcre = dependency('libpcre', version: '>= 8.31', required : false) # Should check for Unicode support, too. FIXME\n  if not pcre.found()\n    if cc.get_id() == 'msvc' or cc.get_id() == 'clang-cl'\n    # MSVC: Search for the PCRE library by the configuration, which corresponds\n    # to the output of CMake builds of PCRE.  Note that debugoptimized\n    # is really a Release build with .PDB files.\n      if buildtype == 'debug'\n        pcre = cc.find_library('pcred', required : false)\n      else\n        pcre = cc.find_library('pcre', required : false)\n      endif\n    endif\n  endif\n  use_system_pcre = pcre.found()\nendif\nglib_conf.set('USE_SYSTEM_PCRE', use_system_pcre)\n\nuse_pcre_static_flag = false\n\nif host_system == 'windows'\n  if not use_system_pcre\n    use_pcre_static_flag = true\n  else\n    pcre_static = cc.links('''#define PCRE_STATIC\n                              #include <pcre.h>\n                              int main() {\n                                void *p = NULL;\n                                pcre_free(p);\n                                return 0;\n                              }''',\n                           dependencies: pcre,\n                           name : 'Windows system PCRE is a static build')\n    if pcre_static\n      use_pcre_static_flag = true\n    endif\n  endif\nendif\n\nlibm = cc.find_library('m', required : false)\nlibffi_dep = dependency('libffi', version : '>= 3.0.0', fallback : ['libffi', 'ffi_dep'])\n\n# Don't use the bundled ZLib sources until we are sure that we can't find it on\n# the system\nlibz_dep = dependency('zlib', required : false)\nif not libz_dep.found()\n  if cc.get_id() != 'msvc' and cc.get_id() != 'clang-cl'\n    libz_dep = cc.find_library('z', required : false)\n  else\n    libz_dep = cc.find_library('zlib1', required : false)\n    if not libz_dep.found()\n      libz_dep = cc.find_library('zlib', required : false)\n    endif\n  endif\n  if not libz_dep.found() or not cc.has_header('zlib.h')\n    libz_dep = subproject('zlib').get_variable('zlib_dep')\n  endif\nendif\n\n# First check in libc, fallback to libintl, and as last chance build\n# proxy-libintl subproject.\n# FIXME: glib-gettext.m4 has much more checks to detect broken/uncompatible\n# implementations. This could be extended if issues are found in some platforms.\nif cc.has_function('ngettext')\n  libintl = []\n  have_bind_textdomain_codeset = cc.has_function('bind_textdomain_codeset')\nelse\n  libintl = cc.find_library('intl', required : false)\n  if not libintl.found()\n    libintl = subproject('proxy-libintl').get_variable('intl_dep')\n    have_bind_textdomain_codeset = true  # proxy-libintl supports it\n  else\n    have_bind_textdomain_codeset = cc.has_function('bind_textdomain_codeset',\n                                                   dependencies : libintl)\n  endif\nendif\n\nglib_conf.set('HAVE_BIND_TEXTDOMAIN_CODESET', have_bind_textdomain_codeset)\n\n# We require gettext to always be present\nglib_conf.set('HAVE_DCGETTEXT', 1)\nglib_conf.set('HAVE_GETTEXT', 1)\n\nglib_conf.set_quoted('GLIB_LOCALE_DIR', join_paths(glib_datadir, 'locale'))\n\n# libmount is only used by gio, but we need to fetch the libs to generate the\n# pkg-config file below\nlibmount_dep = []\nif host_system == 'linux'\n  libmount_dep = dependency('mount', version : '>=2.23', required : get_option('libmount'))\n  glib_conf.set('HAVE_LIBMOUNT', libmount_dep.found())\nendif\n\nif host_system == 'windows'\n  winsock2 = cc.find_library('ws2_32')\nendif\n\nselinux_dep = []\nif host_system == 'linux'\n  selinux_dep = dependency('libselinux', required: get_option('selinux'))\n\n  glib_conf.set('HAVE_SELINUX', selinux_dep.found())\nendif\n\nxattr_dep = []\nif host_system != 'windows' and get_option('xattr')\n  # either glibc or libattr can provide xattr support\n  # for both of them, we check for getxattr being in\n  # the library and a valid xattr header.\n\n  # try glibc\n  if cc.has_function('getxattr') and cc.has_header('sys/xattr.h')\n    glib_conf.set('HAVE_SYS_XATTR_H', 1)\n    glib_conf_prefix = glib_conf_prefix + '#define @0@ 1\\n'.format('HAVE_SYS_XATTR_H')\n  #failure. try libattr\n  elif cc.has_header_symbol('attr/xattr.h', 'getxattr')\n    glib_conf.set('HAVE_ATTR_XATTR_H', 1)\n    glib_conf_prefix = glib_conf_prefix + '#define @0@ 1\\n'.format('HAVE_ATTR_XATTR_H')\n    xattr_dep = [cc.find_library('xattr')]\n  else\n    error('No getxattr implementation found in C library or libxattr')\n  endif\n\n  glib_conf.set('HAVE_XATTR', 1)\n  if cc.compiles(glib_conf_prefix + '''\n                 #include <stdio.h>\n                 #ifdef HAVE_SYS_TYPES_H\n                 #include <sys/types.h>\n                 #endif\n                 #ifdef HAVE_SYS_XATTR_H\n                 #include <sys/xattr.h>\n                 #elif HAVE_ATTR_XATTR_H\n                 #include <attr/xattr.h>\n                 #endif\n\n                 int main (void) {\n                   ssize_t len = getxattr(\"\", \"\", NULL, 0, 0, XATTR_NOFOLLOW);\n                   return len;\n                 }''',\n                 name : 'XATTR_NOFOLLOW')\n    glib_conf.set('HAVE_XATTR_NOFOLLOW', 1)\n  endif\nendif\n\n# If strlcpy is present (BSD and similar), check that it conforms to the BSD\n# specification. Specifically Solaris 8's strlcpy() does not, see\n# https://bugzilla.gnome.org/show_bug.cgi?id=53933 for further context.\nif cc.has_function('strlcpy')\n  if cc_can_run\n    rres = cc.run('''#include <stdlib.h>\n                    #include <string.h>\n                    int main() {\n                      char p[10];\n                      (void) strlcpy (p, \"hi\", 10);\n                      if (strlcat (p, \"bye\", 0) != 3)\n                        return 1;\n                      return 0;\n                    }''',\n                  name : 'OpenBSD strlcpy/strlcat')\n    if rres.compiled() and rres.returncode() == 0\n      glib_conf.set('HAVE_STRLCPY', 1)\n    endif\n  elif meson.get_cross_property('have_strlcpy', false)\n    glib_conf.set('HAVE_STRLCPY', 1)\n  endif\nendif\n\ncmdline_test_code = '''\n#include <fcntl.h>\n#include <sys/stat.h>\n#include <stdio.h>\n#include <stdlib.h>\n#undef NDEBUG\n#include <assert.h>\n\nstatic int\n__getcmdline (void)\n{\n/* This code is a dumbed-down version of g_file_get_contents() */\n#ifndef O_BINARY\n#define O_BINARY 0\n#endif\n#define BUFSIZE 1024\n  char result[BUFSIZE];\n  struct stat stat_buf;\n\n  int fd = open (\"/proc/self/cmdline\", O_RDONLY|O_BINARY);\n  assert (fd >= 0);\n  assert (fstat (fd, &stat_buf) == 0);\n\n  if (stat_buf.st_size > 0 && S_ISREG (stat_buf.st_mode))\n    assert (read (fd, result, BUFSIZE) > 0);\n  else\n    {\n      FILE *f = fdopen (fd, \"r\");\n      assert (f != NULL);\n      assert (fread (result, 1, BUFSIZE, f) > 0);\n    }\n\n  return 0;\n}\n\nint\nmain (void)\n{\n  exit (__getcmdline ());\n}'''\n\nif cc_can_run\n  rres = cc.run(cmdline_test_code, name : '/proc/self/cmdline')\n  have_proc_self_cmdline = rres.compiled() and rres.returncode() == 0\nelse\n  have_proc_self_cmdline = meson.get_cross_property('have_proc_self_cmdline', false)\nendif\n\nglib_conf.set('HAVE_PROC_SELF_CMDLINE', have_proc_self_cmdline)\n\npython = import('python').find_installation('python3')\n# used for '#!/usr/bin/env <name>'\npython_name = 'python3'\n\npython_version = python.language_version()\npython_version_req = '>=3.5'\nif not python_version.version_compare(python_version_req)\n  error('Requires Python @0@, @1@ found.'.format(python_version_req, python_version))\nendif\n\n# Determine which user environment-dependent files that we want to install\nhave_bash = find_program('bash', required : false).found() # For completion scripts\nhave_sh = find_program('sh', required : false).found() # For glib-gettextize\n\n# Some installed tests require a custom environment\nenv_program = find_program('env', required: installed_tests_enabled)\n\n# FIXME: How to detect Solaris? https://github.com/mesonbuild/meson/issues/1578\nif host_system == 'sunos'\n  glib_conf.set('_XOPEN_SOURCE_EXTENDED', 1)\n  glib_conf.set('_XOPEN_SOURCE', 2)\n  glib_conf.set('__EXTENSIONS__',1)\nendif\n\n# Sadly Meson does not expose this value:\n# https://github.com/mesonbuild/meson/pull/3460\nif host_system == 'windows'\n  # Autotools explicitly removed --Wl,--export-all-symbols from windows builds,\n  # with no explanation. Do the same here for now but this could be revisited if\n  # if causes issues.\n  export_dynamic_ldflags = []\nelif host_system == 'cygwin'\n  export_dynamic_ldflags = ['-Wl,--export-all-symbols']\nelif host_system == 'darwin'\n  export_dynamic_ldflags = []\nelif host_system == 'sunos'\n  export_dynamic_ldflags = []\nelse\n  export_dynamic_ldflags = ['-Wl,--export-dynamic']\nendif\n\nwin32_cflags = []\nwin32_ldflags = []\nif host_system == 'windows' and cc.get_id() != 'msvc' and cc.get_id() != 'clang-cl'\n  # Ensure MSVC-compatible struct packing convention is used when\n  # compiling for Win32 with gcc. It is used for the whole project and exposed\n  # in glib-2.0.pc.\n  win32_cflags = ['-mms-bitfields']\n  add_project_arguments(win32_cflags, language : 'c')\n\n  # Win32 API libs, used only by libglib and exposed in glib-2.0.pc\n  win32_ldflags = ['-lws2_32', '-lole32', '-lwinmm', '-lshlwapi']\nelif host_system == 'cygwin'\n  win32_ldflags = ['-luser32', '-lkernel32']\nendif\n\n# Tracing: dtrace\nwant_dtrace = get_option('dtrace')\nenable_dtrace = false\n\n# Since dtrace support is opt-in we just error out if it was requested but\n# is not available. We don't bother with autodetection yet.\nif want_dtrace\n  if glib_have_carbon\n    error('GLib dtrace support not yet compatible with macOS dtrace')\n  endif\n  dtrace = find_program('dtrace', required : true) # error out if not found\n  if not cc.has_header('sys/sdt.h')\n    error('dtrace support needs sys/sdt.h header')\n  endif\n  # FIXME: autotools build also passes -fPIC -DPIC but is it needed in this case?\n  dtrace_obj_gen = generator(dtrace,\n    output : '@BASENAME@.o',\n    arguments : ['-G', '-s', '@INPUT@', '-o', '@OUTPUT@'])\n  # FIXME: $(SED) -e \"s,define STAP_HAS_SEMAPHORES 1,undef STAP_HAS_SEMAPHORES,\"\n  #               -e \"s,define _SDT_HAS_SEMAPHORES 1,undef _SDT_HAS_SEMAPHORES,\"\n  dtrace_hdr_gen = generator(dtrace,\n    output : '@BASENAME@.h',\n    arguments : ['-h', '-s', '@INPUT@', '-o', '@OUTPUT@'])\n  glib_conf.set('HAVE_DTRACE', 1)\n  enable_dtrace = true\nendif\n\n# systemtap\nwant_systemtap = get_option('systemtap')\nenable_systemtap = false\n\nif want_systemtap and enable_dtrace\n  tapset_install_dir = get_option('tapset_install_dir')\n  if tapset_install_dir == ''\n    tapset_install_dir = join_paths(get_option('datadir'), 'systemtap/tapset', host_machine.cpu_family())\n  endif\n  stp_cdata = configuration_data()\n  stp_cdata.set('ABS_GLIB_RUNTIME_LIBDIR', glib_libdir)\n  stp_cdata.set('LT_CURRENT', minor_version * 100)\n  stp_cdata.set('LT_REVISION', micro_version)\n  enable_systemtap = true\nendif\n\ntest_timeout = 60\ntest_timeout_slow = 180\n\npkg = import('pkgconfig')\nwindows = import('windows')\nsubdir('glib')\nsubdir('gobject')\nsubdir('gthread')\nsubdir('gmodule')\nsubdir('gio')\nsubdir('fuzzing')\nif build_tests\n  subdir('tests')\nendif\n\n# xgettext is optional (on Windows for instance)\nif find_program('xgettext', required : get_option('nls')).found()\n  subdir('po')\nendif\n\n# Install glib-gettextize executable, if a UNIX-style shell is found\nif have_sh\n  # These should not contain \" quotes around the values\n  gettextize_conf = configuration_data()\n  gettextize_conf.set('PACKAGE', 'glib')\n  gettextize_conf.set('VERSION', meson.project_version())\n  gettextize_conf.set('prefix', glib_prefix)\n  gettextize_conf.set('datarootdir', glib_datadir)\n  gettextize_conf.set('datadir', glib_datadir)\n  configure_file(input : 'glib-gettextize.in',\n    install_dir : glib_bindir,\n    output : 'glib-gettextize',\n    configuration : gettextize_conf)\nendif\n\n# Install m4 macros that other projects use\ninstall_data('m4macros/glib-2.0.m4', 'm4macros/glib-gettext.m4', 'm4macros/gsettings.m4',\n  install_dir : join_paths(get_option('datadir'), 'aclocal'))\n\nif host_system != 'windows'\n  # Install Valgrind suppression file (except on Windows,\n  # as Valgrind is currently not supported on Windows)\n  install_data('glib.supp',\n    install_dir : join_paths(get_option('datadir'), 'glib-2.0', 'valgrind'))\nendif\n\nconfigure_file(output : 'config.h', configuration : glib_conf)\n\nif host_system == 'windows'\n  install_headers([ 'msvc_recommended_pragmas.h' ], subdir : 'glib-2.0')\nendif\n\nif get_option('man')\n  xsltproc = find_program('xsltproc', required : true)\n  xsltproc_command = [\n    xsltproc,\n    '--nonet',\n    '--stringparam', 'man.output.quietly', '1',\n    '--stringparam', 'funcsynopsis.style', 'ansi',\n    '--stringparam', 'man.th.extra1.suppress', '1',\n    '--stringparam', 'man.authors.section.enabled', '0',\n    '--stringparam', 'man.copyright.section.enabled', '0',\n    '-o', '@OUTPUT@',\n    'http://docbook.sourceforge.net/release/xsl/current/manpages/docbook.xsl',\n    '@INPUT@',\n  ]\n  man1_dir = join_paths(glib_prefix, get_option('mandir'), 'man1')\nendif\n\ngnome = import('gnome')\nsubdir('docs/reference')\n",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.64.1-zay2ciepa5k35t7jfrw2hn5i52snsdx2/spack-src/gmodule/gmodule-ar.c": "/* GMODULE - GLIB wrapper code for dynamic module loading\n * Copyright (C) 1998, 2000 Tim Janik\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\t See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, see <http://www.gnu.org/licenses/>.\n */\n\n/* \n * MT safe\n */\n\n/* because we are compatible with archive format only since AIX 4.3 */\n\n#define __AR_BIG__\n\n#include \"config.h\"\n\n#include <ar.h>\n#include <stdlib.h>\n\n#include <dlfcn.h>\n\n/* --- functions --- */\nstatic gchar*\nfetch_dlerror (gboolean replace_null)\n{\n  gchar *msg = dlerror ();\n\n  /* make sure we always return an error message != NULL, if\n   * expected to do so. */\n\n  if (!msg && replace_null)\n    return \"unknown dl-error\";\n\n  return msg;\n}\n\nstatic gchar* _g_module_get_member(const gchar* file_name)\n{\n  gchar* member = NULL;\n  struct fl_hdr file_header;\n  struct ar_hdr ar_header;\n  long first_member;\n  long name_len;\n  int fd;\n\n  fd = open(file_name, O_RDONLY);\n  if (fd == -1)\n    return NULL;\n\n  if (read(fd, (void*)&file_header, FL_HSZ) != FL_HSZ)\n    goto exit;\n\n  if (strncmp(file_header.fl_magic, AIAMAGBIG, SAIAMAG) != 0)\n    goto exit;\n\n  /* read first archive file member header */\n\n  first_member = atol(file_header.fl_fstmoff);\n\n  if (lseek(fd, first_member, SEEK_SET) != first_member)\n    goto exit;\n\n  if (read(fd, (void*)&ar_header, AR_HSZ - 2) != AR_HSZ - 2)\n    goto exit;\n\n  /* read member name */\n\n  name_len = atol(ar_header.ar_namlen);\n\n  member = g_malloc(name_len+1);\n  if (!member)\n    goto exit;\n\n  if (read(fd, (void*)member, name_len) != name_len)\n    {\n      g_free(member);\n      member = NULL;\n      goto exit;\n    }\n\n  member[name_len] = 0;\n\nexit:\n  close(fd);\n\n  return member;\n}\n\nstatic gpointer\n_g_module_open (const gchar *file_name,\n\t\tgboolean     bind_lazy,\n\t\tgboolean     bind_local)\n{\n  gpointer handle;\n  gchar* member;\n  gchar* full_name;\n\n  /* extract name of first member of archive */\n\n  member = _g_module_get_member (file_name);\n  if (member != NULL)\n    {\n      full_name = g_strconcat (file_name, \"(\", member, \")\", NULL);\n      g_free (member);\n    }\n  else\n    full_name = g_strdup (file_name);\n  \n  handle = dlopen (full_name, \n\t\t   (bind_local ? RTLD_LOCAL : RTLD_GLOBAL) | RTLD_MEMBER | (bind_lazy ? RTLD_LAZY : RTLD_NOW));\n\n  g_free (full_name);\n\n  if (!handle)\n    g_module_set_error (fetch_dlerror (TRUE));\n  \n  return handle;\n}\n\nstatic gpointer\n_g_module_self (void)\n{\n  gpointer handle;\n\n  handle = dlopen (NULL, RTLD_GLOBAL | RTLD_LAZY);\n  if (!handle)\n    g_module_set_error (fetch_dlerror (TRUE));\n  \n  return handle;\n}\n\nstatic void\n_g_module_close (gpointer handle)\n{\n  if (dlclose (handle) != 0)\n    g_module_set_error (fetch_dlerror (TRUE));\n}\n\nstatic gpointer\n_g_module_symbol (gpointer     handle,\n\t\t  const gchar *symbol_name)\n{\n  gpointer p;\n  \n  p = dlsym (handle, symbol_name);\n  if (!p)\n    g_module_set_error (fetch_dlerror (FALSE));\n  \n  return p;\n}\n\nstatic gchar*\n_g_module_build_path (const gchar *directory,\n\t\t      const gchar *module_name)\n{\n  if (directory && *directory) {\n    if (strncmp (module_name, \"lib\", 3) == 0)\n      return g_strconcat (directory, \"/\", module_name, NULL);\n    else\n      return g_strconcat (directory, \"/lib\", module_name, \".\" G_MODULE_SUFFIX, NULL);\n  } else if (strncmp (module_name, \"lib\", 3) == 0)\n    return g_strdup (module_name);\n  else\n    return g_strconcat (\"lib\", module_name, \".\" G_MODULE_SUFFIX, NULL);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.64.1-zay2ciepa5k35t7jfrw2hn5i52snsdx2/spack-src/gmodule/meson.build": "gmoduleconf_conf = configuration_data()\n\ng_module_need_uscore = 0\ng_module_broken_rtld_global = 0\ng_module_have_dlerror = 0\n\ng_module_impl = ''\n\n# On Windows force native WIN32 shared lib loader\nif host_system == 'windows'\n  g_module_impl = 'G_MODULE_IMPL_WIN32'\n# Force native AIX library loader\n# dlopen() filepath must be of the form /path/libname.a(libname.so)\nelif host_system == 'aix'\n  g_module_impl = 'G_MODULE_IMPL_AR'\nelif have_dlopen_dlsym\n  g_module_impl = 'G_MODULE_IMPL_DL'\nendif\n\n# additional checks for G_MODULE_IMPL_DL\nif g_module_impl == 'G_MODULE_IMPL_DL'\n  # FIXME: check for OSF1/5.0 RTLD_GLOBAL brokenness (is this still relevant?)\n\n  # Check whether we need preceding underscores\n  if cc.get_id() == 'msvc' or cc.get_id() == 'clang-cl'\n    message('Building for MSVC: assuming that symbols are prefixed with underscore')\n    g_module_need_uscore = 1\n  elif meson.has_exe_wrapper()\n    # FIXME: communicate result via stdout instead of return value, so non-0 return is not printed in bold red\n    rres = cc.run(dlopen_dlsym_test_code,\n                  dependencies : libdl_dep,\n                  name : 'dlsym() preceding underscores')\n    if host_system == 'windows' or rres.returncode() == 0\n      g_module_need_uscore = 1\n    endif\n  else\n    message('Cross-compiling: assuming that symbols aren\\'t prefixed with underscore')\n    g_module_need_uscore = 0\n  endif\n\n  if cc.has_function('dlerror', dependencies : libdl_dep)\n    g_module_have_dlerror = 1\n  endif\nendif\n\n# Done, have we got an implementation?\nif g_module_impl == ''\n  g_module_impl = '0'\n  message('WARNING: No suitable GModule implementation found!')\nendif\n\ngmoduleconf_conf.set('G_MODULE_IMPL', g_module_impl)\ngmoduleconf_conf.set('G_MODULE_SUPPORTED', g_module_impl != '0')\ngmoduleconf_conf.set('G_MODULE_HAVE_DLERROR', g_module_have_dlerror)\ngmoduleconf_conf.set('G_MODULE_NEED_USCORE', g_module_need_uscore)\ngmoduleconf_conf.set('G_MODULE_BROKEN_RTLD_GLOBAL', g_module_broken_rtld_global)\n\ngmoduleconf_h = configure_file(input : 'gmoduleconf.h.in',\n                               output : 'gmoduleconf.h',\n                               configuration : gmoduleconf_conf)\n\ninstall_headers(['gmodule.h'], subdir : 'glib-2.0')\n\ngmodule_sources = ['gmodule.c']\nif host_system == 'windows'\n  gmodule_win_rc = configure_file(\n    input: 'gmodule.rc.in',\n    output: 'gmodule.rc',\n    configuration: glibconfig_conf,\n  )\n  gmodule_win_res = windows.compile_resources(gmodule_win_rc)\n  gmodule_sources += [gmodule_win_res]\nendif\n\nlibgmodule = library('gmodule-2.0',\n  sources : gmodule_sources,\n  version : library_version,\n  soversion : soversion,\n  darwin_versions : darwin_versions,\n  install : true,\n  include_directories : [configinc, gmoduleinc],\n  dependencies : [libdl_dep, libglib_dep],\n  c_args : ['-DG_LOG_DOMAIN=\"GModule\"'] + glib_hidden_visibility_args,\n  link_args : [glib_link_flags],\n)\n\nsupported_var = 'gmodule_supported=@0@'.format(g_module_impl != '0')\n\npkg.generate(libgmodule,\n  libraries : [thread_dep],\n  requires : ['glib-2.0'],\n  version : glib_version,\n  variables : [supported_var],\n  install_dir : glib_pkgconfigreldir,\n  filebase : 'gmodule-no-export-2.0',\n  name : 'GModule',\n  description : 'Dynamic module loader for GLib',\n)\n\npkg.generate(libraries : [libgmodule, export_dynamic_ldflags],\n  requires : ['glib-2.0'],\n  version : glib_version,\n  variables : [supported_var],\n  install_dir : glib_pkgconfigreldir,\n  filebase : 'gmodule-export-2.0',\n  name : 'GModule',\n  description : 'Dynamic module loader for GLib',\n)\n\npkg.generate(libraries : [libgmodule, export_dynamic_ldflags],\n  requires : ['glib-2.0'],\n  version : glib_version,\n  variables : [supported_var],\n  install_dir : glib_pkgconfigreldir,\n  filebase : 'gmodule-2.0',\n  name : 'GModule',\n  description : 'Dynamic module loader for GLib',\n)\n\nlibgmodule_dep = declare_dependency(link_with : libgmodule,\n  include_directories : [gmoduleinc],\n  dependencies : [libglib_dep])\n",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.64.1-zay2ciepa5k35t7jfrw2hn5i52snsdx2/spack-src/gmodule/gmodule-dl.c": "/* GMODULE - GLIB wrapper code for dynamic module loading\n * Copyright (C) 1998, 2000 Tim Janik\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\t See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, see <http://www.gnu.org/licenses/>.\n */\n\n/*\n * Modified by the GLib Team and others 1997-2000.  See the AUTHORS\n * file for a list of people on the GLib Team.  See the ChangeLog\n * files for a list of changes.  These files are distributed with\n * GLib at ftp://ftp.gtk.org/pub/gtk/. \n */\n\n/* \n * MT safe\n */\n#include \"config.h\"\n\n#include <dlfcn.h>\n\n/* Perl includes <nlist.h> and <link.h> instead of <dlfcn.h> on some systmes? */\n\n\n/* dlerror() is not implemented on all systems\n */\n#ifndef\tG_MODULE_HAVE_DLERROR\n#  ifdef __NetBSD__\n#    define dlerror()\tg_strerror (errno)\n#  else /* !__NetBSD__ */\n/* could we rely on errno's state here? */\n#    define dlerror()\t\"unknown dl-error\"\n#  endif /* !__NetBSD__ */\n#endif\t/* G_MODULE_HAVE_DLERROR */\n\n/* some flags are missing on some systems, so we provide\n * harmless defaults.\n * The Perl sources say, RTLD_LAZY needs to be defined as (1),\n * at least for Solaris 1.\n *\n * Mandatory:\n * RTLD_LAZY   - resolve undefined symbols as code from the dynamic library\n *\t\t is executed.\n * RTLD_NOW    - resolve all undefined symbols before dlopen returns, and fail\n *\t\t if this cannot be done.\n * Optionally:\n * RTLD_GLOBAL - the external symbols defined in the library will be made\n *\t\t available to subsequently loaded libraries.\n */\n#ifndef\tHAVE_RTLD_LAZY\n#define\tRTLD_LAZY\t1\n#endif\t/* RTLD_LAZY */\n#ifndef\tHAVE_RTLD_NOW\n#define\tRTLD_NOW\t0\n#endif\t/* RTLD_NOW */\n/* some systems (OSF1 V5.0) have broken RTLD_GLOBAL linkage */\n#ifdef G_MODULE_BROKEN_RTLD_GLOBAL\n#undef\tRTLD_GLOBAL\n#undef\tHAVE_RTLD_GLOBAL\n#endif /* G_MODULE_BROKEN_RTLD_GLOBAL */\n#ifndef\tHAVE_RTLD_GLOBAL\n#define\tRTLD_GLOBAL\t0\n#endif\t/* RTLD_GLOBAL */\n\n\n/* --- functions --- */\nstatic gchar*\nfetch_dlerror (gboolean replace_null)\n{\n  gchar *msg = dlerror ();\n\n  /* make sure we always return an error message != NULL, if\n   * expected to do so. */\n\n  if (!msg && replace_null)\n    return \"unknown dl-error\";\n\n  return msg;\n}\n\nstatic gpointer\n_g_module_open (const gchar *file_name,\n\t\tgboolean     bind_lazy,\n\t\tgboolean     bind_local)\n{\n  gpointer handle;\n  \n  handle = dlopen (file_name,\n\t\t   (bind_local ? 0 : RTLD_GLOBAL) | (bind_lazy ? RTLD_LAZY : RTLD_NOW));\n  if (!handle)\n    g_module_set_error (fetch_dlerror (TRUE));\n  \n  return handle;\n}\n\nstatic gpointer\n_g_module_self (void)\n{\n  gpointer handle;\n  \n  /* to query symbols from the program itself, special link options\n   * are required on some systems.\n   */\n\n  /* On Android 32 bit (i.e. not __LP64__), dlopen(NULL)\n   * does not work reliable and generally no symbols are found\n   * at all. RTLD_DEFAULT works though.\n   * On Android 64 bit, dlopen(NULL) seems to work but dlsym(handle)\n   * always returns 'undefined symbol'. Only if RTLD_DEFAULT or \n   * NULL is given, dlsym returns an appropriate pointer.\n   */\n#if defined(__BIONIC__)\n  handle = RTLD_DEFAULT;\n#else\n  handle = dlopen (NULL, RTLD_GLOBAL | RTLD_LAZY);\n#endif\n  if (!handle)\n    g_module_set_error (fetch_dlerror (TRUE));\n  \n  return handle;\n}\n\nstatic void\n_g_module_close (gpointer handle)\n{\n#if defined(__BIONIC__)\n  if (handle != RTLD_DEFAULT)\n#endif\n    {\n      if (dlclose (handle) != 0)\n\tg_module_set_error (fetch_dlerror (TRUE));\n    }\n}\n\nstatic gpointer\n_g_module_symbol (gpointer     handle,\n\t\t  const gchar *symbol_name)\n{\n  gpointer p;\n  gchar *msg;\n\n  fetch_dlerror (FALSE);\n  p = dlsym (handle, symbol_name);\n  msg = fetch_dlerror (FALSE);\n  if (msg)\n    g_module_set_error (msg);\n  \n  return p;\n}\n\nstatic gchar*\n_g_module_build_path (const gchar *directory,\n\t\t      const gchar *module_name)\n{\n  if (directory && *directory) {\n    if (strncmp (module_name, \"lib\", 3) == 0)\n      return g_strconcat (directory, \"/\", module_name, NULL);\n    else\n      return g_strconcat (directory, \"/lib\", module_name, \".\" G_MODULE_SUFFIX, NULL);\n  } else if (strncmp (module_name, \"lib\", 3) == 0)\n    return g_strdup (module_name);\n  else\n    return g_strconcat (\"lib\", module_name, \".\" G_MODULE_SUFFIX, NULL);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.64.1-zay2ciepa5k35t7jfrw2hn5i52snsdx2/spack-src/glib/tests/getpwuid-preload.c": "/* GLIB - Library of useful routines for C programming\n *\n * Copyright (C) 2020 Red Hat, Inc.\n *\n * Author: Jakub Jelen <jjelen@redhat.com>\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General\n * Public License along with this library; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <dlfcn.h>\n#include <pwd.h>\n#include <sys/types.h>\n#include <unistd.h>\n\nstatic struct passwd my_pw;\n\n/* This is used in gutils.c used to make sure utility functions\n * handling user information do not crash on bad data (for example\n * caused by getpwuid returning some NULL elements.\n */\nstruct passwd *\ngetpwuid (uid_t uid)\n{\n  static struct passwd *(*real_getpwuid) (uid_t);\n  struct passwd *pw;\n\n  if (real_getpwuid == NULL)\n    real_getpwuid = dlsym (RTLD_NEXT, \"getpwuid\");\n\n  pw = real_getpwuid (uid);\n  my_pw = *pw;\n  my_pw.pw_name = NULL;\n  return &my_pw;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.64.1-zay2ciepa5k35t7jfrw2hn5i52snsdx2/spack-src/gio/tests/slow-connect-preload.c": "/* GIO - GLib Input, Output and Streaming Library\n *\n * Copyright (C) 2018 Igalia S.L.\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General\n * Public License along with this library; if not, see <http://www.gnu.org/licenses/>.\n */\n\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <stdio.h>\n#include <dlfcn.h>\n\n/* This is used in gsocketclient-slow.c used to test\n * and get coverage on how GSocketClient reacts to\n * slow connections.\n */\nint\nconnect (int                    sockfd,\n         const struct sockaddr *addr,\n         socklen_t              addrlen)\n{\n  static int (*real_connect)(int, const struct sockaddr *, socklen_t);\n\n  if (real_connect == NULL)\n    real_connect = dlsym (RTLD_NEXT, \"connect\");\n\n  /* This is long enough for multiple connection attempts to be done\n   * in parallel given that their timeout is 250ms */\n  usleep (600 * 1000);\n  return real_connect (sockfd, addr, addrlen);\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.64.1-zay2ciepa5k35t7jfrw2hn5i52snsdx2/spack-src/tests/utf8.txt",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.64.1-zay2ciepa5k35t7jfrw2hn5i52snsdx2/spack-src/glib/tests/markups/fail-41.gmarkup",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.64.1-zay2ciepa5k35t7jfrw2hn5i52snsdx2/spack-src/glib/tests/markups/fail-3.expected",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.64.1-zay2ciepa5k35t7jfrw2hn5i52snsdx2/spack-src/glib/tests/markups/fail-2.gmarkup",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.64.1-zay2ciepa5k35t7jfrw2hn5i52snsdx2/spack-src/glib/tests/markups/fail-52.gmarkup",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.64.1-zay2ciepa5k35t7jfrw2hn5i52snsdx2/spack-src/glib/tests/markups/fail-41.expected",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.64.1-zay2ciepa5k35t7jfrw2hn5i52snsdx2/spack-src/glib/tests/markups/fail-50.gmarkup",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.64.1-zay2ciepa5k35t7jfrw2hn5i52snsdx2/spack-src/glib/tests/markups/fail-3.gmarkup",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.64.1-zay2ciepa5k35t7jfrw2hn5i52snsdx2/spack-src/glib/tests/markups/fail-53.gmarkup",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.64.1-zay2ciepa5k35t7jfrw2hn5i52snsdx2/spack-src/gio/tests/thumbnails/empty-key.png",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.64.1-zay2ciepa5k35t7jfrw2hn5i52snsdx2/spack-src/gio/tests/thumbnails/bad-header.png",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.64.1-zay2ciepa5k35t7jfrw2hn5i52snsdx2/spack-src/gio/tests/thumbnails/uri-mismatch.png",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.64.1-zay2ciepa5k35t7jfrw2hn5i52snsdx2/spack-src/gio/tests/thumbnails/huge-chunk-size.png",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.64.1-zay2ciepa5k35t7jfrw2hn5i52snsdx2/spack-src/gio/tests/thumbnails/valid-no-size.png",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.64.1-zay2ciepa5k35t7jfrw2hn5i52snsdx2/spack-src/gio/tests/thumbnails/no-text-data.png",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.64.1-zay2ciepa5k35t7jfrw2hn5i52snsdx2/spack-src/gio/tests/thumbnails/header-only.png",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.64.1-zay2ciepa5k35t7jfrw2hn5i52snsdx2/spack-src/gio/tests/thumbnails/mtime-zero.png",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.64.1-zay2ciepa5k35t7jfrw2hn5i52snsdx2/spack-src/gio/tests/thumbnails/valid.png",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.64.1-zay2ciepa5k35t7jfrw2hn5i52snsdx2/spack-src/gio/tests/thumbnails/header-and-chunk-size.png",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.64.1-zay2ciepa5k35t7jfrw2hn5i52snsdx2/spack-src/gio/tests/thumbnails/overlong-value.png",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.64.1-zay2ciepa5k35t7jfrw2hn5i52snsdx2/spack-src/docs/reference/glib/mainloop-states.png",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.64.1-zay2ciepa5k35t7jfrw2hn5i52snsdx2/spack-src/docs/reference/glib/mainloop-states.gif",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.64.1-zay2ciepa5k35t7jfrw2hn5i52snsdx2/spack-src/docs/reference/glib/file-name-encodings.sxd",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.64.1-zay2ciepa5k35t7jfrw2hn5i52snsdx2/spack-src/docs/reference/glib/file-name-encodings.png",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.64.1-zay2ciepa5k35t7jfrw2hn5i52snsdx2/spack-src/docs/reference/gio/menu-model.png",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.64.1-zay2ciepa5k35t7jfrw2hn5i52snsdx2/spack-src/docs/reference/gio/menu-example.png",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.64.1-zay2ciepa5k35t7jfrw2hn5i52snsdx2/spack-src/docs/reference/gio/gvfs-overview.odg",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.64.1-zay2ciepa5k35t7jfrw2hn5i52snsdx2/spack-src/docs/reference/gio/gvfs-overview.png",
        "/tmp/vanessa/spack-stage/spack-stage-glib-2.64.1-zay2ciepa5k35t7jfrw2hn5i52snsdx2/spack-src/docs/reference/gobject/images/glue.png"
    ],
    "total_files": 1934
}