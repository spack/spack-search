{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-legion-17.02.0-4s75mta4eowlznamyr2cbsdl2tuvjeyx/spack-src/runtime/realm/codedesc.cc": "/* Copyright 2017 Stanford University, NVIDIA Corporation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// constructs for describing code blobs to Realm\n\n#include \"codedesc.h\"\n\n#include <dlfcn.h>\n\n#include \"logging.h\"\n#include \"utils.h\"\n\nnamespace Realm {\n\n  Logger log_codetrans(\"codetrans\");\n\n\n  ////////////////////////////////////////////////////////////////////////\n  //\n  // class Type\n\n  std::ostream& operator<<(std::ostream& os, const Type& t)\n  {\n    switch(t.f_common.kind) {\n    case Type::InvalidKind: os << \"INVALIDTYPE\"; break;\n    case Type::OpaqueKind:\n      {\n\tif(t.size_bits() == 0)\n\t  os << \"void\";\n\telse\n\t  os << \"opaque(\" << t.size_bits() << \")\";\n\tbreak;\n      }\n    case Type::IntegerKind:\n      {\n\tos << (t.f_integer.is_signed ? 's' : 'u') << \"int(\" << t.size_bits() << \")\";\n\tbreak;\n      }\n    case Type::FloatingPointKind: os << \"float(\" << t.size_bits() << \")\"; break;\n    case Type::PointerKind:\n      {\n\tos << *t.f_pointer.base_type;\n\tif(t.f_pointer.is_const) os << \" const\";\n\tos << \" *\";\n\tbreak;\n      }\n    case Type::FunctionPointerKind:\n      {\n\tos << *t.f_funcptr.return_type << \"(*)(\";\n\tconst std::vector<Type>& p = *t.f_funcptr.param_types;\n\tif(p.size()) {\n\t  for(size_t i = 0; i < p.size(); i++) {\n\t    if(i) os << \", \";\n\t    os << p[i];\n\t  }\n\t} else\n\t  os << \"void\";\n\tos << \")\";\n\tbreak;\n      }\n    }\n    return os;\n  }\n\n\n  ////////////////////////////////////////////////////////////////////////\n  //\n  // class CodeDescriptor\n\n  CodeDescriptor::CodeDescriptor(void)\n  {}\n\n  CodeDescriptor::CodeDescriptor(const Type& _t)\n    : m_type(_t)\n  {}\n\n  CodeDescriptor::CodeDescriptor(const CodeDescriptor& rhs)\n  {\n    copy_from(rhs);\n  }\n\n  CodeDescriptor& CodeDescriptor::operator=(const CodeDescriptor& rhs)\n  {\n    if(this != &rhs) {\n      clear();\n      copy_from(rhs);\n    }\n    return *this;\n  }\n\n  CodeDescriptor::~CodeDescriptor(void)\n  {\n    clear();\n  }\n\n  void CodeDescriptor::clear(void)\n  {\n    m_type = Type();\n    delete_container_contents(m_impls);\n    delete_container_contents(m_props);\n  }\n\n  void CodeDescriptor::copy_from(const CodeDescriptor& rhs)\n  {\n    m_type = rhs.m_type;\n    {\n      size_t s = rhs.m_impls.size();\n      m_impls.resize(s);\n      for(size_t i = 0; i < s; i++)\n\tm_impls[i] = rhs.m_impls[i]->clone();\n    }\n    {\n      size_t s = rhs.m_props.size();\n      m_props.resize(s);\n      for(size_t i = 0; i < s; i++)\n\tm_props[i] = rhs.m_props[i]->clone();\n    }\n  }\n\n  // are any of the code implementations marked as \"portable\" (i.e.\n  //  usable in another process/address space)?\n  bool CodeDescriptor::has_portable_implementations(void) const\n  {\n    for(std::vector<CodeImplementation *>::const_iterator it = m_impls.begin();\n\tit != m_impls.end();\n\tit++)\n      if((*it)->is_portable())\n\treturn true;\n    return false;\n  }\n\n\n  ////////////////////////////////////////////////////////////////////////\n  //\n  // class FunctionPointerImplementation\n\n  /*static*/ Serialization::PolymorphicSerdezSubclass<CodeImplementation,\n\t\t\t\t\t\t      FunctionPointerImplementation> FunctionPointerImplementation::serdez_subclass;\n\n  FunctionPointerImplementation::FunctionPointerImplementation(void)\n    : fnptr(0)\n  {}\n\n  FunctionPointerImplementation::FunctionPointerImplementation(void (*_fnptr)())\n    : fnptr(_fnptr)\n  {}\n\n  FunctionPointerImplementation::~FunctionPointerImplementation(void)\n  {}\n\n  CodeImplementation *FunctionPointerImplementation::clone(void) const\n  {\n    return new FunctionPointerImplementation(fnptr);\n  }\n\n  bool FunctionPointerImplementation::is_portable(void) const\n  {\n    return false;\n  }\n\n\n#ifdef REALM_USE_DLFCN\n  ////////////////////////////////////////////////////////////////////////\n  //\n  // class DSOReferenceImplementation\n\n  /*static*/ Serialization::PolymorphicSerdezSubclass<CodeImplementation,\n\t\t\t\t\t\t      DSOReferenceImplementation> DSOReferenceImplementation::serdez_subclass;\n\n  DSOReferenceImplementation::DSOReferenceImplementation(void)\n  {}\n\n  DSOReferenceImplementation::DSOReferenceImplementation(const std::string& _dso_name,\n\t\t\t\t\t\t\t const std::string& _symbol_name)\n    : dso_name(_dso_name), symbol_name(_symbol_name)\n  {}\n\n  DSOReferenceImplementation::~DSOReferenceImplementation(void)\n  {}\n\n  CodeImplementation *DSOReferenceImplementation::clone(void) const\n  {\n    return new DSOReferenceImplementation(dso_name, symbol_name);\n  }\n\n  bool DSOReferenceImplementation::is_portable(void) const\n  {\n    return true;\n  }\n\n#ifdef REALM_USE_DLADDR\n  namespace {\n    extern \"C\" { int main(int argc, const char *argv[]) __attribute__((weak)); };\n\n    DSOReferenceImplementation *dladdr_helper(void *ptr, bool quiet)\n    {\n      // if dladdr() gives us something with the same base pointer, assume that's portable\n      // note: return code is not-POSIX-y (i.e. 0 == failure)\n      Dl_info inf;\n      int ret = dladdr(ptr, &inf);\n      if(ret == 0) {\n\tif(!quiet)\n\t  log_codetrans.warning() << \"couldn't map fnptr \" << ptr << \" to a dynamic symbol\";\n\treturn 0;\n      }\n\n      if(inf.dli_saddr != ptr) {\n\tif(!quiet)\n\t  log_codetrans.warning() << \"pointer \" << ptr << \" in middle of symbol '\" << inf.dli_sname << \" (\" << inf.dli_saddr << \")?\";\n\treturn 0;\n      }\n\n      // try to detect symbols that are in the base executable and change the filename to \"\"\n      // only do this if the weak 'main' reference found an actual main\n      if(((void *)main) != 0) {\n\tconst char *fname = inf.dli_fname;\n\t{\n\t  static std::string local_fname;\n\t  if(local_fname.empty()) {\n\t    Dl_info inf2;\n\t    ret = dladdr((void *)main, &inf2);\n\t    assert(ret != 0);\n\t    local_fname = inf2.dli_fname;\n\t  }\n\t  if(local_fname.compare(fname) == 0)\n\t    fname = \"\";\n\t}\n\n\treturn new DSOReferenceImplementation(fname, inf.dli_sname);\n      }\n\n      return 0;\n    }\n  };\n#endif\n\n  /*static*/ DSOReferenceImplementation *DSOReferenceImplementation::cvt_fnptr_to_dsoref(const FunctionPointerImplementation *fpi,\n\t\t\t\t\t\t\t\t\t\t\t bool quiet /*= false*/)\n  {\n    return dladdr_helper((void *)(fpi->fnptr), quiet);\n  } \n#endif\n\n\n  ////////////////////////////////////////////////////////////////////////\n  //\n  // class CodeTranslator\n\n  CodeTranslator::CodeTranslator(const std::string& _name)\n    : name(_name)\n  {}\n\n  CodeTranslator::~CodeTranslator(void)\n  {}\n\n  // default version just iterates over all the implementations in the source\n  bool CodeTranslator::can_translate(const CodeDescriptor& source_codedesc,\n\t\t\t\t     const std::type_info& target_impl_type)\n  {\n    const std::vector<CodeImplementation *>& impls = source_codedesc.implementations();\n    for(std::vector<CodeImplementation *>::const_iterator it = impls.begin();\n\tit != impls.end();\n\tit++) {\n      CodeImplementation &impl = **it;\n      if(can_translate(typeid(impl), target_impl_type))\n\treturn true;\n    }\n\n    return false;\n  }\n\n  // default version just iterates over all the implementations in the source\n  CodeImplementation *CodeTranslator::translate(const CodeDescriptor& source_codedesc,\n\t\t\t\t\t\tconst std::type_info& target_impl_type)\n  {\n    const std::vector<CodeImplementation *>& impls = source_codedesc.implementations();\n    for(std::vector<CodeImplementation *>::const_iterator it = impls.begin();\n\tit != impls.end();\n\tit++) {\n      CodeImplementation &impl = **it;\n      if(can_translate(typeid(impl), target_impl_type))\n\treturn translate(*it, target_impl_type);\n    }\n\n    return 0;\n  }\n\n\n  ////////////////////////////////////////////////////////////////////////\n  //\n  // class DSOCodeTranslator\n\n#ifdef REALM_USE_DLFCN\n  DSOCodeTranslator::DSOCodeTranslator(void)\n    : CodeTranslator(\"dso\")\n  {}\n\n  DSOCodeTranslator::~DSOCodeTranslator(void)\n  {\n    // unload any modules we have loaded\n    for(std::map<std::string, void *>::iterator it = modules_loaded.begin();\n\tit != modules_loaded.end();\n\tit++) {\n      int ret = dlclose(it->second);\n      if(ret != 0)\n\tlog_codetrans.warning() << \"error on dlclose of '\" << it->first << \"': \" << dlerror();\n    }\n  }\n\n  bool DSOCodeTranslator::can_translate(const std::type_info& source_impl_type,\n\t\t\t\t\t   const std::type_info& target_impl_type)\n  {\n    // DSO ref -> function pointer\n    if((source_impl_type == typeid(DSOReferenceImplementation)) &&\n       (target_impl_type == typeid(FunctionPointerImplementation)))\n      return true;\n\n#ifdef REALM_USE_DLADDR\n    if((source_impl_type == typeid(FunctionPointerImplementation)) &&\n       (target_impl_type == typeid(DSOReferenceImplementation)))\n      return true;\n#endif\n\n      return false;\n    }\n\n  CodeImplementation *DSOCodeTranslator::translate(const CodeImplementation *source,\n\t\t\t\t\t\t   const std::type_info& target_impl_type)\n  {\n    if(target_impl_type == typeid(FunctionPointerImplementation)) {\n      const DSOReferenceImplementation *dsoref = dynamic_cast<const DSOReferenceImplementation *>(source);\n      assert(dsoref != 0);\n\n      void *handle = 0;\n      // check to see if we've already loaded the module?\n      std::map<std::string, void *>::iterator it = modules_loaded.find(dsoref->dso_name);\n      if(it != modules_loaded.end()) {\n\thandle = it->second;\n      } else {\n\t// try to load it - empty string for dso_name means the main executable\n\tconst char *dso_name = dsoref->dso_name.c_str();\n\thandle = dlopen(*dso_name ? dso_name : 0, RTLD_NOW | RTLD_LOCAL);\n\tif(!handle) {\n\t  log_codetrans.warning() << \"could not open DSO '\" << dsoref->dso_name << \"': \" << dlerror();\n\t  return 0;\n\t}\n\tmodules_loaded[dsoref->dso_name] = handle;\n      }\n\n      void *ptr = dlsym(handle, dsoref->symbol_name.c_str());\n      if(!ptr) {\n\tlog_codetrans.warning() << \"could not find symbol '\" << dsoref->symbol_name << \"' in  DSO '\" << dsoref->dso_name << \"': \" << dlerror();\n\treturn 0;\n      }\n\n      return new FunctionPointerImplementation((void(*)())ptr);\n    }\n\n#ifdef REALM_USE_DLADDR\n    if(target_impl_type == typeid(DSOReferenceImplementation)) {\n      const FunctionPointerImplementation *fpi = dynamic_cast<const FunctionPointerImplementation *>(source);\n      assert(fpi != 0);\n\n      return dladdr_helper((void *)(fpi->fnptr), false /*!quiet*/);\n    }\n#endif\n\n    return 0;\n  }\n#endif\n\n\n};\n",
        "/tmp/vanessa/spack-stage/spack-stage-legion-17.02.0-4s75mta4eowlznamyr2cbsdl2tuvjeyx/spack-src/runtime/realm/module.cc": "/* Copyright 2017 Stanford University, NVIDIA Corporation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n// Realm modules\n\n#include \"realm_config.h\"\n\n#define REALM_MODULE_REGISTRATION_STATIC\n#include \"module.h\"\n\n#include \"logging.h\"\n\n#include <assert.h>\n#include <string.h>\n#include <stdlib.h>\n\n#ifdef REALM_USE_DLFCN\n#include <dlfcn.h>\n#endif\n\n// TODO: replace this with Makefile (or maybe cmake) magic that adapts automatically\n//  to the build-system-controlled list of statically-linked Realm modules\n#include \"realm/runtime_impl.h\"\n#include \"realm/numa/numa_module.h\"\n#include \"realm/procset/procset_module.h\"\n#ifdef USE_CUDA\n#include \"realm/cuda/cuda_module.h\"\n#endif\n#ifdef REALM_USE_LLVM\n#include \"realm/llvmjit/llvmjit_module.h\"\n#endif\n#ifdef USE_HDF\n#include \"realm/hdf5/hdf5_module.h\"\n#endif\n\nnamespace Realm {\n\n  Logger log_module(\"module\");\n\n  \n  ////////////////////////////////////////////////////////////////////////\n  //\n  // class Module\n  //\n\n  Module::Module(const std::string& _name)\n    : name(_name)\n  {\n    log_module.debug() << \"module \" << name << \" created\";\n  }\n\n  Module::~Module(void)\n  {\n    log_module.debug() << \"module \" << name << \" destroyed\";\n  }\n\n  const std::string& Module::get_name(void) const\n  {\n    return name;\n  }\n\n  void Module::initialize(RuntimeImpl *runtime)\n  {\n    log_module.debug() << \"module \" << name << \" initialize\";\n  }\n\n  void Module::create_memories(RuntimeImpl *runtime)\n  {\n    log_module.debug() << \"module \" << name << \" create_memories\";\n  }\n\n  void Module::create_processors(RuntimeImpl *runtime)\n  {\n    log_module.debug() << \"module \" << name << \" create_processors\";\n  }\n  \n  void Module::create_dma_channels(RuntimeImpl *runtime)\n  {\n    log_module.debug() << \"module \" << name << \" create_dma_channels\";\n  }\n  \n  void Module::create_code_translators(RuntimeImpl *runtime)\n  {\n    log_module.debug() << \"module \" << name << \" create_code_translators\";\n  }\n\n  void Module::cleanup(void)\n  {\n    log_module.debug() << \"module \" << name << \" cleanup\";\n  }\n\n\n  ////////////////////////////////////////////////////////////////////////\n  //\n  // class ModuleRegistrar\n  //\n\n  std::vector<const ModuleRegistrar::StaticRegistrationBase *>& static_module_registrations(void)\n  {\n    static std::vector<const ModuleRegistrar::StaticRegistrationBase *> data;\n    return data;\n  }\n\n  ModuleRegistrar::ModuleRegistrar(RuntimeImpl *_runtime)\n    : runtime(_runtime)\n  {}\n\n  // called by the runtime during init\n  void ModuleRegistrar::create_static_modules(std::vector<std::string>& cmdline,\n\t\t\t\t\t      std::vector<Module *>& modules)\n  {\n    // just iterate over the static module list, trying to create each module\n    for(std::vector<const StaticRegistrationBase *>::const_iterator it = static_module_registrations().begin();\n\tit != static_module_registrations().end();\n\tit++) {\n      Module *m = (*it)->create_module(runtime, cmdline);\n      if(m)\n\tmodules.push_back(m);\n    }\n  }\n\n\n#ifdef REALM_USE_DLFCN\n  // accepts a colon-separated list of so files to try to load\n  static void load_module_list(const char *sonames,\n\t\t\t       RuntimeImpl *runtime,\n\t\t\t       std::vector<std::string>& cmdline,\n\t\t\t       std::vector<void *>& handles,\n\t\t\t       std::vector<Module *>& modules)\n  {\n    // null/empty strings are nops\n    if(!sonames || !*sonames) return;\n\n    const char *p1 = sonames;\n    while(true) {\n      // skip leading colons\n      while(*p1 == ':') p1++;\n      if(!*p1) break;\n\n      const char *p2 = p1 + 1;\n      while(*p2 && (*p2 != ':')) p2++;\n\n      char filename[1024];\n      strncpy(filename, p1, p2 - p1);\n\n      // no leftover errors from anybody else please...\n      assert(dlerror() == 0);\n\n      // open so file, resolving all symbols but not polluting global namespace\n      void *handle = dlopen(filename, RTLD_NOW | RTLD_LOCAL);\n\n      if(handle != 0) {\n\t// this file should have a \"create_realm_module\" symbol\n\tvoid *sym = dlsym(handle, \"create_realm_module\");\n\n\tif(sym != 0) {\n\t  // TODO: hold onto the handle even if it doesn't create a module?\n\t  handles.push_back(handle);\n\n\t  Module *m = ((Module *(*)(RuntimeImpl *, std::vector<std::string>&))dlsym)(runtime, cmdline);\n\t  if(m)\n\t    modules.push_back(m);\n\t} else {\n\t  log_module.error() << \"symbol 'create_realm_module' not found in \" << filename;\n#ifndef NDEBUG\n\t  int ret =\n#endif\n\t    dlclose(handle);\n\t  assert(ret == 0);\n\t}\n      } else {\n\tlog_module.error() << \"could not load \" << filename << \": \" << dlerror();\n      }\n\n      if(!*p2) break;\n      p1 = p2 + 1;\n    }\n  }\n#endif\n\n  // called by the runtime during init\n  void ModuleRegistrar::create_dynamic_modules(std::vector<std::string>& cmdline,\n\t\t\t\t\t       std::vector<Module *>& modules)\n  {\n    // dynamic modules are requested in one of two ways:\n    // 1) REALM_DYNAMIC_MODULES=sonames environment variable\n    // 2) \"-ll:module sonames\" on command line\n    // in both cases, 'sonames' is a colon-separate listed of .so files that should be\n\n    // loading modules can also monkey with the cmdline, so do a pass first where we pull\n    //  out all the name we want to load\n    std::vector<std::string> sonames_list;\n\n    {\n      const char *e = getenv(\"REALM_DYNAMIC_MODULES\");\n      if(e)\n\tsonames_list.push_back(std::string(e));\n    }\n\n    {\n      std::vector<std::string>::iterator it = cmdline.begin();\n      while(it != cmdline.end()) {\n\tif(*it != \"-ll:module\") {\n\t  it++;\n\t  continue;\n\t}\n\n\t// eat this argument and move the next one to sonames_list\n\tit = cmdline.erase(it);\n\tassert(it != cmdline.end());\n\tsonames_list.push_back(*it);\n\tit = cmdline.erase(it);\n      }\n    }\n\n#ifdef REALM_USE_DLFCN\n    for(std::vector<std::string>::const_iterator it = sonames_list.begin();\n\tit != sonames_list.end();\n\tit++)\n      load_module_list(it->c_str(),\n\t\t       runtime, cmdline, sofile_handles, modules);\n#else\n    if(!sonames_list.empty()) {\n      log_module.error() << \"loading of dynamic Realm modules requested, but REALM_USE_DLFCN=0!\";\n      exit(1);\n    }\n#endif\n  }\n\n  // called by runtime after all modules have been cleaned up\n  void ModuleRegistrar::unload_module_sofiles(void)\n  {\n#ifdef REALM_USE_DLFCN\n    while(!sofile_handles.empty()) {\n      void *handle = sofile_handles.back();\n      sofile_handles.pop_back();\n\n#ifndef NDEBUG\n      int ret =\n#endif\n\tdlclose(handle);\n      assert(ret == 0);\n    }\n#endif\n  }\n\n  // called by the module registration helpers\n  /*static*/ void ModuleRegistrar::add_static_registration(const StaticRegistrationBase *reg)\n  {\n    // done during init, so single-threaded\n    static_module_registrations().push_back(reg);\n  }\n  \n}; // namespace Realm\n",
        "/tmp/vanessa/spack-stage/spack-stage-legion-17.02.0-4s75mta4eowlznamyr2cbsdl2tuvjeyx/spack-src/language/src/regent/cudahelper.t": "-- Copyright 2017 Stanford University\n--\n-- Licensed under the Apache License, Version 2.0 (the \"License\");\n-- you may not use this file except in compliance with the License.\n-- You may obtain a copy of the License at\n--\n--     http://www.apache.org/licenses/LICENSE-2.0\n--\n-- Unless required by applicable law or agreed to in writing, software\n-- distributed under the License is distributed on an \"AS IS\" BASIS,\n-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-- See the License for the specific language governing permissions and\n-- limitations under the License.\n\nlocal config = require(\"regent/config\")\nlocal report = require(\"common/report\")\n\nlocal cudahelper = {}\ncudahelper.check_cuda_available = function() return false end\n\nif not config.args()[\"cuda\"] or not terralib.cudacompile then\n  return cudahelper\nend\n\n-- copied and modified from cudalib.lua in Terra interpreter\n\nlocal ffi = require('ffi')\n\nlocal cudapaths = { OSX = \"/usr/local/cuda/lib/libcuda.dylib\";\n                    Linux =  \"libcuda.so\";\n                    Windows = \"nvcuda.dll\"; }\n\nlocal cudaruntimelinked = false\nfunction cudahelper.link_driver_library()\n    if cudaruntimelinked then return end\n    local path = assert(cudapaths[ffi.os],\"unknown OS?\")\n    terralib.linklibrary(path)\n    cudaruntimelinked = true\nend\n\n--\n\nlocal ef = terralib.externfunction\nlocal externcall_builtin = terralib.externfunction\n\nlocal RuntimeAPI = terralib.includec(\"cuda_runtime.h\")\nlocal HijackAPI = terralib.includec(\"legion_terra_cudart_hijack.h\")\n\nlocal C = terralib.includecstring [[\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n]]\n\nlocal terra assert(x : bool, message : rawstring)\n  if not x then\n    var stderr = C.fdopen(2, \"w\")\n    C.fprintf(stderr, \"assertion failed: %s\\n\", message)\n    -- Just because it's stderr doesn't mean it's unbuffered...\n    C.fflush(stderr)\n    C.abort()\n  end\nend\n\nlocal struct CUctx_st\nlocal struct CUmod_st\nlocal struct CUlinkState_st\nlocal struct CUfunc_st\nlocal CUdevice = int32\nlocal CUjit_option = uint32\nlocal CU_JIT_ERROR_LOG_BUFFER = 5\nlocal CU_JIT_ERROR_LOG_BUFFER_SIZE_BYTES = 6\nlocal CU_JIT_INPUT_PTX = 1\nlocal CU_JIT_TARGET = 9\nlocal DriverAPI = {\n  cuInit = ef(\"cuInit\", {uint32} -> uint32);\n  cuCtxGetCurrent = ef(\"cuCtxGetCurrent\", {&&CUctx_st} -> uint32);\n  cuCtxGetDevice = ef(\"cuCtxGetDevice\",{&int32} -> uint32);\n  cuDeviceGet = ef(\"cuDeviceGet\",{&int32,int32} -> uint32);\n  cuCtxCreate_v2 = ef(\"cuCtxCreate_v2\",{&&CUctx_st,uint32,int32} -> uint32);\n  cuDeviceComputeCapability = ef(\"cuDeviceComputeCapability\",\n    {&int32,&int32,int32} -> uint32);\n  cuLinkCreate_v2 = ef(\"cuLinkCreate_v2\",\n    {uint32,&uint32,&&opaque,&&CUlinkState_st} -> uint32);\n  cuLinkAddData_v2 = ef(\"cuLinkAddData_v2\",\n    {&CUlinkState_st,uint32,&opaque,uint64,&int8,uint32,&uint32,&&opaque} -> uint32);\n  cuLinkComplete = ef(\"cuLinkComplete\",\n    {&CUlinkState_st,&&opaque,&uint64} -> uint32);\n  cuLinkDestroy = ef(\"cuLinkDestroy\", {&CUlinkState_st} -> uint32);\n}\n\nlocal dlfcn = terralib.includec(\"dlfcn.h\")\nlocal terra has_symbol(symbol : rawstring)\n  var lib = dlfcn.dlopen([&int8](0), dlfcn.RTLD_LAZY)\n  var has_symbol = dlfcn.dlsym(lib, symbol) ~= [&opaque](0)\n  dlfcn.dlclose(lib)\n  return has_symbol\nend\n\ndo\n  if has_symbol(\"cuInit\") then\n    terra cudahelper.check_cuda_available()\n      var r = DriverAPI.cuInit(0)\n      return r == 0\n    end\n  else\n    terra cudahelper.check_cuda_available()\n      return false\n    end\n  end\nend\n\n-- copied and modified from cudalib.lua in Terra interpreter\n\nlocal terra init_cuda() : int32\n  var r = DriverAPI.cuInit(0)\n  assert(r == 0, \"CUDA error in cuInit\")\n  var cx : &CUctx_st\n  r = DriverAPI.cuCtxGetCurrent(&cx)\n  assert(r == 0, \"CUDA error in cuCtxGetCurrent\")\n  var d : int32\n  if cx ~= nil then\n    r = DriverAPI.cuCtxGetDevice(&d)\n    assert(r == 0, \"CUDA error in cuCtxGetDevice\")\n  else\n    r = DriverAPI.cuDeviceGet(&d, 0)\n    assert(r == 0, \"CUDA error in cuDeviceGet\")\n    r = DriverAPI.cuCtxCreate_v2(&cx, 0, d)\n    assert(r == 0, \"CUDA error in cuCtxCreate_v2\")\n  end\n\n  return d\nend\n\nlocal terra get_cuda_version(device : int) : uint64\n  var major : int, minor : int\n  var r = DriverAPI.cuDeviceComputeCapability(&major, &minor, device)\n  assert(r == 0, \"CUDA error in cuDeviceComputeCapability\")\n  return [uint64](major * 10 + minor)\nend\n\n--\n\nstruct fat_bin_t {\n  magic : int,\n  versions : int,\n  data : &opaque,\n  filename : &opaque,\n}\n\nlocal terra register_ptx(ptxc : rawstring, ptxSize : uint32, version : uint64) : &&opaque\n  var fat_bin : &fat_bin_t\n  -- TODO: this line is leaking memory\n  fat_bin = [&fat_bin_t](C.malloc(sizeof(fat_bin_t)))\n  fat_bin.magic = 1234\n  fat_bin.versions = 5678\n  fat_bin.data = C.malloc(ptxSize + 1)\n  fat_bin.data = ptxc\n  var handle = HijackAPI.hijackCudaRegisterFatBinary(fat_bin)\n  return handle\nend\n\nlocal terra register_function(handle : &&opaque, id : int, name : &int8)\n  HijackAPI.hijackCudaRegisterFunction(handle, [&int8](id), name)\nend\n\nfunction cudahelper.jit_compile_kernels_and_register(kernels)\n  local module = {}\n  for k, v in pairs(kernels) do\n    module[v.name] = v.kernel\n  end\n  local device = init_cuda()\n  local version = get_cuda_version(device)\n  local libdevice =\n    terralib.cudahome..\n    string.format(\"/nvvm/libdevice/libdevice.compute_%d.10.bc\",\n                  tonumber(version))\n  local llvmbc = terralib.linkllvm(libdevice)\n  externcall_builtin = function(name, ftype)\n    return llvmbc:extern(name, ftype)\n  end\n  local ptx = cudalib.toptx(module, nil, version)\n\n  local ptxc = terralib.constant(ptx)\n  local handle = terralib.newsymbol(&&opaque, \"handle\")\n  local register = quote\n    var [handle] = register_ptx(ptxc, [ptx:len() + 1], [version])\n  end\n\n  for k, v in pairs(kernels) do\n    register = quote\n      [register]\n      register_function([handle], [k], [v.name])\n    end\n  end\n\n  return register\nend\n\nfunction cudahelper.codegen_kernel_call(kernel_id, counts, args)\n  local setupArguments = terralib.newlist()\n\n  local offset = 0\n  for i = 1, #args do\n    local arg =  args[i]\n    local size = terralib.sizeof(arg.type)\n    setupArguments:insert(quote\n      RuntimeAPI.cudaSetupArgument(&[arg], size, offset)\n    end)\n    offset = offset + size\n  end\n\n  local grid = terralib.newsymbol(RuntimeAPI.dim3, \"grid\")\n  local block = terralib.newsymbol(RuntimeAPI.dim3, \"block\")\n  local launch_domain_init\n\n  local function round_exp(v, n)\n    return `((v + (n - 1)) / n)\n  end\n\n  -- TODO: Make this handle different thread block sizes and access strides\n  if #counts == 1 then\n    local threadSizeX = 128\n    launch_domain_init = quote\n      [grid].x, [grid].y, [grid].z =\n        [round_exp(counts[1], threadSizeX)], 1, 1\n      [block].x, [block].y, [block].z =\n        threadSizeX, 1, 1\n    end\n  elseif #counts == 2 then\n    local threadSizeX = 16\n    local threadSizeY = 16\n    launch_domain_init = quote\n      [grid].x, [grid].y, [grid].z =\n        [round_exp(counts[1], threadSizeX)],\n        [round_exp(counts[2], threadSizeY)], 1\n      [block].x, [block].y, [block].z =\n        [threadSizeX], [threadSizeY], 1\n    end\n  elseif #counts == 3 then\n    local threadSizeX = 16\n    local threadSizeY = 8\n    local threadSizeZ = 2\n    launch_domain_init = quote\n      [grid].x, [grid].y, [grid].z =\n        [round_exp(counts[1], threadSizeX)],\n        [round_exp(counts[2], threadSizeY)],\n        [round_exp(counts[3], threadSizeZ)]\n      [block].x, [block].y, [block].z =\n        [threadSizeX], [threadSizeY], [threadSizeZ]\n    end\n  else\n    assert(false, \"Indexspaces more than 3 dimensions are not supported\")\n  end\n\n  return quote\n    var [grid], [block]\n    [launch_domain_init]\n    RuntimeAPI.cudaConfigureCall([grid], [block], 0, nil)\n    [setupArguments]\n    RuntimeAPI.cudaLaunch([&int8](kernel_id))\n  end\nend\n\nlocal builtin_gpu_fns = {\n  acos  = externcall_builtin(\"__nv_acos\"  , double -> double),\n  asin  = externcall_builtin(\"__nv_asin\"  , double -> double),\n  atan  = externcall_builtin(\"__nv_atan\"  , double -> double),\n  cbrt  = externcall_builtin(\"__nv_cbrt\"  , double -> double),\n  ceil  = externcall_builtin(\"__nv_ceil\"  , double -> double),\n  cos   = externcall_builtin(\"__nv_cos\"   , double -> double),\n  fabs  = externcall_builtin(\"__nv_fabs\"  , double -> double),\n  floor = externcall_builtin(\"__nv_floor\" , double -> double),\n  fmod  = externcall_builtin(\"__nv_fmod\"  , {double, double} -> double),\n  log   = externcall_builtin(\"__nv_log\"   , double -> double),\n  pow   = externcall_builtin(\"__nv_pow\"   , {double, double} -> double),\n  sin   = externcall_builtin(\"__nv_sin\"   , double -> double),\n  sqrt  = externcall_builtin(\"__nv_sqrt\"  , double -> double),\n  tan   = externcall_builtin(\"__nv_tan\"   , double -> double),\n}\n\nlocal cpu_fn_to_gpu_fn = {}\n\nfunction cudahelper.register_builtin(name, cpu_fn)\n  cpu_fn_to_gpu_fn[cpu_fn] = builtin_gpu_fns[name]\nend\n\nfunction cudahelper.replace_with_builtin(fn)\n  return cpu_fn_to_gpu_fn[fn] or fn\nend\n\nreturn cudahelper\n",
        "/tmp/vanessa/spack-stage/spack-stage-legion-17.02.0-4s75mta4eowlznamyr2cbsdl2tuvjeyx/spack-src/language/examples/manual_capi_dynamic_registration.rg": "-- Copyright 2017 Stanford University\n--\n-- Licensed under the Apache License, Version 2.0 (the \"License\");\n-- you may not use this file except in compliance with the License.\n-- You may obtain a copy of the License at\n--\n--     http://www.apache.org/licenses/LICENSE-2.0\n--\n-- Unless required by applicable law or agreed to in writing, software\n-- distributed under the License is distributed on an \"AS IS\" BASIS,\n-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-- See the License for the specific language governing permissions and\n-- limitations under the License.\n\n-- Note: The binding library is only being used to load the dynamic\n-- library for Legion, not for any actual functionality. All Legion\n-- calls happen through the C API.\nrequire('legionlib')\nc = terralib.includecstring([[\n#include \"legion_c.h\"\n#include <stdio.h>\n#include <stdlib.h>\n]])\n\nFID_1 = 1\nFID_2 = 2\n\nTID_TOP_LEVEL_TASK = 100\nTID_SUB_TASK = 101\n\n---------------------------------------------------------------------\n--\n-- this is task registration code that could/should be in a library\n--\n---------------------------------------------------------------------\n\nlocal dlfcn = terralib.includec(\"dlfcn.h\")\nterra legion_has_llvm_support() : bool\n  return (dlfcn.dlsym([&opaque](0), \"legion_runtime_register_task_variant_llvmir\") ~= [&opaque](0))\nend\nuse_llvm = legion_has_llvm_support()\n\nfunction legion_task_wrapper(body)\n  -- look at the return type of the task we're wrapping to emit the right postamble code\n  local ft = body:gettype()\n  local rt = ft.returntype\n  local wrapper = nil\n  if terralib.sizeof(rt) > 0 then\n    wrapper = terra(data : &opaque, datalen : c.size_t, userdata : &opaque, userlen : c.size_t, proc_id : c.legion_lowlevel_id_t)\n      var task : c.legion_task_t,\n          regions : &c.legion_physical_region_t,\n          num_regions : uint32,\n          ctx : c.legion_context_t,\n          runtime : c.legion_runtime_t\n      c.legion_task_preamble(data, datalen, proc_id, &task, &regions, &num_regions, &ctx, &runtime)\n      var rv : rt = body(task, regions, num_regions, ctx, runtime)\n      c.legion_task_postamble(runtime, ctx, [&opaque](&rv), terralib.sizeof(rt))\n    end\n  else\n    wrapper = terra(data : &opaque, datalen : c.size_t, userdata : &opaque, userlen : c.size_t, proc_id : c.legion_lowlevel_id_t)\n      var task : c.legion_task_t,\n          regions : &c.legion_physical_region_t,\n          num_regions : uint32,\n          ctx : c.legion_context_t,\n          runtime : c.legion_runtime_t\n      c.legion_task_preamble(data, datalen, proc_id, &task, &regions, &num_regions, &ctx, &runtime)\n      body(task, regions, num_regions, ctx, runtime)\n      c.legion_task_postamble(runtime, ctx, [&opaque](0), 0)\n    end\n  end\n  return wrapper\nend\n\nfunction preregister_task(terrafunc)\n  -- either way, we wrap the body with legion preamble and postamble first\n  local wrapped = legion_task_wrapper(terrafunc)\n  if use_llvm then\n    -- if we can register llvmir, ask Terra to generate that\n    local ir = terralib.saveobj(nil, \"llvmir\", { entry=wrapped } )\n    local rfunc = terra(id : c.legion_task_id_t,\n                        task_name : &int8,\n                        execution_constraints : c.legion_execution_constraint_set_t,\n                        layout_constraints : c.legion_task_layout_constraint_set_t,\n                        options: c.legion_task_config_options_t,\n                        userdata : &opaque,\n                        userlen : c.size_t)\n      return c.legion_runtime_preregister_task_variant_llvmir(\n        id, task_name,\n        execution_constraints, layout_constraints, options,\n        ir, \"entry\", userdata, userlen)\n    end\n    return rfunc\n  else\n    -- use the terra function directly, which ffi will convert to a (non-portable) function pointer\n    local rfunc = terra(id : c.legion_task_id_t,\n                        task_name : &int8,\n                        execution_constraints : c.legion_execution_constraint_set_t,\n                        layout_constraints : c.legion_task_layout_constraint_set_t,\n                        options: c.legion_task_config_options_t,\n                        userdata : &opaque,\n                        userlen : c.size_t)\n      return c.legion_runtime_preregister_task_variant_fnptr(\n        id, task_name,\n        execution_constraints, layout_constraints, options,\n        wrapped, userdata, userlen)\n    end\n    return rfunc\n  end\nend\n\nfunction register_task(terrafunc)\n  -- either way, we wrap the body with legion preamble and postamble first\n  local wrapped = legion_task_wrapper(terrafunc)\n  if use_llvm then\n    -- if we can register llvmir, ask Terra to generate that\n    local ir = terralib.saveobj(nil, \"llvmir\", { entry=wrapped } )\n    local rfunc = terra(runtime : c.legion_runtime_t,\n                        id : c.legion_task_id_t,\n                        task_name : &int8,\n                        execution_constraints : c.legion_execution_constraint_set_t,\n                        layout_constraints : c.legion_task_layout_constraint_set_t,\n                        options: c.legion_task_config_options_t,\n                        userdata : &opaque,\n                        userlen : c.size_t)\n      return c.legion_runtime_register_task_variant_llvmir(\n        runtime, id, task_name,\n        true, -- global registration possible with llvmir\n        execution_constraints, layout_constraints, options,\n        ir, \"entry\", userdata, userlen)\n    end\n    return rfunc\n  else\n    -- use the terra function directly, which ffi will convert to a (non-portable) function pointer\n    local rfunc = terra(runtime : c.legion_runtime_t,\n                        id : c.legion_task_id_t,\n                        task_name : &int8,\n                        execution_constraints : c.legion_execution_constraint_set_t,\n                        layout_constraints : c.legion_task_layout_constraint_set_t,\n                        options: c.legion_task_config_options_t,\n                        userdata : &opaque,\n                        userlen : c.size_t)\n      return c.legion_runtime_register_task_variant_fnptr(\n        runtime, id, task_name,\n        false, -- global registration not possible with non-portable pointer\n        execution_constraints, layout_constraints, options,\n        wrapped, userdata, userlen)\n    end\n    return rfunc\n  end\nend\n\n---------------------------------------------------------------------\n--\n-- actual application tasks start here\n--\n---------------------------------------------------------------------\n\n\nterra sub_task(task : c.legion_task_t,\n               regions : &c.legion_physical_region_t,\n               num_regions : uint32,\n               ctx : c.legion_context_t,\n               runtime : c.legion_runtime_t) : uint32\n  var arglen = c.legion_task_get_arglen(task)\n  c.printf(\"in sub_task (%u arglen, %u regions)...\\n\",\n                arglen, num_regions)\n  var y = @[&uint32](c.legion_task_get_args(task))\n  return y + 1\nend\n\nterra top_level_task(task : c.legion_task_t,\n                     regions : &c.legion_physical_region_t,\n                     num_regions : uint32,\n                     ctx : c.legion_context_t,\n                     runtime : c.legion_runtime_t)\n  c.printf(\"in top_level_task...\\n\")\n\n  -- sub task is dynamically registered in the top level task\n  -- the Lua escape here constructs the right registration function, picking between a non-portable function\n  --  pointer and LLVMIR during the compilation of this task, but the actual registration happens when the\n  --  top_level_task is executed\n  var execution_constraints = c.legion_execution_constraint_set_create()\n  c.legion_execution_constraint_set_add_processor_constraint(execution_constraints, c.LOC_PROC)\n  var layout_constraints = c.legion_task_layout_constraint_set_create()\n  [ register_task(sub_task) ](\n    runtime, TID_SUB_TASK, \"sub_task\",\n    execution_constraints, layout_constraints,\n    c.legion_task_config_options_t {\n      leaf = false, inner = false, idempotent = false},\n    nil, 0)\n\n  var x : uint32 = 42\n  var sub_args = c.legion_task_argument_t {\n     args = [&opaque](&x),\n     arglen = terralib.sizeof(uint32)\n  }\n  var launcher = c.legion_task_launcher_create(\n    TID_SUB_TASK, sub_args, c.legion_predicate_true(), 0, 0)\n\n  var f = c.legion_task_launcher_execute(runtime, ctx, launcher)\n  var rv : uint32 = 99\n  c.legion_future_get_result_bytes(f, [&opaque](&rv), terralib.sizeof(uint32))\n  c.printf(\"back in parent (rv = %d)\\n\", rv)\n  if rv ~= 43 then\n    c.printf(\"abort\\n\")\n    c.abort()\n  end\nend\n\nlocal args = require(\"manual_capi_args\")\n\nterra main()\n  c.printf(\"in main...\\n\")\n\n  -- top level task must be \"preregistered\" (i.e. before we start the runtime)\n  var execution_constraints = c.legion_execution_constraint_set_create()\n  c.legion_execution_constraint_set_add_processor_constraint(execution_constraints, c.LOC_PROC)\n  var layout_constraints = c.legion_task_layout_constraint_set_create()\n  [ preregister_task(top_level_task) ](\n    TID_TOP_LEVEL_TASK,\n    \"top_level_task\",\n    execution_constraints, layout_constraints,\n    c.legion_task_config_options_t {\n      leaf = false, inner = false, idempotent = false},\n    nil, 0)\n\n  c.legion_runtime_set_top_level_task_id(TID_TOP_LEVEL_TASK)\n  [args.argv_setup]\n  c.legion_runtime_start(args.argc, args.argv, false)\nend\n\nif use_llvm then\n  print(\"LLVM support detected...  tasks will be registered as LLVM IR\")\nelse\n  print(\"LLVM support NOT detected...  tasks will be registered as function pointers\")\nend\nmain()\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-legion-17.02.0-4s75mta4eowlznamyr2cbsdl2tuvjeyx/spack-src/language/examples/mssp/small/edges.dat",
        "/tmp/vanessa/spack-stage/spack-stage-legion-17.02.0-4s75mta4eowlznamyr2cbsdl2tuvjeyx/spack-src/language/examples/mssp/small/result_3.dat",
        "/tmp/vanessa/spack-stage/spack-stage-legion-17.02.0-4s75mta4eowlznamyr2cbsdl2tuvjeyx/spack-src/doc/arch/persistent/hdf5/figs/high-level-design.png",
        "/tmp/vanessa/spack-stage/spack-stage-legion-17.02.0-4s75mta4eowlznamyr2cbsdl2tuvjeyx/spack-src/doc/arch/persistent/hdf5/figs/hdf5-layout-climate.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-legion-17.02.0-4s75mta4eowlznamyr2cbsdl2tuvjeyx/spack-src/doc/arch/persistent/hdf5/figs/hdf5-layout-climate.png",
        "/tmp/vanessa/spack-stage/spack-stage-legion-17.02.0-4s75mta4eowlznamyr2cbsdl2tuvjeyx/spack-src/doc/arch/persistent/hdf5/figs/hdf5-layout.pptx"
    ],
    "total_files": 1241
}