{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-r-lpsolve-5.6.13.2-2p7y34czadwk3yceelxxk5stmkcgrmfe/spack-src/src/lp_lib.c": "\n/* ----------------------------------------------------------------------------------\n   Main library of routines for lp_solve v5.0+\n   ----------------------------------------------------------------------------------\n    Author:        Michel Berkelaar (to v3.2)\n                   Kjell Eikland    (v4.0 and forward)\n    Contact:       kjell.eikland@broadpark.no\n    License terms: LGPL.\n\n    Requires:      (see below)\n\n    Release notes:\n    v5.0.0  1 January 2004      First integrated and repackaged version.\n    v5.0.1  8 May 2004          Cumulative update since initial release;\n                                overall functionality scope maintained.\n    v5.1.0  20 July 2004        Reworked lp_solve throughout to fit new\n                                flexible matrix storage model.\n\n   ---------------------------------------------------------------------------------- */\n\n/* ---------------------------------------------------------------------------------- */\n/* Main library of routines for lp_solve                                              */\n/*----------------------------------------------------------------------------------- */\n#include <signal.h>\n#include <string.h>\n#include <float.h>\n#include <math.h>\n\n#if LoadInverseLib == TRUE\n  #ifdef WIN32\n    #include <windows.h>\n  #else\n    #include <dlfcn.h>\n  #endif\n#endif\n\n\n/* ---------------------------------------------------------------------------------- */\n/* Include core and support modules via headers                                       */\n/* ---------------------------------------------------------------------------------- */\n#include \"lp_lib.h\"\n#include \"commonlib.h\"\n#include \"lp_utils.h\"\n#include \"lp_matrix.h\"\n#include \"lp_SOS.h\"\n#include \"lp_Hash.h\"\n#include \"lp_MPS.h\"\n#include \"lp_wlp.h\"\n#include \"lp_presolve.h\"\n#include \"lp_scale.h\"\n#include \"lp_simplex.h\"\n#include \"lp_mipbb.h\"\n#include \"lp_report.h\"\n#include \"lp_MDO.h\"\n\n#if INVERSE_ACTIVE==INVERSE_LUMOD\n  #include \"lp_LUMOD.h\"\n#elif INVERSE_ACTIVE==INVERSE_LUSOL\n  #include \"lp_LUSOL.h\"\n#elif INVERSE_ACTIVE==INVERSE_GLPKLU\n  #include \"lp_glpkLU.h\"\n#elif INVERSE_ACTIVE==INVERSE_ETAPFI\n  #include \"lp_etaPFI.h\"\n#elif INVERSE_ACTIVE==INVERSE_LEGACY\n  #include \"lp_etaPFI.h\"\n#endif\n\n#if libBLAS > 0\n  #include \"myblas.h\"\n#endif\n\n#ifdef __BORLANDC__\n  #pragma hdrstop\n  #pragma package(smart_init)\n#endif\n\n/* ---------------------------------------------------------------------------------- */\n/* Include selected basis inverse routines and price norm scalars                     */\n/* ---------------------------------------------------------------------------------- */\n\n#include \"lp_price.h\"\n#include \"lp_pricePSE.h\"\n\n#ifdef FORTIFY\n# include \"lp_fortify.h\"\n#endif\n\n\n/* ---------------------------------------------------------------------------------- */\n/* Define some globals                                                                */\n/* ---------------------------------------------------------------------------------- */\nint callcount = 0;\n\n/* buttrey remove */\nint buttrey_thing = 0;\nFILE *buttrey_debugfile;\n\n/* Return lp_solve version information */\nvoid __WINAPI lp_solve_version(int *majorversion, int *minorversion, int *release, int *build)\n{\n  if(majorversion != NULL)\n    (*majorversion) = MAJORVERSION;\n  if(minorversion != NULL)\n    (*minorversion) = MINORVERSION;\n  if(release != NULL)\n    (*release) = RELEASE;\n  if(build != NULL)\n    (*build) = BUILD;\n}\n\n\n/* ---------------------------------------------------------------------------------- */\n/* Various interaction elements                                                       */\n/* ---------------------------------------------------------------------------------- */\n\n#if defined INLINE\nINLINE void set_biton(MYBOOL *bitarray, int item)\n{\n  bitarray[item / 8] |= (1 << (item % 8));\n}\nINLINE MYBOOL is_biton(MYBOOL *bitarray, int item)\n{\n  return( (MYBOOL) ((bitarray[item / 8] & (1 << (item % 8))) != 0) );\n}\n#else\nvoid set_biton(MYBOOL *bitarray, int item);\nMYBOOL set_bitoff(MYBOOL *bitarray, int item);\nMYBOOL is_biton(MYBOOL *bitarray, int item);\n#endif\n/* This next line went with \"if defined INLINE\" above SEB April 14 2006 */\n#if 0\nINLINE void set_bitoff(MYBOOL *bitarray, int item)\n{\n  bitarray[item / 8] &= ~(1 << (item % 8));\n}\n#endif\n\nMYBOOL __WINAPI userabort(lprec *lp, int message)\n{\n  static MYBOOL abort;\n  static int spx_save;\n\n  spx_save = lp->spx_status;\n  lp->spx_status = RUNNING;\n  if(yieldformessages(lp) != 0) {\n    lp->spx_status = USERABORT;\n    if(lp->bb_level > 0)\n      lp->bb_break = TRUE;\n  }\n  if((message > 0) && (lp->usermessage != NULL) && (lp->msgmask & message))\n    lp->usermessage(lp, lp->msghandle, message);\n  abort = (MYBOOL) (lp->spx_status != RUNNING);\n  if(!abort)\n    lp->spx_status = spx_save;\n  return( abort );\n}\n\nSTATIC int yieldformessages(lprec *lp)\n{\n  static double currenttime;\n\n  if((lp->sectimeout > 0) &&\n     (((currenttime = timeNow()) -lp->timestart)-(REAL)lp->sectimeout>0))\n    lp->spx_status = TIMEOUT;\n\n  if(lp->ctrlc != NULL) {\n    int retcode = lp->ctrlc(lp, lp->ctrlchandle);\n    /* Check for command to restart the B&B */\n    if((retcode == ACTION_RESTART) && (lp->bb_level > 1)) {\n      lp->bb_break = AUTOMATIC;\n      retcode = 0;\n    }\n    return(retcode);\n  }\n  else\n    return(0);\n}\n\nvoid __WINAPI set_outputstream(lprec *lp, FILE *stream)\n{\n  if((lp->outstream != NULL) ) { /* && (lp->outstream != stdout)) { */\n    if(lp->streamowned)\n      fclose(lp->outstream);\n    else\n      fflush(lp->outstream);\n  }\n/*  if(stream == NULL)\n**    lp->outstream = stdout;\n**  else */\n    lp->outstream = stream;\n  lp->streamowned = FALSE;\n}\n\nMYBOOL __WINAPI set_outputfile(lprec *lp, char *filename)\n{\n  MYBOOL ok;\n  FILE   *output; /* = stdout; */\n\n  ok = (MYBOOL) ((filename == NULL) || (*filename == 0) || ((output = fopen(filename,\"w\")) != NULL));\n  if(ok) {\n    set_outputstream(lp, output);\n    lp->streamowned = (MYBOOL) ((filename != NULL) && (*filename != 0));\n#if 1\n    if((filename != NULL) && (*filename == 0))\n      lp->outstream = NULL;\n#endif\n  }\n  return(ok);\n}\n\nREAL __WINAPI time_elapsed(lprec *lp)\n{\n  if(lp->timeend > 0)\n    return(lp->timeend - lp->timestart);\n  else\n    return(timeNow() - lp->timestart);\n}\n\nvoid __WINAPI put_bb_nodefunc(lprec *lp, lphandleint_intfunc newnode, void *bbnodehandle)\n{\n  lp->bb_usenode = newnode;\n  lp->bb_nodehandle = bbnodehandle;         /* User-specified \"owner process ID\" */\n}\nvoid __WINAPI put_bb_branchfunc(lprec *lp, lphandleint_intfunc newbranch, void *bbbranchhandle)\n{\n  lp->bb_usebranch = newbranch;\n  lp->bb_branchhandle = bbbranchhandle;     /* User-specified \"owner process ID\" */\n}\nvoid __WINAPI put_abortfunc(lprec *lp, lphandle_intfunc newctrlc, void *ctrlchandle)\n{\n  lp->ctrlc = newctrlc;\n  lp->ctrlchandle = ctrlchandle;            /* User-specified \"owner process ID\" */\n}\nvoid __WINAPI put_logfunc(lprec *lp, lphandlestr_func newlog, void *loghandle)\n{\n  lp->writelog = newlog;\n  lp->loghandle = loghandle;                /* User-specified \"owner process ID\" */\n}\nvoid __WINAPI put_msgfunc(lprec *lp, lphandleint_func newmsg, void *msghandle, int mask)\n{\n  lp->usermessage = newmsg;\n  lp->msghandle = msghandle;                /* User-specified \"owner process ID\" */\n  lp->msgmask = mask;\n}\n\n\n/* ---------------------------------------------------------------------------------- */\n/* DLL exported function                                                              */\n/* ---------------------------------------------------------------------------------- */\nlprec * __WINAPI read_MPS(char *filename, int verbose)\n{\n  lprec *lp = NULL;\n\n  if(MPS_readfile(&lp, filename, MPSFIXED, verbose))\n    return( lp );\n  else\n    return( NULL );\n}\nlprec * __WINAPI read_mps(FILE *filename, int verbose)\n{\n  lprec *lp = NULL;\n\n  if(MPS_readhandle(&lp, filename, MPSFIXED, verbose))\n    return( lp );\n  else\n    return( NULL );\n}\n#if defined develop\nlprec * __WINAPI read_mpsex(void *userhandle, read_modeldata_func read_modeldata, int verbose)\n{\n  lprec *lp = NULL;\n\n  if(MPS_readex(&lp, userhandle, read_modeldata, MPSFIXED, verbose))\n    return( lp );\n  else\n    return( NULL );\n}\n#endif\nlprec * __WINAPI read_freeMPS(char *filename, int verbose)\n{\n  lprec *lp = NULL;\n\n  if(MPS_readfile(&lp, filename, MPSFREE, verbose))\n    return( lp );\n  else\n    return( NULL );\n}\nlprec * __WINAPI read_freemps(FILE *filename, int verbose)\n{\n  lprec *lp = NULL;\n\n  if(MPS_readhandle(&lp, filename, MPSFREE, verbose))\n    return( lp );\n  else\n    return( NULL );\n}\n#if defined develop\nlprec * __WINAPI read_freempsex(void *userhandle, read_modeldata_func read_modeldata, int verbose)\n{\n  lprec *lp = NULL;\n\n  if(MPS_readex(&lp, userhandle, read_modeldata, MPSFREE, verbose))\n    return( lp );\n  else\n    return( NULL );\n}\n#endif\nMYBOOL __WINAPI write_mps(lprec *lp, char *filename)\n{\n  return(MPS_writefile(lp, MPSFIXED, filename));\n}\nMYBOOL __WINAPI write_MPS(lprec *lp, FILE *output)\n{\n  return(MPS_writehandle(lp, MPSFIXED, output));\n}\n\nMYBOOL __WINAPI write_freemps(lprec *lp, char *filename)\n{\n  return(MPS_writefile(lp, MPSFREE, filename));\n}\nMYBOOL __WINAPI write_freeMPS(lprec *lp, FILE *output)\n{\n  return(MPS_writehandle(lp, MPSFREE, output));\n}\n\nMYBOOL __WINAPI write_lp(lprec *lp, char *filename)\n{\n  return(LP_writefile(lp, filename));\n}\nMYBOOL __WINAPI write_LP(lprec *lp, FILE *output)\n{\n  return(LP_writehandle(lp, output));\n}\n#ifndef PARSER_LP\nMYBOOL __WINAPI LP_readhandle(lprec **lp, FILE *filename, int verbose, char *lp_name)\n{\n  return(FALSE);\n}\nlprec * __WINAPI read_lp(FILE *filename, int verbose, char *lp_name)\n{\n  return(NULL);\n}\nlprec * __WINAPI read_LP(char *filename, int verbose, char *lp_name)\n{\n  return(NULL);\n}\n#endif\n\nMYBOOL __WINAPI write_basis(lprec *lp, char *filename)\n{\n  int typeMPS = MPSFIXED;\n  return( MPS_writeBAS(lp, typeMPS, filename) );\n}\nMYBOOL __WINAPI read_basis(lprec *lp, char *filename, char *info)\n{\n  int typeMPS = MPSFIXED;\n\n  typeMPS = MPS_readBAS(lp, typeMPS, filename, info);\n\n  /* Code basis */\n  if(typeMPS) {\n    set_action(&lp->spx_action, ACTION_REBASE | ACTION_REINVERT | ACTION_RECOMPUTE);\n    lp->basis_valid = TRUE;   /* Do not re-initialize basis on entering Solve */\n    lp->var_basic[0] = FALSE; /* Set to signal that this is a non-default basis */\n  }\n  return( (MYBOOL) typeMPS );\n}\n\n/* Write and read lp_solve parameters (placeholders) - see lp_params.c */\nvoid __WINAPI reset_params(lprec *lp)\n{\n  int mode;\n\n  lp->epsmachine        = DEF_EPSMACHINE;\n  lp->epsperturb        = DEF_PERTURB;\n  lp->lag_accept        = DEF_LAGACCEPT;\n  set_epslevel(lp, EPS_DEFAULT);\n\n  lp->tighten_on_set    = FALSE;\n  lp->negrange          = DEF_NEGRANGE;\n\n#if 0\n  lp->do_presolve       = PRESOLVE_ROWS | PRESOLVE_COLS | PRESOLVE_MERGEROWS |\n                          PRESOLVE_REDUCEGCD |\n                          PRESOLVE_ROWDOMINATE;\n#else\n  lp->do_presolve       = PRESOLVE_NONE;\n#endif\n  lp->presolveloops     = DEF_MAXPRESOLVELOOPS;\n\n  lp->scalelimit        = DEF_SCALINGLIMIT;\n  lp->scalemode         = SCALE_INTEGERS |\n#if 0\n                          SCALE_POWER2 |\n                          SCALE_LOGARITHMIC | SCALE_MEAN;\n#else\n                          SCALE_LINEAR | SCALE_GEOMETRIC |\n                          SCALE_EQUILIBRATE;\n#endif\n\n  lp->crashmode         = CRASH_NONE;\n\n  lp->max_pivots        = 0;\n  lp->simplex_strategy  = SIMPLEX_DUAL_PRIMAL;\n#define PricerDefaultOpt 1\n#if PricerDefaultOpt == 1\n  mode = PRICER_DEVEX;\n#elif PricerDefaultOpt == 2\n  mode = PRICER_STEEPESTEDGE;\n  mode |= PRICE_TRUENORMINIT;\n#else\n  mode = PRICER_STEEPESTEDGE | PRICE_PRIMALFALLBACK;\n#endif\n  mode |= PRICE_ADAPTIVE;\n#ifdef EnableRandomizedPricing\n  mode |= PRICE_RANDOMIZE;\n#endif\n  set_pivoting(lp, mode);\n\n  lp->improve           = IMPROVE_DEFAULT;\n  lp->anti_degen        = ANTIDEGEN_DEFAULT;\n\n  lp->bb_floorfirst     = BRANCH_AUTOMATIC;\n  lp->bb_rule           = NODE_DYNAMICMODE | NODE_GREEDYMODE | NODE_GAPSELECT |\n#if 1\n                          NODE_PSEUDOCOSTSELECT |\n#else\n                          NODE_PSEUDOFEASSELECT |\n#endif\n                          NODE_RCOSTFIXING;\n  lp->bb_limitlevel     = DEF_BB_LIMITLEVEL;\n  lp->bb_PseudoUpdates  = DEF_PSEUDOCOSTUPDATES;\n\n  lp->bb_heuristicOF    = my_chsign(is_maxim(lp), MAX(DEF_INFINITE, lp->infinite));\n  lp->bb_breakOF        = -lp->bb_heuristicOF;\n\n  lp->sectimeout        = 0;\n  lp->solutionlimit     = 1;\n\n  set_outputstream(lp, NULL);          /* Set to default output stream */\n  lp->verbose           = NORMAL;\n  lp->print_sol         = FALSE;       /* Can be FALSE, TRUE, AUTOMATIC (only non-zeros printed) */\n  lp->spx_trace         = FALSE;\n  lp->lag_trace         = FALSE;\n  lp->bb_trace          = FALSE;\n}\n\nvoid __WINAPI unscale(lprec *lp)\n{\n  undoscale(lp);\n}\nint __WINAPI solve(lprec *lp)\n{\n  if(has_BFP(lp)) {\n    lp->solvecount++;\n    if(is_add_rowmode(lp))\n      set_add_rowmode(lp, FALSE);\n    return(lin_solve(lp));\n  }\n  else\n    return( NOBFP );\n}\nvoid __WINAPI print_lp(lprec *lp)\n{\n  REPORT_lp(lp);\n}\nvoid __WINAPI print_tableau(lprec *lp)\n{\n  REPORT_tableau(lp);\n}\nvoid __WINAPI print_objective(lprec *lp)\n{\n  REPORT_objective(lp);\n}\nvoid __WINAPI print_solution(lprec *lp, int columns)\n{\n  REPORT_solution(lp, columns);\n}\nvoid __WINAPI print_constraints(lprec *lp, int columns)\n{\n  REPORT_constraints(lp, columns);\n}\nvoid __WINAPI print_duals(lprec *lp)\n{\n  REPORT_duals(lp);\n}\nvoid __WINAPI print_scales(lprec *lp)\n{\n  REPORT_scales(lp);\n}\nMYBOOL __WINAPI print_debugdump(lprec *lp, char *filename)\n{\n  return(REPORT_debugdump(lp, filename, (MYBOOL) (get_total_iter(lp) > 0)));\n}\nvoid __WINAPI print_str(lprec *lp, char *str)\n{\n  report(lp, lp->verbose, \"%s\", str);\n}\n\n\n\n/* ---------------------------------------------------------------------------------- */\n/* Parameter setting and retrieval functions                                          */\n/* ---------------------------------------------------------------------------------- */\n\nvoid __WINAPI set_timeout(lprec *lp, long sectimeout)\n{\n  lp->sectimeout = sectimeout;\n}\n\nlong __WINAPI get_timeout(lprec *lp)\n{\n  return(lp->sectimeout);\n}\n\nvoid __WINAPI set_verbose(lprec *lp, int verbose)\n{\n  lp->verbose = verbose;\n}\n\nint __WINAPI get_verbose(lprec *lp)\n{\n  return(lp->verbose);\n}\n\nvoid __WINAPI set_print_sol(lprec *lp, int print_sol)\n{\n  lp->print_sol = print_sol;\n}\n\nint __WINAPI get_print_sol(lprec *lp)\n{\n  return(lp->print_sol);\n}\n\nvoid __WINAPI set_debug(lprec *lp, MYBOOL debug)\n{\n  lp->bb_trace = debug;\n}\n\nMYBOOL __WINAPI is_debug(lprec *lp)\n{\n  return(lp->bb_trace);\n}\n\nvoid __WINAPI set_trace(lprec *lp, MYBOOL trace)\n{\n  lp->spx_trace = trace;\n}\n\nMYBOOL __WINAPI is_trace(lprec *lp)\n{\n  return(lp->spx_trace);\n}\n\nvoid __WINAPI set_anti_degen(lprec *lp, int anti_degen)\n{\n  lp->anti_degen = anti_degen;\n}\n\nint __WINAPI get_anti_degen(lprec *lp)\n{\n  return(lp->anti_degen);\n}\n\nMYBOOL __WINAPI is_anti_degen(lprec *lp, int testmask)\n{\n  return((MYBOOL) ((lp->anti_degen == testmask) || ((lp->anti_degen & testmask) != 0)));\n}\n\nvoid __WINAPI set_presolve(lprec *lp, int presolvemode, int maxloops)\n{\n  lp->do_presolve = presolvemode;\n  lp->presolveloops = maxloops;\n}\n\nint __WINAPI get_presolve(lprec *lp)\n{\n  return(lp->do_presolve);\n}\n\nint __WINAPI get_presolveloops(lprec *lp)\n{\n  if(lp->presolveloops < 0)\n    return(DEF_MAXPRESOLVELOOPS);\n  else if(lp->presolveloops == 0)\n    return(MAXINT32);\n  else\n    return(lp->presolveloops);\n}\n\nMYBOOL __WINAPI is_presolve(lprec *lp, int testmask)\n{\n  return((MYBOOL) ((lp->do_presolve == testmask) || ((lp->do_presolve & testmask) != 0)));\n}\n\nvoid __WINAPI set_maxpivot(lprec *lp, int maxpivot)\n{\n  lp->max_pivots = maxpivot;\n}\n\nint __WINAPI get_maxpivot(lprec *lp)\n{\n  return( lp->bfp_pivotmax(lp) );\n}\n\nvoid __WINAPI set_bb_rule(lprec *lp, int bb_rule)\n{\n  lp->bb_rule = bb_rule;\n}\n\nint __WINAPI get_bb_rule(lprec *lp)\n{\n  return(lp->bb_rule);\n}\n\nINLINE MYBOOL is_bb_rule(lprec *lp, int bb_rule)\n{\n  return( (MYBOOL) ((lp->bb_rule & NODE_STRATEGYMASK) == bb_rule) );\n}\n\n/* INLINE */ MYBOOL is_bb_mode(lprec *lp, int bb_mask)\n{\n  return( (MYBOOL) ((lp->bb_rule & bb_mask) > 0) );\n}\n\nvoid __WINAPI set_action(int *actionvar, int actionmask)\n{\n  *actionvar |= actionmask;\n}\n\nvoid __WINAPI clear_action(int *actionvar, int actionmask)\n{\n  *actionvar &= ~actionmask;\n}\n\nMYBOOL __WINAPI is_action(int actionvar, int testmask)\n{\n  return( (MYBOOL) ((actionvar & testmask) != 0) );\n}\n\nvoid __WINAPI set_bb_depthlimit(lprec *lp, int bb_maxlevel)\n{\n  lp->bb_limitlevel = bb_maxlevel;\n}\n\nint __WINAPI get_bb_depthlimit(lprec *lp)\n{\n  return(lp->bb_limitlevel);\n}\n\nvoid __WINAPI set_obj_bound(lprec *lp, REAL bb_heuristicOF)\n{\n  lp->bb_heuristicOF = bb_heuristicOF;\n}\n\nREAL __WINAPI get_obj_bound(lprec *lp)\n{\n  return(lp->bb_heuristicOF);\n}\n\nvoid __WINAPI set_mip_gap(lprec *lp, MYBOOL absolute, REAL mip_gap)\n{\n  if(absolute)\n    lp->mip_absgap = mip_gap;\n  else\n    lp->mip_relgap = mip_gap;\n}\n\nREAL __WINAPI get_mip_gap(lprec *lp, MYBOOL absolute)\n{\n  if(absolute)\n    return(lp->mip_absgap);\n  else\n    return(lp->mip_relgap);\n}\n\nMYBOOL __WINAPI set_var_branch(lprec *lp, int colnr, int branch_mode)\n{\n  if(colnr > lp->columns || colnr < 1) {\n    report(lp, IMPORTANT, \"set_var_branch: Column %d out of range\\n\", colnr);\n    return( FALSE );\n  }\n\n  if(lp->bb_varbranch == NULL) {\n    int i;\n    if(branch_mode == BRANCH_DEFAULT)\n      return( TRUE );\n    allocMYBOOL(lp, &lp->bb_varbranch, lp->columns_alloc, FALSE);\n    for(i = 0; i < lp->columns; i++)\n      lp->bb_varbranch[i] = BRANCH_DEFAULT;\n  }\n  lp->bb_varbranch[colnr - 1] = (MYBOOL) branch_mode;\n  return( TRUE );\n}\n\nint __WINAPI get_var_branch(lprec *lp, int colnr)\n{\n  if(colnr > lp->columns || colnr < 1) {\n    report(lp, IMPORTANT, \"get_var_branch: Column %d out of range\\n\", colnr);\n    return(lp->bb_floorfirst);\n  }\n\n  if(lp->bb_varbranch == NULL)\n    return(lp->bb_floorfirst);\n  if(lp->bb_varbranch[colnr - 1] == BRANCH_DEFAULT)\n    return(lp->bb_floorfirst);\n  else\n    return(lp->bb_varbranch[colnr - 1]);\n}\n\nstatic void set_infiniteex(lprec *lp, REAL infinite, MYBOOL init)\n{\n  int i;\n\n  infinite = fabs(infinite);\n  if((init) || is_infinite(lp, lp->bb_heuristicOF))\n    lp->bb_heuristicOF = my_chsign(is_maxim(lp), infinite);\n  if((init) || is_infinite(lp, lp->bb_breakOF))\n    lp->bb_breakOF = my_chsign(is_maxim(lp), -infinite);\n  for(i = 0; i <= lp->sum; i++) {\n    if((!init) && is_infinite(lp, lp->orig_lowbo[i]))\n      lp->orig_lowbo[i] = -infinite;\n    if((init) || is_infinite(lp, lp->orig_upbo[i]))\n      lp->orig_upbo[i] = infinite;\n  }\n  lp->infinite = infinite;\n}\n\n\nMYBOOL __WINAPI is_infinite(lprec *lp, REAL value)\n{\n#if 1\n  return( (MYBOOL) (fabs(value) >= lp->infinite) );\n#else\n  if(fabs(value) >= lp->infinite)\n    return( TRUE );\n  else\n    return( FALSE );\n#endif\n}\n\nvoid __WINAPI set_infinite(lprec *lp, REAL infinite)\n{\n  set_infiniteex(lp, infinite, FALSE);\n}\n\nREAL __WINAPI get_infinite(lprec *lp)\n{\n  return(lp->infinite);\n}\n\nvoid __WINAPI set_epsperturb(lprec *lp, REAL epsperturb)\n{\n  lp->epsperturb = epsperturb;\n}\n\nREAL __WINAPI get_epsperturb(lprec *lp)\n{\n  return(lp->epsperturb);\n}\n\nvoid __WINAPI set_epspivot(lprec *lp, REAL epspivot)\n{\n  lp->epspivot = epspivot;\n}\n\nREAL __WINAPI get_epspivot(lprec *lp)\n{\n  return(lp->epspivot);\n}\n\nvoid __WINAPI set_epsint(lprec *lp, REAL epsint)\n{\n  lp->epsint = epsint;\n}\n\nREAL __WINAPI get_epsint(lprec *lp)\n{\n  return(lp->epsint);\n}\n\nvoid __WINAPI set_epsb(lprec *lp, REAL epsb)\n{\n  lp->epsprimal = MAX(epsb, lp->epsmachine);\n}\n\nREAL __WINAPI get_epsb(lprec *lp)\n{\n  return(lp->epsprimal);\n}\n\nvoid __WINAPI set_epsd(lprec *lp, REAL epsd)\n{\n  lp->epsdual = MAX(epsd, lp->epsmachine); /* Mainly used as tolerance for reduced cost */\n}\n\nREAL __WINAPI get_epsd(lprec *lp)\n{\n  return(lp->epsdual);\n}\n\nvoid __WINAPI set_epsel(lprec *lp, REAL epsel)\n{\n  lp->epsvalue = MAX(epsel, lp->epsmachine);\n}\n\nREAL __WINAPI get_epsel(lprec *lp)\n{\n  return(lp->epsvalue);\n}\n\nMYBOOL __WINAPI set_epslevel(lprec *lp, int epslevel)\n{\n  REAL SPX_RELAX, MIP_RELAX;\n\n  switch(epslevel) {\n    case EPS_TIGHT:  SPX_RELAX = 1;\n                      MIP_RELAX = 1;\n                      break;\n    case EPS_MEDIUM: SPX_RELAX = 10;\n                      MIP_RELAX = 1;\n                      break;\n    case EPS_LOOSE:  SPX_RELAX = 100;\n                      MIP_RELAX = 10;\n                      break;\n    case EPS_BAGGY:  SPX_RELAX = 1000;\n                      MIP_RELAX = 100;\n                      break;\n    default:        return( FALSE );\n  }\n  lp->epsvalue   = SPX_RELAX*DEF_EPSVALUE;\n  lp->epsprimal  = SPX_RELAX*DEF_EPSPRIMAL;\n  lp->epsdual    = SPX_RELAX*DEF_EPSDUAL;\n  lp->epspivot   = SPX_RELAX*DEF_EPSPIVOT;\n  lp->epssolution= MIP_RELAX*DEF_EPSSOLUTION;\n  lp->epsint     = MIP_RELAX*DEF_EPSINT;\n  lp->mip_absgap = MIP_RELAX*DEF_MIP_GAP;\n  lp->mip_relgap = MIP_RELAX*DEF_MIP_GAP;\n\n  return( TRUE );\n}\n\nvoid __WINAPI set_scaling(lprec *lp, int scalemode)\n{\n  lp->scalemode = scalemode;\n}\n\nint __WINAPI get_scaling(lprec *lp)\n{\n  return(lp->scalemode);\n}\n\nMYBOOL __WINAPI is_scalemode(lprec *lp, int testmask)\n{\n  return((MYBOOL) ((lp->scalemode & testmask) != 0));\n}\n\nMYBOOL __WINAPI is_scaletype(lprec *lp, int scaletype)\n{\n  int testtype;\n\n  testtype = lp->scalemode & SCALE_MAXTYPE;\n  return((MYBOOL) (scaletype == testtype));\n}\n\nvoid __WINAPI set_scalelimit(lprec *lp, REAL scalelimit)\n/* Set the relative scaling convergence criterion for the active scaling mode;\n   the integer part specifies the maximum number of iterations (default = 5). */\n{\n  lp->scalelimit = fabs(scalelimit);\n}\n\nREAL __WINAPI get_scalelimit(lprec *lp)\n{\n  return(lp->scalelimit);\n}\n\nMYBOOL __WINAPI is_integerscaling(lprec *lp)\n{\n  return(is_scalemode(lp, SCALE_INTEGERS));\n}\n\nvoid __WINAPI set_improve(lprec *lp, int improve)\n{\n  lp->improve = improve;\n}\n\nint __WINAPI get_improve(lprec *lp)\n{\n  return(lp->improve);\n}\n\nvoid __WINAPI set_lag_trace(lprec *lp, MYBOOL lag_trace)\n{\n  lp->lag_trace = lag_trace;\n}\n\nMYBOOL __WINAPI is_lag_trace(lprec *lp)\n{\n  return(lp->lag_trace);\n}\n\nvoid __WINAPI set_pivoting(lprec *lp, int pivoting)\n{\n  /* Set new pivoting strategy */\n  lp->piv_strategy = pivoting;\n  report(lp, DETAILED, \"set_pivoting: Pricing strategy set to '%s'\\n\",\n                       get_str_piv_rule(get_piv_rule(lp)));\n}\n\nint __WINAPI get_pivoting(lprec *lp)\n{\n  return( lp->piv_strategy );\n}\n\n/* INLINE */ int get_piv_rule(lprec *lp)\n{\n  return( (lp->piv_strategy | PRICE_STRATEGYMASK) ^ PRICE_STRATEGYMASK );\n}\n\nSTATIC char *get_str_piv_rule(int rule)\n{\n  static char *pivotText[PRICER_LASTOPTION+1] =\n  {\"Bland first index\", \"Dantzig\", \"Devex\", \"Steepest Edge\"};\n\n  return( pivotText[rule] );\n}\n\nMYBOOL __WINAPI is_piv_rule(lprec *lp, int rule)\n{\n  return( (MYBOOL) (get_piv_rule(lp) == rule) );\n}\n\nMYBOOL __WINAPI is_piv_mode(lprec *lp, int testmask)\n{\n  return((MYBOOL) (((testmask & PRICE_STRATEGYMASK) != 0) &&\n                   ((lp->piv_strategy & testmask) != 0)));\n}\n\nvoid __WINAPI set_break_at_first(lprec *lp, MYBOOL break_at_first)\n{\n  lp->bb_breakfirst = break_at_first;\n}\n\nMYBOOL __WINAPI is_break_at_first(lprec *lp)\n{\n  return(lp->bb_breakfirst);\n}\n\nvoid __WINAPI set_bb_floorfirst(lprec *lp, int bb_floorfirst)\n{\n  lp->bb_floorfirst = (MYBOOL) bb_floorfirst;\n}\n\nint __WINAPI get_bb_floorfirst(lprec *lp)\n{\n  return(lp->bb_floorfirst);\n}\n\nvoid __WINAPI set_break_at_value(lprec *lp, REAL break_at_value)\n{\n  lp->bb_breakOF = break_at_value;\n}\n\nREAL __WINAPI get_break_at_value(lprec *lp)\n{\n  return(lp->bb_breakOF);\n}\n\nvoid __WINAPI set_negrange(lprec *lp, REAL negrange)\n{\n  if(negrange <= 0)\n    lp->negrange = negrange;\n  else\n    lp->negrange = 0.0;\n}\n\nREAL __WINAPI get_negrange(lprec *lp)\n{\n  return(lp->negrange);\n}\n\nint __WINAPI get_max_level(lprec *lp)\n{\n  return(lp->bb_maxlevel);\n}\n\nCOUNTER __WINAPI get_total_nodes(lprec *lp)\n{\n  return(lp->bb_totalnodes);\n}\n\nCOUNTER __WINAPI get_total_iter(lprec *lp)\n{\n  return(lp->total_iter + lp->current_iter);\n}\n\nREAL __WINAPI get_objective(lprec *lp)\n{\n  if(!lp->basis_valid) {\n    report(lp, CRITICAL, \"get_objective: Not a valid basis\\n\");\n    return(0.0);\n  }\n\n  return( lp->best_solution[0] );\n}\n\nint __WINAPI get_nonzeros(lprec *lp)\n{\n  return( mat_nonzeros(lp->matA) );\n}\n\nMYBOOL __WINAPI set_mat(lprec *lp, int rownr, int colnr, REAL value)\n{\n  if((rownr < 0) || (rownr > lp->rows)) {\n    report(lp, IMPORTANT, \"set_mat: Row %d out of range\\n\", rownr);\n    return( FALSE );\n  }\n  if((colnr < 1) || (colnr > lp->columns)) {\n    report(lp, IMPORTANT, \"set_mat: Column %d out of range\\n\", colnr);\n    return( FALSE );\n  }\n\n#ifdef DoMatrixRounding\n  if(rownr == 0)\n    value = roundToPrecision(value, lp->matA->epsvalue);\n#endif\n  value = scaled_mat(lp, value, rownr, colnr);\n  if(rownr == 0) {\n    lp->orig_obj[colnr] = my_chsign(is_chsign(lp, rownr), value);\n    return( TRUE );\n  }\n  else\n    return( mat_setvalue(lp->matA, rownr, colnr, value, FALSE) );\n}\n\nREAL __WINAPI get_working_objective(lprec *lp)\n{\n  REAL value = 0.0;\n\n  if(!lp->basis_valid)\n    report(lp, CRITICAL, \"get_working_objective: Not a valid basis\\n\");\n  else if((lp->spx_status == RUNNING) && (lp->solutioncount == 0))\n    value = my_chsign(!is_maxim(lp), lp->rhs[0]);\n  else\n    value = lp->solution[0];\n\n  return(value);\n}\n\nREAL __WINAPI get_var_primalresult(lprec *lp, int index)\n{\n  if((index < 0) || (index > lp->presolve_undo->orig_sum)) {\n    report(lp, IMPORTANT, \"get_var_primalresult: Index %d out of range\\n\", index);\n    return( 0.0 );\n  }\n  if((lp->do_presolve & PRESOLVE_LASTMASKMODE) != PRESOLVE_NONE)\n    return( lp->full_solution[index] );\n  else\n    return( lp->best_solution[index] );\n}\n\nREAL __WINAPI get_var_dualresult(lprec *lp, int index)\n{\n  REAL *duals;\n\n  if((index < 0) || (index > lp->presolve_undo->orig_sum)) {\n    report(lp, IMPORTANT, \"get_var_dualresult: Index %d out of range\\n\", index);\n    return( 0.0 );\n  }\n\n  if(index == 0)\n    return( lp->best_solution[0] );\n\n  /* Make sure we actually have dual information available */\n  if(!get_ptr_sensitivity_rhs(lp, &duals, NULL, NULL))\n    return( 0.0 );\n  else\n    duals = ((lp->full_duals == NULL) ? lp->duals : lp->full_duals);\n  return( duals[index] );\n}\n\nMYBOOL __WINAPI get_variables(lprec *lp, REAL *var)\n{\n  if(!lp->basis_valid) {\n    report(lp, CRITICAL, \"get_variables: Not a valid basis\\n\");\n    return(FALSE);\n  }\n\n  MEMCOPY(var, lp->best_solution + (1 + lp->rows), lp->columns);\n  return(TRUE);\n}\n\nMYBOOL __WINAPI get_ptr_variables(lprec *lp, REAL **var)\n{\n  if(!lp->basis_valid) {\n    report(lp, CRITICAL, \"get_ptr_variables: Not a valid basis\\n\");\n    return(FALSE);\n  }\n\n  if(var != NULL)\n   *var = lp->best_solution + (1 + lp->rows);\n  return(TRUE);\n}\n\nMYBOOL __WINAPI get_constraints(lprec *lp, REAL *constr)\n{\n  if(!lp->basis_valid) {\n    report(lp, CRITICAL, \"get_constraints: Not a valid basis\\n\");\n    return(FALSE);\n  }\n\n  MEMCOPY(constr, lp->best_solution + 1, lp->rows);\n  return(TRUE);\n}\n\nMYBOOL __WINAPI get_ptr_constraints(lprec *lp, REAL **constr)\n{\n  if(!lp->basis_valid) {\n    report(lp, CRITICAL, \"get_ptr_constraints: Not a valid basis\\n\");\n    return(FALSE);\n  }\n\n  if(constr != NULL)\n   *constr = lp->best_solution + 1;\n  return(TRUE);\n}\n\nMYBOOL __WINAPI get_sensitivity_rhs(lprec *lp, REAL *duals, REAL *dualsfrom, REAL *dualstill)\n{\n  REAL *duals0, *dualsfrom0, *dualstill0;\n\n  if(!lp->basis_valid) {\n    report(lp, CRITICAL, \"get_sensitivity_rhs: Not a valid basis\\n\");\n    return(FALSE);\n  }\n\n  if(!get_ptr_sensitivity_rhs(lp,\n                              (duals != NULL) ? &duals0 : NULL,\n                              (dualsfrom != NULL) ? &dualsfrom0 : NULL,\n                              (dualstill != NULL) ? &dualstill0 : NULL))\n    return(FALSE);\n\n  if(duals != NULL)\n    MEMCOPY(duals, duals0, lp->sum);\n  if(dualsfrom != NULL)\n    MEMCOPY(dualsfrom, dualsfrom0, lp->sum);\n  if(dualstill != NULL)\n    MEMCOPY(dualstill, dualstill0, lp->sum);\n  return(TRUE);\n}\n\nMYBOOL __WINAPI get_ptr_sensitivity_rhs(lprec *lp, REAL **duals, REAL **dualsfrom, REAL **dualstill)\n{\n  if(!lp->basis_valid) {\n    report(lp, CRITICAL, \"get_ptr_sensitivity_rhs: Not a valid basis\\n\");\n    return(FALSE);\n  }\n\n  if(duals != NULL) {\n    if(lp->duals == NULL) {\n      if((MIP_count(lp) > 0) && (lp->bb_totalnodes > 0)) {\n        report(lp, CRITICAL, \"get_ptr_sensitivity_rhs: Sensitivity unknown\\n\");\n        return(FALSE);\n      }\n      if(!construct_duals(lp))\n        return(FALSE);\n    }\n    *duals = lp->duals + 1;\n  }\n\n  if((dualsfrom != NULL) || (dualstill != NULL)) {\n    if((lp->dualsfrom == NULL) || (lp->dualstill == NULL)) {\n      if((MIP_count(lp) > 0) && (lp->bb_totalnodes > 0)) {\n        report(lp, CRITICAL, \"get_ptr_sensitivity_rhs: Sensitivity unknown\\n\");\n        return(FALSE);\n      }\n      construct_sensitivity_duals(lp);\n      if((lp->dualsfrom == NULL) || (lp->dualstill == NULL))\n        return(FALSE);\n    }\n    if(dualsfrom != NULL)\n      *dualsfrom = lp->dualsfrom + 1;\n    if(dualstill != NULL)\n      *dualstill = lp->dualstill + 1;\n  }\n  return(TRUE);\n}\n\nMYBOOL __WINAPI get_sensitivity_objex(lprec *lp, REAL *objfrom, REAL *objtill, REAL *objfromvalue, REAL *objtillvalue)\n{\n  REAL *objfrom0, *objtill0, *objfromvalue0, *objtillvalue0;\n\n  if(!lp->basis_valid) {\n    report(lp, CRITICAL, \"get_sensitivity_objex: Not a valid basis\\n\");\n    return(FALSE);\n  }\n\n  if(!get_ptr_sensitivity_objex(lp, (objfrom != NULL) ? &objfrom0 : NULL,\n                                    (objtill != NULL) ? &objtill0 : NULL,\n                                    (objfromvalue != NULL) ? &objfromvalue0 : NULL,\n                                    (objtillvalue != NULL) ? &objtillvalue0 : NULL))\n    return(FALSE);\n\n  if((objfrom != NULL) && (objfrom0 != NULL))\n    MEMCOPY(objfrom, objfrom0, lp->columns);\n  if((objtill != NULL) && (objtill0 != NULL))\n    MEMCOPY(objtill, objtill0, lp->columns);\n  if((objfromvalue != NULL) && (objfromvalue0 != NULL))\n    MEMCOPY(objfromvalue, objfromvalue0, lp->columns);\n  if((objtillvalue != NULL) && (objtillvalue0 != NULL))\n    MEMCOPY(objtillvalue, objtillvalue0, lp->columns);\n  return(TRUE);\n}\n\nMYBOOL __WINAPI get_sensitivity_obj(lprec *lp, REAL *objfrom, REAL *objtill)\n{\n  return(get_sensitivity_objex(lp, objfrom, objtill, NULL, NULL));\n}\n\nMYBOOL __WINAPI get_ptr_sensitivity_objex(lprec *lp, REAL **objfrom, REAL **objtill, REAL **objfromvalue, REAL **objtillvalue)\n{\n  if(!lp->basis_valid) {\n    report(lp, CRITICAL, \"get_ptr_sensitivity_objex: Not a valid basis\\n\");\n    return(FALSE);\n  }\n\n  if((objfrom != NULL) || (objtill != NULL)) {\n    if((lp->objfrom == NULL) || (lp->objtill == NULL)) {\n      if((MIP_count(lp) > 0) && (lp->bb_totalnodes > 0)) {\n        report(lp, CRITICAL, \"get_ptr_sensitivity_objex: Sensitivity unknown\\n\");\n        return(FALSE);\n      }\n      construct_sensitivity_obj(lp);\n      if((lp->objfrom == NULL) || (lp->objtill == NULL))\n        return(FALSE);\n    }\n    if(objfrom != NULL)\n      *objfrom = lp->objfrom + 1;\n    if(objtill != NULL)\n      *objtill = lp->objtill + 1;\n  }\n\n  if((objfromvalue != NULL) /* || (objtillvalue != NULL) */) {\n    if((lp->objfromvalue == NULL) /* || (lp->objtillvalue == NULL) */) {\n      if((MIP_count(lp) > 0) && (lp->bb_totalnodes > 0)) {\n        report(lp, CRITICAL, \"get_ptr_sensitivity_objex: Sensitivity unknown\\n\");\n        return(FALSE);\n      }\n      construct_sensitivity_duals(lp);\n      if((lp->objfromvalue == NULL) /* || (lp->objtillvalue == NULL) */)\n        return(FALSE);\n    }\n  }\n\n  if(objfromvalue != NULL)\n    *objfromvalue = lp->objfromvalue + 1;\n\n  if(objtillvalue != NULL)\n    *objtillvalue = NULL /* lp->objtillvalue + 1 */;\n\n  return(TRUE);\n}\n\nMYBOOL __WINAPI get_ptr_sensitivity_obj(lprec *lp, REAL **objfrom, REAL **objtill)\n{\n  return(get_ptr_sensitivity_objex(lp, objfrom, objtill, NULL, NULL));\n}\n\nvoid __WINAPI set_solutionlimit(lprec *lp, int limit)\n{\n  lp->solutionlimit = limit;\n}\nint __WINAPI get_solutionlimit(lprec *lp)\n{\n  return(lp->solutionlimit);\n}\nint __WINAPI get_solutioncount(lprec *lp)\n{\n  return(lp->solutioncount);\n}\n\nint __WINAPI get_Nrows(lprec *lp)\n{\n  return(lp->rows);\n}\n\nint __WINAPI get_Norig_rows(lprec *lp)\n{\n  if(lp->varmap_locked)\n    return(lp->presolve_undo->orig_rows);\n  else\n    return(lp->rows);\n}\n\nint __WINAPI get_Lrows(lprec *lp)\n{\n  if(lp->matL == NULL)\n    return( 0 );\n  else\n    return( lp->matL->rows );\n}\n\nint __WINAPI get_Ncolumns(lprec *lp)\n{\n  return(lp->columns);\n}\n\nint __WINAPI get_Norig_columns(lprec *lp)\n{\n  if(lp->varmap_locked)\n    return(lp->presolve_undo->orig_columns);\n  else\n    return(lp->columns);\n}\n\n\n/* ---------------------------------------------------------------------------------- */\n/* Core routines for lp_solve                                                         */\n/* ---------------------------------------------------------------------------------- */\nint __WINAPI get_status(lprec *lp)\n{\n  return(lp->spx_status);\n}\n\nchar * __WINAPI get_statustext(lprec *lp, int statuscode)\n{\n  if (statuscode == NOBFP)             return(\"No basis factorization package\");\n  else if (statuscode == DATAIGNORED)  return(\"Invalid input data provided\");\n  else if (statuscode == NOMEMORY)     return(\"Not enough memory available\");\n  else if (statuscode == NOTRUN)       return(\"Model has not been optimized\");\n  else if (statuscode == OPTIMAL)      return(\"OPTIMAL solution\");\n  else if (statuscode == SUBOPTIMAL)   return(\"SUB-OPTIMAL solution\");\n  else if (statuscode == INFEASIBLE)   return(\"Model is primal INFEASIBLE\");\n  else if (statuscode == UNBOUNDED)    return(\"Model is primal UNBOUNDED\");\n  else if (statuscode == RUNNING)      return(\"lp_solve is currently running\");\n  else if (statuscode == NUMFAILURE)   return(\"NUMERIC FAILURE encountered\");\n  else if (statuscode == DEGENERATE)   return(\"DEGENERATE situation\");\n  else if (statuscode == USERABORT)    return(\"User-requested termination\");\n  else if (statuscode == TIMEOUT)      return(\"Termination due to timeout\");\n  else if (statuscode == PRESOLVED)    return(\"Model solved by presolve\");\n  else if (statuscode == PROCFAIL)     return(\"B&B routine failed\");\n  else if (statuscode == PROCBREAK)    return(\"B&B routine terminated\");\n  else if (statuscode == FEASFOUND)    return(\"Feasible B&B solution found\");\n  else if (statuscode == NOFEASFOUND)  return(\"No feasible B&B solution found\");\n  else if (statuscode == FATHOMED)     return(\"Fathomed/pruned branch\");\n  else                                 return(\"Undefined internal error\");\n}\n\nMYBOOL __WINAPI is_obj_in_basis(lprec *lp)\n{\n  return( lp->obj_in_basis );\n}\n\nvoid __WINAPI set_obj_in_basis(lprec *lp, MYBOOL obj_in_basis)\n{\n  lp->obj_in_basis = (MYBOOL) (obj_in_basis == TRUE);\n}\n\nlprec * __WINAPI make_lp(int rows, int columns)\n{\n  lprec *lp;\n\n  callcount++;\n  if(rows < 0 || columns < 0)\n    return(NULL);\n\n  lp = (lprec*) calloc(1, sizeof(*lp));\n  if(!lp)\n    return(NULL);\n\n  set_lp_name(lp, NULL);\n  lp->names_used    = FALSE;\n  lp->use_row_names = TRUE;\n  lp->use_col_names = TRUE;\n\n  /* Do standard initializations ------------------------------------------------------------ */\n#if 1\n  lp->obj_in_basis  = DEF_OBJINBASIS;\n#else\n  lp->obj_in_basis  = FALSE;\n#endif\n  lp->verbose       = NORMAL;\n  set_callbacks(lp);\n  set_BFP(lp, NULL);\n  set_XLI(lp, NULL);\n#if libBLAS > 0\n  init_BLAS();\n#if libBLAS > 1\n  if(is_nativeBLAS() && !load_BLAS(libnameBLAS))\n    /*report(lp, \"make_lp: Could not load external BLAS library '%s'.\\n\", libnameBLAS)*/;\n#endif\n#endif\n\n  /* Define the defaults for key user-settable values --------------------------------------- */\n  reset_params(lp);\n\n  /* Do other initializations --------------------------------------------------------------- */\n  lp->source_is_file    = FALSE;\n  lp->model_is_pure     = TRUE;\n  lp->model_is_valid    = FALSE;\n  lp->spx_status        = NOTRUN;\n  lp->lag_status        = NOTRUN;\n\n  lp->workarrays = mempool_create(lp);\n  lp->wasPreprocessed   = FALSE;\n  lp->wasPresolved      = FALSE;\n  presolve_createUndo(lp);\n\n  lp->bb_varactive      = NULL;\n  lp->bb_varbranch      = NULL;\n  lp->var_priority      = NULL;\n\n  lp->rhsmax            = 0.0;\n  lp->bigM              = 0.0;\n  lp->bb_deltaOF        = 0.0;\n\n  lp->equalities        = 0;\n  lp->fixedvars         = 0;\n  lp->int_vars          = 0;\n  lp->sc_vars           = 0;\n\n  lp->sos_ints          = 0;\n  lp->sos_vars          = 0;\n  lp->sos_priority      = NULL;\n\n  lp->rows_alloc        = 0;\n  lp->columns_alloc     = 0;\n  lp->sum_alloc         = 0;\n\n  lp->rows              = rows;\n  lp->columns           = columns;\n  lp->sum               = rows + columns;\n  varmap_clear(lp);\n\n  lp->matA = mat_create(lp, rows, columns, lp->epsvalue);\n  lp->matL = NULL;\n  lp->invB = NULL;\n  lp->duals = NULL;\n  lp->dualsfrom = NULL;\n  lp->dualstill = NULL;\n  lp->objfromvalue = NULL;\n  lp->objfrom = NULL;\n  lp->objtill = NULL;\n\n  inc_col_space(lp, columns + 1);\n  inc_row_space(lp, rows + 1);\n\n  /* Avoid bound-checker uninitialized variable error */\n  lp->orig_lowbo[0] = 0;\n\n  lp->rootbounds = NULL;\n  lp->bb_bounds = NULL;\n  lp->bb_basis = NULL;\n\n  lp->basis_valid       = FALSE;\n  lp->simplex_mode      = SIMPLEX_DYNAMIC;\n  lp->scaling_used      = FALSE;\n  lp->columns_scaled    = FALSE;\n  lp->P1extraDim        = 0;\n  lp->P1extraVal        = 0.0;\n  lp->bb_strongbranches = 0;\n  lp->current_iter      = 0;\n  lp->total_iter        = 0;\n  lp->current_bswap     = 0;\n  lp->total_bswap       = 0;\n  lp->solutioncount     = 0;\n  lp->solvecount        = 0;\n\n  allocINT(lp, &lp->rejectpivot, DEF_MAXPIVOTRETRY + 1, TRUE);\n\n  set_minim(lp);\n  set_infiniteex(lp, DEF_INFINITE, TRUE);\n\n  initPricer(lp);\n\n  /* Call-back routines by KE */\n  lp->ctrlc = NULL;\n  lp->ctrlchandle = NULL;\n  lp->writelog = NULL;\n  lp->loghandle = NULL;\n  lp->debuginfo = NULL;\n  lp->usermessage = NULL;\n  lp->msgmask = MSG_NONE;\n  lp->msghandle = NULL;\n\n  lp->timecreate = timeNow();\n  return(lp);\n}\n\nMYBOOL __WINAPI resize_lp(lprec *lp, int rows, int columns)\n{\n  MYBOOL status = TRUE;\n\n  if(columns > lp->columns)\n    status = inc_col_space(lp, columns - lp->columns);\n  else\n    while(status && (lp->columns > columns)) {\n      status = del_column(lp, lp->columns);\n    }\n  if(status && (rows > lp->rows))\n    status = inc_row_space(lp, rows - lp->rows);\n  else\n    while(status && (lp->rows > rows)) {\n      status = del_constraint(lp, lp->rows);\n    }\n  return( status );\n}\n\nvoid __WINAPI free_lp(lprec **plp)\n{\n  if(plp != NULL) {\n    lprec *lp = *plp;\n    if(lp != NULL)\n      delete_lp(lp);\n    *plp = NULL;\n  }\n}\n\nvoid __WINAPI delete_lp(lprec *lp)\n{\n  if(lp == NULL)\n    return;\n\n  FREE(lp->lp_name);\n  FREE(lp->ex_status);\n  if(lp->names_used) {\n    FREE(lp->row_name);\n    FREE(lp->col_name);\n    free_hash_table(lp->rowname_hashtab);\n    free_hash_table(lp->colname_hashtab);\n  }\n\n  mat_free(&lp->matA);\n  lp->bfp_free(lp);\n#if LoadInverseLib == TRUE\n  if(lp->hBFP != NULL)\n    set_BFP(lp, NULL);\n#endif\n#if LoadLanguageLib == TRUE\n  if(lp->hXLI != NULL)\n    set_XLI(lp, NULL);\n#endif\n\n  unset_OF_p1extra(lp);\n  FREE(lp->orig_obj);\n  FREE(lp->orig_rhs);\n  FREE(lp->rhs);\n  FREE(lp->var_type);\n  set_var_weights(lp, NULL);\n  FREE(lp->bb_varbranch);\n  FREE(lp->sc_lobound);\n  FREE(lp->var_is_free);\n  FREE(lp->orig_upbo);\n  FREE(lp->orig_lowbo);\n  FREE(lp->upbo);\n  FREE(lp->lowbo);\n  FREE(lp->var_basic);\n  FREE(lp->is_basic);\n  FREE(lp->is_lower);\n  if(lp->bb_PseudoCost != NULL) {\n/*    report(lp, SEVERE, \"delete_lp: The B&B pseudo-cost array was not cleared on delete\\n\"); */\n    free_pseudocost(lp);\n  }\n  if(lp->bb_bounds != NULL) {\n    report(lp, SEVERE, \"delete_lp: The stack of B&B levels was not empty (failed at %.0f nodes)\\n\",\n                       (double) lp->bb_totalnodes);\n    unload_BB(lp);\n  }\n  if(lp->bb_basis != NULL) {\n/*    report(lp, SEVERE, \"delete_lp: The stack of saved bases was not empty on delete\\n\"); */\n    unload_basis(lp, FALSE);\n  }\n\n  FREE(lp->rejectpivot);\n  partial_freeBlocks(&(lp->rowblocks));\n  partial_freeBlocks(&(lp->colblocks));\n  multi_free(&(lp->multivars));\n  multi_free(&(lp->longsteps));\n\n  FREE(lp->solution);\n  FREE(lp->best_solution);\n  FREE(lp->full_solution);\n\n  presolve_freeUndo(lp);\n  mempool_free(&(lp->workarrays));\n\n  freePricer(lp);\n\n  FREE(lp->drow);\n  FREE(lp->nzdrow);\n\n  FREE(lp->duals);\n  FREE(lp->full_duals);\n  FREE(lp->dualsfrom);\n  FREE(lp->dualstill);\n  FREE(lp->objfromvalue);\n  FREE(lp->objfrom);\n  FREE(lp->objtill);\n  FREE(lp->row_type);\n\n  if(lp->sos_vars > 0)\n    FREE(lp->sos_priority);\n  free_SOSgroup(&(lp->SOS));\n  free_SOSgroup(&(lp->GUB));\n  freecuts_BB(lp);\n\n  if(lp->scaling_used)\n    FREE(lp->scalars);\n  if(lp->matL != NULL) {\n    FREE(lp->lag_rhs);\n    FREE(lp->lambda);\n    FREE(lp->lag_con_type);\n    mat_free(&lp->matL);\n  }\n  if(lp->streamowned)\n    set_outputstream(lp, NULL);\n\n#if libBLAS > 0\n  if(!is_nativeBLAS())\n    unload_BLAS();\n#endif\n\n  FREE(lp);\n\n}\n\n/* Make a copy of the existing model using (mostly) high-level\n   construction routines to simplify future maintainance. */\nlprec* __WINAPI copy_lp(lprec *lp)\n{\n  int   i, n, *idx = NULL;\n  REAL  hold, *val = NULL;\n  lprec *newlp = NULL;\n\n#if 0\n  if(lp->wasPresolved)\n    return( newlp );\n#endif\n\n  if(!allocINT(lp, &idx, lp->rows+1, FALSE) ||\n     !allocREAL(lp, &val, lp->rows+1, FALSE))\n    goto Finish;\n\n  /* Create the new object */\n  newlp = make_lp(lp->rows, 0);\n  resize_lp(newlp, lp->rows, lp->columns);\n  set_sense(newlp, is_maxim(lp));\n\n  /* Transfer parameters */\n  set_epspivot(newlp, get_epspivot(lp));\n  set_epsel(newlp, get_epsel(lp));\n  set_epsb(newlp, get_epsb(lp));\n  set_epsd(newlp, get_epsd(lp));\n  set_epsint(newlp, get_epsint(lp));\n  set_pivoting(newlp, get_pivoting(lp));\n  set_negrange(newlp, lp->negrange);\n  set_infinite(newlp, get_infinite(lp));\n  set_presolve(newlp, get_presolve(lp), get_presolveloops(lp));\n  set_scaling(newlp, get_scaling(lp));\n  set_simplextype(newlp, get_simplextype(lp));\n\n  /* Set RHS and range */\n  for(i = 0; i <= lp->rows; i++) {\n    if(i > 0)\n      set_constr_type(newlp, 0, get_constr_type(lp, i));\n    set_rh(newlp, i, get_rh(lp, 0));\n    if((i > 0) && ((hold = get_rh_range(lp, i)) < lp->infinite))\n      set_rh_range(newlp, i, hold);\n    if(lp->names_used)\n      set_row_name(newlp, i, get_row_name(lp, i));\n  }\n  /* Load the constraint matrix and variable definitions */\n  for(i = 1; i <= lp->columns; i++) {\n    n = get_columnex(lp, i, val, idx);\n    add_columnex(newlp, n, val, idx);\n    if(is_binary(lp, i))\n      set_binary(newlp, i, TRUE);\n    else {\n      if(is_int(lp, i))\n        set_int(newlp, i, TRUE);\n      if((hold = get_lowbo(lp, i)) != 0)\n        set_lowbo(newlp, i, hold);\n      if((hold = get_upbo(lp, i)) < lp->infinite)\n        set_upbo(newlp, i, hold);\n    }\n    if(is_semicont(lp, i))\n      set_semicont(newlp, i, TRUE);\n    if(lp->names_used)\n      set_col_name(newlp, i, get_col_name(lp, i));\n  }\n\n  /* Other parameters set if the source model was previously solved */\n  if(lp->solvecount > 0) {\n    MEMCOPY(newlp->scalars, lp->scalars, lp->sum+1);\n    MEMCOPY(newlp->var_basic, lp->var_basic, lp->rows+1);\n    MEMCOPY(newlp->is_basic, lp->is_basic, lp->sum+1);\n    MEMCOPY(newlp->is_lower, lp->is_lower, lp->sum+1);\n    MEMCOPY(newlp->solution, lp->solution, lp->sum+1);\n    if(lp->duals != NULL) {\n      allocREAL(newlp, &newlp->duals, newlp->sum_alloc+1, FALSE);\n      MEMCOPY(newlp->duals, lp->duals, lp->sum+1);\n    }\n    newlp->solutioncount = lp->solutioncount;\n    newlp->solvecount = lp->solvecount;\n  }\n\n  /* Clean up before returning */\nFinish:\n  FREE(val);\n  FREE(idx);\n\n  return( newlp );\n}\nMYBOOL __WINAPI dualize_lp(lprec *lp)\n{\n  int     i, n;\n  MATrec  *mat = lp->matA;\n  REAL    *item;\n\n  /* Are we allowed to perform the operation? */\n  if((MIP_count(lp) > 0) || (lp->solvecount > 0))\n    return( FALSE );\n\n  /* Modify sense */\n  set_sense(lp, (MYBOOL) !is_maxim(lp));\n\n  /* Transpose matrix and reverse signs */\n  n = mat_nonzeros(mat);\n  mat_transpose(mat);\n  item = &COL_MAT_VALUE(0);\n  for(i = 0; i < n; i++, item += matValueStep)\n    *item *= -1;\n\n  /* Row-column swap other vectors */\n  swapINT(&lp->rows, &lp->columns);\n  swapINT(&lp->rows_alloc, &lp->columns_alloc);\n  swapREAL(lp->orig_rhs, lp->orig_obj);\n  swapREAL(lp->rhs, lp->obj);\n\n  /* Reallocate storage */\n/*\nvar_type\nsc_bound\nsolution\nbest_solution\nfull_solution\nduals\n*/\n\n  /* Shift variable bounds */\n/*\nis_basic\norig_upbo\norig_lowbo\nscalars\n*/\n\n  return( TRUE );\n}\n\n/* Optimize memory usage */\nSTATIC MYBOOL memopt_lp(lprec *lp, int rowextra, int colextra, int nzextra)\n{\n  MYBOOL status = FALSE;\n\n  if(lp == NULL)\n    return( status );\n\n  status = mat_memopt(lp->matA, rowextra, colextra, nzextra) &&\n           (++rowextra > 0) && (++colextra > 0) && (++nzextra > 0);\n\n#if 0 /* inc_ routines not well-tested for reduction in size allocation */\n  if(status) {\n    int colalloc = lp->columns_alloc - MIN(lp->columns_alloc, lp->columns + colextra),\n        rowalloc = lp->rows_alloc    - MIN(lp->rows_alloc,    lp->rows + rowextra);\n\n    status = inc_lag_space(lp, rowalloc, FALSE) &&\n             inc_row_space(lp, rowalloc) &&\n             inc_col_space(lp, colalloc);\n  }\n#endif\n\n  return( status );\n}\n\n\n/* Utility routine group for constraint and column deletion/insertion\n   mapping in relation to the original set of constraints and columns */\nSTATIC void varmap_lock(lprec *lp)\n{\n  presolve_fillUndo(lp, lp->rows, lp->columns, TRUE);\n  lp->varmap_locked = TRUE;\n}\nSTATIC void varmap_clear(lprec *lp)\n{\n  presolve_setOrig(lp, 0, 0);\n  lp->varmap_locked = FALSE;\n}\nSTATIC MYBOOL varmap_canunlock(lprec *lp)\n{\n  /* Don't do anything if variables aren't locked yet */\n  if(lp->varmap_locked) {\n    int i;\n    presolveundorec *psundo = lp->presolve_undo;\n\n    /* Check for the obvious */\n    if(/*lp->names_used ||\n       (psundo->orig_columns != lp->columns) || (psundo->orig_rows != lp->rows)) */\n       (psundo->orig_columns > lp->columns) || (psundo->orig_rows > lp->rows))\n      return( FALSE );\n\n    /* Check for deletions */\n    for(i = psundo->orig_rows + psundo->orig_columns; i > 0; i--)\n      if(psundo->orig_to_var[i] == 0)\n        return( FALSE );\n\n    /* Check for insertions */\n    for(i = lp->sum; i > 0; i--)\n      if(psundo->var_to_orig[i] == 0)\n        return( FALSE );\n  }\n  return( TRUE );\n}\nSTATIC void varmap_add(lprec *lp, int base, int delta)\n{\n  int i, ii;\n  presolveundorec *psundo = lp->presolve_undo;\n\n  /* Don't do anything if variables aren't locked yet */\n  if(!lp->varmap_locked)\n    return;\n\n  /* Set new constraints/columns to have an \"undefined\" mapping to original\n     constraints/columns (assumes that counters have NOT yet been updated) */\n  for(i = lp->sum; i >= base; i--) {\n    ii = i + delta;\n    psundo->var_to_orig[ii] = psundo->var_to_orig[i];\n  }\n\n  /* Initialize map of added rows/columns */\n  for(i = 0; i < delta; i++) {\n    ii = base + i;\n    psundo->var_to_orig[ii] = 0;\n  }\n}\n\nSTATIC void varmap_delete(lprec *lp, int base, int delta, LLrec *varmap)\n{\n  int             i, ii, j;\n  MYBOOL          preparecompact;\n  presolveundorec *psundo = lp->presolve_undo;\n\n  /* Set the model \"dirty\" if we are deleting row of constraint */\n  lp->model_is_pure  = FALSE;\n\n  /* Don't do anything if\n     1) variables aren't locked yet, or\n     2) the constraint was added after the variables were locked */\n  if(!lp->varmap_locked) {\n#if 1\n   if(lp->names_used)\n     varmap_lock(lp);\n   else\n#endif\n     return;\n  }\n\n  /* Do mass deletion via a linked list */\n  preparecompact = (MYBOOL) (varmap != NULL);\n  if(preparecompact) {\n    preparecompact = (MYBOOL) (base > lp->rows);  /* Set TRUE for columns */\n    for(j = firstInactiveLink(varmap); j != 0; j = nextInactiveLink(varmap, j)) {\n      i = j;\n      if(preparecompact) {\n#ifdef Paranoia\n        if(SOS_is_member(lp->SOS, 0, j))\n          report(lp, SEVERE, \"varmap_delete: Deleting variable %d, which is in a SOS!\\n\", j);\n#endif\n        i += lp->rows;\n      }\n      ii = psundo->var_to_orig[i];\n      if(ii > 0)  /* It was an original variable; reverse sign of index to flag deletion */\n        psundo->var_to_orig[i] = -ii;\n      else        /* It was a non-original variable; add special code for deletion */\n        psundo->var_to_orig[i] = -(psundo->orig_rows+psundo->orig_columns+i);\n    }\n    return;\n  }\n\n  /* Do legacy simplified version if we are doing batch delete operations */\n  preparecompact = (MYBOOL) (base < 0);\n  if(preparecompact) {\n    base = -base;\n    if(base > lp->rows)\n      base += (psundo->orig_rows - lp->rows);\n    for(i = base; i < base-delta; i++) {\n      ii = psundo->var_to_orig[i];\n      if(ii > 0)  /* It was an original variable; reverse sign of index to flag deletion */\n        psundo->var_to_orig[i] = -ii;\n      else       /* It was a non-original variable; add special code for deletion */\n        psundo->var_to_orig[i] = -(psundo->orig_rows+psundo->orig_columns+i);\n    }\n    return;\n  }\n\n  /* We are deleting an original constraint/column;\n     1) clear mapping of original to deleted\n     2) shift the deleted variable to original mappings left\n     3) decrement all subsequent original-to-current pointers\n  */\n  for(i = base; i < base-delta; i++) {\n    ii = psundo->var_to_orig[i];\n    if(ii > 0)\n      psundo->orig_to_var[ii] = 0;\n  }\n  for(i = base; i <= lp->sum+delta; i++) {\n    ii = i - delta;\n    psundo->var_to_orig[i] = psundo->var_to_orig[ii];\n  }\n\n  i = 1;\n  j = psundo->orig_rows;\n  if(base > lp->rows) {\n    i += j;\n    j += psundo->orig_columns;\n  }\n  ii = base-delta;\n  for(; i <= j; i++) {\n    if(psundo->orig_to_var[i] >= ii)\n      psundo->orig_to_var[i] += delta;\n  }\n\n}\n\nSTATIC MYBOOL varmap_validate(lprec *lp, int varno)\n{\n  MYBOOL success = TRUE;\n  int i, ii, ix, ie,\n       n_rows = lp->rows,\n       orig_sum = lp->presolve_undo->orig_sum,\n       orig_rows = lp->presolve_undo->orig_rows;\n\n  if(varno <= 0) {\n    varno = 1;\n    ie = orig_sum;\n  }\n  else\n    ie = varno;\n  for(i = varno; success && (i <= ie); i++) {\n    ix = lp->presolve_undo->orig_to_var[i];\n    if((ix > 0) && (i > orig_rows))\n      ix += n_rows;\n\n    /* Check for index out of range due to presolve */\n    success = (MYBOOL) (ix <= orig_sum);\n    if(!success)\n      report(lp, SEVERE, \"varmap_validate: Invalid new mapping found for variable %d\\n\",\n                           i);\n    else if(ix != 0) {\n      ii = lp->presolve_undo->var_to_orig[ix];\n      if(ix > n_rows)\n        ii += orig_rows;\n      success = (MYBOOL) (ii == i);\n      if(!success)\n        report(lp, SEVERE, \"varmap_validate: Invalid old mapping found for variable %d (%d)\\n\",\n                           i, ii);\n    }\n  }\n  return( success );\n}\n\nSTATIC void varmap_compact(lprec *lp, int prev_rows, int prev_cols)\n{\n  presolveundorec *psundo = lp->presolve_undo;\n  int             i, ii, n_sum, n_rows,\n                  orig_rows = psundo->orig_rows,\n                  prev_sum = prev_rows + prev_cols;\n\n  /* Nothing to do if the model is not \"dirty\" or the variable map is not locked */\n  if(lp->model_is_pure || !lp->varmap_locked)\n    return;\n\n  /* We are deleting an original constraint/column;\n     1) clear mapping of original to deleted\n     2) shift the deleted variable to original mappings left\n     3) decrement all subsequent original-to-current pointers\n  */\n  n_sum = 0;\n  n_rows = 0;\n  for(i = 1; i <= prev_sum; i++) {\n    ii = psundo->var_to_orig[i];\n\n    /* Process variable if it was deleted in the previous round */\n    if(ii < 0) {\n      ii = -ii;\n      /* Update map back if we have an original variable, otherwise just skip */\n      if(i <= prev_rows)\n        psundo->orig_to_var[ii] = 0;\n      else\n        psundo->orig_to_var[orig_rows+ii] = 0;\n    }\n    /* Otherwise shift and update map back */\n    else {\n      n_sum++;\n      /* Shift only if necessary */\n      if(n_sum < i)\n        psundo->var_to_orig[n_sum] = ii;\n      /* Update map back if we have an original variable */\n      if(ii > 0) {\n        if(i <= prev_rows) {\n          psundo->orig_to_var[ii] = n_sum;\n          n_rows = n_sum;\n        }\n        else\n          psundo->orig_to_var[orig_rows+ii] = n_sum-n_rows;\n      }\n    }\n  }\n#ifdef xxParanoia\n  if(!varmap_validate(lp, 0))\n    report(lp, SEVERE, \"varmap_compact: Internal presolve mapping error at exit\\n\");\n#endif\n\n}\n\n/* Utility group for shifting row and column data */\nSTATIC MYBOOL shift_rowcoldata(lprec *lp, int base, int delta, LLrec *usedmap, MYBOOL isrow)\n/* Note: Assumes that \"lp->sum\" and \"lp->rows\" HAVE NOT been updated to the new counts */\n{\n  int  i, ii;\n  REAL lodefault;\n\n  /* Shift data right/down (insert), and set default values in positive delta-gap */\n  if(delta > 0) {\n\n    /* Determine if we can take the easy way out */\n    MYBOOL easyout = (MYBOOL) ((lp->solvecount == 0) && (base > lp->rows));\n\n    /* Shift the row/column data */\n\n    MEMMOVE(lp->orig_upbo + base + delta, lp->orig_upbo + base, lp->sum - base + 1);\n    MEMMOVE(lp->orig_lowbo + base + delta, lp->orig_lowbo + base, lp->sum - base + 1);\n\n    if(!easyout) {\n      MEMMOVE(lp->upbo + base + delta, lp->upbo + base, lp->sum - base + 1);\n      MEMMOVE(lp->lowbo + base + delta, lp->lowbo + base, lp->sum - base + 1);\n      if(lp->model_is_valid) {\n        MEMMOVE(lp->solution + base + delta, lp->solution + base, lp->sum - base + 1);\n        MEMMOVE(lp->best_solution + base + delta, lp->best_solution + base, lp->sum - base + 1);\n      }\n      MEMMOVE(lp->is_lower + base + delta, lp->is_lower + base, lp->sum - base + 1);\n    }\n\n    /* Deal with scalars; the vector can be NULL */\n    if(lp->scalars != NULL) {\n      if(!easyout)\n        for(ii = lp->sum; ii >= base; ii--) {\n          i = ii + delta;\n          lp->scalars[i] = lp->scalars[ii];\n        }\n      for(ii = base; ii < base + delta; ii++)\n        lp->scalars[ii] = 1;\n    }\n\n    /* Set defaults */\n#ifdef SlackInitMinusInf\n    if(isrow)\n      lodefault = -lp->infinite;\n    else\n#endif\n      lodefault = 0;\n\n    for(i = 0; i < delta; i++) {\n      ii = base + i;\n      lp->orig_upbo[ii] = lp->infinite;\n      lp->orig_lowbo[ii] = lodefault;\n      if(!easyout) {\n        lp->upbo[ii] = lp->orig_upbo[ii];\n        lp->lowbo[ii] = lp->orig_lowbo[ii];\n        lp->is_lower[ii] = TRUE;\n      }\n    }\n  }\n\n  /* Shift data left/up (delete) */\n  else if(usedmap != NULL) {\n    int k, offset = 0;\n    if(!isrow)\n      offset += lp->rows;\n    i = offset + 1;\n    for(k = firstActiveLink(usedmap); k != 0;\n        i++, k = nextActiveLink(usedmap, k)) {\n      ii = k + offset;\n      if(ii == i)\n        continue;\n      lp->upbo[i] = lp->upbo[ii];\n      lp->orig_upbo[i] = lp->orig_upbo[ii];\n      lp->lowbo[i] = lp->lowbo[ii];\n      lp->orig_lowbo[i] = lp->orig_lowbo[ii];\n      lp->solution[i] = lp->solution[ii];\n      lp->best_solution[i] = lp->best_solution[ii];\n      lp->is_lower[i] = lp->is_lower[ii];\n      if(lp->scalars != NULL)\n        lp->scalars[i] = lp->scalars[ii];\n    }\n    if(isrow) {\n      base = lp->rows + 1;\n      MEMMOVE(lp->upbo + i, lp->upbo + base, lp->columns);\n      MEMMOVE(lp->orig_upbo + i, lp->orig_upbo + base, lp->columns);\n      MEMMOVE(lp->lowbo + i, lp->lowbo + base, lp->columns);\n      MEMMOVE(lp->orig_lowbo + i, lp->orig_lowbo + base, lp->columns);\n      if(lp->model_is_valid) {\n        MEMMOVE(lp->solution + i, lp->solution + base, lp->columns);\n        MEMMOVE(lp->best_solution + i, lp->best_solution + base, lp->columns);\n      }\n      MEMMOVE(lp->is_lower + i, lp->is_lower + base, lp->columns);\n      if(lp->scalars != NULL)\n        MEMMOVE(lp->scalars + i, lp->scalars + base, lp->columns);\n    }\n  }\n\n  else if(delta < 0) {\n\n    /* First make sure we don't cross the sum count border */\n    if(base-delta-1 > lp->sum)\n      delta = base - lp->sum - 1;\n\n    /* Shift the data*/\n    for(i = base; i <= lp->sum + delta; i++) {\n      ii = i - delta;\n      lp->upbo[i] = lp->upbo[ii];\n      lp->orig_upbo[i] = lp->orig_upbo[ii];\n      lp->lowbo[i] = lp->lowbo[ii];\n      lp->orig_lowbo[i] = lp->orig_lowbo[ii];\n      lp->solution[i] = lp->solution[ii];\n      lp->best_solution[i] = lp->best_solution[ii];\n      lp->is_lower[i] = lp->is_lower[ii];\n      if(lp->scalars != NULL)\n        lp->scalars[i] = lp->scalars[ii];\n    }\n\n  }\n\n  lp->sum += delta;\n\n  lp->matA->row_end_valid = FALSE;\n\n  return(TRUE);\n}\n\nSTATIC MYBOOL shift_basis(lprec *lp, int base, int delta, LLrec *usedmap, MYBOOL isrow)\n/* Note: Assumes that \"lp->sum\" and \"lp->rows\" HAVE NOT been updated to the new counts */\n{\n  int i, ii;\n  MYBOOL Ok = TRUE;\n\n  /* Don't bother to shift the basis if it is not yet ready */\n  if(!is_BasisReady(lp))\n    return( Ok );\n\n  /* Basis adjustments due to insertions (after actual row/column insertions) */\n  if(delta > 0) {\n\n    /* Determine if the basis becomes invalidated */\n    if(isrow)\n      set_action(&lp->spx_action, ACTION_REBASE | ACTION_REINVERT);\n\n    /* Shift and fix invalid basis references (increment higher order basic variable index) */\n    if(base <= lp->sum)\n      MEMMOVE(lp->is_basic + base + delta, lp->is_basic + base, lp->sum - base + 1);\n\n    /* Prevent CPU-expensive basis updating if this is the initial model creation */\n    if(!lp->model_is_pure || (lp->solvecount > 0))\n      for(i = 1; i <= lp->rows; i++) {\n        ii = lp->var_basic[i];\n        if(ii >= base)\n          lp->var_basic[i] += delta;\n      }\n\n    /* Update the basis (shift and extend) */\n    for(i = 0; i < delta; i++) {\n      ii = base + i;\n      lp->is_basic[ii] = isrow;\n      if(isrow)\n        lp->var_basic[lp->rows+1+i] = ii;\n    }\n\n  }\n  /* Basis adjustments due to deletions (after actual row/column deletions) */\n  else {\n    int j,k;\n\n    /* Fix invalid basis references (decrement high basic slack variable indexes),\n       but reset the entire basis if a deleted variable is found in the basis */\n    k = 0;\n    for(i = 1; i <= lp->rows; i++) {\n      ii = lp->var_basic[i];\n      lp->is_basic[ii] = FALSE;\n      if(ii >= base) {\n       /* Skip to next basis variable if this one is to be deleted */\n        if(ii < base-delta) {\n          set_action(&lp->spx_action, ACTION_REBASE);\n          continue;\n        }\n       /* Otherwise, update the index of the basic variable for deleted variables */\n        ii += delta;\n      }\n      k++;\n      lp->var_basic[k] = ii;\n    }\n\n    /* Set the new basis indicators */\n    i = k;\n    if(isrow)\n      i = MIN(k, lp->rows+delta);\n    for(; i > 0; i--) {\n      j = lp->var_basic[i];\n      lp->is_basic[j] = TRUE;\n    }\n\n    /* If a column was deleted from the basis then simply add back a non-basic\n       slack variable; do two scans, if necessary to avoid adding equality slacks */\n    if(!isrow && (k < lp->rows)) {\n      for(j = 0; j <= 1; j++)\n      for(i = 1; (i <= lp->rows) && (k < lp->rows); i++)\n        if(!lp->is_basic[i]) {\n          if(!is_constr_type(lp, i, EQ) || (j == 1)) {\n            k++;\n            lp->var_basic[k] = i;\n            lp->is_basic[i] = TRUE;\n          }\n        }\n      k = 0;\n    }\n\n    /* We are left with \"k\" indexes; if no basis variable was deleted, k=rows and the\n       inverse is still valid, if k+delta < 0 we do not have a valid\n       basis and must create one (in most usage modes this should not happen,\n       unless there is a bug) */\n    if(k+delta < 0)\n      Ok = FALSE;\n    if(isrow || (k != lp->rows))\n      set_action(&lp->spx_action, ACTION_REINVERT);\n\n  }\n  return(Ok);\n\n}\n\nSTATIC MYBOOL shift_rowdata(lprec *lp, int base, int delta, LLrec *usedmap)\n/* Note: Assumes that \"lp->rows\" HAS NOT been updated to the new count */\n{\n  int i, ii;\n\n  /* Shift sparse matrix row data */\n  if(lp->matA->is_roworder)\n    mat_shiftcols(lp->matA, &base, delta, usedmap);\n  else\n    mat_shiftrows(lp->matA, &base, delta, usedmap);\n\n  /* Shift data down (insert row), and set default values in positive delta-gap */\n  if(delta > 0) {\n\n    /* Shift row data */\n    for(ii = lp->rows; ii >= base; ii--) {\n      i = ii + delta;\n      lp->orig_rhs[i] = lp->orig_rhs[ii];\n      lp->rhs[i] = lp->rhs[ii];\n      lp->row_type[i] = lp->row_type[ii];\n    }\n\n    /* Set defaults (actual basis set in separate procedure) */\n    for(i = 0; i < delta; i++) {\n      ii = base + i;\n      lp->orig_rhs[ii] = 0;\n      lp->rhs[ii] = 0;\n      lp->row_type[ii] = ROWTYPE_EMPTY;\n    }\n  }\n\n  /* Shift data up (delete row) */\n  else if(usedmap != NULL) {\n    for(i = 1, ii = firstActiveLink(usedmap); ii != 0;\n        i++, ii = nextActiveLink(usedmap, ii)) {\n      if(i == ii)\n        continue;\n      lp->orig_rhs[i] = lp->orig_rhs[ii];\n      lp->rhs[i] = lp->rhs[ii];\n      lp->row_type[i] = lp->row_type[ii];\n    }\n    delta = i - lp->rows - 1;\n  }\n  else if(delta < 0) {\n\n    /* First make sure we don't cross the row count border */\n    if(base-delta-1 > lp->rows)\n      delta = base - lp->rows - 1;\n\n    /* Shift row data (don't shift basis indexes here; done in next step) */\n    for(i = base; i <= lp->rows + delta; i++) {\n      ii = i - delta;\n      lp->orig_rhs[i] = lp->orig_rhs[ii];\n      lp->rhs[i] = lp->rhs[ii];\n      lp->row_type[i] = lp->row_type[ii];\n    }\n  }\n\n  shift_basis(lp, base, delta, usedmap, TRUE);\n  shift_rowcoldata(lp, base, delta, usedmap, TRUE);\n  inc_rows(lp, delta);\n\n  return(TRUE);\n}\n\nSTATIC MYBOOL shift_coldata(lprec *lp, int base, int delta, LLrec *usedmap)\n/* Note: Assumes that \"lp->columns\" has NOT been updated to the new count */\n{\n  int i, ii;\n\n  free_duals(lp);\n\n  /* Shift A matrix data */\n  if(lp->matA->is_roworder)\n    mat_shiftrows(lp->matA, &base, delta, usedmap);\n  else\n    mat_shiftcols(lp->matA, &base, delta, usedmap);\n\n  /* Shift data right (insert), and set default values in positive delta-gap */\n  if(delta > 0) {\n\n    /* Fix variable priority data */\n    if((lp->var_priority != NULL) && (base <= lp->columns)) {\n      for(i = 0; i < lp->columns; i++)\n        if(lp->var_priority[i] >= base)\n          lp->var_priority[i] += delta;\n    }\n    if((lp->sos_priority != NULL) && (base <= lp->columns)) {\n      for(i = 0; i < lp->sos_vars; i++)\n        if(lp->sos_priority[i] >= base)\n          lp->sos_priority[i] += delta;\n    }\n\n    /* Fix invalid split variable data */\n    if((lp->var_is_free != NULL) && (base <= lp->columns)) {\n      for(i = 1; i <= lp->columns; i++)\n        if(abs(lp->var_is_free[i]) >= base)\n          lp->var_is_free[i] += my_chsign(lp->var_is_free[i] < 0, delta);\n    }\n\n    /* Shift column data right */\n    for(ii = lp->columns; ii >= base; ii--) {\n      i = ii + delta;\n      lp->var_type[i] = lp->var_type[ii];\n      lp->sc_lobound[i] = lp->sc_lobound[ii];\n      lp->orig_obj[i] = lp->orig_obj[ii];\n      if(lp->obj != NULL)\n        lp->obj[i] = lp->obj[ii];\n/*\n      if(lp->objfromvalue != NULL)\n        lp->objfromvalue[i] = lp->objfromvalue[ii];\n      if(lp->objfrom != NULL)\n        lp->objfrom[i] = lp->objfrom[ii];\n      if(lp->objtill != NULL)\n        lp->objtill[i] = lp->objtill[ii];\n*/\n      if(lp->var_priority != NULL)\n        lp->var_priority[i-1] = lp->var_priority[ii-1];\n      if(lp->bb_varbranch != NULL)\n        lp->bb_varbranch[i-1] = lp->bb_varbranch[ii-1];\n      if(lp->var_is_free != NULL)\n        lp->var_is_free[i] = lp->var_is_free[ii];\n      if(lp->best_solution != NULL)\n        lp->best_solution[lp->rows + i] = lp->best_solution[lp->rows + ii];\n    }\n\n    /* Set defaults */\n    for(i = 0; i < delta; i++) {\n      ii = base + i;\n      lp->var_type[ii] = ISREAL;\n      lp->sc_lobound[ii] = 0;\n      lp->orig_obj[ii] = 0;\n      if(lp->obj != NULL)\n        lp->obj[ii] = 0;\n/*\n      if(lp->objfromvalue != NULL)\n        lp->objfromvalue[ii] = 0;\n      if(lp->objfrom != NULL)\n        lp->objfrom[ii] = 0;\n      if(lp->objtill != NULL)\n        lp->objtill[ii] = 0;\n*/\n      if(lp->var_priority != NULL)\n        lp->var_priority[ii-1] = ii;\n      if(lp->bb_varbranch != NULL)\n        lp->bb_varbranch[ii-1] = BRANCH_DEFAULT;\n      if(lp->var_is_free != NULL)\n        lp->var_is_free[ii] = 0;\n      if(lp->best_solution != NULL)\n        lp->best_solution[lp->rows + ii] = 0;\n    }\n  }\n\n  /* Shift data left (delete) */\n  else if(usedmap != NULL) {\n    /* Assume there is no need to handle split columns, since we are doing\n       this only from presolve, which comes before splitting of columns. */\n\n    /* First update counts */\n    if(lp->int_vars + lp->sc_vars > 0)\n    for(ii = firstInactiveLink(usedmap); ii != 0; ii = nextInactiveLink(usedmap, ii)) {\n      if(is_int(lp, ii)) {\n        lp->int_vars--;\n        if(SOS_is_member(lp->SOS, 0, ii))\n          lp->sos_ints--;\n      }\n      if(is_semicont(lp, ii))\n        lp->sc_vars--;\n    }\n    /* Shift array members */\n    for(i = 1, ii = firstActiveLink(usedmap); ii != 0;\n        i++, ii = nextActiveLink(usedmap, ii)) {\n      if(i == ii)\n        continue;\n      lp->var_type[i] = lp->var_type[ii];\n      lp->sc_lobound[i] = lp->sc_lobound[ii];\n      lp->orig_obj[i] = lp->orig_obj[ii];\n      if(lp->obj != NULL)\n        lp->obj[i] = lp->obj[ii];\n/*\n      if(lp->objfromvalue != NULL)\n        lp->objfromvalue[i] = lp->objfromvalue[ii];\n      if(lp->objfrom != NULL)\n        lp->objfrom[i] = lp->objfrom[ii];\n      if(lp->objtill != NULL)\n        lp->objtill[i] = lp->objtill[ii];\n*/\n      if(lp->bb_varbranch != NULL)\n        lp->bb_varbranch[i-1] = lp->bb_varbranch[ii-1];\n      if(lp->var_is_free != NULL)\n        lp->var_is_free[i] = lp->var_is_free[ii];\n      if(lp->best_solution != NULL)\n        lp->best_solution[lp->rows + i] = lp->best_solution[lp->rows + ii];\n    }\n    /* Shift variable priority data */\n    if((lp->var_priority != NULL) || (lp->sos_priority != NULL)) {\n      int *colmap = NULL, k;\n      allocINT(lp, &colmap, lp->columns + 1, TRUE);\n      for(i = 1, ii = 0; i <= lp->columns; i++) {\n        if(isActiveLink(usedmap, i)) {\n          ii++;\n          colmap[i] = ii;\n        }\n      }\n      if(lp->var_priority != NULL) {\n        for(i = 0, ii = 0; i < lp->columns; i++) {\n          k = colmap[lp->var_priority[i]];\n          if(k > 0) {\n            lp->var_priority[ii] = k;\n            ii++;\n          }\n        }\n      }\n      if(lp->sos_priority != NULL) {\n        for(i = 0, ii = 0; i < lp->sos_vars; i++) {\n          k = colmap[lp->sos_priority[i]];\n          if(k > 0) {\n            lp->sos_priority[ii] = k;\n            ii++;\n          }\n        }\n        lp->sos_vars = ii;\n      }\n      FREE(colmap);\n    }\n\n    delta = i - lp->columns - 1;\n  }\n  else if(delta < 0) {\n\n    /* Fix invalid split variable data */\n    if(lp->var_is_free != NULL) {\n      for(i = 1; i <= lp->columns; i++)\n        if(abs(lp->var_is_free[i]) >= base)\n          lp->var_is_free[i] -= my_chsign(lp->var_is_free[i] < 0, delta);\n    }\n\n    /* Shift column data (excluding the basis) */\n    for(i = base; i < base-delta; i++) {\n      if(is_int(lp, i)) {\n        lp->int_vars--;\n        if(SOS_is_member(lp->SOS, 0, i))\n          lp->sos_ints--;\n      }\n      if(is_semicont(lp, i))\n        lp->sc_vars--;\n    }\n    for(i = base; i <= lp->columns + delta; i++) {\n      ii = i - delta;\n      lp->var_type[i] = lp->var_type[ii];\n      lp->sc_lobound[i] = lp->sc_lobound[ii];\n      lp->orig_obj[i] = lp->orig_obj[ii];\n      if(lp->obj != NULL)\n        lp->obj[i] = lp->obj[ii];\n/*\n      if(lp->objfromvalue != NULL)\n        lp->objfromvalue[i] = lp->objfromvalue[ii];\n      if(lp->objfrom != NULL)\n        lp->objfrom[i] = lp->objfrom[ii];\n      if(lp->objtill != NULL)\n        lp->objtill[i] = lp->objtill[ii];\n*/\n      if(lp->var_priority != NULL)\n        lp->var_priority[i-1] = lp->var_priority[ii-1];\n      if(lp->bb_varbranch != NULL)\n        lp->bb_varbranch[i-1] = lp->bb_varbranch[ii-1];\n      if(lp->var_is_free != NULL)\n        lp->var_is_free[i] = lp->var_is_free[ii];\n      if(lp->best_solution != NULL)\n        lp->best_solution[lp->rows + i] = lp->best_solution[lp->rows + ii];\n    }\n\n    /* Fix invalid variable priority data */\n    if(lp->var_priority != NULL) {\n      for(i = 0, ii = 0; i < lp->columns; i++)\n        if(lp->var_priority[i] > base - delta)\n          lp->var_priority[ii++] = lp->var_priority[i] + delta;\n        else if(lp->var_priority[i] < base)\n          lp->var_priority[ii++] = lp->var_priority[i];\n    }\n    if(lp->sos_priority != NULL) {\n      for(i = 0, ii = 0; i < lp->sos_vars; i++) {\n        if(lp->sos_priority[i] > base - delta)\n          lp->sos_priority[ii++] = lp->sos_priority[i] + delta;\n        else if(lp->sos_priority[i] < base)\n          lp->sos_priority[ii++] = lp->sos_priority[i];\n      }\n      lp->sos_vars = ii;\n    }\n\n  }\n\n  shift_basis(lp, lp->rows+base, delta, usedmap, FALSE);\n  if(SOS_count(lp) > 0)\n    SOS_shift_col(lp->SOS, 0, base, delta, usedmap, FALSE);\n  shift_rowcoldata(lp, lp->rows+base, delta, usedmap, FALSE);\n  inc_columns(lp, delta);\n\n  return( TRUE );\n}\n\n/* Utility group for incrementing row and column vector storage space */\nSTATIC void inc_rows(lprec *lp, int delta)\n{\n  lp->rows += delta;\n  if(lp->matA->is_roworder)\n    lp->matA->columns += delta;\n  else\n    lp->matA->rows += delta;\n}\n\nSTATIC void inc_columns(lprec *lp, int delta)\n{\n  lp->columns += delta;\n  if(lp->matA->is_roworder)\n    lp->matA->rows += delta;\n  else\n    lp->matA->columns += delta;\n  if(get_Lrows(lp) > 0)\n    lp->matL->columns += delta;\n}\n\nSTATIC MYBOOL inc_rowcol_space(lprec *lp, int delta, MYBOOL isrows)\n{\n  int i, oldrowcolalloc, rowcolsum;\n\n  /* Get rid of dual arrays */\n  if(lp->solvecount > 0)\n    free_duals(lp);\n\n  /* Set constants */\n  oldrowcolalloc = lp->sum_alloc;\n  lp->sum_alloc += delta;\n  rowcolsum = lp->sum_alloc + 1;\n\n  /* Reallocate lp memory */\n  if(!allocREAL(lp, &lp->upbo, rowcolsum, AUTOMATIC) ||\n     !allocREAL(lp, &lp->orig_upbo, rowcolsum, AUTOMATIC) ||\n     !allocREAL(lp, &lp->lowbo, rowcolsum, AUTOMATIC) ||\n     !allocREAL(lp, &lp->orig_lowbo, rowcolsum, AUTOMATIC) ||\n     !allocREAL(lp, &lp->solution, rowcolsum, AUTOMATIC) ||\n     !allocREAL(lp, &lp->best_solution, rowcolsum, AUTOMATIC) ||\n     !allocMYBOOL(lp, &lp->is_basic, rowcolsum, AUTOMATIC) ||\n     !allocMYBOOL(lp, &lp->is_lower, rowcolsum, AUTOMATIC) ||\n     ((lp->scalars != NULL) && !allocREAL(lp, &lp->scalars, rowcolsum, AUTOMATIC)))\n    return( FALSE );\n\n  /* Fill in default values, where appropriate */\n  for(i = oldrowcolalloc+1; i < rowcolsum; i++) {\n    lp->upbo[i] = lp->infinite;\n    lp->orig_upbo[i] = lp->upbo[i];\n    lp->lowbo[i] = 0;\n    lp->orig_lowbo[i] = lp->lowbo[i];\n    lp->is_basic[i] = FALSE;\n    lp->is_lower[i] = TRUE;\n  }\n\n  /* Deal with scalars; the vector can be NULL and also contains Lagrangean information */\n  if(lp->scalars != NULL) {\n    for(i = oldrowcolalloc+1; i < rowcolsum; i++)\n      lp->scalars[i] = 1;\n    if(oldrowcolalloc == 0)\n      lp->scalars[0] = 1;\n  }\n\n  return( inc_presolve_space(lp, delta, isrows) &&\n           resizePricer(lp) );\n}\n\nSTATIC MYBOOL inc_lag_space(lprec *lp, int deltarows, MYBOOL ignoreMAT)\n{\n  int newsize;\n\n  if(deltarows > 0) {\n\n    newsize = get_Lrows(lp) + deltarows;\n\n    /* Reallocate arrays */\n    if(!allocREAL(lp, &lp->lag_rhs, newsize+1, AUTOMATIC) ||\n       !allocREAL(lp, &lp->lambda, newsize+1, AUTOMATIC) ||\n       !allocINT(lp, &lp->lag_con_type, newsize+1, AUTOMATIC))\n      return( FALSE );\n\n    /* Reallocate the matrix (note that the row scalars are stored at index 0) */\n    if(!ignoreMAT) {\n      if(lp->matL == NULL)\n        lp->matL = mat_create(lp, newsize, lp->columns, lp->epsvalue);\n      else\n        inc_matrow_space(lp->matL, deltarows);\n    }\n    lp->matL->rows += deltarows;\n\n  }\n  /* Handle column count expansion as special case */\n  else if(!ignoreMAT) {\n    inc_matcol_space(lp->matL, lp->columns_alloc-lp->matL->columns_alloc+1);\n  }\n\n\n  return( TRUE );\n}\n\nSTATIC MYBOOL inc_row_space(lprec *lp, int deltarows)\n{\n  int    i, rowsum, oldrowsalloc;\n  MYBOOL ok = TRUE;\n\n  /* Adjust lp row structures */\n  i = lp->rows_alloc+deltarows;\n  if(lp->matA->is_roworder) {\n    i -= lp->matA->columns_alloc;\n    SETMIN(i, deltarows);\n    if(i > 0)\n      inc_matcol_space(lp->matA, i);\n    rowsum = lp->matA->columns_alloc;\n  }\n  else {\n    i -= lp->matA->rows_alloc;\n    SETMIN(i, deltarows);\n    if(i > 0)\n      inc_matrow_space(lp->matA, i);\n    rowsum = lp->matA->rows_alloc;\n  }\n  if(lp->rows+deltarows > lp->rows_alloc) {\n\n    rowsum++;\n    oldrowsalloc = lp->rows_alloc;\n    lp->rows_alloc = rowsum;\n    deltarows = rowsum - oldrowsalloc;\n    rowsum++;\n\n    if(!allocREAL(lp, &lp->orig_rhs, rowsum, AUTOMATIC) ||\n       !allocLREAL(lp, &lp->rhs, rowsum, AUTOMATIC) ||\n       !allocINT(lp, &lp->row_type, rowsum, AUTOMATIC) ||\n       !allocINT(lp, &lp->var_basic, rowsum, AUTOMATIC))\n      return( FALSE );\n\n    if(oldrowsalloc == 0) {\n      lp->var_basic[0] = AUTOMATIC; /*TRUE;*/  /* Indicates default basis */\n      lp->orig_rhs[0] = 0;\n      lp->row_type[0] = ROWTYPE_OFMIN;\n    }\n    for(i = oldrowsalloc+1; i < rowsum; i++) {\n      lp->orig_rhs[i] = 0;\n      lp->rhs[i] = 0;\n      lp->row_type[i] = ROWTYPE_EMPTY;\n      lp->var_basic[i] = i;\n    }\n\n    /* Adjust hash name structures */\n    if(lp->names_used && (lp->row_name != NULL)) {\n\n      /* First check the hash table */\n      if(lp->rowname_hashtab->size < lp->rows_alloc) {\n        hashtable *ht;\n\n        ht = copy_hash_table(lp->rowname_hashtab, lp->row_name, lp->rows_alloc + 1);\n        if(ht == NULL) {\n          lp->spx_status = NOMEMORY;\n          return( FALSE );\n        }\n        free_hash_table(lp->rowname_hashtab);\n        lp->rowname_hashtab = ht;\n      }\n\n      /* Then the string storage (i.e. pointer to the item's hash structure) */\n      lp->row_name = (hashelem **) realloc(lp->row_name, (rowsum) * sizeof(*lp->row_name));\n      if(lp->row_name == NULL) {\n        lp->spx_status = NOMEMORY;\n        return( FALSE );\n      }\n      for(i = oldrowsalloc + 1; i < rowsum; i++)\n        lp->row_name[i] = NULL;\n    }\n\n    ok = inc_rowcol_space(lp, deltarows, TRUE);\n\n  }\n  return(ok);\n}\n\nSTATIC MYBOOL inc_col_space(lprec *lp, int deltacols)\n{\n  int i,colsum, oldcolsalloc;\n\n  i = lp->columns_alloc+deltacols;\n  if(lp->matA->is_roworder) {\n    i -= lp->matA->rows_alloc;\n    SETMIN(i, deltacols);\n    if(i > 0)\n      inc_matrow_space(lp->matA, i);\n    colsum = lp->matA->rows_alloc;\n  }\n  else {\n    i -= lp->matA->columns_alloc;\n    SETMIN(i, deltacols);\n    if(i > 0)\n      inc_matcol_space(lp->matA, i);\n    colsum = lp->matA->columns_alloc;\n  }\n\n  if(lp->columns+deltacols >= lp->columns_alloc) {\n\n    colsum++;\n    oldcolsalloc = lp->columns_alloc;\n    lp->columns_alloc = colsum;\n    deltacols = colsum - oldcolsalloc;\n    colsum++;\n\n    /* Adjust hash name structures */\n    if(lp->names_used && (lp->col_name != NULL)) {\n\n      /* First check the hash table */\n      if(lp->colname_hashtab->size < lp->columns_alloc) {\n        hashtable *ht;\n\n        ht = copy_hash_table(lp->colname_hashtab, lp->col_name, lp->columns_alloc + 1);\n        if(ht != NULL) {\n          free_hash_table(lp->colname_hashtab);\n          lp->colname_hashtab = ht;\n        }\n      }\n\n      /* Then the string storage (i.e. pointer to the item's hash structure) */\n      lp->col_name = (hashelem **) realloc(lp->col_name, (colsum) * sizeof(*lp->col_name));\n      for(i = oldcolsalloc+1; i < colsum; i++)\n        lp->col_name[i] = NULL;\n    }\n\n    if(!allocREAL(lp, &lp->orig_obj, colsum, AUTOMATIC) ||\n       !allocMYBOOL(lp, &lp->var_type, colsum, AUTOMATIC) ||\n       !allocREAL(lp, &lp->sc_lobound, colsum, AUTOMATIC) ||\n       ((lp->obj != NULL) && !allocREAL(lp, &lp->obj, colsum, AUTOMATIC)) ||\n       ((lp->var_priority != NULL) && !allocINT(lp, &lp->var_priority, colsum-1, AUTOMATIC)) ||\n       ((lp->var_is_free != NULL) && !allocINT(lp, &lp->var_is_free, colsum, AUTOMATIC)) ||\n       ((lp->bb_varbranch != NULL) && !allocMYBOOL(lp, &lp->bb_varbranch, colsum-1, AUTOMATIC)))\n      return( FALSE );\n\n    /* Make sure that Lagrangean constraints have the same number of columns */\n    if(get_Lrows(lp) > 0)\n      inc_lag_space(lp, 0, FALSE);\n\n    /* Update column pointers */\n    for(i = MIN(oldcolsalloc, lp->columns) + 1; i < colsum; i++) {\n      lp->orig_obj[i] = 0;\n      if(lp->obj != NULL)\n        lp->obj[i] = 0;\n      lp->var_type[i] = ISREAL;\n      lp->sc_lobound[i] = 0;\n      if(lp->var_priority != NULL)\n        lp->var_priority[i-1] = i;\n    }\n\n    if(lp->var_is_free != NULL) {\n      for(i = oldcolsalloc+1; i < colsum; i++)\n        lp->var_is_free[i] = 0;\n    }\n\n    if(lp->bb_varbranch != NULL) {\n      for(i = oldcolsalloc; i < colsum-1; i++)\n        lp->bb_varbranch[i] = BRANCH_DEFAULT;\n    }\n\n    inc_rowcol_space(lp, deltacols, FALSE);\n\n  }\n  return(TRUE);\n}\n\n/* Problem manipulation routines */\n\nMYBOOL __WINAPI set_obj(lprec *lp, int colnr, REAL value)\n{\n  if(colnr <= 0)\n    colnr = set_rh(lp, 0, value);\n  else\n    colnr = set_mat(lp, 0, colnr, value);\n  return((MYBOOL) colnr);\n}\n\nMYBOOL __WINAPI set_obj_fnex(lprec *lp, int count, REAL *row, int *colno)\n{\n  MYBOOL chsgn = is_maxim(lp);\n  int    i, ix;\n  REAL   value;\n\n  if(row == NULL)\n    return( FALSE );\n\n  else if(colno == NULL) {\n    if(count <= 0)\n      count = lp->columns;\n    for(i = 1; i <= count; i++) {\n      value = row[i];\n#ifdef DoMatrixRounding\n      value = roundToPrecision(value, lp->matA->epsvalue);\n#endif\n      lp->orig_obj[i] = my_chsign(chsgn, scaled_mat(lp, value, 0, i));\n    }\n  }\n  else {\n    MEMCLEAR(lp->orig_obj, lp->columns+1);\n    for(i = 0; i < count; i++) {\n      ix = colno[i];\n      value = row[i];\n#ifdef DoMatrixRounding\n      value = roundToPrecision(value, lp->matA->epsvalue);\n#endif\n      lp->orig_obj[ix] = my_chsign(chsgn, scaled_mat(lp, value, 0, ix));\n    }\n  }\n\n  return(TRUE);\n}\n\nMYBOOL __WINAPI set_obj_fn(lprec *lp, REAL *row)\n{\n  return( set_obj_fnex(lp, 0, row, NULL) );\n}\n\nMYBOOL __WINAPI str_set_obj_fn(lprec *lp, char *row_string)\n{\n  int    i;\n  MYBOOL ret = TRUE;\n  REAL   *arow;\n  char   *p, *newp;\n\n  allocREAL(lp, &arow, lp->columns + 1, FALSE);\n  p = row_string;\n  for(i = 1; i <= lp->columns; i++) {\n    arow[i] = (REAL) strtod(p, &newp);\n    if(p == newp) {\n      report(lp, IMPORTANT, \"str_set_obj_fn: Bad string %s\\n\", p);\n      lp->spx_status = DATAIGNORED;\n      ret = FALSE;\n      break;\n    }\n    else\n      p = newp;\n  }\n  if(lp->spx_status != DATAIGNORED)\n    ret = set_obj_fn(lp, arow);\n  FREE(arow);\n  return( ret );\n}\n\nSTATIC MYBOOL append_columns(lprec *lp, int deltacolumns)\n{\n  if(!inc_col_space(lp, deltacolumns))\n    return( FALSE );\n  varmap_add(lp, lp->sum+1, deltacolumns);\n  shift_coldata(lp, lp->columns+1, deltacolumns, NULL);\n  return( TRUE );\n}\n\nSTATIC MYBOOL append_rows(lprec *lp, int deltarows)\n{\n  if(!inc_row_space(lp, deltarows))\n    return( FALSE );\n  varmap_add(lp, lp->rows+1, deltarows);\n  shift_rowdata(lp, lp->rows+1, deltarows, NULL);\n\n  return( TRUE );\n}\n\nMYBOOL __WINAPI set_add_rowmode(lprec *lp, MYBOOL turnon)\n{\n  if((lp->solvecount == 0) && (turnon ^ lp->matA->is_roworder))\n    return( mat_transpose(lp->matA) );\n  else\n    return( FALSE );\n}\n\nMYBOOL __WINAPI is_add_rowmode(lprec *lp)\n{\n  return(lp->matA->is_roworder);\n}\n\nMYBOOL __WINAPI set_row(lprec *lp, int rownr, REAL *row)\n{\n  if((rownr < 0) || (rownr > lp->rows)) {\n    report(lp, IMPORTANT, \"set_row: Row %d out of range\\n\", rownr);\n    return( FALSE );\n  }\n  if(rownr == 0)\n    return( set_obj_fn(lp, row) );\n  else\n    return( mat_setrow(lp->matA, rownr, lp->columns, row, NULL, TRUE, TRUE) );\n}\n\nMYBOOL __WINAPI set_rowex(lprec *lp, int rownr, int count, REAL *row, int *colno)\n{\n  if((rownr < 0) || (rownr > lp->rows)) {\n    report(lp, IMPORTANT, \"set_rowex: Row %d out of range\\n\", rownr);\n    return( FALSE );\n  }\n  if(rownr == 0)\n    return( set_obj_fnex(lp, count, row, colno) );\n  else\n    return( mat_setrow(lp->matA, rownr, count, row, colno, TRUE, TRUE) );\n}\n\nMYBOOL __WINAPI add_constraintex(lprec *lp, int count, REAL *row, int *colno, int constr_type, REAL rh)\n{\n  int    n;\n  MYBOOL status = FALSE;\n\n  if(!(constr_type == LE || constr_type == GE || constr_type == EQ)) {\n    report(lp, IMPORTANT, \"add_constraintex: Invalid %d constraint type\\n\", constr_type);\n    return( status );\n  }\n\n  /* Prepare for a new row */\n  if(!append_rows(lp, 1))\n    return( status );\n\n  /* Set constraint parameters, fix the slack */\n  if((constr_type & ROWTYPE_CONSTRAINT) == EQ) {\n    lp->equalities++;\n    lp->orig_upbo[lp->rows] = 0;\n    lp->upbo[lp->rows] = 0;\n  }\n  lp->row_type[lp->rows] = constr_type;\n\n  if(is_chsign(lp, lp->rows) && (rh != 0))\n    lp->orig_rhs[lp->rows] = -rh;\n  else\n    lp->orig_rhs[lp->rows] = rh;\n\n  /* Insert the non-zero constraint values */\n  if(colno == NULL)\n    n = lp->columns;\n  else\n    n = count;\n  mat_appendrow(lp->matA, n, row, colno, my_chsign(is_chsign(lp, lp->rows), 1.0), TRUE);\n  if(!lp->varmap_locked)\n    presolve_setOrig(lp, lp->rows, lp->columns);\n\n#ifdef Paranoia\n  if(lp->matA->is_roworder)\n    n = lp->matA->columns;\n  else\n    n = lp->matA->rows;\n  if(lp->rows != n) {\n    report(lp, SEVERE, \"add_constraintex: Row count mismatch %d vs %d\\n\",\n                       lp->rows, n);\n  }\n  else if(is_BasisReady(lp) && !verify_basis(lp))\n    report(lp, SEVERE, \"add_constraintex: Invalid basis detected for row %d\\n\", lp->rows);\n  else\n#endif\n  status = TRUE;\n\n  return( status );\n}\n\nMYBOOL __WINAPI add_constraint(lprec *lp, REAL *row, int constr_type, REAL rh)\n{\n  return( add_constraintex(lp, 0, row, NULL, constr_type, rh) );\n}\n\nMYBOOL __WINAPI str_add_constraint(lprec *lp, char *row_string, int constr_type, REAL rh)\n{\n  int    i;\n  char   *p, *newp;\n  REAL   *aRow;\n  MYBOOL status = FALSE;\n\n  allocREAL(lp, &aRow, lp->columns + 1, FALSE);\n  p = row_string;\n\n  for(i = 1; i <= lp->columns; i++) {\n    aRow[i] = (REAL) strtod(p, &newp);\n    if(p == newp) {\n      report(lp, IMPORTANT, \"str_add_constraint: Bad string '%s'\\n\", p);\n      lp->spx_status = DATAIGNORED;\n      break;\n    }\n    else\n      p = newp;\n  }\n  if(lp->spx_status != DATAIGNORED)\n    status = add_constraint(lp, aRow, constr_type, rh);\n  FREE(aRow);\n\n  return(status);\n}\n\nSTATIC MYBOOL del_constraintex(lprec *lp, LLrec *rowmap)\n{\n  int i;\n\n  if(lp->equalities > 0)\n  for(i = firstInactiveLink(rowmap); i != 0; i = nextInactiveLink(rowmap, i)) {\n    if(is_constr_type(lp, i, EQ)) {\n#ifdef Paranoia\n      if(lp->equalities == 0)\n        report(lp, SEVERE, \"del_constraintex: Invalid count of equality constraints\\n\");\n#endif\n       lp->equalities--;\n    }\n  }\n\n  varmap_delete(lp, 1, -1, rowmap);\n  shift_rowdata(lp, 1, -1, rowmap);\n  if(!lp->varmap_locked) {\n    presolve_setOrig(lp, lp->rows, lp->columns);\n    if(lp->names_used)\n      del_varnameex(lp, lp->row_name, lp->rowname_hashtab, 0, rowmap);\n  }\n\n#ifdef Paranoia\n  if(is_BasisReady(lp) && !verify_basis(lp))\n    report(lp, SEVERE, \"del_constraintex: Invalid basis detected\\n\");\n#endif\n\n  return(TRUE);\n}\nMYBOOL __WINAPI del_constraint(lprec *lp, int rownr)\n{\n  MYBOOL preparecompact = (MYBOOL) (rownr < 0);\n\n  if(preparecompact)\n    rownr = -rownr;\n  if((rownr < 1) || (rownr > lp->rows)) {\n    report(lp, IMPORTANT, \"del_constraint: Attempt to delete non-existing constraint %d\\n\", rownr);\n    return(FALSE);\n  }\n  if(lp->matA->is_roworder) {\n    report(lp, IMPORTANT, \"del_constraint: Cannot delete constraint while in row entry mode.\\n\");\n    return(FALSE);\n  }\n\n  if(is_constr_type(lp, rownr, EQ) && (lp->equalities > 0))\n    lp->equalities--;\n\n  varmap_delete(lp, my_chsign(preparecompact, rownr), -1, NULL);\n  shift_rowdata(lp, my_chsign(preparecompact, rownr), -1, NULL);\n  if(!lp->varmap_locked) {\n    presolve_setOrig(lp, lp->rows, lp->columns);\n    if(lp->names_used)\n      del_varnameex(lp, lp->row_name, lp->rowname_hashtab, rownr, NULL);\n  }\n\n#ifdef Paranoia\n  if(is_BasisReady(lp) && !verify_basis(lp))\n    report(lp, SEVERE, \"del_constraint: Invalid basis detected at row %d\\n\", rownr);\n#endif\n\n  return(TRUE);\n}\n\nMYBOOL __WINAPI add_lag_con(lprec *lp, REAL *row, int con_type, REAL rhs)\n{\n  int  k;\n  REAL sign;\n\n  if(con_type == LE || con_type == EQ)\n    sign = 1;\n  else if(con_type == GE)\n    sign = -1;\n  else {\n    report(lp, IMPORTANT, \"add_lag_con: Constraint type %d not implemented\\n\", con_type);\n    return(FALSE);\n  }\n\n  inc_lag_space(lp, 1, FALSE);\n\n  k = get_Lrows(lp);\n  lp->lag_rhs[k] = rhs * sign;\n  mat_appendrow(lp->matL, lp->columns, row, NULL, sign, TRUE);\n  lp->lambda[k] = 0;\n  lp->lag_con_type[k] = con_type;\n\n  return(TRUE);\n}\n\nMYBOOL __WINAPI str_add_lag_con(lprec *lp, char *row_string, int con_type, REAL rhs)\n{\n  int    i;\n  MYBOOL ret = TRUE;\n  REAL   *a_row;\n  char   *p, *new_p;\n\n  allocREAL(lp, &a_row, lp->columns + 1, FALSE);\n  p = row_string;\n\n  for(i = 1; i <= lp->columns; i++) {\n    a_row[i] = (REAL) strtod(p, &new_p);\n    if(p == new_p) {\n      report(lp, IMPORTANT, \"str_add_lag_con: Bad string '%s'\\n\", p);\n      lp->spx_status = DATAIGNORED;\n      ret = FALSE;\n      break;\n    }\n    else\n      p = new_p;\n  }\n  if(lp->spx_status != DATAIGNORED)\n    ret = add_lag_con(lp, a_row, con_type, rhs);\n  FREE(a_row);\n  return( ret );\n}\n\n/* INLINE */ MYBOOL is_splitvar(lprec *lp, int colnr)\n/* Two cases handled by var_is_free:\n\n   1) LB:-Inf / UB:<Inf variables\n      No helper column created, sign of var_is_free set negative with index to itself.\n   2) LB:-Inf / UB: Inf (free) variables\n      Sign of var_is_free set positive with index to new helper column,\n      helper column created with negative var_is_free with index to the original column.\n\n   This function helps identify the helper column in 2).\n*/\n{\n   return((MYBOOL) ((lp->var_is_free != NULL) &&\n                    (lp->var_is_free[colnr] < 0) && (-lp->var_is_free[colnr] != colnr)));\n}\n\nvoid del_splitvars(lprec *lp)\n{\n  int j, jj, i;\n\n  if(lp->var_is_free != NULL) {\n    for(j = lp->columns; j >= 1; j--)\n      if(is_splitvar(lp, j)) {\n        /* Check if we need to modify the basis */\n        jj = lp->rows+abs(lp->var_is_free[j]);\n        i = lp->rows+j;\n        if(lp->is_basic[i] && !lp->is_basic[jj]) {\n          i = findBasisPos(lp, i, NULL);\n          set_basisvar(lp, i, jj);\n        }\n        /* Delete the helper column */\n        del_column(lp, j);\n      }\n    FREE(lp->var_is_free);\n  }\n}\n\nMYBOOL __WINAPI set_column(lprec *lp, int colnr, REAL *column)\n{\n  return( mat_setcol(lp->matA, colnr, lp->rows, column, NULL, TRUE, TRUE) );\n}\n\nMYBOOL __WINAPI set_columnex(lprec *lp, int colnr, int count, REAL *column, int *rowno)\n{\n  return( mat_setcol(lp->matA, colnr, count, column, rowno, TRUE, TRUE) );\n}\n\nMYBOOL __WINAPI add_columnex(lprec *lp, int count, REAL *column, int *rowno)\n/* This function adds a data column to the current model; three cases handled:\n\n    1: Prepare for column data by setting column = NULL\n    2: Dense vector indicated by (rowno == NULL) over 0..count+get_Lrows() elements\n    3: Sparse vector set over row vectors rowno, over 0..count-1 elements.\n\n   NB! If the column has only one entry, this should be handled as\n       a bound, but this currently is not the case  */\n{\n  MYBOOL status = FALSE;\n\n /* Prepare and shift column vectors */\n  if(!append_columns(lp, 1))\n    return( status );\n\n /* Append sparse regular constraint values */\n  if(mat_appendcol(lp->matA, count, column, rowno, 1.0, TRUE) < 0)\n    report(lp, SEVERE, \"add_columnex: Data column %d supplied in non-ascending row index order.\\n\",\n                       lp->columns);\n  else\n#ifdef Paranoia\n  if(lp->columns != lp->matA->columns) {\n    report(lp, SEVERE, \"add_columnex: Column count mismatch %d vs %d\\n\",\n                       lp->columns, lp->matA->columns);\n  }\n  else if(is_BasisReady(lp) && (lp->P1extraDim == 0) && !verify_basis(lp))\n    report(lp, SEVERE, \"add_columnex: Invalid basis detected for column %d\\n\",\n                       lp->columns);\n  else\n#endif\n    status = TRUE;\n\n  if(!lp->varmap_locked)\n    presolve_setOrig(lp, lp->rows, lp->columns);\n\n  return( status );\n}\n\nMYBOOL __WINAPI add_column(lprec *lp, REAL *column)\n{\n  del_splitvars(lp);\n  return(add_columnex(lp, lp->rows, column, NULL));\n}\n\nMYBOOL __WINAPI str_add_column(lprec *lp, char *col_string)\n{\n  int  i;\n  MYBOOL ret = TRUE;\n  REAL *aCol;\n  char *p, *newp;\n\n  allocREAL(lp, &aCol, lp->rows + 1, FALSE);\n  p = col_string;\n\n  for(i = 0; i <= lp->rows; i++) {\n    aCol[i] = (REAL) strtod(p, &newp);\n    if(p == newp) {\n      report(lp, IMPORTANT, \"str_add_column: Bad string '%s'\\n\", p);\n      lp->spx_status = DATAIGNORED;\n      ret = FALSE;\n      break;\n    }\n    else\n      p = newp;\n  }\n  if(lp->spx_status != DATAIGNORED)\n    ret = add_column(lp, aCol);\n  FREE(aCol);\n  return( ret );\n}\n\nSTATIC MYBOOL del_varnameex(lprec *lp, hashelem **namelist, hashtable *ht, int varnr, LLrec *varmap)\n{\n  int i, n;\n\n  /* First drop hash table entries of the deleted variables */\n  if(varmap != NULL)\n    i = firstInactiveLink(varmap);\n  else\n    i = varnr;\n  while(i > 0) {\n    if((namelist[i] != NULL) &&\n       (namelist[i]->name != NULL))\n      drophash(namelist[i]->name, namelist, ht);\n    if(varmap != NULL)\n      i = nextInactiveLink(varmap, i);\n    else\n      i = 0;\n  }\n\n  /* Then compress the name list */\n  if(varmap != NULL) {\n    i = firstInactiveLink(varmap);\n    n = nextActiveLink(varmap, i);\n    varnr = i;\n  }\n  else {\n    i = varnr;\n    n = i + 1;\n  }\n  while(n != 0) {\n    namelist[i] = namelist[n];\n    if((namelist[i] != NULL) && (namelist[i]->index > varnr))\n      namelist[i]->index -= n - i;\n    i++;\n    if(varmap != NULL)\n      n = nextActiveLink(varmap, i);\n    else\n      n = 0;\n  }\n\n  return( TRUE );\n}\nSTATIC MYBOOL del_columnex(lprec *lp, LLrec *colmap)\n{\n  varmap_delete(lp, lp->rows+1, -1, colmap);\n  shift_coldata(lp, 1, -1, colmap);\n  if(!lp->varmap_locked) {\n    presolve_setOrig(lp, lp->rows, lp->columns);\n    if(lp->names_used)\n      del_varnameex(lp, lp->col_name, lp->colname_hashtab, 0, colmap);\n  }\n#ifdef Paranoia\n  if(is_BasisReady(lp) && (lp->P1extraDim == 0) && !verify_basis(lp))\n    report(lp, SEVERE, \"del_columnex: Invalid basis detected\\n\");\n#endif\n\n  return(TRUE);\n}\nMYBOOL __WINAPI del_column(lprec *lp, int colnr)\n{\n  MYBOOL preparecompact = (MYBOOL) (colnr < 0);\n\n  if(preparecompact)\n    colnr = -colnr;\n  if((colnr > lp->columns) || (colnr < 1)) {\n    report(lp, IMPORTANT, \"del_column: Column %d out of range\\n\", colnr);\n    return(FALSE);\n  }\n  if(lp->matA->is_roworder) {\n    report(lp, IMPORTANT, \"del_column: Cannot delete column while in row entry mode.\\n\");\n    return(FALSE);\n  }\n\n  if((lp->var_is_free != NULL) && (lp->var_is_free[colnr] > 0))\n    del_column(lp, lp->var_is_free[colnr]); /* delete corresponding split column (is always after this column) */\n\n  varmap_delete(lp, my_chsign(preparecompact, lp->rows+colnr), -1, NULL);\n  shift_coldata(lp, my_chsign(preparecompact, colnr), -1, NULL);\n  if(!lp->varmap_locked) {\n    presolve_setOrig(lp, lp->rows, lp->columns);\n    if(lp->names_used)\n      del_varnameex(lp, lp->col_name, lp->colname_hashtab, colnr, NULL);\n  }\n#ifdef Paranoia\n  if(is_BasisReady(lp) && (lp->P1extraDim == 0) && !verify_basis(lp))\n    report(lp, SEVERE, \"del_column: Invalid basis detected at column %d (%d)\\n\", colnr, lp->columns);\n#endif\n\n  return(TRUE);\n}\n\nvoid __WINAPI set_simplextype(lprec *lp, int simplextype)\n{\n  lp->simplex_strategy = simplextype;\n}\n\nint __WINAPI get_simplextype(lprec *lp)\n{\n  return(lp->simplex_strategy);\n}\n\nvoid __WINAPI set_preferdual(lprec *lp, MYBOOL dodual)\n{\n  if(dodual & TRUE)\n    lp->simplex_strategy = SIMPLEX_DUAL_DUAL;\n  else\n    lp->simplex_strategy = SIMPLEX_PRIMAL_PRIMAL;\n}\n\nvoid __WINAPI set_bounds_tighter(lprec *lp, MYBOOL tighten)\n{\n  lp->tighten_on_set = tighten;\n}\nMYBOOL __WINAPI get_bounds_tighter(lprec *lp)\n{\n  return(lp->tighten_on_set);\n}\n\nMYBOOL __WINAPI set_upbo(lprec *lp, int colnr, REAL value)\n{\n  if((colnr > lp->columns) || (colnr < 1)) {\n    report(lp, IMPORTANT, \"set_upbo: Column %d out of range\\n\", colnr);\n    return(FALSE);\n  }\n\n#ifdef DoBorderRounding\n  if(fabs(value) < lp->infinite)\n    value = my_avoidtiny(value, lp->matA->epsvalue);\n#endif\n  value = scaled_value(lp, value, lp->rows + colnr);\n  if(lp->tighten_on_set) {\n    if(value < lp->orig_lowbo[lp->rows + colnr]) {\n      report(lp, IMPORTANT, \"set_upbo: Upperbound must be >= lowerbound\\n\");\n      return(FALSE);\n    }\n    if(value < lp->orig_upbo[lp->rows + colnr]) {\n      set_action(&lp->spx_action, ACTION_REBASE);\n      lp->orig_upbo[lp->rows + colnr] = value;\n    }\n  }\n  else\n  {\n    set_action(&lp->spx_action, ACTION_REBASE);\n    if(value > lp->infinite)\n      value = lp->infinite;\n    lp->orig_upbo[lp->rows + colnr] = value;\n  }\n  return(TRUE);\n}\n\nREAL __WINAPI get_upbo(lprec *lp, int colnr)\n{\n  REAL value;\n\n  if((colnr > lp->columns) || (colnr < 1)) {\n    report(lp, IMPORTANT, \"get_upbo: Column %d out of range\\n\", colnr);\n    return(0);\n  }\n\n  value = lp->orig_upbo[lp->rows + colnr];\n  value = unscaled_value(lp, value, lp->rows + colnr);\n  return(value);\n}\n\nMYBOOL __WINAPI set_lowbo(lprec *lp, int colnr, REAL value)\n{\n  if((colnr > lp->columns) || (colnr < 1)) {\n    report(lp, IMPORTANT, \"set_lowbo: Column %d out of range\\n\", colnr);\n    return(FALSE);\n  }\n\n#ifdef DoBorderRounding\n  if(fabs(value) < lp->infinite)\n    value = my_avoidtiny(value, lp->matA->epsvalue);\n#endif\n  value = scaled_value(lp, value, lp->rows + colnr);\n  if(lp->tighten_on_set) {\n    if(value > lp->orig_upbo[lp->rows + colnr]) {\n      report(lp, IMPORTANT, \"set_lowbo: Upper bound must be >= lower bound\\n\");\n      return(FALSE);\n    }\n    if((value < 0) || (value > lp->orig_lowbo[lp->rows + colnr])) {\n      set_action(&lp->spx_action, ACTION_REBASE);\n      lp->orig_lowbo[lp->rows + colnr] = value;\n    }\n  }\n  else\n  {\n    set_action(&lp->spx_action, ACTION_REBASE);\n    if(value < -lp->infinite)\n      value = -lp->infinite;\n    lp->orig_lowbo[lp->rows + colnr] = value;\n  }\n  return(TRUE);\n}\n\nREAL __WINAPI get_lowbo(lprec *lp, int colnr)\n{\n  REAL value;\n\n  if((colnr > lp->columns) || (colnr < 1)) {\n    report(lp, IMPORTANT, \"get_lowbo: Column %d out of range\\n\", colnr);\n    return(0);\n  }\n\n  value = lp->orig_lowbo[lp->rows + colnr];\n  value = unscaled_value(lp, value, lp->rows + colnr);\n  return(value);\n}\n\nMYBOOL __WINAPI set_bounds(lprec *lp, int colnr, REAL lower, REAL upper)\n{\n  if((colnr > lp->columns) || (colnr < 1)) {\n    report(lp, IMPORTANT, \"set_bounds: Column %d out of range\\n\", colnr);\n    return(FALSE);\n  }\n  if(fabs(upper - lower) < lp->epsvalue) {\n    if(lower < 0)\n      lower = upper;\n    else\n      upper = lower;\n  }\n  else if(lower > upper) {\n    report(lp, IMPORTANT, \"set_bounds: Column %d upper bound must be >= lower bound\\n\",\n                          colnr);\n    return( FALSE );\n  }\n\n  colnr += lp->rows;\n\n  if(lower < -lp->infinite)\n    lower = -lp->infinite;\n  else if(lp->scaling_used) {\n    lower = scaled_value(lp, lower, colnr);\n#ifdef DoBorderRounding\n    lower = my_avoidtiny(lower, lp->matA->epsvalue);\n#endif\n  }\n\n  if(upper > lp->infinite)\n    upper = lp->infinite;\n  else if(lp->scaling_used) {\n    upper = scaled_value(lp, upper, colnr);\n#ifdef DoBorderRounding\n    upper = my_avoidtiny(upper, lp->matA->epsvalue);\n#endif\n  }\n\n  lp->orig_lowbo[colnr] = lower;\n  lp->orig_upbo[colnr]  = upper;\n  set_action(&lp->spx_action, ACTION_REBASE);\n\n  return(TRUE);\n}\n\nMYBOOL get_bounds(lprec *lp, int column, REAL *lower, REAL *upper)\n{\n  if((column > lp->columns) || (column < 1)) {\n    report(lp, IMPORTANT, \"get_bounds: Column %d out of range\", column);\n    return(FALSE);\n  }\n\n  if(lower != NULL)\n    *lower = get_lowbo(lp, column);\n  if(upper != NULL)\n    *upper = get_upbo(lp, column);\n\n  return(TRUE);\n}\n\nMYBOOL __WINAPI set_int(lprec *lp, int colnr, MYBOOL var_type)\n{\n  if((colnr > lp->columns) || (colnr < 1)) {\n    report(lp, IMPORTANT, \"set_int: Column %d out of range\\n\", colnr);\n    return(FALSE);\n  }\n\n  if((lp->var_type[colnr] & ISINTEGER) != 0) {\n    lp->int_vars--;\n    lp->var_type[colnr] &= ~ISINTEGER;\n  }\n  if(var_type) {\n    lp->var_type[colnr] |= ISINTEGER;\n    lp->int_vars++;\n    if(lp->columns_scaled && !is_integerscaling(lp))\n      unscale_columns(lp);\n  }\n  return(TRUE);\n}\n\nMYBOOL __WINAPI is_int(lprec *lp, int colnr)\n{\n  if((colnr > lp->columns) || (colnr < 1)) {\n    report(lp, IMPORTANT, \"is_int: Column %d out of range\\n\", colnr);\n    return(FALSE);\n  }\n\n  return((lp->var_type[colnr] & ISINTEGER) != 0);\n}\n\nMYBOOL __WINAPI is_SOS_var(lprec *lp, int colnr)\n{\n  if((colnr > lp->columns) || (colnr < 1)) {\n    report(lp, IMPORTANT, \"is_SOS_var: Column %d out of range\\n\", colnr);\n    return(FALSE);\n  }\n\n  return((lp->var_type[colnr] & ISSOS) != 0);\n}\n\nint __WINAPI add_SOS(lprec *lp, char *name, int sostype, int priority, int count, int *sosvars, REAL *weights)\n{\n  SOSrec *SOS;\n  int    k;\n\n  if((sostype < 1) || (count < 0)) {\n    report(lp, IMPORTANT, \"add_SOS: Invalid SOS type definition %d\\n\", sostype);\n    return( 0 );\n  }\n\n  /* Make sure SOSes of order 3 and higher are properly defined */\n  if(sostype > 2) {\n    int j;\n    for(k = 1; k <= count; k++) {\n      j = sosvars[k];\n      if(!is_int(lp, j) || !is_semicont(lp, j)) {\n        report(lp, IMPORTANT, \"add_SOS: SOS3+ members all have to be integer or semi-continuous.\\n\");\n        return( 0 );\n      }\n    }\n  }\n\n  /* Make size in the list to handle another SOS record */\n  if(lp->SOS == NULL)\n    lp->SOS = create_SOSgroup(lp);\n\n  /* Create and append SOS to list */\n  SOS = create_SOSrec(lp->SOS, name, sostype, priority, count, sosvars, weights);\n  k = append_SOSgroup(lp->SOS, SOS);\n\n  return(k);\n}\n\nSTATIC int add_GUB(lprec *lp, char *name, int priority, int count, int *gubvars)\n{\n  SOSrec *GUB;\n  int    k;\n\n#ifdef Paranoia\n  if(count < 0) {\n    report(lp, IMPORTANT, \"add_GUB: Invalid GUB member count %d\\n\", count);\n    return(FALSE);\n  }\n#endif\n\n  /* Make size in the list to handle another GUB record */\n  if(lp->GUB == NULL)\n    lp->GUB = create_SOSgroup(lp);\n\n  /* Create and append GUB to list */\n  GUB = create_SOSrec(lp->GUB, name, 1, priority, count, gubvars, NULL);\n  GUB->isGUB = TRUE;\n  k = append_SOSgroup(lp->GUB, GUB);\n\n  return(k);\n}\n\nMYBOOL __WINAPI set_binary(lprec *lp, int colnr, MYBOOL must_be_bin)\n{\n  MYBOOL status = FALSE;\n\n  if((colnr > lp->columns) || (colnr < 1)) {\n    report(lp, IMPORTANT, \"set_binary: Column %d out of range\\n\", colnr);\n    return( status );\n  }\n\n  status = set_int(lp, colnr, must_be_bin);\n  if(status && must_be_bin)\n    status = set_bounds(lp, colnr, 0, 1);\n  return( status );\n}\n\nMYBOOL __WINAPI is_binary(lprec *lp, int colnr)\n{\n  if((colnr > lp->columns) || (colnr < 1)) {\n    report(lp, IMPORTANT, \"is_binary: Column %d out of range\\n\", colnr);\n    return(FALSE);\n  }\n\n  return((MYBOOL) (((lp->var_type[colnr] & ISINTEGER) != 0) &&\n                    (get_lowbo(lp, colnr) == 0) &&\n                    (fabs(get_upbo(lp, colnr) - 1) < lp->epsprimal)));\n}\n\nMYBOOL __WINAPI set_unbounded(lprec *lp, int colnr)\n{\n  if((colnr > lp->columns) || (colnr < 1)) {\n    report(lp, IMPORTANT, \"set_unbounded: Column %d out of range\\n\", colnr);\n    return( FALSE );\n  }\n\n  return( set_bounds(lp, colnr, -lp->infinite, lp->infinite) );\n}\n\nMYBOOL __WINAPI is_unbounded(lprec *lp, int colnr)\n{\n  MYBOOL test;\n\n  if((colnr > lp->columns) || (colnr < 1)) {\n    report(lp, IMPORTANT, \"is_unbounded: Column %d out of range\\n\", colnr);\n    return(FALSE);\n  }\n\n  test = is_splitvar(lp, colnr);\n  if(!test) {\n    colnr += lp->rows;\n    test = (MYBOOL) ((lp->orig_lowbo[colnr] <= -lp->infinite) &&\n                     (lp->orig_upbo[colnr] >= lp->infinite));\n  }\n  return( test );\n}\n\nMYBOOL __WINAPI is_negative(lprec *lp, int colnr)\n{\n  if((colnr > lp->columns) || (colnr < 1)) {\n    report(lp, IMPORTANT, \"is_negative: Column %d out of range\\n\", colnr);\n    return( FALSE );\n  }\n\n  colnr += lp->rows;\n  return( (MYBOOL) ((lp->orig_upbo[colnr] <= 0) &&\n                    (lp->orig_lowbo[colnr] < 0)) );\n}\n\nMYBOOL __WINAPI set_var_weights(lprec *lp, REAL *weights)\n{\n  if(lp->var_priority != NULL) {\n    FREE(lp->var_priority);\n  }\n  if(weights != NULL) {\n    int n;\n    allocINT(lp, &lp->var_priority, lp->columns_alloc, FALSE);\n    for(n = 0; n < lp->columns; n++) {\n      lp->var_priority[n] = n+1;\n    }\n    n = sortByREAL(lp->var_priority, weights, lp->columns, 0, FALSE);\n  }\n  return(TRUE);\n}\n\nMYBOOL __WINAPI set_var_priority(lprec *lp)\n/* Experimental automatic variable ordering/priority setting */\n{\n  MYBOOL status = FALSE;\n\n  if(is_bb_mode(lp, NODE_AUTOORDER) &&\n     (lp->var_priority == NULL) &&\n     (SOS_count(lp) == 0)) {\n\n    REAL *rcost = NULL;\n    int  i, j, *colorder = NULL;\n\n    allocINT(lp, &colorder, lp->columns+1, FALSE);\n\n    /* Create an \"optimal\" B&B variable ordering; this MDO-based routine\n       returns column indeces in an increasing order of co-dependency.\n       It can be argued that arranging the columns in right-to-left\n       MDO order should tend to minimize the consequences of choosing the\n       wrong variable by reducing the average B&B depth. */\n    colorder[0] = lp->columns;\n    for(j = 1; j <= lp->columns; j++)\n      colorder[j] = lp->rows+j;\n    i = getMDO(lp, NULL, colorder, NULL, FALSE);\n\n    /* Map to variable weight */\n    allocREAL(lp, &rcost, lp->columns+1, FALSE);\n    for(j = lp->columns; j > 0; j--) {\n      i = colorder[j]-lp->rows;\n      rcost[i] = -j;\n    }\n\n   /* Establish the MIP variable priorities */\n    set_var_weights(lp, rcost+1);\n\n    FREE(rcost);\n    FREE(colorder);\n    status = TRUE;\n  }\n\n  return( status );\n}\n\nint __WINAPI get_var_priority(lprec *lp, int colnr)\n{\n  if((colnr > lp->columns) || (colnr < 1)) {\n    report(lp, IMPORTANT, \"get_var_priority: Column %d out of range\\n\", colnr);\n    return(FALSE);\n  }\n\n  if(lp->var_priority == NULL)\n    return(colnr);\n  else\n    return(lp->var_priority[colnr - 1]);\n}\n\nMYBOOL __WINAPI set_semicont(lprec *lp, int colnr, MYBOOL must_be_sc)\n{\n  if((colnr > lp->columns) || (colnr < 1)) {\n    report(lp, IMPORTANT, \"set_semicont: Column %d out of range\\n\", colnr);\n    return(FALSE);\n  }\n\n  if(lp->sc_lobound[colnr] != 0) {\n    lp->sc_vars--;\n    lp->var_type[colnr] &= ~ISSEMI;\n  }\n  lp->sc_lobound[colnr] = must_be_sc;\n  if(must_be_sc) {\n    lp->var_type[colnr] |= ISSEMI;\n    lp->sc_vars++;\n  }\n  return(TRUE);\n}\n\nMYBOOL __WINAPI is_semicont(lprec *lp, int colnr)\n{\n  if((colnr > lp->columns) || (colnr < 1)) {\n    report(lp, IMPORTANT, \"is_semicont: Column %d out of range\\n\", colnr);\n    return(FALSE);\n  }\n\n  return((lp->var_type[colnr] & ISSEMI) != 0);\n}\n\nMYBOOL __WINAPI set_rh(lprec *lp, int rownr, REAL value)\n{\n  if((rownr > lp->rows) || (rownr < 0)) {\n    report(lp, IMPORTANT, \"set_rh: Row %d out of range\\n\", rownr);\n    return(FALSE);\n  }\n\n  if(((rownr == 0) && (!is_maxim(lp))) ||\n     ((rownr > 0) && is_chsign(lp, rownr)))    /* setting of RHS of OF IS meaningful */\n    value = my_flipsign(value);\n  if(fabs(value) > lp->infinite) {\n    if(value < 0)\n      value = -lp->infinite;\n    else\n      value = lp->infinite;\n  }\n#ifdef DoBorderRounding\n  else\n    value = my_avoidtiny(value, lp->matA->epsvalue);\n#endif\n  value = scaled_value(lp, value, rownr);\n  lp->orig_rhs[rownr] = value;\n  set_action(&lp->spx_action, ACTION_RECOMPUTE);\n  return(TRUE);\n}\n\nREAL __WINAPI get_rh(lprec *lp, int rownr)\n{\n  REAL value;\n\n  if((rownr > lp->rows) || (rownr < 0)) {\n    report(lp, IMPORTANT, \"get_rh: Row %d out of range\", rownr);\n    return( 0.0 );\n  }\n\n  value = lp->orig_rhs[rownr];\n  if (((rownr == 0) && !is_maxim(lp)) ||\n      ((rownr > 0) && is_chsign(lp, rownr)))    /* setting of RHS of OF IS meaningful */\n    value = my_flipsign(value);\n  value = unscaled_value(lp, value, rownr);\n  return(value);\n}\n\nREAL get_rh_upper(lprec *lp, int rownr)\n{\n  REAL value, valueR;\n\n  value = lp->orig_rhs[rownr];\n  if(is_chsign(lp, rownr)) {\n    valueR = lp->orig_upbo[rownr];\n    if(is_infinite(lp, valueR))\n      return(lp->infinite);\n    value = my_flipsign(value);\n    value += valueR;\n  }\n  value = unscaled_value(lp, value, rownr);\n  return(value);\n}\n\nREAL get_rh_lower(lprec *lp, int rownr)\n{\n  REAL value, valueR;\n\n  value = lp->orig_rhs[rownr];\n  if(is_chsign(lp, rownr))\n    value = my_flipsign(value);\n  else {\n    valueR = lp->orig_upbo[rownr];\n    if(is_infinite(lp, valueR))\n      return(-lp->infinite);\n    value -= valueR;\n  }\n  value = unscaled_value(lp, value, rownr);\n  return(value);\n}\n\nMYBOOL set_rh_upper(lprec *lp, int rownr, REAL value)\n{\n  if(rownr > lp->rows || rownr < 1) {\n    report(lp, IMPORTANT, \"set_rh_upper: Row %d out of range\", rownr);\n    return(FALSE);\n  }\n\n /* First scale the value */\n  value = scaled_value(lp, value, rownr);\n\n /* orig_rhs stores the upper bound assuming a < constraint;\n    If we have a > constraint, we must adjust the range instead */\n  if(is_chsign(lp, rownr)) {\n    if(is_infinite(lp, value))\n      lp->orig_upbo[rownr] = lp->infinite;\n    else {\n#ifdef Paranoia\n      if(value + lp->orig_rhs[rownr] < 0) {\n        report(lp, SEVERE, \"set_rh_upper: Invalid negative range in row %d\\n\",\n                           rownr);\n        return(FALSE);\n      }\n#endif\n#ifdef DoBorderRounding\n      lp->orig_upbo[rownr] = my_avoidtiny(value + lp->orig_rhs[rownr], lp->epsvalue);\n#else\n      lp->orig_upbo[rownr] = value + lp->orig_rhs[rownr];\n#endif\n    }\n  }\n  else {\n    /* If there is a constraint range, then this has to be adjusted also */\n    if(!is_infinite(lp, lp->orig_upbo[rownr])) {\n      lp->orig_upbo[rownr] -= lp->orig_rhs[rownr] - value;\n      my_roundzero(lp->orig_upbo[rownr], lp->epsvalue);\n      if(lp->orig_upbo[rownr] < 0) {\n        report(lp, IMPORTANT, \"set_rh_upper: Negative bound set for constraint %d made 0\\n\", rownr);\n        lp->orig_upbo[rownr] = 0;\n      }\n    }\n    lp->orig_rhs[rownr] = value;\n  }\n  return(TRUE);\n}\n\nMYBOOL set_rh_lower(lprec *lp, int rownr, REAL value)\n{\n  if(rownr > lp->rows || rownr < 1) {\n    report(lp, IMPORTANT, \"set_rh_lower: Row %d out of range\", rownr);\n    return(FALSE);\n  }\n\n /* First scale the value */\n  value = scaled_value(lp, value, rownr);\n\n /* orig_rhs stores the upper bound assuming a < constraint;\n    If we have a < constraint, we must adjust the range instead */\n  if(!is_chsign(lp, rownr)) {\n    if(is_infinite(lp, value))\n      lp->orig_upbo[rownr] = lp->infinite;\n    else {\n#ifdef Paranoia\n      if(lp->orig_rhs[rownr] - value < 0) {\n        report(lp, SEVERE, \"set_rh_lower: Invalid negative range in row %d\\n\",\n                           rownr);\n        return(FALSE);\n      }\n#endif\n#ifdef DoBorderRounding\n      lp->orig_upbo[rownr] = my_avoidtiny(lp->orig_rhs[rownr] - value, lp->epsvalue);\n#else\n      lp->orig_upbo[rownr] = lp->orig_rhs[rownr] - value;\n#endif\n    }\n  }\n  else {\n    value = my_flipsign(value);\n    /* If there is a constraint range, then this has to be adjusted also */\n    if(!is_infinite(lp, lp->orig_upbo[rownr])) {\n      lp->orig_upbo[rownr] -= lp->orig_rhs[rownr] - value;\n      my_roundzero(lp->orig_upbo[rownr], lp->epsvalue);\n      if(lp->orig_upbo[rownr] < 0) {\n        report(lp, IMPORTANT, \"set_rh_lower: Negative bound set for constraint %d made 0\\n\", rownr);\n        lp->orig_upbo[rownr] = 0;\n      }\n    }\n    lp->orig_rhs[rownr] = value;\n  }\n  return(TRUE);\n}\n\nMYBOOL __WINAPI set_rh_range(lprec *lp, int rownr, REAL deltavalue)\n{\n  if((rownr > lp->rows) || (rownr < 1)) {\n    report(lp, IMPORTANT, \"set_rh_range: Row %d out of range\", rownr);\n    return(FALSE);\n  }\n\n  deltavalue = scaled_value(lp, deltavalue, rownr);\n  if(deltavalue > lp->infinite)\n    deltavalue = lp->infinite;\n  else if(deltavalue < -lp->infinite)\n    deltavalue = -lp->infinite;\n#ifdef DoBorderRounding\n  else\n    deltavalue = my_avoidtiny(deltavalue, lp->matA->epsvalue);\n#endif\n\n  if(fabs(deltavalue) < lp->epsprimal) {\n    /* Conversion to EQ */\n    set_constr_type(lp, rownr, EQ);\n  }\n  else if(is_constr_type(lp, rownr, EQ)) {\n    /* EQ with a non-zero range */\n    if(deltavalue > 0)\n      set_constr_type(lp, rownr, GE);\n    else\n      set_constr_type(lp, rownr, LE);\n    lp->orig_upbo[rownr] = fabs(deltavalue);\n  }\n  else {\n    /* Modify GE/LE ranges */\n    lp->orig_upbo[rownr] = fabs(deltavalue);\n  }\n\n  return(TRUE);\n}\n\nREAL __WINAPI get_rh_range(lprec *lp, int rownr)\n{\n  if((rownr > lp->rows) || (rownr < 0)) {\n    report(lp, IMPORTANT, \"get_rh_range: row %d out of range\\n\", rownr);\n    return(FALSE);\n  }\n\n  if(lp->orig_upbo[rownr] >= lp->infinite)\n    return(lp->orig_upbo[rownr]);\n  else\n    return(unscaled_value(lp, lp->orig_upbo[rownr], rownr));\n}\n\nvoid __WINAPI set_rh_vec(lprec *lp, REAL *rh)\n{\n  int  i;\n  REAL rhi;\n\n  for(i = 1; i <= lp->rows; i++) {\n    rhi = rh[i];\n#ifdef DoBorderRounding\n    rhi = my_avoidtiny(rhi, lp->matA->epsvalue);\n#endif\n    lp->orig_rhs[i] = my_chsign(is_chsign(lp, i), scaled_value(lp, rhi, i));\n  }\n  set_action(&lp->spx_action, ACTION_RECOMPUTE);\n}\n\nMYBOOL __WINAPI str_set_rh_vec(lprec *lp, char *rh_string)\n{\n  int  i;\n  MYBOOL ret = TRUE;\n  REAL *newrh;\n  char *p, *newp;\n\n  allocREAL(lp, &newrh, lp->rows + 1, TRUE);\n  p = rh_string;\n\n  for(i = 1; i <= lp->rows; i++) {\n    newrh[i] = (REAL) strtod(p, &newp);\n    if(p == newp) {\n      report(lp, IMPORTANT, \"str_set_rh_vec: Bad string %s\\n\", p);\n      lp->spx_status = DATAIGNORED;\n      ret = FALSE;\n      break;\n    }\n    else\n      p = newp;\n  }\n  if(!(lp->spx_status == DATAIGNORED))\n    set_rh_vec(lp, newrh);\n  FREE(newrh);\n  return( ret );\n}\n\nvoid __WINAPI set_sense(lprec *lp, MYBOOL maximize)\n{\n  maximize = (MYBOOL) (maximize != FALSE);\n  if(is_maxim(lp) != maximize) {\n    int i;\n    if(is_infinite(lp, lp->bb_heuristicOF))\n      lp->bb_heuristicOF = my_chsign(maximize, lp->infinite);\n    if(is_infinite(lp, lp->bb_breakOF))\n      lp->bb_breakOF = my_chsign(maximize, -lp->infinite);\n    lp->orig_rhs[0] = my_flipsign(lp->orig_rhs[0]);\n    for(i = 1; i <= lp->columns; i++)\n      lp->orig_obj[i] = my_flipsign(lp->orig_obj[i]);\n    set_action(&lp->spx_action, ACTION_REINVERT | ACTION_RECOMPUTE);\n  }\n  if(maximize)\n    lp->row_type[0] = ROWTYPE_OFMAX;\n  else\n    lp->row_type[0] = ROWTYPE_OFMIN;\n}\n\nvoid __WINAPI set_maxim(lprec *lp)\n{\n  set_sense(lp, TRUE);\n}\n\nvoid __WINAPI set_minim(lprec *lp)\n{\n  set_sense(lp, FALSE);\n}\n\nMYBOOL __WINAPI is_maxim(lprec *lp)\n{\n  return( (MYBOOL) ((lp->row_type != NULL) &&\n                     ((lp->row_type[0] & ROWTYPE_CHSIGN) == ROWTYPE_GE)) );\n}\n\nMYBOOL __WINAPI set_constr_type(lprec *lp, int rownr, int con_type)\n{\n  MYBOOL oldchsign;\n\n  if(rownr > lp->rows+1 || rownr < 1) {\n    report(lp, IMPORTANT, \"set_constr_type: Row %d out of range\\n\", rownr);\n    return( FALSE );\n  }\n\n  /* Prepare for a new row */\n  if((rownr > lp->rows) && !append_rows(lp, rownr-lp->rows))\n    return( FALSE );\n\n  /* Update the constraint type data */\n  if(is_constr_type(lp, rownr, EQ))\n    lp->equalities--;\n\n  if((con_type & ROWTYPE_CONSTRAINT) == EQ) {\n    lp->equalities++;\n    lp->orig_upbo[rownr] = 0;\n  }\n  else if(((con_type & LE) > 0) || ((con_type & GE) > 0) || (con_type == FR))\n    lp->orig_upbo[rownr] = lp->infinite;\n  else {\n    report(lp, IMPORTANT, \"set_constr_type: Constraint type %d not implemented (row %d)\\n\",\n                          con_type, rownr);\n    return( FALSE );\n  }\n\n  /* Change the signs of the row, if necessary */\n  oldchsign = is_chsign(lp, rownr);\n  if(con_type == FR)\n    lp->row_type[rownr] = LE;\n  else\n    lp->row_type[rownr] = con_type;\n  if(oldchsign != is_chsign(lp, rownr)) {\n    mat_multrow(lp->matA, rownr, -1);\n    if(lp->orig_rhs[rownr] != 0)\n      lp->orig_rhs[rownr] *= -1;\n    set_action(&lp->spx_action, ACTION_RECOMPUTE);\n  }\n  if(con_type == FR)\n      lp->orig_rhs[rownr] = lp->infinite;\n\n  set_action(&lp->spx_action, ACTION_REINVERT);\n  lp->basis_valid = FALSE;\n\n  return( TRUE );\n}\n\n/* INLINE */ MYBOOL is_chsign(lprec *lp, int rownr)\n{\n  return( (MYBOOL) ((lp->row_type[rownr] & ROWTYPE_CONSTRAINT) == ROWTYPE_CHSIGN) );\n}\n\nMYBOOL __WINAPI is_constr_type(lprec *lp, int rownr, int mask)\n{\n  if((rownr < 0) || (rownr > lp->rows)) {\n    report(lp, IMPORTANT, \"is_constr_type: Row %d out of range\\n\", rownr);\n    return( FALSE );\n  }\n  return( (MYBOOL) ((lp->row_type[rownr] & ROWTYPE_CONSTRAINT) == mask));\n}\n\nint __WINAPI get_constr_type(lprec *lp, int rownr)\n{\n  if((rownr < 0) || (rownr > lp->rows)) {\n    report(lp, IMPORTANT, \"get_constr_type: Row %d out of range\\n\", rownr);\n    return(-1);\n  }\n  return( lp->row_type[rownr] );\n}\nREAL __WINAPI get_constr_value(lprec *lp, int rownr, int count, REAL *primsolution, int *nzindex)\n{\n  int    i;\n  REAL   value = 0.0;\n  MATrec *mat = lp->matA;\n\n  if((rownr < 0) || (rownr > get_Nrows(lp)))\n    return( value );\n\n  /* First do validation and initialization of applicable primal solution */\n  if(!mat_validate(mat) || ((primsolution == NULL) && (lp->solvecount == 0)))\n    return( value );\n  i = get_Ncolumns(lp);\n  if((primsolution != NULL) && (nzindex == NULL) &&\n     ((count <= 0) || (count > i)))\n    count = i;\n  if(primsolution == NULL) {\n    get_ptr_variables(lp, &primsolution);\n    primsolution--;\n    nzindex = NULL;\n    count = i;\n  }\n\n  /* Do objective or constraint, as specified */\n  if(rownr == 0) {\n    value += get_rh(lp, 0);\n    if(nzindex != NULL)\n      for(i = 0; i < count; i++)\n        value += get_mat(lp, 0, nzindex[i]) * primsolution[i];\n    else\n      for(i = 1; i <= count; i++)\n        value += get_mat(lp, 0, i) * primsolution[i];\n  }\n  else {\n    if(nzindex != NULL) {\n      for(i = 0; i < count; i++)\n        value += get_mat(lp, rownr, nzindex[i]) * primsolution[i];\n    }\n    else {\n      int j;\n\n      for(i = mat->row_end[rownr-1]; i < mat->row_end[rownr]; i++) {\n        j = ROW_MAT_COLNR(i);\n        value += unscaled_mat(lp, ROW_MAT_VALUE(i), rownr, j) * primsolution[j];\n      }\n      value = my_chsign(is_chsign(lp, rownr), value);\n    }\n  }\n  return( value );\n}\n\nSTATIC char *get_str_constr_class(lprec *lp, int con_class)\n{\n  switch(con_class) {\n    case ROWCLASS_Unknown:     return(\"Unknown\");\n    case ROWCLASS_Objective:   return(\"Objective\");\n    case ROWCLASS_GeneralREAL: return(\"General REAL\");\n    case ROWCLASS_GeneralMIP:  return(\"General MIP\");\n    case ROWCLASS_GeneralINT:  return(\"General INT\");\n    case ROWCLASS_GeneralBIN:  return(\"General BIN\");\n    case ROWCLASS_KnapsackINT: return(\"Knapsack INT\");\n    case ROWCLASS_KnapsackBIN: return(\"Knapsack BIN\");\n    case ROWCLASS_SetPacking:  return(\"Set packing\");\n    case ROWCLASS_SetCover:    return(\"Set cover\");\n    case ROWCLASS_GUB:         return(\"GUB\");\n    default:                   return(\"Error\");\n  }\n}\n\nSTATIC char *get_str_constr_type(lprec *lp, int con_type)\n{\n  switch(con_type) {\n    case FR: return(\"FR\");\n    case LE: return(\"LE\");\n    case GE: return(\"GE\");\n    case EQ: return(\"EQ\");\n    default: return(\"Error\");\n  }\n}\n\nSTATIC int get_constr_class(lprec *lp, int rownr)\n{\n  int    aBIN = 0, aINT = 0, aREAL = 0,\n         xBIN = 0, xINT = 0, xREAL = 0;\n  int    j, elmnr, elmend, nelm;\n  MYBOOL chsign;\n  REAL   a;\n  MATrec *mat = lp->matA;\n\n  if((rownr < 1) || (rownr > lp->rows)) {\n    report(lp, IMPORTANT, \"get_constr_class: Row %d out of range\\n\", rownr);\n    return( ROWCLASS_Unknown );\n  }\n  mat_validate(mat);\n\n  /* Tally counts of constraint variable types and coefficients */\n  if(rownr == 0) {\n    elmnr = 1;\n    elmend = lp->columns;\n    nelm = 0;\n  }\n  else {\n    elmnr  = mat->row_end[rownr - 1];\n    elmend = mat->row_end[rownr];\n    nelm = elmend - elmnr;\n  }\n  chsign = is_chsign(lp, rownr);\n  for(; elmnr < elmend; elmnr++) {\n    if(rownr == 0) {\n      a = lp->orig_obj[elmnr];\n      if(a == 0)\n        continue;\n      j = elmnr;\n    }\n    else {\n      j = ROW_MAT_COLNR(elmnr);\n      a = ROW_MAT_VALUE(elmnr);\n    }\n    a = unscaled_mat(lp, my_chsign(chsign, a), rownr, j);\n    if(is_binary(lp, j))\n      xBIN++;\n    else if((get_lowbo(lp, j) >= 0) && is_int(lp, j))\n      xINT++;\n    else\n      xREAL++;  /* Includes integer variables with negative lower bound */\n\n    if(fabs(a-1.0) < lp->epsvalue)\n      aBIN++;\n    else if((a > 0) && (fabs(floor(a+lp->epsvalue)-a) < lp->epsvalue))\n      aINT++;\n    else\n      aREAL++;  /* Includes negative integer-valued coefficients */\n  }\n\n  /* Get the constraint type and the RHS */\n  if(rownr == 0)\n    return( ROWCLASS_Objective );\n  j = get_constr_type(lp, rownr);\n  a = get_rh(lp, rownr);\n\n  /* Determine the constraint class */\n  if((aBIN == nelm) && (xBIN == nelm) && (a >= 1)) {\n    if(a > 1)\n      j = ROWCLASS_KnapsackBIN;\n    else if(j == EQ)\n      j = ROWCLASS_GUB;\n    else if(j == LE)\n      j = ROWCLASS_SetCover;\n    else\n      j = ROWCLASS_SetPacking;\n  }\n  else if((aINT == nelm) && (xINT == nelm) && (a >= 1))\n    j = ROWCLASS_KnapsackINT;\n  else if(xBIN == nelm)\n    j = ROWCLASS_GeneralBIN;\n  else if(xINT == nelm)\n    j = ROWCLASS_GeneralINT;\n  else if((xREAL > 0) && (xINT+xBIN > 0))\n    j = ROWCLASS_GeneralMIP;\n  else\n    j = ROWCLASS_GeneralREAL;\n\n  return( j );\n}\n\nREAL __WINAPI get_mat(lprec *lp, int rownr, int colnr)\n{\n  REAL value;\n  int  elmnr;\n\n  if((rownr < 0) || (rownr > lp->rows)) {\n    report(lp, IMPORTANT, \"get_mat: Row %d out of range\", rownr);\n    return(0);\n  }\n  if((colnr < 1) || (colnr > lp->columns)) {\n    report(lp, IMPORTANT, \"get_mat: Column %d out of range\", colnr);\n    return(0);\n  }\n  if(lp->matA->is_roworder) {\n    report(lp, IMPORTANT, \"get_mat: Cannot read a matrix value while in row entry mode.\\n\");\n    return(0);\n  }\n\n  if(rownr == 0) {\n    value = lp->orig_obj[colnr];\n    value = my_chsign(is_chsign(lp, rownr), value);\n    value = unscaled_mat(lp, value, rownr, colnr);\n  }\n  else {\n    elmnr = mat_findelm(lp->matA, rownr, colnr);\n    if(elmnr >= 0) {\n      MATrec *mat = lp->matA;\n      value = my_chsign(is_chsign(lp, rownr), COL_MAT_VALUE(elmnr));\n      value = unscaled_mat(lp, value, rownr, colnr);\n    }\n    else\n      value = 0;\n  }\n  return(value);\n}\n\nREAL __WINAPI get_mat_byindex(lprec *lp, int matindex, MYBOOL isrow, MYBOOL adjustsign)\n/* Note that this function does not adjust for sign-changed GT constraints! */\n{\n  int  *rownr, *colnr;\n  REAL *value, result;\n\n  mat_get_data(lp, matindex, isrow, &rownr, &colnr, &value);\n  if(adjustsign)\n    result = (*value) * (is_chsign(lp, *rownr) ? -1 : 1);\n  else\n    result = *value;\n  if(lp->scaling_used)\n    return( unscaled_mat(lp, result, *rownr, *colnr) );\n  else\n    return( result );\n}\n\nint __WINAPI get_rowex(lprec *lp, int rownr, REAL *row, int *colno)\n{\n  MYBOOL isnz;\n  int    j, countnz = 0;\n  REAL   a;\n\n  if((rownr < 0) || (rownr > lp->rows)) {\n    report(lp, IMPORTANT, \"get_rowex: Row %d out of range\\n\", rownr);\n    return( -1 );\n  }\n  if(lp->matA->is_roworder) {\n    report(lp, IMPORTANT, \"get_rowex: Cannot return a matrix row while in row entry mode.\\n\");\n    return( -1 );\n  }\n\n  if((rownr == 0) || !mat_validate(lp->matA)) {\n    for(j = 1; j <= lp->columns; j++) {\n      a = get_mat(lp,rownr,j);\n      isnz = (a != 0);\n      if(colno == NULL)\n        row[j] = a;\n      else if(isnz) {\n        row[countnz]   = a;\n        colno[countnz] = j;\n      }\n      if(isnz)\n        countnz++;\n    }\n  }\n  else {\n    MYBOOL chsign;\n    int    ie, i;\n    MATrec *mat = lp->matA;\n\n    i = mat->row_end[rownr-1];\n    ie = mat->row_end[rownr];\n    chsign = is_chsign(lp, rownr);\n    if(colno == NULL)\n      MEMCLEAR(row, lp->columns+1);\n    for(; i < ie; i++) {\n      j = ROW_MAT_COLNR(i);\n      a = get_mat_byindex(lp, i, TRUE, FALSE);\n      a = my_chsign(chsign, a);\n      if(colno == NULL)\n        row[j] = a;\n      else {\n        row[countnz]   = a;\n        colno[countnz] = j;\n      }\n      countnz++;\n    }\n  }\n  return( countnz );\n}\n\nMYBOOL __WINAPI get_row(lprec *lp, int rownr, REAL *row)\n{\n  return((MYBOOL) (get_rowex(lp, rownr, row, NULL) >= 0) );\n}\n\nint __WINAPI get_columnex(lprec *lp, int colnr, REAL *column, int *nzrow)\n{\n  int    n = 0, i, ii, ie, *rownr;\n  REAL   hold, *value;\n  MATrec *mat = lp->matA;\n\n  if((colnr > lp->columns) || (colnr < 1)) {\n    report(lp, IMPORTANT, \"get_columnex: Column %d out of range\\n\", colnr);\n    return( -1 );\n  }\n  if(mat->is_roworder) {\n    report(lp, IMPORTANT, \"get_columnex: Cannot return a column while in row entry mode\\n\");\n    return( -1 );\n  }\n\n  /* Add the objective function */\n  if(nzrow == NULL)\n    MEMCLEAR(column, lp->rows + 1);\n  hold = get_mat(lp, 0, colnr);\n  if(nzrow == NULL) {\n    column[n] = hold;\n    if(hold != 0)\n      n++;\n  }\n  else if(hold != 0) {\n    column[n] = hold;\n    nzrow[n] = 0;\n    n++;\n  }\n\n  i  = lp->matA->col_end[colnr - 1];\n  ie = lp->matA->col_end[colnr];\n  if(nzrow == NULL)\n    n += ie - i;\n  rownr = &COL_MAT_ROWNR(i);\n  value = &COL_MAT_VALUE(i);\n  for(; i < ie;\n      i++, rownr += matRowColStep, value += matValueStep) {\n    ii = *rownr;\n\n    hold = my_chsign(is_chsign(lp, ii), *value);\n    hold = unscaled_mat(lp, hold, ii, colnr);\n    if(nzrow == NULL)\n      column[ii] = hold;\n    else if(hold != 0) {\n      column[n] = hold;\n      nzrow[n] = ii;\n      n++;\n    }\n  }\n  return( n );\n}\n\nMYBOOL __WINAPI get_column(lprec *lp, int colnr, REAL *column)\n{\n  return( (MYBOOL) (get_columnex(lp, colnr, column, NULL) >= 0) );\n}\n\nSTATIC void set_OF_override(lprec *lp, REAL *ofVector)\n/* The purpose of this function is to set, or clear if NULL, the\n   ofVector[0..columns] as the active objective function instead of\n   the one stored in the A-matrix. See also lag_solve().*/\n{\n  lp->obj = ofVector;\n}\n\nMYBOOL modifyOF1(lprec *lp, int index, REAL *ofValue, REAL mult)\n/* Adjust objective function values for primal/dual phase 1, if appropriate */\n{\n  MYBOOL accept = TRUE;\n/*  static MYBOOL accept;\n  accept = TRUE;  */\n\n  /* Primal simplex: Set user variables to zero or BigM-scaled */\n  if(((lp->simplex_mode & SIMPLEX_Phase1_PRIMAL) != 0) && (abs(lp->P1extraDim) > 0)) {\n#ifndef Phase1EliminateRedundant\n    if(lp->P1extraDim < 0) {\n      if(index > lp->sum + lp->P1extraDim)\n        accept = FALSE;\n    }\n    else\n#endif\n    if((index <= lp->sum - lp->P1extraDim) || (mult == 0)) {\n      if((mult == 0) || (lp->bigM == 0))\n        accept = FALSE;\n      else\n        (*ofValue) /= lp->bigM;\n    }\n  }\n\n  /* Dual simplex: Subtract P1extraVal from objective function values */\n  else if(((lp->simplex_mode & SIMPLEX_Phase1_DUAL) != 0) && (index > lp->rows)) {\n#if 1  /* This may help increase sparsity of the (extended) basis matrix;\n         Can it introduce degeneracy in some cases? */\n    if((lp->P1extraVal != 0) && (lp->orig_obj[index - lp->rows] > 0))\n      *ofValue = 0;\n    else\n#endif\n    {\n      *ofValue -= lp->P1extraVal;\n#if 0\n      if(is_action(lp->anti_degen, ANTIDEGEN_RHSPERTURB))\n        *ofValue -= rand_uniform(lp, lp->epsperturb);\n#endif\n    }\n  }\n\n  /* Do scaling and test for zero */\n  if(accept) {\n    (*ofValue) *= mult;\n    if(fabs(*ofValue) < lp->epsmachine) {\n      (*ofValue) = 0;\n      accept = FALSE;\n    }\n  }\n  else\n    (*ofValue) = 0;\n\n  return( accept );\n}\n\nSTATIC void set_OF_p1extra(lprec *lp, REAL p1extra)\n{\n  int  i;\n  REAL *value;\n\n  if(lp->spx_trace)\n    report(lp, DETAILED, \"set_OF_p1extra: Set dual objective offset to %g at iter %.0f.\\n\",\n                          p1extra, (double) get_total_iter(lp));\n  lp->P1extraVal = p1extra;\n  if(lp->obj == NULL)\n    allocREAL(lp, &lp->obj, lp->columns_alloc+1, TRUE);\n  for(i = 1, value = lp->obj+1; i <= lp->columns; i++, value++) {\n    *value = lp->orig_obj[i];\n    modifyOF1(lp, lp->rows + i, value, 1.0);\n  }\n}\n\nSTATIC void unset_OF_p1extra(lprec *lp)\n{\n  lp->P1extraVal = 0;\n  FREE(lp->obj);\n}\n\nREAL __WINAPI get_OF_active(lprec *lp, int varnr, REAL mult)\n{\n  int  colnr = varnr - lp->rows;\n  REAL holdOF = 0;\n\n#ifdef Paranoia\n  if((colnr <= 0) || (colnr > lp->columns)) {\n    report(lp, SEVERE, \"get_OF_active: Invalid column index %d supplied\\n\", colnr);\n  }\n  else\n#endif\n  if(lp->obj == NULL) {\n    if(colnr > 0)\n      holdOF = lp->orig_obj[colnr];\n    modifyOF1(lp, varnr, &holdOF, mult);\n  }\n  else if(colnr > 0)\n    holdOF = lp->obj[colnr] * mult;\n\n  return( holdOF );\n}\n\nSTATIC MYBOOL is_OF_nz(lprec *lp, int colnr)\n{\n  return( (MYBOOL) (lp->orig_obj[colnr] != 0) );\n}\n\nSTATIC int singleton_column(lprec *lp, int row_nr, REAL *column, int *nzlist, REAL value, int *maxabs)\n{\n  int nz = 1;\n\n  if(nzlist == NULL) {\n    MEMCLEAR(column, lp->rows + 1);\n    column[row_nr] = value;\n  }\n  else {\n    column[nz] = value;\n    nzlist[nz] = row_nr;\n  }\n\n  if(maxabs != NULL)\n    *maxabs = row_nr;\n  return( nz );\n}\n\nSTATIC int expand_column(lprec *lp, int col_nr, REAL *column, int *nzlist, REAL mult, int *maxabs)\n{\n  int     i, ie, j, maxidx, nzcount;\n  REAL    value, maxval;\n  MATrec  *mat = lp->matA;\n  REAL    *matValue;\n  int     *matRownr;\n\n  /* Retrieve a column from the user data matrix A */\n  maxval = 0;\n  maxidx = -1;\n  if(nzlist == NULL) {\n    MEMCLEAR(column, lp->rows + 1);\n    i  = mat->col_end[col_nr - 1];\n    ie = mat->col_end[col_nr];\n    matRownr = &COL_MAT_ROWNR(i);\n    matValue = &COL_MAT_VALUE(i);\n    nzcount = i;\n    for(; i < ie;\n        i++, matRownr += matRowColStep, matValue += matValueStep) {\n      j = *matRownr;\n      value = *matValue;\n      if(j > 0) {\n        value *= mult;\n        if(fabs(value) > maxval) {\n          maxval = fabs(value);\n          maxidx = j;\n        }\n      }\n      column[j] = value;\n    }\n    nzcount = i - nzcount;\n\n    /* Get the objective as row 0, optionally adjusting the objective for phase 1 */\n    if(lp->obj_in_basis) {\n      column[0] = get_OF_active(lp, lp->rows+col_nr, mult);\n      if(column[0] != 0)\n        nzcount++;\n    }\n  }\n  else {\n    nzcount = 0;\n\n    /* Get the objective as row 0, optionally adjusting the objective for phase 1 */\n    if(lp->obj_in_basis) {\n      value = get_OF_active(lp, lp->rows+col_nr, mult);\n      if(value != 0) {\n        nzcount++;\n        nzlist[nzcount] = 0;\n        column[nzcount] = value;\n      }\n    }\n\n    /* Loop over the non-zero column entries */\n    i  = mat->col_end[col_nr - 1];\n    ie = mat->col_end[col_nr];\n    matRownr = &COL_MAT_ROWNR(i);\n    matValue = &COL_MAT_VALUE(i);\n    for(; i < ie;\n        i++, matRownr += matRowColStep, matValue += matValueStep) {\n      j = *matRownr;\n      value = (*matValue) * mult;\n      nzcount++;\n      nzlist[nzcount] = j;\n      column[nzcount] = value;\n      if(fabs(value) > maxval) {\n        maxval = fabs(value);\n        maxidx = nzcount;\n      }\n    }\n  }\n\n  if(maxabs != NULL)\n    *maxabs = maxidx;\n  return( nzcount );\n}\n\n\n/* Retrieve a column vector from the data matrix [1..rows, rows+1..rows+columns];\n   needs __WINAPI call model since it may be called from BFPs */\nint __WINAPI obtain_column(lprec *lp, int varin, REAL *pcol, int *nzlist, int *maxabs)\n{\n  REAL value = my_chsign(lp->is_lower[varin], -1);\n  if(varin > lp->rows) {\n    varin -= lp->rows;\n    varin = expand_column(lp, varin, pcol, nzlist, value, maxabs);\n  }\n  else if(lp->obj_in_basis || (varin > 0))\n    varin = singleton_column(lp, varin, pcol, nzlist, value, maxabs);\n  else\n    varin = get_basisOF(lp, NULL, pcol, nzlist);\n\n  return(varin);\n}\n\n/* GENERAL INVARIANT CALLBACK FUNCTIONS */\nMYBOOL set_callbacks(lprec *lp)\n{\n  /* Assign API functions to lp structure (mainly for XLIs) */\n  lp->add_column              = add_column;\n  lp->add_columnex            = add_columnex;\n  lp->add_constraint          = add_constraint;\n  lp->add_constraintex        = add_constraintex;\n  lp->add_lag_con             = add_lag_con;\n  lp->add_SOS                 = add_SOS;\n  lp->column_in_lp            = column_in_lp;\n  lp->copy_lp                 = copy_lp;\n  lp->default_basis           = default_basis;\n  lp->del_column              = del_column;\n  lp->del_constraint          = del_constraint;\n  lp->delete_lp               = delete_lp;\n  lp->dualize_lp              = dualize_lp;\n  lp->free_lp                 = free_lp;\n  lp->get_anti_degen          = get_anti_degen;\n  lp->get_basis               = get_basis;\n  lp->get_basiscrash          = get_basiscrash;\n  lp->get_bb_depthlimit       = get_bb_depthlimit;\n  lp->get_bb_floorfirst       = get_bb_floorfirst;\n  lp->get_bb_rule             = get_bb_rule;\n  lp->get_bounds_tighter      = get_bounds_tighter;\n  lp->get_break_at_value      = get_break_at_value;\n  lp->get_col_name            = get_col_name;\n  lp->get_columnex            = get_columnex;\n  lp->get_constr_type         = get_constr_type;\n  lp->get_constr_value        = get_constr_value;\n  lp->get_constraints         = get_constraints;\n  lp->get_dual_solution       = get_dual_solution;\n  lp->get_epsb                = get_epsb;\n  lp->get_epsd                = get_epsd;\n  lp->get_epsel               = get_epsel;\n  lp->get_epsint              = get_epsint;\n  lp->get_epsperturb          = get_epsperturb;\n  lp->get_epspivot            = get_epspivot;\n  lp->get_improve             = get_improve;\n  lp->get_infinite            = get_infinite;\n  lp->get_lambda              = get_lambda;\n  lp->get_lowbo               = get_lowbo;\n  lp->get_lp_index            = get_lp_index;\n  lp->get_lp_name             = get_lp_name;\n  lp->get_Lrows               = get_Lrows;\n  lp->get_mat                 = get_mat;\n  lp->get_mat_byindex         = get_mat_byindex;\n  lp->get_max_level           = get_max_level;\n  lp->get_maxpivot            = get_maxpivot;\n  lp->get_mip_gap             = get_mip_gap;\n  lp->get_multiprice          = get_multiprice;\n  lp->get_nameindex           = get_nameindex;\n  lp->get_Ncolumns            = get_Ncolumns;\n  lp->get_negrange            = get_negrange;\n  lp->get_nonzeros            = get_nonzeros;\n  lp->get_Norig_columns       = get_Norig_columns;\n  lp->get_Norig_rows          = get_Norig_rows;\n  lp->get_Nrows               = get_Nrows;\n  lp->get_obj_bound           = get_obj_bound;\n  lp->get_objective           = get_objective;\n  lp->get_orig_index          = get_orig_index;\n  lp->get_origcol_name        = get_origcol_name;\n  lp->get_origrow_name        = get_origrow_name;\n  lp->get_partialprice        = get_partialprice;\n  lp->get_pivoting            = get_pivoting;\n  lp->get_presolve            = get_presolve;\n  lp->get_presolveloops       = get_presolveloops;\n  lp->get_primal_solution     = get_primal_solution;\n  lp->get_print_sol           = get_print_sol;\n  lp->get_pseudocosts         = get_pseudocosts;\n  lp->get_ptr_constraints     = get_ptr_constraints;\n  lp->get_ptr_dual_solution   = get_ptr_dual_solution;\n  lp->get_ptr_lambda          = get_ptr_lambda;\n  lp->get_ptr_primal_solution = get_ptr_primal_solution;\n  lp->get_ptr_sensitivity_obj = get_ptr_sensitivity_obj;\n  lp->get_ptr_sensitivity_objex = get_ptr_sensitivity_objex;\n  lp->get_ptr_sensitivity_rhs = get_ptr_sensitivity_rhs;\n  lp->get_ptr_variables       = get_ptr_variables;\n  lp->get_rh                  = get_rh;\n  lp->get_rh_range            = get_rh_range;\n  lp->get_row                 = get_row;\n  lp->get_rowex               = get_rowex;\n  lp->get_row_name            = get_row_name;\n  lp->get_scalelimit          = get_scalelimit;\n  lp->get_scaling             = get_scaling;\n  lp->get_sensitivity_obj     = get_sensitivity_obj;\n  lp->get_sensitivity_objex   = get_sensitivity_objex;\n  lp->get_sensitivity_rhs     = get_sensitivity_rhs;\n  lp->get_simplextype         = get_simplextype;\n  lp->get_solutioncount       = get_solutioncount;\n  lp->get_solutionlimit       = get_solutionlimit;\n  lp->get_status              = get_status;\n  lp->get_statustext          = get_statustext;\n  lp->get_timeout             = get_timeout;\n  lp->get_total_iter          = get_total_iter;\n  lp->get_total_nodes         = get_total_nodes;\n  lp->get_upbo                = get_upbo;\n  lp->get_var_branch          = get_var_branch;\n  lp->get_var_dualresult      = get_var_dualresult;\n  lp->get_var_primalresult    = get_var_primalresult;\n  lp->get_var_priority        = get_var_priority;\n  lp->get_variables           = get_variables;\n  lp->get_verbose             = get_verbose;\n  lp->get_working_objective   = get_working_objective;\n  lp->has_BFP                 = has_BFP;\n  lp->has_XLI                 = has_XLI;\n  lp->is_add_rowmode          = is_add_rowmode;\n  lp->is_anti_degen           = is_anti_degen;\n  lp->is_binary               = is_binary;\n  lp->is_break_at_first       = is_break_at_first;\n  lp->is_constr_type          = is_constr_type;\n  lp->is_debug                = is_debug;\n  lp->is_feasible             = is_feasible;\n  lp->is_unbounded            = is_unbounded;\n  lp->is_infinite             = is_infinite;\n  lp->is_int                  = is_int;\n  lp->is_integerscaling       = is_integerscaling;\n  lp->is_lag_trace            = is_lag_trace;\n  lp->is_maxim                = is_maxim;\n  lp->is_nativeBFP            = is_nativeBFP;\n  lp->is_nativeXLI            = is_nativeXLI;\n  lp->is_negative             = is_negative;\n  lp->is_obj_in_basis         = is_obj_in_basis;\n  lp->is_piv_mode             = is_piv_mode;\n  lp->is_piv_rule             = is_piv_rule;\n  lp->is_presolve             = is_presolve;\n  lp->is_scalemode            = is_scalemode;\n  lp->is_scaletype            = is_scaletype;\n  lp->is_semicont             = is_semicont;\n  lp->is_SOS_var              = is_SOS_var;\n  lp->is_trace                = is_trace;\n  lp->lp_solve_version        = lp_solve_version;\n  lp->make_lp                 = make_lp;\n  lp->print_constraints       = print_constraints;\n  lp->print_debugdump         = print_debugdump;\n  lp->print_duals             = print_duals;\n  lp->print_lp                = print_lp;\n  lp->print_objective         = print_objective;\n  lp->print_scales            = print_scales;\n  lp->print_solution          = print_solution;\n  lp->print_str               = print_str;\n  lp->print_tableau           = print_tableau;\n  lp->put_abortfunc           = put_abortfunc;\n  lp->put_bb_nodefunc         = put_bb_nodefunc;\n  lp->put_bb_branchfunc       = put_bb_branchfunc;\n  lp->put_logfunc             = put_logfunc;\n  lp->put_msgfunc             = put_msgfunc;\n  lp->read_LPhandle           = LP_readhandle;\n  lp->read_MPShandle          = MPS_readhandle;\n  lp->read_XLI                = read_XLI;\n  lp->read_basis              = read_basis;\n  lp->reset_basis             = reset_basis;\n  lp->read_params             = read_params;\n  lp->reset_params            = reset_params;\n  lp->resize_lp               = resize_lp;\n  lp->set_action              = set_action;\n  lp->set_add_rowmode         = set_add_rowmode;\n  lp->set_anti_degen          = set_anti_degen;\n  lp->set_basisvar            = set_basisvar;\n  lp->set_basis               = set_basis;\n  lp->set_basiscrash          = set_basiscrash;\n  lp->set_bb_depthlimit       = set_bb_depthlimit;\n  lp->set_bb_floorfirst       = set_bb_floorfirst;\n  lp->set_bb_rule             = set_bb_rule;\n  lp->set_BFP                 = set_BFP;\n  lp->set_binary              = set_binary;\n  lp->set_bounds              = set_bounds;\n  lp->set_bounds_tighter      = set_bounds_tighter;\n  lp->set_break_at_first      = set_break_at_first;\n  lp->set_break_at_value      = set_break_at_value;\n  lp->set_col_name            = set_col_name;\n  lp->set_constr_type         = set_constr_type;\n  lp->set_debug               = set_debug;\n  lp->set_epsb                = set_epsb;\n  lp->set_epsd                = set_epsd;\n  lp->set_epsel               = set_epsel;\n  lp->set_epsint              = set_epsint;\n  lp->set_epslevel            = set_epslevel;\n  lp->set_epsperturb          = set_epsperturb;\n  lp->set_epspivot            = set_epspivot;\n  lp->set_unbounded           = set_unbounded;\n  lp->set_improve             = set_improve;\n  lp->set_infinite            = set_infinite;\n  lp->set_int                 = set_int;\n  lp->set_lag_trace           = set_lag_trace;\n  lp->set_lowbo               = set_lowbo;\n  lp->set_lp_name             = set_lp_name;\n  lp->set_mat                 = set_mat;\n  lp->set_maxim               = set_maxim;\n  lp->set_maxpivot            = set_maxpivot;\n  lp->set_minim               = set_minim;\n  lp->set_mip_gap             = set_mip_gap;\n  lp->set_multiprice          = set_multiprice;\n  lp->set_negrange            = set_negrange;\n  lp->set_obj                 = set_obj;\n  lp->set_obj_bound           = set_obj_bound;\n  lp->set_obj_fn              = set_obj_fn;\n  lp->set_obj_fnex            = set_obj_fnex;\n  lp->set_obj_in_basis        = set_obj_in_basis;\n  lp->set_outputfile          = set_outputfile;\n  lp->set_outputstream        = set_outputstream;\n  lp->set_partialprice        = set_partialprice;\n  lp->set_pivoting            = set_pivoting;\n  lp->set_preferdual          = set_preferdual;\n  lp->set_presolve            = set_presolve;\n  lp->set_print_sol           = set_print_sol;\n  lp->set_pseudocosts         = set_pseudocosts;\n  lp->set_rh                  = set_rh;\n  lp->set_rh_range            = set_rh_range;\n  lp->set_rh_vec              = set_rh_vec;\n  lp->set_row                 = set_row;\n  lp->set_rowex               = set_rowex;\n  lp->set_row_name            = set_row_name;\n  lp->set_scalelimit          = set_scalelimit;\n  lp->set_scaling             = set_scaling;\n  lp->set_semicont            = set_semicont;\n  lp->set_sense               = set_sense;\n  lp->set_simplextype         = set_simplextype;\n  lp->set_solutionlimit       = set_solutionlimit;\n  lp->set_timeout             = set_timeout;\n  lp->set_trace               = set_trace;\n  lp->set_upbo                = set_upbo;\n  lp->set_var_branch          = set_var_branch;\n  lp->set_var_weights         = set_var_weights;\n  lp->set_verbose             = set_verbose;\n  lp->set_XLI                 = set_XLI;\n  lp->solve                   = solve;\n  lp->str_add_column          = str_add_column;\n  lp->str_add_constraint      = str_add_constraint;\n  lp->str_add_lag_con         = str_add_lag_con;\n  lp->str_set_obj_fn          = str_set_obj_fn;\n  lp->str_set_rh_vec          = str_set_rh_vec;\n  lp->time_elapsed            = time_elapsed;\n  lp->unscale                 = unscale;\n  lp->write_lp                = write_lp;\n  lp->write_LP                = write_LP;\n  lp->write_mps               = write_mps;\n  lp->write_freemps           = write_freemps;\n  lp->write_MPS               = write_MPS;\n  lp->write_freeMPS           = write_freeMPS;\n  lp->write_XLI               = write_XLI;\n  lp->write_basis             = write_basis;\n  lp->write_params            = write_params;\n\n  /* Utility functions (mainly for BFPs) */\n  lp->userabort               = userabort;\n  lp->report                  = report;\n  lp->explain                 = explain;\n  lp->set_basisvar            = set_basisvar;\n  lp->get_lpcolumn            = obtain_column;\n  lp->get_basiscolumn         = get_basiscolumn;\n  lp->get_OF_active           = get_OF_active;\n  lp->getMDO                  = getMDO;\n  lp->invert                  = invert;\n  lp->set_action              = set_action;\n  lp->clear_action            = clear_action;\n  lp->is_action               = is_action;\n\n  return( TRUE );\n}\n\n/* SUPPORT FUNCTION FOR BASIS FACTORIZATION PACKAGES */\nMYBOOL __WINAPI has_BFP(lprec *lp)\n{\n  return( is_nativeBFP(lp)\n#if LoadInverseLib == TRUE\n       || (MYBOOL) (lp->hBFP != NULL)\n#endif\n        );\n}\n\nMYBOOL __WINAPI is_nativeBFP(lprec *lp)\n{\n#ifdef ExcludeNativeInverse\n  return( FALSE );\n#elif LoadInverseLib == TRUE\n  return( (MYBOOL) (lp->hBFP == NULL) );\n#else\n  return( TRUE );\n#endif\n}\n\nMYBOOL __WINAPI set_BFP(lprec *lp, char *filename)\n/* (Re)mapping of basis factorization variant methods is done here */\n{\n  int result = LIB_LOADED;\n\n  /* Release the BFP and basis if we are active */\n  if(lp->invB != NULL)\n    bfp_free(lp);\n\n#if LoadInverseLib == TRUE\n  if(lp->hBFP != NULL) {\n  #ifdef WIN32\n    FreeLibrary(lp->hBFP);\n  #else\n    dlclose(lp->hBFP);\n  #endif\n    lp->hBFP = NULL;\n  }\n#endif\n\n  if(filename == NULL) {\n    if(!is_nativeBFP(lp))\n      return( FALSE );\n#ifndef ExcludeNativeInverse\n    lp->bfp_name = bfp_name;\n    lp->bfp_compatible = bfp_compatible;\n    lp->bfp_free = bfp_free;\n    lp->bfp_resize = bfp_resize;\n    lp->bfp_nonzeros = bfp_nonzeros;\n    lp->bfp_memallocated = bfp_memallocated;\n    lp->bfp_restart = bfp_restart;\n    lp->bfp_mustrefactorize = bfp_mustrefactorize;\n    lp->bfp_preparefactorization = bfp_preparefactorization;\n    lp->bfp_factorize = bfp_factorize;\n    lp->bfp_finishupdate = bfp_finishupdate;\n    lp->bfp_ftran_normal = bfp_ftran_normal;\n    lp->bfp_ftran_prepare = bfp_ftran_prepare;\n    lp->bfp_btran_normal = bfp_btran_normal;\n    lp->bfp_status = bfp_status;\n    lp->bfp_implicitslack = bfp_implicitslack;\n    lp->bfp_indexbase = bfp_indexbase;\n    lp->bfp_rowoffset = bfp_rowoffset;\n    lp->bfp_pivotmax = bfp_pivotmax;\n    lp->bfp_init = bfp_init;\n    lp->bfp_pivotalloc = bfp_pivotalloc;\n    lp->bfp_colcount = bfp_colcount;\n    lp->bfp_canresetbasis = bfp_canresetbasis;\n    lp->bfp_finishfactorization = bfp_finishfactorization;\n    lp->bfp_updaterefactstats = bfp_updaterefactstats;\n    lp->bfp_prepareupdate = bfp_prepareupdate;\n    lp->bfp_pivotRHS = bfp_pivotRHS;\n    lp->bfp_btran_double = bfp_btran_double;\n    lp->bfp_efficiency = bfp_efficiency;\n    lp->bfp_pivotvector = bfp_pivotvector;\n    lp->bfp_pivotcount = bfp_pivotcount;\n    lp->bfp_refactcount = bfp_refactcount;\n    lp->bfp_isSetI = bfp_isSetI;\n    lp->bfp_findredundant = bfp_findredundant;\n#endif\n  }\n  else {\n#if LoadInverseLib == TRUE\n  #ifdef WIN32\n   /* Get a handle to the Windows DLL module. */\n    lp->hBFP = LoadLibrary(filename);\n\n   /* If the handle is valid, try to get the function addresses. */\n    if(lp->hBFP != NULL) {\n      lp->bfp_compatible           = (BFPbool_lpintintint *)\n                                      GetProcAddress(lp->hBFP, \"bfp_compatible\");\n      if(lp->bfp_compatible == NULL)\n        result = LIB_NOINFO;\n      else if(lp->bfp_compatible(lp, BFPVERSION, MAJORVERSION, sizeof(REAL))) {\n\n      lp->bfp_name                 = (BFPchar *)\n                                      GetProcAddress(lp->hBFP, \"bfp_name\");\n      lp->bfp_free                 = (BFP_lp *)\n                                      GetProcAddress(lp->hBFP, \"bfp_free\");\n      lp->bfp_resize               = (BFPbool_lpint *)\n                                      GetProcAddress(lp->hBFP, \"bfp_resize\");\n      lp->bfp_nonzeros             = (BFPint_lpbool *)\n                                      GetProcAddress(lp->hBFP, \"bfp_nonzeros\");\n      lp->bfp_memallocated         = (BFPint_lp *)\n                                      GetProcAddress(lp->hBFP, \"bfp_memallocated\");\n      lp->bfp_restart              = (BFPbool_lp *)\n                                      GetProcAddress(lp->hBFP, \"bfp_restart\");\n      lp->bfp_mustrefactorize      = (BFPbool_lp *)\n                                      GetProcAddress(lp->hBFP, \"bfp_mustrefactorize\");\n      lp->bfp_preparefactorization = (BFPint_lp *)\n                                      GetProcAddress(lp->hBFP, \"bfp_preparefactorization\");\n      lp->bfp_factorize            = (BFPint_lpintintboolbool *)\n                                      GetProcAddress(lp->hBFP, \"bfp_factorize\");\n      lp->bfp_finishupdate         = (BFPbool_lpbool *)\n                                      GetProcAddress(lp->hBFP, \"bfp_finishupdate\");\n      lp->bfp_ftran_normal         = (BFP_lprealint *)\n                                      GetProcAddress(lp->hBFP, \"bfp_ftran_normal\");\n      lp->bfp_ftran_prepare        = (BFP_lprealint *)\n                                      GetProcAddress(lp->hBFP, \"bfp_ftran_prepare\");\n      lp->bfp_btran_normal         = (BFP_lprealint *)\n                                      GetProcAddress(lp->hBFP, \"bfp_btran_normal\");\n      lp->bfp_status               = (BFPint_lp *)\n                                      GetProcAddress(lp->hBFP, \"bfp_status\");\n      lp->bfp_implicitslack        = (BFPbool_lp *)\n                                      GetProcAddress(lp->hBFP, \"bfp_implicitslack\");\n      lp->bfp_indexbase            = (BFPint_lp *)\n                                      GetProcAddress(lp->hBFP, \"bfp_indexbase\");\n      lp->bfp_rowoffset            = (BFPint_lp *)\n                                      GetProcAddress(lp->hBFP, \"bfp_rowoffset\");\n      lp->bfp_pivotmax             = (BFPint_lp *)\n                                      GetProcAddress(lp->hBFP, \"bfp_pivotmax\");\n      lp->bfp_init                 = (BFPbool_lpintintchar *)\n                                      GetProcAddress(lp->hBFP, \"bfp_init\");\n      lp->bfp_pivotalloc           = (BFPbool_lpint *)\n                                      GetProcAddress(lp->hBFP, \"bfp_pivotalloc\");\n      lp->bfp_colcount             = (BFPint_lp *)\n                                      GetProcAddress(lp->hBFP, \"bfp_colcount\");\n      lp->bfp_canresetbasis        = (BFPbool_lp *)\n                                      GetProcAddress(lp->hBFP, \"bfp_canresetbasis\");\n      lp->bfp_finishfactorization  = (BFP_lp *)\n                                      GetProcAddress(lp->hBFP, \"bfp_finishfactorization\");\n      lp->bfp_updaterefactstats    = (BFP_lp *)\n                                      GetProcAddress(lp->hBFP, \"bfp_updaterefactstats\");\n      lp->bfp_prepareupdate        = (BFPlreal_lpintintreal *)\n                                      GetProcAddress(lp->hBFP, \"bfp_prepareupdate\");\n      lp->bfp_pivotRHS             = (BFPreal_lplrealreal *)\n                                      GetProcAddress(lp->hBFP, \"bfp_pivotRHS\");\n      lp->bfp_btran_double         = (BFP_lprealintrealint *)\n                                      GetProcAddress(lp->hBFP, \"bfp_btran_double\");\n      lp->bfp_efficiency           = (BFPreal_lp *)\n                                      GetProcAddress(lp->hBFP, \"bfp_efficiency\");\n      lp->bfp_pivotvector          = (BFPrealp_lp *)\n                                      GetProcAddress(lp->hBFP, \"bfp_pivotvector\");\n      lp->bfp_pivotcount           = (BFPint_lp *)\n                                      GetProcAddress(lp->hBFP, \"bfp_pivotcount\");\n      lp->bfp_refactcount          = (BFPint_lpint *)\n                                      GetProcAddress(lp->hBFP, \"bfp_refactcount\");\n      lp->bfp_isSetI               = (BFPbool_lp *)\n                                      GetProcAddress(lp->hBFP, \"bfp_isSetI\");\n      lp->bfp_findredundant        = (BFPint_lpintrealcbintint *)\n                                      GetProcAddress(lp->hBFP, \"bfp_findredundant\");\n      }\n      else\n        result = LIB_VERINVALID;\n    }\n  #else\n   /* First standardize UNIX .SO library name format. */\n    char bfpname[260], *ptr;\n\n    strcpy(bfpname, filename);\n    if((ptr = strrchr(filename, '/')) == NULL)\n      ptr = filename;\n    else\n      ptr++;\n    bfpname[(int) (ptr - filename)] = 0;\n    if(strncmp(ptr, \"lib\", 3))\n      strcat(bfpname, \"lib\");\n    strcat(bfpname, ptr);\n    if(strcmp(bfpname + strlen(bfpname) - 3, \".so\"))\n      strcat(bfpname, \".so\");\n\n   /* Get a handle to the module. */\n    lp->hBFP = dlopen(bfpname, RTLD_LAZY);\n\n   /* If the handle is valid, try to get the function addresses. */\n    if(lp->hBFP != NULL) {\n      lp->bfp_compatible           = (BFPbool_lpintintint *)\n                                      dlsym(lp->hBFP, \"bfp_compatible\");\n      if(lp->bfp_compatible == NULL)\n        result = LIB_NOINFO;\n      else if(lp->bfp_compatible(lp, BFPVERSION, MAJORVERSION, sizeof(REAL))) {\n\n      lp->bfp_name                 = (BFPchar *)\n                                      dlsym(lp->hBFP, \"bfp_name\");\n      lp->bfp_free                 = (BFP_lp *)\n                                      dlsym(lp->hBFP, \"bfp_free\");\n      lp->bfp_resize               = (BFPbool_lpint *)\n                                      dlsym(lp->hBFP, \"bfp_resize\");\n      lp->bfp_nonzeros             = (BFPint_lpbool *)\n                                      dlsym(lp->hBFP, \"bfp_nonzeros\");\n      lp->bfp_memallocated         = (BFPint_lp *)\n                                      dlsym(lp->hBFP, \"bfp_memallocated\");\n      lp->bfp_restart              = (BFPbool_lp *)\n                                      dlsym(lp->hBFP, \"bfp_restart\");\n      lp->bfp_mustrefactorize      = (BFPbool_lp *)\n                                      dlsym(lp->hBFP, \"bfp_mustrefactorize\");\n      lp->bfp_preparefactorization = (BFPint_lp *)\n                                      dlsym(lp->hBFP, \"bfp_preparefactorization\");\n      lp->bfp_factorize            = (BFPint_lpintintboolbool *)\n                                      dlsym(lp->hBFP, \"bfp_factorize\");\n      lp->bfp_finishupdate         = (BFPbool_lpbool *)\n                                      dlsym(lp->hBFP, \"bfp_finishupdate\");\n      lp->bfp_ftran_normal         = (BFP_lprealint *)\n                                      dlsym(lp->hBFP, \"bfp_ftran_normal\");\n      lp->bfp_ftran_prepare        = (BFP_lprealint *)\n                                      dlsym(lp->hBFP, \"bfp_ftran_prepare\");\n      lp->bfp_btran_normal         = (BFP_lprealint *)\n                                      dlsym(lp->hBFP, \"bfp_btran_normal\");\n      lp->bfp_status               = (BFPint_lp *)\n                                      dlsym(lp->hBFP, \"bfp_status\");\n      lp->bfp_implicitslack        = (BFPbool_lp *)\n                                      dlsym(lp->hBFP, \"bfp_implicitslack\");\n      lp->bfp_indexbase            = (BFPint_lp *)\n                                      dlsym(lp->hBFP, \"bfp_indexbase\");\n      lp->bfp_rowoffset            = (BFPint_lp *)\n                                      dlsym(lp->hBFP, \"bfp_rowoffset\");\n      lp->bfp_pivotmax             = (BFPint_lp *)\n                                      dlsym(lp->hBFP, \"bfp_pivotmax\");\n      lp->bfp_init                 = (BFPbool_lpintintchar *)\n                                      dlsym(lp->hBFP, \"bfp_init\");\n      lp->bfp_pivotalloc           = (BFPbool_lpint *)\n                                      dlsym(lp->hBFP, \"bfp_pivotalloc\");\n      lp->bfp_colcount             = (BFPint_lp *)\n                                      dlsym(lp->hBFP, \"bfp_colcount\");\n      lp->bfp_canresetbasis        = (BFPbool_lp *)\n                                      dlsym(lp->hBFP, \"bfp_canresetbasis\");\n      lp->bfp_finishfactorization  = (BFP_lp *)\n                                      dlsym(lp->hBFP, \"bfp_finishfactorization\");\n      lp->bfp_updaterefactstats    = (BFP_lp *)\n                                      dlsym(lp->hBFP, \"bfp_updaterefactstats\");\n      lp->bfp_prepareupdate        = (BFPlreal_lpintintreal *)\n                                      dlsym(lp->hBFP, \"bfp_prepareupdate\");\n      lp->bfp_pivotRHS             = (BFPreal_lplrealreal *)\n                                      dlsym(lp->hBFP, \"bfp_pivotRHS\");\n      lp->bfp_btran_double         = (BFP_lprealintrealint *)\n                                      dlsym(lp->hBFP, \"bfp_btran_double\");\n      lp->bfp_efficiency           = (BFPreal_lp *)\n                                      dlsym(lp->hBFP, \"bfp_efficiency\");\n      lp->bfp_pivotvector          = (BFPrealp_lp *)\n                                      dlsym(lp->hBFP, \"bfp_pivotvector\");\n      lp->bfp_pivotcount           = (BFPint_lp *)\n                                      dlsym(lp->hBFP, \"bfp_pivotcount\");\n      lp->bfp_refactcount          = (BFPint_lpint *)\n                                      dlsym(lp->hBFP, \"bfp_refactcount\");\n      lp->bfp_isSetI               = (BFPbool_lp *)\n                                      dlsym(lp->hBFP, \"bfp_isSetI\");\n      lp->bfp_findredundant        = (BFPint_lpintrealcbintint *)\n                                      dlsym(lp->hBFP, \"bfp_findredundant\");\n      }\n      else\n        result = LIB_VERINVALID;\n    }\n  #endif\n    else\n      result = LIB_NOTFOUND;\n#endif\n    /* Do validation */\n    if((result != LIB_LOADED) ||\n       ((lp->bfp_name == NULL) ||\n        (lp->bfp_compatible == NULL) ||\n        (lp->bfp_free == NULL) ||\n        (lp->bfp_resize == NULL) ||\n        (lp->bfp_nonzeros == NULL) ||\n        (lp->bfp_memallocated == NULL) ||\n        (lp->bfp_restart == NULL) ||\n        (lp->bfp_mustrefactorize == NULL) ||\n        (lp->bfp_preparefactorization == NULL) ||\n        (lp->bfp_factorize == NULL) ||\n        (lp->bfp_finishupdate == NULL) ||\n        (lp->bfp_ftran_normal == NULL) ||\n        (lp->bfp_ftran_prepare == NULL) ||\n        (lp->bfp_btran_normal == NULL) ||\n        (lp->bfp_status == NULL) ||\n        (lp->bfp_implicitslack == NULL) ||\n        (lp->bfp_indexbase == NULL) ||\n        (lp->bfp_rowoffset == NULL) ||\n        (lp->bfp_pivotmax == NULL) ||\n        (lp->bfp_init == NULL) ||\n        (lp->bfp_pivotalloc == NULL) ||\n        (lp->bfp_colcount == NULL) ||\n        (lp->bfp_canresetbasis == NULL) ||\n        (lp->bfp_finishfactorization == NULL) ||\n        (lp->bfp_updaterefactstats == NULL) ||\n        (lp->bfp_prepareupdate == NULL) ||\n        (lp->bfp_pivotRHS == NULL) ||\n        (lp->bfp_btran_double == NULL) ||\n        (lp->bfp_efficiency == NULL) ||\n        (lp->bfp_pivotvector == NULL) ||\n        (lp->bfp_pivotcount == NULL) ||\n        (lp->bfp_refactcount == NULL) ||\n        (lp->bfp_isSetI == NULL) ||\n        (lp->bfp_findredundant == NULL)\n       )) {\n      set_BFP(lp, NULL);\n      if(result == LIB_LOADED)\n        result = LIB_NOFUNCTION;\n    }\n  }\n  if(filename != NULL) {\n    char info[LIB_STR_MAXLEN+1];\n    switch(result) {\n      case LIB_NOTFOUND:   strcpy(info, LIB_STR_NOTFOUND);\n                           break;\n      case LIB_NOINFO:     strcpy(info, LIB_STR_NOINFO);\n                           break;\n      case LIB_NOFUNCTION: strcpy(info, LIB_STR_NOFUNCTION);\n                           break;\n      case LIB_VERINVALID: strcpy(info, LIB_STR_VERINVALID);\n                           break;\n      default:             strcpy(info, LIB_STR_LOADED);\n    }\n    report(lp, IMPORTANT, \"set_BFP: %s '%s'\\n\",\n                          info, filename);\n  }\n  return( (MYBOOL) (result == LIB_LOADED));\n}\n\n#include <R.h>\n#include <R_ext/Print.h>\n\n/* External language interface routines */\n/* DON'T MODIFY */\nlprec * __WINAPI read_XLI(char *xliname, char *modelname, char *dataname, char *options, int verbose)\n{\n  lprec *lp;\n\n  lp = make_lp(0, 0);\n  if(lp != NULL) {\n    lp->source_is_file = TRUE;\n    lp->verbose = verbose;\n    if(!set_XLI(lp, xliname)) {\n      free_lp(&lp);\n      Rprintf(\"read_XLI: No valid XLI package selected or available.\\n\");\n    }\n    else {\n      if(!lp->xli_readmodel(lp, modelname, dataname, options, verbose))\n        free_lp(&lp);\n    }\n  }\n  return( lp );\n}\n\nMYBOOL __WINAPI write_XLI(lprec *lp, char *filename, char *options, MYBOOL results)\n{\n  return( has_XLI(lp) && mat_validate(lp->matA) && lp->xli_writemodel(lp, filename, options, results) );\n}\n\nMYBOOL __WINAPI has_XLI(lprec *lp)\n{\n  return( is_nativeXLI(lp)\n#if LoadLanguageLib == TRUE\n       || (MYBOOL) (lp->hXLI != NULL)\n#endif\n        );\n}\n\nMYBOOL __WINAPI is_nativeXLI(lprec *lp)\n{\n#ifdef ExcludeNativeLanguage\n  return( FALSE );\n#elif LoadLanguageLib == TRUE\n  return( (MYBOOL) (lp->hXLI == NULL) );\n#else\n  return( TRUE );\n#endif\n}\n\nMYBOOL __WINAPI set_XLI(lprec *lp, char *filename)\n/* (Re)mapping of external language interface variant methods is done here */\n{\n  int result = LIB_LOADED;\n\n#if LoadLanguageLib == TRUE\n  if(lp->hXLI != NULL) {\n  #ifdef WIN32\n    FreeLibrary(lp->hXLI);\n  #else\n    dlclose(lp->hXLI);\n  #endif\n    lp->hXLI = NULL;\n  }\n#endif\n\n  if(filename == NULL) {\n    if(!is_nativeXLI(lp))\n      return( FALSE );\n#ifndef ExcludeNativeLanguage\n    lp->xli_name = xli_name;\n    lp->xli_compatible = xli_compatible;\n    lp->xli_readmodel = xli_readmodel;\n    lp->xli_writemodel = xli_writemodel;\n#endif\n  }\n  else {\n#if LoadLanguageLib == TRUE\n  #ifdef WIN32\n   /* Get a handle to the Windows DLL module. */\n    lp->hXLI = LoadLibrary(filename);\n\n   /* If the handle is valid, try to get the function addresses. */\n    if(lp->hXLI != NULL) {\n      lp->xli_compatible           = (XLIbool_lpintintint *)\n                                      GetProcAddress(lp->hXLI, \"xli_compatible\");\n      if(lp->xli_compatible == NULL)\n        result = LIB_NOINFO;\n      else if(lp->xli_compatible(lp, XLIVERSION, MAJORVERSION, sizeof(REAL))) {\n\n        lp->xli_name                 = (XLIchar *)\n                                        GetProcAddress(lp->hXLI, \"xli_name\");\n        lp->xli_readmodel            = (XLIbool_lpcharcharcharint *)\n                                        GetProcAddress(lp->hXLI, \"xli_readmodel\");\n        lp->xli_writemodel           = (XLIbool_lpcharcharbool *)\n                                        GetProcAddress(lp->hXLI, \"xli_writemodel\");\n      }\n      else\n        result = LIB_VERINVALID;\n    }\n  #else\n   /* First standardize UNIX .SO library name format. */\n    char xliname[260], *ptr;\n\n    strcpy(xliname, filename);\n    if((ptr = strrchr(filename, '/')) == NULL)\n      ptr = filename;\n    else\n      ptr++;\n    xliname[(int) (ptr - filename)] = 0;\n    if(strncmp(ptr, \"lib\", 3))\n      strcat(xliname, \"lib\");\n    strcat(xliname, ptr);\n    if(strcmp(xliname + strlen(xliname) - 3, \".so\"))\n      strcat(xliname, \".so\");\n\n   /* Get a handle to the module. */\n    lp->hXLI = dlopen(xliname, RTLD_LAZY);\n\n   /* If the handle is valid, try to get the function addresses. */\n    if(lp->hXLI != NULL) {\n      lp->xli_compatible           = (XLIbool_lpintintint *)\n                                      dlsym(lp->hXLI, \"xli_compatible\");\n      if(lp->xli_compatible == NULL)\n        result = LIB_NOINFO;\n      else if(lp->xli_compatible(lp, XLIVERSION, MAJORVERSION, sizeof(REAL))) {\n\n        lp->xli_name                 = (XLIchar *)\n                                        dlsym(lp->hXLI, \"xli_name\");\n        lp->xli_readmodel            = (XLIbool_lpcharcharcharint *)\n                                        dlsym(lp->hXLI, \"xli_readmodel\");\n        lp->xli_writemodel           = (XLIbool_lpcharcharbool *)\n                                        dlsym(lp->hXLI, \"xli_writemodel\");\n      }\n      else\n        result = LIB_VERINVALID;\n    }\n  #endif\n    else\n      result = LIB_NOTFOUND;\n#endif\n    /* Do validation */\n    if((result != LIB_LOADED) ||\n       ((lp->xli_name == NULL) ||\n        (lp->xli_compatible == NULL) ||\n        (lp->xli_readmodel == NULL) ||\n        (lp->xli_writemodel == NULL)\n       )) {\n      set_XLI(lp, NULL);\n      if(result == LIB_LOADED)\n        result = LIB_NOFUNCTION;\n    }\n  }\n  if(filename != NULL) {\n    char info[LIB_STR_MAXLEN+1];\n    switch(result) {\n      case LIB_NOTFOUND:   strcpy(info, LIB_STR_NOTFOUND);\n                           break;\n      case LIB_NOINFO:     strcpy(info, LIB_STR_NOINFO);\n                           break;\n      case LIB_NOFUNCTION: strcpy(info, LIB_STR_NOFUNCTION);\n                           break;\n      case LIB_VERINVALID: strcpy(info, LIB_STR_VERINVALID);\n                           break;\n      default:             strcpy(info, LIB_STR_LOADED);\n    }\n    report(lp, IMPORTANT, \"set_XLI: %s '%s'\\n\",\n                          info, filename);\n  }\n  return( (MYBOOL) (result == LIB_LOADED));\n}\n\n\nSTATIC int get_basisOF(lprec *lp, int coltarget[], REAL crow[], int colno[])\n/* Fill vector of basic OF values or subtract incoming values from these.\n   This function is called twice during reduced cost updates when the basis\n   does not contain the basic OF vector as the top row.  The colno[] array\n   is filled with the count of non-zero values and the index to those. */\n{\n  int            i, n = lp->rows, nz = 0;\n  REAL           *obj = lp->obj;\n  register REAL epsvalue = lp->epsvalue;\n\n  /* Compute offset over the specified objective indeces (step 2) */\n  if(coltarget != NULL) {\n    register int  ix, m = coltarget[0];\n    register REAL value;\n\n    for(i = 1, coltarget++; i <= m; i++, coltarget++) {\n      ix = *coltarget;\n      value = -crow[ix];\n      if(ix > n)\n        value += obj[ix - n];\n      crow[ix] = value;\n/*      if(value != 0) { */\n      if(fabs(value) > epsvalue) {\n        nz++;\n        if(colno != NULL)\n          colno[nz] = ix;\n      }\n    }\n  }\n\n  /* Get the basic objective function values (step 1) */\n  else {\n    register int *basvar = lp->var_basic;\n\n    for(i = 1, crow++, basvar++; i <= n;\n         i++, crow++, basvar++) {\n      if(*basvar <= n)\n        *crow = 0;\n      else\n        *crow = obj[(*basvar) - n];\n      if((*crow) != 0) {\n/*      if(fabs(*crow) > epsvalue) { */\n        nz++;\n        if(colno != NULL)\n          colno[nz] = i;\n      }\n    }\n  }\n  if(colno != NULL)\n    colno[0] = nz;\n  return( nz );\n}\n\nint __WINAPI get_basiscolumn(lprec *lp, int j, int rn[], double bj[])\n/* This routine returns sparse vectors for all basis\n   columns, including the OF dummy (index 0) and slack columns.\n   NOTE that the index usage is nonstandard for lp_solve, since\n   the array offset is 1, not 0. */\n{\n  int k = lp->bfp_rowoffset(lp),\n      matbase = lp->bfp_indexbase(lp);\n\n  /* Do target index adjustment (etaPFI with matbase==0 is special case) */\n  if(matbase > 0)\n    matbase += k - 1;\n\n /* Convert index of slack and user columns */\n  j -= k;\n  if((j > 0) && !lp->bfp_isSetI(lp))\n    j = lp->var_basic[j];\n\n /* Process OF dummy and slack columns (always at lower bound) */\n  if(j <= lp->rows) {\n    rn[1] = j + matbase;\n    bj[1] = 1.0;\n    k = 1;\n  }\n /* Process user columns (negated if at lower bound) */\n  else {\n    k = obtain_column(lp, j, bj, rn, NULL);\n    if(matbase != 0)\n      for(j = 1; j <= k; j++)\n        rn[j] += matbase;\n  }\n\n  return( k );\n}\n\nMYBOOL __WINAPI get_primal_solution(lprec *lp, REAL *pv)\n{\n  if(!lp->basis_valid) {\n    report(lp, CRITICAL, \"get_primal_solution: Not a valid basis\");\n    return(FALSE);\n  }\n\n  MEMCOPY(pv, lp->best_solution, lp->sum + 1);\n  return(TRUE);\n}\n\nMYBOOL __WINAPI get_ptr_primal_solution(lprec *lp, REAL **pv)\n{\n  *pv = lp->best_solution;\n  return(TRUE);\n}\n\nMYBOOL __WINAPI get_dual_solution(lprec *lp, REAL *rc)\n{\n  REAL *duals;\n  MYBOOL ret;\n\n  if(!lp->basis_valid) {\n    report(lp, CRITICAL, \"get_dual_solution: Not a valid basis\");\n    return(FALSE);\n  }\n\n  ret = get_ptr_sensitivity_rhs(lp, &duals, NULL, NULL);\n\n  if(ret)\n    MEMCOPY(rc, duals - 1, lp->sum + 1);\n  return(ret);\n}\n\nMYBOOL __WINAPI get_ptr_dual_solution(lprec *lp, REAL **rc)\n{\n  MYBOOL ret = lp->basis_valid;\n\n  /* Just return availability of dual information if rc is NULL */\n  if(rc == NULL)\n    return( ret && ((MIP_count(lp) == 0) || (lp->bb_totalnodes > 0)) );\n\n  if(!ret) {\n    report(lp, CRITICAL, \"get_ptr_dual_solution: Not a valid basis\");\n    return(ret);\n  }\n\n  /* Otherwise, get the pointer to the dual information (and optionally produce it) */\n  ret = get_ptr_sensitivity_rhs(lp, rc, NULL, NULL);\n  if(ret)\n    (*rc)--;\n\n  return(ret);\n}\n\nMYBOOL __WINAPI get_lambda(lprec *lp, REAL *lambda)\n{\n  if(!lp->basis_valid || (get_Lrows(lp) == 0)) {\n    report(lp, CRITICAL, \"get_lambda: Not a valid basis\");\n    return(FALSE);\n  }\n\n  MEMCOPY(lambda, lp->lambda+1, get_Lrows(lp));\n  return(TRUE);\n}\n\nMYBOOL __WINAPI get_ptr_lambda(lprec *lp, REAL **lambda)\n{\n  *lambda = lp->lambda;\n  return(TRUE);\n}\n\nint __WINAPI get_orig_index(lprec *lp, int lp_index)\n{\n  if(lp->varmap_locked)\n    return(lp->presolve_undo->var_to_orig[lp_index]);\n  else if(lp_index <= lp->presolve_undo->orig_rows)\n    return(lp_index);\n  else\n    return(lp_index-lp->presolve_undo->orig_rows);\n}\nint __WINAPI get_lp_index(lprec *lp, int orig_index)\n{\n  if(lp->varmap_locked)\n    return(lp->presolve_undo->orig_to_var[orig_index]);\n  else if(orig_index <= lp->presolve_undo->orig_rows)\n    return(orig_index);\n  else\n    return(orig_index-lp->presolve_undo->orig_rows);\n}\n\nMYBOOL __WINAPI is_feasible(lprec *lp, REAL *values, REAL threshold)\n/* Recommend to use threshold = lp->epspivot */\n{\n  int     i, j, elmnr, ie;\n  REAL    *this_rhs, dist;\n  REAL    *value;\n  int     *rownr;\n  MATrec  *mat = lp->matA;\n\n  for(i = lp->rows + 1; i <= lp->sum; i++) {\n    if(values[i - lp->rows] < unscaled_value(lp, lp->orig_lowbo[i], i)\n       || values[i - lp->rows] > unscaled_value(lp, lp->orig_upbo[i], i)) {\n      if(!((lp->sc_lobound[i - lp->rows]>0) && (values[i - lp->rows]==0)))\n        return(FALSE);\n    }\n  }\n\n  this_rhs = (REAL *) mempool_obtainVector(lp->workarrays, lp->rows+1, sizeof(*this_rhs));\n/*  allocREAL(lp, &this_rhs, lp->rows + 1, TRUE); */\n  for(j = 1; j <= lp->columns; j++) {\n    elmnr = mat->col_end[j - 1];\n    ie = mat->col_end[j];\n    rownr = &COL_MAT_ROWNR(elmnr);\n    value = &COL_MAT_VALUE(elmnr);\n    for(; elmnr < ie; elmnr++, rownr += matRowColStep, value += matValueStep) {\n      this_rhs[*rownr] += unscaled_mat(lp, *value, *rownr, j);\n    }\n  }\n  for(i = 1; i <= lp->rows; i++) {\n    dist = lp->orig_rhs[i] - this_rhs[i];\n    my_roundzero(dist, threshold);\n    if((lp->orig_upbo[i] == 0 && dist != 0) ||( dist < 0)) {\n      FREE(this_rhs);\n      return(FALSE);\n    }\n  }\n  mempool_releaseVector(lp->workarrays, (char *) this_rhs, FALSE);\n/*  FREE(this_rhs); */\n  return(TRUE);\n}\n\nint __WINAPI column_in_lp(lprec *lp, REAL *testcolumn)\n{\n  int    i, j, je, colnr = 0;\n  int    nz, ident = 1;\n  MATrec *mat = lp->matA;\n  int    *matRownr;\n  REAL   value, *matValue;\n\n  for(nz = 0, i = 1; i <= lp->rows; i++)\n    if(fabs(testcolumn[i]) > lp->epsvalue) nz++;\n\n  for(i = 1; (i <= lp->columns) && (ident); i++) {\n    ident = nz;\n    value = fabs(get_mat(lp, 0, i)-testcolumn[0]);\n    if(value > lp->epsvalue)\n      continue;\n    j = mat->col_end[i - 1];\n    je = mat->col_end[i];\n    matRownr = &COL_MAT_ROWNR(j);\n    matValue = &COL_MAT_VALUE(j);\n    for(; (j < je) && (ident >= 0);\n        j++, ident--, matRownr += matRowColStep, matValue += matValueStep) {\n      value = *matValue;\n      if(is_chsign(lp, *matRownr))\n        value = my_flipsign(value);\n      value = unscaled_mat(lp, value, *matRownr, i);\n      value -= testcolumn[*matRownr];\n      if(fabs(value) > lp->epsvalue)\n        break;\n    }\n    if(ident == 0)\n      colnr = i;\n  }\n  return( colnr );\n}\n\nMYBOOL __WINAPI set_lp_name(lprec *lp, char *name)\n{\n  if (name == NULL) {\n    FREE(lp->lp_name);\n    lp->lp_name = NULL;\n  }\n  else {\n    allocCHAR(lp, &lp->lp_name, (int) (strlen(name) + 1), AUTOMATIC);\n    strcpy(lp->lp_name, name);\n  }\n  return(TRUE);\n}\n\nchar * __WINAPI get_lp_name(lprec *lp)\n{\n  return((lp->lp_name != NULL) ? lp->lp_name : (char *) \"\");\n}\n\nSTATIC MYBOOL init_rowcol_names(lprec *lp)\n{\n  if(!lp->names_used) {\n    lp->row_name = (hashelem **) calloc(lp->rows_alloc + 1, sizeof(*lp->row_name));\n    lp->col_name = (hashelem **) calloc(lp->columns_alloc + 1, sizeof(*lp->col_name));\n    lp->rowname_hashtab = create_hash_table(lp->rows_alloc + 1, 0);\n    lp->colname_hashtab = create_hash_table(lp->columns_alloc + 1, 1);\n    lp->names_used = TRUE;\n  }\n  return(TRUE);\n}\n\nMYBOOL rename_var(lprec *lp, int varindex, char *new_name, hashelem **list, hashtable **ht)\n{\n  hashelem *hp;\n  MYBOOL   newitem;\n\n  hp = list[varindex];\n  newitem = (MYBOOL) (hp == NULL);\n  if(newitem)\n    hp = puthash(new_name, varindex, list, *ht);\n  else if((strlen(hp->name) != strlen(new_name)) ||\n          (strcmp(hp->name, new_name) != 0)) {\n    hashtable *newht, *oldht;\n\n    allocCHAR(lp, &hp->name, (int) (strlen(new_name) + 1), AUTOMATIC);\n    strcpy(hp->name, new_name);\n    oldht = *ht;\n    newht = copy_hash_table(oldht, list, oldht->size);\n    *ht = newht;\n    free_hash_table(oldht);\n  }\n  return(newitem);\n}\n\nMYBOOL __WINAPI is_use_names(lprec *lp, MYBOOL isrow)\n{\n  if(isrow)\n    return( lp->use_row_names );\n  else\n    return( lp->use_col_names );\n}\n\nvoid __WINAPI set_use_names(lprec *lp, MYBOOL isrow, MYBOOL use_names)\n{\n  if(isrow)\n    lp->use_row_names = use_names;\n  else\n    lp->use_col_names = use_names;\n}\n\nint __WINAPI get_nameindex(lprec *lp, char *varname, MYBOOL isrow)\n{\n  if(isrow)\n    return( find_row(lp, varname, FALSE) );\n  else\n    return( find_var(lp, varname, FALSE) );\n}\n\nMYBOOL __WINAPI set_row_name(lprec *lp, int rownr, char *new_name)\n{\n  if((rownr < 0) || (rownr > lp->rows+1)) {\n    report(lp, IMPORTANT, \"set_row_name: Row %d out of range\", rownr);\n    return(FALSE);\n  }\n\n  /* Prepare for a new row */\n  if((rownr > lp->rows) && !append_rows(lp, rownr-lp->rows))\n    return( FALSE );\n  if(!lp->names_used) {\n    if(!init_rowcol_names(lp))\n      return(FALSE);\n  }\n  rename_var(lp, rownr, new_name, lp->row_name, &lp->rowname_hashtab);\n\n  return(TRUE);\n}\n\nchar * __WINAPI get_row_name(lprec *lp, int rownr)\n{\n  if((rownr < 0) || (rownr > lp->rows+1)) {\n    report(lp, IMPORTANT, \"get_row_name: Row %d out of range\", rownr);\n    return(NULL);\n  }\n\n  if((lp->presolve_undo->var_to_orig != NULL) && lp->wasPresolved) {\n    if(lp->presolve_undo->var_to_orig[rownr] == 0)\n      rownr = -rownr;\n    else\n      rownr = lp->presolve_undo->var_to_orig[rownr];\n  }\n  return( get_origrow_name(lp, rownr) );\n}\n\nchar * __WINAPI get_origrow_name(lprec *lp, int rownr)\n{\n  MYBOOL newrow;\n  static char name[50];\n  char   *ptr;\n\n  newrow = (MYBOOL) (rownr < 0);\n  rownr = abs(rownr);\n#ifdef Paranoia\n  if(((lp->presolve_undo->var_to_orig == NULL) && newrow) ||\n     (rownr > MAX(lp->rows, lp->presolve_undo->orig_rows))) {\n    report(lp, IMPORTANT, \"get_origrow_name: Row %d out of range\", rownr);\n    return(NULL);\n  }\n#endif\n\n  if(lp->names_used && lp->use_row_names && (lp->row_name[rownr] != NULL) &&\n                            (lp->row_name[rownr]->name != NULL)) {\n#ifdef Paranoia\n    if(lp->row_name[rownr]->index != rownr)\n      report(lp, SEVERE, \"get_origrow_name: Inconsistent row ordinal %d vs %d\\n\",\n                         rownr, lp->row_name[rownr]->index);\n#endif\n    ptr = lp->row_name[rownr]->name;\n  }\n  else {\n    if(newrow)\n      sprintf(name, ROWNAMEMASK2, rownr);\n    else\n      sprintf(name, ROWNAMEMASK, rownr);\n    ptr = name;\n  }\n  return(ptr);\n}\n\nMYBOOL __WINAPI set_col_name(lprec *lp, int colnr, char *new_name)\n{\n  if((colnr > lp->columns+1) || (colnr < 1)) {\n    report(lp, IMPORTANT, \"set_col_name: Column %d out of range\", colnr);\n  }\n\n  if((colnr > lp->columns) && !append_columns(lp, colnr-lp->columns))\n    return(FALSE);\n\n  if(!lp->names_used)\n    init_rowcol_names(lp);\n  rename_var(lp, colnr, new_name, lp->col_name, &lp->colname_hashtab);\n\n  return(TRUE);\n}\n\nchar * __WINAPI get_col_name(lprec *lp, int colnr)\n{\n  if((colnr > lp->columns+1) || (colnr < 1)) {\n    report(lp, IMPORTANT, \"get_col_name: Column %d out of range\", colnr);\n    return(NULL);\n  }\n\n  if((lp->presolve_undo->var_to_orig != NULL) && lp->wasPresolved) {\n    if(lp->presolve_undo->var_to_orig[lp->rows + colnr] == 0)\n      colnr = -colnr;\n    else\n      colnr = lp->presolve_undo->var_to_orig[lp->rows + colnr];\n  }\n  return( get_origcol_name(lp, colnr) );\n}\n\nchar * __WINAPI get_origcol_name(lprec *lp, int colnr)\n{\n  MYBOOL newcol;\n  char   *ptr;\n  static char name[50];\n\n  newcol = (MYBOOL) (colnr < 0);\n  colnr = abs(colnr);\n#ifdef Paranoia\n  if(((lp->presolve_undo->var_to_orig == NULL) && newcol) ||\n     (colnr > MAX(lp->columns, lp->presolve_undo->orig_columns))) {\n    report(lp, IMPORTANT, \"get_origcol_name: Column %d out of range\", colnr);\n    return(NULL);\n  }\n#endif\n\n  if(lp->names_used && lp->use_col_names && (lp->col_name[colnr] != NULL) && (lp->col_name[colnr]->name != NULL)) {\n#ifdef Paranoia\n    if(lp->col_name[colnr]->index != colnr)\n      report(lp, SEVERE, \"get_origcol_name: Inconsistent column ordinal %d vs %d\\n\",\n                         colnr, lp->col_name[colnr]->index);\n#endif\n    ptr = lp->col_name[colnr]->name;\n  }\n  else {\n    if(newcol)\n      sprintf((char *) name, COLNAMEMASK2, colnr);\n    else\n      sprintf((char *) name, COLNAMEMASK, colnr);\n    ptr = name;\n  }\n  return(ptr);\n}\n\nSTATIC int MIP_count(lprec *lp)\n{\n  return( lp->int_vars+lp->sc_vars+SOS_count(lp) );\n}\nSTATIC int bin_count(lprec *lp, MYBOOL working)\n{\n  int i, n = 0;\n  if(working) {\n    for(i = lp->rows+1; i <= lp->sum; i++)\n      if(fabs(unscaled_value(lp, lp->upbo[i], i) - 1) < lp->epsvalue)\n        n++;\n  }\n  else {\n    for(i = 1; i <= lp->columns; i++)\n      if((fabs(get_upbo(lp, i) - 1) < lp->epsvalue) &&\n         (fabs(get_lowbo(lp, i) - 0) < lp->epsvalue))\n        n++;\n  }\n  return( n );\n}\nSTATIC int SOS_count(lprec *lp)\n{\n  if(lp->SOS == NULL)\n    return( 0 );\n  else\n    return( lp->SOS->sos_count );\n}\nSTATIC int GUB_count(lprec *lp)\n{\n  if(lp->GUB == NULL)\n    return( 0 );\n  else\n    return( lp->GUB->sos_count );\n}\n\nSTATIC REAL compute_violation(lprec *lp, int row_nr)\n/* Returns the bound violation of a given basic variable; the return\n   value is negative if it is below is lower bound, it is positive\n   if it is greater than the upper bound, and zero otherwise. */\n{\n  REAL value, test;\n\n  value  = lp->rhs[row_nr];\n  row_nr = lp->var_basic[row_nr];\n  test = value - my_lowbound(lp->lowbo[row_nr]);\n  my_roundzero(test, lp->epsprimal);\n  if(test > 0) {\n    test = value - lp->upbo[row_nr];\n    my_roundzero(test, lp->epsprimal);\n    if(test < 0)\n      test = 0;\n  }\n  return( test );\n}\n\nSTATIC REAL feasibilityOffset(lprec *lp, MYBOOL isdual)\n{\n  int    i, j;\n  REAL   f, Extra;\n\n  Extra = 0;\n  if(isdual) {\n   /* This section computes a OF offset to ensure that the dual phase 1 is\n      feasible.  It is used to compute a primal feasible base that can be\n      passed to the primal simplex in phase 2. */\n#if 0\n\n   /* This is the legacy (v3.2-) P1extraVal logic that sets Extra to be the\n      smallest negative reduced cost. Note that the reduced costs are the\n      values of the dual slacks, which are [0..Inf> for feasibility.\n      If we have negative reduced costs for bounded non-basic variables, we\n      can simply switch the bound to obtain feasibility and possibly avoid\n      having to set Extra. */\n    if(!isDualFeasible(lp, lp->epsprimal, NULL, NULL, &f)\n      Extra = f;\n\n#else\n  /* Find the most negative of the objective coefficients. We will subtract this\n     value from every element of the objective row, making it non-negative and\n     the problem therefore dual feasible. */\n    for(i = 1; i <= lp->columns; i++) {\n      f = lp->orig_obj[i];\n      if(f < Extra)\n        Extra = f;\n    }\n#endif\n  }\n\n  else {\n  /* Set Extra to be the index of the most negative of the net RHS coefficients;\n     this approach can be used in the primal phase 1 followed by the dual phase 2\n     and when there are no ranged constraints.  When there are ranged constraints,\n     additional artificial variables must be introduced. */\n    Extra = 0;\n    j = 0;\n    Extra = lp->infinite;\n    for(i = 1; i <= lp->rows; i++) {\n      f = lp->rhs[i];\n      if(f < Extra) {\n        Extra = f;\n        j = i;\n      }\n    }\n    Extra = j;\n  }\n\n  return(Extra);\n\n}\n\nSTATIC REAL compute_dualslacks(lprec *lp, int target, REAL **dvalues, int **nzdvalues, MYBOOL dosum)\n/* Note that this function is similar to the compute_reducedcosts function in lp_price.c */\n{\n  int    i, varnr,\n         *coltarget, **nzduals, *nzvtemp = NULL;\n  REAL   d, g = 0, **duals, *vtemp = NULL;\n  MYBOOL localREAL = (MYBOOL) (dvalues == NULL),\n         localINT  = (MYBOOL) (nzdvalues == NULL);\n\n  if(is_action(lp->spx_action, ACTION_REBASE) ||\n     is_action(lp->spx_action, ACTION_REINVERT) || !lp->basis_valid)\n    return( g );\n\n  /* Initialize */\n  if(!localREAL) {\n    duals = dvalues;\n    nzduals = nzdvalues;\n  }\n  else {\n    duals = &vtemp;\n    nzduals = &nzvtemp;\n  }\n  if(localINT || (*nzduals == NULL))\n    allocINT(lp, nzduals, lp->columns + 1, AUTOMATIC);\n  if(localREAL || (*duals == NULL))\n    allocREAL(lp, duals, lp->sum + 1, AUTOMATIC);\n  if(target == 0)\n    target = SCAN_ALLVARS+ USE_NONBASICVARS;\n\n  /* Define variable target list and compute the reduced costs */\n  coltarget = (int *) mempool_obtainVector(lp->workarrays, lp->columns+1, sizeof(*coltarget));\n  if(!get_colIndexA(lp, target, coltarget, FALSE)) {\n    mempool_releaseVector(lp->workarrays, (char *) coltarget, FALSE);\n    return(FALSE);\n  }\n  bsolve(lp, 0, *duals, NULL, lp->epsmachine*DOUBLEROUND, 1.0);\n  prod_xA(lp, coltarget, *duals, NULL, lp->epsmachine, 1.0,\n                         *duals, *nzduals, MAT_ROUNDDEFAULT | MAT_ROUNDRC);\n  mempool_releaseVector(lp->workarrays, (char *) coltarget, FALSE);\n\n  /* Compute sum or maximum infeasibility as specified */\n  for(i = 1; i <= (*nzduals)[0]; i++) {\n    varnr = (*nzduals)[i];\n    d = my_chsign(!lp->is_lower[varnr], (*duals)[varnr]);\n    if(d < 0) {\n      if(dosum)\n        g += -d;         /* Compute sum as a positive number */\n      else {\n        SETMIN(g, d);    /* Compute gap as a negative number */\n      }\n    }\n  }\n\n  /* Clean up */\n  if(localREAL)\n    FREE(*duals);\n  if(localINT)\n    FREE(*nzduals);\n\n  return( g );\n}\n\nSTATIC REAL compute_feasibilitygap(lprec *lp, MYBOOL isdual, MYBOOL dosum)\n{\n  REAL f = 0;\n\n  /* This computes the primal feasibility gap (for use with the dual simplex phase 1) */\n  if(isdual) {\n    int  i;\n    REAL g;\n\n    for(i = 1; i <= lp->rows; i++) {\n      if(lp->rhs[i] < 0)\n        g = lp->rhs[i];\n      else if(lp->rhs[i] > lp->upbo[lp->var_basic[i]])\n        g = lp->rhs[i] - lp->upbo[lp->var_basic[i]];\n      else\n        g = 0;\n      if(dosum)\n        f += g;\n      else {\n        SETMAX(f, g);\n      }\n    }\n  }\n  /* This computes the dual feasibility gap (for use with the primal simplex phase 1) */\n  else\n    f = compute_dualslacks(lp, SCAN_USERVARS+USE_ALLVARS, NULL, NULL, dosum);\n\n  return( f );\n}\n\n/* Find the smallest fractional value in a given row of the OF/constraint matrix */\nSTATIC int row_decimals(lprec *lp, int rownr, MYBOOL intsonly, REAL *intscalar)\n{\n  int basi, i, j, ncols = lp->columns;\n  REAL f, /* g, */ epsvalue = lp->epsprimal;\n\n  basi = 0;\n  for(j = 1; j <= ncols; j++) {\n    if(intsonly && !is_int(lp, j)) {\n      if(intsonly == TRUE)\n        break;\n      else\n        continue;\n    }\n    f = fabs(get_mat(lp, rownr, j));\n    /* f = fmod(f, 1); */\n    f -= floor (f + epsvalue);\n/*\n    if(f <= epsvalue)\n      continue;\n    g = f;\n*/\n    for(i = 0; (i <= MAX_FRACSCALE) && (/* g */ f > epsvalue); i++) {\n      f *= 10;\n      /* g = fmod(f, 1); */\n      f -= floor (f + epsvalue);\n    }\n    if(i > MAX_FRACSCALE)\n      break;\n    SETMAX(basi, i);\n  }\n  if(j > ncols)\n    *intscalar = pow(10, basi);\n  else {\n    basi = -1;\n    *intscalar = 1;\n  }\n  return( basi );\n}\n\nSTATIC int row_intstats(lprec *lp, int rownr, int pivcolnr,\n                         int *plucount, int *intcount, int *intval, REAL *valGCD, REAL *pivcolval)\n{\n  int    ndec, jb, je, jj, nn = 0, multA, multB, intGCD;\n  REAL   rowval, inthold, intfrac;\n  MATrec *mat = lp->matA;\n\n/* Get rid of a warning by initializing: SEB April 19 2006. */\n    intGCD = 0;\n\n  /* Do we have a valid matrix? */\n  if(mat_validate(mat)) {\n\n    /* Get smallest fractional row value */\n    ndec = row_decimals(lp, rownr, AUTOMATIC, &intfrac);\n    ndec = ndec + 0; /* So the compiler thinks we used ndec! -- Buttrey */\n\n    /* Get OF row starting and ending positions, as well as the first column index */\n    if(rownr == 0) {\n      jb = 1;\n      je = lp->columns+1;\n    }\n    else {\n      jb = mat->row_end[rownr-1];\n      je = mat->row_end[rownr];\n    }\n    nn = je - jb;\n    *pivcolval = 1.0;\n    *plucount = 0;\n    *intcount = 0;\n    *intval   = 0;\n    for(; jb < je; jb++) {\n\n      if(rownr == 0) {\n        if(lp->orig_obj[jb] == 0) {\n          nn--;\n          continue;\n        }\n        jj = jb;\n      }\n      else\n        jj = ROW_MAT_COLNR(jb);\n\n      /* Pick up the value of the pivot column and continue */\n      if(jj == pivcolnr) {\n        if(rownr == 0)\n          *pivcolval = unscaled_mat(lp, lp->orig_obj[jb], 0, jb);\n        else\n          *pivcolval = get_mat_byindex(lp, jb, TRUE, FALSE);\n        continue;\n      }\n      if(!is_int(lp, jj))\n        continue;\n\n      /* Update the count of integer columns */\n      (*intcount)++;\n\n      /* Update the count of positive parameter values */\n      if(rownr == 0)\n        rowval = unscaled_mat(lp, lp->orig_obj[jb], 0, jb);\n      else\n        rowval = get_mat_byindex(lp, jb, TRUE, FALSE);\n      if(rowval > 0)\n        (*plucount)++;\n\n      /* Check if the parameter value is integer and update the row's GDC */\n      rowval = fabs(rowval) * intfrac;\n      rowval += rowval*lp->epsmachine;\n      rowval = modf(rowval, &inthold);\n      if(rowval < lp->epsprimal) {\n        (*intval)++;\n        if(*intval == 1)\n          intGCD = (int) inthold;\n        else\n          intGCD = gcd(intGCD, (LLONG) inthold, &multA, &multB);\n      }\n    }\n    *valGCD = intGCD;\n    *valGCD /= intfrac;\n  }\n\n  return(nn);\n}\n\nREAL MIP_stepOF(lprec *lp)\n/* This function tries to find a non-zero minimum improvement\n   if the OF contains all integer variables (logic only applies if we are\n   looking for a single solution, not possibly several equal-valued ones).\n*/\n{\n  MYBOOL OFgcd;\n  int    OFrow, colnr, n, pluscount, intcount, intval;\n  REAL   value, valOF, divOF, valGCD;\n  MATrec *mat = lp->matA;\n\n  value = 0;\n  if((lp->int_vars > 0) && (lp->solutionlimit == 1) && mat_validate(mat)) {\n\n    /* Get statistics for integer OF variables and compute base stepsize */\n    n = row_intstats(lp, 0, -1, &pluscount, &intcount, &intval, &valGCD, &divOF);\n    if(n == 0)\n      return( value );\n    OFgcd = (MYBOOL) (intval > 0);\n    if(OFgcd)\n      value = valGCD;\n\n    /* Check non-ints in the OF to see if we can get more info */\n    if(n - intcount > 0)\n    for(colnr = 1; colnr <= lp->columns; colnr++) {\n\n      /* Go directly to the next variable if this is an integer or\n        there is no row candidate to explore */\n      if(is_int(lp, colnr) ||\n         (mat_collength(mat, colnr) != 1) ||\n         (!is_constr_type(lp, (OFrow = COL_MAT_ROWNR(mat->col_end[colnr-1])), EQ)))\n        continue;\n\n      /* Get \"child\" row statistics, but break out if we don't\n        find enough information, i.e. integers with integer coefficients */\n      n = row_intstats(lp, OFrow, colnr, &pluscount, &intcount, &intval, &valGCD, &divOF);\n      if(intval < n - 1) {\n        value = 0;\n        break;\n      }\n\n      /* We can update */\n      valOF = unscaled_mat(lp, lp->orig_obj[colnr], 0, colnr);\n      valOF = fabs( valOF * (valGCD / divOF) );\n      if(OFgcd) {\n        SETMIN(value, valOF);\n      }\n      else {\n        OFgcd = TRUE;\n        value = valOF;\n      }\n\n    }\n  }\n  return( value );\n}\n\nSTATIC MYBOOL isPrimalSimplex(lprec *lp)\n{\n  return((MYBOOL) (((lp->simplex_mode & SIMPLEX_Phase1_PRIMAL) != 0) ||\n                   ((lp->simplex_mode & SIMPLEX_Phase2_PRIMAL) != 0)));\n}\n\nSTATIC MYBOOL isPhase1(lprec *lp)\n{\n  return((MYBOOL) (((lp->simplex_mode & SIMPLEX_Phase1_PRIMAL) != 0) ||\n                   ((lp->simplex_mode & SIMPLEX_Phase1_DUAL) != 0)));\n}\n\nSTATIC MYBOOL isP1extra(lprec *lp)\n{\n  return((MYBOOL) ((lp->P1extraDim > 0) || (lp->P1extraVal != 0)));\n}\n\nSTATIC MYBOOL feasiblePhase1(lprec *lp, REAL epsvalue)\n{\n  REAL   gap;\n  MYBOOL test;\n\n  gap = fabs(lp->rhs[0] - lp->orig_rhs[0]);\n  test = (MYBOOL) (gap < epsvalue);\n  return( test) ;\n}\n\nSTATIC MYBOOL isDegenerateBasis(lprec *lp, int basisvar)\n{\n  int varindex;\n\n  varindex = lp->var_basic[basisvar];\n  if((fabs(lp->rhs[basisvar]) < lp->epsprimal) ||\n     (fabs(lp->upbo[varindex]-lp->rhs[basisvar]) < lp->epsprimal))\n    return( TRUE );\n  else\n    return( FALSE );\n}\n\nSTATIC int findBasicFixedvar(lprec *lp, int afternr, MYBOOL slacksonly)\n{\n  int varnr, delta = 1;\n\n  if(afternr < 0) {\n    delta = -1;\n    afternr = -afternr;\n  }\n  afternr += delta;\n  if((afternr < 1) || (afternr > lp->rows))\n    return( 0 );\n\n  for(; (afternr > 0) && (afternr <= lp->rows); afternr += delta) {\n    varnr = lp->var_basic[afternr];\n    if(((varnr <= lp->rows) && is_constr_type(lp, varnr, EQ)) ||\n       (!slacksonly && (varnr > lp->rows) && is_fixedvar(lp, varnr)))\n      break;\n  }\n\n  if(afternr > lp->rows)\n    afternr = 0;\n\n  return( afternr );\n}\n\nSTATIC MYBOOL isBasisVarFeasible(lprec *lp, REAL tol, int basis_row)\n{\n  int    col;\n  REAL   x;\n  MYBOOL Ok = TRUE;\n  MYBOOL doSC = FALSE;\n\n  col = lp->var_basic[basis_row];\n  x = lp->rhs[basis_row];         /* The current solution of basic variables stored here! */\n  if((x < -tol) || (x > lp->upbo[col]+tol))\n    Ok = FALSE;\n  else if(doSC && (col > lp->rows) && (fabs(lp->sc_lobound[col - lp->rows]) > 0)) {\n    if((x > tol) && (x < fabs(lp->sc_lobound[col - lp->rows])-tol))\n      Ok = FALSE;\n  }\n  return( Ok );\n}\nSTATIC MYBOOL isPrimalFeasible(lprec *lp, REAL tol, int infeasibles[], REAL *feasibilitygap)\n{\n  int    i;\n  MYBOOL feasible = TRUE;\n\n  /* This is a short-hand call to rowdual() to check for primal infeasibility */\n\n#if 0\n  /* Traditional indexing style */\n  for(i = 1; i <= lp->rows; i++) {\n    feasible = isBasisVarFeasible(lp, tol, i);\n#else\n  /* Fast array pointer style */\n  LREAL *rhsptr;\n  int  *idxptr;\n\n  if(infeasibles != NULL)\n    infeasibles[0] = 0;\n  for(i = 1, rhsptr = lp->rhs+1, idxptr = lp->var_basic+1;\n      (i <= lp->rows); i++, rhsptr++, idxptr++) {\n    feasible = TRUE;\n/*    if(((*rhsptr) < lp->lowbo[*idxptr]-tol) || ((*rhsptr) > lp->upbo[*idxptr]+tol)) */\n    if(((*rhsptr) < -tol) || ((*rhsptr) > lp->upbo[*idxptr]+tol))\n      feasible = FALSE;\n#endif\n    if(!feasible) {\n      if(infeasibles == NULL)\n        break;\n      infeasibles[0]++;\n      infeasibles[infeasibles[0]] = i;\n    }\n  }\n\n  /* Compute feasibility gap (could actually do this calculation above) */\n  if(feasibilitygap != NULL) {\n    if(feasible)\n      *feasibilitygap = 0.0;\n    else\n      *feasibilitygap = feasibilityOffset(lp, FALSE);\n  }\n\n  return(feasible);\n}\n\nSTATIC MYBOOL isDualFeasible(lprec *lp, REAL tol, int *boundflipcount, int infeasibles[], REAL *feasibilitygap)\n{\n  int    i, varnr,\n         n = 0,  /* Number of infeasible duals corrected with bound-swaps */\n         m = 0,\n         target = SCAN_ALLVARS+USE_NONBASICVARS;\n  REAL   f = 0;\n  MYBOOL feasible, islower;\n\n\n  /* The reduced costs are the values of the dual slacks, which\n     are [0..Inf> for feasibility.  If we have negative reduced costs\n     for bounded non-basic variables, we can simply switch the bound\n     of bounded variables to obtain dual feasibility and possibly avoid\n     having to use dual simplex phase 1. */\n  if((infeasibles != NULL) || (boundflipcount != NULL)) {\n    int  *nzdcol = NULL;\n    REAL d, *dcol = NULL;\n\n    f = compute_dualslacks(lp, target, &dcol, &nzdcol, FALSE);\n    if(nzdcol != NULL)\n    for(i = 1; i <= nzdcol[0]; i++) {\n      varnr = nzdcol[i];\n      islower = lp->is_lower[varnr];\n      d = my_chsign(!islower, dcol[varnr]);\n\n      /* Don't bother with uninteresting non-basic variables */\n      if((d > -tol) ||                /* Positive reduced costs with a tolerance */\n         my_unbounded(lp, varnr) ||   /* Free variables cannot change bound */\n         is_fixedvar(lp, varnr))      /* Equality slack or a fixed variable (\"type 3\") */\n        continue;\n\n      /* Check if we have non-flippable bounds, i.e. an unbounded variable\n         (types 2+4), or bounded variables (type 3), and if the counter is NULL. */\n      if( (boundflipcount == NULL) ||\n          ((lp->bb_level <= 1) && (my_rangebo(lp, varnr) > fabs(lp->negrange))) ||\n          (islower && my_infinite(lp, lp->upbo[varnr])) ||\n          (!islower && my_infinite(lp, my_lowbo(lp, varnr))) ) {\n        m++;\n        if(infeasibles != NULL)\n          infeasibles[m] = varnr;\n      }\n      /* Only do bound flips if the user-provided counter is non-NULL */\n      else {\n        lp->is_lower[varnr] = !islower;\n        n++;\n      }\n    }\n    if(infeasibles != NULL)\n      infeasibles[0] = m;\n    FREE(dcol);\n    FREE(nzdcol);\n    if(n > 0) {\n      set_action(&lp->spx_action, ACTION_RECOMPUTE);\n      if(m == 0)\n        f = 0;\n    }\n  }\n  else\n    f = compute_dualslacks(lp, target, NULL, NULL, FALSE);\n/*    f = feasibilityOffset(lp, TRUE); */  /* Safe legacy mode */\n\n  /* Do an extra scan to see if there are bounded variables in the OF not present in any constraint;\n     Most typically, presolve fixes such cases, so this is rarely encountered. */\n\n  varnr = lp->rows + 1;\n  for(i = 1; i <= lp->columns; i++, varnr++) {\n    islower = lp->is_lower[varnr];\n    if((my_chsign(islower, lp->orig_obj[i]) > 0) && (mat_collength(lp->matA, i) == 0) && !SOS_is_member(lp->SOS, 0, i)) {\n      lp->is_lower[varnr] = !islower;\n      if((islower && my_infinite(lp, lp->upbo[varnr])) ||\n         (!islower && my_infinite(lp, my_lowbo(lp, varnr)))) {\n        lp->spx_status = UNBOUNDED;\n        break;\n      }\n      n++;\n    }\n  }\n\n  /* Return status */\n\n  if(boundflipcount != NULL)\n    *boundflipcount = n;\n  if(feasibilitygap != NULL) {\n    my_roundzero(f, tol);\n    *feasibilitygap = f;\n  }\n  feasible = (MYBOOL) ((f == 0) && (m == 0));\n\n  return(feasible);\n}\n\nvoid __WINAPI default_basis(lprec *lp)\n{\n  int i;\n\n  /* Set the slack variables to be basic; note that the is_basic[] array\n     is a helper array filled in presolve() to match var_basic[]. */\n  for(i = 1; i <= lp->rows; i++) {\n    lp->var_basic[i] = i;\n    lp->is_basic[i] = TRUE;\n    lp->is_lower[i] = TRUE;\n  }\n  lp->var_basic[0] = TRUE; /* Set to signal that this is the default basis */\n\n  /* Set user variables at their lower bound, including the\n     dummy slack for the objective \"constraint\" */\n  for(; i <= lp->sum; i++) {\n    lp->is_basic[i] = FALSE;\n    lp->is_lower[i] = TRUE;\n  }\n  lp->is_lower[0] = TRUE;\n\n  set_action(&lp->spx_action, ACTION_REBASE | ACTION_REINVERT | ACTION_RECOMPUTE);\n  lp->basis_valid = TRUE;  /* Do not re-initialize basis on entering Solve */\n}\n\nint __WINAPI get_basiscrash(lprec *lp)\n{\n  return(lp->crashmode);\n}\n\nvoid __WINAPI set_basiscrash(lprec *lp, int mode)\n{\n  lp->crashmode = mode;\n}\n\nMYBOOL __WINAPI set_basis(lprec *lp, int *bascolumn, MYBOOL nonbasic)   /* Added by KE */\n{\n  int    i,s,k,n;\n\n  /* Make sure we are consistent */\n  if(lp->wasPresolved && ((lp->rows != lp->presolve_undo->orig_rows) ||\n                          (lp->columns != lp->presolve_undo->orig_columns)))\n    return( FALSE );\n\n /* Initialize (lp->is_basic is set in preprocess); Note that as of v5 and before\n    it is an lp_solve convention that basic variables are at their lower bounds!\n    This routine provides for the a possible future case that basic variables\n    can be upper-bounded. */\n  lp->is_lower[0] = TRUE;\n  for(i = 1; i <= lp->sum; i++) {\n    lp->is_lower[i] = TRUE;\n    lp->is_basic[i] = FALSE;\n  }\n  for(i = 1; i <= lp->rows; i++)\n    lp->var_basic[i] = FALSE;\n\n /* Set basic and optionally non-basic variables;\n    negative index means at lower bound, positive at upper bound */\n  if(nonbasic)\n    n = lp->sum;\n  else\n    n = lp->rows;\n  for(i = 1; i <= n; i++) {\n    s = bascolumn[i];\n    k = abs(s);\n    if(k <= 0 || k > lp->sum)\n      return( FALSE );\n    if(i <= lp->rows) {\n      lp->var_basic[i] = k;\n      lp->is_basic[k] = TRUE;\n    }\n    else     /* Remove this test if basic variables can be upper-bounded */\n    if(s > 0)\n      lp->is_lower[k] = FALSE;\n  }\n  if(!verify_basis(lp))\n    return( FALSE );\n\n /* Invalidate basis */\n  set_action(&lp->spx_action, ACTION_REBASE | ACTION_REINVERT | ACTION_RECOMPUTE);\n  lp->basis_valid = TRUE;   /* Do not re-initialize basis on entering Solve */\n  lp->var_basic[0] = FALSE; /* Set to signal that this is a non-default basis */\n\n  return( TRUE );\n}\n\nvoid __WINAPI reset_basis(lprec *lp)\n{\n  lp->basis_valid = FALSE;   /* Causes reinversion at next opportunity */\n}\n\nMYBOOL __WINAPI get_basis(lprec *lp, int *bascolumn, MYBOOL nonbasic)\n{\n  int    k, i;\n\n  if(!lp->basis_valid ||\n     (lp->rows != lp->presolve_undo->orig_rows) ||\n     (lp->columns != lp->presolve_undo->orig_columns))\n    return( FALSE );\n\n  *bascolumn = 0;\n\n  /* First save basic variable indexes */\n  for(i = 1; i <= lp->rows; i++) {\n    k = lp->var_basic[i];\n    bascolumn[i] = my_chsign(lp->is_lower[k], k);\n  }\n\n  /* Then optionally save non-basic variable indeces */\n  if(nonbasic) {\n    for(k = 1; (k <= lp->sum) && (i <= lp->sum); k++) {\n      if(lp->is_basic[k])\n        continue;\n      bascolumn[i] = my_chsign(lp->is_lower[k], k);\n      i++;\n    }\n  }\n  return( TRUE );\n}\n\nSTATIC MYBOOL is_BasisReady(lprec *lp)\n{\n  return( (MYBOOL) (lp->var_basic[0] != AUTOMATIC) );\n}\n\nSTATIC MYBOOL is_slackbasis(lprec *lp)\n{\n  int n = 0, err = 0;\n  if(lp->basis_valid) {\n    int i, k;\n    MYBOOL *used = NULL;\n\n    allocMYBOOL(lp, &used, lp->rows+1, TRUE);\n    for(i = 1; i <= lp->rows; i++) {\n      k = lp->var_basic[i];\n      if(k <= lp->rows) {\n        if(used[k])\n          err++;\n        else\n          used[k] = TRUE;\n        n++;\n      }\n    }\n    FREE(used);\n    if(err > 0)\n      report(lp, SEVERE, \"is_slackbasis: %d inconsistencies found in slack basis\\n\", err);\n  }\n  return( (MYBOOL) (n == lp->rows) );\n}\n\nSTATIC MYBOOL verify_basis(lprec *lp)\n{\n  int    i, ii; /* , k = 0; */\n  MYBOOL result = FALSE;\nif (buttrey_thing > 0)\n{\nbuttrey_debugfile = fopen (\"h:/temp/egaddeath.txt\", \"w\");\n}\n\n  for(i = 1; i <= lp->rows; i++) {\n    ii = lp->var_basic[i];\n    if (buttrey_thing > 0) {\n        fprintf (buttrey_debugfile, \"i %i, rows %i, ii %i, sum %i, basic[%i] %i\\n\",\n            i, lp->rows, ii, lp->sum, ii, lp->is_basic[ii]);\n        fflush (buttrey_debugfile);\n    }\n    if((ii < 1) || (ii > lp->sum) || !lp->is_basic[ii]) {\n        if (buttrey_thing > 0) {\n            fprintf (buttrey_debugfile, \"lp lib: We're inside.\\n\");\n        fflush (buttrey_debugfile);\n        }\n      /* k = i; */\n      ii = 0;\n      goto Done;\n    }\n  }\n    if (buttrey_thing > 0) {\n        fprintf (buttrey_debugfile, \"lp lib: We're down here now.\\n\");\n        fflush (buttrey_debugfile);\n    }\n\n  ii = lp->rows;\n  for(i = 1; i <= lp->sum; i++) {\n    if(lp->is_basic[i])\n      ii--;\n  }\n    if (buttrey_thing > 0) {\n        fprintf (buttrey_debugfile, \"lp lib: About to return.\\n\");\n        fflush (buttrey_debugfile);\n    }\n  result = (MYBOOL) (ii == 0);\n\nDone:\n#if 0  /* For testing */\n  if(!result)\n    ii = 0;\n#endif\n  return(result);\n}\n\nint __WINAPI set_basisvar(lprec *lp, int basisPos, int enteringCol)\n{\n  int leavingCol;\n\n  leavingCol = lp->var_basic[basisPos];\n\n#ifdef Paranoia\n  if((basisPos < 1) || (basisPos > lp->rows))\n    report(lp, SEVERE, \"set_basisvar: Invalid leaving basis position %d specified at iter %.0f\\n\",\n                       basisPos, (double) get_total_iter(lp));\n  if((leavingCol < 1) || (leavingCol > lp->sum))\n    report(lp, SEVERE, \"set_basisvar: Invalid leaving column %d referenced at iter %.0f\\n\",\n                       leavingCol, (double) get_total_iter(lp));\n  if((enteringCol < 1) || (enteringCol > lp->sum))\n    report(lp, SEVERE, \"set_basisvar: Invalid entering column %d specified at iter %.0f\\n\",\n                       enteringCol, (double) get_total_iter(lp));\n#endif\n\n#ifdef ParanoiaXY\n  if(!lp->is_basic[leavingCol])\n    report(lp, IMPORTANT, \"set_basisvar: Leaving variable %d is not basic at iter %.0f\\n\",\n                           leavingCol, (double) get_total_iter(lp));\n  if(enteringCol > lp->rows && lp->is_basic[enteringCol])\n    report(lp, IMPORTANT, \"set_basisvar: Entering variable %d is already basic at iter %.0f\\n\",\n                           enteringCol, (double) get_total_iter(lp));\n#endif\n\n  lp->var_basic[0]          = FALSE;       /* Set to signal that this is a non-default basis */\n  lp->var_basic[basisPos]   = enteringCol;\n  lp->is_basic[leavingCol]  = FALSE;\n  lp->is_basic[enteringCol] = TRUE;\n  if(lp->bb_basis != NULL)\n    lp->bb_basis->pivots++;\n\n  return(leavingCol);\n}\n\n/* Bounds updating and unloading routines; requires that the\n   current values for upbo and lowbo are in the original base. */\nSTATIC int perturb_bounds(lprec *lp, BBrec *perturbed, MYBOOL doRows, MYBOOL doCols, MYBOOL includeFIXED)\n{\n  int  i, ii, n = 0;\n  REAL new_lb, new_ub, *upbo, *lowbo;\n\n  if(perturbed == NULL)\n    return( n );\n\n /* Map reference bounds to previous state, i.e. cumulate\n    perturbations in case of persistent problems */\n  upbo  = perturbed->upbo;\n  lowbo = perturbed->lowbo;\n\n /* Set appropriate target variable range */\n  i = 1;\n  ii = lp->rows;\n  if(!doRows)\n    i += ii;\n  if(!doCols)\n    ii = lp->sum;\n\n /* Perturb (expand) finite variable bounds randomly */\n  for(; i <= ii; i++) {\n\n    /* Don't perturb regular slack variables */\n    if((i <= lp->rows) && (lowbo[i] == 0) && (upbo[i] >= lp->infinite))\n      continue;\n\n    new_lb = lowbo[i];\n    new_ub = upbo[i];\n\n    /* Don't perturb fixed variables if not specified */\n    if(!includeFIXED && (new_ub == new_lb))\n      continue;\n\n    /* Lower bound for variables (consider implementing RHS here w/contentmode== AUTOMATIC) */\n    if((i > lp->rows) && (new_lb < lp->infinite)) {\n      new_lb = rand_uniform(lp, RANDSCALE) + 1;\n      new_lb *= lp->epsperturb;\n      lowbo[i] -= new_lb;\n      n++;\n    }\n\n    /* Upper bound */\n    if(new_ub < lp->infinite) {\n      new_ub = rand_uniform(lp, RANDSCALE) + 1;\n      new_ub *= lp->epsperturb;\n      upbo[i] += new_ub;\n      n++;\n    }\n  }\n\n /* Make sure we start from scratch */\n  set_action(&lp->spx_action, ACTION_REBASE);\n\n  return( n );\n}\n\nSTATIC MYBOOL impose_bounds(lprec *lp, REAL *upbo, REAL *lowbo)\n/* Explicitly set working bounds to given vectors without pushing or popping */\n{\n  MYBOOL ok;\n\n  ok = (MYBOOL) ((upbo != NULL) || (lowbo != NULL));\n  if(ok) {\n    if((upbo != NULL) && (upbo != lp->upbo))\n      MEMCOPY(lp->upbo,  upbo,  lp->sum + 1);\n    if((lowbo != NULL) && (lowbo != lp->lowbo))\n      MEMCOPY(lp->lowbo, lowbo, lp->sum + 1);\n    if(lp->bb_bounds != NULL)\n      lp->bb_bounds->UBzerobased = FALSE;\n    set_action(&lp->spx_action, ACTION_REBASE);\n  }\n  set_action(&lp->spx_action, ACTION_RECOMPUTE);\n  return( ok );\n}\n\nSTATIC MYBOOL validate_bounds(lprec *lp, REAL *upbo, REAL *lowbo)\n/* Check if all bounds are Explicitly set working bounds to given vectors without pushing or popping */\n{\n  MYBOOL ok;\n  int    i;\n\n  ok = (MYBOOL) ((upbo != NULL) || (lowbo != NULL));\n  if(ok) {\n    for(i = 1; i <= lp->sum; i++)\n      if((lowbo[i] > upbo[i]) || (lowbo[i] < lp->orig_lowbo[i]) || (upbo[i] > lp->orig_upbo[i]))\n        break;\n    ok = (MYBOOL) (i > lp->sum);\n  }\n  return( ok );\n}\n\nSTATIC int unload_BB(lprec *lp)\n{\n  int levelsunloaded = 0;\n\n  if(lp->bb_bounds != NULL)\n    while(pop_BB(lp->bb_bounds))\n      levelsunloaded++;\n  return( levelsunloaded );\n}\n\n\n#define LowerStorageModel 1\n#define BasisStorageModel 1\nSTATIC basisrec *push_basis(lprec *lp, int *basisvar, MYBOOL *isbasic, MYBOOL *islower)\n/* Save the ingoing basis and push it onto the stack */\n{\n  int sum = lp->sum + 1;\n  basisrec *newbasis = NULL;\n\n  newbasis = (basisrec *) calloc(sizeof(*newbasis), 1);\n  if((newbasis != NULL) &&\n#if LowerStorageModel == 0\n    allocMYBOOL(lp, &newbasis->is_lower,  sum,  FALSE) &&\n#else\n    allocMYBOOL(lp, &newbasis->is_lower,  (sum + 8) / 8,  TRUE) &&\n#endif\n#if BasisStorageModel == 0\n    allocMYBOOL(lp, &newbasis->is_basic,  sum,  FALSE) &&\n#endif\n    allocINT(lp,    &newbasis->var_basic, lp->rows + 1, FALSE)) {\n\n    if(islower == NULL)\n      islower = lp->is_lower;\n    if(isbasic == NULL)\n      isbasic = lp->is_basic;\n    if(basisvar == NULL)\n      basisvar = lp->var_basic;\n\n#if LowerStorageModel == 0\n    MEMCOPY(newbasis->is_lower,  islower,  sum);\n#else\n    for(sum = 1; sum <= lp->sum; sum++)\n      if(islower[sum])\n        set_biton(newbasis->is_lower, sum);\n#endif\n#if BasisStorageModel == 0\n    MEMCOPY(newbasis->is_basic,  isbasic,  lp->sum + 1);\n#endif\n    MEMCOPY(newbasis->var_basic, basisvar, lp->rows + 1);\n\n    newbasis->previous = lp->bb_basis;\n    if(lp->bb_basis == NULL)\n      newbasis->level = 0;\n    else\n      newbasis->level = lp->bb_basis->level + 1;\n    newbasis->pivots = 0;\n\n    lp->bb_basis = newbasis;\n  }\n  return( newbasis );\n}\n\nSTATIC MYBOOL compare_basis(lprec *lp)\n/* Compares the last pushed basis with the currently active basis */\n{\n  int i, j;\n  MYBOOL same_basis = TRUE;\n\n  if(lp->bb_basis == NULL)\n    return( FALSE );\n\n  /* Loop over basis variables until a mismatch (order can be different) */\n  i = 1;\n  while(same_basis && (i <= lp->rows)) {\n    j = 1;\n    while(same_basis && (j <= lp->rows)) {\n      same_basis = (MYBOOL) (lp->bb_basis->var_basic[i] != lp->var_basic[j]);\n      j++;\n    }\n    same_basis = !same_basis;\n    i++;\n  }\n  /* Loop over bound status indicators until a mismatch */\n  i = 1;\n  while(same_basis && (i <= lp->sum)) {\n    same_basis = (lp->bb_basis->is_lower[i] && lp->is_lower[i]);\n    i++;\n  }\n\n  return( same_basis );\n}\n\nSTATIC MYBOOL restore_basis(lprec *lp)\n/* Restore values from the previously pushed / saved basis without popping it */\n{\n  MYBOOL ok;\n  int    i;\n\n  ok = (MYBOOL) (lp->bb_basis != NULL);\n  if(ok) {\n    MEMCOPY(lp->var_basic, lp->bb_basis->var_basic, lp->rows + 1);\n#if BasisStorageModel == 0\n    MEMCOPY(lp->is_basic,  lp->bb_basis->is_basic,  lp->sum + 1);\n#else\n    MEMCLEAR(lp->is_basic, lp->sum + 1);\n    for(i = 1; i <= lp->rows; i++)\n      lp->is_basic[lp->var_basic[i]] = TRUE;\n#endif\n#if LowerStorageModel == 0\n    MEMCOPY(lp->is_lower,  lp->bb_basis->is_lower,  lp->sum + 1);\n#else\n    for(i = 1; i <= lp->sum; i++)\n      lp->is_lower[i] = is_biton(lp->bb_basis->is_lower, i);\n#endif\n    set_action(&lp->spx_action, ACTION_REBASE | ACTION_REINVERT);\n  }\n  return( ok );\n}\n\nSTATIC MYBOOL pop_basis(lprec *lp, MYBOOL restore)\n/* Pop / free, and optionally restore the previously \"pushed\" / saved basis */\n{\n  MYBOOL ok;\n  basisrec *oldbasis;\n\n  ok = (MYBOOL) (lp->bb_basis != NULL);\n  if(ok) {\n    oldbasis = lp->bb_basis;\n    if(oldbasis != NULL) {\n      lp->bb_basis = oldbasis->previous;\n      FREE(oldbasis->var_basic);\n#if BasisStorageModel == 0\n      FREE(oldbasis->is_basic);\n#endif\n      FREE(oldbasis->is_lower);\n      FREE(oldbasis);\n    }\n    if(restore && (lp->bb_basis != NULL))\n      restore_basis(lp);\n  }\n  return( ok );\n}\n\nSTATIC int unload_basis(lprec *lp, MYBOOL restorelast)\n{\n  int levelsunloaded = 0;\n\n  if(lp->bb_basis != NULL)\n    while(pop_basis(lp, restorelast))\n      levelsunloaded++;\n  return( levelsunloaded );\n}\n\n\nSTATIC REAL scaled_floor(lprec *lp, int colnr, REAL value, REAL epsscale)\n{\n  value = floor(value);\n  if(value != 0)\n  if(lp->columns_scaled && is_integerscaling(lp)) {\n    value = scaled_value(lp, value, colnr);\n    if(epsscale != 0)\n      value += epsscale*lp->epsmachine;\n/*      value += epsscale*lp->epsprimal; */\n/*    value = restoreINT(value, lp->epsint); */\n  }\n  return(value);\n}\n\nSTATIC REAL scaled_ceil(lprec *lp, int colnr, REAL value, REAL epsscale)\n{\n  value = ceil(value);\n  if(value != 0)\n  if(lp->columns_scaled && is_integerscaling(lp)) {\n    value = scaled_value(lp, value, colnr);\n    if(epsscale != 0)\n      value -= epsscale*lp->epsmachine;\n/*      value -= epsscale*lp->epsprimal; */\n/*    value = restoreINT(value, lp->epsint); */\n  }\n  return(value);\n}\n\n/* Branch and bound variable selection functions */\n\nSTATIC MYBOOL is_sc_violated(lprec *lp, int column)\n{\n  int  varno;\n  REAL tmpreal;\n\n  varno = lp->rows+column;\n  tmpreal = unscaled_value(lp, lp->sc_lobound[column], varno);\n  return( (MYBOOL) ((tmpreal > 0) &&                    /* it is an (inactive) SC variable...    */\n                    (lp->solution[varno] < tmpreal) &&  /* ...and the NZ lower bound is violated */\n                    (lp->solution[varno] > 0)) );       /* ...and the Z lowerbound is violated   */\n}\nSTATIC int find_sc_bbvar(lprec *lp, int *count)\n{\n  int    i, ii, n, bestvar;\n  int    firstsc, lastsc;\n  REAL   hold, holdINT, bestval, OFval, randval, scval;\n  MYBOOL reversemode, greedymode, randomizemode,\n         pseudocostmode, pseudocostsel;\n\n  bestvar = 0;\n  if((lp->sc_vars == 0) || (*count > 0))\n    return(bestvar);\n\n  reversemode    = is_bb_mode(lp, NODE_WEIGHTREVERSEMODE);\n  greedymode     = is_bb_mode(lp, NODE_GREEDYMODE);\n  randomizemode  = is_bb_mode(lp, NODE_RANDOMIZEMODE);\n  pseudocostmode = is_bb_mode(lp, NODE_PSEUDOCOSTMODE);\n  pseudocostsel  = is_bb_rule(lp, NODE_PSEUDOCOSTSELECT) ||\n                   is_bb_rule(lp, NODE_PSEUDONONINTSELECT) ||\n                   is_bb_rule(lp, NODE_PSEUDORATIOSELECT);\n\n  bestvar = 0;\n  bestval = -lp->infinite;\n  hold    = 0;\n  randval = 1;\n  firstsc = 0;\n  lastsc  = lp->columns;\n\n  for(n = 1; n <= lp->columns; n++) {\n    ii = get_var_priority(lp, n);\n    i = lp->rows + ii;\n    if(!lp->bb_varactive[ii] && is_sc_violated(lp, ii) && !SOS_is_marked(lp->SOS, 0, ii)) {\n\n      /* Do tallies */\n      (*count)++;\n      lastsc = i;\n      if(firstsc <= 0)\n        firstsc = i;\n      scval = get_pseudorange(lp->bb_PseudoCost, ii, BB_SC);\n\n      /* Select default pricing/weighting mode */\n      if(pseudocostmode)\n        OFval = get_pseudonodecost(lp->bb_PseudoCost, ii, BB_SC, lp->solution[i]);\n      else\n        OFval = my_chsign(is_maxim(lp), get_mat(lp, 0, ii));\n\n      if(randomizemode)\n        randval = exp(rand_uniform(lp, 1.0));\n\n      /* Find the maximum pseudo-cost of a variable (don't apply pseudocostmode here) */\n      if(pseudocostsel) {\n        if(pseudocostmode)\n          hold = OFval;\n        else\n          hold = get_pseudonodecost(lp->bb_PseudoCost, ii, BB_SC, lp->solution[i]);\n        hold *= randval;\n        if(greedymode) {\n          if(pseudocostmode) /* Override! */\n            OFval = my_chsign(is_maxim(lp), get_mat(lp, 0, ii));\n          hold *= OFval;\n        }\n        hold = my_chsign(reversemode, hold);\n      }\n      else\n      /* Find the variable with the largest sc gap (closest to the sc mean) */\n      if(is_bb_rule(lp, NODE_FRACTIONSELECT)) {\n        hold = modf(lp->solution[i]/scval, &holdINT);\n        holdINT = hold-1;\n        if(fabs(holdINT) > hold)\n          hold = holdINT;\n        if(greedymode)\n          hold *= OFval;\n        hold = my_chsign(reversemode, hold)*scval*randval;\n      }\n      else\n      /* Do first or last violated sc index selection (default) */\n      /* if(is_bb_rule(lp, NODE_FIRSTSELECT)) */\n      {\n        if(reversemode)\n          continue;\n        else {\n          bestvar = i;\n          break;\n        }\n      }\n\n      /* Select better, check for ties, and split by proximity to 0.5*sc_lobound */\n      if(hold > bestval) {\n        if( (bestvar == 0) ||\n            (hold > bestval+lp->epsprimal) ||\n            (fabs(modf(lp->solution[i]/scval, &holdINT) - 0.5) <\n             fabs(modf(lp->solution[bestvar]/\n                       get_pseudorange(lp->bb_PseudoCost, bestvar-lp->rows, BB_SC), &holdINT) - 0.5)) ) {\n          bestval = hold;\n          bestvar = i;\n        }\n      }\n    }\n  }\n\n  if(is_bb_rule(lp, NODE_FIRSTSELECT) && reversemode)\n    bestvar = lastsc;\n\n  return(bestvar);\n}\n\nSTATIC int find_sos_bbvar(lprec *lp, int *count, MYBOOL intsos)\n{\n  int k, i, j, var;\n\n  var = 0;\n  if((lp->SOS == NULL) || (*count > 0))\n    return(var);\n\n  /* Check if the SOS'es happen to already be satisified */\n  i = SOS_is_satisfied(lp->SOS, 0, lp->solution);\n  if((i == SOS_COMPLETE) || (i == SOS_INCOMPLETE))\n    return(-1);\n\n  /* Otherwise identify a SOS variable to enter B&B */\n  for(k = 0; k < lp->sos_vars; k++) {\n    i = lp->sos_priority[k];\n#ifdef Paranoia\n    if((i < 1) || (i > lp->columns))\n      report(lp, SEVERE, \"find_sos_bbvar: Invalid SOS variable map %d at %d\\n\",\n                         i, k);\n#endif\n    j = lp->rows + i;\n    if(!SOS_is_marked(lp->SOS, 0, i) && !SOS_is_full(lp->SOS, 0, i, FALSE)) {\n/*    if(!SOS_is_marked(lp->SOS, 0, i) && !SOS_is_full(lp->SOS, 0, i, TRUE)) { */\n      if(!intsos || is_int(lp, i)) {\n        (*count)++;\n        if(var == 0) {\n          var = j;\n          break;\n        }\n      }\n    }\n  }\n#ifdef Paranoia\n  if((var > 0) && !SOS_is_member(lp->SOS, 0, var-lp->rows))\n     report(lp, SEVERE, \"find_sos_bbvar: Found variable %d, which is not a SOS!\\n\", var);\n#endif\n  return(var);\n}\n\nSTATIC int find_int_bbvar(lprec *lp, int *count, BBrec *BB, MYBOOL *isfeasible)\n{\n  int    i, ii, n, k, bestvar, depthmax, *nonint = NULL;\n  REAL   hold, holdINT, bestval, OFval, randval,\n         *lowbo = BB->lowbo, *upbo = BB->upbo;\n  MYBOOL reversemode, greedymode, depthfirstmode, breadthfirstmode,\n         randomizemode, rcostmode,\n         pseudocostmode, pseudocostsel, pseudostrong, isINT, valINT;\n\n  if((lp->int_vars == 0) || (*count > 0))\n    return( 0 );\n  if(lp->bb_usenode != NULL) {\n    i = lp->bb_usenode(lp, lp->bb_nodehandle, BB_INT);\n    if(i >= 0) {\n      if(i > 0)\n        (*count)++;\n      return( i );\n    }\n  }\n\n  reversemode    = is_bb_mode(lp, NODE_WEIGHTREVERSEMODE);\n  greedymode     = is_bb_mode(lp, NODE_GREEDYMODE);\n  randomizemode  = is_bb_mode(lp, NODE_RANDOMIZEMODE);\n  depthfirstmode = is_bb_mode(lp, NODE_DEPTHFIRSTMODE);\n  breadthfirstmode = is_bb_mode(lp, NODE_BREADTHFIRSTMODE) &&\n                     (MYBOOL) (lp->bb_level <= lp->int_vars);\n  rcostmode      = (MYBOOL) (BB->lp->solutioncount > 0) && is_bb_mode(lp, NODE_RCOSTFIXING);\n  pseudocostmode = is_bb_mode(lp, NODE_PSEUDOCOSTMODE);\n  pseudocostsel  = is_bb_rule(lp, NODE_PSEUDOCOSTSELECT) ||\n                   is_bb_rule(lp, NODE_PSEUDONONINTSELECT) ||\n                   is_bb_rule(lp, NODE_PSEUDORATIOSELECT);\n  pseudostrong   = FALSE &&\n                   pseudocostsel && !rcostmode && is_bb_mode(lp, NODE_STRONGINIT);\n\n  /* Fill list of non-ints */\n  allocINT(lp, &nonint, lp->columns + 1, FALSE);\n  n = 0;\n  depthmax = -1;\n  if(isfeasible != NULL)\n    *isfeasible = TRUE;\n  BB->lastrcf = 0;\n  for(k = 1; (k <= lp->columns); k++) {\n    ii = get_var_priority(lp, k);\n    isINT = is_int(lp,ii);\n    i  = lp->rows + ii;\n\n    /* Tally reduced cost fixing opportunities for ranged non-basic nonINTs */\n    if(!isINT) {\n#ifdef UseMilpExpandedRCF\n      if(rcostmode) {\n        bestvar = rcfbound_BB(BB, i, isINT, NULL, isfeasible);\n        if(bestvar != FR)\n          BB->lastrcf++;\n      }\n#endif\n    }\n    else {\n\n      valINT = solution_is_int(lp, i, FALSE);\n\n      /* Skip already fixed variables */\n      if(lowbo[i] == upbo[i]) {\n\n        /* Check for validity */\n#ifdef Paranoia\n        if(!valINT) {\n          report(lp, IMPORTANT,\n                 \"find_int_bbvar: INT var %d was fixed at %d, but computed as %g at node %.0f\\n\",\n                  ii, (int) lowbo[i], lp->solution[i], (double) lp->bb_totalnodes);\n          lp->bb_break = TRUE;\n          lp->spx_status = UNKNOWNERROR;\n          bestvar = 0;\n          goto Done;\n        }\n#endif\n      }\n\n      /* The variable has not yet been fixed */\n      else {\n\n        /* Tally reduced cost fixing opportunities (also when the\n           variables are integer-valued at the current relaxation) */\n        if(rcostmode) {\n          bestvar = rcfbound_BB(BB, i, isINT, NULL, isfeasible);\n          if(bestvar != FR)\n            BB->lastrcf++;\n        }\n        else\n          bestvar = FR;\n\n        /* Only qualify variable as branching node if it is non-integer and\n           it will not be subsequently fixed via reduced cost fixing logic */\n        if(!valINT && (bestvar >= FR)) {\n\n          n++;\n          nonint[n] = ii;\n          SETMAX(depthmax, lp->bb_varactive[ii]);\n        }\n      }\n\n    }\n  }\n\n#ifdef UseMilpSlacksRCF\n  /* Optionally also tally slacks */\n  if(rcostmode) {\n    for(i = 1; (i <= lp->rows) && (BB->lastrcf == 0); i++) {\n      /* Skip already fixed slacks (equalities) */\n      if(lowbo[i] < upbo[i]) {\n        bestvar = rcfbound_BB(BB, i, FALSE, NULL, isfeasible);\n        if(bestvar != FR)\n          BB->lastrcf++;\n      }\n    }\n  }\n#endif\n  nonint[0] = n;\n  *count    = n;\n  bestvar   = 0;\n  if(n == 0)     /* No non-integers found */\n    goto Done;\n\n  bestval  = -lp->infinite;\n  hold     = 0;\n  randval  = 1;\n\n  /* Sort non-ints by depth in case we have breadthfirst or depthfirst modes */\n  if((lp->bb_level > 1) && (depthmax > 0) && (depthfirstmode || breadthfirstmode)) {\n    int *depths = NULL;\n\n    /* Fill attribute array and make sure ordinal order breaks ties during sort */\n    allocINT(lp, &depths, n + 1, FALSE);\n    for(i = 1; i <= n; i++)\n      depths[i] = (depthfirstmode ? n+1-i : i) + (n+1)*lp->bb_varactive[nonint[i]];\n    hpsortex(depths, n, 1, sizeof(*nonint), depthfirstmode, compareINT, nonint);\n    FREE(depths);\n  }\n\n  /* Do simple firstselect handling */\n  if(is_bb_rule(lp, NODE_FIRSTSELECT)) {\n    if(reversemode)\n      bestvar = lp->rows + nonint[nonint[0]];\n    else\n      bestvar = lp->rows + nonint[1];\n  }\n\n  else for(n = 1; n <= nonint[0]; n++) {\n    ii = nonint[n];\n    i = lp->rows + ii;\n\n    /* Do the naive detection */\n    if(n == 1)\n      bestvar = i;\n\n    /* Should we do a \"strong\" pseudo-cost initialization or an incremental update? */\n    if(pseudostrong &&\n       (MAX(lp->bb_PseudoCost->LOcost[ii].rownr,\n            lp->bb_PseudoCost->UPcost[ii].rownr) < lp->bb_PseudoCost->updatelimit) &&\n       (MAX(lp->bb_PseudoCost->LOcost[ii].colnr,\n            lp->bb_PseudoCost->UPcost[ii].colnr) < 5*lp->bb_PseudoCost->updatelimit)) {\n      strongbranch_BB(lp, BB, ii, BB_INT, nonint[0]);\n    }\n\n    /* Select default pricing/weighting mode */\n    if(pseudocostmode)\n      OFval = get_pseudonodecost(lp->bb_PseudoCost, ii, BB_INT, lp->solution[i]);\n    else\n      OFval = my_chsign(is_maxim(lp), get_mat(lp, 0, ii));\n\n    if(randomizemode)\n      randval = exp(rand_uniform(lp, 1.0));\n\n    /* Find the maximum pseudo-cost of a variable (don't apply pseudocostmode here) */\n    if(pseudocostsel) {\n      if(pseudocostmode)\n        hold = OFval;\n      else\n        hold = get_pseudonodecost(lp->bb_PseudoCost, ii, BB_INT, lp->solution[i]);\n      hold *= randval;\n      if(greedymode) {\n        if(pseudocostmode) /* Override! */\n          OFval = my_chsign(is_maxim(lp), get_mat(lp, 0, ii));\n        hold *= OFval;\n      }\n      hold = my_chsign(reversemode, hold);\n    }\n    else\n    /* Find the variable with the largest gap to its bounds (distance from being fixed) */\n    if(is_bb_rule(lp, NODE_GAPSELECT)) {\n      hold = lp->solution[i];\n      holdINT = hold-unscaled_value(lp, upbo[i], i);\n      hold -= unscaled_value(lp, lowbo[i], i);\n      if(fabs(holdINT) > hold)\n        hold = holdINT;\n      if(greedymode)\n        hold *= OFval;\n      hold = my_chsign(reversemode, hold)*randval;\n    }\n    else\n    /* Find the variable with the largest integer gap (closest to 0.5) */\n    if(is_bb_rule(lp, NODE_FRACTIONSELECT)) {\n      hold = modf(lp->solution[i], &holdINT);\n      holdINT = hold-1;\n      if(fabs(holdINT) > hold)\n        hold = holdINT;\n      if(greedymode)\n        hold *= OFval;\n      hold = my_chsign(reversemode, hold)*randval;\n    }\n    else\n    /* Find the \"range\", most flexible variable */\n    if(is_bb_rule(lp, NODE_RANGESELECT)) {\n      hold = unscaled_value(lp, upbo[i]-lowbo[i], i);\n      if(greedymode)\n        hold *= OFval;\n      hold = my_chsign(reversemode, hold)*randval;\n    }\n\n    /* Select better, check for ties, and split by proximity to 0.5 */\n    if(hold > bestval) {\n      if( (hold > bestval+lp->epsprimal) ||\n          (fabs(modf(lp->solution[i], &holdINT) - 0.5) <\n           fabs(modf(lp->solution[bestvar], &holdINT) - 0.5)) ) {\n        bestval = hold;\n        bestvar = i;\n      }\n    }\n  }\n\nDone:\n  FREE(nonint);\n  return(bestvar);\n}\n\nSTATIC BBPSrec *init_pseudocost(lprec *lp, int pseudotype)\n{\n  int     i;\n  REAL    PSinitUP, PSinitLO;\n  BBPSrec *newitem;\n  MYBOOL  isPSCount;\n\n  /* Allocate memory */\n  newitem = (BBPSrec*) malloc(sizeof(*newitem));\n  newitem->lp = lp;\n  newitem->LOcost = (MATitem*) malloc((lp->columns+1) * sizeof(*newitem->LOcost));\n  newitem->UPcost = (MATitem*) malloc((lp->columns+1) * sizeof(*newitem->UPcost));\n  newitem->secondary = NULL;\n\n  /* Initialize with OF values */\n  newitem->pseodotype = (pseudotype & NODE_STRATEGYMASK);\n  isPSCount = ((pseudotype & NODE_PSEUDONONINTSELECT) != 0);\n  for(i = 1; i <= lp->columns; i++) {\n    newitem->LOcost[i].rownr = 1; /* Actual updates */\n    newitem->LOcost[i].colnr = 1; /* Attempted updates */\n    newitem->UPcost[i].rownr = 1;\n    newitem->UPcost[i].colnr = 1;\n\n    /* Initialize with the plain OF value as conventional usage suggests, or\n       override in case of pseudo-nonint count strategy */\n    PSinitUP = my_chsign(is_maxim(lp), get_mat(lp, 0, i));\n    PSinitLO = -PSinitUP;\n    if(isPSCount) {\n      /* Set default assumed reduction in the number of non-ints by choosing this variable;\n         KE changed from 0 on 30 June 2004 and made two-sided selectable.  Note that the\n         typical value range is <0..1>, with a positive bias for an \"a priori\" assumed\n         fast-converging (low \"MIP-complexity\") model. Very hard models may require\n         negative initialized values for one or both. */\n      PSinitUP = 0.1*0;\n#if 0\n      PSinitUP = my_chsign(PSinitUP < 0, PSinitUP);\n      PSinitLO = -PSinitUP;\n#else\n      PSinitLO = PSinitUP;\n#endif\n    }\n    newitem->UPcost[i].value = PSinitUP;\n    newitem->LOcost[i].value = PSinitLO;\n  }\n  newitem->updatelimit     = lp->bb_PseudoUpdates;\n  newitem->updatesfinished = 0;\n  newitem->restartlimit    = DEF_PSEUDOCOSTRESTART;\n\n  /* Let the user get an opportunity to initialize pseudocosts */\n  if(userabort(lp, MSG_INITPSEUDOCOST))\n    lp->spx_status = USERABORT;\n\n  return( newitem );\n}\n\nSTATIC MYBOOL free_pseudoclass(BBPSrec **PseudoClass)\n{\n  BBPSrec *target = *PseudoClass;\n\n  FREE(target->LOcost);\n  FREE(target->UPcost);\n  target = target->secondary;\n  FREE(*PseudoClass);\n  *PseudoClass = target;\n\n  return( (MYBOOL) (target != NULL) );\n}\n\nSTATIC void free_pseudocost(lprec *lp)\n{\n  if((lp != NULL) && (lp->bb_PseudoCost != NULL)) {\n    while(free_pseudoclass(&(lp->bb_PseudoCost)) );\n  }\n}\n\nMYBOOL __WINAPI set_pseudocosts(lprec *lp, REAL *clower, REAL *cupper, int *updatelimit)\n{\n  int i;\n\n  if((lp->bb_PseudoCost == NULL) || ((clower == NULL) && (cupper == NULL)))\n    return(FALSE);\n  for(i = 1; i <= lp->columns; i++) {\n    if(clower != NULL)\n      lp->bb_PseudoCost->LOcost[i].value = clower[i];\n    if(cupper != NULL)\n      lp->bb_PseudoCost->UPcost[i].value = cupper[i];\n  }\n  if(updatelimit != NULL)\n    lp->bb_PseudoCost->updatelimit = *updatelimit;\n  return(TRUE);\n}\n\nMYBOOL __WINAPI get_pseudocosts(lprec *lp, REAL *clower, REAL *cupper, int *updatelimit)\n{\n  int i;\n\n  if((lp->bb_PseudoCost == NULL) || ((clower == NULL) && (cupper == NULL)))\n    return(FALSE);\n  for(i = 1; i <= lp->columns; i++) {\n    if(clower != NULL)\n      clower[i] = lp->bb_PseudoCost->LOcost[i].value;\n    if(cupper != NULL)\n      cupper[i] = lp->bb_PseudoCost->UPcost[i].value;\n  }\n  if(updatelimit != NULL)\n    *updatelimit = lp->bb_PseudoCost->updatelimit;\n  return(TRUE);\n}\n\nSTATIC REAL get_pseudorange(BBPSrec *pc, int mipvar, int varcode)\n{\n  if(varcode == BB_SC)\n    return( unscaled_value(pc->lp, pc->lp->sc_lobound[mipvar], pc->lp->rows+mipvar) );\n  else\n    return( 1.0 );\n}\n\nSTATIC void update_pseudocost(BBPSrec *pc, int mipvar, int varcode, MYBOOL capupper, REAL varsol)\n{\n  REAL     OFsol, uplim;\n  MATitem  *PS;\n  MYBOOL   nonIntSelect = is_bb_rule(pc->lp, NODE_PSEUDONONINTSELECT);\n\n  /* Establish input values;\n     Note: The pseudocosts are normalized to the 0-1 range! */\n  uplim = get_pseudorange(pc, mipvar, varcode);\n  varsol = modf(varsol/uplim, &OFsol);\n\n  /* Set reference value according to pseudocost mode */\n  if(nonIntSelect)\n    OFsol = pc->lp->bb_bounds->lastvarcus;    /* The count of MIP infeasibilities */\n  else\n    OFsol = pc->lp->solution[0];              /* The problem's objective function value */\n\n#if 0\n  if(_isnan(varsol)) {\n    pc->lp->bb_parentOF = OFsol;\n    return;\n  }\n#endif\n\n  /* Point to the applicable (lower or upper) bound and increment attempted update count */\n  if(capupper) {\n    PS = &pc->LOcost[mipvar];\n  }\n  else {\n    PS = &pc->UPcost[mipvar];\n    varsol = 1-varsol;\n  }\n  PS->colnr++;\n\n  /* Make adjustment to divisor if we are using the ratio pseudo-cost approach */\n  if(is_bb_rule(pc->lp, NODE_PSEUDORATIOSELECT))\n    varsol *= capupper;\n\n  /* Compute the update (consider weighting in favor of most recent) */\n  mipvar = pc->updatelimit;\n  if(((mipvar <= 0) || (PS->rownr < mipvar)) &&\n     (fabs(varsol) > pc->lp->epspivot)) {\n    /* We are interested in the change in the MIP measure (contribution to increase\n       or decrease, as the case may be) and not its last value alone. */\n    PS->value = PS->value*PS->rownr + (pc->lp->bb_parentOF-OFsol) / (varsol*uplim);\n    PS->rownr++;\n    PS->value /= PS->rownr;\n    /* Check if we have enough information to restart */\n    if(PS->rownr == mipvar) {\n      pc->updatesfinished++;\n      if(is_bb_mode(pc->lp, NODE_RESTARTMODE) &&\n        (pc->updatesfinished/(2.0*pc->lp->int_vars) >\n         pc->restartlimit)) {\n        pc->lp->bb_break = AUTOMATIC;\n        pc->restartlimit *= 2.681;  /* KE: Who can figure this one out? */\n        if(pc->restartlimit > 1)\n          pc->lp->bb_rule -= NODE_RESTARTMODE;\n        report(pc->lp, NORMAL, \"update_pseudocost: Restarting with updated pseudocosts\\n\");\n      }\n    }\n  }\n  pc->lp->bb_parentOF = OFsol;\n}\n\nSTATIC REAL get_pseudobranchcost(BBPSrec *pc, int mipvar, MYBOOL dofloor)\n{\n  if(dofloor)\n    return( pc->LOcost[mipvar].value );\n  else\n    return( pc->UPcost[mipvar].value );\n}\n\nSTATIC REAL get_pseudonodecost(BBPSrec *pc, int mipvar, int vartype, REAL varsol)\n{\n  REAL hold, uplim;\n\n  uplim = get_pseudorange(pc, mipvar, vartype);\n  varsol = modf(varsol/uplim, &hold);\n#if 0\n  if(_isnan(varsol))\n    varsol = 0;\n#endif\n\n  hold = pc->LOcost[mipvar].value*varsol +\n         pc->UPcost[mipvar].value*(1-varsol);\n\n  return( hold*uplim );\n}\n\nSTATIC int compute_theta(lprec *lp, int rownr, LREAL *theta, int isupbound, REAL HarrisScalar, MYBOOL primal)\n/* The purpose of this routine is to compute the non-basic bound state / value of\n   the leaving variable. Note that the incoming theta is \"d\" in Chvatal-terminology */\n{\n  int             colnr = lp->var_basic[rownr];\n  register LREAL x     = lp->rhs[rownr];\n  REAL            lb    = 0,  /* Put lower bound here when the fully bounded version is implemented */\n                  ub    = lp->upbo[colnr],\n                  eps   = lp->epsprimal;  /* Primal feasibility tolerance */\n\n  /* Compute theta for the primal simplex */\n  HarrisScalar *= eps;\n  if(primal) {\n\n    if(*theta > 0)\n      x -= lb - HarrisScalar;   /* A positive number */\n    else if(ub < lp->infinite)\n      x -= ub + HarrisScalar;   /* A negative number */\n    else {\n      *theta = -lp->infinite;\n      return( colnr );\n    }\n  }\n  /* Compute theta for the dual simplex */\n  else {\n\n    if(isupbound)\n      *theta = -(*theta);\n\n    /* Current value is below or equal to its lower bound */\n    if(x < lb+eps)\n      x -= lb - HarrisScalar;\n\n    /* Current value is above or equal to its upper bound */\n    else if(x > ub-eps) {\n      if(ub >= lp->infinite) {\n        *theta = lp->infinite * my_sign(*theta);\n        return( colnr );\n      }\n      else\n        x -= ub + HarrisScalar;\n    }\n  }\n  my_roundzero(x, lp->epsmachine);\n  *theta = x / *theta;\n\n#ifdef EnforcePositiveTheta\n  /* Check if we have negative theta due to rounding or an internal error */\n  if(*theta < 0) {\n    if(primal && (ub == lb))\n      lp->rhs[rownr] = lb;\n    else\n#ifdef Paranoia\n    if(*theta < -eps) {\n      report(lp, DETAILED, \"compute_theta: Negative theta (%g) not allowed in base-0 version of lp_solve\\n\",\n                            *theta);\n    }\n#endif\n    *theta = 0;\n  }\n#endif\n\n  return( colnr );\n}\n\nSTATIC MYBOOL check_degeneracy(lprec *lp, REAL *pcol, int *degencount)\n/* Check if the entering column Pi=Inv(B)*a is likely to produce improvement;\n   (cfr. Istvan Maros: CTOTSM p. 233) */\n{\n  int  i, ndegen;\n  REAL *rhs, sdegen, epsmargin = lp->epsprimal;\n\n  sdegen = 0;\n  ndegen = 0;\n  rhs    = lp->rhs;\n  for(i = 1; i <= lp->rows; i++) {\n    rhs++;\n    pcol++;\n    if(fabs(*rhs) < epsmargin) {\n      sdegen += *pcol;\n      ndegen++;\n    }\n    else if(fabs((*rhs)-lp->upbo[lp->var_basic[i]]) < epsmargin) {\n      sdegen -= *pcol;\n      ndegen++;\n    }\n  }\n  if(degencount != NULL)\n    *degencount = ndegen;\n/*  sdegen += epsmargin*ndegen; */\n  return( (MYBOOL) (sdegen <= 0) );\n}\n\nSTATIC MYBOOL performiteration(lprec *lp, int rownr, int varin, LREAL theta, MYBOOL primal, MYBOOL allowminit,\n                               REAL *prow, int *nzprow, REAL *pcol, int *nzpcol, int *boundswaps)\n{\n  static int    varout;\n  static REAL   pivot, epsmargin, leavingValue, leavingUB, enteringUB;\n  static MYBOOL leavingToUB, enteringFromUB, enteringIsFixed, leavingIsFixed;\n  MYBOOL *islower = &(lp->is_lower[varin]);\n  MYBOOL minitNow = FALSE, minitStatus = ITERATE_MAJORMAJOR;\n  LREAL  deltatheta = theta;\n\n  if(userabort(lp, MSG_ITERATION))\n    return( minitNow );\n\n#ifdef Paranoia\n  if(rownr > lp->rows) {\n    if (lp->spx_trace)\n      report(lp, IMPORTANT, \"performiteration: Numeric instability encountered!\\n\");\n    lp->spx_status = NUMFAILURE;\n    return( FALSE );\n  }\n#endif\n  varout = lp->var_basic[rownr];\n#ifdef Paranoia\n  if(!lp->is_lower[varout])\n    report(lp, SEVERE, \"performiteration: Leaving variable %d was at its upper bound at iter %.0f\\n\",\n                        varout, (double) get_total_iter(lp));\n#endif\n\n  /* Theta is the largest change possible (strictest constraint) for the entering\n     variable (Theta is Chvatal's \"t\", ref. Linear Programming, pages 124 and 156) */\n  lp->current_iter++;\n\n  /* Test if it is possible to do a cheap \"minor iteration\"; i.e. set entering\n     variable to its opposite bound, without entering the basis - which is\n     obviously not possible for fixed variables! */\n  epsmargin = lp->epsprimal;\n  enteringFromUB = !(*islower);\n  enteringUB = lp->upbo[varin];\n  leavingUB  = lp->upbo[varout];\n  enteringIsFixed = (MYBOOL) (fabs(enteringUB) < epsmargin);\n  leavingIsFixed  = (MYBOOL) (fabs(leavingUB) < epsmargin);\n#ifdef Paranoia\n  if(enteringUB < 0)\n    report(lp, SEVERE, \"performiteration: Negative range for entering variable %d at iter %.0f\\n\",\n                        varin, (double) get_total_iter(lp));\n  if(leavingUB < 0)\n    report(lp, SEVERE, \"performiteration: Negative range for leaving variable %d at iter %.0f\\n\",\n                        varout, (double) get_total_iter(lp));\n#endif\n\n  /* Handle batch bound swaps with the dual long-step algorithm;\n     Loop over specified bound swaps; update RHS and Theta for bound swaps */\n  if((boundswaps != NULL) && (boundswaps[0] > 0)) {\n\n    int   i, boundvar;\n    REAL  *hold;\n\n    /* Allocate and initialize accumulation array */\n    allocREAL(lp, &hold, lp->rows + 1, TRUE);\n\n    /* Accumulate effective bound swaps and update flag */\n    for(i = 1; i <= boundswaps[0]; i++) {\n      boundvar = boundswaps[i];\n      deltatheta = my_chsign(!lp->is_lower[boundvar], lp->upbo[boundvar]);\n      mat_multadd(lp->matA, hold, boundvar, deltatheta);\n      lp->is_lower[boundvar] = !lp->is_lower[boundvar];\n    }\n    lp->current_bswap += boundswaps[0];\n    lp->current_iter  += boundswaps[0];\n\n    /* Solve for bound flip update vector (note that this does not\n       overwrite the stored update vector for the entering variable) */\n    ftran(lp, hold, NULL, lp->epsmachine);\n    if(!lp->obj_in_basis)\n      hold[0] = 0; /* The correct reduced cost goes here (adjusted for bound state) ****** */\n\n    /* Update the RHS / basic variable values and set revised thetas */\n    pivot = lp->bfp_pivotRHS(lp, 1, hold);\n    deltatheta = multi_enteringtheta(lp->longsteps);\n    theta = deltatheta;\n\n    FREE(hold);\n  }\n\n  /* Otherwise to traditional check for single bound swap */\n  else if(allowminit &&\n           !enteringIsFixed) {\n\n/*    pivot = epsmargin; */\n    pivot = lp->epsdual;\n/* #define v51mode */ /* Enable this for v5.1 operation mode */\n#ifdef v51mode\n    if(((lp->simplex_mode & SIMPLEX_Phase1_DUAL) == 0) ||\n       !is_constr_type(lp, rownr, EQ))                      /* *** DEBUG CODE KE */\n#endif\n    if(enteringUB - theta < -pivot) {\n\n#ifndef v51mode\n      if(fabs(enteringUB - theta) < pivot)\n        minitStatus = ITERATE_MINORMAJOR;\n      else\n#endif\n        minitStatus = ITERATE_MINORRETRY;\n      minitNow    = (MYBOOL) (minitStatus != ITERATE_MAJORMAJOR);\n    }\n  }\n\n  /* Process for traditional style single minor iteration */\n  if(minitNow) {\n\n   /* Set the new values (note that theta is set to always be positive) */\n    theta = MIN(fabs(theta), enteringUB);\n\n    /* Update the RHS / variable values and do bound-swap */\n    pivot = lp->bfp_pivotRHS(lp, theta, NULL);\n    *islower = !(*islower);\n\n    lp->current_bswap++;\n\n  }\n\n  /* Process for major iteration */\n  else {\n\n    /* Update the active pricer for the current pivot */\n    updatePricer(lp, rownr, varin, lp->bfp_pivotvector(lp), prow, nzprow);\n\n    /* Update the current basic variable values */\n    pivot = lp->bfp_pivotRHS(lp, theta, NULL);\n\n    /* See if the leaving variable goes directly to its upper bound. */\n    leavingValue = lp->rhs[rownr];\n    leavingToUB = (MYBOOL) (leavingValue > 0.5*leavingUB);\n    lp->is_lower[varout] = leavingIsFixed || !leavingToUB;\n\n    /* Set the value of the entering varible (theta always set to be positive) */\n    if(enteringFromUB) {\n      lp->rhs[rownr] = enteringUB - deltatheta;\n      *islower = TRUE;\n    }\n    else\n      lp->rhs[rownr] = deltatheta;\n    my_roundzero(lp->rhs[rownr], epsmargin);\n\n   /* Update basis indeces */\n    varout = set_basisvar(lp, rownr, varin);\n\n   /* Finalize the update in preparation for next major iteration */\n    lp->bfp_finishupdate(lp, enteringFromUB);\n\n  }\n\n  /* Show pivot tracking information, if specified */\n  if((lp->verbose > NORMAL) && (MIP_count(lp) == 0) &&\n     ((lp->current_iter % MAX(2, lp->rows / 10)) == 0))\n    report(lp, NORMAL, \"Objective value \" RESULTVALUEMASK \" at iter %10.0f.\\n\",\n                       lp->rhs[0], (double) get_total_iter(lp));\n\n#if 0\n  if(verify_solution(lp, FALSE, my_if(minitNow, \"MINOR\", \"MAJOR\")) >= 0) {\n    if(minitNow)\n      pivot = get_obj_active(lp, varin);\n    else\n      pivot = get_obj_active(lp, varout);\n  }\n#endif\n#if 0\n  if((lp->longsteps != NULL) && (boundswaps[0] > 0) && lp->longsteps->objcheck &&\n    ((pivot = fabs(my_reldiff(lp->rhs[0], lp->longsteps->obj_last))) > lp->epssolution)) {\n    report(lp, IMPORTANT, \"performiteration: Objective value gap %8.6f found at iter %6.0f (%d bound flips, %d)\\n\",\n                          pivot, (double) get_total_iter(lp), boundswaps[0], enteringFromUB);\n  }\n#endif\n\n  if(lp->spx_trace) {\n    if(minitNow)\n      report(lp, NORMAL, \"I:%5.0f - minor - %5d ignored,          %5d flips  from %s with THETA=%g and OBJ=%g\\n\",\n                         (double) get_total_iter(lp), varout, varin, (enteringFromUB ? \"UPPER\" : \"LOWER\"), theta, lp->rhs[0]);\n    else\n      report(lp, NORMAL, \"I:%5.0f - MAJOR - %5d leaves to %s,  %5d enters from %s with THETA=%g and OBJ=%g\\n\",\n                         (double) get_total_iter(lp), varout, (leavingToUB    ? \"UPPER\" : \"LOWER\"),\n                                           varin,  (enteringFromUB ? \"UPPER\" : \"LOWER\"), theta, lp->rhs[0]);\n    if(minitNow) {\n      if(!lp->is_lower[varin])\n        report(lp, DETAILED,\n        \"performiteration: Variable %d changed to its lower bound at iter %.0f (from %g)\\n\",\n        varin, (double) get_total_iter(lp), enteringUB);\n      else\n        report(lp, DETAILED,\n        \"performiteration: Variable %d changed to its upper bound at iter %.0f (to %g)\\n\",\n        varin, (double) get_total_iter(lp), enteringUB);\n    }\n    else\n      report(lp, NORMAL,\n          \"performiteration: Variable %d entered basis at iter %.0f at \" RESULTVALUEMASK \"\\n\",\n          varin, (double) get_total_iter(lp), lp->rhs[rownr]);\n    if(!primal) {\n      pivot = compute_feasibilitygap(lp, (MYBOOL)!primal, TRUE);\n      report(lp, NORMAL, \"performiteration: Feasibility gap at iter %.0f is \" RESULTVALUEMASK \"\\n\",\n                         (double) get_total_iter(lp), pivot);\n    }\n    else\n      report(lp, NORMAL,\n          \"performiteration: Current objective function value at iter %.0f is \" RESULTVALUEMASK \"\\n\",\n          (double) get_total_iter(lp), lp->rhs[0]);\n  }\n\n  return( minitStatus );\n\n} /* performiteration */\n\nSTATIC REAL get_refactfrequency(lprec *lp, MYBOOL final)\n{\n  COUNTER iters;\n  int     refacts;\n\n  /* Get numerator and divisor information */\n  iters   = (lp->total_iter+lp->current_iter) - (lp->total_bswap+lp->current_bswap);\n  refacts = lp->bfp_refactcount(lp, BFP_STAT_REFACT_TOTAL);\n\n  /* Return frequency for different cases:\n      1) Actual frequency in case final statistic is desired\n      2) Dummy if we are in a B&B process\n      3) Frequency with added initialization offsets which\n         are diluted in course of the solution process */\n  if(final)\n    return( (REAL) (iters) / MAX(1,refacts) );\n  else if(lp->bb_totalnodes > 0)\n    return( (REAL) lp->bfp_pivotmax(lp) );\n  else\n    return( (REAL) (lp->bfp_pivotmax(lp)+iters) / (1+refacts) );\n}\n\n#if 0\n/* INLINE */ MYBOOL is_fixedvar(lprec *lp, int variable)\n{\n  if((lp->bb_bounds != NULL && lp->bb_bounds->UBzerobased) || (variable <= lp->rows))\n    return( (MYBOOL) (lp->upbo[variable] < lp->epsprimal) );\n  else\n    return( (MYBOOL) (lp->upbo[variable]-lp->lowbo[variable] < lp->epsprimal) );\n} /* is_fixedvar */\n#endif\n\nSTATIC MYBOOL solution_is_int(lprec *lp, int index, MYBOOL checkfixed)\n{\n#if 1\n  return( (MYBOOL) (isINT(lp, lp->solution[index]) && (!checkfixed || is_fixedvar(lp, index))) );\n#else\n  if(isINT(lp, lp->solution[index])) {\n    if(checkfixed)\n      return(is_fixedvar(lp, index));\n    else\n      return(TRUE);\n  }\n  return(FALSE);\n#endif\n} /* solution_is_int */\n\n\nMYBOOL __WINAPI set_multiprice(lprec *lp, int multiblockdiv)\n{\n  /* See if we are resetting multiply priced column structures */\n  if(multiblockdiv != lp->multiblockdiv) {\n    if(multiblockdiv < 1)\n      multiblockdiv = 1;\n    lp->multiblockdiv = multiblockdiv;\n    multi_free(&(lp->multivars));\n  }\n  return( TRUE );\n}\n\nint __WINAPI get_multiprice(lprec *lp, MYBOOL getabssize)\n{\n  if((lp->multivars == NULL) || (lp->multivars->used == 0))\n    return( 0 );\n  if(getabssize)\n    return( lp->multivars->size );\n  else\n    return( lp->multiblockdiv );\n}\n\nMYBOOL __WINAPI set_partialprice(lprec *lp, int blockcount, int *blockstart, MYBOOL isrow)\n{\n  int        ne, i, items;\n  partialrec **blockdata;\n\n  /* Determine partial target (rows or columns) */\n  if(isrow)\n    blockdata = &(lp->rowblocks);\n  else\n    blockdata = &(lp->colblocks);\n\n  /* See if we are resetting partial blocks */\n  ne = 0;\n  items = IF(isrow, lp->rows, lp->columns);\n  if(blockcount == 1)\n    partial_freeBlocks(blockdata);\n\n  /* Set a default block count if this was not specified */\n  else if(blockcount <= 0) {\n    blockstart = NULL;\n    if(items < DEF_PARTIALBLOCKS*DEF_PARTIALBLOCKS)\n      blockcount = items / DEF_PARTIALBLOCKS + 1;\n    else\n      blockcount = DEF_PARTIALBLOCKS;\n    ne = items / blockcount;\n    if(ne * blockcount < items)\n      ne++;\n  }\n\n  /* Fill partial block arrays;\n     Note: These will be modified during preprocess to reflect\n           presolved columns and the handling of slack variables. */\n  if(blockcount > 1) {\n    MYBOOL     isNew = (MYBOOL) (*blockdata == NULL);\n\n    /* Provide for extra block with slack variables in the column mode */\n    i = 0;\n    if(!isrow)\n      i++;\n\n    /* (Re)-allocate memory */\n    if(isNew)\n      *blockdata = partial_createBlocks(lp, isrow);\n    allocINT(lp, &((*blockdata)->blockend), blockcount+i+1, AUTOMATIC);\n    allocINT(lp, &((*blockdata)->blockpos), blockcount+i+1, AUTOMATIC);\n\n    /* Copy the user-provided block start positions */\n    if(blockstart != NULL) {\n      MEMCOPY((*blockdata)->blockend+i, blockstart, blockcount+i+1);\n      if(!isrow) {\n        blockcount++;\n        (*blockdata)->blockend[0] = 1;\n        for(i = 1; i < blockcount; i++)\n          (*blockdata)->blockend[i] += lp->rows;\n      }\n    }\n\n    /* Fill the block ending positions if they were not specified */\n    else {\n      (*blockdata)->blockend[0] = 1;\n      (*blockdata)->blockpos[0] = 1;\n      if(ne == 0) {\n        ne = items / blockcount;\n        /* Increase the block size if we have a fractional value */\n        while(ne * blockcount < items)\n          ne++;\n      }\n      i = 1;\n      if(!isrow) {\n        (*blockdata)->blockend[i] = (*blockdata)->blockend[i-1]+lp->rows;\n        blockcount++;\n        i++;\n        items += lp->rows;\n      }\n      for(; i < blockcount; i++)\n        (*blockdata)->blockend[i] = (*blockdata)->blockend[i-1]+ne;\n\n      /* Let the last block handle the \"residual\" */\n      (*blockdata)->blockend[blockcount] = items+1;\n    }\n\n    /* Fill starting positions (used in multiple partial pricing) */\n    for(i = 1; i <= blockcount; i++)\n      (*blockdata)->blockpos[i] = (*blockdata)->blockend[i-1];\n\n  }\n\n  /* Update block count */\n  (*blockdata)->blockcount = blockcount;\n\n\n  return( TRUE );\n} /* set_partialprice */\n\nvoid __WINAPI get_partialprice(lprec *lp, int *blockcount, int *blockstart, MYBOOL isrow)\n{\n  partialrec *blockdata;\n\n  /* Determine partial target (rows or columns) */\n  if(isrow)\n    blockdata = lp->rowblocks;\n  else\n    blockdata = lp->colblocks;\n\n  *blockcount = partial_countBlocks(lp, isrow);\n  if((blockdata != NULL) && (blockstart != NULL)) {\n    int i = 0, k = *blockcount;\n    if(!isrow)\n      i++;\n    MEMCOPY(blockstart, blockdata->blockend + i, k - i);\n    if(!isrow) {\n      k -= i;\n      for(i = 0; i < k; i++)\n        blockstart[i] -= lp->rows;\n    }\n  }\n}\n\n\n/* Solution-related functions */\nSTATIC MYBOOL bb_better(lprec *lp, int target, int mode)\n/* Must handle four modes (logic assumes Min!):\n      -----|--.--|----->\n   1  ++++++-----------  LHS exclusive test point is better\n   2  +++++++++--------  LHS inclusive\n   3  ++++++-----++++++  LHS+RHS exclusive\n   4  --------+++++++++  RHS inclusive\n   5  -----------++++++  RHS exclusive\n*/\n{\n  REAL   epsvalue, offset = lp->epsprimal,\n         refvalue = lp->infinite, testvalue = lp->solution[0];\n  MYBOOL ismax = is_maxim(lp),\n         relgap = is_action(mode, OF_TEST_RELGAP),\n         fcast  = is_action(target, OF_PROJECTED),\n         delta  = is_action(target, OF_DELTA);\n\n  if(relgap) {\n    epsvalue = lp->mip_relgap;\n    clear_action(&mode, OF_TEST_RELGAP);\n  }\n  else\n    epsvalue = lp->mip_absgap;\n\n  if(delta)\n    clear_action(&target, OF_DELTA);\n  if(fcast)\n    clear_action(&target, OF_PROJECTED);\n#ifdef Paranoia\n  if((mode < OF_TEST_BT) || (mode > OF_TEST_WT))\n    report(lp, SEVERE, \"bb_better: Passed invalid mode '%d'\\n\", mode);\n#endif\n\n  switch(target) {\n    case OF_RELAXED:   refvalue = lp->real_solution;\n                       break;\n    case OF_INCUMBENT: refvalue = lp->best_solution[0];\n                       break;\n    case OF_WORKING:  refvalue = my_chsign(!ismax, lp->bb_workOF);\n                       if(fcast)\n                         testvalue = my_chsign(!ismax, lp->longsteps->obj_last) - epsvalue;\n                       else\n                         testvalue = my_chsign(!ismax, lp->rhs[0]);\n                       break;\n    case OF_USERBREAK: refvalue = lp->bb_breakOF;\n                       break;\n    case OF_HEURISTIC: refvalue = lp->bb_heuristicOF;\n                       break;\n    case OF_DUALLIMIT: refvalue = lp->bb_limitOF;\n                       break;\n    default         :  report(lp, SEVERE, \"bb_better: Passed invalid test target '%d'\\n\", target);\n                       return( FALSE );\n  }\n\n  /* Adjust the test value for the desired acceptability window */\n  if(delta) {\n    SETMAX(epsvalue, lp->bb_deltaOF - epsvalue);\n  }\n  else\n    epsvalue = my_chsign(target >= OF_USERBREAK, epsvalue); /* *** This seems Ok, but should be verified */\n  testvalue += my_chsign(ismax, epsvalue);\n\n  /* Compute the raw test value */\n  if(relgap)\n    testvalue = my_reldiff(testvalue, refvalue);\n  else\n    testvalue -= refvalue;\n\n  /* Make test value adjustment based on the selected option */\n  if(mode == OF_TEST_NE)\n    relgap = (MYBOOL) (fabs(testvalue) >= offset);\n  else {\n    testvalue = my_chsign(mode > OF_TEST_NE, testvalue);\n    testvalue = my_chsign(ismax, testvalue);\n    relgap = (MYBOOL) (testvalue < offset);\n  }\n  return( relgap );\n}\n\nSTATIC void construct_solution(lprec *lp, REAL *target)\n{\n  int     i, j, basi;\n  REAL    f, epsvalue = lp->epsprimal;\n  REAL    *solution;\n  REAL    *value;\n  int     *rownr;\n  MATrec  *mat = lp->matA;\n\n  if(target == NULL)\n    solution = lp->solution;\n  else\n    solution = target;\n\n  /* Initialize OF and slack variables. */\n  for(i = 0; i <= lp->rows; i++) {\n#ifdef LegacySlackDefinition\n    if(i == 0)\n      f = unscaled_value(lp, -lp->orig_rhs[i], i);\n    else {\n      j = lp->presolve_undo->var_to_orig[i];\n      if(j > 0) {\n        f = lp->presolve_undo->fixed_rhs[j];\n        f = unscaled_value(lp, f, i);\n      }\n      else\n        f = 0;\n    }\n#else\n    f = lp->orig_rhs[i];\n    if((i > 0) && !lp->is_basic[i] && !lp->is_lower[i])\n#ifdef SlackInitMinusInf\n      f -= my_chsign(is_chsign(lp, i), fabs(lp->upbo[i]));\n#else\n      f -= my_chsign(is_chsign(lp, i), fabs(lp->lowbo[i] + lp->upbo[i]));\n#endif\n    f = unscaled_value(lp, -f, i);\n#endif\n    solution[i] = f;\n  }\n\n  /* Initialize user variables to their lower bounds. */\n  for(i = lp->rows+1; i <= lp->sum; i++)\n    solution[i] = lp->lowbo[i];\n\n  /* Add values of user basic variables. */\n  for(i = 1; i <= lp->rows; i++) {\n    basi = lp->var_basic[i];\n    if(basi > lp->rows) {\n      solution[basi] += lp->rhs[i];\n    }\n  }\n\n  /* 1. Adjust non-basic variables at their upper bounds,\n     2. Unscale all user variables,\n     3. Optionally do precision management. */\n  for(i = lp->rows + 1; i <= lp->sum; i++) {\n    if(!lp->is_basic[i] && !lp->is_lower[i])\n      solution[i] += lp->upbo[i];\n    solution[i] = unscaled_value(lp, solution[i], i);\n#ifdef xImproveSolutionPrecision\n    if(is_int(lp, i-lp->rows))\n      solution[i] = restoreINT(solution[i], lp->epsint);\n    else\n      solution[i] = restoreINT(solution[i], lp->epsprimal);\n#endif\n  }\n\n  /* Compute the OF and slack values \"in extentio\" */\n  for(j = 1; j <= lp->columns; j++) {\n    f = solution[lp->rows + j];\n    if(f != 0) {\n      solution[0] += f * unscaled_mat(lp, lp->orig_obj[j], 0, j);\n      i = mat->col_end[j-1];\n      basi = mat->col_end[j];\n      rownr = &COL_MAT_ROWNR(i);\n      value = &COL_MAT_VALUE(i);\n      for(; i < basi;\n          i++, rownr += matRowColStep, value += matValueStep)\n        solution[*rownr] += f * unscaled_mat(lp, *value, *rownr, j);\n    }\n  }\n\n  /* Do slack precision management and sign reversal if necessary */\n  for(i = 0; i <= lp->rows; i++) {\n#ifdef ImproveSolutionPrecision\n    my_roundzero(solution[i], epsvalue);\n#endif\n    if(is_chsign(lp, i))\n      solution[i] = my_flipsign(solution[i]);\n  }\n\n /* Record the best real-valued solution and compute a simple MIP solution limit */\n  if(target == NULL) {\n    if(is_infinite(lp, lp->real_solution)) {\n      lp->bb_workOF = lp->rhs[0];\n      lp->real_solution = solution[0];\n      if(is_infinite(lp, lp->bb_limitOF))\n        lp->bb_limitOF = lp->real_solution;\n      else {\n        if(is_maxim(lp)) {\n          SETMIN(lp->bb_limitOF, lp->real_solution);\n        }\n        else {\n          SETMAX(lp->bb_limitOF, lp->real_solution);\n        }\n      }\n\n      /* Do MIP-related tests and computations */\n      if((lp->int_vars > 0) && mat_validate(lp->matA) && !lp->wasPresolved) {\n        REAL fixedOF = unscaled_value(lp, lp->orig_rhs[0], 0);\n\n        /* Check if we have an all-integer OF */\n        basi = lp->columns;\n        for(j = 1; j <= basi; j++) {\n          f = fabs(get_mat(lp, 0, j)) + lp->epsint/2;\n          f = fmod(f, 1);\n          if(!is_int(lp, j) || (f > lp->epsint))\n            break;\n        }\n\n        /* If so, we can round up the fractional OF */\n        if(j > basi) {\n          f = my_chsign(is_maxim(lp), lp->real_solution) + fixedOF;\n          f = floor(f+(1-epsvalue));\n          lp->bb_limitOF = my_chsign(is_maxim(lp), f - fixedOF);\n        }\n      }\n      /* Check that a user limit on the OF is feasible */\n      if((lp->int_vars > 0) &&\n         (my_chsign(is_maxim(lp), my_reldiff(lp->best_solution[0],lp->bb_limitOF)) < -epsvalue)) {\n        lp->spx_status = INFEASIBLE;\n        lp->bb_break = TRUE;\n      }\n    }\n  }\n\n} /* construct_solution */\n\nSTATIC int check_solution(lprec *lp, int  lastcolumn, REAL *solution,\n                          REAL *upbo, REAL *lowbo, REAL tolerance)\n{\n/*#define UseMaxValueInCheck*/\n  MYBOOL isSC;\n  REAL   test, value, hold, diff, maxdiff = 0.0, maxerr = 0.0, *matValue,\n#ifdef UseMaxValueInCheck\n         *maxvalue = NULL,\n#else\n         *plusum = NULL, *negsum = NULL;\n#endif\n  int    i,j,n, errlevel = IMPORTANT, errlimit = 10, *matRownr, *matColnr;\n  MATrec *mat = lp->matA;\n\n  report(lp, NORMAL, \" \\n\");\n  if(MIP_count(lp) > 0)\n    report(lp, NORMAL, \"%sOptimal solution \" RESULTVALUEMASK \" after %10.0f iter, %9.0f nodes (gap %.1f%%).\\n\",\n                       my_if(lp->bb_break, \"-\", \"+\"),\n                       solution[0], (double) lp->total_iter, (double) lp->bb_totalnodes,\n                       100.0*fabs(my_reldiff(lp->solution[0], lp->bb_limitOF)));\n  else\n    report(lp, NORMAL, \"Optimal solution  \" RESULTVALUEMASK \" after %10.0f iter.\\n\",\n                       solution[0], (double) lp->total_iter);\n\n /* Find the signed sums and the largest absolute product in the matrix (exclude the OF for speed) */\n#ifdef UseMaxValueInCheck\n  allocREAL(lp, &maxvalue, lp->rows + 1, FALSE);\n  for(i = 0; i <= lp->rows; i++)\n    maxvalue[i] = fabs(get_rh(lp, i));\n#else\n  allocREAL(lp, &plusum, lp->rows + 1, TRUE);\n  allocREAL(lp, &negsum, lp->rows + 1, TRUE);\n#endif\n  n = get_nonzeros(lp);\n  matRownr = &COL_MAT_ROWNR(0);\n  matColnr = &COL_MAT_COLNR(0);\n  matValue = &COL_MAT_VALUE(0);\n  for(i = 0; i < n; i++, matRownr += matRowColStep,\n                         matColnr += matRowColStep,\n                         matValue += matValueStep) {\n    test = unscaled_mat(lp, *matValue, *matRownr, *matColnr);\n    test *= solution[lp->rows + (*matColnr)];\n#ifdef UseMaxValueInCheck\n    test = fabs(test);\n    if(test > maxvalue[*matRownr])\n      maxvalue[*matRownr] = test;\n#else\n    if(test > 0)\n      plusum[*matRownr] += test;\n    else\n      negsum[*matRownr] += test;\n#endif\n  }\n\n\n /* Check if solution values are within the bounds; allowing a margin for numeric errors */\n  n = 0;\n  for(i = lp->rows + 1; i <= lp->rows+lastcolumn; i++) {\n\n    value = solution[i];\n\n    /* Check for case where we are testing an intermediate solution\n       (variables shifted to the origin) */\n    if(lowbo == NULL)\n      test = 0;\n    else\n      test = unscaled_value(lp, lowbo[i], i);\n\n    isSC = is_semicont(lp, i - lp->rows);\n    diff = my_reldiff(value, test);\n    if(diff < 0) {\n      if(isSC && (value < test/2))\n        test = 0;\n      SETMAX(maxerr, fabs(value-test));\n      SETMAX(maxdiff, fabs(diff));\n    }\n    if((diff < -tolerance) && !isSC)  {\n      if(n < errlimit)\n      report(lp, errlevel,\n        \"check_solution: Variable   %s = \" RESULTVALUEMASK \" is below its lower bound \" RESULTVALUEMASK \"\\n\",\n         get_col_name(lp, i-lp->rows), value, test);\n      n++;\n    }\n\n    test = unscaled_value(lp, upbo[i], i);\n    diff = my_reldiff(value, test);\n    if(diff > 0) {\n      SETMAX(maxerr, fabs(value-test));\n      SETMAX(maxdiff, fabs(diff));\n    }\n    if(diff > tolerance) {\n      if(n < errlimit)\n      report(lp, errlevel,\n         \"check_solution: Variable   %s = \" RESULTVALUEMASK \" is above its upper bound \" RESULTVALUEMASK \"\\n\",\n         get_col_name(lp, i-lp->rows), value, test);\n      n++;\n    }\n  }\n\n /* Check if constraint values are within the bounds; allowing a margin for numeric errors */\n  for(i = 1; i <= lp->rows; i++) {\n\n    test = lp->orig_rhs[i];\n    if(is_infinite(lp, test))\n      continue;\n\n#ifdef LegacySlackDefinition\n    j = lp->presolve_undo->var_to_orig[i];\n    if(j != 0) {\n      if(is_infinite(lp, lp->presolve_undo->fixed_rhs[j]))\n        continue;\n      test += lp->presolve_undo->fixed_rhs[j];\n    }\n#endif\n\n    if(is_chsign(lp, i)) {\n      test = my_flipsign(test);\n      test += fabs(upbo[i]);\n    }\n    value = solution[i];\n    test = unscaled_value(lp, test, i);\n#ifndef LegacySlackDefinition\n    value += test;\n#endif\n/*    diff = my_reldiff(value, test); */\n#ifdef UseMaxValueInCheck\n    hold = maxvalue[i];\n#else\n    hold = plusum[i] - negsum[i];\n#endif\n    if(hold < lp->epsvalue)\n      hold = 1;\n    diff = my_reldiff((value+1)/hold, (test+1)/hold);\n    if(diff > 0) {\n      SETMAX(maxerr, fabs(value-test));\n      SETMAX(maxdiff, fabs(diff));\n    }\n    if(diff > tolerance) {\n      if(n < errlimit)\n      report(lp, errlevel,\n        \"check_solution: Constraint %s = \" RESULTVALUEMASK \" is above its %s \" RESULTVALUEMASK \"\\n\",\n        get_row_name(lp, i), value,\n        (is_constr_type(lp, i, EQ) ? \"equality of\" : \"upper bound\"), test);\n      n++;\n    }\n\n    test = lp->orig_rhs[i];\n#ifdef LegacySlackDefinition\n    j = lp->presolve_undo->var_to_orig[i];\n    if(j != 0) {\n      if(is_infinite(lp, lp->presolve_undo->fixed_rhs[j]))\n        continue;\n      test += lp->presolve_undo->fixed_rhs[j];\n    }\n#endif\n\n    value = solution[i];\n    if(is_chsign(lp, i))\n      test = my_flipsign(test);\n    else {\n      if(is_infinite(lp, upbo[i]))\n        continue;\n      test -= fabs(upbo[i]);\n#ifndef LegacySlackDefinition\n      value = fabs(upbo[i]) - value;\n#endif\n    }\n    test = unscaled_value(lp, test, i);\n#ifndef LegacySlackDefinition\n    value += test;\n#endif\n/*    diff = my_reldiff(value, test); */\n#ifdef UseMaxValueInCheck\n    hold = maxvalue[i];\n#else\n    hold = plusum[i] - negsum[i];\n#endif\n    if(hold < lp->epsvalue)\n      hold = 1;\n    diff = my_reldiff((value+1)/hold, (test+1)/hold);\n    if(diff < 0) {\n      SETMAX(maxerr, fabs(value-test));\n      SETMAX(maxdiff, fabs(diff));\n    }\n    if(diff < -tolerance) {\n      if(n < errlimit)\n      report(lp, errlevel,\n        \"check_solution: Constraint %s = \" RESULTVALUEMASK \" is below its %s \" RESULTVALUEMASK \"\\n\",\n        get_row_name(lp, i), value,\n        (is_constr_type(lp, i, EQ) ? \"equality of\" : \"lower bound\"), test);\n      n++;\n    }\n  }\n\n#ifdef UseMaxValueInCheck\n  FREE(maxvalue);\n#else\n  FREE(plusum);\n  FREE(negsum);\n#endif\n\n  if(n > 0) {\n    report(lp, IMPORTANT, \"\\nSeriously low accuracy found ||*|| = %g (rel. error %g)\\n\",\n               maxerr, maxdiff);\n    return(NUMFAILURE);\n  }\n  else {\n    if(maxerr > 1.0e-7)\n      report(lp, NORMAL, \"\\nMarginal numeric accuracy ||*|| = %g (rel. error %g)\\n\",\n                 maxerr, maxdiff);\n    else if(maxerr > 1.0e-9)\n      report(lp, NORMAL, \"\\nReasonable numeric accuracy ||*|| = %g (rel. error %g)\\n\",\n                 maxerr, maxdiff);\n    else if(maxerr > 1.0e11)\n      report(lp, NORMAL, \"\\nVery good numeric accuracy ||*|| = %g\\n\", maxerr);\n    else\n      report(lp, NORMAL, \"\\nExcellent numeric accuracy ||*|| = %g\\n\", maxerr);\n\n    return(OPTIMAL);\n  }\n\n} /* check_solution */\n\nSTATIC void transfer_solution_var(lprec *lp, int uservar)\n{\n  if(lp->varmap_locked && (MYBOOL) ((lp->do_presolve & PRESOLVE_LASTMASKMODE) != PRESOLVE_NONE)) {\n    uservar += lp->rows;\n    lp->full_solution[lp->presolve_undo->orig_rows +\n                      lp->presolve_undo->var_to_orig[uservar]] = lp->best_solution[uservar];\n  }\n}\nSTATIC void transfer_solution(lprec *lp, MYBOOL dofinal)\n{\n  int i, ii;\n\n  MEMCOPY(lp->best_solution, lp->solution, lp->sum + 1);\n\n  /* Round integer solution values to actual integers */\n  if(is_integerscaling(lp) && (lp->int_vars > 0))\n    for(i = 1; i <= lp->columns; i++) {\n      if(is_int(lp, i)) {\n        ii = lp->rows + i;\n        lp->best_solution[ii] = floor(lp->best_solution[ii] + 0.5);\n      }\n    }\n\n  /* Transfer to full solution vector in the case of presolved eliminations */\n  if(dofinal && lp->varmap_locked &&\n     (MYBOOL) ((lp->do_presolve & PRESOLVE_LASTMASKMODE) != PRESOLVE_NONE)) {\n    presolveundorec *psundo = lp->presolve_undo;\n\n    lp->full_solution[0] = lp->best_solution[0];\n    for(i = 1; i <= lp->rows; i++) {\n      ii = psundo->var_to_orig[i];\n#ifdef Paranoia\n      if((ii < 0) || (ii > lp->presolve_undo->orig_rows))\n        report(lp, SEVERE, \"transfer_solution: Invalid mapping of row index %d to original index '%d'\\n\",\n                            i, ii);\n#endif\n      lp->full_solution[ii] = lp->best_solution[i];\n    }\n    for(i = 1; i <= lp->columns; i++) {\n      ii = psundo->var_to_orig[lp->rows+i];\n#ifdef Paranoia\n      if((ii < 0) || (ii > lp->presolve_undo->orig_columns))\n        report(lp, SEVERE, \"transfer_solution: Invalid mapping of column index %d to original index '%d'\\n\",\n                            i, ii);\n#endif\n      lp->full_solution[psundo->orig_rows+ii] = lp->best_solution[lp->rows+i];\n    }\n  }\n\n}\n\nSTATIC MYBOOL construct_duals(lprec *lp)\n{\n  int  i, n, *coltarget;\n  REAL scale0, value, dualOF;\n\n  if(lp->duals != NULL)\n    free_duals(lp);\n\n  if(is_action(lp->spx_action, ACTION_REBASE) ||\n     is_action(lp->spx_action, ACTION_REINVERT) || (!lp->basis_valid) ||\n     !allocREAL(lp, &(lp->duals), lp->sum + 1, AUTOMATIC))\n    return(FALSE);\n\n  /* Initialize */\n  coltarget = (int *) mempool_obtainVector(lp->workarrays, lp->columns+1, sizeof(*coltarget));\n  if(!get_colIndexA(lp, SCAN_USERVARS+USE_NONBASICVARS, coltarget, FALSE)) {\n    mempool_releaseVector(lp->workarrays, (char *) coltarget, FALSE);\n    return(FALSE);\n  }\n  bsolve(lp, 0, lp->duals, NULL, lp->epsmachine*DOUBLEROUND, 1.0);\n  prod_xA(lp, coltarget, lp->duals, NULL, lp->epsmachine, 1.0,\n                         lp->duals, NULL, MAT_ROUNDDEFAULT | MAT_ROUNDRC);\n  mempool_releaseVector(lp->workarrays, (char *) coltarget, FALSE);\n\n\n  /* The (Lagrangean) dual values are the reduced costs of the primal slacks;\n     when the slack is at its upper bound, change the sign. */\n  n = lp->rows;\n  for(i = 1; i <= n; i++) {\n    if(lp->is_basic[i])\n      lp->duals[i] = 0;\n    /* Added a test if variable is different from 0 because sometime you get -0 and this\n       is different from 0 on for example INTEL processors (ie 0 != -0 on INTEL !) PN */\n    else if((is_chsign(lp, 0) == is_chsign(lp, i)) && lp->duals[i])\n      lp->duals[i] = my_flipsign(lp->duals[i]);\n  }\n  if(is_maxim(lp)) {\n    n = lp->sum;\n    for(i = lp->rows + 1; i <= n; i++)\n      lp->duals[i] = my_flipsign(lp->duals[i]);\n  }\n\n  /* If we presolved, then reconstruct the duals */\n  n = lp->presolve_undo->orig_sum;\n  if(((lp->do_presolve & PRESOLVE_LASTMASKMODE) != PRESOLVE_NONE) &&\n      allocREAL(lp, &(lp->full_duals), n + 1, TRUE)) {\n    int ix, ii = lp->presolve_undo->orig_rows;\n\n    n = lp->sum;\n    for(ix = 1; ix <= n; ix++) {\n      i = lp->presolve_undo->var_to_orig[ix];\n      if(ix > lp->rows)\n        i += ii;\n#ifdef Paranoia\n      /* Check for index out of range due to presolve */\n      if(i > lp->presolve_undo->orig_sum)\n        report(lp, SEVERE, \"construct_duals: Invalid presolve variable mapping found\\n\");\n#endif\n      lp->full_duals[i] = lp->duals[ix];\n    }\n    presolve_rebuildUndo(lp, FALSE);\n  }\n\n  /* Calculate the dual OF and do scaling adjustments to the duals */\n  if(lp->scaling_used)\n    scale0 = lp->scalars[0];\n  else\n    scale0 = 1;\n  dualOF = my_chsign(is_maxim(lp), lp->orig_rhs[0]) / scale0;\n  for(i = 1; i <= lp->sum; i++) {\n    value = scaled_value(lp, lp->duals[i] / scale0, i);\n    my_roundzero(value, lp->epsprimal);\n    lp->duals[i] = value;\n    if(i <= lp->rows)\n      dualOF += value * lp->solution[i];\n  }\n\n#if 0\n  /* See if we can make use of the dual OF;\n     note that we do not currently adjust properly for presolve */\n  if(lp->rows == lp->presolve_undo->orig_rows)\n  if(MIP_count(lp) > 0) {\n    if(is_maxim(lp)) {\n      SETMIN(lp->bb_limitOF, dualOF);\n    }\n    else {\n      SETMAX(lp->bb_limitOF, dualOF);\n    }\n  }\n  else if(fabs(my_reldiff(dualOF, lp->solution[0])) > lp->epssolution)\n    report(lp, IMPORTANT, \"calculate_duals: Check for possible suboptimal solution!\\n\");\n#endif\n\n  return(TRUE);\n} /* construct_duals */\n\n/* Calculate sensitivity duals */\nSTATIC MYBOOL construct_sensitivity_duals(lprec *lp)\n{\n  int  k,varnr, ok = TRUE;\n  int  *workINT = NULL;\n  REAL *pcol,a,infinite,epsvalue,from,till,objfromvalue;\n\n  /* one column of the matrix */\n  FREE(lp->objfromvalue);\n  FREE(lp->dualsfrom);\n  FREE(lp->dualstill);\n  if(!allocREAL(lp, &pcol, lp->rows + 1, TRUE) ||\n     !allocREAL(lp, &lp->objfromvalue, lp->columns + 1, AUTOMATIC) ||\n     !allocREAL(lp, &lp->dualsfrom, lp->sum + 1, AUTOMATIC) ||\n     !allocREAL(lp, &lp->dualstill, lp->sum + 1, AUTOMATIC)) {\n    FREE(pcol);\n    FREE(lp->objfromvalue);\n    FREE(lp->dualsfrom);\n    FREE(lp->dualstill);\n    ok = FALSE;\n  }\n  else {\n    infinite=lp->infinite;\n    epsvalue=lp->epsmachine;\n    for(varnr=1; varnr<=lp->sum; varnr++) {\n      from=infinite;\n      till=infinite;\n      objfromvalue=infinite;\n      if (!lp->is_basic[varnr]) {\n        if (!fsolve(lp, varnr, pcol, workINT, epsvalue, 1.0, FALSE)) {  /* construct one column of the tableau */\n          ok = FALSE;\n          break;\n        }\n        /* Search for the rows(s) which first result in further iterations */\n        for (k=1; k<=lp->rows; k++) {\n          if (fabs(pcol[k])>epsvalue) {\n            a = unscaled_value(lp, lp->rhs[k]/pcol[k], varnr);\n            if((varnr > lp->rows) && (fabs(lp->solution[varnr]) <= epsvalue) && (a < objfromvalue) && (a >= lp->lowbo[varnr]))\n              objfromvalue = a;\n            if ((a<=0.0) && (pcol[k]<0.0) && (-a<from)) from=my_flipsign(a);\n            if ((a>=0.0) && (pcol[k]>0.0) && ( a<till)) till= a;\n            if (lp->upbo[lp->var_basic[k]] < infinite) {\n              a = (REAL) ((lp->rhs[k]-lp->upbo[lp->var_basic[k]])/pcol[k]);\n              a = unscaled_value(lp, a, varnr);\n              if((varnr > lp->rows) && (fabs(lp->solution[varnr]) <= epsvalue) && (a < objfromvalue) && (a >= lp->lowbo[varnr]))\n                objfromvalue = a;\n              if ((a<=0.0) && (pcol[k]>0.0) && (-a<from)) from=my_flipsign(a);\n              if ((a>=0.0) && (pcol[k]<0.0) && ( a<till)) till= a;\n            }\n          }\n        }\n\n        if (!lp->is_lower[varnr]) {\n          a=from;\n          from=till;\n          till=a;\n        }\n        if ((varnr<=lp->rows) && (!is_chsign(lp, varnr))) {\n          a=from;\n          from=till;\n          till=a;\n        }\n      }\n\n      if (from!=infinite)\n        lp->dualsfrom[varnr]=lp->solution[varnr]-from;\n      else\n        lp->dualsfrom[varnr]=-infinite;\n      if (till!=infinite)\n        lp->dualstill[varnr]=lp->solution[varnr]+till;\n      else\n        lp->dualstill[varnr]=infinite;\n\n      if (varnr > lp->rows) {\n        if (objfromvalue != infinite) {\n          if (!lp->is_lower[varnr])\n            objfromvalue = lp->upbo[varnr] - objfromvalue;\n          if ((lp->upbo[varnr] < infinite) && (objfromvalue > lp->upbo[varnr]))\n            objfromvalue = lp->upbo[varnr];\n          objfromvalue += lp->lowbo[varnr];\n        }\n        else\n          objfromvalue = -infinite;\n        lp->objfromvalue[varnr - lp->rows] = objfromvalue;\n      }\n\n    }\n    FREE(pcol);\n  }\n  return((MYBOOL) ok);\n} /* construct_sensitivity_duals */\n\n/* Calculate sensitivity objective function */\nSTATIC MYBOOL construct_sensitivity_obj(lprec *lp)\n{\n  int  i, l, varnr, row_nr, ok = TRUE;\n  REAL *OrigObj = NULL, *drow = NULL, *prow = NULL,\n       sign, a, min1, min2, infinite, epsvalue, from, till;\n\n  /* objective function */\n  FREE(lp->objfrom);\n  FREE(lp->objtill);\n  if(!allocREAL(lp, &drow, lp->sum + 1, TRUE) ||\n     !allocREAL(lp, &OrigObj, lp->columns + 1, FALSE) ||\n     !allocREAL(lp, &prow, lp->sum + 1, TRUE) ||\n     !allocREAL(lp, &lp->objfrom, lp->columns + 1, AUTOMATIC) ||\n     !allocREAL(lp, &lp->objtill, lp->columns + 1, AUTOMATIC)) {\nAbandon:\n    FREE(drow);\n    FREE(OrigObj);\n    FREE(prow);\n    FREE(lp->objfrom);\n    FREE(lp->objtill);\n    ok = FALSE;\n  }\n  else {\n    int *coltarget;\n\n    infinite=lp->infinite;\n    epsvalue=lp->epsmachine;\n\n    coltarget = (int *) mempool_obtainVector(lp->workarrays, lp->columns+1, sizeof(*coltarget));\n    if(!get_colIndexA(lp, SCAN_USERVARS+USE_NONBASICVARS, coltarget, FALSE)) {\n      mempool_releaseVector(lp->workarrays, (char *) coltarget, FALSE);\n      goto Abandon;\n    }\n    bsolve(lp, 0, drow, NULL, epsvalue*DOUBLEROUND, 1.0);\n    prod_xA(lp, coltarget, drow, NULL, epsvalue, 1.0,\n                           drow, NULL, MAT_ROUNDDEFAULT | MAT_ROUNDRC);\n\n    /* original (unscaled) objective function */\n    get_row(lp, 0, OrigObj);\n    for(i = 1; i <= lp->columns; i++) {\n      from=-infinite;\n      till= infinite;\n      varnr = lp->rows + i;\n      if(!lp->is_basic[varnr]) {\n      /* only the coeff of the objective function of column i changes. */\n        a = unscaled_mat(lp, drow[varnr], 0, i);\n        if(is_maxim(lp))\n          a = -a;\n        if (lp->upbo[varnr] == 0.0)\n          /* ignore, because this case doesn't results in further iterations */ ;\n        else if((lp->is_lower[varnr] != 0) == (is_maxim(lp) == FALSE))\n          from = OrigObj[i] - a; /* less than this value gives further iterations */\n        else\n          till = OrigObj[i] - a; /* bigger than this value gives further iterations */\n      }\n      else {\n      /* all the coeff of the objective function change. Search the minimal change needed for further iterations */\n        for(row_nr=1;\n            (row_nr<=lp->rows) && (lp->var_basic[row_nr]!=varnr); row_nr++)\n          /* Search on which row the variable exists in the basis */ ;\n        if(row_nr<=lp->rows) {       /* safety test; should always be found ... */\n          /* Construct one row of the tableau */\n          bsolve(lp, row_nr, prow, NULL, epsvalue*DOUBLEROUND, 1.0);\n          prod_xA(lp, coltarget, prow, NULL, epsvalue, 1.0,\n                                 prow, NULL, MAT_ROUNDDEFAULT);\n          /* sign = my_chsign(is_chsign(lp, row_nr), -1); */\n          sign = my_chsign(lp->is_lower[row_nr], -1);\n          min1=infinite;\n          min2=infinite;\n          for(l=1; l<=lp->sum; l++)   /* search for the column(s) which first results in further iterations */\n            if ((!lp->is_basic[l]) && (lp->upbo[l]>0.0) &&\n                (fabs(prow[l])>epsvalue) && (drow[l]*(lp->is_lower[l] ? -1 : 1)<epsvalue)) {\n              a = unscaled_mat(lp, fabs(drow[l] / prow[l]), 0, i);\n              if(prow[l]*sign*(lp->is_lower[l] ? 1 : -1) < 0.0) {\n                if(a < min1)\n                  min1 = a;\n              }\n              else {\n                if(a < min2)\n                  min2 = a;\n              }\n            }\n          if ((lp->is_lower[varnr] == 0) == (is_maxim(lp) == FALSE)) {\n            a = min1;\n            min1 = min2;\n            min2 = a;\n          }\n          if (min1<infinite)\n            from = OrigObj[i]-min1;\n          if (min2<infinite)\n            till = OrigObj[i]+min2;\n          a = lp->solution[varnr];\n          if (is_maxim(lp)) {\n            if (a - lp->lowbo[varnr] < epsvalue)\n              from = -infinite; /* if variable is at lower bound then decrementing objective coefficient will not result in extra iterations because it would only extra decrease the value, but since it is at its lower bound ... */\n            else if (lp->lowbo[varnr] + lp->upbo[varnr] - a < epsvalue)\n              till = infinite;  /* if variable is at upper bound then incrementing objective coefficient will not result in extra iterations because it would only extra increase the value, but since it is at its upper bound ... */\n          }\n          else {\n            if (a - lp->lowbo[varnr] < epsvalue)\n              till = infinite;  /* if variable is at lower bound then incrementing objective coefficient will not result in extra iterations because it would only extra decrease the value, but since it is at its lower bound ... */\n            else if (lp->lowbo[varnr] + lp->upbo[varnr] - a < epsvalue)\n              from = -infinite; /* if variable is at upper bound then decrementing objective coefficient will not result in extra iterations because it would only extra increase the value, but since it is at its upper bound ... */\n          }\n        }\n      }\n      lp->objfrom[i]=from;\n      lp->objtill[i]=till;\n    }\n    mempool_releaseVector(lp->workarrays, (char *) coltarget, FALSE);\n  }\n  FREE(prow);\n  FREE(OrigObj);\n  FREE(drow);\n\n  return((MYBOOL) ok);\n} /* construct_sensitivity_obj */\n\nSTATIC MYBOOL refactRecent(lprec *lp)\n{\n  int pivcount = lp->bfp_pivotcount(lp);\n  if(pivcount == 0)\n    return( AUTOMATIC );\n  else if (pivcount < 2*DEF_MAXPIVOTRETRY)\n    return( TRUE );\n  else\n    return( FALSE );\n}\n\nSTATIC MYBOOL check_if_less(lprec *lp, REAL x, REAL y, int variable)\n{\n  if(y < x-scaled_value(lp, lp->epsint, variable)) {\n    if(lp->bb_trace)\n      report(lp, NORMAL, \"check_if_less: Invalid new bound %g should be < %g for %s\\n\",\n                         x, y, get_col_name(lp, variable));\n    return(FALSE);\n  }\n  else\n    return(TRUE);\n}\n\n/* Various basis utility routines */\n\nSTATIC int findNonBasicSlack(lprec *lp, MYBOOL *is_basic)\n{\n  int i;\n\n  for(i = lp->rows; i > 0; i--)\n    if(!is_basic[i])\n      break;\n  return( i );\n}\n\nSTATIC int findBasisPos(lprec *lp, int notint, int *var_basic)\n{\n  int i;\n\n  if(var_basic == NULL)\n    var_basic = lp->var_basic;\n  for(i = lp->rows; i > 0; i--)\n    if(var_basic[i] == notint)\n      break;\n  return( i );\n}\n\nSTATIC void replaceBasisVar(lprec *lp, int rownr, int var, int *var_basic, MYBOOL *is_basic)\n{\n  int out;\n\n  out = var_basic[rownr];\n  var_basic[rownr] = var;\n  is_basic[out] = FALSE;\n  is_basic[var] = TRUE;\n}\n\nSTATIC void free_duals(lprec *lp)\n{\n  FREE(lp->duals);\n  FREE(lp->full_duals);\n  FREE(lp->dualsfrom);\n  FREE(lp->dualstill);\n  FREE(lp->objfromvalue);\n  FREE(lp->objfrom);\n  FREE(lp->objtill);\n}\n\n/* Transform RHS by adjusting for the bound state of variables;\n   optionally rebase upper bound, and account for this in later calls */\nSTATIC void initialize_solution(lprec *lp, MYBOOL shiftbounds)\n{\n  int     i, k1, k2, *matRownr, colnr;\n  LREAL   theta;\n  REAL    value, *matValue, loB, upB;\n  MATrec  *mat = lp->matA;\n\n  /* Set bounding status indicators */\n  if(lp->bb_bounds != NULL) {\n    if(shiftbounds == INITSOL_SHIFTZERO) {\n      if(lp->bb_bounds->UBzerobased)\n        report(lp, SEVERE, \"initialize_solution: The upper bounds are already zero-based at refactorization %d\\n\",\n                           lp->bfp_refactcount(lp, BFP_STAT_REFACT_TOTAL));\n      lp->bb_bounds->UBzerobased = TRUE;\n    }\n    else if(!lp->bb_bounds->UBzerobased)\n        report(lp, SEVERE, \"initialize_solution: The upper bounds are not zero-based at refactorization %d\\n\",\n                           lp->bfp_refactcount(lp, BFP_STAT_REFACT_TOTAL));\n  }\n\n  /* Initialize the working RHS/basic variable solution vector */\n  i = is_action(lp->anti_degen, ANTIDEGEN_RHSPERTURB) && (lp->monitor != NULL) && lp->monitor->active;\n  if(sizeof(*lp->rhs) == sizeof(*lp->orig_rhs) && !i) {\n    MEMCOPY(lp->rhs, lp->orig_rhs, lp->rows+1);\n  }\n  else if(i) {\n    lp->rhs[0] = lp->orig_rhs[0];\n    for(i = 1; i <= lp->rows; i++) {\n      if(is_constr_type(lp, i, EQ))\n        theta = rand_uniform(lp, lp->epsvalue);\n      else {\n        theta = rand_uniform(lp, lp->epsperturb);\n/*        if(lp->orig_upbo[i] < lp->infinite)\n          lp->orig_upbo[i] += theta; */\n      }\n      lp->rhs[i] = lp->orig_rhs[i] + theta;\n    }\n  }\n  else\n    for(i = 0; i <= lp->rows; i++)\n      lp->rhs[i] = lp->orig_rhs[i];\n\n/* Adjust active RHS for variables at their active upper/lower bounds */\n  for(i = 1; i <= lp->sum; i++) {\n\n    upB = lp->upbo[i];\n    loB = lp->lowbo[i];\n\n    /* Shift to \"ranged\" upper bound, tantamount to defining zero-based variables */\n    if(shiftbounds == INITSOL_SHIFTZERO) {\n      if((loB > -lp->infinite) && (upB < lp->infinite))\n        lp->upbo[i] -= loB;\n      if(lp->upbo[i] < 0)\n        report(lp, SEVERE, \"initialize_solution: Invalid rebounding; variable %d at refact %d, iter %.0f\\n\",\n                           i, lp->bfp_refactcount(lp, BFP_STAT_REFACT_TOTAL), (double) get_total_iter(lp));\n    }\n\n    /* Use \"ranged\" upper bounds */\n    else if(shiftbounds == INITSOL_USEZERO) {\n      if((loB > -lp->infinite) && (upB < lp->infinite))\n        upB += loB;\n    }\n\n    /* Shift upper bound back to original value */\n    else if(shiftbounds == INITSOL_ORIGINAL) {\n      if((loB > -lp->infinite) && (upB < lp->infinite)) {\n        lp->upbo[i] += loB;\n        upB += loB;\n      }\n      continue;\n    }\n    else\n      report(lp, SEVERE, \"initialize_solution: Invalid option value '%d'\\n\",\n                         shiftbounds);\n\n    /* Set the applicable adjustment */\n    if(lp->is_lower[i])\n      theta = loB;\n    else\n      theta = upB;\n\n\n    /* Check if we need to pass through the matrix;\n       remember that basis variables are always lower-bounded */\n    if(theta == 0)\n      continue;\n\n    /* Do user and artificial variables */\n    if(i > lp->rows) {\n\n      /* Get starting and ending indeces in the NZ vector */\n      colnr = i - lp->rows;\n      k1 = mat->col_end[colnr - 1];\n      k2 = mat->col_end[colnr];\n      matRownr = &COL_MAT_ROWNR(k1);\n      matValue = &COL_MAT_VALUE(k1);\n\n      /* Get the objective as row 0, optionally adjusting the objective for phase 1 */\n      value = get_OF_active(lp, i, theta);\n      lp->rhs[0] -= value;\n\n      /* Do the normal case */\n      for(; k1 < k2;\n          k1++, matRownr += matRowColStep, matValue += matValueStep) {\n        lp->rhs[*matRownr] -= theta * (*matValue);\n      }\n    }\n\n    /* Do slack variables (constraint \"bounds\")*/\n    else {\n      lp->rhs[i] -= theta;\n    }\n\n  }\n\n  /* Do final pass to get the maximum value */\n  i = idamaxlpsolve(lp->rows+1, lp->rhs, 1);\n  lp->rhsmax = fabs(lp->rhs[i]);\n\n  if(shiftbounds == INITSOL_SHIFTZERO)\n    clear_action(&lp->spx_action, ACTION_REBASE);\n\n}\n\n/* This routine recomputes the basic variables using the full inverse */\nSTATIC void recompute_solution(lprec *lp, MYBOOL shiftbounds)\n{\n  /* Compute RHS = b - A(n)*x(n) */\n  initialize_solution(lp, shiftbounds);\n\n  /* Compute x(b) = Inv(B)*RHS (Ref. lp_solve inverse logic and Chvatal p. 121) */\n  lp->bfp_ftran_normal(lp, lp->rhs, NULL);\n  if(!lp->obj_in_basis) {\n    int i, ib, n = lp->rows;\n    for(i = 1; i <= n; i++) {\n      ib = lp->var_basic[i];\n      if(ib > n)\n        lp->rhs[0] -= get_OF_active(lp, ib, lp->rhs[i]);\n    }\n  }\n\n /* Round the values (should not be greater than the factor used in bfp_pivotRHS) */\n  roundVector(lp->rhs, lp->rows, lp->epsvalue);\n\n  clear_action(&lp->spx_action, ACTION_RECOMPUTE);\n}\n\n/* This routine compares an existing basic solution to a recomputed one;\n   Note that the routine must provide for the possibility that the order of the\n   basis variables can be changed by the inversion engine. */\nSTATIC int verify_solution(lprec *lp, MYBOOL reinvert, char *info)\n{\n  int  i, ii, n, *oldmap, *newmap, *refmap = NULL;\n  REAL *oldrhs, err, errmax;\n\n  allocINT(lp, &oldmap, lp->rows+1, FALSE);\n  allocINT(lp, &newmap, lp->rows+1, FALSE);\n  allocREAL(lp, &oldrhs, lp->rows+1, FALSE);\n\n  /* Get sorted mapping of the old basis */\n  for(i = 0; i <= lp->rows; i++)\n    oldmap[i] = i;\n  if(reinvert) {\n    allocINT(lp, &refmap, lp->rows+1, FALSE);\n    MEMCOPY(refmap, lp->var_basic, lp->rows+1);\n    sortByINT(oldmap, refmap, lp->rows, 1, TRUE);\n  }\n\n  /* Save old and calculate the new RHS vector */\n  MEMCOPY(oldrhs, lp->rhs, lp->rows+1);\n  if(reinvert)\n    invert(lp, INITSOL_USEZERO, FALSE);\n  else\n    recompute_solution(lp, INITSOL_USEZERO);\n\n  /* Get sorted mapping of the new basis */\n  for(i = 0; i <= lp->rows; i++)\n    newmap[i] = i;\n  if(reinvert) {\n    MEMCOPY(refmap, lp->var_basic, lp->rows+1);\n    sortByINT(newmap, refmap, lp->rows, 1, TRUE);\n  }\n\n  /* Identify any gap */\n  errmax = 0;\n  ii = -1;\n  n = 0;\n  for(i = lp->rows; i > 0; i--) {\n    err = fabs(my_reldiff(oldrhs[oldmap[i]], lp->rhs[newmap[i]]));\n    if(err > lp->epsprimal) {\n      n++;\n      if(err > errmax) {\n        ii = i;\n        errmax = err;\n      }\n    }\n  }\n  err = fabs(my_reldiff(oldrhs[i], lp->rhs[i]));\n  if(err < lp->epspivot) {\n    i--;\n    err = 0;\n  }\n  else {\n    n++;\n    if(ii < 0) {\n      ii = 0;\n      errmax = err;\n    }\n  }\n  if(n > 0) {\n    report(lp, IMPORTANT, \"verify_solution: Iter %.0f %s - %d errors; OF %g, Max @row %d %g\\n\",\n                           (double) get_total_iter(lp), my_if(info == NULL, \"\", info), n, err, newmap[ii], errmax);\n  }\n  /* Copy old results back (not possible for inversion) */\n  if(!reinvert)\n    MEMCOPY(lp->rhs, oldrhs, lp->rows+1);\n\n  FREE(oldmap);\n  FREE(newmap);\n  FREE(oldrhs);\n  if(reinvert)\n    FREE(refmap);\n\n  return( ii );\n\n}\n\n/* Preprocessing and postprocessing functions */\nSTATIC int identify_GUB(lprec *lp, MYBOOL mark)\n{\n  int    i, j, jb, je, k, knint, srh;\n  REAL   rh, mv, tv, bv;\n  MATrec *mat = lp->matA;\n\n  if((lp->equalities == 0) || !mat_validate(mat))\n    return( 0 );\n\n  k = 0;\n  for(i = 1; i <= lp->rows; i++) {\n\n    /* Check if it is an equality constraint */\n    if(!is_constr_type(lp, i, EQ))\n      continue;\n\n    rh = get_rh(lp, i);\n    srh = my_sign(rh);\n    knint = 0;\n    je = mat->row_end[i];\n    for(jb = mat->row_end[i-1]; jb < je; jb++) {\n      j = ROW_MAT_COLNR(jb);\n\n      /* Check for validity of the equation elements */\n      if(!is_int(lp, j))\n        knint++;\n      if(knint > 1)\n        break;\n\n      mv = get_mat_byindex(lp, jb, TRUE, FALSE);\n      if(fabs(my_reldiff(mv, rh)) > lp->epsprimal)\n        break;\n\n      tv = mv*get_upbo(lp, j);\n      bv = get_lowbo(lp, j);\n#if 0 /* Requires 1 as upper bound */\n      if((fabs(my_reldiff(tv, rh)) > lp->epsprimal) || (bv != 0))\n#else /* Can handle any upper bound >= 1 */\n      if((srh*(tv-rh) < -lp->epsprimal) || (bv != 0))\n#endif\n        break;\n    }\n\n    /* Update GUB count and optionally mark the GUB */\n    if(jb == je) {\n      k++;\n      if(mark == TRUE)\n        lp->row_type[i] |= ROWTYPE_GUB;\n      else if(mark == AUTOMATIC)\n        break;\n    }\n\n  }\n  return( k );\n}\n\nSTATIC int prepare_GUB(lprec *lp)\n{\n  int    i, j, jb, je, k, *members = NULL;\n  REAL   rh;\n  char   GUBname[16];\n  MATrec *mat = lp->matA;\n\n  if((lp->equalities == 0) ||\n     !allocINT(lp, &members, lp->columns+1, TRUE) ||\n     !mat_validate(mat))\n    return( 0 );\n\n  for(i = 1; i <= lp->rows; i++) {\n\n    /* Check if it has been marked as a GUB */\n    if(!(lp->row_type[i] & ROWTYPE_GUB))\n      continue;\n\n    /* Pick up the GUB column indeces */\n    k = 0;\n    je = mat->row_end[i];\n    for(jb = mat->row_end[i-1], k = 0; jb < je; jb++) {\n      members[k] = ROW_MAT_COLNR(jb);\n      k++;\n    }\n\n    /* Add the GUB */\n    j = GUB_count(lp) + 1;\n    sprintf(GUBname, \"GUB_%d\", i);\n    add_GUB(lp, GUBname, j, k, members);\n\n    /* Unmark the GUBs */\n    clear_action(&(lp->row_type[i]), ROWTYPE_GUB);\n\n    /* Standardize coefficients to 1 if necessary */\n    rh = get_rh(lp, i);\n    if(fabs(my_reldiff(rh, 1)) > lp->epsprimal) {\n      set_rh(lp, i, 1);\n      for(jb = mat->row_end[i-1]; jb < je; jb++) {\n        j = ROW_MAT_COLNR(jb);\n        set_mat(lp, i,j, 1);\n      }\n    }\n\n  }\n  FREE(members);\n  return(GUB_count(lp));\n}\n\n/* Pre- and post processing functions, i.a. splitting free variables */\nSTATIC MYBOOL pre_MIPOBJ(lprec *lp)\n{\n#ifdef MIPboundWithOF\n  if(MIP_count(lp) > 0) {\n    int i = 1;\n    while((i <= lp->rows) && !mat_equalRows(lp->matA, 0, i) && !is_constr_type(lp, i, EQ))\n      i++;\n    if(i <= lp->rows)\n      lp->constraintOF = i;\n  }\n#endif\n  lp->bb_deltaOF = MIP_stepOF(lp);\n  return( TRUE );\n}\nSTATIC MYBOOL post_MIPOBJ(lprec *lp)\n{\n#ifdef MIPboundWithOF\n/*\n  if(lp->constraintOF) {\n    del_constraint(lp, lp->rows);\n    if(is_BasisReady(lp) && !verify_basis(lp))\n      return( FALSE );\n  }\n*/\n#endif\n  return( TRUE );\n}\n\nint preprocess(lprec *lp)\n{\n  int    i, j, k, ok = TRUE, *new_index = NULL;\n  REAL   hold, *new_column = NULL;\n  MYBOOL scaled, primal1, primal2;\n\n /* do not process if already preprocessed */\n  if(lp->wasPreprocessed)\n    return( ok );\n\n  /* Write model statistics and optionally initialize partial pricing structures */\n  if(lp->lag_status != RUNNING) {\n    MYBOOL doPP;\n\n    /* Extract the user-specified simplex strategy choices */\n    primal1 = (MYBOOL) (lp->simplex_strategy & SIMPLEX_Phase1_PRIMAL);\n    primal2 = (MYBOOL) (lp->simplex_strategy & SIMPLEX_Phase2_PRIMAL);\n\n    /* Initialize partial pricing structures */\n    doPP = is_piv_mode(lp, PRICE_PARTIAL | PRICE_AUTOPARTIAL);\n/*    doPP &= (MYBOOL) (lp->columns / 2 > lp->rows); */\n    if(doPP) {\n      i = partial_findBlocks(lp, FALSE, FALSE);\n      if(i < 4)\n        i = (int) (5 * log((REAL) lp->columns / lp->rows));\n      report(lp, NORMAL, \"The model is %s to have %d column blocks/stages.\\n\",\n                         (i > 1 ? \"estimated\" : \"set\"), i);\n      set_partialprice(lp, i, NULL, FALSE);\n    }\n/*    doPP &= (MYBOOL) (lp->rows / 4 > lp->columns); */\n    if(doPP) {\n      i = partial_findBlocks(lp, FALSE, TRUE);\n      if(i < 4)\n        i = (int) (5 * log((REAL) lp->rows / lp->columns));\n      report(lp, NORMAL, \"The model is %s to have %d row blocks/stages.\\n\",\n                         (i > 1 ? \"estimated\" : \"set\"), i);\n      set_partialprice(lp, i, NULL, TRUE);\n    }\n\n    /* Check for presence of valid pricing blocks if partial pricing\n      is defined, but not autopartial is not set */\n    if(!doPP && is_piv_mode(lp, PRICE_PARTIAL)) {\n      if((lp->rowblocks == NULL) || (lp->colblocks == NULL)) {\n        report(lp, IMPORTANT, \"Ignoring partial pricing, since block structures are not defined.\\n\");\n        clear_action(&lp->piv_strategy, PRICE_PARTIAL);\n      }\n    }\n\n    /* Initialize multiple pricing block divisor */\n#if 0\n    if(primal1 || primal2)\n      lp->piv_strategy |= PRICE_MULTIPLE | PRICE_AUTOMULTIPLE;\n#endif\n    if(is_piv_mode(lp, PRICE_MULTIPLE) && (primal1 || primal2)) {\n      doPP = is_piv_mode(lp, PRICE_AUTOMULTIPLE);\n      if(doPP) {\n        i = (int) (2.5*log((REAL) lp->sum));\n        SETMAX( i, 1);\n        set_multiprice(lp, i);\n      }\n      if(lp->multiblockdiv > 1)\n      report(lp, NORMAL, \"Using %d-candidate primal simplex multiple pricing block.\\n\",\n                          lp->columns / lp->multiblockdiv);\n    }\n    else\n      set_multiprice(lp, 1);\n\n    report(lp, NORMAL, \"Using %s simplex for phase 1 and %s simplex for phase 2.\\n\",\n                       my_if(primal1, \"PRIMAL\", \"DUAL\"), my_if(primal2, \"PRIMAL\", \"DUAL\"));\n    i = get_piv_rule(lp);\n    if((i == PRICER_STEEPESTEDGE) && is_piv_mode(lp, PRICE_PRIMALFALLBACK))\n      report(lp, NORMAL, \"The pricing strategy is set to '%s' for the dual and '%s' for the primal.\\n\",\n                       get_str_piv_rule(i), get_str_piv_rule(i-1));\n    else\n      report(lp, NORMAL, \"The primal and dual simplex pricing strategy set to '%s'.\\n\",\n                       get_str_piv_rule(i));\n\n    report(lp, NORMAL, \" \\n\");\n  }\n\n  /* Compute a minimum step improvement step requirement */\n  pre_MIPOBJ(lp);\n\n /* First create extra columns for FR variables or flip MI variables */\n  for (j = 1; j <= lp->columns; j++) {\n\n#ifdef Paranoia\n    if((lp->rows != lp->matA->rows) || (lp->columns != lp->matA->columns))\n      report(lp, SEVERE, \"preprocess: Inconsistent variable counts found\\n\");\n#endif\n\n   /* First handle sign-flipping of variables:\n       1) ... with a finite upper bound and a negative Inf-bound (since basis variables are lower-bounded)\n       2) ... with bound assymetry within negrange limits (for stability reasons) */\n    i = lp->rows + j;\n    hold = lp->orig_upbo[i];\n/*\n    if((hold <= 0) || (!is_infinite(lp, lp->negrange) &&\n                       (hold < -lp->negrange) &&\n                       (lp->orig_lowbo[i] <= lp->negrange)) ) {\n*/\n#define fullybounded FALSE\n    if( ((hold < lp->infinite) && my_infinite(lp, lp->orig_lowbo[i])) ||\n        (!fullybounded && !my_infinite(lp, lp->negrange) &&\n         (hold < -lp->negrange) && (lp->orig_lowbo[i] <= lp->negrange)) ) {\n      /* Delete split sibling variable if one existed from before */\n      if((lp->var_is_free != NULL) && (lp->var_is_free[j] > 0))\n        del_column(lp, lp->var_is_free[j]);\n      /* Negate the column / flip to the positive range */\n      mat_multcol(lp->matA, j, -1);\n      if(lp->var_is_free == NULL) {\n        if(!allocINT(lp, &lp->var_is_free, MAX(lp->columns, lp->columns_alloc) + 1, TRUE))\n          return(FALSE);\n      }\n      lp->var_is_free[j] = -j; /* Indicator UB and LB are switched, with no helper variable added */\n      lp->orig_upbo[i] = my_flipsign(lp->orig_lowbo[i]);\n      lp->orig_lowbo[i] = my_flipsign(hold);\n      /* Check for presence of negative ranged SC variable */\n      if(lp->sc_lobound[j] > 0) {\n        lp->sc_lobound[j] = lp->orig_lowbo[i];\n        lp->orig_lowbo[i] = 0;\n      }\n    }\n   /* Then deal with -+, full-range/FREE variables by creating a helper variable */\n    else if((lp->orig_lowbo[i] <= lp->negrange) && (hold >= -lp->negrange)) {\n      if(lp->var_is_free == NULL) {\n        if(!allocINT(lp, &lp->var_is_free, MAX(lp->columns,lp->columns_alloc) + 1, TRUE))\n          return(FALSE);\n      }\n      if(lp->var_is_free[j] <= 0) { /* If this variable wasn't split yet ... */\n        if(SOS_is_member(lp->SOS, 0, i - lp->rows)) {   /* Added */\n          report(lp, IMPORTANT, \"preprocess: Converted negative bound for SOS variable %d to zero\",\n                                i - lp->rows);\n          lp->orig_lowbo[i] = 0;\n          continue;\n        }\n        if(new_column == NULL) {\n          if(!allocREAL(lp, &new_column, lp->rows + 1, FALSE) ||\n             !allocINT(lp, &new_index, lp->rows + 1, FALSE)) {\n            ok = FALSE;\n            break;\n          }\n        }\n       /* Avoid precision loss by turning off unscaling and rescaling */\n       /* in get_column and add_column operations; also make sure that */\n       /* full scaling information is preserved */\n        scaled = lp->scaling_used;\n        lp->scaling_used = FALSE;\n        k = get_columnex(lp, j, new_column, new_index);\n        if(!add_columnex(lp, k, new_column, new_index)) {\n          ok = FALSE;\n          break;\n        }\n        mat_multcol(lp->matA, lp->columns, -1);\n        if(scaled)\n          lp->scalars[lp->rows+lp->columns] = lp->scalars[i];\n        lp->scaling_used = (MYBOOL) scaled;\n        /* Only create name if we are not clearing a pre-used item, since this\n           variable could have been deleted by presolve but the name is required\n           for solution reconstruction. */\n        if(lp->names_used && (lp->col_name[j] == NULL)) {\n          char fieldn[50];\n\n          sprintf(fieldn, \"__AntiBodyOf(%d)__\", j);\n          if(!set_col_name(lp, lp->columns, fieldn)) {\n/*          if (!set_col_name(lp, lp->columns, get_col_name(lp, j))) { */\n            ok = FALSE;\n            break;\n          }\n        }\n        /* Set (positive) index to the original column's split / helper and back */\n        lp->var_is_free[j] = lp->columns;\n      }\n      lp->orig_upbo[lp->rows + lp->var_is_free[j]] = my_flipsign(lp->orig_lowbo[i]);\n      lp->orig_lowbo[i] = 0;\n\n      /* Negative index indicates x is split var and -var_is_free[x] is index of orig var */\n      lp->var_is_free[lp->var_is_free[j]] = -j;\n      lp->var_type[lp->var_is_free[j]] = lp->var_type[j];\n    }\n   /* Check for positive ranged SC variables */\n    else if(lp->sc_lobound[j] > 0) {\n      lp->sc_lobound[j] = lp->orig_lowbo[i];\n      lp->orig_lowbo[i] = 0;\n    }\n\n   /* Tally integer variables in SOS'es */\n    if(SOS_is_member(lp->SOS, 0, j) && is_int(lp, j))\n      lp->sos_ints++;\n  }\n\n  FREE(new_column);\n  FREE(new_index);\n\n  /* Fill lists of GUB constraints, if appropriate */\n  if((MIP_count(lp) > 0) && is_bb_mode(lp, NODE_GUBMODE) && (identify_GUB(lp, AUTOMATIC) > 0))\n    prepare_GUB(lp);\n\n  /* (Re)allocate reduced cost arrays */\n  ok = allocREAL(lp, &(lp->drow), lp->sum+1, AUTOMATIC) &&\n       allocINT(lp, &(lp->nzdrow), lp->sum+1, AUTOMATIC);\n  if(ok)\n    lp->nzdrow[0] = 0;\n\n  /* Minimize memory usage */\n  memopt_lp(lp, 0, 0, 0);\n\n  lp->wasPreprocessed = TRUE;\n\n  return(ok);\n}\n\nvoid postprocess(lprec *lp)\n{\n  int i,ii,j;\n  REAL hold;\n\n /* Check if the problem actually was preprocessed */\n  if(!lp->wasPreprocessed)\n    return;\n\n /* Must compute duals here in case we have free variables; note that in\n    this case sensitivity analysis is not possible unless done here */\n  if((MIP_count(lp) == 0) &&\n     (is_presolve(lp, PRESOLVE_DUALS) || (lp->var_is_free != NULL)))\n    construct_duals(lp);\n  if(is_presolve(lp, PRESOLVE_SENSDUALS)) {\n    if(!construct_sensitivity_duals(lp) || !construct_sensitivity_obj(lp))\n      report(lp, IMPORTANT, \"postprocess: Unable to allocate working memory for duals.\\n\");\n  }\n\n /* Loop over all columns */\n  for (j = 1; j <= lp->columns; j++) {\n    i = lp->rows + j;\n   /* Reconstruct strictly negative values */\n    if((lp->var_is_free != NULL) && (lp->var_is_free[j] < 0)) {\n      /* Check if we have the simple case where the UP and LB are negated and switched */\n      if(-lp->var_is_free[j] == j) {\n        mat_multcol(lp->matA, j, -1);\n        hold = lp->orig_upbo[i];\n        lp->orig_upbo[i] = my_flipsign(lp->orig_lowbo[i]);\n        lp->orig_lowbo[i] = my_flipsign(hold);\n        lp->best_solution[i] = my_flipsign(lp->best_solution[i]);\n        transfer_solution_var(lp, j);\n\n        /* hold = lp->objfrom[j];\n        lp->objfrom[j] = my_flipsign(lp->objtill[j]);\n        lp->objtill[j] = my_flipsign(hold); */ /* under investigation <peno> */\n\n        /* lp->duals[i] = my_flipsign(lp->duals[i]);\n        hold = lp->dualsfrom[i];\n        lp->dualsfrom[i] = my_flipsign(lp->dualstill[i]);\n        lp->dualstill[i] = my_flipsign(hold); */ /* under investigation <peno> */\n       /* Bound switch undone, so clear the status */\n        lp->var_is_free[j] = 0;\n       /* Adjust negative ranged SC */\n        if(lp->sc_lobound[j] > 0)\n          lp->orig_lowbo[lp->rows + j] = -lp->sc_lobound[j];\n      }\n      /* Ignore the split / helper columns (will be deleted later) */\n    }\n   /* Condense values of extra columns of quasi-free variables split in two */\n    else if((lp->var_is_free != NULL) && (lp->var_is_free[j] > 0)) {\n      ii = lp->var_is_free[j]; /* Index of the split helper var */\n      /* if(lp->objfrom[j] == -lp->infinite)\n        lp->objfrom[j] = -lp->objtill[ii];\n      lp->objtill[ii] = lp->infinite;\n      if(lp->objtill[j] == lp->infinite)\n        lp->objtill[j] = my_flipsign(lp->objfrom[ii]);\n      lp->objfrom[ii] = -lp->infinite; */ /* under investigation <peno> */\n\n      ii += lp->rows;\n      lp->best_solution[i] -= lp->best_solution[ii]; /* join the solution again */\n      transfer_solution_var(lp, j);\n      lp->best_solution[ii] = 0;\n\n      /* if(lp->duals[i] == 0)\n        lp->duals[i] = my_flipsign(lp->duals[ii]);\n      lp->duals[ii] = 0;\n      if(lp->dualsfrom[i] == -lp->infinite)\n        lp->dualsfrom[i] = my_flipsign(lp->dualstill[ii]);\n      lp->dualstill[ii] = lp->infinite;\n      if(lp->dualstill[i] == lp->infinite)\n        lp->dualstill[i] = my_flipsign(lp->dualsfrom[ii]);\n      lp->dualsfrom[ii] = -lp->infinite; */ /* under investigation <peno> */\n\n      /* Reset to original bound */\n      lp->orig_lowbo[i] = my_flipsign(lp->orig_upbo[ii]);\n    }\n   /* Adjust for semi-continuous variables */\n    else if(lp->sc_lobound[j] > 0) {\n      lp->orig_lowbo[i] = lp->sc_lobound[j];\n    }\n  }\n\n  /* Remove any split column helper variables */\n  del_splitvars(lp);\n  post_MIPOBJ(lp);\n\n  /* Do extended reporting, if specified */\n  if(lp->verbose > NORMAL) {\n    REPORT_extended(lp);\n\n  }\n\n  lp->wasPreprocessed = FALSE;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-r-lpsolve-5.6.13.2-2p7y34czadwk3yceelxxk5stmkcgrmfe/spack-src/src/commonlib.h": "#ifndef HEADER_commonlib\n#define HEADER_commonlib\n\n#include <stdlib.h>\n#include <stdio.h>\n\n#define BIGNUMBER      1.0e+30\n#define TINYNUMBER     1.0e-04\n#define MACHINEPREC   2.22e-16\n#define MATHPREC       1.0e-16\n#define ERRLIMIT       1.0e-06\n\n#ifndef LINEARSEARCH\n  #define LINEARSEARCH 5\n#endif\n\n#if 0\n  #define INTEGERTIME\n#endif\n\n/* ************************************************************************ */\n/* Define loadable library function headers                                 */\n/* ************************************************************************ */\n#if (defined WIN32) || (defined WIN64)\n  #define my_LoadLibrary(name)              LoadLibrary(name)\n  #define my_GetProcAddress(handle, name)   GetProcAddress(handle, name)\n  #define my_FreeLibrary(handle)            FreeLibrary(handle); \\\n                                            handle = NULL\n#else\n  #define my_LoadLibrary(name)              dlopen(name, RTLD_LAZY)\n  #define my_GetProcAddress(handle, name)   dlsym(handle, name)\n  #define my_FreeLibrary(handle)            dlclose(handle); \\\n                                            handle = NULL\n#endif\n\n\n/* ************************************************************************ */\n/* Define sizes of standard number types                                    */\n/* ************************************************************************ */\n#ifndef LLONG\n  #if defined __BORLANDC__\n    #define LLONG __int64\n  #elif !defined _MSC_VER || _MSC_VER >= 1310\n    #define LLONG long long\n  #else\n    #define LLONG __int64\n  #endif\n#endif\n\n#ifndef MYBOOL\n  #if 0\n    #define MYBOOL unsigned int\n  #else\n    #define MYBOOL unsigned char\n  #endif\n#endif\n\n#ifndef REAL\n  #define REAL     double\n#endif\n#ifndef BLAS_prec\n  #define BLAS_prec \"d\" /* The BLAS precision prefix must correspond to the REAL type */\n#endif\n\n#ifndef REALXP\n  #if 1\n    #define REALXP long double  /* Set local accumulation variable as long double */\n  #else\n    #define REALXP REAL          /* Set local accumulation as default precision */\n  #endif\n#endif\n\n#ifndef my_boolstr\n  #define my_boolstr(x)          (!(x) ? \"FALSE\" : \"TRUE\")\n#endif\n\n#ifndef NULL\n  #define NULL \t       0\n#endif\n\n#ifndef FALSE\n  #define FALSE        0\n  #define TRUE         1\n#endif\n\n#ifndef DEF_STRBUFSIZE\n  #define DEF_STRBUFSIZE   512\n#endif\n#ifndef MAXINT32\n  #define MAXINT32  2147483647\n#endif\n#ifndef MAXUINT32\n  #define MAXUINT32 4294967295\n#endif\n\n#ifndef MAXINT64\n  #if defined _LONGLONG || defined __LONG_LONG_MAX__ || defined LLONG_MAX\n    #define MAXINT64   9223372036854775807ll\n  #else\n    #define MAXINT64   9223372036854775807l\n  #endif\n#endif\n#ifndef MAXUINT64\n  #if defined _LONGLONG || defined __LONG_LONG_MAX__ || defined LLONG_MAX\n    #define MAXUINT64 18446744073709551616ll\n  #else\n    #define MAXUINT64 18446744073709551616l\n  #endif\n#endif\n\n#ifndef DOFASTMATH\n  #define DOFASTMATH\n#endif\n\n\n#ifndef XCALLOC\n#define XCALLOC(ptr, nr)\\\n  if(!(ptr = calloc((size_t)(nr), sizeof(*ptr))) && nr) {\\\n    printf(\"calloc of %d bytes failed on line %d of file %s\\n\",\\\n           (size_t) nr * sizeof(*ptr), __LINE__, __FILE__);\\\n  }\n#endif\n\n#ifndef XMALLOC\n#define XMALLOC(ptr, nr)\\\n  if(!((void *) ptr = malloc((size_t)((size_t) (nr) * sizeof(*ptr)))) && nr) {\\\n    printf(\"malloc of %d bytes failed on line %d of file %s\\n\",\\\n           (size_t) nr * sizeof(*ptr), __LINE__, __FILE__);\\\n  }\n#endif\n\n#ifndef XREALLOC\n#define XREALLOC(ptr, nr)\\\n  if(!((void *) ptr = realloc(ptr, (size_t)((size_t) (nr) * sizeof(*ptr)))) && nr) {\\\n    printf(\"realloc of %d bytes failed on line %d of file %s\\n\",\\\n           (size_t) nr * sizeof(*ptr), __LINE__, __FILE__);\\\n  }\n#endif\n\n#ifndef FREE\n#define FREE(ptr)\\\n  if((void *) ptr != NULL) {\\\n    free(ptr);\\\n    ptr = NULL; \\\n  }\n#endif\n\n#ifndef MEMCOPY\n#define MEMCOPY(nptr, optr, nr)\\\n  memcpy((nptr), (optr), (size_t)((size_t)(nr) * sizeof(*(optr))))\n#endif\n\n#ifndef MEMMOVE\n#define MEMMOVE(nptr, optr, nr)\\\n  memmove((nptr), (optr), (size_t)((size_t)(nr) * sizeof(*(optr))))\n#endif\n\n#ifndef MEMALLOCCOPY\n#define MEMALLOCCOPY(nptr, optr, nr)\\\n  {MALLOC(nptr, (size_t)(nr));\\\n   MEMCOPY(nptr, optr, (size_t)(nr));}\n#endif\n\n#ifndef STRALLOCCOPY\n#define STRALLOCCOPY(nstr, ostr)\\\n  {nstr = (char *) malloc((size_t) (strlen(ostr) + 1));\\\n   strcpy(nstr, ostr);}\n#endif\n\n#ifndef MEMCLEAR\n/*#define useMMX*/\n#ifdef useMMX\n  #define MEMCLEAR(ptr, nr)\\\n    mem_set((ptr), '\\0', (size_t)((size_t)(nr) * sizeof(*(ptr))))\n#else\n  #define MEMCLEAR(ptr, nr)\\\n    memset((ptr), '\\0', (size_t)((size_t)(nr) * sizeof(*(ptr))))\n#endif\n#endif\n\n\n#define MIN(x, y)         ((x) < (y) ? (x) : (y))\n#define MAX(x, y)         ((x) > (y) ? (x) : (y))\n#define SETMIN(x, y)      if((x) > (y)) x = y\n#define SETMAX(x, y)      if((x) < (y)) x = y\n#define LIMIT(lo, x, hi)  ((x < (lo) ? lo : ((x) > hi ? hi : x)))\n#define BETWEEN(x, a, b)  (MYBOOL) (((x)-(a)) * ((x)-(b)) <= 0)\n#define IF(t, x, y)       ((t) ? (x) : (y))\n#define SIGN(x)           ((x) < 0 ? -1 : 1)\n\n#define DELTA_SIZE(newSize, oldSize) ((int) ((newSize) * MIN(1.33, pow(1.5, fabs((double)newSize)/((oldSize+newSize)+1)))))\n\n#ifndef CMP_CALLMODEL\n#if (defined WIN32) || (defined WIN64)\n  #define CMP_CALLMODEL _cdecl\n#else\n  #define CMP_CALLMODEL\n#endif\n#endif\n\ntypedef int (CMP_CALLMODEL findCompare_func)(const void *current, const void *candidate);\n#define CMP_COMPARE(current, candidate) ( current < candidate ? -1 : (current > candidate ? 1 : 0) )\n#define CMP_ATTRIBUTES(item)            (((char *) attributes)+(item)*recsize)\n\n\n#ifndef UNIONTYPE\n  #ifdef __cplusplus\n    #define UNIONTYPE\n  #else\n    #define UNIONTYPE union\n  #endif\n#endif\n\n/* This defines a 16 byte sort record (in both 32 and 64 bit OS-es) */\ntypedef struct _QSORTrec1\n{\n  void     *ptr;\n  void     *ptr2;\n} QSORTrec1;\ntypedef struct _QSORTrec2\n{\n  void     *ptr;\n  double   realval;\n} QSORTrec2;\ntypedef struct _QSORTrec3\n{\n  void     *ptr;\n  int      intval;\n  int      intpar1;\n} QSORTrec3;\ntypedef struct _QSORTrec4\n{\n  REAL     realval;\n  int      intval;\n  int      intpar1;\n} QSORTrec4;\ntypedef struct _QSORTrec5\n{\n  double   realval;\n  long int longval;\n} QSORTrec5;\ntypedef struct _QSORTrec6\n{\n  double   realval;\n  double   realpar1;\n} QSORTrec6;\ntypedef struct _QSORTrec7\n{\n  int      intval;\n  int      intpar1;\n  int      intpar2;\n  int      intpar3;\n} QSORTrec7;\nunion QSORTrec\n{\n  QSORTrec1 pvoid2;\n  QSORTrec2 pvoidreal;\n  QSORTrec3 pvoidint2;\n  QSORTrec4 realint2;\n  QSORTrec5 reallong;\n  QSORTrec6 real2;\n  QSORTrec7 int4;\n};\n\n\n#ifdef __cplusplus\n  extern \"C\" {\n#endif\n\nint intpow(int base, int exponent);\nint mod(int n, int d);\n\nvoid strtoup(char *s);\nvoid strtolo(char *s);\nvoid strcpyup(char *t, char *s);\nvoid strcpylo(char *t, char *s);\n\nMYBOOL so_stdname(char *stdname, char *descname, int buflen);\nint gcd(LLONG a, LLONG b, int *c, int *d);\n\nint findIndex(int target, int *attributes, int count, int offset);\nint findIndexEx(void *target, void *attributes, int count, int offset, int recsize, findCompare_func findCompare, MYBOOL ascending);\n\nint CMP_CALLMODEL compareCHAR(const void *current, const void *candidate);\nint CMP_CALLMODEL compareINT(const void *current, const void *candidate);\nint CMP_CALLMODEL compareREAL(const void *current, const void *candidate);\nvoid hpsort(void *attributes, int count, int offset, int recsize, MYBOOL descending, findCompare_func findCompare);\nvoid hpsortex(void *attributes, int count, int offset, int recsize, MYBOOL descending, findCompare_func findCompare, int *tags);\n\nvoid QS_swap(UNIONTYPE QSORTrec a[], int i, int j);\nint QS_addfirst(UNIONTYPE QSORTrec a[], void *mydata);\nint QS_append(UNIONTYPE QSORTrec a[], int ipos, void *mydata);\nvoid QS_replace(UNIONTYPE QSORTrec a[], int ipos, void *mydata);\nvoid QS_insert(UNIONTYPE QSORTrec a[], int ipos, void *mydata, int epos);\nvoid QS_delete(UNIONTYPE QSORTrec a[], int ipos, int epos);\nMYBOOL QS_execute(UNIONTYPE QSORTrec a[], int count, findCompare_func findCompare, int *nswaps);\n\nint sortByREAL(int *item, REAL *weight, int size, int offset, MYBOOL unique);\nint sortByINT(int *item, int *weight, int size, int offset, MYBOOL unique);\nREAL sortREALByINT(REAL *item, int *weight, int size, int offset, MYBOOL unique);\n\ndouble timeNow(void);\n\nvoid blockWriteBOOL(FILE *output, char *label, MYBOOL *myvector, int first, int last, MYBOOL asRaw);\nvoid blockWriteINT(FILE *output, char *label, int *myvector, int first, int last);\nvoid blockWriteREAL(FILE *output, char *label, REAL *myvector, int first, int last);\n\nvoid printvec( int n, REAL *x, int modulo );\nvoid printmatSQ( int size, int n, REAL *X, int modulo );\nvoid printmatUT( int size, int n, REAL *U, int modulo );\n\n#if defined _MSC_VER\nint fileCount( char *filemask );\nMYBOOL fileSearchPath( char *envvar, char *searchfile, char *foundpath );\n#endif\n\n#ifdef __cplusplus\n  }\n#endif\n\n#endif /* HEADER_commonlib */\n",
        "/tmp/vanessa/spack-stage/spack-stage-r-lpsolve-5.6.13.2-2p7y34czadwk3yceelxxk5stmkcgrmfe/spack-src/src/lp_explicit.h": "#include \"lp_lib.h\"\n\n/* entries for lp structure */\nadd_column_func               *_add_column;\nadd_columnex_func             *_add_columnex;\nadd_constraint_func           *_add_constraint;\nadd_constraintex_func         *_add_constraintex;\nadd_lag_con_func              *_add_lag_con;\nadd_SOS_func                  *_add_SOS;\ncolumn_in_lp_func             *_column_in_lp;\ncopy_lp_func                  *_copy_lp;\ndefault_basis_func            *_default_basis;\ndel_column_func               *_del_column;\ndel_constraint_func           *_del_constraint;\ndelete_lp_func                *_delete_lp;\ndualize_lp_func               *_dualize_lp;\nfree_lp_func                  *_free_lp;\nget_anti_degen_func           *_get_anti_degen;\nget_basis_func                *_get_basis;\nget_basiscrash_func           *_get_basiscrash;\nget_bb_depthlimit_func        *_get_bb_depthlimit;\nget_bb_floorfirst_func        *_get_bb_floorfirst;\nget_bb_rule_func              *_get_bb_rule;\nget_bounds_tighter_func       *_get_bounds_tighter;\nget_break_at_value_func       *_get_break_at_value;\nget_col_name_func             *_get_col_name;\nget_columnex_func             *_get_columnex;\nget_constr_type_func          *_get_constr_type;\nget_constr_value_func         *_get_constr_value;\nget_constraints_func          *_get_constraints;\nget_dual_solution_func        *_get_dual_solution;\nget_epsb_func                 *_get_epsb;\nget_epsd_func                 *_get_epsd;\nget_epsel_func                *_get_epsel;\nget_epsint_func               *_get_epsint;\nget_epsperturb_func           *_get_epsperturb;\nget_epspivot_func             *_get_epspivot;\nget_improve_func              *_get_improve;\nget_infinite_func             *_get_infinite;\nget_lambda_func               *_get_lambda;\nget_lowbo_func                *_get_lowbo;\nget_lp_index_func             *_get_lp_index;\nget_lp_name_func              *_get_lp_name;\nget_Lrows_func                *_get_Lrows;\nget_mat_func                  *_get_mat;\nget_mat_byindex_func          *_get_mat_byindex;\nget_max_level_func            *_get_max_level;\nget_maxpivot_func             *_get_maxpivot;\nget_mip_gap_func              *_get_mip_gap;\nget_multiprice_func           *_get_multiprice;\nget_nameindex_func            *_get_nameindex;\nget_Ncolumns_func             *_get_Ncolumns;\nget_negrange_func             *_get_negrange;\nget_nz_func                   *_get_nonzeros;\nget_Norig_columns_func        *_get_Norig_columns;\nget_Norig_rows_func           *_get_Norig_rows;\nget_Nrows_func                *_get_Nrows;\nget_obj_bound_func            *_get_obj_bound;\nget_objective_func            *_get_objective;\nget_orig_index_func           *_get_orig_index;\nget_origcol_name_func         *_get_origcol_name;\nget_origrow_name_func         *_get_origrow_name;\nget_partialprice_func         *_get_partialprice;\nget_pivoting_func             *_get_pivoting;\nget_presolve_func             *_get_presolve;\nget_presolveloops_func        *_get_presolveloops;\nget_primal_solution_func      *_get_primal_solution;\nget_print_sol_func            *_get_print_sol;\nget_pseudocosts_func          *_get_pseudocosts;\nget_ptr_constraints_func      *_get_ptr_constraints;\nget_ptr_dual_solution_func    *_get_ptr_dual_solution;\nget_ptr_lambda_func           *_get_ptr_lambda;\nget_ptr_primal_solution_func  *_get_ptr_primal_solution;\nget_ptr_sensitivity_obj_func  *_get_ptr_sensitivity_obj;\nget_ptr_sensitivity_objex_func *_get_ptr_sensitivity_objex;\nget_ptr_sensitivity_rhs_func  *_get_ptr_sensitivity_rhs;\nget_ptr_variables_func        *_get_ptr_variables;\nget_rh_func                   *_get_rh;\nget_rh_range_func             *_get_rh_range;\nget_row_func                  *_get_row;\nget_row_name_func             *_get_row_name;\nget_scalelimit_func           *_get_scalelimit;\nget_scaling_func              *_get_scaling;\nget_sensitivity_obj_func      *_get_sensitivity_obj;\nget_sensitivity_objex_func    *_get_sensitivity_objex;\nget_sensitivity_rhs_func      *_get_sensitivity_rhs;\nget_simplextype_func          *_get_simplextype;\nget_solutioncount_func        *_get_solutioncount;\nget_solutionlimit_func        *_get_solutionlimit;\nget_status_func               *_get_status;\nget_statustext_func           *_get_statustext;\nget_timeout_func              *_get_timeout;\nget_total_iter_func           *_get_total_iter;\nget_total_nodes_func          *_get_total_nodes;\nget_upbo_func                 *_get_upbo;\nget_var_branch_func           *_get_var_branch;\nget_var_dualresult_func       *_get_var_dualresult;\nget_var_primalresult_func     *_get_var_primalresult;\nget_var_priority_func         *_get_var_priority;\nget_variables_func            *_get_variables;\nget_verbose_func              *_get_verbose;\nget_working_objective_func    *_get_working_objective;\nhas_BFP_func                  *_has_BFP;\nhas_XLI_func                  *_has_XLI;\nis_add_rowmode_func           *_is_add_rowmode;\nis_anti_degen_func            *_is_anti_degen;\nis_binary_func                *_is_binary;\nis_break_at_first_func        *_is_break_at_first;\nis_constr_type_func           *_is_constr_type;\nis_debug_func                 *_is_debug;\nis_feasible_func              *_is_feasible;\nis_unbounded_func             *_is_unbounded;\nis_infinite_func              *_is_infinite;\nis_int_func                   *_is_int;\nis_integerscaling_func        *_is_integerscaling;\nis_lag_trace_func             *_is_lag_trace;\nis_maxim_func                 *_is_maxim;\nis_nativeBFP_func             *_is_nativeBFP;\nis_nativeXLI_func             *_is_nativeXLI;\nis_negative_func              *_is_negative;\nis_piv_mode_func              *_is_piv_mode;\nis_piv_rule_func              *_is_piv_rule;\nis_presolve_func              *_is_presolve;\nis_scalemode_func             *_is_scalemode;\nis_scaletype_func             *_is_scaletype;\nis_semicont_func              *_is_semicont;\nis_SOS_var_func               *_is_SOS_var;\nis_trace_func                 *_is_trace;\nlp_solve_version_func         *_lp_solve_version;\nmake_lp_func                  *_make_lp;\nprint_constraints_func        *_print_constraints;\nprint_debugdump_func          *_print_debugdump;\nprint_duals_func              *_print_duals;\nprint_lp_func                 *_print_lp;\nprint_objective_func          *_print_objective;\nprint_scales_func             *_print_scales;\nprint_solution_func           *_print_solution;\nprint_str_func                *_print_str;\nprint_tableau_func            *_print_tableau;\nput_abortfunc_func            *_put_abortfunc;\nput_bb_nodefunc_func          *_put_bb_nodefunc;\nput_bb_branchfunc_func        *_put_bb_branchfunc;\nput_logfunc_func              *_put_logfunc;\nput_msgfunc_func              *_put_msgfunc;\nread_LPhandle_func            *_read_LPhandle;\nread_MPShandle_func           *_read_MPShandle;\nread_XLI_func                 *_read_XLI;\nread_params_func              *_read_params;\nread_basis_func               *_read_basis;\nreset_basis_func              *_reset_basis;\nreset_params_func             *_reset_params;\nresize_lp_func                *_resize_lp;\nset_add_rowmode_func          *_set_add_rowmode;\nset_anti_degen_func           *_set_anti_degen;\nset_basisvar_func             *_set_basisvar;\nset_basis_func                *_set_basis;\nset_basiscrash_func           *_set_basiscrash;\nset_bb_depthlimit_func        *_set_bb_depthlimit;\nset_bb_floorfirst_func        *_set_bb_floorfirst;\nset_bb_rule_func              *_set_bb_rule;\nset_BFP_func                  *_set_BFP;\nset_binary_func               *_set_binary;\nset_bounds_func               *_set_bounds;\nset_bounds_tighter_func       *_set_bounds_tighter;\nset_break_at_first_func       *_set_break_at_first;\nset_break_at_value_func       *_set_break_at_value;\nset_column_func               *_set_column;\nset_columnex_func             *_set_columnex;\nset_col_name_func             *_set_col_name;\nset_constr_type_func          *_set_constr_type;\nset_debug_func                *_set_debug;\nset_epsb_func                 *_set_epsb;\nset_epsd_func                 *_set_epsd;\nset_epsel_func                *_set_epsel;\nset_epsint_func               *_set_epsint;\nset_epslevel_func             *_set_epslevel;\nset_epsperturb_func           *_set_epsperturb;\nset_epspivot_func             *_set_epspivot;\nset_unbounded_func            *_set_unbounded;\nset_improve_func              *_set_improve;\nset_infinite_func             *_set_infinite;\nset_int_func                  *_set_int;\nset_lag_trace_func            *_set_lag_trace;\nset_lowbo_func                *_set_lowbo;\nset_lp_name_func              *_set_lp_name;\nset_mat_func                  *_set_mat;\nset_maxim_func                *_set_maxim;\nset_maxpivot_func             *_set_maxpivot;\nset_minim_func                *_set_minim;\nset_mip_gap_func              *_set_mip_gap;\nset_multiprice_func           *_set_multiprice;\nset_negrange_func             *_set_negrange;\nset_obj_bound_func            *_set_obj_bound;\nset_obj_fn_func               *_set_obj_fn;\nset_obj_fnex_func             *_set_obj_fnex;\nset_obj_func                  *_set_obj;\nset_outputfile_func           *_set_outputfile;\nset_outputstream_func         *_set_outputstream;\nset_partialprice_func         *_set_partialprice;\nset_pivoting_func             *_set_pivoting;\nset_preferdual_func           *_set_preferdual;\nset_presolve_func             *_set_presolve;\nset_print_sol_func            *_set_print_sol;\nset_pseudocosts_func          *_set_pseudocosts;\nset_rh_func                   *_set_rh;\nset_rh_range_func             *_set_rh_range;\nset_rh_vec_func               *_set_rh_vec;\nset_row_func                  *_set_row;\nset_rowex_func                *_set_rowex;\nset_row_name_func             *_set_row_name;\nset_scalelimit_func           *_set_scalelimit;\nset_scaling_func              *_set_scaling;\nset_semicont_func             *_set_semicont;\nset_sense_func                *_set_sense;\nset_simplextype_func          *_set_simplextype;\nset_solutionlimit_func        *_set_solutionlimit;\nset_timeout_func              *_set_timeout;\nset_trace_func                *_set_trace;\nset_upbo_func                 *_set_upbo;\nset_var_branch_func           *_set_var_branch;\nset_var_weights_func          *_set_var_weights;\nset_verbose_func              *_set_verbose;\nset_XLI_func                  *_set_XLI;\nsolve_func                    *_solve;\nstr_add_column_func           *_str_add_column;\nstr_add_constraint_func       *_str_add_constraint;\nstr_add_lag_con_func          *_str_add_lag_con;\nstr_set_obj_fn_func           *_str_set_obj_fn;\nstr_set_rh_vec_func           *_str_set_rh_vec;\ntime_elapsed_func             *_time_elapsed;\nunscale_func                  *_unscale;\nwrite_lp_func                 *_write_lp;\nwrite_LP_func                 *_write_LP;\nwrite_mps_func                *_write_mps;\nwrite_MPS_func                *_write_MPS;\nwrite_freemps_func            *_write_freemps;\nwrite_freeMPS_func            *_write_freeMPS;\nwrite_XLI_func                *_write_XLI;\nwrite_basis_func              *_write_basis;\nwrite_params_func             *_write_params;\n\n#if defined LPSOLVEAPIFROMLPREC\n\nstatic int init_lpsolve(lprec *lp)\n{\n  _add_column = lp->add_column;\n  _add_columnex = lp->add_columnex;\n  _add_constraint = lp->add_constraint;\n  _add_constraintex = lp->add_constraintex;\n  _add_lag_con = lp->add_lag_con;\n  _add_SOS = lp->add_SOS;\n  _column_in_lp = lp->column_in_lp;\n  _copy_lp = lp->copy_lp;\n  _default_basis = lp->default_basis;\n  _del_column = lp->del_column;\n  _del_constraint = lp->del_constraint;\n  _delete_lp = lp->delete_lp;\n  _dualize_lp = lp->dualize_lp;\n  _free_lp = lp->free_lp;\n  _get_anti_degen = lp->get_anti_degen;\n  _get_basis = lp->get_basis;\n  _get_basiscrash = lp->get_basiscrash;\n  _get_bb_depthlimit = lp->get_bb_depthlimit;\n  _get_bb_floorfirst = lp->get_bb_floorfirst;\n  _get_bb_rule = lp->get_bb_rule;\n  _get_bounds_tighter = lp->get_bounds_tighter;\n  _get_break_at_value = lp->get_break_at_value;\n  _get_col_name = lp->get_col_name;\n  _get_columnex = lp->get_columnex;\n  _get_constr_type = lp->get_constr_type;\n  _get_constr_value = lp->get_constr_value;\n  _get_constraints = lp->get_constraints;\n  _get_dual_solution = lp->get_dual_solution;\n  _get_epsb = lp->get_epsb;\n  _get_epsd = lp->get_epsd;\n  _get_epsel = lp->get_epsel;\n  _get_epsint = lp->get_epsint;\n  _get_epsperturb = lp->get_epsperturb;\n  _get_epspivot = lp->get_epspivot;\n  _get_improve = lp->get_improve;\n  _get_infinite = lp->get_infinite;\n  _get_lambda = lp->get_lambda;\n  _get_lowbo = lp->get_lowbo;\n  _get_lp_index = lp->get_lp_index;\n  _get_lp_name = lp->get_lp_name;\n  _get_Lrows = lp->get_Lrows;\n  _get_mat = lp->get_mat;\n  _get_mat_byindex = lp->get_mat_byindex;\n  _get_max_level = lp->get_max_level;\n  _get_maxpivot = lp->get_maxpivot;\n  _get_mip_gap = lp->get_mip_gap;\n  _get_multiprice = lp->get_multiprice;\n  _get_nameindex = lp->get_nameindex;\n  _get_Ncolumns = lp->get_Ncolumns;\n  _get_negrange = lp->get_negrange;\n  _get_nonzeros = lp->get_nonzeros;\n  _get_Norig_columns = lp->get_Norig_columns;\n  _get_Norig_rows = lp->get_Norig_rows;\n  _get_Nrows = lp->get_Nrows;\n  _get_obj_bound = lp->get_obj_bound;\n  _get_objective = lp->get_objective;\n  _get_orig_index = lp->get_orig_index;\n  _get_origcol_name = lp->get_origcol_name;\n  _get_origrow_name = lp->get_origrow_name;\n  _get_partialprice = lp->get_partialprice;\n  _get_pivoting = lp->get_pivoting;\n  _get_presolve = lp->get_presolve;\n  _get_presolveloops = lp->get_presolveloops;\n  _get_primal_solution = lp->get_primal_solution;\n  _get_print_sol = lp->get_print_sol;\n  _get_pseudocosts = lp->get_pseudocosts;\n  _get_ptr_constraints = lp->get_ptr_constraints;\n  _get_ptr_dual_solution = lp->get_ptr_dual_solution;\n  _get_ptr_lambda = lp->get_ptr_lambda;\n  _get_ptr_primal_solution = lp->get_ptr_primal_solution;\n  _get_ptr_sensitivity_obj = lp->get_ptr_sensitivity_obj;\n  _get_ptr_sensitivity_objex = lp->get_ptr_sensitivity_objex;\n  _get_ptr_sensitivity_rhs = lp->get_ptr_sensitivity_rhs;\n  _get_ptr_variables = lp->get_ptr_variables;\n  _get_rh = lp->get_rh;\n  _get_rh_range = lp->get_rh_range;\n  _get_row = lp->get_row;\n  _get_row_name = lp->get_row_name;\n  _get_scalelimit = lp->get_scalelimit;\n  _get_scaling = lp->get_scaling;\n  _get_sensitivity_obj = lp->get_sensitivity_obj;\n  _get_sensitivity_objex = lp->get_sensitivity_objex;\n  _get_sensitivity_rhs = lp->get_sensitivity_rhs;\n  _get_simplextype = lp->get_simplextype;\n  _get_solutioncount = lp->get_solutioncount;\n  _get_solutionlimit = lp->get_solutionlimit;\n  _get_status = lp->get_status;\n  _get_statustext = lp->get_statustext;\n  _get_timeout = lp->get_timeout;\n  _get_total_iter = lp->get_total_iter;\n  _get_total_nodes = lp->get_total_nodes;\n  _get_upbo = lp->get_upbo;\n  _get_var_branch = lp->get_var_branch;\n  _get_var_dualresult = lp->get_var_dualresult;\n  _get_var_primalresult = lp->get_var_primalresult;\n  _get_var_priority = lp->get_var_priority;\n  _get_variables = lp->get_variables;\n  _get_verbose = lp->get_verbose;\n  _get_working_objective = lp->get_working_objective;\n  _has_BFP = lp->has_BFP;\n  _has_XLI = lp->has_XLI;\n  _is_add_rowmode = lp->is_add_rowmode;\n  _is_anti_degen = lp->is_anti_degen;\n  _is_binary = lp->is_binary;\n  _is_break_at_first = lp->is_break_at_first;\n  _is_constr_type = lp->is_constr_type;\n  _is_debug = lp->is_debug;\n  _is_feasible = lp->is_feasible;\n  _is_unbounded = lp->is_unbounded;\n  _is_infinite = lp->is_infinite;\n  _is_int = lp->is_int;\n  _is_integerscaling = lp->is_integerscaling;\n  _is_lag_trace = lp->is_lag_trace;\n  _is_maxim = lp->is_maxim;\n  _is_nativeBFP = lp->is_nativeBFP;\n  _is_nativeXLI = lp->is_nativeXLI;\n  _is_negative = lp->is_negative;\n  _is_piv_mode = lp->is_piv_mode;\n  _is_piv_rule = lp->is_piv_rule;\n  _is_presolve = lp->is_presolve;\n  _is_scalemode = lp->is_scalemode;\n  _is_scaletype = lp->is_scaletype;\n  _is_semicont = lp->is_semicont;\n  _is_SOS_var = lp->is_SOS_var;\n  _is_trace = lp->is_trace;\n  _lp_solve_version = lp->lp_solve_version;\n  _make_lp = lp->make_lp;\n  _print_constraints = lp->print_constraints;\n  _print_debugdump = lp->print_debugdump;\n  _print_duals = lp->print_duals;\n  _print_lp = lp->print_lp;\n  _print_objective = lp->print_objective;\n  _print_scales = lp->print_scales;\n  _print_solution = lp->print_solution;\n  _print_str = lp->print_str;\n  _print_tableau = lp->print_tableau;\n  _put_abortfunc = lp->put_abortfunc;\n  _put_bb_nodefunc = lp->put_bb_nodefunc;\n  _put_bb_branchfunc = lp->put_bb_branchfunc;\n  _put_logfunc = lp->put_logfunc;\n  _put_msgfunc = lp->put_msgfunc;\n  _read_LPhandle = lp->read_LPhandle;\n  _read_MPShandle = lp->read_MPShandle;\n  _read_XLI = lp->read_XLI;\n  _read_params = lp->read_params;\n  _read_basis = lp->read_basis;\n  _reset_basis = lp->reset_basis;\n  _reset_params = lp->reset_params;\n  _resize_lp = lp->resize_lp;\n  _set_add_rowmode = lp->set_add_rowmode;\n  _set_anti_degen = lp->set_anti_degen;\n  _set_basisvar = lp->set_basisvar;\n  _set_basis = lp->set_basis;\n  _set_basiscrash = lp->set_basiscrash;\n  _set_bb_depthlimit = lp->set_bb_depthlimit;\n  _set_bb_floorfirst = lp->set_bb_floorfirst;\n  _set_bb_rule = lp->set_bb_rule;\n  _set_BFP = lp->set_BFP;\n  _set_binary = lp->set_binary;\n  _set_bounds = lp->set_bounds;\n  _set_bounds_tighter = lp->set_bounds_tighter;\n  _set_break_at_first = lp->set_break_at_first;\n  _set_break_at_value = lp->set_break_at_value;\n  _set_column = lp->set_column;\n  _set_columnex = lp->set_columnex;\n  _set_col_name = lp->set_col_name;\n  _set_constr_type = lp->set_constr_type;\n  _set_debug = lp->set_debug;\n  _set_epsb = lp->set_epsb;\n  _set_epsd = lp->set_epsd;\n  _set_epsel = lp->set_epsel;\n  _set_epsint = lp->set_epsint;\n  _set_epslevel = lp->set_epslevel;\n  _set_epsperturb = lp->set_epsperturb;\n  _set_epspivot = lp->set_epspivot;\n  _set_unbounded = lp->set_unbounded;\n  _set_improve = lp->set_improve;\n  _set_infinite = lp->set_infinite;\n  _set_int = lp->set_int;\n  _set_lag_trace = lp->set_lag_trace;\n  _set_lowbo = lp->set_lowbo;\n  _set_lp_name = lp->set_lp_name;\n  _set_mat = lp->set_mat;\n  _set_maxim = lp->set_maxim;\n  _set_maxpivot = lp->set_maxpivot;\n  _set_minim = lp->set_minim;\n  _set_mip_gap = lp->set_mip_gap;\n  _set_multiprice = lp->set_multiprice;\n  _set_negrange = lp->set_negrange;\n  _set_obj_bound = lp->set_obj_bound;\n  _set_obj_fn = lp->set_obj_fn;\n  _set_obj_fnex = lp->set_obj_fnex;\n  _set_obj = lp->set_obj;\n  _set_outputfile = lp->set_outputfile;\n  _set_outputstream = lp->set_outputstream;\n  _set_partialprice = lp->set_partialprice;\n  _set_pivoting = lp->set_pivoting;\n  _set_preferdual = lp->set_preferdual;\n  _set_presolve = lp->set_presolve;\n  _set_print_sol = lp->set_print_sol;\n  _set_pseudocosts = lp->set_pseudocosts;\n  _set_rh = lp->set_rh;\n  _set_rh_range = lp->set_rh_range;\n  _set_rh_vec = lp->set_rh_vec;\n  _set_row = lp->set_row;\n  _set_rowex = lp->set_rowex;\n  _set_row_name = lp->set_row_name;\n  _set_scalelimit = lp->set_scalelimit;\n  _set_scaling = lp->set_scaling;\n  _set_semicont = lp->set_semicont;\n  _set_sense = lp->set_sense;\n  _set_simplextype = lp->set_simplextype;\n  _set_solutionlimit = lp->set_solutionlimit;\n  _set_timeout = lp->set_timeout;\n  _set_trace = lp->set_trace;\n  _set_upbo = lp->set_upbo;\n  _set_var_branch = lp->set_var_branch;\n  _set_var_weights = lp->set_var_weights;\n  _set_verbose = lp->set_verbose;\n  _set_XLI = lp->set_XLI;\n  _solve = lp->solve;\n  _str_add_column = lp->str_add_column;\n  _str_add_constraint = lp->str_add_constraint;\n  _str_add_lag_con = lp->str_add_lag_con;\n  _str_set_obj_fn = lp->str_set_obj_fn;\n  _str_set_rh_vec = lp->str_set_rh_vec;\n  _time_elapsed = lp->time_elapsed;\n  _unscale = lp->unscale;\n  _write_lp = lp->write_lp;\n  _write_LP = lp->write_LP;\n  _write_mps = lp->write_mps;\n  _write_MPS = lp->write_MPS;\n  _write_freemps = lp->write_freemps;\n  _write_freeMPS = lp->write_freeMPS;\n  _write_XLI = lp->write_XLI;\n  _write_basis = lp->write_basis;\n  _write_params = lp->write_params;\n\n  return(TRUE);\n}\n\n#elif defined LPSOLVEAPIFROMLIB\n\n#ifdef WIN32\n#  include <windows.h>\n#else\n#  include <dlfcn.h>\n#endif\n\n#if defined WIN32\n# define hlpsolve HINSTANCE\n#else\n# define hlpsolve void *\n#endif\n\nstatic hlpsolve open_lpsolve_lib(char *filename)\n{\n  hlpsolve lpsolve;\n\n# if defined WIN32\n  /* Get a handle to the Windows DLL module. */\n  lpsolve = LoadLibrary(\"lpsolve55.dll\");\n# else\n  lpsolve = dlopen(\"liblpsolve55.so\", RTLD_LAZY);;\n# endif\n  return(lpsolve);\n}\n\nstatic int close_lpsolve_lib(hlpsolve lpsolve)\n{\n#ifdef WIN32\n  FreeLibrary(lpsolve);\n#else\n  dlclose(lpsolve);\n#endif\n\n  return(TRUE);\n}\n\nstatic int init_lpsolve(hlpsolve lpsolve)\n{\n# if defined WIN32\n#   define AddressOf GetProcAddress\n# else\n#   define AddressOf dlsym\n# endif\n\n  /* assign API functions to lp structure */\n  _add_column = (add_column_func *) AddressOf(lpsolve, \"add_column\");\n  _add_columnex = (add_columnex_func *) AddressOf(lpsolve, \"add_columnex\");\n  _add_constraint = (add_constraint_func *) AddressOf(lpsolve, \"add_constraint\");\n  _add_constraintex = (add_constraintex_func *) AddressOf(lpsolve, \"add_constraintex\");\n  _add_lag_con = (add_lag_con_func *) AddressOf(lpsolve, \"add_lag_con\");\n  _add_SOS = (add_SOS_func *) AddressOf(lpsolve, \"add_SOS\");\n  _column_in_lp = (column_in_lp_func *) AddressOf(lpsolve, \"column_in_lp\");\n  _copy_lp = (copy_lp_func *) AddressOf(lpsolve, \"copy_lp\");\n  _default_basis = (default_basis_func *) AddressOf(lpsolve, \"default_basis\");\n  _del_column = (del_column_func *) AddressOf(lpsolve, \"del_column\");\n  _del_constraint = (del_constraint_func *) AddressOf(lpsolve, \"del_constraint\");\n  _delete_lp = (delete_lp_func *) AddressOf(lpsolve, \"delete_lp\");\n  _dualize_lp = (dualize_lp_func *) AddressOf(lpsolve, \"dualize_lp\");\n  _free_lp = (free_lp_func *) AddressOf(lpsolve, \"free_lp\");\n  _get_anti_degen = (get_anti_degen_func *) AddressOf(lpsolve, \"get_anti_degen\");\n  _get_basis = (get_basis_func *) AddressOf(lpsolve, \"get_basis\");\n  _get_basiscrash = (get_basiscrash_func *) AddressOf(lpsolve, \"get_basiscrash\");\n  _get_bb_depthlimit = (get_bb_depthlimit_func *) AddressOf(lpsolve, \"get_bb_depthlimit\");\n  _get_bb_floorfirst = (get_bb_floorfirst_func *) AddressOf(lpsolve, \"get_bb_floorfirst\");\n  _get_bb_rule = (get_bb_rule_func *) AddressOf(lpsolve, \"get_bb_rule\");\n  _get_bounds_tighter = (get_bounds_tighter_func *) AddressOf(lpsolve, \"get_bounds_tighter\");\n  _get_break_at_value = (get_break_at_value_func *) AddressOf(lpsolve, \"get_break_at_value\");\n  _get_col_name = (get_col_name_func *) AddressOf(lpsolve, \"get_col_name\");\n  _get_columnex = (get_columnex_func *) AddressOf(lpsolve, \"get_columnex\");\n  _get_constr_type = (get_constr_type_func *) AddressOf(lpsolve, \"get_constr_type\");\n  _get_constr_value = (get_constr_value_func *) AddressOf(lpsolve, \"get_constr_value\");\n  _get_constraints = (get_constraints_func *) AddressOf(lpsolve, \"get_constraints\");\n  _get_dual_solution = (get_dual_solution_func *) AddressOf(lpsolve, \"get_dual_solution\");\n  _get_epsb = (get_epsb_func *) AddressOf(lpsolve, \"get_epsb\");\n  _get_epsd = (get_epsd_func *) AddressOf(lpsolve, \"get_epsd\");\n  _get_epsel = (get_epsel_func *) AddressOf(lpsolve, \"get_epsel\");\n  _get_epsint = (get_epsint_func *) AddressOf(lpsolve, \"get_epsint\");\n  _get_epsperturb = (get_epsperturb_func *) AddressOf(lpsolve, \"get_epsperturb\");\n  _get_epspivot = (get_epspivot_func *) AddressOf(lpsolve, \"get_epspivot\");\n  _get_improve = (get_improve_func *) AddressOf(lpsolve, \"get_improve\");\n  _get_infinite = (get_infinite_func *) AddressOf(lpsolve, \"get_infinite\");\n  _get_lambda = (get_lambda_func *) AddressOf(lpsolve, \"get_lambda\");\n  _get_lowbo = (get_lowbo_func *) AddressOf(lpsolve, \"get_lowbo\");\n  _get_lp_index = (get_lp_index_func *) AddressOf(lpsolve, \"get_lp_index\");\n  _get_lp_name = (get_lp_name_func *) AddressOf(lpsolve, \"get_lp_name\");\n  _get_Lrows = (get_Lrows_func *) AddressOf(lpsolve, \"get_Lrows\");\n  _get_mat = (get_mat_func *) AddressOf(lpsolve, \"get_mat\");\n  _get_mat_byindex = (get_mat_byindex_func *) AddressOf(lpsolve, \"get_mat_byindex\");\n  _get_max_level = (get_max_level_func *) AddressOf(lpsolve, \"get_max_level\");\n  _get_maxpivot = (get_maxpivot_func *) AddressOf(lpsolve, \"get_maxpivot\");\n  _get_mip_gap = (get_mip_gap_func *) AddressOf(lpsolve, \"get_mip_gap\");\n  _get_multiprice = (get_multiprice_func *) AddressOf(lpsolve, \"get_multiprice\");\n  _get_nameindex = (get_nameindex_func *) AddressOf(lpsolve, \"get_nameindex\");\n  _get_Ncolumns = (get_Ncolumns_func *) AddressOf(lpsolve, \"get_Ncolumns\");\n  _get_negrange = (get_negrange_func *) AddressOf(lpsolve, \"get_negrange\");\n  _get_nonzeros = (get_nz_func *) AddressOf(lpsolve, \"get_nonzeros\");\n  _get_Norig_columns = (get_Norig_columns_func *) AddressOf(lpsolve, \"get_Norig_columns\");\n  _get_Norig_rows = (get_Norig_rows_func *) AddressOf(lpsolve, \"get_Norig_rows\");\n  _get_Nrows = (get_Nrows_func *) AddressOf(lpsolve, \"get_Nrows\");\n  _get_obj_bound = (get_obj_bound_func *) AddressOf(lpsolve, \"get_obj_bound\");\n  _get_objective = (get_objective_func *) AddressOf(lpsolve, \"get_objective\");\n  _get_orig_index = (get_orig_index_func *) AddressOf(lpsolve, \"get_orig_index\");\n  _get_origcol_name = (get_origcol_name_func *) AddressOf(lpsolve, \"get_origcol_name\");\n  _get_origrow_name = (get_origrow_name_func *) AddressOf(lpsolve, \"get_origrow_name\");\n  _get_partialprice = (get_partialprice_func *) AddressOf(lpsolve, \"get_partialprice\");\n  _get_pivoting = (get_pivoting_func *) AddressOf(lpsolve, \"get_pivoting\");\n  _get_presolve = (get_presolve_func *) AddressOf(lpsolve, \"get_presolve\");\n  _get_presolveloops = (get_presolveloops_func *) AddressOf(lpsolve, \"get_presolveloops\");\n  _get_primal_solution = (get_primal_solution_func *) AddressOf(lpsolve, \"get_primal_solution\");\n  _get_print_sol = (get_print_sol_func *) AddressOf(lpsolve, \"get_print_sol\");\n  _get_pseudocosts = (get_pseudocosts_func *) AddressOf(lpsolve, \"get_pseudocosts\");\n  _get_ptr_constraints = (get_ptr_constraints_func *) AddressOf(lpsolve, \"get_ptr_constraints\");\n  _get_ptr_dual_solution = (get_ptr_dual_solution_func *) AddressOf(lpsolve, \"get_ptr_dual_solution\");\n  _get_ptr_lambda = (get_ptr_lambda_func *) AddressOf(lpsolve, \"get_ptr_lambda\");\n  _get_ptr_primal_solution = (get_ptr_primal_solution_func *) AddressOf(lpsolve, \"get_ptr_primal_solution\");\n  _get_ptr_sensitivity_obj = (get_ptr_sensitivity_obj_func *) AddressOf(lpsolve, \"get_ptr_sensitivity_obj\");\n  _get_ptr_sensitivity_objex = (get_ptr_sensitivity_objex_func *) AddressOf(lpsolve, \"get_ptr_sensitivity_objex\");\n  _get_ptr_sensitivity_rhs = (get_ptr_sensitivity_rhs_func *) AddressOf(lpsolve, \"get_ptr_sensitivity_rhs\");\n  _get_ptr_variables = (get_ptr_variables_func *) AddressOf(lpsolve, \"get_ptr_variables\");\n  _get_rh = (get_rh_func *) AddressOf(lpsolve, \"get_rh\");\n  _get_rh_range = (get_rh_range_func *) AddressOf(lpsolve, \"get_rh_range\");\n  _get_row = (get_row_func *) AddressOf(lpsolve, \"get_row\");\n  _get_row_name = (get_row_name_func *) AddressOf(lpsolve, \"get_row_name\");\n  _get_scalelimit = (get_scalelimit_func *) AddressOf(lpsolve, \"get_scalelimit\");\n  _get_scaling = (get_scaling_func *) AddressOf(lpsolve, \"get_scaling\");\n  _get_sensitivity_obj = (get_sensitivity_obj_func *) AddressOf(lpsolve, \"get_sensitivity_obj\");\n  _get_sensitivity_objex = (get_sensitivity_objex_func *) AddressOf(lpsolve, \"get_sensitivity_objex\");\n  _get_sensitivity_rhs = (get_sensitivity_rhs_func *) AddressOf(lpsolve, \"get_sensitivity_rhs\");\n  _get_simplextype = (get_simplextype_func *) AddressOf(lpsolve, \"get_simplextype\");\n  _get_solutioncount = (get_solutioncount_func *) AddressOf(lpsolve, \"get_solutioncount\");\n  _get_solutionlimit = (get_solutionlimit_func *) AddressOf(lpsolve, \"get_solutionlimit\");\n  _get_status = (get_status_func *) AddressOf(lpsolve, \"get_status\");\n  _get_statustext = (get_statustext_func *) AddressOf(lpsolve, \"get_statustext\");\n  _get_timeout = (get_timeout_func *) AddressOf(lpsolve, \"get_timeout\");\n  _get_total_iter = (get_total_iter_func *) AddressOf(lpsolve, \"get_total_iter\");\n  _get_total_nodes = (get_total_nodes_func *) AddressOf(lpsolve, \"get_total_nodes\");\n  _get_upbo = (get_upbo_func *) AddressOf(lpsolve, \"get_upbo\");\n  _get_var_branch = (get_var_branch_func *) AddressOf(lpsolve, \"get_var_branch\");\n  _get_var_dualresult = (get_var_dualresult_func *) AddressOf(lpsolve, \"get_var_dualresult\");\n  _get_var_primalresult = (get_var_primalresult_func *) AddressOf(lpsolve, \"get_var_primalresult\");\n  _get_var_priority = (get_var_priority_func *) AddressOf(lpsolve, \"get_var_priority\");\n  _get_variables = (get_variables_func *) AddressOf(lpsolve, \"get_variables\");\n  _get_verbose = (get_verbose_func *) AddressOf(lpsolve, \"get_verbose\");\n  _get_working_objective = (get_working_objective_func *) AddressOf(lpsolve, \"get_working_objective\");\n  _has_BFP = (has_BFP_func *) AddressOf(lpsolve, \"has_BFP\");\n  _has_XLI = (has_XLI_func *) AddressOf(lpsolve, \"has_XLI\");\n  _is_add_rowmode = (is_add_rowmode_func *) AddressOf(lpsolve, \"is_add_rowmode\");\n  _is_anti_degen = (is_anti_degen_func *) AddressOf(lpsolve, \"is_anti_degen\");\n  _is_binary = (is_binary_func *) AddressOf(lpsolve, \"is_binary\");\n  _is_break_at_first = (is_break_at_first_func *) AddressOf(lpsolve, \"is_break_at_first\");\n  _is_constr_type = (is_constr_type_func *) AddressOf(lpsolve, \"is_constr_type\");\n  _is_debug = (is_debug_func *) AddressOf(lpsolve, \"is_debug\");\n  _is_feasible = (is_feasible_func *) AddressOf(lpsolve, \"is_feasible\");\n  _is_unbounded = (is_unbounded_func *) AddressOf(lpsolve, \"is_unbounded\");\n  _is_infinite = (is_infinite_func *) AddressOf(lpsolve, \"is_infinite\");\n  _is_int = (is_int_func *) AddressOf(lpsolve, \"is_int\");\n  _is_integerscaling = (is_integerscaling_func *) AddressOf(lpsolve, \"is_integerscaling\");\n  _is_lag_trace = (is_lag_trace_func *) AddressOf(lpsolve, \"is_lag_trace\");\n  _is_maxim = (is_maxim_func *) AddressOf(lpsolve, \"is_maxim\");\n  _is_nativeBFP = (is_nativeBFP_func *) AddressOf(lpsolve, \"is_nativeBFP\");\n  _is_nativeXLI = (is_nativeXLI_func *) AddressOf(lpsolve, \"is_nativeXLI\");\n  _is_negative = (is_negative_func *) AddressOf(lpsolve, \"is_negative\");\n  _is_piv_mode = (is_piv_mode_func *) AddressOf(lpsolve, \"is_piv_mode\");\n  _is_piv_rule = (is_piv_rule_func *) AddressOf(lpsolve, \"is_piv_rule\");\n  _is_presolve = (is_presolve_func *) AddressOf(lpsolve, \"is_presolve\");\n  _is_scalemode = (is_scalemode_func *) AddressOf(lpsolve, \"is_scalemode\");\n  _is_scaletype = (is_scaletype_func *) AddressOf(lpsolve, \"is_scaletype\");\n  _is_semicont = (is_semicont_func *) AddressOf(lpsolve, \"is_semicont\");\n  _is_SOS_var = (is_SOS_var_func *) AddressOf(lpsolve, \"is_SOS_var\");\n  _is_trace = (is_trace_func *) AddressOf(lpsolve, \"is_trace\");\n  _lp_solve_version = (lp_solve_version_func *) AddressOf(lpsolve, \"lp_solve_version\");\n  _make_lp = (make_lp_func *) AddressOf(lpsolve, \"make_lp\");\n  _print_constraints = (print_constraints_func *) AddressOf(lpsolve, \"print_constraints\");\n  _print_debugdump = (print_debugdump_func *) AddressOf(lpsolve, \"print_debugdump\");\n  _print_duals = (print_duals_func *) AddressOf(lpsolve, \"print_duals\");\n  _print_lp = (print_lp_func *) AddressOf(lpsolve, \"print_lp\");\n  _print_objective = (print_objective_func *) AddressOf(lpsolve, \"print_objective\");\n  _print_scales = (print_scales_func *) AddressOf(lpsolve, \"print_scales\");\n  _print_solution = (print_solution_func *) AddressOf(lpsolve, \"print_solution\");\n  _print_str = (print_str_func *) AddressOf(lpsolve, \"print_str\");\n  _print_tableau = (print_tableau_func *) AddressOf(lpsolve, \"print_tableau\");\n  _put_abortfunc = (put_abortfunc_func *) AddressOf(lpsolve, \"put_abortfunc\");\n  _put_bb_nodefunc = (put_bb_nodefunc_func *) AddressOf(lpsolve, \"put_bb_nodefunc\");\n  _put_bb_branchfunc = (put_bb_branchfunc_func *) AddressOf(lpsolve, \"put_bb_branchfunc\");\n  _put_logfunc = (put_logfunc_func *) AddressOf(lpsolve, \"put_logfunc\");\n  _put_msgfunc = (put_msgfunc_func *) AddressOf(lpsolve, \"put_msgfunc\");\n  _read_LPhandle = (read_LPhandle_func *) AddressOf(lpsolve, \"read_LPhandle\");\n  _read_MPShandle = (read_MPShandle_func *) AddressOf(lpsolve, \"read_MPShandle\");\n  _read_XLI = (read_XLI_func *) AddressOf(lpsolve, \"read_XLI\");\n  _read_params = (read_params_func *) AddressOf(lpsolve, \"read_params\");\n  _read_basis = (read_basis_func *) AddressOf(lpsolve, \"read_basis\");\n  _reset_basis = (reset_basis_func *) AddressOf(lpsolve, \"reset_basis\");\n  _reset_params = (reset_params_func *) AddressOf(lpsolve, \"reset_params\");\n  _resize_lp = (resize_lp_func *) AddressOf(lpsolve, \"resize_lp\");\n  _set_add_rowmode = (set_add_rowmode_func *) AddressOf(lpsolve, \"set_add_rowmode\");\n  _set_anti_degen = (set_anti_degen_func *) AddressOf(lpsolve, \"set_anti_degen\");\n  _set_basisvar = (set_basisvar_func *) AddressOf(lpsolve, \"set_basisvar\");\n  _set_basis = (set_basis_func *) AddressOf(lpsolve, \"set_basis\");\n  _set_basiscrash = (set_basiscrash_func *) AddressOf(lpsolve, \"set_basiscrash\");\n  _set_bb_depthlimit = (set_bb_depthlimit_func *) AddressOf(lpsolve, \"set_bb_depthlimit\");\n  _set_bb_floorfirst = (set_bb_floorfirst_func *) AddressOf(lpsolve, \"set_bb_floorfirst\");\n  _set_bb_rule = (set_bb_rule_func *) AddressOf(lpsolve, \"set_bb_rule\");\n  _set_BFP = (set_BFP_func *) AddressOf(lpsolve, \"set_BFP\");\n  _set_binary = (set_binary_func *) AddressOf(lpsolve, \"set_binary\");\n  _set_bounds = (set_bounds_func *) AddressOf(lpsolve, \"set_bounds\");\n  _set_bounds_tighter = (set_bounds_tighter_func *) AddressOf(lpsolve, \"set_bounds_tighter\");\n  _set_break_at_first = (set_break_at_first_func *) AddressOf(lpsolve, \"set_break_at_first\");\n  _set_break_at_value = (set_break_at_value_func *) AddressOf(lpsolve, \"set_break_at_value\");\n  _set_column = (set_column_func *) AddressOf(lpsolve, \"set_column\");\n  _set_columnex = (set_columnex_func *) AddressOf(lpsolve, \"set_columnex\");\n  _set_col_name = (set_col_name_func *) AddressOf(lpsolve, \"set_col_name\");\n  _set_constr_type = (set_constr_type_func *) AddressOf(lpsolve, \"set_constr_type\");\n  _set_debug = (set_debug_func *) AddressOf(lpsolve, \"set_debug\");\n  _set_epsb = (set_epsb_func *) AddressOf(lpsolve, \"set_epsb\");\n  _set_epsd = (set_epsd_func *) AddressOf(lpsolve, \"set_epsd\");\n  _set_epsel = (set_epsel_func *) AddressOf(lpsolve, \"set_epsel\");\n  _set_epsint = (set_epsint_func *) AddressOf(lpsolve, \"set_epsint\");\n  _set_epslevel = (set_epslevel_func *) AddressOf(lpsolve, \"set_epslevel\");\n  _set_epsperturb = (set_epsperturb_func *) AddressOf(lpsolve, \"set_epsperturb\");\n  _set_epspivot = (set_epspivot_func *) AddressOf(lpsolve, \"set_epspivot\");\n  _set_unbounded = (set_unbounded_func *) AddressOf(lpsolve, \"set_unbounded\");\n  _set_improve = (set_improve_func *) AddressOf(lpsolve, \"set_improve\");\n  _set_infinite = (set_infinite_func *) AddressOf(lpsolve, \"set_infinite\");\n  _set_int = (set_int_func *) AddressOf(lpsolve, \"set_int\");\n  _set_lag_trace = (set_lag_trace_func *) AddressOf(lpsolve, \"set_lag_trace\");\n  _set_lowbo = (set_lowbo_func *) AddressOf(lpsolve, \"set_lowbo\");\n  _set_lp_name = (set_lp_name_func *) AddressOf(lpsolve, \"set_lp_name\");\n  _set_mat = (set_mat_func *) AddressOf(lpsolve, \"set_mat\");\n  _set_maxim = (set_maxim_func *) AddressOf(lpsolve, \"set_maxim\");\n  _set_maxpivot = (set_maxpivot_func *) AddressOf(lpsolve, \"set_maxpivot\");\n  _set_minim = (set_minim_func *) AddressOf(lpsolve, \"set_minim\");\n  _set_mip_gap = (set_mip_gap_func *) AddressOf(lpsolve, \"set_mip_gap\");\n  _set_multiprice = (set_multiprice_func *) AddressOf(lpsolve, \"set_multiprice\");\n  _set_negrange = (set_negrange_func *) AddressOf(lpsolve, \"set_negrange\");\n  _set_obj_bound = (set_obj_bound_func *) AddressOf(lpsolve, \"set_obj_bound\");\n  _set_obj_fn = (set_obj_fn_func *) AddressOf(lpsolve, \"set_obj_fn\");\n  _set_obj_fnex = (set_obj_fnex_func *) AddressOf(lpsolve, \"set_obj_fnex\");\n  _set_obj = (set_obj_func *) AddressOf(lpsolve, \"set_obj\");\n  _set_outputfile = (set_outputfile_func *) AddressOf(lpsolve, \"set_outputfile\");\n  _set_outputstream = (set_outputstream_func *) AddressOf(lpsolve, \"set_outputstream\");\n  _set_partialprice = (set_partialprice_func *) AddressOf(lpsolve, \"set_partialprice\");\n  _set_pivoting = (set_pivoting_func *) AddressOf(lpsolve, \"set_pivoting\");\n  _set_preferdual = (set_preferdual_func *) AddressOf(lpsolve, \"set_preferdual\");\n  _set_presolve = (set_presolve_func *) AddressOf(lpsolve, \"set_presolve\");\n  _set_print_sol = (set_print_sol_func *) AddressOf(lpsolve, \"set_print_sol\");\n  _set_pseudocosts = (set_pseudocosts_func *) AddressOf(lpsolve, \"set_pseudocosts\");\n  _set_rh = (set_rh_func *) AddressOf(lpsolve, \"set_rh\");\n  _set_rh_range = (set_rh_range_func *) AddressOf(lpsolve, \"set_rh_range\");\n  _set_rh_vec = (set_rh_vec_func *) AddressOf(lpsolve, \"set_rh_vec\");\n  _set_row = (set_row_func *) AddressOf(lpsolve, \"set_row\");\n  _set_rowex = (set_rowex_func *) AddressOf(lpsolve, \"set_rowex\");\n  _set_row_name = (set_row_name_func *) AddressOf(lpsolve, \"set_row_name\");\n  _set_scalelimit = (set_scalelimit_func *) AddressOf(lpsolve, \"set_scalelimit\");\n  _set_scaling = (set_scaling_func *) AddressOf(lpsolve, \"set_scaling\");\n  _set_semicont = (set_semicont_func *) AddressOf(lpsolve, \"set_semicont\");\n  _set_sense = (set_sense_func *) AddressOf(lpsolve, \"set_sense\");\n  _set_simplextype = (set_simplextype_func *) AddressOf(lpsolve, \"set_simplextype\");\n  _set_solutionlimit = (set_solutionlimit_func *) AddressOf(lpsolve, \"set_solutionlimit\");\n  _set_timeout = (set_timeout_func *) AddressOf(lpsolve, \"set_timeout\");\n  _set_trace = (set_trace_func *) AddressOf(lpsolve, \"set_trace\");\n  _set_upbo = (set_upbo_func *) AddressOf(lpsolve, \"set_upbo\");\n  _set_var_branch = (set_var_branch_func *) AddressOf(lpsolve, \"set_var_branch\");\n  _set_var_weights = (set_var_weights_func *) AddressOf(lpsolve, \"set_var_weights\");\n  _set_verbose = (set_verbose_func *) AddressOf(lpsolve, \"set_verbose\");\n  _set_XLI = (set_XLI_func *) AddressOf(lpsolve, \"set_XLI\");\n  _solve = (solve_func *) AddressOf(lpsolve, \"solve\");\n  _str_add_column = (str_add_column_func *) AddressOf(lpsolve, \"str_add_column\");\n  _str_add_constraint = (str_add_constraint_func *) AddressOf(lpsolve, \"str_add_constraint\");\n  _str_add_lag_con = (str_add_lag_con_func *) AddressOf(lpsolve, \"str_add_lag_con\");\n  _str_set_obj_fn = (str_set_obj_fn_func *) AddressOf(lpsolve, \"str_set_obj_fn\");\n  _str_set_rh_vec = (str_set_rh_vec_func *) AddressOf(lpsolve, \"str_set_rh_vec\");\n  _time_elapsed = (time_elapsed_func *) AddressOf(lpsolve, \"time_elapsed\");\n  _unscale = (unscale_func *) AddressOf(lpsolve, \"unscale\");\n  _write_lp = (write_lp_func *) AddressOf(lpsolve, \"write_lp\");\n  _write_LP = (write_LP_func *) AddressOf(lpsolve, \"write_LP\");\n  _write_mps = (write_mps_func *) AddressOf(lpsolve, \"write_mps\");\n  _write_MPS = (write_MPS_func *) AddressOf(lpsolve, \"write_MPS\");\n  _write_freemps = (write_freemps_func *) AddressOf(lpsolve, \"write_freemps\");\n  _write_freeMPS = (write_freeMPS_func *) AddressOf(lpsolve, \"write_freeMPS\");\n  _write_XLI = (write_XLI_func *) AddressOf(lpsolve, \"write_XLI\");\n  _write_basis = (write_basis_func *) AddressOf(lpsolve, \"write_basis\");\n  _write_params = (write_params_func *) AddressOf(lpsolve, \"write_params\");\n\n  return(TRUE);\n# undef AddressOf\n}\n\n#else\n#  error Either LPSOLVEAPIFROMLPREC or LPSOLVEAPIFROMLIB must be defined\n#endif\n\n#define add_column _add_column\n#define add_columnex _add_columnex\n#define add_constraint _add_constraint\n#define add_constraintex _add_constraintex\n#define add_lag_con _add_lag_con\n#define add_SOS _add_SOS\n#define column_in_lp _column_in_lp\n#define copy_lp _copy_lp\n#define default_basis _default_basis\n#define del_column _del_column\n#define del_constraint _del_constraint\n#define delete_lp _delete_lp\n#define dualize_lp _dualize_lp\n#define free_lp _free_lp\n#define get_anti_degen _get_anti_degen\n#define get_basis _get_basis\n#define get_basiscrash _get_basiscrash\n#define get_bb_depthlimit _get_bb_depthlimit\n#define get_bb_floorfirst _get_bb_floorfirst\n#define get_bb_rule _get_bb_rule\n#define get_bounds_tighter _get_bounds_tighter\n#define get_break_at_value _get_break_at_value\n#define get_col_name _get_col_name\n#define get_columnex _get_columnex\n#define get_constr_type _get_constr_type\n#define get_constr_value _get_constr_value\n#define get_constraints _get_constraints\n#define get_dual_solution _get_dual_solution\n#define get_epsb _get_epsb\n#define get_epsd _get_epsd\n#define get_epsel _get_epsel\n#define get_epsint _get_epsint\n#define get_epsperturb _get_epsperturb\n#define get_epspivot _get_epspivot\n#define get_improve _get_improve\n#define get_infinite _get_infinite\n#define get_lambda _get_lambda\n#define get_lowbo _get_lowbo\n#define get_lp_index _get_lp_index\n#define get_lp_name _get_lp_name\n#define get_Lrows _get_Lrows\n#define get_mat _get_mat\n#define get_mat_byindex _get_mat_byindex\n#define get_max_level _get_max_level\n#define get_maxpivot _get_maxpivot\n#define get_mip_gap _get_mip_gap\n#define get_multiprice _get_multiprice\n#define get_nameindex _get_nameindex\n#define get_Ncolumns _get_Ncolumns\n#define get_negrange _get_negrange\n#define get_nonzeros _get_nonzeros\n#define get_Norig_columns _get_Norig_columns\n#define get_Norig_rows _get_Norig_rows\n#define get_Nrows _get_Nrows\n#define get_obj_bound _get_obj_bound\n#define get_objective _get_objective\n#define get_orig_index _get_orig_index\n#define get_origcol_name _get_origcol_name\n#define get_origrow_name _get_origrow_name\n#define get_partialprice _get_partialprice\n#define get_pivoting _get_pivoting\n#define get_presolve _get_presolve\n#define get_presolveloops _get_presolveloops\n#define get_primal_solution _get_primal_solution\n#define get_print_sol _get_print_sol\n#define get_pseudocosts _get_pseudocosts\n#define get_ptr_constraints _get_ptr_constraints\n#define get_ptr_dual_solution _get_ptr_dual_solution\n#define get_ptr_lambda _get_ptr_lambda\n#define get_ptr_primal_solution _get_ptr_primal_solution\n#define get_ptr_sensitivity_obj _get_ptr_sensitivity_obj\n#define get_ptr_sensitivity_objex _get_ptr_sensitivity_objex\n#define get_ptr_sensitivity_rhs _get_ptr_sensitivity_rhs\n#define get_ptr_variables _get_ptr_variables\n#define get_rh _get_rh\n#define get_rh_range _get_rh_range\n#define get_row _get_row\n#define get_row_name _get_row_name\n#define get_scalelimit _get_scalelimit\n#define get_scaling _get_scaling\n#define get_sensitivity_obj _get_sensitivity_obj\n#define get_sensitivity_objex _get_sensitivity_objex\n#define get_sensitivity_rhs _get_sensitivity_rhs\n#define get_simplextype _get_simplextype\n#define get_solutioncount _get_solutioncount\n#define get_solutionlimit _get_solutionlimit\n#define get_status _get_status\n#define get_statustext _get_statustext\n#define get_timeout _get_timeout\n#define get_total_iter _get_total_iter\n#define get_total_nodes _get_total_nodes\n#define get_upbo _get_upbo\n#define get_var_branch _get_var_branch\n#define get_var_dualresult _get_var_dualresult\n#define get_var_primalresult _get_var_primalresult\n#define get_var_priority _get_var_priority\n#define get_variables _get_variables\n#define get_verbose _get_verbose\n#define get_working_objective _get_working_objective\n#define has_BFP _has_BFP\n#define has_XLI _has_XLI\n#define is_add_rowmode _is_add_rowmode\n#define is_anti_degen _is_anti_degen\n#define is_binary _is_binary\n#define is_break_at_first _is_break_at_first\n#define is_constr_type _is_constr_type\n#define is_debug _is_debug\n#define is_feasible _is_feasible\n#define is_unbounded _is_unbounded\n#define is_infinite _is_infinite\n#define is_int _is_int\n#define is_integerscaling _is_integerscaling\n#define is_lag_trace _is_lag_trace\n#define is_maxim _is_maxim\n#define is_nativeBFP _is_nativeBFP\n#define is_nativeXLI _is_nativeXLI\n#define is_negative _is_negative\n#define is_piv_mode _is_piv_mode\n#define is_piv_rule _is_piv_rule\n#define is_presolve _is_presolve\n#define is_scalemode _is_scalemode\n#define is_scaletype _is_scaletype\n#define is_semicont _is_semicont\n#define is_SOS_var _is_SOS_var\n#define is_trace _is_trace\n#define lp_solve_version _lp_solve_version\n#define make_lp _make_lp\n#define print_constraints _print_constraints\n#define print_debugdump _print_debugdump\n#define print_duals _print_duals\n#define print_lp _print_lp\n#define print_objective _print_objective\n#define print_scales _print_scales\n#define print_solution _print_solution\n#define print_str _print_str\n#define print_tableau _print_tableau\n#define put_abortfunc _put_abortfunc\n#define put_bb_nodefunc _put_bb_nodefunc\n#define put_bb_branchfunc _put_bb_branchfunc\n#define put_logfunc _put_logfunc\n#define put_msgfunc _put_msgfunc\n#define read_LPhandle _read_LPhandle\n#define read_MPShandle _read_MPShandle\n#define read_XLI _read_XLI\n#define read_params _read_params\n#define read_basis _read_basis\n#define reset_basis _reset_basis\n#define reset_params _reset_params\n#define resize_lp _resize_lp\n#define set_add_rowmode _set_add_rowmode\n#define set_anti_degen _set_anti_degen\n#define set_basisvar _set_basisvar\n#define set_basis _set_basis\n#define set_basiscrash _set_basiscrash\n#define set_bb_depthlimit _set_bb_depthlimit\n#define set_bb_floorfirst _set_bb_floorfirst\n#define set_bb_rule _set_bb_rule\n#define set_BFP _set_BFP\n#define set_binary _set_binary\n#define set_bounds _set_bounds\n#define set_bounds_tighter _set_bounds_tighter\n#define set_break_at_first _set_break_at_first\n#define set_break_at_value _set_break_at_value\n#define set_column _set_column\n#define set_columnex _set_columnex\n#define set_col_name _set_col_name\n#define set_constr_type _set_constr_type\n#define set_debug _set_debug\n#define set_epsb _set_epsb\n#define set_epsd _set_epsd\n#define set_epsel _set_epsel\n#define set_epsint _set_epsint\n#define set_epslevel _set_epslevel\n#define set_epsperturb _set_epsperturb\n#define set_epspivot _set_epspivot\n#define set_unbounded _set_unbounded\n#define set_improve _set_improve\n#define set_infinite _set_infinite\n#define set_int _set_int\n#define set_lag_trace _set_lag_trace\n#define set_lowbo _set_lowbo\n#define set_lp_name _set_lp_name\n#define set_mat _set_mat\n#define set_maxim _set_maxim\n#define set_maxpivot _set_maxpivot\n#define set_minim _set_minim\n#define set_mip_gap _set_mip_gap\n#define set_multiprice _set_multiprice\n#define set_negrange _set_negrange\n#define set_obj_bound _set_obj_bound\n#define set_obj_fn _set_obj_fn\n#define set_obj_fnex _set_obj_fnex\n#define set_obj _set_obj\n#define set_outputfile _set_outputfile\n#define set_outputstream _set_outputstream\n#define set_partialprice _set_partialprice\n#define set_pivoting _set_pivoting\n#define set_preferdual _set_preferdual\n#define set_presolve _set_presolve\n#define set_print_sol _set_print_sol\n#define set_pseudocosts _set_pseudocosts\n#define set_rh _set_rh\n#define set_rh_range _set_rh_range\n#define set_rh_vec _set_rh_vec\n#define set_row _set_row\n#define set_rowex _set_rowex\n#define set_row_name _set_row_name\n#define set_scalelimit _set_scalelimit\n#define set_scaling _set_scaling\n#define set_semicont _set_semicont\n#define set_sense _set_sense\n#define set_simplextype _set_simplextype\n#define set_solutionlimit _set_solutionlimit\n#define set_timeout _set_timeout\n#define set_trace _set_trace\n#define set_upbo _set_upbo\n#define set_var_branch _set_var_branch\n#define set_var_weights _set_var_weights\n#define set_verbose _set_verbose\n#define set_XLI _set_XLI\n#define solve _solve\n#define str_add_column _str_add_column\n#define str_add_constraint _str_add_constraint\n#define str_add_lag_con _str_add_lag_con\n#define str_set_obj_fn _str_set_obj_fn\n#define str_set_rh_vec _str_set_rh_vec\n#define time_elapsed _time_elapsed\n#define unscale _unscale\n#define write_lp _write_lp\n#define write_LP _write_LP\n#define write_mps _write_mps\n#define write_MPS _write_MPS\n#define write_freemps _write_freemps\n#define write_freeMPS _write_freeMPS\n#define write_XLI _write_XLI\n#define write_basis _write_basis\n#define write_params _write_params\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-r-lpsolve-5.6.13.2-2p7y34czadwk3yceelxxk5stmkcgrmfe/spack-src/src/lp_matrix.c"
    ],
    "total_files": 91
}