{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-rsync-3.1.1-osiiinomiblpjrgkaah3q3xyqnp5nzdx/spack-src/util.c": "/*\n * Utility routines used in rsync.\n *\n * Copyright (C) 1996-2000 Andrew Tridgell\n * Copyright (C) 1996 Paul Mackerras\n * Copyright (C) 2001, 2002 Martin Pool <mbp@samba.org>\n * Copyright (C) 2003-2014 Wayne Davison\n *\n * This program is free software; you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation; either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License along\n * with this program; if not, visit the http://fsf.org website.\n */\n\n#include \"rsync.h\"\n#include \"ifuncs.h\"\n#include \"itypes.h\"\n#include \"inums.h\"\n\nextern int dry_run;\nextern int module_id;\nextern int protect_args;\nextern int modify_window;\nextern int relative_paths;\nextern int preserve_times;\nextern int preserve_xattrs;\nextern int preallocate_files;\nextern char *module_dir;\nextern unsigned int module_dirlen;\nextern char *partial_dir;\nextern filter_rule_list daemon_filter_list;\n\nint sanitize_paths = 0;\n\nchar curr_dir[MAXPATHLEN];\nunsigned int curr_dir_len;\nint curr_dir_depth; /* This is only set for a sanitizing daemon. */\n\n/* Set a fd into nonblocking mode. */\nvoid set_nonblocking(int fd)\n{\n\tint val;\n\n\tif ((val = fcntl(fd, F_GETFL)) == -1)\n\t\treturn;\n\tif (!(val & NONBLOCK_FLAG)) {\n\t\tval |= NONBLOCK_FLAG;\n\t\tfcntl(fd, F_SETFL, val);\n\t}\n}\n\n/* Set a fd into blocking mode. */\nvoid set_blocking(int fd)\n{\n\tint val;\n\n\tif ((val = fcntl(fd, F_GETFL)) == -1)\n\t\treturn;\n\tif (val & NONBLOCK_FLAG) {\n\t\tval &= ~NONBLOCK_FLAG;\n\t\tfcntl(fd, F_SETFL, val);\n\t}\n}\n\n/**\n * Create a file descriptor pair - like pipe() but use socketpair if\n * possible (because of blocking issues on pipes).\n *\n * Always set non-blocking.\n */\nint fd_pair(int fd[2])\n{\n\tint ret;\n\n#ifdef HAVE_SOCKETPAIR\n\tret = socketpair(AF_UNIX, SOCK_STREAM, 0, fd);\n#else\n\tret = pipe(fd);\n#endif\n\n\tif (ret == 0) {\n\t\tset_nonblocking(fd[0]);\n\t\tset_nonblocking(fd[1]);\n\t}\n\n\treturn ret;\n}\n\nvoid print_child_argv(const char *prefix, char **cmd)\n{\n\tint cnt = 0;\n\trprintf(FCLIENT, \"%s \", prefix);\n\tfor (; *cmd; cmd++) {\n\t\t/* Look for characters that ought to be quoted.  This\n\t\t* is not a great quoting algorithm, but it's\n\t\t* sufficient for a log message. */\n\t\tif (strspn(*cmd, \"abcdefghijklmnopqrstuvwxyz\"\n\t\t\t   \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\t\t\t   \"0123456789\"\n\t\t\t   \",.-_=+@/\") != strlen(*cmd)) {\n\t\t\trprintf(FCLIENT, \"\\\"%s\\\" \", *cmd);\n\t\t} else {\n\t\t\trprintf(FCLIENT, \"%s \", *cmd);\n\t\t}\n\t\tcnt++;\n\t}\n\trprintf(FCLIENT, \" (%d args)\\n\", cnt);\n}\n\n/* This returns 0 for success, 1 for a symlink if symlink time-setting\n * is not possible, or -1 for any other error. */\nint set_modtime(const char *fname, time_t modtime, uint32 mod_nsec, mode_t mode)\n{\n\tstatic int switch_step = 0;\n\n\tif (DEBUG_GTE(TIME, 1)) {\n\t\trprintf(FINFO, \"set modtime of %s to (%ld) %s\",\n\t\t\tfname, (long)modtime,\n\t\t\tasctime(localtime(&modtime)));\n\t}\n\n\tswitch (switch_step) {\n#ifdef HAVE_UTIMENSAT\n#include \"case_N.h\"\n\t\tif (do_utimensat(fname, modtime, mod_nsec) == 0)\n\t\t\tbreak;\n\t\tif (errno != ENOSYS)\n\t\t\treturn -1;\n\t\tswitch_step++;\n\t\t/* FALLTHROUGH */\n#endif\n\n#ifdef HAVE_LUTIMES\n#include \"case_N.h\"\n\t\tif (do_lutimes(fname, modtime, mod_nsec) == 0)\n\t\t\tbreak;\n\t\tif (errno != ENOSYS)\n\t\t\treturn -1;\n\t\tswitch_step++;\n\t\t/* FALLTHROUGH */\n#endif\n\n#include \"case_N.h\"\n\t\tswitch_step++;\n\t\tif (preserve_times & PRESERVE_LINK_TIMES) {\n\t\t\tpreserve_times &= ~PRESERVE_LINK_TIMES;\n\t\t\tif (S_ISLNK(mode))\n\t\t\t\treturn 1;\n\t\t}\n\t\t/* FALLTHROUGH */\n\n#include \"case_N.h\"\n#ifdef HAVE_UTIMES\n\t\tif (do_utimes(fname, modtime, mod_nsec) == 0)\n\t\t\tbreak;\n#else\n\t\tif (do_utime(fname, modtime, mod_nsec) == 0)\n\t\t\tbreak;\n#endif\n\n\t\treturn -1;\n\t}\n\n\treturn 0;\n}\n\n/* Create any necessary directories in fname.  Any missing directories are\n * created with default permissions.  Returns < 0 on error, or the number\n * of directories created. */\nint make_path(char *fname, int flags)\n{\n\tchar *end, *p;\n\tint ret = 0;\n\n\tif (flags & MKP_SKIP_SLASH) {\n\t\twhile (*fname == '/')\n\t\t\tfname++;\n\t}\n\n\twhile (*fname == '.' && fname[1] == '/')\n\t\tfname += 2;\n\n\tif (flags & MKP_DROP_NAME) {\n\t\tend = strrchr(fname, '/');\n\t\tif (!end)\n\t\t\treturn 0;\n\t\t*end = '\\0';\n\t} else\n\t\tend = fname + strlen(fname);\n\n\t/* Try to find an existing dir, starting from the deepest dir. */\n\tfor (p = end; ; ) {\n\t\tif (dry_run) {\n\t\t\tSTRUCT_STAT st;\n\t\t\tif (do_stat(fname, &st) == 0) {\n\t\t\t\tif (S_ISDIR(st.st_mode))\n\t\t\t\t\terrno = EEXIST;\n\t\t\t\telse\n\t\t\t\t\terrno = ENOTDIR;\n\t\t\t}\n\t\t} else if (do_mkdir(fname, ACCESSPERMS) == 0) {\n\t\t\tret++;\n\t\t\tbreak;\n\t\t}\n\t\tif (errno != ENOENT) {\n\t\t\tif (errno != EEXIST)\n\t\t\t\tret = -ret - 1;\n\t\t\tbreak;\n\t\t}\n\t\twhile (1) {\n\t\t\tif (p == fname) {\n\t\t\t\t/* We got a relative path that doesn't exist, so assume that '.'\n\t\t\t\t * is there and just break out and create the whole thing. */\n\t\t\t\tp = NULL;\n\t\t\t\tgoto double_break;\n\t\t\t}\n\t\t\tif (*--p == '/') {\n\t\t\t\tif (p == fname) {\n\t\t\t\t\t/* We reached the \"/\" dir, which we assume is there. */\n\t\t\t\t\tgoto double_break;\n\t\t\t\t}\n\t\t\t\t*p = '\\0';\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n  double_break:\n\n\t/* Make all the dirs that we didn't find on the way here. */\n\twhile (p != end) {\n\t\tif (p)\n\t\t\t*p = '/';\n\t\telse\n\t\t\tp = fname;\n\t\tp += strlen(p);\n\t\tif (ret < 0) /* Skip mkdir on error, but keep restoring the path. */\n\t\t\tcontinue;\n\t\tif (do_mkdir(fname, ACCESSPERMS) < 0)\n\t\t\tret = -ret - 1;\n\t\telse\n\t\t\tret++;\n\t}\n\n\tif (flags & MKP_DROP_NAME)\n\t\t*end = '/';\n\n\treturn ret;\n}\n\n/**\n * Write @p len bytes at @p ptr to descriptor @p desc, retrying if\n * interrupted.\n *\n * @retval len upon success\n *\n * @retval <0 write's (negative) error code\n *\n * Derived from GNU C's cccp.c.\n */\nint full_write(int desc, const char *ptr, size_t len)\n{\n\tint total_written;\n\n\ttotal_written = 0;\n\twhile (len > 0) {\n\t\tint written = write(desc, ptr, len);\n\t\tif (written < 0)  {\n\t\t\tif (errno == EINTR)\n\t\t\t\tcontinue;\n\t\t\treturn written;\n\t\t}\n\t\ttotal_written += written;\n\t\tptr += written;\n\t\tlen -= written;\n\t}\n\treturn total_written;\n}\n\n/**\n * Read @p len bytes at @p ptr from descriptor @p desc, retrying if\n * interrupted.\n *\n * @retval >0 the actual number of bytes read\n *\n * @retval 0 for EOF\n *\n * @retval <0 for an error.\n *\n * Derived from GNU C's cccp.c. */\nstatic int safe_read(int desc, char *ptr, size_t len)\n{\n\tint n_chars;\n\n\tif (len == 0)\n\t\treturn len;\n\n\tdo {\n\t\tn_chars = read(desc, ptr, len);\n\t} while (n_chars < 0 && errno == EINTR);\n\n\treturn n_chars;\n}\n\n/* Copy a file.  If ofd < 0, copy_file unlinks and opens the \"dest\" file.\n * Otherwise, it just writes to and closes the provided file descriptor.\n * In either case, if --xattrs are being preserved, the dest file will\n * have its xattrs set from the source file.\n *\n * This is used in conjunction with the --temp-dir, --backup, and\n * --copy-dest options. */\nint copy_file(const char *source, const char *dest, int ofd, mode_t mode)\n{\n\tint ifd;\n\tchar buf[1024 * 8];\n\tint len;   /* Number of bytes read into `buf'. */\n#ifdef PREALLOCATE_NEEDS_TRUNCATE\n\tOFF_T preallocated_len = 0, offset = 0;\n#endif\n\n\tif ((ifd = do_open(source, O_RDONLY, 0)) < 0) {\n\t\tint save_errno = errno;\n\t\trsyserr(FERROR_XFER, errno, \"open %s\", full_fname(source));\n\t\terrno = save_errno;\n\t\treturn -1;\n\t}\n\n\tif (ofd < 0) {\n\t\tif (robust_unlink(dest) && errno != ENOENT) {\n\t\t\tint save_errno = errno;\n\t\t\trsyserr(FERROR_XFER, errno, \"unlink %s\", full_fname(dest));\n\t\t\terrno = save_errno;\n\t\t\treturn -1;\n\t\t}\n\n#ifdef SUPPORT_XATTRS\n\t\tif (preserve_xattrs)\n\t\t\tmode |= S_IWUSR;\n#endif\n\t\tmode &= INITACCESSPERMS;\n\t\tif ((ofd = do_open(dest, O_WRONLY | O_CREAT | O_TRUNC | O_EXCL, mode)) < 0) {\n\t\t\tint save_errno = errno;\n\t\t\trsyserr(FERROR_XFER, save_errno, \"open %s\", full_fname(dest));\n\t\t\tclose(ifd);\n\t\t\terrno = save_errno;\n\t\t\treturn -1;\n\t\t}\n\t}\n\n#ifdef SUPPORT_PREALLOCATION\n\tif (preallocate_files) {\n\t\tSTRUCT_STAT srcst;\n\n\t\t/* Try to preallocate enough space for file's eventual length.  Can\n\t\t * reduce fragmentation on filesystems like ext4, xfs, and NTFS. */\n\t\tif (do_fstat(ifd, &srcst) < 0)\n\t\t\trsyserr(FWARNING, errno, \"fstat %s\", full_fname(source));\n\t\telse if (srcst.st_size > 0) {\n\t\t\tif (do_fallocate(ofd, 0, srcst.st_size) == 0) {\n#ifdef PREALLOCATE_NEEDS_TRUNCATE\n\t\t\t\tpreallocated_len = srcst.st_size;\n#endif\n\t\t\t} else\n\t\t\t\trsyserr(FWARNING, errno, \"do_fallocate %s\", full_fname(dest));\n\t\t}\n\t}\n#endif\n\n\twhile ((len = safe_read(ifd, buf, sizeof buf)) > 0) {\n\t\tif (full_write(ofd, buf, len) < 0) {\n\t\t\tint save_errno = errno;\n\t\t\trsyserr(FERROR_XFER, errno, \"write %s\", full_fname(dest));\n\t\t\tclose(ifd);\n\t\t\tclose(ofd);\n\t\t\terrno = save_errno;\n\t\t\treturn -1;\n\t\t}\n#ifdef PREALLOCATE_NEEDS_TRUNCATE\n\t\toffset += len;\n#endif\n\t}\n\n\tif (len < 0) {\n\t\tint save_errno = errno;\n\t\trsyserr(FERROR_XFER, errno, \"read %s\", full_fname(source));\n\t\tclose(ifd);\n\t\tclose(ofd);\n\t\terrno = save_errno;\n\t\treturn -1;\n\t}\n\n\tif (close(ifd) < 0) {\n\t\trsyserr(FWARNING, errno, \"close failed on %s\",\n\t\t\tfull_fname(source));\n\t}\n\n#ifdef PREALLOCATE_NEEDS_TRUNCATE\n\t/* Source file might have shrunk since we fstatted it.\n\t * Cut off any extra preallocated zeros from dest file. */\n\tif (offset < preallocated_len && do_ftruncate(ofd, offset) < 0) {\n\t\t/* If we fail to truncate, the dest file may be wrong, so we\n\t\t * must trigger the \"partial transfer\" error. */\n\t\trsyserr(FERROR_XFER, errno, \"ftruncate %s\", full_fname(dest));\n\t}\n#endif\n\n\tif (close(ofd) < 0) {\n\t\tint save_errno = errno;\n\t\trsyserr(FERROR_XFER, errno, \"close failed on %s\",\n\t\t\tfull_fname(dest));\n\t\terrno = save_errno;\n\t\treturn -1;\n\t}\n\n#ifdef SUPPORT_XATTRS\n\tif (preserve_xattrs)\n\t\tcopy_xattrs(source, dest);\n#endif\n\n\treturn 0;\n}\n\n/* MAX_RENAMES should be 10**MAX_RENAMES_DIGITS */\n#define MAX_RENAMES_DIGITS 3\n#define MAX_RENAMES 1000\n\n/**\n * Robust unlink: some OS'es (HPUX) refuse to unlink busy files, so\n * rename to <path>/.rsyncNNN instead.\n *\n * Note that successive rsync runs will shuffle the filenames around a\n * bit as long as the file is still busy; this is because this function\n * does not know if the unlink call is due to a new file coming in, or\n * --delete trying to remove old .rsyncNNN files, hence it renames it\n * each time.\n **/\nint robust_unlink(const char *fname)\n{\n#ifndef ETXTBSY\n\treturn do_unlink(fname);\n#else\n\tstatic int counter = 1;\n\tint rc, pos, start;\n\tchar path[MAXPATHLEN];\n\n\trc = do_unlink(fname);\n\tif (rc == 0 || errno != ETXTBSY)\n\t\treturn rc;\n\n\tif ((pos = strlcpy(path, fname, MAXPATHLEN)) >= MAXPATHLEN)\n\t\tpos = MAXPATHLEN - 1;\n\n\twhile (pos > 0 && path[pos-1] != '/')\n\t\tpos--;\n\tpos += strlcpy(path+pos, \".rsync\", MAXPATHLEN-pos);\n\n\tif (pos > (MAXPATHLEN-MAX_RENAMES_DIGITS-1)) {\n\t\terrno = ETXTBSY;\n\t\treturn -1;\n\t}\n\n\t/* start where the last one left off to reduce chance of clashes */\n\tstart = counter;\n\tdo {\n\t\tsnprintf(&path[pos], MAX_RENAMES_DIGITS+1, \"%03d\", counter);\n\t\tif (++counter >= MAX_RENAMES)\n\t\t\tcounter = 1;\n\t} while ((rc = access(path, 0)) == 0 && counter != start);\n\n\tif (INFO_GTE(MISC, 1)) {\n\t\trprintf(FWARNING, \"renaming %s to %s because of text busy\\n\",\n\t\t\tfname, path);\n\t}\n\n\t/* maybe we should return rename()'s exit status? Nah. */\n\tif (do_rename(fname, path) != 0) {\n\t\terrno = ETXTBSY;\n\t\treturn -1;\n\t}\n\treturn 0;\n#endif\n}\n\n/* Returns 0 on successful rename, 1 if we successfully copied the file\n * across filesystems, -2 if copy_file() failed, and -1 on other errors.\n * If partialptr is not NULL and we need to do a copy, copy the file into\n * the active partial-dir instead of over the destination file. */\nint robust_rename(const char *from, const char *to, const char *partialptr,\n\t\t  int mode)\n{\n\tint tries = 4;\n\n\twhile (tries--) {\n\t\tif (do_rename(from, to) == 0)\n\t\t\treturn 0;\n\n\t\tswitch (errno) {\n#ifdef ETXTBSY\n\t\tcase ETXTBSY:\n\t\t\tif (robust_unlink(to) != 0) {\n\t\t\t\terrno = ETXTBSY;\n\t\t\t\treturn -1;\n\t\t\t}\n\t\t\terrno = ETXTBSY;\n\t\t\tbreak;\n#endif\n\t\tcase EXDEV:\n\t\t\tif (partialptr) {\n\t\t\t\tif (!handle_partial_dir(partialptr,PDIR_CREATE))\n\t\t\t\t\treturn -2;\n\t\t\t\tto = partialptr;\n\t\t\t}\n\t\t\tif (copy_file(from, to, -1, mode) != 0)\n\t\t\t\treturn -2;\n\t\t\tdo_unlink(from);\n\t\t\treturn 1;\n\t\tdefault:\n\t\t\treturn -1;\n\t\t}\n\t}\n\treturn -1;\n}\n\nstatic pid_t all_pids[10];\nstatic int num_pids;\n\n/** Fork and record the pid of the child. **/\npid_t do_fork(void)\n{\n\tpid_t newpid = fork();\n\n\tif (newpid != 0  &&  newpid != -1) {\n\t\tall_pids[num_pids++] = newpid;\n\t}\n\treturn newpid;\n}\n\n/**\n * Kill all children.\n *\n * @todo It would be kind of nice to make sure that they are actually\n * all our children before we kill them, because their pids may have\n * been recycled by some other process.  Perhaps when we wait for a\n * child, we should remove it from this array.  Alternatively we could\n * perhaps use process groups, but I think that would not work on\n * ancient Unix versions that don't support them.\n **/\nvoid kill_all(int sig)\n{\n\tint i;\n\n\tfor (i = 0; i < num_pids; i++) {\n\t\t/* Let's just be a little careful where we\n\t\t * point that gun, hey?  See kill(2) for the\n\t\t * magic caused by negative values. */\n\t\tpid_t p = all_pids[i];\n\n\t\tif (p == getpid())\n\t\t\tcontinue;\n\t\tif (p <= 0)\n\t\t\tcontinue;\n\n\t\tkill(p, sig);\n\t}\n}\n\n/** Lock a byte range in a open file */\nint lock_range(int fd, int offset, int len)\n{\n\tstruct flock lock;\n\n\tlock.l_type = F_WRLCK;\n\tlock.l_whence = SEEK_SET;\n\tlock.l_start = offset;\n\tlock.l_len = len;\n\tlock.l_pid = 0;\n\n\treturn fcntl(fd,F_SETLK,&lock) == 0;\n}\n\n#define ENSURE_MEMSPACE(buf, type, sz, req) \\\n\tif ((req) > sz && !(buf = realloc_array(buf, type, sz = MAX(sz * 2, req)))) \\\n\t\tout_of_memory(\"glob_expand\")\n\nstatic inline void call_glob_match(const char *name, int len, int from_glob,\n\t\t\t\t   char *arg, int abpos, int fbpos);\n\nstatic struct glob_data {\n\tchar *arg_buf, *filt_buf, **argv;\n\tint absize, fbsize, maxargs, argc;\n} glob;\n\nstatic void glob_match(char *arg, int abpos, int fbpos)\n{\n\tint len;\n\tchar *slash;\n\n\twhile (*arg == '.' && arg[1] == '/') {\n\t\tif (fbpos < 0) {\n\t\t\tENSURE_MEMSPACE(glob.filt_buf, char, glob.fbsize, glob.absize);\n\t\t\tmemcpy(glob.filt_buf, glob.arg_buf, abpos + 1);\n\t\t\tfbpos = abpos;\n\t\t}\n\t\tENSURE_MEMSPACE(glob.arg_buf, char, glob.absize, abpos + 3);\n\t\tglob.arg_buf[abpos++] = *arg++;\n\t\tglob.arg_buf[abpos++] = *arg++;\n\t\tglob.arg_buf[abpos] = '\\0';\n\t}\n\tif ((slash = strchr(arg, '/')) != NULL) {\n\t\t*slash = '\\0';\n\t\tlen = slash - arg;\n\t} else\n\t\tlen = strlen(arg);\n\tif (strpbrk(arg, \"*?[\")) {\n\t\tstruct dirent *di;\n\t\tDIR *d;\n\n\t\tif (!(d = opendir(abpos ? glob.arg_buf : \".\")))\n\t\t\treturn;\n\t\twhile ((di = readdir(d)) != NULL) {\n\t\t\tchar *dname = d_name(di);\n\t\t\tif (dname[0] == '.' && (dname[1] == '\\0'\n\t\t\t  || (dname[1] == '.' && dname[2] == '\\0')))\n\t\t\t\tcontinue;\n\t\t\tif (!wildmatch(arg, dname))\n\t\t\t\tcontinue;\n\t\t\tcall_glob_match(dname, strlen(dname), 1,\n\t\t\t\t\tslash ? arg + len + 1 : NULL,\n\t\t\t\t\tabpos, fbpos);\n\t\t}\n\t\tclosedir(d);\n\t} else {\n\t\tcall_glob_match(arg, len, 0,\n\t\t\t\tslash ? arg + len + 1 : NULL,\n\t\t\t\tabpos, fbpos);\n\t}\n\tif (slash)\n\t\t*slash = '/';\n}\n\nstatic inline void call_glob_match(const char *name, int len, int from_glob,\n\t\t\t\t   char *arg, int abpos, int fbpos)\n{\n\tchar *use_buf;\n\n\tENSURE_MEMSPACE(glob.arg_buf, char, glob.absize, abpos + len + 2);\n\tmemcpy(glob.arg_buf + abpos, name, len);\n\tabpos += len;\n\tglob.arg_buf[abpos] = '\\0';\n\n\tif (fbpos >= 0) {\n\t\tENSURE_MEMSPACE(glob.filt_buf, char, glob.fbsize, fbpos + len + 2);\n\t\tmemcpy(glob.filt_buf + fbpos, name, len);\n\t\tfbpos += len;\n\t\tglob.filt_buf[fbpos] = '\\0';\n\t\tuse_buf = glob.filt_buf;\n\t} else\n\t\tuse_buf = glob.arg_buf;\n\n\tif (from_glob || (arg && len)) {\n\t\tSTRUCT_STAT st;\n\t\tint is_dir;\n\n\t\tif (do_stat(glob.arg_buf, &st) != 0)\n\t\t\treturn;\n\t\tis_dir = S_ISDIR(st.st_mode) != 0;\n\t\tif (arg && !is_dir)\n\t\t\treturn;\n\n\t\tif (daemon_filter_list.head\n\t\t && check_filter(&daemon_filter_list, FLOG, use_buf, is_dir) < 0)\n\t\t\treturn;\n\t}\n\n\tif (arg) {\n\t\tglob.arg_buf[abpos++] = '/';\n\t\tglob.arg_buf[abpos] = '\\0';\n\t\tif (fbpos >= 0) {\n\t\t\tglob.filt_buf[fbpos++] = '/';\n\t\t\tglob.filt_buf[fbpos] = '\\0';\n\t\t}\n\t\tglob_match(arg, abpos, fbpos);\n\t} else {\n\t\tENSURE_MEMSPACE(glob.argv, char *, glob.maxargs, glob.argc + 1);\n\t\tif (!(glob.argv[glob.argc++] = strdup(glob.arg_buf)))\n\t\t\tout_of_memory(\"glob_match\");\n\t}\n}\n\n/* This routine performs wild-card expansion of the pathname in \"arg\".  Any\n * daemon-excluded files/dirs will not be matched by the wildcards.  Returns 0\n * if a wild-card string is the only returned item (due to matching nothing). */\nint glob_expand(const char *arg, char ***argv_p, int *argc_p, int *maxargs_p)\n{\n\tint ret, save_argc;\n\tchar *s;\n\n\tif (!arg) {\n\t\tif (glob.filt_buf)\n\t\t\tfree(glob.filt_buf);\n\t\tfree(glob.arg_buf);\n\t\tmemset(&glob, 0, sizeof glob);\n\t\treturn -1;\n\t}\n\n\tif (sanitize_paths)\n\t\ts = sanitize_path(NULL, arg, \"\", 0, SP_KEEP_DOT_DIRS);\n\telse {\n\t\ts = strdup(arg);\n\t\tif (!s)\n\t\t\tout_of_memory(\"glob_expand\");\n\t\tclean_fname(s, CFN_KEEP_DOT_DIRS\n\t\t\t     | CFN_KEEP_TRAILING_SLASH\n\t\t\t     | CFN_COLLAPSE_DOT_DOT_DIRS);\n\t}\n\n\tENSURE_MEMSPACE(glob.arg_buf, char, glob.absize, MAXPATHLEN);\n\t*glob.arg_buf = '\\0';\n\n\tglob.argc = save_argc = *argc_p;\n\tglob.argv = *argv_p;\n\tglob.maxargs = *maxargs_p;\n\n\tENSURE_MEMSPACE(glob.argv, char *, glob.maxargs, 100);\n\n\tglob_match(s, 0, -1);\n\n\t/* The arg didn't match anything, so add the failed arg to the list. */\n\tif (glob.argc == save_argc) {\n\t\tENSURE_MEMSPACE(glob.argv, char *, glob.maxargs, glob.argc + 1);\n\t\tglob.argv[glob.argc++] = s;\n\t\tret = 0;\n\t} else {\n\t\tfree(s);\n\t\tret = 1;\n\t}\n\n\t*maxargs_p = glob.maxargs;\n\t*argv_p = glob.argv;\n\t*argc_p = glob.argc;\n\n\treturn ret;\n}\n\n/* This routine is only used in daemon mode. */\nvoid glob_expand_module(char *base1, char *arg, char ***argv_p, int *argc_p, int *maxargs_p)\n{\n\tchar *p, *s;\n\tchar *base = base1;\n\tint base_len = strlen(base);\n\n\tif (!arg || !*arg)\n\t\treturn;\n\n\tif (strncmp(arg, base, base_len) == 0)\n\t\targ += base_len;\n\n\tif (protect_args) {\n\t\tglob_expand(arg, argv_p, argc_p, maxargs_p);\n\t\treturn;\n\t}\n\n\tif (!(arg = strdup(arg)))\n\t\tout_of_memory(\"glob_expand_module\");\n\n\tif (asprintf(&base,\" %s/\", base1) < 0)\n\t\tout_of_memory(\"glob_expand_module\");\n\tbase_len++;\n\n\tfor (s = arg; *s; s = p + base_len) {\n\t\tif ((p = strstr(s, base)) != NULL)\n\t\t\t*p = '\\0'; /* split it at this point */\n\t\tglob_expand(s, argv_p, argc_p, maxargs_p);\n\t\tif (!p)\n\t\t\tbreak;\n\t}\n\n\tfree(arg);\n\tfree(base);\n}\n\n/**\n * Convert a string to lower case\n **/\nvoid strlower(char *s)\n{\n\twhile (*s) {\n\t\tif (isUpper(s))\n\t\t\t*s = toLower(s);\n\t\ts++;\n\t}\n}\n\n/* Join strings p1 & p2 into \"dest\" with a guaranteed '/' between them.  (If\n * p1 ends with a '/', no extra '/' is inserted.)  Returns the length of both\n * strings + 1 (if '/' was inserted), regardless of whether the null-terminated\n * string fits into destsize. */\nsize_t pathjoin(char *dest, size_t destsize, const char *p1, const char *p2)\n{\n\tsize_t len = strlcpy(dest, p1, destsize);\n\tif (len < destsize - 1) {\n\t\tif (!len || dest[len-1] != '/')\n\t\t\tdest[len++] = '/';\n\t\tif (len < destsize - 1)\n\t\t\tlen += strlcpy(dest + len, p2, destsize - len);\n\t\telse {\n\t\t\tdest[len] = '\\0';\n\t\t\tlen += strlen(p2);\n\t\t}\n\t}\n\telse\n\t\tlen += strlen(p2) + 1; /* Assume we'd insert a '/'. */\n\treturn len;\n}\n\n/* Join any number of strings together, putting them in \"dest\".  The return\n * value is the length of all the strings, regardless of whether the null-\n * terminated whole fits in destsize.  Your list of string pointers must end\n * with a NULL to indicate the end of the list. */\nsize_t stringjoin(char *dest, size_t destsize, ...)\n{\n\tva_list ap;\n\tsize_t len, ret = 0;\n\tconst char *src;\n\n\tva_start(ap, destsize);\n\twhile (1) {\n\t\tif (!(src = va_arg(ap, const char *)))\n\t\t\tbreak;\n\t\tlen = strlen(src);\n\t\tret += len;\n\t\tif (destsize > 1) {\n\t\t\tif (len >= destsize)\n\t\t\t\tlen = destsize - 1;\n\t\t\tmemcpy(dest, src, len);\n\t\t\tdestsize -= len;\n\t\t\tdest += len;\n\t\t}\n\t}\n\t*dest = '\\0';\n\tva_end(ap);\n\n\treturn ret;\n}\n\nint count_dir_elements(const char *p)\n{\n\tint cnt = 0, new_component = 1;\n\twhile (*p) {\n\t\tif (*p++ == '/')\n\t\t\tnew_component = (*p != '.' || (p[1] != '/' && p[1] != '\\0'));\n\t\telse if (new_component) {\n\t\t\tnew_component = 0;\n\t\t\tcnt++;\n\t\t}\n\t}\n\treturn cnt;\n}\n\n/* Turns multiple adjacent slashes into a single slash (possible exception:\n * the preserving of two leading slashes at the start), drops all leading or\n * interior \".\" elements unless CFN_KEEP_DOT_DIRS is flagged.  Will also drop\n * a trailing '.' after a '/' if CFN_DROP_TRAILING_DOT_DIR is flagged, removes\n * a trailing slash (perhaps after removing the aforementioned dot) unless\n * CFN_KEEP_TRAILING_SLASH is flagged, and will also collapse \"..\" elements\n * (except at the start) if CFN_COLLAPSE_DOT_DOT_DIRS is flagged.  If the\n * resulting name would be empty, returns \".\". */\nint clean_fname(char *name, int flags)\n{\n\tchar *limit = name - 1, *t = name, *f = name;\n\tint anchored;\n\n\tif (!name)\n\t\treturn 0;\n\n#define DOT_IS_DOT_DOT_DIR(bp) (bp[1] == '.' && (bp[2] == '/' || !bp[2]))\n\n\tif ((anchored = *f == '/') != 0) {\n\t\t*t++ = *f++;\n#ifdef __CYGWIN__\n\t\t/* If there are exactly 2 slashes at the start, preserve\n\t\t * them.  Would break daemon excludes unless the paths are\n\t\t * really treated differently, so used this sparingly. */\n\t\tif (*f == '/' && f[1] != '/')\n\t\t\t*t++ = *f++;\n#endif\n\t} else if (flags & CFN_KEEP_DOT_DIRS && *f == '.' && f[1] == '/') {\n\t\t*t++ = *f++;\n\t\t*t++ = *f++;\n\t} else if (flags & CFN_REFUSE_DOT_DOT_DIRS && *f == '.' && DOT_IS_DOT_DOT_DIR(f))\n\t\treturn -1;\n\twhile (*f) {\n\t\t/* discard extra slashes */\n\t\tif (*f == '/') {\n\t\t\tf++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (*f == '.') {\n\t\t\t/* discard interior \".\" dirs */\n\t\t\tif (f[1] == '/' && !(flags & CFN_KEEP_DOT_DIRS)) {\n\t\t\t\tf += 2;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (f[1] == '\\0' && flags & CFN_DROP_TRAILING_DOT_DIR)\n\t\t\t\tbreak;\n\t\t\t/* collapse \"..\" dirs */\n\t\t\tif (flags & (CFN_COLLAPSE_DOT_DOT_DIRS|CFN_REFUSE_DOT_DOT_DIRS) && DOT_IS_DOT_DOT_DIR(f)) {\n\t\t\t\tchar *s = t - 1;\n\t\t\t\tif (flags & CFN_REFUSE_DOT_DOT_DIRS)\n\t\t\t\t\treturn -1;\n\t\t\t\tif (s == name && anchored) {\n\t\t\t\t\tf += 2;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\twhile (s > limit && *--s != '/') {}\n\t\t\t\tif (s != t - 1 && (s < name || *s == '/')) {\n\t\t\t\t\tt = s + 1;\n\t\t\t\t\tf += 2;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tlimit = t + 2;\n\t\t\t}\n\t\t}\n\t\twhile (*f && (*t++ = *f++) != '/') {}\n\t}\n\n\tif (t > name+anchored && t[-1] == '/' && !(flags & CFN_KEEP_TRAILING_SLASH))\n\t\tt--;\n\tif (t == name)\n\t\t*t++ = '.';\n\t*t = '\\0';\n\n#undef DOT_IS_DOT_DOT_DIR\n\n\treturn t - name;\n}\n\n/* Make path appear as if a chroot had occurred.  This handles a leading\n * \"/\" (either removing it or expanding it) and any leading or embedded\n * \"..\" components that attempt to escape past the module's top dir.\n *\n * If dest is NULL, a buffer is allocated to hold the result.  It is legal\n * to call with the dest and the path (p) pointing to the same buffer, but\n * rootdir will be ignored to avoid expansion of the string.\n *\n * The rootdir string contains a value to use in place of a leading slash.\n * Specify NULL to get the default of \"module_dir\".\n *\n * The depth var is a count of how many '..'s to allow at the start of the\n * path.\n *\n * We also clean the path in a manner similar to clean_fname() but with a\n * few differences:\n *\n * Turns multiple adjacent slashes into a single slash, gets rid of \".\" dir\n * elements (INCLUDING a trailing dot dir), PRESERVES a trailing slash, and\n * ALWAYS collapses \"..\" elements (except for those at the start of the\n * string up to \"depth\" deep).  If the resulting name would be empty,\n * change it into a \".\". */\nchar *sanitize_path(char *dest, const char *p, const char *rootdir, int depth,\n\t\t    int flags)\n{\n\tchar *start, *sanp;\n\tint rlen = 0, drop_dot_dirs = !relative_paths || !(flags & SP_KEEP_DOT_DIRS);\n\n\tif (dest != p) {\n\t\tint plen = strlen(p);\n\t\tif (*p == '/') {\n\t\t\tif (!rootdir)\n\t\t\t\trootdir = module_dir;\n\t\t\trlen = strlen(rootdir);\n\t\t\tdepth = 0;\n\t\t\tp++;\n\t\t}\n\t\tif (dest) {\n\t\t\tif (rlen + plen + 1 >= MAXPATHLEN)\n\t\t\t\treturn NULL;\n\t\t} else if (!(dest = new_array(char, rlen + plen + 1)))\n\t\t\tout_of_memory(\"sanitize_path\");\n\t\tif (rlen) {\n\t\t\tmemcpy(dest, rootdir, rlen);\n\t\t\tif (rlen > 1)\n\t\t\t\tdest[rlen++] = '/';\n\t\t}\n\t}\n\n\tif (drop_dot_dirs) {\n\t\twhile (*p == '.' && p[1] == '/')\n\t\t\tp += 2;\n\t}\n\n\tstart = sanp = dest + rlen;\n\t/* This loop iterates once per filename component in p, pointing at\n\t * the start of the name (past any prior slash) for each iteration. */\n\twhile (*p) {\n\t\t/* discard leading or extra slashes */\n\t\tif (*p == '/') {\n\t\t\tp++;\n\t\t\tcontinue;\n\t\t}\n\t\tif (drop_dot_dirs) {\n\t\t\tif (*p == '.' && (p[1] == '/' || p[1] == '\\0')) {\n\t\t\t\t/* skip \".\" component */\n\t\t\t\tp++;\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tif (*p == '.' && p[1] == '.' && (p[2] == '/' || p[2] == '\\0')) {\n\t\t\t/* \"..\" component followed by slash or end */\n\t\t\tif (depth <= 0 || sanp != start) {\n\t\t\t\tp += 2;\n\t\t\t\tif (sanp != start) {\n\t\t\t\t\t/* back up sanp one level */\n\t\t\t\t\t--sanp; /* now pointing at slash */\n\t\t\t\t\twhile (sanp > start && sanp[-1] != '/')\n\t\t\t\t\t\tsanp--;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\t/* allow depth levels of .. at the beginning */\n\t\t\tdepth--;\n\t\t\t/* move the virtual beginning to leave the .. alone */\n\t\t\tstart = sanp + 3;\n\t\t}\n\t\t/* copy one component through next slash */\n\t\twhile (*p && (*sanp++ = *p++) != '/') {}\n\t}\n\tif (sanp == dest) {\n\t\t/* ended up with nothing, so put in \".\" component */\n\t\t*sanp++ = '.';\n\t}\n\t*sanp = '\\0';\n\n\treturn dest;\n}\n\n/* Like chdir(), but it keeps track of the current directory (in the\n * global \"curr_dir\"), and ensures that the path size doesn't overflow.\n * Also cleans the path using the clean_fname() function. */\nint change_dir(const char *dir, int set_path_only)\n{\n\tstatic int initialised, skipped_chdir;\n\tunsigned int len;\n\n\tif (!initialised) {\n\t\tinitialised = 1;\n\t\tif (getcwd(curr_dir, sizeof curr_dir - 1) == NULL) {\n\t\t\trsyserr(FERROR, errno, \"getcwd()\");\n\t\t\texit_cleanup(RERR_FILESELECT);\n\t\t}\n\t\tcurr_dir_len = strlen(curr_dir);\n\t}\n\n\tif (!dir)\t/* this call was probably just to initialize */\n\t\treturn 0;\n\n\tlen = strlen(dir);\n\tif (len == 1 && *dir == '.' && (!skipped_chdir || set_path_only))\n\t\treturn 1;\n\n\tif (*dir == '/') {\n\t\tif (len >= sizeof curr_dir) {\n\t\t\terrno = ENAMETOOLONG;\n\t\t\treturn 0;\n\t\t}\n\t\tif (!set_path_only && chdir(dir))\n\t\t\treturn 0;\n\t\tskipped_chdir = set_path_only;\n\t\tmemcpy(curr_dir, dir, len + 1);\n\t} else {\n\t\tif (curr_dir_len + 1 + len >= sizeof curr_dir) {\n\t\t\terrno = ENAMETOOLONG;\n\t\t\treturn 0;\n\t\t}\n\t\tif (!(curr_dir_len && curr_dir[curr_dir_len-1] == '/'))\n\t\t\tcurr_dir[curr_dir_len++] = '/';\n\t\tmemcpy(curr_dir + curr_dir_len, dir, len + 1);\n\n\t\tif (!set_path_only && chdir(curr_dir)) {\n\t\t\tcurr_dir[curr_dir_len] = '\\0';\n\t\t\treturn 0;\n\t\t}\n\t\tskipped_chdir = set_path_only;\n\t}\n\n\tcurr_dir_len = clean_fname(curr_dir, CFN_COLLAPSE_DOT_DOT_DIRS | CFN_DROP_TRAILING_DOT_DIR);\n\tif (sanitize_paths) {\n\t\tif (module_dirlen > curr_dir_len)\n\t\t\tmodule_dirlen = curr_dir_len;\n\t\tcurr_dir_depth = count_dir_elements(curr_dir + module_dirlen);\n\t}\n\n\tif (DEBUG_GTE(CHDIR, 1) && !set_path_only)\n\t\trprintf(FINFO, \"[%s] change_dir(%s)\\n\", who_am_i(), curr_dir);\n\n\treturn 1;\n}\n\n/* This will make a relative path absolute and clean it up via clean_fname().\n * Returns the string, which might be newly allocated, or NULL on error. */\nchar *normalize_path(char *path, BOOL force_newbuf, unsigned int *len_ptr)\n{\n\tunsigned int len;\n\n\tif (*path != '/') { /* Make path absolute. */\n\t\tint len = strlen(path);\n\t\tif (curr_dir_len + 1 + len >= sizeof curr_dir)\n\t\t\treturn NULL;\n\t\tcurr_dir[curr_dir_len] = '/';\n\t\tmemcpy(curr_dir + curr_dir_len + 1, path, len + 1);\n\t\tif (!(path = strdup(curr_dir)))\n\t\t\tout_of_memory(\"normalize_path\");\n\t\tcurr_dir[curr_dir_len] = '\\0';\n\t} else if (force_newbuf) {\n\t\tif (!(path = strdup(path)))\n\t\t\tout_of_memory(\"normalize_path\");\n\t}\n\n\tlen = clean_fname(path, CFN_COLLAPSE_DOT_DOT_DIRS | CFN_DROP_TRAILING_DOT_DIR);\n\n\tif (len_ptr)\n\t\t*len_ptr = len;\n\n\treturn path;\n}\n\n/**\n * Return a quoted string with the full pathname of the indicated filename.\n * The string \" (in MODNAME)\" may also be appended.  The returned pointer\n * remains valid until the next time full_fname() is called.\n **/\nchar *full_fname(const char *fn)\n{\n\tstatic char *result = NULL;\n\tchar *m1, *m2, *m3;\n\tchar *p1, *p2;\n\n\tif (result)\n\t\tfree(result);\n\n\tif (*fn == '/')\n\t\tp1 = p2 = \"\";\n\telse {\n\t\tp1 = curr_dir + module_dirlen;\n\t\tfor (p2 = p1; *p2 == '/'; p2++) {}\n\t\tif (*p2)\n\t\t\tp2 = \"/\";\n\t}\n\tif (module_id >= 0) {\n\t\tm1 = \" (in \";\n\t\tm2 = lp_name(module_id);\n\t\tm3 = \")\";\n\t} else\n\t\tm1 = m2 = m3 = \"\";\n\n\tif (asprintf(&result, \"\\\"%s%s%s\\\"%s%s%s\", p1, p2, fn, m1, m2, m3) < 0)\n\t\tout_of_memory(\"full_fname\");\n\n\treturn result;\n}\n\nstatic char partial_fname[MAXPATHLEN];\n\nchar *partial_dir_fname(const char *fname)\n{\n\tchar *t = partial_fname;\n\tint sz = sizeof partial_fname;\n\tconst char *fn;\n\n\tif ((fn = strrchr(fname, '/')) != NULL) {\n\t\tfn++;\n\t\tif (*partial_dir != '/') {\n\t\t\tint len = fn - fname;\n\t\t\tstrncpy(t, fname, len); /* safe */\n\t\t\tt += len;\n\t\t\tsz -= len;\n\t\t}\n\t} else\n\t\tfn = fname;\n\tif ((int)pathjoin(t, sz, partial_dir, fn) >= sz)\n\t\treturn NULL;\n\tif (daemon_filter_list.head) {\n\t\tt = strrchr(partial_fname, '/');\n\t\t*t = '\\0';\n\t\tif (check_filter(&daemon_filter_list, FLOG, partial_fname, 1) < 0)\n\t\t\treturn NULL;\n\t\t*t = '/';\n\t\tif (check_filter(&daemon_filter_list, FLOG, partial_fname, 0) < 0)\n\t\t\treturn NULL;\n\t}\n\n\treturn partial_fname;\n}\n\n/* If no --partial-dir option was specified, we don't need to do anything\n * (the partial-dir is essentially '.'), so just return success. */\nint handle_partial_dir(const char *fname, int create)\n{\n\tchar *fn, *dir;\n\n\tif (fname != partial_fname)\n\t\treturn 1;\n\tif (!create && *partial_dir == '/')\n\t\treturn 1;\n\tif (!(fn = strrchr(partial_fname, '/')))\n\t\treturn 1;\n\n\t*fn = '\\0';\n\tdir = partial_fname;\n\tif (create) {\n\t\tSTRUCT_STAT st;\n\t\tint statret = do_lstat(dir, &st);\n\t\tif (statret == 0 && !S_ISDIR(st.st_mode)) {\n\t\t\tif (do_unlink(dir) < 0) {\n\t\t\t\t*fn = '/';\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t\tstatret = -1;\n\t\t}\n\t\tif (statret < 0 && do_mkdir(dir, 0700) < 0) {\n\t\t\t*fn = '/';\n\t\t\treturn 0;\n\t\t}\n\t} else\n\t\tdo_rmdir(dir);\n\t*fn = '/';\n\n\treturn 1;\n}\n\n/* Determine if a symlink points outside the current directory tree.\n * This is considered \"unsafe\" because e.g. when mirroring somebody\n * else's machine it might allow them to establish a symlink to\n * /etc/passwd, and then read it through a web server.\n *\n * Returns 1 if unsafe, 0 if safe.\n *\n * Null symlinks and absolute symlinks are always unsafe.\n *\n * Basically here we are concerned with symlinks whose target contains\n * \"..\", because this might cause us to walk back up out of the\n * transferred directory.  We are not allowed to go back up and\n * reenter.\n *\n * \"dest\" is the target of the symlink in question.\n *\n * \"src\" is the top source directory currently applicable at the level\n * of the referenced symlink.  This is usually the symlink's full path\n * (including its name), as referenced from the root of the transfer. */\nint unsafe_symlink(const char *dest, const char *src)\n{\n\tconst char *name, *slash;\n\tint depth = 0;\n\n\t/* all absolute and null symlinks are unsafe */\n\tif (!dest || !*dest || *dest == '/')\n\t\treturn 1;\n\n\t/* find out what our safety margin is */\n\tfor (name = src; (slash = strchr(name, '/')) != 0; name = slash+1) {\n\t\t/* \"..\" segment starts the count over.  \".\" segment is ignored. */\n\t\tif (*name == '.' && (name[1] == '/' || (name[1] == '.' && name[2] == '/'))) {\n\t\t\tif (name[1] == '.')\n\t\t\t\tdepth = 0;\n\t\t} else\n\t\t\tdepth++;\n\t\twhile (slash[1] == '/') slash++; /* just in case src isn't clean */\n\t}\n\tif (*name == '.' && name[1] == '.' && name[2] == '\\0')\n\t\tdepth = 0;\n\n\tfor (name = dest; (slash = strchr(name, '/')) != 0; name = slash+1) {\n\t\tif (*name == '.' && (name[1] == '/' || (name[1] == '.' && name[2] == '/'))) {\n\t\t\tif (name[1] == '.') {\n\t\t\t\t/* if at any point we go outside the current directory\n\t\t\t\t   then stop - it is unsafe */\n\t\t\t\tif (--depth < 0)\n\t\t\t\t\treturn 1;\n\t\t\t}\n\t\t} else\n\t\t\tdepth++;\n\t\twhile (slash[1] == '/') slash++;\n\t}\n\tif (*name == '.' && name[1] == '.' && name[2] == '\\0')\n\t\tdepth--;\n\n\treturn depth < 0;\n}\n\n/* Return the date and time as a string.  Some callers tweak returned buf. */\nchar *timestring(time_t t)\n{\n\tstatic char TimeBuf[200];\n\tstruct tm *tm = localtime(&t);\n\tchar *p;\n\n#ifdef HAVE_STRFTIME\n\tstrftime(TimeBuf, sizeof TimeBuf - 1, \"%Y/%m/%d %H:%M:%S\", tm);\n#else\n\tstrlcpy(TimeBuf, asctime(tm), sizeof TimeBuf);\n#endif\n\n\tif ((p = strchr(TimeBuf, '\\n')) != NULL)\n\t\t*p = '\\0';\n\n\treturn TimeBuf;\n}\n\n/* Determine if two time_t values are equivalent (either exact, or in\n * the modification timestamp window established by --modify-window).\n *\n * @retval 0 if the times should be treated as the same\n *\n * @retval +1 if the first is later\n *\n * @retval -1 if the 2nd is later\n **/\nint cmp_time(time_t file1, time_t file2)\n{\n\tif (file2 > file1) {\n\t\t/* The final comparison makes sure that modify_window doesn't overflow a\n\t\t * time_t, which would mean that file2 must be in the equality window. */\n\t\tif (!modify_window || (file2 > file1 + modify_window && file1 + modify_window > file1))\n\t\t\treturn -1;\n\t} else if (file1 > file2) {\n\t\tif (!modify_window || (file1 > file2 + modify_window && file2 + modify_window > file2))\n\t\t\treturn 1;\n\t}\n\treturn 0;\n}\n\n#ifdef __INSURE__XX\n#include <dlfcn.h>\n\n/**\n   This routine is a trick to immediately catch errors when debugging\n   with insure. A xterm with a gdb is popped up when insure catches\n   a error. It is Linux specific.\n**/\nint _Insure_trap_error(int a1, int a2, int a3, int a4, int a5, int a6)\n{\n\tstatic int (*fn)();\n\tint ret, pid_int = getpid();\n\tchar *cmd;\n\n\tif (asprintf(&cmd,\n\t    \"/usr/X11R6/bin/xterm -display :0 -T Panic -n Panic -e /bin/sh -c 'cat /tmp/ierrs.*.%d ; \"\n\t    \"gdb /proc/%d/exe %d'\", pid_int, pid_int, pid_int) < 0)\n\t\treturn -1;\n\n\tif (!fn) {\n\t\tstatic void *h;\n\t\th = dlopen(\"/usr/local/parasoft/insure++lite/lib.linux2/libinsure.so\", RTLD_LAZY);\n\t\tfn = dlsym(h, \"_Insure_trap_error\");\n\t}\n\n\tret = fn(a1, a2, a3, a4, a5, a6);\n\n\tsystem(cmd);\n\n\tfree(cmd);\n\n\treturn ret;\n}\n#endif\n\n/* Take a filename and filename length and return the most significant\n * filename suffix we can find.  This ignores suffixes such as \"~\",\n * \".bak\", \".orig\", \".~1~\", etc. */\nconst char *find_filename_suffix(const char *fn, int fn_len, int *len_ptr)\n{\n\tconst char *suf, *s;\n\tBOOL had_tilde;\n\tint s_len;\n\n\t/* One or more dots at the start aren't a suffix. */\n\twhile (fn_len && *fn == '.') fn++, fn_len--;\n\n\t/* Ignore the ~ in a \"foo~\" filename. */\n\tif (fn_len > 1 && fn[fn_len-1] == '~')\n\t\tfn_len--, had_tilde = True;\n\telse\n\t\thad_tilde = False;\n\n\t/* Assume we don't find an suffix. */\n\tsuf = \"\";\n\t*len_ptr = 0;\n\n\t/* Find the last significant suffix. */\n\tfor (s = fn + fn_len; fn_len > 1; ) {\n\t\twhile (*--s != '.' && s != fn) {}\n\t\tif (s == fn)\n\t\t\tbreak;\n\t\ts_len = fn_len - (s - fn);\n\t\tfn_len = s - fn;\n\t\tif (s_len == 4) {\n\t\t\tif (strcmp(s+1, \"bak\") == 0\n\t\t\t || strcmp(s+1, \"old\") == 0)\n\t\t\t\tcontinue;\n\t\t} else if (s_len == 5) {\n\t\t\tif (strcmp(s+1, \"orig\") == 0)\n\t\t\t\tcontinue;\n\t\t} else if (s_len > 2 && had_tilde\n\t\t    && s[1] == '~' && isDigit(s + 2))\n\t\t\tcontinue;\n\t\t*len_ptr = s_len;\n\t\tsuf = s;\n\t\tif (s_len == 1)\n\t\t\tbreak;\n\t\t/* Determine if the suffix is all digits. */\n\t\tfor (s++, s_len--; s_len > 0; s++, s_len--) {\n\t\t\tif (!isDigit(s))\n\t\t\t\treturn suf;\n\t\t}\n\t\t/* An all-digit suffix may not be that signficant. */\n\t\ts = suf;\n\t}\n\n\treturn suf;\n}\n\n/* This is an implementation of the Levenshtein distance algorithm.  It\n * was implemented to avoid needing a two-dimensional matrix (to save\n * memory).  It was also tweaked to try to factor in the ASCII distance\n * between changed characters as a minor distance quantity.  The normal\n * Levenshtein units of distance (each signifying a single change between\n * the two strings) are defined as a \"UNIT\". */\n\n#define UNIT (1 << 16)\n\nuint32 fuzzy_distance(const char *s1, unsigned len1, const char *s2, unsigned len2)\n{\n\tuint32 a[MAXPATHLEN], diag, above, left, diag_inc, above_inc, left_inc;\n\tint32 cost;\n\tunsigned i1, i2;\n\n\tif (!len1 || !len2) {\n\t\tif (!len1) {\n\t\t\ts1 = s2;\n\t\t\tlen1 = len2;\n\t\t}\n\t\tfor (i1 = 0, cost = 0; i1 < len1; i1++)\n\t\t\tcost += s1[i1];\n\t\treturn (int32)len1 * UNIT + cost;\n\t}\n\n\tfor (i2 = 0; i2 < len2; i2++)\n\t\ta[i2] = (i2+1) * UNIT;\n\n\tfor (i1 = 0; i1 < len1; i1++) {\n\t\tdiag = i1 * UNIT;\n\t\tabove = (i1+1) * UNIT;\n\t\tfor (i2 = 0; i2 < len2; i2++) {\n\t\t\tleft = a[i2];\n\t\t\tif ((cost = *((uchar*)s1+i1) - *((uchar*)s2+i2)) != 0) {\n\t\t\t\tif (cost < 0)\n\t\t\t\t\tcost = UNIT - cost;\n\t\t\t\telse\n\t\t\t\t\tcost = UNIT + cost;\n\t\t\t}\n\t\t\tdiag_inc = diag + cost;\n\t\t\tleft_inc = left + UNIT + *((uchar*)s1+i1);\n\t\t\tabove_inc = above + UNIT + *((uchar*)s2+i2);\n\t\t\ta[i2] = above = left < above\n\t\t\t      ? (left_inc < diag_inc ? left_inc : diag_inc)\n\t\t\t      : (above_inc < diag_inc ? above_inc : diag_inc);\n\t\t\tdiag = left;\n\t\t}\n\t}\n\n\treturn a[len2-1];\n}\n\n#define BB_SLOT_SIZE     (16*1024)          /* Desired size in bytes */\n#define BB_PER_SLOT_BITS (BB_SLOT_SIZE * 8) /* Number of bits per slot */\n#define BB_PER_SLOT_INTS (BB_SLOT_SIZE / 4) /* Number of int32s per slot */\n\nstruct bitbag {\n    uint32 **bits;\n    int slot_cnt;\n};\n\nstruct bitbag *bitbag_create(int max_ndx)\n{\n\tstruct bitbag *bb = new(struct bitbag);\n\tbb->slot_cnt = (max_ndx + BB_PER_SLOT_BITS - 1) / BB_PER_SLOT_BITS;\n\n\tif (!(bb->bits = (uint32**)calloc(bb->slot_cnt, sizeof (uint32*))))\n\t\tout_of_memory(\"bitbag_create\");\n\n\treturn bb;\n}\n\nvoid bitbag_set_bit(struct bitbag *bb, int ndx)\n{\n\tint slot = ndx / BB_PER_SLOT_BITS;\n\tndx %= BB_PER_SLOT_BITS;\n\n\tif (!bb->bits[slot]) {\n\t\tif (!(bb->bits[slot] = (uint32*)calloc(BB_PER_SLOT_INTS, 4)))\n\t\t\tout_of_memory(\"bitbag_set_bit\");\n\t}\n\n\tbb->bits[slot][ndx/32] |= 1u << (ndx % 32);\n}\n\n#if 0 /* not needed yet */\nvoid bitbag_clear_bit(struct bitbag *bb, int ndx)\n{\n\tint slot = ndx / BB_PER_SLOT_BITS;\n\tndx %= BB_PER_SLOT_BITS;\n\n\tif (!bb->bits[slot])\n\t\treturn;\n\n\tbb->bits[slot][ndx/32] &= ~(1u << (ndx % 32));\n}\n\nint bitbag_check_bit(struct bitbag *bb, int ndx)\n{\n\tint slot = ndx / BB_PER_SLOT_BITS;\n\tndx %= BB_PER_SLOT_BITS;\n\n\tif (!bb->bits[slot])\n\t\treturn 0;\n\n\treturn bb->bits[slot][ndx/32] & (1u << (ndx % 32)) ? 1 : 0;\n}\n#endif\n\n/* Call this with -1 to start checking from 0.  Returns -1 at the end. */\nint bitbag_next_bit(struct bitbag *bb, int after)\n{\n\tuint32 bits, mask;\n\tint i, ndx = after + 1;\n\tint slot = ndx / BB_PER_SLOT_BITS;\n\tndx %= BB_PER_SLOT_BITS;\n\n\tmask = (1u << (ndx % 32)) - 1;\n\tfor (i = ndx / 32; slot < bb->slot_cnt; slot++, i = mask = 0) {\n\t\tif (!bb->bits[slot])\n\t\t\tcontinue;\n\t\tfor ( ; i < BB_PER_SLOT_INTS; i++, mask = 0) {\n\t\t\tif (!(bits = bb->bits[slot][i] & ~mask))\n\t\t\t\tcontinue;\n\t\t\t/* The xor magic figures out the lowest enabled bit in\n\t\t\t * bits, and the switch quickly computes log2(bit). */\n\t\t\tswitch (bits ^ (bits & (bits-1))) {\n#define LOG2(n) case 1u << n: return slot*BB_PER_SLOT_BITS + i*32 + n\n\t\t\t    LOG2(0);  LOG2(1);  LOG2(2);  LOG2(3);\n\t\t\t    LOG2(4);  LOG2(5);  LOG2(6);  LOG2(7);\n\t\t\t    LOG2(8);  LOG2(9);  LOG2(10); LOG2(11);\n\t\t\t    LOG2(12); LOG2(13); LOG2(14); LOG2(15);\n\t\t\t    LOG2(16); LOG2(17); LOG2(18); LOG2(19);\n\t\t\t    LOG2(20); LOG2(21); LOG2(22); LOG2(23);\n\t\t\t    LOG2(24); LOG2(25); LOG2(26); LOG2(27);\n\t\t\t    LOG2(28); LOG2(29); LOG2(30); LOG2(31);\n\t\t\t}\n\t\t\treturn -1; /* impossible... */\n\t\t}\n\t}\n\n\treturn -1;\n}\n\nvoid flist_ndx_push(flist_ndx_list *lp, int ndx)\n{\n\tstruct flist_ndx_item *item;\n\n\tif (!(item = new(struct flist_ndx_item)))\n\t\tout_of_memory(\"flist_ndx_push\");\n\titem->next = NULL;\n\titem->ndx = ndx;\n\tif (lp->tail)\n\t\tlp->tail->next = item;\n\telse\n\t\tlp->head = item;\n\tlp->tail = item;\n}\n\nint flist_ndx_pop(flist_ndx_list *lp)\n{\n\tstruct flist_ndx_item *next;\n\tint ndx;\n\n\tif (!lp->head)\n\t\treturn -1;\n\n\tndx = lp->head->ndx;\n\tnext = lp->head->next;\n\tfree(lp->head);\n\tlp->head = next;\n\tif (!next)\n\t\tlp->tail = NULL;\n\n\treturn ndx;\n}\n\nvoid *expand_item_list(item_list *lp, size_t item_size,\n\t\t       const char *desc, int incr)\n{\n\t/* First time through, 0 <= 0, so list is expanded. */\n\tif (lp->malloced <= lp->count) {\n\t\tvoid *new_ptr;\n\t\tsize_t new_size = lp->malloced;\n\t\tif (incr < 0)\n\t\t\tnew_size += -incr; /* increase slowly */\n\t\telse if (new_size < (size_t)incr)\n\t\t\tnew_size += incr;\n\t\telse\n\t\t\tnew_size *= 2;\n\t\tif (new_size < lp->malloced)\n\t\t\toverflow_exit(\"expand_item_list\");\n\t\t/* Using _realloc_array() lets us pass the size, not a type. */\n\t\tnew_ptr = _realloc_array(lp->items, item_size, new_size);\n\t\tif (DEBUG_GTE(FLIST, 3)) {\n\t\t\trprintf(FINFO, \"[%s] expand %s to %s bytes, did%s move\\n\",\n\t\t\t\twho_am_i(), desc, big_num(new_size * item_size),\n\t\t\t\tnew_ptr == lp->items ? \" not\" : \"\");\n\t\t}\n\t\tif (!new_ptr)\n\t\t\tout_of_memory(\"expand_item_list\");\n\n\t\tlp->items = new_ptr;\n\t\tlp->malloced = new_size;\n\t}\n\treturn (char*)lp->items + (lp->count++ * item_size);\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-rsync-3.1.1-osiiinomiblpjrgkaah3q3xyqnp5nzdx/spack-src/wildtest.txt",
        "/tmp/vanessa/spack-stage/spack-stage-rsync-3.1.1-osiiinomiblpjrgkaah3q3xyqnp5nzdx/spack-src/testsuite/unsafe-links.test",
        "/tmp/vanessa/spack-stage/spack-stage-rsync-3.1.1-osiiinomiblpjrgkaah3q3xyqnp5nzdx/spack-src/testsuite/unsafe-byname.test"
    ],
    "total_files": 184
}