{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/yorick/dlsym.c": "/*\n * Stub interface to dynamic linker routines\n * that SunOS uses but didn't ship with 4.1.\n *\n * The C library routine wcstombs in SunOS 4.1 tries to dynamically\n * load some routines using the dlsym interface, described in dlsym(3x).\n * Unfortunately SunOS 4.1 does not include the necessary library, libdl.\n *\n * The R5 Xlib uses wcstombs.  If you link dynamically, your program can\n * run even with the unresolved reference to dlsym.  However, if you\n * link statically, you will encounter this bug.  One workaround\n * is to include these stub routines when you link.\n */\n\nvoid *dlopen()\n{\n  return 0;\n}\n\nvoid *dlsym()\n{\n  return 0;\n}\n\nint dlclose()\n{\n  return -1;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/yorick/NOTES-1.6": "\nPlug-in Support for Yorick\n--------------------------\n\nThe easiest way to add compiled code to yorick is to build a special\nversion of yorick which includes your compiled routines.  When you\nwant your additional features, you run your special executable instead\nof the distribution yorick.  If you want your custom features all the\ntime, or available to everyone at your site, change the name of your\nspecial executable to \"yorick\" and install it in place of the\ndistribution yorick.\n\nThe only disadvantage of this approach is that you cannot easily\ndistribute your package to other yorick users in binary form.  More\ngenerally, if there are many yorick packages which are potentially\ninteresting, it can become a very tedious business to maintain a giant\nversion of yorick which includes the subset that are relevant to you\nand any coworkers.  The cleanest way to meet this challenge is to be\nable to link a simple distribution yorick to an arbitrary set of\nadditional packages at runtime, using the same technology that Web\nbrowsers use to link plug-ins.  Since browsers with plug-ins are\navailable on most platforms, this is obviously possible.\n\nUnfortunately, the technique to build a shareable object file varies\ntremendously across different platforms.  Even the filename extension\nthat identifies such a file changes from one platform to another:\n\".dll\" on MS Windows and \".so\" on Linux and many other UNIX systems,\nexcept \".sl\" on HPUX.  There is a GNU development tool (called\nlibtool) which tries to bring all of these models under one umbrella\nsystem, but needless to say it has to include all of the complexity of\nevery model.\n\nFortunately, yorick needs only the form of \"dynamic linking\" in which\nyou call a system function to \"dlopen\" a shared object file, whose\npathname you pass as you would to open a file with fopen.  Yorick\nrequires just two functions: \"dlopen\" to open the shared object file\ncontaining your package's compiled code, and \"dlsym\" to look up the\naddress of the function that initializes your package, making its\ncompiled code known to the yorick interpreter.  There is no need to\never \"dlclose\" the package; just as yorick has no way to \"forget\" the\ncontents of an include (.i) file, it has no ability to \"forget\" about\nnew compiled features.  Since a dynamically linked yorick package will\nbe connected using explicit \"dlopen\" and \"dlsym\" calls, there is no\nneed to worry about the additional layer of platform dependent tricks\nrequired to be able to link against the package at build time (the way\nyou link to the libc or libm shared libraries).\n\nA subtle requirement, which imposes a difficult burden on some\nplatforms, is that the yorick plug-in must be able to call the\nfunctions declared in ydata.h in order to retrieve input parameters\nand otherwise communicate with the interpreter.  This is quite\ndifferent from a dynamic system library like libc or libm, where the\nlibrary functions are completely independent of anything defined in\nthe calling code.  That is, in addition to the explicit retrieval of a\nfunction pointer in the plug-in via \"dlsym\", the plug-in's calls to\nfuctions in the yorick executable must be linked at runtime.  This is\nthe function usually performed by the system dynamic linker at\nruntime, but there is some unfortunate platform dependence on how the\nruntime linker accomplishes such backward linking from the library to\nthe executable.\n\nWhile you are developing your package, you will find it much easier to\nlink it statically into a special version of yorick, which you can\ndebug in the usual manner.\n\nAfter your package is debugged, you may wish to take advantage of\nyorick's plug-in support to distribute it.  Here is how it works: The\ninterface between yorick and your compiled functions is described in\none or more startup .i files, which, like extend/cerfc.i, contain\nextern statements and, optionally, PROTOTYPE comments, for the\ncompiled functions.\n\nWhen you link statically, this .i file is read twice: First, during\nthe build process, codger (yorick/codger.c) scans your startup .i\nfile(s) and generates two critical things: (1) a reference to the\naddress of each compiled function mentioned in an extern statement,\ntogether with the string representing the name of the function for the\ninterpreter, and (2) any optional wrapper code from PROTOTYPE\ncomments.  When you build a yorick executable, the output of codger in\n\"wrap\" mode, called ywrap.c, contains an array of all the function\npointer/name pairs for all of yorick.  Those function pointers get\nbuilt into yorick, and those references are what forces the loader to\nactually load all that compiled code into the yorick executable.\nAdditionally, the name of every startup .i file is built into the\nyorick executable, and when yorick starts it must find and include all\nof those .i files in order to parse any func definitions or other\ninterpreted code associated with your package.\n\nWhen you dynamically link to a package, none of this happened at the\ntime yorick was built.  Thus, not only must you \"dlopen\" the shared\nobject containing your compiled code, somehow yorick has to find all\nthe compiled function pointer/name pairs in order to enable the\ninterpreter to actually call your compiled functions.  In order to do\nthis, codger has to put the information about the function\npointer/name pairs into the ywrap.c code, which then becomes a part of\nthe plug-in code.  Note that codger still has to generate any\nPROTOTYPE wrapper code, which must also be built into your plug-in.\n\nPlug-in support in yorick therefore consists of a single function:\n   plug_in, dll_name This function goes in the startup .i file for\nyour package, so that when you #include that .i file, it performs the\nrequired dlopen of the plug-in shared binary, say, mylib.so (or\nmylib.dll on MS Windows, or mylib.sl on HPUX, or whatever file\nextension is standard on your platform).  The plug_in command opens\nthe shared library (which must be installed someplace in Y_HOME or\n~/yorick), and retrieves the function pointer/name information to\nexpose the compiled routines to interpreted builtin functions.  The\npoint of this is, that the #include file defining the interpreted\ninterface to a compiled yorick package (that is, containing a plug_in\ncommand), dynamically links to the plug-in, so that including it\nactaully makes the compiled functions available, just as including a\npurely interpreted package makes those functions available.\n\nIf the file has already been loaded, plug_in is a no-op; you cannot\ndevelop a dynamically linked object by including multiple versions,\nsince the ability to \"dlclose\" and then reopen such a file is not\ncommon to all platforms.  The plug_in function will also recognize the\ncase that the associated package was statically linked when yorick was\nbuilt.  In this case, plug_in is again a no-op.  That way, you do not\nneed to change any compiled code to run on a platform that does not\nsupport plug-ins, and you can still get all the functionality by\nbuilding a special version of yorick that includes statically linked\nversions of all your packages.\n",
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/yorick/task.c": "/*\n * $Id: task.c,v 1.16 2010-07-04 23:07:06 dhmunro Exp $\n * Implement Yorick virtual machine.\n */\n/* Copyright (c) 2005, The Regents of the University of California.\n * All rights reserved.\n * This file is part of yorick (http://yorick.sourceforge.net).\n * Read the accompanying LICENSE file for details.\n */\n\n#include \"yapi.h\"\n#include \"ydata.h\"\n#include \"yio.h\"\n#include \"pstdlib.h\"\n#include \"play.h\"\n\n#include <string.h>\n\n/* packages that need to clean up before Yorick exits should supply\n   CleanUpForExit, then call the one they found */\nextern void (*CleanUpForExit)(void);\nvoid (*CleanUpForExit)(void)= 0;\n\nextern int YpParse(void *func);  /* argument non-zero for YpReparse */\n\n/* The offsetof macro may be defined in <stddef.h> (it is ANSI standard).  */\n/* #define offsetof(structure, member)  ((long)&(((structure*)0)->member))\n   (does not work on Crays) */\n#ifndef offsetof\n#define offsetof(structure, member) \\\n  ((long)((char *)&(((structure*)0)->member) - (char *)0))\n#endif\n\n/*--------------------------------------------------------------------------*/\n\nextern BuiltIn Y_quit, Y_include, Y_require, Y_help, Y_exit, Y_error, Y_batch;\nextern BuiltIn Y_current_include, Y_get_includes;\nextern BuiltIn Y_plug_in, Y_plug_dir, Y_maybe_prompt, Y_suspend, Y_resume;\nextern BuiltIn Y_after, Y__after_func, Y_include1, Y_vopen, Y_vclose;\n\nextern ybuiltin_t Y_prompt_marker;\n\nextern void YRun(void);\nextern void YHalt(void);\n\nextern int CheckForTasks(int wait);\n\nextern VMaction Eval, Return, PushVariable;\n\nextern void ClearTasks(void);\nextern int DoTask(void);\n\nextern Function *FuncContaining(Instruction *pc);\n\n/* If yAutoDebug!=0, debug mode will be entered automatically whenever\n   a runtime error occurs.  Otherwise, you must type \"debug\".  */\nextern int yAutoDebug;\nint yAutoDebug= 0;\n\nint yDebugLevel= 0;\n\n/* most recent error message was built in yErrorMsg */\nchar yErrorMsg[192+12];\nchar yWarningMsg[192];\n\nstatic int inYError= 0;\n\n/* from fnctn.c */\nextern Instruction *ClearStack(void);\nextern Instruction *AbortReturn(void);\n\nextern long ypBeginLine;\n\nextern TextStream *NewTextStream(char *fullname,\n                                 void *stream, int permissions,\n                                 long line, long pos);\n\ntypedef struct DebugBlk DebugBlk;\nextern DebugBlk *NewDebugBlk(Function *f, long pcerr, char *errFile,\n                             long lnum);\n\n/* stuff to implement catch */\nextern BuiltIn Y_catch;\ntypedef struct Catcher Catcher;\nstruct Catcher {\n  Instruction *task;\n  Instruction *pc;  /* of conditional branch instruction */\n  long isp;         /* sp-spBottom of returnSym for calling function */\n  int category;     /* of error to be caught */\n};\nstatic long n_catchers= 0;\nstatic long max_catchers= 0;\nstatic Catcher *catchers= 0;\nextern void YCatchDrop(long isp);        /* used in fnctn.c */\nextern long ispCatch;                    /* used in fnctn.c */\nlong ispCatch= 0;\nextern int y_catch_category;\nint y_catch_category= 0x08;\nstatic Catcher *CatchScan(const char *msg, int category);\nstatic Catcher *CatchNew(void);\nstatic int caughtTask= 0;\n\n/* stuff to implement set_idler */\nextern BuiltIn Y_set_idler;\nFunction *y_idler_function= 0;\nstatic int y_idler_fault = 0;\n\n/*--------------------------------------------------------------------------*/\n\nInstruction *pc= 0;\n\nstatic int ym_state= 0;\nstatic int ym_fatal = 0;\nextern int ym_dbenter;\nint ym_dbenter = 0;\n#define Y_QUITTING 1\n#define Y_RUNNING 2\n#define Y_SUSPENDED 4\n#define Y_PENDING 8\n\nvoid\nYRun(void)\n{\n  register VMaction *Action;\n  int run_state = ym_state & Y_RUNNING;\n  ym_state |= Y_RUNNING;\n  ym_dbenter = 0;\n\n  P_SOFTFPE_TEST;\n\n  while (!p_signalling) {\n    Action = (pc++)->Action;\n    Action();\n  }\n  if (p_signalling==-1 && !(ym_state&Y_RUNNING))\n    p_signalling = 0;      /* p_signalling set by YHalt (?? see below) */\n\n  /* reset Y_RUNNING to value on entry -- allows YRun to recurse */\n  ym_state = (ym_state & ~Y_RUNNING) | run_state;\n\n  P_SOFTFPE_TEST;\n\n  if (p_signalling)\n    p_abort();             /* p_signalling set by real signal */\n}\n\nextern void ym_escape(void);\nvoid\nym_escape(void)\n{\n  Y_quit(0);\n  if (p_signalling==-1) p_signalling = 0;\n  p_abort();\n}\n\nvoid\nYHalt(void)\n{\n  ym_state &= ~Y_RUNNING;\n  /* this may not be quite right -- a real signal might go unnoticed --\n   * but may only be possible for SIGINT when machine is halting anyway\n   * -- but if several other tasks queued, behavior might not be right */\n  if (!p_signalling) p_signalling = -1;\n}\n\n/* if read() interrupted by uncaught error, have a serious problem */\nextern char *y_read_prompt;\nextern Instruction *ym_suspend(void);\nextern void ym_resume(Instruction *pc);\n\nstatic Instruction ym_stopper;\n\nInstruction *\nym_suspend(void)\n{\n  Instruction *ipc = pc;\n  if (caughtTask || (ym_state&(Y_SUSPENDED|Y_PENDING)))\n    YError(\"ym_suspend called while suspended or in catch\");\n  ym_state |= Y_PENDING;\n  ym_stopper.Action = YHalt;\n  pc = &ym_stopper;\n  return ipc;\n}\n\nvoid\nym_resume(Instruction *ipc)\n{\n  int was_suspended = (ym_state&Y_SUSPENDED);\n  ym_state &= ~(Y_SUSPENDED|Y_PENDING);\n  if (!was_suspended)\n    YError(\"ym_resume called while not suspended\");\n  if (!ipc) YError(\"(BUG) ym_resume from null pc\");\n  pc = ipc;\n  caughtTask = 1;\n  /* protect against following sequence:\n   * (1) task suspends during include file, causing y_on_idle to return 0\n   *     this marks idler_eligible==0 in p_on_idle (alarms.c)\n   * (2) event arrives (e.g.- expose) and is handled as a pending event\n   *     before calling p_timeout; this event calls ym_resume\n   * (3) p_timeout is called, which should resume execution, but cannot\n   *     because idler_eligible has never been reset\n   */\n  p_timeout();\n}\n\n/*--------------------------------------------------------------------------*/\n\nstatic Function **tasks= 0;\nstatic int nTasks= 0;\nstatic int maxTasks= 0;\n\nvoid ClearTasks(void)\n{\n  while (nTasks) { nTasks--;  Unref(tasks[nTasks]); }\n  if (maxTasks>16) {\n    maxTasks= 0;\n    p_free(tasks);\n    tasks= 0;\n  }\n}\n\nvoid\nPushTask(Function *task)\n{\n  if (p_signalling) p_abort();\n  if (nTasks>=maxTasks) {\n    int newSize = maxTasks+16;\n    tasks = p_realloc(tasks, sizeof(Function *)*newSize);\n    maxTasks = newSize;\n  }\n  tasks[nTasks++] = Ref(task);  /* WARNING-- this is the reference for when\n                                 * DoTask pushes the task onto the stack--\n                                 * you are still giving your reference to the\n                                 * Function* away when you call PushTask */\n}\n\n/* The task pseudo-code MUST be static, since YError may p_abort out\n   of the DoTask procedure.  */\nstatic Instruction taskCode[4];\nstatic int taskCodeInit= 0;\n\nstatic Instruction *ym_suspc = 0;\nextern int yg_blocking;         /* graph.c */\n\nint DoTask(void)\n{\n  extern Operations debugOps;\n  if (caughtTask) {\n    caughtTask= 0;\n  } else if (nTasks>0) {\n    Function *task;\n    if (p_signalling) p_abort();\n    task = tasks[--nTasks];\n\n    CheckStack(1);\n    (sp+1)->ops= &dataBlockSym;\n    (sp+1)->value.db= (DataBlock *)task;  /* use owned by stack */\n    sp++;\n\n    pc= taskCode;     /* note that original pc is clobbered */\n  }\n  YRun();\n  if (yg_blocking == 4) {  /* resume has been called */\n    yg_blocking = 0;\n    if (ym_suspc) {\n      Instruction *suspc = ym_suspc;\n      ym_suspc = 0;\n      ym_resume(suspc);\n    }\n  }\n  if (ym_state & Y_PENDING) {\n    ym_state &= ~Y_PENDING;\n    ym_state |= Y_SUSPENDED;\n  } else if (sp->ops!=&dataBlockSym || sp->value.db->ops!=&debugOps) {\n    /* actually, something is terribly wrong if this is not *main* */\n    Drop(1);\n  }\n  return nTasks;\n}\n\n/*--------------------------------------------------------------------------*/\n\nextern int y_on_idle(void);\nextern void y_on_exception(int signal, char *errmsg);\nextern int y_on_quit(void);\n\nextern void y_cleanup(void);\n\nextern int nYpInputs;   /* from yinput.c */\nextern int yImpossible;\nint yImpossible= 0;\n\nextern int yBatchMode;  /* may be set with -batch, see std0.c */\nint yBatchMode= 0;\n\nstatic int y_was_idle= 0;\n\n/* prompt marker after prompts simplifies writing yorick controllers */\nstatic char *prompt_marker = 0;\nvoid\nY_prompt_marker(int argc)\n{\n  char *marker = (argc==1)? ygets_q(0) : 0;\n  if (argc > 1) y_error(\"prompt_marker expecting single string argument\");\n  if (marker && !marker[0]) marker = 0;\n  if (prompt_marker) {\n    char *old = prompt_marker;\n    prompt_marker = 0;\n    p_free(old);\n  }\n  if (marker)\n    prompt_marker = p_strcpy(marker);\n}\n\nstatic void ym_prompter(void);\nextern char *y_read_prompt;     /* ascio.c */\n/* yp_did_prompt reset by y_on_stdin */\nextern int yp_did_prompt;\nint yp_did_prompt= 0;\n\nstatic void\nym_prompter(void)\n{\n  if (!yp_did_prompt) {\n    if (y_read_prompt) {\n      if (y_read_prompt[0]) {\n        p_stdout(y_read_prompt);\n        if (prompt_marker) p_stdout(prompt_marker);\n        yp_did_prompt = 1;\n      }\n    } else {\n      extern void y_do_prompt(void);  /* yorick.c */\n      if (!yg_blocking) {\n        y_do_prompt();\n        if (prompt_marker) p_stdout(prompt_marker);\n        yp_did_prompt = 1;\n      }\n    }\n  }\n}\n\nvoid\nY_maybe_prompt(int nargs)\n{\n  if (nargs) YError(\"maybe_prompt accepts no arguments\");\n  if (!yp_did_prompt && !y_read_prompt) ym_prompter();\n}\n\n/* suspend/resume is very primitive - would be nice to permit a\n * queue of suspended tasks, but needs a bigger interpreted API\n */\nvoid\nY_suspend(int nargs)\n{\n  if (ym_suspc || yg_blocking || y_read_prompt)\n    YError(\"suspend: already suspended, paused, or waiting for input\");\n  ym_suspc = ym_suspend();\n  yg_blocking = 3;     /* for y_on_stdin */\n}\n\nvoid\nY_resume(int nargs)\n{\n  /* cannot call ym_resume directly, signal DoTask to do that */\n  if (ym_suspc && yg_blocking==3) yg_blocking = 4;\n}\n\nstatic void ym_after(void *context);\nstatic void ym_after_dq(int i);\n\ntypedef struct ym_after_t ym_after_t;\nstruct ym_after_t {\n  void *f, *d;     /* yget_use function and data handles */\n  long fndx, dndx;  /* same as closure object, see oxy.c */\n  int next;\n};\nstatic ym_after_t *ym_after_list = 0;\nstatic int ym_after_n = 0;  /* length of list, not number active */\nstatic int ym_after_i = -1; /* index of first active list item */\nstatic int ym_after_j = -1; /* index of first unused list item */\nstatic int ym_after_k = -1; /* index of last active list item */\n#define YM_AFTER_MAX 1024\n\nvoid Y__after_func(int argc)\n{\n  extern void FormEvalOp(int nargs, Operand *obj);\n  ym_after_t *ao;\n  long dref;\n  void *p = 0;\n  Operand op;\n  if (ym_after_i<0 || ym_after_i>=ym_after_n)\n    y_error(\"(BUG?) bad link in _after_func\");\n  ao = ym_after_list + ym_after_i;\n  ym_after_i = ao->next;\n  if (ym_after_i == -1) ym_after_k = -1;\n  ao->next = ym_after_j;\n  ym_after_j = ao - ym_after_list;\n  if (argc!=0 || !yarg_subroutine() || yarg_func(0)!=2)\n    y_error(\"_after_func must only be called by _after_work\");\n  yarg_drop(1);\n  ypush_check(3);\n  dref = ao->dndx;\n  p = ao->f;\n  ao->f = 0;\n  if (ao->fndx >= 0) {\n    ypush_global(ao->fndx);\n    if (yarg_func(0)) dref = -1L;\n  } else {\n    ypush_use(p);\n  }\n  p = ao->d;\n  ao->d = 0;\n  if (dref >= -1L) {\n    if (dref < 0) {\n      ypush_use(p);\n    } else {  /* object(member,...) semantics */\n      sp[1].ops = &referenceSym;\n      sp[1].index = dref;\n      sp++;\n    }\n    argc = 1;\n  } else {\n    argc = 0;\n  }\n  FormEvalOp(argc, &op);\n  op.ops->Eval(&op);\n}\n\nstatic Function *ym_after_work = 0;  /* yget_use handle to _after_work */\n\nvoid\nY_after(int argc)\n{\n  long range[3];\n  int flags = yget_range(argc-1, range);\n  double secs = -1.0;\n  long fndx=-1L, dndx=-1L;\n  if (!ym_after_work) {  /* this is first call */\n    long w = yfind_global(\"_after_work\", 0);\n    if (w > 0) {\n      ypush_global(w);\n      if (yarg_func(0) == 1) ym_after_work = yget_use(0);\n      yarg_drop(1);\n    }\n    if (!ym_after_work) y_error(\"(BUG) missing _after_work function\");\n  }\n  if (flags==(Y_PSEUDO | Y_MIN_DFLT | Y_MAX_DFLT) && range[2]==1) {\n    if (argc == 1) {\n      ym_after_dq(-1);  /* cancel everything, just like error */\n      return;\n    }\n  } else {\n    secs = ygets_d(argc-1);\n    if (secs < 0.0) secs = 0.0;\n    flags = 0;  /* if not, previous line raised error */\n  }\n  if (argc!=2 && argc!=3)\n    y_error(\"after called with illegal number of arguments\");\n  flags = yarg_func(argc-2);\n  if (!flags) {\n    yo_ops_t *ops;\n    if (yo_get(argc-2, &ops)) {\n      flags = -1;\n    } else if (yarg_string(argc-2)==1) {\n      char *name = ygets_q(argc-2);\n      if (name[0]=='o' && name[1]==':') name+=2, flags=-1;\n      else flags = -2;\n      fndx = yget_global(name, 0L);\n    } else {\n      y_error(\"unrecognized second argument to after\");\n    }\n  }\n  if (argc == 3) {\n    dndx = yget_ref(0);\n    if (flags>0 || dndx<0) {\n      if (yarg_typeid(0) >= 100)\n        y_error(\"(BUG?) unrecognized third argument to after\");\n      dndx = -1L;\n    }\n  } else {\n    dndx = -2L;  /* no data argument */\n  }\n\n  yexec_after(secs, fndx, argc-2, dndx, argc-3);\n}\n\nvoid\nyexec_after(double secs, long fndx, int farg, long dndx, int darg)\n{\n  int i;\n\n  if (secs < 0.0) { /* dequeue anything which matches */\n    /* first check active list */\n    void *f = (fndx>=0)? 0 : yget_use(farg);\n    void *d = (dndx!=-1L)? 0 : yget_use(darg);\n    int j = -1;\n    if (f) ydrop_use(f);\n    if (d) ydrop_use(d);\n    for (i=ym_after_i ; i>=0 ; j=i,i=ym_after_list[i].next) {\n      if (ym_after_list[i].f==f && ym_after_list[i].fndx==fndx) {\n        if (dndx==-2L ||\n            (ym_after_list[i].d==d && ym_after_list[i].dndx==dndx)) {\n          if (j >= 0) ym_after_list[j].next = ym_after_list[i].next;\n          else ym_after_i = ym_after_list[i].next;\n          if (i == ym_after_k) ym_after_k = j;\n          ym_after_dq(i);\n        }\n      }\n    }\n    /* then check any waiting items (no list of these) */\n    for (i=0 ; i<ym_after_n ; i++) {\n      if (ym_after_list[i].next != -2) continue;\n      if (ym_after_list[i].f==f && ym_after_list[i].fndx==fndx) {\n        if (dndx==-2L &&\n            (ym_after_list[i].d==d && ym_after_list[i].dndx==dndx)) {\n          ym_after_dq(i);\n        }\n      }\n    }\n    return;\n  }\n\n  if (ym_after_j < 0) {  /* need to lengthen list */\n    int j, k;\n    if (ym_after_n+ym_after_n > YM_AFTER_MAX)\n      y_error(\"runaway queue of after functions\");\n    if (!ym_after_n) {\n      j = 0;\n      k = 4;\n    } else {\n      j = ym_after_n;\n      k = j+j;\n    }\n    ym_after_list = p_realloc(ym_after_list, sizeof(ym_after_t)*k);\n    for (i=j ; i<k ; i++) {\n      ym_after_list[i].f = ym_after_list[i].d = 0;\n      ym_after_list[i].fndx = ym_after_list[i].dndx = -1L;\n      ym_after_list[i].next = (i<k-1)? i+1 : -1;\n    }\n    ym_after_j = j;\n    ym_after_n = k;\n  }\n  i = ym_after_j;\n  ym_after_j = ym_after_list[i].next;\n  ym_after_list[i].next = -2;\n\n  ym_after_list[i].f = (fndx>=0)? 0 : yget_use(farg);\n  ym_after_list[i].fndx = fndx;\n  ym_after_list[i].d = (dndx!=-1L)? 0 : yget_use(darg);\n  ym_after_list[i].dndx = dndx;\n\n  p_set_alarm(secs, ym_after, i+(char*)0);\n}\n\nstatic void\nym_after(void *context)\n{\n  long i = (char *)context - (char*)0;\n  if (i>=0 && i<ym_after_n) {\n    if (ym_after_list[i].next != -2) return; /* cancelled */\n    if (ym_after_k>=0) ym_after_list[ym_after_k].next = i;\n    else ym_after_i = i;\n    ym_after_k = i;\n    ym_after_list[i].next = -1;\n    PushTask(ym_after_work);\n  } else {\n    y_error(\"(BUG) bad task.c:ym_after call\");\n  }\n}\n\nstatic void\nym_after_dq(int i)\n{\n  if (i<0) {\n    for (i=ym_after_n-1 ; i>=0 ; i--) ym_after_dq(i);\n    ym_after_i = ym_after_k = -1;\n  } else {\n    void *p = ym_after_list[i].f;\n    if (p) {\n      ym_after_list[i].f = 0;\n      ydrop_use(p);\n    }\n    p = ym_after_list[i].d;\n    if (p) {\n      ym_after_list[i].d = 0;\n      ydrop_use(p);\n    }\n    ym_after_list[i].next = ym_after_j;\n    ym_after_j = i;\n  }\n}\n\nstatic int startup_done = 0;\n\nint\ny_on_idle(void)\n{\n  int more_work = 0;\n  int pending_stdin = 0;\n  int idler_fault = 0;\n\n  if (!taskCodeInit) {\n    taskCode[0].Action = &Eval;\n    taskCode[1].count = 0;\n    taskCode[2].Action = &YHalt;\n    taskCode[3].index = 0;\n    taskCodeInit = 1;\n  }\n\n  p_fpehandling(2);  /* be sure yorick FPE handling set properly */\n\n  if (ym_state & Y_QUITTING) {\n  die_now:\n    y_cleanup();\n    p_quit();\n    return 0;\n  }\n  if (!(nTasks+caughtTask)) {\n    extern int y_pending_stdin(void);  /* yinput.c */\n    if (nYpIncludes || nYpInputs) {\n      YpParse((void *)0);\n    } else {\n      if (startup_done) {\n        pending_stdin = y_pending_stdin();\n      } else {\n        /* make sure idler gets called once before any stdin\n         * - without this, starting with shell here-document makes\n         *   lines passed as here-document execute before custom.i,\n         *   not what user expects\n         */\n        if (!y_idler_function) pending_stdin = y_pending_stdin();\n        startup_done = 1;\n      }\n      if (!(nTasks+caughtTask || nYpIncludes || nYpInputs) &&\n          y_idler_function) {\n        Function *f = y_idler_function;\n        y_idler_function = 0;\n        /* this does not really detect when the after_error function\n         * itself has completed - a catch inside after_error can get\n         * complicated and probably defeat this loop detection attempt\n         */\n        idler_fault = y_idler_fault;\n        PushTask(f);\n        Unref(f);\n      }\n    }\n  }\n\n  if (nTasks+caughtTask) DoTask();\n  if (ym_state & Y_QUITTING) goto die_now;\n  if (idler_fault) y_idler_fault = 0;\n  more_work = (nTasks+caughtTask || nYpIncludes || nYpInputs ||\n               pending_stdin || y_idler_function);\n\n  /* non-0 return means we want to run again\n   * -- need to prompt if nothing left to do, but want to check\n   *    for more input events before deciding\n   * thus, first time we are out of tasks return non-0 anyway,\n   * but prompt and return 0 second consecutive time we are out */\n  if (more_work)\n    {\n      y_was_idle = 0;\n\n      /* probably incorrect -- any tasks created before the suspend\n       * but not yet run will be blocked\n       * or maybe that's correct behavior?  what are the implied\n       * dependencies of one task on another?\n       */\n\n      /* block on window,wait=1 or mouse() from #include file */\n      /* if (yg_blocking) more_work=0; */\n      /* block whenever suspended for any reason from #include file */\n      if (ym_state&Y_SUSPENDED) more_work = 0;\n      /* deliver prompt on read() or rdline() from #include file */\n      if (y_read_prompt) ym_prompter();\n    }\n  else if (y_was_idle)\n    y_was_idle=0, ym_prompter();\n  else\n    y_was_idle = more_work = !yBatchMode;\n  if (!(nTasks+caughtTask)) {\n    extern void yg_before_wait(void);\n    yg_before_wait();\n  }\n  return more_work;\n}\n\nvoid Y_quit(int nArgs)\n{\n  ym_state|= Y_QUITTING;\n  ResetStack(0);\n  YHalt();\n}\n\nstatic int did_cleanup = 0;\n\nint\ny_on_quit(void)\n{\n  if (!did_cleanup) y_cleanup();\n  return ym_fatal;\n}\n\nstatic volatile int detectRecursion = 0;\nstatic IOStream *yclean_file = 0;\n\nvoid\ny_cleanup(void)\n{\n  if (detectRecursion) {\n    if (detectRecursion < 2) {\n      detectRecursion = 3;\n      RemoveIOLink(yBinaryFiles, yclean_file);\n    } else {\n      yBinaryFiles = 0;\n    }\n    detectRecursion = 0;\n  }\n  /* attempt to close all binary files properly */\n  while (yBinaryFiles) {\n    yclean_file = yBinaryFiles->ios;\n    yclean_file->references = 0;\n    detectRecursion = 1;\n    Unref(yclean_file);\n    detectRecursion = 2;\n    RemoveIOLink(yBinaryFiles, yclean_file);\n  }\n\n  if (CleanUpForExit) CleanUpForExit();\n  did_cleanup = 1;\n}\n\nvoid RunTaskNow(Function *task)\n{\n  Instruction *pcHere = pc;\n  int t0 = nTasks;\n  if (ym_state & Y_SUSPENDED)\n    YError(\"RunTaskNow called while suspended waiting for event\");\n  PushTask(Ref(task));\n  while (nTasks>t0 && !(ym_state&(Y_QUITTING|Y_SUSPENDED))) DoTask();\n  if (ym_state & Y_SUSPENDED)\n    YError(\"(read, pause, wait=1, etc.) suspended during RunTaskNow\");\n  pc = pcHere;           /* may have been clobbered by DoTask */\n  if (ym_state&Y_QUITTING) YHalt();\n}\n\nvoid IncludeNow(void)\n{\n  Instruction *pcHere= pc;\n  int i0= nYpIncludes;\n  int t0= nTasks;\n  if (ym_state & Y_SUSPENDED)\n    YError(\"IncludeNow called while suspended waiting for event\");\n  for (;;) {\n    while (nTasks<=t0 && (nYpIncludes>i0 || (nYpIncludes==i0 &&\n           ypIncludes[i0-1].file))) YpParse((void *)0);\n    while (nTasks>t0 && !(ym_state&(Y_QUITTING|Y_SUSPENDED))) DoTask();\n    if ((ym_state&(Y_QUITTING|Y_SUSPENDED)) || nYpIncludes<i0 ||\n        !ypIncludes[i0-1].file) break;\n  }\n  if (ym_state & Y_SUSPENDED)\n    YError(\"(read, pause, wait=1, etc.) suspended during IncludeNow\");\n  pc= pcHere;           /* may have been clobbered by DoTask */\n  if (ym_state&Y_QUITTING) YHalt();\n}\n\nstatic char *y_include_arg(p_file **file);\n\nvoid\nY_include(int nArgs)\n{\n  long now = 0;\n  char *name;\n  p_file *file = 0;\n  if (nArgs!=1 && nArgs!=2)\n    YError(\"include function takes exactly one or two arguments\");\n  if (nArgs > 1) {\n    now = YGetInteger(sp);\n    Drop(1);\n  }\n  name = y_include_arg(&file);\n  if (name[0]) {  /* name==\"\" special hack cleans out pending includes */\n    if (now >= 0) {\n      if (file) {\n        y_push_include(file, name);\n      } else if (!YpPushInclude(name)) {\n        if (!(now&2))\n          YError(\"missing include file specified in include function\");\n        now = 0;\n      }\n    } else {\n      if (file) YError(\"include: now<0 only possible with filename argument\");\n      YpPush(name);          /* defer until all pending input parsed */\n    }\n  }\n  Drop(1);\n  if (now>0) IncludeNow(); /* parse and maybe execute file to be included\n                            * -- without now, this won't happen until the\n                            * next line is parsed naturally */\n}\n\nvoid\nyexec_include(int iarg, int now)\n{\n  ypush_use(yget_use(iarg));\n  ypush_int(now);\n  Y_include(2);\n}\n\nvoid\nytask_push(int iarg)\n{\n  if (iarg>=0 && yarg_func(iarg)==1) {\n    Function *f = (Function *)sp[-iarg].value.db;\n    PushTask(Ref(f));\n  } else {\n    YError(\"can only run interpreted functions as tasks\");\n  }\n}\n\nvoid\nytask_run(int iarg)\n{\n  if (iarg>=0 && yarg_func(iarg)==1) {\n    Function *f = (Function *)sp[-iarg].value.db;\n    RunTaskNow(f);\n  } else {\n    YError(\"can only push interpreted functions onto task stack\");\n  }\n}\n\nvoid\nY_include1(int nArgs)\n{\n  int i0 = nYpIncludes;\n  int t0 = nTasks;\n  char *name;\n  p_file *file = 0;\n  if (nArgs != 1) YError(\"include1 function takes exactly one argument\");\n  name = y_include_arg(&file);\n  if (file) y_push_include(file, name);\n  else if (!YpPushInclude(name))\n    YError(\"missing include file specified in include1 function\");\n  Drop(nArgs);\n  if (ym_state & Y_SUSPENDED)\n    YError(\"include1 called while suspended waiting for event\");\n  while (nTasks<=t0 && (nYpIncludes>i0 || (nYpIncludes==i0 &&\n         ypIncludes[i0-1].file))) YpParse((void *)0);\n  if (nTasks == t0+1) {\n    (sp+1)->ops = &dataBlockSym;\n    (sp+1)->value.db = (DataBlock *)tasks[--nTasks];  /* use owned by stack */\n    sp++;\n  } else if (nTasks <= t0) {\n    PushDataBlock(RefNC(&nilDB));\n  } else {\n    YError(\"include1 created more than one task (impossible?)\");\n  }\n}\n\nstatic p_file *ynew_vopen(Array *array, int binary);\nstatic char *y_vopen_name = \"(vopen file)\";\n\nstatic char *\ny_include_arg(p_file **file)\n{\n  Operand op;\n  char *name = y_vopen_name;\n  if (!sp->ops) YError(\"unexpected keyword argument in include or include1\");\n  sp->ops->FormOperand(sp, &op);\n  if (op.ops->typeID == T_STRING) {\n    if (!op.type.dims) {\n      char **q = op.value;\n      if (!q[0]) YError(\"string(0) filename to include or include1\");\n      name = q[0];\n    } else {\n      *file = ynew_vopen((Array *)sp->value.db, 0);\n      name = y_vopen_name;\n    }\n  } else if (op.ops->typeID == T_CHAR) {\n    *file = ynew_vopen((Array *)sp->value.db, 0);\n    name = y_vopen_name;\n  } else if (op.ops == &textOps) {\n    /* first few members of TextStream same as IOStream */\n    name = ((IOStream *)op.value)->fullname;\n  } else {\n    if (op.ops == &streamOps)\n      YError(\"include or include1 cannot accept binary file handle\");\n    YError(\"include or include1 cannot convert argument to text file handle\");\n  }\n  return name;\n}\n\n/* ----- begin vopen implementation ----- */\n\nstatic unsigned long yv_fsize(p_file *file);\nstatic unsigned long yv_ftell(p_file *file);\nstatic int yv_fseek(p_file *file, unsigned long addr);\n\nstatic char *yv_fgets(p_file *file, char *buf, int buflen);\nstatic int yv_fputs(p_file *file, const char *buf);\nstatic unsigned long yv_fread(p_file *file,\n                              void *buf, unsigned long nbytes);\nstatic unsigned long yv_fwrite(p_file *file,\n                               const void *buf, unsigned long nbytes);\n\nstatic int yv_feof(p_file *file);\nstatic int yv_ferror(p_file *file);\nstatic int yv_fflush(p_file *file);\nstatic int yv_fclose(p_file *file);\n\nstatic p_file_ops y_vopen_ops = {\n  &yv_fsize, &yv_ftell, &yv_fseek,\n  &yv_fgets, &yv_fputs, &yv_fread, &yv_fwrite,\n  &yv_feof, &yv_ferror, &yv_fflush, &yv_fclose };\n\ntypedef struct y_vopen_t y_vopen_t;\nstruct y_vopen_t {\n  p_file_ops *ops;\n  Array *array;\n  long addr, maxaddr, offset;\n  int binary;\n};\n\nstatic p_file *\nynew_vopen(Array *array, int binary)\n{\n  y_vopen_t *file = p_malloc(sizeof(y_vopen_t));\n  file->ops = &y_vopen_ops;\n  file->array = Ref(array);\n  file->addr = file->offset = 0;\n  file->maxaddr = (binary&2)? 0 : ((y_vopen_t *)file)->array->type.number;\n  file->binary = binary;\n  return (p_file *)file;\n}\n\nvoid *\ny_vopen_file(void *stream)\n{\n  y_vopen_t *file = stream;\n  return (file->ops==&y_vopen_ops)? file->array : 0;\n}\n\nvoid\nY_vopen(int argc)\n{\n  Operand op;\n  p_file *file = 0;\n  int binary = 0, wrt = 0;\n  if (argc == 2) {\n    if (!sp[-1].ops) YError(\"vopen: unexpected keyword argument\");\n    binary = (YGetInteger(sp) != 0);\n    Drop(1);\n  } else if (argc != 1) {\n    YError(\"vopen takes one or two arguments\");\n  }\n  sp->ops->FormOperand(sp, &op);\n  if (op.ops->typeID == T_VOID) {\n    Dimension *tmp = tmpDims;\n    tmpDims = 0;\n    FreeDimension(tmp);\n    tmpDims = NewDimension(binary? 16384L : 1024L, 1L, (Dimension *)0);\n    Drop(1);\n    if (binary) PushDataBlock(NewArray(&charStruct, tmpDims));\n    else PushDataBlock(NewArray(&stringStruct, tmpDims));\n    sp->ops->FormOperand(sp, &op);\n    binary |= (wrt = 2);\n  }\n  if (op.ops->typeID!=T_STRING && op.ops->typeID!=T_CHAR)\n    YError(\"vopen argument must be string or char array\");\n  file = ynew_vopen((Array *)sp->value.db, binary);\n  if (binary&1)\n    PushDataBlock(NewIOStream(p_strcpy(y_vopen_name), file, 9|wrt));\n  else\n    PushDataBlock(NewTextStream(p_strcpy(y_vopen_name), file, 1|wrt, 0L, 0L));\n}\n\nvoid\nY_vclose(int argc)\n{\n  long index = -1;\n  Operand op;\n  if (argc != 1) YError(\"vclose takes exactly one argument\");\n  if (sp->ops == &referenceSym) index = sp->index;\n  sp->ops->FormOperand(sp, &op);\n  if (op.ops==&textOps || op.ops==&streamOps) {\n    IOStream *ios = op.value;  /* first few members match TextStream */\n    y_vopen_t *file = ios->stream;\n    if (file && file->ops==&y_vopen_ops) {\n      long len;\n      len = file->maxaddr;\n      if (!len) {\n        PushDataBlock(RefNC(&nilDB));\n      } else {\n        if (file->binary & 2) {\n          if (file->binary & 1) {\n            if (ios->CloseHook) {\n              ios->CloseHook(ios);\n              ios->CloseHook = 0;\n              len = file->maxaddr;\n            }\n          }\n          if (file->array->type.number > len) {\n            /* shrink array to elements actually used */\n            file->array->type.number =\n              file->array->type.dims->number = len;\n            if (!(file->binary & 1)) len *= sizeof(char*);\n            len += (char *)file->array->value.q - (char *)file->array;\n            file->array = p_realloc(file->array, len);\n          }\n        }\n        PushDataBlock(Ref(file->array));\n        if ((file->binary & 3) == 3) {\n          ios->ioOps->Close(ios);\n          ios->stream = 0;\n        }\n      }\n      if (index >= 0) {\n        /* set reference argument to nil */\n        Symbol *s = &globTab[index];\n        if (s->ops==&dataBlockSym && s->value.db==op.value) {\n          s->ops = &intScalar;\n          Unref(s->value.db);\n          s->value.db = RefNC(&nilDB);\n          s->ops = &dataBlockSym;\n        }\n      }\n      return;\n    }\n  }\n  YError(\"vclose: already closed, not vopen handle, or not a file handle\");\n}\n\nstatic unsigned long\nyv_fsize(p_file *file)\n{\n  if (((y_vopen_t *)file)->binary & 2) return ((y_vopen_t *)file)->maxaddr;\n  else return ((y_vopen_t *)file)->array->type.number;\n}\n\nstatic unsigned long\nyv_ftell(p_file *file)\n{\n  return ((y_vopen_t *)file)->addr;\n}\n\nstatic int\nyv_fseek(p_file *file, unsigned long addr)\n{\n  long len = ((y_vopen_t *)file)->array->type.number;\n  if (((y_vopen_t *)file)->binary & 2) {\n    if (((y_vopen_t *)file)->binary & 1) {\n      if (addr > len) {\n        long j, n = 2*((y_vopen_t *)file)->array->type.number;\n        long nhead = (char *)((y_vopen_t *)file)->array->value.c -\n          (char *)((y_vopen_t *)file)->array;\n        while (n < addr) n += n;\n        ((y_vopen_t *)file)->array = p_realloc(((y_vopen_t *)file)->array,\n                                               nhead+n);\n        for (j=len ; j<n ; j++) ((y_vopen_t *)file)->array->value.c[j] = '\\0';\n        ((y_vopen_t *)file)->array->type.number =\n          ((y_vopen_t *)file)->array->type.dims->number = n;\n      }\n      len = addr;\n    } else {\n      len = ((y_vopen_t *)file)->maxaddr;\n    }\n  }\n  if (addr<0 || addr>len) return -1;\n  ((y_vopen_t *)file)->addr = addr;\n  ((y_vopen_t *)file)->offset = 0;\n  if (addr > ((y_vopen_t *)file)->maxaddr)\n    ((y_vopen_t *)file)->maxaddr = addr;\n  return 0;\n}\n\nstatic char *\nyv_fgets(p_file *file, char *buf, int buflen)\n{\n  int strng = (((y_vopen_t *)file)->array->ops->typeID == T_STRING);\n  char *txt, c='\\0';\n  long jeof;\n  int i, j;\n  if (!strng) {\n    txt = ((y_vopen_t *)file)->array->value.c + ((y_vopen_t *)file)->addr;\n    jeof = ((y_vopen_t *)file)->array->type.number - ((y_vopen_t *)file)->addr;\n  } else {\n    txt = ((y_vopen_t *)file)->array->value.q[((y_vopen_t *)file)->addr];\n    txt += ((y_vopen_t *)file)->offset;\n    jeof = 0L;\n  }\n  if (buflen <= 0) return 0;\n  for (i=j=0 ; i<buflen-1 && c!='\\n' ; i++,j++) {\n    if (!strng && j>=jeof) break;\n    if (!txt || !txt[j]) {\n      c = '\\n';\n    } else if (txt[j] == '\\r') {\n      if (j<jeof-1 && txt[j+1]=='\\n') j++;\n      c = '\\n';\n    } else {\n      c = txt[j];\n    }\n    buf[i] = c;\n  }\n  buf[i] = '\\0';\n  if (!strng) {\n    ((y_vopen_t *)file)->addr += j;\n  } else if (i>=buflen-1 && txt && txt[j] && j>0) {\n    /* handle case where fgets stopped because buflen too short to hold line */\n    ((y_vopen_t *)file)->offset += j;\n  } else {\n    ((y_vopen_t *)file)->addr++;\n    ((y_vopen_t *)file)->offset = 0;\n  }\n  return buf;\n}\n\nstatic int\nyv_fputs(p_file *file, const char *buf)\n{\n  if (!buf) return 0;\n  if (((y_vopen_t *)file)->binary == 2) {\n    long n, addr = ((y_vopen_t *)file)->addr;\n    long len = ((y_vopen_t *)file)->array->type.number;\n    long nhead = (char *)((y_vopen_t *)file)->array->value.q -\n      (char *)((y_vopen_t *)file)->array;\n    char *line;\n    for (;;) {\n      if (addr == len) {\n        n = nhead + (len+len)*sizeof(char*);\n        ((y_vopen_t *)file)->array = p_realloc(((y_vopen_t *)file)->array, n);\n        for (n=0 ; n<len ; n++) ((y_vopen_t *)file)->array->value.q[len+n] = 0;\n        ((y_vopen_t *)file)->array->type.number =\n          ((y_vopen_t *)file)->array->type.dims->number = len + len;\n      }\n      for (n=0 ; buf[n] && buf[n]!='\\n' ; n++);\n      line = ((y_vopen_t *)file)->array->value.q[addr];\n      if (n) {\n        ((y_vopen_t *)file)->array->value.q[addr] = p_strncat(line, buf, n);\n        if (line) p_free(line);\n      } else if (!line) {\n        ((y_vopen_t *)file)->array->value.q[addr] = p_strcpy(\"\");\n      }\n      if (buf[n] == '\\n') addr++, n++;\n      if (!buf[n]) break;\n      buf += n;\n    }\n    ((y_vopen_t *)file)->addr = addr;\n    if (addr > ((y_vopen_t *)file)->maxaddr)\n      ((y_vopen_t *)file)->maxaddr = addr;\n  } else {\n    YError(\"p_fputs to binary or read-only vopen file handle\");\n  }\n  return 0;\n}\n\nstatic unsigned long\nyv_fread(p_file *file, void *buf, unsigned long nbytes)\n{\n  int strng = (((y_vopen_t *)file)->array->ops->typeID == T_STRING);\n  char *cbuf=buf, *txt=0;\n  unsigned long j, jeof=0;\n  if (!strng) {\n    txt = ((y_vopen_t *)file)->array->value.c + ((y_vopen_t *)file)->addr;\n    jeof = ((y_vopen_t *)file)->array->type.number - ((y_vopen_t *)file)->addr;\n  } else {\n    YError(\"p_fread from text vopen file handle\");\n  }\n  if (!nbytes) return 0L;\n  for (j=0 ; j<nbytes ; j++) {\n    if (!strng && j>=jeof) break;\n    cbuf[j] = txt[j];\n    if (strng && !txt[j]) break;\n  }\n  if (!strng) ((y_vopen_t *)file)->addr += j;\n  else ((y_vopen_t *)file)->addr++;\n  return j;\n}\n\nstatic unsigned long\nyv_fwrite(p_file *file, const void *buf, unsigned long nbytes)\n{\n  if (((y_vopen_t *)file)->binary == 3) {\n    long len = ((y_vopen_t *)file)->array->type.number;\n    long i = ((y_vopen_t *)file)->addr;\n    if (i+nbytes > len) {\n      /* double array size if at eof */\n      long j, n = len + len;\n      long nhead = (char *)((y_vopen_t *)file)->array->value.c -\n        (char *)((y_vopen_t *)file)->array;\n      while (n < i+nbytes) n += n;\n      ((y_vopen_t *)file)->array = p_realloc(((y_vopen_t *)file)->array,\n                                             nhead + n);\n      for (j=len ; j<n ; j++) ((y_vopen_t *)file)->array->value.c[j] = '\\0';\n      ((y_vopen_t *)file)->array->type.number =\n        ((y_vopen_t *)file)->array->type.dims->number = n;\n    }\n    if (nbytes) memcpy(((y_vopen_t *)file)->array->value.c+i, buf, nbytes);\n    ((y_vopen_t *)file)->addr = (i += nbytes);\n    if (i > ((y_vopen_t *)file)->maxaddr) ((y_vopen_t *)file)->maxaddr = i;\n  } else {\n    YError(\"p_fwrite to text or read-only vopen file handle\");\n  }\n  return nbytes;\n}\n\nstatic int\nyv_feof(p_file *file)\n{\n  return (((y_vopen_t *)file)->addr\n          >= ((y_vopen_t *)file)->array->type.number);\n}\n\nstatic int yv_ferror(p_file *file) { return 0; }\nstatic int yv_fflush(p_file *file) { return 0; }\n\nstatic int\nyv_fclose(p_file *file)\n{\n  Array *array = ((y_vopen_t *)file)->array;\n  ((y_vopen_t *)file)->array = 0;\n  Unref(array);\n  p_free(file);\n  return 0;\n}\n\n/* ----- end vopen implementation ----- */\n\nstatic char **yplug_path = 0;\n\nvoid\nY_plug_dir(int nArgs)\n{\n  Dimension *dims = 0;\n  char **d = (nArgs==1)? YGet_Q(sp, 1, &dims) : 0;\n  long nd = d? TotalNumber(dims) : 0;\n  int i;\n  if (nArgs > 1)\n    YError(\"plug_dir function takes at most one argument\");\n  if (nArgs && !CalledAsSubroutine()) {\n    for (i=0 ; yplug_path && yplug_path[i] ; i++);\n    if (i > 1) {\n      int n = i - 1;\n      Array *rslt;\n      Dimension *tmp = tmpDims;\n      tmpDims = 0;\n      FreeDimension(tmp);\n      tmpDims = NewDimension((long)n, 1L, (Dimension *)0);\n      rslt = (Array *)PushDataBlock(NewArray(&stringStruct, tmpDims));\n      for (i=0 ; i<n ; i++)\n        rslt->value.q[i] = p_strcpy(yplug_path[i]);\n    } else {\n      PushDataBlock(RefNC(&nilDB));\n    }\n    if (!nd) return;\n  }\n  if (yplug_path) {\n    for (i=0 ; yplug_path[i] ; i++) {\n      p_free(yplug_path[i]);\n      yplug_path[i] = 0;\n    }\n    p_free(yplug_path);\n    yplug_path = 0;\n  }\n  yplug_path = p_malloc(sizeof(char *)*(nd+2));\n  for (i=0 ; i<=nd ; i++) {\n    if (i < nd) {\n      yplug_path[i] = YExpandName(d[i]);\n      YNameToHead(&yplug_path[i]);\n    } else {\n      yplug_path[i] = p_strncat(yHomeDir, \"lib/\", 0L);\n    }\n  }\n  yplug_path[nd+1] = 0;\n}\n\nstruct y_package_t {\n  char *name;\n  y_pkg_t *init;\n  char **ifiles;\n  BuiltIn **code;\n  void **data;\n  char **varname;\n};\nstatic struct y_package_t *y_pkg_list = 0;\nstatic int y_npkg = 0;\nstatic int y_n0pkg = 0;\n\nchar *\ny_pkg_name(int i)\n{\n  return (i<0 || i>=y_npkg || !y_pkg_list)? 0 : y_pkg_list[i].name;\n}\n\nint\ny_pkg_count(int i)\n{\n  return i? y_npkg : y_n0pkg;\n}\n\ny_pkg_t *\ny_pkg_lookup(char *name)\n{\n  int i;\n  for (i=0 ; i<y_npkg ; i++)\n    if (!strcmp(y_pkg_list[i].name, name))\n      return y_pkg_list[i].init;\n  return 0;\n}\n\nvoid\ny_pkg_add(y_pkg_t *init)\n{\n  char **ifiles, **varname;\n  BuiltIn **code;\n  void **data;\n  char *pkgname = init(&ifiles, &code, &data, &varname);\n  if (!y_pkg_list)\n    y_pkg_list = p_malloc(sizeof(struct y_package_t)*8);\n  else if (!(y_npkg & 7))\n    y_pkg_list = p_realloc(y_pkg_list, sizeof(struct y_package_t)*(y_npkg+8));\n  y_pkg_list[y_npkg].name = pkgname;\n  y_pkg_list[y_npkg].init = init;\n  y_pkg_list[y_npkg].ifiles = ifiles;\n  y_pkg_list[y_npkg].code = code;\n  y_pkg_list[y_npkg].data = data;\n  y_pkg_list[y_npkg].varname = varname;\n  y_npkg++;\n}\n\nstatic void y_pkg_0link(char **varname, BuiltIn **code, void **data);\n\nvoid\ny_pkg_link(char *name)\n{\n  /* use name==0 to relink every package */\n  int i;\n  if (!y_n0pkg) y_n0pkg = y_npkg;\n  for (i=0 ; i<y_npkg ; i++) {\n    if (!name || !strcmp(y_pkg_list[i].name, name)) {\n      y_pkg_0link(y_pkg_list[i].varname,\n                  y_pkg_list[i].code, y_pkg_list[i].data);\n      if (name) break;\n    }\n  }\n}\n\nstatic void\ny_pkg_0link(char **varname, BuiltIn **code, void **data)\n{\n  long index;\n  DataBlock *db;\n\n  /* initialize built-in functions */\n  if (code) while (*code) {\n    index = Globalize(*varname++, 0L);\n    db = globTab[index].ops==&dataBlockSym? globTab[index].value.db : 0;\n    if (!db || db->ops!=&builtinOps ||\n        ((BIFunction *)db)->function!=*code) {\n      globTab[index].value.db = (DataBlock *)NewBIFunction(*code, index);\n      globTab[index].ops = &dataBlockSym;\n      Unref(db);\n    }\n    code++;\n  }\n\n  /* initialize compiled variables */\n  if (data) while (*data) {\n    index = Globalize(*varname++, 0L);\n    db = globTab[index].ops==&dataBlockSym? globTab[index].value.db : 0;\n    if (!db || db->ops!=&lvalueOps || ((LValue *)db)->type.base->file ||\n        ((LValue *)db)->owner || ((LValue *)db)->address.m!=*data) {\n      /* note: everything starts out as a scalar char at the correct address\n       * - subsequent reshape will set true data type and dimensions\n       */\n      globTab[index].value.db =\n        (DataBlock *)NewLValueM((Array *)0, *data++,\n                                &charStruct, (Dimension *)0);\n      globTab[index].ops = &dataBlockSym;\n    }\n    Unref(db);\n  }\n}\n\nvoid\ny_pkg_include(char *name, int now)\n{\n  char **ifiles, *msg;\n  int i;\n  /* use name==0 to relink every package */\n  if (now) {\n    for (i=0 ; i<y_npkg ; i++) {\n      if (!name || !strcmp(y_pkg_list[i].name, name)) {\n        ifiles = y_pkg_list[i].ifiles;\n        if (ifiles) while (ifiles[0]) {\n          if (YpPushInclude(*ifiles++)) {\n            IncludeNow();\n          } else {\n            msg= p_strncat(\"missing include file \", ifiles[-1], 0);\n            YWarning(msg);\n            p_free(msg);\n          }\n        }\n        if (name) break;\n      }\n    }\n  } else {\n    /* when not immediate (e.g.- at startup) push in reverse order */\n    for (i=y_npkg-1 ; i>=0 ; i--) {\n      if (!name || !strcmp(y_pkg_list[i].name, name)) {\n        ifiles = y_pkg_list[i].ifiles;\n        if (ifiles) {\n          while (ifiles[0]) ifiles++;\n          for (ifiles-- ; ifiles>=y_pkg_list[i].ifiles ; ifiles--)\n            YpPush(ifiles[0]);\n        }\n        if (name) break;\n      }\n    }\n  }\n}\n\nvoid\nY_plug_in(int nArgs)\n{\n  char *pname, *pkgname;\n  y_pkg_t *init = 0;\n  void *plug;\n  int i;\n  if (nArgs!=1) YError(\"plug_in function takes exactly one argument\");\n  pkgname = YGetString(sp-nArgs+1);\n  if (!pkgname || !pkgname[0]) \n    YError(\"plug_in: package name argument is null\");\n  for (i=1 ; pkgname[i] ; i++);\n  for (pname=pkgname+i-1 ; pname>pkgname ; pname--)\n    if (pname[0]=='/' || pname[0]=='\\\\') break;\n\n  /* become a no-op if pkgname already plugged in */\n  if (y_pkg_lookup(pname)) return;\n\n  if (!yplug_path) Y_plug_dir(0);\n\n  plug = p_dlopen(pkgname);\n  if (!plug && !YIsAbsolute(pkgname)) {\n    /* check in plug_dir and Y_HOME/lib before giving up */\n    char *tmp;\n    for (i=0 ; yplug_path[i] ; i++) {\n      tmp = p_strncat(yplug_path[i], pkgname, 0L);\n      plug = p_dlopen(tmp);\n      p_free(tmp);\n      if (plug) break;\n    }\n  }\n  if (plug) {\n    char *tmp = p_strncat(\"yk_\", pname, 0);\n    int failed = p_dlsym(plug, tmp, 0, &init);\n    p_free(tmp);\n    if (failed || !init)\n      YError(\"plug_in: dynamic library missing yk_<pkgname> function\");\n  }\n  if (init) {\n    y_pkg_add(init);\n    y_pkg_link(pname);\n  } else {\n    YError(\"plug_in: unable to find dynamic library file\");\n  }\n}\n\nvoid Y_require(int nArgs)\n{\n  char *full, *name, *tail= 0;\n  long i;\n  if (nArgs!=1) YError(\"require function takes exactly one argument\");\n  full= YGetString(sp);\n  name= YNameTail(full);\n  for (i=0 ; i<sourceTab.nItems ; i++) {\n    tail= YNameTail(sourceTab.names[i]);\n    if (name && tail && strcmp(tail, name)==0) break;\n    p_free(tail);\n    tail= 0;\n  }\n  p_free(name);\n  p_free(tail);\n  if (i>=sourceTab.nItems && !YpPushInclude(full))\n    YError(\"missing include file specified in require function\");\n  Drop(nArgs);\n  if (i>=sourceTab.nItems)\n    IncludeNow();   /* parse and maybe execute file to be included */\n}\n\nvoid Y_current_include(int argc)\n{\n  if (argc != 1 || YNotNil(sp))\n    y_error(\"current_include takes exactly one nil argument\");\n  if (nYpIncludes > 0 && ypIncludes[nYpIncludes-1].filename != NULL) {\n    *ypush_q(NULL) = p_strcpy(ypIncludes[nYpIncludes-1].filename);\n  } else {\n    ypush_nil();\n  }\n}\n\nvoid Y_get_includes(int argc)\n{\n  if (argc != 1 || YNotNil(sp))\n    YError(\"get_includes takes exactly one nil argument\");\n  if (sourceTab.nItems > 0) {\n    long i, n;\n    long dims[2];\n    char **s;\n    dims[0] = 1L;\n    dims[1] = (n = sourceTab.nItems);\n    s = ypush_q(dims);\n    for (i = 0; i < n; ++i) {\n      s[i] = p_strcpy(sourceTab.names[i]);\n    }\n  } else {\n    ypush_nil();\n  }\n}\n\n/*--------------------------------------------------------------------------*/\n\nstatic int findingFunc= 0;\n/* error handling hacks (for mpy) set up with set_idler\n * bit\n *  1  do not print error messages (like .SYNC.)\n *  2  include [pc] after func name in error messages\n *  4  call after_error in dbug mode (rather than full stack reset)\n *     - after_error responsible for calling dbexit\n *  8  reserved for use by y_errhook\n */\nPLUG_API int yerror_flags;\nint yerror_flags = 0;\n\nFunction *FuncContaining(Instruction *pc)\n{\n  Function *func= 0;\n\n  if (!findingFunc && pc) {\n    long i = -1;\n    if (pc>=taskCode && pc<=taskCode+4) return 0;\n    findingFunc = 1;\n    for (;; i++) {\n      while (pc[i].Action) i++;\n      if (pc[i-1].Action==&Return) break;\n    }\n    i++;\n    /* Now pc[i] is the Instruction generated by following line\n       in parse.c (YpFunc):\n          vmCode[nextPC].index= codeSize= nPos+nKey+nLocal+ nextPC;\n       (nextPC does NOT include the parameters or locals)\n     */\n    i -= pc[i].index;\n    if (i<0) {\n      /* see also Pointee function in ydata.c */\n      func = (Function *)((char *)(pc+i) - offsetof(Function, code));\n      findingFunc = 0;\n    }\n  }\n\n  if (findingFunc) {\n    /* may get here after a disaster causing an interrupt above, as well\n       as after scanning from a garbled initial pc */\n    int no_pf = ((yerror_flags&1) != 0);\n    findingFunc = 0;\n    if (!no_pf) YputsErr(\"(BUG) lost function produced following error:\");\n  }\n  return func;\n}\n\n/*--------------------------------------------------------------------------*/\n\nvoid ResetStack(int hard)\n{\n  Instruction *pcRet;\n  while ((pcRet= AbortReturn())) if (pcRet==&taskCode[2] && !hard) break;\n}\n\n/*--------------------------------------------------------------------------*/\n\nstatic int y_do_not_abort = 0;\n\nvoid\ny_on_exception(int signal, char *errmsg)\n{\n  /* signal==PSIG_SOFT for call to p_abort, otherwise this is real signal */\n  if (signal != PSIG_SOFT) {\n    y_do_not_abort = 1;\n    if (signal==PSIG_INT)\n      {\n        y_catch_category= 0x04;\n        YError(\"Keyboard interrupt received (SIGINT)\");\n      }\n    else if (signal==PSIG_FPE)\n      {\n        y_catch_category= 0x01;\n        YError(\"Floating point interrupt (SIGFPE)\");\n      }\n    else if (signal==PSIG_SEGV)\n      YError(\"Segmentation violation interrupt (SIGSEGV)\");\n    else if (signal==PSIG_ILL)\n      YError(\"Illegal instruction interrupt (SIGILL)\");\n    else if (signal==PSIG_BUS)\n      YError(\"Misaligned address interrupt (SIGBUS)\");\n    else if (signal==PSIG_IO)\n      YError((errmsg&&errmsg[0])? errmsg : \"I/O interrupt (SIGIO)\");\n    else\n      YError((errmsg&&errmsg[0])? errmsg :\n             \"Unrecognized signal delivered to y_on_exception\");\n  }\n  if (ym_state&Y_QUITTING) {\n    y_cleanup();\n    p_quit();\n  }\n}\n\nvoid YWarning(const char *msg)\n{\n  strcpy(yWarningMsg, \"WARNING \");\n  strncat(yWarningMsg, msg, 120);\n  YputsErr(yWarningMsg);\n}\n\nstatic char *includeFile= 0;\nstatic long mainIndex= -1;\nInstruction *yErrorPC= 0;   /* for dbup function in debug.c */\n\nstatic void yset_catchmsg(char *tmsg);\nstatic long after_index = -1;\n\nPLUG_API int (*y_errhook)(const char *msg, long *after);\nint (*y_errhook)(const char *msg, long *after) = 0;\n\nvoid\nYError(const char *msg)\n{\n  extern void yg_got_expose(void);\n  long beginLine= ypBeginLine;\n  Instruction *pcDebug= pc;\n  Function *func;\n  char *name;\n  DebugBlk *dbg;\n  Instruction *pcUp=yErrorPC, *pcue;\n  int category;\n  int no_abort = y_do_not_abort;\n  int no_print = 0, no_pf = ((yerror_flags&1) != 0);\n  int no_reset = ((yerror_flags&4) != 0);\n\n  int recursing= inYError;\n  inYError++;\n  yErrorPC= 0;\n  y_do_not_abort = 0;\n\n  category= y_catch_category;\n  y_catch_category= 0x08;\n\n  ym_state &= ~Y_PENDING;\n  ym_dbenter = 0;\n\n  if (recursing>8 || yImpossible>8) {\n    if (!no_pf) YputsErr(\"****FATAL**** YError looping -- quitting now\");\n    ym_state|= Y_QUITTING;\n    ym_fatal = 3;\n    if (!no_abort) p_abort();\n    return;\n  }\n  yImpossible++;  /* zeroed only by GetNextLine and after CatchScan */\n\n  if (!caughtTask && CatchScan(msg, category)) {\n    /* resume at catch PC if this error has been caught --\n     * is this really proof against catastrophic looping? */\n    inYError= 0;\n    yImpossible= 0;\n    caughtTask= 1;\n    if (!no_abort) p_abort();\n    return;\n  } else if (caughtTask) {\n    caughtTask= 0;\n    if (!no_pf) YputsErr(\"****OOPS**** error on read resume or throw/catch\");\n  }\n\n  if (y_idler_function) {\n    /* remove any idler on error - after_error can reset if desired */\n    Function *f= y_idler_function;\n    y_idler_function= 0;\n    Unref(f);\n  }\n  if (after_index < 0) after_index = yget_global(\"after_error\", 0L);\n  if (!y_idler_fault\n      && globTab[after_index].ops == &dataBlockSym\n      && globTab[after_index].value.db->ops == &functionOps) {\n    /* if after_error function present, make it the idler */\n    y_idler_function = (Function *)Ref(globTab[after_index].value.db);\n    y_idler_fault = 1;\n  } else {\n    y_idler_fault = 0;\n  }\n\n  /* this is a nasty hack for mpy and after_error */\n  no_print = no_pf || (msg && !strcmp(msg, \".SYNC.\"));\n\n  for (;;) {\n    func = (((ym_state&Y_RUNNING)||no_abort) && !recursing &&\n            pcUp!=&taskCode[2])? FuncContaining(pcDebug) : 0;\n    if (!func || !func->errup) break;\n    ClearStack();\n    pcue = AbortReturn();\n    if (!pcue || pcue==&taskCode[2]) break;\n    pcDebug = pc = pcue;\n    func = 0;\n  }\n  name = func? globalTable.names[func->code[0].index] : \"VM idle or lost\";\n\n  /* Clear out include stack, but remember current include file name.\n     If the error happened while executing a main program which came from\n     the include file, then includeFile will be the filename, and\n     ypBeginLine will be the line number at which the errant main\n     program began.  (No other line number information will be available\n     for a main program?)  */\n  if (!recursing) {\n    char *tmp= includeFile;\n    includeFile= 0;\n    p_free(tmp);\n    if (nYpIncludes)\n      includeFile= p_strcpy(ypIncludes[nYpIncludes-1].filename);\n  }\n  YpClearIncludes();\n\n  /* Clean up any Array temporaries (used for data format conversions).  */\n  if (recursing<2) ClearTmpArray();\n\n  /* Clear out any pending keyboard input or tasks.  */\n  if (recursing<3) {\n    p_qclear();\n    ClearTasks();\n  } else if (nTasks) {\n    if (!no_pf) YputsErr(\"WARNING unable to free task pointers in YError\");\n    nTasks = 0;\n  }\n\n  /* Print error message, with name of current Yorick function prepended:\n        ERROR (yorick_function) msg passed to YError\n        ERROR (VM idle or lost) msg passed to YError\n     The second form is used when the virtual machine is idle at the\n     time of the error.  */\n  if (!pcUp || recursing)\n    strcpy(yErrorMsg, \"ERROR (\");\n  else\n    strcpy(yErrorMsg, \"Up to (\");\n  strncat(yErrorMsg, name, 40);\n  if (func && (yerror_flags&2)!=0) {\n    char relpc[32];\n    sprintf(relpc, \"[%ld]\", (long)(pcDebug-func->code));\n    strncat(yErrorMsg, relpc, 12);\n  }\n  strcat(yErrorMsg, \") \");\n  if (!pcUp || recursing)\n    strncat(yErrorMsg, msg, 140);\n  if (y_errhook) {\n    long index;\n    int hook = y_errhook(yErrorMsg, &index);\n    if (no_print != no_pf) no_pf = (hook & 1);\n    else no_print = no_pf = (hook & 1);\n    if ((hook & 2)\n        && globTab[index].ops == &dataBlockSym\n        && globTab[index].value.db->ops == &functionOps) {\n      /* if alternate after_error function present, make it the idler */\n      y_idler_function = (Function *)Ref(globTab[index].value.db);\n      no_reset = ((hook & 4) != 0);\n    }\n  }\n  if (!no_print) YputsErr(yErrorMsg);\n\n  if (recursing) {\n    func= 0;\n    if (!no_print) YputsErr(\"WARNING aborting on recursive calls to YError\");\n  } else if (ym_state&Y_SUSPENDED) {\n    func= 0;\n    if (y_read_prompt) {\n      if (!no_print) YputsErr(\"WARNING aborting on YError\"\n                              \" during keyboard read()\");\n    } else if (ym_suspc) {\n      if (!no_print) YputsErr(\"WARNING aborting on YError during suspend\");\n    } else {\n      if (!no_print) YputsErr(\"WARNING aborting on YError\"\n                              \" after mouse() pause() or wait=1\");\n    }\n  }\n  ym_suspc = 0;\n  if (yg_blocking==3 || yg_blocking==4) yg_blocking = 0;\n\n  if (func && !no_print) {\n    /* Try to find the source code for this function.  */\n    long index= func->code[0].index;\n    if (mainIndex<0) mainIndex= Globalize(\"*main*\", 0L);\n    if (index==mainIndex) {\n      name= includeFile;\n    } else {\n      char *mess= YpReparse(func);\n      if (nTasks) ClearTasks();\n      if (mess[0]!='*') {\n        /* reparse succeeded, skip to filename */\n        name= 0;\n        while (mess[0] && mess[0]!=':') mess++;\n        if (mess[0]) do { mess++; } while (mess[0] && mess[0]!=':');\n        if (mess[0]) {\n          mess++;\n          if (mess[0]==' ') mess++;\n          if (mess[0]) name= mess;\n        }\n      } else {\n        /* reparse failed */\n        name= 0;\n      }\n      beginLine= 0;  /* used only for *main* from includeFile */\n    }\n\n    /* Push debug info (function and code index) onto stack.  */\n    ClearStack();\n    CheckStack(2);\n    dbg= NewDebugBlk(func, pcDebug-func->code, name, beginLine);\n    if (dbg) {\n      PushDataBlock(dbg);\n    } else {\n      ResetStack(0);\n      YputsErr(\"Function corrupted, cannot enter debug mode.\");\n    }\n\n    if (y_idler_function) {\n      /* special after_error function will get control */\n      if (no_reset && yDebugLevel<=2 && !y_read_prompt) {\n        if (yDebugLevel>1) ResetStack(0);\n      } else {\n        ResetStack(1);\n        yr_reset();\n      }\n      yg_got_expose();\n    } else if (!yBatchMode && !pcUp && (!yAutoDebug || yDebugLevel>1)) {\n      if (yDebugLevel>1) {\n        YputsErr(\" To enter recursive debug level, type <RETURN> now\");\n      } else {\n        YputsErr(\" To enter debug mode, type <RETURN> now\"\n                 \" (then dbexit to get out)\");\n      }\n      ym_dbenter = 1;\n    }\n\n  } else {\n    /* Clear the stack back to the most recent debugging level,\n     * or completely clear if aborting a read() operation.  */\n    if (recursing<5) {\n      ResetStack(y_read_prompt!=0);\n    } else {\n      if (!no_pf) YputsErr(\"****SEVERE**** YError unable to reset stack -- \"\n                           \"probably lost variables\");\n      sp= spBottom;\n    }\n    ym_state &= ~Y_SUSPENDED;\n    if (y_read_prompt) yr_reset();\n    yg_got_expose();  /* in case window,wait=1 or pause */\n  }\n  p_clr_alarm(0, 0);\n  ym_after_dq(-1);\n\n  if (ym_state&Y_QUITTING) {\n    if (!no_pf)\n      YputsErr(\"****TERMINATING**** on error after main loop exit\");\n    if (!no_abort) p_abort();\n    return;\n  }\n\n  if ((yBatchMode && !y_idler_function) || !strncmp(msg,\"(FATAL)\",7)) {\n    if (!no_pf) {\n      if (yBatchMode) YputsErr(\"yorick: quitting on error in batch mode\");\n      else YputsErr(\"yorick: quitting on fatal error\");\n    }\n    ym_fatal = yBatchMode? 1 : 2;\n    ResetStack(0);\n    ym_state|= Y_QUITTING;\n  }\n\n  /* set catch_message variable for after_error function */\n  if (y_idler_function) yset_catchmsg(yErrorMsg);\n\n  /* Go back to the main loop.  */\n  inYError= 0;\n  if (!no_abort) p_abort();\n}\n\n/*--------------------------------------------------------------------------*/\n\nstatic Function *help_worker= 0;\n\nvoid Y_help(int nArgs)\n{\n  Symbol *stack= sp-nArgs+1;\n  long index, worker_arg, isrc=-1;\n  int nAbove;\n  p_file *file;\n\n  worker_arg= Globalize(\"help_topic\", 0L);\n\n  while (stack<=sp && !stack->ops) stack+=2;  /* skip any keywords */\n  nAbove= sp-stack;\n  if (nAbove>=0) {\n    /* a legal argument has been supplied */\n    if (stack->ops==&referenceSym) {\n      index= stack->index;\n      ReplaceRef(stack);\n    } else {\n      index= -1;\n    }\n    if (stack->ops==&dataBlockSym) {\n      DataBlock *db= stack->value.db;\n      Operations *ops= db->ops;\n      if (ops==&functionOps) {\n        Function *f= (Function *)db;\n        index= f->code[0].index;\n        isrc = f->isrc;\n      } else if (ops==&structDefOps) {\n        StructDef *base= (StructDef *)db;\n        while (base->model) base= base->model;\n        index= Globalize(yStructTable.names[base->index], 0L);\n      } else if (ops==&builtinOps) {\n        BIFunction *f= (BIFunction *)db;\n        index= f->index;\n      }\n    }\n    Drop(nAbove);\n    nArgs-= nAbove+1;\n  } else {\n    /* no legal arguments, help function itself is target */\n    BIFunction *f= (BIFunction *)(sp-nArgs)->value.db;\n    index= f->index;\n    PushDataBlock(RefNC(&nilDB));\n  }\n\n  /* move help topic argument off stack into help_topic extern variable */\n  PopTo(&globTab[worker_arg]);  /* help_topic */\n  Drop(nArgs);  /* only argument of any conceivable value just saved */\n\n  if (!help_worker) {\n    long help_index= Globalize(\"help_worker\", 0L);\n    if (globTab[help_index].ops!=&dataBlockSym ||\n        (help_worker= (Function *)Ref(globTab[help_index].value.db))->ops\n        !=&functionOps)\n      YError(\"(BUG) help_worker function not found -- help unavailable\");\n  }\n\n  /* create help_file extern variable */\n  if (index>=0 && (file= OpenSource(index, isrc)))\n    PushDataBlock(NewTextStream(p_strcpy(ypIncludes[nYpIncludes-1].filename),\n                                file, 1, ypBeginLine-1, p_ftell(file)));\n  else\n    PushDataBlock(RefNC(&nilDB));\n  worker_arg= Globalize(\"help_file\", 0L);\n  PopTo(&globTab[worker_arg]);  /* help_file */\n\n  RunTaskNow(help_worker);\n}\n\n/*--------------------------------------------------------------------------*/\n\nvoid Y_exit(int nArgs)\n{\n  char *msg= 0;\n  if (nArgs>1) YError(\"exit takes exactly zero or one argument\");\n  if (nArgs==1 && YNotNil(sp)) msg= YGetString(sp);\n  if (msg) YputsOut(msg);\n  else YputsOut(\"EXIT called, back to main loop\");\n  ResetStack(0);\n  p_abort();\n}\n\nvoid Y_error(int nArgs)\n{\n  char *msg= 0;\n  if (nArgs>1) YError(\"error takes exactly zero or one argument\");\n  if (nArgs==1 && YNotNil(sp)) msg= YGetString(sp);\n  y_catch_category= 0x10;\n  if (msg) YError(msg);\n  else YError(\"<interpreted error function called>\");\n}\n\n/* FIXME: this should also turn off on_stdin event handling */\nvoid Y_batch(int nArgs)\n{\n  int flag= 2;\n  if (nArgs>1) YError(\"batch takes exactly zero or one argument\");\n  if (nArgs==1 && YNotNil(sp)) {\n    flag= (YGetInteger(sp)!=0);\n    Drop(1);\n  }\n  PushIntValue(yBatchMode);\n  if (flag!=2) yBatchMode= flag;\n}\n\n/*--------------------------------------------------------------------------*/\n\nstatic Catcher *CatchNew(void)\n{\n  if (n_catchers>=max_catchers) {\n    catchers= p_realloc(catchers, (max_catchers+16)*sizeof(Catcher));\n    max_catchers+= 16;\n  }\n  catchers[n_catchers].task= 0;\n  catchers[n_catchers].pc= 0;\n  catchers[n_catchers].isp= 0;\n  catchers[n_catchers].category= 0;\n  return &catchers[n_catchers++];\n}\n\nvoid YCatchDrop(long isp)\n{\n  while (n_catchers>0 && catchers[n_catchers-1].isp>=isp) {\n    n_catchers--;\n    catchers[n_catchers].category= 0;\n  }\n\n  if (n_catchers>0) ispCatch= catchers[n_catchers-1].isp;\n  else ispCatch= 0;\n\n  if ((max_catchers>>6) > n_catchers) {\n    /* attempt to limit damage from runaway catch calls */\n    catchers= p_realloc(catchers, (max_catchers>>6)*sizeof(Catcher));\n    max_catchers>>= 6;\n  }\n}\n\nstatic Catcher *CatchScan(const char *msg, int category)\n{\n  long i= n_catchers-1;\n  while (i>=0 && !(category&catchers[i].category)) {\n    if (catchers[i].task != &taskCode[2]) i= 0;\n    i--;\n  }\n\n  if (i>=0) {\n    char tmsg[144];\n    Instruction *pcRet;\n    Symbol *spCatch= spBottom + catchers[i].isp;\n    catchers[i].category= 0;  /* disable this catcher */\n\n    /* note: msg itself might be on stack! */\n    strncpy(tmsg, msg, 140);\n    tmsg[140]= '\\0';\n\n    for (;;) {\n      ClearStack();\n      if (spCatch >= sp) break;\n      pcRet= AbortReturn();\n      if (!pcRet || pcRet==&taskCode[2])\n        YError(\"catch does not work outside immediate include or require\");\n    }\n    if (spCatch!=sp) YError(\"(BUG) impossible catch or corrupt stack\");\n    pc= catchers[i].pc;\n    PushIntValue(1);\n\n    /* set catch_message variable (after stack cleared) */\n    yset_catchmsg(tmsg);\n\n    return &catchers[i];\n\n  } else {\n    return 0;\n  }\n}\n\nstatic void\nyset_catchmsg(char *tmsg)\n{\n  Array *array;\n  long cmsg = Globalize(\"catch_message\", 0L);\n  if (globTab[cmsg].ops==&dataBlockSym) {\n    globTab[cmsg].ops = &intScalar;\n    Unref(globTab[cmsg].value.db);\n  }\n  array=  NewArray(&stringStruct, (Dimension *)0);\n  globTab[cmsg].value.db = (DataBlock *)array;\n  globTab[cmsg].ops = &dataBlockSym;\n  array->value.q[0] = p_strcpy(tmsg);\n}\n\nextern VMaction BranchFalse, BranchTrue;\n\nvoid Y_catch(int nArgs)\n{\n  Catcher *catcher= 0;\n  long i= n_catchers-1;\n  long isp= (sp-2) - spBottom;\n  int category;\n  if (nArgs!=1) YError(\"catch takes exactly one argument\");\n  category= YGetInteger(sp);\n  if ((sp-2)->ops != &returnSym ||\n      (pc->Action!=&BranchFalse && pc->Action!=&BranchTrue))\n    YError(\"catch() must be the condition in an if or while statement\");\n\n  while (i>=0 && catchers[i].task==&taskCode[2] && catchers[i].isp==isp) {\n    if (catchers[i].pc==pc) {\n      catcher= &catchers[i];\n      break;\n    }\n    i--;\n  }\n  if (!catcher) catcher= CatchNew();\n  catcher->task= &taskCode[2];\n  catcher->pc= pc;\n  catcher->isp= ispCatch= isp;\n  catcher->category= category;\n\n  PushIntValue(0);\n}\n\n/*--------------------------------------------------------------------------*/\n\nvoid Y_set_idler(int nArgs)\n{\n  Function *f;\n  if (nArgs>1) {\n    /* second argument is hack to add error handling features */\n    if (nArgs==2 && sp[-1].ops) yerror_flags = YGetInteger(sp);\n    else YError(\"set_idler function takes zero or one arguments\");\n  }\n\n  if (nArgs>0 && YNotNil(sp-nArgs+1)) {\n    f = (Function *)sp[1-nArgs].value.db;\n    if (sp[1-nArgs].ops!=&dataBlockSym || f->ops!=&functionOps)\n      YError(\"set_idler expecting function as argument\");\n    y_idler_function = Ref(f);\n\n  } else if (y_idler_function) {\n    f = y_idler_function;\n    y_idler_function = 0;\n    Unref(f);\n  }\n}\n\n/*--------------------------------------------------------------------------*/\n",
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/play/pstdlib.h": "/*\n * $Id: pstdlib.h,v 1.1 2005-09-18 22:05:31 dhmunro Exp $\n * portability layer basic memory management interface\n */\n/* Copyright (c) 2005, The Regents of the University of California.\n * All rights reserved.\n * This file is part of yorick (http://yorick.sourceforge.net).\n * Read the accompanying LICENSE file for details.\n */\n\n#include <stdlib.h>\n\n#include \"plugin.h\"\n\nBEGIN_EXTERN_C\n\nPLUG_API void *(*p_malloc)(size_t);\nPLUG_API void  (*p_free)(void *);\nPLUG_API void *(*p_realloc)(void *, size_t);\n\n/* above data loaded to system malloc, free, and realloc\n * -- call p_mminit to get mm version\n */\n#ifdef P_DEBUG\n#define p_mminit p_mmdebug\nPLUG2_API int p_mmcheck(void *p);\nPLUG2_API void p_mmguard(void *b, unsigned long n);\nPLUG2_API long p_mmextra, p_mmoffset;\n#endif\nPLUG_API void p_mminit(void);\n\n/* make trivial memory statistics globally available\n * -- counts total number of allocations, frees, and\n *    current number of large blocks */\nPLUG_API long p_nallocs;\nPLUG_API long p_nfrees;\nPLUG_API long p_nsmall;\nPLUG_API long p_asmall;\n\n/* define this to get control when mm functions fail\n * -- if it returns, must return 0 */\nPLUG_API void *(*p_mmfail)(unsigned long n);\n\n/* temporary space */\n#define P_WKSIZ 2048\ntypedef union {\n  char c[P_WKSIZ+8];\n  int i[P_WKSIZ/8];\n  long l[P_WKSIZ/8];\n  double d[P_WKSIZ/8];\n} p_twkspc;\nPLUG_API p_twkspc p_wkspc;\n\n/* similar to the string.h functions, but p_malloc destination\n * - 0 src is acceptable */\nPLUG_API void *p_memcpy(const void *, size_t);\nPLUG_API char *p_strcpy(const char *);\nPLUG_API char *p_strncat(const char *, const char *, size_t);\n\n/* expand leading env var, ~, set / or \\ separators, free with p_free */\nPLUG_API char *p_native(const char *unix_name);\n\n/* dont do anything critical if this is set -- signal an error */\nPLUG2_API volatile int p_signalling;\n\n/* dynamic linking interface\n * dlname is filename not including .so, .dll, .dylib, etc. suffix\n * symbol is name in a C program\n * type is 0 if expecting a function, 1 if expecting data\n * paddr is &addr where addr is void* or void(*)(),\n * p_dlsym return value is 0 on success, 1 on failure */\nPLUG_API void *p_dlopen(const char *dlname);\nPLUG_API int p_dlsym(void *handle, const char *symbol, int type, void *paddr);\n\n/* interface for synchronous subprocess\n * (p_popen, p_spawn in pstdio.h for asynchronous)\n */\nPLUG_API int p_system(const char *cmdline);\n\nEND_EXTERN_C\n",
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/play/win/wdl.c": "/*\n * $Id: wdl.c,v 1.1 2005-09-18 22:05:38 dhmunro Exp $\n * MS Windows version of play dynamic linking operations\n */\n/* Copyright (c) 2005, The Regents of the University of California.\n * All rights reserved.\n * This file is part of yorick (http://yorick.sourceforge.net).\n * Read the accompanying LICENSE file for details.\n */\n\n#include \"config.h\"\n\n#include \"pstdlib.h\"\n#include \"playw.h\"\n#include <string.h>\n\n#ifdef PLUG_HEADER\n#include PLUG_HEADER\n#endif\n\n#ifndef PLUG_DISABLE\n\n#ifndef PLUG_SUFFIX\n# define PLUG_SUFFIX \".dll\"\n#endif\n\nvoid *\np_dlopen(const char *dlname)\n{\n  void *handle = 0;\n  if (dlname && dlname[0]) {\n    char *name = p_strncat(w_pathname(dlname), PLUG_SUFFIX, 0);\n    handle = LoadLibrary(name);\n    p_free(name);\n  }\n  return handle;\n}\n\nint\np_dlsym(void *handle, const char *symbol, int type, void *paddr)\n{\n  void **addr = paddr;\n  addr[0] = GetProcAddress(handle, symbol);\n  return !addr[0];\n}\n\n\n\n#else\n\n/* ARGSUSED */\nvoid *\np_dlopen(const char *dlname)\n{\n  return 0;\n}\n\n/* ARGSUSED */\nint\np_dlsym(void *handle, const char *symbol, int type, void *paddr)\n{\n  void **addr = paddr;\n  addr[0] = 0;\n  return 1;\n}\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/play/unix/PLUGIN.txt": "Dynamic linking requires four platform/compiler dependent steps:\n\n(1) Compiling the udl.c p_dlopen/p_dlsym dynamic linking functions:\n\n    $(CC) $(CPPFLAGS) $(CFLAGS) $(PLUG_UDL) -c udl.c\n\n(2) Linking the main program which calls p_dlopen/p_dlsym:\n\n    CCPLUG=$(CC) $(LDOPTIONS) $(LDFLAGS) $(PLUG_EXPORT)\n    $(CCPLUG) -o prog $(PROG_OBJS) $(PROG_LIBS) $(PLUG_LIB)\n      PROG_OBJS are the .o files for the program\n      PROG_LIBS are the -l libraries for the program\n\n(3) Compiling position-independent objects to go in a plugin:\n\n    $(CC) $(CPPFLAGS) $(CFLAGS) $(PLUG_PIC) -c udl.c\n\n(4) Linking a plugin:\n\n    LD_PLUGIN=$(CC) $(LDOPTIONS) $(LDFLAGS) $(PLUG_SHARED)\n    $(LD_PLUGIN) -o plugin$(PLUG_SFX) $(PLUGIN_OBJS) $(PLUGIN_LIBS)\n      PLUGIN_OBJS are the .o files for the plugin, built with (3)\n      PLUGIN_LIBS are the -l libraries for the plugin\n\nThe flags and other Makefile variables to be determined by config.sh\nhave the following meanings:\n\nPLUG_UDL    -DPLUG_... define that selects branch of udl.c for this platform\n          Supported values are currently:\n  -DPLUG_LIBDL   dlopen/dlsym in most UNIX systems\n  -DPLUG_HPUX    shl_load/shl_findsym in HPUX systems\n  -DPLUG_MACOSX  NSLinkModule/NSLookupSymbolInModule in Darwin systems\n  (see play/win/wdl.c for Windows LoadLibrary support)\n  -DPLUG_UNSUPPORTED  non-functional stubs\n\nPLUG_LIB    -ldl or other system library containing functions called by\n          udl.c, or blank if in libc or other default library\nPLUG_EXPORT compiler flag required to allow functions in the plugins to\n          call functions in the main program (yorick plugins always\n          need to do this to get their arguments from the interpreter),\n          corresponding to -export-dynamic libtool flag, often -Wl,-E\n\nPLUG_PIC    -fPIC or other compiler flag required to produce position\n          independent code required for a plugin\n\nPLUG_SHARED -shared or other compiler flag required to link PIC object\n          files into a plugin (that is, a shared library) instead of\n          an ordinary executable, corresponding to -module libtool flag\nPLUG_SFX    native file suffix for plugins, .so for most UNIX platforms,\n          but .sl for HPUX (possibly should use .so everywhere)\n          (must match PLUG_SUFFIX in udl.c)\n\nThe config,sh script recognizes several platforms by the uname -s\ncommand.  The following platforms are recognized and yorick should\nsupport plugins for at least some versions of the OS:\n\nLinux, FreeBSD, NetBSD, OpenBSD, and other GNU-based systems\nSunOS\nIRIX*\nAIX\nOSF1\nHP-UX\nDarwin\n\nYou can look in config.sh to see what values yorick uses on each\nplatform.  If your system needs other values, you can either edit\nMake.cfg by hand after the top level make config to set the\nappropriate values, or add a branch to the case statement in config.sh\nbefore running make config.\n\nThere are deeper incompatibilities among the different platforms,\nwhich have only slight, if any, consequences for yorick plugins.  The\nmost significant is that the AIX -bexpall switch in PLUG_EXPORT does not\nexport symbol names beginning with underscore \"_\".  Hence, no variable\nor function in the yorick main program whose name begins with _ will\nbe visible to a plugin on AIX.  This is not a significant limitation.\n\nThe PLUG_EXPORT flags for SunOS and IRIX are not obvious.  IRIX\ndocumentation suggests '-Wl,-hidden_symbol,*' may be necessary.  A\nsignificant worry is that libtool resorts to creating its own list of\nevery extern symbol in the program for some platforms.  If this is\nnecessary on any platform, the simple system adopted here will not\nwork, and yorick plugins will not be available.\n\nOn IRIX, can convert any .a file to a .so file like this:\n    ld -shared -all libmine.a -o libmine.so\n\nOn HPUX, PLUG_PIC=+z would mostly work, and the -b flag to ld could be\nused instead of the -n flag to cc.\n\nOn Linux i86 systems, the above flags work with the Intel icc compiler\nas well as with the GNU gcc compiler.  I don't know about the Portland\npgcc compiler.\n\nOn Mac OS X systems, a plugin is called a \"bundle\", and PLUG_SHARED is\n-bundle -bundle_loader $(YORICK_EXE), where YORICK_EXE is the path to\nthe yorick executable (or whatever program calls p_dlopen).  This is\nthe only system for which the LD_PLUGIN command must reference the\nexecutable that will be loading the plugin.  In principle, this would\nallow the bundle to be statically linked back to the yorick\nexecutable, so that the plugin would run only with one particular\nexecutable.  However, experiments prove that is not actually what\nhappens on OSX; a plugin linked with -bundle_loader set to one version\nof yorick can in fact be loaded by other yorick executables.  In\nparticular, a yorick plugin need not always be upgraded or rebuilt\nwhen the yorick executable is upgraded, a very useful feature shared\nby all the other operating systems.\n\nMac OS X features a separate shared library binary type, \".dylib\",\nwhich for versions <=10.2 was not able to link back to the yorick API.\nas of 10.3, this appears to be possible in principal.  There is no\nswitch to CC to produce such a binary; you need to use libtool (_not_\nGNU libtool!).  The link command is:\nLD_PLUGIN=MACOSX_DEPLOYMENT_TARGET=10.3 libtool -dynamic -undefined dynamic_lookup\nHowever, I could not get this to work properly for the\ncerfc function in extend/; libtool fails with a message that cerfc.o\ncontains symbols in the wrong segment.  If you force it to produce\ncerfc.dylib, yorick dies when you attempt to call the cerfc function.\nIn any event, it appears that -bundle is the intended binary format\nfor plugins, so I abandoned my attempts to get .dylib to work for that\npurpose.  Python extensions use -bundle.  I didn't check perl.\n",
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/play/unix/config.c": "/*\n * $Id: config.c,v 1.1 2005-09-18 22:05:39 dhmunro Exp $\n * configuration tester for UNIX machines\n */\n/* Copyright (c) 2005, The Regents of the University of California.\n * All rights reserved.\n * This file is part of yorick (http://yorick.sourceforge.net).\n * Read the accompanying LICENSE file for details.\n */\n\n#define MAIN_DECLARE int main(int argc, char *argv[])\n#define MAIN_RETURN(value) return value\n\n#ifdef TEST_GCC\n# ifdef __GNUC__\nMAIN_DECLARE {\n  MAIN_RETURN(0); }\n# else\n#error not gcc\n# endif\n#endif\n\n#ifdef TEST_UTIME\n/* check settings of: USE_GETRUSAGE USE_TIMES */\n#include \"timeu.c\"\nMAIN_DECLARE {\n  double s;\n  double t = p_cpu_secs(&s);\n  MAIN_RETURN(t!=0.); }\n#endif\n\n#ifdef TEST_WTIME\n/* check settings of: USE_GETTIMEOFDAY */\n#include \"timew.c\"\nMAIN_DECLARE {\n  double t = p_wall_secs();\n  MAIN_RETURN(t!=0.); }\n#endif\n\n#ifdef TEST_USERNM\n/* check settings of: NO_PASSWD */\n#include \"usernm.c\"\nMAIN_DECLARE {\n  char *u = p_getuser();\n  MAIN_RETURN(u==0); }\n#endif\n\n#ifdef TEST_TIOCGPGRP\n/* check settings of: USE_TIOCGPGRP_IOCTL */\n#include \"uinbg.c\"\nMAIN_DECLARE {\n  MAIN_RETURN(u_in_background()); }\n#endif\n\n#ifdef TEST_GETCWD\n/* check settings of: USE_GETWD */\n#include <unistd.h>\nstatic char dirbuf[1024];\n#ifdef USE_GETWD\n#define getcwd(x,y) getwd(x)\n#endif\nMAIN_DECLARE {\n  char *u = getcwd(dirbuf, 1024);\n  MAIN_RETURN(u==0); }\n#endif\n\n#ifdef TEST_DIRENT\n/* check settings of: DIRENT_HEADER USE_GETWD */\n#include \"dir.c\"\np_twkspc p_wkspc;\nMAIN_DECLARE {\n  p_dir *d = p_dopen(\"no/such/thing\");\n  int value = 0;\n  char *l = p_dnext(d, &value);\n  MAIN_RETURN(p_chdir(l) || p_rmdir(l) || p_mkdir(l)); }\n#endif\n\n#ifdef TEST_POLL\n/* check settings of: USE_SYS_POLL_H USE_SELECT HAVE_SYS_SELECT_H\n                      NO_SYS_TIME_H NEED_SELECT_PROTO */\n#include \"uevent.c\"\nMAIN_DECLARE {\n  int p = u_poll(1000);\n  MAIN_RETURN(p!=0); }\n#endif\n\n#ifdef TEST_PLUG\n/* check settings of: PLUG_LIBDL PLUG_HPUX PLUG_MACOSX */\n/* also check that udltest.c can call function in main executable */\nextern int testcall(int check);\nint testcall(int check) {\n  return (check == 13579);\n}\n#include \"udltest.c\"\nMAIN_DECLARE {\n  union {\n    void *data;\n    void (*function)(int);\n  } addr;\n  void *h = test_dlopen();\n  if (!h) {\n    return 1;\n  } else if (!(test_dlsym(h, 1, &addr) & 1)) {\n    return 2;\n  } else {\n    int *pdat = addr.data;\n    if (!pdat || pdat[0]!=-1 || pdat[1]!=-2) {\n      return 3;\n    } else if (!(test_dlsym(h, 0, &addr) & 2)) {\n      return 4;\n    } else {\n      void (*pfun)(int) = addr.function;\n      pdat[0] = 24680;\n      pfun(13579);\n      if (pdat[0]!=13579 || pdat[1]!=24680) {\n        return 5;\n      }\n    }\n  }\n  MAIN_RETURN(0); }\n#endif\n\n#ifdef TEST_SOCKETS\n/* check if IEEE 1003.1 sockets present, seek usock.c */\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netdb.h>\nMAIN_DECLARE {\n  static struct addrinfo hints, *ai;\n  char text[1025];\n  int fd;\n  hints.ai_family = AF_UNIX;\n  hints.ai_family = AF_UNSPEC;\n  hints.ai_socktype = SOCK_STREAM;\n  hints.ai_flags = AI_PASSIVE;  /* will call bind, not connect */\n  getaddrinfo(0, text, &hints, &ai);\n  fd = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);\n  if (fd != -1) {\n    struct sockaddr_storage sad;\n    socklen_t lsad = sizeof(struct sockaddr_storage);\n    struct sockaddr *psad = (struct sockaddr *)&sad;\n    getsockname(fd, psad, &lsad);\n    getnameinfo(psad, lsad, 0, 0, text, 1025, NI_NUMERICSERV);\n  }\n  MAIN_RETURN(0); }\n#endif\n\n#ifdef TEST_FENV_H\n#include <fenv.h>\n#include <signal.h>\nMAIN_DECLARE {\n  int except = FE_DIVBYZERO | FE_INVALID | FE_OVERFLOW;\n  fenv_t env;\n  if (fetestexcept(except)) {\n    feclearexcept(except);\n  }\n  fegetenv(&env);\n  fesetenv(FE_DFL_ENV);\n  MAIN_RETURN(0); }\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/play/unix/udltest.c": "/*\n * $Id: udltest.c,v 1.1 2005-09-18 22:05:41 dhmunro Exp $\n * test of play dynamic link functions (with config.c TEST_DL branch)\n */\n/* Copyright (c) 2005, The Regents of the University of California.\n * All rights reserved.\n * This file is part of yorick (http://yorick.sourceforge.net).\n * Read the accompanying LICENSE file for details.\n */\n\n#if defined(TEST_SHARED)\n\n/* main() that dlopens this is TEST_DL branch of config.c */\nextern void fun(int x);\nextern int dat[2];\nint dat[2] = { -1, -2 };\nvoid fun(int x) {\n  extern int testcall(int);\n  if (dat[0]>0 && testcall(x)) {\n    dat[1] = dat[0];\n    dat[0] = x;\n  }\n}\n\n\n\n#else\n\n#ifdef PLUG_HEADER\n#include PLUG_HEADER\n#endif\n\n#if defined(PLUG_LIBDL)\n\n#ifndef PLUG_SUFFIX\n# define PLUG_SUFFIX \".so\"\n#endif\n\n#ifndef PLUG_HEADER\n#include <dlfcn.h>\n#endif\n\n#ifndef PLUG_FLAGS\n# define PLUG_FLAGS RTLD_LAZY | RTLD_GLOBAL\n#endif\n\nextern void *test_dlopen(void);\nextern int test_dlsym(void *handle, int dat, void *paddr);\n\nvoid *\ntest_dlopen(void)\n{\n  return dlopen(\"./udltest\" PLUG_SUFFIX, PLUG_FLAGS);\n}\n\nint\ntest_dlsym(void *handle, int dat, void *paddr)\n{\n  void **addr = paddr;\n  addr[0] = dlsym(handle, (dat? \"dat\" : \"fun\"));\n  return addr[0]? 3 : 0;\n}\n\n\n\n#elif defined(PLUG_HPUX)\n\n#define PLUG_SUFFIX \".sl\"\n\n#ifndef PLUG_HEADER\n#include <dl.h>\n#endif\n\n#ifndef PLUG_FLAGS\n# define PLUG_FLAGS BIND_DEFERRED\n#endif\n\nextern void *test_dlopen(void);\nextern int test_dlsym(void *handle, int dat, void *paddr);\n\nvoid *\ntest_dlopen(void)\n{\n  return (void *)shl_load(\"./udltest\" PLUG_SUFFIX, PLUG_FLAGS);\n}\n\nint\ntest_dlsym(void *handle, int dat, void *paddr)\n{\n  void **addr = paddr;\n  int notok = shl_findsym(&handle, (dat? \"dat\" : \"fun\"), TYPE_UNDEFINED, addr);\n  return (notok || !addr[0])? 0 : 3;\n}\n\n\n\n#elif defined(PLUG_MACOSX)\n\n#define PLUG_SUFFIX \".so\"\n\n#ifndef PLUG_HEADER\n#include <mach-o/dyld.h>\n#endif\n\nvoid *\ntest_dlopen(void)\n{\n  void *handle = 0;\n  NSObjectFileImage file_image;\n  if (NSCreateObjectFileImageFromFile(\"./udltest\" PLUG_SUFFIX, &file_image) ==\n      NSObjectFileImageSuccess) {\n    handle = (void *)NSLinkModule(file_image, \"./udltest\" PLUG_SUFFIX, \n                                  NSLINKMODULE_OPTION_RETURN_ON_ERROR\n                                  | NSLINKMODULE_OPTION_PRIVATE);\n    NSDestroyObjectFileImage(file_image);\n  }\n  return handle;  /* actually type NSModule */\n}\n\nint\ntest_dlsym(void *handle, int dat, void *paddr)\n{\n  void **addr = paddr;\n  NSSymbol sym = NSLookupSymbolInModule(handle, (dat? \"_dat\" : \"_fun\"));\n  if (sym) addr[0] = NSAddressOfSymbol(sym);\n  return addr[0]? 3 : 0;\n}\n\n\n\n#elif defined(PLUG_MACOSX_DYLIB)\n# do not use this branch, see notes in udl.c\n\n#define PLUG_SUFFIX \".dylib\"\n\n#ifndef PLUG_HEADER\n#include <mach-o/dyld.h>\n#endif\n\n#ifndef PLUG_FLAGS\n# define PLUG_FLAGS NSLOOKUPSYMBOLINIMAGE_OPTION_BIND\n#endif\n\nextern void *test_dlopen(void);\nextern int test_dlsym(void *handle, int dat, void *paddr);\n\nvoid *\ntest_dlopen(void)\n{\n  return (void *)NSAddImage(\"./udltest\" PLUG_SUFFIX,\n                            NSADDIMAGE_OPTION_RETURN_ON_ERROR);\n}\n\nint\ntest_dlsym(void *handle, int dat, void *paddr)\n{\n  void **addr = paddr;\n  addr[0] = 0;\n  if (NSIsSymbolNameDefinedInImage(handle, (dat? \"_dat\" : \"_fun\"))) {\n    NSSymbol nss =\n      NSLookupSymbolInImage(handle, (dat? \"_dat\" : \"_fun\"), PLUG_FLAGS |\n                            NSLOOKUPSYMBOLINIMAGE_OPTION_RETURN_ON_ERROR);\n    if (nss) addr[0] = NSAddressOfSymbol(nss);\n  }\n  return (!addr[0])? 0 : 3;\n}\n\n\n\n#else\n\n#error one of PLUG_LIBDL, PLUG_HPUX, or PLUG_MACOSX must be set\n\n#endif\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/play/unix/udl.c": "/*\n * $Id: udl.c,v 1.1 2005-09-18 22:05:41 dhmunro Exp $\n * UNIX version of play dynamic linking operations\n */\n/* Copyright (c) 2005, The Regents of the University of California.\n * All rights reserved.\n * This file is part of yorick (http://yorick.sourceforge.net).\n * Read the accompanying LICENSE file for details.\n */\n\n#include \"config.h\"\n\n#include \"playu.h\"\n#include \"pstdlib.h\"\n#include <string.h>\n\n#ifdef PLUG_HEADER\n#include PLUG_HEADER\n#endif\n\n#if defined(PLUG_LIBDL)\n\n#ifndef PLUG_SUFFIX\n# define PLUG_SUFFIX \".so\"\n#endif\n\n#ifndef PLUG_HEADER\n#include <dlfcn.h>\n#endif\n\n#ifndef PLUG_FLAGS\n# define PLUG_FLAGS RTLD_LAZY | RTLD_GLOBAL\n#endif\n\nvoid *\np_dlopen(const char *dlname)\n{\n  void *handle = 0;\n  if (dlname && dlname[0]) {\n    char *name = p_strncat(u_pathname(dlname), PLUG_SUFFIX, 0);\n    handle = dlopen(name, PLUG_FLAGS);\n    p_free(name);\n  }\n  return handle;\n}\n\nint\np_dlsym(void *handle, const char *symbol, int type, void *paddr)\n{\n  void **addr = paddr;\n  addr[0] = dlsym(handle, symbol);\n  /* correct way to detect failure if a==0 were legal:\n   *   const char *msg = dlerror();\n   *   if (msg) return 0;\n   */\n  return !addr[0];\n}\n\n\n\n#elif defined(PLUG_HPUX)\n\n#define PLUG_SUFFIX \".sl\"\n\n#ifndef PLUG_HEADER\n#include <dl.h>\n#endif\n#include <errno.h>\n\n#ifndef PLUG_FLAGS\n# define PLUG_FLAGS BIND_DEFERRED\n#endif\n\nvoid *\np_dlopen(const char *dlname)\n{\n  void *handle = 0;\n  if (dlname && dlname[0]) {\n    char *name = p_strncat(u_pathname(dlname), PLUG_SUFFIX, 0);\n    handle = (void *)shl_load(name, PLUG_FLAGS, 0);\n    p_free(name);\n  }\n  return handle;\n}\n\nint\np_dlsym(void *handle, const char *symbol, int type, void *paddr)\n{\n  void **addr = paddr;\n  short expect = type? ((type&1)? TYPE_DATA : TYPE_UNDEFINED) : TYPE_PROCEDURE;\n  int notok = shl_findsym(&handle, symbol, expect, paddr);\n  return notok || !addr[0];\n}\n\n\n\n#elif defined(PLUG_MACOSX)\n/* Apple now deprecates this.  At Mac OS X 10.4 and beyond, use PLUG_LIBDL.\n * see https://developer.apple.com/library/mac/#qa/qa1180/_index.html\n */\n\n#define PLUG_SUFFIX \".so\"\n\n#ifndef PLUG_HEADER\n#include <mach-o/dyld.h>\n#endif\n\nvoid *\np_dlopen(const char *dlname)\n{\n  void *handle = 0;\n  if (dlname && dlname[0]) {\n    char *name = p_strncat(u_pathname(dlname), PLUG_SUFFIX, 0);\n    NSObjectFileImage file_image;\n    if (NSCreateObjectFileImageFromFile(name, &file_image) ==\n        NSObjectFileImageSuccess) {\n      handle = (void *)NSLinkModule(file_image, name, \n                                    NSLINKMODULE_OPTION_RETURN_ON_ERROR\n                                    | NSLINKMODULE_OPTION_PRIVATE);\n      NSDestroyObjectFileImage(file_image);\n    }\n    p_free(name);\n  }\n  return handle;  /* actually type NSModule */\n}\n\nint\np_dlsym(void *handle, const char *symbol, int type, void *paddr)\n{\n  void **addr = paddr;\n  addr[0] = 0;\n  if (symbol && symbol[0]) {\n    char *symname = p_strncat(\"_\", symbol, 0);\n    NSSymbol sym = NSLookupSymbolInModule(handle, symname);\n    if (sym) addr[0] = NSAddressOfSymbol(sym);\n    p_free(symname);\n  }\n  return !addr[0];\n}\n\n\n\n#elif defined(PLUG_MACOSX_DYLIB)\n/*\n  this is fossil code - it is correct, but I couldn't get the linker\n  to build a correct optimized .dylib for the cerfc example in extend/\n\n  a more careful reading of the Mach-O documentation (the tech note on\n  porting to UNIX in particular) suggests that plugins are supposed\n  to be implemented with the -bundle switch to the compiler, not .dylib\n  the required MACOSX_DEPLOYMENT_TARGET env var to libtool exists only\n  from 10.3 onward, so -bundle is the only possibility for <=10.2\n*/\n\n#define PLUG_SUFFIX \".dylib\"\n\n#ifndef PLUG_HEADER\n#include <mach-o/dyld.h>\n#endif\n\n#ifndef PLUG_FLAGS\n# define PLUG_FLAGS NSLOOKUPSYMBOLINIMAGE_OPTION_BIND\n#endif\n\nvoid *\np_dlopen(const char *dlname)\n{\n  void *handle = 0;\n  if (dlname && dlname[0]) {\n    char *name = p_strncat(u_pathname(dlname), PLUG_SUFFIX, 0);\n    handle = (void *)NSAddImage(name, NSADDIMAGE_OPTION_RETURN_ON_ERROR);\n    p_free(name);\n  }\n  return handle;  /* actually type (struct mach_header *) */\n}\n\nint\np_dlsym(void *handle, const char *symbol, int type, void *paddr)\n{\n  void **addr = paddr;\n  addr[0] = 0;\n  if (symbol && symbol[0]) {\n    char *symname = p_strncat(\"_\", symbol, 0);\n    if (NSIsSymbolNameDefinedInImage(handle, symname)) {\n      NSSymbol nss =\n        NSLookupSymbolInImage(handle, symname, PLUG_FLAGS |\n                              NSLOOKUPSYMBOLINIMAGE_OPTION_RETURN_ON_ERROR);\n      if (nss) addr[0] = NSAddressOfSymbol(nss);\n    }\n    p_free(symname);\n  }\n  return !addr[0];\n}\n\n\n\n#else\n\n/* ARGSUSED */\nvoid *\np_dlopen(const char *dlname)\n{\n  return 0;\n}\n\n/* ARGSUSED */\nint\np_dlsym(void *handle, const char *symbol, int type, void *paddr)\n{\n  void **addr = paddr;\n  addr[0] = 0;\n  return 1;\n}\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/win/yflat.vcxproj": "\ufeff<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Project DefaultTargets=\"Build\" ToolsVersion=\"12.0\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n  <ItemGroup Label=\"ProjectConfigurations\">\n    <ProjectConfiguration Include=\"Debug|Win32\">\n      <Configuration>Debug</Configuration>\n      <Platform>Win32</Platform>\n    </ProjectConfiguration>\n    <ProjectConfiguration Include=\"Debug|x64\">\n      <Configuration>Debug</Configuration>\n      <Platform>x64</Platform>\n    </ProjectConfiguration>\n    <ProjectConfiguration Include=\"Release|Win32\">\n      <Configuration>Release</Configuration>\n      <Platform>Win32</Platform>\n    </ProjectConfiguration>\n    <ProjectConfiguration Include=\"Release|x64\">\n      <Configuration>Release</Configuration>\n      <Platform>x64</Platform>\n    </ProjectConfiguration>\n    <ProjectConfiguration Include=\"Template|Win32\">\n      <Configuration>Template</Configuration>\n      <Platform>Win32</Platform>\n    </ProjectConfiguration>\n    <ProjectConfiguration Include=\"Template|x64\">\n      <Configuration>Template</Configuration>\n      <Platform>x64</Platform>\n    </ProjectConfiguration>\n  </ItemGroup>\n  <PropertyGroup Label=\"Globals\">\n    <SccProjectName />\n    <SccLocalPath />\n    <Keyword>MFCProj</Keyword>\n    <ProjectGuid>{C0523648-3F4A-4E0B-8902-4BE9D61F20CE}</ProjectGuid>\n  </PropertyGroup>\n  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.Default.props\" />\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Template|Win32'\" Label=\"Configuration\">\n    <ConfigurationType>Application</ConfigurationType>\n    <PlatformToolset>v120</PlatformToolset>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Template|x64'\" Label=\"Configuration\">\n    <ConfigurationType>Application</ConfigurationType>\n    <PlatformToolset>v120</PlatformToolset>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\" Label=\"Configuration\">\n    <ConfigurationType>Application</ConfigurationType>\n    <PlatformToolset>v120</PlatformToolset>\n    <UseOfMfc>Dynamic</UseOfMfc>\n    <CharacterSet>Unicode</CharacterSet>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\" Label=\"Configuration\">\n    <ConfigurationType>Application</ConfigurationType>\n    <PlatformToolset>v120</PlatformToolset>\n    <UseOfMfc>Dynamic</UseOfMfc>\n    <CharacterSet>Unicode</CharacterSet>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\" Label=\"Configuration\">\n    <ConfigurationType>Application</ConfigurationType>\n    <PlatformToolset>v120</PlatformToolset>\n    <UseOfMfc>Dynamic</UseOfMfc>\n    <CharacterSet>MultiByte</CharacterSet>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"Configuration\">\n    <ConfigurationType>Application</ConfigurationType>\n    <PlatformToolset>v120</PlatformToolset>\n    <UseOfMfc>Dynamic</UseOfMfc>\n    <CharacterSet>MultiByte</CharacterSet>\n  </PropertyGroup>\n  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.props\" />\n  <ImportGroup Label=\"ExtensionSettings\">\n  </ImportGroup>\n  <ImportGroup Label=\"PropertySheets\" Condition=\"'$(Configuration)|$(Platform)'=='Template|Win32'\">\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n  </ImportGroup>\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Template|x64'\" Label=\"PropertySheets\">\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n  </ImportGroup>\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\" Label=\"PropertySheets\">\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n    <Import Project=\"$(VCTargetsPath)Microsoft.Cpp.UpgradeFromVC60.props\" />\n  </ImportGroup>\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\" Label=\"PropertySheets\">\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n    <Import Project=\"$(VCTargetsPath)Microsoft.Cpp.UpgradeFromVC60.props\" />\n  </ImportGroup>\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\" Label=\"PropertySheets\">\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n    <Import Project=\"$(VCTargetsPath)Microsoft.Cpp.UpgradeFromVC60.props\" />\n  </ImportGroup>\n  <ImportGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\" Label=\"PropertySheets\">\n    <Import Project=\"$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props\" Condition=\"exists('$(UserRootDir)\\Microsoft.Cpp.$(Platform).user.props')\" Label=\"LocalAppDataPlatform\" />\n    <Import Project=\"$(VCTargetsPath)Microsoft.Cpp.UpgradeFromVC60.props\" />\n  </ImportGroup>\n  <PropertyGroup Label=\"UserMacros\" />\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">\n    <OutDir>.\\..\\Release\\</OutDir>\n    <IntDir>.\\..\\Release\\</IntDir>\n    <LinkIncremental>false</LinkIncremental>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">\n    <LinkIncremental>false</LinkIncremental>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">\n    <OutDir>.\\..\\Debug\\</OutDir>\n    <IntDir>.\\..\\Debug\\</IntDir>\n    <LinkIncremental>true</LinkIncremental>\n  </PropertyGroup>\n  <PropertyGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n    <LinkIncremental>true</LinkIncremental>\n  </PropertyGroup>\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">\n    <ClCompile>\n      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>\n      <InlineFunctionExpansion>Default</InlineFunctionExpansion>\n      <StringPooling>true</StringPooling>\n      <FunctionLevelLinking>true</FunctionLevelLinking>\n      <Optimization>MaxSpeed</Optimization>\n      <SuppressStartupBanner>true</SuppressStartupBanner>\n      <WarningLevel>Level3</WarningLevel>\n      <AdditionalIncludeDirectories>..\\play;..\\play\\win;..\\gist;..\\yorick;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <AssemblerListingLocation>.\\..\\Release\\</AssemblerListingLocation>\n      <PrecompiledHeaderOutputFile>.\\..\\Release\\yflat.pch</PrecompiledHeaderOutputFile>\n      <ObjectFileName>.\\..\\Release\\</ObjectFileName>\n      <ProgramDataBaseFileName>.\\..\\Release\\</ProgramDataBaseFileName>\n    </ClCompile>\n    <Midl>\n      <SuppressStartupBanner>true</SuppressStartupBanner>\n      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <TypeLibraryName>.\\..\\Release\\yflat.tlb</TypeLibraryName>\n      <MkTypLibCompatible>true</MkTypLibCompatible>\n      <TargetEnvironment>Win32</TargetEnvironment>\n    </Midl>\n    <ResourceCompile>\n      <Culture>0x0409</Culture>\n      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n    </ResourceCompile>\n    <Bscmake>\n      <SuppressStartupBanner>true</SuppressStartupBanner>\n      <OutputFile>.\\..\\Release\\yflat.bsc</OutputFile>\n    </Bscmake>\n    <Link>\n      <SuppressStartupBanner>true</SuppressStartupBanner>\n      <SubSystem>Windows</SubSystem>\n      <OutputFile>.\\..\\Release\\yflat.exe</OutputFile>\n    </Link>\n  </ItemDefinitionGroup>\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">\n    <ClCompile>\n      <RuntimeLibrary>MultiThreadedDLL</RuntimeLibrary>\n      <InlineFunctionExpansion>Default</InlineFunctionExpansion>\n      <StringPooling>true</StringPooling>\n      <FunctionLevelLinking>true</FunctionLevelLinking>\n      <Optimization>MaxSpeed</Optimization>\n      <SuppressStartupBanner>true</SuppressStartupBanner>\n      <WarningLevel>Level3</WarningLevel>\n      <AdditionalIncludeDirectories>..\\play;..\\play\\win;..\\gist;..\\yorick;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n      <PreprocessorDefinitions>WIN32;NDEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <AssemblerListingLocation>.\\..\\Release\\</AssemblerListingLocation>\n      <PrecompiledHeaderOutputFile>.\\..\\Release\\yflat.pch</PrecompiledHeaderOutputFile>\n      <ObjectFileName>.\\..\\Release\\</ObjectFileName>\n      <ProgramDataBaseFileName>.\\..\\Release\\</ProgramDataBaseFileName>\n    </ClCompile>\n    <Midl>\n      <SuppressStartupBanner>true</SuppressStartupBanner>\n      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <TypeLibraryName>.\\..\\Release\\yflat.tlb</TypeLibraryName>\n      <MkTypLibCompatible>true</MkTypLibCompatible>\n    </Midl>\n    <ResourceCompile>\n      <Culture>0x0409</Culture>\n      <PreprocessorDefinitions>NDEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n    </ResourceCompile>\n    <Bscmake>\n      <SuppressStartupBanner>true</SuppressStartupBanner>\n      <OutputFile>.\\..\\Release\\yflat.bsc</OutputFile>\n    </Bscmake>\n    <Link>\n      <SuppressStartupBanner>true</SuppressStartupBanner>\n      <SubSystem>Windows</SubSystem>\n      <OutputFile>.\\..\\Release\\yflat.exe</OutputFile>\n    </Link>\n  </ItemDefinitionGroup>\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">\n    <ClCompile>\n      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>\n      <InlineFunctionExpansion>Default</InlineFunctionExpansion>\n      <FunctionLevelLinking>false</FunctionLevelLinking>\n      <Optimization>Disabled</Optimization>\n      <SuppressStartupBanner>true</SuppressStartupBanner>\n      <WarningLevel>Level3</WarningLevel>\n      <MinimalRebuild>true</MinimalRebuild>\n      <DebugInformationFormat>EditAndContinue</DebugInformationFormat>\n      <AdditionalIncludeDirectories>..\\play;..\\play\\win;..\\gist;..\\yorick;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <AssemblerListingLocation>.\\..\\Debug\\</AssemblerListingLocation>\n      <PrecompiledHeaderOutputFile>.\\..\\Debug\\yflat.pch</PrecompiledHeaderOutputFile>\n      <ObjectFileName>.\\..\\Debug\\</ObjectFileName>\n      <ProgramDataBaseFileName>.\\..\\Debug\\</ProgramDataBaseFileName>\n      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>\n    </ClCompile>\n    <Midl>\n      <SuppressStartupBanner>true</SuppressStartupBanner>\n      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <TypeLibraryName>.\\..\\Debug\\yflat.tlb</TypeLibraryName>\n      <MkTypLibCompatible>true</MkTypLibCompatible>\n      <TargetEnvironment>Win32</TargetEnvironment>\n    </Midl>\n    <ResourceCompile>\n      <Culture>0x0409</Culture>\n      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n    </ResourceCompile>\n    <Bscmake>\n      <SuppressStartupBanner>true</SuppressStartupBanner>\n      <OutputFile>.\\..\\Debug\\yflat.bsc</OutputFile>\n    </Bscmake>\n    <Link>\n      <SuppressStartupBanner>true</SuppressStartupBanner>\n      <GenerateDebugInformation>true</GenerateDebugInformation>\n      <SubSystem>Windows</SubSystem>\n      <OutputFile>.\\..\\Debug\\yflat.exe</OutputFile>\n    </Link>\n  </ItemDefinitionGroup>\n  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">\n    <ClCompile>\n      <RuntimeLibrary>MultiThreadedDebugDLL</RuntimeLibrary>\n      <InlineFunctionExpansion>Default</InlineFunctionExpansion>\n      <FunctionLevelLinking>false</FunctionLevelLinking>\n      <Optimization>Disabled</Optimization>\n      <SuppressStartupBanner>true</SuppressStartupBanner>\n      <WarningLevel>Level3</WarningLevel>\n      <DebugInformationFormat>ProgramDatabase</DebugInformationFormat>\n      <AdditionalIncludeDirectories>..\\play;..\\play\\win;..\\gist;..\\yorick;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n      <PreprocessorDefinitions>WIN32;_DEBUG;_WINDOWS;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <AssemblerListingLocation>.\\..\\Debug\\</AssemblerListingLocation>\n      <PrecompiledHeaderOutputFile>.\\..\\Debug\\yflat.pch</PrecompiledHeaderOutputFile>\n      <ObjectFileName>.\\..\\Debug\\</ObjectFileName>\n      <ProgramDataBaseFileName>.\\..\\Debug\\</ProgramDataBaseFileName>\n      <BasicRuntimeChecks>EnableFastChecks</BasicRuntimeChecks>\n    </ClCompile>\n    <Midl>\n      <SuppressStartupBanner>true</SuppressStartupBanner>\n      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <TypeLibraryName>.\\..\\Debug\\yflat.tlb</TypeLibraryName>\n      <MkTypLibCompatible>true</MkTypLibCompatible>\n    </Midl>\n    <ResourceCompile>\n      <Culture>0x0409</Culture>\n      <PreprocessorDefinitions>_DEBUG;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n    </ResourceCompile>\n    <Bscmake>\n      <SuppressStartupBanner>true</SuppressStartupBanner>\n      <OutputFile>.\\..\\Debug\\yflat.bsc</OutputFile>\n    </Bscmake>\n    <Link>\n      <SuppressStartupBanner>true</SuppressStartupBanner>\n      <GenerateDebugInformation>true</GenerateDebugInformation>\n      <SubSystem>Windows</SubSystem>\n      <OutputFile>.\\..\\Debug\\yflat.exe</OutputFile>\n    </Link>\n  </ItemDefinitionGroup>\n  <ItemGroup>\n    <ClCompile Include=\"..\\drat\\bound.c\" />\n    <ClCompile Include=\"..\\drat\\drat.c\" />\n    <ClCompile Include=\"..\\drat\\track.c\" />\n    <ClCompile Include=\"..\\drat\\trans.c\" />\n    <ClCompile Include=\"..\\drat\\ydrat.c\" />\n    <ClCompile Include=\"..\\fft\\cfft2.c\">\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">Disabled</Optimization>\n      <Optimization Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">Disabled</Optimization>\n    </ClCompile>\n    <ClCompile Include=\"..\\fft\\cfftb.c\" />\n    <ClCompile Include=\"..\\fft\\cfftf.c\" />\n    <ClCompile Include=\"..\\fft\\cffti.c\" />\n    <ClCompile Include=\"..\\fft\\roll2.c\" />\n    <ClCompile Include=\"..\\gist\\cgm.c\" />\n    <ClCompile Include=\"..\\gist\\clip.c\" />\n    <ClCompile Include=\"..\\gist\\draw.c\">\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">NO_EXP10;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">NO_EXP10;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">NO_EXP10;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">NO_EXP10;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n    </ClCompile>\n    <ClCompile Include=\"..\\gist\\draw0.c\" />\n    <ClCompile Include=\"..\\gist\\engine.c\" />\n    <ClCompile Include=\"..\\gist\\gcntr.c\" />\n    <ClCompile Include=\"..\\gist\\gist.c\" />\n    <ClCompile Include=\"..\\gist\\gread.c\" />\n    <ClCompile Include=\"..\\gist\\gtext.c\" />\n    <ClCompile Include=\"..\\gist\\hlevel.c\" />\n    <ClCompile Include=\"..\\gist\\ps.c\" />\n    <ClCompile Include=\"..\\gist\\tick.c\">\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">NO_EXP10;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">NO_EXP10;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">NO_EXP10;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">NO_EXP10;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n    </ClCompile>\n    <ClCompile Include=\"..\\gist\\tick60.c\" />\n    <ClCompile Include=\"..\\gist\\xbasic.c\" />\n    <ClCompile Include=\"..\\gist\\xfancy.c\">\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">NO_EXP10;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">NO_EXP10;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">NO_EXP10;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n      <PreprocessorDefinitions Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">NO_EXP10;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n    </ClCompile>\n    <ClCompile Include=\"..\\hex\\hex.c\" />\n    <ClCompile Include=\"..\\hex\\hex24.c\" />\n    <ClCompile Include=\"..\\hex\\hex5.c\" />\n    <ClCompile Include=\"..\\hex\\hydram.c\" />\n    <ClCompile Include=\"..\\hex\\regul.c\" />\n    <ClCompile Include=\"..\\hex\\store.c\" />\n    <ClCompile Include=\"..\\hex\\tools.c\" />\n    <ClCompile Include=\"..\\hex\\yhex.c\" />\n    <ClCompile Include=\"..\\matrix\\cblasy.c\" />\n    <ClCompile Include=\"..\\matrix\\cxerbla.c\" />\n    <ClCompile Include=\"..\\matrix\\dbdsqr.c\" />\n    <ClCompile Include=\"..\\matrix\\dgecon.c\" />\n    <ClCompile Include=\"..\\matrix\\dgels.c\" />\n    <ClCompile Include=\"..\\matrix\\dgelss.c\" />\n    <ClCompile Include=\"..\\matrix\\dgesv.c\" />\n    <ClCompile Include=\"..\\matrix\\dgesv2.c\" />\n    <ClCompile Include=\"..\\matrix\\dgesvd.c\" />\n    <ClCompile Include=\"..\\matrix\\dgtsv.c\" />\n    <ClCompile Include=\"..\\matrix\\dgyor.c\" />\n    <ClCompile Include=\"..\\matrix\\dlamc3.c\" />\n    <ClCompile Include=\"..\\matrix\\dlasr.c\" />\n    <ClCompile Include=\"..\\play\\all\\alarms.c\" />\n    <ClCompile Include=\"..\\play\\all\\bitlrot.c\" />\n    <ClCompile Include=\"..\\play\\all\\bitmrot.c\" />\n    <ClCompile Include=\"..\\play\\all\\bitrev.c\" />\n    <ClCompile Include=\"..\\play\\all\\hash.c\" />\n    <ClCompile Include=\"..\\play\\all\\hash0.c\" />\n    <ClCompile Include=\"..\\play\\all\\hashctx.c\" />\n    <ClCompile Include=\"..\\play\\all\\hashid.c\" />\n    <ClCompile Include=\"..\\play\\all\\mm.c\" />\n    <ClCompile Include=\"..\\play\\all\\mminit.c\" />\n    <ClCompile Include=\"..\\play\\all\\p595.c\" />\n    <ClCompile Include=\"..\\play\\all\\pmemcpy.c\" />\n    <ClCompile Include=\"..\\play\\all\\pstrcpy.c\" />\n    <ClCompile Include=\"..\\play\\all\\pstrncat.c\" />\n    <ClCompile Include=\"..\\play\\win\\clips.c\" />\n    <ClCompile Include=\"..\\play\\win\\conterm.c\" />\n    <ClCompile Include=\"..\\play\\win\\cursors.c\" />\n    <ClCompile Include=\"..\\play\\win\\dir.c\" />\n    <ClCompile Include=\"..\\play\\win\\ellipse.c\" />\n    <ClCompile Include=\"..\\play\\win\\feep.c\" />\n    <ClCompile Include=\"..\\play\\win\\files.c\" />\n    <ClCompile Include=\"..\\play\\win\\getdc.c\" />\n    <ClCompile Include=\"..\\play\\win\\handler.c\" />\n    <ClCompile Include=\"..\\play\\win\\mfcapp.cpp\" />\n    <ClCompile Include=\"..\\play\\win\\mfcmain.cpp\" />\n    <ClCompile Include=\"..\\play\\win\\mfcterm.cpp\" />\n    <ClCompile Include=\"..\\play\\win\\pals.c\" />\n    <ClCompile Include=\"..\\play\\win\\pathnm.c\" />\n    <ClCompile Include=\"..\\play\\win\\pcell.c\" />\n    <ClCompile Include=\"..\\play\\win\\pfill.c\" />\n    <ClCompile Include=\"..\\play\\win\\plines.c\" />\n    <ClCompile Include=\"..\\play\\win\\points.c\" />\n    <ClCompile Include=\"..\\play\\win\\prect.c\" />\n    <ClCompile Include=\"..\\play\\win\\pscr.c\" />\n    <ClCompile Include=\"..\\play\\win\\ptext.c\" />\n    <ClCompile Include=\"..\\play\\win\\pwin.c\" />\n    <ClCompile Include=\"..\\play\\win\\sigseh.c\" />\n    <ClCompile Include=\"..\\play\\win\\timeu.c\" />\n    <ClCompile Include=\"..\\play\\win\\timew.c\" />\n    <ClCompile Include=\"..\\play\\win\\usernm.c\" />\n    <ClCompile Include=\"..\\play\\win\\wpoll.c\" />\n    <ClCompile Include=\"..\\play\\win\\wstdio.c\" />\n    <ClCompile Include=\"..\\regexp\\yfnmatch.c\" />\n    <ClCompile Include=\"..\\regexp\\yregexp.c\" />\n    <ClCompile Include=\"..\\yorick\\array.c\" />\n    <ClCompile Include=\"..\\yorick\\ascio.c\" />\n    <ClCompile Include=\"..\\yorick\\autold.c\" />\n    <ClCompile Include=\"..\\yorick\\bcast.c\" />\n    <ClCompile Include=\"..\\yorick\\binio.c\" />\n    <ClCompile Include=\"..\\yorick\\binobj.c\" />\n    <ClCompile Include=\"..\\yorick\\binpdb.c\" />\n    <ClCompile Include=\"..\\yorick\\binstd.c\" />\n    <ClCompile Include=\"..\\yorick\\cache.c\" />\n    <ClCompile Include=\"..\\yorick\\clog.c\" />\n    <ClCompile Include=\"..\\yorick\\convrt.c\" />\n    <ClCompile Include=\"..\\yorick\\debug.c\" />\n    <ClCompile Include=\"..\\yorick\\defmem.c\" />\n    <ClCompile Include=\"..\\yorick\\dlsym.c\" />\n    <ClCompile Include=\"..\\yorick\\fnctn.c\" />\n    <ClCompile Include=\"..\\yorick\\graph.c\" />\n    <ClCompile Include=\"..\\yorick\\graph0.c\" />\n    <ClCompile Include=\"..\\yorick\\list.c\" />\n    <ClCompile Include=\"..\\yorick\\nonc.c\" />\n    <ClCompile Include=\"..\\yorick\\ops.c\" />\n    <ClCompile Include=\"..\\yorick\\ops0.c\" />\n    <ClCompile Include=\"..\\yorick\\ops1.c\" />\n    <ClCompile Include=\"..\\yorick\\ops2.c\" />\n    <ClCompile Include=\"..\\yorick\\ops3.c\" />\n    <ClCompile Include=\"..\\yorick\\opsv.c\" />\n    <ClCompile Include=\"..\\yorick\\parse.c\" />\n    <ClCompile Include=\"..\\yorick\\pathfun.c\" />\n    <ClCompile Include=\"..\\yorick\\range.c\" />\n    <ClCompile Include=\"..\\yorick\\std0.c\" />\n    <ClCompile Include=\"..\\yorick\\std1.c\" />\n    <ClCompile Include=\"..\\yorick\\std2.c\" />\n    <ClCompile Include=\"..\\yorick\\style.c\" />\n    <ClCompile Include=\"..\\yorick\\task.c\" />\n    <ClCompile Include=\"..\\yorick\\ydata.c\" />\n    <ClCompile Include=\"..\\yorick\\yhash.c\" />\n    <ClCompile Include=\"..\\yorick\\yinput.c\" />\n    <ClCompile Include=\"..\\yorick\\yio.c\" />\n    <ClCompile Include=\"..\\yorick\\yorick.c\" />\n    <ClCompile Include=\"..\\yorick\\yrdwr.c\" />\n    <ClCompile Include=\"..\\yorick\\ystr.c\" />\n    <ClCompile Include=\"yinit.c\" />\n    <ClCompile Include=\"ywrap.c\" />\n  </ItemGroup>\n  <ItemGroup>\n    <ResourceCompile Include=\"yorick.rc\">\n      <Culture Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">0x0409</Culture>\n      <Culture Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">0x0409</Culture>\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">..\\play\\win;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">..\\play\\win;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n      <Culture Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">0x0409</Culture>\n      <Culture Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">0x0409</Culture>\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">..\\play\\win;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n      <AdditionalIncludeDirectories Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">..\\play\\win;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n    </ResourceCompile>\n  </ItemGroup>\n  <ItemGroup>\n    <ClInclude Include=\"..\\drat\\bound.h\" />\n    <ClInclude Include=\"..\\drat\\drat.h\" />\n    <ClInclude Include=\"..\\drat\\track.h\" />\n    <ClInclude Include=\"..\\drat\\trans.h\" />\n    <ClInclude Include=\"..\\gist\\cgm.h\" />\n    <ClInclude Include=\"..\\gist\\clip.h\" />\n    <ClInclude Include=\"..\\gist\\draw.h\" />\n    <ClInclude Include=\"..\\gist\\engine.h\" />\n    <ClInclude Include=\"..\\gist\\gist.h\" />\n    <ClInclude Include=\"..\\gist\\gtext.h\" />\n    <ClInclude Include=\"..\\gist\\hlevel.h\" />\n    <ClInclude Include=\"..\\gist\\ps.h\" />\n    <ClInclude Include=\"..\\gist\\xbasic.h\" />\n    <ClInclude Include=\"..\\gist\\xfancy.h\" />\n    <ClInclude Include=\"..\\hex\\hex.h\" />\n    <ClInclude Include=\"..\\hex\\hydram.h\" />\n    <ClInclude Include=\"..\\hex\\regul.h\" />\n    <ClInclude Include=\"..\\hex\\tools.h\" />\n    <ClInclude Include=\"..\\matrix\\cblasy.h\" />\n    <ClInclude Include=\"..\\matrix\\dg.h\" />\n    <ClInclude Include=\"..\\play\\phash.h\" />\n    <ClInclude Include=\"..\\play\\play.h\" />\n    <ClInclude Include=\"..\\play\\plugin.h\" />\n    <ClInclude Include=\"..\\play\\pmin.h\" />\n    <ClInclude Include=\"..\\play\\pstdio.h\" />\n    <ClInclude Include=\"..\\play\\pstdlib.h\" />\n    <ClInclude Include=\"..\\play\\win\\config.h\" />\n    <ClInclude Include=\"..\\play\\win\\mfcapp.h\" />\n    <ClInclude Include=\"..\\play\\win\\mfcres.h\" />\n    <ClInclude Include=\"..\\play\\win\\mfcterm.h\" />\n    <ClInclude Include=\"..\\play\\win\\playw.h\" />\n    <ClInclude Include=\"..\\play\\yversion.h\" />\n    <ClInclude Include=\"..\\regexp\\yfnmatch.h\" />\n    <ClInclude Include=\"..\\regexp\\yregexp.h\" />\n    <ClInclude Include=\"..\\yorick\\bcast.h\" />\n    <CustomBuild Include=\"..\\yorick\\binio.h\">\n      <Command Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">$(OutDir)numfmt numfmt.h \nmove/y numfmt.h %(RootDir)%(Directory)\\prmtyp.h </Command>\n      <Command Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">$(OutDir)numfmt numfmt.h \nmove/y numfmt.h %(RootDir)%(Directory)\\prmtyp.h </Command>\n      <Outputs Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">$(InputDir)prmtyp.h;%(Outputs)</Outputs>\n      <Outputs Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">$(InputDir)prmtyp.h;%(Outputs)</Outputs>\n      <Command Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">$(OutDir)numfmt numfmt.h \nmove/y numfmt.h %(RootDir)%(Directory)\\prmtyp.h </Command>\n      <Command Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">$(OutDir)numfmt numfmt.h \nmove/y numfmt.h %(RootDir)%(Directory)\\prmtyp.h </Command>\n      <Outputs Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">$(InputDir)prmtyp.h;%(Outputs)</Outputs>\n      <Outputs Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">$(InputDir)prmtyp.h;%(Outputs)</Outputs>\n    </CustomBuild>\n    <ClInclude Include=\"..\\yorick\\defmem.h\" />\n    <ClInclude Include=\"..\\yorick\\hash.h\" />\n    <ClInclude Include=\"..\\yorick\\parse.h\" />\n    <ClInclude Include=\"..\\yorick\\prmtyp.h\" />\n    <ClInclude Include=\"..\\yorick\\yasync.h\" />\n    <ClInclude Include=\"..\\yorick\\ydata.h\" />\n    <ClInclude Include=\"..\\yorick\\yio.h\" />\n  </ItemGroup>\n  <ItemGroup>\n    <Image Include=\"yorick.ico\" />\n  </ItemGroup>\n  <ItemGroup>\n    <CustomBuild Include=\"makeinit.bat\">\n      <Command Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">$(ProjectDir)makeinit.bat $(OutDir)</Command>\n      <Command Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">$(ProjectDir)makeinit.bat $(OutDir)</Command>\n      <Outputs Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">$(ProjectDir)yinit.c;$(ProjectDir)ywrap.c;%(Outputs)</Outputs>\n      <Outputs Condition=\"'$(Configuration)|$(Platform)'=='Release|x64'\">$(ProjectDir)yinit.c;$(ProjectDir)ywrap.c;%(Outputs)</Outputs>\n      <Command Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">$(ProjectDir)makeinit.bat $(OutDir)</Command>\n      <Command Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">$(ProjectDir)makeinit.bat $(OutDir)</Command>\n      <Outputs Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">$(ProjectDir)yinit.c;$(ProjectDir)ywrap.c;%(Outputs)</Outputs>\n      <Outputs Condition=\"'$(Configuration)|$(Platform)'=='Debug|x64'\">$(ProjectDir)yinit.c;$(ProjectDir)ywrap.c;%(Outputs)</Outputs>\n    </CustomBuild>\n    <CustomBuild Include=\"README\" />\n  </ItemGroup>\n  <ItemGroup>\n    <ProjectReference Include=\"codger.vcxproj\">\n      <Project>{cb340131-1d09-45eb-8a1c-f2803f5309c0}</Project>\n      <ReferenceOutputAssembly>false</ReferenceOutputAssembly>\n    </ProjectReference>\n    <ProjectReference Include=\"numfmt.vcxproj\">\n      <Project>{16ed75f2-791b-490e-9082-0e8d2ffb6c16}</Project>\n      <ReferenceOutputAssembly>false</ReferenceOutputAssembly>\n    </ProjectReference>\n  </ItemGroup>\n  <Import Project=\"$(VCTargetsPath)\\Microsoft.Cpp.targets\" />\n  <ImportGroup Label=\"ExtensionTargets\">\n  </ImportGroup>\n</Project>"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/icons/yorick.ico",
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/icons/yicon32.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/icons/yicon48.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/icons/yicon16.png",
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/icons/yicon48.png",
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/icons/yicon32.png",
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/icons/yicon16.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/icons/yicon48.gif",
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/.git/objects/pack/pack-97377abdb12f5e0e70a3ae5ea38f284d16ce66a7.pack",
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/.git/objects/pack/pack-97377abdb12f5e0e70a3ae5ea38f284d16ce66a7.idx",
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/win/ylogo32.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/win/yorick.ico",
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/win/ylogo16.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/win/ylogo48.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/i/fits.i",
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/doc/refs.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/doc/yorick.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/doc/html/images/a_begin_na.gif",
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/doc/html/images/a_index_na.gif",
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/doc/html/images/a_end_na.gif",
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/doc/html/images/a_left_na.gif",
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/doc/html/images/a_right.gif",
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/doc/html/images/a_left.gif",
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/doc/html/images/a_tableofcon_na.gif",
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/doc/html/images/skull_up.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/doc/html/images/a_begin.gif",
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/doc/html/images/a_end.gif",
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/doc/html/images/a_leftdouble_na.gif",
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/doc/html/images/a_help.gif",
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/doc/html/images/a_up_na.gif",
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/doc/html/images/triangle3.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/doc/html/images/a_top.gif",
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/doc/html/images/skull_down.jpeg",
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/doc/html/images/a_rightdouble.gif",
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/doc/html/images/a_rightdouble_na.gif",
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/doc/html/images/a_tableofcon.gif",
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/doc/html/images/a_index.gif",
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/doc/html/images/a_right_na.gif",
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/doc/html/images/triangle2inv.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/doc/html/images/star-bullet-s1.png",
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/doc/html/images/triangle2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/doc/html/images/a_help_na.gif",
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/doc/html/images/a_up.gif",
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/doc/html/images/a_leftdouble.gif",
        "/tmp/vanessa/spack-stage/spack-stage-yorick-master-wvevjqokej4grkfjqyznsotcxpitbl6i/spack-src/doc/html/images/a_top_na.gif"
    ],
    "total_files": 590
}