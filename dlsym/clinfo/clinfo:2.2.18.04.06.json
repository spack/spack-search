{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-clinfo-2.2.18.04.06-6ifkvqlahzueis63k6pf3m6j7n6lbhdc/spack-src/src/clinfo.c": "/* Collect all available information on all available devices\n * on all available OpenCL platforms present in the system\n */\n\n#include <time.h>\n#include <string.h>\n\n/* We will want to check for symbols in the OpenCL library.\n * On Windows, we must get the module handle for it, on Unix-like\n * systems we can just use RTLD_DEFAULT\n */\n#ifdef _MSC_VER\n# include <windows.h>\n# define dlsym GetProcAddress\n# define DL_MODULE GetModuleHandle(\"OpenCL\")\n#else\n# include <dlfcn.h>\n# define DL_MODULE ((void*)0) /* This would be RTLD_DEFAULT */\n#endif\n\n/* Load STDC format macros (PRI*), or define them\n * for those crappy, non-standard compilers\n */\n#include \"fmtmacros.h\"\n\n// More support for the horrible MS C compiler\n#ifdef _MSC_VER\n#include \"ms_support.h\"\n#endif\n\n#include \"error.h\"\n#include \"memory.h\"\n#include \"strbuf.h\"\n\n#include \"ext.h\"\n#include \"ctx_prop.h\"\n#include \"info_loc.h\"\n#include \"info_ret.h\"\n#include \"opt_out.h\"\n\n#define ARRAY_SIZE(ar) (sizeof(ar)/sizeof(*ar))\n\n#ifndef UNUSED\n#define UNUSED(x) x __attribute__((unused))\n#endif\n\nstruct platform_data {\n\tchar *pname; /* CL_PLATFORM_NAME */\n\tchar *sname; /* CL_PLATFORM_ICD_SUFFIX_KHR or surrogate */\n\tcl_uint ndevs; /* number of devices */\n\tcl_bool has_amd_offline; /* has cl_amd_offline_devices extension */\n};\n\nstruct platform_info_checks {\n\tcl_uint plat_version;\n\tcl_bool has_khr_icd;\n\tcl_bool has_amd_object_metadata;\n};\n\nstruct platform_list {\n\t/* Number of platforms in the system */\n\tcl_uint num_platforms;\n\t/* Total number of devices across all platforms */\n\tcl_uint ndevs_total;\n\t/* Number of devices allocated in all_devs array */\n\tcl_uint alloc_devs;\n\t/* Highest OpenCL version supported by any platform.\n\t * If the OpenCL library / ICD loader only supports\n\t * a lower version, problems may arise (such as\n\t * API calls causing segfaults or any other unexpected\n\t * behavior\n\t */\n\tcl_uint max_plat_version;\n\t/* Largest number of devices on any platform */\n\tcl_uint max_devs;\n\t/* Length of the longest platform sname */\n\tcl_int max_sname_len;\n\t/* Array of platform IDs */\n\tcl_platform_id *platform;\n\t/* Array of device IDs (across all platforms) */\n\tcl_device_id *all_devs;\n\t/* Array of offsets in all_devs where the devices\n\t * of each platform begin */\n\tcl_uint *dev_offset;\n\t/* Array of clinfo-specific platform data */\n\tstruct platform_data *pdata;\n\t/* Arrau of clinfo-specifici platform checks */\n\tstruct platform_info_checks *platform_checks;\n};\n\nvoid\ninit_plist(struct platform_list *plist)\n{\n\tplist->num_platforms = 0;\n\tplist->ndevs_total = 0;\n\tplist->alloc_devs = 0;\n\tplist->max_plat_version = 0;\n\tplist->platform = NULL;\n\tplist->all_devs = NULL;\n\tplist->dev_offset = NULL;\n\tplist->pdata = NULL;\n\tplist->platform_checks = NULL;\n}\n\nvoid plist_devs_reserve(struct platform_list *plist, cl_uint amount)\n{\n\tif (amount > plist->alloc_devs) {\n\t\tREALLOC(plist->all_devs, amount, \"all devices\");\n\t\tplist->alloc_devs = amount;\n\t}\n}\n\n\nvoid\nalloc_plist(struct platform_list *plist)\n{\n\tALLOC(plist->platform, plist->num_platforms, \"platform IDs\");\n\tALLOC(plist->dev_offset, plist->num_platforms, \"platform device list offset\");\n\t/* The actual sizing for this will change as we gather platform info,\n\t * but assume at least one device per platform\n\t */\n\tplist_devs_reserve(plist, plist->num_platforms);\n\tALLOC(plist->pdata, plist->num_platforms, \"platform data\");\n\tALLOC(plist->platform_checks, plist->num_platforms, \"platform checks data\");\n}\nvoid\nfree_plist(struct platform_list *plist)\n{\n\tfree(plist->platform);\n\tfree(plist->all_devs);\n\tfree(plist->dev_offset);\n\tfree(plist->pdata);\n\tfree(plist->platform_checks);\n\tinit_plist(plist);\n}\n\nconst cl_device_id *\nget_platform_devs(const struct platform_list *plist, cl_uint p)\n{\n\treturn plist->all_devs + plist->dev_offset[p];\n}\n\ncl_device_id\nget_platform_dev(const struct platform_list *plist, cl_uint p, cl_uint d)\n{\n\treturn get_platform_devs(plist, p)[d];\n}\n\n/* Data for the OpenCL library / ICD loader */\nstruct icdl_data {\n\t/* auto-detected OpenCL version support for the ICD loader */\n\tcl_uint detected_version;\n\t/* OpenCL version support declared by the ICD loader */\n\tcl_uint reported_version;\n};\n\n/* line prefix, used to identify the platform/device for each\n * device property in RAW output mode */\nchar *line_pfx;\nint line_pfx_len;\n\n#define CHECK_SIZE(ret, loc, val, cmd, ...) do { \\\n\t/* check if the issue is with param size */ \\\n\tif (output->check_size && ret->err == CL_INVALID_VALUE) { \\\n\t\tsize_t _actual_sz; \\\n\t\tif (cmd(__VA_ARGS__, 0, NULL, &_actual_sz) == CL_SUCCESS) { \\\n\t\t\tREPORT_SIZE_MISMATCH(&(ret->err_str), loc, _actual_sz, sizeof(val)); \\\n\t\t} \\\n\t} \\\n} while (0)\n\nstatic const char unk[] = \"Unknown\";\nstatic const char none[] = \"None\";\nstatic const char none_raw[] = \"CL_NONE\";\nstatic const char na[] = \"n/a\"; // not available\nstatic const char na_wrap[] = \"(n/a)\"; // not available\nstatic const char core[] = \"core\";\n\nstatic const char bytes_str[] = \" bytes\";\nstatic const char pixels_str[] = \" pixels\";\nstatic const char images_str[] = \" images\";\n\nstatic const char* bool_str[] = { \"No\", \"Yes\" };\nstatic const char* bool_raw_str[] = { \"CL_FALSE\", \"CL_TRUE\" };\n\nstatic const char* endian_str[] = { \"Big-Endian\", \"Little-Endian\" };\n\nstatic const cl_device_type devtype[] = { 0,\n\tCL_DEVICE_TYPE_DEFAULT, CL_DEVICE_TYPE_CPU, CL_DEVICE_TYPE_GPU,\n\tCL_DEVICE_TYPE_ACCELERATOR, CL_DEVICE_TYPE_CUSTOM, CL_DEVICE_TYPE_ALL };\n\nconst size_t devtype_count = ARRAY_SIZE(devtype);\n/* number of actual device types, without ALL */\nconst size_t actual_devtype_count = ARRAY_SIZE(devtype) - 1;\n\nstatic const char* device_type_str[] = { unk, \"Default\", \"CPU\", \"GPU\", \"Accelerator\", \"Custom\", \"All\" };\nstatic const char* device_type_raw_str[] = { unk,\n\t\"CL_DEVICE_TYPE_DEFAULT\", \"CL_DEVICE_TYPE_CPU\", \"CL_DEVICE_TYPE_GPU\",\n\t\"CL_DEVICE_TYPE_ACCELERATOR\", \"CL_DEVICE_TYPE_CUSTOM\", \"CL_DEVICE_TYPE_ALL\"\n};\n\nstatic const char* partition_type_str[] = {\n\tnone, \"equally\", \"by counts\", \"by affinity domain\", \"by names (Intel)\"\n};\nstatic const char* partition_type_raw_str[] = {\n\tnone_raw,\n\t\"CL_DEVICE_PARTITION_EQUALLY_EXT\",\n\t\"CL_DEVICE_PARTITION_BY_COUNTS_EXT\",\n\t\"CL_DEVICE_PARTITION_BY_AFFINITY_DOMAIN_EXT\",\n\t\"CL_DEVICE_PARTITION_BY_NAMES_INTEL_EXT\"\n};\n\nstatic const char numa[] = \"NUMA\";\nstatic const char l1cache[] = \"L1 cache\";\nstatic const char l2cache[] = \"L2 cache\";\nstatic const char l3cache[] = \"L3 cache\";\nstatic const char l4cache[] = \"L4 cache\";\n\nstatic const char* affinity_domain_str[] = {\n\tnuma, l4cache, l3cache, l2cache, l1cache, \"next partitionable\"\n};\n\nstatic const char* affinity_domain_ext_str[] = {\n\tnuma, l4cache, l3cache, l2cache, l1cache, \"next fissionable\"\n};\n\nstatic const char* affinity_domain_raw_str[] = {\n\t\"CL_DEVICE_AFFINITY_DOMAIN_NUMA\",\n\t\"CL_DEVICE_AFFINITY_DOMAIN_L4_CACHE\",\n\t\"CL_DEVICE_AFFINITY_DOMAIN_L3_CACHE\",\n\t\"CL_DEVICE_AFFINITY_DOMAIN_L2_CACHE\",\n\t\"CL_DEVICE_AFFINITY_DOMAIN_L1_CACHE\",\n\t\"CL_DEVICE_AFFINITY_DOMAIN_NEXT_PARTITIONABLE\"\n};\n\nstatic const char* affinity_domain_raw_ext_str[] = {\n\t\"CL_AFFINITY_DOMAIN_NUMA_EXT\",\n\t\"CL_AFFINITY_DOMAIN_L4_CACHE_EXT\",\n\t\"CL_AFFINITY_DOMAIN_L3_CACHE_EXT\",\n\t\"CL_AFFINITY_DOMAIN_L2_CACHE_EXT\",\n\t\"CL_AFFINITY_DOMAIN_L1_CACHE_EXT\",\n\t\"CL_AFFINITY_DOMAIN_NEXT_FISSIONABLE_EXT\"\n};\n\nconst size_t affinity_domain_count = ARRAY_SIZE(affinity_domain_str);\n\nstatic const char *terminate_capability_str[] = {\n\t\"Context\"\n};\n\nstatic const char *terminate_capability_raw_str[] = {\n\t\"CL_DEVICE_TERMINATE_CAPABILITY_CONTEXT_KHR\"\n};\n\nconst size_t terminate_capability_count = ARRAY_SIZE(terminate_capability_str);\n\nstatic const char* fp_conf_str[] = {\n\t\"Denormals\", \"Infinity and NANs\", \"Round to nearest\", \"Round to zero\",\n\t\"Round to infinity\", \"IEEE754-2008 fused multiply-add\",\n\t\"Support is emulated in software\",\n\t\"Correctly-rounded divide and sqrt operations\"\n};\n\nstatic const char* fp_conf_raw_str[] = {\n\t\"CL_FP_DENORM\",\n\t\"CL_FP_INF_NAN\",\n\t\"CL_FP_ROUND_TO_NEAREST\",\n\t\"CL_FP_ROUND_TO_ZERO\",\n\t\"CL_FP_ROUND_TO_INF\",\n\t\"CL_FP_FMA\",\n\t\"CL_FP_SOFT_FLOAT\",\n\t\"CL_FP_CORRECTLY_ROUNDED_DIVIDE_SQRT\"\n};\n\nconst size_t fp_conf_count = ARRAY_SIZE(fp_conf_str);\n\nstatic const char* svm_cap_str[] = {\n\t\"Coarse-grained buffer sharing\",\n\t\"Fine-grained buffer sharing\",\n\t\"Fine-grained system sharing\",\n\t\"Atomics\"\n};\n\nstatic const char* svm_cap_raw_str[] = {\n\t\"CL_DEVICE_SVM_COARSE_GRAIN_BUFFER\",\n\t\"CL_DEVICE_SVM_FINE_GRAIN_BUFFER\",\n\t\"CL_DEVICE_SVM_FINE_GRAIN_SYSTEM\",\n\t\"CL_DEVICE_SVM_ATOMICS\",\n};\n\nconst size_t svm_cap_count = ARRAY_SIZE(svm_cap_str);\n\n/* SI suffixes for memory sizes. Note that in OpenCL most of them are\n * passed via a cl_ulong, which at most can mode 16 EiB, but hey,\n * let's be forward-thinking ;-)\n */\nstatic const char* memsfx[] = {\n\t\"B\", \"KiB\", \"MiB\", \"GiB\", \"TiB\", \"PiB\", \"EiB\", \"ZiB\", \"YiB\"\n};\n\nconst size_t memsfx_end = ARRAY_SIZE(memsfx) + 1;\n\nstatic const char* lmem_type_str[] = { none, \"Local\", \"Global\" };\nstatic const char* lmem_type_raw_str[] = { none_raw, \"CL_LOCAL\", \"CL_GLOBAL\" };\nstatic const char* cache_type_str[] = { none, \"Read-Only\", \"Read/Write\" };\nstatic const char* cache_type_raw_str[] = { none_raw, \"CL_READ_ONLY_CACHE\", \"CL_READ_WRITE_CACHE\" };\n\nstatic const char* queue_prop_str[] = { \"Out-of-order execution\", \"Profiling\" };\nstatic const char* queue_prop_raw_str[] = {\n\t\"CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE\",\n\t\"CL_QUEUE_PROFILING_ENABLE\"\n};\n\nconst size_t queue_prop_count = ARRAY_SIZE(queue_prop_str);\n\nstatic const char* execap_str[] = { \"Run OpenCL kernels\", \"Run native kernels\" };\nstatic const char* execap_raw_str[] = {\n\t\"CL_EXEC_KERNEL\",\n\t\"CL_EXEC_NATIVE_KERNEL\"\n};\n\nconst size_t execap_count = ARRAY_SIZE(execap_str);\n\nstatic const char* sources[] = {\n\t\"#define GWO(type) global type* restrict\\n\",\n\t\"#define GRO(type) global const type* restrict\\n\",\n\t\"#define BODY int i = get_global_id(0); out[i] = in1[i] + in2[i]\\n\",\n\t\"#define _KRN(T, N) void kernel sum##N(GWO(T##N) out, GRO(T##N) in1, GRO(T##N) in2) { BODY; }\\n\",\n\t\"#define KRN(N) _KRN(float, N)\\n\",\n\t\"KRN()\\n/* KRN(2)\\nKRN(4)\\nKRN(8)\\nKRN(16) */\\n\",\n};\n\nconst char *num_devs_header(const struct opt_out *output, cl_bool these_are_offline)\n{\n\treturn output->mode == CLINFO_HUMAN ?\n\t\t(these_are_offline ? \"Number of offine devices (AMD)\" : \"Number of devices\") :\n\t\t(these_are_offline ? \"#OFFDEVICES\" : \"#DEVICES\");\n}\n\nconst char *not_specified(const struct opt_out *output)\n{\n\treturn output->mode == CLINFO_HUMAN ?\n\t\tna_wrap : \"\";\n}\n\nconst char *no_plat(const struct opt_out *output)\n{\n\treturn output->mode == CLINFO_HUMAN ?\n\t\t\"No platform\" :\n\t\t\"CL_INVALID_PLATFORM\";\n}\n\nconst char *invalid_dev_type(const struct opt_out *output)\n{\n\treturn output->mode == CLINFO_HUMAN ?\n\t\t\"Invalid device type for platform\" :\n\t\t\"CL_INVALID_DEVICE_TYPE\";\n}\n\nconst char *invalid_dev_value(const struct opt_out *output)\n{\n\treturn output->mode == CLINFO_HUMAN ?\n\t\t\"Invalid device type value for platform\" :\n\t\t\"CL_INVALID_VALUE\";\n}\n\nconst char *no_dev_found(const struct opt_out *output)\n{\n\treturn output->mode == CLINFO_HUMAN ?\n\t\t\"No devices found in platform\" :\n\t\t\"CL_DEVICE_NOT_FOUND\";\n}\n\nconst char *no_dev_avail(const struct opt_out *output)\n{\n\treturn output->mode == CLINFO_HUMAN ?\n\t\t\"No devices available in platform\" :\n\t\t\"CL_DEVICE_NOT_AVAILABLE\";\n}\n\n/* OpenCL context interop names */\n\ntypedef struct cl_interop_name {\n\tcl_uint from;\n\tcl_uint to;\n\t/* 5 because that's the largest we know of,\n\t * 2 because it's HUMAN, RAW */\n\tconst char *value[5][2];\n} cl_interop_name;\n\nstatic const cl_interop_name cl_interop_names[] = {\n\t{ /* cl_khr_gl_sharing */\n\t\t CL_GL_CONTEXT_KHR,\n\t\t CL_CGL_SHAREGROUP_KHR,\n\t\t {\n\t\t\t{ \"GL\", \"CL_GL_CONTEXT_KHR\" },\n\t\t\t{ \"EGL\", \"CL_EGL_DISPALY_KHR\" },\n\t\t\t{ \"GLX\", \"CL_GLX_DISPLAY_KHR\" },\n\t\t\t{ \"WGL\", \"CL_WGL_HDC_KHR\" },\n\t\t\t{ \"CGL\", \"CL_CGL_SHAREGROUP_KHR\" }\n\t\t}\n\t},\n\t{ /* cl_khr_dx9_media_sharing */\n\t\tCL_CONTEXT_ADAPTER_D3D9_KHR,\n\t\tCL_CONTEXT_ADAPTER_DXVA_KHR,\n\t\t{\n\t\t\t{ \"D3D9 (KHR)\", \"CL_CONTEXT_ADAPTER_D3D9_KHR\" },\n\t\t\t{ \"D3D9Ex (KHR)\", \"CL_CONTEXT_ADAPTER_D3D9EX_KHR\" },\n\t\t\t{ \"DXVA (KHR)\", \"CL_CONTEXT_ADAPTER_DXVA_KHR\" }\n\t\t}\n\t},\n\t{ /* cl_khr_d3d10_sharing */\n\t\tCL_CONTEXT_D3D10_DEVICE_KHR,\n\t\tCL_CONTEXT_D3D10_DEVICE_KHR,\n\t\t{\n\t\t\t{ \"D3D10\", \"CL_CONTEXT_D3D10_DEVICE_KHR\" }\n\t\t}\n\t},\n\t{ /* cl_khr_d3d11_sharing */\n\t\tCL_CONTEXT_D3D11_DEVICE_KHR,\n\t\tCL_CONTEXT_D3D11_DEVICE_KHR,\n\t\t{\n\t\t\t{ \"D3D11\", \"CL_CONTEXT_D3D11_DEVICE_KHR\" }\n\t\t}\n\t},\n\t{ /* cl_intel_dx9_media_sharing */\n\t\tCL_CONTEXT_D3D9_DEVICE_INTEL,\n\t\tCL_CONTEXT_DXVA_DEVICE_INTEL,\n\t\t{\n\t\t\t{ \"D3D9 (INTEL)\", \"CL_CONTEXT_D3D9_DEVICE_INTEL\" },\n\t\t\t{ \"D3D9Ex (INTEL)\", \"CL_CONTEXT_D3D9EX_DEVICE_INTEL\" },\n\t\t\t{ \"DXVA (INTEL)\", \"CL_CONTEXT_DXVA_DEVICE_INTEL\" }\n\t\t}\n\t},\n\t{ /* cl_intel_va_api_media_sharing */\n\t\tCL_CONTEXT_VA_API_DISPLAY_INTEL,\n\t\tCL_CONTEXT_VA_API_DISPLAY_INTEL,\n\t\t{\n\t\t\t{ \"VA-API\", \"CL_CONTEXT_VA_API_DISPLAY_INTEL\" }\n\t\t}\n\t}\n};\n\nconst size_t num_known_interops = ARRAY_SIZE(cl_interop_names);\n\n\n#define INDENT \"  \"\n#define I0_STR \"%-48s  \"\n#define I1_STR \"  %-46s  \"\n#define I2_STR \"    %-44s  \"\n\nstatic const char empty_str[] = \"\";\nstatic const char spc_str[] = \" \";\nstatic const char times_str[] = \"x\";\nstatic const char comma_str[] = \", \";\nstatic const char vbar_str[] = \" | \";\n\nconst char *cur_sfx = empty_str;\n\n/* parse a CL_DEVICE_VERSION or CL_PLATFORM_VERSION info to determine the OpenCL version.\n * Returns an unsigned integer in the form major*10 + minor\n */\ncl_uint\ngetOpenCLVersion(const char *version)\n{\n\tcl_uint ret = 10;\n\tlong parse = 0;\n\tconst char *from = version;\n\tchar *next = NULL;\n\tparse = strtol(from, &next, 10);\n\n\tif (next != from) {\n\t\tret = parse*10;\n\t\t// skip the dot TODO should we actually check for the dot?\n\t\tfrom = ++next;\n\t\tparse = strtol(from, &next, 10);\n\t\tif (next != from)\n\t\t\tret += parse;\n\t}\n\treturn ret;\n}\n\n#define SPLIT_CL_VERSION(ver) ((ver)/10), ((ver)%10)\n\n/* print strbuf, prefixed by pname, skipping leading whitespace if skip is nonzero,\n * affixing cur_sfx */\nstatic inline\nvoid show_strbuf(const struct _strbuf *strbuf, const char *pname, int skip, cl_int err)\n{\n\tprintf(\"%s\" I1_STR \"%s%s\\n\",\n\t\tline_pfx, pname,\n\t\t(skip ? skip_leading_ws(strbuf->buf) : strbuf->buf),\n\t\terr ? empty_str : cur_sfx);\n}\n\nvoid\nplatform_info_str(struct platform_info_ret *ret,\n\tconst struct info_loc *loc, const struct platform_info_checks* UNUSED(chk),\n\tconst struct opt_out* UNUSED(output))\n{\n\tGET_STRING_LOC(ret, loc, clGetPlatformInfo, loc->plat, loc->param.plat);\n}\n\nvoid\nplatform_info_ulong(struct platform_info_ret *ret,\n\tconst struct info_loc *loc, const struct platform_info_checks* UNUSED(chk),\n\tconst struct opt_out *output)\n{\n\tret->err = REPORT_ERROR_LOC(ret,\n\t\tclGetPlatformInfo(loc->plat, loc->param.plat, sizeof(ret->value.u64), &ret->value.u64, NULL),\n\t\tloc, \"get %s\");\n\tCHECK_SIZE(ret, loc, ret->value.u64, clGetPlatformInfo, loc->plat, loc->param.plat);\n\tstrbuf_printf(&ret->str, \"%\" PRIu64, ret->value.u64);\n}\n\nvoid\nplatform_info_sz(struct platform_info_ret *ret,\n\tconst struct info_loc *loc, const struct platform_info_checks* UNUSED(chk),\n\tconst struct opt_out *output)\n{\n\tret->err = REPORT_ERROR_LOC(ret,\n\t\tclGetPlatformInfo(loc->plat, loc->param.plat, sizeof(ret->value.s), &ret->value.s, NULL),\n\t\tloc, \"get %s\");\n\tCHECK_SIZE(ret, loc, ret->value.s, clGetPlatformInfo, loc->plat, loc->param.plat);\n\tstrbuf_printf(&ret->str, \"%\" PRIuS, ret->value.s);\n}\n\nstruct platform_info_traits {\n\tcl_platform_info param; // CL_PLATFORM_*\n\tconst char *sname; // \"CL_PLATFORM_*\"\n\tconst char *pname; // \"Platform *\"\n\tconst char *sfx; // suffix for the output in non-raw mode\n\t/* pointer to function that retrieves the parameter */\n\tvoid (*show_func)(struct platform_info_ret *,\n\t\tconst struct info_loc *, const struct platform_info_checks *,\n\t\tconst struct opt_out *);\n\t/* pointer to function that checks if the parameter should be retrieved */\n\tcl_bool (*check_func)(const struct platform_info_checks *);\n};\n\ncl_bool khr_icd_p(const struct platform_info_checks *chk)\n{\n\treturn chk->has_khr_icd;\n}\n\ncl_bool plat_is_20(const struct platform_info_checks *chk)\n{\n\treturn !(chk->plat_version < 20);\n}\n\ncl_bool plat_is_21(const struct platform_info_checks *chk)\n{\n\treturn !(chk->plat_version < 21);\n}\n\ncl_bool plat_has_amd_object_metadata(const struct platform_info_checks *chk)\n{\n\treturn chk->has_amd_object_metadata;\n}\n\n\n#define PINFO_COND(symbol, name, sfx, typ, funcptr) { symbol, #symbol, \"Platform \" name, sfx, &platform_info_##typ, &funcptr }\n#define PINFO(symbol, name, sfx, typ) { symbol, #symbol, \"Platform \" name, sfx, &platform_info_##typ, NULL }\nstruct platform_info_traits pinfo_traits[] = {\n\tPINFO(CL_PLATFORM_NAME, \"Name\", NULL, str),\n\tPINFO(CL_PLATFORM_VENDOR, \"Vendor\", NULL, str),\n\tPINFO(CL_PLATFORM_VERSION, \"Version\", NULL, str),\n\tPINFO(CL_PLATFORM_PROFILE, \"Profile\", NULL, str),\n\tPINFO(CL_PLATFORM_EXTENSIONS, \"Extensions\", NULL, str),\n\tPINFO_COND(CL_PLATFORM_MAX_KEYS_AMD, \"Max metadata object keys (AMD)\", NULL, sz, plat_has_amd_object_metadata),\n\tPINFO_COND(CL_PLATFORM_HOST_TIMER_RESOLUTION, \"Host timer resolution\", \"ns\", ulong, plat_is_21),\n\tPINFO_COND(CL_PLATFORM_ICD_SUFFIX_KHR, \"Extensions function suffix\", NULL, str, khr_icd_p)\n};\n\n/* Collect (and optionally show) infomation on a specific platform,\n * initializing relevant arrays and optionally showing the collected\n * information\n */\nvoid\ngatherPlatformInfo(struct platform_list *plist, cl_uint p, const struct opt_out *output)\n{\n\tcl_int len = 0;\n\n\tstruct platform_data *pdata = plist->pdata + p;\n\tstruct platform_info_checks *pinfo_checks = plist->platform_checks + p;\n\tstruct platform_info_ret ret;\n\tstruct info_loc loc;\n\n\tpinfo_checks->plat_version = 10;\n\n\tINIT_RET(ret, \"platform\");\n\treset_loc(&loc, __func__);\n\tloc.plat = plist->platform[p];\n\n\tfor (loc.line = 0; loc.line < ARRAY_SIZE(pinfo_traits); ++loc.line) {\n\t\tconst struct platform_info_traits *traits = pinfo_traits + loc.line;\n\n\t\t/* checked is true if there was no condition to check for, or if the\n\t\t * condition was satisfied\n\t\t */\n\t\tint checked = !(traits->check_func && !traits->check_func(pinfo_checks));\n\n\t\tif (output->cond == COND_PROP_CHECK && !checked)\n\t\t\tcontinue;\n\n\t\tloc.sname = traits->sname;\n\t\tloc.pname = (output->mode == CLINFO_HUMAN ?\n\t\t\ttraits->pname : traits->sname);\n\t\tloc.param.plat = traits->param;\n\n\t\tcur_sfx = (output->mode == CLINFO_HUMAN && traits->sfx) ? traits->sfx : empty_str;\n\n\t\tret.str.buf[0] = '\\0';\n\t\tret.err_str.buf[0] = '\\0';\n\t\ttraits->show_func(&ret, &loc, pinfo_checks, output);\n\n\t\t/* The property is skipped if this was a conditional property,\n\t\t * unsatisfied, there was an error retrieving it and cond_prop_mode is not\n\t\t * COND_PROP_SHOW.\n\t\t */\n\t\tif (ret.err && !checked && output->cond != COND_PROP_SHOW)\n\t\t\tcontinue;\n\n\t\t/* when only listing, do not print anything, we're just gathering\n\t\t * information */\n\t\tif (output->detailed) {\n\t\t\tshow_strbuf(RET_BUF(ret), loc.pname, 0, ret.err);\n\t\t}\n\n\t\tif (ret.err)\n\t\t\tcontinue;\n\n\t\t/* post-processing */\n\n\t\tswitch (traits->param) {\n\t\tcase CL_PLATFORM_NAME:\n\t\t\t/* Store name for future reference */\n\t\t\tlen = strlen(ret.str.buf);\n\t\t\tALLOC(pdata->pname, len+1, \"platform name copy\");\n\t\t\t/* memcpy instead of strncpy since we already have the len\n\t\t\t * and memcpy is possibly more optimized */\n\t\t\tmemcpy(pdata->pname, ret.str.buf, len);\n\t\t\tpdata->pname[len] = '\\0';\n\t\t\tbreak;\n\t\tcase CL_PLATFORM_VERSION:\n\t\t\t/* compute numeric value for OpenCL version */\n\t\t\tpinfo_checks->plat_version = getOpenCLVersion(ret.str.buf + 7);\n\t\t\tbreak;\n\t\tcase CL_PLATFORM_EXTENSIONS:\n\t\t\tpinfo_checks->has_khr_icd = !!strstr(ret.str.buf, \"cl_khr_icd\");\n\t\t\tpinfo_checks->has_amd_object_metadata = !!strstr(ret.str.buf, \"cl_amd_object_metadata\");\n\t\t\tpdata->has_amd_offline = !!strstr(ret.str.buf, \"cl_amd_offline_devices\");\n\t\t\tbreak;\n\t\tcase CL_PLATFORM_ICD_SUFFIX_KHR:\n\t\t\t/* Store ICD suffix for future reference */\n\t\t\tlen = strlen(ret.str.buf);\n\t\t\tALLOC(pdata->sname, len+1, \"platform ICD suffix copy\");\n\t\t\t/* memcpy instead of strncpy since we already have the len\n\t\t\t * and memcpy is possibly more optimized */\n\t\t\tmemcpy(pdata->sname, ret.str.buf, len);\n\t\t\tpdata->sname[len] = '\\0';\n\t\tdefault:\n\t\t\t/* do nothing */\n\t\t\tbreak;\n\t\t}\n\n\t}\n\n\tif (pinfo_checks->plat_version > plist->max_plat_version)\n\t\tplist->max_plat_version = pinfo_checks->plat_version;\n\n\t/* if no CL_PLATFORM_ICD_SUFFIX_KHR, use P### as short/symbolic name */\n\tif (!pdata->sname) {\n#define SNAME_MAX 32\n\t\tALLOC(pdata->sname, SNAME_MAX, \"platform symbolic name\");\n\t\tsnprintf(pdata->sname, SNAME_MAX, \"P%\" PRIu32 \"\", p);\n\t}\n\n\tlen = (cl_int)strlen(pdata->sname);\n\tif (len > plist->max_sname_len)\n\t\tplist->max_sname_len = len;\n\n\tret.err = clGetDeviceIDs(loc.plat, CL_DEVICE_TYPE_ALL, 0, NULL, &pdata->ndevs);\n\tif (ret.err == CL_DEVICE_NOT_FOUND)\n\t\tpdata->ndevs = 0;\n\telse\n\t\tCHECK_ERROR(ret.err, \"number of devices\");\n\tplist->ndevs_total += pdata->ndevs;\n\tplist->dev_offset[p] = p ? plist->dev_offset[p-1] + (pdata-1)->ndevs : 0;\n\tplist_devs_reserve(plist, plist->ndevs_total);\n\n\tif (pdata->ndevs > 0) {\n\t\tret.err = clGetDeviceIDs(loc.plat, CL_DEVICE_TYPE_ALL,\n\t\t\tpdata->ndevs,\n\t\t\tplist->all_devs + plist->dev_offset[p], NULL);\n\t}\n\n\tif (pdata->ndevs > plist->max_devs)\n\t\tplist->max_devs = pdata->ndevs;\n\n\tUNINIT_RET(ret);\n}\n\n/*\n * Device properties/extensions used in traits checks, and relevant functions\n */\n\nstruct device_info_checks {\n\tconst struct platform_info_checks *pinfo_checks;\n\tcl_device_type devtype;\n\tcl_device_mem_cache_type cachetype;\n\tcl_device_local_mem_type lmemtype;\n\tcl_bool image_support;\n\tcl_bool compiler_available;\n\tchar has_half[12];\n\tchar has_double[24];\n\tchar has_nv[29];\n\tchar has_amd[30];\n\tchar has_amd_svm[11];\n\tchar has_arm_svm[29];\n\tchar has_fission[22];\n\tchar has_atomic_counters[26];\n\tchar has_image2d_buffer[27];\n\tchar has_il_program[18];\n\tchar has_intel_local_thread[30];\n\tchar has_intel_AME[36];\n\tchar has_intel_AVC_ME[43];\n\tchar has_intel_planar_yuv[20];\n\tchar has_intel_required_subgroup_size[32];\n\tchar has_altera_dev_temp[29];\n\tchar has_p2p[23];\n\tchar has_spir[12];\n\tchar has_qcom_ext_host_ptr[21];\n\tchar has_simultaneous_sharing[30];\n\tchar has_subgroup_named_barrier[30];\n\tchar has_terminate_context[25];\n\tcl_uint dev_version;\n};\n\n#define DEFINE_EXT_CHECK(ext) cl_bool dev_has_##ext(const struct device_info_checks *chk) \\\n{ \\\n\treturn !!(chk->has_##ext[0]); \\\n}\n\nDEFINE_EXT_CHECK(half)\nDEFINE_EXT_CHECK(double)\nDEFINE_EXT_CHECK(nv)\nDEFINE_EXT_CHECK(amd)\nDEFINE_EXT_CHECK(amd_svm)\nDEFINE_EXT_CHECK(arm_svm)\nDEFINE_EXT_CHECK(fission)\nDEFINE_EXT_CHECK(atomic_counters)\nDEFINE_EXT_CHECK(image2d_buffer)\nDEFINE_EXT_CHECK(il_program)\nDEFINE_EXT_CHECK(intel_local_thread)\nDEFINE_EXT_CHECK(intel_AME)\nDEFINE_EXT_CHECK(intel_AVC_ME)\nDEFINE_EXT_CHECK(intel_planar_yuv)\nDEFINE_EXT_CHECK(intel_required_subgroup_size)\nDEFINE_EXT_CHECK(altera_dev_temp)\nDEFINE_EXT_CHECK(p2p)\nDEFINE_EXT_CHECK(spir)\nDEFINE_EXT_CHECK(qcom_ext_host_ptr)\nDEFINE_EXT_CHECK(simultaneous_sharing)\nDEFINE_EXT_CHECK(subgroup_named_barrier)\nDEFINE_EXT_CHECK(terminate_context)\n\n/* In the version checks we negate the opposite conditions\n * instead of double-negating the actual condition\n */\n\n// device supports 1.2\ncl_bool dev_is_12(const struct device_info_checks *chk)\n{\n\treturn !(chk->dev_version < 12);\n}\n\n// device supports 2.0\ncl_bool dev_is_20(const struct device_info_checks *chk)\n{\n\treturn !(chk->dev_version < 20);\n}\n\n// device supports 2.1\ncl_bool dev_is_21(const struct device_info_checks *chk)\n{\n\treturn !(chk->dev_version < 21);\n}\n\n// device does not support 2.0\ncl_bool dev_not_20(const struct device_info_checks *chk)\n{\n\treturn !(chk->dev_version >= 20);\n}\n\n\ncl_bool dev_is_gpu(const struct device_info_checks *chk)\n{\n\treturn !!(chk->devtype & CL_DEVICE_TYPE_GPU);\n}\n\ncl_bool dev_is_gpu_amd(const struct device_info_checks *chk)\n{\n\treturn dev_is_gpu(chk) && dev_has_amd(chk);\n}\n\n/* Device supports cl_amd_device_attribute_query v4 */\ncl_bool dev_has_amd_v4(const struct device_info_checks *chk)\n{\n\t/* We don't actually have a criterion to check if the device\n\t * supports a specific version of an extension, so for the time\n\t * being rely on them being GPU devices with cl_amd_device_attribute_query\n\t * and the platform supporting OpenCL 2.0 or later\n\t * TODO FIXME tune criteria\n\t */\n\treturn dev_is_gpu(chk) && dev_has_amd(chk) && plat_is_20(chk->pinfo_checks);\n}\n\n\ncl_bool dev_has_svm(const struct device_info_checks *chk)\n{\n\treturn dev_is_20(chk) || dev_has_amd_svm(chk);\n}\n\ncl_bool dev_has_partition(const struct device_info_checks *chk)\n{\n\treturn dev_is_12(chk) || dev_has_fission(chk);\n}\n\ncl_bool dev_has_cache(const struct device_info_checks *chk)\n{\n\treturn chk->cachetype != CL_NONE;\n}\n\ncl_bool dev_has_lmem(const struct device_info_checks *chk)\n{\n\treturn chk->lmemtype != CL_NONE;\n}\n\ncl_bool dev_has_il(const struct device_info_checks *chk)\n{\n\treturn dev_is_21(chk) || dev_has_il_program(chk);\n}\n\ncl_bool dev_has_images(const struct device_info_checks *chk)\n{\n\treturn chk->image_support;\n}\n\ncl_bool dev_has_images_12(const struct device_info_checks *chk)\n{\n\treturn dev_has_images(chk) && dev_is_12(chk);\n}\n\ncl_bool dev_has_images_20(const struct device_info_checks *chk)\n{\n\treturn dev_has_images(chk) && dev_is_20(chk);\n}\n\ncl_bool dev_has_compiler(const struct device_info_checks *chk)\n{\n\treturn chk->compiler_available;\n}\n\n\nvoid identify_device_extensions(const char *extensions, struct device_info_checks *chk)\n{\n#define _HAS_EXT(ext) (strstr(extensions, ext))\n#define HAS_EXT(ext) _HAS_EXT(#ext)\n#define CPY_EXT(what, ext) do { \\\n\tstrncpy(chk->has_##what, has, sizeof(ext)); \\\n\tchk->has_##what[sizeof(ext)-1] = '\\0'; \\\n} while (0)\n#define CHECK_EXT(what, ext) do { \\\n\thas = _HAS_EXT(#ext); \\\n\tif (has) CPY_EXT(what, #ext); \\\n} while(0)\n\n\tchar *has;\n\tCHECK_EXT(half, cl_khr_fp16);\n\tCHECK_EXT(spir, cl_khr_spir);\n\tCHECK_EXT(double, cl_khr_fp64);\n\tif (!dev_has_double(chk))\n\t\tCHECK_EXT(double, cl_amd_fp64);\n\tif (!dev_has_double(chk))\n\t\tCHECK_EXT(double, cl_APPLE_fp64_basic_ops);\n\tCHECK_EXT(nv, cl_nv_device_attribute_query);\n\tCHECK_EXT(amd, cl_amd_device_attribute_query);\n\tCHECK_EXT(amd_svm, cl_amd_svm);\n\tCHECK_EXT(arm_svm, cl_arm_shared_virtual_memory);\n\tCHECK_EXT(fission, cl_ext_device_fission);\n\tCHECK_EXT(atomic_counters, cl_ext_atomic_counters_64);\n\tif (dev_has_atomic_counters(chk))\n\t\tCHECK_EXT(atomic_counters, cl_ext_atomic_counters_32);\n\tCHECK_EXT(image2d_buffer, cl_khr_image2d_from_buffer);\n\tCHECK_EXT(il_program, cl_khr_il_program);\n\tCHECK_EXT(intel_local_thread, cl_intel_exec_by_local_thread);\n\tCHECK_EXT(intel_AME, cl_intel_advanced_motion_estimation);\n\tCHECK_EXT(intel_AVC_ME, cl_intel_device_side_avc_motion_estimation);\n\tCHECK_EXT(intel_planar_yuv, cl_intel_planar_yuv);\n\tCHECK_EXT(intel_required_subgroup_size, cl_intel_required_subgroup_size);\n\tCHECK_EXT(altera_dev_temp, cl_altera_device_temperature);\n\tCHECK_EXT(p2p, cl_amd_copy_buffer_p2p);\n\tCHECK_EXT(qcom_ext_host_ptr, cl_qcom_ext_host_ptr);\n\tCHECK_EXT(simultaneous_sharing, cl_intel_simultaneous_sharing);\n\tCHECK_EXT(subgroup_named_barrier, cl_khr_subgroup_named_barrier);\n\tCHECK_EXT(terminate_context, cl_khr_terminate_context);\n}\n\n\n/*\n * Device info print functions\n */\n\n#define _GET_VAL(ret, loc, val) \\\n\tret->err = REPORT_ERROR_LOC(ret, \\\n\t\tclGetDeviceInfo((loc)->dev, (loc)->param.dev, sizeof(val), &(val), NULL), \\\n\t\tloc, \"get %s\"); \\\n\tCHECK_SIZE(ret, loc, val, clGetDeviceInfo, (loc)->dev, (loc)->param.dev);\n\n#define _GET_VAL_ARRAY(ret, loc) \\\n\tret->err = REPORT_ERROR_LOC(ret, \\\n\t\tclGetDeviceInfo(loc->dev, loc->param.dev, 0, NULL, &szval), \\\n\t\tloc, \"get number of %s\"); \\\n\tnumval = szval/sizeof(*val); \\\n\tif (!ret->err) { \\\n\t\tREALLOC(val, numval, loc->sname); \\\n\t\tret->err = REPORT_ERROR_LOC(ret, \\\n\t\t\tclGetDeviceInfo(loc->dev, loc->param.dev, szval, val, NULL), \\\n\t\t\tloc, \"get %s\"); \\\n\t\tif (ret->err) { free(val); val = NULL; } \\\n\t}\n\n#define GET_VAL(ret, loc, field) do { \\\n\t_GET_VAL(ret, (loc), ret->value.field) \\\n} while (0)\n\n#define GET_VAL_ARRAY(ret, loc) do { \\\n\t_GET_VAL_ARRAY(ret, (loc)) \\\n} while (0)\n\n#define DEFINE_DEVINFO_FETCH(type, field) \\\ntype \\\ndevice_fetch_##type(struct device_info_ret *ret, \\\n\tconst struct info_loc *loc, const struct device_info_checks* UNUSED(chk), \\\n\tconst struct opt_out *output) \\\n{ \\\n\tGET_VAL(ret, loc, field); \\\n\treturn ret->value.field; \\\n}\n\nDEFINE_DEVINFO_FETCH(size_t, s)\nDEFINE_DEVINFO_FETCH(cl_bool, b)\nDEFINE_DEVINFO_FETCH(cl_uint, u32)\nDEFINE_DEVINFO_FETCH(cl_ulong, u64)\nDEFINE_DEVINFO_FETCH(cl_device_type, devtype)\nDEFINE_DEVINFO_FETCH(cl_device_mem_cache_type, cachetype)\nDEFINE_DEVINFO_FETCH(cl_device_local_mem_type, lmemtype)\nDEFINE_DEVINFO_FETCH(cl_device_topology_amd, devtopo)\nDEFINE_DEVINFO_FETCH(cl_device_affinity_domain, affinity_domain)\nDEFINE_DEVINFO_FETCH(cl_device_fp_config, fpconfig)\nDEFINE_DEVINFO_FETCH(cl_command_queue_properties, qprop)\nDEFINE_DEVINFO_FETCH(cl_device_exec_capabilities, execap)\nDEFINE_DEVINFO_FETCH(cl_device_svm_capabilities, svmcap)\nDEFINE_DEVINFO_FETCH(cl_device_terminate_capability_khr, termcap)\n\n#define DEV_FETCH_LOC(type, var, loc) \\\n\ttype var = device_fetch_##type(ret, loc, chk, output)\n#define DEV_FETCH(type, var) DEV_FETCH_LOC(type, var, loc)\n\n#define FMT_VAL(ret, fmt, val) if (!ret->err) strbuf_printf(&ret->str, fmt, val)\n\n#define DEFINE_DEVINFO_SHOW(how, type, field, fmt) \\\nvoid \\\ndevice_info_##how(struct device_info_ret *ret, \\\n\tconst struct info_loc *loc, const struct device_info_checks* chk, \\\n\tconst struct opt_out *output) \\\n{ \\\n\tDEV_FETCH(type, val); \\\n\tif (!ret->err) FMT_VAL(ret, fmt, val); \\\n}\n\nDEFINE_DEVINFO_SHOW(int, cl_uint, u32, \"%\" PRIu32)\nDEFINE_DEVINFO_SHOW(hex, cl_uint, u32, \"%#\" PRIx32)\nDEFINE_DEVINFO_SHOW(long, cl_ulong, u64, \"%\" PRIu64)\nDEFINE_DEVINFO_SHOW(sz, size_t, s, \"%\" PRIuS)\n\nvoid\ndevice_info_str(struct device_info_ret *ret,\n\tconst struct info_loc *loc, const struct device_info_checks* UNUSED(chk),\n\tconst struct opt_out* UNUSED(output))\n{\n\tGET_STRING_LOC(ret, loc, clGetDeviceInfo, loc->dev, loc->param.dev);\n}\n\nvoid\ndevice_info_bool(struct device_info_ret *ret,\n\tconst struct info_loc *loc, const struct device_info_checks* UNUSED(chk),\n\tconst struct opt_out *output)\n{\n\tDEV_FETCH(cl_bool, val);\n\tif (!ret->err) {\n\t\tconst char * const * str = (output->mode == CLINFO_HUMAN ?\n\t\t\tbool_str : bool_raw_str);\n\t\tstrbuf_printf(&ret->str, \"%s\", str[val]);\n\t}\n}\n\nvoid\ndevice_info_bits(struct device_info_ret *ret,\n\tconst struct info_loc *loc, const struct device_info_checks* UNUSED(chk),\n\tconst struct opt_out *output)\n{\n\tDEV_FETCH(cl_uint, val);\n\tif (!ret->err)\n\t\tstrbuf_printf(&ret->str, \"%\" PRIu32 \" bits (%\" PRIu32 \" bytes)\", val, val/8);\n}\n\n\nsize_t strbuf_mem(struct _strbuf *str, cl_ulong val, size_t szval)\n{\n\tdouble dbl = (double)val;\n\tsize_t sfx = 0;\n\twhile (dbl > 1024 && sfx < memsfx_end) {\n\t\tdbl /= 1024;\n\t\t++sfx;\n\t}\n\treturn sprintf(str->buf + szval, \" (%.4lg%s)\",\n\t\tdbl, memsfx[sfx]);\n}\n\nvoid\ndevice_info_mem(struct device_info_ret *ret,\n\tconst struct info_loc *loc, const struct device_info_checks* UNUSED(chk),\n\tconst struct opt_out *output)\n{\n\tDEV_FETCH(cl_ulong, val);\n\tif (!ret->err) {\n\t\tsize_t szval = strbuf_printf(&ret->str, \"%\" PRIu64, val);\n\t\tif (output->mode == CLINFO_HUMAN && val > 1024)\n\t\t\tstrbuf_mem(&ret->str, val, szval);\n\t}\n}\n\nvoid\ndevice_info_mem_int(struct device_info_ret *ret,\n\tconst struct info_loc *loc, const struct device_info_checks* UNUSED(chk),\n\tconst struct opt_out *output)\n{\n\tDEV_FETCH(cl_uint, val);\n\tif (!ret->err) {\n\t\tsize_t szval = strbuf_printf(&ret->str, \"%\" PRIu32, val);\n\t\tif (output->mode == CLINFO_HUMAN && val > 1024)\n\t\t\tstrbuf_mem(&ret->str, val, szval);\n\t}\n}\n\nvoid\ndevice_info_mem_sz(struct device_info_ret *ret,\n\tconst struct info_loc *loc, const struct device_info_checks* UNUSED(chk),\n\tconst struct opt_out *output)\n{\n\tDEV_FETCH(size_t, val);\n\tif (!ret->err) {\n\t\tsize_t szval = strbuf_printf(&ret->str, \"%\" PRIuS, val);\n\t\tif (output->mode == CLINFO_HUMAN && val > 1024)\n\t\t\tstrbuf_mem(&ret->str, val, szval);\n\t}\n}\n\nvoid\ndevice_info_free_mem_amd(struct device_info_ret *ret,\n\tconst struct info_loc *loc, const struct device_info_checks* UNUSED(chk),\n\tconst struct opt_out *output)\n{\n\tsize_t *val = NULL;\n\tsize_t szval = 0, numval = 0;\n\tGET_VAL_ARRAY(ret, loc);\n\tif (!ret->err) {\n\t\tsize_t cursor = 0;\n\t\tszval = 0;\n\t\tfor (cursor = 0; cursor < numval; ++cursor) {\n\t\t\tif (szval > 0) {\n\t\t\t\tret->str.buf[szval] = ' ';\n\t\t\t\t++szval;\n\t\t\t}\n\t\t\tszval += sprintf(ret->str.buf + szval, \"%\" PRIuS, val[cursor]);\n\t\t\tif (output->mode == CLINFO_HUMAN)\n\t\t\t\tszval += strbuf_mem(&ret->str, val[cursor]*UINT64_C(1024), szval);\n\t\t}\n\t\t// TODO: ret->value.??? = val;\n\t}\n\tfree(val);\n}\n\nvoid\ndevice_info_time_offset(struct device_info_ret *ret,\n\tconst struct info_loc *loc, const struct device_info_checks* UNUSED(chk),\n\tconst struct opt_out *output)\n{\n\tDEV_FETCH(cl_ulong, val);\n\tif (!ret->err) {\n\t\tsize_t szval = 0;\n\t\ttime_t time = val/UINT64_C(1000000000);\n\t\tszval += strbuf_printf(&ret->str, \"%\" PRIu64 \"ns (\", val);\n\t\tszval += bufcpy(&ret->str, szval, ctime(&time));\n\t\t/* overwrite ctime's newline with the closing parenthesis */\n\t\tif (szval < ret->str.sz)\n\t\t\tret->str.buf[szval - 1] = ')';\n\t}\n}\n\nvoid\ndevice_info_szptr_sep(struct device_info_ret *ret, const char *human_sep,\n\tconst struct info_loc *loc, const struct device_info_checks* UNUSED(chk),\n\tconst struct opt_out *output)\n{\n\tsize_t *val = NULL;\n\tsize_t szval = 0, numval = 0;\n\tGET_VAL_ARRAY(ret, loc);\n\tif (!ret->err) {\n\t\tsize_t counter = 0;\n\t\tset_separator(output->mode == CLINFO_HUMAN ? human_sep : spc_str);\n\t\tszval = 0;\n\t\tfor (counter = 0; counter < numval; ++counter) {\n\t\t\tadd_separator(&ret->str, &szval);\n\t\t\tszval += snprintf(ret->str.buf + szval, ret->str.sz - szval - 1, \"%\" PRIuS, val[counter]);\n\t\t\tif (szval >= ret->str.sz) {\n\t\t\t\ttrunc_strbuf(&ret->str);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// TODO: ret->value.??? = val;\n\t}\n\tfree(val);\n}\n\nvoid\ndevice_info_szptr_times(struct device_info_ret *ret,\n\tconst struct info_loc *loc, const struct device_info_checks* chk,\n\tconst struct opt_out *output)\n{\n\tdevice_info_szptr_sep(ret, times_str, loc, chk, output);\n}\n\nvoid\ndevice_info_szptr_comma(struct device_info_ret *ret,\n\tconst struct info_loc *loc, const struct device_info_checks* chk,\n\tconst struct opt_out *output)\n{\n\tdevice_info_szptr_sep(ret, comma_str, loc, chk, output);\n}\n\nvoid\ngetWGsizes(struct device_info_ret *ret, const struct info_loc *loc, size_t *wgm, size_t wgm_sz,\n\tconst struct opt_out* UNUSED(output))\n{\n\tcl_int log_err;\n\n\tcl_context_properties ctxpft[] = {\n\t\tCL_CONTEXT_PLATFORM, (cl_context_properties)loc->plat,\n\t\t0, 0 };\n\tcl_uint cursor = 0;\n\tcl_context ctx = NULL;\n\tcl_program prg = NULL;\n\tcl_kernel krn = NULL;\n\n\tret->err = CL_SUCCESS;\n\n\tctx = clCreateContext(ctxpft, 1, &loc->dev, NULL, NULL, &ret->err);\n\tif (REPORT_ERROR(&ret->err_str, ret->err, \"create context\")) goto out;\n\tprg = clCreateProgramWithSource(ctx, ARRAY_SIZE(sources), sources, NULL, &ret->err);\n\tif (REPORT_ERROR(&ret->err_str, ret->err, \"create program\")) goto out;\n\tret->err = clBuildProgram(prg, 1, &loc->dev, NULL, NULL, NULL);\n\tlog_err = REPORT_ERROR(&ret->err_str, ret->err, \"build program\");\n\n\t/* for a program build failure, dump the log to stderr before bailing */\n\tif (log_err == CL_BUILD_PROGRAM_FAILURE) {\n\t\tstruct _strbuf logbuf;\n\t\tinit_strbuf(&logbuf);\n\t\tGET_STRING(&logbuf, ret->err,\n\t\t\tclGetProgramBuildInfo, CL_PROGRAM_BUILD_LOG, \"CL_PROGRAM_BUILD_LOG\", prg, loc->dev);\n\t\tif (ret->err == CL_SUCCESS) {\n\t\t\tfflush(stdout);\n\t\t\tfflush(stderr);\n\t\t\tfputs(\"=== CL_PROGRAM_BUILD_LOG ===\\n\", stderr);\n\t\t\tfputs(logbuf.buf, stderr);\n\t\t\tfflush(stderr);\n\t\t}\n\t\tfree_strbuf(&logbuf);\n\t}\n\tif (ret->err)\n\t\tgoto out;\n\n\tfor (cursor = 0; cursor < wgm_sz; ++cursor) {\n\t\tstrbuf_printf(&ret->str, \"sum%u\", 1<<cursor);\n\t\tif (cursor == 0)\n\t\t\tret->str.buf[3] = 0; // scalar kernel is called 'sum'\n\t\tkrn = clCreateKernel(prg, ret->str.buf, &ret->err);\n\t\tif (REPORT_ERROR(&ret->err_str, ret->err, \"create kernel\")) goto out;\n\t\tret->err = clGetKernelWorkGroupInfo(krn, loc->dev, CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE,\n\t\t\tsizeof(*wgm), wgm + cursor, NULL);\n\t\tif (REPORT_ERROR(&ret->err_str, ret->err, \"get kernel info\")) goto out;\n\t\tclReleaseKernel(krn);\n\t\tkrn = NULL;\n\t}\n\nout:\n\tif (krn)\n\t\tclReleaseKernel(krn);\n\tif (prg)\n\t\tclReleaseProgram(prg);\n\tif (ctx)\n\t\tclReleaseContext(ctx);\n}\n\n\nvoid\ndevice_info_wg(struct device_info_ret *ret,\n\tconst struct info_loc *loc, const struct device_info_checks* UNUSED(chk),\n\tconst struct opt_out *output)\n{\n\t/* preferred workgroup size multiple for each kernel\n\t * have not found a platform where the WG multiple changes,\n\t * but keep this flexible (this can grow up to 5)\n\t */\n#define NUM_KERNELS 1\n\tsize_t wgm[NUM_KERNELS] = {0};\n\n\tgetWGsizes(ret, loc, wgm, NUM_KERNELS, output);\n\tif (!ret->err) {\n\t\tstrbuf_printf(&ret->str, \"%\" PRIuS, wgm[0]);\n\t}\n\tret->value.s = wgm[0];\n}\n\nvoid\ndevice_info_img_sz_2d(struct device_info_ret *ret,\n\tconst struct info_loc *loc, const struct device_info_checks* UNUSED(chk),\n\tconst struct opt_out *output)\n{\n\tstruct info_loc loc2 = *loc;\n\tsize_t width = 0, height = 0;\n\t_GET_VAL(ret, loc, height); /* HEIGHT */\n\tif (!ret->err) {\n\t\tRESET_LOC_PARAM(loc2, dev, CL_DEVICE_IMAGE2D_MAX_WIDTH);\n\t\t_GET_VAL(ret, &loc2, width);\n\t\tif (!ret->err) {\n\t\t\tstrbuf_printf(&ret->str, \"%\" PRIuS \"x%\" PRIuS, width, height);\n\t\t}\n\t}\n\tret->value.u32v.s[0] = width;\n\tret->value.u32v.s[1] = height;\n}\n\nvoid\ndevice_info_img_sz_intel_planar_yuv(struct device_info_ret *ret,\n\tconst struct info_loc *loc, const struct device_info_checks* UNUSED(chk),\n\tconst struct opt_out *output)\n{\n\tstruct info_loc loc2 = *loc;\n\tsize_t width = 0, height = 0;\n\t_GET_VAL(ret, loc, height); /* HEIGHT */\n\tif (!ret->err) {\n\t\tRESET_LOC_PARAM(loc2, dev, CL_DEVICE_PLANAR_YUV_MAX_WIDTH_INTEL);\n\t\t_GET_VAL(ret, &loc2, width);\n\t\tif (!ret->err) {\n\t\t\tstrbuf_printf(&ret->str, \"%\" PRIuS \"x%\" PRIuS, width, height);\n\t\t}\n\t}\n\tret->value.u32v.s[0] = width;\n\tret->value.u32v.s[1] = height;\n}\n\n\nvoid\ndevice_info_img_sz_3d(struct device_info_ret *ret,\n\tconst struct info_loc *loc, const struct device_info_checks* UNUSED(chk),\n\tconst struct opt_out *output)\n{\n\tstruct info_loc loc2 = *loc;\n\tsize_t width = 0, height = 0, depth = 0;\n\t_GET_VAL(ret, loc, height); /* HEIGHT */\n\tif (!ret->err) {\n\t\tRESET_LOC_PARAM(loc2, dev, CL_DEVICE_IMAGE3D_MAX_WIDTH);\n\t\t_GET_VAL(ret, &loc2, width);\n\t\tif (!ret->err) {\n\t\t\tRESET_LOC_PARAM(loc2, dev, CL_DEVICE_IMAGE3D_MAX_DEPTH);\n\t\t\t_GET_VAL(ret, &loc2, depth);\n\t\t\tif (!ret->err) {\n\t\t\t\tstrbuf_printf(&ret->str, \"%\" PRIuS \"x%\" PRIuS \"x%\" PRIuS,\n\t\t\t\t\twidth, height, depth);\n\t\t\t}\n\t\t}\n\t}\n\tret->value.u32v.s[0] = width;\n\tret->value.u32v.s[1] = height;\n\tret->value.u32v.s[2] = depth;\n}\n\n\nvoid\ndevice_info_devtype(struct device_info_ret *ret,\n\tconst struct info_loc *loc, const struct device_info_checks* UNUSED(chk),\n\tconst struct opt_out *output)\n{\n\tDEV_FETCH(cl_device_type, val);\n\tif (!ret->err) {\n\t\t/* iterate over device type strings, appending their textual form\n\t\t * to ret->str */\n\t\tcl_uint i = (cl_uint)actual_devtype_count;\n\t\tconst char * const *devstr = (output->mode == CLINFO_HUMAN ?\n\t\t\tdevice_type_str : device_type_raw_str);\n\t\tsize_t szval = 0;\n\t\tset_separator(output->mode == CLINFO_HUMAN ? comma_str : vbar_str);\n\t\tfor (; i > 0; --i) {\n\t\t\t/* assemble CL_DEVICE_TYPE_* from index i */\n\t\t\tcl_device_type cur = (cl_device_type)(1) << (i-1);\n\t\t\tif (val & cur) {\n\t\t\t\t/* match: add separator if not first match */\n\t\t\t\tadd_separator(&ret->str, &szval);\n\t\t\t\tszval += bufcpy(&ret->str, szval, devstr[i]);\n\t\t\t}\n\t\t}\n\t\t/* check for extra bits */\n\t\tif (szval < ret->str.sz) {\n\t\t\tcl_device_type known_mask = ((cl_device_type)(1) << actual_devtype_count) - 1;\n\t\t\tcl_device_type extra = val & ~known_mask;\n\t\t\tif (extra) {\n\t\t\t\tadd_separator(&ret->str, &szval);\n\t\t\t\tszval += snprintf(ret->str.buf + szval, ret->str.sz - szval - 1, \"%#\" PRIx64, extra);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid\ndevice_info_cachetype(struct device_info_ret *ret,\n\tconst struct info_loc *loc, const struct device_info_checks* UNUSED(chk),\n\tconst struct opt_out *output)\n{\n\tDEV_FETCH(cl_device_mem_cache_type, val);\n\tif (!ret->err) {\n\t\tconst char * const *ar = (output->mode == CLINFO_HUMAN ?\n\t\t\tcache_type_str : cache_type_raw_str);\n\t\tbufcpy(&ret->str, 0, ar[val]);\n\t}\n}\n\nvoid\ndevice_info_lmemtype(struct device_info_ret *ret,\n\tconst struct info_loc *loc, const struct device_info_checks* UNUSED(chk),\n\tconst struct opt_out *output)\n{\n\tDEV_FETCH(cl_device_local_mem_type, val);\n\tif (!ret->err) {\n\t\tconst char * const *ar = (output->mode == CLINFO_HUMAN ?\n\t\t\tlmem_type_str : lmem_type_raw_str);\n\t\tbufcpy(&ret->str, 0, ar[val]);\n\t}\n\tret->value.lmemtype = val;\n}\n\n/* stringify a cl_device_topology_amd */\nvoid devtopo_str(struct device_info_ret *ret, const cl_device_topology_amd *devtopo)\n{\n\tswitch (devtopo->raw.type) {\n\tcase 0:\n\t\t/* leave empty */\n\t\tbreak;\n\tcase CL_DEVICE_TOPOLOGY_TYPE_PCIE_AMD:\n\t\tstrbuf_printf(&ret->str, \"PCI-E, %02x:%02x.%u\",\n\t\t\t(cl_uchar)(devtopo->pcie.bus),\n\t\t\tdevtopo->pcie.device, devtopo->pcie.function);\n\t\tbreak;\n\tdefault:\n\t\tstrbuf_printf(&ret->str, \"<unknown (%u): %u %u %u %u %u>\",\n\t\t\tdevtopo->raw.type,\n\t\t\tdevtopo->raw.data[0], devtopo->raw.data[1],\n\t\t\tdevtopo->raw.data[2],\n\t\t\tdevtopo->raw.data[3], devtopo->raw.data[4]);\n\t}\n}\n\nvoid\ndevice_info_devtopo_amd(struct device_info_ret *ret,\n\tconst struct info_loc *loc, const struct device_info_checks* UNUSED(chk),\n\tconst struct opt_out *output)\n{\n\tDEV_FETCH(cl_device_topology_amd, val);\n\t/* TODO how to do this in CLINFO_RAW mode */\n\tif (!ret->err) {\n\t\tdevtopo_str(ret, &val);\n\t}\n}\n\n/* we assemble a cl_device_topology_amd struct from the NVIDIA info */\nvoid\ndevice_info_devtopo_nv(struct device_info_ret *ret,\n\tconst struct info_loc *loc, const struct device_info_checks* UNUSED(chk),\n\tconst struct opt_out *output)\n{\n\tstruct info_loc loc2 = *loc;\n\tcl_device_topology_amd devtopo;\n\tDEV_FETCH(cl_uint, val); /* CL_DEVICE_PCI_BUS_ID_NV */\n\tif (!ret->err) {\n\t\tdevtopo.raw.type = CL_DEVICE_TOPOLOGY_TYPE_PCIE_AMD;\n\t\tdevtopo.pcie.bus = val & 0xff;\n\t\tRESET_LOC_PARAM(loc2, dev, CL_DEVICE_PCI_SLOT_ID_NV);\n\t\t_GET_VAL(ret, &loc2, val);\n\n\t\tif (!ret->err) {\n\t\t\tdevtopo.pcie.device = (val >> 3) & 0xff;\n\t\t\tdevtopo.pcie.function = val & 7;\n\t\t\tdevtopo_str(ret, &devtopo);\n\t\t}\n\t\tret->value.devtopo = devtopo;\n\t}\n}\n\n/* NVIDIA Compute Capability */\nvoid\ndevice_info_cc_nv(struct device_info_ret *ret,\n\tconst struct info_loc *loc, const struct device_info_checks* UNUSED(chk),\n\tconst struct opt_out *output)\n{\n\tstruct info_loc loc2 = *loc;\n\tcl_uint major = 0, minor = 0;\n\t_GET_VAL(ret, loc, major); /* MAJOR */\n\tif (!ret->err) {\n\t\tRESET_LOC_PARAM(loc2, dev, CL_DEVICE_COMPUTE_CAPABILITY_MINOR_NV);\n\t\t_GET_VAL(ret, &loc2, minor);\n\t\tif (!ret->err) {\n\t\t\tstrbuf_printf(&ret->str, \"%\" PRIu32 \".%\" PRIu32 \"\", major, minor);\n\t\t}\n\t}\n\tret->value.u32v.s[0] = major;\n\tret->value.u32v.s[1] = minor;\n}\n\n/* AMD GFXIP */\nvoid\ndevice_info_gfxip_amd(struct device_info_ret *ret,\n\tconst struct info_loc *loc, const struct device_info_checks* UNUSED(chk),\n\tconst struct opt_out *output)\n{\n\tstruct info_loc loc2 = *loc;\n\tcl_uint major = 0, minor = 0;\n\t_GET_VAL(ret, loc, major); /* MAJOR */\n\tif (!ret->err) {\n\t\tRESET_LOC_PARAM(loc2, dev, CL_DEVICE_GFXIP_MINOR_AMD);\n\t\t_GET_VAL(ret, &loc2, minor);\n\t\tif (!ret->err) {\n\t\t\tstrbuf_printf(&ret->str, \"%\" PRIu32 \".%\" PRIu32 \"\", major, minor);\n\t\t}\n\t}\n\tret->value.u32v.s[0] = major;\n\tret->value.u32v.s[1] = minor;\n}\n\n\n/* Device Partition, CLINFO_HUMAN header */\nvoid\ndevice_info_partition_header(struct device_info_ret *ret,\n\tconst struct info_loc *UNUSED(loc), const struct device_info_checks *chk,\n\tconst struct opt_out* UNUSED(output))\n{\n\tcl_bool is_12 = dev_is_12(chk);\n\tcl_bool has_fission = dev_has_fission(chk);\n\tsize_t szval = strbuf_printf(&ret->str, \"(%s%s%s%s)\",\n\t\t(is_12 ? core : empty_str),\n\t\t(is_12 && has_fission ? comma_str : empty_str),\n\t\tchk->has_fission,\n\t\t(!(is_12 || has_fission) ? na : empty_str));\n\n\tret->err = CL_SUCCESS;\n\n\tif (szval >= ret->str.sz)\n\t\ttrunc_strbuf(&ret->str);\n}\n\n/* Device partition properties */\nvoid\ndevice_info_partition_types(struct device_info_ret *ret,\n\tconst struct info_loc *loc, const struct device_info_checks* UNUSED(chk),\n\tconst struct opt_out *output)\n{\n\tsize_t numval = 0, szval = 0, cursor = 0, slen = 0;\n\tcl_device_partition_property *val = NULL;\n\tconst char * const *ptstr = (output->mode == CLINFO_HUMAN ?\n\t\tpartition_type_str : partition_type_raw_str);\n\n\tset_separator(output->mode == CLINFO_HUMAN ? comma_str : vbar_str);\n\n\tGET_VAL_ARRAY(ret, loc);\n\n\tszval = 0;\n\tif (!ret->err) {\n\t\tfor (cursor = 0; cursor < numval; ++cursor) {\n\t\t\tint str_idx = -1;\n\n\t\t\t/* add separator for values past the first */\n\t\t\tadd_separator(&ret->str, &szval);\n\n\t\t\tswitch (val[cursor]) {\n\t\t\tcase 0: str_idx = 0; break;\n\t\t\tcase CL_DEVICE_PARTITION_EQUALLY: str_idx = 1; break;\n\t\t\tcase CL_DEVICE_PARTITION_BY_COUNTS: str_idx = 2; break;\n\t\t\tcase CL_DEVICE_PARTITION_BY_AFFINITY_DOMAIN: str_idx = 3; break;\n\t\t\tcase CL_DEVICE_PARTITION_BY_NAMES_INTEL: str_idx = 4; break;\n\t\t\tdefault:\n\t\t\t\tszval += snprintf(ret->str.buf + szval, ret->str.sz - szval - 1, \"by <unknown> (%#\" PRIxPTR \")\", val[cursor]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (str_idx >= 0) {\n\t\t\t\t/* string length, minus _EXT */\n\t\t\t\tslen = strlen(ptstr[str_idx]);\n\t\t\t\tif (output->mode == CLINFO_RAW && str_idx > 0)\n\t\t\t\t\tslen -= 4;\n\t\t\t\tszval += bufcpy_len(&ret->str, szval, ptstr[str_idx], slen);\n\t\t\t}\n\t\t\tif (szval >= ret->str.sz) {\n\t\t\t\ttrunc_strbuf(&ret->str);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// TODO ret->value.??? = val\n\t}\n\tfree(val);\n}\n\nvoid\ndevice_info_partition_types_ext(struct device_info_ret *ret,\n\tconst struct info_loc *loc, const struct device_info_checks* UNUSED(chk),\n\tconst struct opt_out *output)\n{\n\tsize_t numval = 0, szval = 0, cursor = 0, slen = 0;\n\tcl_device_partition_property_ext *val = NULL;\n\tconst char * const *ptstr = (output->mode == CLINFO_HUMAN ?\n\t\tpartition_type_str : partition_type_raw_str);\n\n\tset_separator(output->mode == CLINFO_HUMAN ? comma_str : vbar_str);\n\n\tGET_VAL_ARRAY(ret, loc);\n\n\tszval = 0;\n\tif (!ret->err) {\n\t\tfor (cursor = 0; cursor < numval; ++cursor) {\n\t\t\tint str_idx = -1;\n\n\t\t\t/* add separator for values past the first */\n\t\t\tadd_separator(&ret->str, &szval);\n\n\t\t\tswitch (val[cursor]) {\n\t\t\tcase 0: str_idx = 0; break;\n\t\t\tcase CL_DEVICE_PARTITION_EQUALLY_EXT: str_idx = 1; break;\n\t\t\tcase CL_DEVICE_PARTITION_BY_COUNTS_EXT: str_idx = 2; break;\n\t\t\tcase CL_DEVICE_PARTITION_BY_AFFINITY_DOMAIN_EXT: str_idx = 3; break;\n\t\t\tcase CL_DEVICE_PARTITION_BY_NAMES_EXT: str_idx = 4; break;\n\t\t\tdefault:\n\t\t\t\tszval += snprintf(ret->str.buf + szval, ret->str.sz - szval - 1, \"by <unknown> (%#\" PRIx64 \")\", val[cursor]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (str_idx >= 0) {\n\t\t\t\t/* string length */\n\t\t\t\tslen = strlen(ptstr[str_idx]);\n\t\t\t\tstrncpy(ret->str.buf + szval, ptstr[str_idx], slen);\n\t\t\t\tszval += slen;\n\t\t\t}\n\t\t\tif (szval >= ret->str.sz) {\n\t\t\t\ttrunc_strbuf(&ret->str);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (szval < ret->str.sz)\n\t\t\tret->str.buf[szval] = '\\0';\n\t\t// TODO ret->value.??? = val\n\t}\n\tfree(val);\n}\n\n\n/* Device partition affinity domains */\nvoid\ndevice_info_partition_affinities(struct device_info_ret *ret,\n\tconst struct info_loc *loc, const struct device_info_checks* UNUSED(chk),\n\tconst struct opt_out *output)\n{\n\tDEV_FETCH(cl_device_affinity_domain, val);\n\tif (!ret->err && val) {\n\t\t/* iterate over affinity domain strings appending their textual form\n\t\t * to ret->str */\n\t\tsize_t szval = 0;\n\t\tcl_uint i = 0;\n\t\tconst char * const *affstr = (output->mode == CLINFO_HUMAN ?\n\t\t\taffinity_domain_str : affinity_domain_raw_str);\n\t\tset_separator(output->mode == CLINFO_HUMAN ? comma_str : vbar_str);\n\t\tfor (i = 0; i < affinity_domain_count; ++i) {\n\t\t\tcl_device_affinity_domain cur = (cl_device_affinity_domain)(1) << i;\n\t\t\tif (val & cur) {\n\t\t\t\t/* match: add separator if not first match */\n\t\t\t\tadd_separator(&ret->str, &szval);\n\t\t\t\tszval += bufcpy(&ret->str, szval, affstr[i]);\n\t\t\t}\n\t\t\tif (szval >= ret->str.sz)\n\t\t\t\tbreak;\n\t\t}\n\t\t/* check for extra bits */\n\t\tif (szval < ret->str.sz) {\n\t\t\tcl_device_affinity_domain known_mask = ((cl_device_affinity_domain)(1) << affinity_domain_count) - 1;\n\t\t\tcl_device_affinity_domain extra = val & ~known_mask;\n\t\t\tif (extra) {\n\t\t\t\tadd_separator(&ret->str, &szval);\n\t\t\t\tszval += snprintf(ret->str.buf + szval, ret->str.sz - szval - 1, \"%#\" PRIx64, extra);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid\ndevice_info_partition_affinities_ext(struct device_info_ret *ret,\n\tconst struct info_loc *loc, const struct device_info_checks* UNUSED(chk),\n\tconst struct opt_out *output)\n{\n\tsize_t numval = 0, szval = 0, cursor = 0, slen = 0;\n\tcl_device_partition_property_ext *val = NULL;\n\tconst char * const *ptstr = (output->mode == CLINFO_HUMAN ?\n\t\taffinity_domain_ext_str : affinity_domain_raw_ext_str);\n\n\tset_separator(output->mode == CLINFO_HUMAN ? comma_str : vbar_str);\n\n\tGET_VAL_ARRAY(ret, loc);\n\n\tszval = 0;\n\tif (!ret->err) {\n\t\tfor (cursor = 0; cursor < numval; ++cursor) {\n\t\t\tint str_idx = -1;\n\n\t\t\t/* add separator for values past the first */\n\t\t\tadd_separator(&ret->str, &szval);\n\n\t\t\tswitch (val[cursor]) {\n\t\t\tcase CL_AFFINITY_DOMAIN_NUMA_EXT: str_idx = 0; break;\n\t\t\tcase CL_AFFINITY_DOMAIN_L4_CACHE_EXT: str_idx = 1; break;\n\t\t\tcase CL_AFFINITY_DOMAIN_L3_CACHE_EXT: str_idx = 2; break;\n\t\t\tcase CL_AFFINITY_DOMAIN_L2_CACHE_EXT: str_idx = 3; break;\n\t\t\tcase CL_AFFINITY_DOMAIN_L1_CACHE_EXT: str_idx = 4; break;\n\t\t\tcase CL_AFFINITY_DOMAIN_NEXT_FISSIONABLE_EXT: str_idx = 5; break;\n\t\t\tdefault:\n\t\t\t\tszval += snprintf(ret->str.buf + szval, ret->str.sz - szval - 1, \"<unknown> (%#\" PRIx64 \")\", val[cursor]);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (str_idx >= 0) {\n\t\t\t\t/* string length */\n\t\t\t\tconst char *str = ptstr[str_idx];\n\t\t\t\tslen = strlen(str);\n\t\t\t\tstrncpy(ret->str.buf + szval, str, slen);\n\t\t\t\tszval += slen;\n\t\t\t}\n\t\t\tif (szval >= ret->str.sz) {\n\t\t\t\ttrunc_strbuf(&ret->str);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tret->str.buf[szval] = '\\0';\n\t\t// TODO: ret->value.??? = val\n\t}\n\tfree(val);\n}\n\n/* Preferred / native vector widths */\nvoid\ndevice_info_vecwidth(struct device_info_ret *ret,\n\tconst struct info_loc *loc, const struct device_info_checks *chk,\n\tconst struct opt_out *output)\n{\n\tstruct info_loc loc2 = *loc;\n\tcl_uint preferred = 0, native = 0;\n\t_GET_VAL(ret, loc, preferred);\n\tif (!ret->err) {\n\t\t/* we get called with PREFERRED, NATIVE is at +0x30 offset, except for HALF,\n\t\t * which is at +0x08 */\n\t\tloc2.param.dev +=\n\t\t\t(loc2.param.dev == CL_DEVICE_PREFERRED_VECTOR_WIDTH_HALF ? 0x08 : 0x30);\n\t\t/* TODO update loc2.sname */\n\t\t_GET_VAL(ret, &loc2, native);\n\n\t\tif (!ret->err) {\n\t\t\tsize_t szval = 0;\n\t\t\tconst char *ext = (loc2.param.dev == CL_DEVICE_NATIVE_VECTOR_WIDTH_HALF ?\n\t\t\t\tchk->has_half : (loc2.param.dev == CL_DEVICE_NATIVE_VECTOR_WIDTH_DOUBLE ?\n\t\t\t\tchk->has_double : NULL));\n\t\t\tszval = strbuf_printf(&ret->str, \"%8u / %-8u\", preferred, native);\n\t\t\tif (ext)\n\t\t\t\tsprintf(ret->str.buf + szval, \" (%s)\", *ext ? ext : na);\n\t\t}\n\t}\n\tret->value.u32v.s[0] = preferred;\n\tret->value.u32v.s[1] = native;\n}\n\n/* Floating-point configurations */\nvoid\ndevice_info_fpconf(struct device_info_ret *ret,\n\tconst struct info_loc *loc, const struct device_info_checks *chk,\n\tconst struct opt_out *output)\n{\n\t/* When in HUMAN output, we are called unconditionally,\n\t * so we have to do some manual checks ourselves */\n\tconst cl_bool get_it = (output->mode != CLINFO_HUMAN) ||\n\t\t(loc->param.dev == CL_DEVICE_SINGLE_FP_CONFIG) ||\n\t\t(loc->param.dev == CL_DEVICE_HALF_FP_CONFIG && dev_has_half(chk)) ||\n\t\t(loc->param.dev == CL_DEVICE_DOUBLE_FP_CONFIG && dev_has_double(chk));\n\n\tDEV_FETCH(cl_device_fp_config, val);\n\t/* Sanitize! */\n\tif (ret->err && !get_it) {\n\t\tret->err = CL_SUCCESS;\n\t\tval = 0;\n\t}\n\n\n\tif (!ret->err) {\n\t\tsize_t szval = 0;\n\t\tcl_uint i = 0;\n\t\tconst char * const *fpstr = (output->mode == CLINFO_HUMAN ?\n\t\t\tfp_conf_str : fp_conf_raw_str);\n\t\tset_separator(vbar_str);\n\t\tif (output->mode == CLINFO_HUMAN) {\n\t\t\tconst char *why = na;\n\t\t\tswitch (loc->param.dev) {\n\t\t\tcase CL_DEVICE_HALF_FP_CONFIG:\n\t\t\t\tif (get_it)\n\t\t\t\t\twhy = chk->has_half;\n\t\t\t\tbreak;\n\t\t\tcase CL_DEVICE_SINGLE_FP_CONFIG:\n\t\t\t\twhy = core;\n\t\t\t\tbreak;\n\t\t\tcase CL_DEVICE_DOUBLE_FP_CONFIG:\n\t\t\t\tif (get_it)\n\t\t\t\t\twhy = chk->has_double;\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t/* \"this can't happen\" (unless OpenCL starts supporting _other_ floating-point formats, maybe) */\n\t\t\t\tfprintf(stderr, \"unsupported floating-point configuration parameter %s\\n\", loc->pname);\n\t\t\t}\n\t\t\t/* show 'why' it's being shown */\n\t\t\tszval += strbuf_printf(&ret->str, \"(%s)\", why);\n\t\t}\n\t\tif (get_it) {\n\t\t\tsize_t num_flags = fp_conf_count;\n\t\t\t/* The last flag, CL_FP_CORRECTLY_ROUNDED_DIVIDE_SQRT is only considered\n\t\t\t * in the single-precision case. half and double don't consider it,\n\t\t\t * so we skip it altogether */\n\t\t\tif (loc->param.dev != CL_DEVICE_SINGLE_FP_CONFIG)\n\t\t\t\tnum_flags -= 1;\n\n\t\t\tfor (i = 0; i < num_flags; ++i) {\n\t\t\t\tcl_device_fp_config cur = (cl_device_fp_config)(1) << i;\n\t\t\t\tif (output->mode == CLINFO_HUMAN) {\n\t\t\t\t\tszval += sprintf(ret->str.buf + szval, \"\\n%s\" I2_STR \"%s\",\n\t\t\t\t\t\tline_pfx, fpstr[i], bool_str[!!(val & cur)]);\n\t\t\t\t} else if (val & cur) {\n\t\t\t\t\tadd_separator(&ret->str, &szval);\n\t\t\t\t\tszval += bufcpy(&ret->str, szval, fpstr[i]);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* Queue properties */\nvoid\ndevice_info_qprop(struct device_info_ret *ret,\n\tconst struct info_loc *loc, const struct device_info_checks *chk,\n\tconst struct opt_out *output)\n{\n\tDEV_FETCH(cl_command_queue_properties, val);\n\tif (!ret->err) {\n\t\tsize_t szval = 0;\n\t\tcl_uint i = 0;\n\t\tconst char * const *qpstr = (output->mode == CLINFO_HUMAN ?\n\t\t\tqueue_prop_str : queue_prop_raw_str);\n\t\tset_separator(vbar_str);\n\t\tfor (i = 0; i < queue_prop_count; ++i) {\n\t\t\tcl_command_queue_properties cur = (cl_command_queue_properties)(1) << i;\n\t\t\tif (output->mode == CLINFO_HUMAN) {\n\t\t\t\tszval += sprintf(ret->str.buf + szval, \"\\n%s\" I2_STR \"%s\",\n\t\t\t\t\tline_pfx, qpstr[i], bool_str[!!(val & cur)]);\n\t\t\t} else if (val & cur) {\n\t\t\t\tadd_separator(&ret->str, &szval);\n\t\t\t\tszval += bufcpy(&ret->str, szval, qpstr[i]);\n\t\t\t}\n\t\t}\n\t\tif (output->mode == CLINFO_HUMAN && loc->param.dev == CL_DEVICE_QUEUE_PROPERTIES &&\n\t\t\tdev_has_intel_local_thread(chk))\n\t\t\tsprintf(ret->str.buf + szval, \"\\n%s\" I2_STR \"%s\",\n\t\t\t\tline_pfx, \"Local thread execution (Intel)\", bool_str[CL_TRUE]);\n\t}\n}\n\n/* Execution capbilities */\nvoid\ndevice_info_execap(struct device_info_ret *ret,\n\tconst struct info_loc *loc, const struct device_info_checks* UNUSED(chk),\n\tconst struct opt_out *output)\n{\n\tDEV_FETCH(cl_device_exec_capabilities, val);\n\tif (!ret->err) {\n\t\tsize_t szval = 0;\n\t\tcl_uint i = 0;\n\t\tconst char * const *qpstr = (output->mode == CLINFO_HUMAN ?\n\t\t\texecap_str : execap_raw_str);\n\t\tset_separator(vbar_str);\n\t\tfor (i = 0; i < execap_count; ++i) {\n\t\t\tcl_device_exec_capabilities cur = (cl_device_exec_capabilities)(1) << i;\n\t\t\tif (output->mode == CLINFO_HUMAN) {\n\t\t\t\tszval += sprintf(ret->str.buf + szval, \"\\n%s\" I2_STR \"%s\",\n\t\t\t\t\tline_pfx, qpstr[i], bool_str[!!(val & cur)]);\n\t\t\t} else if (val & cur) {\n\t\t\t\tadd_separator(&ret->str, &szval);\n\t\t\t\tszval += bufcpy(&ret->str, szval, qpstr[i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* Arch bits and endianness (HUMAN) */\nvoid\ndevice_info_arch(struct device_info_ret *ret,\n\tconst struct info_loc *loc, const struct device_info_checks* UNUSED(chk),\n\tconst struct opt_out *output)\n{\n\tDEV_FETCH(cl_uint, bits);\n\tstruct info_loc loc2 = *loc;\n\tRESET_LOC_PARAM(loc2, dev, CL_DEVICE_ENDIAN_LITTLE);\n\n\tif (!ret->err) {\n\t\tDEV_FETCH_LOC(cl_bool, val, &loc2);\n\t\tif (!ret->err) {\n\t\t\tstrbuf_printf(&ret->str, \"%\" PRIu32 \", %s\", bits, endian_str[val]);\n\t\t}\n\t}\n}\n\n/* SVM capabilities */\nvoid\ndevice_info_svm_cap(struct device_info_ret *ret,\n\tconst struct info_loc *loc, const struct device_info_checks *chk,\n\tconst struct opt_out *output)\n{\n\tconst cl_bool is_20 = dev_is_20(chk);\n\tconst cl_bool checking_core = (loc->param.dev == CL_DEVICE_SVM_CAPABILITIES);\n\tconst cl_bool has_amd_svm = (checking_core && dev_has_amd_svm(chk));\n\tDEV_FETCH(cl_device_svm_capabilities, val);\n\n\tif (!ret->err) {\n\t\tsize_t szval = 0;\n\t\tcl_uint i = 0;\n\t\tconst char * const *scstr = (output->mode == CLINFO_HUMAN ?\n\t\t\tsvm_cap_str : svm_cap_raw_str);\n\t\tset_separator(vbar_str);\n\t\tif (output->mode == CLINFO_HUMAN && checking_core) {\n\t\t\t/* show 'why' it's being shown */\n\t\t\tszval += strbuf_printf(&ret->str, \"(%s%s%s)\",\n\t\t\t\t(is_20 ? core : empty_str),\n\t\t\t\t(is_20 && has_amd_svm ? comma_str : empty_str),\n\t\t\t\tchk->has_amd_svm);\n\t\t}\n\t\tfor (i = 0; i < svm_cap_count; ++i) {\n\t\t\tcl_device_svm_capabilities cur = (cl_device_svm_capabilities)(1) << i;\n\t\t\tif (output->mode == CLINFO_HUMAN) {\n\t\t\t\tszval += sprintf(ret->str.buf + szval, \"\\n%s\" I2_STR \"%s\",\n\t\t\t\t\tline_pfx, scstr[i], bool_str[!!(val & cur)]);\n\t\t\t} else if (val & cur) {\n\t\t\t\tadd_separator(&ret->str, &szval);\n\t\t\t\tszval += bufcpy(&ret->str, szval, scstr[i]);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/* Device terminate capability */\nvoid\ndevice_info_terminate_capability(struct device_info_ret *ret,\n\tconst struct info_loc *loc, const struct device_info_checks* UNUSED(chk),\n\tconst struct opt_out *output)\n{\n\tDEV_FETCH(cl_device_terminate_capability_khr, val);\n\tif (!ret->err && val) {\n\t\t/* iterate over terminate capability strings appending their textual form\n\t\t * to ret->str */\n\t\tsize_t szval = 0;\n\t\tcl_uint i = 0;\n\t\tconst char * const *capstr = (output->mode == CLINFO_HUMAN ?\n\t\t\tterminate_capability_str : terminate_capability_raw_str);\n\t\tset_separator(output->mode == CLINFO_HUMAN ? comma_str : vbar_str);\n\t\tfor (i = 0; i < terminate_capability_count; ++i) {\n\t\t\tcl_device_terminate_capability_khr cur = (cl_device_terminate_capability_khr)(1) << i;\n\t\t\tif (val & cur) {\n\t\t\t\t/* match: add separator if not first match */\n\t\t\t\tadd_separator(&ret->str, &szval);\n\t\t\t\tszval += bufcpy(&ret->str, szval, capstr[i]);\n\t\t\t}\n\t\t\tif (szval >= ret->str.sz)\n\t\t\t\tbreak;\n\t\t}\n\t\t/* check for extra bits */\n\t\tif (szval < ret->str.sz) {\n\t\t\tcl_device_terminate_capability_khr known_mask = ((cl_device_terminate_capability_khr)(1) << terminate_capability_count) - 1;\n\t\t\tcl_device_terminate_capability_khr extra = val & ~known_mask;\n\t\t\tif (extra) {\n\t\t\t\tadd_separator(&ret->str, &szval);\n\t\t\t\tszval += snprintf(ret->str.buf + szval, ret->str.sz - szval - 1, \"%#\" PRIx64, extra);\n\t\t\t}\n\t\t}\n\t}\n}\n\nvoid\ndevice_info_p2p_dev_list(struct device_info_ret *ret,\n\tconst struct info_loc *loc, const struct device_info_checks* UNUSED(chk),\n\tconst struct opt_out* UNUSED(output))\n{\n\tcl_device_id *val = NULL;\n\tsize_t szval = 0, numval = 0;\n\tGET_VAL_ARRAY(ret, loc);\n\tif (!ret->err) {\n\t\tsize_t cursor = 0;\n\t\tszval = 0;\n\t\tfor (cursor= 0; cursor < numval; ++cursor) {\n\t\t\tif (szval > 0) {\n\t\t\t\tret->str.buf[szval] = ' ';\n\t\t\t\t++szval;\n\t\t\t}\n\t\t\tszval += snprintf(ret->str.buf + szval, ret->str.sz - szval - 1, \"%p\", (void*)val[cursor]);\n\t\t}\n\t\t// TODO: ret->value.??? = val;\n\t}\n\tfree(val);\n}\n\nvoid\ndevice_info_interop_list(struct device_info_ret *ret,\n\tconst struct info_loc *loc, const struct device_info_checks* UNUSED(chk),\n\tconst struct opt_out *output)\n{\n\tcl_uint *val = NULL;\n\tsize_t szval = 0, numval = 0;\n\tGET_VAL_ARRAY(ret, loc);\n\tif (!ret->err) {\n\t\tsize_t cursor = 0;\n\t\tconst cl_interop_name *interop_name_end = cl_interop_names + num_known_interops;\n\t\tcl_uint human_raw = output->mode - CLINFO_HUMAN;\n\t\tconst char *groupsep = (output->mode == CLINFO_HUMAN ? comma_str : vbar_str);\n\t\tcl_bool first = CL_TRUE;\n\t\tszval = 0;\n\t\tfor (cursor = 0; cursor < numval; ++cursor) {\n\t\t\tcl_uint current = val[cursor];\n\t\t\tif (!current && cursor < numval - 1) {\n\t\t\t\t/* A null value is used as group terminator, but we only print it\n\t\t\t\t * if it's not the final one\n\t\t\t\t */\n\t\t\t\tszval += snprintf(ret->str.buf + szval, ret->str.sz - szval - 1, \"%s\", groupsep);\n\t\t\t\tfirst = CL_TRUE;\n\t\t\t}\n\t\t\tif (current) {\n\t\t\t\tcl_bool found = CL_FALSE;\n\t\t\t\tconst cl_interop_name *n = cl_interop_names;\n\n\t\t\t\tif (!first) {\n\t\t\t\t\tret->str.buf[szval] = ' ';\n\t\t\t\t\t++szval;\n\t\t\t\t}\n\n\t\t\t\twhile (n < interop_name_end) {\n\t\t\t\t\tif (current >= n->from && current <= n->to) {\n\t\t\t\t\t\tfound = CL_TRUE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t++n;\n\t\t\t\t}\n\t\t\t\tif (found) {\n\t\t\t\t\tcl_uint i = current - n->from;\n\t\t\t\t\tszval += snprintf(ret->str.buf + szval, ret->str.sz - szval - 1, \"%s\", n->value[i][human_raw]);\n\t\t\t\t} else {\n\t\t\t\t\tszval += snprintf(ret->str.buf + szval, ret->str.sz - szval - 1, \"%#\" PRIx32, val[cursor]);\n\t\t\t\t}\n\t\t\t\tfirst = CL_FALSE;\n\t\t\t}\n\t\t\tif (szval >= ret->str.sz) {\n\t\t\t\ttrunc_strbuf(&ret->str);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\t// TODO: ret->value.??? = val;\n\t}\n\tfree(val);\n}\n\n\n/*\n * Device info traits\n */\n\n/* A CL_FALSE param means \"just print pname\" */\n\nstruct device_info_traits {\n\tenum output_modes output_mode;\n\tcl_device_info param; // CL_DEVICE_*\n\tconst char *sname; // \"CL_DEVICE_*\"\n\tconst char *pname; // \"Device *\"\n\tconst char *sfx; // suffix for the output in non-raw mode\n\t/* pointer to function that retrieves the parameter */\n\tvoid (*show_func)(struct device_info_ret *,\n\t\tconst struct info_loc *, const struct device_info_checks *,\n\t\tconst struct opt_out *);\n\t/* pointer to function that checks if the parameter should be retrieved */\n\tcl_bool (*check_func)(const struct device_info_checks *);\n};\n\n#define DINFO_SFX(symbol, name, sfx, typ) symbol, #symbol, name, sfx, device_info_##typ\n#define DINFO(symbol, name, typ) symbol, #symbol, name, NULL, device_info_##typ\n\nstruct device_info_traits dinfo_traits[] = {\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_NAME, \"Device Name\", str), NULL },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_VENDOR, \"Device Vendor\", str), NULL },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_VENDOR_ID, \"Device Vendor ID\", hex), NULL },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_VERSION, \"Device Version\", str), NULL },\n\t{ CLINFO_BOTH, DINFO(CL_DRIVER_VERSION, \"Driver Version\", str), NULL },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_OPENCL_C_VERSION, \"Device OpenCL C Version\", str), NULL },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_EXTENSIONS, \"Device Extensions\", str), NULL },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_TYPE, \"Device Type\", devtype), NULL },\n\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_BOARD_NAME_AMD, \"Device Board Name (AMD)\", str), dev_has_amd },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_TOPOLOGY_AMD, \"Device Topology (AMD)\", devtopo_amd), dev_has_amd },\n\n\t/* Device Topology (NV) is multipart, so different for HUMAN and RAW */\n\t{ CLINFO_HUMAN, DINFO(CL_DEVICE_PCI_BUS_ID_NV, \"Device Topology (NV)\", devtopo_nv), dev_has_nv },\n\t{ CLINFO_RAW, DINFO(CL_DEVICE_PCI_BUS_ID_NV, \"Device PCI bus (NV)\", int), dev_has_nv },\n\t{ CLINFO_RAW, DINFO(CL_DEVICE_PCI_SLOT_ID_NV, \"Device PCI slot (NV)\", int), dev_has_nv },\n\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_PROFILE, \"Device Profile\", str), NULL },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_AVAILABLE, \"Device Available\", bool), NULL },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_COMPILER_AVAILABLE, \"Compiler Available\", bool), NULL },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_LINKER_AVAILABLE, \"Linker Available\", bool), dev_is_12 },\n\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_MAX_COMPUTE_UNITS, \"Max compute units\", int), NULL },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_SIMD_PER_COMPUTE_UNIT_AMD, \"SIMD per compute unit (AMD)\", int), dev_is_gpu_amd },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_SIMD_WIDTH_AMD, \"SIMD width (AMD)\", int), dev_is_gpu_amd },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_SIMD_INSTRUCTION_WIDTH_AMD, \"SIMD instruction width (AMD)\", int), dev_is_gpu_amd },\n\t{ CLINFO_BOTH, DINFO_SFX(CL_DEVICE_MAX_CLOCK_FREQUENCY, \"Max clock frequency\", \"MHz\", int), NULL },\n\n\t/* Device Compute Capability (NV) is multipart, so different for HUMAN and RAW */\n\t{ CLINFO_HUMAN, DINFO(CL_DEVICE_COMPUTE_CAPABILITY_MAJOR_NV, \"Compute Capability (NV)\", cc_nv), dev_has_nv },\n\t{ CLINFO_RAW, DINFO(CL_DEVICE_COMPUTE_CAPABILITY_MAJOR_NV, INDENT \"Compute Capability Major (NV)\", int), dev_has_nv },\n\t{ CLINFO_RAW, DINFO(CL_DEVICE_COMPUTE_CAPABILITY_MINOR_NV, INDENT \"Compute Capability Minor (NV)\", int), dev_has_nv },\n\n\t/* GFXIP (AMD) is multipart, so different for HUMAN and RAW */\n\t/* TODO: find a better human-friendly name than GFXIP; v3 of the cl_amd_device_attribute_query\n\t * extension specification calls it \u201ccore engine GFXIP\u201d, which honestly is not better than\n\t * our name choice. */\n\t{ CLINFO_HUMAN, DINFO(CL_DEVICE_GFXIP_MAJOR_AMD, \"Graphics IP (AMD)\", gfxip_amd), dev_is_gpu_amd },\n\t{ CLINFO_RAW, DINFO(CL_DEVICE_GFXIP_MAJOR_AMD, INDENT \"Graphics IP MAJOR (AMD)\", int), dev_is_gpu_amd },\n\t{ CLINFO_RAW, DINFO(CL_DEVICE_GFXIP_MINOR_AMD, INDENT \"Graphics IP MINOR (AMD)\", int), dev_is_gpu_amd },\n\n\t{ CLINFO_BOTH, DINFO_SFX(CL_DEVICE_CORE_TEMPERATURE_ALTERA, \"Core Temperature (Altera)\", \" C\", int), dev_has_altera_dev_temp },\n\n\t/* Device partition support: summary is only presented in HUMAN case */\n\t{ CLINFO_HUMAN, DINFO(CL_DEVICE_PARTITION_MAX_SUB_DEVICES, \"Device Partition\", partition_header), dev_has_partition },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_PARTITION_MAX_SUB_DEVICES, INDENT \"Max number of sub-devices\", int), dev_is_12 },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_PARTITION_PROPERTIES, INDENT \"Supported partition types\", partition_types), dev_is_12 },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_PARTITION_AFFINITY_DOMAIN, INDENT \"Supported affinity domains\", partition_affinities), dev_is_12 },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_PARTITION_TYPES_EXT, INDENT \"Supported partition types (ext)\", partition_types_ext), dev_has_fission },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_AFFINITY_DOMAINS_EXT, INDENT \"Supported affinity domains (ext)\", partition_affinities_ext), dev_has_fission },\n\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS, \"Max work item dimensions\", int), NULL },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_MAX_WORK_ITEM_SIZES, \"Max work item sizes\", szptr_times), NULL },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_MAX_WORK_GROUP_SIZE, \"Max work group size\", sz), NULL },\n\n\t/* cl_amd_device_attribute_query v4 */\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_PREFERRED_WORK_GROUP_SIZE_AMD, \"Preferred work group size (AMD)\", sz), dev_has_amd_v4 },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_MAX_WORK_GROUP_SIZE_AMD, \"Max work group size (AMD)\", sz), dev_has_amd_v4 },\n\n\t{ CLINFO_BOTH, DINFO(CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE, \"Preferred work group size multiple\", wg), dev_has_compiler },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_WARP_SIZE_NV, \"Warp size (NV)\", int), dev_has_nv },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_WAVEFRONT_WIDTH_AMD, \"Wavefront width (AMD)\", int), dev_is_gpu_amd },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_MAX_NUM_SUB_GROUPS, \"Max sub-groups per work group\", int), dev_is_21 },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_MAX_NAMED_BARRIER_COUNT_KHR, \"Max named sub-group barriers\", int), dev_has_subgroup_named_barrier },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_SUB_GROUP_SIZES_INTEL, \"Sub-group sizes (Intel)\", szptr_comma), dev_has_intel_required_subgroup_size },\n\n\t/* Preferred/native vector widths: header is only presented in HUMAN case, that also pairs\n\t * PREFERRED and NATIVE in a single line */\n#define DINFO_VECWIDTH(Type, type) \\\n\t{ CLINFO_HUMAN, DINFO(CL_DEVICE_PREFERRED_VECTOR_WIDTH_##Type, INDENT #type, vecwidth), NULL }, \\\n\t{ CLINFO_RAW, DINFO(CL_DEVICE_PREFERRED_VECTOR_WIDTH_##Type, INDENT #type, int), NULL }, \\\n\t{ CLINFO_RAW, DINFO(CL_DEVICE_NATIVE_VECTOR_WIDTH_##Type, INDENT #type, int), NULL }\n\n\t{ CLINFO_HUMAN, DINFO(CL_FALSE, \"Preferred / native vector sizes\", str), NULL },\n\tDINFO_VECWIDTH(CHAR, char),\n\tDINFO_VECWIDTH(SHORT, short),\n\tDINFO_VECWIDTH(INT, int),\n\tDINFO_VECWIDTH(LONG, long),\n\tDINFO_VECWIDTH(HALF, half),\n\tDINFO_VECWIDTH(FLOAT, float),\n\tDINFO_VECWIDTH(DOUBLE, double),\n\n\t/* Floating point configurations */\n#define DINFO_FPCONF(Type, type, cond) \\\n\t{ CLINFO_HUMAN, DINFO(CL_DEVICE_##Type##_FP_CONFIG, #type \"-precision Floating-point support\", fpconf), NULL }, \\\n\t{ CLINFO_RAW, DINFO(CL_DEVICE_##Type##_FP_CONFIG, #type \"-precision Floating-point support\", fpconf), cond }\n\n\tDINFO_FPCONF(HALF, Half, dev_has_half),\n\tDINFO_FPCONF(SINGLE, Single, NULL),\n\tDINFO_FPCONF(DOUBLE, Double, dev_has_double),\n\n\t/* Address bits and endianness are written together for HUMAN, separate for RAW */\n\t{ CLINFO_HUMAN, DINFO(CL_DEVICE_ADDRESS_BITS, \"Address bits\", arch), NULL },\n\t{ CLINFO_RAW, DINFO(CL_DEVICE_ADDRESS_BITS, \"Address bits\", int), NULL },\n\t{ CLINFO_RAW, DINFO(CL_DEVICE_ENDIAN_LITTLE, \"Little Endian\", bool), NULL },\n\n\t/* Global memory */\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_GLOBAL_MEM_SIZE, \"Global memory size\", mem), NULL },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_GLOBAL_FREE_MEMORY_AMD, \"Global free memory (AMD)\", free_mem_amd), dev_is_gpu_amd },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_GLOBAL_MEM_CHANNELS_AMD, \"Global memory channels (AMD)\", int), dev_is_gpu_amd },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_GLOBAL_MEM_CHANNEL_BANKS_AMD, \"Global memory banks per channel (AMD)\", int), dev_is_gpu_amd },\n\t{ CLINFO_BOTH, DINFO_SFX(CL_DEVICE_GLOBAL_MEM_CHANNEL_BANK_WIDTH_AMD, \"Global memory bank width (AMD)\", bytes_str, int), dev_is_gpu_amd },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_ERROR_CORRECTION_SUPPORT, \"Error Correction support\", bool), NULL },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_MAX_MEM_ALLOC_SIZE, \"Max memory allocation\", mem), NULL },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_HOST_UNIFIED_MEMORY, \"Unified memory for Host and Device\", bool), NULL },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_INTEGRATED_MEMORY_NV, \"Integrated memory (NV)\", bool), dev_has_nv },\n\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_SVM_CAPABILITIES, \"Shared Virtual Memory (SVM) capabilities\", svm_cap), dev_has_svm },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_SVM_CAPABILITIES_ARM, \"Shared Virtual Memory (SVM) capabilities (ARM)\", svm_cap), dev_has_arm_svm },\n\n\t/* Alignment */\n\t{ CLINFO_BOTH, DINFO_SFX(CL_DEVICE_MIN_DATA_TYPE_ALIGN_SIZE, \"Minimum alignment for any data type\", bytes_str, int), NULL },\n\t{ CLINFO_HUMAN, DINFO(CL_DEVICE_MEM_BASE_ADDR_ALIGN, \"Alignment of base address\", bits), NULL },\n\t{ CLINFO_RAW, DINFO(CL_DEVICE_MEM_BASE_ADDR_ALIGN, \"Alignment of base address\", int), NULL },\n\n\t{ CLINFO_BOTH, DINFO_SFX(CL_DEVICE_PAGE_SIZE_QCOM, \"Page size (QCOM)\", bytes_str, sz), dev_has_qcom_ext_host_ptr },\n\t{ CLINFO_BOTH, DINFO_SFX(CL_DEVICE_EXT_MEM_PADDING_IN_BYTES_QCOM, \"External memory padding (QCOM)\", bytes_str, sz), dev_has_qcom_ext_host_ptr },\n\n\t/* Atomics alignment, with HUMAN-only header */\n\t{ CLINFO_HUMAN, DINFO(CL_FALSE, \"Preferred alignment for atomics\", str), dev_is_20 },\n\t{ CLINFO_BOTH, DINFO_SFX(CL_DEVICE_PREFERRED_PLATFORM_ATOMIC_ALIGNMENT, INDENT \"SVM\", bytes_str, int), dev_is_20 },\n\t{ CLINFO_BOTH, DINFO_SFX(CL_DEVICE_PREFERRED_GLOBAL_ATOMIC_ALIGNMENT, INDENT \"Global\", bytes_str, int), dev_is_20 },\n\t{ CLINFO_BOTH, DINFO_SFX(CL_DEVICE_PREFERRED_LOCAL_ATOMIC_ALIGNMENT, INDENT \"Local\", bytes_str, int), dev_is_20 },\n\n\t/* Global variables. TODO some 1.2 devices respond to this too */\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_MAX_GLOBAL_VARIABLE_SIZE, \"Max size for global variable\", mem), dev_is_20 },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_GLOBAL_VARIABLE_PREFERRED_TOTAL_SIZE, \"Preferred total size of global vars\", mem), dev_is_20 },\n\n\t/* Global memory cache */\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_GLOBAL_MEM_CACHE_TYPE, \"Global Memory cache type\", cachetype), NULL },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_GLOBAL_MEM_CACHE_SIZE, \"Global Memory cache size\", mem), dev_has_cache },\n\t{ CLINFO_BOTH, DINFO_SFX(CL_DEVICE_GLOBAL_MEM_CACHELINE_SIZE, \"Global Memory cache line size\", \" bytes\", int), dev_has_cache },\n\n\t/* Image support */\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_IMAGE_SUPPORT, \"Image support\", bool), NULL },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_MAX_SAMPLERS, INDENT \"Max number of samplers per kernel\", int), dev_has_images },\n\t{ CLINFO_BOTH, DINFO_SFX(CL_DEVICE_IMAGE_MAX_BUFFER_SIZE, INDENT \"Max size for 1D images from buffer\", pixels_str, sz), dev_has_images_12 },\n\t{ CLINFO_BOTH, DINFO_SFX(CL_DEVICE_IMAGE_MAX_ARRAY_SIZE, INDENT \"Max 1D or 2D image array size\", images_str, sz), dev_has_images_12 },\n\t{ CLINFO_BOTH, DINFO_SFX(CL_DEVICE_IMAGE_BASE_ADDRESS_ALIGNMENT, INDENT \"Base address alignment for 2D image buffers\", bytes_str, sz), dev_has_image2d_buffer },\n\t{ CLINFO_BOTH, DINFO_SFX(CL_DEVICE_IMAGE_PITCH_ALIGNMENT, INDENT \"Pitch alignment for 2D image buffers\", pixels_str, sz), dev_has_image2d_buffer },\n\n\t/* Image dimensions are split for RAW, combined for HUMAN */\n\t{ CLINFO_HUMAN, DINFO_SFX(CL_DEVICE_IMAGE2D_MAX_HEIGHT, INDENT \"Max 2D image size\",  pixels_str, img_sz_2d), dev_has_images },\n\t{ CLINFO_RAW, DINFO(CL_DEVICE_IMAGE2D_MAX_HEIGHT, INDENT \"Max 2D image height\",  sz), dev_has_images },\n\t{ CLINFO_RAW, DINFO(CL_DEVICE_IMAGE2D_MAX_WIDTH, INDENT \"Max 2D image width\",  sz), dev_has_images },\n\t{ CLINFO_HUMAN, DINFO_SFX(CL_DEVICE_PLANAR_YUV_MAX_HEIGHT_INTEL, INDENT \"Max planar YUV image size\",  pixels_str, img_sz_2d), dev_has_intel_planar_yuv },\n\t{ CLINFO_RAW, DINFO(CL_DEVICE_PLANAR_YUV_MAX_HEIGHT_INTEL, INDENT \"Max planar YUV image height\",  sz), dev_has_intel_planar_yuv },\n\t{ CLINFO_RAW, DINFO(CL_DEVICE_PLANAR_YUV_MAX_WIDTH_INTEL, INDENT \"Max planar YUV image width\",  sz), dev_has_intel_planar_yuv },\n\t{ CLINFO_HUMAN, DINFO_SFX(CL_DEVICE_IMAGE3D_MAX_HEIGHT, INDENT \"Max 3D image size\",  pixels_str, img_sz_3d), dev_has_images },\n\t{ CLINFO_RAW, DINFO(CL_DEVICE_IMAGE3D_MAX_HEIGHT, INDENT \"Max 3D image height\",  sz), dev_has_images },\n\t{ CLINFO_RAW, DINFO(CL_DEVICE_IMAGE3D_MAX_WIDTH, INDENT \"Max 3D image width\",  sz), dev_has_images },\n\t{ CLINFO_RAW, DINFO(CL_DEVICE_IMAGE3D_MAX_DEPTH, INDENT \"Max 3D image depth\",  sz), dev_has_images },\n\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_MAX_READ_IMAGE_ARGS, INDENT \"Max number of read image args\", int), dev_has_images },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_MAX_WRITE_IMAGE_ARGS, INDENT \"Max number of write image args\", int), dev_has_images },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_MAX_READ_WRITE_IMAGE_ARGS, INDENT \"Max number of read/write image args\", int), dev_has_images_20 },\n\n\t/* Pipes */\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_MAX_PIPE_ARGS, \"Max number of pipe args\", int), dev_is_20 },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_PIPE_MAX_ACTIVE_RESERVATIONS, \"Max active pipe reservations\", int), dev_is_20 },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_PIPE_MAX_PACKET_SIZE, \"Max pipe packet size\", mem_int), dev_is_20 },\n\n\t/* Local memory */\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_LOCAL_MEM_TYPE, \"Local memory type\", lmemtype), NULL },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_LOCAL_MEM_SIZE, \"Local memory size\", mem), dev_has_lmem },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_LOCAL_MEM_SIZE_PER_COMPUTE_UNIT_AMD, \"Local memory syze per CU (AMD)\", mem), dev_is_gpu_amd },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_LOCAL_MEM_BANKS_AMD, \"Local memory banks (AMD)\", int), dev_is_gpu_amd },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_REGISTERS_PER_BLOCK_NV, \"Registers per block (NV)\", int), dev_has_nv },\n\n\t/* Constant memory */\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_MAX_CONSTANT_ARGS, \"Max number of constant args\", int), NULL },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE, \"Max constant buffer size\", mem), NULL },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_PREFERRED_CONSTANT_BUFFER_SIZE_AMD, \"Preferred constant buffer size (AMD)\", mem_sz), dev_has_amd_v4 },\n\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_MAX_PARAMETER_SIZE, \"Max size of kernel argument\", mem), NULL },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_MAX_ATOMIC_COUNTERS_EXT, \"Max number of atomic counters\", sz), dev_has_atomic_counters },\n\n\t/* Queue properties */\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_QUEUE_PROPERTIES, \"Queue properties\", qprop), dev_not_20 },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_QUEUE_ON_HOST_PROPERTIES, \"Queue properties (on host)\", qprop), dev_is_20 },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_QUEUE_ON_DEVICE_PROPERTIES, \"Queue properties (on device)\", qprop), dev_is_20 },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_QUEUE_ON_DEVICE_PREFERRED_SIZE, INDENT \"Preferred size\", mem), dev_is_20 },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_QUEUE_ON_DEVICE_MAX_SIZE, INDENT \"Max size\", mem), dev_is_20 },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_MAX_ON_DEVICE_QUEUES, \"Max queues on device\", int), dev_is_20 },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_MAX_ON_DEVICE_EVENTS, \"Max events on device\", int), dev_is_20 },\n\n\t/* Terminate context */\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_TERMINATE_CAPABILITY_KHR_1x, \"Terminate capability (1.2 define)\", terminate_capability), dev_has_terminate_context },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_TERMINATE_CAPABILITY_KHR_2x, \"Terminate capability (2.x define)\", terminate_capability), dev_has_terminate_context },\n\n\t/* Interop */\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_PREFERRED_INTEROP_USER_SYNC, \"Prefer user sync for interop\", bool), dev_is_12 },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_NUM_SIMULTANEOUS_INTEROPS_INTEL, \"Number of simultaneous interops (Intel)\", int), dev_has_simultaneous_sharing },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_SIMULTANEOUS_INTEROPS_INTEL, \"Simultaneous interops\", interop_list), dev_has_simultaneous_sharing },\n\n\t/* P2P buffer copy */\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_NUM_P2P_DEVICES_AMD, \"Number of P2P devices (AMD)\", int), dev_has_p2p },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_P2P_DEVICES_AMD, \"P2P devices (AMD)\", p2p_dev_list), dev_has_p2p },\n\n\t/* Profiling resolution */\n\t{ CLINFO_BOTH, DINFO_SFX(CL_DEVICE_PROFILING_TIMER_RESOLUTION, \"Profiling timer resolution\", \"ns\", sz), NULL },\n\t{ CLINFO_HUMAN, DINFO(CL_DEVICE_PROFILING_TIMER_OFFSET_AMD, \"Profiling timer offset since Epoch (AMD)\", time_offset), dev_has_amd },\n\t{ CLINFO_RAW, DINFO(CL_DEVICE_PROFILING_TIMER_OFFSET_AMD, \"Profiling timer offset since Epoch (AMD)\", long), dev_has_amd },\n\n\t/* Kernel execution capabilities */\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_EXECUTION_CAPABILITIES, \"Execution capabilities\", execap), NULL },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_SUB_GROUP_INDEPENDENT_FORWARD_PROGRESS, INDENT \"Sub-group independent forward progress\", bool), dev_is_21 },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_THREAD_TRACE_SUPPORTED_AMD, INDENT \"Thread trace supported (AMD)\", bool), dev_is_gpu_amd },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_KERNEL_EXEC_TIMEOUT_NV, INDENT \"Kernel execution timeout (NV)\", bool), dev_has_nv },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_GPU_OVERLAP_NV, \"Concurrent copy and kernel execution (NV)\", bool), dev_has_nv },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_ATTRIBUTE_ASYNC_ENGINE_COUNT_NV, INDENT \"Number of async copy engines\", int), dev_has_nv },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_AVAILABLE_ASYNC_QUEUES_AMD, INDENT \"Number of async queues (AMD)\", int), dev_has_amd_v4 },\n\t/* TODO FIXME undocumented, experimental */\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_MAX_REAL_TIME_COMPUTE_QUEUES_AMD, INDENT \"Max real-time compute queues (AMD)\", int), dev_has_amd_v4 },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_MAX_REAL_TIME_COMPUTE_UNITS_AMD, INDENT \"Max real-time compute units (AMD)\", int), dev_has_amd_v4 },\n\n\t/* TODO: this should tell if it's being done due to the device being 2.1 or due to it having the extension */\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_IL_VERSION, INDENT \"IL version\", str), dev_has_il },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_SPIR_VERSIONS, INDENT \"SPIR versions\", str), dev_has_spir },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_PRINTF_BUFFER_SIZE, \"printf() buffer size\", mem_sz), dev_is_12 },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_BUILT_IN_KERNELS, \"Built-in kernels\", str), dev_is_12 },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_ME_VERSION_INTEL, \"Motion Estimation accelerator version (Intel)\", int), dev_has_intel_AME },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_AVC_ME_VERSION_INTEL, INDENT \"Device-side AVC Motion Estimation version\", int), dev_has_intel_AVC_ME },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_AVC_ME_SUPPORTS_TEXTURE_SAMPLER_USE_INTEL, INDENT INDENT \"Supports texture sampler use\", bool), dev_has_intel_AVC_ME },\n\t{ CLINFO_BOTH, DINFO(CL_DEVICE_AVC_ME_SUPPORTS_PREEMPTION_INTEL, INDENT INDENT \"Supports preemption\", bool), dev_has_intel_AVC_ME },\n};\n\n/* Process all the device info in the traits, except if param_whitelist is not NULL,\n * in which case only those in the whitelist will be processed.\n * If present, the whitelist should be sorted in the order of appearance of the parameters\n * in the traits table, and terminated by the value CL_FALSE\n */\n\nvoid\nprintDeviceInfo(cl_device_id dev, const struct platform_list *plist, cl_uint p,\n\tconst cl_device_info *param_whitelist, /* list of device info to process, or NULL */\n\tconst struct opt_out *output)\n{\n\tchar *extensions = NULL;\n\n\t/* pointer to the traits for CL_DEVICE_EXTENSIONS */\n\tconst struct device_info_traits *extensions_traits = NULL;\n\n\tstruct device_info_checks chk;\n\tstruct device_info_ret ret;\n\tstruct info_loc loc;\n\n\tmemset(&chk, 0, sizeof(chk));\n\tchk.pinfo_checks = plist->platform_checks + p;\n\tchk.dev_version = 10;\n\n\tINIT_RET(ret, \"device\");\n\n\treset_loc(&loc, __func__);\n\tloc.plat = plist->platform[p];\n\tloc.dev = dev;\n\n\tfor (loc.line = 0; loc.line < ARRAY_SIZE(dinfo_traits); ++loc.line) {\n\n\t\tconst struct device_info_traits *traits = dinfo_traits + loc.line;\n\n\t\t/* checked is true if there was no condition to check for, or if the\n\t\t * condition was satisfied\n\t\t */\n\t\tint checked = !(traits->check_func && !traits->check_func(&chk));\n\n\t\tloc.sname = traits->sname;\n\t\tloc.pname = (output->mode == CLINFO_HUMAN ?\n\t\t\ttraits->pname : traits->sname);\n\t\tloc.param.dev = traits->param;\n\n\t\t/* Whitelist check: finish if done traversing the list,\n\t\t * skip current param if it's not the right one\n\t\t */\n\t\tif ((output->cond == COND_PROP_CHECK || output->brief) && param_whitelist) {\n\t\t\tif (*param_whitelist == CL_FALSE)\n\t\t\t\tbreak;\n\t\t\tif (traits->param != *param_whitelist)\n\t\t\t\tcontinue;\n\t\t\t++param_whitelist;\n\t\t}\n\n\t\t/* skip if it's not for this output mode */\n\t\tif (!(output->mode & traits->output_mode))\n\t\t\tcontinue;\n\n\t\tif (output->cond == COND_PROP_CHECK && !checked)\n\t\t\tcontinue;\n\n\t\tcur_sfx = (output->mode == CLINFO_HUMAN && traits->sfx) ? traits->sfx : empty_str;\n\n\t\tret.str.buf[0] = '\\0';\n\t\tret.err_str.buf[0] = '\\0';\n\n\t\t/* Handle headers */\n\t\tif (traits->param == CL_FALSE) {\n\t\t\tret.err = CL_SUCCESS;\n\t\t\tshow_strbuf(&ret.str, loc.pname, 0, ret.err);\n\t\t\tcontinue;\n\t\t}\n\n\t\ttraits->show_func(&ret, &loc, &chk, output);\n\n\t\tif (traits->param == CL_DEVICE_EXTENSIONS) {\n\t\t\t/* make a backup of the extensions string, regardless of\n\t\t\t * errors */\n\t\t\tconst char *msg = RET_BUF(ret)->buf;\n\t\t\tsize_t len = strlen(msg);\n\t\t\textensions_traits = traits;\n\t\t\tALLOC(extensions, len+1, \"extensions\");\n\t\t\tmemcpy(extensions, msg, len);\n\t\t\textensions[len] = '\\0';\n\t\t} else {\n\t\t\tif (ret.err) {\n\t\t\t\t/* if there was an error retrieving the property,\n\t\t\t\t * skip if it wasn't expected to work and we\n\t\t\t\t * weren't asked to show everything regardless of\n\t\t\t\t * error */\n\t\t\t\tif (!checked && output->cond != COND_PROP_SHOW)\n\t\t\t\t\tcontinue;\n\n\t\t\t} else {\n\t\t\t\t/* on success, but empty result, show (n/a) */\n\t\t\t\tif (ret.str.buf[0] == '\\0')\n\t\t\t\t\tbufcpy(&ret.str, 0, not_specified(output));\n\t\t\t}\n\t\t\tif (output->brief)\n\t\t\t\tprintf(\"%s%s\\n\", line_pfx, RET_BUF(ret)->buf);\n\t\t\telse\n\t\t\t\tshow_strbuf(RET_BUF(ret), loc.pname, 0, ret.err);\n\t\t}\n\n\t\tif (ret.err)\n\t\t\tcontinue;\n\n\t\tswitch (traits->param) {\n\t\tcase CL_DEVICE_VERSION:\n\t\t\t/* compute numeric value for OpenCL version */\n\t\t\tchk.dev_version = getOpenCLVersion(ret.str.buf + 7);\n\t\t\tbreak;\n\t\tcase CL_DEVICE_EXTENSIONS:\n\t\t\tidentify_device_extensions(extensions, &chk);\n\t\t\tbreak;\n\t\tcase CL_DEVICE_TYPE:\n\t\t\tchk.devtype = ret.value.devtype;\n\t\t\tbreak;\n\t\tcase CL_DEVICE_GLOBAL_MEM_CACHE_TYPE:\n\t\t\tchk.cachetype = ret.value.cachetype;\n\t\t\tbreak;\n\t\tcase CL_DEVICE_LOCAL_MEM_TYPE:\n\t\t\tchk.lmemtype = ret.value.lmemtype;\n\t\t\tbreak;\n\t\tcase CL_DEVICE_IMAGE_SUPPORT:\n\t\t\tchk.image_support = ret.value.b;\n\t\t\tbreak;\n\t\tcase CL_DEVICE_COMPILER_AVAILABLE:\n\t\t\tchk.compiler_available = ret.value.b;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* do nothing */\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// and finally the extensions, if we retrieved them\n\tif (extensions)\n\t\tprintf(\"%s\" I1_STR \"%s\\n\", line_pfx, (output->mode == CLINFO_HUMAN ?\n\t\t\t\textensions_traits->pname :\n\t\t\t\textensions_traits->sname), extensions);\n\tfree(extensions);\n\textensions = NULL;\n\tUNINIT_RET(ret);\n}\n\n/* list of allowed properties for AMD offline devices */\n/* everything else seems to be set to 0, and all the other string properties\n * actually segfault the driver */\n\nstatic const cl_device_info amd_offline_info_whitelist[] = {\n\tCL_DEVICE_NAME,\n\t/* These are present, but all the same, so just skip them:\n\tCL_DEVICE_VENDOR,\n\tCL_DEVICE_VENDOR_ID,\n\tCL_DEVICE_VERSION,\n\tCL_DRIVER_VERSION,\n\tCL_DEVICE_OPENCL_C_VERSION,\n\t*/\n\tCL_DEVICE_EXTENSIONS,\n\tCL_DEVICE_TYPE,\n\tCL_DEVICE_GFXIP_MAJOR_AMD,\n\tCL_DEVICE_GFXIP_MINOR_AMD,\n\tCL_DEVICE_MAX_WORK_GROUP_SIZE,\n\tCL_FALSE\n};\n\nstatic const cl_device_info list_info_whitelist[] = {\n\tCL_DEVICE_NAME,\n\tCL_FALSE\n};\n\n/* return a list of offline devices from the AMD extension */\ncl_device_id *\nfetchOfflineDevicesAMD(const struct platform_list *plist, cl_uint p,\n\t/* the number of devices will be returned in ret->value.u32,\n\t * the associated context in ret->base.ctx;\n\t */\n\tstruct device_info_ret *ret)\n{\n\tcl_platform_id pid = plist->platform[p];\n\tcl_device_id *device = NULL;\n\tcl_uint num_devs = 0;\n\tcl_context ctx = NULL;\n\n\tcl_context_properties ctxpft[] = {\n\t\tCL_CONTEXT_PLATFORM, (cl_context_properties)pid,\n\t\tCL_CONTEXT_OFFLINE_DEVICES_AMD, (cl_context_properties)CL_TRUE,\n\t\t0\n\t};\n\n\tctx = clCreateContextFromType(ctxpft, CL_DEVICE_TYPE_ALL,\n\t\tNULL, NULL, &ret->err);\n\tREPORT_ERROR(&ret->err_str, ret->err, \"create context\");\n\n\tif (!ret->err) {\n\t\tret->err = REPORT_ERROR(&ret->err_str,\n\t\t\tclGetContextInfo(ctx, CL_CONTEXT_NUM_DEVICES,\n\t\t\t\tsizeof(num_devs), &num_devs, NULL),\n\t\t\t\"get num devs\");\n\t}\n\n\tif (!ret->err) {\n\t\tALLOC(device, num_devs, \"offline devices\");\n\n\t\tret->err = REPORT_ERROR(&ret->err_str,\n\t\t\tclGetContextInfo(ctx, CL_CONTEXT_DEVICES,\n\t\t\t\tnum_devs*sizeof(*device), device, NULL),\n\t\t\t\"get devs\");\n\t}\n\n\tif (ret->err) {\n\t\tif (ctx) clReleaseContext(ctx);\n\t\tfree(device);\n\t\tdevice = NULL;\n\t} else {\n\t\tret->value.u32 = num_devs;\n\t\tret->base.ctx = ctx;\n\t}\n\treturn device;\n}\n\nvoid printPlatformName(const struct platform_list *plist, cl_uint p, struct _strbuf *str,\n\tconst struct opt_out *output)\n{\n\tconst struct platform_data *pdata = plist->pdata + p;\n\tconst char *brief_prefix = (output->mode == CLINFO_HUMAN ? \"Platform #\" : \"\");\n\tconst char *title = (output->mode == CLINFO_HUMAN  ? pinfo_traits[0].pname :\n\t\tpinfo_traits[0].sname);\n\tconst int prefix_width = -line_pfx_len*(!output->brief);\n\tif (output->brief) {\n\t\tstrbuf_printf(str, \"%s%\" PRIu32 \": \", brief_prefix, p);\n\t} else if (output->mode == CLINFO_RAW) {\n\t\tstrbuf_printf(str, \"[%s/*]\", pdata->sname);\n\t}\n\tsprintf(line_pfx, \"%*s\", prefix_width, str->buf);\n\n\tif (output->brief)\n\t\tprintf(\"%s%s\\n\", line_pfx, pdata->pname);\n\telse\n\t\tprintf(\"%s\" I1_STR \"%s\\n\", line_pfx, title, pdata->pname);\n}\n\nvoid printPlatformDevices(const struct platform_list *plist, cl_uint p,\n\tconst cl_device_id *device, cl_uint ndevs,\n\tstruct _strbuf *str, const struct opt_out *output, cl_bool these_are_offline)\n{\n\tconst struct platform_data *pdata = plist->pdata + p;\n\tconst cl_device_info *param_whitelist = output->brief ? list_info_whitelist :\n\t\tthese_are_offline ? amd_offline_info_whitelist : NULL;\n\tcl_uint d;\n\n\tif (output->detailed)\n\t\tprintf(\"%s\" I0_STR \"%\" PRIu32 \"\\n\",\n\t\t\tline_pfx,\n\t\t\tnum_devs_header(output, these_are_offline),\n\t\t\tndevs);\n\n\tfor (d = 0; d < ndevs; ++d) {\n\t\tconst cl_device_id dev = device[d];\n\t\tif (output->brief) {\n\t\t\tconst cl_bool last_device = (d == ndevs - 1 &&\n\t\t\t\toutput->mode != CLINFO_RAW &&\n\t\t\t\t(!output->offline ||\n\t\t\t\t !pdata->has_amd_offline ||\n\t\t\t\t these_are_offline));\n\t\t\tif (output->mode == CLINFO_RAW)\n\t\t\t\tsprintf(line_pfx, \"%\" PRIu32 \"%c%\" PRIu32 \": \",\n\t\t\t\t\tp,\n\t\t\t\t\tthese_are_offline ? '*' : '.',\n\t\t\t\t\td);\n\t\t\telse\n\t\t\t\tsprintf(line_pfx, \" +-- %sDevice #%\" PRIu32 \": \",\n\t\t\t\t\tthese_are_offline ? \"Offline \" : \"\",\n\t\t\t\t\td);\n\t\t\tif (last_device)\n\t\t\t\tline_pfx[1] = '`';\n\t\t} else if (line_pfx_len > 0) {\n\t\t\tcl_int sd = (these_are_offline ? -1 : 1)*(cl_int)d;\n\t\t\tstrbuf_printf(str, \"[%s/%\" PRId32 \"]\", pdata->sname, sd);\n\t\t\tsprintf(line_pfx, \"%*s\", -line_pfx_len, str->buf);\n\t\t}\n\t\tprintDeviceInfo(dev, plist, p, param_whitelist, output);\n\t\tif (output->detailed && d < pdata[p].ndevs - 1)\n\t\t\tputs(\"\");\n\t\tfflush(stdout);\n\t\tfflush(stderr);\n\t}\n}\n\n\nvoid showDevices(const struct platform_list *plist, const struct opt_out *output)\n{\n\tconst cl_uint num_platforms = plist->num_platforms;\n\tconst cl_uint maxdevs = plist->max_devs;\n\tconst struct platform_data *pdata = plist->pdata;\n\n\tcl_uint p;\n\tstruct _strbuf str;\n\tinit_strbuf(&str);\n\trealloc_strbuf(&str, 1024, \"show devices\");\n\n\tif (output->mode == CLINFO_RAW) {\n\t\tif (output->brief)\n\t\t\tstrbuf_printf(&str, \"%\" PRIu32 \".%\" PRIu32 \": \", num_platforms, maxdevs);\n\t\telse\n\t\t\tstrbuf_printf(&str, \"[%*s/%\" PRIu32 \"] \",\n\t\t\t\tplist->max_sname_len, \"\", maxdevs);\n\t} else {\n\t\tif (output->brief)\n\t\t\tstrbuf_printf(&str, \" +-- %sDevice #%\" PRIu32 \": \",\n\t\t\t\t(output->offline ? \"Offline \" : \"\"), maxdevs);\n\t\telse\n\t\t\tstr.buf[0] = '\\0'; /* reset */\n\t\t/* TODO we have no prefix in HUMAN detailed output mode,\n\t\t * consider adding one\n\t\t */\n\t}\n\n\tif (str.buf[0]) {\n\t\tline_pfx_len = (int)(strlen(str.buf) + 1);\n\t\tREALLOC(line_pfx, line_pfx_len, \"line prefix\");\n\t\tstr.buf[0] = '\\0'; /* reset */\n\t}\n\n\tfor (p = 0; p < num_platforms; ++p) {\n\t\tprintPlatformName(plist, p, &str, output);\n\n\t\tprintPlatformDevices(plist, p,\n\t\t\tget_platform_devs(plist, p), pdata[p].ndevs,\n\t\t\t&str, output, CL_FALSE);\n\n\t\tif (output->offline && pdata[p].has_amd_offline) {\n\t\t\tstruct device_info_ret ret;\n\t\t\tcl_device_id *devs = NULL;\n\n\t\t\tINIT_RET(ret, \"offline device\");\n\t\t\tif (output->detailed)\n\t\t\t\tputs(\"\");\n\n\t\t\tdevs = fetchOfflineDevicesAMD(plist, p, &ret);\n\t\t\tif (ret.err) {\n\t\t\t\tputs(ret.err_str.buf);\n\t\t\t} else {\n\t\t\t\tprintPlatformDevices(plist, p, devs, ret.value.u32,\n\t\t\t\t\t&str, output, CL_TRUE);\n\t\t\t\tclReleaseContext(ret.base.ctx);\n\t\t\t\tfree(devs);\n\t\t\t}\n\t\t\tUNINIT_RET(ret);\n\t\t}\n\t\tif (output->detailed)\n\t\t\tputs(\"\");\n\t}\n\tfree_strbuf(&str);\n}\n\n/* check the behavior of clGetPlatformInfo() when given a NULL platform ID */\nvoid checkNullGetPlatformName(const struct opt_out *output)\n{\n\tstruct device_info_ret ret;\n\tstruct info_loc loc;\n\n\tINIT_RET(ret, \"null ctx\");\n\treset_loc(&loc, __func__);\n\tRESET_LOC_PARAM(loc, plat, CL_PLATFORM_NAME);\n\n\tret.err = clGetPlatformInfo(NULL, CL_PLATFORM_NAME, ret.str.sz, ret.str.buf, NULL);\n\tif (ret.err == CL_INVALID_PLATFORM) {\n\t\tbufcpy(&ret.err_str, 0, no_plat(output));\n\t} else {\n\t\tloc.line = __LINE__ + 1;\n\t\tREPORT_ERROR_LOC(&ret, ret.err, &loc, \"get %s\");\n\t}\n\tprintf(I1_STR \"%s\\n\",\n\t\t\"clGetPlatformInfo(NULL, CL_PLATFORM_NAME, ...)\", RET_BUF(ret)->buf);\n\tUNINIT_RET(ret);\n}\n\n/* check the behavior of clGetDeviceIDs() when given a NULL platform ID;\n * return the index of the default platform in our array of platform IDs,\n * or num_platforms (which is an invalid platform index) in case of errors\n * or no platform or device found.\n */\ncl_uint checkNullGetDevices(const struct platform_list *plist, const struct opt_out *output)\n{\n\tconst cl_uint num_platforms = plist->num_platforms;\n\tconst struct platform_data *pdata = plist->pdata;\n\tconst cl_platform_id *platform = plist->platform;\n\n\tstruct device_info_ret ret;\n\tstruct info_loc loc;\n\n\tcl_uint i = 0; /* generic iterator */\n\tcl_device_id dev = NULL; /* sample device */\n\tcl_platform_id plat = NULL; /* detected platform */\n\n\tcl_uint found = 0; /* number of platforms found */\n\tcl_uint pidx = num_platforms; /* index of the platform found */\n\tcl_uint numdevs = 0;\n\n\tINIT_RET(ret, \"null get devices\");\n\n\treset_loc(&loc, __func__);\n\tloc.sname = \"device IDs\";\n\n\tret.err = clGetDeviceIDs(NULL, CL_DEVICE_TYPE_ALL, 0, NULL, &numdevs);\n\t/* TODO we should check other CL_DEVICE_TYPE_* combinations, since a smart\n\t * implementation might give you a different default platform for GPUs\n\t * and for CPUs.\n\t * Of course the \u201cno devices\u201d case would then need to be handled differently.\n\t * The logic might be maintained similarly, provided we also gather\n\t * the number of devices of each type for each platform, although it's\n\t * obviously more likely to have multiple platforms with no devices\n\t * of a given type.\n\t */\n\n\tswitch (ret.err) {\n\tcase CL_INVALID_PLATFORM:\n\t\tbufcpy(&ret.err_str, 0, no_plat(output));\n\t\tbreak;\n\tcase CL_DEVICE_NOT_FOUND:\n\t\t /* No devices were found, see if there are platforms with\n\t\t  * no devices, and if there's only one, assume this is the\n\t\t  * one being used as default by the ICD loader */\n\t\tfor (i = 0; i < num_platforms; ++i) {\n\t\t\tif (pdata[i].ndevs == 0) {\n\t\t\t\t++found;\n\t\t\t\tif (found > 1)\n\t\t\t\t\tbreak;\n\t\t\t\telse {\n\t\t\t\t\tplat = platform[i];\n\t\t\t\t\tpidx = i;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tswitch (found) {\n\t\tcase 0:\n\t\t\tbufcpy(&ret.err_str, 0, (output->mode == CLINFO_HUMAN ?\n\t\t\t\t\"<error: 0 devices, no matching platform!>\" :\n\t\t\t\t\"CL_DEVICE_NOT_FOUND | CL_INVALID_PLATFORM\"));\n\t\t\tbreak;\n\t\tcase 1:\n\t\t\tbufcpy(&ret.str, 0, (output->mode == CLINFO_HUMAN ?\n\t\t\t\tpdata[pidx].pname :\n\t\t\t\tpdata[pidx].sname));\n\t\t\tbreak;\n\t\tdefault: /* found > 1 */\n\t\t\tbufcpy(&ret.err_str, 0, (output->mode == CLINFO_HUMAN ?\n\t\t\t\t\"<error: 0 devices, multiple matching platforms!>\" :\n\t\t\t\t\"CL_DEVICE_NOT_FOUND | ????\"));\n\t\t\tbreak;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\tloc.line = __LINE__+1;\n\t\tif (REPORT_ERROR_LOC(&ret, ret.err, &loc, \"get number of %s\")) break;\n\n\t\t/* Determine platform by looking at the CL_DEVICE_PLATFORM of\n\t\t * one of the devices */\n\t\tret.err = clGetDeviceIDs(NULL, CL_DEVICE_TYPE_ALL, 1, &dev, NULL);\n\t\tloc.line = __LINE__+1;\n\t\tif (REPORT_ERROR_LOC(&ret, ret.err, &loc, \"get %s\")) break;\n\n\t\tRESET_LOC_PARAM(loc, dev, CL_DEVICE_PLATFORM);\n\t\tret.err = clGetDeviceInfo(dev, CL_DEVICE_PLATFORM,\n\t\t\tsizeof(plat), &plat, NULL);\n\t\tloc.line = __LINE__+1;\n\t\tif (REPORT_ERROR_LOC(&ret, ret.err, &loc, \"get %s\")) break;\n\n\t\tfor (i = 0; i < num_platforms; ++i) {\n\t\t\tif (platform[i] == plat) {\n\t\t\t\tpidx = i;\n\t\t\t\tstrbuf_printf(&ret.str, \"%s [%s]\",\n\t\t\t\t\t(output->mode == CLINFO_HUMAN ? \"Success\" : \"CL_SUCCESS\"),\n\t\t\t\t\tpdata[i].sname);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == num_platforms) {\n\t\t\tret.err = CL_INVALID_PLATFORM;\n\t\t\tstrbuf_printf(&ret.err_str, \"<error: platform %p not found>\", (void*)plat);\n\t\t}\n\t}\n\tprintf(I1_STR \"%s\\n\",\n\t\t\"clGetDeviceIDs(NULL, CL_DEVICE_TYPE_ALL, ...)\", RET_BUF(ret)->buf);\n\n\tUNINIT_RET(ret);\n\treturn pidx;\n}\n\nvoid checkNullCtx(struct device_info_ret *ret,\n\tconst struct platform_list *plist, cl_uint pidx, const char *which,\n\tconst struct opt_out *output)\n{\n\tconst cl_device_id *dev = plist->all_devs + plist->dev_offset[pidx];\n\tstruct info_loc loc;\n\tcl_context ctx = clCreateContext(NULL, 1, dev, NULL, NULL, &ret->err);\n\n\treset_loc(&loc, __func__);\n\tloc.sname = which;\n\tloc.line = __LINE__+2;\n\n\tif (!REPORT_ERROR_LOC(ret, ret->err, &loc, \"create context with device from %s platform\"))\n\t\tstrbuf_printf(&ret->str, \"%s [%s]\",\n\t\t\t(output->mode == CLINFO_HUMAN ? \"Success\" : \"CL_SUCCESS\"),\n\t\t\tplist->pdata[pidx].sname);\n\tif (ctx) {\n\t\tclReleaseContext(ctx);\n\t\tctx = NULL;\n\t}\n}\n\n/* check behavior of clCreateContextFromType() with NULL cl_context_properties */\nvoid checkNullCtxFromType(const struct platform_list *plist, const struct opt_out *output)\n{\n\tconst cl_uint num_platforms = plist->num_platforms;\n\tconst struct platform_data *pdata = plist->pdata;\n\tconst cl_platform_id *platform = plist->platform;\n\n\tsize_t t; /* type iterator */\n\tsize_t i; /* generic iterator */\n\tchar def[1024];\n\tcl_context ctx = NULL;\n\n\tsize_t ndevs = 8;\n\tsize_t szval = 0;\n\tsize_t cursz = ndevs*sizeof(cl_device_id);\n\tcl_platform_id plat = NULL;\n\tcl_device_id *devs = NULL;\n\n\tstruct device_info_ret ret;\n\tstruct info_loc loc;\n\n\tconst char *platname_prop = (output->mode == CLINFO_HUMAN ?\n\t\tpinfo_traits[0].pname :\n\t\tpinfo_traits[0].sname);\n\n\tconst char *devname_prop = (output->mode == CLINFO_HUMAN ?\n\t\tdinfo_traits[0].pname :\n\t\tdinfo_traits[0].sname);\n\n\treset_loc(&loc, __func__);\n\tINIT_RET(ret, \"null ctx from type\");\n\n\tALLOC(devs, ndevs, \"context devices\");\n\n\tfor (t = 1; t < devtype_count; ++t) { /* we skip 0 */\n\t\tloc.sname = device_type_raw_str[t];\n\n\t\tstrbuf_printf(&ret.str, \"clCreateContextFromType(NULL, %s)\", loc.sname);\n\t\tsprintf(def, I1_STR, ret.str.buf);\n\n\t\tloc.line = __LINE__+1;\n\t\tctx = clCreateContextFromType(NULL, devtype[t], NULL, NULL, &ret.err);\n\n\t\tswitch (ret.err) {\n\t\tcase CL_INVALID_PLATFORM:\n\t\t\tbufcpy(&ret.err_str, 0, no_plat(output)); break;\n\t\tcase CL_DEVICE_NOT_FOUND:\n\t\t\tbufcpy(&ret.err_str, 0, no_dev_found(output)); break;\n\t\tcase CL_INVALID_DEVICE_TYPE: /* e.g. _CUSTOM device on 1.1 platform */\n\t\t\tbufcpy(&ret.err_str, 0, invalid_dev_type(output)); break;\n\t\tcase CL_INVALID_VALUE: /* This is what apple returns for the case above */\n\t\t\tbufcpy(&ret.err_str, 0, invalid_dev_type(output)); break;\n\t\tcase CL_DEVICE_NOT_AVAILABLE:\n\t\t\tbufcpy(&ret.err_str, 0, no_dev_avail(output)); break;\n\t\tdefault:\n\t\t\tif (REPORT_ERROR_LOC(&ret, ret.err, &loc, \"create context from type %s\")) break;\n\n\t\t\t/* get the devices */\n\t\t\tloc.sname = \"CL_CONTEXT_DEVICES\";\n\t\t\tloc.line = __LINE__+2;\n\n\t\t\tret.err = clGetContextInfo(ctx, CL_CONTEXT_DEVICES, 0, NULL, &szval);\n\t\t\tif (REPORT_ERROR_LOC(&ret, ret.err, &loc, \"get %s size\")) break;\n\t\t\tif (szval > cursz) {\n\t\t\t\tREALLOC(devs, szval, \"context devices\");\n\t\t\t\tcursz = szval;\n\t\t\t}\n\n\t\t\tloc.line = __LINE__+1;\n\t\t\tret.err = clGetContextInfo(ctx, CL_CONTEXT_DEVICES, cursz, devs, NULL);\n\t\t\tif (REPORT_ERROR_LOC(&ret, ret.err, &loc, \"get %s\")) break;\n\t\t\tndevs = szval/sizeof(cl_device_id);\n\t\t\tif (ndevs < 1) {\n\t\t\t\tret.err = CL_DEVICE_NOT_FOUND;\n\t\t\t\tbufcpy(&ret.err_str, 0, \"<error: context created with no devices>\");\n\t\t\t}\n\n\t\t\t/* get the platform from the first device */\n\t\t\tRESET_LOC_PARAM(loc, dev, CL_DEVICE_PLATFORM);\n\t\t\tloc.line = __LINE__+1;\n\t\t\tret.err = clGetDeviceInfo(*devs, CL_DEVICE_PLATFORM, sizeof(plat), &plat, NULL);\n\t\t\tif (REPORT_ERROR_LOC(&ret, ret.err, &loc, \"get %s\")) break;\n\t\t\tloc.plat = plat;\n\n\t\t\tszval = 0;\n\t\t\tfor (i = 0; i < num_platforms; ++i) {\n\t\t\t\tif (platform[i] == plat)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (i == num_platforms) {\n\t\t\t\tret.err = CL_INVALID_PLATFORM;\n\t\t\t\tstrbuf_printf(&ret.err_str, \"<error: platform %p not found>\", (void*)plat);\n\t\t\t\tbreak;\n\t\t\t} else {\n\t\t\t\tszval += strbuf_printf(&ret.str, \"%s (%\" PRIuS \")\",\n\t\t\t\t\t(output->mode == CLINFO_HUMAN ? \"Success\" : \"CL_SUCCESS\"),\n\t\t\t\t\tndevs);\n\t\t\t\tszval += snprintf(ret.str.buf + szval, ret.str.sz - szval, \"\\n\" I2_STR \"%s\",\n\t\t\t\t\tplatname_prop, pdata[i].pname);\n\t\t\t}\n\t\t\tfor (i = 0; i < ndevs; ++i) {\n\t\t\t\tsize_t szname = 0;\n\t\t\t\t/* for each device, show the device name */\n\t\t\t\t/* TODO some other unique ID too, e.g. PCI address, if available? */\n\n\t\t\t\tszval += snprintf(ret.str.buf + szval, ret.str.sz - szval, \"\\n\" I2_STR, devname_prop);\n\t\t\t\tif (szval >= ret.str.sz) {\n\t\t\t\t\ttrunc_strbuf(&ret.str);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tRESET_LOC_PARAM(loc, dev, CL_DEVICE_NAME);\n\t\t\t\tloc.dev = devs[i];\n\t\t\t\tloc.line = __LINE__+1;\n\t\t\t\tret.err = clGetDeviceInfo(devs[i], CL_DEVICE_NAME, ret.str.sz - szval, ret.str.buf + szval, &szname);\n\t\t\t\tif (REPORT_ERROR_LOC(&ret, ret.err, &loc, \"get %s\")) break;\n\t\t\t\tszval += szname - 1;\n\t\t\t}\n\t\t\tif (i != ndevs)\n\t\t\t\tbreak; /* had an error earlier, bail */\n\n\t\t}\n\n\t\tif (ctx) {\n\t\t\tclReleaseContext(ctx);\n\t\t\tctx = NULL;\n\t\t}\n\t\tprintf(\"%s%s\\n\", def, RET_BUF(ret)->buf);\n\t}\n\tfree(devs);\n\tUNINIT_RET(ret);\n}\n\n/* check the behavior of NULL platform in clGetDeviceIDs (see checkNullGetDevices)\n * and in clCreateContext() */\nvoid checkNullBehavior(const struct platform_list *plist, const struct opt_out *output)\n{\n\tconst cl_uint num_platforms = plist->num_platforms;\n\tconst struct platform_data *pdata = plist->pdata;\n\n\tcl_uint p = 0;\n\tstruct device_info_ret ret;\n\n\tINIT_RET(ret, \"null behavior\");\n\n\tprintf(\"NULL platform behavior\\n\");\n\n\tcheckNullGetPlatformName(output);\n\n\tp = checkNullGetDevices(plist, output);\n\n\t/* If there's a default platform, and it has devices, try\n\t * creating a context with its first device and see if it works */\n\n\tif (p == num_platforms) {\n\t\tret.err = CL_INVALID_PLATFORM;\n\t\tbufcpy(&ret.err_str, 0, no_plat(output));\n\t} else if (pdata[p].ndevs == 0) {\n\t\tret.err = CL_DEVICE_NOT_FOUND;\n\t\tbufcpy(&ret.err_str, 0, no_dev_found(output));\n\t} else {\n\t\tif (p < num_platforms) {\n\t\t\tcheckNullCtx(&ret, plist, p, \"default\", output);\n\t\t} else {\n\t\t\t/* this shouldn't happen, but still ... */\n\t\t\tret.err = CL_OUT_OF_HOST_MEMORY;\n\t\t\tbufcpy(&ret.err_str, 0, \"<error: overflow in default platform scan>\");\n\t\t}\n\t}\n\tprintf(I1_STR \"%s\\n\", \"clCreateContext(NULL, ...) [default]\", RET_BUF(ret)->buf);\n\n\t/* Look for a device from a non-default platform, if there are any */\n\tif (p == num_platforms || num_platforms > 1) {\n\t\tcl_uint p2 = 0;\n\t\twhile (p2 < num_platforms && (p2 == p || pdata[p2].ndevs == 0)) {\n\t\t\tp2++;\n\t\t}\n\t\tif (p2 < num_platforms) {\n\t\t\tcheckNullCtx(&ret, plist, p2, \"non-default\", output);\n\t\t} else {\n\t\t\tret.err = CL_DEVICE_NOT_FOUND;\n\t\t\tbufcpy(&ret.str, 0, \"<error: no devices in non-default plaforms>\");\n\t\t}\n\t\tprintf(I1_STR \"%s\\n\", \"clCreateContext(NULL, ...) [other]\", RET_BUF(ret)->buf);\n\t}\n\n\tcheckNullCtxFromType(plist, output);\n\n\tUNINIT_RET(ret);\n}\n\n\n/* Get properties of the ocl-icd loader, if available */\n/* All properties are currently char[] */\n\n/* Function pointer to the ICD loader info function */\n\ntypedef cl_int (*icdl_info_fn_ptr)(cl_icdl_info, size_t, void*, size_t*);\nicdl_info_fn_ptr clGetICDLoaderInfoOCLICD;\n\n/* We want to auto-detect the OpenCL version supported by the ICD loader.\n * To do this, we will progressively find symbols introduced in new APIs,\n * until a NULL symbol is found.\n */\n\nstruct icd_loader_test {\n\tcl_uint version;\n\tconst char *symbol;\n} icd_loader_tests[] = {\n\t{ 11, \"clCreateSubBuffer\" },\n\t{ 12, \"clCreateImage\" },\n\t{ 20, \"clSVMAlloc\" },\n\t{ 21, \"clGetHostTimer\" },\n\t{ 22, \"clSetProgramSpecializationConstant\" },\n\t{ 0, NULL }\n};\n\nvoid\nicdl_info_str(struct icdl_info_ret *ret, const struct info_loc *loc)\n{\n\tGET_STRING_LOC(ret, loc, clGetICDLoaderInfoOCLICD, loc->param.icdl);\n\treturn;\n}\n\nstruct icdl_info_traits {\n\tcl_icdl_info param; // CL_ICDL_*\n\tconst char *sname; // \"CL_ICDL_*\"\n\tconst char *pname; // \"ICD loader *\"\n};\n\nstatic const char * const oclicdl_pfx = \"OCLICD\";\n\n#define LINFO(symbol, name) { symbol, #symbol, \"ICD loader \" name }\nstruct icdl_info_traits linfo_traits[] = {\n\tLINFO(CL_ICDL_NAME, \"Name\"),\n\tLINFO(CL_ICDL_VENDOR, \"Vendor\"),\n\tLINFO(CL_ICDL_VERSION, \"Version\"),\n\tLINFO(CL_ICDL_OCL_VERSION, \"Profile\")\n};\n\n/* The ICD loader info function must be retrieved via clGetExtensionFunctionAddress,\n * which returns a void pointer.\n * ISO C forbids assignments between function pointers and void pointers,\n * but POSIX allows it. To compile without warnings even in -pedantic mode,\n * we take advantage of the fact that we _can_ do the conversion via\n * pointers-to-pointers. This is supported on most compilers, except\n * for some rather old GCC versions whose strict aliasing rules are\n * too strict. Disable strict aliasing warnings for these compilers.\n */\n#if defined __GNUC__ && ((__GNUC__*10 + __GNUC_MINOR__) < 46)\n#pragma GCC diagnostic ignored \"-Wstrict-aliasing\"\n#endif\n\nstruct icdl_data oclIcdProps(const struct platform_list *plist, const struct opt_out *output)\n{\n\tconst cl_uint max_plat_version = plist->max_plat_version;\n\n\tstruct icdl_data icdl;\n\n\t/* Counter that'll be used to walk the icd_loader_tests */\n\tint i = 0;\n\n\t/* We find the clGetICDLoaderInfoOCLICD extension address, which will be used\n\t * to query the ICD loader properties.\n\t * It should be noted that in this specific case we cannot replace the\n\t * call to clGetExtensionFunctionAddress with a call to the superseding function\n\t * clGetExtensionFunctionAddressForPlatform because the extension is in the\n\t * loader itself, not in a specific platform.\n\t */\n\tvoid *ptrHack = clGetExtensionFunctionAddress(\"clGetICDLoaderInfoOCLICD\");\n\tclGetICDLoaderInfoOCLICD = *(icdl_info_fn_ptr*)(&ptrHack);\n\n\t/* Initialize icdl_data ret versions */\n\ticdl.detected_version = 10;\n\ticdl.reported_version = 0;\n\n\t/* Step #1: try to auto-detect the supported ICD loader version */\n\tdo {\n\t\tstruct icd_loader_test check = icd_loader_tests[i];\n\t\tif (check.symbol == NULL)\n\t\t\tbreak;\n\t\tif (dlsym(DL_MODULE, check.symbol) == NULL)\n\t\t\tbreak;\n\t\ticdl.detected_version = check.version;\n\t\t++i;\n\t} while (1);\n\n\t/* Step #2: query properties from extension, if available */\n\tif (clGetICDLoaderInfoOCLICD != NULL) {\n\t\tstruct info_loc loc;\n\t\tstruct icdl_info_ret ret;\n\t\treset_loc(&loc, __func__);\n\t\tINIT_RET(ret, \"ICD loader\");\n\n\t\t/* TODO think of a sensible header in CLINFO_RAW */\n\t\tif (output->mode != CLINFO_RAW)\n\t\t\tputs(\"\\nICD loader properties\");\n\n\t\tif (output->mode == CLINFO_RAW) {\n\t\t\tline_pfx_len = (int)(strlen(oclicdl_pfx) + 5);\n\t\t\tREALLOC(line_pfx, line_pfx_len, \"line prefix OCL ICD\");\n\t\t\tstrbuf_printf(&ret.str, \"[%s/*]\", oclicdl_pfx);\n\t\t\tsprintf(line_pfx, \"%*s\", -line_pfx_len, ret.str.buf);\n\t\t}\n\n\t\tfor (loc.line = 0; loc.line < ARRAY_SIZE(linfo_traits); ++loc.line) {\n\t\t\tconst struct icdl_info_traits *traits = linfo_traits + loc.line;\n\t\t\tloc.sname = traits->sname;\n\t\t\tloc.pname = (output->mode == CLINFO_HUMAN ?\n\t\t\t\ttraits->pname : traits->sname);\n\t\t\tloc.param.icdl = traits->param;\n\n\t\t\tret.str.buf[0] = '\\0';\n\t\t\tret.err_str.buf[0] = '\\0';\n\t\t\ticdl_info_str(&ret, &loc);\n\t\t\tshow_strbuf(RET_BUF(ret), loc.pname, 1, ret.err);\n\n\t\t\tif (!ret.err && traits->param == CL_ICDL_OCL_VERSION) {\n\t\t\t\ticdl.reported_version = getOpenCLVersion(ret.str.buf + 7);\n\t\t\t}\n\t\t}\n\t\tUNINIT_RET(ret);\n\t}\n\n\t/* Step #3: show it */\n\tif (output->mode == CLINFO_HUMAN) {\n\t\tif (icdl.reported_version &&\n\t\t\ticdl.reported_version != icdl.detected_version) {\n\t\t\tprintf(\t\"\\tNOTE:\\tyour OpenCL library declares to support OpenCL %\" PRIu32 \".%\" PRIu32 \",\\n\"\n\t\t\t\t\"\\t\\tbut it seems to support up to OpenCL %\" PRIu32 \".%\" PRIu32 \" %s.\\n\",\n\t\t\t\tSPLIT_CL_VERSION(icdl.reported_version),\n\t\t\t\tSPLIT_CL_VERSION(icdl.detected_version),\n\t\t\t\ticdl.detected_version < icdl.reported_version  ?\n\t\t\t\t\"only\" : \"too\");\n\t\t}\n\t\tif (icdl.detected_version < max_plat_version) {\n\t\t\tprintf(\t\"\\tNOTE:\\tyour OpenCL library only supports OpenCL %\" PRIu32 \".%\" PRIu32 \",\\n\"\n\t\t\t\t\"\\t\\tbut some installed platforms support OpenCL %\" PRIu32 \".%\" PRIu32 \".\\n\"\n\t\t\t\t\"\\t\\tPrograms using %\" PRIu32 \".%\" PRIu32 \" features may crash\\n\"\n\t\t\t\t\"\\t\\tor behave unexpectedly\\n\",\n\t\t\t\tSPLIT_CL_VERSION(icdl.detected_version),\n\t\t\t\tSPLIT_CL_VERSION(max_plat_version),\n\t\t\t\tSPLIT_CL_VERSION(max_plat_version));\n\t\t}\n\t}\n\treturn icdl;\n}\n\n#if defined __GNUC__ && ((__GNUC__*10 + __GNUC_MINOR__) < 46)\n#pragma GCC diagnostic warning \"-Wstrict-aliasing\"\n#endif\n\nvoid version(void)\n{\n\tputs(\"clinfo version 2.2.18.04.06\");\n}\n\nvoid usage(void)\n{\n\tversion();\n\tputs(\"Display properties of all available OpenCL platforms and devices\");\n\tputs(\"Usage: clinfo [options ...]\\n\");\n\tputs(\"Options:\");\n\tputs(\"\\t--all-props, -a\\t\\ttry all properties, only show valid ones\");\n\tputs(\"\\t--always-all-props, -A\\t\\tshow all properties, even if invalid\");\n\tputs(\"\\t--human\\t\\thuman-friendly output (default)\");\n\tputs(\"\\t--raw\\t\\traw output\");\n\tputs(\"\\t--offline\\talso show offline devices\");\n\tputs(\"\\t--list, -l\\tonly list the platforms and devices by name\");\n\tputs(\"\\t-h, -?\\t\\tshow usage\");\n\tputs(\"\\t--version, -v\\tshow version\\n\");\n\tputs(\"Defaults to raw mode if invoked with\");\n\tputs(\"a name that contains the string \\\"raw\\\"\");\n}\n\nint main(int argc, char *argv[])\n{\n\tcl_uint p;\n\tcl_int err;\n\tint a = 0;\n\n\tstruct opt_out output;\n\n\tstruct platform_list plist;\n\tinit_plist(&plist);\n\n\toutput.mode = CLINFO_HUMAN;\n\toutput.cond = COND_PROP_CHECK;\n\toutput.brief = CL_FALSE;\n\toutput.offline = CL_FALSE;\n\toutput.check_size = CL_FALSE;\n\n\t/* if there's a 'raw' in the program name, switch to raw output mode */\n\tif (strstr(argv[0], \"raw\"))\n\t\toutput.mode = CLINFO_RAW;\n\n\t/* process command-line arguments */\n\twhile (++a < argc) {\n\t\tif (!strcmp(argv[a], \"-a\") || !strcmp(argv[a], \"--all-props\"))\n\t\t\toutput.cond = COND_PROP_TRY;\n\t\telse if (!strcmp(argv[a], \"-A\") || !strcmp(argv[a], \"--always-all-props\"))\n\t\t\toutput.cond = COND_PROP_SHOW;\n\t\telse if (!strcmp(argv[a], \"--raw\"))\n\t\t\toutput.mode = CLINFO_RAW;\n\t\telse if (!strcmp(argv[a], \"--human\"))\n\t\t\toutput.mode = CLINFO_HUMAN;\n\t\telse if (!strcmp(argv[a], \"--offline\"))\n\t\t\toutput.offline = CL_TRUE;\n\t\telse if (!strcmp(argv[a], \"-l\") || !strcmp(argv[a], \"--list\"))\n\t\t\toutput.brief = CL_TRUE;\n\t\telse if (!strcmp(argv[a], \"-?\") || !strcmp(argv[a], \"-h\")) {\n\t\t\tusage();\n\t\t\treturn 0;\n\t\t} else if (!strcmp(argv[a], \"--version\") || !strcmp(argv[a], \"-v\")) {\n\t\t\tversion();\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tfprintf(stderr, \"ignoring unknown command-line parameter %s\\n\", argv[a]);\n\t\t}\n\t}\n\toutput.detailed = !output.brief;\n\n\terr = clGetPlatformIDs(0, NULL, &plist.num_platforms);\n\tif (err != CL_PLATFORM_NOT_FOUND_KHR)\n\t\tCHECK_ERROR(err, \"number of platforms\");\n\n\tif (!output.brief)\n\t\tprintf(I0_STR \"%\" PRIu32 \"\\n\",\n\t\t\t(output.mode == CLINFO_HUMAN ?\n\t\t\t \"Number of platforms\" : \"#PLATFORMS\"),\n\t\t\tplist.num_platforms);\n\tif (!plist.num_platforms)\n\t\treturn 0;\n\n\talloc_plist(&plist);\n\terr = clGetPlatformIDs(plist.num_platforms, plist.platform, NULL);\n\tCHECK_ERROR(err, \"platform IDs\");\n\n\tALLOC(line_pfx, 1, \"line prefix\");\n\n\tfor (p = 0; p < plist.num_platforms; ++p) {\n\t\tgatherPlatformInfo(&plist, p, &output);\n\t\tif (output.detailed)\n\t\t\tputs(\"\");\n\t}\n\tshowDevices(&plist, &output);\n\tif (output.detailed) {\n\t\tif (output.mode != CLINFO_RAW)\n\t\t\tcheckNullBehavior(&plist, &output);\n\t\toclIcdProps(&plist, &output);\n\t}\n\n\tfree_plist(&plist);\n\treturn 0;\n}\n"
    },
    "skipped": [],
    "total_files": 21
}