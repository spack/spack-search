{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-rocprofiler-dev-3.5.0-gucmlniizd247uuh2s7vpd4nr6jdzlwp/spack-src/src/util/hsa_rsrc_factory.cpp": "/**********************************************************************\nCopyright \u00a92013 Advanced Micro Devices, Inc. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification, are permitted\nprovided that the following conditions are met:\n\n<95>    Redistributions of source code must retain the above copyright notice, this list of\nconditions and the following disclaimer.\n<95>    Redistributions in binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\n other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\nIMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT\nSHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY\n DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\nWHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n********************************************************************/\n\n#include \"util/hsa_rsrc_factory.h\"\n\n#include <dlfcn.h>\n#include <fcntl.h>\n#include <hsa.h>\n#include <hsa_ext_amd.h>\n#include <hsa_ext_finalize.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\n#include <atomic>\n#include <cassert>\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <vector>\n\nnamespace rocprofiler {\nnamespace util {\n\n// Callback function to get available in the system agents\nhsa_status_t HsaRsrcFactory::GetHsaAgentsCallback(hsa_agent_t agent, void* data) {\n  hsa_status_t status = HSA_STATUS_ERROR;\n  HsaRsrcFactory* hsa_rsrc = reinterpret_cast<HsaRsrcFactory*>(data);\n  const AgentInfo* agent_info = hsa_rsrc->AddAgentInfo(agent);\n  if (agent_info != NULL) status = HSA_STATUS_SUCCESS;\n  return status;\n}\n\n// This function checks to see if the provided\n// pool has the HSA_AMD_SEGMENT_GLOBAL property. If the kern_arg flag is true,\n// the function adds an additional requirement that the pool have the\n// HSA_AMD_MEMORY_POOL_GLOBAL_FLAG_KERNARG_INIT property. If kern_arg is false,\n// pools must NOT have this property.\n// Upon finding a pool that meets these conditions, HSA_STATUS_INFO_BREAK is\n// returned. HSA_STATUS_SUCCESS is returned if no errors were encountered, but\n// no pool was found meeting the requirements. If an error is encountered, we\n// return that error.\nstatic hsa_status_t FindGlobalPool(hsa_amd_memory_pool_t pool, void* data, bool kern_arg) {\n  hsa_status_t err;\n  hsa_amd_segment_t segment;\n  uint32_t flag;\n\n  if (nullptr == data) {\n    return HSA_STATUS_ERROR_INVALID_ARGUMENT;\n  }\n\n  err = HsaRsrcFactory::HsaApi()->hsa_amd_memory_pool_get_info(pool, HSA_AMD_MEMORY_POOL_INFO_SEGMENT, &segment);\n  CHECK_STATUS(\"hsa_amd_memory_pool_get_info\", err);\n  if (HSA_AMD_SEGMENT_GLOBAL != segment) {\n    return HSA_STATUS_SUCCESS;\n  }\n\n  err = HsaRsrcFactory::HsaApi()->hsa_amd_memory_pool_get_info(pool, HSA_AMD_MEMORY_POOL_INFO_GLOBAL_FLAGS, &flag);\n  CHECK_STATUS(\"hsa_amd_memory_pool_get_info\", err);\n\n  uint32_t karg_st = flag & HSA_AMD_MEMORY_POOL_GLOBAL_FLAG_KERNARG_INIT;\n\n  if ((karg_st == 0 && kern_arg) || (karg_st != 0 && !kern_arg)) {\n    return HSA_STATUS_SUCCESS;\n  }\n\n  *(reinterpret_cast<hsa_amd_memory_pool_t*>(data)) = pool;\n  return HSA_STATUS_INFO_BREAK;\n}\n\n// This is the call-back function for hsa_amd_agent_iterate_memory_pools() that\n// finds a pool with the properties of HSA_AMD_SEGMENT_GLOBAL and that is NOT\n// HSA_AMD_MEMORY_POOL_GLOBAL_FLAG_KERNARG_INIT\nhsa_status_t FindStandardPool(hsa_amd_memory_pool_t pool, void* data) {\n  return FindGlobalPool(pool, data, false);\n}\n\n// This is the call-back function for hsa_amd_agent_iterate_memory_pools() that\n// finds a pool with the properties of HSA_AMD_SEGMENT_GLOBAL and that IS\n// HSA_AMD_MEMORY_POOL_GLOBAL_FLAG_KERNARG_INIT\nhsa_status_t FindKernArgPool(hsa_amd_memory_pool_t pool, void* data) {\n  return FindGlobalPool(pool, data, true);\n}\n\n// Constructor of the class\nHsaRsrcFactory::HsaRsrcFactory(bool initialize_hsa) : initialize_hsa_(initialize_hsa) {\n  hsa_status_t status;\n\n  cpu_pool_ = NULL;\n  kern_arg_pool_ = NULL;\n\n  InitHsaApiTable(NULL);\n\n  // Initialize the Hsa Runtime\n  if (initialize_hsa_) {\n    status = hsa_api_.hsa_init();\n    CHECK_STATUS(\"Error in hsa_init\", status);\n  }\n\n  // Discover the set of Gpu devices available on the platform\n  status = hsa_api_.hsa_iterate_agents(GetHsaAgentsCallback, this);\n  CHECK_STATUS(\"Error Calling hsa_iterate_agents\", status);\n  if (cpu_pool_ == NULL) CHECK_STATUS(\"CPU memory pool is not found\", HSA_STATUS_ERROR);\n  if (kern_arg_pool_ == NULL) CHECK_STATUS(\"Kern-arg memory pool is not found\", HSA_STATUS_ERROR);\n\n  // Get AqlProfile API table\n  aqlprofile_api_ = {0};\n#ifdef ROCP_LD_AQLPROFILE\n  status = LoadAqlProfileLib(&aqlprofile_api_);\n#else\n  status = hsa_api_.hsa_system_get_major_extension_table(HSA_EXTENSION_AMD_AQLPROFILE, hsa_ven_amd_aqlprofile_VERSION_MAJOR, sizeof(aqlprofile_api_), &aqlprofile_api_);\n#endif\n  CHECK_STATUS(\"aqlprofile API table load failed\", status);\n\n  // Get Loader API table\n  loader_api_ = {0};\n  status = hsa_api_.hsa_system_get_major_extension_table(HSA_EXTENSION_AMD_LOADER, 1, sizeof(loader_api_), &loader_api_);\n  CHECK_STATUS(\"loader API table query failed\", status);\n\n  // Instantiate HSA timer\n  timer_ = new HsaTimer(&hsa_api_);\n  CHECK_STATUS(\"HSA timer allocation failed\",\n    (timer_ == NULL) ? HSA_STATUS_ERROR : HSA_STATUS_SUCCESS);\n\n  // Time correlation\n  const uint32_t corr_iters = 1000;\n  for (unsigned time_id = 0; time_id < HsaTimer::TIME_ID_NUMBER; time_id += 1) {\n    CorrelateTime((HsaTimer::time_id_t)time_id, corr_iters);\n  }\n\n  // System timeout\n  timeout_ = (timeout_ns_ == HsaTimer::TIMESTAMP_MAX) ? timeout_ns_ : timer_->ns_to_sysclock(timeout_ns_);\n}\n\n// Destructor of the class\nHsaRsrcFactory::~HsaRsrcFactory() {\n  delete timer_;\n  for (auto p : cpu_list_) delete p;\n  for (auto p : gpu_list_) delete p;\n  if (initialize_hsa_) {\n    hsa_status_t status = hsa_api_.hsa_shut_down();\n    CHECK_STATUS(\"Error in hsa_shut_down\", status);\n  }\n}\n\nvoid HsaRsrcFactory::InitHsaApiTable(HsaApiTable* table) {\n  std::lock_guard<mutex_t> lck(mutex_);\n\n  if (hsa_api_.hsa_init == NULL) {\n    if (table != NULL) {\n      hsa_api_.hsa_init = table->core_->hsa_init_fn;\n      hsa_api_.hsa_shut_down = table->core_->hsa_shut_down_fn;\n      hsa_api_.hsa_agent_get_info = table->core_->hsa_agent_get_info_fn;\n      hsa_api_.hsa_iterate_agents = table->core_->hsa_iterate_agents_fn;\n\n      hsa_api_.hsa_queue_create = table->core_->hsa_queue_create_fn;\n      hsa_api_.hsa_queue_destroy = table->core_->hsa_queue_destroy_fn;\n      hsa_api_.hsa_queue_load_write_index_relaxed = table->core_->hsa_queue_load_write_index_relaxed_fn;\n      hsa_api_.hsa_queue_store_write_index_relaxed = table->core_->hsa_queue_store_write_index_relaxed_fn;\n      hsa_api_.hsa_queue_load_read_index_relaxed = table->core_->hsa_queue_load_read_index_relaxed_fn;\n\n      hsa_api_.hsa_signal_create = table->core_->hsa_signal_create_fn;\n      hsa_api_.hsa_signal_destroy = table->core_->hsa_signal_destroy_fn;\n      hsa_api_.hsa_signal_load_relaxed = table->core_->hsa_signal_load_relaxed_fn;\n      hsa_api_.hsa_signal_store_relaxed = table->core_->hsa_signal_store_relaxed_fn;\n      hsa_api_.hsa_signal_wait_scacquire = table->core_->hsa_signal_wait_scacquire_fn;\n      hsa_api_.hsa_signal_store_screlease = table->core_->hsa_signal_store_screlease_fn;\n\n      hsa_api_.hsa_code_object_reader_create_from_file = table->core_->hsa_code_object_reader_create_from_file_fn;\n      hsa_api_.hsa_executable_create_alt = table->core_->hsa_executable_create_alt_fn;\n      hsa_api_.hsa_executable_load_agent_code_object = table->core_->hsa_executable_load_agent_code_object_fn;\n      hsa_api_.hsa_executable_freeze = table->core_->hsa_executable_freeze_fn;\n      hsa_api_.hsa_executable_get_symbol = table->core_->hsa_executable_get_symbol_fn;\n      hsa_api_.hsa_executable_symbol_get_info = table->core_->hsa_executable_symbol_get_info_fn;\n      hsa_api_.hsa_executable_iterate_symbols = table->core_->hsa_executable_iterate_symbols_fn;\n\n      hsa_api_.hsa_system_get_info = table->core_->hsa_system_get_info_fn;\n      hsa_api_.hsa_system_get_major_extension_table = table->core_->hsa_system_get_major_extension_table_fn;\n\n      hsa_api_.hsa_amd_agent_iterate_memory_pools = table->amd_ext_->hsa_amd_agent_iterate_memory_pools_fn;\n      hsa_api_.hsa_amd_memory_pool_get_info = table->amd_ext_->hsa_amd_memory_pool_get_info_fn;\n      hsa_api_.hsa_amd_memory_pool_allocate = table->amd_ext_->hsa_amd_memory_pool_allocate_fn;\n      hsa_api_.hsa_amd_agents_allow_access = table->amd_ext_->hsa_amd_agents_allow_access_fn;\n      hsa_api_.hsa_amd_memory_async_copy = table->amd_ext_->hsa_amd_memory_async_copy_fn;\n\n      hsa_api_.hsa_amd_signal_async_handler = table->amd_ext_->hsa_amd_signal_async_handler_fn;\n      hsa_api_.hsa_amd_profiling_set_profiler_enabled = table->amd_ext_->hsa_amd_profiling_set_profiler_enabled_fn;\n      hsa_api_.hsa_amd_profiling_get_async_copy_time = table->amd_ext_->hsa_amd_profiling_get_async_copy_time_fn;\n      hsa_api_.hsa_amd_profiling_get_dispatch_time = table->amd_ext_->hsa_amd_profiling_get_dispatch_time_fn;\n    } else {\n      hsa_api_.hsa_init = hsa_init;\n      hsa_api_.hsa_shut_down = hsa_shut_down;\n      hsa_api_.hsa_agent_get_info = hsa_agent_get_info;\n      hsa_api_.hsa_iterate_agents = hsa_iterate_agents;\n\n      hsa_api_.hsa_queue_create = hsa_queue_create;\n      hsa_api_.hsa_queue_destroy = hsa_queue_destroy;\n      hsa_api_.hsa_queue_load_write_index_relaxed = hsa_queue_load_write_index_relaxed;\n      hsa_api_.hsa_queue_store_write_index_relaxed = hsa_queue_store_write_index_relaxed;\n      hsa_api_.hsa_queue_load_read_index_relaxed = hsa_queue_load_read_index_relaxed;\n\n      hsa_api_.hsa_signal_create = hsa_signal_create;\n      hsa_api_.hsa_signal_destroy = hsa_signal_destroy;\n      hsa_api_.hsa_signal_load_relaxed = hsa_signal_load_relaxed;\n      hsa_api_.hsa_signal_store_relaxed = hsa_signal_store_relaxed;\n      hsa_api_.hsa_signal_wait_scacquire = hsa_signal_wait_scacquire;\n      hsa_api_.hsa_signal_store_screlease = hsa_signal_store_screlease;\n\n      hsa_api_.hsa_code_object_reader_create_from_file = hsa_code_object_reader_create_from_file;\n      hsa_api_.hsa_executable_create_alt = hsa_executable_create_alt;\n      hsa_api_.hsa_executable_load_agent_code_object = hsa_executable_load_agent_code_object;\n      hsa_api_.hsa_executable_freeze = hsa_executable_freeze;\n      hsa_api_.hsa_executable_get_symbol = hsa_executable_get_symbol;\n      hsa_api_.hsa_executable_symbol_get_info = hsa_executable_symbol_get_info;\n      hsa_api_.hsa_executable_iterate_symbols = hsa_executable_iterate_symbols;\n\n      hsa_api_.hsa_system_get_info = hsa_system_get_info;\n      hsa_api_.hsa_system_get_major_extension_table = hsa_system_get_major_extension_table;\n\n      hsa_api_.hsa_amd_agent_iterate_memory_pools = hsa_amd_agent_iterate_memory_pools;\n      hsa_api_.hsa_amd_memory_pool_get_info = hsa_amd_memory_pool_get_info;\n      hsa_api_.hsa_amd_memory_pool_allocate = hsa_amd_memory_pool_allocate;\n      hsa_api_.hsa_amd_agents_allow_access = hsa_amd_agents_allow_access;\n      hsa_api_.hsa_amd_memory_async_copy = hsa_amd_memory_async_copy;\n\n      hsa_api_.hsa_amd_signal_async_handler = hsa_amd_signal_async_handler;\n      hsa_api_.hsa_amd_profiling_set_profiler_enabled = hsa_amd_profiling_set_profiler_enabled;\n      hsa_api_.hsa_amd_profiling_get_async_copy_time = hsa_amd_profiling_get_async_copy_time;\n      hsa_api_.hsa_amd_profiling_get_dispatch_time = hsa_amd_profiling_get_dispatch_time;\n    }\n  }\n}\n\nhsa_status_t HsaRsrcFactory::LoadAqlProfileLib(aqlprofile_pfn_t* api) {\n  void* handle = dlopen(kAqlProfileLib, RTLD_NOW);\n  if (handle == NULL) {\n    fprintf(stderr, \"Loading '%s' failed, %s\\n\", kAqlProfileLib, dlerror());\n    return HSA_STATUS_ERROR;\n  }\n  dlerror(); /* Clear any existing error */\n\n  api->hsa_ven_amd_aqlprofile_error_string =\n      (decltype(::hsa_ven_amd_aqlprofile_error_string)*)dlsym(\n          handle, \"hsa_ven_amd_aqlprofile_error_string\");\n  api->hsa_ven_amd_aqlprofile_validate_event =\n      (decltype(::hsa_ven_amd_aqlprofile_validate_event)*)dlsym(\n          handle, \"hsa_ven_amd_aqlprofile_validate_event\");\n  api->hsa_ven_amd_aqlprofile_start =\n      (decltype(::hsa_ven_amd_aqlprofile_start)*)dlsym(handle, \"hsa_ven_amd_aqlprofile_start\");\n  api->hsa_ven_amd_aqlprofile_stop =\n      (decltype(::hsa_ven_amd_aqlprofile_stop)*)dlsym(handle, \"hsa_ven_amd_aqlprofile_stop\");\n#ifdef AQLPROF_NEW_API\n  api->hsa_ven_amd_aqlprofile_read =\n      (decltype(::hsa_ven_amd_aqlprofile_read)*)dlsym(handle, \"hsa_ven_amd_aqlprofile_read\");\n#endif\n  api->hsa_ven_amd_aqlprofile_legacy_get_pm4 =\n      (decltype(::hsa_ven_amd_aqlprofile_legacy_get_pm4)*)dlsym(\n          handle, \"hsa_ven_amd_aqlprofile_legacy_get_pm4\");\n  api->hsa_ven_amd_aqlprofile_get_info = (decltype(::hsa_ven_amd_aqlprofile_get_info)*)dlsym(\n      handle, \"hsa_ven_amd_aqlprofile_get_info\");\n  api->hsa_ven_amd_aqlprofile_iterate_data =\n      (decltype(::hsa_ven_amd_aqlprofile_iterate_data)*)dlsym(\n          handle, \"hsa_ven_amd_aqlprofile_iterate_data\");\n\n  return HSA_STATUS_SUCCESS;\n}\n\n// Add system agent info\nconst AgentInfo* HsaRsrcFactory::AddAgentInfo(const hsa_agent_t agent) {\n  // Determine if device is a Gpu agent\n  hsa_status_t status;\n  AgentInfo* agent_info = NULL;\n\n  hsa_device_type_t type;\n  status = hsa_api_.hsa_agent_get_info(agent, HSA_AGENT_INFO_DEVICE, &type);\n  CHECK_STATUS(\"Error Calling hsa_agent_get_info\", status);\n\n  if (type == HSA_DEVICE_TYPE_CPU) {\n    agent_info = new AgentInfo{};\n    agent_info->dev_id = agent;\n    agent_info->dev_type = HSA_DEVICE_TYPE_CPU;\n    agent_info->dev_index = cpu_list_.size();\n\n    status = hsa_api_.hsa_amd_agent_iterate_memory_pools(agent, FindStandardPool, &agent_info->cpu_pool);\n    if ((status == HSA_STATUS_INFO_BREAK) && (cpu_pool_ == NULL)) cpu_pool_ = &agent_info->cpu_pool;\n    status = hsa_api_.hsa_amd_agent_iterate_memory_pools(agent, FindKernArgPool, &agent_info->kern_arg_pool);\n    if ((status == HSA_STATUS_INFO_BREAK) && (kern_arg_pool_ == NULL)) kern_arg_pool_ = &agent_info->kern_arg_pool;\n    agent_info->gpu_pool = {};\n\n    cpu_list_.push_back(agent_info);\n    cpu_agents_.push_back(agent);\n  }\n\n  if (type == HSA_DEVICE_TYPE_GPU) {\n    agent_info = new AgentInfo{};\n    agent_info->dev_id = agent;\n    agent_info->dev_type = HSA_DEVICE_TYPE_GPU;\n    hsa_api_.hsa_agent_get_info(agent, HSA_AGENT_INFO_NAME, agent_info->name);\n    strncpy(agent_info->gfxip, agent_info->name, 4);\n    agent_info->gfxip[4] = '\\0';\n    hsa_api_.hsa_agent_get_info(agent, HSA_AGENT_INFO_WAVEFRONT_SIZE, &agent_info->max_wave_size);\n    hsa_api_.hsa_agent_get_info(agent, HSA_AGENT_INFO_QUEUE_MAX_SIZE, &agent_info->max_queue_size);\n    hsa_api_.hsa_agent_get_info(agent, HSA_AGENT_INFO_PROFILE, &agent_info->profile);\n    agent_info->is_apu = (agent_info->profile == HSA_PROFILE_FULL) ? true : false;\n    hsa_api_.hsa_agent_get_info(agent, static_cast<hsa_agent_info_t>(HSA_AMD_AGENT_INFO_COMPUTE_UNIT_COUNT),\n                       &agent_info->cu_num);\n    hsa_api_.hsa_agent_get_info(agent, static_cast<hsa_agent_info_t>(HSA_AMD_AGENT_INFO_MAX_WAVES_PER_CU),\n                       &agent_info->waves_per_cu);\n    hsa_api_.hsa_agent_get_info(agent, static_cast<hsa_agent_info_t>(HSA_AMD_AGENT_INFO_NUM_SIMDS_PER_CU),\n                       &agent_info->simds_per_cu);\n    hsa_api_.hsa_agent_get_info(agent, static_cast<hsa_agent_info_t>(HSA_AMD_AGENT_INFO_NUM_SHADER_ENGINES),\n                       &agent_info->se_num);\n    hsa_api_.hsa_agent_get_info(agent,\n                       static_cast<hsa_agent_info_t>(HSA_AMD_AGENT_INFO_NUM_SHADER_ARRAYS_PER_SE),\n                       &agent_info->shader_arrays_per_se);\n\n    agent_info->cpu_pool = {};\n    agent_info->kern_arg_pool = {};\n    status = hsa_api_.hsa_amd_agent_iterate_memory_pools(agent, FindStandardPool, &agent_info->gpu_pool);\n    CHECK_ITER_STATUS(\"hsa_amd_agent_iterate_memory_pools(gpu pool)\", status);\n\n    // GFX8 and GFX9 SGPR/VGPR block sizes\n    agent_info->sgpr_block_dflt = (strcmp(agent_info->gfxip, \"gfx8\") == 0) ? 1 : 2;\n    agent_info->sgpr_block_size = 8;\n    agent_info->vgpr_block_size = 4;\n\n    // Set GPU index\n    agent_info->dev_index = gpu_list_.size();\n    gpu_list_.push_back(agent_info);\n    gpu_agents_.push_back(agent);\n  }\n\n  if (agent_info) agent_map_[agent.handle] = agent_info;\n\n  return agent_info;\n}\n\n// Return systen agent info\nconst AgentInfo* HsaRsrcFactory::GetAgentInfo(const hsa_agent_t agent) {\n  const AgentInfo* agent_info = NULL;\n  auto it = agent_map_.find(agent.handle);\n  if (it != agent_map_.end()) {\n    agent_info = it->second;\n  }\n  return agent_info;\n}\n\n// Get the count of Hsa Gpu Agents available on the platform\n//\n// @return uint32_t Number of Gpu agents on platform\n//\nuint32_t HsaRsrcFactory::GetCountOfGpuAgents() { return uint32_t(gpu_list_.size()); }\n\n// Get the count of Hsa Cpu Agents available on the platform\n//\n// @return uint32_t Number of Cpu agents on platform\n//\nuint32_t HsaRsrcFactory::GetCountOfCpuAgents() { return uint32_t(cpu_list_.size()); }\n\n// Get the AgentInfo handle of a Gpu device\n//\n// @param idx Gpu Agent at specified index\n//\n// @param agent_info Output parameter updated with AgentInfo\n//\n// @return bool true if successful, false otherwise\n//\nbool HsaRsrcFactory::GetGpuAgentInfo(uint32_t idx, const AgentInfo** agent_info) {\n  // Determine if request is valid\n  uint32_t size = uint32_t(gpu_list_.size());\n  if (idx >= size) {\n    return false;\n  }\n\n  // Copy AgentInfo from specified index\n  *agent_info = gpu_list_[idx];\n\n  return true;\n}\n\n// Get the AgentInfo handle of a Cpu device\n//\n// @param idx Cpu Agent at specified index\n//\n// @param agent_info Output parameter updated with AgentInfo\n//\n// @return bool true if successful, false otherwise\n//\nbool HsaRsrcFactory::GetCpuAgentInfo(uint32_t idx, const AgentInfo** agent_info) {\n  // Determine if request is valid\n  uint32_t size = uint32_t(cpu_list_.size());\n  if (idx >= size) {\n    return false;\n  }\n\n  // Copy AgentInfo from specified index\n  *agent_info = cpu_list_[idx];\n  return true;\n}\n\n// Create a Queue object and return its handle. The queue object is expected\n// to support user requested number of Aql dispatch packets.\n//\n// @param agent_info Gpu Agent on which to create a queue object\n//\n// @param num_Pkts Number of packets to be held by queue\n//\n// @param queue Output parameter updated with handle of queue object\n//\n// @return bool true if successful, false otherwise\n//\nbool HsaRsrcFactory::CreateQueue(const AgentInfo* agent_info, uint32_t num_pkts,\n                                 hsa_queue_t** queue) {\n  hsa_status_t status;\n  status = hsa_api_.hsa_queue_create(agent_info->dev_id, num_pkts, HSA_QUEUE_TYPE_MULTI, NULL, NULL,\n                            UINT32_MAX, UINT32_MAX, queue);\n  return (status == HSA_STATUS_SUCCESS);\n}\n\n// Create a Signal object and return its handle.\n// @param value Initial value of signal object\n// @param signal Output parameter updated with handle of signal object\n// @return bool true if successful, false otherwise\nbool HsaRsrcFactory::CreateSignal(uint32_t value, hsa_signal_t* signal) {\n  hsa_status_t status;\n  status = hsa_api_.hsa_signal_create(value, 0, NULL, signal);\n  return (status == HSA_STATUS_SUCCESS);\n}\n\n// Allocate memory for use by a kernel of specified size in specified\n// agent's memory region.\n// @param agent_info Agent from whose memory region to allocate\n// @param size Size of memory in terms of bytes\n// @return uint8_t* Pointer to buffer, null if allocation fails.\nuint8_t* HsaRsrcFactory::AllocateLocalMemory(const AgentInfo* agent_info, size_t size) {\n  hsa_status_t status = HSA_STATUS_ERROR;\n  uint8_t* buffer = NULL;\n  size = (size + MEM_PAGE_MASK) & ~MEM_PAGE_MASK;\n  status = hsa_api_.hsa_amd_memory_pool_allocate(agent_info->gpu_pool, size, 0, reinterpret_cast<void**>(&buffer));\n  uint8_t* ptr = (status == HSA_STATUS_SUCCESS) ? buffer : NULL;\n  return ptr;\n}\n\n// Allocate memory to pass kernel parameters.\n// Memory is alocated accessible for all CPU agents and for GPU given by AgentInfo parameter.\n// @param agent_info Agent from whose memory region to allocate\n// @param size Size of memory in terms of bytes\n// @return uint8_t* Pointer to buffer, null if allocation fails.\nuint8_t* HsaRsrcFactory::AllocateKernArgMemory(const AgentInfo* agent_info, size_t size) {\n  hsa_status_t status = HSA_STATUS_ERROR;\n  uint8_t* buffer = NULL;\n  if (!cpu_agents_.empty()) {\n    size = (size + MEM_PAGE_MASK) & ~MEM_PAGE_MASK;\n    status = hsa_api_.hsa_amd_memory_pool_allocate(*kern_arg_pool_, size, 0, reinterpret_cast<void**>(&buffer));\n    // Both the CPU and GPU can access the kernel arguments\n    if (status == HSA_STATUS_SUCCESS) {\n      hsa_agent_t ag_list[1] = {agent_info->dev_id};\n      status = hsa_api_.hsa_amd_agents_allow_access(1, ag_list, NULL, buffer);\n    }\n  }\n  uint8_t* ptr = (status == HSA_STATUS_SUCCESS) ? buffer : NULL;\n  return ptr;\n}\n\n// Allocate system memory accessible by both CPU and GPU\n// @param agent_info Agent from whose memory region to allocate\n// @param size Size of memory in terms of bytes\n// @return uint8_t* Pointer to buffer, null if allocation fails.\nuint8_t* HsaRsrcFactory::AllocateSysMemory(const AgentInfo* agent_info, size_t size) {\n  hsa_status_t status = HSA_STATUS_ERROR;\n  uint8_t* buffer = NULL;\n  size = (size + MEM_PAGE_MASK) & ~MEM_PAGE_MASK;\n  if (!cpu_agents_.empty()) {\n    status = hsa_api_.hsa_amd_memory_pool_allocate(*cpu_pool_, size, 0, reinterpret_cast<void**>(&buffer));\n    // Both the CPU and GPU can access the memory\n    if (status == HSA_STATUS_SUCCESS) {\n      hsa_agent_t ag_list[1] = {agent_info->dev_id};\n      status = hsa_api_.hsa_amd_agents_allow_access(1, ag_list, NULL, buffer);\n    }\n  }\n  uint8_t* ptr = (status == HSA_STATUS_SUCCESS) ? buffer : NULL;\n  return ptr;\n}\n\n// Allocate memory for command buffer.\n// @param agent_info Agent from whose memory region to allocate\n// @param size Size of memory in terms of bytes\n// @return uint8_t* Pointer to buffer, null if allocation fails.\nuint8_t* HsaRsrcFactory::AllocateCmdMemory(const AgentInfo* agent_info, size_t size) {\n  size = (size + MEM_PAGE_MASK) & ~MEM_PAGE_MASK;\n  uint8_t* ptr = (agent_info->is_apu && CMD_MEMORY_MMAP)\n      ? reinterpret_cast<uint8_t*>(\n            mmap(NULL, size, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_SHARED | MAP_ANONYMOUS, 0, 0))\n      : AllocateSysMemory(agent_info, size);\n  return ptr;\n}\n\n// Wait signal\nhsa_signal_value_t HsaRsrcFactory::SignalWait(const hsa_signal_t& signal, const hsa_signal_value_t& signal_value) const {\n  const hsa_signal_value_t exp_value = signal_value - 1;\n  hsa_signal_value_t ret_value = signal_value;\n  while (1) {\n    ret_value =\n      hsa_api_.hsa_signal_wait_scacquire(signal, HSA_SIGNAL_CONDITION_LT, signal_value, timeout_, HSA_WAIT_STATE_BLOCKED);\n    if (ret_value == exp_value) break;\n    if (ret_value != signal_value) {\n      std::cerr << \"Error: HsaRsrcFactory::SignalWait: signal_value(\" << signal_value\n                << \"), ret_value(\" << ret_value << \")\" << std::endl << std::flush;\n      abort();\n    }\n  }\n  return ret_value;\n}\n\n// Wait signal with signal value restore\nvoid HsaRsrcFactory::SignalWaitRestore(const hsa_signal_t& signal, const hsa_signal_value_t& signal_value) const {\n  SignalWait(signal, signal_value);\n  hsa_api_.hsa_signal_store_relaxed(const_cast<hsa_signal_t&>(signal), signal_value);\n}\n\n// Copy data from GPU to host memory\nbool HsaRsrcFactory::Memcpy(const hsa_agent_t& agent, void* dst, const void* src, size_t size) {\n  hsa_status_t status = HSA_STATUS_ERROR;\n  if (!cpu_agents_.empty()) {\n    hsa_signal_t s = {};\n    status = hsa_api_.hsa_signal_create(1, 0, NULL, &s);\n    CHECK_STATUS(\"hsa_signal_create()\", status);\n    status = hsa_api_.hsa_amd_memory_async_copy(dst, cpu_agents_[0], src, agent, size, 0, NULL, s);\n    CHECK_STATUS(\"hsa_amd_memory_async_copy()\", status);\n    SignalWait(s, 1);\n    status = hsa_api_.hsa_signal_destroy(s);\n    CHECK_STATUS(\"hsa_signal_destroy()\", status);\n  }\n  return (status == HSA_STATUS_SUCCESS);\n}\nbool HsaRsrcFactory::Memcpy(const AgentInfo* agent_info, void* dst, const void* src, size_t size) {\n  return Memcpy(agent_info->dev_id, dst, src, size);\n}\n\n// Memory free method\nbool HsaRsrcFactory::FreeMemory(void* ptr) {\n  const hsa_status_t status = hsa_memory_free(ptr);\n  CHECK_STATUS(\"hsa_memory_free\", status);\n  return (status == HSA_STATUS_SUCCESS);\n}\n\n// Loads an Assembled Brig file and Finalizes it into Device Isa\n// @param agent_info Gpu device for which to finalize\n// @param brig_path File path of the Assembled Brig file\n// @param kernel_name Name of the kernel to finalize\n// @param code_desc Handle of finalized Code Descriptor that could\n// be used to submit for execution\n// @return bool true if successful, false otherwise\nbool HsaRsrcFactory::LoadAndFinalize(const AgentInfo* agent_info, const char* brig_path,\n                                     const char* kernel_name, hsa_executable_t* executable,\n                                     hsa_executable_symbol_t* code_desc) {\n  hsa_status_t status = HSA_STATUS_ERROR;\n\n  // Build the code object filename\n  std::string filename(brig_path);\n  std::clog << \"Code object filename: \" << filename << std::endl;\n\n  // Open the file containing code object\n  hsa_file_t file_handle = open(filename.c_str(), O_RDONLY);\n  if (file_handle == -1) {\n    std::cerr << \"Error: failed to load '\" << filename << \"'\" << std::endl;\n    assert(false);\n    return false;\n  }\n\n  // Create code object reader\n  hsa_code_object_reader_t code_obj_rdr = {0};\n  status = hsa_api_.hsa_code_object_reader_create_from_file(file_handle, &code_obj_rdr);\n  if (status != HSA_STATUS_SUCCESS) {\n    std::cerr << \"Failed to create code object reader '\" << filename << \"'\" << std::endl;\n    return false;\n  }\n\n  // Create executable.\n  status = hsa_api_.hsa_executable_create_alt(HSA_PROFILE_FULL, HSA_DEFAULT_FLOAT_ROUNDING_MODE_DEFAULT,\n                                     NULL, executable);\n  CHECK_STATUS(\"Error in creating executable object\", status);\n\n  // Load code object.\n  status = hsa_api_.hsa_executable_load_agent_code_object(*executable, agent_info->dev_id, code_obj_rdr,\n                                                 NULL, NULL);\n  CHECK_STATUS(\"Error in loading executable object\", status);\n\n  // Freeze executable.\n  status = hsa_api_.hsa_executable_freeze(*executable, \"\");\n  CHECK_STATUS(\"Error in freezing executable object\", status);\n\n  // Get symbol handle.\n  hsa_executable_symbol_t kernelSymbol;\n  status = hsa_api_.hsa_executable_get_symbol(*executable, NULL, kernel_name, agent_info->dev_id, 0,\n                                     &kernelSymbol);\n  CHECK_STATUS(\"Error in looking up kernel symbol\", status);\n\n  // Update output parameter\n  *code_desc = kernelSymbol;\n  return true;\n}\n\n// Print the various fields of Hsa Gpu Agents\nbool HsaRsrcFactory::PrintGpuAgents(const std::string& header) {\n  std::cout << std::flush;\n  std::clog << header << \" :\" << std::endl;\n\n  const AgentInfo* agent_info;\n  int size = uint32_t(gpu_list_.size());\n  for (int idx = 0; idx < size; idx++) {\n    agent_info = gpu_list_[idx];\n\n    std::clog << \"> agent[\" << idx << \"] :\" << std::endl;\n    std::clog << \">> Name : \" << agent_info->name << std::endl;\n    std::clog << \">> APU : \" << agent_info->is_apu << std::endl;\n    std::clog << \">> HSAIL profile : \" << agent_info->profile << std::endl;\n    std::clog << \">> Max Wave Size : \" << agent_info->max_wave_size << std::endl;\n    std::clog << \">> Max Queue Size : \" << agent_info->max_queue_size << std::endl;\n    std::clog << \">> CU number : \" << agent_info->cu_num << std::endl;\n    std::clog << \">> Waves per CU : \" << agent_info->waves_per_cu << std::endl;\n    std::clog << \">> SIMDs per CU : \" << agent_info->simds_per_cu << std::endl;\n    std::clog << \">> SE number : \" << agent_info->se_num << std::endl;\n    std::clog << \">> Shader Arrays per SE : \" << agent_info->shader_arrays_per_se << std::endl;\n  }\n  return true;\n}\n\nuint64_t HsaRsrcFactory::Submit(hsa_queue_t* queue, const void* packet) {\n  const uint32_t slot_size_b = CMD_SLOT_SIZE_B;\n\n  // adevance command queue\n  const uint64_t write_idx = hsa_api_.hsa_queue_load_write_index_relaxed(queue);\n  hsa_api_.hsa_queue_store_write_index_relaxed(queue, write_idx + 1);\n  while ((write_idx - hsa_api_.hsa_queue_load_read_index_relaxed(queue)) >= queue->size) {\n    sched_yield();\n  }\n\n  uint32_t slot_idx = (uint32_t)(write_idx % queue->size);\n  uint32_t* queue_slot = reinterpret_cast<uint32_t*>((uintptr_t)(queue->base_address) + (slot_idx * slot_size_b));\n  const uint32_t* slot_data = reinterpret_cast<const uint32_t*>(packet);\n\n  // Copy buffered commands into the queue slot.\n  // Overwrite the AQL invalid header (first dword) last.\n  // This prevents the slot from being read until it's fully written.\n  memcpy(&queue_slot[1], &slot_data[1], slot_size_b - sizeof(uint32_t));\n  std::atomic<uint32_t>* header_atomic_ptr =\n      reinterpret_cast<std::atomic<uint32_t>*>(&queue_slot[0]);\n  header_atomic_ptr->store(slot_data[0], std::memory_order_release);\n\n  // ringdoor bell\n  hsa_api_.hsa_signal_store_relaxed(queue->doorbell_signal, write_idx);\n\n  return write_idx;\n}\n\nuint64_t HsaRsrcFactory::Submit(hsa_queue_t* queue, const void* packet, size_t size_bytes) {\n  const uint32_t slot_size_b = CMD_SLOT_SIZE_B;\n  if ((size_bytes & (slot_size_b - 1)) != 0) {\n    fprintf(stderr, \"HsaRsrcFactory::Submit: Bad packet size %zx\\n\", size_bytes);\n    abort();\n  }\n\n  const char* begin = reinterpret_cast<const char*>(packet);\n  const char* end = begin + size_bytes;\n  uint64_t write_idx = 0;\n  for (const char* ptr = begin; ptr < end; ptr += slot_size_b) {\n    write_idx = Submit(queue, ptr);\n  }\n\n  return write_idx;\n}\n\nconst char* HsaRsrcFactory::GetKernelNameRef(uint64_t addr) {\n  std::lock_guard<mutex_t> lck(mutex_);\n  const auto it = symbols_map_->find(addr);\n  if (it == symbols_map_->end()) {\n    fprintf(stderr, \"HsaRsrcFactory::kernel addr (0x%lx) is not found\\n\", addr);\n    abort();\n  }\n  return it->second;\n}\n\nvoid HsaRsrcFactory::EnableExecutableTracking(HsaApiTable* table) {\n  std::lock_guard<mutex_t> lck(mutex_);\n  executable_tracking_on_ = true;\n  table->core_->hsa_executable_freeze_fn = hsa_executable_freeze_interceptor;\n}\n\nhsa_status_t HsaRsrcFactory::executable_symbols_cb(hsa_executable_t exec, hsa_executable_symbol_t symbol, void *data) {\n  hsa_symbol_kind_t value = (hsa_symbol_kind_t)0;\n  hsa_status_t status = hsa_api_.hsa_executable_symbol_get_info(symbol, HSA_EXECUTABLE_SYMBOL_INFO_TYPE, &value);\n  CHECK_STATUS(\"Error in getting symbol info\", status);\n  if (value == HSA_SYMBOL_KIND_KERNEL) {\n    uint64_t addr = 0;\n    uint32_t len = 0;\n    status = hsa_api_.hsa_executable_symbol_get_info(symbol, HSA_EXECUTABLE_SYMBOL_INFO_KERNEL_OBJECT, &addr);\n    CHECK_STATUS(\"Error in getting kernel object\", status);\n    status = hsa_api_.hsa_executable_symbol_get_info(symbol, HSA_EXECUTABLE_SYMBOL_INFO_NAME_LENGTH, &len);\n    CHECK_STATUS(\"Error in getting name len\", status);\n    char *name = new char[len + 1];\n    status = hsa_api_.hsa_executable_symbol_get_info(symbol, HSA_EXECUTABLE_SYMBOL_INFO_NAME, name);\n    CHECK_STATUS(\"Error in getting kernel name\", status);\n    name[len] = 0;\n    auto ret = symbols_map_->insert({addr, name});\n    if (ret.second == false) {\n      delete[] ret.first->second;\n      ret.first->second = name;\n    }\n  }\n  return HSA_STATUS_SUCCESS;\n}\n\nhsa_status_t HsaRsrcFactory::hsa_executable_freeze_interceptor(hsa_executable_t executable, const char *options) {\n  std::lock_guard<mutex_t> lck(mutex_);\n  if (symbols_map_ == NULL) symbols_map_ = new symbols_map_t;\n  hsa_status_t status = hsa_api_.hsa_executable_iterate_symbols(executable, executable_symbols_cb, NULL);\n  CHECK_STATUS(\"Error in iterating executable symbols\", status);\n  return hsa_api_.hsa_executable_freeze(executable, options);;\n}\n\nstd::atomic<HsaRsrcFactory*> HsaRsrcFactory::instance_{};\nHsaRsrcFactory::mutex_t HsaRsrcFactory::mutex_;\nHsaRsrcFactory::timestamp_t HsaRsrcFactory::timeout_ns_ = HsaTimer::TIMESTAMP_MAX;\nhsa_pfn_t HsaRsrcFactory::hsa_api_{};\nbool HsaRsrcFactory::executable_tracking_on_ = false;\nHsaRsrcFactory::symbols_map_t* HsaRsrcFactory::symbols_map_ = NULL;\n\n}  // namespace util\n}  // namespace rocprofiler\n",
        "/tmp/vanessa/spack-stage/spack-stage-rocprofiler-dev-3.5.0-gucmlniizd247uuh2s7vpd4nr6jdzlwp/spack-src/src/core/rocprofiler.cpp": "/******************************************************************************\nCopyright (c) 2018 Advanced Micro Devices, Inc. All rights reserved.\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*******************************************************************************/\n\n#include \"inc/rocprofiler.h\"\n\n#include <hsa.h>\n#include <string.h>\n\n#include <sstream>\n#include <vector>\n\n#include \"core/context.h\"\n#include \"core/context_pool.h\"\n#include \"core/hsa_queue.h\"\n#include \"core/hsa_interceptor.h\"\n#include \"core/intercept_queue.h\"\n#include \"core/proxy_queue.h\"\n#include \"core/simple_proxy_queue.h\"\n#include \"util/exception.h\"\n#include \"util/hsa_rsrc_factory.h\"\n#include \"util/logger.h\"\n\n#define PUBLIC_API __attribute__((visibility(\"default\")))\n#define CONSTRUCTOR_API __attribute__((constructor))\n#define DESTRUCTOR_API __attribute__((destructor))\n\n#define API_METHOD_PREFIX                                                                          \\\n  hsa_status_t status = HSA_STATUS_SUCCESS;                                                        \\\n  try {\n\n#define API_METHOD_SUFFIX                                                                          \\\n  }                                                                                                \\\n  catch (std::exception & e) {                                                                     \\\n    ERR_LOGGING(__FUNCTION__ << \"(), \" << e.what());                                               \\\n    status = rocprofiler::GetExcStatus(e);                                                         \\\n  }                                                                                                \\\n  return status;\n\n#define ONLOAD_TRACE(str) \\\n  if (getenv(\"ROCP_ONLOAD_TRACE\")) do { \\\n    std::cout << \"PID(\" << GetPid() << \"): PROF_LIB::\" << __FUNCTION__ << \" \" << str << std::endl << std::flush; \\\n  } while(0);\n#define ONLOAD_TRACE_BEG() ONLOAD_TRACE(\"begin\")\n#define ONLOAD_TRACE_END() ONLOAD_TRACE(\"end\")\n\nstatic inline uint32_t GetPid() { return syscall(__NR_getpid); }\n\n///////////////////////////////////////////////////////////////////////////////////////////////////\n// Internal library methods\n//\nnamespace rocprofiler {\nhsa_status_t CreateQueuePro(\n    hsa_agent_t agent,\n    uint32_t size,\n    hsa_queue_type32_t type,\n    void (*callback)(hsa_status_t status, hsa_queue_t *source, void *data),\n    void *data,\n    uint32_t private_segment_size,\n    uint32_t group_segment_size,\n    hsa_queue_t **queue);\n\ndecltype(hsa_queue_create)* hsa_queue_create_fn;\ndecltype(hsa_queue_destroy)* hsa_queue_destroy_fn;\n\ndecltype(hsa_signal_store_relaxed)* hsa_signal_store_relaxed_fn;\ndecltype(hsa_signal_store_relaxed)* hsa_signal_store_screlease_fn;\n\ndecltype(hsa_queue_load_write_index_relaxed)* hsa_queue_load_write_index_relaxed_fn;\ndecltype(hsa_queue_store_write_index_relaxed)* hsa_queue_store_write_index_relaxed_fn;\ndecltype(hsa_queue_load_read_index_relaxed)* hsa_queue_load_read_index_relaxed_fn;\n\ndecltype(hsa_queue_load_write_index_scacquire)* hsa_queue_load_write_index_scacquire_fn;\ndecltype(hsa_queue_store_write_index_screlease)* hsa_queue_store_write_index_screlease_fn;\ndecltype(hsa_queue_load_read_index_scacquire)* hsa_queue_load_read_index_scacquire_fn;\n\ndecltype(hsa_amd_queue_intercept_create)* hsa_amd_queue_intercept_create_fn;\ndecltype(hsa_amd_queue_intercept_register)* hsa_amd_queue_intercept_register_fn;\n\ndecltype(hsa_memory_allocate)* hsa_memory_allocate_fn;\ndecltype(hsa_memory_assign_agent)* hsa_memory_assign_agent_fn;\ndecltype(hsa_memory_copy)* hsa_memory_copy_fn;\ndecltype(hsa_amd_memory_pool_allocate)* hsa_amd_memory_pool_allocate_fn;\ndecltype(hsa_amd_memory_pool_free)* hsa_amd_memory_pool_free_fn;\ndecltype(hsa_amd_agents_allow_access)* hsa_amd_agents_allow_access_fn;\ndecltype(hsa_amd_memory_async_copy)* hsa_amd_memory_async_copy_fn;\ndecltype(hsa_amd_memory_async_copy_rect)* hsa_amd_memory_async_copy_rect_fn;\ndecltype(hsa_executable_freeze)* hsa_executable_freeze_fn;\ndecltype(hsa_executable_destroy)* hsa_executable_destroy_fn;\n\n::HsaApiTable* kHsaApiTable;\n\nvoid SaveHsaApi(::HsaApiTable* table) {\n  util::HsaRsrcFactory::InitHsaApiTable(table);\n\n  kHsaApiTable = table;\n  hsa_queue_create_fn = table->core_->hsa_queue_create_fn;\n  hsa_queue_destroy_fn = table->core_->hsa_queue_destroy_fn;\n\n  hsa_signal_store_relaxed_fn = table->core_->hsa_signal_store_relaxed_fn;\n  hsa_signal_store_screlease_fn = table->core_->hsa_signal_store_screlease_fn;\n\n  hsa_queue_load_write_index_relaxed_fn = table->core_->hsa_queue_load_write_index_relaxed_fn;\n  hsa_queue_store_write_index_relaxed_fn = table->core_->hsa_queue_store_write_index_relaxed_fn;\n  hsa_queue_load_read_index_relaxed_fn = table->core_->hsa_queue_load_read_index_relaxed_fn;\n\n  hsa_queue_load_write_index_scacquire_fn = table->core_->hsa_queue_load_write_index_scacquire_fn;\n  hsa_queue_store_write_index_screlease_fn = table->core_->hsa_queue_store_write_index_screlease_fn;\n  hsa_queue_load_read_index_scacquire_fn = table->core_->hsa_queue_load_read_index_scacquire_fn;\n\n  hsa_amd_queue_intercept_create_fn = table->amd_ext_->hsa_amd_queue_intercept_create_fn;\n  hsa_amd_queue_intercept_register_fn = table->amd_ext_->hsa_amd_queue_intercept_register_fn;\n}\n\nvoid RestoreHsaApi() {\n  ::HsaApiTable* table = kHsaApiTable;\n  table->core_->hsa_queue_create_fn = hsa_queue_create_fn;\n  table->core_->hsa_queue_destroy_fn = hsa_queue_destroy_fn;\n\n  table->core_->hsa_signal_store_relaxed_fn = hsa_signal_store_relaxed_fn;\n  table->core_->hsa_signal_store_screlease_fn = hsa_signal_store_screlease_fn;\n\n  table->core_->hsa_queue_load_write_index_relaxed_fn = hsa_queue_load_write_index_relaxed_fn;\n  table->core_->hsa_queue_store_write_index_relaxed_fn = hsa_queue_store_write_index_relaxed_fn;\n  table->core_->hsa_queue_load_read_index_relaxed_fn = hsa_queue_load_read_index_relaxed_fn;\n\n  table->core_->hsa_queue_load_write_index_scacquire_fn = hsa_queue_load_write_index_scacquire_fn;\n  table->core_->hsa_queue_store_write_index_screlease_fn = hsa_queue_store_write_index_screlease_fn;\n  table->core_->hsa_queue_load_read_index_scacquire_fn = hsa_queue_load_read_index_scacquire_fn;\n\n  table->amd_ext_->hsa_amd_queue_intercept_create_fn = hsa_amd_queue_intercept_create_fn;\n  table->amd_ext_->hsa_amd_queue_intercept_register_fn = hsa_amd_queue_intercept_register_fn;\n}\n\nvoid StandaloneIntercept() {\n  ::HsaApiTable* table = kHsaApiTable;\n  table->core_->hsa_queue_create_fn = rocprofiler::CreateQueuePro;\n}\n\ntypedef void (*tool_handler_t)();\ntypedef void (*tool_handler_prop_t)(rocprofiler_settings_t*);\nvoid * tool_handle = NULL;\n\n// Load profiling tool library\n// Return true if intercepting mode is enabled\nenum {\n  DISPATCH_INTERCEPT_MODE = 0x1,\n  CODE_OBJ_TRACKING_MODE = 0x2,\n  MEMCOPY_INTERCEPT_MODE = 0x4,\n  HSA_INTERCEPT_MODE = 0x8,\n};\nuint32_t LoadTool() {\n  uint32_t intercept_mode = 0;\n  const char* tool_lib = getenv(\"ROCP_TOOL_LIB\");\n  std::ostringstream oss;\n  if (tool_lib) oss << \"load tool library(\" << tool_lib << \")\";\n  ONLOAD_TRACE(oss.str());\n\n  if (tool_lib) {\n    intercept_mode = DISPATCH_INTERCEPT_MODE;\n\n    tool_handle = dlopen(tool_lib, RTLD_NOW);\n    if (tool_handle == NULL) {\n      fprintf(stderr, \"ROCProfiler: can't load tool library \\\"%s\\\"\\n\", tool_lib);\n      fprintf(stderr, \"%s\\n\", dlerror());\n      abort();\n    }\n    tool_handler_t handler = reinterpret_cast<tool_handler_t>(dlsym(tool_handle, \"OnLoadTool\"));\n    tool_handler_prop_t handler_prop = reinterpret_cast<tool_handler_prop_t>(dlsym(tool_handle, \"OnLoadToolProp\"));\n    if ((handler == NULL) && (handler_prop == NULL)) {\n      fprintf(stderr, \"ROCProfiler: tool library corrupted, OnLoadTool()/OnLoadToolProp() method is expected\\n\");\n      fprintf(stderr, \"%s\\n\", dlerror());\n      abort();\n    }\n    tool_handler_t on_unload_handler = reinterpret_cast<tool_handler_t>(dlsym(tool_handle, \"OnUnloadTool\"));\n    if (on_unload_handler == NULL) {\n      fprintf(stderr, \"ROCProfiler: tool library corrupted, OnUnloadTool() method is expected\\n\");\n      fprintf(stderr, \"%s\\n\", dlerror());\n      abort();\n    }\n\n    rocprofiler_settings_t settings{};\n    settings.intercept_mode = (intercept_mode != 0) ? 1 : 0;\n    settings.trace_size = TraceProfile::GetSize();\n    settings.trace_local = TraceProfile::IsLocal() ? 1: 0;\n    settings.timeout = util::HsaRsrcFactory::GetTimeoutNs();\n    settings.timestamp_on = InterceptQueue::IsTrackerOn() ? 1 : 0;\n\n    if (handler) handler();\n    else if (handler_prop) handler_prop(&settings);\n\n    TraceProfile::SetSize(settings.trace_size);\n    TraceProfile::SetLocal(settings.trace_local != 0);\n    util::HsaRsrcFactory::SetTimeoutNs(settings.timeout);\n    InterceptQueue::TrackerOn(settings.timestamp_on != 0);\n    if (settings.intercept_mode != 0) intercept_mode = DISPATCH_INTERCEPT_MODE;\n    if (settings.code_obj_tracking) intercept_mode |= CODE_OBJ_TRACKING_MODE;\n    if (settings.memcopy_tracking) intercept_mode |= MEMCOPY_INTERCEPT_MODE;\n    if (settings.hsa_intercepting) intercept_mode |= HSA_INTERCEPT_MODE;\n  }\n\n  ONLOAD_TRACE(\"end intercept_mode(\" << intercept_mode << \")\");\n  return intercept_mode;\n}\n\n// Unload profiling tool librray\nvoid UnloadTool() {\n  ONLOAD_TRACE(\"tool handle(\" << tool_handle << \")\");\n  if (tool_handle) {\n    tool_handler_t handler = reinterpret_cast<tool_handler_t>(dlsym(tool_handle, \"OnUnloadTool\"));\n    if (handler == NULL) {\n      fprintf(stderr, \"ROCProfiler error: tool library corrupted, OnUnloadTool() method is expected\\n\");\n      fprintf(stderr, \"%s\\n\", dlerror());\n      abort();\n    }\n    handler();\n    dlclose(tool_handle);\n  }\n  ONLOAD_TRACE_END();\n}\n\nCONSTRUCTOR_API void constructor() {\n  ONLOAD_TRACE_BEG();\n  util::Logger::Create();\n  ONLOAD_TRACE_END();\n}\n\nDESTRUCTOR_API void destructor() {\n  ONLOAD_TRACE_BEG();\n  rocprofiler::MetricsDict::Destroy();\n  util::HsaRsrcFactory::Destroy();\n  util::Logger::Destroy();\n  ONLOAD_TRACE_END();\n}\n\nconst MetricsDict* GetMetrics(const hsa_agent_t& agent) {\n  rocprofiler::util::HsaRsrcFactory* hsa_rsrc = &rocprofiler::util::HsaRsrcFactory::Instance();\n  const rocprofiler::util::AgentInfo* agent_info = hsa_rsrc->GetAgentInfo(agent);\n  if (agent_info == NULL) EXC_RAISING(HSA_STATUS_ERROR, \"agent is not found\");\n  const MetricsDict* metrics = MetricsDict::Create(agent_info);\n  if (metrics == NULL) EXC_RAISING(HSA_STATUS_ERROR, \"MetricsDict create failed\");\n  return metrics;\n}\n\nhsa_status_t GetExcStatus(const std::exception& e) {\n  const util::exception* rocprofiler_exc_ptr = dynamic_cast<const util::exception*>(&e);\n  return (rocprofiler_exc_ptr) ? static_cast<hsa_status_t>(rocprofiler_exc_ptr->status())\n                               : HSA_STATUS_ERROR;\n}\n\ninline size_t CreateEnableCmd(const rocprofiler::util::AgentInfo* agent_info, packet_t* command, const size_t& slot_count) {\n  const bool is_legacy = (strncmp(agent_info->name, \"gfx8\", 4) == 0);\n  const size_t packet_count = (is_legacy) ? Profile::LEGACY_SLOT_SIZE_PKT : 1;\n\n  rocprofiler::util::HsaRsrcFactory* hsa_rsrc = &rocprofiler::util::HsaRsrcFactory::Instance();\n\n  if (packet_count > slot_count) EXC_RAISING(HSA_STATUS_ERROR, \"packet_count > slot_count\");\n\n  // AQLprofile object\n  hsa_ven_amd_aqlprofile_profile_t profile{};\n  profile.agent = agent_info->dev_id;\n  // Query for cmd buffer size\n  hsa_status_t status = hsa_rsrc->AqlProfileApi()->hsa_ven_amd_aqlprofile_get_info(\n    &profile, HSA_VEN_AMD_AQLPROFILE_INFO_ENABLE_CMD, NULL);\n  if (status != HSA_STATUS_SUCCESS) EXC_RAISING(status, \"get_info(ENABLE_CMD).size exc\");\n  if (profile.command_buffer.size == 0) EXC_RAISING(status, \"get_info(ENABLE_CMD).size == 0\");\n  // Allocate cmd buffer\n  const size_t aligment_mask = 0x100 - 1;\n  profile.command_buffer.ptr =\n    hsa_rsrc->AllocateSysMemory(agent_info, profile.command_buffer.size);\n  if ((reinterpret_cast<uintptr_t>(profile.command_buffer.ptr) & aligment_mask) != 0) {\n    EXC_RAISING(status, \"profile.command_buffer.ptr bad alignment\");\n  }\n\n  // Generating cmd packet\n  if (is_legacy) {\n    packet_t packet{};\n\n    // Query for cmd buffer data\n    status = hsa_rsrc->AqlProfileApi()->hsa_ven_amd_aqlprofile_get_info(\n      &profile, HSA_VEN_AMD_AQLPROFILE_INFO_ENABLE_CMD, &packet);\n    if (status != HSA_STATUS_SUCCESS) EXC_RAISING(status, \"get_info(ENABLE_CMD).data exc\");\n\n    // Check for legacy GFXIP\n    status = hsa_rsrc->AqlProfileApi()->hsa_ven_amd_aqlprofile_legacy_get_pm4(&packet, command);\n    if (status != HSA_STATUS_SUCCESS) AQL_EXC_RAISING(status, \"hsa_ven_amd_aqlprofile_legacy_get_pm4\");\n  } else {\n    // Query for cmd buffer data\n    status = hsa_rsrc->AqlProfileApi()->hsa_ven_amd_aqlprofile_get_info(\n      &profile, HSA_VEN_AMD_AQLPROFILE_INFO_ENABLE_CMD, command);\n    if (status != HSA_STATUS_SUCCESS) EXC_RAISING(status, \"get_info(ENABLE_CMD).data exc\");\n  }\n\n  // Return cmd packet data size\n  return (packet_count * sizeof(packet_t));\n}\n\nhsa_status_t CreateQueuePro(\n    hsa_agent_t agent,\n    uint32_t size,\n    hsa_queue_type32_t type,\n    void (*callback)(hsa_status_t status, hsa_queue_t *source, void *data),\n    void *data,\n    uint32_t private_segment_size,\n    uint32_t group_segment_size,\n    hsa_queue_t **queue)\n{\n  typedef std::pair<packet_t[Profile::LEGACY_SLOT_SIZE_PKT], uint32_t> cmd_entry_t;\n  typedef std::vector<cmd_entry_t> cmd_vec_t;\n  static cmd_vec_t cmd_vec;\n  static uint32_t cmd_mask = 0;\n  static std::mutex cmd_mutex;\n\n  rocprofiler::util::HsaRsrcFactory* hsa_rsrc = &rocprofiler::util::HsaRsrcFactory::Instance();\n\n  // Create HSA queue\n  hsa_status_t status = hsa_queue_create_fn(\n    agent,\n    size,\n    type,\n    callback,\n    data,\n    private_segment_size,\n    group_segment_size,\n    queue);\n  if (status != HSA_STATUS_SUCCESS) return status;\n\n  // Create 'Enable' cmd packet\n  const rocprofiler::util::AgentInfo* agent_info = hsa_rsrc->GetAgentInfo(agent);\n  const uint32_t dev_index = 1 << agent_info->dev_index;\n  const uint32_t dev_mask = 1 << dev_index;\n  if ((cmd_mask & dev_mask) == 0) {\n    std::lock_guard<std::mutex> lck(cmd_mutex);\n\n    if ((cmd_mask & dev_mask) == 0) {\n      cmd_mask |= dev_mask;\n      // Allocating cmd vector\n      uint32_t mask = 1;\n      while (1) {\n        const uint32_t max = 1 << cmd_vec.size();\n        if (mask >= max) cmd_vec.push_back({});\n        if (((mask & dev_mask) != 0) || (mask == 0)) break;\n        mask <<= 1;\n      }\n      if (mask == 0) EXC_RAISING(status, \"bad device index (\" << dev_index << \")\");\n      // Creating cmd packets\n      cmd_vec[dev_index].second = CreateEnableCmd(agent_info, cmd_vec[dev_index].first, Profile::LEGACY_SLOT_SIZE_PKT);\n    }\n  }\n\n  // Enable counters for the queue\n  rocprofiler::util::HsaRsrcFactory::Instance().Submit(*queue, cmd_vec[dev_index].first, cmd_vec[dev_index].second);\n\n  return HSA_STATUS_SUCCESS;\n}\n\nbool async_copy_handler(hsa_signal_value_t value, void* arg) {\n  Tracker::entry_t* entry = reinterpret_cast<Tracker::entry_t*>(arg);\n  printf(\"%lu: async-copy time(%lu,%lu)\\n\", entry->index, entry->record->begin, entry->record->end);\n  return false;\n}\n\nhsa_status_t hsa_amd_memory_async_copy_interceptor(\n    void* dst, hsa_agent_t dst_agent, const void* src,\n    hsa_agent_t src_agent, size_t size, uint32_t num_dep_signals,\n    const hsa_signal_t* dep_signals, hsa_signal_t completion_signal)\n{\n  Tracker* tracker = &Tracker::Instance();\n  Tracker::entry_t* tracker_entry = tracker->Alloc(hsa_agent_t{}, completion_signal);\n  hsa_status_t status = hsa_amd_memory_async_copy_fn(dst, dst_agent, src,\n                                                     src_agent, size, num_dep_signals,\n                                                     dep_signals, tracker_entry->signal);\n  if (status == HSA_STATUS_SUCCESS) {\n    tracker->EnableMemcopy(tracker_entry, async_copy_handler, reinterpret_cast<void*>(tracker_entry));\n  } else {\n    tracker->Delete(tracker_entry);\n  }\n  return status;\n}\n\nhsa_status_t hsa_amd_memory_async_copy_rect_interceptor(\n    const hsa_pitched_ptr_t* dst, const hsa_dim3_t* dst_offset, const hsa_pitched_ptr_t* src,\n    const hsa_dim3_t* src_offset, const hsa_dim3_t* range, hsa_agent_t copy_agent,\n    hsa_amd_copy_direction_t dir, uint32_t num_dep_signals, const hsa_signal_t* dep_signals,\n    hsa_signal_t completion_signal)\n{\n  Tracker* tracker = &Tracker::Instance();\n  Tracker::entry_t* tracker_entry = tracker->Alloc(hsa_agent_t{}, completion_signal);\n  hsa_status_t status = hsa_amd_memory_async_copy_rect_fn(dst, dst_offset, src,\n                                                          src_offset, range, copy_agent,\n                                                          dir, num_dep_signals, dep_signals,\n                                                          tracker_entry->signal);\n  if (status == HSA_STATUS_SUCCESS) {\n    tracker->EnableMemcopy(tracker_entry, async_copy_handler, reinterpret_cast<void*>(tracker_entry));\n  } else {\n    tracker->Delete(tracker_entry);\n  }\n  return status;\n}\n\nrocprofiler_properties_t rocprofiler_properties;\nuint32_t TraceProfile::output_buffer_size_ = 0x2000000;  // 32M\nbool TraceProfile::output_buffer_local_ = true;\nstd::atomic<Tracker*> Tracker::instance_{};\nTracker::mutex_t Tracker::glob_mutex_;\nTracker::counter_t Tracker::counter_ = 0;\nutil::Logger::mutex_t util::Logger::mutex_;\nstd::atomic<util::Logger*> util::Logger::instance_{};\n}\n\n///////////////////////////////////////////////////////////////////////////////////////////////////\n// Public library methods\n//\nextern \"C\" {\n\n// HSA-runtime tool on-load method\nPUBLIC_API bool OnLoad(HsaApiTable* table, uint64_t runtime_version, uint64_t failed_tool_count,\n                       const char* const* failed_tool_names) {\n  ONLOAD_TRACE_BEG();\n  rocprofiler::SaveHsaApi(table);\n  rocprofiler::ProxyQueue::InitFactory();\n  bool intercept_mode = false;\n\n  // Checking environment to enable intercept mode\n  const char* intercept_env = getenv(\"ROCP_HSA_INTERCEPT\");\n  if (intercept_env != NULL) {\n    switch (atoi(intercept_env)) {\n      // Intercepting disabled\n      case 0:\n        intercept_mode = false;\n        rocprofiler::InterceptQueue::TrackerOn(false);\n        break;\n      // Intercepting enabled without timestamping\n      case 1:\n        intercept_mode = true;\n        rocprofiler::InterceptQueue::TrackerOn(false);\n        break;\n      // Intercepting enabled with timestamping\n      case 2:\n        intercept_mode = true;\n        rocprofiler::InterceptQueue::TrackerOn(true);\n        break;\n      default:\n        ERR_LOGGING(\"Bad ROCP_HSA_INTERCEPT env var value (\" << intercept_env << \")\");\n        return false;\n    }\n  }\n\n  // Loading a tool lib and setting of intercept mode\n  const uint32_t intercept_mode_mask = rocprofiler::LoadTool();\n  if (intercept_mode_mask & rocprofiler::DISPATCH_INTERCEPT_MODE) {\n    intercept_mode = true;\n  }\n  if (intercept_mode_mask & rocprofiler::CODE_OBJ_TRACKING_MODE) {\n    if (intercept_mode == false) EXC_RAISING(HSA_STATUS_ERROR, \"code objects tracking without intercept mode enabled\");\n    rocprofiler::util::HsaRsrcFactory::EnableExecutableTracking(table);\n  }\n  if (intercept_mode_mask & rocprofiler::MEMCOPY_INTERCEPT_MODE) {\n    hsa_status_t status = hsa_amd_profiling_async_copy_enable(true);\n    if (status != HSA_STATUS_SUCCESS) EXC_ABORT(status, \"hsa_amd_profiling_async_copy_enable\");\n    rocprofiler::hsa_amd_memory_async_copy_fn = table->amd_ext_->hsa_amd_memory_async_copy_fn;\n    rocprofiler::hsa_amd_memory_async_copy_rect_fn = table->amd_ext_->hsa_amd_memory_async_copy_rect_fn;\n    table->amd_ext_->hsa_amd_memory_async_copy_fn = rocprofiler::hsa_amd_memory_async_copy_interceptor;\n    table->amd_ext_->hsa_amd_memory_async_copy_rect_fn = rocprofiler::hsa_amd_memory_async_copy_rect_interceptor;\n  }\n  if (intercept_mode_mask & rocprofiler::HSA_INTERCEPT_MODE) {\n    if (intercept_mode_mask & rocprofiler::MEMCOPY_INTERCEPT_MODE) {\n      EXC_ABORT(HSA_STATUS_ERROR, \"HSA_INTERCEPT and MEMCOPY_INTERCEPT conflict\");\n    }\n    rocprofiler::HsaInterceptor::Enable(true);\n    rocprofiler::HsaInterceptor::HsaIntercept(table);\n  }\n\n  // HSA intercepting\n  if (intercept_mode) {\n    rocprofiler::ProxyQueue::HsaIntercept(table);\n    rocprofiler::InterceptQueue::HsaIntercept(table);\n  } else {\n    rocprofiler::StandaloneIntercept();\n  }\n\n  ONLOAD_TRACE_END();\n  return true;\n}\n\n// HSA-runtime tool on-unload method\nPUBLIC_API void OnUnload() {\n  ONLOAD_TRACE_BEG();\n  rocprofiler::UnloadTool();\n  rocprofiler::RestoreHsaApi();\n  ONLOAD_TRACE_END();\n}\n\n// Returns library vesrion\nPUBLIC_API uint32_t rocprofiler_version_major() { return ROCPROFILER_VERSION_MAJOR; }\nPUBLIC_API uint32_t rocprofiler_version_minor() { return ROCPROFILER_VERSION_MINOR; }\n\n// Returns the last error message\nPUBLIC_API hsa_status_t rocprofiler_error_string(const char** str) {\n  API_METHOD_PREFIX\n  *str = rocprofiler::util::Logger::LastMessage().c_str();\n  API_METHOD_SUFFIX\n}\n\n// Create new profiling context\nPUBLIC_API hsa_status_t rocprofiler_open(hsa_agent_t agent, rocprofiler_feature_t* features,\n                                         uint32_t feature_count, rocprofiler_t** handle, uint32_t mode,\n                                         rocprofiler_properties_t* properties) {\n  API_METHOD_PREFIX\n  rocprofiler::util::HsaRsrcFactory* hsa_rsrc = &rocprofiler::util::HsaRsrcFactory::Instance();\n  const rocprofiler::util::AgentInfo* agent_info = hsa_rsrc->GetAgentInfo(agent);\n  if (agent_info == NULL) {\n    EXC_RAISING(HSA_STATUS_ERROR, \"agent is not found\");\n  }\n\n  rocprofiler::Queue* queue = NULL;\n  if (mode != 0) {\n    if (mode & ROCPROFILER_MODE_STANDALONE) {\n      if (mode & ROCPROFILER_MODE_CREATEQUEUE) {\n        if (hsa_rsrc->CreateQueue(agent_info, properties->queue_depth, &(properties->queue)) ==\n            false) {\n          EXC_RAISING(HSA_STATUS_ERROR, \"CreateQueue() failed\");\n        }\n      }\n      queue = new rocprofiler::HsaQueue(agent_info, properties->queue);\n    } else {\n      EXC_RAISING(HSA_STATUS_ERROR, \"invalid mode (\" << mode << \")\");\n    }\n  }\n\n  rocprofiler::Context** context_ret = reinterpret_cast<rocprofiler::Context**>(handle);\n  *context_ret = rocprofiler::Context::Create(agent_info, queue, features, feature_count,\n                                              properties->handler, properties->handler_arg);\n  API_METHOD_SUFFIX\n}\n\n// Delete profiling info\nPUBLIC_API hsa_status_t rocprofiler_close(rocprofiler_t* handle) {\n  API_METHOD_PREFIX\n  rocprofiler::Context* context = reinterpret_cast<rocprofiler::Context*>(handle);\n  if (context) rocprofiler::Context::Destroy(context);\n  API_METHOD_SUFFIX\n}\n\n// Reset context\nPUBLIC_API hsa_status_t rocprofiler_reset(rocprofiler_t* handle, uint32_t group_index) {\n  API_METHOD_PREFIX\n  rocprofiler::Context* context = reinterpret_cast<rocprofiler::Context*>(handle);\n  context->Reset(group_index);\n  API_METHOD_SUFFIX\n}\n\n// Return context agent\nPUBLIC_API hsa_status_t rocprofiler_get_agent(rocprofiler_t* handle, hsa_agent_t* agent) {\n  API_METHOD_PREFIX\n  rocprofiler::Context* context = reinterpret_cast<rocprofiler::Context*>(handle);\n  *agent = context->GetAgent();\n  API_METHOD_SUFFIX\n}\n\n// Get profiling group count\nPUBLIC_API hsa_status_t rocprofiler_group_count(const rocprofiler_t* handle,\n                                                uint32_t* group_count) {\n  API_METHOD_PREFIX\n  const rocprofiler::Context* context = reinterpret_cast<const rocprofiler::Context*>(handle);\n  *group_count = context->GetGroupCount();\n  API_METHOD_SUFFIX\n}\n\n// Get profiling group for a given group index\nPUBLIC_API hsa_status_t rocprofiler_get_group(rocprofiler_t* handle, uint32_t group_index,\n                                              rocprofiler_group_t* group) {\n  API_METHOD_PREFIX\n  rocprofiler::Context* context = reinterpret_cast<rocprofiler::Context*>(handle);\n  *group = context->GetGroupInfo(group_index);\n  API_METHOD_SUFFIX\n}\n\n// Start profiling\nPUBLIC_API hsa_status_t rocprofiler_start(rocprofiler_t* handle, uint32_t group_index) {\n  API_METHOD_PREFIX\n  rocprofiler::Context* context = reinterpret_cast<rocprofiler::Context*>(handle);\n  context->Start(group_index);\n  API_METHOD_SUFFIX\n}\n\n// Stop profiling\nPUBLIC_API hsa_status_t rocprofiler_stop(rocprofiler_t* handle, uint32_t group_index) {\n  API_METHOD_PREFIX\n  rocprofiler::Context* context = reinterpret_cast<rocprofiler::Context*>(handle);\n  context->Stop(group_index);\n  API_METHOD_SUFFIX\n}\n\n// Read profiling\nPUBLIC_API hsa_status_t rocprofiler_read(rocprofiler_t* handle, uint32_t group_index) {\n  API_METHOD_PREFIX\n  rocprofiler::Context* context = reinterpret_cast<rocprofiler::Context*>(handle);\n  context->Read(group_index);\n  API_METHOD_SUFFIX\n}\n\n// Get profiling data\nPUBLIC_API hsa_status_t rocprofiler_get_data(rocprofiler_t* handle, uint32_t group_index) {\n  API_METHOD_PREFIX\n  rocprofiler::Context* context = reinterpret_cast<rocprofiler::Context*>(handle);\n  context->GetData(group_index);\n  API_METHOD_SUFFIX\n}\n\n// Start profiling\nPUBLIC_API hsa_status_t rocprofiler_group_start(rocprofiler_group_t* group) {\n  API_METHOD_PREFIX\n  rocprofiler_start(group->context, group->index);\n  API_METHOD_SUFFIX\n}\n\n// Stop profiling\nPUBLIC_API hsa_status_t rocprofiler_group_stop(rocprofiler_group_t* group) {\n  API_METHOD_PREFIX\n  rocprofiler_stop(group->context, group->index);\n  API_METHOD_SUFFIX\n}\n\n// Read profiling\nPUBLIC_API hsa_status_t rocprofiler_group_read(rocprofiler_group_t* group) {\n  API_METHOD_PREFIX\n  rocprofiler_read(group->context, group->index);\n  API_METHOD_SUFFIX\n}\n\n// Get profiling data\nPUBLIC_API hsa_status_t rocprofiler_group_get_data(rocprofiler_group_t* group) {\n  API_METHOD_PREFIX\n  rocprofiler::Context* context = reinterpret_cast<rocprofiler::Context*>(group->context);\n  context->GetData(group->index);\n  API_METHOD_SUFFIX\n}\n\n// Get metrics data\nPUBLIC_API hsa_status_t rocprofiler_get_metrics(const rocprofiler_t* handle) {\n  API_METHOD_PREFIX\n  const rocprofiler::Context* context = reinterpret_cast<const rocprofiler::Context*>(handle);\n  context->GetMetricsData();\n  API_METHOD_SUFFIX\n}\n\n// Set/remove queue callbacks\nPUBLIC_API hsa_status_t rocprofiler_set_queue_callbacks(rocprofiler_queue_callbacks_t callbacks, void* data) {\n  API_METHOD_PREFIX\n  rocprofiler::InterceptQueue::SetCallbacks(callbacks, data);\n  API_METHOD_SUFFIX\n}\n\n// Remove queue callbacks\nPUBLIC_API hsa_status_t rocprofiler_remove_queue_callbacks() {\n  API_METHOD_PREFIX\n  rocprofiler::InterceptQueue::RemoveCallbacks();\n  API_METHOD_SUFFIX\n}\n\n// Start/stop queue callbacks\nPUBLIC_API hsa_status_t rocprofiler_start_queue_callbacks() {\n  API_METHOD_PREFIX\n  rocprofiler::InterceptQueue::Start();\n  API_METHOD_SUFFIX\n}\nPUBLIC_API hsa_status_t rocprofiler_stop_queue_callbacks() {\n  API_METHOD_PREFIX\n  rocprofiler::InterceptQueue::Stop();\n  API_METHOD_SUFFIX\n}\n\n// Method for iterating the events output data\nPUBLIC_API hsa_status_t rocprofiler_iterate_trace_data(\n    rocprofiler_t* handle, hsa_ven_amd_aqlprofile_data_callback_t callback, void* data) {\n  API_METHOD_PREFIX\n  rocprofiler::Context* context = reinterpret_cast<rocprofiler::Context*>(handle);\n  context->IterateTraceData(callback, data);\n  API_METHOD_SUFFIX\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Open profiling pool\nPUBLIC_API hsa_status_t rocprofiler_pool_open(hsa_agent_t agent,        // GPU handle\n                                   rocprofiler_feature_t* features,     // [in] profiling features array\n                                   uint32_t feature_count,              // profiling info count\n                                   rocprofiler_pool_t** pool,           // [out] context object\n                                   uint32_t mode,                       // profiling mode mask\n                                   rocprofiler_pool_properties_t* properties)  // pool properties\n{\n  API_METHOD_PREFIX\n  rocprofiler::util::HsaRsrcFactory* hsa_rsrc = &rocprofiler::util::HsaRsrcFactory::Instance();\n  const rocprofiler::util::AgentInfo* agent_info = hsa_rsrc->GetAgentInfo(agent);\n  if (agent_info == NULL) {\n    EXC_RAISING(HSA_STATUS_ERROR, \"agent is not found\");\n  }\n\n  rocprofiler::ContextPool* obj = rocprofiler::ContextPool::Create(\n    properties->num_entries,\n    properties->payload_bytes,\n    agent_info,\n    features,\n    feature_count,\n    properties->handler,\n    properties->handler_arg\n  );\n  *pool = reinterpret_cast<rocprofiler_pool_t*>(obj);\n  API_METHOD_SUFFIX\n}\n\n// Close profiling pool\nPUBLIC_API hsa_status_t rocprofiler_pool_close(rocprofiler_pool_t* pool)  // profiling pool handle\n{\n  API_METHOD_PREFIX\n  rocprofiler::ContextPool* obj = reinterpret_cast<rocprofiler::ContextPool*>(pool);\n  rocprofiler::ContextPool::Destroy(obj);\n  API_METHOD_SUFFIX\n}\n\n// Fetch profiling pool entry\nPUBLIC_API hsa_status_t rocprofiler_pool_fetch(rocprofiler_pool_t* pool,  // profiling pool handle\n                                    rocprofiler_pool_entry_t* entry)      // [out] empty profling pool entry\n{\n  API_METHOD_PREFIX\n  rocprofiler::ContextPool* context_pool = reinterpret_cast<rocprofiler::ContextPool*>(pool);\n  context_pool->Fetch(entry);\n  API_METHOD_SUFFIX\n}\n\n// Fetch profiling pool entry\nPUBLIC_API hsa_status_t rocprofiler_pool_flush(rocprofiler_pool_t* pool)  // profiling pool handle\n{\n  API_METHOD_PREFIX\n  rocprofiler::ContextPool* context_pool = reinterpret_cast<rocprofiler::ContextPool*>(pool);\n  context_pool->Flush();\n  API_METHOD_SUFFIX\n}\n\n////////////////////////////////////////////////////////////////////////////////\n// Return the info for a given info kind\nPUBLIC_API hsa_status_t rocprofiler_get_info(\n  const hsa_agent_t *agent,\n  rocprofiler_info_kind_t kind,\n  void *data)\n{\n  API_METHOD_PREFIX\n  if (agent == NULL) EXC_RAISING(HSA_STATUS_ERROR, \"NULL agent\");\n  uint32_t* result_32bit_ptr = reinterpret_cast<uint32_t*>(data);\n\n  switch (kind) {\n    case ROCPROFILER_INFO_KIND_METRIC_COUNT:\n      *result_32bit_ptr = rocprofiler::GetMetrics(*agent)->Size();\n      break;\n    case ROCPROFILER_INFO_KIND_TRACE_COUNT:\n      *result_32bit_ptr = 1;\n      break;\n    default:\n      EXC_RAISING(HSA_STATUS_ERROR, \"unknown info kind(\" << kind << \")\");\n  }\n  API_METHOD_SUFFIX\n}\n\n// Iterate over the info for a given info kind, and invoke an application-defined callback on every iteration\nPUBLIC_API hsa_status_t rocprofiler_iterate_info(\n  const hsa_agent_t* agent,\n  rocprofiler_info_kind_t kind,\n  hsa_status_t (*callback)(const rocprofiler_info_data_t info, void* data),\n  void* data)\n{\n  API_METHOD_PREFIX\n  rocprofiler::util::HsaRsrcFactory* hsa_rsrc = &rocprofiler::util::HsaRsrcFactory::Instance();\n  rocprofiler_info_data_t info{};\n  info.kind = kind;\n  uint32_t agent_idx = 0;\n  uint32_t agent_max = 0;\n  const rocprofiler::util::AgentInfo* agent_info = NULL;\n\n  if (agent != NULL) {\n    agent_info = hsa_rsrc->GetAgentInfo(*agent);\n    agent_idx = agent_info->dev_index;\n    agent_max = agent_idx + 1;\n  }\n\n  while (hsa_rsrc->GetGpuAgentInfo(agent_idx, &agent_info)) {\n    info.agent_index = agent_idx;\n\n    switch (kind) {\n      case ROCPROFILER_INFO_KIND_METRIC:\n      {\n        const rocprofiler::MetricsDict* dict = rocprofiler::GetMetrics(agent_info->dev_id);\n        auto nodes_vec = dict->GetNodes();\n\n        for (auto* node : nodes_vec) {\n          const std::string& name = node->opts[\"name\"];\n          const std::string& descr = node->opts[\"descr\"];\n          const std::string& expr = node->opts[\"expr\"];\n          info.metric.name = strdup(name.c_str());\n          info.metric.description = strdup(descr.c_str());\n          info.metric.expr = expr.empty() ? NULL : strdup(expr.c_str());\n          info.metric.instances = 1;\n\n          if (expr.empty()) {\n            // Getting the block name\n            const std::string block_name = node->opts[\"block\"];\n\n            // Querying profile\n            rocprofiler::profile_t profile = {};\n            profile.agent = agent_info->dev_id;\n            profile.type = HSA_VEN_AMD_AQLPROFILE_EVENT_TYPE_PMC;\n\n            // Query block id info\n            hsa_ven_amd_aqlprofile_id_query_t query = {block_name.c_str(), 0, 0};\n            hsa_status_t status = rocprofiler::util::HsaRsrcFactory::Instance().AqlProfileApi()->hsa_ven_amd_aqlprofile_get_info(\n              &profile, HSA_VEN_AMD_AQLPROFILE_INFO_BLOCK_ID, &query);\n            if (status != HSA_STATUS_SUCCESS) AQL_EXC_RAISING(HSA_STATUS_ERROR, \"get block id info: '\" << block_name << \"'\");\n\n            // Metric object\n            const std::string metric_name = (query.instance_count > 1) ? name + \"[0]\" : name;\n            const rocprofiler::Metric* metric = dict->Get(metric_name);\n            if (metric == NULL) EXC_RAISING(HSA_STATUS_ERROR, \"metric '\" << name << \"' is not found\");\n\n            // Process metrics counters\n            const rocprofiler::counters_vec_t& counters_vec = metric->GetCounters();\n            if (counters_vec.size() != 1) EXC_RAISING(HSA_STATUS_ERROR, \"error: '\" << metric->GetName() << \"' is not basic\");\n\n            // Query block counters number\n            uint32_t block_counters;\n            profile.events = &(counters_vec[0]->event);\n            status = rocprofiler::util::HsaRsrcFactory::Instance().AqlProfileApi()->hsa_ven_amd_aqlprofile_get_info(\n              &profile, HSA_VEN_AMD_AQLPROFILE_INFO_BLOCK_COUNTERS, &block_counters);\n            if (status != HSA_STATUS_SUCCESS) continue;\n\n            info.metric.instances = query.instance_count;\n            info.metric.block_name = block_name.c_str();\n            info.metric.block_counters = block_counters;\n          }\n\n          status = callback(info, data);\n          if (status != HSA_STATUS_SUCCESS) break;\n        }\n        break;\n      }\n      case ROCPROFILER_INFO_KIND_TRACE:\n      {\n        info.trace.name = strdup(\"TT\");\n        info.trace.description = strdup(\"Thread Trace\");\n        info.trace.parameter_count = 5;\n        status = callback(info, data);\n        if (status != HSA_STATUS_SUCCESS) break;\n        break;\n      }\n      default:\n        EXC_RAISING(HSA_STATUS_ERROR, \"unknown info kind(\" << kind << \")\");\n    }\n\n    ++agent_idx;\n    if (agent_idx == agent_max) break;\n  }\n\n  if (status == HSA_STATUS_INFO_BREAK) status = HSA_STATUS_SUCCESS;\n  if (status != HSA_STATUS_SUCCESS) ERR_LOGGING(\"iterate_info error, info kind(\" << kind << \")\");\n\n  API_METHOD_SUFFIX\n}\n\n// Iterate over the info for a given info query, and invoke an application-defined callback on every iteration\nPUBLIC_API hsa_status_t rocprofiler_query_info(\n  const hsa_agent_t *agent,\n  rocprofiler_info_query_t query,\n  hsa_status_t (*callback)(const rocprofiler_info_data_t info, void *data),\n  void *data)\n{\n  API_METHOD_PREFIX\n  EXC_RAISING(HSA_STATUS_ERROR, \"Not implemented\");\n  API_METHOD_SUFFIX\n}\n\n// Creates a profiled queue. All dispatches on this queue will be profiled\nPUBLIC_API hsa_status_t rocprofiler_queue_create_profiled(\n    hsa_agent_t agent, uint32_t size, hsa_queue_type32_t type,\n    void (*callback)(hsa_status_t status, hsa_queue_t* source, void* data),\n    void* data, uint32_t private_segment_size, uint32_t group_segment_size,\n    hsa_queue_t** queue)\n{\n  API_METHOD_PREFIX\n  status = rocprofiler::InterceptQueue::QueueCreateTracked(\n    agent, size, type, callback, data, private_segment_size, group_segment_size, queue);\n  API_METHOD_SUFFIX\n}\n\n// Return time value for a given time ID and profiling timestamp\nPUBLIC_API hsa_status_t rocprofiler_get_time(\n  rocprofiler_time_id_t time_id,\n  uint64_t timestamp,\n  uint64_t* value_ns,\n  uint64_t* error_ns)\n{\n  API_METHOD_PREFIX\n  if (error_ns != NULL) {\n    *error_ns = 0;\n    status = rocprofiler::util::HsaRsrcFactory::Instance().GetTimeErr(time_id, error_ns);\n  }\n  if ((status == HSA_STATUS_SUCCESS) && (value_ns != NULL)) {\n    *value_ns = 0;\n    status = rocprofiler::util::HsaRsrcFactory::Instance().GetTimeVal(time_id, timestamp, value_ns);\n  }\n  API_METHOD_SUFFIX\n}\n\n}  // extern \"C\"\n\n///////////////////////////////////////////////////////////////////////////////////////////////////\n// HSA API callbacks routines\n//\nbool rocprofiler::HsaInterceptor::enable_ = false;\nthread_local bool rocprofiler::HsaInterceptor::recursion_ = false;;\nrocprofiler_hsa_callbacks_t rocprofiler::HsaInterceptor::callbacks_{};\nrocprofiler::HsaInterceptor::arg_t rocprofiler::HsaInterceptor::arg_{};\nhsa_ven_amd_loader_1_01_pfn_t rocprofiler::HsaInterceptor::LoaderApiTable{};\nrocprofiler::HsaInterceptor::mutex_t rocprofiler::HsaInterceptor::mutex_;\n\n// Set HSA callbacks. If a callback is NULL then it is disabled\nextern \"C\" PUBLIC_API hsa_status_t rocprofiler_set_hsa_callbacks(const rocprofiler_hsa_callbacks_t callbacks, void* arg) {\n  API_METHOD_PREFIX\n  rocprofiler::HsaInterceptor::SetCallbacks(callbacks, arg);\n  rocprofiler::InterceptQueue::SetSubmitCallback(callbacks.submit, arg);\n  API_METHOD_SUFFIX\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-rocprofiler-dev-3.5.0-gucmlniizd247uuh2s7vpd4nr6jdzlwp/spack-src/roctracer/src/util/hsa_rsrc_factory.cpp": "/**********************************************************************\nCopyright \u00a92013 Advanced Micro Devices, Inc. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification, are permitted\nprovided that the following conditions are met:\n\n<95>    Redistributions of source code must retain the above copyright notice, this list of\nconditions and the following disclaimer.\n<95>    Redistributions in binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\n other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\nIMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT\nSHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY\n DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\nWHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n********************************************************************/\n\n#include \"util/hsa_rsrc_factory.h\"\n\n#include <dlfcn.h>\n#include <fcntl.h>\n#include <hsa.h>\n#include <hsa_ext_amd.h>\n#include <hsa_ext_finalize.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\n#include <atomic>\n#include <cassert>\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <vector>\n\nnamespace util {\n\n// Callback function to get available in the system agents\nhsa_status_t HsaRsrcFactory::GetHsaAgentsCallback(hsa_agent_t agent, void* data) {\n  hsa_status_t status = HSA_STATUS_ERROR;\n  HsaRsrcFactory* hsa_rsrc = reinterpret_cast<HsaRsrcFactory*>(data);\n  const AgentInfo* agent_info = hsa_rsrc->AddAgentInfo(agent);\n  if (agent_info != NULL) status = HSA_STATUS_SUCCESS;\n  return status;\n}\n\n// This function checks to see if the provided\n// pool has the HSA_AMD_SEGMENT_GLOBAL property. If the kern_arg flag is true,\n// the function adds an additional requirement that the pool have the\n// HSA_AMD_MEMORY_POOL_GLOBAL_FLAG_KERNARG_INIT property. If kern_arg is false,\n// pools must NOT have this property.\n// Upon finding a pool that meets these conditions, HSA_STATUS_INFO_BREAK is\n// returned. HSA_STATUS_SUCCESS is returned if no errors were encountered, but\n// no pool was found meeting the requirements. If an error is encountered, we\n// return that error.\nstatic hsa_status_t FindGlobalPool(hsa_amd_memory_pool_t pool, void* data, bool kern_arg) {\n  hsa_status_t err;\n  hsa_amd_segment_t segment;\n  uint32_t flag;\n\n  if (nullptr == data) {\n    return HSA_STATUS_ERROR_INVALID_ARGUMENT;\n  }\n\n  err = HsaRsrcFactory::HsaApi()->hsa_amd_memory_pool_get_info(pool, HSA_AMD_MEMORY_POOL_INFO_SEGMENT, &segment);\n  CHECK_STATUS(\"hsa_amd_memory_pool_get_info\", err);\n  if (HSA_AMD_SEGMENT_GLOBAL != segment) {\n    return HSA_STATUS_SUCCESS;\n  }\n\n  err = HsaRsrcFactory::HsaApi()->hsa_amd_memory_pool_get_info(pool, HSA_AMD_MEMORY_POOL_INFO_GLOBAL_FLAGS, &flag);\n  CHECK_STATUS(\"hsa_amd_memory_pool_get_info\", err);\n\n  uint32_t karg_st = flag & HSA_AMD_MEMORY_POOL_GLOBAL_FLAG_KERNARG_INIT;\n\n  if ((karg_st == 0 && kern_arg) || (karg_st != 0 && !kern_arg)) {\n    return HSA_STATUS_SUCCESS;\n  }\n\n  *(reinterpret_cast<hsa_amd_memory_pool_t*>(data)) = pool;\n  return HSA_STATUS_INFO_BREAK;\n}\n\n// This is the call-back function for hsa_amd_agent_iterate_memory_pools() that\n// finds a pool with the properties of HSA_AMD_SEGMENT_GLOBAL and that is NOT\n// HSA_AMD_MEMORY_POOL_GLOBAL_FLAG_KERNARG_INIT\nhsa_status_t FindStandardPool(hsa_amd_memory_pool_t pool, void* data) {\n  return FindGlobalPool(pool, data, false);\n}\n\n// This is the call-back function for hsa_amd_agent_iterate_memory_pools() that\n// finds a pool with the properties of HSA_AMD_SEGMENT_GLOBAL and that IS\n// HSA_AMD_MEMORY_POOL_GLOBAL_FLAG_KERNARG_INIT\nhsa_status_t FindKernArgPool(hsa_amd_memory_pool_t pool, void* data) {\n  return FindGlobalPool(pool, data, true);\n}\n\n// Constructor of the class\nHsaRsrcFactory::HsaRsrcFactory(bool initialize_hsa) : initialize_hsa_(initialize_hsa) {\n  hsa_status_t status;\n\n  cpu_pool_ = NULL;\n  kern_arg_pool_ = NULL;\n\n  InitHsaApiTable(NULL);\n\n  // Initialize the Hsa Runtime\n  if (initialize_hsa_) {\n    status = hsa_api_.hsa_init();\n    CHECK_STATUS(\"Error in hsa_init\", status);\n  }\n\n  // Discover the set of Gpu devices available on the platform\n  status = hsa_api_.hsa_iterate_agents(GetHsaAgentsCallback, this);\n  CHECK_STATUS(\"Error Calling hsa_iterate_agents\", status);\n  if (cpu_pool_ == NULL) CHECK_STATUS(\"CPU memory pool is not found\", HSA_STATUS_ERROR);\n  if (kern_arg_pool_ == NULL) CHECK_STATUS(\"Kern-arg memory pool is not found\", HSA_STATUS_ERROR);\n\n  // Get AqlProfile API table\n  aqlprofile_api_ = {0};\n#ifdef ROCP_LD_AQLPROFILE\n  status = LoadAqlProfileLib(&aqlprofile_api_);\n#else\n  status = hsa_api_.hsa_system_get_major_extension_table(HSA_EXTENSION_AMD_AQLPROFILE, hsa_ven_amd_aqlprofile_VERSION_MAJOR, sizeof(aqlprofile_api_), &aqlprofile_api_);\n#endif\n  CHECK_STATUS(\"aqlprofile API table load failed\", status);\n\n  // Get Loader API table\n  loader_api_ = {0};\n  status = hsa_api_.hsa_system_get_major_extension_table(HSA_EXTENSION_AMD_LOADER, 1, sizeof(loader_api_), &loader_api_);\n  CHECK_STATUS(\"loader API table query failed\", status);\n\n  // Instantiate HSA timer\n  timer_ = new HsaTimer(&hsa_api_);\n  CHECK_STATUS(\"HSA timer allocation failed\",\n    (timer_ == NULL) ? HSA_STATUS_ERROR : HSA_STATUS_SUCCESS);\n\n  // Time correlation\n  const uint32_t corr_iters = 1000;\n  CorrelateTime(HsaTimer::TIME_ID_CLOCK_REALTIME, corr_iters);\n  CorrelateTime(HsaTimer::TIME_ID_CLOCK_MONOTONIC, corr_iters);\n\n  // System timeout\n  timeout_ = (timeout_ns_ == HsaTimer::TIMESTAMP_MAX) ? timeout_ns_ : timer_->ns_to_sysclock(timeout_ns_);\n}\n\n// Destructor of the class\nHsaRsrcFactory::~HsaRsrcFactory() {\n  delete timer_;\n  for (auto p : cpu_list_) delete p;\n  for (auto p : gpu_list_) delete p;\n  if (initialize_hsa_) {\n    hsa_status_t status = hsa_api_.hsa_shut_down();\n    CHECK_STATUS(\"Error in hsa_shut_down\", status);\n  }\n}\n\nvoid HsaRsrcFactory::InitHsaApiTable(HsaApiTable* table) {\n  std::lock_guard<mutex_t> lck(mutex_);\n\n  if (hsa_api_.hsa_init == NULL) {\n    if (table != NULL) {\n      hsa_api_.hsa_init = table->core_->hsa_init_fn;\n      hsa_api_.hsa_shut_down = table->core_->hsa_shut_down_fn;\n      hsa_api_.hsa_agent_get_info = table->core_->hsa_agent_get_info_fn;\n      hsa_api_.hsa_iterate_agents = table->core_->hsa_iterate_agents_fn;\n\n      hsa_api_.hsa_queue_create = table->core_->hsa_queue_create_fn;\n      hsa_api_.hsa_queue_destroy = table->core_->hsa_queue_destroy_fn;\n      hsa_api_.hsa_queue_load_write_index_relaxed = table->core_->hsa_queue_load_write_index_relaxed_fn;\n      hsa_api_.hsa_queue_store_write_index_relaxed = table->core_->hsa_queue_store_write_index_relaxed_fn;\n      hsa_api_.hsa_queue_load_read_index_relaxed = table->core_->hsa_queue_load_read_index_relaxed_fn;\n\n      hsa_api_.hsa_signal_create = table->core_->hsa_signal_create_fn;\n      hsa_api_.hsa_signal_destroy = table->core_->hsa_signal_destroy_fn;\n      hsa_api_.hsa_signal_load_relaxed = table->core_->hsa_signal_load_relaxed_fn;\n      hsa_api_.hsa_signal_store_relaxed = table->core_->hsa_signal_store_relaxed_fn;\n      hsa_api_.hsa_signal_wait_scacquire = table->core_->hsa_signal_wait_scacquire_fn;\n      hsa_api_.hsa_signal_store_screlease = table->core_->hsa_signal_store_screlease_fn;\n\n      hsa_api_.hsa_code_object_reader_create_from_file = table->core_->hsa_code_object_reader_create_from_file_fn;\n      hsa_api_.hsa_executable_create_alt = table->core_->hsa_executable_create_alt_fn;\n      hsa_api_.hsa_executable_load_agent_code_object = table->core_->hsa_executable_load_agent_code_object_fn;\n      hsa_api_.hsa_executable_freeze = table->core_->hsa_executable_freeze_fn;\n      hsa_api_.hsa_executable_get_symbol = table->core_->hsa_executable_get_symbol_fn;\n      hsa_api_.hsa_executable_symbol_get_info = table->core_->hsa_executable_symbol_get_info_fn;\n      hsa_api_.hsa_executable_iterate_symbols = table->core_->hsa_executable_iterate_symbols_fn;\n\n      hsa_api_.hsa_system_get_info = table->core_->hsa_system_get_info_fn;\n      hsa_api_.hsa_system_get_major_extension_table = table->core_->hsa_system_get_major_extension_table_fn;\n\n      hsa_api_.hsa_amd_agent_iterate_memory_pools = table->amd_ext_->hsa_amd_agent_iterate_memory_pools_fn;\n      hsa_api_.hsa_amd_memory_pool_get_info = table->amd_ext_->hsa_amd_memory_pool_get_info_fn;\n      hsa_api_.hsa_amd_memory_pool_allocate = table->amd_ext_->hsa_amd_memory_pool_allocate_fn;\n      hsa_api_.hsa_amd_agents_allow_access = table->amd_ext_->hsa_amd_agents_allow_access_fn;\n      hsa_api_.hsa_amd_memory_async_copy = table->amd_ext_->hsa_amd_memory_async_copy_fn;\n\n      hsa_api_.hsa_amd_signal_async_handler = table->amd_ext_->hsa_amd_signal_async_handler_fn;\n      hsa_api_.hsa_amd_profiling_set_profiler_enabled = table->amd_ext_->hsa_amd_profiling_set_profiler_enabled_fn;\n      hsa_api_.hsa_amd_profiling_get_async_copy_time = table->amd_ext_->hsa_amd_profiling_get_async_copy_time_fn;\n      hsa_api_.hsa_amd_profiling_get_dispatch_time = table->amd_ext_->hsa_amd_profiling_get_dispatch_time_fn;\n    } else {\n      hsa_api_.hsa_init = hsa_init;\n      hsa_api_.hsa_shut_down = hsa_shut_down;\n      hsa_api_.hsa_agent_get_info = hsa_agent_get_info;\n      hsa_api_.hsa_iterate_agents = hsa_iterate_agents;\n\n      hsa_api_.hsa_queue_create = hsa_queue_create;\n      hsa_api_.hsa_queue_destroy = hsa_queue_destroy;\n      hsa_api_.hsa_queue_load_write_index_relaxed = hsa_queue_load_write_index_relaxed;\n      hsa_api_.hsa_queue_store_write_index_relaxed = hsa_queue_store_write_index_relaxed;\n      hsa_api_.hsa_queue_load_read_index_relaxed = hsa_queue_load_read_index_relaxed;\n\n      hsa_api_.hsa_signal_create = hsa_signal_create;\n      hsa_api_.hsa_signal_destroy = hsa_signal_destroy;\n      hsa_api_.hsa_signal_load_relaxed = hsa_signal_load_relaxed;\n      hsa_api_.hsa_signal_store_relaxed = hsa_signal_store_relaxed;\n      hsa_api_.hsa_signal_wait_scacquire = hsa_signal_wait_scacquire;\n      hsa_api_.hsa_signal_store_screlease = hsa_signal_store_screlease;\n\n      hsa_api_.hsa_code_object_reader_create_from_file = hsa_code_object_reader_create_from_file;\n      hsa_api_.hsa_executable_create_alt = hsa_executable_create_alt;\n      hsa_api_.hsa_executable_load_agent_code_object = hsa_executable_load_agent_code_object;\n      hsa_api_.hsa_executable_freeze = hsa_executable_freeze;\n      hsa_api_.hsa_executable_get_symbol = hsa_executable_get_symbol;\n      hsa_api_.hsa_executable_symbol_get_info = hsa_executable_symbol_get_info;\n      hsa_api_.hsa_executable_iterate_symbols = hsa_executable_iterate_symbols;\n\n      hsa_api_.hsa_system_get_info = hsa_system_get_info;\n      hsa_api_.hsa_system_get_major_extension_table = hsa_system_get_major_extension_table;\n\n      hsa_api_.hsa_amd_agent_iterate_memory_pools = hsa_amd_agent_iterate_memory_pools;\n      hsa_api_.hsa_amd_memory_pool_get_info = hsa_amd_memory_pool_get_info;\n      hsa_api_.hsa_amd_memory_pool_allocate = hsa_amd_memory_pool_allocate;\n      hsa_api_.hsa_amd_agents_allow_access = hsa_amd_agents_allow_access;\n      hsa_api_.hsa_amd_memory_async_copy = hsa_amd_memory_async_copy;\n\n      hsa_api_.hsa_amd_signal_async_handler = hsa_amd_signal_async_handler;\n      hsa_api_.hsa_amd_profiling_set_profiler_enabled = hsa_amd_profiling_set_profiler_enabled;\n      hsa_api_.hsa_amd_profiling_get_async_copy_time = hsa_amd_profiling_get_async_copy_time;\n      hsa_api_.hsa_amd_profiling_get_dispatch_time = hsa_amd_profiling_get_dispatch_time;\n    }\n  }\n}\n\nhsa_status_t HsaRsrcFactory::LoadAqlProfileLib(aqlprofile_pfn_t* api) {\n  void* handle = dlopen(kAqlProfileLib, RTLD_NOW);\n  if (handle == NULL) {\n    fprintf(stderr, \"Loading '%s' failed, %s\\n\", kAqlProfileLib, dlerror());\n    return HSA_STATUS_ERROR;\n  }\n  dlerror(); /* Clear any existing error */\n\n  api->hsa_ven_amd_aqlprofile_error_string =\n      (decltype(::hsa_ven_amd_aqlprofile_error_string)*)dlsym(\n          handle, \"hsa_ven_amd_aqlprofile_error_string\");\n  api->hsa_ven_amd_aqlprofile_validate_event =\n      (decltype(::hsa_ven_amd_aqlprofile_validate_event)*)dlsym(\n          handle, \"hsa_ven_amd_aqlprofile_validate_event\");\n  api->hsa_ven_amd_aqlprofile_start =\n      (decltype(::hsa_ven_amd_aqlprofile_start)*)dlsym(handle, \"hsa_ven_amd_aqlprofile_start\");\n  api->hsa_ven_amd_aqlprofile_stop =\n      (decltype(::hsa_ven_amd_aqlprofile_stop)*)dlsym(handle, \"hsa_ven_amd_aqlprofile_stop\");\n#ifdef AQLPROF_NEW_API\n  api->hsa_ven_amd_aqlprofile_read =\n      (decltype(::hsa_ven_amd_aqlprofile_read)*)dlsym(handle, \"hsa_ven_amd_aqlprofile_read\");\n#endif\n  api->hsa_ven_amd_aqlprofile_legacy_get_pm4 =\n      (decltype(::hsa_ven_amd_aqlprofile_legacy_get_pm4)*)dlsym(\n          handle, \"hsa_ven_amd_aqlprofile_legacy_get_pm4\");\n  api->hsa_ven_amd_aqlprofile_get_info = (decltype(::hsa_ven_amd_aqlprofile_get_info)*)dlsym(\n      handle, \"hsa_ven_amd_aqlprofile_get_info\");\n  api->hsa_ven_amd_aqlprofile_iterate_data =\n      (decltype(::hsa_ven_amd_aqlprofile_iterate_data)*)dlsym(\n          handle, \"hsa_ven_amd_aqlprofile_iterate_data\");\n\n  return HSA_STATUS_SUCCESS;\n}\n\n// Add system agent info\nconst AgentInfo* HsaRsrcFactory::AddAgentInfo(const hsa_agent_t agent) {\n  // Determine if device is a Gpu agent\n  hsa_status_t status;\n  AgentInfo* agent_info = NULL;\n\n  hsa_device_type_t type;\n  status = hsa_api_.hsa_agent_get_info(agent, HSA_AGENT_INFO_DEVICE, &type);\n  CHECK_STATUS(\"Error Calling hsa_agent_get_info\", status);\n\n  if (type == HSA_DEVICE_TYPE_CPU) {\n    agent_info = new AgentInfo{};\n    agent_info->dev_id = agent;\n    agent_info->dev_type = HSA_DEVICE_TYPE_CPU;\n    agent_info->dev_index = cpu_list_.size();\n\n    status = hsa_api_.hsa_amd_agent_iterate_memory_pools(agent, FindStandardPool, &agent_info->cpu_pool);\n    if ((status == HSA_STATUS_INFO_BREAK) && (cpu_pool_ == NULL)) cpu_pool_ = &agent_info->cpu_pool;\n    status = hsa_api_.hsa_amd_agent_iterate_memory_pools(agent, FindKernArgPool, &agent_info->kern_arg_pool);\n    if ((status == HSA_STATUS_INFO_BREAK) && (kern_arg_pool_ == NULL)) kern_arg_pool_ = &agent_info->kern_arg_pool;\n    agent_info->gpu_pool = {};\n\n    cpu_list_.push_back(agent_info);\n    cpu_agents_.push_back(agent);\n  }\n\n  if (type == HSA_DEVICE_TYPE_GPU) {\n    agent_info = new AgentInfo{};\n    agent_info->dev_id = agent;\n    agent_info->dev_type = HSA_DEVICE_TYPE_GPU;\n    hsa_api_.hsa_agent_get_info(agent, HSA_AGENT_INFO_NAME, agent_info->name);\n    strncpy(agent_info->gfxip, agent_info->name, 4);\n    agent_info->gfxip[4] = '\\0';\n    hsa_api_.hsa_agent_get_info(agent, HSA_AGENT_INFO_WAVEFRONT_SIZE, &agent_info->max_wave_size);\n    hsa_api_.hsa_agent_get_info(agent, HSA_AGENT_INFO_QUEUE_MAX_SIZE, &agent_info->max_queue_size);\n    hsa_api_.hsa_agent_get_info(agent, HSA_AGENT_INFO_PROFILE, &agent_info->profile);\n    agent_info->is_apu = (agent_info->profile == HSA_PROFILE_FULL) ? true : false;\n    hsa_api_.hsa_agent_get_info(agent, static_cast<hsa_agent_info_t>(HSA_AMD_AGENT_INFO_COMPUTE_UNIT_COUNT),\n                       &agent_info->cu_num);\n    hsa_api_.hsa_agent_get_info(agent, static_cast<hsa_agent_info_t>(HSA_AMD_AGENT_INFO_MAX_WAVES_PER_CU),\n                       &agent_info->waves_per_cu);\n    hsa_api_.hsa_agent_get_info(agent, static_cast<hsa_agent_info_t>(HSA_AMD_AGENT_INFO_NUM_SIMDS_PER_CU),\n                       &agent_info->simds_per_cu);\n    hsa_api_.hsa_agent_get_info(agent, static_cast<hsa_agent_info_t>(HSA_AMD_AGENT_INFO_NUM_SHADER_ENGINES),\n                       &agent_info->se_num);\n    hsa_api_.hsa_agent_get_info(agent,\n                       static_cast<hsa_agent_info_t>(HSA_AMD_AGENT_INFO_NUM_SHADER_ARRAYS_PER_SE),\n                       &agent_info->shader_arrays_per_se);\n\n    agent_info->cpu_pool = {};\n    agent_info->kern_arg_pool = {};\n    status = hsa_api_.hsa_amd_agent_iterate_memory_pools(agent, FindStandardPool, &agent_info->gpu_pool);\n    CHECK_ITER_STATUS(\"hsa_amd_agent_iterate_memory_pools(gpu pool)\", status);\n\n    // GFX8 and GFX9 SGPR/VGPR block sizes\n    agent_info->sgpr_block_dflt = (strcmp(agent_info->gfxip, \"gfx8\") == 0) ? 1 : 2;\n    agent_info->sgpr_block_size = 8;\n    agent_info->vgpr_block_size = 4;\n\n    // Set GPU index\n    agent_info->dev_index = gpu_list_.size();\n    gpu_list_.push_back(agent_info);\n    gpu_agents_.push_back(agent);\n  }\n\n  if (agent_info) agent_map_[agent.handle] = agent_info;\n\n  return agent_info;\n}\n\n// Return systen agent info\nconst AgentInfo* HsaRsrcFactory::GetAgentInfo(const hsa_agent_t agent) {\n  const AgentInfo* agent_info = NULL;\n  auto it = agent_map_.find(agent.handle);\n  if (it != agent_map_.end()) {\n    agent_info = it->second;\n  }\n  return agent_info;\n}\n\n// Get the count of Hsa Gpu Agents available on the platform\n//\n// @return uint32_t Number of Gpu agents on platform\n//\nuint32_t HsaRsrcFactory::GetCountOfGpuAgents() { return uint32_t(gpu_list_.size()); }\n\n// Get the count of Hsa Cpu Agents available on the platform\n//\n// @return uint32_t Number of Cpu agents on platform\n//\nuint32_t HsaRsrcFactory::GetCountOfCpuAgents() { return uint32_t(cpu_list_.size()); }\n\n// Get the AgentInfo handle of a Gpu device\n//\n// @param idx Gpu Agent at specified index\n//\n// @param agent_info Output parameter updated with AgentInfo\n//\n// @return bool true if successful, false otherwise\n//\nbool HsaRsrcFactory::GetGpuAgentInfo(uint32_t idx, const AgentInfo** agent_info) {\n  // Determine if request is valid\n  uint32_t size = uint32_t(gpu_list_.size());\n  if (idx >= size) {\n    return false;\n  }\n\n  // Copy AgentInfo from specified index\n  *agent_info = gpu_list_[idx];\n\n  return true;\n}\n\n// Get the AgentInfo handle of a Cpu device\n//\n// @param idx Cpu Agent at specified index\n//\n// @param agent_info Output parameter updated with AgentInfo\n//\n// @return bool true if successful, false otherwise\n//\nbool HsaRsrcFactory::GetCpuAgentInfo(uint32_t idx, const AgentInfo** agent_info) {\n  // Determine if request is valid\n  uint32_t size = uint32_t(cpu_list_.size());\n  if (idx >= size) {\n    return false;\n  }\n\n  // Copy AgentInfo from specified index\n  *agent_info = cpu_list_[idx];\n  return true;\n}\n\n// Create a Queue object and return its handle. The queue object is expected\n// to support user requested number of Aql dispatch packets.\n//\n// @param agent_info Gpu Agent on which to create a queue object\n//\n// @param num_Pkts Number of packets to be held by queue\n//\n// @param queue Output parameter updated with handle of queue object\n//\n// @return bool true if successful, false otherwise\n//\nbool HsaRsrcFactory::CreateQueue(const AgentInfo* agent_info, uint32_t num_pkts,\n                                 hsa_queue_t** queue) {\n  hsa_status_t status;\n  status = hsa_api_.hsa_queue_create(agent_info->dev_id, num_pkts, HSA_QUEUE_TYPE_MULTI, NULL, NULL,\n                            UINT32_MAX, UINT32_MAX, queue);\n  return (status == HSA_STATUS_SUCCESS);\n}\n\n// Create a Signal object and return its handle.\n// @param value Initial value of signal object\n// @param signal Output parameter updated with handle of signal object\n// @return bool true if successful, false otherwise\nbool HsaRsrcFactory::CreateSignal(uint32_t value, hsa_signal_t* signal) {\n  hsa_status_t status;\n  status = hsa_api_.hsa_signal_create(value, 0, NULL, signal);\n  return (status == HSA_STATUS_SUCCESS);\n}\n\n// Allocate memory for use by a kernel of specified size in specified\n// agent's memory region.\n// @param agent_info Agent from whose memory region to allocate\n// @param size Size of memory in terms of bytes\n// @return uint8_t* Pointer to buffer, null if allocation fails.\nuint8_t* HsaRsrcFactory::AllocateLocalMemory(const AgentInfo* agent_info, size_t size) {\n  hsa_status_t status = HSA_STATUS_ERROR;\n  uint8_t* buffer = NULL;\n  size = (size + MEM_PAGE_MASK) & ~MEM_PAGE_MASK;\n  status = hsa_api_.hsa_amd_memory_pool_allocate(agent_info->gpu_pool, size, 0, reinterpret_cast<void**>(&buffer));\n  uint8_t* ptr = (status == HSA_STATUS_SUCCESS) ? buffer : NULL;\n  return ptr;\n}\n\n// Allocate memory to pass kernel parameters.\n// Memory is alocated accessible for all CPU agents and for GPU given by AgentInfo parameter.\n// @param agent_info Agent from whose memory region to allocate\n// @param size Size of memory in terms of bytes\n// @return uint8_t* Pointer to buffer, null if allocation fails.\nuint8_t* HsaRsrcFactory::AllocateKernArgMemory(const AgentInfo* agent_info, size_t size) {\n  hsa_status_t status = HSA_STATUS_ERROR;\n  uint8_t* buffer = NULL;\n  if (!cpu_agents_.empty()) {\n    size = (size + MEM_PAGE_MASK) & ~MEM_PAGE_MASK;\n    status = hsa_api_.hsa_amd_memory_pool_allocate(*kern_arg_pool_, size, 0, reinterpret_cast<void**>(&buffer));\n    // Both the CPU and GPU can access the kernel arguments\n    if (status == HSA_STATUS_SUCCESS) {\n      hsa_agent_t ag_list[1] = {agent_info->dev_id};\n      status = hsa_api_.hsa_amd_agents_allow_access(1, ag_list, NULL, buffer);\n    }\n  }\n  uint8_t* ptr = (status == HSA_STATUS_SUCCESS) ? buffer : NULL;\n  return ptr;\n}\n\n// Allocate system memory accessible by both CPU and GPU\n// @param agent_info Agent from whose memory region to allocate\n// @param size Size of memory in terms of bytes\n// @return uint8_t* Pointer to buffer, null if allocation fails.\nuint8_t* HsaRsrcFactory::AllocateSysMemory(const AgentInfo* agent_info, size_t size) {\n  hsa_status_t status = HSA_STATUS_ERROR;\n  uint8_t* buffer = NULL;\n  size = (size + MEM_PAGE_MASK) & ~MEM_PAGE_MASK;\n  if (!cpu_agents_.empty()) {\n    status = hsa_api_.hsa_amd_memory_pool_allocate(*cpu_pool_, size, 0, reinterpret_cast<void**>(&buffer));\n    // Both the CPU and GPU can access the memory\n    if (status == HSA_STATUS_SUCCESS) {\n      hsa_agent_t ag_list[1] = {agent_info->dev_id};\n      status = hsa_api_.hsa_amd_agents_allow_access(1, ag_list, NULL, buffer);\n    }\n  }\n  uint8_t* ptr = (status == HSA_STATUS_SUCCESS) ? buffer : NULL;\n  return ptr;\n}\n\n// Allocate memory for command buffer.\n// @param agent_info Agent from whose memory region to allocate\n// @param size Size of memory in terms of bytes\n// @return uint8_t* Pointer to buffer, null if allocation fails.\nuint8_t* HsaRsrcFactory::AllocateCmdMemory(const AgentInfo* agent_info, size_t size) {\n  size = (size + MEM_PAGE_MASK) & ~MEM_PAGE_MASK;\n  uint8_t* ptr = (agent_info->is_apu && CMD_MEMORY_MMAP)\n      ? reinterpret_cast<uint8_t*>(\n            mmap(NULL, size, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_SHARED | MAP_ANONYMOUS, 0, 0))\n      : AllocateSysMemory(agent_info, size);\n  return ptr;\n}\n\n// Wait signal\nhsa_signal_value_t HsaRsrcFactory::SignalWait(const hsa_signal_t& signal, const hsa_signal_value_t& signal_value) const {\n  const hsa_signal_value_t exp_value = signal_value - 1;\n  hsa_signal_value_t ret_value = signal_value;\n  while (1) {\n    ret_value =\n      hsa_api_.hsa_signal_wait_scacquire(signal, HSA_SIGNAL_CONDITION_LT, signal_value, timeout_, HSA_WAIT_STATE_BLOCKED);\n    if (ret_value == exp_value) break;\n    if (ret_value != signal_value) {\n      std::cerr << \"Error: HsaRsrcFactory::SignalWait: signal_value(\" << signal_value\n                << \"), ret_value(\" << ret_value << \")\" << std::endl << std::flush;\n      abort();\n    }\n  }\n  return ret_value;\n}\n\n// Wait signal with signal value restore\nvoid HsaRsrcFactory::SignalWaitRestore(const hsa_signal_t& signal, const hsa_signal_value_t& signal_value) const {\n  SignalWait(signal, signal_value);\n  hsa_api_.hsa_signal_store_relaxed(const_cast<hsa_signal_t&>(signal), signal_value);\n}\n\n// Copy data from GPU to host memory\nbool HsaRsrcFactory::Memcpy(const hsa_agent_t& agent, void* dst, const void* src, size_t size) {\n  hsa_status_t status = HSA_STATUS_ERROR;\n  if (!cpu_agents_.empty()) {\n    hsa_signal_t s = {};\n    status = hsa_api_.hsa_signal_create(1, 0, NULL, &s);\n    CHECK_STATUS(\"hsa_signal_create()\", status);\n    status = hsa_api_.hsa_amd_memory_async_copy(dst, cpu_agents_[0], src, agent, size, 0, NULL, s);\n    CHECK_STATUS(\"hsa_amd_memory_async_copy()\", status);\n    SignalWait(s, 1);\n    status = hsa_api_.hsa_signal_destroy(s);\n    CHECK_STATUS(\"hsa_signal_destroy()\", status);\n  }\n  return (status == HSA_STATUS_SUCCESS);\n}\nbool HsaRsrcFactory::Memcpy(const AgentInfo* agent_info, void* dst, const void* src, size_t size) {\n  return Memcpy(agent_info->dev_id, dst, src, size);\n}\n\n// Memory free method\nbool HsaRsrcFactory::FreeMemory(void* ptr) {\n  const hsa_status_t status = hsa_memory_free(ptr);\n  CHECK_STATUS(\"hsa_memory_free\", status);\n  return (status == HSA_STATUS_SUCCESS);\n}\n\n// Loads an Assembled Brig file and Finalizes it into Device Isa\n// @param agent_info Gpu device for which to finalize\n// @param brig_path File path of the Assembled Brig file\n// @param kernel_name Name of the kernel to finalize\n// @param code_desc Handle of finalized Code Descriptor that could\n// be used to submit for execution\n// @return bool true if successful, false otherwise\nbool HsaRsrcFactory::LoadAndFinalize(const AgentInfo* agent_info, const char* brig_path,\n                                     const char* kernel_name, hsa_executable_t* executable,\n                                     hsa_executable_symbol_t* code_desc) {\n  hsa_status_t status = HSA_STATUS_ERROR;\n\n  // Build the code object filename\n  std::string filename(brig_path);\n  std::clog << \"Code object filename: \" << filename << std::endl;\n\n  // Open the file containing code object\n  hsa_file_t file_handle = open(filename.c_str(), O_RDONLY);\n  if (file_handle == -1) {\n    std::cerr << \"Error: failed to load '\" << filename << \"'\" << std::endl;\n    assert(false);\n    return false;\n  }\n\n  // Create code object reader\n  hsa_code_object_reader_t code_obj_rdr = {0};\n  status = hsa_api_.hsa_code_object_reader_create_from_file(file_handle, &code_obj_rdr);\n  if (status != HSA_STATUS_SUCCESS) {\n    std::cerr << \"Failed to create code object reader '\" << filename << \"'\" << std::endl;\n    return false;\n  }\n\n  // Create executable.\n  status = hsa_api_.hsa_executable_create_alt(HSA_PROFILE_FULL, HSA_DEFAULT_FLOAT_ROUNDING_MODE_DEFAULT,\n                                     NULL, executable);\n  CHECK_STATUS(\"Error in creating executable object\", status);\n\n  // Load code object.\n  status = hsa_api_.hsa_executable_load_agent_code_object(*executable, agent_info->dev_id, code_obj_rdr,\n                                                 NULL, NULL);\n  CHECK_STATUS(\"Error in loading executable object\", status);\n\n  // Freeze executable.\n  status = hsa_api_.hsa_executable_freeze(*executable, \"\");\n  CHECK_STATUS(\"Error in freezing executable object\", status);\n\n  // Get symbol handle.\n  hsa_executable_symbol_t kernelSymbol;\n  status = hsa_api_.hsa_executable_get_symbol(*executable, NULL, kernel_name, agent_info->dev_id, 0,\n                                     &kernelSymbol);\n  CHECK_STATUS(\"Error in looking up kernel symbol\", status);\n\n  // Update output parameter\n  *code_desc = kernelSymbol;\n  return true;\n}\n\n// Print the various fields of Hsa Gpu Agents\nbool HsaRsrcFactory::PrintGpuAgents(const std::string& header) {\n  std::cout << std::flush;\n  std::clog << header << \" :\" << std::endl;\n\n  const AgentInfo* agent_info;\n  int size = uint32_t(gpu_list_.size());\n  for (int idx = 0; idx < size; idx++) {\n    agent_info = gpu_list_[idx];\n\n    std::clog << \"> agent[\" << idx << \"] :\" << std::endl;\n    std::clog << \">> Name : \" << agent_info->name << std::endl;\n    std::clog << \">> APU : \" << agent_info->is_apu << std::endl;\n    std::clog << \">> HSAIL profile : \" << agent_info->profile << std::endl;\n    std::clog << \">> Max Wave Size : \" << agent_info->max_wave_size << std::endl;\n    std::clog << \">> Max Queue Size : \" << agent_info->max_queue_size << std::endl;\n    std::clog << \">> CU number : \" << agent_info->cu_num << std::endl;\n    std::clog << \">> Waves per CU : \" << agent_info->waves_per_cu << std::endl;\n    std::clog << \">> SIMDs per CU : \" << agent_info->simds_per_cu << std::endl;\n    std::clog << \">> SE number : \" << agent_info->se_num << std::endl;\n    std::clog << \">> Shader Arrays per SE : \" << agent_info->shader_arrays_per_se << std::endl;\n  }\n  return true;\n}\n\nuint64_t HsaRsrcFactory::Submit(hsa_queue_t* queue, const void* packet) {\n  const uint32_t slot_size_b = CMD_SLOT_SIZE_B;\n\n  // adevance command queue\n  const uint64_t write_idx = hsa_api_.hsa_queue_load_write_index_relaxed(queue);\n  hsa_api_.hsa_queue_store_write_index_relaxed(queue, write_idx + 1);\n  while ((write_idx - hsa_api_.hsa_queue_load_read_index_relaxed(queue)) >= queue->size) {\n    sched_yield();\n  }\n\n  uint32_t slot_idx = (uint32_t)(write_idx % queue->size);\n  uint32_t* queue_slot = reinterpret_cast<uint32_t*>((uintptr_t)(queue->base_address) + (slot_idx * slot_size_b));\n  const uint32_t* slot_data = reinterpret_cast<const uint32_t*>(packet);\n\n  // Copy buffered commands into the queue slot.\n  // Overwrite the AQL invalid header (first dword) last.\n  // This prevents the slot from being read until it's fully written.\n  memcpy(&queue_slot[1], &slot_data[1], slot_size_b - sizeof(uint32_t));\n  std::atomic<uint32_t>* header_atomic_ptr =\n      reinterpret_cast<std::atomic<uint32_t>*>(&queue_slot[0]);\n  header_atomic_ptr->store(slot_data[0], std::memory_order_release);\n\n  // ringdoor bell\n  hsa_api_.hsa_signal_store_relaxed(queue->doorbell_signal, write_idx);\n\n  return write_idx;\n}\n\nuint64_t HsaRsrcFactory::Submit(hsa_queue_t* queue, const void* packet, size_t size_bytes) {\n  const uint32_t slot_size_b = CMD_SLOT_SIZE_B;\n  if ((size_bytes & (slot_size_b - 1)) != 0) {\n    fprintf(stderr, \"HsaRsrcFactory::Submit: Bad packet size %zx\\n\", size_bytes);\n    abort();\n  }\n\n  const char* begin = reinterpret_cast<const char*>(packet);\n  const char* end = begin + size_bytes;\n  uint64_t write_idx = 0;\n  for (const char* ptr = begin; ptr < end; ptr += slot_size_b) {\n    write_idx = Submit(queue, ptr);\n  }\n\n  return write_idx;\n}\n\nconst char* HsaRsrcFactory::GetKernelName(uint64_t addr) {\n  std::lock_guard<mutex_t> lck(mutex_);\n  const auto it = symbols_map_->find(addr);\n  if (it == symbols_map_->end()) {\n    fprintf(stderr, \"HsaRsrcFactory::kernel addr (0x%lx) is not found\\n\", addr);\n    abort();\n  }\n  return strdup(it->second);\n}\n\nvoid HsaRsrcFactory::EnableExecutableTracking(HsaApiTable* table) {\n  std::lock_guard<mutex_t> lck(mutex_);\n  executable_tracking_on_ = true;\n  table->core_->hsa_executable_freeze_fn = hsa_executable_freeze_interceptor;\n}\n\nhsa_status_t HsaRsrcFactory::executable_symbols_cb(hsa_executable_t exec, hsa_executable_symbol_t symbol, void *data) {\n  hsa_symbol_kind_t value = (hsa_symbol_kind_t)0;\n  hsa_status_t status = hsa_api_.hsa_executable_symbol_get_info(symbol, HSA_EXECUTABLE_SYMBOL_INFO_TYPE, &value);\n  CHECK_STATUS(\"Error in getting symbol info\", status);\n  if (value == HSA_SYMBOL_KIND_KERNEL) {\n    uint64_t addr = 0;\n    uint32_t len = 0;\n    status = hsa_api_.hsa_executable_symbol_get_info(symbol, HSA_EXECUTABLE_SYMBOL_INFO_KERNEL_OBJECT, &addr);\n    CHECK_STATUS(\"Error in getting kernel object\", status);\n    status = hsa_api_.hsa_executable_symbol_get_info(symbol, HSA_EXECUTABLE_SYMBOL_INFO_NAME_LENGTH, &len);\n    CHECK_STATUS(\"Error in getting name len\", status);\n    char *name = new char[len + 1];\n    status = hsa_api_.hsa_executable_symbol_get_info(symbol, HSA_EXECUTABLE_SYMBOL_INFO_NAME, name);\n    CHECK_STATUS(\"Error in getting kernel name\", status);\n    name[len] = 0;\n    auto ret = symbols_map_->insert({addr, name});\n    if (ret.second == false) {\n      delete[] ret.first->second;\n      ret.first->second = name;\n    }\n  }\n  return HSA_STATUS_SUCCESS;\n}\n\nhsa_status_t HsaRsrcFactory::hsa_executable_freeze_interceptor(hsa_executable_t executable, const char *options) {\n  std::lock_guard<mutex_t> lck(mutex_);\n  if (symbols_map_ == NULL) symbols_map_ = new symbols_map_t;\n  hsa_status_t status = hsa_api_.hsa_executable_iterate_symbols(executable, executable_symbols_cb, NULL);\n  CHECK_STATUS(\"Error in iterating executable symbols\", status);\n  return hsa_api_.hsa_executable_freeze(executable, options);;\n}\n\nstd::atomic<HsaRsrcFactory*> HsaRsrcFactory::instance_{};\nHsaRsrcFactory::mutex_t HsaRsrcFactory::mutex_;\nHsaRsrcFactory::timestamp_t HsaRsrcFactory::timeout_ns_ = HsaTimer::TIMESTAMP_MAX;\nhsa_pfn_t HsaRsrcFactory::hsa_api_{};\nbool HsaRsrcFactory::executable_tracking_on_ = false;\nHsaRsrcFactory::symbols_map_t* HsaRsrcFactory::symbols_map_ = NULL;\n\n}  // namespace util\n",
        "/tmp/vanessa/spack-stage/spack-stage-rocprofiler-dev-3.5.0-gucmlniizd247uuh2s7vpd4nr6jdzlwp/spack-src/roctracer/src/core/loader.h": "#ifndef SRC_CORE_LOADER_H_\n#define SRC_CORE_LOADER_H_\n\n#include <atomic>\n#include <mutex>\n#include <dlfcn.h>\n\n#define ONLD_TRACE(str) \\\n  if (getenv(\"ROCP_ONLOAD_TRACE\")) do { \\\n    std::cout << \"PID(\" << GetPid() << \"): TRACER_LOADER::\" << __FUNCTION__ << \" \" << str << std::endl << std::flush; \\\n  } while(0);\n\nnamespace roctracer {\n\n// Base runtime loader class\ntemplate <class T>\nclass BaseLoader : public T {\n  static uint32_t GetPid() { return syscall(__NR_getpid); }\n\n  public:\n  typedef std::mutex mutex_t;\n  typedef BaseLoader<T> loader_t;\n\n  bool Enabled() const { return (handle_ != NULL); }\n\n  template <class fun_t>\n  fun_t* GetFun(const char* fun_name) {\n    if (handle_ == NULL) return NULL;\n\n    fun_t *f = (fun_t*) dlsym(handle_, fun_name);\n    if ((to_check_symb_ == true) && (f == NULL)) {\n      fprintf(stderr, \"roctracer: symbol lookup '%s' failed: \\\"%s\\\"\\n\", fun_name, dlerror());\n      abort();\n    }\n    return f;\n  }\n\n  static inline loader_t& Instance() {\n    loader_t* obj = instance_.load(std::memory_order_acquire);\n    if (obj == NULL) {\n      std::lock_guard<mutex_t> lck(mutex_);\n      if (instance_.load(std::memory_order_relaxed) == NULL) {\n        obj = new loader_t();\n        instance_.store(obj, std::memory_order_release);\n      }\n    }\n    return *instance_;\n  }\n\n  static loader_t* GetRef() { return instance_; }\n  static void SetLibName(const char *name) { lib_name_ = name; }\n\n  private:\n  BaseLoader() {\n    const int flags = (to_load_ == true) ? RTLD_LAZY : RTLD_LAZY|RTLD_NOLOAD;\n    handle_ = dlopen(lib_name_, flags);\n    ONLD_TRACE(\"(\" << lib_name_ << \" = \" << handle_ << \")\");\n    if ((to_check_open_ == true) && (handle_ == NULL)) {\n      fprintf(stderr, \"roctracer: Loading '%s' failed, %s\\n\", lib_name_, dlerror());\n      abort();\n    }\n\n    T::init(this);\n  }\n\n  ~BaseLoader() {\n    if (handle_ != NULL) dlclose(handle_);\n  }\n\n  static bool to_load_;\n  static bool to_check_open_;\n  static bool to_check_symb_;\n\n  static mutex_t mutex_;\n  static const char* lib_name_;\n  static std::atomic<loader_t*> instance_;\n  void* handle_;\n};\n\n// 'rocprofiler' library loader class\nclass RocpApi {\n  public:\n  typedef BaseLoader<RocpApi> Loader;\n\n  typedef bool (RegisterCallback_t)(uint32_t op, void* callback, void* arg);\n  typedef bool (OperateCallback_t)(uint32_t op);\n  typedef bool (InitCallback_t)(void* callback, void* arg);\n  typedef bool (EnableCallback_t)(uint32_t op, bool enable);\n  typedef const char* (NameCallback_t)(uint32_t op);\n\n  RegisterCallback_t* RegisterApiCallback;\n  OperateCallback_t* RemoveApiCallback;\n  InitCallback_t* InitActivityCallback;\n  EnableCallback_t* EnableActivityCallback;\n  NameCallback_t* GetOpName;\n\n  protected:\n  void init(Loader* loader) {\n    RegisterApiCallback = loader->GetFun<RegisterCallback_t>(\"RegisterApiCallback\");\n    RemoveApiCallback = loader->GetFun<OperateCallback_t>(\"RemoveApiCallback\");\n    InitActivityCallback = loader->GetFun<InitCallback_t>(\"InitActivityCallback\");\n    EnableActivityCallback = loader->GetFun<EnableCallback_t>(\"EnableActivityCallback\");\n    GetOpName = loader->GetFun<NameCallback_t>(\"GetOpName\");\n  }\n};\n\n// HIP runtime library loader class\nclass HipApi {\n  public:\n  typedef BaseLoader<HipApi> Loader;\n\n  typedef decltype(hipRegisterApiCallback) RegisterApiCallback_t;\n  typedef decltype(hipRemoveApiCallback) RemoveApiCallback_t;\n  typedef decltype(hipRegisterActivityCallback) RegisterActivityCallback_t;\n  typedef decltype(hipRemoveActivityCallback) RemoveActivityCallback_t;\n  typedef decltype(hipKernelNameRef) KernelNameRef_t;\n  typedef decltype(hipKernelNameRefByPtr) KernelNameRefByPtr_t;\n  typedef decltype(hipApiName) ApiName_t;\n\n  RegisterApiCallback_t* RegisterApiCallback;\n  RemoveApiCallback_t* RemoveApiCallback;\n  RegisterActivityCallback_t* RegisterActivityCallback;\n  RemoveActivityCallback_t* RemoveActivityCallback;\n  KernelNameRef_t* KernelNameRef;\n  KernelNameRefByPtr_t* KernelNameRefByPtr;\n  ApiName_t* ApiName;\n\n  protected:\n  void init(Loader* loader) {\n    RegisterApiCallback = loader->GetFun<RegisterApiCallback_t>(\"hipRegisterApiCallback\");\n    RemoveApiCallback = loader->GetFun<RemoveApiCallback_t>(\"hipRemoveApiCallback\");\n    RegisterActivityCallback = loader->GetFun<RegisterActivityCallback_t>(\"hipRegisterActivityCallback\");\n    RemoveActivityCallback = loader->GetFun<RemoveActivityCallback_t>(\"hipRemoveActivityCallback\");\n    KernelNameRef = loader->GetFun<KernelNameRef_t>(\"hipKernelNameRef\");\n    KernelNameRefByPtr = loader->GetFun<KernelNameRefByPtr_t>(\"hipKernelNameRefByPtr\");\n    ApiName = loader->GetFun<ApiName_t>(\"hipApiName\");\n  }\n};\n\n// HCC runtime library loader class\n#include \"inc/roctracer_hcc.h\"\nclass HccApi {\n  public:\n  typedef BaseLoader<HccApi> Loader;\n\n  hipInitAsyncActivityCallback_t* InitActivityCallback;\n  hipEnableAsyncActivityCallback_t* EnableActivityCallback;\n  hipGetOpName_t* GetOpName;\n\n  protected:\n  void init(Loader* loader) {\n#if HIP_VDI\n    InitActivityCallback = loader->GetFun<hipInitAsyncActivityCallback_t>(\"hipInitActivityCallback\");\n    EnableActivityCallback = loader->GetFun<hipEnableAsyncActivityCallback_t>(\"hipEnableActivityCallback\");\n    GetOpName = loader->GetFun<hipGetOpName_t>(\"hipGetCmdName\");\n#else\n    InitActivityCallback = loader->GetFun<hipInitAsyncActivityCallback_t>(\"InitActivityCallbackImpl\");\n    EnableActivityCallback = loader->GetFun<hipEnableAsyncActivityCallback_t>(\"EnableActivityCallbackImpl\");\n    GetOpName = loader->GetFun<hipGetOpName_t>(\"GetCmdNameImpl\");\n#endif\n  }\n};\n\n// KFD runtime library loader class\nclass KfdApi {\n  public:\n  typedef BaseLoader<KfdApi> Loader;\n\n  typedef bool (RegisterApiCallback_t)(uint32_t op, void* callback, void* arg);\n  typedef bool (RemoveApiCallback_t)(uint32_t op);\n\n  RegisterApiCallback_t* RegisterApiCallback;\n  RemoveApiCallback_t* RemoveApiCallback;\n\n  protected:\n  void init(Loader* loader) {\n    RegisterApiCallback = loader->GetFun<RegisterApiCallback_t>(\"RegisterApiCallback\");\n    RemoveApiCallback = loader->GetFun<RemoveApiCallback_t>(\"RemoveApiCallback\");\n  }\n};\n\n// rocTX runtime library loader class\n#include \"inc/roctracer_roctx.h\"\nclass RocTxApi {\n  public:\n  typedef BaseLoader<RocTxApi> Loader;\n\n  typedef decltype(RegisterApiCallback) RegisterApiCallback_t;\n  typedef decltype(RemoveApiCallback) RemoveApiCallback_t;\n  typedef decltype(RangeStackIterate) RangeStackIterate_t;\n\n  RegisterApiCallback_t* RegisterApiCallback;\n  RemoveApiCallback_t* RemoveApiCallback;\n  RangeStackIterate_t* RangeStackIterate;\n\n  protected:\n  void init(Loader* loader) {\n    RegisterApiCallback = loader->GetFun<RegisterApiCallback_t>(\"RegisterApiCallback\");\n    RemoveApiCallback = loader->GetFun<RemoveApiCallback_t>(\"RemoveApiCallback\");\n    RangeStackIterate = loader->GetFun<RangeStackIterate_t>(\"RangeStackIterate\");\n  }\n};\n\ntypedef BaseLoader<RocpApi> RocpLoader;\ntypedef BaseLoader<HipApi> HipLoader;\ntypedef BaseLoader<HccApi> HccLoader;\ntypedef BaseLoader<KfdApi> KfdLoader;\ntypedef BaseLoader<RocTxApi> RocTxLoader;\n\n} // namespace roctracer\n\n#define LOADER_INSTANTIATE2(HIP_LIB, HCC_LIB) \\\n  template<class T> typename roctracer::BaseLoader<T>::mutex_t roctracer::BaseLoader<T>::mutex_; \\\n  template<class T> std::atomic<roctracer::BaseLoader<T>*> roctracer::BaseLoader<T>::instance_{}; \\\n  template<class T> bool roctracer::BaseLoader<T>::to_load_ = false; \\\n  template<class T> bool roctracer::BaseLoader<T>::to_check_open_ = true; \\\n  template<class T> bool roctracer::BaseLoader<T>::to_check_symb_ = true; \\\n  template<> const char* roctracer::RocpLoader::lib_name_ = \"librocprofiler64.so\"; \\\n  template<> const char* roctracer::HipLoader::lib_name_ = HIP_LIB; \\\n  template<> bool roctracer::HipLoader::to_check_open_ = false; \\\n  template<> const char* roctracer::HccLoader::lib_name_ = HCC_LIB; \\\n  template<> bool roctracer::HccLoader::to_check_open_ = false; \\\n  template<> const char* roctracer::KfdLoader::lib_name_ = \"libkfdwrapper64.so\"; \\\n  template<> const char* roctracer::RocTxLoader::lib_name_ = \"libroctx64.so\"; \\\n  template<> bool roctracer::RocTxLoader::to_load_ = true;\n\n#if HIP_VDI\n#define LOADER_INSTANTIATE() LOADER_INSTANTIATE2(\"libamdhip64.so\", \"libamdhip64.so\");\n#else\n#define LOADER_INSTANTIATE() LOADER_INSTANTIATE2(\"libhip_hcc.so\", \"libmcwamp.so\");\n#endif\n\n#endif // SRC_CORE_LOADER_H_\n",
        "/tmp/vanessa/spack-stage/spack-stage-rocprofiler-dev-3.5.0-gucmlniizd247uuh2s7vpd4nr6jdzlwp/spack-src/roctracer/script/kfdap.py": "#!/usr/bin/python\nfrom __future__ import print_function\nimport os, sys, re\n\nOUT_H = 'inc/kfd_prof_str.h' \nOUT_CPP = 'src/kfd/kfd_wrapper.cpp'\nAPI_HEADERS_H = ( \n  ('HSAKMTAPI', 'hsakmt.h'), \n)\n\nLICENSE = \\\n'/*\\n' + \\\n'Copyright (c) 2018 Advanced Micro Devices, Inc. All rights reserved.\\n' + \\\n'\\n' + \\\n'Permission is hereby granted, free of charge, to any person obtaining a copy\\n' + \\\n'of this software and associated documentation files (the \"Software\"), to deal\\n' + \\\n'in the Software without restriction, including without limitation the rights\\n' + \\\n'to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\n' + \\\n'copies of the Software, and to permit persons to whom the Software is\\n' + \\\n'furnished to do so, subject to the following conditions:\\n' + \\\n'\\n' + \\\n'The above copyright notice and this permission notice shall be included in\\n' + \\\n'all copies or substantial portions of the Software.\\n' + \\\n'\\n' + \\\n'THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\n' + \\\n'IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\n' + \\\n'FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\\n' + \\\n'AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\n' + \\\n'LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\n' + \\\n'OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\n' + \\\n'THE SOFTWARE.\\n' + \\\n'*/\\n'\n\n#############################################################\n# Error handler\ndef fatal(module, msg):\n  print (module + ' Error: \"' + msg + '\"', file = sys.stderr)\n  sys.exit(1)\n\n# Get next text block\ndef NextBlock(pos, record): \n  if len(record) == 0: return pos\n\n  space_pattern = re.compile(r'(\\s+)')\n  word_pattern = re.compile(r'([\\w\\*]+\\[*\\]*)')\n  if record[pos] != '(':\n    m = space_pattern.match(record, pos)\n    if not m:\n      m = word_pattern.match(record, pos)\n    if m:\n      return pos + len(m.group(1))\n    else:\n      fatal('NextBlock', \"bad record '\" + record + \"' pos(\" + str(pos) + \")\")\n  else:\n    count = 0\n    for index in range(pos, len(record)):\n      if record[index] == '(':\n        count = count + 1\n      elif record[index] == ')':\n        count = count-1\n        if count == 0:\n          index = index + 1\n          break\n    if count != 0:\n      fatal('NextBlock', \"count is not zero (\" + str(count) + \")\")\n    if record[index-1] != ')':\n      fatal('NextBlock', \"last char is not ')' '\" + record[index-1] + \"'\")\n    return index\n\n#############################################################\n# API table parser class\nclass API_TableParser:\n  def fatal(self, msg):\n    fatal('API_TableParser', msg)\n\n  def __init__(self, header, name, full_fct):\n    self.name = name\n    self.full_fct = full_fct\n\n    if not os.path.isfile(header):\n      self.fatal(\"file '\" + header + \"' not found\")\n\n    self.inp = open(header, 'r')\n\n    self.beg_pattern = re.compile(name) \n    self.end_pattern = re.compile('.*\\)\\s*;\\s*$'); \n    self.array = []\n    self.parse()\n\n  # normalizing a line\n  def norm_line(self, line):\n    return re.sub(r'^\\s+', r' ', line)\n\n  def fix_comment_line(self, line):\n    return re.sub(r'\\/\\/.*', r'', line) \n\n  def remove_ret_line(self, line):\n    return re.sub(r'\\n', r'', line) \n\n  # check for start record\n  def is_start(self, record):\n    return self.beg_pattern.match(record)\n\n  # check for end record\n  def is_end(self, record):\n    return self.end_pattern.match(record)\n\n  # check for declaration entry record\n  def is_entry(self, record):\n    return re.match(r'^\\s*HSAKMTAPI\\s*(.*)\\s*\\((.*)\\)', record) \n\n  # parse method\n  def parse(self):\n    active = 0\n    record = \"\";\n    cumulate = 0;\n    self.full_fct = {}\n    rettype = \"\"\n    prev_line = \"\"\n    for line in self.inp.readlines():\n      line = self.norm_line(line)\n      line = self.fix_comment_line(line)\n\n      if cumulate == 1: record += \" \" + line; \n      else: record = line;\n      if self.is_start(line): rettype = prev_line.strip(); cumulate = 1; prev_line = line; continue;\n      if self.is_end(line): record = self.remove_ret_line(record); cumulate = 0; active = 1;\n      else: prev_line = line; continue;\n      if active != 0:\n        m = self.is_entry(record)\n        if m:\n          mycall_full = rettype  + \" \" + m.group(1) + ' (' + m.group(2) + ')'\n          mycall = m.group(1)\n          self.full_fct[mycall] = mycall_full\n          self.array.append(mycall) \n          rettype = \"\";\n      prev_line = line\n\n#############################################################\n# API declaration parser clas\nclass API_DeclParser:\n  def fatal(self, msg):\n    fatal('API_DeclParser', msg)\n\n  def __init__(self, header, array, data, full_fct):\n    if not os.path.isfile(header):\n      self.fatal(\"file '\" + header + \"' not found\")\n\n    self.inp = open(header, 'r')\n\n    self.end_pattern = re.compile('\\)\\s*;\\s*$')\n    self.data = data\n    for call in array:\n      if call in data:\n        self.fatal(call + ' is already found')\n      self.parse(call,full_fct)\n\n  # check for start record\n  def is_start(self, call, record):\n    return re.search('\\s*' + call + '\\s*\\(', record)\n\n  # check for API method record\n  def is_api(self, call, record):\n    return re.match('\\s*' + call + '\\s*\\(', record)\n\n\n  # check for end record\n  def is_end(self, record):\n    return self.end_pattern.search(record)\n\n  # parse method args\n  def get_args(self, record):\n    struct = {'ret': '', 'args': '', 'astr': {}, 'alst': [], 'tlst': []}\n    record = re.sub(r'^\\s+', r'', record)\n    record = re.sub(r'\\s*(\\*+)\\s*', r'\\1 ', record)\n    rind = NextBlock(0, record) \n    struct['ret'] = record[0:rind]\n    pos = record.find('(')\n    end = NextBlock(pos, record);\n    args = record[pos:end]\n    args = re.sub(r'^\\(\\s*', r'', args)\n    args = re.sub(r'\\s*\\)$', r'', args)\n    args = re.sub(r'\\s*,\\s*', r',', args)\n    struct['args'] = re.sub(r',', r', ', args)\n    if args == \"void\":\n      return struct\n        \n    if len(args) == 0: return struct\n\n    pos = 0\n    args = args + ','\n    while pos < len(args):\n      ind1 = NextBlock(pos, args) # type\n      ind2 = NextBlock(ind1, args) # space\n      if args[ind2] != '(':\n        while ind2 < len(args):\n          end = NextBlock(ind2, args)\n          if args[end] == ',': break\n          else: ind2 = end\n        name = args[ind2:end]\n      else:\n        ind3 = NextBlock(ind2, args) # field\n        m = re.match(r'\\(\\s*\\*\\s*(\\S+)\\s*\\)', args[ind2:ind3])\n        if not m:\n          self.fatal(\"bad block3 '\" + args + \"' : '\" + args[ind2:ind3] + \"'\")\n        name = m.group(1)\n        end = NextBlock(ind3, args) # the rest\n      item = args[pos:end]\n      struct['astr'][name] = item\n      struct['alst'].append(name)\n      struct['tlst'].append(item)\n      if args[end] != ',':\n        self.fatal(\"no comma '\" + args + \"'\")\n      pos = end + 1\n\n    return struct\n\n  # parse given api\n  def parse(self, call, full_fct):\n    if call in full_fct: \n      self.data[call] = self.get_args(full_fct[call])\n    else:\n      self.data[call] = self.get_args(call)\n\n#############################################################\n# API description parser class\nclass API_DescrParser:\n  def fatal(self, msg):\n    fatal('API_DescrParser', msg)\n\n  def __init__(self, out_file, kfd_dir, api_headers, license):\n    out_macro = re.sub(r'[\\/\\.]', r'_', out_file.upper()) + '_'\n\n    self.content_h = ''\n    self.content_cpp = ''\n\n    self.api_names = []\n    self.api_calls = {}\n    self.api_rettypes = set()\n    self.api_id = {}\n    \n    api_data = {}\n    full_fct = {}\n    api_list = []\n    ns_calls = []\n\n    (name, header) = api_headers[0]\n    api = API_TableParser(kfd_dir + header, name, full_fct)\n    full_fct = api.full_fct\n    api_list = api.array\n    self.api_names.append(name)\n    self.api_calls[name] = api_list\n\n    for call in api_list:\n      if call in api_data:\n        self.fatal(\"call '\"  + call + \"' is already found\")\n\n    API_DeclParser(kfd_dir + header, api_list, api_data, full_fct)\n\n    for call in api_list:\n      if not call in api_data:\n        # Not-supported functions\n        ns_calls.append(call)\n      else:\n        # API ID map\n        self.api_id[call] = 'KFD_API_ID_' + call\n        # Return types\n        self.api_rettypes.add(api_data[call]['ret'])\n\n    self.api_data = api_data\n    self.ns_calls = ns_calls\n\n    self.content_h += \"// automatically generated\\n\\n\" + license + '\\n'\n    \n    self.content_h += \"/////////////////////////////////////////////////////////////////////////////\\n\"\n    for call in self.ns_calls:\n      self.content_h += '// ' + call + ' was not parsed\\n'\n    self.content_h += '\\n'\n    self.content_h += '#ifndef ' + out_macro + '\\n'\n    self.content_h += '#define ' + out_macro + '\\n'\n\n    self.content_h += '\\n'\n\n    self.content_h += '#include <dlfcn.h>\\n'\n    self.content_h += '#include <string.h>\\n'\n    self.content_h += '#include <roctracer_kfd.h>\\n'\n    self.content_h += '#include <hsakmt.h>\\n'\n\n    self.content_h += '#define PUBLIC_API __attribute__((visibility(\\\"default\\\")))\\n'\n\n    self.add_section('API ID enumeration', '  ', self.gen_id_enum)\n    self.add_section('API arg structure', '    ', self.gen_arg_struct)\n\n    self.content_h += '\\n'\n    self.content_h += '#if PROF_API_IMPL\\n'\n    self.content_h += '#include <roctracer_cb_table.h>\\n'\n    self.content_h += 'namespace roctracer {\\n'\n    self.content_h += 'namespace kfd_support {\\n'\n\n    self.add_section('API get_name function', '    ', self.gen_get_name)\n    self.add_section('API get_code function', '  ', self.gen_get_code) \n\n    self.add_section('API intercepting code', '', self.gen_intercept_decl)\n    self.add_section('API intercepting code', '', self.gen_intercept)\n    self.add_section('API callback functions', '', self.gen_callbacks)\n\n    self.content_h += '\\n};};\\n'\n    self.content_h += '#endif // PROF_API_IMPL\\n'\n\n    self.content_cpp += \"// automatically generated\\n\\n\" + license + '\\n'\n    self.content_cpp += \"/////////////////////////////////////////////////////////////////////////////\\n\\n\"\n    self.content_cpp += '#define PROF_API_IMPL 1\\n'\n    self.content_cpp += '#include \\\"kfd_prof_str.h\\\"\\n'\n\n    self.add_section('API output stream', '    ', self.gen_out_stream)\n    self.add_section_cpp('API callback fcts', '    ', self.gen_public_api)\n    self.content_h += '#endif // ' + out_macro + '_'\n    self.content_cpp += '}\\n'\n    self.content_cpp += '\\n'\n\n  # add code section\n  def add_section_cpp(self, title, gap, fun):\n    n = 0\n    self.content_cpp += '\\n// section: ' + title + '\\n\\n'\n    fun(-1, '-', '-', {})\n    for index in range(len(self.api_names)):\n      last = (index == len(self.api_names)-1)\n      name = self.api_names[index]\n\n      if n != 0:\n        if gap == '': fun(n, name, '-', {})\n        self.content_cpp += '\\n'\n      self.content_cpp += gap + '// block: ' + name + ' API\\n'\n      for call in self.api_calls[name]:\n        fun(n, name, call, self.api_data[call])\n        n += 1\n    fun(n, '-', '-', {})\n\n  def add_section(self, title, gap, fun):\n    n = 0\n    self.content_h += '\\n// section: ' + title + '\\n\\n'\n    fun(-1, '-', '-', {})\n    for index in range(len(self.api_names)):\n      last = (index == len(self.api_names)-1)\n      name = self.api_names[index]\n\n      if n != 0:\n        if gap == '': fun(n, name, '-', {})\n        self.content_h += '\\n'\n      self.content_h += gap + '// block: ' + name + ' API\\n'\n      for call in self.api_calls[name]:\n        fun(n, name, call, self.api_data[call])\n        n += 1\n    fun(n, '-', '-', {})\n\n  # check if it's an array decl\n  def is_arr(self, record):\n    return re.match(r'\\s*(.*)\\s+(.*)\\[\\]\\s*', record)\n\n  # generate API ID enumeration\n  def gen_id_enum(self, n, name, call, data):\n    if n == -1:\n      self.content_h += 'enum kfd_api_id_t {\\n'\n      return\n    if call != '-':\n      self.content_h += '  ' + self.api_id[call] + ' = ' + str(n) + ',\\n'\n    else:\n      self.content_h += '\\n'\n      self.content_h += '  KFD_API_ID_NUMBER = ' + str(n) + ',\\n'\n      self.content_h += '  KFD_API_ID_ANY = ' + str(n + 1) + ',\\n'\n      self.content_h += '};\\n'\n    \n  # generate API args structure\n  def gen_arg_struct(self, n, name, call, struct):\n    if n == -1:\n      self.content_h += 'typedef struct kfd_api_data_s {\\n'\n      self.content_h += '  uint64_t correlation_id;\\n'\n      self.content_h += '  uint32_t phase;\\n'\n      if len(self.api_rettypes) != 0:\n        self.content_h += '  union {\\n'\n        for ret_type in self.api_rettypes:\n          if ret_type != 'void':\n            self.content_h += '    ' + ret_type + ' ' + ret_type + '_retval;\\n'\n        self.content_h += '  };\\n'\n      self.content_h += '  union {\\n'\n      return\n    if call != '-':\n      self.content_h += '    struct {\\n'\n      for (var, item) in struct['astr'].items():\n        m = self.is_arr(item)\n        if m:\n          self.content_h += '      ' + m.group(1)  + '* ' +  m.group(2) + ';\\n'\n        else:\n          self.content_h += '      ' + item + ';\\n'\n      self.content_h += '    } ' +  call + ';\\n'\n    else:\n      self.content_h += '  } args;\\n'\n      self.content_h += '} kfd_api_data_t;\\n'\n    \n  # generate API callbacks\n  def gen_callbacks(self, n, name, call, struct):\n    if n == -1:\n      self.content_h += 'typedef CbTable<KFD_API_ID_NUMBER> cb_table_t;\\n'\n      self.content_h += 'cb_table_t cb_table;\\n'\n      self.content_h += '\\n'\n    if call != '-':\n      call_id = self.api_id[call];\n      ret_type = struct['ret']\n      self.content_h += ret_type + ' ' + call + '_callback(' + struct['args'] + ') {\\n'  # 'static '  + \n      self.content_h += '  if (' + name + '_table == NULL) intercept_KFDApiTable();\\n'\n      self.content_h += '  kfd_api_data_t api_data{};\\n'\n      for var in struct['alst']:\n        self.content_h += '  api_data.args.' + call + '.' + var.replace(\"[]\",\"\") + ' = ' + var.replace(\"[]\",\"\") + ';\\n'\n      self.content_h += '  activity_rtapi_callback_t api_callback_fun = NULL;\\n'\n      self.content_h += '  void* api_callback_arg = NULL;\\n'\n      self.content_h += '  cb_table.get(' + call_id + ', &api_callback_fun, &api_callback_arg);\\n'\n      self.content_h += '  api_data.phase = 0;\\n'\n      self.content_h += '  if (api_callback_fun) api_callback_fun(ACTIVITY_DOMAIN_KFD_API, ' + call_id + ', &api_data, api_callback_arg);\\n'\n      if ret_type != 'void':\n        self.content_h += '  ' + ret_type + ' ret = '\n      tmp_str = '  ' + name + '_table->' + call + '_fn(' + ', '.join(struct['alst']) + ');\\n'\n      self.content_h += tmp_str.replace(\"[]\",\"\")\n      if ret_type != 'void':\n        self.content_h += '  api_data.' + ret_type + '_retval = ret;\\n'\n      self.content_h += '  api_data.phase = 1;\\n'\n      self.content_h += '  if (api_callback_fun) api_callback_fun(ACTIVITY_DOMAIN_KFD_API, ' + call_id + ', &api_data, api_callback_arg);\\n'\n      if ret_type != 'void':\n        self.content_h += '  return ret;\\n'\n      self.content_h += '}\\n'\n\n  # Generates API intercepting table struct definition\n  def gen_intercept_decl(self, n, name, call, struct):\n    if n > 0 and call == '-':\n      self.content_h += '} HSAKMTAPI_table_t;\\n' #was HSAKMTAPI_table_t\n    if n == 0 or (call == '-' and name != '-'):\n      self.content_h += 'typedef struct {\\n'\n    if call != '-':\n      self.content_h += '  decltype(' + call + ')* ' + call + '_fn;\\n'\n\n  # generate API intercepting code\n  def gen_intercept(self, n, name, call, struct):\n    if n > 0 and call == '-':\n      self.content_h += '};\\n'\n    if n == 0 or (call == '-' and name != '-'):\n      self.content_h += name + '_table_t* ' + name + '_table = NULL;\\n'\n      self.content_h += 'void intercept_' + 'KFDApiTable' + '(void) {\\n'\n      self.content_h += '  ' + name + '_table = new ' + name + '_table_t{}' + ';\\n'\n\n    if call != '-':\n      self.content_h += '  typedef decltype(' + name + '_table_t::' + call + '_fn) ' + call + '_t;\\n'\n      self.content_h += '  ' + name + '_table->' + call + '_fn = (' + call + '_t)' + 'dlsym(RTLD_NEXT,\\\"'  + call + '\\\");\\n' \n\n  # generate API name function\n  def gen_get_name(self, n, name, call, struct):\n    if n == -1:\n      self.content_h += 'const char* GetApiName(const uint32_t& id) {\\n' #static\n      self.content_h += '  switch (id) {\\n'\n      return\n    if call != '-':\n      self.content_h += '    case ' + self.api_id[call] + ': return \"' + call + '\";\\n'\n    else:\n      self.content_h += '  }\\n'\n      self.content_h += '  return \"unknown\";\\n'\n      self.content_h +=  '}\\n'\n\n  # generate API code function\n  def gen_get_code(self, n, name, call, struct):\n    if n == -1:\n      self.content_h += 'uint32_t GetApiCode(const char* str) {\\n' # static\n      return\n    if call != '-':\n      self.content_h += '  if (strcmp(\"' + call + '\", str) == 0) return ' + self.api_id[call] + ';\\n'\n    else:\n      self.content_h += '  return KFD_API_ID_NUMBER;\\n'\n      self.content_h += '}\\n'\n\n  # generate stream operator\n  def gen_out_stream(self, n, name, call, struct):\n    if n == -1:\n      self.content_h += '#ifdef __cplusplus\\n'\n      self.content_h += 'typedef std::pair<uint32_t, kfd_api_data_t> kfd_api_data_pair_t;\\n'\n      self.content_h += 'inline std::ostream& operator<< (std::ostream& out, const kfd_api_data_pair_t& data_pair) {\\n'\n      self.content_h += '  const uint32_t cid = data_pair.first;\\n'\n      self.content_h += '  const kfd_api_data_t& api_data = data_pair.second;\\n'\n      self.content_h += '  switch(cid) {\\n'\n      return\n    if call != '-':\n      self.content_h += '    case ' + self.api_id[call] + ': {\\n'\n      self.content_h += '      out << \"' + call + '(\";\\n'\n      arg_list = struct['alst']\n      if len(arg_list) != 0:\n        for ind in range(len(arg_list)):\n          arg_var = arg_list[ind]\n          arg_val = 'api_data.args.' + call + '.' + arg_var\n          if re.search(r'MemFlags',arg_var):\n            continue \n          self.content_h += '      typedef decltype(' + arg_val.replace(\"[]\",\"\") + ') arg_val_type_t' + str(ind) + ';\\n'\n          self.content_h += '      roctracer::kfd_support::output_streamer<arg_val_type_t' + str(ind) + '>::put(out, ' + arg_val.replace(\"[]\",\"\") + ')'\n          if ind < len(arg_list)-1: self.content_h += ' << \", \";\\n'\n          else: self.content_h += ';\\n'\n      if struct['ret'] != 'void':\n        self.content_h += '      out << \") = \" << api_data.' + struct['ret'] + '_retval;\\n'\n      else:\n        self.content_h += '      out << \") = void\";\\n'\n      self.content_h += '      break;\\n'\n      self.content_h += '    }\\n'\n    else:\n      self.content_h += '    default:\\n'\n      self.content_h += '      out << \"ERROR: unknown API\";\\n'\n      self.content_h += '      abort();\\n'\n      self.content_h += '  }\\n'\n      self.content_h += '  return out;\\n'\n      self.content_h += '}\\n'  \n      self.content_h += '#endif\\n'\n      self.content_cpp += 'inline std::ostream& operator<< (std::ostream& out, const HsaMemFlags& v) { out << \"HsaMemFlags\"; return out; }\\n' \n\n  # generate PUBLIC_API for all API fcts \n  def gen_public_api(self, n, name, call, struct):\n    if n == -1:\n      self.content_cpp += 'extern \"C\" {\\n'\n      self.content_cpp += 'PUBLIC_API bool RegisterApiCallback(uint32_t op, void* callback, void* user_data) {\\n';\n      self.content_cpp += '    roctracer::kfd_support::cb_table.set(op, reinterpret_cast<activity_rtapi_callback_t>(callback), user_data);\\n';\n      self.content_cpp += '    return true;\\n';\n      self.content_cpp += '}\\n';\n      self.content_cpp += 'PUBLIC_API bool RemoveApiCallback(uint32_t op) {\\n'\n      self.content_cpp += '    roctracer::kfd_support::cb_table.set(op, NULL, NULL);\\n';\n      self.content_cpp += '    return true;\\n';\n      self.content_cpp += '}\\n\\n';\n\n    if call != '-' and call != 'hsaKmtCloseKFD' and call != 'hsaKmtOpenKFD':\n      self.content_cpp += 'PUBLIC_API ' + struct['ret'] + \" \" + call + '(' + struct['args'] + ') { return roctracer::kfd_support::' + call + '_callback('\n      for i in range(0,len(struct['alst'])):\n        if i == (len(struct['alst'])-1):\n          self.content_cpp += struct['alst'][i].replace(\"[]\",\"\")\n        else:\n          self.content_cpp += struct['alst'][i].replace(\"[]\",\"\") + ', '\n      self.content_cpp +=  ');} \\n'\n\n#############################################################\n# main\n# Usage\nif len(sys.argv) != 3:\n  print (\"Usage:\", sys.argv[0], \" <rocTracer root> <KFD include path>\", file = sys.stderr)\n  sys.exit(1)\nelse:\n  ROOT = sys.argv[1] + '/'\n  KFD_DIR = sys.argv[2] + '/'\n\ndescr = API_DescrParser(OUT_H, KFD_DIR, API_HEADERS_H, LICENSE)\n\nout_file = ROOT + OUT_H\nprint ('Generating \"' + out_file + '\"')\nf = open(out_file, 'w')\nf.write(descr.content_h[:-1])\nf.close()\n\nout_file = ROOT + OUT_CPP\nprint ('Generating \"' + out_file + '\"')\nf = open(out_file, 'w')\nf.write(descr.content_cpp[:-1])\nf.close()\n\n#############################################################\n",
        "/tmp/vanessa/spack-stage/spack-stage-rocprofiler-dev-3.5.0-gucmlniizd247uuh2s7vpd4nr6jdzlwp/spack-src/test/util/hsa_rsrc_factory.cpp": "/**********************************************************************\nCopyright \u00a92013 Advanced Micro Devices, Inc. All rights reserved.\n\nRedistribution and use in source and binary forms, with or without modification, are permitted\nprovided that the following conditions are met:\n\n<95>    Redistributions of source code must retain the above copyright notice, this list of\nconditions and the following disclaimer.\n<95>    Redistributions in binary form must reproduce the above copyright notice, this list of\nconditions and the following disclaimer in the documentation and/or\n other materials provided with the distribution.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\nIMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT\nSHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY\n DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\nLIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\nWHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\nPOSSIBILITY OF SUCH DAMAGE.\n********************************************************************/\n\n#include \"util/hsa_rsrc_factory.h\"\n\n#include <dlfcn.h>\n#include <fcntl.h>\n#include <hsa.h>\n#include <hsa_ext_amd.h>\n#include <hsa_ext_finalize.h>\n#include <stdint.h>\n#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n\n#include <atomic>\n#include <cassert>\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <vector>\n\n// Callback function to get available in the system agents\nhsa_status_t HsaRsrcFactory::GetHsaAgentsCallback(hsa_agent_t agent, void* data) {\n  hsa_status_t status = HSA_STATUS_ERROR;\n  HsaRsrcFactory* hsa_rsrc = reinterpret_cast<HsaRsrcFactory*>(data);\n  const AgentInfo* agent_info = hsa_rsrc->AddAgentInfo(agent);\n  if (agent_info != NULL) status = HSA_STATUS_SUCCESS;\n  return status;\n}\n\n// This function checks to see if the provided\n// pool has the HSA_AMD_SEGMENT_GLOBAL property. If the kern_arg flag is true,\n// the function adds an additional requirement that the pool have the\n// HSA_AMD_MEMORY_POOL_GLOBAL_FLAG_KERNARG_INIT property. If kern_arg is false,\n// pools must NOT have this property.\n// Upon finding a pool that meets these conditions, HSA_STATUS_INFO_BREAK is\n// returned. HSA_STATUS_SUCCESS is returned if no errors were encountered, but\n// no pool was found meeting the requirements. If an error is encountered, we\n// return that error.\nstatic hsa_status_t FindGlobalPool(hsa_amd_memory_pool_t pool, void* data, bool kern_arg) {\n  hsa_status_t err;\n  hsa_amd_segment_t segment;\n  uint32_t flag;\n\n  if (nullptr == data) {\n    return HSA_STATUS_ERROR_INVALID_ARGUMENT;\n  }\n\n  err = HsaRsrcFactory::HsaApi()->hsa_amd_memory_pool_get_info(pool, HSA_AMD_MEMORY_POOL_INFO_SEGMENT, &segment);\n  CHECK_STATUS(\"hsa_amd_memory_pool_get_info\", err);\n  if (HSA_AMD_SEGMENT_GLOBAL != segment) {\n    return HSA_STATUS_SUCCESS;\n  }\n\n  err = HsaRsrcFactory::HsaApi()->hsa_amd_memory_pool_get_info(pool, HSA_AMD_MEMORY_POOL_INFO_GLOBAL_FLAGS, &flag);\n  CHECK_STATUS(\"hsa_amd_memory_pool_get_info\", err);\n\n  uint32_t karg_st = flag & HSA_AMD_MEMORY_POOL_GLOBAL_FLAG_KERNARG_INIT;\n\n  if ((karg_st == 0 && kern_arg) || (karg_st != 0 && !kern_arg)) {\n    return HSA_STATUS_SUCCESS;\n  }\n\n  *(reinterpret_cast<hsa_amd_memory_pool_t*>(data)) = pool;\n  return HSA_STATUS_INFO_BREAK;\n}\n\n// This is the call-back function for hsa_amd_agent_iterate_memory_pools() that\n// finds a pool with the properties of HSA_AMD_SEGMENT_GLOBAL and that is NOT\n// HSA_AMD_MEMORY_POOL_GLOBAL_FLAG_KERNARG_INIT\nhsa_status_t FindStandardPool(hsa_amd_memory_pool_t pool, void* data) {\n  return FindGlobalPool(pool, data, false);\n}\n\n// This is the call-back function for hsa_amd_agent_iterate_memory_pools() that\n// finds a pool with the properties of HSA_AMD_SEGMENT_GLOBAL and that IS\n// HSA_AMD_MEMORY_POOL_GLOBAL_FLAG_KERNARG_INIT\nhsa_status_t FindKernArgPool(hsa_amd_memory_pool_t pool, void* data) {\n  return FindGlobalPool(pool, data, true);\n}\n\n// Constructor of the class\nHsaRsrcFactory::HsaRsrcFactory(bool initialize_hsa) : initialize_hsa_(initialize_hsa) {\n  hsa_status_t status;\n\n  cpu_pool_ = NULL;\n  kern_arg_pool_ = NULL;\n\n  InitHsaApiTable(NULL);\n\n  // Initialize the Hsa Runtime\n  if (initialize_hsa_) {\n    status = hsa_api_.hsa_init();\n    CHECK_STATUS(\"Error in hsa_init\", status);\n  }\n\n  // Discover the set of Gpu devices available on the platform\n  status = hsa_api_.hsa_iterate_agents(GetHsaAgentsCallback, this);\n  CHECK_STATUS(\"Error Calling hsa_iterate_agents\", status);\n  if (cpu_pool_ == NULL) CHECK_STATUS(\"CPU memory pool is not found\", HSA_STATUS_ERROR);\n  if (kern_arg_pool_ == NULL) CHECK_STATUS(\"Kern-arg memory pool is not found\", HSA_STATUS_ERROR);\n\n  // Get AqlProfile API table\n  aqlprofile_api_ = {0};\n#ifdef ROCP_LD_AQLPROFILE\n  status = LoadAqlProfileLib(&aqlprofile_api_);\n#else\n  status = hsa_api_.hsa_system_get_major_extension_table(HSA_EXTENSION_AMD_AQLPROFILE, hsa_ven_amd_aqlprofile_VERSION_MAJOR, sizeof(aqlprofile_api_), &aqlprofile_api_);\n#endif\n  CHECK_STATUS(\"aqlprofile API table load failed\", status);\n\n  // Get Loader API table\n  loader_api_ = {0};\n  status = hsa_api_.hsa_system_get_major_extension_table(HSA_EXTENSION_AMD_LOADER, 1, sizeof(loader_api_), &loader_api_);\n  CHECK_STATUS(\"loader API table query failed\", status);\n\n  // Instantiate HSA timer\n  timer_ = new HsaTimer(&hsa_api_);\n  CHECK_STATUS(\"HSA timer allocation failed\",\n    (timer_ == NULL) ? HSA_STATUS_ERROR : HSA_STATUS_SUCCESS);\n\n  // Time correlation\n  const uint32_t corr_iters = 1000;\n  for (unsigned time_id = 0; time_id < HsaTimer::TIME_ID_NUMBER; time_id += 1) {\n    CorrelateTime((HsaTimer::time_id_t)time_id, corr_iters);\n  }\n\n  // System timeout\n  timeout_ = (timeout_ns_ == HsaTimer::TIMESTAMP_MAX) ? timeout_ns_ : timer_->ns_to_sysclock(timeout_ns_);\n}\n\n// Destructor of the class\nHsaRsrcFactory::~HsaRsrcFactory() {\n  delete timer_;\n  for (auto p : cpu_list_) delete p;\n  for (auto p : gpu_list_) delete p;\n  if (initialize_hsa_) {\n    hsa_status_t status = hsa_api_.hsa_shut_down();\n    CHECK_STATUS(\"Error in hsa_shut_down\", status);\n  }\n}\n\nvoid HsaRsrcFactory::InitHsaApiTable(HsaApiTable* table) {\n  std::lock_guard<mutex_t> lck(mutex_);\n\n  if (hsa_api_.hsa_init == NULL) {\n    if (table != NULL) {\n      hsa_api_.hsa_init = table->core_->hsa_init_fn;\n      hsa_api_.hsa_shut_down = table->core_->hsa_shut_down_fn;\n      hsa_api_.hsa_agent_get_info = table->core_->hsa_agent_get_info_fn;\n      hsa_api_.hsa_iterate_agents = table->core_->hsa_iterate_agents_fn;\n\n      hsa_api_.hsa_queue_create = table->core_->hsa_queue_create_fn;\n      hsa_api_.hsa_queue_destroy = table->core_->hsa_queue_destroy_fn;\n      hsa_api_.hsa_queue_load_write_index_relaxed = table->core_->hsa_queue_load_write_index_relaxed_fn;\n      hsa_api_.hsa_queue_store_write_index_relaxed = table->core_->hsa_queue_store_write_index_relaxed_fn;\n      hsa_api_.hsa_queue_load_read_index_relaxed = table->core_->hsa_queue_load_read_index_relaxed_fn;\n\n      hsa_api_.hsa_signal_create = table->core_->hsa_signal_create_fn;\n      hsa_api_.hsa_signal_destroy = table->core_->hsa_signal_destroy_fn;\n      hsa_api_.hsa_signal_load_relaxed = table->core_->hsa_signal_load_relaxed_fn;\n      hsa_api_.hsa_signal_store_relaxed = table->core_->hsa_signal_store_relaxed_fn;\n      hsa_api_.hsa_signal_wait_scacquire = table->core_->hsa_signal_wait_scacquire_fn;\n      hsa_api_.hsa_signal_store_screlease = table->core_->hsa_signal_store_screlease_fn;\n\n      hsa_api_.hsa_code_object_reader_create_from_file = table->core_->hsa_code_object_reader_create_from_file_fn;\n      hsa_api_.hsa_executable_create_alt = table->core_->hsa_executable_create_alt_fn;\n      hsa_api_.hsa_executable_load_agent_code_object = table->core_->hsa_executable_load_agent_code_object_fn;\n      hsa_api_.hsa_executable_freeze = table->core_->hsa_executable_freeze_fn;\n      hsa_api_.hsa_executable_get_symbol = table->core_->hsa_executable_get_symbol_fn;\n      hsa_api_.hsa_executable_symbol_get_info = table->core_->hsa_executable_symbol_get_info_fn;\n      hsa_api_.hsa_executable_iterate_symbols = table->core_->hsa_executable_iterate_symbols_fn;\n\n      hsa_api_.hsa_system_get_info = table->core_->hsa_system_get_info_fn;\n      hsa_api_.hsa_system_get_major_extension_table = table->core_->hsa_system_get_major_extension_table_fn;\n\n      hsa_api_.hsa_amd_agent_iterate_memory_pools = table->amd_ext_->hsa_amd_agent_iterate_memory_pools_fn;\n      hsa_api_.hsa_amd_memory_pool_get_info = table->amd_ext_->hsa_amd_memory_pool_get_info_fn;\n      hsa_api_.hsa_amd_memory_pool_allocate = table->amd_ext_->hsa_amd_memory_pool_allocate_fn;\n      hsa_api_.hsa_amd_agents_allow_access = table->amd_ext_->hsa_amd_agents_allow_access_fn;\n      hsa_api_.hsa_amd_memory_async_copy = table->amd_ext_->hsa_amd_memory_async_copy_fn;\n\n      hsa_api_.hsa_amd_signal_async_handler = table->amd_ext_->hsa_amd_signal_async_handler_fn;\n      hsa_api_.hsa_amd_profiling_set_profiler_enabled = table->amd_ext_->hsa_amd_profiling_set_profiler_enabled_fn;\n      hsa_api_.hsa_amd_profiling_get_async_copy_time = table->amd_ext_->hsa_amd_profiling_get_async_copy_time_fn;\n      hsa_api_.hsa_amd_profiling_get_dispatch_time = table->amd_ext_->hsa_amd_profiling_get_dispatch_time_fn;\n    } else {\n      hsa_api_.hsa_init = hsa_init;\n      hsa_api_.hsa_shut_down = hsa_shut_down;\n      hsa_api_.hsa_agent_get_info = hsa_agent_get_info;\n      hsa_api_.hsa_iterate_agents = hsa_iterate_agents;\n\n      hsa_api_.hsa_queue_create = hsa_queue_create;\n      hsa_api_.hsa_queue_destroy = hsa_queue_destroy;\n      hsa_api_.hsa_queue_load_write_index_relaxed = hsa_queue_load_write_index_relaxed;\n      hsa_api_.hsa_queue_store_write_index_relaxed = hsa_queue_store_write_index_relaxed;\n      hsa_api_.hsa_queue_load_read_index_relaxed = hsa_queue_load_read_index_relaxed;\n\n      hsa_api_.hsa_signal_create = hsa_signal_create;\n      hsa_api_.hsa_signal_destroy = hsa_signal_destroy;\n      hsa_api_.hsa_signal_load_relaxed = hsa_signal_load_relaxed;\n      hsa_api_.hsa_signal_store_relaxed = hsa_signal_store_relaxed;\n      hsa_api_.hsa_signal_wait_scacquire = hsa_signal_wait_scacquire;\n      hsa_api_.hsa_signal_store_screlease = hsa_signal_store_screlease;\n\n      hsa_api_.hsa_code_object_reader_create_from_file = hsa_code_object_reader_create_from_file;\n      hsa_api_.hsa_executable_create_alt = hsa_executable_create_alt;\n      hsa_api_.hsa_executable_load_agent_code_object = hsa_executable_load_agent_code_object;\n      hsa_api_.hsa_executable_freeze = hsa_executable_freeze;\n      hsa_api_.hsa_executable_get_symbol = hsa_executable_get_symbol;\n      hsa_api_.hsa_executable_symbol_get_info = hsa_executable_symbol_get_info;\n      hsa_api_.hsa_executable_iterate_symbols = hsa_executable_iterate_symbols;\n\n      hsa_api_.hsa_system_get_info = hsa_system_get_info;\n      hsa_api_.hsa_system_get_major_extension_table = hsa_system_get_major_extension_table;\n\n      hsa_api_.hsa_amd_agent_iterate_memory_pools = hsa_amd_agent_iterate_memory_pools;\n      hsa_api_.hsa_amd_memory_pool_get_info = hsa_amd_memory_pool_get_info;\n      hsa_api_.hsa_amd_memory_pool_allocate = hsa_amd_memory_pool_allocate;\n      hsa_api_.hsa_amd_agents_allow_access = hsa_amd_agents_allow_access;\n      hsa_api_.hsa_amd_memory_async_copy = hsa_amd_memory_async_copy;\n\n      hsa_api_.hsa_amd_signal_async_handler = hsa_amd_signal_async_handler;\n      hsa_api_.hsa_amd_profiling_set_profiler_enabled = hsa_amd_profiling_set_profiler_enabled;\n      hsa_api_.hsa_amd_profiling_get_async_copy_time = hsa_amd_profiling_get_async_copy_time;\n      hsa_api_.hsa_amd_profiling_get_dispatch_time = hsa_amd_profiling_get_dispatch_time;\n    }\n  }\n}\n\nhsa_status_t HsaRsrcFactory::LoadAqlProfileLib(aqlprofile_pfn_t* api) {\n  void* handle = dlopen(kAqlProfileLib, RTLD_NOW);\n  if (handle == NULL) {\n    fprintf(stderr, \"Loading '%s' failed, %s\\n\", kAqlProfileLib, dlerror());\n    return HSA_STATUS_ERROR;\n  }\n  dlerror(); /* Clear any existing error */\n\n  api->hsa_ven_amd_aqlprofile_error_string =\n      (decltype(::hsa_ven_amd_aqlprofile_error_string)*)dlsym(\n          handle, \"hsa_ven_amd_aqlprofile_error_string\");\n  api->hsa_ven_amd_aqlprofile_validate_event =\n      (decltype(::hsa_ven_amd_aqlprofile_validate_event)*)dlsym(\n          handle, \"hsa_ven_amd_aqlprofile_validate_event\");\n  api->hsa_ven_amd_aqlprofile_start =\n      (decltype(::hsa_ven_amd_aqlprofile_start)*)dlsym(handle, \"hsa_ven_amd_aqlprofile_start\");\n  api->hsa_ven_amd_aqlprofile_stop =\n      (decltype(::hsa_ven_amd_aqlprofile_stop)*)dlsym(handle, \"hsa_ven_amd_aqlprofile_stop\");\n#ifdef AQLPROF_NEW_API\n  api->hsa_ven_amd_aqlprofile_read =\n      (decltype(::hsa_ven_amd_aqlprofile_read)*)dlsym(handle, \"hsa_ven_amd_aqlprofile_read\");\n#endif\n  api->hsa_ven_amd_aqlprofile_legacy_get_pm4 =\n      (decltype(::hsa_ven_amd_aqlprofile_legacy_get_pm4)*)dlsym(\n          handle, \"hsa_ven_amd_aqlprofile_legacy_get_pm4\");\n  api->hsa_ven_amd_aqlprofile_get_info = (decltype(::hsa_ven_amd_aqlprofile_get_info)*)dlsym(\n      handle, \"hsa_ven_amd_aqlprofile_get_info\");\n  api->hsa_ven_amd_aqlprofile_iterate_data =\n      (decltype(::hsa_ven_amd_aqlprofile_iterate_data)*)dlsym(\n          handle, \"hsa_ven_amd_aqlprofile_iterate_data\");\n\n  return HSA_STATUS_SUCCESS;\n}\n\n// Add system agent info\nconst AgentInfo* HsaRsrcFactory::AddAgentInfo(const hsa_agent_t agent) {\n  // Determine if device is a Gpu agent\n  hsa_status_t status;\n  AgentInfo* agent_info = NULL;\n\n  hsa_device_type_t type;\n  status = hsa_api_.hsa_agent_get_info(agent, HSA_AGENT_INFO_DEVICE, &type);\n  CHECK_STATUS(\"Error Calling hsa_agent_get_info\", status);\n\n  if (type == HSA_DEVICE_TYPE_CPU) {\n    agent_info = new AgentInfo{};\n    agent_info->dev_id = agent;\n    agent_info->dev_type = HSA_DEVICE_TYPE_CPU;\n    agent_info->dev_index = cpu_list_.size();\n\n    status = hsa_api_.hsa_amd_agent_iterate_memory_pools(agent, FindStandardPool, &agent_info->cpu_pool);\n    if ((status == HSA_STATUS_INFO_BREAK) && (cpu_pool_ == NULL)) cpu_pool_ = &agent_info->cpu_pool;\n    status = hsa_api_.hsa_amd_agent_iterate_memory_pools(agent, FindKernArgPool, &agent_info->kern_arg_pool);\n    if ((status == HSA_STATUS_INFO_BREAK) && (kern_arg_pool_ == NULL)) kern_arg_pool_ = &agent_info->kern_arg_pool;\n    agent_info->gpu_pool = {};\n\n    cpu_list_.push_back(agent_info);\n    cpu_agents_.push_back(agent);\n  }\n\n  if (type == HSA_DEVICE_TYPE_GPU) {\n    agent_info = new AgentInfo{};\n    agent_info->dev_id = agent;\n    agent_info->dev_type = HSA_DEVICE_TYPE_GPU;\n    hsa_api_.hsa_agent_get_info(agent, HSA_AGENT_INFO_NAME, agent_info->name);\n    strncpy(agent_info->gfxip, agent_info->name, 4);\n    agent_info->gfxip[4] = '\\0';\n    hsa_api_.hsa_agent_get_info(agent, HSA_AGENT_INFO_WAVEFRONT_SIZE, &agent_info->max_wave_size);\n    hsa_api_.hsa_agent_get_info(agent, HSA_AGENT_INFO_QUEUE_MAX_SIZE, &agent_info->max_queue_size);\n    hsa_api_.hsa_agent_get_info(agent, HSA_AGENT_INFO_PROFILE, &agent_info->profile);\n    agent_info->is_apu = (agent_info->profile == HSA_PROFILE_FULL) ? true : false;\n    hsa_api_.hsa_agent_get_info(agent, static_cast<hsa_agent_info_t>(HSA_AMD_AGENT_INFO_COMPUTE_UNIT_COUNT),\n                       &agent_info->cu_num);\n    hsa_api_.hsa_agent_get_info(agent, static_cast<hsa_agent_info_t>(HSA_AMD_AGENT_INFO_MAX_WAVES_PER_CU),\n                       &agent_info->waves_per_cu);\n    hsa_api_.hsa_agent_get_info(agent, static_cast<hsa_agent_info_t>(HSA_AMD_AGENT_INFO_NUM_SIMDS_PER_CU),\n                       &agent_info->simds_per_cu);\n    hsa_api_.hsa_agent_get_info(agent, static_cast<hsa_agent_info_t>(HSA_AMD_AGENT_INFO_NUM_SHADER_ENGINES),\n                       &agent_info->se_num);\n    hsa_api_.hsa_agent_get_info(agent,\n                       static_cast<hsa_agent_info_t>(HSA_AMD_AGENT_INFO_NUM_SHADER_ARRAYS_PER_SE),\n                       &agent_info->shader_arrays_per_se);\n\n    agent_info->cpu_pool = {};\n    agent_info->kern_arg_pool = {};\n    status = hsa_api_.hsa_amd_agent_iterate_memory_pools(agent, FindStandardPool, &agent_info->gpu_pool);\n    CHECK_ITER_STATUS(\"hsa_amd_agent_iterate_memory_pools(gpu pool)\", status);\n\n    // GFX8 and GFX9 SGPR/VGPR block sizes\n    agent_info->sgpr_block_dflt = (strcmp(agent_info->gfxip, \"gfx8\") == 0) ? 1 : 2;\n    agent_info->sgpr_block_size = 8;\n    agent_info->vgpr_block_size = 4;\n\n    // Set GPU index\n    agent_info->dev_index = gpu_list_.size();\n    gpu_list_.push_back(agent_info);\n    gpu_agents_.push_back(agent);\n  }\n\n  if (agent_info) agent_map_[agent.handle] = agent_info;\n\n  return agent_info;\n}\n\n// Return systen agent info\nconst AgentInfo* HsaRsrcFactory::GetAgentInfo(const hsa_agent_t agent) {\n  const AgentInfo* agent_info = NULL;\n  auto it = agent_map_.find(agent.handle);\n  if (it != agent_map_.end()) {\n    agent_info = it->second;\n  }\n  return agent_info;\n}\n\n// Get the count of Hsa Gpu Agents available on the platform\n//\n// @return uint32_t Number of Gpu agents on platform\n//\nuint32_t HsaRsrcFactory::GetCountOfGpuAgents() { return uint32_t(gpu_list_.size()); }\n\n// Get the count of Hsa Cpu Agents available on the platform\n//\n// @return uint32_t Number of Cpu agents on platform\n//\nuint32_t HsaRsrcFactory::GetCountOfCpuAgents() { return uint32_t(cpu_list_.size()); }\n\n// Get the AgentInfo handle of a Gpu device\n//\n// @param idx Gpu Agent at specified index\n//\n// @param agent_info Output parameter updated with AgentInfo\n//\n// @return bool true if successful, false otherwise\n//\nbool HsaRsrcFactory::GetGpuAgentInfo(uint32_t idx, const AgentInfo** agent_info) {\n  // Determine if request is valid\n  uint32_t size = uint32_t(gpu_list_.size());\n  if (idx >= size) {\n    return false;\n  }\n\n  // Copy AgentInfo from specified index\n  *agent_info = gpu_list_[idx];\n\n  return true;\n}\n\n// Get the AgentInfo handle of a Cpu device\n//\n// @param idx Cpu Agent at specified index\n//\n// @param agent_info Output parameter updated with AgentInfo\n//\n// @return bool true if successful, false otherwise\n//\nbool HsaRsrcFactory::GetCpuAgentInfo(uint32_t idx, const AgentInfo** agent_info) {\n  // Determine if request is valid\n  uint32_t size = uint32_t(cpu_list_.size());\n  if (idx >= size) {\n    return false;\n  }\n\n  // Copy AgentInfo from specified index\n  *agent_info = cpu_list_[idx];\n  return true;\n}\n\n// Create a Queue object and return its handle. The queue object is expected\n// to support user requested number of Aql dispatch packets.\n//\n// @param agent_info Gpu Agent on which to create a queue object\n//\n// @param num_Pkts Number of packets to be held by queue\n//\n// @param queue Output parameter updated with handle of queue object\n//\n// @return bool true if successful, false otherwise\n//\nbool HsaRsrcFactory::CreateQueue(const AgentInfo* agent_info, uint32_t num_pkts,\n                                 hsa_queue_t** queue) {\n  hsa_status_t status;\n  status = hsa_api_.hsa_queue_create(agent_info->dev_id, num_pkts, HSA_QUEUE_TYPE_MULTI, NULL, NULL,\n                            UINT32_MAX, UINT32_MAX, queue);\n  return (status == HSA_STATUS_SUCCESS);\n}\n\n// Create a Signal object and return its handle.\n// @param value Initial value of signal object\n// @param signal Output parameter updated with handle of signal object\n// @return bool true if successful, false otherwise\nbool HsaRsrcFactory::CreateSignal(uint32_t value, hsa_signal_t* signal) {\n  hsa_status_t status;\n  status = hsa_api_.hsa_signal_create(value, 0, NULL, signal);\n  return (status == HSA_STATUS_SUCCESS);\n}\n\n// Allocate memory for use by a kernel of specified size in specified\n// agent's memory region.\n// @param agent_info Agent from whose memory region to allocate\n// @param size Size of memory in terms of bytes\n// @return uint8_t* Pointer to buffer, null if allocation fails.\nuint8_t* HsaRsrcFactory::AllocateLocalMemory(const AgentInfo* agent_info, size_t size) {\n  hsa_status_t status = HSA_STATUS_ERROR;\n  uint8_t* buffer = NULL;\n  size = (size + MEM_PAGE_MASK) & ~MEM_PAGE_MASK;\n  status = hsa_api_.hsa_amd_memory_pool_allocate(agent_info->gpu_pool, size, 0, reinterpret_cast<void**>(&buffer));\n  uint8_t* ptr = (status == HSA_STATUS_SUCCESS) ? buffer : NULL;\n  return ptr;\n}\n\n// Allocate memory to pass kernel parameters.\n// Memory is alocated accessible for all CPU agents and for GPU given by AgentInfo parameter.\n// @param agent_info Agent from whose memory region to allocate\n// @param size Size of memory in terms of bytes\n// @return uint8_t* Pointer to buffer, null if allocation fails.\nuint8_t* HsaRsrcFactory::AllocateKernArgMemory(const AgentInfo* agent_info, size_t size) {\n  hsa_status_t status = HSA_STATUS_ERROR;\n  uint8_t* buffer = NULL;\n  if (!cpu_agents_.empty()) {\n    size = (size + MEM_PAGE_MASK) & ~MEM_PAGE_MASK;\n    status = hsa_api_.hsa_amd_memory_pool_allocate(*kern_arg_pool_, size, 0, reinterpret_cast<void**>(&buffer));\n    // Both the CPU and GPU can access the kernel arguments\n    if (status == HSA_STATUS_SUCCESS) {\n      hsa_agent_t ag_list[1] = {agent_info->dev_id};\n      status = hsa_api_.hsa_amd_agents_allow_access(1, ag_list, NULL, buffer);\n    }\n  }\n  uint8_t* ptr = (status == HSA_STATUS_SUCCESS) ? buffer : NULL;\n  return ptr;\n}\n\n// Allocate system memory accessible by both CPU and GPU\n// @param agent_info Agent from whose memory region to allocate\n// @param size Size of memory in terms of bytes\n// @return uint8_t* Pointer to buffer, null if allocation fails.\nuint8_t* HsaRsrcFactory::AllocateSysMemory(const AgentInfo* agent_info, size_t size) {\n  hsa_status_t status = HSA_STATUS_ERROR;\n  uint8_t* buffer = NULL;\n  size = (size + MEM_PAGE_MASK) & ~MEM_PAGE_MASK;\n  if (!cpu_agents_.empty()) {\n    status = hsa_api_.hsa_amd_memory_pool_allocate(*cpu_pool_, size, 0, reinterpret_cast<void**>(&buffer));\n    // Both the CPU and GPU can access the memory\n    if (status == HSA_STATUS_SUCCESS) {\n      hsa_agent_t ag_list[1] = {agent_info->dev_id};\n      status = hsa_api_.hsa_amd_agents_allow_access(1, ag_list, NULL, buffer);\n    }\n  }\n  uint8_t* ptr = (status == HSA_STATUS_SUCCESS) ? buffer : NULL;\n  return ptr;\n}\n\n// Allocate memory for command buffer.\n// @param agent_info Agent from whose memory region to allocate\n// @param size Size of memory in terms of bytes\n// @return uint8_t* Pointer to buffer, null if allocation fails.\nuint8_t* HsaRsrcFactory::AllocateCmdMemory(const AgentInfo* agent_info, size_t size) {\n  size = (size + MEM_PAGE_MASK) & ~MEM_PAGE_MASK;\n  uint8_t* ptr = (agent_info->is_apu && CMD_MEMORY_MMAP)\n      ? reinterpret_cast<uint8_t*>(\n            mmap(NULL, size, PROT_READ | PROT_WRITE | PROT_EXEC, MAP_SHARED | MAP_ANONYMOUS, 0, 0))\n      : AllocateSysMemory(agent_info, size);\n  return ptr;\n}\n\n// Wait signal\nhsa_signal_value_t HsaRsrcFactory::SignalWait(const hsa_signal_t& signal, const hsa_signal_value_t& signal_value) const {\n  const hsa_signal_value_t exp_value = signal_value - 1;\n  hsa_signal_value_t ret_value = signal_value;\n  while (1) {\n    ret_value =\n      hsa_api_.hsa_signal_wait_scacquire(signal, HSA_SIGNAL_CONDITION_LT, signal_value, timeout_, HSA_WAIT_STATE_BLOCKED);\n    if (ret_value == exp_value) break;\n    if (ret_value != signal_value) {\n      std::cerr << \"Error: HsaRsrcFactory::SignalWait: signal_value(\" << signal_value\n                << \"), ret_value(\" << ret_value << \")\" << std::endl << std::flush;\n      abort();\n    }\n  }\n  return ret_value;\n}\n\n// Wait signal with signal value restore\nvoid HsaRsrcFactory::SignalWaitRestore(const hsa_signal_t& signal, const hsa_signal_value_t& signal_value) const {\n  SignalWait(signal, signal_value);\n  hsa_api_.hsa_signal_store_relaxed(const_cast<hsa_signal_t&>(signal), signal_value);\n}\n\n// Copy data from GPU to host memory\nbool HsaRsrcFactory::Memcpy(const hsa_agent_t& agent, void* dst, const void* src, size_t size) {\n  hsa_status_t status = HSA_STATUS_ERROR;\n  if (!cpu_agents_.empty()) {\n    hsa_signal_t s = {};\n    status = hsa_api_.hsa_signal_create(1, 0, NULL, &s);\n    CHECK_STATUS(\"hsa_signal_create()\", status);\n    status = hsa_api_.hsa_amd_memory_async_copy(dst, cpu_agents_[0], src, agent, size, 0, NULL, s);\n    CHECK_STATUS(\"hsa_amd_memory_async_copy()\", status);\n    SignalWait(s, 1);\n    status = hsa_api_.hsa_signal_destroy(s);\n    CHECK_STATUS(\"hsa_signal_destroy()\", status);\n  }\n  return (status == HSA_STATUS_SUCCESS);\n}\nbool HsaRsrcFactory::Memcpy(const AgentInfo* agent_info, void* dst, const void* src, size_t size) {\n  return Memcpy(agent_info->dev_id, dst, src, size);\n}\n\n// Memory free method\nbool HsaRsrcFactory::FreeMemory(void* ptr) {\n  const hsa_status_t status = hsa_memory_free(ptr);\n  CHECK_STATUS(\"hsa_memory_free\", status);\n  return (status == HSA_STATUS_SUCCESS);\n}\n\n// Loads an Assembled Brig file and Finalizes it into Device Isa\n// @param agent_info Gpu device for which to finalize\n// @param brig_path File path of the Assembled Brig file\n// @param kernel_name Name of the kernel to finalize\n// @param code_desc Handle of finalized Code Descriptor that could\n// be used to submit for execution\n// @return bool true if successful, false otherwise\nbool HsaRsrcFactory::LoadAndFinalize(const AgentInfo* agent_info, const char* brig_path,\n                                     const char* kernel_name, hsa_executable_t* executable,\n                                     hsa_executable_symbol_t* code_desc) {\n  hsa_status_t status = HSA_STATUS_ERROR;\n\n  // Build the code object filename\n  std::string filename(brig_path);\n  std::clog << \"Code object filename: \" << filename << std::endl;\n\n  // Open the file containing code object\n  hsa_file_t file_handle = open(filename.c_str(), O_RDONLY);\n  if (file_handle == -1) {\n    std::cerr << \"Error: failed to load '\" << filename << \"'\" << std::endl;\n    assert(false);\n    return false;\n  }\n\n  // Create code object reader\n  hsa_code_object_reader_t code_obj_rdr = {0};\n  status = hsa_api_.hsa_code_object_reader_create_from_file(file_handle, &code_obj_rdr);\n  if (status != HSA_STATUS_SUCCESS) {\n    std::cerr << \"Failed to create code object reader '\" << filename << \"'\" << std::endl;\n    return false;\n  }\n\n  // Create executable.\n  status = hsa_api_.hsa_executable_create_alt(HSA_PROFILE_FULL, HSA_DEFAULT_FLOAT_ROUNDING_MODE_DEFAULT,\n                                     NULL, executable);\n  CHECK_STATUS(\"Error in creating executable object\", status);\n\n  // Load code object.\n  status = hsa_api_.hsa_executable_load_agent_code_object(*executable, agent_info->dev_id, code_obj_rdr,\n                                                 NULL, NULL);\n  CHECK_STATUS(\"Error in loading executable object\", status);\n\n  // Freeze executable.\n  status = hsa_api_.hsa_executable_freeze(*executable, \"\");\n  CHECK_STATUS(\"Error in freezing executable object\", status);\n\n  // Get symbol handle.\n  hsa_executable_symbol_t kernelSymbol;\n  status = hsa_api_.hsa_executable_get_symbol(*executable, NULL, kernel_name, agent_info->dev_id, 0,\n                                     &kernelSymbol);\n  CHECK_STATUS(\"Error in looking up kernel symbol\", status);\n\n  // Update output parameter\n  *code_desc = kernelSymbol;\n  return true;\n}\n\n// Print the various fields of Hsa Gpu Agents\nbool HsaRsrcFactory::PrintGpuAgents(const std::string& header) {\n  std::cout << std::flush;\n  std::clog << header << \" :\" << std::endl;\n\n  const AgentInfo* agent_info;\n  int size = uint32_t(gpu_list_.size());\n  for (int idx = 0; idx < size; idx++) {\n    agent_info = gpu_list_[idx];\n\n    std::clog << \"> agent[\" << idx << \"] :\" << std::endl;\n    std::clog << \">> Name : \" << agent_info->name << std::endl;\n    std::clog << \">> APU : \" << agent_info->is_apu << std::endl;\n    std::clog << \">> HSAIL profile : \" << agent_info->profile << std::endl;\n    std::clog << \">> Max Wave Size : \" << agent_info->max_wave_size << std::endl;\n    std::clog << \">> Max Queue Size : \" << agent_info->max_queue_size << std::endl;\n    std::clog << \">> CU number : \" << agent_info->cu_num << std::endl;\n    std::clog << \">> Waves per CU : \" << agent_info->waves_per_cu << std::endl;\n    std::clog << \">> SIMDs per CU : \" << agent_info->simds_per_cu << std::endl;\n    std::clog << \">> SE number : \" << agent_info->se_num << std::endl;\n    std::clog << \">> Shader Arrays per SE : \" << agent_info->shader_arrays_per_se << std::endl;\n  }\n  return true;\n}\n\nuint64_t HsaRsrcFactory::Submit(hsa_queue_t* queue, const void* packet) {\n  const uint32_t slot_size_b = CMD_SLOT_SIZE_B;\n\n  // adevance command queue\n  const uint64_t write_idx = hsa_api_.hsa_queue_load_write_index_relaxed(queue);\n  hsa_api_.hsa_queue_store_write_index_relaxed(queue, write_idx + 1);\n  while ((write_idx - hsa_api_.hsa_queue_load_read_index_relaxed(queue)) >= queue->size) {\n    sched_yield();\n  }\n\n  uint32_t slot_idx = (uint32_t)(write_idx % queue->size);\n  uint32_t* queue_slot = reinterpret_cast<uint32_t*>((uintptr_t)(queue->base_address) + (slot_idx * slot_size_b));\n  const uint32_t* slot_data = reinterpret_cast<const uint32_t*>(packet);\n\n  // Copy buffered commands into the queue slot.\n  // Overwrite the AQL invalid header (first dword) last.\n  // This prevents the slot from being read until it's fully written.\n  memcpy(&queue_slot[1], &slot_data[1], slot_size_b - sizeof(uint32_t));\n  std::atomic<uint32_t>* header_atomic_ptr =\n      reinterpret_cast<std::atomic<uint32_t>*>(&queue_slot[0]);\n  header_atomic_ptr->store(slot_data[0], std::memory_order_release);\n\n  // ringdoor bell\n  hsa_api_.hsa_signal_store_relaxed(queue->doorbell_signal, write_idx);\n\n  return write_idx;\n}\n\nuint64_t HsaRsrcFactory::Submit(hsa_queue_t* queue, const void* packet, size_t size_bytes) {\n  const uint32_t slot_size_b = CMD_SLOT_SIZE_B;\n  if ((size_bytes & (slot_size_b - 1)) != 0) {\n    fprintf(stderr, \"HsaRsrcFactory::Submit: Bad packet size %zx\\n\", size_bytes);\n    abort();\n  }\n\n  const char* begin = reinterpret_cast<const char*>(packet);\n  const char* end = begin + size_bytes;\n  uint64_t write_idx = 0;\n  for (const char* ptr = begin; ptr < end; ptr += slot_size_b) {\n    write_idx = Submit(queue, ptr);\n  }\n\n  return write_idx;\n}\n\nconst char* HsaRsrcFactory::GetKernelNameRef(uint64_t addr) {\n  std::lock_guard<mutex_t> lck(mutex_);\n  const auto it = symbols_map_->find(addr);\n  if (it == symbols_map_->end()) {\n    fprintf(stderr, \"HsaRsrcFactory::kernel addr (0x%lx) is not found\\n\", addr);\n    abort();\n  }\n  return it->second;\n}\n\nvoid HsaRsrcFactory::EnableExecutableTracking(HsaApiTable* table) {\n  std::lock_guard<mutex_t> lck(mutex_);\n  executable_tracking_on_ = true;\n  table->core_->hsa_executable_freeze_fn = hsa_executable_freeze_interceptor;\n}\n\nhsa_status_t HsaRsrcFactory::executable_symbols_cb(hsa_executable_t exec, hsa_executable_symbol_t symbol, void *data) {\n  hsa_symbol_kind_t value = (hsa_symbol_kind_t)0;\n  hsa_status_t status = hsa_api_.hsa_executable_symbol_get_info(symbol, HSA_EXECUTABLE_SYMBOL_INFO_TYPE, &value);\n  CHECK_STATUS(\"Error in getting symbol info\", status);\n  if (value == HSA_SYMBOL_KIND_KERNEL) {\n    uint64_t addr = 0;\n    uint32_t len = 0;\n    status = hsa_api_.hsa_executable_symbol_get_info(symbol, HSA_EXECUTABLE_SYMBOL_INFO_KERNEL_OBJECT, &addr);\n    CHECK_STATUS(\"Error in getting kernel object\", status);\n    status = hsa_api_.hsa_executable_symbol_get_info(symbol, HSA_EXECUTABLE_SYMBOL_INFO_NAME_LENGTH, &len);\n    CHECK_STATUS(\"Error in getting name len\", status);\n    char *name = new char[len + 1];\n    status = hsa_api_.hsa_executable_symbol_get_info(symbol, HSA_EXECUTABLE_SYMBOL_INFO_NAME, name);\n    CHECK_STATUS(\"Error in getting kernel name\", status);\n    name[len] = 0;\n    auto ret = symbols_map_->insert({addr, name});\n    if (ret.second == false) {\n      delete[] ret.first->second;\n      ret.first->second = name;\n    }\n  }\n  return HSA_STATUS_SUCCESS;\n}\n\nhsa_status_t HsaRsrcFactory::hsa_executable_freeze_interceptor(hsa_executable_t executable, const char *options) {\n  std::lock_guard<mutex_t> lck(mutex_);\n  if (symbols_map_ == NULL) symbols_map_ = new symbols_map_t;\n  hsa_status_t status = hsa_api_.hsa_executable_iterate_symbols(executable, executable_symbols_cb, NULL);\n  CHECK_STATUS(\"Error in iterating executable symbols\", status);\n  return hsa_api_.hsa_executable_freeze(executable, options);;\n}\n\nstd::atomic<HsaRsrcFactory*> HsaRsrcFactory::instance_{};\nHsaRsrcFactory::mutex_t HsaRsrcFactory::mutex_;\nHsaRsrcFactory::timestamp_t HsaRsrcFactory::timeout_ns_ = HsaTimer::TIMESTAMP_MAX;\nhsa_pfn_t HsaRsrcFactory::hsa_api_{};\nbool HsaRsrcFactory::executable_tracking_on_ = false;\nHsaRsrcFactory::symbols_map_t* HsaRsrcFactory::symbols_map_ = NULL;\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-rocprofiler-dev-3.5.0-gucmlniizd247uuh2s7vpd4nr6jdzlwp/spack-src/test/simple_convolution/gfx9_SimpleConvolution.hsaco",
        "/tmp/vanessa/spack-stage/spack-stage-rocprofiler-dev-3.5.0-gucmlniizd247uuh2s7vpd4nr6jdzlwp/spack-src/test/simple_convolution/gfx8_SimpleConvolution.hsaco",
        "/tmp/vanessa/spack-stage/spack-stage-rocprofiler-dev-3.5.0-gucmlniizd247uuh2s7vpd4nr6jdzlwp/spack-src/test/dummy_kernel/gfx8_DummyKernel.hsaco",
        "/tmp/vanessa/spack-stage/spack-stage-rocprofiler-dev-3.5.0-gucmlniizd247uuh2s7vpd4nr6jdzlwp/spack-src/test/dummy_kernel/gfx9_DummyKernel.hsaco",
        "/tmp/vanessa/spack-stage/spack-stage-rocprofiler-dev-3.5.0-gucmlniizd247uuh2s7vpd4nr6jdzlwp/spack-src/test/ocl/SimpleConvolution_Kernels.cl"
    ],
    "total_files": 154
}