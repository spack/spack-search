{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-kim-api-2.2.1-e4uhfywqrb6ugjqennpcniwbcyuonf4c/spack-src/cpp/src/KIM_SharedLibrary.cpp": "//\n// CDDL HEADER START\n//\n// The contents of this file are subject to the terms of the Common Development\n// and Distribution License Version 1.0 (the \"License\").\n//\n// You can obtain a copy of the license at\n// http://www.opensource.org/licenses/CDDL-1.0.  See the License for the\n// specific language governing permissions and limitations under the License.\n//\n// When distributing Covered Code, include this CDDL HEADER in each file and\n// include the License file in a prominent location with the name LICENSE.CDDL.\n// If applicable, add the following below this CDDL HEADER, with the fields\n// enclosed by brackets \"[]\" replaced with your own identifying information:\n//\n// Portions Copyright (c) [yyyy] [name of copyright owner]. All rights reserved.\n//\n// CDDL HEADER END\n//\n\n//\n// Copyright (c) 2016--2020, Regents of the University of Minnesota.\n// All rights reserved.\n//\n// Contributors:\n//    Ryan S. Elliott\n//    Alexander Stukowski\n//\n\n//\n// Release: This file is part of the kim-api-2.2.1 package.\n//\n\n#include <cstdio>\n#include <cstring>\n#ifndef _WIN32\n#include <dlfcn.h>\n#else\n#include <libloaderapi.h>\n#endif\n#include <fstream>\n#include <sstream>\n#include <unistd.h>  // IWYU pragma: keep  // For macOS\n\n#ifndef KIM_SHARED_LIBRARY_HPP_\n#include \"KIM_SharedLibrary.hpp\"\n#endif\n\n#ifndef KIM_LOG_VERBOSITY_HPP_\n#include \"KIM_LogVerbosity.hpp\"\n#endif\n\n#ifndef KIM_LOG_HPP_\n#include \"KIM_Log.hpp\"\n#endif\n\n#ifndef KIM_SHARED_LIBRARY_SCHEMA_HPP_\n#include \"KIM_SharedLibrarySchema.hpp\"\n#endif\n\nnamespace\n{\nstatic void * const referencePointForKIM_Library = NULL;\nKIM::FILESYSTEM::Path PrivateGetORIGIN()\n{\n#if !defined(_WIN32) && !defined(__CYGWIN__)\n  Dl_info info;\n  int OK = false;\n  OK = dladdr(&referencePointForKIM_Library, &info);\n  return KIM::FILESYSTEM::Path(OK ? info.dli_fname : \"\").parent_path();\n#else\n  // https://stackoverflow.com/questions/6924195/get-dll-path-at-runtime\n  HMODULE hm = NULL;\n  GetModuleHandleEx(GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS\n                        | GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT,\n                    reinterpret_cast<LPCSTR>(&referencePointForKIM_Library),\n                    &hm);\n  wchar_t pathBuf[MAX_PATH];\n  if (!GetModuleFileNameW(hm, pathBuf, MAX_PATH))\n    return KIM::FILESYSTEM::Path();\n\n  return KIM::FILESYSTEM::Path(pathBuf).parent_path();\n#endif\n}\n}  // namespace\n\n// log helpers\n#define SNUM(x)                                                \\\n  static_cast<std::ostringstream const &>(std::ostringstream() \\\n                                          << std::dec << x)    \\\n      .str()\n#define SPTR(x)                                                            \\\n  static_cast<std::ostringstream const &>(std::ostringstream()             \\\n                                          << static_cast<void const *>(x)) \\\n      .str()\n#define SFUNCP(x)                                                         \\\n  static_cast<std::ostringstream const &>(std::ostringstream()            \\\n                                          << static_cast<Function **>(x)) \\\n      .str()\n\n#include \"KIM_LogMacros.hpp\"\n#define KIM_LOGGER_OBJECT_NAME this\nnamespace KIM\n{\nSharedLibrary::SharedLibrary::EmbeddedFile::EmbeddedFile() :\n    fileName(NULL), fileLength(0), filePointer(NULL)\n{\n}\n\nSharedLibrary::SharedLibrary(Log * const log) :\n    sharedLibraryHandle_(NULL),\n    sharedLibrarySchemaVersion_(NULL),\n    createRoutine_(NULL),\n    numberOfParameterFiles_(0),\n    numberOfMetadataFiles_(0),\n    parameterFileDirectoryName_(\"\"),\n    log_(log)\n{\n#if DEBUG_VERBOSITY\n  std::string const callString = \"SharedLibrary(\" + SPTR(log) + \").\";\n#endif\n  LOG_DEBUG(\"Enter  \" + callString);\n\n  LOG_DEBUG(\"Exit   \" + callString);\n}\n\nSharedLibrary::~SharedLibrary()\n{\n#if DEBUG_VERBOSITY\n  std::string const callString = \"~SharedLibrary().\";\n#endif\n  LOG_DEBUG(\"Enter  \" + callString);\n\n  Close();\n\n  LOG_DEBUG(\"Exit   \" + callString);\n}\n\nint SharedLibrary::Open(FILESYSTEM::Path const & sharedLibraryName)\n{\n#if DEBUG_VERBOSITY\n  std::string const callString = \"Open('\" + sharedLibraryName.string() + \"').\";\n#endif\n  LOG_DEBUG(\"Enter  \" + callString);\n\n  if (sharedLibraryHandle_ != NULL)\n  {\n    LOG_ERROR(\"\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;  // already open\n  }\n\n  sharedLibraryName_ = sharedLibraryName;\n#ifndef _WIN32\n  sharedLibraryHandle_ = dlopen(sharedLibraryName_.string().c_str(), RTLD_NOW);\n#else\n  FILESYSTEM::Path winPath = sharedLibraryName;\n  sharedLibraryHandle_ = (void *) LoadLibraryExW(\n      winPath.make_preferred().c_str(), NULL, LOAD_WITH_ALTERED_SEARCH_PATH);\n#endif\n  if (sharedLibraryHandle_ == NULL)\n  {\n    LOG_ERROR(\"Unable to open '\" + sharedLibraryName_.string() + \"'.\");\n#ifndef _WIN32\n    LOG_ERROR(dlerror());\n#endif\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;\n  }\n#ifndef _WIN32\n  sharedLibrarySchemaVersion_ = reinterpret_cast<int const *>(\n      dlsym(sharedLibraryHandle_, \"kim_shared_library_schema_version\"));\n#else\n  sharedLibrarySchemaVersion_ = reinterpret_cast<int const *>(::GetProcAddress(\n      (HMODULE) sharedLibraryHandle_, \"kim_shared_library_schema_version\"));\n#endif\n  if (sharedLibrarySchemaVersion_ == NULL)\n  {\n    LOG_ERROR(\n        \"Failed to look up symbol 'kim_shared_library_schema_version' in '\"\n        + sharedLibraryName_.string() + \"'.\");\n#ifndef _WIN32\n    LOG_ERROR(dlerror());\n#endif\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;\n  }\n\n\n  if (*sharedLibrarySchemaVersion_ == 2)\n  {\n    using namespace SHARED_LIBRARY_SCHEMA;\n#ifndef _WIN32\n    SharedLibrarySchemaV2 const * const schemaV2\n        = reinterpret_cast<SharedLibrarySchemaV2 const *>(\n            dlsym(sharedLibraryHandle_, \"kim_shared_library_schema\"));\n#else\n    SharedLibrarySchemaV2 const * const schemaV2\n        = reinterpret_cast<SharedLibrarySchemaV2 const *>(::GetProcAddress(\n            (HMODULE) sharedLibraryHandle_, \"kim_shared_library_schema\"));\n#endif\n    if (schemaV2 == NULL)\n    {\n      LOG_ERROR(\"Failed to look up symbol 'kim_shared_library_schema' in '\"\n                + sharedLibraryName_.string() + \"'.\");\n#ifndef _WIN32\n      LOG_ERROR(dlerror());\n#endif\n      LOG_DEBUG(\"Exit 1=\" + callString);\n      return true;\n    }\n\n    itemType_ = schemaV2->itemType;\n    createLanguageName_ = schemaV2->createLanguageName;\n    createRoutine_ = schemaV2->createRoutine;\n    driverName_ = ((schemaV2->driverName) ? schemaV2->driverName : \"\");\n\n    if (schemaV2->simulatorModelSpecificationFile != NULL)\n    {\n      simulatorModelSpecificationFile_.fileName\n          = schemaV2->simulatorModelSpecificationFile->fileName;\n      simulatorModelSpecificationFile_.fileLength\n          = schemaV2->simulatorModelSpecificationFile->fileLength;\n      simulatorModelSpecificationFile_.filePointer\n          = schemaV2->simulatorModelSpecificationFile->filePointer;\n    }\n\n    numberOfParameterFiles_ = schemaV2->numberOfParameterFiles;\n    for (int i = 0; i < numberOfParameterFiles_; ++i)\n    {\n      EmbeddedFile fl;\n      fl.fileName = schemaV2->parameterFiles[i].fileName;\n      fl.fileLength = schemaV2->parameterFiles[i].fileLength;\n      fl.filePointer = schemaV2->parameterFiles[i].filePointer;\n\n      parameterFiles_.push_back(fl);\n    }\n    numberOfMetadataFiles_ = schemaV2->numberOfMetadataFiles;\n    for (int i = 0; i < numberOfMetadataFiles_; ++i)\n    {\n      EmbeddedFile fl;\n      fl.fileName = schemaV2->metadataFiles[i].fileName;\n      fl.fileLength = schemaV2->metadataFiles[i].fileLength;\n      fl.filePointer = schemaV2->metadataFiles[i].filePointer;\n\n      metadataFiles_.push_back(fl);\n    }\n  }\n  else if (*sharedLibrarySchemaVersion_ == 1)\n  {\n    using namespace SHARED_LIBRARY_SCHEMA;\n#ifndef _WIN32\n    SharedLibrarySchemaV1 const * const schemaV1\n        = reinterpret_cast<SharedLibrarySchemaV1 const *>(\n            dlsym(sharedLibraryHandle_, \"kim_shared_library_schema\"));\n#else\n    SharedLibrarySchemaV1 const * const schemaV1\n        = reinterpret_cast<SharedLibrarySchemaV1 const *>(::GetProcAddress(\n            (HMODULE) sharedLibraryHandle_, \"kim_shared_library_schema\"));\n#endif\n    if (schemaV1 == NULL)\n    {\n      LOG_ERROR(\"Failed to look up symbol 'kim_shared_library_schema' in '\"\n                + sharedLibraryName_.string() + \"'.\");\n#ifndef _WIN32\n      LOG_ERROR(dlerror());\n#endif\n      LOG_DEBUG(\"Exit 1=\" + callString);\n      return true;\n    }\n\n    if (schemaV1->itemType == SharedLibrarySchemaV1::STAND_ALONE_MODEL)\n    {\n      itemType_ = COLLECTION_ITEM_TYPE::portableModel;\n    }\n    else if (schemaV1->itemType == SharedLibrarySchemaV1::PARAMETERIZED_MODEL)\n    {\n      itemType_ = COLLECTION_ITEM_TYPE::portableModel;\n      // differentiated from above by driverName_\n    }\n    else if (schemaV1->itemType == SharedLibrarySchemaV1::SIMULATOR_MODEL)\n    {\n      itemType_ = COLLECTION_ITEM_TYPE::simulatorModel;\n    }\n    else if (schemaV1->itemType == SharedLibrarySchemaV1::MODEL_DRIVER)\n    {\n      itemType_ = COLLECTION_ITEM_TYPE::modelDriver;\n    }\n    else\n    {\n      LOG_ERROR(\"SHOULD NEVER GET HERE.\");\n      LOG_DEBUG(\"Exit 1=\" + callString);\n      return true;\n    }\n\n    createLanguageName_ = schemaV1->createLanguageName;\n    createRoutine_ = schemaV1->createRoutine;\n    driverName_ = ((schemaV1->driverName) ? schemaV1->driverName : \"\");\n\n    if (schemaV1->metadataFile != NULL)\n    {\n      simulatorModelSpecificationFile_.fileName\n          = schemaV1->metadataFile->fileName;\n      simulatorModelSpecificationFile_.fileLength\n          = schemaV1->metadataFile->fileLength;\n      simulatorModelSpecificationFile_.filePointer\n          = schemaV1->metadataFile->filePointer;\n    }\n\n    numberOfParameterFiles_ = schemaV1->numberOfParameterFiles;\n    for (int i = 0; i < numberOfParameterFiles_; ++i)\n    {\n      EmbeddedFile fl;\n      fl.fileName = schemaV1->parameterFiles[i].fileName;\n      fl.fileLength = schemaV1->parameterFiles[i].fileLength;\n      fl.filePointer = schemaV1->parameterFiles[i].filePointer;\n\n      parameterFiles_.push_back(fl);\n    }\n    numberOfMetadataFiles_ = 1;\n    EmbeddedFile fl;\n    fl.fileName = \"compiled-with-version.txt\";\n    fl.fileLength = strlen(schemaV1->compiledWithVersion);\n    fl.filePointer = reinterpret_cast<unsigned char const *>(\n        schemaV1->compiledWithVersion);\n    metadataFiles_.push_back(fl);\n  }\n  else\n  {\n    LOG_ERROR(\"Unknown KIM::SharedLibrarySchema version.\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;\n  }\n\n  LOG_DEBUG(\"Exit 0=\" + callString);\n  return false;\n}\n\nint SharedLibrary::Close()\n{\n#if DEBUG_VERBOSITY\n  std::string const callString = \"Close().\";\n#endif\n  LOG_DEBUG(\"Enter  \" + callString);\n\n  if (sharedLibraryHandle_ == NULL)\n  {\n    LOG_ERROR(\"SharedLibrary not open.\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;  // not open\n  }\n\n  RemoveParameterFileDirectory();\n\n  sharedLibraryName_.clear();\n  sharedLibrarySchemaVersion_ = 0;\n  createRoutine_ = NULL;\n  driverName_ = \"\";\n  simulatorModelSpecificationFile_.fileName = NULL;\n  simulatorModelSpecificationFile_.fileLength = 0;\n  simulatorModelSpecificationFile_.filePointer = NULL;\n  numberOfParameterFiles_ = 0;\n  parameterFiles_.clear();\n  numberOfMetadataFiles_ = 0;\n  metadataFiles_.clear();\n#ifndef _WIN32\n  int error = dlclose(sharedLibraryHandle_);\n#else\n  int error = !::FreeLibrary((HMODULE) sharedLibraryHandle_);\n#endif\n  if (error)\n  {\n    LOG_ERROR(\"\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;\n  }\n  else\n  {\n    sharedLibraryHandle_ = NULL;\n  }\n\n  LOG_DEBUG(\"Exit 0=\" + callString);\n  return false;\n}\n\nint SharedLibrary::GetType(CollectionItemType * const type) const\n{\n#if DEBUG_VERBOSITY\n  std::string const callString = \"GetType(\" + SPTR(type) + \").\";\n#endif\n  LOG_DEBUG(\"Enter  \" + callString);\n\n  if (sharedLibraryHandle_ == NULL)\n  {\n    LOG_ERROR(\"Library not open.\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;  // not open\n  }\n\n  *type = itemType_;\n\n  LOG_DEBUG(\"Exit 0=\" + callString);\n  return false;\n}\n\nint SharedLibrary::GetCreateFunctionPointer(\n    LanguageName * const languageName, Function ** const functionPointer) const\n{\n#if DEBUG_VERBOSITY\n  std::string const callString = \"GetCreateFunctionPointer(\"\n                                 + SPTR(languageName) + \", \"\n                                 + SFUNCP(functionPointer) + \").\";\n#endif\n  LOG_DEBUG(\"Enter  \" + callString);\n\n  if (sharedLibraryHandle_ == NULL)\n  {\n    LOG_ERROR(\"Library not open.\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;  // not open\n  }\n\n  if (languageName != NULL) *languageName = createLanguageName_;\n  if (functionPointer != NULL) *functionPointer = createRoutine_;\n\n  LOG_DEBUG(\"Exit 0=\" + callString);\n  return false;\n}\n\nint SharedLibrary::GetNumberOfParameterFiles(\n    int * const numberOfParameterFiles) const\n{\n#if DEBUG_VERBOSITY\n  std::string const callString\n      = \"GetNumberOfParameterFiles(\" + SPTR(numberOfParameterFiles) + \").\";\n#endif\n  LOG_DEBUG(\"Enter  \" + callString);\n\n  if (sharedLibraryHandle_ == NULL)\n  {\n    LOG_ERROR(\"Library not open.\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;  // not open\n  }\n\n  *numberOfParameterFiles = numberOfParameterFiles_;\n\n  LOG_DEBUG(\"Exit 0=\" + callString);\n  return false;\n}\n\nint SharedLibrary::GetParameterFile(\n    int const index,\n    std::string * const parameterFileName,\n    unsigned int * const parameterFileLength,\n    unsigned char const ** const parameterFileData) const\n{\n#if DEBUG_VERBOSITY\n  std::string const callString = \"GetParameterFile(\" + SNUM(index) + \", \"\n                                 + SPTR(parameterFileName) + \", \"\n                                 + SPTR(parameterFileLength) + \", \"\n                                 + SPTR(parameterFileData) + \").\";\n#endif\n  LOG_DEBUG(\"Enter  \" + callString);\n\n  if (sharedLibraryHandle_ == NULL)\n  {\n    LOG_ERROR(\"Library not open.\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;  // not open\n  }\n\n  if (((itemType_ == COLLECTION_ITEM_TYPE::portableModel)\n       && (driverName_ == \"\"))\n      || (itemType_ == COLLECTION_ITEM_TYPE::modelDriver))\n  {\n    LOG_ERROR(\"This item type does not have parameter files.\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;\n  }\n\n  if ((index < 0) || index >= numberOfParameterFiles_)\n  {\n    LOG_ERROR(\"Invalid parameter file index.\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;\n  }\n\n  if (parameterFileName != NULL)\n    *parameterFileName = (parameterFiles_[index]).fileName;\n  if (parameterFileLength != NULL)\n    *parameterFileLength = (parameterFiles_[index]).fileLength;\n  if (parameterFileData != NULL)\n    *parameterFileData = (parameterFiles_[index]).filePointer;\n\n  LOG_DEBUG(\"Exit 0=\" + callString);\n  return false;\n}\n\nint SharedLibrary::GetNumberOfMetadataFiles(\n    int * const numberOfMetadataFiles) const\n{\n#if DEBUG_VERBOSITY\n  std::string const callString\n      = \"GetNumberOfMetadataFiles(\" + SPTR(numberOfMetadataFiles) + \").\";\n#endif\n  LOG_DEBUG(\"Enter  \" + callString);\n\n  if (sharedLibraryHandle_ == NULL)\n  {\n    LOG_ERROR(\"Library not open.\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;  // not open\n  }\n\n  *numberOfMetadataFiles = numberOfMetadataFiles_;\n\n  LOG_DEBUG(\"Exit 0=\" + callString);\n  return false;\n}\n\nint SharedLibrary::GetMetadataFile(\n    int const index,\n    std::string * const metadataFileName,\n    unsigned int * const metadataFileLength,\n    unsigned char const ** const metadataFileData) const\n{\n#if DEBUG_VERBOSITY\n  std::string const callString\n      = \"GetMetadataFile(\" + SNUM(index) + \", \" + SPTR(metadataFileName) + \", \"\n        + SPTR(metadataFileLength) + \", \" + SPTR(metadataFileData) + \").\";\n#endif\n  LOG_DEBUG(\"Enter  \" + callString);\n\n  if (sharedLibraryHandle_ == NULL)\n  {\n    LOG_ERROR(\"Library not open.\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;  // not open\n  }\n\n  if ((index < 0) || index >= numberOfMetadataFiles_)\n  {\n    LOG_ERROR(\"Invalid metadata file index.\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;\n  }\n\n  if (metadataFileName != NULL)\n    *metadataFileName = (metadataFiles_[index]).fileName;\n  if (metadataFileLength != NULL)\n    *metadataFileLength = (metadataFiles_[index]).fileLength;\n  if (metadataFileData != NULL)\n    *metadataFileData = (metadataFiles_[index]).filePointer;\n\n  LOG_DEBUG(\"Exit 0=\" + callString);\n  return false;\n}\n\nint SharedLibrary::GetSimulatorModelSpecificationFile(\n    std::string * const specFileName,\n    unsigned int * const specFileLength,\n    unsigned char const ** const specFileData) const\n{\n#if DEBUG_VERBOSITY\n  std::string const callString\n      = \"GetSimulatorModelSpecificationFile(, \" + SPTR(specFileName) + \", \"\n        + SPTR(specFileLength) + \", \" + SPTR(specFileData) + \").\";\n#endif\n  LOG_DEBUG(\"Enter  \" + callString);\n\n  if (sharedLibraryHandle_ == NULL)\n  {\n    LOG_ERROR(\"Library not open.\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;  // not open\n  }\n\n  if (itemType_ != COLLECTION_ITEM_TYPE::simulatorModel)\n  {\n    LOG_ERROR(\n        \"This item type does not have a simulator model specification file.\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;\n  }\n\n  if (specFileName != NULL)\n    *specFileName = (simulatorModelSpecificationFile_).fileName;\n  if (specFileLength != NULL)\n    *specFileLength = (simulatorModelSpecificationFile_).fileLength;\n  if (specFileData != NULL)\n    *specFileData = (simulatorModelSpecificationFile_).filePointer;\n\n  LOG_DEBUG(\"Exit 0=\" + callString);\n  return false;\n}\n\nint SharedLibrary::WriteParameterFileDirectory()\n{\n#if DEBUG_VERBOSITY\n  std::string const callString = \"WriteParameterFileDirectory().\";\n#endif\n  LOG_DEBUG(\"Enter  \" + callString);\n\n  int error;\n\n  if (sharedLibraryHandle_ == NULL)\n  {\n    LOG_ERROR(\"Library not open.\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;  // not open\n  }\n\n  parameterFileDirectoryName_ = FILESYSTEM::Path::CreateTemporaryDirectory(\n      \"kim-shared-library-parameter-file-directory-\");\n  if (parameterFileDirectoryName_.empty())\n  {\n    LOG_ERROR(\"Could not create a secure temporary directory.\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;\n  }\n\n  if (itemType_ == KIM::COLLECTION_ITEM_TYPE::simulatorModel)\n  {\n    unsigned int len;\n    unsigned char const * specificationData;\n    std::string specFileName;\n    error = GetSimulatorModelSpecificationFile(\n        &specFileName, &len, &specificationData);\n    if (error)\n    {\n      LOG_ERROR(\"Unable to get specification file.\");\n      RemoveParameterFileDirectory();\n      LOG_DEBUG(\"Exit 1=\" + callString);\n      return true;\n    }\n    FILESYSTEM::Path const specificationFilePathName\n        = parameterFileDirectoryName_ / specFileName;\n    std::ofstream fl;\n    fl.open(specificationFilePathName.string().c_str(),\n            std::ifstream::out | std::ifstream::binary);\n    fl.write(reinterpret_cast<const char *>(specificationData), len);\n    if (!fl)\n    {\n      LOG_ERROR(\"Unable to get write parameter file.\");\n      fl.close();\n      RemoveParameterFileDirectory();\n      LOG_DEBUG(\"Exit 1=\" + callString);\n      return true;\n    }\n  }\n\n  int noParamFiles;\n  GetNumberOfParameterFiles(&noParamFiles);\n  for (int i = 0; i < noParamFiles; ++i)\n  {\n    std::string parameterFileName;\n    unsigned char const * strPtr;\n    unsigned int length;\n    error = GetParameterFile(i, &parameterFileName, &length, &strPtr);\n    if (error)\n    {\n      LOG_ERROR(\"Could not get parameter file data.\");\n      LOG_DEBUG(\"Exit 1=\" + callString);\n      return true;\n    }\n\n    FILESYSTEM::Path const parameterFilePathName\n        = parameterFileDirectoryName_ / parameterFileName;\n    std::ofstream fl;\n    fl.open(parameterFilePathName.string().c_str(),\n            std::ifstream::out | std::ifstream::binary);\n    fl.write(reinterpret_cast<const char *>(strPtr), length);\n    if (!fl)\n    {\n      LOG_ERROR(\"Unable to get write parameter file.\");\n      fl.close();\n      RemoveParameterFileDirectory();\n      LOG_DEBUG(\"Exit 1=\" + callString);\n      return true;\n    }\n  }\n\n  LOG_DEBUG(\"Exit 0=\" + callString);\n  return false;\n}\n\nint SharedLibrary::GetParameterFileDirectoryName(\n    FILESYSTEM::Path * const directoryName) const\n{\n#if DEBUG_VERBOSITY\n  std::string const callString\n      = \"GetParameterFileDirectoryName(\" + SPTR(directoryName) + \").\";\n#endif\n  LOG_DEBUG(\"Enter  \" + callString);\n\n  if (sharedLibraryHandle_ == NULL)\n  {\n    LOG_ERROR(\"Library not open.\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;  // not open\n  }\n\n  *directoryName = parameterFileDirectoryName_;\n\n  LOG_DEBUG(\"Exit 0=\" + callString);\n  return false;\n}\n\nint SharedLibrary::RemoveParameterFileDirectory()\n{\n#if DEBUG_VERBOSITY\n  std::string const callString = \"RemoveParameterFileDirectory().\";\n#endif\n  LOG_DEBUG(\"Enter  \" + callString);\n\n  if (sharedLibraryHandle_ == NULL)\n  {\n    LOG_ERROR(\"Library not open.\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;  // not open\n  }\n\n  if (!parameterFileDirectoryName_.empty())\n  {\n    if (parameterFileDirectoryName_.RemoveDirectoryRecursive())\n    {\n      LOG_ERROR(\"Unable to remove simulator model parameter file directory '\"\n                + parameterFileDirectoryName_.string() + \"'.\");\n    }\n\n    // clear out directory name variable\n    parameterFileDirectoryName_.clear();\n  }\n\n  LOG_DEBUG(\"Exit 0=\" + callString);\n  return false;\n}\n\nint SharedLibrary::GetDriverName(std::string * const driverName) const\n{\n#if DEBUG_VERBOSITY\n  std::string const callString = \"GetDriverName(\" + SPTR(driverName) + \").\";\n#endif\n  LOG_DEBUG(\"Enter  \" + callString);\n\n  if (sharedLibraryHandle_ == NULL)\n  {\n    LOG_ERROR(\"Library not open.\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;  // not open\n  }\n\n  if ((itemType_ != COLLECTION_ITEM_TYPE::portableModel) && (driverName_ != \"\"))\n  {\n    LOG_ERROR(\"This item type does not have an associated  model driver.\");\n    LOG_DEBUG(\"Exit 1=\" + callString);\n    return true;\n  }\n\n  *driverName = driverName_;\n\n  LOG_DEBUG(\"Exit 0=\" + callString);\n  return false;\n}  // namespace KIM\n\nvoid SharedLibrary::LogEntry(LogVerbosity const logVerbosity,\n                             std::string const & message,\n                             int const lineNumber,\n                             std::string const & fileName) const\n{\n  if (log_ != NULL) log_->LogEntry(logVerbosity, message, lineNumber, fileName);\n}\n\nFILESYSTEM::Path const SharedLibrary::ORIGIN = PrivateGetORIGIN();\n\nFILESYSTEM::Path SharedLibrary::GetORIGIN() { return ORIGIN; }\n}  // namespace KIM\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-kim-api-2.2.1-e4uhfywqrb6ugjqennpcniwbcyuonf4c/spack-src/examples/model-drivers/LennardJones612__MD_414112407348_003/LICENSE.CDDL",
        "/tmp/vanessa/spack-stage/spack-stage-kim-api-2.2.1-e4uhfywqrb6ugjqennpcniwbcyuonf4c/spack-src/examples/portable-models/LennardJones612_UniversalShifted__MO_959249795837_003/LICENSE.CDDL",
        "/tmp/vanessa/spack-stage/spack-stage-kim-api-2.2.1-e4uhfywqrb6ugjqennpcniwbcyuonf4c/spack-src/docs/src/asymptote-figures/square-lattice-configuration-1.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-kim-api-2.2.1-e4uhfywqrb6ugjqennpcniwbcyuonf4c/spack-src/docs/src/asymptote-figures/square-lattice-configuration-1.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-kim-api-2.2.1-e4uhfywqrb6ugjqennpcniwbcyuonf4c/spack-src/docs/src/asymptote-figures/square-lattice-configuration-2.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-kim-api-2.2.1-e4uhfywqrb6ugjqennpcniwbcyuonf4c/spack-src/docs/src/asymptote-figures/square-lattice-configuration-2.jpg"
    ],
    "total_files": 360
}