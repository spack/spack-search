{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/src/nvim/lua/treesitter.c": "// This is an open source non-commercial project. Dear PVS-Studio, please check\n// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n\n// lua bindings for tree-sitter.\n// NB: this file mostly contains a generic lua interface for tree-sitter\n// trees and nodes, and could be broken out as a reusable lua package\n\n#include <stdbool.h>\n#include <stdlib.h>\n#include <string.h>\n#include <inttypes.h>\n#include <assert.h>\n\n#include <lua.h>\n#include <lualib.h>\n#include <lauxlib.h>\n\n#include \"tree_sitter/api.h\"\n\n#include \"nvim/lua/treesitter.h\"\n#include \"nvim/api/private/handle.h\"\n#include \"nvim/memline.h\"\n#include \"nvim/buffer.h\"\n\n#define TS_META_PARSER \"treesitter_parser\"\n#define TS_META_TREE \"treesitter_tree\"\n#define TS_META_NODE \"treesitter_node\"\n#define TS_META_QUERY \"treesitter_query\"\n#define TS_META_QUERYCURSOR \"treesitter_querycursor\"\n#define TS_META_TREECURSOR \"treesitter_treecursor\"\n\ntypedef struct {\n  TSQueryCursor *cursor;\n  int predicated_match;\n} TSLua_cursor;\n\n#ifdef INCLUDE_GENERATED_DECLARATIONS\n# include \"lua/treesitter.c.generated.h\"\n#endif\n\nstatic struct luaL_Reg parser_meta[] = {\n  { \"__gc\", parser_gc },\n  { \"__tostring\", parser_tostring },\n  { \"parse\", parser_parse },\n  { \"set_included_ranges\", parser_set_ranges },\n  { \"included_ranges\", parser_get_ranges },\n  { NULL, NULL }\n};\n\nstatic struct luaL_Reg tree_meta[] = {\n  { \"__gc\", tree_gc },\n  { \"__tostring\", tree_tostring },\n  { \"root\", tree_root },\n  { \"edit\", tree_edit },\n  { \"copy\", tree_copy },\n  { NULL, NULL }\n};\n\nstatic struct luaL_Reg node_meta[] = {\n  { \"__tostring\", node_tostring },\n  { \"__eq\", node_eq },\n  { \"__len\", node_child_count },\n  { \"id\", node_id },\n  { \"range\", node_range },\n  { \"start\", node_start },\n  { \"end_\", node_end },\n  { \"type\", node_type },\n  { \"symbol\", node_symbol },\n  { \"field\", node_field },\n  { \"named\", node_named },\n  { \"missing\", node_missing },\n  { \"has_error\", node_has_error },\n  { \"sexpr\", node_sexpr },\n  { \"child_count\", node_child_count },\n  { \"named_child_count\", node_named_child_count },\n  { \"child\", node_child },\n  { \"named_child\", node_named_child },\n  { \"descendant_for_range\", node_descendant_for_range },\n  { \"named_descendant_for_range\", node_named_descendant_for_range },\n  { \"parent\", node_parent },\n  { \"iter_children\", node_iter_children },\n  { \"_rawquery\", node_rawquery },\n  { NULL, NULL }\n};\n\nstatic struct luaL_Reg query_meta[] = {\n  { \"__gc\", query_gc },\n  { \"__tostring\", query_tostring },\n  { \"inspect\", query_inspect },\n  { NULL, NULL }\n};\n\n// cursors are not exposed, but still needs garbage collection\nstatic struct luaL_Reg querycursor_meta[] = {\n  { \"__gc\", querycursor_gc },\n  { NULL, NULL }\n};\n\nstatic struct luaL_Reg treecursor_meta[] = {\n  { \"__gc\", treecursor_gc },\n  { NULL, NULL }\n};\n\nstatic PMap(cstr_t) *langs;\n\nstatic void build_meta(lua_State *L, const char *tname, const luaL_Reg *meta)\n{\n  if (luaL_newmetatable(L, tname)) {  // [meta]\n    luaL_register(L, NULL, meta);\n\n    lua_pushvalue(L, -1);  // [meta, meta]\n    lua_setfield(L, -2, \"__index\");  // [meta]\n  }\n  lua_pop(L, 1);  // [] (don't use it now)\n}\n\n/// init the tslua library\n///\n/// all global state is stored in the regirstry of the lua_State\nvoid tslua_init(lua_State *L)\n{\n  langs = pmap_new(cstr_t)();\n\n  // type metatables\n  build_meta(L, TS_META_PARSER, parser_meta);\n  build_meta(L, TS_META_TREE, tree_meta);\n  build_meta(L, TS_META_NODE, node_meta);\n  build_meta(L, TS_META_QUERY, query_meta);\n  build_meta(L, TS_META_QUERYCURSOR, querycursor_meta);\n  build_meta(L, TS_META_TREECURSOR, treecursor_meta);\n}\n\nint tslua_has_language(lua_State *L)\n{\n  const char *lang_name = luaL_checkstring(L, 1);\n  lua_pushboolean(L, pmap_has(cstr_t)(langs, lang_name));\n  return 1;\n}\n\nint tslua_add_language(lua_State *L)\n{\n  const char *path = luaL_checkstring(L, 1);\n  const char *lang_name = luaL_checkstring(L, 2);\n\n  if (pmap_has(cstr_t)(langs, lang_name)) {\n    return 0;\n  }\n\n#define BUFSIZE 128\n  char symbol_buf[BUFSIZE];\n  snprintf(symbol_buf, BUFSIZE, \"tree_sitter_%s\", lang_name);\n#undef BUFSIZE\n\n  uv_lib_t lib;\n  if (uv_dlopen(path, &lib)) {\n    snprintf((char *)IObuff, IOSIZE, \"Failed to load parser: uv_dlopen: %s\",\n             uv_dlerror(&lib));\n    uv_dlclose(&lib);\n    lua_pushstring(L, (char *)IObuff);\n    return lua_error(L);\n  }\n\n  TSLanguage *(*lang_parser)(void);\n  if (uv_dlsym(&lib, symbol_buf, (void **)&lang_parser)) {\n    snprintf((char *)IObuff, IOSIZE, \"Failed to load parser: uv_dlsym: %s\",\n             uv_dlerror(&lib));\n    uv_dlclose(&lib);\n    lua_pushstring(L, (char *)IObuff);\n    return lua_error(L);\n  }\n\n  TSLanguage *lang = lang_parser();\n  if (lang == NULL) {\n    return luaL_error(L, \"Failed to load parser: internal error\");\n  }\n\n  uint32_t lang_version = ts_language_version(lang);\n  if (lang_version < TREE_SITTER_MIN_COMPATIBLE_LANGUAGE_VERSION\n      || lang_version > TREE_SITTER_LANGUAGE_VERSION) {\n    return luaL_error(\n        L,\n        \"ABI version mismatch : supported between %d and %d, found %d\",\n        TREE_SITTER_MIN_COMPATIBLE_LANGUAGE_VERSION,\n        TREE_SITTER_LANGUAGE_VERSION, lang_version);\n  }\n\n  pmap_put(cstr_t)(langs, xstrdup(lang_name), lang);\n\n  lua_pushboolean(L, true);\n  return 1;\n}\n\nint tslua_inspect_lang(lua_State *L)\n{\n  const char *lang_name = luaL_checkstring(L, 1);\n\n  TSLanguage *lang = pmap_get(cstr_t)(langs, lang_name);\n  if (!lang) {\n    return luaL_error(L, \"no such language: %s\", lang_name);\n  }\n\n  lua_createtable(L, 0, 2);  // [retval]\n\n  size_t nsymbols = (size_t)ts_language_symbol_count(lang);\n\n  lua_createtable(L, nsymbols-1, 1);  // [retval, symbols]\n  for (size_t i = 0; i < nsymbols; i++) {\n    TSSymbolType t = ts_language_symbol_type(lang, i);\n    if (t == TSSymbolTypeAuxiliary) {\n      // not used by the API\n      continue;\n    }\n    lua_createtable(L, 2, 0);  // [retval, symbols, elem]\n    lua_pushstring(L, ts_language_symbol_name(lang, i));\n    lua_rawseti(L, -2, 1);\n    lua_pushboolean(L, t == TSSymbolTypeRegular);\n    lua_rawseti(L, -2, 2);  // [retval, symbols, elem]\n    lua_rawseti(L, -2, i);  // [retval, symbols]\n  }\n\n  lua_setfield(L, -2, \"symbols\");  // [retval]\n\n  size_t nfields = (size_t)ts_language_field_count(lang);\n  lua_createtable(L, nfields-1, 1);  // [retval, fields]\n  for (size_t i = 0; i < nfields; i++) {\n    lua_pushstring(L, ts_language_field_name_for_id(lang, i));\n    lua_rawseti(L, -2, i);  // [retval, fields]\n  }\n\n  lua_setfield(L, -2, \"fields\");  // [retval]\n  return 1;\n}\n\nint tslua_push_parser(lua_State *L)\n{\n  // Gather language name\n  const char *lang_name = luaL_checkstring(L, 1);\n\n  TSLanguage *lang = pmap_get(cstr_t)(langs, lang_name);\n  if (!lang) {\n    return luaL_error(L, \"no such language: %s\", lang_name);\n  }\n\n  TSParser **parser = lua_newuserdata(L, sizeof(TSParser *));\n  *parser = ts_parser_new();\n\n  if (!ts_parser_set_language(*parser, lang)) {\n    ts_parser_delete(*parser);\n    return luaL_error(L, \"Failed to load language : %s\", lang_name);\n  }\n\n  lua_getfield(L, LUA_REGISTRYINDEX, TS_META_PARSER);  // [udata, meta]\n  lua_setmetatable(L, -2);  // [udata]\n  return 1;\n}\n\nstatic TSParser ** parser_check(lua_State *L, uint16_t index)\n{\n  return luaL_checkudata(L, index, TS_META_PARSER);\n}\n\nstatic int parser_gc(lua_State *L)\n{\n  TSParser **p = parser_check(L, 1);\n  if (!p) {\n    return 0;\n  }\n\n  ts_parser_delete(*p);\n  return 0;\n}\n\nstatic int parser_tostring(lua_State *L)\n{\n  lua_pushstring(L, \"<parser>\");\n  return 1;\n}\n\nstatic const char *input_cb(void *payload, uint32_t byte_index,\n                            TSPoint position, uint32_t *bytes_read)\n{\n  buf_T *bp  = payload;\n#define BUFSIZE 256\n  static char buf[BUFSIZE];\n\n  if ((linenr_T)position.row >= bp->b_ml.ml_line_count) {\n    *bytes_read = 0;\n    return \"\";\n  }\n  char_u *line = ml_get_buf(bp, position.row+1, false);\n  size_t len = STRLEN(line);\n  if (position.column > len) {\n    *bytes_read = 0;\n    return \"\";\n  }\n  size_t tocopy = MIN(len-position.column, BUFSIZE);\n\n  memcpy(buf, line+position.column, tocopy);\n  // Translate embedded \\n to NUL\n  memchrsub(buf, '\\n', '\\0', tocopy);\n  *bytes_read = (uint32_t)tocopy;\n  if (tocopy < BUFSIZE) {\n    // now add the final \\n. If it didn't fit, input_cb will be called again\n    // on the same line with advanced column.\n    buf[tocopy] = '\\n';\n    (*bytes_read)++;\n  }\n  return buf;\n#undef BUFSIZE\n}\n\nstatic void push_ranges(lua_State *L,\n                        const TSRange *ranges,\n                        const unsigned int length)\n{\n  lua_createtable(L, length, 0);\n  for (size_t i = 0; i < length; i++) {\n    lua_createtable(L, 4, 0);\n    lua_pushinteger(L, ranges[i].start_point.row);\n    lua_rawseti(L, -2, 1);\n    lua_pushinteger(L, ranges[i].start_point.column);\n    lua_rawseti(L, -2, 2);\n    lua_pushinteger(L, ranges[i].end_point.row);\n    lua_rawseti(L, -2, 3);\n    lua_pushinteger(L, ranges[i].end_point.column);\n    lua_rawseti(L, -2, 4);\n\n    lua_rawseti(L, -2, i+1);\n  }\n}\n\nstatic int parser_parse(lua_State *L)\n{\n  TSParser **p = parser_check(L, 1);\n  if (!p || !(*p)) {\n    return 0;\n  }\n\n  TSTree *old_tree = NULL;\n  if (!lua_isnil(L, 2)) {\n    TSTree **tmp = tree_check(L, 2);\n    old_tree = tmp ? *tmp : NULL;\n  }\n\n  TSTree *new_tree = NULL;\n  size_t len;\n  const char *str;\n  long bufnr;\n  buf_T *buf;\n  TSInput input;\n\n  // This switch is necessary because of the behavior of lua_isstring, that\n  // consider numbers as strings...\n  switch (lua_type(L, 3)) {\n    case LUA_TSTRING:\n      str = lua_tolstring(L, 3, &len);\n      new_tree = ts_parser_parse_string(*p, old_tree, str, len);\n      break;\n\n    case LUA_TNUMBER:\n      bufnr = lua_tointeger(L, 3);\n      buf = handle_get_buffer(bufnr);\n\n      if (!buf) {\n        return luaL_error(L, \"invalid buffer handle: %d\", bufnr);\n      }\n\n      input = (TSInput){ (void *)buf, input_cb, TSInputEncodingUTF8 };\n      new_tree = ts_parser_parse(*p, old_tree, input);\n\n      break;\n\n    default:\n      return luaL_error(L, \"invalid argument to parser:parse()\");\n  }\n\n  // Sometimes parsing fails (timeout, or wrong parser ABI)\n  // In those case, just return an error.\n  if (!new_tree) {\n    return luaL_error(L, \"An error occured when parsing.\");\n  }\n\n  // The new tree will be pushed to the stack, without copy, owwership is now to\n  // the lua GC.\n  // Old tree is still owned by the lua GC.\n  uint32_t n_ranges = 0;\n  TSRange *changed = old_tree ?  ts_tree_get_changed_ranges(\n      old_tree, new_tree, &n_ranges) : NULL;\n\n  push_tree(L, new_tree, false);  // [tree]\n\n  push_ranges(L, changed, n_ranges);  // [tree, ranges]\n\n  xfree(changed);\n  return 2;\n}\n\nstatic int tree_copy(lua_State *L)\n{\n  TSTree **tree = tree_check(L, 1);\n  if (!(*tree)) {\n    return 0;\n  }\n\n  push_tree(L, *tree, true);  // [tree]\n\n  return 1;\n}\n\nstatic int tree_edit(lua_State *L)\n{\n  if (lua_gettop(L) < 10) {\n    lua_pushstring(L, \"not enough args to tree:edit()\");\n    return lua_error(L);\n  }\n\n  TSTree **tree = tree_check(L, 1);\n  if (!(*tree)) {\n    return 0;\n  }\n\n  long start_byte = lua_tointeger(L, 2);\n  long old_end_byte = lua_tointeger(L, 3);\n  long new_end_byte = lua_tointeger(L, 4);\n  TSPoint start_point = { lua_tointeger(L, 5), lua_tointeger(L, 6) };\n  TSPoint old_end_point = { lua_tointeger(L, 7), lua_tointeger(L, 8) };\n  TSPoint new_end_point = { lua_tointeger(L, 9), lua_tointeger(L, 10) };\n\n  TSInputEdit edit = { start_byte, old_end_byte, new_end_byte,\n                       start_point, old_end_point, new_end_point };\n\n  ts_tree_edit(*tree, &edit);\n\n  return 0;\n}\n\n// Use the top of the stack (without popping it) to create a TSRange, it can be\n// either a lua table or a TSNode\nstatic void range_from_lua(lua_State *L, TSRange *range)\n{\n  TSNode node;\n\n  if (lua_istable(L, -1)) {\n    // should be a table of 6 elements\n    if (lua_objlen(L, -1) != 6) {\n      goto error;\n    }\n\n    uint32_t start_row, start_col, start_byte, end_row, end_col, end_byte;\n    lua_rawgeti(L, -1, 1);  // [ range, start_row]\n    start_row = luaL_checkinteger(L, -1);\n    lua_pop(L, 1);\n\n    lua_rawgeti(L, -1, 2);  // [ range, start_col]\n    start_col = luaL_checkinteger(L, -1);\n    lua_pop(L, 1);\n\n    lua_rawgeti(L, -1, 3);  // [ range, start_byte]\n    start_byte = luaL_checkinteger(L, -1);\n    lua_pop(L, 1);\n\n    lua_rawgeti(L, -1, 4);  // [ range, end_row]\n    end_row = luaL_checkinteger(L, -1);\n    lua_pop(L, 1);\n\n    lua_rawgeti(L, -1, 5);  // [ range, end_col]\n    end_col = luaL_checkinteger(L, -1);\n    lua_pop(L, 1);\n\n    lua_rawgeti(L, -1, 6);  // [ range, end_byte]\n    end_byte = luaL_checkinteger(L, -1);\n    lua_pop(L, 1);  // [ range ]\n\n    *range = (TSRange) {\n      .start_point = (TSPoint) {\n        .row = start_row,\n        .column = start_col\n      },\n      .end_point = (TSPoint) {\n        .row = end_row,\n        .column = end_col\n      },\n      .start_byte = start_byte,\n      .end_byte = end_byte,\n    };\n  } else if (node_check(L, -1, &node)) {\n    *range = (TSRange) {\n      .start_point = ts_node_start_point(node),\n      .end_point = ts_node_end_point(node),\n      .start_byte = ts_node_start_byte(node),\n      .end_byte = ts_node_end_byte(node)\n    };\n  } else {\n    goto error;\n  }\n  return;\nerror:\n  luaL_error(\n      L,\n      \"Ranges can only be made from 6 element long tables or nodes.\");\n}\n\nstatic int parser_set_ranges(lua_State *L)\n{\n  if (lua_gettop(L) < 2) {\n    return luaL_error(\n        L,\n        \"not enough args to parser:set_included_ranges()\");\n  }\n\n  TSParser **p = parser_check(L, 1);\n  if (!p) {\n    return 0;\n  }\n\n  if (!lua_istable(L, 2)) {\n    return luaL_error(\n        L,\n        \"argument for parser:set_included_ranges() should be a table.\");\n  }\n\n  size_t tbl_len = lua_objlen(L, 2);\n  TSRange *ranges = xmalloc(sizeof(TSRange) * tbl_len);\n\n\n  // [ parser, ranges ]\n  for (size_t index = 0; index < tbl_len; index++) {\n    lua_rawgeti(L, 2, index + 1);  // [ parser, ranges, range ]\n    range_from_lua(L, ranges + index);\n    lua_pop(L, 1);\n  }\n\n  // This memcpies ranges, thus we can free it afterwards\n  ts_parser_set_included_ranges(*p, ranges, tbl_len);\n  xfree(ranges);\n\n  return 0;\n}\n\nstatic int parser_get_ranges(lua_State *L)\n{\n  TSParser **p = parser_check(L, 1);\n  if (!p) {\n    return 0;\n  }\n\n  unsigned int len;\n  const TSRange *ranges = ts_parser_included_ranges(*p, &len);\n\n  push_ranges(L, ranges, len);\n  return 1;\n}\n\n\n// Tree methods\n\n/// push tree interface on lua stack.\n///\n/// This makes a copy of the tree, so ownership of the argument is unaffected.\nvoid push_tree(lua_State *L, TSTree *tree, bool do_copy)\n{\n  if (tree == NULL) {\n    lua_pushnil(L);\n    return;\n  }\n  TSTree **ud = lua_newuserdata(L, sizeof(TSTree *));  // [udata]\n\n  if (do_copy) {\n    *ud = ts_tree_copy(tree);\n  } else {\n    *ud = tree;\n  }\n\n  lua_getfield(L, LUA_REGISTRYINDEX, TS_META_TREE);  // [udata, meta]\n  lua_setmetatable(L, -2);  // [udata]\n\n  // table used for node wrappers to keep a reference to tree wrapper\n  // NB: in lua 5.3 the uservalue for the node could just be the tree, but\n  // in lua 5.1 the uservalue (fenv) must be a table.\n  lua_createtable(L, 1, 0);  // [udata, reftable]\n  lua_pushvalue(L, -2);  // [udata, reftable, udata]\n  lua_rawseti(L, -2, 1);  // [udata, reftable]\n  lua_setfenv(L, -2);  // [udata]\n}\n\nstatic TSTree **tree_check(lua_State *L, uint16_t index)\n{\n  TSTree **ud = luaL_checkudata(L, index, TS_META_TREE);\n  return ud;\n}\n\nstatic int tree_gc(lua_State *L)\n{\n  TSTree **tree = tree_check(L, 1);\n  if (!tree) {\n    return 0;\n  }\n\n  ts_tree_delete(*tree);\n  return 0;\n}\n\nstatic int tree_tostring(lua_State *L)\n{\n  lua_pushstring(L, \"<tree>\");\n  return 1;\n}\n\nstatic int tree_root(lua_State *L)\n{\n  TSTree **tree = tree_check(L, 1);\n  if (!tree) {\n    return 0;\n  }\n  TSNode root = ts_tree_root_node(*tree);\n  push_node(L, root, 1);\n  return 1;\n}\n\n// Node methods\n\n/// push node interface on lua stack\n///\n/// top of stack must either be the tree this node belongs to or another node\n/// of the same tree! This value is not popped. Can only be called inside a\n/// cfunction with the tslua environment.\nstatic void push_node(lua_State *L, TSNode node, int uindex)\n{\n  assert(uindex > 0 || uindex < -LUA_MINSTACK);\n  if (ts_node_is_null(node)) {\n    lua_pushnil(L);  // [nil]\n    return;\n  }\n  TSNode *ud = lua_newuserdata(L, sizeof(TSNode));  // [udata]\n  *ud = node;\n  lua_getfield(L, LUA_REGISTRYINDEX, TS_META_NODE);  // [udata, meta]\n  lua_setmetatable(L, -2);  // [udata]\n  lua_getfenv(L, uindex);  // [udata, reftable]\n  lua_setfenv(L, -2);  // [udata]\n}\n\nstatic bool node_check(lua_State *L, int index, TSNode *res)\n{\n  TSNode *ud = luaL_checkudata(L, index, TS_META_NODE);\n  if (ud) {\n    *res = *ud;\n    return true;\n  }\n  return false;\n}\n\n\nstatic int node_tostring(lua_State *L)\n{\n  TSNode node;\n  if (!node_check(L, 1, &node)) {\n    return 0;\n  }\n  lua_pushstring(L, \"<node \");\n  lua_pushstring(L, ts_node_type(node));\n  lua_pushstring(L, \">\");\n  lua_concat(L, 3);\n  return 1;\n}\n\nstatic int node_eq(lua_State *L)\n{\n  TSNode node;\n  if (!node_check(L, 1, &node)) {\n    return 0;\n  }\n\n  TSNode node2;\n  if (!node_check(L, 2, &node2)) {\n    return 0;\n  }\n\n  lua_pushboolean(L, ts_node_eq(node, node2));\n  return 1;\n}\n\nstatic int node_id(lua_State *L)\n{\n  TSNode node;\n  if (!node_check(L, 1, &node)) {\n    return 0;\n  }\n\n  lua_pushlstring(L, (const char *)&node.id, sizeof node.id);\n  return 1;\n}\n\nstatic int node_range(lua_State *L)\n{\n  TSNode node;\n  if (!node_check(L, 1, &node)) {\n    return 0;\n  }\n  TSPoint start = ts_node_start_point(node);\n  TSPoint end = ts_node_end_point(node);\n  lua_pushnumber(L, start.row);\n  lua_pushnumber(L, start.column);\n  lua_pushnumber(L, end.row);\n  lua_pushnumber(L, end.column);\n  return 4;\n}\n\nstatic int node_start(lua_State *L)\n{\n  TSNode node;\n  if (!node_check(L, 1, &node)) {\n    return 0;\n  }\n  TSPoint start = ts_node_start_point(node);\n  uint32_t start_byte = ts_node_start_byte(node);\n  lua_pushnumber(L, start.row);\n  lua_pushnumber(L, start.column);\n  lua_pushnumber(L, start_byte);\n  return 3;\n}\n\nstatic int node_end(lua_State *L)\n{\n  TSNode node;\n  if (!node_check(L, 1, &node)) {\n    return 0;\n  }\n  TSPoint end = ts_node_end_point(node);\n  uint32_t end_byte = ts_node_end_byte(node);\n  lua_pushnumber(L, end.row);\n  lua_pushnumber(L, end.column);\n  lua_pushnumber(L, end_byte);\n  return 3;\n}\n\nstatic int node_child_count(lua_State *L)\n{\n  TSNode node;\n  if (!node_check(L, 1, &node)) {\n    return 0;\n  }\n  uint32_t count = ts_node_child_count(node);\n  lua_pushnumber(L, count);\n  return 1;\n}\n\nstatic int node_named_child_count(lua_State *L)\n{\n  TSNode node;\n  if (!node_check(L, 1, &node)) {\n    return 0;\n  }\n  uint32_t count = ts_node_named_child_count(node);\n  lua_pushnumber(L, count);\n  return 1;\n}\n\nstatic int node_type(lua_State *L)\n{\n  TSNode node;\n  if (!node_check(L, 1, &node)) {\n    return 0;\n  }\n  lua_pushstring(L, ts_node_type(node));\n  return 1;\n}\n\nstatic int node_symbol(lua_State *L)\n{\n  TSNode node;\n  if (!node_check(L, 1, &node)) {\n    return 0;\n  }\n  TSSymbol symbol = ts_node_symbol(node);\n  lua_pushnumber(L, symbol);\n  return 1;\n}\n\nstatic int node_field(lua_State *L)\n{\n  TSNode node;\n  if (!node_check(L, 1, &node)) {\n    return 0;\n  }\n\n  size_t name_len;\n  const char *field_name = luaL_checklstring(L, 2, &name_len);\n\n  TSTreeCursor cursor = ts_tree_cursor_new(node);\n\n  lua_newtable(L);  // [table]\n  unsigned int curr_index = 0;\n\n  if (ts_tree_cursor_goto_first_child(&cursor)) {\n    do {\n      const char *current_field = ts_tree_cursor_current_field_name(&cursor);\n\n      if (current_field != NULL && !STRCMP(field_name, current_field)) {\n        push_node(L, ts_tree_cursor_current_node(&cursor), 1);  // [table, node]\n        lua_rawseti(L, -2, ++curr_index);\n      }\n    } while (ts_tree_cursor_goto_next_sibling(&cursor));\n  }\n\n  ts_tree_cursor_delete(&cursor);\n  return 1;\n}\n\nstatic int node_named(lua_State *L)\n{\n  TSNode node;\n  if (!node_check(L, 1, &node)) {\n    return 0;\n  }\n  lua_pushboolean(L, ts_node_is_named(node));\n  return 1;\n}\n\nstatic int node_sexpr(lua_State *L)\n{\n  TSNode node;\n  if (!node_check(L, 1, &node)) {\n    return 0;\n  }\n  char *allocated = ts_node_string(node);\n  lua_pushstring(L, allocated);\n  xfree(allocated);\n  return 1;\n}\n\nstatic int node_missing(lua_State *L)\n{\n  TSNode node;\n  if (!node_check(L, 1, &node)) {\n    return 0;\n  }\n  lua_pushboolean(L, ts_node_is_missing(node));\n  return 1;\n}\n\nstatic int node_has_error(lua_State *L)\n{\n  TSNode node;\n  if (!node_check(L, 1, &node)) {\n    return 0;\n  }\n  lua_pushboolean(L, ts_node_has_error(node));\n  return 1;\n}\n\nstatic int node_child(lua_State *L)\n{\n  TSNode node;\n  if (!node_check(L, 1, &node)) {\n    return 0;\n  }\n  long num = lua_tointeger(L, 2);\n  TSNode child = ts_node_child(node, (uint32_t)num);\n\n  push_node(L, child, 1);\n  return 1;\n}\n\nstatic int node_named_child(lua_State *L)\n{\n  TSNode node;\n  if (!node_check(L, 1, &node)) {\n    return 0;\n  }\n  long num = lua_tointeger(L, 2);\n  TSNode child = ts_node_named_child(node, (uint32_t)num);\n\n  push_node(L, child, 1);\n  return 1;\n}\n\nstatic int node_descendant_for_range(lua_State *L)\n{\n  TSNode node;\n  if (!node_check(L, 1, &node)) {\n    return 0;\n  }\n  TSPoint start = { (uint32_t)lua_tointeger(L, 2),\n                   (uint32_t)lua_tointeger(L, 3) };\n  TSPoint end = { (uint32_t)lua_tointeger(L, 4),\n                 (uint32_t)lua_tointeger(L, 5) };\n  TSNode child = ts_node_descendant_for_point_range(node, start, end);\n\n  push_node(L, child, 1);\n  return 1;\n}\n\nstatic int node_named_descendant_for_range(lua_State *L)\n{\n  TSNode node;\n  if (!node_check(L, 1, &node)) {\n    return 0;\n  }\n  TSPoint start = { (uint32_t)lua_tointeger(L, 2),\n                   (uint32_t)lua_tointeger(L, 3) };\n  TSPoint end = { (uint32_t)lua_tointeger(L, 4),\n                 (uint32_t)lua_tointeger(L, 5) };\n  TSNode child = ts_node_named_descendant_for_point_range(node, start, end);\n\n  push_node(L, child, 1);\n  return 1;\n}\n\nstatic int node_next_child(lua_State *L)\n{\n  TSTreeCursor *ud = luaL_checkudata(\n      L, lua_upvalueindex(1), TS_META_TREECURSOR);\n  if (!ud) {\n    return 0;\n  }\n\n  TSNode source;\n  if (!node_check(L, lua_upvalueindex(2), &source)) {\n    return 0;\n  }\n\n  // First call should return first child\n  if (ts_node_eq(source, ts_tree_cursor_current_node(ud))) {\n    if (ts_tree_cursor_goto_first_child(ud)) {\n      goto push;\n    } else {\n      goto end;\n    }\n  }\n\n  if (ts_tree_cursor_goto_next_sibling(ud)) {\npush:\n      push_node(\n          L,\n          ts_tree_cursor_current_node(ud),\n          lua_upvalueindex(2));  // [node]\n\n      const char * field = ts_tree_cursor_current_field_name(ud);\n\n      if (field != NULL) {\n        lua_pushstring(L, ts_tree_cursor_current_field_name(ud));\n      } else {\n        lua_pushnil(L);\n      }  // [node, field_name_or_nil]\n      return 2;\n  }\n\nend:\n  return 0;\n}\n\nstatic int node_iter_children(lua_State *L)\n{\n  TSNode source;\n  if (!node_check(L, 1, &source)) {\n    return 0;\n  }\n\n  TSTreeCursor *ud = lua_newuserdata(L, sizeof(TSTreeCursor));  // [udata]\n  *ud = ts_tree_cursor_new(source);\n\n  lua_getfield(L, LUA_REGISTRYINDEX, TS_META_TREECURSOR);  // [udata, mt]\n  lua_setmetatable(L, -2);  // [udata]\n  lua_pushvalue(L, 1);  // [udata, source_node]\n  lua_pushcclosure(L, node_next_child, 2);\n\n  return 1;\n}\n\nstatic int treecursor_gc(lua_State *L)\n{\n  TSTreeCursor *ud = luaL_checkudata(L, 1, TS_META_TREECURSOR);\n  ts_tree_cursor_delete(ud);\n  return 0;\n}\n\nstatic int node_parent(lua_State *L)\n{\n  TSNode node;\n  if (!node_check(L, 1, &node)) {\n    return 0;\n  }\n  TSNode parent = ts_node_parent(node);\n  push_node(L, parent, 1);\n  return 1;\n}\n\n/// assumes the match table being on top of the stack\nstatic void set_match(lua_State *L, TSQueryMatch *match, int nodeidx)\n{\n  for (int i = 0; i < match->capture_count; i++) {\n    push_node(L, match->captures[i].node, nodeidx);\n    lua_rawseti(L, -2, match->captures[i].index+1);\n  }\n}\n\nstatic int query_next_match(lua_State *L)\n{\n  TSLua_cursor *ud = lua_touserdata(L, lua_upvalueindex(1));\n  TSQueryCursor *cursor = ud->cursor;\n\n  TSQuery *query = query_check(L, lua_upvalueindex(3));\n  TSQueryMatch match;\n  if (ts_query_cursor_next_match(cursor, &match)) {\n    lua_pushinteger(L, match.pattern_index+1);  // [index]\n    lua_createtable(L, ts_query_capture_count(query), 2);  // [index, match]\n    set_match(L, &match, lua_upvalueindex(2));\n    return 2;\n  }\n  return 0;\n}\n\n\nstatic int query_next_capture(lua_State *L)\n{\n  TSLua_cursor *ud = lua_touserdata(L, lua_upvalueindex(1));\n  TSQueryCursor *cursor = ud->cursor;\n\n  TSQuery *query = query_check(L, lua_upvalueindex(3));\n\n  if (ud->predicated_match > -1) {\n    lua_getfield(L, lua_upvalueindex(4), \"active\");\n    bool active = lua_toboolean(L, -1);\n    lua_pop(L, 1);\n    if (!active) {\n      ts_query_cursor_remove_match(cursor, ud->predicated_match);\n    }\n    ud->predicated_match = -1;\n  }\n\n  TSQueryMatch match;\n  uint32_t capture_index;\n  if (ts_query_cursor_next_capture(cursor, &match, &capture_index)) {\n    TSQueryCapture capture = match.captures[capture_index];\n\n    lua_pushinteger(L, capture.index+1);  // [index]\n    push_node(L, capture.node, lua_upvalueindex(2));  // [index, node]\n\n    uint32_t n_pred;\n    ts_query_predicates_for_pattern(query, match.pattern_index, &n_pred);\n    if (n_pred > 0 && capture_index == 0) {\n      lua_pushvalue(L, lua_upvalueindex(4));  // [index, node, match]\n      set_match(L, &match, lua_upvalueindex(2));\n      lua_pushinteger(L, match.pattern_index+1);\n      lua_setfield(L, -2, \"pattern\");\n\n      if (match.capture_count > 1) {\n        ud->predicated_match = match.id;\n        lua_pushboolean(L, false);\n        lua_setfield(L, -2, \"active\");\n      }\n      return 3;\n    }\n    return 2;\n  }\n  return 0;\n}\n\nstatic int node_rawquery(lua_State *L)\n{\n  TSNode node;\n  if (!node_check(L, 1, &node)) {\n    return 0;\n  }\n  TSQuery *query = query_check(L, 2);\n  // TODO(bfredl): these are expensive allegedly,\n  // use a reuse list later on?\n  TSQueryCursor *cursor = ts_query_cursor_new();\n  ts_query_cursor_exec(cursor, query, node);\n\n  bool captures = lua_toboolean(L, 3);\n\n  if (lua_gettop(L) >= 4) {\n    int start = luaL_checkinteger(L, 4);\n    int end = lua_gettop(L) >= 5 ? luaL_checkinteger(L, 5) : MAXLNUM;\n    ts_query_cursor_set_point_range(cursor,\n                                    (TSPoint){ start, 0 }, (TSPoint){ end, 0 });\n  }\n\n  TSLua_cursor *ud = lua_newuserdata(L, sizeof(*ud));  // [udata]\n  ud->cursor = cursor;\n  ud->predicated_match = -1;\n\n  lua_getfield(L, LUA_REGISTRYINDEX, TS_META_QUERYCURSOR);\n  lua_setmetatable(L, -2);  // [udata]\n  lua_pushvalue(L, 1);  // [udata, node]\n\n  // include query separately, as to keep a ref to it for gc\n  lua_pushvalue(L, 2);  // [udata, node, query]\n\n  if (captures) {\n    // placeholder for match state\n    lua_createtable(L, ts_query_capture_count(query), 2);  // [u, n, q, match]\n    lua_pushcclosure(L, query_next_capture, 4);  // [closure]\n  } else {\n    lua_pushcclosure(L, query_next_match, 3);  // [closure]\n  }\n\n  return 1;\n}\n\nstatic int querycursor_gc(lua_State *L)\n{\n  TSLua_cursor *ud = luaL_checkudata(L, 1, TS_META_QUERYCURSOR);\n  ts_query_cursor_delete(ud->cursor);\n  return 0;\n}\n\n// Query methods\n\nint ts_lua_parse_query(lua_State *L)\n{\n  if (lua_gettop(L) < 2 || !lua_isstring(L, 1) || !lua_isstring(L, 2)) {\n    return luaL_error(L, \"string expected\");\n  }\n\n  const char *lang_name = lua_tostring(L, 1);\n  TSLanguage *lang = pmap_get(cstr_t)(langs, lang_name);\n  if (!lang) {\n    return luaL_error(L, \"no such language: %s\", lang_name);\n  }\n\n  size_t len;\n  const char *src = lua_tolstring(L, 2, &len);\n\n  uint32_t error_offset;\n  TSQueryError error_type;\n  TSQuery *query = ts_query_new(lang, src, len, &error_offset, &error_type);\n\n  if (!query) {\n    return luaL_error(L, \"query: %s at position %d\",\n                      query_err_string(error_type), (int)error_offset);\n  }\n\n  TSQuery **ud = lua_newuserdata(L, sizeof(TSQuery *));  // [udata]\n  *ud = query;\n  lua_getfield(L, LUA_REGISTRYINDEX, TS_META_QUERY);  // [udata, meta]\n  lua_setmetatable(L, -2);  // [udata]\n  return 1;\n}\n\n\nstatic const char *query_err_string(TSQueryError err) {\n  switch (err) {\n    case TSQueryErrorSyntax: return \"invalid syntax\";\n    case TSQueryErrorNodeType: return \"invalid node type\";\n    case TSQueryErrorField: return \"invalid field\";\n    case TSQueryErrorCapture: return \"invalid capture\";\n    default: return \"error\";\n  }\n}\n\nstatic TSQuery *query_check(lua_State *L, int index)\n{\n  TSQuery **ud = luaL_checkudata(L, index, TS_META_QUERY);\n  return *ud;\n}\n\nstatic int query_gc(lua_State *L)\n{\n  TSQuery *query = query_check(L, 1);\n  if (!query) {\n    return 0;\n  }\n\n  ts_query_delete(query);\n  return 0;\n}\n\nstatic int query_tostring(lua_State *L)\n{\n  lua_pushstring(L, \"<query>\");\n  return 1;\n}\n\nstatic int query_inspect(lua_State *L)\n{\n  TSQuery *query = query_check(L, 1);\n  if (!query) {\n    return 0;\n  }\n\n  uint32_t n_pat = ts_query_pattern_count(query);\n  lua_createtable(L, 0, 2);  // [retval]\n  lua_createtable(L, n_pat, 1);  // [retval, patterns]\n  for (size_t i = 0; i < n_pat; i++) {\n    uint32_t len;\n    const TSQueryPredicateStep *step = ts_query_predicates_for_pattern(query,\n                                                                       i, &len);\n    if (len == 0) {\n      continue;\n    }\n    lua_createtable(L, len/4, 1);  // [retval, patterns, pat]\n    lua_createtable(L, 3, 0);  // [retval, patterns, pat, pred]\n    int nextpred = 1;\n    int nextitem = 1;\n    for (size_t k = 0; k < len; k++) {\n      if (step[k].type == TSQueryPredicateStepTypeDone) {\n        lua_rawseti(L, -2, nextpred++);  // [retval, patterns, pat]\n        lua_createtable(L, 3, 0);  // [retval, patterns, pat, pred]\n        nextitem = 1;\n        continue;\n      }\n\n      if (step[k].type == TSQueryPredicateStepTypeString) {\n        uint32_t strlen;\n        const char *str = ts_query_string_value_for_id(query, step[k].value_id,\n                                                       &strlen);\n        lua_pushlstring(L, str, strlen);  // [retval, patterns, pat, pred, item]\n      } else if (step[k].type == TSQueryPredicateStepTypeCapture) {\n        lua_pushnumber(L, step[k].value_id+1);  // [..., pat, pred, item]\n      } else {\n        abort();\n      }\n      lua_rawseti(L, -2, nextitem++);  // [retval, patterns, pat, pred]\n    }\n    // last predicate should have ended with TypeDone\n    lua_pop(L, 1);  // [retval, patters, pat]\n    lua_rawseti(L, -2, i+1);  // [retval, patterns]\n  }\n  lua_setfield(L, -2, \"patterns\");  // [retval]\n\n  uint32_t n_captures = ts_query_capture_count(query);\n  lua_createtable(L, n_captures, 0);  // [retval, captures]\n  for (size_t i = 0; i < n_captures; i++) {\n    uint32_t strlen;\n    const char *str = ts_query_capture_name_for_id(query, i, &strlen);\n    lua_pushlstring(L, str, strlen);  // [retval, captures, capture]\n    lua_rawseti(L, -2, i+1);\n  }\n  lua_setfield(L, -2, \"captures\");  // [retval]\n\n  return 1;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/src/nvim/os/pty_conpty_win.c": "// This is an open source non-commercial project. Dear PVS-Studio, please check\n// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n\n#include <uv.h>\n\n#include \"nvim/vim.h\"\n#include \"nvim/os/os.h\"\n#include \"nvim/os/pty_conpty_win.h\"\n\n#ifndef EXTENDED_STARTUPINFO_PRESENT\n# define EXTENDED_STARTUPINFO_PRESENT 0x00080000\n#endif\n#ifndef PROC_THREAD_ATTRIBUTE_PSEUDOCONSOLE\n# define PROC_THREAD_ATTRIBUTE_PSEUDOCONSOLE 0x00020016\n#endif\n\nHRESULT (WINAPI *pCreatePseudoConsole)(COORD, HANDLE, HANDLE, DWORD, HPCON *);\nHRESULT (WINAPI *pResizePseudoConsole)(HPCON, COORD);\nvoid (WINAPI *pClosePseudoConsole)(HPCON);\n\nbool os_has_conpty_working(void)\n{\n  static TriState has_conpty = kNone;\n  if (has_conpty == kNone) {\n    has_conpty = os_dyn_conpty_init();\n  }\n\n  return has_conpty == kTrue;\n}\n\nTriState os_dyn_conpty_init(void)\n{\n  uv_lib_t kernel;\n  if (uv_dlopen(\"kernel32.dll\", &kernel)) {\n    uv_dlclose(&kernel);\n    return kFalse;\n  }\n  static struct {\n    char *name;\n    FARPROC *ptr;\n  } conpty_entry[] = {\n    { \"CreatePseudoConsole\", (FARPROC *)&pCreatePseudoConsole },\n    { \"ResizePseudoConsole\", (FARPROC *)&pResizePseudoConsole },\n    { \"ClosePseudoConsole\", (FARPROC *)&pClosePseudoConsole },\n    { NULL, NULL }\n  };\n  for (int i = 0;\n       conpty_entry[i].name != NULL && conpty_entry[i].ptr != NULL; i++) {\n    if (uv_dlsym(&kernel, conpty_entry[i].name, (void **)conpty_entry[i].ptr)) {\n      uv_dlclose(&kernel);\n      return kFalse;\n    }\n  }\n  return kTrue;\n}\n\nconpty_t *os_conpty_init(char **in_name, char **out_name,\n                         uint16_t width, uint16_t height)\n{\n  static int count = 0;\n  conpty_t *conpty_object = xcalloc(1, sizeof(*conpty_object));\n  const char *emsg = NULL;\n  HANDLE in_read = INVALID_HANDLE_VALUE;\n  HANDLE out_write = INVALID_HANDLE_VALUE;\n  char buf[MAXPATHL];\n  SECURITY_ATTRIBUTES sa = { 0 };\n  const DWORD mode = PIPE_ACCESS_INBOUND\n    | PIPE_ACCESS_OUTBOUND | FILE_FLAG_FIRST_PIPE_INSTANCE;\n\n  sa.nLength = sizeof(sa);\n  snprintf(buf, sizeof(buf), \"\\\\\\\\.\\\\pipe\\\\nvim-term-in-%d-%d\",\n           os_get_pid(), count);\n  *in_name = xstrdup(buf);\n  if ((in_read = CreateNamedPipeA(\n      *in_name,\n      mode,\n      PIPE_TYPE_BYTE | PIPE_READMODE_BYTE | PIPE_WAIT,\n      1,\n      0,\n      0,\n      30000,\n      &sa)) == INVALID_HANDLE_VALUE) {\n    emsg = \"create input pipe failed\";\n    goto failed;\n  }\n  snprintf(buf, sizeof(buf), \"\\\\\\\\.\\\\pipe\\\\nvim-term-out-%d-%d\",\n           os_get_pid(), count);\n  *out_name = xstrdup(buf);\n  if ((out_write = CreateNamedPipeA(\n      *out_name,\n      mode,\n      PIPE_TYPE_BYTE | PIPE_READMODE_BYTE | PIPE_WAIT,\n      1,\n      0,\n      0,\n      30000,\n      &sa)) == INVALID_HANDLE_VALUE) {\n    emsg = \"create output pipe failed\";\n    goto failed;\n  }\n  assert(width <= SHRT_MAX);\n  assert(height <=  SHRT_MAX);\n  COORD size = { (int16_t)width, (int16_t)height };\n  HRESULT hr;\n  hr = pCreatePseudoConsole(size, in_read, out_write, 0, &conpty_object->pty);\n  if (FAILED(hr)) {\n    emsg = \"create psudo console failed\";\n    goto failed;\n  }\n\n  conpty_object->si_ex.StartupInfo.cb = sizeof(conpty_object->si_ex);\n  size_t bytes_required;\n  InitializeProcThreadAttributeList(NULL, 1, 0,  & bytes_required);\n  conpty_object->si_ex.lpAttributeList =\n    (PPROC_THREAD_ATTRIBUTE_LIST)xmalloc(bytes_required);\n  if (!InitializeProcThreadAttributeList(\n      conpty_object->si_ex.lpAttributeList,\n      1,\n      0,\n      &bytes_required)) {\n    emsg = \"InitializeProcThreadAttributeList failed\";\n    goto failed;\n  }\n  if (!UpdateProcThreadAttribute(\n      conpty_object->si_ex.lpAttributeList,\n      0,\n      PROC_THREAD_ATTRIBUTE_PSEUDOCONSOLE,\n      conpty_object->pty,\n      sizeof(conpty_object->pty),\n      NULL,\n      NULL)) {\n    emsg = \"UpdateProcThreadAttribute failed\";\n    goto failed;\n  }\n  count++;\n  goto finished;\n\nfailed:\n  ELOG(\"os_conpty_init:%s : error code: %d\",\n       emsg, os_translate_sys_error((int)GetLastError()));\n  os_conpty_free(conpty_object);\n  conpty_object = NULL;\nfinished:\n  if (in_read != INVALID_HANDLE_VALUE) {\n    CloseHandle(in_read);\n  }\n  if (out_write != INVALID_HANDLE_VALUE) {\n    CloseHandle(out_write);\n  }\n  return conpty_object;\n}\n\nbool os_conpty_spawn(conpty_t *conpty_object, HANDLE *process_handle,\n                     wchar_t *name, wchar_t *cmd_line, wchar_t *cwd,\n                     wchar_t *env)\n{\n  PROCESS_INFORMATION pi = { 0 };\n  if (!CreateProcessW(\n      name,\n      cmd_line,\n      NULL,\n      NULL,\n      false,\n      EXTENDED_STARTUPINFO_PRESENT | CREATE_UNICODE_ENVIRONMENT,\n      env,\n      cwd,\n      &conpty_object->si_ex.StartupInfo,\n      &pi)) {\n    return false;\n  }\n  *process_handle = pi.hProcess;\n  return true;\n}\n\nvoid os_conpty_set_size(conpty_t *conpty_object,\n                        uint16_t width, uint16_t height)\n{\n    assert(width <= SHRT_MAX);\n    assert(height <= SHRT_MAX);\n    COORD size = { (int16_t)width, (int16_t)height };\n    if (pResizePseudoConsole(conpty_object->pty, size) != S_OK) {\n      ELOG(\"ResizePseudoConsoel failed: error code: %d\",\n           os_translate_sys_error((int)GetLastError()));\n    }\n}\n\nvoid os_conpty_free(conpty_t *conpty_object)\n{\n  if (conpty_object != NULL) {\n    if (conpty_object->si_ex.lpAttributeList != NULL) {\n      DeleteProcThreadAttributeList(conpty_object->si_ex.lpAttributeList);\n      xfree(conpty_object->si_ex.lpAttributeList);\n    }\n    if (conpty_object->pty != NULL) {\n      pClosePseudoConsole(conpty_object->pty);\n    }\n  }\n  xfree(conpty_object);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/src/nvim/os/dl.c": "// This is an open source non-commercial project. Dear PVS-Studio, please check\n// it. PVS-Studio Static Code Analyzer for C, C++ and C#: http://www.viva64.com\n\n/// Functions for using external native libraries\n\n#include <stdbool.h>\n#include <stdint.h>\n#include <uv.h>\n\n#include \"nvim/os/dl.h\"\n#include \"nvim/os/os.h\"\n#include \"nvim/memory.h\"\n#include \"nvim/message.h\"\n\n/// possible function prototypes that can be called by os_libcall()\n/// int -> int\n/// int -> string\n/// string -> string\n/// string -> int\ntypedef void (*gen_fn)(void);\ntypedef const char *(*str_str_fn)(const char *str);\ntypedef int (*str_int_fn)(const char *str);\ntypedef const char *(*int_str_fn)(int i);\ntypedef int (*int_int_fn)(int i);\n\n/// os_libcall - call a function in a dynamic loadable library\n///\n/// an example of calling a function that takes a string and returns an int:\n///\n///   int int_out = 0;\n///   os_libcall(\"mylib.so\", \"somefn\", \"string-argument\", 0, NULL, &int_out);\n///\n/// @param libname the name of the library to load (e.g.: libsomething.so)\n/// @param funcname the name of the library function (e.g.: myfunc)\n/// @param argv the input string, NULL when using `argi`\n/// @param argi the input integer, not used when using `argv` != NULL\n/// @param[out] str_out an allocated output string, caller must free if\n///             not NULL. NULL when using `int_out`.\n/// @param[out] int_out the output integer param\n/// @return true on success, false on failure\nbool os_libcall(const char *libname,\n                const char *funcname,\n                const char *argv,\n                int argi,\n                char **str_out,\n                int *int_out)\n{\n  if (!libname || !funcname) {\n    return false;\n  }\n\n  uv_lib_t lib;\n\n  // open the dynamic loadable library\n  if (uv_dlopen(libname, &lib)) {\n      EMSG2(_(\"dlerror = \\\"%s\\\"\"), uv_dlerror(&lib));\n      uv_dlclose(&lib);\n      return false;\n  }\n\n  // find and load the requested function in the library\n  gen_fn fn;\n  if (uv_dlsym(&lib, funcname, (void **) &fn)) {\n      EMSG2(_(\"dlerror = \\\"%s\\\"\"), uv_dlerror(&lib));\n      uv_dlclose(&lib);\n      return false;\n  }\n\n  // call the library and save the result\n  // TODO(aktau): catch signals and use jmp (if available) to handle\n  // exceptions. jmp's on Unix seem to interact trickily with signals as\n  // well. So for now we only support those libraries that are well-behaved.\n  if (str_out) {\n    str_str_fn sfn = (str_str_fn) fn;\n    int_str_fn ifn = (int_str_fn) fn;\n\n    const char *res = argv ? sfn(argv) : ifn(argi);\n\n    // assume that ptr values of NULL, 1 or -1 are illegal\n    *str_out = (res && (intptr_t) res != 1 && (intptr_t) res != -1)\n        ? xstrdup(res) : NULL;\n  } else {\n    str_int_fn sfn = (str_int_fn) fn;\n    int_int_fn ifn = (int_int_fn) fn;\n    *int_out = argv ? sfn(argv) : ifn(argi);\n  }\n\n  // free the library\n  uv_dlclose(&lib);\n\n  return true;\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/src/nvim/po/cs.po",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/src/nvim/po/ja.euc-jp.po",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/src/nvim/po/sk.po",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/src/nvim/po/cs.cp1250.po",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/src/nvim/po/ca.po",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/src/nvim/po/sk.cp1250.po",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/src/nvim/po/ga.po",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/src/nvim/po/sv.po",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/src/nvim/po/nb.po",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/src/nvim/po/it.po",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/src/nvim/po/no.po",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/src/nvim/po/pt_BR.po",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/src/nvim/po/af.po",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/src/nvim/po/fr.po",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/src/nvim/po/de.po",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/src/nvim/testdir/test_increment_dbcs.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/src/nvim/testdir/test_spell.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/src/nvim/testdir/test_regexp_utf8.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/src/nvim/testdir/test42.ok",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/src/nvim/testdir/test_regex_char_classes.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/src/nvim/testdir/test42.in",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/.git/objects/pack/pack-a92ee5722b43c8856161cf3262594d199a5391d7.pack",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/.git/objects/pack/pack-a92ee5722b43c8856161cf3262594d199a5391d7.idx",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/runtime/nvim.png",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/runtime/syntax/moo.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/runtime/syntax/tilde.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/runtime/syntax/pascal.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/runtime/syntax/rtf.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/runtime/syntax/groff.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/runtime/syntax/lout.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/runtime/syntax/forth.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/runtime/syntax/nroff.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/runtime/syntax/css.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/runtime/syntax/rpl.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/runtime/syntax/fortran.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/runtime/syntax/initng.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/runtime/syntax/iss.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/runtime/syntax/mmix.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/runtime/syntax/elf.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/runtime/syntax/robots.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/runtime/ftplugin/ocaml.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/runtime/ftplugin/rpl.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/runtime/ftplugin/erlang.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/runtime/keymap/hebrewp_utf-8.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/runtime/keymap/greek_cp737.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/runtime/keymap/canfr-win.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/runtime/keymap/serbian_cp1251.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/runtime/keymap/slovak_iso-8859-2.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/runtime/keymap/greek_iso-8859-7.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/runtime/keymap/hebrew_iso-8859-8.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/runtime/keymap/serbian_iso-8859-5.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/runtime/keymap/accents.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/runtime/keymap/serbian_cp1250.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/runtime/keymap/esperanto_utf-8.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/runtime/keymap/croatian_iso-8859-2.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/runtime/keymap/serbian_iso-8859-2.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/runtime/keymap/greek_utf-8.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/runtime/keymap/croatian_cp1250.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/runtime/keymap/greek_cp1253.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/runtime/keymap/hebrewp_cp1255.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/runtime/keymap/slovak_cp1250.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/runtime/indent/tilde.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/runtime/indent/rpl.vim",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/runtime/doc/makehtml.awk",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/runtime/spell/en.utf-8.spl",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/test/functional/legacy/093_mksession_cursor_cols_latin1_spec.lua",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/test/functional/legacy/044_099_regexp_multibyte_magic_spec.lua",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/test/functional/fixtures/api_level_2.mpack",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/test/functional/fixtures/api_level_0.mpack",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/test/functional/fixtures/shell_data.txt",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/test/functional/fixtures/api_level_6.mpack",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/test/functional/fixtures/api_level_3.mpack",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/test/functional/fixtures/api_level_4.mpack",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/test/functional/fixtures/api_level_1.mpack",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/test/functional/fixtures/api_level_5.mpack",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/contrib/doxygen/logo-devdoc.png",
        "/tmp/vanessa/spack-stage/spack-stage-neovim-master-sd6k6lftbb4uqfhfmd277a7agfmtntsi/spack-src/ci/snap/travis_snapcraft.cfg"
    ],
    "total_files": 2663
}