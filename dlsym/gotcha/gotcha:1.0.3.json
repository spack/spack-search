{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-gotcha-1.0.3-64ohcxquoykyaq52pavphymncemuknvf/spack-src/src/gotcha_dl.h": "#ifndef GOTCHA_DL_H\n#define GOTCHA_DL_H\n\n#include \"hash.h\"\n#include \"tool.h\"\n\nvoid handle_libdl();\nextern void update_all_library_gots(hash_table_t *bindings);\nextern int prepare_symbol(struct internal_binding_t *binding);\n\nextern gotcha_wrappee_handle_t orig_dlopen_handle;\nextern gotcha_wrappee_handle_t orig_dlsym_handle;\n\nextern struct gotcha_binding_t dl_binds[];\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-gotcha-1.0.3-64ohcxquoykyaq52pavphymncemuknvf/spack-src/src/gotcha_dl.c": "#define _GNU_SOURCE\n#include \"gotcha_dl.h\"\n#include \"tool.h\"\n#include \"libc_wrappers.h\"\n#include \"elf_ops.h\"\n#include <dlfcn.h>\n\nvoid* _dl_sym(void* handle, const char* name, void* where);\n\ngotcha_wrappee_handle_t orig_dlopen_handle;\ngotcha_wrappee_handle_t orig_dlsym_handle;\n\nstatic int per_binding(hash_key_t key, hash_data_t data, void *opaque KNOWN_UNUSED)\n{\n   int result;\n   struct internal_binding_t *binding = (struct internal_binding_t *) data;\n\n   debug_printf(3, \"Trying to re-bind %s from tool %s after dlopen\\n\",\n                binding->user_binding->name, binding->associated_binding_table->tool->tool_name);\n   \n   while (binding->next_binding) {\n      binding = binding->next_binding;\n      debug_printf(3, \"Selecting new innermost version of binding %s from tool %s.\\n\",\n                   binding->user_binding->name, binding->associated_binding_table->tool->tool_name);\n   }\n   \n   result = prepare_symbol(binding);\n   if (result == -1) {\n      debug_printf(3, \"Still could not prepare binding %s after dlopen\\n\", binding->user_binding->name);\n      return 0;\n   }\n\n   removefrom_hashtable(&notfound_binding_table, key);\n   return 0;\n}\n\nstatic void* dlopen_wrapper(const char* filename, int flags) {\n   typeof(&dlopen_wrapper) orig_dlopen = gotcha_get_wrappee(orig_dlopen_handle);\n   void *handle;\n   debug_printf(1, \"User called dlopen(%s, 0x%x)\\n\", filename, (unsigned int) flags);\n   handle = orig_dlopen(filename,flags);\n\n   debug_printf(2, \"Searching new dlopened libraries for previously-not-found exports\\n\");\n   foreach_hash_entry(&notfound_binding_table, NULL, per_binding);\n\n   debug_printf(2, \"Updating GOT entries for new dlopened libraries\\n\");\n   update_all_library_gots(&function_hash_table);\n  \n   return handle;\n}\n\nstatic void* dlsym_wrapper(void* handle, const char* symbol_name){\n  typeof(&dlsym_wrapper) orig_dlsym = gotcha_get_wrappee(orig_dlsym_handle);\n  struct internal_binding_t *binding;\n  int result;\n  \n  if(handle == RTLD_NEXT){\n    return _dl_sym(RTLD_NEXT, symbol_name ,__builtin_return_address(0));\n  }\n  \n  result = lookup_hashtable(&function_hash_table, (hash_key_t) symbol_name, (hash_data_t *) &binding);\n  if (result == -1)\n     return orig_dlsym(handle, symbol_name);\n  else\n     return binding->user_binding->wrapper_pointer;\n}\n\nstruct gotcha_binding_t dl_binds[] = {\n  {\"dlopen\", dlopen_wrapper, &orig_dlopen_handle},\n  {\"dlsym\", dlsym_wrapper, &orig_dlsym_handle}\n};     \nvoid handle_libdl(){\n  gotcha_wrap(dl_binds, 2, \"gotcha\");\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-gotcha-1.0.3-64ohcxquoykyaq52pavphymncemuknvf/spack-src/test/dlopen/test_dlopen.c": "/*\nThis file is part of GOTCHA.  For copyright information see the COPYRIGHT\nfile in the top level directory, or at\nhttps://github.com/LLNL/gotcha/blob/master/COPYRIGHT\nThis program is free software; you can redistribute it and/or modify it under\nthe terms of the GNU Lesser General Public License (as published by the Free\nSoftware Foundation) version 2.1 dated February 1999.  This program is\ndistributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\nwithout even the IMPLIED WARRANTY OF MERCHANTABILITY or FITNESS FOR A PARTICULAR\nPURPOSE. See the terms and conditions of the GNU Lesser General Public License\nfor more details.  You should have received a copy of the GNU Lesser General\nPublic License along with this program; if not, write to the Free Software\nFoundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA\n*/\n\n#include <dlfcn.h>\n#include <stdio.h>\n#include \"gotcha/gotcha.h\"\n\n#define Q(x) #x\n#define QUOTE(x) Q(x)\n\n#ifndef LIB_NAME_RAW\n#define LIB_NAME_RAW libnum.so\n#endif\n\n#define LIB_NAME QUOTE(LIB_NAME_RAW)\nint correct_return_four()\n{\n   return 4;\n}\n\nint return_five() \n{\n   /* Intentional bug, gotcha will correct this to return 5*/\n   return 3;\n}\n\nint correct_return_five()\n{\n   return 5;\n}\n\n\nstatic gotcha_wrappee_handle_t buggy_return_four;\nstatic gotcha_wrappee_handle_t buggy_return_five;\nstruct gotcha_binding_t funcs[] = {\n   { \"return_four\", correct_return_four, &buggy_return_four },\n   { \"return_five\", correct_return_five, &buggy_return_five }\n};\n\nint main()\n{\n   void *libnum;\n   int (*retfour)(void);\n   int (*test_retfive)(void);\n   int had_error = 0;\n   int result;\n\n   result = gotcha_wrap(funcs, 2, \"dlopen_test\");\n   if(result != GOTCHA_FUNCTION_NOT_FOUND){\n     fprintf(stderr, \"GOTCHA should have failed to find a function, but found it\\n\");\n     return -1;\n   }\n\n   libnum = dlopen(LIB_NAME, RTLD_NOW);\n   if (!libnum) {\n      fprintf(stderr, \"ERROR: Test failed to dlopen libnum.so\\n\");\n      return -1;\n   }\n\n   /* Test 1: Check if a dlsym generated indirect call gets re-routed by gotcha */\n   retfour = (int (*)(void)) dlsym(libnum, \"return_four\");\n   if (retfour() != 4) {\n      fprintf(stderr, \"ERROR: dlsym returned original function, not wrapped\\n\");\n      had_error = -1;\n   }\n\n   /* Test 2: Does a call in a dlopen'd library get rerouted by gotcha */\n   test_retfive = (int (*)(void)) dlsym(libnum, \"test_return_five\");\n   if (test_retfive() != 5) {\n      fprintf(stderr, \"ERROR: call to return_five in libnum.so was not wrapped by correct_return_five\\n\");\n      had_error = -1;\n   }\n\n   return had_error;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gotcha-1.0.3-64ohcxquoykyaq52pavphymncemuknvf/spack-src/test/multi_agent_dlopen/dlsym.c": "/*\n *  dlsym.c  -->  libsym.so\n *\n *  Override dlsym() and replace with __libc_dlsym().\n */\n\n#define _GNU_SOURCE  1\n\n#include <dlfcn.h>\n#include <err.h>\n#include <errno.h>\n#include <stdio.h>\n\n#define MYNAME  \"libsym.so\"\n\ntypedef void * dlsym_fcn_t(void *, const char *);\ntypedef void * dlopen_mode_fcn_t(const char *, int);\n\ndlsym_fcn_t __libc_dlsym;\ndlopen_mode_fcn_t __libc_dlopen_mode;\n\nvoid *\ndlsym(void *handle, const char *symbol)\n{\n    fprintf(stderr, \"%s:  enter dlsym:  sym = %s\\n\", MYNAME, symbol);\n\n    void * dl_handle = __libc_dlopen_mode(\"libdl.so\", RTLD_LAZY);\n\n    if (dl_handle == NULL) {\n\terr(1, \"__libc_dlopen_mode failed\");\n    }\n\n    dlsym_fcn_t * the_dlsym = __libc_dlsym(dl_handle, \"dlsym\");\n\n    if (the_dlsym == NULL) {\n\terr(1, \"__libc_dlsym failed\");\n    }\n\n    fprintf(stderr, \"%s:  mid   dlsym:  dlsym = %p\\n\", MYNAME, the_dlsym);\n\n#if 0\n    if (handle == RTLD_NEXT) { handle = RTLD_DEFAULT; }\n#endif\n\n    void *ans = the_dlsym(handle, symbol);\n\n    if (ans == NULL) {\n\terr(1, \"the_dlsym failed\");\n    }\n\n    fprintf(stderr, \"%s:  exit  dlsym:  ans = %p\\n\", MYNAME, ans);\n\n    return ans;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gotcha-1.0.3-64ohcxquoykyaq52pavphymncemuknvf/spack-src/test/multi_agent_dlopen/monitor.c": "/*\n *  monitor.c  -->  libmon.so\n *\n *  Override dlopen() use dlsym(RTLD_NEXT).\n */\n\n#define _GNU_SOURCE  1\n\n#include <dlfcn.h>\n#include <err.h>\n#include <errno.h>\n#include <stdio.h>\n#include <gotcha/gotcha.h>\n\n#define MYNAME  \"libmon.so\"\n\ntypedef void *dlopen_fcn_t(const char *, int);\n\ngotcha_wrappee_handle_t reel_dlopen_handle;\n\nvoid *\nwrap_dlopen(const char *file, int flag)\n{\n    typeof(&wrap_dlopen) reel_dlopen = gotcha_get_wrappee(reel_dlopen_handle);\n    fprintf(stderr, \"ENTER WRAP: %p\\n\", reel_dlopen);\n    fprintf(stderr, \"%s:  enter dlopen:  file = %s\\n\", MYNAME, file);\n\n    void *ans = reel_dlopen ? (reel_dlopen)(file, flag) : NULL;\n    if(!ans){\n      fprintf(stderr, \"Real dlopen not found\\n\");\n    }\n    fprintf(stderr, \"%s:  exit  dlopen:  handle = %p\\n\", MYNAME, ans);\n\n    return ans;\n}\nvoid* opaque;\nstruct gotcha_binding_t binds[] = {\n  { \"dlopen\", wrap_dlopen, &reel_dlopen_handle}\n};\nvoid fix_things(){\n  reel_dlopen_handle = NULL;\n  gotcha_wrap(binds, 1, \"silly\");\n  typeof(&wrap_dlopen) reel_dlopen = gotcha_get_wrappee(reel_dlopen_handle);\n  fprintf(stderr, \"IMMEDIATE WRITE: %p\\n\", reel_dlopen);\n}\n__attribute__((constructor)) void startup_fix_things(){\n  fix_things(); \n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gotcha-1.0.3-64ohcxquoykyaq52pavphymncemuknvf/spack-src/test/multi_agent_dlopen/main.c": "/*\n *  Try dlopen(libm.so, ...) and call sin().\n */\n\n#include <dlfcn.h>\n#include <err.h>\n#include <errno.h>\n#include <math.h>\n#include <stdio.h>\n\n#define MYNAME  \"main\"\n\ntypedef double sin_fcn_t(double);\n\nint\nmain(int argc, char **argv)\n{\n    sin_fcn_t *sin_fcn = NULL;\n    double val = 4.0;\n    double ans = 0.0;\n\n    fprintf(stderr, \"%s:  val = %.6f\\n\", MYNAME, val);\n\n    void *handle = dlopen(\"libm.so\", RTLD_NOW);\n    if (handle == NULL) {\n\terr(1, \"dlopen failed\");\n    }\n\n    fprintf(stderr, \"%s:\\n\", MYNAME);\n\n    sin_fcn = dlsym(handle, \"sin\");\n    if (sin_fcn == NULL) {\n\terr(1, \"dlsym failed\");\n    }\n\n    fprintf(stderr, \"%s:\\n\", MYNAME);\n\n    ans = (*sin_fcn)(val);\n\n    fprintf(stderr, \"%s:  ans = %.6f\\n\", MYNAME, ans);\n\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gotcha-1.0.3-64ohcxquoykyaq52pavphymncemuknvf/spack-src/test/multi_agent_dlopen/CMakeLists.txt": "set(CMAKE_C_FLAGS \"-g -O -fPIC\")\nadd_library(multi_agent_sym SHARED dlsym.c)\nadd_library(multi_agent_mon SHARED monitor.c)\nadd_executable(multi_agent_main main.c)\ntarget_link_libraries(multi_agent_main dl)\ntarget_link_libraries(multi_agent_mon dl gotcha)\ngotcha_add_test(multi_agent_dlopen multi_agent_main)\nenvironment_add(multi_agent_dlopen TEST \"LD_PRELOAD=${CMAKE_CURRENT_BINARY_DIR}/libmulti_agent_sym.so:${CMAKE_CURRENT_BINARY_DIR}/libmulti_agent_mon.so GOTCHA_DEBUG=3 LIBNUM_DIR=${CMAKE_CURRENT_BINARY_DIR}\")\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-gotcha-1.0.3-64ohcxquoykyaq52pavphymncemuknvf/spack-src/.git/objects/pack/pack-7e9f47b493157e0de9a8e67624c9ff0e64f99c69.pack",
        "/tmp/vanessa/spack-stage/spack-stage-gotcha-1.0.3-64ohcxquoykyaq52pavphymncemuknvf/spack-src/.git/objects/pack/pack-7e9f47b493157e0de9a8e67624c9ff0e64f99c69.idx"
    ],
    "total_files": 107
}