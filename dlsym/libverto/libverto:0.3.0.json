{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-libverto-0.3.0-momtpszevh6jr2yhyzxzthmsoa65t335/spack-src/src/module.c": "/*\n * Copyright 2011 Red Hat, Inc.\n *\n * Permission is hereby granted, free of charge, to any person\n * obtaining a copy of this software and associated documentation files\n * (the \"Software\"), to deal in the Software without restriction,\n * including without limitation the rights to use, copy, modify, merge,\n * publish, distribute, sublicense, and/or sell copies of the Software,\n * and to permit persons to whom the Software is furnished to do so,\n * subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be\n * included in all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n#ifdef WIN32\n#include <windows.h>\n#define dlltype HMODULE\nstatic char *\ndllerror(void) {\n    char *amsg;\n    LPTSTR msg;\n\n    FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER\n                      | FORMAT_MESSAGE_FROM_SYSTEM\n                      | FORMAT_MESSAGE_IGNORE_INSERTS,\n                  NULL, GetLastError(),\n                  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n                  (LPTSTR) &msg, 0, NULL);\n    amsg = strdup((const char*) msg);\n    LocalFree(msg);\n    return amsg;\n}\n#elif defined(aix)\n#include \"sys/ldr.h\"\n\nstruct Dl_info {\n  const char* dli_fname;\n};\n\nstatic int\ndladdr(void* s, Dl_info* i)\n{\n    static const size_t bufSize = 4096;\n    G__FastAllocString buf(bufSize);\n    char* pldi = buf;\n    int r;\n\n    r = loadquery(L_GETINFO, pldi, bufSize);\n    if (r == -1) {\n        i->dli_fname = NULL;\n        return 0;\n    }\n\n    for (ld_info* ldi = (ld_info*) buf;\n         ldi->ldinfo_next;\n         ldi += ldi->ldinfo_next) {\n        char* textBegin = (char*) ldi->ldinfo_textorg;\n        if (textBegin < s) {\n            char* textEnd = textBegin + ldi->ldinfo_textsize;\n            if (textEnd > s) {\n                i->dli_fname = ldi->ldinfo_filename;\n                return 1;\n            }\n        }\n    }\n\n    // First is main(), skip.\n    ld_info* ldi = (ld_info*) pldi;\n    while (ldi->ldinfo_next) {\n        pldi += ldi->ldinfo_next;\n        ldi = (ld_info*) pldi;\n\n    }\n\n    i->dli_fname = NULL;\n    return 0;\n}\n#else\n#include <stdlib.h>\n#include <string.h>\n#include <dlfcn.h>\n#define dlltype void *\n#define dllerror() strdup(dlerror())\n#endif\n\nint\nmodule_symbol_is_present(const char *modname, const char *symbname)\n{\n#ifdef WIN32\n    return (GetProcAddress(GetModuleHandle(modname), symbname) != NULL ||\n            GetProcAddress(GetModuleHandle(NULL), symbname) != NULL);\n#else  /* WIN32 */\n    void *mod;\n    (void) modname;\n\n    mod = dlopen(NULL, RTLD_LAZY | RTLD_LOCAL);\n    if (mod) {\n        void* sym = dlsym(mod, symbname);\n        dlclose(mod);\n        return sym != NULL;\n    }\n#endif /* WIN32 */\n    return 0;\n}\n\nint\nmodule_get_filename_for_symbol(void *addr, char **filename)\n{\n#ifdef WIN32\n    MEMORY_BASIC_INFORMATION info;\n    HMODULE mod;\n    char tmp[MAX_PATH];\n\n    if (!VirtualQuery(addr, &info, sizeof(info)))\n        return 0;\n    mod = (HMODULE) info.AllocationBase;\n\n    if (!GetModuleFileNameA(mod, tmp, MAX_PATH))\n        return 0;\n#else\n    const char *tmp;\n    Dl_info dlinfo;\n\n    if (!dladdr(addr, &dlinfo))\n        return 0;\n    tmp = dlinfo.dli_fname;\n#endif\n\n    if (filename) {\n        *filename = strdup(tmp);\n        if (!*filename)\n            return 0;\n    }\n\n    return 1;\n}\n\nvoid\nmodule_close(void *dll)\n{\n    if (!dll)\n        return;\n\n#ifdef WIN32\n    FreeLibrary((dlltype) dll);\n#else  /* WIN32 */\n    dlclose((dlltype) dll);\n#endif /* WIN32 */\n}\n\nchar *\nmodule_load(const char *filename, const char *symbname,\n            int (*shouldload)(void *symb, void *misc, char **err), void *misc,\n            void **dll, void **symb)\n{\n    dlltype intdll = NULL;\n    void *  intsym = NULL;\n    char *  interr = NULL;\n\n    if (dll)\n        *dll = NULL;\n    if (symb)\n        *symb = NULL;\n\n    /* Open the module library */\n#ifdef WIN32\n    /* NOTE: DONT_RESOLVE_DLL_REFERENCES is evil. Don't use this in your own\n     * code. However, our design pattern avoids all the issues surrounding a\n     * more general use of this evil flag. */\n    intdll = LoadLibraryEx(filename, NULL, DONT_RESOLVE_DLL_REFERENCES);\n#else  /* WIN32 */\n    intdll = dlopen(filename, RTLD_LAZY | RTLD_LOCAL);\n#endif /* WIN32 */\n    if (!intdll)\n        return dllerror();\n\n    /* Get the module symbol */\n#ifdef WIN32\n    intsym = (void *) GetProcAddress(intdll, symbname);\n#else /* WIN32 */\n    intsym = dlsym(intdll, symbname);\n#endif /* WIN32 */\n    if (!intsym) {\n        module_close(intdll);\n        return dllerror();\n    }\n\n    /* Figure out whether or not to load this module */\n    if (!shouldload(intsym, misc, &interr)) {\n        module_close(intdll);\n        return interr;\n    }\n\n    /* Re-open the module */\n    module_close(intdll);\n#ifdef WIN32\n    intdll = LoadLibrary(filename);\n#else  /* WIN32 */\n    intdll = dlopen(filename, RTLD_NOW | RTLD_LOCAL);\n#endif /* WIN32 */\n    if (!intdll) {\n        return dllerror();\n    }\n\n    /* Get the symbol again */\n#ifdef WIN32\n    intsym = (void *) GetProcAddress(intdll, symbname);\n#else /* WIN32 */\n    intsym = dlsym(intdll, symbname);\n#endif /* WIN32 */\n    if (!intsym) {\n        module_close(intdll);\n        return dllerror();\n    }\n\n    if (dll)\n        *dll = intdll;\n    if (symb)\n        *symb = intsym;\n    return NULL;\n}\n"
    },
    "skipped": [],
    "total_files": 45
}