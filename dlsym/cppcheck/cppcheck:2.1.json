{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-cppcheck-2.1-nuqkpwt6rmykw7pafaimnhmrhiu5lb4y/spack-src/cfg/posix.cfg": "<?xml version=\"1.0\"?>\n<!-- Description of the interfaces described by previous and current POSIX standards.\n     Current reference: http://pubs.opengroup.org/onlinepubs/9699919799/ -->\n<def format=\"2\">\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/wait.html -->\n  <!-- Note: These are defined as macros in POSIX system headers -->\n  <function name=\"WIFEXITED,WEXITSTATUS,WIFSIGNALED,WTERMSIG,WIFSTOPPED,WSTOPSIG,WIFCONTINUED\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <use-retval/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- http://man7.org/linux/man-pages/man3/a64l.3.html -->\n  <!-- long a64l(const char *str64); -->\n  <function name=\"a64l\">\n    <use-retval/>\n    <returnValue type=\"long\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- http://man7.org/linux/man-pages/man3/a64l.3.html -->\n  <!-- char *l64a(long value); -->\n  <function name=\"l64a\">\n    <use-retval/>\n    <returnValue type=\"char *\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <!-- The behavior of l64a() is undefined when value is negative. -->\n      <!-- If value is zero, it returns an empty string. -->\n      <valid>0:</valid>\n    </arg>\n  </function>\n  <!-- int isalnum_l(int c, locale_t locale) -->\n  <function name=\"isalnum_l\">\n    <use-retval/>\n    <pure/>\n    <returnValue type=\"int\">arg1&gt;=0x30 &amp;&amp; arg1&lt;=0x39 || arg1&gt;=0x41 &amp;&amp; arg1 &lt;=0x5A || arg1&gt;=0x61 &amp;&amp; arg1 &lt;=0x7A</returnValue>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <valid>0:255</valid>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n  </function>\n  <!-- int isalpha_l(int c, locale_t locale); -->\n  <function name=\"isalpha_l\">\n    <use-retval/>\n    <pure/>\n    <returnValue type=\"int\">arg1&gt;='A' &amp;&amp; arg1&lt;='Z' || arg1&gt;='a' &amp;&amp; arg1 &lt;='z'</returnValue>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <valid>0:255</valid>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n  </function>\n  <!-- int isblank_l(int c, locale_t locale); -->\n  <function name=\"isblank_l\">\n    <use-retval/>\n    <pure/>\n    <returnValue type=\"int\">arg1==' ' || arg1=='\\t'</returnValue>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <valid>0:255</valid>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n  </function>\n  <!-- int iscntrl_l(int c, locale_t locale); -->\n  <function name=\"iscntrl_l\">\n    <use-retval/>\n    <pure/>\n    <returnValue type=\"int\">arg1==0x7F || arg1&lt;=0x1F</returnValue>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <valid>0:255</valid>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n  </function>\n  <!-- int isdigit_l(int c, locale_t locale); -->\n  <function name=\"isdigit_l\">\n    <use-retval/>\n    <pure/>\n    <returnValue type=\"int\">arg1&gt;='0' &amp;&amp; arg1&lt;='9'</returnValue>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <valid>0:255</valid>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n  </function>\n  <!-- int isgraph_l(int c, locale_t locale); -->\n  <function name=\"isgraph_l\">\n    <use-retval/>\n    <pure/>\n    <returnValue type=\"int\">arg1&gt;=0x21 &amp;&amp; arg1&lt;=0x7E</returnValue>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <valid>0:255</valid>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n  </function>\n  <!-- int islower_l(int c, locale_t locale); -->\n  <function name=\"islower_l\">\n    <use-retval/>\n    <pure/>\n    <returnValue type=\"int\">arg1&gt;=0x61 &amp;&amp; arg1&lt;=0x7A</returnValue>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <valid>0:255</valid>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n  </function>\n  <!-- int isprint_l(int c, locale_t locale); -->\n  <function name=\"isprint_l\">\n    <use-retval/>\n    <pure/>\n    <returnValue type=\"int\">arg1&gt;=0x20 &amp;&amp; arg1&lt;=0x7E</returnValue>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <valid>0:255</valid>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n  </function>\n  <!-- int ispunct_l(int c, locale_t locale); -->\n  <function name=\"ispunct_l\">\n    <use-retval/>\n    <pure/>\n    <returnValue type=\"int\">arg1&gt;=0x21 &amp;&amp; arg1&lt;=0x2F || arg1&gt;=0x3A &amp;&amp; arg1&lt;=0x40 || arg1&gt;=0x5B &amp;&amp; arg1&lt;=0x60 || arg1&gt;=0x7B &amp;&amp; arg1&lt;=0x7E</returnValue>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <valid>0:255</valid>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n  </function>\n  <!-- int isspace_l(int c, locale_t locale); -->\n  <function name=\"isspace_l\">\n    <use-retval/>\n    <pure/>\n    <returnValue type=\"int\">arg1&gt;=0x09 &amp;&amp; arg1&lt;=0x0D || arg1==0x20</returnValue>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <valid>0:255</valid>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n  </function>\n  <!-- int isascii(int c); -->\n  <function name=\"isascii\">\n    <use-retval/>\n    <pure/>\n    <returnValue type=\"int\">arg1&gt;=0 &amp;&amp; arg1&lt;=0x7F</returnValue>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:255</valid>\n    </arg>\n  </function>\n  <!-- int isupper_l(int c, locale_t locale) -->\n  <function name=\"isupper_l\">\n    <use-retval/>\n    <pure/>\n    <returnValue type=\"int\">arg1&gt;=0x41 &amp;&amp; arg1&lt;=0x5A</returnValue>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <valid>0:255</valid>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n  </function>\n  <!-- int isxdigit_l(int c, locale_t locale) -->\n  <function name=\"isxdigit_l\">\n    <use-retval/>\n    <pure/>\n    <returnValue type=\"int\">arg1&gt;=0x30 &amp;&amp; arg1&lt;=0x39 || arg1&gt;=0x41 &amp;&amp; arg1&lt;=0x46 || arg1&gt;=0x61 &amp;&amp; arg1&lt;=0x66</returnValue>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <valid>0:255</valid>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n  </function>\n  <!-- http://man7.org/linux/man-pages/man2/accept.2.html -->\n  <!-- int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen); -->\n  <function name=\"accept\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"2\" direction=\"out\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"3\" direction=\"inout\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- http://pubs.opengroup.org/onlinepubs/9699919799/functions/access.html -->\n  <!-- int access(const char *pathname, int amode); -->\n  <function name=\"access\">\n    <use-retval/>\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-null/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- http://man7.org/linux/man-pages/man3/adjtime.3.html -->\n  <!-- int adjtime(const struct timeval *delta, struct timeval *olddelta); -->\n  <function name=\"adjtime\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"out\">\n      <not-bool/>\n    </arg>\n  </function>\n  <resource>\n    <alloc>dlopen</alloc>\n    <dealloc>dlclose</dealloc>\n  </resource>\n  <!-- int bind(int socket, const struct sockaddr *address, socklen_t address_len); -->\n  <function name=\"bind\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"int\"/>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-bool/>\n      <not-uninit/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-null/>\n      <minsize type=\"argvalue\" arg=\"3\"/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n  </function>\n  <!-- int listen(int sockfd, int backlog); -->\n  <function name=\"listen\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"int\"/>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-bool/>\n      <not-uninit/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-bool/>\n      <not-uninit/>\n    </arg>\n  </function>\n  <!-- int getpeername(int sockfd, struct sockaddr *addr, socklen_t *addrlen); -->\n  <!-- int getsockname(int sockfd, struct sockaddr *addr, socklen_t *addrlen); -->\n  <function name=\"getpeername,getsockname\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"int\"/>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"2\" direction=\"out\">\n      <not-null/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n  </function>\n  <!-- int connect(int socket, const struct sockaddr *address, socklen_t address_len); -->\n  <function name=\"connect\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n  </function>\n  <!-- see http://pubs.opengroup.org/onlinepubs/9699919799/functions/dlopen.html -->\n  <!-- void *dlopen(const char *file, int mode); -->\n  <function name=\"dlopen\">\n    <noreturn>false</noreturn>\n    <use-retval/>\n    <returnValue type=\"void*\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- see http://pubs.opengroup.org/onlinepubs/9699919799/functions/dlsym.html -->\n  <!-- void *dlsym(void *restrict handle, const char *restrict name); -->\n  <function name=\"dlsym\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <use-retval/>\n    <returnValue type=\"void*\"/>\n    <arg nr=\"1\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n  </function>\n  <!-- see http://pubs.opengroup.org/onlinepubs/9699919799/functions/dlclose.html -->\n  <!-- int dlclose(void *handle); -->\n  <function name=\"dlclose\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\">\n      <not-uninit/>\n    </arg>\n  </function>\n  <!-- int dup(int fildes);\n     see http://pubs.opengroup.org/onlinepubs/9699919799/functions/dup.html -->\n  <function name=\"dup\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"int\"/>\n    <use-retval/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-bool/>\n      <not-uninit/>\n      <valid>0:</valid>\n    </arg>\n  </function>\n  <!-- int dup2(int fildes1, int filedes2);\n     see http://pubs.opengroup.org/onlinepubs/9699919799/functions/dup.html -->\n  <function name=\"dup2\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-bool/>\n      <not-uninit/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-bool/>\n      <not-uninit/>\n      <valid>0:</valid>\n    </arg>\n  </function>\n  <!-- int gettimeofday(struct timeval *tv, struct timezone *tz); -->\n  <function name=\"gettimeofday\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"int\"/>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"out\"/>\n    <arg nr=\"2\" direction=\"out\">\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int settimeofday(const struct timeval *tv, const struct timezone *tz); -->\n  <function name=\"settimeofday\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"int\"/>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- void FD_CLR(int fd, fd_set *set); -->\n  <function name=\"FD_CLR\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"void\"/>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"2\" direction=\"inout\">\n      <not-null/>\n    </arg>\n  </function>\n  <!-- int FD_ISSET(int fd, fd_set *set); -->\n  <function name=\"FD_ISSET\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-null/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- void FD_SET(int fd, fd_set *set); -->\n  <function name=\"FD_SET\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"void\"/>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"2\" direction=\"inout\">\n      <not-null/>\n    </arg>\n  </function>\n  <!-- void FD_ZERO(fd_set *set);-->\n  <function name=\"FD_ZERO\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"void\"/>\n    <arg nr=\"1\" direction=\"out\">\n      <not-null/>\n    </arg>\n  </function>\n  <!-- http://pubs.opengroup.org/onlinepubs/009695399/functions/fdatasync.html -->\n  <!-- int fdatasync(int fildes); -->\n  <function name=\"fdatasync\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n  </function>\n  <!-- http://pubs.opengroup.org/onlinepubs/9699919799/functions/fnmatch.html -->\n  <!-- int fnmatch(const char *pattern, const char *string, int flags); -->\n  <function name=\"fnmatch\">\n    <pure/>\n    <use-retval/>\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-null/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-null/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- http://pubs.opengroup.org/onlinepubs/009695399/functions/fsync.html -->\n  <!-- int fsync(int fildes); -->\n  <function name=\"fsync\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n  </function>\n  <!-- http://pubs.opengroup.org/onlinepubs/9699919799/functions/truncate.html -->\n  <!-- int truncate(const char *path, off_t length); -->\n  <function name=\"truncate\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int ftruncate(int fd, off_t length); -->\n  <function name=\"ftruncate\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int flock(int fd, int operation); -->\n  <function name=\"flock\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int lockf(int fd, int cmd, off_t len); -->\n  <function name=\"lockf\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- void flockfile(FILE *filehandle); -->\n  <!-- void funlockfile(FILE *filehandle); -->\n  <function name=\"flockfile,funlockfile\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"void\"/>\n    <arg nr=\"1\" direction=\"inout\">\n      <not-uninit/>\n    </arg>\n  </function>\n  <!-- int ftrylockfile(FILE *filehandle); -->\n  <function name=\"ftrylockfile\">\n    <noreturn>false</noreturn>\n    <use-retval/>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"inout\">\n      <not-uninit/>\n    </arg>\n  </function>\n  <!-- int symlinkat(const char *oldpath, int newdirfd, const char *newpath); -->\n  <function name=\"symlinkat\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <valid>0:</valid>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n  </function>\n  <!-- int symlink(const char *oldpath, const char *newpath); -->\n  <function name=\"symlink\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int open(const char *pathname, int flags) -->\n  <!-- int open(const char *pathname, int flags, mode_t mode); -->\n  <function name=\"open\">\n    <!-- TODO: add use-retval when cppcheck suppresses redundant messages\n    because of violations to alloc/dealloc and use-retval configuration-->\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"3\" default=\"0\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int openat(int dirfd, const char *pathname, int flags); -->\n  <!-- int openat(int dirfd, const char *pathname, int flags, mode_t mode);  -->\n  <function name=\"openat\">\n    <!-- TODO: add use-retval when cppcheck suppresses redundant messages\n    because of violations to alloc/dealloc and use-retval configuration-->\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"4\" default=\"0\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int creat(const char *pathname, mode_t mode); -->\n  <function name=\"creat\">\n    <use-retval/>\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- unsigned int sleep(unsigned int seconds); -->\n  <function name=\"sleep\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"unsigned int\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n  </function>\n  <!-- int usleep(useconds_t useconds); -->\n  <function name=\"usleep\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"int\"/>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-bool/>\n      <valid>0:999999</valid>\n    </arg>\n    <warn severity=\"style\">Obsolescent function 'usleep' called. It is recommended to use 'nanosleep' or 'setitimer' instead.\nThe obsolescent function 'usleep' is called. POSIX.1-2001 declares usleep() function obsolescent and POSIX.1-2008 removes it. It is recommended that new applications use the 'nanosleep' or 'setitimer' function.</warn>\n  </function>\n  <!-- void _exit(int status); -->\n  <function name=\"_exit\">\n    <noreturn>true</noreturn>\n    <returnValue type=\"void\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- http://man7.org/linux/man-pages/man3/dirfd.3.html -->\n  <!-- int dirfd(DIR *dirp); -->\n  <function name=\"dirfd\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-null/>\n    </arg>\n  </function>\n  <!-- http://man7.org/linux/man-pages/man2/access.2.html -->\n  <!-- int faccessat(int dirfd, const char *pathname, int mode, int flags); -->\n  <function name=\"faccessat\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"4\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- http://man7.org/linux/man-pages/man2/acct.2.html -->\n  <!-- int acct(const char *filename); -->\n  <function name=\"acct\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- http://man7.org/linux/man-pages/man2/alarm.2.html -->\n  <!-- unsigned int alarm(unsigned int seconds); -->\n  <function name=\"alarm\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"unsigned int\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n  </function>\n  <!-- struct rpcent *getrpcent(void); -->\n  <function name=\"getrpcent\">\n    <use-retval/>\n    <returnValue type=\"struct rpcent *\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <warn severity=\"portability\">Non reentrant function 'getrpcent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getrpcent_r'.</warn>\n  </function>\n  <!-- struct rpcent *getrpcbyname(char *name); -->\n  <function name=\"getrpcbyname\">\n    <use-retval/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"struct rpcent *\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <warn severity=\"portability\">Non reentrant function 'getrpcbyname' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getrpcbyname_r'.</warn>\n  </function>\n  <!-- struct rpcent *getrpcbynumber(int number); -->\n  <function name=\"getrpcbynumber\">\n    <use-retval/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"struct rpcent *\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <warn severity=\"portability\">Non reentrant function 'getrpcbynumber' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getrpcbynumber_r'.</warn>\n  </function>\n  <!-- struct protoent *getprotoent(void); -->\n  <function name=\"getprotoent\">\n    <use-retval/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"struct protoent *\"/>\n    <warn severity=\"portability\">Non reentrant function 'getprotoent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getprotoent_r'.</warn>\n  </function>\n  <!-- struct protoent *getprotobyname(const char *name); -->\n  <function name=\"getprotobyname\">\n    <use-retval/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"struct protoent *\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <warn severity=\"portability\">Non reentrant function 'getprotobyname' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getprotobyname_r'.</warn>\n  </function>\n  <!-- struct protoent *getprotobynumber(int proto); -->\n  <function name=\"getprotobynumber\">\n    <use-retval/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"struct protoent *\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <warn severity=\"portability\">Non reentrant function 'getprotobynumber' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getprotobynumber_r'.</warn>\n  </function>\n  <!-- struct servent *getservent(void); -->\n  <function name=\"getservent\">\n    <use-retval/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"struct servent *\"/>\n    <warn severity=\"portability\">Non reentrant function 'getservent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getservent_r'.</warn>\n  </function>\n  <!-- struct servent *getservbyname(const char *name, const char *proto); -->\n  <function name=\"getservbyname\">\n    <use-retval/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"struct servent *\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <warn severity=\"portability\">Non reentrant function 'getservbyname' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getservbyname_r'.</warn>\n  </function>\n  <!-- struct servent *getservbyport(int port, const char *proto); -->\n  <function name=\"getservbyport\">\n    <use-retval/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"struct servent *\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <warn severity=\"portability\">Non reentrant function 'getservbyport' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getservbyport_r'.</warn>\n  </function>\n  <!-- struct netent  *getnetent(void); -->\n  <function name=\"getnetent\">\n    <use-retval/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"struct netent *\"/>\n    <warn severity=\"portability\">Non reentrant function 'getnetent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getnetent_r'.</warn>\n  </function>\n  <!-- struct netent *getnetbyname(const char *name); -->\n  <function name=\"getnetbyname\">\n    <use-retval/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"struct netent *\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <warn severity=\"portability\">Non reentrant function 'getnetbyname' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getnetbyname_r'.</warn>\n  </function>\n  <!-- struct netent *getnetbyaddr(uint32_t net, int type); -->\n  <function name=\"getnetbyaddr\">\n    <use-retval/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"struct netent *\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <warn severity=\"portability\">Non reentrant function 'getnetbyaddr' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getnetbyaddr_r'.</warn>\n  </function>\n  <!-- struct hostent *gethostent(void); -->\n  <function name=\"gethostent\">\n    <use-retval/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"struct hostent *\"/>\n    <warn severity=\"portability\">Non reentrant function 'gethostent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'gethostent_r'.</warn>\n  </function>\n  <!-- struct hostent *gethostbyname(const char *name); -->\n  <function name=\"gethostbyname\">\n    <use-retval/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"struct hostent *\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <warn severity=\"style\" reason=\"Obsolescent\" alternatives=\"getaddrinfo\"/>\n  </function>\n  <!-- struct hostent *gethostbyname2(const char *name, int af); -->\n  <function name=\"gethostbyname2\">\n    <use-retval/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"struct hostent *\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <warn severity=\"portability\">Non reentrant function 'gethostbyname2' called. For threadsafe applications it is recommended to use the reentrant replacement function 'gethostbyname2_r'.</warn>\n  </function>\n  <!-- struct hostent *gethostbyaddr(const void *addr, socklen_t len, int type); -->\n  <function name=\"gethostbyaddr\">\n    <use-retval/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"struct hostent *\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <warn severity=\"style\" reason=\"Obsolescent\" alternatives=\"getnameinfo\"/>\n  </function>\n  <!-- int brk(void *addr); -->\n  <function name=\"brk\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\">\n      <not-null/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- void *sbrk(intptr_t incr);-->\n  <function name=\"sbrk\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"void *\"/>\n    <arg nr=\"1\">\n      <not-uninit/>\n    </arg>\n  </function>\n  <!-- int closedir(DIR *dir); -->\n  <function name=\"closedir\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\">\n      <not-null/>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- char *strfry(char *string); -->\n  <function name=\"strfry\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"char *\"/>\n    <arg nr=\"1\">\n      <not-null/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- char *strsep(char **stringp, const char *delim); -->\n  <function name=\"strsep\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"char *\"/>\n    <arg nr=\"1\">\n      <not-uninit/>\n      <not-null/>\n    </arg>\n    <arg nr=\"2\">\n      <not-null/>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- char *strdup(const char *s); -->\n  <function name=\"strdup\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"char *\"/>\n    <use-retval/>\n    <arg nr=\"1\">\n      <not-null/>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- char *strndup(const char *s, size_t n); -->\n  <function name=\"strndup\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"char *\"/>\n    <use-retval/>\n    <arg nr=\"1\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n  </function>\n  <!-- wchar_t *wcsdup(const wchar_t *s); -->\n  <function name=\"wcsdup\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"wchar_t *\"/>\n    <use-retval/>\n    <arg nr=\"1\">\n      <not-null/>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int mkstemp(char *template); -->\n  <function name=\"mkstemp\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\">\n      <not-null/>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- char *mkdtemp(char *template); -->\n  <function name=\"mkdtemp\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"char *\"/>\n    <arg nr=\"1\">\n      <not-null/>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- char *mktemp(char *template); -->\n  <function name=\"mktemp\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"char *\"/>\n    <leak-ignore/>\n    <use-retval/>\n    <arg nr=\"1\">\n      <not-null/>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <warn severity=\"warning\">Obsolete function 'mktemp' called. It is recommended to use 'mkstemp' or 'mkdtemp' instead.\nThe function 'mktemp' is considered to be dangerous due to race conditions and some implementations generating only up to 26 different filenames out of each template. This function has been removed in POSIX.1-2008. Use 'mkstemp' or 'mkdtemp' instead.</warn>\n  </function>\n  <!-- char *getcwd(char *buf, size_t size); -->\n  <function name=\"getcwd\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"char *\"/>\n    <leak-ignore/>\n    <arg nr=\"1\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n  </function>\n  <!-- int mkdir(const char *pathname, mode_t mode); -->\n  <function name=\"mkdir\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"int\"/>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int mknod(const char *pathname, mode_t mode, dev_t dev); -->\n  <function name=\"mknod\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"int\"/>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n  </function>\n  <!-- int mknodat(int dirfd, const char *pathname, mode_t mode, dev_t dev); -->\n  <function name=\"mknodat\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"int\"/>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"4\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n  </function>\n  <!-- int mkdirat(int dirfd, const char *pathname, mode_t mode); -->\n  <function name=\"mkdirat\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"int\"/>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int fchmodat(int dirfd, const char *pathname, mode_t mode, int flags); -->\n  <function name=\"fchmodat\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"int\"/>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"4\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int fchownat(int dirfd, const char *pathname, uid_t owner, gid_t group, int flags); -->\n  <function name=\"fchownat\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"int\"/>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"4\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"5\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int rmdir(const char *pathname); -->\n  <function name=\"rmdir\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int chdir(const char *path); -->\n  <function name=\"chdir\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int chroot(const char *path); -->\n  <function name=\"chroot\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int link(const char *oldpath, const char *newpath); -->\n  <function name=\"link\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int linkat(int fd1, const char *path1, int fd2, const char *path2, int flag); -->\n  <function name=\"linkat\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <valid>0:</valid>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"4\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int unlinkat(int fd, const char *path, int flag); -->\n  <function name=\"unlinkat\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <valid>0:</valid>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int unlink(const char *pathname); -->\n  <function name=\"unlink\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int stat(const char *file_name, struct stat *buf); -->\n  <function name=\"stat\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"out\">\n      <not-null/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int lstat(const char *file_name, struct stat *buf); -->\n  <function name=\"lstat\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"out\">\n      <not-null/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int fstat(int fd, struct stat *statbuf); -->\n  <function name=\"fstat\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <valid>0:</valid>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"out\">\n      <not-null/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int fstatat(int dirfd, const char *pathname, struct stat *statbuf, int flags); -->\n  <function name=\"fstatat\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"3\" direction=\"out\">\n      <not-null/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"4\" direction=\"in\">\n      <not-bool/>\n      <not-uninit/>\n    </arg>\n  </function>\n  <!-- int chmod(const char *path, mode_t mode); -->\n  <function name=\"chmod\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- mode_t umask(mode_t mask); -->\n  <function name=\"umask\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"mode_t\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int fchmod(int fildes, mode_t mode); -->\n  <function name=\"fchmod\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int chown(const char *path, uid_t owner, gid_t group); -->\n  <function name=\"chown\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int lchown(const char *path, uid_t owner, gid_t group); -->\n  <function name=\"lchown\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int fchown(int fildes, uid_t owner, gid_t group); -->\n  <function name=\"fchown\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- clock_t times(struct tms *buffer); -->\n  <function name=\"times\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"clock_t\"/>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"out\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int utime(const char *filename, struct utimbuf *buf); -->\n  <function name=\"utime\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <warn severity=\"style\" reason=\"Obsolescent\" alternatives=\"utimensat\"/>\n  </function>\n  <!-- int futimens(int fd, const struct timespec times[2]);-->\n  <function name=\"futimens\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <minsize type=\"value\" value=\"2\"/>\n    </arg>\n  </function>\n  <!-- int utimensat(int dirfd, const char *pathname, const struct timespec times[2], int flags);-->\n  <function name=\"utimensat\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <minsize type=\"value\" value=\"2\"/>\n    </arg>\n    <arg nr=\"4\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int utimes(const char *filename, const struct timeval times[2]); -->\n  <function name=\"utimes\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <minsize type=\"value\" value=\"2\"/>\n    </arg>\n  </function>\n  <!-- DIR *opendir(const char *name); -->\n  <function name=\"opendir\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"DIR *\"/>\n    <use-retval/>\n    <arg nr=\"1\">\n      <not-null/>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- DIR *fdopendir(int fd); -->\n  <function name=\"fdopendir\">\n    <use-retval/>\n    <returnValue type=\"DIR *\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\">\n      <not-uninit/>\n      <valid>0:</valid>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int isatty(int fildes); -->\n  <function name=\"isatty\">\n    <use-retval/>\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\">\n      <valid>0:</valid>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- FILE *popen(const char *command, const char *type); -->\n  <function name=\"popen\">\n    <use-retval/>\n    <returnValue type=\"FILE *\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\">\n      <not-null/>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int pclose(FILE *stream); -->\n  <function name=\"pclose\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\">\n      <not-null/>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int socket(int domain, int type, int protocol); -->\n  <function name=\"socket\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"3\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/setsockopt.html -->\n  <!-- int setsockopt(int socket, int level, int option_name,\n       const void *option_value, socklen_t option_len); -->\n  <function name=\"setsockopt\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"int\"/>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"4\" direction=\"in\">\n      <not-null/>\n      <minsize type=\"argvalue\" arg=\"5\"/>\n    </arg>\n    <arg nr=\"5\" direction=\"in\">\n      <not-uninit/>\n      <valid>0:</valid>\n    </arg>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/getsockopt.html -->\n  <!-- int getsockopt(int socket, int level, int option_name,\n       void *restrict option_value, socklen_t *restrict option_len); -->\n  <function name=\"getsockopt\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"int\"/>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"4\" direction=\"out\">\n      <not-null/>\n    </arg>\n    <arg nr=\"5\" direction=\"inout\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n  </function>\n  <!-- int nice(int incr); -->\n  <function name=\"nice\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"int\"/>\n    <leak-ignore/>\n    <arg nr=\"1\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int pause(void); -->\n  <function name=\"pause\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"int\"/>\n    <leak-ignore/>\n  </function>\n  <!-- int close(int fildes); -->\n  <function name=\"close\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n  </function>\n  <!-- size_t confstr(int, char *, size_t); -->\n  <function name=\"confstr\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"size_t\"/>\n    <arg nr=\"1\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"3\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n  </function>\n  <!-- long int fpathconf(int fildes, int name); -->\n  <function name=\"fpathconf\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"long int\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- long int pathconf(const char *path, int name); -->\n  <function name=\"pathconf\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"long int\"/>\n    <arg nr=\"1\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- long int sysconf(int name); -->\n  <function name=\"sysconf\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"long int\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- FILE *fdopen(int fd, const char *mode); -->\n  <function name=\"fdopen\">\n    <use-retval/>\n    <returnValue type=\"FILE *\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"2\">\n      <not-null/>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- long int random(void); -->\n  <function name=\"random\">\n    <use-retval/>\n    <returnValue type=\"long int\"/>\n    <noreturn>false</noreturn>\n  </function>\n  <!-- void srandom(unsigned int seed); -->\n  <function name=\"srandom\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"void\"/>\n    <!-- It is common practice to call srandom with an uninitialized \n         variable. Therefore, no warning shall be generated in this \n         very special case. -->\n    <arg nr=\"1\"/>\n  </function>\n  <!-- void rewinddir(DIR *dir); -->\n  <function name=\"rewinddir\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"void\"/>\n    <arg nr=\"1\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n  </function>\n  <!-- void seekdir(DIR *dirp, long loc); -->\n  <function name=\"seekdir\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"void\"/>\n    <arg nr=\"1\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int rand_r(unsigned int *seedp); -->\n  <function name=\"rand_r\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\">\n      <not-null/>\n      <not-bool/>\n    </arg>\n    <warn severity=\"style\" reason=\"Obsolescent\" alternatives=\"rand\"/>\n  </function>\n  <!-- int strcasecmp(const char *s1, const char *s2); -->\n  <function name=\"strcasecmp\">\n    <pure/>\n    <use-retval/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int strncasecmp(const char *s1, const char *s2, size_t n); -->\n  <function name=\"strncasecmp\">\n    <pure/>\n    <use-retval/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n  </function>\n  <!-- ssize_t sendfile(int out_fd, int in_fd, off_t *offset, size_t count); -->\n  <function name=\"sendfile\">\n    <leak-ignore/>\n    <returnValue type=\"ssize_t\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"4\" direction=\"in\">\n      <not-bool/>\n      <valid>1:</valid>\n    </arg>\n  </function>\n  <!-- ssize_t read(int fd, void *buf, size_t count); -->\n  <function name=\"read\">\n    <leak-ignore/>\n    <returnValue type=\"ssize_t\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"2\" direction=\"out\">\n      <minsize type=\"argvalue\" arg=\"3\"/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n  </function>\n  <!-- ssize_t write(int fildes, const void *buf, size_t nbyte); -->\n  <function name=\"write\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"ssize_t\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <minsize type=\"argvalue\" arg=\"3\"/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n  </function>\n  <!-- ssize_t recv(int sockfd, void *buf, size_t len, int flags); -->\n  <function name=\"recv\">\n    <returnValue type=\"ssize_t\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"2\" direction=\"out\">\n      <minsize type=\"argvalue\" arg=\"3\"/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"4\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,\n                        struct sockaddr *src_addr, socklen_t *addrlen); -->\n  <function name=\"recvfrom\">\n    <returnValue type=\"ssize_t\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"2\" direction=\"out\">\n      <minsize type=\"argvalue\" arg=\"3\"/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"4\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"5\" direction=\"out\"/>\n    <arg nr=\"6\" direction=\"inout\">\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- ssize_t recvmsg(int sockfd, struct msghdr *msg, int flags); -->\n  <function name=\"recvmsg\">\n    <returnValue type=\"ssize_t\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"2\" direction=\"inout\"/>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- ssize_t send(int sockfd, const void *buf, size_t len, int flags); -->\n  <function name=\"send\">\n    <returnValue type=\"ssize_t\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <minsize type=\"argvalue\" arg=\"3\"/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"4\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,\n                      const struct sockaddr *dest_addr, socklen_t addrlen); -->\n  <function name=\"sendto\">\n    <returnValue type=\"ssize_t\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <minsize type=\"argvalue\" arg=\"3\"/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"4\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"5\" direction=\"in\"/>\n    <arg nr=\"6\" direction=\"in\">\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- ssize_t sendmsg(int sockfd, const struct msghdr *msg, int flags); -->\n  <function name=\"sendmsg\">\n    <returnValue type=\"ssize_t\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/mmap.html -->\n  <!-- void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset); -->\n  <function name=\"mmap\">\n    <use-retval/>\n    <returnValue type=\"void *\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>1:</valid>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-bool/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"4\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"5\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"6\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- void *mmap64(void *addr, size_t length, int prot, int flags, int fd, off64_t offset); -->\n  <function name=\"mmap64\">\n    <use-retval/>\n    <returnValue type=\"void *\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>1:</valid>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"4\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"5\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"6\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/munmap.html -->\n  <!-- int munmap(void *addr, size_t length); -->\n  <function name=\"munmap\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>1:</valid>\n    </arg>\n  </function>\n  <!-- void openlog(const char *ident, int option, int facility); -->\n  <function name=\"openlog\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"void\"/>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n  </function>\n  <!-- int fcntl(int fd, int cmd, ... /* arg */ ); -->\n  <function name=\"fcntl\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"any\">\n      <not-uninit/>\n    </arg>\n  </function>\n  <!-- http://man7.org/linux/man-pages/man2/ioctl.2.html -->\n  <!-- int ioctl(int fd, unsigned long request, ...); -->\n  <function name=\"ioctl\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"any\">\n      <not-uninit/>\n    </arg>\n  </function>\n  <!-- void syslog(int priority, const char *format, ...); -->\n  <function name=\"syslog\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <formatstr/>\n    <arg nr=\"2\" direction=\"in\">\n      <formatstr/>\n    </arg>\n    <arg nr=\"any\">\n      <not-uninit/>\n    </arg>\n  </function>\n  <!-- void vsyslog(int priority, const char *format, va_list ap); -->\n  <function name=\"vsyslog\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"void\"/>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <formatstr/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n  </function>\n  <!-- gid_t getgid(void) -->\n  <function name=\"getgid\">\n    <use-retval/>\n    <returnValue type=\"gid_t\"/>\n    <noreturn>false</noreturn>\n  </function>\n  <!-- gid_t getegid(void) -->\n  <function name=\"getegid\">\n    <use-retval/>\n    <returnValue type=\"gid_t\"/>\n    <noreturn>false</noreturn>\n  </function>\n  <!-- uid_t getuid (void); -->\n  <function name=\"getuid\">\n    <use-retval/>\n    <returnValue type=\"uid_t\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n  </function>\n  <!-- pid_t getsid(pid_t pid); -->\n  <function name=\"getsid\">\n    <use-retval/>\n    <returnValue type=\"pid_t\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- uid_t geteuid(void); -->\n  <function name=\"geteuid\">\n    <use-retval/>\n    <returnValue type=\"uid_t\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n  </function>\n  <!-- pid_t getppid(void); -->\n  <function name=\"getppid\">\n    <use-retval/>\n    <returnValue type=\"pid_t\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n  </function>\n  <!-- pid_t getpid(void); -->\n  <function name=\"getpid\">\n    <use-retval/>\n    <returnValue type=\"pid_t\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n  </function>\n  <!-- pid_t getpgrp(void); -->\n  <function name=\"getpgrp\">\n    <use-retval/>\n    <returnValue type=\"pid_t\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n  </function>\n  <!-- ppid_t getpgid(pid_t pid); -->\n  <function name=\"getpgid\">\n    <use-retval/>\n    <returnValue type=\"ppid_t\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int setuid(uid_t uid); -->\n  <function name=\"setuid\">\n    <use-retval/>\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int seteuid(uid_t euid); -->\n  <function name=\"seteuid\">\n    <use-retval/>\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int setgid(gid_t gid); -->\n  <function name=\"setgid\">\n    <use-retval/>\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int setegid(gid_t egid); -->\n  <function name=\"setegid\">\n    <use-retval/>\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int setpgid(pid_t pid, pid_t pgid); -->\n  <function name=\"setpgid\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int socketpair(int domain, int type, int protocol, int sv[2]); -->\n  <function name=\"socketpair\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"4\" direction=\"out\">\n      <not-null/>\n      <not-bool/>\n      <minsize type=\"value\" value=\"2\"/>\n    </arg>\n  </function>\n  <!-- http://man7.org/linux/man-pages/man2/socketpair.2.html -->\n  <!-- int pipe(int fildes[2]); -->\n  <function name=\"pipe\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <use-retval/>\n    <arg nr=\"1\" direction=\"out\">\n      <not-null/>\n      <not-bool/>\n      <minsize type=\"value\" value=\"2\"/>\n    </arg>\n  </function>\n  <!-- int pselect(int nfds, fd_set *restrict readfds,\n       fd_set *restrict writefds, fd_set *restrict errorfds,\n       const struct timespec *restrict timeout,\n       const sigset_t *restrict sigmask);\n\t   see http://pubs.opengroup.org/onlinepubs/9699919799/functions/pselect.html -->\n  <function name=\"pselect\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"int\"/>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-bool/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"inout\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"3\" direction=\"inout\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"4\" direction=\"inout\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"5\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"6\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n  </function>\n  <!-- int select(int nfds, fd_set *restrict readfds, fd_set * writefds, fd_set * errorfds, struct timeval *timeout);\n       see http://pubs.opengroup.org/onlinepubs/9699919799/functions/pselect.html -->\n  <function name=\"select\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"int\"/>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-bool/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"inout\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"3\" direction=\"inout\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"4\" direction=\"inout\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"5\" direction=\"inout\">\n      <not-uninit/>\n    </arg>\n  </function>\n  <!-- pid_t setpgrp(void); -->\n  <function name=\"setpgrp\">\n    <returnValue type=\"pid_t\"/>\n    <noreturn>false</noreturn>\n  </function>\n  <!-- int setregid(gid_t rgid, gid_t egid); -->\n  <function name=\"setregid\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int setreuid(uid_t ruid, uid_t euid); -->\n  <function name=\"setreuid\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int setfsuid(uid_t fsuid); -->\n  <function name=\"setfsuid\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int setfsgid(uid_t fsgid); -->\n  <function name=\"setfsgid\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- pid_t setsid(void); -->\n  <function name=\"setsid\">\n    <returnValue type=\"pid_t\"/>\n    <noreturn>false</noreturn>\n    <!-- it is a good idea to do: <use-retval/> -->\n  </function>\n  <!-- char *getwd(char *path_name);-->\n  <function name=\"getwd\">\n    <returnValue type=\"char *\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\" direction=\"out\">\n      <not-null/>\n      <not-bool/>\n    </arg>\n    <leak-ignore/>\n    <warn severity=\"style\" reason=\"Obsolescent\" alternatives=\"getcwd\"/>\n  </function>\n  <!-- http://pubs.opengroup.org/onlinepubs/009695399/basedefs/arpa/inet.h.html -->\n  <!-- uint32_t htonl(uint32_t); -->\n  <function name=\"htonl\">\n    <returnValue type=\"uint32_t\"/>\n    <noreturn>false</noreturn>\n    <use-retval/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- uint16_t htons(uint16_t); -->\n  <function name=\"htons\">\n    <returnValue type=\"uint16_t\"/>\n    <noreturn>false</noreturn>\n    <use-retval/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- uint32_t ntohl(uint32_t); -->\n  <function name=\"ntohl\">\n    <returnValue type=\"uint32_t\"/>\n    <noreturn>false</noreturn>\n    <use-retval/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- uint16_t ntohs(uint16_t); -->\n  <function name=\"ntohs\">\n    <returnValue type=\"uint16_t\"/>\n    <noreturn>false</noreturn>\n    <use-retval/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- in_addr_t inet_addr(const char *cp);\n       http://pubs.opengroup.org/onlinepubs/009695399/functions/inet_addr.html -->\n  <function name=\"inet_addr\">\n    <leak-ignore/>\n    <pure/>\n    <returnValue type=\"in_addr_t\"/>\n    <noreturn>false</noreturn>\n    <use-retval/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <strz/>\n    </arg>\n  </function>\n  <!-- char *inet_ntoa(struct in_addr in);\n       http://pubs.opengroup.org/onlinepubs/009695399/functions/inet_addr.html -->\n  <function name=\"inet_ntoa\">\n    <leak-ignore/>\n    <returnValue type=\"char *\"/>\n    <noreturn>false</noreturn>\n    <use-retval/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int mq_close(mqd_t); -->\n  <function name=\"mq_close\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int mq_getattr(mqd_t, struct mq_attr *); -->\n  <function name=\"mq_getattr\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"out\">\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int mq_notify(mqd_t, const struct sigevent *); -->\n  <function name=\"mq_notify\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/mq_open.html -->\n  <!-- mqd_t mq_open(const char *name, int oflag, ...); -->\n  <function name=\"mq_open\">\n    <returnValue type=\"mqd_t\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <strz/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"any\"/>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/mq_receive.html -->\n  <!-- ssize_t mq_receive(mqd_t mqdes, char *msg_ptr, size_t msg_len, unsigned *msg_prio); -->\n  <function name=\"mq_receive\">\n    <returnValue type=\"ssize_t\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"out\">\n      <minsize type=\"argvalue\" arg=\"3\"/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"4\" direction=\"out\">\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/mq_send.html -->\n  <!-- int mq_send(mqd_t mqdes, const char *msg_ptr, size_t msg_len, unsigned msg_prio); -->\n  <function name=\"mq_send\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <minsize type=\"argvalue\" arg=\"3\"/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"4\" direction=\"in\">\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/mq_setattr.html -->\n  <!-- int mq_setattr(mqd_t mqdes, const struct mq_attr *restrict mqstat, struct mq_attr *restrict omqstat); -->\n  <function name=\"mq_setattr\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"3\" direction=\"out\">\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/mq_receive.html -->\n  <!-- ssize_t mq_timedreceive(mqd_t mqdes, char *restrict msg_ptr, size_t msg_len, unsigned *restrict msg_prio, const struct timespec *restrict abstime); -->\n  <function name=\"mq_timedreceive\">\n    <returnValue type=\"ssize_t\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"out\">\n      <minsize type=\"argvalue\" arg=\"3\"/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"4\" direction=\"out\"/>\n    <arg nr=\"5\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/mq_send.html -->\n  <!-- int mq_timedsend(mqd_t mqdes, const char *msg_ptr, size_t msg_len, unsigned msg_prio, const struct timespec *abstime); -->\n  <function name=\"mq_timedsend\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <minsize type=\"argvalue\" arg=\"3\"/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"4\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"5\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int mq_unlink(const char *name); -->\n  <function name=\"mq_unlink\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/dbm_clearerr.html -->\n  <!-- int dbm_clearerr(DBM *db); -->\n  <function name=\"dbm_clearerr\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\">\n      <not-null/>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- void dbm_close(DBM *db); -->\n  <function name=\"dbm_close\">\n    <noreturn>false</noreturn>\n    <arg nr=\"1\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n  </function>\n  <!-- int dbm_delete(DBM *db, datum key); -->\n  <function name=\"dbm_delete\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n  </function>\n  <!-- int dbm_error(DBM *db); -->\n  <function name=\"dbm_error\">\n    <use-retval/>\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\">\n      <not-null/>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- datum dbm_fetch(DBM *db, datum key); -->\n  <function name=\"dbm_fetch\">\n    <use-retval/>\n    <returnValue type=\"datum\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n  </function>\n  <!-- datum dbm_firstkey(DBM *db); -->\n  <function name=\"dbm_firstkey\">\n    <use-retval/>\n    <returnValue type=\"datum\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\">\n      <not-null/>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- datum dbm_nextkey(DBM *db); -->\n  <function name=\"dbm_nextkey\">\n    <use-retval/>\n    <returnValue type=\"datum\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\">\n      <not-null/>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- DBM *dbm_open(const char *file, int open_flags, mode_t file_mode); -->\n  <function name=\"dbm_open\">\n    <returnValue type=\"DBM *\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int dbm_store(DBM *db, datum key, datum content, int store_mode); -->\n  <function name=\"dbm_store\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"4\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- http://pubs.opengroup.org/onlinepubs/009695399/functions/freeaddrinfo.html -->\n  <!-- void freeaddrinfo(struct addrinfo *ai); -->\n  <function name=\"freeaddrinfo\">\n    <noreturn>false</noreturn>\n    <arg nr=\"1\">\n      <not-uninit/>\n      <not-null/>\n      <!-- not-null is not required by the resource above, but some systems will segfault -->\n    </arg>\n  </function>\n  <!-- http://pubs.opengroup.org/onlinepubs/009695399/functions/freeaddrinfo.html -->\n  <!-- int getaddrinfo(const char * nodename, const char * servname, const struct addrinfo * hints, struct addrinfo ** res); -->\n  <function name=\"getaddrinfo\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"4\" direction=\"out\">\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int getnameinfo(const struct sockaddr *restrict sa,\n                       socklen_t salen,\n                       char *restrict node,\n                       socklen_t nodelen,\n                       char *restrict service,\n                       socklen_t servicelen,\n                       int flags); -->\n  <function name=\"getnameinfo\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"int\"/>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <minsize type=\"argvalue\" arg=\"2\"/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"3\" direction=\"out\">\n      <minsize type=\"argvalue\" arg=\"4\"/>\n    </arg>\n    <arg nr=\"4\" direction=\"in\">\n      <not-uninit/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"5\" direction=\"out\">\n      <minsize type=\"argvalue\" arg=\"6\"/>\n    </arg>\n    <arg nr=\"6\" direction=\"in\">\n      <not-uninit/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"7\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- const char *gai_strerror(int ecode); -->\n  <function name=\"gai_strerror\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"const char *\"/>\n    <use-retval/>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- void endhostent(void); -->\n  <function name=\"endhostent\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"void\"/>\n  </function>\n  <!-- void sethostent(int stayopen); -->\n  <function name=\"sethostent\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"void\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int uname(struct utsname *buf); -->\n  <function name=\"uname\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\">\n      <not-null/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!--void endpwent(void); -->\n  <function name=\"endpwent\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"void\"/>\n  </function>\n  <!--struct passwd *getpwent(void); -->\n  <function name=\"getpwent\">\n    <use-retval/>\n    <returnValue type=\"struct passwd *\"/>\n    <noreturn>false</noreturn>\n    <warn severity=\"portability\">Non reentrant function 'getpwent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getpwent_r'.</warn>\n  </function>\n  <!--struct passwd *getpwnam(const char *); -->\n  <function name=\"getpwnam\">\n    <use-retval/>\n    <returnValue type=\"struct passwd *\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <warn severity=\"portability\">Non reentrant function 'getpwnam' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getpwnam_r'.</warn>\n  </function>\n  <!-- char *strtok(char *s, const char *ct); -->\n  <function name=\"strtok,std::strtok\">\n    <!-- Already configured in std.cfg. Add only a warning for POSIX that a\n    threadsafe function exists that should be used. -->\n    <warn severity=\"portability\">Non reentrant function 'strtok' called. For threadsafe applications it is recommended to use the reentrant replacement function 'strtok_r'.</warn>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/strtok.html -->\n  <!-- char *strtok_r(char *str, const char *delim, char **saveptr); -->\n  <function name=\"strtok_r\">\n    <!-- strtok may modify the first argument, so using the return value is not mandatory -->\n    <noreturn>false</noreturn>\n    <returnValue type=\"char *\"/>\n    <pure/>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"inout\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"3\" direction=\"inout\">\n      <not-null/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/getpwnam.html -->\n  <!-- int getpwnam_r(const char *name, struct passwd *pwd, char *buffer, size_t bufsize, struct passwd **result); -->\n  <function name=\"getpwnam_r\">\n    <use-retval/>\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"out\"/>\n    <arg nr=\"3\" direction=\"out\">\n      <minsize type=\"argvalue\" arg=\"4\"/>\n    </arg>\n    <arg nr=\"4\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"5\" direction=\"out\">\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- struct passwd *getpwuid(uid_t uid); -->\n  <function name=\"getpwuid\">\n    <use-retval/>\n    <returnValue type=\"struct passwd *\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <warn severity=\"portability\">Non reentrant function 'getpwuid' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getpwuid_r'.</warn>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/getpwuid.html -->\n  <!-- int getpwuid_r(uid_t uid, struct passwd *pwd, char *buffer, size_t bufsize, struct passwd **result); -->\n  <function name=\"getpwuid_r\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\" direction=\"out\"/>\n    <arg nr=\"3\" direction=\"out\">\n      <minsize type=\"argvalue\" arg=\"4\"/>\n    </arg>\n    <arg nr=\"4\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"5\" direction=\"out\">\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- void setpwent(void); -->\n  <function name=\"setpwent\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"void\"/>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/catclose.html -->\n  <!-- int catclose(nl_catd catd); -->\n  <function name=\"catclose\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/catgets.html -->\n  <!-- char *catgets(nl_catd catd, int set_id, int msg_id, const char *s); -->\n  <function name=\"catgets\">\n    <returnValue type=\"char *\"/>\n    <use-retval/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"4\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/catopen.html -->\n  <!-- nl_catd catopen(const char *name, int oflag); -->\n  <function name=\"catopen\">\n    <returnValue type=\"nl_catd\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/poll.h.html -->\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/poll.html -->\n  <!-- int poll(struct pollfd fds[], nfds_t nfds, int timeout); -->\n  <function name=\"poll\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\" direction=\"inout\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/regcomp.html -->\n  <!-- int regcomp(regex_t *restrict preg, const char *restrict pattern, int cflags); -->\n  <function name=\"regcomp\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\" direction=\"out\">\n      <not-null/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- size_t regerror(int errcode, const regex_t *restrict preg, char *restrict errbuf, size_t errbuf_size); -->\n  <function name=\"regerror\">\n    <returnValue type=\"size_t\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"3\" direction=\"out\">\n      <minsize type=\"argvalue\" arg=\"4\"/>\n    </arg>\n    <arg nr=\"4\" direction=\"in\">\n      <not-uninit/>\n      <valid>0:</valid>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int regexec(const regex_t *restrict preg, const char *restrict string, size_t nmatch, regmatch_t pmatch[restrict], int eflags); -->\n  <function name=\"regexec\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"4\" direction=\"out\"/>\n    <arg nr=\"5\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- void regfree(regex_t *preg); -->\n  <function name=\"regfree\">\n    <noreturn>false</noreturn>\n    <arg nr=\"1\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/sched_get_priority_max.html -->\n  <!-- int sched_get_priority_max(int policy); -->\n  <function name=\"sched_get_priority_max\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <use-retval/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int sched_get_priority_min(int policy); -->\n  <function name=\"sched_get_priority_min\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <use-retval/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/sched_getparam.html -->\n  <!-- int sched_getparam(pid_t pid, struct sched_param *param); -->\n  <function name=\"sched_getparam\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"2\" direction=\"out\">\n      <not-null/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/sched_getscheduler.html -->\n  <!-- int sched_getscheduler(pid_t pid); -->\n  <function name=\"sched_getscheduler\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/sched_rr_get_interval.html -->\n  <!-- int sched_rr_get_interval(pid_t pid, struct timespec *interval); -->\n  <function name=\"sched_rr_get_interval\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\" direction=\"out\">\n      <not-null/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/sched_setparam.html# -->\n  <!-- int sched_setparam(pid_t pid, const struct sched_param *param); -->\n  <function name=\"sched_setparam\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/sched_setscheduler.html -->\n  <!-- int sched_setscheduler(pid_t pid, int policy, const struct sched_param *param); -->\n  <function name=\"sched_setscheduler\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/sched_yield.html -->\n  <!-- int sched_yield(void); -->\n  <function name=\"sched_yield\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/009696799/functions/ecvt.html -->\n  <!-- char *ecvt(double value, int ndigit, int *restrict decpt, int *restrict sign);-->\n  <!--      LEGACY in POSIX.1-2001, removed in POSIX.1-2008-->\n  <function name=\"ecvt\">\n    <returnValue type=\"char *\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"3\" direction=\"out\">\n      <not-null/>\n    </arg>\n    <arg nr=\"4\" direction=\"out\">\n      <not-null/>\n      <not-bool/>\n    </arg>\n    <warn severity=\"style\" reason=\"Obsolescent\" alternatives=\"sprintf\"/>\n  </function>\n  <!-- char *fcvt(double value, int ndigit, int *restrict decpt, int *restrict sign);-->\n  <!--    LEGACY in POSIX.1-2001, removed in POSIX.1-2008-->\n  <function name=\"fcvt\">\n    <returnValue type=\"char *\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"3\" direction=\"out\">\n      <not-null/>\n    </arg>\n    <arg nr=\"4\" direction=\"out\">\n      <not-null/>\n      <not-bool/>\n    </arg>\n    <warn severity=\"style\" reason=\"Obsolescent\" alternatives=\"sprintf\"/>\n  </function>\n  <!-- char *gcvt(double value, int ndigit, char *buf);-->\n  <!--    LEGACY in POSIX.1-2001, removed in POSIX.1-2008-->\n  <function name=\"gcvt\">\n    <returnValue type=\"char *\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"3\" direction=\"out\">\n      <not-null/>\n      <not-bool/>\n    </arg>\n    <warn severity=\"style\" reason=\"Obsolescent\" alternatives=\"sprintf\"/>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/lseek.html -->\n  <!-- off_t lseek(int fildes, off_t offset, int whence); -->\n  <function name=\"lseek\">\n    <returnValue type=\"off_t\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int nanosleep(const struct timespec *rqtp, struct timespec *rmtp); -->\n  <function name=\"nanosleep\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n    </arg>\n    <arg nr=\"2\" direction=\"out\">\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- void setkey(const char *key); -->\n  <function name=\"setkey\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"void\"/>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n  </function>\n  <!-- char *getpass(const char *prompt); -->\n  <function name=\"getpass\">\n    <returnValue type=\"char *\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- http://pubs.opengroup.org/onlinepubs/009695399/basedefs/stdlib.h.html -->\n  <!-- double drand48(void); -->\n  <function name=\"drand48\">\n    <use-retval/>\n    <returnValue type=\"double\"/>\n    <noreturn>false</noreturn>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/putenv.html -->\n  <!-- int putenv(char *string); -->\n  <function name=\"putenv\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\">\n      <not-null/>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/setenv.html -->\n  <!-- int setenv(const char *envname, const char *envval, int overwrite); -->\n  <function name=\"setenv\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int unsetenv(const char *name); -->\n  <function name=\"unsetenv\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- struct tm * localtime(const time_t *tp); -->\n  <function name=\"localtime,std::localtime\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"struct tm *\"/>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <warn severity=\"portability\">Non reentrant function 'localtime' called. For threadsafe applications it is recommended to use the reentrant replacement function 'localtime_r'.</warn>\n  </function>\n  <!-- struct tm *localtime_r(const time_t *timep, struct tm *result); -->\n  <function name=\"localtime_r\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"struct tm *\"/>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"out\">\n      <not-null/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/readdir.html -->\n  <!-- struct dirent *readdir(DIR *dirp); -->\n  <function name=\"readdir\">\n    <returnValue type=\"struct dirent *\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\">\n      <not-null/>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <warn severity=\"portability\">Non reentrant function 'readdir' called. For threadsafe applications it is recommended to use the reentrant replacement function 'readdir_r'.</warn>\n  </function>\n  <!-- int readdir_r(DIR *dirp, struct dirent *entry, struct dirent **result); -->\n  <function name=\"readdir_r\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"out\">\n      <not-null/>\n    </arg>\n    <arg nr=\"3\" direction=\"out\">\n      <not-null/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/readlink.html -->\n  <!-- ssize_t readlink(const char *path, char *buf, size_t bufsiz); -->\n  <function name=\"readlink\">\n    <returnValue type=\"ssize_t\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"out\">\n      <not-null/>\n      <minsize type=\"argvalue\" arg=\"3\"/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n  </function>\n  <!-- int renameat(int olddirfd, const char *oldpath, int newdirfd, const char *newpath); -->\n  <function name=\"renameat\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"4\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n  </function>\n  <!-- int readlinkat(int dirfd, const char *pathname, char *buf, size_t bufsiz); -->\n  <function name=\"readlinkat\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"3\" direction=\"out\">\n      <not-null/>\n      <minsize type=\"argvalue\" arg=\"4\"/>\n    </arg>\n    <arg nr=\"4\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/asctime.html -->\n  <!-- char *asctime_r(const struct tm *tm, char *buf); -->\n  <function name=\"asctime_r\">\n    <returnValue type=\"char *\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"out\">\n      <not-null/>\n      <not-bool/>\n      <minsize type=\"value\" value=\"26\"/>\n    </arg>\n    <warn severity=\"style\" reason=\"Obsolescent\" alternatives=\"strftime\"/>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/ctime.html -->\n  <!-- char *ctime_r(const time_t *timep, char *buf); -->\n  <function name=\"ctime_r\">\n    <returnValue type=\"char *\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"out\">\n      <not-null/>\n      <not-bool/>\n      <minsize type=\"value\" value=\"26\"/>\n    </arg>\n    <warn severity=\"style\" reason=\"Obsolescent\" alternatives=\"strftime\"/>\n  </function>\n  <!-- struct tm *gmtime_r(const time_t *timep, struct tm *result); -->\n  <function name=\"gmtime_r\">\n    <returnValue type=\"struct tm *\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"out\">\n      <not-null/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/gmtime.html -->\n  <!-- struct tm * gmtime(const time_t *tp); -->\n  <function name=\"gmtime\">\n    <returnValue type=\"struct tm *\"/>\n    <use-retval/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <warn severity=\"portability\">Non reentrant function 'gmtime' called. For threadsafe applications it is recommended to use the reentrant replacement function 'gmtime_r'.</warn>\n  </function>\n  <!-- http://pubs.opengroup.org/onlinepubs/007908799/xsh/time.h.html -->\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/clock_settime.html -->\n  <!-- int clock_settime(clockid_t clock_id, const struct timespec *tp); -->\n  <function name=\"clock_settime\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int killpg(int pgrp, int sig); -->\n  <function name=\"killpg\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int kill(pid_t pid, int sig); -->\n  <function name=\"kill\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int clock_gettime(clockid_t clock_id, struct timespec *tp); -->\n  <function name=\"clock_gettime\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"out\">\n      <not-null/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int clock_getres(clockid_t clock_id, struct timespec *res); -->\n  <function name=\"clock_getres\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"out\">\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/tmpnam.html -->\n  <!-- char* tmpnam(char *s); -->\n  <function name=\"tmpnam,tmpnam_r\">\n    <returnValue type=\"char *\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"out\">\n      <not-bool/>\n    </arg>\n    <warn severity=\"style\" reason=\"Obsolescent\" alternatives=\"tmpfile,mkstemp,mkdtemp\"/>\n  </function>\n  <!-- void makecontext(ucontext_t *ucp, void (*func)(), int argc, ...); -->\n  <function name=\"makecontext\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\">\n      <not-null/>\n    </arg>\n    <arg nr=\"2\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"3\">\n      <not-bool/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"any\"/>\n    <warn severity=\"portability\">Obsolescent function 'makecontext' called. Applications are recommended to be rewritten to use POSIX threads.</warn>\n  </function>\n  <!-- void swapcontext(ucontext_t *restrict oucp, const ucontext_t *restrict ucp); -->\n  <function name=\"swapcontext\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\">\n      <not-null/>\n    </arg>\n    <arg nr=\"2\">\n      <not-null/>\n    </arg>\n    <warn severity=\"portability\">Obsolescent function 'swapcontext' called. Applications are recommended to be rewritten to use POSIX threads.</warn>\n  </function>\n  <!-- void getcontext(ucontext_t *ucp); -->\n  <function name=\"getcontext\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\">\n      <not-null/>\n    </arg>\n    <warn severity=\"portability\">Obsolescent function 'getcontext' called. Applications are recommended to be rewritten to use POSIX threads.</warn>\n  </function>\n  <!-- useconds_t ualarm(useconds_t useconds, useconds_t interval); -->\n  <function name=\"ualarm\">\n    <returnValue type=\"useconds_t\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <warn severity=\"style\" reason=\"Obsolescent\" alternatives=\"timer_create,timer_delete,timer_getoverrun,timer_gettime,timer_settime\"/>\n  </function>\n  <!-- double scalb(double x, double n); -->\n  <function name=\"scalb\">\n    <returnValue type=\"double\"/>\n    <use-retval/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <warn severity=\"style\" reason=\"Obsolescent\" alternatives=\"scalbln,scalblnf,scalbln,scalbn,scalbnf,scalbnl\"/>\n  </function>\n  <!-- void bcopy(const void *s1, void *s2, size_t n); -->\n  <function name=\"bcopy\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n      <minsize type=\"argvalue\" arg=\"3\"/>\n    </arg>\n    <arg nr=\"2\" direction=\"out\">\n      <not-null/>\n      <minsize type=\"argvalue\" arg=\"3\"/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n    <warn severity=\"style\" reason=\"Obsolescent\" alternatives=\"memcpy,memmove\"/>\n  </function>\n  <!-- int bcmp(const void *s1, const void *s2, size_t n); -->\n  <function name=\"bcmp\">\n    <use-retval/>\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n    <warn severity=\"style\" reason=\"Obsolescent\" alternatives=\"memcmp\"/>\n  </function>\n  <!-- void bzero(void *s, size_t n); -->\n  <function name=\"bzero\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"out\">\n      <not-null/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n    <warn severity=\"style\" reason=\"Obsolescent\" alternatives=\"memset\"/>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/007904875/functions/ftime.html -->\n  <!-- int ftime(struct timeb *tp); -->\n  <function name=\"ftime\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"out\">\n      <not-null/>\n      <not-bool/>\n    </arg>\n    <warn severity=\"style\" reason=\"Obsolescent\" alternatives=\"time,gettimeofday,clock_gettime\"/>\n  </function>\n  <!-- wchar_t *wcswcs(const wchar_t *ws1, const wchar_t *ws2); -->\n  <function name=\"wcswcs\">\n    <use-retval/>\n    <returnValue type=\"wchar_t *\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <warn severity=\"style\" reason=\"Obsolescent\" alternatives=\"wcsstr\"/>\n  </function>\n  <!-- char *stpcpy(char *desstr, const char *srcstr); -->\n  <function name=\"stpcpy\">\n    <returnValue type=\"char *\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"out\">\n      <not-null/>\n      <minsize type=\"strlen\" arg=\"2\"/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n      <strz/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- char *index(const char *s, int c); -->\n  <function name=\"index\">\n    <use-retval/>\n    <returnValue type=\"char *\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <warn severity=\"style\" reason=\"Obsolescent\" alternatives=\"strchr\"/>\n  </function>\n  <!-- char *rindex(const char *s, int c); -->\n  <function name=\"rindex\">\n    <use-retval/>\n    <returnValue type=\"char *\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <warn severity=\"style\" reason=\"Obsolescent\" alternatives=\"strrchr\"/>\n  </function>\n  <!-- sighandler_t bsd_signal(int signum, sighandler_t handler); -->\n  <function name=\"bsd_signal\">\n    <returnValue type=\"sighandler_t\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <warn severity=\"style\" reason=\"Obsolescent\" alternatives=\"sigaction\"/>\n  </function>\n  <!-- pid_t fork(void); -->\n  <function name=\"fork\">\n    <returnValue type=\"pid_t\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n  </function>\n  <!-- pid_t vfork(void); -->\n  <function name=\"vfork\">\n    <returnValue type=\"pid_t\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <warn severity=\"style\" reason=\"Obsolescent\" alternatives=\"fork\"/>\n  </function>\n  <!-- int pthread_atfork(void (*prepare)(void), void (*parent)(void), void (*child)(void)); -->\n  <function name=\"pthread_atfork\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"3\"/>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_cond_broadcast.html -->\n  <!-- int pthread_cond_signal(pthread_cond_t *cond);\n       int pthread_cond_broadcast(pthread_cond_t *cond); -->\n  <function name=\"pthread_cond_signal,pthread_cond_broadcast\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_create.html -->\n  <!-- int pthread_create(pthread_t * thread, const pthread_attr_t * attr, void *(*start_routine)(void*), void * arg); -->\n  <function name=\"pthread_create\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\" direction=\"out\">\n      <not-null/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\"/>\n    <arg nr=\"3\">\n      <not-null/>\n    </arg>\n    <arg nr=\"4\"/>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_detach.html -->\n  <!-- int pthread_detach(pthread_t thread); -->\n  <function name=\"pthread_detach\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_equal.html -->\n  <!-- int pthread_equal(pthread_t t1, pthread_t t2); -->\n  <function name=\"pthread_equal\">\n    <noreturn>false</noreturn>\n    <use-retval/>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n  </function>\n  <function name=\"pthread_exit\">\n    <noreturn>true</noreturn>\n    <arg nr=\"1\"/>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_join.html -->\n  <!-- int pthread_join(pthread_t thread, void **value_ptr); -->\n  <function name=\"pthread_join\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"out\">\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_kill.html -->\n  <!-- int pthread_kill(pthread_t thread, int sig); -->\n  <function name=\"pthread_kill\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_self.html -->\n  <!-- pthread_t pthread_self(void); -->\n  <function name=\"pthread_self\">\n    <noreturn>false</noreturn>\n    <use-retval/>\n    <returnValue type=\"pthread_t\"/>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_attr_destroy.html -->\n  <!-- int pthread_attr_destroy(pthread_attr_t *attr); -->\n  <function name=\"pthread_attr_destroy\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"inout\">\n      <not-null/>\n    </arg>\n  </function>\n  <!-- int pthread_attr_init(pthread_attr_t *attr); -->\n  <function name=\"pthread_attr_init\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"out\">\n      <not-null/>\n    </arg>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/009695399/functions/pthread_attr_getstackaddr.html -->\n  <!-- int pthread_attr_setstackaddr(pthread_attr_t *attr, void *stackaddr); -->\n  <function name=\"pthread_attr_setstackaddr\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\">\n      <not-null/>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <warn severity=\"style\" reason=\"Obsolescent\" alternatives=\"pthread_attr_setstack\"/>\n  </function>\n  <!-- int pthread_attr_getstackaddr(const pthread_attr_t *attr, void **stackaddr); -->\n  <function name=\"pthread_attr_getstackaddr\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\">\n      <not-null/>\n      <not-bool/>\n    </arg>\n    <warn severity=\"style\" reason=\"Obsolescent\" alternatives=\"pthread_attr_getstack\"/>\n  </function>\n  <!-- int pthread_attr_setstacksize(pthread_attr_t *attr, size_t stacksize); -->\n  <!-- int pthread_attr_setguardsize(pthread_attr_t *attr, size_t guardsize); -->\n  <function name=\"pthread_attr_setstacksize,pthread_attr_setguardsize\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"int\"/>\n    <leak-ignore/>\n    <arg nr=\"1\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n  </function>\n  <!-- int pthread_attr_getstacksize(const pthread_attr_t *attr, size_t *stacksize); -->\n  <!-- int pthread_attr_getguardsize(const pthread_attr_t *attr, size_t *guardsize); -->\n  <function name=\"pthread_attr_getstacksize,pthread_attr_getguardsize\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"int\"/>\n    <leak-ignore/>\n    <arg nr=\"1\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"out\">\n      <not-null/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutex_init.html -->\n  <!-- int pthread_mutex_init(pthread_mutex_t *restrict mutex, const pthread_mutexattr_t *restrict attr); -->\n  <function name=\"pthread_mutex_init\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"out\">\n      <not-null/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <!-- NULL is valid -->\n    </arg>\n  </function>\n  <!-- int pthread_mutex_destroy(pthread_mutex_t *mutex); -->\n  <function name=\"pthread_mutex_destroy\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"inout\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/pthread_mutex_lock.html -->\n  <!-- int pthread_mutex_lock(pthread_mutex_t *mutex); -->\n  <function name=\"pthread_mutex_lock\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"inout\">\n      <not-null/>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int pthread_mutex_trylock(pthread_mutex_t *mutex); -->\n  <function name=\"pthread_mutex_trylock\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"int\"/>\n    <use-retval/>\n    <arg nr=\"1\" direction=\"inout\">\n      <not-null/>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int pthread_mutex_unlock(pthread_mutex_t *mutex); -->\n  <function name=\"pthread_mutex_unlock\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"inout\">\n      <not-null/>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- char *tempnam(const char *dir, const char *pfx); -->\n  <function name=\"tempnam\">\n    <use-retval/>\n    <returnValue type=\"char *\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <strz/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <strz/>\n    </arg>\n    <warn severity=\"portability\">Non reentrant function 'tempnam' called. For threadsafe applications it is recommended to use the reentrant replacement function 'tempnam_r'.</warn>\n  </function>\n  <!-- char *crypt(const char *key, const char *salt); -->\n  <function name=\"crypt\">\n    <use-retval/>\n    <returnValue type=\"char *\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n      <strz/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n      <not-bool/>\n      <strz/>\n    </arg>\n    <warn severity=\"portability\">Non reentrant function 'crypt' called. For threadsafe applications it is recommended to use the reentrant replacement function 'crypt_r'.</warn>\n  </function>\n  <!-- char *ttyname(int fd); -->\n  <function name=\"ttyname\">\n    <use-retval/>\n    <returnValue type=\"char *\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <valid>0:</valid>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <warn severity=\"portability\">Non reentrant function 'ttyname' called. For threadsafe applications it is recommended to use the reentrant replacement function 'ttyname_r'.</warn>\n  </function>\n  <!-- int ttyname_r(int fd, char *buf, size_t buflen); -->\n  <function name=\"ttyname_r\">\n    <use-retval/>\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <valid>0:</valid>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\" direction=\"inout\">\n      <not-null/>\n      <not-uninit/>\n      <minsize type=\"argvalue\" arg=\"3\"/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n  </function>\n  <!-- struct spwd *getspnam(const char *name); -->\n  <function name=\"getspnam\">\n    <use-retval/>\n    <returnValue type=\"struct spwd *\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <warn severity=\"portability\">Non reentrant function 'getspnam' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getspnam_r'.</warn>\n  </function>\n  <!-- struct spwd *getspent(void); -->\n  <function name=\"getspent\">\n    <use-retval/>\n    <returnValue type=\"struct spwd *\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <warn severity=\"portability\">Non reentrant function 'getspent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getspent_r'.</warn>\n  </function>\n  <!-- struct spwd *fgetspent(FILE *fp); -->\n  <function name=\"fgetspent\">\n    <use-retval/>\n    <returnValue type=\"struct spwd *\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\">\n      <not-null/>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <warn severity=\"portability\">Non reentrant function 'fgetspent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'fgetspent_r'.</warn>\n  </function>\n  <!-- struct spwd *sgetspent(const char *s); -->\n  <function name=\"sgetspent\">\n    <use-retval/>\n    <returnValue type=\"struct spwd *\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <warn severity=\"portability\">Non reentrant function 'sgetspent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'sgetspent_r'.</warn>\n  </function>\n  <!-- struct passwd *fgetpwent(FILE *stream); -->\n  <function name=\"fgetpwent\">\n    <use-retval/>\n    <returnValue type=\"struct passwd *\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\">\n      <not-null/>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <warn severity=\"portability\">Non reentrant function 'fgetpwent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'fgetpwent_r'.</warn>\n  </function>\n  <!-- struct group *getgrent(void); -->\n  <function name=\"getgrent\">\n    <use-retval/>\n    <returnValue type=\"struct group *\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <warn severity=\"portability\">Non reentrant function 'getgrent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getgrent_r'.</warn>\n  </function>\n  <!-- int getgrent_r(struct group *gbuf, char *buf, size_t buflen, struct group **gbufp) -->\n  <function name=\"getgrent_r\">\n    <use-retval/>\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"out\"/>\n    <arg nr=\"2\" direction=\"out\">\n      <minsize type=\"argvalue\" arg=\"3\"/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"4\" direction=\"out\">\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- struct group *fgetgrent(FILE *stream); -->\n  <function name=\"fgetgrent\">\n    <use-retval/>\n    <returnValue type=\"struct group *\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\">\n      <not-null/>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <warn severity=\"portability\">Non reentrant function 'fgetgrent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'fgetgrent_r'.</warn>\n  </function>\n  <!-- int getnetgrent(char **host, char **user, char **domain); -->\n  <function name=\"getnetgrent\">\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"out\">\n      <not-null/>\n    </arg>\n    <arg nr=\"2\" direction=\"out\">\n      <not-null/>\n    </arg>\n    <arg nr=\"3\" direction=\"out\">\n      <not-null/>\n      <not-bool/>\n    </arg>\n    <warn severity=\"portability\">Non reentrant function 'getnetgrent' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getnetgrent_r'.</warn>\n  </function>\n  <!-- struct group *getgrnam(const char *name); -->\n  <function name=\"getgrnam\">\n    <use-retval/>\n    <returnValue type=\"struct group *\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <warn severity=\"portability\">Non reentrant function 'getgrnam' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getgrnam_r'.</warn>\n  </function>\n  <!-- struct group *getgrgid(gid_t gid); -->\n  <function name=\"getgrgid\">\n    <returnValue type=\"struct group *\"/>\n    <use-retval/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <warn severity=\"portability\">Non reentrant function 'getgrgid' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getgrgid_r'.</warn>\n  </function>\n  <!-- char *getlogin(void); -->\n  <function name=\"getlogin\">\n    <returnValue type=\"char *\"/>\n    <use-retval/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <warn severity=\"portability\">Non reentrant function 'getlogin' called. For threadsafe applications it is recommended to use the reentrant replacement function 'getlogin_r'.</warn>\n  </function>\n  <!-- char *ctermid(char *s); -->\n  <function name=\"ctermid\">\n    <returnValue type=\"char *\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"out\">\n      <not-bool/>\n    </arg>\n    <warn severity=\"portability\">Non reentrant function 'ctermid' called. For threadsafe applications it is recommended to use the reentrant replacement function 'ctermid_r'.</warn>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/realpath.html -->\n  <!-- char *realpath(const char *path, char *resolved_path); -->\n  <function name=\"realpath\">\n    <returnValue type=\"char *\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-null/>\n    </arg>\n    <arg nr=\"2\" direction=\"out\">\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- long telldir(DIR *dirp); -->\n  <function name=\"telldir\">\n    <returnValue type=\"long\"/>\n    <use-retval/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"inout\">\n      <not-null/>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- http://man7.org/linux/man-pages/man3/scandir.3.html -->\n  <!-- int scandir(const char *dirp, \n                    struct dirent ***namelist,\n                    int (*filter)(const struct dirent *),\n                    int (*compar)(const struct dirent **, const struct dirent **));-->\n  <function name=\"scandir\">\n    <use-retval/>\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"out\">\n      <not-null/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"4\" direction=\"in\">\n      <not-uninit/>\n      <not-null/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- http://man7.org/linux/man-pages/man3/fileno.3p.html -->\n  <!-- int fileno(FILE *stream); -->\n  <function name=\"fileno\">\n    <returnValue type=\"int\"/>\n    <use-retval/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"inout\">\n      <not-null/>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int fseeko(FILE *stream, off_t offset, int whence); -->\n  <function name=\"fseeko\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- off_t ftello(FILE *stream); -->\n  <function name=\"ftello\">\n    <use-retval/>\n    <returnValue type=\"off_t\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\">\n      <not-null/>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/exec.html -->\n  <!-- int execv(const char *path, char *const argv[]); \n       int execvp(const char *file, char *const argv[]); -->\n  <function name=\"execv,execvp\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n      <strz/>\n    </arg>\n    <arg nr=\"2\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- pid_t wait(int *stat_loc); -->\n  <function name=\"wait\">\n    <returnValue type=\"pid_t\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"out\">\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- pid_t waitpid(pid_t pid, int *stat_loc, int options); -->\n  <function name=\"waitpid\">\n    <returnValue type=\"pid_t\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\" direction=\"out\"/>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- see http://man7.org/linux/man-pages/man3/wcsnlen.3.html-->\n  <!-- size_t wcsnlen(const wchar_t *s, size_t maxlen);-->\n  <!-- see http://man7.org/linux/man-pages/man3/strnlen.3.html-->\n  <!-- size_t strnlen(const char *s, size_t maxlen); -->\n  <function name=\"strnlen,wcsnlen\">\n    <use-retval/>\n    <returnValue type=\"size_t\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n  </function>\n  <!-- http://man7.org/linux/man-pages/man3/ffs.3.html -->\n  <!-- int ffs(int i); -->\n  <function name=\"ffs\">\n    <returnValue type=\"int\"/>\n    <use-retval/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- http://pubs.opengroup.org/onlinepubs/9699919799/functions/shmctl.html -->\n  <!-- int shmctl(int shmid, int cmd, struct shmid_ds *buf); -->\n  <function name=\"shmctl\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"3\">\n      <!-- direction (in/out) depends on the value of arg2 \"cmd\" -->\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- http://pubs.opengroup.org/onlinepubs/009695399/functions/shmget.html -->\n  <!-- int shmget(key_t key, size_t size, int shmflg); -->\n  <function name=\"shmget\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- http://man7.org/linux/man-pages/man2/shmat.2.html -->\n  <!-- void *shmat(int shmid, const void *shmaddr, int shmflg); -->\n  <function name=\"shmat\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"void *\"/>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\"/>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- http://man7.org/linux/man-pages/man2/shmat.2.html -->\n  <!-- int shmdt(const void *shmaddr);-->\n  <function name=\"shmdt\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- http://man7.org/linux/man-pages/man2/setrlimit.2.html -->\n  <!-- int getrlimit(int resource, struct rlimit *rlim); -->\n  <function name=\"getrlimit\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\" direction=\"out\">\n      <not-null/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- http://man7.org/linux/man-pages/man2/setrlimit.2.html -->\n  <!-- int setrlimit(int resource, const struct rlimit *rlim); -->\n  <function name=\"setrlimit\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-null/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- http://man7.org/linux/man-pages/man3/glob.3.html -->\n  <!-- int glob(const char *pattern, int flags, int (*errfunc) (const char *epath, int eerrno), glob_t *pglob);-->\n  <function name=\"glob\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-null/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"4\" direction=\"out\">\n      <not-null/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- http://man7.org/linux/man-pages/man3/glob.3.html -->\n  <!--  void globfree(glob_t *pglob)-->\n  <function name=\"globfree\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"void\"/>\n    <arg nr=\"1\">\n      <not-uninit/>\n      <not-null/>\n    </arg>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/wcpncpy.html -->\n  <!-- http://man7.org/linux/man-pages/man3/wcpncpy.3.html -->\n  <!-- wchar_t *wcpncpy(wchar_t *dest, const wchar_t *src, size_t n); -->\n  <function name=\"wcpncpy\">\n    <returnValue type=\"wchar_t *\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"out\">\n      <not-null/>\n      <minsize type=\"argvalue\" arg=\"3\"/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n  </function>\n  <!-- http://man7.org/linux/man-pages/man3/stpncpy.3.html -->\n  <!-- char *stpncpy(char *dest, const char *src, size_t n); -->\n  <function name=\"stpncpy\">\n    <returnValue type=\"char *\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"out\">\n      <not-null/>\n      <minsize type=\"argvalue\" arg=\"3\"/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n  </function>\n  <!-- http://man7.org/linux/man-pages/man3/memccpy.3.html -->\n  <!-- void *memccpy(void *dest, const void *src, int c, size_t n);-->\n  <function name=\"memccpy\">\n    <leak-ignore/>\n    <returnValue type=\"void *\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\" direction=\"out\">\n      <not-null/>\n      <minsize type=\"sizeof\" arg=\"2\"/>\n      <minsize type=\"argvalue\" arg=\"4\"/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"4\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n  </function>\n  <!-- http://man7.org/linux/man-pages/man3/opterr.3.html-->\n  <!-- int getopt(int argc, char * const argv[], const char *optstring); -->\n  <function name=\"getopt\">\n    <leak-ignore/>\n    <noreturn>false</noreturn>\n    <returnValue type=\"int\"/>\n    <use-retval/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"2\">\n      <not-uninit/>\n      <not-null/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <not-null/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- http://man7.org/linux/man-pages/man2/setitimer.2.html-->\n  <!-- int getitimer(int which, struct itimerval *curr_value); -->\n  <function name=\"getitimer\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\" direction=\"out\">\n      <not-null/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- http://man7.org/linux/man-pages/man2/setitimer.2.html-->\n  <!-- int setitimer(int which, const struct itimerval *new_value, struct itimerval *old_value); -->\n  <function name=\"setitimer\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"3\" direction=\"out\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- http://man7.org/linux/man-pages/man2/sigaction.2.html -->\n  <!-- int sigaction(int signum, const struct sigaction *act, struct sigaction *oldact); -->\n  <function name=\"sigaction\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\"/>\n    <arg nr=\"3\" direction=\"out\">\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- http://pubs.opengroup.org/onlinepubs/9699919799/functions/sigaltstack.html -->\n  <!-- int sigaltstack(const stack_t *restrict ss, stack_t *restrict oss); -->\n  <function name=\"sigaltstack\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"out\">\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/siglongjmp.html -->\n  <!-- void siglongjmp(sigjmp_buf env, int val); -->\n  <function name=\"siglongjmp,_longjmp\">\n    <returnValue type=\"void\"/>\n    <noreturn>true</noreturn>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- http://pubs.opengroup.org/onlinepubs/9699919799/functions/sigsetjmp.html -->\n  <!-- int sigsetjmp(sigjmp_buf env, int savemask); -->\n  <function name=\"sigsetjmp,_setjmp\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\" direction=\"out\"/>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- int sigsuspend(const sigset_t *mask);-->\n  <function name=\"sigsuspend\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- http://pubs.opengroup.org/onlinepubs/9699919799/functions/sigprocmask.html -->\n  <!-- int pthread_sigmask(int how, const sigset_t *restrict set, sigset_t *restrict oset);\n\t\tint sigprocmask(int how, const sigset_t *restrict set, sigset_t *restrict oset); -->\n  <function name=\"pthread_sigmask,sigprocmask\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"3\" direction=\"out\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- pubs.opengroup.org/onlinepubs/9699919799/functions/sighold.html -->\n  <function name=\"sighold,sigignore,sigpause,sigrelse\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"int\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n  </function>\n  <function name=\"sigset\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"void*\"/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n    </arg>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/getrusage.html -->\n  <!-- http://man7.org/linux/man-pages/man2/getrusage.2.html-->\n  <!-- int getrusage(int who, struct rusage *usage);-->\n  <function name=\"getrusage\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\" direction=\"out\">\n      <not-null/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/sigemptyset.html -->\n  <!-- http://man7.org/linux/man-pages/man3/sigsetops.3.html -->\n  <!-- int sigemptyset(sigset_t *set); -->\n  <function name=\"sigemptyset\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"out\">\n      <not-null/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/sigfillset.html -->\n  <!-- http://man7.org/linux/man-pages/man3/sigsetops.3.html -->\n  <!-- int sigfillset(sigset_t *set); -->\n  <function name=\"sigfillset\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"out\">\n      <not-null/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/sigaddset.html -->\n  <!-- http://man7.org/linux/man-pages/man3/sigsetops.3.html -->\n  <!-- int sigaddset(sigset_t *set, int signum); -->\n  <function name=\"sigaddset\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"inout\">\n      <not-uninit/>\n      <not-null/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/sigdelset.html -->\n  <!-- http://man7.org/linux/man-pages/man3/sigsetops.3.html -->\n  <!-- int sigdelset(sigset_t *set, int signum);-->\n  <function name=\"sigdelset\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"inout\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- http://pubs.opengroup.org/onlinepubs/000095399/functions/sigismember.html -->\n  <!-- int sigismember(const sigset_t *set, int signum);-->\n  <function name=\"sigismember\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <use-retval/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_spawn.html -->\n  <!-- int posix_spawn(pid_t *restrict pid, const char *restrict path,\n                       const posix_spawn_file_actions_t *file_actions,\n                       const posix_spawnattr_t *restrict attrp,\n                       char *const argv[restrict], char *const envp[restrict]);\n       int posix_spawnp(pid_t *restrict pid, const char *restrict file,\n                       const posix_spawn_file_actions_t *file_actions,\n                       const posix_spawnattr_t *restrict attrp,\n                       char *const argv[restrict], char * const envp[restrict]); -->\n  <function name=\"posix_spawn,posix_spawnp\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"out\"/>\n    <arg nr=\"2\" direction=\"in\"/>\n    <arg nr=\"3\" direction=\"in\"/>\n    <arg nr=\"4\" direction=\"in\"/>\n    <arg nr=\"5\"/>\n    <arg nr=\"6\">\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/msgctl.html -->\n  <!-- int msgctl(int msqid, int cmd, struct msqid_ds *buf); -->\n  <function name=\"msgctl\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"3\">\n      <!-- direction (in/out) depends on the value of arg2 \"cmd\" -->\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/msgget.html -->\n  <!-- int msgget(key_t key, int msgflg);-->\n  <function name=\"msgget\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <use-retval/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/msgrcv.html -->\n  <!-- ssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,\n               int msgflg); -->\n  <function name=\"msgrcv\">\n    <returnValue type=\"ssize_t\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\" direction=\"out\">\n      <not-null/>\n      <minsize type=\"argvalue\" arg=\"3\"/>\n      <!-- TODO: sizeof(long) must be added to this value, but this can not be configured yet -->\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"4\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"5\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/msgsnd.html -->\n  <!-- int msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg); -->\n  <function name=\"msgsnd\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n      <minsize type=\"argvalue\" arg=\"3\"/>\n      <!-- TODO: sizeof(long) must be added to this value, but this can not be configured yet -->\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"4\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- http://man7.org/linux/man-pages/man3/tcflow.3p.html -->\n  <!-- int tcflow(int fildes, int action); -->\n  <function name=\"tcflow\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- http://man7.org/linux/man-pages/man3/tcflush.3p.html -->\n  <!-- int tcflush(int fildes, int queue_selector); -->\n  <function name=\"tcflush\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/tcsendbreak.html -->\n  <!-- http://man7.org/linux/man-pages/man3/tcsendbreak.3p.html -->\n  <!-- int tcsendbreak(int fildes, int duration); -->\n  <function name=\"tcsendbreak\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/tcgetattr.html -->\n  <!-- http://man7.org/linux/man-pages/man3/tcgetattr.3p.html -->\n  <!-- int tcgetattr(int fildes, struct termios *termios_p); -->\n  <function name=\"tcgetattr\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"2\" direction=\"out\">\n      <not-null/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- http://man7.org/linux/man-pages/man3/tcsetattr.3p.html -->\n  <!-- int tcsetattr(int fildes, int optional_actions, const struct termios *termios_p); -->\n  <function name=\"tcsetattr\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-null/>\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- http://man7.org/linux/man-pages/man3/cfsetospeed.3p.html -->\n  <!-- int cfsetospeed(struct termios *termios_p, speed_t speed); -->\n  <!-- http://man7.org/linux/man-pages/man3/cfsetispeed.3p.html -->\n  <!-- int cfsetispeed(struct termios *termios_p, speed_t speed); -->\n  <function name=\"cfsetospeed,cfsetispeed\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"inout\">\n      <not-uninit/>\n      <not-null/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- http://man7.org/linux/man-pages/man3/tcdrain.3p.html -->\n  <!-- int tcdrain(int fildes); -->\n  <function name=\"tcdrain\">\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n  </function>\n  <!-- These are defined as macros http://man7.org/linux/man-pages/man7/inode.7.html -->\n  <!-- It is better to configure them as functions -->\n  <function name=\"S_ISREG,S_ISDIR,S_ISCHR,S_ISBLK,S_ISFIFO,S_ISLNK,S_ISSOCK\">\n    <returnValue type=\"int\"/>\n    <use-retval/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/swab.html -->\n  <!-- void swab(const void * src, void* dest, ssize_t bytes); -->\n  <function name=\"swab\">\n    <returnValue type=\"void\"/>\n    <noreturn>false</noreturn>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <minsize type=\"argvalue\" arg=\"3\"/>\n    </arg>\n    <arg nr=\"2\" direction=\"out\">\n      <not-null/>\n      <minsize type=\"argvalue\" arg=\"3\"/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n  </function>\n  <!-- void sync(void); -->\n  <function name=\"sync\">\n    <returnValue type=\"void\"/>\n    <noreturn>false</noreturn>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/gethostname.html -->\n  <!-- int gethostname(char *name, size_t len); -->\n  <function name=\"gethostname\">\n    <noreturn>false</noreturn>\n    <returnValue type=\"int\"/>\n    <leak-ignore/>\n    <arg nr=\"1\" direction=\"out\">\n      <not-null/>\n      <minsize type=\"argvalue\" arg=\"2\"/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>1:</valid>\n    </arg>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/9699919799/functions/posix_memalign.html -->\n  <!-- int posix_memalign(void **memptr, size_t alignment, size_t size); -->\n  <function name=\"posix_memalign\">\n    <use-retval/>\n    <returnValue type=\"int\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\" direction=\"out\">\n      <not-null/>\n    </arg>\n    <arg nr=\"2\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n    </arg>\n    <arg nr=\"3\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n  </function>\n  <!-- https://pubs.opengroup.org/onlinepubs/7908799/xsh/valloc.html -->\n  <!-- void *valloc(size_t size); -->\n  <function name=\"valloc\">\n    <use-retval/>\n    <returnValue type=\"void *\"/>\n    <noreturn>false</noreturn>\n    <arg nr=\"1\" direction=\"in\">\n      <not-uninit/>\n      <not-bool/>\n      <valid>0:</valid>\n    </arg>\n    <warn severity=\"style\" alternatives=\"malloc,mmap\" reason=\"Obsolete\"/>\n  </function>\n  <memory>\n    <alloc init=\"false\" buffer-size=\"malloc\">valloc</alloc>\n    <dealloc>free</dealloc>\n  </memory>\n  <memory>\n    <alloc init=\"false\" arg=\"1\">posix_memalign</alloc>\n    <dealloc>free</dealloc>\n  </memory>\n  <memory>\n    <alloc init=\"false\" arg=\"2\">scandir</alloc>\n    <dealloc>free</dealloc>\n  </memory>\n  <memory>\n    <alloc init=\"true\" buffer-size=\"strdup\">strdup</alloc>\n    <alloc init=\"true\">strndup</alloc>\n    <alloc init=\"true\">wcsdup</alloc>\n    <dealloc>free</dealloc>\n  </memory>\n  <memory>\n    <alloc init=\"true\">mmap</alloc>\n    <alloc init=\"true\">mmap64</alloc>\n    <dealloc>munmap</dealloc>\n  </memory>\n  <resource>\n    <alloc init=\"true\">open</alloc>\n    <alloc init=\"true\">mkstemp</alloc>\n    <alloc init=\"true\">creat</alloc>\n    <alloc init=\"true\">openat</alloc>\n    <alloc init=\"true\">socket</alloc>\n    <dealloc>close</dealloc>\n  </resource>\n  <resource>\n    <alloc init=\"true\">opendir</alloc>\n    <alloc init=\"true\">fdopendir</alloc>\n    <dealloc>closedir</dealloc>\n  </resource>\n  <resource>\n    <alloc init=\"true\">fdopen</alloc>\n    <dealloc>fclose</dealloc>\n  </resource>\n  <resource>\n    <alloc init=\"true\">popen</alloc>\n    <dealloc>pclose</dealloc>\n  </resource>\n  <resource>\n    <alloc init=\"true\">mq_open</alloc>\n    <dealloc>mq_close</dealloc>\n  </resource>\n  <memory>\n    <alloc init=\"true\" arg=\"4\">getaddrinfo</alloc>\n    <dealloc>freeaddrinfo</dealloc>\n  </memory>\n  <!-- This type definitions refer to http://pubs.opengroup.org/onlinepubs/009695399/basedefs/sys/types.h.html-->\n  <podtype name=\"in_port_t\" sign=\"u\" size=\"2\"/>\n  <podtype name=\"in_addr_t\" sign=\"u\" size=\"4\"/>\n  <podtype name=\"nfds_t\" sign=\"u\"/>\n  <podtype name=\"socklen_t\" sign=\"u\" size=\"4\"/>\n  <podtype name=\"sa_family_t\" sign=\"u\" size=\"2\"/>\n  <podtype name=\"nlink_t\" sign=\"s\"/>\n  <podtype name=\"mode_t\" sign=\"s\"/>\n  <podtype name=\"pid_t\" sign=\"s\"/>\n  <podtype name=\"uid_t\" sign=\"s\"/>\n  <podtype name=\"gid_t\" sign=\"s\"/>\n  <podtype name=\"id_t\" sign=\"s\"/>\n  <podtype name=\"blkcnt_t\" sign=\"s\"/>\n  <podtype name=\"off_t\" sign=\"s\"/>\n  <podtype name=\"fsblkcnt_t\" sign=\"u\"/>\n  <podtype name=\"fsfilcnt_t\" sign=\"u\"/>\n  <podtype name=\"ino_t\" sign=\"u\"/>\n  <podtype name=\"useconds_t\" sign=\"u\"/>\n  <podtype name=\"suseconds_t\" sign=\"u\"/>\n  <podtype name=\"blksize_t\" sign=\"s\"/>\n  <podtype name=\"ssize_t\" sign=\"s\"/>\n  <!-- struct: <podtype name=\"dirent\"/> -->\n  <!-- struct: <podtype name=\"DIR\"/> -->\n  <podtype name=\"clockid_t\"/>\n  <podtype name=\"dev_t\"/>\n  <podtype name=\"key_t\"/>\n  <podtype name=\"tms\"/>\n  <!-- struct: <podtype name=\"utsname\"/> -->\n  <podtype name=\"pthread_attr_t\"/>\n  <podtype name=\"pthread_cond_t\"/>\n  <podtype name=\"pthread_condattr_t\"/>\n  <podtype name=\"pthread_key_t\"/>\n  <podtype name=\"pthread_mutexattr_t\"/>\n  <podtype name=\"pthread_mutex_t\"/>\n  <podtype name=\"pthread_barrier_t\"/>\n  <podtype name=\"pthread_barrierattr_t\"/>\n  <podtype name=\"pthread_once_t\"/>\n  <podtype name=\"pthread_rwlock_t\"/>\n  <podtype name=\"pthread_rwlockattr_t\"/>\n  <podtype name=\"pthread_spinlock_t\"/>\n  <podtype name=\"pthread_t\"/>\n  <podtype name=\"timer_t\"/>\n  <podtype name=\"trace_attr_t\"/>\n  <podtype name=\"trace_event_id_t\"/>\n  <podtype name=\"trace_event_set_t\"/>\n  <podtype name=\"trace_id_t\"/>\n  <podtype name=\"stat\"/>\n  <podtype name=\"sigjmp_buf\"/>\n  <podtype name=\"sigset_t\"/>\n  <podtype name=\"termios\"/>\n  <podtype name=\"intptr_t\"/>\n  <podtype name=\"timespec\"/>\n  <!-- struct: <podtype name=\"timeval\"/> -->\n  <podtype name=\"timezone\"/>\n  <!-- struct: <podtype name=\"sigaction\"/> -->\n  <podtype name=\"stack_t\"/>\n  <podtype name=\"mq_attr\"/>\n  <podtype name=\"mqd_t\"/>\n  <podtype name=\"datum\"/>\n  <podtype name=\"DBM\"/>\n  <podtype name=\"addrinfo\"/>\n  <podtype name=\"hostent\"/>\n  <podtype name=\"netent\"/>\n  <podtype name=\"protoent\"/>\n  <podtype name=\"servent\"/>\n  <podtype name=\"passwd\"/>\n  <podtype name=\"nl_catd\"/>\n  <podtype name=\"nl_item\"/>\n  <podtype name=\"regex_t\"/>\n  <podtype name=\"sched_param\"/>\n  <podtype name=\"glob_t\"/>\n  <podtype name=\"locale_t\"/>\n  <define name=\"MAP_FAILED\" value=\"-1\"/>\n  <define name=\"RTLD_LAZY\" value=\"0x01\"/>\n  <define name=\"RTLD_NOW\" value=\"0x02\"/>\n  <define name=\"RTLD_GLOBAL\" value=\"0x04\"/>\n  <define name=\"RTLD_LOCAL\" value=\"0x08\"/>\n  <define name=\"S_IFMT\" value=\"0170000\"/>\n  <define name=\"S_IFSOCK\" value=\"0140000\"/>\n  <define name=\"S_IFLNK\" value=\"0120000\"/>\n  <define name=\"S_IFREG\" value=\"0100000\"/>\n  <define name=\"S_IFBLK\" value=\"0060000\"/>\n  <define name=\"S_IFDIR\" value=\"0040000\"/>\n  <define name=\"S_IFCHR\" value=\"0020000\"/>\n  <define name=\"S_IFIFO\" value=\"0010000\"/>\n  <!-- see http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/signal.h.html \n       Some other signals are defined in std.cfg! -->\n  <define name=\"SIGHUP\" value=\"1\"/>\n  <define name=\"SIGQUIT\" value=\"3\"/>\n  <define name=\"SIGILL\" value=\"4\"/>\n  <define name=\"SIGTRAP\" value=\"5\"/>\n  <define name=\"SIGBUS\" value=\"7\"/>\n  <define name=\"SIGUSR1\" value=\"10\"/>\n  <define name=\"SIGUSR2\" value=\"12\"/>\n  <define name=\"SIGPIPE\" value=\"13\"/>\n  <define name=\"SIGALRM\" value=\"14\"/>\n  <define name=\"SIGCHLD\" value=\"17\"/>\n  <define name=\"SIGCONT\" value=\"18\"/>\n  <define name=\"SIGSTOP\" value=\"19\"/>\n  <define name=\"SIGTSTP\" value=\"20\"/>\n  <define name=\"SIGTTIN\" value=\"21\"/>\n  <define name=\"SIGTTOU\" value=\"22\"/>\n  <define name=\"SIGURG\" value=\"23\"/>\n  <define name=\"SIGXCPU\" value=\"24\"/>\n  <define name=\"SIGXFSZ\" value=\"25\"/>\n  <define name=\"SIGVTALRM\" value=\"26\"/>\n  <define name=\"SIGPROF\" value=\"27\"/>\n  <define name=\"SIGPOLL\" value=\"29\"/>\n  <define name=\"SIGSYS\" value=\"31\"/>\n</def>\n",
        "/tmp/vanessa/spack-stage/spack-stage-cppcheck-2.1-nuqkpwt6rmykw7pafaimnhmrhiu5lb4y/spack-src/test/testunusedvar.cpp": "/*\n * Cppcheck - A tool for static C/C++ code analysis\n * Copyright (C) 2007-2020 Cppcheck team.\n *\n * This program is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program.  If not, see <http://www.gnu.org/licenses/>.\n */\n\n#include \"checkunusedvar.h\"\n#include \"settings.h\"\n#include \"testsuite.h\"\n#include \"tokenize.h\"\n\n#include <string>\n\nclass TestUnusedVar : public TestFixture {\npublic:\n    TestUnusedVar() : TestFixture(\"TestUnusedVar\") {\n    }\n\nprivate:\n    Settings settings;\n\n    void run() OVERRIDE {\n        settings.addEnabled(\"style\");\n        settings.addEnabled(\"information\");\n        settings.checkLibrary = true;\n        LOAD_LIB_2(settings.library, \"std.cfg\");\n\n        TEST_CASE(emptyclass);  // #5355 - False positive: Variable is not assigned a value.\n        TEST_CASE(emptystruct);  // #5355 - False positive: Variable is not assigned a value.\n\n        TEST_CASE(structmember1);\n        TEST_CASE(structmember2);\n        TEST_CASE(structmember3);\n        TEST_CASE(structmember4);\n        TEST_CASE(structmember5);\n        TEST_CASE(structmember6);\n        TEST_CASE(structmember7);\n        TEST_CASE(structmember8);\n        TEST_CASE(structmember9);  // #2017 - struct is inherited\n        TEST_CASE(structmember_extern); // No false positives for extern structs\n        TEST_CASE(structmember10);\n        TEST_CASE(structmember11); // #4168 - initialization with {} / passed by address to unknown function\n        TEST_CASE(structmember12); // #7179 - FP unused structmember\n        TEST_CASE(structmember13); // #3088 - __attribute__((packed))\n        TEST_CASE(structmember14); // #6508 - (struct x){1,2,..}\n        TEST_CASE(structmember_sizeof);\n\n        TEST_CASE(localvar1);\n        TEST_CASE(localvar2);\n        TEST_CASE(localvar3);\n        TEST_CASE(localvar4);\n        TEST_CASE(localvar5);\n        TEST_CASE(localvar6);\n        TEST_CASE(localvar8);\n        TEST_CASE(localvar9); // ticket #1605\n        TEST_CASE(localvar10);\n        TEST_CASE(localvar11);\n        TEST_CASE(localvar12);\n        TEST_CASE(localvar13); // ticket #1640\n        TEST_CASE(localvar14); // ticket #5\n        TEST_CASE(localvar15);\n        TEST_CASE(localvar16); // ticket #1709\n        TEST_CASE(localvar17); // ticket #1720\n        TEST_CASE(localvar18); // ticket #1723\n        TEST_CASE(localvar19); // ticket #1776\n        TEST_CASE(localvar20); // ticket #1799\n        TEST_CASE(localvar21); // ticket #1807\n        TEST_CASE(localvar22); // ticket #1811\n        TEST_CASE(localvar23); // ticket #1808\n        TEST_CASE(localvar24); // ticket #1803\n        TEST_CASE(localvar25); // ticket #1729\n        TEST_CASE(localvar26); // ticket #1894\n        TEST_CASE(localvar27); // ticket #2160\n        TEST_CASE(localvar28); // ticket #2205\n        TEST_CASE(localvar29); // ticket #2206 (array initialization)\n        TEST_CASE(localvar30);\n        TEST_CASE(localvar31); // ticket #2286\n        TEST_CASE(localvar32); // ticket #2330\n        TEST_CASE(localvar33); // ticket #2346\n        TEST_CASE(localvar34); // ticket #2368\n        TEST_CASE(localvar35); // ticket #2535\n        TEST_CASE(localvar36); // ticket #2805\n        TEST_CASE(localvar37); // ticket #3078\n        TEST_CASE(localvar38);\n        TEST_CASE(localvar39); // ticket #3454\n        TEST_CASE(localvar40); // ticket #3473\n        TEST_CASE(localvar41); // ticket #3603\n        TEST_CASE(localvar42); // ticket #3742\n        TEST_CASE(localvar43); // ticket #3602\n        TEST_CASE(localvar44); // ticket #4020\n        TEST_CASE(localvar45); // ticket #4899\n        TEST_CASE(localvar46); // ticket #5491 (C++11 style initialization)\n        TEST_CASE(localvar47); // ticket #6603\n        TEST_CASE(localvar48); // ticket #6954\n        TEST_CASE(localvar49); // ticket #7594\n        TEST_CASE(localvar50); // ticket #6261 : dostuff(cond ? buf1 : buf2)\n        TEST_CASE(localvar51); // ticket #8128 - FN : tok = tok->next();\n        TEST_CASE(localvar52);\n        TEST_CASE(localvar53); // continue\n        TEST_CASE(localvar54); // ast, {}\n        TEST_CASE(localvar55);\n        TEST_CASE(localvar56);\n        TEST_CASE(localvar57); // #8974 - increment\n        TEST_CASE(localvarloops); // loops\n        TEST_CASE(localvaralias1);\n        TEST_CASE(localvaralias2); // ticket #1637\n        TEST_CASE(localvaralias3); // ticket #1639\n        TEST_CASE(localvaralias4); // ticket #1643\n        TEST_CASE(localvaralias5); // ticket #1647\n        TEST_CASE(localvaralias6); // ticket #1729\n        TEST_CASE(localvaralias7); // ticket #1732\n        TEST_CASE(localvaralias8);\n        TEST_CASE(localvaralias9); // ticket #1996\n        TEST_CASE(localvaralias10); // ticket #2004\n        TEST_CASE(localvaralias11); // ticket #4423 - iterator\n        TEST_CASE(localvaralias12); // ticket #4394\n        TEST_CASE(localvaralias13); // ticket #4487\n        TEST_CASE(localvaralias14); // ticket #5619\n        TEST_CASE(localvaralias15); // ticket #6315\n        TEST_CASE(localvaralias16);\n        TEST_CASE(localvaralias17); // ticket #8911\n        TEST_CASE(localvaralias18); // ticket #9234 - iterator\n        TEST_CASE(localvarasm);\n        TEST_CASE(localvarstatic);\n        TEST_CASE(localvarextern);\n        TEST_CASE(localvardynamic1);\n        TEST_CASE(localvardynamic2); // ticket #2904\n        TEST_CASE(localvardynamic3); // ticket #3467\n        TEST_CASE(localvararray1);  // ticket #2780\n        TEST_CASE(localvararray2);  // ticket #3438\n        TEST_CASE(localvararray3);  // ticket #3980\n        TEST_CASE(localvararray4);  // ticket #4839\n        TEST_CASE(localvararray5);  // ticket #7092\n        TEST_CASE(localvarstring1);\n        TEST_CASE(localvarstring2); // ticket #2929\n        TEST_CASE(localvarconst1);\n        TEST_CASE(localvarconst2);\n        TEST_CASE(localvarreturn); // ticket #9167\n        TEST_CASE(localvarmaybeunused);\n\n        TEST_CASE(localvarthrow); // ticket #3687\n\n        TEST_CASE(localVarStd);\n        TEST_CASE(localVarClass);\n\n        // Don't give false positives for variables in structs/unions\n        TEST_CASE(localvarStruct1);\n        TEST_CASE(localvarStruct2);\n        TEST_CASE(localvarStruct3);\n        TEST_CASE(localvarStruct5);\n        TEST_CASE(localvarStruct6);\n        TEST_CASE(localvarStruct7);\n        TEST_CASE(localvarStruct8);\n        TEST_CASE(localvarStruct9);\n        TEST_CASE(localvarStructArray);\n\n        TEST_CASE(localvarOp);          // Usage with arithmetic operators\n        TEST_CASE(localvarInvert);      // Usage with inverted variable\n        TEST_CASE(localvarIf);          // Usage in if\n        TEST_CASE(localvarIfElse);      // return tmp1 ? tmp2 : tmp3;\n        TEST_CASE(localvarOpAssign);    // a |= b;\n        TEST_CASE(localvarFor);         // for ( ; var; )\n        TEST_CASE(localvarForEach);     // #4155 - BOOST_FOREACH, hlist_for_each, etc\n        TEST_CASE(localvarShift1);      // 1 >> var\n        TEST_CASE(localvarShift3);      // x << y\n        TEST_CASE(localvarCast);\n        TEST_CASE(localvarClass);\n        TEST_CASE(localvarUnused);\n        TEST_CASE(localvarFunction); // ticket #1799\n        TEST_CASE(localvarIfNOT);    // #3104 - if ( NOT var )\n        TEST_CASE(localvarAnd);      // #3672\n        TEST_CASE(localvarSwitch);   // #3744 - false positive when localvar is used in switch\n        TEST_CASE(localvarNULL);     // #4203 - Setting NULL value is not redundant - it is safe\n        TEST_CASE(localvarUnusedGoto);    // #4447, #4558 goto\n        TEST_CASE(localvarRangeBasedFor); // #7075\n        TEST_CASE(localvarAssignInWhile);\n        TEST_CASE(localvarTemplate); // #4955 - variable is used as template parameter\n        TEST_CASE(localvarFuncPtr); // #7194\n        TEST_CASE(localvarAddr); // #7477\n        TEST_CASE(localvarDelete);\n        TEST_CASE(localvarLambda); // #8941, #8948\n\n        TEST_CASE(localvarCppInitialization);\n        TEST_CASE(localvarCpp11Initialization);\n\n        TEST_CASE(chainedAssignment); // #5466\n\n        TEST_CASE(crash1);\n        TEST_CASE(crash2);\n        TEST_CASE(usingNamespace);     // #4585\n\n        TEST_CASE(lambdaFunction); // #5078\n        TEST_CASE(namespaces); // #7557\n        TEST_CASE(bracesInitCpp11);// #7895 - \"int var{123}\" initialization\n\n        TEST_CASE(argument);\n        TEST_CASE(argumentClass);\n        TEST_CASE(escapeAlias); // #9150\n        TEST_CASE(volatileData); // #9280\n    }\n\n    void checkStructMemberUsage(const char code[]) {\n        // Clear the error buffer..\n        errout.str(\"\");\n\n        // Tokenize..\n        Tokenizer tokenizer(&settings, this);\n        std::istringstream istr(code);\n        tokenizer.tokenize(istr, \"test.cpp\");\n\n        // Check for unused variables..\n        CheckUnusedVar checkUnusedVar(&tokenizer, &settings, this);\n        checkUnusedVar.checkStructMemberUsage();\n    }\n\n    // #5355 - False positive: Variable is not assigned a value.\n    void emptyclass() {\n        functionVariableUsage(\"class Carla {\\n\"\n                              \"};\\n\"\n                              \"class Fred : Carla {\\n\"\n                              \"};\\n\"\n                              \"void foo() {\\n\"\n                              \"    Fred fred;\\n\"\n                              \"    throw fred;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    // #5355 - False positive: Variable is not assigned a value.\n    void emptystruct() {\n        functionVariableUsage(\"struct Fred {\\n\"\n                              \"};\\n\"\n                              \"void foo() {\\n\"\n                              \"    Fred fred;\\n\"\n                              \"    throw fred;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void structmember1() {\n        checkStructMemberUsage(\"struct abc\\n\"\n                               \"{\\n\"\n                               \"    int a;\\n\"\n                               \"    int b;\\n\"\n                               \"    int c;\\n\"\n                               \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) struct member 'abc::a' is never used.\\n\"\n                      \"[test.cpp:4]: (style) struct member 'abc::b' is never used.\\n\"\n                      \"[test.cpp:5]: (style) struct member 'abc::c' is never used.\\n\", errout.str());\n\n        checkStructMemberUsage(\"union abc\\n\"\n                               \"{\\n\"\n                               \"    int a;\\n\"\n                               \"    int b;\\n\"\n                               \"    int c;\\n\"\n                               \"};\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) union member 'abc::a' is never used.\\n\"\n                      \"[test.cpp:4]: (style) union member 'abc::b' is never used.\\n\"\n                      \"[test.cpp:5]: (style) union member 'abc::c' is never used.\\n\", errout.str());\n    }\n\n    void structmember2() {\n        checkStructMemberUsage(\"struct ABC\\n\"\n                               \"{\\n\"\n                               \"    int a;\\n\"\n                               \"    int b;\\n\"\n                               \"    int c;\\n\"\n                               \"};\\n\"\n                               \"\\n\"\n                               \"void foo()\\n\"\n                               \"{\\n\"\n                               \"    struct ABC abc;\\n\"\n                               \"    int a = abc.a;\\n\"\n                               \"    int b = abc.b;\\n\"\n                               \"    int c = abc.c;\\n\"\n                               \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void structmember3() {\n        checkStructMemberUsage(\"struct ABC\\n\"\n                               \"{\\n\"\n                               \"    int a;\\n\"\n                               \"    int b;\\n\"\n                               \"    int c;\\n\"\n                               \"};\\n\"\n                               \"\\n\"\n                               \"static struct ABC abc[] = { {1, 2, 3} };\\n\"\n                               \"\\n\"\n                               \"void foo()\\n\"\n                               \"{\\n\"\n                               \"    int a = abc[0].a;\\n\"\n                               \"    int b = abc[0].b;\\n\"\n                               \"    int c = abc[0].c;\\n\"\n                               \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void structmember4() {\n        checkStructMemberUsage(\"struct ABC\\n\"\n                               \"{\\n\"\n                               \"    const int a;\\n\"\n                               \"};\\n\"\n                               \"\\n\"\n                               \"void foo()\\n\"\n                               \"{\\n\"\n                               \"    ABC abc;\\n\"\n                               \"    if (abc.a == 2);\\n\"\n                               \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void structmember5() {\n        checkStructMemberUsage(\"struct AB\\n\"\n                               \"{\\n\"\n                               \"    int a;\\n\"\n                               \"    int b;\\n\"\n                               \"    void reset()\\n\"\n                               \"    {\\n\"\n                               \"        a = 1;\\n\"\n                               \"        b = 2;\\n\"\n                               \"    }\\n\"\n                               \"};\\n\"\n                               \"\\n\"\n                               \"void foo()\\n\"\n                               \"{\\n\"\n                               \"    struct AB ab;\\n\"\n                               \"    ab.reset();\\n\"\n                               \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void structmember6() {\n        checkStructMemberUsage(\"struct AB\\n\"\n                               \"{\\n\"\n                               \"    int a;\\n\"\n                               \"    int b;\\n\"\n                               \"};\\n\"\n                               \"\\n\"\n                               \"void foo(char *buf)\\n\"\n                               \"{\\n\"\n                               \"    struct AB *ab = (struct AB *)&buf[10];\\n\"\n                               \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        checkStructMemberUsage(\"struct AB\\n\"\n                               \"{\\n\"\n                               \"    int a;\\n\"\n                               \"    int b;\\n\"\n                               \"};\\n\"\n                               \"\\n\"\n                               \"void foo(char *buf)\\n\"\n                               \"{\\n\"\n                               \"    struct AB *ab = (AB *)&buf[10];\\n\"\n                               \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void structmember7() {\n        checkStructMemberUsage(\"struct AB\\n\"\n                               \"{\\n\"\n                               \"    int a;\\n\"\n                               \"    int b;\\n\"\n                               \"};\\n\"\n                               \"\\n\"\n                               \"void foo(struct AB *ab)\\n\"\n                               \"{\\n\"\n                               \"    ab->a = 0;\\n\"\n                               \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        checkStructMemberUsage(\"struct AB\\n\"\n                               \"{\\n\"\n                               \"    int a;\\n\"\n                               \"    int b;\\n\"\n                               \"};\\n\"\n                               \"\\n\"\n                               \"void foo(struct AB _shuge *ab)\\n\"\n                               \"{\\n\"\n                               \"    ab->a = 0;\\n\"\n                               \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void structmember8() {\n        checkStructMemberUsage(\"struct AB\\n\"\n                               \"{\\n\"\n                               \"    int a;\\n\"\n                               \"    int b;\\n\"\n                               \"};\\n\"\n                               \"\\n\"\n                               \"void foo(char *ab)\\n\"\n                               \"{\\n\"\n                               \"    ((AB *)ab)->b = 0;\\n\"\n                               \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void structmember9() {\n        checkStructMemberUsage(\"struct base {\\n\"\n                               \"    int a;\\n\"\n                               \"};\\n\"\n                               \"\\n\"\n                               \"struct derived : public base {\"\n                               \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void structmember10() {\n        // Fred may have some useful side-effects\n        checkStructMemberUsage(\"struct abc {\\n\"\n                               \"    Fred fred;\\n\"\n                               \"};\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void structmember11() { // #4168\n        checkStructMemberUsage(\"struct abc { int x; };\\n\"\n                               \"struct abc s = {0};\\n\"\n                               \"void f() { do_something(&s); }\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        checkStructMemberUsage(\"struct abc { int x; };\\n\"\n                               \"struct abc s = {0};\\n\"\n                               \"void f() { }\");\n        TODO_ASSERT_EQUALS(\"abc::x is not used\", \"\", errout.str());\n    }\n\n    void structmember12() { // #7179\n        checkStructMemberUsage(\"#include <stdio.h>\\n\"\n                               \"struct\\n\"\n                               \"{\\n\"\n                               \"    union\\n\"\n                               \"    {\\n\"\n                               \"        struct\\n\"\n                               \"        {\\n\"\n                               \"            int a;\\n\"\n                               \"        } struct1;\\n\"\n                               \"    };\\n\"\n                               \"} var = {0};\\n\"\n                               \"int main(int argc, char *argv[])\\n\"\n                               \"{\\n\"\n                               \"    printf(\\\"var.struct1.a = %d\\\", var.struct1.a);\\n\"\n                               \"    return 1;\\n\"\n                               \"}\\n\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void structmember13() { // #3088 - struct members required by hardware\n        checkStructMemberUsage(\"struct S {\\n\"\n                               \"  int x;\\n\"\n                               \"} __attribute__((packed));\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void structmember14() { // #6508\n        checkStructMemberUsage(\"struct bstr { char *bstart; size_t len; };\\n\"\n                               \"struct bstr bstr0(void) {\\n\"\n                               \"  return (struct bstr){\\\"hello\\\",6};\\n\"\n                               \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void structmember_extern() {\n        // extern struct => no false positive\n        checkStructMemberUsage(\"extern struct AB\\n\"\n                               \"{\\n\"\n                               \"    int a;\\n\"\n                               \"    int b;\\n\"\n                               \"} ab;\\n\"\n                               \"\\n\"\n                               \"void foo()\\n\"\n                               \"{\\n\"\n                               \"    ab.b = 0;\\n\"\n                               \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        // global linkage => no false positive\n        checkStructMemberUsage(\"struct AB\\n\"\n                               \"{\\n\"\n                               \"    int a;\\n\"\n                               \"    int b;\\n\"\n                               \"} ab;\\n\"\n                               \"\\n\"\n                               \"void foo()\\n\"\n                               \"{\\n\"\n                               \"    ab.b = 0;\\n\"\n                               \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        // static linkage => error message\n        checkStructMemberUsage(\"static struct AB\\n\"\n                               \"{\\n\"\n                               \"    int a;\\n\"\n                               \"    int b;\\n\"\n                               \"} ab;\\n\"\n                               \"\\n\"\n                               \"void foo()\\n\"\n                               \"{\\n\"\n                               \"    ab.b = 0;\\n\"\n                               \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) struct member 'AB::a' is never used.\\n\", errout.str());\n\n        checkStructMemberUsage(\"struct A\\n\"\n                               \"{\\n\"\n                               \"    static const int a = 0;\\n\"\n                               \"};\\n\"\n                               \"\\n\"\n                               \"int foo()\\n\"\n                               \"{\\n\"\n                               \"    return A::a;\\n\"\n                               \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void structmember_sizeof() {\n        checkStructMemberUsage(\"struct Header {\\n\"\n                               \"  uint8_t message_type;\\n\"\n                               \"}\\n\"\n                               \"\\n\"\n                               \"input.skip(sizeof(Header));\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        checkStructMemberUsage(\"struct Header {\\n\"\n                               \"  uint8_t message_type;\\n\"\n                               \"}\\n\"\n                               \"\\n\"\n                               \"input.skip(sizeof(struct Header));\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void functionVariableUsage(const char code[], const char filename[]=\"test.cpp\") {\n        // Clear the error buffer..\n        errout.str(\"\");\n\n        // Tokenize..\n        Tokenizer tokenizer(&settings, this);\n        std::istringstream istr(code);\n        if (!tokenizer.tokenize(istr, filename))\n            return;\n\n        // Check for unused variables..\n        CheckUnusedVar checkUnusedVar(&tokenizer, &settings, this);\n        checkUnusedVar.checkFunctionVariableUsage();\n    }\n\n    void localvar1() {\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int i = 0;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'i' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int i(0);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'i' is assigned a value that is never used.\\n\", errout.str());\n\n        // if a is undefined then Cppcheck can't determine if \"int i(a)\" is a\n        // * variable declaration\n        // * function declaration\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int i(a);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'i' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int j = 0;\\n\"\n                              \"    int i(j);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4]: (style) Variable 'i' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int j = 0;\\n\"\n                              \"    int & i = j;\\n\"\n                              \"    x(j);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4]: (style) Variable 'i' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int j = 0;\\n\"\n                              \"    const int & i = j;\\n\"\n                              \"    x(j);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4]: (style) Variable 'i' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int j = 0;\\n\"\n                              \"    int & i(j);\\n\"\n                              \"    x(j);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4]: (style) Variable 'i' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int j = 0;\\n\"\n                              \"    const int & i(j);\\n\"\n                              \"    x(j);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4]: (style) Variable 'i' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int * j = Data;\\n\"\n                              \"    int * i(j);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4]: (style) Variable 'i' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int * j = Data;\\n\"\n                              \"    const int * i(j);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4]: (style) Variable 'i' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    bool i = false;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'i' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    bool i = true;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'i' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    char *i;\\n\"\n                              \"    i = fgets();\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4]: (style) Variable 'i' is assigned a value that is never used.\\n\", errout.str());\n\n        // undefined variables are not reported because they may be classes with constructors\n        functionVariableUsage(\"undefined foo()\\n\"\n                              \"{\\n\"\n                              \"    undefined i = 0;\\n\"\n                              \"}\");\n        // ? ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"undefined foo()\\n\"\n                              \"{\\n\"\n                              \"    undefined i = 0;\\n\"\n                              \"}\\n\",\n                              \"test.c\");\n        ASSERT_EQUALS(\"[test.c:3]: (style) Variable 'i' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int i = undefined;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'i' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int * i = Data;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'i' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    void * i = Data;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'i' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    const void * i = Data;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'i' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    struct S * i = DATA;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'i' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    const struct S * i = DATA;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'i' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    struct S & i = j;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'i' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    const struct S & i = j;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'i' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    undefined * i = X;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'i' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int i = 0;\\n\"\n                              \"    int j = i;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4]: (style) Variable 'j' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int i[10] = { 0 };\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'i' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo(int n)\\n\"\n                              \"{\\n\"\n                              \"    int i[n] = { 0 };\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'i' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    char i[10] = \\\"123456789\\\";\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'i' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    char *i = \\\"123456789\\\";\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'i' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int i = 0;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'i' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int i = 0,code=10;\\n\"\n                              \"    for(i = 0; i < 10; i++) {\\n\"\n                              \"        std::cout<<code<<std::endl;\\n\"\n                              \"        code += 2;\\n\"\n                              \"    }\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int i = 0,code=10,d=10;\\n\"\n                              \"    for(i = 0; i < 10; i++) {\\n\"\n                              \"        std::cout<<code<<std::endl;\\n\"\n                              \"        code += 2;\\n\"\n                              \"        d = code;\\n\"\n                              \"    }\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'd' is assigned a value that is never used.\\n\"\n                      \"[test.cpp:7]: (style) Variable 'd' is assigned a value that is never used.\\n\",\n                      errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int i = 0,code=10,d=10;\\n\"\n                              \"    for(i = 0; i < 10; i++) {\\n\"\n                              \"        std::cout<<code<<std::endl;\\n\"\n                              \"        code += 2;\\n\"\n                              \"        g(d);\\n\"\n                              \"        d = code;\\n\"\n                              \"    }\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int i = 0,code=10,d=10;\\n\"\n                              \"    for(i = 0; i < 10; i++) {\\n\"\n                              \"        std::cout<<code<<std::endl;\\n\"\n                              \"        code += 2;\\n\"\n                              \"        if (i == 3) {\\n\"\n                              \"            return d;\\n\"\n                              \"        }\\n\"\n                              \"        d = code;\\n\"\n                              \"    }\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int i = 0,a=10,b=20;\\n\"\n                              \"    for(i = 0; i < 10; i++) {\\n\"\n                              \"        std::cout<<a<<std::endl;\\n\"\n                              \"        int tmp=a;\\n\"\n                              \"        a=b;\\n\"\n                              \"        b=tmp;\\n\"\n                              \"    }\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int code=10;\\n\"\n                              \"    while(code < 20) {\\n\"\n                              \"        std::cout<<code<<std::endl;\\n\"\n                              \"        code += 2;\\n\"\n                              \"    }\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int code=10,d=10;\\n\"\n                              \"    while(code < 20) {\\n\"\n                              \"        std::cout<<code<<std::endl;\\n\"\n                              \"        code += 2;\\n\"\n                              \"        d += code;\\n\"\n                              \"    }\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'd' is assigned a value that is never used.\\n\"\n                      \"[test.cpp:7]: (style) Variable 'd' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int code=10,d=10;\\n\"\n                              \"    while(code < 20) {\\n\"\n                              \"        std::cout<<code<<std::endl;\\n\"\n                              \"        code += 2;\\n\"\n                              \"        g(d);\\n\"\n                              \"        d += code;\\n\"\n                              \"    }\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int code=10,d=10;\\n\"\n                              \"    while(code < 20) {\\n\"\n                              \"        std::cout<<code<<std::endl;\\n\"\n                              \"        code += 2;\\n\"\n                              \"        if (i == 3) {\\n\"\n                              \"            return d;\\n\"\n                              \"        }\\n\"\n                              \"        d += code;\\n\"\n                              \"    }\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int a=10,b=20;\\n\"\n                              \"    while(a != 30) {\\n\"\n                              \"        std::cout<<a<<std::endl;\\n\"\n                              \"        int tmp=a;\\n\"\n                              \"        a=b;\\n\"\n                              \"        b=tmp;\\n\"\n                              \"    }\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int code=10;\\n\"\n                              \"    do {\\n\"\n                              \"        std::cout<<code<<std::endl;\\n\"\n                              \"        code += 2;\\n\"\n                              \"    } while(code < 20);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int code=10,d=10;\\n\"\n                              \"    do {\\n\"\n                              \"        std::cout<<code<<std::endl;\\n\"\n                              \"        code += 2;\\n\"\n                              \"        d += code;\\n\"\n                              \"    } while(code < 20);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'd' is assigned a value that is never used.\\n\"\n                      \"[test.cpp:7]: (style) Variable 'd' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int code=10,d=10;\\n\"\n                              \"    do {\\n\"\n                              \"        std::cout<<code<<std::endl;\\n\"\n                              \"        code += 2;\\n\"\n                              \"        g(d);\\n\"\n                              \"        d += code;\\n\"\n                              \"    } while(code < 20);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int code=10,d=10;\\n\"\n                              \"    do {\\n\"\n                              \"        std::cout<<code<<std::endl;\\n\"\n                              \"        code += 2;\\n\"\n                              \"        if (i == 3) {\\n\"\n                              \"            return d;\\n\"\n                              \"        }\\n\"\n                              \"        d += code;\\n\"\n                              \"    } while(code < 20);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int a=10,b=20;\\n\"\n                              \"    do {\\n\"\n                              \"        std::cout<<a<<std::endl;\\n\"\n                              \"        int tmp=a;\\n\"\n                              \"        a=b;\\n\"\n                              \"        b=tmp;\\n\"\n                              \"    } while( a!=30 );\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int code=10;\\n\"\n                              \"    for(int i=0; i < 10; i++) {\\n\"\n                              \"        if(true) {\\n\"\n                              \"            std::cout<<code<<std::endl;\\n\"\n                              \"            code += 2;\\n\"\n                              \"        }\\n\"\n                              \"    }\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int code=10;\\n\"\n                              \"    for(int i=0; i < 10; i++) {\\n\"\n                              \"        if(true) {\\n\"\n                              \"            std::cout<<code<<std::endl;\\n\"\n                              \"        }\\n\"\n                              \"        code += 2;\\n\"\n                              \"    }\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int code=10;\\n\"\n                              \"    while(code < 20) {\\n\"\n                              \"        if(true) {\\n\"\n                              \"            std::cout<<code<<std::endl;\\n\"\n                              \"            code += 2;\\n\"\n                              \"        }\\n\"\n                              \"    }\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int code=10;\\n\"\n                              \"    do {\\n\"\n                              \"        if(true) {\\n\"\n                              \"            std::cout<<code<<std::endl;\\n\"\n                              \"            code += 2;\\n\"\n                              \"        }\\n\"\n                              \"    } while(code < 20);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo(int j = 0) {\\n\" // #5985 - default function parameters should not affect checking results\n                              \"    int i = 0;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2]: (style) Variable 'i' is assigned a value that is never used.\\n\", errout.str());\n    }\n\n    void localvar2() {\n        functionVariableUsage(\"int foo()\\n\"\n                              \"{\\n\"\n                              \"    int i;\\n\"\n                              \"    return i;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'i' is not assigned a value.\\n\", errout.str());\n\n        functionVariableUsage(\"bool foo()\\n\"\n                              \"{\\n\"\n                              \"    bool i;\\n\"\n                              \"    return i;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'i' is not assigned a value.\\n\", errout.str());\n\n        // undefined variables are not reported because they may be classes with constructors\n        functionVariableUsage(\"undefined foo()\\n\"\n                              \"{\\n\"\n                              \"    undefined i;\\n\"\n                              \"    return i;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"undefined foo()\\n\"\n                              \"{\\n\"\n                              \"    undefined i;\\n\"\n                              \"    return i;\\n\"\n                              \"}\\n\",\n                              \"test.c\");\n        ASSERT_EQUALS(\"[test.c:3]: (style) Variable 'i' is not assigned a value.\\n\", errout.str());\n\n        functionVariableUsage(\"undefined *foo()\\n\"\n                              \"{\\n\"\n                              \"    undefined * i;\\n\"\n                              \"    return i;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'i' is not assigned a value.\\n\", errout.str());\n\n        functionVariableUsage(\"int *foo()\\n\"\n                              \"{\\n\"\n                              \"    int * i;\\n\"\n                              \"    return i;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'i' is not assigned a value.\\n\", errout.str());\n\n        functionVariableUsage(\"const int *foo()\\n\"\n                              \"{\\n\"\n                              \"    const int * i;\\n\"\n                              \"    return i;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'i' is not assigned a value.\\n\", errout.str());\n\n        functionVariableUsage(\"struct S *foo()\\n\"\n                              \"{\\n\"\n                              \"    struct S * i;\\n\"\n                              \"    return i;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'i' is not assigned a value.\\n\", errout.str());\n\n        functionVariableUsage(\"const struct S *foo()\\n\"\n                              \"{\\n\"\n                              \"    const struct S * i;\\n\"\n                              \"    return i;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'i' is not assigned a value.\\n\", errout.str());\n\n        // assume f() can write a\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int a[10];\\n\"\n                              \"    f(a[0]);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        // assume f() can write a\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int a[10];\\n\"\n                              \"    f(a[0], 0);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        // assume f() can write a\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int a[10];\\n\"\n                              \"    f(0, a[0]);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        // assume f() can write a\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int a[10];\\n\"\n                              \"    f(0, a[0], 0);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        // f() can not write a (not supported yet)\n        functionVariableUsage(\"void f(int i) { }\\n\"\n                              \"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int a[10];\\n\"\n                              \"    f(a[0]);\\n\"\n                              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:4]: (style) Variable 'a' is not assigned a value.\\n\",\n                           \"\", errout.str());\n\n        // f() can not write a (not supported yet)\n        functionVariableUsage(\"void f(const int & i) { }\\n\"\n                              \"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int a[10];\\n\"\n                              \"    f(a[0]);\\n\"\n                              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:4]: (style) Variable 'a' is not assigned a value.\\n\",\n                           \"\", errout.str());\n\n        // f() writes a\n        functionVariableUsage(\"void f(int & i) { }\\n\"\n                              \"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int a[10];\\n\"\n                              \"    f(a[0]);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void f(int * i);\\n\"\n                              \"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int a[10];\\n\"\n                              \"    f(a+1);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvar3() {\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int i;\\n\"\n                              \"    if ( abc )\\n\"\n                              \"        ;\\n\"\n                              \"    else i = 0;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6]: (style) Variable 'i' is assigned a value that is never used.\\n\", errout.str());\n    }\n\n    void localvar4() {\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int i = 0;\\n\"\n                              \"    f(i);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int i = 0;\\n\"\n                              \"    f(&i);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvar5() {\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int a = 0;\\n\"\n                              \"    b = (char)a;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvar6() {\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int b[10];\\n\"\n                              \"    for (int i=0;i<10;++i)\\n\"\n                              \"        b[i] = 0;\\n\"\n                              \"}\");\n        // TODO ASSERT_EQUALS(\"[test.cpp:5]: (style) Variable 'b' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int a = 0;\\n\"\n                              \"    int b[10];\\n\"\n                              \"    for (int i=0;i<10;++i)\\n\"\n                              \"        b[i] = ++a;\\n\"\n                              \"}\");\n        // TODO ASSERT_EQUALS(\"[test.cpp:6]: (style) Variable 'b' is assigned a value that is never used.\\n\", errout.str());\n    }\n\n    void localvar8() {\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int i;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Unused variable: i\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int i[2];\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Unused variable: i\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    void * i;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Unused variable: i\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    const void * i;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Unused variable: i\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    A * i;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Unused variable: i\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    struct A * i;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Unused variable: i\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    const struct A * i;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Unused variable: i\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int * i[2];\\n\"\n                              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:3]: (style) Unused variable: i\\n\", \"\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    const int * i[2];\\n\"\n                              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:3]: (style) Unused variable: i\\n\", \"\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    void * i[2];\\n\"\n                              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:3]: (style) Unused variable: i\\n\", \"\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    const void * i[2];\\n\"\n                              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:3]: (style) Unused variable: i\\n\", \"\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    struct A * i[2];\\n\"\n                              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:3]: (style) Unused variable: i\\n\", \"\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    const struct A * i[2];\\n\"\n                              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:3]: (style) Unused variable: i\\n\", \"\", errout.str());\n\n        functionVariableUsage(\"void foo(int n)\\n\"\n                              \"{\\n\"\n                              \"    int i[n];\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Unused variable: i\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int i = 0;\\n\"\n                              \"    int &j = i;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4]: (style) Variable 'j' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int i;\\n\"\n                              \"    int &j = i;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4]: (style) Variable 'j' is assigned a value that is never used.\\n\"\n                      \"[test.cpp:3]: (style) Unused variable: i\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int i;\\n\"\n                              \"    int &j = i;\\n\"\n                              \"    j = 0;\\n\"\n                              \"}\");\n        // TODO ASSERT_EQUALS(\"[test.cpp:5]: (style) Variable 'i' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"double foo()\\n\"\n                              \"{\\n\"\n                              \"    double i = 0.0;\\n\"\n                              \"    const double j = i;\\n\"\n                              \"    return j;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    A * i;\\n\"\n                              \"    i->f();\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    char * i;\\n\"\n                              \"    if (i);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    char * i = 0;\\n\"\n                              \"    if (i);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    char * i = new char[10];\\n\"\n                              \"    if (i);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    char *i;\\n\"\n                              \"    f(i);\\n\"\n                              \"}\");\n\n        functionVariableUsage(\"int a;\\n\"\n                              \"void foo()\\n\"\n                              \"{\\n\"\n                              \"    return &a;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"int a[10];\\n\"\n                              \"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int *p = a;\\n\"\n                              \"    for (int i = 0; i < 10; i++)\\n\"\n                              \"        p[i] = 0;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"int a[10];\\n\"\n                              \"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int *p = &a[0];\\n\"\n                              \"    for (int i = 0; i < 10; i++)\\n\"\n                              \"        p[i] = 0;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int a[10];\\n\"\n                              \"    int x;\\n\"\n                              \"    a[0] = 0;\\n\"\n                              \"    x = a[0];\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6]: (style) Variable 'x' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int a, b, c;\\n\"\n                              \"    a = b = c = f();\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4]: (style) Variable 'a' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"int * foo()\\n\"\n                              \"{\\n\"\n                              \"    return &undefined[0];\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvar9() {\n        // ticket #1605\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int a[10];\\n\"\n                              \"    for (int i = 0; i < 10; )\\n\"\n                              \"        a[i++] = 0;\\n\"\n                              \"}\");\n        // TODO ASSERT_EQUALS(\"[test.cpp:5]: (style) Variable 'a' is assigned a value that is never used.\\n\", errout.str());\n    }\n\n    void localvar10() {\n        functionVariableUsage(\"void foo(int x)\\n\"\n                              \"{\\n\"\n                              \"    int i;\\n\"\n                              \"    if (x) {\\n\"\n                              \"        int i;\\n\"\n                              \"    } else {\\n\"\n                              \"        int i;\\n\"\n                              \"    }\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Unused variable: i\\n\"\n                      \"[test.cpp:5]: (style) Unused variable: i\\n\"\n                      \"[test.cpp:7]: (style) Unused variable: i\\n\", errout.str());\n\n        functionVariableUsage(\"void foo(int x)\\n\"\n                              \"{\\n\"\n                              \"    int i;\\n\"\n                              \"    if (x)\\n\"\n                              \"        int i;\\n\"\n                              \"    else\\n\"\n                              \"        int i;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Unused variable: i\\n\"\n                      \"[test.cpp:5]: (style) Unused variable: i\\n\"\n                      \"[test.cpp:7]: (style) Unused variable: i\\n\", errout.str());\n\n        functionVariableUsage(\"void foo(int x)\\n\"\n                              \"{\\n\"\n                              \"    int i;\\n\"\n                              \"    if (x) {\\n\"\n                              \"        int i;\\n\"\n                              \"    } else {\\n\"\n                              \"        int i = 0;\\n\"\n                              \"    }\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:7]: (style) Variable 'i' is assigned a value that is never used.\\n\"\n                      \"[test.cpp:3]: (style) Unused variable: i\\n\"\n                      \"[test.cpp:5]: (style) Unused variable: i\\n\", errout.str());\n\n        functionVariableUsage(\"void foo(int x)\\n\"\n                              \"{\\n\"\n                              \"    int i;\\n\"\n                              \"    if (x) {\\n\"\n                              \"        int i;\\n\"\n                              \"    } else {\\n\"\n                              \"        int i;\\n\"\n                              \"    }\\n\"\n                              \"    i = 1;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:9]: (style) Variable 'i' is assigned a value that is never used.\\n\"\n                      \"[test.cpp:5]: (style) Unused variable: i\\n\"\n                      \"[test.cpp:7]: (style) Unused variable: i\\n\", errout.str());\n    }\n\n    void localvar11() {\n        functionVariableUsage(\"void foo(int x)\\n\"\n                              \"{\\n\"\n                              \"    int a = 0;\\n\"\n                              \"    if (x == 1)\\n\"\n                              \"    {\\n\"\n                              \"        a = 123;\\n\"    // redundant assignment\n                              \"        return;\\n\"\n                              \"    }\\n\"\n                              \"    x = a;\\n\"  // redundant assignment\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6]: (style) Variable 'a' is assigned a value that is never used.\\n\"\n                      \"[test.cpp:9]: (style) Variable 'x' is assigned a value that is never used.\\n\", errout.str());\n\n        // The variable 'a' is initialized. But the initialized value is\n        // never used. It is only initialized for security reasons.\n        functionVariableUsage(\"void foo(int x)\\n\"\n                              \"{\\n\"\n                              \"    int a = 0;\\n\"\n                              \"    if (x == 1)\\n\"\n                              \"        a = 123;\\n\"\n                              \"    else if (x == 2)\\n\"\n                              \"        a = 456;\\n\"\n                              \"    else\\n\"\n                              \"        return;\\n\"\n                              \"    x = a;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:10]: (style) Variable 'x' is assigned a value that is never used.\\n\", errout.str());\n    }\n\n    void localvar12() {\n        // ticket #1574\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int a, b, c, d, e, f;\\n\"\n                              \"    a = b = c = d = e = f = 15;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\n            \"[test.cpp:4]: (style) Variable 'a' is assigned a value that is never used.\\n\"\n            \"[test.cpp:4]: (style) Variable 'b' is assigned a value that is never used.\\n\"\n            \"[test.cpp:4]: (style) Variable 'c' is assigned a value that is never used.\\n\"\n            \"[test.cpp:4]: (style) Variable 'd' is assigned a value that is never used.\\n\"\n            \"[test.cpp:4]: (style) Variable 'e' is assigned a value that is never used.\\n\"\n            \"[test.cpp:4]: (style) Variable 'f' is assigned a value that is never used.\\n\",\n            errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int a, b, c = 0;\\n\"\n                              \"    a = b = c;\\n\"\n                              \"\\n\"\n                              \"}\");\n\n        TODO_ASSERT_EQUALS(\n            \"[test.cpp:4]: (style) Variable 'a' is assigned a value that is never used.\\n\"\n            \"[test.cpp:4]: (style) Variable 'b' is assigned a value that is never used.\\n\"\n            \"[test.cpp:3]: (style) Variable 'c' is assigned a value that is never used.\\n\",\n\n            \"[test.cpp:4]: (style) Variable 'a' is assigned a value that is never used.\\n\"\n            \"[test.cpp:4]: (style) Variable 'b' is assigned a value that is never used.\\n\",\n            errout.str());\n    }\n\n    void localvar13() { // ticket #1640\n        functionVariableUsage(\"void foo( OBJECT *obj )\\n\"\n                              \"{\\n\"\n                              \"    int x;\\n\"\n                              \"    x = obj->ySize / 8;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4]: (style) Variable 'x' is assigned a value that is never used.\\n\", errout.str());\n    }\n\n    void localvar14() {\n        // ticket #5\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int a[10];\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Unused variable: a\\n\", errout.str());\n    }\n\n    void localvar15() {\n        functionVariableUsage(\"int foo()\\n\"\n                              \"{\\n\"\n                              \"    int a = 5;\\n\"\n                              \"    int b[a];\\n\"\n                              \"    b[0] = 0;\\n\"\n                              \"    return b[0];\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"int foo()\\n\"\n                              \"{\\n\"\n                              \"    int a = 5;\\n\"\n                              \"    int * b[a];\\n\"\n                              \"    b[0] = &c;\\n\"\n                              \"    return *b[0];\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"int * foo()\\n\"\n                              \"{\\n\"\n                              \"    int a = 5;\\n\"\n                              \"    const int * b[a];\\n\"\n                              \"    b[0] = &c;\\n\"\n                              \"    return b[0];\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"struct B * foo()\\n\"\n                              \"{\\n\"\n                              \"    int a = 5;\\n\"\n                              \"    struct B * b[a];\\n\"\n                              \"    b[0] = &c;\\n\"\n                              \"    return b[0];\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"const struct B * foo()\\n\"\n                              \"{\\n\"\n                              \"    int a = 5;\\n\"\n                              \"    const struct B * b[a];\\n\"\n                              \"    b[0] = &c;\\n\"\n                              \"    return b[0];\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvar16() { // ticket #1709\n        functionVariableUsage(\"int foo()\\n\"\n                              \"{\\n\"\n                              \"    char buf[5];\\n\"\n                              \"    char *ptr = buf;\\n\"\n                              \"    *(ptr++) = 0;\\n\"\n                              \"}\");\n        // TODO ASSERT_EQUALS(\"[test.cpp:5]: (style) Variable 'buf' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"int foo()\\n\"\n                              \"{\\n\"\n                              \"    char buf[5];\\n\"\n                              \"    char *ptr = buf - 1;\\n\"\n                              \"    *(++ptr) = 0;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'buf' is not assigned a value.\\n\", errout.str());\n\n        // #3910\n        functionVariableUsage(\"int foo() {\\n\"\n                              \"    char buf[5];\\n\"\n                              \"    char *data[2];\\n\"\n                              \"    data[0] = buf;\\n\"\n                              \"    do_something(data);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"int foo() {\\n\"\n                              \"    char buf1[5];\\n\"\n                              \"    char buf2[5];\\n\"\n                              \"    char *data[2];\\n\"\n                              \"    data[0] = buf1;\\n\"\n                              \"    data[1] = buf2;\\n\"\n                              \"    do_something(data);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvar17() { // ticket #1720\n        // Don't crash when checking the code below!\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    struct DATA *data = DATA;\\n\"\n                              \"    char *k = data->req;\\n\"\n                              \"    char *ptr;\\n\"\n                              \"    char *line_start;\\n\"\n                              \"    ptr = data->buffer;\\n\"\n                              \"    line_start = ptr;\\n\"\n                              \"    data->info = k;\\n\"\n                              \"    line_start = ptr;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:10]: (style) Variable 'line_start' is assigned a value that is never used.\\n\", errout.str());\n    }\n\n    void localvar18() { // ticket #1723\n        functionVariableUsage(\"A::A(int iValue) {\\n\"\n                              \"    UserDefinedException* pe = new UserDefinedException();\\n\"\n                              \"    throw pe;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvar19() { // ticket #1776\n        functionVariableUsage(\"void foo() {\\n\"\n                              \"    int a[10];\\n\"\n                              \"    int c;\\n\"\n                              \"    c = *(a);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4]: (style) Variable 'c' is assigned a value that is never used.\\n\"\n                      \"[test.cpp:2]: (style) Variable 'a' is not assigned a value.\\n\", errout.str());\n    }\n\n    void localvar20() { // ticket #1799\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    char c1 = 'c';\\n\"\n                              \"    char c2[] = { c1 };\\n\"\n                              \"    a(c2);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvar21() { // ticket #1807\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    char buffer[1024];\\n\"\n                              \"    bar((void *)buffer);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvar22() { // ticket #1811\n        functionVariableUsage(\"int foo(int u, int v)\\n\"\n                              \"{\\n\"\n                              \"    int h, i;\\n\"\n                              \"    h = 0 ? u : v;\\n\"\n                              \"    i = 1 ? u : v;\\n\"\n                              \"    return h + i;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvar23() { // ticket #1808\n        functionVariableUsage(\"int foo(int c)\\n\"\n                              \"{\\n\"\n                              \"    int a;\\n\"\n                              \"    int b[10];\\n\"\n                              \"    a = b[c] = 0;\\n\"\n                              \"    return a;\\n\"\n                              \"}\");\n        // TODO ASSERT_EQUALS(\"[test.cpp:5]: (style) Variable 'b' is assigned a value that is never used.\\n\", errout.str());\n    }\n\n    void localvar24() { // ticket #1803\n        functionVariableUsage(\"class MyException\\n\"\n                              \"{\\n\"\n                              \"    virtual void raise() const\\n\"\n                              \"    {\\n\"\n                              \"        throw *this;\\n\"\n                              \"    }\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvar25() { // ticket #1729\n        functionVariableUsage(\"int main() {\\n\"\n                              \"    int ppos = 1;\\n\"\n                              \"    int pneg = 0;\\n\"\n                              \"    const char*edge = ppos? \\\" +\\\" : pneg ? \\\" -\\\" : \\\"\\\";\\n\"\n                              \"    printf(\\\"This should be a '+' -> %s\\n\\\", edge);\\n\"\n                              \"    return 0;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvar26() { // ticket #1894\n        functionVariableUsage(\"int main() {\\n\"\n                              \"    const Fred &fred = getfred();\\n\"\n                              \"    int *p = fred.x();\\n\"\n                              \"    *p = 0;\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvar27() { // ticket #2160\n        functionVariableUsage(\"void f(struct s *ptr) {\\n\"\n                              \"    int param = 1;\\n\"\n                              \"    ptr->param = param++;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvar28() { // ticket #2205\n        functionVariableUsage(\"void f(char* buffer, int value) {\\n\"\n                              \"    char* pos = buffer;\\n\"\n                              \"    int size = value;\\n\"\n                              \"    *(int*)pos = size;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvar29() { // ticket #2206\n        functionVariableUsage(\"void f() {\\n\"\n                              \"    float s_ranges[] = { 0, 256 };\\n\"\n                              \"    float* ranges[] = { s_ranges };\\n\"\n                              \"    cout << ranges[0][0];\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvar30() { // ticket #2264\n        functionVariableUsage(\"void f() {\\n\"\n                              \"    Engine *engine = e;\\n\"\n                              \"    x->engine = engine->clone();\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvar31() { // ticket #2286\n        functionVariableUsage(\"void f() {\\n\"\n                              \"    int x = 0;\\n\"\n                              \"    a.x = x - b;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvar32() {\n        // ticket #2330 - fstream >> x\n        functionVariableUsage(\"void f() {\\n\"\n                              \"    int x;\\n\"\n                              \"    fstream &f = getfile();\\n\"\n                              \"    f >> x;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        // ticket #4596 - if (c >>= x) {}\n        functionVariableUsage(\"void f(int x) {\\n\"\n                              \"    C c;\\n\" // possibly some stream class\n                              \"    if (c >>= x) {}\\n\"\n                              \"}\");\n        // TODO ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void f(int x) {\\n\"\n                              \"    C c;\\n\"\n                              \"    if (c >>= x) {}\\n\"\n                              \"}\", \"test.c\");\n        ASSERT_EQUALS(\"[test.c:3]: (style) Variable 'c' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void f(int c) {\\n\"\n                              \"    int x;\\n\"\n                              \"    if (c >> x) {}\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2]: (style) Variable 'x' is not assigned a value.\\n\", errout.str());\n\n        functionVariableUsage(\"void f() {\\n\"\n                              \"    int x, y;\\n\"\n                              \"    std::cin >> x >> y;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        // ticket #8494\n        functionVariableUsage(\"void f(C c) {\\n\"\n                              \"  int x;\\n\"\n                              \"  c & x;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void f(int c) {\\n\"\n                              \"  int x;\\n\"\n                              \"  c & x;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2]: (style) Variable 'x' is not assigned a value.\\n\", errout.str());\n    }\n\n    void localvar33() { // ticket #2345\n        functionVariableUsage(\"void f() {\\n\"\n                              \"    Abc* abc = getabc();\\n\"\n                              \"    while (0 != (abc = abc->next())) {\\n\"\n                              \"        ++nOldNum;\\n\"\n                              \"    }\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvar34() { // ticket #2368\n        functionVariableUsage(\"void f() {\\n\"\n                              \"    int i = 0;\\n\"\n                              \"    if (false) {\\n\"\n                              \"    } else {\\n\"\n                              \"        j -= i;\\n\"\n                              \"    }\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvar35() { // ticket #2535\n        functionVariableUsage(\"void f() {\\n\"\n                              \"    int a, b;\\n\"\n                              \"    x(1,a,b);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvar36() { // ticket #2805\n        functionVariableUsage(\"int f() {\\n\"\n                              \"    int a, b;\\n\"\n                              \"    a = 2 * (b = 3);\\n\"\n                              \"    return a + b;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"int f() {\\n\" // ticket #4318\n                              \"    int a,b;\\n\"\n                              \"    x(a, b=2);\\n\"  // <- if param2 is passed-by-reference then b might be used in x\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"int foo() {\\n\" // ticket #6147\n                              \"    int a = 0;\\n\"\n                              \"    bar(a=a+2);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"int foo() {\\n\" // ticket #6147\n                              \"    int a = 0;\\n\"\n                              \"    bar(a=2);\\n\"\n                              \"}\");\n        TODO_ASSERT_EQUALS(\"error\", \"\", errout.str());\n\n        functionVariableUsage(\"void bar(int);\\n\"\n                              \"int foo() {\\n\"\n                              \"    int a = 0;\\n\"\n                              \"    bar(a=a+2);\\n\"\n                              \"}\");\n        TODO_ASSERT_EQUALS(\"error\", \"\", errout.str());\n    }\n\n    void localvar37() { // ticket #3078\n        functionVariableUsage(\"void f() {\\n\"\n                              \"    int a = 2;\\n\"\n                              \"    ints.at(a) = 0;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvar38() {\n        functionVariableUsage(\"std::string f() {\\n\"\n                              \"    const char code[] = \\\"foo\\\";\\n\"\n                              \"    const std::string s1(sizeof_(code));\\n\"\n                              \"    const std::string s2 = sizeof_(code);\\n\"\n                              \"    return(s1+s2);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvar39() {\n        functionVariableUsage(\"void f() {\\n\"\n                              \"    int a = 1;\\n\"\n                              \"    foo(x*a);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvar40() {\n        functionVariableUsage(\"int f() {\\n\"\n                              \"    int a = 1;\\n\"\n                              \"    return x & a;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvar41() {\n        // #3603 - false positive 'x is assigned a value that is never used'\n        functionVariableUsage(\"int f() {\\n\"\n                              \"    int x = 1;\\n\"\n                              \"    int y = FOO::VALUE * x;\\n\"\n                              \"    return y;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvar42() { // #3742\n        functionVariableUsage(\"float g_float = 1;\\n\"\n                              \"extern void SomeTestFunc(float);\\n\"\n                              \"void MyFuncError()\\n\"\n                              \"{\\n\"\n                              \"    const float floatA = 2.2f;\\n\"\n                              \"    const float floatTot = g_float * floatA;\\n\"\n                              \"    SomeTestFunc(floatTot);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"float g_float = 1;\\n\"\n                              \"extern void SomeTestFunc(float);\\n\"\n                              \"void MyFuncNoError()\\n\"\n                              \"{\\n\"\n                              \"    const float floatB = 2.2f;\\n\"\n                              \"    const float floatTot = floatB * g_float;\\n\"\n                              \"    SomeTestFunc(floatTot);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"float g_float = 1;\\n\"\n                              \"extern void SomeTestFunc(float);\\n\"\n                              \"void MyFuncNoError2()\\n\"\n                              \"{\\n\"\n                              \"    const float floatC = 2.2f;\\n\"\n                              \"    float floatTot = g_float * floatC;\\n\"\n                              \"    SomeTestFunc(floatTot);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvar43() { // ticket #3602 (false positive)\n        functionVariableUsage(\"void bar()\\n\"\n                              \"{\\n\"\n                              \"    int * piArray = NULL;\\n\"\n                              \"    unsigned int uiArrayLength = 2048;\\n\"\n                              \"    unsigned int uiIndex;\\n\"\n                              \"\\n\"\n                              \"    try\\n\"\n                              \"    {\\n\"\n                              \"        piArray = new int[uiArrayLength];\\n\" // Allocate memory\n                              \"    }\\n\"\n                              \"    catch (...)\\n\"\n                              \"    {\\n\"\n                              \"        SOME_MACRO\\n\"\n                              \"        delete [] piArray;\\n\"\n                              \"        return;\\n\"\n                              \"    }\\n\"\n                              \"    for (uiIndex = 0; uiIndex < uiArrayLength; uiIndex++)\\n\"\n                              \"    {\\n\"\n                              \"        piArray[uiIndex] = -1234;\\n\"\n                              \"    }\\n\"\n                              \"    delete [] piArray;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvar44() { // #4020 - FP\n        functionVariableUsage(\"void func() {\\n\"\n                              \"    int *sp_mem[2] = { global1, global2 };\\n\"\n                              \"    sp_mem[0][3] = 123;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvar45() { // #4899 - FP\n        functionVariableUsage(\"int func() {\\n\"\n                              \"    int a = 123;\\n\"\n                              \"    int b = (short)-a;;\\n\"\n                              \"    return b;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvar46() { // #5491/#5494/#6301\n        functionVariableUsage(\"int func() {\\n\"\n                              \"    int i = 0;\\n\"\n                              \"    int j{i};\\n\"\n                              \"    return j;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"int func() {\\n\"\n                              \"    std::mutex m;\\n\"\n                              \"    std::unique_lock<std::mutex> l{ m };\\n\"\n                              \"    return 0;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"int func() {\\n\"\n                              \"    std::shared_lock<std::shared_timed_mutex> lock( m );\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvar47() { // #6603\n        functionVariableUsage(\"void f() {\\n\"\n                              \"    int (SfxUndoManager::*retrieveCount)(bool) const\\n\"\n                              \"        = (flag) ? &SfxUndoManager::foo : &SfxUndoManager::bar;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'retrieveCount' is assigned a value that is never used.\\n\", errout.str());\n    }\n\n    void localvar48() { // #6954\n        functionVariableUsage(\"void foo() {\\n\"\n                              \"  long (*pKoeff)[256] = new long[9][256];\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvar49() { // #7594\n        functionVariableUsage(\"class A {\\n\"\n                              \"    public:\\n\"\n                              \"        typedef enum { ID1,ID2,ID3 } Id_t;\\n\"\n                              \"        typedef struct {Id_t id; std::string a; } x_t;\\n\"\n                              \"        std::vector<x_t> m_vec;\\n\"\n                              \"        std::vector<x_t> Get(void);\\n\"\n                              \"        void DoSomething();\\n\"\n                              \"};\\n\"\n                              \"std::vector<A::x_t> A::Get(void) {\\n\"\n                              \"    return m_vec;\\n\"\n                              \"}\\n\"\n                              \"const std::string Bar() {\\n\"\n                              \"    return \\\"x\\\";\\n\"\n                              \"}\\n\"\n                              \"void A::DoSomething(void) {\\n\"\n                              \"    const std::string x = Bar();\\n\"  // <- warning\n                              \"}\");\n        // TODO ASSERT_EQUALS(\"[test.cpp:16]: (style) Variable 'x' is assigned a value that is never used.\\n\", errout.str());\n    }\n\n    void localvar50() { // #6261, #6542\n        // #6261 - ternary operator in function call\n        functionVariableUsage(\"void foo() {\\n\"\n                              \"  char buf1[10];\\n\"\n                              \"  dostuff(cond?buf1:buf2);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo() {\\n\"\n                              \"  char buf1[10];\\n\"\n                              \"  dostuff(cond?buf2:buf1);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        // #6542 - ternary operator\n        functionVariableUsage(\"void foo(int c) {\\n\"\n                              \"  char buf1[10], buf2[10];\\n\"\n                              \"  char *p = c ? buf1 : buf2;\\n\"\n                              \"  dostuff(p);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvar51() { // #8128 FN\n        functionVariableUsage(\"void foo() {\\n\"\n                              \"  const char *tok = var->nameToken();\\n\"\n                              \"  tok = tok->next();\\n\"  // read+write\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'tok' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo() {\\n\"\n                              \"  int x = 4;\\n\"\n                              \"  x = 15 + x;\\n\"  // read+write\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'x' is assigned a value that is never used.\\n\", errout.str());\n    }\n\n    void localvar52() {\n        functionVariableUsage(\"void foo() {\\n\"\n                              \"  std::vector<int> data;\\n\"\n                              \"  data[2] = 32;\\n\"\n                              \"  return data;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvar53() {\n        functionVariableUsage(\"void foo() {\\n\"\n                              \"  bool x = false;\\n\"\n                              \"  while (loop) {\\n\"\n                              \"    if (a) {\\n\"\n                              \"      x = true;\\n\" // unused value\n                              \"      continue;\\n\"\n                              \"    }\\n\"\n                              \"  }\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2]: (style) Variable 'x' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo() {\\n\"\n                              \"  bool x = false;\\n\"\n                              \"  while (loop) {\\n\"\n                              \"    if (a) {\\n\"\n                              \"      x = true;\\n\"\n                              \"      continue;\\n\"\n                              \"    }\\n\"\n                              \"  }\\n\"\n                              \"  return x;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvar54() {\n        functionVariableUsage(\"Padding fun() {\\n\"\n                              \"  Distance d = DISTANCE;\\n\"\n                              \"  return (Padding){ d, d, d, d };\\n\"\n                              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvar55() {\n        functionVariableUsage(\"void f(int mode) {\\n\"\n                              \"    int x = 0;\\n\" // <- redundant assignment\n                              \"\\n\"\n                              \"    for (int i = 0; i < 10; i++) {\\n\"\n                              \"        if (mode == 0x04)\\n\"\n                              \"            x = 0;\\n\" // <- redundant assignment\n                              \"        if (mode == 0x0f) {\\n\"\n                              \"            x = address;\\n\"\n                              \"            data[x] = 0;\\n\"\n                              \"        }\\n\"\n                              \"    }\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2]: (style) Variable 'x' is assigned a value that is never used.\\n\"\n                      \"[test.cpp:6]: (style) Variable 'x' is assigned a value that is never used.\\n\",\n                      errout.str());\n    }\n\n    void localvar56() {\n        functionVariableUsage(\"void f()\\n\"\n                              \"{\\n\"\n                              \"    int x = 31;\\n\"\n                              \"    mask[x] |= 123;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvar57() {\n        functionVariableUsage(\"void f()\\n\"\n                              \"{\\n\"\n                              \"    int x = 0;\\n\"\n                              \"    x++;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4]: (style) Variable 'x' is assigned a value that is never used.\\n\", errout.str());\n    }\n\n    void localvarloops() {\n        // loops\n        functionVariableUsage(\"void fun() {\\n\"\n                              \"  int x;\\n\"\n                              \"  while (c) { x=10; }\\n\"\n                              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'x' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void dostuff(int x);\\n\"\n                              \"void fun() {\\n\"\n                              \"  int x = 1;\\n\"\n                              \"  while (c) {\\n\"\n                              \"    dostuff(x);\\n\"\n                              \"    if (y) { x=10; break; }\\n\"\n                              \"  }\\n\"\n                              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:6]: (style) Variable 'x' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void dostuff(int &x);\\n\"\n                              \"void fun() {\\n\"\n                              \"  int x = 1;\\n\"\n                              \"  while (c) {\\n\"\n                              \"    dostuff(x);\\n\"\n                              \"    if (y) { x=10; break; }\\n\"\n                              \"  }\\n\"\n                              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout.str()); // TODO : in this special case we can ignore that x is aliased. x is local and there are no function calls after the assignment\n\n        functionVariableUsage(\"void fun() {\\n\"\n                              \"  int x = 0;\\n\"\n                              \"  while (c) {\\n\"\n                              \"    dostuff(x);\\n\"\n                              \"    x = 10;\\n\"\n                              \"  }\\n\"\n                              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void fun() {\\n\"\n                              \"  int x = 0;\\n\"\n                              \"  while (x < 10) { x = x + 1; }\\n\"\n                              \"}\\n\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void fun()\\n\"\n                              \"{\\n\"\n                              \"    int   status = 0;\\n\"\n                              \"    for (ind = 0; ((ind < nrArgs) && (status < 10)); ind++)\\n\"\n                              \"        status = x;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void f()\\n\"\n                              \"{\\n\"\n                              \"    int sum = 0U;\\n\"\n                              \"    for (i = 0U; i < 2U; i++)\\n\"\n                              \"        sum += 123;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'sum' is assigned a value that is never used.\\n\"\n                      \"[test.cpp:5]: (style) Variable 'sum' is assigned a value that is never used.\\n\", errout.str());\n    }\n\n    void localvaralias1() {\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int a;\\n\"\n                              \"    int *b = &a;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4]: (style) Variable 'b' is assigned a value that is never used.\\n\"\n                      \"[test.cpp:3]: (style) Unused variable: a\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int a[10];\\n\"\n                              \"    int *b = a;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4]: (style) Variable 'b' is assigned a value that is never used.\\n\"\n                      \"[test.cpp:3]: (style) Unused variable: a\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int a;\\n\"\n                              \"    int *b = &a;\\n\"\n                              \"    *b = 0;\\n\"\n                              \"}\");\n        // TODO ASSERT_EQUALS(\"[test.cpp:5]: (style) Variable 'a' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int a;\\n\"\n                              \"    char *b = (char *)&a;\\n\"\n                              \"    *b = 0;\\n\"\n                              \"}\");\n        // TODO ASSERT_EQUALS(\"[test.cpp:5]: (style) Variable 'a' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int a;\\n\"\n                              \"    char *b = (char *)(&a);\\n\"\n                              \"    *b = 0;\\n\"\n                              \"}\");\n        // TODO ASSERT_EQUALS(\"[test.cpp:5]: (style) Variable 'a' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int a;\\n\"\n                              \"    const char *b = (const char *)&a;\\n\"\n                              \"    *b = 0;\\n\"\n                              \"}\");\n        // TODO ASSERT_EQUALS(\"[test.cpp:5]: (style) Variable 'a' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int a;\\n\"\n                              \"    const char *b = (const char *)(&a);\\n\"\n                              \"    *b = 0;\\n\"\n                              \"}\");\n        // TODO ASSERT_EQUALS(\"[test.cpp:5]: (style) Variable 'a' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int a;\\n\"\n                              \"    char *b = static_cast<char *>(&a);\\n\"\n                              \"    *b = 0;\\n\"\n                              \"}\");\n        // TODO ASSERT_EQUALS(\"[test.cpp:5]: (style) Variable 'a' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int a;\\n\"\n                              \"    const char *b = static_cast<const char *>(&a);\\n\"\n                              \"    *b = 0;\\n\"\n                              \"}\");\n        // TODO ASSERT_EQUALS(\"[test.cpp:5]: (style) Variable 'a' is assigned a value that is never used.\\n\", errout.str());\n\n        // a is not a local variable and b is aliased to it\n        functionVariableUsage(\"int a;\\n\"\n                              \"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int *b = &a;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4]: (style) Variable 'b' is assigned a value that is never used.\\n\", errout.str());\n\n        // a is not a local variable and b is aliased to it\n        functionVariableUsage(\"void foo(int a)\\n\"\n                              \"{\\n\"\n                              \"    int *b = &a;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'b' is assigned a value that is never used.\\n\", errout.str());\n\n        // a is not a local variable and b is aliased to it\n        functionVariableUsage(\"class A\\n\"\n                              \"{\\n\"\n                              \"    int a;\\n\"\n                              \"    void foo()\\n\"\n                              \"    {\\n\"\n                              \"        int *b = &a;\\n\"\n                              \"    }\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:6]: (style) Variable 'b' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"int a;\\n\"\n                              \"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int *b = &a;\\n\"\n                              \"    *b = 0;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo(int a)\\n\"\n                              \"{\\n\"\n                              \"    int *b = &a;\\n\"\n                              \"    *b = 0;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"class A\\n\"\n                              \"{\\n\"\n                              \"    int a;\\n\"\n                              \"    void foo()\\n\"\n                              \"    {\\n\"\n                              \"        int *b = &a;\\n\"\n                              \"        *b = 0;\\n\"\n                              \"    }\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int a[10];\\n\"\n                              \"    int *b = a;\\n\"\n                              \"    *b = 0;\\n\"\n                              \"}\");\n        // TODO ASSERT_EQUALS(\"[test.cpp:5]: (style) Variable 'a' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int a[10];\\n\"\n                              \"    char *b = (char *)a;\\n\"\n                              \"    *b = 0;\\n\"\n                              \"}\");\n        // TODO ASSERT_EQUALS(\"[test.cpp:5]: (style) Variable 'a' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int a[10];\\n\"\n                              \"    char *b = (char *)(a);\\n\"\n                              \"    *b = 0;\\n\"\n                              \"}\");\n        // TODO ASSERT_EQUALS(\"[test.cpp:5]: (style) Variable 'a' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int a[10];\\n\"\n                              \"    const char *b = (const char *)a;\\n\"\n                              \"    *b = 0;\\n\"\n                              \"}\");\n        // TODO ASSERT_EQUALS(\"[test.cpp:5]: (style) Variable 'a' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int a[10];\\n\"\n                              \"    const char *b = (const char *)(a);\\n\"\n                              \"    *b = 0;\\n\"\n                              \"}\");\n        // TODO ASSERT_EQUALS(\"[test.cpp:5]: (style) Variable 'a' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int a[10];\\n\"\n                              \"    char *b = static_cast<char *>(a);\\n\"\n                              \"    *b = 0;\\n\"\n                              \"}\");\n        // TODO ASSERT_EQUALS(\"[test.cpp:5]: (style) Variable 'a' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int a[10];\\n\"\n                              \"    const char *b = static_cast<const char *>(a);\\n\"\n                              \"    *b = 0;\\n\"\n                              \"}\");\n        // TODO ASSERT_EQUALS(\"[test.cpp:5]: (style) Variable 'a' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"int a[10];\\n\"\n                              \"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int *b = a;\\n\"\n                              \"    *b = 0;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"int a[10];\\n\"\n                              \"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int *b = a;\\n\"\n                              \"    int *c = b;\\n\"\n                              \"    *c = 0;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int *b = a;\\n\"\n                              \"    int *c = b;\\n\"\n                              \"    *c = 0;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int *b = a;\\n\"\n                              \"    int *c = b;\\n\"\n                              \"    *c = b[0];\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int *b = a;\\n\"\n                              \"    int *c;\\n\"\n                              \"    *c = b[0];\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4]: (style) Variable 'c' is not assigned a value.\\n\", errout.str());\n\n        functionVariableUsage(\"int a[10];\\n\"\n                              \"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int *b = a;\\n\"\n                              \"    int c = b[0];\\n\"\n                              \"    x(c);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int *b = a;\\n\"\n                              \"    int c = b[0];\\n\"\n                              \"    x(c);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"int a[10];\\n\"\n                              \"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int *b = &a[0];\\n\"\n                              \"    a[0] = b[0];\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int *b = &a[0];\\n\"\n                              \"    a[0] = b[0];\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int *b = a;\\n\"\n                              \"    a[0] = b[0];\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo(int a[10])\\n\"\n                              \"{\\n\"\n                              \"    int *b = a;\\n\"\n                              \"    *b = 0;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"class A\\n\"\n                              \"{\\n\"\n                              \"    int a[10];\\n\"\n                              \"    void foo()\\n\"\n                              \"    {\\n\"\n                              \"        int *b = a;\\n\"\n                              \"        *b = 0;\\n\"\n                              \"    }\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int a[10];\\n\"\n                              \"    int *b = a;\\n\"\n                              \"    int *c = b;\\n\"\n                              \"    *c = 0;\\n\"\n                              \"}\");\n        // TODO ASSERT_EQUALS(\"[test.cpp:6]: (style) Variable 'a' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int a[10];\\n\"\n                              \"    int b[10];\\n\"\n                              \"    int *c = a;\\n\"\n                              \"    int *d = b;\\n\"\n                              \"    *d = 0;\\n\"\n                              \"}\");\n        // TODO ASSERT_EQUALS(\"[test.cpp:3]: (style) Unused variable: a\\n\"\n        // TODO               \"[test.cpp:7]: (style) Variable 'b' is assigned a value that is never used.\\n\"\n        // TODO               \"[test.cpp:5]: (style) Variable 'c' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int a[10];\\n\"\n                              \"    int b[10];\\n\"\n                              \"    int *c = a;\\n\"\n                              \"    c = b;\\n\"\n                              \"    *c = 0;\\n\"\n                              \"}\");\n        // TODO ASSERT_EQUALS(\"[test.cpp:3]: (style) Unused variable: a\\n\"\n        // TODO               \"[test.cpp:7]: (style) Variable 'b' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int a[10];\\n\"\n                              \"    int b[10];\\n\"\n                              \"    int *c = a;\\n\"\n                              \"    c = b;\\n\"\n                              \"    *c = 0;\\n\"\n                              \"    c = a;\\n\"\n                              \"    *c = 0;\\n\"\n                              \"}\");\n        // TODO ASSERT_EQUALS(\"[test.cpp:9]: (style) Variable 'a' is assigned a value that is never used.\\n\"\n        // TODO               \"[test.cpp:7]: (style) Variable 'b' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int a[10], * b = a + 10;\\n\"\n                              \"    b[-10] = 1;\\n\"\n                              \"}\");\n        // TODO ASSERT_EQUALS(\"[test.cpp:4]: (style) Variable 'b[-10]' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int a[10], * b = a + 10;\\n\"\n                              \"    b[-10] = 0;\\n\"\n                              \"    int * c = b - 10;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(// TODO \"[test.cpp:4]: (style) Variable 'a' is assigned a value that is never used.\\n\"\n            \"[test.cpp:5]: (style) Variable 'c' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int a[10], * b = a + 10;\\n\"\n                              \"    int * c = b - 10;\\n\"\n                              \"    x = c[0];\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'a' is not assigned a value.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int a[10], * b = a + 10;\\n\"\n                              \"    int * c = b - 10;\\n\"\n                              \"    c[1] = 3;\\n\"\n                              \"}\");\n        // TODO ASSERT_EQUALS(\"[test.cpp:5]: (style) Variable 'c[1]' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int a[10], * b = a + 10;\\n\"\n                              \"    int * c = b - 10;\\n\"\n                              \"    c[1] = c[0];\\n\"\n                              \"}\");\n        // TODO ASSERT_EQUALS(\"[test.cpp:5]: (style) Variable 'c[1]' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int a[10], * b = a + 10;\\n\"\n                              \"    int * c = b - 10;\\n\"\n                              \"    int d = c[0];\\n\"\n                              \"    f(d);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'a' is not assigned a value.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo() {\\n\" // #4022 - FP (a is assigned a value that is never used)\n                              \"    int a[2], *b[2];\\n\"\n                              \"    a[0] = 123;\\n\"\n                              \"    b[0] = &a[0];\\n\"\n                              \"    int *d = b[0];\\n\"\n                              \"    return *d;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo() {\\n\" // #4022 - FP (a is assigned a value that is never used)\n                              \"    entry a[2], *b[2];\\n\"\n                              \"    a[0].value = 123;\\n\"\n                              \"    b[0] = &a[0];\\n\"\n                              \"    int d = b[0].value;\\n\"\n                              \"    return d;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"struct S { char c[100]; };\\n\"\n                              \"void foo()\\n\"\n                              \"{\\n\"\n                              \"    char a[100];\\n\"\n                              \"    struct S * s = (struct S *)a;\\n\"\n                              \"    s->c[0] = 0;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"struct S { char c[100]; };\\n\"\n                              \"void foo()\\n\"\n                              \"{\\n\"\n                              \"    char a[100];\\n\"\n                              \"    struct S * s = (struct S *)a;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5]: (style) Variable 's' is assigned a value that is never used.\\n\"\n                      \"[test.cpp:4]: (style) Unused variable: a\\n\", errout.str());\n\n        functionVariableUsage(\"struct S { char c[100]; };\\n\"\n                              \"void foo()\\n\"\n                              \"{\\n\"\n                              \"    char a[100];\\n\"\n                              \"    const struct S * s = (const struct S *)a;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5]: (style) Variable 's' is assigned a value that is never used.\\n\"\n                      \"[test.cpp:4]: (style) Unused variable: a\\n\", errout.str());\n\n        functionVariableUsage(\"struct S { char c[100]; };\\n\"\n                              \"void foo()\\n\"\n                              \"{\\n\"\n                              \"    char a[100];\\n\"\n                              \"    struct S * s = static_cast<struct S *>(a);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5]: (style) Variable 's' is assigned a value that is never used.\\n\"\n                      \"[test.cpp:4]: (style) Unused variable: a\\n\", errout.str());\n\n        functionVariableUsage(\"struct S { char c[100]; };\\n\"\n                              \"void foo()\\n\"\n                              \"{\\n\"\n                              \"    char a[100];\\n\"\n                              \"    const struct S * s = static_cast<const struct S *>(a);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5]: (style) Variable 's' is assigned a value that is never used.\\n\"\n                      \"[test.cpp:4]: (style) Unused variable: a\\n\", errout.str());\n\n        functionVariableUsage(\"int a[10];\\n\"\n                              \"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int b[10];\\n\"\n                              \"    int c[10];\\n\"\n                              \"    int *d;\\n\"\n                              \"    d = b;\\n\"\n                              \"    d = a;\\n\"\n                              \"    d = c;\\n\"\n                              \"    *d = 0;\\n\"\n                              \"}\");\n        // TODO ASSERT_EQUALS(\"[test.cpp:4]: (style) Unused variable: b\\n\"\n        // TODO               \"[test.cpp:10]: (style) Variable 'c' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"int a[10];\\n\"\n                              \"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int b[10];\\n\"\n                              \"    int c[10];\\n\"\n                              \"    int *d;\\n\"\n                              \"    d = b; *d = 0;\\n\"\n                              \"    d = a; *d = 0;\\n\"\n                              \"    d = c; *d = 0;\\n\"\n                              \"}\");\n        // TODO ASSERT_EQUALS(\"[test.cpp:7]: (style) Variable 'b' is assigned a value that is never used.\\n\"\n        // TODO               \"[test.cpp:9]: (style) Variable 'c' is assigned a value that is never used.\\n\", errout.str());\n    }\n\n    void localvaralias2() { // ticket 1637\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int * a;\\n\"\n                              \"    x(a);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvaralias3() { // ticket 1639\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    BROWSEINFO    info;\\n\"\n                              \"    char          szDisplayName[MAX_PATH];\\n\"\n                              \"    info.pszDisplayName = szDisplayName;\\n\"\n                              \"    SHBrowseForFolder(&info);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvaralias4() { // ticket 1643\n        functionVariableUsage(\"struct AB { int a; int b; } ab;\\n\"\n                              \"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int * a = &ab.a;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4]: (style) Variable 'a' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"struct AB { int a; int b; } ab;\\n\"\n                              \"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int * a = &ab.a;\\n\"\n                              \"    *a = 0;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"struct AB { int a; int b; };\\n\"\n                              \"void foo()\\n\"\n                              \"{\\n\"\n                              \"    struct AB ab;\\n\"\n                              \"    int * a = &ab.a;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5]: (style) Variable 'a' is assigned a value that is never used.\\n\"\n                      \"[test.cpp:4]: (style) Variable 'ab' is not assigned a value.\\n\", errout.str());\n\n        functionVariableUsage(\"struct AB { int a; int b; };\\n\"\n                              \"void foo()\\n\"\n                              \"{\\n\"\n                              \"    struct AB ab;\\n\"\n                              \"    int * a = &ab.a;\\n\"\n                              \"    *a = 0;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvaralias5() { // ticket 1647\n        functionVariableUsage(\"char foo()\\n\"\n                              \"{\\n\"\n                              \"    char buf[8];\\n\"\n                              \"    char *p = &buf[0];\\n\"\n                              \"    *p++ = 0;\\n\"\n                              \"    return buf[0];\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"char foo()\\n\"\n                              \"{\\n\"\n                              \"    char buf[8];\\n\"\n                              \"    char *p = &buf[1];\\n\"\n                              \"    *p-- = 0;\\n\"\n                              \"    return buf[0];\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"char foo()\\n\"\n                              \"{\\n\"\n                              \"    char buf[8];\\n\"\n                              \"    char *p = &buf[0];\\n\"\n                              \"    *++p = 0;\\n\"\n                              \"    return buf[0];\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"char foo()\\n\"\n                              \"{\\n\"\n                              \"    char buf[8];\\n\"\n                              \"    char *p = &buf[1];\\n\"\n                              \"    *--p = 0;\\n\"\n                              \"    return buf[0];\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvaralias6() { // ticket 1729\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    char buf[8];\\n\"\n                              \"    char *srcdata;\\n\"\n                              \"    if (a()) {\\n\"\n                              \"        buf[0] = 1;\\n\"\n                              \"        srcdata = buf;\\n\"\n                              \"    } else {\\n\"\n                              \"        srcdata = vdata;\\n\"\n                              \"    }\\n\"\n                              \"    b(srcdata);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    char buf[8];\\n\"\n                              \"    char *srcdata;\\n\"\n                              \"    if (a()) {\\n\"\n                              \"        buf[0] = 1;\\n\"\n                              \"        srcdata = buf;\\n\"\n                              \"        srcdata = vdata;\\n\"\n                              \"    }\\n\"\n                              \"    b(srcdata);\\n\"\n                              \"}\");\n        // TODO ASSERT_EQUALS(\"[test.cpp:6]: (style) Variable 'buf' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    char buf[8];\\n\"\n                              \"    char *srcdata;\\n\"\n                              \"    if (a()) {\\n\"\n                              \"        buf[0] = 1;\\n\"\n                              \"        srcdata = buf;\\n\"\n                              \"    }\\n\"\n                              \"    srcdata = vdata;\\n\"\n                              \"    b(srcdata);\\n\"\n                              \"}\");\n        // TODO ASSERT_EQUALS(\"[test.cpp:6]: (style) Variable 'buf' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    char buf[8];\\n\"\n                              \"    char *srcdata;\\n\"\n                              \"    if (a()) {\\n\"\n                              \"        srcdata = buf;\\n\"\n                              \"    }\\n\"\n                              \"    srcdata = vdata;\\n\"\n                              \"    b(srcdata);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Unused variable: buf\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    char buf[8];\\n\"\n                              \"    char *srcdata;\\n\"\n                              \"    if (a()) {\\n\"\n                              \"        srcdata = vdata;\\n\"\n                              \"    }\\n\"\n                              \"    srcdata = buf;\\n\"\n                              \"    b(srcdata);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    char buf[8];\\n\"\n                              \"    char *srcdata;\\n\"\n                              \"    char vdata[8];\\n\"\n                              \"    if (a()) {\\n\"\n                              \"        buf[0] = 1;\\n\"\n                              \"        srcdata = buf;\\n\"\n                              \"    } else {\\n\"\n                              \"        srcdata = vdata;\\n\"\n                              \"    }\\n\"\n                              \"    b(srcdata);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    char buf[8];\\n\"\n                              \"    char *srcdata;\\n\"\n                              \"    char vdata[8];\\n\"\n                              \"    if (a()) {\\n\"\n                              \"        buf[0] = 1;\\n\"\n                              \"        srcdata = buf;\\n\"\n                              \"        srcdata = vdata;\\n\"\n                              \"    }\\n\"\n                              \"    b(srcdata);\\n\"\n                              \"}\");\n        // TODO ASSERT_EQUALS(\"[test.cpp:7]: (style) Variable 'buf' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    char buf[8];\\n\"\n                              \"    char *srcdata;\\n\"\n                              \"    char vdata[8];\\n\"\n                              \"    if (a()) {\\n\"\n                              \"        buf[0] = 1;\\n\"\n                              \"        srcdata = buf;\\n\"\n                              \"    }\\n\"\n                              \"    srcdata = vdata;\\n\"\n                              \"    b(srcdata);\\n\"\n                              \"}\");\n        // TODO ASSERT_EQUALS(\"[test.cpp:7]: (style) Variable 'buf' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    char buf[8];\\n\"\n                              \"    char *srcdata;\\n\"\n                              \"    char vdata[8];\\n\"\n                              \"    if (a()) {\\n\"\n                              \"        srcdata = buf;\\n\"\n                              \"    }\\n\"\n                              \"    srcdata = vdata;\\n\"\n                              \"    b(srcdata);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Unused variable: buf\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    char buf[8];\\n\"\n                              \"    char *srcdata;\\n\"\n                              \"    char vdata[8];\\n\"\n                              \"    if (a()) {\\n\"\n                              \"        srcdata = vdata;\\n\"\n                              \"    }\\n\"\n                              \"    srcdata = buf;\\n\"\n                              \"    b(srcdata);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:5]: (style) Unused variable: vdata\\n\", errout.str());\n    }\n\n    void localvaralias7() { // ticket 1732\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    char *c[10];\\n\"\n                              \"    char **cp;\\n\"\n                              \"    cp = c;\\n\"\n                              \"    *cp = 0;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvaralias8() {\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    char b1[8];\\n\"\n                              \"    char b2[8];\\n\"\n                              \"    char b3[8];\\n\"\n                              \"    char b4[8];\\n\"\n                              \"    char *pb;\\n\"\n                              \"    if (a == 1)\\n\"\n                              \"        pb = b1;\\n\"\n                              \"    else if (a == 2)\\n\"\n                              \"        pb = b2;\\n\"\n                              \"    else if (a == 3)\\n\"\n                              \"        pb = b3;\\n\"\n                              \"    else\\n\"\n                              \"        pb = b4;\\n\"\n                              \"    b(pb);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    char b1[8];\\n\"\n                              \"    char b2[8];\\n\"\n                              \"    char b3[8];\\n\"\n                              \"    char b4[8];\\n\"\n                              \"    char *pb;\\n\"\n                              \"    if (a == 1)\\n\"\n                              \"        pb = b1;\\n\"\n                              \"    else if (a == 2)\\n\"\n                              \"        pb = b2;\\n\"\n                              \"    else if (a == 3)\\n\"\n                              \"        pb = b3;\\n\"\n                              \"    else {\\n\"\n                              \"        pb = b1;\\n\"\n                              \"        pb = b4;\\n\"\n                              \"    }\\n\"\n                              \"    b(pb);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    char b1[8];\\n\"\n                              \"    char b2[8];\\n\"\n                              \"    char b3[8];\\n\"\n                              \"    char b4[8];\\n\"\n                              \"    char *pb;\\n\"\n                              \"    if (a == 1)\\n\"\n                              \"        pb = b1;\\n\"\n                              \"    else if (a == 2)\\n\"\n                              \"        pb = b2;\\n\"\n                              \"    else if (a == 3)\\n\"\n                              \"        pb = b3;\\n\"\n                              \"    else {\\n\"\n                              \"        pb = b1;\\n\"\n                              \"        pb = b2;\\n\"\n                              \"        pb = b3;\\n\"\n                              \"        pb = b4;\\n\"\n                              \"    }\\n\"\n                              \"    b(pb);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    char b1[8];\\n\"\n                              \"    char b2[8];\\n\"\n                              \"    char b3[8];\\n\"\n                              \"    char b4[8];\\n\"\n                              \"    char *pb;\\n\"\n                              \"    if (a == 1)\\n\"\n                              \"        pb = b1;\\n\"\n                              \"    else if (a == 2)\\n\"\n                              \"        pb = b2;\\n\"\n                              \"    else if (a == 3)\\n\"\n                              \"        pb = b3;\\n\"\n                              \"    pb = b4;\\n\"\n                              \"    b(pb);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Unused variable: b1\\n\"\n                      \"[test.cpp:4]: (style) Unused variable: b2\\n\"\n                      \"[test.cpp:5]: (style) Unused variable: b3\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    char b1[8];\\n\"\n                              \"    char b2[8];\\n\"\n                              \"    char b3[8];\\n\"\n                              \"    char b4[8];\\n\"\n                              \"    char *pb;\\n\"\n                              \"    if (a == 1)\\n\"\n                              \"        pb = b1;\\n\"\n                              \"    else {\\n\"\n                              \"        if (a == 2)\\n\"\n                              \"            pb = b2;\\n\"\n                              \"        else {\\n\"\n                              \"            if (a == 3)\\n\"\n                              \"                pb = b3;\\n\"\n                              \"            else\\n\"\n                              \"                pb = b4;\\n\"\n                              \"        }\\n\"\n                              \"    }\\n\"\n                              \"    b(pb);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    char b1[8];\\n\"\n                              \"    char b2[8];\\n\"\n                              \"    char b3[8];\\n\"\n                              \"    char b4[8];\\n\"\n                              \"    char *pb;\\n\"\n                              \"    if (a == 1)\\n\"\n                              \"        pb = b1;\\n\"\n                              \"    else {\\n\"\n                              \"        if (a == 2)\\n\"\n                              \"            pb = b2;\\n\"\n                              \"        else {\\n\"\n                              \"            if (a == 3)\\n\"\n                              \"                pb = b3;\\n\"\n                              \"            else {\\n\"\n                              \"                pb = b1;\\n\"\n                              \"                pb = b4;\\n\"\n                              \"            }\\n\"\n                              \"        }\\n\"\n                              \"    }\\n\"\n                              \"    b(pb);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    char b1[8];\\n\"\n                              \"    char b2[8];\\n\"\n                              \"    char b3[8];\\n\"\n                              \"    char b4[8];\\n\"\n                              \"    char *pb;\\n\"\n                              \"    if (a == 1)\\n\"\n                              \"        pb = b1;\\n\"\n                              \"    else {\\n\"\n                              \"        if (a == 2)\\n\"\n                              \"            pb = b2;\\n\"\n                              \"        else {\\n\"\n                              \"            if (a == 3)\\n\"\n                              \"                pb = b3;\\n\"\n                              \"            else {\\n\"\n                              \"                pb = b1;\\n\"\n                              \"                pb = b2;\\n\"\n                              \"                pb = b3;\\n\"\n                              \"                pb = b4;\\n\"\n                              \"            }\\n\"\n                              \"        }\\n\"\n                              \"    }\\n\"\n                              \"    b(pb);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    char b1[8];\\n\"\n                              \"    char b2[8];\\n\"\n                              \"    char b3[8];\\n\"\n                              \"    char b4[8];\\n\"\n                              \"    char *pb;\\n\"\n                              \"    if (a == 1)\\n\"\n                              \"        pb = b1;\\n\"\n                              \"    else {\\n\"\n                              \"        if (a == 2)\\n\"\n                              \"            pb = b2;\\n\"\n                              \"        else {\\n\"\n                              \"            if (a == 3)\\n\"\n                              \"                pb = b3;\\n\"\n                              \"        }\\n\"\n                              \"    }\\n\"\n                              \"    pb = b4;\\n\"\n                              \"    b(pb);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Unused variable: b1\\n\"\n                      \"[test.cpp:4]: (style) Unused variable: b2\\n\"\n                      \"[test.cpp:5]: (style) Unused variable: b3\\n\", errout.str());\n    }\n\n    void localvaralias9() { // ticket 1996\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    Foo foo;\\n\"\n                              \"    Foo &ref = foo;\\n\"\n                              \"    ref[0] = 123;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    Foo foo;\\n\"\n                              \"    Foo &ref = foo;\\n\"\n                              \"    ref[0] = 123;\\n\"\n                              \"}\",\n                              \"test.c\");\n        // TODO ASSERT_EQUALS(\"[test.c:5]: (style) Variable 'foo' is assigned a value that is never used.\\n\", errout.str());\n    }\n\n    void localvaralias10() { // ticket 2004\n        functionVariableUsage(\"void foo(Foo &foo)\\n\"\n                              \"{\\n\"\n                              \"    Foo &ref = foo;\\n\"\n                              \"    int *x = &ref.x();\\n\"\n                              \"    *x = 0;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo(Foo &foo)\\n\"\n                              \"{\\n\"\n                              \"    Foo &ref = foo;\\n\"\n                              \"    int *x = &ref.x;\\n\"\n                              \"    *x = 0;\\n\"\n                              \"}\",\n                              \"test.c\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvaralias11() { // #4423 - iterator\n        functionVariableUsage(\"void f(Foo &foo) {\\n\"\n                              \"    std::set<int>::iterator x = foo.dostuff();\\n\"\n                              \"    *(x) = 0;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvaralias12() { // #4394\n        functionVariableUsage(\"void f(void) {\\n\"\n                              \"    int a[4];\\n\"\n                              \"    int *b = (int*)((int*)a+1);\\n\"\n                              \"    x(b);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"int f(void) {\\n\" // #4628\n                              \"    int x=1,y;\\n\"\n                              \"    y = (x * a) / 100;\\n\"\n                              \"    return y;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvaralias13() { // #4487\n        functionVariableUsage(\"void f(char *p) {\\n\"\n                              \"    char a[4];\\n\"\n                              \"    p = a;\\n\"\n                              \"    strcpy(p, \\\"x\\\");\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void f(char *p) {\\n\"\n                              \"    char a[4];\\n\"\n                              \"    p = a;\\n\"\n                              \"    strcpy(p, \\\"x\\\");\\n\"\n                              \"}\");\n        TODO_ASSERT_EQUALS(\"a is assigned value that is never used\", \"\", errout.str());\n    }\n\n    void localvaralias14() { // #5619\n        functionVariableUsage(\"char * dostuff(char *p);\\n\"\n                              \"void f() {\\n\"\n                              \"    char a[4], *p=a;\\n\"\n                              \"    p = dostuff(p);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4]: (style) Variable 'p' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"char * dostuff(char *&p);\\n\"\n                              \"void f() {\\n\"\n                              \"    char a[4], *p=a;\\n\"\n                              \"    p = dostuff(p);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str()); // TODO: we can warn in this special case; variable is local and there are no function calls after the assignment\n\n        functionVariableUsage(\"void f() {\\n\"\n                              \"    char a[4], *p=a;\\n\"\n                              \"    p = dostuff(p);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str()); // TODO: we can warn in this special case; variable is local and there are no function calls after the assignment\n    }\n\n    void localvaralias15() { // #6315\n        functionVariableUsage(\"void f() {\\n\"\n                              \"  int x=3;\\n\"\n                              \"  int *p = &x;\\n\"\n                              \"  int *p2[1] = {p};\\n\"\n                              \"  dostuff(p2);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvaralias16() {\n        functionVariableUsage(\"void f() {\\n\"\n                              \"  auto x = dostuff();\\n\"\n                              \"  p = x;\\n\"\n                              \"  x->data[0] = 9;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvaralias17() {\n        functionVariableUsage(\"void f() {\\n\"\n                              \"  int x;\\n\"\n                              \"  unknown_type p = &x;\\n\"\n                              \"  *p = 9;\\n\"\n                              \"}\", \"test.c\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvaralias18() {\n        functionVariableUsage(\"void add( std::vector< std::pair< int, double > >& v)\\n\"\n                              \"{\\n\"\n                              \"    std::vector< std::pair< int, double > >::iterator it;\\n\"\n                              \"    for ( it = v.begin(); it != v.end(); ++it )\\n\"\n                              \"    {\\n\"\n                              \"        if ( x )\\n\"\n                              \"        {\\n\"\n                              \"            ( *it ).second = 0;\\n\"\n                              \"            break;\\n\"\n                              \"        }\\n\"\n                              \"    }\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvarasm() {\n\n        functionVariableUsage(\"void foo(int &b)\\n\"\n                              \"{\\n\"\n                              \"    int a;\\n\"\n                              \"    asm();\\n\"\n                              \"    b = a;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvarStruct1() {\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    static const struct{ int x, y, w, h; } bounds = {1,2,3,4};\\n\"\n                              \"    return bounds.x + bounds.y + bounds.w + bounds.h;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvarStruct2() {\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    struct ABC { int a, b, c; };\\n\"\n                              \"    struct ABC abc = { 1, 2, 3 };\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4]: (style) Variable 'abc' is assigned a value that is never used.\\n\", errout.str());\n    }\n\n    void localvarStruct3() {\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int a = 10;\\n\"\n                              \"    union { struct { unsigned char x; }; unsigned char z; };\\n\"\n                              \"    do {\\n\"\n                              \"        func();\\n\"\n                              \"    } while(a--);\\n\"\n                              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:4]: (style) Unused variable: x\\n\"\n                           \"[test.cpp:4]: (style) Unused variable: z\\n\", \"\", errout.str());\n    }\n\n    void localvarStruct5() {\n        functionVariableUsage(\"int foo() {\\n\"\n                              \"    A a;\\n\"\n                              \"    return a.i;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"int foo() {\\n\"\n                              \"    A a;\\n\"\n                              \"    return 0;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"int foo() {\\n\"\n                              \"    A a;\\n\"\n                              \"    return 0;\\n\"\n                              \"}\\n\",\n                              \"test.c\");\n        ASSERT_EQUALS(\"[test.c:2]: (style) Unused variable: a\\n\", errout.str());\n\n        functionVariableUsage(\"struct A { int i; };\\n\"\n                              \"int foo() {\\n\"\n                              \"    A a;\\n\"\n                              \"    return a.i;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"class A { int i; };\\n\"\n                              \"int foo() {\\n\"\n                              \"    A a;\\n\"\n                              \"    return a.i;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"struct A { int i; };\\n\"\n                              \"int foo() {\\n\"\n                              \"    A a;\\n\"\n                              \"    a.i = 0;\\n\"\n                              \"    return 0;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4]: (style) Variable 'a.i' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"class A { int i; };\\n\"\n                              \"int foo() {\\n\"\n                              \"    A a;\\n\"\n                              \"    a.i = 0;\\n\"\n                              \"    return 0;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4]: (style) Variable 'a.i' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"struct A { int i; };\\n\"\n                              \"int foo() {\\n\"\n                              \"    A a = { 0 };\\n\"\n                              \"    return 0;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'a' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"class A { int i; };\\n\"\n                              \"int foo() {\\n\"\n                              \"    A a = { 0 };\\n\"\n                              \"    return 0;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'a' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"class A { int i; public: A(); { } };\\n\"\n                              \"int foo() {\\n\"\n                              \"    A a;\\n\"\n                              \"    return 0;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"struct A { int i; };\\n\"\n                              \"int foo() {\\n\"\n                              \"    A a;\\n\"\n                              \"    return 0;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Unused variable: a\\n\", errout.str());\n\n        functionVariableUsage(\"class A { int i; };\\n\"\n                              \"int foo() {\\n\"\n                              \"    A a;\\n\"\n                              \"    return 0;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Unused variable: a\\n\", errout.str());\n\n        functionVariableUsage(\"class A { int i; public: A(); { } };\\n\"\n                              \"int foo() {\\n\"\n                              \"    A a;\\n\"\n                              \"    return 0;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"class A { unknown i; };\\n\"\n                              \"int foo() {\\n\"\n                              \"    A a;\\n\"\n                              \"    return 0;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"class A : public Fred { int i; };\\n\"\n                              \"int foo() {\\n\"\n                              \"    A a;\\n\"\n                              \"    return 0;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"class Fred {char c;};\\n\"\n                              \"class A : public Fred { int i; };\\n\"\n                              \"int foo() {\\n\"\n                              \"    A a;\\n\"\n                              \"    return 0;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4]: (style) Unused variable: a\\n\", errout.str());\n    }\n\n    void localvarStruct6() {\n        functionVariableUsage(\"class Type { };\\n\"\n                              \"class A {\\n\"\n                              \"public:\\n\"\n                              \"    Type & get() { return t; }\\n\"\n                              \"private:\\n\"\n                              \"    Type t;\\n\"\n                              \"};\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvarStruct7() {\n        functionVariableUsage(\"struct IMAPARG {\\n\"\n                              \"  void *text;\\n\"\n                              \"};\\n\"\n                              \"\\n\"\n                              \"void fun() {\\n\"\n                              \"  IMAPARG *args, aatt;\\n\"\n                              \"  args = &aatt;\\n\"\n                              \"  aatt.text = tmp;\\n\"\n                              \"  dostuff(args);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"struct ARG {\\n\"\n                              \"  void *a;\\n\"\n                              \"  void *b;\\n\"\n                              \"};\\n\"\n                              \"\\n\"\n                              \"void fun() {\\n\"\n                              \"  ARG aatt;\\n\"\n                              \"  int *p = &aatt.b;\\n\"\n                              \"  aatt.a = 123;\\n\"\n                              \"  dostuff(p);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:9]: (style) Variable 'aatt.a' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"struct AB {\\n\"\n                              \"  int a;\\n\"\n                              \"  int b;\\n\"\n                              \"};\\n\"\n                              \"\\n\"\n                              \"void fun() {\\n\"\n                              \"  AB ab;\\n\"\n                              \"  int &a = ab.a;\\n\"\n                              \"  ab.a = 123;\\n\"\n                              \"  dostuff(a);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvarStruct8() {\n        functionVariableUsage(\"struct s {\\n\"\n                              \"     union {\\n\"\n                              \"         struct {\\n\"\n                              \"             int fld1 : 16;\\n\"\n                              \"             int fld2 : 16;\\n\"\n                              \"         };\\n\"\n                              \"         int raw;\\n\"\n                              \"     };\\n\"\n                              \"};\\n\"\n                              \"\\n\"\n                              \"void foo() {\\n\"\n                              \"      struct s test;\\n\"\n                              \"      test.raw = 0x100;\\n\"\n                              \"      dostuff(test.fld1, test.fld2);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvarStruct9() {\n        functionVariableUsage(\"struct XY { int x; int y; };\\n\"\n                              \"\\n\"\n                              \"void foo() {\\n\"\n                              \"      struct XY xy(get());\\n\"\n                              \"      return xy.x + xy.y;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvarStructArray() {\n        // #3633 - detect that struct array is assigned a value\n        functionVariableUsage(\"void f() {\\n\"\n                              \"    struct X x[10];\\n\"\n                              \"    x[0].a = 5;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'x[0].a' is assigned a value that is never used.\\n\", errout.str());\n    }\n\n    void localvarOp() {\n        const char op[] = \"+-*/%&|^\";\n        for (const char *p = op; *p; ++p) {\n            std::string code(\"int main()\\n\"\n                             \"{\\n\"\n                             \"    int tmp = 10;\\n\"\n                             \"    return 123 \" + std::string(1, *p) + \" tmp;\\n\"\n                             \"}\");\n            functionVariableUsage(code.c_str());\n            ASSERT_EQUALS(\"\", errout.str());\n        }\n    }\n\n    void localvarInvert() {\n        functionVariableUsage(\"int main()\\n\"\n                              \"{\\n\"\n                              \"    int tmp = 10;\\n\"\n                              \"    return ~tmp;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvarIf() {\n        functionVariableUsage(\"int main()\\n\"\n                              \"{\\n\"\n                              \"    int tmp = 10;\\n\"\n                              \"    if ( tmp )\\n\"\n                              \"        return 1;\\n\"\n                              \"    return 0;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvarIfElse() {\n        functionVariableUsage(\"int foo()\\n\"\n                              \"{\\n\"\n                              \"    int tmp1 = 1;\\n\"\n                              \"    int tmp2 = 2;\\n\"\n                              \"    int tmp3 = 3;\\n\"\n                              \"    return tmp1 ? tmp2 : tmp3;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvarOpAssign() {\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int a = 1;\\n\"\n                              \"    int b = 2;\\n\"\n                              \"    a |= b;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'a' is assigned a value that is never used.\\n\"\n                      \"[test.cpp:5]: (style) Variable 'a' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo() {\\n\"\n                              \"    int a = 1;\\n\"\n                              \"    (b).x += a;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo() {\\n\"\n                              \"    int a=1, b[10];\\n\"\n                              \"    b[0] = x;\\n\"\n                              \"    a += b[0];\\n\"\n                              \"    return a;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void f(int *start, int *stop) {\\n\"\n                              \"  int length = *start - *stop;\\n\"\n                              \"  if (length < 10000)\\n\"\n                              \"    length = 10000;\\n\"\n                              \"  *stop -= length;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void f(int a) {\\n\"\n                              \"  int x = 3;\\n\"\n                              \"  a &= ~x;\\n\"\n                              \"  return a;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void f() {\\n\"  // unknown class => library configuration is needed\n                              \"  Fred fred;\\n\"\n                              \"  int *a; a = b;\\n\"\n                              \"  fred += a;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4]: (information) --check-library: Provide <type-checks><unusedvar> configuration for Fred\\n\", errout.str());\n\n        functionVariableUsage(\"void f() {\\n\"\n                              \"  std::pair<int,int> fred;\\n\"  // class with library configuration\n                              \"  fred = x;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'fred' is assigned a value that is never used.\\n\", errout.str());\n    }\n\n    void localvarFor() {\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    int a = 1;\\n\"\n                              \"    for (;a;);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo() {\\n\"\n                              \"    for (int i = 0; (pci = cdi_list_get(pciDevices, i)); i++)\\n\"\n                              \"    {}\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvarForEach() { // #4155 - foreach\n        functionVariableUsage(\"void foo() {\\n\"\n                              \"    int i = -1;\\n\"\n                              \"    int a[] = {1,2,3};\\n\"\n                              \"    FOREACH_X (int x, a) {\\n\"\n                              \"        if (i==x) return x;\\n\"\n                              \"        i = x;\\n\"\n                              \"    }\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        // #5154 - MSVC 'for each'\n        functionVariableUsage(\"void f() {\\n\"\n                              \"  std::map<int,int> ints;\\n\"\n                              \"  ints[0]= 1;\\n\"\n                              \"  for each(std::pair<int,int> i in ints) { x += i.first; }\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvarShift1() {\n        functionVariableUsage(\"int foo()\\n\"\n                              \"{\\n\"\n                              \"    int var = 1;\\n\"\n                              \"    return 1 >> var;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvarShift3() {  // #3509\n        functionVariableUsage(\"int foo()\\n\"\n                              \"{\\n\"\n                              \"    QList<int *> ints;\\n\"\n                              \"    ints << 1;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"int foo() {\\n\" // #4320\n                              \"    int x;\\n\"\n                              \"    x << 1;\\n\"\n                              \"    return x;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvarCast() {\n        functionVariableUsage(\"int foo()\\n\"\n                              \"{\\n\"\n                              \"    int a = 1;\\n\"\n                              \"    int b = static_cast<int>(a);\\n\"\n                              \"    return b;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvarClass() {\n        functionVariableUsage(\"int foo()\\n\"\n                              \"{\\n\"\n                              \"    class B : public A {\\n\"\n                              \"        int a;\\n\"\n                              \"        int f() { return a; }\\n\"\n                              \"    } b;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvarUnused() {\n        functionVariableUsage(\"int foo()\\n\"\n                              \"{\\n\"\n                              \"    bool test __attribute__((unused));\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"int foo()\\n\"\n                              \"{\\n\"\n                              \"    bool test __attribute__((unused)) = true;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"int foo()\\n\"\n                              \"{\\n\"\n                              \"    bool __attribute__((unused)) test;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"int foo()\\n\"\n                              \"{\\n\"\n                              \"    bool __attribute__((unused)) test = true;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"int foo()\\n\"\n                              \"{\\n\"\n                              \"    bool test __attribute__((used));\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"int foo()\\n\"\n                              \"{\\n\"\n                              \"    bool __attribute__((used)) test;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvarFunction() {\n        functionVariableUsage(\"void check_dlsym(void*& h)\\n\"\n                              \"{\\n\"\n                              \"  typedef void (*function_type) (void);\\n\"\n                              \"  function_type fn;\\n\"\n                              \"  fn = reinterpret_cast<function_type>(dlsym(h, \\\"try_allocation\\\"));\\n\"\n                              \"  fn();\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvarstatic() {\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    static int i;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    static int i = 0;\\n\"\n                              \"}\");\n        // TODO ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'i' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    static int i(0);\\n\"\n                              \"}\");\n        // TODO ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'i' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    static int j = 0;\\n\"\n                              \"    static int i(j);\\n\"\n                              \"}\");\n        // TODO ASSERT_EQUALS(\"[test.cpp:4]: (style) Variable 'i' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"int * foo(int x)\\n\"\n                              \"{\\n\"\n                              \"    static int a[] = { 3, 4, 5, 6 };\\n\"\n                              \"    static int b[] = { 4, 5, 6, 7 };\\n\"\n                              \"    static int c[] = { 5, 6, 7, 8 };\\n\"\n                              \"    b[1] = 1;\\n\"\n                              \"    return x ? a : c;\\n\"\n                              \"}\");\n        // TODO ASSERT_EQUALS(\"[test.cpp:6]: (style) Variable 'b' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    static int i = 0;\\n\"\n                              \"    if(i < foo())\\n\"\n                              \"        i += 5;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo() {\\n\"\n                              \"    static int x = 0;\\n\"\n                              \"    print(x);\\n\"\n                              \"    if(x > 5)\\n\"\n                              \"        x = 0;\\n\"\n                              \"    else\\n\"\n                              \"        x++;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo(int value) {\\n\"\n                              \"    static int array[16] = {0};\\n\"\n                              \"    if(array[value]) {}\\n\"\n                              \"    array[value] = 1;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvarextern() {\n        functionVariableUsage(\"void foo() {\\n\"\n                              \"    extern int i;\\n\"\n                              \"    i = 0;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvardynamic1() {\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    void* ptr = malloc(16);\\n\"\n                              \"    free(ptr);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'ptr' is allocated memory that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    void* ptr = g_malloc(16);\\n\"\n                              \"    g_free(ptr);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'ptr' is allocated memory that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    void* ptr = kmalloc(16, GFP_KERNEL);\\n\"\n                              \"    kfree(ptr);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'ptr' is allocated memory that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    void* ptr = vmalloc(16, GFP_KERNEL);\\n\"\n                              \"    vfree(ptr);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'ptr' is allocated memory that is never used.\\n\", errout.str());\n\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    char* ptr = new char[16];\\n\"\n                              \"    delete[] ptr;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'ptr' is allocated memory that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    char* ptr = new ( nothrow ) char[16];\\n\"\n                              \"    delete[] ptr;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'ptr' is allocated memory that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    char* ptr = new ( std::nothrow ) char[16];\\n\"\n                              \"    delete[] ptr;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'ptr' is allocated memory that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    char* ptr = new char;\\n\"\n                              \"    delete ptr;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'ptr' is allocated memory that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    void* ptr = malloc(16);\\n\"\n                              \"    ptr[0] = 123;\\n\"\n                              \"    free(ptr);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    char* ptr = new char[16];\\n\"\n                              \"    ptr[0] = 123;\\n\"\n                              \"    delete[] ptr;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    Fred* fred = new Fred;\\n\"\n                              \"    std::cout << \\\"test\\\" << std::endl;\\n\"\n                              \"    delete fred;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"struct Fred { int a; };\\n\"\n                              \"void foo()\\n\"\n                              \"{\\n\"\n                              \"    Fred* fred = new Fred;\\n\"\n                              \"    std::cout << \\\"test\\\" << std::endl;\\n\"\n                              \"    delete fred;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4]: (style) Variable 'fred' is allocated memory that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"struct Fred { int a; Fred() : a(0) {} };\\n\"\n                              \"void foo()\\n\"\n                              \"{\\n\"\n                              \"    Fred* fred = new Fred;\\n\"\n                              \"    std::cout << \\\"test\\\" << std::endl;\\n\"\n                              \"    delete fred;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    Fred* fred = malloc(sizeof(Fred));\\n\"\n                              \"    std::cout << \\\"test\\\" << std::endl;\\n\"\n                              \"    free(fred);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'fred' is allocated memory that is never used.\\n\", errout.str());\n\n\n        functionVariableUsage(\"void foo()\\n\"\n                              \"{\\n\"\n                              \"    char* ptr = names[i];\\n\"\n                              \"    delete[] ptr;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvardynamic2() {\n        functionVariableUsage(\"struct Fred { int i; };\\n\"\n                              \"void foo()\\n\"\n                              \"{\\n\"\n                              \"    Fred* ptr = malloc(sizeof(Fred));\\n\"\n                              \"    free(ptr);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4]: (style) Variable 'ptr' is allocated memory that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"struct Fred { int i; };\\n\"\n                              \"void foo()\\n\"\n                              \"{\\n\"\n                              \"    Fred* ptr = malloc(sizeof(Fred));\\n\"\n                              \"    ptr->i = 0;\\n\"\n                              \"    free(ptr);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"struct Fred { int i; };\\n\"\n                              \"void foo()\\n\"\n                              \"{\\n\"\n                              \"    struct Fred* ptr = malloc(sizeof(Fred));\\n\"\n                              \"    free(ptr);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4]: (style) Variable 'ptr' is allocated memory that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"struct Fred { int i; };\\n\"\n                              \"void foo()\\n\"\n                              \"{\\n\"\n                              \"    struct Fred* ptr = malloc(sizeof(Fred));\\n\"\n                              \"    ptr->i = 0;\\n\"\n                              \"    free(ptr);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"struct Fred { int i; };\\n\"\n                              \"void foo()\\n\"\n                              \"{\\n\"\n                              \"    Fred* ptr = new Fred();\\n\"\n                              \"    delete ptr;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4]: (style) Variable 'ptr' is allocated memory that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"struct Fred { int i; };\\n\"\n                              \"void foo()\\n\"\n                              \"{\\n\"\n                              \"    Fred* ptr = new (nothrow ) Fred();\\n\"\n                              \"    delete ptr;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4]: (style) Variable 'ptr' is allocated memory that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"struct Fred { int i; };\\n\"\n                              \"void foo()\\n\"\n                              \"{\\n\"\n                              \"    Fred* ptr = new (std::nothrow) Fred();\\n\"\n                              \"    delete ptr;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4]: (style) Variable 'ptr' is allocated memory that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"struct Fred { int i; };\\n\"\n                              \"void foo()\\n\"\n                              \"{\\n\"\n                              \"    Fred* ptr = new Fred();\\n\"\n                              \"    ptr->i = 0;\\n\"\n                              \"    delete ptr;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"struct Fred { int i; };\\n\"\n                              \"void foo()\\n\"\n                              \"{\\n\"\n                              \"    struct Fred* ptr = new Fred();\\n\"\n                              \"    free(ptr);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4]: (style) Variable 'ptr' is allocated memory that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"struct Fred { int i; };\\n\"\n                              \"void foo()\\n\"\n                              \"{\\n\"\n                              \"    struct Fred* ptr = new Fred();\\n\"\n                              \"    ptr->i = 0;\\n\"\n                              \"    free(ptr);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"class Fred { public: int i; };\\n\"\n                              \"void foo()\\n\"\n                              \"{\\n\"\n                              \"    Fred* ptr = malloc(sizeof(Fred));\\n\"\n                              \"    free(ptr);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4]: (style) Variable 'ptr' is allocated memory that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"class Fred { public: int i; };\\n\"\n                              \"void foo()\\n\"\n                              \"{\\n\"\n                              \"    Fred* ptr = malloc(sizeof(Fred));\\n\"\n                              \"    ptr->i = 0;\\n\"\n                              \"    free(ptr);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"class Fred { public: int i; };\\n\"\n                              \"void foo()\\n\"\n                              \"{\\n\"\n                              \"    Fred* ptr = new Fred();\\n\"\n                              \"    delete ptr;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:4]: (style) Variable 'ptr' is allocated memory that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"class Fred { public: int i; };\\n\"\n                              \"void foo()\\n\"\n                              \"{\\n\"\n                              \"    Fred* ptr = new Fred();\\n\"\n                              \"    ptr->i = 0;\\n\"\n                              \"    delete ptr;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvardynamic3() {\n        // Ticket #3467 - False positive that 'data' is not assigned a value\n        functionVariableUsage(\"void foo() {\\n\"\n                              \"    int* data = new int[100];\\n\"\n                              \"    int* p = data;\\n\"\n                              \"    for ( int i = 0; i < 10; ++i )\\n\"\n                              \"        p++;\\n\"\n                              \"}\");\n        // TODO ASSERT_EQUALS(\"[test.cpp:5]: (style) Variable 'p' is modified but its new value is never used.\\n\", errout.str());\n    }\n\n    void localvararray1() {\n        functionVariableUsage(\"void foo() {\\n\"\n                              \"    int p[5];\\n\"\n                              \"    *p = 0;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvararray2() {\n        functionVariableUsage(\"int foo() {\\n\"\n                              \"    int p[5][5];\\n\"\n                              \"    p[0][0] = 0;\\n\"\n                              \"    return p[0][0];\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvararray3() {\n        functionVariableUsage(\"int foo() {\\n\"\n                              \"    int p[5][5];\\n\"\n                              \"    *((int*)p[0]) = 0;\\n\"\n                              \"    return p[0][0];\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvararray4() {\n        functionVariableUsage(\"void foo() {\\n\"\n                              \"    int p[1];\\n\"\n                              \"    int *pp[0];\\n\"\n                              \"    p[0] = 1;\\n\"\n                              \"    *pp[0] = p[0];\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvararray5() {\n        functionVariableUsage(\"int foo() {\\n\"\n                              \"    int p[5][5];\\n\"\n                              \"    dostuff(*p);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvarstring1() { // ticket #1597\n        functionVariableUsage(\"void foo() {\\n\"\n                              \"    std::string s;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2]: (style) Unused variable: s\\n\", errout.str());\n\n        functionVariableUsage(\"void foo() {\\n\"\n                              \"    std::string s;\\n\"\n                              \"    s = \\\"foo\\\";\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 's' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo() {\\n\"\n                              \"    std::string s = \\\"foo\\\";\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2]: (style) Variable 's' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void foo() {\\n\" // #8901\n                              \"    const std::string s = \\\"foo\\\";\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2]: (style) Variable 's' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"std::string foo() {\\n\"\n                              \"    std::string s;\\n\" // Class instances are initialized. Assignment is not necessary\n                              \"    return s;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"std::string foo() {\\n\"\n                              \"    std::string s = \\\"foo\\\";\\n\"\n                              \"    return s;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvarstring2() { // ticket #2929\n        functionVariableUsage(\"void foo() {\\n\"\n                              \"    std::string s;\\n\"\n                              \"    int i;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2]: (style) Unused variable: s\\n\"\n                      \"[test.cpp:3]: (style) Unused variable: i\\n\", errout.str());\n    }\n\n    void localvarconst1() {\n        functionVariableUsage(\"void foo() {\\n\"\n                              \"    const bool b = true;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2]: (style) Variable 'b' is assigned a value that is never used.\\n\", errout.str());\n    }\n\n    void localvarconst2() {\n        functionVariableUsage(\"void foo() {\\n\"\n                              \"    const int N = 10;\\n\"\n                              \"    struct X { int x[N]; };\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvarreturn() { // ticket #9167\n        functionVariableUsage(\"void foo() {\\n\"\n                              \"    const int MyInt = 1;\\n\"\n                              \"    class bar {\\n\"\n                              \"      public:\\n\"\n                              \"        bool operator()(const int &uIndexA, const int &uIndexB) const {\\n\"\n                              \"            return true;\\n\"\n                              \"        }\\n\"\n                              \"        bar() {}\\n\"\n                              \"    };\\n\"\n                              \"    return MyInt;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvarmaybeunused() {\n        functionVariableUsage(\"int main() {\\n\"\n                              \"    [[maybe_unused]] int x;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"[[nodiscard]] int getX() { return 4; }\\n\"\n                              \"int main() {\\n\"\n                              \"    [[maybe_unused]] int x = getX();\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"[[nodiscard]] int getX() { return 4; }\\n\"\n                              \"int main() {\\n\"\n                              \"    [[maybe_unused]] int x = getX();\\n\"\n                              \"    x = getX();\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"[[nodiscard]] int getX() { return 4; }\\n\"\n                              \"int main() {\\n\"\n                              \"    [[maybe_unused]] int x = getX();\\n\"\n                              \"    x = getX();\\n\"\n                              \"    std::cout << x;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"int main() {\\n\"\n                              \"    [[maybe_unused]] const int x = getX();\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"int main() {\\n\"\n                              \"    [[maybe_unused]] const int& x = getX();\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"int main() {\\n\"\n                              \"    [[maybe_unused]] const int* x = getX();\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"int main() {\\n\"\n                              \"    [[maybe_unused]] int& x = getX();\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"int main() {\\n\"\n                              \"    [[maybe_unused]] int* x = getX();\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"int main() {\\n\"\n                              \"    [[maybe_unused]] auto x = getX();\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"int main() {\\n\"\n                              \"    [[maybe_unused]] auto&& x = getX();\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"int main() {\\n\"\n                              \"    [[maybe_unused]] int x[] = getX();\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"int main() {\\n\"\n                              \"    [[maybe_unused]] constexpr volatile static int x = 1;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"[[maybe_unused]] inline int x = 1;\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"int main() {\\n\"\n                              \"    [[maybe_unused]] [[anotherattribute]] const int* = 1;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvarthrow() { // ticket #3687\n        functionVariableUsage(\"void foo() {\\n\"\n                              \"    try {}\"\n                              \"    catch(Foo& bar) {}\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localVarStd() {\n        functionVariableUsage(\"void f() {\\n\"\n                              \"    std::string x = foo();\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2]: (style) Variable 'x' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void f() {\\n\"\n                              \"    std::vector<int> x;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2]: (style) Unused variable: x\\n\", errout.str());\n\n        functionVariableUsage(\"void f() {\\n\"\n                              \"    std::vector<int> x(100);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2]: (style) Variable 'x' is assigned a value that is never used.\\n\", errout.str());\n\n        functionVariableUsage(\"void f() {\\n\"\n                              \"    std::vector<MyClass> x;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2]: (style) Unused variable: x\\n\", errout.str());\n\n        functionVariableUsage(\"void f() {\\n\"\n                              \"    std::lock_guard<MyClass> lock(mutex_);\\n\" // Has a side-effect #4385\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void f() {\\n\"\n                              \"    pLocker = std::shared_ptr<jfxLocker>(new jfxLocker(m_lock, true));\\n\" // Could have side-effects (#4355)\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void f() {\\n\"\n                              \"    std::mutex m;\\n\"\n                              \"    std::unique_lock<std::mutex> lock(m);\\n\" // #4624\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localVarClass() {\n        functionVariableUsage(\"void f() {\\n\"\n                              \"    Fred f;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"class C { int x; };\\n\"\n                              \"void f() {\\n\"\n                              \"    C c;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:3]: (style) Unused variable: c\\n\", errout.str());\n\n        functionVariableUsage(\"class C { public: C(int); ~C(); };\\n\"\n                              \"void f() {\\n\"\n                              \"    C c(12);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    // ticket #3104 - false positive when variable is read with \"if (NOT var)\"\n    void localvarIfNOT() {\n        functionVariableUsage(\"void f() {\\n\"\n                              \"    bool x = foo();\\n\"\n                              \"    if (NOT x) { }\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvarAnd() { // #3672\n        functionVariableUsage(\"int main() {\\n\"\n                              \"    unsigned flag = 0x1 << i;\\n\"\n                              \"    if (m_errorflags & flag) {\\n\"\n                              \"        return 1;\\n\"\n                              \"    }\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvarSwitch() { // #3744 - false positive when used in switch\n        functionVariableUsage(\"const char *f(int x) {\\n\"\n                              \"    const char a[] = \\\"abc\\\";\\n\"\n                              \"    const char def[] = \\\"def\\\";\\n\"\n                              \"    const char *ptr;\\n\"\n                              \"    switch(x) {\\n\"\n                              \"        case 1:  ptr=a; break;\\n\"\n                              \"        default: ptr=def; break;\\n\"\n                              \"    }\\n\"\n                              \"    return ptr;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str()); // Don't write an error that \"a\" is not used\n\n        functionVariableUsage(\"void x() {\\n\"\n                              \"    unsigned char* pcOctet = NULL;\\n\"\n                              \"    float fValeur;\\n\"\n                              \"    switch (pnodeCurrent->left.pnode->usLen) {\\n\"\n                              \"    case 4:\\n\"\n                              \"        fValeur = (float)pevalDataLeft->data.fd;\\n\"\n                              \"        pcOctet = (unsigned char*)&fValeur;\\n\"\n                              \"        break;\\n\"\n                              \"    case 8:\\n\"\n                              \"        pcOctet = (unsigned char*)&pevalDataLeft->data.fd;\\n\"\n                              \"        break;\\n\"\n                              \"    }\\n\"\n                              \"    for (iIndice = 1; iIndice <= (pnodeCurrent->usLen / 2); iIndice++) {\\n\"\n                              \"        *pcData = gacHexChar[(*pcOctet >> 4) & 0x0F];\\n\"\n                              \"    }\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str()); // Don't write an error that \"fValeur\" is not used\n    }\n\n    void localvarNULL() { // #4203 - Setting NULL value is not redundant - it is safe\n        functionVariableUsage(\"void f() {\\n\"\n                              \"    char *p = malloc(100);\\n\"\n                              \"    foo(p);\\n\"\n                              \"    free(p);\\n\"\n                              \"    p = NULL;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void f(Foo *p) {\\n\"\n                              \"    free(p);\\n\"\n                              \"    p = (Foo *)NULL;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvarUnusedGoto() {\n        // #4447\n        functionVariableUsage(\"bool f(const int &i) {\\n\"\n                              \" int X = i;\\n\"\n                              \"label:\\n\"\n                              \" if ( X == 0 ) {\\n\"\n                              \"    X -= 101;\\n\"\n                              \"    return true;\\n\"\n                              \" }\\n\"\n                              \" if ( X < 1001 )  {\\n\"\n                              \"    X += 1;\\n\"\n                              \"    goto label;\\n\"\n                              \" }\\n\"\n                              \" return false;\\n\"\n                              \"}\\n\");\n        ASSERT_EQUALS(\"[test.cpp:5]: (style) Variable 'X' is assigned a value that is never used.\\n\", errout.str());\n\n        // #4558\n        functionVariableUsage(\"int f() {\\n\"\n                              \" int i,j=0;\\n\"\n                              \" start:\\n\"\n                              \" i=j;\\n\"\n                              \" i++;\\n\"\n                              \" j=i;\\n\"\n                              \" if (i<3)\\n\"\n                              \"     goto start;\\n\"\n                              \" return i;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvarLambda() {\n        functionVariableUsage(\"int foo() {\\n\"\n                              \"    auto f = []{return 1};\\n\"\n                              \"    return f();\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"int foo() {\\n\"\n                              \"    auto f = []{return 1};\\n\"\n                              \"    auto g = []{return 1};\\n\"\n                              \"    return f() + g();\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void foo(std::vector<int>& v) {\\n\"\n                              \"    int n = 0;\\n\"\n                              \"    std::generate(v.begin(), v.end(), [&n] {\\n\"\n                              \"        int r = n;\\n\"\n                              \"        n += 2;\\n\"\n                              \"        return r;\\n\"\n                              \"    });\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvarCppInitialization() {\n        functionVariableUsage(\"void foo() {\\n\"\n                              \"    int buf[6];\\n\"\n                              \"    Data data(buf);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvarCpp11Initialization() {\n        // #6160\n        functionVariableUsage(\"void foo() {\\n\"\n                              \"    int myNewValue{ 3u };\\n\"\n                              \"    myManager.theDummyTable.addRow(UnsignedIndexValue{ myNewValue }, DummyRowData{ false });\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvarRangeBasedFor() {\n        // #7075\n        functionVariableUsage(\"void reset() {\\n\"\n                              \"    for (auto & e : array)\\n\"\n                              \"        e = 0;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvarAssignInWhile() {\n        functionVariableUsage(\"void foo() {\\n\"\n                              \"  int a = 0;\\n\"\n                              \"  do {\\n\"\n                              \"    dostuff(a);\\n\"\n                              \"  } while((a + = x) < 30);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"int foo() {\\n\"\n                              \"    int var = 1;\\n\"\n                              \"    while (var = var >> 1) { }\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvarTemplate() {\n        functionVariableUsage(\"template<int A> void f() {}\\n\"\n                              \"void foo() {\\n\"\n                              \"  const int x = 0;\\n\"\n                              \"  f<x>();\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void f() {\\n\"\n                              \"  constexpr std::size_t ArraySize(5);\\n\"\n                              \"  std::array<int, ArraySize> X; X.dostuff();\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvarFuncPtr() {\n        functionVariableUsage(\"int main() {\\n\"\n                              \"    void(*funcPtr)(void)(x);\\n\"\n                              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:2]: (style) Variable 'funcPtr' is assigned a value never used.\\n\", \"\", errout.str());\n\n        functionVariableUsage(\"int main() {\\n\"\n                              \"    void(*funcPtr)(void);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"[test.cpp:2]: (style) Unused variable: funcPtr\\n\", errout.str());\n\n        functionVariableUsage(\"int main() {\\n\"\n                              \"    void(*funcPtr)(void)(x);\\n\"\n                              \"    funcPtr();\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"int main() {\\n\"\n                              \"    void(*funcPtr)(void) = x;\\n\"\n                              \"    funcPtr();\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvarAddr() { // #7747\n        functionVariableUsage(\"void f() {\\n\"\n                              \"  int x = 0;\\n\"\n                              \"  dostuff(&x);\\n\"\n                              \"  x = 1;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void f() {\\n\"\n                              \"  int x = 0;\\n\"\n                              \"  dostuff(std::ref(x));\\n\"\n                              \"  x = 1;\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void localvarDelete() { // #8339\n        functionVariableUsage(\"void reassign(char*& data, int size)\"\n                              \"{\"\n                              \"    char* buf = new char[size];\"\n                              \"\"\n                              \"    char* tmp = data;\"\n                              \"    data = buf;\"\n                              \"    buf = tmp;\"\n                              \"\"\n                              \"    delete [] buf;\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void chainedAssignment() {\n        // #5466\n        functionVariableUsage(\"void NotUsed(double* pdD, int n) {\\n\"\n                              \"    double sum = 0.0;\\n\"\n                              \"    for (int i = 0; i<n; ++i)\\n\"\n                              \"        pdD[i] = (sum += pdD[i]);\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void crash1() {\n        functionVariableUsage(\"SAL_WNODEPRECATED_DECLARATIONS_PUSH\\n\"\n                              \"void convertToTokenArray() {\\n\"\n                              \"}\\n\"\n                              \"SAL_WNODEPRECATED_DECLARATIONS_POP\"); // #4033\n    }\n\n    void crash2() {\n        functionVariableUsage(\"template<unsigned dim>\\n\"\n                              \"struct Y: Y<dim-1> { };\\n\"\n                              \"template<>\\n\"\n                              \"struct Y<0> {};\\n\"\n                              \"void f() {\\n\"\n                              \"    Y y;\\n\"\n                              \"}\"); // #4695\n    }\n\n    void usingNamespace() {\n        functionVariableUsage(\"int foo() {\\n\"\n                              \"   using namespace ::com::sun::star::i18n;\\n\"\n                              \"   bool b = false;\\n\"\n                              \"   int j = 0;\\n\"\n                              \"   for (int i = 0; i < 3; i++) {\\n\"\n                              \"          if (!b) {\\n\"\n                              \"             j = 3;\\n\"\n                              \"             b = true;\\n\"\n                              \"          }\\n\"\n                              \"   }\\n\"\n                              \"   return j;\\n\"\n                              \"}\"); // #4585\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void lambdaFunction() {\n        // #7026\n        functionVariableUsage(\"void f() {\\n\"\n                              \"  bool first = true;\\n\"\n                              \"\\n\"\n                              \"  auto do_something = [&first]() {\\n\"\n                              \"    if (first) {\\n\"\n                              \"      first = false;\\n\"\n                              \"    } else {\\n\"\n                              \"      dostuff();\\n\"\n                              \"    }\\n\"\n                              \"  };\\n\"\n                              \"  do_something();\\n\"\n                              \"  do_something();\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n\n        // #4956 - assignment in for_each\n        functionVariableUsage(\"void f(std::vector<int> ints) {\\n\"\n                              \"  int x = 0;\\n\"\n                              \"  std::for_each(ints.begin(), ints.end(), [&x](int i){ dostuff(x); x = i; });\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\"void f(std::vector<int> ints) {\\n\"\n                              \"  int x = 0;\\n\"\n                              \"  std::for_each(ints.begin(), ints.end(), [&x](int i){ x += i; });\\n\"\n                              \"}\");\n        TODO_ASSERT_EQUALS(\"[test.cpp:3]: (style) Variable 'x' is assigned a value that is never used.\\n\", \"\", errout.str());\n    }\n\n    void namespaces() { // #7557\n        functionVariableUsage(\"namespace t { namespace g {\\n\"\n                              \"   typedef std::pair<BoostBox, size_t> value;\\n\"\n                              \"} }\\n\"\n                              \"namespace t { namespace g {} }\\n\"\n                              \"namespace t {\\n\"\n                              \"  inline double getTime() const {\\n\"\n                              \"     iterator it=find();\\n\"\n                              \"     double& value=it->second.values[index];\\n\"\n                              \"     if(isnan(value)) {\\n\"\n                              \"       value=get();\\n\"\n                              \"     }\\n\"\n                              \"     return value;\\n\"\n                              \"  }\\n\"\n                              \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void bracesInitCpp11() {\n        functionVariableUsage(\n            \"int fun() {\\n\"\n            \" static int fpUnread{0};\\n\"\n            \" const int var{fpUnread++};\\n\"\n            \" return var;\\n\"\n            \"}\\n\"\n        );\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void argument() {\n        functionVariableUsage(\n            \"void fun(Value value) {\\n\"\n            \" value[10] = 123;\\n\"\n            \"}\\n\"\n        );\n        ASSERT_EQUALS(\"\", errout.str());\n\n        functionVariableUsage(\n            \"void fun(std::string s) {\\n\"\n            \" s[10] = 123;\\n\"\n            \"}\\n\"\n        );\n        // TODO This works on command line.. load std.cfg? ASSERT_EQUALS(\"error\", errout.str());\n\n        functionVariableUsage(\n            \"void fun(short data[2]) {\\n\"\n            \"  data[2] = 1;\\n\"\n            \"}\"\n        );\n        ASSERT_EQUALS(\"\", errout.str());\n\n        // Unknown argument type\n        functionVariableUsage(\n            \"void A::b(Date& result) {\"\n            \"  result = 12;\\n\"\n            \"}\"\n        );\n        ASSERT_EQUALS(\"\", errout.str());\n\n        {\n            // #8914\n            functionVariableUsage( // assume unknown argument type is reference\n                \"void fun(Date result) {\"\n                \"  result.x = 12;\\n\"\n                \"}\"\n            );\n            ASSERT_EQUALS(\"\", errout.str());\n\n            functionVariableUsage( // there is no reference type in C\n                \"void fun(Date result) {\"\n                \"  result.x = 12;\\n\"\n                \"}\",\n                \"test.c\"\n            );\n            ASSERT_EQUALS(\"[test.c:1]: (style) Variable 'result.x' is assigned a value that is never used.\\n\", errout.str());\n\n            functionVariableUsage(\n                \"struct Date { int x; };\\n\"\n                \"void fun(Date result) {\"\n                \"  result.x = 12;\\n\"\n                \"}\"\n            );\n            ASSERT_EQUALS(\"[test.cpp:2]: (style) Variable 'result.x' is assigned a value that is never used.\\n\", errout.str());\n        }\n\n        // Unknown struct type\n        functionVariableUsage(\n            \"void fun() {\"\n            \"  struct FOO foo;\\n\"\n            \"  foo.x = 123;\\n\"\n            \"}\"\n        );\n        ASSERT_EQUALS(\"[test.cpp:2]: (style) Variable 'foo.x' is assigned a value that is never used.\\n\", errout.str());\n    }\n\n    void argumentClass() {\n        functionVariableUsage(\n            \"void foo(std::insert_iterator<C> it) {\\n\"\n            \"  it = 123;\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void escapeAlias() {\n        functionVariableUsage(\n            \"struct A {\\n\"\n            \"    std::map<int, int> m;\\n\"\n            \"    void f(int key, int number) {\\n\"\n            \"        auto pos = m.find(key);\\n\"\n            \"        if (pos == m.end())\\n\"\n            \"            m.insert(std::map<int, int>::value_type(key, number));\\n\"\n            \"        else\\n\"\n            \"            (*pos).second = number;\\n\"\n            \"    }\\n\"\n            \"};\\n\"\n        );\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n\n    void volatileData() {\n        functionVariableUsage(\n            \"struct Data { unsigned int n; };\\n\"\n            \"int main() {\\n\"\n            \"  (*(volatile struct Data*)0x4200).n = 1;\\n\"\n            \"}\");\n        ASSERT_EQUALS(\"\", errout.str());\n    }\n};\n\nREGISTER_TEST(TestUnusedVar)\n",
        "/tmp/vanessa/spack-stage/spack-stage-cppcheck-2.1-nuqkpwt6rmykw7pafaimnhmrhiu5lb4y/spack-src/test/cfg/posix.c": "\n// Test library configuration for posix.cfg\n//\n// Usage:\n// $ cppcheck --check-library --library=posix --enable=information --error-exitcode=1 --inline-suppr --suppress=missingIncludeSystem test/cfg/posix.c\n// =>\n// No warnings about bad library configuration, unmatched suppressions, etc. exitcode=0\n//\n\n#include <stdlib.h>\n#include <stdio.h> // <- FILE\n#include <dirent.h>\n#include <sys/mman.h>\n#include <sys/socket.h>\n#include <dlfcn.h>\n#include <fcntl.h>\n// unavailable on some linux systems #include <ndbm.h>\n#include <netdb.h>\n#include <regex.h>\n#include <time.h>\n#include <unistd.h>\n#include <pthread.h>\n#include <syslog.h>\n#include <stdarg.h>\n#include <ctype.h>\n#include <stdbool.h>\n\nbool invalidFunctionArgBool_isascii(bool b, int c)\n{\n    // cppcheck-suppress invalidFunctionArgBool\n    (void)isascii(b);\n    // cppcheck-suppress invalidFunctionArgBool\n    return isascii(c != 0);\n}\n\nvoid uninitvar_putenv(char * envstr)\n{\n    // No warning is expected\n    (void)putenv(envstr);\n\n    char * p;\n    // cppcheck-suppress uninitvar\n    (void)putenv(p);\n}\n\nvoid nullPointer_putenv(char * envstr)\n{\n    // No warning is expected\n    (void)putenv(envstr);\n\n    char * p=NULL;\n    // cppcheck-suppress nullPointer\n    (void)putenv(p);\n}\n\nvoid memleak_scandir(void)\n{\n    struct dirent **namelist;\n    int n = scandir(\".\", &namelist, NULL, alphasort);\n    if (n == -1) {\n        return;\n    }\n\n    // http://man7.org/linux/man-pages/man3/scandir.3.html\n    /* The scandir() function scans the directory dirp, calling filter() on\n       each directory entry.  Entries for which filter() returns nonzero are\n       stored in strings allocated via malloc(3), sorted using qsort(3) with\n       the comparison function compar(), and collected in array namelist\n       which is allocated via malloc(3).  If filter is NULL, all entries are\n       selected.*/\n\n    // TODO: cppcheck-suppress memleak\n}\n\nvoid no_memleak_scandir(void)\n{\n    struct dirent **namelist;\n    int n = scandir(\".\", &namelist, NULL, alphasort);\n    if (n == -1) {\n        return;\n    }\n    while (n--) {\n        free(namelist[n]);\n    }\n    free(namelist);\n}\n\nvoid validCode(va_list valist_arg1, va_list valist_arg2)\n{\n    void *ptr;\n    if (posix_memalign(&ptr, sizeof(void *), sizeof(void *)) == 0)\n        free(ptr);\n    syslog(LOG_ERR, \"err %u\", 0U);\n    syslog(LOG_WARNING, \"warn %d %d\", 5, 1);\n    vsyslog(LOG_EMERG, \"emerg %d\", valist_arg1);\n    vsyslog(LOG_INFO, \"test %s %d %p\", valist_arg2);\n\n    void* handle = dlopen(\"/lib.so\", RTLD_NOW);\n    if (handle) {\n        dlclose(handle);\n    }\n}\n\nvoid bufferAccessOutOfBounds(int fd)\n{\n    char a[5];\n    read(fd,a,5);\n    // cppcheck-suppress bufferAccessOutOfBounds\n    read(fd,a,6);\n    write(fd,a,5);\n    // cppcheck-suppress bufferAccessOutOfBounds\n    write(fd,a,6);\n    recv(fd,a,5,0);\n    // cppcheck-suppress bufferAccessOutOfBounds\n    recv(fd,a,6,0);\n    recvfrom(fd,a,5,0,0x0,0x0);\n    // cppcheck-suppress bufferAccessOutOfBounds\n    recvfrom(fd,a,6,0,0x0,0x0);\n    send(fd,a,5,0);\n    // cppcheck-suppress bufferAccessOutOfBounds\n    send(fd,a,6,0);\n    sendto(fd,a,5,0,0x0,0x0);\n    // cppcheck-suppress bufferAccessOutOfBounds\n    sendto(fd,a,6,0,0x0,0x0);\n    // cppcheck-suppress constStatement\n    0;\n    readlink(\"path\", a, 5);\n    // cppcheck-suppress bufferAccessOutOfBounds\n    readlink(\"path\", a, 6);\n    readlinkat(1, \"path\", a, 5);\n    // cppcheck-suppress bufferAccessOutOfBounds\n    readlinkat(1, \"path\", a, 6);\n    // This is valid\n    gethostname(a, 5);\n    // cppcheck-suppress bufferAccessOutOfBounds\n    gethostname(a, 6);\n}\n\nvoid nullPointer(char *p, int fd, pthread_mutex_t mutex)\n{\n    // cppcheck-suppress ignoredReturnValue\n    isatty(0);\n    mkdir(p, 0);\n    getcwd(0, 0);\n    // cppcheck-suppress nullPointer\n    // cppcheck-suppress readdirCalled\n    readdir(0);\n    // cppcheck-suppress nullPointer\n    // cppcheck-suppress utimeCalled\n    utime(NULL, NULL);\n    // not implemented yet: cppcheck-suppress nullPointer\n    read(fd,NULL,42);\n    read(fd,NULL,0);\n    // not implemented yet: cppcheck-suppress nullPointer\n    write(fd,NULL,42);\n    write(fd,NULL,0);\n    // cppcheck-suppress leakReturnValNotUsed\n    // cppcheck-suppress nullPointer\n    open(NULL, 0);\n    // cppcheck-suppress leakReturnValNotUsed\n    // cppcheck-suppress nullPointer\n    open(NULL, 0, 0);\n    // cppcheck-suppress unreadVariable\n    // cppcheck-suppress nullPointer\n    int ret = access(NULL, 0);\n    // cppcheck-suppress ignoredReturnValue\n    // cppcheck-suppress leakReturnValNotUsed\n    // cppcheck-suppress nullPointer\n    fdopen(fd, NULL);\n    // cppcheck-suppress strtokCalled\n    // cppcheck-suppress nullPointer\n    strtok(p, NULL);\n\n    // cppcheck-suppress nullPointer\n    pthread_mutex_init(NULL, NULL);\n    // Second argument can be NULL\n    pthread_mutex_init(&mutex, NULL);\n    // cppcheck-suppress nullPointer\n    pthread_mutex_destroy(NULL);\n    // cppcheck-suppress nullPointer\n    pthread_mutex_lock(NULL);\n    // cppcheck-suppress nullPointer\n    (void)pthread_mutex_trylock(NULL);\n    // cppcheck-suppress nullPointer\n    pthread_mutex_unlock(NULL);\n}\n\nvoid memleak_getaddrinfo()\n{\n    //TODO: nothing to report yet, see http://sourceforge.net/p/cppcheck/discussion/general/thread/d9737d5d/\n    struct addrinfo * res=NULL;\n    getaddrinfo(\"node\", NULL, NULL, &res);\n    freeaddrinfo(res);\n}\n\nvoid memleak_mmap(int fd)\n{\n    // cppcheck-suppress unreadVariable\n    void *addr = mmap(NULL, 255, PROT_NONE, MAP_PRIVATE, fd, 0);\n    // cppcheck-suppress memleak\n}\n\nvoid resourceLeak_fdopen(int fd)\n{\n    // cppcheck-suppress unreadVariable\n    FILE *f = fdopen(fd, \"r\");\n    // cppcheck-suppress resourceLeak\n}\n\nvoid resourceLeak_mkstemp(char *template)\n{\n    // cppcheck-suppress unreadVariable\n    int fp = mkstemp(template);\n    // cppcheck-suppress resourceLeak\n}\n\nvoid no_resourceLeak_mkstemp_01(char *template)\n{\n    int fp = mkstemp(template);\n    close(fp);\n}\n\nint no_resourceLeak_mkstemp_02(char *template)\n{\n    return mkstemp(template);\n}\n\nvoid resourceLeak_fdopendir(int fd)\n{\n    // cppcheck-suppress unreadVariable\n    DIR* leak1 = fdopendir(fd);\n    // cppcheck-suppress resourceLeak\n}\n\nvoid resourceLeak_opendir(void)\n{\n    // cppcheck-suppress unreadVariable\n    DIR* leak1 = opendir(\"abc\");\n    // cppcheck-suppress resourceLeak\n}\n\nvoid resourceLeak_socket(void)\n{\n    // cppcheck-suppress unreadVariable\n    int s = socket(AF_INET, SOCK_STREAM, 0);\n    // cppcheck-suppress resourceLeak\n}\n\nvoid resourceLeak_open1(void)\n{\n    // cppcheck-suppress unreadVariable\n    int fd = open(\"file\", O_RDWR | O_CREAT);\n    // cppcheck-suppress resourceLeak\n}\n\nvoid resourceLeak_open2(void)\n{\n    // cppcheck-suppress unreadVariable\n    int fd = open(\"file\", O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);\n    // cppcheck-suppress resourceLeak\n}\n\nvoid noleak(int x, int y, int z)\n{\n    DIR *p1 = fdopendir(x);\n    closedir(p1);\n    DIR *p2 = opendir(\"abc\");\n    closedir(p2);\n    int s = socket(AF_INET,SOCK_STREAM,0);\n    close(s);\n    int fd1 = open(\"a\", O_RDWR | O_CREAT);\n    close(fd1);\n    int fd2 = open(\"a\", O_RDWR | O_CREAT, S_IRUSR | S_IWUSR);\n    close(fd2);\n    /* TODO: add configuration for open/fdopen\n        // #2830\n        int fd = open(\"path\", O_RDONLY);\n        FILE *f = fdopen(fd, \"rt\");\n        fclose(f);\n    */\n}\n\n\n// unused return value\n\nvoid ignoredReturnValue(void *addr, int fd)\n{\n    // cppcheck-suppress ignoredReturnValue\n    // cppcheck-suppress leakReturnValNotUsed\n    mmap(addr, 255, PROT_NONE, MAP_PRIVATE, fd, 0);\n    // cppcheck-suppress ignoredReturnValue\n    setuid(42);\n    // cppcheck-suppress ignoredReturnValue\n    getuid();\n    // cppcheck-suppress ignoredReturnValue\n    access(\"filename\", 1);\n}\n\n\n// valid range\n\nvoid invalidFunctionArg()\n{\n    // cppcheck-suppress invalidFunctionArg\n    // cppcheck-suppress usleepCalled\n    usleep(-1);\n    // cppcheck-suppress usleepCalled\n    usleep(0);\n    // cppcheck-suppress usleepCalled\n    usleep(999999);\n    // cppcheck-suppress invalidFunctionArg\n    // cppcheck-suppress usleepCalled\n    usleep(1000000);\n}\n\nvoid invalidFunctionArg_close(int fd)\n{\n    if (fd < 0) {\n        // cppcheck-suppress invalidFunctionArg\n        (void)close(fd);\n    }\n}\n\nvoid uninitvar(int fd)\n{\n    int x1, x2, x3, x4;\n    char buf[2];\n    int decimal, sign;\n    double d;\n    void *p;\n    pthread_mutex_t mutex, mutex1, mutex2, mutex3;\n    // cppcheck-suppress uninitvar\n    write(x1,\"ab\",2);\n    // TODO cppcheck-suppress uninitvar\n    write(fd,buf,2); // #6325\n    // cppcheck-suppress uninitvar\n    write(fd,\"ab\",x2);\n    // cppcheck-suppress uninitvar\n    write(fd,p,2);\n\n\n    /* int regcomp(regex_t *restrict preg, const char *restrict pattern, int cflags); */\n    regex_t reg;\n    const char * pattern;\n    int cflags1, cflags2;\n    // cppcheck-suppress uninitvar\n    regcomp(&reg, pattern, cflags1);\n    pattern=\"\";\n    // cppcheck-suppress uninitvar\n    regcomp(&reg, pattern, cflags2);\n    regerror(0, &reg, 0, 0);\n#ifndef __CYGWIN__\n    // cppcheck-suppress uninitvar\n    // cppcheck-suppress unreadVariable\n    // cppcheck-suppress ecvtCalled\n    char *buffer = ecvt(d, 11, &decimal, &sign);\n#endif\n    // cppcheck-suppress gcvtCalled\n    gcvt(3.141, 2, buf);\n\n    char *filename;\n    struct utimbuf *times;\n    // cppcheck-suppress uninitvar\n    // cppcheck-suppress utimeCalled\n    utime(filename, times);\n    struct timeval times1[2];\n    // cppcheck-suppress uninitvar\n    // cppcheck-suppress utimeCalled\n    utime(filename, times1);\n\n    // cppcheck-suppress unreadVariable\n    // cppcheck-suppress uninitvar\n    int access_ret = access(\"file\", x3);\n\n    // cppcheck-suppress ignoredReturnValue\n    // cppcheck-suppress leakReturnValNotUsed\n    // cppcheck-suppress uninitvar\n    fdopen(x4, \"rw\");\n\n    char *strtok_arg1;\n    // cppcheck-suppress strtokCalled\n    // cppcheck-suppress uninitvar\n    strtok(strtok_arg1, \";\");\n\n    // cppcheck-suppress uninitvar\n    pthread_mutex_lock(&mutex1);\n    // cppcheck-suppress uninitvar\n    (void)pthread_mutex_trylock(&mutex2);\n    // cppcheck-suppress uninitvar\n    pthread_mutex_unlock(&mutex3);\n    // after initialization it must be OK to call lock, trylock and unlock for this mutex\n    pthread_mutex_init(&mutex, NULL);\n    pthread_mutex_lock(&mutex);\n    (void)pthread_mutex_trylock(&mutex);\n    pthread_mutex_unlock(&mutex);\n}\n\nvoid uninitvar_getcwd(void)\n{\n    char *buf;\n    size_t size;\n    // cppcheck-suppress uninitvar\n    (void)getcwd(buf,size);\n}\n\n\nvoid uninitvar_types(void)\n{\n    // cppcheck-suppress unassignedVariable\n    blkcnt_t b;\n    // cppcheck-suppress uninitvar\n    b + 1;\n\n    struct dirent d;\n    // TODO cppcheck-suppress uninitvar\n    d.d_ino + 1;\n}\n\nvoid timet_h(struct timespec* ptp1)\n{\n    clockid_t clk_id1, clk_id2, clk_id3;\n    struct timespec* ptp;\n    // cppcheck-suppress uninitvar\n    clock_settime(CLOCK_REALTIME, ptp);\n    // cppcheck-suppress uninitvar\n    clock_settime(clk_id1, ptp);\n    // cppcheck-suppress uninitvar\n    clock_settime(clk_id2, ptp1);\n\n    struct timespec tp;\n    // TODO cppcheck-suppress uninitvar\n    clock_settime(CLOCK_REALTIME, &tp); // #6577 - false negative\n    // cppcheck-suppress uninitvar\n    clock_settime(clk_id3, &tp);\n\n    time_t clock = time(0);\n    char buf[26];\n    // cppcheck-suppress ctime_rCalled\n    ctime_r(&clock, buf);\n}\n\nvoid dl(const char* libname, const char* func)\n{\n    void* lib = dlopen(libname, RTLD_NOW);\n    // cppcheck-suppress redundantInitialization\n    // cppcheck-suppress resourceLeak\n    lib = dlopen(libname, RTLD_LAZY);\n    const char* funcname;\n    // cppcheck-suppress uninitvar\n    // cppcheck-suppress unreadVariable\n    void* sym = dlsym(lib, funcname);\n    // cppcheck-suppress ignoredReturnValue\n    dlsym(lib, \"foo\");\n    void* uninit;\n    // cppcheck-suppress uninitvar\n    dlclose(uninit);\n    // cppcheck-suppress resourceLeak\n}\n\nvoid asctime_r_test(struct tm * tm, char * bufSizeUnknown)\n{\n    struct tm tm_uninit_data;\n    struct tm * tm_uninit_pointer;\n    char bufSize5[5];\n    char bufSize25[25];\n    char bufSize26[26];\n    char bufSize100[100];\n\n    // cppcheck-suppress asctime_rCalled\n    // cppcheck-suppress bufferAccessOutOfBounds\n    asctime_r(tm, bufSize5);\n    // cppcheck-suppress asctime_rCalled\n    // cppcheck-suppress bufferAccessOutOfBounds\n    asctime_r(tm, bufSize25);\n    // cppcheck-suppress asctime_rCalled\n    asctime_r(tm, bufSize26);\n    // cppcheck-suppress asctime_rCalled\n    asctime_r(tm, bufSize100);\n\n    // cppcheck-suppress asctime_rCalled\n    // cppcheck-suppress uninitvar\n    asctime_r(&tm_uninit_data, bufSize100);\n    // cppcheck-suppress asctime_rCalled\n    // cppcheck-suppress uninitvar\n    asctime_r(tm_uninit_pointer, bufSize100);\n\n    // cppcheck-suppress asctime_rCalled\n    asctime_r(tm, bufSizeUnknown);\n}\n\nvoid ctime_r_test(time_t * timep, char * bufSizeUnknown)\n{\n    time_t time_t_uninit_data;\n    time_t * time_t_uninit_pointer;\n    char bufSize5[5];\n    char bufSize25[25];\n    char bufSize26[26];\n    char bufSize100[100];\n\n    // cppcheck-suppress ctime_rCalled\n    // cppcheck-suppress bufferAccessOutOfBounds\n    ctime_r(timep, bufSize5);\n    // cppcheck-suppress ctime_rCalled\n    // cppcheck-suppress bufferAccessOutOfBounds\n    ctime_r(timep, bufSize25);\n    // cppcheck-suppress ctime_rCalled\n    ctime_r(timep, bufSize26);\n    // cppcheck-suppress ctime_rCalled\n    ctime_r(timep, bufSize100);\n\n    // cppcheck-suppress ctime_rCalled\n    // cppcheck-suppress uninitvar\n    ctime_r(&time_t_uninit_data, bufSize100);\n    // cppcheck-suppress ctime_rCalled\n    // cppcheck-suppress uninitvar\n    ctime_r(time_t_uninit_pointer, bufSize100);\n\n    // cppcheck-suppress ctime_rCalled\n    ctime_r(timep, bufSizeUnknown);\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-cppcheck-2.1-nuqkpwt6rmykw7pafaimnhmrhiu5lb4y/spack-src/snap/gui/cppcheck-gui.png",
        "/tmp/vanessa/spack-stage/spack-stage-cppcheck-2.1-nuqkpwt6rmykw7pafaimnhmrhiu5lb4y/spack-src/man/images/gui-results.png",
        "/tmp/vanessa/spack-stage/spack-stage-cppcheck-2.1-nuqkpwt6rmykw7pafaimnhmrhiu5lb4y/spack-src/man/images/gui-newproject-addons.png",
        "/tmp/vanessa/spack-stage/spack-stage-cppcheck-2.1-nuqkpwt6rmykw7pafaimnhmrhiu5lb4y/spack-src/man/images/gui-newproject-pathsanddefines.png",
        "/tmp/vanessa/spack-stage/spack-stage-cppcheck-2.1-nuqkpwt6rmykw7pafaimnhmrhiu5lb4y/spack-src/man/images/gui-newproject.png",
        "/tmp/vanessa/spack-stage/spack-stage-cppcheck-2.1-nuqkpwt6rmykw7pafaimnhmrhiu5lb4y/spack-src/man/images/gui-newproject-project.png",
        "/tmp/vanessa/spack-stage/spack-stage-cppcheck-2.1-nuqkpwt6rmykw7pafaimnhmrhiu5lb4y/spack-src/test/bug-hunting/cve/CVE-2019-19888/jfif.c",
        "/tmp/vanessa/spack-stage/spack-stage-cppcheck-2.1-nuqkpwt6rmykw7pafaimnhmrhiu5lb4y/spack-src/addons/test/misra/misra2012_rules_dummy_windows1250.txt",
        "/tmp/vanessa/spack-stage/spack-stage-cppcheck-2.1-nuqkpwt6rmykw7pafaimnhmrhiu5lb4y/spack-src/addons/doc/img/cppcheck-gui-addons.png",
        "/tmp/vanessa/spack-stage/spack-stage-cppcheck-2.1-nuqkpwt6rmykw7pafaimnhmrhiu5lb4y/spack-src/win_installer/images/banner.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-cppcheck-2.1-nuqkpwt6rmykw7pafaimnhmrhiu5lb4y/spack-src/win_installer/images/dialog.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-cppcheck-2.1-nuqkpwt6rmykw7pafaimnhmrhiu5lb4y/spack-src/gui/cppcheck.ico",
        "/tmp/vanessa/spack-stage/spack-stage-cppcheck-2.1-nuqkpwt6rmykw7pafaimnhmrhiu5lb4y/spack-src/gui/cppcheck-gui.png",
        "/tmp/vanessa/spack-stage/spack-stage-cppcheck-2.1-nuqkpwt6rmykw7pafaimnhmrhiu5lb4y/spack-src/gui/images/applications-system.png",
        "/tmp/vanessa/spack-stage/spack-stage-cppcheck-2.1-nuqkpwt6rmykw7pafaimnhmrhiu5lb4y/spack-src/gui/images/showerrors.png",
        "/tmp/vanessa/spack-stage/spack-stage-cppcheck-2.1-nuqkpwt6rmykw7pafaimnhmrhiu5lb4y/spack-src/gui/images/go-down.png",
        "/tmp/vanessa/spack-stage/spack-stage-cppcheck-2.1-nuqkpwt6rmykw7pafaimnhmrhiu5lb4y/spack-src/gui/images/media-floppy.png",
        "/tmp/vanessa/spack-stage/spack-stage-cppcheck-2.1-nuqkpwt6rmykw7pafaimnhmrhiu5lb4y/spack-src/gui/images/scratchpad.png",
        "/tmp/vanessa/spack-stage/spack-stage-cppcheck-2.1-nuqkpwt6rmykw7pafaimnhmrhiu5lb4y/spack-src/gui/images/view-refresh.png",
        "/tmp/vanessa/spack-stage/spack-stage-cppcheck-2.1-nuqkpwt6rmykw7pafaimnhmrhiu5lb4y/spack-src/gui/images/process-stop.png",
        "/tmp/vanessa/spack-stage/spack-stage-cppcheck-2.1-nuqkpwt6rmykw7pafaimnhmrhiu5lb4y/spack-src/gui/images/view-recheck.png",
        "/tmp/vanessa/spack-stage/spack-stage-cppcheck-2.1-nuqkpwt6rmykw7pafaimnhmrhiu5lb4y/spack-src/gui/images/showwarnings.png",
        "/tmp/vanessa/spack-stage/spack-stage-cppcheck-2.1-nuqkpwt6rmykw7pafaimnhmrhiu5lb4y/spack-src/gui/images/showperformance.png",
        "/tmp/vanessa/spack-stage/spack-stage-cppcheck-2.1-nuqkpwt6rmykw7pafaimnhmrhiu5lb4y/spack-src/gui/images/applications-development.png",
        "/tmp/vanessa/spack-stage/spack-stage-cppcheck-2.1-nuqkpwt6rmykw7pafaimnhmrhiu5lb4y/spack-src/gui/images/go-next.png",
        "/tmp/vanessa/spack-stage/spack-stage-cppcheck-2.1-nuqkpwt6rmykw7pafaimnhmrhiu5lb4y/spack-src/gui/images/edit-clear.png",
        "/tmp/vanessa/spack-stage/spack-stage-cppcheck-2.1-nuqkpwt6rmykw7pafaimnhmrhiu5lb4y/spack-src/gui/images/go-previous.png",
        "/tmp/vanessa/spack-stage/spack-stage-cppcheck-2.1-nuqkpwt6rmykw7pafaimnhmrhiu5lb4y/spack-src/gui/images/dialog-error.png",
        "/tmp/vanessa/spack-stage/spack-stage-cppcheck-2.1-nuqkpwt6rmykw7pafaimnhmrhiu5lb4y/spack-src/gui/images/utilities-system-monitor.png",
        "/tmp/vanessa/spack-stage/spack-stage-cppcheck-2.1-nuqkpwt6rmykw7pafaimnhmrhiu5lb4y/spack-src/gui/images/preferences-system.png",
        "/tmp/vanessa/spack-stage/spack-stage-cppcheck-2.1-nuqkpwt6rmykw7pafaimnhmrhiu5lb4y/spack-src/gui/images/showstylewarnings.png",
        "/tmp/vanessa/spack-stage/spack-stage-cppcheck-2.1-nuqkpwt6rmykw7pafaimnhmrhiu5lb4y/spack-src/gui/images/text-x-generic.png",
        "/tmp/vanessa/spack-stage/spack-stage-cppcheck-2.1-nuqkpwt6rmykw7pafaimnhmrhiu5lb4y/spack-src/gui/images/openproject.png",
        "/tmp/vanessa/spack-stage/spack-stage-cppcheck-2.1-nuqkpwt6rmykw7pafaimnhmrhiu5lb4y/spack-src/gui/images/help-browser.png",
        "/tmp/vanessa/spack-stage/spack-stage-cppcheck-2.1-nuqkpwt6rmykw7pafaimnhmrhiu5lb4y/spack-src/gui/images/llvm-dragon.png",
        "/tmp/vanessa/spack-stage/spack-stage-cppcheck-2.1-nuqkpwt6rmykw7pafaimnhmrhiu5lb4y/spack-src/gui/images/go-home.png",
        "/tmp/vanessa/spack-stage/spack-stage-cppcheck-2.1-nuqkpwt6rmykw7pafaimnhmrhiu5lb4y/spack-src/gui/images/dialog-warning.png",
        "/tmp/vanessa/spack-stage/spack-stage-cppcheck-2.1-nuqkpwt6rmykw7pafaimnhmrhiu5lb4y/spack-src/gui/images/dialog-information.png"
    ],
    "total_files": 804
}