{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-slang-2.3.1-ckai3zgicxvtap5jn7nixag4rkbyrsm2/spack-src/src/slimport.c": "/*\nCopyright (C) 2004-2016 John E. Davis\n\nThis file is part of the S-Lang Library.\n\nThe S-Lang Library is free software; you can redistribute it and/or\nmodify it under the terms of the GNU General Public License as\npublished by the Free Software Foundation; either version 2 of the\nLicense, or (at your option) any later version.\n\nThe S-Lang Library is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\nGeneral Public License for more details.\n\nYou should have received a copy of the GNU General Public License\nalong with this library; if not, write to the Free Software\nFoundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307,\nUSA.\n*/\n\n#include \"slinclud.h\"\n\n#include \"slang.h\"\n#include \"_slang.h\"\n\n#if defined (HAVE_DLFCN_H) || defined(__WIN32__)\n# define SLANG_HAS_DYNAMIC_LINKING\t1\n#else\n# define SLANG_HAS_DYNAMIC_LINKING\t0\n#endif\n\n/* The rest of this file is in the if block */\n#if SLANG_HAS_DYNAMIC_LINKING\n\n#ifdef HAVE_DLFCN_H\n# include <dlfcn.h>\n#endif\n\n#ifdef __WIN32__\n# include <windows.h>\n# define dlopen(a, b) LoadLibrary(a)\n# define dlsym (void *)GetProcAddress\n# define dlclose FreeLibrary\n# define dlerror() NULL\n# define SO_SUFFIX \"dll\"\n#else\n# define SO_SUFFIX \"so\"\n#endif\n\nstatic SLFUTURE_CONST char *Module_Path;\n#ifndef MODULE_PATH_ENV_NAME\n# define MODULE_PATH_ENV_NAME \"SLANG_MODULE_PATH\"\n#endif\n#ifndef MODULE_INSTALL_DIR\n# define MODULE_INSTALL_DIR \"/usr/local/lib/slang/v2/modules\"\n#endif\n\n#define MAX_MODULE_NAME_SIZE 256\n\ntypedef struct Namespace_List_Type\n{\n   char *ns;\n   struct Namespace_List_Type *next;\n}\nNamespace_List_Type;\n\ntypedef struct _Handle_Type\n{\n   struct _Handle_Type *next;\n   char *module_name;\n   VOID_STAR handle;\n   int (*ns_init_fun) (SLCONST char *);\n   void (*deinit_fun) (void);\n   Namespace_List_Type *ns_list;\n}\nHandle_Type;\n\nstatic Handle_Type *Handle_List;\n\nstatic void free_namespace_list (Namespace_List_Type *ns_list)\n{\n   while (ns_list != NULL)\n     {\n\tNamespace_List_Type *next = ns_list->next;\n\tSLang_free_slstring (ns_list->ns);\n\tSLfree ((char *)ns_list);\n\tns_list = next;\n     }\n}\n\nstatic void free_handle_type (Handle_Type *h)\n{\n   if (h == NULL)\n     return;\n\n   SLang_free_slstring (h->module_name);\n   free_namespace_list (h->ns_list);\n   SLfree ((char *)h);\n}\n\nstatic void delete_handles (void)\n{\n   while (Handle_List != NULL)\n     {\n\tHandle_Type *next = Handle_List->next;\n\n\tif (Handle_List->deinit_fun != NULL)\n\t  Handle_List->deinit_fun ();\n\t/* (void) dlclose (Handle_List->handle); */\n\tfree_handle_type (Handle_List);\n\tHandle_List = next;\n     }\n}\n\nstatic Handle_Type *allocate_handle_type (SLFUTURE_CONST char *module_name, VOID_STAR handle)\n{\n   Handle_Type *h;\n\n   h = (Handle_Type *) SLcalloc (1, sizeof (Handle_Type));\n   if (h == NULL)\n     return NULL;\n   if (NULL == (h->module_name = SLang_create_slstring (module_name)))\n     {\n\tSLfree ((char *) h);\n\treturn NULL;\n     }\n   h->handle = handle;\n   return h;\n}\n\nstatic Handle_Type *find_handle (SLCONST char *module_name)\n{\n   Handle_Type *l;\n\n   l = Handle_List;\n   while (l != NULL)\n     {\n\tif (0 == strcmp (l->module_name, module_name))\n\t  break;\n\tl = l->next;\n     }\n   return l;\n}\n\nstatic int check_api_version (char *file, int api_version)\n{\n   if (api_version/10000 == SLANG_VERSION/10000)\n     return 0;\n\n   _pSLang_verror (SL_Import_Error, \"Module %s is incompatible with this version of S-Lang\",\n\t\t file);\n   return -1;\n}\n\n#if defined(__GNUC__)\n# pragma GCC diagnostic ignored \"-Wformat-nonliteral\"\n#endif\nstatic VOID_STAR do_dlsym (VOID_STAR handle, SLFUTURE_CONST char *file, int check_error, SLFUTURE_CONST char *fmt, char *module)\n{\n   char symbol[MAX_MODULE_NAME_SIZE + 32];\n   VOID_STAR s;\n\n   SLsnprintf (symbol, sizeof(symbol), fmt, module);\n   if (NULL != (s = (VOID_STAR) dlsym (handle, symbol)))\n     return s;\n\n   if (check_error)\n     {\n\tSLCONST char *err;\n\n\tif (NULL == (err = (char *) dlerror ()))\n\t  err = \"UNKNOWN\";\n\n\t_pSLang_verror (SL_Import_Error,\n\t\t      \"Unable to get symbol %s from %s: %s\",\n\t\t      symbol, file, err);\n     }\n   return NULL;\n}\n#if defined(__GNUC__)\n# pragma GCC diagnostic warning \"-Wformat-nonliteral\"\n#endif\n\nstatic Handle_Type *dynamic_link_module (SLFUTURE_CONST char *module)\n{\n   Handle_Type *h;\n   VOID_STAR handle;\n   SLFUTURE_CONST char *err;\n   char filebuf[1024];\n   char *save_file;\n   char *save_err;\n   int api_version;\n   int *api_version_ptr;\n#define MAX_MODULE_NAME_SIZE 256\n   char module_so[MAX_MODULE_NAME_SIZE + 32];\n   char *module_name;\n   char *file, *pathfile;\n\n   if (strlen (module) >= MAX_MODULE_NAME_SIZE)\n     {\n\t_pSLang_verror (SL_LimitExceeded_Error, \"module name too long\");\n\treturn NULL;\n     }\n   SLsnprintf (module_so, sizeof(module_so), \"%s-module.%s\", module, SO_SUFFIX);\n\n   if (Module_Path != NULL)\n     pathfile = SLpath_find_file_in_path (Module_Path, module_so);\n   else pathfile = NULL;\n\n   if ((pathfile == NULL)\n       && (NULL != (pathfile = _pSLsecure_getenv (MODULE_PATH_ENV_NAME))))\n     pathfile = SLpath_find_file_in_path (pathfile, module_so);\n\n   if (pathfile == NULL)\n     pathfile = SLpath_find_file_in_path (MODULE_INSTALL_DIR, module_so);\n\n   if (pathfile != NULL)\n     file = pathfile;\n   else\n     file = module_so;\n\n   save_err = NULL;\n   save_file = file;\n   while (1)\n     {\n#ifndef RTLD_GLOBAL\n# define RTLD_GLOBAL 0\n#endif\n#ifdef RTLD_NOW\n\thandle = (VOID_STAR) dlopen (file, RTLD_NOW | RTLD_GLOBAL);\n#else\n\thandle = (VOID_STAR) dlopen (file, RTLD_LAZY | RTLD_GLOBAL);\n#endif\n\n\tif (handle != NULL)\n\t  {\n\t     if (_pSLang_Load_File_Verbose & SLANG_LOAD_MODULE_VERBOSE)\n\t       SLang_vmessage (\"Importing %s\", file);\n\t     if (save_err != NULL)\n\t       SLfree (save_err);\n\t     break;\n\t  }\n\n\t/* Purify reports that dlerror returns a pointer that generates UMR\n\t * errors.  There is nothing that I can do about that....\n\t */\n\tif ((NULL == strchr (file, '/'))\n\t    && (strlen(file) < sizeof(filebuf)))\n\t  {\n\t     err = (char *) dlerror ();\n\t     if (err != NULL)\n\t       save_err = SLmake_string (err);\n\n\t     SLsnprintf (filebuf, sizeof (filebuf), \"./%s\", file);\n\t     file = filebuf;\n\t     continue;\n\t  }\n\n\tif ((NULL == (err = save_err))\n\t    && (NULL == (err = (char *) dlerror ())))\n\t  err = \"UNKNOWN\";\n\n\t_pSLang_verror (SL_Import_Error,\n\t\t      \"Error linking to %s: %s\", save_file, err);\n\n\tif (save_err != NULL)\n\t  SLfree (save_err);\n\tif (pathfile != NULL)\n\t  SLfree (pathfile);\n\n\treturn NULL;\n     }\n\n   /* Using SLpath_basename allows, e.g., import (\"/path/to/module\"); */\n   module_name = SLpath_basename (module);\n\n   api_version_ptr = (int *) do_dlsym (handle, file, 0, \"SLmodule_%s_api_version\", module_name);\n   if (api_version_ptr == NULL)\n     api_version_ptr = (int *) do_dlsym (handle, file, 0, \"_SLmodule_%s_api_version\", module_name);\n\n   if (api_version_ptr == NULL)\n     api_version = 0;\n   else\n     api_version = *api_version_ptr;\n\n   if ((-1 == check_api_version (file, api_version))\n       || (NULL == (h = allocate_handle_type (module, handle))))\n     {\n\tSLfree (pathfile);\t       /* NULL ok */\n\tdlclose (handle);\n\treturn NULL;\n     }\n\n   if (NULL == (h->ns_init_fun = (int (*)(SLCONST char *)) do_dlsym (handle, file, 1, \"init_%s_module_ns\", module_name)))\n     {\n\tSLfree (pathfile);\n\tfree_handle_type (h);\n\tdlclose (handle);\n\treturn NULL;\n     }\n   h->deinit_fun = (void (*)(void)) do_dlsym (handle, file, 0, \"deinit_%s_module\", module_name);\n\n   SLfree (pathfile);\t\t       /* NULL ok */\n   h->next = Handle_List;\n   Handle_List = h;\n\n   return h;\n}\n\nstatic int import_module (SLFUTURE_CONST char *module, SLFUTURE_CONST char *ns)\n{\n   Handle_Type *h;\n   Namespace_List_Type *ns_list;\n\n   if (ns == NULL)\n     ns = _pSLang_cur_namespace_intrinsic ();\n\n   if (*ns == 0)\n     ns = \"Global\";\n\n   if ((NULL == (h = find_handle (module)))\n       && (NULL == (h = dynamic_link_module (module))))\n     return -1;\n\n   ns_list = h->ns_list;\n   while (ns_list != NULL)\n     {\n\tif (0 == strcmp (ns, ns_list->ns))\n\t  return 0;\t\t       /* already linked to this ns */\n\tns_list = ns_list->next;\n     }\n\n   if (NULL == (ns_list = (Namespace_List_Type *)SLmalloc (sizeof (Namespace_List_Type))))\n     return -1;\n\n   if (NULL == (ns_list->ns = SLang_create_slstring (ns)))\n     {\n\tSLfree ((char *)ns_list);\n\treturn -1;\n     }\n   ns_list->next = h->ns_list;\n   h->ns_list = ns_list;\n\n   if (-1 == (h->ns_init_fun (ns)))\n     return -1;\n\n   return 0;\n}\n\nstatic void import_module_intrin (void)\n{\n   char *module;\n   char *ns = NULL;\n\n   if (SLang_Num_Function_Args == 2)\n     {\n\tif (-1 == SLang_pop_slstring (&ns))\n\t  return;\n     }\n\n   if (-1 == SLang_pop_slstring (&module))\n     {\n\tSLang_free_slstring (ns);      /* NULL ok */\n\treturn;\n     }\n\n   (void) import_module (module, ns);\n   SLang_free_slstring (module);\n   SLang_free_slstring (ns);\t       /* NULL ok */\n}\n\nstatic void set_import_module_path (char *path)\n{\n   (void) SLang_set_module_load_path (path);\n}\n\nstatic SLCONST char *get_import_module_path (void)\n{\n   char *path;\n   if (Module_Path != NULL)\n     return Module_Path;\n   if (NULL != (path = _pSLsecure_getenv (MODULE_PATH_ENV_NAME)))\n     return path;\n   return MODULE_INSTALL_DIR;\n}\n\nstatic SLang_Intrin_Fun_Type Module_Intrins [] =\n{\n   MAKE_INTRINSIC_0(\"import\", import_module_intrin, SLANG_VOID_TYPE),\n   MAKE_INTRINSIC_S(\"set_import_module_path\", set_import_module_path, SLANG_VOID_TYPE),\n   MAKE_INTRINSIC_0(\"get_import_module_path\", get_import_module_path, SLANG_STRING_TYPE),\n   SLANG_END_INTRIN_FUN_TABLE\n};\n\n#endif\t\t\t\t       /* SLANG_HAS_DYNAMIC_LINKING */\n\nint SLang_set_module_load_path (SLFUTURE_CONST char *path)\n{\n#if SLANG_HAS_DYNAMIC_LINKING\n   if (NULL == (path = SLang_create_slstring (path)))\n     return -1;\n   SLang_free_slstring ((char *) Module_Path);\n   Module_Path = path;\n   return 0;\n#else\n   (void) path;\n   return -1;\n#endif\n}\n\nint SLang_init_import (void)\n{\n#if SLANG_HAS_DYNAMIC_LINKING\n   (void) SLang_add_cleanup_function (delete_handles);\n   return SLadd_intrin_fun_table (Module_Intrins, \"__IMPORT__\");\n#else\n   return 0;\n#endif\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-slang-2.3.1-ckai3zgicxvtap5jn7nixag4rkbyrsm2/spack-src/changes.txt",
        "/tmp/vanessa/spack-stage/spack-stage-slang-2.3.1-ckai3zgicxvtap5jn7nixag4rkbyrsm2/spack-src/utf8/testfiles/UTF-8-test.txt",
        "/tmp/vanessa/spack-stage/spack-stage-slang-2.3.1-ckai3zgicxvtap5jn7nixag4rkbyrsm2/spack-src/src/slutf8.c",
        "/tmp/vanessa/spack-stage/spack-stage-slang-2.3.1-ckai3zgicxvtap5jn7nixag4rkbyrsm2/spack-src/src/sltoken.c",
        "/tmp/vanessa/spack-stage/spack-stage-slang-2.3.1-ckai3zgicxvtap5jn7nixag4rkbyrsm2/spack-src/src/mkfiles/mkmake16.exe",
        "/tmp/vanessa/spack-stage/spack-stage-slang-2.3.1-ckai3zgicxvtap5jn7nixag4rkbyrsm2/spack-src/src/mkfiles/mkmake.exe",
        "/tmp/vanessa/spack-stage/spack-stage-slang-2.3.1-ckai3zgicxvtap5jn7nixag4rkbyrsm2/spack-src/slsh/mkfiles/slsh.ico",
        "/tmp/vanessa/spack-stage/spack-stage-slang-2.3.1-ckai3zgicxvtap5jn7nixag4rkbyrsm2/spack-src/slsh/mkfiles/sldoc.ico"
    ],
    "total_files": 525
}