{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/configure.ac": "# DO NOT EDIT ./configure FILE\n# One should edit configure.ac and the run autoconf in this\n# directory. Also the resulting \"configure\" is stored on the git,\n# so as to allow people not to install a recent autoconf on their\n# system.\n# If you modify configure.ac, remember to run\n# autoconf and then commit both files to the git repository.\n\n# we require a recent version\n# notice that autoconf is not necessary on user's machine, but only\n# if one has to update configure.ac\nAC_PREREQ([2.68])\nAC_INIT([PLUMED], [2])\n\n##################################################################\n# In order to add m4 macros, put then in a m4 directory and include them here.\n# E.g.:\n# m4_include([./m4/m4_ax_openmp.m4])\n\n##################################################################\n# Here we define a few useful macros\n\n# PLUMED_CONFIG_ENABLE(variablename,optionname,doc,default)\n# notice that variablename and optionname are likely identical,\n# they just need to be different with optionname contains a \"-\"\n# (not allowed in shell variable names)\nAC_DEFUN([PLUMED_CONFIG_ENABLE], [\nm4_bpatsubst([$1],-,_)=\nAC_ARG_ENABLE([$1],\n  AS_HELP_STRING([--enable-$1], [enable $2, default: $3]),\n  [case \"${enableval}\" in\n             (yes) m4_bpatsubst([$1],-,_)=true ;;\n             (no)  m4_bpatsubst([$1],-,_)=false ;;\n             (*)   AC_MSG_ERROR([wrong argument to --enable-$1]) ;;\n  esac],\n  [case \"$3\" in\n             (yes) m4_bpatsubst([$1],-,_)=true ;;\n             (no)  m4_bpatsubst([$1],-,_)=false ;;\n  esac]\n)\n])\n\n# PLUMED_CHECK_CXXFLAG(flag)\n# use it to check if a flag is available on this compiler\nAC_DEFUN([PLUMED_CHECK_CXXFLAG], [\n  save_CXXFLAGS=\"$CXXFLAGS\"\n  CXXFLAGS=\"$CXXFLAGS $1\"\n  AC_MSG_CHECKING([whether $CXX accepts $1])\n  AC_COMPILE_IFELSE([AC_LANG_PROGRAM([])],\n    [\n      AC_LINK_IFELSE([AC_LANG_PROGRAM([])],\n        [AC_MSG_RESULT([yes])],\n        [AC_MSG_RESULT([not linking]); CXXFLAGS=\"$save_CXXFLAGS\"])\n    ],\n    [AC_MSG_RESULT([no]); CXXFLAGS=\"$save_CXXFLAGS\"]\n  )\n])\n\n# PLUMED_CHECK_CFLAG(flag)\n# use it to check if a flag is available on this compiler\nAC_DEFUN([PLUMED_CHECK_CFLAG], [\n  AC_LANG_PUSH(C)\n  save_CFLAGS=\"$CFLAGS\"\n  CFLAGS=\"$CFLAGS $1\"\n  AC_MSG_CHECKING([whether $CC accepts $1])\n  AC_COMPILE_IFELSE([AC_LANG_PROGRAM([])],\n    [\n      AC_LINK_IFELSE([AC_LANG_PROGRAM([])],\n        [AC_MSG_RESULT([yes])],\n        [AC_MSG_RESULT([not linking]); CCFLAGS=\"$save_CCFLAGS\"])\n    ],\n    [AC_MSG_RESULT([no]); CCFLAGS=\"$save_CCFLAGS\"]\n  )\n  AC_LANG_POP\n])\n\n# PLUMED_CHECK_LDFLAGS(flag)\n# use it to check if a flag is available on this compiler\nAC_DEFUN([PLUMED_CHECK_LDFLAGS], [\n  save_LDFLAGS=\"$LDFLAGS\"\n  LDFLAGS=\"$LDFLAGS $1\"\n  AC_MSG_CHECKING([whether LDFLAGS can contain $1])\n  AC_LINK_IFELSE([AC_LANG_PROGRAM([])],\n    [AC_MSG_RESULT([yes])],\n    [AC_MSG_RESULT([no]); LDFLAGS=\"$save_LDFLAGS\"])\n])\n\n# PLUMED_SEARCH_LIBS(function,search-libs[,action-if-found][,action-if-not-found][,other-libraries])\n# same as AC_SEARCH_LIBS, but does not try any library unless $libsearch==true\n# Should be used instead of AC_SEARCH_LIBS in order to make --disable-libsearch work correctly\nAC_DEFUN([PLUMED_SEARCH_LIBS], [\n  if test \"${libsearch}\" == true ; then\n    AC_SEARCH_LIBS([$1],[$2],[$3],[$4],[$5])\n  else\n    AC_SEARCH_LIBS([$1],[],[$3],[$4],[])\n  fi\n])\n\n# PLUMED_CHECK_PACKAGE(header,function,define[,library])\n# first we check if the header is present. if so, we check if the given function can be found.\n# if it cannot be found and the fourth argument (library) has been supplied, we look for it\n# in the library. finally, we set the define flag\nAC_DEFUN([PLUMED_CHECK_PACKAGE], [\n    found=ko\n    $3=no\n    AC_CHECK_HEADER( [$1],[\n      PLUMED_SEARCH_LIBS([$2],[$4],[found=ok])\n    ])\n    if test $found == ok ; then\n       AC_DEFINE([$3])\n       $3=yes\n    else\n       AC_MSG_WARN([cannot enable $3]) \n    fi\n])\n\n# PLUMED_CHECK_CXX_PACKAGE(name,program,define[,library])\n# Similar to PLUMED_CHECK_PACKAGE but suitable for checking C++ libraries.\n# Name is just a string used in the configure log\n# program is a string containing a short C++ program that should compiled.\n# If present and necessary, library is also linked.\nAC_DEFUN([PLUMED_CHECK_CXX_PACKAGE], [\n    found=ko\n    $3=no\n    if test \"${libsearch}\" == true ; then\n      testlibs=\"$4\"\n    else\n      testlibs=\"\"\n    fi\n    for testlib in \"\" $testlibs\n    do\n      save_LIBS=\"$LIBS\"\n      if test -n \"$testlib\" ; then\n        AC_MSG_CHECKING([$1 with -l$testlib])\n        LIBS=\"-l$testlib $LIBS\"\n      else\n        AC_MSG_CHECKING([$1 without extra libs])\n      fi\n      AC_LINK_IFELSE([AC_LANG_SOURCE([$2])],\n          [found=ok]\n          [AC_MSG_RESULT([yes])],\n          [AC_MSG_RESULT([no])]\n      )\n      if test $found == ok ; then\n        break\n      fi\n      LIBS=\"$save_LIBS\"\n    done\n    if test $found == ok ; then\n      AC_DEFINE([$3])\n      $3=yes\n    else\n      AC_MSG_WARN([cannot enable $3]) \n      LIBS=\"$save_LIBS\"\n    fi\n])\n\n##################################################################\n\nAC_MSG_NOTICE([Optional modules are disabled by default])\nrm -f src/*.on src/*.off\n\nAC_ARG_ENABLE([modules],\n  AS_HELP_STRING([--enable-modules], [all/none/reset or : separated list such as +crystallization:-bias default: reset]),\n  [\n   rm -f src/*.on src/*.off\n   if test \"${enableval}\" == yes ; then\n     enableval=reset\n   fi\n   if test \"${enableval}\" == no ; then\n     enableval=none\n   fi\n   for modules_mod in `echo \"${enableval}\" | sed 's/:/ /g' | sed 's/+/ +/g' | sed 's/-/ -/g'`\n   do\n     case \"$modules_mod\" in\n     (none)\n       AC_MSG_NOTICE([Disabling all optional modules])\n       rm -f src/*.off src/*.on\n       touch $(grep default-on src/*/module.type | sed \"s|/module.type:.*|.off|\") ;;\n     (all)\n       AC_MSG_NOTICE([Enabling all optional modules])\n       rm -f src/*.off src/*.off\n       touch $(grep default-off src/*/module.type | sed \"s|/module.type:.*|.on|\") ;;\n     (reset)\n        AC_MSG_NOTICE([Resetting modules to default])\n        rm -f src/*.on src/*.off ;;\n     (-*)\n       modules_mod=`echo \"${modules_mod}\" | sed \"s|-||\"`\n       if test ! -f src/$modules_mod/module.type ; then\n         AC_MSG_ERROR([trying to remove module $modules_mod which does not exist])\n       fi\n       AC_MSG_NOTICE([Disabling module ${modules_mod}])\n       rm -f src/$modules_mod.on\n       touch src/$modules_mod.off ;;\n     (+*)\n       modules_mod=`echo \"${modules_mod}\" | sed \"s|+||\"`\n       if test ! -f src/$modules_mod/module.type ; then\n         AC_MSG_ERROR([trying to add module $modules_mod which does not exist])\n       fi\n       AC_MSG_NOTICE([Enabling module ${modules_mod}])\n       rm -f src/$modules_mod.off\n       touch src/$modules_mod.on ;;\n     (*)\n       if test ! -f src/$modules_mod/module.type ; then\n         AC_MSG_ERROR([trying to add module $modules_mod which does not exist])\n       fi\n       AC_MSG_NOTICE([Enabling module ${modules_mod}])\n       rm -f src/$modules_mod.off\n       touch src/$modules_mod.on ;;\n     esac\n   done\n  ]\n  ,\n  []\n)\n\n\n# set enable flags for ./configure\n\n# This can be disabled when configuring within a package manager\n# such as macports to make sure that only libraries explicitly\n# listed in LDFLAGS are linked\nPLUMED_CONFIG_ENABLE([libsearch],[search for libraries],[yes])\n\n# This can be disabled to avoid the extra tests for static patching.\n# In the future, when this is disabled, we could disable the \"--static\" flag\n# of \"plumed patch\"\nPLUMED_CONFIG_ENABLE([static-patch],[allow statically linking plumed],[yes])\n\nPLUMED_CONFIG_ENABLE([doc],[documentation],[yes])\nPLUMED_CONFIG_ENABLE([pdfdoc],[pdf version of the manual],[no])\nPLUMED_CONFIG_ENABLE([debug],[debugging],[no])\nPLUMED_CONFIG_ENABLE([gcov],[gcov to estimate code coverage],[no])\nPLUMED_CONFIG_ENABLE([basic-warnings],[basic warnings],[yes])\nPLUMED_CONFIG_ENABLE([fussy],[fussy warnings],[no])\nPLUMED_CONFIG_ENABLE([debug-glibcxx],[enable boundary check],[no])\nPLUMED_CONFIG_ENABLE([shared],[shared libs],[yes])\nPLUMED_CONFIG_ENABLE([dependency-tracking],[dependency tracking],[yes])\nPLUMED_CONFIG_ENABLE([rpath],[store rpath],[no])\nPLUMED_CONFIG_ENABLE([absolute-soname],[store absolute soname (Linux only - this is the default behavior on OSX). Only enable for testing!],[no])\nPLUMED_CONFIG_ENABLE([absolute-install-name],[store absolute relative (OSX only - disable to have a behavior similar to Linux). Only disable for testing!],[yes])\nPLUMED_CONFIG_ENABLE([loader-path],[use @loader_path to find libplumedKernel.dylib (OSX only)],[yes])\nPLUMED_CONFIG_ENABLE([bsymbolic],[use -Bsymbolic flag in making shared libraries (Linux only)],[yes])\nPLUMED_CONFIG_ENABLE([ld-r],[group object files],[yes])\nPLUMED_CONFIG_ENABLE([ar-cr],[use ar to build libplumedWrapper.a],[yes])\nPLUMED_CONFIG_ENABLE([static-archive],[try to build libplumed.a for static linking],[yes])\nPLUMED_CONFIG_ENABLE([mpi],[search for mpi],[yes])\nPLUMED_CONFIG_ENABLE([external-lapack],[search for external lapack],[yes])\nPLUMED_CONFIG_ENABLE([external-blas],[search for external blas],[yes])\nPLUMED_CONFIG_ENABLE([molfile-plugins],[use molfile_plugins],[yes])\nPLUMED_CONFIG_ENABLE([external-molfile-plugins],[search for external molfile_plugins],[yes])\nPLUMED_CONFIG_ENABLE([zlib],[search for zlib],[yes])\nPLUMED_CONFIG_ENABLE([readdir-r],[search for readdir_r (threadsafe)],[yes])\nPLUMED_CONFIG_ENABLE([cregex],[search for C regular expression],[yes])\nPLUMED_CONFIG_ENABLE([dlopen],[search for dlopen],[yes])\nPLUMED_CONFIG_ENABLE([rtld_default],[search for RTLD_DEFAULT macro],[yes])\nPLUMED_CONFIG_ENABLE([chdir],[search for chdir function],[yes])\nPLUMED_CONFIG_ENABLE([getcwd],[search for getcwd function],[yes])\nPLUMED_CONFIG_ENABLE([execinfo],[search for execinfo],[yes])\nPLUMED_CONFIG_ENABLE([gsl],[search for gsl],[yes])\nPLUMED_CONFIG_ENABLE([xdrfile],[search for xdrfile],[yes])\nPLUMED_CONFIG_ENABLE([boost_graph],[search for boost graph],[no])\nPLUMED_CONFIG_ENABLE([boost_serialization],[search for boost serialization],[no])\nPLUMED_CONFIG_ENABLE([asmjit],[search for asmjit],[no])\nPLUMED_CONFIG_ENABLE([fftw],[search for fftw],[yes])\nPLUMED_CONFIG_ENABLE([python],[search for python],[yes])\nPLUMED_CONFIG_ENABLE([af_ocl],[arrayfire_opencl],[search for arrayfire],[no])\nPLUMED_CONFIG_ENABLE([af_cuda],[arrayfire_cuda],[search for arrayfire],[no])\nPLUMED_CONFIG_ENABLE([af_cpu],[arrayfire_cpu],[search for arrayfire],[no])\n\nAC_ARG_VAR(SOEXT,[extension of dynamic libraries (so/dylib)])\nAC_ARG_VAR(STATIC_LIBS,[variables that should be linked statically directly to MD code - configure will add here -ldl if necessary ])\nAC_ARG_VAR(LDSHARED,[command for linking shared library - configure will use CXX plus the proper flags ])\nAC_ARG_VAR(PYTHON_BIN,[python executable (e.g. python2.7 or /opt/local/bin/python2.7) - default: search for a python executable])\nAC_ARG_VAR(BASH_COMPLETION_DIR,[path where bash completion will be installed - default: search with pkg-config])\nAC_ARG_VAR(MPIEXEC,[command to run mpi programs in tests - default not specified, which means use PLUMED_MPIRUN env var at runtime for backward compatibility])\n\n\n# by default use -O flag\n# we override the autoconf default (-g) because in release build we do not want to\n# include symbol information (obj files are huge)\nif test -z \"$CXXFLAGS\"\nthen\n  CXXFLAGS=-O3\nfi\n\n# this is a list of common compilers\ncompilers=\"g++ c++ cxx icpc\"\nc_compilers=\"gcc cc icc\"\n\n# on OSX, prefer clang++\ncase `(uname)` in\n  (Darwin)\n    compilers=\"clang++ $compilers\"\n    c_compilers=\"clang $c_compilers\"\n  ;;\nesac\n\n# if searching for MPI, try first mpi-like compilers\nif test $mpi == true ; then\ncompilers=\"mpic++ mpicxx mpiicpc openmpic++ openmpicxx $compilers\"\nfi\n\n# do the actual search\nAC_PROG_CXX([$compilers])\nAC_PROG_CC([$c_compilers])\n\n# also setup Fortran compiler\n# this is optional, and can be used in the late part of this \n# script to verify that fortran can indeed link properly the\n# a c++ library\nAC_PROG_FC\n\n# we use C++ for all the autoconf tests\nAC_LANG(C++)\n\nif test -z \"$LDSHARED\" ; then\n  LDSHARED=\"$CXX\"\nfi\n\nAC_MSG_NOTICE([Initial CXX:         $CXX])\nAC_MSG_NOTICE([Initial CXXFLAGS:    $CXXFLAGS])\nAC_MSG_NOTICE([Initial CPPFLAGS:    $CPPFLAGS])\nAC_MSG_NOTICE([Initial CFLAGS:      $CFLAGS])\nAC_MSG_NOTICE([Initial LDFLAGS:     $LDFLAGS])\nAC_MSG_NOTICE([Initial LIBS:        $LIBS])\nAC_MSG_NOTICE([Initial STATIC_LIBS: $STATIC_LIBS])\nAC_MSG_NOTICE([Initial LD:          $LD])\nAC_MSG_NOTICE([Initial LDSHARED:    $LDSHARED])\nAC_MSG_NOTICE([Initial SOEXT:       $SOEXT])\n\n# check C++ flags\nif test $shared == true\nthen\n  PLUMED_CHECK_CXXFLAG([-fPIC])\n  PLUMED_CHECK_CFLAG([-fPIC])\nfi\n\nif test $basic_warnings == true\nthen\n  PLUMED_CHECK_CXXFLAG([-Wall])\n  PLUMED_CHECK_CXXFLAG([-pedantic])\n  PLUMED_CHECK_CXXFLAG([-std=c++11])\nfi\n\nif test $debug == true\nthen\n  PLUMED_CHECK_CXXFLAG([-g])\nfi\n\nif test $gcov == true\nthen\n  CXX=\"$CXX --coverage\"\n  LDSHARED=\"$LDSHARED --coverage\"\n  CFLAGS=\"$CFLAGS --coverage\"\n  PLUMED_CHECK_LDFLAGS([--coverage])\n  STATIC_LIBS=\"$STATIC_LIBS --coverage\"\nfi\n\nif test $fussy == true\nthen\n  PLUMED_CHECK_CXXFLAG([-Wextra])\n  PLUMED_CHECK_CXXFLAG([-Wfloat-equal])\n  PLUMED_CHECK_CXXFLAG([-Wwrite-strings])\n  PLUMED_CHECK_CXXFLAG([-Wpointer-arith])\n  PLUMED_CHECK_CXXFLAG([-Wcast-qual])\n  PLUMED_CHECK_CXXFLAG([-Wcast-align])\n  PLUMED_CHECK_CXXFLAG([-Wconversion])\n  PLUMED_CHECK_CXXFLAG([-Wredundant-delcs])\n  PLUMED_CHECK_CXXFLAG([-Wvariadic-macros])\n  PLUMED_CHECK_CXXFLAG([-Wold-style-cast])\nfi\n\nAC_MSG_CHECKING([whether $CXX declares c++11 support])\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM([\n#if __cplusplus <= 199711L\nthis_compiler_does_not_support_cxx11\n#endif\n])],\n  [AC_MSG_RESULT([yes])];\n  support_cxx11=true,\n  [AC_MSG_RESULT([no]) ;\n  support_cxx11=false])\n\nif test \"$support_cxx11\" = false\nthen\n   AC_MSG_WARN([C++11 support is required as of PLUMED 2.4])\n   AC_MSG_WARN([Your compiler appears not to support C++11])\n   AC_MSG_WARN([Please change compiler or make sure that everything works correctly])\nfi\n\nAC_MSG_CHECKING([whether C++ library supports C++11 exceptions])\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM([\n#include <new>\n#include <functional>\n#include <memory>\n#include <system_error>\n#include <ios>\n#include <future>\n// capable to catch:\nvoid func(void) {\n  try{\n  } catch(std::bad_array_new_length &) {\n  } catch(std::bad_function_call &) {\n  } catch(std::bad_weak_ptr &) {\n  } catch(std::ios_base::failure &e) {\n    if(e.code().category()==std::generic_category()) {}\n    else if(e.code().category()==std::system_category()) {}\n    else if(e.code().category()==std::iostream_category()) {}\n    else if(e.code().category()==std::future_category()) {}\n  } catch(std::system_error &e) {\n    if(e.code().category()==std::generic_category()) {}\n    else if(e.code().category()==std::system_category()) {}\n    else if(e.code().category()==std::iostream_category()) {}\n    else if(e.code().category()==std::future_category()) {}\n  }\n// capable to throw:\n  auto a=std::bad_array_new_length();\n  auto b=std::bad_function_call();\n  auto c=std::bad_weak_ptr();\n  auto d=std::system_error(10,std::generic_category(),\"msg\");\n  auto e=std::system_error(10,std::system_category(),\"msg\");\n  auto f=std::system_error(10,std::iostream_category(),\"msg\");\n  auto g=std::system_error(10,std::future_category(),\"msg\");\n  auto h=std::ios_base::failure(\"msg\",std::error_code(10,std::generic_category()));\n  auto i=std::ios_base::failure(\"msg\",std::error_code(10,std::system_category()));\n  auto j=std::ios_base::failure(\"msg\",std::error_code(10,std::iostream_category()));\n  auto k=std::ios_base::failure(\"msg\",std::error_code(10,std::future_category()));\n}\n])],\n[\n  AC_MSG_RESULT([yes]);\n  AC_DEFINE([__PLUMED_LIBCXX11])\n],\n[AC_MSG_RESULT([no])\n])\n\nAC_SUBST(disable_dependency_tracking)\n\nif test \"$dependency_tracking\" = true\nthen\n  AC_MSG_CHECKING([whether $CXX can generate dependency file with -MM -MF])\n  dependency=ko\n  echo \"#include \\\"conftest1.h\\\"\" > conftest.cpp\n  echo \"#include \\\"conftest2.h\\\"\" > conftest1.h\n  echo \"/* */\" > conftest2.h\n  $CXX $CXXFLAGS -c -MM -MFconftest.d conftest.cpp 1> /dev/null 2> /dev/null\n  grep conftest2 conftest.d 1> /dev/null 2>/dev/null && dependency=ok\n  if test \"$dependency\" = ok ; then\n    AC_MSG_RESULT([yes])\n    disable_dependency_tracking=no\n  else\n    AC_MSG_RESULT([no])\n    disable_dependency_tracking=yes\n  fi\nelse\n  disable_dependency_tracking=yes\nfi\n\nif test \"$disable_dependency_tracking\" = yes ; then\n  AC_MSG_WARN([dependencies tracking disabled - always make clean before make])\nelse\n  AC_MSG_NOTICE([dependency tracking enabled])\nfi\n\n\n\n\n#### Compulsory libraries ####\n# some of them might be made optional if we find that are not available in some system\nAC_MSG_NOTICE([Now we will check compulsory headers and libraries])\nAC_CHECK_HEADER([dirent.h],     [ ], [AC_MSG_ERROR([compulsory header not found])] )\nAC_CHECK_FUNC(  [readdir],      [ ], [AC_MSG_ERROR([compulsory function not found])] )\n\n# Then check for blas. This is a bit complicated because we want to allow\n# either the version with underscore or the one without\nblas_found=\nlapack_found=\n\n# external lapack can only work with external blas\n# thus, if external blas are disabled also external lapack should be disabled\nif test \"$external_blas\" == false && test \"$external_lapack\" == true ; then\n  AC_MSG_NOTICE([Internal blas can only be used with internal lapack])\n  AC_MSG_NOTICE([Will not search for external lapack])\n  external_lapack=false\nfi\n\n# first look for blas\nif test \"$external_blas\" == true ; then\n  AC_MSG_CHECKING([whether dgemv can be linked with no library])\n  AC_LINK_IFELSE([AC_LANG_CALL([], [dgemv])],[\n    AC_MSG_RESULT([yes])\n    blas_found=nounderscore\n    ],[\n    AC_MSG_RESULT([no])\n    AC_MSG_CHECKING([whether dgemv_ can be linked with no library])\n    AC_LINK_IFELSE([AC_LANG_CALL([], [dgemv_])],[\n      AC_MSG_RESULT([yes])\n      blas_found=underscore\n    ],[\n      AC_MSG_RESULT([no])\n      PLUMED_SEARCH_LIBS([dgemv],[blas],[blas_found=nounderscore],[\n        PLUMED_SEARCH_LIBS([dgemv_],[blas],[blas_found=underscore])\n      ])\n    ])\n  ])\nfi\n\n# if not found, then use internal lapack and blas\nif test -z \"$blas_found\" ; then\nAC_MSG_WARN([using internal lapack and blas, could be inefficient])\nfi\n\n# if found, also look for external lapack\nif test -n \"$blas_found\" ; then\n\nAC_DEFINE([__PLUMED_HAS_EXTERNAL_BLAS])\n\nif test \"$external_lapack\" == true ; then\n# Then we look for lapack using same underscoring\ncase \"$blas_found\" in\n(underscore) search_for=dsyevr_ ;;\n(nounderscore) search_for=dsyevr ;;\nesac\nPLUMED_SEARCH_LIBS( [$search_for],[lapack],[lapack_found=yes])\nfi\n\n# if not found, then use internal lapack with external blas\nif test -z \"$lapack_found\" ; then\nAC_MSG_WARN([using internal lapack, could be inefficient])\nelse\nAC_DEFINE([__PLUMED_HAS_EXTERNAL_LAPACK])\nfi\n\nfi \n\n# in case external blas have been found, take note of their underscoring\n# notice that this applies also when external blas are used with internal lapack\n# in the latter case, also (internal) lapack names will be underscored consistently\nif test \"$blas_found\" == nounderscore\nthen\n  AC_DEFINE([F77_NO_UNDERSCORE])\nfi\n\nif test -n \"$blas_found\" ; then\n\nAC_DEFUN([PLUMED_TEST_SDOT],[\n#if ! defined(F77_NO_UNDERSCORE)\n#define sdot sdot_\n#endif\nextern \"C\"{\n$1 sdot(int *n, float *dx, int *incx, float *dy, int *incy);\n}\n\nint main(){\n  int size=5;\n// notice that [[]] is required to cheat autoconf\n  float af[[5]],bf[[5]];\n  for(unsigned i=0;i<size;i++){\n    af[[i]]=size;\n    bf[[i]]=size-i;\n  }\n  int inca=1;\n  int incb=1;\n  $1 f=sdot(&size,af,&inca,bf,&incb)-75;\n  if(f*f<1e-10) return 0;\n  else return 1;\n}\n])\n\n\nAC_MSG_CHECKING([whether sdot returns float])\nAC_RUN_IFELSE([AC_LANG_SOURCE([PLUMED_TEST_SDOT([float])])],\n  [ sdot_returns_float=yes ; AC_MSG_RESULT([yes]) ],\n  [ sdot_returns_float=no ;  AC_MSG_RESULT([no]) ],\n  [ AC_MSG_RESULT([not checked (cross compiling)]) ]\n)\n\nif test \"$sdot_returns_float\" == no ;\nthen\n\nAC_MSG_CHECKING([whether sdot returns double])\nAC_RUN_IFELSE([AC_LANG_SOURCE([PLUMED_TEST_SDOT([double])])],\n  [ sdot_returns_double=yes ; AC_MSG_RESULT([yes]) ],\n  [ sdot_returns_double=no ;  AC_MSG_RESULT([no]) ],\n  [ AC_MSG_RESULT([not checked (cross compiling)]) ]\n)\n\nfi\n\nif test \"$sdot_returns_double\" = yes ; then\n  AC_MSG_NOTICE([Setting workaround for blas float functions returning double])\n  AC_DEFINE(__PLUMED_BLAS_RETURNS_FLOAT,double)\n  if test -n \"$lapack_found\" ; then\n    AC_MSG_NOTICE([Setting workaround for lapack float functions returning double])\n    AC_DEFINE(__PLUMED_LAPACK_RETURNS_FLOAT,double)\n  fi\nelse if test \"$sdot_returns_float\" = no && test \"$sdot_returns_double\" = no ;\nthen\n  AC_MSG_WARN([There is a problem with your blas implementation])\nfi\n\nfi\n\nfi\n\n#### End of compulsory libraries ####\n\n#### Optional libraries ####\nAC_MSG_NOTICE([Now we will check for optional headers and libraries])\n\n#############################################################\n# I add the possibility to completely remove molfile_plugins\n# I would like to be 100% that the molfile module compiles\n# correctly on all machines\n# In case of problem, it is sufficient to configure with\n# ./configure --disable-molfile-plugins\n# GB\n#############################################################\n\nif test $molfile_plugins == true ; then\n\n# Check for molfile_plugins and use internal fallback if not found. TG\n\n# We always have molfile, now\nAC_DEFINE([__PLUMED_HAS_MOLFILE_PLUGINS])\n\n  if test \"$external_molfile_plugins\" == true ; then\n    PLUMED_CHECK_PACKAGE([libmolfile_plugin.h],[molfile_dcdplugin_init],[__PLUMED_HAS_EXTERNAL_MOLFILE_PLUGINS],molfile_plugin)\n    if test \"$__PLUMED_HAS_EXTERNAL_MOLFILE_PLUGINS\" != yes ; then\n      AC_MSG_WARN([using internal molfile_plugins, which only support dcd/xtc/trr/trj/crd files])\n    else\n      AC_DEFINE([__PLUMED_HAS_EXTERNAL_MOLFILE_PLUGINS])\n    fi\n  fi\nfi\n\n# this is special and is also attached to STATIC_LIBS\n# this flag should be used also when linking MD engines to allow plumed\n# to be loaded later\nAC_CHECK_LIB([dl],dlopen, [STATIC_LIBS=\"-ldl $STATIC_LIBS\"] [LIBS=\"-ldl $LIBS\"])\n\nmpi_found=ko\n# optional libraries follow\nif test $mpi == true ; then\n  PLUMED_CHECK_PACKAGE([mpi.h],[MPI_Init],[__PLUMED_HAS_MPI])\n  if test \"$__PLUMED_HAS_MPI\" = yes; then\n    mpi_found=ok\n  fi\nelse \n  mpi_found=ko\nfi\n\n# search for openmp is automatically disabled by autoconf\n# when configuring with --disable-openmp\nAC_OPENMP\n\nif test $readdir_r == true ; then\n  PLUMED_CHECK_PACKAGE([dirent.h],[readdir_r],[__PLUMED_HAS_READDIR_R])\nfi\nif test $cregex == true ; then\n  PLUMED_CHECK_PACKAGE([regex.h],[regcomp],[__PLUMED_HAS_CREGEX])\nfi\nif test $dlopen == true ; then\n  PLUMED_CHECK_PACKAGE([dlfcn.h],[dlopen],[__PLUMED_HAS_DLOPEN])\nfi\n\nif test $rtld_default == true ; then\n  PLUMED_CHECK_CXX_PACKAGE([RTLD_DEFAULT],[\n#include <dlfcn.h>\nint\nmain ()\n{\n  void* f=dlsym(RTLD_DEFAULT,\"path\");\n  return 0;\n}\n  ], [__PLUMED_HAS_RTLD_DEFAULT])\nfi\n\nif test $chdir == true ; then\n  PLUMED_CHECK_PACKAGE([unistd.h],[chdir],[__PLUMED_HAS_CHDIR])\nfi\n\nif test $getcwd == true ; then\n  PLUMED_CHECK_PACKAGE([unistd.h],[getcwd],[__PLUMED_HAS_GETCWD])\nfi\n\nif test $execinfo == true ; then\n  PLUMED_CHECK_PACKAGE([execinfo.h],[backtrace],[__PLUMED_HAS_EXECINFO])\nfi\nif test $zlib == true ; then\n  PLUMED_CHECK_PACKAGE([zlib.h],[gzopen],[__PLUMED_HAS_ZLIB],[z])\nfi\n\nif test $gsl == true ; then\n  found=ko\n  PLUMED_SEARCH_LIBS([cblas_dgemv],[gslcblas], [\n    AC_CHECK_HEADER(  [gsl/gsl_vector.h], [\n      PLUMED_SEARCH_LIBS([gsl_vector_alloc],[gsl],[found=ok])\n    ])\n  ])\n  if test $found == ok ; then\n    AC_DEFINE([__PLUMED_HAS_GSL])\n  else\n    AC_MSG_WARN([cannot enable __PLUMED_HAS_GSL])\n  fi\nfi\n\nif test $xdrfile == true ; then\n  PLUMED_CHECK_PACKAGE([xdrfile/xdrfile_xtc.h],[write_xtc],[__PLUMED_HAS_XDRFILE],[xdrfile])\nfi\n\nif test $boost_graph == true ; then\n  PLUMED_CHECK_CXX_PACKAGE([boost graph],[\n#include <boost/graph/graph_utility.hpp>\n#include <boost/graph/adjacency_matrix.hpp>\nint\nmain ()\n{\n  boost::adjacency_matrix<boost::directedS> a(1);\n  ;\n  return 0;\n}\n  ], [__PLUMED_HAS_BOOST_GRAPH])\nfi\n\nif test $boost_serialization == true ; then\n  PLUMED_CHECK_CXX_PACKAGE([boost serialization],[\n#include <fstream>\n#include <boost/archive/text_oarchive.hpp>\nint main() {\n    std::ofstream ofs(\"filename\");\n    boost::archive::text_oarchive oa(ofs);\n    return 0;\n}\n  ], [__PLUMED_HAS_BOOST_SERIALIZATION],[boost_serialization boost_serialization-mt])\n# notice: macports install libraries with -mt suffix\nfi\n\nif test $asmjit == true ; then\n  PLUMED_CHECK_CXX_PACKAGE([asmjit],[\n#include <asmjit/asmjit.h>\n#include <stdio.h>\nusing namespace asmjit;\ntypedef int (*Func)(void);\nint main(int argc, char* argv[[]]) {\n  JitRuntime rt;\n  CodeHolder code;\n  code.init(rt.getCodeInfo());\n  X86Assembler a(&code);\n  a.mov(x86::eax, 1);\n  a.ret();\n  Func fn;\n  Error err = rt.add(&fn, &code);\n  if (err) return 1;\n  int result = fn();\n  printf(\"%d\\n\", result);\n  rt.release(fn);\n  return 0;\n}\n  ], [__PLUMED_HAS_ASMJIT],[asmjit])\nfi\n\nif test $fftw == true ; then\n  PLUMED_CHECK_PACKAGE([fftw3.h],[fftw_execute],[__PLUMED_HAS_FFTW],[fftw3])\nfi\n\nif test $python == true  ; then\n# if PYTHON_BIN is defined, it is expected to be the full path to python\n# Otherwise, search from a list of names:\n  if test -z \"$PYTHON_BIN\" ; then\n    AC_CHECK_PROGS([PYTHON_BIN],[python])\n  fi\n  if test -n \"$PYTHON_BIN\"\n  then\n    AC_MSG_NOTICE([Python executable is $PYTHON_BIN])\n    AC_MSG_CHECKING([support for required python modules (setuptools, cython, subprocess, os, shutil)])\ntestimport=\"\nfrom setuptools import setup\nfrom setuptools import Extension\nimport subprocess\nimport os\nimport os.path\nimport sys\nfrom shutil import copyfile\nfrom Cython.Build import cythonize\n\"\n    if echo \"$testimport\" | \"$PYTHON_BIN\" 1>/dev/null 2>/dev/null;  then\n       AC_MSG_RESULT([yes])\n       AC_DEFINE([__PLUMED_HAS_PYTHON])\n    else\n       AC_MSG_RESULT([no])\n       AC_MSG_WARN([cannot enable python interface])\n       PYTHON_BIN=\n    fi\n  else\n    AC_MSG_WARN([cannot enable python interface])\n  fi\nfi\n\nif test \"$af_ocl\" == true ; then\n  PLUMED_CHECK_PACKAGE([arrayfire.h],[af_is_double],[__PLUMED_HAS_ARRAYFIRE],[afopencl])\nfi\nif test \"$af_cuda\" == true ; then\n  PLUMED_CHECK_PACKAGE([arrayfire.h],[af_is_double],[__PLUMED_HAS_ARRAYFIRE],[afcuda])\nfi\nif test \"$af_cpu\" == true ; then\n  PLUMED_CHECK_PACKAGE([arrayfire.h],[af_is_double],[__PLUMED_HAS_ARRAYFIRE],[afcpu])\nfi\n\n# in non-debug mode, add -DNDEBUG\nif test \"$debug\" == false ; then\n  AC_MSG_NOTICE([Release mode, adding -DNDEBUG])\n  AC_DEFINE([NDEBUG])\nfi\n\n# in debug-glibcxx mode, add -D_GLIBCXX_DEBUG\nif test \"$debug_glibcxx\" == true ; then\n  AC_MSG_NOTICE([Check boundaries, adding -D_GLIBCXX_DEBUG])\n  AC_DEFINE([_GLIBCXX_DEBUG])\nfi\n\n# this is necessary in many MPI implementations\n# I leave it by default, since it seems harmless\nAC_DEFINE([_REENTRANT])\n\n#### Options for dynamic library to work properly ####\nAC_SUBST(SOEXT)\nAC_SUBST(LDSHARED)\n# these are libraries that should be linked also to MD engines\nAC_SUBST(STATIC_LIBS)\n# python executable\nAC_SUBST(PYTHON_BIN)\n\nAC_SUBST(MPIEXEC)\n\nif test \"$shared\" == true ; then\n  case `(uname)` in\n  (Darwin)\n    AC_MSG_NOTICE([*** Special settings for dynamic libraries on OSX ***])\n    AC_MSG_NOTICE([Dynamic library extension is 'dylib'])\n    AC_MSG_NOTICE([LDSHARED needs special flags])\n    SOEXT=dylib\n    LDSHARED=\"$LDSHARED -dynamiclib -Wl,-headerpad_max_install_names\"\n    if test \"$rpath\" = true ; then\n      AC_MSG_NOTICE([Switching off rpath on OSX])\n      rpath=false\n    fi\n  ;;\n  (Linux)\n    AC_MSG_NOTICE([*** Special settings for dynamic libraries on Linux ***])\n    AC_MSG_NOTICE([Dynamic library extension is 'so'])\n    AC_MSG_NOTICE([LDSHARED and LDFLAGS need special flags])\n    SOEXT=so\n    LDSHARED=\"$LDSHARED -shared\"\n    PLUMED_CHECK_LDFLAGS([-rdynamic])\n    if test \"$bsymbolic\" == true ; then\n      PLUMED_CHECK_LDFLAGS([-Wl,-Bsymbolic])\n    fi\n  ;;\n  (*)\n    AC_MSG_NOTICE([*** Dynamic library only enabled on OSX and Linux ***])\n  esac\nfi\n\n# check linking of runtime library\nif test -n \"$SOEXT\"\nthen\n  AC_MSG_NOTICE([Using LDSHARED='$LDSHARED'])\n  AC_MSG_NOTICE([Using LDFLAGS='$LDFLAGS'])\n  AC_MSG_CHECKING([whether LDSHARED can create dynamic libraries])\n  rm -f conftest.*\n  echo \"void f(void){ return;}\" > conftest.cpp\n  $CXX $CXXFLAGS $CPPFLAGS -c conftest.cpp 1>/dev/null 2>/dev/null\n  $LDSHARED $LDFLAGS conftest.o -o conftest.$SOEXT 1>/dev/null 2>/dev/null\n  if test -f conftest.$SOEXT\n  then\n    AC_MSG_RESULT([yes])\n  else\n    AC_MSG_RESULT([no])\n    AC_MSG_WARN([dynamic library will be disabled])\n    SOEXT=\n  fi\n  if test -n \"$SOEXT\" && test \"$rpath\" = true ; then\n    rm -f conftest.$SOEXT\n    readelf=\"\"\n    AC_CHECK_PROG([readelf],[readelf],[found])\n    if test \"$readelf\" == found ; then\n      test_LDSHARED=\"$LDSHARED -Wl,-R -Wl,/some/random/dir/\"\n      $test_LDSHARED $LDFLAGS conftest.o -o conftest.$SOEXT 1>/dev/null 2>/dev/null\n      if readelf -d conftest.$SOEXT | grep RPATH | grep -q /some/random/dir ; then\n        LDSHARED=\"$LDSHARED -Wl,-R -Wl,\\\"$LIBRARY_PATH\\\"\"\n      else\n        AC_MSG_WARN([-R option seems not working, disabling rpath])\n      fi\n    else\n      AC_MSG_WARN([readelf not available, no way to set rpath])\n    fi \n  fi\n  rm -f conftest.*\nfi\n#### Options for dynamic library to work properly ####\n\nAC_SUBST(make_doc)\nmake_doc=no\nif test \"$doc\" == true\nthen\n\nmake_doc=yes\n\n### Look for doxygen\nAC_CHECK_PROG([doxygen],[doxygen],[found])\nif test \"$doxygen\" == found\nthen\n  doxygen_version=`doxygen --version | awk 'BEGIN{FS=\".\"}{if($1>1 || ($1==1 && $2>=8)) print \"ok\"}'`\n  if test \"$doxygen_version\" == ok\n  then\n    AC_MSG_NOTICE([Doxygen version is fine])\n  else\n    AC_MSG_WARN([Doxygen version is <1.8])\n    make_doc=no\n  fi\n  AC_CHECK_PROG([dot],[dot],[found])\n  if test \"$dot\" != found\n  then\n    AC_MSG_WARN([You will not be able to see diagrams in the manual])\n  fi\nelse\n  make_doc=no\nfi\nfi\n\nif test \"$make_doc\" = yes\nthen\n  AC_MSG_NOTICE([Manuals will be generated])\nelse\n  AC_MSG_NOTICE([Manuals will not be generated])\nfi\n\nAC_SUBST(make_pdfdoc)\nmake_pdfdoc=\"\"\nif test \"$pdfdoc\" == true && test \"$make_doc\" == yes\nthen\n  AC_MSG_NOTICE([A PDF version of the manual will be generated])\n  make_pdfdoc=yes\nelse\n  AC_MSG_NOTICE([A PDF version of the manual will not be generated])\n  make_pdfdoc=no\nfi\n\n### Look for xxd\nAC_CHECK_PROG([xxd],[xxd],[found])\nif test \"$xxd\" != found\nthen\n  AC_MSG_ERROR([xxd should be installed for PLUMED to compile properly])\nfi\n\nAC_SUBST(program_can_run)\nprogram_can_run=\"\"\nAC_MSG_CHECKING([whether a program can be run on this machine])\nAC_RUN_IFELSE([AC_LANG_SOURCE([\n#ifdef __PLUMED_HAS_MPI\n#include <mpi.h>\n#endif\n// notice that [[]] is required to cheat autoconf\nint main(int argc,char*argv[[]]){\n#ifdef __PLUMED_HAS_MPI\n// this emulates what happens when plumed\n// is compiled with mpi and invoked with --no-mpi\n  if(argc==10){\n    MPI_Init(&argc,&argv);\n    return MPI_Finalize();\n  }\n#endif\n  return 0;\n}\n])],\n  [ program_can_run=yes ; AC_MSG_RESULT([yes]) ],\n  [ program_can_run=no ; AC_MSG_RESULT([no]) ],\n  [ program_can_run=no ; AC_MSG_RESULT([no (cross compiling)]) ]\n)\n\nif test $mpi_found == ok ; then\nAC_SUBST(program_can_run_mpi)\nprogram_can_run_mpi=\"\"\nAC_MSG_CHECKING([whether a program compiled with mpi can be run on this machine])\nAC_RUN_IFELSE([AC_LANG_SOURCE([\n#ifdef __PLUMED_HAS_MPI\n#include <mpi.h>\n#endif\n// notice that [[]] is required to cheat autoconf\nint main(int argc,char*argv[[]]){\n#ifdef __PLUMED_HAS_MPI\n  MPI_Init(&argc,&argv);\n  return MPI_Finalize();\n#endif\n  return 0;\n}\n])],\n  [ program_can_run_mpi=yes ; AC_MSG_RESULT([yes]) ],\n  [ program_can_run_mpi=no ; AC_MSG_RESULT([no]) ],\n  [ program_can_run_mpi=no ; AC_MSG_RESULT([no (cross compiling)]) ]\n)\nfi\n\nif test $mpi_found == ok ; then\n  if test -n \"$MPIEXEC\" ; then\n    AC_MSG_NOTICE([Regtest suite will use $MPIEXEC command to run MPI tests])\n  else\n    AC_MSG_NOTICE([Regtest suite will use env var PLUMED_MPIRUN to run MPI tests (default: mpirun)])\n  fi\nfi\n\nif test \"$SOEXT\" == \"dylib\" ; then\n  use_absolute_soname=yes\nelse\n  use_absolute_soname=no\nfi\n\nAC_SUBST(use_absolute_soname)\nif test \"$absolute_soname\" == true ; then\n  if test \"$SOEXT\" == \"dylib\" ; then\n    AC_MSG_WARN([--enable-absolute-soname has no effect on OSX])\n  else\n    AC_MSG_NOTICE([enabling absolute soname. Full path will be hardcoded in plumed library soname])\n    use_absolute_soname=yes\n  fi\nfi\n\nif test \"$absolute_install_name\" == false ; then\n  if test \"$SOEXT\" == \"so\" ; then\n    AC_MSG_WARN([--disable-absolute-install-name has no effect on Linux])\n  else\n    AC_MSG_NOTICE([enabling relative install_name. You will have to set DYLD_LIBRARY_PATH yor plumed libraries to be found at runtime])\n    use_absolute_soname=no\n  fi\nfi\n\nAC_SUBST(use_loader_path)\nif test \"$SOEXT\" == \"dylib\" ; then\n  if test \"$loader_path\" == true ; then\n    use_loader_path=yes\n  else\n    use_loader_path=no\n  fi\nelse\n  use_loader_path=no\nfi\n\n#### This further tests are required to allow linking with non c++ compiler\nAC_MSG_NOTICE([PLUMED seems to be configured properly!])\nAC_MSG_NOTICE([**************************])\nAC_SUBST(LD_RO)\nLD_RO=\nif test \"$ld_r\" == true ; then\nfor test_LD_RO in \"$($CXX --print-prog-name=ld) -r -o\" \"$CXX -Wl,-r -o\" \"ld -r -o\"\ndo\n  AC_MSG_CHECKING([whether C++ objects can be grouped with $test_LD_RO])\n  \n  rm -f conftest-*\n  \n  cat << EOF > conftest-main.cpp\n  void f(void);\n  int main(int argc,char**argv){ f(); return 0; }\nEOF\n  cat << EOF > conftest-f.cpp\n  void g(void);\n  void f(void){ g(); }\nEOF\n  cat << EOF > conftest-g.cpp\n  void g(void){ return; }\nEOF\n  \n  $CXX $CXXFLAGS -c conftest-main.cpp 1> /dev/null 2> /dev/null\n  $CXX $CXXFLAGS -c conftest-f.cpp 1> /dev/null 2> /dev/null\n  $CXX $CXXFLAGS -c conftest-g.cpp 1> /dev/null 2> /dev/null\n  \n  $test_LD_RO conftest-both.o conftest-f.o conftest-g.o 1> /dev/null 2> /dev/null\n  \n  $CXX $CXXFLAGS -o conftest.exe conftest-main.o conftest-both.o 1> /dev/null 2> /dev/null\n  \n  if test -f conftest.exe\n  then\n    AC_MSG_RESULT([yes])\n    LD_RO=\"$test_LD_RO\"\n    break\n  else\n    AC_MSG_RESULT([no])\n  fi\ndone\n\nfi\n\nAC_SUBST(AR_CR)\nAR_CR=\nif test \"$ar_cr\" == true ; then\nfor test_AR_CR in \"$($CXX --print-prog-name=ar) cr\" \"ar cr\"\ndo\n  AC_MSG_CHECKING([whether static libraries can be created with $test_AR_CR])\n  \n  rm -f conftest-*\n  \n  cat << EOF > conftest-main.cpp\n  void f(void);\n  int main(int argc,char**argv){ f(); return 0; }\nEOF\n  cat << EOF > conftest-f.cpp\n  void g(void);\n  void f(void){ g(); }\nEOF\n  cat << EOF > conftest-g.cpp\n  void g(void){ return; }\nEOF\n  \n  $CXX $CXXFLAGS -c conftest-main.cpp 1> /dev/null 2> /dev/null\n  $CXX $CXXFLAGS -c conftest-f.cpp 1> /dev/null 2> /dev/null\n  $CXX $CXXFLAGS -c conftest-g.cpp 1> /dev/null 2> /dev/null\n  \n  $test_AR_CR conftest-both.a conftest-f.o conftest-g.o 1> /dev/null 2> /dev/null\n  \n  $CXX $CXXFLAGS -o conftest.exe conftest-main.o conftest-both.a 1> /dev/null 2> /dev/null\n  \n  if test -f conftest.exe\n  then\n    AC_MSG_RESULT([yes])\n    AR_CR=\"$test_AR_CR\"\n    break\n  else\n    AC_MSG_RESULT([no])\n  fi\ndone\n \nfi\n\nmake_static_archive=no\nAC_SUBST(make_static_archive)\n\nif test \"${static_archive}\" == true ; then\n  if test -z \"$LD_RO\" || test -z \"$AR_CR\" ; then\n    AC_MSG_WARN([no way to create a static archive if ld -ro or ar cr do not work])\n    static_archive=false\n  fi\nfi\n\nif test \"${static_archive}\" == true ; then\n  AC_MSG_CHECKING([whether static-object constructors can be linked from a static archive])\n\n  magic_token=c1bc476d093a3a5c67b4530e6c54c633593fe9aa\n  rm -f conftest-*\n  \n  cat << EOF > conftest-main.cpp\n  void f(void);\n  int main(int argc,char**argv){ f(); return 0; }\nEOF\n  cat << EOF > conftest-f.cpp\n  void f(void){ return; }\nEOF\n  cat << EOF > conftest-g.cpp\n#include <iostream>\n  class g{\n    public:\n    g(){ std::cout<<\"$magic_token\\n\"; }\n  } init;\nEOF\n\n  $CXX $CXXFLAGS -c conftest-main.cpp 1> /dev/null 2> /dev/null\n  $CXX $CXXFLAGS -c conftest-f.cpp 1> /dev/null 2> /dev/null\n  $CXX $CXXFLAGS -c conftest-g.cpp 1> /dev/null 2> /dev/null\n  \n  $LD_RO conftest-both.o conftest-f.o conftest-g.o 1> /dev/null 2> /dev/null\n# linking the previously merged objects should work:\n  $AR_CR conftest-both.a conftest-both.o 1> /dev/null 2> /dev/null\n# something like the following, instead, should not work:\n#  $AR_CR conftest-both.a conftest-f.o conftest-g.o 1> /dev/null 2> /dev/null\n#\n  $CXX $CXXFLAGS -o conftest.exe conftest-main.o conftest-both.a 1> /dev/null 2> /dev/null\n  if grep -q $magic_token ./conftest.exe ; then\n    AC_MSG_RESULT([yes])\n    make_static_archive=yes\n  else\n    AC_MSG_RESULT([no])\n  fi\nfi\n\nif test \"${static_patch}\" == true ; then\n\nAC_MSG_NOTICE([I will now check if C++ objects can be linked by C/Fortran compilers])\nAC_MSG_NOTICE([This is relevant if you want to use plumed patch --static on a non-C++ code])\n\nfor compiler in CC FC\ndo\n  rm -f conftest.* conftest-main.*\n  eval compexe=\\$$compiler\n  if test -n \"$compexe\" ; then\n    case $compiler in\n    (CC)\n      name=C\n      cat << EOF > conftest-main.c\nint main(int argc,char**argv){\n  return 0;\n}\nEOF\n      $CC -c conftest-main.c\n    ;;\n    (FC)\n      name=FORTRAN\n      cat << EOF > conftest-main.f90\n       program main\n       integer i\n       end program main\nEOF\n      $FC -c conftest-main.f90\n    ;;\n    esac\n    cat << EOF > conftest.cpp\n#include <iostream>\nvoid f(void){\n  std::cout<<\"ciao\";return;\n}\nEOF\n    $CXX $CXXFLAGS -c conftest.cpp \n# start search:\n    found=\n    if test \"${libsearch}\" == true ; then\n      testlibs=\"-lstdc++ -lc++ -lmpi_cxx\"\n    else\n      testlibs=\"\"\n    fi\n    for testlib in \"\" $testlibs ; do\n      comment=\n      test -n \"$testlib\" && comment=\" with library $testlib\"\n      AC_MSG_CHECKING([whether $name can link a C++ object$comment])\n      $compexe conftest.o conftest-main.o $LDFLAGS $testlib $LIBS -o conftest.exe 1>/dev/null 2>/dev/null\n      if test -f conftest.exe\n      then\n        found=yes\n        AC_MSG_RESULT([yes])\n        LIBS=\"$testlib $LIBS\"\n        break\n      else\n        AC_MSG_RESULT([no])\n      fi\n    done\n    if test -z \"$found\" ; then\n      AC_MSG_WARN([You might have problems linking $name programs.])\n      AC_MSG_WARN([Please add c++ library to LIBS])\n    fi\n  else\n    AC_MSG_NOTICE([$compiler compiler not configured])\n  fi\n  rm -f conftest.* conftest-main.*\ndone\n\nelse\nAC_MSG_NOTICE([Static patching is disabled, thus tests required for static patching will be skipped])\nfi\n\nif test \"$prefix\" == NONE\nthen\n  prefix=/usr/local\nfi\n\npkgconfig_bin=\"\"\n\nAC_PATH_PROGS(pkgconfig_bin,pkg-config)\n\nif test -z \"$BASH_COMPLETION_DIR\" && test -n \"$pkgconfig_bin\"; then\n  if test \"$prefix\" == \"$(pkg-config --variable=prefix bash-completion 2>/dev/null)\"\n  then\n    AC_MSG_NOTICE([bash-completion is installed on the same prefix where plumed will be installed])\n    if pkg-config --variable=completionsdir bash-completion 2>/dev/null >/dev/null ; then\n      BASH_COMPLETION_DIR=\"$(pkg-config --variable=completionsdir  bash-completion 2>/dev/null)\"\n    fi\n  else\n    AC_MSG_NOTICE([bash-completion is not installed or it is installed on a different prefix])\n    pkgconfig_bin=\"\"\n  fi\nfi\n\nif test -n \"$BASH_COMPLETION_DIR\"\nthen\n  AC_MSG_NOTICE([bash completion for plumed will be installed in $BASH_COMPLETION_DIR])\nelse\n  AC_MSG_NOTICE([bash completion for plumed will not be installed])\nfi\n\nAC_SUBST(BASH_COMPLETION_DIR)\n\nAC_ARG_PROGRAM\n\n\n# version modified to work in shell script instead of makefile:\nprogram_transform_name_sh=$(echo \"${program_transform_name}\" | sed 's:\\$\\$:$:g')\nprogram_name=$(echo plumed | sed \"$program_transform_name_sh\")\nAC_SUBST(program_name)\n\nif test \"$(echo \"$program_name\" | tr '[A-Z]' '[a-z]')\" != \"$(echo \"$program_name\" | tr '[A-Z]' '[a-z]' | sed 's/wrapper$//')\" ; then\n  AC_MSG_ERROR([$program_name is not a valid program name (should not terminate with Wrapper)])\nfi\nif test \"$(echo \"$program_name\" | tr '[A-Z]' '[a-z]')\" != \"$(echo \"$program_name\" | tr '[A-Z]' '[a-z]' | sed 's/kernel$//')\" ; then\n  AC_MSG_ERROR([$program_name is not a valid program name (should not terminate with Kernel)])\nfi\nif test \"$(echo \"$program_name\" | tr '[A-Z]' '[a-z]')\" != \"$(echo \"$program_name\" | tr '[A-Z]' '[a-z]' | sed 's/-patch$//')\" ; then\n  AC_MSG_ERROR([$program_name is not a valid program name (should not terminate with -patch)])\nfi\nif test \"$(echo \"$program_name\" | tr '[A-Z]' '[a-z]')\" != \"$(echo \"$program_name\" | tr '[A-Z]' '[a-z]' | sed 's/-config$//')\" ; then\n  AC_MSG_ERROR([$program_name is not a valid program name (should not terminate with -config)])\nfi\n\nAC_MSG_NOTICE([**** PLUMED will be installed using the following paths:])\nAC_MSG_NOTICE([**** prefix: $prefix])\nif test \"$exec_prefix\" = NONE ; then\n  exec_prefix_='${prefix}'\nelse\n  exec_prefix_=\"${exec_prefix}\"\nfi\nAC_MSG_NOTICE([**** exec_prefix: $exec_prefix_])\nAC_MSG_NOTICE([**** bindir: $bindir])\nAC_MSG_NOTICE([**** libdir: $libdir])\nAC_MSG_NOTICE([**** includedir: $includedir])\nAC_MSG_NOTICE([**** datarootdir: $datarootdir])\nAC_MSG_NOTICE([**** datadir: $datadir])\nAC_MSG_NOTICE([**** docdir: ${datarootdir}/doc/$program_name])\nAC_MSG_NOTICE([**** htmldir: $htmldir])\nAC_MSG_NOTICE([**** Executable will be named $program_name])\nAC_MSG_NOTICE([**** As of PLUMED 2.5, you cannot change paths anymore during \"make install\"])\nAC_MSG_NOTICE([**** Please configure and make clean to change the prefix])\n\nif test -z \"$BASH_COMPLETION_DIR\" ; then\n  AC_MSG_WARN([**** Bash completion for plumed will not be installed, please add the following two lines to your bashrc])\n  AC_MSG_WARN([**** _$program_name() { eval \"\\$($program_name --no-mpi completion 2>/dev/null)\";}])\n  AC_MSG_WARN([**** complete -F _$program_name -o default $program_name])\nfi\n\nif test $mpi == true; then\n  if test $mpi_found == ok; then\n    AC_MSG_NOTICE([**** PLUMED will be compiled using MPI])\n  else \n    AC_MSG_WARN([**** PLUMED will NOT be compiled using MPI because MPI have not been found!])\n  fi\nelse\n    AC_MSG_NOTICE([**** PLUMED will be compiled without MPI])\nfi\n\nif test $program_can_run == no ; then\n  AC_MSG_WARN([plumed executable will not run on this machine])\n  AC_MSG_WARN([to patch an MD code use 'plumed-patch'])\nelif test $mpi_found == ok ; then\n  if test $program_can_run_mpi == no ; then\n    AC_MSG_WARN([plumed executable will not run on this machine])\n    AC_MSG_WARN([unless you invoke it as 'plumed --no-mpi'])\n    AC_MSG_WARN([all command line tools are thus available as 'plumed --no-mpi name-of-the-tool'])\n    AC_MSG_WARN([e.g. 'plumed --no-mpi driver'])\n    AC_MSG_WARN([to patch an MD code use 'plumed --no-mpi patch'])\n    AC_MSG_WARN([(notice that MPI will be available anyway in the patched code)])\n  fi\nfi\n\nAC_SUBST(build_dir)\nbuild_dir=`pwd`\n\n\n\n# This is to replace tags in Makefile.conf.in\n# saving the result to Makefile.conf\nAC_CONFIG_FILES([Makefile.conf sourceme.sh])\n# This is to have the stamp-h file up to date\n# The date of this file keeps track of when Makefile.conf and sourceme.sh have been updated\nAC_CONFIG_FILES([stamp-h], [echo timestamp > stamp-h])\nAC_OUTPUT\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/src/wrapper/Plumed.h": "/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n   Copyright (c) 2011-2019 The plumed team\n   (see the PEOPLE file at the root of the distribution for a list of names)\n\n   See http://www.plumed.org for more information.\n\n   This file is part of plumed, version 2.\n\n   plumed is free software: you can redistribute it and/or modify\n   it under the terms of the GNU Lesser General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   plumed is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public License\n   along with plumed.  If not, see <http://www.gnu.org/licenses/>.\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */\n#ifndef __PLUMED_wrapper_Plumed_h\n#define __PLUMED_wrapper_Plumed_h\n\n/*\n  This header might be included more than once in order to provide\n  the declarations and the definitions. The guard is thus closed before the end of the file\n  (match this brace) {\n  and a new guard is added for the definitions.\n*/\n\n/**\n\\page ReferencePlumedH Reference for interfacing MD codes with PLUMED\n\n  Plumed.h and Plumed.c contain the external plumed interface, which is used to\n  integrate it with MD engines. This interface is very general, and is expected\n  not to change across plumed versions. Plumed.c also implements a dummy version\n  of the interface, so as to allow a code to be fully linked even if the plumed\n  library is not available yet. These files could be directly included in the official\n  host MD distribution. In this manner, it will be sufficient to link the plumed\n  library at link time (on all systems) or directly at runtime (on systems where\n  dynamic loading is enabled) to include plumed features.\n\n  Notice that in PLUMED 2.5 this interface has been rewritten in order to allow\n  more debugging features and a better behavior in multithread environments.\n  The interface is almost perfectly backward compatible, although it implements\n  a few additional functions. See more details below.\n\n  Why is Plumed.c written in C and not C++? The reason is that the resulting Plumed.o\n  needs to be linked with the host MD code immediately (whereas the rest of plumed\n  could be linked a posteriori). Imagine the MD code is written in FORTRAN: when we\n  link the Plumed.o file we would like not to need any C++ library linked. In this\n  manner, we do not need to know which C++ compiler will be used to compile plumed.\n  The C++ library is only linked to the \"rest\" of plumed, which actually uses it.\n  Anyway, Plumed.c is written in such a manner to allow its compilation also in C++\n  (C++ is a bit stricter than C). This will\n  allow e.g. MD codes written in C++ to just incorporate Plumed.c (maybe renamed into\n  Plumed.cpp), without the need of configuring a plain C compiler.\n\n  Plumed interface can be used from C, C++ and FORTRAN. Everything concerning plumed\n  is hidden inside a single object type, which is described in C by a structure\n  (struct \\ref plumed), in C++ by a class (PLMD::Plumed) and in FORTRAN by a\n  fixed-length string (CHARACTER(LEN=32)). Obviously C++ can use both struct\n  and class interfaces, but the second should be preferred since it will automatically take\n  care of objects constructions and destructions. The reference interface\n  is the C one, whereas FORTRAN and C++ interfaces are implemented as wrappers\n  around it.\n  In the C++ interface, all the routines are implemented as methods of PLMD::Plumed.\n  In the C and FORTRAN interfaces, all the routines are named plumed_*, to\n  avoid potential name clashes. Notice that the entire plumed library\n  is implemented in C++, and it is hidden inside the PLMD namespace.\n\n  Handlers to the plumed object can be converted among different representations,\n  to allow inter-operability among languages. In C, there are tools to convert\n  to/from FORTRAN, whereas in C++ there are tools to convert to/from FORTRAN and C.\n\n  These handlers only contain a pointer to the real structure, so that\n  when a plumed object is brought from one language to another,\n  it brings a reference to the same environment.\n\n  Moreover, to simplify life in all cases where a single Plumed object is\n  required for the entire simulation (which covers many of the practical\n  applications with conventional MD codes) it is possible to take advantage\n  of a global interface, which is implicitly referring to a unique global instance.\n  The global object should still be initialized and finalized properly.\n  This global object is obviously not usable in a multithread context.\n\n  As of PLUMED 2.5, the interface contains a reference counter that allows\n  for a better control of plumed initializations and deallocations.\n  This is particularly useful for the C++ interface that now\n  behaves similarly to a primitive shared pointer and can be thus copied.\n  In other languages, to use the reference counter correctly it is sufficient to\n  remember the following rule: for any `plumed_create*` call, there should be a corresponding\n  `plumed_finalize` call. More examples can be found below.\n\n  The basic method to send a message to plumed is\n\\verbatim\n  (C) plumed_cmd\n  (C++) PLMD::Plumed::cmd\n  (FORTRAN)  PLUMED_F_CMD\n\\endverbatim\n\n  To initialize a plumed object, use:\n\\verbatim\n  (C)        plumed_create\n  (C++)      (constructor of PLMD::Plumed)\n  (FORTRAN)  PLUMED_F_CREATE\n\\endverbatim\n\n  As of PLUMED 2.5, you can also initialize a plumed object using the following functions,\n  that load a specific kernel:\n\\verbatim\n  (C)        plumed_create_dlopen\n  (C++)      PLMD::Plumed::dlopen\n  (FORTRAN)  PLUMED_F_CREATE_DLOPEN\n\\endverbatim\n\n  To finalize a plumed object, use\n\\verbatim\n  (C)        plumed_finalize\n  (C++)      (destructor of PLMD::Plumed)\n  (FORTRAN)  PLUMED_F_FINALIZE\n\\endverbatim\n\n  To access to the global-object, use\n\\verbatim\n  (C)        plumed_gcreate, plumed_gfinalize, plumed_gcmd\n  (C++)      PLMD::Plumed::gcreate, PLMD::Plumed::gfinalize, PLMD::Plumed::gcmd\n  (FORTRAN)  PLUMED_F_GCREATE, PLUMED_F_GFINALIZE, PLUMED_F_GCMD\n\\endverbatim\n\n  To check if the global object has been initialized, use\n\\verbatim\n  (C)        plumed_ginitialized\n  (C++)      PLMD::Plumed::ginitialized\n  (FORTRAN)  PLUMED_F_GINITIALIZED\n\\endverbatim\n\n  Notice that when using runtime binding the plumed library might be not available.\n  In this case, plumed_create (and plumed_gcreate) will still succeed, but a subsequent\n  call to plumed_cmd (or plumed_gcmd) would exit. In order to avoid this\n  unpleasant situation you have two options.\n\n  First, you can check if plumed library is available before actually creating an object\n  using this function:\n\\verbatim\n  (C)        plumed_installed\n  (C++)      PLMD::Plumed::installed\n  (FORTRAN)  PLUMED_F_INSTALLED\n\\endverbatim\n\n  Alternatively, as of PLUMED 2.5, you can interrogate the just created plumed\n  object using the following function:\n\\verbatim\n  (C)        plumed_valid\n  (C++)      PLMD::Plumed::valid\n  (FORTRAN)  PLUMED_F_VALID\n\\endverbatim\n\n  If you want to create on purpose an invalid Plumed object (useful in C++ to postpone\n  the loading of the library) you can use `Plumed p(Plumed::makeInvalid());`.\n\n  To know if the global object is valid instead you should use the following function:\n\\verbatim\n  (C)        plumed_gvalid\n  (C++)      PLMD::Plumed::gvalid\n  (FORTRAN)  PLUMED_F_GVALID\n\\endverbatim\n\n  To convert handlers between different languages, use\n\\verbatim\n  (C)        plumed_c2f                 (C to FORTRAN)\n  (C)        plumed_f2c                 (FORTRAN to C)\n  (C++)      Plumed(plumed) constructor (C to C++)\n  (C++)      operator plumed() cast     (C++ to C)\n  (C++)      Plumed(char*)  constructor (FORTRAN to C++)\n  (C++)      toFortran(char*)           (C++ to FORTRAN)\n\\endverbatim\n\n  As of PLUMED 2.5, when using C or C++ we allow a user to explicitly store a plumed object as\n  a void pointer (indeed: that's the only thing contained in a plumed object).\n  This might be useful in case you do not want to include the Plumed.h header in some\n  of your headers. In order to convert to/from void pointers you can use the following functions\n\\verbatim\n  (C)        plumed_v2c                 (void* to C)\n  (C)        plumed_c2v                 (C to void*)\n  (C++)      Plumed(void*) constructor  (void* to C++)\n  (C++)      toVoid()                   (C++ to void*)\n\\endverbatim\n  Using the functions above is much safer than accessing directly the pointer contained in the \\ref plumed struct\n  since, when compiling with debug options, it will check if the void pointer actually points to a plumed object.\n\n  As of PLUMED 2.5, we added a reference count. It is in practice possible\n  to create multiple `plumed` object that refer to the same environment.\n  This is done using the following functions\n\\verbatim\n  (C)        plumed_create_reference     (from a C object)\n  (C)        plumed_create_reference_f   (from a FORTRAN object)\n  (C)        plumed_create_reference_v   (from a void pointer)\n  (FORTRAN)  plumed_f_create_reference   (from a FORTRAN object)\n\\endverbatim\n  In C++ references are managed automatically by constructors and destructor.\n  In addition, you can manually manage them (with care!) using incref() and decref().\n\n  The interface of the FORTRAN functions is very similar to that of the C functions\n  and is listed below:\n\n\\verbatim\n  FORTRAN interface\n    SUBROUTINE PLUMED_F_CREATE(p)\n      CHARACTER(LEN=32), INTENT(OUT)   :: p\n    SUBROUTINE PLUMED_F_CREATE_DLOPEN(p,path)\n      CHARACTER(LEN=32), INTENT(OUT)   :: p\n      CHARACTER(LEN=*),  INTENT(IN)    :: path\n    SUBROUTINE PLUMED_F_CREATE_REFERENCE(p,r)\n      CHARACTER(LEN=32), INTENT(OUT)   :: p\n      CHARACTER(LEN=32), INTENT(IN)    :: r\n    SUBROUTINE PLUMED_F_CREATE_INVALID(p)\n      CHARACTER(LEN=32), INTENT(OUT)   :: p\n    SUBROUTINE PLUMED_F_CMD(p,key,val)\n      CHARACTER(LEN=32), INTENT(IN)    :: p\n      CHARACTER(LEN=*),  INTENT(IN)    :: key\n      UNSPECIFIED_TYPE,  INTENT(INOUT) :: val(*)\n    SUBROUTINE PLUMED_F_FINALIZE(p)\n      CHARACTER(LEN=32), INTENT(IN)    :: p\n    SUBROUTINE PLUMED_F_INSTALLED(i)\n      INTEGER,           INTENT(OUT)   :: i\n    SUBROUTINE PLUMED_F_VALID(p,i)\n      CHARACTER(LEN=32), INTENT(IN)    :: p\n      INTEGER,           INTENT(OUT)   :: i\n    SUBROUTINE PLUMED_F_USE_COUNT(p,i)\n      CHARACTER(LEN=32), INTENT(IN)    :: p\n      INTEGER,           INTENT(OUT)   :: i\n    SUBROUTINE PLUMED_F_GLOBAL(p)\n      CHARACTER(LEN=32), INTENT(OUT)   :: p\n    SUBROUTINE PLUMED_F_GINITIALIZED(i)\n      INTEGER,           INTENT(OUT)   :: i\n    SUBROUTINE PLUMED_F_GCREATE()\n    SUBROUTINE PLUMED_F_GCMD(key,val)\n      CHARACTER(LEN=*), INTENT(IN)     :: key\n      UNSPECIFIED_TYPE, INTENT(INOUT)  :: val(*)\n    SUBROUTINE PLUMED_F_GFINALIZE()\n    SUBROUTINE PLUMED_F_GVALID(i)\n      INTEGER,           INTENT(OUT)   :: i\n\\endverbatim\n\n  Almost all C functions have a corresponding FORTRAN function.\n  As a simple mnemonic, if you know the name of the C function you can obtain the\n  corresponding FORTRAN subroutine by adding `F_` after the `PLUMED_` prefix.\n  In addition, all `plumed` objects are replaced by `CHARACTER(LEN=32)` objects\n  holding the same information. These pointers basically contain a text representation\n  of the stored pointer, that is suitable to be contained in a string.\n  Finally, whenever a C function returns a value,\n  the corresponding FORTRAN subroutine will have an additional `INTENT(OUT)` parameter\n  passed as the its last argument.\n\n  When you compile the FORTRAN interface, wrapper functions are added with several possible\n  name manglings, so you should not experience problems linking the plumed library with a FORTRAN file.\n\n\\section ReferencePlumedH-exceptions Error handling\n\n  In case an error is detected by PLUMED, either because of some user error, some internal bug,\n  or some mistake in using the library, an exception will be thrown. The behavior is different depending if you use\n  PLUMED from C/FORTRAN or from C++.\n\n  First of all, notice that access to PLUMED goes through three functions:\n  - plumed_create: this, as of PLUMED 2.5, is guaranteed not to throw any exception. If there is a problem, it will\n    just return a NULL pointer\n  - plumed_cmd: this function might throw exceptions.\n  - plumed_finalize: this is a destructor and is guaranteed not to throw any exception.\n\n  The following discussion concerns all the exceptions thrown by plumed_cmd.\n\n  If you use C/FORTRAN, you will basically have no way to intercept the exception and the program will just terminate.\n\n  If you use C++ but you are calling the C interface (e.g. \\ref plumed_cmd), then you might be\n  able to catch the exceptions thrown by PLUMED. Notice that all the exceptions thrown by PLUMED inherit from std::exception,\n  so you might want to catch it by reference. Notice however that there is a C layer between your C++ code and the PLUMED\n  library. In principle, the stack unwinding performed during exception handling is undefined in C and might lead to problems\n  that are system and compiler dependent. In addition to this, there might be troubles when combining different compilers\n  or different standard libraries. E.g., if you MD code is linked against a given C++ library and PLUMED is linked against\n  another one, the two std::exception types will differ and you won't be able to catch exceptions raised by PLUMED.\n\n  If you use C++ and you are calling the C++ interface (e.g. \\ref Plumed::cmd), as of PLUMED 2.5 we implemented a complete\n  remapping of the exceptions thrown by PLUMED.  This solves both the problems mentioned above. In particular:\n  - Instead of throwing an exception, PLUMED will return (using a \\ref plumed_nothrow_handler) the details about the occurred error.\n  - An equivalent exception will be thrown within the inline PLUMED interface compiled with your MD code.\n\n  As a consequence, you will be able to combine different compilers and avoid stack unwinding in the C layer.\n\n  Notice that, even if you use \\ref Plumed::cmd, if you are loading a kernel <=2.4 any exception generated by PLUMED will\n  leak through the C layer. This might lead to undefined behavior. If you are lucky (with some compiler it works!) and\n  the exception arrives to C, PLUMED will catch it and rethrow it as it would do if you were using a kernel >=2.5.\n\n  The remapping of exceptions takes care of all the standard C++ exceptions plus all the exceptions raised within\n  PLUMED. Unexpected exceptions that are derived from std::exception will be rethrown as std::exception.\n  Notice that this implies some loss of information, since the original exception might have been of a different type.\n  However, it also implies that the virtual table of the original exception won't be needed anymore. This allows to\n  completely decouple the MD code from the PLUMED library.\n\n\\section ReferencePlumedH-2-5 New in PLUMED 2.5\n\n  The wrappers in PLUMED 2.5 have been completely rewritten with several improvements.\n  The interface is almost perfectly backward compatible, although the behavior of C++ constructors\n  has been modified slightly.\n  In addition, a few new functions are introduced (explicitly marked in the documentation).\n  As a consequence, if your code uses some of the new functions, you will not be able\n  to link it directly with an older PLUMED library (though you will still be able to load\n  an older PLUMED library at runtime). In addition, the reference counter changes slightly\n  the behavior of the C++ methods used to interoperate with C and FORTRAN.\n\n  An important novelty is in the way the runtime loader is implemented.\n  In particular, the loader works also if the symbols of the main executable are not exported.\n  The proper functions from the kernel are indeed searched explicitly now using `dlsym`.\n\n  Some additional features can be enabled using suitable environment variables. In particular:\n  - `PLUMED_LOAD_DEBUG` can be set to report more information about the loading process.\n  - `PLUMED_LOAD_NAMESPACE` can be set to `LOCAL` to load the PLUMED kernel in a separate\n    namespace. The default is global namespace, which is the same behavior of PLUMED <=2.4,\n    and is consistent with what happens when linking PLUMED as a shared library.\n  - `PLUMED_LOAD_NODEEPBIND` can be set to load the PLUMED kernel in not-deepbind mode. Deepbind\n    mode implies that the symbols defined in the library are preferred to other symbols with the same name.\n    Only works on systems supporting `RTLD_DEEPBIND` and is mostly for debugging purposes.\n\n  Another difference is that the implementation of the wrappers is now completely contained in the `Plumed.h`\n  file. You can see that the `Plumed.c` is much simpler now and just includes `Plumed.h`. With a similar\n  procedure you could compile the wrappers directly into your code making it unnecessary to link\n  the libplumedWrapper.a library. The corresponding macros are still subject to change and are not documented here.\n\n  As written above, the plumed object now implements a reference counter.  Consider the following example\n\\verbatim\n  plumed p=plumed_create();\n  plumed_cmd(p,\"init\",NULL);\n  plumed q=plumed_create_reference(p);\n  plumed_finalize(p);\n// at this stage, object q still exists\n  plumed_cmd(q,\"whatever\",NULL);\n  plumed_finalize(q);\n// now plumed has been really finalized\n\\endverbatim\n\n  In other words, every \\ref plumed_create, \\ref plumed_create_dlopen, \\ref plumed_create_reference,\n  \\ref plumed_create_reference_f, and \\ref plumed_create_reference_v call must be matched by a \\ref plumed_finalize.\n  Notice that in C++ whenever an object goes out of scope the reference counter\n  will be decreased. In addition, consider that conversion from C/FORTRAN/void* to C++ implies calling a C++ constructor, that\n  is increases the number of references by one. Converting from C++ to C/FORTRAN/void* instead does not call any constructor,\n  that is the number of references is unchanged.\n\n  The change in the behavior of C++ constructors means that the following code will behave in a backward incompatible manner:\n\\verbatim\n  plumed p=plumed_create();\n  plumed_cmd(p,\"init\",NULL);\n  Plumed q(p);\n  plumed_finalize(p);\n// at this stage, object q still exists with PLUMED 2.5\n// on the other hand, with PLUMED 2.4 object q refers to an\n// already finalized object\n  q.cmd(\"whatever\",NULL);\n\\endverbatim\n\n  Another difference is that the value of the variable `PLUMED_KERNEL` is read every time a new\n  plumed object is instantiated. So, you might even use it to load different plumed versions\n  simultaneously, although the preferred way to do this is using the function \\ref plumed_create_dlopen.\n  Notice that if you want to load multiple versions simultaneously you should load them in a local namespace.\n  \\ref plumed_create_dlopen does it automatically, whereas loading through env var `PLUMED_KERNEL` only does it if\n  you also set env var `PLUMED_NAMESPACE=LOCAL`.\n\n  Finally, a few functions have been added, namely:\n  - Functions to find if a plumed object is valid\n    (\\ref plumed_valid(), \\ref plumed_gvalid(), \\ref PLMD::Plumed::valid(), and \\ref PLMD::Plumed::gvalid()).\n  - Functions to create a plumed object based on the path of a specific kernel\n    (\\ref plumed_create_dlopen() and \\ref PLMD::Plumed::dlopen()).\n  - Functions to create a plumed object referencing to another one, implementing a reference counter\n    (\\ref plumed_create_reference(), \\ref plumed_create_reference_v(), \\ref plumed_create_reference_f().\n\n*/\n\n/* BEGINNING OF DECLARATIONS */\n\n/* SETTING DEFAULT VALUES FOR CONTROL MACROS */\n\n/*\n  1: make the C wrapper functions extern (default)\n  0: make the C wrapper functions static (C) or inline (C++)\n\n  If set to zero, it disables all functions that only make sense as extern, such as\n  Fortran wrappers, global objects, and plumed_kernel_register.\n\n  It can be set to zero to include multiple copies of the wrapper implementation without worrying\n  about duplicated symbols.\n\n  Notice that C++ wrappers are always inline. What this function controls is if the C wrappers\n  (called by the C++ wrappers) is inline or not. Also consider that if this header is compiled\n  with C++ and inline C wrappers, the C wrappers will be actually compiled with C++ linkage\n  in the root namespace.\n\n  Used both in declarations (to know which functions to declare) and definitions (to know which functions to define).\n*/\n\n#ifndef __PLUMED_WRAPPER_EXTERN\n#define __PLUMED_WRAPPER_EXTERN 1\n#endif\n\n/*\n  1: emit global plumed object and related functions (default)\n  0: do not emit global plumed object and related functions\n\n  Used both in declarations (to know which functions to declare) and definitions (to know which functions to define).\n*/\n\n#ifndef __PLUMED_WRAPPER_GLOBAL\n#define __PLUMED_WRAPPER_GLOBAL 1\n#endif\n\n/*\n  1: enable C++ wrapper (default)\n  0: disable C++ wrapper\n\n  Only used in declarations, but affects the scope of the C interface also in definitions.\n*/\n\n#ifndef __PLUMED_WRAPPER_CXX\n#define __PLUMED_WRAPPER_CXX 1\n#endif\n\n/*\n  1: new headers such as cstdlib are included in C++ (default)\n  0: old headers such as stdlib.h are included in C++\n\n  Should only be set to zero when including the Plumed.h file in a file using the\n  old (stdlib.h) convention.\n\n  Used both in declarations and definitions.\n*/\n\n#ifndef __PLUMED_WRAPPER_CXX_STD\n#define __PLUMED_WRAPPER_CXX_STD 1\n#endif\n\n/*\n  1: place C++ wrappers in an anonymous namespace\n  0: place C++ wrappers in the PLMD namespace (default)\n\n  It will make PLMD::Plumed a different class (though with the same name)\n  in each of the translation units in which `Plumed.h` is included.\n\n  Can be used to completey separate C++ implementations. However, it will make\n  it impossible to transfer Plumed objects between different translation units\n  without converting to a void* or plumed object.\n\n  Only used in declarations, but affects the scope of the C interface also in definitions.\n*/\n\n#ifndef __PLUMED_WRAPPER_CXX_ANONYMOUS_NAMESPACE\n#define __PLUMED_WRAPPER_CXX_ANONYMOUS_NAMESPACE 0\n#endif\n\n/*\n  1: make PLMD::Plumed class polymorphic (default)\n  0: make PLMD::Plumed class non-polymorphic\n\n  Only used in declarations.\n*/\n\n#ifndef __PLUMED_WRAPPER_CXX_POLYMORPHIC\n#define __PLUMED_WRAPPER_CXX_POLYMORPHIC 1\n#endif\n\n/*\n  1: make the default constructor create an invalid object\n  0: make the default constructor create a valid object\n\n  Only for internal usage.\n*/\n#ifndef __PLUMED_WRAPPER_CXX_DEFAULT_INVALID\n#define __PLUMED_WRAPPER_CXX_DEFAULT_INVALID 0\n#endif\n\n/*\n  Size of a buffer used to store message for exceptions with noexcept constructor.\n  Should typically hold short messages. Anyway, as long as the stack size stays within the correct\n  limits it does not seem to affect efficiency. Notice that there cannot be recursive calls of\n  PLMD::Plumed::cmd, so that it should be in practice irrelevant.\n*/\n#ifndef __PLUMED_WRAPPER_CXX_EXCEPTION_BUFFER\n#define __PLUMED_WRAPPER_CXX_EXCEPTION_BUFFER 512\n#endif\n\n\n/*\n By default, assume C++11 compliant library is not available.\n*/\n\n#ifndef __PLUMED_WRAPPER_LIBCXX11\n#define __PLUMED_WRAPPER_LIBCXX11 0\n#endif\n\n/* The following macros are just to define shortcuts */\n\n/* Simplify addition of extern \"C\" blocks.  */\n#ifdef __cplusplus\n#define __PLUMED_WRAPPER_EXTERN_C_BEGIN extern \"C\" {\n#define __PLUMED_WRAPPER_EXTERN_C_END }\n#else\n#define __PLUMED_WRAPPER_EXTERN_C_BEGIN\n#define __PLUMED_WRAPPER_EXTERN_C_END\n#endif\n\n/* Without C++, stdlib functions should not be prepended with ::std:: */\n#ifndef __cplusplus\n#undef __PLUMED_WRAPPER_CXX_STD\n#define __PLUMED_WRAPPER_CXX_STD 0\n#endif\n\n/* Set prefix for stdlib functions */\n#if __PLUMED_WRAPPER_CXX_STD\n#define __PLUMED_WRAPPER_STD ::std::\n#else\n#define __PLUMED_WRAPPER_STD\n#endif\n\n/* Allow using noexcept and explicit with C++11 compilers */\n#if __cplusplus > 199711L\n#define __PLUMED_WRAPPER_CXX_NOEXCEPT noexcept\n#define __PLUMED_WRAPPER_CXX_EXPLICIT explicit\n#else\n#define __PLUMED_WRAPPER_CXX_NOEXCEPT throw()\n#define __PLUMED_WRAPPER_CXX_EXPLICIT\n#endif\n\n/* Macros for anonymous namespace */\n#if __PLUMED_WRAPPER_CXX_ANONYMOUS_NAMESPACE && defined(__cplusplus) /*{*/\n#define __PLUMED_WRAPPER_ANONYMOUS_BEGIN namespace {\n#define __PLUMED_WRAPPER_ANONYMOUS_END }\n#else\n#define __PLUMED_WRAPPER_ANONYMOUS_BEGIN\n#define __PLUMED_WRAPPER_ANONYMOUS_END\n#endif /*}*/\n\n#if __PLUMED_WRAPPER_EXTERN /*{*/\n\n#define __PLUMED_WRAPPER_C_BEGIN __PLUMED_WRAPPER_EXTERN_C_BEGIN extern\n#define __PLUMED_WRAPPER_C_END __PLUMED_WRAPPER_EXTERN_C_END\n#define __PLUMED_WRAPPER_INTERNALS_BEGIN __PLUMED_WRAPPER_EXTERN_C_BEGIN static\n#define __PLUMED_WRAPPER_INTERNALS_END __PLUMED_WRAPPER_EXTERN_C_END\n\n#else\n\n#ifdef __cplusplus\n#define __PLUMED_WRAPPER_C_BEGIN  __PLUMED_WRAPPER_ANONYMOUS_BEGIN inline\n#define __PLUMED_WRAPPER_C_END __PLUMED_WRAPPER_ANONYMOUS_END\n#else\n#define __PLUMED_WRAPPER_C_BEGIN static\n#define __PLUMED_WRAPPER_C_END\n#endif\n\n#define __PLUMED_WRAPPER_INTERNALS_BEGIN __PLUMED_WRAPPER_C_BEGIN\n#define __PLUMED_WRAPPER_INTERNALS_END __PLUMED_WRAPPER_C_END\n\n/* with an not-external interface, it does not make sense to define global functions */\n#undef __PLUMED_WRAPPER_GLOBAL\n#define __PLUMED_WRAPPER_GLOBAL 0\n\n#endif /*}*/\n\n/**\n  \\brief Main plumed object\n\n  This is an object containing a Plumed instance, which should be used in\n  the MD engine. It should first be initialized with plumed_create(),\n  then it communicates with the MD engine using plumed_cmd(). Finally,\n  before the termination, it should be deallocated with plumed_finalize().\n  Its interface is very simple and general, and is expected\n  not to change across plumed versions. See \\ref ReferencePlumedH.\n*/\ntypedef struct {\n  /**\n    \\private\n    \\brief Void pointer holding the real PlumedMain structure\n\n    To maintain binary compatibility, we should not add members to this structure.\n    As of PLUMED 2.5, in order to add new components we do not store the pointer\n    to \\ref PlumedMain here but rather a pointer to an intermediate private structure\n    that contains all the details.\n  */\n  void*p;\n} plumed;\n\ntypedef struct {\n  void* ptr;\n  void (*handler)(void*,int,const char*,const void*);\n} plumed_nothrow_handler;\n\n/** \\relates plumed\n    \\brief Constructor\n\n    Constructs a plumed object.\n\n    Notice that if you are linking against libplumedWrapper.a, if you are\n    using a code patched in runtime mode, or if you are including the `Plumed.c`\n    file directly in your code, this constructor might return an invalid plumed\n    object. In particular, this could happen if the `PLUMED_KERNEL` environment\n    variable is not set or set incorrectly. In order to detect an incorrect\n    plumed object you might use \\ref plumed_valid() on the resulting object.\n    Alternatively, if you use \\ref plumed_cmd() on an invalid plumed object the code will exit.\n    Also notice that to avoid memory leaks you should call \\ref plumed_finalize()\n    to finalize a plumed object even if it is invalid:\n\\verbatim\n  plumed p=plumed_create();\n  if(!plumed_valid(p)) {\n// this will happen if the PLUMED_KERNEL variable is not set correctly\n    plumed_finalize(p);\n    return whatever;\n  }\n\\endverbatim\n\n    \\return The constructed plumed object\n*/\n__PLUMED_WRAPPER_C_BEGIN\nplumed plumed_create(void);\n__PLUMED_WRAPPER_C_END\n\n/** \\relates plumed\n    \\brief Constructor from path. Available as of PLUMED 2.5\n\n    It tries to construct a plumed object loading the kernel located at path.\n    Notice that it could leave the resulting object in an invalid state.\n    In order to detect an invalid\n    plumed object you might use \\ref plumed_valid() on the resulting object.\n    Alternatively, if you use \\ref plumed_cmd() on an invalid plumed object the code will exit.\n\n    Also notice that to avoid memory leaks you should call \\ref plumed_finalize()\n    to finalize a plumed object even if it is invalid.\n\\verbatim\n  plumed p=plumed_create(path);\n  if(!plumed_valid(p)) {\n// this will happen if the path argument is not set correctly\n    plumed_finalize(p);\n    return whatever;\n  }\n\\endverbatim\n\n    \\return The constructed plumed object\n*/\n__PLUMED_WRAPPER_C_BEGIN\nplumed plumed_create_dlopen(const char*path);\n__PLUMED_WRAPPER_C_END\n\n\n/**\n  \\brief Constructor from path. Available as of PLUMED 2.5\n\n  Same as \\ref plumed_create_dlopen, but also allows to specify the mode for dlopen.\n\n  \\warning\n  Use with care, since not all the possible modes work correctly with PLUMED.\n*/\n__PLUMED_WRAPPER_C_BEGIN\nplumed plumed_create_dlopen2(const char*path,int mode);\n__PLUMED_WRAPPER_C_END\n\n/** \\relates plumed\n    Create a new reference to an existing object, increasing its reference count. Available as of PLUMED 2.5\n\n    Use it to increase by one the reference count of a plumed object.\n    The resulting pointer might be identical to the one passed as an\n    argument, but the reference count will be incremented by one.\n    Notice that you should finalize the resulting object.\n\\verbatim\n  plumed p1;\n  plumed p2;\n  p1=plumed_create();\n  p2=plumed_create_reference(p1);\n  plumed_finalize(p1);\n// now you can still use p2\n  plumed_cmd(p2,\"init\",NULL);\n  plumed_finalize(p2);\n// now the underlying object is destroyed.\n\\endverbatim\n\n    If the `p` object is invalid, also the returned object will be invalid.\n\n    \\param p The plumed object that will be referenced to.\n    \\return The constructed plumed object\n*/\n\n__PLUMED_WRAPPER_C_BEGIN\nplumed plumed_create_reference(plumed p);\n__PLUMED_WRAPPER_C_END\n\n/** \\relates plumed\n    \\brief Create a new reference to an existing object passed as a void pointer, increasing its reference count. Available as of PLUMED 2.5\n\n  \\return The constructed plumed object\n*/\n\n__PLUMED_WRAPPER_C_BEGIN\nplumed plumed_create_reference_v(void*v);\n__PLUMED_WRAPPER_C_END\n\n/** \\relates plumed\n    \\brief Create a new reference to an existing object passed as a fortran string, increasing its reference count. Available as of PLUMED 2.5\n\n  \\return The constructed plumed object\n*/\n\n__PLUMED_WRAPPER_C_BEGIN\nplumed plumed_create_reference_f(const char*f);\n__PLUMED_WRAPPER_C_END\n\n/** \\relates plumed\n    \\brief Constructor as invalid. Available as of PLUMED 2.5\n\n   Can be used to create an object in the same state as if it was returned by\n   plumed_create_dlopen with an incorrect path (or plumed_create using runtime binding\n   and an incorrect PLUMED_KERNEL).\n\n   Can be used to initialize a plumed object to a well-defined state without explicitly\n   creating it. The resulting object can be checked later with \\ref plumed_valid.\n   Consider the following example\n\\verbatim\n    plumed p;\n    p=plumed_create_invalid();\n// at this point p is initialized to a well-defined (invalid) state.\n    setenv(\"PLUMED_KERNEL\",\"/path/to/kernel/libplumedKernel.so\",1);\n    plumed_finalize(p);\n    p=plumed_create();\n\\endverbatim\n\n    \\return The constructed plumed object\n*/\n\n__PLUMED_WRAPPER_C_BEGIN\nplumed plumed_create_invalid();\n__PLUMED_WRAPPER_C_END\n\n/** \\relates plumed\n    \\brief Tells p to execute a command.\n\n    If the object is not valid (see \\ref plumed_valid), this command will exit.\n\n    \\param p The plumed object on which command is acting\n    \\param key The name of the command to be executed\n    \\param val The argument. It is declared as const to allow calls like plumed_cmd(p,\"A\",\"B\"),\n               but for some choice of key it can change the content.\n\n    Notice that within PLUMED we use a const_cast to remove any const qualifier from the second\n    argument of \\ref plumed_cmd.\n\n    In some cases val can be omitted: just pass a NULL pointer (in C++, val is optional and can be omitted,\n    or you can equivalently pass NULL or nullptr).\n    The set of possible keys is the real API of the plumed library, and will be expanded with time.\n    New commands will be added, but backward compatibility will be retained as long as possible.\n*/\n\n__PLUMED_WRAPPER_C_BEGIN\nvoid plumed_cmd(plumed p,const char*key,const void*val);\n__PLUMED_WRAPPER_C_END\n\n/**\n  \\relates plumed\n  \\brief Same as \\ref plumed_cmd, but does not throw exceptions.\n\n  This function is meant to be used when errors should be handled explicitly.\n  if an exception is raised within PLUMED, the function nothrow.handler() will\n  be called with arguments (nothrow.ptr,code,message,opt). This allows the C++ interface\n  to correctly rethrow exceptions, but might be used from C as well. opt can be used\n  to pass further information (not used yet).\n*/\n\n__PLUMED_WRAPPER_C_BEGIN\nvoid plumed_cmd_nothrow(plumed p,const char*key,const void*val,plumed_nothrow_handler nothrow);\n__PLUMED_WRAPPER_C_END\n\n/** \\relates plumed\n    \\brief Destructor.\n\n    It must be used for any object created using \\ref plumed_create(),\n    even if the created object is not valid.\n\n    \\param p The plumed object to be deallocated\n*/\n\n__PLUMED_WRAPPER_C_BEGIN\nvoid plumed_finalize(plumed p);\n__PLUMED_WRAPPER_C_END\n\n/** \\relates plumed\n    \\brief Check if plumed is installed (for runtime binding).\n\n    Notice that this is equivalent to creating a dummy object and checking if it is valid.\n\n\\verbatim\n  // this:\n  //int a=plumed_installed();\n  // is equivalent to this:\n\n  plumed p=plumed_create();\n  int a=plumed_valid(p);\n  plumed_finalize(p);\n\n\\endverbatim\n\n    This function is mostly provided for compatibility with PLUMED 2.4, where \\ref plumed_valid()\n    was not available. Using \\ref plumed_valid() is now preferred since it creates a single object\n    instead of creating a dummy object that is then discarded.\n\n    \\return 1 if plumed is installed, 0 otherwise\n*/\n\n__PLUMED_WRAPPER_C_BEGIN\nint plumed_installed(void);\n__PLUMED_WRAPPER_C_END\n\n/** \\relates plumed\n    \\brief Check if plumed object is valid. Available as of PLUMED 2.5\n\n    It might return false if plumed is not available at runtime.\n\n    \\return 1 if plumed is valid, 0 otherwise\n*/\n\n__PLUMED_WRAPPER_C_BEGIN\nint plumed_valid(plumed p);\n__PLUMED_WRAPPER_C_END\n\n/** \\relates plumed\n    \\brief Returns the number of references to the underlying object. Available as of PLUMED 2.5.\n*/\n\n__PLUMED_WRAPPER_C_BEGIN\nint plumed_use_count(plumed p);\n__PLUMED_WRAPPER_C_END\n\n\n/* routines to convert char handler from/to plumed objects */\n\n/** \\related plumed\n    \\brief Converts a C handler to a FORTRAN handler\n\n    \\param p The C handler\n    \\param c The FORTRAN handler (a char[32])\n\n    This function can be used to convert a plumed object created in C to\n    a plumed handler that can be used in FORTRAN. Notice that the reference counter\n    is not incremented. In other words, the FORTRAN object will be a weak reference.\n    If you later finalize the C handler, the FORTRAN handler will be invalid.\n\\verbatim\n#include <plumed/wrapper/Plumed.h>\nint main(int argc,char*argv[]){\n  plumed p;\n  p=plumed_create();\n  char fortran_handler[32];\n  plumed_c2f(p,fortran_handler);\n  printf(\"DEBUG: this is a string representation for the plumed handler: %s\\n\",fortran_handler);\n  fortran_routine(fortran_handler);\n  plumed_finalize(p);\n  return 0;\n}\n\\endverbatim\n  Here `fortran_routine` is a routine implemented in FORTRAN that manipulates the\n  fortran_handler.\n*/\n\n__PLUMED_WRAPPER_C_BEGIN\nvoid   plumed_c2f(plumed p,char* c);\n__PLUMED_WRAPPER_C_END\n\n/** \\related plumed\n    \\brief Converts a FORTRAN handler to a C handler\n    \\param c The FORTRAN handler (a char[32])\n    \\return The C handler\n\n    This function can be used to convert a plumed object created in FORTRAN\n    to a plumed handler that can be used in C.  Notice that the reference counter\n    is not incremented. In other words, the C object will be a weak reference.\n    If you later finalize the FORTRAN handler, the C handler will be invalid.\n\\verbatim\nvoid c_routine(char handler[32]){\n  plumed p;\n  p=plumed_f2c(handler);\n  plumed_cmd(p,\"init\",NULL);\n}\n\\endverbatim\n  Here `c_routine` is a C function that can be called from FORTRAN\n  and interact with the provided plumed handler.\n*/\n\n__PLUMED_WRAPPER_C_BEGIN\nplumed plumed_f2c(const char* c);\n__PLUMED_WRAPPER_C_END\n\n/** \\related plumed\n    \\brief Converts a plumed object to a void pointer. Available as of PLUMED 2.5.\n\n    It returns a void pointer that can be converted back to a plumed object using \\ref plumed_v2c.\n    When compiling without NDEBUG, it checks if the plumed object was properly created.\n    Notice that an invalid object (see \\ref plumed_valid) can be converted to void* and back.\n\n    Can be used to store a reference to a plumed object without including the Plumed.h header.\n*/\n\n__PLUMED_WRAPPER_C_BEGIN\nvoid* plumed_c2v(plumed p);\n__PLUMED_WRAPPER_C_END\n\n\n/** \\related plumed\n    \\brief Converts a void pointer to a plumed object. Available as of PLUMED 2.5.\n\n    It returns a plumed object from a void pointer obtained with \\ref plumed_c2v.\n    When compiling without NDEBUG, it checks if the plumed object was properly created.\n\n    Can be used to store a reference to a plumed object without including the Plumed.h header.\n*/\n\n__PLUMED_WRAPPER_C_BEGIN\nplumed plumed_v2c(void*);\n__PLUMED_WRAPPER_C_END\n\n\n#if __PLUMED_WRAPPER_GLOBAL /*{*/\n\n/* Global C functions are always extern */\n__PLUMED_WRAPPER_EXTERN_C_BEGIN /*{*/\n\n/** \\relates plumed\n    \\brief Retrieves an handler to the global structure.\n\n  You can use this if you work on a code that uses the global structure and you want to\n  pass to a generic routine an handler to the same structure. E.g.\n\n\\verbatim\n  plumed p=plumed_global();\n  some_routine(p);\n\\endverbatim\n*/\nextern\nplumed plumed_global(void);\n\n/** \\relates plumed\n    \\brief Check if the global interface has been initialized.\n\n    \\return 1 if plumed has been initialized, 0 otherwise\n*/\nextern\nint plumed_ginitialized(void);\n\n/** \\relates plumed\n    \\brief Constructor for the global interface.\n\n    \\note Equivalent to plumed_create(), but initialize the static global plumed object\n*/\nextern\nvoid plumed_gcreate(void);\n\n/** \\relates plumed\n    \\brief Tells to the global interface to execute a command.\n\n    \\param key The name of the command to be executed\n    \\param val The argument. It is declared as const to allow calls like plumed_gcmd(\"A\",\"B\"),\n               but for some choice of key it can change the content\n\n    `plumed_gcmd(a,b);` is equivalent to `plumed_cmd(plumed_global(),a,b);`.\n*/\nextern\nvoid plumed_gcmd(const char* key,const void* val);\n\n/** \\relates plumed\n    \\brief Destructor for the global interface.\n\n    `plumed_gfinalize(a,b);` is similar to `plumed_finalize(plumed_global(),a,b);`, but not completely\n    equivalent. In particular, plumed_gfinalize() also makes sure that the global object\n    is reset to its initial status. After calling it, \\ref plumed_ginitialized() will thus return 0.\n*/\nextern\nvoid plumed_gfinalize(void);\n\n/** \\relates plumed\n    \\brief Check if global plumed object is valid. Available as of PLUMED 2.5\n\n    It might return zero if plumed is not available at runtime.\n\n    \\return 1 if plumed is valid, 0 otherwise.\n*/\nextern\nint plumed_gvalid();\n\n__PLUMED_WRAPPER_EXTERN_C_END /*}*/\n\n#endif /*}*/\n\n#if defined( __cplusplus) && __PLUMED_WRAPPER_CXX /*{*/\n\n#if __PLUMED_WRAPPER_CXX_STD\n#include <cstdlib> /* NULL getenv */\n#include <cstring> /* strncat strlen */\n#include <cstdio> /* fprintf */\n#else\n#include <stdlib.h>\n#include <string.h>\n#include <stdio.h>\n#endif\n\n#include <exception> /* exception bad_exception */\n#include <stdexcept> /* runtime_error logic_error invalid_argument domain_error length_error out_of_range range_error overflow_error underflow_error */\n#include <string> /* string */\n#include <ios> /* iostream_category (C++11) ios_base::failure (C++11 and C++<11) */\n#include <new> /* bad_alloc bad_array_new_length (C++11) */\n#include <typeinfo> /* bad_typeid bad_cast */\n#if __cplusplus > 199711L && __PLUMED_WRAPPER_LIBCXX11\n#include <system_error> /* system_error generic_category system_category */\n#include <future> /* future_category */\n#include <memory> /* bad_weak_ptr */\n#include <functional> /* bad_function_call */\n#endif\n\n/* C++ interface is hidden in PLMD namespace (same as plumed library) */\nnamespace PLMD {\n\n/* Optionally, it is further hidden in an anonymous namespace */\n\n__PLUMED_WRAPPER_ANONYMOUS_BEGIN /*{*/\n\n/**\n  C++ wrapper for \\ref plumed.\n\n  This class provides a C++ interface to PLUMED.\n  It only containts a \\ref plumed object, but wraps it with a number of useful methods.\n  All methods are inlined so as to avoid the compilation of an extra c++ file.\n\n*/\n\nclass Plumed {\n  /**\n    C structure.\n  */\n  plumed main;\n\n  /**\n    Error handler used to rethrow exceptions.\n  */\n\n  struct NothrowHandler {\n    /** code used for translating messages */\n    int code;\n    /** short message buffer for non-throwing exceptions */\n    char exception_buffer[__PLUMED_WRAPPER_CXX_EXCEPTION_BUFFER];\n    /** if exception_buffer='\\0', message stored as an allocatable string */\n    ::std::string what;\n    /** error code for system_error */\n    int error_code;\n  };\n\n  /**\n    Callback function that sets the error handler.\n\n    opt argument is interpreted as the pointer to a null terminated array of void*.\n    The number of non-null element is expected to be even, and there should be a null element\n    that follows. Every pair of pointers should point\n    to a char, identifying the type of argument passed, and an arbitrary object.\n    Currently used to (optionally) pass error_code.\n  */\n  static void nothrow_handler(void*ptr,int code,const char*what,const void* opt) {\n    NothrowHandler* h=(NothrowHandler*) ptr;\n    h->code=code;\n    h->exception_buffer[0]='\\0';\n    h->what.clear();\n    h->error_code=0;\n    /*\n       These codes correspond to exceptions that should not allocate a separate buffer but use the fixed one.\n       Notice that a mismatch between the exceptions using the stack buffer here and those implementing\n       the stack buffer would be in practice harmless. However, it makes sense to be consistent.\n    */\n    if(code==10000 || (code>=11000 && code<12000)) {\n      __PLUMED_WRAPPER_STD strncat(h->exception_buffer,what,__PLUMED_WRAPPER_CXX_EXCEPTION_BUFFER-1);\n    } else {\n      h->what=what;\n    }\n\n    /* interpret optional arguments */\n    const void** options=(const void**)opt;\n    if(options) while(*options) {\n        if(*((char*)*options)=='c') h->error_code=*((int*)*(options+1));\n        options+=2;\n      }\n\n    static const char* debug=__PLUMED_WRAPPER_STD getenv(\"PLUMED_EXCEPTIONS_DEBUG\");\n\n    if(debug) {\n      __PLUMED_WRAPPER_STD fprintf(stderr,\"+++ PLUMED_EXCEPTIONS_DEBUG\\n\");\n      __PLUMED_WRAPPER_STD fprintf(stderr,\"+++ code: %d error_code: %d message:\\n%s\\n\",h->code,h->error_code,what);\n      if(__PLUMED_WRAPPER_STD strlen(what) > __PLUMED_WRAPPER_CXX_EXCEPTION_BUFFER-1) __PLUMED_WRAPPER_STD fprintf(stderr,\"+++ WARNING: message will be truncated\\n\");\n      __PLUMED_WRAPPER_STD fprintf(stderr,\"+++ END PLUMED_EXCEPTIONS_DEBUG\\n\");\n    }\n\n  }\n\n  /**\n    Rethrow the exception based on the information saved in the NothrowHandler.\n  */\n\n  static void rethrow(const NothrowHandler&h) {\n    /* The interpretation of the codes should be kept in sync with core/PlumedMainInitializer.cpp */\n    /* check if we are using a full string or a fixes size buffer */\n    const char* msg=(h.exception_buffer[0]?h.exception_buffer:h.what.c_str());\n    if(h.code==1) throw Plumed::Invalid(msg);\n    /* logic errors */\n    if(h.code>=10100 && h.code<10200) {\n      if(h.code>=10105 && h.code<10110) throw ::std::invalid_argument(msg);\n      if(h.code>=10110 && h.code<10115) throw ::std::domain_error(msg);\n      if(h.code>=10115 && h.code<10120) throw ::std::length_error(msg);\n      if(h.code>=10120 && h.code<10125) throw ::std::out_of_range(msg);\n      throw ::std::logic_error(msg);\n    }\n    /* runtime errors */\n    if(h.code>=10200 && h.code<10300) {\n      if(h.code>=10205 && h.code<10210) throw ::std::range_error(msg);\n      if(h.code>=10210 && h.code<10215) throw ::std::overflow_error(msg);\n      if(h.code>=10215 && h.code<10220) throw ::std::underflow_error(msg);\n#if __cplusplus > 199711L && __PLUMED_WRAPPER_LIBCXX11\n      if(h.code==10220) throw ::std::system_error(h.error_code,::std::generic_category(),msg);\n      if(h.code==10221) throw ::std::system_error(h.error_code,::std::system_category(),msg);\n      if(h.code==10222) throw ::std::system_error(h.error_code,::std::iostream_category(),msg);\n      if(h.code==10223) throw ::std::system_error(h.error_code,::std::future_category(),msg);\n#endif\n      if(h.code>=10230 && h.code<10240) {\n#if __cplusplus > 199711L && __PLUMED_WRAPPER_LIBCXX11\n// These cases are probably useless as it looks like this should always be std::iostream_category\n        if(h.code==10230) throw ::std::ios_base::failure(msg,std::error_code(h.error_code,::std::generic_category()));\n        if(h.code==10231) throw ::std::ios_base::failure(msg,std::error_code(h.error_code,::std::system_category()));\n        if(h.code==10232) throw ::std::ios_base::failure(msg,std::error_code(h.error_code,::std::iostream_category()));\n        if(h.code==10233) throw ::std::ios_base::failure(msg,std::error_code(h.error_code,::std::future_category()));\n#endif\n        throw ::std::ios_base::failure(msg);\n      }\n      throw ::std::runtime_error(msg);\n    }\n    /* \"bad\" errors */\n    if(h.code>=11000 && h.code<11100) throw Plumed::std_bad_typeid(msg);\n    if(h.code>=11100 && h.code<11200) throw Plumed::std_bad_cast(msg);\n#if __cplusplus > 199711L && __PLUMED_WRAPPER_LIBCXX11\n    if(h.code>=11200 && h.code<11300) throw Plumed::std_bad_weak_ptr(msg);\n    if(h.code>=11300 && h.code<11400) throw Plumed::std_bad_function_call(msg);\n#endif\n    if(h.code>=11400 && h.code<11500) {\n#if __cplusplus > 199711L && __PLUMED_WRAPPER_LIBCXX11\n      if(h.code>=11410 && h.code<11420) throw Plumed::std_bad_array_new_length(msg);\n#endif\n      throw Plumed::std_bad_alloc(msg);\n    }\n    if(h.code>=11500 && h.code<11600) throw Plumed::std_bad_exception(msg);\n    /* lepton error */\n    if(h.code>=19900 && h.code<20000) throw Plumed::LeptonException(msg);\n    /* plumed exceptions */\n    if(h.code>=20000 && h.code<30000) {\n      /* debug - only raised with debug options */\n      if(h.code>=20100 && h.code<20200) throw Plumed::ExceptionDebug(msg);\n      /* error - runtime check */\n      if(h.code>=20200 && h.code<20300) throw Plumed::ExceptionError(msg);\n      throw Plumed::Exception(msg);\n    }\n    /* fallback for any other exception */\n    throw Plumed::std_exception(msg);\n  }\n\n  /**\n    Rethrow the current exception.\n\n    This is useful in order to handle an exception thrown by a kernel <=2.4.\n    Only std exceptions are handled, though some of them are thrown as special\n    Plumed exceptions in order to be attached a message.\n  */\n  static void rethrow() {\n    try {\n      throw;\n    } catch(const ::std::bad_exception & e) {\n      throw Plumed::std_bad_exception(e.what());\n#if __cplusplus > 199711L && __PLUMED_WRAPPER_LIBCXX11\n    } catch(const ::std::bad_array_new_length & e) {\n      throw Plumed::std_bad_array_new_length(e.what());\n#endif\n    } catch(const ::std::bad_alloc & e) {\n      throw Plumed::std_bad_alloc(e.what());\n#if __cplusplus > 199711L && __PLUMED_WRAPPER_LIBCXX11\n    } catch(const ::std::bad_function_call & e) {\n      throw Plumed::std_bad_function_call(e.what());\n    } catch(const ::std::bad_weak_ptr & e) {\n      throw Plumed::std_bad_weak_ptr(e.what());\n#endif\n    } catch(const ::std::bad_cast & e) {\n      throw Plumed::std_bad_cast(e.what());\n    } catch(const ::std::bad_typeid & e) {\n      throw Plumed::std_bad_typeid(e.what());\n      // not implemented yet: std::regex_error\n      // we do not allow regex yet due to portability problems with gcc 4.8\n      // as soon as we transition to using <regex> it should be straightforward to add\n    } catch(const ::std::ios_base::failure & e) {\n#if __cplusplus > 199711L && __PLUMED_WRAPPER_LIBCXX11\n      throw ::std::ios_base::failure(e.what(),e.code());\n#else\n      throw ::std::ios_base::failure(e.what());\n#endif\n#if __cplusplus > 199711L && __PLUMED_WRAPPER_LIBCXX11\n    } catch(const ::std::system_error & e) {\n      throw ::std::system_error(e.code(),e.what());\n#endif\n    } catch(const ::std::underflow_error &e) {\n      throw ::std::underflow_error(e.what());\n    } catch(const ::std::overflow_error &e) {\n      throw ::std::overflow_error(e.what());\n    } catch(const ::std::range_error &e) {\n      throw ::std::range_error(e.what());\n    } catch(const ::std::runtime_error & e) {\n      throw ::std::runtime_error(e.what());\n      // not implemented yet: std::future_error\n      // not clear how useful it would be.\n    } catch(const ::std::out_of_range & e) {\n      throw ::std::out_of_range(e.what());\n    } catch(const ::std::length_error & e) {\n      throw ::std::length_error(e.what());\n    } catch(const ::std::domain_error & e) {\n      throw ::std::domain_error(e.what());\n    } catch(const ::std::invalid_argument & e) {\n      throw ::std::invalid_argument(e.what());\n    } catch(const ::std::logic_error & e) {\n      throw ::std::logic_error(e.what());\n    } catch(const ::std::exception & e) {\n      throw Plumed::std_exception(e.what());\n    } catch(...) {\n      throw Plumed::std_bad_exception(\"plumed could not translate exception\");\n    }\n  }\n\npublic:\n\n  /**\n    Base class used to rethrow PLUMED exceptions.\n  */\n\n  class Exception :\n    public ::std::exception\n  {\n    ::std::string msg;\n  public:\n    __PLUMED_WRAPPER_CXX_EXPLICIT Exception(const char* msg): msg(msg) {}\n    Exception(const Exception & other): msg(other.what()) {}\n    const char* what() const __PLUMED_WRAPPER_CXX_NOEXCEPT {return msg.c_str();}\n    ~Exception() __PLUMED_WRAPPER_CXX_NOEXCEPT {}\n  };\n\n  /**\n    Used to rethrow a PLMD::ExceptionError\n  */\n\n  class ExceptionError :\n    public Exception {\n  public:\n    __PLUMED_WRAPPER_CXX_EXPLICIT ExceptionError(const char* msg): Exception(msg) {}\n    ExceptionError(const ExceptionError & other) : Exception(other.what()) {}\n    ~ExceptionError() __PLUMED_WRAPPER_CXX_NOEXCEPT {}\n  };\n\n  /**\n    Used to rethrow a PLMD::ExceptionDebug\n  */\n\n  class ExceptionDebug :\n    public Exception {\n  public:\n    __PLUMED_WRAPPER_CXX_EXPLICIT ExceptionDebug(const char* msg): Exception(msg) {}\n    ExceptionDebug(const ExceptionDebug & other) : Exception(other.what()) {}\n    ~ExceptionDebug() __PLUMED_WRAPPER_CXX_NOEXCEPT {}\n  };\n\n  /**\n    Thrown when trying to access an invalid plumed object\n  */\n\n  class Invalid :\n    public Exception {\n  public:\n    __PLUMED_WRAPPER_CXX_EXPLICIT Invalid(const char* msg): Exception(msg) {}\n    Invalid(const Invalid & other) : Exception(other.what()) {}\n    ~Invalid() __PLUMED_WRAPPER_CXX_NOEXCEPT {}\n  };\n\n  /**\n    Class used to rethrow Lepton exceptions.\n  */\n\n  class LeptonException :\n    public ::std::exception\n  {\n    ::std::string msg;\n  public:\n    __PLUMED_WRAPPER_CXX_EXPLICIT LeptonException(const char* msg): msg(msg) {}\n    LeptonException(const LeptonException & other): msg(other.what()) {}\n    const char* what() const __PLUMED_WRAPPER_CXX_NOEXCEPT {return msg.c_str();}\n    ~LeptonException() __PLUMED_WRAPPER_CXX_NOEXCEPT {}\n  };\n\nprivate:\n  /*\n    These exceptions are declared as private as they are not supposed to be\n    catched by value. they only exist to allow a buffer to be attached to\n    the std::exceptions that do not contain it already.\n    Notice that these exceptions are those whose constructor should never throw, and as\n    such they use a fixed size buffer.\n  */\n\n#define __PLUMED_WRAPPER_NOSTRING_EXCEPTION(name) \\\n  class std_ ## name : \\\n    public ::std::name \\\n  { \\\n    char msg[__PLUMED_WRAPPER_CXX_EXCEPTION_BUFFER]; \\\n  public: \\\n    __PLUMED_WRAPPER_CXX_EXPLICIT std_ ## name(const char * msg) __PLUMED_WRAPPER_CXX_NOEXCEPT { \\\n      this->msg[0]='\\0'; \\\n      __PLUMED_WRAPPER_STD strncat(this->msg,msg,__PLUMED_WRAPPER_CXX_EXCEPTION_BUFFER-1); \\\n      static const char* debug=__PLUMED_WRAPPER_STD getenv(\"PLUMED_EXCEPTIONS_DEBUG\"); \\\n      if(debug && __PLUMED_WRAPPER_STD strlen(msg) > __PLUMED_WRAPPER_CXX_EXCEPTION_BUFFER-1) __PLUMED_WRAPPER_STD fprintf(stderr,\"+++ WARNING: message will be truncated\\n\"); \\\n    } \\\n    std_ ## name(const std_ ## name & other) __PLUMED_WRAPPER_CXX_NOEXCEPT { \\\n      msg[0]='\\0'; \\\n      __PLUMED_WRAPPER_STD strncat(msg,other.msg,__PLUMED_WRAPPER_CXX_EXCEPTION_BUFFER-1); \\\n    } \\\n    std_ ## name & operator=(const std_ ## name & other) __PLUMED_WRAPPER_CXX_NOEXCEPT { \\\n      if(this==&other) return *this;\\\n      msg[0]='\\0'; \\\n      __PLUMED_WRAPPER_STD strncat(msg,other.msg,__PLUMED_WRAPPER_CXX_EXCEPTION_BUFFER-1); \\\n      return *this; \\\n    } \\\n    const char* what() const __PLUMED_WRAPPER_CXX_NOEXCEPT {return msg;} \\\n    ~std_ ## name() __PLUMED_WRAPPER_CXX_NOEXCEPT {} \\\n  };\n\n  __PLUMED_WRAPPER_NOSTRING_EXCEPTION(bad_typeid)\n  __PLUMED_WRAPPER_NOSTRING_EXCEPTION(bad_cast)\n#if __cplusplus > 199711L && __PLUMED_WRAPPER_LIBCXX11\n  __PLUMED_WRAPPER_NOSTRING_EXCEPTION(bad_weak_ptr)\n  __PLUMED_WRAPPER_NOSTRING_EXCEPTION(bad_function_call)\n#endif\n  __PLUMED_WRAPPER_NOSTRING_EXCEPTION(bad_alloc)\n#if __cplusplus > 199711L && __PLUMED_WRAPPER_LIBCXX11\n  __PLUMED_WRAPPER_NOSTRING_EXCEPTION(bad_array_new_length)\n#endif\n  __PLUMED_WRAPPER_NOSTRING_EXCEPTION(bad_exception)\n  __PLUMED_WRAPPER_NOSTRING_EXCEPTION(exception)\n\npublic:\n\n  /**\n     Check if plumed is installed (for runtime binding)\n     \\return true if plumed is installed, false otherwise\n     \\note Equivalent to plumed_installed() but returns a bool\n  */\n  static bool installed() __PLUMED_WRAPPER_CXX_NOEXCEPT {\n    return plumed_installed();\n  }\n  /**\n     Check if Plumed object is valid. Available as of PLUMED 2.5\n     \\return true if plumed is valid, false otherwise\n     \\note Equivalent to plumed_valid() but returns a bool\n  */\n  bool valid() const __PLUMED_WRAPPER_CXX_NOEXCEPT {\n    return plumed_valid(main);\n  }\n#if __cplusplus > 199711L\n  /**\n     Same as \\ref valid(). Available as of PLUMED 2.5.\n\n  Allow code such as\n  \\verbatim\n  Plumed p;\n  if(!p) raise_error();\n  p.cmd(\"init\");\n  \\endverbatim\n\n  In order to avoid ambiguous conversions, this is only allowed when compiling with C++11\n  where it is marked as explicit.\n  */\n  explicit\n  operator bool() const __PLUMED_WRAPPER_CXX_NOEXCEPT {\n    return plumed_valid(main);\n  }\n#endif\n\n  /**\n     Returns the number of references to this object. Available as of PLUMED 2.5.\n    \\note Equivalent to plumed_use_count()\n  */\n  int useCount() const __PLUMED_WRAPPER_CXX_NOEXCEPT {\n    return plumed_use_count(main);\n  }\n\n#if __PLUMED_WRAPPER_GLOBAL /*{*/\n  /**\n     Check if global-plumed has been initialized\n     \\return true if global plumed object (see global()) is initialized (i.e. if gcreate() has been\n             called), false otherwise.\n     \\note Equivalent to plumed_ginitialized() but returns a bool\n  */\n  static bool ginitialized() __PLUMED_WRAPPER_CXX_NOEXCEPT {\n    return plumed_ginitialized();\n  }\n  /**\n     Check if global-plumed is valid\n     \\return true if global plumed object (see global()) is valid.\n     \\note Equivalent to plumed_gvalid() but returns a bool\n  */\n  static bool gvalid() __PLUMED_WRAPPER_CXX_NOEXCEPT {\n    return plumed_gvalid();\n  }\n  /**\n     Initialize global-plumed.\n     \\note Equivalent to plumed_gcreate()\n  */\n  static void gcreate() __PLUMED_WRAPPER_CXX_NOEXCEPT {\n    plumed_gcreate();\n  }\n  /**\n     Send a command to global-plumed\n      \\param key The name of the command to be executed\n      \\param val The argument. It is declared as const to allow calls like gcmd(\"A\",\"B\"),\n                 but for some choice of key it can change the content\n     \\note Equivalent to plumed_gcmd()\n  */\n  static void gcmd(const char* key,const void* val=NULL) {\n    global().cmd(key,val);\n  }\n  /**\n     Finalize global-plumed\n  */\n  static void gfinalize() __PLUMED_WRAPPER_CXX_NOEXCEPT {\n    plumed_gfinalize();\n  }\n  /**\n     Returns the Plumed global object\n\n     Notice that the object is copied, thus increasing the reference counter of the\n     global object. In this manner, the global object will survive after a call to\n     \\ref gfinalize() if the resulting object is still in scope.\n\n     \\return The Plumed global object\n  */\n  static Plumed global() __PLUMED_WRAPPER_CXX_NOEXCEPT {\n    return Plumed(plumed_global());\n  }\n#endif /*}*/\n  /**\n     Constructor.\n\n    Notice that when using runtime binding the constructed object might be\n    invalid. One might check it using the \\ref valid() method.\n\n    \\note Performs the same task a plumed_create()\n  */\nPlumed()__PLUMED_WRAPPER_CXX_NOEXCEPT :\n#if __PLUMED_WRAPPER_CXX_DEFAULT_INVALID\n  main(plumed_create_invalid())\n#else\n  main(plumed_create())\n#endif\n  {\n  }\n\n  /**\n     Clone a Plumed object from a FORTRAN char* handler.\n\n     \\param c The FORTRAN handler (a char[32]).\n\n     The reference counter for the corresponding object will be increased\n     to make sure that the object will be available after plumed_f_finalize is called\n     if the created object is still in scope.\n  */\n__PLUMED_WRAPPER_CXX_EXPLICIT Plumed(const char*c)__PLUMED_WRAPPER_CXX_NOEXCEPT :\n  main(plumed_create_reference_f(c))\n  {\n  }\n\n  /**\n    Create a reference from a void* pointer. Available as of PLUMED 2.5.\n  */\n__PLUMED_WRAPPER_CXX_EXPLICIT Plumed(void*v)__PLUMED_WRAPPER_CXX_NOEXCEPT :\n  main(plumed_create_reference_v(v))\n  {\n  }\n\n  /**\n     Clone a Plumed object from a C plumed structure\n\n     \\param p The C plumed structure.\n\n     The reference counter for the corresponding object will be increased\n     to make sure that the object will be available after plumed_finalize is called\n     if the created object is still in scope.\n  */\n__PLUMED_WRAPPER_CXX_EXPLICIT Plumed(plumed p)__PLUMED_WRAPPER_CXX_NOEXCEPT :\n  main(plumed_create_reference(p))\n  {\n  }\n\n  /** Copy constructor.\n\n    Takes a reference, incrementing the reference counter of the corresponding object.\n  */\nPlumed(const Plumed& p)__PLUMED_WRAPPER_CXX_NOEXCEPT :\n  main(plumed_create_reference(p.main))\n  {\n  }\n\n  /** Assignment operator. Available as of PLUMED 2.5.\n\n    Takes a reference,incrementing the reference counter of the corresponding object.\n  */\n  Plumed&operator=(const Plumed&p) __PLUMED_WRAPPER_CXX_NOEXCEPT {\n    if(this != &p) {\n// the check is needed to avoid calling plumed_finalize on moved objects\n      if(main.p) decref();\n      main=plumed_create_reference(p.main);\n    }\n    return *this;\n  }\n\n  /*\n    PLUMED >= 2.4 requires a C++11 compiler.\n    Anyway, since Plumed.h file might be redistributed with other codes\n    and it should be possible to combine it with earlier PLUMED versions,\n    we here explicitly check if C+11 is available before enabling move semantics.\n  */\n#if __cplusplus > 199711L\n  /** Move constructor. Available as of PLUMED 2.5.\n    Only if move semantics is enabled.\n  */\nPlumed(Plumed&&p)__PLUMED_WRAPPER_CXX_NOEXCEPT :\n  main(p.main)\n  {\n    p.main.p=nullptr;\n  }\n  /** Move assignment. Available as of PLUMED 2.5.\n    Only if move semantics is enabled.\n  */\n  Plumed& operator=(Plumed&&p)__PLUMED_WRAPPER_CXX_NOEXCEPT  {\n    if(this != &p) {\n// the check is needed to avoid calling plumed_finalize on moved objects\n      if(main.p) decref();\n      main=p.main;\n      p.main.p=nullptr;\n    }\n    return *this;\n  }\n#endif\n  /**\n    Create a PLUMED object loading a specific kernel. Available as of PLUMED 2.5.\n\n    It returns an object created with \\ref plumed_create_dlopen. The object is owned and\n    is then finalized in the destructor. It can be used as follows:\n  \\verbatim\n    PLMD::Plumed p = PLMD::Plumed::dlopen(\"/path/to/libplumedKernel.so\");\n  // or, equivalenty:\n  //    PLMD::Plumed p(PLMD::Plumed::dlopen(\"/path/to/libplumedKernel.so\"));\n    p.cmd(\"init\");\n  \\endverbatim\n    or, equivalently, as\n  \\verbatim\n    auto p = PLMD::Plumed::dlopen(\"/path/to/libplumedKernel.so\");\n    p.cmd(\"init\");\n  \\endverbatim\n  */\n  static Plumed dlopen(const char* path)__PLUMED_WRAPPER_CXX_NOEXCEPT  {\n// use decref to remove the extra reference\n    return Plumed(plumed_create_dlopen(path)).decref();\n  }\n\n  /**\n    Create a PLUMED object loading a specific kernel. Available as of PLUMED 2.5.\n\n    Same as \\ref dlopen(const char* path), but allows a dlopen mode to be chosen explicitly.\n  */\n  static Plumed dlopen(const char* path,int mode)__PLUMED_WRAPPER_CXX_NOEXCEPT  {\n// use decref to remove the extra reference\n    return Plumed(plumed_create_dlopen2(path,mode)).decref();\n  }\n  /** Invalid constructor. Available as of PLUMED 2.5.\n\n    Can be used to initialize an invalid object. It might be useful to postpone\n    the initialization of a Plumed object. Consider the following case\n  \\verbatim\n    Plumed p;\n    setenv(\"PLUMED_KERNEL\",\"/path/to/kernel/libplumedKernel.so\",1);\n    p.cmd(\"init\")\n  \\endverbatim\n    Here the `p` object will be initialized *before* the `PLUMED_KERNEL` env var has been set.\n    This can be particularly problematic if `p` is stored in some high level class.\n    The following case would do the job\n  \\verbatim\n    Plumed p;\n    setenv(\"PLUMED_KERNEL\",\"/path/to/kernel/libplumedKernel.so\",1);\n    p=Plumed();\n    p.cmd(\"init\")\n  \\endverbatim\n    However, there will be some error reported related to the attempt to load the kernel\n    when `p` is initialized. The following solution is the optimal one:\n  \\verbatim\n    Plumed p(Plumed::makeInvalid());\n    setenv(\"PLUMED_KERNEL\",\"/path/to/kernel/libplumedKernel.so\",1);\n    p=Plumed();\n    p.cmd(\"init\")\n  \\endverbatim\n  */\n  static Plumed makeInvalid() __PLUMED_WRAPPER_CXX_NOEXCEPT  {\n// use decref to remove the extra reference\n    return Plumed(plumed_create_invalid()).decref();\n  }\n\n  /**\n    Create a valid PLMD::Plumed object.\n\n    Can be used to create a valid object e.g. when Plumed.h was compiled with\n    `-D__PLUMED_WRAPPER_CXX_DEFAULT_INVALID`. For internal usage.\n  */\n\n  static Plumed makeValid()__PLUMED_WRAPPER_CXX_NOEXCEPT  {\n// use decref to remove the extra reference\n    return Plumed(plumed_create()).decref();\n  }\n\n\n  /**\n     Retrieve the C plumed structure for this object.\n\n     Notice that the resulting plumed structure is a weak reference and\n     should NOT be finalized, unless a new reference is explicitly added\n  \\verbatim\n  Plumed p;\n  plumed c=p;\n  plumed_finalize(c); // <- this is wrong\n  \\endverbatim\n  \\verbatim\n  Plumed p;\n  plumed c=plumed_create_reference(p);\n  plumed_finalize(c); // <- this is right\n  \\endverbatim\n  */\n  operator plumed()const __PLUMED_WRAPPER_CXX_NOEXCEPT {\n    return main;\n  }\n\n  /**\n     Retrieve a FORTRAN handler for this object\n      \\param c The FORTRAN handler (a char[32]).\n    Notice that the resulting plumed structure is a weak reference and\n    should NOT be finalized, unless a new reference is explicitly added.\n  */\n  void toFortran(char*c)const __PLUMED_WRAPPER_CXX_NOEXCEPT {\n    plumed_c2f(main,c);\n  }\n\n  /**\n     Retrieve a void* handler for this object. Available as of PLUMED 2.5.\n    Notice that the resulting plumed structure is a weak reference and\n    should NOT be finalized, unless a new reference is explicitly added.\n  */\n  void* toVoid()const __PLUMED_WRAPPER_CXX_NOEXCEPT {\n    return plumed_c2v(main);\n  }\n\n  /**\n    Increase reference counter. Available as of PLUMED 2.5.\n\n    Using this method improperly might interfere with correct object construction\n    and destruction.\n    If you want to play with this, also try to compile using `-D__PLUMED_WRAPPER_DEBUG_REFCOUNT=1` and see what happens.\n\n    A possible usage is to transfer the ownership of a temporary\n    object when it is converted\n  \\verbatim\n  plumed p=Plumed::dlopen(path).incref()\n  // without incref(), the just constructed object will be destroyed\n  // when the temporary object is deleted.\n  ... do stuff ...\n  plumed_finalize(p);\n  \\endverbatim\n\n  */\n  Plumed& incref() __PLUMED_WRAPPER_CXX_NOEXCEPT {\n    plumed_create_reference(main);\n    return *this;\n  }\n\n  /**\n    Decrease reference counter. Available as of PLUMED 2.5.\n\n    Using this method improperly might interfere with correct object construction\n    and destruction.\n    If you want to play with this, also try to compile using `-D__PLUMED_WRAPPER_DEBUG_REFCOUNT=1` and see what happens.\n  */\n  Plumed& decref() __PLUMED_WRAPPER_CXX_NOEXCEPT {\n// calling decref on a moved plumed object should give an error, so we do not check if main.p!=NULL here:\n    plumed_finalize(main);\n    return *this;\n  }\n\n  /**\n     Send a command to this plumed object\n      \\param key The name of the command to be executed\n      \\param val The argument. It is declared as const to allow calls like p.cmd(\"A\",\"B\"),\n                 but for some choice of key it can change the content\n      \\note Similar to \\ref plumed_cmd(). It actually called \\ref plumed_cmd_nothrow() and\n            rethrow any exception raised within PLUMED.\n  */\n  void cmd(const char*key,const void*val=NULL) {\n    NothrowHandler h;\n    h.code=0;\n    plumed_nothrow_handler nothrow= {&h,nothrow_handler};\n    try {\n      plumed_cmd_nothrow(main,key,val,nothrow);\n    } catch (...) {\n      /*\n        When loading a kernel <=2.4, plumed_cmd_nothrow could throw an exception.\n        If the exception is transmitted through the C interface and arrives here,\n        we translate it so as to free the virtual tables of the loaded kernel.\n      */\n      rethrow();\n    }\n    if(h.code!=0) rethrow(h);\n  }\n\n  /**\n     Destructor\n\n     It calls \\ref plumed_finalize(). Notice that this is done also if the\n     constructor failed (that is, if it returned an invalid object). This allows\n     declaring Plumed objects also if PLUMED is actually not available, provided\n     one does not use the \\ref cmd method.\n\n     Destructor is virtual so as to allow correct inheritance from Plumed object.\n  */\n#if __PLUMED_WRAPPER_CXX_POLYMORPHIC\n  virtual\n#endif\n  ~Plumed() __PLUMED_WRAPPER_CXX_NOEXCEPT {\n// the check is needed to avoid calling plumed_finalize on moved objects\n    if(main.p) decref();\n  }\n};\n\n/**\n  \\related Plumed\n  Comparison operator. Available as of PLUMED 2.5.\n*/\ninline\nbool operator==(const Plumed&a,const Plumed&b) __PLUMED_WRAPPER_CXX_NOEXCEPT {\n  return a.toVoid()==b.toVoid();\n}\n\n/**\n  \\related Plumed\n  Comparison operator. Available as of PLUMED 2.5.\n*/\ninline\nbool operator!=(const Plumed&a,const Plumed&b) __PLUMED_WRAPPER_CXX_NOEXCEPT {\n  return a.toVoid()!=b.toVoid();\n}\n\n/**\n  \\related Plumed\n  Comparison operator. Available as of PLUMED 2.5.\n*/\ninline\nbool operator<=(const Plumed&a,const Plumed&b) __PLUMED_WRAPPER_CXX_NOEXCEPT {\n  return a.toVoid()<=b.toVoid();\n}\n\n/**\n  \\related Plumed\n  Comparison operator. Available as of PLUMED 2.5.\n*/\ninline\nbool operator<(const Plumed&a,const Plumed&b) __PLUMED_WRAPPER_CXX_NOEXCEPT {\n  return a.toVoid()<b.toVoid();\n}\n\n/**\n  \\related Plumed\n  Comparison operator. Available as of PLUMED 2.5.\n*/\ninline\nbool operator>=(const Plumed&a,const Plumed&b) __PLUMED_WRAPPER_CXX_NOEXCEPT {\n  return a.toVoid()>=b.toVoid();\n}\n\n/**\n  \\related Plumed\n  Comparison operator. Available as of PLUMED 2.5.\n*/\ninline\nbool operator>(const Plumed&a,const Plumed&b) __PLUMED_WRAPPER_CXX_NOEXCEPT {\n  return a.toVoid()>b.toVoid();\n}\n\n__PLUMED_WRAPPER_ANONYMOUS_END /*}*/\n\n}\n\n#endif /*}*/\n\n#endif /*}*/\n\n/* END OF DECLARATIONS */\n\n/*\n\n  1: emit implementation\n  0: do not emit implementation\n\n  Allows an implementation to be emitted together with the declarations.\n\n  Used to decide if definitions should be emitted. This macro could have a different\n  value when Plumed.h is reincluded. As a consequence, we map it to a local\n  macro (__PLUMED_WRAPPER_IMPLEMENTATION_) that is reset at the end of this file.\n*/\n\n#ifdef __PLUMED_WRAPPER_IMPLEMENTATION\n#define __PLUMED_WRAPPER_IMPLEMENTATION_ __PLUMED_WRAPPER_IMPLEMENTATION\n#else\n#define __PLUMED_WRAPPER_IMPLEMENTATION_ 0\n#endif\n\n/* BEGINNING OF DEFINITIONS */\n\n#if __PLUMED_WRAPPER_IMPLEMENTATION_  /*{*/\n#ifndef __PLUMED_wrapper_Plumed_implementation /*{*/\n#define __PLUMED_wrapper_Plumed_implementation\n\n/*\n  the following macros only control the implementation\n*/\n\n/*\n  1: enable the definition of plumed_symbol_table_reexport\n  0: does not enable the definition of plumed_symbol_table_reexport\n\n  This is only needed in the official plumed library to make\n  the symbol table available. This is a hack to reexport the function table\n  and is only needed when creating the library libplumed.so.\n*/\n\n#ifndef __PLUMED_WRAPPER_REEXPORT_SYMBOL_TABLE\n#define __PLUMED_WRAPPER_REEXPORT_SYMBOL_TABLE 0\n#endif\n\n/*\n  1: write on stderr changes in reference counters\n  0: do not write changes in reference counters\n\n  Used for debugging.\n\n  Only used in definitions.\n*/\n\n#ifndef __PLUMED_WRAPPER_DEBUG_REFCOUNT\n#define __PLUMED_WRAPPER_DEBUG_REFCOUNT 0\n#endif\n\n/*\n  1: emit plumed_kernel_register function (default)\n  0: do not emit plumed_kernel_register function\n\n  This function is only needed to avoid an extra warning when loading old (<=2.4) kernels.\n  We might change its default in the future.\n\n  Used only in definitions.\n*/\n\n#ifndef __PLUMED_WRAPPER_KERNEL_REGISTER\n#define __PLUMED_WRAPPER_KERNEL_REGISTER 1\n#endif\n\n/*\n  1: emit Fortran wrappers\n  0: do not emit Fortran wrappers (default)\n\n  Used only in definitions.\n*/\n\n#ifndef __PLUMED_WRAPPER_FORTRAN\n#define __PLUMED_WRAPPER_FORTRAN 0\n#endif\n\n/*\n  With internal interface, it does not make sence to emit kernel register or fortran interfaces\n*/\n\n#if ! __PLUMED_WRAPPER_EXTERN /*{*/\n#undef __PLUMED_WRAPPER_KERNEL_REGISTER\n#define __PLUMED_WRAPPER_KERNEL_REGISTER 0\n#undef __PLUMED_WRAPPER_FORTRAN\n#define __PLUMED_WRAPPER_FORTRAN 0\n#endif /*}*/\n\n#ifdef __PLUMED_HAS_DLOPEN\n#include <dlfcn.h> /* dlopen dlerror dlsym */\n#endif\n\n#if __PLUMED_WRAPPER_CXX_STD\n#include <cstdio>  /* fprintf */\n#include <cstring> /* memcpy strlen strncpy memcmp memmove strcmp memcpy */\n#include <cassert> /* assert */\n#include <cstdlib> /* getenv malloc free abort exit */\n#include <climits> /* CHAR_BIT */\n#else\n#include <stdio.h>\n#include <string.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <limits.h>\n#endif\n\n/**\n  Function pointer to plumed_create\n*/\n\ntypedef void*(*plumed_create_pointer)(void);\n/**\n  Function pointer to plumed_cmd\n*/\ntypedef void(*plumed_cmd_pointer)(void*,const char*,const void*);\n\n/**\n  Function pointer to plumed_finalize\n*/\ntypedef void(*plumed_finalize_pointer)(void*);\n\n/**\n   Holder for plumedmain function pointers.\n*/\ntypedef struct {\n  plumed_create_pointer create;\n  plumed_cmd_pointer cmd;\n  plumed_finalize_pointer finalize;\n} plumed_plumedmain_function_holder;\n\n/**\n  Holder for plumed symbol table.\n\n  The table contains pointers to function exported from plumed. Functions can be added increasing the version number.\n  Notice that the default way to extend functionalities is by adding cmd strings. This is a last resort, and all new\n  functions should be explicitly motivated. Here's the addition:\n\n  version=2, cmd_nothrow.\n\n  This function accepts an extra argument `plumed_nothrow_handler*handler`.\n  In case an exception is thrown withint plumed, it just calls `handler->handler(handler->ptr,code,message,opt)` and return.\n  An alternative would have been to install an error handler (with a call to cmd(\"setErrorHandler\")). However, the cost\n  of doing it everytime Plumed::cmd is called is too high. On the other hand, installing it only at object construction\n  is very risky since and object created in that way would not report any error if manipulated from the C interface.\n  So, it looks like this is the only possibility.\n\n*/\ntypedef struct {\n  /**\n    Version number.\n\n    Minimum value is 1.\n  */\n  int version;\n  /**\n    Pointers to standard plumed functions (create/cmd/finalize).\n\n    Always available.\n  */\n  plumed_plumedmain_function_holder functions;\n  /**\n    Pointer to a cmd function guaranteed not to throw exceptions.\n\n    Available with version>=2.\n  */\n  void (*cmd_nothrow)(void*plumed,const char*key,const void*val,plumed_nothrow_handler);\n} plumed_symbol_table_type;\n\n/* Utility to convert function pointers to pointers, just for the sake of printing them */\n#define __PLUMED_CONVERT_FPTR(ptr,fptr) { ptr=NULL; __PLUMED_WRAPPER_STD memcpy(&ptr,&fptr,(sizeof(fptr)>sizeof(ptr)?sizeof(ptr):sizeof(fptr))); }\n\n#define __PLUMED_GETENV __PLUMED_WRAPPER_STD getenv\n#define __PLUMED_FPRINTF __PLUMED_WRAPPER_STD fprintf\n#define __PLUMED_MALLOC __PLUMED_WRAPPER_STD malloc\n#define __PLUMED_FREE __PLUMED_WRAPPER_STD free\n\n/**\n  Historically (PLUMED<=2.4) register for plumedmain function pointers.\n  As of PLUMED>=2.5, this function does not do anything except for reporting the attempt to register\n  something. It always returns NULL. The function should be here anyway to allow an incomplete\n  libplumedKernel (<=2.4), expecting this function to be present, to be loaded correctly.\n*/\n#if __PLUMED_WRAPPER_KERNEL_REGISTER\n/* Since it is only called from outside, it must be hardcoded to be extern */\n__PLUMED_WRAPPER_EXTERN_C_BEGIN /*{*/\nextern plumed_plumedmain_function_holder* plumed_kernel_register(const plumed_plumedmain_function_holder*);\nplumed_plumedmain_function_holder* plumed_kernel_register(const plumed_plumedmain_function_holder* f) {\n  void* tmpptr;\n  if(f) {\n    if(__PLUMED_GETENV(\"PLUMED_LOAD_DEBUG\")) {\n      __PLUMED_FPRINTF(stderr,\"+++ Ignoring registration at %p (\",(void*)f);\n      __PLUMED_CONVERT_FPTR(tmpptr,f->create);\n      __PLUMED_FPRINTF(stderr,\"%p,\",tmpptr);\n      __PLUMED_CONVERT_FPTR(tmpptr,f->cmd);\n      __PLUMED_FPRINTF(stderr,\"%p,\",tmpptr);\n      __PLUMED_CONVERT_FPTR(tmpptr,f->finalize);\n      __PLUMED_FPRINTF(stderr,\"%p) +++\\n\",tmpptr);\n    }\n  }\n  return NULL;\n}\n__PLUMED_WRAPPER_EXTERN_C_END /*}*/\n#endif\n\n#if defined( __PLUMED_HAS_DLOPEN) /*{*/\n/**\nTry to dlopen a path with a given mode.\nIf the dlopen command fails, it tries to strip the `Kernel` part of the name.\n\nThis function is declared static (internal linkage) so that it is not visible from outside.\nIt is first declared then defined to make sure it is a regular C static function.\n*/\n\n__PLUMED_WRAPPER_INTERNALS_BEGIN\nvoid* plumed_attempt_dlopen(const char*path,int mode) {\n  char* pathcopy;\n  void* p;\n  char* pc;\n  size_t strlenpath;\n  FILE* fp;\n  pathcopy=NULL;\n  p=NULL;\n  pc=NULL;\n  strlenpath=0;\n  fp=__PLUMED_WRAPPER_STD fopen(path,\"r\");\n  if(!fp) {\n    __PLUMED_FPRINTF(stderr,\"+++ File %s does not exist or cannot be read\\n\",path);\n    return NULL;\n  }\n  __PLUMED_WRAPPER_STD fclose(fp);\n  dlerror();\n  p=dlopen(path,mode);\n  if(!p) {\n    /*\n      Something went wrong. We try to remove \"Kernel\" string from the PLUMED_KERNEL variable\n      and load directly the shared library. Notice that this particular path is only expected\n      to be necessary when using PLUMED<=2.4 and the symbols in the main executable are\n      not visible. All the other cases (either PLUMED>=2.5 or symbols in the main executable visible)\n      should work correctly without entering here.\n    */\n    __PLUMED_FPRINTF(stderr,\"+++ An error occurred. Message from dlopen(): %s +++\\n\",dlerror());\n    strlenpath=__PLUMED_WRAPPER_STD strlen(path);\n    pathcopy=(char*) __PLUMED_MALLOC(strlenpath+1);\n    __PLUMED_WRAPPER_STD strncpy(pathcopy,path,strlenpath+1);\n    pc=pathcopy+strlenpath-6;\n    while(pc>=pathcopy && __PLUMED_WRAPPER_STD memcmp(pc,\"Kernel\",6)) pc--;\n    if(pc>=pathcopy) {\n      __PLUMED_WRAPPER_STD memmove(pc, pc+6, __PLUMED_WRAPPER_STD strlen(pc)-5);\n      __PLUMED_FPRINTF(stderr,\"+++ This error is expected if you are trying to load a kernel <=2.4\\n\");\n      __PLUMED_FPRINTF(stderr,\"+++ Trying %s +++\\n\",pathcopy);\n      fp=__PLUMED_WRAPPER_STD fopen(path,\"r\");\n      if(!fp) {\n        __PLUMED_FPRINTF(stderr,\"+++ File %s does not exist or cannot be read\\n\",pathcopy);\n        __PLUMED_FREE(pathcopy);\n        return NULL;\n      }\n      __PLUMED_WRAPPER_STD fclose(fp);\n      dlerror();\n      p=dlopen(pathcopy,mode);\n      if(!p) __PLUMED_FPRINTF(stderr,\"+++ An error occurred. Message from dlopen(): %s +++\\n\",dlerror());\n    }\n    __PLUMED_FREE(pathcopy);\n  }\n  return p;\n}\n__PLUMED_WRAPPER_INTERNALS_END\n\n/**\n  Utility to search for a function.\n*/\n#define __PLUMED_SEARCH_FUNCTION(tmpptr,handle,func,name,debug) \\\n  if(!func) { \\\n    tmpptr=dlsym(handle,name); \\\n    if(tmpptr) { \\\n      *(void **)(&func)=tmpptr; \\\n      if(debug) __PLUMED_FPRINTF(stderr,\"+++ %s found at %p +++\\n\",name,tmpptr); \\\n    } else { \\\n      if(debug) __PLUMED_FPRINTF(stderr,\"+++ Function %s not found\\n\",name); \\\n    } \\\n  }\n\n/**\nSearch symbols in a dlopened library.\n\nThis function is declared static (internal linkage) so that it is not visible from outside.\n*/\n__PLUMED_WRAPPER_INTERNALS_BEGIN\nvoid plumed_search_symbols(void* handle, plumed_plumedmain_function_holder* f,plumed_symbol_table_type** table) {\n  plumed_plumedmain_function_holder functions;\n  plumed_symbol_table_type* table_ptr;\n  void* tmpptr;\n  char* debug;\n  functions.create=NULL;\n  functions.cmd=NULL;\n  functions.finalize=NULL;\n  table_ptr=NULL;\n  tmpptr=NULL;\n  /*\n    Notice that as of PLUMED 2.5 we ignore self registrations.\n    Pointers are searched in the form of a single pointer to a structure, which\n    is the standard way in PLUMED 2.5, as well as using alternative names used in\n    PLUMED 2.0 to 2.4 (e.g. plumedmain_create) and in some intermediate versions between\n    PLUMED 2.4 and 2.5 (e.g. plumed_plumedmain_create). The last chance is probably\n    unnecessary and might be removed at some point.\n  */\n  debug=__PLUMED_GETENV(\"PLUMED_LOAD_DEBUG\");\n  table_ptr=(plumed_symbol_table_type*) dlsym(handle,\"plumed_symbol_table\");\n  if(table_ptr) functions=table_ptr->functions;\n  if(debug) {\n    if(table_ptr) {\n      __PLUMED_FPRINTF(stderr,\"+++ plumed_symbol_table version %i found at %p +++\\n\",table_ptr->version,(void*)table_ptr);\n      __PLUMED_FPRINTF(stderr,\"+++ plumed_function_pointers found at %p (\",(void*)&table_ptr->functions);\n      __PLUMED_CONVERT_FPTR(tmpptr,functions.create);\n      __PLUMED_FPRINTF(stderr,\"%p,\",tmpptr);\n      __PLUMED_CONVERT_FPTR(tmpptr,functions.cmd);\n      __PLUMED_FPRINTF(stderr,\"%p,\",tmpptr);\n      __PLUMED_CONVERT_FPTR(tmpptr,functions.finalize);\n      __PLUMED_FPRINTF(stderr,\"%p) +++\\n\",tmpptr);\n    } else {\n      __PLUMED_FPRINTF(stderr,\"+++ plumed_symbol_table (available in PLUMED>=2.5) not found, perhaps kernel is older +++\\n\");\n    }\n  }\n  /* only searches if they were not found already */\n  __PLUMED_SEARCH_FUNCTION(tmpptr,handle,functions.create,\"plumedmain_create\",debug);\n  __PLUMED_SEARCH_FUNCTION(tmpptr,handle,functions.create,\"plumed_plumedmain_create\",debug);\n  __PLUMED_SEARCH_FUNCTION(tmpptr,handle,functions.cmd,\"plumedmain_cmd\",debug);\n  __PLUMED_SEARCH_FUNCTION(tmpptr,handle,functions.cmd,\"plumed_plumedmain_cmd\",debug);\n  __PLUMED_SEARCH_FUNCTION(tmpptr,handle,functions.finalize,\"plumedmain_finalize\",debug);\n  __PLUMED_SEARCH_FUNCTION(tmpptr,handle,functions.finalize,\"plumed_plumedmain_finalize\",debug);\n  if(functions.create && functions.cmd && functions.finalize) {\n    if(debug) __PLUMED_FPRINTF(stderr,\"+++ PLUMED was loaded correctly +++\\n\");\n    *f=functions;\n    if(table) *table=table_ptr;\n  } else {\n    if(!functions.create) __PLUMED_FPRINTF(stderr,\"+++ Pointer to (plumed_)plumedmain_create not found +++\\n\");\n    if(!functions.cmd) __PLUMED_FPRINTF(stderr,\"+++ Pointer to (plumed_)plumedmain_cmd not found +++\\n\");\n    if(!functions.finalize) __PLUMED_FPRINTF(stderr,\"+++ Pointer to (plumed_)plumedmain_finalize not found +++\\n\");\n    f->create=NULL;\n    f->cmd=NULL;\n    f->finalize=NULL;\n    if(table) *table=NULL;\n  }\n}\n__PLUMED_WRAPPER_INTERNALS_END\n\n#endif /*}*/\n\n\n#if __PLUMED_WRAPPER_REEXPORT_SYMBOL_TABLE\n\n/*\n  Here is the case where plumed_symbol_table is\n  visible as extern. We first declare it (together with plumed_symbol_table_init) ...\n*/\n\n__PLUMED_WRAPPER_EXTERN_C_BEGIN\nextern\nplumed_symbol_table_type plumed_symbol_table;\n__PLUMED_WRAPPER_EXTERN_C_END\n__PLUMED_WRAPPER_EXTERN_C_BEGIN\nextern\nvoid plumed_symbol_table_init(void);\n__PLUMED_WRAPPER_EXTERN_C_END\n\n/*\n  ... and then make available a function that returns the address\n  of the symbol table.\n*/\n__PLUMED_WRAPPER_C_BEGIN\nplumed_symbol_table_type* plumed_symbol_table_reexport() {\n  /* make sure the table is initialized */\n  plumed_symbol_table_init();\n  return &plumed_symbol_table;\n}\n__PLUMED_WRAPPER_C_END\n\n#else\n\n/*\n  Here is the case where plumed_symbol_table is not\n  visible as extern. We thus assume that plumed_symbol_table_reexport is\n  available.\n*/\n\n__PLUMED_WRAPPER_EXTERN_C_BEGIN\nextern plumed_symbol_table_type* plumed_symbol_table_reexport();\n__PLUMED_WRAPPER_EXTERN_C_END\n#endif\n\n\n/*\n  Returns the global pointers, either those available at link time or those\n  found in the library loaded at PLUMED_KERNEL env var.\n  If plumed_symbol_table_ptr is not NULL, it is used to return a pointer to the symbol table\n  (if available).\n  Notice that problems can be detected checking if the functions have a NULL ptr.\n  On the other hand, the symbol table pointer might be NULL just because the plumed version is <=2.4.\n  If handle is not NULL, it is used to return a dlopen handle that could be subsequently dlclosed.\n*/\n__PLUMED_WRAPPER_INTERNALS_BEGIN\nvoid plumed_retrieve_functions(plumed_plumedmain_function_holder* functions, plumed_symbol_table_type** plumed_symbol_table_ptr,void** handle) {\n#if ! __PLUMED_WRAPPER_LINK_RUNTIME\n  /*\n    Real interface, constructed using the symbol table obtained with plumed_symbol_table_reexport.\n    This makes the symbols hardcoded and independent of a mis-set PLUMED_KERNEL variable.\n  */\n  plumed_symbol_table_type* ptr=plumed_symbol_table_reexport();\n  if(plumed_symbol_table_ptr) *plumed_symbol_table_ptr=ptr;\n  if(handle) *handle=NULL;\n  if(functions) *functions=ptr->functions;\n#elif ! defined(__PLUMED_HAS_DLOPEN)\n  /*\n    When dlopen is not available, we hard code them to NULL\n  */\n  fprintf(stderr,\"+++ PLUMED has been compiled without dlopen and without a static kernel +++\\n\");\n  plumed_plumedmain_function_holder g= {NULL,NULL,NULL};\n  if(plumed_symbol_table_ptr) *plumed_symbol_table_ptr=NULL;\n  if(handle) *handle=NULL;\n  if(functions) *functions=g;\n#else\n  /*\n    On the other hand, for runtime binding, we use dlsym to find the relevant functions.\n  */\n  plumed_plumedmain_function_holder g;\n  /* search is done once and only once */\n  const char* path;\n  void* p;\n  char* debug;\n  int dlopenmode;\n  g.create=NULL;\n  g.cmd=NULL;\n  g.finalize=NULL;\n  path=__PLUMED_GETENV(\"PLUMED_KERNEL\");\n  p=NULL;\n  debug=__PLUMED_GETENV(\"PLUMED_LOAD_DEBUG\");\n  dlopenmode=0;\n  if(plumed_symbol_table_ptr) *plumed_symbol_table_ptr=NULL;\n  if(handle) *handle=NULL;\n#ifdef __PLUMED_DEFAULT_KERNEL\n  /*\n    This variable allows a default path for the kernel to be hardcoded.\n    Can be useful for hardcoding the predefined plumed location\n    still allowing the user to override this choice setting PLUMED_KERNEL.\n    The path should be chosen at compile time adding e.g.\n    -D__PLUMED_DEFAULT_KERNEL=/opt/local/lib/libplumed.dylib\n  */\n  /* This is required to add quotes */\n#define PLUMED_QUOTE_DIRECT(name) #name\n#define PLUMED_QUOTE(macro) PLUMED_QUOTE_DIRECT(macro)\n  if(! (path && (*path) )) path=PLUMED_QUOTE(__PLUMED_DEFAULT_KERNEL);\n#endif\n  if(path && (*path)) {\n    fprintf(stderr,\"+++ Loading the PLUMED kernel runtime +++\\n\");\n    fprintf(stderr,\"+++ PLUMED_KERNEL=\\\"%s\\\" +++\\n\",path);\n    if(debug) __PLUMED_FPRINTF(stderr,\"+++ Loading with mode RTLD_NOW\");\n    dlopenmode=RTLD_NOW;\n    if(__PLUMED_GETENV(\"PLUMED_LOAD_NAMESPACE\") && !__PLUMED_WRAPPER_STD strcmp(__PLUMED_GETENV(\"PLUMED_LOAD_NAMESPACE\"),\"LOCAL\")) {\n      dlopenmode=dlopenmode|RTLD_LOCAL;\n      if(debug) __PLUMED_FPRINTF(stderr,\"|RTLD_LOCAL\");\n    } else {\n      dlopenmode=dlopenmode|RTLD_GLOBAL;\n      if(debug) __PLUMED_FPRINTF(stderr,\"|RTLD_GLOBAL\");\n    }\n#ifdef RTLD_DEEPBIND\n    if(!__PLUMED_GETENV(\"PLUMED_LOAD_NODEEPBIND\")) {\n      dlopenmode=dlopenmode|RTLD_DEEPBIND;\n      if(debug) __PLUMED_FPRINTF(stderr,\"|RTLD_DEEPBIND\");\n    }\n#endif\n    if(debug) __PLUMED_FPRINTF(stderr,\" +++\\n\");\n    p=plumed_attempt_dlopen(path,dlopenmode);\n    if(p) plumed_search_symbols(p,&g,plumed_symbol_table_ptr);\n  }\n  if(handle) *handle=p;\n  if(functions) *functions=g;\n#endif\n}\n__PLUMED_WRAPPER_INTERNALS_END\n\n/**\n  Implementation.\n  Small object used to store pointers directly into the plumed object defined in Plumed.h.\n  This allows avoiding the extra function call to plumed_retrieve_functions at every cmd,\n  at the cost of an extra indirection.\n*/\ntypedef struct {\n  /* allows errors with pointers to be found when debugging */\n  char magic[6];\n  /* reference count */\n  int refcount;\n  /* handler to dlopened library. NULL if there was no library opened */\n  void* dlhandle;\n  /* non zero if, upon destruction, the library should be dlclosed */\n  int dlclose;\n  /* 1 if path to kernel was taken from PLUMED_KERNEL var, 0 otherwise */\n  int used_plumed_kernel;\n  /* function pointers */\n  plumed_plumedmain_function_holder functions;\n  /* pointer to the symbol table. NULL if kernel <=2.4 */\n  plumed_symbol_table_type* table;\n  /* pointer to plumed object */\n  void* p;\n} plumed_implementation;\n\n__PLUMED_WRAPPER_INTERNALS_BEGIN\nplumed_implementation* plumed_malloc_pimpl() {\n  plumed_implementation* pimpl;\n  /* allocate space for implementation object. this is free-ed in plumed_finalize(). */\n  pimpl=(plumed_implementation*) __PLUMED_MALLOC(sizeof(plumed_implementation));\n  if(!pimpl) {\n    __PLUMED_FPRINTF(stderr,\"+++ Allocation error +++\\n\");\n    __PLUMED_WRAPPER_STD abort();\n  }\n  __PLUMED_WRAPPER_STD memcpy(pimpl->magic,\"pLuMEd\",6);\n  pimpl->refcount=1;\n#if __PLUMED_WRAPPER_DEBUG_REFCOUNT\n  fprintf(stderr,\"refcount: new at %p\\n\",(void*)pimpl);\n#endif\n  pimpl->dlhandle=NULL;\n  pimpl->dlclose=0;\n  pimpl->used_plumed_kernel=0;\n  pimpl->functions.create=NULL;\n  pimpl->functions.cmd=NULL;\n  pimpl->functions.finalize=NULL;\n  pimpl->table=NULL;\n  pimpl->p=NULL;\n  return pimpl;\n}\n__PLUMED_WRAPPER_INTERNALS_END\n\n#ifndef NDEBUG\n\n__PLUMED_WRAPPER_INTERNALS_BEGIN\nint plumed_check_pimpl(plumed_implementation*pimpl) {\n  if(!pimpl) return 0;\n  if(__PLUMED_WRAPPER_STD memcmp(pimpl->magic,\"pLuMEd\",6)) return 0;\n  return 1;\n}\n__PLUMED_WRAPPER_INTERNALS_END\n#endif\n\n/* C wrappers: */\n\n__PLUMED_WRAPPER_C_BEGIN\nplumed plumed_create(void) {\n  /* returned object */\n  plumed p;\n  /* pointer to implementation */\n  plumed_implementation* pimpl;\n  /* allocate space for implementation object. this is free-ed in plumed_finalize(). */\n  pimpl=plumed_malloc_pimpl();\n  /* store pointers in pimpl */\n  plumed_retrieve_functions(&pimpl->functions,&pimpl->table,&pimpl->dlhandle);\n#if __PLUMED_WRAPPER_LINK_RUNTIME\n  /* note if PLUMED_KERNEL variable was used */\n  pimpl->used_plumed_kernel=1;\n#endif\n  /* note if handle should not be dlclosed */\n  pimpl->dlclose=1;\n  if(__PLUMED_GETENV(\"PLUMED_LOAD_DLCLOSE\") && !__PLUMED_WRAPPER_STD strcmp(__PLUMED_GETENV(\"PLUMED_LOAD_DLCLOSE\"),\"no\")) pimpl->dlclose=0;\n  /* in case of failure, return */\n  /* the resulting object should be plumed_finalized, though you cannot use plumed_cmd */\n  if(!pimpl->functions.create) {\n    /* store pimpl in returned object */\n    p.p=pimpl;\n    return p;\n  }\n  assert(pimpl->functions.cmd);\n  assert(pimpl->functions.finalize);\n  /* obtain object */\n  pimpl->p=(*(pimpl->functions.create))();\n  /* notice: we do not assert pimpl->p since in principle it might be nullptr */\n  /* user might identify this using plumed_valid() */\n  /* store pimpl in returned object */\n  p.p=pimpl;\n  return p;\n}\n__PLUMED_WRAPPER_C_END\n\n__PLUMED_WRAPPER_C_BEGIN\nplumed plumed_create_dlopen(const char*path) {\n  int dlopenmode;\n  /* plumed_create_dlopen always uses RTLD_LOCAL and, when possible, RTLD_DEEPBIND to allow multiple versions */\n#ifdef __PLUMED_HAS_DLOPEN\n  dlopenmode=RTLD_NOW|RTLD_LOCAL;\n#ifdef RTLD_DEEPBIND\n  dlopenmode=dlopenmode|RTLD_DEEPBIND;\n#endif\n#else\n  dlopenmode=0;\n#endif\n  return plumed_create_dlopen2(path,dlopenmode);\n}\n__PLUMED_WRAPPER_C_END\n\n__PLUMED_WRAPPER_C_BEGIN\nplumed plumed_create_dlopen2(const char*path,int mode) {\n  /* returned object */\n  plumed p;\n  /* pointer to implementation */\n  plumed_implementation* pimpl;\n  /* allocate space for implementation object. this is free-ed in plumed_finalize(). */\n  pimpl=plumed_malloc_pimpl();\n#ifdef __PLUMED_HAS_DLOPEN\n  if(path) pimpl->dlhandle=plumed_attempt_dlopen(path,mode);\n  /* mark this library to be dlclosed when the object is finalized */\n  pimpl->dlclose=1;\n  if(pimpl->dlhandle) plumed_search_symbols(pimpl->dlhandle,&pimpl->functions,&pimpl->table);\n#endif\n  if(!pimpl->functions.create) {\n    p.p=pimpl;\n    return p;\n  }\n  assert(pimpl->functions.cmd);\n  assert(pimpl->functions.finalize);\n  /* obtain object */\n  pimpl->p=(*(pimpl->functions.create))();\n  /* notice: we do not assert pimpl->p since in principle it might be nullptr */\n  /* user might identify this using plumed_valid() */\n  /* store pimpl in returned object */\n  p.p=pimpl;\n  return p;\n}\n__PLUMED_WRAPPER_C_END\n\n__PLUMED_WRAPPER_C_BEGIN\nplumed plumed_create_reference(plumed p) {\n  plumed_implementation* pimpl;\n  /* obtain pimpl */\n  pimpl=(plumed_implementation*) p.p;\n  assert(plumed_check_pimpl(pimpl));\n  /* increase reference count */\n  pimpl->refcount++;\n#if __PLUMED_WRAPPER_DEBUG_REFCOUNT\n  fprintf(stderr,\"refcount: increase at %p\\n\",(void*)pimpl);\n#endif\n  return p;\n}\n__PLUMED_WRAPPER_C_END\n\n__PLUMED_WRAPPER_C_BEGIN\nplumed plumed_create_reference_v(void*v) {\n  return plumed_create_reference(plumed_v2c(v));\n}\n__PLUMED_WRAPPER_C_END\n\n__PLUMED_WRAPPER_C_BEGIN\nplumed plumed_create_reference_f(const char*f) {\n  return plumed_create_reference(plumed_f2c(f));\n}\n__PLUMED_WRAPPER_C_END\n\n__PLUMED_WRAPPER_C_BEGIN\nplumed plumed_create_invalid() {\n  plumed p;\n  plumed_implementation* pimpl;\n  pimpl=plumed_malloc_pimpl();\n  p.p=pimpl;\n  return p;\n}\n__PLUMED_WRAPPER_C_END\n\n__PLUMED_WRAPPER_C_BEGIN\nvoid plumed_cmd(plumed p,const char*key,const void*val) {\n  plumed_implementation* pimpl;\n  /* obtain pimpl */\n  pimpl=(plumed_implementation*) p.p;\n  assert(plumed_check_pimpl(pimpl));\n  if(!pimpl->p) {\n    __PLUMED_FPRINTF(stderr,\"+++ ERROR: You are trying to use an invalid plumed object. +++\\n\");\n    if(pimpl->used_plumed_kernel) __PLUMED_FPRINTF(stderr,\"+++ Check your PLUMED_KERNEL environment variable. +++\\n\");\n    __PLUMED_WRAPPER_STD exit(1);\n  }\n  assert(pimpl->functions.create);\n  assert(pimpl->functions.cmd);\n  assert(pimpl->functions.finalize);\n  /* execute */\n  (*(pimpl->functions.cmd))(pimpl->p,key,val);\n}\n__PLUMED_WRAPPER_C_END\n\n__PLUMED_WRAPPER_C_BEGIN\nvoid plumed_cmd_nothrow(plumed p,const char*key,const void*val,plumed_nothrow_handler nothrow) {\n  plumed_implementation* pimpl;\n  /* obtain pimpl */\n  pimpl=(plumed_implementation*) p.p;\n  assert(plumed_check_pimpl(pimpl));\n  if(!pimpl->p) {\n    if(pimpl->used_plumed_kernel) {\n      nothrow.handler(nothrow.ptr,1,\"You are trying to use plumed, but it is not available.\\nCheck your PLUMED_KERNEL environment variable.\",NULL);\n    } else {\n      nothrow.handler(nothrow.ptr,1,\"You are trying to use plumed, but it is not available.\",NULL);\n    }\n    return;\n  }\n  assert(pimpl->functions.create);\n  assert(pimpl->functions.cmd);\n  assert(pimpl->functions.finalize);\n  /* execute */\n  if(pimpl->table && pimpl->table->version>1) (*(pimpl->table->cmd_nothrow))(pimpl->p,key,val,nothrow);\n  else (*(pimpl->functions.cmd))(pimpl->p,key,val);\n}\n__PLUMED_WRAPPER_C_END\n\n\n\n__PLUMED_WRAPPER_C_BEGIN\nvoid plumed_finalize(plumed p) {\n  plumed_implementation* pimpl;\n  /* obtain pimpl */\n  pimpl=(plumed_implementation*) p.p;\n  assert(plumed_check_pimpl(pimpl));\n  /* decrease reference count */\n  pimpl->refcount--;\n#if __PLUMED_WRAPPER_DEBUG_REFCOUNT\n  fprintf(stderr,\"refcount: decrease at %p\\n\",(void*)pimpl);\n#endif\n  if(pimpl->refcount>0) return;\n  /* to allow finalizing an invalid plumed object, we only call\n     finalize if the object is valid */\n  if(pimpl->p) {\n    assert(pimpl->functions.create);\n    assert(pimpl->functions.cmd);\n    assert(pimpl->functions.finalize);\n    /* finalize */\n    (*(pimpl->functions.finalize))(pimpl->p);\n  }\n#ifdef __PLUMED_HAS_DLOPEN\n  /* dlclose library */\n  if(pimpl->dlhandle && pimpl->dlclose) {\n    if(__PLUMED_GETENV(\"PLUMED_LOAD_DEBUG\")) fprintf(stderr,\"+++ Unloading library\\n\");\n    dlclose(pimpl->dlhandle);\n  }\n#endif\n#if __PLUMED_WRAPPER_DEBUG_REFCOUNT\n  fprintf(stderr,\"refcount: delete at %p\\n\",(void*)pimpl);\n#endif\n  /* free pimpl space */\n  __PLUMED_FREE(pimpl);\n}\n__PLUMED_WRAPPER_C_END\n\n__PLUMED_WRAPPER_C_BEGIN\nint plumed_valid(plumed p) {\n  plumed_implementation* pimpl;\n  /* obtain pimpl */\n  pimpl=(plumed_implementation*) p.p;\n  assert(plumed_check_pimpl(pimpl));\n  if(pimpl->p) return 1;\n  else return 0;\n}\n__PLUMED_WRAPPER_C_END\n\n__PLUMED_WRAPPER_C_BEGIN\nint plumed_use_count(plumed p) {\n  plumed_implementation* pimpl;\n  /* obtain pimpl */\n  pimpl=(plumed_implementation*) p.p;\n  assert(plumed_check_pimpl(pimpl));\n  return pimpl->refcount;\n}\n__PLUMED_WRAPPER_C_END\n\n__PLUMED_WRAPPER_C_BEGIN\nint plumed_installed(void) {\n  plumed p;\n  int result;\n  p=plumed_create();\n  result=plumed_valid(p);\n  plumed_finalize(p);\n  return result;\n}\n__PLUMED_WRAPPER_C_END\n\n#if __PLUMED_WRAPPER_GLOBAL /*{*/\n\n__PLUMED_WRAPPER_EXTERN_C_BEGIN\n\n/* we declare a Plumed_g_main object here, in such a way that it is always available */\n\nstatic plumed plumed_gmain= {NULL};\n\nplumed plumed_global(void) {\n  return plumed_gmain;\n}\n\nvoid plumed_gcreate(void) {\n  /* should be created once */\n  assert(plumed_gmain.p==NULL);\n  plumed_gmain=plumed_create();\n}\n\nvoid plumed_gcmd(const char*key,const void*val) {\n  plumed_cmd(plumed_gmain,key,val);\n}\n\nvoid plumed_gfinalize(void) {\n  plumed_finalize(plumed_gmain);\n  plumed_gmain.p=NULL;\n}\n\nint plumed_ginitialized(void) {\n  if(plumed_gmain.p) return 1;\n  else        return 0;\n}\n\nint plumed_gvalid() {\n  assert(plumed_gmain.p);\n  return plumed_valid(plumed_gmain);\n}\n\n__PLUMED_WRAPPER_EXTERN_C_END\n\n#endif /*}*/\n\n__PLUMED_WRAPPER_C_BEGIN\nvoid plumed_c2f(plumed p,char*c) {\n  unsigned i;\n  unsigned char* cc;\n  /*\n    Convert the address stored in p.p into a proper FORTRAN string\n    made of only ASCII characters. For this to work, the two following\n    assertions should be satisfied:\n  */\n  assert(CHAR_BIT<=12);\n  assert(sizeof(p.p)<=16);\n\n  assert(c);\n  cc=(unsigned char*)&p.p;\n  for(i=0; i<sizeof(p.p); i++) {\n    /*\n      characters will range between '0' (ASCII 48) and 'o' (ASCII 111=48+63)\n    */\n    c[2*i]=cc[i]/64+48;\n    c[2*i+1]=cc[i]%64+48;\n  }\n  for(; i<16; i++) {\n    c[2*i]=' ';\n    c[2*i+1]=' ';\n  }\n}\n__PLUMED_WRAPPER_C_END\n\n__PLUMED_WRAPPER_C_BEGIN\nplumed plumed_f2c(const char*c) {\n  plumed p;\n  unsigned i;\n  unsigned char* cc;\n\n  assert(CHAR_BIT<=12);\n  assert(sizeof(p.p)<=16);\n\n  assert(c);\n  cc=(unsigned char*)&p.p;\n  for(i=0; i<sizeof(p.p); i++) {\n    assert(c[2*i]>=48 && c[2*i]<48+64);\n    assert(c[2*i+1]>=48 && c[2*i+1]<48+64);\n    /*\n      perform the reversed transform\n    */\n    cc[i]=(c[2*i]-48)*64 + (c[2*i+1]-48);\n  }\n  for(; i<16; i++) {\n    assert(c[2*i]==' ');\n    assert(c[2*i+1]==' ');\n  }\n  return p;\n}\n__PLUMED_WRAPPER_C_END\n\n__PLUMED_WRAPPER_C_BEGIN\nvoid* plumed_c2v(plumed p) {\n  assert(plumed_check_pimpl((plumed_implementation*)p.p));\n  return p.p;\n}\n__PLUMED_WRAPPER_C_END\n\n__PLUMED_WRAPPER_C_BEGIN\nplumed plumed_v2c(void* v) {\n  assert(plumed_check_pimpl((plumed_implementation*)v));\n  plumed p;\n  p.p=v;\n  return p;\n}\n__PLUMED_WRAPPER_C_END\n\n#if __PLUMED_WRAPPER_FORTRAN /*{*/\n\n/*\n  Fortran wrappers\n  These are just like the global C wrappers. They are\n  just defined here and not declared since they\n  should not be used from c/c++ anyway.\n\n  We use a macro that does the following:\n  - declare a static function named NAME_static\n  - declare a number of functions named NAME_ etc, with all possible\n    fortran mangling schemes (zero, one, or two underscores, lower and upper case)\n  - define the NAME_static function.\n\n  The static function is used basically as an inline function in a C-compatible manner.\n*/\n\n#define __PLUMED_IMPLEMENT_FORTRAN(lower,upper,arg1,arg2) \\\n  static void lower ## _static arg1; \\\n  extern void lower      arg1 {lower ## _static arg2;} \\\n  extern void lower ##_  arg1 {lower ## _static arg2;} \\\n  extern void lower ##__ arg1 {lower ## _static arg2;} \\\n  extern void upper      arg1 {lower ## _static arg2;} \\\n  extern void upper ##_  arg1 {lower ## _static arg2;} \\\n  extern void upper ##__ arg1 {lower ## _static arg2;} \\\n  static void lower ## _static arg1\n\n/* FORTRAN wrappers would only make sense as extern \"C\" */\n\n__PLUMED_WRAPPER_EXTERN_C_BEGIN\n\n__PLUMED_IMPLEMENT_FORTRAN(plumed_f_create,PLUMED_F_CREATE,(char*c),(c)) {\n  plumed_c2f(plumed_create(),c);\n}\n\n__PLUMED_IMPLEMENT_FORTRAN(plumed_f_create_dlopen,PLUMED_F_CREATE_DLOPEN,(char*path,char*c),(path,c)) {\n  plumed_c2f(plumed_create_dlopen(path),c);\n}\n\n__PLUMED_IMPLEMENT_FORTRAN(plumed_f_create_reference,PLUMED_F_CREATE_REFERENCE,(char* r,char*c),(r,c)) {\n  plumed_c2f(plumed_create_reference_f(r),c);\n}\n\n__PLUMED_IMPLEMENT_FORTRAN(plumed_f_create_invalid,PLUMED_F_CREATE_INVALID,(char* c),(c)) {\n  plumed_c2f(plumed_create_invalid(),c);\n}\n\n__PLUMED_IMPLEMENT_FORTRAN(plumed_f_cmd,PLUMED_F_CMD,(char*c,char*key,void*val),(c,key,val)) {\n  plumed_cmd(plumed_f2c(c),key,val);\n}\n\n__PLUMED_IMPLEMENT_FORTRAN(plumed_f_finalize,PLUMED_F_FINALIZE,(char*c),(c)) {\n  plumed_finalize(plumed_f2c(c));\n}\n\n__PLUMED_IMPLEMENT_FORTRAN(plumed_f_installed,PLUMED_F_INSTALLED,(int*i),(i)) {\n  assert(i);\n  *i=plumed_installed();\n}\n\n/* New in PLUMED 2.5 */\n__PLUMED_IMPLEMENT_FORTRAN(plumed_f_valid,PLUMED_F_VALID,(char*c,int*i),(c,i)) {\n  assert(i);\n  *i=plumed_valid(plumed_f2c(c));\n}\n\n__PLUMED_IMPLEMENT_FORTRAN(plumed_f_use_count,PLUMED_F_USE_COUNT,(char*c,int*i),(c,i)) {\n  assert(i);\n  *i=plumed_use_count(plumed_f2c(c));\n}\n\n#if __PLUMED_WRAPPER_GLOBAL /*{*/\n\n__PLUMED_IMPLEMENT_FORTRAN(plumed_f_global,PLUMED_F_GLOBAL,(char*c),(c)) {\n  plumed_c2f(plumed_gmain,c);\n}\n\n__PLUMED_IMPLEMENT_FORTRAN(plumed_f_ginitialized,PLUMED_F_GINITIALIZED,(int*i),(i)) {\n  assert(i);\n  *i=plumed_ginitialized();\n}\n\n__PLUMED_IMPLEMENT_FORTRAN(plumed_f_gcreate,PLUMED_F_GCREATE,(void),()) {\n  plumed_gcreate();\n}\n\n__PLUMED_IMPLEMENT_FORTRAN(plumed_f_gcmd,PLUMED_F_GCMD,(char*key,void*val),(key,val)) {\n  plumed_gcmd(key,val);\n}\n\n__PLUMED_IMPLEMENT_FORTRAN(plumed_f_gfinalize,PLUMED_F_GFINALIZE,(void),()) {\n  plumed_gfinalize();\n}\n\n/* New in PLUMED 2.5 */\n__PLUMED_IMPLEMENT_FORTRAN(plumed_f_gvalid,PLUMED_F_GVALID,(int*i),(i)) {\n  assert(i);\n  *i=plumed_gvalid();\n}\n\n#endif /*}*/\n\n__PLUMED_WRAPPER_EXTERN_C_END\n\n#endif /*}*/\n\n#endif /*}*/\n\n#endif /*}*/\n\n/* END OF DEFINITIONS */\n\n/* reset variable to allow it to be redefined upon re-inclusion */\n\n#undef __PLUMED_WRAPPER_IMPLEMENTATION_\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/src/core/PlumedMainInitializer.cpp": "/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n   Copyright (c) 2011-2019 The plumed team\n   (see the PEOPLE file at the root of the distribution for a list of names)\n\n   See http://www.plumed.org for more information.\n\n   This file is part of plumed, version 2.\n\n   plumed is free software: you can redistribute it and/or modify\n   it under the terms of the GNU Lesser General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   plumed is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public License\n   along with plumed.  If not, see <http://www.gnu.org/licenses/>.\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */\n#include \"PlumedMainInitializer.h\"\n#include \"PlumedMain.h\"\n#include \"tools/Exception.h\"\n#include \"lepton/Exception.h\"\n#include <cstdlib>\n#include <cstring>\n#include <iostream>\n#if defined __PLUMED_HAS_DLOPEN\n#include <dlfcn.h>\n#endif\n#include <exception>\n#include <stdexcept>\n#include <ios>\n#include <new>\n#include <typeinfo>\n#ifdef __PLUMED_LIBCXX11\n#include <system_error>\n#include <future>\n#include <memory>\n#include <functional>\n#endif\n\n\nusing namespace std;\n\n// create should never throw\n// in case of a problem, it logs the error and return a null pointer\n// when loaded by an interface >=2.5, this will result in a non valid plumed object.\n// earlier interfaces will just give a segfault or a failed assertion.\nextern \"C\" void*plumed_plumedmain_create() {\n  try {\n    return new PLMD::PlumedMain;\n  } catch(const std::exception & e) {\n    std::cerr<<\"+++ an error happened while creating a plumed object\\n\";\n    std::cerr<<e.what()<<std::endl;\n    return nullptr;\n  } catch(...) {\n    std::cerr<<\"+++ an unknown error happened while creating a plumed object\"<<std::endl;\n    return nullptr;\n  }\n}\n\nextern \"C\" void plumed_plumedmain_cmd(void*plumed,const char*key,const void*val) {\n  plumed_massert(plumed,\"trying to use a plumed object which is not initialized\");\n  auto p=static_cast<PLMD::PlumedMain*>(plumed);\n  p->cmd(key,val);\n}\n\nextern \"C\" void plumed_plumedmain_cmd_nothrow(void*plumed,const char*key,const void*val,plumed_nothrow_handler nothrow) {\n// At library boundaries we translate exceptions to error codes.\n// This allows an exception to be catched also if the MD code\n// was linked against a different C++ library\n  try {\n    plumed_massert(plumed,\"trying to use a plumed object which is not initialized\");\n    static_cast<PLMD::PlumedMain*>(plumed)->cmd(key,val);;\n  } catch(const PLMD::ExceptionError & e) {\n    nothrow.handler(nothrow.ptr,20200,e.what(),nullptr);\n  } catch(const PLMD::ExceptionDebug & e) {\n    nothrow.handler(nothrow.ptr,20100,e.what(),nullptr);\n  } catch(const PLMD::Exception & e) {\n    nothrow.handler(nothrow.ptr,20000,e.what(),nullptr);\n  } catch(const PLMD::lepton::Exception & e) {\n    nothrow.handler(nothrow.ptr,19900,e.what(),nullptr);\n    // 11000 to 12000 are \"bad exceptions\". message will be copied without new allocations\n  } catch(const bad_exception & e) {\n    nothrow.handler(nothrow.ptr,11500,e.what(),nullptr);\n#ifdef __PLUMED_LIBCXX11\n  } catch(const bad_array_new_length & e) {\n    nothrow.handler(nothrow.ptr,11410,e.what(),nullptr);\n#endif\n  } catch(const bad_alloc & e) {\n    nothrow.handler(nothrow.ptr,11400,e.what(),nullptr);\n#ifdef __PLUMED_LIBCXX11\n  } catch(const bad_function_call & e) {\n    nothrow.handler(nothrow.ptr,11300,e.what(),nullptr);\n  } catch(const bad_weak_ptr & e) {\n    nothrow.handler(nothrow.ptr,11200,e.what(),nullptr);\n#endif\n  } catch(const bad_cast & e) {\n    nothrow.handler(nothrow.ptr,11100,e.what(),nullptr);\n  } catch(const bad_typeid & e) {\n    nothrow.handler(nothrow.ptr,11000,e.what(),nullptr);\n    // not implemented yet: std::regex_error\n    // we do not allow regex yet due to portability problems with gcc 4.8\n    // as soon as we transition to using <regex> it should be straightforward to add\n  } catch(const std::ios_base::failure & e) {\n#ifdef __PLUMED_LIBCXX11\n    int value=e.code().value();\n    const void* opt[3]= {\"c\",&value,nullptr}; // \"c\" passes the error code. nullptr terminates the optional part.\n    if(e.code().category()==generic_category()) nothrow.handler(nothrow.ptr,10230,e.what(),opt);\n    else if(e.code().category()==system_category()) nothrow.handler(nothrow.ptr,10231,e.what(),opt);\n    else if(e.code().category()==iostream_category()) nothrow.handler(nothrow.ptr,10232,e.what(),opt);\n    else if(e.code().category()==future_category()) nothrow.handler(nothrow.ptr,10233,e.what(),opt);\n    else\n#endif\n      // 10239 represents std::ios_base::failure with default constructur\n      nothrow.handler(nothrow.ptr,10239,e.what(),nullptr);\n#ifdef __PLUMED_LIBCXX11\n  } catch(const std::system_error & e) {\n    int value=e.code().value();\n    const void* opt[3]= {\"c\",&value,nullptr}; // \"c\" passes the error code. nullptr terminates the optional part.\n    if(e.code().category()==generic_category()) nothrow.handler(nothrow.ptr,10220,e.what(),opt);\n    else if(e.code().category()==system_category()) nothrow.handler(nothrow.ptr,10221,e.what(),opt);\n    else if(e.code().category()==iostream_category()) nothrow.handler(nothrow.ptr,10222,e.what(),opt);\n    else if(e.code().category()==future_category()) nothrow.handler(nothrow.ptr,10223,e.what(),opt);\n    // fallback to generic runtime_error\n    else nothrow.handler(nothrow.ptr,10200,e.what(),nullptr);\n#endif\n  } catch(const std::underflow_error &e) {\n    nothrow.handler(nothrow.ptr,10215,e.what(),nullptr);\n  } catch(const std::overflow_error &e) {\n    nothrow.handler(nothrow.ptr,10210,e.what(),nullptr);\n  } catch(const std::range_error &e) {\n    nothrow.handler(nothrow.ptr,10205,e.what(),nullptr);\n  } catch(const std::runtime_error & e) {\n    nothrow.handler(nothrow.ptr,10200,e.what(),nullptr);\n    // not implemented yet: std::future_error\n    // not clear how useful it would be.\n  } catch(const std::out_of_range & e) {\n    nothrow.handler(nothrow.ptr,10120,e.what(),nullptr);\n  } catch(const std::length_error & e) {\n    nothrow.handler(nothrow.ptr,10115,e.what(),nullptr);\n  } catch(const std::domain_error & e) {\n    nothrow.handler(nothrow.ptr,10110,e.what(),nullptr);\n  } catch(const std::invalid_argument & e) {\n    nothrow.handler(nothrow.ptr,10105,e.what(),nullptr);\n  } catch(const std::logic_error & e) {\n    nothrow.handler(nothrow.ptr,10100,e.what(),nullptr);\n    // generic exception. message will be copied without new allocations\n    // reports all non caught exceptions that are derived from std::exception\n    // for instance, boost exceptions would end up here\n  } catch(const std::exception & e) {\n    nothrow.handler(nothrow.ptr,10000,e.what(),nullptr);\n  } catch(...) {\n    // if exception cannot be translated, we throw a bad_exception\n    nothrow.handler(nothrow.ptr,11500,\"plumed could not translate exception\",nullptr);\n    throw;\n  }\n}\n\nextern \"C\" void plumed_plumedmain_finalize(void*plumed) {\n  plumed_massert(plumed,\"trying to deallocate a plumed object which is not initialized\");\n// I think it is not possible to replace this delete with a smart pointer\n// since the ownership of this pointer is in a C structure. GB\n  delete static_cast<PLMD::PlumedMain*>(plumed);\n}\n\n// values here should be consistent with those in plumed_symbol_table_init !!!!\nplumed_symbol_table_type plumed_symbol_table= {\n  2,\n  {plumed_plumedmain_create,plumed_plumedmain_cmd,plumed_plumedmain_finalize},\n  plumed_plumedmain_cmd_nothrow\n};\n\n// values here should be consistent with those above !!!!\nextern \"C\" void plumed_symbol_table_init() {\n  plumed_symbol_table.version=2;\n  plumed_symbol_table.functions.create=plumed_plumedmain_create;\n  plumed_symbol_table.functions.cmd=plumed_plumedmain_cmd;\n  plumed_symbol_table.functions.finalize=plumed_plumedmain_finalize;\n  plumed_symbol_table.cmd_nothrow=plumed_plumedmain_cmd_nothrow;\n}\n\nnamespace PLMD {\n\n#define plumed_convert_fptr(ptr,fptr) { ptr=NULL; std::memcpy(&ptr,&fptr,(sizeof(fptr)>sizeof(ptr)?sizeof(ptr):sizeof(fptr))); }\n\n/// Static object which registers Plumed.\n/// This is a static object which, during its construction at startup,\n/// registers the pointers to plumed_plumedmain_create, plumed_plumedmain_cmd and plumed_plumedmain_finalize\n/// to the plumed_kernel_register function.\n/// Registration is only required with plumed loader <=2.4, but we do it anyway in order to maintain\n/// backward compatibility. Notice that as of plumed 2.5 the plumed_kernel_register is found\n/// using dlsym, in order to allow the libplumedKernel library to be loadable also when\n/// the plumed_kernel_register symbol is not available.\nstatic class PlumedMainInitializer {\n  const bool debug;\npublic:\n  PlumedMainInitializer():\n    debug(std::getenv(\"PLUMED_LOAD_DEBUG\"))\n  {\n// make sure static plumed_function_pointers is initialized here\n    plumed_symbol_table_init();\n    if(debug) fprintf(stderr,\"+++ Initializing PLUMED with plumed_symbol_table version %i at %p\\n\",plumed_symbol_table.version,(void*)&plumed_symbol_table);\n#if defined(__PLUMED_HAS_DLOPEN)\n    if(std::getenv(\"PLUMED_LOAD_SKIP_REGISTRATION\")) {\n      if(debug) fprintf(stderr,\"+++ Skipping registration +++\\n\");\n      return;\n    }\n    typedef plumed_plumedmain_function_holder* (*plumed_kernel_register_type)(const plumed_plumedmain_function_holder*);\n    plumed_kernel_register_type plumed_kernel_register=nullptr;\n    void* handle=nullptr;\n#if defined(__PLUMED_HAS_RTLD_DEFAULT)\n    if(debug) fprintf(stderr,\"+++ Registering functions. Looking in RTLD_DEFAULT +++\\n\");\n    void* dls=dlsym(RTLD_DEFAULT,\"plumed_kernel_register\");\n#else\n    handle=dlopen(NULL,RTLD_LOCAL);\n    if(debug) fprintf(stderr,\"+++ Registering functions. dlopen handle at %p +++\\n\",handle);\n    void* dls=dlsym(handle,\"plumed_kernel_register\");\n#endif\n    *(void **)(&plumed_kernel_register)=dls;\n    if(debug) {\n      if(plumed_kernel_register) {\n        fprintf(stderr,\"+++ plumed_kernel_register found at %p +++\\n\",dls);\n      }\n      else fprintf(stderr,\"+++ plumed_kernel_register not found +++\\n\");\n    }\n    void*createp;\n    void*cmdp;\n    void*finalizep;\n    plumed_convert_fptr(createp,plumed_symbol_table.functions.create);\n    plumed_convert_fptr(cmdp,plumed_symbol_table.functions.cmd);\n    plumed_convert_fptr(finalizep,plumed_symbol_table.functions.finalize);\n    if(plumed_kernel_register && debug) fprintf(stderr,\"+++ Registering functions at %p (%p,%p,%p) +++\\n\",\n          (void*)&plumed_symbol_table.functions,createp,cmdp,finalizep);\n    if(plumed_kernel_register) (*plumed_kernel_register)(&plumed_symbol_table.functions);\n// Notice that handle could be null in the following cases:\n// - if we use RTLD_DEFAULT\n// - on Linux if we don't use RTLD_DEFAULT, since dlopen(NULL,RTLD_LOCAL) returns a null pointer.\n    if(handle) dlclose(handle);\n#endif\n// I think this is a bug in cppcheck 1.87\n// Notice that if handle is NULL there's no point in dlclosing it.\n// cppcheck-suppress resourceLeak\n  }\n  ~PlumedMainInitializer() {\n    if(debug) fprintf(stderr,\"+++ Finalizing PLUMED with plumed_symbol_table at %p\\n\",(void*)&plumed_symbol_table);\n  }\n} PlumedMainInitializerRegisterMe;\n\n}\n\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/src/tools/PlumedHandle.h": "/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n   Copyright (c) 2018,2019 The plumed team\n   (see the PEOPLE file at the root of the distribution for a list of names)\n\n   See http://www.plumed.org for more information.\n\n   This file is part of plumed, version 2.\n\n   plumed is free software: you can redistribute it and/or modify\n   it under the terms of the GNU Lesser General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   plumed is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public License\n   along with plumed.  If not, see <http://www.gnu.org/licenses/>.\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */\n#ifndef __PLUMED_tools_PlumedHandle_h\n#define __PLUMED_tools_PlumedHandle_h\n#include \"core/PlumedMainInitializer.h\"\n#include <memory>\n\nnamespace PLMD\n{\n\nclass PlumedMain;\n\n/**\nTiny local class to load a PLUMED kernel.\n\nMaps command to either a loaded PLUMED kernel or to the present one.\nIt is a simplified version of the interface located at wrapper/Plumed.h.\nDifferences are:\n- It does not use the `PLUMED_KERNEL` env var. Indeed, it would not make sense to use it,\n  since this class is meant to load different kernels.\n- It does not implement interoperability with C/FORTRAN interfaces.\n- It does not implement global versions (e.g. PLMD::Plumed::gcmd).\n- It does not implement PLMD::Plumed::ginitialized. If it cannot be loaded, it crashes in its constructor.\n  This will make sure that once constructed the object is usable.\n\nThe mechanism for loading the kernel is anyway very similar to the one in wrapper/Plumed.c.\nIn particular, it can load both kernels from PLUMED <=2.4 and >=2.5, and it\ntries to load the `libplumed.so` object if the `libplumedKernel.so` object does not load correctly.\nIt can also be created without passing any kernel path. In that case it refers to the current one\n(the one to which this class belongs).\n\nThe following syntax creates a handle referring to the current kernel\n\\verbatim\nPlumedHandle p;\n// Alternatively:\n// auto p=PlumedHandle();\np.cmd(\"init\");\n\\endverbatim\n\nThe following syntax instead creates a handle referring to a loaded kernel\n\\verbatim\nPlumedHandle p(PlumedHandle::dlopen(\"/path/to/libplumedkernel.so\");\n// Alternatively:\n// auto p=PlumedHandle::dlopen(\"/path/to/libplumedkernel.so\");\np.cmd(\"init\");\n\\endverbatim\n\nNotice that if there are problems loading the kernel an exception is thrown.\nThus, once constructed the object is guaranteed to be functional.\n\n*/\nclass PlumedHandle {\n/// Automatically dlclosing auxiliary class.\n/// Just used to make sure that handle is dlclosed correctly.\n  class DlHandle {\n    void *handle=nullptr;\n  public:\n/// Default construct as nullptr\n    DlHandle() {}\n/// Construct from a void*\n    explicit DlHandle(void*h): handle(h) {}\n/// Destructor will call dlclose if necessary\n    ~DlHandle();\n/// Covertible to void* so that it can be used directly\n    operator void*() const {\n      return handle;\n    }\n  };\n/// Pointer to PlumedMain.\n/// Used when using the current kernel in order to avoid unneeded indirections.\n  std::unique_ptr<PlumedMain> local;\n/// Pointer to dlsym handle used to open the kernel.\n/// Null when using current kernel.\n  DlHandle handle;\n/// Pointer to symbol table.\n/// Used for kernels>=2.5. We store it here since it is needed\n/// in constructor to initialize create_/cmd_/finalize_.\n/// Later on we might use the additional version information that it carries.\n  plumed_symbol_table_type* const symbol_=nullptr;\n/// Pointer to create function.\n/// Used when kernel is dlopened.\n  const plumed_create_pointer create_=nullptr;\n/// Pointer to cmd function.\n/// Used when kernel is dlopened.\n  const plumed_cmd_pointer cmd_=nullptr;\n/// Pointer to finalize function.\n/// Used when kernel is dlopened.\n  const plumed_finalize_pointer finalize_=nullptr;\n/// Pointer to the plumed object.\n/// Used when kernel is dlopened.\n  void* const p=nullptr;\n/// Constructor using the path to a kernel.\n/// I keep it private to avoid confusion wrt the\n/// similar constructor of PLMD::Plumed that accepts a string (conversion from FORTRAN).\n  explicit PlumedHandle(const char* path);\npublic:\n/// Default constructor.\n/// Maps following commands to the current kernel.\n  PlumedHandle();\n/// Construct a PlumedHandle given the path to a kernel.\n/// It just uses the private constructor PlumedHandle(const char* path).\n  static PlumedHandle dlopen(const char* path);\n/// Destructor.\n/// In case a kernel was dlopened, it dlcloses it.\n/// I make it virtual for future extensibility, though this is not necessary now.\n  virtual ~PlumedHandle();\n/// Move constructor.\n  PlumedHandle(PlumedHandle &&) = default;\n/// Execute cmd.\n  void cmd(const char*key,const void*ptr=nullptr);\n};\n\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/src/tools/PlumedHandle.cpp": "/* +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\n   Copyright (c) 2018,2019 The plumed team\n   (see the PEOPLE file at the root of the distribution for a list of names)\n\n   See http://www.plumed.org for more information.\n\n   This file is part of plumed, version 2.\n\n   plumed is free software: you can redistribute it and/or modify\n   it under the terms of the GNU Lesser General Public License as published by\n   the Free Software Foundation, either version 3 of the License, or\n   (at your option) any later version.\n\n   plumed is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n   GNU Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public License\n   along with plumed.  If not, see <http://www.gnu.org/licenses/>.\n+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ */\n#include \"PlumedHandle.h\"\n#include \"core/PlumedMain.h\"\n#include \"Tools.h\"\n#include <cstring>\n#ifdef __PLUMED_HAS_DLOPEN\n#include <dlfcn.h>\n#endif\n\nnamespace PLMD\n{\n\nPlumedHandle::DlHandle::~DlHandle() {\n#ifdef __PLUMED_HAS_DLOPEN\n  if(handle) dlclose(handle);\n#endif\n}\n\nPlumedHandle::PlumedHandle():\n  local(new PlumedMain)\n{\n}\n\nPlumedHandle::PlumedHandle(const char* kernel)\n#ifdef __PLUMED_HAS_DLOPEN\n  :\n  handle([&]() {\n  dlerror();\n  int mode = RTLD_LOCAL | RTLD_NOW;\n#ifdef RTLD_DEEPBIND\n// Needed on Linux to avoid namespace clashes\n  mode |= RTLD_DEEPBIND;\n#endif\n  void* h=::dlopen(kernel,mode);\n// try to remove the \"Kernel\" string.\n// needed to load old versions\n  if(!h) {\n    std::string k(kernel);\n    auto i=k.rfind(\"Kernel\");\n    if(i!=std::string::npos) {\n      k=k.substr(0,i) + k.substr(i+6);\n      h=::dlopen(k.c_str(),mode);\n    }\n  }\n  plumed_assert(h) << \"there was a problem loading kernel \"<<kernel <<\"\\n\"<<dlerror();\n  return DlHandle(h);\n// once the DlHandle has been constructed we know that later exceptions will also call dlclose().\n}()),\nsymbol_((plumed_symbol_table_type*) dlsym(handle,\"plumed_symbol_table\")),\ncreate_([&]() {\n  if(symbol_) {\n    plumed_assert(symbol_->functions.create);\n    return symbol_->functions.create;\n  }\n  void* c=nullptr;\n  if(!c) c=dlsym(handle,\"plumedmain_create\");\n  if(!c) c=dlsym(handle,\"plumed_plumedmain_create\");\n  plumed_assert(c) << \"in kernel \"<<kernel<<\" I could not find (plumed_)plumedmain_create\";\n  plumed_create_pointer cc;\n  *(void **)(&cc)=c;\n  return cc;\n}()),\ncmd_([&]() {\n  if(symbol_) {\n    plumed_assert(symbol_->functions.cmd);\n    return symbol_->functions.cmd;\n  }\n  void* c=nullptr;\n  if(!c) c=dlsym(handle,\"plumedmain_cmd\");\n  if(!c) c=dlsym(handle,\"plumed_plumedmain_cmd\");\n  plumed_assert(c) << \"in kernel \"<<kernel<<\" I could not find (plumed_)plumedmain_cmd\";\n  plumed_cmd_pointer cc;\n  *(void **)(&cc)=c;\n  return cc;\n}()),\nfinalize_([&]() {\n  if(symbol_) {\n    plumed_assert(symbol_->functions.finalize);\n    return symbol_->functions.finalize;\n  }\n  void* f=nullptr;\n  if(!f) f=dlsym(handle,\"plumedmain_finalize\");\n  if(!f) f=dlsym(handle,\"plumed_plumedmain_finalize\");\n  plumed_assert(f) << \"in kernel \"<<kernel<<\" I could not find (plumed_)plumedmain_finalize\";\n  plumed_finalize_pointer ff;\n  *(void **)(&ff)=f;\n  return ff;\n}()),\np(create_())\n// No exceptions thrown past this point.\n// Thus, destructor PlumedHandle::~PlumedHandle() will always be called and p will always be finalized.\n{}\n#else\n{\n  plumed_error() << \"You are trying to dynamically load a kernel, but PLUMED was compiled without dlopen\";\n}\n#endif\n\nPlumedHandle::~PlumedHandle() {\n#ifdef __PLUMED_HAS_DLOPEN\n  if(p) finalize_(p);\n#endif\n}\n\nPlumedHandle PlumedHandle::dlopen(const char* path) {\n  return PlumedHandle(path);\n}\n\nvoid PlumedHandle::cmd(const char*key,const void*ptr) {\n  if(local) local->cmd(key,ptr);\n  else if(p && cmd_) cmd_(p,key,ptr);\n  else plumed_error() << \"should never arrive here (either one or the other should work)\";\n}\n\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/CHANGES/v2.5.md": "@page CHANGES-2-5 Version 2.5\n\n## Version 2.5 (Dec 19, 2018)\n\nThis page contains changes that will end up in 2.5\n\nChanges from version 2.4 which are relevant for users:\n- Changes leading to incompatible behavior:\n  - \\ref RMSD, \\ref MULTI-RMSD, \\ref PATHMSD, \\ref PROPERTYMAP, \\ref PCAVARS, \\ref PCARMSD, \\ref FIT_TO_TEMPLATE,\n    \\ref DIPOLE, \\ref ALPHARMSD, \\ref ANTIBETARMSD, and \\ref PARABETARMSD now automatically make molecules whole.\n    In case you do not want them to do it, use NOPBC flag,\n  - There is some subtle change in the installation layout (see below). There should be no visible effect, however it is now compulsory\n    to set correctly the `LD_LIBRARY_PATH` variable for the linux executable to work correctly. The procedure has been tested well on OSX and Linux,\n    but could give problems on other platform. Please report possible problems on the mailing list.\n  - \\ref driver now stops correctly when using \\ref COMMITTOR. If you want to continue the analysis, use the `NOSTOP` flag in \\ref COMMITTOR.\n  - \\ref METAD the calculation of the reweighting factor is now activated by CALC_RCT instead of REWEIGHTING_NGRID and REWEIGHTING_NHILLS, the frequency of update can be set \n    by RCT_USTRIDE, the default value is 1 and should be OK for most of the cases\n  - Fixed sign in Cartesian components of \\ref PUCKERING with 6 membered rings (thanks to Carol Simoes and Javi Iglesias).\n\n- New actions:\n  - \\ref COLLECT_FRAMES\n  - \\ref EUCLIDEAN_DISSIMILARITIES\n  - \\ref HBPAMM_MATRIX\n  - \\ref HBPAMM_SH\n  - \\ref LANDMARK_SELECT_FPS\n  - \\ref LANDMARK_SELECT_RANDOM\n  - \\ref LANDMARK_SELECT_STAGED\n  - \\ref LANDMARK_SELECT_STRIDE\n  - \\ref OUTPUT_ANALYSIS_DATA_TO_COLVAR\n  - \\ref OUTPUT_ANALYSIS_DATA_TO_PDB\n  - \\ref OUTPUT_PCA_PROJECTION\n  - \\ref PAMM\n  - \\ref PLUMED\n  - \\ref PRINT_DISSIMILARITY_MATRIX\n  - \\ref PROJECT_ALL_ANALYSIS_DATA\n  - \\ref READ_DISSIMILARITY_MATRIX\n  - \\ref RESELECT_LANDMARKS\n  - \\ref REWEIGHT_WHAM\n  - \\ref SKETCHMAP_CONJGRAD\n  - \\ref SKETCHMAP_POINTWISE\n  - \\ref SKETCHMAP_READ\n  - \\ref SKETCHMAP_SMACOF\n  - \\ref SKETCH_MAP\n  - \\ref SMACOF_MDS\n  - \\ref WHAM_HISTOGRAM\n  - \\ref WHAM_WEIGHTS\n\n- New command line tools:\n  - \\ref completion (used to generate command line completion scripts).\n  - \\ref pdbrenumber (see \\issue{371}).\n\n- New modules:\n  - A new PIV module has been included, contributed by Silvio Pipolo and Fabio Pietrucci.\n    This module implements the following collective variable:\n    - \\ref PIV\n  - A new LOGMFD module has been included, contributed by Tetsuya Morishita.\n    This module implements the following bias:\n    - \\ref LOGMFD\n\n- Changes in the ISDB module\n  - \\ref CS2BACKBONE is now mpi parallelized in particular with DOSCORE and CAMSHIFT\n  - \\ref SAXS has an additional implementation based on Bessel functions that can be faster for large systems (new keyword BESSEL)\n  - \\ref SAXS keyword SCEXP has been renamed into SCALEINT\n  - \\ref SAXS includes the MARTINI bead structure factors for Proteins and Nucleic Acids\n  - \\ref SAXS includes a GPU implementation based on ArrayFire (need to be linked at compile time) that can be activated with GPU\n  - \\ref METAINFERENCE and all related methods has a new keyword REGRES_ZERO to scale data using a linear scale fit\n  - \\ref CALIBER new bias to perform Maximum Caliber replica-averaged restrained simulations \n\n- Changes in the eABF/DRR module (contributed by Haochuan Chen and Haohao Fu):\n  - \\ref DRR now supports the extended generalized ABF(egABF) method.\n  - \\ref DRR accepts different GRID options for CVs and extended variables.\n  - The MAXFACTOR option is added in \\ref DRR to control the factor of biasing force.\n  - \\ref drr_tool can calculate the divergence of gradients now. (Maybe useful for future pABF)\n  - Fixed conflicts of output files in multiple replicas.\n\n- Changes in the EDS module:\n  - \\ref EDS implements Levenberg-Marquardt optimization in addition to previous gradient descent. \n  - \\ref EDS no longer automatically increases prefactor for bias parameter updates. This results in more stable optimization for the cases tested.\n  - \\ref EDS now has a larger default RANGE parameter to go with these other changes.\n\n- Other changes:\n  - \\ref METAD there is a new FLYING_GAUSSIAN keyword to activate the flying gaussian methods by Spiwok (contributed by Spiwok and Hozzova)\n  - \\ref EXTERNAL can now SCALE the input grid. This allows for more flexibility without modifying the grid file.\n  - \\ref ALPHABETA can now combine dihedral angles with different coefficients\n  - \\ref INCLUDE can now be used also before setup actions.\n  - \\ref CENTER can now be computed using trigonometric functions (PHASES) to simplify its calculation with periodic boundary conditions.\n  - Libmatheval is not used anymore. \\ref MATHEVAL (and \\ref CUSTOM) are still available\n    but employ an internal implementation of the lepton library.\n    Functions available in libmatheval and absent in the original lepton library have been added so as to have backward compatibility.\n    `atan2(y,x)` function has also been added.\n    Notice that MATHEVAL (and CUSTOM) \\ref switchingfunction \"switching functions\"\n    using the lepton library have been further optimized with respect to PLUMED 2.4.\n    Finally, notice that it is possible to use asmjit to optimize performance (see \\ref Lepton).\n  - Implemented bash autocompletion, see \\ref BashAutocompletion.\n  - \\ref MOLINFO now allows selecting atoms from chains with a numeric ID (see \\issue{320}).\n  - Removed the patch for GMX 5.1.4\n  - LAMMPS patch has been finally removed. Notice that LAMMPS has native support for PLUMED now.\n  - AMBER patch has been finally removed. Notice that AMBER (sander module) has native support for PLUMED starting from version 15.\n  - \\ref RMSD calculation has been optimized. This should positively affect the performances of CVs where\n     many RMSD values are computed on small groups of atoms, such as secondary structure variables.\n  - In \\ref METAD, when using a bias factor equal to one (no bias) the `rct` component is set to zero rather than to one.\n  - New shortcuts are available for selecting atoms: `@allatoms` and `@mdatoms` (see \\ref atomSpecs).\n  - When using \\ref MOLINFO, also the following shortcuts are available for selecting atoms: `@nucleic`, `@protein`, `@water`, `@ions`, `@hydrogens`, `@nonhydrogens`.\n  - When using \\ref MOLINFO, individual atoms can be chosen also from water molecules (e.g. `@OW-100`).\n  - Additional switching function COSINUS contributed by Michael King\n  - added API to set the number of used openMP threads from the linked code, updated gromacs 2018.3 patch to use it\n\nChanges from version 2.4 which are relevant for developers:\n- Code has been cleanup up replacing a number of pointers with `std::unique_ptr`. All `delete` statements\n  in the core parts of the code have been eliminated.\n- Exceptions cannot be disabled (`--disable-cxx-exceptions` option has been removed from `./configure`).\n- Every exception thrown in PLUMED now also writes its message on PLUMED log.\n- Runtime loader in `Plumed.c` now works also when linked without `-rdynamic` (that is, \n  its names are not exported). Notice that all the combinations are expected to\n  work, that is: `Plumed.c` from <=2.4 or >=2.5 combined with libplumedKernel\n  from <=2.4 or >=2.5. In order to achieve this the following changes are implemented:\n  - libplumedKernel does not depend anymore on `Plumed.c`. This allows loading it even\n    in cases where names in the loader are not visible. The relevant function needed\n    to be compatible with `Plumed.c` <=2.4 are found using `dlsym`.\n  - `Plumed.c` does not need anymore libplumedKernel to register itself, but rather\n    searches the relevant functions using `dlsym`. In addition, if it is not able to\n    load `libplumedKernel` since the latter is <=2.4 and needs `Plumed.c` to be visible,\n    it just uses as a fallback `libplumed`, which should load properly.\n- In addition to the capability mentioned above, the MD-code interface has been significantly\n  improved and allows for:\n  - Translation of exception (allowing to mix PLUMED and an MD-code linked against a different C++ library).\n  - Possibility to choose the path to the PLUMED kernel while instantiating a Plumed object.\n  See the developer documentation for more information.\n- The installation layout of shared libraries has been modified. In particular,\n  both `libplumed.so` and `plumed` links to `libplumedKernel.so`.\n  This reduces considerably the size of the installed package. In addition, it allows\n  using two-level namespace on OSX. Notice that this implies that on Linux one should\n  always set the `LD_LIBRARY_PATH` flag to have a working executable.\n- A smaller number of header files is installed. In particular, all the files that were historically generated in subdirectories\n  (such as `plumed/core/tools/Vector.h', just including `plumed/tools/Vector.h`) are not installed and the related include\n  statements are fixed. This makes the installed package smaller.\n- List of preferred compilers (used when `CXX` or `CC` are not set) has been changed. On OSX, `./configure` will try `clang++/clang` as first choices.\n- Added `--enable-static-archive` to `./configure` to build a `libplumed.a` static library (yes by default).\n- Stop setting `DYLD_LIBRARY_PATH` in `sourceme.sh` and in modulefile. Notice that as of PLUMED v2.3.3\n  it should not be needed.\n- Coverage scan is not anymore contained in developer manual. It can be found in a separate repository\n  `github.com/coverage-branch` (see \\issue{348}). In addition, coverage for third-party libraries included in PLUMED\n  is reported as well.\n- It is not possible anymore to use `make install prefix=/path`. Prefix can only be changed during `./configure` (see \\issue{332}).\n- Exception class has been rewritten to allow more extensive messages. Now also function name is shown.\n- On linux, library is linked with `-Bsymbolic`.\n- When launching `plumed`, flags `--no-mpi` and `--mpi` can appear multiple times. The last appearence is the effective one.\n- Internal BLAS and LAPACK libraries updated to gromacs 2018.\n- Choosing `./configure --prefix=$PWD` does not lead anymore to deletion of all header files.\n- A copy of `plumed-runtime` is installed in `prefix/lib/plumed` and can be used for testing.\n- Absolute/relative soname/install_name can be configured on linux/OSX. This feature is only\n  for testing, the default choice is the typical one used on the respective operating system.\n- On OSX, `plumed` and `libplumed.dylib` will find `libplumedKernel.dylib` using `@loader_path`.\n- Using CXX compiler to link the main program.\n- plumed can be compiled with ArrayFire to enable for gpu code. \\ref SAXS collective variable is available as part of the isdb module to provide an example of a gpu implementation for a CV\n\n\n## Version 2.5.1 (Apr 1, 2019)\n\nFor users:\n- in \\ref SAXS the keyword ADDEXP is removed. Furthemore, SAXS intensities are automatically normalised for I(0)=1, in case experimental data are provided, the intensity is rescaled with the intensity of the lowest q provided. As a consequence SCALEINT is only needed for additional adjustments.\n- gromacs patch updated to gromacs 2018.5\n- Fixed a bug in gromacs patch that was resulting in incorrect number of threads (0) set when not explicitly using `-ntomp` on the \n  command line or setting `OMP_NUM_THREADS` (see \\issue{446}). To apply this fix you need to re-patch gromacs.\n  Notice that setting the number of threads to zero might lead to inconsistent results when using secondary structure variables\n  or other multicolvars.\n- Fixed PLUMED so that when zero threads are selected from gromacs (see previous fix) the number of used threads is set to 1.\n  This fix allows to use a GROMACS executable patched with PLUMED 2.5.0 and linked at runtime with PLUMED 2.5.1 without introducing\n  errors. However, re-patching is preferred since it selectes the correct number of threads.\n- Python wrappers:\n  - Fixed building of python interface on MacOS Mojave (see \\issue{445}, thanks to Omar Valsson).\n  - Numpy is not required anymore at build time (though it is required at runtime for our tests).\n  - Raw python arrays can be passed as an alternative to Numpy ndarrays.\n\n## Version 2.5.2 (Jul 19, 2019)\n\nFor users:\n- New shortcuts are available for selecting protein atoms: `@chi2-#`, `@chi3-#`,`@chi4-#` and `@chi5-#`\n- Fixed performance of \\ref CUSTOM when having zero derivatives with respect to some arguments.\n- New --parse-only option in \\ref driver to check the validity of a plumed input file\n- New patch for GROMACS 2019.2\n- Module VES: Fixed performance of \\ref BF_CUSTOM for basis functions with linear terms (e.g. having zero derivatives). \n- Python wrappers:\n  - Python module is now always named `plumed` irrespectively of program prefix and suffix. Notice \n    that python module is installed inside the `lib/program_name` directory and thus it is not necessary to\n    use `program_name` in order to install multiple modules side by side.\n  - Python module can be compiled without compiling PLUMED first.\n  - `Plumed` object can be explicitly finalized using `finalize()`. Can be used to make sure all files are closed,\n    but it is not necessary if the `Plumed` object gets correctly collected by Python.\n  - `Plumed` object can be used in context managers (e.g. `with plumed.Plumed() as p:`).\n- Precompiled binaries are available on Anaconda cloud on the [conda-forge channel](https://anaconda.org/conda-forge/plumed).\n\n## Version 2.5.3 (Oct 11, 2019)\n\nFor users:\n- Fixed a bug with \\ref CONVERT_TO_FES and periodic variables, see \\issue{441}\n- Fixed a bug with \\ref FOURIER_TRANSFORM \n- Updated patch for GROMACS 2019.4\n- Updated patch for GROMACS 2018.8\n- Python module:\n  - Fixed building with clang-8.\n  - Set `language_level` for cython to the actually used language level.\n  - Force using cython when compiling from source. Still using the pre-generated cpp file\n    when installing from PyPI, to avoid cython dependency.\n  - Using python 2 to create the cpp file uploaded on PyPI (this will change to python 3 in 2.6, see \\issue{502}).\n- Module VES: Fixed a bug in updating of bias potential in \\ref VES_LINEAR_EXPANSION that is present for certain integrators that call the calculation of the bias multiple times (see [here](https://groups.google.com/d/msg/plumed-users/kPZu_tNZtgk/LrkS0EqrCQAJ)) and replica exchange.\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/src/molfile/periodic_table.h",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/isdb/rt-jcouplings-mi/trajectory.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/isdb/rt-caliber/trajout.2.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/isdb/rt-caliber/trajout.1.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/isdb/rt-caliber/trajout.3.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/isdb/rt-caliber/trajout.0.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/isdb/rt-saxs-mi/traj.0.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/isdb/rt-saxs-mi/traj.1.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/drr/rt-divergence/eabf2dpbc.drrstate",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/drr/rt-extract2dpbc/eabf2dpbc.drrstate",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/drr/rt-extract/test.drrstate",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/drr/rt-merge/eabf_win1.drrstate",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/drr/rt-merge/eabf_win2.drrstate",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/drr/rt-restart/bck.eabf.drrstate.0.reference",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/drr/rt-restart/eabf.drrstate",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/analysis/rt-wham/alltraj.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/trajectories/molfile_plugin/traj.dcd",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/trajectories/molfile_plugin/traj.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/crystallization/rt-sean-marks/some_frames.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/pamm/rt-hbpamm/example-hbpamm.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/basic/rt19-mpi/HH.gz",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/basic/rt19-mpi/HH.0.gz",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/basic/rt19-mpi/input_colvar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/basic/rt19-mpi/COLVAR.res.1.gz",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/basic/rt19-mpi/HH.1.gz",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/basic/rt19-mpi/COLVAR.res.0.gz",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/basic/rt-maxent-3/traj.4.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/basic/rt-maxent-3/traj.2.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/basic/rt-maxent-3/traj.0.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/basic/rt-maxent-3/traj.5.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/basic/rt-maxent-3/traj.1.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/basic/rt-maxent-3/traj.3.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/basic/rt-mpi7b/grid.0.gz",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/basic/rt-mpi7b/gridx.0.gz",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/basic/rt-acc-1/aladip.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/basic/rt-maxent-5/traj.2.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/basic/rt-maxent-5/traj.0.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/basic/rt-maxent-5/traj.1.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/basic/rt-xdrfile-1/test.xtc.reference",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/basic/rt-xdrfile-1/test.trr.reference",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/basic/rt-xdrfile-1/traj.trr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/basic/rt-maxent-1/traj.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/basic/rt-molfile-3/test.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/basic/rt54-xdrfile/helix.ttt.reference",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/basic/rt54-xdrfile/helix.trr.reference",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/basic/rt54-xdrfile/helix.xtc.reference",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/basic/rt54-xdrfile/helix-pr.xtc.reference",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/basic/rt54-xdrfile/traj.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/basic/rt19/COLVAR.res.gz",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/basic/rt19/HH.gz",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/basic/rt19/COLVAR.nores.gz",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/basic/rt19/input_colvar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/basic/rt19/bck.0.COLVAR.nores.gz.reference",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/basic/rt-ermsd/traj.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/basic/rt-ermsd2/traj.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/basic/rt-maxent-4/traj.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/basic/rt-maxent-2/traj.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/basic/rt-xdrfile-2/traj.1.trr.reference",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/basic/rt-xdrfile-2/traj.0.trr.reference",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/basic/rt-xdrfile-2/test.1.trr.reference",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/basic/rt-xdrfile-2/traj.0.trr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/basic/rt-xdrfile-2/test.1.xtc.reference",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/basic/rt-xdrfile-2/traj.1.trr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/basic/rt-xdrfile-2/test.0.trr.reference",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/basic/rt-xdrfile-2/test.0.xtc.reference",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/regtest/basic/rt77/trajectory.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/developer-doc/octocat.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/developer-doc/developer-logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/developer-doc/logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/developer-doc/pigeon.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/user-logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/octocat.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/pigeon.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/ves-lugano2017-kinetics_figure-2.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/trieste-2-block-averages.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/belfast-7-pt2fes.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/ves_basisf-chebyshev.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/belfast-2-bad-matrix.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/lugano-3-hysteresis.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/munster-usrem-phi-all.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/lugano-5-gismo.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/ves-lugano2017-kinetics_figure-1B.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/belfast-2-transition.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/belfast-7-pt2temp.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/lugano-6b-ffdp.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/ves-lugano2017-kinetics_figure-3.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/trieste-2-mc-autocorrelation.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/cambridge-2-deltaG.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/ves-lugano2017-ves1_fesEvolution1.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/lugano-6b-ffcn.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/belfast-2-ab-sz.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/ves-lugano2017-ves2_2D-fes.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/munster-metad-phifest.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/cambridge-chignolin.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/belfast-7-ptwteene.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/ves-lugano2017-metad_NaCl.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/trieste-5-demux-good.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/belfast-2-ala.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/ves-lugano2017-metad_biasEvolution.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/belfast-7-ptmetadhidd.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/lugano-6d-gb.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/trieste-4-block-phi.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/ves-lugano2017-metad_reweightBoth.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/cambridge-2-cvs.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/trieste-6-gb.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/trieste-2-autocorrelation.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/lyon-histograms-lowT.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/ves_basisf-legendre.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/belfast-2-ab-sz-nowhere.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/belfast-2-metadpath.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/trieste-2-histogram-errors.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/belfast-7-pt.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/belfast-7-ptdemux.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/ves-lugano2017-ves1_reweight.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/ves-lugano2017-ves2_well-tempered.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/ves-lugano2017-ves1_biasedDistrib.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/munster-metad-phihills.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/trieste-5-demux-bad.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/belfast-5-work-1.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/belfast-2-ab.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/munster-usrem-phi-fes.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/ves_basisf-legendre-scaled.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/ves-lugano2017-metad_fesEvolution.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/belfast-2-metadpath-free.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/belfast-6-wtb6.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/trieste-5-colvars.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/ves-lugano2017-metad_barrier.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/belfast-2-good-matrix.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/trieste-6-bard1.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/ves-lugano2017-ves1_targetDistrib.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/belfast-8-convergence.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/lugano-6b-ffdc.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/belfast-2-cdk.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/belfast-7-pt2demux.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/belfast-5-doublesteer.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/munster-metad-phi.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/lyon-lj7-minima.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/trieste-6-cmycurea.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/ves-lugano2017-ves2_targetDistrib.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/munster-metad-phifes-difft.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/ves-lugano2017-kinetics_figure-1A.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/trieste-2-confidence.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/munster-usrem-psi-demux.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/belfast-6-phialone.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/belfast-7-ptfes.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/belfast-2-metadpath-correction.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/lugano-6b-ffcnUB.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/lyon-time-series.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/munster-ala-traj-metad.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/belfast-2-good-vs-bad.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/lugano-6b-ffdnUB.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/belfast-4-meta.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/cambridge-2-fes1d.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/ves-lugano2017-ves1_coeffs1.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/lugano-4-lj7-errors.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/belfast-6-phifes.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/lugano-6b-fes.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/belfast-6-hidden.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/trieste-3-histo-dimer.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/belfast-7-ptalaw.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/belfast-5-jarz.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/belfast-6-difft.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/ves-lugano2017-metad_reweightDist.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/trieste-3-wdimer.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/belfast-6-phifest.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/trieste-5-weights.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/marvel-2-pca-coordinates.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/belfast-2-rama.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/belfast-6-metad.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/munster-usrem-psi-fes.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/ves-lugano2017-kinetics_StoneWales.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/belfast-7-ptmetadh.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/belfast-2-good-bad-path.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/belfast-6-wtdifft.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/belfast-6-wtb15.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/munster-metad-psi-phi.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/ves-lugano2017-logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/munster-metad-phifes.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/belfast-7-ptwtediff.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/belfast-8-mg1.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/lyon-histograms-highT.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/ves-lugano2017-ves2_2D-coeffs.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/marvel-2-trans-state.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/ves-lugano2017-ves1_fes.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/munster-ala-traj.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/figs/cambridge-2-fes.png",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/belfast-8/first/topol0.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/belfast-8/first/topol2.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/belfast-8/first/topol3.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/belfast-8/first/topol1.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/belfast-8/second/topol0.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/belfast-8/second/topol2.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/belfast-8/second/topol3.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/belfast-8/second/topol1.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/performance-optimization/topol.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/cambridge-2/TOPO/topol0.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/cambridge-2/TOPO/topol2.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/cambridge-2/TOPO/topol3.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/cambridge-2/TOPO/topol1.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/cambridge-2/first/topol0.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/cambridge-2/first/topol2.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/cambridge-2/first/topol3.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/cambridge-2/first/topol1.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/lugano-6d/GB1.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/trieste-5/topol0.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/trieste-5/topol2.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/trieste-5/topol3.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/trieste-5/topol1.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/trieste-3/wdimer/dimer.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/trieste-3/aladip/aladip.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/marvel-2/PCA-isocommittor/traj_comp.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/marvel-2/PATH-isocommittor/traj_comp.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/marvel-2/2CV-isocommittor/traj_comp.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/lugano-2/topol.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/trieste-4/topol.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/belfast-4/topol.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/munster/TOPO/topolBwat.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/munster/TOPO/topolA.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/munster/TOPO/topolAwat.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/munster/TOPO/topolB.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/cineca/SETUP/topolA.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/cineca/SETUP/topolB.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/belfast-7/Exercise_4/TOPO/topol0.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/belfast-7/Exercise_4/TOPO/topol2.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/belfast-7/Exercise_4/TOPO/topol3.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/belfast-7/Exercise_4/TOPO/topol1.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/belfast-7/Exercise_1/TOPO/topol0.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/belfast-7/Exercise_1/TOPO/topol1.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/belfast-7/Exercise_2/TOPO/topol0.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/belfast-7/Exercise_2/TOPO/topol2.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/belfast-7/Exercise_2/TOPO/topol3.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/belfast-7/Exercise_2/TOPO/topol1.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/belfast-7/Exercise_3/TOPO/topol0.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/belfast-7/Exercise_3/TOPO/topol2.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/belfast-7/Exercise_3/TOPO/topol3.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/belfast-7/Exercise_3/TOPO/topol1.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/cambridge-3/topol0.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/cambridge-3/topol2.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/cambridge-3/topol3.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/cambridge-3/topol1.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/belfast-6/TOPO/topol.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/lugano-3/topol.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/belfast-9a/system/topol.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/belfast-9a/third/topol7.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/belfast-9a/third/topol0.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/belfast-9a/third/topol2.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/belfast-9a/third/topol6.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/belfast-9a/third/topol3.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/belfast-9a/third/topol4.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/belfast-9a/third/topol5.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/belfast-9a/third/topol1.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/belfast-9a/first/topol.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/belfast-9a/second/topol0.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/belfast-9a/second/topol2.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/belfast-9a/second/topol3.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/belfast-9a/second/topol1.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/trieste-1/traj-broken.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/trieste-1/traj-whole.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/cambridge-1/topol.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/others/isdb-2/TUTORIAL_SAXS-AACG/samplextc.xtc",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/others/isdb-1/reference-impl-pbmetad/topolnew2.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/others/isdb-1/reference-impl-pbmetad/topolnew7.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/others/isdb-1/reference-impl-pbmetad/topolnew9.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/others/isdb-1/reference-impl-pbmetad/topolnew8.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/others/isdb-1/reference-impl-pbmetad/topolnew1.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/others/isdb-1/reference-impl-pbmetad/topolnew0.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/others/isdb-1/reference-impl-pbmetad/topolnew6.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/others/isdb-1/reference-impl-pbmetad/topolnew4.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/others/isdb-1/reference-impl-pbmetad/topolnew5.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/others/isdb-1/reference-impl-pbmetad/topolnew13.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/others/isdb-1/reference-impl-pbmetad/topolnew3.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/others/isdb-1/reference-impl-pbmetad/topolnew10.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/others/isdb-1/reference-impl-pbmetad/topolnew12.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/others/isdb-1/reference-impl-pbmetad/topolnew11.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/others/isdb-1/reference-impl/run.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/others/isdb-1/m_and_m/topolnew2.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/others/isdb-1/m_and_m/topolnew7.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/others/isdb-1/m_and_m/topolnew9.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/others/isdb-1/m_and_m/topolnew8.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/others/isdb-1/m_and_m/topolnew1.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/others/isdb-1/m_and_m/topolnew0.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/others/isdb-1/m_and_m/topolnew6.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/others/isdb-1/m_and_m/topolnew4.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/others/isdb-1/m_and_m/topolnew5.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/others/isdb-1/m_and_m/topolnew13.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/others/isdb-1/m_and_m/topolnew3.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/others/isdb-1/m_and_m/topolnew10.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/others/isdb-1/m_and_m/topolnew12.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/user-doc/tutorials/others/isdb-1/m_and_m/topolnew11.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/astyle/doc/news.html",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/test/gromacs/cs2back/topol0.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/test/gromacs/cs2back/topol2.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/test/gromacs/cs2back/topol3.tpr",
        "/tmp/vanessa/spack-stage/spack-stage-plumed-2.5.3-7l7kuwbvampdhyz45jvmq5d6ealuywkx/spack-src/test/gromacs/cs2back/topol1.tpr"
    ],
    "total_files": 5151
}