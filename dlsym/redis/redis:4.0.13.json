{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-redis-4.0.13-c6t5xnt2ivmsaib6izc4ma6blwxnshrd/spack-src/src/module.c": "/*\n * Copyright (c) 2016, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"server.h\"\n#include \"cluster.h\"\n#include <dlfcn.h>\n\n#define REDISMODULE_CORE 1\n#include \"redismodule.h\"\n\n/* --------------------------------------------------------------------------\n * Private data structures used by the modules system. Those are data\n * structures that are never exposed to Redis Modules, if not as void\n * pointers that have an API the module can call with them)\n * -------------------------------------------------------------------------- */\n\n/* This structure represents a module inside the system. */\nstruct RedisModule {\n    void *handle;   /* Module dlopen() handle. */\n    char *name;     /* Module name. */\n    int ver;        /* Module version. We use just progressive integers. */\n    int apiver;     /* Module API version as requested during initialization.*/\n    list *types;    /* Module data types. */\n};\ntypedef struct RedisModule RedisModule;\n\nstatic dict *modules; /* Hash table of modules. SDS -> RedisModule ptr.*/\n\n/* Entries in the context->amqueue array, representing objects to free\n * when the callback returns. */\nstruct AutoMemEntry {\n    void *ptr;\n    int type;\n};\n\n/* AutMemEntry type field values. */\n#define REDISMODULE_AM_KEY 0\n#define REDISMODULE_AM_STRING 1\n#define REDISMODULE_AM_REPLY 2\n#define REDISMODULE_AM_FREED 3 /* Explicitly freed by user already. */\n\n/* The pool allocator block. Redis Modules can allocate memory via this special\n * allocator that will automatically release it all once the callback returns.\n * This means that it can only be used for ephemeral allocations. However\n * there are two advantages for modules to use this API:\n *\n * 1) The memory is automatically released when the callback returns.\n * 2) This allocator is faster for many small allocations since whole blocks\n *    are allocated, and small pieces returned to the caller just advancing\n *    the index of the allocation.\n *\n * Allocations are always rounded to the size of the void pointer in order\n * to always return aligned memory chunks. */\n\n#define REDISMODULE_POOL_ALLOC_MIN_SIZE (1024*8)\n#define REDISMODULE_POOL_ALLOC_ALIGN (sizeof(void*))\n\ntypedef struct RedisModulePoolAllocBlock {\n    uint32_t size;\n    uint32_t used;\n    struct RedisModulePoolAllocBlock *next;\n    char memory[];\n} RedisModulePoolAllocBlock;\n\n/* This structure represents the context in which Redis modules operate.\n * Most APIs module can access, get a pointer to the context, so that the API\n * implementation can hold state across calls, or remember what to free after\n * the call and so forth.\n *\n * Note that not all the context structure is always filled with actual values\n * but only the fields needed in a given context. */\n\nstruct RedisModuleBlockedClient;\n\nstruct RedisModuleCtx {\n    void *getapifuncptr;            /* NOTE: Must be the first field. */\n    struct RedisModule *module;     /* Module reference. */\n    client *client;                 /* Client calling a command. */\n    struct RedisModuleBlockedClient *blocked_client; /* Blocked client for\n                                                        thread safe context. */\n    struct AutoMemEntry *amqueue;   /* Auto memory queue of objects to free. */\n    int amqueue_len;                /* Number of slots in amqueue. */\n    int amqueue_used;               /* Number of used slots in amqueue. */\n    int flags;                      /* REDISMODULE_CTX_... flags. */\n    void **postponed_arrays;        /* To set with RM_ReplySetArrayLength(). */\n    int postponed_arrays_count;     /* Number of entries in postponed_arrays. */\n    void *blocked_privdata;         /* Privdata set when unblocking a client. */\n\n    /* Used if there is the REDISMODULE_CTX_KEYS_POS_REQUEST flag set. */\n    int *keys_pos;\n    int keys_count;\n\n    struct RedisModulePoolAllocBlock *pa_head;\n};\ntypedef struct RedisModuleCtx RedisModuleCtx;\n\n#define REDISMODULE_CTX_INIT {(void*)(unsigned long)&RM_GetApi, NULL, NULL, NULL, NULL, 0, 0, 0, NULL, 0, NULL, NULL, 0, NULL}\n#define REDISMODULE_CTX_MULTI_EMITTED (1<<0)\n#define REDISMODULE_CTX_AUTO_MEMORY (1<<1)\n#define REDISMODULE_CTX_KEYS_POS_REQUEST (1<<2)\n#define REDISMODULE_CTX_BLOCKED_REPLY (1<<3)\n#define REDISMODULE_CTX_BLOCKED_TIMEOUT (1<<4)\n#define REDISMODULE_CTX_THREAD_SAFE (1<<5)\n\n/* This represents a Redis key opened with RM_OpenKey(). */\nstruct RedisModuleKey {\n    RedisModuleCtx *ctx;\n    redisDb *db;\n    robj *key;      /* Key name object. */\n    robj *value;    /* Value object, or NULL if the key was not found. */\n    void *iter;     /* Iterator. */\n    int mode;       /* Opening mode. */\n\n    /* Zset iterator. */\n    uint32_t ztype;         /* REDISMODULE_ZSET_RANGE_* */\n    zrangespec zrs;         /* Score range. */\n    zlexrangespec zlrs;     /* Lex range. */\n    uint32_t zstart;        /* Start pos for positional ranges. */\n    uint32_t zend;          /* End pos for positional ranges. */\n    void *zcurrent;         /* Zset iterator current node. */\n    int zer;                /* Zset iterator end reached flag\n                               (true if end was reached). */\n};\ntypedef struct RedisModuleKey RedisModuleKey;\n\n/* RedisModuleKey 'ztype' values. */\n#define REDISMODULE_ZSET_RANGE_NONE 0       /* This must always be 0. */\n#define REDISMODULE_ZSET_RANGE_LEX 1\n#define REDISMODULE_ZSET_RANGE_SCORE 2\n#define REDISMODULE_ZSET_RANGE_POS 3\n\n/* Function pointer type of a function representing a command inside\n * a Redis module. */\ntypedef int (*RedisModuleCmdFunc) (RedisModuleCtx *ctx, void **argv, int argc);\n\n/* This struct holds the information about a command registered by a module.*/\nstruct RedisModuleCommandProxy {\n    struct RedisModule *module;\n    RedisModuleCmdFunc func;\n    struct redisCommand *rediscmd;\n};\ntypedef struct RedisModuleCommandProxy RedisModuleCommandProxy;\n\n#define REDISMODULE_REPLYFLAG_NONE 0\n#define REDISMODULE_REPLYFLAG_TOPARSE (1<<0) /* Protocol must be parsed. */\n#define REDISMODULE_REPLYFLAG_NESTED (1<<1)  /* Nested reply object. No proto\n                                                or struct free. */\n\n/* Reply of RM_Call() function. The function is filled in a lazy\n * way depending on the function called on the reply structure. By default\n * only the type, proto and protolen are filled. */\ntypedef struct RedisModuleCallReply {\n    RedisModuleCtx *ctx;\n    int type;       /* REDISMODULE_REPLY_... */\n    int flags;      /* REDISMODULE_REPLYFLAG_...  */\n    size_t len;     /* Len of strings or num of elements of arrays. */\n    char *proto;    /* Raw reply protocol. An SDS string at top-level object. */\n    size_t protolen;/* Length of protocol. */\n    union {\n        const char *str; /* String pointer for string and error replies. This\n                            does not need to be freed, always points inside\n                            a reply->proto buffer of the reply object or, in\n                            case of array elements, of parent reply objects. */\n        long long ll;    /* Reply value for integer reply. */\n        struct RedisModuleCallReply *array; /* Array of sub-reply elements. */\n    } val;\n} RedisModuleCallReply;\n\n/* Structure representing a blocked client. We get a pointer to such\n * an object when blocking from modules. */\ntypedef struct RedisModuleBlockedClient {\n    client *client;  /* Pointer to the blocked client. or NULL if the client\n                        was destroyed during the life of this object. */\n    RedisModule *module;    /* Module blocking the client. */\n    RedisModuleCmdFunc reply_callback; /* Reply callback on normal completion.*/\n    RedisModuleCmdFunc timeout_callback; /* Reply callback on timeout. */\n    void (*free_privdata)(void *);       /* privdata cleanup callback. */\n    void *privdata;     /* Module private data that may be used by the reply\n                           or timeout callback. It is set via the\n                           RedisModule_UnblockClient() API. */\n    client *reply_client;           /* Fake client used to accumulate replies\n                                       in thread safe contexts. */\n    int dbid;           /* Database number selected by the original client. */\n} RedisModuleBlockedClient;\n\nstatic pthread_mutex_t moduleUnblockedClientsMutex = PTHREAD_MUTEX_INITIALIZER;\nstatic list *moduleUnblockedClients;\n\n/* We need a mutex that is unlocked / relocked in beforeSleep() in order to\n * allow thread safe contexts to execute commands at a safe moment. */\nstatic pthread_mutex_t moduleGIL = PTHREAD_MUTEX_INITIALIZER;\n\n\n/* Function pointer type for keyspace event notification subscriptions from modules. */\ntypedef int (*RedisModuleNotificationFunc) (RedisModuleCtx *ctx, int type, const char *event, RedisModuleString *key);\n\n/* Keyspace notification subscriber information.\n * See RM_SubscribeToKeyspaceEvents() for more information. */\ntypedef struct RedisModuleKeyspaceSubscriber {\n    /* The module subscribed to the event */\n    RedisModule *module;\n    /* Notification callback in the module*/\n    RedisModuleNotificationFunc notify_callback;\n    /* A bit mask of the events the module is interested in */\n    int event_mask;\n    /* Active flag set on entry, to avoid reentrant subscribers\n     * calling themselves */\n    int active;\n} RedisModuleKeyspaceSubscriber;\n\n/* The module keyspace notification subscribers list */\nstatic list *moduleKeyspaceSubscribers;\n\n/* Static client recycled for all notification clients, to avoid allocating\n * per round. */\nstatic client *moduleKeyspaceSubscribersClient;\n\n/* --------------------------------------------------------------------------\n * Prototypes\n * -------------------------------------------------------------------------- */\n\nvoid RM_FreeCallReply(RedisModuleCallReply *reply);\nvoid RM_CloseKey(RedisModuleKey *key);\nvoid autoMemoryCollect(RedisModuleCtx *ctx);\nrobj **moduleCreateArgvFromUserFormat(const char *cmdname, const char *fmt, int *argcp, int *flags, va_list ap);\nvoid moduleReplicateMultiIfNeeded(RedisModuleCtx *ctx);\nvoid RM_ZsetRangeStop(RedisModuleKey *kp);\nstatic void zsetKeyReset(RedisModuleKey *key);\n\n/* --------------------------------------------------------------------------\n * Heap allocation raw functions\n * -------------------------------------------------------------------------- */\n\n/* Use like malloc(). Memory allocated with this function is reported in\n * Redis INFO memory, used for keys eviction according to maxmemory settings\n * and in general is taken into account as memory allocated by Redis.\n * You should avoid using malloc(). */\nvoid *RM_Alloc(size_t bytes) {\n    return zmalloc(bytes);\n}\n\n/* Use like calloc(). Memory allocated with this function is reported in\n * Redis INFO memory, used for keys eviction according to maxmemory settings\n * and in general is taken into account as memory allocated by Redis.\n * You should avoid using calloc() directly. */\nvoid *RM_Calloc(size_t nmemb, size_t size) {\n    return zcalloc(nmemb*size);\n}\n\n/* Use like realloc() for memory obtained with RedisModule_Alloc(). */\nvoid* RM_Realloc(void *ptr, size_t bytes) {\n    return zrealloc(ptr,bytes);\n}\n\n/* Use like free() for memory obtained by RedisModule_Alloc() and\n * RedisModule_Realloc(). However you should never try to free with\n * RedisModule_Free() memory allocated with malloc() inside your module. */\nvoid RM_Free(void *ptr) {\n    zfree(ptr);\n}\n\n/* Like strdup() but returns memory allocated with RedisModule_Alloc(). */\nchar *RM_Strdup(const char *str) {\n    return zstrdup(str);\n}\n\n/* --------------------------------------------------------------------------\n * Pool allocator\n * -------------------------------------------------------------------------- */\n\n/* Release the chain of blocks used for pool allocations. */\nvoid poolAllocRelease(RedisModuleCtx *ctx) {\n    RedisModulePoolAllocBlock *head = ctx->pa_head, *next;\n\n    while(head != NULL) {\n        next = head->next;\n        zfree(head);\n        head = next;\n    }\n    ctx->pa_head = NULL;\n}\n\n/* Return heap allocated memory that will be freed automatically when the\n * module callback function returns. Mostly suitable for small allocations\n * that are short living and must be released when the callback returns\n * anyway. The returned memory is aligned to the architecture word size\n * if at least word size bytes are requested, otherwise it is just\n * aligned to the next power of two, so for example a 3 bytes request is\n * 4 bytes aligned while a 2 bytes request is 2 bytes aligned.\n *\n * There is no realloc style function since when this is needed to use the\n * pool allocator is not a good idea.\n *\n * The function returns NULL if `bytes` is 0. */\nvoid *RM_PoolAlloc(RedisModuleCtx *ctx, size_t bytes) {\n    if (bytes == 0) return NULL;\n    RedisModulePoolAllocBlock *b = ctx->pa_head;\n    size_t left = b ? b->size - b->used : 0;\n\n    /* Fix alignment. */\n    if (left >= bytes) {\n        size_t alignment = REDISMODULE_POOL_ALLOC_ALIGN;\n        while (bytes < alignment && alignment/2 >= bytes) alignment /= 2;\n        if (b->used % alignment)\n            b->used += alignment - (b->used % alignment);\n        left = (b->used > b->size) ? 0 : b->size - b->used;\n    }\n\n    /* Create a new block if needed. */\n    if (left < bytes) {\n        size_t blocksize = REDISMODULE_POOL_ALLOC_MIN_SIZE;\n        if (blocksize < bytes) blocksize = bytes;\n        b = zmalloc(sizeof(*b) + blocksize);\n        b->size = blocksize;\n        b->used = 0;\n        b->next = ctx->pa_head;\n        ctx->pa_head = b;\n    }\n\n    char *retval = b->memory + b->used;\n    b->used += bytes;\n    return retval;\n}\n\n/* --------------------------------------------------------------------------\n * Helpers for modules API implementation\n * -------------------------------------------------------------------------- */\n\n/* Create an empty key of the specified type. 'kp' must point to a key object\n * opened for writing where the .value member is set to NULL because the\n * key was found to be non existing.\n *\n * On success REDISMODULE_OK is returned and the key is populated with\n * the value of the specified type. The function fails and returns\n * REDISMODULE_ERR if:\n *\n * 1) The key is not open for writing.\n * 2) The key is not empty.\n * 3) The specified type is unknown.\n */\nint moduleCreateEmptyKey(RedisModuleKey *key, int type) {\n    robj *obj;\n\n    /* The key must be open for writing and non existing to proceed. */\n    if (!(key->mode & REDISMODULE_WRITE) || key->value)\n        return REDISMODULE_ERR;\n\n    switch(type) {\n    case REDISMODULE_KEYTYPE_LIST:\n        obj = createQuicklistObject();\n        quicklistSetOptions(obj->ptr, server.list_max_ziplist_size,\n                            server.list_compress_depth);\n        break;\n    case REDISMODULE_KEYTYPE_ZSET:\n        obj = createZsetZiplistObject();\n        break;\n    case REDISMODULE_KEYTYPE_HASH:\n        obj = createHashObject();\n        break;\n    default: return REDISMODULE_ERR;\n    }\n    dbAdd(key->db,key->key,obj);\n    key->value = obj;\n    return REDISMODULE_OK;\n}\n\n/* This function is called in low-level API implementation functions in order\n * to check if the value associated with the key remained empty after an\n * operation that removed elements from an aggregate data type.\n *\n * If this happens, the key is deleted from the DB and the key object state\n * is set to the right one in order to be targeted again by write operations\n * possibly recreating the key if needed.\n *\n * The function returns 1 if the key value object is found empty and is\n * deleted, otherwise 0 is returned. */\nint moduleDelKeyIfEmpty(RedisModuleKey *key) {\n    if (!(key->mode & REDISMODULE_WRITE) || key->value == NULL) return 0;\n    int isempty;\n    robj *o = key->value;\n\n    switch(o->type) {\n    case OBJ_LIST: isempty = listTypeLength(o) == 0; break;\n    case OBJ_SET: isempty = setTypeSize(o) == 0; break;\n    case OBJ_ZSET: isempty = zsetLength(o) == 0; break;\n    case OBJ_HASH : isempty = hashTypeLength(o) == 0; break;\n    default: isempty = 0;\n    }\n\n    if (isempty) {\n        dbDelete(key->db,key->key);\n        key->value = NULL;\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\n/* --------------------------------------------------------------------------\n * Service API exported to modules\n *\n * Note that all the exported APIs are called RM_<funcname> in the core\n * and RedisModule_<funcname> in the module side (defined as function\n * pointers in redismodule.h). In this way the dynamic linker does not\n * mess with our global function pointers, overriding it with the symbols\n * defined in the main executable having the same names.\n * -------------------------------------------------------------------------- */\n\n/* Lookup the requested module API and store the function pointer into the\n * target pointer. The function returns REDISMODULE_ERR if there is no such\n * named API, otherwise REDISMODULE_OK.\n *\n * This function is not meant to be used by modules developer, it is only\n * used implicitly by including redismodule.h. */\nint RM_GetApi(const char *funcname, void **targetPtrPtr) {\n    dictEntry *he = dictFind(server.moduleapi, funcname);\n    if (!he) return REDISMODULE_ERR;\n    *targetPtrPtr = dictGetVal(he);\n    return REDISMODULE_OK;\n}\n\n/* Free the context after the user function was called. */\nvoid moduleFreeContext(RedisModuleCtx *ctx) {\n    autoMemoryCollect(ctx);\n    poolAllocRelease(ctx);\n    if (ctx->postponed_arrays) {\n        zfree(ctx->postponed_arrays);\n        ctx->postponed_arrays_count = 0;\n        serverLog(LL_WARNING,\n            \"API misuse detected in module %s: \"\n            \"RedisModule_ReplyWithArray(REDISMODULE_POSTPONED_ARRAY_LEN) \"\n            \"not matched by the same number of RedisModule_SetReplyArrayLen() \"\n            \"calls.\",\n            ctx->module->name);\n    }\n    if (ctx->flags & REDISMODULE_CTX_THREAD_SAFE) freeClient(ctx->client);\n}\n\n/* Helper function for when a command callback is called, in order to handle\n * details needed to correctly replicate commands. */\nvoid moduleHandlePropagationAfterCommandCallback(RedisModuleCtx *ctx) {\n    client *c = ctx->client;\n\n    if (c->flags & CLIENT_LUA) return;\n\n    /* Handle the replication of the final EXEC, since whatever a command\n     * emits is always wrappered around MULTI/EXEC. */\n    if (ctx->flags & REDISMODULE_CTX_MULTI_EMITTED) {\n        robj *propargv[1];\n        propargv[0] = createStringObject(\"EXEC\",4);\n        alsoPropagate(server.execCommand,c->db->id,propargv,1,\n            PROPAGATE_AOF|PROPAGATE_REPL);\n        decrRefCount(propargv[0]);\n    }\n}\n\n/* This Redis command binds the normal Redis command invocation with commands\n * exported by modules. */\nvoid RedisModuleCommandDispatcher(client *c) {\n    RedisModuleCommandProxy *cp = (void*)(unsigned long)c->cmd->getkeys_proc;\n    RedisModuleCtx ctx = REDISMODULE_CTX_INIT;\n\n    ctx.module = cp->module;\n    ctx.client = c;\n    cp->func(&ctx,(void**)c->argv,c->argc);\n    moduleHandlePropagationAfterCommandCallback(&ctx);\n    moduleFreeContext(&ctx);\n}\n\n/* This function returns the list of keys, with the same interface as the\n * 'getkeys' function of the native commands, for module commands that exported\n * the \"getkeys-api\" flag during the registration. This is done when the\n * list of keys are not at fixed positions, so that first/last/step cannot\n * be used.\n *\n * In order to accomplish its work, the module command is called, flagging\n * the context in a way that the command can recognize this is a special\n * \"get keys\" call by calling RedisModule_IsKeysPositionRequest(ctx). */\nint *moduleGetCommandKeysViaAPI(struct redisCommand *cmd, robj **argv, int argc, int *numkeys) {\n    RedisModuleCommandProxy *cp = (void*)(unsigned long)cmd->getkeys_proc;\n    RedisModuleCtx ctx = REDISMODULE_CTX_INIT;\n\n    ctx.module = cp->module;\n    ctx.client = NULL;\n    ctx.flags |= REDISMODULE_CTX_KEYS_POS_REQUEST;\n    cp->func(&ctx,(void**)argv,argc);\n    int *res = ctx.keys_pos;\n    if (numkeys) *numkeys = ctx.keys_count;\n    moduleFreeContext(&ctx);\n    return res;\n}\n\n/* Return non-zero if a module command, that was declared with the\n * flag \"getkeys-api\", is called in a special way to get the keys positions\n * and not to get executed. Otherwise zero is returned. */\nint RM_IsKeysPositionRequest(RedisModuleCtx *ctx) {\n    return (ctx->flags & REDISMODULE_CTX_KEYS_POS_REQUEST) != 0;\n}\n\n/* When a module command is called in order to obtain the position of\n * keys, since it was flagged as \"getkeys-api\" during the registration,\n * the command implementation checks for this special call using the\n * RedisModule_IsKeysPositionRequest() API and uses this function in\n * order to report keys, like in the following example:\n *\n *     if (RedisModule_IsKeysPositionRequest(ctx)) {\n *         RedisModule_KeyAtPos(ctx,1);\n *         RedisModule_KeyAtPos(ctx,2);\n *     }\n *\n *  Note: in the example below the get keys API would not be needed since\n *  keys are at fixed positions. This interface is only used for commands\n *  with a more complex structure. */\nvoid RM_KeyAtPos(RedisModuleCtx *ctx, int pos) {\n    if (!(ctx->flags & REDISMODULE_CTX_KEYS_POS_REQUEST)) return;\n    if (pos <= 0) return;\n    ctx->keys_pos = zrealloc(ctx->keys_pos,sizeof(int)*(ctx->keys_count+1));\n    ctx->keys_pos[ctx->keys_count++] = pos;\n}\n\n/* Helper for RM_CreateCommand(). Truns a string representing command\n * flags into the command flags used by the Redis core.\n *\n * It returns the set of flags, or -1 if unknown flags are found. */\nint commandFlagsFromString(char *s) {\n    int count, j;\n    int flags = 0;\n    sds *tokens = sdssplitlen(s,strlen(s),\" \",1,&count);\n    for (j = 0; j < count; j++) {\n        char *t = tokens[j];\n        if (!strcasecmp(t,\"write\")) flags |= CMD_WRITE;\n        else if (!strcasecmp(t,\"readonly\")) flags |= CMD_READONLY;\n        else if (!strcasecmp(t,\"admin\")) flags |= CMD_ADMIN;\n        else if (!strcasecmp(t,\"deny-oom\")) flags |= CMD_DENYOOM;\n        else if (!strcasecmp(t,\"deny-script\")) flags |= CMD_NOSCRIPT;\n        else if (!strcasecmp(t,\"allow-loading\")) flags |= CMD_LOADING;\n        else if (!strcasecmp(t,\"pubsub\")) flags |= CMD_PUBSUB;\n        else if (!strcasecmp(t,\"random\")) flags |= CMD_RANDOM;\n        else if (!strcasecmp(t,\"allow-stale\")) flags |= CMD_STALE;\n        else if (!strcasecmp(t,\"no-monitor\")) flags |= CMD_SKIP_MONITOR;\n        else if (!strcasecmp(t,\"fast\")) flags |= CMD_FAST;\n        else if (!strcasecmp(t,\"getkeys-api\")) flags |= CMD_MODULE_GETKEYS;\n        else if (!strcasecmp(t,\"no-cluster\")) flags |= CMD_MODULE_NO_CLUSTER;\n        else break;\n    }\n    sdsfreesplitres(tokens,count);\n    if (j != count) return -1; /* Some token not processed correctly. */\n    return flags;\n}\n\n/* Register a new command in the Redis server, that will be handled by\n * calling the function pointer 'func' using the RedisModule calling\n * convention. The function returns REDISMODULE_ERR if the specified command\n * name is already busy or a set of invalid flags were passed, otherwise\n * REDISMODULE_OK is returned and the new command is registered.\n *\n * This function must be called during the initialization of the module\n * inside the RedisModule_OnLoad() function. Calling this function outside\n * of the initialization function is not defined.\n *\n * The command function type is the following:\n *\n *      int MyCommand_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc);\n *\n * And is supposed to always return REDISMODULE_OK.\n *\n * The set of flags 'strflags' specify the behavior of the command, and should\n * be passed as a C string compoesd of space separated words, like for\n * example \"write deny-oom\". The set of flags are:\n *\n * * **\"write\"**:     The command may modify the data set (it may also read\n *                    from it).\n * * **\"readonly\"**:  The command returns data from keys but never writes.\n * * **\"admin\"**:     The command is an administrative command (may change\n *                    replication or perform similar tasks).\n * * **\"deny-oom\"**:  The command may use additional memory and should be\n *                    denied during out of memory conditions.\n * * **\"deny-script\"**:   Don't allow this command in Lua scripts.\n * * **\"allow-loading\"**: Allow this command while the server is loading data.\n *                        Only commands not interacting with the data set\n *                        should be allowed to run in this mode. If not sure\n *                        don't use this flag.\n * * **\"pubsub\"**:    The command publishes things on Pub/Sub channels.\n * * **\"random\"**:    The command may have different outputs even starting\n *                    from the same input arguments and key values.\n * * **\"allow-stale\"**: The command is allowed to run on slaves that don't\n *                      serve stale data. Don't use if you don't know what\n *                      this means.\n * * **\"no-monitor\"**: Don't propoagate the command on monitor. Use this if\n *                     the command has sensible data among the arguments.\n * * **\"fast\"**:      The command time complexity is not greater\n *                    than O(log(N)) where N is the size of the collection or\n *                    anything else representing the normal scalability\n *                    issue with the command.\n * * **\"getkeys-api\"**: The command implements the interface to return\n *                      the arguments that are keys. Used when start/stop/step\n *                      is not enough because of the command syntax.\n * * **\"no-cluster\"**: The command should not register in Redis Cluster\n *                     since is not designed to work with it because, for\n *                     example, is unable to report the position of the\n *                     keys, programmatically creates key names, or any\n *                     other reason.\n */\nint RM_CreateCommand(RedisModuleCtx *ctx, const char *name, RedisModuleCmdFunc cmdfunc, const char *strflags, int firstkey, int lastkey, int keystep) {\n    int flags = strflags ? commandFlagsFromString((char*)strflags) : 0;\n    if (flags == -1) return REDISMODULE_ERR;\n    if ((flags & CMD_MODULE_NO_CLUSTER) && server.cluster_enabled)\n        return REDISMODULE_ERR;\n\n    struct redisCommand *rediscmd;\n    RedisModuleCommandProxy *cp;\n    sds cmdname = sdsnew(name);\n\n    /* Check if the command name is busy. */\n    if (lookupCommand(cmdname) != NULL) {\n        sdsfree(cmdname);\n        return REDISMODULE_ERR;\n    }\n\n    /* Create a command \"proxy\", which is a structure that is referenced\n     * in the command table, so that the generic command that works as\n     * binding between modules and Redis, can know what function to call\n     * and what the module is.\n     *\n     * Note that we use the Redis command table 'getkeys_proc' in order to\n     * pass a reference to the command proxy structure. */\n    cp = zmalloc(sizeof(*cp));\n    cp->module = ctx->module;\n    cp->func = cmdfunc;\n    cp->rediscmd = zmalloc(sizeof(*rediscmd));\n    cp->rediscmd->name = cmdname;\n    cp->rediscmd->proc = RedisModuleCommandDispatcher;\n    cp->rediscmd->arity = -1;\n    cp->rediscmd->flags = flags | CMD_MODULE;\n    cp->rediscmd->getkeys_proc = (redisGetKeysProc*)(unsigned long)cp;\n    cp->rediscmd->firstkey = firstkey;\n    cp->rediscmd->lastkey = lastkey;\n    cp->rediscmd->keystep = keystep;\n    cp->rediscmd->microseconds = 0;\n    cp->rediscmd->calls = 0;\n    dictAdd(server.commands,sdsdup(cmdname),cp->rediscmd);\n    dictAdd(server.orig_commands,sdsdup(cmdname),cp->rediscmd);\n    return REDISMODULE_OK;\n}\n\n/* Called by RM_Init() to setup the `ctx->module` structure.\n *\n * This is an internal function, Redis modules developers don't need\n * to use it. */\nvoid RM_SetModuleAttribs(RedisModuleCtx *ctx, const char *name, int ver, int apiver) {\n    RedisModule *module;\n\n    if (ctx->module != NULL) return;\n    module = zmalloc(sizeof(*module));\n    module->name = sdsnew((char*)name);\n    module->ver = ver;\n    module->apiver = apiver;\n    module->types = listCreate();\n    ctx->module = module;\n}\n\n/* Return non-zero if the module name is busy.\n * Otherwise zero is returned. */\nint RM_IsModuleNameBusy(const char *name) {\n    sds modulename = sdsnew(name);\n    dictEntry *de = dictFind(modules,modulename);\n    sdsfree(modulename);\n    return de != NULL;\n}\n\n/* Return the current UNIX time in milliseconds. */\nlong long RM_Milliseconds(void) {\n    return mstime();\n}\n\n/* --------------------------------------------------------------------------\n * Automatic memory management for modules\n * -------------------------------------------------------------------------- */\n\n/* Enable automatic memory management. See API.md for more information.\n *\n * The function must be called as the first function of a command implementation\n * that wants to use automatic memory. */\nvoid RM_AutoMemory(RedisModuleCtx *ctx) {\n    ctx->flags |= REDISMODULE_CTX_AUTO_MEMORY;\n}\n\n/* Add a new object to release automatically when the callback returns. */\nvoid autoMemoryAdd(RedisModuleCtx *ctx, int type, void *ptr) {\n    if (!(ctx->flags & REDISMODULE_CTX_AUTO_MEMORY)) return;\n    if (ctx->amqueue_used == ctx->amqueue_len) {\n        ctx->amqueue_len *= 2;\n        if (ctx->amqueue_len < 16) ctx->amqueue_len = 16;\n        ctx->amqueue = zrealloc(ctx->amqueue,sizeof(struct AutoMemEntry)*ctx->amqueue_len);\n    }\n    ctx->amqueue[ctx->amqueue_used].type = type;\n    ctx->amqueue[ctx->amqueue_used].ptr = ptr;\n    ctx->amqueue_used++;\n}\n\n/* Mark an object as freed in the auto release queue, so that users can still\n * free things manually if they want.\n *\n * The function returns 1 if the object was actually found in the auto memory\n * pool, otherwise 0 is returned. */\nint autoMemoryFreed(RedisModuleCtx *ctx, int type, void *ptr) {\n    if (!(ctx->flags & REDISMODULE_CTX_AUTO_MEMORY)) return 0;\n\n    int count = (ctx->amqueue_used+1)/2;\n    for (int j = 0; j < count; j++) {\n        for (int side = 0; side < 2; side++) {\n            /* For side = 0 check right side of the array, for\n             * side = 1 check the left side instead (zig-zag scanning). */\n            int i = (side == 0) ? (ctx->amqueue_used - 1 - j) : j;\n            if (ctx->amqueue[i].type == type &&\n                ctx->amqueue[i].ptr == ptr)\n            {\n                ctx->amqueue[i].type = REDISMODULE_AM_FREED;\n\n                /* Switch the freed element and the last element, to avoid growing\n                 * the queue unnecessarily if we allocate/free in a loop */\n                if (i != ctx->amqueue_used-1) {\n                    ctx->amqueue[i] = ctx->amqueue[ctx->amqueue_used-1];\n                }\n\n                /* Reduce the size of the queue because we either moved the top\n                 * element elsewhere or freed it */\n                ctx->amqueue_used--;\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n\n/* Release all the objects in queue. */\nvoid autoMemoryCollect(RedisModuleCtx *ctx) {\n    if (!(ctx->flags & REDISMODULE_CTX_AUTO_MEMORY)) return;\n    /* Clear the AUTO_MEMORY flag from the context, otherwise the functions\n     * we call to free the resources, will try to scan the auto release\n     * queue to mark the entries as freed. */\n    ctx->flags &= ~REDISMODULE_CTX_AUTO_MEMORY;\n    int j;\n    for (j = 0; j < ctx->amqueue_used; j++) {\n        void *ptr = ctx->amqueue[j].ptr;\n        switch(ctx->amqueue[j].type) {\n        case REDISMODULE_AM_STRING: decrRefCount(ptr); break;\n        case REDISMODULE_AM_REPLY: RM_FreeCallReply(ptr); break;\n        case REDISMODULE_AM_KEY: RM_CloseKey(ptr); break;\n        }\n    }\n    ctx->flags |= REDISMODULE_CTX_AUTO_MEMORY;\n    zfree(ctx->amqueue);\n    ctx->amqueue = NULL;\n    ctx->amqueue_len = 0;\n    ctx->amqueue_used = 0;\n}\n\n/* --------------------------------------------------------------------------\n * String objects APIs\n * -------------------------------------------------------------------------- */\n\n/* Create a new module string object. The returned string must be freed\n * with RedisModule_FreeString(), unless automatic memory is enabled.\n *\n * The string is created by copying the `len` bytes starting\n * at `ptr`. No reference is retained to the passed buffer. */\nRedisModuleString *RM_CreateString(RedisModuleCtx *ctx, const char *ptr, size_t len) {\n    RedisModuleString *o = createStringObject(ptr,len);\n    autoMemoryAdd(ctx,REDISMODULE_AM_STRING,o);\n    return o;\n}\n\n\n/* Create a new module string object from a printf format and arguments.\n * The returned string must be freed with RedisModule_FreeString(), unless\n * automatic memory is enabled.\n *\n * The string is created using the sds formatter function sdscatvprintf(). */\nRedisModuleString *RM_CreateStringPrintf(RedisModuleCtx *ctx, const char *fmt, ...) {\n    sds s = sdsempty();\n\n    va_list ap;\n    va_start(ap, fmt);\n    s = sdscatvprintf(s, fmt, ap);\n    va_end(ap);\n\n    RedisModuleString *o = createObject(OBJ_STRING, s);\n    autoMemoryAdd(ctx,REDISMODULE_AM_STRING,o);\n\n    return o;\n}\n\n\n/* Like RedisModule_CreatString(), but creates a string starting from a long long\n * integer instead of taking a buffer and its length.\n *\n * The returned string must be released with RedisModule_FreeString() or by\n * enabling automatic memory management. */\nRedisModuleString *RM_CreateStringFromLongLong(RedisModuleCtx *ctx, long long ll) {\n    char buf[LONG_STR_SIZE];\n    size_t len = ll2string(buf,sizeof(buf),ll);\n    return RM_CreateString(ctx,buf,len);\n}\n\n/* Like RedisModule_CreatString(), but creates a string starting from another\n * RedisModuleString.\n *\n * The returned string must be released with RedisModule_FreeString() or by\n * enabling automatic memory management. */\nRedisModuleString *RM_CreateStringFromString(RedisModuleCtx *ctx, const RedisModuleString *str) {\n    RedisModuleString *o = dupStringObject(str);\n    autoMemoryAdd(ctx,REDISMODULE_AM_STRING,o);\n    return o;\n}\n\n/* Free a module string object obtained with one of the Redis modules API calls\n * that return new string objects.\n *\n * It is possible to call this function even when automatic memory management\n * is enabled. In that case the string will be released ASAP and removed\n * from the pool of string to release at the end. */\nvoid RM_FreeString(RedisModuleCtx *ctx, RedisModuleString *str) {\n    decrRefCount(str);\n    autoMemoryFreed(ctx,REDISMODULE_AM_STRING,str);\n}\n\n/* Every call to this function, will make the string 'str' requiring\n * an additional call to RedisModule_FreeString() in order to really\n * free the string. Note that the automatic freeing of the string obtained\n * enabling modules automatic memory management counts for one\n * RedisModule_FreeString() call (it is just executed automatically).\n *\n * Normally you want to call this function when, at the same time\n * the following conditions are true:\n *\n * 1) You have automatic memory management enabled.\n * 2) You want to create string objects.\n * 3) Those string objects you create need to live *after* the callback\n *    function(for example a command implementation) creating them returns.\n *\n * Usually you want this in order to store the created string object\n * into your own data structure, for example when implementing a new data\n * type.\n *\n * Note that when memory management is turned off, you don't need\n * any call to RetainString() since creating a string will always result\n * into a string that lives after the callback function returns, if\n * no FreeString() call is performed. */\nvoid RM_RetainString(RedisModuleCtx *ctx, RedisModuleString *str) {\n    if (!autoMemoryFreed(ctx,REDISMODULE_AM_STRING,str)) {\n        /* Increment the string reference counting only if we can't\n         * just remove the object from the list of objects that should\n         * be reclaimed. Why we do that, instead of just incrementing\n         * the refcount in any case, and let the automatic FreeString()\n         * call at the end to bring the refcount back at the desired\n         * value? Because this way we ensure that the object refcount\n         * value is 1 (instead of going to 2 to be dropped later to 1)\n         * after the call to this function. This is needed for functions\n         * like RedisModule_StringAppendBuffer() to work. */\n        incrRefCount(str);\n    }\n}\n\n/* Given a string module object, this function returns the string pointer\n * and length of the string. The returned pointer and length should only\n * be used for read only accesses and never modified. */\nconst char *RM_StringPtrLen(const RedisModuleString *str, size_t *len) {\n    if (str == NULL) {\n        const char *errmsg = \"(NULL string reply referenced in module)\";\n        if (len) *len = strlen(errmsg);\n        return errmsg;\n    }\n    if (len) *len = sdslen(str->ptr);\n    return str->ptr;\n}\n\n/* --------------------------------------------------------------------------\n * Higher level string operations\n * ------------------------------------------------------------------------- */\n\n/* Convert the string into a long long integer, storing it at `*ll`.\n * Returns REDISMODULE_OK on success. If the string can't be parsed\n * as a valid, strict long long (no spaces before/after), REDISMODULE_ERR\n * is returned. */\nint RM_StringToLongLong(const RedisModuleString *str, long long *ll) {\n    return string2ll(str->ptr,sdslen(str->ptr),ll) ? REDISMODULE_OK :\n                                                     REDISMODULE_ERR;\n}\n\n/* Convert the string into a double, storing it at `*d`.\n * Returns REDISMODULE_OK on success or REDISMODULE_ERR if the string is\n * not a valid string representation of a double value. */\nint RM_StringToDouble(const RedisModuleString *str, double *d) {\n    int retval = getDoubleFromObject(str,d);\n    return (retval == C_OK) ? REDISMODULE_OK : REDISMODULE_ERR;\n}\n\n/* Compare two string objects, returning -1, 0 or 1 respectively if\n * a < b, a == b, a > b. Strings are compared byte by byte as two\n * binary blobs without any encoding care / collation attempt. */\nint RM_StringCompare(RedisModuleString *a, RedisModuleString *b) {\n    return compareStringObjects(a,b);\n}\n\n/* Return the (possibly modified in encoding) input 'str' object if\n * the string is unshared, otherwise NULL is returned. */\nRedisModuleString *moduleAssertUnsharedString(RedisModuleString *str) {\n    if (str->refcount != 1) {\n        serverLog(LL_WARNING,\n            \"Module attempted to use an in-place string modify operation \"\n            \"with a string referenced multiple times. Please check the code \"\n            \"for API usage correctness.\");\n        return NULL;\n    }\n    if (str->encoding == OBJ_ENCODING_EMBSTR) {\n        /* Note: here we \"leak\" the additional allocation that was\n         * used in order to store the embedded string in the object. */\n        str->ptr = sdsnewlen(str->ptr,sdslen(str->ptr));\n        str->encoding = OBJ_ENCODING_RAW;\n    } else if (str->encoding == OBJ_ENCODING_INT) {\n        /* Convert the string from integer to raw encoding. */\n        str->ptr = sdsfromlonglong((long)str->ptr);\n        str->encoding = OBJ_ENCODING_RAW;\n    }\n    return str;\n}\n\n/* Append the specified buffere to the string 'str'. The string must be a\n * string created by the user that is referenced only a single time, otherwise\n * REDISMODULE_ERR is returend and the operation is not performed. */\nint RM_StringAppendBuffer(RedisModuleCtx *ctx, RedisModuleString *str, const char *buf, size_t len) {\n    UNUSED(ctx);\n    str = moduleAssertUnsharedString(str);\n    if (str == NULL) return REDISMODULE_ERR;\n    str->ptr = sdscatlen(str->ptr,buf,len);\n    return REDISMODULE_OK;\n}\n\n/* --------------------------------------------------------------------------\n * Reply APIs\n *\n * Most functions always return REDISMODULE_OK so you can use it with\n * 'return' in order to return from the command implementation with:\n *\n *     if (... some condition ...)\n *         return RM_ReplyWithLongLong(ctx,mycount);\n * -------------------------------------------------------------------------- */\n\n/* Send an error about the number of arguments given to the command,\n * citing the command name in the error message.\n *\n * Example:\n *\n *     if (argc != 3) return RedisModule_WrongArity(ctx);\n */\nint RM_WrongArity(RedisModuleCtx *ctx) {\n    addReplyErrorFormat(ctx->client,\n        \"wrong number of arguments for '%s' command\",\n        (char*)ctx->client->argv[0]->ptr);\n    return REDISMODULE_OK;\n}\n\n/* Return the client object the `RM_Reply*` functions should target.\n * Normally this is just `ctx->client`, that is the client that called\n * the module command, however in the case of thread safe contexts there\n * is no directly associated client (since it would not be safe to access\n * the client from a thread), so instead the blocked client object referenced\n * in the thread safe context, has a fake client that we just use to accumulate\n * the replies. Later, when the client is unblocked, the accumulated replies\n * are appended to the actual client.\n *\n * The function returns the client pointer depending on the context, or\n * NULL if there is no potential client. This happens when we are in the\n * context of a thread safe context that was not initialized with a blocked\n * client object. */\nclient *moduleGetReplyClient(RedisModuleCtx *ctx) {\n    if (!(ctx->flags & REDISMODULE_CTX_THREAD_SAFE) && ctx->client)\n        return ctx->client;\n    if (ctx->blocked_client)\n        return ctx->blocked_client->reply_client;\n    return NULL;\n}\n\n/* Send an integer reply to the client, with the specified long long value.\n * The function always returns REDISMODULE_OK. */\nint RM_ReplyWithLongLong(RedisModuleCtx *ctx, long long ll) {\n    client *c = moduleGetReplyClient(ctx);\n    if (c == NULL) return REDISMODULE_OK;\n    addReplyLongLong(c,ll);\n    return REDISMODULE_OK;\n}\n\n/* Reply with an error or simple string (status message). Used to implement\n * ReplyWithSimpleString() and ReplyWithError().\n * The function always returns REDISMODULE_OK. */\nint replyWithStatus(RedisModuleCtx *ctx, const char *msg, char *prefix) {\n    client *c = moduleGetReplyClient(ctx);\n    if (c == NULL) return REDISMODULE_OK;\n    sds strmsg = sdsnewlen(prefix,1);\n    strmsg = sdscat(strmsg,msg);\n    strmsg = sdscatlen(strmsg,\"\\r\\n\",2);\n    addReplySds(c,strmsg);\n    return REDISMODULE_OK;\n}\n\n/* Reply with the error 'err'.\n *\n * Note that 'err' must contain all the error, including\n * the initial error code. The function only provides the initial \"-\", so\n * the usage is, for example:\n *\n *     RedisModule_ReplyWithError(ctx,\"ERR Wrong Type\");\n *\n * and not just:\n *\n *     RedisModule_ReplyWithError(ctx,\"Wrong Type\");\n *\n * The function always returns REDISMODULE_OK.\n */\nint RM_ReplyWithError(RedisModuleCtx *ctx, const char *err) {\n    return replyWithStatus(ctx,err,\"-\");\n}\n\n/* Reply with a simple string (+... \\r\\n in RESP protocol). This replies\n * are suitable only when sending a small non-binary string with small\n * overhead, like \"OK\" or similar replies.\n *\n * The function always returns REDISMODULE_OK. */\nint RM_ReplyWithSimpleString(RedisModuleCtx *ctx, const char *msg) {\n    return replyWithStatus(ctx,msg,\"+\");\n}\n\n/* Reply with an array type of 'len' elements. However 'len' other calls\n * to `ReplyWith*` style functions must follow in order to emit the elements\n * of the array.\n *\n * When producing arrays with a number of element that is not known beforehand\n * the function can be called with the special count\n * REDISMODULE_POSTPONED_ARRAY_LEN, and the actual number of elements can be\n * later set with RedisModule_ReplySetArrayLength() (which will set the\n * latest \"open\" count if there are multiple ones).\n *\n * The function always returns REDISMODULE_OK. */\nint RM_ReplyWithArray(RedisModuleCtx *ctx, long len) {\n    client *c = moduleGetReplyClient(ctx);\n    if (c == NULL) return REDISMODULE_OK;\n    if (len == REDISMODULE_POSTPONED_ARRAY_LEN) {\n        ctx->postponed_arrays = zrealloc(ctx->postponed_arrays,sizeof(void*)*\n                (ctx->postponed_arrays_count+1));\n        ctx->postponed_arrays[ctx->postponed_arrays_count] =\n            addDeferredMultiBulkLength(c);\n        ctx->postponed_arrays_count++;\n    } else {\n        addReplyMultiBulkLen(c,len);\n    }\n    return REDISMODULE_OK;\n}\n\n/* When RedisModule_ReplyWithArray() is used with the argument\n * REDISMODULE_POSTPONED_ARRAY_LEN, because we don't know beforehand the number\n * of items we are going to output as elements of the array, this function\n * will take care to set the array length.\n *\n * Since it is possible to have multiple array replies pending with unknown\n * length, this function guarantees to always set the latest array length\n * that was created in a postponed way.\n *\n * For example in order to output an array like [1,[10,20,30]] we\n * could write:\n *\n *      RedisModule_ReplyWithArray(ctx,REDISMODULE_POSTPONED_ARRAY_LEN);\n *      RedisModule_ReplyWithLongLong(ctx,1);\n *      RedisModule_ReplyWithArray(ctx,REDISMODULE_POSTPONED_ARRAY_LEN);\n *      RedisModule_ReplyWithLongLong(ctx,10);\n *      RedisModule_ReplyWithLongLong(ctx,20);\n *      RedisModule_ReplyWithLongLong(ctx,30);\n *      RedisModule_ReplySetArrayLength(ctx,3); // Set len of 10,20,30 array.\n *      RedisModule_ReplySetArrayLength(ctx,2); // Set len of top array\n *\n * Note that in the above example there is no reason to postpone the array\n * length, since we produce a fixed number of elements, but in the practice\n * the code may use an interator or other ways of creating the output so\n * that is not easy to calculate in advance the number of elements.\n */\nvoid RM_ReplySetArrayLength(RedisModuleCtx *ctx, long len) {\n    client *c = moduleGetReplyClient(ctx);\n    if (c == NULL) return;\n    if (ctx->postponed_arrays_count == 0) {\n        serverLog(LL_WARNING,\n            \"API misuse detected in module %s: \"\n            \"RedisModule_ReplySetArrayLength() called without previous \"\n            \"RedisModule_ReplyWithArray(ctx,REDISMODULE_POSTPONED_ARRAY_LEN) \"\n            \"call.\", ctx->module->name);\n            return;\n    }\n    ctx->postponed_arrays_count--;\n    setDeferredMultiBulkLength(c,\n            ctx->postponed_arrays[ctx->postponed_arrays_count],\n            len);\n    if (ctx->postponed_arrays_count == 0) {\n        zfree(ctx->postponed_arrays);\n        ctx->postponed_arrays = NULL;\n    }\n}\n\n/* Reply with a bulk string, taking in input a C buffer pointer and length.\n *\n * The function always returns REDISMODULE_OK. */\nint RM_ReplyWithStringBuffer(RedisModuleCtx *ctx, const char *buf, size_t len) {\n    client *c = moduleGetReplyClient(ctx);\n    if (c == NULL) return REDISMODULE_OK;\n    addReplyBulkCBuffer(c,(char*)buf,len);\n    return REDISMODULE_OK;\n}\n\n/* Reply with a bulk string, taking in input a RedisModuleString object.\n *\n * The function always returns REDISMODULE_OK. */\nint RM_ReplyWithString(RedisModuleCtx *ctx, RedisModuleString *str) {\n    client *c = moduleGetReplyClient(ctx);\n    if (c == NULL) return REDISMODULE_OK;\n    addReplyBulk(c,str);\n    return REDISMODULE_OK;\n}\n\n/* Reply to the client with a NULL. In the RESP protocol a NULL is encoded\n * as the string \"$-1\\r\\n\".\n *\n * The function always returns REDISMODULE_OK. */\nint RM_ReplyWithNull(RedisModuleCtx *ctx) {\n    client *c = moduleGetReplyClient(ctx);\n    if (c == NULL) return REDISMODULE_OK;\n    addReply(c,shared.nullbulk);\n    return REDISMODULE_OK;\n}\n\n/* Reply exactly what a Redis command returned us with RedisModule_Call().\n * This function is useful when we use RedisModule_Call() in order to\n * execute some command, as we want to reply to the client exactly the\n * same reply we obtained by the command.\n *\n * The function always returns REDISMODULE_OK. */\nint RM_ReplyWithCallReply(RedisModuleCtx *ctx, RedisModuleCallReply *reply) {\n    client *c = moduleGetReplyClient(ctx);\n    if (c == NULL) return REDISMODULE_OK;\n    sds proto = sdsnewlen(reply->proto, reply->protolen);\n    addReplySds(c,proto);\n    return REDISMODULE_OK;\n}\n\n/* Send a string reply obtained converting the double 'd' into a bulk string.\n * This function is basically equivalent to converting a double into\n * a string into a C buffer, and then calling the function\n * RedisModule_ReplyWithStringBuffer() with the buffer and length.\n *\n * The function always returns REDISMODULE_OK. */\nint RM_ReplyWithDouble(RedisModuleCtx *ctx, double d) {\n    client *c = moduleGetReplyClient(ctx);\n    if (c == NULL) return REDISMODULE_OK;\n    addReplyDouble(c,d);\n    return REDISMODULE_OK;\n}\n\n/* --------------------------------------------------------------------------\n * Commands replication API\n * -------------------------------------------------------------------------- */\n\n/* Helper function to replicate MULTI the first time we replicate something\n * in the context of a command execution. EXEC will be handled by the\n * RedisModuleCommandDispatcher() function. */\nvoid moduleReplicateMultiIfNeeded(RedisModuleCtx *ctx) {\n    /* Skip this if client explicitly wrap the command with MULTI, or if\n     * the module command was called by a script. */\n    if (ctx->client->flags & (CLIENT_MULTI|CLIENT_LUA)) return;\n    /* If we already emitted MULTI return ASAP. */\n    if (ctx->flags & REDISMODULE_CTX_MULTI_EMITTED) return;\n    /* If this is a thread safe context, we do not want to wrap commands\n     * executed into MUTLI/EXEC, they are executed as single commands\n     * from an external client in essence. */\n    if (ctx->flags & REDISMODULE_CTX_THREAD_SAFE) return;\n    execCommandPropagateMulti(ctx->client);\n    ctx->flags |= REDISMODULE_CTX_MULTI_EMITTED;\n}\n\n/* Replicate the specified command and arguments to slaves and AOF, as effect\n * of execution of the calling command implementation.\n *\n * The replicated commands are always wrapped into the MULTI/EXEC that\n * contains all the commands replicated in a given module command\n * execution. However the commands replicated with RedisModule_Call()\n * are the first items, the ones replicated with RedisModule_Replicate()\n * will all follow before the EXEC.\n *\n * Modules should try to use one interface or the other.\n *\n * This command follows exactly the same interface of RedisModule_Call(),\n * so a set of format specifiers must be passed, followed by arguments\n * matching the provided format specifiers.\n *\n * Please refer to RedisModule_Call() for more information.\n *\n * The command returns REDISMODULE_ERR if the format specifiers are invalid\n * or the command name does not belong to a known command. */\nint RM_Replicate(RedisModuleCtx *ctx, const char *cmdname, const char *fmt, ...) {\n    struct redisCommand *cmd;\n    robj **argv = NULL;\n    int argc = 0, flags = 0, j;\n    va_list ap;\n\n    cmd = lookupCommandByCString((char*)cmdname);\n    if (!cmd) return REDISMODULE_ERR;\n\n    /* Create the client and dispatch the command. */\n    va_start(ap, fmt);\n    argv = moduleCreateArgvFromUserFormat(cmdname,fmt,&argc,&flags,ap);\n    va_end(ap);\n    if (argv == NULL) return REDISMODULE_ERR;\n\n    /* Replicate! */\n    moduleReplicateMultiIfNeeded(ctx);\n    alsoPropagate(cmd,ctx->client->db->id,argv,argc,\n        PROPAGATE_AOF|PROPAGATE_REPL);\n\n    /* Release the argv. */\n    for (j = 0; j < argc; j++) decrRefCount(argv[j]);\n    zfree(argv);\n    server.dirty++;\n    return REDISMODULE_OK;\n}\n\n/* This function will replicate the command exactly as it was invoked\n * by the client. Note that this function will not wrap the command into\n * a MULTI/EXEC stanza, so it should not be mixed with other replication\n * commands.\n *\n * Basically this form of replication is useful when you want to propagate\n * the command to the slaves and AOF file exactly as it was called, since\n * the command can just be re-executed to deterministically re-create the\n * new state starting from the old one.\n *\n * The function always returns REDISMODULE_OK. */\nint RM_ReplicateVerbatim(RedisModuleCtx *ctx) {\n    alsoPropagate(ctx->client->cmd,ctx->client->db->id,\n        ctx->client->argv,ctx->client->argc,\n        PROPAGATE_AOF|PROPAGATE_REPL);\n    server.dirty++;\n    return REDISMODULE_OK;\n}\n\n/* --------------------------------------------------------------------------\n * DB and Key APIs -- Generic API\n * -------------------------------------------------------------------------- */\n\n/* Return the ID of the current client calling the currently active module\n * command. The returned ID has a few guarantees:\n *\n * 1. The ID is different for each different client, so if the same client\n *    executes a module command multiple times, it can be recognized as\n *    having the same ID, otherwise the ID will be different.\n * 2. The ID increases monotonically. Clients connecting to the server later\n *    are guaranteed to get IDs greater than any past ID previously seen.\n *\n * Valid IDs are from 1 to 2^64-1. If 0 is returned it means there is no way\n * to fetch the ID in the context the function was currently called. */\nunsigned long long RM_GetClientId(RedisModuleCtx *ctx) {\n    if (ctx->client == NULL) return 0;\n    return ctx->client->id;\n}\n\n/* Return the currently selected DB. */\nint RM_GetSelectedDb(RedisModuleCtx *ctx) {\n    return ctx->client->db->id;\n}\n\n\n/* Return the current context's flags. The flags provide information on the \n * current request context (whether the client is a Lua script or in a MULTI),\n * and about the Redis instance in general, i.e replication and persistence. \n * \n * The available flags are:\n * \n *  * REDISMODULE_CTX_FLAGS_LUA: The command is running in a Lua script\n * \n *  * REDISMODULE_CTX_FLAGS_MULTI: The command is running inside a transaction\n * \n *  * REDISMODULE_CTX_FLAGS_MASTER: The Redis instance is a master\n * \n *  * REDISMODULE_CTX_FLAGS_SLAVE: The Redis instance is a slave\n * \n *  * REDISMODULE_CTX_FLAGS_READONLY: The Redis instance is read-only\n * \n *  * REDISMODULE_CTX_FLAGS_CLUSTER: The Redis instance is in cluster mode\n * \n *  * REDISMODULE_CTX_FLAGS_AOF: The Redis instance has AOF enabled\n * \n *  * REDISMODULE_CTX_FLAGS_RDB: The instance has RDB enabled\n * \n *  * REDISMODULE_CTX_FLAGS_MAXMEMORY:  The instance has Maxmemory set\n * \n *  * REDISMODULE_CTX_FLAGS_EVICT:  Maxmemory is set and has an eviction\n *    policy that may delete keys\n */\nint RM_GetContextFlags(RedisModuleCtx *ctx) {\n    \n    int flags = 0;\n    /* Client specific flags */\n    if (ctx->client) {\n        if (ctx->client->flags & CLIENT_LUA) \n         flags |= REDISMODULE_CTX_FLAGS_LUA;\n        if (ctx->client->flags & CLIENT_MULTI) \n         flags |= REDISMODULE_CTX_FLAGS_MULTI;\n    }\n\n    if (server.cluster_enabled)\n        flags |= REDISMODULE_CTX_FLAGS_CLUSTER;\n    \n    /* Maxmemory and eviction policy */\n    if (server.maxmemory > 0) {\n        flags |= REDISMODULE_CTX_FLAGS_MAXMEMORY;\n        \n        if (server.maxmemory_policy != MAXMEMORY_NO_EVICTION)\n            flags |= REDISMODULE_CTX_FLAGS_EVICT;\n    }\n\n    /* Persistence flags */\n    if (server.aof_state != AOF_OFF)\n        flags |= REDISMODULE_CTX_FLAGS_AOF;\n    if (server.saveparamslen > 0)\n        flags |= REDISMODULE_CTX_FLAGS_RDB;\n\n    /* Replication flags */\n    if (server.masterhost == NULL) {\n        flags |= REDISMODULE_CTX_FLAGS_MASTER;\n    } else {\n        flags |= REDISMODULE_CTX_FLAGS_SLAVE;\n        if (server.repl_slave_ro)\n            flags |= REDISMODULE_CTX_FLAGS_READONLY;\n    }\n    \n    return flags;\n}\n\n/* Change the currently selected DB. Returns an error if the id\n * is out of range.\n *\n * Note that the client will retain the currently selected DB even after\n * the Redis command implemented by the module calling this function\n * returns.\n *\n * If the module command wishes to change something in a different DB and\n * returns back to the original one, it should call RedisModule_GetSelectedDb()\n * before in order to restore the old DB number before returning. */\nint RM_SelectDb(RedisModuleCtx *ctx, int newid) {\n    int retval = selectDb(ctx->client,newid);\n    return (retval == C_OK) ? REDISMODULE_OK : REDISMODULE_ERR;\n}\n\n/* Return an handle representing a Redis key, so that it is possible\n * to call other APIs with the key handle as argument to perform\n * operations on the key.\n *\n * The return value is the handle repesenting the key, that must be\n * closed with RM_CloseKey().\n *\n * If the key does not exist and WRITE mode is requested, the handle\n * is still returned, since it is possible to perform operations on\n * a yet not existing key (that will be created, for example, after\n * a list push operation). If the mode is just READ instead, and the\n * key does not exist, NULL is returned. However it is still safe to\n * call RedisModule_CloseKey() and RedisModule_KeyType() on a NULL\n * value. */\nvoid *RM_OpenKey(RedisModuleCtx *ctx, robj *keyname, int mode) {\n    RedisModuleKey *kp;\n    robj *value;\n\n    if (mode & REDISMODULE_WRITE) {\n        value = lookupKeyWrite(ctx->client->db,keyname);\n    } else {\n        value = lookupKeyRead(ctx->client->db,keyname);\n        if (value == NULL) {\n            return NULL;\n        }\n    }\n\n    /* Setup the key handle. */\n    kp = zmalloc(sizeof(*kp));\n    kp->ctx = ctx;\n    kp->db = ctx->client->db;\n    kp->key = keyname;\n    incrRefCount(keyname);\n    kp->value = value;\n    kp->iter = NULL;\n    kp->mode = mode;\n    zsetKeyReset(kp);\n    autoMemoryAdd(ctx,REDISMODULE_AM_KEY,kp);\n    return (void*)kp;\n}\n\n/* Close a key handle. */\nvoid RM_CloseKey(RedisModuleKey *key) {\n    if (key == NULL) return;\n    if (key->mode & REDISMODULE_WRITE) signalModifiedKey(key->db,key->key);\n    /* TODO: if (key->iter) RM_KeyIteratorStop(kp); */\n    RM_ZsetRangeStop(key);\n    decrRefCount(key->key);\n    autoMemoryFreed(key->ctx,REDISMODULE_AM_KEY,key);\n    zfree(key);\n}\n\n/* Return the type of the key. If the key pointer is NULL then\n * REDISMODULE_KEYTYPE_EMPTY is returned. */\nint RM_KeyType(RedisModuleKey *key) {\n    if (key == NULL || key->value ==  NULL) return REDISMODULE_KEYTYPE_EMPTY;\n    /* We map between defines so that we are free to change the internal\n     * defines as desired. */\n    switch(key->value->type) {\n    case OBJ_STRING: return REDISMODULE_KEYTYPE_STRING;\n    case OBJ_LIST: return REDISMODULE_KEYTYPE_LIST;\n    case OBJ_SET: return REDISMODULE_KEYTYPE_SET;\n    case OBJ_ZSET: return REDISMODULE_KEYTYPE_ZSET;\n    case OBJ_HASH: return REDISMODULE_KEYTYPE_HASH;\n    case OBJ_MODULE: return REDISMODULE_KEYTYPE_MODULE;\n    default: return 0;\n    }\n}\n\n/* Return the length of the value associated with the key.\n * For strings this is the length of the string. For all the other types\n * is the number of elements (just counting keys for hashes).\n *\n * If the key pointer is NULL or the key is empty, zero is returned. */\nsize_t RM_ValueLength(RedisModuleKey *key) {\n    if (key == NULL || key->value == NULL) return 0;\n    switch(key->value->type) {\n    case OBJ_STRING: return stringObjectLen(key->value);\n    case OBJ_LIST: return listTypeLength(key->value);\n    case OBJ_SET: return setTypeSize(key->value);\n    case OBJ_ZSET: return zsetLength(key->value);\n    case OBJ_HASH: return hashTypeLength(key->value);\n    default: return 0;\n    }\n}\n\n/* If the key is open for writing, remove it, and setup the key to\n * accept new writes as an empty key (that will be created on demand).\n * On success REDISMODULE_OK is returned. If the key is not open for\n * writing REDISMODULE_ERR is returned. */\nint RM_DeleteKey(RedisModuleKey *key) {\n    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;\n    if (key->value) {\n        dbDelete(key->db,key->key);\n        key->value = NULL;\n    }\n    return REDISMODULE_OK;\n}\n\n/* If the key is open for writing, unlink it (that is delete it in a \n * non-blocking way, not reclaiming memory immediately) and setup the key to\n * accept new writes as an empty key (that will be created on demand).\n * On success REDISMODULE_OK is returned. If the key is not open for\n * writing REDISMODULE_ERR is returned. */\nint RM_UnlinkKey(RedisModuleKey *key) {\n    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;\n    if (key->value) {\n        dbAsyncDelete(key->db,key->key);\n        key->value = NULL;\n    }\n    return REDISMODULE_OK;\n}\n\n/* Return the key expire value, as milliseconds of remaining TTL.\n * If no TTL is associated with the key or if the key is empty,\n * REDISMODULE_NO_EXPIRE is returned. */\nmstime_t RM_GetExpire(RedisModuleKey *key) {\n    mstime_t expire = getExpire(key->db,key->key);\n    if (expire == -1 || key->value == NULL) return -1;\n    expire -= mstime();\n    return expire >= 0 ? expire : 0;\n}\n\n/* Set a new expire for the key. If the special expire\n * REDISMODULE_NO_EXPIRE is set, the expire is cancelled if there was\n * one (the same as the PERSIST command).\n *\n * Note that the expire must be provided as a positive integer representing\n * the number of milliseconds of TTL the key should have.\n *\n * The function returns REDISMODULE_OK on success or REDISMODULE_ERR if\n * the key was not open for writing or is an empty key. */\nint RM_SetExpire(RedisModuleKey *key, mstime_t expire) {\n    if (!(key->mode & REDISMODULE_WRITE) || key->value == NULL)\n        return REDISMODULE_ERR;\n    if (expire != REDISMODULE_NO_EXPIRE) {\n        expire += mstime();\n        setExpire(key->ctx->client,key->db,key->key,expire);\n    } else {\n        removeExpire(key->db,key->key);\n    }\n    return REDISMODULE_OK;\n}\n\n/* --------------------------------------------------------------------------\n * Key API for String type\n * -------------------------------------------------------------------------- */\n\n/* If the key is open for writing, set the specified string 'str' as the\n * value of the key, deleting the old value if any.\n * On success REDISMODULE_OK is returned. If the key is not open for\n * writing or there is an active iterator, REDISMODULE_ERR is returned. */\nint RM_StringSet(RedisModuleKey *key, RedisModuleString *str) {\n    if (!(key->mode & REDISMODULE_WRITE) || key->iter) return REDISMODULE_ERR;\n    RM_DeleteKey(key);\n    setKey(key->db,key->key,str);\n    key->value = str;\n    return REDISMODULE_OK;\n}\n\n/* Prepare the key associated string value for DMA access, and returns\n * a pointer and size (by reference), that the user can use to read or\n * modify the string in-place accessing it directly via pointer.\n *\n * The 'mode' is composed by bitwise OR-ing the following flags:\n *\n *     REDISMODULE_READ -- Read access\n *     REDISMODULE_WRITE -- Write access\n *\n * If the DMA is not requested for writing, the pointer returned should\n * only be accessed in a read-only fashion.\n *\n * On error (wrong type) NULL is returned.\n *\n * DMA access rules:\n *\n * 1. No other key writing function should be called since the moment\n * the pointer is obtained, for all the time we want to use DMA access\n * to read or modify the string.\n *\n * 2. Each time RM_StringTruncate() is called, to continue with the DMA\n * access, RM_StringDMA() should be called again to re-obtain\n * a new pointer and length.\n *\n * 3. If the returned pointer is not NULL, but the length is zero, no\n * byte can be touched (the string is empty, or the key itself is empty)\n * so a RM_StringTruncate() call should be used if there is to enlarge\n * the string, and later call StringDMA() again to get the pointer.\n */\nchar *RM_StringDMA(RedisModuleKey *key, size_t *len, int mode) {\n    /* We need to return *some* pointer for empty keys, we just return\n     * a string literal pointer, that is the advantage to be mapped into\n     * a read only memory page, so the module will segfault if a write\n     * attempt is performed. */\n    char *emptystring = \"<dma-empty-string>\";\n    if (key->value == NULL) {\n        *len = 0;\n        return emptystring;\n    }\n\n    if (key->value->type != OBJ_STRING) return NULL;\n\n    /* For write access, and even for read access if the object is encoded,\n     * we unshare the string (that has the side effect of decoding it). */\n    if ((mode & REDISMODULE_WRITE) || key->value->encoding != OBJ_ENCODING_RAW)\n        key->value = dbUnshareStringValue(key->db, key->key, key->value);\n\n    *len = sdslen(key->value->ptr);\n    return key->value->ptr;\n}\n\n/* If the string is open for writing and is of string type, resize it, padding\n * with zero bytes if the new length is greater than the old one.\n *\n * After this call, RM_StringDMA() must be called again to continue\n * DMA access with the new pointer.\n *\n * The function returns REDISMODULE_OK on success, and REDISMODULE_ERR on\n * error, that is, the key is not open for writing, is not a string\n * or resizing for more than 512 MB is requested.\n *\n * If the key is empty, a string key is created with the new string value\n * unless the new length value requested is zero. */\nint RM_StringTruncate(RedisModuleKey *key, size_t newlen) {\n    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;\n    if (key->value && key->value->type != OBJ_STRING) return REDISMODULE_ERR;\n    if (newlen > 512*1024*1024) return REDISMODULE_ERR;\n\n    /* Empty key and new len set to 0. Just return REDISMODULE_OK without\n     * doing anything. */\n    if (key->value == NULL && newlen == 0) return REDISMODULE_OK;\n\n    if (key->value == NULL) {\n        /* Empty key: create it with the new size. */\n        robj *o = createObject(OBJ_STRING,sdsnewlen(NULL, newlen));\n        setKey(key->db,key->key,o);\n        key->value = o;\n        decrRefCount(o);\n    } else {\n        /* Unshare and resize. */\n        key->value = dbUnshareStringValue(key->db, key->key, key->value);\n        size_t curlen = sdslen(key->value->ptr);\n        if (newlen > curlen) {\n            key->value->ptr = sdsgrowzero(key->value->ptr,newlen);\n        } else if (newlen < curlen) {\n            sdsrange(key->value->ptr,0,newlen-1);\n            /* If the string is too wasteful, reallocate it. */\n            if (sdslen(key->value->ptr) < sdsavail(key->value->ptr))\n                key->value->ptr = sdsRemoveFreeSpace(key->value->ptr);\n        }\n    }\n    return REDISMODULE_OK;\n}\n\n/* --------------------------------------------------------------------------\n * Key API for List type\n * -------------------------------------------------------------------------- */\n\n/* Push an element into a list, on head or tail depending on 'where' argumnet.\n * If the key pointer is about an empty key opened for writing, the key\n * is created. On error (key opened for read-only operations or of the wrong\n * type) REDISMODULE_ERR is returned, otherwise REDISMODULE_OK is returned. */\nint RM_ListPush(RedisModuleKey *key, int where, RedisModuleString *ele) {\n    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;\n    if (key->value && key->value->type != OBJ_LIST) return REDISMODULE_ERR;\n    if (key->value == NULL) moduleCreateEmptyKey(key,REDISMODULE_KEYTYPE_LIST);\n    listTypePush(key->value, ele,\n        (where == REDISMODULE_LIST_HEAD) ? QUICKLIST_HEAD : QUICKLIST_TAIL);\n    return REDISMODULE_OK;\n}\n\n/* Pop an element from the list, and returns it as a module string object\n * that the user should be free with RM_FreeString() or by enabling\n * automatic memory. 'where' specifies if the element should be popped from\n * head or tail. The command returns NULL if:\n * 1) The list is empty.\n * 2) The key was not open for writing.\n * 3) The key is not a list. */\nRedisModuleString *RM_ListPop(RedisModuleKey *key, int where) {\n    if (!(key->mode & REDISMODULE_WRITE) ||\n        key->value == NULL ||\n        key->value->type != OBJ_LIST) return NULL;\n    robj *ele = listTypePop(key->value,\n        (where == REDISMODULE_LIST_HEAD) ? QUICKLIST_HEAD : QUICKLIST_TAIL);\n    robj *decoded = getDecodedObject(ele);\n    decrRefCount(ele);\n    moduleDelKeyIfEmpty(key);\n    autoMemoryAdd(key->ctx,REDISMODULE_AM_STRING,decoded);\n    return decoded;\n}\n\n/* --------------------------------------------------------------------------\n * Key API for Sorted Set type\n * -------------------------------------------------------------------------- */\n\n/* Conversion from/to public flags of the Modules API and our private flags,\n * so that we have everything decoupled. */\nint RM_ZsetAddFlagsToCoreFlags(int flags) {\n    int retflags = 0;\n    if (flags & REDISMODULE_ZADD_XX) retflags |= ZADD_XX;\n    if (flags & REDISMODULE_ZADD_NX) retflags |= ZADD_NX;\n    return retflags;\n}\n\n/* See previous function comment. */\nint RM_ZsetAddFlagsFromCoreFlags(int flags) {\n    int retflags = 0;\n    if (flags & ZADD_ADDED) retflags |= REDISMODULE_ZADD_ADDED;\n    if (flags & ZADD_UPDATED) retflags |= REDISMODULE_ZADD_UPDATED;\n    if (flags & ZADD_NOP) retflags |= REDISMODULE_ZADD_NOP;\n    return retflags;\n}\n\n/* Add a new element into a sorted set, with the specified 'score'.\n * If the element already exists, the score is updated.\n *\n * A new sorted set is created at value if the key is an empty open key\n * setup for writing.\n *\n * Additional flags can be passed to the function via a pointer, the flags\n * are both used to receive input and to communicate state when the function\n * returns. 'flagsptr' can be NULL if no special flags are used.\n *\n * The input flags are:\n *\n *     REDISMODULE_ZADD_XX: Element must already exist. Do nothing otherwise.\n *     REDISMODULE_ZADD_NX: Element must not exist. Do nothing otherwise.\n *\n * The output flags are:\n *\n *     REDISMODULE_ZADD_ADDED: The new element was added to the sorted set.\n *     REDISMODULE_ZADD_UPDATED: The score of the element was updated.\n *     REDISMODULE_ZADD_NOP: No operation was performed because XX or NX flags.\n *\n * On success the function returns REDISMODULE_OK. On the following errors\n * REDISMODULE_ERR is returned:\n *\n * * The key was not opened for writing.\n * * The key is of the wrong type.\n * * 'score' double value is not a number (NaN).\n */\nint RM_ZsetAdd(RedisModuleKey *key, double score, RedisModuleString *ele, int *flagsptr) {\n    int flags = 0;\n    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;\n    if (key->value && key->value->type != OBJ_ZSET) return REDISMODULE_ERR;\n    if (key->value == NULL) moduleCreateEmptyKey(key,REDISMODULE_KEYTYPE_ZSET);\n    if (flagsptr) flags = RM_ZsetAddFlagsToCoreFlags(*flagsptr);\n    if (zsetAdd(key->value,score,ele->ptr,&flags,NULL) == 0) {\n        if (flagsptr) *flagsptr = 0;\n        return REDISMODULE_ERR;\n    }\n    if (flagsptr) *flagsptr = RM_ZsetAddFlagsFromCoreFlags(flags);\n    return REDISMODULE_OK;\n}\n\n/* This function works exactly like RM_ZsetAdd(), but instead of setting\n * a new score, the score of the existing element is incremented, or if the\n * element does not already exist, it is added assuming the old score was\n * zero.\n *\n * The input and output flags, and the return value, have the same exact\n * meaning, with the only difference that this function will return\n * REDISMODULE_ERR even when 'score' is a valid double number, but adding it\n * to the existing score resuts into a NaN (not a number) condition.\n *\n * This function has an additional field 'newscore', if not NULL is filled\n * with the new score of the element after the increment, if no error\n * is returned. */\nint RM_ZsetIncrby(RedisModuleKey *key, double score, RedisModuleString *ele, int *flagsptr, double *newscore) {\n    int flags = 0;\n    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;\n    if (key->value && key->value->type != OBJ_ZSET) return REDISMODULE_ERR;\n    if (key->value == NULL) moduleCreateEmptyKey(key,REDISMODULE_KEYTYPE_ZSET);\n    if (flagsptr) flags = RM_ZsetAddFlagsToCoreFlags(*flagsptr);\n    flags |= ZADD_INCR;\n    if (zsetAdd(key->value,score,ele->ptr,&flags,newscore) == 0) {\n        if (flagsptr) *flagsptr = 0;\n        return REDISMODULE_ERR;\n    }\n    /* zsetAdd() may signal back that the resulting score is not a number. */\n    if (flagsptr && (*flagsptr & ZADD_NAN)) {\n        *flagsptr = 0;\n        return REDISMODULE_ERR;\n    }\n    if (flagsptr) *flagsptr = RM_ZsetAddFlagsFromCoreFlags(flags);\n    return REDISMODULE_OK;\n}\n\n/* Remove the specified element from the sorted set.\n * The function returns REDISMODULE_OK on success, and REDISMODULE_ERR\n * on one of the following conditions:\n *\n * * The key was not opened for writing.\n * * The key is of the wrong type.\n *\n * The return value does NOT indicate the fact the element was really\n * removed (since it existed) or not, just if the function was executed\n * with success.\n *\n * In order to know if the element was removed, the additional argument\n * 'deleted' must be passed, that populates the integer by reference\n * setting it to 1 or 0 depending on the outcome of the operation.\n * The 'deleted' argument can be NULL if the caller is not interested\n * to know if the element was really removed.\n *\n * Empty keys will be handled correctly by doing nothing. */\nint RM_ZsetRem(RedisModuleKey *key, RedisModuleString *ele, int *deleted) {\n    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;\n    if (key->value && key->value->type != OBJ_ZSET) return REDISMODULE_ERR;\n    if (key->value != NULL && zsetDel(key->value,ele->ptr)) {\n        if (deleted) *deleted = 1;\n    } else {\n        if (deleted) *deleted = 0;\n    }\n    return REDISMODULE_OK;\n}\n\n/* On success retrieve the double score associated at the sorted set element\n * 'ele' and returns REDISMODULE_OK. Otherwise REDISMODULE_ERR is returned\n * to signal one of the following conditions:\n *\n * * There is no such element 'ele' in the sorted set.\n * * The key is not a sorted set.\n * * The key is an open empty key.\n */\nint RM_ZsetScore(RedisModuleKey *key, RedisModuleString *ele, double *score) {\n    if (key->value == NULL) return REDISMODULE_ERR;\n    if (key->value->type != OBJ_ZSET) return REDISMODULE_ERR;\n    if (zsetScore(key->value,ele->ptr,score) == C_ERR) return REDISMODULE_ERR;\n    return REDISMODULE_OK;\n}\n\n/* --------------------------------------------------------------------------\n * Key API for Sorted Set iterator\n * -------------------------------------------------------------------------- */\n\nvoid zsetKeyReset(RedisModuleKey *key) {\n    key->ztype = REDISMODULE_ZSET_RANGE_NONE;\n    key->zcurrent = NULL;\n    key->zer = 1;\n}\n\n/* Stop a sorted set iteration. */\nvoid RM_ZsetRangeStop(RedisModuleKey *key) {\n    /* Free resources if needed. */\n    if (key->ztype == REDISMODULE_ZSET_RANGE_LEX)\n        zslFreeLexRange(&key->zlrs);\n    /* Setup sensible values so that misused iteration API calls when an\n     * iterator is not active will result into something more sensible\n     * than crashing. */\n    zsetKeyReset(key);\n}\n\n/* Return the \"End of range\" flag value to signal the end of the iteration. */\nint RM_ZsetRangeEndReached(RedisModuleKey *key) {\n    return key->zer;\n}\n\n/* Helper function for RM_ZsetFirstInScoreRange() and RM_ZsetLastInScoreRange().\n * Setup the sorted set iteration according to the specified score range\n * (see the functions calling it for more info). If 'first' is true the\n * first element in the range is used as a starting point for the iterator\n * otherwise the last. Return REDISMODULE_OK on success otherwise\n * REDISMODULE_ERR. */\nint zsetInitScoreRange(RedisModuleKey *key, double min, double max, int minex, int maxex, int first) {\n    if (!key->value || key->value->type != OBJ_ZSET) return REDISMODULE_ERR;\n\n    RM_ZsetRangeStop(key);\n    key->ztype = REDISMODULE_ZSET_RANGE_SCORE;\n    key->zer = 0;\n\n    /* Setup the range structure used by the sorted set core implementation\n     * in order to seek at the specified element. */\n    zrangespec *zrs = &key->zrs;\n    zrs->min = min;\n    zrs->max = max;\n    zrs->minex = minex;\n    zrs->maxex = maxex;\n\n    if (key->value->encoding == OBJ_ENCODING_ZIPLIST) {\n        key->zcurrent = first ? zzlFirstInRange(key->value->ptr,zrs) :\n                                zzlLastInRange(key->value->ptr,zrs);\n    } else if (key->value->encoding == OBJ_ENCODING_SKIPLIST) {\n        zset *zs = key->value->ptr;\n        zskiplist *zsl = zs->zsl;\n        key->zcurrent = first ? zslFirstInRange(zsl,zrs) :\n                                zslLastInRange(zsl,zrs);\n    } else {\n        serverPanic(\"Unsupported zset encoding\");\n    }\n    if (key->zcurrent == NULL) key->zer = 1;\n    return REDISMODULE_OK;\n}\n\n/* Setup a sorted set iterator seeking the first element in the specified\n * range. Returns REDISMODULE_OK if the iterator was correctly initialized\n * otherwise REDISMODULE_ERR is returned in the following conditions:\n *\n * 1. The value stored at key is not a sorted set or the key is empty.\n *\n * The range is specified according to the two double values 'min' and 'max'.\n * Both can be infinite using the following two macros:\n *\n * REDISMODULE_POSITIVE_INFINITE for positive infinite value\n * REDISMODULE_NEGATIVE_INFINITE for negative infinite value\n *\n * 'minex' and 'maxex' parameters, if true, respectively setup a range\n * where the min and max value are exclusive (not included) instead of\n * inclusive. */\nint RM_ZsetFirstInScoreRange(RedisModuleKey *key, double min, double max, int minex, int maxex) {\n    return zsetInitScoreRange(key,min,max,minex,maxex,1);\n}\n\n/* Exactly like RedisModule_ZsetFirstInScoreRange() but the last element of\n * the range is selected for the start of the iteration instead. */\nint RM_ZsetLastInScoreRange(RedisModuleKey *key, double min, double max, int minex, int maxex) {\n    return zsetInitScoreRange(key,min,max,minex,maxex,0);\n}\n\n/* Helper function for RM_ZsetFirstInLexRange() and RM_ZsetLastInLexRange().\n * Setup the sorted set iteration according to the specified lexicographical\n * range (see the functions calling it for more info). If 'first' is true the\n * first element in the range is used as a starting point for the iterator\n * otherwise the last. Return REDISMODULE_OK on success otherwise\n * REDISMODULE_ERR.\n *\n * Note that this function takes 'min' and 'max' in the same form of the\n * Redis ZRANGEBYLEX command. */\nint zsetInitLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max, int first) {\n    if (!key->value || key->value->type != OBJ_ZSET) return REDISMODULE_ERR;\n\n    RM_ZsetRangeStop(key);\n    key->zer = 0;\n\n    /* Setup the range structure used by the sorted set core implementation\n     * in order to seek at the specified element. */\n    zlexrangespec *zlrs = &key->zlrs;\n    if (zslParseLexRange(min, max, zlrs) == C_ERR) return REDISMODULE_ERR;\n\n    /* Set the range type to lex only after successfully parsing the range,\n     * otherwise we don't want the zlexrangespec to be freed. */\n    key->ztype = REDISMODULE_ZSET_RANGE_LEX;\n\n    if (key->value->encoding == OBJ_ENCODING_ZIPLIST) {\n        key->zcurrent = first ? zzlFirstInLexRange(key->value->ptr,zlrs) :\n                                zzlLastInLexRange(key->value->ptr,zlrs);\n    } else if (key->value->encoding == OBJ_ENCODING_SKIPLIST) {\n        zset *zs = key->value->ptr;\n        zskiplist *zsl = zs->zsl;\n        key->zcurrent = first ? zslFirstInLexRange(zsl,zlrs) :\n                                zslLastInLexRange(zsl,zlrs);\n    } else {\n        serverPanic(\"Unsupported zset encoding\");\n    }\n    if (key->zcurrent == NULL) key->zer = 1;\n\n    return REDISMODULE_OK;\n}\n\n/* Setup a sorted set iterator seeking the first element in the specified\n * lexicographical range. Returns REDISMODULE_OK if the iterator was correctly\n * initialized otherwise REDISMODULE_ERR is returned in the\n * following conditions:\n *\n * 1. The value stored at key is not a sorted set or the key is empty.\n * 2. The lexicographical range 'min' and 'max' format is invalid.\n *\n * 'min' and 'max' should be provided as two RedisModuleString objects\n * in the same format as the parameters passed to the ZRANGEBYLEX command.\n * The function does not take ownership of the objects, so they can be released\n * ASAP after the iterator is setup. */\nint RM_ZsetFirstInLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max) {\n    return zsetInitLexRange(key,min,max,1);\n}\n\n/* Exactly like RedisModule_ZsetFirstInLexRange() but the last element of\n * the range is selected for the start of the iteration instead. */\nint RM_ZsetLastInLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max) {\n    return zsetInitLexRange(key,min,max,0);\n}\n\n/* Return the current sorted set element of an active sorted set iterator\n * or NULL if the range specified in the iterator does not include any\n * element. */\nRedisModuleString *RM_ZsetRangeCurrentElement(RedisModuleKey *key, double *score) {\n    RedisModuleString *str;\n\n    if (key->zcurrent == NULL) return NULL;\n    if (key->value->encoding == OBJ_ENCODING_ZIPLIST) {\n        unsigned char *eptr, *sptr;\n        eptr = key->zcurrent;\n        sds ele = ziplistGetObject(eptr);\n        if (score) {\n            sptr = ziplistNext(key->value->ptr,eptr);\n            *score = zzlGetScore(sptr);\n        }\n        str = createObject(OBJ_STRING,ele);\n    } else if (key->value->encoding == OBJ_ENCODING_SKIPLIST) {\n        zskiplistNode *ln = key->zcurrent;\n        if (score) *score = ln->score;\n        str = createStringObject(ln->ele,sdslen(ln->ele));\n    } else {\n        serverPanic(\"Unsupported zset encoding\");\n    }\n    autoMemoryAdd(key->ctx,REDISMODULE_AM_STRING,str);\n    return str;\n}\n\n/* Go to the next element of the sorted set iterator. Returns 1 if there was\n * a next element, 0 if we are already at the latest element or the range\n * does not include any item at all. */\nint RM_ZsetRangeNext(RedisModuleKey *key) {\n    if (!key->ztype || !key->zcurrent) return 0; /* No active iterator. */\n\n    if (key->value->encoding == OBJ_ENCODING_ZIPLIST) {\n        unsigned char *zl = key->value->ptr;\n        unsigned char *eptr = key->zcurrent;\n        unsigned char *next;\n        next = ziplistNext(zl,eptr); /* Skip element. */\n        if (next) next = ziplistNext(zl,next); /* Skip score. */\n        if (next == NULL) {\n            key->zer = 1;\n            return 0;\n        } else {\n            /* Are we still within the range? */\n            if (key->ztype == REDISMODULE_ZSET_RANGE_SCORE) {\n                /* Fetch the next element score for the\n                 * range check. */\n                unsigned char *saved_next = next;\n                next = ziplistNext(zl,next); /* Skip next element. */\n                double score = zzlGetScore(next); /* Obtain the next score. */\n                if (!zslValueLteMax(score,&key->zrs)) {\n                    key->zer = 1;\n                    return 0;\n                }\n                next = saved_next;\n            } else if (key->ztype == REDISMODULE_ZSET_RANGE_LEX) {\n                if (!zzlLexValueLteMax(next,&key->zlrs)) {\n                    key->zer = 1;\n                    return 0;\n                }\n            }\n            key->zcurrent = next;\n            return 1;\n        }\n    } else if (key->value->encoding == OBJ_ENCODING_SKIPLIST) {\n        zskiplistNode *ln = key->zcurrent, *next = ln->level[0].forward;\n        if (next == NULL) {\n            key->zer = 1;\n            return 0;\n        } else {\n            /* Are we still within the range? */\n            if (key->ztype == REDISMODULE_ZSET_RANGE_SCORE &&\n                !zslValueLteMax(next->score,&key->zrs))\n            {\n                key->zer = 1;\n                return 0;\n            } else if (key->ztype == REDISMODULE_ZSET_RANGE_LEX) {\n                if (!zslLexValueLteMax(next->ele,&key->zlrs)) {\n                    key->zer = 1;\n                    return 0;\n                }\n            }\n            key->zcurrent = next;\n            return 1;\n        }\n    } else {\n        serverPanic(\"Unsupported zset encoding\");\n    }\n}\n\n/* Go to the previous element of the sorted set iterator. Returns 1 if there was\n * a previous element, 0 if we are already at the first element or the range\n * does not include any item at all. */\nint RM_ZsetRangePrev(RedisModuleKey *key) {\n    if (!key->ztype || !key->zcurrent) return 0; /* No active iterator. */\n\n    if (key->value->encoding == OBJ_ENCODING_ZIPLIST) {\n        unsigned char *zl = key->value->ptr;\n        unsigned char *eptr = key->zcurrent;\n        unsigned char *prev;\n        prev = ziplistPrev(zl,eptr); /* Go back to previous score. */\n        if (prev) prev = ziplistPrev(zl,prev); /* Back to previous ele. */\n        if (prev == NULL) {\n            key->zer = 1;\n            return 0;\n        } else {\n            /* Are we still within the range? */\n            if (key->ztype == REDISMODULE_ZSET_RANGE_SCORE) {\n                /* Fetch the previous element score for the\n                 * range check. */\n                unsigned char *saved_prev = prev;\n                prev = ziplistNext(zl,prev); /* Skip element to get the score.*/\n                double score = zzlGetScore(prev); /* Obtain the prev score. */\n                if (!zslValueGteMin(score,&key->zrs)) {\n                    key->zer = 1;\n                    return 0;\n                }\n                prev = saved_prev;\n            } else if (key->ztype == REDISMODULE_ZSET_RANGE_LEX) {\n                if (!zzlLexValueGteMin(prev,&key->zlrs)) {\n                    key->zer = 1;\n                    return 0;\n                }\n            }\n            key->zcurrent = prev;\n            return 1;\n        }\n    } else if (key->value->encoding == OBJ_ENCODING_SKIPLIST) {\n        zskiplistNode *ln = key->zcurrent, *prev = ln->backward;\n        if (prev == NULL) {\n            key->zer = 1;\n            return 0;\n        } else {\n            /* Are we still within the range? */\n            if (key->ztype == REDISMODULE_ZSET_RANGE_SCORE &&\n                !zslValueGteMin(prev->score,&key->zrs))\n            {\n                key->zer = 1;\n                return 0;\n            } else if (key->ztype == REDISMODULE_ZSET_RANGE_LEX) {\n                if (!zslLexValueGteMin(prev->ele,&key->zlrs)) {\n                    key->zer = 1;\n                    return 0;\n                }\n            }\n            key->zcurrent = prev;\n            return 1;\n        }\n    } else {\n        serverPanic(\"Unsupported zset encoding\");\n    }\n}\n\n/* --------------------------------------------------------------------------\n * Key API for Hash type\n * -------------------------------------------------------------------------- */\n\n/* Set the field of the specified hash field to the specified value.\n * If the key is an empty key open for writing, it is created with an empty\n * hash value, in order to set the specified field.\n *\n * The function is variadic and the user must specify pairs of field\n * names and values, both as RedisModuleString pointers (unless the\n * CFIELD option is set, see later).\n *\n * Example to set the hash argv[1] to the value argv[2]:\n *\n *      RedisModule_HashSet(key,REDISMODULE_HASH_NONE,argv[1],argv[2],NULL);\n *\n * The function can also be used in order to delete fields (if they exist)\n * by setting them to the specified value of REDISMODULE_HASH_DELETE:\n *\n *      RedisModule_HashSet(key,REDISMODULE_HASH_NONE,argv[1],\n *                          REDISMODULE_HASH_DELETE,NULL);\n *\n * The behavior of the command changes with the specified flags, that can be\n * set to REDISMODULE_HASH_NONE if no special behavior is needed.\n *\n *     REDISMODULE_HASH_NX: The operation is performed only if the field was not\n *                          already existing in the hash.\n *     REDISMODULE_HASH_XX: The operation is performed only if the field was\n *                          already existing, so that a new value could be\n *                          associated to an existing filed, but no new fields\n *                          are created.\n *     REDISMODULE_HASH_CFIELDS: The field names passed are null terminated C\n *                               strings instead of RedisModuleString objects.\n *\n * Unless NX is specified, the command overwrites the old field value with\n * the new one.\n *\n * When using REDISMODULE_HASH_CFIELDS, field names are reported using\n * normal C strings, so for example to delete the field \"foo\" the following\n * code can be used:\n *\n *      RedisModule_HashSet(key,REDISMODULE_HASH_CFIELDS,\"foo\",\n *                          REDISMODULE_HASH_DELETE,NULL);\n *\n * Return value:\n *\n * The number of fields updated (that may be less than the number of fields\n * specified because of the XX or NX options).\n *\n * In the following case the return value is always zero:\n *\n * * The key was not open for writing.\n * * The key was associated with a non Hash value.\n */\nint RM_HashSet(RedisModuleKey *key, int flags, ...) {\n    va_list ap;\n    if (!(key->mode & REDISMODULE_WRITE)) return 0;\n    if (key->value && key->value->type != OBJ_HASH) return 0;\n    if (key->value == NULL) moduleCreateEmptyKey(key,REDISMODULE_KEYTYPE_HASH);\n\n    int updated = 0;\n    va_start(ap, flags);\n    while(1) {\n        RedisModuleString *field, *value;\n        /* Get the field and value objects. */\n        if (flags & REDISMODULE_HASH_CFIELDS) {\n            char *cfield = va_arg(ap,char*);\n            if (cfield == NULL) break;\n            field = createRawStringObject(cfield,strlen(cfield));\n        } else {\n            field = va_arg(ap,RedisModuleString*);\n            if (field == NULL) break;\n        }\n        value = va_arg(ap,RedisModuleString*);\n\n        /* Handle XX and NX */\n        if (flags & (REDISMODULE_HASH_XX|REDISMODULE_HASH_NX)) {\n            int exists = hashTypeExists(key->value, field->ptr);\n            if (((flags & REDISMODULE_HASH_XX) && !exists) ||\n                ((flags & REDISMODULE_HASH_NX) && exists))\n            {\n                if (flags & REDISMODULE_HASH_CFIELDS) decrRefCount(field);\n                continue;\n            }\n        }\n\n        /* Handle deletion if value is REDISMODULE_HASH_DELETE. */\n        if (value == REDISMODULE_HASH_DELETE) {\n            updated += hashTypeDelete(key->value, field->ptr);\n            if (flags & REDISMODULE_HASH_CFIELDS) decrRefCount(field);\n            continue;\n        }\n\n        int low_flags = HASH_SET_COPY;\n        /* If CFIELDS is active, we can pass the ownership of the\n         * SDS object to the low level function that sets the field\n         * to avoid a useless copy. */\n        if (flags & REDISMODULE_HASH_CFIELDS)\n            low_flags |= HASH_SET_TAKE_FIELD;\n        updated += hashTypeSet(key->value, field->ptr, value->ptr, low_flags);\n\n        /* If CFIELDS is active, SDS string ownership is now of hashTypeSet(),\n         * however we still have to release the 'field' object shell. */\n        if (flags & REDISMODULE_HASH_CFIELDS) {\n           field->ptr = NULL; /* Prevent the SDS string from being freed. */\n           decrRefCount(field);\n        }\n    }\n    va_end(ap);\n    moduleDelKeyIfEmpty(key);\n    return updated;\n}\n\n/* Get fields from an hash value. This function is called using a variable\n * number of arguments, alternating a field name (as a StringRedisModule\n * pointer) with a pointer to a StringRedisModule pointer, that is set to the\n * value of the field if the field exist, or NULL if the field did not exist.\n * At the end of the field/value-ptr pairs, NULL must be specified as last\n * argument to signal the end of the arguments in the variadic function.\n *\n * This is an example usage:\n *\n *      RedisModuleString *first, *second;\n *      RedisModule_HashGet(mykey,REDISMODULE_HASH_NONE,argv[1],&first,\n *                      argv[2],&second,NULL);\n *\n * As with RedisModule_HashSet() the behavior of the command can be specified\n * passing flags different than REDISMODULE_HASH_NONE:\n *\n * REDISMODULE_HASH_CFIELD: field names as null terminated C strings.\n *\n * REDISMODULE_HASH_EXISTS: instead of setting the value of the field\n * expecting a RedisModuleString pointer to pointer, the function just\n * reports if the field esists or not and expects an integer pointer\n * as the second element of each pair.\n *\n * Example of REDISMODULE_HASH_CFIELD:\n *\n *      RedisModuleString *username, *hashedpass;\n *      RedisModule_HashGet(mykey,\"username\",&username,\"hp\",&hashedpass, NULL);\n *\n * Example of REDISMODULE_HASH_EXISTS:\n *\n *      int exists;\n *      RedisModule_HashGet(mykey,argv[1],&exists,NULL);\n *\n * The function returns REDISMODULE_OK on success and REDISMODULE_ERR if\n * the key is not an hash value.\n *\n * Memory management:\n *\n * The returned RedisModuleString objects should be released with\n * RedisModule_FreeString(), or by enabling automatic memory management.\n */\nint RM_HashGet(RedisModuleKey *key, int flags, ...) {\n    va_list ap;\n    if (key->value && key->value->type != OBJ_HASH) return REDISMODULE_ERR;\n\n    va_start(ap, flags);\n    while(1) {\n        RedisModuleString *field, **valueptr;\n        int *existsptr;\n        /* Get the field object and the value pointer to pointer. */\n        if (flags & REDISMODULE_HASH_CFIELDS) {\n            char *cfield = va_arg(ap,char*);\n            if (cfield == NULL) break;\n            field = createRawStringObject(cfield,strlen(cfield));\n        } else {\n            field = va_arg(ap,RedisModuleString*);\n            if (field == NULL) break;\n        }\n\n        /* Query the hash for existence or value object. */\n        if (flags & REDISMODULE_HASH_EXISTS) {\n            existsptr = va_arg(ap,int*);\n            if (key->value)\n                *existsptr = hashTypeExists(key->value,field->ptr);\n            else\n                *existsptr = 0;\n        } else {\n            valueptr = va_arg(ap,RedisModuleString**);\n            if (key->value) {\n                *valueptr = hashTypeGetValueObject(key->value,field->ptr);\n                if (*valueptr) {\n                    robj *decoded = getDecodedObject(*valueptr);\n                    decrRefCount(*valueptr);\n                    *valueptr = decoded;\n                }\n                if (*valueptr)\n                    autoMemoryAdd(key->ctx,REDISMODULE_AM_STRING,*valueptr);\n            } else {\n                *valueptr = NULL;\n            }\n        }\n\n        /* Cleanup */\n        if (flags & REDISMODULE_HASH_CFIELDS) decrRefCount(field);\n    }\n    va_end(ap);\n    return REDISMODULE_OK;\n}\n\n/* --------------------------------------------------------------------------\n * Redis <-> Modules generic Call() API\n * -------------------------------------------------------------------------- */\n\n/* Create a new RedisModuleCallReply object. The processing of the reply\n * is lazy, the object is just populated with the raw protocol and later\n * is processed as needed. Initially we just make sure to set the right\n * reply type, which is extremely cheap to do. */\nRedisModuleCallReply *moduleCreateCallReplyFromProto(RedisModuleCtx *ctx, sds proto) {\n    RedisModuleCallReply *reply = zmalloc(sizeof(*reply));\n    reply->ctx = ctx;\n    reply->proto = proto;\n    reply->protolen = sdslen(proto);\n    reply->flags = REDISMODULE_REPLYFLAG_TOPARSE; /* Lazy parsing. */\n    switch(proto[0]) {\n    case '$':\n    case '+': reply->type = REDISMODULE_REPLY_STRING; break;\n    case '-': reply->type = REDISMODULE_REPLY_ERROR; break;\n    case ':': reply->type = REDISMODULE_REPLY_INTEGER; break;\n    case '*': reply->type = REDISMODULE_REPLY_ARRAY; break;\n    default: reply->type = REDISMODULE_REPLY_UNKNOWN; break;\n    }\n    if ((proto[0] == '*' || proto[0] == '$') && proto[1] == '-')\n        reply->type = REDISMODULE_REPLY_NULL;\n    return reply;\n}\n\nvoid moduleParseCallReply_Int(RedisModuleCallReply *reply);\nvoid moduleParseCallReply_BulkString(RedisModuleCallReply *reply);\nvoid moduleParseCallReply_SimpleString(RedisModuleCallReply *reply);\nvoid moduleParseCallReply_Array(RedisModuleCallReply *reply);\n\n/* Do nothing if REDISMODULE_REPLYFLAG_TOPARSE is false, otherwise\n * use the protcol of the reply in reply->proto in order to fill the\n * reply with parsed data according to the reply type. */\nvoid moduleParseCallReply(RedisModuleCallReply *reply) {\n    if (!(reply->flags & REDISMODULE_REPLYFLAG_TOPARSE)) return;\n    reply->flags &= ~REDISMODULE_REPLYFLAG_TOPARSE;\n\n    switch(reply->proto[0]) {\n    case ':': moduleParseCallReply_Int(reply); break;\n    case '$': moduleParseCallReply_BulkString(reply); break;\n    case '-': /* handled by next item. */\n    case '+': moduleParseCallReply_SimpleString(reply); break;\n    case '*': moduleParseCallReply_Array(reply); break;\n    }\n}\n\nvoid moduleParseCallReply_Int(RedisModuleCallReply *reply) {\n    char *proto = reply->proto;\n    char *p = strchr(proto+1,'\\r');\n\n    string2ll(proto+1,p-proto-1,&reply->val.ll);\n    reply->protolen = p-proto+2;\n    reply->type = REDISMODULE_REPLY_INTEGER;\n}\n\nvoid moduleParseCallReply_BulkString(RedisModuleCallReply *reply) {\n    char *proto = reply->proto;\n    char *p = strchr(proto+1,'\\r');\n    long long bulklen;\n\n    string2ll(proto+1,p-proto-1,&bulklen);\n    if (bulklen == -1) {\n        reply->protolen = p-proto+2;\n        reply->type = REDISMODULE_REPLY_NULL;\n    } else {\n        reply->val.str = p+2;\n        reply->len = bulklen;\n        reply->protolen = p-proto+2+bulklen+2;\n        reply->type = REDISMODULE_REPLY_STRING;\n    }\n}\n\nvoid moduleParseCallReply_SimpleString(RedisModuleCallReply *reply) {\n    char *proto = reply->proto;\n    char *p = strchr(proto+1,'\\r');\n\n    reply->val.str = proto+1;\n    reply->len = p-proto-1;\n    reply->protolen = p-proto+2;\n    reply->type = proto[0] == '+' ? REDISMODULE_REPLY_STRING :\n                                    REDISMODULE_REPLY_ERROR;\n}\n\nvoid moduleParseCallReply_Array(RedisModuleCallReply *reply) {\n    char *proto = reply->proto;\n    char *p = strchr(proto+1,'\\r');\n    long long arraylen, j;\n\n    string2ll(proto+1,p-proto-1,&arraylen);\n    p += 2;\n\n    if (arraylen == -1) {\n        reply->protolen = p-proto;\n        reply->type = REDISMODULE_REPLY_NULL;\n        return;\n    }\n\n    reply->val.array = zmalloc(sizeof(RedisModuleCallReply)*arraylen);\n    reply->len = arraylen;\n    for (j = 0; j < arraylen; j++) {\n        RedisModuleCallReply *ele = reply->val.array+j;\n        ele->flags = REDISMODULE_REPLYFLAG_NESTED |\n                     REDISMODULE_REPLYFLAG_TOPARSE;\n        ele->proto = p;\n        ele->ctx = reply->ctx;\n        moduleParseCallReply(ele);\n        p += ele->protolen;\n    }\n    reply->protolen = p-proto;\n    reply->type = REDISMODULE_REPLY_ARRAY;\n}\n\n/* Free a Call reply and all the nested replies it contains if it's an\n * array. */\nvoid RM_FreeCallReply_Rec(RedisModuleCallReply *reply, int freenested){\n    /* Don't free nested replies by default: the user must always free the\n     * toplevel reply. However be gentle and don't crash if the module\n     * misuses the API. */\n    if (!freenested && reply->flags & REDISMODULE_REPLYFLAG_NESTED) return;\n\n    if (!(reply->flags & REDISMODULE_REPLYFLAG_TOPARSE)) {\n        if (reply->type == REDISMODULE_REPLY_ARRAY) {\n            size_t j;\n            for (j = 0; j < reply->len; j++)\n                RM_FreeCallReply_Rec(reply->val.array+j,1);\n            zfree(reply->val.array);\n        }\n    }\n\n    /* For nested replies, we don't free reply->proto (which if not NULL\n     * references the parent reply->proto buffer), nor the structure\n     * itself which is allocated as an array of structures, and is freed\n     * when the array value is released. */\n    if (!(reply->flags & REDISMODULE_REPLYFLAG_NESTED)) {\n        if (reply->proto) sdsfree(reply->proto);\n        zfree(reply);\n    }\n}\n\n/* Wrapper for the recursive free reply function. This is needed in order\n * to have the first level function to return on nested replies, but only\n * if called by the module API. */\nvoid RM_FreeCallReply(RedisModuleCallReply *reply) {\n\n    RedisModuleCtx *ctx = reply->ctx;\n    RM_FreeCallReply_Rec(reply,0);\n    autoMemoryFreed(ctx,REDISMODULE_AM_REPLY,reply);\n}\n\n/* Return the reply type. */\nint RM_CallReplyType(RedisModuleCallReply *reply) {\n    if (!reply) return REDISMODULE_REPLY_UNKNOWN;\n    return reply->type;\n}\n\n/* Return the reply type length, where applicable. */\nsize_t RM_CallReplyLength(RedisModuleCallReply *reply) {\n    moduleParseCallReply(reply);\n    switch(reply->type) {\n    case REDISMODULE_REPLY_STRING:\n    case REDISMODULE_REPLY_ERROR:\n    case REDISMODULE_REPLY_ARRAY:\n        return reply->len;\n    default:\n        return 0;\n    }\n}\n\n/* Return the 'idx'-th nested call reply element of an array reply, or NULL\n * if the reply type is wrong or the index is out of range. */\nRedisModuleCallReply *RM_CallReplyArrayElement(RedisModuleCallReply *reply, size_t idx) {\n    moduleParseCallReply(reply);\n    if (reply->type != REDISMODULE_REPLY_ARRAY) return NULL;\n    if (idx >= reply->len) return NULL;\n    return reply->val.array+idx;\n}\n\n/* Return the long long of an integer reply. */\nlong long RM_CallReplyInteger(RedisModuleCallReply *reply) {\n    moduleParseCallReply(reply);\n    if (reply->type != REDISMODULE_REPLY_INTEGER) return LLONG_MIN;\n    return reply->val.ll;\n}\n\n/* Return the pointer and length of a string or error reply. */\nconst char *RM_CallReplyStringPtr(RedisModuleCallReply *reply, size_t *len) {\n    moduleParseCallReply(reply);\n    if (reply->type != REDISMODULE_REPLY_STRING &&\n        reply->type != REDISMODULE_REPLY_ERROR) return NULL;\n    if (len) *len = reply->len;\n    return reply->val.str;\n}\n\n/* Return a new string object from a call reply of type string, error or\n * integer. Otherwise (wrong reply type) return NULL. */\nRedisModuleString *RM_CreateStringFromCallReply(RedisModuleCallReply *reply) {\n    moduleParseCallReply(reply);\n    switch(reply->type) {\n    case REDISMODULE_REPLY_STRING:\n    case REDISMODULE_REPLY_ERROR:\n        return RM_CreateString(reply->ctx,reply->val.str,reply->len);\n    case REDISMODULE_REPLY_INTEGER: {\n        char buf[64];\n        int len = ll2string(buf,sizeof(buf),reply->val.ll);\n        return RM_CreateString(reply->ctx,buf,len);\n        }\n    default: return NULL;\n    }\n}\n\n/* Returns an array of robj pointers, and populates *argc with the number\n * of items, by parsing the format specifier \"fmt\" as described for\n * the RM_Call(), RM_Replicate() and other module APIs.\n *\n * The integer pointed by 'flags' is populated with flags according\n * to special modifiers in \"fmt\". For now only one exists:\n *\n *     \"!\" -> REDISMODULE_ARGV_REPLICATE\n *\n * On error (format specifier error) NULL is returned and nothing is\n * allocated. On success the argument vector is returned. */\n\n#define REDISMODULE_ARGV_REPLICATE (1<<0)\n\nrobj **moduleCreateArgvFromUserFormat(const char *cmdname, const char *fmt, int *argcp, int *flags, va_list ap) {\n    int argc = 0, argv_size, j;\n    robj **argv = NULL;\n\n    /* As a first guess to avoid useless reallocations, size argv to\n     * hold one argument for each char specifier in 'fmt'. */\n    argv_size = strlen(fmt)+1; /* +1 because of the command name. */\n    argv = zrealloc(argv,sizeof(robj*)*argv_size);\n\n    /* Build the arguments vector based on the format specifier. */\n    argv[0] = createStringObject(cmdname,strlen(cmdname));\n    argc++;\n\n    /* Create the client and dispatch the command. */\n    const char *p = fmt;\n    while(*p) {\n        if (*p == 'c') {\n            char *cstr = va_arg(ap,char*);\n            argv[argc++] = createStringObject(cstr,strlen(cstr));\n        } else if (*p == 's') {\n            robj *obj = va_arg(ap,void*);\n            argv[argc++] = obj;\n            incrRefCount(obj);\n        } else if (*p == 'b') {\n            char *buf = va_arg(ap,char*);\n            size_t len = va_arg(ap,size_t);\n            argv[argc++] = createStringObject(buf,len);\n        } else if (*p == 'l') {\n            long ll = va_arg(ap,long long);\n            argv[argc++] = createObject(OBJ_STRING,sdsfromlonglong(ll));\n        } else if (*p == 'v') {\n             /* A vector of strings */\n             robj **v = va_arg(ap, void*);\n             size_t vlen = va_arg(ap, size_t);\n\n             /* We need to grow argv to hold the vector's elements.\n              * We resize by vector_len-1 elements, because we held\n              * one element in argv for the vector already */\n             argv_size += vlen-1;\n             argv = zrealloc(argv,sizeof(robj*)*argv_size);\n\n             size_t i = 0;\n             for (i = 0; i < vlen; i++) {\n                 incrRefCount(v[i]);\n                 argv[argc++] = v[i];\n             }\n        } else if (*p == '!') {\n            if (flags) (*flags) |= REDISMODULE_ARGV_REPLICATE;\n        } else {\n            goto fmterr;\n        }\n        p++;\n    }\n    *argcp = argc;\n    return argv;\n\nfmterr:\n    for (j = 0; j < argc; j++)\n        decrRefCount(argv[j]);\n    zfree(argv);\n    return NULL;\n}\n\n/* Exported API to call any Redis command from modules.\n * On success a RedisModuleCallReply object is returned, otherwise\n * NULL is returned and errno is set to the following values:\n *\n * EINVAL: command non existing, wrong arity, wrong format specifier.\n * EPERM:  operation in Cluster instance with key in non local slot. */\nRedisModuleCallReply *RM_Call(RedisModuleCtx *ctx, const char *cmdname, const char *fmt, ...) {\n    struct redisCommand *cmd;\n    client *c = NULL;\n    robj **argv = NULL;\n    int argc = 0, flags = 0;\n    va_list ap;\n    RedisModuleCallReply *reply = NULL;\n    int replicate = 0; /* Replicate this command? */\n\n    cmd = lookupCommandByCString((char*)cmdname);\n    if (!cmd) {\n        errno = EINVAL;\n        return NULL;\n    }\n\n    /* Create the client and dispatch the command. */\n    va_start(ap, fmt);\n    c = createClient(-1);\n    argv = moduleCreateArgvFromUserFormat(cmdname,fmt,&argc,&flags,ap);\n    replicate = flags & REDISMODULE_ARGV_REPLICATE;\n    va_end(ap);\n\n    /* Setup our fake client for command execution. */\n    c->flags |= CLIENT_MODULE;\n    c->db = ctx->client->db;\n    c->argv = argv;\n    c->argc = argc;\n    c->cmd = c->lastcmd = cmd;\n    /* We handle the above format error only when the client is setup so that\n     * we can free it normally. */\n    if (argv == NULL) goto cleanup;\n\n    /* Basic arity checks. */\n    if ((cmd->arity > 0 && cmd->arity != argc) || (argc < -cmd->arity)) {\n        errno = EINVAL;\n        goto cleanup;\n    }\n\n    /* If this is a Redis Cluster node, we need to make sure the module is not\n     * trying to access non-local keys, with the exception of commands\n     * received from our master. */\n    if (server.cluster_enabled && !(ctx->client->flags & CLIENT_MASTER)) {\n        /* Duplicate relevant flags in the module client. */\n        c->flags &= ~(CLIENT_READONLY|CLIENT_ASKING);\n        c->flags |= ctx->client->flags & (CLIENT_READONLY|CLIENT_ASKING);\n        if (getNodeByQuery(c,c->cmd,c->argv,c->argc,NULL,NULL) !=\n                           server.cluster->myself)\n        {\n            errno = EPERM;\n            goto cleanup;\n        }\n    }\n\n    /* If we are using single commands replication, we need to wrap what\n     * we propagate into a MULTI/EXEC block, so that it will be atomic like\n     * a Lua script in the context of AOF and slaves. */\n    if (replicate) moduleReplicateMultiIfNeeded(ctx);\n\n    /* Run the command */\n    int call_flags = CMD_CALL_SLOWLOG | CMD_CALL_STATS;\n    if (replicate) {\n        call_flags |= CMD_CALL_PROPAGATE_AOF;\n        call_flags |= CMD_CALL_PROPAGATE_REPL;\n    }\n    call(c,call_flags);\n\n    /* Convert the result of the Redis command into a suitable Lua type.\n     * The first thing we need is to create a single string from the client\n     * output buffers. */\n    sds proto = sdsnewlen(c->buf,c->bufpos);\n    c->bufpos = 0;\n    while(listLength(c->reply)) {\n        sds o = listNodeValue(listFirst(c->reply));\n\n        proto = sdscatsds(proto,o);\n        listDelNode(c->reply,listFirst(c->reply));\n    }\n    reply = moduleCreateCallReplyFromProto(ctx,proto);\n    autoMemoryAdd(ctx,REDISMODULE_AM_REPLY,reply);\n\ncleanup:\n    freeClient(c);\n    return reply;\n}\n\n/* Return a pointer, and a length, to the protocol returned by the command\n * that returned the reply object. */\nconst char *RM_CallReplyProto(RedisModuleCallReply *reply, size_t *len) {\n    if (reply->proto) *len = sdslen(reply->proto);\n    return reply->proto;\n}\n\n/* --------------------------------------------------------------------------\n * Modules data types\n *\n * When String DMA or using existing data structures is not enough, it is\n * possible to create new data types from scratch and export them to\n * Redis. The module must provide a set of callbacks for handling the\n * new values exported (for example in order to provide RDB saving/loading,\n * AOF rewrite, and so forth). In this section we define this API.\n * -------------------------------------------------------------------------- */\n\n/* Turn a 9 chars name in the specified charset and a 10 bit encver into\n * a single 64 bit unsigned integer that represents this exact module name\n * and version. This final number is called a \"type ID\" and is used when\n * writing module exported values to RDB files, in order to re-associate the\n * value to the right module to load them during RDB loading.\n *\n * If the string is not of the right length or the charset is wrong, or\n * if encver is outside the unsigned 10 bit integer range, 0 is returned,\n * otherwise the function returns the right type ID.\n *\n * The resulting 64 bit integer is composed as follows:\n *\n *     (high order bits) 6|6|6|6|6|6|6|6|6|10 (low order bits)\n *\n * The first 6 bits value is the first character, name[0], while the last\n * 6 bits value, immediately before the 10 bits integer, is name[8].\n * The last 10 bits are the encoding version.\n *\n * Note that a name and encver combo of \"AAAAAAAAA\" and 0, will produce\n * zero as return value, that is the same we use to signal errors, thus\n * this combination is invalid, and also useless since type names should\n * try to be vary to avoid collisions. */\n\nconst char *ModuleTypeNameCharSet =\n             \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n             \"abcdefghijklmnopqrstuvwxyz\"\n             \"0123456789-_\";\n\nuint64_t moduleTypeEncodeId(const char *name, int encver) {\n    /* We use 64 symbols so that we can map each character into 6 bits\n     * of the final output. */\n    const char *cset = ModuleTypeNameCharSet;\n    if (strlen(name) != 9) return 0;\n    if (encver < 0 || encver > 1023) return 0;\n\n    uint64_t id = 0;\n    for (int j = 0; j < 9; j++) {\n        char *p = strchr(cset,name[j]);\n        if (!p) return 0;\n        unsigned long pos = p-cset;\n        id = (id << 6) | pos;\n    }\n    id = (id << 10) | encver;\n    return id;\n}\n\n/* Search, in the list of exported data types of all the modules registered,\n * a type with the same name as the one given. Returns the moduleType\n * structure pointer if such a module is found, or NULL otherwise. */\nmoduleType *moduleTypeLookupModuleByName(const char *name) {\n    dictIterator *di = dictGetIterator(modules);\n    dictEntry *de;\n\n    while ((de = dictNext(di)) != NULL) {\n        struct RedisModule *module = dictGetVal(de);\n        listIter li;\n        listNode *ln;\n\n        listRewind(module->types,&li);\n        while((ln = listNext(&li))) {\n            moduleType *mt = ln->value;\n            if (memcmp(name,mt->name,sizeof(mt->name)) == 0) {\n                dictReleaseIterator(di);\n                return mt;\n            }\n        }\n    }\n    dictReleaseIterator(di);\n    return NULL;\n}\n\n/* Lookup a module by ID, with caching. This function is used during RDB\n * loading. Modules exporting data types should never be able to unload, so\n * our cache does not need to expire. */\n#define MODULE_LOOKUP_CACHE_SIZE 3\n\nmoduleType *moduleTypeLookupModuleByID(uint64_t id) {\n    static struct {\n        uint64_t id;\n        moduleType *mt;\n    } cache[MODULE_LOOKUP_CACHE_SIZE];\n\n    /* Search in cache to start. */\n    int j;\n    for (j = 0; j < MODULE_LOOKUP_CACHE_SIZE && cache[j].mt != NULL; j++)\n        if (cache[j].id == id) return cache[j].mt;\n\n    /* Slow module by module lookup. */\n    moduleType *mt = NULL;\n    dictIterator *di = dictGetIterator(modules);\n    dictEntry *de;\n\n    while ((de = dictNext(di)) != NULL && mt == NULL) {\n        struct RedisModule *module = dictGetVal(de);\n        listIter li;\n        listNode *ln;\n\n        listRewind(module->types,&li);\n        while((ln = listNext(&li))) {\n            moduleType *this_mt = ln->value;\n            /* Compare only the 54 bit module identifier and not the\n             * encoding version. */\n            if (this_mt->id >> 10 == id >> 10) {\n                mt = this_mt;\n                break;\n            }\n        }\n    }\n    dictReleaseIterator(di);\n\n    /* Add to cache if possible. */\n    if (mt && j < MODULE_LOOKUP_CACHE_SIZE) {\n        cache[j].id = id;\n        cache[j].mt = mt;\n    }\n    return mt;\n}\n\n/* Turn an (unresolved) module ID into a type name, to show the user an\n * error when RDB files contain module data we can't load.\n * The buffer pointed by 'name' must be 10 bytes at least. The function will\n * fill it with a null terminated module name. */\nvoid moduleTypeNameByID(char *name, uint64_t moduleid) {\n    const char *cset = ModuleTypeNameCharSet;\n\n    name[9] = '\\0';\n    char *p = name+8;\n    moduleid >>= 10;\n    for (int j = 0; j < 9; j++) {\n        *p-- = cset[moduleid & 63];\n        moduleid >>= 6;\n    }\n}\n\n/* Register a new data type exported by the module. The parameters are the\n * following. Please for in depth documentation check the modules API\n * documentation, especially the TYPES.md file.\n *\n * * **name**: A 9 characters data type name that MUST be unique in the Redis\n *   Modules ecosystem. Be creative... and there will be no collisions. Use\n *   the charset A-Z a-z 9-0, plus the two \"-_\" characters. A good\n *   idea is to use, for example `<typename>-<vendor>`. For example\n *   \"tree-AntZ\" may mean \"Tree data structure by @antirez\". To use both\n *   lower case and upper case letters helps in order to prevent collisions.\n * * **encver**: Encoding version, which is, the version of the serialization\n *   that a module used in order to persist data. As long as the \"name\"\n *   matches, the RDB loading will be dispatched to the type callbacks\n *   whatever 'encver' is used, however the module can understand if\n *   the encoding it must load are of an older version of the module.\n *   For example the module \"tree-AntZ\" initially used encver=0. Later\n *   after an upgrade, it started to serialize data in a different format\n *   and to register the type with encver=1. However this module may\n *   still load old data produced by an older version if the rdb_load\n *   callback is able to check the encver value and act accordingly.\n *   The encver must be a positive value between 0 and 1023.\n * * **typemethods_ptr** is a pointer to a RedisModuleTypeMethods structure\n *   that should be populated with the methods callbacks and structure\n *   version, like in the following example:\n *\n *      RedisModuleTypeMethods tm = {\n *          .version = REDISMODULE_TYPE_METHOD_VERSION,\n *          .rdb_load = myType_RDBLoadCallBack,\n *          .rdb_save = myType_RDBSaveCallBack,\n *          .aof_rewrite = myType_AOFRewriteCallBack,\n *          .free = myType_FreeCallBack,\n *\n *          // Optional fields\n *          .digest = myType_DigestCallBack,\n *          .mem_usage = myType_MemUsageCallBack,\n *      }\n *\n * * **rdb_load**: A callback function pointer that loads data from RDB files.\n * * **rdb_save**: A callback function pointer that saves data to RDB files.\n * * **aof_rewrite**: A callback function pointer that rewrites data as commands.\n * * **digest**: A callback function pointer that is used for `DEBUG DIGEST`.\n * * **free**: A callback function pointer that can free a type value.\n *\n * The **digest* and **mem_usage** methods should currently be omitted since\n * they are not yet implemented inside the Redis modules core.\n *\n * Note: the module name \"AAAAAAAAA\" is reserved and produces an error, it\n * happens to be pretty lame as well.\n *\n * If there is already a module registering a type with the same name,\n * and if the module name or encver is invalid, NULL is returned.\n * Otherwise the new type is registered into Redis, and a reference of\n * type RedisModuleType is returned: the caller of the function should store\n * this reference into a gobal variable to make future use of it in the\n * modules type API, since a single module may register multiple types.\n * Example code fragment:\n *\n *      static RedisModuleType *BalancedTreeType;\n *\n *      int RedisModule_OnLoad(RedisModuleCtx *ctx) {\n *          // some code here ...\n *          BalancedTreeType = RM_CreateDataType(...);\n *      }\n */\nmoduleType *RM_CreateDataType(RedisModuleCtx *ctx, const char *name, int encver, void *typemethods_ptr) {\n    uint64_t id = moduleTypeEncodeId(name,encver);\n    if (id == 0) return NULL;\n    if (moduleTypeLookupModuleByName(name) != NULL) return NULL;\n\n    long typemethods_version = ((long*)typemethods_ptr)[0];\n    if (typemethods_version == 0) return NULL;\n\n    struct typemethods {\n        uint64_t version;\n        moduleTypeLoadFunc rdb_load;\n        moduleTypeSaveFunc rdb_save;\n        moduleTypeRewriteFunc aof_rewrite;\n        moduleTypeMemUsageFunc mem_usage;\n        moduleTypeDigestFunc digest;\n        moduleTypeFreeFunc free;\n    } *tms = (struct typemethods*) typemethods_ptr;\n\n    moduleType *mt = zcalloc(sizeof(*mt));\n    mt->id = id;\n    mt->module = ctx->module;\n    mt->rdb_load = tms->rdb_load;\n    mt->rdb_save = tms->rdb_save;\n    mt->aof_rewrite = tms->aof_rewrite;\n    mt->mem_usage = tms->mem_usage;\n    mt->digest = tms->digest;\n    mt->free = tms->free;\n    memcpy(mt->name,name,sizeof(mt->name));\n    listAddNodeTail(ctx->module->types,mt);\n    return mt;\n}\n\n/* If the key is open for writing, set the specified module type object\n * as the value of the key, deleting the old value if any.\n * On success REDISMODULE_OK is returned. If the key is not open for\n * writing or there is an active iterator, REDISMODULE_ERR is returned. */\nint RM_ModuleTypeSetValue(RedisModuleKey *key, moduleType *mt, void *value) {\n    if (!(key->mode & REDISMODULE_WRITE) || key->iter) return REDISMODULE_ERR;\n    RM_DeleteKey(key);\n    robj *o = createModuleObject(mt,value);\n    setKey(key->db,key->key,o);\n    decrRefCount(o);\n    key->value = o;\n    return REDISMODULE_OK;\n}\n\n/* Assuming RedisModule_KeyType() returned REDISMODULE_KEYTYPE_MODULE on\n * the key, returns the moduel type pointer of the value stored at key.\n *\n * If the key is NULL, is not associated with a module type, or is empty,\n * then NULL is returned instead. */\nmoduleType *RM_ModuleTypeGetType(RedisModuleKey *key) {\n    if (key == NULL ||\n        key->value == NULL ||\n        RM_KeyType(key) != REDISMODULE_KEYTYPE_MODULE) return NULL;\n    moduleValue *mv = key->value->ptr;\n    return mv->type;\n}\n\n/* Assuming RedisModule_KeyType() returned REDISMODULE_KEYTYPE_MODULE on\n * the key, returns the module type low-level value stored at key, as\n * it was set by the user via RedisModule_ModuleTypeSet().\n *\n * If the key is NULL, is not associated with a module type, or is empty,\n * then NULL is returned instead. */\nvoid *RM_ModuleTypeGetValue(RedisModuleKey *key) {\n    if (key == NULL ||\n        key->value == NULL ||\n        RM_KeyType(key) != REDISMODULE_KEYTYPE_MODULE) return NULL;\n    moduleValue *mv = key->value->ptr;\n    return mv->value;\n}\n\n/* --------------------------------------------------------------------------\n * RDB loading and saving functions\n * -------------------------------------------------------------------------- */\n\n/* Called when there is a load error in the context of a module. This cannot\n * be recovered like for the built-in types. */\nvoid moduleRDBLoadError(RedisModuleIO *io) {\n    serverLog(LL_WARNING,\n        \"Error loading data from RDB (short read or EOF). \"\n        \"Read performed by module '%s' about type '%s' \"\n        \"after reading '%llu' bytes of a value.\",\n        io->type->module->name,\n        io->type->name,\n        (unsigned long long)io->bytes);\n    exit(1);\n}\n\n/* Save an unsigned 64 bit value into the RDB file. This function should only\n * be called in the context of the rdb_save method of modules implementing new\n * data types. */\nvoid RM_SaveUnsigned(RedisModuleIO *io, uint64_t value) {\n    if (io->error) return;\n    /* Save opcode. */\n    int retval = rdbSaveLen(io->rio, RDB_MODULE_OPCODE_UINT);\n    if (retval == -1) goto saveerr;\n    io->bytes += retval;\n    /* Save value. */\n    retval = rdbSaveLen(io->rio, value);\n    if (retval == -1) goto saveerr;\n    io->bytes += retval;\n    return;\n\nsaveerr:\n    io->error = 1;\n}\n\n/* Load an unsigned 64 bit value from the RDB file. This function should only\n * be called in the context of the rdb_load method of modules implementing\n * new data types. */\nuint64_t RM_LoadUnsigned(RedisModuleIO *io) {\n    if (io->ver == 2) {\n        uint64_t opcode = rdbLoadLen(io->rio,NULL);\n        if (opcode != RDB_MODULE_OPCODE_UINT) goto loaderr;\n    }\n    uint64_t value;\n    int retval = rdbLoadLenByRef(io->rio, NULL, &value);\n    if (retval == -1) goto loaderr;\n    return value;\n\nloaderr:\n    moduleRDBLoadError(io);\n    return 0; /* Never reached. */\n}\n\n/* Like RedisModule_SaveUnsigned() but for signed 64 bit values. */\nvoid RM_SaveSigned(RedisModuleIO *io, int64_t value) {\n    union {uint64_t u; int64_t i;} conv;\n    conv.i = value;\n    RM_SaveUnsigned(io,conv.u);\n}\n\n/* Like RedisModule_LoadUnsigned() but for signed 64 bit values. */\nint64_t RM_LoadSigned(RedisModuleIO *io) {\n    union {uint64_t u; int64_t i;} conv;\n    conv.u = RM_LoadUnsigned(io);\n    return conv.i;\n}\n\n/* In the context of the rdb_save method of a module type, saves a\n * string into the RDB file taking as input a RedisModuleString.\n *\n * The string can be later loaded with RedisModule_LoadString() or\n * other Load family functions expecting a serialized string inside\n * the RDB file. */\nvoid RM_SaveString(RedisModuleIO *io, RedisModuleString *s) {\n    if (io->error) return;\n    /* Save opcode. */\n    ssize_t retval = rdbSaveLen(io->rio, RDB_MODULE_OPCODE_STRING);\n    if (retval == -1) goto saveerr;\n    io->bytes += retval;\n    /* Save value. */\n    retval = rdbSaveStringObject(io->rio, s);\n    if (retval == -1) goto saveerr;\n    io->bytes += retval;\n    return;\n\nsaveerr:\n    io->error = 1;\n}\n\n/* Like RedisModule_SaveString() but takes a raw C pointer and length\n * as input. */\nvoid RM_SaveStringBuffer(RedisModuleIO *io, const char *str, size_t len) {\n    if (io->error) return;\n    /* Save opcode. */\n    ssize_t retval = rdbSaveLen(io->rio, RDB_MODULE_OPCODE_STRING);\n    if (retval == -1) goto saveerr;\n    io->bytes += retval;\n    /* Save value. */\n    retval = rdbSaveRawString(io->rio, (unsigned char*)str,len);\n    if (retval == -1) goto saveerr;\n    io->bytes += retval;\n    return;\n\nsaveerr:\n    io->error = 1;\n}\n\n/* Implements RM_LoadString() and RM_LoadStringBuffer() */\nvoid *moduleLoadString(RedisModuleIO *io, int plain, size_t *lenptr) {\n    if (io->ver == 2) {\n        uint64_t opcode = rdbLoadLen(io->rio,NULL);\n        if (opcode != RDB_MODULE_OPCODE_STRING) goto loaderr;\n    }\n    void *s = rdbGenericLoadStringObject(io->rio,\n              plain ? RDB_LOAD_PLAIN : RDB_LOAD_NONE, lenptr);\n    if (s == NULL) goto loaderr;\n    return s;\n\nloaderr:\n    moduleRDBLoadError(io);\n    return NULL; /* Never reached. */\n}\n\n/* In the context of the rdb_load method of a module data type, loads a string\n * from the RDB file, that was previously saved with RedisModule_SaveString()\n * functions family.\n *\n * The returned string is a newly allocated RedisModuleString object, and\n * the user should at some point free it with a call to RedisModule_FreeString().\n *\n * If the data structure does not store strings as RedisModuleString objects,\n * the similar function RedisModule_LoadStringBuffer() could be used instead. */\nRedisModuleString *RM_LoadString(RedisModuleIO *io) {\n    return moduleLoadString(io,0,NULL);\n}\n\n/* Like RedisModule_LoadString() but returns an heap allocated string that\n * was allocated with RedisModule_Alloc(), and can be resized or freed with\n * RedisModule_Realloc() or RedisModule_Free().\n *\n * The size of the string is stored at '*lenptr' if not NULL.\n * The returned string is not automatically NULL termianted, it is loaded\n * exactly as it was stored inisde the RDB file. */\nchar *RM_LoadStringBuffer(RedisModuleIO *io, size_t *lenptr) {\n    return moduleLoadString(io,1,lenptr);\n}\n\n/* In the context of the rdb_save method of a module data type, saves a double\n * value to the RDB file. The double can be a valid number, a NaN or infinity.\n * It is possible to load back the value with RedisModule_LoadDouble(). */\nvoid RM_SaveDouble(RedisModuleIO *io, double value) {\n    if (io->error) return;\n    /* Save opcode. */\n    int retval = rdbSaveLen(io->rio, RDB_MODULE_OPCODE_DOUBLE);\n    if (retval == -1) goto saveerr;\n    io->bytes += retval;\n    /* Save value. */\n    retval = rdbSaveBinaryDoubleValue(io->rio, value);\n    if (retval == -1) goto saveerr;\n    io->bytes += retval;\n    return;\n\nsaveerr:\n    io->error = 1;\n}\n\n/* In the context of the rdb_save method of a module data type, loads back the\n * double value saved by RedisModule_SaveDouble(). */\ndouble RM_LoadDouble(RedisModuleIO *io) {\n    if (io->ver == 2) {\n        uint64_t opcode = rdbLoadLen(io->rio,NULL);\n        if (opcode != RDB_MODULE_OPCODE_DOUBLE) goto loaderr;\n    }\n    double value;\n    int retval = rdbLoadBinaryDoubleValue(io->rio, &value);\n    if (retval == -1) goto loaderr;\n    return value;\n\nloaderr:\n    moduleRDBLoadError(io);\n    return 0; /* Never reached. */\n}\n\n/* In the context of the rdb_save method of a module data type, saves a float\n * value to the RDB file. The float can be a valid number, a NaN or infinity.\n * It is possible to load back the value with RedisModule_LoadFloat(). */\nvoid RM_SaveFloat(RedisModuleIO *io, float value) {\n    if (io->error) return;\n    /* Save opcode. */\n    int retval = rdbSaveLen(io->rio, RDB_MODULE_OPCODE_FLOAT);\n    if (retval == -1) goto saveerr;\n    io->bytes += retval;\n    /* Save value. */\n    retval = rdbSaveBinaryFloatValue(io->rio, value);\n    if (retval == -1) goto saveerr;\n    io->bytes += retval;\n    return;\n\nsaveerr:\n    io->error = 1;\n}\n\n/* In the context of the rdb_save method of a module data type, loads back the\n * float value saved by RedisModule_SaveFloat(). */\nfloat RM_LoadFloat(RedisModuleIO *io) {\n    if (io->ver == 2) {\n        uint64_t opcode = rdbLoadLen(io->rio,NULL);\n        if (opcode != RDB_MODULE_OPCODE_FLOAT) goto loaderr;\n    }\n    float value;\n    int retval = rdbLoadBinaryFloatValue(io->rio, &value);\n    if (retval == -1) goto loaderr;\n    return value;\n\nloaderr:\n    moduleRDBLoadError(io);\n    return 0; /* Never reached. */\n}\n\n/* --------------------------------------------------------------------------\n * Key digest API (DEBUG DIGEST interface for modules types)\n * -------------------------------------------------------------------------- */\n\n/* Add a new element to the digest. This function can be called multiple times\n * one element after the other, for all the elements that constitute a given\n * data structure. The function call must be followed by the call to\n * `RedisModule_DigestEndSequence` eventually, when all the elements that are\n * always in a given order are added. See the Redis Modules data types\n * documentation for more info. However this is a quick example that uses Redis\n * data types as an example.\n *\n * To add a sequence of unordered elements (for example in the case of a Redis\n * Set), the pattern to use is:\n *\n *     foreach element {\n *         AddElement(element);\n *         EndSequence();\n *     }\n *\n * Because Sets are not ordered, so every element added has a position that\n * does not depend from the other. However if instead our elements are\n * ordered in pairs, like field-value pairs of an Hash, then one should\n * use:\n *\n *     foreach key,value {\n *         AddElement(key);\n *         AddElement(value);\n *         EndSquence();\n *     }\n *\n * Because the key and value will be always in the above order, while instead\n * the single key-value pairs, can appear in any position into a Redis hash.\n *\n * A list of ordered elements would be implemented with:\n *\n *     foreach element {\n *         AddElement(element);\n *     }\n *     EndSequence();\n *\n */\nvoid RM_DigestAddStringBuffer(RedisModuleDigest *md, unsigned char *ele, size_t len) {\n    mixDigest(md->o,ele,len);\n}\n\n/* Like `RedisModule_DigestAddStringBuffer()` but takes a long long as input\n * that gets converted into a string before adding it to the digest. */\nvoid RM_DigestAddLongLong(RedisModuleDigest *md, long long ll) {\n    char buf[LONG_STR_SIZE];\n    size_t len = ll2string(buf,sizeof(buf),ll);\n    mixDigest(md->o,buf,len);\n}\n\n/* See the doucmnetation for `RedisModule_DigestAddElement()`. */\nvoid RM_DigestEndSequence(RedisModuleDigest *md) {\n    xorDigest(md->x,md->o,sizeof(md->o));\n    memset(md->o,0,sizeof(md->o));\n}\n\n/* --------------------------------------------------------------------------\n * AOF API for modules data types\n * -------------------------------------------------------------------------- */\n\n/* Emits a command into the AOF during the AOF rewriting process. This function\n * is only called in the context of the aof_rewrite method of data types exported\n * by a module. The command works exactly like RedisModule_Call() in the way\n * the parameters are passed, but it does not return anything as the error\n * handling is performed by Redis itself. */\nvoid RM_EmitAOF(RedisModuleIO *io, const char *cmdname, const char *fmt, ...) {\n    if (io->error) return;\n    struct redisCommand *cmd;\n    robj **argv = NULL;\n    int argc = 0, flags = 0, j;\n    va_list ap;\n\n    cmd = lookupCommandByCString((char*)cmdname);\n    if (!cmd) {\n        serverLog(LL_WARNING,\n            \"Fatal: AOF method for module data type '%s' tried to \"\n            \"emit unknown command '%s'\",\n            io->type->name, cmdname);\n        io->error = 1;\n        errno = EINVAL;\n        return;\n    }\n\n    /* Emit the arguments into the AOF in Redis protocol format. */\n    va_start(ap, fmt);\n    argv = moduleCreateArgvFromUserFormat(cmdname,fmt,&argc,&flags,ap);\n    va_end(ap);\n    if (argv == NULL) {\n        serverLog(LL_WARNING,\n            \"Fatal: AOF method for module data type '%s' tried to \"\n            \"call RedisModule_EmitAOF() with wrong format specifiers '%s'\",\n            io->type->name, fmt);\n        io->error = 1;\n        errno = EINVAL;\n        return;\n    }\n\n    /* Bulk count. */\n    if (!io->error && rioWriteBulkCount(io->rio,'*',argc) == 0)\n        io->error = 1;\n\n    /* Arguments. */\n    for (j = 0; j < argc; j++) {\n        if (!io->error && rioWriteBulkObject(io->rio,argv[j]) == 0)\n            io->error = 1;\n        decrRefCount(argv[j]);\n    }\n    zfree(argv);\n    return;\n}\n\n/* --------------------------------------------------------------------------\n * IO context handling\n * -------------------------------------------------------------------------- */\n\nRedisModuleCtx *RM_GetContextFromIO(RedisModuleIO *io) {\n    if (io->ctx) return io->ctx; /* Can't have more than one... */\n    RedisModuleCtx ctxtemplate = REDISMODULE_CTX_INIT;\n    io->ctx = zmalloc(sizeof(RedisModuleCtx));\n    *(io->ctx) = ctxtemplate;\n    io->ctx->module = io->type->module;\n    io->ctx->client = NULL;\n    return io->ctx;\n}\n\n/* --------------------------------------------------------------------------\n * Logging\n * -------------------------------------------------------------------------- */\n\n/* This is the low level function implementing both:\n *\n *      RM_Log()\n *      RM_LogIOError()\n *\n */\nvoid RM_LogRaw(RedisModule *module, const char *levelstr, const char *fmt, va_list ap) {\n    char msg[LOG_MAX_LEN];\n    size_t name_len;\n    int level;\n\n    if (!strcasecmp(levelstr,\"debug\")) level = LL_DEBUG;\n    else if (!strcasecmp(levelstr,\"verbose\")) level = LL_VERBOSE;\n    else if (!strcasecmp(levelstr,\"notice\")) level = LL_NOTICE;\n    else if (!strcasecmp(levelstr,\"warning\")) level = LL_WARNING;\n    else level = LL_VERBOSE; /* Default. */\n\n    name_len = snprintf(msg, sizeof(msg),\"<%s> \", module->name);\n    vsnprintf(msg + name_len, sizeof(msg) - name_len, fmt, ap);\n    serverLogRaw(level,msg);\n}\n\n/* Produces a log message to the standard Redis log, the format accepts\n * printf-alike specifiers, while level is a string describing the log\n * level to use when emitting the log, and must be one of the following:\n *\n * * \"debug\"\n * * \"verbose\"\n * * \"notice\"\n * * \"warning\"\n *\n * If the specified log level is invalid, verbose is used by default.\n * There is a fixed limit to the length of the log line this function is able\n * to emit, this limti is not specified but is guaranteed to be more than\n * a few lines of text.\n */\nvoid RM_Log(RedisModuleCtx *ctx, const char *levelstr, const char *fmt, ...) {\n    if (!ctx->module) return;   /* Can only log if module is initialized */\n\n    va_list ap;\n    va_start(ap, fmt);\n    RM_LogRaw(ctx->module,levelstr,fmt,ap);\n    va_end(ap);\n}\n\n/* Log errors from RDB / AOF serialization callbacks.\n *\n * This function should be used when a callback is returning a critical\n * error to the caller since cannot load or save the data for some\n * critical reason. */\nvoid RM_LogIOError(RedisModuleIO *io, const char *levelstr, const char *fmt, ...) {\n    va_list ap;\n    va_start(ap, fmt);\n    RM_LogRaw(io->type->module,levelstr,fmt,ap);\n    va_end(ap);\n}\n\n/* --------------------------------------------------------------------------\n * Blocking clients from modules\n * -------------------------------------------------------------------------- */\n\n/* Readable handler for the awake pipe. We do nothing here, the awake bytes\n * will be actually read in a more appropriate place in the\n * moduleHandleBlockedClients() function that is where clients are actually\n * served. */\nvoid moduleBlockedClientPipeReadable(aeEventLoop *el, int fd, void *privdata, int mask) {\n    UNUSED(el);\n    UNUSED(fd);\n    UNUSED(mask);\n    UNUSED(privdata);\n}\n\n/* This is called from blocked.c in order to unblock a client: may be called\n * for multiple reasons while the client is in the middle of being blocked\n * because the client is terminated, but is also called for cleanup when a\n * client is unblocked in a clean way after replaying.\n *\n * What we do here is just to set the client to NULL in the redis module\n * blocked client handle. This way if the client is terminated while there\n * is a pending threaded operation involving the blocked client, we'll know\n * that the client no longer exists and no reply callback should be called.\n *\n * The structure RedisModuleBlockedClient will be always deallocated when\n * running the list of clients blocked by a module that need to be unblocked. */\nvoid unblockClientFromModule(client *c) {\n    RedisModuleBlockedClient *bc = c->bpop.module_blocked_handle;\n    bc->client = NULL;\n    /* Reset the client for a new query since, for blocking commands implemented\n     * into modules, we do not it immediately after the command returns (and\n     * the client blocks) in order to be still able to access the argument\n     * vector from callbacks. */\n    resetClient(c);\n}\n\n/* Block a client in the context of a blocking command, returning an handle\n * which will be used, later, in order to unblock the client with a call to\n * RedisModule_UnblockClient(). The arguments specify callback functions\n * and a timeout after which the client is unblocked.\n *\n * The callbacks are called in the following contexts:\n *\n *     reply_callback:  called after a successful RedisModule_UnblockClient()\n *                      call in order to reply to the client and unblock it.\n *\n *     reply_timeout:   called when the timeout is reached in order to send an\n *                      error to the client.\n *\n *     free_privdata:   called in order to free the privata data that is passed\n *                      by RedisModule_UnblockClient() call.\n */\nRedisModuleBlockedClient *RM_BlockClient(RedisModuleCtx *ctx, RedisModuleCmdFunc reply_callback, RedisModuleCmdFunc timeout_callback, void (*free_privdata)(void*), long long timeout_ms) {\n    client *c = ctx->client;\n    int islua = c->flags & CLIENT_LUA;\n    int ismulti = c->flags & CLIENT_MULTI;\n\n    c->bpop.module_blocked_handle = zmalloc(sizeof(RedisModuleBlockedClient));\n    RedisModuleBlockedClient *bc = c->bpop.module_blocked_handle;\n\n    /* We need to handle the invalid operation of calling modules blocking\n     * commands from Lua or MULTI. We actually create an already aborted\n     * (client set to NULL) blocked client handle, and actually reply with\n     * an error. */\n    bc->client = (islua || ismulti) ? NULL : c;\n    bc->module = ctx->module;\n    bc->reply_callback = reply_callback;\n    bc->timeout_callback = timeout_callback;\n    bc->free_privdata = free_privdata;\n    bc->privdata = NULL;\n    bc->reply_client = createClient(-1);\n    bc->reply_client->flags |= CLIENT_MODULE;\n    bc->dbid = c->db->id;\n    c->bpop.timeout = timeout_ms ? (mstime()+timeout_ms) : 0;\n\n    if (islua || ismulti) {\n        c->bpop.module_blocked_handle = NULL;\n        addReplyError(c, islua ?\n            \"Blocking module command called from Lua script\" :\n            \"Blocking module command called from transaction\");\n    } else {\n        blockClient(c,BLOCKED_MODULE);\n    }\n    return bc;\n}\n\n/* Unblock a client blocked by `RedisModule_BlockedClient`. This will trigger\n * the reply callbacks to be called in order to reply to the client.\n * The 'privdata' argument will be accessible by the reply callback, so\n * the caller of this function can pass any value that is needed in order to\n * actually reply to the client.\n *\n * A common usage for 'privdata' is a thread that computes something that\n * needs to be passed to the client, included but not limited some slow\n * to compute reply or some reply obtained via networking.\n *\n * Note: this function can be called from threads spawned by the module. */\nint RM_UnblockClient(RedisModuleBlockedClient *bc, void *privdata) {\n    pthread_mutex_lock(&moduleUnblockedClientsMutex);\n    bc->privdata = privdata;\n    listAddNodeTail(moduleUnblockedClients,bc);\n    if (write(server.module_blocked_pipe[1],\"A\",1) != 1) {\n        /* Ignore the error, this is best-effort. */\n    }\n    pthread_mutex_unlock(&moduleUnblockedClientsMutex);\n    return REDISMODULE_OK;\n}\n\n/* Abort a blocked client blocking operation: the client will be unblocked\n * without firing the reply callback. */\nint RM_AbortBlock(RedisModuleBlockedClient *bc) {\n    bc->reply_callback = NULL;\n    return RM_UnblockClient(bc,NULL);\n}\n\n/* This function will check the moduleUnblockedClients queue in order to\n * call the reply callback and really unblock the client.\n *\n * Clients end into this list because of calls to RM_UnblockClient(),\n * however it is possible that while the module was doing work for the\n * blocked client, it was terminated by Redis (for timeout or other reasons).\n * When this happens the RedisModuleBlockedClient structure in the queue\n * will have the 'client' field set to NULL. */\nvoid moduleHandleBlockedClients(void) {\n    listNode *ln;\n    RedisModuleBlockedClient *bc;\n\n    pthread_mutex_lock(&moduleUnblockedClientsMutex);\n    /* Here we unblock all the pending clients blocked in modules operations\n     * so we can read every pending \"awake byte\" in the pipe. */\n    char buf[1];\n    while (read(server.module_blocked_pipe[0],buf,1) == 1);\n    while (listLength(moduleUnblockedClients)) {\n        ln = listFirst(moduleUnblockedClients);\n        bc = ln->value;\n        client *c = bc->client;\n        listDelNode(moduleUnblockedClients,ln);\n        pthread_mutex_unlock(&moduleUnblockedClientsMutex);\n\n        /* Release the lock during the loop, as long as we don't\n         * touch the shared list. */\n\n        /* Call the reply callback if the client is valid and we have\n         * any callback. */\n        if (c && bc->reply_callback) {\n            RedisModuleCtx ctx = REDISMODULE_CTX_INIT;\n            ctx.flags |= REDISMODULE_CTX_BLOCKED_REPLY;\n            ctx.blocked_privdata = bc->privdata;\n            ctx.module = bc->module;\n            ctx.client = bc->client;\n            bc->reply_callback(&ctx,(void**)c->argv,c->argc);\n            moduleHandlePropagationAfterCommandCallback(&ctx);\n            moduleFreeContext(&ctx);\n        }\n\n        /* Free privdata if any. */\n        if (bc->privdata && bc->free_privdata)\n            bc->free_privdata(bc->privdata);\n\n        /* It is possible that this blocked client object accumulated\n         * replies to send to the client in a thread safe context.\n         * We need to glue such replies to the client output buffer and\n         * free the temporary client we just used for the replies. */\n        if (c) {\n            if (bc->reply_client->bufpos)\n                addReplyString(c,bc->reply_client->buf,\n                                 bc->reply_client->bufpos);\n            if (listLength(bc->reply_client->reply))\n                listJoin(c->reply,bc->reply_client->reply);\n            c->reply_bytes += bc->reply_client->reply_bytes;\n        }\n        freeClient(bc->reply_client);\n\n        if (c != NULL) {\n            unblockClient(c);\n            /* Put the client in the list of clients that need to write\n             * if there are pending replies here. This is needed since\n             * during a non blocking command the client may receive output. */\n            if (clientHasPendingReplies(c) &&\n                !(c->flags & CLIENT_PENDING_WRITE))\n            {\n                c->flags |= CLIENT_PENDING_WRITE;\n                listAddNodeHead(server.clients_pending_write,c);\n            }\n        }\n\n        /* Free 'bc' only after unblocking the client, since it is\n         * referenced in the client blocking context, and must be valid\n         * when calling unblockClient(). */\n        zfree(bc);\n\n        /* Lock again before to iterate the loop. */\n        pthread_mutex_lock(&moduleUnblockedClientsMutex);\n    }\n    pthread_mutex_unlock(&moduleUnblockedClientsMutex);\n}\n\n/* Called when our client timed out. After this function unblockClient()\n * is called, and it will invalidate the blocked client. So this function\n * does not need to do any cleanup. Eventually the module will call the\n * API to unblock the client and the memory will be released. */\nvoid moduleBlockedClientTimedOut(client *c) {\n    RedisModuleBlockedClient *bc = c->bpop.module_blocked_handle;\n    RedisModuleCtx ctx = REDISMODULE_CTX_INIT;\n    ctx.flags |= REDISMODULE_CTX_BLOCKED_TIMEOUT;\n    ctx.module = bc->module;\n    ctx.client = bc->client;\n    bc->timeout_callback(&ctx,(void**)c->argv,c->argc);\n    moduleFreeContext(&ctx);\n}\n\n/* Return non-zero if a module command was called in order to fill the\n * reply for a blocked client. */\nint RM_IsBlockedReplyRequest(RedisModuleCtx *ctx) {\n    return (ctx->flags & REDISMODULE_CTX_BLOCKED_REPLY) != 0;\n}\n\n/* Return non-zero if a module command was called in order to fill the\n * reply for a blocked client that timed out. */\nint RM_IsBlockedTimeoutRequest(RedisModuleCtx *ctx) {\n    return (ctx->flags & REDISMODULE_CTX_BLOCKED_TIMEOUT) != 0;\n}\n\n/* Get the privata data set by RedisModule_UnblockClient() */\nvoid *RM_GetBlockedClientPrivateData(RedisModuleCtx *ctx) {\n    return ctx->blocked_privdata;\n}\n\n/* --------------------------------------------------------------------------\n * Thread Safe Contexts\n * -------------------------------------------------------------------------- */\n\n/* Return a context which can be used inside threads to make Redis context\n * calls with certain modules APIs. If 'bc' is not NULL then the module will\n * be bound to a blocked client, and it will be possible to use the\n * `RedisModule_Reply*` family of functions to accumulate a reply for when the\n * client will be unblocked. Otherwise the thread safe context will be\n * detached by a specific client.\n *\n * To call non-reply APIs, the thread safe context must be prepared with:\n *\n *     RedisModule_ThreadSafeCallStart(ctx);\n *     ... make your call here ...\n *     RedisModule_ThreadSafeCallStop(ctx);\n *\n * This is not needed when using `RedisModule_Reply*` functions, assuming\n * that a blocked client was used when the context was created, otherwise\n * no RedisModule_Reply* call should be made at all.\n *\n * TODO: thread safe contexts do not inherit the blocked client\n * selected database. */\nRedisModuleCtx *RM_GetThreadSafeContext(RedisModuleBlockedClient *bc) {\n    RedisModuleCtx *ctx = zmalloc(sizeof(*ctx));\n    RedisModuleCtx empty = REDISMODULE_CTX_INIT;\n    memcpy(ctx,&empty,sizeof(empty));\n    if (bc) {\n        ctx->blocked_client = bc;\n        ctx->module = bc->module;\n    }\n    ctx->flags |= REDISMODULE_CTX_THREAD_SAFE;\n    /* Even when the context is associated with a blocked client, we can't\n     * access it safely from another thread, so we create a fake client here\n     * in order to keep things like the currently selected database and similar\n     * things. */\n    ctx->client = createClient(-1);\n    if (bc) selectDb(ctx->client,bc->dbid);\n    return ctx;\n}\n\n/* Release a thread safe context. */\nvoid RM_FreeThreadSafeContext(RedisModuleCtx *ctx) {\n    moduleFreeContext(ctx);\n    zfree(ctx);\n}\n\n/* Acquire the server lock before executing a thread safe API call.\n * This is not needed for `RedisModule_Reply*` calls when there is\n * a blocked client connected to the thread safe context. */\nvoid RM_ThreadSafeContextLock(RedisModuleCtx *ctx) {\n    DICT_NOTUSED(ctx);\n    moduleAcquireGIL();\n}\n\n/* Release the server lock after a thread safe API call was executed. */\nvoid RM_ThreadSafeContextUnlock(RedisModuleCtx *ctx) {\n    DICT_NOTUSED(ctx);\n    moduleReleaseGIL();\n}\n\nvoid moduleAcquireGIL(void) {\n    pthread_mutex_lock(&moduleGIL);\n}\n\nvoid moduleReleaseGIL(void) {\n    pthread_mutex_unlock(&moduleGIL);\n}\n\n\n/* --------------------------------------------------------------------------\n * Module Keyspace Notifications API\n * -------------------------------------------------------------------------- */\n\n/* Subscribe to keyspace notifications. This is a low-level version of the\n * keyspace-notifications API. A module cand register callbacks to be notified\n * when keyspce events occur.\n *\n * Notification events are filtered by their type (string events, set events,\n * etc), and the subsriber callback receives only events that match a specific\n * mask of event types.\n *\n * When subscribing to notifications with RedisModule_SubscribeToKeyspaceEvents \n * the module must provide an event type-mask, denoting the events the subscriber\n * is interested in. This can be an ORed mask of any of the following flags:\n *\n *  - REDISMODULE_NOTIFY_GENERIC: Generic commands like DEL, EXPIRE, RENAME\n *  - REDISMODULE_NOTIFY_STRING: String events\n *  - REDISMODULE_NOTIFY_LIST: List events\n *  - REDISMODULE_NOTIFY_SET: Set events\n *  - REDISMODULE_NOTIFY_HASH: Hash events\n *  - REDISMODULE_NOTIFY_ZSET: Sorted Set events\n *  - REDISMODULE_NOTIFY_EXPIRED: Expiration events\n *  - REDISMODULE_NOTIFY_EVICTED: Eviction events\n *  - REDISMODULE_NOTIFY_STREAM: Stream events\n *  - REDISMODULE_NOTIFY_ALL: All events\n *\n * We do not distinguish between key events and keyspace events, and it is up\n * to the module to filter the actions taken based on the key.\n *\n * The subscriber signature is:\n *\n *   int (*RedisModuleNotificationFunc) (RedisModuleCtx *ctx, int type,\n *                                       const char *event,\n *                                       RedisModuleString *key);\n *\n * `type` is the event type bit, that must match the mask given at registration\n * time. The event string is the actual command being executed, and key is the\n * relevant Redis key.\n *\n * Notification callback gets executed with a redis context that can not be\n * used to send anything to the client, and has the db number where the event\n * occured as its selected db number.\n *\n * Notice that it is not necessary to enable norifications in redis.conf for\n * module notifications to work.\n *\n * Warning: the notification callbacks are performed in a synchronous manner,\n * so notification callbacks must to be fast, or they would slow Redis down.\n * If you need to take long actions, use threads to offload them.\n *\n * See https://redis.io/topics/notifications for more information.\n */\nint RM_SubscribeToKeyspaceEvents(RedisModuleCtx *ctx, int types, RedisModuleNotificationFunc callback) {\n    RedisModuleKeyspaceSubscriber *sub = zmalloc(sizeof(*sub));\n    sub->module = ctx->module;\n    sub->event_mask = types;\n    sub->notify_callback = callback;\n    sub->active = 0;\n\n    listAddNodeTail(moduleKeyspaceSubscribers, sub);\n    return REDISMODULE_OK;\n}\n\n/* Dispatcher for keyspace notifications to module subscriber functions.\n * This gets called  only if at least one module requested to be notified on\n * keyspace notifications */\nvoid moduleNotifyKeyspaceEvent(int type, const char *event, robj *key, int dbid) {\n    /* Don't do anything if there aren't any subscribers */\n    if (listLength(moduleKeyspaceSubscribers) == 0) return;\n\n    listIter li;\n    listNode *ln;\n    listRewind(moduleKeyspaceSubscribers,&li);\n\n    /* Remove irrelevant flags from the type mask */\n    type &= ~(NOTIFY_KEYEVENT | NOTIFY_KEYSPACE);\n\n    while((ln = listNext(&li))) {\n        RedisModuleKeyspaceSubscriber *sub = ln->value;\n        /* Only notify subscribers on events matching they registration,\n         * and avoid subscribers triggering themselves */\n        if ((sub->event_mask & type) && sub->active == 0) {\n            RedisModuleCtx ctx = REDISMODULE_CTX_INIT;\n            ctx.module = sub->module;\n            ctx.client = moduleKeyspaceSubscribersClient;\n            selectDb(ctx.client, dbid);\n\n            /* mark the handler as activer to avoid reentrant loops.\n             * If the subscriber performs an action triggering itself,\n             * it will not be notified about it. */\n            sub->active = 1;\n            sub->notify_callback(&ctx, type, event, key);\n            sub->active = 0;\n            moduleFreeContext(&ctx);\n        }\n    }\n}\n\n/* Unsubscribe any notification subscirbers this module has upon unloading */\nvoid moduleUnsubscribeNotifications(RedisModule *module) {\n    listIter li;\n    listNode *ln;\n    listRewind(moduleKeyspaceSubscribers,&li);\n    while((ln = listNext(&li))) {\n        RedisModuleKeyspaceSubscriber *sub = ln->value;\n        if (sub->module == module) {\n            listDelNode(moduleKeyspaceSubscribers, ln);\n            zfree(sub);\n        }\n    }\n}\n\n/* --------------------------------------------------------------------------\n * Modules API internals\n * -------------------------------------------------------------------------- */\n\n/* server.moduleapi dictionary type. Only uses plain C strings since\n * this gets queries from modules. */\n\nuint64_t dictCStringKeyHash(const void *key) {\n    return dictGenHashFunction((unsigned char*)key, strlen((char*)key));\n}\n\nint dictCStringKeyCompare(void *privdata, const void *key1, const void *key2) {\n    DICT_NOTUSED(privdata);\n    return strcmp(key1,key2) == 0;\n}\n\ndictType moduleAPIDictType = {\n    dictCStringKeyHash,        /* hash function */\n    NULL,                      /* key dup */\n    NULL,                      /* val dup */\n    dictCStringKeyCompare,     /* key compare */\n    NULL,                      /* key destructor */\n    NULL                       /* val destructor */\n};\n\nint moduleRegisterApi(const char *funcname, void *funcptr) {\n    return dictAdd(server.moduleapi, (char*)funcname, funcptr);\n}\n\n#define REGISTER_API(name) \\\n    moduleRegisterApi(\"RedisModule_\" #name, (void *)(unsigned long)RM_ ## name)\n\n/* Global initialization at Redis startup. */\nvoid moduleRegisterCoreAPI(void);\n\nvoid moduleInitModulesSystem(void) {\n    moduleUnblockedClients = listCreate();\n    server.loadmodule_queue = listCreate();\n    modules = dictCreate(&modulesDictType,NULL);\n\n    /* Set up the keyspace notification susbscriber list and static client */\n    moduleKeyspaceSubscribers = listCreate();\n    moduleKeyspaceSubscribersClient = createClient(-1);\n    moduleKeyspaceSubscribersClient->flags |= CLIENT_MODULE;\n\n    moduleRegisterCoreAPI();\n    if (pipe(server.module_blocked_pipe) == -1) {\n        serverLog(LL_WARNING,\n            \"Can't create the pipe for module blocking commands: %s\",\n            strerror(errno));\n        exit(1);\n    }\n    /* Make the pipe non blocking. This is just a best effort aware mechanism\n     * and we do not want to block not in the read nor in the write half. */\n    anetNonBlock(NULL,server.module_blocked_pipe[0]);\n    anetNonBlock(NULL,server.module_blocked_pipe[1]);\n\n    /* Our thread-safe contexts GIL must start with already locked:\n     * it is just unlocked when it's safe. */\n    pthread_mutex_lock(&moduleGIL);\n}\n\n/* Load all the modules in the server.loadmodule_queue list, which is\n * populated by `loadmodule` directives in the configuration file.\n * We can't load modules directly when processing the configuration file\n * because the server must be fully initialized before loading modules.\n *\n * The function aborts the server on errors, since to start with missing\n * modules is not considered sane: clients may rely on the existance of\n * given commands, loading AOF also may need some modules to exist, and\n * if this instance is a slave, it must understand commands from master. */\nvoid moduleLoadFromQueue(void) {\n    listIter li;\n    listNode *ln;\n\n    listRewind(server.loadmodule_queue,&li);\n    while((ln = listNext(&li))) {\n        struct moduleLoadQueueEntry *loadmod = ln->value;\n        if (moduleLoad(loadmod->path,(void **)loadmod->argv,loadmod->argc)\n            == C_ERR)\n        {\n            serverLog(LL_WARNING,\n                \"Can't load module from %s: server aborting\",\n                loadmod->path);\n            exit(1);\n        }\n    }\n}\n\nvoid moduleFreeModuleStructure(struct RedisModule *module) {\n    listRelease(module->types);\n    sdsfree(module->name);\n    zfree(module);\n}\n\nvoid moduleUnregisterCommands(struct RedisModule *module) {\n    /* Unregister all the commands registered by this module. */\n    dictIterator *di = dictGetSafeIterator(server.commands);\n    dictEntry *de;\n    while ((de = dictNext(di)) != NULL) {\n        struct redisCommand *cmd = dictGetVal(de);\n        if (cmd->proc == RedisModuleCommandDispatcher) {\n            RedisModuleCommandProxy *cp =\n                (void*)(unsigned long)cmd->getkeys_proc;\n            sds cmdname = cp->rediscmd->name;\n            if (cp->module == module) {\n                dictDelete(server.commands,cmdname);\n                dictDelete(server.orig_commands,cmdname);\n                sdsfree(cmdname);\n                zfree(cp->rediscmd);\n                zfree(cp);\n            }\n        }\n    }\n    dictReleaseIterator(di);\n}\n\n/* Load a module and initialize it. On success C_OK is returned, otherwise\n * C_ERR is returned. */\nint moduleLoad(const char *path, void **module_argv, int module_argc) {\n    int (*onload)(void *, void **, int);\n    void *handle;\n    RedisModuleCtx ctx = REDISMODULE_CTX_INIT;\n\n    handle = dlopen(path,RTLD_NOW|RTLD_LOCAL);\n    if (handle == NULL) {\n        serverLog(LL_WARNING, \"Module %s failed to load: %s\", path, dlerror());\n        return C_ERR;\n    }\n    onload = (int (*)(void *, void **, int))(unsigned long) dlsym(handle,\"RedisModule_OnLoad\");\n    if (onload == NULL) {\n        serverLog(LL_WARNING,\n            \"Module %s does not export RedisModule_OnLoad() \"\n            \"symbol. Module not loaded.\",path);\n        return C_ERR;\n    }\n    if (onload((void*)&ctx,module_argv,module_argc) == REDISMODULE_ERR) {\n        if (ctx.module) {\n            moduleUnregisterCommands(ctx.module);\n            moduleFreeModuleStructure(ctx.module);\n        }\n        dlclose(handle);\n        serverLog(LL_WARNING,\n            \"Module %s initialization failed. Module not loaded\",path);\n        return C_ERR;\n    }\n\n    /* Redis module loaded! Register it. */\n    dictAdd(modules,ctx.module->name,ctx.module);\n    ctx.module->handle = handle;\n    serverLog(LL_NOTICE,\"Module '%s' loaded from %s\",ctx.module->name,path);\n    moduleFreeContext(&ctx);\n    return C_OK;\n}\n\n\n/* Unload the module registered with the specified name. On success\n * C_OK is returned, otherwise C_ERR is returned and errno is set\n * to the following values depending on the type of error:\n *\n * * ENONET: No such module having the specified name.\n * * EBUSY: The module exports a new data type and can only be reloaded. */\nint moduleUnload(sds name) {\n    struct RedisModule *module = dictFetchValue(modules,name);\n\n    if (module == NULL) {\n        errno = ENOENT;\n        return REDISMODULE_ERR;\n    }\n\n    if (listLength(module->types)) {\n        errno = EBUSY;\n        return REDISMODULE_ERR;\n    }\n\n    moduleUnregisterCommands(module);\n\n    /* Remvoe any noification subscribers this module might have */\n    moduleUnsubscribeNotifications(module);\n\n    /* Unregister all the hooks. TODO: Yet no hooks support here. */\n\n    /* Unload the dynamic library. */\n    if (dlclose(module->handle) == -1) {\n        char *error = dlerror();\n        if (error == NULL) error = \"Unknown error\";\n        serverLog(LL_WARNING,\"Error when trying to close the %s module: %s\",\n            module->name, error);\n    }\n\n    /* Remove from list of modules. */\n    serverLog(LL_NOTICE,\"Module %s unloaded\",module->name);\n    dictDelete(modules,module->name);\n    module->name = NULL; /* The name was already freed by dictDelete(). */\n    moduleFreeModuleStructure(module);\n\n    return REDISMODULE_OK;\n}\n\n/* Redis MODULE command.\n *\n * MODULE LOAD <path> [args...] */\nvoid moduleCommand(client *c) {\n    char *subcmd = c->argv[1]->ptr;\n\n    if (!strcasecmp(subcmd,\"load\") && c->argc >= 3) {\n        robj **argv = NULL;\n        int argc = 0;\n\n        if (c->argc > 3) {\n            argc = c->argc - 3;\n            argv = &c->argv[3];\n        }\n\n        if (moduleLoad(c->argv[2]->ptr,(void **)argv,argc) == C_OK)\n            addReply(c,shared.ok);\n        else\n            addReplyError(c,\n                \"Error loading the extension. Please check the server logs.\");\n    } else if (!strcasecmp(subcmd,\"unload\") && c->argc == 3) {\n        if (moduleUnload(c->argv[2]->ptr) == C_OK)\n            addReply(c,shared.ok);\n        else {\n            char *errmsg;\n            switch(errno) {\n            case ENOENT:\n                errmsg = \"no such module with that name\";\n                break;\n            case EBUSY:\n                errmsg = \"the module exports one or more module-side data types, can't unload\";\n                break;\n            default:\n                errmsg = \"operation not possible.\";\n                break;\n            }\n            addReplyErrorFormat(c,\"Error unloading module: %s\",errmsg);\n        }\n    } else if (!strcasecmp(subcmd,\"list\") && c->argc == 2) {\n        dictIterator *di = dictGetIterator(modules);\n        dictEntry *de;\n\n        addReplyMultiBulkLen(c,dictSize(modules));\n        while ((de = dictNext(di)) != NULL) {\n            sds name = dictGetKey(de);\n            struct RedisModule *module = dictGetVal(de);\n            addReplyMultiBulkLen(c,4);\n            addReplyBulkCString(c,\"name\");\n            addReplyBulkCBuffer(c,name,sdslen(name));\n            addReplyBulkCString(c,\"ver\");\n            addReplyLongLong(c,module->ver);\n        }\n        dictReleaseIterator(di);\n    } else {\n        addReply(c,shared.syntaxerr);\n    }\n}\n\n/* Return the number of registered modules. */\nsize_t moduleCount(void) {\n    return dictSize(modules);\n}\n\n/* Register all the APIs we export. Keep this function at the end of the\n * file so that's easy to seek it to add new entries. */\nvoid moduleRegisterCoreAPI(void) {\n    server.moduleapi = dictCreate(&moduleAPIDictType,NULL);\n    REGISTER_API(Alloc);\n    REGISTER_API(Calloc);\n    REGISTER_API(Realloc);\n    REGISTER_API(Free);\n    REGISTER_API(Strdup);\n    REGISTER_API(CreateCommand);\n    REGISTER_API(SetModuleAttribs);\n    REGISTER_API(IsModuleNameBusy);\n    REGISTER_API(WrongArity);\n    REGISTER_API(ReplyWithLongLong);\n    REGISTER_API(ReplyWithError);\n    REGISTER_API(ReplyWithSimpleString);\n    REGISTER_API(ReplyWithArray);\n    REGISTER_API(ReplySetArrayLength);\n    REGISTER_API(ReplyWithString);\n    REGISTER_API(ReplyWithStringBuffer);\n    REGISTER_API(ReplyWithNull);\n    REGISTER_API(ReplyWithCallReply);\n    REGISTER_API(ReplyWithDouble);\n    REGISTER_API(GetSelectedDb);\n    REGISTER_API(SelectDb);\n    REGISTER_API(OpenKey);\n    REGISTER_API(CloseKey);\n    REGISTER_API(KeyType);\n    REGISTER_API(ValueLength);\n    REGISTER_API(ListPush);\n    REGISTER_API(ListPop);\n    REGISTER_API(StringToLongLong);\n    REGISTER_API(StringToDouble);\n    REGISTER_API(Call);\n    REGISTER_API(CallReplyProto);\n    REGISTER_API(FreeCallReply);\n    REGISTER_API(CallReplyInteger);\n    REGISTER_API(CallReplyType);\n    REGISTER_API(CallReplyLength);\n    REGISTER_API(CallReplyArrayElement);\n    REGISTER_API(CallReplyStringPtr);\n    REGISTER_API(CreateStringFromCallReply);\n    REGISTER_API(CreateString);\n    REGISTER_API(CreateStringFromLongLong);\n    REGISTER_API(CreateStringFromString);\n    REGISTER_API(CreateStringPrintf);\n    REGISTER_API(FreeString);\n    REGISTER_API(StringPtrLen);\n    REGISTER_API(AutoMemory);\n    REGISTER_API(Replicate);\n    REGISTER_API(ReplicateVerbatim);\n    REGISTER_API(DeleteKey);\n    REGISTER_API(UnlinkKey);\n    REGISTER_API(StringSet);\n    REGISTER_API(StringDMA);\n    REGISTER_API(StringTruncate);\n    REGISTER_API(SetExpire);\n    REGISTER_API(GetExpire);\n    REGISTER_API(ZsetAdd);\n    REGISTER_API(ZsetIncrby);\n    REGISTER_API(ZsetScore);\n    REGISTER_API(ZsetRem);\n    REGISTER_API(ZsetRangeStop);\n    REGISTER_API(ZsetFirstInScoreRange);\n    REGISTER_API(ZsetLastInScoreRange);\n    REGISTER_API(ZsetFirstInLexRange);\n    REGISTER_API(ZsetLastInLexRange);\n    REGISTER_API(ZsetRangeCurrentElement);\n    REGISTER_API(ZsetRangeNext);\n    REGISTER_API(ZsetRangePrev);\n    REGISTER_API(ZsetRangeEndReached);\n    REGISTER_API(HashSet);\n    REGISTER_API(HashGet);\n    REGISTER_API(IsKeysPositionRequest);\n    REGISTER_API(KeyAtPos);\n    REGISTER_API(GetClientId);\n    REGISTER_API(GetContextFlags);\n    REGISTER_API(PoolAlloc);\n    REGISTER_API(CreateDataType);\n    REGISTER_API(ModuleTypeSetValue);\n    REGISTER_API(ModuleTypeGetType);\n    REGISTER_API(ModuleTypeGetValue);\n    REGISTER_API(SaveUnsigned);\n    REGISTER_API(LoadUnsigned);\n    REGISTER_API(SaveSigned);\n    REGISTER_API(LoadSigned);\n    REGISTER_API(SaveString);\n    REGISTER_API(SaveStringBuffer);\n    REGISTER_API(LoadString);\n    REGISTER_API(LoadStringBuffer);\n    REGISTER_API(SaveDouble);\n    REGISTER_API(LoadDouble);\n    REGISTER_API(SaveFloat);\n    REGISTER_API(LoadFloat);\n    REGISTER_API(EmitAOF);\n    REGISTER_API(Log);\n    REGISTER_API(LogIOError);\n    REGISTER_API(StringAppendBuffer);\n    REGISTER_API(RetainString);\n    REGISTER_API(StringCompare);\n    REGISTER_API(GetContextFromIO);\n    REGISTER_API(BlockClient);\n    REGISTER_API(UnblockClient);\n    REGISTER_API(IsBlockedReplyRequest);\n    REGISTER_API(IsBlockedTimeoutRequest);\n    REGISTER_API(GetBlockedClientPrivateData);\n    REGISTER_API(AbortBlock);\n    REGISTER_API(Milliseconds);\n    REGISTER_API(GetThreadSafeContext);\n    REGISTER_API(FreeThreadSafeContext);\n    REGISTER_API(ThreadSafeContextLock);\n    REGISTER_API(ThreadSafeContextUnlock);\n    REGISTER_API(DigestAddStringBuffer);\n    REGISTER_API(DigestAddLongLong);\n    REGISTER_API(DigestEndSequence);\n    REGISTER_API(SubscribeToKeyspaceEvents);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-redis-4.0.13-c6t5xnt2ivmsaib6izc4ma6blwxnshrd/spack-src/deps/lua/src/loadlib.c": "/*\n** $Id: loadlib.c,v 1.52.1.4 2009/09/09 13:17:16 roberto Exp $\n** Dynamic library loader for Lua\n** See Copyright Notice in lua.h\n**\n** This module contains an implementation of loadlib for Unix systems\n** that have dlfcn, an implementation for Darwin (Mac OS X), an\n** implementation for Windows, and a stub for other systems.\n*/\n\n\n#include <stdlib.h>\n#include <string.h>\n\n\n#define loadlib_c\n#define LUA_LIB\n\n#include \"lua.h\"\n\n#include \"lauxlib.h\"\n#include \"lualib.h\"\n\n\n/* prefix for open functions in C libraries */\n#define LUA_POF\t\t\"luaopen_\"\n\n/* separator for open functions in C libraries */\n#define LUA_OFSEP\t\"_\"\n\n\n#define LIBPREFIX\t\"LOADLIB: \"\n\n#define POF\t\tLUA_POF\n#define LIB_FAIL\t\"open\"\n\n\n/* error codes for ll_loadfunc */\n#define ERRLIB\t\t1\n#define ERRFUNC\t\t2\n\n#define setprogdir(L)\t\t((void)0)\n\n\nstatic void ll_unloadlib (void *lib);\nstatic void *ll_load (lua_State *L, const char *path);\nstatic lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym);\n\n\n\n#if defined(LUA_DL_DLOPEN)\n/*\n** {========================================================================\n** This is an implementation of loadlib based on the dlfcn interface.\n** The dlfcn interface is available in Linux, SunOS, Solaris, IRIX, FreeBSD,\n** NetBSD, AIX 4.2, HPUX 11, and  probably most other Unix flavors, at least\n** as an emulation layer on top of native functions.\n** =========================================================================\n*/\n\n#include <dlfcn.h>\n\nstatic void ll_unloadlib (void *lib) {\n  dlclose(lib);\n}\n\n\nstatic void *ll_load (lua_State *L, const char *path) {\n  void *lib = dlopen(path, RTLD_NOW);\n  if (lib == NULL) lua_pushstring(L, dlerror());\n  return lib;\n}\n\n\nstatic lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {\n  lua_CFunction f = (lua_CFunction)dlsym(lib, sym);\n  if (f == NULL) lua_pushstring(L, dlerror());\n  return f;\n}\n\n/* }====================================================== */\n\n\n\n#elif defined(LUA_DL_DLL)\n/*\n** {======================================================================\n** This is an implementation of loadlib for Windows using native functions.\n** =======================================================================\n*/\n\n#include <windows.h>\n\n\n#undef setprogdir\n\nstatic void setprogdir (lua_State *L) {\n  char buff[MAX_PATH + 1];\n  char *lb;\n  DWORD nsize = sizeof(buff)/sizeof(char);\n  DWORD n = GetModuleFileNameA(NULL, buff, nsize);\n  if (n == 0 || n == nsize || (lb = strrchr(buff, '\\\\')) == NULL)\n    luaL_error(L, \"unable to get ModuleFileName\");\n  else {\n    *lb = '\\0';\n    luaL_gsub(L, lua_tostring(L, -1), LUA_EXECDIR, buff);\n    lua_remove(L, -2);  /* remove original string */\n  }\n}\n\n\nstatic void pusherror (lua_State *L) {\n  int error = GetLastError();\n  char buffer[128];\n  if (FormatMessageA(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,\n      NULL, error, 0, buffer, sizeof(buffer), NULL))\n    lua_pushstring(L, buffer);\n  else\n    lua_pushfstring(L, \"system error %d\\n\", error);\n}\n\nstatic void ll_unloadlib (void *lib) {\n  FreeLibrary((HINSTANCE)lib);\n}\n\n\nstatic void *ll_load (lua_State *L, const char *path) {\n  HINSTANCE lib = LoadLibraryA(path);\n  if (lib == NULL) pusherror(L);\n  return lib;\n}\n\n\nstatic lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {\n  lua_CFunction f = (lua_CFunction)GetProcAddress((HINSTANCE)lib, sym);\n  if (f == NULL) pusherror(L);\n  return f;\n}\n\n/* }====================================================== */\n\n\n\n#elif defined(LUA_DL_DYLD)\n/*\n** {======================================================================\n** Native Mac OS X / Darwin Implementation\n** =======================================================================\n*/\n\n#include <mach-o/dyld.h>\n\n\n/* Mac appends a `_' before C function names */\n#undef POF\n#define POF\t\"_\" LUA_POF\n\n\nstatic void pusherror (lua_State *L) {\n  const char *err_str;\n  const char *err_file;\n  NSLinkEditErrors err;\n  int err_num;\n  NSLinkEditError(&err, &err_num, &err_file, &err_str);\n  lua_pushstring(L, err_str);\n}\n\n\nstatic const char *errorfromcode (NSObjectFileImageReturnCode ret) {\n  switch (ret) {\n    case NSObjectFileImageInappropriateFile:\n      return \"file is not a bundle\";\n    case NSObjectFileImageArch:\n      return \"library is for wrong CPU type\";\n    case NSObjectFileImageFormat:\n      return \"bad format\";\n    case NSObjectFileImageAccess:\n      return \"cannot access file\";\n    case NSObjectFileImageFailure:\n    default:\n      return \"unable to load library\";\n  }\n}\n\n\nstatic void ll_unloadlib (void *lib) {\n  NSUnLinkModule((NSModule)lib, NSUNLINKMODULE_OPTION_RESET_LAZY_REFERENCES);\n}\n\n\nstatic void *ll_load (lua_State *L, const char *path) {\n  NSObjectFileImage img;\n  NSObjectFileImageReturnCode ret;\n  /* this would be a rare case, but prevents crashing if it happens */\n  if(!_dyld_present()) {\n    lua_pushliteral(L, \"dyld not present\");\n    return NULL;\n  }\n  ret = NSCreateObjectFileImageFromFile(path, &img);\n  if (ret == NSObjectFileImageSuccess) {\n    NSModule mod = NSLinkModule(img, path, NSLINKMODULE_OPTION_PRIVATE |\n                       NSLINKMODULE_OPTION_RETURN_ON_ERROR);\n    NSDestroyObjectFileImage(img);\n    if (mod == NULL) pusherror(L);\n    return mod;\n  }\n  lua_pushstring(L, errorfromcode(ret));\n  return NULL;\n}\n\n\nstatic lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {\n  NSSymbol nss = NSLookupSymbolInModule((NSModule)lib, sym);\n  if (nss == NULL) {\n    lua_pushfstring(L, \"symbol \" LUA_QS \" not found\", sym);\n    return NULL;\n  }\n  return (lua_CFunction)NSAddressOfSymbol(nss);\n}\n\n/* }====================================================== */\n\n\n\n#else\n/*\n** {======================================================\n** Fallback for other systems\n** =======================================================\n*/\n\n#undef LIB_FAIL\n#define LIB_FAIL\t\"absent\"\n\n\n#define DLMSG\t\"dynamic libraries not enabled; check your Lua installation\"\n\n\nstatic void ll_unloadlib (void *lib) {\n  (void)lib;  /* to avoid warnings */\n}\n\n\nstatic void *ll_load (lua_State *L, const char *path) {\n  (void)path;  /* to avoid warnings */\n  lua_pushliteral(L, DLMSG);\n  return NULL;\n}\n\n\nstatic lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {\n  (void)lib; (void)sym;  /* to avoid warnings */\n  lua_pushliteral(L, DLMSG);\n  return NULL;\n}\n\n/* }====================================================== */\n#endif\n\n\n\nstatic void **ll_register (lua_State *L, const char *path) {\n  void **plib;\n  lua_pushfstring(L, \"%s%s\", LIBPREFIX, path);\n  lua_gettable(L, LUA_REGISTRYINDEX);  /* check library in registry? */\n  if (!lua_isnil(L, -1))  /* is there an entry? */\n    plib = (void **)lua_touserdata(L, -1);\n  else {  /* no entry yet; create one */\n    lua_pop(L, 1);\n    plib = (void **)lua_newuserdata(L, sizeof(const void *));\n    *plib = NULL;\n    luaL_getmetatable(L, \"_LOADLIB\");\n    lua_setmetatable(L, -2);\n    lua_pushfstring(L, \"%s%s\", LIBPREFIX, path);\n    lua_pushvalue(L, -2);\n    lua_settable(L, LUA_REGISTRYINDEX);\n  }\n  return plib;\n}\n\n\n/*\n** __gc tag method: calls library's `ll_unloadlib' function with the lib\n** handle\n*/\nstatic int gctm (lua_State *L) {\n  void **lib = (void **)luaL_checkudata(L, 1, \"_LOADLIB\");\n  if (*lib) ll_unloadlib(*lib);\n  *lib = NULL;  /* mark library as closed */\n  return 0;\n}\n\n\nstatic int ll_loadfunc (lua_State *L, const char *path, const char *sym) {\n  void **reg = ll_register(L, path);\n  if (*reg == NULL) *reg = ll_load(L, path);\n  if (*reg == NULL)\n    return ERRLIB;  /* unable to load library */\n  else {\n    lua_CFunction f = ll_sym(L, *reg, sym);\n    if (f == NULL)\n      return ERRFUNC;  /* unable to find function */\n    lua_pushcfunction(L, f);\n    return 0;  /* return function */\n  }\n}\n\n\nstatic int ll_loadlib (lua_State *L) {\n  const char *path = luaL_checkstring(L, 1);\n  const char *init = luaL_checkstring(L, 2);\n  int stat = ll_loadfunc(L, path, init);\n  if (stat == 0)  /* no errors? */\n    return 1;  /* return the loaded function */\n  else {  /* error; error message is on stack top */\n    lua_pushnil(L);\n    lua_insert(L, -2);\n    lua_pushstring(L, (stat == ERRLIB) ?  LIB_FAIL : \"init\");\n    return 3;  /* return nil, error message, and where */\n  }\n}\n\n\n\n/*\n** {======================================================\n** 'require' function\n** =======================================================\n*/\n\n\nstatic int readable (const char *filename) {\n  FILE *f = fopen(filename, \"r\");  /* try to open file */\n  if (f == NULL) return 0;  /* open failed */\n  fclose(f);\n  return 1;\n}\n\n\nstatic const char *pushnexttemplate (lua_State *L, const char *path) {\n  const char *l;\n  while (*path == *LUA_PATHSEP) path++;  /* skip separators */\n  if (*path == '\\0') return NULL;  /* no more templates */\n  l = strchr(path, *LUA_PATHSEP);  /* find next separator */\n  if (l == NULL) l = path + strlen(path);\n  lua_pushlstring(L, path, l - path);  /* template */\n  return l;\n}\n\n\nstatic const char *findfile (lua_State *L, const char *name,\n                                           const char *pname) {\n  const char *path;\n  name = luaL_gsub(L, name, \".\", LUA_DIRSEP);\n  lua_getfield(L, LUA_ENVIRONINDEX, pname);\n  path = lua_tostring(L, -1);\n  if (path == NULL)\n    luaL_error(L, LUA_QL(\"package.%s\") \" must be a string\", pname);\n  lua_pushliteral(L, \"\");  /* error accumulator */\n  while ((path = pushnexttemplate(L, path)) != NULL) {\n    const char *filename;\n    filename = luaL_gsub(L, lua_tostring(L, -1), LUA_PATH_MARK, name);\n    lua_remove(L, -2);  /* remove path template */\n    if (readable(filename))  /* does file exist and is readable? */\n      return filename;  /* return that file name */\n    lua_pushfstring(L, \"\\n\\tno file \" LUA_QS, filename);\n    lua_remove(L, -2);  /* remove file name */\n    lua_concat(L, 2);  /* add entry to possible error message */\n  }\n  return NULL;  /* not found */\n}\n\n\nstatic void loaderror (lua_State *L, const char *filename) {\n  luaL_error(L, \"error loading module \" LUA_QS \" from file \" LUA_QS \":\\n\\t%s\",\n                lua_tostring(L, 1), filename, lua_tostring(L, -1));\n}\n\n\nstatic int loader_Lua (lua_State *L) {\n  const char *filename;\n  const char *name = luaL_checkstring(L, 1);\n  filename = findfile(L, name, \"path\");\n  if (filename == NULL) return 1;  /* library not found in this path */\n  if (luaL_loadfile(L, filename) != 0)\n    loaderror(L, filename);\n  return 1;  /* library loaded successfully */\n}\n\n\nstatic const char *mkfuncname (lua_State *L, const char *modname) {\n  const char *funcname;\n  const char *mark = strchr(modname, *LUA_IGMARK);\n  if (mark) modname = mark + 1;\n  funcname = luaL_gsub(L, modname, \".\", LUA_OFSEP);\n  funcname = lua_pushfstring(L, POF\"%s\", funcname);\n  lua_remove(L, -2);  /* remove 'gsub' result */\n  return funcname;\n}\n\n\nstatic int loader_C (lua_State *L) {\n  const char *funcname;\n  const char *name = luaL_checkstring(L, 1);\n  const char *filename = findfile(L, name, \"cpath\");\n  if (filename == NULL) return 1;  /* library not found in this path */\n  funcname = mkfuncname(L, name);\n  if (ll_loadfunc(L, filename, funcname) != 0)\n    loaderror(L, filename);\n  return 1;  /* library loaded successfully */\n}\n\n\nstatic int loader_Croot (lua_State *L) {\n  const char *funcname;\n  const char *filename;\n  const char *name = luaL_checkstring(L, 1);\n  const char *p = strchr(name, '.');\n  int stat;\n  if (p == NULL) return 0;  /* is root */\n  lua_pushlstring(L, name, p - name);\n  filename = findfile(L, lua_tostring(L, -1), \"cpath\");\n  if (filename == NULL) return 1;  /* root not found */\n  funcname = mkfuncname(L, name);\n  if ((stat = ll_loadfunc(L, filename, funcname)) != 0) {\n    if (stat != ERRFUNC) loaderror(L, filename);  /* real error */\n    lua_pushfstring(L, \"\\n\\tno module \" LUA_QS \" in file \" LUA_QS,\n                       name, filename);\n    return 1;  /* function not found */\n  }\n  return 1;\n}\n\n\nstatic int loader_preload (lua_State *L) {\n  const char *name = luaL_checkstring(L, 1);\n  lua_getfield(L, LUA_ENVIRONINDEX, \"preload\");\n  if (!lua_istable(L, -1))\n    luaL_error(L, LUA_QL(\"package.preload\") \" must be a table\");\n  lua_getfield(L, -1, name);\n  if (lua_isnil(L, -1))  /* not found? */\n    lua_pushfstring(L, \"\\n\\tno field package.preload['%s']\", name);\n  return 1;\n}\n\n\nstatic const int sentinel_ = 0;\n#define sentinel\t((void *)&sentinel_)\n\n\nstatic int ll_require (lua_State *L) {\n  const char *name = luaL_checkstring(L, 1);\n  int i;\n  lua_settop(L, 1);  /* _LOADED table will be at index 2 */\n  lua_getfield(L, LUA_REGISTRYINDEX, \"_LOADED\");\n  lua_getfield(L, 2, name);\n  if (lua_toboolean(L, -1)) {  /* is it there? */\n    if (lua_touserdata(L, -1) == sentinel)  /* check loops */\n      luaL_error(L, \"loop or previous error loading module \" LUA_QS, name);\n    return 1;  /* package is already loaded */\n  }\n  /* else must load it; iterate over available loaders */\n  lua_getfield(L, LUA_ENVIRONINDEX, \"loaders\");\n  if (!lua_istable(L, -1))\n    luaL_error(L, LUA_QL(\"package.loaders\") \" must be a table\");\n  lua_pushliteral(L, \"\");  /* error message accumulator */\n  for (i=1; ; i++) {\n    lua_rawgeti(L, -2, i);  /* get a loader */\n    if (lua_isnil(L, -1))\n      luaL_error(L, \"module \" LUA_QS \" not found:%s\",\n                    name, lua_tostring(L, -2));\n    lua_pushstring(L, name);\n    lua_call(L, 1, 1);  /* call it */\n    if (lua_isfunction(L, -1))  /* did it find module? */\n      break;  /* module loaded successfully */\n    else if (lua_isstring(L, -1))  /* loader returned error message? */\n      lua_concat(L, 2);  /* accumulate it */\n    else\n      lua_pop(L, 1);\n  }\n  lua_pushlightuserdata(L, sentinel);\n  lua_setfield(L, 2, name);  /* _LOADED[name] = sentinel */\n  lua_pushstring(L, name);  /* pass name as argument to module */\n  lua_call(L, 1, 1);  /* run loaded module */\n  if (!lua_isnil(L, -1))  /* non-nil return? */\n    lua_setfield(L, 2, name);  /* _LOADED[name] = returned value */\n  lua_getfield(L, 2, name);\n  if (lua_touserdata(L, -1) == sentinel) {   /* module did not set a value? */\n    lua_pushboolean(L, 1);  /* use true as result */\n    lua_pushvalue(L, -1);  /* extra copy to be returned */\n    lua_setfield(L, 2, name);  /* _LOADED[name] = true */\n  }\n  return 1;\n}\n\n/* }====================================================== */\n\n\n\n/*\n** {======================================================\n** 'module' function\n** =======================================================\n*/\n  \n\nstatic void setfenv (lua_State *L) {\n  lua_Debug ar;\n  if (lua_getstack(L, 1, &ar) == 0 ||\n      lua_getinfo(L, \"f\", &ar) == 0 ||  /* get calling function */\n      lua_iscfunction(L, -1))\n    luaL_error(L, LUA_QL(\"module\") \" not called from a Lua function\");\n  lua_pushvalue(L, -2);\n  lua_setfenv(L, -2);\n  lua_pop(L, 1);\n}\n\n\nstatic void dooptions (lua_State *L, int n) {\n  int i;\n  for (i = 2; i <= n; i++) {\n    lua_pushvalue(L, i);  /* get option (a function) */\n    lua_pushvalue(L, -2);  /* module */\n    lua_call(L, 1, 0);\n  }\n}\n\n\nstatic void modinit (lua_State *L, const char *modname) {\n  const char *dot;\n  lua_pushvalue(L, -1);\n  lua_setfield(L, -2, \"_M\");  /* module._M = module */\n  lua_pushstring(L, modname);\n  lua_setfield(L, -2, \"_NAME\");\n  dot = strrchr(modname, '.');  /* look for last dot in module name */\n  if (dot == NULL) dot = modname;\n  else dot++;\n  /* set _PACKAGE as package name (full module name minus last part) */\n  lua_pushlstring(L, modname, dot - modname);\n  lua_setfield(L, -2, \"_PACKAGE\");\n}\n\n\nstatic int ll_module (lua_State *L) {\n  const char *modname = luaL_checkstring(L, 1);\n  int loaded = lua_gettop(L) + 1;  /* index of _LOADED table */\n  lua_getfield(L, LUA_REGISTRYINDEX, \"_LOADED\");\n  lua_getfield(L, loaded, modname);  /* get _LOADED[modname] */\n  if (!lua_istable(L, -1)) {  /* not found? */\n    lua_pop(L, 1);  /* remove previous result */\n    /* try global variable (and create one if it does not exist) */\n    if (luaL_findtable(L, LUA_GLOBALSINDEX, modname, 1) != NULL)\n      return luaL_error(L, \"name conflict for module \" LUA_QS, modname);\n    lua_pushvalue(L, -1);\n    lua_setfield(L, loaded, modname);  /* _LOADED[modname] = new table */\n  }\n  /* check whether table already has a _NAME field */\n  lua_getfield(L, -1, \"_NAME\");\n  if (!lua_isnil(L, -1))  /* is table an initialized module? */\n    lua_pop(L, 1);\n  else {  /* no; initialize it */\n    lua_pop(L, 1);\n    modinit(L, modname);\n  }\n  lua_pushvalue(L, -1);\n  setfenv(L);\n  dooptions(L, loaded - 1);\n  return 0;\n}\n\n\nstatic int ll_seeall (lua_State *L) {\n  luaL_checktype(L, 1, LUA_TTABLE);\n  if (!lua_getmetatable(L, 1)) {\n    lua_createtable(L, 0, 1); /* create new metatable */\n    lua_pushvalue(L, -1);\n    lua_setmetatable(L, 1);\n  }\n  lua_pushvalue(L, LUA_GLOBALSINDEX);\n  lua_setfield(L, -2, \"__index\");  /* mt.__index = _G */\n  return 0;\n}\n\n\n/* }====================================================== */\n\n\n\n/* auxiliary mark (for internal use) */\n#define AUXMARK\t\t\"\\1\"\n\nstatic void setpath (lua_State *L, const char *fieldname, const char *envname,\n                                   const char *def) {\n  const char *path = getenv(envname);\n  if (path == NULL)  /* no environment variable? */\n    lua_pushstring(L, def);  /* use default */\n  else {\n    /* replace \";;\" by \";AUXMARK;\" and then AUXMARK by default path */\n    path = luaL_gsub(L, path, LUA_PATHSEP LUA_PATHSEP,\n                              LUA_PATHSEP AUXMARK LUA_PATHSEP);\n    luaL_gsub(L, path, AUXMARK, def);\n    lua_remove(L, -2);\n  }\n  setprogdir(L);\n  lua_setfield(L, -2, fieldname);\n}\n\n\nstatic const luaL_Reg pk_funcs[] = {\n  {\"loadlib\", ll_loadlib},\n  {\"seeall\", ll_seeall},\n  {NULL, NULL}\n};\n\n\nstatic const luaL_Reg ll_funcs[] = {\n  {\"module\", ll_module},\n  {\"require\", ll_require},\n  {NULL, NULL}\n};\n\n\nstatic const lua_CFunction loaders[] =\n  {loader_preload, loader_Lua, loader_C, loader_Croot, NULL};\n\n\nLUALIB_API int luaopen_package (lua_State *L) {\n  int i;\n  /* create new type _LOADLIB */\n  luaL_newmetatable(L, \"_LOADLIB\");\n  lua_pushcfunction(L, gctm);\n  lua_setfield(L, -2, \"__gc\");\n  /* create `package' table */\n  luaL_register(L, LUA_LOADLIBNAME, pk_funcs);\n#if defined(LUA_COMPAT_LOADLIB) \n  lua_getfield(L, -1, \"loadlib\");\n  lua_setfield(L, LUA_GLOBALSINDEX, \"loadlib\");\n#endif\n  lua_pushvalue(L, -1);\n  lua_replace(L, LUA_ENVIRONINDEX);\n  /* create `loaders' table */\n  lua_createtable(L, sizeof(loaders)/sizeof(loaders[0]) - 1, 0);\n  /* fill it with pre-defined loaders */\n  for (i=0; loaders[i] != NULL; i++) {\n    lua_pushcfunction(L, loaders[i]);\n    lua_rawseti(L, -2, i+1);\n  }\n  lua_setfield(L, -2, \"loaders\");  /* put it in field `loaders' */\n  setpath(L, \"path\", LUA_PATH, LUA_PATH_DEFAULT);  /* set field `path' */\n  setpath(L, \"cpath\", LUA_CPATH, LUA_CPATH_DEFAULT); /* set field `cpath' */\n  /* store config information */\n  lua_pushliteral(L, LUA_DIRSEP \"\\n\" LUA_PATHSEP \"\\n\" LUA_PATH_MARK \"\\n\"\n                     LUA_EXECDIR \"\\n\" LUA_IGMARK);\n  lua_setfield(L, -2, \"config\");\n  /* set field `loaded' */\n  luaL_findtable(L, LUA_REGISTRYINDEX, \"_LOADED\", 2);\n  lua_setfield(L, -2, \"loaded\");\n  /* set field `preload' */\n  lua_newtable(L);\n  lua_setfield(L, -2, \"preload\");\n  lua_pushvalue(L, LUA_GLOBALSINDEX);\n  luaL_register(L, NULL, ll_funcs);  /* open lib into global table */\n  lua_pop(L, 1);\n  return 1;  /* return 'package' table */\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-redis-4.0.13-c6t5xnt2ivmsaib6izc4ma6blwxnshrd/spack-src/deps/jemalloc/configure.ac": "dnl Process this file with autoconf to produce a configure script.\nAC_INIT([Makefile.in])\n\ndnl ============================================================================\ndnl Custom macro definitions.\n\ndnl JE_CFLAGS_APPEND(cflag)\nAC_DEFUN([JE_CFLAGS_APPEND],\n[\nAC_MSG_CHECKING([whether compiler supports $1])\nTCFLAGS=\"${CFLAGS}\"\nif test \"x${CFLAGS}\" = \"x\" ; then\n  CFLAGS=\"$1\"\nelse\n  CFLAGS=\"${CFLAGS} $1\"\nfi\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n[[\n]], [[\n    return 0;\n]])],\n              [je_cv_cflags_appended=$1]\n              AC_MSG_RESULT([yes]),\n              [je_cv_cflags_appended=]\n              AC_MSG_RESULT([no])\n              [CFLAGS=\"${TCFLAGS}\"]\n)\n])\n\ndnl JE_COMPILABLE(label, hcode, mcode, rvar)\ndnl \ndnl Use AC_LINK_IFELSE() rather than AC_COMPILE_IFELSE() so that linker errors\ndnl cause failure.\nAC_DEFUN([JE_COMPILABLE],\n[\nAC_CACHE_CHECK([whether $1 is compilable],\n               [$4],\n               [AC_LINK_IFELSE([AC_LANG_PROGRAM([$2],\n                                                [$3])],\n                               [$4=yes],\n                               [$4=no])])\n])\n\ndnl ============================================================================\n\nCONFIG=`echo ${ac_configure_args} | sed -e 's#'\"'\"'\\([^ ]*\\)'\"'\"'#\\1#g'`\nAC_SUBST([CONFIG])\n\ndnl Library revision.\nrev=2\nAC_SUBST([rev])\n\nsrcroot=$srcdir\nif test \"x${srcroot}\" = \"x.\" ; then\n  srcroot=\"\"\nelse\n  srcroot=\"${srcroot}/\"\nfi\nAC_SUBST([srcroot])\nabs_srcroot=\"`cd \\\"${srcdir}\\\"; pwd`/\"\nAC_SUBST([abs_srcroot])\n\nobjroot=\"\"\nAC_SUBST([objroot])\nabs_objroot=\"`pwd`/\"\nAC_SUBST([abs_objroot])\n\ndnl Munge install path variables.\nif test \"x$prefix\" = \"xNONE\" ; then\n  prefix=\"/usr/local\"\nfi\nif test \"x$exec_prefix\" = \"xNONE\" ; then\n  exec_prefix=$prefix\nfi\nPREFIX=$prefix\nAC_SUBST([PREFIX])\nBINDIR=`eval echo $bindir`\nBINDIR=`eval echo $BINDIR`\nAC_SUBST([BINDIR])\nINCLUDEDIR=`eval echo $includedir`\nINCLUDEDIR=`eval echo $INCLUDEDIR`\nAC_SUBST([INCLUDEDIR])\nLIBDIR=`eval echo $libdir`\nLIBDIR=`eval echo $LIBDIR`\nAC_SUBST([LIBDIR])\nDATADIR=`eval echo $datadir`\nDATADIR=`eval echo $DATADIR`\nAC_SUBST([DATADIR])\nMANDIR=`eval echo $mandir`\nMANDIR=`eval echo $MANDIR`\nAC_SUBST([MANDIR])\n\ndnl Support for building documentation.\nAC_PATH_PROG([XSLTPROC], [xsltproc], [false], [$PATH])\nif test -d \"/usr/share/xml/docbook/stylesheet/docbook-xsl\" ; then\n  DEFAULT_XSLROOT=\"/usr/share/xml/docbook/stylesheet/docbook-xsl\"\nelif test -d \"/usr/share/sgml/docbook/xsl-stylesheets\" ; then\n  DEFAULT_XSLROOT=\"/usr/share/sgml/docbook/xsl-stylesheets\"\nelse\n  dnl Documentation building will fail if this default gets used.\n  DEFAULT_XSLROOT=\"\"\nfi\nAC_ARG_WITH([xslroot],\n  [AS_HELP_STRING([--with-xslroot=<path>], [XSL stylesheet root path])], [\nif test \"x$with_xslroot\" = \"xno\" ; then\n  XSLROOT=\"${DEFAULT_XSLROOT}\"\nelse\n  XSLROOT=\"${with_xslroot}\"\nfi\n],\n  XSLROOT=\"${DEFAULT_XSLROOT}\"\n)\nAC_SUBST([XSLROOT])\n\ndnl If CFLAGS isn't defined, set CFLAGS to something reasonable.  Otherwise,\ndnl just prevent autoconf from molesting CFLAGS.\nCFLAGS=$CFLAGS\nAC_PROG_CC\nif test \"x$GCC\" != \"xyes\" ; then\n  AC_CACHE_CHECK([whether compiler is MSVC],\n                 [je_cv_msvc],\n                 [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([],\n                                                     [\n#ifndef _MSC_VER\n  int fail[-1];\n#endif\n])],\n                               [je_cv_msvc=yes],\n                               [je_cv_msvc=no])])\nfi\n\nif test \"x$CFLAGS\" = \"x\" ; then\n  no_CFLAGS=\"yes\"\n  if test \"x$GCC\" = \"xyes\" ; then\n    JE_CFLAGS_APPEND([-std=gnu99])\n    if test \"x$je_cv_cflags_appended\" = \"x-std=gnu99\" ; then\n      AC_DEFINE_UNQUOTED([JEMALLOC_HAS_RESTRICT])\n    fi\n    JE_CFLAGS_APPEND([-Wall])\n    JE_CFLAGS_APPEND([-Werror=declaration-after-statement])\n    JE_CFLAGS_APPEND([-pipe])\n    JE_CFLAGS_APPEND([-g3])\n  elif test \"x$je_cv_msvc\" = \"xyes\" ; then\n    CC=\"$CC -nologo\"\n    JE_CFLAGS_APPEND([-Zi])\n    JE_CFLAGS_APPEND([-MT])\n    JE_CFLAGS_APPEND([-W3])\n    JE_CFLAGS_APPEND([-FS])\n    CPPFLAGS=\"$CPPFLAGS -I${srcdir}/include/msvc_compat\"\n  fi\nfi\ndnl Append EXTRA_CFLAGS to CFLAGS, if defined.\nif test \"x$EXTRA_CFLAGS\" != \"x\" ; then\n  JE_CFLAGS_APPEND([$EXTRA_CFLAGS])\nfi\nAC_PROG_CPP\n\nAC_C_BIGENDIAN([ac_cv_big_endian=1], [ac_cv_big_endian=0])\nif test \"x${ac_cv_big_endian}\" = \"x1\" ; then\n  AC_DEFINE_UNQUOTED([JEMALLOC_BIG_ENDIAN], [ ])\nfi\n\nif test \"x${je_cv_msvc}\" = \"xyes\" -a \"x${ac_cv_header_inttypes_h}\" = \"xno\"; then\n  CPPFLAGS=\"$CPPFLAGS -I${srcdir}/include/msvc_compat/C99\"\nfi\n\nAC_CHECK_SIZEOF([void *])\nif test \"x${ac_cv_sizeof_void_p}\" = \"x8\" ; then\n  LG_SIZEOF_PTR=3\nelif test \"x${ac_cv_sizeof_void_p}\" = \"x4\" ; then\n  LG_SIZEOF_PTR=2\nelse\n  AC_MSG_ERROR([Unsupported pointer size: ${ac_cv_sizeof_void_p}])\nfi\nAC_DEFINE_UNQUOTED([LG_SIZEOF_PTR], [$LG_SIZEOF_PTR])\n\nAC_CHECK_SIZEOF([int])\nif test \"x${ac_cv_sizeof_int}\" = \"x8\" ; then\n  LG_SIZEOF_INT=3\nelif test \"x${ac_cv_sizeof_int}\" = \"x4\" ; then\n  LG_SIZEOF_INT=2\nelse\n  AC_MSG_ERROR([Unsupported int size: ${ac_cv_sizeof_int}])\nfi\nAC_DEFINE_UNQUOTED([LG_SIZEOF_INT], [$LG_SIZEOF_INT])\n\nAC_CHECK_SIZEOF([long])\nif test \"x${ac_cv_sizeof_long}\" = \"x8\" ; then\n  LG_SIZEOF_LONG=3\nelif test \"x${ac_cv_sizeof_long}\" = \"x4\" ; then\n  LG_SIZEOF_LONG=2\nelse\n  AC_MSG_ERROR([Unsupported long size: ${ac_cv_sizeof_long}])\nfi\nAC_DEFINE_UNQUOTED([LG_SIZEOF_LONG], [$LG_SIZEOF_LONG])\n\nAC_CHECK_SIZEOF([intmax_t])\nif test \"x${ac_cv_sizeof_intmax_t}\" = \"x16\" ; then\n  LG_SIZEOF_INTMAX_T=4\nelif test \"x${ac_cv_sizeof_intmax_t}\" = \"x8\" ; then\n  LG_SIZEOF_INTMAX_T=3\nelif test \"x${ac_cv_sizeof_intmax_t}\" = \"x4\" ; then\n  LG_SIZEOF_INTMAX_T=2\nelse\n  AC_MSG_ERROR([Unsupported intmax_t size: ${ac_cv_sizeof_intmax_t}])\nfi\nAC_DEFINE_UNQUOTED([LG_SIZEOF_INTMAX_T], [$LG_SIZEOF_INTMAX_T])\n\nAC_CANONICAL_HOST\ndnl CPU-specific settings.\nCPU_SPINWAIT=\"\"\ncase \"${host_cpu}\" in\n  i686|x86_64)\n\tAC_CACHE_VAL([je_cv_pause],\n\t  [JE_COMPILABLE([pause instruction], [],\n\t                [[__asm__ volatile(\"pause\"); return 0;]],\n\t                [je_cv_pause])])\n\tif test \"x${je_cv_pause}\" = \"xyes\" ; then\n\t    CPU_SPINWAIT='__asm__ volatile(\"pause\")'\n\tfi\n\t;;\n  powerpc)\n\tAC_DEFINE_UNQUOTED([HAVE_ALTIVEC], [ ])\n\t;;\n  *)\n\t;;\nesac\nAC_DEFINE_UNQUOTED([CPU_SPINWAIT], [$CPU_SPINWAIT])\n\nLD_PRELOAD_VAR=\"LD_PRELOAD\"\nso=\"so\"\nimportlib=\"${so}\"\no=\"$ac_objext\"\na=\"a\"\nexe=\"$ac_exeext\"\nlibprefix=\"lib\"\nDSO_LDFLAGS='-shared -Wl,-soname,$(@F)'\nRPATH='-Wl,-rpath,$(1)'\nSOREV=\"${so}.${rev}\"\nPIC_CFLAGS='-fPIC -DPIC'\nCTARGET='-o $@'\nLDTARGET='-o $@'\nEXTRA_LDFLAGS=\nARFLAGS='crus'\nAROUT=' $@'\nCC_MM=1\n\nAN_MAKEVAR([AR], [AC_PROG_AR])\nAN_PROGRAM([ar], [AC_PROG_AR])\nAC_DEFUN([AC_PROG_AR], [AC_CHECK_TOOL(AR, ar, :)])\nAC_PROG_AR\n\ndnl Platform-specific settings.  abi and RPATH can probably be determined\ndnl programmatically, but doing so is error-prone, which makes it generally\ndnl not worth the trouble.\ndnl \ndnl Define cpp macros in CPPFLAGS, rather than doing AC_DEFINE(macro), since the\ndnl definitions need to be seen before any headers are included, which is a pain\ndnl to make happen otherwise.\ndefault_munmap=\"1\"\nmaps_coalesce=\"1\"\ncase \"${host}\" in\n  *-*-darwin* | *-*-ios*)\n\tCFLAGS=\"$CFLAGS\"\n\tabi=\"macho\"\n\tAC_DEFINE([JEMALLOC_PURGE_MADVISE_FREE], [ ])\n\tRPATH=\"\"\n\tLD_PRELOAD_VAR=\"DYLD_INSERT_LIBRARIES\"\n\tso=\"dylib\"\n\timportlib=\"${so}\"\n\tforce_tls=\"0\"\n\tDSO_LDFLAGS='-shared -Wl,-install_name,$(LIBDIR)/$(@F)'\n\tSOREV=\"${rev}.${so}\"\n\tsbrk_deprecated=\"1\"\n\t;;\n  *-*-freebsd*)\n\tCFLAGS=\"$CFLAGS\"\n\tabi=\"elf\"\n\tAC_DEFINE([JEMALLOC_PURGE_MADVISE_FREE], [ ])\n\tforce_lazy_lock=\"1\"\n\t;;\n  *-*-dragonfly*)\n\tCFLAGS=\"$CFLAGS\"\n\tabi=\"elf\"\n\tAC_DEFINE([JEMALLOC_PURGE_MADVISE_FREE], [ ])\n\t;;\n  *-*-openbsd*)\n\tCFLAGS=\"$CFLAGS\"\n\tabi=\"elf\"\n\tAC_DEFINE([JEMALLOC_PURGE_MADVISE_FREE], [ ])\n\tforce_tls=\"0\"\n\t;;\n  *-*-bitrig*)\n\tCFLAGS=\"$CFLAGS\"\n\tabi=\"elf\"\n\tAC_DEFINE([JEMALLOC_PURGE_MADVISE_FREE], [ ])\n\t;;\n  *-*-linux*)\n\tCFLAGS=\"$CFLAGS\"\n\tCPPFLAGS=\"$CPPFLAGS -D_GNU_SOURCE\"\n\tabi=\"elf\"\n\tAC_DEFINE([JEMALLOC_HAS_ALLOCA_H])\n\tAC_DEFINE([JEMALLOC_PURGE_MADVISE_DONTNEED], [ ])\n\tAC_DEFINE([JEMALLOC_THREADED_INIT], [ ])\n\tAC_DEFINE([JEMALLOC_USE_CXX_THROW], [ ])\n\tdefault_munmap=\"0\"\n\t;;\n  *-*-netbsd*)\n\tAC_MSG_CHECKING([ABI])\n        AC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n[[#ifdef __ELF__\n/* ELF */\n#else\n#error aout\n#endif\n]])],\n                          [CFLAGS=\"$CFLAGS\"; abi=\"elf\"],\n                          [abi=\"aout\"])\n\tAC_MSG_RESULT([$abi])\n\tAC_DEFINE([JEMALLOC_PURGE_MADVISE_FREE], [ ])\n\t;;\n  *-*-solaris2*)\n\tCFLAGS=\"$CFLAGS\"\n\tabi=\"elf\"\n\tAC_DEFINE([JEMALLOC_PURGE_MADVISE_FREE], [ ])\n\tRPATH='-Wl,-R,$(1)'\n\tdnl Solaris needs this for sigwait().\n\tCPPFLAGS=\"$CPPFLAGS -D_POSIX_PTHREAD_SEMANTICS\"\n\tLIBS=\"$LIBS -lposix4 -lsocket -lnsl\"\n\t;;\n  *-ibm-aix*)\n\tif \"$LG_SIZEOF_PTR\" = \"8\"; then\n\t  dnl 64bit AIX\n\t  LD_PRELOAD_VAR=\"LDR_PRELOAD64\"\n\telse\n\t  dnl 32bit AIX\n\t  LD_PRELOAD_VAR=\"LDR_PRELOAD\"\n\tfi\n\tabi=\"xcoff\"\n\t;;\n  *-*-mingw* | *-*-cygwin*)\n\tabi=\"pecoff\"\n\tforce_tls=\"0\"\n\tforce_lazy_lock=\"1\"\n\tmaps_coalesce=\"0\"\n\tRPATH=\"\"\n\tso=\"dll\"\n\tif test \"x$je_cv_msvc\" = \"xyes\" ; then\n\t  importlib=\"lib\"\n\t  DSO_LDFLAGS=\"-LD\"\n\t  EXTRA_LDFLAGS=\"-link -DEBUG\"\n\t  CTARGET='-Fo$@'\n\t  LDTARGET='-Fe$@'\n\t  AR='lib'\n\t  ARFLAGS='-nologo -out:'\n\t  AROUT='$@'\n\t  CC_MM=\n        else\n\t  importlib=\"${so}\"\n\t  DSO_LDFLAGS=\"-shared\"\n\tfi\n\ta=\"lib\"\n\tlibprefix=\"\"\n\tSOREV=\"${so}\"\n\tPIC_CFLAGS=\"\"\n\t;;\n  *)\n\tAC_MSG_RESULT([Unsupported operating system: ${host}])\n\tabi=\"elf\"\n\t;;\nesac\n\nJEMALLOC_USABLE_SIZE_CONST=const\nAC_CHECK_HEADERS([malloc.h], [\n  AC_MSG_CHECKING([whether malloc_usable_size definition can use const argument])\n  AC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n    [#include <malloc.h>\n     #include <stddef.h>\n    size_t malloc_usable_size(const void *ptr);\n    ],\n    [])],[\n                AC_MSG_RESULT([yes])\n         ],[\n                JEMALLOC_USABLE_SIZE_CONST=\n                AC_MSG_RESULT([no])\n         ])\n])\nAC_DEFINE_UNQUOTED([JEMALLOC_USABLE_SIZE_CONST], [$JEMALLOC_USABLE_SIZE_CONST])\nAC_SUBST([abi])\nAC_SUBST([RPATH])\nAC_SUBST([LD_PRELOAD_VAR])\nAC_SUBST([so])\nAC_SUBST([importlib])\nAC_SUBST([o])\nAC_SUBST([a])\nAC_SUBST([exe])\nAC_SUBST([libprefix])\nAC_SUBST([DSO_LDFLAGS])\nAC_SUBST([EXTRA_LDFLAGS])\nAC_SUBST([SOREV])\nAC_SUBST([PIC_CFLAGS])\nAC_SUBST([CTARGET])\nAC_SUBST([LDTARGET])\nAC_SUBST([MKLIB])\nAC_SUBST([ARFLAGS])\nAC_SUBST([AROUT])\nAC_SUBST([CC_MM])\n\nJE_COMPILABLE([__attribute__ syntax],\n              [static __attribute__((unused)) void foo(void){}],\n              [],\n              [je_cv_attribute])\nif test \"x${je_cv_attribute}\" = \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_HAVE_ATTR], [ ])\n  if test \"x${GCC}\" = \"xyes\" -a \"x${abi}\" = \"xelf\"; then\n    JE_CFLAGS_APPEND([-fvisibility=hidden])\n  fi\nfi\ndnl Check for tls_model attribute support (clang 3.0 still lacks support).\nSAVED_CFLAGS=\"${CFLAGS}\"\nJE_CFLAGS_APPEND([-Werror])\nJE_COMPILABLE([tls_model attribute], [],\n              [static __thread int\n               __attribute__((tls_model(\"initial-exec\"), unused)) foo;\n               foo = 0;],\n              [je_cv_tls_model])\nCFLAGS=\"${SAVED_CFLAGS}\"\nif test \"x${je_cv_tls_model}\" = \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_TLS_MODEL],\n            [__attribute__((tls_model(\"initial-exec\")))])\nelse\n  AC_DEFINE([JEMALLOC_TLS_MODEL], [ ])\nfi\ndnl Check for alloc_size attribute support.\nSAVED_CFLAGS=\"${CFLAGS}\"\nJE_CFLAGS_APPEND([-Werror])\nJE_COMPILABLE([alloc_size attribute], [#include <stdlib.h>],\n              [void *foo(size_t size) __attribute__((alloc_size(1)));],\n              [je_cv_alloc_size])\nCFLAGS=\"${SAVED_CFLAGS}\"\nif test \"x${je_cv_alloc_size}\" = \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_HAVE_ATTR_ALLOC_SIZE], [ ])\nfi\ndnl Check for format(gnu_printf, ...) attribute support.\nSAVED_CFLAGS=\"${CFLAGS}\"\nJE_CFLAGS_APPEND([-Werror])\nJE_COMPILABLE([format(gnu_printf, ...) attribute], [#include <stdlib.h>],\n              [void *foo(const char *format, ...) __attribute__((format(gnu_printf, 1, 2)));],\n              [je_cv_format_gnu_printf])\nCFLAGS=\"${SAVED_CFLAGS}\"\nif test \"x${je_cv_format_gnu_printf}\" = \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_HAVE_ATTR_FORMAT_GNU_PRINTF], [ ])\nfi\ndnl Check for format(printf, ...) attribute support.\nSAVED_CFLAGS=\"${CFLAGS}\"\nJE_CFLAGS_APPEND([-Werror])\nJE_COMPILABLE([format(printf, ...) attribute], [#include <stdlib.h>],\n              [void *foo(const char *format, ...) __attribute__((format(printf, 1, 2)));],\n              [je_cv_format_printf])\nCFLAGS=\"${SAVED_CFLAGS}\"\nif test \"x${je_cv_format_printf}\" = \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_HAVE_ATTR_FORMAT_PRINTF], [ ])\nfi\n\ndnl Support optional additions to rpath.\nAC_ARG_WITH([rpath],\n  [AS_HELP_STRING([--with-rpath=<rpath>], [Colon-separated rpath (ELF systems only)])],\nif test \"x$with_rpath\" = \"xno\" ; then\n  RPATH_EXTRA=\nelse\n  RPATH_EXTRA=\"`echo $with_rpath | tr \\\":\\\" \\\" \\\"`\"\nfi,\n  RPATH_EXTRA=\n)\nAC_SUBST([RPATH_EXTRA])\n\ndnl Disable rules that do automatic regeneration of configure output by default.\nAC_ARG_ENABLE([autogen],\n  [AS_HELP_STRING([--enable-autogen], [Automatically regenerate configure output])],\nif test \"x$enable_autogen\" = \"xno\" ; then\n  enable_autogen=\"0\"\nelse\n  enable_autogen=\"1\"\nfi\n,\nenable_autogen=\"0\"\n)\nAC_SUBST([enable_autogen])\n\nAC_PROG_INSTALL\nAC_PROG_RANLIB\nAC_PATH_PROG([LD], [ld], [false], [$PATH])\nAC_PATH_PROG([AUTOCONF], [autoconf], [false], [$PATH])\n\npublic_syms=\"malloc_conf malloc_message malloc calloc posix_memalign aligned_alloc realloc free mallocx rallocx xallocx sallocx dallocx sdallocx nallocx mallctl mallctlnametomib mallctlbymib malloc_stats_print malloc_usable_size\"\n\ndnl Check for allocator-related functions that should be wrapped.\nAC_CHECK_FUNC([memalign],\n\t      [AC_DEFINE([JEMALLOC_OVERRIDE_MEMALIGN], [ ])\n\t       public_syms=\"${public_syms} memalign\"])\nAC_CHECK_FUNC([valloc],\n\t      [AC_DEFINE([JEMALLOC_OVERRIDE_VALLOC], [ ])\n\t       public_syms=\"${public_syms} valloc\"])\n\ndnl Do not compute test code coverage by default.\nGCOV_FLAGS=\nAC_ARG_ENABLE([code-coverage],\n  [AS_HELP_STRING([--enable-code-coverage],\n   [Enable code coverage])],\n[if test \"x$enable_code_coverage\" = \"xno\" ; then\n  enable_code_coverage=\"0\"\nelse\n  enable_code_coverage=\"1\"\nfi\n],\n[enable_code_coverage=\"0\"]\n)\nif test \"x$enable_code_coverage\" = \"x1\" ; then\n  deoptimize=\"no\"\n  echo \"$CFLAGS $EXTRA_CFLAGS\" | grep '\\-O' >/dev/null || deoptimize=\"yes\"\n  if test \"x${deoptimize}\" = \"xyes\" ; then\n    JE_CFLAGS_APPEND([-O0])\n  fi\n  JE_CFLAGS_APPEND([-fprofile-arcs -ftest-coverage])\n  EXTRA_LDFLAGS=\"$EXTRA_LDFLAGS -fprofile-arcs -ftest-coverage\"\n  AC_DEFINE([JEMALLOC_CODE_COVERAGE], [ ])\nfi\nAC_SUBST([enable_code_coverage])\n\ndnl Perform no name mangling by default.\nAC_ARG_WITH([mangling],\n  [AS_HELP_STRING([--with-mangling=<map>], [Mangle symbols in <map>])],\n  [mangling_map=\"$with_mangling\"], [mangling_map=\"\"])\n\ndnl Do not prefix public APIs by default.\nAC_ARG_WITH([jemalloc_prefix],\n  [AS_HELP_STRING([--with-jemalloc-prefix=<prefix>], [Prefix to prepend to all public APIs])],\n  [JEMALLOC_PREFIX=\"$with_jemalloc_prefix\"],\n  [if test \"x$abi\" != \"xmacho\" -a \"x$abi\" != \"xpecoff\"; then\n  JEMALLOC_PREFIX=\"\"\nelse\n  JEMALLOC_PREFIX=\"je_\"\nfi]\n)\nif test \"x$JEMALLOC_PREFIX\" != \"x\" ; then\n  JEMALLOC_CPREFIX=`echo ${JEMALLOC_PREFIX} | tr \"a-z\" \"A-Z\"`\n  AC_DEFINE_UNQUOTED([JEMALLOC_PREFIX], [\"$JEMALLOC_PREFIX\"])\n  AC_DEFINE_UNQUOTED([JEMALLOC_CPREFIX], [\"$JEMALLOC_CPREFIX\"])\nfi\nAC_SUBST([JEMALLOC_CPREFIX])\n\nAC_ARG_WITH([export],\n  [AS_HELP_STRING([--without-export], [disable exporting jemalloc public APIs])],\n  [if test \"x$with_export\" = \"xno\"; then\n  AC_DEFINE([JEMALLOC_EXPORT],[])\nfi]\n)\n\ndnl Mangle library-private APIs.\nAC_ARG_WITH([private_namespace],\n  [AS_HELP_STRING([--with-private-namespace=<prefix>], [Prefix to prepend to all library-private APIs])],\n  [JEMALLOC_PRIVATE_NAMESPACE=\"${with_private_namespace}je_\"],\n  [JEMALLOC_PRIVATE_NAMESPACE=\"je_\"]\n)\nAC_DEFINE_UNQUOTED([JEMALLOC_PRIVATE_NAMESPACE], [$JEMALLOC_PRIVATE_NAMESPACE])\nprivate_namespace=\"$JEMALLOC_PRIVATE_NAMESPACE\"\nAC_SUBST([private_namespace])\n\ndnl Do not add suffix to installed files by default.\nAC_ARG_WITH([install_suffix],\n  [AS_HELP_STRING([--with-install-suffix=<suffix>], [Suffix to append to all installed files])],\n  [INSTALL_SUFFIX=\"$with_install_suffix\"],\n  [INSTALL_SUFFIX=]\n)\ninstall_suffix=\"$INSTALL_SUFFIX\"\nAC_SUBST([install_suffix])\n\ndnl Substitute @je_@ in jemalloc_protos.h.in, primarily to make generation of\ndnl jemalloc_protos_jet.h easy.\nje_=\"je_\"\nAC_SUBST([je_])\n\ncfgoutputs_in=\"Makefile.in\"\ncfgoutputs_in=\"${cfgoutputs_in} jemalloc.pc.in\"\ncfgoutputs_in=\"${cfgoutputs_in} doc/html.xsl.in\"\ncfgoutputs_in=\"${cfgoutputs_in} doc/manpages.xsl.in\"\ncfgoutputs_in=\"${cfgoutputs_in} doc/jemalloc.xml.in\"\ncfgoutputs_in=\"${cfgoutputs_in} include/jemalloc/jemalloc_macros.h.in\"\ncfgoutputs_in=\"${cfgoutputs_in} include/jemalloc/jemalloc_protos.h.in\"\ncfgoutputs_in=\"${cfgoutputs_in} include/jemalloc/jemalloc_typedefs.h.in\"\ncfgoutputs_in=\"${cfgoutputs_in} include/jemalloc/internal/jemalloc_internal.h.in\"\ncfgoutputs_in=\"${cfgoutputs_in} test/test.sh.in\"\ncfgoutputs_in=\"${cfgoutputs_in} test/include/test/jemalloc_test.h.in\"\n\ncfgoutputs_out=\"Makefile\"\ncfgoutputs_out=\"${cfgoutputs_out} jemalloc.pc\"\ncfgoutputs_out=\"${cfgoutputs_out} doc/html.xsl\"\ncfgoutputs_out=\"${cfgoutputs_out} doc/manpages.xsl\"\ncfgoutputs_out=\"${cfgoutputs_out} doc/jemalloc.xml\"\ncfgoutputs_out=\"${cfgoutputs_out} include/jemalloc/jemalloc_macros.h\"\ncfgoutputs_out=\"${cfgoutputs_out} include/jemalloc/jemalloc_protos.h\"\ncfgoutputs_out=\"${cfgoutputs_out} include/jemalloc/jemalloc_typedefs.h\"\ncfgoutputs_out=\"${cfgoutputs_out} include/jemalloc/internal/jemalloc_internal.h\"\ncfgoutputs_out=\"${cfgoutputs_out} test/test.sh\"\ncfgoutputs_out=\"${cfgoutputs_out} test/include/test/jemalloc_test.h\"\n\ncfgoutputs_tup=\"Makefile\"\ncfgoutputs_tup=\"${cfgoutputs_tup} jemalloc.pc:jemalloc.pc.in\"\ncfgoutputs_tup=\"${cfgoutputs_tup} doc/html.xsl:doc/html.xsl.in\"\ncfgoutputs_tup=\"${cfgoutputs_tup} doc/manpages.xsl:doc/manpages.xsl.in\"\ncfgoutputs_tup=\"${cfgoutputs_tup} doc/jemalloc.xml:doc/jemalloc.xml.in\"\ncfgoutputs_tup=\"${cfgoutputs_tup} include/jemalloc/jemalloc_macros.h:include/jemalloc/jemalloc_macros.h.in\"\ncfgoutputs_tup=\"${cfgoutputs_tup} include/jemalloc/jemalloc_protos.h:include/jemalloc/jemalloc_protos.h.in\"\ncfgoutputs_tup=\"${cfgoutputs_tup} include/jemalloc/jemalloc_typedefs.h:include/jemalloc/jemalloc_typedefs.h.in\"\ncfgoutputs_tup=\"${cfgoutputs_tup} include/jemalloc/internal/jemalloc_internal.h\"\ncfgoutputs_tup=\"${cfgoutputs_tup} test/test.sh:test/test.sh.in\"\ncfgoutputs_tup=\"${cfgoutputs_tup} test/include/test/jemalloc_test.h:test/include/test/jemalloc_test.h.in\"\n\ncfghdrs_in=\"include/jemalloc/jemalloc_defs.h.in\"\ncfghdrs_in=\"${cfghdrs_in} include/jemalloc/internal/jemalloc_internal_defs.h.in\"\ncfghdrs_in=\"${cfghdrs_in} include/jemalloc/internal/private_namespace.sh\"\ncfghdrs_in=\"${cfghdrs_in} include/jemalloc/internal/private_unnamespace.sh\"\ncfghdrs_in=\"${cfghdrs_in} include/jemalloc/internal/private_symbols.txt\"\ncfghdrs_in=\"${cfghdrs_in} include/jemalloc/internal/public_namespace.sh\"\ncfghdrs_in=\"${cfghdrs_in} include/jemalloc/internal/public_unnamespace.sh\"\ncfghdrs_in=\"${cfghdrs_in} include/jemalloc/internal/size_classes.sh\"\ncfghdrs_in=\"${cfghdrs_in} include/jemalloc/jemalloc_rename.sh\"\ncfghdrs_in=\"${cfghdrs_in} include/jemalloc/jemalloc_mangle.sh\"\ncfghdrs_in=\"${cfghdrs_in} include/jemalloc/jemalloc.sh\"\ncfghdrs_in=\"${cfghdrs_in} test/include/test/jemalloc_test_defs.h.in\"\n\ncfghdrs_out=\"include/jemalloc/jemalloc_defs.h\"\ncfghdrs_out=\"${cfghdrs_out} include/jemalloc/jemalloc${install_suffix}.h\"\ncfghdrs_out=\"${cfghdrs_out} include/jemalloc/internal/private_namespace.h\"\ncfghdrs_out=\"${cfghdrs_out} include/jemalloc/internal/private_unnamespace.h\"\ncfghdrs_out=\"${cfghdrs_out} include/jemalloc/internal/public_symbols.txt\"\ncfghdrs_out=\"${cfghdrs_out} include/jemalloc/internal/public_namespace.h\"\ncfghdrs_out=\"${cfghdrs_out} include/jemalloc/internal/public_unnamespace.h\"\ncfghdrs_out=\"${cfghdrs_out} include/jemalloc/internal/size_classes.h\"\ncfghdrs_out=\"${cfghdrs_out} include/jemalloc/jemalloc_protos_jet.h\"\ncfghdrs_out=\"${cfghdrs_out} include/jemalloc/jemalloc_rename.h\"\ncfghdrs_out=\"${cfghdrs_out} include/jemalloc/jemalloc_mangle.h\"\ncfghdrs_out=\"${cfghdrs_out} include/jemalloc/jemalloc_mangle_jet.h\"\ncfghdrs_out=\"${cfghdrs_out} include/jemalloc/internal/jemalloc_internal_defs.h\"\ncfghdrs_out=\"${cfghdrs_out} test/include/test/jemalloc_test_defs.h\"\n\ncfghdrs_tup=\"include/jemalloc/jemalloc_defs.h:include/jemalloc/jemalloc_defs.h.in\"\ncfghdrs_tup=\"${cfghdrs_tup} include/jemalloc/internal/jemalloc_internal_defs.h:include/jemalloc/internal/jemalloc_internal_defs.h.in\"\ncfghdrs_tup=\"${cfghdrs_tup} test/include/test/jemalloc_test_defs.h:test/include/test/jemalloc_test_defs.h.in\"\n\ndnl Silence irrelevant compiler warnings by default.\nAC_ARG_ENABLE([cc-silence],\n  [AS_HELP_STRING([--disable-cc-silence],\n                  [Do not silence irrelevant compiler warnings])],\n[if test \"x$enable_cc_silence\" = \"xno\" ; then\n  enable_cc_silence=\"0\"\nelse\n  enable_cc_silence=\"1\"\nfi\n],\n[enable_cc_silence=\"1\"]\n)\nif test \"x$enable_cc_silence\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_CC_SILENCE], [ ])\nfi\n\ndnl Do not compile with debugging by default.\nAC_ARG_ENABLE([debug],\n  [AS_HELP_STRING([--enable-debug],\n                  [Build debugging code (implies --enable-ivsalloc)])],\n[if test \"x$enable_debug\" = \"xno\" ; then\n  enable_debug=\"0\"\nelse\n  enable_debug=\"1\"\nfi\n],\n[enable_debug=\"0\"]\n)\nif test \"x$enable_debug\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_DEBUG], [ ])\nfi\nif test \"x$enable_debug\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_DEBUG], [ ])\n  enable_ivsalloc=\"1\"\nfi\nAC_SUBST([enable_debug])\n\ndnl Do not validate pointers by default.\nAC_ARG_ENABLE([ivsalloc],\n  [AS_HELP_STRING([--enable-ivsalloc],\n                  [Validate pointers passed through the public API])],\n[if test \"x$enable_ivsalloc\" = \"xno\" ; then\n  enable_ivsalloc=\"0\"\nelse\n  enable_ivsalloc=\"1\"\nfi\n],\n[enable_ivsalloc=\"0\"]\n)\nif test \"x$enable_ivsalloc\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_IVSALLOC], [ ])\nfi\n\ndnl Only optimize if not debugging.\nif test \"x$enable_debug\" = \"x0\" -a \"x$no_CFLAGS\" = \"xyes\" ; then\n  dnl Make sure that an optimization flag was not specified in EXTRA_CFLAGS.\n  optimize=\"no\"\n  echo \"$CFLAGS $EXTRA_CFLAGS\" | grep '\\-O' >/dev/null || optimize=\"yes\"\n  if test \"x${optimize}\" = \"xyes\" ; then\n    if test \"x$GCC\" = \"xyes\" ; then\n      JE_CFLAGS_APPEND([-O3])\n      JE_CFLAGS_APPEND([-funroll-loops])\n    elif test \"x$je_cv_msvc\" = \"xyes\" ; then\n      JE_CFLAGS_APPEND([-O2])\n    else\n      JE_CFLAGS_APPEND([-O])\n    fi\n  fi\nfi\n\ndnl Enable statistics calculation by default.\nAC_ARG_ENABLE([stats],\n  [AS_HELP_STRING([--disable-stats],\n                  [Disable statistics calculation/reporting])],\n[if test \"x$enable_stats\" = \"xno\" ; then\n  enable_stats=\"0\"\nelse\n  enable_stats=\"1\"\nfi\n],\n[enable_stats=\"1\"]\n)\nif test \"x$enable_stats\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_STATS], [ ])\nfi\nAC_SUBST([enable_stats])\n\ndnl Do not enable profiling by default.\nAC_ARG_ENABLE([prof],\n  [AS_HELP_STRING([--enable-prof], [Enable allocation profiling])],\n[if test \"x$enable_prof\" = \"xno\" ; then\n  enable_prof=\"0\"\nelse\n  enable_prof=\"1\"\nfi\n],\n[enable_prof=\"0\"]\n)\nif test \"x$enable_prof\" = \"x1\" ; then\n  backtrace_method=\"\"\nelse\n  backtrace_method=\"N/A\"\nfi\n\nAC_ARG_ENABLE([prof-libunwind],\n  [AS_HELP_STRING([--enable-prof-libunwind], [Use libunwind for backtracing])],\n[if test \"x$enable_prof_libunwind\" = \"xno\" ; then\n  enable_prof_libunwind=\"0\"\nelse\n  enable_prof_libunwind=\"1\"\nfi\n],\n[enable_prof_libunwind=\"0\"]\n)\nAC_ARG_WITH([static_libunwind],\n  [AS_HELP_STRING([--with-static-libunwind=<libunwind.a>],\n  [Path to static libunwind library; use rather than dynamically linking])],\nif test \"x$with_static_libunwind\" = \"xno\" ; then\n  LUNWIND=\"-lunwind\"\nelse\n  if test ! -f \"$with_static_libunwind\" ; then\n    AC_MSG_ERROR([Static libunwind not found: $with_static_libunwind])\n  fi\n  LUNWIND=\"$with_static_libunwind\"\nfi,\n  LUNWIND=\"-lunwind\"\n)\nif test \"x$backtrace_method\" = \"x\" -a \"x$enable_prof_libunwind\" = \"x1\" ; then\n  AC_CHECK_HEADERS([libunwind.h], , [enable_prof_libunwind=\"0\"])\n  if test \"x$LUNWIND\" = \"x-lunwind\" ; then\n    AC_CHECK_LIB([unwind], [unw_backtrace], [LIBS=\"$LIBS $LUNWIND\"],\n                 [enable_prof_libunwind=\"0\"])\n  else\n    LIBS=\"$LIBS $LUNWIND\"\n  fi\n  if test \"x${enable_prof_libunwind}\" = \"x1\" ; then\n    backtrace_method=\"libunwind\"\n    AC_DEFINE([JEMALLOC_PROF_LIBUNWIND], [ ])\n  fi\nfi\n\nAC_ARG_ENABLE([prof-libgcc],\n  [AS_HELP_STRING([--disable-prof-libgcc],\n  [Do not use libgcc for backtracing])],\n[if test \"x$enable_prof_libgcc\" = \"xno\" ; then\n  enable_prof_libgcc=\"0\"\nelse\n  enable_prof_libgcc=\"1\"\nfi\n],\n[enable_prof_libgcc=\"1\"]\n)\nif test \"x$backtrace_method\" = \"x\" -a \"x$enable_prof_libgcc\" = \"x1\" \\\n     -a \"x$GCC\" = \"xyes\" ; then\n  AC_CHECK_HEADERS([unwind.h], , [enable_prof_libgcc=\"0\"])\n  AC_CHECK_LIB([gcc], [_Unwind_Backtrace], [LIBS=\"$LIBS -lgcc\"], [enable_prof_libgcc=\"0\"])\n  if test \"x${enable_prof_libgcc}\" = \"x1\" ; then\n    backtrace_method=\"libgcc\"\n    AC_DEFINE([JEMALLOC_PROF_LIBGCC], [ ])\n  fi\nelse\n  enable_prof_libgcc=\"0\"\nfi\n\nAC_ARG_ENABLE([prof-gcc],\n  [AS_HELP_STRING([--disable-prof-gcc],\n  [Do not use gcc intrinsics for backtracing])],\n[if test \"x$enable_prof_gcc\" = \"xno\" ; then\n  enable_prof_gcc=\"0\"\nelse\n  enable_prof_gcc=\"1\"\nfi\n],\n[enable_prof_gcc=\"1\"]\n)\nif test \"x$backtrace_method\" = \"x\" -a \"x$enable_prof_gcc\" = \"x1\" \\\n     -a \"x$GCC\" = \"xyes\" ; then\n  JE_CFLAGS_APPEND([-fno-omit-frame-pointer])\n  backtrace_method=\"gcc intrinsics\"\n  AC_DEFINE([JEMALLOC_PROF_GCC], [ ])\nelse\n  enable_prof_gcc=\"0\"\nfi\n\nif test \"x$backtrace_method\" = \"x\" ; then\n  backtrace_method=\"none (disabling profiling)\"\n  enable_prof=\"0\"\nfi\nAC_MSG_CHECKING([configured backtracing method])\nAC_MSG_RESULT([$backtrace_method])\nif test \"x$enable_prof\" = \"x1\" ; then\n  if test \"x$abi\" != \"xpecoff\"; then\n    dnl Heap profiling uses the log(3) function.\n    LIBS=\"$LIBS -lm\"\n  fi\n\n  AC_DEFINE([JEMALLOC_PROF], [ ])\nfi\nAC_SUBST([enable_prof])\n\ndnl Enable thread-specific caching by default.\nAC_ARG_ENABLE([tcache],\n  [AS_HELP_STRING([--disable-tcache], [Disable per thread caches])],\n[if test \"x$enable_tcache\" = \"xno\" ; then\n  enable_tcache=\"0\"\nelse\n  enable_tcache=\"1\"\nfi\n],\n[enable_tcache=\"1\"]\n)\nif test \"x$enable_tcache\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_TCACHE], [ ])\nfi\nAC_SUBST([enable_tcache])\n\ndnl Indicate whether adjacent virtual memory mappings automatically coalesce\ndnl (and fragment on demand).\nif test \"x${maps_coalesce}\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_MAPS_COALESCE], [ ])\nfi\n\ndnl Enable VM deallocation via munmap() by default.\nAC_ARG_ENABLE([munmap],\n  [AS_HELP_STRING([--disable-munmap], [Disable VM deallocation via munmap(2)])],\n[if test \"x$enable_munmap\" = \"xno\" ; then\n  enable_munmap=\"0\"\nelse\n  enable_munmap=\"1\"\nfi\n],\n[enable_munmap=\"${default_munmap}\"]\n)\nif test \"x$enable_munmap\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_MUNMAP], [ ])\nfi\nAC_SUBST([enable_munmap])\n\ndnl Enable allocation from DSS if supported by the OS.\nhave_dss=\"1\"\ndnl Check whether the BSD/SUSv1 sbrk() exists.  If not, disable DSS support.\nAC_CHECK_FUNC([sbrk], [have_sbrk=\"1\"], [have_sbrk=\"0\"])\nif test \"x$have_sbrk\" = \"x1\" ; then\n  if test \"x$sbrk_deprecated\" = \"x1\" ; then\n    AC_MSG_RESULT([Disabling dss allocation because sbrk is deprecated])\n    have_dss=\"0\"\n  fi\nelse\n  have_dss=\"0\"\nfi\n\nif test \"x$have_dss\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_DSS], [ ])\nfi\n\ndnl Support the junk/zero filling option by default.\nAC_ARG_ENABLE([fill],\n  [AS_HELP_STRING([--disable-fill],\n                  [Disable support for junk/zero filling, quarantine, and redzones])],\n[if test \"x$enable_fill\" = \"xno\" ; then\n  enable_fill=\"0\"\nelse\n  enable_fill=\"1\"\nfi\n],\n[enable_fill=\"1\"]\n)\nif test \"x$enable_fill\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_FILL], [ ])\nfi\nAC_SUBST([enable_fill])\n\ndnl Disable utrace(2)-based tracing by default.\nAC_ARG_ENABLE([utrace],\n  [AS_HELP_STRING([--enable-utrace], [Enable utrace(2)-based tracing])],\n[if test \"x$enable_utrace\" = \"xno\" ; then\n  enable_utrace=\"0\"\nelse\n  enable_utrace=\"1\"\nfi\n],\n[enable_utrace=\"0\"]\n)\nJE_COMPILABLE([utrace(2)], [\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/time.h>\n#include <sys/uio.h>\n#include <sys/ktrace.h>\n], [\n\tutrace((void *)0, 0);\n], [je_cv_utrace])\nif test \"x${je_cv_utrace}\" = \"xno\" ; then\n  enable_utrace=\"0\"\nfi\nif test \"x$enable_utrace\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_UTRACE], [ ])\nfi\nAC_SUBST([enable_utrace])\n\ndnl Support Valgrind by default.\nAC_ARG_ENABLE([valgrind],\n  [AS_HELP_STRING([--disable-valgrind], [Disable support for Valgrind])],\n[if test \"x$enable_valgrind\" = \"xno\" ; then\n  enable_valgrind=\"0\"\nelse\n  enable_valgrind=\"1\"\nfi\n],\n[enable_valgrind=\"1\"]\n)\nif test \"x$enable_valgrind\" = \"x1\" ; then\n  JE_COMPILABLE([valgrind], [\n#include <valgrind/valgrind.h>\n#include <valgrind/memcheck.h>\n\n#if !defined(VALGRIND_RESIZEINPLACE_BLOCK)\n#  error \"Incompatible Valgrind version\"\n#endif\n], [], [je_cv_valgrind])\n  if test \"x${je_cv_valgrind}\" = \"xno\" ; then\n    enable_valgrind=\"0\"\n  fi\n  if test \"x$enable_valgrind\" = \"x1\" ; then\n    AC_DEFINE([JEMALLOC_VALGRIND], [ ])\n  fi\nfi\nAC_SUBST([enable_valgrind])\n\ndnl Do not support the xmalloc option by default.\nAC_ARG_ENABLE([xmalloc],\n  [AS_HELP_STRING([--enable-xmalloc], [Support xmalloc option])],\n[if test \"x$enable_xmalloc\" = \"xno\" ; then\n  enable_xmalloc=\"0\"\nelse\n  enable_xmalloc=\"1\"\nfi\n],\n[enable_xmalloc=\"0\"]\n)\nif test \"x$enable_xmalloc\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_XMALLOC], [ ])\nfi\nAC_SUBST([enable_xmalloc])\n\ndnl Support cache-oblivious allocation alignment by default.\nAC_ARG_ENABLE([cache-oblivious],\n  [AS_HELP_STRING([--disable-cache-oblivious],\n                  [Disable support for cache-oblivious allocation alignment])],\n[if test \"x$enable_cache_oblivious\" = \"xno\" ; then\n  enable_cache_oblivious=\"0\"\nelse\n  enable_cache_oblivious=\"1\"\nfi\n],\n[enable_cache_oblivious=\"1\"]\n)\nif test \"x$enable_cache_oblivious\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_CACHE_OBLIVIOUS], [ ])\nfi\nAC_SUBST([enable_cache_oblivious])\n\ndnl ============================================================================\ndnl Check for  __builtin_ffsl(), then ffsl(3), and fail if neither are found.\ndnl One of those two functions should (theoretically) exist on all platforms\ndnl that jemalloc currently has a chance of functioning on without modification.\ndnl We additionally assume ffs() or __builtin_ffs() are defined if\ndnl ffsl() or __builtin_ffsl() are defined, respectively.\nJE_COMPILABLE([a program using __builtin_ffsl], [\n#include <stdio.h>\n#include <strings.h>\n#include <string.h>\n], [\n\t{\n\t\tint rv = __builtin_ffsl(0x08);\n\t\tprintf(\"%d\\n\", rv);\n\t}\n], [je_cv_gcc_builtin_ffsl])\nif test \"x${je_cv_gcc_builtin_ffsl}\" = \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_INTERNAL_FFSL], [__builtin_ffsl])\n  AC_DEFINE([JEMALLOC_INTERNAL_FFS], [__builtin_ffs])\nelse\n  JE_COMPILABLE([a program using ffsl], [\n  #include <stdio.h>\n  #include <strings.h>\n  #include <string.h>\n  ], [\n\t{\n\t\tint rv = ffsl(0x08);\n\t\tprintf(\"%d\\n\", rv);\n\t}\n  ], [je_cv_function_ffsl])\n  if test \"x${je_cv_function_ffsl}\" = \"xyes\" ; then\n    AC_DEFINE([JEMALLOC_INTERNAL_FFSL], [ffsl])\n    AC_DEFINE([JEMALLOC_INTERNAL_FFS], [ffs])\n  else\n    AC_MSG_ERROR([Cannot build without ffsl(3) or __builtin_ffsl()])\n  fi\nfi\n\nAC_ARG_WITH([lg_tiny_min],\n  [AS_HELP_STRING([--with-lg-tiny-min=<lg-tiny-min>],\n   [Base 2 log of minimum tiny size class to support])],\n  [LG_TINY_MIN=\"$with_lg_tiny_min\"],\n  [LG_TINY_MIN=\"3\"])\nAC_DEFINE_UNQUOTED([LG_TINY_MIN], [$LG_TINY_MIN])\n\nAC_ARG_WITH([lg_quantum],\n  [AS_HELP_STRING([--with-lg-quantum=<lg-quantum>],\n   [Base 2 log of minimum allocation alignment])],\n  [LG_QUANTA=\"$with_lg_quantum\"],\n  [LG_QUANTA=\"3 4\"])\nif test \"x$with_lg_quantum\" != \"x\" ; then\n  AC_DEFINE_UNQUOTED([LG_QUANTUM], [$with_lg_quantum])\nfi\n\nAC_ARG_WITH([lg_page],\n  [AS_HELP_STRING([--with-lg-page=<lg-page>], [Base 2 log of system page size])],\n  [LG_PAGE=\"$with_lg_page\"], [LG_PAGE=\"detect\"])\nif test \"x$LG_PAGE\" = \"xdetect\"; then\n  AC_CACHE_CHECK([LG_PAGE],\n               [je_cv_lg_page],\n               AC_RUN_IFELSE([AC_LANG_PROGRAM(\n[[\n#include <strings.h>\n#ifdef _WIN32\n#include <windows.h>\n#else\n#include <unistd.h>\n#endif\n#include <stdio.h>\n]],\n[[\n    int result;\n    FILE *f;\n\n#ifdef _WIN32\n    SYSTEM_INFO si;\n    GetSystemInfo(&si);\n    result = si.dwPageSize;\n#else\n    result = sysconf(_SC_PAGESIZE);\n#endif\n    if (result == -1) {\n\treturn 1;\n    }\n    result = JEMALLOC_INTERNAL_FFSL(result) - 1;\n\n    f = fopen(\"conftest.out\", \"w\");\n    if (f == NULL) {\n\treturn 1;\n    }\n    fprintf(f, \"%d\\n\", result);\n    fclose(f);\n\n    return 0;\n]])],\n                             [je_cv_lg_page=`cat conftest.out`],\n                             [je_cv_lg_page=undefined],\n                             [je_cv_lg_page=12]))\nfi\nif test \"x${je_cv_lg_page}\" != \"x\" ; then\n  LG_PAGE=\"${je_cv_lg_page}\"\nfi\nif test \"x${LG_PAGE}\" != \"xundefined\" ; then\n   AC_DEFINE_UNQUOTED([LG_PAGE], [$LG_PAGE])\nelse\n   AC_MSG_ERROR([cannot determine value for LG_PAGE])\nfi\n\nAC_ARG_WITH([lg_page_sizes],\n  [AS_HELP_STRING([--with-lg-page-sizes=<lg-page-sizes>],\n   [Base 2 logs of system page sizes to support])],\n  [LG_PAGE_SIZES=\"$with_lg_page_sizes\"], [LG_PAGE_SIZES=\"$LG_PAGE\"])\n\nAC_ARG_WITH([lg_size_class_group],\n  [AS_HELP_STRING([--with-lg-size-class-group=<lg-size-class-group>],\n   [Base 2 log of size classes per doubling])],\n  [LG_SIZE_CLASS_GROUP=\"$with_lg_size_class_group\"],\n  [LG_SIZE_CLASS_GROUP=\"2\"])\n\ndnl ============================================================================\ndnl jemalloc configuration.\ndnl \n\ndnl Set VERSION if source directory is inside a git repository.\nif test \"x`test ! \\\"${srcroot}\\\" && cd \\\"${srcroot}\\\"; git rev-parse --is-inside-work-tree 2>/dev/null`\" = \"xtrue\" ; then\n  dnl Pattern globs aren't powerful enough to match both single- and\n  dnl double-digit version numbers, so iterate over patterns to support up to\n  dnl version 99.99.99 without any accidental matches.\n  rm -f \"${objroot}VERSION\"\n  for pattern in ['[0-9].[0-9].[0-9]' '[0-9].[0-9].[0-9][0-9]' \\\n                 '[0-9].[0-9][0-9].[0-9]' '[0-9].[0-9][0-9].[0-9][0-9]' \\\n                 '[0-9][0-9].[0-9].[0-9]' '[0-9][0-9].[0-9].[0-9][0-9]' \\\n                 '[0-9][0-9].[0-9][0-9].[0-9]' \\\n                 '[0-9][0-9].[0-9][0-9].[0-9][0-9]']; do\n    if test ! -e \"${objroot}VERSION\" ; then\n      (test ! \"${srcroot}\" && cd \"${srcroot}\"; git describe --long --abbrev=40 --match=\"${pattern}\") > \"${objroot}VERSION.tmp\" 2>/dev/null\n      if test $? -eq 0 ; then\n        mv \"${objroot}VERSION.tmp\" \"${objroot}VERSION\"\n        break\n      fi\n    fi\n  done\nfi\nrm -f \"${objroot}VERSION.tmp\"\nif test ! -e \"${objroot}VERSION\" ; then\n  if test ! -e \"${srcroot}VERSION\" ; then\n    AC_MSG_RESULT(\n      [Missing VERSION file, and unable to generate it; creating bogus VERSION])\n    echo \"0.0.0-0-g0000000000000000000000000000000000000000\" > \"${objroot}VERSION\"\n  else\n    cp ${srcroot}VERSION ${objroot}VERSION\n  fi\nfi\njemalloc_version=`cat \"${objroot}VERSION\"`\njemalloc_version_major=`echo ${jemalloc_version} | tr \".g-\" \" \" | awk '{print [$]1}'`\njemalloc_version_minor=`echo ${jemalloc_version} | tr \".g-\" \" \" | awk '{print [$]2}'`\njemalloc_version_bugfix=`echo ${jemalloc_version} | tr \".g-\" \" \" | awk '{print [$]3}'`\njemalloc_version_nrev=`echo ${jemalloc_version} | tr \".g-\" \" \" | awk '{print [$]4}'`\njemalloc_version_gid=`echo ${jemalloc_version} | tr \".g-\" \" \" | awk '{print [$]5}'`\nAC_SUBST([jemalloc_version])\nAC_SUBST([jemalloc_version_major])\nAC_SUBST([jemalloc_version_minor])\nAC_SUBST([jemalloc_version_bugfix])\nAC_SUBST([jemalloc_version_nrev])\nAC_SUBST([jemalloc_version_gid])\n\ndnl ============================================================================\ndnl Configure pthreads.\n\nif test \"x$abi\" != \"xpecoff\" ; then\n  AC_CHECK_HEADERS([pthread.h], , [AC_MSG_ERROR([pthread.h is missing])])\n  dnl Some systems may embed pthreads functionality in libc; check for libpthread\n  dnl first, but try libc too before failing.\n  AC_CHECK_LIB([pthread], [pthread_create], [LIBS=\"$LIBS -lpthread\"],\n               [AC_SEARCH_LIBS([pthread_create], , ,\n                               AC_MSG_ERROR([libpthread is missing]))])\nfi\n\nCPPFLAGS=\"$CPPFLAGS -D_REENTRANT\"\n\ndnl Check whether clock_gettime(2) is in libc or librt.  This function is only\ndnl used in test code, so save the result to TESTLIBS to avoid poluting LIBS.\nSAVED_LIBS=\"${LIBS}\"\nLIBS=\nAC_SEARCH_LIBS([clock_gettime], [rt], [TESTLIBS=\"${LIBS}\"])\nAC_SUBST([TESTLIBS])\nLIBS=\"${SAVED_LIBS}\"\n\ndnl Check if the GNU-specific secure_getenv function exists.\nAC_CHECK_FUNC([secure_getenv],\n              [have_secure_getenv=\"1\"],\n              [have_secure_getenv=\"0\"]\n             )\nif test \"x$have_secure_getenv\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_HAVE_SECURE_GETENV], [ ])\nfi\n\ndnl Check if the Solaris/BSD issetugid function exists.\nAC_CHECK_FUNC([issetugid],\n              [have_issetugid=\"1\"],\n              [have_issetugid=\"0\"]\n             )\nif test \"x$have_issetugid\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_HAVE_ISSETUGID], [ ])\nfi\n\ndnl Check whether the BSD-specific _malloc_thread_cleanup() exists.  If so, use\ndnl it rather than pthreads TSD cleanup functions to support cleanup during\ndnl thread exit, in order to avoid pthreads library recursion during\ndnl bootstrapping.\nAC_CHECK_FUNC([_malloc_thread_cleanup],\n              [have__malloc_thread_cleanup=\"1\"],\n              [have__malloc_thread_cleanup=\"0\"]\n             )\nif test \"x$have__malloc_thread_cleanup\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_MALLOC_THREAD_CLEANUP], [ ])\n  force_tls=\"1\"\nfi\n\ndnl Check whether the BSD-specific _pthread_mutex_init_calloc_cb() exists.  If\ndnl so, mutex initialization causes allocation, and we need to implement this\ndnl callback function in order to prevent recursive allocation.\nAC_CHECK_FUNC([_pthread_mutex_init_calloc_cb],\n              [have__pthread_mutex_init_calloc_cb=\"1\"],\n              [have__pthread_mutex_init_calloc_cb=\"0\"]\n             )\nif test \"x$have__pthread_mutex_init_calloc_cb\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_MUTEX_INIT_CB])\nfi\n\ndnl Disable lazy locking by default.\nAC_ARG_ENABLE([lazy_lock],\n  [AS_HELP_STRING([--enable-lazy-lock],\n  [Enable lazy locking (only lock when multi-threaded)])],\n[if test \"x$enable_lazy_lock\" = \"xno\" ; then\n  enable_lazy_lock=\"0\"\nelse\n  enable_lazy_lock=\"1\"\nfi\n],\n[enable_lazy_lock=\"\"]\n)\nif test \"x$enable_lazy_lock\" = \"x\" -a \"x${force_lazy_lock}\" = \"x1\" ; then\n  AC_MSG_RESULT([Forcing lazy-lock to avoid allocator/threading bootstrap issues])\n  enable_lazy_lock=\"1\"\nfi\nif test \"x$enable_lazy_lock\" = \"x1\" ; then\n  if test \"x$abi\" != \"xpecoff\" ; then\n    AC_CHECK_HEADERS([dlfcn.h], , [AC_MSG_ERROR([dlfcn.h is missing])])\n    AC_CHECK_FUNC([dlsym], [],\n      [AC_CHECK_LIB([dl], [dlsym], [LIBS=\"$LIBS -ldl\"],\n                    [AC_MSG_ERROR([libdl is missing])])\n      ])\n  fi\n  AC_DEFINE([JEMALLOC_LAZY_LOCK], [ ])\nelse\n  enable_lazy_lock=\"0\"\nfi\nAC_SUBST([enable_lazy_lock])\n\nAC_ARG_ENABLE([tls],\n  [AS_HELP_STRING([--disable-tls], [Disable thread-local storage (__thread keyword)])],\nif test \"x$enable_tls\" = \"xno\" ; then\n  enable_tls=\"0\"\nelse\n  enable_tls=\"1\"\nfi\n,\nenable_tls=\"\"\n)\nif test \"x${enable_tls}\" = \"x\" ; then\n  if test \"x${force_tls}\" = \"x1\" ; then\n    AC_MSG_RESULT([Forcing TLS to avoid allocator/threading bootstrap issues])\n    enable_tls=\"1\"\n  elif test \"x${force_tls}\" = \"x0\" ; then\n    AC_MSG_RESULT([Forcing no TLS to avoid allocator/threading bootstrap issues])\n    enable_tls=\"0\"\n  else\n    enable_tls=\"1\"\n  fi\nfi\nif test \"x${enable_tls}\" = \"x1\" ; then\nAC_MSG_CHECKING([for TLS])\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n[[\n    __thread int x;\n]], [[\n    x = 42;\n\n    return 0;\n]])],\n              AC_MSG_RESULT([yes]),\n              AC_MSG_RESULT([no])\n              enable_tls=\"0\")\nelse\n  enable_tls=\"0\"\nfi\nAC_SUBST([enable_tls])\nif test \"x${enable_tls}\" = \"x1\" ; then\n  if test \"x${force_tls}\" = \"x0\" ; then\n    AC_MSG_WARN([TLS enabled despite being marked unusable on this platform])\n  fi\n  AC_DEFINE_UNQUOTED([JEMALLOC_TLS], [ ])\nelif test \"x${force_tls}\" = \"x1\" ; then\n  AC_MSG_WARN([TLS disabled despite being marked critical on this platform])\nfi\n\ndnl ============================================================================\ndnl Check for C11 atomics.\n\nJE_COMPILABLE([C11 atomics], [\n#include <stdint.h>\n#if (__STDC_VERSION__ >= 201112L) && !defined(__STDC_NO_ATOMICS__)\n#include <stdatomic.h>\n#else\n#error Atomics not available\n#endif\n], [\n    uint64_t *p = (uint64_t *)0;\n    uint64_t x = 1;\n    volatile atomic_uint_least64_t *a = (volatile atomic_uint_least64_t *)p;\n    uint64_t r = atomic_fetch_add(a, x) + x;\n    return (r == 0);\n], [je_cv_c11atomics])\nif test \"x${je_cv_c11atomics}\" = \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_C11ATOMICS])\nfi\n\ndnl ============================================================================\ndnl Check for atomic(9) operations as provided on FreeBSD.\n\nJE_COMPILABLE([atomic(9)], [\n#include <sys/types.h>\n#include <machine/atomic.h>\n#include <inttypes.h>\n], [\n\t{\n\t\tuint32_t x32 = 0;\n\t\tvolatile uint32_t *x32p = &x32;\n\t\tatomic_fetchadd_32(x32p, 1);\n\t}\n\t{\n\t\tunsigned long xlong = 0;\n\t\tvolatile unsigned long *xlongp = &xlong;\n\t\tatomic_fetchadd_long(xlongp, 1);\n\t}\n], [je_cv_atomic9])\nif test \"x${je_cv_atomic9}\" = \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_ATOMIC9])\nfi\n\ndnl ============================================================================\ndnl Check for atomic(3) operations as provided on Darwin.\n\nJE_COMPILABLE([Darwin OSAtomic*()], [\n#include <libkern/OSAtomic.h>\n#include <inttypes.h>\n], [\n\t{\n\t\tint32_t x32 = 0;\n\t\tvolatile int32_t *x32p = &x32;\n\t\tOSAtomicAdd32(1, x32p);\n\t}\n\t{\n\t\tint64_t x64 = 0;\n\t\tvolatile int64_t *x64p = &x64;\n\t\tOSAtomicAdd64(1, x64p);\n\t}\n], [je_cv_osatomic])\nif test \"x${je_cv_osatomic}\" = \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_OSATOMIC], [ ])\nfi\n\ndnl ============================================================================\ndnl Check for madvise(2).\n\nJE_COMPILABLE([madvise(2)], [\n#include <sys/mman.h>\n], [\n\t{\n\t\tmadvise((void *)0, 0, 0);\n\t}\n], [je_cv_madvise])\nif test \"x${je_cv_madvise}\" = \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_HAVE_MADVISE], [ ])\nfi\n\ndnl ============================================================================\ndnl Check whether __sync_{add,sub}_and_fetch() are available despite\ndnl __GCC_HAVE_SYNC_COMPARE_AND_SWAP_n macros being undefined.\n\nAC_DEFUN([JE_SYNC_COMPARE_AND_SWAP_CHECK],[\n  AC_CACHE_CHECK([whether to force $1-bit __sync_{add,sub}_and_fetch()],\n               [je_cv_sync_compare_and_swap_$2],\n               [AC_LINK_IFELSE([AC_LANG_PROGRAM([\n                                                 #include <stdint.h>\n                                                ],\n                                                [\n                                                 #ifndef __GCC_HAVE_SYNC_COMPARE_AND_SWAP_$2\n                                                 {\n                                                    uint$1_t x$1 = 0;\n                                                    __sync_add_and_fetch(&x$1, 42);\n                                                    __sync_sub_and_fetch(&x$1, 1);\n                                                 }\n                                                 #else\n                                                 #error __GCC_HAVE_SYNC_COMPARE_AND_SWAP_$2 is defined, no need to force\n                                                 #endif\n                                                ])],\n                               [je_cv_sync_compare_and_swap_$2=yes],\n                               [je_cv_sync_compare_and_swap_$2=no])])\n\n  if test \"x${je_cv_sync_compare_and_swap_$2}\" = \"xyes\" ; then\n    AC_DEFINE([JE_FORCE_SYNC_COMPARE_AND_SWAP_$2], [ ])\n  fi\n])\n\nif test \"x${je_cv_atomic9}\" != \"xyes\" -a \"x${je_cv_osatomic}\" != \"xyes\" ; then\n  JE_SYNC_COMPARE_AND_SWAP_CHECK(32, 4)\n  JE_SYNC_COMPARE_AND_SWAP_CHECK(64, 8)\nfi\n\ndnl ============================================================================\ndnl Check for __builtin_clz() and __builtin_clzl().\n\nAC_CACHE_CHECK([for __builtin_clz],\n               [je_cv_builtin_clz],\n               [AC_LINK_IFELSE([AC_LANG_PROGRAM([],\n                                                [\n                                                {\n                                                        unsigned x = 0;\n                                                        int y = __builtin_clz(x);\n                                                }\n                                                {\n                                                        unsigned long x = 0;\n                                                        int y = __builtin_clzl(x);\n                                                }\n                                                ])],\n                               [je_cv_builtin_clz=yes],\n                               [je_cv_builtin_clz=no])])\n\nif test \"x${je_cv_builtin_clz}\" = \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_HAVE_BUILTIN_CLZ], [ ])\nfi\n\ndnl ============================================================================\ndnl Check for spinlock(3) operations as provided on Darwin.\n\nJE_COMPILABLE([Darwin OSSpin*()], [\n#include <libkern/OSAtomic.h>\n#include <inttypes.h>\n], [\n\tOSSpinLock lock = 0;\n\tOSSpinLockLock(&lock);\n\tOSSpinLockUnlock(&lock);\n], [je_cv_osspin])\nif test \"x${je_cv_osspin}\" = \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_OSSPIN], [ ])\nfi\n\ndnl ============================================================================\ndnl Darwin-related configuration.\n\nAC_ARG_ENABLE([zone-allocator],\n  [AS_HELP_STRING([--disable-zone-allocator],\n                  [Disable zone allocator for Darwin])],\n[if test \"x$enable_zone_allocator\" = \"xno\" ; then\n  enable_zone_allocator=\"0\"\nelse\n  enable_zone_allocator=\"1\"\nfi\n],\n[if test \"x${abi}\" = \"xmacho\"; then\n  enable_zone_allocator=\"1\"\nfi\n]\n)\nAC_SUBST([enable_zone_allocator])\n\nif test \"x${enable_zone_allocator}\" = \"x1\" ; then\n  if test \"x${abi}\" != \"xmacho\"; then\n    AC_MSG_ERROR([--enable-zone-allocator is only supported on Darwin])\n  fi\n  AC_DEFINE([JEMALLOC_ZONE], [ ])\n\n  dnl The szone version jumped from 3 to 6 between the OS X 10.5.x and 10.6\n  dnl releases.  malloc_zone_t and malloc_introspection_t have new fields in\n  dnl 10.6, which is the only source-level indication of the change.\n  AC_MSG_CHECKING([malloc zone version])\n  AC_DEFUN([JE_ZONE_PROGRAM],\n    [AC_LANG_PROGRAM(\n      [#include <malloc/malloc.h>],\n      [static int foo[[sizeof($1) $2 sizeof(void *) * $3 ? 1 : -1]]]\n    )])\n\n  AC_COMPILE_IFELSE([JE_ZONE_PROGRAM(malloc_zone_t,==,14)],[JEMALLOC_ZONE_VERSION=3],[\n  AC_COMPILE_IFELSE([JE_ZONE_PROGRAM(malloc_zone_t,==,15)],[JEMALLOC_ZONE_VERSION=5],[\n  AC_COMPILE_IFELSE([JE_ZONE_PROGRAM(malloc_zone_t,==,16)],[\n    AC_COMPILE_IFELSE([JE_ZONE_PROGRAM(malloc_introspection_t,==,9)],[JEMALLOC_ZONE_VERSION=6],[\n    AC_COMPILE_IFELSE([JE_ZONE_PROGRAM(malloc_introspection_t,==,13)],[JEMALLOC_ZONE_VERSION=7],[JEMALLOC_ZONE_VERSION=]\n  )])],[\n  AC_COMPILE_IFELSE([JE_ZONE_PROGRAM(malloc_zone_t,==,17)],[JEMALLOC_ZONE_VERSION=8],[\n  AC_COMPILE_IFELSE([JE_ZONE_PROGRAM(malloc_zone_t,>,17)],[JEMALLOC_ZONE_VERSION=9],[JEMALLOC_ZONE_VERSION=]\n  )])])])])\n  if test \"x${JEMALLOC_ZONE_VERSION}\" = \"x\"; then\n    AC_MSG_RESULT([unsupported])\n    AC_MSG_ERROR([Unsupported malloc zone version])\n  fi\n  if test \"${JEMALLOC_ZONE_VERSION}\" = 9; then\n    JEMALLOC_ZONE_VERSION=8\n    AC_MSG_RESULT([> 8])\n  else\n    AC_MSG_RESULT([$JEMALLOC_ZONE_VERSION])\n  fi\n  AC_DEFINE_UNQUOTED(JEMALLOC_ZONE_VERSION, [$JEMALLOC_ZONE_VERSION])\nfi\n\ndnl ============================================================================\ndnl Check for glibc malloc hooks\n\nJE_COMPILABLE([glibc malloc hook], [\n#include <stddef.h>\n\nextern void (* __free_hook)(void *ptr);\nextern void *(* __malloc_hook)(size_t size);\nextern void *(* __realloc_hook)(void *ptr, size_t size);\n], [\n  void *ptr = 0L;\n  if (__malloc_hook) ptr = __malloc_hook(1);\n  if (__realloc_hook) ptr = __realloc_hook(ptr, 2);\n  if (__free_hook && ptr) __free_hook(ptr);\n], [je_cv_glibc_malloc_hook])\nif test \"x${je_cv_glibc_malloc_hook}\" = \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_GLIBC_MALLOC_HOOK], [ ])\nfi\n\nJE_COMPILABLE([glibc memalign hook], [\n#include <stddef.h>\n\nextern void *(* __memalign_hook)(size_t alignment, size_t size);\n], [\n  void *ptr = 0L;\n  if (__memalign_hook) ptr = __memalign_hook(16, 7);\n], [je_cv_glibc_memalign_hook])\nif test \"x${je_cv_glibc_memalign_hook}\" = \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_GLIBC_MEMALIGN_HOOK], [ ])\nfi\n\nJE_COMPILABLE([pthreads adaptive mutexes], [\n#include <pthread.h>\n], [\n  pthread_mutexattr_t attr;\n  pthread_mutexattr_init(&attr);\n  pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_ADAPTIVE_NP);\n  pthread_mutexattr_destroy(&attr);\n], [je_cv_pthread_mutex_adaptive_np])\nif test \"x${je_cv_pthread_mutex_adaptive_np}\" = \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_HAVE_PTHREAD_MUTEX_ADAPTIVE_NP], [ ])\nfi\n\ndnl ============================================================================\ndnl Check for typedefs, structures, and compiler characteristics.\nAC_HEADER_STDBOOL\n\ndnl ============================================================================\ndnl Define commands that generate output files.\n\nAC_CONFIG_COMMANDS([include/jemalloc/internal/private_namespace.h], [\n  mkdir -p \"${objroot}include/jemalloc/internal\"\n  \"${srcdir}/include/jemalloc/internal/private_namespace.sh\" \"${srcdir}/include/jemalloc/internal/private_symbols.txt\" > \"${objroot}include/jemalloc/internal/private_namespace.h\"\n], [\n  srcdir=\"${srcdir}\"\n  objroot=\"${objroot}\"\n])\nAC_CONFIG_COMMANDS([include/jemalloc/internal/private_unnamespace.h], [\n  mkdir -p \"${objroot}include/jemalloc/internal\"\n  \"${srcdir}/include/jemalloc/internal/private_unnamespace.sh\" \"${srcdir}/include/jemalloc/internal/private_symbols.txt\" > \"${objroot}include/jemalloc/internal/private_unnamespace.h\"\n], [\n  srcdir=\"${srcdir}\"\n  objroot=\"${objroot}\"\n])\nAC_CONFIG_COMMANDS([include/jemalloc/internal/public_symbols.txt], [\n  f=\"${objroot}include/jemalloc/internal/public_symbols.txt\"\n  mkdir -p \"${objroot}include/jemalloc/internal\"\n  cp /dev/null \"${f}\"\n  for nm in `echo ${mangling_map} |tr ',' ' '` ; do\n    n=`echo ${nm} |tr ':' ' ' |awk '{print $[]1}'`\n    m=`echo ${nm} |tr ':' ' ' |awk '{print $[]2}'`\n    echo \"${n}:${m}\" >> \"${f}\"\n    dnl Remove name from public_syms so that it isn't redefined later.\n    public_syms=`for sym in ${public_syms}; do echo \"${sym}\"; done |grep -v \"^${n}\\$\" |tr '\\n' ' '`\n  done\n  for sym in ${public_syms} ; do\n    n=\"${sym}\"\n    m=\"${JEMALLOC_PREFIX}${sym}\"\n    echo \"${n}:${m}\" >> \"${f}\"\n  done\n], [\n  srcdir=\"${srcdir}\"\n  objroot=\"${objroot}\"\n  mangling_map=\"${mangling_map}\"\n  public_syms=\"${public_syms}\"\n  JEMALLOC_PREFIX=\"${JEMALLOC_PREFIX}\"\n])\nAC_CONFIG_COMMANDS([include/jemalloc/internal/public_namespace.h], [\n  mkdir -p \"${objroot}include/jemalloc/internal\"\n  \"${srcdir}/include/jemalloc/internal/public_namespace.sh\" \"${objroot}include/jemalloc/internal/public_symbols.txt\" > \"${objroot}include/jemalloc/internal/public_namespace.h\"\n], [\n  srcdir=\"${srcdir}\"\n  objroot=\"${objroot}\"\n])\nAC_CONFIG_COMMANDS([include/jemalloc/internal/public_unnamespace.h], [\n  mkdir -p \"${objroot}include/jemalloc/internal\"\n  \"${srcdir}/include/jemalloc/internal/public_unnamespace.sh\" \"${objroot}include/jemalloc/internal/public_symbols.txt\" > \"${objroot}include/jemalloc/internal/public_unnamespace.h\"\n], [\n  srcdir=\"${srcdir}\"\n  objroot=\"${objroot}\"\n])\nAC_CONFIG_COMMANDS([include/jemalloc/internal/size_classes.h], [\n  mkdir -p \"${objroot}include/jemalloc/internal\"\n  \"${SHELL}\" \"${srcdir}/include/jemalloc/internal/size_classes.sh\" \"${LG_QUANTA}\" ${LG_TINY_MIN} \"${LG_PAGE_SIZES}\" ${LG_SIZE_CLASS_GROUP} > \"${objroot}include/jemalloc/internal/size_classes.h\"\n], [\n  SHELL=\"${SHELL}\"\n  srcdir=\"${srcdir}\"\n  objroot=\"${objroot}\"\n  LG_QUANTA=\"${LG_QUANTA}\"\n  LG_TINY_MIN=${LG_TINY_MIN}\n  LG_PAGE_SIZES=\"${LG_PAGE_SIZES}\"\n  LG_SIZE_CLASS_GROUP=${LG_SIZE_CLASS_GROUP}\n])\nAC_CONFIG_COMMANDS([include/jemalloc/jemalloc_protos_jet.h], [\n  mkdir -p \"${objroot}include/jemalloc\"\n  cat \"${srcdir}/include/jemalloc/jemalloc_protos.h.in\" | sed -e 's/@je_@/jet_/g' > \"${objroot}include/jemalloc/jemalloc_protos_jet.h\"\n], [\n  srcdir=\"${srcdir}\"\n  objroot=\"${objroot}\"\n])\nAC_CONFIG_COMMANDS([include/jemalloc/jemalloc_rename.h], [\n  mkdir -p \"${objroot}include/jemalloc\"\n  \"${srcdir}/include/jemalloc/jemalloc_rename.sh\" \"${objroot}include/jemalloc/internal/public_symbols.txt\" > \"${objroot}include/jemalloc/jemalloc_rename.h\"\n], [\n  srcdir=\"${srcdir}\"\n  objroot=\"${objroot}\"\n])\nAC_CONFIG_COMMANDS([include/jemalloc/jemalloc_mangle.h], [\n  mkdir -p \"${objroot}include/jemalloc\"\n  \"${srcdir}/include/jemalloc/jemalloc_mangle.sh\" \"${objroot}include/jemalloc/internal/public_symbols.txt\" je_ > \"${objroot}include/jemalloc/jemalloc_mangle.h\"\n], [\n  srcdir=\"${srcdir}\"\n  objroot=\"${objroot}\"\n])\nAC_CONFIG_COMMANDS([include/jemalloc/jemalloc_mangle_jet.h], [\n  mkdir -p \"${objroot}include/jemalloc\"\n  \"${srcdir}/include/jemalloc/jemalloc_mangle.sh\" \"${objroot}include/jemalloc/internal/public_symbols.txt\" jet_ > \"${objroot}include/jemalloc/jemalloc_mangle_jet.h\"\n], [\n  srcdir=\"${srcdir}\"\n  objroot=\"${objroot}\"\n])\nAC_CONFIG_COMMANDS([include/jemalloc/jemalloc.h], [\n  mkdir -p \"${objroot}include/jemalloc\"\n  \"${srcdir}/include/jemalloc/jemalloc.sh\" \"${objroot}\" > \"${objroot}include/jemalloc/jemalloc${install_suffix}.h\"\n], [\n  srcdir=\"${srcdir}\"\n  objroot=\"${objroot}\"\n  install_suffix=\"${install_suffix}\"\n])\n\ndnl Process .in files.\nAC_SUBST([cfghdrs_in])\nAC_SUBST([cfghdrs_out])\nAC_CONFIG_HEADERS([$cfghdrs_tup])\n\ndnl ============================================================================\ndnl Generate outputs.\n\nAC_CONFIG_FILES([$cfgoutputs_tup config.stamp bin/jemalloc-config bin/jemalloc.sh bin/jeprof])\nAC_SUBST([cfgoutputs_in])\nAC_SUBST([cfgoutputs_out])\nAC_OUTPUT\n\ndnl ============================================================================\ndnl Print out the results of configuration.\nAC_MSG_RESULT([===============================================================================])\nAC_MSG_RESULT([jemalloc version   : ${jemalloc_version}])\nAC_MSG_RESULT([library revision   : ${rev}])\nAC_MSG_RESULT([])\nAC_MSG_RESULT([CONFIG             : ${CONFIG}])\nAC_MSG_RESULT([CC                 : ${CC}])\nAC_MSG_RESULT([CFLAGS             : ${CFLAGS}])\nAC_MSG_RESULT([CPPFLAGS           : ${CPPFLAGS}])\nAC_MSG_RESULT([LDFLAGS            : ${LDFLAGS}])\nAC_MSG_RESULT([EXTRA_LDFLAGS      : ${EXTRA_LDFLAGS}])\nAC_MSG_RESULT([LIBS               : ${LIBS}])\nAC_MSG_RESULT([TESTLIBS           : ${TESTLIBS}])\nAC_MSG_RESULT([RPATH_EXTRA        : ${RPATH_EXTRA}])\nAC_MSG_RESULT([])\nAC_MSG_RESULT([XSLTPROC           : ${XSLTPROC}])\nAC_MSG_RESULT([XSLROOT            : ${XSLROOT}])\nAC_MSG_RESULT([])\nAC_MSG_RESULT([PREFIX             : ${PREFIX}])\nAC_MSG_RESULT([BINDIR             : ${BINDIR}])\nAC_MSG_RESULT([DATADIR            : ${DATADIR}])\nAC_MSG_RESULT([INCLUDEDIR         : ${INCLUDEDIR}])\nAC_MSG_RESULT([LIBDIR             : ${LIBDIR}])\nAC_MSG_RESULT([MANDIR             : ${MANDIR}])\nAC_MSG_RESULT([])\nAC_MSG_RESULT([srcroot            : ${srcroot}])\nAC_MSG_RESULT([abs_srcroot        : ${abs_srcroot}])\nAC_MSG_RESULT([objroot            : ${objroot}])\nAC_MSG_RESULT([abs_objroot        : ${abs_objroot}])\nAC_MSG_RESULT([])\nAC_MSG_RESULT([JEMALLOC_PREFIX    : ${JEMALLOC_PREFIX}])\nAC_MSG_RESULT([JEMALLOC_PRIVATE_NAMESPACE])\nAC_MSG_RESULT([                   : ${JEMALLOC_PRIVATE_NAMESPACE}])\nAC_MSG_RESULT([install_suffix     : ${install_suffix}])\nAC_MSG_RESULT([autogen            : ${enable_autogen}])\nAC_MSG_RESULT([cc-silence         : ${enable_cc_silence}])\nAC_MSG_RESULT([debug              : ${enable_debug}])\nAC_MSG_RESULT([code-coverage      : ${enable_code_coverage}])\nAC_MSG_RESULT([stats              : ${enable_stats}])\nAC_MSG_RESULT([prof               : ${enable_prof}])\nAC_MSG_RESULT([prof-libunwind     : ${enable_prof_libunwind}])\nAC_MSG_RESULT([prof-libgcc        : ${enable_prof_libgcc}])\nAC_MSG_RESULT([prof-gcc           : ${enable_prof_gcc}])\nAC_MSG_RESULT([tcache             : ${enable_tcache}])\nAC_MSG_RESULT([fill               : ${enable_fill}])\nAC_MSG_RESULT([utrace             : ${enable_utrace}])\nAC_MSG_RESULT([valgrind           : ${enable_valgrind}])\nAC_MSG_RESULT([xmalloc            : ${enable_xmalloc}])\nAC_MSG_RESULT([munmap             : ${enable_munmap}])\nAC_MSG_RESULT([lazy_lock          : ${enable_lazy_lock}])\nAC_MSG_RESULT([tls                : ${enable_tls}])\nAC_MSG_RESULT([cache-oblivious    : ${enable_cache_oblivious}])\nAC_MSG_RESULT([===============================================================================])\n",
        "/tmp/vanessa/spack-stage/spack-stage-redis-4.0.13-c6t5xnt2ivmsaib6izc4ma6blwxnshrd/spack-src/deps/jemalloc/src/mutex.c": "#define\tJEMALLOC_MUTEX_C_\n#include \"jemalloc/internal/jemalloc_internal.h\"\n\n#if defined(JEMALLOC_LAZY_LOCK) && !defined(_WIN32)\n#include <dlfcn.h>\n#endif\n\n#ifndef _CRT_SPINCOUNT\n#define\t_CRT_SPINCOUNT 4000\n#endif\n\n/******************************************************************************/\n/* Data. */\n\n#ifdef JEMALLOC_LAZY_LOCK\nbool isthreaded = false;\n#endif\n#ifdef JEMALLOC_MUTEX_INIT_CB\nstatic bool\t\tpostpone_init = true;\nstatic malloc_mutex_t\t*postponed_mutexes = NULL;\n#endif\n\n#if defined(JEMALLOC_LAZY_LOCK) && !defined(_WIN32)\nstatic void\tpthread_create_once(void);\n#endif\n\n/******************************************************************************/\n/*\n * We intercept pthread_create() calls in order to toggle isthreaded if the\n * process goes multi-threaded.\n */\n\n#if defined(JEMALLOC_LAZY_LOCK) && !defined(_WIN32)\nstatic int (*pthread_create_fptr)(pthread_t *__restrict, const pthread_attr_t *,\n    void *(*)(void *), void *__restrict);\n\nstatic void\npthread_create_once(void)\n{\n\n\tpthread_create_fptr = dlsym(RTLD_NEXT, \"pthread_create\");\n\tif (pthread_create_fptr == NULL) {\n\t\tmalloc_write(\"<jemalloc>: Error in dlsym(RTLD_NEXT, \"\n\t\t    \"\\\"pthread_create\\\")\\n\");\n\t\tabort();\n\t}\n\n\tisthreaded = true;\n}\n\nJEMALLOC_EXPORT int\npthread_create(pthread_t *__restrict thread,\n    const pthread_attr_t *__restrict attr, void *(*start_routine)(void *),\n    void *__restrict arg)\n{\n\tstatic pthread_once_t once_control = PTHREAD_ONCE_INIT;\n\n\tpthread_once(&once_control, pthread_create_once);\n\n\treturn (pthread_create_fptr(thread, attr, start_routine, arg));\n}\n#endif\n\n/******************************************************************************/\n\n#ifdef JEMALLOC_MUTEX_INIT_CB\nJEMALLOC_EXPORT int\t_pthread_mutex_init_calloc_cb(pthread_mutex_t *mutex,\n    void *(calloc_cb)(size_t, size_t));\n#endif\n\nbool\nmalloc_mutex_init(malloc_mutex_t *mutex)\n{\n\n#ifdef _WIN32\n#  if _WIN32_WINNT >= 0x0600\n\tInitializeSRWLock(&mutex->lock);\n#  else\n\tif (!InitializeCriticalSectionAndSpinCount(&mutex->lock,\n\t    _CRT_SPINCOUNT))\n\t\treturn (true);\n#  endif\n#elif (defined(JEMALLOC_OSSPIN))\n\tmutex->lock = 0;\n#elif (defined(JEMALLOC_MUTEX_INIT_CB))\n\tif (postpone_init) {\n\t\tmutex->postponed_next = postponed_mutexes;\n\t\tpostponed_mutexes = mutex;\n\t} else {\n\t\tif (_pthread_mutex_init_calloc_cb(&mutex->lock,\n\t\t    bootstrap_calloc) != 0)\n\t\t\treturn (true);\n\t}\n#else\n\tpthread_mutexattr_t attr;\n\n\tif (pthread_mutexattr_init(&attr) != 0)\n\t\treturn (true);\n\tpthread_mutexattr_settype(&attr, MALLOC_MUTEX_TYPE);\n\tif (pthread_mutex_init(&mutex->lock, &attr) != 0) {\n\t\tpthread_mutexattr_destroy(&attr);\n\t\treturn (true);\n\t}\n\tpthread_mutexattr_destroy(&attr);\n#endif\n\treturn (false);\n}\n\nvoid\nmalloc_mutex_prefork(malloc_mutex_t *mutex)\n{\n\n\tmalloc_mutex_lock(mutex);\n}\n\nvoid\nmalloc_mutex_postfork_parent(malloc_mutex_t *mutex)\n{\n\n\tmalloc_mutex_unlock(mutex);\n}\n\nvoid\nmalloc_mutex_postfork_child(malloc_mutex_t *mutex)\n{\n\n#ifdef JEMALLOC_MUTEX_INIT_CB\n\tmalloc_mutex_unlock(mutex);\n#else\n\tif (malloc_mutex_init(mutex)) {\n\t\tmalloc_printf(\"<jemalloc>: Error re-initializing mutex in \"\n\t\t    \"child\\n\");\n\t\tif (opt_abort)\n\t\t\tabort();\n\t}\n#endif\n}\n\nbool\nmutex_boot(void)\n{\n\n#ifdef JEMALLOC_MUTEX_INIT_CB\n\tpostpone_init = false;\n\twhile (postponed_mutexes != NULL) {\n\t\tif (_pthread_mutex_init_calloc_cb(&postponed_mutexes->lock,\n\t\t    bootstrap_calloc) != 0)\n\t\t\treturn (true);\n\t\tpostponed_mutexes = postponed_mutexes->postponed_next;\n\t}\n#endif\n\treturn (false);\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-redis-4.0.13-c6t5xnt2ivmsaib6izc4ma6blwxnshrd/spack-src/tests/assets/hash-zipmap.rdb",
        "/tmp/vanessa/spack-stage/spack-stage-redis-4.0.13-c6t5xnt2ivmsaib6izc4ma6blwxnshrd/spack-src/tests/assets/encodings.rdb",
        "/tmp/vanessa/spack-stage/spack-stage-redis-4.0.13-c6t5xnt2ivmsaib6izc4ma6blwxnshrd/spack-src/deps/lua/test/life.lua",
        "/tmp/vanessa/spack-stage/spack-stage-redis-4.0.13-c6t5xnt2ivmsaib6izc4ma6blwxnshrd/spack-src/deps/lua/etc/lua.ico",
        "/tmp/vanessa/spack-stage/spack-stage-redis-4.0.13-c6t5xnt2ivmsaib6izc4ma6blwxnshrd/spack-src/deps/lua/doc/logo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-redis-4.0.13-c6t5xnt2ivmsaib6izc4ma6blwxnshrd/spack-src/deps/lua/doc/cover.png",
        "/tmp/vanessa/spack-stage/spack-stage-redis-4.0.13-c6t5xnt2ivmsaib6izc4ma6blwxnshrd/spack-src/deps/jemalloc/doc/jemalloc.html"
    ],
    "total_files": 562
}