{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-redis-5.0.1-gykpygjr4nuvp2gxloszw6ksswcpsjes/spack-src/src/module.c": "/*\n * Copyright (c) 2016, Salvatore Sanfilippo <antirez at gmail dot com>\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *   * Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *   * Redistributions in binary form must reproduce the above copyright\n *     notice, this list of conditions and the following disclaimer in the\n *     documentation and/or other materials provided with the distribution.\n *   * Neither the name of Redis nor the names of its contributors may be used\n *     to endorse or promote products derived from this software without\n *     specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n * POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include \"server.h\"\n#include \"cluster.h\"\n#include <dlfcn.h>\n\n#define REDISMODULE_CORE 1\n#include \"redismodule.h\"\n\n/* --------------------------------------------------------------------------\n * Private data structures used by the modules system. Those are data\n * structures that are never exposed to Redis Modules, if not as void\n * pointers that have an API the module can call with them)\n * -------------------------------------------------------------------------- */\n\n/* This structure represents a module inside the system. */\nstruct RedisModule {\n    void *handle;   /* Module dlopen() handle. */\n    char *name;     /* Module name. */\n    int ver;        /* Module version. We use just progressive integers. */\n    int apiver;     /* Module API version as requested during initialization.*/\n    list *types;    /* Module data types. */\n};\ntypedef struct RedisModule RedisModule;\n\nstatic dict *modules; /* Hash table of modules. SDS -> RedisModule ptr.*/\n\n/* Entries in the context->amqueue array, representing objects to free\n * when the callback returns. */\nstruct AutoMemEntry {\n    void *ptr;\n    int type;\n};\n\n/* AutMemEntry type field values. */\n#define REDISMODULE_AM_KEY 0\n#define REDISMODULE_AM_STRING 1\n#define REDISMODULE_AM_REPLY 2\n#define REDISMODULE_AM_FREED 3 /* Explicitly freed by user already. */\n#define REDISMODULE_AM_DICT 4\n\n/* The pool allocator block. Redis Modules can allocate memory via this special\n * allocator that will automatically release it all once the callback returns.\n * This means that it can only be used for ephemeral allocations. However\n * there are two advantages for modules to use this API:\n *\n * 1) The memory is automatically released when the callback returns.\n * 2) This allocator is faster for many small allocations since whole blocks\n *    are allocated, and small pieces returned to the caller just advancing\n *    the index of the allocation.\n *\n * Allocations are always rounded to the size of the void pointer in order\n * to always return aligned memory chunks. */\n\n#define REDISMODULE_POOL_ALLOC_MIN_SIZE (1024*8)\n#define REDISMODULE_POOL_ALLOC_ALIGN (sizeof(void*))\n\ntypedef struct RedisModulePoolAllocBlock {\n    uint32_t size;\n    uint32_t used;\n    struct RedisModulePoolAllocBlock *next;\n    char memory[];\n} RedisModulePoolAllocBlock;\n\n/* This structure represents the context in which Redis modules operate.\n * Most APIs module can access, get a pointer to the context, so that the API\n * implementation can hold state across calls, or remember what to free after\n * the call and so forth.\n *\n * Note that not all the context structure is always filled with actual values\n * but only the fields needed in a given context. */\n\nstruct RedisModuleBlockedClient;\n\nstruct RedisModuleCtx {\n    void *getapifuncptr;            /* NOTE: Must be the first field. */\n    struct RedisModule *module;     /* Module reference. */\n    client *client;                 /* Client calling a command. */\n    struct RedisModuleBlockedClient *blocked_client; /* Blocked client for\n                                                        thread safe context. */\n    struct AutoMemEntry *amqueue;   /* Auto memory queue of objects to free. */\n    int amqueue_len;                /* Number of slots in amqueue. */\n    int amqueue_used;               /* Number of used slots in amqueue. */\n    int flags;                      /* REDISMODULE_CTX_... flags. */\n    void **postponed_arrays;        /* To set with RM_ReplySetArrayLength(). */\n    int postponed_arrays_count;     /* Number of entries in postponed_arrays. */\n    void *blocked_privdata;         /* Privdata set when unblocking a client. */\n\n    /* Used if there is the REDISMODULE_CTX_KEYS_POS_REQUEST flag set. */\n    int *keys_pos;\n    int keys_count;\n\n    struct RedisModulePoolAllocBlock *pa_head;\n};\ntypedef struct RedisModuleCtx RedisModuleCtx;\n\n#define REDISMODULE_CTX_INIT {(void*)(unsigned long)&RM_GetApi, NULL, NULL, NULL, NULL, 0, 0, 0, NULL, 0, NULL, NULL, 0, NULL}\n#define REDISMODULE_CTX_MULTI_EMITTED (1<<0)\n#define REDISMODULE_CTX_AUTO_MEMORY (1<<1)\n#define REDISMODULE_CTX_KEYS_POS_REQUEST (1<<2)\n#define REDISMODULE_CTX_BLOCKED_REPLY (1<<3)\n#define REDISMODULE_CTX_BLOCKED_TIMEOUT (1<<4)\n#define REDISMODULE_CTX_THREAD_SAFE (1<<5)\n#define REDISMODULE_CTX_BLOCKED_DISCONNECTED (1<<6)\n\n/* This represents a Redis key opened with RM_OpenKey(). */\nstruct RedisModuleKey {\n    RedisModuleCtx *ctx;\n    redisDb *db;\n    robj *key;      /* Key name object. */\n    robj *value;    /* Value object, or NULL if the key was not found. */\n    void *iter;     /* Iterator. */\n    int mode;       /* Opening mode. */\n\n    /* Zset iterator. */\n    uint32_t ztype;         /* REDISMODULE_ZSET_RANGE_* */\n    zrangespec zrs;         /* Score range. */\n    zlexrangespec zlrs;     /* Lex range. */\n    uint32_t zstart;        /* Start pos for positional ranges. */\n    uint32_t zend;          /* End pos for positional ranges. */\n    void *zcurrent;         /* Zset iterator current node. */\n    int zer;                /* Zset iterator end reached flag\n                               (true if end was reached). */\n};\ntypedef struct RedisModuleKey RedisModuleKey;\n\n/* RedisModuleKey 'ztype' values. */\n#define REDISMODULE_ZSET_RANGE_NONE 0       /* This must always be 0. */\n#define REDISMODULE_ZSET_RANGE_LEX 1\n#define REDISMODULE_ZSET_RANGE_SCORE 2\n#define REDISMODULE_ZSET_RANGE_POS 3\n\n/* Function pointer type of a function representing a command inside\n * a Redis module. */\nstruct RedisModuleBlockedClient;\ntypedef int (*RedisModuleCmdFunc) (RedisModuleCtx *ctx, void **argv, int argc);\ntypedef void (*RedisModuleDisconnectFunc) (RedisModuleCtx *ctx, struct RedisModuleBlockedClient *bc);\n\n/* This struct holds the information about a command registered by a module.*/\nstruct RedisModuleCommandProxy {\n    struct RedisModule *module;\n    RedisModuleCmdFunc func;\n    struct redisCommand *rediscmd;\n};\ntypedef struct RedisModuleCommandProxy RedisModuleCommandProxy;\n\n#define REDISMODULE_REPLYFLAG_NONE 0\n#define REDISMODULE_REPLYFLAG_TOPARSE (1<<0) /* Protocol must be parsed. */\n#define REDISMODULE_REPLYFLAG_NESTED (1<<1)  /* Nested reply object. No proto\n                                                or struct free. */\n\n/* Reply of RM_Call() function. The function is filled in a lazy\n * way depending on the function called on the reply structure. By default\n * only the type, proto and protolen are filled. */\ntypedef struct RedisModuleCallReply {\n    RedisModuleCtx *ctx;\n    int type;       /* REDISMODULE_REPLY_... */\n    int flags;      /* REDISMODULE_REPLYFLAG_...  */\n    size_t len;     /* Len of strings or num of elements of arrays. */\n    char *proto;    /* Raw reply protocol. An SDS string at top-level object. */\n    size_t protolen;/* Length of protocol. */\n    union {\n        const char *str; /* String pointer for string and error replies. This\n                            does not need to be freed, always points inside\n                            a reply->proto buffer of the reply object or, in\n                            case of array elements, of parent reply objects. */\n        long long ll;    /* Reply value for integer reply. */\n        struct RedisModuleCallReply *array; /* Array of sub-reply elements. */\n    } val;\n} RedisModuleCallReply;\n\n/* Structure representing a blocked client. We get a pointer to such\n * an object when blocking from modules. */\ntypedef struct RedisModuleBlockedClient {\n    client *client;  /* Pointer to the blocked client. or NULL if the client\n                        was destroyed during the life of this object. */\n    RedisModule *module;    /* Module blocking the client. */\n    RedisModuleCmdFunc reply_callback; /* Reply callback on normal completion.*/\n    RedisModuleCmdFunc timeout_callback; /* Reply callback on timeout. */\n    RedisModuleDisconnectFunc disconnect_callback; /* Called on disconnection.*/\n    void (*free_privdata)(RedisModuleCtx*,void*);/* privdata cleanup callback.*/\n    void *privdata;     /* Module private data that may be used by the reply\n                           or timeout callback. It is set via the\n                           RedisModule_UnblockClient() API. */\n    client *reply_client;           /* Fake client used to accumulate replies\n                                       in thread safe contexts. */\n    int dbid;           /* Database number selected by the original client. */\n} RedisModuleBlockedClient;\n\nstatic pthread_mutex_t moduleUnblockedClientsMutex = PTHREAD_MUTEX_INITIALIZER;\nstatic list *moduleUnblockedClients;\n\n/* We need a mutex that is unlocked / relocked in beforeSleep() in order to\n * allow thread safe contexts to execute commands at a safe moment. */\nstatic pthread_mutex_t moduleGIL = PTHREAD_MUTEX_INITIALIZER;\n\n\n/* Function pointer type for keyspace event notification subscriptions from modules. */\ntypedef int (*RedisModuleNotificationFunc) (RedisModuleCtx *ctx, int type, const char *event, RedisModuleString *key);\n\n/* Keyspace notification subscriber information.\n * See RM_SubscribeToKeyspaceEvents() for more information. */\ntypedef struct RedisModuleKeyspaceSubscriber {\n    /* The module subscribed to the event */\n    RedisModule *module;\n    /* Notification callback in the module*/\n    RedisModuleNotificationFunc notify_callback;\n    /* A bit mask of the events the module is interested in */\n    int event_mask;\n    /* Active flag set on entry, to avoid reentrant subscribers\n     * calling themselves */\n    int active;\n} RedisModuleKeyspaceSubscriber;\n\n/* The module keyspace notification subscribers list */\nstatic list *moduleKeyspaceSubscribers;\n\n/* Static client recycled for when we need to provide a context with a client\n * in a situation where there is no client to provide. This avoidsallocating\n * a new client per round. For instance this is used in the keyspace\n * notifications, timers and cluster messages callbacks. */\nstatic client *moduleFreeContextReusedClient;\n\n/* Data structures related to the exported dictionary data structure. */\ntypedef struct RedisModuleDict {\n    rax *rax;                       /* The radix tree. */\n} RedisModuleDict;\n\ntypedef struct RedisModuleDictIter {\n    RedisModuleDict *dict;\n    raxIterator ri;\n} RedisModuleDictIter;\n\n/* --------------------------------------------------------------------------\n * Prototypes\n * -------------------------------------------------------------------------- */\n\nvoid RM_FreeCallReply(RedisModuleCallReply *reply);\nvoid RM_CloseKey(RedisModuleKey *key);\nvoid autoMemoryCollect(RedisModuleCtx *ctx);\nrobj **moduleCreateArgvFromUserFormat(const char *cmdname, const char *fmt, int *argcp, int *flags, va_list ap);\nvoid moduleReplicateMultiIfNeeded(RedisModuleCtx *ctx);\nvoid RM_ZsetRangeStop(RedisModuleKey *kp);\nstatic void zsetKeyReset(RedisModuleKey *key);\nvoid RM_FreeDict(RedisModuleCtx *ctx, RedisModuleDict *d);\n\n/* --------------------------------------------------------------------------\n * Heap allocation raw functions\n * -------------------------------------------------------------------------- */\n\n/* Use like malloc(). Memory allocated with this function is reported in\n * Redis INFO memory, used for keys eviction according to maxmemory settings\n * and in general is taken into account as memory allocated by Redis.\n * You should avoid using malloc(). */\nvoid *RM_Alloc(size_t bytes) {\n    return zmalloc(bytes);\n}\n\n/* Use like calloc(). Memory allocated with this function is reported in\n * Redis INFO memory, used for keys eviction according to maxmemory settings\n * and in general is taken into account as memory allocated by Redis.\n * You should avoid using calloc() directly. */\nvoid *RM_Calloc(size_t nmemb, size_t size) {\n    return zcalloc(nmemb*size);\n}\n\n/* Use like realloc() for memory obtained with RedisModule_Alloc(). */\nvoid* RM_Realloc(void *ptr, size_t bytes) {\n    return zrealloc(ptr,bytes);\n}\n\n/* Use like free() for memory obtained by RedisModule_Alloc() and\n * RedisModule_Realloc(). However you should never try to free with\n * RedisModule_Free() memory allocated with malloc() inside your module. */\nvoid RM_Free(void *ptr) {\n    zfree(ptr);\n}\n\n/* Like strdup() but returns memory allocated with RedisModule_Alloc(). */\nchar *RM_Strdup(const char *str) {\n    return zstrdup(str);\n}\n\n/* --------------------------------------------------------------------------\n * Pool allocator\n * -------------------------------------------------------------------------- */\n\n/* Release the chain of blocks used for pool allocations. */\nvoid poolAllocRelease(RedisModuleCtx *ctx) {\n    RedisModulePoolAllocBlock *head = ctx->pa_head, *next;\n\n    while(head != NULL) {\n        next = head->next;\n        zfree(head);\n        head = next;\n    }\n    ctx->pa_head = NULL;\n}\n\n/* Return heap allocated memory that will be freed automatically when the\n * module callback function returns. Mostly suitable for small allocations\n * that are short living and must be released when the callback returns\n * anyway. The returned memory is aligned to the architecture word size\n * if at least word size bytes are requested, otherwise it is just\n * aligned to the next power of two, so for example a 3 bytes request is\n * 4 bytes aligned while a 2 bytes request is 2 bytes aligned.\n *\n * There is no realloc style function since when this is needed to use the\n * pool allocator is not a good idea.\n *\n * The function returns NULL if `bytes` is 0. */\nvoid *RM_PoolAlloc(RedisModuleCtx *ctx, size_t bytes) {\n    if (bytes == 0) return NULL;\n    RedisModulePoolAllocBlock *b = ctx->pa_head;\n    size_t left = b ? b->size - b->used : 0;\n\n    /* Fix alignment. */\n    if (left >= bytes) {\n        size_t alignment = REDISMODULE_POOL_ALLOC_ALIGN;\n        while (bytes < alignment && alignment/2 >= bytes) alignment /= 2;\n        if (b->used % alignment)\n            b->used += alignment - (b->used % alignment);\n        left = (b->used > b->size) ? 0 : b->size - b->used;\n    }\n\n    /* Create a new block if needed. */\n    if (left < bytes) {\n        size_t blocksize = REDISMODULE_POOL_ALLOC_MIN_SIZE;\n        if (blocksize < bytes) blocksize = bytes;\n        b = zmalloc(sizeof(*b) + blocksize);\n        b->size = blocksize;\n        b->used = 0;\n        b->next = ctx->pa_head;\n        ctx->pa_head = b;\n    }\n\n    char *retval = b->memory + b->used;\n    b->used += bytes;\n    return retval;\n}\n\n/* --------------------------------------------------------------------------\n * Helpers for modules API implementation\n * -------------------------------------------------------------------------- */\n\n/* Create an empty key of the specified type. 'kp' must point to a key object\n * opened for writing where the .value member is set to NULL because the\n * key was found to be non existing.\n *\n * On success REDISMODULE_OK is returned and the key is populated with\n * the value of the specified type. The function fails and returns\n * REDISMODULE_ERR if:\n *\n * 1) The key is not open for writing.\n * 2) The key is not empty.\n * 3) The specified type is unknown.\n */\nint moduleCreateEmptyKey(RedisModuleKey *key, int type) {\n    robj *obj;\n\n    /* The key must be open for writing and non existing to proceed. */\n    if (!(key->mode & REDISMODULE_WRITE) || key->value)\n        return REDISMODULE_ERR;\n\n    switch(type) {\n    case REDISMODULE_KEYTYPE_LIST:\n        obj = createQuicklistObject();\n        quicklistSetOptions(obj->ptr, server.list_max_ziplist_size,\n                            server.list_compress_depth);\n        break;\n    case REDISMODULE_KEYTYPE_ZSET:\n        obj = createZsetZiplistObject();\n        break;\n    case REDISMODULE_KEYTYPE_HASH:\n        obj = createHashObject();\n        break;\n    default: return REDISMODULE_ERR;\n    }\n    dbAdd(key->db,key->key,obj);\n    key->value = obj;\n    return REDISMODULE_OK;\n}\n\n/* This function is called in low-level API implementation functions in order\n * to check if the value associated with the key remained empty after an\n * operation that removed elements from an aggregate data type.\n *\n * If this happens, the key is deleted from the DB and the key object state\n * is set to the right one in order to be targeted again by write operations\n * possibly recreating the key if needed.\n *\n * The function returns 1 if the key value object is found empty and is\n * deleted, otherwise 0 is returned. */\nint moduleDelKeyIfEmpty(RedisModuleKey *key) {\n    if (!(key->mode & REDISMODULE_WRITE) || key->value == NULL) return 0;\n    int isempty;\n    robj *o = key->value;\n\n    switch(o->type) {\n    case OBJ_LIST: isempty = listTypeLength(o) == 0; break;\n    case OBJ_SET: isempty = setTypeSize(o) == 0; break;\n    case OBJ_ZSET: isempty = zsetLength(o) == 0; break;\n    case OBJ_HASH : isempty = hashTypeLength(o) == 0; break;\n    default: isempty = 0;\n    }\n\n    if (isempty) {\n        dbDelete(key->db,key->key);\n        key->value = NULL;\n        return 1;\n    } else {\n        return 0;\n    }\n}\n\n/* --------------------------------------------------------------------------\n * Service API exported to modules\n *\n * Note that all the exported APIs are called RM_<funcname> in the core\n * and RedisModule_<funcname> in the module side (defined as function\n * pointers in redismodule.h). In this way the dynamic linker does not\n * mess with our global function pointers, overriding it with the symbols\n * defined in the main executable having the same names.\n * -------------------------------------------------------------------------- */\n\n/* Lookup the requested module API and store the function pointer into the\n * target pointer. The function returns REDISMODULE_ERR if there is no such\n * named API, otherwise REDISMODULE_OK.\n *\n * This function is not meant to be used by modules developer, it is only\n * used implicitly by including redismodule.h. */\nint RM_GetApi(const char *funcname, void **targetPtrPtr) {\n    dictEntry *he = dictFind(server.moduleapi, funcname);\n    if (!he) return REDISMODULE_ERR;\n    *targetPtrPtr = dictGetVal(he);\n    return REDISMODULE_OK;\n}\n\n/* Free the context after the user function was called. */\nvoid moduleFreeContext(RedisModuleCtx *ctx) {\n    autoMemoryCollect(ctx);\n    poolAllocRelease(ctx);\n    if (ctx->postponed_arrays) {\n        zfree(ctx->postponed_arrays);\n        ctx->postponed_arrays_count = 0;\n        serverLog(LL_WARNING,\n            \"API misuse detected in module %s: \"\n            \"RedisModule_ReplyWithArray(REDISMODULE_POSTPONED_ARRAY_LEN) \"\n            \"not matched by the same number of RedisModule_SetReplyArrayLen() \"\n            \"calls.\",\n            ctx->module->name);\n    }\n    if (ctx->flags & REDISMODULE_CTX_THREAD_SAFE) freeClient(ctx->client);\n}\n\n/* Helper function for when a command callback is called, in order to handle\n * details needed to correctly replicate commands. */\nvoid moduleHandlePropagationAfterCommandCallback(RedisModuleCtx *ctx) {\n    client *c = ctx->client;\n\n    if (c->flags & CLIENT_LUA) return;\n\n    /* Handle the replication of the final EXEC, since whatever a command\n     * emits is always wrapped around MULTI/EXEC. */\n    if (ctx->flags & REDISMODULE_CTX_MULTI_EMITTED) {\n        robj *propargv[1];\n        propargv[0] = createStringObject(\"EXEC\",4);\n        alsoPropagate(server.execCommand,c->db->id,propargv,1,\n            PROPAGATE_AOF|PROPAGATE_REPL);\n        decrRefCount(propargv[0]);\n    }\n}\n\n/* This Redis command binds the normal Redis command invocation with commands\n * exported by modules. */\nvoid RedisModuleCommandDispatcher(client *c) {\n    RedisModuleCommandProxy *cp = (void*)(unsigned long)c->cmd->getkeys_proc;\n    RedisModuleCtx ctx = REDISMODULE_CTX_INIT;\n\n    ctx.module = cp->module;\n    ctx.client = c;\n    cp->func(&ctx,(void**)c->argv,c->argc);\n    moduleHandlePropagationAfterCommandCallback(&ctx);\n    moduleFreeContext(&ctx);\n}\n\n/* This function returns the list of keys, with the same interface as the\n * 'getkeys' function of the native commands, for module commands that exported\n * the \"getkeys-api\" flag during the registration. This is done when the\n * list of keys are not at fixed positions, so that first/last/step cannot\n * be used.\n *\n * In order to accomplish its work, the module command is called, flagging\n * the context in a way that the command can recognize this is a special\n * \"get keys\" call by calling RedisModule_IsKeysPositionRequest(ctx). */\nint *moduleGetCommandKeysViaAPI(struct redisCommand *cmd, robj **argv, int argc, int *numkeys) {\n    RedisModuleCommandProxy *cp = (void*)(unsigned long)cmd->getkeys_proc;\n    RedisModuleCtx ctx = REDISMODULE_CTX_INIT;\n\n    ctx.module = cp->module;\n    ctx.client = NULL;\n    ctx.flags |= REDISMODULE_CTX_KEYS_POS_REQUEST;\n    cp->func(&ctx,(void**)argv,argc);\n    int *res = ctx.keys_pos;\n    if (numkeys) *numkeys = ctx.keys_count;\n    moduleFreeContext(&ctx);\n    return res;\n}\n\n/* Return non-zero if a module command, that was declared with the\n * flag \"getkeys-api\", is called in a special way to get the keys positions\n * and not to get executed. Otherwise zero is returned. */\nint RM_IsKeysPositionRequest(RedisModuleCtx *ctx) {\n    return (ctx->flags & REDISMODULE_CTX_KEYS_POS_REQUEST) != 0;\n}\n\n/* When a module command is called in order to obtain the position of\n * keys, since it was flagged as \"getkeys-api\" during the registration,\n * the command implementation checks for this special call using the\n * RedisModule_IsKeysPositionRequest() API and uses this function in\n * order to report keys, like in the following example:\n *\n *     if (RedisModule_IsKeysPositionRequest(ctx)) {\n *         RedisModule_KeyAtPos(ctx,1);\n *         RedisModule_KeyAtPos(ctx,2);\n *     }\n *\n *  Note: in the example below the get keys API would not be needed since\n *  keys are at fixed positions. This interface is only used for commands\n *  with a more complex structure. */\nvoid RM_KeyAtPos(RedisModuleCtx *ctx, int pos) {\n    if (!(ctx->flags & REDISMODULE_CTX_KEYS_POS_REQUEST)) return;\n    if (pos <= 0) return;\n    ctx->keys_pos = zrealloc(ctx->keys_pos,sizeof(int)*(ctx->keys_count+1));\n    ctx->keys_pos[ctx->keys_count++] = pos;\n}\n\n/* Helper for RM_CreateCommand(). Turns a string representing command\n * flags into the command flags used by the Redis core.\n *\n * It returns the set of flags, or -1 if unknown flags are found. */\nint commandFlagsFromString(char *s) {\n    int count, j;\n    int flags = 0;\n    sds *tokens = sdssplitlen(s,strlen(s),\" \",1,&count);\n    for (j = 0; j < count; j++) {\n        char *t = tokens[j];\n        if (!strcasecmp(t,\"write\")) flags |= CMD_WRITE;\n        else if (!strcasecmp(t,\"readonly\")) flags |= CMD_READONLY;\n        else if (!strcasecmp(t,\"admin\")) flags |= CMD_ADMIN;\n        else if (!strcasecmp(t,\"deny-oom\")) flags |= CMD_DENYOOM;\n        else if (!strcasecmp(t,\"deny-script\")) flags |= CMD_NOSCRIPT;\n        else if (!strcasecmp(t,\"allow-loading\")) flags |= CMD_LOADING;\n        else if (!strcasecmp(t,\"pubsub\")) flags |= CMD_PUBSUB;\n        else if (!strcasecmp(t,\"random\")) flags |= CMD_RANDOM;\n        else if (!strcasecmp(t,\"allow-stale\")) flags |= CMD_STALE;\n        else if (!strcasecmp(t,\"no-monitor\")) flags |= CMD_SKIP_MONITOR;\n        else if (!strcasecmp(t,\"fast\")) flags |= CMD_FAST;\n        else if (!strcasecmp(t,\"getkeys-api\")) flags |= CMD_MODULE_GETKEYS;\n        else if (!strcasecmp(t,\"no-cluster\")) flags |= CMD_MODULE_NO_CLUSTER;\n        else break;\n    }\n    sdsfreesplitres(tokens,count);\n    if (j != count) return -1; /* Some token not processed correctly. */\n    return flags;\n}\n\n/* Register a new command in the Redis server, that will be handled by\n * calling the function pointer 'func' using the RedisModule calling\n * convention. The function returns REDISMODULE_ERR if the specified command\n * name is already busy or a set of invalid flags were passed, otherwise\n * REDISMODULE_OK is returned and the new command is registered.\n *\n * This function must be called during the initialization of the module\n * inside the RedisModule_OnLoad() function. Calling this function outside\n * of the initialization function is not defined.\n *\n * The command function type is the following:\n *\n *      int MyCommand_RedisCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc);\n *\n * And is supposed to always return REDISMODULE_OK.\n *\n * The set of flags 'strflags' specify the behavior of the command, and should\n * be passed as a C string composed of space separated words, like for\n * example \"write deny-oom\". The set of flags are:\n *\n * * **\"write\"**:     The command may modify the data set (it may also read\n *                    from it).\n * * **\"readonly\"**:  The command returns data from keys but never writes.\n * * **\"admin\"**:     The command is an administrative command (may change\n *                    replication or perform similar tasks).\n * * **\"deny-oom\"**:  The command may use additional memory and should be\n *                    denied during out of memory conditions.\n * * **\"deny-script\"**:   Don't allow this command in Lua scripts.\n * * **\"allow-loading\"**: Allow this command while the server is loading data.\n *                        Only commands not interacting with the data set\n *                        should be allowed to run in this mode. If not sure\n *                        don't use this flag.\n * * **\"pubsub\"**:    The command publishes things on Pub/Sub channels.\n * * **\"random\"**:    The command may have different outputs even starting\n *                    from the same input arguments and key values.\n * * **\"allow-stale\"**: The command is allowed to run on slaves that don't\n *                      serve stale data. Don't use if you don't know what\n *                      this means.\n * * **\"no-monitor\"**: Don't propagate the command on monitor. Use this if\n *                     the command has sensible data among the arguments.\n * * **\"fast\"**:      The command time complexity is not greater\n *                    than O(log(N)) where N is the size of the collection or\n *                    anything else representing the normal scalability\n *                    issue with the command.\n * * **\"getkeys-api\"**: The command implements the interface to return\n *                      the arguments that are keys. Used when start/stop/step\n *                      is not enough because of the command syntax.\n * * **\"no-cluster\"**: The command should not register in Redis Cluster\n *                     since is not designed to work with it because, for\n *                     example, is unable to report the position of the\n *                     keys, programmatically creates key names, or any\n *                     other reason.\n */\nint RM_CreateCommand(RedisModuleCtx *ctx, const char *name, RedisModuleCmdFunc cmdfunc, const char *strflags, int firstkey, int lastkey, int keystep) {\n    int flags = strflags ? commandFlagsFromString((char*)strflags) : 0;\n    if (flags == -1) return REDISMODULE_ERR;\n    if ((flags & CMD_MODULE_NO_CLUSTER) && server.cluster_enabled)\n        return REDISMODULE_ERR;\n\n    struct redisCommand *rediscmd;\n    RedisModuleCommandProxy *cp;\n    sds cmdname = sdsnew(name);\n\n    /* Check if the command name is busy. */\n    if (lookupCommand(cmdname) != NULL) {\n        sdsfree(cmdname);\n        return REDISMODULE_ERR;\n    }\n\n    /* Create a command \"proxy\", which is a structure that is referenced\n     * in the command table, so that the generic command that works as\n     * binding between modules and Redis, can know what function to call\n     * and what the module is.\n     *\n     * Note that we use the Redis command table 'getkeys_proc' in order to\n     * pass a reference to the command proxy structure. */\n    cp = zmalloc(sizeof(*cp));\n    cp->module = ctx->module;\n    cp->func = cmdfunc;\n    cp->rediscmd = zmalloc(sizeof(*rediscmd));\n    cp->rediscmd->name = cmdname;\n    cp->rediscmd->proc = RedisModuleCommandDispatcher;\n    cp->rediscmd->arity = -1;\n    cp->rediscmd->flags = flags | CMD_MODULE;\n    cp->rediscmd->getkeys_proc = (redisGetKeysProc*)(unsigned long)cp;\n    cp->rediscmd->firstkey = firstkey;\n    cp->rediscmd->lastkey = lastkey;\n    cp->rediscmd->keystep = keystep;\n    cp->rediscmd->microseconds = 0;\n    cp->rediscmd->calls = 0;\n    dictAdd(server.commands,sdsdup(cmdname),cp->rediscmd);\n    dictAdd(server.orig_commands,sdsdup(cmdname),cp->rediscmd);\n    return REDISMODULE_OK;\n}\n\n/* Called by RM_Init() to setup the `ctx->module` structure.\n *\n * This is an internal function, Redis modules developers don't need\n * to use it. */\nvoid RM_SetModuleAttribs(RedisModuleCtx *ctx, const char *name, int ver, int apiver) {\n    RedisModule *module;\n\n    if (ctx->module != NULL) return;\n    module = zmalloc(sizeof(*module));\n    module->name = sdsnew((char*)name);\n    module->ver = ver;\n    module->apiver = apiver;\n    module->types = listCreate();\n    ctx->module = module;\n}\n\n/* Return non-zero if the module name is busy.\n * Otherwise zero is returned. */\nint RM_IsModuleNameBusy(const char *name) {\n    sds modulename = sdsnew(name);\n    dictEntry *de = dictFind(modules,modulename);\n    sdsfree(modulename);\n    return de != NULL;\n}\n\n/* Return the current UNIX time in milliseconds. */\nlong long RM_Milliseconds(void) {\n    return mstime();\n}\n\n/* --------------------------------------------------------------------------\n * Automatic memory management for modules\n * -------------------------------------------------------------------------- */\n\n/* Enable automatic memory management. See API.md for more information.\n *\n * The function must be called as the first function of a command implementation\n * that wants to use automatic memory. */\nvoid RM_AutoMemory(RedisModuleCtx *ctx) {\n    ctx->flags |= REDISMODULE_CTX_AUTO_MEMORY;\n}\n\n/* Add a new object to release automatically when the callback returns. */\nvoid autoMemoryAdd(RedisModuleCtx *ctx, int type, void *ptr) {\n    if (!(ctx->flags & REDISMODULE_CTX_AUTO_MEMORY)) return;\n    if (ctx->amqueue_used == ctx->amqueue_len) {\n        ctx->amqueue_len *= 2;\n        if (ctx->amqueue_len < 16) ctx->amqueue_len = 16;\n        ctx->amqueue = zrealloc(ctx->amqueue,sizeof(struct AutoMemEntry)*ctx->amqueue_len);\n    }\n    ctx->amqueue[ctx->amqueue_used].type = type;\n    ctx->amqueue[ctx->amqueue_used].ptr = ptr;\n    ctx->amqueue_used++;\n}\n\n/* Mark an object as freed in the auto release queue, so that users can still\n * free things manually if they want.\n *\n * The function returns 1 if the object was actually found in the auto memory\n * pool, otherwise 0 is returned. */\nint autoMemoryFreed(RedisModuleCtx *ctx, int type, void *ptr) {\n    if (!(ctx->flags & REDISMODULE_CTX_AUTO_MEMORY)) return 0;\n\n    int count = (ctx->amqueue_used+1)/2;\n    for (int j = 0; j < count; j++) {\n        for (int side = 0; side < 2; side++) {\n            /* For side = 0 check right side of the array, for\n             * side = 1 check the left side instead (zig-zag scanning). */\n            int i = (side == 0) ? (ctx->amqueue_used - 1 - j) : j;\n            if (ctx->amqueue[i].type == type &&\n                ctx->amqueue[i].ptr == ptr)\n            {\n                ctx->amqueue[i].type = REDISMODULE_AM_FREED;\n\n                /* Switch the freed element and the last element, to avoid growing\n                 * the queue unnecessarily if we allocate/free in a loop */\n                if (i != ctx->amqueue_used-1) {\n                    ctx->amqueue[i] = ctx->amqueue[ctx->amqueue_used-1];\n                }\n\n                /* Reduce the size of the queue because we either moved the top\n                 * element elsewhere or freed it */\n                ctx->amqueue_used--;\n                return 1;\n            }\n        }\n    }\n    return 0;\n}\n\n/* Release all the objects in queue. */\nvoid autoMemoryCollect(RedisModuleCtx *ctx) {\n    if (!(ctx->flags & REDISMODULE_CTX_AUTO_MEMORY)) return;\n    /* Clear the AUTO_MEMORY flag from the context, otherwise the functions\n     * we call to free the resources, will try to scan the auto release\n     * queue to mark the entries as freed. */\n    ctx->flags &= ~REDISMODULE_CTX_AUTO_MEMORY;\n    int j;\n    for (j = 0; j < ctx->amqueue_used; j++) {\n        void *ptr = ctx->amqueue[j].ptr;\n        switch(ctx->amqueue[j].type) {\n        case REDISMODULE_AM_STRING: decrRefCount(ptr); break;\n        case REDISMODULE_AM_REPLY: RM_FreeCallReply(ptr); break;\n        case REDISMODULE_AM_KEY: RM_CloseKey(ptr); break;\n        case REDISMODULE_AM_DICT: RM_FreeDict(NULL,ptr); break;\n        }\n    }\n    ctx->flags |= REDISMODULE_CTX_AUTO_MEMORY;\n    zfree(ctx->amqueue);\n    ctx->amqueue = NULL;\n    ctx->amqueue_len = 0;\n    ctx->amqueue_used = 0;\n}\n\n/* --------------------------------------------------------------------------\n * String objects APIs\n * -------------------------------------------------------------------------- */\n\n/* Create a new module string object. The returned string must be freed\n * with RedisModule_FreeString(), unless automatic memory is enabled.\n *\n * The string is created by copying the `len` bytes starting\n * at `ptr`. No reference is retained to the passed buffer.\n *\n * The module context 'ctx' is optional and may be NULL if you want to create\n * a string out of the context scope. However in that case, the automatic\n * memory management will not be available, and the string memory must be\n * managed manually. */\nRedisModuleString *RM_CreateString(RedisModuleCtx *ctx, const char *ptr, size_t len) {\n    RedisModuleString *o = createStringObject(ptr,len);\n    if (ctx != NULL) autoMemoryAdd(ctx,REDISMODULE_AM_STRING,o);\n    return o;\n}\n\n/* Create a new module string object from a printf format and arguments.\n * The returned string must be freed with RedisModule_FreeString(), unless\n * automatic memory is enabled.\n *\n * The string is created using the sds formatter function sdscatvprintf().\n *\n * The passed context 'ctx' may be NULL if necessary, see the\n * RedisModule_CreateString() documentation for more info. */\nRedisModuleString *RM_CreateStringPrintf(RedisModuleCtx *ctx, const char *fmt, ...) {\n    sds s = sdsempty();\n\n    va_list ap;\n    va_start(ap, fmt);\n    s = sdscatvprintf(s, fmt, ap);\n    va_end(ap);\n\n    RedisModuleString *o = createObject(OBJ_STRING, s);\n    if (ctx != NULL) autoMemoryAdd(ctx,REDISMODULE_AM_STRING,o);\n\n    return o;\n}\n\n\n/* Like RedisModule_CreatString(), but creates a string starting from a long long\n * integer instead of taking a buffer and its length.\n *\n * The returned string must be released with RedisModule_FreeString() or by\n * enabling automatic memory management.\n *\n * The passed context 'ctx' may be NULL if necessary, see the\n * RedisModule_CreateString() documentation for more info. */\nRedisModuleString *RM_CreateStringFromLongLong(RedisModuleCtx *ctx, long long ll) {\n    char buf[LONG_STR_SIZE];\n    size_t len = ll2string(buf,sizeof(buf),ll);\n    return RM_CreateString(ctx,buf,len);\n}\n\n/* Like RedisModule_CreatString(), but creates a string starting from another\n * RedisModuleString.\n *\n * The returned string must be released with RedisModule_FreeString() or by\n * enabling automatic memory management.\n *\n * The passed context 'ctx' may be NULL if necessary, see the\n * RedisModule_CreateString() documentation for more info. */\nRedisModuleString *RM_CreateStringFromString(RedisModuleCtx *ctx, const RedisModuleString *str) {\n    RedisModuleString *o = dupStringObject(str);\n    if (ctx != NULL) autoMemoryAdd(ctx,REDISMODULE_AM_STRING,o);\n    return o;\n}\n\n/* Free a module string object obtained with one of the Redis modules API calls\n * that return new string objects.\n *\n * It is possible to call this function even when automatic memory management\n * is enabled. In that case the string will be released ASAP and removed\n * from the pool of string to release at the end.\n *\n * If the string was created with a NULL context 'ctx', it is also possible to\n * pass ctx as NULL when releasing the string (but passing a context will not\n * create any issue). Strings created with a context should be freed also passing\n * the context, so if you want to free a string out of context later, make sure\n * to create it using a NULL context. */\nvoid RM_FreeString(RedisModuleCtx *ctx, RedisModuleString *str) {\n    decrRefCount(str);\n    if (ctx != NULL) autoMemoryFreed(ctx,REDISMODULE_AM_STRING,str);\n}\n\n/* Every call to this function, will make the string 'str' requiring\n * an additional call to RedisModule_FreeString() in order to really\n * free the string. Note that the automatic freeing of the string obtained\n * enabling modules automatic memory management counts for one\n * RedisModule_FreeString() call (it is just executed automatically).\n *\n * Normally you want to call this function when, at the same time\n * the following conditions are true:\n *\n * 1) You have automatic memory management enabled.\n * 2) You want to create string objects.\n * 3) Those string objects you create need to live *after* the callback\n *    function(for example a command implementation) creating them returns.\n *\n * Usually you want this in order to store the created string object\n * into your own data structure, for example when implementing a new data\n * type.\n *\n * Note that when memory management is turned off, you don't need\n * any call to RetainString() since creating a string will always result\n * into a string that lives after the callback function returns, if\n * no FreeString() call is performed.\n *\n * It is possible to call this function with a NULL context. */\nvoid RM_RetainString(RedisModuleCtx *ctx, RedisModuleString *str) {\n    if (ctx == NULL || !autoMemoryFreed(ctx,REDISMODULE_AM_STRING,str)) {\n        /* Increment the string reference counting only if we can't\n         * just remove the object from the list of objects that should\n         * be reclaimed. Why we do that, instead of just incrementing\n         * the refcount in any case, and let the automatic FreeString()\n         * call at the end to bring the refcount back at the desired\n         * value? Because this way we ensure that the object refcount\n         * value is 1 (instead of going to 2 to be dropped later to 1)\n         * after the call to this function. This is needed for functions\n         * like RedisModule_StringAppendBuffer() to work. */\n        incrRefCount(str);\n    }\n}\n\n/* Given a string module object, this function returns the string pointer\n * and length of the string. The returned pointer and length should only\n * be used for read only accesses and never modified. */\nconst char *RM_StringPtrLen(const RedisModuleString *str, size_t *len) {\n    if (str == NULL) {\n        const char *errmsg = \"(NULL string reply referenced in module)\";\n        if (len) *len = strlen(errmsg);\n        return errmsg;\n    }\n    if (len) *len = sdslen(str->ptr);\n    return str->ptr;\n}\n\n/* --------------------------------------------------------------------------\n * Higher level string operations\n * ------------------------------------------------------------------------- */\n\n/* Convert the string into a long long integer, storing it at `*ll`.\n * Returns REDISMODULE_OK on success. If the string can't be parsed\n * as a valid, strict long long (no spaces before/after), REDISMODULE_ERR\n * is returned. */\nint RM_StringToLongLong(const RedisModuleString *str, long long *ll) {\n    return string2ll(str->ptr,sdslen(str->ptr),ll) ? REDISMODULE_OK :\n                                                     REDISMODULE_ERR;\n}\n\n/* Convert the string into a double, storing it at `*d`.\n * Returns REDISMODULE_OK on success or REDISMODULE_ERR if the string is\n * not a valid string representation of a double value. */\nint RM_StringToDouble(const RedisModuleString *str, double *d) {\n    int retval = getDoubleFromObject(str,d);\n    return (retval == C_OK) ? REDISMODULE_OK : REDISMODULE_ERR;\n}\n\n/* Compare two string objects, returning -1, 0 or 1 respectively if\n * a < b, a == b, a > b. Strings are compared byte by byte as two\n * binary blobs without any encoding care / collation attempt. */\nint RM_StringCompare(RedisModuleString *a, RedisModuleString *b) {\n    return compareStringObjects(a,b);\n}\n\n/* Return the (possibly modified in encoding) input 'str' object if\n * the string is unshared, otherwise NULL is returned. */\nRedisModuleString *moduleAssertUnsharedString(RedisModuleString *str) {\n    if (str->refcount != 1) {\n        serverLog(LL_WARNING,\n            \"Module attempted to use an in-place string modify operation \"\n            \"with a string referenced multiple times. Please check the code \"\n            \"for API usage correctness.\");\n        return NULL;\n    }\n    if (str->encoding == OBJ_ENCODING_EMBSTR) {\n        /* Note: here we \"leak\" the additional allocation that was\n         * used in order to store the embedded string in the object. */\n        str->ptr = sdsnewlen(str->ptr,sdslen(str->ptr));\n        str->encoding = OBJ_ENCODING_RAW;\n    } else if (str->encoding == OBJ_ENCODING_INT) {\n        /* Convert the string from integer to raw encoding. */\n        str->ptr = sdsfromlonglong((long)str->ptr);\n        str->encoding = OBJ_ENCODING_RAW;\n    }\n    return str;\n}\n\n/* Append the specified buffer to the string 'str'. The string must be a\n * string created by the user that is referenced only a single time, otherwise\n * REDISMODULE_ERR is returned and the operation is not performed. */\nint RM_StringAppendBuffer(RedisModuleCtx *ctx, RedisModuleString *str, const char *buf, size_t len) {\n    UNUSED(ctx);\n    str = moduleAssertUnsharedString(str);\n    if (str == NULL) return REDISMODULE_ERR;\n    str->ptr = sdscatlen(str->ptr,buf,len);\n    return REDISMODULE_OK;\n}\n\n/* --------------------------------------------------------------------------\n * Reply APIs\n *\n * Most functions always return REDISMODULE_OK so you can use it with\n * 'return' in order to return from the command implementation with:\n *\n *     if (... some condition ...)\n *         return RM_ReplyWithLongLong(ctx,mycount);\n * -------------------------------------------------------------------------- */\n\n/* Send an error about the number of arguments given to the command,\n * citing the command name in the error message.\n *\n * Example:\n *\n *     if (argc != 3) return RedisModule_WrongArity(ctx);\n */\nint RM_WrongArity(RedisModuleCtx *ctx) {\n    addReplyErrorFormat(ctx->client,\n        \"wrong number of arguments for '%s' command\",\n        (char*)ctx->client->argv[0]->ptr);\n    return REDISMODULE_OK;\n}\n\n/* Return the client object the `RM_Reply*` functions should target.\n * Normally this is just `ctx->client`, that is the client that called\n * the module command, however in the case of thread safe contexts there\n * is no directly associated client (since it would not be safe to access\n * the client from a thread), so instead the blocked client object referenced\n * in the thread safe context, has a fake client that we just use to accumulate\n * the replies. Later, when the client is unblocked, the accumulated replies\n * are appended to the actual client.\n *\n * The function returns the client pointer depending on the context, or\n * NULL if there is no potential client. This happens when we are in the\n * context of a thread safe context that was not initialized with a blocked\n * client object. Other contexts without associated clients are the ones\n * initialized to run the timers callbacks. */\nclient *moduleGetReplyClient(RedisModuleCtx *ctx) {\n    if (ctx->flags & REDISMODULE_CTX_THREAD_SAFE) {\n        if (ctx->blocked_client)\n            return ctx->blocked_client->reply_client;\n        else\n            return NULL;\n    } else {\n        /* If this is a non thread safe context, just return the client\n         * that is running the command if any. This may be NULL as well\n         * in the case of contexts that are not executed with associated\n         * clients, like timer contexts. */\n        return ctx->client;\n    }\n}\n\n/* Send an integer reply to the client, with the specified long long value.\n * The function always returns REDISMODULE_OK. */\nint RM_ReplyWithLongLong(RedisModuleCtx *ctx, long long ll) {\n    client *c = moduleGetReplyClient(ctx);\n    if (c == NULL) return REDISMODULE_OK;\n    addReplyLongLong(c,ll);\n    return REDISMODULE_OK;\n}\n\n/* Reply with an error or simple string (status message). Used to implement\n * ReplyWithSimpleString() and ReplyWithError().\n * The function always returns REDISMODULE_OK. */\nint replyWithStatus(RedisModuleCtx *ctx, const char *msg, char *prefix) {\n    client *c = moduleGetReplyClient(ctx);\n    if (c == NULL) return REDISMODULE_OK;\n    sds strmsg = sdsnewlen(prefix,1);\n    strmsg = sdscat(strmsg,msg);\n    strmsg = sdscatlen(strmsg,\"\\r\\n\",2);\n    addReplySds(c,strmsg);\n    return REDISMODULE_OK;\n}\n\n/* Reply with the error 'err'.\n *\n * Note that 'err' must contain all the error, including\n * the initial error code. The function only provides the initial \"-\", so\n * the usage is, for example:\n *\n *     RedisModule_ReplyWithError(ctx,\"ERR Wrong Type\");\n *\n * and not just:\n *\n *     RedisModule_ReplyWithError(ctx,\"Wrong Type\");\n *\n * The function always returns REDISMODULE_OK.\n */\nint RM_ReplyWithError(RedisModuleCtx *ctx, const char *err) {\n    return replyWithStatus(ctx,err,\"-\");\n}\n\n/* Reply with a simple string (+... \\r\\n in RESP protocol). This replies\n * are suitable only when sending a small non-binary string with small\n * overhead, like \"OK\" or similar replies.\n *\n * The function always returns REDISMODULE_OK. */\nint RM_ReplyWithSimpleString(RedisModuleCtx *ctx, const char *msg) {\n    return replyWithStatus(ctx,msg,\"+\");\n}\n\n/* Reply with an array type of 'len' elements. However 'len' other calls\n * to `ReplyWith*` style functions must follow in order to emit the elements\n * of the array.\n *\n * When producing arrays with a number of element that is not known beforehand\n * the function can be called with the special count\n * REDISMODULE_POSTPONED_ARRAY_LEN, and the actual number of elements can be\n * later set with RedisModule_ReplySetArrayLength() (which will set the\n * latest \"open\" count if there are multiple ones).\n *\n * The function always returns REDISMODULE_OK. */\nint RM_ReplyWithArray(RedisModuleCtx *ctx, long len) {\n    client *c = moduleGetReplyClient(ctx);\n    if (c == NULL) return REDISMODULE_OK;\n    if (len == REDISMODULE_POSTPONED_ARRAY_LEN) {\n        ctx->postponed_arrays = zrealloc(ctx->postponed_arrays,sizeof(void*)*\n                (ctx->postponed_arrays_count+1));\n        ctx->postponed_arrays[ctx->postponed_arrays_count] =\n            addDeferredMultiBulkLength(c);\n        ctx->postponed_arrays_count++;\n    } else {\n        addReplyMultiBulkLen(c,len);\n    }\n    return REDISMODULE_OK;\n}\n\n/* When RedisModule_ReplyWithArray() is used with the argument\n * REDISMODULE_POSTPONED_ARRAY_LEN, because we don't know beforehand the number\n * of items we are going to output as elements of the array, this function\n * will take care to set the array length.\n *\n * Since it is possible to have multiple array replies pending with unknown\n * length, this function guarantees to always set the latest array length\n * that was created in a postponed way.\n *\n * For example in order to output an array like [1,[10,20,30]] we\n * could write:\n *\n *      RedisModule_ReplyWithArray(ctx,REDISMODULE_POSTPONED_ARRAY_LEN);\n *      RedisModule_ReplyWithLongLong(ctx,1);\n *      RedisModule_ReplyWithArray(ctx,REDISMODULE_POSTPONED_ARRAY_LEN);\n *      RedisModule_ReplyWithLongLong(ctx,10);\n *      RedisModule_ReplyWithLongLong(ctx,20);\n *      RedisModule_ReplyWithLongLong(ctx,30);\n *      RedisModule_ReplySetArrayLength(ctx,3); // Set len of 10,20,30 array.\n *      RedisModule_ReplySetArrayLength(ctx,2); // Set len of top array\n *\n * Note that in the above example there is no reason to postpone the array\n * length, since we produce a fixed number of elements, but in the practice\n * the code may use an iterator or other ways of creating the output so\n * that is not easy to calculate in advance the number of elements.\n */\nvoid RM_ReplySetArrayLength(RedisModuleCtx *ctx, long len) {\n    client *c = moduleGetReplyClient(ctx);\n    if (c == NULL) return;\n    if (ctx->postponed_arrays_count == 0) {\n        serverLog(LL_WARNING,\n            \"API misuse detected in module %s: \"\n            \"RedisModule_ReplySetArrayLength() called without previous \"\n            \"RedisModule_ReplyWithArray(ctx,REDISMODULE_POSTPONED_ARRAY_LEN) \"\n            \"call.\", ctx->module->name);\n            return;\n    }\n    ctx->postponed_arrays_count--;\n    setDeferredMultiBulkLength(c,\n            ctx->postponed_arrays[ctx->postponed_arrays_count],\n            len);\n    if (ctx->postponed_arrays_count == 0) {\n        zfree(ctx->postponed_arrays);\n        ctx->postponed_arrays = NULL;\n    }\n}\n\n/* Reply with a bulk string, taking in input a C buffer pointer and length.\n *\n * The function always returns REDISMODULE_OK. */\nint RM_ReplyWithStringBuffer(RedisModuleCtx *ctx, const char *buf, size_t len) {\n    client *c = moduleGetReplyClient(ctx);\n    if (c == NULL) return REDISMODULE_OK;\n    addReplyBulkCBuffer(c,(char*)buf,len);\n    return REDISMODULE_OK;\n}\n\n/* Reply with a bulk string, taking in input a RedisModuleString object.\n *\n * The function always returns REDISMODULE_OK. */\nint RM_ReplyWithString(RedisModuleCtx *ctx, RedisModuleString *str) {\n    client *c = moduleGetReplyClient(ctx);\n    if (c == NULL) return REDISMODULE_OK;\n    addReplyBulk(c,str);\n    return REDISMODULE_OK;\n}\n\n/* Reply to the client with a NULL. In the RESP protocol a NULL is encoded\n * as the string \"$-1\\r\\n\".\n *\n * The function always returns REDISMODULE_OK. */\nint RM_ReplyWithNull(RedisModuleCtx *ctx) {\n    client *c = moduleGetReplyClient(ctx);\n    if (c == NULL) return REDISMODULE_OK;\n    addReply(c,shared.nullbulk);\n    return REDISMODULE_OK;\n}\n\n/* Reply exactly what a Redis command returned us with RedisModule_Call().\n * This function is useful when we use RedisModule_Call() in order to\n * execute some command, as we want to reply to the client exactly the\n * same reply we obtained by the command.\n *\n * The function always returns REDISMODULE_OK. */\nint RM_ReplyWithCallReply(RedisModuleCtx *ctx, RedisModuleCallReply *reply) {\n    client *c = moduleGetReplyClient(ctx);\n    if (c == NULL) return REDISMODULE_OK;\n    sds proto = sdsnewlen(reply->proto, reply->protolen);\n    addReplySds(c,proto);\n    return REDISMODULE_OK;\n}\n\n/* Send a string reply obtained converting the double 'd' into a bulk string.\n * This function is basically equivalent to converting a double into\n * a string into a C buffer, and then calling the function\n * RedisModule_ReplyWithStringBuffer() with the buffer and length.\n *\n * The function always returns REDISMODULE_OK. */\nint RM_ReplyWithDouble(RedisModuleCtx *ctx, double d) {\n    client *c = moduleGetReplyClient(ctx);\n    if (c == NULL) return REDISMODULE_OK;\n    addReplyDouble(c,d);\n    return REDISMODULE_OK;\n}\n\n/* --------------------------------------------------------------------------\n * Commands replication API\n * -------------------------------------------------------------------------- */\n\n/* Helper function to replicate MULTI the first time we replicate something\n * in the context of a command execution. EXEC will be handled by the\n * RedisModuleCommandDispatcher() function. */\nvoid moduleReplicateMultiIfNeeded(RedisModuleCtx *ctx) {\n    /* Skip this if client explicitly wrap the command with MULTI, or if\n     * the module command was called by a script. */\n    if (ctx->client->flags & (CLIENT_MULTI|CLIENT_LUA)) return;\n    /* If we already emitted MULTI return ASAP. */\n    if (ctx->flags & REDISMODULE_CTX_MULTI_EMITTED) return;\n    /* If this is a thread safe context, we do not want to wrap commands\n     * executed into MUTLI/EXEC, they are executed as single commands\n     * from an external client in essence. */\n    if (ctx->flags & REDISMODULE_CTX_THREAD_SAFE) return;\n    execCommandPropagateMulti(ctx->client);\n    ctx->flags |= REDISMODULE_CTX_MULTI_EMITTED;\n}\n\n/* Replicate the specified command and arguments to slaves and AOF, as effect\n * of execution of the calling command implementation.\n *\n * The replicated commands are always wrapped into the MULTI/EXEC that\n * contains all the commands replicated in a given module command\n * execution. However the commands replicated with RedisModule_Call()\n * are the first items, the ones replicated with RedisModule_Replicate()\n * will all follow before the EXEC.\n *\n * Modules should try to use one interface or the other.\n *\n * This command follows exactly the same interface of RedisModule_Call(),\n * so a set of format specifiers must be passed, followed by arguments\n * matching the provided format specifiers.\n *\n * Please refer to RedisModule_Call() for more information.\n *\n * The command returns REDISMODULE_ERR if the format specifiers are invalid\n * or the command name does not belong to a known command. */\nint RM_Replicate(RedisModuleCtx *ctx, const char *cmdname, const char *fmt, ...) {\n    struct redisCommand *cmd;\n    robj **argv = NULL;\n    int argc = 0, flags = 0, j;\n    va_list ap;\n\n    cmd = lookupCommandByCString((char*)cmdname);\n    if (!cmd) return REDISMODULE_ERR;\n\n    /* Create the client and dispatch the command. */\n    va_start(ap, fmt);\n    argv = moduleCreateArgvFromUserFormat(cmdname,fmt,&argc,&flags,ap);\n    va_end(ap);\n    if (argv == NULL) return REDISMODULE_ERR;\n\n    /* Replicate! */\n    moduleReplicateMultiIfNeeded(ctx);\n    alsoPropagate(cmd,ctx->client->db->id,argv,argc,\n        PROPAGATE_AOF|PROPAGATE_REPL);\n\n    /* Release the argv. */\n    for (j = 0; j < argc; j++) decrRefCount(argv[j]);\n    zfree(argv);\n    server.dirty++;\n    return REDISMODULE_OK;\n}\n\n/* This function will replicate the command exactly as it was invoked\n * by the client. Note that this function will not wrap the command into\n * a MULTI/EXEC stanza, so it should not be mixed with other replication\n * commands.\n *\n * Basically this form of replication is useful when you want to propagate\n * the command to the slaves and AOF file exactly as it was called, since\n * the command can just be re-executed to deterministically re-create the\n * new state starting from the old one.\n *\n * The function always returns REDISMODULE_OK. */\nint RM_ReplicateVerbatim(RedisModuleCtx *ctx) {\n    alsoPropagate(ctx->client->cmd,ctx->client->db->id,\n        ctx->client->argv,ctx->client->argc,\n        PROPAGATE_AOF|PROPAGATE_REPL);\n    server.dirty++;\n    return REDISMODULE_OK;\n}\n\n/* --------------------------------------------------------------------------\n * DB and Key APIs -- Generic API\n * -------------------------------------------------------------------------- */\n\n/* Return the ID of the current client calling the currently active module\n * command. The returned ID has a few guarantees:\n *\n * 1. The ID is different for each different client, so if the same client\n *    executes a module command multiple times, it can be recognized as\n *    having the same ID, otherwise the ID will be different.\n * 2. The ID increases monotonically. Clients connecting to the server later\n *    are guaranteed to get IDs greater than any past ID previously seen.\n *\n * Valid IDs are from 1 to 2^64-1. If 0 is returned it means there is no way\n * to fetch the ID in the context the function was currently called. */\nunsigned long long RM_GetClientId(RedisModuleCtx *ctx) {\n    if (ctx->client == NULL) return 0;\n    return ctx->client->id;\n}\n\n/* Return the currently selected DB. */\nint RM_GetSelectedDb(RedisModuleCtx *ctx) {\n    return ctx->client->db->id;\n}\n\n\n/* Return the current context's flags. The flags provide information on the\n * current request context (whether the client is a Lua script or in a MULTI),\n * and about the Redis instance in general, i.e replication and persistence.\n *\n * The available flags are:\n *\n *  * REDISMODULE_CTX_FLAGS_LUA: The command is running in a Lua script\n *\n *  * REDISMODULE_CTX_FLAGS_MULTI: The command is running inside a transaction\n *\n *  * REDISMODULE_CTX_FLAGS_MASTER: The Redis instance is a master\n *\n *  * REDISMODULE_CTX_FLAGS_SLAVE: The Redis instance is a slave\n *\n *  * REDISMODULE_CTX_FLAGS_READONLY: The Redis instance is read-only\n *\n *  * REDISMODULE_CTX_FLAGS_CLUSTER: The Redis instance is in cluster mode\n *\n *  * REDISMODULE_CTX_FLAGS_AOF: The Redis instance has AOF enabled\n *\n *  * REDISMODULE_CTX_FLAGS_RDB: The instance has RDB enabled\n *\n *  * REDISMODULE_CTX_FLAGS_MAXMEMORY:  The instance has Maxmemory set\n *\n *  * REDISMODULE_CTX_FLAGS_EVICT:  Maxmemory is set and has an eviction\n *    policy that may delete keys\n *\n *  * REDISMODULE_CTX_FLAGS_OOM: Redis is out of memory according to the\n *    maxmemory setting.\n *\n *  * REDISMODULE_CTX_FLAGS_OOM_WARNING: Less than 25% of memory remains before\n *                                       reaching the maxmemory level.\n */\nint RM_GetContextFlags(RedisModuleCtx *ctx) {\n\n    int flags = 0;\n    /* Client specific flags */\n    if (ctx->client) {\n        if (ctx->client->flags & CLIENT_LUA)\n         flags |= REDISMODULE_CTX_FLAGS_LUA;\n        if (ctx->client->flags & CLIENT_MULTI)\n         flags |= REDISMODULE_CTX_FLAGS_MULTI;\n    }\n\n    if (server.cluster_enabled)\n        flags |= REDISMODULE_CTX_FLAGS_CLUSTER;\n\n    /* Maxmemory and eviction policy */\n    if (server.maxmemory > 0) {\n        flags |= REDISMODULE_CTX_FLAGS_MAXMEMORY;\n\n        if (server.maxmemory_policy != MAXMEMORY_NO_EVICTION)\n            flags |= REDISMODULE_CTX_FLAGS_EVICT;\n    }\n\n    /* Persistence flags */\n    if (server.aof_state != AOF_OFF)\n        flags |= REDISMODULE_CTX_FLAGS_AOF;\n    if (server.saveparamslen > 0)\n        flags |= REDISMODULE_CTX_FLAGS_RDB;\n\n    /* Replication flags */\n    if (server.masterhost == NULL) {\n        flags |= REDISMODULE_CTX_FLAGS_MASTER;\n    } else {\n        flags |= REDISMODULE_CTX_FLAGS_SLAVE;\n        if (server.repl_slave_ro)\n            flags |= REDISMODULE_CTX_FLAGS_READONLY;\n    }\n\n    /* OOM flag. */\n    float level;\n    int retval = getMaxmemoryState(NULL,NULL,NULL,&level);\n    if (retval == C_ERR) flags |= REDISMODULE_CTX_FLAGS_OOM;\n    if (level > 0.75) flags |= REDISMODULE_CTX_FLAGS_OOM_WARNING;\n\n    return flags;\n}\n\n/* Change the currently selected DB. Returns an error if the id\n * is out of range.\n *\n * Note that the client will retain the currently selected DB even after\n * the Redis command implemented by the module calling this function\n * returns.\n *\n * If the module command wishes to change something in a different DB and\n * returns back to the original one, it should call RedisModule_GetSelectedDb()\n * before in order to restore the old DB number before returning. */\nint RM_SelectDb(RedisModuleCtx *ctx, int newid) {\n    int retval = selectDb(ctx->client,newid);\n    return (retval == C_OK) ? REDISMODULE_OK : REDISMODULE_ERR;\n}\n\n/* Return an handle representing a Redis key, so that it is possible\n * to call other APIs with the key handle as argument to perform\n * operations on the key.\n *\n * The return value is the handle representing the key, that must be\n * closed with RM_CloseKey().\n *\n * If the key does not exist and WRITE mode is requested, the handle\n * is still returned, since it is possible to perform operations on\n * a yet not existing key (that will be created, for example, after\n * a list push operation). If the mode is just READ instead, and the\n * key does not exist, NULL is returned. However it is still safe to\n * call RedisModule_CloseKey() and RedisModule_KeyType() on a NULL\n * value. */\nvoid *RM_OpenKey(RedisModuleCtx *ctx, robj *keyname, int mode) {\n    RedisModuleKey *kp;\n    robj *value;\n\n    if (mode & REDISMODULE_WRITE) {\n        value = lookupKeyWrite(ctx->client->db,keyname);\n    } else {\n        value = lookupKeyRead(ctx->client->db,keyname);\n        if (value == NULL) {\n            return NULL;\n        }\n    }\n\n    /* Setup the key handle. */\n    kp = zmalloc(sizeof(*kp));\n    kp->ctx = ctx;\n    kp->db = ctx->client->db;\n    kp->key = keyname;\n    incrRefCount(keyname);\n    kp->value = value;\n    kp->iter = NULL;\n    kp->mode = mode;\n    zsetKeyReset(kp);\n    autoMemoryAdd(ctx,REDISMODULE_AM_KEY,kp);\n    return (void*)kp;\n}\n\n/* Close a key handle. */\nvoid RM_CloseKey(RedisModuleKey *key) {\n    if (key == NULL) return;\n    if (key->mode & REDISMODULE_WRITE) signalModifiedKey(key->db,key->key);\n    /* TODO: if (key->iter) RM_KeyIteratorStop(kp); */\n    RM_ZsetRangeStop(key);\n    decrRefCount(key->key);\n    autoMemoryFreed(key->ctx,REDISMODULE_AM_KEY,key);\n    zfree(key);\n}\n\n/* Return the type of the key. If the key pointer is NULL then\n * REDISMODULE_KEYTYPE_EMPTY is returned. */\nint RM_KeyType(RedisModuleKey *key) {\n    if (key == NULL || key->value ==  NULL) return REDISMODULE_KEYTYPE_EMPTY;\n    /* We map between defines so that we are free to change the internal\n     * defines as desired. */\n    switch(key->value->type) {\n    case OBJ_STRING: return REDISMODULE_KEYTYPE_STRING;\n    case OBJ_LIST: return REDISMODULE_KEYTYPE_LIST;\n    case OBJ_SET: return REDISMODULE_KEYTYPE_SET;\n    case OBJ_ZSET: return REDISMODULE_KEYTYPE_ZSET;\n    case OBJ_HASH: return REDISMODULE_KEYTYPE_HASH;\n    case OBJ_MODULE: return REDISMODULE_KEYTYPE_MODULE;\n    default: return 0;\n    }\n}\n\n/* Return the length of the value associated with the key.\n * For strings this is the length of the string. For all the other types\n * is the number of elements (just counting keys for hashes).\n *\n * If the key pointer is NULL or the key is empty, zero is returned. */\nsize_t RM_ValueLength(RedisModuleKey *key) {\n    if (key == NULL || key->value == NULL) return 0;\n    switch(key->value->type) {\n    case OBJ_STRING: return stringObjectLen(key->value);\n    case OBJ_LIST: return listTypeLength(key->value);\n    case OBJ_SET: return setTypeSize(key->value);\n    case OBJ_ZSET: return zsetLength(key->value);\n    case OBJ_HASH: return hashTypeLength(key->value);\n    default: return 0;\n    }\n}\n\n/* If the key is open for writing, remove it, and setup the key to\n * accept new writes as an empty key (that will be created on demand).\n * On success REDISMODULE_OK is returned. If the key is not open for\n * writing REDISMODULE_ERR is returned. */\nint RM_DeleteKey(RedisModuleKey *key) {\n    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;\n    if (key->value) {\n        dbDelete(key->db,key->key);\n        key->value = NULL;\n    }\n    return REDISMODULE_OK;\n}\n\n/* If the key is open for writing, unlink it (that is delete it in a \n * non-blocking way, not reclaiming memory immediately) and setup the key to\n * accept new writes as an empty key (that will be created on demand).\n * On success REDISMODULE_OK is returned. If the key is not open for\n * writing REDISMODULE_ERR is returned. */\nint RM_UnlinkKey(RedisModuleKey *key) {\n    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;\n    if (key->value) {\n        dbAsyncDelete(key->db,key->key);\n        key->value = NULL;\n    }\n    return REDISMODULE_OK;\n}\n\n/* Return the key expire value, as milliseconds of remaining TTL.\n * If no TTL is associated with the key or if the key is empty,\n * REDISMODULE_NO_EXPIRE is returned. */\nmstime_t RM_GetExpire(RedisModuleKey *key) {\n    mstime_t expire = getExpire(key->db,key->key);\n    if (expire == -1 || key->value == NULL) return -1;\n    expire -= mstime();\n    return expire >= 0 ? expire : 0;\n}\n\n/* Set a new expire for the key. If the special expire\n * REDISMODULE_NO_EXPIRE is set, the expire is cancelled if there was\n * one (the same as the PERSIST command).\n *\n * Note that the expire must be provided as a positive integer representing\n * the number of milliseconds of TTL the key should have.\n *\n * The function returns REDISMODULE_OK on success or REDISMODULE_ERR if\n * the key was not open for writing or is an empty key. */\nint RM_SetExpire(RedisModuleKey *key, mstime_t expire) {\n    if (!(key->mode & REDISMODULE_WRITE) || key->value == NULL)\n        return REDISMODULE_ERR;\n    if (expire != REDISMODULE_NO_EXPIRE) {\n        expire += mstime();\n        setExpire(key->ctx->client,key->db,key->key,expire);\n    } else {\n        removeExpire(key->db,key->key);\n    }\n    return REDISMODULE_OK;\n}\n\n/* --------------------------------------------------------------------------\n * Key API for String type\n * -------------------------------------------------------------------------- */\n\n/* If the key is open for writing, set the specified string 'str' as the\n * value of the key, deleting the old value if any.\n * On success REDISMODULE_OK is returned. If the key is not open for\n * writing or there is an active iterator, REDISMODULE_ERR is returned. */\nint RM_StringSet(RedisModuleKey *key, RedisModuleString *str) {\n    if (!(key->mode & REDISMODULE_WRITE) || key->iter) return REDISMODULE_ERR;\n    RM_DeleteKey(key);\n    setKey(key->db,key->key,str);\n    key->value = str;\n    return REDISMODULE_OK;\n}\n\n/* Prepare the key associated string value for DMA access, and returns\n * a pointer and size (by reference), that the user can use to read or\n * modify the string in-place accessing it directly via pointer.\n *\n * The 'mode' is composed by bitwise OR-ing the following flags:\n *\n *     REDISMODULE_READ -- Read access\n *     REDISMODULE_WRITE -- Write access\n *\n * If the DMA is not requested for writing, the pointer returned should\n * only be accessed in a read-only fashion.\n *\n * On error (wrong type) NULL is returned.\n *\n * DMA access rules:\n *\n * 1. No other key writing function should be called since the moment\n * the pointer is obtained, for all the time we want to use DMA access\n * to read or modify the string.\n *\n * 2. Each time RM_StringTruncate() is called, to continue with the DMA\n * access, RM_StringDMA() should be called again to re-obtain\n * a new pointer and length.\n *\n * 3. If the returned pointer is not NULL, but the length is zero, no\n * byte can be touched (the string is empty, or the key itself is empty)\n * so a RM_StringTruncate() call should be used if there is to enlarge\n * the string, and later call StringDMA() again to get the pointer.\n */\nchar *RM_StringDMA(RedisModuleKey *key, size_t *len, int mode) {\n    /* We need to return *some* pointer for empty keys, we just return\n     * a string literal pointer, that is the advantage to be mapped into\n     * a read only memory page, so the module will segfault if a write\n     * attempt is performed. */\n    char *emptystring = \"<dma-empty-string>\";\n    if (key->value == NULL) {\n        *len = 0;\n        return emptystring;\n    }\n\n    if (key->value->type != OBJ_STRING) return NULL;\n\n    /* For write access, and even for read access if the object is encoded,\n     * we unshare the string (that has the side effect of decoding it). */\n    if ((mode & REDISMODULE_WRITE) || key->value->encoding != OBJ_ENCODING_RAW)\n        key->value = dbUnshareStringValue(key->db, key->key, key->value);\n\n    *len = sdslen(key->value->ptr);\n    return key->value->ptr;\n}\n\n/* If the string is open for writing and is of string type, resize it, padding\n * with zero bytes if the new length is greater than the old one.\n *\n * After this call, RM_StringDMA() must be called again to continue\n * DMA access with the new pointer.\n *\n * The function returns REDISMODULE_OK on success, and REDISMODULE_ERR on\n * error, that is, the key is not open for writing, is not a string\n * or resizing for more than 512 MB is requested.\n *\n * If the key is empty, a string key is created with the new string value\n * unless the new length value requested is zero. */\nint RM_StringTruncate(RedisModuleKey *key, size_t newlen) {\n    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;\n    if (key->value && key->value->type != OBJ_STRING) return REDISMODULE_ERR;\n    if (newlen > 512*1024*1024) return REDISMODULE_ERR;\n\n    /* Empty key and new len set to 0. Just return REDISMODULE_OK without\n     * doing anything. */\n    if (key->value == NULL && newlen == 0) return REDISMODULE_OK;\n\n    if (key->value == NULL) {\n        /* Empty key: create it with the new size. */\n        robj *o = createObject(OBJ_STRING,sdsnewlen(NULL, newlen));\n        setKey(key->db,key->key,o);\n        key->value = o;\n        decrRefCount(o);\n    } else {\n        /* Unshare and resize. */\n        key->value = dbUnshareStringValue(key->db, key->key, key->value);\n        size_t curlen = sdslen(key->value->ptr);\n        if (newlen > curlen) {\n            key->value->ptr = sdsgrowzero(key->value->ptr,newlen);\n        } else if (newlen < curlen) {\n            sdsrange(key->value->ptr,0,newlen-1);\n            /* If the string is too wasteful, reallocate it. */\n            if (sdslen(key->value->ptr) < sdsavail(key->value->ptr))\n                key->value->ptr = sdsRemoveFreeSpace(key->value->ptr);\n        }\n    }\n    return REDISMODULE_OK;\n}\n\n/* --------------------------------------------------------------------------\n * Key API for List type\n * -------------------------------------------------------------------------- */\n\n/* Push an element into a list, on head or tail depending on 'where' argument.\n * If the key pointer is about an empty key opened for writing, the key\n * is created. On error (key opened for read-only operations or of the wrong\n * type) REDISMODULE_ERR is returned, otherwise REDISMODULE_OK is returned. */\nint RM_ListPush(RedisModuleKey *key, int where, RedisModuleString *ele) {\n    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;\n    if (key->value && key->value->type != OBJ_LIST) return REDISMODULE_ERR;\n    if (key->value == NULL) moduleCreateEmptyKey(key,REDISMODULE_KEYTYPE_LIST);\n    listTypePush(key->value, ele,\n        (where == REDISMODULE_LIST_HEAD) ? QUICKLIST_HEAD : QUICKLIST_TAIL);\n    return REDISMODULE_OK;\n}\n\n/* Pop an element from the list, and returns it as a module string object\n * that the user should be free with RM_FreeString() or by enabling\n * automatic memory. 'where' specifies if the element should be popped from\n * head or tail. The command returns NULL if:\n * 1) The list is empty.\n * 2) The key was not open for writing.\n * 3) The key is not a list. */\nRedisModuleString *RM_ListPop(RedisModuleKey *key, int where) {\n    if (!(key->mode & REDISMODULE_WRITE) ||\n        key->value == NULL ||\n        key->value->type != OBJ_LIST) return NULL;\n    robj *ele = listTypePop(key->value,\n        (where == REDISMODULE_LIST_HEAD) ? QUICKLIST_HEAD : QUICKLIST_TAIL);\n    robj *decoded = getDecodedObject(ele);\n    decrRefCount(ele);\n    moduleDelKeyIfEmpty(key);\n    autoMemoryAdd(key->ctx,REDISMODULE_AM_STRING,decoded);\n    return decoded;\n}\n\n/* --------------------------------------------------------------------------\n * Key API for Sorted Set type\n * -------------------------------------------------------------------------- */\n\n/* Conversion from/to public flags of the Modules API and our private flags,\n * so that we have everything decoupled. */\nint RM_ZsetAddFlagsToCoreFlags(int flags) {\n    int retflags = 0;\n    if (flags & REDISMODULE_ZADD_XX) retflags |= ZADD_XX;\n    if (flags & REDISMODULE_ZADD_NX) retflags |= ZADD_NX;\n    return retflags;\n}\n\n/* See previous function comment. */\nint RM_ZsetAddFlagsFromCoreFlags(int flags) {\n    int retflags = 0;\n    if (flags & ZADD_ADDED) retflags |= REDISMODULE_ZADD_ADDED;\n    if (flags & ZADD_UPDATED) retflags |= REDISMODULE_ZADD_UPDATED;\n    if (flags & ZADD_NOP) retflags |= REDISMODULE_ZADD_NOP;\n    return retflags;\n}\n\n/* Add a new element into a sorted set, with the specified 'score'.\n * If the element already exists, the score is updated.\n *\n * A new sorted set is created at value if the key is an empty open key\n * setup for writing.\n *\n * Additional flags can be passed to the function via a pointer, the flags\n * are both used to receive input and to communicate state when the function\n * returns. 'flagsptr' can be NULL if no special flags are used.\n *\n * The input flags are:\n *\n *     REDISMODULE_ZADD_XX: Element must already exist. Do nothing otherwise.\n *     REDISMODULE_ZADD_NX: Element must not exist. Do nothing otherwise.\n *\n * The output flags are:\n *\n *     REDISMODULE_ZADD_ADDED: The new element was added to the sorted set.\n *     REDISMODULE_ZADD_UPDATED: The score of the element was updated.\n *     REDISMODULE_ZADD_NOP: No operation was performed because XX or NX flags.\n *\n * On success the function returns REDISMODULE_OK. On the following errors\n * REDISMODULE_ERR is returned:\n *\n * * The key was not opened for writing.\n * * The key is of the wrong type.\n * * 'score' double value is not a number (NaN).\n */\nint RM_ZsetAdd(RedisModuleKey *key, double score, RedisModuleString *ele, int *flagsptr) {\n    int flags = 0;\n    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;\n    if (key->value && key->value->type != OBJ_ZSET) return REDISMODULE_ERR;\n    if (key->value == NULL) moduleCreateEmptyKey(key,REDISMODULE_KEYTYPE_ZSET);\n    if (flagsptr) flags = RM_ZsetAddFlagsToCoreFlags(*flagsptr);\n    if (zsetAdd(key->value,score,ele->ptr,&flags,NULL) == 0) {\n        if (flagsptr) *flagsptr = 0;\n        return REDISMODULE_ERR;\n    }\n    if (flagsptr) *flagsptr = RM_ZsetAddFlagsFromCoreFlags(flags);\n    return REDISMODULE_OK;\n}\n\n/* This function works exactly like RM_ZsetAdd(), but instead of setting\n * a new score, the score of the existing element is incremented, or if the\n * element does not already exist, it is added assuming the old score was\n * zero.\n *\n * The input and output flags, and the return value, have the same exact\n * meaning, with the only difference that this function will return\n * REDISMODULE_ERR even when 'score' is a valid double number, but adding it\n * to the existing score results into a NaN (not a number) condition.\n *\n * This function has an additional field 'newscore', if not NULL is filled\n * with the new score of the element after the increment, if no error\n * is returned. */\nint RM_ZsetIncrby(RedisModuleKey *key, double score, RedisModuleString *ele, int *flagsptr, double *newscore) {\n    int flags = 0;\n    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;\n    if (key->value && key->value->type != OBJ_ZSET) return REDISMODULE_ERR;\n    if (key->value == NULL) moduleCreateEmptyKey(key,REDISMODULE_KEYTYPE_ZSET);\n    if (flagsptr) flags = RM_ZsetAddFlagsToCoreFlags(*flagsptr);\n    flags |= ZADD_INCR;\n    if (zsetAdd(key->value,score,ele->ptr,&flags,newscore) == 0) {\n        if (flagsptr) *flagsptr = 0;\n        return REDISMODULE_ERR;\n    }\n    /* zsetAdd() may signal back that the resulting score is not a number. */\n    if (flagsptr && (*flagsptr & ZADD_NAN)) {\n        *flagsptr = 0;\n        return REDISMODULE_ERR;\n    }\n    if (flagsptr) *flagsptr = RM_ZsetAddFlagsFromCoreFlags(flags);\n    return REDISMODULE_OK;\n}\n\n/* Remove the specified element from the sorted set.\n * The function returns REDISMODULE_OK on success, and REDISMODULE_ERR\n * on one of the following conditions:\n *\n * * The key was not opened for writing.\n * * The key is of the wrong type.\n *\n * The return value does NOT indicate the fact the element was really\n * removed (since it existed) or not, just if the function was executed\n * with success.\n *\n * In order to know if the element was removed, the additional argument\n * 'deleted' must be passed, that populates the integer by reference\n * setting it to 1 or 0 depending on the outcome of the operation.\n * The 'deleted' argument can be NULL if the caller is not interested\n * to know if the element was really removed.\n *\n * Empty keys will be handled correctly by doing nothing. */\nint RM_ZsetRem(RedisModuleKey *key, RedisModuleString *ele, int *deleted) {\n    if (!(key->mode & REDISMODULE_WRITE)) return REDISMODULE_ERR;\n    if (key->value && key->value->type != OBJ_ZSET) return REDISMODULE_ERR;\n    if (key->value != NULL && zsetDel(key->value,ele->ptr)) {\n        if (deleted) *deleted = 1;\n    } else {\n        if (deleted) *deleted = 0;\n    }\n    return REDISMODULE_OK;\n}\n\n/* On success retrieve the double score associated at the sorted set element\n * 'ele' and returns REDISMODULE_OK. Otherwise REDISMODULE_ERR is returned\n * to signal one of the following conditions:\n *\n * * There is no such element 'ele' in the sorted set.\n * * The key is not a sorted set.\n * * The key is an open empty key.\n */\nint RM_ZsetScore(RedisModuleKey *key, RedisModuleString *ele, double *score) {\n    if (key->value == NULL) return REDISMODULE_ERR;\n    if (key->value->type != OBJ_ZSET) return REDISMODULE_ERR;\n    if (zsetScore(key->value,ele->ptr,score) == C_ERR) return REDISMODULE_ERR;\n    return REDISMODULE_OK;\n}\n\n/* --------------------------------------------------------------------------\n * Key API for Sorted Set iterator\n * -------------------------------------------------------------------------- */\n\nvoid zsetKeyReset(RedisModuleKey *key) {\n    key->ztype = REDISMODULE_ZSET_RANGE_NONE;\n    key->zcurrent = NULL;\n    key->zer = 1;\n}\n\n/* Stop a sorted set iteration. */\nvoid RM_ZsetRangeStop(RedisModuleKey *key) {\n    /* Free resources if needed. */\n    if (key->ztype == REDISMODULE_ZSET_RANGE_LEX)\n        zslFreeLexRange(&key->zlrs);\n    /* Setup sensible values so that misused iteration API calls when an\n     * iterator is not active will result into something more sensible\n     * than crashing. */\n    zsetKeyReset(key);\n}\n\n/* Return the \"End of range\" flag value to signal the end of the iteration. */\nint RM_ZsetRangeEndReached(RedisModuleKey *key) {\n    return key->zer;\n}\n\n/* Helper function for RM_ZsetFirstInScoreRange() and RM_ZsetLastInScoreRange().\n * Setup the sorted set iteration according to the specified score range\n * (see the functions calling it for more info). If 'first' is true the\n * first element in the range is used as a starting point for the iterator\n * otherwise the last. Return REDISMODULE_OK on success otherwise\n * REDISMODULE_ERR. */\nint zsetInitScoreRange(RedisModuleKey *key, double min, double max, int minex, int maxex, int first) {\n    if (!key->value || key->value->type != OBJ_ZSET) return REDISMODULE_ERR;\n\n    RM_ZsetRangeStop(key);\n    key->ztype = REDISMODULE_ZSET_RANGE_SCORE;\n    key->zer = 0;\n\n    /* Setup the range structure used by the sorted set core implementation\n     * in order to seek at the specified element. */\n    zrangespec *zrs = &key->zrs;\n    zrs->min = min;\n    zrs->max = max;\n    zrs->minex = minex;\n    zrs->maxex = maxex;\n\n    if (key->value->encoding == OBJ_ENCODING_ZIPLIST) {\n        key->zcurrent = first ? zzlFirstInRange(key->value->ptr,zrs) :\n                                zzlLastInRange(key->value->ptr,zrs);\n    } else if (key->value->encoding == OBJ_ENCODING_SKIPLIST) {\n        zset *zs = key->value->ptr;\n        zskiplist *zsl = zs->zsl;\n        key->zcurrent = first ? zslFirstInRange(zsl,zrs) :\n                                zslLastInRange(zsl,zrs);\n    } else {\n        serverPanic(\"Unsupported zset encoding\");\n    }\n    if (key->zcurrent == NULL) key->zer = 1;\n    return REDISMODULE_OK;\n}\n\n/* Setup a sorted set iterator seeking the first element in the specified\n * range. Returns REDISMODULE_OK if the iterator was correctly initialized\n * otherwise REDISMODULE_ERR is returned in the following conditions:\n *\n * 1. The value stored at key is not a sorted set or the key is empty.\n *\n * The range is specified according to the two double values 'min' and 'max'.\n * Both can be infinite using the following two macros:\n *\n * REDISMODULE_POSITIVE_INFINITE for positive infinite value\n * REDISMODULE_NEGATIVE_INFINITE for negative infinite value\n *\n * 'minex' and 'maxex' parameters, if true, respectively setup a range\n * where the min and max value are exclusive (not included) instead of\n * inclusive. */\nint RM_ZsetFirstInScoreRange(RedisModuleKey *key, double min, double max, int minex, int maxex) {\n    return zsetInitScoreRange(key,min,max,minex,maxex,1);\n}\n\n/* Exactly like RedisModule_ZsetFirstInScoreRange() but the last element of\n * the range is selected for the start of the iteration instead. */\nint RM_ZsetLastInScoreRange(RedisModuleKey *key, double min, double max, int minex, int maxex) {\n    return zsetInitScoreRange(key,min,max,minex,maxex,0);\n}\n\n/* Helper function for RM_ZsetFirstInLexRange() and RM_ZsetLastInLexRange().\n * Setup the sorted set iteration according to the specified lexicographical\n * range (see the functions calling it for more info). If 'first' is true the\n * first element in the range is used as a starting point for the iterator\n * otherwise the last. Return REDISMODULE_OK on success otherwise\n * REDISMODULE_ERR.\n *\n * Note that this function takes 'min' and 'max' in the same form of the\n * Redis ZRANGEBYLEX command. */\nint zsetInitLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max, int first) {\n    if (!key->value || key->value->type != OBJ_ZSET) return REDISMODULE_ERR;\n\n    RM_ZsetRangeStop(key);\n    key->zer = 0;\n\n    /* Setup the range structure used by the sorted set core implementation\n     * in order to seek at the specified element. */\n    zlexrangespec *zlrs = &key->zlrs;\n    if (zslParseLexRange(min, max, zlrs) == C_ERR) return REDISMODULE_ERR;\n\n    /* Set the range type to lex only after successfully parsing the range,\n     * otherwise we don't want the zlexrangespec to be freed. */\n    key->ztype = REDISMODULE_ZSET_RANGE_LEX;\n\n    if (key->value->encoding == OBJ_ENCODING_ZIPLIST) {\n        key->zcurrent = first ? zzlFirstInLexRange(key->value->ptr,zlrs) :\n                                zzlLastInLexRange(key->value->ptr,zlrs);\n    } else if (key->value->encoding == OBJ_ENCODING_SKIPLIST) {\n        zset *zs = key->value->ptr;\n        zskiplist *zsl = zs->zsl;\n        key->zcurrent = first ? zslFirstInLexRange(zsl,zlrs) :\n                                zslLastInLexRange(zsl,zlrs);\n    } else {\n        serverPanic(\"Unsupported zset encoding\");\n    }\n    if (key->zcurrent == NULL) key->zer = 1;\n\n    return REDISMODULE_OK;\n}\n\n/* Setup a sorted set iterator seeking the first element in the specified\n * lexicographical range. Returns REDISMODULE_OK if the iterator was correctly\n * initialized otherwise REDISMODULE_ERR is returned in the\n * following conditions:\n *\n * 1. The value stored at key is not a sorted set or the key is empty.\n * 2. The lexicographical range 'min' and 'max' format is invalid.\n *\n * 'min' and 'max' should be provided as two RedisModuleString objects\n * in the same format as the parameters passed to the ZRANGEBYLEX command.\n * The function does not take ownership of the objects, so they can be released\n * ASAP after the iterator is setup. */\nint RM_ZsetFirstInLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max) {\n    return zsetInitLexRange(key,min,max,1);\n}\n\n/* Exactly like RedisModule_ZsetFirstInLexRange() but the last element of\n * the range is selected for the start of the iteration instead. */\nint RM_ZsetLastInLexRange(RedisModuleKey *key, RedisModuleString *min, RedisModuleString *max) {\n    return zsetInitLexRange(key,min,max,0);\n}\n\n/* Return the current sorted set element of an active sorted set iterator\n * or NULL if the range specified in the iterator does not include any\n * element. */\nRedisModuleString *RM_ZsetRangeCurrentElement(RedisModuleKey *key, double *score) {\n    RedisModuleString *str;\n\n    if (key->zcurrent == NULL) return NULL;\n    if (key->value->encoding == OBJ_ENCODING_ZIPLIST) {\n        unsigned char *eptr, *sptr;\n        eptr = key->zcurrent;\n        sds ele = ziplistGetObject(eptr);\n        if (score) {\n            sptr = ziplistNext(key->value->ptr,eptr);\n            *score = zzlGetScore(sptr);\n        }\n        str = createObject(OBJ_STRING,ele);\n    } else if (key->value->encoding == OBJ_ENCODING_SKIPLIST) {\n        zskiplistNode *ln = key->zcurrent;\n        if (score) *score = ln->score;\n        str = createStringObject(ln->ele,sdslen(ln->ele));\n    } else {\n        serverPanic(\"Unsupported zset encoding\");\n    }\n    autoMemoryAdd(key->ctx,REDISMODULE_AM_STRING,str);\n    return str;\n}\n\n/* Go to the next element of the sorted set iterator. Returns 1 if there was\n * a next element, 0 if we are already at the latest element or the range\n * does not include any item at all. */\nint RM_ZsetRangeNext(RedisModuleKey *key) {\n    if (!key->ztype || !key->zcurrent) return 0; /* No active iterator. */\n\n    if (key->value->encoding == OBJ_ENCODING_ZIPLIST) {\n        unsigned char *zl = key->value->ptr;\n        unsigned char *eptr = key->zcurrent;\n        unsigned char *next;\n        next = ziplistNext(zl,eptr); /* Skip element. */\n        if (next) next = ziplistNext(zl,next); /* Skip score. */\n        if (next == NULL) {\n            key->zer = 1;\n            return 0;\n        } else {\n            /* Are we still within the range? */\n            if (key->ztype == REDISMODULE_ZSET_RANGE_SCORE) {\n                /* Fetch the next element score for the\n                 * range check. */\n                unsigned char *saved_next = next;\n                next = ziplistNext(zl,next); /* Skip next element. */\n                double score = zzlGetScore(next); /* Obtain the next score. */\n                if (!zslValueLteMax(score,&key->zrs)) {\n                    key->zer = 1;\n                    return 0;\n                }\n                next = saved_next;\n            } else if (key->ztype == REDISMODULE_ZSET_RANGE_LEX) {\n                if (!zzlLexValueLteMax(next,&key->zlrs)) {\n                    key->zer = 1;\n                    return 0;\n                }\n            }\n            key->zcurrent = next;\n            return 1;\n        }\n    } else if (key->value->encoding == OBJ_ENCODING_SKIPLIST) {\n        zskiplistNode *ln = key->zcurrent, *next = ln->level[0].forward;\n        if (next == NULL) {\n            key->zer = 1;\n            return 0;\n        } else {\n            /* Are we still within the range? */\n            if (key->ztype == REDISMODULE_ZSET_RANGE_SCORE &&\n                !zslValueLteMax(next->score,&key->zrs))\n            {\n                key->zer = 1;\n                return 0;\n            } else if (key->ztype == REDISMODULE_ZSET_RANGE_LEX) {\n                if (!zslLexValueLteMax(next->ele,&key->zlrs)) {\n                    key->zer = 1;\n                    return 0;\n                }\n            }\n            key->zcurrent = next;\n            return 1;\n        }\n    } else {\n        serverPanic(\"Unsupported zset encoding\");\n    }\n}\n\n/* Go to the previous element of the sorted set iterator. Returns 1 if there was\n * a previous element, 0 if we are already at the first element or the range\n * does not include any item at all. */\nint RM_ZsetRangePrev(RedisModuleKey *key) {\n    if (!key->ztype || !key->zcurrent) return 0; /* No active iterator. */\n\n    if (key->value->encoding == OBJ_ENCODING_ZIPLIST) {\n        unsigned char *zl = key->value->ptr;\n        unsigned char *eptr = key->zcurrent;\n        unsigned char *prev;\n        prev = ziplistPrev(zl,eptr); /* Go back to previous score. */\n        if (prev) prev = ziplistPrev(zl,prev); /* Back to previous ele. */\n        if (prev == NULL) {\n            key->zer = 1;\n            return 0;\n        } else {\n            /* Are we still within the range? */\n            if (key->ztype == REDISMODULE_ZSET_RANGE_SCORE) {\n                /* Fetch the previous element score for the\n                 * range check. */\n                unsigned char *saved_prev = prev;\n                prev = ziplistNext(zl,prev); /* Skip element to get the score.*/\n                double score = zzlGetScore(prev); /* Obtain the prev score. */\n                if (!zslValueGteMin(score,&key->zrs)) {\n                    key->zer = 1;\n                    return 0;\n                }\n                prev = saved_prev;\n            } else if (key->ztype == REDISMODULE_ZSET_RANGE_LEX) {\n                if (!zzlLexValueGteMin(prev,&key->zlrs)) {\n                    key->zer = 1;\n                    return 0;\n                }\n            }\n            key->zcurrent = prev;\n            return 1;\n        }\n    } else if (key->value->encoding == OBJ_ENCODING_SKIPLIST) {\n        zskiplistNode *ln = key->zcurrent, *prev = ln->backward;\n        if (prev == NULL) {\n            key->zer = 1;\n            return 0;\n        } else {\n            /* Are we still within the range? */\n            if (key->ztype == REDISMODULE_ZSET_RANGE_SCORE &&\n                !zslValueGteMin(prev->score,&key->zrs))\n            {\n                key->zer = 1;\n                return 0;\n            } else if (key->ztype == REDISMODULE_ZSET_RANGE_LEX) {\n                if (!zslLexValueGteMin(prev->ele,&key->zlrs)) {\n                    key->zer = 1;\n                    return 0;\n                }\n            }\n            key->zcurrent = prev;\n            return 1;\n        }\n    } else {\n        serverPanic(\"Unsupported zset encoding\");\n    }\n}\n\n/* --------------------------------------------------------------------------\n * Key API for Hash type\n * -------------------------------------------------------------------------- */\n\n/* Set the field of the specified hash field to the specified value.\n * If the key is an empty key open for writing, it is created with an empty\n * hash value, in order to set the specified field.\n *\n * The function is variadic and the user must specify pairs of field\n * names and values, both as RedisModuleString pointers (unless the\n * CFIELD option is set, see later). At the end of the field/value-ptr pairs, \n * NULL must be specified as last argument to signal the end of the arguments \n * in the variadic function.\n *\n * Example to set the hash argv[1] to the value argv[2]:\n *\n *      RedisModule_HashSet(key,REDISMODULE_HASH_NONE,argv[1],argv[2],NULL);\n *\n * The function can also be used in order to delete fields (if they exist)\n * by setting them to the specified value of REDISMODULE_HASH_DELETE:\n *\n *      RedisModule_HashSet(key,REDISMODULE_HASH_NONE,argv[1],\n *                          REDISMODULE_HASH_DELETE,NULL);\n *\n * The behavior of the command changes with the specified flags, that can be\n * set to REDISMODULE_HASH_NONE if no special behavior is needed.\n *\n *     REDISMODULE_HASH_NX: The operation is performed only if the field was not\n *                          already existing in the hash.\n *     REDISMODULE_HASH_XX: The operation is performed only if the field was\n *                          already existing, so that a new value could be\n *                          associated to an existing filed, but no new fields\n *                          are created.\n *     REDISMODULE_HASH_CFIELDS: The field names passed are null terminated C\n *                               strings instead of RedisModuleString objects.\n *\n * Unless NX is specified, the command overwrites the old field value with\n * the new one.\n *\n * When using REDISMODULE_HASH_CFIELDS, field names are reported using\n * normal C strings, so for example to delete the field \"foo\" the following\n * code can be used:\n *\n *      RedisModule_HashSet(key,REDISMODULE_HASH_CFIELDS,\"foo\",\n *                          REDISMODULE_HASH_DELETE,NULL);\n *\n * Return value:\n *\n * The number of fields updated (that may be less than the number of fields\n * specified because of the XX or NX options).\n *\n * In the following case the return value is always zero:\n *\n * * The key was not open for writing.\n * * The key was associated with a non Hash value.\n */\nint RM_HashSet(RedisModuleKey *key, int flags, ...) {\n    va_list ap;\n    if (!(key->mode & REDISMODULE_WRITE)) return 0;\n    if (key->value && key->value->type != OBJ_HASH) return 0;\n    if (key->value == NULL) moduleCreateEmptyKey(key,REDISMODULE_KEYTYPE_HASH);\n\n    int updated = 0;\n    va_start(ap, flags);\n    while(1) {\n        RedisModuleString *field, *value;\n        /* Get the field and value objects. */\n        if (flags & REDISMODULE_HASH_CFIELDS) {\n            char *cfield = va_arg(ap,char*);\n            if (cfield == NULL) break;\n            field = createRawStringObject(cfield,strlen(cfield));\n        } else {\n            field = va_arg(ap,RedisModuleString*);\n            if (field == NULL) break;\n        }\n        value = va_arg(ap,RedisModuleString*);\n\n        /* Handle XX and NX */\n        if (flags & (REDISMODULE_HASH_XX|REDISMODULE_HASH_NX)) {\n            int exists = hashTypeExists(key->value, field->ptr);\n            if (((flags & REDISMODULE_HASH_XX) && !exists) ||\n                ((flags & REDISMODULE_HASH_NX) && exists))\n            {\n                if (flags & REDISMODULE_HASH_CFIELDS) decrRefCount(field);\n                continue;\n            }\n        }\n\n        /* Handle deletion if value is REDISMODULE_HASH_DELETE. */\n        if (value == REDISMODULE_HASH_DELETE) {\n            updated += hashTypeDelete(key->value, field->ptr);\n            if (flags & REDISMODULE_HASH_CFIELDS) decrRefCount(field);\n            continue;\n        }\n\n        int low_flags = HASH_SET_COPY;\n        /* If CFIELDS is active, we can pass the ownership of the\n         * SDS object to the low level function that sets the field\n         * to avoid a useless copy. */\n        if (flags & REDISMODULE_HASH_CFIELDS)\n            low_flags |= HASH_SET_TAKE_FIELD;\n\n        robj *argv[2] = {field,value};\n        hashTypeTryConversion(key->value,argv,0,1);\n        updated += hashTypeSet(key->value, field->ptr, value->ptr, low_flags);\n\n        /* If CFIELDS is active, SDS string ownership is now of hashTypeSet(),\n         * however we still have to release the 'field' object shell. */\n        if (flags & REDISMODULE_HASH_CFIELDS) {\n           field->ptr = NULL; /* Prevent the SDS string from being freed. */\n           decrRefCount(field);\n        }\n    }\n    va_end(ap);\n    moduleDelKeyIfEmpty(key);\n    return updated;\n}\n\n/* Get fields from an hash value. This function is called using a variable\n * number of arguments, alternating a field name (as a StringRedisModule\n * pointer) with a pointer to a StringRedisModule pointer, that is set to the\n * value of the field if the field exist, or NULL if the field did not exist.\n * At the end of the field/value-ptr pairs, NULL must be specified as last\n * argument to signal the end of the arguments in the variadic function.\n *\n * This is an example usage:\n *\n *      RedisModuleString *first, *second;\n *      RedisModule_HashGet(mykey,REDISMODULE_HASH_NONE,argv[1],&first,\n *                      argv[2],&second,NULL);\n *\n * As with RedisModule_HashSet() the behavior of the command can be specified\n * passing flags different than REDISMODULE_HASH_NONE:\n *\n * REDISMODULE_HASH_CFIELD: field names as null terminated C strings.\n *\n * REDISMODULE_HASH_EXISTS: instead of setting the value of the field\n * expecting a RedisModuleString pointer to pointer, the function just\n * reports if the field esists or not and expects an integer pointer\n * as the second element of each pair.\n *\n * Example of REDISMODULE_HASH_CFIELD:\n *\n *      RedisModuleString *username, *hashedpass;\n *      RedisModule_HashGet(mykey,\"username\",&username,\"hp\",&hashedpass, NULL);\n *\n * Example of REDISMODULE_HASH_EXISTS:\n *\n *      int exists;\n *      RedisModule_HashGet(mykey,argv[1],&exists,NULL);\n *\n * The function returns REDISMODULE_OK on success and REDISMODULE_ERR if\n * the key is not an hash value.\n *\n * Memory management:\n *\n * The returned RedisModuleString objects should be released with\n * RedisModule_FreeString(), or by enabling automatic memory management.\n */\nint RM_HashGet(RedisModuleKey *key, int flags, ...) {\n    va_list ap;\n    if (key->value && key->value->type != OBJ_HASH) return REDISMODULE_ERR;\n\n    va_start(ap, flags);\n    while(1) {\n        RedisModuleString *field, **valueptr;\n        int *existsptr;\n        /* Get the field object and the value pointer to pointer. */\n        if (flags & REDISMODULE_HASH_CFIELDS) {\n            char *cfield = va_arg(ap,char*);\n            if (cfield == NULL) break;\n            field = createRawStringObject(cfield,strlen(cfield));\n        } else {\n            field = va_arg(ap,RedisModuleString*);\n            if (field == NULL) break;\n        }\n\n        /* Query the hash for existence or value object. */\n        if (flags & REDISMODULE_HASH_EXISTS) {\n            existsptr = va_arg(ap,int*);\n            if (key->value)\n                *existsptr = hashTypeExists(key->value,field->ptr);\n            else\n                *existsptr = 0;\n        } else {\n            valueptr = va_arg(ap,RedisModuleString**);\n            if (key->value) {\n                *valueptr = hashTypeGetValueObject(key->value,field->ptr);\n                if (*valueptr) {\n                    robj *decoded = getDecodedObject(*valueptr);\n                    decrRefCount(*valueptr);\n                    *valueptr = decoded;\n                }\n                if (*valueptr)\n                    autoMemoryAdd(key->ctx,REDISMODULE_AM_STRING,*valueptr);\n            } else {\n                *valueptr = NULL;\n            }\n        }\n\n        /* Cleanup */\n        if (flags & REDISMODULE_HASH_CFIELDS) decrRefCount(field);\n    }\n    va_end(ap);\n    return REDISMODULE_OK;\n}\n\n/* --------------------------------------------------------------------------\n * Redis <-> Modules generic Call() API\n * -------------------------------------------------------------------------- */\n\n/* Create a new RedisModuleCallReply object. The processing of the reply\n * is lazy, the object is just populated with the raw protocol and later\n * is processed as needed. Initially we just make sure to set the right\n * reply type, which is extremely cheap to do. */\nRedisModuleCallReply *moduleCreateCallReplyFromProto(RedisModuleCtx *ctx, sds proto) {\n    RedisModuleCallReply *reply = zmalloc(sizeof(*reply));\n    reply->ctx = ctx;\n    reply->proto = proto;\n    reply->protolen = sdslen(proto);\n    reply->flags = REDISMODULE_REPLYFLAG_TOPARSE; /* Lazy parsing. */\n    switch(proto[0]) {\n    case '$':\n    case '+': reply->type = REDISMODULE_REPLY_STRING; break;\n    case '-': reply->type = REDISMODULE_REPLY_ERROR; break;\n    case ':': reply->type = REDISMODULE_REPLY_INTEGER; break;\n    case '*': reply->type = REDISMODULE_REPLY_ARRAY; break;\n    default: reply->type = REDISMODULE_REPLY_UNKNOWN; break;\n    }\n    if ((proto[0] == '*' || proto[0] == '$') && proto[1] == '-')\n        reply->type = REDISMODULE_REPLY_NULL;\n    return reply;\n}\n\nvoid moduleParseCallReply_Int(RedisModuleCallReply *reply);\nvoid moduleParseCallReply_BulkString(RedisModuleCallReply *reply);\nvoid moduleParseCallReply_SimpleString(RedisModuleCallReply *reply);\nvoid moduleParseCallReply_Array(RedisModuleCallReply *reply);\n\n/* Do nothing if REDISMODULE_REPLYFLAG_TOPARSE is false, otherwise\n * use the protcol of the reply in reply->proto in order to fill the\n * reply with parsed data according to the reply type. */\nvoid moduleParseCallReply(RedisModuleCallReply *reply) {\n    if (!(reply->flags & REDISMODULE_REPLYFLAG_TOPARSE)) return;\n    reply->flags &= ~REDISMODULE_REPLYFLAG_TOPARSE;\n\n    switch(reply->proto[0]) {\n    case ':': moduleParseCallReply_Int(reply); break;\n    case '$': moduleParseCallReply_BulkString(reply); break;\n    case '-': /* handled by next item. */\n    case '+': moduleParseCallReply_SimpleString(reply); break;\n    case '*': moduleParseCallReply_Array(reply); break;\n    }\n}\n\nvoid moduleParseCallReply_Int(RedisModuleCallReply *reply) {\n    char *proto = reply->proto;\n    char *p = strchr(proto+1,'\\r');\n\n    string2ll(proto+1,p-proto-1,&reply->val.ll);\n    reply->protolen = p-proto+2;\n    reply->type = REDISMODULE_REPLY_INTEGER;\n}\n\nvoid moduleParseCallReply_BulkString(RedisModuleCallReply *reply) {\n    char *proto = reply->proto;\n    char *p = strchr(proto+1,'\\r');\n    long long bulklen;\n\n    string2ll(proto+1,p-proto-1,&bulklen);\n    if (bulklen == -1) {\n        reply->protolen = p-proto+2;\n        reply->type = REDISMODULE_REPLY_NULL;\n    } else {\n        reply->val.str = p+2;\n        reply->len = bulklen;\n        reply->protolen = p-proto+2+bulklen+2;\n        reply->type = REDISMODULE_REPLY_STRING;\n    }\n}\n\nvoid moduleParseCallReply_SimpleString(RedisModuleCallReply *reply) {\n    char *proto = reply->proto;\n    char *p = strchr(proto+1,'\\r');\n\n    reply->val.str = proto+1;\n    reply->len = p-proto-1;\n    reply->protolen = p-proto+2;\n    reply->type = proto[0] == '+' ? REDISMODULE_REPLY_STRING :\n                                    REDISMODULE_REPLY_ERROR;\n}\n\nvoid moduleParseCallReply_Array(RedisModuleCallReply *reply) {\n    char *proto = reply->proto;\n    char *p = strchr(proto+1,'\\r');\n    long long arraylen, j;\n\n    string2ll(proto+1,p-proto-1,&arraylen);\n    p += 2;\n\n    if (arraylen == -1) {\n        reply->protolen = p-proto;\n        reply->type = REDISMODULE_REPLY_NULL;\n        return;\n    }\n\n    reply->val.array = zmalloc(sizeof(RedisModuleCallReply)*arraylen);\n    reply->len = arraylen;\n    for (j = 0; j < arraylen; j++) {\n        RedisModuleCallReply *ele = reply->val.array+j;\n        ele->flags = REDISMODULE_REPLYFLAG_NESTED |\n                     REDISMODULE_REPLYFLAG_TOPARSE;\n        ele->proto = p;\n        ele->ctx = reply->ctx;\n        moduleParseCallReply(ele);\n        p += ele->protolen;\n    }\n    reply->protolen = p-proto;\n    reply->type = REDISMODULE_REPLY_ARRAY;\n}\n\n/* Free a Call reply and all the nested replies it contains if it's an\n * array. */\nvoid RM_FreeCallReply_Rec(RedisModuleCallReply *reply, int freenested){\n    /* Don't free nested replies by default: the user must always free the\n     * toplevel reply. However be gentle and don't crash if the module\n     * misuses the API. */\n    if (!freenested && reply->flags & REDISMODULE_REPLYFLAG_NESTED) return;\n\n    if (!(reply->flags & REDISMODULE_REPLYFLAG_TOPARSE)) {\n        if (reply->type == REDISMODULE_REPLY_ARRAY) {\n            size_t j;\n            for (j = 0; j < reply->len; j++)\n                RM_FreeCallReply_Rec(reply->val.array+j,1);\n            zfree(reply->val.array);\n        }\n    }\n\n    /* For nested replies, we don't free reply->proto (which if not NULL\n     * references the parent reply->proto buffer), nor the structure\n     * itself which is allocated as an array of structures, and is freed\n     * when the array value is released. */\n    if (!(reply->flags & REDISMODULE_REPLYFLAG_NESTED)) {\n        if (reply->proto) sdsfree(reply->proto);\n        zfree(reply);\n    }\n}\n\n/* Wrapper for the recursive free reply function. This is needed in order\n * to have the first level function to return on nested replies, but only\n * if called by the module API. */\nvoid RM_FreeCallReply(RedisModuleCallReply *reply) {\n\n    RedisModuleCtx *ctx = reply->ctx;\n    RM_FreeCallReply_Rec(reply,0);\n    autoMemoryFreed(ctx,REDISMODULE_AM_REPLY,reply);\n}\n\n/* Return the reply type. */\nint RM_CallReplyType(RedisModuleCallReply *reply) {\n    if (!reply) return REDISMODULE_REPLY_UNKNOWN;\n    return reply->type;\n}\n\n/* Return the reply type length, where applicable. */\nsize_t RM_CallReplyLength(RedisModuleCallReply *reply) {\n    moduleParseCallReply(reply);\n    switch(reply->type) {\n    case REDISMODULE_REPLY_STRING:\n    case REDISMODULE_REPLY_ERROR:\n    case REDISMODULE_REPLY_ARRAY:\n        return reply->len;\n    default:\n        return 0;\n    }\n}\n\n/* Return the 'idx'-th nested call reply element of an array reply, or NULL\n * if the reply type is wrong or the index is out of range. */\nRedisModuleCallReply *RM_CallReplyArrayElement(RedisModuleCallReply *reply, size_t idx) {\n    moduleParseCallReply(reply);\n    if (reply->type != REDISMODULE_REPLY_ARRAY) return NULL;\n    if (idx >= reply->len) return NULL;\n    return reply->val.array+idx;\n}\n\n/* Return the long long of an integer reply. */\nlong long RM_CallReplyInteger(RedisModuleCallReply *reply) {\n    moduleParseCallReply(reply);\n    if (reply->type != REDISMODULE_REPLY_INTEGER) return LLONG_MIN;\n    return reply->val.ll;\n}\n\n/* Return the pointer and length of a string or error reply. */\nconst char *RM_CallReplyStringPtr(RedisModuleCallReply *reply, size_t *len) {\n    moduleParseCallReply(reply);\n    if (reply->type != REDISMODULE_REPLY_STRING &&\n        reply->type != REDISMODULE_REPLY_ERROR) return NULL;\n    if (len) *len = reply->len;\n    return reply->val.str;\n}\n\n/* Return a new string object from a call reply of type string, error or\n * integer. Otherwise (wrong reply type) return NULL. */\nRedisModuleString *RM_CreateStringFromCallReply(RedisModuleCallReply *reply) {\n    moduleParseCallReply(reply);\n    switch(reply->type) {\n    case REDISMODULE_REPLY_STRING:\n    case REDISMODULE_REPLY_ERROR:\n        return RM_CreateString(reply->ctx,reply->val.str,reply->len);\n    case REDISMODULE_REPLY_INTEGER: {\n        char buf[64];\n        int len = ll2string(buf,sizeof(buf),reply->val.ll);\n        return RM_CreateString(reply->ctx,buf,len);\n        }\n    default: return NULL;\n    }\n}\n\n/* Returns an array of robj pointers, and populates *argc with the number\n * of items, by parsing the format specifier \"fmt\" as described for\n * the RM_Call(), RM_Replicate() and other module APIs.\n *\n * The integer pointed by 'flags' is populated with flags according\n * to special modifiers in \"fmt\". For now only one exists:\n *\n *     \"!\" -> REDISMODULE_ARGV_REPLICATE\n *\n * On error (format specifier error) NULL is returned and nothing is\n * allocated. On success the argument vector is returned. */\n\n#define REDISMODULE_ARGV_REPLICATE (1<<0)\n\nrobj **moduleCreateArgvFromUserFormat(const char *cmdname, const char *fmt, int *argcp, int *flags, va_list ap) {\n    int argc = 0, argv_size, j;\n    robj **argv = NULL;\n\n    /* As a first guess to avoid useless reallocations, size argv to\n     * hold one argument for each char specifier in 'fmt'. */\n    argv_size = strlen(fmt)+1; /* +1 because of the command name. */\n    argv = zrealloc(argv,sizeof(robj*)*argv_size);\n\n    /* Build the arguments vector based on the format specifier. */\n    argv[0] = createStringObject(cmdname,strlen(cmdname));\n    argc++;\n\n    /* Create the client and dispatch the command. */\n    const char *p = fmt;\n    while(*p) {\n        if (*p == 'c') {\n            char *cstr = va_arg(ap,char*);\n            argv[argc++] = createStringObject(cstr,strlen(cstr));\n        } else if (*p == 's') {\n            robj *obj = va_arg(ap,void*);\n            argv[argc++] = obj;\n            incrRefCount(obj);\n        } else if (*p == 'b') {\n            char *buf = va_arg(ap,char*);\n            size_t len = va_arg(ap,size_t);\n            argv[argc++] = createStringObject(buf,len);\n        } else if (*p == 'l') {\n            long ll = va_arg(ap,long long);\n            argv[argc++] = createObject(OBJ_STRING,sdsfromlonglong(ll));\n        } else if (*p == 'v') {\n             /* A vector of strings */\n             robj **v = va_arg(ap, void*);\n             size_t vlen = va_arg(ap, size_t);\n\n             /* We need to grow argv to hold the vector's elements.\n              * We resize by vector_len-1 elements, because we held\n              * one element in argv for the vector already */\n             argv_size += vlen-1;\n             argv = zrealloc(argv,sizeof(robj*)*argv_size);\n\n             size_t i = 0;\n             for (i = 0; i < vlen; i++) {\n                 incrRefCount(v[i]);\n                 argv[argc++] = v[i];\n             }\n        } else if (*p == '!') {\n            if (flags) (*flags) |= REDISMODULE_ARGV_REPLICATE;\n        } else {\n            goto fmterr;\n        }\n        p++;\n    }\n    *argcp = argc;\n    return argv;\n\nfmterr:\n    for (j = 0; j < argc; j++)\n        decrRefCount(argv[j]);\n    zfree(argv);\n    return NULL;\n}\n\n/* Exported API to call any Redis command from modules.\n * On success a RedisModuleCallReply object is returned, otherwise\n * NULL is returned and errno is set to the following values:\n *\n * EINVAL: command non existing, wrong arity, wrong format specifier.\n * EPERM:  operation in Cluster instance with key in non local slot. */\nRedisModuleCallReply *RM_Call(RedisModuleCtx *ctx, const char *cmdname, const char *fmt, ...) {\n    struct redisCommand *cmd;\n    client *c = NULL;\n    robj **argv = NULL;\n    int argc = 0, flags = 0;\n    va_list ap;\n    RedisModuleCallReply *reply = NULL;\n    int replicate = 0; /* Replicate this command? */\n\n    cmd = lookupCommandByCString((char*)cmdname);\n    if (!cmd) {\n        errno = EINVAL;\n        return NULL;\n    }\n\n    /* Create the client and dispatch the command. */\n    va_start(ap, fmt);\n    c = createClient(-1);\n    argv = moduleCreateArgvFromUserFormat(cmdname,fmt,&argc,&flags,ap);\n    replicate = flags & REDISMODULE_ARGV_REPLICATE;\n    va_end(ap);\n\n    /* Setup our fake client for command execution. */\n    c->flags |= CLIENT_MODULE;\n    c->db = ctx->client->db;\n    c->argv = argv;\n    c->argc = argc;\n    c->cmd = c->lastcmd = cmd;\n    /* We handle the above format error only when the client is setup so that\n     * we can free it normally. */\n    if (argv == NULL) goto cleanup;\n\n    /* Basic arity checks. */\n    if ((cmd->arity > 0 && cmd->arity != argc) || (argc < -cmd->arity)) {\n        errno = EINVAL;\n        goto cleanup;\n    }\n\n    /* If this is a Redis Cluster node, we need to make sure the module is not\n     * trying to access non-local keys, with the exception of commands\n     * received from our master. */\n    if (server.cluster_enabled && !(ctx->client->flags & CLIENT_MASTER)) {\n        /* Duplicate relevant flags in the module client. */\n        c->flags &= ~(CLIENT_READONLY|CLIENT_ASKING);\n        c->flags |= ctx->client->flags & (CLIENT_READONLY|CLIENT_ASKING);\n        if (getNodeByQuery(c,c->cmd,c->argv,c->argc,NULL,NULL) !=\n                           server.cluster->myself)\n        {\n            errno = EPERM;\n            goto cleanup;\n        }\n    }\n\n    /* If we are using single commands replication, we need to wrap what\n     * we propagate into a MULTI/EXEC block, so that it will be atomic like\n     * a Lua script in the context of AOF and slaves. */\n    if (replicate) moduleReplicateMultiIfNeeded(ctx);\n\n    /* Run the command */\n    int call_flags = CMD_CALL_SLOWLOG | CMD_CALL_STATS;\n    if (replicate) {\n        call_flags |= CMD_CALL_PROPAGATE_AOF;\n        call_flags |= CMD_CALL_PROPAGATE_REPL;\n    }\n    call(c,call_flags);\n\n    /* Convert the result of the Redis command into a suitable Lua type.\n     * The first thing we need is to create a single string from the client\n     * output buffers. */\n    sds proto = sdsnewlen(c->buf,c->bufpos);\n    c->bufpos = 0;\n    while(listLength(c->reply)) {\n        clientReplyBlock *o = listNodeValue(listFirst(c->reply));\n\n        proto = sdscatlen(proto,o->buf,o->used);\n        listDelNode(c->reply,listFirst(c->reply));\n    }\n    reply = moduleCreateCallReplyFromProto(ctx,proto);\n    autoMemoryAdd(ctx,REDISMODULE_AM_REPLY,reply);\n\ncleanup:\n    freeClient(c);\n    return reply;\n}\n\n/* Return a pointer, and a length, to the protocol returned by the command\n * that returned the reply object. */\nconst char *RM_CallReplyProto(RedisModuleCallReply *reply, size_t *len) {\n    if (reply->proto) *len = sdslen(reply->proto);\n    return reply->proto;\n}\n\n/* --------------------------------------------------------------------------\n * Modules data types\n *\n * When String DMA or using existing data structures is not enough, it is\n * possible to create new data types from scratch and export them to\n * Redis. The module must provide a set of callbacks for handling the\n * new values exported (for example in order to provide RDB saving/loading,\n * AOF rewrite, and so forth). In this section we define this API.\n * -------------------------------------------------------------------------- */\n\n/* Turn a 9 chars name in the specified charset and a 10 bit encver into\n * a single 64 bit unsigned integer that represents this exact module name\n * and version. This final number is called a \"type ID\" and is used when\n * writing module exported values to RDB files, in order to re-associate the\n * value to the right module to load them during RDB loading.\n *\n * If the string is not of the right length or the charset is wrong, or\n * if encver is outside the unsigned 10 bit integer range, 0 is returned,\n * otherwise the function returns the right type ID.\n *\n * The resulting 64 bit integer is composed as follows:\n *\n *     (high order bits) 6|6|6|6|6|6|6|6|6|10 (low order bits)\n *\n * The first 6 bits value is the first character, name[0], while the last\n * 6 bits value, immediately before the 10 bits integer, is name[8].\n * The last 10 bits are the encoding version.\n *\n * Note that a name and encver combo of \"AAAAAAAAA\" and 0, will produce\n * zero as return value, that is the same we use to signal errors, thus\n * this combination is invalid, and also useless since type names should\n * try to be vary to avoid collisions. */\n\nconst char *ModuleTypeNameCharSet =\n             \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n             \"abcdefghijklmnopqrstuvwxyz\"\n             \"0123456789-_\";\n\nuint64_t moduleTypeEncodeId(const char *name, int encver) {\n    /* We use 64 symbols so that we can map each character into 6 bits\n     * of the final output. */\n    const char *cset = ModuleTypeNameCharSet;\n    if (strlen(name) != 9) return 0;\n    if (encver < 0 || encver > 1023) return 0;\n\n    uint64_t id = 0;\n    for (int j = 0; j < 9; j++) {\n        char *p = strchr(cset,name[j]);\n        if (!p) return 0;\n        unsigned long pos = p-cset;\n        id = (id << 6) | pos;\n    }\n    id = (id << 10) | encver;\n    return id;\n}\n\n/* Search, in the list of exported data types of all the modules registered,\n * a type with the same name as the one given. Returns the moduleType\n * structure pointer if such a module is found, or NULL otherwise. */\nmoduleType *moduleTypeLookupModuleByName(const char *name) {\n    dictIterator *di = dictGetIterator(modules);\n    dictEntry *de;\n\n    while ((de = dictNext(di)) != NULL) {\n        struct RedisModule *module = dictGetVal(de);\n        listIter li;\n        listNode *ln;\n\n        listRewind(module->types,&li);\n        while((ln = listNext(&li))) {\n            moduleType *mt = ln->value;\n            if (memcmp(name,mt->name,sizeof(mt->name)) == 0) {\n                dictReleaseIterator(di);\n                return mt;\n            }\n        }\n    }\n    dictReleaseIterator(di);\n    return NULL;\n}\n\n/* Lookup a module by ID, with caching. This function is used during RDB\n * loading. Modules exporting data types should never be able to unload, so\n * our cache does not need to expire. */\n#define MODULE_LOOKUP_CACHE_SIZE 3\n\nmoduleType *moduleTypeLookupModuleByID(uint64_t id) {\n    static struct {\n        uint64_t id;\n        moduleType *mt;\n    } cache[MODULE_LOOKUP_CACHE_SIZE];\n\n    /* Search in cache to start. */\n    int j;\n    for (j = 0; j < MODULE_LOOKUP_CACHE_SIZE && cache[j].mt != NULL; j++)\n        if (cache[j].id == id) return cache[j].mt;\n\n    /* Slow module by module lookup. */\n    moduleType *mt = NULL;\n    dictIterator *di = dictGetIterator(modules);\n    dictEntry *de;\n\n    while ((de = dictNext(di)) != NULL && mt == NULL) {\n        struct RedisModule *module = dictGetVal(de);\n        listIter li;\n        listNode *ln;\n\n        listRewind(module->types,&li);\n        while((ln = listNext(&li))) {\n            moduleType *this_mt = ln->value;\n            /* Compare only the 54 bit module identifier and not the\n             * encoding version. */\n            if (this_mt->id >> 10 == id >> 10) {\n                mt = this_mt;\n                break;\n            }\n        }\n    }\n    dictReleaseIterator(di);\n\n    /* Add to cache if possible. */\n    if (mt && j < MODULE_LOOKUP_CACHE_SIZE) {\n        cache[j].id = id;\n        cache[j].mt = mt;\n    }\n    return mt;\n}\n\n/* Turn an (unresolved) module ID into a type name, to show the user an\n * error when RDB files contain module data we can't load.\n * The buffer pointed by 'name' must be 10 bytes at least. The function will\n * fill it with a null terminated module name. */\nvoid moduleTypeNameByID(char *name, uint64_t moduleid) {\n    const char *cset = ModuleTypeNameCharSet;\n\n    name[9] = '\\0';\n    char *p = name+8;\n    moduleid >>= 10;\n    for (int j = 0; j < 9; j++) {\n        *p-- = cset[moduleid & 63];\n        moduleid >>= 6;\n    }\n}\n\n/* Register a new data type exported by the module. The parameters are the\n * following. Please for in depth documentation check the modules API\n * documentation, especially the TYPES.md file.\n *\n * * **name**: A 9 characters data type name that MUST be unique in the Redis\n *   Modules ecosystem. Be creative... and there will be no collisions. Use\n *   the charset A-Z a-z 9-0, plus the two \"-_\" characters. A good\n *   idea is to use, for example `<typename>-<vendor>`. For example\n *   \"tree-AntZ\" may mean \"Tree data structure by @antirez\". To use both\n *   lower case and upper case letters helps in order to prevent collisions.\n * * **encver**: Encoding version, which is, the version of the serialization\n *   that a module used in order to persist data. As long as the \"name\"\n *   matches, the RDB loading will be dispatched to the type callbacks\n *   whatever 'encver' is used, however the module can understand if\n *   the encoding it must load are of an older version of the module.\n *   For example the module \"tree-AntZ\" initially used encver=0. Later\n *   after an upgrade, it started to serialize data in a different format\n *   and to register the type with encver=1. However this module may\n *   still load old data produced by an older version if the rdb_load\n *   callback is able to check the encver value and act accordingly.\n *   The encver must be a positive value between 0 and 1023.\n * * **typemethods_ptr** is a pointer to a RedisModuleTypeMethods structure\n *   that should be populated with the methods callbacks and structure\n *   version, like in the following example:\n *\n *      RedisModuleTypeMethods tm = {\n *          .version = REDISMODULE_TYPE_METHOD_VERSION,\n *          .rdb_load = myType_RDBLoadCallBack,\n *          .rdb_save = myType_RDBSaveCallBack,\n *          .aof_rewrite = myType_AOFRewriteCallBack,\n *          .free = myType_FreeCallBack,\n *\n *          // Optional fields\n *          .digest = myType_DigestCallBack,\n *          .mem_usage = myType_MemUsageCallBack,\n *      }\n *\n * * **rdb_load**: A callback function pointer that loads data from RDB files.\n * * **rdb_save**: A callback function pointer that saves data to RDB files.\n * * **aof_rewrite**: A callback function pointer that rewrites data as commands.\n * * **digest**: A callback function pointer that is used for `DEBUG DIGEST`.\n * * **free**: A callback function pointer that can free a type value.\n *\n * The **digest* and **mem_usage** methods should currently be omitted since\n * they are not yet implemented inside the Redis modules core.\n *\n * Note: the module name \"AAAAAAAAA\" is reserved and produces an error, it\n * happens to be pretty lame as well.\n *\n * If there is already a module registering a type with the same name,\n * and if the module name or encver is invalid, NULL is returned.\n * Otherwise the new type is registered into Redis, and a reference of\n * type RedisModuleType is returned: the caller of the function should store\n * this reference into a gobal variable to make future use of it in the\n * modules type API, since a single module may register multiple types.\n * Example code fragment:\n *\n *      static RedisModuleType *BalancedTreeType;\n *\n *      int RedisModule_OnLoad(RedisModuleCtx *ctx) {\n *          // some code here ...\n *          BalancedTreeType = RM_CreateDataType(...);\n *      }\n */\nmoduleType *RM_CreateDataType(RedisModuleCtx *ctx, const char *name, int encver, void *typemethods_ptr) {\n    uint64_t id = moduleTypeEncodeId(name,encver);\n    if (id == 0) return NULL;\n    if (moduleTypeLookupModuleByName(name) != NULL) return NULL;\n\n    long typemethods_version = ((long*)typemethods_ptr)[0];\n    if (typemethods_version == 0) return NULL;\n\n    struct typemethods {\n        uint64_t version;\n        moduleTypeLoadFunc rdb_load;\n        moduleTypeSaveFunc rdb_save;\n        moduleTypeRewriteFunc aof_rewrite;\n        moduleTypeMemUsageFunc mem_usage;\n        moduleTypeDigestFunc digest;\n        moduleTypeFreeFunc free;\n    } *tms = (struct typemethods*) typemethods_ptr;\n\n    moduleType *mt = zcalloc(sizeof(*mt));\n    mt->id = id;\n    mt->module = ctx->module;\n    mt->rdb_load = tms->rdb_load;\n    mt->rdb_save = tms->rdb_save;\n    mt->aof_rewrite = tms->aof_rewrite;\n    mt->mem_usage = tms->mem_usage;\n    mt->digest = tms->digest;\n    mt->free = tms->free;\n    memcpy(mt->name,name,sizeof(mt->name));\n    listAddNodeTail(ctx->module->types,mt);\n    return mt;\n}\n\n/* If the key is open for writing, set the specified module type object\n * as the value of the key, deleting the old value if any.\n * On success REDISMODULE_OK is returned. If the key is not open for\n * writing or there is an active iterator, REDISMODULE_ERR is returned. */\nint RM_ModuleTypeSetValue(RedisModuleKey *key, moduleType *mt, void *value) {\n    if (!(key->mode & REDISMODULE_WRITE) || key->iter) return REDISMODULE_ERR;\n    RM_DeleteKey(key);\n    robj *o = createModuleObject(mt,value);\n    setKey(key->db,key->key,o);\n    decrRefCount(o);\n    key->value = o;\n    return REDISMODULE_OK;\n}\n\n/* Assuming RedisModule_KeyType() returned REDISMODULE_KEYTYPE_MODULE on\n * the key, returns the module type pointer of the value stored at key.\n *\n * If the key is NULL, is not associated with a module type, or is empty,\n * then NULL is returned instead. */\nmoduleType *RM_ModuleTypeGetType(RedisModuleKey *key) {\n    if (key == NULL ||\n        key->value == NULL ||\n        RM_KeyType(key) != REDISMODULE_KEYTYPE_MODULE) return NULL;\n    moduleValue *mv = key->value->ptr;\n    return mv->type;\n}\n\n/* Assuming RedisModule_KeyType() returned REDISMODULE_KEYTYPE_MODULE on\n * the key, returns the module type low-level value stored at key, as\n * it was set by the user via RedisModule_ModuleTypeSet().\n *\n * If the key is NULL, is not associated with a module type, or is empty,\n * then NULL is returned instead. */\nvoid *RM_ModuleTypeGetValue(RedisModuleKey *key) {\n    if (key == NULL ||\n        key->value == NULL ||\n        RM_KeyType(key) != REDISMODULE_KEYTYPE_MODULE) return NULL;\n    moduleValue *mv = key->value->ptr;\n    return mv->value;\n}\n\n/* --------------------------------------------------------------------------\n * RDB loading and saving functions\n * -------------------------------------------------------------------------- */\n\n/* Called when there is a load error in the context of a module. This cannot\n * be recovered like for the built-in types. */\nvoid moduleRDBLoadError(RedisModuleIO *io) {\n    serverLog(LL_WARNING,\n        \"Error loading data from RDB (short read or EOF). \"\n        \"Read performed by module '%s' about type '%s' \"\n        \"after reading '%llu' bytes of a value.\",\n        io->type->module->name,\n        io->type->name,\n        (unsigned long long)io->bytes);\n    exit(1);\n}\n\n/* Save an unsigned 64 bit value into the RDB file. This function should only\n * be called in the context of the rdb_save method of modules implementing new\n * data types. */\nvoid RM_SaveUnsigned(RedisModuleIO *io, uint64_t value) {\n    if (io->error) return;\n    /* Save opcode. */\n    int retval = rdbSaveLen(io->rio, RDB_MODULE_OPCODE_UINT);\n    if (retval == -1) goto saveerr;\n    io->bytes += retval;\n    /* Save value. */\n    retval = rdbSaveLen(io->rio, value);\n    if (retval == -1) goto saveerr;\n    io->bytes += retval;\n    return;\n\nsaveerr:\n    io->error = 1;\n}\n\n/* Load an unsigned 64 bit value from the RDB file. This function should only\n * be called in the context of the rdb_load method of modules implementing\n * new data types. */\nuint64_t RM_LoadUnsigned(RedisModuleIO *io) {\n    if (io->ver == 2) {\n        uint64_t opcode = rdbLoadLen(io->rio,NULL);\n        if (opcode != RDB_MODULE_OPCODE_UINT) goto loaderr;\n    }\n    uint64_t value;\n    int retval = rdbLoadLenByRef(io->rio, NULL, &value);\n    if (retval == -1) goto loaderr;\n    return value;\n\nloaderr:\n    moduleRDBLoadError(io);\n    return 0; /* Never reached. */\n}\n\n/* Like RedisModule_SaveUnsigned() but for signed 64 bit values. */\nvoid RM_SaveSigned(RedisModuleIO *io, int64_t value) {\n    union {uint64_t u; int64_t i;} conv;\n    conv.i = value;\n    RM_SaveUnsigned(io,conv.u);\n}\n\n/* Like RedisModule_LoadUnsigned() but for signed 64 bit values. */\nint64_t RM_LoadSigned(RedisModuleIO *io) {\n    union {uint64_t u; int64_t i;} conv;\n    conv.u = RM_LoadUnsigned(io);\n    return conv.i;\n}\n\n/* In the context of the rdb_save method of a module type, saves a\n * string into the RDB file taking as input a RedisModuleString.\n *\n * The string can be later loaded with RedisModule_LoadString() or\n * other Load family functions expecting a serialized string inside\n * the RDB file. */\nvoid RM_SaveString(RedisModuleIO *io, RedisModuleString *s) {\n    if (io->error) return;\n    /* Save opcode. */\n    ssize_t retval = rdbSaveLen(io->rio, RDB_MODULE_OPCODE_STRING);\n    if (retval == -1) goto saveerr;\n    io->bytes += retval;\n    /* Save value. */\n    retval = rdbSaveStringObject(io->rio, s);\n    if (retval == -1) goto saveerr;\n    io->bytes += retval;\n    return;\n\nsaveerr:\n    io->error = 1;\n}\n\n/* Like RedisModule_SaveString() but takes a raw C pointer and length\n * as input. */\nvoid RM_SaveStringBuffer(RedisModuleIO *io, const char *str, size_t len) {\n    if (io->error) return;\n    /* Save opcode. */\n    ssize_t retval = rdbSaveLen(io->rio, RDB_MODULE_OPCODE_STRING);\n    if (retval == -1) goto saveerr;\n    io->bytes += retval;\n    /* Save value. */\n    retval = rdbSaveRawString(io->rio, (unsigned char*)str,len);\n    if (retval == -1) goto saveerr;\n    io->bytes += retval;\n    return;\n\nsaveerr:\n    io->error = 1;\n}\n\n/* Implements RM_LoadString() and RM_LoadStringBuffer() */\nvoid *moduleLoadString(RedisModuleIO *io, int plain, size_t *lenptr) {\n    if (io->ver == 2) {\n        uint64_t opcode = rdbLoadLen(io->rio,NULL);\n        if (opcode != RDB_MODULE_OPCODE_STRING) goto loaderr;\n    }\n    void *s = rdbGenericLoadStringObject(io->rio,\n              plain ? RDB_LOAD_PLAIN : RDB_LOAD_NONE, lenptr);\n    if (s == NULL) goto loaderr;\n    return s;\n\nloaderr:\n    moduleRDBLoadError(io);\n    return NULL; /* Never reached. */\n}\n\n/* In the context of the rdb_load method of a module data type, loads a string\n * from the RDB file, that was previously saved with RedisModule_SaveString()\n * functions family.\n *\n * The returned string is a newly allocated RedisModuleString object, and\n * the user should at some point free it with a call to RedisModule_FreeString().\n *\n * If the data structure does not store strings as RedisModuleString objects,\n * the similar function RedisModule_LoadStringBuffer() could be used instead. */\nRedisModuleString *RM_LoadString(RedisModuleIO *io) {\n    return moduleLoadString(io,0,NULL);\n}\n\n/* Like RedisModule_LoadString() but returns an heap allocated string that\n * was allocated with RedisModule_Alloc(), and can be resized or freed with\n * RedisModule_Realloc() or RedisModule_Free().\n *\n * The size of the string is stored at '*lenptr' if not NULL.\n * The returned string is not automatically NULL termianted, it is loaded\n * exactly as it was stored inisde the RDB file. */\nchar *RM_LoadStringBuffer(RedisModuleIO *io, size_t *lenptr) {\n    return moduleLoadString(io,1,lenptr);\n}\n\n/* In the context of the rdb_save method of a module data type, saves a double\n * value to the RDB file. The double can be a valid number, a NaN or infinity.\n * It is possible to load back the value with RedisModule_LoadDouble(). */\nvoid RM_SaveDouble(RedisModuleIO *io, double value) {\n    if (io->error) return;\n    /* Save opcode. */\n    int retval = rdbSaveLen(io->rio, RDB_MODULE_OPCODE_DOUBLE);\n    if (retval == -1) goto saveerr;\n    io->bytes += retval;\n    /* Save value. */\n    retval = rdbSaveBinaryDoubleValue(io->rio, value);\n    if (retval == -1) goto saveerr;\n    io->bytes += retval;\n    return;\n\nsaveerr:\n    io->error = 1;\n}\n\n/* In the context of the rdb_save method of a module data type, loads back the\n * double value saved by RedisModule_SaveDouble(). */\ndouble RM_LoadDouble(RedisModuleIO *io) {\n    if (io->ver == 2) {\n        uint64_t opcode = rdbLoadLen(io->rio,NULL);\n        if (opcode != RDB_MODULE_OPCODE_DOUBLE) goto loaderr;\n    }\n    double value;\n    int retval = rdbLoadBinaryDoubleValue(io->rio, &value);\n    if (retval == -1) goto loaderr;\n    return value;\n\nloaderr:\n    moduleRDBLoadError(io);\n    return 0; /* Never reached. */\n}\n\n/* In the context of the rdb_save method of a module data type, saves a float\n * value to the RDB file. The float can be a valid number, a NaN or infinity.\n * It is possible to load back the value with RedisModule_LoadFloat(). */\nvoid RM_SaveFloat(RedisModuleIO *io, float value) {\n    if (io->error) return;\n    /* Save opcode. */\n    int retval = rdbSaveLen(io->rio, RDB_MODULE_OPCODE_FLOAT);\n    if (retval == -1) goto saveerr;\n    io->bytes += retval;\n    /* Save value. */\n    retval = rdbSaveBinaryFloatValue(io->rio, value);\n    if (retval == -1) goto saveerr;\n    io->bytes += retval;\n    return;\n\nsaveerr:\n    io->error = 1;\n}\n\n/* In the context of the rdb_save method of a module data type, loads back the\n * float value saved by RedisModule_SaveFloat(). */\nfloat RM_LoadFloat(RedisModuleIO *io) {\n    if (io->ver == 2) {\n        uint64_t opcode = rdbLoadLen(io->rio,NULL);\n        if (opcode != RDB_MODULE_OPCODE_FLOAT) goto loaderr;\n    }\n    float value;\n    int retval = rdbLoadBinaryFloatValue(io->rio, &value);\n    if (retval == -1) goto loaderr;\n    return value;\n\nloaderr:\n    moduleRDBLoadError(io);\n    return 0; /* Never reached. */\n}\n\n/* --------------------------------------------------------------------------\n * Key digest API (DEBUG DIGEST interface for modules types)\n * -------------------------------------------------------------------------- */\n\n/* Add a new element to the digest. This function can be called multiple times\n * one element after the other, for all the elements that constitute a given\n * data structure. The function call must be followed by the call to\n * `RedisModule_DigestEndSequence` eventually, when all the elements that are\n * always in a given order are added. See the Redis Modules data types\n * documentation for more info. However this is a quick example that uses Redis\n * data types as an example.\n *\n * To add a sequence of unordered elements (for example in the case of a Redis\n * Set), the pattern to use is:\n *\n *     foreach element {\n *         AddElement(element);\n *         EndSequence();\n *     }\n *\n * Because Sets are not ordered, so every element added has a position that\n * does not depend from the other. However if instead our elements are\n * ordered in pairs, like field-value pairs of an Hash, then one should\n * use:\n *\n *     foreach key,value {\n *         AddElement(key);\n *         AddElement(value);\n *         EndSquence();\n *     }\n *\n * Because the key and value will be always in the above order, while instead\n * the single key-value pairs, can appear in any position into a Redis hash.\n *\n * A list of ordered elements would be implemented with:\n *\n *     foreach element {\n *         AddElement(element);\n *     }\n *     EndSequence();\n *\n */\nvoid RM_DigestAddStringBuffer(RedisModuleDigest *md, unsigned char *ele, size_t len) {\n    mixDigest(md->o,ele,len);\n}\n\n/* Like `RedisModule_DigestAddStringBuffer()` but takes a long long as input\n * that gets converted into a string before adding it to the digest. */\nvoid RM_DigestAddLongLong(RedisModuleDigest *md, long long ll) {\n    char buf[LONG_STR_SIZE];\n    size_t len = ll2string(buf,sizeof(buf),ll);\n    mixDigest(md->o,buf,len);\n}\n\n/* See the documentation for `RedisModule_DigestAddElement()`. */\nvoid RM_DigestEndSequence(RedisModuleDigest *md) {\n    xorDigest(md->x,md->o,sizeof(md->o));\n    memset(md->o,0,sizeof(md->o));\n}\n\n/* --------------------------------------------------------------------------\n * AOF API for modules data types\n * -------------------------------------------------------------------------- */\n\n/* Emits a command into the AOF during the AOF rewriting process. This function\n * is only called in the context of the aof_rewrite method of data types exported\n * by a module. The command works exactly like RedisModule_Call() in the way\n * the parameters are passed, but it does not return anything as the error\n * handling is performed by Redis itself. */\nvoid RM_EmitAOF(RedisModuleIO *io, const char *cmdname, const char *fmt, ...) {\n    if (io->error) return;\n    struct redisCommand *cmd;\n    robj **argv = NULL;\n    int argc = 0, flags = 0, j;\n    va_list ap;\n\n    cmd = lookupCommandByCString((char*)cmdname);\n    if (!cmd) {\n        serverLog(LL_WARNING,\n            \"Fatal: AOF method for module data type '%s' tried to \"\n            \"emit unknown command '%s'\",\n            io->type->name, cmdname);\n        io->error = 1;\n        errno = EINVAL;\n        return;\n    }\n\n    /* Emit the arguments into the AOF in Redis protocol format. */\n    va_start(ap, fmt);\n    argv = moduleCreateArgvFromUserFormat(cmdname,fmt,&argc,&flags,ap);\n    va_end(ap);\n    if (argv == NULL) {\n        serverLog(LL_WARNING,\n            \"Fatal: AOF method for module data type '%s' tried to \"\n            \"call RedisModule_EmitAOF() with wrong format specifiers '%s'\",\n            io->type->name, fmt);\n        io->error = 1;\n        errno = EINVAL;\n        return;\n    }\n\n    /* Bulk count. */\n    if (!io->error && rioWriteBulkCount(io->rio,'*',argc) == 0)\n        io->error = 1;\n\n    /* Arguments. */\n    for (j = 0; j < argc; j++) {\n        if (!io->error && rioWriteBulkObject(io->rio,argv[j]) == 0)\n            io->error = 1;\n        decrRefCount(argv[j]);\n    }\n    zfree(argv);\n    return;\n}\n\n/* --------------------------------------------------------------------------\n * IO context handling\n * -------------------------------------------------------------------------- */\n\nRedisModuleCtx *RM_GetContextFromIO(RedisModuleIO *io) {\n    if (io->ctx) return io->ctx; /* Can't have more than one... */\n    RedisModuleCtx ctxtemplate = REDISMODULE_CTX_INIT;\n    io->ctx = zmalloc(sizeof(RedisModuleCtx));\n    *(io->ctx) = ctxtemplate;\n    io->ctx->module = io->type->module;\n    io->ctx->client = NULL;\n    return io->ctx;\n}\n\n/* --------------------------------------------------------------------------\n * Logging\n * -------------------------------------------------------------------------- */\n\n/* This is the low level function implementing both:\n *\n *      RM_Log()\n *      RM_LogIOError()\n *\n */\nvoid RM_LogRaw(RedisModule *module, const char *levelstr, const char *fmt, va_list ap) {\n    char msg[LOG_MAX_LEN];\n    size_t name_len;\n    int level;\n\n    if (!strcasecmp(levelstr,\"debug\")) level = LL_DEBUG;\n    else if (!strcasecmp(levelstr,\"verbose\")) level = LL_VERBOSE;\n    else if (!strcasecmp(levelstr,\"notice\")) level = LL_NOTICE;\n    else if (!strcasecmp(levelstr,\"warning\")) level = LL_WARNING;\n    else level = LL_VERBOSE; /* Default. */\n\n    name_len = snprintf(msg, sizeof(msg),\"<%s> \", module->name);\n    vsnprintf(msg + name_len, sizeof(msg) - name_len, fmt, ap);\n    serverLogRaw(level,msg);\n}\n\n/* Produces a log message to the standard Redis log, the format accepts\n * printf-alike specifiers, while level is a string describing the log\n * level to use when emitting the log, and must be one of the following:\n *\n * * \"debug\"\n * * \"verbose\"\n * * \"notice\"\n * * \"warning\"\n *\n * If the specified log level is invalid, verbose is used by default.\n * There is a fixed limit to the length of the log line this function is able\n * to emit, this limit is not specified but is guaranteed to be more than\n * a few lines of text.\n */\nvoid RM_Log(RedisModuleCtx *ctx, const char *levelstr, const char *fmt, ...) {\n    if (!ctx->module) return;   /* Can only log if module is initialized */\n\n    va_list ap;\n    va_start(ap, fmt);\n    RM_LogRaw(ctx->module,levelstr,fmt,ap);\n    va_end(ap);\n}\n\n/* Log errors from RDB / AOF serialization callbacks.\n *\n * This function should be used when a callback is returning a critical\n * error to the caller since cannot load or save the data for some\n * critical reason. */\nvoid RM_LogIOError(RedisModuleIO *io, const char *levelstr, const char *fmt, ...) {\n    va_list ap;\n    va_start(ap, fmt);\n    RM_LogRaw(io->type->module,levelstr,fmt,ap);\n    va_end(ap);\n}\n\n/* --------------------------------------------------------------------------\n * Blocking clients from modules\n * -------------------------------------------------------------------------- */\n\n/* Readable handler for the awake pipe. We do nothing here, the awake bytes\n * will be actually read in a more appropriate place in the\n * moduleHandleBlockedClients() function that is where clients are actually\n * served. */\nvoid moduleBlockedClientPipeReadable(aeEventLoop *el, int fd, void *privdata, int mask) {\n    UNUSED(el);\n    UNUSED(fd);\n    UNUSED(mask);\n    UNUSED(privdata);\n}\n\n/* This is called from blocked.c in order to unblock a client: may be called\n * for multiple reasons while the client is in the middle of being blocked\n * because the client is terminated, but is also called for cleanup when a\n * client is unblocked in a clean way after replaying.\n *\n * What we do here is just to set the client to NULL in the redis module\n * blocked client handle. This way if the client is terminated while there\n * is a pending threaded operation involving the blocked client, we'll know\n * that the client no longer exists and no reply callback should be called.\n *\n * The structure RedisModuleBlockedClient will be always deallocated when\n * running the list of clients blocked by a module that need to be unblocked. */\nvoid unblockClientFromModule(client *c) {\n    RedisModuleBlockedClient *bc = c->bpop.module_blocked_handle;\n\n    /* Call the disconnection callback if any. */\n    if (bc->disconnect_callback) {\n        RedisModuleCtx ctx = REDISMODULE_CTX_INIT;\n        ctx.blocked_privdata = bc->privdata;\n        ctx.module = bc->module;\n        ctx.client = bc->client;\n        bc->disconnect_callback(&ctx,bc);\n        moduleFreeContext(&ctx);\n    }\n\n    bc->client = NULL;\n    /* Reset the client for a new query since, for blocking commands implemented\n     * into modules, we do not it immediately after the command returns (and\n     * the client blocks) in order to be still able to access the argument\n     * vector from callbacks. */\n    resetClient(c);\n}\n\n/* Block a client in the context of a blocking command, returning an handle\n * which will be used, later, in order to unblock the client with a call to\n * RedisModule_UnblockClient(). The arguments specify callback functions\n * and a timeout after which the client is unblocked.\n *\n * The callbacks are called in the following contexts:\n *\n *     reply_callback:  called after a successful RedisModule_UnblockClient()\n *                      call in order to reply to the client and unblock it.\n *\n *     reply_timeout:   called when the timeout is reached in order to send an\n *                      error to the client.\n *\n *     free_privdata:   called in order to free the private data that is passed\n *                      by RedisModule_UnblockClient() call.\n */\nRedisModuleBlockedClient *RM_BlockClient(RedisModuleCtx *ctx, RedisModuleCmdFunc reply_callback, RedisModuleCmdFunc timeout_callback, void (*free_privdata)(RedisModuleCtx*,void*), long long timeout_ms) {\n    client *c = ctx->client;\n    int islua = c->flags & CLIENT_LUA;\n    int ismulti = c->flags & CLIENT_MULTI;\n\n    c->bpop.module_blocked_handle = zmalloc(sizeof(RedisModuleBlockedClient));\n    RedisModuleBlockedClient *bc = c->bpop.module_blocked_handle;\n\n    /* We need to handle the invalid operation of calling modules blocking\n     * commands from Lua or MULTI. We actually create an already aborted\n     * (client set to NULL) blocked client handle, and actually reply with\n     * an error. */\n    bc->client = (islua || ismulti) ? NULL : c;\n    bc->module = ctx->module;\n    bc->reply_callback = reply_callback;\n    bc->timeout_callback = timeout_callback;\n    bc->disconnect_callback = NULL; /* Set by RM_SetDisconnectCallback() */\n    bc->free_privdata = free_privdata;\n    bc->privdata = NULL;\n    bc->reply_client = createClient(-1);\n    bc->reply_client->flags |= CLIENT_MODULE;\n    bc->dbid = c->db->id;\n    c->bpop.timeout = timeout_ms ? (mstime()+timeout_ms) : 0;\n\n    if (islua || ismulti) {\n        c->bpop.module_blocked_handle = NULL;\n        addReplyError(c, islua ?\n            \"Blocking module command called from Lua script\" :\n            \"Blocking module command called from transaction\");\n    } else {\n        blockClient(c,BLOCKED_MODULE);\n    }\n    return bc;\n}\n\n/* Unblock a client blocked by `RedisModule_BlockedClient`. This will trigger\n * the reply callbacks to be called in order to reply to the client.\n * The 'privdata' argument will be accessible by the reply callback, so\n * the caller of this function can pass any value that is needed in order to\n * actually reply to the client.\n *\n * A common usage for 'privdata' is a thread that computes something that\n * needs to be passed to the client, included but not limited some slow\n * to compute reply or some reply obtained via networking.\n *\n * Note: this function can be called from threads spawned by the module. */\nint RM_UnblockClient(RedisModuleBlockedClient *bc, void *privdata) {\n    pthread_mutex_lock(&moduleUnblockedClientsMutex);\n    bc->privdata = privdata;\n    listAddNodeTail(moduleUnblockedClients,bc);\n    if (write(server.module_blocked_pipe[1],\"A\",1) != 1) {\n        /* Ignore the error, this is best-effort. */\n    }\n    pthread_mutex_unlock(&moduleUnblockedClientsMutex);\n    return REDISMODULE_OK;\n}\n\n/* Abort a blocked client blocking operation: the client will be unblocked\n * without firing any callback. */\nint RM_AbortBlock(RedisModuleBlockedClient *bc) {\n    bc->reply_callback = NULL;\n    bc->disconnect_callback = NULL;\n    return RM_UnblockClient(bc,NULL);\n}\n\n/* Set a callback that will be called if a blocked client disconnects\n * before the module has a chance to call RedisModule_UnblockClient()\n *\n * Usually what you want to do there, is to cleanup your module state\n * so that you can call RedisModule_UnblockClient() safely, otherwise\n * the client will remain blocked forever if the timeout is large.\n *\n * Notes:\n *\n * 1. It is not safe to call Reply* family functions here, it is also\n *    useless since the client is gone.\n *\n * 2. This callback is not called if the client disconnects because of\n *    a timeout. In such a case, the client is unblocked automatically\n *    and the timeout callback is called.\n */\nvoid RM_SetDisconnectCallback(RedisModuleBlockedClient *bc, RedisModuleDisconnectFunc callback) {\n    bc->disconnect_callback = callback;\n}\n\n/* This function will check the moduleUnblockedClients queue in order to\n * call the reply callback and really unblock the client.\n *\n * Clients end into this list because of calls to RM_UnblockClient(),\n * however it is possible that while the module was doing work for the\n * blocked client, it was terminated by Redis (for timeout or other reasons).\n * When this happens the RedisModuleBlockedClient structure in the queue\n * will have the 'client' field set to NULL. */\nvoid moduleHandleBlockedClients(void) {\n    listNode *ln;\n    RedisModuleBlockedClient *bc;\n\n    pthread_mutex_lock(&moduleUnblockedClientsMutex);\n    /* Here we unblock all the pending clients blocked in modules operations\n     * so we can read every pending \"awake byte\" in the pipe. */\n    char buf[1];\n    while (read(server.module_blocked_pipe[0],buf,1) == 1);\n    while (listLength(moduleUnblockedClients)) {\n        ln = listFirst(moduleUnblockedClients);\n        bc = ln->value;\n        client *c = bc->client;\n        listDelNode(moduleUnblockedClients,ln);\n        pthread_mutex_unlock(&moduleUnblockedClientsMutex);\n\n        /* Release the lock during the loop, as long as we don't\n         * touch the shared list. */\n\n        /* Call the reply callback if the client is valid and we have\n         * any callback. */\n        if (c && bc->reply_callback) {\n            RedisModuleCtx ctx = REDISMODULE_CTX_INIT;\n            ctx.flags |= REDISMODULE_CTX_BLOCKED_REPLY;\n            ctx.blocked_privdata = bc->privdata;\n            ctx.module = bc->module;\n            ctx.client = bc->client;\n            ctx.blocked_client = bc;\n            bc->reply_callback(&ctx,(void**)c->argv,c->argc);\n            moduleHandlePropagationAfterCommandCallback(&ctx);\n            moduleFreeContext(&ctx);\n        }\n\n        /* Free privdata if any. */\n        if (bc->privdata && bc->free_privdata) {\n            RedisModuleCtx ctx = REDISMODULE_CTX_INIT;\n            if (c == NULL)\n                ctx.flags |= REDISMODULE_CTX_BLOCKED_DISCONNECTED;\n            ctx.blocked_privdata = bc->privdata;\n            ctx.module = bc->module;\n            ctx.client = bc->client;\n            bc->free_privdata(&ctx,bc->privdata);\n            moduleFreeContext(&ctx);\n        }\n\n        /* It is possible that this blocked client object accumulated\n         * replies to send to the client in a thread safe context.\n         * We need to glue such replies to the client output buffer and\n         * free the temporary client we just used for the replies. */\n        if (c) {\n            if (bc->reply_client->bufpos)\n                addReplyString(c,bc->reply_client->buf,\n                                 bc->reply_client->bufpos);\n            if (listLength(bc->reply_client->reply))\n                listJoin(c->reply,bc->reply_client->reply);\n            c->reply_bytes += bc->reply_client->reply_bytes;\n        }\n        freeClient(bc->reply_client);\n\n        if (c != NULL) {\n            /* Before unblocking the client, set the disconnect callback\n             * to NULL, because if we reached this point, the client was\n             * properly unblocked by the module. */\n            bc->disconnect_callback = NULL;\n            unblockClient(c);\n            /* Put the client in the list of clients that need to write\n             * if there are pending replies here. This is needed since\n             * during a non blocking command the client may receive output. */\n            if (clientHasPendingReplies(c) &&\n                !(c->flags & CLIENT_PENDING_WRITE))\n            {\n                c->flags |= CLIENT_PENDING_WRITE;\n                listAddNodeHead(server.clients_pending_write,c);\n            }\n        }\n\n        /* Free 'bc' only after unblocking the client, since it is\n         * referenced in the client blocking context, and must be valid\n         * when calling unblockClient(). */\n        zfree(bc);\n\n        /* Lock again before to iterate the loop. */\n        pthread_mutex_lock(&moduleUnblockedClientsMutex);\n    }\n    pthread_mutex_unlock(&moduleUnblockedClientsMutex);\n}\n\n/* Called when our client timed out. After this function unblockClient()\n * is called, and it will invalidate the blocked client. So this function\n * does not need to do any cleanup. Eventually the module will call the\n * API to unblock the client and the memory will be released. */\nvoid moduleBlockedClientTimedOut(client *c) {\n    RedisModuleBlockedClient *bc = c->bpop.module_blocked_handle;\n    RedisModuleCtx ctx = REDISMODULE_CTX_INIT;\n    ctx.flags |= REDISMODULE_CTX_BLOCKED_TIMEOUT;\n    ctx.module = bc->module;\n    ctx.client = bc->client;\n    ctx.blocked_client = bc;\n    bc->timeout_callback(&ctx,(void**)c->argv,c->argc);\n    moduleFreeContext(&ctx);\n    /* For timeout events, we do not want to call the disconnect callback,\n     * because the blocked client will be automatically disconnected in\n     * this case, and the user can still hook using the timeout callback. */\n    bc->disconnect_callback = NULL;\n}\n\n/* Return non-zero if a module command was called in order to fill the\n * reply for a blocked client. */\nint RM_IsBlockedReplyRequest(RedisModuleCtx *ctx) {\n    return (ctx->flags & REDISMODULE_CTX_BLOCKED_REPLY) != 0;\n}\n\n/* Return non-zero if a module command was called in order to fill the\n * reply for a blocked client that timed out. */\nint RM_IsBlockedTimeoutRequest(RedisModuleCtx *ctx) {\n    return (ctx->flags & REDISMODULE_CTX_BLOCKED_TIMEOUT) != 0;\n}\n\n/* Get the private data set by RedisModule_UnblockClient() */\nvoid *RM_GetBlockedClientPrivateData(RedisModuleCtx *ctx) {\n    return ctx->blocked_privdata;\n}\n\n/* Get the blocked client associated with a given context.\n * This is useful in the reply and timeout callbacks of blocked clients,\n * before sometimes the module has the blocked client handle references\n * around, and wants to cleanup it. */\nRedisModuleBlockedClient *RM_GetBlockedClientHandle(RedisModuleCtx *ctx) {\n    return ctx->blocked_client;\n}\n\n/* Return true if when the free callback of a blocked client is called,\n * the reason for the client to be unblocked is that it disconnected\n * while it was blocked. */\nint RM_BlockedClientDisconnected(RedisModuleCtx *ctx) {\n    return (ctx->flags & REDISMODULE_CTX_BLOCKED_DISCONNECTED) != 0;\n}\n\n/* --------------------------------------------------------------------------\n * Thread Safe Contexts\n * -------------------------------------------------------------------------- */\n\n/* Return a context which can be used inside threads to make Redis context\n * calls with certain modules APIs. If 'bc' is not NULL then the module will\n * be bound to a blocked client, and it will be possible to use the\n * `RedisModule_Reply*` family of functions to accumulate a reply for when the\n * client will be unblocked. Otherwise the thread safe context will be\n * detached by a specific client.\n *\n * To call non-reply APIs, the thread safe context must be prepared with:\n *\n *     RedisModule_ThreadSafeCallStart(ctx);\n *     ... make your call here ...\n *     RedisModule_ThreadSafeCallStop(ctx);\n *\n * This is not needed when using `RedisModule_Reply*` functions, assuming\n * that a blocked client was used when the context was created, otherwise\n * no RedisModule_Reply* call should be made at all.\n *\n * TODO: thread safe contexts do not inherit the blocked client\n * selected database. */\nRedisModuleCtx *RM_GetThreadSafeContext(RedisModuleBlockedClient *bc) {\n    RedisModuleCtx *ctx = zmalloc(sizeof(*ctx));\n    RedisModuleCtx empty = REDISMODULE_CTX_INIT;\n    memcpy(ctx,&empty,sizeof(empty));\n    if (bc) {\n        ctx->blocked_client = bc;\n        ctx->module = bc->module;\n    }\n    ctx->flags |= REDISMODULE_CTX_THREAD_SAFE;\n    /* Even when the context is associated with a blocked client, we can't\n     * access it safely from another thread, so we create a fake client here\n     * in order to keep things like the currently selected database and similar\n     * things. */\n    ctx->client = createClient(-1);\n    if (bc) selectDb(ctx->client,bc->dbid);\n    return ctx;\n}\n\n/* Release a thread safe context. */\nvoid RM_FreeThreadSafeContext(RedisModuleCtx *ctx) {\n    moduleFreeContext(ctx);\n    zfree(ctx);\n}\n\n/* Acquire the server lock before executing a thread safe API call.\n * This is not needed for `RedisModule_Reply*` calls when there is\n * a blocked client connected to the thread safe context. */\nvoid RM_ThreadSafeContextLock(RedisModuleCtx *ctx) {\n    UNUSED(ctx);\n    moduleAcquireGIL();\n}\n\n/* Release the server lock after a thread safe API call was executed. */\nvoid RM_ThreadSafeContextUnlock(RedisModuleCtx *ctx) {\n    UNUSED(ctx);\n    moduleReleaseGIL();\n}\n\nvoid moduleAcquireGIL(void) {\n    pthread_mutex_lock(&moduleGIL);\n}\n\nvoid moduleReleaseGIL(void) {\n    pthread_mutex_unlock(&moduleGIL);\n}\n\n\n/* --------------------------------------------------------------------------\n * Module Keyspace Notifications API\n * -------------------------------------------------------------------------- */\n\n/* Subscribe to keyspace notifications. This is a low-level version of the\n * keyspace-notifications API. A module can register callbacks to be notified\n * when keyspce events occur.\n *\n * Notification events are filtered by their type (string events, set events,\n * etc), and the subscriber callback receives only events that match a specific\n * mask of event types.\n *\n * When subscribing to notifications with RedisModule_SubscribeToKeyspaceEvents \n * the module must provide an event type-mask, denoting the events the subscriber\n * is interested in. This can be an ORed mask of any of the following flags:\n *\n *  - REDISMODULE_NOTIFY_GENERIC: Generic commands like DEL, EXPIRE, RENAME\n *  - REDISMODULE_NOTIFY_STRING: String events\n *  - REDISMODULE_NOTIFY_LIST: List events\n *  - REDISMODULE_NOTIFY_SET: Set events\n *  - REDISMODULE_NOTIFY_HASH: Hash events\n *  - REDISMODULE_NOTIFY_ZSET: Sorted Set events\n *  - REDISMODULE_NOTIFY_EXPIRED: Expiration events\n *  - REDISMODULE_NOTIFY_EVICTED: Eviction events\n *  - REDISMODULE_NOTIFY_STREAM: Stream events\n *  - REDISMODULE_NOTIFY_ALL: All events\n *\n * We do not distinguish between key events and keyspace events, and it is up\n * to the module to filter the actions taken based on the key.\n *\n * The subscriber signature is:\n *\n *   int (*RedisModuleNotificationFunc) (RedisModuleCtx *ctx, int type,\n *                                       const char *event,\n *                                       RedisModuleString *key);\n *\n * `type` is the event type bit, that must match the mask given at registration\n * time. The event string is the actual command being executed, and key is the\n * relevant Redis key.\n *\n * Notification callback gets executed with a redis context that can not be\n * used to send anything to the client, and has the db number where the event\n * occurred as its selected db number.\n *\n * Notice that it is not necessary to enable notifications in redis.conf for\n * module notifications to work.\n *\n * Warning: the notification callbacks are performed in a synchronous manner,\n * so notification callbacks must to be fast, or they would slow Redis down.\n * If you need to take long actions, use threads to offload them.\n *\n * See https://redis.io/topics/notifications for more information.\n */\nint RM_SubscribeToKeyspaceEvents(RedisModuleCtx *ctx, int types, RedisModuleNotificationFunc callback) {\n    RedisModuleKeyspaceSubscriber *sub = zmalloc(sizeof(*sub));\n    sub->module = ctx->module;\n    sub->event_mask = types;\n    sub->notify_callback = callback;\n    sub->active = 0;\n\n    listAddNodeTail(moduleKeyspaceSubscribers, sub);\n    return REDISMODULE_OK;\n}\n\n/* Dispatcher for keyspace notifications to module subscriber functions.\n * This gets called  only if at least one module requested to be notified on\n * keyspace notifications */\nvoid moduleNotifyKeyspaceEvent(int type, const char *event, robj *key, int dbid) {\n    /* Don't do anything if there aren't any subscribers */\n    if (listLength(moduleKeyspaceSubscribers) == 0) return;\n\n    listIter li;\n    listNode *ln;\n    listRewind(moduleKeyspaceSubscribers,&li);\n\n    /* Remove irrelevant flags from the type mask */\n    type &= ~(NOTIFY_KEYEVENT | NOTIFY_KEYSPACE);\n\n    while((ln = listNext(&li))) {\n        RedisModuleKeyspaceSubscriber *sub = ln->value;\n        /* Only notify subscribers on events matching they registration,\n         * and avoid subscribers triggering themselves */\n        if ((sub->event_mask & type) && sub->active == 0) {\n            RedisModuleCtx ctx = REDISMODULE_CTX_INIT;\n            ctx.module = sub->module;\n            ctx.client = moduleFreeContextReusedClient;\n            selectDb(ctx.client, dbid);\n\n            /* mark the handler as active to avoid reentrant loops.\n             * If the subscriber performs an action triggering itself,\n             * it will not be notified about it. */\n            sub->active = 1;\n            sub->notify_callback(&ctx, type, event, key);\n            sub->active = 0;\n            moduleFreeContext(&ctx);\n        }\n    }\n}\n\n/* Unsubscribe any notification subscribers this module has upon unloading */\nvoid moduleUnsubscribeNotifications(RedisModule *module) {\n    listIter li;\n    listNode *ln;\n    listRewind(moduleKeyspaceSubscribers,&li);\n    while((ln = listNext(&li))) {\n        RedisModuleKeyspaceSubscriber *sub = ln->value;\n        if (sub->module == module) {\n            listDelNode(moduleKeyspaceSubscribers, ln);\n            zfree(sub);\n        }\n    }\n}\n\n/* --------------------------------------------------------------------------\n * Modules Cluster API\n * -------------------------------------------------------------------------- */\n\n/* The Cluster message callback function pointer type. */\ntypedef void (*RedisModuleClusterMessageReceiver)(RedisModuleCtx *ctx, const char *sender_id, uint8_t type, const unsigned char *payload, uint32_t len);\n\n/* This structure identifies a registered caller: it must match a given module\n * ID, for a given message type. The callback function is just the function\n * that was registered as receiver. */\ntypedef struct moduleClusterReceiver {\n    uint64_t module_id;\n    RedisModuleClusterMessageReceiver callback;\n    struct RedisModule *module;\n    struct moduleClusterReceiver *next;\n} moduleClusterReceiver;\n\ntypedef struct moduleClusterNodeInfo {\n    int flags;\n    char ip[NET_IP_STR_LEN];\n    int port;\n    char master_id[40]; /* Only if flags & REDISMODULE_NODE_MASTER is true. */\n} mdouleClusterNodeInfo;\n\n/* We have an array of message types: each bucket is a linked list of\n * configured receivers. */\nstatic moduleClusterReceiver *clusterReceivers[UINT8_MAX];\n\n/* Dispatch the message to the right module receiver. */\nvoid moduleCallClusterReceivers(const char *sender_id, uint64_t module_id, uint8_t type, const unsigned char *payload, uint32_t len) {\n    moduleClusterReceiver *r = clusterReceivers[type];\n    while(r) {\n        if (r->module_id == module_id) {\n            RedisModuleCtx ctx = REDISMODULE_CTX_INIT;\n            ctx.module = r->module;\n            ctx.client = moduleFreeContextReusedClient;\n            selectDb(ctx.client, 0);\n            r->callback(&ctx,sender_id,type,payload,len);\n            moduleFreeContext(&ctx);\n            return;\n        }\n        r = r->next;\n    }\n}\n\n/* Register a callback receiver for cluster messages of type 'type'. If there\n * was already a registered callback, this will replace the callback function\n * with the one provided, otherwise if the callback is set to NULL and there\n * is already a callback for this function, the callback is unregistered\n * (so this API call is also used in order to delete the receiver). */\nvoid RM_RegisterClusterMessageReceiver(RedisModuleCtx *ctx, uint8_t type, RedisModuleClusterMessageReceiver callback) {\n    if (!server.cluster_enabled) return;\n\n    uint64_t module_id = moduleTypeEncodeId(ctx->module->name,0);\n    moduleClusterReceiver *r = clusterReceivers[type], *prev = NULL;\n    while(r) {\n        if (r->module_id == module_id) {\n            /* Found! Set or delete. */\n            if (callback) {\n                r->callback = callback;\n            } else {\n                /* Delete the receiver entry if the user is setting\n                 * it to NULL. Just unlink the receiver node from the\n                 * linked list. */\n                if (prev)\n                    prev->next = r->next;\n                else\n                    clusterReceivers[type]->next = r->next;\n                zfree(r);\n            }\n            return;\n        }\n        prev = r;\n        r = r->next;\n    }\n\n    /* Not found, let's add it. */\n    if (callback) {\n        r = zmalloc(sizeof(*r));\n        r->module_id = module_id;\n        r->module = ctx->module;\n        r->callback = callback;\n        r->next = clusterReceivers[type];\n        clusterReceivers[type] = r;\n    }\n}\n\n/* Send a message to all the nodes in the cluster if `target` is NULL, otherwise\n * at the specified target, which is a REDISMODULE_NODE_ID_LEN bytes node ID, as\n * returned by the receiver callback or by the nodes iteration functions.\n *\n * The function returns REDISMODULE_OK if the message was successfully sent,\n * otherwise if the node is not connected or such node ID does not map to any\n * known cluster node, REDISMODULE_ERR is returned. */\nint RM_SendClusterMessage(RedisModuleCtx *ctx, char *target_id, uint8_t type, unsigned char *msg, uint32_t len) {\n    if (!server.cluster_enabled) return REDISMODULE_ERR;\n    uint64_t module_id = moduleTypeEncodeId(ctx->module->name,0);\n    if (clusterSendModuleMessageToTarget(target_id,module_id,type,msg,len) == C_OK)\n        return REDISMODULE_OK;\n    else\n        return REDISMODULE_ERR;\n}\n\n/* Return an array of string pointers, each string pointer points to a cluster\n * node ID of exactly REDISMODULE_NODE_ID_SIZE bytes (without any null term).\n * The number of returned node IDs is stored into `*numnodes`.\n * However if this function is called by a module not running an a Redis\n * instance with Redis Cluster enabled, NULL is returned instead.\n *\n * The IDs returned can be used with RedisModule_GetClusterNodeInfo() in order\n * to get more information about single nodes.\n *\n * The array returned by this function must be freed using the function\n * RedisModule_FreeClusterNodesList().\n *\n * Example:\n *\n *     size_t count, j;\n *     char **ids = RedisModule_GetClusterNodesList(ctx,&count);\n *     for (j = 0; j < count; j++) {\n *         RedisModule_Log(\"notice\",\"Node %.*s\",\n *             REDISMODULE_NODE_ID_LEN,ids[j]);\n *     }\n *     RedisModule_FreeClusterNodesList(ids);\n */\nchar **RM_GetClusterNodesList(RedisModuleCtx *ctx, size_t *numnodes) {\n    UNUSED(ctx);\n\n    if (!server.cluster_enabled) return NULL;\n    size_t count = dictSize(server.cluster->nodes);\n    char **ids = zmalloc((count+1)*REDISMODULE_NODE_ID_LEN);\n    dictIterator *di = dictGetIterator(server.cluster->nodes);\n    dictEntry *de;\n    int j = 0;\n    while((de = dictNext(di)) != NULL) {\n        clusterNode *node = dictGetVal(de);\n        if (node->flags & (CLUSTER_NODE_NOADDR|CLUSTER_NODE_HANDSHAKE)) continue;\n        ids[j] = zmalloc(REDISMODULE_NODE_ID_LEN);\n        memcpy(ids[j],node->name,REDISMODULE_NODE_ID_LEN);\n        j++;\n    }\n    *numnodes = j;\n    ids[j] = NULL; /* Null term so that FreeClusterNodesList does not need\n                    * to also get the count argument. */\n    dictReleaseIterator(di);\n    return ids;\n}\n\n/* Free the node list obtained with RedisModule_GetClusterNodesList. */\nvoid RM_FreeClusterNodesList(char **ids) {\n    if (ids == NULL) return;\n    for (int j = 0; ids[j]; j++) zfree(ids[j]);\n    zfree(ids);\n}\n\n/* Return this node ID (REDISMODULE_CLUSTER_ID_LEN bytes) or NULL if the cluster\n * is disabled. */\nconst char *RM_GetMyClusterID(void) {\n    if (!server.cluster_enabled) return NULL;\n    return server.cluster->myself->name;\n}\n\n/* Return the number of nodes in the cluster, regardless of their state\n * (handshake, noaddress, ...) so that the number of active nodes may actually\n * be smaller, but not greater than this number. If the instance is not in\n * cluster mode, zero is returned. */\nsize_t RM_GetClusterSize(void) {\n    if (!server.cluster_enabled) return 0;\n    return dictSize(server.cluster->nodes);\n}\n\n/* Populate the specified info for the node having as ID the specified 'id',\n * then returns REDISMODULE_OK. Otherwise if the node ID does not exist from\n * the POV of this local node, REDISMODULE_ERR is returned.\n *\n * The arguments ip, master_id, port and flags can be NULL in case we don't\n * need to populate back certain info. If an ip and master_id (only populated\n * if the instance is a slave) are specified, they point to buffers holding\n * at least REDISMODULE_NODE_ID_LEN bytes. The strings written back as ip\n * and master_id are not null terminated.\n *\n * The list of flags reported is the following:\n *\n * * REDISMODULE_NODE_MYSELF        This node\n * * REDISMODULE_NODE_MASTER        The node is a master\n * * REDISMODULE_NODE_SLAVE         The node is a replica\n * * REDISMODULE_NODE_PFAIL         We see the node as failing\n * * REDISMODULE_NODE_FAIL          The cluster agrees the node is failing\n * * REDISMODULE_NODE_NOFAILOVER    The slave is configured to never failover\n */\n\nclusterNode *clusterLookupNode(const char *name); /* We need access to internals */\n\nint RM_GetClusterNodeInfo(RedisModuleCtx *ctx, const char *id, char *ip, char *master_id, int *port, int *flags) {\n    UNUSED(ctx);\n\n    clusterNode *node = clusterLookupNode(id);\n    if (node->flags & (CLUSTER_NODE_NOADDR|CLUSTER_NODE_HANDSHAKE))\n        return REDISMODULE_ERR;\n\n    if (ip) memcpy(ip,node->name,REDISMODULE_NODE_ID_LEN);\n\n    if (master_id) {\n        /* If the information is not available, the function will set the\n         * field to zero bytes, so that when the field can't be populated the\n         * function kinda remains predictable. */\n        if (node->flags & CLUSTER_NODE_MASTER && node->slaveof)\n            memcpy(master_id,node->slaveof->name,REDISMODULE_NODE_ID_LEN);\n        else\n            memset(master_id,0,REDISMODULE_NODE_ID_LEN);\n    }\n    if (port) *port = node->port;\n\n    /* As usually we have to remap flags for modules, in order to ensure\n     * we can provide binary compatibility. */\n    if (flags) {\n        *flags = 0;\n        if (node->flags & CLUSTER_NODE_MYSELF) *flags |= REDISMODULE_NODE_MYSELF;\n        if (node->flags & CLUSTER_NODE_MASTER) *flags |= REDISMODULE_NODE_MASTER;\n        if (node->flags & CLUSTER_NODE_SLAVE) *flags |= REDISMODULE_NODE_SLAVE;\n        if (node->flags & CLUSTER_NODE_PFAIL) *flags |= REDISMODULE_NODE_PFAIL;\n        if (node->flags & CLUSTER_NODE_FAIL) *flags |= REDISMODULE_NODE_FAIL;\n        if (node->flags & CLUSTER_NODE_NOFAILOVER) *flags |= REDISMODULE_NODE_NOFAILOVER;\n    }\n    return REDISMODULE_OK;\n}\n\n/* Set Redis Cluster flags in order to change the normal behavior of\n * Redis Cluster, especially with the goal of disabling certain functions.\n * This is useful for modules that use the Cluster API in order to create\n * a different distributed system, but still want to use the Redis Cluster\n * message bus. Flags that can be set:\n *\n *  CLUSTER_MODULE_FLAG_NO_FAILOVER\n *  CLUSTER_MODULE_FLAG_NO_REDIRECTION\n *\n * With the following effects:\n *\n *  NO_FAILOVER: prevent Redis Cluster slaves to failover a failing master.\n *               Also disables the replica migration feature.\n *\n *  NO_REDIRECTION: Every node will accept any key, without trying to perform\n *                  partitioning according to the user Redis Cluster algorithm.\n *                  Slots informations will still be propagated across the\n *                  cluster, but without effects. */\nvoid RM_SetClusterFlags(RedisModuleCtx *ctx, uint64_t flags) {\n    UNUSED(ctx);\n    if (flags & REDISMODULE_CLUSTER_FLAG_NO_FAILOVER)\n        server.cluster_module_flags |= CLUSTER_MODULE_FLAG_NO_FAILOVER;\n    if (flags & REDISMODULE_CLUSTER_FLAG_NO_REDIRECTION)\n        server.cluster_module_flags |= CLUSTER_MODULE_FLAG_NO_REDIRECTION;\n}\n\n/* --------------------------------------------------------------------------\n * Modules Timers API\n *\n * Module timers are an high precision \"green timers\" abstraction where\n * every module can register even millions of timers without problems, even if\n * the actual event loop will just have a single timer that is used to awake the\n * module timers subsystem in order to process the next event.\n *\n * All the timers are stored into a radix tree, ordered by expire time, when\n * the main Redis event loop timer callback is called, we try to process all\n * the timers already expired one after the other. Then we re-enter the event\n * loop registering a timer that will expire when the next to process module\n * timer will expire.\n *\n * Every time the list of active timers drops to zero, we unregister the\n * main event loop timer, so that there is no overhead when such feature is\n * not used.\n * -------------------------------------------------------------------------- */\n\nstatic rax *Timers;     /* The radix tree of all the timers sorted by expire. */\nlong long aeTimer = -1; /* Main event loop (ae.c) timer identifier. */\n\ntypedef void (*RedisModuleTimerProc)(RedisModuleCtx *ctx, void *data);\n\n/* The timer descriptor, stored as value in the radix tree. */\ntypedef struct RedisModuleTimer {\n    RedisModule *module;                /* Module reference. */\n    RedisModuleTimerProc callback;      /* The callback to invoke on expire. */\n    void *data;                         /* Private data for the callback. */\n    int dbid;                           /* Database number selected by the original client. */\n} RedisModuleTimer;\n\n/* This is the timer handler that is called by the main event loop. We schedule\n * this timer to be called when the nearest of our module timers will expire. */\nint moduleTimerHandler(struct aeEventLoop *eventLoop, long long id, void *clientData) {\n    UNUSED(eventLoop);\n    UNUSED(id);\n    UNUSED(clientData);\n\n    /* To start let's try to fire all the timers already expired. */\n    raxIterator ri;\n    raxStart(&ri,Timers);\n    uint64_t now = ustime();\n    long long next_period = 0;\n    while(1) {\n        raxSeek(&ri,\"^\",NULL,0);\n        if (!raxNext(&ri)) break;\n        uint64_t expiretime;\n        memcpy(&expiretime,ri.key,sizeof(expiretime));\n        expiretime = ntohu64(expiretime);\n        if (now >= expiretime) {\n            RedisModuleTimer *timer = ri.data;\n            RedisModuleCtx ctx = REDISMODULE_CTX_INIT;\n\n            ctx.module = timer->module;\n            ctx.client = moduleFreeContextReusedClient;\n            selectDb(ctx.client, timer->dbid);\n            timer->callback(&ctx,timer->data);\n            moduleFreeContext(&ctx);\n            raxRemove(Timers,(unsigned char*)ri.key,ri.key_len,NULL);\n            zfree(timer);\n        } else {\n            next_period = (expiretime-now)/1000; /* Scale to milliseconds. */\n            break;\n        }\n    }\n    raxStop(&ri);\n\n    /* Reschedule the next timer or cancel it. */\n    if (next_period <= 0) next_period = 1;\n    return (raxSize(Timers) > 0) ? next_period : AE_NOMORE;\n}\n\n/* Create a new timer that will fire after `period` milliseconds, and will call\n * the specified function using `data` as argument. The returned timer ID can be\n * used to get information from the timer or to stop it before it fires. */\nRedisModuleTimerID RM_CreateTimer(RedisModuleCtx *ctx, mstime_t period, RedisModuleTimerProc callback, void *data) {\n    RedisModuleTimer *timer = zmalloc(sizeof(*timer));\n    timer->module = ctx->module;\n    timer->callback = callback;\n    timer->data = data;\n    timer->dbid = ctx->client->db->id;\n    uint64_t expiretime = ustime()+period*1000;\n    uint64_t key;\n\n    while(1) {\n        key = htonu64(expiretime);\n        if (raxFind(Timers, (unsigned char*)&key,sizeof(key)) == raxNotFound) {\n            raxInsert(Timers,(unsigned char*)&key,sizeof(key),timer,NULL);\n            break;\n        } else {\n            expiretime++;\n        }\n    }\n\n    /* We need to install the main event loop timer if it's not already\n     * installed, or we may need to refresh its period if we just installed\n     * a timer that will expire sooner than any other else. */\n    if (aeTimer != -1) {\n        raxIterator ri;\n        raxStart(&ri,Timers);\n        raxSeek(&ri,\"^\",NULL,0);\n        raxNext(&ri);\n        if (memcmp(ri.key,&key,sizeof(key)) == 0) {\n            /* This is the first key, we need to re-install the timer according\n             * to the just added event. */\n            aeDeleteTimeEvent(server.el,aeTimer);\n            aeTimer = -1;\n        }\n        raxStop(&ri);\n    }\n\n    /* If we have no main timer (the old one was invalidated, or this is the\n     * first module timer we have), install one. */\n    if (aeTimer == -1)\n        aeTimer = aeCreateTimeEvent(server.el,period,moduleTimerHandler,NULL,NULL);\n\n    return key;\n}\n\n/* Stop a timer, returns REDISMODULE_OK if the timer was found, belonged to the\n * calling module, and was stopped, otherwise REDISMODULE_ERR is returned.\n * If not NULL, the data pointer is set to the value of the data argument when\n * the timer was created. */\nint RM_StopTimer(RedisModuleCtx *ctx, RedisModuleTimerID id, void **data) {\n    RedisModuleTimer *timer = raxFind(Timers,(unsigned char*)&id,sizeof(id));\n    if (timer == raxNotFound || timer->module != ctx->module)\n        return REDISMODULE_ERR;\n    if (data) *data = timer->data;\n    raxRemove(Timers,(unsigned char*)&id,sizeof(id),NULL);\n    zfree(timer);\n    return REDISMODULE_OK;\n}\n\n/* Obtain information about a timer: its remaining time before firing\n * (in milliseconds), and the private data pointer associated with the timer.\n * If the timer specified does not exist or belongs to a different module\n * no information is returned and the function returns REDISMODULE_ERR, otherwise\n * REDISMODULE_OK is returned. The arguments remaining or data can be NULL if\n * the caller does not need certain information. */\nint RM_GetTimerInfo(RedisModuleCtx *ctx, RedisModuleTimerID id, uint64_t *remaining, void **data) {\n    RedisModuleTimer *timer = raxFind(Timers,(unsigned char*)&id,sizeof(id));\n    if (timer == raxNotFound || timer->module != ctx->module)\n        return REDISMODULE_ERR;\n    if (remaining) {\n        int64_t rem = ntohu64(id)-ustime();\n        if (rem < 0) rem = 0;\n        *remaining = rem/1000; /* Scale to milliseconds. */\n    }\n    if (data) *data = timer->data;\n    return REDISMODULE_OK;\n}\n\n/* --------------------------------------------------------------------------\n * Modules Dictionary API\n *\n * Implements a sorted dictionary (actually backed by a radix tree) with\n * the usual get / set / del / num-items API, together with an iterator\n * capable of going back and forth.\n * -------------------------------------------------------------------------- */\n\n/* Create a new dictionary. The 'ctx' pointer can be the current module context\n * or NULL, depending on what you want. Please follow the following rules:\n *\n * 1. Use a NULL context if you plan to retain a reference to this dictionary\n *    that will survive the time of the module callback where you created it.\n * 2. Use a NULL context if no context is available at the time you are creating\n *    the dictionary (of course...).\n * 3. However use the current callback context as 'ctx' argument if the\n *    dictionary time to live is just limited to the callback scope. In this\n *    case, if enabled, you can enjoy the automatic memory management that will\n *    reclaim the dictionary memory, as well as the strings returned by the\n *    Next / Prev dictionary iterator calls.\n */\nRedisModuleDict *RM_CreateDict(RedisModuleCtx *ctx) {\n    struct RedisModuleDict *d = zmalloc(sizeof(*d));\n    d->rax = raxNew();\n    if (ctx != NULL) autoMemoryAdd(ctx,REDISMODULE_AM_DICT,d);\n    return d;\n}\n\n/* Free a dictionary created with RM_CreateDict(). You need to pass the\n * context pointer 'ctx' only if the dictionary was created using the\n * context instead of passing NULL. */\nvoid RM_FreeDict(RedisModuleCtx *ctx, RedisModuleDict *d) {\n    if (ctx != NULL) autoMemoryFreed(ctx,REDISMODULE_AM_DICT,d);\n    raxFree(d->rax);\n    zfree(d);\n}\n\n/* Return the size of the dictionary (number of keys). */\nuint64_t RM_DictSize(RedisModuleDict *d) {\n    return raxSize(d->rax);\n}\n\n/* Store the specified key into the dictionary, setting its value to the\n * pointer 'ptr'. If the key was added with success, since it did not\n * already exist, REDISMODULE_OK is returned. Otherwise if the key already\n * exists the function returns REDISMODULE_ERR. */\nint RM_DictSetC(RedisModuleDict *d, void *key, size_t keylen, void *ptr) {\n    int retval = raxTryInsert(d->rax,key,keylen,ptr,NULL);\n    return (retval == 1) ? REDISMODULE_OK : REDISMODULE_ERR;\n}\n\n/* Like RedisModule_DictSetC() but will replace the key with the new\n * value if the key already exists. */\nint RM_DictReplaceC(RedisModuleDict *d, void *key, size_t keylen, void *ptr) {\n    int retval = raxInsert(d->rax,key,keylen,ptr,NULL);\n    return (retval == 1) ? REDISMODULE_OK : REDISMODULE_ERR;\n}\n\n/* Like RedisModule_DictSetC() but takes the key as a RedisModuleString. */\nint RM_DictSet(RedisModuleDict *d, RedisModuleString *key, void *ptr) {\n    return RM_DictSetC(d,key->ptr,sdslen(key->ptr),ptr);\n}\n\n/* Like RedisModule_DictReplaceC() but takes the key as a RedisModuleString. */\nint RM_DictReplace(RedisModuleDict *d, RedisModuleString *key, void *ptr) {\n    return RM_DictReplaceC(d,key->ptr,sdslen(key->ptr),ptr);\n}\n\n/* Return the value stored at the specified key. The function returns NULL\n * both in the case the key does not exist, or if you actually stored\n * NULL at key. So, optionally, if the 'nokey' pointer is not NULL, it will\n * be set by reference to 1 if the key does not exist, or to 0 if the key\n * exists. */\nvoid *RM_DictGetC(RedisModuleDict *d, void *key, size_t keylen, int *nokey) {\n    void *res = raxFind(d->rax,key,keylen);\n    if (nokey) *nokey = (res == raxNotFound);\n    return (res == raxNotFound) ? NULL : res;\n}\n\n/* Like RedisModule_DictGetC() but takes the key as a RedisModuleString. */\nvoid *RM_DictGet(RedisModuleDict *d, RedisModuleString *key, int *nokey) {\n    return RM_DictGetC(d,key->ptr,sdslen(key->ptr),nokey);\n}\n\n/* Remove the specified key from the dictionary, returning REDISMODULE_OK if\n * the key was found and delted, or REDISMODULE_ERR if instead there was\n * no such key in the dictionary. When the operation is successful, if\n * 'oldval' is not NULL, then '*oldval' is set to the value stored at the\n * key before it was deleted. Using this feature it is possible to get\n * a pointer to the value (for instance in order to release it), without\n * having to call RedisModule_DictGet() before deleting the key. */\nint RM_DictDelC(RedisModuleDict *d, void *key, size_t keylen, void *oldval) {\n    int retval = raxRemove(d->rax,key,keylen,oldval);\n    return retval ? REDISMODULE_OK : REDISMODULE_ERR;\n}\n\n/* Like RedisModule_DictDelC() but gets the key as a RedisModuleString. */\nint RM_DictDel(RedisModuleDict *d, RedisModuleString *key, void *oldval) {\n    return RM_DictDelC(d,key->ptr,sdslen(key->ptr),oldval);\n}\n\n/* Return an interator, setup in order to start iterating from the specified\n * key by applying the operator 'op', which is just a string specifying the\n * comparison operator to use in order to seek the first element. The\n * operators avalable are:\n *\n * \"^\"   -- Seek the first (lexicographically smaller) key.\n * \"$\"   -- Seek the last  (lexicographically biffer) key.\n * \">\"   -- Seek the first element greter than the specified key.\n * \">=\"  -- Seek the first element greater or equal than the specified key.\n * \"<\"   -- Seek the first element smaller than the specified key.\n * \"<=\"  -- Seek the first element smaller or equal than the specified key.\n * \"==\"  -- Seek the first element matching exactly the specified key.\n *\n * Note that for \"^\" and \"$\" the passed key is not used, and the user may\n * just pass NULL with a length of 0.\n *\n * If the element to start the iteration cannot be seeked based on the\n * key and operator passed, RedisModule_DictNext() / Prev() will just return\n * REDISMODULE_ERR at the first call, otherwise they'll produce elements.\n */\nRedisModuleDictIter *RM_DictIteratorStartC(RedisModuleDict *d, const char *op, void *key, size_t keylen) {\n    RedisModuleDictIter *di = zmalloc(sizeof(*di));\n    di->dict = d;\n    raxStart(&di->ri,d->rax);\n    raxSeek(&di->ri,op,key,keylen);\n    return di;\n}\n\n/* Exactly like RedisModule_DictIteratorStartC, but the key is passed as a\n * RedisModuleString. */\nRedisModuleDictIter *RM_DictIteratorStart(RedisModuleDict *d, const char *op, RedisModuleString *key) {\n    return RM_DictIteratorStartC(d,op,key->ptr,sdslen(key->ptr));\n}\n\n/* Release the iterator created with RedisModule_DictIteratorStart(). This call\n * is mandatory otherwise a memory leak is introduced in the module. */\nvoid RM_DictIteratorStop(RedisModuleDictIter *di) {\n    raxStop(&di->ri);\n    zfree(di);\n}\n\n/* After its creation with RedisModule_DictIteratorStart(), it is possible to\n * change the currently selected element of the iterator by using this\n * API call. The result based on the operator and key is exactly like\n * the function RedisModule_DictIteratorStart(), however in this case the\n * return value is just REDISMODULE_OK in case the seeked element was found,\n * or REDISMODULE_ERR in case it was not possible to seek the specified\n * element. It is possible to reseek an iterator as many times as you want. */\nint RM_DictIteratorReseekC(RedisModuleDictIter *di, const char *op, void *key, size_t keylen) {\n    return raxSeek(&di->ri,op,key,keylen);\n}\n\n/* Like RedisModule_DictIteratorReseekC() but takes the key as as a\n * RedisModuleString. */\nint RM_DictIteratorReseek(RedisModuleDictIter *di, const char *op, RedisModuleString *key) {\n    return RM_DictIteratorReseekC(di,op,key->ptr,sdslen(key->ptr));\n}\n\n/* Return the current item of the dictionary iterator 'di' and steps to the\n * next element. If the iterator already yield the last element and there\n * are no other elements to return, NULL is returned, otherwise a pointer\n * to a string representing the key is provided, and the '*keylen' length\n * is set by reference (if keylen is not NULL). The '*dataptr', if not NULL\n * is set to the value of the pointer stored at the returned key as auxiliary\n * data (as set by the RedisModule_DictSet API).\n *\n * Usage example:\n *\n *      ... create the iterator here ...\n *      char *key;\n *      void *data;\n *      while((key = RedisModule_DictNextC(iter,&keylen,&data)) != NULL) {\n *          printf(\"%.*s %p\\n\", (int)keylen, key, data);\n *      }\n *\n * The returned pointer is of type void because sometimes it makes sense\n * to cast it to a char* sometimes to an unsigned char* depending on the\n * fact it contains or not binary data, so this API ends being more\n * comfortable to use.\n *\n * The validity of the returned pointer is until the next call to the\n * next/prev iterator step. Also the pointer is no longer valid once the\n * iterator is released. */\nvoid *RM_DictNextC(RedisModuleDictIter *di, size_t *keylen, void **dataptr) {\n    if (!raxNext(&di->ri)) return NULL;\n    if (keylen) *keylen = di->ri.key_len;\n    if (dataptr) *dataptr = di->ri.data;\n    return di->ri.key;\n}\n\n/* This function is exactly like RedisModule_DictNext() but after returning\n * the currently selected element in the iterator, it selects the previous\n * element (laxicographically smaller) instead of the next one. */\nvoid *RM_DictPrevC(RedisModuleDictIter *di, size_t *keylen, void **dataptr) {\n    if (!raxPrev(&di->ri)) return NULL;\n    if (keylen) *keylen = di->ri.key_len;\n    if (dataptr) *dataptr = di->ri.data;\n    return di->ri.key;\n}\n\n/* Like RedisModuleNextC(), but instead of returning an internally allocated\n * buffer and key length, it returns directly a module string object allocated\n * in the specified context 'ctx' (that may be NULL exactly like for the main\n * API RedisModule_CreateString).\n *\n * The returned string object should be deallocated after use, either manually\n * or by using a context that has automatic memory management active. */\nRedisModuleString *RM_DictNext(RedisModuleCtx *ctx, RedisModuleDictIter *di, void **dataptr) {\n    size_t keylen;\n    void *key = RM_DictNextC(di,&keylen,dataptr);\n    if (key == NULL) return NULL;\n    return RM_CreateString(ctx,key,keylen);\n}\n\n/* Like RedisModule_DictNext() but after returning the currently selected\n * element in the iterator, it selects the previous element (laxicographically\n * smaller) instead of the next one. */\nRedisModuleString *RM_DictPrev(RedisModuleCtx *ctx, RedisModuleDictIter *di, void **dataptr) {\n    size_t keylen;\n    void *key = RM_DictPrevC(di,&keylen,dataptr);\n    if (key == NULL) return NULL;\n    return RM_CreateString(ctx,key,keylen);\n}\n\n/* Compare the element currently pointed by the iterator to the specified\n * element given by key/keylen, according to the operator 'op' (the set of\n * valid operators are the same valid for RedisModule_DictIteratorStart).\n * If the comparision is successful the command returns REDISMODULE_OK\n * otherwise REDISMODULE_ERR is returned.\n *\n * This is useful when we want to just emit a lexicographical range, so\n * in the loop, as we iterate elements, we can also check if we are still\n * on range.\n *\n * The function returne REDISMODULE_ERR if the iterator reached the\n * end of elements condition as well. */\nint RM_DictCompareC(RedisModuleDictIter *di, const char *op, void *key, size_t keylen) {\n    if (raxEOF(&di->ri)) return REDISMODULE_ERR;\n    int res = raxCompare(&di->ri,op,key,keylen);\n    return res ? REDISMODULE_OK : REDISMODULE_ERR;\n}\n\n/* Like RedisModule_DictCompareC but gets the key to compare with the current\n * iterator key as a RedisModuleString. */\nint RM_DictCompare(RedisModuleDictIter *di, const char *op, RedisModuleString *key) {\n    if (raxEOF(&di->ri)) return REDISMODULE_ERR;\n    int res = raxCompare(&di->ri,op,key->ptr,sdslen(key->ptr));\n    return res ? REDISMODULE_OK : REDISMODULE_ERR;\n}\n\n/* --------------------------------------------------------------------------\n * Modules utility APIs\n * -------------------------------------------------------------------------- */\n\n/* Return random bytes using SHA1 in counter mode with a /dev/urandom\n * initialized seed. This function is fast so can be used to generate\n * many bytes without any effect on the operating system entropy pool.\n * Currently this function is not thread safe. */\nvoid RM_GetRandomBytes(unsigned char *dst, size_t len) {\n    getRandomBytes(dst,len);\n}\n\n/* Like RedisModule_GetRandomBytes() but instead of setting the string to\n * random bytes the string is set to random characters in the in the\n * hex charset [0-9a-f]. */\nvoid RM_GetRandomHexChars(char *dst, size_t len) {\n    getRandomHexChars(dst,len);\n}\n\n/* --------------------------------------------------------------------------\n * Modules API internals\n * -------------------------------------------------------------------------- */\n\n/* server.moduleapi dictionary type. Only uses plain C strings since\n * this gets queries from modules. */\n\nuint64_t dictCStringKeyHash(const void *key) {\n    return dictGenHashFunction((unsigned char*)key, strlen((char*)key));\n}\n\nint dictCStringKeyCompare(void *privdata, const void *key1, const void *key2) {\n    UNUSED(privdata);\n    return strcmp(key1,key2) == 0;\n}\n\ndictType moduleAPIDictType = {\n    dictCStringKeyHash,        /* hash function */\n    NULL,                      /* key dup */\n    NULL,                      /* val dup */\n    dictCStringKeyCompare,     /* key compare */\n    NULL,                      /* key destructor */\n    NULL                       /* val destructor */\n};\n\nint moduleRegisterApi(const char *funcname, void *funcptr) {\n    return dictAdd(server.moduleapi, (char*)funcname, funcptr);\n}\n\n#define REGISTER_API(name) \\\n    moduleRegisterApi(\"RedisModule_\" #name, (void *)(unsigned long)RM_ ## name)\n\n/* Global initialization at Redis startup. */\nvoid moduleRegisterCoreAPI(void);\n\nvoid moduleInitModulesSystem(void) {\n    moduleUnblockedClients = listCreate();\n    server.loadmodule_queue = listCreate();\n    modules = dictCreate(&modulesDictType,NULL);\n\n    /* Set up the keyspace notification susbscriber list and static client */\n    moduleKeyspaceSubscribers = listCreate();\n    moduleFreeContextReusedClient = createClient(-1);\n    moduleFreeContextReusedClient->flags |= CLIENT_MODULE;\n\n    moduleRegisterCoreAPI();\n    if (pipe(server.module_blocked_pipe) == -1) {\n        serverLog(LL_WARNING,\n            \"Can't create the pipe for module blocking commands: %s\",\n            strerror(errno));\n        exit(1);\n    }\n    /* Make the pipe non blocking. This is just a best effort aware mechanism\n     * and we do not want to block not in the read nor in the write half. */\n    anetNonBlock(NULL,server.module_blocked_pipe[0]);\n    anetNonBlock(NULL,server.module_blocked_pipe[1]);\n\n    /* Create the timers radix tree. */\n    Timers = raxNew();\n\n    /* Our thread-safe contexts GIL must start with already locked:\n     * it is just unlocked when it's safe. */\n    pthread_mutex_lock(&moduleGIL);\n}\n\n/* Load all the modules in the server.loadmodule_queue list, which is\n * populated by `loadmodule` directives in the configuration file.\n * We can't load modules directly when processing the configuration file\n * because the server must be fully initialized before loading modules.\n *\n * The function aborts the server on errors, since to start with missing\n * modules is not considered sane: clients may rely on the existence of\n * given commands, loading AOF also may need some modules to exist, and\n * if this instance is a slave, it must understand commands from master. */\nvoid moduleLoadFromQueue(void) {\n    listIter li;\n    listNode *ln;\n\n    listRewind(server.loadmodule_queue,&li);\n    while((ln = listNext(&li))) {\n        struct moduleLoadQueueEntry *loadmod = ln->value;\n        if (moduleLoad(loadmod->path,(void **)loadmod->argv,loadmod->argc)\n            == C_ERR)\n        {\n            serverLog(LL_WARNING,\n                \"Can't load module from %s: server aborting\",\n                loadmod->path);\n            exit(1);\n        }\n    }\n}\n\nvoid moduleFreeModuleStructure(struct RedisModule *module) {\n    listRelease(module->types);\n    sdsfree(module->name);\n    zfree(module);\n}\n\nvoid moduleUnregisterCommands(struct RedisModule *module) {\n    /* Unregister all the commands registered by this module. */\n    dictIterator *di = dictGetSafeIterator(server.commands);\n    dictEntry *de;\n    while ((de = dictNext(di)) != NULL) {\n        struct redisCommand *cmd = dictGetVal(de);\n        if (cmd->proc == RedisModuleCommandDispatcher) {\n            RedisModuleCommandProxy *cp =\n                (void*)(unsigned long)cmd->getkeys_proc;\n            sds cmdname = cp->rediscmd->name;\n            if (cp->module == module) {\n                dictDelete(server.commands,cmdname);\n                dictDelete(server.orig_commands,cmdname);\n                sdsfree(cmdname);\n                zfree(cp->rediscmd);\n                zfree(cp);\n            }\n        }\n    }\n    dictReleaseIterator(di);\n}\n\n/* Load a module and initialize it. On success C_OK is returned, otherwise\n * C_ERR is returned. */\nint moduleLoad(const char *path, void **module_argv, int module_argc) {\n    int (*onload)(void *, void **, int);\n    void *handle;\n    RedisModuleCtx ctx = REDISMODULE_CTX_INIT;\n\n    handle = dlopen(path,RTLD_NOW|RTLD_LOCAL);\n    if (handle == NULL) {\n        serverLog(LL_WARNING, \"Module %s failed to load: %s\", path, dlerror());\n        return C_ERR;\n    }\n    onload = (int (*)(void *, void **, int))(unsigned long) dlsym(handle,\"RedisModule_OnLoad\");\n    if (onload == NULL) {\n        dlclose(handle);\n        serverLog(LL_WARNING,\n            \"Module %s does not export RedisModule_OnLoad() \"\n            \"symbol. Module not loaded.\",path);\n        return C_ERR;\n    }\n    if (onload((void*)&ctx,module_argv,module_argc) == REDISMODULE_ERR) {\n        if (ctx.module) {\n            moduleUnregisterCommands(ctx.module);\n            moduleFreeModuleStructure(ctx.module);\n        }\n        dlclose(handle);\n        serverLog(LL_WARNING,\n            \"Module %s initialization failed. Module not loaded\",path);\n        return C_ERR;\n    }\n\n    /* Redis module loaded! Register it. */\n    dictAdd(modules,ctx.module->name,ctx.module);\n    ctx.module->handle = handle;\n    serverLog(LL_NOTICE,\"Module '%s' loaded from %s\",ctx.module->name,path);\n    moduleFreeContext(&ctx);\n    return C_OK;\n}\n\n\n/* Unload the module registered with the specified name. On success\n * C_OK is returned, otherwise C_ERR is returned and errno is set\n * to the following values depending on the type of error:\n *\n * * ENONET: No such module having the specified name.\n * * EBUSY: The module exports a new data type and can only be reloaded. */\nint moduleUnload(sds name) {\n    struct RedisModule *module = dictFetchValue(modules,name);\n\n    if (module == NULL) {\n        errno = ENOENT;\n        return REDISMODULE_ERR;\n    }\n\n    if (listLength(module->types)) {\n        errno = EBUSY;\n        return REDISMODULE_ERR;\n    }\n\n    moduleUnregisterCommands(module);\n\n    /* Remove any notification subscribers this module might have */\n    moduleUnsubscribeNotifications(module);\n\n    /* Unregister all the hooks. TODO: Yet no hooks support here. */\n\n    /* Unload the dynamic library. */\n    if (dlclose(module->handle) == -1) {\n        char *error = dlerror();\n        if (error == NULL) error = \"Unknown error\";\n        serverLog(LL_WARNING,\"Error when trying to close the %s module: %s\",\n            module->name, error);\n    }\n\n    /* Remove from list of modules. */\n    serverLog(LL_NOTICE,\"Module %s unloaded\",module->name);\n    dictDelete(modules,module->name);\n    module->name = NULL; /* The name was already freed by dictDelete(). */\n    moduleFreeModuleStructure(module);\n\n    return REDISMODULE_OK;\n}\n\n/* Redis MODULE command.\n *\n * MODULE LOAD <path> [args...] */\nvoid moduleCommand(client *c) {\n    char *subcmd = c->argv[1]->ptr;\n    if (c->argc == 2 && !strcasecmp(subcmd,\"help\")) {\n        const char *help[] = {\n\"LIST -- Return a list of loaded modules.\",\n\"LOAD <path> [arg ...] -- Load a module library from <path>.\",\n\"UNLOAD <name> -- Unload a module.\",\nNULL\n        };\n        addReplyHelp(c, help);\n    } else\n    if (!strcasecmp(subcmd,\"load\") && c->argc >= 3) {\n        robj **argv = NULL;\n        int argc = 0;\n\n        if (c->argc > 3) {\n            argc = c->argc - 3;\n            argv = &c->argv[3];\n        }\n\n        if (moduleLoad(c->argv[2]->ptr,(void **)argv,argc) == C_OK)\n            addReply(c,shared.ok);\n        else\n            addReplyError(c,\n                \"Error loading the extension. Please check the server logs.\");\n    } else if (!strcasecmp(subcmd,\"unload\") && c->argc == 3) {\n        if (moduleUnload(c->argv[2]->ptr) == C_OK)\n            addReply(c,shared.ok);\n        else {\n            char *errmsg;\n            switch(errno) {\n            case ENOENT:\n                errmsg = \"no such module with that name\";\n                break;\n            case EBUSY:\n                errmsg = \"the module exports one or more module-side data types, can't unload\";\n                break;\n            default:\n                errmsg = \"operation not possible.\";\n                break;\n            }\n            addReplyErrorFormat(c,\"Error unloading module: %s\",errmsg);\n        }\n    } else if (!strcasecmp(subcmd,\"list\") && c->argc == 2) {\n        dictIterator *di = dictGetIterator(modules);\n        dictEntry *de;\n\n        addReplyMultiBulkLen(c,dictSize(modules));\n        while ((de = dictNext(di)) != NULL) {\n            sds name = dictGetKey(de);\n            struct RedisModule *module = dictGetVal(de);\n            addReplyMultiBulkLen(c,4);\n            addReplyBulkCString(c,\"name\");\n            addReplyBulkCBuffer(c,name,sdslen(name));\n            addReplyBulkCString(c,\"ver\");\n            addReplyLongLong(c,module->ver);\n        }\n        dictReleaseIterator(di);\n    } else {\n        addReplySubcommandSyntaxError(c);\n        return;\n    }\n}\n\n/* Return the number of registered modules. */\nsize_t moduleCount(void) {\n    return dictSize(modules);\n}\n\n/* Register all the APIs we export. Keep this function at the end of the\n * file so that's easy to seek it to add new entries. */\nvoid moduleRegisterCoreAPI(void) {\n    server.moduleapi = dictCreate(&moduleAPIDictType,NULL);\n    REGISTER_API(Alloc);\n    REGISTER_API(Calloc);\n    REGISTER_API(Realloc);\n    REGISTER_API(Free);\n    REGISTER_API(Strdup);\n    REGISTER_API(CreateCommand);\n    REGISTER_API(SetModuleAttribs);\n    REGISTER_API(IsModuleNameBusy);\n    REGISTER_API(WrongArity);\n    REGISTER_API(ReplyWithLongLong);\n    REGISTER_API(ReplyWithError);\n    REGISTER_API(ReplyWithSimpleString);\n    REGISTER_API(ReplyWithArray);\n    REGISTER_API(ReplySetArrayLength);\n    REGISTER_API(ReplyWithString);\n    REGISTER_API(ReplyWithStringBuffer);\n    REGISTER_API(ReplyWithNull);\n    REGISTER_API(ReplyWithCallReply);\n    REGISTER_API(ReplyWithDouble);\n    REGISTER_API(GetSelectedDb);\n    REGISTER_API(SelectDb);\n    REGISTER_API(OpenKey);\n    REGISTER_API(CloseKey);\n    REGISTER_API(KeyType);\n    REGISTER_API(ValueLength);\n    REGISTER_API(ListPush);\n    REGISTER_API(ListPop);\n    REGISTER_API(StringToLongLong);\n    REGISTER_API(StringToDouble);\n    REGISTER_API(Call);\n    REGISTER_API(CallReplyProto);\n    REGISTER_API(FreeCallReply);\n    REGISTER_API(CallReplyInteger);\n    REGISTER_API(CallReplyType);\n    REGISTER_API(CallReplyLength);\n    REGISTER_API(CallReplyArrayElement);\n    REGISTER_API(CallReplyStringPtr);\n    REGISTER_API(CreateStringFromCallReply);\n    REGISTER_API(CreateString);\n    REGISTER_API(CreateStringFromLongLong);\n    REGISTER_API(CreateStringFromString);\n    REGISTER_API(CreateStringPrintf);\n    REGISTER_API(FreeString);\n    REGISTER_API(StringPtrLen);\n    REGISTER_API(AutoMemory);\n    REGISTER_API(Replicate);\n    REGISTER_API(ReplicateVerbatim);\n    REGISTER_API(DeleteKey);\n    REGISTER_API(UnlinkKey);\n    REGISTER_API(StringSet);\n    REGISTER_API(StringDMA);\n    REGISTER_API(StringTruncate);\n    REGISTER_API(SetExpire);\n    REGISTER_API(GetExpire);\n    REGISTER_API(ZsetAdd);\n    REGISTER_API(ZsetIncrby);\n    REGISTER_API(ZsetScore);\n    REGISTER_API(ZsetRem);\n    REGISTER_API(ZsetRangeStop);\n    REGISTER_API(ZsetFirstInScoreRange);\n    REGISTER_API(ZsetLastInScoreRange);\n    REGISTER_API(ZsetFirstInLexRange);\n    REGISTER_API(ZsetLastInLexRange);\n    REGISTER_API(ZsetRangeCurrentElement);\n    REGISTER_API(ZsetRangeNext);\n    REGISTER_API(ZsetRangePrev);\n    REGISTER_API(ZsetRangeEndReached);\n    REGISTER_API(HashSet);\n    REGISTER_API(HashGet);\n    REGISTER_API(IsKeysPositionRequest);\n    REGISTER_API(KeyAtPos);\n    REGISTER_API(GetClientId);\n    REGISTER_API(GetContextFlags);\n    REGISTER_API(PoolAlloc);\n    REGISTER_API(CreateDataType);\n    REGISTER_API(ModuleTypeSetValue);\n    REGISTER_API(ModuleTypeGetType);\n    REGISTER_API(ModuleTypeGetValue);\n    REGISTER_API(SaveUnsigned);\n    REGISTER_API(LoadUnsigned);\n    REGISTER_API(SaveSigned);\n    REGISTER_API(LoadSigned);\n    REGISTER_API(SaveString);\n    REGISTER_API(SaveStringBuffer);\n    REGISTER_API(LoadString);\n    REGISTER_API(LoadStringBuffer);\n    REGISTER_API(SaveDouble);\n    REGISTER_API(LoadDouble);\n    REGISTER_API(SaveFloat);\n    REGISTER_API(LoadFloat);\n    REGISTER_API(EmitAOF);\n    REGISTER_API(Log);\n    REGISTER_API(LogIOError);\n    REGISTER_API(StringAppendBuffer);\n    REGISTER_API(RetainString);\n    REGISTER_API(StringCompare);\n    REGISTER_API(GetContextFromIO);\n    REGISTER_API(BlockClient);\n    REGISTER_API(UnblockClient);\n    REGISTER_API(IsBlockedReplyRequest);\n    REGISTER_API(IsBlockedTimeoutRequest);\n    REGISTER_API(GetBlockedClientPrivateData);\n    REGISTER_API(AbortBlock);\n    REGISTER_API(Milliseconds);\n    REGISTER_API(GetThreadSafeContext);\n    REGISTER_API(FreeThreadSafeContext);\n    REGISTER_API(ThreadSafeContextLock);\n    REGISTER_API(ThreadSafeContextUnlock);\n    REGISTER_API(DigestAddStringBuffer);\n    REGISTER_API(DigestAddLongLong);\n    REGISTER_API(DigestEndSequence);\n    REGISTER_API(SubscribeToKeyspaceEvents);\n    REGISTER_API(RegisterClusterMessageReceiver);\n    REGISTER_API(SendClusterMessage);\n    REGISTER_API(GetClusterNodeInfo);\n    REGISTER_API(GetClusterNodesList);\n    REGISTER_API(FreeClusterNodesList);\n    REGISTER_API(CreateTimer);\n    REGISTER_API(StopTimer);\n    REGISTER_API(GetTimerInfo);\n    REGISTER_API(GetMyClusterID);\n    REGISTER_API(GetClusterSize);\n    REGISTER_API(GetRandomBytes);\n    REGISTER_API(GetRandomHexChars);\n    REGISTER_API(BlockedClientDisconnected);\n    REGISTER_API(SetDisconnectCallback);\n    REGISTER_API(GetBlockedClientHandle);\n    REGISTER_API(SetClusterFlags);\n    REGISTER_API(CreateDict);\n    REGISTER_API(FreeDict);\n    REGISTER_API(DictSize);\n    REGISTER_API(DictSetC);\n    REGISTER_API(DictReplaceC);\n    REGISTER_API(DictSet);\n    REGISTER_API(DictReplace);\n    REGISTER_API(DictGetC);\n    REGISTER_API(DictGet);\n    REGISTER_API(DictDelC);\n    REGISTER_API(DictDel);\n    REGISTER_API(DictIteratorStartC);\n    REGISTER_API(DictIteratorStart);\n    REGISTER_API(DictIteratorStop);\n    REGISTER_API(DictIteratorReseekC);\n    REGISTER_API(DictIteratorReseek);\n    REGISTER_API(DictNextC);\n    REGISTER_API(DictPrevC);\n    REGISTER_API(DictNext);\n    REGISTER_API(DictPrev);\n    REGISTER_API(DictCompareC);\n    REGISTER_API(DictCompare);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-redis-5.0.1-gykpygjr4nuvp2gxloszw6ksswcpsjes/spack-src/deps/lua/src/loadlib.c": "/*\n** $Id: loadlib.c,v 1.52.1.4 2009/09/09 13:17:16 roberto Exp $\n** Dynamic library loader for Lua\n** See Copyright Notice in lua.h\n**\n** This module contains an implementation of loadlib for Unix systems\n** that have dlfcn, an implementation for Darwin (Mac OS X), an\n** implementation for Windows, and a stub for other systems.\n*/\n\n\n#include <stdlib.h>\n#include <string.h>\n\n\n#define loadlib_c\n#define LUA_LIB\n\n#include \"lua.h\"\n\n#include \"lauxlib.h\"\n#include \"lualib.h\"\n\n\n/* prefix for open functions in C libraries */\n#define LUA_POF\t\t\"luaopen_\"\n\n/* separator for open functions in C libraries */\n#define LUA_OFSEP\t\"_\"\n\n\n#define LIBPREFIX\t\"LOADLIB: \"\n\n#define POF\t\tLUA_POF\n#define LIB_FAIL\t\"open\"\n\n\n/* error codes for ll_loadfunc */\n#define ERRLIB\t\t1\n#define ERRFUNC\t\t2\n\n#define setprogdir(L)\t\t((void)0)\n\n\nstatic void ll_unloadlib (void *lib);\nstatic void *ll_load (lua_State *L, const char *path);\nstatic lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym);\n\n\n\n#if defined(LUA_DL_DLOPEN)\n/*\n** {========================================================================\n** This is an implementation of loadlib based on the dlfcn interface.\n** The dlfcn interface is available in Linux, SunOS, Solaris, IRIX, FreeBSD,\n** NetBSD, AIX 4.2, HPUX 11, and  probably most other Unix flavors, at least\n** as an emulation layer on top of native functions.\n** =========================================================================\n*/\n\n#include <dlfcn.h>\n\nstatic void ll_unloadlib (void *lib) {\n  dlclose(lib);\n}\n\n\nstatic void *ll_load (lua_State *L, const char *path) {\n  void *lib = dlopen(path, RTLD_NOW);\n  if (lib == NULL) lua_pushstring(L, dlerror());\n  return lib;\n}\n\n\nstatic lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {\n  lua_CFunction f = (lua_CFunction)dlsym(lib, sym);\n  if (f == NULL) lua_pushstring(L, dlerror());\n  return f;\n}\n\n/* }====================================================== */\n\n\n\n#elif defined(LUA_DL_DLL)\n/*\n** {======================================================================\n** This is an implementation of loadlib for Windows using native functions.\n** =======================================================================\n*/\n\n#include <windows.h>\n\n\n#undef setprogdir\n\nstatic void setprogdir (lua_State *L) {\n  char buff[MAX_PATH + 1];\n  char *lb;\n  DWORD nsize = sizeof(buff)/sizeof(char);\n  DWORD n = GetModuleFileNameA(NULL, buff, nsize);\n  if (n == 0 || n == nsize || (lb = strrchr(buff, '\\\\')) == NULL)\n    luaL_error(L, \"unable to get ModuleFileName\");\n  else {\n    *lb = '\\0';\n    luaL_gsub(L, lua_tostring(L, -1), LUA_EXECDIR, buff);\n    lua_remove(L, -2);  /* remove original string */\n  }\n}\n\n\nstatic void pusherror (lua_State *L) {\n  int error = GetLastError();\n  char buffer[128];\n  if (FormatMessageA(FORMAT_MESSAGE_IGNORE_INSERTS | FORMAT_MESSAGE_FROM_SYSTEM,\n      NULL, error, 0, buffer, sizeof(buffer), NULL))\n    lua_pushstring(L, buffer);\n  else\n    lua_pushfstring(L, \"system error %d\\n\", error);\n}\n\nstatic void ll_unloadlib (void *lib) {\n  FreeLibrary((HINSTANCE)lib);\n}\n\n\nstatic void *ll_load (lua_State *L, const char *path) {\n  HINSTANCE lib = LoadLibraryA(path);\n  if (lib == NULL) pusherror(L);\n  return lib;\n}\n\n\nstatic lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {\n  lua_CFunction f = (lua_CFunction)GetProcAddress((HINSTANCE)lib, sym);\n  if (f == NULL) pusherror(L);\n  return f;\n}\n\n/* }====================================================== */\n\n\n\n#elif defined(LUA_DL_DYLD)\n/*\n** {======================================================================\n** Native Mac OS X / Darwin Implementation\n** =======================================================================\n*/\n\n#include <mach-o/dyld.h>\n\n\n/* Mac appends a `_' before C function names */\n#undef POF\n#define POF\t\"_\" LUA_POF\n\n\nstatic void pusherror (lua_State *L) {\n  const char *err_str;\n  const char *err_file;\n  NSLinkEditErrors err;\n  int err_num;\n  NSLinkEditError(&err, &err_num, &err_file, &err_str);\n  lua_pushstring(L, err_str);\n}\n\n\nstatic const char *errorfromcode (NSObjectFileImageReturnCode ret) {\n  switch (ret) {\n    case NSObjectFileImageInappropriateFile:\n      return \"file is not a bundle\";\n    case NSObjectFileImageArch:\n      return \"library is for wrong CPU type\";\n    case NSObjectFileImageFormat:\n      return \"bad format\";\n    case NSObjectFileImageAccess:\n      return \"cannot access file\";\n    case NSObjectFileImageFailure:\n    default:\n      return \"unable to load library\";\n  }\n}\n\n\nstatic void ll_unloadlib (void *lib) {\n  NSUnLinkModule((NSModule)lib, NSUNLINKMODULE_OPTION_RESET_LAZY_REFERENCES);\n}\n\n\nstatic void *ll_load (lua_State *L, const char *path) {\n  NSObjectFileImage img;\n  NSObjectFileImageReturnCode ret;\n  /* this would be a rare case, but prevents crashing if it happens */\n  if(!_dyld_present()) {\n    lua_pushliteral(L, \"dyld not present\");\n    return NULL;\n  }\n  ret = NSCreateObjectFileImageFromFile(path, &img);\n  if (ret == NSObjectFileImageSuccess) {\n    NSModule mod = NSLinkModule(img, path, NSLINKMODULE_OPTION_PRIVATE |\n                       NSLINKMODULE_OPTION_RETURN_ON_ERROR);\n    NSDestroyObjectFileImage(img);\n    if (mod == NULL) pusherror(L);\n    return mod;\n  }\n  lua_pushstring(L, errorfromcode(ret));\n  return NULL;\n}\n\n\nstatic lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {\n  NSSymbol nss = NSLookupSymbolInModule((NSModule)lib, sym);\n  if (nss == NULL) {\n    lua_pushfstring(L, \"symbol \" LUA_QS \" not found\", sym);\n    return NULL;\n  }\n  return (lua_CFunction)NSAddressOfSymbol(nss);\n}\n\n/* }====================================================== */\n\n\n\n#else\n/*\n** {======================================================\n** Fallback for other systems\n** =======================================================\n*/\n\n#undef LIB_FAIL\n#define LIB_FAIL\t\"absent\"\n\n\n#define DLMSG\t\"dynamic libraries not enabled; check your Lua installation\"\n\n\nstatic void ll_unloadlib (void *lib) {\n  (void)lib;  /* to avoid warnings */\n}\n\n\nstatic void *ll_load (lua_State *L, const char *path) {\n  (void)path;  /* to avoid warnings */\n  lua_pushliteral(L, DLMSG);\n  return NULL;\n}\n\n\nstatic lua_CFunction ll_sym (lua_State *L, void *lib, const char *sym) {\n  (void)lib; (void)sym;  /* to avoid warnings */\n  lua_pushliteral(L, DLMSG);\n  return NULL;\n}\n\n/* }====================================================== */\n#endif\n\n\n\nstatic void **ll_register (lua_State *L, const char *path) {\n  void **plib;\n  lua_pushfstring(L, \"%s%s\", LIBPREFIX, path);\n  lua_gettable(L, LUA_REGISTRYINDEX);  /* check library in registry? */\n  if (!lua_isnil(L, -1))  /* is there an entry? */\n    plib = (void **)lua_touserdata(L, -1);\n  else {  /* no entry yet; create one */\n    lua_pop(L, 1);\n    plib = (void **)lua_newuserdata(L, sizeof(const void *));\n    *plib = NULL;\n    luaL_getmetatable(L, \"_LOADLIB\");\n    lua_setmetatable(L, -2);\n    lua_pushfstring(L, \"%s%s\", LIBPREFIX, path);\n    lua_pushvalue(L, -2);\n    lua_settable(L, LUA_REGISTRYINDEX);\n  }\n  return plib;\n}\n\n\n/*\n** __gc tag method: calls library's `ll_unloadlib' function with the lib\n** handle\n*/\nstatic int gctm (lua_State *L) {\n  void **lib = (void **)luaL_checkudata(L, 1, \"_LOADLIB\");\n  if (*lib) ll_unloadlib(*lib);\n  *lib = NULL;  /* mark library as closed */\n  return 0;\n}\n\n\nstatic int ll_loadfunc (lua_State *L, const char *path, const char *sym) {\n  void **reg = ll_register(L, path);\n  if (*reg == NULL) *reg = ll_load(L, path);\n  if (*reg == NULL)\n    return ERRLIB;  /* unable to load library */\n  else {\n    lua_CFunction f = ll_sym(L, *reg, sym);\n    if (f == NULL)\n      return ERRFUNC;  /* unable to find function */\n    lua_pushcfunction(L, f);\n    return 0;  /* return function */\n  }\n}\n\n\nstatic int ll_loadlib (lua_State *L) {\n  const char *path = luaL_checkstring(L, 1);\n  const char *init = luaL_checkstring(L, 2);\n  int stat = ll_loadfunc(L, path, init);\n  if (stat == 0)  /* no errors? */\n    return 1;  /* return the loaded function */\n  else {  /* error; error message is on stack top */\n    lua_pushnil(L);\n    lua_insert(L, -2);\n    lua_pushstring(L, (stat == ERRLIB) ?  LIB_FAIL : \"init\");\n    return 3;  /* return nil, error message, and where */\n  }\n}\n\n\n\n/*\n** {======================================================\n** 'require' function\n** =======================================================\n*/\n\n\nstatic int readable (const char *filename) {\n  FILE *f = fopen(filename, \"r\");  /* try to open file */\n  if (f == NULL) return 0;  /* open failed */\n  fclose(f);\n  return 1;\n}\n\n\nstatic const char *pushnexttemplate (lua_State *L, const char *path) {\n  const char *l;\n  while (*path == *LUA_PATHSEP) path++;  /* skip separators */\n  if (*path == '\\0') return NULL;  /* no more templates */\n  l = strchr(path, *LUA_PATHSEP);  /* find next separator */\n  if (l == NULL) l = path + strlen(path);\n  lua_pushlstring(L, path, l - path);  /* template */\n  return l;\n}\n\n\nstatic const char *findfile (lua_State *L, const char *name,\n                                           const char *pname) {\n  const char *path;\n  name = luaL_gsub(L, name, \".\", LUA_DIRSEP);\n  lua_getfield(L, LUA_ENVIRONINDEX, pname);\n  path = lua_tostring(L, -1);\n  if (path == NULL)\n    luaL_error(L, LUA_QL(\"package.%s\") \" must be a string\", pname);\n  lua_pushliteral(L, \"\");  /* error accumulator */\n  while ((path = pushnexttemplate(L, path)) != NULL) {\n    const char *filename;\n    filename = luaL_gsub(L, lua_tostring(L, -1), LUA_PATH_MARK, name);\n    lua_remove(L, -2);  /* remove path template */\n    if (readable(filename))  /* does file exist and is readable? */\n      return filename;  /* return that file name */\n    lua_pushfstring(L, \"\\n\\tno file \" LUA_QS, filename);\n    lua_remove(L, -2);  /* remove file name */\n    lua_concat(L, 2);  /* add entry to possible error message */\n  }\n  return NULL;  /* not found */\n}\n\n\nstatic void loaderror (lua_State *L, const char *filename) {\n  luaL_error(L, \"error loading module \" LUA_QS \" from file \" LUA_QS \":\\n\\t%s\",\n                lua_tostring(L, 1), filename, lua_tostring(L, -1));\n}\n\n\nstatic int loader_Lua (lua_State *L) {\n  const char *filename;\n  const char *name = luaL_checkstring(L, 1);\n  filename = findfile(L, name, \"path\");\n  if (filename == NULL) return 1;  /* library not found in this path */\n  if (luaL_loadfile(L, filename) != 0)\n    loaderror(L, filename);\n  return 1;  /* library loaded successfully */\n}\n\n\nstatic const char *mkfuncname (lua_State *L, const char *modname) {\n  const char *funcname;\n  const char *mark = strchr(modname, *LUA_IGMARK);\n  if (mark) modname = mark + 1;\n  funcname = luaL_gsub(L, modname, \".\", LUA_OFSEP);\n  funcname = lua_pushfstring(L, POF\"%s\", funcname);\n  lua_remove(L, -2);  /* remove 'gsub' result */\n  return funcname;\n}\n\n\nstatic int loader_C (lua_State *L) {\n  const char *funcname;\n  const char *name = luaL_checkstring(L, 1);\n  const char *filename = findfile(L, name, \"cpath\");\n  if (filename == NULL) return 1;  /* library not found in this path */\n  funcname = mkfuncname(L, name);\n  if (ll_loadfunc(L, filename, funcname) != 0)\n    loaderror(L, filename);\n  return 1;  /* library loaded successfully */\n}\n\n\nstatic int loader_Croot (lua_State *L) {\n  const char *funcname;\n  const char *filename;\n  const char *name = luaL_checkstring(L, 1);\n  const char *p = strchr(name, '.');\n  int stat;\n  if (p == NULL) return 0;  /* is root */\n  lua_pushlstring(L, name, p - name);\n  filename = findfile(L, lua_tostring(L, -1), \"cpath\");\n  if (filename == NULL) return 1;  /* root not found */\n  funcname = mkfuncname(L, name);\n  if ((stat = ll_loadfunc(L, filename, funcname)) != 0) {\n    if (stat != ERRFUNC) loaderror(L, filename);  /* real error */\n    lua_pushfstring(L, \"\\n\\tno module \" LUA_QS \" in file \" LUA_QS,\n                       name, filename);\n    return 1;  /* function not found */\n  }\n  return 1;\n}\n\n\nstatic int loader_preload (lua_State *L) {\n  const char *name = luaL_checkstring(L, 1);\n  lua_getfield(L, LUA_ENVIRONINDEX, \"preload\");\n  if (!lua_istable(L, -1))\n    luaL_error(L, LUA_QL(\"package.preload\") \" must be a table\");\n  lua_getfield(L, -1, name);\n  if (lua_isnil(L, -1))  /* not found? */\n    lua_pushfstring(L, \"\\n\\tno field package.preload['%s']\", name);\n  return 1;\n}\n\n\nstatic const int sentinel_ = 0;\n#define sentinel\t((void *)&sentinel_)\n\n\nstatic int ll_require (lua_State *L) {\n  const char *name = luaL_checkstring(L, 1);\n  int i;\n  lua_settop(L, 1);  /* _LOADED table will be at index 2 */\n  lua_getfield(L, LUA_REGISTRYINDEX, \"_LOADED\");\n  lua_getfield(L, 2, name);\n  if (lua_toboolean(L, -1)) {  /* is it there? */\n    if (lua_touserdata(L, -1) == sentinel)  /* check loops */\n      luaL_error(L, \"loop or previous error loading module \" LUA_QS, name);\n    return 1;  /* package is already loaded */\n  }\n  /* else must load it; iterate over available loaders */\n  lua_getfield(L, LUA_ENVIRONINDEX, \"loaders\");\n  if (!lua_istable(L, -1))\n    luaL_error(L, LUA_QL(\"package.loaders\") \" must be a table\");\n  lua_pushliteral(L, \"\");  /* error message accumulator */\n  for (i=1; ; i++) {\n    lua_rawgeti(L, -2, i);  /* get a loader */\n    if (lua_isnil(L, -1))\n      luaL_error(L, \"module \" LUA_QS \" not found:%s\",\n                    name, lua_tostring(L, -2));\n    lua_pushstring(L, name);\n    lua_call(L, 1, 1);  /* call it */\n    if (lua_isfunction(L, -1))  /* did it find module? */\n      break;  /* module loaded successfully */\n    else if (lua_isstring(L, -1))  /* loader returned error message? */\n      lua_concat(L, 2);  /* accumulate it */\n    else\n      lua_pop(L, 1);\n  }\n  lua_pushlightuserdata(L, sentinel);\n  lua_setfield(L, 2, name);  /* _LOADED[name] = sentinel */\n  lua_pushstring(L, name);  /* pass name as argument to module */\n  lua_call(L, 1, 1);  /* run loaded module */\n  if (!lua_isnil(L, -1))  /* non-nil return? */\n    lua_setfield(L, 2, name);  /* _LOADED[name] = returned value */\n  lua_getfield(L, 2, name);\n  if (lua_touserdata(L, -1) == sentinel) {   /* module did not set a value? */\n    lua_pushboolean(L, 1);  /* use true as result */\n    lua_pushvalue(L, -1);  /* extra copy to be returned */\n    lua_setfield(L, 2, name);  /* _LOADED[name] = true */\n  }\n  return 1;\n}\n\n/* }====================================================== */\n\n\n\n/*\n** {======================================================\n** 'module' function\n** =======================================================\n*/\n  \n\nstatic void setfenv (lua_State *L) {\n  lua_Debug ar;\n  if (lua_getstack(L, 1, &ar) == 0 ||\n      lua_getinfo(L, \"f\", &ar) == 0 ||  /* get calling function */\n      lua_iscfunction(L, -1))\n    luaL_error(L, LUA_QL(\"module\") \" not called from a Lua function\");\n  lua_pushvalue(L, -2);\n  lua_setfenv(L, -2);\n  lua_pop(L, 1);\n}\n\n\nstatic void dooptions (lua_State *L, int n) {\n  int i;\n  for (i = 2; i <= n; i++) {\n    lua_pushvalue(L, i);  /* get option (a function) */\n    lua_pushvalue(L, -2);  /* module */\n    lua_call(L, 1, 0);\n  }\n}\n\n\nstatic void modinit (lua_State *L, const char *modname) {\n  const char *dot;\n  lua_pushvalue(L, -1);\n  lua_setfield(L, -2, \"_M\");  /* module._M = module */\n  lua_pushstring(L, modname);\n  lua_setfield(L, -2, \"_NAME\");\n  dot = strrchr(modname, '.');  /* look for last dot in module name */\n  if (dot == NULL) dot = modname;\n  else dot++;\n  /* set _PACKAGE as package name (full module name minus last part) */\n  lua_pushlstring(L, modname, dot - modname);\n  lua_setfield(L, -2, \"_PACKAGE\");\n}\n\n\nstatic int ll_module (lua_State *L) {\n  const char *modname = luaL_checkstring(L, 1);\n  int loaded = lua_gettop(L) + 1;  /* index of _LOADED table */\n  lua_getfield(L, LUA_REGISTRYINDEX, \"_LOADED\");\n  lua_getfield(L, loaded, modname);  /* get _LOADED[modname] */\n  if (!lua_istable(L, -1)) {  /* not found? */\n    lua_pop(L, 1);  /* remove previous result */\n    /* try global variable (and create one if it does not exist) */\n    if (luaL_findtable(L, LUA_GLOBALSINDEX, modname, 1) != NULL)\n      return luaL_error(L, \"name conflict for module \" LUA_QS, modname);\n    lua_pushvalue(L, -1);\n    lua_setfield(L, loaded, modname);  /* _LOADED[modname] = new table */\n  }\n  /* check whether table already has a _NAME field */\n  lua_getfield(L, -1, \"_NAME\");\n  if (!lua_isnil(L, -1))  /* is table an initialized module? */\n    lua_pop(L, 1);\n  else {  /* no; initialize it */\n    lua_pop(L, 1);\n    modinit(L, modname);\n  }\n  lua_pushvalue(L, -1);\n  setfenv(L);\n  dooptions(L, loaded - 1);\n  return 0;\n}\n\n\nstatic int ll_seeall (lua_State *L) {\n  luaL_checktype(L, 1, LUA_TTABLE);\n  if (!lua_getmetatable(L, 1)) {\n    lua_createtable(L, 0, 1); /* create new metatable */\n    lua_pushvalue(L, -1);\n    lua_setmetatable(L, 1);\n  }\n  lua_pushvalue(L, LUA_GLOBALSINDEX);\n  lua_setfield(L, -2, \"__index\");  /* mt.__index = _G */\n  return 0;\n}\n\n\n/* }====================================================== */\n\n\n\n/* auxiliary mark (for internal use) */\n#define AUXMARK\t\t\"\\1\"\n\nstatic void setpath (lua_State *L, const char *fieldname, const char *envname,\n                                   const char *def) {\n  const char *path = getenv(envname);\n  if (path == NULL)  /* no environment variable? */\n    lua_pushstring(L, def);  /* use default */\n  else {\n    /* replace \";;\" by \";AUXMARK;\" and then AUXMARK by default path */\n    path = luaL_gsub(L, path, LUA_PATHSEP LUA_PATHSEP,\n                              LUA_PATHSEP AUXMARK LUA_PATHSEP);\n    luaL_gsub(L, path, AUXMARK, def);\n    lua_remove(L, -2);\n  }\n  setprogdir(L);\n  lua_setfield(L, -2, fieldname);\n}\n\n\nstatic const luaL_Reg pk_funcs[] = {\n  {\"loadlib\", ll_loadlib},\n  {\"seeall\", ll_seeall},\n  {NULL, NULL}\n};\n\n\nstatic const luaL_Reg ll_funcs[] = {\n  {\"module\", ll_module},\n  {\"require\", ll_require},\n  {NULL, NULL}\n};\n\n\nstatic const lua_CFunction loaders[] =\n  {loader_preload, loader_Lua, loader_C, loader_Croot, NULL};\n\n\nLUALIB_API int luaopen_package (lua_State *L) {\n  int i;\n  /* create new type _LOADLIB */\n  luaL_newmetatable(L, \"_LOADLIB\");\n  lua_pushcfunction(L, gctm);\n  lua_setfield(L, -2, \"__gc\");\n  /* create `package' table */\n  luaL_register(L, LUA_LOADLIBNAME, pk_funcs);\n#if defined(LUA_COMPAT_LOADLIB) \n  lua_getfield(L, -1, \"loadlib\");\n  lua_setfield(L, LUA_GLOBALSINDEX, \"loadlib\");\n#endif\n  lua_pushvalue(L, -1);\n  lua_replace(L, LUA_ENVIRONINDEX);\n  /* create `loaders' table */\n  lua_createtable(L, sizeof(loaders)/sizeof(loaders[0]) - 1, 0);\n  /* fill it with pre-defined loaders */\n  for (i=0; loaders[i] != NULL; i++) {\n    lua_pushcfunction(L, loaders[i]);\n    lua_rawseti(L, -2, i+1);\n  }\n  lua_setfield(L, -2, \"loaders\");  /* put it in field `loaders' */\n  setpath(L, \"path\", LUA_PATH, LUA_PATH_DEFAULT);  /* set field `path' */\n  setpath(L, \"cpath\", LUA_CPATH, LUA_CPATH_DEFAULT); /* set field `cpath' */\n  /* store config information */\n  lua_pushliteral(L, LUA_DIRSEP \"\\n\" LUA_PATHSEP \"\\n\" LUA_PATH_MARK \"\\n\"\n                     LUA_EXECDIR \"\\n\" LUA_IGMARK);\n  lua_setfield(L, -2, \"config\");\n  /* set field `loaded' */\n  luaL_findtable(L, LUA_REGISTRYINDEX, \"_LOADED\", 2);\n  lua_setfield(L, -2, \"loaded\");\n  /* set field `preload' */\n  lua_newtable(L);\n  lua_setfield(L, -2, \"preload\");\n  lua_pushvalue(L, LUA_GLOBALSINDEX);\n  luaL_register(L, NULL, ll_funcs);  /* open lib into global table */\n  lua_pop(L, 1);\n  return 1;  /* return 'package' table */\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-redis-5.0.1-gykpygjr4nuvp2gxloszw6ksswcpsjes/spack-src/deps/jemalloc/configure.ac": "dnl Process this file with autoconf to produce a configure script.\nAC_PREREQ(2.68)\nAC_INIT([Makefile.in])\n\nAC_CONFIG_AUX_DIR([build-aux])\n\ndnl ============================================================================\ndnl Custom macro definitions.\n\ndnl JE_CONCAT_VVV(r, a, b)\ndnl\ndnl Set $r to the concatenation of $a and $b, with a space separating them iff\ndnl both $a and $b are non-empty.\nAC_DEFUN([JE_CONCAT_VVV],\nif test \"x[$]{$2}\" = \"x\" -o \"x[$]{$3}\" = \"x\" ; then\n  $1=\"[$]{$2}[$]{$3}\"\nelse\n  $1=\"[$]{$2} [$]{$3}\"\nfi\n)\n\ndnl JE_APPEND_VS(a, b)\ndnl\ndnl Set $a to the concatenation of $a and b, with a space separating them iff\ndnl both $a and b are non-empty.\nAC_DEFUN([JE_APPEND_VS],\n  T_APPEND_V=$2\n  JE_CONCAT_VVV($1, $1, T_APPEND_V)\n)\n\nCONFIGURE_CFLAGS=\nSPECIFIED_CFLAGS=\"${CFLAGS}\"\ndnl JE_CFLAGS_ADD(cflag)\ndnl\ndnl CFLAGS is the concatenation of CONFIGURE_CFLAGS and SPECIFIED_CFLAGS\ndnl (ignoring EXTRA_CFLAGS, which does not impact configure tests.  This macro\ndnl appends to CONFIGURE_CFLAGS and regenerates CFLAGS.\nAC_DEFUN([JE_CFLAGS_ADD],\n[\nAC_MSG_CHECKING([whether compiler supports $1])\nT_CONFIGURE_CFLAGS=\"${CONFIGURE_CFLAGS}\"\nJE_APPEND_VS(CONFIGURE_CFLAGS, $1)\nJE_CONCAT_VVV(CFLAGS, CONFIGURE_CFLAGS, SPECIFIED_CFLAGS)\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n[[\n]], [[\n    return 0;\n]])],\n              [je_cv_cflags_added=$1]\n              AC_MSG_RESULT([yes]),\n              [je_cv_cflags_added=]\n              AC_MSG_RESULT([no])\n              [CONFIGURE_CFLAGS=\"${T_CONFIGURE_CFLAGS}\"]\n)\nJE_CONCAT_VVV(CFLAGS, CONFIGURE_CFLAGS, SPECIFIED_CFLAGS)\n])\n\ndnl JE_CFLAGS_SAVE()\ndnl JE_CFLAGS_RESTORE()\ndnl\ndnl Save/restore CFLAGS.  Nesting is not supported.\nAC_DEFUN([JE_CFLAGS_SAVE],\nSAVED_CONFIGURE_CFLAGS=\"${CONFIGURE_CFLAGS}\"\n)\nAC_DEFUN([JE_CFLAGS_RESTORE],\nCONFIGURE_CFLAGS=\"${SAVED_CONFIGURE_CFLAGS}\"\nJE_CONCAT_VVV(CFLAGS, CONFIGURE_CFLAGS, SPECIFIED_CFLAGS)\n)\n\nCONFIGURE_CXXFLAGS=\nSPECIFIED_CXXFLAGS=\"${CXXFLAGS}\"\ndnl JE_CXXFLAGS_ADD(cxxflag)\nAC_DEFUN([JE_CXXFLAGS_ADD],\n[\nAC_MSG_CHECKING([whether compiler supports $1])\nT_CONFIGURE_CXXFLAGS=\"${CONFIGURE_CXXFLAGS}\"\nJE_APPEND_VS(CONFIGURE_CXXFLAGS, $1)\nJE_CONCAT_VVV(CXXFLAGS, CONFIGURE_CXXFLAGS, SPECIFIED_CXXFLAGS)\nAC_LANG_PUSH([C++])\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n[[\n]], [[\n    return 0;\n]])],\n              [je_cv_cxxflags_added=$1]\n              AC_MSG_RESULT([yes]),\n              [je_cv_cxxflags_added=]\n              AC_MSG_RESULT([no])\n              [CONFIGURE_CXXFLAGS=\"${T_CONFIGURE_CXXFLAGS}\"]\n)\nAC_LANG_POP([C++])\nJE_CONCAT_VVV(CXXFLAGS, CONFIGURE_CXXFLAGS, SPECIFIED_CXXFLAGS)\n])\n\ndnl JE_COMPILABLE(label, hcode, mcode, rvar)\ndnl\ndnl Use AC_LINK_IFELSE() rather than AC_COMPILE_IFELSE() so that linker errors\ndnl cause failure.\nAC_DEFUN([JE_COMPILABLE],\n[\nAC_CACHE_CHECK([whether $1 is compilable],\n               [$4],\n               [AC_LINK_IFELSE([AC_LANG_PROGRAM([$2],\n                                                [$3])],\n                               [$4=yes],\n                               [$4=no])])\n])\n\ndnl ============================================================================\n\nCONFIG=`echo ${ac_configure_args} | sed -e 's#'\"'\"'\\([^ ]*\\)'\"'\"'#\\1#g'`\nAC_SUBST([CONFIG])\n\ndnl Library revision.\nrev=2\nAC_SUBST([rev])\n\nsrcroot=$srcdir\nif test \"x${srcroot}\" = \"x.\" ; then\n  srcroot=\"\"\nelse\n  srcroot=\"${srcroot}/\"\nfi\nAC_SUBST([srcroot])\nabs_srcroot=\"`cd \\\"${srcdir}\\\"; pwd`/\"\nAC_SUBST([abs_srcroot])\n\nobjroot=\"\"\nAC_SUBST([objroot])\nabs_objroot=\"`pwd`/\"\nAC_SUBST([abs_objroot])\n\ndnl Munge install path variables.\nif test \"x$prefix\" = \"xNONE\" ; then\n  prefix=\"/usr/local\"\nfi\nif test \"x$exec_prefix\" = \"xNONE\" ; then\n  exec_prefix=$prefix\nfi\nPREFIX=$prefix\nAC_SUBST([PREFIX])\nBINDIR=`eval echo $bindir`\nBINDIR=`eval echo $BINDIR`\nAC_SUBST([BINDIR])\nINCLUDEDIR=`eval echo $includedir`\nINCLUDEDIR=`eval echo $INCLUDEDIR`\nAC_SUBST([INCLUDEDIR])\nLIBDIR=`eval echo $libdir`\nLIBDIR=`eval echo $LIBDIR`\nAC_SUBST([LIBDIR])\nDATADIR=`eval echo $datadir`\nDATADIR=`eval echo $DATADIR`\nAC_SUBST([DATADIR])\nMANDIR=`eval echo $mandir`\nMANDIR=`eval echo $MANDIR`\nAC_SUBST([MANDIR])\n\ndnl Support for building documentation.\nAC_PATH_PROG([XSLTPROC], [xsltproc], [false], [$PATH])\nif test -d \"/usr/share/xml/docbook/stylesheet/docbook-xsl\" ; then\n  DEFAULT_XSLROOT=\"/usr/share/xml/docbook/stylesheet/docbook-xsl\"\nelif test -d \"/usr/share/sgml/docbook/xsl-stylesheets\" ; then\n  DEFAULT_XSLROOT=\"/usr/share/sgml/docbook/xsl-stylesheets\"\nelse\n  dnl Documentation building will fail if this default gets used.\n  DEFAULT_XSLROOT=\"\"\nfi\nAC_ARG_WITH([xslroot],\n  [AS_HELP_STRING([--with-xslroot=<path>], [XSL stylesheet root path])], [\nif test \"x$with_xslroot\" = \"xno\" ; then\n  XSLROOT=\"${DEFAULT_XSLROOT}\"\nelse\n  XSLROOT=\"${with_xslroot}\"\nfi\n],\n  XSLROOT=\"${DEFAULT_XSLROOT}\"\n)\nAC_SUBST([XSLROOT])\n\ndnl If CFLAGS isn't defined, set CFLAGS to something reasonable.  Otherwise,\ndnl just prevent autoconf from molesting CFLAGS.\nCFLAGS=$CFLAGS\nAC_PROG_CC\n\nif test \"x$GCC\" != \"xyes\" ; then\n  AC_CACHE_CHECK([whether compiler is MSVC],\n                 [je_cv_msvc],\n                 [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([],\n                                                     [\n#ifndef _MSC_VER\n  int fail[-1];\n#endif\n])],\n                               [je_cv_msvc=yes],\n                               [je_cv_msvc=no])])\nfi\n\ndnl check if a cray prgenv wrapper compiler is being used\nje_cv_cray_prgenv_wrapper=\"\"\nif test \"x${PE_ENV}\" != \"x\" ; then\n  case \"${CC}\" in\n    CC|cc)\n\tje_cv_cray_prgenv_wrapper=\"yes\"\n\t;;\n    *)\n       ;;\n  esac\nfi\n\nAC_CACHE_CHECK([whether compiler is cray],\n              [je_cv_cray],\n              [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([],\n                                                  [\n#ifndef _CRAYC\n  int fail[-1];\n#endif\n])],\n                            [je_cv_cray=yes],\n                            [je_cv_cray=no])])\n\nif test \"x${je_cv_cray}\" = \"xyes\" ; then\n  AC_CACHE_CHECK([whether cray compiler version is 8.4],\n                [je_cv_cray_84],\n                [AC_COMPILE_IFELSE([AC_LANG_PROGRAM([],\n                                                      [\n#if !(_RELEASE_MAJOR == 8 && _RELEASE_MINOR == 4)\n  int fail[-1];\n#endif\n])],\n                              [je_cv_cray_84=yes],\n                              [je_cv_cray_84=no])])\nfi\n\nif test \"x$GCC\" = \"xyes\" ; then\n  JE_CFLAGS_ADD([-std=gnu11])\n  if test \"x$je_cv_cflags_added\" = \"x-std=gnu11\" ; then\n    AC_DEFINE_UNQUOTED([JEMALLOC_HAS_RESTRICT])\n  else\n    JE_CFLAGS_ADD([-std=gnu99])\n    if test \"x$je_cv_cflags_added\" = \"x-std=gnu99\" ; then\n      AC_DEFINE_UNQUOTED([JEMALLOC_HAS_RESTRICT])\n    fi\n  fi\n  JE_CFLAGS_ADD([-Wall])\n  JE_CFLAGS_ADD([-Wshorten-64-to-32])\n  JE_CFLAGS_ADD([-Wsign-compare])\n  JE_CFLAGS_ADD([-Wundef])\n  JE_CFLAGS_ADD([-Wno-format-zero-length])\n  JE_CFLAGS_ADD([-pipe])\n  JE_CFLAGS_ADD([-g3])\nelif test \"x$je_cv_msvc\" = \"xyes\" ; then\n  CC=\"$CC -nologo\"\n  JE_CFLAGS_ADD([-Zi])\n  JE_CFLAGS_ADD([-MT])\n  JE_CFLAGS_ADD([-W3])\n  JE_CFLAGS_ADD([-FS])\n  JE_APPEND_VS(CPPFLAGS, -I${srcdir}/include/msvc_compat)\nfi\nif test \"x$je_cv_cray\" = \"xyes\" ; then\n  dnl cray compiler 8.4 has an inlining bug\n  if test \"x$je_cv_cray_84\" = \"xyes\" ; then\n    JE_CFLAGS_ADD([-hipa2])\n    JE_CFLAGS_ADD([-hnognu])\n  fi\n  dnl ignore unreachable code warning\n  JE_CFLAGS_ADD([-hnomessage=128])\n  dnl ignore redefinition of \"malloc\", \"free\", etc warning\n  JE_CFLAGS_ADD([-hnomessage=1357])\nfi\nAC_SUBST([CONFIGURE_CFLAGS])\nAC_SUBST([SPECIFIED_CFLAGS])\nAC_SUBST([EXTRA_CFLAGS])\nAC_PROG_CPP\n\nAC_ARG_ENABLE([cxx],\n  [AS_HELP_STRING([--disable-cxx], [Disable C++ integration])],\nif test \"x$enable_cxx\" = \"xno\" ; then\n  enable_cxx=\"0\"\nelse\n  enable_cxx=\"1\"\nfi\n,\nenable_cxx=\"1\"\n)\nif test \"x$enable_cxx\" = \"x1\" ; then\n  dnl Require at least c++14, which is the first version to support sized\n  dnl deallocation.  C++ support is not compiled otherwise.\n  m4_include([m4/ax_cxx_compile_stdcxx.m4])\n  AX_CXX_COMPILE_STDCXX([14], [noext], [optional])\n  if test \"x${HAVE_CXX14}\" = \"x1\" ; then\n    JE_CXXFLAGS_ADD([-Wall])\n    JE_CXXFLAGS_ADD([-g3])\n\n    SAVED_LIBS=\"${LIBS}\"\n    JE_APPEND_VS(LIBS, -lstdc++)\n    JE_COMPILABLE([libstdc++ linkage], [\n#include <stdlib.h>\n], [[\n\tint *arr = (int *)malloc(sizeof(int) * 42);\n\tif (arr == NULL)\n\t\treturn 1;\n]], [je_cv_libstdcxx])\n    if test \"x${je_cv_libstdcxx}\" = \"xno\" ; then\n      LIBS=\"${SAVED_LIBS}\"\n    fi\n  else\n    enable_cxx=\"0\"\n  fi\nfi\nAC_SUBST([enable_cxx])\nAC_SUBST([CONFIGURE_CXXFLAGS])\nAC_SUBST([SPECIFIED_CXXFLAGS])\nAC_SUBST([EXTRA_CXXFLAGS])\n\nAC_C_BIGENDIAN([ac_cv_big_endian=1], [ac_cv_big_endian=0])\nif test \"x${ac_cv_big_endian}\" = \"x1\" ; then\n  AC_DEFINE_UNQUOTED([JEMALLOC_BIG_ENDIAN], [ ])\nfi\n\nif test \"x${je_cv_msvc}\" = \"xyes\" -a \"x${ac_cv_header_inttypes_h}\" = \"xno\"; then\n  JE_APPEND_VS(CPPFLAGS, -I${srcdir}/include/msvc_compat/C99)\nfi\n\nif test \"x${je_cv_msvc}\" = \"xyes\" ; then\n  LG_SIZEOF_PTR=LG_SIZEOF_PTR_WIN\n  AC_MSG_RESULT([Using a predefined value for sizeof(void *): 4 for 32-bit, 8 for 64-bit])\nelse\n  AC_CHECK_SIZEOF([void *])\n  if test \"x${ac_cv_sizeof_void_p}\" = \"x8\" ; then\n    LG_SIZEOF_PTR=3\n  elif test \"x${ac_cv_sizeof_void_p}\" = \"x4\" ; then\n    LG_SIZEOF_PTR=2\n  else\n    AC_MSG_ERROR([Unsupported pointer size: ${ac_cv_sizeof_void_p}])\n  fi\nfi\nAC_DEFINE_UNQUOTED([LG_SIZEOF_PTR], [$LG_SIZEOF_PTR])\n\nAC_CHECK_SIZEOF([int])\nif test \"x${ac_cv_sizeof_int}\" = \"x8\" ; then\n  LG_SIZEOF_INT=3\nelif test \"x${ac_cv_sizeof_int}\" = \"x4\" ; then\n  LG_SIZEOF_INT=2\nelse\n  AC_MSG_ERROR([Unsupported int size: ${ac_cv_sizeof_int}])\nfi\nAC_DEFINE_UNQUOTED([LG_SIZEOF_INT], [$LG_SIZEOF_INT])\n\nAC_CHECK_SIZEOF([long])\nif test \"x${ac_cv_sizeof_long}\" = \"x8\" ; then\n  LG_SIZEOF_LONG=3\nelif test \"x${ac_cv_sizeof_long}\" = \"x4\" ; then\n  LG_SIZEOF_LONG=2\nelse\n  AC_MSG_ERROR([Unsupported long size: ${ac_cv_sizeof_long}])\nfi\nAC_DEFINE_UNQUOTED([LG_SIZEOF_LONG], [$LG_SIZEOF_LONG])\n\nAC_CHECK_SIZEOF([long long])\nif test \"x${ac_cv_sizeof_long_long}\" = \"x8\" ; then\n  LG_SIZEOF_LONG_LONG=3\nelif test \"x${ac_cv_sizeof_long_long}\" = \"x4\" ; then\n  LG_SIZEOF_LONG_LONG=2\nelse\n  AC_MSG_ERROR([Unsupported long long size: ${ac_cv_sizeof_long_long}])\nfi\nAC_DEFINE_UNQUOTED([LG_SIZEOF_LONG_LONG], [$LG_SIZEOF_LONG_LONG])\n\nAC_CHECK_SIZEOF([intmax_t])\nif test \"x${ac_cv_sizeof_intmax_t}\" = \"x16\" ; then\n  LG_SIZEOF_INTMAX_T=4\nelif test \"x${ac_cv_sizeof_intmax_t}\" = \"x8\" ; then\n  LG_SIZEOF_INTMAX_T=3\nelif test \"x${ac_cv_sizeof_intmax_t}\" = \"x4\" ; then\n  LG_SIZEOF_INTMAX_T=2\nelse\n  AC_MSG_ERROR([Unsupported intmax_t size: ${ac_cv_sizeof_intmax_t}])\nfi\nAC_DEFINE_UNQUOTED([LG_SIZEOF_INTMAX_T], [$LG_SIZEOF_INTMAX_T])\n\nAC_CANONICAL_HOST\ndnl CPU-specific settings.\nCPU_SPINWAIT=\"\"\ncase \"${host_cpu}\" in\n  i686|x86_64)\n\tHAVE_CPU_SPINWAIT=1\n\tif test \"x${je_cv_msvc}\" = \"xyes\" ; then\n\t    AC_CACHE_VAL([je_cv_pause_msvc],\n\t      [JE_COMPILABLE([pause instruction MSVC], [],\n\t\t\t\t\t[[_mm_pause(); return 0;]],\n\t\t\t\t\t[je_cv_pause_msvc])])\n\t    if test \"x${je_cv_pause_msvc}\" = \"xyes\" ; then\n\t\tCPU_SPINWAIT='_mm_pause()'\n\t    fi\n\telse\n\t    AC_CACHE_VAL([je_cv_pause],\n\t      [JE_COMPILABLE([pause instruction], [],\n\t\t\t\t\t[[__asm__ volatile(\"pause\"); return 0;]],\n\t\t\t\t\t[je_cv_pause])])\n\t    if test \"x${je_cv_pause}\" = \"xyes\" ; then\n\t\tCPU_SPINWAIT='__asm__ volatile(\"pause\")'\n\t    fi\n\tfi\n\t;;\n  *)\n\tHAVE_CPU_SPINWAIT=0\n\t;;\nesac\nAC_DEFINE_UNQUOTED([HAVE_CPU_SPINWAIT], [$HAVE_CPU_SPINWAIT])\nAC_DEFINE_UNQUOTED([CPU_SPINWAIT], [$CPU_SPINWAIT])\n\nAC_ARG_WITH([lg_vaddr],\n  [AS_HELP_STRING([--with-lg-vaddr=<lg-vaddr>], [Number of significant virtual address bits])],\n  [LG_VADDR=\"$with_lg_vaddr\"], [LG_VADDR=\"detect\"])\n\ncase \"${host_cpu}\" in\n  aarch64)\n    if test \"x$LG_VADDR\" = \"xdetect\"; then\n      AC_MSG_CHECKING([number of significant virtual address bits])\n      if test \"x${LG_SIZEOF_PTR}\" = \"x2\" ; then\n        #aarch64 ILP32\n        LG_VADDR=32\n      else\n        #aarch64 LP64\n        LG_VADDR=48\n      fi\n      AC_MSG_RESULT([$LG_VADDR])\n    fi\n    ;;\n  x86_64)\n    if test \"x$LG_VADDR\" = \"xdetect\"; then\n      AC_CACHE_CHECK([number of significant virtual address bits],\n                     [je_cv_lg_vaddr],\n                     AC_RUN_IFELSE([AC_LANG_PROGRAM(\n[[\n#include <stdio.h>\n#ifdef _WIN32\n#include <limits.h>\n#include <intrin.h>\ntypedef unsigned __int32 uint32_t;\n#else\n#include <stdint.h>\n#endif\n]], [[\n\tuint32_t r[[4]];\n\tuint32_t eax_in = 0x80000008U;\n#ifdef _WIN32\n\t__cpuid((int *)r, (int)eax_in);\n#else\n\tasm volatile (\"cpuid\"\n\t    : \"=a\" (r[[0]]), \"=b\" (r[[1]]), \"=c\" (r[[2]]), \"=d\" (r[[3]])\n\t    : \"a\" (eax_in), \"c\" (0)\n\t);\n#endif\n\tuint32_t eax_out = r[[0]];\n\tuint32_t vaddr = ((eax_out & 0x0000ff00U) >> 8);\n\tFILE *f = fopen(\"conftest.out\", \"w\");\n\tif (f == NULL) {\n\t\treturn 1;\n\t}\n\tif (vaddr > (sizeof(void *) << 3)) {\n\t\tvaddr = sizeof(void *) << 3;\n\t}\n\tfprintf(f, \"%u\", vaddr);\n\tfclose(f);\n\treturn 0;\n]])],\n                   [je_cv_lg_vaddr=`cat conftest.out`],\n                   [je_cv_lg_vaddr=error],\n                   [je_cv_lg_vaddr=57]))\n      if test \"x${je_cv_lg_vaddr}\" != \"x\" ; then\n        LG_VADDR=\"${je_cv_lg_vaddr}\"\n      fi\n      if test \"x${LG_VADDR}\" != \"xerror\" ; then\n        AC_DEFINE_UNQUOTED([LG_VADDR], [$LG_VADDR])\n      else\n        AC_MSG_ERROR([cannot determine number of significant virtual address bits])\n      fi\n    fi\n    ;;\n  *)\n    if test \"x$LG_VADDR\" = \"xdetect\"; then\n      AC_MSG_CHECKING([number of significant virtual address bits])\n      if test \"x${LG_SIZEOF_PTR}\" = \"x3\" ; then\n        LG_VADDR=64\n      elif test \"x${LG_SIZEOF_PTR}\" = \"x2\" ; then\n        LG_VADDR=32\n      elif test \"x${LG_SIZEOF_PTR}\" = \"xLG_SIZEOF_PTR_WIN\" ; then\n        LG_VADDR=\"(1U << (LG_SIZEOF_PTR_WIN+3))\"\n      else\n        AC_MSG_ERROR([Unsupported lg(pointer size): ${LG_SIZEOF_PTR}])\n      fi\n      AC_MSG_RESULT([$LG_VADDR])\n    fi\n    ;;\nesac\nAC_DEFINE_UNQUOTED([LG_VADDR], [$LG_VADDR])\n\nLD_PRELOAD_VAR=\"LD_PRELOAD\"\nso=\"so\"\nimportlib=\"${so}\"\no=\"$ac_objext\"\na=\"a\"\nexe=\"$ac_exeext\"\nlibprefix=\"lib\"\nlink_whole_archive=\"0\"\nDSO_LDFLAGS='-shared -Wl,-soname,$(@F)'\nRPATH='-Wl,-rpath,$(1)'\nSOREV=\"${so}.${rev}\"\nPIC_CFLAGS='-fPIC -DPIC'\nCTARGET='-o $@'\nLDTARGET='-o $@'\nTEST_LD_MODE=\nEXTRA_LDFLAGS=\nARFLAGS='crus'\nAROUT=' $@'\nCC_MM=1\n\nif test \"x$je_cv_cray_prgenv_wrapper\" = \"xyes\" ; then\n  TEST_LD_MODE='-dynamic'\nfi\n\nif test \"x${je_cv_cray}\" = \"xyes\" ; then\n  CC_MM=\nfi\n\nAN_MAKEVAR([AR], [AC_PROG_AR])\nAN_PROGRAM([ar], [AC_PROG_AR])\nAC_DEFUN([AC_PROG_AR], [AC_CHECK_TOOL(AR, ar, :)])\nAC_PROG_AR\n\nAN_MAKEVAR([NM], [AC_PROG_NM])\nAN_PROGRAM([nm], [AC_PROG_NM])\nAC_DEFUN([AC_PROG_NM], [AC_CHECK_TOOL(NM, nm, :)])\nAC_PROG_NM\n\nAC_PROG_AWK\n\ndnl Platform-specific settings.  abi and RPATH can probably be determined\ndnl programmatically, but doing so is error-prone, which makes it generally\ndnl not worth the trouble.\ndnl\ndnl Define cpp macros in CPPFLAGS, rather than doing AC_DEFINE(macro), since the\ndnl definitions need to be seen before any headers are included, which is a pain\ndnl to make happen otherwise.\ndefault_retain=\"0\"\nmaps_coalesce=\"1\"\nDUMP_SYMS=\"${NM} -a\"\nSYM_PREFIX=\"\"\ncase \"${host}\" in\n  *-*-darwin* | *-*-ios*)\n\tabi=\"macho\"\n\tRPATH=\"\"\n\tLD_PRELOAD_VAR=\"DYLD_INSERT_LIBRARIES\"\n\tso=\"dylib\"\n\timportlib=\"${so}\"\n\tforce_tls=\"0\"\n\tDSO_LDFLAGS='-shared -Wl,-install_name,$(LIBDIR)/$(@F)'\n\tSOREV=\"${rev}.${so}\"\n\tsbrk_deprecated=\"1\"\n\tSYM_PREFIX=\"_\"\n\t;;\n  *-*-freebsd*)\n\tabi=\"elf\"\n\tAC_DEFINE([JEMALLOC_SYSCTL_VM_OVERCOMMIT], [ ])\n\tforce_lazy_lock=\"1\"\n\t;;\n  *-*-dragonfly*)\n\tabi=\"elf\"\n\t;;\n  *-*-openbsd*)\n\tabi=\"elf\"\n\tforce_tls=\"0\"\n\t;;\n  *-*-bitrig*)\n\tabi=\"elf\"\n\t;;\n  *-*-linux-android)\n\tdnl syscall(2) and secure_getenv(3) are exposed by _GNU_SOURCE.\n\tJE_APPEND_VS(CPPFLAGS, -D_GNU_SOURCE)\n\tabi=\"elf\"\n\tAC_DEFINE([JEMALLOC_PURGE_MADVISE_DONTNEED_ZEROS], [ ])\n\tAC_DEFINE([JEMALLOC_HAS_ALLOCA_H])\n\tAC_DEFINE([JEMALLOC_PROC_SYS_VM_OVERCOMMIT_MEMORY], [ ])\n\tAC_DEFINE([JEMALLOC_THREADED_INIT], [ ])\n\tAC_DEFINE([JEMALLOC_C11_ATOMICS])\n\tforce_tls=\"0\"\n\tif test \"${LG_SIZEOF_PTR}\" = \"3\"; then\n\t  default_retain=\"1\"\n\tfi\n\t;;\n  *-*-linux*)\n\tdnl syscall(2) and secure_getenv(3) are exposed by _GNU_SOURCE.\n\tJE_APPEND_VS(CPPFLAGS, -D_GNU_SOURCE)\n\tabi=\"elf\"\n\tAC_DEFINE([JEMALLOC_PURGE_MADVISE_DONTNEED_ZEROS], [ ])\n\tAC_DEFINE([JEMALLOC_HAS_ALLOCA_H])\n\tAC_DEFINE([JEMALLOC_PROC_SYS_VM_OVERCOMMIT_MEMORY], [ ])\n\tAC_DEFINE([JEMALLOC_THREADED_INIT], [ ])\n\tAC_DEFINE([JEMALLOC_USE_CXX_THROW], [ ])\n\tif test \"${LG_SIZEOF_PTR}\" = \"3\"; then\n\t  default_retain=\"1\"\n\tfi\n\t;;\n  *-*-kfreebsd*)\n\tdnl syscall(2) and secure_getenv(3) are exposed by _GNU_SOURCE.\n\tJE_APPEND_VS(CPPFLAGS, -D_GNU_SOURCE)\n\tabi=\"elf\"\n\tAC_DEFINE([JEMALLOC_HAS_ALLOCA_H])\n\tAC_DEFINE([JEMALLOC_SYSCTL_VM_OVERCOMMIT], [ ])\n\tAC_DEFINE([JEMALLOC_THREADED_INIT], [ ])\n\tAC_DEFINE([JEMALLOC_USE_CXX_THROW], [ ])\n\t;;\n  *-*-netbsd*)\n\tAC_MSG_CHECKING([ABI])\n        AC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n[[#ifdef __ELF__\n/* ELF */\n#else\n#error aout\n#endif\n]])],\n                          [abi=\"elf\"],\n                          [abi=\"aout\"])\n\tAC_MSG_RESULT([$abi])\n\t;;\n  *-*-solaris2*)\n\tabi=\"elf\"\n\tRPATH='-Wl,-R,$(1)'\n\tdnl Solaris needs this for sigwait().\n\tJE_APPEND_VS(CPPFLAGS, -D_POSIX_PTHREAD_SEMANTICS)\n\tJE_APPEND_VS(LIBS, -lposix4 -lsocket -lnsl)\n\t;;\n  *-ibm-aix*)\n\tif test \"${LG_SIZEOF_PTR}\" = \"3\"; then\n\t  dnl 64bit AIX\n\t  LD_PRELOAD_VAR=\"LDR_PRELOAD64\"\n\telse\n\t  dnl 32bit AIX\n\t  LD_PRELOAD_VAR=\"LDR_PRELOAD\"\n\tfi\n\tabi=\"xcoff\"\n\t;;\n  *-*-mingw* | *-*-cygwin*)\n\tabi=\"pecoff\"\n\tforce_tls=\"0\"\n\tmaps_coalesce=\"0\"\n\tRPATH=\"\"\n\tso=\"dll\"\n\tif test \"x$je_cv_msvc\" = \"xyes\" ; then\n\t  importlib=\"lib\"\n\t  DSO_LDFLAGS=\"-LD\"\n\t  EXTRA_LDFLAGS=\"-link -DEBUG\"\n\t  CTARGET='-Fo$@'\n\t  LDTARGET='-Fe$@'\n\t  AR='lib'\n\t  ARFLAGS='-nologo -out:'\n\t  AROUT='$@'\n\t  CC_MM=\n        else\n\t  importlib=\"${so}\"\n\t  DSO_LDFLAGS=\"-shared\"\n\t  link_whole_archive=\"1\"\n\tfi\n\tcase \"${host}\" in\n\t  *-*-cygwin*)\n\t    DUMP_SYMS=\"dumpbin /SYMBOLS\"\n\t    ;;\n\t  *)\n\t    ;;\n\tesac\n\ta=\"lib\"\n\tlibprefix=\"\"\n\tSOREV=\"${so}\"\n\tPIC_CFLAGS=\"\"\n\t;;\n  *)\n\tAC_MSG_RESULT([Unsupported operating system: ${host}])\n\tabi=\"elf\"\n\t;;\nesac\n\nJEMALLOC_USABLE_SIZE_CONST=const\nAC_CHECK_HEADERS([malloc.h], [\n  AC_MSG_CHECKING([whether malloc_usable_size definition can use const argument])\n  AC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n    [#include <malloc.h>\n     #include <stddef.h>\n    size_t malloc_usable_size(const void *ptr);\n    ],\n    [])],[\n                AC_MSG_RESULT([yes])\n         ],[\n                JEMALLOC_USABLE_SIZE_CONST=\n                AC_MSG_RESULT([no])\n         ])\n])\nAC_DEFINE_UNQUOTED([JEMALLOC_USABLE_SIZE_CONST], [$JEMALLOC_USABLE_SIZE_CONST])\nAC_SUBST([abi])\nAC_SUBST([RPATH])\nAC_SUBST([LD_PRELOAD_VAR])\nAC_SUBST([so])\nAC_SUBST([importlib])\nAC_SUBST([o])\nAC_SUBST([a])\nAC_SUBST([exe])\nAC_SUBST([libprefix])\nAC_SUBST([link_whole_archive])\nAC_SUBST([DSO_LDFLAGS])\nAC_SUBST([EXTRA_LDFLAGS])\nAC_SUBST([SOREV])\nAC_SUBST([PIC_CFLAGS])\nAC_SUBST([CTARGET])\nAC_SUBST([LDTARGET])\nAC_SUBST([TEST_LD_MODE])\nAC_SUBST([MKLIB])\nAC_SUBST([ARFLAGS])\nAC_SUBST([AROUT])\nAC_SUBST([DUMP_SYMS])\nAC_SUBST([CC_MM])\n\ndnl Determine whether libm must be linked to use e.g. log(3).\nAC_SEARCH_LIBS([log], [m], , [AC_MSG_ERROR([Missing math functions])])\nif test \"x$ac_cv_search_log\" != \"xnone required\" ; then\n  LM=\"$ac_cv_search_log\"\nelse\n  LM=\nfi\nAC_SUBST(LM)\n\nJE_COMPILABLE([__attribute__ syntax],\n              [static __attribute__((unused)) void foo(void){}],\n              [],\n              [je_cv_attribute])\nif test \"x${je_cv_attribute}\" = \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_HAVE_ATTR], [ ])\n  if test \"x${GCC}\" = \"xyes\" -a \"x${abi}\" = \"xelf\"; then\n    JE_CFLAGS_ADD([-fvisibility=hidden])\n    JE_CXXFLAGS_ADD([-fvisibility=hidden])\n  fi\nfi\ndnl Check for tls_model attribute support (clang 3.0 still lacks support).\nJE_CFLAGS_SAVE()\nJE_CFLAGS_ADD([-Werror])\nJE_CFLAGS_ADD([-herror_on_warning])\nJE_COMPILABLE([tls_model attribute], [],\n              [static __thread int\n               __attribute__((tls_model(\"initial-exec\"), unused)) foo;\n               foo = 0;],\n              [je_cv_tls_model])\nJE_CFLAGS_RESTORE()\ndnl (Setting of JEMALLOC_TLS_MODEL is done later, after we've checked for\ndnl --disable-initial-exec-tls)\n\ndnl Check for alloc_size attribute support.\nJE_CFLAGS_SAVE()\nJE_CFLAGS_ADD([-Werror])\nJE_CFLAGS_ADD([-herror_on_warning])\nJE_COMPILABLE([alloc_size attribute], [#include <stdlib.h>],\n              [void *foo(size_t size) __attribute__((alloc_size(1)));],\n              [je_cv_alloc_size])\nJE_CFLAGS_RESTORE()\nif test \"x${je_cv_alloc_size}\" = \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_HAVE_ATTR_ALLOC_SIZE], [ ])\nfi\ndnl Check for format(gnu_printf, ...) attribute support.\nJE_CFLAGS_SAVE()\nJE_CFLAGS_ADD([-Werror])\nJE_CFLAGS_ADD([-herror_on_warning])\nJE_COMPILABLE([format(gnu_printf, ...) attribute], [#include <stdlib.h>],\n              [void *foo(const char *format, ...) __attribute__((format(gnu_printf, 1, 2)));],\n              [je_cv_format_gnu_printf])\nJE_CFLAGS_RESTORE()\nif test \"x${je_cv_format_gnu_printf}\" = \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_HAVE_ATTR_FORMAT_GNU_PRINTF], [ ])\nfi\ndnl Check for format(printf, ...) attribute support.\nJE_CFLAGS_SAVE()\nJE_CFLAGS_ADD([-Werror])\nJE_CFLAGS_ADD([-herror_on_warning])\nJE_COMPILABLE([format(printf, ...) attribute], [#include <stdlib.h>],\n              [void *foo(const char *format, ...) __attribute__((format(printf, 1, 2)));],\n              [je_cv_format_printf])\nJE_CFLAGS_RESTORE()\nif test \"x${je_cv_format_printf}\" = \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_HAVE_ATTR_FORMAT_PRINTF], [ ])\nfi\n\ndnl Support optional additions to rpath.\nAC_ARG_WITH([rpath],\n  [AS_HELP_STRING([--with-rpath=<rpath>], [Colon-separated rpath (ELF systems only)])],\nif test \"x$with_rpath\" = \"xno\" ; then\n  RPATH_EXTRA=\nelse\n  RPATH_EXTRA=\"`echo $with_rpath | tr \\\":\\\" \\\" \\\"`\"\nfi,\n  RPATH_EXTRA=\n)\nAC_SUBST([RPATH_EXTRA])\n\ndnl Disable rules that do automatic regeneration of configure output by default.\nAC_ARG_ENABLE([autogen],\n  [AS_HELP_STRING([--enable-autogen], [Automatically regenerate configure output])],\nif test \"x$enable_autogen\" = \"xno\" ; then\n  enable_autogen=\"0\"\nelse\n  enable_autogen=\"1\"\nfi\n,\nenable_autogen=\"0\"\n)\nAC_SUBST([enable_autogen])\n\nAC_PROG_INSTALL\nAC_PROG_RANLIB\nAC_PATH_PROG([LD], [ld], [false], [$PATH])\nAC_PATH_PROG([AUTOCONF], [autoconf], [false], [$PATH])\n\ndnl Perform no name mangling by default.\nAC_ARG_WITH([mangling],\n  [AS_HELP_STRING([--with-mangling=<map>], [Mangle symbols in <map>])],\n  [mangling_map=\"$with_mangling\"], [mangling_map=\"\"])\n\ndnl Do not prefix public APIs by default.\nAC_ARG_WITH([jemalloc_prefix],\n  [AS_HELP_STRING([--with-jemalloc-prefix=<prefix>], [Prefix to prepend to all public APIs])],\n  [JEMALLOC_PREFIX=\"$with_jemalloc_prefix\"],\n  [if test \"x$abi\" != \"xmacho\" -a \"x$abi\" != \"xpecoff\"; then\n  JEMALLOC_PREFIX=\"\"\nelse\n  JEMALLOC_PREFIX=\"je_\"\nfi]\n)\nif test \"x$JEMALLOC_PREFIX\" = \"x\" ; then\n  AC_DEFINE([JEMALLOC_IS_MALLOC])\nelse\n  JEMALLOC_CPREFIX=`echo ${JEMALLOC_PREFIX} | tr \"a-z\" \"A-Z\"`\n  AC_DEFINE_UNQUOTED([JEMALLOC_PREFIX], [\"$JEMALLOC_PREFIX\"])\n  AC_DEFINE_UNQUOTED([JEMALLOC_CPREFIX], [\"$JEMALLOC_CPREFIX\"])\nfi\nAC_SUBST([JEMALLOC_PREFIX])\nAC_SUBST([JEMALLOC_CPREFIX])\n\nAC_ARG_WITH([export],\n  [AS_HELP_STRING([--without-export], [disable exporting jemalloc public APIs])],\n  [if test \"x$with_export\" = \"xno\"; then\n  AC_DEFINE([JEMALLOC_EXPORT],[])\nfi]\n)\n\npublic_syms=\"aligned_alloc calloc dallocx free mallctl mallctlbymib mallctlnametomib malloc malloc_conf malloc_message malloc_stats_print malloc_usable_size mallocx nallocx posix_memalign rallocx realloc sallocx sdallocx xallocx\"\ndnl Check for additional platform-specific public API functions.\nAC_CHECK_FUNC([memalign],\n\t      [AC_DEFINE([JEMALLOC_OVERRIDE_MEMALIGN], [ ])\n\t       public_syms=\"${public_syms} memalign\"])\nAC_CHECK_FUNC([valloc],\n\t      [AC_DEFINE([JEMALLOC_OVERRIDE_VALLOC], [ ])\n\t       public_syms=\"${public_syms} valloc\"])\n\ndnl Check for allocator-related functions that should be wrapped.\nwrap_syms=\nif test \"x${JEMALLOC_PREFIX}\" = \"x\" ; then\n  AC_CHECK_FUNC([__libc_calloc],\n\t\t[AC_DEFINE([JEMALLOC_OVERRIDE___LIBC_CALLOC], [ ])\n\t\t wrap_syms=\"${wrap_syms} __libc_calloc\"])\n  AC_CHECK_FUNC([__libc_free],\n\t\t[AC_DEFINE([JEMALLOC_OVERRIDE___LIBC_FREE], [ ])\n\t\t wrap_syms=\"${wrap_syms} __libc_free\"])\n  AC_CHECK_FUNC([__libc_malloc],\n\t\t[AC_DEFINE([JEMALLOC_OVERRIDE___LIBC_MALLOC], [ ])\n\t\t wrap_syms=\"${wrap_syms} __libc_malloc\"])\n  AC_CHECK_FUNC([__libc_memalign],\n\t\t[AC_DEFINE([JEMALLOC_OVERRIDE___LIBC_MEMALIGN], [ ])\n\t\t wrap_syms=\"${wrap_syms} __libc_memalign\"])\n  AC_CHECK_FUNC([__libc_realloc],\n\t\t[AC_DEFINE([JEMALLOC_OVERRIDE___LIBC_REALLOC], [ ])\n\t\t wrap_syms=\"${wrap_syms} __libc_realloc\"])\n  AC_CHECK_FUNC([__libc_valloc],\n\t\t[AC_DEFINE([JEMALLOC_OVERRIDE___LIBC_VALLOC], [ ])\n\t\t wrap_syms=\"${wrap_syms} __libc_valloc\"])\n  AC_CHECK_FUNC([__posix_memalign],\n\t\t[AC_DEFINE([JEMALLOC_OVERRIDE___POSIX_MEMALIGN], [ ])\n\t\t wrap_syms=\"${wrap_syms} __posix_memalign\"])\nfi\n\ncase \"${host}\" in\n  *-*-mingw* | *-*-cygwin*)\n    wrap_syms=\"${wrap_syms} tls_callback\"\n    ;;\n  *)\n    ;;\nesac\n\ndnl Mangle library-private APIs.\nAC_ARG_WITH([private_namespace],\n  [AS_HELP_STRING([--with-private-namespace=<prefix>], [Prefix to prepend to all library-private APIs])],\n  [JEMALLOC_PRIVATE_NAMESPACE=\"${with_private_namespace}je_\"],\n  [JEMALLOC_PRIVATE_NAMESPACE=\"je_\"]\n)\nAC_DEFINE_UNQUOTED([JEMALLOC_PRIVATE_NAMESPACE], [$JEMALLOC_PRIVATE_NAMESPACE])\nprivate_namespace=\"$JEMALLOC_PRIVATE_NAMESPACE\"\nAC_SUBST([private_namespace])\n\ndnl Do not add suffix to installed files by default.\nAC_ARG_WITH([install_suffix],\n  [AS_HELP_STRING([--with-install-suffix=<suffix>], [Suffix to append to all installed files])],\n  [INSTALL_SUFFIX=\"$with_install_suffix\"],\n  [INSTALL_SUFFIX=]\n)\ninstall_suffix=\"$INSTALL_SUFFIX\"\nAC_SUBST([install_suffix])\n\ndnl Specify default malloc_conf.\nAC_ARG_WITH([malloc_conf],\n  [AS_HELP_STRING([--with-malloc-conf=<malloc_conf>], [config.malloc_conf options string])],\n  [JEMALLOC_CONFIG_MALLOC_CONF=\"$with_malloc_conf\"],\n  [JEMALLOC_CONFIG_MALLOC_CONF=\"\"]\n)\nconfig_malloc_conf=\"$JEMALLOC_CONFIG_MALLOC_CONF\"\nAC_DEFINE_UNQUOTED([JEMALLOC_CONFIG_MALLOC_CONF], [\"$config_malloc_conf\"])\n\ndnl Substitute @je_@ in jemalloc_protos.h.in, primarily to make generation of\ndnl jemalloc_protos_jet.h easy.\nje_=\"je_\"\nAC_SUBST([je_])\n\ncfgoutputs_in=\"Makefile.in\"\ncfgoutputs_in=\"${cfgoutputs_in} jemalloc.pc.in\"\ncfgoutputs_in=\"${cfgoutputs_in} doc/html.xsl.in\"\ncfgoutputs_in=\"${cfgoutputs_in} doc/manpages.xsl.in\"\ncfgoutputs_in=\"${cfgoutputs_in} doc/jemalloc.xml.in\"\ncfgoutputs_in=\"${cfgoutputs_in} include/jemalloc/jemalloc_macros.h.in\"\ncfgoutputs_in=\"${cfgoutputs_in} include/jemalloc/jemalloc_protos.h.in\"\ncfgoutputs_in=\"${cfgoutputs_in} include/jemalloc/jemalloc_typedefs.h.in\"\ncfgoutputs_in=\"${cfgoutputs_in} include/jemalloc/internal/jemalloc_preamble.h.in\"\ncfgoutputs_in=\"${cfgoutputs_in} test/test.sh.in\"\ncfgoutputs_in=\"${cfgoutputs_in} test/include/test/jemalloc_test.h.in\"\n\ncfgoutputs_out=\"Makefile\"\ncfgoutputs_out=\"${cfgoutputs_out} jemalloc.pc\"\ncfgoutputs_out=\"${cfgoutputs_out} doc/html.xsl\"\ncfgoutputs_out=\"${cfgoutputs_out} doc/manpages.xsl\"\ncfgoutputs_out=\"${cfgoutputs_out} doc/jemalloc.xml\"\ncfgoutputs_out=\"${cfgoutputs_out} include/jemalloc/jemalloc_macros.h\"\ncfgoutputs_out=\"${cfgoutputs_out} include/jemalloc/jemalloc_protos.h\"\ncfgoutputs_out=\"${cfgoutputs_out} include/jemalloc/jemalloc_typedefs.h\"\ncfgoutputs_out=\"${cfgoutputs_out} include/jemalloc/internal/jemalloc_preamble.h\"\ncfgoutputs_out=\"${cfgoutputs_out} test/test.sh\"\ncfgoutputs_out=\"${cfgoutputs_out} test/include/test/jemalloc_test.h\"\n\ncfgoutputs_tup=\"Makefile\"\ncfgoutputs_tup=\"${cfgoutputs_tup} jemalloc.pc:jemalloc.pc.in\"\ncfgoutputs_tup=\"${cfgoutputs_tup} doc/html.xsl:doc/html.xsl.in\"\ncfgoutputs_tup=\"${cfgoutputs_tup} doc/manpages.xsl:doc/manpages.xsl.in\"\ncfgoutputs_tup=\"${cfgoutputs_tup} doc/jemalloc.xml:doc/jemalloc.xml.in\"\ncfgoutputs_tup=\"${cfgoutputs_tup} include/jemalloc/jemalloc_macros.h:include/jemalloc/jemalloc_macros.h.in\"\ncfgoutputs_tup=\"${cfgoutputs_tup} include/jemalloc/jemalloc_protos.h:include/jemalloc/jemalloc_protos.h.in\"\ncfgoutputs_tup=\"${cfgoutputs_tup} include/jemalloc/jemalloc_typedefs.h:include/jemalloc/jemalloc_typedefs.h.in\"\ncfgoutputs_tup=\"${cfgoutputs_tup} include/jemalloc/internal/jemalloc_preamble.h\"\ncfgoutputs_tup=\"${cfgoutputs_tup} test/test.sh:test/test.sh.in\"\ncfgoutputs_tup=\"${cfgoutputs_tup} test/include/test/jemalloc_test.h:test/include/test/jemalloc_test.h.in\"\n\ncfghdrs_in=\"include/jemalloc/jemalloc_defs.h.in\"\ncfghdrs_in=\"${cfghdrs_in} include/jemalloc/internal/jemalloc_internal_defs.h.in\"\ncfghdrs_in=\"${cfghdrs_in} include/jemalloc/internal/private_symbols.sh\"\ncfghdrs_in=\"${cfghdrs_in} include/jemalloc/internal/private_namespace.sh\"\ncfghdrs_in=\"${cfghdrs_in} include/jemalloc/internal/public_namespace.sh\"\ncfghdrs_in=\"${cfghdrs_in} include/jemalloc/internal/public_unnamespace.sh\"\ncfghdrs_in=\"${cfghdrs_in} include/jemalloc/internal/size_classes.sh\"\ncfghdrs_in=\"${cfghdrs_in} include/jemalloc/jemalloc_rename.sh\"\ncfghdrs_in=\"${cfghdrs_in} include/jemalloc/jemalloc_mangle.sh\"\ncfghdrs_in=\"${cfghdrs_in} include/jemalloc/jemalloc.sh\"\ncfghdrs_in=\"${cfghdrs_in} test/include/test/jemalloc_test_defs.h.in\"\n\ncfghdrs_out=\"include/jemalloc/jemalloc_defs.h\"\ncfghdrs_out=\"${cfghdrs_out} include/jemalloc/jemalloc${install_suffix}.h\"\ncfghdrs_out=\"${cfghdrs_out} include/jemalloc/internal/private_symbols.awk\"\ncfghdrs_out=\"${cfghdrs_out} include/jemalloc/internal/private_symbols_jet.awk\"\ncfghdrs_out=\"${cfghdrs_out} include/jemalloc/internal/public_symbols.txt\"\ncfghdrs_out=\"${cfghdrs_out} include/jemalloc/internal/public_namespace.h\"\ncfghdrs_out=\"${cfghdrs_out} include/jemalloc/internal/public_unnamespace.h\"\ncfghdrs_out=\"${cfghdrs_out} include/jemalloc/internal/size_classes.h\"\ncfghdrs_out=\"${cfghdrs_out} include/jemalloc/jemalloc_protos_jet.h\"\ncfghdrs_out=\"${cfghdrs_out} include/jemalloc/jemalloc_rename.h\"\ncfghdrs_out=\"${cfghdrs_out} include/jemalloc/jemalloc_mangle.h\"\ncfghdrs_out=\"${cfghdrs_out} include/jemalloc/jemalloc_mangle_jet.h\"\ncfghdrs_out=\"${cfghdrs_out} include/jemalloc/internal/jemalloc_internal_defs.h\"\ncfghdrs_out=\"${cfghdrs_out} test/include/test/jemalloc_test_defs.h\"\n\ncfghdrs_tup=\"include/jemalloc/jemalloc_defs.h:include/jemalloc/jemalloc_defs.h.in\"\ncfghdrs_tup=\"${cfghdrs_tup} include/jemalloc/internal/jemalloc_internal_defs.h:include/jemalloc/internal/jemalloc_internal_defs.h.in\"\ncfghdrs_tup=\"${cfghdrs_tup} test/include/test/jemalloc_test_defs.h:test/include/test/jemalloc_test_defs.h.in\"\n\ndnl Do not compile with debugging by default.\nAC_ARG_ENABLE([debug],\n  [AS_HELP_STRING([--enable-debug],\n                  [Build debugging code])],\n[if test \"x$enable_debug\" = \"xno\" ; then\n  enable_debug=\"0\"\nelse\n  enable_debug=\"1\"\nfi\n],\n[enable_debug=\"0\"]\n)\nif test \"x$enable_debug\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_DEBUG], [ ])\nfi\nif test \"x$enable_debug\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_DEBUG], [ ])\nfi\nAC_SUBST([enable_debug])\n\ndnl Only optimize if not debugging.\nif test \"x$enable_debug\" = \"x0\" ; then\n  if test \"x$GCC\" = \"xyes\" ; then\n    JE_CFLAGS_ADD([-O3])\n    JE_CXXFLAGS_ADD([-O3])\n    JE_CFLAGS_ADD([-funroll-loops])\n  elif test \"x$je_cv_msvc\" = \"xyes\" ; then\n    JE_CFLAGS_ADD([-O2])\n    JE_CXXFLAGS_ADD([-O2])\n  else\n    JE_CFLAGS_ADD([-O])\n    JE_CXXFLAGS_ADD([-O])\n  fi\nfi\n\ndnl Enable statistics calculation by default.\nAC_ARG_ENABLE([stats],\n  [AS_HELP_STRING([--disable-stats],\n                  [Disable statistics calculation/reporting])],\n[if test \"x$enable_stats\" = \"xno\" ; then\n  enable_stats=\"0\"\nelse\n  enable_stats=\"1\"\nfi\n],\n[enable_stats=\"1\"]\n)\nif test \"x$enable_stats\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_STATS], [ ])\nfi\nAC_SUBST([enable_stats])\n\ndnl Do not enable profiling by default.\nAC_ARG_ENABLE([prof],\n  [AS_HELP_STRING([--enable-prof], [Enable allocation profiling])],\n[if test \"x$enable_prof\" = \"xno\" ; then\n  enable_prof=\"0\"\nelse\n  enable_prof=\"1\"\nfi\n],\n[enable_prof=\"0\"]\n)\nif test \"x$enable_prof\" = \"x1\" ; then\n  backtrace_method=\"\"\nelse\n  backtrace_method=\"N/A\"\nfi\n\nAC_ARG_ENABLE([prof-libunwind],\n  [AS_HELP_STRING([--enable-prof-libunwind], [Use libunwind for backtracing])],\n[if test \"x$enable_prof_libunwind\" = \"xno\" ; then\n  enable_prof_libunwind=\"0\"\nelse\n  enable_prof_libunwind=\"1\"\nfi\n],\n[enable_prof_libunwind=\"0\"]\n)\nAC_ARG_WITH([static_libunwind],\n  [AS_HELP_STRING([--with-static-libunwind=<libunwind.a>],\n  [Path to static libunwind library; use rather than dynamically linking])],\nif test \"x$with_static_libunwind\" = \"xno\" ; then\n  LUNWIND=\"-lunwind\"\nelse\n  if test ! -f \"$with_static_libunwind\" ; then\n    AC_MSG_ERROR([Static libunwind not found: $with_static_libunwind])\n  fi\n  LUNWIND=\"$with_static_libunwind\"\nfi,\n  LUNWIND=\"-lunwind\"\n)\nif test \"x$backtrace_method\" = \"x\" -a \"x$enable_prof_libunwind\" = \"x1\" ; then\n  AC_CHECK_HEADERS([libunwind.h], , [enable_prof_libunwind=\"0\"])\n  if test \"x$LUNWIND\" = \"x-lunwind\" ; then\n    AC_CHECK_LIB([unwind], [unw_backtrace], [JE_APPEND_VS(LIBS, $LUNWIND)],\n                 [enable_prof_libunwind=\"0\"])\n  else\n    JE_APPEND_VS(LIBS, $LUNWIND)\n  fi\n  if test \"x${enable_prof_libunwind}\" = \"x1\" ; then\n    backtrace_method=\"libunwind\"\n    AC_DEFINE([JEMALLOC_PROF_LIBUNWIND], [ ])\n  fi\nfi\n\nAC_ARG_ENABLE([prof-libgcc],\n  [AS_HELP_STRING([--disable-prof-libgcc],\n  [Do not use libgcc for backtracing])],\n[if test \"x$enable_prof_libgcc\" = \"xno\" ; then\n  enable_prof_libgcc=\"0\"\nelse\n  enable_prof_libgcc=\"1\"\nfi\n],\n[enable_prof_libgcc=\"1\"]\n)\nif test \"x$backtrace_method\" = \"x\" -a \"x$enable_prof_libgcc\" = \"x1\" \\\n     -a \"x$GCC\" = \"xyes\" ; then\n  AC_CHECK_HEADERS([unwind.h], , [enable_prof_libgcc=\"0\"])\n  if test \"x${enable_prof_libgcc}\" = \"x1\" ; then\n    AC_CHECK_LIB([gcc], [_Unwind_Backtrace], [JE_APPEND_VS(LIBS, -lgcc)], [enable_prof_libgcc=\"0\"])\n  fi\n  if test \"x${enable_prof_libgcc}\" = \"x1\" ; then\n    backtrace_method=\"libgcc\"\n    AC_DEFINE([JEMALLOC_PROF_LIBGCC], [ ])\n  fi\nelse\n  enable_prof_libgcc=\"0\"\nfi\n\nAC_ARG_ENABLE([prof-gcc],\n  [AS_HELP_STRING([--disable-prof-gcc],\n  [Do not use gcc intrinsics for backtracing])],\n[if test \"x$enable_prof_gcc\" = \"xno\" ; then\n  enable_prof_gcc=\"0\"\nelse\n  enable_prof_gcc=\"1\"\nfi\n],\n[enable_prof_gcc=\"1\"]\n)\nif test \"x$backtrace_method\" = \"x\" -a \"x$enable_prof_gcc\" = \"x1\" \\\n     -a \"x$GCC\" = \"xyes\" ; then\n  JE_CFLAGS_ADD([-fno-omit-frame-pointer])\n  backtrace_method=\"gcc intrinsics\"\n  AC_DEFINE([JEMALLOC_PROF_GCC], [ ])\nelse\n  enable_prof_gcc=\"0\"\nfi\n\nif test \"x$backtrace_method\" = \"x\" ; then\n  backtrace_method=\"none (disabling profiling)\"\n  enable_prof=\"0\"\nfi\nAC_MSG_CHECKING([configured backtracing method])\nAC_MSG_RESULT([$backtrace_method])\nif test \"x$enable_prof\" = \"x1\" ; then\n  dnl Heap profiling uses the log(3) function.\n  JE_APPEND_VS(LIBS, $LM)\n\n  AC_DEFINE([JEMALLOC_PROF], [ ])\nfi\nAC_SUBST([enable_prof])\n\ndnl Indicate whether adjacent virtual memory mappings automatically coalesce\ndnl (and fragment on demand).\nif test \"x${maps_coalesce}\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_MAPS_COALESCE], [ ])\nfi\n\ndnl Indicate whether to retain memory (rather than using munmap()) by default.\nif test \"x$default_retain\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_RETAIN], [ ])\nfi\n\ndnl Enable allocation from DSS if supported by the OS.\nhave_dss=\"1\"\ndnl Check whether the BSD/SUSv1 sbrk() exists.  If not, disable DSS support.\nAC_CHECK_FUNC([sbrk], [have_sbrk=\"1\"], [have_sbrk=\"0\"])\nif test \"x$have_sbrk\" = \"x1\" ; then\n  if test \"x$sbrk_deprecated\" = \"x1\" ; then\n    AC_MSG_RESULT([Disabling dss allocation because sbrk is deprecated])\n    have_dss=\"0\"\n  fi\nelse\n  have_dss=\"0\"\nfi\n\nif test \"x$have_dss\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_DSS], [ ])\nfi\n\ndnl Support the junk/zero filling option by default.\nAC_ARG_ENABLE([fill],\n  [AS_HELP_STRING([--disable-fill], [Disable support for junk/zero filling])],\n[if test \"x$enable_fill\" = \"xno\" ; then\n  enable_fill=\"0\"\nelse\n  enable_fill=\"1\"\nfi\n],\n[enable_fill=\"1\"]\n)\nif test \"x$enable_fill\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_FILL], [ ])\nfi\nAC_SUBST([enable_fill])\n\ndnl Disable utrace(2)-based tracing by default.\nAC_ARG_ENABLE([utrace],\n  [AS_HELP_STRING([--enable-utrace], [Enable utrace(2)-based tracing])],\n[if test \"x$enable_utrace\" = \"xno\" ; then\n  enable_utrace=\"0\"\nelse\n  enable_utrace=\"1\"\nfi\n],\n[enable_utrace=\"0\"]\n)\nJE_COMPILABLE([utrace(2)], [\n#include <sys/types.h>\n#include <sys/param.h>\n#include <sys/time.h>\n#include <sys/uio.h>\n#include <sys/ktrace.h>\n], [\n\tutrace((void *)0, 0);\n], [je_cv_utrace])\nif test \"x${je_cv_utrace}\" = \"xno\" ; then\n  enable_utrace=\"0\"\nfi\nif test \"x$enable_utrace\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_UTRACE], [ ])\nfi\nAC_SUBST([enable_utrace])\n\ndnl Do not support the xmalloc option by default.\nAC_ARG_ENABLE([xmalloc],\n  [AS_HELP_STRING([--enable-xmalloc], [Support xmalloc option])],\n[if test \"x$enable_xmalloc\" = \"xno\" ; then\n  enable_xmalloc=\"0\"\nelse\n  enable_xmalloc=\"1\"\nfi\n],\n[enable_xmalloc=\"0\"]\n)\nif test \"x$enable_xmalloc\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_XMALLOC], [ ])\nfi\nAC_SUBST([enable_xmalloc])\n\ndnl Support cache-oblivious allocation alignment by default.\nAC_ARG_ENABLE([cache-oblivious],\n  [AS_HELP_STRING([--disable-cache-oblivious],\n                  [Disable support for cache-oblivious allocation alignment])],\n[if test \"x$enable_cache_oblivious\" = \"xno\" ; then\n  enable_cache_oblivious=\"0\"\nelse\n  enable_cache_oblivious=\"1\"\nfi\n],\n[enable_cache_oblivious=\"1\"]\n)\nif test \"x$enable_cache_oblivious\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_CACHE_OBLIVIOUS], [ ])\nfi\nAC_SUBST([enable_cache_oblivious])\n\ndnl Do not log by default.\nAC_ARG_ENABLE([log],\n  [AS_HELP_STRING([--enable-log], [Support debug logging])],\n[if test \"x$enable_log\" = \"xno\" ; then\n  enable_log=\"0\"\nelse\n  enable_log=\"1\"\nfi\n],\n[enable_log=\"0\"]\n)\nif test \"x$enable_log\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_LOG], [ ])\nfi\nAC_SUBST([enable_log])\n\n\nJE_COMPILABLE([a program using __builtin_unreachable], [\nvoid foo (void) {\n  __builtin_unreachable();\n}\n], [\n\t{\n\t\tfoo();\n\t}\n], [je_cv_gcc_builtin_unreachable])\nif test \"x${je_cv_gcc_builtin_unreachable}\" = \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_INTERNAL_UNREACHABLE], [__builtin_unreachable])\nelse\n  AC_DEFINE([JEMALLOC_INTERNAL_UNREACHABLE], [abort])\nfi\n\ndnl ============================================================================\ndnl Check for  __builtin_ffsl(), then ffsl(3), and fail if neither are found.\ndnl One of those two functions should (theoretically) exist on all platforms\ndnl that jemalloc currently has a chance of functioning on without modification.\ndnl We additionally assume ffs[ll]() or __builtin_ffs[ll]() are defined if\ndnl ffsl() or __builtin_ffsl() are defined, respectively.\nJE_COMPILABLE([a program using __builtin_ffsl], [\n#include <stdio.h>\n#include <strings.h>\n#include <string.h>\n], [\n\t{\n\t\tint rv = __builtin_ffsl(0x08);\n\t\tprintf(\"%d\\n\", rv);\n\t}\n], [je_cv_gcc_builtin_ffsl])\nif test \"x${je_cv_gcc_builtin_ffsl}\" = \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_INTERNAL_FFSLL], [__builtin_ffsll])\n  AC_DEFINE([JEMALLOC_INTERNAL_FFSL], [__builtin_ffsl])\n  AC_DEFINE([JEMALLOC_INTERNAL_FFS], [__builtin_ffs])\nelse\n  JE_COMPILABLE([a program using ffsl], [\n  #include <stdio.h>\n  #include <strings.h>\n  #include <string.h>\n  ], [\n\t{\n\t\tint rv = ffsl(0x08);\n\t\tprintf(\"%d\\n\", rv);\n\t}\n  ], [je_cv_function_ffsl])\n  if test \"x${je_cv_function_ffsl}\" = \"xyes\" ; then\n    AC_DEFINE([JEMALLOC_INTERNAL_FFSLL], [ffsll])\n    AC_DEFINE([JEMALLOC_INTERNAL_FFSL], [ffsl])\n    AC_DEFINE([JEMALLOC_INTERNAL_FFS], [ffs])\n  else\n    AC_MSG_ERROR([Cannot build without ffsl(3) or __builtin_ffsl()])\n  fi\nfi\n\nAC_ARG_WITH([lg_quantum],\n  [AS_HELP_STRING([--with-lg-quantum=<lg-quantum>],\n   [Base 2 log of minimum allocation alignment])],\n  [LG_QUANTA=\"$with_lg_quantum\"],\n  [LG_QUANTA=\"3 4\"])\nif test \"x$with_lg_quantum\" != \"x\" ; then\n  AC_DEFINE_UNQUOTED([LG_QUANTUM], [$with_lg_quantum])\nfi\n\nAC_ARG_WITH([lg_page],\n  [AS_HELP_STRING([--with-lg-page=<lg-page>], [Base 2 log of system page size])],\n  [LG_PAGE=\"$with_lg_page\"], [LG_PAGE=\"detect\"])\nif test \"x$LG_PAGE\" = \"xdetect\"; then\n  AC_CACHE_CHECK([LG_PAGE],\n               [je_cv_lg_page],\n               AC_RUN_IFELSE([AC_LANG_PROGRAM(\n[[\n#include <strings.h>\n#ifdef _WIN32\n#include <windows.h>\n#else\n#include <unistd.h>\n#endif\n#include <stdio.h>\n]],\n[[\n    int result;\n    FILE *f;\n\n#ifdef _WIN32\n    SYSTEM_INFO si;\n    GetSystemInfo(&si);\n    result = si.dwPageSize;\n#else\n    result = sysconf(_SC_PAGESIZE);\n#endif\n    if (result == -1) {\n\treturn 1;\n    }\n    result = JEMALLOC_INTERNAL_FFSL(result) - 1;\n\n    f = fopen(\"conftest.out\", \"w\");\n    if (f == NULL) {\n\treturn 1;\n    }\n    fprintf(f, \"%d\", result);\n    fclose(f);\n\n    return 0;\n]])],\n                             [je_cv_lg_page=`cat conftest.out`],\n                             [je_cv_lg_page=undefined],\n                             [je_cv_lg_page=12]))\nfi\nif test \"x${je_cv_lg_page}\" != \"x\" ; then\n  LG_PAGE=\"${je_cv_lg_page}\"\nfi\nif test \"x${LG_PAGE}\" != \"xundefined\" ; then\n   AC_DEFINE_UNQUOTED([LG_PAGE], [$LG_PAGE])\nelse\n   AC_MSG_ERROR([cannot determine value for LG_PAGE])\nfi\n\nAC_ARG_WITH([lg_hugepage],\n  [AS_HELP_STRING([--with-lg-hugepage=<lg-hugepage>],\n   [Base 2 log of system huge page size])],\n  [je_cv_lg_hugepage=\"${with_lg_hugepage}\"],\n  [je_cv_lg_hugepage=\"\"])\nif test \"x${je_cv_lg_hugepage}\" = \"x\" ; then\n  dnl Look in /proc/meminfo (Linux-specific) for information on the default huge\n  dnl page size, if any.  The relevant line looks like:\n  dnl\n  dnl   Hugepagesize:       2048 kB\n  if test -e \"/proc/meminfo\" ; then\n    hpsk=[`cat /proc/meminfo 2>/dev/null | \\\n          grep -e '^Hugepagesize:[[:space:]]\\+[0-9]\\+[[:space:]]kB$' | \\\n          awk '{print $2}'`]\n    if test \"x${hpsk}\" != \"x\" ; then\n      je_cv_lg_hugepage=10\n      while test \"${hpsk}\" -gt 1 ; do\n        hpsk=\"$((hpsk / 2))\"\n        je_cv_lg_hugepage=\"$((je_cv_lg_hugepage + 1))\"\n      done\n    fi\n  fi\n\n  dnl Set default if unable to automatically configure.\n  if test \"x${je_cv_lg_hugepage}\" = \"x\" ; then\n    je_cv_lg_hugepage=21\n  fi\nfi\nif test \"x${LG_PAGE}\" != \"xundefined\" -a \\\n        \"${je_cv_lg_hugepage}\" -lt \"${LG_PAGE}\" ; then\n  AC_MSG_ERROR([Huge page size (2^${je_cv_lg_hugepage}) must be at least page size (2^${LG_PAGE})])\nfi\nAC_DEFINE_UNQUOTED([LG_HUGEPAGE], [${je_cv_lg_hugepage}])\n\nAC_ARG_WITH([lg_page_sizes],\n  [AS_HELP_STRING([--with-lg-page-sizes=<lg-page-sizes>],\n   [Base 2 logs of system page sizes to support])],\n  [LG_PAGE_SIZES=\"$with_lg_page_sizes\"], [LG_PAGE_SIZES=\"$LG_PAGE\"])\n\ndnl ============================================================================\ndnl jemalloc configuration.\ndnl\n\nAC_ARG_WITH([version],\n  [AS_HELP_STRING([--with-version=<major>.<minor>.<bugfix>-<nrev>-g<gid>],\n   [Version string])],\n  [\n    echo \"${with_version}\" | grep ['^[0-9]\\+\\.[0-9]\\+\\.[0-9]\\+-[0-9]\\+-g[0-9a-f]\\+$'] 2>&1 1>/dev/null\n    if test $? -eq 0 ; then\n      echo \"$with_version\" > \"${objroot}VERSION\"\n    else\n      echo \"${with_version}\" | grep ['^VERSION$'] 2>&1 1>/dev/null\n      if test $? -ne 0 ; then\n        AC_MSG_ERROR([${with_version} does not match <major>.<minor>.<bugfix>-<nrev>-g<gid> or VERSION])\n      fi\n    fi\n  ], [\n    dnl Set VERSION if source directory is inside a git repository.\n    if test \"x`test ! \\\"${srcroot}\\\" && cd \\\"${srcroot}\\\"; git rev-parse --is-inside-work-tree 2>/dev/null`\" = \"xtrue\" ; then\n      dnl Pattern globs aren't powerful enough to match both single- and\n      dnl double-digit version numbers, so iterate over patterns to support up\n      dnl to version 99.99.99 without any accidental matches.\n      for pattern in ['[0-9].[0-9].[0-9]' '[0-9].[0-9].[0-9][0-9]' \\\n                     '[0-9].[0-9][0-9].[0-9]' '[0-9].[0-9][0-9].[0-9][0-9]' \\\n                     '[0-9][0-9].[0-9].[0-9]' '[0-9][0-9].[0-9].[0-9][0-9]' \\\n                     '[0-9][0-9].[0-9][0-9].[0-9]' \\\n                     '[0-9][0-9].[0-9][0-9].[0-9][0-9]']; do\n        (test ! \"${srcroot}\" && cd \"${srcroot}\"; git describe --long --abbrev=40 --match=\"${pattern}\") > \"${objroot}VERSION.tmp\" 2>/dev/null\n        if test $? -eq 0 ; then\n          mv \"${objroot}VERSION.tmp\" \"${objroot}VERSION\"\n          break\n        fi\n      done\n    fi\n    rm -f \"${objroot}VERSION.tmp\"\n  ])\n\nif test ! -e \"${objroot}VERSION\" ; then\n  if test ! -e \"${srcroot}VERSION\" ; then\n    AC_MSG_RESULT(\n      [Missing VERSION file, and unable to generate it; creating bogus VERSION])\n    echo \"0.0.0-0-g0000000000000000000000000000000000000000\" > \"${objroot}VERSION\"\n  else\n    cp ${srcroot}VERSION ${objroot}VERSION\n  fi\nfi\njemalloc_version=`cat \"${objroot}VERSION\"`\njemalloc_version_major=`echo ${jemalloc_version} | tr \".g-\" \" \" | awk '{print [$]1}'`\njemalloc_version_minor=`echo ${jemalloc_version} | tr \".g-\" \" \" | awk '{print [$]2}'`\njemalloc_version_bugfix=`echo ${jemalloc_version} | tr \".g-\" \" \" | awk '{print [$]3}'`\njemalloc_version_nrev=`echo ${jemalloc_version} | tr \".g-\" \" \" | awk '{print [$]4}'`\njemalloc_version_gid=`echo ${jemalloc_version} | tr \".g-\" \" \" | awk '{print [$]5}'`\nAC_SUBST([jemalloc_version])\nAC_SUBST([jemalloc_version_major])\nAC_SUBST([jemalloc_version_minor])\nAC_SUBST([jemalloc_version_bugfix])\nAC_SUBST([jemalloc_version_nrev])\nAC_SUBST([jemalloc_version_gid])\n\ndnl ============================================================================\ndnl Configure pthreads.\n\nif test \"x$abi\" != \"xpecoff\" ; then\n  AC_DEFINE([JEMALLOC_HAVE_PTHREAD], [ ])\n  AC_CHECK_HEADERS([pthread.h], , [AC_MSG_ERROR([pthread.h is missing])])\n  dnl Some systems may embed pthreads functionality in libc; check for libpthread\n  dnl first, but try libc too before failing.\n  AC_CHECK_LIB([pthread], [pthread_create], [JE_APPEND_VS(LIBS, -lpthread)],\n               [AC_SEARCH_LIBS([pthread_create], , ,\n                               AC_MSG_ERROR([libpthread is missing]))])\n  wrap_syms=\"${wrap_syms} pthread_create\"\n  have_pthread=\"1\"\n  dnl Check if we have dlsym support.\n  have_dlsym=\"1\"\n  AC_CHECK_HEADERS([dlfcn.h],\n    AC_CHECK_FUNC([dlsym], [],\n      [AC_CHECK_LIB([dl], [dlsym], [LIBS=\"$LIBS -ldl\"], [have_dlsym=\"0\"])]),\n    [have_dlsym=\"0\"])\n  if test \"x$have_dlsym\" = \"x1\" ; then\n    AC_DEFINE([JEMALLOC_HAVE_DLSYM], [ ])\n  fi\n  JE_COMPILABLE([pthread_atfork(3)], [\n#include <pthread.h>\n], [\n  pthread_atfork((void *)0, (void *)0, (void *)0);\n], [je_cv_pthread_atfork])\n  if test \"x${je_cv_pthread_atfork}\" = \"xyes\" ; then\n    AC_DEFINE([JEMALLOC_HAVE_PTHREAD_ATFORK], [ ])\n  fi\n  dnl Check if pthread_setname_np is available with the expected API.\n  JE_COMPILABLE([pthread_setname_np(3)], [\n#include <pthread.h>\n], [\n  pthread_setname_np(pthread_self(), \"setname_test\");\n], [je_cv_pthread_setname_np])\n  if test \"x${je_cv_pthread_setname_np}\" = \"xyes\" ; then\n    AC_DEFINE([JEMALLOC_HAVE_PTHREAD_SETNAME_NP], [ ])\n  fi\nfi\n\nJE_APPEND_VS(CPPFLAGS, -D_REENTRANT)\n\ndnl Check whether clock_gettime(2) is in libc or librt.\nAC_SEARCH_LIBS([clock_gettime], [rt])\n\ndnl Cray wrapper compiler often adds `-lrt` when using `-static`. Check with\ndnl `-dynamic` as well in case a user tries to dynamically link in jemalloc\nif test \"x$je_cv_cray_prgenv_wrapper\" = \"xyes\" ; then\n  if test \"$ac_cv_search_clock_gettime\" != \"-lrt\"; then\n    JE_CFLAGS_SAVE()\n\n    unset ac_cv_search_clock_gettime\n    JE_CFLAGS_ADD([-dynamic])\n    AC_SEARCH_LIBS([clock_gettime], [rt])\n\n    JE_CFLAGS_RESTORE()\n  fi\nfi\n\ndnl check for CLOCK_MONOTONIC_COARSE (Linux-specific).\nJE_COMPILABLE([clock_gettime(CLOCK_MONOTONIC_COARSE, ...)], [\n#include <time.h>\n], [\n\tstruct timespec ts;\n\n\tclock_gettime(CLOCK_MONOTONIC_COARSE, &ts);\n], [je_cv_clock_monotonic_coarse])\nif test \"x${je_cv_clock_monotonic_coarse}\" = \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_HAVE_CLOCK_MONOTONIC_COARSE])\nfi\n\ndnl check for CLOCK_MONOTONIC.\nJE_COMPILABLE([clock_gettime(CLOCK_MONOTONIC, ...)], [\n#include <unistd.h>\n#include <time.h>\n], [\n\tstruct timespec ts;\n\n\tclock_gettime(CLOCK_MONOTONIC, &ts);\n#if !defined(_POSIX_MONOTONIC_CLOCK) || _POSIX_MONOTONIC_CLOCK < 0\n#  error _POSIX_MONOTONIC_CLOCK missing/invalid\n#endif\n], [je_cv_clock_monotonic])\nif test \"x${je_cv_clock_monotonic}\" = \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_HAVE_CLOCK_MONOTONIC])\nfi\n\ndnl Check for mach_absolute_time().\nJE_COMPILABLE([mach_absolute_time()], [\n#include <mach/mach_time.h>\n], [\n\tmach_absolute_time();\n], [je_cv_mach_absolute_time])\nif test \"x${je_cv_mach_absolute_time}\" = \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_HAVE_MACH_ABSOLUTE_TIME])\nfi\n\ndnl Use syscall(2) (if available) by default.\nAC_ARG_ENABLE([syscall],\n  [AS_HELP_STRING([--disable-syscall], [Disable use of syscall(2)])],\n[if test \"x$enable_syscall\" = \"xno\" ; then\n  enable_syscall=\"0\"\nelse\n  enable_syscall=\"1\"\nfi\n],\n[enable_syscall=\"1\"]\n)\nif test \"x$enable_syscall\" = \"x1\" ; then\n  dnl Check if syscall(2) is usable.  Treat warnings as errors, so that e.g. OS\n  dnl X 10.12's deprecation warning prevents use.\n  JE_CFLAGS_SAVE()\n  JE_CFLAGS_ADD([-Werror])\n  JE_COMPILABLE([syscall(2)], [\n#include <sys/syscall.h>\n#include <unistd.h>\n], [\n\tsyscall(SYS_write, 2, \"hello\", 5);\n],\n                [je_cv_syscall])\n  JE_CFLAGS_RESTORE()\n  if test \"x$je_cv_syscall\" = \"xyes\" ; then\n    AC_DEFINE([JEMALLOC_USE_SYSCALL], [ ])\n  fi\nfi\n\ndnl Check if the GNU-specific secure_getenv function exists.\nAC_CHECK_FUNC([secure_getenv],\n              [have_secure_getenv=\"1\"],\n              [have_secure_getenv=\"0\"]\n             )\nif test \"x$have_secure_getenv\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_HAVE_SECURE_GETENV], [ ])\nfi\n\ndnl Check if the GNU-specific sched_getcpu function exists.\nAC_CHECK_FUNC([sched_getcpu],\n              [have_sched_getcpu=\"1\"],\n              [have_sched_getcpu=\"0\"]\n             )\nif test \"x$have_sched_getcpu\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_HAVE_SCHED_GETCPU], [ ])\nfi\n\ndnl Check if the GNU-specific sched_setaffinity function exists.\nAC_CHECK_FUNC([sched_setaffinity],\n              [have_sched_setaffinity=\"1\"],\n              [have_sched_setaffinity=\"0\"]\n             )\nif test \"x$have_sched_setaffinity\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_HAVE_SCHED_SETAFFINITY], [ ])\nfi\n\ndnl Check if the Solaris/BSD issetugid function exists.\nAC_CHECK_FUNC([issetugid],\n              [have_issetugid=\"1\"],\n              [have_issetugid=\"0\"]\n             )\nif test \"x$have_issetugid\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_HAVE_ISSETUGID], [ ])\nfi\n\ndnl Check whether the BSD-specific _malloc_thread_cleanup() exists.  If so, use\ndnl it rather than pthreads TSD cleanup functions to support cleanup during\ndnl thread exit, in order to avoid pthreads library recursion during\ndnl bootstrapping.\nAC_CHECK_FUNC([_malloc_thread_cleanup],\n              [have__malloc_thread_cleanup=\"1\"],\n              [have__malloc_thread_cleanup=\"0\"]\n             )\nif test \"x$have__malloc_thread_cleanup\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_MALLOC_THREAD_CLEANUP], [ ])\n  wrap_syms=\"${wrap_syms} _malloc_thread_cleanup\"\n  force_tls=\"1\"\nfi\n\ndnl Check whether the BSD-specific _pthread_mutex_init_calloc_cb() exists.  If\ndnl so, mutex initialization causes allocation, and we need to implement this\ndnl callback function in order to prevent recursive allocation.\nAC_CHECK_FUNC([_pthread_mutex_init_calloc_cb],\n              [have__pthread_mutex_init_calloc_cb=\"1\"],\n              [have__pthread_mutex_init_calloc_cb=\"0\"]\n             )\nif test \"x$have__pthread_mutex_init_calloc_cb\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_MUTEX_INIT_CB])\n  wrap_syms=\"${wrap_syms} _malloc_prefork _malloc_postfork\"\nfi\n\ndnl Disable lazy locking by default.\nAC_ARG_ENABLE([lazy_lock],\n  [AS_HELP_STRING([--enable-lazy-lock],\n  [Enable lazy locking (only lock when multi-threaded)])],\n[if test \"x$enable_lazy_lock\" = \"xno\" ; then\n  enable_lazy_lock=\"0\"\nelse\n  enable_lazy_lock=\"1\"\nfi\n],\n[enable_lazy_lock=\"\"]\n)\nif test \"x${enable_lazy_lock}\" = \"x\" ; then\n  if test \"x${force_lazy_lock}\" = \"x1\" ; then\n    AC_MSG_RESULT([Forcing lazy-lock to avoid allocator/threading bootstrap issues])\n    enable_lazy_lock=\"1\"\n  else\n    enable_lazy_lock=\"0\"\n  fi\nfi\nif test \"x${enable_lazy_lock}\" = \"x1\" -a \"x${abi}\" = \"xpecoff\" ; then\n  AC_MSG_RESULT([Forcing no lazy-lock because thread creation monitoring is unimplemented])\n  enable_lazy_lock=\"0\"\nfi\nif test \"x$enable_lazy_lock\" = \"x1\" ; then\n  if test \"x$have_dlsym\" = \"x1\" ; then\n    AC_DEFINE([JEMALLOC_LAZY_LOCK], [ ])\n  else\n    AC_MSG_ERROR([Missing dlsym support: lazy-lock cannot be enabled.])\n  fi\nfi\nAC_SUBST([enable_lazy_lock])\n\ndnl Automatically configure TLS.\nif test \"x${force_tls}\" = \"x1\" ; then\n  enable_tls=\"1\"\nelif test \"x${force_tls}\" = \"x0\" ; then\n  enable_tls=\"0\"\nelse\n  enable_tls=\"1\"\nfi\nif test \"x${enable_tls}\" = \"x1\" ; then\nAC_MSG_CHECKING([for TLS])\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM(\n[[\n    __thread int x;\n]], [[\n    x = 42;\n\n    return 0;\n]])],\n              AC_MSG_RESULT([yes]),\n              AC_MSG_RESULT([no])\n              enable_tls=\"0\")\nelse\n  enable_tls=\"0\"\nfi\nAC_SUBST([enable_tls])\nif test \"x${enable_tls}\" = \"x1\" ; then\n  AC_DEFINE_UNQUOTED([JEMALLOC_TLS], [ ])\nfi\n\ndnl ============================================================================\ndnl Check for C11 atomics.\n\nJE_COMPILABLE([C11 atomics], [\n#include <stdint.h>\n#if (__STDC_VERSION__ >= 201112L) && !defined(__STDC_NO_ATOMICS__)\n#include <stdatomic.h>\n#else\n#error Atomics not available\n#endif\n], [\n    uint64_t *p = (uint64_t *)0;\n    uint64_t x = 1;\n    volatile atomic_uint_least64_t *a = (volatile atomic_uint_least64_t *)p;\n    uint64_t r = atomic_fetch_add(a, x) + x;\n    return r == 0;\n], [je_cv_c11_atomics])\nif test \"x${je_cv_c11_atomics}\" = \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_C11_ATOMICS])\nfi\n\ndnl ============================================================================\ndnl Check for GCC-style __atomic atomics.\n\nJE_COMPILABLE([GCC __atomic atomics], [\n], [\n    int x = 0;\n    int val = 1;\n    int y = __atomic_fetch_add(&x, val, __ATOMIC_RELAXED);\n    int after_add = x;\n    return after_add == 1;\n], [je_cv_gcc_atomic_atomics])\nif test \"x${je_cv_gcc_atomic_atomics}\" = \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_GCC_ATOMIC_ATOMICS])\nfi\n\ndnl ============================================================================\ndnl Check for GCC-style __sync atomics.\n\nJE_COMPILABLE([GCC __sync atomics], [\n], [\n    int x = 0;\n    int before_add = __sync_fetch_and_add(&x, 1);\n    int after_add = x;\n    return (before_add == 0) && (after_add == 1);\n], [je_cv_gcc_sync_atomics])\nif test \"x${je_cv_gcc_sync_atomics}\" = \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_GCC_SYNC_ATOMICS])\nfi\n\ndnl ============================================================================\ndnl Check for atomic(3) operations as provided on Darwin.\ndnl We need this not for the atomic operations (which are provided above), but\ndnl rather for the OSSpinLock type it exposes.\n\nJE_COMPILABLE([Darwin OSAtomic*()], [\n#include <libkern/OSAtomic.h>\n#include <inttypes.h>\n], [\n\t{\n\t\tint32_t x32 = 0;\n\t\tvolatile int32_t *x32p = &x32;\n\t\tOSAtomicAdd32(1, x32p);\n\t}\n\t{\n\t\tint64_t x64 = 0;\n\t\tvolatile int64_t *x64p = &x64;\n\t\tOSAtomicAdd64(1, x64p);\n\t}\n], [je_cv_osatomic])\nif test \"x${je_cv_osatomic}\" = \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_OSATOMIC], [ ])\nfi\n\ndnl ============================================================================\ndnl Check for madvise(2).\n\nJE_COMPILABLE([madvise(2)], [\n#include <sys/mman.h>\n], [\n\tmadvise((void *)0, 0, 0);\n], [je_cv_madvise])\nif test \"x${je_cv_madvise}\" = \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_HAVE_MADVISE], [ ])\n\n  dnl Check for madvise(..., MADV_FREE).\n  JE_COMPILABLE([madvise(..., MADV_FREE)], [\n#include <sys/mman.h>\n], [\n\tmadvise((void *)0, 0, MADV_FREE);\n], [je_cv_madv_free])\n  if test \"x${je_cv_madv_free}\" = \"xyes\" ; then\n    AC_DEFINE([JEMALLOC_PURGE_MADVISE_FREE], [ ])\n  elif test \"x${je_cv_madvise}\" = \"xyes\" ; then\n    case \"${host_cpu}\" in i686|x86_64)\n        case \"${host}\" in *-*-linux*)\n            AC_DEFINE([JEMALLOC_PURGE_MADVISE_FREE], [ ])\n            AC_DEFINE([JEMALLOC_DEFINE_MADVISE_FREE], [ ])\n\t    ;;\n        esac\n        ;;\n    esac\n  fi\n\n  dnl Check for madvise(..., MADV_DONTNEED).\n  JE_COMPILABLE([madvise(..., MADV_DONTNEED)], [\n#include <sys/mman.h>\n], [\n\tmadvise((void *)0, 0, MADV_DONTNEED);\n], [je_cv_madv_dontneed])\n  if test \"x${je_cv_madv_dontneed}\" = \"xyes\" ; then\n    AC_DEFINE([JEMALLOC_PURGE_MADVISE_DONTNEED], [ ])\n  fi\n\n  dnl Check for madvise(..., MADV_DO[NT]DUMP).\n  JE_COMPILABLE([madvise(..., MADV_DO[[NT]]DUMP)], [\n#include <sys/mman.h>\n], [\n\tmadvise((void *)0, 0, MADV_DONTDUMP);\n\tmadvise((void *)0, 0, MADV_DODUMP);\n], [je_cv_madv_dontdump])\n  if test \"x${je_cv_madv_dontdump}\" = \"xyes\" ; then\n    AC_DEFINE([JEMALLOC_MADVISE_DONTDUMP], [ ])\n  fi\n \n  dnl Check for madvise(..., MADV_[NO]HUGEPAGE).\n  JE_COMPILABLE([madvise(..., MADV_[[NO]]HUGEPAGE)], [\n#include <sys/mman.h>\n], [\n\tmadvise((void *)0, 0, MADV_HUGEPAGE);\n\tmadvise((void *)0, 0, MADV_NOHUGEPAGE);\n], [je_cv_thp])\ncase \"${host_cpu}\" in\n  arm*)\n    ;;\n  *)\n  if test \"x${je_cv_thp}\" = \"xyes\" ; then\n    AC_DEFINE([JEMALLOC_HAVE_MADVISE_HUGE], [ ])\n  fi\n  ;;\nesac\nfi\n\ndnl ============================================================================\ndnl Check whether __sync_{add,sub}_and_fetch() are available despite\ndnl __GCC_HAVE_SYNC_COMPARE_AND_SWAP_n macros being undefined.\n\nAC_DEFUN([JE_SYNC_COMPARE_AND_SWAP_CHECK],[\n  AC_CACHE_CHECK([whether to force $1-bit __sync_{add,sub}_and_fetch()],\n               [je_cv_sync_compare_and_swap_$2],\n               [AC_LINK_IFELSE([AC_LANG_PROGRAM([\n                                                 #include <stdint.h>\n                                                ],\n                                                [\n                                                 #ifndef __GCC_HAVE_SYNC_COMPARE_AND_SWAP_$2\n                                                 {\n                                                    uint$1_t x$1 = 0;\n                                                    __sync_add_and_fetch(&x$1, 42);\n                                                    __sync_sub_and_fetch(&x$1, 1);\n                                                 }\n                                                 #else\n                                                 #error __GCC_HAVE_SYNC_COMPARE_AND_SWAP_$2 is defined, no need to force\n                                                 #endif\n                                                ])],\n                               [je_cv_sync_compare_and_swap_$2=yes],\n                               [je_cv_sync_compare_and_swap_$2=no])])\n\n  if test \"x${je_cv_sync_compare_and_swap_$2}\" = \"xyes\" ; then\n    AC_DEFINE([JE_FORCE_SYNC_COMPARE_AND_SWAP_$2], [ ])\n  fi\n])\n\nif test \"x${je_cv_atomic9}\" != \"xyes\" -a \"x${je_cv_osatomic}\" != \"xyes\" ; then\n  JE_SYNC_COMPARE_AND_SWAP_CHECK(32, 4)\n  JE_SYNC_COMPARE_AND_SWAP_CHECK(64, 8)\nfi\n\ndnl ============================================================================\ndnl Check for __builtin_clz() and __builtin_clzl().\n\nAC_CACHE_CHECK([for __builtin_clz],\n               [je_cv_builtin_clz],\n               [AC_LINK_IFELSE([AC_LANG_PROGRAM([],\n                                                [\n                                                {\n                                                        unsigned x = 0;\n                                                        int y = __builtin_clz(x);\n                                                }\n                                                {\n                                                        unsigned long x = 0;\n                                                        int y = __builtin_clzl(x);\n                                                }\n                                                ])],\n                               [je_cv_builtin_clz=yes],\n                               [je_cv_builtin_clz=no])])\n\nif test \"x${je_cv_builtin_clz}\" = \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_HAVE_BUILTIN_CLZ], [ ])\nfi\n\ndnl ============================================================================\ndnl Check for os_unfair_lock operations as provided on Darwin.\n\nJE_COMPILABLE([Darwin os_unfair_lock_*()], [\n#include <os/lock.h>\n#include <AvailabilityMacros.h>\n], [\n\t#if MAC_OS_X_VERSION_MIN_REQUIRED < 101200\n\t#error \"os_unfair_lock is not supported\"\n\t#else\n\tos_unfair_lock lock = OS_UNFAIR_LOCK_INIT;\n\tos_unfair_lock_lock(&lock);\n\tos_unfair_lock_unlock(&lock);\n\t#endif\n], [je_cv_os_unfair_lock])\nif test \"x${je_cv_os_unfair_lock}\" = \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_OS_UNFAIR_LOCK], [ ])\nfi\n\ndnl ============================================================================\ndnl Check for spinlock(3) operations as provided on Darwin.\n\nJE_COMPILABLE([Darwin OSSpin*()], [\n#include <libkern/OSAtomic.h>\n#include <inttypes.h>\n], [\n\tOSSpinLock lock = 0;\n\tOSSpinLockLock(&lock);\n\tOSSpinLockUnlock(&lock);\n], [je_cv_osspin])\nif test \"x${je_cv_osspin}\" = \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_OSSPIN], [ ])\nfi\n\ndnl ============================================================================\ndnl Darwin-related configuration.\n\nAC_ARG_ENABLE([zone-allocator],\n  [AS_HELP_STRING([--disable-zone-allocator],\n                  [Disable zone allocator for Darwin])],\n[if test \"x$enable_zone_allocator\" = \"xno\" ; then\n  enable_zone_allocator=\"0\"\nelse\n  enable_zone_allocator=\"1\"\nfi\n],\n[if test \"x${abi}\" = \"xmacho\"; then\n  enable_zone_allocator=\"1\"\nfi\n]\n)\nAC_SUBST([enable_zone_allocator])\n\nif test \"x${enable_zone_allocator}\" = \"x1\" ; then\n  if test \"x${abi}\" != \"xmacho\"; then\n    AC_MSG_ERROR([--enable-zone-allocator is only supported on Darwin])\n  fi\n  AC_DEFINE([JEMALLOC_ZONE], [ ])\nfi\n\ndnl ============================================================================\ndnl Use initial-exec TLS by default.\nAC_ARG_ENABLE([initial-exec-tls],\n  [AS_HELP_STRING([--disable-initial-exec-tls],\n                  [Disable the initial-exec tls model])],\n[if test \"x$enable_initial_exec_tls\" = \"xno\" ; then\n  enable_initial_exec_tls=\"0\"\nelse\n  enable_initial_exec_tls=\"1\"\nfi\n],\n[enable_initial_exec_tls=\"1\"]\n)\nAC_SUBST([enable_initial_exec_tls])\n\nif test \"x${je_cv_tls_model}\" = \"xyes\" -a \\\n       \"x${enable_initial_exec_tls}\" = \"x1\" ; then\n  AC_DEFINE([JEMALLOC_TLS_MODEL],\n            [__attribute__((tls_model(\"initial-exec\")))])\nelse\n  AC_DEFINE([JEMALLOC_TLS_MODEL], [ ])\nfi\n\ndnl ============================================================================\ndnl Enable background threads if possible.\n\nif test \"x${have_pthread}\" = \"x1\" -a \"x${have_dlsym}\" = \"x1\" \\\n    -a \"x${je_cv_os_unfair_lock}\" != \"xyes\" \\\n    -a \"x${je_cv_osspin}\" != \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_BACKGROUND_THREAD])\nfi\n\ndnl ============================================================================\ndnl Check for glibc malloc hooks\n\nJE_COMPILABLE([glibc malloc hook], [\n#include <stddef.h>\n\nextern void (* __free_hook)(void *ptr);\nextern void *(* __malloc_hook)(size_t size);\nextern void *(* __realloc_hook)(void *ptr, size_t size);\n], [\n  void *ptr = 0L;\n  if (__malloc_hook) ptr = __malloc_hook(1);\n  if (__realloc_hook) ptr = __realloc_hook(ptr, 2);\n  if (__free_hook && ptr) __free_hook(ptr);\n], [je_cv_glibc_malloc_hook])\nif test \"x${je_cv_glibc_malloc_hook}\" = \"xyes\" ; then\n  if test \"x${JEMALLOC_PREFIX}\" = \"x\" ; then\n    AC_DEFINE([JEMALLOC_GLIBC_MALLOC_HOOK], [ ])\n    wrap_syms=\"${wrap_syms} __free_hook __malloc_hook __realloc_hook\"\n  fi\nfi\n\nJE_COMPILABLE([glibc memalign hook], [\n#include <stddef.h>\n\nextern void *(* __memalign_hook)(size_t alignment, size_t size);\n], [\n  void *ptr = 0L;\n  if (__memalign_hook) ptr = __memalign_hook(16, 7);\n], [je_cv_glibc_memalign_hook])\nif test \"x${je_cv_glibc_memalign_hook}\" = \"xyes\" ; then\n  if test \"x${JEMALLOC_PREFIX}\" = \"x\" ; then\n    AC_DEFINE([JEMALLOC_GLIBC_MEMALIGN_HOOK], [ ])\n    wrap_syms=\"${wrap_syms} __memalign_hook\"\n  fi\nfi\n\nJE_COMPILABLE([pthreads adaptive mutexes], [\n#include <pthread.h>\n], [\n  pthread_mutexattr_t attr;\n  pthread_mutexattr_init(&attr);\n  pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_ADAPTIVE_NP);\n  pthread_mutexattr_destroy(&attr);\n], [je_cv_pthread_mutex_adaptive_np])\nif test \"x${je_cv_pthread_mutex_adaptive_np}\" = \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_HAVE_PTHREAD_MUTEX_ADAPTIVE_NP], [ ])\nfi\n\nJE_CFLAGS_SAVE()\nJE_CFLAGS_ADD([-D_GNU_SOURCE])\nJE_CFLAGS_ADD([-Werror])\nJE_CFLAGS_ADD([-herror_on_warning])\nJE_COMPILABLE([strerror_r returns char with gnu source], [\n#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n], [\n  char *buffer = (char *) malloc(100);\n  char *error = strerror_r(EINVAL, buffer, 100);\n  printf(\"%s\\n\", error);\n], [je_cv_strerror_r_returns_char_with_gnu_source])\nJE_CFLAGS_RESTORE()\nif test \"x${je_cv_strerror_r_returns_char_with_gnu_source}\" = \"xyes\" ; then\n  AC_DEFINE([JEMALLOC_STRERROR_R_RETURNS_CHAR_WITH_GNU_SOURCE], [ ])\nfi\n\ndnl ============================================================================\ndnl Check for typedefs, structures, and compiler characteristics.\nAC_HEADER_STDBOOL\n\ndnl ============================================================================\ndnl Define commands that generate output files.\n\nAC_CONFIG_COMMANDS([include/jemalloc/internal/public_symbols.txt], [\n  f=\"${objroot}include/jemalloc/internal/public_symbols.txt\"\n  mkdir -p \"${objroot}include/jemalloc/internal\"\n  cp /dev/null \"${f}\"\n  for nm in `echo ${mangling_map} |tr ',' ' '` ; do\n    n=`echo ${nm} |tr ':' ' ' |awk '{print $[]1}'`\n    m=`echo ${nm} |tr ':' ' ' |awk '{print $[]2}'`\n    echo \"${n}:${m}\" >> \"${f}\"\n    dnl Remove name from public_syms so that it isn't redefined later.\n    public_syms=`for sym in ${public_syms}; do echo \"${sym}\"; done |grep -v \"^${n}\\$\" |tr '\\n' ' '`\n  done\n  for sym in ${public_syms} ; do\n    n=\"${sym}\"\n    m=\"${JEMALLOC_PREFIX}${sym}\"\n    echo \"${n}:${m}\" >> \"${f}\"\n  done\n], [\n  srcdir=\"${srcdir}\"\n  objroot=\"${objroot}\"\n  mangling_map=\"${mangling_map}\"\n  public_syms=\"${public_syms}\"\n  JEMALLOC_PREFIX=\"${JEMALLOC_PREFIX}\"\n])\nAC_CONFIG_COMMANDS([include/jemalloc/internal/private_symbols.awk], [\n  f=\"${objroot}include/jemalloc/internal/private_symbols.awk\"\n  mkdir -p \"${objroot}include/jemalloc/internal\"\n  export_syms=`for sym in ${public_syms}; do echo \"${JEMALLOC_PREFIX}${sym}\"; done; for sym in ${wrap_syms}; do echo \"${sym}\"; done;`\n  \"${srcdir}/include/jemalloc/internal/private_symbols.sh\" \"${SYM_PREFIX}\" ${export_syms} > \"${objroot}include/jemalloc/internal/private_symbols.awk\"\n], [\n  srcdir=\"${srcdir}\"\n  objroot=\"${objroot}\"\n  public_syms=\"${public_syms}\"\n  wrap_syms=\"${wrap_syms}\"\n  SYM_PREFIX=\"${SYM_PREFIX}\"\n  JEMALLOC_PREFIX=\"${JEMALLOC_PREFIX}\"\n])\nAC_CONFIG_COMMANDS([include/jemalloc/internal/private_symbols_jet.awk], [\n  f=\"${objroot}include/jemalloc/internal/private_symbols_jet.awk\"\n  mkdir -p \"${objroot}include/jemalloc/internal\"\n  export_syms=`for sym in ${public_syms}; do echo \"jet_${sym}\"; done; for sym in ${wrap_syms}; do echo \"${sym}\"; done;`\n  \"${srcdir}/include/jemalloc/internal/private_symbols.sh\" \"${SYM_PREFIX}\" ${export_syms} > \"${objroot}include/jemalloc/internal/private_symbols_jet.awk\"\n], [\n  srcdir=\"${srcdir}\"\n  objroot=\"${objroot}\"\n  public_syms=\"${public_syms}\"\n  wrap_syms=\"${wrap_syms}\"\n  SYM_PREFIX=\"${SYM_PREFIX}\"\n])\nAC_CONFIG_COMMANDS([include/jemalloc/internal/public_namespace.h], [\n  mkdir -p \"${objroot}include/jemalloc/internal\"\n  \"${srcdir}/include/jemalloc/internal/public_namespace.sh\" \"${objroot}include/jemalloc/internal/public_symbols.txt\" > \"${objroot}include/jemalloc/internal/public_namespace.h\"\n], [\n  srcdir=\"${srcdir}\"\n  objroot=\"${objroot}\"\n])\nAC_CONFIG_COMMANDS([include/jemalloc/internal/public_unnamespace.h], [\n  mkdir -p \"${objroot}include/jemalloc/internal\"\n  \"${srcdir}/include/jemalloc/internal/public_unnamespace.sh\" \"${objroot}include/jemalloc/internal/public_symbols.txt\" > \"${objroot}include/jemalloc/internal/public_unnamespace.h\"\n], [\n  srcdir=\"${srcdir}\"\n  objroot=\"${objroot}\"\n])\nAC_CONFIG_COMMANDS([include/jemalloc/internal/size_classes.h], [\n  mkdir -p \"${objroot}include/jemalloc/internal\"\n  \"${SHELL}\" \"${srcdir}/include/jemalloc/internal/size_classes.sh\" \"${LG_QUANTA}\" 3 \"${LG_PAGE_SIZES}\" 2 > \"${objroot}include/jemalloc/internal/size_classes.h\"\n], [\n  SHELL=\"${SHELL}\"\n  srcdir=\"${srcdir}\"\n  objroot=\"${objroot}\"\n  LG_QUANTA=\"${LG_QUANTA}\"\n  LG_PAGE_SIZES=\"${LG_PAGE_SIZES}\"\n])\nAC_CONFIG_COMMANDS([include/jemalloc/jemalloc_protos_jet.h], [\n  mkdir -p \"${objroot}include/jemalloc\"\n  cat \"${srcdir}/include/jemalloc/jemalloc_protos.h.in\" | sed -e 's/@je_@/jet_/g' > \"${objroot}include/jemalloc/jemalloc_protos_jet.h\"\n], [\n  srcdir=\"${srcdir}\"\n  objroot=\"${objroot}\"\n])\nAC_CONFIG_COMMANDS([include/jemalloc/jemalloc_rename.h], [\n  mkdir -p \"${objroot}include/jemalloc\"\n  \"${srcdir}/include/jemalloc/jemalloc_rename.sh\" \"${objroot}include/jemalloc/internal/public_symbols.txt\" > \"${objroot}include/jemalloc/jemalloc_rename.h\"\n], [\n  srcdir=\"${srcdir}\"\n  objroot=\"${objroot}\"\n])\nAC_CONFIG_COMMANDS([include/jemalloc/jemalloc_mangle.h], [\n  mkdir -p \"${objroot}include/jemalloc\"\n  \"${srcdir}/include/jemalloc/jemalloc_mangle.sh\" \"${objroot}include/jemalloc/internal/public_symbols.txt\" je_ > \"${objroot}include/jemalloc/jemalloc_mangle.h\"\n], [\n  srcdir=\"${srcdir}\"\n  objroot=\"${objroot}\"\n])\nAC_CONFIG_COMMANDS([include/jemalloc/jemalloc_mangle_jet.h], [\n  mkdir -p \"${objroot}include/jemalloc\"\n  \"${srcdir}/include/jemalloc/jemalloc_mangle.sh\" \"${objroot}include/jemalloc/internal/public_symbols.txt\" jet_ > \"${objroot}include/jemalloc/jemalloc_mangle_jet.h\"\n], [\n  srcdir=\"${srcdir}\"\n  objroot=\"${objroot}\"\n])\nAC_CONFIG_COMMANDS([include/jemalloc/jemalloc.h], [\n  mkdir -p \"${objroot}include/jemalloc\"\n  \"${srcdir}/include/jemalloc/jemalloc.sh\" \"${objroot}\" > \"${objroot}include/jemalloc/jemalloc${install_suffix}.h\"\n], [\n  srcdir=\"${srcdir}\"\n  objroot=\"${objroot}\"\n  install_suffix=\"${install_suffix}\"\n])\n\ndnl Process .in files.\nAC_SUBST([cfghdrs_in])\nAC_SUBST([cfghdrs_out])\nAC_CONFIG_HEADERS([$cfghdrs_tup])\n\ndnl ============================================================================\ndnl Generate outputs.\n\nAC_CONFIG_FILES([$cfgoutputs_tup config.stamp bin/jemalloc-config bin/jemalloc.sh bin/jeprof])\nAC_SUBST([cfgoutputs_in])\nAC_SUBST([cfgoutputs_out])\nAC_OUTPUT\n\ndnl ============================================================================\ndnl Print out the results of configuration.\nAC_MSG_RESULT([===============================================================================])\nAC_MSG_RESULT([jemalloc version   : ${jemalloc_version}])\nAC_MSG_RESULT([library revision   : ${rev}])\nAC_MSG_RESULT([])\nAC_MSG_RESULT([CONFIG             : ${CONFIG}])\nAC_MSG_RESULT([CC                 : ${CC}])\nAC_MSG_RESULT([CONFIGURE_CFLAGS   : ${CONFIGURE_CFLAGS}])\nAC_MSG_RESULT([SPECIFIED_CFLAGS   : ${SPECIFIED_CFLAGS}])\nAC_MSG_RESULT([EXTRA_CFLAGS       : ${EXTRA_CFLAGS}])\nAC_MSG_RESULT([CPPFLAGS           : ${CPPFLAGS}])\nAC_MSG_RESULT([CXX                : ${CXX}])\nAC_MSG_RESULT([CONFIGURE_CXXFLAGS : ${CONFIGURE_CXXFLAGS}])\nAC_MSG_RESULT([SPECIFIED_CXXFLAGS : ${SPECIFIED_CXXFLAGS}])\nAC_MSG_RESULT([EXTRA_CXXFLAGS     : ${EXTRA_CXXFLAGS}])\nAC_MSG_RESULT([LDFLAGS            : ${LDFLAGS}])\nAC_MSG_RESULT([EXTRA_LDFLAGS      : ${EXTRA_LDFLAGS}])\nAC_MSG_RESULT([DSO_LDFLAGS        : ${DSO_LDFLAGS}])\nAC_MSG_RESULT([LIBS               : ${LIBS}])\nAC_MSG_RESULT([RPATH_EXTRA        : ${RPATH_EXTRA}])\nAC_MSG_RESULT([])\nAC_MSG_RESULT([XSLTPROC           : ${XSLTPROC}])\nAC_MSG_RESULT([XSLROOT            : ${XSLROOT}])\nAC_MSG_RESULT([])\nAC_MSG_RESULT([PREFIX             : ${PREFIX}])\nAC_MSG_RESULT([BINDIR             : ${BINDIR}])\nAC_MSG_RESULT([DATADIR            : ${DATADIR}])\nAC_MSG_RESULT([INCLUDEDIR         : ${INCLUDEDIR}])\nAC_MSG_RESULT([LIBDIR             : ${LIBDIR}])\nAC_MSG_RESULT([MANDIR             : ${MANDIR}])\nAC_MSG_RESULT([])\nAC_MSG_RESULT([srcroot            : ${srcroot}])\nAC_MSG_RESULT([abs_srcroot        : ${abs_srcroot}])\nAC_MSG_RESULT([objroot            : ${objroot}])\nAC_MSG_RESULT([abs_objroot        : ${abs_objroot}])\nAC_MSG_RESULT([])\nAC_MSG_RESULT([JEMALLOC_PREFIX    : ${JEMALLOC_PREFIX}])\nAC_MSG_RESULT([JEMALLOC_PRIVATE_NAMESPACE])\nAC_MSG_RESULT([                   : ${JEMALLOC_PRIVATE_NAMESPACE}])\nAC_MSG_RESULT([install_suffix     : ${install_suffix}])\nAC_MSG_RESULT([malloc_conf        : ${config_malloc_conf}])\nAC_MSG_RESULT([autogen            : ${enable_autogen}])\nAC_MSG_RESULT([debug              : ${enable_debug}])\nAC_MSG_RESULT([stats              : ${enable_stats}])\nAC_MSG_RESULT([prof               : ${enable_prof}])\nAC_MSG_RESULT([prof-libunwind     : ${enable_prof_libunwind}])\nAC_MSG_RESULT([prof-libgcc        : ${enable_prof_libgcc}])\nAC_MSG_RESULT([prof-gcc           : ${enable_prof_gcc}])\nAC_MSG_RESULT([fill               : ${enable_fill}])\nAC_MSG_RESULT([utrace             : ${enable_utrace}])\nAC_MSG_RESULT([xmalloc            : ${enable_xmalloc}])\nAC_MSG_RESULT([log                : ${enable_log}])\nAC_MSG_RESULT([lazy_lock          : ${enable_lazy_lock}])\nAC_MSG_RESULT([cache-oblivious    : ${enable_cache_oblivious}])\nAC_MSG_RESULT([cxx                : ${enable_cxx}])\nAC_MSG_RESULT([===============================================================================])\n",
        "/tmp/vanessa/spack-stage/spack-stage-redis-5.0.1-gykpygjr4nuvp2gxloszw6ksswcpsjes/spack-src/deps/jemalloc/src/background_thread.c": "#define JEMALLOC_BACKGROUND_THREAD_C_\n#include \"jemalloc/internal/jemalloc_preamble.h\"\n#include \"jemalloc/internal/jemalloc_internal_includes.h\"\n\n#include \"jemalloc/internal/assert.h\"\n\n/******************************************************************************/\n/* Data. */\n\n/* This option should be opt-in only. */\n#define BACKGROUND_THREAD_DEFAULT false\n/* Read-only after initialization. */\nbool opt_background_thread = BACKGROUND_THREAD_DEFAULT;\nsize_t opt_max_background_threads = MAX_BACKGROUND_THREAD_LIMIT;\n\n/* Used for thread creation, termination and stats. */\nmalloc_mutex_t background_thread_lock;\n/* Indicates global state.  Atomic because decay reads this w/o locking. */\natomic_b_t background_thread_enabled_state;\nsize_t n_background_threads;\nsize_t max_background_threads;\n/* Thread info per-index. */\nbackground_thread_info_t *background_thread_info;\n\n/* False if no necessary runtime support. */\nbool can_enable_background_thread;\n\n/******************************************************************************/\n\n#ifdef JEMALLOC_PTHREAD_CREATE_WRAPPER\n#include <dlfcn.h>\n\nstatic int (*pthread_create_fptr)(pthread_t *__restrict, const pthread_attr_t *,\n    void *(*)(void *), void *__restrict);\n\nstatic void\npthread_create_wrapper_init(void) {\n#ifdef JEMALLOC_LAZY_LOCK\n\tif (!isthreaded) {\n\t\tisthreaded = true;\n\t}\n#endif\n}\n\nint\npthread_create_wrapper(pthread_t *__restrict thread, const pthread_attr_t *attr,\n    void *(*start_routine)(void *), void *__restrict arg) {\n\tpthread_create_wrapper_init();\n\n\treturn pthread_create_fptr(thread, attr, start_routine, arg);\n}\n#endif /* JEMALLOC_PTHREAD_CREATE_WRAPPER */\n\n#ifndef JEMALLOC_BACKGROUND_THREAD\n#define NOT_REACHED { not_reached(); }\nbool background_thread_create(tsd_t *tsd, unsigned arena_ind) NOT_REACHED\nbool background_threads_enable(tsd_t *tsd) NOT_REACHED\nbool background_threads_disable(tsd_t *tsd) NOT_REACHED\nvoid background_thread_interval_check(tsdn_t *tsdn, arena_t *arena,\n    arena_decay_t *decay, size_t npages_new) NOT_REACHED\nvoid background_thread_prefork0(tsdn_t *tsdn) NOT_REACHED\nvoid background_thread_prefork1(tsdn_t *tsdn) NOT_REACHED\nvoid background_thread_postfork_parent(tsdn_t *tsdn) NOT_REACHED\nvoid background_thread_postfork_child(tsdn_t *tsdn) NOT_REACHED\nbool background_thread_stats_read(tsdn_t *tsdn,\n    background_thread_stats_t *stats) NOT_REACHED\nvoid background_thread_ctl_init(tsdn_t *tsdn) NOT_REACHED\n#undef NOT_REACHED\n#else\n\nstatic bool background_thread_enabled_at_fork;\n\nstatic void\nbackground_thread_info_init(tsdn_t *tsdn, background_thread_info_t *info) {\n\tbackground_thread_wakeup_time_set(tsdn, info, 0);\n\tinfo->npages_to_purge_new = 0;\n\tif (config_stats) {\n\t\tinfo->tot_n_runs = 0;\n\t\tnstime_init(&info->tot_sleep_time, 0);\n\t}\n}\n\nstatic inline bool\nset_current_thread_affinity(UNUSED int cpu) {\n#if defined(JEMALLOC_HAVE_SCHED_SETAFFINITY)\n\tcpu_set_t cpuset;\n\tCPU_ZERO(&cpuset);\n\tCPU_SET(cpu, &cpuset);\n\tint ret = sched_setaffinity(0, sizeof(cpu_set_t), &cpuset);\n\n\treturn (ret != 0);\n#else\n\treturn false;\n#endif\n}\n\n/* Threshold for determining when to wake up the background thread. */\n#define BACKGROUND_THREAD_NPAGES_THRESHOLD UINT64_C(1024)\n#define BILLION UINT64_C(1000000000)\n/* Minimal sleep interval 100 ms. */\n#define BACKGROUND_THREAD_MIN_INTERVAL_NS (BILLION / 10)\n\nstatic inline size_t\ndecay_npurge_after_interval(arena_decay_t *decay, size_t interval) {\n\tsize_t i;\n\tuint64_t sum = 0;\n\tfor (i = 0; i < interval; i++) {\n\t\tsum += decay->backlog[i] * h_steps[i];\n\t}\n\tfor (; i < SMOOTHSTEP_NSTEPS; i++) {\n\t\tsum += decay->backlog[i] * (h_steps[i] - h_steps[i - interval]);\n\t}\n\n\treturn (size_t)(sum >> SMOOTHSTEP_BFP);\n}\n\nstatic uint64_t\narena_decay_compute_purge_interval_impl(tsdn_t *tsdn, arena_decay_t *decay,\n    extents_t *extents) {\n\tif (malloc_mutex_trylock(tsdn, &decay->mtx)) {\n\t\t/* Use minimal interval if decay is contended. */\n\t\treturn BACKGROUND_THREAD_MIN_INTERVAL_NS;\n\t}\n\n\tuint64_t interval;\n\tssize_t decay_time = atomic_load_zd(&decay->time_ms, ATOMIC_RELAXED);\n\tif (decay_time <= 0) {\n\t\t/* Purging is eagerly done or disabled currently. */\n\t\tinterval = BACKGROUND_THREAD_INDEFINITE_SLEEP;\n\t\tgoto label_done;\n\t}\n\n\tuint64_t decay_interval_ns = nstime_ns(&decay->interval);\n\tassert(decay_interval_ns > 0);\n\tsize_t npages = extents_npages_get(extents);\n\tif (npages == 0) {\n\t\tunsigned i;\n\t\tfor (i = 0; i < SMOOTHSTEP_NSTEPS; i++) {\n\t\t\tif (decay->backlog[i] > 0) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (i == SMOOTHSTEP_NSTEPS) {\n\t\t\t/* No dirty pages recorded.  Sleep indefinitely. */\n\t\t\tinterval = BACKGROUND_THREAD_INDEFINITE_SLEEP;\n\t\t\tgoto label_done;\n\t\t}\n\t}\n\tif (npages <= BACKGROUND_THREAD_NPAGES_THRESHOLD) {\n\t\t/* Use max interval. */\n\t\tinterval = decay_interval_ns * SMOOTHSTEP_NSTEPS;\n\t\tgoto label_done;\n\t}\n\n\tsize_t lb = BACKGROUND_THREAD_MIN_INTERVAL_NS / decay_interval_ns;\n\tsize_t ub = SMOOTHSTEP_NSTEPS;\n\t/* Minimal 2 intervals to ensure reaching next epoch deadline. */\n\tlb = (lb < 2) ? 2 : lb;\n\tif ((decay_interval_ns * ub <= BACKGROUND_THREAD_MIN_INTERVAL_NS) ||\n\t    (lb + 2 > ub)) {\n\t\tinterval = BACKGROUND_THREAD_MIN_INTERVAL_NS;\n\t\tgoto label_done;\n\t}\n\n\tassert(lb + 2 <= ub);\n\tsize_t npurge_lb, npurge_ub;\n\tnpurge_lb = decay_npurge_after_interval(decay, lb);\n\tif (npurge_lb > BACKGROUND_THREAD_NPAGES_THRESHOLD) {\n\t\tinterval = decay_interval_ns * lb;\n\t\tgoto label_done;\n\t}\n\tnpurge_ub = decay_npurge_after_interval(decay, ub);\n\tif (npurge_ub < BACKGROUND_THREAD_NPAGES_THRESHOLD) {\n\t\tinterval = decay_interval_ns * ub;\n\t\tgoto label_done;\n\t}\n\n\tunsigned n_search = 0;\n\tsize_t target, npurge;\n\twhile ((npurge_lb + BACKGROUND_THREAD_NPAGES_THRESHOLD < npurge_ub)\n\t    && (lb + 2 < ub)) {\n\t\ttarget = (lb + ub) / 2;\n\t\tnpurge = decay_npurge_after_interval(decay, target);\n\t\tif (npurge > BACKGROUND_THREAD_NPAGES_THRESHOLD) {\n\t\t\tub = target;\n\t\t\tnpurge_ub = npurge;\n\t\t} else {\n\t\t\tlb = target;\n\t\t\tnpurge_lb = npurge;\n\t\t}\n\t\tassert(n_search++ < lg_floor(SMOOTHSTEP_NSTEPS) + 1);\n\t}\n\tinterval = decay_interval_ns * (ub + lb) / 2;\nlabel_done:\n\tinterval = (interval < BACKGROUND_THREAD_MIN_INTERVAL_NS) ?\n\t    BACKGROUND_THREAD_MIN_INTERVAL_NS : interval;\n\tmalloc_mutex_unlock(tsdn, &decay->mtx);\n\n\treturn interval;\n}\n\n/* Compute purge interval for background threads. */\nstatic uint64_t\narena_decay_compute_purge_interval(tsdn_t *tsdn, arena_t *arena) {\n\tuint64_t i1, i2;\n\ti1 = arena_decay_compute_purge_interval_impl(tsdn, &arena->decay_dirty,\n\t    &arena->extents_dirty);\n\tif (i1 == BACKGROUND_THREAD_MIN_INTERVAL_NS) {\n\t\treturn i1;\n\t}\n\ti2 = arena_decay_compute_purge_interval_impl(tsdn, &arena->decay_muzzy,\n\t    &arena->extents_muzzy);\n\n\treturn i1 < i2 ? i1 : i2;\n}\n\nstatic void\nbackground_thread_sleep(tsdn_t *tsdn, background_thread_info_t *info,\n    uint64_t interval) {\n\tif (config_stats) {\n\t\tinfo->tot_n_runs++;\n\t}\n\tinfo->npages_to_purge_new = 0;\n\n\tstruct timeval tv;\n\t/* Specific clock required by timedwait. */\n\tgettimeofday(&tv, NULL);\n\tnstime_t before_sleep;\n\tnstime_init2(&before_sleep, tv.tv_sec, tv.tv_usec * 1000);\n\n\tint ret;\n\tif (interval == BACKGROUND_THREAD_INDEFINITE_SLEEP) {\n\t\tassert(background_thread_indefinite_sleep(info));\n\t\tret = pthread_cond_wait(&info->cond, &info->mtx.lock);\n\t\tassert(ret == 0);\n\t} else {\n\t\tassert(interval >= BACKGROUND_THREAD_MIN_INTERVAL_NS &&\n\t\t    interval <= BACKGROUND_THREAD_INDEFINITE_SLEEP);\n\t\t/* We need malloc clock (can be different from tv). */\n\t\tnstime_t next_wakeup;\n\t\tnstime_init(&next_wakeup, 0);\n\t\tnstime_update(&next_wakeup);\n\t\tnstime_iadd(&next_wakeup, interval);\n\t\tassert(nstime_ns(&next_wakeup) <\n\t\t    BACKGROUND_THREAD_INDEFINITE_SLEEP);\n\t\tbackground_thread_wakeup_time_set(tsdn, info,\n\t\t    nstime_ns(&next_wakeup));\n\n\t\tnstime_t ts_wakeup;\n\t\tnstime_copy(&ts_wakeup, &before_sleep);\n\t\tnstime_iadd(&ts_wakeup, interval);\n\t\tstruct timespec ts;\n\t\tts.tv_sec = (size_t)nstime_sec(&ts_wakeup);\n\t\tts.tv_nsec = (size_t)nstime_nsec(&ts_wakeup);\n\n\t\tassert(!background_thread_indefinite_sleep(info));\n\t\tret = pthread_cond_timedwait(&info->cond, &info->mtx.lock, &ts);\n\t\tassert(ret == ETIMEDOUT || ret == 0);\n\t\tbackground_thread_wakeup_time_set(tsdn, info,\n\t\t    BACKGROUND_THREAD_INDEFINITE_SLEEP);\n\t}\n\tif (config_stats) {\n\t\tgettimeofday(&tv, NULL);\n\t\tnstime_t after_sleep;\n\t\tnstime_init2(&after_sleep, tv.tv_sec, tv.tv_usec * 1000);\n\t\tif (nstime_compare(&after_sleep, &before_sleep) > 0) {\n\t\t\tnstime_subtract(&after_sleep, &before_sleep);\n\t\t\tnstime_add(&info->tot_sleep_time, &after_sleep);\n\t\t}\n\t}\n}\n\nstatic bool\nbackground_thread_pause_check(tsdn_t *tsdn, background_thread_info_t *info) {\n\tif (unlikely(info->state == background_thread_paused)) {\n\t\tmalloc_mutex_unlock(tsdn, &info->mtx);\n\t\t/* Wait on global lock to update status. */\n\t\tmalloc_mutex_lock(tsdn, &background_thread_lock);\n\t\tmalloc_mutex_unlock(tsdn, &background_thread_lock);\n\t\tmalloc_mutex_lock(tsdn, &info->mtx);\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nstatic inline void\nbackground_work_sleep_once(tsdn_t *tsdn, background_thread_info_t *info, unsigned ind) {\n\tuint64_t min_interval = BACKGROUND_THREAD_INDEFINITE_SLEEP;\n\tunsigned narenas = narenas_total_get();\n\n\tfor (unsigned i = ind; i < narenas; i += max_background_threads) {\n\t\tarena_t *arena = arena_get(tsdn, i, false);\n\t\tif (!arena) {\n\t\t\tcontinue;\n\t\t}\n\t\tarena_decay(tsdn, arena, true, false);\n\t\tif (min_interval == BACKGROUND_THREAD_MIN_INTERVAL_NS) {\n\t\t\t/* Min interval will be used. */\n\t\t\tcontinue;\n\t\t}\n\t\tuint64_t interval = arena_decay_compute_purge_interval(tsdn,\n\t\t    arena);\n\t\tassert(interval >= BACKGROUND_THREAD_MIN_INTERVAL_NS);\n\t\tif (min_interval > interval) {\n\t\t\tmin_interval = interval;\n\t\t}\n\t}\n\tbackground_thread_sleep(tsdn, info, min_interval);\n}\n\nstatic bool\nbackground_threads_disable_single(tsd_t *tsd, background_thread_info_t *info) {\n\tif (info == &background_thread_info[0]) {\n\t\tmalloc_mutex_assert_owner(tsd_tsdn(tsd),\n\t\t    &background_thread_lock);\n\t} else {\n\t\tmalloc_mutex_assert_not_owner(tsd_tsdn(tsd),\n\t\t    &background_thread_lock);\n\t}\n\n\tpre_reentrancy(tsd, NULL);\n\tmalloc_mutex_lock(tsd_tsdn(tsd), &info->mtx);\n\tbool has_thread;\n\tassert(info->state != background_thread_paused);\n\tif (info->state == background_thread_started) {\n\t\thas_thread = true;\n\t\tinfo->state = background_thread_stopped;\n\t\tpthread_cond_signal(&info->cond);\n\t} else {\n\t\thas_thread = false;\n\t}\n\tmalloc_mutex_unlock(tsd_tsdn(tsd), &info->mtx);\n\n\tif (!has_thread) {\n\t\tpost_reentrancy(tsd);\n\t\treturn false;\n\t}\n\tvoid *ret;\n\tif (pthread_join(info->thread, &ret)) {\n\t\tpost_reentrancy(tsd);\n\t\treturn true;\n\t}\n\tassert(ret == NULL);\n\tn_background_threads--;\n\tpost_reentrancy(tsd);\n\n\treturn false;\n}\n\nstatic void *background_thread_entry(void *ind_arg);\n\nstatic int\nbackground_thread_create_signals_masked(pthread_t *thread,\n    const pthread_attr_t *attr, void *(*start_routine)(void *), void *arg) {\n\t/*\n\t * Mask signals during thread creation so that the thread inherits\n\t * an empty signal set.\n\t */\n\tsigset_t set;\n\tsigfillset(&set);\n\tsigset_t oldset;\n\tint mask_err = pthread_sigmask(SIG_SETMASK, &set, &oldset);\n\tif (mask_err != 0) {\n\t\treturn mask_err;\n\t}\n\tint create_err = pthread_create_wrapper(thread, attr, start_routine,\n\t    arg);\n\t/*\n\t * Restore the signal mask.  Failure to restore the signal mask here\n\t * changes program behavior.\n\t */\n\tint restore_err = pthread_sigmask(SIG_SETMASK, &oldset, NULL);\n\tif (restore_err != 0) {\n\t\tmalloc_printf(\"<jemalloc>: background thread creation \"\n\t\t    \"failed (%d), and signal mask restoration failed \"\n\t\t    \"(%d)\\n\", create_err, restore_err);\n\t\tif (opt_abort) {\n\t\t\tabort();\n\t\t}\n\t}\n\treturn create_err;\n}\n\nstatic bool\ncheck_background_thread_creation(tsd_t *tsd, unsigned *n_created,\n    bool *created_threads) {\n\tbool ret = false;\n\tif (likely(*n_created == n_background_threads)) {\n\t\treturn ret;\n\t}\n\n\ttsdn_t *tsdn = tsd_tsdn(tsd);\n\tmalloc_mutex_unlock(tsdn, &background_thread_info[0].mtx);\n\tfor (unsigned i = 1; i < max_background_threads; i++) {\n\t\tif (created_threads[i]) {\n\t\t\tcontinue;\n\t\t}\n\t\tbackground_thread_info_t *info = &background_thread_info[i];\n\t\tmalloc_mutex_lock(tsdn, &info->mtx);\n\t\t/*\n\t\t * In case of the background_thread_paused state because of\n\t\t * arena reset, delay the creation.\n\t\t */\n\t\tbool create = (info->state == background_thread_started);\n\t\tmalloc_mutex_unlock(tsdn, &info->mtx);\n\t\tif (!create) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tpre_reentrancy(tsd, NULL);\n\t\tint err = background_thread_create_signals_masked(&info->thread,\n\t\t    NULL, background_thread_entry, (void *)(uintptr_t)i);\n\t\tpost_reentrancy(tsd);\n\n\t\tif (err == 0) {\n\t\t\t(*n_created)++;\n\t\t\tcreated_threads[i] = true;\n\t\t} else {\n\t\t\tmalloc_printf(\"<jemalloc>: background thread \"\n\t\t\t    \"creation failed (%d)\\n\", err);\n\t\t\tif (opt_abort) {\n\t\t\t\tabort();\n\t\t\t}\n\t\t}\n\t\t/* Return to restart the loop since we unlocked. */\n\t\tret = true;\n\t\tbreak;\n\t}\n\tmalloc_mutex_lock(tsdn, &background_thread_info[0].mtx);\n\n\treturn ret;\n}\n\nstatic void\nbackground_thread0_work(tsd_t *tsd) {\n\t/* Thread0 is also responsible for launching / terminating threads. */\n\tVARIABLE_ARRAY(bool, created_threads, max_background_threads);\n\tunsigned i;\n\tfor (i = 1; i < max_background_threads; i++) {\n\t\tcreated_threads[i] = false;\n\t}\n\t/* Start working, and create more threads when asked. */\n\tunsigned n_created = 1;\n\twhile (background_thread_info[0].state != background_thread_stopped) {\n\t\tif (background_thread_pause_check(tsd_tsdn(tsd),\n\t\t    &background_thread_info[0])) {\n\t\t\tcontinue;\n\t\t}\n\t\tif (check_background_thread_creation(tsd, &n_created,\n\t\t    (bool *)&created_threads)) {\n\t\t\tcontinue;\n\t\t}\n\t\tbackground_work_sleep_once(tsd_tsdn(tsd),\n\t\t    &background_thread_info[0], 0);\n\t}\n\n\t/*\n\t * Shut down other threads at exit.  Note that the ctl thread is holding\n\t * the global background_thread mutex (and is waiting) for us.\n\t */\n\tassert(!background_thread_enabled());\n\tfor (i = 1; i < max_background_threads; i++) {\n\t\tbackground_thread_info_t *info = &background_thread_info[i];\n\t\tassert(info->state != background_thread_paused);\n\t\tif (created_threads[i]) {\n\t\t\tbackground_threads_disable_single(tsd, info);\n\t\t} else {\n\t\t\tmalloc_mutex_lock(tsd_tsdn(tsd), &info->mtx);\n\t\t\tif (info->state != background_thread_stopped) {\n\t\t\t\t/* The thread was not created. */\n\t\t\t\tassert(info->state ==\n\t\t\t\t    background_thread_started);\n\t\t\t\tn_background_threads--;\n\t\t\t\tinfo->state = background_thread_stopped;\n\t\t\t}\n\t\t\tmalloc_mutex_unlock(tsd_tsdn(tsd), &info->mtx);\n\t\t}\n\t}\n\tbackground_thread_info[0].state = background_thread_stopped;\n\tassert(n_background_threads == 1);\n}\n\nstatic void\nbackground_work(tsd_t *tsd, unsigned ind) {\n\tbackground_thread_info_t *info = &background_thread_info[ind];\n\n\tmalloc_mutex_lock(tsd_tsdn(tsd), &info->mtx);\n\tbackground_thread_wakeup_time_set(tsd_tsdn(tsd), info,\n\t    BACKGROUND_THREAD_INDEFINITE_SLEEP);\n\tif (ind == 0) {\n\t\tbackground_thread0_work(tsd);\n\t} else {\n\t\twhile (info->state != background_thread_stopped) {\n\t\t\tif (background_thread_pause_check(tsd_tsdn(tsd),\n\t\t\t    info)) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tbackground_work_sleep_once(tsd_tsdn(tsd), info, ind);\n\t\t}\n\t}\n\tassert(info->state == background_thread_stopped);\n\tbackground_thread_wakeup_time_set(tsd_tsdn(tsd), info, 0);\n\tmalloc_mutex_unlock(tsd_tsdn(tsd), &info->mtx);\n}\n\nstatic void *\nbackground_thread_entry(void *ind_arg) {\n\tunsigned thread_ind = (unsigned)(uintptr_t)ind_arg;\n\tassert(thread_ind < max_background_threads);\n#ifdef JEMALLOC_HAVE_PTHREAD_SETNAME_NP\n\tpthread_setname_np(pthread_self(), \"jemalloc_bg_thd\");\n#endif\n\tif (opt_percpu_arena != percpu_arena_disabled) {\n\t\tset_current_thread_affinity((int)thread_ind);\n\t}\n\t/*\n\t * Start periodic background work.  We use internal tsd which avoids\n\t * side effects, for example triggering new arena creation (which in\n\t * turn triggers another background thread creation).\n\t */\n\tbackground_work(tsd_internal_fetch(), thread_ind);\n\tassert(pthread_equal(pthread_self(),\n\t    background_thread_info[thread_ind].thread));\n\n\treturn NULL;\n}\n\nstatic void\nbackground_thread_init(tsd_t *tsd, background_thread_info_t *info) {\n\tmalloc_mutex_assert_owner(tsd_tsdn(tsd), &background_thread_lock);\n\tinfo->state = background_thread_started;\n\tbackground_thread_info_init(tsd_tsdn(tsd), info);\n\tn_background_threads++;\n}\n\n/* Create a new background thread if needed. */\nbool\nbackground_thread_create(tsd_t *tsd, unsigned arena_ind) {\n\tassert(have_background_thread);\n\tmalloc_mutex_assert_owner(tsd_tsdn(tsd), &background_thread_lock);\n\n\t/* We create at most NCPUs threads. */\n\tsize_t thread_ind = arena_ind % max_background_threads;\n\tbackground_thread_info_t *info = &background_thread_info[thread_ind];\n\n\tbool need_new_thread;\n\tmalloc_mutex_lock(tsd_tsdn(tsd), &info->mtx);\n\tneed_new_thread = background_thread_enabled() &&\n\t    (info->state == background_thread_stopped);\n\tif (need_new_thread) {\n\t\tbackground_thread_init(tsd, info);\n\t}\n\tmalloc_mutex_unlock(tsd_tsdn(tsd), &info->mtx);\n\tif (!need_new_thread) {\n\t\treturn false;\n\t}\n\tif (arena_ind != 0) {\n\t\t/* Threads are created asynchronously by Thread 0. */\n\t\tbackground_thread_info_t *t0 = &background_thread_info[0];\n\t\tmalloc_mutex_lock(tsd_tsdn(tsd), &t0->mtx);\n\t\tassert(t0->state == background_thread_started);\n\t\tpthread_cond_signal(&t0->cond);\n\t\tmalloc_mutex_unlock(tsd_tsdn(tsd), &t0->mtx);\n\n\t\treturn false;\n\t}\n\n\tpre_reentrancy(tsd, NULL);\n\t/*\n\t * To avoid complications (besides reentrancy), create internal\n\t * background threads with the underlying pthread_create.\n\t */\n\tint err = background_thread_create_signals_masked(&info->thread, NULL,\n\t    background_thread_entry, (void *)thread_ind);\n\tpost_reentrancy(tsd);\n\n\tif (err != 0) {\n\t\tmalloc_printf(\"<jemalloc>: arena 0 background thread creation \"\n\t\t    \"failed (%d)\\n\", err);\n\t\tmalloc_mutex_lock(tsd_tsdn(tsd), &info->mtx);\n\t\tinfo->state = background_thread_stopped;\n\t\tn_background_threads--;\n\t\tmalloc_mutex_unlock(tsd_tsdn(tsd), &info->mtx);\n\n\t\treturn true;\n\t}\n\n\treturn false;\n}\n\nbool\nbackground_threads_enable(tsd_t *tsd) {\n\tassert(n_background_threads == 0);\n\tassert(background_thread_enabled());\n\tmalloc_mutex_assert_owner(tsd_tsdn(tsd), &background_thread_lock);\n\n\tVARIABLE_ARRAY(bool, marked, max_background_threads);\n\tunsigned i, nmarked;\n\tfor (i = 0; i < max_background_threads; i++) {\n\t\tmarked[i] = false;\n\t}\n\tnmarked = 0;\n\t/* Thread 0 is required and created at the end. */\n\tmarked[0] = true;\n\t/* Mark the threads we need to create for thread 0. */\n\tunsigned n = narenas_total_get();\n\tfor (i = 1; i < n; i++) {\n\t\tif (marked[i % max_background_threads] ||\n\t\t    arena_get(tsd_tsdn(tsd), i, false) == NULL) {\n\t\t\tcontinue;\n\t\t}\n\t\tbackground_thread_info_t *info = &background_thread_info[\n\t\t    i % max_background_threads];\n\t\tmalloc_mutex_lock(tsd_tsdn(tsd), &info->mtx);\n\t\tassert(info->state == background_thread_stopped);\n\t\tbackground_thread_init(tsd, info);\n\t\tmalloc_mutex_unlock(tsd_tsdn(tsd), &info->mtx);\n\t\tmarked[i % max_background_threads] = true;\n\t\tif (++nmarked == max_background_threads) {\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn background_thread_create(tsd, 0);\n}\n\nbool\nbackground_threads_disable(tsd_t *tsd) {\n\tassert(!background_thread_enabled());\n\tmalloc_mutex_assert_owner(tsd_tsdn(tsd), &background_thread_lock);\n\n\t/* Thread 0 will be responsible for terminating other threads. */\n\tif (background_threads_disable_single(tsd,\n\t    &background_thread_info[0])) {\n\t\treturn true;\n\t}\n\tassert(n_background_threads == 0);\n\n\treturn false;\n}\n\n/* Check if we need to signal the background thread early. */\nvoid\nbackground_thread_interval_check(tsdn_t *tsdn, arena_t *arena,\n    arena_decay_t *decay, size_t npages_new) {\n\tbackground_thread_info_t *info = arena_background_thread_info_get(\n\t    arena);\n\tif (malloc_mutex_trylock(tsdn, &info->mtx)) {\n\t\t/*\n\t\t * Background thread may hold the mutex for a long period of\n\t\t * time.  We'd like to avoid the variance on application\n\t\t * threads.  So keep this non-blocking, and leave the work to a\n\t\t * future epoch.\n\t\t */\n\t\treturn;\n\t}\n\n\tif (info->state != background_thread_started) {\n\t\tgoto label_done;\n\t}\n\tif (malloc_mutex_trylock(tsdn, &decay->mtx)) {\n\t\tgoto label_done;\n\t}\n\n\tssize_t decay_time = atomic_load_zd(&decay->time_ms, ATOMIC_RELAXED);\n\tif (decay_time <= 0) {\n\t\t/* Purging is eagerly done or disabled currently. */\n\t\tgoto label_done_unlock2;\n\t}\n\tuint64_t decay_interval_ns = nstime_ns(&decay->interval);\n\tassert(decay_interval_ns > 0);\n\n\tnstime_t diff;\n\tnstime_init(&diff, background_thread_wakeup_time_get(info));\n\tif (nstime_compare(&diff, &decay->epoch) <= 0) {\n\t\tgoto label_done_unlock2;\n\t}\n\tnstime_subtract(&diff, &decay->epoch);\n\tif (nstime_ns(&diff) < BACKGROUND_THREAD_MIN_INTERVAL_NS) {\n\t\tgoto label_done_unlock2;\n\t}\n\n\tif (npages_new > 0) {\n\t\tsize_t n_epoch = (size_t)(nstime_ns(&diff) / decay_interval_ns);\n\t\t/*\n\t\t * Compute how many new pages we would need to purge by the next\n\t\t * wakeup, which is used to determine if we should signal the\n\t\t * background thread.\n\t\t */\n\t\tuint64_t npurge_new;\n\t\tif (n_epoch >= SMOOTHSTEP_NSTEPS) {\n\t\t\tnpurge_new = npages_new;\n\t\t} else {\n\t\t\tuint64_t h_steps_max = h_steps[SMOOTHSTEP_NSTEPS - 1];\n\t\t\tassert(h_steps_max >=\n\t\t\t    h_steps[SMOOTHSTEP_NSTEPS - 1 - n_epoch]);\n\t\t\tnpurge_new = npages_new * (h_steps_max -\n\t\t\t    h_steps[SMOOTHSTEP_NSTEPS - 1 - n_epoch]);\n\t\t\tnpurge_new >>= SMOOTHSTEP_BFP;\n\t\t}\n\t\tinfo->npages_to_purge_new += npurge_new;\n\t}\n\n\tbool should_signal;\n\tif (info->npages_to_purge_new > BACKGROUND_THREAD_NPAGES_THRESHOLD) {\n\t\tshould_signal = true;\n\t} else if (unlikely(background_thread_indefinite_sleep(info)) &&\n\t    (extents_npages_get(&arena->extents_dirty) > 0 ||\n\t    extents_npages_get(&arena->extents_muzzy) > 0 ||\n\t    info->npages_to_purge_new > 0)) {\n\t\tshould_signal = true;\n\t} else {\n\t\tshould_signal = false;\n\t}\n\n\tif (should_signal) {\n\t\tinfo->npages_to_purge_new = 0;\n\t\tpthread_cond_signal(&info->cond);\n\t}\nlabel_done_unlock2:\n\tmalloc_mutex_unlock(tsdn, &decay->mtx);\nlabel_done:\n\tmalloc_mutex_unlock(tsdn, &info->mtx);\n}\n\nvoid\nbackground_thread_prefork0(tsdn_t *tsdn) {\n\tmalloc_mutex_prefork(tsdn, &background_thread_lock);\n\tbackground_thread_enabled_at_fork = background_thread_enabled();\n}\n\nvoid\nbackground_thread_prefork1(tsdn_t *tsdn) {\n\tfor (unsigned i = 0; i < max_background_threads; i++) {\n\t\tmalloc_mutex_prefork(tsdn, &background_thread_info[i].mtx);\n\t}\n}\n\nvoid\nbackground_thread_postfork_parent(tsdn_t *tsdn) {\n\tfor (unsigned i = 0; i < max_background_threads; i++) {\n\t\tmalloc_mutex_postfork_parent(tsdn,\n\t\t    &background_thread_info[i].mtx);\n\t}\n\tmalloc_mutex_postfork_parent(tsdn, &background_thread_lock);\n}\n\nvoid\nbackground_thread_postfork_child(tsdn_t *tsdn) {\n\tfor (unsigned i = 0; i < max_background_threads; i++) {\n\t\tmalloc_mutex_postfork_child(tsdn,\n\t\t    &background_thread_info[i].mtx);\n\t}\n\tmalloc_mutex_postfork_child(tsdn, &background_thread_lock);\n\tif (!background_thread_enabled_at_fork) {\n\t\treturn;\n\t}\n\n\t/* Clear background_thread state (reset to disabled for child). */\n\tmalloc_mutex_lock(tsdn, &background_thread_lock);\n\tn_background_threads = 0;\n\tbackground_thread_enabled_set(tsdn, false);\n\tfor (unsigned i = 0; i < max_background_threads; i++) {\n\t\tbackground_thread_info_t *info = &background_thread_info[i];\n\t\tmalloc_mutex_lock(tsdn, &info->mtx);\n\t\tinfo->state = background_thread_stopped;\n\t\tint ret = pthread_cond_init(&info->cond, NULL);\n\t\tassert(ret == 0);\n\t\tbackground_thread_info_init(tsdn, info);\n\t\tmalloc_mutex_unlock(tsdn, &info->mtx);\n\t}\n\tmalloc_mutex_unlock(tsdn, &background_thread_lock);\n}\n\nbool\nbackground_thread_stats_read(tsdn_t *tsdn, background_thread_stats_t *stats) {\n\tassert(config_stats);\n\tmalloc_mutex_lock(tsdn, &background_thread_lock);\n\tif (!background_thread_enabled()) {\n\t\tmalloc_mutex_unlock(tsdn, &background_thread_lock);\n\t\treturn true;\n\t}\n\n\tstats->num_threads = n_background_threads;\n\tuint64_t num_runs = 0;\n\tnstime_init(&stats->run_interval, 0);\n\tfor (unsigned i = 0; i < max_background_threads; i++) {\n\t\tbackground_thread_info_t *info = &background_thread_info[i];\n\t\tmalloc_mutex_lock(tsdn, &info->mtx);\n\t\tif (info->state != background_thread_stopped) {\n\t\t\tnum_runs += info->tot_n_runs;\n\t\t\tnstime_add(&stats->run_interval, &info->tot_sleep_time);\n\t\t}\n\t\tmalloc_mutex_unlock(tsdn, &info->mtx);\n\t}\n\tstats->num_runs = num_runs;\n\tif (num_runs > 0) {\n\t\tnstime_idivide(&stats->run_interval, num_runs);\n\t}\n\tmalloc_mutex_unlock(tsdn, &background_thread_lock);\n\n\treturn false;\n}\n\n#undef BACKGROUND_THREAD_NPAGES_THRESHOLD\n#undef BILLION\n#undef BACKGROUND_THREAD_MIN_INTERVAL_NS\n\nstatic bool\npthread_create_fptr_init(void) {\n\tif (pthread_create_fptr != NULL) {\n\t\treturn false;\n\t}\n\tpthread_create_fptr = dlsym(RTLD_NEXT, \"pthread_create\");\n\tif (pthread_create_fptr == NULL) {\n\t\tcan_enable_background_thread = false;\n\t\tif (config_lazy_lock || opt_background_thread) {\n\t\t\tmalloc_write(\"<jemalloc>: Error in dlsym(RTLD_NEXT, \"\n\t\t\t    \"\\\"pthread_create\\\")\\n\");\n\t\t\tabort();\n\t\t}\n\t} else {\n\t\tcan_enable_background_thread = true;\n\t}\n\n\treturn false;\n}\n\n/*\n * When lazy lock is enabled, we need to make sure setting isthreaded before\n * taking any background_thread locks.  This is called early in ctl (instead of\n * wait for the pthread_create calls to trigger) because the mutex is required\n * before creating background threads.\n */\nvoid\nbackground_thread_ctl_init(tsdn_t *tsdn) {\n\tmalloc_mutex_assert_not_owner(tsdn, &background_thread_lock);\n#ifdef JEMALLOC_PTHREAD_CREATE_WRAPPER\n\tpthread_create_fptr_init();\n\tpthread_create_wrapper_init();\n#endif\n}\n\n#endif /* defined(JEMALLOC_BACKGROUND_THREAD) */\n\nbool\nbackground_thread_boot0(void) {\n\tif (!have_background_thread && opt_background_thread) {\n\t\tmalloc_printf(\"<jemalloc>: option background_thread currently \"\n\t\t    \"supports pthread only\\n\");\n\t\treturn true;\n\t}\n#ifdef JEMALLOC_PTHREAD_CREATE_WRAPPER\n\tif ((config_lazy_lock || opt_background_thread) &&\n\t    pthread_create_fptr_init()) {\n\t\treturn true;\n\t}\n#endif\n\treturn false;\n}\n\nbool\nbackground_thread_boot1(tsdn_t *tsdn) {\n#ifdef JEMALLOC_BACKGROUND_THREAD\n\tassert(have_background_thread);\n\tassert(narenas_total_get() > 0);\n\n\tif (opt_max_background_threads == MAX_BACKGROUND_THREAD_LIMIT &&\n\t    ncpus < MAX_BACKGROUND_THREAD_LIMIT) {\n\t\topt_max_background_threads = ncpus;\n\t}\n\tmax_background_threads = opt_max_background_threads;\n\n\tbackground_thread_enabled_set(tsdn, opt_background_thread);\n\tif (malloc_mutex_init(&background_thread_lock,\n\t    \"background_thread_global\",\n\t    WITNESS_RANK_BACKGROUND_THREAD_GLOBAL,\n\t    malloc_mutex_rank_exclusive)) {\n\t\treturn true;\n\t}\n\n\tbackground_thread_info = (background_thread_info_t *)base_alloc(tsdn,\n\t    b0get(), opt_max_background_threads *\n\t    sizeof(background_thread_info_t), CACHELINE);\n\tif (background_thread_info == NULL) {\n\t\treturn true;\n\t}\n\n\tfor (unsigned i = 0; i < max_background_threads; i++) {\n\t\tbackground_thread_info_t *info = &background_thread_info[i];\n\t\t/* Thread mutex is rank_inclusive because of thread0. */\n\t\tif (malloc_mutex_init(&info->mtx, \"background_thread\",\n\t\t    WITNESS_RANK_BACKGROUND_THREAD,\n\t\t    malloc_mutex_address_ordered)) {\n\t\t\treturn true;\n\t\t}\n\t\tif (pthread_cond_init(&info->cond, NULL)) {\n\t\t\treturn true;\n\t\t}\n\t\tmalloc_mutex_lock(tsdn, &info->mtx);\n\t\tinfo->state = background_thread_stopped;\n\t\tbackground_thread_info_init(tsdn, info);\n\t\tmalloc_mutex_unlock(tsdn, &info->mtx);\n\t}\n#endif\n\n\treturn false;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-redis-5.0.1-gykpygjr4nuvp2gxloszw6ksswcpsjes/spack-src/deps/jemalloc/src/ctl.c": "#define JEMALLOC_CTL_C_\n#include \"jemalloc/internal/jemalloc_preamble.h\"\n#include \"jemalloc/internal/jemalloc_internal_includes.h\"\n\n#include \"jemalloc/internal/assert.h\"\n#include \"jemalloc/internal/ctl.h\"\n#include \"jemalloc/internal/extent_dss.h\"\n#include \"jemalloc/internal/extent_mmap.h\"\n#include \"jemalloc/internal/mutex.h\"\n#include \"jemalloc/internal/nstime.h\"\n#include \"jemalloc/internal/size_classes.h\"\n#include \"jemalloc/internal/util.h\"\n\n/******************************************************************************/\n/* Data. */\n\n/*\n * ctl_mtx protects the following:\n * - ctl_stats->*\n */\nstatic malloc_mutex_t\tctl_mtx;\nstatic bool\t\tctl_initialized;\nstatic ctl_stats_t\t*ctl_stats;\nstatic ctl_arenas_t\t*ctl_arenas;\n\n/******************************************************************************/\n/* Helpers for named and indexed nodes. */\n\nstatic const ctl_named_node_t *\nctl_named_node(const ctl_node_t *node) {\n\treturn ((node->named) ? (const ctl_named_node_t *)node : NULL);\n}\n\nstatic const ctl_named_node_t *\nctl_named_children(const ctl_named_node_t *node, size_t index) {\n\tconst ctl_named_node_t *children = ctl_named_node(node->children);\n\n\treturn (children ? &children[index] : NULL);\n}\n\nstatic const ctl_indexed_node_t *\nctl_indexed_node(const ctl_node_t *node) {\n\treturn (!node->named ? (const ctl_indexed_node_t *)node : NULL);\n}\n\n/******************************************************************************/\n/* Function prototypes for non-inline static functions. */\n\n#define CTL_PROTO(n)\t\t\t\t\t\t\t\\\nstatic int\tn##_ctl(tsd_t *tsd, const size_t *mib, size_t miblen,\t\\\n    void *oldp, size_t *oldlenp, void *newp, size_t newlen);\n\n#define INDEX_PROTO(n)\t\t\t\t\t\t\t\\\nstatic const ctl_named_node_t\t*n##_index(tsdn_t *tsdn,\t\t\\\n    const size_t *mib, size_t miblen, size_t i);\n\nCTL_PROTO(version)\nCTL_PROTO(epoch)\nCTL_PROTO(background_thread)\nCTL_PROTO(max_background_threads)\nCTL_PROTO(thread_tcache_enabled)\nCTL_PROTO(thread_tcache_flush)\nCTL_PROTO(thread_prof_name)\nCTL_PROTO(thread_prof_active)\nCTL_PROTO(thread_arena)\nCTL_PROTO(thread_allocated)\nCTL_PROTO(thread_allocatedp)\nCTL_PROTO(thread_deallocated)\nCTL_PROTO(thread_deallocatedp)\nCTL_PROTO(config_cache_oblivious)\nCTL_PROTO(config_debug)\nCTL_PROTO(config_fill)\nCTL_PROTO(config_lazy_lock)\nCTL_PROTO(config_malloc_conf)\nCTL_PROTO(config_prof)\nCTL_PROTO(config_prof_libgcc)\nCTL_PROTO(config_prof_libunwind)\nCTL_PROTO(config_stats)\nCTL_PROTO(config_utrace)\nCTL_PROTO(config_xmalloc)\nCTL_PROTO(opt_abort)\nCTL_PROTO(opt_abort_conf)\nCTL_PROTO(opt_metadata_thp)\nCTL_PROTO(opt_retain)\nCTL_PROTO(opt_dss)\nCTL_PROTO(opt_narenas)\nCTL_PROTO(opt_percpu_arena)\nCTL_PROTO(opt_background_thread)\nCTL_PROTO(opt_max_background_threads)\nCTL_PROTO(opt_dirty_decay_ms)\nCTL_PROTO(opt_muzzy_decay_ms)\nCTL_PROTO(opt_stats_print)\nCTL_PROTO(opt_stats_print_opts)\nCTL_PROTO(opt_junk)\nCTL_PROTO(opt_zero)\nCTL_PROTO(opt_utrace)\nCTL_PROTO(opt_xmalloc)\nCTL_PROTO(opt_tcache)\nCTL_PROTO(opt_thp)\nCTL_PROTO(opt_lg_extent_max_active_fit)\nCTL_PROTO(opt_lg_tcache_max)\nCTL_PROTO(opt_prof)\nCTL_PROTO(opt_prof_prefix)\nCTL_PROTO(opt_prof_active)\nCTL_PROTO(opt_prof_thread_active_init)\nCTL_PROTO(opt_lg_prof_sample)\nCTL_PROTO(opt_lg_prof_interval)\nCTL_PROTO(opt_prof_gdump)\nCTL_PROTO(opt_prof_final)\nCTL_PROTO(opt_prof_leak)\nCTL_PROTO(opt_prof_accum)\nCTL_PROTO(tcache_create)\nCTL_PROTO(tcache_flush)\nCTL_PROTO(tcache_destroy)\nCTL_PROTO(arena_i_initialized)\nCTL_PROTO(arena_i_decay)\nCTL_PROTO(arena_i_purge)\nCTL_PROTO(arena_i_reset)\nCTL_PROTO(arena_i_destroy)\nCTL_PROTO(arena_i_dss)\nCTL_PROTO(arena_i_dirty_decay_ms)\nCTL_PROTO(arena_i_muzzy_decay_ms)\nCTL_PROTO(arena_i_extent_hooks)\nCTL_PROTO(arena_i_retain_grow_limit)\nINDEX_PROTO(arena_i)\nCTL_PROTO(arenas_bin_i_size)\nCTL_PROTO(arenas_bin_i_nregs)\nCTL_PROTO(arenas_bin_i_slab_size)\nINDEX_PROTO(arenas_bin_i)\nCTL_PROTO(arenas_lextent_i_size)\nINDEX_PROTO(arenas_lextent_i)\nCTL_PROTO(arenas_narenas)\nCTL_PROTO(arenas_dirty_decay_ms)\nCTL_PROTO(arenas_muzzy_decay_ms)\nCTL_PROTO(arenas_quantum)\nCTL_PROTO(arenas_page)\nCTL_PROTO(arenas_tcache_max)\nCTL_PROTO(arenas_nbins)\nCTL_PROTO(arenas_nhbins)\nCTL_PROTO(arenas_nlextents)\nCTL_PROTO(arenas_create)\nCTL_PROTO(arenas_lookup)\nCTL_PROTO(prof_thread_active_init)\nCTL_PROTO(prof_active)\nCTL_PROTO(prof_dump)\nCTL_PROTO(prof_gdump)\nCTL_PROTO(prof_reset)\nCTL_PROTO(prof_interval)\nCTL_PROTO(lg_prof_sample)\nCTL_PROTO(stats_arenas_i_small_allocated)\nCTL_PROTO(stats_arenas_i_small_nmalloc)\nCTL_PROTO(stats_arenas_i_small_ndalloc)\nCTL_PROTO(stats_arenas_i_small_nrequests)\nCTL_PROTO(stats_arenas_i_large_allocated)\nCTL_PROTO(stats_arenas_i_large_nmalloc)\nCTL_PROTO(stats_arenas_i_large_ndalloc)\nCTL_PROTO(stats_arenas_i_large_nrequests)\nCTL_PROTO(stats_arenas_i_bins_j_nmalloc)\nCTL_PROTO(stats_arenas_i_bins_j_ndalloc)\nCTL_PROTO(stats_arenas_i_bins_j_nrequests)\nCTL_PROTO(stats_arenas_i_bins_j_curregs)\nCTL_PROTO(stats_arenas_i_bins_j_nfills)\nCTL_PROTO(stats_arenas_i_bins_j_nflushes)\nCTL_PROTO(stats_arenas_i_bins_j_nslabs)\nCTL_PROTO(stats_arenas_i_bins_j_nreslabs)\nCTL_PROTO(stats_arenas_i_bins_j_curslabs)\nINDEX_PROTO(stats_arenas_i_bins_j)\nCTL_PROTO(stats_arenas_i_lextents_j_nmalloc)\nCTL_PROTO(stats_arenas_i_lextents_j_ndalloc)\nCTL_PROTO(stats_arenas_i_lextents_j_nrequests)\nCTL_PROTO(stats_arenas_i_lextents_j_curlextents)\nINDEX_PROTO(stats_arenas_i_lextents_j)\nCTL_PROTO(stats_arenas_i_nthreads)\nCTL_PROTO(stats_arenas_i_uptime)\nCTL_PROTO(stats_arenas_i_dss)\nCTL_PROTO(stats_arenas_i_dirty_decay_ms)\nCTL_PROTO(stats_arenas_i_muzzy_decay_ms)\nCTL_PROTO(stats_arenas_i_pactive)\nCTL_PROTO(stats_arenas_i_pdirty)\nCTL_PROTO(stats_arenas_i_pmuzzy)\nCTL_PROTO(stats_arenas_i_mapped)\nCTL_PROTO(stats_arenas_i_retained)\nCTL_PROTO(stats_arenas_i_dirty_npurge)\nCTL_PROTO(stats_arenas_i_dirty_nmadvise)\nCTL_PROTO(stats_arenas_i_dirty_purged)\nCTL_PROTO(stats_arenas_i_muzzy_npurge)\nCTL_PROTO(stats_arenas_i_muzzy_nmadvise)\nCTL_PROTO(stats_arenas_i_muzzy_purged)\nCTL_PROTO(stats_arenas_i_base)\nCTL_PROTO(stats_arenas_i_internal)\nCTL_PROTO(stats_arenas_i_metadata_thp)\nCTL_PROTO(stats_arenas_i_tcache_bytes)\nCTL_PROTO(stats_arenas_i_resident)\nINDEX_PROTO(stats_arenas_i)\nCTL_PROTO(stats_allocated)\nCTL_PROTO(stats_active)\nCTL_PROTO(stats_background_thread_num_threads)\nCTL_PROTO(stats_background_thread_num_runs)\nCTL_PROTO(stats_background_thread_run_interval)\nCTL_PROTO(stats_metadata)\nCTL_PROTO(stats_metadata_thp)\nCTL_PROTO(stats_resident)\nCTL_PROTO(stats_mapped)\nCTL_PROTO(stats_retained)\n\n#define MUTEX_STATS_CTL_PROTO_GEN(n)\t\t\t\t\t\\\nCTL_PROTO(stats_##n##_num_ops)\t\t\t\t\t\t\\\nCTL_PROTO(stats_##n##_num_wait)\t\t\t\t\t\t\\\nCTL_PROTO(stats_##n##_num_spin_acq)\t\t\t\t\t\\\nCTL_PROTO(stats_##n##_num_owner_switch)\t\t\t\t\t\\\nCTL_PROTO(stats_##n##_total_wait_time)\t\t\t\t\t\\\nCTL_PROTO(stats_##n##_max_wait_time)\t\t\t\t\t\\\nCTL_PROTO(stats_##n##_max_num_thds)\n\n/* Global mutexes. */\n#define OP(mtx) MUTEX_STATS_CTL_PROTO_GEN(mutexes_##mtx)\nMUTEX_PROF_GLOBAL_MUTEXES\n#undef OP\n\n/* Per arena mutexes. */\n#define OP(mtx) MUTEX_STATS_CTL_PROTO_GEN(arenas_i_mutexes_##mtx)\nMUTEX_PROF_ARENA_MUTEXES\n#undef OP\n\n/* Arena bin mutexes. */\nMUTEX_STATS_CTL_PROTO_GEN(arenas_i_bins_j_mutex)\n#undef MUTEX_STATS_CTL_PROTO_GEN\n\nCTL_PROTO(stats_mutexes_reset)\n\n/******************************************************************************/\n/* mallctl tree. */\n\n#define NAME(n)\t{true},\tn\n#define CHILD(t, c)\t\t\t\t\t\t\t\\\n\tsizeof(c##_node) / sizeof(ctl_##t##_node_t),\t\t\t\\\n\t(ctl_node_t *)c##_node,\t\t\t\t\t\t\\\n\tNULL\n#define CTL(c)\t0, NULL, c##_ctl\n\n/*\n * Only handles internal indexed nodes, since there are currently no external\n * ones.\n */\n#define INDEX(i)\t{false},\ti##_index\n\nstatic const ctl_named_node_t\tthread_tcache_node[] = {\n\t{NAME(\"enabled\"),\tCTL(thread_tcache_enabled)},\n\t{NAME(\"flush\"),\t\tCTL(thread_tcache_flush)}\n};\n\nstatic const ctl_named_node_t\tthread_prof_node[] = {\n\t{NAME(\"name\"),\t\tCTL(thread_prof_name)},\n\t{NAME(\"active\"),\tCTL(thread_prof_active)}\n};\n\nstatic const ctl_named_node_t\tthread_node[] = {\n\t{NAME(\"arena\"),\t\tCTL(thread_arena)},\n\t{NAME(\"allocated\"),\tCTL(thread_allocated)},\n\t{NAME(\"allocatedp\"),\tCTL(thread_allocatedp)},\n\t{NAME(\"deallocated\"),\tCTL(thread_deallocated)},\n\t{NAME(\"deallocatedp\"),\tCTL(thread_deallocatedp)},\n\t{NAME(\"tcache\"),\tCHILD(named, thread_tcache)},\n\t{NAME(\"prof\"),\t\tCHILD(named, thread_prof)}\n};\n\nstatic const ctl_named_node_t\tconfig_node[] = {\n\t{NAME(\"cache_oblivious\"), CTL(config_cache_oblivious)},\n\t{NAME(\"debug\"),\t\tCTL(config_debug)},\n\t{NAME(\"fill\"),\t\tCTL(config_fill)},\n\t{NAME(\"lazy_lock\"),\tCTL(config_lazy_lock)},\n\t{NAME(\"malloc_conf\"),\tCTL(config_malloc_conf)},\n\t{NAME(\"prof\"),\t\tCTL(config_prof)},\n\t{NAME(\"prof_libgcc\"),\tCTL(config_prof_libgcc)},\n\t{NAME(\"prof_libunwind\"), CTL(config_prof_libunwind)},\n\t{NAME(\"stats\"),\t\tCTL(config_stats)},\n\t{NAME(\"utrace\"),\tCTL(config_utrace)},\n\t{NAME(\"xmalloc\"),\tCTL(config_xmalloc)}\n};\n\nstatic const ctl_named_node_t opt_node[] = {\n\t{NAME(\"abort\"),\t\tCTL(opt_abort)},\n\t{NAME(\"abort_conf\"),\tCTL(opt_abort_conf)},\n\t{NAME(\"metadata_thp\"),\tCTL(opt_metadata_thp)},\n\t{NAME(\"retain\"),\tCTL(opt_retain)},\n\t{NAME(\"dss\"),\t\tCTL(opt_dss)},\n\t{NAME(\"narenas\"),\tCTL(opt_narenas)},\n\t{NAME(\"percpu_arena\"),\tCTL(opt_percpu_arena)},\n\t{NAME(\"background_thread\"),\tCTL(opt_background_thread)},\n\t{NAME(\"max_background_threads\"),\tCTL(opt_max_background_threads)},\n\t{NAME(\"dirty_decay_ms\"), CTL(opt_dirty_decay_ms)},\n\t{NAME(\"muzzy_decay_ms\"), CTL(opt_muzzy_decay_ms)},\n\t{NAME(\"stats_print\"),\tCTL(opt_stats_print)},\n\t{NAME(\"stats_print_opts\"),\tCTL(opt_stats_print_opts)},\n\t{NAME(\"junk\"),\t\tCTL(opt_junk)},\n\t{NAME(\"zero\"),\t\tCTL(opt_zero)},\n\t{NAME(\"utrace\"),\tCTL(opt_utrace)},\n\t{NAME(\"xmalloc\"),\tCTL(opt_xmalloc)},\n\t{NAME(\"tcache\"),\tCTL(opt_tcache)},\n\t{NAME(\"thp\"),\t\tCTL(opt_thp)},\n\t{NAME(\"lg_extent_max_active_fit\"), CTL(opt_lg_extent_max_active_fit)},\n\t{NAME(\"lg_tcache_max\"),\tCTL(opt_lg_tcache_max)},\n\t{NAME(\"prof\"),\t\tCTL(opt_prof)},\n\t{NAME(\"prof_prefix\"),\tCTL(opt_prof_prefix)},\n\t{NAME(\"prof_active\"),\tCTL(opt_prof_active)},\n\t{NAME(\"prof_thread_active_init\"), CTL(opt_prof_thread_active_init)},\n\t{NAME(\"lg_prof_sample\"), CTL(opt_lg_prof_sample)},\n\t{NAME(\"lg_prof_interval\"), CTL(opt_lg_prof_interval)},\n\t{NAME(\"prof_gdump\"),\tCTL(opt_prof_gdump)},\n\t{NAME(\"prof_final\"),\tCTL(opt_prof_final)},\n\t{NAME(\"prof_leak\"),\tCTL(opt_prof_leak)},\n\t{NAME(\"prof_accum\"),\tCTL(opt_prof_accum)}\n};\n\nstatic const ctl_named_node_t\ttcache_node[] = {\n\t{NAME(\"create\"),\tCTL(tcache_create)},\n\t{NAME(\"flush\"),\t\tCTL(tcache_flush)},\n\t{NAME(\"destroy\"),\tCTL(tcache_destroy)}\n};\n\nstatic const ctl_named_node_t arena_i_node[] = {\n\t{NAME(\"initialized\"),\tCTL(arena_i_initialized)},\n\t{NAME(\"decay\"),\t\tCTL(arena_i_decay)},\n\t{NAME(\"purge\"),\t\tCTL(arena_i_purge)},\n\t{NAME(\"reset\"),\t\tCTL(arena_i_reset)},\n\t{NAME(\"destroy\"),\tCTL(arena_i_destroy)},\n\t{NAME(\"dss\"),\t\tCTL(arena_i_dss)},\n\t{NAME(\"dirty_decay_ms\"), CTL(arena_i_dirty_decay_ms)},\n\t{NAME(\"muzzy_decay_ms\"), CTL(arena_i_muzzy_decay_ms)},\n\t{NAME(\"extent_hooks\"),\tCTL(arena_i_extent_hooks)},\n\t{NAME(\"retain_grow_limit\"),\tCTL(arena_i_retain_grow_limit)}\n};\nstatic const ctl_named_node_t super_arena_i_node[] = {\n\t{NAME(\"\"),\t\tCHILD(named, arena_i)}\n};\n\nstatic const ctl_indexed_node_t arena_node[] = {\n\t{INDEX(arena_i)}\n};\n\nstatic const ctl_named_node_t arenas_bin_i_node[] = {\n\t{NAME(\"size\"),\t\tCTL(arenas_bin_i_size)},\n\t{NAME(\"nregs\"),\t\tCTL(arenas_bin_i_nregs)},\n\t{NAME(\"slab_size\"),\tCTL(arenas_bin_i_slab_size)}\n};\nstatic const ctl_named_node_t super_arenas_bin_i_node[] = {\n\t{NAME(\"\"),\t\tCHILD(named, arenas_bin_i)}\n};\n\nstatic const ctl_indexed_node_t arenas_bin_node[] = {\n\t{INDEX(arenas_bin_i)}\n};\n\nstatic const ctl_named_node_t arenas_lextent_i_node[] = {\n\t{NAME(\"size\"),\t\tCTL(arenas_lextent_i_size)}\n};\nstatic const ctl_named_node_t super_arenas_lextent_i_node[] = {\n\t{NAME(\"\"),\t\tCHILD(named, arenas_lextent_i)}\n};\n\nstatic const ctl_indexed_node_t arenas_lextent_node[] = {\n\t{INDEX(arenas_lextent_i)}\n};\n\nstatic const ctl_named_node_t arenas_node[] = {\n\t{NAME(\"narenas\"),\tCTL(arenas_narenas)},\n\t{NAME(\"dirty_decay_ms\"), CTL(arenas_dirty_decay_ms)},\n\t{NAME(\"muzzy_decay_ms\"), CTL(arenas_muzzy_decay_ms)},\n\t{NAME(\"quantum\"),\tCTL(arenas_quantum)},\n\t{NAME(\"page\"),\t\tCTL(arenas_page)},\n\t{NAME(\"tcache_max\"),\tCTL(arenas_tcache_max)},\n\t{NAME(\"nbins\"),\t\tCTL(arenas_nbins)},\n\t{NAME(\"nhbins\"),\tCTL(arenas_nhbins)},\n\t{NAME(\"bin\"),\t\tCHILD(indexed, arenas_bin)},\n\t{NAME(\"nlextents\"),\tCTL(arenas_nlextents)},\n\t{NAME(\"lextent\"),\tCHILD(indexed, arenas_lextent)},\n\t{NAME(\"create\"),\tCTL(arenas_create)},\n\t{NAME(\"lookup\"),\tCTL(arenas_lookup)}\n};\n\nstatic const ctl_named_node_t\tprof_node[] = {\n\t{NAME(\"thread_active_init\"), CTL(prof_thread_active_init)},\n\t{NAME(\"active\"),\tCTL(prof_active)},\n\t{NAME(\"dump\"),\t\tCTL(prof_dump)},\n\t{NAME(\"gdump\"),\t\tCTL(prof_gdump)},\n\t{NAME(\"reset\"),\t\tCTL(prof_reset)},\n\t{NAME(\"interval\"),\tCTL(prof_interval)},\n\t{NAME(\"lg_sample\"),\tCTL(lg_prof_sample)}\n};\n\nstatic const ctl_named_node_t stats_arenas_i_small_node[] = {\n\t{NAME(\"allocated\"),\tCTL(stats_arenas_i_small_allocated)},\n\t{NAME(\"nmalloc\"),\tCTL(stats_arenas_i_small_nmalloc)},\n\t{NAME(\"ndalloc\"),\tCTL(stats_arenas_i_small_ndalloc)},\n\t{NAME(\"nrequests\"),\tCTL(stats_arenas_i_small_nrequests)}\n};\n\nstatic const ctl_named_node_t stats_arenas_i_large_node[] = {\n\t{NAME(\"allocated\"),\tCTL(stats_arenas_i_large_allocated)},\n\t{NAME(\"nmalloc\"),\tCTL(stats_arenas_i_large_nmalloc)},\n\t{NAME(\"ndalloc\"),\tCTL(stats_arenas_i_large_ndalloc)},\n\t{NAME(\"nrequests\"),\tCTL(stats_arenas_i_large_nrequests)}\n};\n\n#define MUTEX_PROF_DATA_NODE(prefix)\t\t\t\t\t\\\nstatic const ctl_named_node_t stats_##prefix##_node[] = {\t\t\\\n\t{NAME(\"num_ops\"),\t\t\t\t\t\t\\\n\t CTL(stats_##prefix##_num_ops)},\t\t\t\t\\\n\t{NAME(\"num_wait\"),\t\t\t\t\t\t\\\n\t CTL(stats_##prefix##_num_wait)},\t\t\t\t\\\n\t{NAME(\"num_spin_acq\"),\t\t\t\t\t\t\\\n\t CTL(stats_##prefix##_num_spin_acq)},\t\t\t\t\\\n\t{NAME(\"num_owner_switch\"),\t\t\t\t\t\\\n\t CTL(stats_##prefix##_num_owner_switch)},\t\t\t\\\n\t{NAME(\"total_wait_time\"),\t\t\t\t\t\\\n\t CTL(stats_##prefix##_total_wait_time)},\t\t\t\\\n\t{NAME(\"max_wait_time\"),\t\t\t\t\t\t\\\n\t CTL(stats_##prefix##_max_wait_time)},\t\t\t\t\\\n\t{NAME(\"max_num_thds\"),\t\t\t\t\t\t\\\n\t CTL(stats_##prefix##_max_num_thds)}\t\t\t\t\\\n\t/* Note that # of current waiting thread not provided. */\t\\\n};\n\nMUTEX_PROF_DATA_NODE(arenas_i_bins_j_mutex)\n\nstatic const ctl_named_node_t stats_arenas_i_bins_j_node[] = {\n\t{NAME(\"nmalloc\"),\tCTL(stats_arenas_i_bins_j_nmalloc)},\n\t{NAME(\"ndalloc\"),\tCTL(stats_arenas_i_bins_j_ndalloc)},\n\t{NAME(\"nrequests\"),\tCTL(stats_arenas_i_bins_j_nrequests)},\n\t{NAME(\"curregs\"),\tCTL(stats_arenas_i_bins_j_curregs)},\n\t{NAME(\"nfills\"),\tCTL(stats_arenas_i_bins_j_nfills)},\n\t{NAME(\"nflushes\"),\tCTL(stats_arenas_i_bins_j_nflushes)},\n\t{NAME(\"nslabs\"),\tCTL(stats_arenas_i_bins_j_nslabs)},\n\t{NAME(\"nreslabs\"),\tCTL(stats_arenas_i_bins_j_nreslabs)},\n\t{NAME(\"curslabs\"),\tCTL(stats_arenas_i_bins_j_curslabs)},\n\t{NAME(\"mutex\"),\t\tCHILD(named, stats_arenas_i_bins_j_mutex)}\n};\n\nstatic const ctl_named_node_t super_stats_arenas_i_bins_j_node[] = {\n\t{NAME(\"\"),\t\tCHILD(named, stats_arenas_i_bins_j)}\n};\n\nstatic const ctl_indexed_node_t stats_arenas_i_bins_node[] = {\n\t{INDEX(stats_arenas_i_bins_j)}\n};\n\nstatic const ctl_named_node_t stats_arenas_i_lextents_j_node[] = {\n\t{NAME(\"nmalloc\"),\tCTL(stats_arenas_i_lextents_j_nmalloc)},\n\t{NAME(\"ndalloc\"),\tCTL(stats_arenas_i_lextents_j_ndalloc)},\n\t{NAME(\"nrequests\"),\tCTL(stats_arenas_i_lextents_j_nrequests)},\n\t{NAME(\"curlextents\"),\tCTL(stats_arenas_i_lextents_j_curlextents)}\n};\nstatic const ctl_named_node_t super_stats_arenas_i_lextents_j_node[] = {\n\t{NAME(\"\"),\t\tCHILD(named, stats_arenas_i_lextents_j)}\n};\n\nstatic const ctl_indexed_node_t stats_arenas_i_lextents_node[] = {\n\t{INDEX(stats_arenas_i_lextents_j)}\n};\n\n#define OP(mtx)  MUTEX_PROF_DATA_NODE(arenas_i_mutexes_##mtx)\nMUTEX_PROF_ARENA_MUTEXES\n#undef OP\n\nstatic const ctl_named_node_t stats_arenas_i_mutexes_node[] = {\n#define OP(mtx) {NAME(#mtx), CHILD(named, stats_arenas_i_mutexes_##mtx)},\nMUTEX_PROF_ARENA_MUTEXES\n#undef OP\n};\n\nstatic const ctl_named_node_t stats_arenas_i_node[] = {\n\t{NAME(\"nthreads\"),\tCTL(stats_arenas_i_nthreads)},\n\t{NAME(\"uptime\"),\tCTL(stats_arenas_i_uptime)},\n\t{NAME(\"dss\"),\t\tCTL(stats_arenas_i_dss)},\n\t{NAME(\"dirty_decay_ms\"), CTL(stats_arenas_i_dirty_decay_ms)},\n\t{NAME(\"muzzy_decay_ms\"), CTL(stats_arenas_i_muzzy_decay_ms)},\n\t{NAME(\"pactive\"),\tCTL(stats_arenas_i_pactive)},\n\t{NAME(\"pdirty\"),\tCTL(stats_arenas_i_pdirty)},\n\t{NAME(\"pmuzzy\"),\tCTL(stats_arenas_i_pmuzzy)},\n\t{NAME(\"mapped\"),\tCTL(stats_arenas_i_mapped)},\n\t{NAME(\"retained\"),\tCTL(stats_arenas_i_retained)},\n\t{NAME(\"dirty_npurge\"),\tCTL(stats_arenas_i_dirty_npurge)},\n\t{NAME(\"dirty_nmadvise\"), CTL(stats_arenas_i_dirty_nmadvise)},\n\t{NAME(\"dirty_purged\"),\tCTL(stats_arenas_i_dirty_purged)},\n\t{NAME(\"muzzy_npurge\"),\tCTL(stats_arenas_i_muzzy_npurge)},\n\t{NAME(\"muzzy_nmadvise\"), CTL(stats_arenas_i_muzzy_nmadvise)},\n\t{NAME(\"muzzy_purged\"),\tCTL(stats_arenas_i_muzzy_purged)},\n\t{NAME(\"base\"),\t\tCTL(stats_arenas_i_base)},\n\t{NAME(\"internal\"),\tCTL(stats_arenas_i_internal)},\n\t{NAME(\"metadata_thp\"),\tCTL(stats_arenas_i_metadata_thp)},\n\t{NAME(\"tcache_bytes\"),\tCTL(stats_arenas_i_tcache_bytes)},\n\t{NAME(\"resident\"),\tCTL(stats_arenas_i_resident)},\n\t{NAME(\"small\"),\t\tCHILD(named, stats_arenas_i_small)},\n\t{NAME(\"large\"),\t\tCHILD(named, stats_arenas_i_large)},\n\t{NAME(\"bins\"),\t\tCHILD(indexed, stats_arenas_i_bins)},\n\t{NAME(\"lextents\"),\tCHILD(indexed, stats_arenas_i_lextents)},\n\t{NAME(\"mutexes\"),\tCHILD(named, stats_arenas_i_mutexes)}\n};\nstatic const ctl_named_node_t super_stats_arenas_i_node[] = {\n\t{NAME(\"\"),\t\tCHILD(named, stats_arenas_i)}\n};\n\nstatic const ctl_indexed_node_t stats_arenas_node[] = {\n\t{INDEX(stats_arenas_i)}\n};\n\nstatic const ctl_named_node_t stats_background_thread_node[] = {\n\t{NAME(\"num_threads\"),\tCTL(stats_background_thread_num_threads)},\n\t{NAME(\"num_runs\"),\tCTL(stats_background_thread_num_runs)},\n\t{NAME(\"run_interval\"),\tCTL(stats_background_thread_run_interval)}\n};\n\n#define OP(mtx) MUTEX_PROF_DATA_NODE(mutexes_##mtx)\nMUTEX_PROF_GLOBAL_MUTEXES\n#undef OP\n\nstatic const ctl_named_node_t stats_mutexes_node[] = {\n#define OP(mtx) {NAME(#mtx), CHILD(named, stats_mutexes_##mtx)},\nMUTEX_PROF_GLOBAL_MUTEXES\n#undef OP\n\t{NAME(\"reset\"),\t\tCTL(stats_mutexes_reset)}\n};\n#undef MUTEX_PROF_DATA_NODE\n\nstatic const ctl_named_node_t stats_node[] = {\n\t{NAME(\"allocated\"),\tCTL(stats_allocated)},\n\t{NAME(\"active\"),\tCTL(stats_active)},\n\t{NAME(\"metadata\"),\tCTL(stats_metadata)},\n\t{NAME(\"metadata_thp\"),\tCTL(stats_metadata_thp)},\n\t{NAME(\"resident\"),\tCTL(stats_resident)},\n\t{NAME(\"mapped\"),\tCTL(stats_mapped)},\n\t{NAME(\"retained\"),\tCTL(stats_retained)},\n\t{NAME(\"background_thread\"),\n\t CHILD(named, stats_background_thread)},\n\t{NAME(\"mutexes\"),\tCHILD(named, stats_mutexes)},\n\t{NAME(\"arenas\"),\tCHILD(indexed, stats_arenas)}\n};\n\nstatic const ctl_named_node_t\troot_node[] = {\n\t{NAME(\"version\"),\tCTL(version)},\n\t{NAME(\"epoch\"),\t\tCTL(epoch)},\n\t{NAME(\"background_thread\"),\tCTL(background_thread)},\n\t{NAME(\"max_background_threads\"),\tCTL(max_background_threads)},\n\t{NAME(\"thread\"),\tCHILD(named, thread)},\n\t{NAME(\"config\"),\tCHILD(named, config)},\n\t{NAME(\"opt\"),\t\tCHILD(named, opt)},\n\t{NAME(\"tcache\"),\tCHILD(named, tcache)},\n\t{NAME(\"arena\"),\t\tCHILD(indexed, arena)},\n\t{NAME(\"arenas\"),\tCHILD(named, arenas)},\n\t{NAME(\"prof\"),\t\tCHILD(named, prof)},\n\t{NAME(\"stats\"),\t\tCHILD(named, stats)}\n};\nstatic const ctl_named_node_t super_root_node[] = {\n\t{NAME(\"\"),\t\tCHILD(named, root)}\n};\n\n#undef NAME\n#undef CHILD\n#undef CTL\n#undef INDEX\n\n/******************************************************************************/\n\n/*\n * Sets *dst + *src non-atomically.  This is safe, since everything is\n * synchronized by the ctl mutex.\n */\nstatic void\nctl_accum_arena_stats_u64(arena_stats_u64_t *dst, arena_stats_u64_t *src) {\n#ifdef JEMALLOC_ATOMIC_U64\n\tuint64_t cur_dst = atomic_load_u64(dst, ATOMIC_RELAXED);\n\tuint64_t cur_src = atomic_load_u64(src, ATOMIC_RELAXED);\n\tatomic_store_u64(dst, cur_dst + cur_src, ATOMIC_RELAXED);\n#else\n\t*dst += *src;\n#endif\n}\n\n/* Likewise: with ctl mutex synchronization, reading is simple. */\nstatic uint64_t\nctl_arena_stats_read_u64(arena_stats_u64_t *p) {\n#ifdef JEMALLOC_ATOMIC_U64\n\treturn atomic_load_u64(p, ATOMIC_RELAXED);\n#else\n\treturn *p;\n#endif\n}\n\nstatic void\naccum_atomic_zu(atomic_zu_t *dst, atomic_zu_t *src) {\n\tsize_t cur_dst = atomic_load_zu(dst, ATOMIC_RELAXED);\n\tsize_t cur_src = atomic_load_zu(src, ATOMIC_RELAXED);\n\tatomic_store_zu(dst, cur_dst + cur_src, ATOMIC_RELAXED);\n}\n\n/******************************************************************************/\n\nstatic unsigned\narenas_i2a_impl(size_t i, bool compat, bool validate) {\n\tunsigned a;\n\n\tswitch (i) {\n\tcase MALLCTL_ARENAS_ALL:\n\t\ta = 0;\n\t\tbreak;\n\tcase MALLCTL_ARENAS_DESTROYED:\n\t\ta = 1;\n\t\tbreak;\n\tdefault:\n\t\tif (compat && i == ctl_arenas->narenas) {\n\t\t\t/*\n\t\t\t * Provide deprecated backward compatibility for\n\t\t\t * accessing the merged stats at index narenas rather\n\t\t\t * than via MALLCTL_ARENAS_ALL.  This is scheduled for\n\t\t\t * removal in 6.0.0.\n\t\t\t */\n\t\t\ta = 0;\n\t\t} else if (validate && i >= ctl_arenas->narenas) {\n\t\t\ta = UINT_MAX;\n\t\t} else {\n\t\t\t/*\n\t\t\t * This function should never be called for an index\n\t\t\t * more than one past the range of indices that have\n\t\t\t * initialized ctl data.\n\t\t\t */\n\t\t\tassert(i < ctl_arenas->narenas || (!validate && i ==\n\t\t\t    ctl_arenas->narenas));\n\t\t\ta = (unsigned)i + 2;\n\t\t}\n\t\tbreak;\n\t}\n\n\treturn a;\n}\n\nstatic unsigned\narenas_i2a(size_t i) {\n\treturn arenas_i2a_impl(i, true, false);\n}\n\nstatic ctl_arena_t *\narenas_i_impl(tsd_t *tsd, size_t i, bool compat, bool init) {\n\tctl_arena_t *ret;\n\n\tassert(!compat || !init);\n\n\tret = ctl_arenas->arenas[arenas_i2a_impl(i, compat, false)];\n\tif (init && ret == NULL) {\n\t\tif (config_stats) {\n\t\t\tstruct container_s {\n\t\t\t\tctl_arena_t\t\tctl_arena;\n\t\t\t\tctl_arena_stats_t\tastats;\n\t\t\t};\n\t\t\tstruct container_s *cont =\n\t\t\t    (struct container_s *)base_alloc(tsd_tsdn(tsd),\n\t\t\t    b0get(), sizeof(struct container_s), QUANTUM);\n\t\t\tif (cont == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tret = &cont->ctl_arena;\n\t\t\tret->astats = &cont->astats;\n\t\t} else {\n\t\t\tret = (ctl_arena_t *)base_alloc(tsd_tsdn(tsd), b0get(),\n\t\t\t    sizeof(ctl_arena_t), QUANTUM);\n\t\t\tif (ret == NULL) {\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t\tret->arena_ind = (unsigned)i;\n\t\tctl_arenas->arenas[arenas_i2a_impl(i, compat, false)] = ret;\n\t}\n\n\tassert(ret == NULL || arenas_i2a(ret->arena_ind) == arenas_i2a(i));\n\treturn ret;\n}\n\nstatic ctl_arena_t *\narenas_i(size_t i) {\n\tctl_arena_t *ret = arenas_i_impl(tsd_fetch(), i, true, false);\n\tassert(ret != NULL);\n\treturn ret;\n}\n\nstatic void\nctl_arena_clear(ctl_arena_t *ctl_arena) {\n\tctl_arena->nthreads = 0;\n\tctl_arena->dss = dss_prec_names[dss_prec_limit];\n\tctl_arena->dirty_decay_ms = -1;\n\tctl_arena->muzzy_decay_ms = -1;\n\tctl_arena->pactive = 0;\n\tctl_arena->pdirty = 0;\n\tctl_arena->pmuzzy = 0;\n\tif (config_stats) {\n\t\tmemset(&ctl_arena->astats->astats, 0, sizeof(arena_stats_t));\n\t\tctl_arena->astats->allocated_small = 0;\n\t\tctl_arena->astats->nmalloc_small = 0;\n\t\tctl_arena->astats->ndalloc_small = 0;\n\t\tctl_arena->astats->nrequests_small = 0;\n\t\tmemset(ctl_arena->astats->bstats, 0, NBINS *\n\t\t    sizeof(bin_stats_t));\n\t\tmemset(ctl_arena->astats->lstats, 0, (NSIZES - NBINS) *\n\t\t    sizeof(arena_stats_large_t));\n\t}\n}\n\nstatic void\nctl_arena_stats_amerge(tsdn_t *tsdn, ctl_arena_t *ctl_arena, arena_t *arena) {\n\tunsigned i;\n\n\tif (config_stats) {\n\t\tarena_stats_merge(tsdn, arena, &ctl_arena->nthreads,\n\t\t    &ctl_arena->dss, &ctl_arena->dirty_decay_ms,\n\t\t    &ctl_arena->muzzy_decay_ms, &ctl_arena->pactive,\n\t\t    &ctl_arena->pdirty, &ctl_arena->pmuzzy,\n\t\t    &ctl_arena->astats->astats, ctl_arena->astats->bstats,\n\t\t    ctl_arena->astats->lstats);\n\n\t\tfor (i = 0; i < NBINS; i++) {\n\t\t\tctl_arena->astats->allocated_small +=\n\t\t\t    ctl_arena->astats->bstats[i].curregs *\n\t\t\t    sz_index2size(i);\n\t\t\tctl_arena->astats->nmalloc_small +=\n\t\t\t    ctl_arena->astats->bstats[i].nmalloc;\n\t\t\tctl_arena->astats->ndalloc_small +=\n\t\t\t    ctl_arena->astats->bstats[i].ndalloc;\n\t\t\tctl_arena->astats->nrequests_small +=\n\t\t\t    ctl_arena->astats->bstats[i].nrequests;\n\t\t}\n\t} else {\n\t\tarena_basic_stats_merge(tsdn, arena, &ctl_arena->nthreads,\n\t\t    &ctl_arena->dss, &ctl_arena->dirty_decay_ms,\n\t\t    &ctl_arena->muzzy_decay_ms, &ctl_arena->pactive,\n\t\t    &ctl_arena->pdirty, &ctl_arena->pmuzzy);\n\t}\n}\n\nstatic void\nctl_arena_stats_sdmerge(ctl_arena_t *ctl_sdarena, ctl_arena_t *ctl_arena,\n    bool destroyed) {\n\tunsigned i;\n\n\tif (!destroyed) {\n\t\tctl_sdarena->nthreads += ctl_arena->nthreads;\n\t\tctl_sdarena->pactive += ctl_arena->pactive;\n\t\tctl_sdarena->pdirty += ctl_arena->pdirty;\n\t\tctl_sdarena->pmuzzy += ctl_arena->pmuzzy;\n\t} else {\n\t\tassert(ctl_arena->nthreads == 0);\n\t\tassert(ctl_arena->pactive == 0);\n\t\tassert(ctl_arena->pdirty == 0);\n\t\tassert(ctl_arena->pmuzzy == 0);\n\t}\n\n\tif (config_stats) {\n\t\tctl_arena_stats_t *sdstats = ctl_sdarena->astats;\n\t\tctl_arena_stats_t *astats = ctl_arena->astats;\n\n\t\tif (!destroyed) {\n\t\t\taccum_atomic_zu(&sdstats->astats.mapped,\n\t\t\t    &astats->astats.mapped);\n\t\t\taccum_atomic_zu(&sdstats->astats.retained,\n\t\t\t    &astats->astats.retained);\n\t\t}\n\n\t\tctl_accum_arena_stats_u64(&sdstats->astats.decay_dirty.npurge,\n\t\t    &astats->astats.decay_dirty.npurge);\n\t\tctl_accum_arena_stats_u64(&sdstats->astats.decay_dirty.nmadvise,\n\t\t    &astats->astats.decay_dirty.nmadvise);\n\t\tctl_accum_arena_stats_u64(&sdstats->astats.decay_dirty.purged,\n\t\t    &astats->astats.decay_dirty.purged);\n\n\t\tctl_accum_arena_stats_u64(&sdstats->astats.decay_muzzy.npurge,\n\t\t    &astats->astats.decay_muzzy.npurge);\n\t\tctl_accum_arena_stats_u64(&sdstats->astats.decay_muzzy.nmadvise,\n\t\t    &astats->astats.decay_muzzy.nmadvise);\n\t\tctl_accum_arena_stats_u64(&sdstats->astats.decay_muzzy.purged,\n\t\t    &astats->astats.decay_muzzy.purged);\n\n#define OP(mtx) malloc_mutex_prof_merge(\t\t\t\t\\\n\t\t    &(sdstats->astats.mutex_prof_data[\t\t\t\\\n\t\t        arena_prof_mutex_##mtx]),\t\t\t\\\n\t\t    &(astats->astats.mutex_prof_data[\t\t\t\\\n\t\t        arena_prof_mutex_##mtx]));\nMUTEX_PROF_ARENA_MUTEXES\n#undef OP\n\t\tif (!destroyed) {\n\t\t\taccum_atomic_zu(&sdstats->astats.base,\n\t\t\t    &astats->astats.base);\n\t\t\taccum_atomic_zu(&sdstats->astats.internal,\n\t\t\t    &astats->astats.internal);\n\t\t\taccum_atomic_zu(&sdstats->astats.resident,\n\t\t\t    &astats->astats.resident);\n\t\t\taccum_atomic_zu(&sdstats->astats.metadata_thp,\n\t\t\t    &astats->astats.metadata_thp);\n\t\t} else {\n\t\t\tassert(atomic_load_zu(\n\t\t\t    &astats->astats.internal, ATOMIC_RELAXED) == 0);\n\t\t}\n\n\t\tif (!destroyed) {\n\t\t\tsdstats->allocated_small += astats->allocated_small;\n\t\t} else {\n\t\t\tassert(astats->allocated_small == 0);\n\t\t}\n\t\tsdstats->nmalloc_small += astats->nmalloc_small;\n\t\tsdstats->ndalloc_small += astats->ndalloc_small;\n\t\tsdstats->nrequests_small += astats->nrequests_small;\n\n\t\tif (!destroyed) {\n\t\t\taccum_atomic_zu(&sdstats->astats.allocated_large,\n\t\t\t    &astats->astats.allocated_large);\n\t\t} else {\n\t\t\tassert(atomic_load_zu(&astats->astats.allocated_large,\n\t\t\t    ATOMIC_RELAXED) == 0);\n\t\t}\n\t\tctl_accum_arena_stats_u64(&sdstats->astats.nmalloc_large,\n\t\t    &astats->astats.nmalloc_large);\n\t\tctl_accum_arena_stats_u64(&sdstats->astats.ndalloc_large,\n\t\t    &astats->astats.ndalloc_large);\n\t\tctl_accum_arena_stats_u64(&sdstats->astats.nrequests_large,\n\t\t    &astats->astats.nrequests_large);\n\n\t\taccum_atomic_zu(&sdstats->astats.tcache_bytes,\n\t\t    &astats->astats.tcache_bytes);\n\n\t\tif (ctl_arena->arena_ind == 0) {\n\t\t\tsdstats->astats.uptime = astats->astats.uptime;\n\t\t}\n\n\t\tfor (i = 0; i < NBINS; i++) {\n\t\t\tsdstats->bstats[i].nmalloc += astats->bstats[i].nmalloc;\n\t\t\tsdstats->bstats[i].ndalloc += astats->bstats[i].ndalloc;\n\t\t\tsdstats->bstats[i].nrequests +=\n\t\t\t    astats->bstats[i].nrequests;\n\t\t\tif (!destroyed) {\n\t\t\t\tsdstats->bstats[i].curregs +=\n\t\t\t\t    astats->bstats[i].curregs;\n\t\t\t} else {\n\t\t\t\tassert(astats->bstats[i].curregs == 0);\n\t\t\t}\n\t\t\tsdstats->bstats[i].nfills += astats->bstats[i].nfills;\n\t\t\tsdstats->bstats[i].nflushes +=\n\t\t\t    astats->bstats[i].nflushes;\n\t\t\tsdstats->bstats[i].nslabs += astats->bstats[i].nslabs;\n\t\t\tsdstats->bstats[i].reslabs += astats->bstats[i].reslabs;\n\t\t\tif (!destroyed) {\n\t\t\t\tsdstats->bstats[i].curslabs +=\n\t\t\t\t    astats->bstats[i].curslabs;\n\t\t\t} else {\n\t\t\t\tassert(astats->bstats[i].curslabs == 0);\n\t\t\t}\n\t\t\tmalloc_mutex_prof_merge(&sdstats->bstats[i].mutex_data,\n\t\t\t    &astats->bstats[i].mutex_data);\n\t\t}\n\n\t\tfor (i = 0; i < NSIZES - NBINS; i++) {\n\t\t\tctl_accum_arena_stats_u64(&sdstats->lstats[i].nmalloc,\n\t\t\t    &astats->lstats[i].nmalloc);\n\t\t\tctl_accum_arena_stats_u64(&sdstats->lstats[i].ndalloc,\n\t\t\t    &astats->lstats[i].ndalloc);\n\t\t\tctl_accum_arena_stats_u64(&sdstats->lstats[i].nrequests,\n\t\t\t    &astats->lstats[i].nrequests);\n\t\t\tif (!destroyed) {\n\t\t\t\tsdstats->lstats[i].curlextents +=\n\t\t\t\t    astats->lstats[i].curlextents;\n\t\t\t} else {\n\t\t\t\tassert(astats->lstats[i].curlextents == 0);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic void\nctl_arena_refresh(tsdn_t *tsdn, arena_t *arena, ctl_arena_t *ctl_sdarena,\n    unsigned i, bool destroyed) {\n\tctl_arena_t *ctl_arena = arenas_i(i);\n\n\tctl_arena_clear(ctl_arena);\n\tctl_arena_stats_amerge(tsdn, ctl_arena, arena);\n\t/* Merge into sum stats as well. */\n\tctl_arena_stats_sdmerge(ctl_sdarena, ctl_arena, destroyed);\n}\n\nstatic unsigned\nctl_arena_init(tsd_t *tsd, extent_hooks_t *extent_hooks) {\n\tunsigned arena_ind;\n\tctl_arena_t *ctl_arena;\n\n\tif ((ctl_arena = ql_last(&ctl_arenas->destroyed, destroyed_link)) !=\n\t    NULL) {\n\t\tql_remove(&ctl_arenas->destroyed, ctl_arena, destroyed_link);\n\t\tarena_ind = ctl_arena->arena_ind;\n\t} else {\n\t\tarena_ind = ctl_arenas->narenas;\n\t}\n\n\t/* Trigger stats allocation. */\n\tif (arenas_i_impl(tsd, arena_ind, false, true) == NULL) {\n\t\treturn UINT_MAX;\n\t}\n\n\t/* Initialize new arena. */\n\tif (arena_init(tsd_tsdn(tsd), arena_ind, extent_hooks) == NULL) {\n\t\treturn UINT_MAX;\n\t}\n\n\tif (arena_ind == ctl_arenas->narenas) {\n\t\tctl_arenas->narenas++;\n\t}\n\n\treturn arena_ind;\n}\n\nstatic void\nctl_background_thread_stats_read(tsdn_t *tsdn) {\n\tbackground_thread_stats_t *stats = &ctl_stats->background_thread;\n\tif (!have_background_thread ||\n\t    background_thread_stats_read(tsdn, stats)) {\n\t\tmemset(stats, 0, sizeof(background_thread_stats_t));\n\t\tnstime_init(&stats->run_interval, 0);\n\t}\n}\n\nstatic void\nctl_refresh(tsdn_t *tsdn) {\n\tunsigned i;\n\tctl_arena_t *ctl_sarena = arenas_i(MALLCTL_ARENAS_ALL);\n\tVARIABLE_ARRAY(arena_t *, tarenas, ctl_arenas->narenas);\n\n\t/*\n\t * Clear sum stats, since they will be merged into by\n\t * ctl_arena_refresh().\n\t */\n\tctl_arena_clear(ctl_sarena);\n\n\tfor (i = 0; i < ctl_arenas->narenas; i++) {\n\t\ttarenas[i] = arena_get(tsdn, i, false);\n\t}\n\n\tfor (i = 0; i < ctl_arenas->narenas; i++) {\n\t\tctl_arena_t *ctl_arena = arenas_i(i);\n\t\tbool initialized = (tarenas[i] != NULL);\n\n\t\tctl_arena->initialized = initialized;\n\t\tif (initialized) {\n\t\t\tctl_arena_refresh(tsdn, tarenas[i], ctl_sarena, i,\n\t\t\t    false);\n\t\t}\n\t}\n\n\tif (config_stats) {\n\t\tctl_stats->allocated = ctl_sarena->astats->allocated_small +\n\t\t    atomic_load_zu(&ctl_sarena->astats->astats.allocated_large,\n\t\t\tATOMIC_RELAXED);\n\t\tctl_stats->active = (ctl_sarena->pactive << LG_PAGE);\n\t\tctl_stats->metadata = atomic_load_zu(\n\t\t    &ctl_sarena->astats->astats.base, ATOMIC_RELAXED) +\n\t\t    atomic_load_zu(&ctl_sarena->astats->astats.internal,\n\t\t\tATOMIC_RELAXED);\n\t\tctl_stats->metadata_thp = atomic_load_zu(\n\t\t    &ctl_sarena->astats->astats.metadata_thp, ATOMIC_RELAXED);\n\t\tctl_stats->resident = atomic_load_zu(\n\t\t    &ctl_sarena->astats->astats.resident, ATOMIC_RELAXED);\n\t\tctl_stats->mapped = atomic_load_zu(\n\t\t    &ctl_sarena->astats->astats.mapped, ATOMIC_RELAXED);\n\t\tctl_stats->retained = atomic_load_zu(\n\t\t    &ctl_sarena->astats->astats.retained, ATOMIC_RELAXED);\n\n\t\tctl_background_thread_stats_read(tsdn);\n\n#define READ_GLOBAL_MUTEX_PROF_DATA(i, mtx)\t\t\t\t\\\n    malloc_mutex_lock(tsdn, &mtx);\t\t\t\t\t\\\n    malloc_mutex_prof_read(tsdn, &ctl_stats->mutex_prof_data[i], &mtx);\t\\\n    malloc_mutex_unlock(tsdn, &mtx);\n\n\t\tif (config_prof && opt_prof) {\n\t\t\tREAD_GLOBAL_MUTEX_PROF_DATA(global_prof_mutex_prof,\n\t\t\t    bt2gctx_mtx);\n\t\t}\n\t\tif (have_background_thread) {\n\t\t\tREAD_GLOBAL_MUTEX_PROF_DATA(\n\t\t\t    global_prof_mutex_background_thread,\n\t\t\t    background_thread_lock);\n\t\t} else {\n\t\t\tmemset(&ctl_stats->mutex_prof_data[\n\t\t\t    global_prof_mutex_background_thread], 0,\n\t\t\t    sizeof(mutex_prof_data_t));\n\t\t}\n\t\t/* We own ctl mutex already. */\n\t\tmalloc_mutex_prof_read(tsdn,\n\t\t    &ctl_stats->mutex_prof_data[global_prof_mutex_ctl],\n\t\t    &ctl_mtx);\n#undef READ_GLOBAL_MUTEX_PROF_DATA\n\t}\n\tctl_arenas->epoch++;\n}\n\nstatic bool\nctl_init(tsd_t *tsd) {\n\tbool ret;\n\ttsdn_t *tsdn = tsd_tsdn(tsd);\n\n\tmalloc_mutex_lock(tsdn, &ctl_mtx);\n\tif (!ctl_initialized) {\n\t\tctl_arena_t *ctl_sarena, *ctl_darena;\n\t\tunsigned i;\n\n\t\t/*\n\t\t * Allocate demand-zeroed space for pointers to the full\n\t\t * range of supported arena indices.\n\t\t */\n\t\tif (ctl_arenas == NULL) {\n\t\t\tctl_arenas = (ctl_arenas_t *)base_alloc(tsdn,\n\t\t\t    b0get(), sizeof(ctl_arenas_t), QUANTUM);\n\t\t\tif (ctl_arenas == NULL) {\n\t\t\t\tret = true;\n\t\t\t\tgoto label_return;\n\t\t\t}\n\t\t}\n\n\t\tif (config_stats && ctl_stats == NULL) {\n\t\t\tctl_stats = (ctl_stats_t *)base_alloc(tsdn, b0get(),\n\t\t\t    sizeof(ctl_stats_t), QUANTUM);\n\t\t\tif (ctl_stats == NULL) {\n\t\t\t\tret = true;\n\t\t\t\tgoto label_return;\n\t\t\t}\n\t\t}\n\n\t\t/*\n\t\t * Allocate space for the current full range of arenas\n\t\t * here rather than doing it lazily elsewhere, in order\n\t\t * to limit when OOM-caused errors can occur.\n\t\t */\n\t\tif ((ctl_sarena = arenas_i_impl(tsd, MALLCTL_ARENAS_ALL, false,\n\t\t    true)) == NULL) {\n\t\t\tret = true;\n\t\t\tgoto label_return;\n\t\t}\n\t\tctl_sarena->initialized = true;\n\n\t\tif ((ctl_darena = arenas_i_impl(tsd, MALLCTL_ARENAS_DESTROYED,\n\t\t    false, true)) == NULL) {\n\t\t\tret = true;\n\t\t\tgoto label_return;\n\t\t}\n\t\tctl_arena_clear(ctl_darena);\n\t\t/*\n\t\t * Don't toggle ctl_darena to initialized until an arena is\n\t\t * actually destroyed, so that arena.<i>.initialized can be used\n\t\t * to query whether the stats are relevant.\n\t\t */\n\n\t\tctl_arenas->narenas = narenas_total_get();\n\t\tfor (i = 0; i < ctl_arenas->narenas; i++) {\n\t\t\tif (arenas_i_impl(tsd, i, false, true) == NULL) {\n\t\t\t\tret = true;\n\t\t\t\tgoto label_return;\n\t\t\t}\n\t\t}\n\n\t\tql_new(&ctl_arenas->destroyed);\n\t\tctl_refresh(tsdn);\n\n\t\tctl_initialized = true;\n\t}\n\n\tret = false;\nlabel_return:\n\tmalloc_mutex_unlock(tsdn, &ctl_mtx);\n\treturn ret;\n}\n\nstatic int\nctl_lookup(tsdn_t *tsdn, const char *name, ctl_node_t const **nodesp,\n    size_t *mibp, size_t *depthp) {\n\tint ret;\n\tconst char *elm, *tdot, *dot;\n\tsize_t elen, i, j;\n\tconst ctl_named_node_t *node;\n\n\telm = name;\n\t/* Equivalent to strchrnul(). */\n\tdot = ((tdot = strchr(elm, '.')) != NULL) ? tdot : strchr(elm, '\\0');\n\telen = (size_t)((uintptr_t)dot - (uintptr_t)elm);\n\tif (elen == 0) {\n\t\tret = ENOENT;\n\t\tgoto label_return;\n\t}\n\tnode = super_root_node;\n\tfor (i = 0; i < *depthp; i++) {\n\t\tassert(node);\n\t\tassert(node->nchildren > 0);\n\t\tif (ctl_named_node(node->children) != NULL) {\n\t\t\tconst ctl_named_node_t *pnode = node;\n\n\t\t\t/* Children are named. */\n\t\t\tfor (j = 0; j < node->nchildren; j++) {\n\t\t\t\tconst ctl_named_node_t *child =\n\t\t\t\t    ctl_named_children(node, j);\n\t\t\t\tif (strlen(child->name) == elen &&\n\t\t\t\t    strncmp(elm, child->name, elen) == 0) {\n\t\t\t\t\tnode = child;\n\t\t\t\t\tif (nodesp != NULL) {\n\t\t\t\t\t\tnodesp[i] =\n\t\t\t\t\t\t    (const ctl_node_t *)node;\n\t\t\t\t\t}\n\t\t\t\t\tmibp[i] = j;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (node == pnode) {\n\t\t\t\tret = ENOENT;\n\t\t\t\tgoto label_return;\n\t\t\t}\n\t\t} else {\n\t\t\tuintmax_t index;\n\t\t\tconst ctl_indexed_node_t *inode;\n\n\t\t\t/* Children are indexed. */\n\t\t\tindex = malloc_strtoumax(elm, NULL, 10);\n\t\t\tif (index == UINTMAX_MAX || index > SIZE_T_MAX) {\n\t\t\t\tret = ENOENT;\n\t\t\t\tgoto label_return;\n\t\t\t}\n\n\t\t\tinode = ctl_indexed_node(node->children);\n\t\t\tnode = inode->index(tsdn, mibp, *depthp, (size_t)index);\n\t\t\tif (node == NULL) {\n\t\t\t\tret = ENOENT;\n\t\t\t\tgoto label_return;\n\t\t\t}\n\n\t\t\tif (nodesp != NULL) {\n\t\t\t\tnodesp[i] = (const ctl_node_t *)node;\n\t\t\t}\n\t\t\tmibp[i] = (size_t)index;\n\t\t}\n\n\t\tif (node->ctl != NULL) {\n\t\t\t/* Terminal node. */\n\t\t\tif (*dot != '\\0') {\n\t\t\t\t/*\n\t\t\t\t * The name contains more elements than are\n\t\t\t\t * in this path through the tree.\n\t\t\t\t */\n\t\t\t\tret = ENOENT;\n\t\t\t\tgoto label_return;\n\t\t\t}\n\t\t\t/* Complete lookup successful. */\n\t\t\t*depthp = i + 1;\n\t\t\tbreak;\n\t\t}\n\n\t\t/* Update elm. */\n\t\tif (*dot == '\\0') {\n\t\t\t/* No more elements. */\n\t\t\tret = ENOENT;\n\t\t\tgoto label_return;\n\t\t}\n\t\telm = &dot[1];\n\t\tdot = ((tdot = strchr(elm, '.')) != NULL) ? tdot :\n\t\t    strchr(elm, '\\0');\n\t\telen = (size_t)((uintptr_t)dot - (uintptr_t)elm);\n\t}\n\n\tret = 0;\nlabel_return:\n\treturn ret;\n}\n\nint\nctl_byname(tsd_t *tsd, const char *name, void *oldp, size_t *oldlenp,\n    void *newp, size_t newlen) {\n\tint ret;\n\tsize_t depth;\n\tctl_node_t const *nodes[CTL_MAX_DEPTH];\n\tsize_t mib[CTL_MAX_DEPTH];\n\tconst ctl_named_node_t *node;\n\n\tif (!ctl_initialized && ctl_init(tsd)) {\n\t\tret = EAGAIN;\n\t\tgoto label_return;\n\t}\n\n\tdepth = CTL_MAX_DEPTH;\n\tret = ctl_lookup(tsd_tsdn(tsd), name, nodes, mib, &depth);\n\tif (ret != 0) {\n\t\tgoto label_return;\n\t}\n\n\tnode = ctl_named_node(nodes[depth-1]);\n\tif (node != NULL && node->ctl) {\n\t\tret = node->ctl(tsd, mib, depth, oldp, oldlenp, newp, newlen);\n\t} else {\n\t\t/* The name refers to a partial path through the ctl tree. */\n\t\tret = ENOENT;\n\t}\n\nlabel_return:\n\treturn(ret);\n}\n\nint\nctl_nametomib(tsd_t *tsd, const char *name, size_t *mibp, size_t *miblenp) {\n\tint ret;\n\n\tif (!ctl_initialized && ctl_init(tsd)) {\n\t\tret = EAGAIN;\n\t\tgoto label_return;\n\t}\n\n\tret = ctl_lookup(tsd_tsdn(tsd), name, NULL, mibp, miblenp);\nlabel_return:\n\treturn(ret);\n}\n\nint\nctl_bymib(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,\n    size_t *oldlenp, void *newp, size_t newlen) {\n\tint ret;\n\tconst ctl_named_node_t *node;\n\tsize_t i;\n\n\tif (!ctl_initialized && ctl_init(tsd)) {\n\t\tret = EAGAIN;\n\t\tgoto label_return;\n\t}\n\n\t/* Iterate down the tree. */\n\tnode = super_root_node;\n\tfor (i = 0; i < miblen; i++) {\n\t\tassert(node);\n\t\tassert(node->nchildren > 0);\n\t\tif (ctl_named_node(node->children) != NULL) {\n\t\t\t/* Children are named. */\n\t\t\tif (node->nchildren <= mib[i]) {\n\t\t\t\tret = ENOENT;\n\t\t\t\tgoto label_return;\n\t\t\t}\n\t\t\tnode = ctl_named_children(node, mib[i]);\n\t\t} else {\n\t\t\tconst ctl_indexed_node_t *inode;\n\n\t\t\t/* Indexed element. */\n\t\t\tinode = ctl_indexed_node(node->children);\n\t\t\tnode = inode->index(tsd_tsdn(tsd), mib, miblen, mib[i]);\n\t\t\tif (node == NULL) {\n\t\t\t\tret = ENOENT;\n\t\t\t\tgoto label_return;\n\t\t\t}\n\t\t}\n\t}\n\n\t/* Call the ctl function. */\n\tif (node && node->ctl) {\n\t\tret = node->ctl(tsd, mib, miblen, oldp, oldlenp, newp, newlen);\n\t} else {\n\t\t/* Partial MIB. */\n\t\tret = ENOENT;\n\t}\n\nlabel_return:\n\treturn(ret);\n}\n\nbool\nctl_boot(void) {\n\tif (malloc_mutex_init(&ctl_mtx, \"ctl\", WITNESS_RANK_CTL,\n\t    malloc_mutex_rank_exclusive)) {\n\t\treturn true;\n\t}\n\n\tctl_initialized = false;\n\n\treturn false;\n}\n\nvoid\nctl_prefork(tsdn_t *tsdn) {\n\tmalloc_mutex_prefork(tsdn, &ctl_mtx);\n}\n\nvoid\nctl_postfork_parent(tsdn_t *tsdn) {\n\tmalloc_mutex_postfork_parent(tsdn, &ctl_mtx);\n}\n\nvoid\nctl_postfork_child(tsdn_t *tsdn) {\n\tmalloc_mutex_postfork_child(tsdn, &ctl_mtx);\n}\n\n/******************************************************************************/\n/* *_ctl() functions. */\n\n#define READONLY()\tdo {\t\t\t\t\t\t\\\n\tif (newp != NULL || newlen != 0) {\t\t\t\t\\\n\t\tret = EPERM;\t\t\t\t\t\t\\\n\t\tgoto label_return;\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n#define WRITEONLY()\tdo {\t\t\t\t\t\t\\\n\tif (oldp != NULL || oldlenp != NULL) {\t\t\t\t\\\n\t\tret = EPERM;\t\t\t\t\t\t\\\n\t\tgoto label_return;\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n#define READ_XOR_WRITE()\tdo {\t\t\t\t\t\\\n\tif ((oldp != NULL && oldlenp != NULL) && (newp != NULL ||\t\\\n\t    newlen != 0)) {\t\t\t\t\t\t\\\n\t\tret = EPERM;\t\t\t\t\t\t\\\n\t\tgoto label_return;\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n#define READ(v, t)\tdo {\t\t\t\t\t\t\\\n\tif (oldp != NULL && oldlenp != NULL) {\t\t\t\t\\\n\t\tif (*oldlenp != sizeof(t)) {\t\t\t\t\\\n\t\t\tsize_t\tcopylen = (sizeof(t) <= *oldlenp)\t\\\n\t\t\t    ? sizeof(t) : *oldlenp;\t\t\t\\\n\t\t\tmemcpy(oldp, (void *)&(v), copylen);\t\t\\\n\t\t\tret = EINVAL;\t\t\t\t\t\\\n\t\t\tgoto label_return;\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\t*(t *)oldp = (v);\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n#define WRITE(v, t)\tdo {\t\t\t\t\t\t\\\n\tif (newp != NULL) {\t\t\t\t\t\t\\\n\t\tif (newlen != sizeof(t)) {\t\t\t\t\\\n\t\t\tret = EINVAL;\t\t\t\t\t\\\n\t\t\tgoto label_return;\t\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t\t(v) = *(t *)newp;\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n} while (0)\n\n#define MIB_UNSIGNED(v, i) do {\t\t\t\t\t\t\\\n\tif (mib[i] > UINT_MAX) {\t\t\t\t\t\\\n\t\tret = EFAULT;\t\t\t\t\t\t\\\n\t\tgoto label_return;\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tv = (unsigned)mib[i];\t\t\t\t\t\t\\\n} while (0)\n\n/*\n * There's a lot of code duplication in the following macros due to limitations\n * in how nested cpp macros are expanded.\n */\n#define CTL_RO_CLGEN(c, l, n, v, t)\t\t\t\t\t\\\nstatic int\t\t\t\t\t\t\t\t\\\nn##_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,\t\\\n    size_t *oldlenp, void *newp, size_t newlen) {\t\t\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\tt oldval;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (!(c)) {\t\t\t\t\t\t\t\\\n\t\treturn ENOENT;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tif (l) {\t\t\t\t\t\t\t\\\n\t\tmalloc_mutex_lock(tsd_tsdn(tsd), &ctl_mtx);\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tREADONLY();\t\t\t\t\t\t\t\\\n\toldval = (v);\t\t\t\t\t\t\t\\\n\tREAD(oldval, t);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = 0;\t\t\t\t\t\t\t\\\nlabel_return:\t\t\t\t\t\t\t\t\\\n\tif (l) {\t\t\t\t\t\t\t\\\n\t\tmalloc_mutex_unlock(tsd_tsdn(tsd), &ctl_mtx);\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\treturn ret;\t\t\t\t\t\t\t\\\n}\n\n#define CTL_RO_CGEN(c, n, v, t)\t\t\t\t\t\t\\\nstatic int\t\t\t\t\t\t\t\t\\\nn##_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,\t\\\n    size_t *oldlenp, void *newp, size_t newlen) {\t\t\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\tt oldval;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (!(c)) {\t\t\t\t\t\t\t\\\n\t\treturn ENOENT;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tmalloc_mutex_lock(tsd_tsdn(tsd), &ctl_mtx);\t\t\t\\\n\tREADONLY();\t\t\t\t\t\t\t\\\n\toldval = (v);\t\t\t\t\t\t\t\\\n\tREAD(oldval, t);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = 0;\t\t\t\t\t\t\t\\\nlabel_return:\t\t\t\t\t\t\t\t\\\n\tmalloc_mutex_unlock(tsd_tsdn(tsd), &ctl_mtx);\t\t\t\\\n\treturn ret;\t\t\t\t\t\t\t\\\n}\n\n#define CTL_RO_GEN(n, v, t)\t\t\t\t\t\t\\\nstatic int\t\t\t\t\t\t\t\t\\\nn##_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,\t\\\n    size_t *oldlenp, void *newp, size_t newlen) {\t\t\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\tt oldval;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tmalloc_mutex_lock(tsd_tsdn(tsd), &ctl_mtx);\t\t\t\\\n\tREADONLY();\t\t\t\t\t\t\t\\\n\toldval = (v);\t\t\t\t\t\t\t\\\n\tREAD(oldval, t);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = 0;\t\t\t\t\t\t\t\\\nlabel_return:\t\t\t\t\t\t\t\t\\\n\tmalloc_mutex_unlock(tsd_tsdn(tsd), &ctl_mtx);\t\t\t\\\n\treturn ret;\t\t\t\t\t\t\t\\\n}\n\n/*\n * ctl_mtx is not acquired, under the assumption that no pertinent data will\n * mutate during the call.\n */\n#define CTL_RO_NL_CGEN(c, n, v, t)\t\t\t\t\t\\\nstatic int\t\t\t\t\t\t\t\t\\\nn##_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,\t\\\n    size_t *oldlenp, void *newp, size_t newlen) {\t\t\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\tt oldval;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (!(c)) {\t\t\t\t\t\t\t\\\n\t\treturn ENOENT;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tREADONLY();\t\t\t\t\t\t\t\\\n\toldval = (v);\t\t\t\t\t\t\t\\\n\tREAD(oldval, t);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = 0;\t\t\t\t\t\t\t\\\nlabel_return:\t\t\t\t\t\t\t\t\\\n\treturn ret;\t\t\t\t\t\t\t\\\n}\n\n#define CTL_RO_NL_GEN(n, v, t)\t\t\t\t\t\t\\\nstatic int\t\t\t\t\t\t\t\t\\\nn##_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,\t\\\n    size_t *oldlenp, void *newp, size_t newlen) {\t\t\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\tt oldval;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tREADONLY();\t\t\t\t\t\t\t\\\n\toldval = (v);\t\t\t\t\t\t\t\\\n\tREAD(oldval, t);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = 0;\t\t\t\t\t\t\t\\\nlabel_return:\t\t\t\t\t\t\t\t\\\n\treturn ret;\t\t\t\t\t\t\t\\\n}\n\n#define CTL_TSD_RO_NL_CGEN(c, n, m, t)\t\t\t\t\t\\\nstatic int\t\t\t\t\t\t\t\t\\\nn##_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,\t\\\n    size_t *oldlenp, void *newp, size_t newlen) {\t\t\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\tt oldval;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tif (!(c)) {\t\t\t\t\t\t\t\\\n\t\treturn ENOENT;\t\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\t\t\\\n\tREADONLY();\t\t\t\t\t\t\t\\\n\toldval = (m(tsd));\t\t\t\t\t\t\\\n\tREAD(oldval, t);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = 0;\t\t\t\t\t\t\t\\\nlabel_return:\t\t\t\t\t\t\t\t\\\n\treturn ret;\t\t\t\t\t\t\t\\\n}\n\n#define CTL_RO_CONFIG_GEN(n, t)\t\t\t\t\t\t\\\nstatic int\t\t\t\t\t\t\t\t\\\nn##_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,\t\\\n    size_t *oldlenp, void *newp, size_t newlen) {\t\t\t\\\n\tint ret;\t\t\t\t\t\t\t\\\n\tt oldval;\t\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tREADONLY();\t\t\t\t\t\t\t\\\n\toldval = n;\t\t\t\t\t\t\t\\\n\tREAD(oldval, t);\t\t\t\t\t\t\\\n\t\t\t\t\t\t\t\t\t\\\n\tret = 0;\t\t\t\t\t\t\t\\\nlabel_return:\t\t\t\t\t\t\t\t\\\n\treturn ret;\t\t\t\t\t\t\t\\\n}\n\n/******************************************************************************/\n\nCTL_RO_NL_GEN(version, JEMALLOC_VERSION, const char *)\n\nstatic int\nepoch_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,\n    size_t *oldlenp, void *newp, size_t newlen) {\n\tint ret;\n\tUNUSED uint64_t newval;\n\n\tmalloc_mutex_lock(tsd_tsdn(tsd), &ctl_mtx);\n\tWRITE(newval, uint64_t);\n\tif (newp != NULL) {\n\t\tctl_refresh(tsd_tsdn(tsd));\n\t}\n\tREAD(ctl_arenas->epoch, uint64_t);\n\n\tret = 0;\nlabel_return:\n\tmalloc_mutex_unlock(tsd_tsdn(tsd), &ctl_mtx);\n\treturn ret;\n}\n\nstatic int\nbackground_thread_ctl(tsd_t *tsd, const size_t *mib, size_t miblen,\n    void *oldp, size_t *oldlenp, void *newp, size_t newlen) {\n\tint ret;\n\tbool oldval;\n\n\tif (!have_background_thread) {\n\t\treturn ENOENT;\n\t}\n\tbackground_thread_ctl_init(tsd_tsdn(tsd));\n\n\tmalloc_mutex_lock(tsd_tsdn(tsd), &ctl_mtx);\n\tmalloc_mutex_lock(tsd_tsdn(tsd), &background_thread_lock);\n\tif (newp == NULL) {\n\t\toldval = background_thread_enabled();\n\t\tREAD(oldval, bool);\n\t} else {\n\t\tif (newlen != sizeof(bool)) {\n\t\t\tret = EINVAL;\n\t\t\tgoto label_return;\n\t\t}\n\t\toldval = background_thread_enabled();\n\t\tREAD(oldval, bool);\n\n\t\tbool newval = *(bool *)newp;\n\t\tif (newval == oldval) {\n\t\t\tret = 0;\n\t\t\tgoto label_return;\n\t\t}\n\n\t\tbackground_thread_enabled_set(tsd_tsdn(tsd), newval);\n\t\tif (newval) {\n\t\t\tif (!can_enable_background_thread) {\n\t\t\t\tmalloc_printf(\"<jemalloc>: Error in dlsym(\"\n\t\t\t            \"RTLD_NEXT, \\\"pthread_create\\\"). Cannot \"\n\t\t\t\t    \"enable background_thread\\n\");\n\t\t\t\tret = EFAULT;\n\t\t\t\tgoto label_return;\n\t\t\t}\n\t\t\tif (background_threads_enable(tsd)) {\n\t\t\t\tret = EFAULT;\n\t\t\t\tgoto label_return;\n\t\t\t}\n\t\t} else {\n\t\t\tif (background_threads_disable(tsd)) {\n\t\t\t\tret = EFAULT;\n\t\t\t\tgoto label_return;\n\t\t\t}\n\t\t}\n\t}\n\tret = 0;\nlabel_return:\n\tmalloc_mutex_unlock(tsd_tsdn(tsd), &background_thread_lock);\n\tmalloc_mutex_unlock(tsd_tsdn(tsd), &ctl_mtx);\n\n\treturn ret;\n}\n\nstatic int\nmax_background_threads_ctl(tsd_t *tsd, const size_t *mib, size_t miblen,\n    void *oldp, size_t *oldlenp, void *newp, size_t newlen) {\n\tint ret;\n\tsize_t oldval;\n\n\tif (!have_background_thread) {\n\t\treturn ENOENT;\n\t}\n\tbackground_thread_ctl_init(tsd_tsdn(tsd));\n\n\tmalloc_mutex_lock(tsd_tsdn(tsd), &ctl_mtx);\n\tmalloc_mutex_lock(tsd_tsdn(tsd), &background_thread_lock);\n\tif (newp == NULL) {\n\t\toldval = max_background_threads;\n\t\tREAD(oldval, size_t);\n\t} else {\n\t\tif (newlen != sizeof(size_t)) {\n\t\t\tret = EINVAL;\n\t\t\tgoto label_return;\n\t\t}\n\t\toldval = max_background_threads;\n\t\tREAD(oldval, size_t);\n\n\t\tsize_t newval = *(size_t *)newp;\n\t\tif (newval == oldval) {\n\t\t\tret = 0;\n\t\t\tgoto label_return;\n\t\t}\n\t\tif (newval > opt_max_background_threads) {\n\t\t\tret = EINVAL;\n\t\t\tgoto label_return;\n\t\t}\n\n\t\tif (background_thread_enabled()) {\n\t\t\tif (!can_enable_background_thread) {\n\t\t\t\tmalloc_printf(\"<jemalloc>: Error in dlsym(\"\n\t\t\t            \"RTLD_NEXT, \\\"pthread_create\\\"). Cannot \"\n\t\t\t\t    \"enable background_thread\\n\");\n\t\t\t\tret = EFAULT;\n\t\t\t\tgoto label_return;\n\t\t\t}\n\t\t\tbackground_thread_enabled_set(tsd_tsdn(tsd), false);\n\t\t\tif (background_threads_disable(tsd)) {\n\t\t\t\tret = EFAULT;\n\t\t\t\tgoto label_return;\n\t\t\t}\n\t\t\tmax_background_threads = newval;\n\t\t\tbackground_thread_enabled_set(tsd_tsdn(tsd), true);\n\t\t\tif (background_threads_enable(tsd)) {\n\t\t\t\tret = EFAULT;\n\t\t\t\tgoto label_return;\n\t\t\t}\n\t\t} else {\n\t\t\tmax_background_threads = newval;\n\t\t}\n\t}\n\tret = 0;\nlabel_return:\n\tmalloc_mutex_unlock(tsd_tsdn(tsd), &background_thread_lock);\n\tmalloc_mutex_unlock(tsd_tsdn(tsd), &ctl_mtx);\n\n\treturn ret;\n}\n\n/******************************************************************************/\n\nCTL_RO_CONFIG_GEN(config_cache_oblivious, bool)\nCTL_RO_CONFIG_GEN(config_debug, bool)\nCTL_RO_CONFIG_GEN(config_fill, bool)\nCTL_RO_CONFIG_GEN(config_lazy_lock, bool)\nCTL_RO_CONFIG_GEN(config_malloc_conf, const char *)\nCTL_RO_CONFIG_GEN(config_prof, bool)\nCTL_RO_CONFIG_GEN(config_prof_libgcc, bool)\nCTL_RO_CONFIG_GEN(config_prof_libunwind, bool)\nCTL_RO_CONFIG_GEN(config_stats, bool)\nCTL_RO_CONFIG_GEN(config_utrace, bool)\nCTL_RO_CONFIG_GEN(config_xmalloc, bool)\n\n/******************************************************************************/\n\nCTL_RO_NL_GEN(opt_abort, opt_abort, bool)\nCTL_RO_NL_GEN(opt_abort_conf, opt_abort_conf, bool)\nCTL_RO_NL_GEN(opt_metadata_thp, metadata_thp_mode_names[opt_metadata_thp],\n    const char *)\nCTL_RO_NL_GEN(opt_retain, opt_retain, bool)\nCTL_RO_NL_GEN(opt_dss, opt_dss, const char *)\nCTL_RO_NL_GEN(opt_narenas, opt_narenas, unsigned)\nCTL_RO_NL_GEN(opt_percpu_arena, percpu_arena_mode_names[opt_percpu_arena],\n    const char *)\nCTL_RO_NL_GEN(opt_background_thread, opt_background_thread, bool)\nCTL_RO_NL_GEN(opt_max_background_threads, opt_max_background_threads, size_t)\nCTL_RO_NL_GEN(opt_dirty_decay_ms, opt_dirty_decay_ms, ssize_t)\nCTL_RO_NL_GEN(opt_muzzy_decay_ms, opt_muzzy_decay_ms, ssize_t)\nCTL_RO_NL_GEN(opt_stats_print, opt_stats_print, bool)\nCTL_RO_NL_GEN(opt_stats_print_opts, opt_stats_print_opts, const char *)\nCTL_RO_NL_CGEN(config_fill, opt_junk, opt_junk, const char *)\nCTL_RO_NL_CGEN(config_fill, opt_zero, opt_zero, bool)\nCTL_RO_NL_CGEN(config_utrace, opt_utrace, opt_utrace, bool)\nCTL_RO_NL_CGEN(config_xmalloc, opt_xmalloc, opt_xmalloc, bool)\nCTL_RO_NL_GEN(opt_tcache, opt_tcache, bool)\nCTL_RO_NL_GEN(opt_thp, thp_mode_names[opt_thp], const char *)\nCTL_RO_NL_GEN(opt_lg_extent_max_active_fit, opt_lg_extent_max_active_fit,\n    size_t)\nCTL_RO_NL_GEN(opt_lg_tcache_max, opt_lg_tcache_max, ssize_t)\nCTL_RO_NL_CGEN(config_prof, opt_prof, opt_prof, bool)\nCTL_RO_NL_CGEN(config_prof, opt_prof_prefix, opt_prof_prefix, const char *)\nCTL_RO_NL_CGEN(config_prof, opt_prof_active, opt_prof_active, bool)\nCTL_RO_NL_CGEN(config_prof, opt_prof_thread_active_init,\n    opt_prof_thread_active_init, bool)\nCTL_RO_NL_CGEN(config_prof, opt_lg_prof_sample, opt_lg_prof_sample, size_t)\nCTL_RO_NL_CGEN(config_prof, opt_prof_accum, opt_prof_accum, bool)\nCTL_RO_NL_CGEN(config_prof, opt_lg_prof_interval, opt_lg_prof_interval, ssize_t)\nCTL_RO_NL_CGEN(config_prof, opt_prof_gdump, opt_prof_gdump, bool)\nCTL_RO_NL_CGEN(config_prof, opt_prof_final, opt_prof_final, bool)\nCTL_RO_NL_CGEN(config_prof, opt_prof_leak, opt_prof_leak, bool)\n\n/******************************************************************************/\n\nstatic int\nthread_arena_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,\n    size_t *oldlenp, void *newp, size_t newlen) {\n\tint ret;\n\tarena_t *oldarena;\n\tunsigned newind, oldind;\n\n\toldarena = arena_choose(tsd, NULL);\n\tif (oldarena == NULL) {\n\t\treturn EAGAIN;\n\t}\n\tnewind = oldind = arena_ind_get(oldarena);\n\tWRITE(newind, unsigned);\n\tREAD(oldind, unsigned);\n\n\tif (newind != oldind) {\n\t\tarena_t *newarena;\n\n\t\tif (newind >= narenas_total_get()) {\n\t\t\t/* New arena index is out of range. */\n\t\t\tret = EFAULT;\n\t\t\tgoto label_return;\n\t\t}\n\n\t\tif (have_percpu_arena &&\n\t\t    PERCPU_ARENA_ENABLED(opt_percpu_arena)) {\n\t\t\tif (newind < percpu_arena_ind_limit(opt_percpu_arena)) {\n\t\t\t\t/*\n\t\t\t\t * If perCPU arena is enabled, thread_arena\n\t\t\t\t * control is not allowed for the auto arena\n\t\t\t\t * range.\n\t\t\t\t */\n\t\t\t\tret = EPERM;\n\t\t\t\tgoto label_return;\n\t\t\t}\n\t\t}\n\n\t\t/* Initialize arena if necessary. */\n\t\tnewarena = arena_get(tsd_tsdn(tsd), newind, true);\n\t\tif (newarena == NULL) {\n\t\t\tret = EAGAIN;\n\t\t\tgoto label_return;\n\t\t}\n\t\t/* Set new arena/tcache associations. */\n\t\tarena_migrate(tsd, oldind, newind);\n\t\tif (tcache_available(tsd)) {\n\t\t\ttcache_arena_reassociate(tsd_tsdn(tsd),\n\t\t\t    tsd_tcachep_get(tsd), newarena);\n\t\t}\n\t}\n\n\tret = 0;\nlabel_return:\n\treturn ret;\n}\n\nCTL_TSD_RO_NL_CGEN(config_stats, thread_allocated, tsd_thread_allocated_get,\n    uint64_t)\nCTL_TSD_RO_NL_CGEN(config_stats, thread_allocatedp, tsd_thread_allocatedp_get,\n    uint64_t *)\nCTL_TSD_RO_NL_CGEN(config_stats, thread_deallocated, tsd_thread_deallocated_get,\n    uint64_t)\nCTL_TSD_RO_NL_CGEN(config_stats, thread_deallocatedp,\n    tsd_thread_deallocatedp_get, uint64_t *)\n\nstatic int\nthread_tcache_enabled_ctl(tsd_t *tsd, const size_t *mib, size_t miblen,\n    void *oldp, size_t *oldlenp, void *newp, size_t newlen) {\n\tint ret;\n\tbool oldval;\n\n\toldval = tcache_enabled_get(tsd);\n\tif (newp != NULL) {\n\t\tif (newlen != sizeof(bool)) {\n\t\t\tret = EINVAL;\n\t\t\tgoto label_return;\n\t\t}\n\t\ttcache_enabled_set(tsd, *(bool *)newp);\n\t}\n\tREAD(oldval, bool);\n\n\tret = 0;\nlabel_return:\n\treturn ret;\n}\n\nstatic int\nthread_tcache_flush_ctl(tsd_t *tsd, const size_t *mib, size_t miblen,\n    void *oldp, size_t *oldlenp, void *newp, size_t newlen) {\n\tint ret;\n\n\tif (!tcache_available(tsd)) {\n\t\tret = EFAULT;\n\t\tgoto label_return;\n\t}\n\n\tREADONLY();\n\tWRITEONLY();\n\n\ttcache_flush(tsd);\n\n\tret = 0;\nlabel_return:\n\treturn ret;\n}\n\nstatic int\nthread_prof_name_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,\n    size_t *oldlenp, void *newp, size_t newlen) {\n\tint ret;\n\n\tif (!config_prof) {\n\t\treturn ENOENT;\n\t}\n\n\tREAD_XOR_WRITE();\n\n\tif (newp != NULL) {\n\t\tif (newlen != sizeof(const char *)) {\n\t\t\tret = EINVAL;\n\t\t\tgoto label_return;\n\t\t}\n\n\t\tif ((ret = prof_thread_name_set(tsd, *(const char **)newp)) !=\n\t\t    0) {\n\t\t\tgoto label_return;\n\t\t}\n\t} else {\n\t\tconst char *oldname = prof_thread_name_get(tsd);\n\t\tREAD(oldname, const char *);\n\t}\n\n\tret = 0;\nlabel_return:\n\treturn ret;\n}\n\nstatic int\nthread_prof_active_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,\n    size_t *oldlenp, void *newp, size_t newlen) {\n\tint ret;\n\tbool oldval;\n\n\tif (!config_prof) {\n\t\treturn ENOENT;\n\t}\n\n\toldval = prof_thread_active_get(tsd);\n\tif (newp != NULL) {\n\t\tif (newlen != sizeof(bool)) {\n\t\t\tret = EINVAL;\n\t\t\tgoto label_return;\n\t\t}\n\t\tif (prof_thread_active_set(tsd, *(bool *)newp)) {\n\t\t\tret = EAGAIN;\n\t\t\tgoto label_return;\n\t\t}\n\t}\n\tREAD(oldval, bool);\n\n\tret = 0;\nlabel_return:\n\treturn ret;\n}\n\n/******************************************************************************/\n\nstatic int\ntcache_create_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,\n    size_t *oldlenp, void *newp, size_t newlen) {\n\tint ret;\n\tunsigned tcache_ind;\n\n\tREADONLY();\n\tif (tcaches_create(tsd, &tcache_ind)) {\n\t\tret = EFAULT;\n\t\tgoto label_return;\n\t}\n\tREAD(tcache_ind, unsigned);\n\n\tret = 0;\nlabel_return:\n\treturn ret;\n}\n\nstatic int\ntcache_flush_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,\n    size_t *oldlenp, void *newp, size_t newlen) {\n\tint ret;\n\tunsigned tcache_ind;\n\n\tWRITEONLY();\n\ttcache_ind = UINT_MAX;\n\tWRITE(tcache_ind, unsigned);\n\tif (tcache_ind == UINT_MAX) {\n\t\tret = EFAULT;\n\t\tgoto label_return;\n\t}\n\ttcaches_flush(tsd, tcache_ind);\n\n\tret = 0;\nlabel_return:\n\treturn ret;\n}\n\nstatic int\ntcache_destroy_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,\n    size_t *oldlenp, void *newp, size_t newlen) {\n\tint ret;\n\tunsigned tcache_ind;\n\n\tWRITEONLY();\n\ttcache_ind = UINT_MAX;\n\tWRITE(tcache_ind, unsigned);\n\tif (tcache_ind == UINT_MAX) {\n\t\tret = EFAULT;\n\t\tgoto label_return;\n\t}\n\ttcaches_destroy(tsd, tcache_ind);\n\n\tret = 0;\nlabel_return:\n\treturn ret;\n}\n\n/******************************************************************************/\n\nstatic int\narena_i_initialized_ctl(tsd_t *tsd, const size_t *mib, size_t miblen,\n    void *oldp, size_t *oldlenp, void *newp, size_t newlen) {\n\tint ret;\n\ttsdn_t *tsdn = tsd_tsdn(tsd);\n\tunsigned arena_ind;\n\tbool initialized;\n\n\tREADONLY();\n\tMIB_UNSIGNED(arena_ind, 1);\n\n\tmalloc_mutex_lock(tsdn, &ctl_mtx);\n\tinitialized = arenas_i(arena_ind)->initialized;\n\tmalloc_mutex_unlock(tsdn, &ctl_mtx);\n\n\tREAD(initialized, bool);\n\n\tret = 0;\nlabel_return:\n\treturn ret;\n}\n\nstatic void\narena_i_decay(tsdn_t *tsdn, unsigned arena_ind, bool all) {\n\tmalloc_mutex_lock(tsdn, &ctl_mtx);\n\t{\n\t\tunsigned narenas = ctl_arenas->narenas;\n\n\t\t/*\n\t\t * Access via index narenas is deprecated, and scheduled for\n\t\t * removal in 6.0.0.\n\t\t */\n\t\tif (arena_ind == MALLCTL_ARENAS_ALL || arena_ind == narenas) {\n\t\t\tunsigned i;\n\t\t\tVARIABLE_ARRAY(arena_t *, tarenas, narenas);\n\n\t\t\tfor (i = 0; i < narenas; i++) {\n\t\t\t\ttarenas[i] = arena_get(tsdn, i, false);\n\t\t\t}\n\n\t\t\t/*\n\t\t\t * No further need to hold ctl_mtx, since narenas and\n\t\t\t * tarenas contain everything needed below.\n\t\t\t */\n\t\t\tmalloc_mutex_unlock(tsdn, &ctl_mtx);\n\n\t\t\tfor (i = 0; i < narenas; i++) {\n\t\t\t\tif (tarenas[i] != NULL) {\n\t\t\t\t\tarena_decay(tsdn, tarenas[i], false,\n\t\t\t\t\t    all);\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tarena_t *tarena;\n\n\t\t\tassert(arena_ind < narenas);\n\n\t\t\ttarena = arena_get(tsdn, arena_ind, false);\n\n\t\t\t/* No further need to hold ctl_mtx. */\n\t\t\tmalloc_mutex_unlock(tsdn, &ctl_mtx);\n\n\t\t\tif (tarena != NULL) {\n\t\t\t\tarena_decay(tsdn, tarena, false, all);\n\t\t\t}\n\t\t}\n\t}\n}\n\nstatic int\narena_i_decay_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,\n    size_t *oldlenp, void *newp, size_t newlen) {\n\tint ret;\n\tunsigned arena_ind;\n\n\tREADONLY();\n\tWRITEONLY();\n\tMIB_UNSIGNED(arena_ind, 1);\n\tarena_i_decay(tsd_tsdn(tsd), arena_ind, false);\n\n\tret = 0;\nlabel_return:\n\treturn ret;\n}\n\nstatic int\narena_i_purge_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,\n    size_t *oldlenp, void *newp, size_t newlen) {\n\tint ret;\n\tunsigned arena_ind;\n\n\tREADONLY();\n\tWRITEONLY();\n\tMIB_UNSIGNED(arena_ind, 1);\n\tarena_i_decay(tsd_tsdn(tsd), arena_ind, true);\n\n\tret = 0;\nlabel_return:\n\treturn ret;\n}\n\nstatic int\narena_i_reset_destroy_helper(tsd_t *tsd, const size_t *mib, size_t miblen,\n    void *oldp, size_t *oldlenp, void *newp, size_t newlen, unsigned *arena_ind,\n    arena_t **arena) {\n\tint ret;\n\n\tREADONLY();\n\tWRITEONLY();\n\tMIB_UNSIGNED(*arena_ind, 1);\n\n\t*arena = arena_get(tsd_tsdn(tsd), *arena_ind, false);\n\tif (*arena == NULL || arena_is_auto(*arena)) {\n\t\tret = EFAULT;\n\t\tgoto label_return;\n\t}\n\n\tret = 0;\nlabel_return:\n\treturn ret;\n}\n\nstatic void\narena_reset_prepare_background_thread(tsd_t *tsd, unsigned arena_ind) {\n\t/* Temporarily disable the background thread during arena reset. */\n\tif (have_background_thread) {\n\t\tmalloc_mutex_lock(tsd_tsdn(tsd), &background_thread_lock);\n\t\tif (background_thread_enabled()) {\n\t\t\tunsigned ind = arena_ind % ncpus;\n\t\t\tbackground_thread_info_t *info =\n\t\t\t    &background_thread_info[ind];\n\t\t\tassert(info->state == background_thread_started);\n\t\t\tmalloc_mutex_lock(tsd_tsdn(tsd), &info->mtx);\n\t\t\tinfo->state = background_thread_paused;\n\t\t\tmalloc_mutex_unlock(tsd_tsdn(tsd), &info->mtx);\n\t\t}\n\t}\n}\n\nstatic void\narena_reset_finish_background_thread(tsd_t *tsd, unsigned arena_ind) {\n\tif (have_background_thread) {\n\t\tif (background_thread_enabled()) {\n\t\t\tunsigned ind = arena_ind % ncpus;\n\t\t\tbackground_thread_info_t *info =\n\t\t\t    &background_thread_info[ind];\n\t\t\tassert(info->state == background_thread_paused);\n\t\t\tmalloc_mutex_lock(tsd_tsdn(tsd), &info->mtx);\n\t\t\tinfo->state = background_thread_started;\n\t\t\tmalloc_mutex_unlock(tsd_tsdn(tsd), &info->mtx);\n\t\t}\n\t\tmalloc_mutex_unlock(tsd_tsdn(tsd), &background_thread_lock);\n\t}\n}\n\nstatic int\narena_i_reset_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,\n    size_t *oldlenp, void *newp, size_t newlen) {\n\tint ret;\n\tunsigned arena_ind;\n\tarena_t *arena;\n\n\tret = arena_i_reset_destroy_helper(tsd, mib, miblen, oldp, oldlenp,\n\t    newp, newlen, &arena_ind, &arena);\n\tif (ret != 0) {\n\t\treturn ret;\n\t}\n\n\tarena_reset_prepare_background_thread(tsd, arena_ind);\n\tarena_reset(tsd, arena);\n\tarena_reset_finish_background_thread(tsd, arena_ind);\n\n\treturn ret;\n}\n\nstatic int\narena_i_destroy_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,\n    size_t *oldlenp, void *newp, size_t newlen) {\n\tint ret;\n\tunsigned arena_ind;\n\tarena_t *arena;\n\tctl_arena_t *ctl_darena, *ctl_arena;\n\n\tret = arena_i_reset_destroy_helper(tsd, mib, miblen, oldp, oldlenp,\n\t    newp, newlen, &arena_ind, &arena);\n\tif (ret != 0) {\n\t\tgoto label_return;\n\t}\n\n\tif (arena_nthreads_get(arena, false) != 0 || arena_nthreads_get(arena,\n\t    true) != 0) {\n\t\tret = EFAULT;\n\t\tgoto label_return;\n\t}\n\n\tarena_reset_prepare_background_thread(tsd, arena_ind);\n\t/* Merge stats after resetting and purging arena. */\n\tarena_reset(tsd, arena);\n\tarena_decay(tsd_tsdn(tsd), arena, false, true);\n\tctl_darena = arenas_i(MALLCTL_ARENAS_DESTROYED);\n\tctl_darena->initialized = true;\n\tctl_arena_refresh(tsd_tsdn(tsd), arena, ctl_darena, arena_ind, true);\n\t/* Destroy arena. */\n\tarena_destroy(tsd, arena);\n\tctl_arena = arenas_i(arena_ind);\n\tctl_arena->initialized = false;\n\t/* Record arena index for later recycling via arenas.create. */\n\tql_elm_new(ctl_arena, destroyed_link);\n\tql_tail_insert(&ctl_arenas->destroyed, ctl_arena, destroyed_link);\n\tarena_reset_finish_background_thread(tsd, arena_ind);\n\n\tassert(ret == 0);\nlabel_return:\n\treturn ret;\n}\n\nstatic int\narena_i_dss_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,\n    size_t *oldlenp, void *newp, size_t newlen) {\n\tint ret;\n\tconst char *dss = NULL;\n\tunsigned arena_ind;\n\tdss_prec_t dss_prec_old = dss_prec_limit;\n\tdss_prec_t dss_prec = dss_prec_limit;\n\n\tmalloc_mutex_lock(tsd_tsdn(tsd), &ctl_mtx);\n\tWRITE(dss, const char *);\n\tMIB_UNSIGNED(arena_ind, 1);\n\tif (dss != NULL) {\n\t\tint i;\n\t\tbool match = false;\n\n\t\tfor (i = 0; i < dss_prec_limit; i++) {\n\t\t\tif (strcmp(dss_prec_names[i], dss) == 0) {\n\t\t\t\tdss_prec = i;\n\t\t\t\tmatch = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\tif (!match) {\n\t\t\tret = EINVAL;\n\t\t\tgoto label_return;\n\t\t}\n\t}\n\n\t/*\n\t * Access via index narenas is deprecated, and scheduled for removal in\n\t * 6.0.0.\n\t */\n\tif (arena_ind == MALLCTL_ARENAS_ALL || arena_ind ==\n\t    ctl_arenas->narenas) {\n\t\tif (dss_prec != dss_prec_limit &&\n\t\t    extent_dss_prec_set(dss_prec)) {\n\t\t\tret = EFAULT;\n\t\t\tgoto label_return;\n\t\t}\n\t\tdss_prec_old = extent_dss_prec_get();\n\t} else {\n\t\tarena_t *arena = arena_get(tsd_tsdn(tsd), arena_ind, false);\n\t\tif (arena == NULL || (dss_prec != dss_prec_limit &&\n\t\t    arena_dss_prec_set(arena, dss_prec))) {\n\t\t\tret = EFAULT;\n\t\t\tgoto label_return;\n\t\t}\n\t\tdss_prec_old = arena_dss_prec_get(arena);\n\t}\n\n\tdss = dss_prec_names[dss_prec_old];\n\tREAD(dss, const char *);\n\n\tret = 0;\nlabel_return:\n\tmalloc_mutex_unlock(tsd_tsdn(tsd), &ctl_mtx);\n\treturn ret;\n}\n\nstatic int\narena_i_decay_ms_ctl_impl(tsd_t *tsd, const size_t *mib, size_t miblen,\n    void *oldp, size_t *oldlenp, void *newp, size_t newlen, bool dirty) {\n\tint ret;\n\tunsigned arena_ind;\n\tarena_t *arena;\n\n\tMIB_UNSIGNED(arena_ind, 1);\n\tarena = arena_get(tsd_tsdn(tsd), arena_ind, false);\n\tif (arena == NULL) {\n\t\tret = EFAULT;\n\t\tgoto label_return;\n\t}\n\n\tif (oldp != NULL && oldlenp != NULL) {\n\t\tsize_t oldval = dirty ? arena_dirty_decay_ms_get(arena) :\n\t\t    arena_muzzy_decay_ms_get(arena);\n\t\tREAD(oldval, ssize_t);\n\t}\n\tif (newp != NULL) {\n\t\tif (newlen != sizeof(ssize_t)) {\n\t\t\tret = EINVAL;\n\t\t\tgoto label_return;\n\t\t}\n\t\tif (dirty ? arena_dirty_decay_ms_set(tsd_tsdn(tsd), arena,\n\t\t    *(ssize_t *)newp) : arena_muzzy_decay_ms_set(tsd_tsdn(tsd),\n\t\t    arena, *(ssize_t *)newp)) {\n\t\t\tret = EFAULT;\n\t\t\tgoto label_return;\n\t\t}\n\t}\n\n\tret = 0;\nlabel_return:\n\treturn ret;\n}\n\nstatic int\narena_i_dirty_decay_ms_ctl(tsd_t *tsd, const size_t *mib, size_t miblen,\n    void *oldp, size_t *oldlenp, void *newp, size_t newlen) {\n\treturn arena_i_decay_ms_ctl_impl(tsd, mib, miblen, oldp, oldlenp, newp,\n\t    newlen, true);\n}\n\nstatic int\narena_i_muzzy_decay_ms_ctl(tsd_t *tsd, const size_t *mib, size_t miblen,\n    void *oldp, size_t *oldlenp, void *newp, size_t newlen) {\n\treturn arena_i_decay_ms_ctl_impl(tsd, mib, miblen, oldp, oldlenp, newp,\n\t    newlen, false);\n}\n\nstatic int\narena_i_extent_hooks_ctl(tsd_t *tsd, const size_t *mib, size_t miblen,\n    void *oldp, size_t *oldlenp, void *newp, size_t newlen) {\n\tint ret;\n\tunsigned arena_ind;\n\tarena_t *arena;\n\n\tmalloc_mutex_lock(tsd_tsdn(tsd), &ctl_mtx);\n\tMIB_UNSIGNED(arena_ind, 1);\n\tif (arena_ind < narenas_total_get()) {\n\t\textent_hooks_t *old_extent_hooks;\n\t\tarena = arena_get(tsd_tsdn(tsd), arena_ind, false);\n\t\tif (arena == NULL) {\n\t\t\tif (arena_ind >= narenas_auto) {\n\t\t\t\tret = EFAULT;\n\t\t\t\tgoto label_return;\n\t\t\t}\n\t\t\told_extent_hooks =\n\t\t\t    (extent_hooks_t *)&extent_hooks_default;\n\t\t\tREAD(old_extent_hooks, extent_hooks_t *);\n\t\t\tif (newp != NULL) {\n\t\t\t\t/* Initialize a new arena as a side effect. */\n\t\t\t\textent_hooks_t *new_extent_hooks\n\t\t\t\t    JEMALLOC_CC_SILENCE_INIT(NULL);\n\t\t\t\tWRITE(new_extent_hooks, extent_hooks_t *);\n\t\t\t\tarena = arena_init(tsd_tsdn(tsd), arena_ind,\n\t\t\t\t    new_extent_hooks);\n\t\t\t\tif (arena == NULL) {\n\t\t\t\t\tret = EFAULT;\n\t\t\t\t\tgoto label_return;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tif (newp != NULL) {\n\t\t\t\textent_hooks_t *new_extent_hooks\n\t\t\t\t    JEMALLOC_CC_SILENCE_INIT(NULL);\n\t\t\t\tWRITE(new_extent_hooks, extent_hooks_t *);\n\t\t\t\told_extent_hooks = extent_hooks_set(tsd, arena,\n\t\t\t\t    new_extent_hooks);\n\t\t\t\tREAD(old_extent_hooks, extent_hooks_t *);\n\t\t\t} else {\n\t\t\t\told_extent_hooks = extent_hooks_get(arena);\n\t\t\t\tREAD(old_extent_hooks, extent_hooks_t *);\n\t\t\t}\n\t\t}\n\t} else {\n\t\tret = EFAULT;\n\t\tgoto label_return;\n\t}\n\tret = 0;\nlabel_return:\n\tmalloc_mutex_unlock(tsd_tsdn(tsd), &ctl_mtx);\n\treturn ret;\n}\n\nstatic int\narena_i_retain_grow_limit_ctl(tsd_t *tsd, const size_t *mib, size_t miblen,\n    void *oldp, size_t *oldlenp, void *newp, size_t newlen) {\n\tint ret;\n\tunsigned arena_ind;\n\tarena_t *arena;\n\n\tif (!opt_retain) {\n\t\t/* Only relevant when retain is enabled. */\n\t\treturn ENOENT;\n\t}\n\n\tmalloc_mutex_lock(tsd_tsdn(tsd), &ctl_mtx);\n\tMIB_UNSIGNED(arena_ind, 1);\n\tif (arena_ind < narenas_total_get() && (arena =\n\t    arena_get(tsd_tsdn(tsd), arena_ind, false)) != NULL) {\n\t\tsize_t old_limit, new_limit;\n\t\tif (newp != NULL) {\n\t\t\tWRITE(new_limit, size_t);\n\t\t}\n\t\tbool err = arena_retain_grow_limit_get_set(tsd, arena,\n\t\t    &old_limit, newp != NULL ? &new_limit : NULL);\n\t\tif (!err) {\n\t\t\tREAD(old_limit, size_t);\n\t\t\tret = 0;\n\t\t} else {\n\t\t\tret = EFAULT;\n\t\t}\n\t} else {\n\t\tret = EFAULT;\n\t}\nlabel_return:\n\tmalloc_mutex_unlock(tsd_tsdn(tsd), &ctl_mtx);\n\treturn ret;\n}\n\nstatic const ctl_named_node_t *\narena_i_index(tsdn_t *tsdn, const size_t *mib, size_t miblen, size_t i) {\n\tconst ctl_named_node_t *ret;\n\n\tmalloc_mutex_lock(tsdn, &ctl_mtx);\n\tswitch (i) {\n\tcase MALLCTL_ARENAS_ALL:\n\tcase MALLCTL_ARENAS_DESTROYED:\n\t\tbreak;\n\tdefault:\n\t\tif (i > ctl_arenas->narenas) {\n\t\t\tret = NULL;\n\t\t\tgoto label_return;\n\t\t}\n\t\tbreak;\n\t}\n\n\tret = super_arena_i_node;\nlabel_return:\n\tmalloc_mutex_unlock(tsdn, &ctl_mtx);\n\treturn ret;\n}\n\n/******************************************************************************/\n\nstatic int\narenas_narenas_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,\n    size_t *oldlenp, void *newp, size_t newlen) {\n\tint ret;\n\tunsigned narenas;\n\n\tmalloc_mutex_lock(tsd_tsdn(tsd), &ctl_mtx);\n\tREADONLY();\n\tif (*oldlenp != sizeof(unsigned)) {\n\t\tret = EINVAL;\n\t\tgoto label_return;\n\t}\n\tnarenas = ctl_arenas->narenas;\n\tREAD(narenas, unsigned);\n\n\tret = 0;\nlabel_return:\n\tmalloc_mutex_unlock(tsd_tsdn(tsd), &ctl_mtx);\n\treturn ret;\n}\n\nstatic int\narenas_decay_ms_ctl_impl(tsd_t *tsd, const size_t *mib, size_t miblen,\n    void *oldp, size_t *oldlenp, void *newp, size_t newlen, bool dirty) {\n\tint ret;\n\n\tif (oldp != NULL && oldlenp != NULL) {\n\t\tsize_t oldval = (dirty ? arena_dirty_decay_ms_default_get() :\n\t\t    arena_muzzy_decay_ms_default_get());\n\t\tREAD(oldval, ssize_t);\n\t}\n\tif (newp != NULL) {\n\t\tif (newlen != sizeof(ssize_t)) {\n\t\t\tret = EINVAL;\n\t\t\tgoto label_return;\n\t\t}\n\t\tif (dirty ? arena_dirty_decay_ms_default_set(*(ssize_t *)newp)\n\t\t    : arena_muzzy_decay_ms_default_set(*(ssize_t *)newp)) {\n\t\t\tret = EFAULT;\n\t\t\tgoto label_return;\n\t\t}\n\t}\n\n\tret = 0;\nlabel_return:\n\treturn ret;\n}\n\nstatic int\narenas_dirty_decay_ms_ctl(tsd_t *tsd, const size_t *mib, size_t miblen,\n    void *oldp, size_t *oldlenp, void *newp, size_t newlen) {\n\treturn arenas_decay_ms_ctl_impl(tsd, mib, miblen, oldp, oldlenp, newp,\n\t    newlen, true);\n}\n\nstatic int\narenas_muzzy_decay_ms_ctl(tsd_t *tsd, const size_t *mib, size_t miblen,\n    void *oldp, size_t *oldlenp, void *newp, size_t newlen) {\n\treturn arenas_decay_ms_ctl_impl(tsd, mib, miblen, oldp, oldlenp, newp,\n\t    newlen, false);\n}\n\nCTL_RO_NL_GEN(arenas_quantum, QUANTUM, size_t)\nCTL_RO_NL_GEN(arenas_page, PAGE, size_t)\nCTL_RO_NL_GEN(arenas_tcache_max, tcache_maxclass, size_t)\nCTL_RO_NL_GEN(arenas_nbins, NBINS, unsigned)\nCTL_RO_NL_GEN(arenas_nhbins, nhbins, unsigned)\nCTL_RO_NL_GEN(arenas_bin_i_size, bin_infos[mib[2]].reg_size, size_t)\nCTL_RO_NL_GEN(arenas_bin_i_nregs, bin_infos[mib[2]].nregs, uint32_t)\nCTL_RO_NL_GEN(arenas_bin_i_slab_size, bin_infos[mib[2]].slab_size, size_t)\nstatic const ctl_named_node_t *\narenas_bin_i_index(tsdn_t *tsdn, const size_t *mib, size_t miblen, size_t i) {\n\tif (i > NBINS) {\n\t\treturn NULL;\n\t}\n\treturn super_arenas_bin_i_node;\n}\n\nCTL_RO_NL_GEN(arenas_nlextents, NSIZES - NBINS, unsigned)\nCTL_RO_NL_GEN(arenas_lextent_i_size, sz_index2size(NBINS+(szind_t)mib[2]),\n    size_t)\nstatic const ctl_named_node_t *\narenas_lextent_i_index(tsdn_t *tsdn, const size_t *mib, size_t miblen,\n    size_t i) {\n\tif (i > NSIZES - NBINS) {\n\t\treturn NULL;\n\t}\n\treturn super_arenas_lextent_i_node;\n}\n\nstatic int\narenas_create_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,\n    size_t *oldlenp, void *newp, size_t newlen) {\n\tint ret;\n\textent_hooks_t *extent_hooks;\n\tunsigned arena_ind;\n\n\tmalloc_mutex_lock(tsd_tsdn(tsd), &ctl_mtx);\n\n\textent_hooks = (extent_hooks_t *)&extent_hooks_default;\n\tWRITE(extent_hooks, extent_hooks_t *);\n\tif ((arena_ind = ctl_arena_init(tsd, extent_hooks)) == UINT_MAX) {\n\t\tret = EAGAIN;\n\t\tgoto label_return;\n\t}\n\tREAD(arena_ind, unsigned);\n\n\tret = 0;\nlabel_return:\n\tmalloc_mutex_unlock(tsd_tsdn(tsd), &ctl_mtx);\n\treturn ret;\n}\n\nstatic int\narenas_lookup_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,\n    size_t *oldlenp, void *newp, size_t newlen) {\n\tint ret;\n\tunsigned arena_ind;\n\tvoid *ptr;\n\textent_t *extent;\n\tarena_t *arena;\n\n\tptr = NULL;\n\tret = EINVAL;\n\tmalloc_mutex_lock(tsd_tsdn(tsd), &ctl_mtx);\n\tWRITE(ptr, void *);\n\textent = iealloc(tsd_tsdn(tsd), ptr);\n\tif (extent == NULL)\n\t\tgoto label_return;\n\n\tarena = extent_arena_get(extent);\n\tif (arena == NULL)\n\t\tgoto label_return;\n\n\tarena_ind = arena_ind_get(arena);\n\tREAD(arena_ind, unsigned);\n\n\tret = 0;\nlabel_return:\n\tmalloc_mutex_unlock(tsd_tsdn(tsd), &ctl_mtx);\n\treturn ret;\n}\n\n/******************************************************************************/\n\nstatic int\nprof_thread_active_init_ctl(tsd_t *tsd, const size_t *mib, size_t miblen,\n    void *oldp, size_t *oldlenp, void *newp, size_t newlen) {\n\tint ret;\n\tbool oldval;\n\n\tif (!config_prof) {\n\t\treturn ENOENT;\n\t}\n\n\tif (newp != NULL) {\n\t\tif (newlen != sizeof(bool)) {\n\t\t\tret = EINVAL;\n\t\t\tgoto label_return;\n\t\t}\n\t\toldval = prof_thread_active_init_set(tsd_tsdn(tsd),\n\t\t    *(bool *)newp);\n\t} else {\n\t\toldval = prof_thread_active_init_get(tsd_tsdn(tsd));\n\t}\n\tREAD(oldval, bool);\n\n\tret = 0;\nlabel_return:\n\treturn ret;\n}\n\nstatic int\nprof_active_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,\n    size_t *oldlenp, void *newp, size_t newlen) {\n\tint ret;\n\tbool oldval;\n\n\tif (!config_prof) {\n\t\treturn ENOENT;\n\t}\n\n\tif (newp != NULL) {\n\t\tif (newlen != sizeof(bool)) {\n\t\t\tret = EINVAL;\n\t\t\tgoto label_return;\n\t\t}\n\t\toldval = prof_active_set(tsd_tsdn(tsd), *(bool *)newp);\n\t} else {\n\t\toldval = prof_active_get(tsd_tsdn(tsd));\n\t}\n\tREAD(oldval, bool);\n\n\tret = 0;\nlabel_return:\n\treturn ret;\n}\n\nstatic int\nprof_dump_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,\n    size_t *oldlenp, void *newp, size_t newlen) {\n\tint ret;\n\tconst char *filename = NULL;\n\n\tif (!config_prof) {\n\t\treturn ENOENT;\n\t}\n\n\tWRITEONLY();\n\tWRITE(filename, const char *);\n\n\tif (prof_mdump(tsd, filename)) {\n\t\tret = EFAULT;\n\t\tgoto label_return;\n\t}\n\n\tret = 0;\nlabel_return:\n\treturn ret;\n}\n\nstatic int\nprof_gdump_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,\n    size_t *oldlenp, void *newp, size_t newlen) {\n\tint ret;\n\tbool oldval;\n\n\tif (!config_prof) {\n\t\treturn ENOENT;\n\t}\n\n\tif (newp != NULL) {\n\t\tif (newlen != sizeof(bool)) {\n\t\t\tret = EINVAL;\n\t\t\tgoto label_return;\n\t\t}\n\t\toldval = prof_gdump_set(tsd_tsdn(tsd), *(bool *)newp);\n\t} else {\n\t\toldval = prof_gdump_get(tsd_tsdn(tsd));\n\t}\n\tREAD(oldval, bool);\n\n\tret = 0;\nlabel_return:\n\treturn ret;\n}\n\nstatic int\nprof_reset_ctl(tsd_t *tsd, const size_t *mib, size_t miblen, void *oldp,\n    size_t *oldlenp, void *newp, size_t newlen) {\n\tint ret;\n\tsize_t lg_sample = lg_prof_sample;\n\n\tif (!config_prof) {\n\t\treturn ENOENT;\n\t}\n\n\tWRITEONLY();\n\tWRITE(lg_sample, size_t);\n\tif (lg_sample >= (sizeof(uint64_t) << 3)) {\n\t\tlg_sample = (sizeof(uint64_t) << 3) - 1;\n\t}\n\n\tprof_reset(tsd, lg_sample);\n\n\tret = 0;\nlabel_return:\n\treturn ret;\n}\n\nCTL_RO_NL_CGEN(config_prof, prof_interval, prof_interval, uint64_t)\nCTL_RO_NL_CGEN(config_prof, lg_prof_sample, lg_prof_sample, size_t)\n\n/******************************************************************************/\n\nCTL_RO_CGEN(config_stats, stats_allocated, ctl_stats->allocated, size_t)\nCTL_RO_CGEN(config_stats, stats_active, ctl_stats->active, size_t)\nCTL_RO_CGEN(config_stats, stats_metadata, ctl_stats->metadata, size_t)\nCTL_RO_CGEN(config_stats, stats_metadata_thp, ctl_stats->metadata_thp, size_t)\nCTL_RO_CGEN(config_stats, stats_resident, ctl_stats->resident, size_t)\nCTL_RO_CGEN(config_stats, stats_mapped, ctl_stats->mapped, size_t)\nCTL_RO_CGEN(config_stats, stats_retained, ctl_stats->retained, size_t)\n\nCTL_RO_CGEN(config_stats, stats_background_thread_num_threads,\n    ctl_stats->background_thread.num_threads, size_t)\nCTL_RO_CGEN(config_stats, stats_background_thread_num_runs,\n    ctl_stats->background_thread.num_runs, uint64_t)\nCTL_RO_CGEN(config_stats, stats_background_thread_run_interval,\n    nstime_ns(&ctl_stats->background_thread.run_interval), uint64_t)\n\nCTL_RO_GEN(stats_arenas_i_dss, arenas_i(mib[2])->dss, const char *)\nCTL_RO_GEN(stats_arenas_i_dirty_decay_ms, arenas_i(mib[2])->dirty_decay_ms,\n    ssize_t)\nCTL_RO_GEN(stats_arenas_i_muzzy_decay_ms, arenas_i(mib[2])->muzzy_decay_ms,\n    ssize_t)\nCTL_RO_GEN(stats_arenas_i_nthreads, arenas_i(mib[2])->nthreads, unsigned)\nCTL_RO_GEN(stats_arenas_i_uptime,\n    nstime_ns(&arenas_i(mib[2])->astats->astats.uptime), uint64_t)\nCTL_RO_GEN(stats_arenas_i_pactive, arenas_i(mib[2])->pactive, size_t)\nCTL_RO_GEN(stats_arenas_i_pdirty, arenas_i(mib[2])->pdirty, size_t)\nCTL_RO_GEN(stats_arenas_i_pmuzzy, arenas_i(mib[2])->pmuzzy, size_t)\nCTL_RO_CGEN(config_stats, stats_arenas_i_mapped,\n    atomic_load_zu(&arenas_i(mib[2])->astats->astats.mapped, ATOMIC_RELAXED),\n    size_t)\nCTL_RO_CGEN(config_stats, stats_arenas_i_retained,\n    atomic_load_zu(&arenas_i(mib[2])->astats->astats.retained, ATOMIC_RELAXED),\n    size_t)\n\nCTL_RO_CGEN(config_stats, stats_arenas_i_dirty_npurge,\n    ctl_arena_stats_read_u64(\n    &arenas_i(mib[2])->astats->astats.decay_dirty.npurge), uint64_t)\nCTL_RO_CGEN(config_stats, stats_arenas_i_dirty_nmadvise,\n    ctl_arena_stats_read_u64(\n    &arenas_i(mib[2])->astats->astats.decay_dirty.nmadvise), uint64_t)\nCTL_RO_CGEN(config_stats, stats_arenas_i_dirty_purged,\n    ctl_arena_stats_read_u64(\n    &arenas_i(mib[2])->astats->astats.decay_dirty.purged), uint64_t)\n\nCTL_RO_CGEN(config_stats, stats_arenas_i_muzzy_npurge,\n    ctl_arena_stats_read_u64(\n    &arenas_i(mib[2])->astats->astats.decay_muzzy.npurge), uint64_t)\nCTL_RO_CGEN(config_stats, stats_arenas_i_muzzy_nmadvise,\n    ctl_arena_stats_read_u64(\n    &arenas_i(mib[2])->astats->astats.decay_muzzy.nmadvise), uint64_t)\nCTL_RO_CGEN(config_stats, stats_arenas_i_muzzy_purged,\n    ctl_arena_stats_read_u64(\n    &arenas_i(mib[2])->astats->astats.decay_muzzy.purged), uint64_t)\n\nCTL_RO_CGEN(config_stats, stats_arenas_i_base,\n    atomic_load_zu(&arenas_i(mib[2])->astats->astats.base, ATOMIC_RELAXED),\n    size_t)\nCTL_RO_CGEN(config_stats, stats_arenas_i_internal,\n    atomic_load_zu(&arenas_i(mib[2])->astats->astats.internal, ATOMIC_RELAXED),\n    size_t)\nCTL_RO_CGEN(config_stats, stats_arenas_i_metadata_thp,\n    atomic_load_zu(&arenas_i(mib[2])->astats->astats.metadata_thp,\n    ATOMIC_RELAXED), size_t)\nCTL_RO_CGEN(config_stats, stats_arenas_i_tcache_bytes,\n    atomic_load_zu(&arenas_i(mib[2])->astats->astats.tcache_bytes,\n    ATOMIC_RELAXED), size_t)\nCTL_RO_CGEN(config_stats, stats_arenas_i_resident,\n    atomic_load_zu(&arenas_i(mib[2])->astats->astats.resident, ATOMIC_RELAXED),\n    size_t)\n\nCTL_RO_CGEN(config_stats, stats_arenas_i_small_allocated,\n    arenas_i(mib[2])->astats->allocated_small, size_t)\nCTL_RO_CGEN(config_stats, stats_arenas_i_small_nmalloc,\n    arenas_i(mib[2])->astats->nmalloc_small, uint64_t)\nCTL_RO_CGEN(config_stats, stats_arenas_i_small_ndalloc,\n    arenas_i(mib[2])->astats->ndalloc_small, uint64_t)\nCTL_RO_CGEN(config_stats, stats_arenas_i_small_nrequests,\n    arenas_i(mib[2])->astats->nrequests_small, uint64_t)\nCTL_RO_CGEN(config_stats, stats_arenas_i_large_allocated,\n    atomic_load_zu(&arenas_i(mib[2])->astats->astats.allocated_large,\n    ATOMIC_RELAXED), size_t)\nCTL_RO_CGEN(config_stats, stats_arenas_i_large_nmalloc,\n    ctl_arena_stats_read_u64(\n    &arenas_i(mib[2])->astats->astats.nmalloc_large), uint64_t)\nCTL_RO_CGEN(config_stats, stats_arenas_i_large_ndalloc,\n    ctl_arena_stats_read_u64(\n    &arenas_i(mib[2])->astats->astats.ndalloc_large), uint64_t)\n/*\n * Note: \"nmalloc\" here instead of \"nrequests\" in the read.  This is intentional.\n */\nCTL_RO_CGEN(config_stats, stats_arenas_i_large_nrequests,\n    ctl_arena_stats_read_u64(\n    &arenas_i(mib[2])->astats->astats.nmalloc_large), uint64_t) /* Intentional. */\n\n/* Lock profiling related APIs below. */\n#define RO_MUTEX_CTL_GEN(n, l)\t\t\t\t\t\t\\\nCTL_RO_CGEN(config_stats, stats_##n##_num_ops,\t\t\t\t\\\n    l.n_lock_ops, uint64_t)\t\t\t\t\t\t\\\nCTL_RO_CGEN(config_stats, stats_##n##_num_wait,\t\t\t\t\\\n    l.n_wait_times, uint64_t)\t\t\t\t\t\t\\\nCTL_RO_CGEN(config_stats, stats_##n##_num_spin_acq,\t\t\t\\\n    l.n_spin_acquired, uint64_t)\t\t\t\t\t\\\nCTL_RO_CGEN(config_stats, stats_##n##_num_owner_switch,\t\t\t\\\n    l.n_owner_switches, uint64_t) \t\t\t\t\t\\\nCTL_RO_CGEN(config_stats, stats_##n##_total_wait_time,\t\t\t\\\n    nstime_ns(&l.tot_wait_time), uint64_t)\t\t\t\t\\\nCTL_RO_CGEN(config_stats, stats_##n##_max_wait_time,\t\t\t\\\n    nstime_ns(&l.max_wait_time), uint64_t)\t\t\t\t\\\nCTL_RO_CGEN(config_stats, stats_##n##_max_num_thds,\t\t\t\\\n    l.max_n_thds, uint32_t)\n\n/* Global mutexes. */\n#define OP(mtx)\t\t\t\t\t\t\t\t\\\n    RO_MUTEX_CTL_GEN(mutexes_##mtx,\t\t\t\t\t\\\n        ctl_stats->mutex_prof_data[global_prof_mutex_##mtx])\nMUTEX_PROF_GLOBAL_MUTEXES\n#undef OP\n\n/* Per arena mutexes */\n#define OP(mtx) RO_MUTEX_CTL_GEN(arenas_i_mutexes_##mtx,\t\t\\\n    arenas_i(mib[2])->astats->astats.mutex_prof_data[arena_prof_mutex_##mtx])\nMUTEX_PROF_ARENA_MUTEXES\n#undef OP\n\n/* tcache bin mutex */\nRO_MUTEX_CTL_GEN(arenas_i_bins_j_mutex,\n    arenas_i(mib[2])->astats->bstats[mib[4]].mutex_data)\n#undef RO_MUTEX_CTL_GEN\n\n/* Resets all mutex stats, including global, arena and bin mutexes. */\nstatic int\nstats_mutexes_reset_ctl(tsd_t *tsd, const size_t *mib, size_t miblen,\n    void *oldp, size_t *oldlenp, void *newp, size_t newlen) {\n\tif (!config_stats) {\n\t\treturn ENOENT;\n\t}\n\n\ttsdn_t *tsdn = tsd_tsdn(tsd);\n\n#define MUTEX_PROF_RESET(mtx)\t\t\t\t\t\t\\\n    malloc_mutex_lock(tsdn, &mtx);\t\t\t\t\t\\\n    malloc_mutex_prof_data_reset(tsdn, &mtx);\t\t\t\t\\\n    malloc_mutex_unlock(tsdn, &mtx);\n\n\t/* Global mutexes: ctl and prof. */\n\tMUTEX_PROF_RESET(ctl_mtx);\n\tif (have_background_thread) {\n\t\tMUTEX_PROF_RESET(background_thread_lock);\n\t}\n\tif (config_prof && opt_prof) {\n\t\tMUTEX_PROF_RESET(bt2gctx_mtx);\n\t}\n\n\n\t/* Per arena mutexes. */\n\tunsigned n = narenas_total_get();\n\n\tfor (unsigned i = 0; i < n; i++) {\n\t\tarena_t *arena = arena_get(tsdn, i, false);\n\t\tif (!arena) {\n\t\t\tcontinue;\n\t\t}\n\t\tMUTEX_PROF_RESET(arena->large_mtx);\n\t\tMUTEX_PROF_RESET(arena->extent_avail_mtx);\n\t\tMUTEX_PROF_RESET(arena->extents_dirty.mtx);\n\t\tMUTEX_PROF_RESET(arena->extents_muzzy.mtx);\n\t\tMUTEX_PROF_RESET(arena->extents_retained.mtx);\n\t\tMUTEX_PROF_RESET(arena->decay_dirty.mtx);\n\t\tMUTEX_PROF_RESET(arena->decay_muzzy.mtx);\n\t\tMUTEX_PROF_RESET(arena->tcache_ql_mtx);\n\t\tMUTEX_PROF_RESET(arena->base->mtx);\n\n\t\tfor (szind_t i = 0; i < NBINS; i++) {\n\t\t\tbin_t *bin = &arena->bins[i];\n\t\t\tMUTEX_PROF_RESET(bin->lock);\n\t\t}\n\t}\n#undef MUTEX_PROF_RESET\n\treturn 0;\n}\n\nCTL_RO_CGEN(config_stats, stats_arenas_i_bins_j_nmalloc,\n    arenas_i(mib[2])->astats->bstats[mib[4]].nmalloc, uint64_t)\nCTL_RO_CGEN(config_stats, stats_arenas_i_bins_j_ndalloc,\n    arenas_i(mib[2])->astats->bstats[mib[4]].ndalloc, uint64_t)\nCTL_RO_CGEN(config_stats, stats_arenas_i_bins_j_nrequests,\n    arenas_i(mib[2])->astats->bstats[mib[4]].nrequests, uint64_t)\nCTL_RO_CGEN(config_stats, stats_arenas_i_bins_j_curregs,\n    arenas_i(mib[2])->astats->bstats[mib[4]].curregs, size_t)\nCTL_RO_CGEN(config_stats, stats_arenas_i_bins_j_nfills,\n    arenas_i(mib[2])->astats->bstats[mib[4]].nfills, uint64_t)\nCTL_RO_CGEN(config_stats, stats_arenas_i_bins_j_nflushes,\n    arenas_i(mib[2])->astats->bstats[mib[4]].nflushes, uint64_t)\nCTL_RO_CGEN(config_stats, stats_arenas_i_bins_j_nslabs,\n    arenas_i(mib[2])->astats->bstats[mib[4]].nslabs, uint64_t)\nCTL_RO_CGEN(config_stats, stats_arenas_i_bins_j_nreslabs,\n    arenas_i(mib[2])->astats->bstats[mib[4]].reslabs, uint64_t)\nCTL_RO_CGEN(config_stats, stats_arenas_i_bins_j_curslabs,\n    arenas_i(mib[2])->astats->bstats[mib[4]].curslabs, size_t)\n\nstatic const ctl_named_node_t *\nstats_arenas_i_bins_j_index(tsdn_t *tsdn, const size_t *mib, size_t miblen,\n    size_t j) {\n\tif (j > NBINS) {\n\t\treturn NULL;\n\t}\n\treturn super_stats_arenas_i_bins_j_node;\n}\n\nCTL_RO_CGEN(config_stats, stats_arenas_i_lextents_j_nmalloc,\n    ctl_arena_stats_read_u64(\n    &arenas_i(mib[2])->astats->lstats[mib[4]].nmalloc), uint64_t)\nCTL_RO_CGEN(config_stats, stats_arenas_i_lextents_j_ndalloc,\n    ctl_arena_stats_read_u64(\n    &arenas_i(mib[2])->astats->lstats[mib[4]].ndalloc), uint64_t)\nCTL_RO_CGEN(config_stats, stats_arenas_i_lextents_j_nrequests,\n    ctl_arena_stats_read_u64(\n    &arenas_i(mib[2])->astats->lstats[mib[4]].nrequests), uint64_t)\nCTL_RO_CGEN(config_stats, stats_arenas_i_lextents_j_curlextents,\n    arenas_i(mib[2])->astats->lstats[mib[4]].curlextents, size_t)\n\nstatic const ctl_named_node_t *\nstats_arenas_i_lextents_j_index(tsdn_t *tsdn, const size_t *mib, size_t miblen,\n    size_t j) {\n\tif (j > NSIZES - NBINS) {\n\t\treturn NULL;\n\t}\n\treturn super_stats_arenas_i_lextents_j_node;\n}\n\nstatic const ctl_named_node_t *\nstats_arenas_i_index(tsdn_t *tsdn, const size_t *mib, size_t miblen, size_t i) {\n\tconst ctl_named_node_t *ret;\n\tsize_t a;\n\n\tmalloc_mutex_lock(tsdn, &ctl_mtx);\n\ta = arenas_i2a_impl(i, true, true);\n\tif (a == UINT_MAX || !ctl_arenas->arenas[a]->initialized) {\n\t\tret = NULL;\n\t\tgoto label_return;\n\t}\n\n\tret = super_stats_arenas_i_node;\nlabel_return:\n\tmalloc_mutex_unlock(tsdn, &ctl_mtx);\n\treturn ret;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-redis-5.0.1-gykpygjr4nuvp2gxloszw6ksswcpsjes/spack-src/deps/jemalloc/include/jemalloc/internal/jemalloc_internal_defs.h.in": "#ifndef JEMALLOC_INTERNAL_DEFS_H_\n#define JEMALLOC_INTERNAL_DEFS_H_\n/*\n * If JEMALLOC_PREFIX is defined via --with-jemalloc-prefix, it will cause all\n * public APIs to be prefixed.  This makes it possible, with some care, to use\n * multiple allocators simultaneously.\n */\n#undef JEMALLOC_PREFIX\n#undef JEMALLOC_CPREFIX\n\n/*\n * Define overrides for non-standard allocator-related functions if they are\n * present on the system.\n */\n#undef JEMALLOC_OVERRIDE___LIBC_CALLOC\n#undef JEMALLOC_OVERRIDE___LIBC_FREE\n#undef JEMALLOC_OVERRIDE___LIBC_MALLOC\n#undef JEMALLOC_OVERRIDE___LIBC_MEMALIGN\n#undef JEMALLOC_OVERRIDE___LIBC_REALLOC\n#undef JEMALLOC_OVERRIDE___LIBC_VALLOC\n#undef JEMALLOC_OVERRIDE___POSIX_MEMALIGN\n\n/*\n * JEMALLOC_PRIVATE_NAMESPACE is used as a prefix for all library-private APIs.\n * For shared libraries, symbol visibility mechanisms prevent these symbols\n * from being exported, but for static libraries, naming collisions are a real\n * possibility.\n */\n#undef JEMALLOC_PRIVATE_NAMESPACE\n\n/*\n * Hyper-threaded CPUs may need a special instruction inside spin loops in\n * order to yield to another virtual CPU.\n */\n#undef CPU_SPINWAIT\n/* 1 if CPU_SPINWAIT is defined, 0 otherwise. */\n#undef HAVE_CPU_SPINWAIT\n\n/*\n * Number of significant bits in virtual addresses.  This may be less than the\n * total number of bits in a pointer, e.g. on x64, for which the uppermost 16\n * bits are the same as bit 47.\n */\n#undef LG_VADDR\n\n/* Defined if C11 atomics are available. */\n#undef JEMALLOC_C11_ATOMICS\n\n/* Defined if GCC __atomic atomics are available. */\n#undef JEMALLOC_GCC_ATOMIC_ATOMICS\n\n/* Defined if GCC __sync atomics are available. */\n#undef JEMALLOC_GCC_SYNC_ATOMICS\n\n/*\n * Defined if __sync_add_and_fetch(uint32_t *, uint32_t) and\n * __sync_sub_and_fetch(uint32_t *, uint32_t) are available, despite\n * __GCC_HAVE_SYNC_COMPARE_AND_SWAP_4 not being defined (which means the\n * functions are defined in libgcc instead of being inlines).\n */\n#undef JE_FORCE_SYNC_COMPARE_AND_SWAP_4\n\n/*\n * Defined if __sync_add_and_fetch(uint64_t *, uint64_t) and\n * __sync_sub_and_fetch(uint64_t *, uint64_t) are available, despite\n * __GCC_HAVE_SYNC_COMPARE_AND_SWAP_8 not being defined (which means the\n * functions are defined in libgcc instead of being inlines).\n */\n#undef JE_FORCE_SYNC_COMPARE_AND_SWAP_8\n\n/*\n * Defined if __builtin_clz() and __builtin_clzl() are available.\n */\n#undef JEMALLOC_HAVE_BUILTIN_CLZ\n\n/*\n * Defined if os_unfair_lock_*() functions are available, as provided by Darwin.\n */\n#undef JEMALLOC_OS_UNFAIR_LOCK\n\n/*\n * Defined if OSSpin*() functions are available, as provided by Darwin, and\n * documented in the spinlock(3) manual page.\n */\n#undef JEMALLOC_OSSPIN\n\n/* Defined if syscall(2) is usable. */\n#undef JEMALLOC_USE_SYSCALL\n\n/*\n * Defined if secure_getenv(3) is available.\n */\n#undef JEMALLOC_HAVE_SECURE_GETENV\n\n/*\n * Defined if issetugid(2) is available.\n */\n#undef JEMALLOC_HAVE_ISSETUGID\n\n/* Defined if pthread_atfork(3) is available. */\n#undef JEMALLOC_HAVE_PTHREAD_ATFORK\n\n/* Defined if pthread_setname_np(3) is available. */\n#undef JEMALLOC_HAVE_PTHREAD_SETNAME_NP\n\n/*\n * Defined if clock_gettime(CLOCK_MONOTONIC_COARSE, ...) is available.\n */\n#undef JEMALLOC_HAVE_CLOCK_MONOTONIC_COARSE\n\n/*\n * Defined if clock_gettime(CLOCK_MONOTONIC, ...) is available.\n */\n#undef JEMALLOC_HAVE_CLOCK_MONOTONIC\n\n/*\n * Defined if mach_absolute_time() is available.\n */\n#undef JEMALLOC_HAVE_MACH_ABSOLUTE_TIME\n\n/*\n * Defined if _malloc_thread_cleanup() exists.  At least in the case of\n * FreeBSD, pthread_key_create() allocates, which if used during malloc\n * bootstrapping will cause recursion into the pthreads library.  Therefore, if\n * _malloc_thread_cleanup() exists, use it as the basis for thread cleanup in\n * malloc_tsd.\n */\n#undef JEMALLOC_MALLOC_THREAD_CLEANUP\n\n/*\n * Defined if threaded initialization is known to be safe on this platform.\n * Among other things, it must be possible to initialize a mutex without\n * triggering allocation in order for threaded allocation to be safe.\n */\n#undef JEMALLOC_THREADED_INIT\n\n/*\n * Defined if the pthreads implementation defines\n * _pthread_mutex_init_calloc_cb(), in which case the function is used in order\n * to avoid recursive allocation during mutex initialization.\n */\n#undef JEMALLOC_MUTEX_INIT_CB\n\n/* Non-empty if the tls_model attribute is supported. */\n#undef JEMALLOC_TLS_MODEL\n\n/*\n * JEMALLOC_DEBUG enables assertions and other sanity checks, and disables\n * inline functions.\n */\n#undef JEMALLOC_DEBUG\n\n/* JEMALLOC_STATS enables statistics calculation. */\n#undef JEMALLOC_STATS\n\n/* JEMALLOC_PROF enables allocation profiling. */\n#undef JEMALLOC_PROF\n\n/* Use libunwind for profile backtracing if defined. */\n#undef JEMALLOC_PROF_LIBUNWIND\n\n/* Use libgcc for profile backtracing if defined. */\n#undef JEMALLOC_PROF_LIBGCC\n\n/* Use gcc intrinsics for profile backtracing if defined. */\n#undef JEMALLOC_PROF_GCC\n\n/*\n * JEMALLOC_DSS enables use of sbrk(2) to allocate extents from the data storage\n * segment (DSS).\n */\n#undef JEMALLOC_DSS\n\n/* Support memory filling (junk/zero). */\n#undef JEMALLOC_FILL\n\n/* Support utrace(2)-based tracing. */\n#undef JEMALLOC_UTRACE\n\n/* Support optional abort() on OOM. */\n#undef JEMALLOC_XMALLOC\n\n/* Support lazy locking (avoid locking unless a second thread is launched). */\n#undef JEMALLOC_LAZY_LOCK\n\n/*\n * Minimum allocation alignment is 2^LG_QUANTUM bytes (ignoring tiny size\n * classes).\n */\n#undef LG_QUANTUM\n\n/* One page is 2^LG_PAGE bytes. */\n#undef LG_PAGE\n\n/*\n * One huge page is 2^LG_HUGEPAGE bytes.  Note that this is defined even if the\n * system does not explicitly support huge pages; system calls that require\n * explicit huge page support are separately configured.\n */\n#undef LG_HUGEPAGE\n\n/*\n * If defined, adjacent virtual memory mappings with identical attributes\n * automatically coalesce, and they fragment when changes are made to subranges.\n * This is the normal order of things for mmap()/munmap(), but on Windows\n * VirtualAlloc()/VirtualFree() operations must be precisely matched, i.e.\n * mappings do *not* coalesce/fragment.\n */\n#undef JEMALLOC_MAPS_COALESCE\n\n/*\n * If defined, retain memory for later reuse by default rather than using e.g.\n * munmap() to unmap freed extents.  This is enabled on 64-bit Linux because\n * common sequences of mmap()/munmap() calls will cause virtual memory map\n * holes.\n */\n#undef JEMALLOC_RETAIN\n\n/* TLS is used to map arenas and magazine caches to threads. */\n#undef JEMALLOC_TLS\n\n/*\n * Used to mark unreachable code to quiet \"end of non-void\" compiler warnings.\n * Don't use this directly; instead use unreachable() from util.h\n */\n#undef JEMALLOC_INTERNAL_UNREACHABLE\n\n/*\n * ffs*() functions to use for bitmapping.  Don't use these directly; instead,\n * use ffs_*() from util.h.\n */\n#undef JEMALLOC_INTERNAL_FFSLL\n#undef JEMALLOC_INTERNAL_FFSL\n#undef JEMALLOC_INTERNAL_FFS\n\n/*\n * If defined, explicitly attempt to more uniformly distribute large allocation\n * pointer alignments across all cache indices.\n */\n#undef JEMALLOC_CACHE_OBLIVIOUS\n\n/*\n * If defined, enable logging facilities.  We make this a configure option to\n * avoid taking extra branches everywhere.\n */\n#undef JEMALLOC_LOG\n\n/*\n * Darwin (OS X) uses zones to work around Mach-O symbol override shortcomings.\n */\n#undef JEMALLOC_ZONE\n\n/*\n * Methods for determining whether the OS overcommits.\n * JEMALLOC_PROC_SYS_VM_OVERCOMMIT_MEMORY: Linux's\n *                                         /proc/sys/vm.overcommit_memory file.\n * JEMALLOC_SYSCTL_VM_OVERCOMMIT: FreeBSD's vm.overcommit sysctl.\n */\n#undef JEMALLOC_SYSCTL_VM_OVERCOMMIT\n#undef JEMALLOC_PROC_SYS_VM_OVERCOMMIT_MEMORY\n\n/* Defined if madvise(2) is available. */\n#undef JEMALLOC_HAVE_MADVISE\n\n/*\n * Defined if transparent huge pages are supported via the MADV_[NO]HUGEPAGE\n * arguments to madvise(2).\n */\n#undef JEMALLOC_HAVE_MADVISE_HUGE\n\n/*\n * Methods for purging unused pages differ between operating systems.\n *\n *   madvise(..., MADV_FREE) : This marks pages as being unused, such that they\n *                             will be discarded rather than swapped out.\n *   madvise(..., MADV_DONTNEED) : If JEMALLOC_PURGE_MADVISE_DONTNEED_ZEROS is\n *                                 defined, this immediately discards pages,\n *                                 such that new pages will be demand-zeroed if\n *                                 the address region is later touched;\n *                                 otherwise this behaves similarly to\n *                                 MADV_FREE, though typically with higher\n *                                 system overhead.\n */\n#undef JEMALLOC_PURGE_MADVISE_FREE\n#undef JEMALLOC_PURGE_MADVISE_DONTNEED\n#undef JEMALLOC_PURGE_MADVISE_DONTNEED_ZEROS\n\n/* Defined if madvise(2) is available but MADV_FREE is not (x86 Linux only). */\n#undef JEMALLOC_DEFINE_MADVISE_FREE\n\n/*\n * Defined if MADV_DO[NT]DUMP is supported as an argument to madvise.\n */\n#undef JEMALLOC_MADVISE_DONTDUMP\n\n/*\n * Defined if transparent huge pages (THPs) are supported via the\n * MADV_[NO]HUGEPAGE arguments to madvise(2), and THP support is enabled.\n */\n#undef JEMALLOC_THP\n\n/* Define if operating system has alloca.h header. */\n#undef JEMALLOC_HAS_ALLOCA_H\n\n/* C99 restrict keyword supported. */\n#undef JEMALLOC_HAS_RESTRICT\n\n/* For use by hash code. */\n#undef JEMALLOC_BIG_ENDIAN\n\n/* sizeof(int) == 2^LG_SIZEOF_INT. */\n#undef LG_SIZEOF_INT\n\n/* sizeof(long) == 2^LG_SIZEOF_LONG. */\n#undef LG_SIZEOF_LONG\n\n/* sizeof(long long) == 2^LG_SIZEOF_LONG_LONG. */\n#undef LG_SIZEOF_LONG_LONG\n\n/* sizeof(intmax_t) == 2^LG_SIZEOF_INTMAX_T. */\n#undef LG_SIZEOF_INTMAX_T\n\n/* glibc malloc hooks (__malloc_hook, __realloc_hook, __free_hook). */\n#undef JEMALLOC_GLIBC_MALLOC_HOOK\n\n/* glibc memalign hook. */\n#undef JEMALLOC_GLIBC_MEMALIGN_HOOK\n\n/* pthread support */\n#undef JEMALLOC_HAVE_PTHREAD\n\n/* dlsym() support */\n#undef JEMALLOC_HAVE_DLSYM\n\n/* Adaptive mutex support in pthreads. */\n#undef JEMALLOC_HAVE_PTHREAD_MUTEX_ADAPTIVE_NP\n\n/* GNU specific sched_getcpu support */\n#undef JEMALLOC_HAVE_SCHED_GETCPU\n\n/* GNU specific sched_setaffinity support */\n#undef JEMALLOC_HAVE_SCHED_SETAFFINITY\n\n/*\n * If defined, all the features necessary for background threads are present.\n */\n#undef JEMALLOC_BACKGROUND_THREAD\n\n/*\n * If defined, jemalloc symbols are not exported (doesn't work when\n * JEMALLOC_PREFIX is not defined).\n */\n#undef JEMALLOC_EXPORT\n\n/* config.malloc_conf options string. */\n#undef JEMALLOC_CONFIG_MALLOC_CONF\n\n/* If defined, jemalloc takes the malloc/free/etc. symbol names. */\n#undef JEMALLOC_IS_MALLOC\n\n/*\n * Defined if strerror_r returns char * if _GNU_SOURCE is defined.\n */\n#undef JEMALLOC_STRERROR_R_RETURNS_CHAR_WITH_GNU_SOURCE\n\n#endif /* JEMALLOC_INTERNAL_DEFS_H_ */\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-redis-5.0.1-gykpygjr4nuvp2gxloszw6ksswcpsjes/spack-src/tests/assets/hash-zipmap.rdb",
        "/tmp/vanessa/spack-stage/spack-stage-redis-5.0.1-gykpygjr4nuvp2gxloszw6ksswcpsjes/spack-src/tests/assets/encodings.rdb",
        "/tmp/vanessa/spack-stage/spack-stage-redis-5.0.1-gykpygjr4nuvp2gxloszw6ksswcpsjes/spack-src/deps/lua/test/life.lua",
        "/tmp/vanessa/spack-stage/spack-stage-redis-5.0.1-gykpygjr4nuvp2gxloszw6ksswcpsjes/spack-src/deps/lua/etc/lua.ico",
        "/tmp/vanessa/spack-stage/spack-stage-redis-5.0.1-gykpygjr4nuvp2gxloszw6ksswcpsjes/spack-src/deps/lua/doc/logo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-redis-5.0.1-gykpygjr4nuvp2gxloszw6ksswcpsjes/spack-src/deps/lua/doc/cover.png"
    ],
    "total_files": 701
}