{
    "matches": {
        "/var/tmp/sochat1/spack-stage/spack-stage-nginx-1.13.8-3egkdu37ryxbl4zmrugjg3m3bciljfvf/spack-src/src/os/unix/ngx_dlopen.h": "\n/*\n * Copyright (C) Maxim Dounin\n * Copyright (C) Nginx, Inc.\n */\n\n\n#ifndef _NGX_DLOPEN_H_INCLUDED_\n#define _NGX_DLOPEN_H_INCLUDED_\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n\n\n#define ngx_dlopen(path)           dlopen((char *) path, RTLD_NOW | RTLD_GLOBAL)\n#define ngx_dlopen_n               \"dlopen()\"\n\n#define ngx_dlsym(handle, symbol)  dlsym(handle, symbol)\n#define ngx_dlsym_n                \"dlsym()\"\n\n#define ngx_dlclose(handle)        dlclose(handle)\n#define ngx_dlclose_n              \"dlclose()\"\n\n\n#if (NGX_HAVE_DLOPEN)\nchar *ngx_dlerror(void);\n#endif\n\n\n#endif /* _NGX_DLOPEN_H_INCLUDED_ */\n",
        "/var/tmp/sochat1/spack-stage/spack-stage-nginx-1.13.8-3egkdu37ryxbl4zmrugjg3m3bciljfvf/spack-src/src/core/nginx.c": "\n/*\n * Copyright (C) Igor Sysoev\n * Copyright (C) Nginx, Inc.\n */\n\n\n#include <ngx_config.h>\n#include <ngx_core.h>\n#include <nginx.h>\n\n\nstatic void ngx_show_version_info(void);\nstatic ngx_int_t ngx_add_inherited_sockets(ngx_cycle_t *cycle);\nstatic void ngx_cleanup_environment(void *data);\nstatic ngx_int_t ngx_get_options(int argc, char *const *argv);\nstatic ngx_int_t ngx_process_options(ngx_cycle_t *cycle);\nstatic ngx_int_t ngx_save_argv(ngx_cycle_t *cycle, int argc, char *const *argv);\nstatic void *ngx_core_module_create_conf(ngx_cycle_t *cycle);\nstatic char *ngx_core_module_init_conf(ngx_cycle_t *cycle, void *conf);\nstatic char *ngx_set_user(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);\nstatic char *ngx_set_env(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);\nstatic char *ngx_set_priority(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);\nstatic char *ngx_set_cpu_affinity(ngx_conf_t *cf, ngx_command_t *cmd,\n    void *conf);\nstatic char *ngx_set_worker_processes(ngx_conf_t *cf, ngx_command_t *cmd,\n    void *conf);\nstatic char *ngx_load_module(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);\n#if (NGX_HAVE_DLOPEN)\nstatic void ngx_unload_module(void *data);\n#endif\n\n\nstatic ngx_conf_enum_t  ngx_debug_points[] = {\n    { ngx_string(\"stop\"), NGX_DEBUG_POINTS_STOP },\n    { ngx_string(\"abort\"), NGX_DEBUG_POINTS_ABORT },\n    { ngx_null_string, 0 }\n};\n\n\nstatic ngx_command_t  ngx_core_commands[] = {\n\n    { ngx_string(\"daemon\"),\n      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_FLAG,\n      ngx_conf_set_flag_slot,\n      0,\n      offsetof(ngx_core_conf_t, daemon),\n      NULL },\n\n    { ngx_string(\"master_process\"),\n      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_FLAG,\n      ngx_conf_set_flag_slot,\n      0,\n      offsetof(ngx_core_conf_t, master),\n      NULL },\n\n    { ngx_string(\"timer_resolution\"),\n      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_msec_slot,\n      0,\n      offsetof(ngx_core_conf_t, timer_resolution),\n      NULL },\n\n    { ngx_string(\"pid\"),\n      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_str_slot,\n      0,\n      offsetof(ngx_core_conf_t, pid),\n      NULL },\n\n    { ngx_string(\"lock_file\"),\n      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_str_slot,\n      0,\n      offsetof(ngx_core_conf_t, lock_file),\n      NULL },\n\n    { ngx_string(\"worker_processes\"),\n      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,\n      ngx_set_worker_processes,\n      0,\n      0,\n      NULL },\n\n    { ngx_string(\"debug_points\"),\n      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_enum_slot,\n      0,\n      offsetof(ngx_core_conf_t, debug_points),\n      &ngx_debug_points },\n\n    { ngx_string(\"user\"),\n      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE12,\n      ngx_set_user,\n      0,\n      0,\n      NULL },\n\n    { ngx_string(\"worker_priority\"),\n      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,\n      ngx_set_priority,\n      0,\n      0,\n      NULL },\n\n    { ngx_string(\"worker_cpu_affinity\"),\n      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_1MORE,\n      ngx_set_cpu_affinity,\n      0,\n      0,\n      NULL },\n\n    { ngx_string(\"worker_rlimit_nofile\"),\n      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_num_slot,\n      0,\n      offsetof(ngx_core_conf_t, rlimit_nofile),\n      NULL },\n\n    { ngx_string(\"worker_rlimit_core\"),\n      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_off_slot,\n      0,\n      offsetof(ngx_core_conf_t, rlimit_core),\n      NULL },\n\n    { ngx_string(\"worker_shutdown_timeout\"),\n      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_msec_slot,\n      0,\n      offsetof(ngx_core_conf_t, shutdown_timeout),\n      NULL },\n\n    { ngx_string(\"working_directory\"),\n      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,\n      ngx_conf_set_str_slot,\n      0,\n      offsetof(ngx_core_conf_t, working_directory),\n      NULL },\n\n    { ngx_string(\"env\"),\n      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,\n      ngx_set_env,\n      0,\n      0,\n      NULL },\n\n    { ngx_string(\"load_module\"),\n      NGX_MAIN_CONF|NGX_DIRECT_CONF|NGX_CONF_TAKE1,\n      ngx_load_module,\n      0,\n      0,\n      NULL },\n\n      ngx_null_command\n};\n\n\nstatic ngx_core_module_t  ngx_core_module_ctx = {\n    ngx_string(\"core\"),\n    ngx_core_module_create_conf,\n    ngx_core_module_init_conf\n};\n\n\nngx_module_t  ngx_core_module = {\n    NGX_MODULE_V1,\n    &ngx_core_module_ctx,                  /* module context */\n    ngx_core_commands,                     /* module directives */\n    NGX_CORE_MODULE,                       /* module type */\n    NULL,                                  /* init master */\n    NULL,                                  /* init module */\n    NULL,                                  /* init process */\n    NULL,                                  /* init thread */\n    NULL,                                  /* exit thread */\n    NULL,                                  /* exit process */\n    NULL,                                  /* exit master */\n    NGX_MODULE_V1_PADDING\n};\n\n\nstatic ngx_uint_t   ngx_show_help;\nstatic ngx_uint_t   ngx_show_version;\nstatic ngx_uint_t   ngx_show_configure;\nstatic u_char      *ngx_prefix;\nstatic u_char      *ngx_conf_file;\nstatic u_char      *ngx_conf_params;\nstatic char        *ngx_signal;\n\n\nstatic char **ngx_os_environ;\n\n\nint ngx_cdecl\nmain(int argc, char *const *argv)\n{\n    ngx_buf_t        *b;\n    ngx_log_t        *log;\n    ngx_uint_t        i;\n    ngx_cycle_t      *cycle, init_cycle;\n    ngx_conf_dump_t  *cd;\n    ngx_core_conf_t  *ccf;\n\n    ngx_debug_init();\n\n    if (ngx_strerror_init() != NGX_OK) {\n        return 1;\n    }\n\n    if (ngx_get_options(argc, argv) != NGX_OK) {\n        return 1;\n    }\n\n    if (ngx_show_version) {\n        ngx_show_version_info();\n\n        if (!ngx_test_config) {\n            return 0;\n        }\n    }\n\n    /* TODO */ ngx_max_sockets = -1;\n\n    ngx_time_init();\n\n#if (NGX_PCRE)\n    ngx_regex_init();\n#endif\n\n    ngx_pid = ngx_getpid();\n    ngx_parent = ngx_getppid();\n\n    log = ngx_log_init(ngx_prefix);\n    if (log == NULL) {\n        return 1;\n    }\n\n    /* STUB */\n#if (NGX_OPENSSL)\n    ngx_ssl_init(log);\n#endif\n\n    /*\n     * init_cycle->log is required for signal handlers and\n     * ngx_process_options()\n     */\n\n    ngx_memzero(&init_cycle, sizeof(ngx_cycle_t));\n    init_cycle.log = log;\n    ngx_cycle = &init_cycle;\n\n    init_cycle.pool = ngx_create_pool(1024, log);\n    if (init_cycle.pool == NULL) {\n        return 1;\n    }\n\n    if (ngx_save_argv(&init_cycle, argc, argv) != NGX_OK) {\n        return 1;\n    }\n\n    if (ngx_process_options(&init_cycle) != NGX_OK) {\n        return 1;\n    }\n\n    if (ngx_os_init(log) != NGX_OK) {\n        return 1;\n    }\n\n    /*\n     * ngx_crc32_table_init() requires ngx_cacheline_size set in ngx_os_init()\n     */\n\n    if (ngx_crc32_table_init() != NGX_OK) {\n        return 1;\n    }\n\n    /*\n     * ngx_slab_sizes_init() requires ngx_pagesize set in ngx_os_init()\n     */\n\n    ngx_slab_sizes_init();\n\n    if (ngx_add_inherited_sockets(&init_cycle) != NGX_OK) {\n        return 1;\n    }\n\n    if (ngx_preinit_modules() != NGX_OK) {\n        return 1;\n    }\n\n    cycle = ngx_init_cycle(&init_cycle);\n    if (cycle == NULL) {\n        if (ngx_test_config) {\n            ngx_log_stderr(0, \"configuration file %s test failed\",\n                           init_cycle.conf_file.data);\n        }\n\n        return 1;\n    }\n\n    if (ngx_test_config) {\n        if (!ngx_quiet_mode) {\n            ngx_log_stderr(0, \"configuration file %s test is successful\",\n                           cycle->conf_file.data);\n        }\n\n        if (ngx_dump_config) {\n            cd = cycle->config_dump.elts;\n\n            for (i = 0; i < cycle->config_dump.nelts; i++) {\n\n                ngx_write_stdout(\"# configuration file \");\n                (void) ngx_write_fd(ngx_stdout, cd[i].name.data,\n                                    cd[i].name.len);\n                ngx_write_stdout(\":\" NGX_LINEFEED);\n\n                b = cd[i].buffer;\n\n                (void) ngx_write_fd(ngx_stdout, b->pos, b->last - b->pos);\n                ngx_write_stdout(NGX_LINEFEED);\n            }\n        }\n\n        return 0;\n    }\n\n    if (ngx_signal) {\n        return ngx_signal_process(cycle, ngx_signal);\n    }\n\n    ngx_os_status(cycle->log);\n\n    ngx_cycle = cycle;\n\n    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);\n\n    if (ccf->master && ngx_process == NGX_PROCESS_SINGLE) {\n        ngx_process = NGX_PROCESS_MASTER;\n    }\n\n#if !(NGX_WIN32)\n\n    if (ngx_init_signals(cycle->log) != NGX_OK) {\n        return 1;\n    }\n\n    if (!ngx_inherited && ccf->daemon) {\n        if (ngx_daemon(cycle->log) != NGX_OK) {\n            return 1;\n        }\n\n        ngx_daemonized = 1;\n    }\n\n    if (ngx_inherited) {\n        ngx_daemonized = 1;\n    }\n\n#endif\n\n    if (ngx_create_pidfile(&ccf->pid, cycle->log) != NGX_OK) {\n        return 1;\n    }\n\n    if (ngx_log_redirect_stderr(cycle) != NGX_OK) {\n        return 1;\n    }\n\n    if (log->file->fd != ngx_stderr) {\n        if (ngx_close_file(log->file->fd) == NGX_FILE_ERROR) {\n            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n                          ngx_close_file_n \" built-in log failed\");\n        }\n    }\n\n    ngx_use_stderr = 0;\n\n    if (ngx_process == NGX_PROCESS_SINGLE) {\n        ngx_single_process_cycle(cycle);\n\n    } else {\n        ngx_master_process_cycle(cycle);\n    }\n\n    return 0;\n}\n\n\nstatic void\nngx_show_version_info(void)\n{\n    ngx_write_stderr(\"nginx version: \" NGINX_VER_BUILD NGX_LINEFEED);\n\n    if (ngx_show_help) {\n        ngx_write_stderr(\n            \"Usage: nginx [-?hvVtTq] [-s signal] [-c filename] \"\n                         \"[-p prefix] [-g directives]\" NGX_LINEFEED\n                         NGX_LINEFEED\n            \"Options:\" NGX_LINEFEED\n            \"  -?,-h         : this help\" NGX_LINEFEED\n            \"  -v            : show version and exit\" NGX_LINEFEED\n            \"  -V            : show version and configure options then exit\"\n                               NGX_LINEFEED\n            \"  -t            : test configuration and exit\" NGX_LINEFEED\n            \"  -T            : test configuration, dump it and exit\"\n                               NGX_LINEFEED\n            \"  -q            : suppress non-error messages \"\n                               \"during configuration testing\" NGX_LINEFEED\n            \"  -s signal     : send signal to a master process: \"\n                               \"stop, quit, reopen, reload\" NGX_LINEFEED\n#ifdef NGX_PREFIX\n            \"  -p prefix     : set prefix path (default: \" NGX_PREFIX \")\"\n                               NGX_LINEFEED\n#else\n            \"  -p prefix     : set prefix path (default: NONE)\" NGX_LINEFEED\n#endif\n            \"  -c filename   : set configuration file (default: \" NGX_CONF_PATH\n                               \")\" NGX_LINEFEED\n            \"  -g directives : set global directives out of configuration \"\n                               \"file\" NGX_LINEFEED NGX_LINEFEED\n        );\n    }\n\n    if (ngx_show_configure) {\n\n#ifdef NGX_COMPILER\n        ngx_write_stderr(\"built by \" NGX_COMPILER NGX_LINEFEED);\n#endif\n\n#if (NGX_SSL)\n        if (ngx_strcmp(ngx_ssl_version(), OPENSSL_VERSION_TEXT) == 0) {\n            ngx_write_stderr(\"built with \" OPENSSL_VERSION_TEXT NGX_LINEFEED);\n        } else {\n            ngx_write_stderr(\"built with \" OPENSSL_VERSION_TEXT\n                             \" (running with \");\n            ngx_write_stderr((char *) (uintptr_t) ngx_ssl_version());\n            ngx_write_stderr(\")\" NGX_LINEFEED);\n        }\n#ifdef SSL_CTRL_SET_TLSEXT_HOSTNAME\n        ngx_write_stderr(\"TLS SNI support enabled\" NGX_LINEFEED);\n#else\n        ngx_write_stderr(\"TLS SNI support disabled\" NGX_LINEFEED);\n#endif\n#endif\n\n        ngx_write_stderr(\"configure arguments:\" NGX_CONFIGURE NGX_LINEFEED);\n    }\n}\n\n\nstatic ngx_int_t\nngx_add_inherited_sockets(ngx_cycle_t *cycle)\n{\n    u_char           *p, *v, *inherited;\n    ngx_int_t         s;\n    ngx_listening_t  *ls;\n\n    inherited = (u_char *) getenv(NGINX_VAR);\n\n    if (inherited == NULL) {\n        return NGX_OK;\n    }\n\n    ngx_log_error(NGX_LOG_NOTICE, cycle->log, 0,\n                  \"using inherited sockets from \\\"%s\\\"\", inherited);\n\n    if (ngx_array_init(&cycle->listening, cycle->pool, 10,\n                       sizeof(ngx_listening_t))\n        != NGX_OK)\n    {\n        return NGX_ERROR;\n    }\n\n    for (p = inherited, v = p; *p; p++) {\n        if (*p == ':' || *p == ';') {\n            s = ngx_atoi(v, p - v);\n            if (s == NGX_ERROR) {\n                ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,\n                              \"invalid socket number \\\"%s\\\" in \" NGINX_VAR\n                              \" environment variable, ignoring the rest\"\n                              \" of the variable\", v);\n                break;\n            }\n\n            v = p + 1;\n\n            ls = ngx_array_push(&cycle->listening);\n            if (ls == NULL) {\n                return NGX_ERROR;\n            }\n\n            ngx_memzero(ls, sizeof(ngx_listening_t));\n\n            ls->fd = (ngx_socket_t) s;\n        }\n    }\n\n    if (v != p) {\n        ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,\n                      \"invalid socket number \\\"%s\\\" in \" NGINX_VAR\n                      \" environment variable, ignoring\", v);\n    }\n\n    ngx_inherited = 1;\n\n    return ngx_set_inherited_sockets(cycle);\n}\n\n\nchar **\nngx_set_environment(ngx_cycle_t *cycle, ngx_uint_t *last)\n{\n    char                **p, **env;\n    ngx_str_t            *var;\n    ngx_uint_t            i, n;\n    ngx_core_conf_t      *ccf;\n    ngx_pool_cleanup_t   *cln;\n\n    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);\n\n    if (last == NULL && ccf->environment) {\n        return ccf->environment;\n    }\n\n    var = ccf->env.elts;\n\n    for (i = 0; i < ccf->env.nelts; i++) {\n        if (ngx_strcmp(var[i].data, \"TZ\") == 0\n            || ngx_strncmp(var[i].data, \"TZ=\", 3) == 0)\n        {\n            goto tz_found;\n        }\n    }\n\n    var = ngx_array_push(&ccf->env);\n    if (var == NULL) {\n        return NULL;\n    }\n\n    var->len = 2;\n    var->data = (u_char *) \"TZ\";\n\n    var = ccf->env.elts;\n\ntz_found:\n\n    n = 0;\n\n    for (i = 0; i < ccf->env.nelts; i++) {\n\n        if (var[i].data[var[i].len] == '=') {\n            n++;\n            continue;\n        }\n\n        for (p = ngx_os_environ; *p; p++) {\n\n            if (ngx_strncmp(*p, var[i].data, var[i].len) == 0\n                && (*p)[var[i].len] == '=')\n            {\n                n++;\n                break;\n            }\n        }\n    }\n\n    if (last) {\n        env = ngx_alloc((*last + n + 1) * sizeof(char *), cycle->log);\n        if (env == NULL) {\n            return NULL;\n        }\n\n        *last = n;\n\n    } else {\n        cln = ngx_pool_cleanup_add(cycle->pool, 0);\n        if (cln == NULL) {\n            return NULL;\n        }\n\n        env = ngx_alloc((n + 1) * sizeof(char *), cycle->log);\n        if (env == NULL) {\n            return NULL;\n        }\n\n        cln->handler = ngx_cleanup_environment;\n        cln->data = env;\n    }\n\n    n = 0;\n\n    for (i = 0; i < ccf->env.nelts; i++) {\n\n        if (var[i].data[var[i].len] == '=') {\n            env[n++] = (char *) var[i].data;\n            continue;\n        }\n\n        for (p = ngx_os_environ; *p; p++) {\n\n            if (ngx_strncmp(*p, var[i].data, var[i].len) == 0\n                && (*p)[var[i].len] == '=')\n            {\n                env[n++] = *p;\n                break;\n            }\n        }\n    }\n\n    env[n] = NULL;\n\n    if (last == NULL) {\n        ccf->environment = env;\n        environ = env;\n    }\n\n    return env;\n}\n\n\nstatic void\nngx_cleanup_environment(void *data)\n{\n    char  **env = data;\n\n    if (environ == env) {\n\n        /*\n         * if the environment is still used, as it happens on exit,\n         * the only option is to leak it\n         */\n\n        return;\n    }\n\n    ngx_free(env);\n}\n\n\nngx_pid_t\nngx_exec_new_binary(ngx_cycle_t *cycle, char *const *argv)\n{\n    char             **env, *var;\n    u_char            *p;\n    ngx_uint_t         i, n;\n    ngx_pid_t          pid;\n    ngx_exec_ctx_t     ctx;\n    ngx_core_conf_t   *ccf;\n    ngx_listening_t   *ls;\n\n    ngx_memzero(&ctx, sizeof(ngx_exec_ctx_t));\n\n    ctx.path = argv[0];\n    ctx.name = \"new binary process\";\n    ctx.argv = argv;\n\n    n = 2;\n    env = ngx_set_environment(cycle, &n);\n    if (env == NULL) {\n        return NGX_INVALID_PID;\n    }\n\n    var = ngx_alloc(sizeof(NGINX_VAR)\n                    + cycle->listening.nelts * (NGX_INT32_LEN + 1) + 2,\n                    cycle->log);\n    if (var == NULL) {\n        ngx_free(env);\n        return NGX_INVALID_PID;\n    }\n\n    p = ngx_cpymem(var, NGINX_VAR \"=\", sizeof(NGINX_VAR));\n\n    ls = cycle->listening.elts;\n    for (i = 0; i < cycle->listening.nelts; i++) {\n        p = ngx_sprintf(p, \"%ud;\", ls[i].fd);\n    }\n\n    *p = '\\0';\n\n    env[n++] = var;\n\n#if (NGX_SETPROCTITLE_USES_ENV)\n\n    /* allocate the spare 300 bytes for the new binary process title */\n\n    env[n++] = \"SPARE=XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\"\n               \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\"\n               \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\"\n               \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\"\n               \"XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX\";\n\n#endif\n\n    env[n] = NULL;\n\n#if (NGX_DEBUG)\n    {\n    char  **e;\n    for (e = env; *e; e++) {\n        ngx_log_debug1(NGX_LOG_DEBUG_CORE, cycle->log, 0, \"env: %s\", *e);\n    }\n    }\n#endif\n\n    ctx.envp = (char *const *) env;\n\n    ccf = (ngx_core_conf_t *) ngx_get_conf(cycle->conf_ctx, ngx_core_module);\n\n    if (ngx_rename_file(ccf->pid.data, ccf->oldpid.data) == NGX_FILE_ERROR) {\n        ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n                      ngx_rename_file_n \" %s to %s failed \"\n                      \"before executing new binary process \\\"%s\\\"\",\n                      ccf->pid.data, ccf->oldpid.data, argv[0]);\n\n        ngx_free(env);\n        ngx_free(var);\n\n        return NGX_INVALID_PID;\n    }\n\n    pid = ngx_execute(cycle, &ctx);\n\n    if (pid == NGX_INVALID_PID) {\n        if (ngx_rename_file(ccf->oldpid.data, ccf->pid.data)\n            == NGX_FILE_ERROR)\n        {\n            ngx_log_error(NGX_LOG_ALERT, cycle->log, ngx_errno,\n                          ngx_rename_file_n \" %s back to %s failed after \"\n                          \"an attempt to execute new binary process \\\"%s\\\"\",\n                          ccf->oldpid.data, ccf->pid.data, argv[0]);\n        }\n    }\n\n    ngx_free(env);\n    ngx_free(var);\n\n    return pid;\n}\n\n\nstatic ngx_int_t\nngx_get_options(int argc, char *const *argv)\n{\n    u_char     *p;\n    ngx_int_t   i;\n\n    for (i = 1; i < argc; i++) {\n\n        p = (u_char *) argv[i];\n\n        if (*p++ != '-') {\n            ngx_log_stderr(0, \"invalid option: \\\"%s\\\"\", argv[i]);\n            return NGX_ERROR;\n        }\n\n        while (*p) {\n\n            switch (*p++) {\n\n            case '?':\n            case 'h':\n                ngx_show_version = 1;\n                ngx_show_help = 1;\n                break;\n\n            case 'v':\n                ngx_show_version = 1;\n                break;\n\n            case 'V':\n                ngx_show_version = 1;\n                ngx_show_configure = 1;\n                break;\n\n            case 't':\n                ngx_test_config = 1;\n                break;\n\n            case 'T':\n                ngx_test_config = 1;\n                ngx_dump_config = 1;\n                break;\n\n            case 'q':\n                ngx_quiet_mode = 1;\n                break;\n\n            case 'p':\n                if (*p) {\n                    ngx_prefix = p;\n                    goto next;\n                }\n\n                if (argv[++i]) {\n                    ngx_prefix = (u_char *) argv[i];\n                    goto next;\n                }\n\n                ngx_log_stderr(0, \"option \\\"-p\\\" requires directory name\");\n                return NGX_ERROR;\n\n            case 'c':\n                if (*p) {\n                    ngx_conf_file = p;\n                    goto next;\n                }\n\n                if (argv[++i]) {\n                    ngx_conf_file = (u_char *) argv[i];\n                    goto next;\n                }\n\n                ngx_log_stderr(0, \"option \\\"-c\\\" requires file name\");\n                return NGX_ERROR;\n\n            case 'g':\n                if (*p) {\n                    ngx_conf_params = p;\n                    goto next;\n                }\n\n                if (argv[++i]) {\n                    ngx_conf_params = (u_char *) argv[i];\n                    goto next;\n                }\n\n                ngx_log_stderr(0, \"option \\\"-g\\\" requires parameter\");\n                return NGX_ERROR;\n\n            case 's':\n                if (*p) {\n                    ngx_signal = (char *) p;\n\n                } else if (argv[++i]) {\n                    ngx_signal = argv[i];\n\n                } else {\n                    ngx_log_stderr(0, \"option \\\"-s\\\" requires parameter\");\n                    return NGX_ERROR;\n                }\n\n                if (ngx_strcmp(ngx_signal, \"stop\") == 0\n                    || ngx_strcmp(ngx_signal, \"quit\") == 0\n                    || ngx_strcmp(ngx_signal, \"reopen\") == 0\n                    || ngx_strcmp(ngx_signal, \"reload\") == 0)\n                {\n                    ngx_process = NGX_PROCESS_SIGNALLER;\n                    goto next;\n                }\n\n                ngx_log_stderr(0, \"invalid option: \\\"-s %s\\\"\", ngx_signal);\n                return NGX_ERROR;\n\n            default:\n                ngx_log_stderr(0, \"invalid option: \\\"%c\\\"\", *(p - 1));\n                return NGX_ERROR;\n            }\n        }\n\n    next:\n\n        continue;\n    }\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_save_argv(ngx_cycle_t *cycle, int argc, char *const *argv)\n{\n#if (NGX_FREEBSD)\n\n    ngx_os_argv = (char **) argv;\n    ngx_argc = argc;\n    ngx_argv = (char **) argv;\n\n#else\n    size_t     len;\n    ngx_int_t  i;\n\n    ngx_os_argv = (char **) argv;\n    ngx_argc = argc;\n\n    ngx_argv = ngx_alloc((argc + 1) * sizeof(char *), cycle->log);\n    if (ngx_argv == NULL) {\n        return NGX_ERROR;\n    }\n\n    for (i = 0; i < argc; i++) {\n        len = ngx_strlen(argv[i]) + 1;\n\n        ngx_argv[i] = ngx_alloc(len, cycle->log);\n        if (ngx_argv[i] == NULL) {\n            return NGX_ERROR;\n        }\n\n        (void) ngx_cpystrn((u_char *) ngx_argv[i], (u_char *) argv[i], len);\n    }\n\n    ngx_argv[i] = NULL;\n\n#endif\n\n    ngx_os_environ = environ;\n\n    return NGX_OK;\n}\n\n\nstatic ngx_int_t\nngx_process_options(ngx_cycle_t *cycle)\n{\n    u_char  *p;\n    size_t   len;\n\n    if (ngx_prefix) {\n        len = ngx_strlen(ngx_prefix);\n        p = ngx_prefix;\n\n        if (len && !ngx_path_separator(p[len - 1])) {\n            p = ngx_pnalloc(cycle->pool, len + 1);\n            if (p == NULL) {\n                return NGX_ERROR;\n            }\n\n            ngx_memcpy(p, ngx_prefix, len);\n            p[len++] = '/';\n        }\n\n        cycle->conf_prefix.len = len;\n        cycle->conf_prefix.data = p;\n        cycle->prefix.len = len;\n        cycle->prefix.data = p;\n\n    } else {\n\n#ifndef NGX_PREFIX\n\n        p = ngx_pnalloc(cycle->pool, NGX_MAX_PATH);\n        if (p == NULL) {\n            return NGX_ERROR;\n        }\n\n        if (ngx_getcwd(p, NGX_MAX_PATH) == 0) {\n            ngx_log_stderr(ngx_errno, \"[emerg]: \" ngx_getcwd_n \" failed\");\n            return NGX_ERROR;\n        }\n\n        len = ngx_strlen(p);\n\n        p[len++] = '/';\n\n        cycle->conf_prefix.len = len;\n        cycle->conf_prefix.data = p;\n        cycle->prefix.len = len;\n        cycle->prefix.data = p;\n\n#else\n\n#ifdef NGX_CONF_PREFIX\n        ngx_str_set(&cycle->conf_prefix, NGX_CONF_PREFIX);\n#else\n        ngx_str_set(&cycle->conf_prefix, NGX_PREFIX);\n#endif\n        ngx_str_set(&cycle->prefix, NGX_PREFIX);\n\n#endif\n    }\n\n    if (ngx_conf_file) {\n        cycle->conf_file.len = ngx_strlen(ngx_conf_file);\n        cycle->conf_file.data = ngx_conf_file;\n\n    } else {\n        ngx_str_set(&cycle->conf_file, NGX_CONF_PATH);\n    }\n\n    if (ngx_conf_full_name(cycle, &cycle->conf_file, 0) != NGX_OK) {\n        return NGX_ERROR;\n    }\n\n    for (p = cycle->conf_file.data + cycle->conf_file.len - 1;\n         p > cycle->conf_file.data;\n         p--)\n    {\n        if (ngx_path_separator(*p)) {\n            cycle->conf_prefix.len = p - ngx_cycle->conf_file.data + 1;\n            cycle->conf_prefix.data = ngx_cycle->conf_file.data;\n            break;\n        }\n    }\n\n    if (ngx_conf_params) {\n        cycle->conf_param.len = ngx_strlen(ngx_conf_params);\n        cycle->conf_param.data = ngx_conf_params;\n    }\n\n    if (ngx_test_config) {\n        cycle->log->log_level = NGX_LOG_INFO;\n    }\n\n    return NGX_OK;\n}\n\n\nstatic void *\nngx_core_module_create_conf(ngx_cycle_t *cycle)\n{\n    ngx_core_conf_t  *ccf;\n\n    ccf = ngx_pcalloc(cycle->pool, sizeof(ngx_core_conf_t));\n    if (ccf == NULL) {\n        return NULL;\n    }\n\n    /*\n     * set by ngx_pcalloc()\n     *\n     *     ccf->pid = NULL;\n     *     ccf->oldpid = NULL;\n     *     ccf->priority = 0;\n     *     ccf->cpu_affinity_auto = 0;\n     *     ccf->cpu_affinity_n = 0;\n     *     ccf->cpu_affinity = NULL;\n     */\n\n    ccf->daemon = NGX_CONF_UNSET;\n    ccf->master = NGX_CONF_UNSET;\n    ccf->timer_resolution = NGX_CONF_UNSET_MSEC;\n    ccf->shutdown_timeout = NGX_CONF_UNSET_MSEC;\n\n    ccf->worker_processes = NGX_CONF_UNSET;\n    ccf->debug_points = NGX_CONF_UNSET;\n\n    ccf->rlimit_nofile = NGX_CONF_UNSET;\n    ccf->rlimit_core = NGX_CONF_UNSET;\n\n    ccf->user = (ngx_uid_t) NGX_CONF_UNSET_UINT;\n    ccf->group = (ngx_gid_t) NGX_CONF_UNSET_UINT;\n\n    if (ngx_array_init(&ccf->env, cycle->pool, 1, sizeof(ngx_str_t))\n        != NGX_OK)\n    {\n        return NULL;\n    }\n\n    return ccf;\n}\n\n\nstatic char *\nngx_core_module_init_conf(ngx_cycle_t *cycle, void *conf)\n{\n    ngx_core_conf_t  *ccf = conf;\n\n    ngx_conf_init_value(ccf->daemon, 1);\n    ngx_conf_init_value(ccf->master, 1);\n    ngx_conf_init_msec_value(ccf->timer_resolution, 0);\n    ngx_conf_init_msec_value(ccf->shutdown_timeout, 0);\n\n    ngx_conf_init_value(ccf->worker_processes, 1);\n    ngx_conf_init_value(ccf->debug_points, 0);\n\n#if (NGX_HAVE_CPU_AFFINITY)\n\n    if (!ccf->cpu_affinity_auto\n        && ccf->cpu_affinity_n\n        && ccf->cpu_affinity_n != 1\n        && ccf->cpu_affinity_n != (ngx_uint_t) ccf->worker_processes)\n    {\n        ngx_log_error(NGX_LOG_WARN, cycle->log, 0,\n                      \"the number of \\\"worker_processes\\\" is not equal to \"\n                      \"the number of \\\"worker_cpu_affinity\\\" masks, \"\n                      \"using last mask for remaining worker processes\");\n    }\n\n#endif\n\n\n    if (ccf->pid.len == 0) {\n        ngx_str_set(&ccf->pid, NGX_PID_PATH);\n    }\n\n    if (ngx_conf_full_name(cycle, &ccf->pid, 0) != NGX_OK) {\n        return NGX_CONF_ERROR;\n    }\n\n    ccf->oldpid.len = ccf->pid.len + sizeof(NGX_OLDPID_EXT);\n\n    ccf->oldpid.data = ngx_pnalloc(cycle->pool, ccf->oldpid.len);\n    if (ccf->oldpid.data == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    ngx_memcpy(ngx_cpymem(ccf->oldpid.data, ccf->pid.data, ccf->pid.len),\n               NGX_OLDPID_EXT, sizeof(NGX_OLDPID_EXT));\n\n\n#if !(NGX_WIN32)\n\n    if (ccf->user == (uid_t) NGX_CONF_UNSET_UINT && geteuid() == 0) {\n        struct group   *grp;\n        struct passwd  *pwd;\n\n        ngx_set_errno(0);\n        pwd = getpwnam(NGX_USER);\n        if (pwd == NULL) {\n            ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,\n                          \"getpwnam(\\\"\" NGX_USER \"\\\") failed\");\n            return NGX_CONF_ERROR;\n        }\n\n        ccf->username = NGX_USER;\n        ccf->user = pwd->pw_uid;\n\n        ngx_set_errno(0);\n        grp = getgrnam(NGX_GROUP);\n        if (grp == NULL) {\n            ngx_log_error(NGX_LOG_EMERG, cycle->log, ngx_errno,\n                          \"getgrnam(\\\"\" NGX_GROUP \"\\\") failed\");\n            return NGX_CONF_ERROR;\n        }\n\n        ccf->group = grp->gr_gid;\n    }\n\n\n    if (ccf->lock_file.len == 0) {\n        ngx_str_set(&ccf->lock_file, NGX_LOCK_PATH);\n    }\n\n    if (ngx_conf_full_name(cycle, &ccf->lock_file, 0) != NGX_OK) {\n        return NGX_CONF_ERROR;\n    }\n\n    {\n    ngx_str_t  lock_file;\n\n    lock_file = cycle->old_cycle->lock_file;\n\n    if (lock_file.len) {\n        lock_file.len--;\n\n        if (ccf->lock_file.len != lock_file.len\n            || ngx_strncmp(ccf->lock_file.data, lock_file.data, lock_file.len)\n               != 0)\n        {\n            ngx_log_error(NGX_LOG_EMERG, cycle->log, 0,\n                          \"\\\"lock_file\\\" could not be changed, ignored\");\n        }\n\n        cycle->lock_file.len = lock_file.len + 1;\n        lock_file.len += sizeof(\".accept\");\n\n        cycle->lock_file.data = ngx_pstrdup(cycle->pool, &lock_file);\n        if (cycle->lock_file.data == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n    } else {\n        cycle->lock_file.len = ccf->lock_file.len + 1;\n        cycle->lock_file.data = ngx_pnalloc(cycle->pool,\n                                      ccf->lock_file.len + sizeof(\".accept\"));\n        if (cycle->lock_file.data == NULL) {\n            return NGX_CONF_ERROR;\n        }\n\n        ngx_memcpy(ngx_cpymem(cycle->lock_file.data, ccf->lock_file.data,\n                              ccf->lock_file.len),\n                   \".accept\", sizeof(\".accept\"));\n    }\n    }\n\n#endif\n\n    return NGX_CONF_OK;\n}\n\n\nstatic char *\nngx_set_user(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n#if (NGX_WIN32)\n\n    ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n                       \"\\\"user\\\" is not supported, ignored\");\n\n    return NGX_CONF_OK;\n\n#else\n\n    ngx_core_conf_t  *ccf = conf;\n\n    char             *group;\n    struct passwd    *pwd;\n    struct group     *grp;\n    ngx_str_t        *value;\n\n    if (ccf->user != (uid_t) NGX_CONF_UNSET_UINT) {\n        return \"is duplicate\";\n    }\n\n    if (geteuid() != 0) {\n        ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n                           \"the \\\"user\\\" directive makes sense only \"\n                           \"if the master process runs \"\n                           \"with super-user privileges, ignored\");\n        return NGX_CONF_OK;\n    }\n\n    value = cf->args->elts;\n\n    ccf->username = (char *) value[1].data;\n\n    ngx_set_errno(0);\n    pwd = getpwnam((const char *) value[1].data);\n    if (pwd == NULL) {\n        ngx_conf_log_error(NGX_LOG_EMERG, cf, ngx_errno,\n                           \"getpwnam(\\\"%s\\\") failed\", value[1].data);\n        return NGX_CONF_ERROR;\n    }\n\n    ccf->user = pwd->pw_uid;\n\n    group = (char *) ((cf->args->nelts == 2) ? value[1].data : value[2].data);\n\n    ngx_set_errno(0);\n    grp = getgrnam(group);\n    if (grp == NULL) {\n        ngx_conf_log_error(NGX_LOG_EMERG, cf, ngx_errno,\n                           \"getgrnam(\\\"%s\\\") failed\", group);\n        return NGX_CONF_ERROR;\n    }\n\n    ccf->group = grp->gr_gid;\n\n    return NGX_CONF_OK;\n\n#endif\n}\n\n\nstatic char *\nngx_set_env(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n    ngx_core_conf_t  *ccf = conf;\n\n    ngx_str_t   *value, *var;\n    ngx_uint_t   i;\n\n    var = ngx_array_push(&ccf->env);\n    if (var == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    value = cf->args->elts;\n    *var = value[1];\n\n    for (i = 0; i < value[1].len; i++) {\n\n        if (value[1].data[i] == '=') {\n\n            var->len = i;\n\n            return NGX_CONF_OK;\n        }\n    }\n\n    return NGX_CONF_OK;\n}\n\n\nstatic char *\nngx_set_priority(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n    ngx_core_conf_t  *ccf = conf;\n\n    ngx_str_t        *value;\n    ngx_uint_t        n, minus;\n\n    if (ccf->priority != 0) {\n        return \"is duplicate\";\n    }\n\n    value = cf->args->elts;\n\n    if (value[1].data[0] == '-') {\n        n = 1;\n        minus = 1;\n\n    } else if (value[1].data[0] == '+') {\n        n = 1;\n        minus = 0;\n\n    } else {\n        n = 0;\n        minus = 0;\n    }\n\n    ccf->priority = ngx_atoi(&value[1].data[n], value[1].len - n);\n    if (ccf->priority == NGX_ERROR) {\n        return \"invalid number\";\n    }\n\n    if (minus) {\n        ccf->priority = -ccf->priority;\n    }\n\n    return NGX_CONF_OK;\n}\n\n\nstatic char *\nngx_set_cpu_affinity(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n#if (NGX_HAVE_CPU_AFFINITY)\n    ngx_core_conf_t  *ccf = conf;\n\n    u_char            ch, *p;\n    ngx_str_t        *value;\n    ngx_uint_t        i, n;\n    ngx_cpuset_t     *mask;\n\n    if (ccf->cpu_affinity) {\n        return \"is duplicate\";\n    }\n\n    mask = ngx_palloc(cf->pool, (cf->args->nelts - 1) * sizeof(ngx_cpuset_t));\n    if (mask == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    ccf->cpu_affinity_n = cf->args->nelts - 1;\n    ccf->cpu_affinity = mask;\n\n    value = cf->args->elts;\n\n    if (ngx_strcmp(value[1].data, \"auto\") == 0) {\n\n        if (cf->args->nelts > 3) {\n            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                               \"invalid number of arguments in \"\n                               \"\\\"worker_cpu_affinity\\\" directive\");\n            return NGX_CONF_ERROR;\n        }\n\n        ccf->cpu_affinity_auto = 1;\n\n        CPU_ZERO(&mask[0]);\n        for (i = 0; i < (ngx_uint_t) ngx_min(ngx_ncpu, CPU_SETSIZE); i++) {\n            CPU_SET(i, &mask[0]);\n        }\n\n        n = 2;\n\n    } else {\n        n = 1;\n    }\n\n    for ( /* void */ ; n < cf->args->nelts; n++) {\n\n        if (value[n].len > CPU_SETSIZE) {\n            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                         \"\\\"worker_cpu_affinity\\\" supports up to %d CPUs only\",\n                         CPU_SETSIZE);\n            return NGX_CONF_ERROR;\n        }\n\n        i = 0;\n        CPU_ZERO(&mask[n - 1]);\n\n        for (p = value[n].data + value[n].len - 1;\n             p >= value[n].data;\n             p--)\n        {\n            ch = *p;\n\n            if (ch == ' ') {\n                continue;\n            }\n\n            i++;\n\n            if (ch == '0') {\n                continue;\n            }\n\n            if (ch == '1') {\n                CPU_SET(i - 1, &mask[n - 1]);\n                continue;\n            }\n\n            ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                          \"invalid character \\\"%c\\\" in \\\"worker_cpu_affinity\\\"\",\n                          ch);\n            return NGX_CONF_ERROR;\n        }\n    }\n\n#else\n\n    ngx_conf_log_error(NGX_LOG_WARN, cf, 0,\n                       \"\\\"worker_cpu_affinity\\\" is not supported \"\n                       \"on this platform, ignored\");\n#endif\n\n    return NGX_CONF_OK;\n}\n\n\nngx_cpuset_t *\nngx_get_cpu_affinity(ngx_uint_t n)\n{\n#if (NGX_HAVE_CPU_AFFINITY)\n    ngx_uint_t        i, j;\n    ngx_cpuset_t     *mask;\n    ngx_core_conf_t  *ccf;\n\n    static ngx_cpuset_t  result;\n\n    ccf = (ngx_core_conf_t *) ngx_get_conf(ngx_cycle->conf_ctx,\n                                           ngx_core_module);\n\n    if (ccf->cpu_affinity == NULL) {\n        return NULL;\n    }\n\n    if (ccf->cpu_affinity_auto) {\n        mask = &ccf->cpu_affinity[ccf->cpu_affinity_n - 1];\n\n        for (i = 0, j = n; /* void */ ; i++) {\n\n            if (CPU_ISSET(i % CPU_SETSIZE, mask) && j-- == 0) {\n                break;\n            }\n\n            if (i == CPU_SETSIZE && j == n) {\n                /* empty mask */\n                return NULL;\n            }\n\n            /* void */\n        }\n\n        CPU_ZERO(&result);\n        CPU_SET(i % CPU_SETSIZE, &result);\n\n        return &result;\n    }\n\n    if (ccf->cpu_affinity_n > n) {\n        return &ccf->cpu_affinity[n];\n    }\n\n    return &ccf->cpu_affinity[ccf->cpu_affinity_n - 1];\n\n#else\n\n    return NULL;\n\n#endif\n}\n\n\nstatic char *\nngx_set_worker_processes(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n    ngx_str_t        *value;\n    ngx_core_conf_t  *ccf;\n\n    ccf = (ngx_core_conf_t *) conf;\n\n    if (ccf->worker_processes != NGX_CONF_UNSET) {\n        return \"is duplicate\";\n    }\n\n    value = cf->args->elts;\n\n    if (ngx_strcmp(value[1].data, \"auto\") == 0) {\n        ccf->worker_processes = ngx_ncpu;\n        return NGX_CONF_OK;\n    }\n\n    ccf->worker_processes = ngx_atoi(value[1].data, value[1].len);\n\n    if (ccf->worker_processes == NGX_ERROR) {\n        return \"invalid value\";\n    }\n\n    return NGX_CONF_OK;\n}\n\n\nstatic char *\nngx_load_module(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)\n{\n#if (NGX_HAVE_DLOPEN)\n    void                *handle;\n    char               **names, **order;\n    ngx_str_t           *value, file;\n    ngx_uint_t           i;\n    ngx_module_t        *module, **modules;\n    ngx_pool_cleanup_t  *cln;\n\n    if (cf->cycle->modules_used) {\n        return \"is specified too late\";\n    }\n\n    value = cf->args->elts;\n\n    file = value[1];\n\n    if (ngx_conf_full_name(cf->cycle, &file, 0) != NGX_OK) {\n        return NGX_CONF_ERROR;\n    }\n\n    cln = ngx_pool_cleanup_add(cf->cycle->pool, 0);\n    if (cln == NULL) {\n        return NGX_CONF_ERROR;\n    }\n\n    handle = ngx_dlopen(file.data);\n    if (handle == NULL) {\n        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                           ngx_dlopen_n \" \\\"%s\\\" failed (%s)\",\n                           file.data, ngx_dlerror());\n        return NGX_CONF_ERROR;\n    }\n\n    cln->handler = ngx_unload_module;\n    cln->data = handle;\n\n    modules = ngx_dlsym(handle, \"ngx_modules\");\n    if (modules == NULL) {\n        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                           ngx_dlsym_n \" \\\"%V\\\", \\\"%s\\\" failed (%s)\",\n                           &value[1], \"ngx_modules\", ngx_dlerror());\n        return NGX_CONF_ERROR;\n    }\n\n    names = ngx_dlsym(handle, \"ngx_module_names\");\n    if (names == NULL) {\n        ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                           ngx_dlsym_n \" \\\"%V\\\", \\\"%s\\\" failed (%s)\",\n                           &value[1], \"ngx_module_names\", ngx_dlerror());\n        return NGX_CONF_ERROR;\n    }\n\n    order = ngx_dlsym(handle, \"ngx_module_order\");\n\n    for (i = 0; modules[i]; i++) {\n        module = modules[i];\n        module->name = names[i];\n\n        if (ngx_add_module(cf, &file, module, order) != NGX_OK) {\n            return NGX_CONF_ERROR;\n        }\n\n        ngx_log_debug2(NGX_LOG_DEBUG_CORE, cf->log, 0, \"module: %s i:%ui\",\n                       module->name, module->index);\n    }\n\n    return NGX_CONF_OK;\n\n#else\n\n    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,\n                       \"\\\"load_module\\\" is not supported \"\n                       \"on this platform\");\n    return NGX_CONF_ERROR;\n\n#endif\n}\n\n\n#if (NGX_HAVE_DLOPEN)\n\nstatic void\nngx_unload_module(void *data)\n{\n    void  *handle = data;\n\n    if (ngx_dlclose(handle) != 0) {\n        ngx_log_error(NGX_LOG_ALERT, ngx_cycle->log, 0,\n                      ngx_dlclose_n \" failed (%s)\", ngx_dlerror());\n    }\n}\n\n#endif\n"
    },
    "skipped": [],
    "total_files": 325
}