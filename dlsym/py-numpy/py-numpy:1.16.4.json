{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.16.4-rddsfz5tosg7yhtz7tpb5iv3q5pnc7rb/spack-src/numpy/_build_utils/src/apple_sgemv_fix.c": "/* This is a collection of ugly hacks to circumvent a bug in\n * Apple Accelerate framework's SGEMV subroutine.\n *\n * See: https://github.com/numpy/numpy/issues/4007\n *\n * SGEMV in Accelerate framework will segfault on MacOS X version 10.9\n * (aka Mavericks) if arrays are not aligned to 32 byte boundaries\n * and the CPU supports AVX instructions. This can produce segfaults\n * in np.dot.\n *\n * This patch overshadows the symbols cblas_sgemv, sgemv_ and sgemv\n * exported by Accelerate to produce the correct behavior. The MacOS X\n * version and CPU specs are checked on module import. If Mavericks and\n * AVX are detected the call to SGEMV is emulated with a call to SGEMM\n * if the arrays are not 32 byte aligned. If the exported symbols cannot\n * be overshadowed on module import, a fatal error is produced and the\n * process aborts. All the fixes are in a self-contained C file\n * and do not alter the multiarray C code. The patch is not applied\n * unless NumPy is configured to link with Apple's Accelerate\n * framework.\n *\n */\n\n#define NPY_NO_DEPRECATED_API NPY_API_VERSION\n#include \"Python.h\"\n#include \"numpy/arrayobject.h\"\n\n#include <string.h>\n#include <dlfcn.h>\n#include <stdlib.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include <sys/sysctl.h>\n#include <string.h>\n\n/* ----------------------------------------------------------------- */\n/* Original cblas_sgemv */\n\n#define VECLIB_FILE \"/System/Library/Frameworks/Accelerate.framework/Versions/A/Frameworks/vecLib.framework/vecLib\"\n\nenum CBLAS_ORDER {CblasRowMajor=101, CblasColMajor=102};\nenum CBLAS_TRANSPOSE {CblasNoTrans=111, CblasTrans=112, CblasConjTrans=113};\nextern void cblas_xerbla(int info, const char *rout, const char *form, ...);\n\ntypedef void cblas_sgemv_t(const enum CBLAS_ORDER order,\n                 const enum CBLAS_TRANSPOSE TransA, const int M, const int N,\n                 const float alpha, const float  *A, const int lda,\n                 const float  *X, const int incX,\n                 const float beta, float  *Y, const int incY);\n\ntypedef void cblas_sgemm_t(const enum CBLAS_ORDER order,\n                 const enum CBLAS_TRANSPOSE TransA, const enum CBLAS_TRANSPOSE TransB,\n                 const int M, const int N, const int K,\n                 const float alpha, const float  *A, const int lda,\n                 const float  *B, const int ldb,\n                 const float beta, float  *C, const int incC);\n\ntypedef void fortran_sgemv_t( const char* trans, const int* m, const int* n,\n             const float* alpha, const float* A, const int* ldA,\n             const float* X, const int* incX,\n             const float* beta, float* Y, const int* incY );\n\nstatic void *veclib = NULL;\nstatic cblas_sgemv_t *accelerate_cblas_sgemv = NULL;\nstatic cblas_sgemm_t *accelerate_cblas_sgemm = NULL;\nstatic fortran_sgemv_t *accelerate_sgemv = NULL;\nstatic int AVX_and_10_9 = 0;\n\n/* Dynamic check for AVX support\n * __builtin_cpu_supports(\"avx\") is available in gcc 4.8,\n * but clang and icc do not currently support it. */\nstatic inline int \ncpu_supports_avx() \n{\n    int enabled, r;\n    size_t length = sizeof(enabled);\n    r = sysctlbyname(\"hw.optional.avx1_0\", &enabled, &length, NULL, 0);\n    if ( r == 0 && enabled != 0) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\n\t\n/* Check if we are using MacOS X version 10.9 */\nstatic inline int \nusing_mavericks() \n{\n    int r;\n    char str[32] = {0};\n    size_t size = sizeof(str);\n    r = sysctlbyname(\"kern.osproductversion\", str, &size, NULL, 0);\n    if ( r == 0 && strncmp(str, \"10.9\", strlen(\"10.9\")) == 0) {\n        return 1;\n    }\n    else {\n        return 0;\n    }\n}\n\n__attribute__((destructor))\nstatic void unloadlib(void)\n{\n   if (veclib) dlclose(veclib);\n}\n\n__attribute__((constructor))\nstatic void loadlib()\n/* automatically executed on module import */\n{\n    char errormsg[1024];\n    int AVX, MAVERICKS;\n    memset((void*)errormsg, 0, sizeof(errormsg));\n    /* check if the CPU supports AVX */\n    AVX = cpu_supports_avx();\n    /* check if the OS is MacOS X Mavericks */\n    MAVERICKS = using_mavericks();\n    /* we need the workaround when the CPU supports\n     * AVX and the OS version is Mavericks */\n    AVX_and_10_9 = AVX && MAVERICKS;\n    /* load vecLib */\n    veclib = dlopen(VECLIB_FILE, RTLD_LOCAL | RTLD_FIRST);\n    if (!veclib) {\n        veclib = NULL;\n        snprintf(errormsg, sizeof(errormsg),\n                 \"Failed to open vecLib from location '%s'.\", VECLIB_FILE);\n        Py_FatalError(errormsg); /* calls abort() and dumps core */\n    }\n    /* resolve Fortran SGEMV from Accelerate */\n    accelerate_sgemv = (fortran_sgemv_t*) dlsym(veclib, \"sgemv_\");\n    if (!accelerate_sgemv) {\n        unloadlib();\n        Py_FatalError(\"Failed to resolve symbol 'sgemv_'.\");\n    }\n    /* resolve cblas_sgemv from Accelerate */\n    accelerate_cblas_sgemv = (cblas_sgemv_t*) dlsym(veclib, \"cblas_sgemv\");\n    if (!accelerate_cblas_sgemv) {\n        unloadlib();\n        Py_FatalError(\"Failed to resolve symbol 'cblas_sgemv'.\");\n    }\n    /* resolve cblas_sgemm from Accelerate */\n    accelerate_cblas_sgemm = (cblas_sgemm_t*) dlsym(veclib, \"cblas_sgemm\");\n    if (!accelerate_cblas_sgemm) {\n        unloadlib();\n        Py_FatalError(\"Failed to resolve symbol 'cblas_sgemm'.\");\n    }\n}\n\n/* ----------------------------------------------------------------- */\n/* Fortran SGEMV override */\n\nvoid sgemv_( const char* trans, const int* m, const int* n,\n             const float* alpha, const float* A, const int* ldA,\n             const float* X, const int* incX,\n             const float* beta, float* Y, const int* incY )\n{\n    /* It is safe to use the original SGEMV if we are not using AVX on Mavericks\n     * or the input arrays A, X and Y are all aligned on 32 byte boundaries. */\n    #define BADARRAY(x) (((npy_intp)(void*)x) % 32)\n    const int use_sgemm = AVX_and_10_9 && (BADARRAY(A) || BADARRAY(X) || BADARRAY(Y));\n    if (!use_sgemm) {\n        accelerate_sgemv(trans,m,n,alpha,A,ldA,X,incX,beta,Y,incY);\n        return;\n    }\n\n    /* Arrays are misaligned, the CPU supports AVX, and we are running\n     * Mavericks.\n     *\n     * Emulation of SGEMV with SGEMM:\n     *\n     * SGEMV allows vectors to be strided. SGEMM requires all arrays to be\n     * contiguous along the leading dimension. To emulate striding in SGEMV\n     * with the leading dimension arguments in SGEMM we compute\n     *\n     *    Y = alpha * op(A) @ X + beta * Y\n     *\n     * as\n     *\n     *    Y.T = alpha * X.T @ op(A).T + beta * Y.T\n     *\n     * Because Fortran uses column major order and X.T and Y.T are row vectors,\n     * the leading dimensions of X.T and Y.T in SGEMM become equal to the\n     * strides of the column vectors X and Y in SGEMV. */\n\n    switch (*trans) {\n        case 'T':\n        case 't':\n        case 'C':\n        case 'c':\n            accelerate_cblas_sgemm( CblasColMajor, CblasNoTrans, CblasNoTrans,\n                1, *n, *m, *alpha, X, *incX, A, *ldA, *beta, Y, *incY );\n            break;\n        case 'N':\n        case 'n':\n            accelerate_cblas_sgemm( CblasColMajor, CblasNoTrans, CblasTrans,\n                1, *m, *n, *alpha, X, *incX, A, *ldA, *beta, Y, *incY );\n            break;\n        default:\n            cblas_xerbla(1, \"SGEMV\", \"Illegal transpose setting: %c\\n\", *trans);\n    }\n}\n\n/* ----------------------------------------------------------------- */\n/* Override for an alias symbol for sgemv_ in Accelerate */\n\nvoid sgemv (char *trans,\n            const int *m, const int *n,\n            const float *alpha,\n            const float *A, const int *lda,\n            const float *B, const int *incB,\n            const float *beta,\n            float *C, const int *incC)\n{\n    sgemv_(trans,m,n,alpha,A,lda,B,incB,beta,C,incC);\n}\n\n/* ----------------------------------------------------------------- */\n/* cblas_sgemv override, based on Netlib CBLAS code */\n\nvoid cblas_sgemv(const enum CBLAS_ORDER order,\n                 const enum CBLAS_TRANSPOSE TransA, const int M, const int N,\n                 const float alpha, const float  *A, const int lda,\n                 const float  *X, const int incX, const float beta,\n                 float  *Y, const int incY)\n{\n   char TA;\n   if (order == CblasColMajor)\n   {\n      if (TransA == CblasNoTrans) TA = 'N';\n      else if (TransA == CblasTrans) TA = 'T';\n      else if (TransA == CblasConjTrans) TA = 'C';\n      else\n      {\n         cblas_xerbla(2, \"cblas_sgemv\",\"Illegal TransA setting, %d\\n\", TransA);\n      }\n      sgemv_(&TA, &M, &N, &alpha, A, &lda, X, &incX, &beta, Y, &incY);\n   }\n   else if (order == CblasRowMajor)\n   {\n      if (TransA == CblasNoTrans) TA = 'T';\n      else if (TransA == CblasTrans) TA = 'N';\n      else if (TransA == CblasConjTrans) TA = 'N';\n      else\n      {\n         cblas_xerbla(2, \"cblas_sgemv\", \"Illegal TransA setting, %d\\n\", TransA);\n         return;\n      }\n      sgemv_(&TA, &N, &M, &alpha, A, &lda, X, &incX, &beta, Y, &incY);\n   }\n   else\n      cblas_xerbla(1, \"cblas_sgemv\", \"Illegal Order setting, %d\\n\", order);\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.16.4-rddsfz5tosg7yhtz7tpb5iv3q5pnc7rb/spack-src/numpy/lib/tests/data/python3.npy",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.16.4-rddsfz5tosg7yhtz7tpb5iv3q5pnc7rb/spack-src/numpy/lib/tests/data/win64python2.npy",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.16.4-rddsfz5tosg7yhtz7tpb5iv3q5pnc7rb/spack-src/numpy/lib/tests/data/py2-objarr.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.16.4-rddsfz5tosg7yhtz7tpb5iv3q5pnc7rb/spack-src/numpy/lib/tests/data/py3-objarr.npz",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.16.4-rddsfz5tosg7yhtz7tpb5iv3q5pnc7rb/spack-src/numpy/lib/tests/data/py2-objarr.npy",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.16.4-rddsfz5tosg7yhtz7tpb5iv3q5pnc7rb/spack-src/numpy/lib/tests/data/py3-objarr.npy",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.16.4-rddsfz5tosg7yhtz7tpb5iv3q5pnc7rb/spack-src/numpy/core/tests/data/recarray_from_file.fits",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.16.4-rddsfz5tosg7yhtz7tpb5iv3q5pnc7rb/spack-src/numpy/core/tests/data/astype_copy.pkl",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.16.4-rddsfz5tosg7yhtz7tpb5iv3q5pnc7rb/spack-src/tools/allocation_tracking/sorttable.js",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.16.4-rddsfz5tosg7yhtz7tpb5iv3q5pnc7rb/spack-src/doc/neps/_static/nep0013_image3.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.16.4-rddsfz5tosg7yhtz7tpb5iv3q5pnc7rb/spack-src/doc/neps/_static/nep0013_image2.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.16.4-rddsfz5tosg7yhtz7tpb5iv3q5pnc7rb/spack-src/doc/neps/_static/nep0013_image1.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.16.4-rddsfz5tosg7yhtz7tpb5iv3q5pnc7rb/spack-src/doc/neps/_static/nep-0000.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.16.4-rddsfz5tosg7yhtz7tpb5iv3q5pnc7rb/spack-src/doc/scipy-sphinx-theme/_theme/scipy/static/img/scipy_org_logo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.16.4-rddsfz5tosg7yhtz7tpb5iv3q5pnc7rb/spack-src/doc/scipy-sphinx-theme/_theme/scipy/static/img/glyphicons-halflings.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.16.4-rddsfz5tosg7yhtz7tpb5iv3q5pnc7rb/spack-src/doc/scipy-sphinx-theme/_theme/scipy/static/img/glyphicons-halflings-white.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.16.4-rddsfz5tosg7yhtz7tpb5iv3q5pnc7rb/spack-src/doc/scipy-sphinx-theme/_static/scipyshiny_small.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.16.4-rddsfz5tosg7yhtz7tpb5iv3q5pnc7rb/spack-src/doc/source/dev/gitwash/forking_button.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.16.4-rddsfz5tosg7yhtz7tpb5iv3q5pnc7rb/spack-src/doc/source/dev/gitwash/pull_button.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.16.4-rddsfz5tosg7yhtz7tpb5iv3q5pnc7rb/spack-src/doc/source/reference/figures/dtype-hierarchy.dia",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.16.4-rddsfz5tosg7yhtz7tpb5iv3q5pnc7rb/spack-src/doc/source/reference/figures/dtype-hierarchy.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.16.4-rddsfz5tosg7yhtz7tpb5iv3q5pnc7rb/spack-src/doc/source/reference/figures/dtype-hierarchy.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.16.4-rddsfz5tosg7yhtz7tpb5iv3q5pnc7rb/spack-src/doc/source/reference/figures/threefundamental.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.16.4-rddsfz5tosg7yhtz7tpb5iv3q5pnc7rb/spack-src/doc/source/reference/figures/threefundamental.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.16.4-rddsfz5tosg7yhtz7tpb5iv3q5pnc7rb/spack-src/doc/source/user/theory.broadcast_4.gif",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.16.4-rddsfz5tosg7yhtz7tpb5iv3q5pnc7rb/spack-src/doc/source/user/theory.broadcast_3.gif",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.16.4-rddsfz5tosg7yhtz7tpb5iv3q5pnc7rb/spack-src/doc/source/user/theory.broadcast_1.gif",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.16.4-rddsfz5tosg7yhtz7tpb5iv3q5pnc7rb/spack-src/doc/source/user/theory.broadcast_5.png",
        "/tmp/vanessa/spack-stage/spack-stage-py-numpy-1.16.4-rddsfz5tosg7yhtz7tpb5iv3q5pnc7rb/spack-src/doc/source/user/theory.broadcast_2.gif"
    ],
    "total_files": 1129
}