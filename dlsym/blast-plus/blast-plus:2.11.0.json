{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/corelib/ncbifile.cpp": "/*  $Id: ncbifile.cpp 610319 2020-06-15 17:06:08Z ivanov $\n * ===========================================================================\n *\n *                            PUBLIC DOMAIN NOTICE\n *               National Center for Biotechnology Information\n *\n *  This software/database is a \"United States Government Work\" under the\n *  terms of the United States Copyright Act.  It was written as part of\n *  the author's official duties as a United States Government employee and\n *  thus cannot be copyrighted.  This software/database is freely available\n *  to the public for use. The National Library of Medicine and the U.S.\n *  Government have not placed any restriction on its use or reproduction.\n *\n *  Although all reasonable efforts have been taken to ensure the accuracy\n *  and reliability of the software and data, the NLM and the U.S.\n *  Government do not and cannot warrant the performance or results that\n *  may be obtained by using this software or data. The NLM and the U.S.\n *  Government disclaim all warranties, express or implied, including\n *  warranties of performance, merchantability or fitness for any particular\n *  purpose.\n *\n *  Please cite the author in any work or product based on this material.\n *\n * ===========================================================================\n *\n * Author:  Vladimir Ivanov\n *\n * File Description:   Files and directories accessory functions\n *\n */\n\n#include <ncbi_pch.hpp>\n#include <corelib/ncbifile.hpp>\n#include <corelib/ncbi_limits.h>\n#include <corelib/ncbi_limits.hpp>\n#include <corelib/ncbi_safe_static.hpp>\n#include <corelib/error_codes.hpp>\n#include <corelib/ncbierror.hpp>\n\n#include <stdio.h>\n\n#if defined(NCBI_OS_MSWIN)\n#  include \"ncbi_os_mswin_p.hpp\"\n#  include <direct.h>\n#  include <io.h>\n#  include <fcntl.h> // for _O_* flags\n#  include <sys/utime.h>\n\n#elif defined(NCBI_OS_UNIX)\n#  include \"ncbi_os_unix_p.hpp\"\n#  include <corelib/impl/ncbi_panfs.h>\n#  include <dirent.h>\n#  include <fcntl.h>\n#  include <unistd.h>\n#  include <utime.h>\n#  include <sys/mman.h>\n#  include <sys/time.h>\n#  ifdef HAVE_SYS_STATVFS_H\n#    include <sys/statvfs.h>\n#  endif\n#  include <sys/param.h>\n#  ifdef HAVE_SYS_MOUNT_H\n#    include <sys/mount.h>\n#  endif\n#  ifdef HAVE_SYS_VFS_H\n#    include <sys/vfs.h>\n#  endif\n#  if !defined(MAP_FAILED)\n#    define MAP_FAILED ((void *)(-1L))\n#  endif\n#  include <sys/ioctl.h>\n\n#else\n#  error \"File API defined for MS Windows and UNIX platforms only\"\n\n#endif  /* NCBI_OS_MSWIN, NCBI_OS_UNIX */\n\n\n// Define platforms on which we support PANFS\n#if defined(NCBI_OS_UNIX)  &&  !defined(NCBI_OS_CYGWIN)\n#  define SUPPORT_PANFS\n#  include <sys/types.h>\n#  include <sys/wait.h>\n#endif\n\n\n#define NCBI_USE_ERRCODE_X   Corelib_File\n\n\nBEGIN_NCBI_SCOPE\n\n\n// Path separators\n\n#undef  DIR_SEPARATOR\n#undef  DIR_SEPARATOR_ALT\n#undef  DIR_SEPARATORS\n#undef  DISK_SEPARATOR\n#undef  ALL_SEPARATORS\n#undef  ALL_OS_SEPARATORS\n\n#define DIR_PARENT  \"..\"\n#define DIR_CURRENT \".\"\n#define ALL_OS_SEPARATORS   \":/\\\\\"\n\n#if defined(NCBI_OS_MSWIN)\n#  define DIR_SEPARATOR     '\\\\'\n#  define DIR_SEPARATOR_ALT '/'\n#  define DISK_SEPARATOR    ':'\n#  define DIR_SEPARATORS    \"/\\\\\"\n#  define ALL_SEPARATORS    \":/\\\\\"\n#elif defined(NCBI_OS_UNIX)\n#  define DIR_SEPARATOR     '/'\n#  define DIR_SEPARATORS    \"/\"\n#  define ALL_SEPARATORS    \"/\"\n#endif\n\n// Macro to check bits\n#define F_ISSET(flags, mask) ((flags & (mask)) == (mask))\n\n// Default buffer size, used to read/write files\nconst size_t kDefaultBufferSize = 64*1024;\n\n// List of files for CFileDeleteAtExit class\nstatic CSafeStatic< CFileDeleteList > s_DeleteAtExitFileList;\n\n\n// Declare the parameter to get directory for temporary files.\n// Registry file:\n//     [NCBI]\n//     TmpDir = ...\n// Environment variable:\n//     NCBI_CONFIG__NCBI__TmpDir\n//\nNCBI_PARAM_DECL(string, NCBI, TmpDir); \nNCBI_PARAM_DEF (string, NCBI, TmpDir, \"\");\n\n\n// Define how read-only files are treated on Windows.\n// Registry file:\n//     [NCBI]\n//     DeleteReadOnlyFiles = true/false\n// Environment variable:\n//     NCBI_CONFIG__DELETEREADONLYFILES\n//\nNCBI_PARAM_DECL(bool, NCBI, DeleteReadOnlyFiles);\nNCBI_PARAM_DEF_EX(bool, NCBI, DeleteReadOnlyFiles, false,\n    eParam_NoThread, NCBI_CONFIG__DELETEREADONLYFILES);\n\n\n// Declare how umask settings on Unix affect creating files/directories \n// in the File API.\n// Registry file:\n//     [NCBI]\n//     FileAPIHonorUmask = true/false\n// Environment variable:\n//     NCBI_CONFIG__FILEAPIHONORUMASK\n//\n// On WINDOWS: umask affect only CRT function, the part of API that\n// use Windows API directly just ignore umask setting.\n#define DEFAULT_HONOR_UMASK_VALUE false\n\nNCBI_PARAM_DECL(bool, NCBI, FileAPIHonorUmask);\nNCBI_PARAM_DEF_EX(bool, NCBI, FileAPIHonorUmask, DEFAULT_HONOR_UMASK_VALUE,\n    eParam_NoThread, NCBI_CONFIG__FILEAPIHONORUMASK);\n\n\n// Declare the parameter to turn on logging from CFile,\n// CDirEntry, etc. classes.\n// Registry file:\n//     [NCBI]\n//     FileAPILogging = true/false\n// Environment variable:\n//     NCBI_CONFIG__FILEAPILOGGING\n//\n#define DEFAULT_LOGGING_VALUE false\n\nNCBI_PARAM_DECL(bool, NCBI, FileAPILogging);\nNCBI_PARAM_DEF_EX(bool, NCBI, FileAPILogging, DEFAULT_LOGGING_VALUE,\n    eParam_NoThread, NCBI_CONFIG__FILEAPILOGGING);\n\n\n// NOTE:\n//\n// Some common and very often used methods like\n//    CDirEntry::GetType()\n//    CDirEntry::Exists()\n// don't use LOG_ERROR* to report errors, and just set an error codes to CNcbiError.\n\n// Report error without error code.\n// Used when error code is unknown, or in conjunction with methods\n// that already report errors and codes itself.\n#define LOG_ERROR(subcode, log_message) \\\n    { \\\n        if (NCBI_PARAM_TYPE(NCBI, FileAPILogging)::GetDefault()) { \\\n            ERR_POST_X(subcode, log_message); \\\n        } \\\n    }\n\n// Report general NCBI error\n#define LOG_ERROR_NCBI(subcode, log_message, ncbierr) \\\n    { \\\n        CNcbiError::Set(ncbierr, log_message); \\\n        if (NCBI_PARAM_TYPE(NCBI, FileAPILogging)::GetDefault()) { \\\n            ERR_POST_X(subcode, log_message); \\\n        } \\\n    }\n\n// Report Windows API error.\n// Should be called immediately after failed Windows API call.\n#define LOG_ERROR_WIN(subcode, log_message) \\\n    { \\\n        CNcbiError::SetFromWindowsError(log_message); \\\n        if (NCBI_PARAM_TYPE(NCBI, FileAPILogging)::GetDefault()) { \\\n            ERR_POST_X(subcode, log_message); \\\n        } \\\n    }\n\n// Report errno-based error.\n// Should be called immediately after system call.\n#define LOG_ERROR_ERRNO(subcode, log_message) \\\n    { \\\n        int saved_error = errno; \\\n        CNcbiError::SetErrno(saved_error, log_message); \\\n        if (NCBI_PARAM_TYPE(NCBI, FileAPILogging)::GetDefault()) { \\\n            ERR_POST_X(subcode, log_message << \": \" << _T_STDSTRING(NcbiSys_strerror(saved_error))); \\\n        } \\\n        errno = saved_error; \\\n    }\n    \n// Macro to silence GCC's __wur (warn unused result)\n#define _no_warning(expr)  while ( expr ) break\n\n// Get an error string for last error on Windows\n#define WIN_LAST_ERROR_STR CLastErrorAdapt::GetErrCodeString(::GetLastError())\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CDirEntry\n//\n\nCDirEntry::CDirEntry(const string& name)\n{\n    Reset(name);\n    m_DefaultMode[eUser]    = m_DefaultModeGlobal[eFile][eUser];\n    m_DefaultMode[eGroup]   = m_DefaultModeGlobal[eFile][eGroup];\n    m_DefaultMode[eOther]   = m_DefaultModeGlobal[eFile][eOther];\n    m_DefaultMode[eSpecial] = m_DefaultModeGlobal[eFile][eSpecial];\n}\n\n\nCDirEntry::CDirEntry(const CDirEntry& other)\n    : m_Path(other.m_Path)\n{\n    m_DefaultMode[eUser]    = other.m_DefaultMode[eUser];\n    m_DefaultMode[eGroup]   = other.m_DefaultMode[eGroup];\n    m_DefaultMode[eOther]   = other.m_DefaultMode[eOther];\n    m_DefaultMode[eSpecial] = other.m_DefaultMode[eSpecial];\n}\n\n\nCDirEntry::~CDirEntry(void)\n{\n    return;\n}\n\n\nCDirEntry* CDirEntry::CreateObject(EType type, const string& path)\n{\n    CDirEntry *ptr;\n    switch ( type ) {\n        case eFile:\n            ptr = new CFile(path);\n            break;\n        case eDir:\n            ptr = new CDir(path);\n            break;\n        case eLink:\n            ptr = new CSymLink(path);\n            break;\n        default:\n            ptr = new CDirEntry(path);\n            break;\n    }\n    return ptr;\n}\n\n\nvoid CDirEntry::Reset(const string& path)\n{\n    m_Path = path;\n    size_t len = path.length();\n    // Root dir\n    if ((len == 1)  &&  IsPathSeparator(path[0])) {\n        return;\n    }\n    // Disk name\n#  if defined(DISK_SEPARATOR)\n    if ( (len == 2 || len == 3) && (path[1] == DISK_SEPARATOR) ) {\n        return;\n    }\n#  endif\n    m_Path = DeleteTrailingPathSeparator(path);\n}\n\n\nCDirEntry::TMode CDirEntry::m_DefaultModeGlobal[eUnknown][4] =\n{\n    // eFile\n    { CDirEntry::fDefaultUser, CDirEntry::fDefaultGroup, CDirEntry::fDefaultOther, 0 },\n    // eDir\n    { CDirEntry::fDefaultDirUser, CDirEntry::fDefaultDirGroup, CDirEntry::fDefaultDirOther, 0 },\n    // ePipe\n    { CDirEntry::fDefaultUser, CDirEntry::fDefaultGroup, CDirEntry::fDefaultOther, 0 },\n    // eLink\n    { CDirEntry::fDefaultUser, CDirEntry::fDefaultGroup, CDirEntry::fDefaultOther, 0 },\n    // eSocket\n    { CDirEntry::fDefaultUser, CDirEntry::fDefaultGroup, CDirEntry::fDefaultOther, 0 },\n    // eDoor\n    { CDirEntry::fDefaultUser, CDirEntry::fDefaultGroup, CDirEntry::fDefaultOther, 0 },\n    // eBlockSpecial\n    { CDirEntry::fDefaultUser, CDirEntry::fDefaultGroup, CDirEntry::fDefaultOther, 0 },\n    // eCharSpecial\n    { CDirEntry::fDefaultUser, CDirEntry::fDefaultGroup, CDirEntry::fDefaultOther, 0 }\n};\n\n\n// Default backup suffix\nconst char* CDirEntry::m_BackupSuffix = \".bak\";\n\n// Part of the temporary name used for \"safe copy\"\nstatic const char* kTmpSafeSuffix = \".tmp.\";\n\n\n\nCDirEntry& CDirEntry::operator= (const CDirEntry& other)\n{\n    if (this != &other) {\n        m_Path                  = other.m_Path;\n        m_DefaultMode[eUser]    = other.m_DefaultMode[eUser];\n        m_DefaultMode[eGroup]   = other.m_DefaultMode[eGroup];\n        m_DefaultMode[eOther]   = other.m_DefaultMode[eOther];\n        m_DefaultMode[eSpecial] = other.m_DefaultMode[eSpecial];\n    }\n    return *this;\n}\n\n\nvoid CDirEntry::SplitPath(const string& path, string* dir,\n                          string* base, string* ext)\n{\n    // Get file name\n    size_t pos = path.find_last_of(ALL_SEPARATORS);\n    string filename = (pos == NPOS) ? path : path.substr(pos+1);\n\n    // Get dir\n    if ( dir ) {\n        *dir = (pos == NPOS) ? kEmptyStr : path.substr(0, pos+1);\n    }\n    // Split file name to base and extension\n    pos = filename.rfind('.');\n    if ( base ) {\n        *base = (pos == NPOS) ? filename : filename.substr(0, pos);\n    }\n    if ( ext ) {\n        *ext = (pos == NPOS) ? kEmptyStr : filename.substr(pos);\n    }\n}\n\n\nvoid CDirEntry::SplitPathEx(const string& path,\n                            string* disk, string* dir,\n                            string* base, string* ext)\n{\n    size_t start_pos = 0;\n\n    // Get disk\n    if ( disk ) {\n        if ( isalpha((unsigned char)path[0])  &&  path[1] == ':' ) {\n            *disk = path.substr(0, 2);\n            start_pos = 2;\n        } else {\n            *disk = kEmptyStr;\n        }\n    }\n    // Get file name\n    size_t pos = path.find_last_of(ALL_OS_SEPARATORS);\n    string filename = (pos == NPOS) ? path : path.substr(pos+1);\n    // Get dir\n    if ( dir ) {\n        *dir = (pos == NPOS) ? kEmptyStr : path.substr(start_pos, pos - start_pos + 1);\n    }\n    // Split file name to base and extension\n    pos = filename.rfind('.');\n    if ( base ) {\n        *base = (pos == NPOS) ? filename : filename.substr(0, pos);\n    }\n    if ( ext ) {\n        *ext = (pos == NPOS) ? kEmptyStr : filename.substr(pos);\n    }\n}\n\n\nstring CDirEntry::MakePath(const string& dir, const string& base, \n                           const string& ext)\n{\n    string path;\n\n    // Adding \"dir\" and file base\n    if ( dir.length() ) {\n        path = AddTrailingPathSeparator(dir);\n    }\n    path += base;\n    // Adding extension\n    if ( ext.length()  &&  ext.at(0) != '.' ) {\n        path += '.';\n    }\n    path += ext;\n    // Return result\n    return path;\n}\n\n\nchar CDirEntry::GetPathSeparator(void) \n{\n    return DIR_SEPARATOR;\n}\n\n\nbool CDirEntry::IsPathSeparator(const char c)\n{\n#if defined(DISK_SEPARATOR)\n    if ( c == DISK_SEPARATOR ) {\n        return true;\n    }\n#endif\n#if defined(DIR_SEPARATOR_ALT)\n    if ( c == DIR_SEPARATOR_ALT ) {\n        return true;\n    }\n#endif\n    return c == DIR_SEPARATOR;\n}\n\n\nstring CDirEntry::AddTrailingPathSeparator(const string& path)\n{\n    size_t len = path.length();\n    if (len  &&  string(ALL_SEPARATORS).rfind(path.at(len - 1)) == NPOS) {\n        return path + GetPathSeparator();\n    }\n    return path;\n}\n\n\nstring CDirEntry::DeleteTrailingPathSeparator(const string& path)\n{\n    size_t pos = path.find_last_not_of(DIR_SEPARATORS);\n    if (pos + 1 < path.length()) {\n        return path.substr(0, pos + 1);\n    }\n    return path;\n}\n\n\nstring CDirEntry::GetDir(EIfEmptyPath mode) const\n{\n    string dir;\n    SplitPath(GetPath(), &dir);\n    if ( dir.empty()  &&  mode == eIfEmptyPath_Current  &&  !GetPath().empty() ) {\n        return string(DIR_CURRENT) + DIR_SEPARATOR;\n    }\n    return dir;\n}\n\n\n// Windows: \ninline bool s_Win_IsDiskPath(const string& path)\n{\n    if ((isalpha((unsigned char)path[0]) && path[1] == ':')  &&\n         (path[2] == '/' || path[2] == '\\\\')) {\n        return true;\n    }\n    return false;\n}\n\n// Windows: \ninline bool s_Win_IsNetworkPath(const string& path)\n{\n    // Any combination of slashes in 2 first symbols\n    if ((path[0] == '\\\\' || path[0] == '/')  &&\n        (path[1] == '\\\\' || path[1] == '/')) {\n        return true;\n    }\n    return false;\n}\n\n\nbool CDirEntry::IsAbsolutePath(const string& path)\n{\n    if (path.empty()) {\n        return false;\n    }\n#if defined(NCBI_OS_MSWIN)\n    if (s_Win_IsDiskPath(path) || s_Win_IsNetworkPath(path)) {\n        return true;\n    }\n#elif defined(NCBI_OS_UNIX)\n    if ( path[0] == '/' ) {\n        return true;\n    }\n#endif\n    return false;\n}\n\n\nbool CDirEntry::IsAbsolutePathEx(const string& path)\n{\n    if ( path.empty() )\n        return false;\n\n    // Windows: \n    if (s_Win_IsDiskPath(path) || s_Win_IsNetworkPath(path)) {\n        return true;\n    }\n    // Unix\n    if (path[0] == '/') {\n        // FIXME:\n        // This is an Unix absolute path or MS Windows relative.\n        // But Unix have favor here, because '/' is native dir separator.\n        return true;\n    }\n    // Else - relative\n    return false;\n}\n\n\nstring CDirEntry::GetNearestExistingParentDir(const string& path)\n{\n    CDirEntry entry(NormalizePath(path));\n\n    // Find closest existing directory\n    while (!entry.Exists()) {\n        string dir = entry.GetDir();\n        if (dir.empty()) {\n            NCBI_THROW(CFileException, eNotExists,\n                       \"Failed to find existing containing directory for: \" + entry.GetPath());\n        }\n        entry.Reset(dir);\n    }\n    return entry.GetPath();\n}\n\n\n/// Helper -- strips dir to parts:\n///     c:\\a\\b\\     will be <c:><a><b>\n///     /usr/bin/   will be </><usr><bin>\nstatic void s_StripDir(const string& dir, vector<string> * dir_parts)\n{\n    dir_parts->clear();\n    if (dir.empty()) {\n        return;\n    }\n    const char sep = CDirEntry::GetPathSeparator();\n\n    size_t sep_pos = 0;\n    size_t last_ind = dir.length() - 1;\n    size_t part_start = 0;\n    for (;;) {\n        sep_pos = dir.find(sep, sep_pos);\n        if (sep_pos == NPOS) {\n            dir_parts->push_back(string(dir, part_start, dir.length() - part_start));\n            break;\n        }\n        // If path starts from '/' - it's a root directory\n        if (sep_pos == 0) {\n            dir_parts->push_back(string(1, sep));\n        } else {\n            dir_parts->push_back(string(dir, part_start, sep_pos - part_start));\n        }\n        sep_pos++;\n        part_start = sep_pos;\n        if (sep_pos >= last_ind) {\n            break;\n        }\n    }\n}\n\n\nstring CDirEntry::CreateRelativePath( const string& path_from, \n                                      const string& path_to )\n{\n    string path; // the result    \n    \n    if ( !IsAbsolutePath(path_from) ) {\n        NCBI_THROW(CFileException, eRelativePath, \"path_from is not absolute path\");\n    }\n\n    if ( !IsAbsolutePath(path_to) ) {\n        NCBI_THROW(CFileException, eRelativePath, \"path_to is not absolute path\");\n    }\n\n    // Split and strip FROM\n    string dir_from;\n    SplitPath(AddTrailingPathSeparator(path_from), &dir_from);\n    vector<string> dir_from_parts;\n    s_StripDir(dir_from, &dir_from_parts);\n    if ( dir_from_parts.empty() ) {\n        NCBI_THROW(CFileException, eRelativePath, \"path_from is empty path\");\n    }\n\n    // Split and strip TO\n    string dir_to, base_to, ext_to;\n    SplitPath(path_to, &dir_to, &base_to, &ext_to);    \n    vector<string> dir_to_parts;\n    s_StripDir(dir_to, &dir_to_parts);\n    if ( dir_to_parts.empty() ) {\n        NCBI_THROW(CFileException, eRelativePath, \"path_to is empty path\");\n    }\n\n    // Platform-dependent compare mode\n#ifdef NCBI_OS_MSWIN\n#  define DIR_PARTS_CMP_MODE NStr::eNocase\n#else /*NCBI_OS_UNIX*/\n#  define DIR_PARTS_CMP_MODE NStr::eCase\n#endif\n    // Roots must be the same to create relative path from one to another\n\n    if (NStr::Compare(dir_from_parts.front(), \n                      dir_to_parts.front(), \n                      DIR_PARTS_CMP_MODE) != 0) {\n        NCBI_THROW(CFileException, eRelativePath, \"roots of input paths are different\");\n    }\n\n    size_t min_parts = min(dir_from_parts.size(), dir_to_parts.size());\n    size_t common_length = min_parts;\n    for (size_t i = 0; i < min_parts; i++) {\n        if (NStr::Compare(dir_from_parts[i], dir_to_parts[i], DIR_PARTS_CMP_MODE) != 0) {\n            common_length = i;\n            break;\n        }\n    }\n    for (size_t i = common_length; i < dir_from_parts.size(); i++) {\n        path += \"..\";\n        path += GetPathSeparator();\n    }\n    for (size_t i = common_length; i < dir_to_parts.size(); i++) {\n        path += dir_to_parts[i];\n        path += GetPathSeparator();\n    }\n    \n    return path + base_to + ext_to;\n}\n\n\nstring CDirEntry::CreateAbsolutePath(const string& path, ERelativeToWhat rtw)\n{\n    if ( IsAbsolutePath(path) ) {\n        return NormalizePath(path);\n    }\n    string result;\n\n#if defined(NCBI_OS_MSWIN)\n    if ( path.find(DISK_SEPARATOR) != NPOS ) {\n        NCBI_THROW(CFileException, eRelativePath, \n                   \"Path must not contain disk separator: \" + path);\n    }\n    // Path started with slash\n    if (!path.empty() && (path[0] == '/' || path[0] == '\\\\')) {\n        // network path ?\n        if ( s_Win_IsNetworkPath(path) ) {\n            NCBI_THROW(CFileException, eRelativePath,\n                       \"Cannot use network path: \" + path);\n        }\n        // relative to current drive only\n        if (rtw != eRelativeToCwd) {\n            NCBI_THROW(CFileException, eRelativePath,\n                       \"Path can be used as relative to current drive only: \" + path);\n        }\n        return CDir::GetCwd().substr(0,3) + path;\n    }\n#endif\n\n    switch (rtw) {\n        case eRelativeToCwd:\n            result = ConcatPath(CDir::GetCwd(), path);\n            break;\n        case eRelativeToExe:\n          {\n            string dir;\n            SplitPath(CNcbiApplication::GetAppName(CNcbiApplication::eFullName), &dir);\n            result = ConcatPath(dir, path);\n            if ( !CDirEntry(result).Exists() ) {\n                SplitPath(CNcbiApplication::GetAppName(CNcbiApplication::eRealName), &dir);\n                result = ConcatPath(dir, path);\n            }\n            break;\n          }\n    }\n    return NormalizePath(result);\n}\n\n\nstring CDirEntry::CreateAbsolutePath(const string& path, const string& rtw)\n{\n    if ( IsAbsolutePath(path) ) {\n        return NormalizePath(path);\n    }\n\n#if defined(NCBI_OS_MSWIN)\n    if ( path.find(DISK_SEPARATOR) != NPOS ) {\n        NCBI_THROW(CFileException, eRelativePath, \n                   \"Path must not contain disk separator: \" + path);\n    }\n    // Path started with slash\n    if (!path.empty() && (path[0] == '/' || path[0] == '\\\\')) {\n        // network path ?\n        if ( s_Win_IsNetworkPath(path) ) {\n            NCBI_THROW(CFileException, eRelativePath,\n                       \"Cannot use network path: \" + path);\n        }\n        // relative to current drive only -- error\n        NCBI_THROW(CFileException, eRelativePath,\n                    \"Path can be used as relative to current drive only: \" + path);\n    }\n#endif\n\n    if ( !IsAbsolutePath(rtw) ) {\n        NCBI_THROW(CFileException, eRelativePath,\n                   \"2nd parameter must represent absolute path: \" + rtw);\n    }\n    return NormalizePath(ConcatPath(rtw, path));\n}\n\n\nstring CDirEntry::ConvertToOSPath(const string& path)\n{\n    // Not process empty or absolute path\n    if ( path.empty()  ||  IsAbsolutePathEx(path)) {\n        return NormalizePath(path);\n    }\n    // Now we have relative \"path\"\n    string xpath = path;\n    // Add trailing separator if path ends with DIR_PARENT or DIR_CURRENT\n#if defined(DIR_PARENT)\n    if ( NStr::EndsWith(xpath, DIR_PARENT) )  {\n        xpath += DIR_SEPARATOR;\n    }\n#endif\n#if defined(DIR_CURRENT)\n    if ( NStr::EndsWith(xpath, DIR_CURRENT) )  {\n        xpath += DIR_SEPARATOR;\n    }\n#endif\n    // Replace each path separator with the current OS separator character\n    for (size_t i = 0; i < xpath.length(); i++) {\n        char c = xpath[i];\n        if ( c == '\\\\' || c == '/' ) {\n            xpath[i] = DIR_SEPARATOR;\n        }\n    }\n    xpath = NormalizePath(xpath);\n    return xpath;\n}\n\n\nstring CDirEntry::ConcatPath(const string& first, const string& second)\n{\n    // Prepare first part of path\n    string path = AddTrailingPathSeparator(NStr::TruncateSpaces(first));\n    // Remove leading separator in \"second\" part\n    string part = NStr::TruncateSpaces(second);\n    if ( !path.empty()  &&  part.length() > 0  &&  part[0] == DIR_SEPARATOR ) {\n        part.erase(0,1);\n    }\n    // Add second part\n    path += part;\n    return path;\n}\n\n\nstring CDirEntry::ConcatPathEx(const string& first, const string& second)\n{\n    // Prepare first part of path\n    string path = NStr::TruncateSpaces(first);\n\n    // Add trailing path separator to first part (OS independence)\n\n    size_t pos = path.length();\n    if ( pos  &&  string(ALL_OS_SEPARATORS).find(path.at(pos-1)) == NPOS ) {\n        // Find used path separator\n        char sep = GetPathSeparator();\n        size_t sep_pos = path.find_last_of(ALL_OS_SEPARATORS);\n        if ( sep_pos != NPOS ) {\n            sep = path.at(sep_pos);\n        }\n        path += sep;\n    }\n    // Remove leading separator in \"second\" part\n    string part = NStr::TruncateSpaces(second);\n    if ( part.length() > 0  &&\n         string(ALL_OS_SEPARATORS).find(part[0]) != NPOS ) {\n        part.erase(0,1);\n    }\n    // Add second part\n    path += part;\n    return path;\n}\n\n\nstring CDirEntry::NormalizePath(const string& path, EFollowLinks follow_links)\n{\n    if ( path.empty() ) {\n        return path;\n    }\n    static const char kSep[] = { DIR_SEPARATOR, '\\0' };\n\n    std::list<string> head;       // already resolved to our satisfaction\n    std::list<string> tail;       // to resolve afterwards\n    string  current;              // to resolve next\n    int     link_depth = 0;\n\n    // Delete trailing slash for all paths except similar to 'd:\\'\n#  ifdef DISK_SEPARATOR\n    if ( path.find(DISK_SEPARATOR) == NPOS ) {\n        current = DeleteTrailingPathSeparator(path);\n    } else {\n        current = path;\n    }\n#  else\n    current = DeleteTrailingPathSeparator(path);\n#  endif\n\n    if ( current.empty() ) {\n        // root dir\n        return string(1, DIR_SEPARATOR);\n    }\n\n#ifdef NCBI_OS_MSWIN\n    NStr::ReplaceInPlace(current, \"/\", \"\\\\\");\n#endif\n\n    while ( !current.empty()  ||  !tail.empty() ) {\n        std::list<string> pretail;\n        if ( !current.empty() ) {\n            NStr::Split(current, kSep, pretail);\n            current.erase();\n            if (pretail.front().empty()\n#ifdef DISK_SEPARATOR\n                ||  pretail.front().find(DISK_SEPARATOR) != NPOS\n#endif\n                ) {\n                // Absolute path\n                head.clear();\n#ifdef NCBI_OS_MSWIN\n                // Remove leading \"\\\\?\\\". Replace leading \"\\\\?\\UNC\\\" with \"\\\\\".\n                static const char* const kUNC[] = { \"\", \"\", \"?\", \"UNC\" };\n                std::list<string>::iterator it = pretail.begin();\n                unsigned int matched = 0;\n                while (matched < 4  &&  it != pretail.end()\n                       &&  !NStr::CompareNocase(*it, kUNC[matched])) {\n                    ++it;\n                    ++matched;\n                }\n                pretail.erase(pretail.begin(), it);\n                switch (matched) {\n                case 2: case 4: // got a UNC path (\\\\... or \\\\?\\UNC\\...)\n                    head.push_back(kEmptyStr);\n                    // fall through\n                case 1:         // normal volume-less absolute path\n                    head.push_back(kEmptyStr);\n                    break;\n                case 3/*?*/:    // normal path, absolute or relative\n                    break;\n                }\n#endif\n            }\n            tail.splice(tail.begin(), pretail);\n        }\n\n        string next;\n        if (!tail.empty()) {\n            next = tail.front();\n            tail.pop_front();\n        }\n        if ( !head.empty() ) { // empty heads should accept anything\n            string& last = head.back();\n            if (last == DIR_CURRENT) {\n                if (!next.empty()) {\n                    head.pop_back();\n                }\n#ifdef DISK_SEPARATOR\n            } else if (!last.empty() && last[last.size()-1] == DISK_SEPARATOR) {\n                // Allow almost anything right after a volume specification\n#endif\n            } else if (next == DIR_CURRENT) {\n                // Leave out, since we already have content\n                continue;\n            } else if (next.empty()) {\n                continue; // leave out empty components in most cases\n            } else if (next == DIR_PARENT) {\n#ifdef DISK_SEPARATOR\n                SIZE_TYPE pos;\n#endif\n                // Back up if possible, assuming existing path to be \"physical\"\n                if (last.empty()) {\n                    // Already at the root; .. is a no-op\n                    continue;\n#ifdef DISK_SEPARATOR\n                } else if ((pos = last.find(DISK_SEPARATOR) != NPOS)) {\n                    last.erase(pos + 1);\n#endif\n                } else if (last != DIR_PARENT) {\n                    head.pop_back();\n                    continue;\n                }\n            }\n        }\n#ifdef NCBI_OS_UNIX\n        // Is there a Windows equivalent for readlink?\n        if ( follow_links ) {\n            string s(head.empty() ? next : NStr::Join(head, string(1, DIR_SEPARATOR)) + DIR_SEPARATOR + next);\n            char buf[PATH_MAX];\n            int  length = (int)readlink(s.c_str(), buf, sizeof(buf));\n            if (length > 0) {\n                current.assign(buf, length);\n                if (++link_depth >= 1024) {\n                    ERR_POST_X(1, Warning << \"CDirEntry::NormalizePath(): \"\n                               \"Reached symlink depth limit \" <<\n                               link_depth << \" when resolving \" << path);\n                    CNcbiError::Set(CNcbiError::eTooManySymbolicLinkLevels);\n                    follow_links = eIgnoreLinks;\n                }\n                continue;\n            }\n        }\n#endif\n        // Normal case: just append the next element to head\n        head.push_back(next);\n    }\n\n    // Special cases\n    if ( (head.size() == 0)  ||\n         (head.size() == 2  &&  head.front() == DIR_CURRENT  &&  head.back().empty()) ) {\n        // current dir\n        return DIR_CURRENT;\n    }\n    if (head.size() == 1  &&  head.front().empty()) {\n        // root dir\n        return string(1, DIR_SEPARATOR);\n    }\n#ifdef DISK_SEPARATOR\n    if (head.front().find(DISK_SEPARATOR) != NPOS) {\n        if ((head.size() == 2  &&  head.back() == DIR_CURRENT) || \n            (head.size() == 3  &&  *(++head.begin()) == DIR_CURRENT  &&  head.back().empty()) ) {\n            // root dir on drive X:\n            return head.front() + DIR_SEPARATOR;\n        }\n    }\n#endif\n    // Compose path\n    return NStr::Join(head, string(1, DIR_SEPARATOR));\n}\n\n\nbool CDirEntry::GetMode(TMode* user_mode, TMode* group_mode,\n                        TMode* other_mode, TSpecialModeBits* special) const\n{\n    TNcbiSys_stat st;\n    if (NcbiSys_stat(_T_XCSTRING(GetPath()), &st) != 0) {\n        LOG_ERROR_ERRNO(5, \"CDirEntry::GetMode(): stat() failed for: \" + GetPath());\n        return false;\n    }\n    ModeFromModeT(st.st_mode, user_mode, group_mode, other_mode, special);\n    return true;\n}\n\n\n// Auxiliary macro to set/clear/replace current permissions\n\n#define UPDATE_PERMS(mode, perms) \\\n    { \\\n        _ASSERT( !F_ISSET(perms, fModeNoChange | fModeAdd)    ); \\\n        _ASSERT( !F_ISSET(perms, fModeNoChange | fModeRemove) ); \\\n        _ASSERT( !F_ISSET(perms, fModeAdd      | fModeRemove) ); \\\n        \\\n        if ( perms & fModeNoChange ) { \\\n            \\\n        } else  \\\n        if ( perms & fModeAdd ) { \\\n            mode |= perms; \\\n        } else  \\\n        if ( perms & fModeRemove ) { \\\n            mode &= ~perms; \\\n        } \\\n        else { \\\n            mode = perms; \\\n        } \\\n        /* clear auxiliary bits */ \\\n        mode &= ~(fDefault | fModeAdd | fModeRemove | fModeNoChange); \\\n    }\n\n\nbool CDirEntry::SetMode(TMode user_mode, TMode group_mode,\n                        TMode other_mode, TSpecialModeBits special_mode,\n                        TSetModeFlags flags) const\n{\n    // Assumption\n    _ASSERT(eEntryOnly == fEntry);\n\n    // Is this a directory ? (and processing not entry only)\n    if ( (flags & (fDir_All | fDir_Recursive)) != eEntryOnly  &&  IsDir(eIgnoreLinks) ) {\n        return CDir(GetPath()).SetMode(user_mode, group_mode, other_mode, special_mode, flags);\n    }\n    // Other entries\n    return SetModeEntry(user_mode, group_mode, other_mode, special_mode, flags);\n}\n\n\nbool CDirEntry::SetModeEntry(TMode user_mode, TMode group_mode,\n                             TMode other_mode, TSpecialModeBits special_mode,\n                             TSetModeFlags flags) const\n{\n    // Check on defaults modes\n    if (user_mode & fDefault) {\n        user_mode = m_DefaultMode[eUser];\n    }\n    if (group_mode & fDefault) {\n        group_mode = m_DefaultMode[eGroup];\n    }\n    if (other_mode & fDefault) {\n        other_mode = m_DefaultMode[eOther];\n    }\n    if (special_mode == 0) {\n        special_mode = m_DefaultMode[eSpecial];\n    }\n    \n    TMode user  = 0;\n    TMode group = 0;\n    TMode other = 0;\n    TSpecialModeBits special = 0;\n    TMode relative_mask = fModeNoChange | fModeAdd | fModeRemove;\n\n    // relative permissions\n    \n    if ( (user_mode    & relative_mask) ||\n         (group_mode   & relative_mask) ||\n         (other_mode   & relative_mask) ||\n         (special_mode & relative_mask) ) {\n\n        TNcbiSys_stat st;\n        if (NcbiSys_stat(_T_XCSTRING(GetPath()), &st) != 0) {\n            if ( (flags & fIgnoreMissing)  &&  (errno == ENOENT) ) {\n                return true;\n            }\n            LOG_ERROR_ERRNO(6, \"CDirEntry::SetModeEntry(): stat() failed for: \" + GetPath());\n            return false;\n        }\n        ModeFromModeT(st.st_mode, &user, &group, &other);\n    }\n    \n    UPDATE_PERMS(user,    user_mode);\n    UPDATE_PERMS(group,   group_mode);\n    UPDATE_PERMS(other,   other_mode);\n    UPDATE_PERMS(special, special_mode);\n   \n    // change permissions\n    \n    mode_t mode = MakeModeT(user, group, other, special);\n\n    if ( NcbiSys_chmod(_T_XCSTRING(GetPath()), mode) != 0 ) {\n        if ( (flags & fIgnoreMissing)  &&  (errno == ENOENT) ) {\n            return true;\n        }\n        LOG_ERROR_ERRNO(7, \"CDirEntry::SetModeEntry(): chmod() failed for: \" + GetPath());\n        return false;\n    }\n    return true;\n}\n\n\nvoid CDirEntry::SetDefaultModeGlobal(EType entry_type, TMode user_mode, \n                                     TMode group_mode, TMode other_mode,\n                                     TSpecialModeBits special)\n{\n    if ( entry_type >= eUnknown ) {\n        return;\n    }\n    if ( entry_type == eDir ) {\n        if ( user_mode == fDefault ) {\n            user_mode = fDefaultDirUser;\n        }\n        if ( group_mode == fDefault ) {\n            group_mode = fDefaultDirGroup;\n        }\n        if ( other_mode == fDefault ) {\n            other_mode = fDefaultDirOther;\n        }\n    } else {\n        if ( user_mode == fDefault ) {\n            user_mode = fDefaultUser;\n        }\n        if ( group_mode == fDefault ) {\n            group_mode = fDefaultGroup;\n        }\n        if ( other_mode == fDefault ) {\n            other_mode = fDefaultOther;\n        }\n    }\n    if ( special == 0 ) {\n        special = m_DefaultModeGlobal[entry_type][eSpecial];\n    }\n    m_DefaultModeGlobal[entry_type][eUser]    = user_mode;\n    m_DefaultModeGlobal[entry_type][eGroup]   = group_mode;\n    m_DefaultModeGlobal[entry_type][eOther]   = other_mode;\n    m_DefaultModeGlobal[entry_type][eSpecial] = special;\n}\n\n\nvoid CDirEntry::SetDefaultMode(EType entry_type, TMode user_mode, \n                               TMode group_mode, TMode other_mode,\n                               TSpecialModeBits special)\n{\n    if ( user_mode == fDefault ) {\n        user_mode  = m_DefaultModeGlobal[entry_type][eUser];\n    }\n    if ( group_mode == fDefault ) {\n        group_mode = m_DefaultModeGlobal[entry_type][eGroup];\n    }\n    if ( other_mode == fDefault ) {\n        other_mode = m_DefaultModeGlobal[entry_type][eOther];\n    }\n    if ( special == 0 ) {\n        special = m_DefaultModeGlobal[entry_type][eSpecial];\n    }\n    m_DefaultMode[eUser]    = user_mode;\n    m_DefaultMode[eGroup]   = group_mode;\n    m_DefaultMode[eOther]   = other_mode;\n    m_DefaultMode[eSpecial] = special;\n}\n\n\nvoid CDirEntry::GetDefaultModeGlobal(EType  entry_type, TMode* user_mode,\n                                     TMode* group_mode, TMode* other_mode,\n                                     TSpecialModeBits* special)\n{\n    if ( user_mode ) {\n        *user_mode  = m_DefaultModeGlobal[entry_type][eUser];\n    }\n    if ( group_mode ) {\n        *group_mode = m_DefaultModeGlobal[entry_type][eGroup];\n    }\n    if ( other_mode ) {\n        *other_mode = m_DefaultModeGlobal[entry_type][eOther];\n    }\n    if ( special ) {\n        *special  = m_DefaultModeGlobal[entry_type][eSpecial];\n    }\n}\n\n\nvoid CDirEntry::GetDefaultMode(TMode* user_mode, TMode* group_mode,\n                               TMode* other_mode,\n                               TSpecialModeBits* special) const\n{\n    if ( user_mode ) {\n        *user_mode  = m_DefaultMode[eUser];\n    }\n    if ( group_mode ) {\n        *group_mode = m_DefaultMode[eGroup];\n    }\n    if ( other_mode ) {\n        *other_mode = m_DefaultMode[eOther];\n    }\n    if ( special ) {\n        *special   = m_DefaultMode[eSpecial];\n    }\n}\n\n\nmode_t CDirEntry::MakeModeT(TMode user_mode, TMode group_mode,\n                            TMode other_mode, TSpecialModeBits special)\n{\n    mode_t mode = (\n    // special bits\n#ifdef S_ISUID\n                   (special & fSetUID     ? S_ISUID  : 0) |\n#endif\n#ifdef S_ISGID\n                   (special & fSetGID     ? S_ISGID  : 0) |\n#endif\n#ifdef S_ISVTX\n                   (special & fSticky     ? S_ISVTX  : 0) |\n#endif\n    // modes\n#if   defined(S_IRUSR)\n                   (user_mode & fRead     ? S_IRUSR  : 0) |\n#elif defined(S_IREAD) \n                   (user_mode & fRead     ? S_IREAD  : 0) |\n#endif\n#if   defined(S_IWUSR)\n                   (user_mode & fWrite    ? S_IWUSR  : 0) |\n#elif defined(S_IWRITE)\n                   (user_mode & fWrite    ? S_IWRITE : 0) |\n#endif\n#if   defined(S_IXUSR)\n                   (user_mode & fExecute  ? S_IXUSR  : 0) |\n#elif defined(S_IEXEC)\n                   (user_mode & fExecute  ? S_IEXEC  : 0) |\n#endif\n#ifdef S_IRGRP\n                   (group_mode & fRead    ? S_IRGRP  : 0) |\n#endif\n#ifdef S_IWGRP\n                   (group_mode & fWrite   ? S_IWGRP  : 0) |\n#endif\n#ifdef S_IXGRP\n                   (group_mode & fExecute ? S_IXGRP  : 0) |\n#endif\n#ifdef S_IROTH\n                   (other_mode & fRead    ? S_IROTH  : 0) |\n#endif\n#ifdef S_IWOTH\n                   (other_mode & fWrite   ? S_IWOTH  : 0) |\n#endif\n#ifdef S_IXOTH\n                   (other_mode & fExecute ? S_IXOTH  : 0) |\n#endif\n                   0);\n    return mode;\n}\n\n\nvoid CDirEntry::ModeFromModeT(mode_t mode, \n                              TMode* user_mode, TMode* group_mode, \n                              TMode* other_mode, TSpecialModeBits* special)\n{\n    // Owner\n    if (user_mode) {\n        *user_mode = (\n#if   defined(S_IRUSR)\n                     (mode & S_IRUSR  ? fRead    : 0) |\n#elif defined(S_IREAD)\n                     (mode & S_IREAD  ? fRead    : 0) |\n#endif\n#if   defined(S_IWUSR)\n                     (mode & S_IWUSR  ? fWrite   : 0) |\n#elif defined(S_IWRITE)\n                     (mode & S_IWRITE ? fWrite   : 0) |\n#endif\n#if   defined(S_IXUSR)\n                     (mode & S_IXUSR  ? fExecute : 0) |\n#elif defined(S_IEXEC)\n                     (mode & S_IEXEC  ? fExecute : 0) |\n#endif\n                     0);\n    }\n\n#ifdef NCBI_OS_MSWIN\n    if (group_mode) *group_mode = 0;\n    if (other_mode) *other_mode = 0;\n    if (special)    *special    = 0;\n\n#else\n    // Group\n    if (group_mode) {\n        *group_mode = (\n#ifdef S_IRGRP\n                     (mode & S_IRGRP  ? fRead    : 0) |\n#endif\n#ifdef S_IWGRP\n                     (mode & S_IWGRP  ? fWrite   : 0) |\n#endif\n#ifdef S_IXGRP\n                     (mode & S_IXGRP  ? fExecute : 0) |\n#endif\n                     0);\n    }\n    // Others\n    if (other_mode) {\n        *other_mode = (\n#ifdef S_IROTH\n                     (mode & S_IROTH  ? fRead    : 0) |\n#endif\n#ifdef S_IWOTH\n                     (mode & S_IWOTH  ? fWrite   : 0) |\n#endif\n#ifdef S_IXOTH\n                     (mode & S_IXOTH  ? fExecute : 0) |\n#endif\n                     0);\n    }\n    // Special bits\n    if (special) {\n        *special = (\n#ifdef S_ISUID\n                    (mode & S_ISUID   ? fSetUID  : 0) |\n#endif\n#ifdef S_ISGID\n                    (mode & S_ISGID   ? fSetGID  : 0) |\n#endif\n#ifdef S_ISVTX\n                    (mode & S_ISVTX   ? fSticky  : 0) |\n#endif\n                    0);\n    }\n#endif // NCBI_OS_MSWIN\n}\n\n\n// Convert permission mode to \"rw[xsStT]\" string.\nstring CDirEntry::x_ModeToSymbolicString(CDirEntry::EWho who, CDirEntry::TMode mode, bool special_bit, char filler)\n{\n    string out;\n    out.reserve(3);\n\n    char c;\n    c = (mode & CDirEntry::fRead  ? 'r' : filler);\n    if (c) {\n        out += c;\n    }\n    c = (mode & CDirEntry::fWrite ? 'w' : filler);\n    if (c) {\n        out += c;\n    }\n    c = filler;\n    if ( special_bit ) {\n        if (who == CDirEntry::eOther) {\n            c = (mode & CDirEntry::fExecute) ? 't' : 'T';\n        } else {\n            c = (mode & CDirEntry::fExecute) ? 's' : 'S';\n        }\n    } else if (mode & CDirEntry::fExecute) {\n        c = 'x';\n    }\n    if (c) {\n        out += c;\n    }\n    return out;\n}\n\n\nstring CDirEntry::ModeToString(TMode user_mode, TMode group_mode, \n                               TMode other_mode, TSpecialModeBits special,\n                               EModeStringFormat format)\n{\n    string out;\n    switch (format) {\n    case eModeFormat_Octal:\n        {\n            int i = 0;\n            if (special > 0) {\n                out = \"0000\";\n                out[0] = char(special + '0');\n                i++;\n            } else {\n                out = \"000\";\n            }\n            out[i++] = char(user_mode  + '0');\n            out[i++] = char(group_mode + '0');\n            out[i++] = char(other_mode + '0');\n        }\n        break;\n    case eModeFormat_Symbolic:\n        {\n            out.reserve(17);\n            out =   \"u=\" + x_ModeToSymbolicString(eUser,  user_mode,  (special & fSetUID) > 0, '\\0');\n            out += \",g=\" + x_ModeToSymbolicString(eGroup, group_mode, (special & fSetGID) > 0, '\\0');\n            out += \",o=\" + x_ModeToSymbolicString(eOther, other_mode, (special & fSticky) > 0, '\\0');\n        }\n        break;\n    case eModeFormat_List:\n        {\n            out.reserve(9);\n            out =  x_ModeToSymbolicString(eUser,  user_mode,  (special & fSetUID) > 0, '-');\n            out += x_ModeToSymbolicString(eGroup, group_mode, (special & fSetGID) > 0, '-');\n            out += x_ModeToSymbolicString(eOther, other_mode, (special & fSticky) > 0, '-');\n        }\n        break;\n    default:\n        _TROUBLE;\n    }\n\n    return out;\n}\n\n\nbool CDirEntry::StringToMode(const CTempString& mode, \n                             TMode* user_mode, TMode* group_mode, \n                             TMode* other_mode, TSpecialModeBits* special)\n{\n    if ( mode.empty() ) {\n        CNcbiError::Set(CNcbiError::eInvalidArgument);\n        return false;\n    }\n    if ( isdigit((unsigned char)(mode[0])) ) {\n        // eModeFormat_Octal\n        unsigned int oct = NStr::StringToUInt(mode, NStr::fConvErr_NoThrow, 8);\n        if ((oct > 07777) || (!oct  &&  errno != 0)) {\n            CNcbiError::Set(CNcbiError::eInvalidArgument, mode);\n            return false;\n        }\n        if (other_mode) {\n            *other_mode = TMode(oct & 7);\n        }\n        oct >>= 3;\n        if (group_mode) {\n            *group_mode = TMode(oct & 7);\n        }\n        oct >>= 3;\n        if (user_mode) {\n            *user_mode = TMode(oct & 7);\n        }\n        if (special) {\n            oct >>= 3;\n            *special = TSpecialModeBits(oct);\n        }\n\n    } else {\n\n        if (user_mode) \n            *user_mode = 0;\n        if (group_mode)\n            *group_mode = 0;\n        if (other_mode)\n            *other_mode = 0;\n        if (special)\n            *special = 0;\n\n        // eModeFormat_List:\n        if (mode.find('=') == NPOS  &&  mode.length() == 9) {\n            for (int i = 0; i < 3; i++) {\n                TMode m = 0;\n                bool is_special = false;\n\n                switch (mode[i*3]) {\n                    case 'r':\n                        m |= fRead;\n                        break;\n                    case '-':\n                        break;\n                    default:\n                        CNcbiError::Set(CNcbiError::eInvalidArgument, mode);\n                        return false;\n                }\n                switch (mode[i*3 + 1]) {\n                    case 'w':\n                        m |= fWrite;\n                        break;\n                    case '-':\n                        break;\n                    default:\n                        CNcbiError::Set(CNcbiError::eInvalidArgument, mode);\n                        return false;\n                }\n                switch (mode[i*3 + 2]) {\n                    case 'S':\n                    case 'T':\n                        is_special = true;\n                        break;\n                    case 's':\n                    case 't':\n                        is_special = true;\n                        // fall through\n                    case 'x':\n                        m |= fExecute;\n                        break;\n                    case '-':\n                        break;\n                    default:\n                        CNcbiError::Set(CNcbiError::eInvalidArgument, mode);\n                        return false;\n                }\n                switch (i) {\n                    case 0: // user\n                        if (user_mode) \n                            *user_mode = m;\n                        if (is_special  &&  special)\n                            *special |= fSetUID;\n                        break;\n                    case 1: // group\n                        if (group_mode)\n                            *group_mode = m;\n                        if (is_special  &&  special)\n                            *special |= fSetGID;\n                        break;\n                    case 2: // other\n                        if (other_mode)\n                            *other_mode = m;\n                        if (is_special  &&  special)\n                            *special |= fSticky;\n                        break;\n                }\n            }\n\n        // eModeFormat_Symbolic\n        } else {\n            std::list<string> parts;\n            NStr::Split(mode, \",\", parts, NStr::fSplit_MergeDelimiters | NStr::fSplit_Truncate);\n            if ( parts.empty() ) {\n                CNcbiError::Set(CNcbiError::eInvalidArgument, mode);\n                return false;\n            }\n            bool have_user  = false;\n            bool have_group = false;\n            bool have_other = false;\n\n            ITERATE(std::list<string>, it, parts) {\n                string accessor, perm;\n                if ( !NStr::SplitInTwo(*it, \"=\", accessor, perm) ) {\n                    CNcbiError::Set(CNcbiError::eInvalidArgument, mode);\n                    return false;\n                }\n                TMode m = 0;\n                bool is_special = false;\n                // Permission mode(s) (rwx)\n                ITERATE(string, s, perm) {\n                    switch(char(*s)) {\n                    case 'r':\n                        m |= fRead;\n                        break;\n                    case 'w':\n                        m |= fWrite;\n                        break;\n                    case 'S':\n                    case 'T':\n                        is_special = true;\n                        break;\n                    case 's':\n                    case 't':\n                        is_special = true;\n                        // fall through\n                    case 'x':\n                        m |= fExecute;\n                        break;\n                    default:\n                       CNcbiError::Set(CNcbiError::eInvalidArgument, mode);\n                       return false;\n                    }\n                }\n                // Permission group category (ugoa)\n                ITERATE(string, s, accessor) {\n                    switch(char(*s)) {\n                    case 'u':\n                        if (have_user) {\n                            CNcbiError::Set(CNcbiError::eInvalidArgument, mode);\n                            return false;\n                        }\n                        if (user_mode)\n                            *user_mode = m;\n                        if (is_special  &&  special)\n                            *special |= fSetUID;\n                        have_user = true;\n                        break;\n                    case 'g':\n                        if (have_group) {\n                            CNcbiError::Set(CNcbiError::eInvalidArgument, mode);\n                            return false;\n                        }\n                        if (group_mode)\n                            *group_mode = m;\n                        if (is_special  &&  special)\n                            *special |= fSetGID;\n                        have_group = true;\n                        break;\n                    case 'o':\n                        if (have_other) {\n                            CNcbiError::Set(CNcbiError::eInvalidArgument, mode);\n                            return false;\n                        }\n                        if (other_mode)\n                            *other_mode = m;\n                        if (is_special  &&  special)\n                            *special |= fSticky;\n                        have_other = true;\n                        break;\n                    case 'a':\n                        if (is_special || have_user || have_group || have_other) {\n                            CNcbiError::Set(CNcbiError::eInvalidArgument, mode);\n                            return false;\n                        }\n                        have_user  = true;\n                        have_group = true;\n                        have_other = true;\n                        if (user_mode)\n                            *user_mode = m;\n                        if (group_mode)\n                            *group_mode = m;\n                        if (other_mode)\n                            *other_mode = m;\n                        break;\n                    default:\n                        CNcbiError::Set(CNcbiError::eInvalidArgument, mode);\n                        return false;\n                    }\n                }\n            }\n        }\n\n    }\n    return true;\n}\n\n\nvoid CDirEntry::GetUmask(TMode* user_mode, TMode* group_mode, \n                         TMode* other_mode, TSpecialModeBits* special)\n{\n#ifdef HAVE_GETUMASK\n    mode_t mode = getumask();\n#else\n    mode_t mode = NcbiSys_umask(0);\n    NcbiSys_umask(mode);\n#endif //HAVE_GETUMASK\n    ModeFromModeT(mode, user_mode, group_mode, other_mode, special);\n}\n\n\nvoid CDirEntry::SetUmask(TMode user_mode, TMode group_mode, \n                         TMode other_mode, TSpecialModeBits special)\n{\n    mode_t mode = MakeModeT((user_mode  == fDefault) ? 0 : user_mode,\n                            (group_mode == fDefault) ? 0 : group_mode,\n                            (other_mode == fDefault) ? 0 : other_mode,\n                            special);\n    NcbiSys_umask(mode);\n}\n\n\n#if defined(NCBI_OS_UNIX) && !defined(HAVE_EUIDACCESS) && !defined(EFF_ONLY_OK)\n\nstatic bool s_CheckAccessStat(struct stat* p, int mode)\n{\n    const struct stat& st = *p;\n    uid_t uid = geteuid();\n\n    // Check user permissions\n    if (uid == st.st_uid) {\n        return (!(mode & R_OK)  ||  (st.st_mode & S_IRUSR))  &&\n               (!(mode & W_OK)  ||  (st.st_mode & S_IWUSR))  &&\n               (!(mode & X_OK)  ||  (st.st_mode & S_IXUSR));\n    }\n\n    // Initialize list of group IDs for effective user\n    int ngroups = 0;\n    gid_t gids[NGROUPS_MAX + 1];\n    gids[0] = getegid();\n    ngroups = getgroups((int)(sizeof(gids)/sizeof(gids[0])) - 1, gids + 1);\n    if (ngroups < 0) {\n        ngroups = 1;\n    } else {\n        ngroups++;\n    }\n    for (int i = 1;  i < ngroups;  i++) {\n        if (gids[i] == uid) {\n            if (i < --ngroups) {\n                memmove(&gids[i], &gids[i + 1], sizeof(gids[0])*(ngroups-i));\n            }\n            break;\n        }\n    }\n    // Check group permissions\n    for (int i = 0;  i < ngroups;  i++) {\n        if (gids[i] == st.st_gid) {\n            return  (!(mode & R_OK)  ||  (st.st_mode & S_IRGRP))  &&\n                    (!(mode & W_OK)  ||  (st.st_mode & S_IWGRP))  &&\n                    (!(mode & X_OK)  ||  (st.st_mode & S_IXGRP));\n        }\n    }\n    // Check other permissions\n    if ( (!(mode & R_OK)  ||  (st.st_mode & S_IROTH))  &&\n         (!(mode & W_OK)  ||  (st.st_mode & S_IWOTH))  &&\n         (!(mode & X_OK)  ||  (st.st_mode & S_IXOTH)) ) {\n        return true;\n    }\n\n    // Permissions not granted\n    return false;\n}\n\n\nstatic bool s_CheckAccessPath(const char* path, int mode)\n{\n    if (!path) {\n        errno = 0;\n        CNcbiError::Set(CNcbiError::eInvalidArgument);\n        return false;\n    }\n    if (!*path) {\n        CNcbiError::SetErrno(errno = ENOENT, path);\n        return false;\n    }\n    struct stat st;\n    if (stat(path, &st) != 0) {\n        CNcbiError::SetFromErrno(path);\n        return false;\n    }\n    if (!s_CheckAccessStat(&st, mode)) {\n        CNcbiError::SetErrno(errno = EACCES, path);\n        return false;\n    }\n    // Permissions granted\n    return true;\n}\n\n#endif  // defined(NCBI_OS_UNIX)\n\n\nbool CDirEntry::CheckAccess(TMode access_mode) const\n{\n#if defined(NCBI_OS_MSWIN)\n    // Try to get effective access rights on this file object for\n    // the current process owner.\n    ACCESS_MASK mask = 0;\n    if ( CWinSecurity::GetFilePermissions(GetPath(), &mask) ) {\n        TMode perm = ( (mask & FILE_READ_DATA  ? fRead    : 0) |\n                       (mask & FILE_WRITE_DATA ? fWrite   : 0) |\n                       (mask & FILE_EXECUTE    ? fExecute : 0) );\n        return (access_mode & perm) > 0;\n     }\n     return false;\n\n#elif defined(NCBI_OS_UNIX)\n    const char* path = GetPath().c_str();\n    int         mode = F_OK;\n\n    if ( access_mode & fRead)    mode |= R_OK;\n    if ( access_mode & fWrite)   mode |= W_OK;\n    if ( access_mode & fExecute) mode |= X_OK;\n    \n    // Use euidaccess() where possible\n#  if defined(HAVE_EUIDACCESS)\n    if (euidaccess(path, mode) != 0) {\n        CNcbiError::SetFromErrno(path);\n        return false;\n    }\n    return true;\n\n#  elif defined(EFF_ONLY_OK)\n    // Some Unix have special flag for access() to use effective user ID.\n    mode |= EFF_ONLY_OK;\n    if (access(path, mode) != 0) {\n        CNcbiError::SetFromErrno(path);\n        return false;\n    }\n    return true;\n\n#  else\n    // We can use access() only if effective and real user/group IDs are equal.\n    // access() operate with real IDs only, but we should check access\n    // for effective IDs.\n    if (getuid() == geteuid()  &&  getgid() == getegid()) {\n        if (access(path, mode) != 0) {\n            CNcbiError::SetFromErrno(path);\n            return false;\n        }\n        return true;\n    }\n    // Otherwise, try to check permissions itself.\n    // Note, that this function is not perfect, it doesn't work with ACL,\n    // which implementation can differ for each platform.\n    // But in most cases it works.\n    return s_CheckAccessPath(path, mode);\n\n#  endif\n#endif // NCBI_OS\n}\n\n\n#ifdef NCBI_OS_MSWIN\n\nbool s_FileTimeToCTime(const FILETIME& filetime, CTime& t) \n{\n    // Clear time object\n    t.Clear();\n\n    if ( !filetime.dwLowDateTime  &&  !filetime.dwHighDateTime ) {\n        // File time is undefined, just return \"empty\" time\n        return true;\n    }\n    SYSTEMTIME system;\n    FILETIME   local;\n\n    // Convert the file time to local time\n    if ( !::FileTimeToLocalFileTime(&filetime, &local) ) {\n        CNcbiError::SetFromWindowsError();\n        return false;\n    }\n    // Convert the local file time from UTC to system time.\n    if ( !::FileTimeToSystemTime(&local, &system) ) {\n        CNcbiError::SetFromWindowsError();\n        return false;\n    }\n\n    // Construct new time\n    CTime newtime(system.wYear,\n                  system.wMonth,\n                  system.wDay,\n                  system.wHour,\n                  system.wMinute,\n                  system.wSecond,\n                  system.wMilliseconds * (kNanoSecondsPerSecond / kMilliSecondsPerSecond),\n                  CTime::eLocal,\n                  t.GetTimeZonePrecision());\n\n    // And assign it\n    if ( t.GetTimeZone() == CTime::eLocal ) {\n        t = newtime;\n    } else {\n        t = newtime.GetGmtTime();\n    }\n    return true;\n}\n\n\nvoid s_UnixTimeToFileTime(time_t t, long nanosec, FILETIME& filetime) \n{\n    // Note that LONGLONG is a 64-bit value\n    LONGLONG res;\n    // This algorithm was found in MSDN\n    res = Int32x32To64(t, 10000000) + 116444736000000000 + nanosec/100;\n    filetime.dwLowDateTime  = (DWORD)res;\n    filetime.dwHighDateTime = (DWORD)(res >> 32);\n}\n\n#endif // NCBI_OS_MSWIN\n\n\nbool CDirEntry::GetTime(CTime* modification,\n                        CTime* last_access,\n                        CTime* creation) const\n{\n#ifdef NCBI_OS_MSWIN\n    HANDLE handle;\n    WIN32_FIND_DATA buf;\n\n    // Get file times using FindFile\n    handle = ::FindFirstFile(_T_XCSTRING(GetPath()), &buf);\n    if ( handle == INVALID_HANDLE_VALUE ) {\n        LOG_ERROR_WIN(8, \"CDirEntry::GetTime(): Cannot find: \" + GetPath());\n        return false;\n    }\n    ::FindClose(handle);\n\n    // Convert file UTC times into CTime format\n    if ( modification  &&\n        !s_FileTimeToCTime(buf.ftLastWriteTime, *modification) ) {\n        LOG_ERROR(9, \"CDirEntry::GetTime(): Cannot get modification time for: \" + GetPath());\n        return false;\n    }\n    if ( last_access  &&\n         !s_FileTimeToCTime(buf.ftLastAccessTime, *last_access) ) {\n        LOG_ERROR(9, \"CDirEntry::GetTime(): Cannot get access time for: \" + GetPath());\n        return false;\n    }\n    if ( creation  &&\n        !s_FileTimeToCTime(buf.ftCreationTime, *creation) ) {\n        LOG_ERROR(9, \"CDirEntry::GetTime(): Cannot get creation time for: \" + GetPath());\n        return false;\n    }\n    return true;\n\n#else // NCBI_OS_UNIX\n\n    struct SStat st;\n    if ( !Stat(&st) ) {\n        LOG_ERROR(8, \"CDirEntry::GetTime(): Cannot get time for: \" + GetPath());\n        return false;\n    }\n    if ( modification ) {\n        modification->SetTimeT(st.orig.st_mtime);\n        if ( st.mtime_nsec )\n            modification->SetNanoSecond(st.mtime_nsec);\n    }\n    if ( last_access ) {\n        last_access->SetTimeT(st.orig.st_atime);\n        if ( st.atime_nsec )\n            last_access->SetNanoSecond(st.atime_nsec);\n    }\n    if ( creation ) {\n        creation->SetTimeT(st.orig.st_ctime);\n        if ( st.ctime_nsec )\n            creation->SetNanoSecond(st.ctime_nsec);\n    }\n    return true;\n#endif\n}\n\n\nbool CDirEntry::SetTime(const CTime* modification,\n                        const CTime* last_access,\n                        const CTime* creation) const\n{\n#ifdef NCBI_OS_MSWIN\n    if ( !modification  &&  !last_access  &&  !creation ) {\n        return true;\n    }\n\n    FILETIME   x_modification,        x_last_access,        x_creation;\n    LPFILETIME p_modification = NULL, p_last_access = NULL, p_creation = NULL;\n\n    // Convert times to FILETIME format\n    if ( modification ) {\n        s_UnixTimeToFileTime(modification->GetTimeT(), modification->NanoSecond(), x_modification);\n        p_modification = &x_modification;\n    }\n    if ( last_access ) {\n        s_UnixTimeToFileTime(last_access->GetTimeT(), last_access->NanoSecond(), x_last_access);\n        p_last_access = &x_last_access;\n    }\n    if ( creation ) {\n        s_UnixTimeToFileTime(creation->GetTimeT(), creation->NanoSecond(), x_creation);\n        p_creation = &x_creation;\n    }\n\n    // Change times\n    HANDLE h = ::CreateFile(_T_XCSTRING(GetPath()), FILE_WRITE_ATTRIBUTES,\n                            FILE_SHARE_READ, NULL, OPEN_EXISTING,\n                            FILE_FLAG_BACKUP_SEMANTICS /*for dirs*/, NULL); \n    if ( h == INVALID_HANDLE_VALUE ) {\n        LOG_ERROR_WIN(10, \"CDirEntry::SetTime(): Cannot open: \" + GetPath());\n        return false;\n    }\n    if ( !::SetFileTime(h, p_creation, p_last_access, p_modification) ) {\n        LOG_ERROR_WIN(11, \"CDirEntry::SetTime(): Cannot set new time for: \" + GetPath());\n        ::CloseHandle(h);\n        return false;\n    }\n    ::CloseHandle(h);\n\n    return true;\n\n#else // NCBI_OS_UNIX\n\n    // Creation time doesn't used on Unix\n    creation = NULL;  /* DUMMY, to avoid warnings */\n\n    if ( !modification  &&  !last_access  /*&&  !creation*/ ) {\n        return true;\n    }\n\n#  ifdef HAVE_UTIMES\n    // Get current times\n    CTime x_modification, x_last_access;\n\n    if ( !modification  ||  !last_access ) {\n        if ( !GetTime(modification ? NULL : &x_modification,\n                      last_access  ? NULL : &x_last_access,\n                      NULL /* creation */) ) {\n            return false;\n        }\n        if (!modification) {\n            modification = &x_modification;\n        } else {\n            last_access = &x_last_access;\n        }\n    }\n\n    // Change times\n    struct timeval tvp[2];\n    tvp[0].tv_sec  = last_access->GetTimeT();\n    tvp[0].tv_usec = last_access->NanoSecond() / (kNanoSecondsPerSecond / kMicroSecondsPerSecond);\n    tvp[1].tv_sec  = modification->GetTimeT();\n    tvp[1].tv_usec = modification->NanoSecond() / (kNanoSecondsPerSecond / kMicroSecondsPerSecond);\n\n#    ifdef HAVE_LUTIMES\n    bool ut_res = lutimes(GetPath().c_str(), tvp) == 0;\n#    else\n    bool ut_res = utimes(GetPath().c_str(), tvp) == 0;\n#    endif\n    if ( !ut_res ) {\n        LOG_ERROR_ERRNO(12, \"CDirEntry::SetTime(): Cannot change time for: \" + GetPath());\n        return false;\n    }\n    return true;\n\n# else\n    // utimes() does not exist on current platform,\n    // so use less accurate utime().\n\n    // Get current times\n    time_t x_modification, x_last_access;\n\n    if ((!modification  ||  !last_access)\n        &&  !GetTimeT(&x_modification, &x_last_access, NULL /* creation */)) {\n        LOG_ERROR(12, \"CDirEntry::SetTime(): Cannot get current time for: \" + GetPath());\n        return false;\n    }\n\n    // Change times to new\n    struct utimbuf times;\n    times.modtime  = modification ? modification->GetTimeT() : x_modification;\n    times.actime   = last_access  ? last_access->GetTimeT()  : x_last_access;\n    if ( utime(GetPath().c_str(), &times) != 0 ) {\n        LOG_ERROR_ERRNO(12, \"CDirEntry::SetTime(): Cannot change time for: \" + GetPath());\n        return false;\n    }\n    return true;\n\n#  endif // HAVE_UTIMES\n\n#endif\n}\n\n\nbool CDirEntry::GetTimeT(time_t* modification,\n                         time_t* last_access,\n                         time_t* creation) const\n{\n    TNcbiSys_stat st;\n    if (NcbiSys_stat(_T_XCSTRING(GetPath()), &st) != 0) {\n        LOG_ERROR_ERRNO(13, \"CDirEntry::GetTimeT(): stat() failed for: \" + GetPath());\n        return false;\n    }\n    if ( modification ) {\n        *modification = st.st_mtime;\n    }\n    if ( last_access ) {\n        *last_access = st.st_atime;\n    }\n    if ( creation ) {\n        *creation = st.st_ctime;\n    }\n    return true;\n}\n\n\nbool CDirEntry::SetTimeT(const time_t* modification,\n                         const time_t* last_access,\n                         const time_t* creation) const\n{\n#ifdef NCBI_OS_MSWIN\n    if ( !modification  &&  !last_access  &&  !creation ) {\n        return true;\n    }\n\n    FILETIME   x_modification,        x_last_access,        x_creation;\n    LPFILETIME p_modification = NULL, p_last_access = NULL, p_creation = NULL;\n\n    // Convert times to FILETIME format\n    if ( modification ) {\n        s_UnixTimeToFileTime(*modification, 0, x_modification);\n        p_modification = &x_modification;\n    }\n    if ( last_access ) {\n        s_UnixTimeToFileTime(*last_access, 0, x_last_access);\n        p_last_access = &x_last_access;\n    }\n    if ( creation ) {\n        s_UnixTimeToFileTime(*creation, 0, x_creation);\n        p_creation = &x_creation;\n    }\n\n    // Change times\n    HANDLE h = ::CreateFile(_T_XCSTRING(GetPath()), FILE_WRITE_ATTRIBUTES,\n                            FILE_SHARE_READ, NULL, OPEN_EXISTING,\n                            FILE_FLAG_BACKUP_SEMANTICS /*for dirs*/, NULL); \n    if ( h == INVALID_HANDLE_VALUE ) {\n        LOG_ERROR_WIN(14, \"CDirEntry::SetTimeT(): Cannot open: \" + GetPath());\n        return false;\n    }\n    if ( !::SetFileTime(h, p_creation, p_last_access, p_modification) ) {\n        LOG_ERROR_WIN(15, \"CDirEntry::SetTimeT(): Cannot change time for: \" + GetPath());\n        ::CloseHandle(h);\n        return false;\n    }\n    ::CloseHandle(h);\n\n    return true;\n\n#else // NCBI_OS_UNIX\n\n    // Creation time doesn't used on Unix\n    creation = NULL;  /* DUMMY, to avoid warnings */\n\n    if ( !modification  &&  !last_access  /*&&  !creation*/ )\n        return true;\n\n    time_t x_modification, x_last_access;\n    if ((!modification  ||  !last_access)\n        &&  !GetTimeT(&x_modification, &x_last_access, NULL /* creation */) ) {\n          LOG_ERROR(15, \"CDirEntry::SetTimeT(): Cannot get current time for: \" + GetPath());\n          return false;\n    }\n\n    // Change times to new\n    struct utimbuf times;\n    times.modtime = modification ? *modification : x_modification;\n    times.actime  = last_access  ? *last_access  : x_last_access;\n    if ( utime(GetPath().c_str(), &times) != 0 ) {\n        LOG_ERROR_ERRNO(15, \"CDirEntry::SetTimeT(): Cannot change time for: \" + GetPath());\n        return false;\n    }\n    return true;\n\n#endif\n}\n\n\nbool CDirEntry::Stat(struct SStat *buffer, EFollowLinks follow_links) const\n{\n    if ( !buffer ) {\n        errno = EFAULT;\n        LOG_ERROR_ERRNO(16, \"CDirEntry::Stat(): NULL stat buffer passed for: \" + GetPath());\n        return false;\n    }\n    int errcode;\n#ifdef NCBI_OS_MSWIN\n    errcode = NcbiSys_stat(_T_XCSTRING(GetPath()), &buffer->orig);\n#else // NCBI_OS_UNIX\n    if (follow_links == eFollowLinks) {\n        errcode = stat(GetPath().c_str(), &buffer->orig);\n    } else {\n        errcode = lstat(GetPath().c_str(), &buffer->orig);\n    }\n#endif\n    if (errcode != 0) {\n        LOG_ERROR_ERRNO(16, \"CDirEntry::Stat(): stat() failed for: \" + GetPath());\n        return false;\n    }\n   \n    // Assign additional fields\n    buffer->atime_nsec = 0;\n    buffer->mtime_nsec = 0;\n    buffer->ctime_nsec = 0;\n    \n#ifdef NCBI_OS_UNIX\n    // UNIX:\n    // Some systems have additional fields in the stat structure to store\n    // nanoseconds. If you know one more platform which have nanoseconds\n    // support for file times, add it here.\n\n#  if !defined(__GLIBC_PREREQ)\n#    define __GLIBC_PREREQ(x, y) 0\n#  endif\n\n#  if defined(NCBI_OS_LINUX)  &&  __GLIBC_PREREQ(2,3)\n#    if defined(__USE_MISC)\n    buffer->atime_nsec = buffer->orig.st_atim.tv_nsec;\n    buffer->mtime_nsec = buffer->orig.st_mtim.tv_nsec;\n    buffer->ctime_nsec = buffer->orig.st_ctim.tv_nsec;\n#    else\n    buffer->atime_nsec = buffer->orig.st_atimensec;\n    buffer->mtime_nsec = buffer->orig.st_mtimensec;\n    buffer->ctime_nsec = buffer->orig.st_ctimensec;\n#    endif\n#  endif\n\n#  if defined(NCBI_OS_SOLARIS)\n#    if !defined(_XOPEN_SOURCE) && !defined(_POSIX_C_SOURCE) || \\\n     defined(__EXTENSIONS__)\n    buffer->atime_nsec = buffer->orig.st_atim.tv_nsec;\n    buffer->mtime_nsec = buffer->orig.st_mtim.tv_nsec;\n    buffer->ctime_nsec = buffer->orig.st_ctim.tv_nsec;\n#    else\n    buffer->atime_nsec = buffer->orig.st_atim.__tv_nsec;\n    buffer->mtime_nsec = buffer->orig.st_mtim.__tv_nsec;\n    buffer->ctime_nsec = buffer->orig.st_ctim.__tv_nsec;\n#    endif\n#  endif\n   \n#  if defined(NCBI_OS_BSD) || defined(NCBI_OS_DARWIN)\n#    if defined(_POSIX_SOURCE)\n    buffer->atime_nsec = buffer->orig.st_atimensec;\n    buffer->mtime_nsec = buffer->orig.st_mtimensec;\n    buffer->ctime_nsec = buffer->orig.st_ctimensec;\n#    else\n    buffer->atime_nsec = buffer->orig.st_atimespec.tv_nsec;\n    buffer->mtime_nsec = buffer->orig.st_mtimespec.tv_nsec;\n    buffer->ctime_nsec = buffer->orig.st_ctimespec.tv_nsec;\n#    endif\n#  endif\n\n#  if defined(NCBI_OS_IRIX)\n#    if defined(tv_sec)\n    buffer->atime_nsec = buffer->orig.st_atim.__tv_nsec;\n    buffer->mtime_nsec = buffer->orig.st_mtim.__tv_nsec;\n    buffer->ctime_nsec = buffer->orig.st_ctim.__tv_nsec;\n#    else\n    buffer->atime_nsec = buffer->orig.st_atim.tv_nsec;\n    buffer->mtime_nsec = buffer->orig.st_mtim.tv_nsec;\n    buffer->ctime_nsec = buffer->orig.st_ctim.tv_nsec;\n#    endif\n#  endif\n    \n#endif  // NCBI_OS_UNIX\n\n    return true;\n}\n\n\nCDirEntry::EType CDirEntry::GetType(EFollowLinks follow) const\n{\n    TNcbiSys_stat st;\n    int errcode;\n\n#if defined(NCBI_OS_MSWIN)\n    errcode = NcbiSys_stat(_T_XCSTRING(GetPath()), &st);\n    if (errcode != 0) {\n        // Make additional checks for UNC paths, because \n        // stat() cannot handle path that looks like \\\\Server\\Share.\n        if (s_Win_IsNetworkPath(GetPath())) {\n            DWORD attr = ::GetFileAttributes(_T_XCSTRING(GetPath()));\n            if (attr == INVALID_FILE_ATTRIBUTES) {\n                // Don't report an error here, just set CNcbiError.\n                // eUnknown is a legit return value.\n                CNcbiError::SetFromWindowsError(GetPath());\n                return eUnknown;\n            }\n            if ( F_ISSET(attr, FILE_ATTRIBUTE_DIRECTORY) ) {\n                return eDir;\n            }\n            return eFile;\n        }\n    }\n#else // NCBI_OS_UNIX\n    if (follow == eFollowLinks) {\n        errcode = stat(GetPath().c_str(), &st);\n    } else {\n        errcode = lstat(GetPath().c_str(), &st);\n    }\n#endif\n    if (errcode != 0) {\n        // Don't report an error here, just set CNcbiError.\n        // eUnknown is a legit return value.\n        CNcbiError::SetFromErrno(GetPath());\n        return eUnknown;\n    }\n    return GetType(st);\n}\n\n\n/// Test macro for file types\n#define NCBI_IS_TYPE(mode, mask)  (((mode) & S_IFMT) == (mask))\n\nCDirEntry::EType CDirEntry::GetType(const TNcbiSys_stat& st)\n{\n    unsigned int mode = (unsigned int)st.st_mode;\n\n#ifdef S_ISDIR\n    if (S_ISDIR(mode))\n#else\n    if (NCBI_IS_TYPE(mode, S_IFDIR))\n#endif\n        return eDir;\n\n#ifdef S_ISCHR\n    if (S_ISCHR(mode))\n#else\n    if (NCBI_IS_TYPE(mode, S_IFCHR))\n#endif\n        return eCharSpecial;\n\n#ifdef NCBI_OS_MSWIN\n    if (NCBI_IS_TYPE(mode, _S_IFIFO))\n        return ePipe;\n#else\n    // NCBI_OS_UNIX\n#  ifdef S_ISFIFO\n    if (S_ISFIFO(mode))\n#  else\n    if (NCBI_IS_TYPE(mode, S_IFIFO))\n#  endif\n        return ePipe;\n\n#  ifdef S_ISLNK\n    if (S_ISLNK(mode))\n#  else\n    if (NCBI_IS_TYPE(mode, S_IFLNK))\n#  endif\n        return eLink;\n\n#  ifdef S_ISSOCK\n    if (S_ISSOCK(mode))\n#  else\n    if (NCBI_IS_TYPE(mode, S_IFSOCK))\n#  endif\n        return eSocket;\n\n#  ifdef S_ISBLK\n    if (S_ISBLK(mode))\n#  else\n    if (NCBI_IS_TYPE(mode, S_IFBLK))\n#  endif\n        return eBlockSpecial;\n\n#  ifdef S_IFDOOR \n    // only Solaris seems to have this one\n#    ifdef S_ISDOOR\n    if (S_ISDOOR(mode))\n#    else\n    if (NCBI_IS_TYPE(mode, S_IFDOOR))\n#    endif\n        return eDoor;\n#  endif\n\n#endif //NCBI_OS_MSWIN\n\n    // Check on regular file last\n#ifdef S_ISREG\n    if (S_ISREG(mode))\n#else\n    if (NCBI_IS_TYPE(mode, S_IFREG))\n#endif\n        return eFile;\n\n    return eUnknown;\n}\n\n\n#if defined(NCBI_OS_MSWIN)\n\n// Windows-specific implementation. See default implementation in the .hpp file\nbool CDirEntry::Exists(void) const\n{\n    HANDLE h = ::CreateFile(_T_XCSTRING(GetPath()),\n                            GENERIC_READ, FILE_SHARE_READ | FILE_SHARE_WRITE, NULL,\n                            OPEN_EXISTING,\n                            FILE_FLAG_BACKUP_SEMANTICS /*for dirs*/, NULL);\n    if (h == INVALID_HANDLE_VALUE) {\n        // Don't report an error here, just set CNcbiError.\n        CNcbiError::SetFromWindowsError(GetPath());\n        return false;\n    }\n    ::CloseHandle(h);\n    return true;\n}\n\n#endif\n\n\nstring CDirEntry::LookupLink(void) const\n{\n#ifdef NCBI_OS_MSWIN\n    return kEmptyStr;\n\n#else  // NCBI_OS_UNIX\n    char buf[PATH_MAX];\n    string name;\n    int length = (int)readlink(_T_XCSTRING(GetPath()), buf, sizeof(buf));\n    if (length > 0) {\n        name.assign(buf, length);\n    }\n    return name;\n#endif\n}\n\n\nvoid CDirEntry::DereferenceLink(ENormalizePath normalize)\n{\n#ifdef NCBI_OS_MSWIN\n    // Not implemented\n    return;\n#endif\n    string prev;\n    while ( IsLink() ) {\n        string name = LookupLink();\n        if ( name.empty() ||  name == prev ) {\n            return;\n        }\n        prev = name;\n        if ( IsAbsolutePath(name) ) {\n            Reset(name);\n        } else {\n            string path = MakePath(GetDir(), name);\n            if (normalize == eNormalizePath) {\n                Reset(NormalizePath(path));\n            } else {\n                Reset(path);\n            }\n        }\n    }\n}\n\n\nvoid s_DereferencePath(CDirEntry& entry)\n{\n#ifdef NCBI_OS_MSWIN\n    // Not implemented\n    return;\n#endif\n    // Dereference each path components starting from last one\n    entry.DereferenceLink(eNotNormalizePath);\n\n    // Get dir and file names\n    string path = entry.GetPath();\n    size_t pos = path.find_last_of(ALL_SEPARATORS);\n    if (pos == NPOS) {\n        return; \n    }\n    string filename = path.substr(pos+1);\n    string dirname  = path.substr(0, pos);\n    if ( dirname.empty() ) {\n        return;\n    }\n    // Dereference path one level up\n    entry.Reset(dirname);\n    s_DereferencePath(entry);\n    // Create new path\n    entry.Reset(CDirEntry::MakePath(entry.GetPath(), filename));\n}\n\n\nvoid CDirEntry::DereferencePath(void)\n{\n#ifdef NCBI_OS_MSWIN\n    // Not implemented\n    return;\n#endif\n    // Use s_DereferencePath() recursively and normalize result only once\n    CDirEntry e(GetPath());\n    s_DereferencePath(e);\n    Reset(NormalizePath(e.GetPath()));\n}\n\n\nbool CDirEntry::Copy(const string& path, TCopyFlags flags, size_t buf_size)\n    const\n{\n    // Dereference link if specified\n    bool follow = F_ISSET(flags, fCF_FollowLinks);\n    EType type = GetType(follow ? eFollowLinks : eIgnoreLinks);\n    switch (type) {\n        case eFile:\n            return CFile(GetPath()).Copy(path, flags, buf_size);\n        case eDir: \n            return CDir(GetPath()).Copy(path, flags, buf_size);\n        case eLink:\n            return CSymLink(GetPath()).Copy(path, flags, buf_size);\n        case eUnknown:\n            {\n                CNcbiError::Set(CNcbiError::eNoSuchFileOrDirectory, GetPath());\n                return false;\n            }\n        default:\n            CNcbiError::Set(CNcbiError::eNotSupported, GetPath());\n            break;\n    }\n    // We \"don't know\" how to copy entry of other type, by default.\n    // Use overloaded Copy() method in derived classes.\n    return (flags & fCF_SkipUnsupported) == fCF_SkipUnsupported;\n}\n\n\nbool CDirEntry::Rename(const string& newname, TRenameFlags flags)\n{\n    CDirEntry src(*this);\n    CDirEntry dst(newname);\n\n    // Dereference links\n    if ( F_ISSET(flags, fRF_FollowLinks) ) {\n        src.DereferenceLink();\n        dst.DereferenceLink();\n    }\n    // The source entry must exists\n    EType src_type = src.GetType();\n    if ( src_type == eUnknown ) {\n        LOG_ERROR_NCBI(17, \"CDirEntry::Rename():\"\n                           \" Source path does not exist: \" + src.GetPath(),\n                           CNcbiError::eNoSuchFileOrDirectory);\n        return false;\n    }\n\n    // Try to \"move\" in one atomic operation if possible to avoid race\n    // conditions between check on destination existence and renaming.\n\n#ifdef NCBI_OS_MSWIN\n    // On Windows we can try to move file or whole directory, even across volumes\n    if ( ::MoveFileEx(_T_XCSTRING(src.GetPath()),\n                      _T_XCSTRING(dst.GetPath()), MOVEFILE_COPY_ALLOWED) ) {\n        Reset(newname);\n        return true;\n    }\n#else\n    // On Unix we can use \"link\" technique for files.\n    \n    // link() have different behavior on some flavors of Unix\n    // regarding symbolic links handling, and can automatically\n    // dereference both source and destination as POSIX required, \n    // or not (Linux with kernel 2.0 and up behavior).\n    // We need to rename symlink itself, if not dereferenced yet\n    // (see fRF_FollowLinks), and the destination should remain\n    // a symlink. So just dont use link() in this case and,\n    // fall back to regular rename() instead.\n    \n    if ( src_type == eFile  && \n         link(_T_XCSTRING(src.GetPath()),\n              _T_XCSTRING(dst.GetPath())) == 0 ) {\n        // Hard link successfully created, so we can just remove source file\n        if ( src.RemoveEntry() ) {\n            Reset(newname);\n            return true;\n        }\n    }\n#endif\n    // On error, symlink, or destination existence --\n    // continue on regular processing below\n\n    EType dst_type = dst.GetType();\n\n    // If destination exists...\n\n    if ( dst_type != eUnknown ) {\n        // Can rename entries with different types?\n        if ( F_ISSET(flags, fRF_EqualTypes)  &&  (src_type != dst_type) ) {\n            LOG_ERROR_NCBI(18, \"CDirEntry::Rename():\"\n                               \" Both source and destination exist and have different types: \"\n                               + src.GetPath() + \" and \" + dst.GetPath(),\n                               CNcbiError::eOperationNotPermitted);\n            return false;\n        }\n        // Can overwrite entry?\n        if ( !F_ISSET(flags, fRF_Overwrite) ) {\n            LOG_ERROR_NCBI(19, \"CDirEntry::Rename(): Destination path already exists: \"\n                               + dst.GetPath(), \n                               CNcbiError::eOperationNotPermitted);\n            return false;\n        }\n        // Rename only if destination is older, otherwise just remove source\n        if ( F_ISSET(flags, fRF_Update)  &&  !src.IsNewer(dst.GetPath(), 0)) {\n            return src.Remove();\n        }\n        // Backup destination entry first\n        if ( F_ISSET(flags, fRF_Backup) ) {\n            // Use new CDirEntry object instead of 'dst', because its path\n            // will be changed after backup\n            CDirEntry dst_tmp(dst);\n            if ( !dst_tmp.Backup(GetBackupSuffix(), eBackup_Rename) ) {\n                LOG_ERROR(20, \"CDirEntry::Rename(): Cannot backup: \" + dst.GetPath());\n                return false;\n            }\n        }\n        // Overwrite destination entry\n        if ( F_ISSET(flags, fRF_Overwrite) ) {\n            if ( dst.Exists() ) {\n                dst.Remove();\n            }\n        }\n    }\n\n    // On some platform rename() fails if destination entry exists, \n    // on others it can overwrite destination.\n    // For consistency return FALSE if destination already exists.\n    if ( dst.Exists() ) {\n        // this means Remove() has failed, and error is set already\n        LOG_ERROR(21, \"CDirEntry::Rename(): Destination path exists: \" + GetPath());\n        return false;\n    }\n    \n    // Rename\n    \n    if ( NcbiSys_rename(_T_XCSTRING(src.GetPath()),\n                        _T_XCSTRING(dst.GetPath())) != 0 ) {\n#ifdef NCBI_OS_MSWIN\n        if ( errno != EACCES ) {\n#else\n        if ( errno != EXDEV ) {\n#endif\n            LOG_ERROR_ERRNO(21, \"CDirEntry::Rename(): rename() failed for \" + GetPath());\n            return false;\n        }\n        // Note that rename() fails in the case of cross-device renaming.\n        // So, try to make a copy and remove the original later.\n        unique_ptr<CDirEntry> e(CDirEntry::CreateObject(src_type, src.GetPath()));\n        if ( !e->Copy(dst.GetPath(), fCF_Recursive | fCF_PreserveAll ) ) {\n            LOG_ERROR(102, \"CDirEntry::Rename(): Renaming via Copy() failed for \" + GetPath());\n            unique_ptr<CDirEntry> tmp(CDirEntry::CreateObject(src_type, dst.GetPath()));\n            tmp->Remove(eRecursive);\n            return false;\n        }\n        // Remove 'src'\n        if ( !e->Remove(eRecursive) ) {\n            LOG_ERROR(102, \"CDirEntry::Rename(): Renaming via Copy() failed for \" + GetPath());\n            // Do not delete 'dst' here because in case of directories the\n            // source may be already partially removed, so we can lost data.\n            return false;\n        }\n    }\n    Reset(newname);\n    return true;\n}\n\n\nbool CDirEntry::Remove(TRemoveFlags flags) const\n{\n    // Is this a directory ? (and processing not entry only)\n    if ( (flags & (fDir_All | fDir_Recursive)) != eEntryOnly  &&  IsDir(eIgnoreLinks) ) {\n        return CDir(GetPath()).Remove(flags);\n    }\n    // Other entries\n    return RemoveEntry(flags);\n}\n\n\nbool CDirEntry::RemoveEntry(TRemoveFlags flags) const\n{\n\n    if ( NcbiSys_remove(_T_XCSTRING(GetPath())) != 0 ) {\n        switch (errno) {\n        case ENOENT:\n            if ( flags & fIgnoreMissing )\n                return true;\n            break;\n\n#if defined(NCBI_OS_MSWIN)\n        case EACCES:\n            if ( NCBI_PARAM_TYPE(NCBI, DeleteReadOnlyFiles)::GetDefault() ) {\n                SetModeEntry(fDefault);\n                if ( NcbiSys_remove(_T_XCSTRING(GetPath())) == 0 ) {\n                    return true;\n                }\n            }\n            errno = EACCES;\n#endif\n        }\n        LOG_ERROR_ERRNO(22, \"CDirEntry::RemoveEntry(): remove() failed for: \" + GetPath());\n        return false;\n    }\n    return true;\n}\n\n\nbool CDirEntry::Backup(const string& suffix, EBackupMode mode,\n                       TCopyFlags copyflags, size_t copybufsize)\n{\n    string backup_name = DeleteTrailingPathSeparator(GetPath()) +\n                         (suffix.empty() ? string(GetBackupSuffix()) : suffix);\n    switch (mode) {\n        case eBackup_Copy:\n            {\n                TCopyFlags flags = copyflags;\n                flags &= ~(fCF_Update | fCF_Backup);\n                flags |=  (fCF_Overwrite | fCF_TopDirOnly);\n                return Copy(backup_name, flags, copybufsize);\n            }\n        case eBackup_Rename:\n            return Rename(backup_name, fRF_Overwrite);\n        default:\n            _TROUBLE;\n    }\n    // Unreachable\n    return false;\n}\n\n\nbool CDirEntry::IsNewer(const string& entry_name, TIfAbsent2 if_absent) const\n{\n    CDirEntry entry(entry_name);\n    CTime this_time;\n    CTime entry_time;\n    int v = 0;\n\n    if ( !GetTime(&this_time) ) {\n        v += 1;\n    }\n    if ( !entry.GetTime(&entry_time) ) {\n        v += 2;\n    }\n    if ( v == 0 ) {\n        return this_time > entry_time;\n    }\n    if ( if_absent ) {\n        switch(v) {\n        case 1:  // NoThis - HasPath\n            if ( if_absent &\n                 (fNoThisHasPath_Newer | fNoThisHasPath_NotNewer) )\n                return (if_absent & fNoThisHasPath_Newer) > 0;\n            break;\n        case 2:  // HasThis - NoPath\n            if ( if_absent &\n                 (fHasThisNoPath_Newer | fHasThisNoPath_NotNewer) )\n                return (if_absent & fHasThisNoPath_Newer) > 0;\n            break;\n        case 3:  // NoThis - NoPath\n            if ( if_absent &\n                 (fNoThisNoPath_Newer | fNoThisNoPath_NotNewer) )\n                return (if_absent & fNoThisNoPath_Newer) > 0;\n            break;\n        }\n    }\n    // throw an exception by default\n    NCBI_THROW(CFileException, eNotExists, \n               \"Directory entry does not exist\");\n    /*NOTREACHED*/\n    return false;\n}\n\n\nbool CDirEntry::IsNewer(time_t tm, EIfAbsent if_absent) const\n{\n    time_t current;\n    if ( !GetTimeT(&current) ) {\n        switch(if_absent) {\n        case eIfAbsent_Newer:\n            return true;\n        case eIfAbsent_NotNewer:\n            return false;\n        case eIfAbsent_Throw:\n        default:\n            NCBI_THROW(CFileException, eNotExists,\n                       \"Directory entry does not exist\");\n        }\n    }\n    return current > tm;\n}\n\n\nbool CDirEntry::IsNewer(const CTime& tm, EIfAbsent if_absent) const\n{\n    CTime current;\n    if ( !GetTime(&current) ) {\n        switch(if_absent) {\n        case eIfAbsent_Newer:\n            return true;\n        case eIfAbsent_NotNewer:\n            return false;\n        case eIfAbsent_Throw:\n        default:\n            NCBI_THROW(CFileException, eNotExists, \n                       \"Directory entry does not exist\");\n        }\n    }\n    return current > tm;\n}\n\n\nbool CDirEntry::IsIdentical(const string& entry_name,\n                            EFollowLinks  follow_links) const\n{\n#if defined(NCBI_OS_UNIX)\n    struct SStat st1, st2;\n    if ( !Stat(&st1, follow_links) ) {\n        LOG_ERROR(23, \"CDirEntry::IsIdentical(): Cannot find: \" + GetPath());\n        return false;\n    }\n    if ( !CDirEntry(entry_name).Stat(&st2, follow_links) ) {\n        LOG_ERROR(23, \"CDirEntry::IsIdentical(): Cannot find: \" + entry_name);\n        return false;\n    }\n    return st1.orig.st_dev == st2.orig.st_dev  &&\n           st1.orig.st_ino == st2.orig.st_ino;\n#else\n    return NormalizePath(GetPath(),  follow_links) ==\n           NormalizePath(entry_name, follow_links);\n#endif\n}\n\n\nbool CDirEntry::GetOwner(string* owner, string* group,\n                         EFollowLinks follow, \n                         unsigned int* uid, unsigned int* gid) const\n{\n    if ( !owner  &&  !group ) {\n        LOG_ERROR_NCBI(24, \"CDirEntry::GetOwner(): parameters are empty\", CNcbiError::eInvalidArgument);\n        return false;\n    }\n\n#if defined(NCBI_OS_MSWIN)\n\n    bool res = CWinSecurity::GetFileOwner(GetPath(), owner, group, uid, gid);\n    if (!res) {\n        // CWinSecurity already set CNcbiError\n        LOG_ERROR(24, \"CDirEntry::GetOwner(): unable to get owner for: \" + GetPath());\n    }\n    return res;\n\n#elif defined(NCBI_OS_UNIX)\n    struct stat st;\n    int errcode;\n    \n    if ( follow == eFollowLinks ) {\n        errcode = stat(GetPath().c_str(), &st);\n    } else {\n        errcode = lstat(GetPath().c_str(), &st);\n    }\n    if ( errcode != 0 ) {\n        LOG_ERROR_ERRNO(24, \"CDirEntry::GetOwner(): stat() failed for: \" + GetPath());\n        return false;\n    }\n    if ( uid ) {\n        *uid = st.st_uid;\n    }\n    if ( gid ) {\n        *gid = st.st_gid;\n    }\n    if ( owner ) {\n        CUnixFeature::GetUserNameByUID(st.st_uid).swap(*owner);\n        if (owner->empty()) {\n            NStr::NumericToString(*owner, st.st_uid, 0 /* flags */, 10);\n        }\n    }\n    if ( group ) {\n        CUnixFeature::GetGroupNameByGID(st.st_gid).swap(*group);\n        if (group->empty()) {\n            NStr::NumericToString(*group, st.st_gid, 0 /* flags */, 10);\n        }\n    }\n    return true;\n\n#endif\n}\n\n\nbool CDirEntry::SetOwner(const string& owner, const string& group,\n                         EFollowLinks follow,\n                         unsigned int* uid, unsigned int* gid) const\n{\n    if ( gid ) *gid = 0;\n    if ( uid ) *uid = 0;\n\n    if ( owner.empty()  &&  group.empty() ) {\n        LOG_ERROR_NCBI(103, \"CDirEntry::SetOwner(): parameters are empty\", CNcbiError::eInvalidArgument);\n        return false;\n    }\n\n#if defined(NCBI_OS_MSWIN)\n    bool res = CWinSecurity::SetFileOwner(GetPath(), owner, group, uid, gid);\n    if (!res) {\n        // CWinSecurity already set CNcbiError\n        LOG_ERROR(104, \"CDirEntry::SetOwner(): unable to set owner for: \" + GetPath());\n    }\n    return res;\n\n#elif defined(NCBI_OS_UNIX)\n\n    uid_t temp_uid;\n    if ( !owner.empty() ) {\n        temp_uid = CUnixFeature::GetUserUIDByName(owner);\n        if (temp_uid == (uid_t)(-1)){\n            CNcbiError::SetFromErrno();\n            unsigned int temp;\n            if (!NStr::StringToNumeric(owner, &temp, NStr::fConvErr_NoThrow, 0)) {\n                LOG_ERROR(25, \"CDirEntry::SetOwner(): Invalid owner name: \" + owner);\n                return false;\n            }\n            temp_uid = (uid_t) temp;\n        }\n        if ( uid ) {\n            *uid = temp_uid;\n        }\n    } else {\n        temp_uid = (uid_t)(-1);\n    }\n\n    gid_t temp_gid;\n    if ( !group.empty() ) {\n        temp_gid = CUnixFeature::GetGroupGIDByName(group);\n        if (temp_gid == (gid_t)(-1)) {\n            CNcbiError::SetFromErrno();\n            unsigned int temp;\n            if (!NStr::StringToNumeric(group, &temp, NStr::fConvErr_NoThrow, 0)) {\n                LOG_ERROR(26, \"CDirEntry::SetOwner(): Invalid group name: \" + group);\n                return false;\n            }\n            temp_gid = (gid_t) temp;\n        }\n        if ( gid ) {\n            *gid = temp_gid;\n        }\n    } else {\n        temp_gid = (gid_t)(-1);\n    }\n\n    if (follow == eFollowLinks  ||  GetType(eIgnoreLinks) != eLink) {\n        if ( chown(GetPath().c_str(), temp_uid, temp_gid) ) {\n            LOG_ERROR_ERRNO(27, \"CDirEntry::SetOwner(): Cannot change owner for: \" + GetPath());\n            return false;\n        }\n    }\n#  if defined(HAVE_LCHOWN)\n    else {\n        if ( lchown(GetPath().c_str(), temp_uid, temp_gid) ) {\n            LOG_ERROR_ERRNO(28, \"CDirEntry::SetOwner(): Cannot change symlink owner for: \" + GetPath());\n            return false;\n        }\n    }\n#  endif\n\n    return true;\n#endif\n}\n\n\nstring CDirEntry::GetTmpName(ETmpFileCreationMode mode)\n{\n#if defined(NCBI_OS_MSWIN)  ||  defined(NCBI_OS_UNIX)\n    return GetTmpNameEx(kEmptyStr, kEmptyStr, mode);\n#else\n    if (mode == eTmpFileCreate) {\n        ERR_POST_X(2, Warning << \n                   \"Temporary file cannot be auto-created on this platform, \"\n                   \"return its name only\");\n    }\n    TXChar* filename = NcbiSys_tempnam(0,0);\n    if ( !filename ) {\n        LOG_ERROR_ERRNO(91, \"CDirEntry::GetTmpName(): tempnam() failed\");\n        return kEmptyStr;\n    }\n    string res(_T_CSTRING(filename));\n    free(filename);\n    return res;\n#endif\n}\n\n\n#if !defined(NCBI_OS_UNIX)  &&  !defined(NCBI_OS_MSWIN)\nstatic string s_StdGetTmpName(const char* dir, const char* prefix)\n{\n    char* filename = tempnam(dir, prefix);\n    if ( !filename ) {\n        LOG_ERROR_ERRNO(92, \"CDirEntry::s_StdGetTmpName(): tempnam() failed\");\n        return kEmptyStr;\n    }\n    string str(filename);\n    free(filename);\n    return str;\n}\n#endif\n\n\nstring CDirEntry::GetTmpNameEx(const string&        dir,\n                               const string&        prefix,\n                               ETmpFileCreationMode mode)\n{\n    CFileIO temp_file;\n    temp_file.CreateTemporary(dir, prefix,\n                              mode == eTmpFileCreate ? CFileIO::eDoNotRemove : \n                                                       CFileIO::eRemoveInClose);\n    temp_file.Close();\n    return temp_file.GetPathname();\n}\n\n\nclass CTmpStream : public fstream\n{\npublic:\n\n    CTmpStream(const char* s, IOS_BASE::openmode mode) : fstream(s, mode)\n    {\n        m_FileName = s;\n        // Try to remove file and OS will automatically delete it after\n        // the last file descriptor to it is closed (works only on UNIXes)\n        CFile(m_FileName).Remove();\n    }\n\n#if defined(NCBI_OS_MSWIN)\n    CTmpStream(const char* s, FILE* file) : fstream(file)\n    {\n        m_FileName = s; \n    }\n#endif    \n\n    virtual ~CTmpStream(void) \n    { \n        close();\n        if ( !m_FileName.empty() ) {\n            CFile(m_FileName).Remove();\n        }\n    }\n\nprotected:\n    string m_FileName;  // Temporary file name\n};\n\n\nfstream* CDirEntry::CreateTmpFile(const string& filename, \n                                  ETextBinary   text_binary,\n                                  EAllowRead    allow_read)\n{\n    string tmpname = filename.empty() ? GetTmpName(eTmpFileCreate) : filename;\n    if ( tmpname.empty() ) {\n        LOG_ERROR(29, \"CDirEntry::CreateTmpFile(): Cannot get temporary file name\");\n        return 0;\n    }\n#if defined(NCBI_OS_MSWIN)\n    // Open file manually, because we cannot say to fstream\n    // to use some specific flags for file opening.\n    // MS Windows should delete created file automatically\n    // after closing all opened file descriptors.\n\n    // We cannot enable \"only write\" mode here,\n    // so ignore 'allow_read' flag.\n    // Specify 'TD' (_O_SHORT_LIVED | _O_TEMPORARY)\n    char mode[6] = \"w+TDb\";\n    if (text_binary != eBinary) {\n        mode[4] = '\\0';\n    }\n    FILE* file = NcbiSys_fopen(_T_XCSTRING(tmpname), _T_XCSTRING(mode));\n    if ( !file ) {\n        LOG_ERROR_ERRNO(105, \"CDirEntry::CreateTmpFile(): Cannot create temporary file: \" + tmpname);\n        return 0;\n    }\n    // Create FILE* based fstream.\n    fstream* stream = new CTmpStream(tmpname.c_str(), file);\n    // We dont need to close FILE*, it will be closed in the fstream\n\n#else\n    // Create filename based fstream\n    ios::openmode mode = ios::out | ios::trunc;\n    if ( text_binary == eBinary ) {\n        mode = mode | ios::binary;\n    }\n    if ( allow_read == eAllowRead ) {\n        mode = mode | ios::in;\n    }\n    fstream* stream = new CTmpStream(tmpname.c_str(), mode);\n#endif\n\n    if ( !stream->good() ) {\n        delete stream;\n        LOG_ERROR_NCBI(106, \"CDirEntry::CreateTmpFile(): Cannot create temporary file stream for: \" + tmpname,\n                       CNcbiError::eNoSuchFileOrDirectory);\n        return 0;\n    }\n    return stream;\n}\n\n\nfstream* CDirEntry::CreateTmpFileEx(const string& dir, const string& prefix,\n                                    ETextBinary text_binary, \n                                    EAllowRead allow_read)\n{\n    return CreateTmpFile(GetTmpNameEx(dir, prefix, eTmpFileCreate),\n                         text_binary, allow_read);\n}\n\n\n// Helper: Copy attributes (owner/date/time) from one entry to another.\n// Both entries should have equal type.\n//\n// UNIX:\n//     In mostly cases only super-user can change owner for\n//     destination entry.  The owner of a file may change the group of\n//     the file to any group of which that owner is a member.\n// WINDOWS:\n//     This function doesn't support ownership change yet.\n//\nstatic bool s_CopyAttrs(const char* from, const char* to,\n                        CDirEntry::EType type, CDirEntry::TCopyFlags flags)\n{\n#if defined(NCBI_OS_UNIX)\n    CDirEntry::SStat st;\n    if ( !CDirEntry(from).Stat(&st) ) {\n        LOG_ERROR(30, \"s_CopyAttrs(): cannot get attributes for: \" + string(from));\n        return false;\n    }\n\n    // Date/time.\n    // Set time before chmod() call, because on some platforms\n    // setting time can affect file mode also.\n    if ( F_ISSET(flags, CDirEntry::fCF_PreserveTime) ) {\n#  if defined(HAVE_UTIMES)\n        struct timeval tvp[2];\n        tvp[0].tv_sec  = st.orig.st_atime;\n        tvp[0].tv_usec = st.atime_nsec / 1000;\n        tvp[1].tv_sec  = st.orig.st_mtime;\n        tvp[1].tv_usec = st.mtime_nsec / 1000;\n#    if defined(HAVE_LUTIMES)\n        if (lutimes(to, tvp)) {\n            LOG_ERROR_ERRNO(31, \"CDirEntry::s_CopyAttrs(): lutimes() failed for: \" + string(to));\n            return false;\n        }\n#    else\n        if (utimes(to, tvp)) {\n            LOG_ERROR_ERRNO(32, \"CDirEntry::s_CopyAttrs(): utimes() failed for: \" + string(to));\n            return false;\n        }\n#    endif\n# else  // !HAVE_UTIMES\n        // utimes() does not exists on current platform,\n        // so use less accurate utime().\n        struct utimbuf times;\n        times.actime  = st.orig.st_atime;\n        times.modtime = st.orig.st_mtime;\n        if (utime(to, &times)) {\n            LOG_ERROR_ERRNO(33, \"CDirEntry::s_CopyAttrs(): utime() failed for: \" + string(to));\n            return false;\n        }\n#  endif // HAVE_UTIMES\n    }\n\n    // Owner. \n    // To improve performance change it right here,\n    // do not use GetOwner/SetOwner.\n\n    if ( F_ISSET(flags, CDirEntry::fCF_PreserveOwner) ) {\n        if ( type == CDirEntry::eLink ) {\n#  if defined(HAVE_LCHOWN)\n            if ( lchown(to, st.orig.st_uid, st.orig.st_gid) ) {\n                if (errno != EPERM) {\n                    LOG_ERROR_ERRNO(34, \"CDirEntry::s_CopyAttrs(): lchown() failed for: \" + string(to));\n                    return false;\n                }\n            }\n#  endif\n            // We cannot change permissions for sym.links (below),\n            // so just exit from the function.\n            return true;\n        } else {\n            // Changing the ownership will probably fail, unless we're root.\n            // The setuid/gid bits can be cleared by OS.  If chown() fails,\n            // strip the setuid/gid bits.\n            if ( chown(to, st.orig.st_uid, st.orig.st_gid) ) {\n                if ( errno != EPERM ) {\n                    LOG_ERROR_ERRNO(35, \"CDirEntry::s_CopyAttrs(): chown() failed for: \" + string(to));\n                    return false;\n                }\n                st.orig.st_mode &= ~(S_ISUID | S_ISGID);\n            }\n        }\n    }\n\n    // Permissions\n    if ( F_ISSET(flags, CDirEntry::fCF_PreservePerm)  &&\n        type != CDirEntry::eLink ) {\n        if ( chmod(to, st.orig.st_mode) ) {\n            LOG_ERROR_ERRNO(36, \"CDirEntry::s_CopyAttrs(): chmod() failed for: \" + string(to));\n            return false;\n        }\n    }\n    return true;\n\n\n#elif defined(NCBI_OS_MSWIN)\n\n    CDirEntry efrom(from), eto(to);\n\n    WIN32_FILE_ATTRIBUTE_DATA attr;\n    if ( !::GetFileAttributesEx(_T_XCSTRING(from), GetFileExInfoStandard, &attr) ) {\n        LOG_ERROR_WIN(30, \"CDirEntry::s_CopyAttrs(): cannot get attributes for: \" + string(from));\n        return false;\n    }\n\n    // Date/time\n    if ( F_ISSET(flags, CDirEntry::fCF_PreserveTime) ) {\n        HANDLE h = ::CreateFile(_T_XCSTRING(to),\n                                FILE_WRITE_ATTRIBUTES, FILE_SHARE_READ, NULL,\n                                OPEN_EXISTING,\n                                FILE_FLAG_BACKUP_SEMANTICS /*for dirs*/, NULL); \n        if ( h == INVALID_HANDLE_VALUE ) {\n            LOG_ERROR_WIN(37, \"CDirEntry::s_CopyAttrs(): Cannot open: \" + string(to));\n            return false;\n        }\n        if ( !::SetFileTime(h, &attr.ftCreationTime, &attr.ftLastAccessTime, &attr.ftLastWriteTime) ) {\n            LOG_ERROR_WIN(38, \"CDirEntry::s_CopyAttrs(): Cannot change time for: \" + string(to));\n            ::CloseHandle(h);\n            return false;\n        }\n        ::CloseHandle(h);\n    }\n    // Permissions\n    if ( F_ISSET(flags, CDirEntry::fCF_PreservePerm) ) {\n        if ( !::SetFileAttributes(_T_XCSTRING(to), attr.dwFileAttributes) ) {\n            LOG_ERROR_WIN(39, \"CDirEntry::s_CopyAttrs(): Cannot change pemissions for: \" + string(to));\n            return false;\n        }\n    }\n    // Owner\n    if ( F_ISSET(flags, CDirEntry::fCF_PreserveOwner) ) {\n        string owner, group;\n        // We don't check the result here, because often is impossible\n        // to set the original owner name without administrator's rights.\n        if ( efrom.GetOwner(&owner, &group) ) {\n            eto.SetOwner(owner, group);\n        }\n    }\n\n    return true;\n#endif\n}\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CFile\n//\n\n\nCFile::~CFile(void)\n{ \n    return;\n}\n\n\nInt8 CFile::GetLength(void) const\n{\n    TNcbiSys_stat st;\n    if (NcbiSys_stat(_T_XCSTRING(GetPath()), &st) != 0) {\n        LOG_ERROR_ERRNO(40, \"CFile:GetLength(): stat() failed for: \" + GetPath());\n        return -1L;\n    }\n    if ( GetType(st) != eFile ) {\n        LOG_ERROR_NCBI(40, \"CFile:GetLength(): Not a file: \" + GetPath(), CNcbiError::eOperationNotPermitted);\n        return -1L;\n    }\n    return st.st_size;\n}\n\n\n#if !defined(NCBI_OS_MSWIN)\n\n// Close file handle\n//\nstatic int s_CloseFile(int fd)\n{\n    while (close(fd) != 0) {\n        if (errno != EINTR)\n            return errno;\n    }\n    // Success\n    return 0; \n}\n\n\n// Copy file \"src\" to \"dst\"\n//\nstatic bool s_CopyFile(const char* src, const char* dst, size_t buf_size)\n{\n    int fs;  // source file descriptor\n    int fd;  // destination file descriptor\n    \n    if ((fs = NcbiSys_open(src, O_RDONLY)) == -1) {\n        CNcbiError::SetFromErrno(src);\n        return false;\n    }\n\n    TNcbiSys_fstat st;\n    if (NcbiSys_fstat(fs, &st) != 0  ||\n        (fd = NcbiSys_open(dst, O_WRONLY|O_CREAT|O_TRUNC, st.st_mode & 0777)) == -1) {\n        int x_errno = errno;\n        s_CloseFile(fs);\n        CNcbiError::SetErrno(errno = x_errno, src);\n        return false;\n    }\n\n    // To prevent unnecessary memory (re-)allocations,\n    // use the on-stack buffer if either the specified\n    // \"buf_size\" or the size of the copied file is small.\n    char  x_buf[4096];\n    char* buf;\n\n    if (3 * sizeof(x_buf) >= (Uint8) st.st_size) {\n        // Use on-stack buffer for any files smaller than 3x of buffer size.\n        buf_size = sizeof(x_buf);\n        buf = x_buf;\n    } else {\n        if (buf_size == 0) {\n            buf_size = kDefaultBufferSize;\n        }\n        // Use allocated buffer no bigger than the size of the file to copy.\n        if (buf_size > (Uint8) st.st_size) {\n            buf_size = st.st_size;\n        }\n        buf = buf_size > sizeof(x_buf) ? new char[buf_size] : x_buf;\n    }\n\n    // Copy files\n    int x_errno = 0;\n    do {\n        ssize_t n_read = read(fs, buf, buf_size);\n        if (n_read == 0) {\n            break;\n        }\n        if (n_read < 0) {\n            if (errno == EINTR) {\n                continue;\n            }\n            x_errno = errno;\n            break;\n        }\n        // Write to the output file\n        const char* ptr = buf;\n        do {\n            ssize_t n_written = write(fd, ptr, n_read);\n            if (n_written == 0) {\n                x_errno = EINVAL;\n                break;\n            }\n            if ( n_written < 0 ) {\n                if (errno == EINTR) {\n                    continue;\n                }\n                x_errno = errno;\n                break;\n            }\n            n_read -= n_written;\n            ptr    += n_written;\n        } while (n_read > 0);\n        \n        if (n_read != 0) {\n            if (x_errno == 0) {\n                x_errno = EIO;\n            }\n        }\n    } while (!x_errno);\n\n    s_CloseFile(fs);\n    int xx_err = s_CloseFile(fd);\n    if (x_errno == 0) {\n        x_errno = xx_err;\n    }\n    if (buf != x_buf) {\n        delete [] buf;\n    }\n    if (x_errno != 0) {\n        CNcbiError::SetErrno(errno = x_errno, src);\n        return false;\n    }\n    return true;\n}\n\n#endif\n\n\nbool CFile::Copy(const string& newname, TCopyFlags flags, size_t buf_size) const\n{\n    CFile src(*this);\n    CFile dst(newname);\n\n    // Dereference links\n    if ( F_ISSET(flags, fCF_FollowLinks) ) {\n        src.DereferenceLink();\n        dst.DereferenceLink();\n    }\n    // The source file must exists\n    EType src_type = src.GetType();\n    if ( src_type != eFile )  {\n        LOG_ERROR_NCBI(41, \"CFile::Copy(): Source is not a file: \" + GetPath(),\n                       CNcbiError::eOperationNotPermitted);\n        return false;\n    }\n\n    EType  dst_type   = dst.GetType();\n    bool   dst_exists = (dst_type != eUnknown);\n    string dst_safe_path;  // saved path for fCF_Safe\n\n    // If destination exists...\n    if ( dst_exists ) {\n        // UNIX: check on copying file into yourself.\n        // MS Window's ::CopyFile() can recognize such case.\n#if defined(NCBI_OS_UNIX)\n        if ( src.IsIdentical(dst.GetPath()) ) {\n            LOG_ERROR_NCBI(41, \"CFile::Copy(): Cannot copy into itself: \" + src.GetPath(),\n                           CNcbiError::eOperationNotPermitted);\n            return false;\n        }\n#endif\n        // Can copy entries with different types?\n        // Destination must be a file too.\n        if ( F_ISSET(flags, fCF_EqualTypes)  &&  (src_type != dst_type) ) {\n            LOG_ERROR_NCBI(41, \"CFile::Copy(): Destination is not a file: \" + dst.GetPath(),\n                           CNcbiError::eOperationNotPermitted);\n            return false;\n        }\n        // Can overwrite entry?\n        if ( !F_ISSET(flags, fCF_Overwrite) ) {\n            LOG_ERROR_NCBI(42, \"CFile::Copy(): Destination file exists: \" + dst.GetPath(), \n                           CNcbiError::eOperationNotPermitted);\n            return false;\n        }\n        // Copy only if destination is older\n        if ( F_ISSET(flags, fCF_Update)  &&  !src.IsNewer(dst.GetPath(),0) ) {\n            return true;\n        }\n        // Backup destination entry first\n        if ( F_ISSET(flags, fCF_Backup) ) {\n            // Use new CDirEntry object for 'dst', because its path\n            // will be changed after backup\n            CDirEntry dst_tmp(dst);\n            if ( !dst_tmp.Backup(GetBackupSuffix(), eBackup_Rename) ) {\n                LOG_ERROR(43, \"CFile::Copy(): Cannot backup: \" + dst.GetPath());\n                return false;\n            }\n        }\n    }\n    // Safe copy -- copy to temporary file and rename later\n    if (F_ISSET(flags, fCF_Safe)) {\n        // Get new temporary name in the same directory\n        string path, name, ext;\n        SplitPath(dst.GetPath(), &path, &name, &ext);\n        string tmp = GetTmpNameEx(path.empty() ? CDir::GetCwd() : path, name + ext + kTmpSafeSuffix);\n        // Set new destination\n        dst_safe_path = dst.GetPath();\n        dst.Reset(tmp);\n    }\n\n    // Copy\n#if defined(NCBI_OS_MSWIN)\n    if ( !::CopyFile(_T_XCSTRING(src.GetPath()),\n                     _T_XCSTRING(dst.GetPath()), FALSE) ) {\n        LOG_ERROR_WIN(44, \"CFile::Copy(): Cannot copy \" + src.GetPath() + \" to \" + dst.GetPath());\n        dst.RemoveEntry();\n        return false;\n    }\n#else\n    if ( !s_CopyFile(src.GetPath().c_str(), dst.GetPath().c_str(), buf_size) ) {\n        LOG_ERROR_ERRNO(44, \"CFile::Copy(): Cannot copy \" + src.GetPath() + \" to \" + dst.GetPath());\n        dst.Remove();\n        return false;\n    }\n#endif\n\n    // Safe copy -- renaming\n    if (F_ISSET(flags, fCF_Safe)) {\n        if (!dst.Rename(dst_safe_path, fRF_Overwrite)) {\n            dst.RemoveEntry();\n            LOG_ERROR_NCBI(45, \"CFile:Copy():\"\n                               \" Cannot rename temporary file \" + dst.GetPath() +\n                               \" to \" + dst_safe_path, CNcbiError::eIoError);\n            return false;\n        }\n    }\n    // Verify copied data\n    if ( F_ISSET(flags, fCF_Verify)  &&  !src.Compare(dst.GetPath()) ) {\n        LOG_ERROR_NCBI(46, \"CFile::Copy(): Verification for \" + src.GetPath() + \n                           \" and \" + dst.GetPath() + \" failed\", CNcbiError::eIoError);\n        return false;\n    }\n\n    // Preserve attributes\n    // s_CopyFile() preserve permissions on Unix, MS-Windows don't need it at all.\n\n#if defined(NCBI_OS_MSWIN)\n    // On MS Windows ::CopyFile() already preserved file attributes\n    // and all date/times.\n    flags &= ~(fCF_PreservePerm | fCF_PreserveTime);\n#endif\n    if ( flags & fCF_PreserveAll ) {\n        if ( !s_CopyAttrs(src.GetPath().c_str(),\n                          dst.GetPath().c_str(), eFile, flags) ) {\n            LOG_ERROR(95, \"CFile::Copy(): Cannot copy permissions from \" + \n                          src.GetPath() + \" to \" + dst.GetPath());\n            return false;\n        }\n    }\n    return true;\n}\n\n\nbool CFile::Compare(const string& filename, size_t buf_size) const\n{\n    // To prevent unnecessary memory (re-)allocations,\n    // use the on-stack buffer if either the specified\n    // \"buf_size\" or the size of the compared files is small.\n    char   x_buf[4096*2];\n    size_t x_size = sizeof(x_buf)/2;\n    char*  buf1   = 0;\n    char*  buf2   = 0;\n    bool   equal  = false;\n    \n    try {\n        CFileIO f1;\n        CFileIO f2;\n        f1.Open(GetPath(), CFileIO::eOpen, CFileIO::eRead);\n        f2.Open(filename,  CFileIO::eOpen, CFileIO::eRead);\n \n        Uint8 s1 = f1.GetFileSize();\n        Uint8 s2 = f2.GetFileSize();\n        \n        // Files should have equal sizes\n        if (s1 != s2) {\n            LOG_ERROR_NCBI(93, \"CFile::Compare(): files have different size: \" + \n                               GetPath() + \" and \" + filename, \n                               CNcbiError::eOperationNotPermitted);\n            return false;\n        }\n        if (s1 == 0) {\n            return true;\n        }\n        // Use on-stack buffer for any files smaller than 3x of buffer size.\n        if (s1 <= 3 * x_size) {\n            buf_size = x_size;\n            buf1 = x_buf;\n            buf2 = x_buf + x_size;\n        } else {\n            if (buf_size == 0) {\n                buf_size = kDefaultBufferSize;\n            }\n            // Use allocated buffer no bigger than the size of the file to compare.\n            // Align buffer in memory to 8 byte boundary.\n            if (buf_size > s1) {\n                buf_size = (size_t)s1 + (8 - s1 % 8);\n            }\n            if (buf_size > x_size) {\n                buf1 = new char[buf_size*2];\n                buf2 = buf1 + buf_size;\n            } else {\n                buf1 = x_buf;\n                buf2 = x_buf + x_size;\n            }\n        }\n\n        size_t n1 = 0;\n        size_t n2 = 0;\n        size_t s  = 0;\n\n        // Compare files\n        for (;;) {\n            size_t n;\n            if (n1 < buf_size) {\n                n = f1.Read(buf1 + n1, buf_size - n1);\n                if (n == 0) {\n                    break;\n                }\n                n1 += n;\n            }\n            if (n2 < buf_size) {\n                n = f2.Read(buf2 + n2, buf_size - n2);\n                if (n == 0) {\n                    break;\n                }\n                n2 += n;\n            }\n            size_t m = min(n1, n2);\n            if ( memcmp(buf1, buf2, m) != 0 ) {\n                break;\n            }\n            if (n1 > m) {\n                memmove(buf1, buf1 + m, n1 - m);\n                n1 -= m;\n            } else {\n                n1 = 0;\n            }\n            if (n2 > m) {\n                memmove(buf2, buf2 + m, n2 - m);\n                n2 -= m;\n            } else {\n                n2 = 0;\n            }\n            s += m;\n        }\n        equal = (s1 == s);\n    }\n    catch (const CFileErrnoException& ex) {\n        LOG_ERROR_NCBI(47, \"CFile::Compare(): error comparing files \" + GetPath() + \n                           \" and \" + filename + \" : \" + ex.what(), \n                           CNcbiError::eIoError);\n    }\n    if (buf1 != x_buf) {\n        delete [] buf1;\n    }\n    return equal;\n}\n\n\nbool CFile::CompareTextContents(const string& file, ECompareText mode,\n                                size_t buf_size) const\n{\n    CNcbiIfstream f1(GetPath().c_str(), IOS_BASE::in);\n    CNcbiIfstream f2(file.c_str(),      IOS_BASE::in);\n\n    if ( !buf_size ) {\n        buf_size = kDefaultBufferSize;\n    }\n    return NcbiStreamCompareText(f1, f2, (ECompareTextMode)mode, (streamsize)buf_size);\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CDir\n//\n\n#if defined(NCBI_OS_UNIX)\n\nstatic bool s_GetHomeByUID(string& home)\n{\n    // Get the info using user ID\n    struct passwd* pwd;\n\n    if ((pwd = getpwuid(getuid())) == 0) {\n        LOG_ERROR_ERRNO(48, \"s_GetHomeByUID(): getpwuid() failed\");\n        return false;\n    }\n    home = pwd->pw_dir;\n    return true;\n}\n\nstatic bool s_GetHomeByLOGIN(string& home)\n{\n    const TXChar* ptr = 0;\n    // Get user name\n    if ( !(ptr = NcbiSys_getenv(_TX(\"USER\"))) ) {\n        if ( !(ptr = NcbiSys_getenv(_TX(\"LOGNAME\"))) ) {\n            if ( !(ptr = getlogin()) ) {\n                LOG_ERROR_ERRNO(49, \"s_GetHomeByLOGIN(): Unable to get user name\");\n                return false;\n            }\n        }\n    }\n    // Get home dir for this user\n    struct passwd* pwd = getpwnam(ptr);\n    if ( !pwd ||  pwd->pw_dir[0] == '\\0') {\n        LOG_ERROR_ERRNO(50, \"s_GetHomeByLOGIN(): getpwnam() failed\");\n        return false;\n    }\n    home = pwd->pw_dir;\n    return true;\n}\n\n#endif // NCBI_OS_UNIX\n\n\nstring CDir::GetHome(void)\n{\n    string home;\n\n#if defined(NCBI_OS_MSWIN)\n    // Get home dir from environment variables\n    // like - C:\\Documents and Settings\\user\\Application Data\n    const TXChar* str = NcbiSys_getenv(_TX(\"APPDATA\"));\n    if ( str ) {\n        home = _T_CSTRING(str);\n    } else {\n        // like - C:\\Documents and Settings\\user\n        str = NcbiSys_getenv(_TX(\"USERPROFILE\"));\n        if ( str ) {\n            home = _T_CSTRING(str);\n        }\n    }\n#elif defined(NCBI_OS_UNIX)\n    // Try get home dir from environment variable\n    char* str = NcbiSys_getenv(_TX(\"HOME\"));\n    if ( str ) {\n        home = str;\n    } else {\n        // Try to retrieve the home dir -- first use user's ID,\n        // and if failed, then use user's login name.\n        if ( !s_GetHomeByUID(home) ) { \n            s_GetHomeByLOGIN(home);\n        }\n    }\n#endif \n\n    // Add trailing separator if needed\n    return AddTrailingPathSeparator(home);\n}\n\n\nstring CDir::GetTmpDir(void)\n{\n    string tmp;\n\n#if defined(NCBI_OS_UNIX)\n\n    char* tmpdir = getenv(\"TMPDIR\");\n    if ( tmpdir ) {\n        tmp = tmpdir;\n    } else  {\n#  if defined(P_tmpdir)\n        tmp = P_tmpdir;\n#  else\n        tmp = \"/tmp\";\n#  endif\n    }\n\n#elif defined(NCBI_OS_MSWIN)\n\n    const TXChar* tmpdir = NcbiSys_getenv(_TX(\"TEMP\"));\n    if ( tmpdir ) {\n        tmp = _T_CSTRING(tmpdir);\n    } else  {\n#  if defined(P_tmpdir)\n        tmp = P_tmpdir;\n#  else\n        tmp = CDir::GetHome();\n#  endif\n    }\n\n#endif\n\n    return tmp;\n}\n\n\nstring CDir::GetAppTmpDir(void)\n{\n    // Get application specific temporary directory name\n    string tmp = NCBI_PARAM_TYPE(NCBI, TmpDir)::GetThreadDefault();\n    if ( !tmp.empty() ) {\n        return tmp;\n    }\n    // Use default TMP directory specified by OS\n    return CDir::GetTmpDir();\n}\n\n\nstring CDir::GetCwd(void)\n{\n    TXChar buf[4096];\n    if ( NcbiSys_getcwd(buf, sizeof(buf)/sizeof(TXChar) - 1) ) {\n        return _T_CSTRING(buf);\n    }\n    LOG_ERROR_ERRNO(90, \"CDir::GetCwd(): Cannot get current directory\");\n    return kEmptyCStr;\n}\n\n\nbool CDir::SetCwd(const string& dir)\n{\n    if ( NcbiSys_chdir(_T_XCSTRING(dir)) != 0 ) {\n        LOG_ERROR_ERRNO(51, \"CDir::SetCwd(): Cannot change directory to: \" + dir);\n        return false;\n    }\n    return true;\n}\n\n\nCDir::~CDir(void)\n{\n    return;\n}\n\n\nbool CDirEntry::MatchesMask(const string& name,\n                            const vector<string>& masks,\n                            NStr::ECase use_case)\n{\n    if ( masks.empty() ) {\n        return true;\n    }\n    ITERATE(vector<string>, itm, masks) {\n        const string& mask = *itm;\n        if ( MatchesMask(name, mask, use_case) ) {\n            return true;\n        }\n    }\n    return false;\n}\n\n\n// Helpers functions and macro for GetEntries().\n\n#if defined(NCBI_OS_MSWIN)\n\n// Set errno for failed FindFirstFile/FindNextFile\n// TODO: \n//   This method should be removed, we dont need to translate\n//   Windows error to errno, we already have CNcbiErrno for this,\n//   please use it.\n\nstatic void s_SetFindFileError(DWORD err)\n{\n    ::SetLastError(err); // set Windows error back\n    switch (err) {\n        case ERROR_NO_MORE_FILES:\n        case ERROR_FILE_NOT_FOUND:\n        case ERROR_PATH_NOT_FOUND:\n            errno = ENOENT;\n            break;\n        case ERROR_NOT_ENOUGH_MEMORY:\n            errno = ENOMEM;\n            break;\n        case ERROR_ACCESS_DENIED:\n            errno = EACCES;\n            break;\n        default:\n            errno = EINVAL;\n            break;\n    }\n}\n\n#  define IS_RECURSIVE_ENTRY                     \\\n    ( (flags & CDir::fIgnoreRecursive)  &&       \\\n      ((NcbiSys_strcmp(entry.cFileName, _TX(\".\"))  == 0) ||  \\\n       (NcbiSys_strcmp(entry.cFileName, _TX(\"..\")) == 0)) )\n\nstatic void s_AddEntry(CDir::TEntries*        contents,\n                       const string&          base_path,\n                       const WIN32_FIND_DATA& entry,\n                       CDir::TGetEntriesFlags flags)\n{\n    const string name = (flags & CDir::fIgnorePath) ?\n                         _T_CSTRING(entry.cFileName) :\n                         base_path + _T_CSTRING(entry.cFileName);\n        \n    if (flags & CDir::fCreateObjects) {\n        CDirEntry::EType type = (entry.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY) \n                                 ? CDirEntry::eDir : CDirEntry::eFile;\n        contents->push_back(CDirEntry::CreateObject(type, name));\n    } else {\n        contents->push_back(new CDirEntry(name));\n    }\n}\n\n#else // NCBI_OS_UNIX\n\n#  define IS_RECURSIVE_ENTRY                   \\\n    ( (flags & CDir::fIgnoreRecursive)  &&     \\\n      ((::strcmp(entry->d_name, \".\")  == 0) || \\\n       (::strcmp(entry->d_name, \"..\") == 0)) )\n\nstatic void s_AddEntry(CDir::TEntries*        contents,\n                       const string&          base_path,\n                       const struct dirent*   entry,\n                       CDir::TGetEntriesFlags flags)\n{\n    const string name = (flags & CDir::fIgnorePath) ? entry->d_name : base_path + entry->d_name;\n\n    if (flags & CDir::fCreateObjects) {\n        CDirEntry::EType type = CDir::eUnknown;\n#  if defined(_DIRENT_HAVE_D_TYPE)\n        struct stat st;\n        if (entry->d_type) {\n            st.st_mode = DTTOIF(entry->d_type);\n            type = CDirEntry::GetType(st);\n        }\n#  endif\n        if (type == CDir::eUnknown) {\n            if (flags & CDir::fIgnorePath) {\n                const string path = base_path + entry->d_name;\n                type = CDirEntry(path).GetType();\n            } else {\n                type = CDirEntry(name).GetType();\n            }\n        }\n        contents->push_back(CDirEntry::CreateObject(type, name));\n    } else {\n        contents->push_back(new CDirEntry(name));\n    }\n}\n\n#endif\n\n\nCDir::TEntries CDir::GetEntries(const string& mask, TGetEntriesFlags flags) const\n{\n    CMaskFileName masks;\n    if ( !mask.empty() ) {\n        masks.Add(mask);\n    }\n    return GetEntries(masks, flags);\n}\n\n\nCDir::TEntries* CDir::GetEntriesPtr(const string& mask, TGetEntriesFlags flags) const\n{\n    CMaskFileName masks;\n    if ( !mask.empty() ) {\n        masks.Add(mask);\n    }\n    return GetEntriesPtr(masks, flags);\n}\n\n\nCDir::TEntries CDir::GetEntries(const vector<string>& masks, TGetEntriesFlags flags) const\n{\n    unique_ptr<TEntries> contents(GetEntriesPtr(masks, flags));\n    return contents.get() ? *contents.get() : TEntries();\n}\n\n\nCDir::TEntries* CDir::GetEntriesPtr(const vector<string>& masks, TGetEntriesFlags flags) const\n{\n    if ( masks.empty() ) {\n        return GetEntriesPtr(kEmptyStr, flags);\n    }\n    TEntries* contents = new TEntries;\n    string base_path =  AddTrailingPathSeparator(GetPath().empty() ? DIR_CURRENT : GetPath());\n    NStr::ECase use_case = (flags & fNoCase) ? NStr::eNocase : NStr::eCase;\n\n#if defined(NCBI_OS_MSWIN)\n\n    // Append to the \"path\" mask for all files in directory\n    string pattern = base_path + \"*\";\n\n    WIN32_FIND_DATA entry;\n    HANDLE          handle;\n\n    handle = ::FindFirstFile(_T_XCSTRING(pattern), &entry);\n    if (handle != INVALID_HANDLE_VALUE) {\n        // Check all masks\n        do {\n            if (!IS_RECURSIVE_ENTRY) {\n                ITERATE(vector<string>, it, masks) {\n                    const string& mask = *it;\n                    if ( mask.empty()  ||\n                         MatchesMask(_T_CSTRING(entry.cFileName), mask, use_case) ) {\n                        s_AddEntry(contents, base_path, entry, flags);\n                        break;\n                    }                \n                }\n            }\n        } while (::FindNextFile(handle, &entry));\n        CNcbiError::SetFromWindowsError();\n        ::FindClose(handle);\n\n    } else {\n        DWORD err = ::GetLastError();\n        CNcbiError::SetWindowsError(err);\n        s_SetFindFileError(err);\n        delete contents;\n        if ( F_ISSET(flags, fThrowOnError) ) {\n            NCBI_THROW(CFileErrnoException, eFile, \"Cannot read directory \" + base_path);\n        }\n        return NULL;\n    }\n\n#elif defined(NCBI_OS_UNIX)\n\n    DIR* dir = opendir(base_path.c_str());\n    if ( !dir ) {\n        CNcbiError::SetFromErrno();\n        delete contents;\n        if ( F_ISSET(flags, fThrowOnError) ) {\n            NCBI_THROW(CFileErrnoException, eFile, \"Cannot read directory \" + base_path);\n        }\n        return NULL;\n    }\n    while (struct dirent* entry = readdir(dir)) {\n        if (IS_RECURSIVE_ENTRY) {\n            continue;\n        }\n        ITERATE(vector<string>, it, masks) {\n            const string& mask = *it;\n            if ( mask.empty()  ||  MatchesMask(entry->d_name, mask, use_case) ) {\n                s_AddEntry(contents, base_path, entry, flags);\n                break;\n            }\n        } // ITERATE\n    } // while\n    CNcbiError::SetFromErrno();\n    closedir(dir);\n\n#endif\n\n    return contents;\n}\n\n\nCDir::TEntries CDir::GetEntries(const CMask& masks, TGetEntriesFlags flags) const\n{\n    unique_ptr<TEntries> contents(GetEntriesPtr(masks, flags));\n    return contents.get() ? *contents.get() : TEntries();\n}\n\n\nCDir::TEntries* CDir::GetEntriesPtr(const CMask& masks, TGetEntriesFlags flags) const\n{\n    TEntries* contents = new TEntries;\n    string base_path = AddTrailingPathSeparator(GetPath().empty() ? DIR_CURRENT : GetPath());\n    NStr::ECase use_case = (flags & fNoCase) ? NStr::eNocase : NStr::eCase;\n\n#if defined(NCBI_OS_MSWIN)\n\n    // Append to the \"path\" mask for all files in directory\n    string pattern = base_path + \"*\";\n\n    WIN32_FIND_DATA entry;\n    HANDLE          handle;\n\n    handle = ::FindFirstFile(_T_XCSTRING(pattern), &entry);\n    if (handle != INVALID_HANDLE_VALUE) {\n        do {\n            if ( !IS_RECURSIVE_ENTRY  &&\n                 masks.Match(_T_CSTRING(entry.cFileName), use_case) ) {\n                s_AddEntry(contents, base_path, entry, flags);\n            }\n        } while ( ::FindNextFile(handle, &entry) );\n        CNcbiError::SetFromWindowsError();\n        ::FindClose(handle);\n\n    } else {\n        DWORD err = ::GetLastError();\n        CNcbiError::SetWindowsError(err);\n        s_SetFindFileError(err);\n        delete contents;\n        if ( F_ISSET(flags, fThrowOnError) ) {\n            NCBI_THROW(CFileErrnoException, eFile, string(\"Cannot read directory \") + base_path);\n        }\n        return NULL;\n    }\n\n#elif defined(NCBI_OS_UNIX)\n\n    DIR* dir = opendir(base_path.c_str());\n    if ( !dir ) {\n        CNcbiError::SetFromErrno();\n        delete contents;\n        if ( F_ISSET(flags, fThrowOnError) ) {\n            NCBI_THROW(CFileErrnoException, eFile, string(\"Cannot read directory \") + base_path);\n        }\n        return NULL;\n    }\n    while (struct dirent* entry = readdir(dir)) {\n        if ( !IS_RECURSIVE_ENTRY  &&\n             masks.Match(entry->d_name, use_case) ) {\n            s_AddEntry(contents, base_path, entry, flags);\n        }\n    }\n    CNcbiError::SetFromErrno();\n    closedir(dir);\n\n#endif\n\n    return contents;\n}\n\n\n// Helper function for CDir::Create[Path]()\ninline bool s_DirCreate(const string&path, CDir::TCreateFlags flags, mode_t mode)\n{\n    errno = 0;\n#if defined(NCBI_OS_MSWIN)\n    int res = NcbiSys_mkdir(_T_XCSTRING(path));\n#elif defined(NCBI_OS_UNIX)\n    int res = NcbiSys_mkdir(_T_XCSTRING(path), mode);\n#endif\n    if (res != 0) {\n        if (errno != EEXIST) {\n            LOG_ERROR_ERRNO(52, \"s_DirCreate(): Cannot create directory: \" + path);\n            return false;\n        }\n        // Entry with such name already exists, check its type\n        CDirEntry::EType type = CDirEntry(path).GetType();\n        if (type != CDirEntry::eDir) {\n            LOG_ERROR_NCBI(53, \"s_DirCreate(): Path already exist and is not a directory: \" + path, CNcbiError::eNotADirectory);\n            return false;\n        }\n        if (F_ISSET(flags, CDir::fCreate_ErrorIfExists)) {\n            LOG_ERROR_NCBI(54, \"s_DirCreate(): Directory already exist: \" + path, CNcbiError::eFileExists);\n            return false;\n        }\n        if (!F_ISSET(flags, CDir::fCreate_UpdateIfExists)) {\n            return true;\n        }\n    }\n    // The permissions for the created directory is controlled by umask and is (mode & ~umask & 0777).\n    // We need to call chmod() directly if we need other behavior.\n\n    _ASSERT(CDir::fCreate_Default      == 0  &&\n            CDir::fCreate_PermByUmask  != 0  &&\n            CDir::fCreate_PermAsParent != 0);\n    _ASSERT(!F_ISSET(flags, CDir::fCreate_PermByUmask | CDir::fCreate_PermAsParent));\n\n    if ( F_ISSET(flags, CDir::fCreate_PermByUmask)  ||  \n          (!F_ISSET(flags, CDir::fCreate_PermByUmask)  &&  !F_ISSET(flags, CDir::fCreate_PermAsParent)  &&\n           NCBI_PARAM_TYPE(NCBI, FileAPIHonorUmask)::GetDefault()) ) {\n        // nothing to do if (umask) or (default mode with \"honor umask\" global flag)\n        return true;\n    }\n    // Change directory permissions\n    if (NcbiSys_chmod(_T_XCSTRING(path), mode) != 0) {\n        LOG_ERROR_ERRNO(55, \"CDir::Create(): Cannot set mode for directory: \" + path);\n        return false;\n    }\n    return true;\n}\n\n\nbool CDir::Create(TCreateFlags flags) const\n{\n    if (GetPath().empty()) {\n        LOG_ERROR_NCBI(56, \"CDir::Create(): Path is empty\", CNcbiError::eInvalidArgument);\n        return false;\n    }\n    mode_t mode = GetDefaultModeT();\n\n    // Get parent permissions\n    if (F_ISSET(flags, fCreate_PermAsParent)) {\n        CDir d(CreateAbsolutePath(GetPath()));\n        string path_up(d.GetDir());\n        if ( path_up.empty()  ||  path_up == d.GetPath() ) {\n            LOG_ERROR_NCBI(57, \"CDir::Create(): Cannot get parent directory for: \" + GetPath(), \n                           CNcbiError::eNoSuchFileOrDirectory);\n            return false;\n        }\n#if defined(NCBI_OS_MSWIN)\n        // Special case -- stat() dont works if directory have trailing path\n        // separator, except it is a root directory with a disk name, like \"C:\\\".\n        if (path_up.length() > 3) {\n            path_up = DeleteTrailingPathSeparator(path_up);\n        }\n#endif\n        TNcbiSys_stat st;\n        if (NcbiSys_stat(_T_XCSTRING(path_up), &st) != 0) {\n            LOG_ERROR_ERRNO(58, \"CDir::Create(): stat() failed for: \" + GetPath());\n            return false;\n        }\n        mode = st.st_mode;\n    }\n    return s_DirCreate(GetPath(), flags, mode);\n}\n\n\nbool CDir::CreatePath(TCreateFlags flags) const\n{\n    if (GetPath().empty()) {\n        LOG_ERROR_NCBI(59, \"CDir::CreatePath(): Path is empty\", CNcbiError::eInvalidArgument);\n        return false;\n    }\n    string path(CreateAbsolutePath(GetPath()));\n    if (path.empty()) {\n        LOG_ERROR_NCBI(60, \"CDir::CreatePath(): Cannot create absolute path from: \" + path, CNcbiError::eInvalidArgument);\n        return false;\n    }\n    if (path[path.length()-1] == GetPathSeparator()\n#if defined(NCBI_OS_MSWIN)\n        &&  path.length() != 3\n        // Special case -- for path like \"C:\\\" dont remove a last separator, it represent a root directory\n#endif\n        ) {\n        path.erase(path.length() - 1);\n    }\n\n    // Find all missed parts of the path\n\n    CTempString tmp(path); // existent part of a path\n    std::list<CTempString> missed_parts;\n\n    while (!tmp.empty()  &&  !CDirEntry(tmp).Exists()) {\n        size_t pos = tmp.find_last_of(DIR_SEPARATORS);\n        if (pos == NPOS) {\n            break;\n        }\n        CTempString part(tmp.substr(pos+1));\n        missed_parts.push_front(part);\n        tmp.erase(pos);\n    }\n\n    mode_t mode = GetDefaultModeT();\n\n    // Get parent permissions\n    if (F_ISSET(flags, fCreate_PermAsParent)) {\n        string parent;\n        if (missed_parts.empty()) {\n            parent.assign(CDir(tmp).GetDir());\n        } else {\n            parent.assign(tmp);\n        }\n#if defined(NCBI_OS_MSWIN)\n        // Special case -- for paths like \"C:\" add slash to represent a root directory\n        if (parent.length() == 2) {\n            parent += GetPathSeparator();\n        }\n#endif\n        TNcbiSys_stat st;\n        if (NcbiSys_stat(_T_XCSTRING(parent), &st) != 0) {\n            LOG_ERROR_ERRNO(61, \"CDir::CreatePath(): stat() failed for: \" + parent);\n            return false;\n        }\n        mode = st.st_mode;\n    }\n\n    // Path exists?\n    if (missed_parts.empty()) {\n        // check existence and behave depends on flags\n        if (!s_DirCreate(path, flags, mode)) {\n            LOG_ERROR(96, \"CDir::CreatePath(): Cannot create path: \" + GetPath());\n            return false;\n        }\n        return true;\n    }\n\n    // Create missed subdirectories\n    string p = tmp;\n    for (auto i : missed_parts) {\n        p += GetPathSeparator();\n        p += i;\n        if (!s_DirCreate(p, flags, mode)) {\n            LOG_ERROR(97, \"CDir::CreatePath(): Cannot create path: \" + GetPath());\n            return false;\n        }\n    }\n    return true;\n}\n\n\nbool CDir::Copy(const string& newname, TCopyFlags flags, size_t buf_size) const\n{\n    CDir src(*this);\n    CDir dst(newname);\n\n    // Dereference links\n    bool follow = F_ISSET(flags, fCF_FollowLinks);\n    if ( follow ) {\n        src.DereferenceLink();\n        dst.DereferenceLink();\n    }\n    // The source dir must exists\n    EType src_type = src.GetType();\n    if ( src_type != eDir )  {\n        LOG_ERROR_NCBI(62, \"CDir::Copy(): Source is not a directory: \" + src.GetPath(),\n                       CNcbiError::eNoSuchFileOrDirectory);\n        return false;\n    }\n    EType  dst_type        = dst.GetType();\n    bool   dst_exists      = (dst_type != eUnknown);\n    bool   need_create_dst = !dst_exists;\n    string dst_safe_path;  // saved path for fCF_Safe\n\n    // Safe copy? \n    // Don't use it if fCF_TopDirOnly is not specified. If target directory\n    // exists it will be just \"updated\" and safe copying will be applied\n    // on a file level for every copied entry.\n    bool need_safe_copy = F_ISSET(flags, fCF_Safe | fCF_TopDirOnly);\n\n    // If destination exists...\n    if ( dst_exists ) {\n        // Check on copying dir into yourself\n        if ( src.IsIdentical(dst.GetPath()) ) {\n            LOG_ERROR_NCBI(63, \"CDir::Copy(): Source and destination are the same: \" + src.GetPath(),\n                           CNcbiError::eOperationNotPermitted);\n            return false;\n        }\n        // Can rename entries with different types?\n        if ( F_ISSET(flags, fCF_EqualTypes)  &&  (src_type != dst_type) ) {\n            LOG_ERROR_NCBI(64, \"CDir::Copy(): Destination is not a directory: \" + dst.GetPath(), \n                           CNcbiError::eOperationNotPermitted);\n            return false;\n        }\n\n        // Some operation can be made for top directory only\n\n        if ( F_ISSET(flags, fCF_TopDirOnly) ) {\n            // Can overwrite entry?\n            if ( !F_ISSET(flags, fCF_Overwrite) ) {\n                LOG_ERROR_NCBI(65, \"CDir::Copy(): Destination directory already exists: \" + dst.GetPath(), \n                               CNcbiError::eOperationNotPermitted);\n                return false;\n            }\n            // Copy only if destination is older\n            if ( F_ISSET(flags, fCF_Update)  &&  !src.IsNewer(dst.GetPath(), 0) ) {\n                return true;\n            }\n            // Backup destination directory\n            if (F_ISSET(flags, fCF_Backup)) {\n                // Use new CDirEntry object instead of 'dst', because its path\n                // will be changed after backup\n                CDirEntry dst_tmp(dst);\n                if ( !dst_tmp.Backup(GetBackupSuffix(), eBackup_Rename) ) {\n                    LOG_ERROR(66, \"CDir::Copy(): Cannot backup destination directory: \" + dst.GetPath());\n                    return false;\n                }\n                need_create_dst = true;\n            }\n            // Clear flags not needed anymore.\n            // Keep fCF_Overwrite if it is set (fCF_Backup is a compound flag).\n            flags &= ~(fCF_TopDirOnly | (fCF_Backup - fCF_Overwrite));\n        }\n    }\n\n    // Safe copy for top directory -- copy to temporary directory in the same\n    // parent directory and rename later.\n\n    if ( need_safe_copy ) {\n        // Get new temporary name in the same directory\n        string path, name, ext;\n        SplitPath(dst.GetPath(), &path, &name, &ext);\n        string tmp = GetTmpNameEx(path.empty() ? CDir::GetCwd() : path, name + ext + kTmpSafeSuffix);\n        // Set new destination\n        dst_safe_path = dst.GetPath();\n        dst.Reset(tmp);\n        need_create_dst = true;\n        // Clear safe flag, we already have a temporary top directory\n        flags &= ~fCF_Safe;\n    }\n\n    // Create target directory if needed\n    if ( need_create_dst ) {\n        if ( !dst.CreatePath() ) {\n            LOG_ERROR(67, \"CDir::Copy(): Cannot create \" << \n                          (dst_safe_path.empty() ? \"target\" : \"temporary\") <<\n                          \" directory: \" << dst.GetPath());\n            return false;\n        }\n    }\n\n    // Read all entries in source directory\n    unique_ptr<TEntries> contents(src.GetEntriesPtr(kEmptyStr, fIgnoreRecursive));\n    if ( !contents.get() ) {\n        LOG_ERROR(68, \"CDir::Copy(): Cannot get content of \" + src.GetPath());\n        return false;\n    }\n\n    // And copy each of them to target directory\n    ITERATE(TEntries, e, *contents.get()) {\n        CDirEntry& entry = **e;\n        if (!F_ISSET(flags, fCF_Recursive) &&\n            entry.IsDir(follow ? eFollowLinks : eIgnoreLinks)) {\n            continue;\n        }\n        // Copy entry\n        if (!entry.CopyToDir(dst.GetPath(), flags, buf_size)) {\n            LOG_ERROR(69, \"CDir::Copy(): Cannot copy \" + \n                      entry.GetPath() + \" to directory \" + dst.GetPath());\n            return false;\n        }\n    }\n\n    // Safe copy for top directory -- renaming temporary to target\n    if (!dst_safe_path.empty()) {\n        if (!dst.Rename(dst_safe_path, fRF_Overwrite)) {\n            dst.Remove();\n            LOG_ERROR(70, \"CDir:Copy(): Cannot rename temporary directory \" +\n                      dst.GetPath() + \" to \" + dst_safe_path);\n            return false;\n        }\n    }\n    // Preserve attributes\n    if ( flags & fCF_PreserveAll ) {\n        if ( !s_CopyAttrs(src.GetPath().c_str(),\n                          dst.GetPath().c_str(), eDir, flags) ) {\n            LOG_ERROR(98, \"CDir:Copy(): Cannot copy attributes from \" +\n                      src.GetPath() + \" to \" + dst.GetPath());\n            return false;\n        }\n    } else {\n        // Set default permissions for directory, if we should not\n        // honor umask settings.\n        if ( !NCBI_PARAM_TYPE(NCBI, FileAPIHonorUmask)::GetDefault()) {\n            if ( !dst.SetMode(fDefault, fDefault, fDefault) ) {\n                LOG_ERROR(99, \"CDir:Copy(): Cannot set default directory permissions: \" + dst.GetPath());\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\n\nbool CDir::Remove(TRemoveFlags flags) const\n{\n    // Assumption\n    _ASSERT(fDir_Self  == fEntry);\n    _ASSERT(eOnlyEmpty == fEntry);\n    \n    // Remove directory as empty\n    if ( (flags & (fDir_All | fDir_Recursive)) == eOnlyEmpty ) {\n        if ( NcbiSys_rmdir(_T_XCSTRING(GetPath())) != 0 ) {\n            if ( (flags & fIgnoreMissing)  &&  (errno == ENOENT) ) {\n                return true;\n            }\n            LOG_ERROR_ERRNO(71, \"CDir::Remove(): Cannot remove (by implication empty)\"\n                                \" directory: \" + GetPath());\n            return false;\n        }\n        return true;\n    }\n\n#if !defined(NCBI_OS_MSWIN)\n    // Make directory writable for user to remove any entry inside\n    SetMode(CDirEntry::fWrite | CDirEntry::fModeAdd, \n            CDirEntry::fModeNoChange,\n            CDirEntry::fModeNoChange);\n#endif\n\n    // Read all entries in directory\n    unique_ptr<TEntries> contents(GetEntriesPtr());\n    if (!contents.get()) {\n        LOG_ERROR(72, \"CDir::Remove(): Cannot get content of: \" + GetPath());\n        return false;\n    }\n \n    try {\n        // Remove each entry\n        ITERATE(TEntries, entry, *contents.get()) {\n            string name = (*entry)->GetName();\n            if (name == \".\" || name == \"..\" || name == string(1, GetPathSeparator())) {\n                continue;\n            }\n            // Get entry item with full pathname\n            CDirEntry item(GetPath() + GetPathSeparator() + name);\n\n            if (flags & fDir_Recursive) {\n                // Update flags to process subdirectories itself,\n                // because the top directory entry may not have\n                // such flag.\n                int f = (flags & fDir_Subdirs) ? (flags | fDir_Self) : flags;\n                if (item.IsDir(eIgnoreLinks)) {\n                    if (!CDir(item.GetPath()).Remove(f)) {\n                        throw \"Removing subdirectory failed\";\n                    }\n                }\n                else if (flags & fDir_Files) {\n                    if (!item.Remove(f)) {\n                        throw \"Removing directory entry failed\";\n                    }\n                }\n            }\n            else if (item.IsDir(eIgnoreLinks)) {\n                // Non-recursive directory removal\n                if (flags & fDir_Subdirs) {\n                    // Clear all flags to go inside directory,\n                    // and try to remove it as \"empty\".\n                    if (!item.Remove((flags & ~fDir_All) | fDir_Self)) {\n                        throw \"Removing directory entry (non-recursive) failed\";\n                    }\n                }\n                continue;\n            }\n            else {\n                if (flags & fDir_Files) {\n                    if (!item.Remove(flags)) {\n                        throw \"\";\n                    }\n                }\n            }\n        }\n        // Remove top directory\n        if ((flags & fDir_Self) && NcbiSys_rmdir(_T_XCSTRING(GetPath())) != 0) {\n            if ((flags & fIgnoreMissing) && (errno == ENOENT)) {\n                return true;\n            }\n            throw \"Cannot remove directory itself\";\n        }\n    }\n    catch (const char* what) {\n        // The error is may be reported already in child .Remove() for recursive calls,\n        // but add an additional error log for the current directory itself. \n        LOG_ERROR(73, \"CDir::Remove(): Cannot remove directory: \" + GetPath() + \": \" + what);\n        return false;\n    }\n    return true;\n}\n\n\nbool CDir::SetMode(TMode user_mode,  TMode group_mode,\n                   TMode other_mode, TSpecialModeBits special_mode,\n                   TSetModeFlags flags) const\n{\n    // Assumption\n    _ASSERT(fDir_Self == fEntry);\n    _ASSERT(eEntryOnly == fEntry);\n\n    // Default mode (backward compatibility) -- top entry only\n    if ( (flags & (fDir_All | fDir_Recursive)) == eEntryOnly ) {\n        return SetModeEntry(user_mode, group_mode, other_mode, special_mode, flags);\n    }\n    \n    // Read all entries in directory\n    unique_ptr<TEntries> contents(GetEntriesPtr());\n    if (!contents.get()) {\n        LOG_ERROR(74, \"CDir::SetMode(): Cannot get content of: \" + GetPath());\n        return false;\n    }\n\n    try {\n        // Process each entry\n        ITERATE(TEntries, entry, *contents.get()) {\n            string name = (*entry)->GetName();\n            if (name == \".\" || name == \"..\" ||\n                name == string(1, GetPathSeparator())) {\n                continue;\n            }\n            // Get entry item with full pathname.\n            CDirEntry item(GetPath() + GetPathSeparator() + name);\n            if (flags & fDir_Recursive) {\n                // Update flags to process subdirectories itself,\n                // because the top directory entry may not have such flag.\n                int f = (flags & fDir_Subdirs) ? (flags | fDir_Self) : flags;\n                if (item.IsDir(eIgnoreLinks)) {\n                    if (!CDir(item.GetPath()).SetMode(user_mode, group_mode, other_mode, special_mode, f)) {\n                        throw \"Changing mode for subdirectory failed\";\n                    }\n                }\n                else if (flags & fDir_Files) {\n                    if (!item.SetModeEntry(user_mode, group_mode, other_mode, special_mode, f)) {\n                        throw \"Changing mode for subdirectory entry failed\";\n                    }\n                }\n            }\n            else if (item.IsDir(eIgnoreLinks)) {\n                // Non-recursive directory processing\n                if (flags & fDir_Subdirs) {\n                    // Clear all flags to go inside directory,\n                    // and try to change modes for entry only.\n                    if (!CDir(item.GetPath()).SetMode(user_mode, group_mode, other_mode, special_mode,\n                        (flags & ~fDir_All) | fDir_Self)) {\n                        throw \"Changing mode for subdirectory (non-recursive) failed\";\n                    }\n                }\n                continue;\n            }\n            else {\n                if (flags & fDir_Files) {\n                    if (!item.SetModeEntry(user_mode, group_mode, other_mode, special_mode, flags)) {\n                        // Changing mode for a regular file entry failed\n                        throw \"Changing mode for subdirectory entry failed\";\n                    }\n                }\n            }\n        }\n    }\n    catch (const char* what) {\n        // The error is may be reported already in child .SetMode() for recursive calls,\n        // but add an additional error log for the current directory itself. \n        LOG_ERROR(94, \"CDir::SetMode(): Cannot change mode for directory: \" + GetPath() + \": \" + what);\n        return false;\n    }\n\n    // Process directory entry\n    if (flags & fDir_Self) {\n        // Change mode for entry/directory itself.\n        return SetModeEntry(user_mode, group_mode, other_mode, special_mode, fEntry);\n    }\n    return true;\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CSymLink\n//\n\nCSymLink::~CSymLink(void)\n{ \n    return;\n}\n\n\nbool CSymLink::Create(const string& path) const\n{\n#if defined(NCBI_OS_UNIX)\n    char buf[PATH_MAX + 1];\n    int len = (int)readlink(_T_XCSTRING(GetPath()), buf, sizeof(buf) - 1);\n    if (len >= 0) {\n        buf[len] = '\\0';\n        if (strcmp(buf, path.c_str()) == 0) {\n            return true;\n        }\n    }\n    // Leave it to the kernel to decide whether the symlink can be recreated\n    if ( symlink(_T_XCSTRING(path), _T_XCSTRING(GetPath())) == 0 ) {\n        return true;\n    }\n    LOG_ERROR_ERRNO(75, \"CSymLink::Create(): failed: \" + path);\n#else\n    LOG_ERROR_NCBI(76, \"CSymLink::Create():\"\n                       \" Symbolic links not supported on this platform: \"\n                       + path, CNcbiError::eNotSupported);\n#endif\n    return false;\n}\n\n\nbool CSymLink::Copy(const string& new_path, TCopyFlags flags, size_t buf_size) const\n{\n#if defined(NCBI_OS_UNIX)\n\n    // Dereference link if specified\n    if ( F_ISSET(flags, fCF_FollowLinks) ) {\n        switch ( GetType(eFollowLinks) ) {\n            case eFile:\n                return CFile(*this).Copy(new_path, flags, buf_size);\n            case eDir:\n                return CDir(*this).Copy(new_path, flags, buf_size);\n            case eLink:\n                return CSymLink(*this).Copy(new_path, flags, buf_size);\n            default:\n                return CDirEntry(*this).Copy(new_path, flags, buf_size);\n        }\n        // not reached\n    }\n\n    // The source link must exists\n    EType src_type = GetType(eIgnoreLinks);\n    if ( src_type == eUnknown )  {\n        LOG_ERROR_NCBI(77, \"CSymLink::Copy(): Unknown entry type \" + GetPath(),\n                       CNcbiError::eNoSuchFileOrDirectory);\n        return false;\n    }\n\n    CSymLink dst(new_path);\n    EType    dst_type = dst.GetType(eIgnoreLinks);\n    bool     dst_exists = (dst_type != eUnknown);\n    string   dst_safe_path;  // saved path for fCF_Safe\n\n    // If destination exists...\n    if ( dst_exists ) {\n        // Check on copying link into yourself.\n        if ( IsIdentical(dst.GetPath()) ) {\n            LOG_ERROR_NCBI(78, \"CSymLink::Copy(): Source and destination are the same: \" + GetPath(),\n                           CNcbiError::eInvalidArgument);\n            return false;\n        }\n        // Can copy entries with different types?\n        if ( F_ISSET(flags, fCF_EqualTypes)  &&  (src_type != dst_type) ) {\n            LOG_ERROR_NCBI(79, \"CSymLink::Copy(): Cannot copy entries with different types: \" + GetPath(),\n                           CNcbiError::eOperationNotPermitted);\n            return false;\n        }\n        // Can overwrite entry?\n        if ( !F_ISSET(flags, fCF_Overwrite) ) {\n            LOG_ERROR_NCBI(80, \"CSymLink::Copy(): Destination already exists: \" + dst.GetPath(),\n                           CNcbiError::eOperationNotPermitted);\n            return false;\n        }\n        // Copy only if destination is older\n        if ( F_ISSET(flags, fCF_Update)  &&  !IsNewer(dst.GetPath(), 0)) {\n            return true;\n        }\n        // Backup destination entry first\n        if ( F_ISSET(flags, fCF_Backup) ) {\n            // Use a new CDirEntry object for 'dst', because its path\n            // will be changed after backup\n            CDirEntry dst_tmp(dst);\n            if ( !dst_tmp.Backup(GetBackupSuffix(), eBackup_Rename) ) {\n                LOG_ERROR(81, \"CSymLink::Copy(): Cannot backup destination: \" + dst.GetPath());\n                return false;\n            }\n        }\n        // Overwrite destination entry\n        if ( F_ISSET(flags, fCF_Overwrite) ) {\n            dst.Remove();\n        } \n    }\n    // Safe copy -- create temporary symlink and rename later\n    if (F_ISSET(flags, fCF_Safe)) {\n        // Get new temporary name in the same directory\n        string path, name, ext;\n        SplitPath(dst.GetPath(), &path, &name, &ext);\n        string tmp = GetTmpNameEx(path.empty() ? CDir::GetCwd() : path, name + ext + kTmpSafeSuffix);\n        // Set new destination\n        dst_safe_path = dst.GetPath();\n        dst.Reset(tmp);\n    }\n    else {\n        // Overwrite destination entry\n        if (dst_exists  &&  F_ISSET(flags, fCF_Overwrite)) {\n            dst.Remove();\n        }\n    }\n    // Copy symbolic link (create new one)\n    char buf[PATH_MAX + 1];\n    int  len = (int)readlink(_T_XCSTRING(GetPath()), buf, sizeof(buf)-1);\n    if (len < 1) {\n        LOG_ERROR_ERRNO(82, \"CSymLink::Copy(): Cannot read symbolic link: \" + GetPath());\n        return false;\n    }\n    buf[len] = '\\0';\n    if (symlink(buf, _T_XCSTRING(dst.GetPath()))) {\n        LOG_ERROR_ERRNO(83, \"CSymLink::Copy():\"\n                            \" Cannot create symbolic link \" + dst.GetPath() + \n                            \" to \" + string(buf));\n        return false;\n    }\n\n    // Safe copy -- renaming\n    if (F_ISSET(flags, fCF_Safe)) {\n        if (!dst.Rename(dst_safe_path, fRF_Overwrite)) {\n            dst.Remove();\n            LOG_ERROR_NCBI(84, \"CSymLink:Copy():\"\n                               \" Cannot rename temporary symlink \" + dst.GetPath() +\n                               \" to \" + dst_safe_path, CNcbiError::eIoError);\n            return false;\n        }\n    }\n    // Preserve attributes\n    if (flags & fCF_PreserveAll) {\n        if (!s_CopyAttrs(GetPath().c_str(), new_path.c_str(), eLink, flags)) {\n            LOG_ERROR(100, \"CSymLink::Copy(): Cannot copy permissions from \" + \n                          GetPath() + \" to \" + new_path);\n            return false;\n        }\n    }\n    return true;\n\n#else\n    // Windows -- regular copy\n    return CParent::Copy(new_path, flags, buf_size);\n#endif\n}\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CFileUtil\n//\n\n/// Flags to get information about file system.\n/// Each flag corresponds to one or some fields in\n/// the CFileUtil::SFileSystemInfo structure.\nenum EFileSystemInfo {\n    fFSI_Type        = (1<<1),    ///< fs_type\n    fFSI_DiskSpace   = (1<<2),    ///< total_space, free_space\n    fFSI_BlockSize   = (1<<3),    ///< block_size\n    fFSI_FileNameMax = (1<<4),    ///< filename_max\n    fFSI_All         = 0xFF       ///< get all possible information\n};\ntypedef int TFileSystemInfo;      ///< Binary OR of \"EFileSystemInfo\"\n\n// File system identification strings\nstruct SFileSystem {\n    const char*                name;\n    CFileUtil::EFileSystemType type;\n};\n\n// File system identification table\nstatic const SFileSystem s_FileSystem[] = {\n    { \"ADFS\",    CFileUtil::eADFS    },\n    { \"ADVFS\",   CFileUtil::eAdvFS   },\n    { \"AFFS\",    CFileUtil::eAFFS    },\n    { \"AUTOFS\",  CFileUtil::eAUTOFS  },\n    { \"CACHEFS\", CFileUtil::eCacheFS },\n    { \"CD9669\",  CFileUtil::eCDFS    },\n    { \"CDFS\",    CFileUtil::eCDFS    },\n    { \"DEVFS\",   CFileUtil::eDEVFS   },\n    { \"DFS\",     CFileUtil::eDFS     },\n    { \"DOS\",     CFileUtil::eFAT     },\n    { \"EXT\",     CFileUtil::eExt     },\n    { \"EXT2\",    CFileUtil::eExt2    },\n    { \"EXT3\",    CFileUtil::eExt3    },\n    { \"FAT\",     CFileUtil::eFAT     },\n    { \"FAT32\",   CFileUtil::eFAT32   },\n    { \"FDFS\",    CFileUtil::eFDFS    },\n    { \"FFM\",     CFileUtil::eFFM     },\n    { \"FFS\",     CFileUtil::eFFS     },\n    { \"HFS\",     CFileUtil::eHFS     },\n    { \"HSFS\",    CFileUtil::eHSFS    },\n    { \"HPFS\",    CFileUtil::eHPFS    },\n    { \"JFS\",     CFileUtil::eJFS     },\n    { \"LOFS\",    CFileUtil::eLOFS    },\n    { \"MFS\",     CFileUtil::eMFS     },\n    { \"MSFS\",    CFileUtil::eMSFS    },\n    { \"NFS\",     CFileUtil::eNFS     },\n    { \"NFS2\",    CFileUtil::eNFS     },\n    { \"NFSV2\",   CFileUtil::eNFS     },\n    { \"NFS3\",    CFileUtil::eNFS     },\n    { \"NFSV3\",   CFileUtil::eNFS     },\n    { \"NFS4\",    CFileUtil::eNFS     },\n    { \"NFSV4\",   CFileUtil::eNFS     },\n    { \"NTFS\",    CFileUtil::eNTFS    },\n    { \"PCFS\",    CFileUtil::eFAT     },\n    { \"PROC\",    CFileUtil::ePROC    },\n    { \"PROCFS\",  CFileUtil::ePROC    },\n    { \"RFS\",     CFileUtil::eRFS     },\n    { \"SMBFS\",   CFileUtil::eSMBFS   },\n    { \"SPECFS\",  CFileUtil::eSPECFS  },\n    { \"TMP\",     CFileUtil::eTMPFS   },\n    { \"UFS\",     CFileUtil::eUFS     },\n    { \"VXFS\",    CFileUtil::eVxFS    },\n    { \"XFS\",     CFileUtil::eXFS     }\n};\n\n\n// Macros to get filesystem status information\n\n#define GET_STATVFS_INFO                                       \\\n    struct statvfs st;                                         \\\n    memset(&st, 0, sizeof(st));                                \\\n    if (statvfs(path.c_str(), &st) != 0) {                     \\\n        CNcbiError::SetFromErrno();                            \\\n        NCBI_THROW(CFileErrnoException, eFileSystemInfo, string(msg) + path); \\\n    }                                                          \\\n    info->total_space  = (Uint8)st.f_bsize * st.f_blocks;      \\\n    if (st.f_frsize) {                                         \\\n        info->free_space = (Uint8)st.f_frsize * st.f_bavail;   \\\n        info->block_size = (unsigned long)st.f_frsize;         \\\n    } else {                                                   \\\n        info->free_space = (Uint8)st.f_bsize * st.f_bavail;    \\\n        info->block_size = (unsigned long)st.f_bsize;          \\\n    }                                                          \\\n    info->used_space   = info->total_space - info->free_space\n\n\n#define GET_STATFS_INFO                                        \\\n    struct statfs st;                                          \\\n    memset(&st, 0, sizeof(st));                                \\\n    if (statfs(path.c_str(), &st) != 0) {                      \\\n        CNcbiError::SetFromErrno();                            \\\n        NCBI_THROW(CFileErrnoException, eFileSystemInfo,  string(msg) + path); \\\n    }                                                          \\\n    info->total_space  = (Uint8)st.f_bsize * st.f_blocks;      \\\n    info->free_space   = (Uint8)st.f_bsize * st.f_bavail;      \\\n    info->used_space   = info->total_space - info->free_space; \\\n    info->block_size   = (unsigned long)st.f_bsize\n\n\n\n#if defined(SUPPORT_PANFS)\n\n// Auxiliary function to exit from forked process with reporting errno\n// on errors to specified file descriptor \nstatic void s_PipeExit(int status, int fd)\n{\n    int errcode = errno;\n    _no_warning(::write(fd, &errcode, sizeof(errcode)));\n    ::close(fd);\n    ::_exit(status);\n}\n\n// Close pipe handle\n#define CLOSE_PIPE_END(fd) \\\n    if (fd != -1) {        \\\n        ::close(fd);       \\\n        fd = -1;           \\\n    }\n\n// Standard kernel calls cannot get correct information \n// about PANFS mounts, so we use workaround for that.\n//\n// Use external method fist, if 'ncbi_panfs.so' exists and can be loaded.\n// Fall back to 'pan_df' utuility (if present).\n// Fall back to use standard OS info if none of above works.\n//\nvoid s_GetDiskSpace_PANFS(const string& path, CFileUtil::SFileSystemInfo* info)\n{\n    DEFINE_STATIC_FAST_MUTEX(s_Mutex);\n    CFastMutexGuard guard_mutex(s_Mutex);\n\n    // TRUE if initialization has done for EXE method\n    static bool s_InitEXE  = false;\n    static bool s_ExistEXE = false;\n    \n#if defined(ALLOW_USE_NCBI_PANFS_DLL)\n\n    // TRUE if initialization has done for DLL method\n    static bool s_InitDLL = false;\n    static FGetDiskSpace_PANFS f_GetDiskSpace = NULL;\n   \n    if ( !s_InitDLL ) {\n        s_InitDLL = true;\n\n        #define STRINGIFY(x) #x\n        #define TOSTRING(x) STRINGIFY(x)\n        const char* kNcbiPanfsDLL = \"/opt/ncbi/\" TOSTRING(NCBI_PLATFORM_BITS) \"/lib/ncbi_panfs.so\";\n        \n        // Check if 'ncbi_panfs.so' exists and can be loaded\n        if ( CFile(kNcbiPanfsDLL).Exists() ) {\n            void* handle = ::dlopen(kNcbiPanfsDLL, RTLD_NOW | RTLD_GLOBAL);\n            const char* err = NULL;\n            if ( handle ) {\n                f_GetDiskSpace = (FGetDiskSpace_PANFS) ::dlsym(handle, \"ncbi_GetDiskSpace_PANFS\");\n                if ( !f_GetDiskSpace ) {\n                    err = \"Undefined symbol\";\n                }\n            } else {\n                err = \"Cannot open shared object file\";\n            }\n            if ( err ) {\n                char* dlerr = dlerror();\n                string msg = \"Trying to get ncbi_GetDiskSpace_PANFS() function from '\" +\n                             string(kNcbiPanfsDLL) + \"': \" + err;\n                if ( dlerr ) {\n                    msg = msg + \" (\" + dlerr + \")\";\n                }\n                LOG_ERROR_NCBI(85, msg, CNcbiError::eUnknown);\n                if ( handle) {\n                    dlclose(handle);\n                }\n            }\n        }\n    }\n   \n    if ( f_GetDiskSpace ) {\n        const char* err_msg = NULL;\n        bool do_throw = false;\n        \n        int res = f_GetDiskSpace(path.c_str(), &info->total_space, &info->free_space, &err_msg);\n        switch ( res ) {\n\n        case NCBI_PANFS_OK:\n            info->used_space = info->total_space - info->free_space;\n            // All done, return\n            return;\n\n        case NCBI_PANFS_THROW:\n             do_throw = true;\n             /*FALLTHRU*/\n             \n        // Same processing for all errors codes, but could be detailed\n        case NCBI_PANFS_ERR:\n        case NCBI_PANFS_ERR_OPEN:\n        case NCBI_PANFS_ERR_QUERY:\n        case NCBI_PANFS_ERR_VERSION:\n        default:\n            {\n                string msg = \"Cannot get information for PANFS mount '\"+ path + \"'\";\n                if ( err_msg ) {\n                    msg += string(\": \") + err_msg;\n                }\n                if ( do_throw ) {\n                    NCBI_THROW(CFileException, eFileSystemInfo, msg);\n                }\n                LOG_ERROR_NCBI(86, msg, CNcbiError::eUnknown);\n            }\n        }\n    }\n#endif // defined(ALLOW_USE_NCBI_PANFS_DLL)\n\n\n    // Cannot use DLL, so -- fall through to use pan_df.\n\n    // -----------------------------------------\n    // Call 'pan_df' utility and parse results\n    // -----------------------------------------\n\n    const char* kPanDF = \"/opt/panfs/bin/pan_df\";\n\n    if ( !s_InitEXE ) {\n        s_InitEXE = true;\n        // Check if 'pan_df' exists\n        if ( CFile(kPanDF).Exists() ) {\n            s_ExistEXE = true;\n        }\n    }\n    \n    if ( s_ExistEXE ) {\n        // Child process I/O handles\n        int status_pipe[2] = {-1,-1};\n        int pipe_fd[2]     = {-1,-1};\n        \n        try {\n            ::fflush(NULL);\n            // Create pipe for child's stdout\n            if (::pipe(pipe_fd) < 0) {\n                throw \"failed to create pipe for stdout\";\n            }\n            // Create temporary pipe to get status of execution\n            // of the child process\n            if (::pipe(status_pipe) < 0) {\n                throw \"failed to create status pipe\";\n            }\n            if (::fcntl(status_pipe[1], F_SETFD, \n                ::fcntl(status_pipe[1], F_GETFD, 0) | FD_CLOEXEC) < 0) {\n                throw \"failed to set close-on-exec mode for status pipe\";\n            }\n\n            // Fork child process\n            pid_t pid = ::fork();\n            if (pid == -1) {\n                throw \"fork() failed\";\n            }\n            if (pid == 0) {\n                // -- Now we are in the child process\n\n                // Close unused pipe handle\n                ::close(status_pipe[0]);\n                // stdin/stderr -- don't use\n                _no_warning(::freopen(\"/dev/null\", \"r\", stdin));\n                _no_warning(::freopen(\"/dev/null\", \"a\", stderr));\n                // stdout\n                if (pipe_fd[1] != STDOUT_FILENO) {\n                    if (::dup2(pipe_fd[1], STDOUT_FILENO) < 0) {\n                        s_PipeExit(-1, status_pipe[1]);\n                    }\n                    ::close(pipe_fd[1]);\n                }\n                ::close(pipe_fd[0]);\n                int status = ::execl(kPanDF, kPanDF, \"--block-size=1\", path.c_str(), NULL);\n                s_PipeExit(status, status_pipe[1]);\n\n                // -- End of child process\n            }\n        \n            // Close unused pipes' ends\n            CLOSE_PIPE_END(pipe_fd[1]);\n            CLOSE_PIPE_END(status_pipe[1]);\n\n            // Check status pipe.\n            // If it have some data, this is an errno from the child process.\n            // If EOF in status pipe, that child executed successful.\n            // Retry if either blocked or interrupted\n\n            // Try to read errno from forked process\n            ssize_t n;\n            int errcode;\n            while ((n = read(status_pipe[0], &errcode, sizeof(errcode))) < 0) {\n                if (errno != EINTR)\n                    break;\n            }\n            CLOSE_PIPE_END(status_pipe[0]);\n            if (n > 0) {\n                // Child could not run -- reap it and exit with error\n                ::waitpid(pid, 0, 0);\n                errno = (size_t) n >= sizeof(errcode) ? errcode : 0;\n                throw \"failed to run pan_df\";\n            }\n\n            // Read data from pipe\n            char buf[1024];\n            while ((n = read(pipe_fd[0], &buf, sizeof(buf)-1)) < 0) {\n                if (errno != EINTR)\n                    break;\n            }\n            CLOSE_PIPE_END(pipe_fd[0]);\n            if ( !n ) {\n                throw \"error reading from pipe\";\n            }\n            buf[n] = '\\0';\n            \n            // Parse resilt\n            const char* kParseError = \"results parse error\";\n            const char* data = strchr(buf, '\\n');\n            if ( !data ) {\n                throw kParseError;\n            }\n            vector<string> tokens;\n            NStr::Split(data + 1, \" \", tokens, NStr::fSplit_MergeDelimiters | NStr::fSplit_Truncate);\n            if ( tokens.size() != 6 ) {\n                throw kParseError;\n            }\n            Uint8 x_total = 1, x_free = 2, x_used = 3; // dummy values\n            try {\n                x_total = NStr::StringToUInt8(tokens[1]);\n                x_free  = NStr::StringToUInt8(tokens[2]);\n                x_used  = NStr::StringToUInt8(tokens[3]);\n            }\n            catch (const CException& e) {\n                throw kParseError;\n            }\n            // Check\n            if ( x_free + x_used != x_total ) {\n                throw kParseError;\n            }\n            info->total_space = x_total;\n            info->free_space  = x_free;\n            info->used_space  = x_used;\n            return;\n        }\n        catch (const char* what) {\n            CLOSE_PIPE_END(pipe_fd[0]);\n            CLOSE_PIPE_END(pipe_fd[1]);\n            CLOSE_PIPE_END(status_pipe[0]);\n            CLOSE_PIPE_END(status_pipe[1]);\n            ERR_POST_X_ONCE(3, Warning << \"Failed to use 'pan_df': \" << what);\n        }           \n    } // if ( s_ExistEXE ) \n    \n    // Failed\n    ERR_POST_X_ONCE(3, Warning << \n                    \"Cannot use any external method to get information about \"\n                    \"PANFS mount, fall back to use standard OS info \"\n                    \"(NOTE: it can be incorrect)\");\n    return;\n}\n\n#endif // defined(SUPPORT_PANFS)\n\n\n\nvoid s_GetFileSystemInfo(const string&               path,\n                         CFileUtil::SFileSystemInfo* info,\n                         TFileSystemInfo             flags)\n{\n    if ( !info ) {\n        NCBI_THROW(CCoreException, eInvalidArg,\n                   \"s_GetFileSystemInfo(path, NULL) is not allowed\");\n    }\n    memset(info, 0, sizeof(*info));\n    const char* msg = \"Cannot get system information for \";\n    const char* fs_name_ptr = 0;\n\n#if defined(NCBI_OS_MSWIN)\n    // Try to get a root disk directory from given path\n    string xpath = path;\n    // Not UNC path\n    if (!s_Win_IsNetworkPath(path)) {\n        if ( !isalpha((unsigned char)path[0]) || path[1] != DISK_SEPARATOR ) {\n            // absolute or relative path without disk name -- current disk,\n            // dir entry should exists\n            if ( CDirEntry(path).Exists() ) {\n                xpath = CDir::GetCwd();\n            }\n        }\n        // Get disk root directory name from the path\n        xpath[2] = '\\\\';\n        xpath.resize(3);\n    }\n\n    // Get volume information\n    TXChar fs_name[MAX_PATH+1];\n    string ufs_name;\n    if (flags & (fFSI_Type | fFSI_FileNameMax))  {\n        DWORD filename_max;\n        DWORD fs_flags;\n\n        if ( !::GetVolumeInformation(_T_XCSTRING(xpath),\n                                     NULL, 0, // Name of the volume\n                                     NULL,    // and its serial number\n                                     &filename_max,\n                                     &fs_flags,\n                                     fs_name,\n                                     sizeof(fs_name)/sizeof(fs_name[0])) ) {\n            NCBI_THROW(CFileErrnoException, eFileSystemInfo, string(msg) + path);\n        }\n        info->filename_max = filename_max;\n        ufs_name = _T_CSTRING(fs_name);\n        fs_name_ptr = ufs_name.c_str();\n    }\n        \n    // Get disk spaces\n    if (flags & fFSI_DiskSpace) {\n        if ( !::GetDiskFreeSpaceEx(_T_XCSTRING(xpath),\n                                   (PULARGE_INTEGER)&info->free_space,\n                                   (PULARGE_INTEGER)&info->total_space, 0) ) {\n            NCBI_THROW(CFileErrnoException, eFileSystemInfo, string(msg) + path);\n        }\n    }\n\n    // Get volume cluster size\n    if (flags & fFSI_BlockSize) {\n        DWORD dwSectPerClust; \n        DWORD dwBytesPerSect;\n        if ( !::GetDiskFreeSpace(_T_XCSTRING(xpath),\n                                 &dwSectPerClust, &dwBytesPerSect,\n                                 NULL, NULL) ) {\n            NCBI_THROW(CFileErrnoException, eFileSystemInfo, string(msg) + path);\n        }\n        info->block_size = dwBytesPerSect * dwSectPerClust;\n    }\n\n#else // defined(NCBI_OS_MSWIN)\n\n    bool need_name_max = true;\n#  ifdef _PC_NAME_MAX\n    long r_name_max = pathconf(path.c_str(), _PC_NAME_MAX);\n    if (r_name_max != -1) {\n        info->filename_max = (unsigned long)r_name_max;\n        need_name_max = false;\n    }\n#  endif\n\n#  if (defined(NCBI_OS_LINUX) || defined(NCBI_OS_CYGWIN))  &&  defined(HAVE_STATFS)\n    \n    GET_STATFS_INFO;\n    if (flags & (fFSI_Type | fFSI_DiskSpace)) {\n        switch (st.f_type) {\n            case 0xADF5:      info->fs_type = CFileUtil::eADFS;     break;\n            case 0xADFF:      info->fs_type = CFileUtil::eAFFS;     break;\n            case 0x5346414F:  info->fs_type = CFileUtil::eAFS;      break;\n            case 0x0187:      info->fs_type = CFileUtil::eAUTOFS;   break;\n            case 0x1BADFACE:  info->fs_type = CFileUtil::eBFS;      break;\n            case 0x4004:\n            case 0x4000:\n            case 0x9660:      info->fs_type = CFileUtil::eCDFS;     break;\n            case 0xF15F:      info->fs_type = CFileUtil::eCryptFS;  break;\n            case 0xFF534D42:  info->fs_type = CFileUtil::eCIFS;     break;\n            case 0x73757245:  info->fs_type = CFileUtil::eCODA;     break;\n            case 0x012FF7B7:  info->fs_type = CFileUtil::eCOH;      break;\n            case 0x28CD3D45:  info->fs_type = CFileUtil::eCRAMFS;   break;\n            case 0x1373:      info->fs_type = CFileUtil::eDEVFS;    break;\n            case 0x414A53:    info->fs_type = CFileUtil::eEFS;      break;\n            case 0x5DF5:      info->fs_type = CFileUtil::eEXOFS;    break;\n            case 0x137D:      info->fs_type = CFileUtil::eExt;      break;\n            case 0xEF51:\n            case 0xEF53:      info->fs_type = CFileUtil::eExt2;     break;\n            case 0x4d44:      info->fs_type = CFileUtil::eFAT;      break;\n            case 0x65735546:  info->fs_type = CFileUtil::eFUSE;     break;\n            case 0x65735543:  info->fs_type = CFileUtil::eFUSE_CTL; break;\n            case 0x01161970:  info->fs_type = CFileUtil::eGFS2;     break;\n            case 0x4244:      info->fs_type = CFileUtil::eHFS;      break;\n            case 0x482B:      info->fs_type = CFileUtil::eHFSPLUS;  break;\n            case 0xF995E849:  info->fs_type = CFileUtil::eHPFS;     break;\n            case 0x3153464A:  info->fs_type = CFileUtil::eJFS;      break;\n            case 0x07C0:      info->fs_type = CFileUtil::eJFFS;     break;\n            case 0x72B6:      info->fs_type = CFileUtil::eJFFS2;    break;\n            case 0x47504653:  info->fs_type = CFileUtil::eGPFS;     break;\n            case 0x137F:\n            case 0x138F:      info->fs_type = CFileUtil::eMinix;    break;\n            case 0x2468:\n            case 0x2478:      info->fs_type = CFileUtil::eMinix2;   break;\n            case 0x4D5A:      info->fs_type = CFileUtil::eMinix3;   break;\n            case 0x564C:      info->fs_type = CFileUtil::eNCPFS;    break;\n            case 0x6969:      info->fs_type = CFileUtil::eNFS;      break;\n            case 0x5346544E:  info->fs_type = CFileUtil::eNTFS;     break;\n            case 0x7461636F:  info->fs_type = CFileUtil::eOCFS2;    break;\n            case 0x9fA1:      info->fs_type = CFileUtil::eOPENPROM; break;\n            case 0xAAD7AAEA:  info->fs_type = CFileUtil::ePANFS;    break;\n            case 0x9fA0:      info->fs_type = CFileUtil::ePROC;     break;\n            case 0x20030528:  info->fs_type = CFileUtil::ePVFS2;    break;\n            case 0x002F:      info->fs_type = CFileUtil::eQNX4;     break;\n            case 0x52654973:  info->fs_type = CFileUtil::eReiserFS; break;\n            case 0x7275:      info->fs_type = CFileUtil::eROMFS;    break;\n            case 0xF97CFF8C:  info->fs_type = CFileUtil::eSELINUX;  break;\n            case 0x517B:      info->fs_type = CFileUtil::eSMBFS;    break;\n            case 0x73717368:  info->fs_type = CFileUtil::eSquashFS; break;\n            case 0x62656572:  info->fs_type = CFileUtil::eSYSFS;    break;\n            case 0x012FF7B6:  info->fs_type = CFileUtil::eSYSV2;    break;\n            case 0x012FF7B5:  info->fs_type = CFileUtil::eSYSV4;    break;\n            case 0x01021994:  info->fs_type = CFileUtil::eTMPFS;    break;\n            case 0x24051905:  info->fs_type = CFileUtil::eUBIFS;    break;\n            case 0x15013346:  info->fs_type = CFileUtil::eUDF;      break;\n            case 0x00011954:  info->fs_type = CFileUtil::eUFS;      break;\n            case 0x19540119:  info->fs_type = CFileUtil::eUFS2;     break;\n            case 0x9fA2:      info->fs_type = CFileUtil::eUSBDEVICE;break;\n            case 0x012FF7B8:  info->fs_type = CFileUtil::eV7;       break;\n            case 0xa501FCF5:  info->fs_type = CFileUtil::eVxFS;     break;\n            case 0x565a4653:  info->fs_type = CFileUtil::eVZFS;     break;\n            case 0x012FF7B4:  info->fs_type = CFileUtil::eXENIX;    break;\n            case 0x58465342:  info->fs_type = CFileUtil::eXFS;      break;\n            case 0x012FD16D:  info->fs_type = CFileUtil::eXIAFS;    break;\n            default:          info->fs_type = CFileUtil::eUnknown;  break;\n        }\n    }\n    if (need_name_max) {\n        info->filename_max = (unsigned long)st.f_namelen;\n    }\n\n#  elif (defined(NCBI_OS_SOLARIS) || defined(NCBI_OS_IRIX) || defined(NCBI_OS_OSF1)) \\\n         &&  defined(HAVE_STATVFS)\n\n    GET_STATVFS_INFO;\n    if (need_name_max) {\n        info->filename_max = (unsigned long)st.f_namemax;\n    }\n    fs_name_ptr = st.f_basetype;\n\n#  elif defined(NCBI_OS_DARWIN)  &&  defined(HAVE_STATFS)\n\n    GET_STATFS_INFO;\n    // Seems statfs structure on Darwin doesn't have any information \n    // about name length, so rely on pathconf() only.\n    //if (need_name_max) {\n    //    info->filename_max = (unsigned long)st.f_namelen;\n    //}\n    fs_name_ptr = st.f_fstypename;\n\n#  elif defined(NCBI_OS_BSD)  &&  defined(HAVE_STATFS)\n\n    GET_STATFS_INFO;\n    fs_name_ptr = st.f_fstypename;\n    if (need_name_max) {\n        info->filename_max = (unsigned long)st.f_namemax;\n    }\n\n#  elif defined(NCBI_OS_OSF1)  &&  defined(HAVE_STATVFS)\n\n    GET_STATVFS_INFO;\n    if (need_name_max) {\n        info->filename_max = (unsigned long)st.f_namelen;\n    }\n    fs_name_ptr = st.f_fstypename;\n\n#  else\n\n     // Unknown UNIX OS\n    #if defined(HAVE_STATVFS)\n        GET_STATVFS_INFO;\n    #elif defined(HAVE_STATFS)\n        GET_STATFS_INFO;\n    #endif\n\n#  endif\n#endif\n\n    // Try to define file system type by name\n    if ((flags & fFSI_Type)  &&  fs_name_ptr) {\n        for (size_t i=0; \n             i < sizeof(s_FileSystem)/sizeof(s_FileSystem[0]); i++) {\n            if ( NStr::EqualNocase(fs_name_ptr, s_FileSystem[i].name) ) {\n                info->fs_type = s_FileSystem[i].type;\n                break;\n            }\n        }\n    }\n\n#if defined(SUPPORT_PANFS)\n    // Standard kernel calls cannot get correct information \n    // about PANFS mounts, so we use workaround for that.\n    if ((info->fs_type == CFileUtil::ePANFS) && (flags & fFSI_DiskSpace)) {\n        s_GetDiskSpace_PANFS(path, info);\n    }\n#endif\n}\n\n\nvoid CFileUtil::GetFileSystemInfo(const string& path, CFileUtil::SFileSystemInfo* info)\n{\n    s_GetFileSystemInfo(path, info, fFSI_All);\n}\n\n\nUint8 CFileUtil::GetFreeDiskSpace(const string& path)\n{\n    SFileSystemInfo info;\n    s_GetFileSystemInfo(path, &info, fFSI_DiskSpace);\n    return info.free_space;\n}\n\n\nUint8 CFileUtil::GetUsedDiskSpace(const string& path)\n{\n    SFileSystemInfo info;\n    s_GetFileSystemInfo(path, &info, fFSI_DiskSpace);\n    return info.used_space;\n}\n\n\nUint8 CFileUtil::GetTotalDiskSpace(const string& path)\n{\n    SFileSystemInfo info;\n    s_GetFileSystemInfo(path, &info, fFSI_DiskSpace);\n    return info.total_space;\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CFileDeleteList / CFileDeleteAtExit\n//\n\nCFileDeleteList::~CFileDeleteList()\n{\n    ITERATE (TList, path, m_Paths) {\n        if (!CDirEntry(*path).Remove(CDirEntry::eRecursiveIgnoreMissing)) {\n            ERR_POST_X(5, Warning << \"CFileDeleteList: failed to remove path: \" << *path);\n        }\n    }\n}\n\nvoid CFileDeleteAtExit::Add(const string& path)\n{\n    s_DeleteAtExitFileList->Add(path);\n}\n\nconst CFileDeleteList& CFileDeleteAtExit::GetDeleteList(void)\n{\n    return *s_DeleteAtExitFileList;\n}\n\nvoid CFileDeleteAtExit::SetDeleteList(CFileDeleteList& list)\n{\n    *s_DeleteAtExitFileList = list;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CTmpFile\n//\n\n\nCTmpFile::CTmpFile(ERemoveMode remove_file)\n{\n    m_FileName = CFile::GetTmpName();\n    if ( m_FileName.empty() ) {\n        NCBI_THROW(CFileException, eTmpFile, \"Cannot generate temporary file name\");\n    }\n    m_RemoveOnDestruction = remove_file;\n}\n\nCTmpFile::CTmpFile(const string& file_name, ERemoveMode remove_file)\n    : m_FileName(file_name), \n      m_RemoveOnDestruction(remove_file)\n{\n    return;\n}\n\nCTmpFile::~CTmpFile()\n{\n    // First, close and delete created streams.\n    m_InFile.reset();\n    m_OutFile.reset();\n\n    // Remove file if specified\n    if (m_RemoveOnDestruction == eRemove) {\n        NcbiSys_unlink(_T_XCSTRING(m_FileName));\n    }\n}\n\n    enum EIfExists {\n        /// You can make call of AsInputFile/AsOutputFile only once,\n        /// on each following call throws CFileException exception.\n        eIfExists_Throw,\n        /// Delete previous stream and return reference to new object.\n        eIfExists_Reset,\n        /// Return reference to current stream, or new if this is first call.\n        eIfExists_ReturnCurrent\n    };\n\n    // CTmpFile\n\nconst string& CTmpFile::GetFileName(void) const\n{\n    return m_FileName;\n}\n\n\nCNcbiIstream& CTmpFile::AsInputFile(EIfExists if_exists, IOS_BASE::openmode mode)\n{\n    if ( m_InFile.get() ) {\n        switch (if_exists) {\n        case eIfExists_Throw:\n            NCBI_THROW(CFileException, eTmpFile, \"AsInputFile() is already called\");\n            /*NOTREACHED*/\n            break;\n        case eIfExists_Reset:\n            // see below\n            break;\n        case eIfExists_ReturnCurrent:\n            return *m_InFile;\n        }\n    }\n    m_InFile.reset(new CNcbiIfstream(_T_XCSTRING(m_FileName), IOS_BASE::in | mode));\n    return *m_InFile;\n}\n\n\nCNcbiOstream& CTmpFile::AsOutputFile(EIfExists if_exists, IOS_BASE::openmode mode)\n{\n    if ( m_OutFile.get() ) {\n        switch (if_exists) {\n        case eIfExists_Throw:\n            NCBI_THROW(CFileException, eTmpFile, \"AsOutputFile() is already called\");\n            /*NOTREACHED*/\n            break;\n        case eIfExists_Reset:\n            // see below\n            break;\n        case eIfExists_ReturnCurrent:\n            return *m_OutFile;\n        }\n    }\n    m_OutFile.reset(new CNcbiOfstream(_T_XCSTRING(m_FileName), IOS_BASE::out | mode));\n    return *m_OutFile;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CMemoryFile\n//\n\n// Platform-dependent memory file handle definition\nstruct SMemoryFileHandle {\n#if defined(NCBI_OS_MSWIN)\n    HANDLE  hMap;   // File-mapping handle (see ::[Open/Create]FileMapping())\n#else /* UNIX */\n    int     hMap;   // File handle\n#endif\n    string  sFileName;\n};\n\n// Platform-dependent memory file attributes\nstruct SMemoryFileAttrs {\n#if defined(NCBI_OS_MSWIN)\n    DWORD map_protect;\n    DWORD map_access;\n    DWORD file_share;\n    DWORD file_access;\n#else\n    int   map_protect;\n    int   map_access;\n    int   file_access;\n#endif\n};\n\n\n// Translate memory mapping attributes into OS specific flags.\nstatic SMemoryFileAttrs*\ns_TranslateAttrs(CMemoryFile_Base::EMemMapProtect protect_attr, \n                 CMemoryFile_Base::EMemMapShare   share_attr)\n{\n    SMemoryFileAttrs* attrs = new SMemoryFileAttrs();\n    memset(attrs, 0, sizeof(SMemoryFileAttrs));\n\n#if defined(NCBI_OS_MSWIN)\n\n    switch (protect_attr) {\n        case CMemoryFile_Base::eMMP_Read:\n            attrs->map_access  = FILE_MAP_READ;\n            attrs->map_protect = PAGE_READONLY;\n            attrs->file_access = GENERIC_READ;\n            break;\n        case CMemoryFile_Base::eMMP_Write:\n        case CMemoryFile_Base::eMMP_ReadWrite:\n            // On MS Windows platform Write & ReadWrite access\n            // to the mapped memory is equivalent\n            if  (share_attr == CMemoryFile_Base::eMMS_Shared ) {\n                attrs->map_access = FILE_MAP_ALL_ACCESS;\n            } else {\n                attrs->map_access = FILE_MAP_COPY;\n            }\n            attrs->map_protect = PAGE_READWRITE;\n            // So the file also must be open for reading and writing\n            attrs->file_access = GENERIC_READ | GENERIC_WRITE;\n            break;\n        default:\n            _TROUBLE;\n    }\n    if ( share_attr == CMemoryFile_Base::eMMS_Shared ) {\n        attrs->file_share = FILE_SHARE_READ | FILE_SHARE_WRITE;\n    } else {\n        attrs->file_share = FILE_SHARE_READ;\n    }\n\n#elif defined(NCBI_OS_UNIX)\n\n    switch (share_attr) {\n        case CMemoryFile_Base::eMMS_Shared:\n            attrs->map_access  = MAP_SHARED;\n            // Read + write except, eMMP_Read mode\n            attrs->file_access = O_RDWR;\n            break;\n        case CMemoryFile_Base::eMMS_Private:\n            attrs->map_access  = MAP_PRIVATE;\n            // In the private mode writing to the mapped region\n            // do not affect the original file, so we can open it\n            // in the read-only mode.\n            attrs->file_access = O_RDONLY;\n            break;\n        default:\n            _TROUBLE;\n    }\n    switch (protect_attr) {\n        case CMemoryFile_Base::eMMP_Read:\n            attrs->map_protect = PROT_READ;\n            attrs->file_access = O_RDONLY;\n            break;\n        case CMemoryFile_Base::eMMP_Write:\n            attrs->map_protect = PROT_WRITE;\n            break;\n        case CMemoryFile_Base::eMMP_ReadWrite:\n            attrs->map_protect = PROT_READ | PROT_WRITE;\n            break;\n        default:\n            _TROUBLE;\n    }\n\n#endif\n    return attrs;\n}\n\n\nCMemoryFile_Base::CMemoryFile_Base(void)\n{\n    // Check if memory-mapping is supported on this platform\n    if ( !IsSupported() ) {\n        NCBI_THROW(CFileException, eMemoryMap,\n                   \"Memory-mapping is not supported by the C++ Toolkit on this platform\");\n    }\n}\n\n\nbool CMemoryFile_Base::IsSupported(void)\n{\n#if defined(NCBI_OS_MSWIN)  ||  defined(NCBI_OS_UNIX)\n    return true;\n#else\n    return false;\n#endif\n}\n\n\nCMemoryFileSegment::CMemoryFileSegment(SMemoryFileHandle& handle,\n                                       SMemoryFileAttrs&  attrs,\n                                       TOffsetType        offset,\n                                       size_t             length)\n    : m_DataPtr(0), m_Offset(offset), m_Length(length),\n      m_DataPtrReal(0), m_OffsetReal(offset), m_LengthReal(length)\n{\n    if ( m_Offset < 0 ) {\n        NCBI_THROW(CFileException, eMemoryMap,\n                   \"File offset may not be negative\");\n    }\n    if ( !m_Length ) {\n        NCBI_THROW(CFileException, eMemoryMap,\n                   \"File mapping region size must be greater than 0\");\n    }\n    // Get system's memory allocation granularity.\n    // Note, GetVirtualMemoryAllocationGranularity() cache it. \n    unsigned long vm_gran = CSystemInfo::GetVirtualMemoryAllocationGranularity();\n\n    if ( !vm_gran ) {\n        NCBI_THROW(CFileException, eMemoryMap,\n                   \"Cannot determine virtual memory allocation granularity\");\n    }\n    // Adjust mapped length and offset.\n    if ( m_Offset % vm_gran ) {\n        m_OffsetReal -= m_Offset % vm_gran;\n        m_LengthReal += m_Offset % vm_gran;\n    }\n    // Map file view to memory\n    string errmsg;\n\n#if defined(NCBI_OS_MSWIN)\n    DWORD offset_hi  = DWORD(Int8(m_OffsetReal) >> 32);\n    DWORD offset_low = DWORD(Int8(m_OffsetReal) & 0xFFFFFFFF);\n    m_DataPtrReal = ::MapViewOfFile(handle.hMap, attrs.map_access, offset_hi, offset_low, m_LengthReal);\n    if ( !m_DataPtrReal ) {\n        errmsg = WIN_LAST_ERROR_STR;\n    }\n\n#elif defined(NCBI_OS_UNIX)\n    errno = 0;\n    m_DataPtrReal = mmap(0, m_LengthReal, attrs.map_protect,\n                         attrs.map_access, handle.hMap, m_OffsetReal);\n    if ( m_DataPtrReal == MAP_FAILED ) {\n        m_DataPtrReal = 0;\n        errmsg = NcbiSys_strerror(errno);\n    }\n#endif\n    if ( !m_DataPtrReal ) {\n        NCBI_THROW(CFileException, eMemoryMap,\n                   \"Cannot map file '\" + \n                   handle.sFileName + \"' to memory (offset=\" +\n                   NStr::Int8ToString(m_Offset) + \", length=\" +\n                   NStr::Int8ToString(m_Length) + \"): \" + errmsg);\n    }\n    // Calculate user's pointer to data\n    m_DataPtr = (char*)m_DataPtrReal + (m_Offset - m_OffsetReal);\n}\n\n\nCMemoryFileSegment::~CMemoryFileSegment(void)\n{\n    Unmap();\n}\n\n\nbool CMemoryFileSegment::Flush(void) const\n{\n    if ( !m_DataPtr ) {\n        CNcbiError::Set(CNcbiError::eBadAddress);\n        return false;\n    }\n    bool status;\n#if defined(NCBI_OS_MSWIN)\n    status = (::FlushViewOfFile(m_DataPtrReal, m_LengthReal) != 0);\n    if ( !status ) {\n        LOG_ERROR_WIN(87, \"CMemoryFileSegment::Flush(): Cannot flush memory segment\");\n        return false;\n    }\n#elif defined(NCBI_OS_UNIX)\n    status = (msync((char*)m_DataPtrReal, m_LengthReal, MS_SYNC) == 0);\n    if ( !status ) {\n        LOG_ERROR_ERRNO(87, \"CMemoryFileSegment::Flush(): Cannot flush memory segment\");\n        return false;\n    }\n#endif\n    return status;\n}\n\n\nbool CMemoryFileSegment::Unmap(void)\n{\n    // If file view is not mapped do nothing\n    if ( !m_DataPtr ) {\n        CNcbiError::Set(CNcbiError::eBadAddress);\n        return true;\n    }\n    bool status;\n#if defined(NCBI_OS_MSWIN)\n    status = (::UnmapViewOfFile(m_DataPtrReal) != 0);\n    if (!status) {\n        LOG_ERROR_WIN(88, \"CMemoryFileSegment::Unmap(): Cannot unmap memory segment\");\n        return false;\n    }\n#elif defined(NCBI_OS_UNIX)\n    status = (munmap((char*)m_DataPtrReal, (size_t) m_LengthReal) == 0);\n    if (!status) {\n        LOG_ERROR_ERRNO(88, \"CMemoryFileSegment::Unmap(): Cannot unmap memory segment\");\n        return false;\n    }\n#endif\n    if ( status ) {\n        m_DataPtr = 0;\n    }\n    return status;\n}\n\n\nvoid CMemoryFileSegment::x_Verify(void) const\n{\n    if ( m_DataPtr ) {\n        return;\n    }\n    NCBI_THROW(CFileException, eMemoryMap, \"File not mapped\");\n}\n\n\nCMemoryFileMap::CMemoryFileMap(const string&  file_name,\n                               EMemMapProtect protect,\n                               EMemMapShare   share,\n                               EOpenMode      mode,\n                               Uint8          max_file_len)\n    : m_FileName(file_name), m_Handle(0), m_Attrs(0)\n{\n#if defined(NCBI_OS_MSWIN)\n    // Name of a file-mapping object cannot contain '\\'\n    NStr::ReplaceInPlace(m_FileName, \"\\\\\", \"/\");\n#endif\n\n    // Translate attributes \n    m_Attrs = s_TranslateAttrs(protect, share);\n\n    // Create file if necessary\n    if ( mode == eCreate ) {\n        x_Create(max_file_len);\n    }\n    // Check file size\n    Int8 file_size = GetFileSize();\n    if ( file_size < 0 ) {\n        if ( m_Attrs ) {\n            delete m_Attrs;\n            m_Attrs = 0;\n        }\n        NCBI_THROW(CFileException, eMemoryMap,\n                   \"To be memory mapped the file must exist: '\" + m_FileName +\"'\");\n    }\n    // Extend file size if necessary\n    if ( mode == eExtend  &&  max_file_len > (Uint8)file_size) {\n        x_Extend(file_size, max_file_len);\n        file_size = (Int8)max_file_len;\n    }\n\n    // Open file\n    if ( file_size == 0 ) {\n        // Special case -- file is empty\n        m_Handle = new SMemoryFileHandle();\n        m_Handle->hMap = kInvalidHandle;\n        m_Handle->sFileName = m_FileName;\n        return;\n    }\n    x_Open();\n}\n\n\nCMemoryFileMap::~CMemoryFileMap(void)\n{\n    // Unmap used memory and close file\n    x_Close();\n    // Clean up allocated memory\n    if ( m_Attrs ) {\n        delete m_Attrs;\n    }\n}\n\n\nvoid* CMemoryFileMap::Map(TOffsetType offset, size_t length)\n{\n    if ( !m_Handle  ||  (m_Handle->hMap == kInvalidHandle) ) {\n        // Special case.\n        // Always return 0 if a file is unmapped or have zero length.\n        return 0;\n    }\n    // Map file wholly if the length of the mapped region is not specified\n    if ( !length ) {\n        Int8 file_size = GetFileSize() - offset;\n        if ( (Uint8)file_size > get_limits(length).max() ) {\n            NCBI_THROW(CFileException, eMemoryMap,\n                       \"File too big for memory mapping \"   \\\n                       \"(file '\" + m_FileName +\"', \"\n                       \"offset=\" + NStr::Int8ToString(offset) + \", \"    \\\n                       \"length=\" + NStr::Int8ToString(length) + \")\");\n        } else if ( file_size > 0 ) {\n            length = (size_t)file_size;\n        } else {\n            NCBI_THROW(CFileException, eMemoryMap,\n                       \"Mapping region offset specified beyond file size\");\n        }\n    }\n    // Map file segment\n    CMemoryFileSegment* segment =  new CMemoryFileSegment(*m_Handle, *m_Attrs, offset, length);\n    void* ptr = segment->GetPtr();\n    if ( !ptr ) {\n        delete segment;\n        NCBI_THROW(CFileException, eMemoryMap,\n                   \"Cannot map (file '\" + m_FileName +\"', \"\n                   \"offset=\" + NStr::Int8ToString(offset) + \", \"    \\\n                   \"length=\" + NStr::Int8ToString(length) + \")\");\n    }\n    m_Segments[ptr] = segment;\n    return ptr;\n}\n\n\nbool CMemoryFileMap::Unmap(void* ptr)\n{\n    // Unmap mapped view of a file\n    bool status = false;\n    TSegments::iterator segment = m_Segments.find(ptr);\n    if ( segment != m_Segments.end() ) {\n        status = segment->second->Unmap();\n        if ( status ) {\n            delete segment->second;\n            m_Segments.erase(segment);\n        }\n    }\n    if ( !status ) {\n        LOG_ERROR(89, \"CMemoryFileMap::Unmap(): Memory segment not found\");\n        return false;\n    }\n    return status;\n}\n\n\nbool CMemoryFileMap::UnmapAll(void)\n{\n    bool status = true;\n    void* key_to_delete = 0;\n    ITERATE(TSegments, it, m_Segments) {\n        if ( key_to_delete ) {\n            m_Segments.erase(key_to_delete);\n        }\n        bool unmapped = it->second->Unmap();\n        if ( status ) {\n            status = unmapped;\n        }\n        if ( unmapped ) {\n            key_to_delete = it->first;\n            delete it->second;\n        } else {\n            key_to_delete = 0;\n        }\n    }\n    if ( key_to_delete ) {\n        m_Segments.erase(key_to_delete);\n    }\n    if ( !status ) {\n        LOG_ERROR(89, \"CMemoryFileMap::UnmapAll(): Memory segment not found\");\n        return false;\n    }\n    return status;\n}\n\n\nInt8 CMemoryFileMap::GetFileSize(void) const\n{\n    // On Unix -- mapping handle is the same as file handle,\n    // use it to get file size if file is already opened.\n    #if defined(NCBI_OS_UNIX)\n        if ( m_Handle  &&  (m_Handle->hMap != kInvalidHandle) ) {\n            TNcbiSys_fstat st;\n            if ( NcbiSys_fstat(m_Handle->hMap, &st) != 0 ) {\n                LOG_ERROR_ERRNO(101, \"CMemoryFileMap::GetFileSize(): unable to get file size of the mapped file: \" + m_FileName);\n                return -1L;\n            }\n            return st.st_size;\n        }\n    #endif\n    // On Windows -- file handle is already closed, use file name. \n    return CFile(m_FileName).GetLength();\n}\n\n\nvoid CMemoryFileMap::x_Open(void)\n{\n    m_Handle = new SMemoryFileHandle();\n    m_Handle->hMap = kInvalidHandle;\n    m_Handle->sFileName = m_FileName;\n\n    string errmsg;\n\n    for (;;) { // quasi-TRY block\n\n#if defined(NCBI_OS_MSWIN)\n        errmsg = \": \";\n        TXString filename(_T_XSTRING(m_FileName));\n\n        // If failed to attach to an existing file-mapping object then\n        // create a new one (based on the specified file)\n        HANDLE hMap = ::OpenFileMapping(m_Attrs->map_access, false, filename.c_str());\n        if ( !hMap ) {\n            // Open file\n            HANDLE hFile;\n            hFile = ::CreateFile(filename.c_str(), m_Attrs->file_access, \n                                 m_Attrs->file_share, NULL,\n                                 OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);\n            if ( hFile == INVALID_HANDLE_VALUE ) {\n                errmsg += WIN_LAST_ERROR_STR;\n                break;\n            }\n            // Create mapping\n            hMap = ::CreateFileMapping(hFile, NULL, m_Attrs->map_protect, 0, 0, filename.c_str());\n            if ( !hMap ) {\n                errmsg += WIN_LAST_ERROR_STR;\n                ::CloseHandle(hFile);\n                break;\n            }\n            ::CloseHandle(hFile);\n        }\n        m_Handle->hMap = hMap;\n\n#elif defined(NCBI_OS_UNIX)\n        // Open file\n        errno = 0;\n        m_Handle->hMap = NcbiSys_open(_T_XCSTRING(m_FileName), m_Attrs->file_access);\n        if ( m_Handle->hMap < 0 ) {\n            errmsg = NcbiSys_strerror(errno);\n            break;\n        }\n#endif\n        // Success\n        return;\n    }\n    // Error: close and cleanup\n    x_Close();\n    NCBI_THROW(CFileException, eMemoryMap,\n               \"CMemoryFile: Cannot memory map file '\" + m_FileName + \"':\" + errmsg);\n}\n\n\nvoid CMemoryFileMap::x_Close()\n{\n    // Unmap all mapped segments with error ignoring\n    ITERATE(TSegments, it, m_Segments) {\n        delete it->second;\n    }\n    m_Segments.clear();\n\n    // Close handle and cleanup\n    if ( m_Handle ) {\n        if ( m_Handle->hMap != kInvalidHandle ) { \n#if defined(NCBI_OS_MSWIN)\n            CloseHandle(m_Handle->hMap);\n#elif defined(NCBI_OS_UNIX)\n            close(m_Handle->hMap);\n#endif\n        }\n        delete m_Handle;\n        m_Handle  = 0;\n    }\n}\n\n\n// Extend/truncate file size to 'new_size' bytes.\n// Do not change position in the file.\n// Return 0 on success, or errno value.\n// NOTE: Unix only.\n//\n#if defined(NCBI_OS_UNIX)\nint s_FTruncate(int fd, Uint8 new_size)\n{\n    int errcode = 0;\n    // ftruncate() add zeros\n    while (ftruncate(fd, (off_t)new_size) < 0) {\n        if (errno != EINTR) {\n            errcode = errno;\n            break;\n        }\n    }\n    return errcode;\n}\n#endif\n\n// Extend file size to 'new_size' bytes, 'new_size' should be > current file size.\n// Do not change position in the file.\n// Return 0 on success, or errno value.\n// Similar to s_FTruncate() but can extend file size only. \n// NOTE: \n//   Works on both Windows and Unix, but file should not be opened in append mode,\n//   or write() will ignore current position in the file and starts with EOF.\n//\nint s_FExtend(int fd, Uint8 new_size)\n{\n    if (!new_size) {\n        return 0;\n    }\n    // Save current position\n    off_t current_pos = NcbiSys_lseek(fd, 0, SEEK_CUR);\n    if (current_pos < 0) {\n        return errno;\n    }\n    // Set position beyond EOF, one byte less than necessary,\n    // and write single zero byte.\n    off_t pos = NcbiSys_lseek(fd, (off_t)new_size - 1, SEEK_SET);\n    if (pos < 0) {\n        return errno;\n    }\n    while (NcbiSys_write(fd, \"\\0\", 1) < 0) {\n        if (errno != EINTR) {\n            return errno;\n        }\n    }\n    // Restore current position\n    pos = NcbiSys_lseek(fd, current_pos, SEEK_SET);\n    if (pos < 0) {\n        return errno;\n    }\n    return 0;\n}\n\n\nvoid CMemoryFileMap::x_Create(Uint8 size)\n{\n    int pmode = S_IREAD;\n#if defined(NCBI_OS_MSWIN)\n    if (m_Attrs->file_access & (GENERIC_READ | GENERIC_WRITE)) \n#elif defined(NCBI_OS_UNIX)\n    if (m_Attrs->file_access & O_RDWR) \n#endif\n        pmode |= S_IWRITE;\n\n    // Create new file\n    int fd = NcbiSys_creat(_T_XCSTRING(m_FileName), pmode);\n    if ( fd < 0 ) {\n        NCBI_THROW(CFileException, eMemoryMap, \"CMemoryFileMap:\"\n                   \" Cannot create file '\" + m_FileName + \"'\");\n    }\n    // and fill it with zeros\n    int errcode = s_FExtend(fd, size);\n    NcbiSys_close(fd);\n    if (errcode) {\n#if defined(NCBI_OS_MSWIN)\n        string errmsg = _T_STDSTRING(NcbiSys_strerror(errcode));\n#elif defined(NCBI_OS_UNIX)\n        string errmsg = NcbiSys_strerror(errcode);\n#endif\n        NCBI_THROW(CFileException, eMemoryMap, \"CMemoryFileMap:\"\n                   \" Cannot create file with specified size: \" + errmsg);\n    }\n}\n\n\nvoid CMemoryFileMap::x_Extend(Uint8 size, Uint8 new_size)\n{\n    if (size >= new_size) {\n        return;\n    }\n    // Open file for writing.\n    // Note: do not use append mode, or s_FExtend() will work incorrectly.\n    int fd = NcbiSys_open(_T_XCSTRING(m_FileName), O_WRONLY, 0);\n    if ( fd < 0 ) {\n        int errcode = errno;\n        NCBI_THROW(CFileException, eMemoryMap, \"CMemoryFileMap:\"\n                   \" Cannot open file '\" + m_FileName +\n                   \"' to change its size: \" +\n\t\t\t       _T_STDSTRING(NcbiSys_strerror(errcode)));\n    }\n    // and extend it with zeros\n    int errcode = s_FExtend(fd, new_size);\n    NcbiSys_close(fd);\n    if (errcode) {\n#if defined(NCBI_OS_MSWIN)\n        string errmsg = _T_STDSTRING(NcbiSys_strerror(errcode));\n#elif defined(NCBI_OS_UNIX)\n        string errmsg = NcbiSys_strerror(errcode);\n#endif\n        NCBI_THROW(CFileException, eMemoryMap, \"CMemoryFileMap:\"\n                   \" Cannot extend file size: \" + errmsg);\n    }\n}\n\n\nCMemoryFileSegment* \nCMemoryFileMap::x_GetMemoryFileSegment(void* ptr) const\n{\n    if ( !m_Handle  ||  (m_Handle->hMap == kInvalidHandle) ) {\n        NCBI_THROW(CFileException, eMemoryMap, \"CMemoryFileMap:\"\n                   \" File is not mapped\");\n    }\n    TSegments::const_iterator segment = m_Segments.find(ptr);\n    if ( segment == m_Segments.end() ) {\n        NCBI_THROW(CFileException, eMemoryMap, \"CMemoryFileMap:\"\n                   \" Cannot find mapped file segment\"\n                   \" with specified address\");\n    }\n    return segment->second;\n}\n\n   \nCMemoryFile::CMemoryFile(const string&  file_name,\n                         EMemMapProtect protect,\n                         EMemMapShare   share,\n                         TOffsetType    offset,\n                         size_t         length,\n                         EOpenMode      mode,\n                         Uint8          max_file_len)\n\n    : CMemoryFileMap(file_name, protect, share, mode, max_file_len), m_Ptr(0)\n{\n    // Check that file is ready for mapping to memory\n    if ( !m_Handle  ||  (m_Handle->hMap == kInvalidHandle) ) {\n        return;\n    }\n    Map(offset, length);\n}\n\n\nvoid* CMemoryFile::Map(TOffsetType offset, size_t length)\n{\n    // Unmap if already mapped\n    if ( m_Ptr ) {\n        Unmap();\n    }\n    m_Ptr = CMemoryFileMap::Map(offset, length);\n    return m_Ptr;\n}\n\n\nbool CMemoryFile::Unmap()\n{\n    if ( !m_Ptr ) {\n        return true;\n    }\n    bool status = CMemoryFileMap::Unmap(m_Ptr);\n    m_Ptr = 0;\n    return status;\n}\n\n\nvoid* CMemoryFile::Extend(size_t length)\n{\n    x_Verify();\n\n    // Get current mapped segment\n    CMemoryFileSegment* segment = x_GetMemoryFileSegment(m_Ptr);\n    TOffsetType offset = segment->GetOffset();\n\n    // Get file size\n    Int8 file_size = GetFileSize();\n\n    // Map file wholly if the length of the mapped region is not specified\n    if ( !length ) {\n        Int8 fs = file_size - offset;\n        if ( (Uint8)fs > get_limits(length).max() ) {\n            NCBI_THROW(CFileException, eMemoryMap, \"CMemoryFile: \"\n                       \"Specified length of the mapping region is too big \"\n                       \"(length=\" + NStr::Int8ToString(length) + ')');\n        } else if ( fs > 0 ) {\n            length = (size_t)fs;\n        } else {\n            NCBI_THROW(CFileException, eMemoryMap, \"CMemoryFile: \"\n                       \"Specified offset of the mapping region\"\n                       \" exceeds the file size\");\n        }\n    }\n\n    // Changing file size is necessary\n    if (Int8(offset + length) > file_size) {\n        x_Close();\n        m_Ptr = 0;\n        x_Extend(file_size, offset + length);\n        x_Open();\n    }\n    // Remap current region\n    Map(offset, length);\n    return GetPtr();\n}\n\n\nvoid CMemoryFile::x_Verify(void) const\n{\n    if ( m_Ptr ) {\n        return;\n    }\n    NCBI_THROW(CFileException, eMemoryMap, \"CMemoryFile: File is not mapped\");\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CFileException\n//\n\nconst char* CFileException::GetErrCodeString(void) const\n{\n    switch (GetErrCode()) {\n    case eMemoryMap:    return \"eMemoryMap\";\n    case eRelativePath: return \"eRelativePath\";\n    case eNotExists:    return \"eNotExists\";\n    case eFileIO:       return \"eFileIO\";\n    case eTmpFile:      return \"eTmpFile\";\n    default:            return CException::GetErrCodeString();\n    }\n}\n\nconst char* CFileErrnoException::GetErrCodeString(void) const\n{\n    switch (GetErrCode()) {\n    case eFile:            return \"eFile\";\n    case eFileSystemInfo:  return \"eFileSystemInfo\";\n    case eFileLock:        return \"eFileLock\";\n    case eFileIO:          return \"eFileIO\";\n    default:               return CException::GetErrCodeString();\n    }\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// Find files\n//\n\nvoid x_Glob(const string& path,\n            const std::list<string>& parts,\n            std::list<string>::const_iterator next,\n            std::list<string>& result,\n            TFindFiles flags)\n{\n    vector<string> paths;\n    paths.push_back(path);\n    vector<string> masks;\n    masks.push_back(*next);\n    bool last = ++next == parts.end();\n    TFindFiles ff = flags;\n    if ( !last ) {\n        ff &= ~(fFF_File | fFF_Recursive);\n        ff |= fFF_Dir;\n    }\n    std::list<string> found;\n    FindFiles(found, paths.begin(), paths.end(), masks, ff);\n    if ( last ) {\n        result.insert(result.end(), found.begin(), found.end());\n    }\n    else {\n        if ( !found.empty() ) {\n            ITERATE(std::list<string>, it, found) {\n                x_Glob(CDirEntry::AddTrailingPathSeparator(*it), parts, next, result, flags);\n            }\n        }\n        else {\n            x_Glob(CDirEntry::AddTrailingPathSeparator(path + masks.front()), parts, next, result, flags);\n        }\n    }\n}\n\n\nvoid FindFiles(const string& pattern,  std::list<string>& result, TFindFiles flags)\n{\n    TFindFiles find_type = flags & fFF_All;\n    if ( find_type == 0 ) {\n        flags |= fFF_All;\n    }\n\n    string kDirSep(1, CDirEntry::GetPathSeparator());\n    string abs_path = CDirEntry::CreateAbsolutePath(pattern);\n    string search_path = kDirSep;\n\n    std::list<string> parts;\n    NStr::Split(abs_path, kDirSep, parts, NStr::fSplit_MergeDelimiters | NStr::fSplit_Truncate);\n    if ( parts.empty() ) {\n        return;\n    }\n\n#if defined(DISK_SEPARATOR)\n    // Network paths on Windows start with double back-slash and\n    // need special processing.\n    // Note: abs_path has normalized in CreateAbsolutePath().\n\n    string kNetSep(2, CDirEntry::GetPathSeparator());\n    bool is_network = abs_path.find(kNetSep) == 0;\n    if ( is_network ) {\n        search_path = kNetSep + parts.front() + kDirSep;\n        parts.erase(parts.begin());\n    }\n    else {\n        string disk;\n        CDirEntry::SplitPathEx(abs_path, &disk);\n        if ( disk.empty() ) {\n            // Disk is missing in the absolute path, add it.\n            CDirEntry::SplitPathEx(CDir::GetCwd(), &disk);\n            if ( !disk.empty() ) {\n                search_path = disk + kDirSep;\n            }\n        }\n        else {\n            search_path = disk;\n            // Disk is present but may be missing dir separator\n            if (abs_path[disk.size()] == DIR_SEPARATOR) {\n                parts.erase(parts.begin()); // Remove disk from parts\n                search_path += kDirSep;\n            }\n            else {\n                // Disk is included in the first part, remove it.\n                string temp = parts.front().substr(disk.size());\n                parts.erase(parts.begin());\n                parts.insert(parts.begin(), temp);\n            }\n        }\n    }\n#endif\n\n    x_Glob(search_path, parts, parts.begin(), result, flags);\n}\n\n\n#define UNDEFINED_SORT_MODE kMax_Int\n\nSCompareDirEntries::SCompareDirEntries(ESort s1)\n{\n    m_Sort[0] = s1;\n    m_Sort[1] = UNDEFINED_SORT_MODE;\n    m_Sort[2] = UNDEFINED_SORT_MODE;\n}\nSCompareDirEntries::SCompareDirEntries(ESort s1, ESort s2)\n{\n    m_Sort[0] = s1;\n    m_Sort[1] = s2;\n    m_Sort[2] = UNDEFINED_SORT_MODE;\n}\nSCompareDirEntries::SCompareDirEntries(ESort s1, ESort s2, ESort s3)\n{\n    m_Sort[0] = s1;\n    m_Sort[1] = s2;\n    m_Sort[2] = s3;\n}\n\nbool SCompareDirEntries::operator()(const string& p1, const string& p2)\n{\n    // Default case\n    if (m_Sort[0] == ePath) {\n        return (p1 < p2);\n    }\n    string d1, n1, e1;\n    string d2, n2, e2;\n    CDirEntry::SplitPath(p1, &d1, &n1, &e1);\n    CDirEntry::SplitPath(p2, &d2, &n2, &e2);\n\n    int nc = 0;\n\n    for (int i = 0; i < 3; i++) {\n        if (m_Sort[i] == UNDEFINED_SORT_MODE) {\n            break;\n        }\n        switch (m_Sort[i]) {\n        case ePath:\n            // usually we shouldn't get here, so just compare and exit\n            return (p1 < p2);\n        case eDir:\n            nc = NStr::CompareCase(d1, d2);\n            break;\n        case eName:\n            nc = NStr::CompareCase(n1 + e1, n2 + e2);\n            break;\n        case eBase:\n            nc = NStr::CompareCase(n1, n2);\n            break;\n        case eExt:\n            nc = NStr::CompareCase(e1, e2);\n            break;\n        default:\n            NCBI_THROW(CCoreException, eInvalidArg, \"Unknown sorting mode\");\n        }\n        if (nc != 0)\n            break;\n    }\n    return nc < 0;\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CFileIO\n//\n\nCFileIO::CFileIO(void) :\n    m_Handle(kInvalidHandle),\n    m_AutoClose(false),\n    m_AutoRemove(CFileIO::eDoNotRemove)\n{\n}\n\n\nCFileIO::~CFileIO()\n{\n    if (m_Handle != kInvalidHandle && m_AutoClose) {\n        try {\n            Close();\n        }\n        NCBI_CATCH_ALL(\"Error while closing file [IGNORED]\");\n    }\n}\n\n\nvoid CFileIO::Open(const string& filename,\n                   EOpenMode     open_mode,\n                   EAccessMode   access_mode,\n                   EShareMode    share_mode)\n{\n    string errmsg;\n\n#if defined(NCBI_OS_MSWIN)\n\n    // Translate parameters\n    DWORD dwAccessMode, dwShareMode, dwOpenMode;\n\n    switch (open_mode) {\n        case eCreate:\n            dwOpenMode = CREATE_ALWAYS;\n            break;\n        case eCreateNew:\n            dwOpenMode = CREATE_NEW;\n            break;\n        case eOpen:\n            dwOpenMode = OPEN_EXISTING;\n            break;\n        case eOpenAlways:\n            dwOpenMode = OPEN_ALWAYS;\n            break;\n        case eTruncate:\n            dwOpenMode = TRUNCATE_EXISTING;\n            break;\n        default:\n            _TROUBLE;\n    }\n    switch (access_mode) {\n        case eRead:\n            dwAccessMode = GENERIC_READ;\n            break;\n        case eWrite:\n            dwAccessMode = GENERIC_WRITE;\n            break;\n        case eReadWrite:\n            dwAccessMode = GENERIC_READ | GENERIC_WRITE;\n            break;\n        default:\n            _TROUBLE;\n    };\n    switch (share_mode) {\n        case eShareRead:\n            dwShareMode = FILE_SHARE_READ;\n            break;\n        case eShareWrite:\n            dwShareMode = FILE_SHARE_WRITE;\n            break;\n        case eShare:\n            dwShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;\n            break;\n        case eExclusive:\n            dwShareMode = 0;\n            break;\n        default:\n            _TROUBLE;\n    }\n\n    m_Handle = ::CreateFile(_T_XCSTRING(filename),\n                            dwAccessMode, dwShareMode, NULL, dwOpenMode,\n                            FILE_ATTRIBUTE_NORMAL, NULL);\n    if (m_Handle == kInvalidHandle) {\n        errmsg = WIN_LAST_ERROR_STR;\n    }\n\n#elif defined(NCBI_OS_UNIX)\n\n    // Translate parameters\n# if defined(O_BINARY)\n    int flags = O_BINARY;\n# else\n    int flags = 0; \n# endif\n    mode_t mode = 0;\n\n    switch (open_mode) {\n        case eCreate:\n            flags |= (O_CREAT | O_TRUNC);\n            break;\n        case eCreateNew:\n            if ( CFile(filename).Exists() ) {\n                NCBI_THROW(CFileException, eFileIO,\n                           \"Open mode is eCreateNew but file already exists: \"\n                           + filename );\n            }\n            flags |= O_CREAT;\n            break;\n        case eOpen:\n            // by default\n            break;\n        case eOpenAlways:\n            if ( !CFile(filename).Exists() ) {\n                flags |= O_CREAT;\n            }\n            break;\n        case eTruncate:\n            flags |= O_TRUNC;\n            break;\n        default:\n            _TROUBLE;\n    }\n    switch (access_mode) {\n        case eRead:\n            flags |= O_RDONLY;\n            mode  |= CDirEntry::MakeModeT(CDirEntry::fRead,\n                                          CDirEntry::fRead,\n                                          CDirEntry::fRead, 0);\n            break;\n        case eWrite:\n            flags |= O_WRONLY;\n            mode  |= CDirEntry::MakeModeT(CDirEntry::fWrite,\n                                          CDirEntry::fWrite,\n                                          CDirEntry::fWrite, 0);\n            break;\n        case eReadWrite:\n            flags |= O_RDWR;\n            mode  |= CDirEntry::MakeModeT(CDirEntry::fRead | CDirEntry::fWrite,\n                                          CDirEntry::fRead | CDirEntry::fWrite,\n                                          CDirEntry::fRead | CDirEntry::fWrite, 0);\n            break;\n        default:\n            _TROUBLE;\n    };\n    // Dummy, ignore 'share_mode' on UNIX\n    share_mode = eShare;\n\n    // Try to open/create file\n    m_Handle = NcbiSys_open(_T_XCSTRING(filename), flags, mode);\n    if (m_Handle == kInvalidHandle) {\n        errmsg = NcbiSys_strerror(errno);\n    }\n\n#endif\n    if (m_Handle == kInvalidHandle) {\n        NCBI_THROW(CFileErrnoException, eFileIO,\n                   \"Cannot open file '\" + filename + \"': \" + errmsg);\n    }\n    m_Pathname = filename;\n    m_AutoClose = true;\n}\n\n\nvoid CFileIO::CreateTemporary(const string& dir,\n                              const string& prefix,\n                              EAutoRemove auto_remove)\n{\n    if (m_Handle != kInvalidHandle) {\n       NCBI_THROW(CFileException, eFileIO,\n                  \"Cannot create temporary: Handle already open\");\n    }\n    static volatile int s_Count = 0;\n    string x_dir = dir;\n    if (x_dir.empty()) {\n        // Get application specific temporary directory name\n        x_dir = CDir::GetAppTmpDir();\n    }\n    if (!x_dir.empty()) {\n        x_dir = CDirEntry::AddTrailingPathSeparator(x_dir);\n    }\n    Uint8 x_tid = (Uint8) GetCurrentThreadSystemID();\n    unsigned int tid = (unsigned int) x_tid;\n    string x_prefix = prefix\n        + NStr::NumericToString(CCurrentProcess::GetPid())\n        + NStr::NumericToString(s_Count++)\n        + NStr::NumericToString(tid);\n\n#if defined(NCBI_OS_MSWIN)  ||  defined(NCBI_OS_UNIX)\n    string pattern = x_dir + x_prefix;\n\n#  if defined(NCBI_OS_UNIX)\n    pattern += \"XXXXXX\";\n    if (pattern.size() > PATH_MAX) {\n        NCBI_THROW(CFileErrnoException, eFileIO,\n                   \"Pattern too long '\" + pattern + \"'\");\n    }\n    char pathname[PATH_MAX+1];\n    memcpy(pathname, pattern.c_str(), pattern.size()+1);\n    if ((m_Handle = mkstemp(pathname)) == kInvalidHandle) {\n        NCBI_THROW(CFileErrnoException, eFileIO,\n                   \"mkstemp() failed for '\" + pattern + \"'\");\n    }\n    m_Pathname = pathname;\n    if (auto_remove == eRemoveASAP) {\n        NcbiSys_remove(_T_XCSTRING(m_Pathname));\n    }\n\n#  elif defined(NCBI_OS_MSWIN)\n    unsigned long ofs = (unsigned long) int(rand());\n    while (ofs < numeric_limits<unsigned long>::max()) {\n        char buffer[40];\n        _ultoa(ofs, buffer, 36);\n        string pathname = pattern + buffer;\n        m_Handle = ::CreateFile(_T_XCSTRING(pathname), GENERIC_ALL, 0, NULL,\n                                CREATE_NEW, FILE_ATTRIBUTE_TEMPORARY, NULL);\n        if (m_Handle != kInvalidHandle) {\n            m_Pathname.swap(pathname);\n            break;\n        }\n        if (::GetLastError() != ERROR_FILE_EXISTS) {\n            break;\n        }\n        ++ofs;\n    }\n\n    if (m_Handle == kInvalidHandle) {\n        NCBI_THROW(CFileErrnoException, eFileIO,\n                   \"Unable to create temporary file '\" + pattern + \"'\");\n    }\n\n#  endif\n\n#else // defined(NCBI_OS_MSWIN)  ||  defined(NCBI_OS_UNIX)\n    x_prefix += NStr::NumericToString((unsigned int) rand());\n    Open(s_StdGetTmpName(x_dir.c_str(), x_prefix.c_str()), eCreateNew, eReadWrite);\n#endif\n\n    m_AutoClose = true;\n    m_AutoRemove = auto_remove;\n}\n\n\nvoid CFileIO::Close(void)\n{\n    if (m_Handle != kInvalidHandle) {\n#if defined(NCBI_OS_MSWIN)\n        if (!::CloseHandle(m_Handle)) {\n            NCBI_THROW(CFileErrnoException, eFileIO, \"CloseHandle() failed\");\n        }\n#elif defined(NCBI_OS_UNIX)\n        while (close(m_Handle) < 0) {\n            if (errno != EINTR) {\n                NCBI_THROW(CFileErrnoException, eFileIO, \"close() failed\");\n            }\n        }\n#endif\n        m_Handle = kInvalidHandle;\n\n        if (m_AutoRemove != eDoNotRemove)\n            NcbiSys_remove(_T_XCSTRING(m_Pathname));\n    }\n}\n\n\nsize_t CFileIO::Read(void* buf, size_t count) const\n{\n    if (count == 0) {\n        return 0;\n    }\n    char* ptr = (char*) buf;\n    \n#if defined(NCBI_OS_MSWIN)\n    const DWORD   kMax = numeric_limits<DWORD>::max();\n#elif defined(NCBI_OS_UNIX)\n    const ssize_t kMax = numeric_limits<ssize_t>::max();\n#endif   \n    \n    while (count) {\n\n#if defined(NCBI_OS_MSWIN)\n        DWORD nmax = count > kMax ? kMax : (DWORD) count;\n        DWORD n = 0;\n        if ( ::ReadFile(m_Handle, ptr, nmax, &n, NULL) == 0 ) {\n            if (::GetLastError() == ERROR_HANDLE_EOF) {\n                break;\n            }\n            NCBI_THROW(CFileErrnoException, eFileIO, \"ReadFile() failed\");\n        }\n        if ( n == 0 ) {\n            break;\n        }\n#elif defined(NCBI_OS_UNIX)\n        ssize_t nmax = count > kMax ? kMax : (ssize_t) count;\n        ssize_t n = ::read(int(m_Handle), ptr, nmax);\n        if (n == 0) {\n            break;\n        }\n        if ( n < 0 ) {\n            if (errno == EINTR) {\n                continue;\n            }\n            NCBI_THROW(CFileErrnoException, eFileIO, \"read() failed\");\n        }\n#endif\n        count -= n;\n        ptr += n;\n    }\n    return ptr - (char*)buf;\n}\n\n\nsize_t CFileIO::Write(const void* buf, size_t count) const\n{\n    if (count == 0) {\n        return 0;\n    }\n    const char* ptr = (const char*) buf;\n    \n#if defined(NCBI_OS_MSWIN)\n    const DWORD   kMax = numeric_limits<DWORD>::max();\n#elif defined(NCBI_OS_UNIX)\n    const ssize_t kMax = numeric_limits<ssize_t>::max();\n#endif   \n    \n    while (count) {\n\n#if defined(NCBI_OS_MSWIN)\n        DWORD nmax = count > kMax ? kMax : (DWORD) count;\n        DWORD n = 0;\n        if ( ::WriteFile(m_Handle, ptr, nmax, &n, NULL) == 0 ) {\n            NCBI_THROW(CFileErrnoException, eFileIO, \"WriteFile() failed\");\n        }\n#elif defined(NCBI_OS_UNIX)\n        ssize_t nmax = count > kMax ? kMax : (ssize_t) count;\n        ssize_t n = ::write(int(m_Handle), ptr, nmax);\n        if ( n < 0  &&  errno == EINTR ) {\n            continue;\n        }\n        if ( n <= 0 ) {\n            NCBI_THROW(CFileErrnoException, eFileIO, \"write() failed\");\n        }\n#endif\n        count -= n;\n        ptr += n;\n    }\n    return ptr - (char*)buf;\n}\n\n\nvoid CFileIO::Flush(void) const\n{\n    bool res;\n#if defined(NCBI_OS_MSWIN)\n    res = (::FlushFileBuffers(m_Handle) == TRUE);\n#elif defined(NCBI_OS_UNIX)\n    res = (fsync(m_Handle) == 0);\n#endif\n    if (!res) {\n        NCBI_THROW(CFileErrnoException, eFileIO, \"Cannot flush\");\n    }\n}\n\n\nvoid CFileIO::SetFileHandle(TFileHandle handle)\n{\n    // Close previous handle if needed\n    if (m_AutoClose) {\n        Close();\n        m_AutoClose = false;\n    }\n    // Use given handle for all I/O\n    m_Handle = handle;\n}\n\n\nUint8 CFileIO::GetFilePos(void) const\n{\n#if defined(NCBI_OS_MSWIN)\n    LARGE_INTEGER ofs;\n    LARGE_INTEGER pos;\n    ofs.QuadPart = 0;\n    pos.QuadPart = 0;\n    BOOL res = SetFilePointerEx(m_Handle, ofs, &pos, FILE_CURRENT);\n    if (res) {\n        return (Uint8)pos.QuadPart;\n    }\n#elif defined(NCBI_OS_UNIX)\n    off_t pos = NcbiSys_lseek(m_Handle, 0, SEEK_CUR);\n    if (pos != -1L) {\n        return (Uint8)pos;\n    }\n#endif\n    NCBI_THROW(CFileErrnoException, eFileIO, \"Cannot get file position\");\n    // Unreachable\n    return 0;\n}\n\n\nvoid CFileIO::SetFilePos(Uint8 position) const\n{\n#if defined(NCBI_OS_MSWIN)\n    LARGE_INTEGER ofs;\n    ofs.QuadPart = position;\n    bool res = (SetFilePointerEx(m_Handle, ofs, NULL, FILE_BEGIN) == TRUE);\n#elif defined(NCBI_OS_UNIX)\n    bool res = (NcbiSys_lseek(m_Handle, (off_t)position, SEEK_SET) != -1);\n#endif\n    if (!res) {\n        NCBI_THROW(CFileErrnoException, eFileIO,\n                   \"Cannot change file positon\"\n                   \" (position=\" + NStr::UInt8ToString(position) + ')');\n    }\n}\n\n\nvoid CFileIO::SetFilePos(Int8 offset, EPositionMoveMethod move_method) const\n{\n#if defined(NCBI_OS_MSWIN)\n    DWORD from = 0;\n    switch (move_method) {\n        case eBegin:\n            from = FILE_BEGIN;\n            break;\n        case eCurrent:\n            from = FILE_CURRENT;\n            break;\n        case eEnd:\n            from = FILE_END;\n            break;\n        default:\n            _TROUBLE;\n    }\n    LARGE_INTEGER ofs;\n    ofs.QuadPart = offset;\n    bool res = (SetFilePointerEx(m_Handle, ofs, NULL, from) == TRUE);\n\n#elif defined(NCBI_OS_UNIX)\n    int from = 0;\n    switch (move_method) {\n        case eBegin:\n            from = SEEK_SET;\n            break;\n        case eCurrent:\n            from = SEEK_CUR;\n            break;\n        case eEnd:\n            from = SEEK_END;\n            break;\n        default:\n            _TROUBLE;\n    }\n    bool res = (NcbiSys_lseek(m_Handle, (off_t)offset, from) != -1);\n#endif\n    if (!res) {\n        NCBI_THROW(CFileErrnoException, eFileIO,\n                   \"Cannot change file positon\"\n                   \" (offset=\" + NStr::Int8ToString(offset) +\n                   \", method=\" + NStr::IntToString(move_method) + ')');\n    }\n}\n\n\nUint8 CFileIO::GetFileSize(void) const\n{\n#if defined(NCBI_OS_MSWIN)\n    DWORD size_hi = 0;\n    DWORD size_lo = ::GetFileSize(m_Handle, &size_hi);\n    if (size_lo != INVALID_FILE_SIZE) {\n        return ((unsigned __int64)size_hi << 32) | size_lo;\n    }\n#elif defined(NCBI_OS_UNIX)\n    TNcbiSys_fstat st;\n    if (NcbiSys_fstat(m_Handle, &st) != -1) {\n        return st.st_size;\n    }\n#endif\n    NCBI_THROW(CFileErrnoException, eFileIO, \"Cannot get file size\");\n    // Unreachable\n    return 0;\n}\n\n\nvoid CFileIO::SetFileSize(Uint8 length, EPositionMoveMethod pos) const\n{\n#if defined(NCBI_OS_MSWIN)\n    BOOL res = true;\n    // Get current position if needed\n    LARGE_INTEGER ofs;\n    LARGE_INTEGER saved;\n    ofs.QuadPart = 0;\n    saved.QuadPart = 0;\n    // Save current file position if needed\n    if (pos == eCurrent) {\n        res = SetFilePointerEx(m_Handle, ofs, &saved, FILE_CURRENT);\n    }\n    if (res) {\n        // Set file position to specified length (new EOF)\n        ofs.QuadPart = length;\n        res = SetFilePointerEx(m_Handle, ofs, NULL, FILE_BEGIN);\n        // And change file size\n        if (res) {\n            res = SetEndOfFile(m_Handle);\n        }\n        // Set file pointer if other than eEnd\n        if (res) {\n            if (pos == eBegin) {\n                // eBegin\n                ofs.QuadPart = 0;\n                res = SetFilePointerEx(m_Handle, ofs, NULL, FILE_BEGIN);\n            }\n            else if (pos == eCurrent) {\n                res = SetFilePointerEx(m_Handle, saved, NULL, FILE_BEGIN);\n            }\n            // Nothing todo if eEnd, because we already at the EOF position\n        }\n    }\n#elif defined(NCBI_OS_UNIX)\n    bool res = true;\n    int errcode = s_FTruncate(m_Handle, length);\n    if (!errcode  &&  pos != eCurrent) {\n        // Move file offset to the start/end of the file.\n        SetFilePos(0, pos);\n    }\n    if (errcode) {\n       // Restore errno for CFileErrnoException exception\n       errno = errcode;\n       res = false;\n    }\n   \n#endif\n    if (!res) {\n        NCBI_THROW(CFileErrnoException, eFileIO,\n                   \"Cannot change file size\"\n                   \" (length=\" + NStr::NumericToString(length) + ')');\n    }\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CFileReader\n//\n\nCFileReader::CFileReader(const string& filename, EShareMode share_mode)\n{\n    m_File.Open(filename, eOpen, eRead, share_mode);\n}\n\n\nCFileReader::CFileReader(const char* filename, EShareMode share_mode)\n{\n    m_File.Open(filename, eOpen, eRead, share_mode);\n}\n\n\nCFileReader::CFileReader(TFileHandle handle)\n{\n    m_File.SetFileHandle(handle);\n}\n\n\nIReader* CFileReader::New(const string& filename, EShareMode share_mode)\n{\n    if ( filename == \"-\" ) {\n#if defined(NCBI_OS_MSWIN)\n        TFileHandle handle = GetStdHandle(STD_INPUT_HANDLE);\n#elif defined(NCBI_OS_UNIX)\n#  ifdef STDIN_FILENO\n        TFileHandle handle = STDIN_FILENO;\n#  else\n        TFileHandle handle = 0;\n#  endif //STDIN_FILENO\n#endif\n        return new CFileReader(handle);\n    }\n    return new CFileReader(filename, share_mode);\n}\n\n\nERW_Result CFileReader::Read(void* buf, size_t count, size_t* bytes_read)\n{\n    if ( bytes_read ) {\n        *bytes_read = 0;\n    }\n    if ( !count ) {\n        return eRW_Success;\n    }\n    size_t n;\n    try {\n        n = m_File.Read(buf, count);\n    }\n    catch (const CFileErrnoException& ex) {\n        CNcbiError::SetErrno(ex.GetErrno());\n        return eRW_Error;\n    }\n    if ( bytes_read ) {\n        *bytes_read = n;\n    }\n    return n? eRW_Success : eRW_Eof;\n}\n\n\nERW_Result CFileReader::PendingCount(size_t* /*count*/)\n{\n    return eRW_NotImplemented;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CFileWriter\n//\n\nCFileWriter::CFileWriter(const string& filename,\n                         EOpenMode  open_mode,\n                         EShareMode share_mode)\n{\n    m_File.Open(filename, open_mode, eWrite, share_mode);\n}\n\n\nCFileWriter::CFileWriter(const char* filename,\n                         EOpenMode  open_mode,\n                         EShareMode share_mode)\n{\n    m_File.Open(filename, open_mode, eWrite, share_mode);\n}\n\n\nCFileWriter::CFileWriter(TFileHandle handle)\n{\n    m_File.SetFileHandle(handle);\n    return;\n}\n\n\nIWriter* CFileWriter::New(const string& filename,\n                          EOpenMode  open_mode,\n                          EShareMode share_mode)\n{\n    if ( filename == \"-\" ) {\n#if defined(NCBI_OS_MSWIN)\n        TFileHandle handle = GetStdHandle(STD_OUTPUT_HANDLE);\n#elif defined(NCBI_OS_UNIX)\n#  ifdef STDOUT_FILENO\n        TFileHandle handle = STDOUT_FILENO;\n#  else\n        TFileHandle handle = 1;\n#  endif //STDOUT_FILENO\n#endif\n        return new CFileWriter(handle);\n    }\n    return new CFileWriter(filename, open_mode, share_mode);\n}\n\n\nERW_Result CFileWriter::Write(const void* buf,\n                              size_t count, size_t* bytes_written)\n{\n    if ( bytes_written ) {\n        *bytes_written = 0;\n    }\n    if ( !count ) {\n        return eRW_Success;\n    }\n    size_t n;\n    try {\n        n = m_File.Write(buf, count);\n    }\n    catch (const CFileErrnoException& ex) {\n        CNcbiError::SetErrno(ex.GetErrno());\n        return eRW_Error;\n    }\n    if ( bytes_written ) {\n        *bytes_written = n;\n    }\n    return n? eRW_Success : eRW_Error;\n}\n\n\nERW_Result CFileWriter::Flush(void)\n{\n    try {\n        m_File.Flush();\n    }\n    catch (const CFileErrnoException& ex) {\n        CNcbiError::SetErrno(ex.GetErrno());\n        return eRW_Error;\n    }\n    return eRW_Success;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CFileReaderWriter\n//\n\nCFileReaderWriter::CFileReaderWriter(const string& filename,\n                                     EOpenMode  open_mode,\n                                     EShareMode share_mode)\n{\n    m_File.Open(filename, open_mode, eReadWrite, share_mode);\n}\n\n\nCFileReaderWriter::CFileReaderWriter(const char* filename,\n                                     EOpenMode  open_mode,\n                                     EShareMode share_mode)\n{\n    m_File.Open(filename, open_mode, eReadWrite, share_mode);\n}\n\n\nCFileReaderWriter::CFileReaderWriter(TFileHandle handle)\n{\n    m_File.SetFileHandle(handle);\n    return;\n}\n\n\nIReaderWriter* CFileReaderWriter::New(const string& filename,\n                                      EOpenMode  open_mode,\n                                      EShareMode share_mode)\n{\n    return new CFileReaderWriter(filename, open_mode, share_mode);\n}\n\n\nERW_Result CFileReaderWriter::Read(void* buf,\n                                   size_t count, size_t* bytes_read)\n{\n    if ( bytes_read ) {\n        *bytes_read = 0;\n    }\n    if ( !count ) {\n        return eRW_Success;\n    }\n    size_t n;\n    try {\n        n = m_File.Read(buf, count);\n    }\n    catch (const CFileErrnoException& ex) {\n        CNcbiError::SetErrno(ex.GetErrno());\n        return eRW_Error;\n    }\n    if ( bytes_read ) {\n        *bytes_read = n;\n    }\n    return n? eRW_Success : eRW_Eof;\n}\n\n\nERW_Result CFileReaderWriter::PendingCount(size_t* /*count*/)\n{\n    return eRW_NotImplemented;\n}\n\n\nERW_Result CFileReaderWriter::Write(const void* buf,\n                                    size_t count, size_t* bytes_written)\n{\n    if ( bytes_written ) {\n        *bytes_written = 0;\n    }\n    if ( !count ) {\n        return eRW_Success;\n    }\n    size_t n;\n    try {\n        n = m_File.Write(buf, count);\n    }\n    catch (const CFileErrnoException& ex) {\n        CNcbiError::SetErrno(ex.GetErrno());\n        return eRW_Error;\n    }\n    if ( bytes_written ) {\n        *bytes_written = n;\n    }\n    return n? eRW_Success : eRW_Error;\n}\n\n\nERW_Result CFileReaderWriter::Flush(void)\n{\n    try {\n        m_File.Flush();\n    }\n    catch (const CFileException&) { \n       return eRW_Error;\n    }\n    return eRW_Success;\n}\n\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// CFileLock\n//\n\n// Clean up an all non-default bits in group if all bits are set\n#define F_CLEAN_REDUNDANT(group) \\\n    if (F_ISSET(m_Flags, (group))) \\\n        m_Flags &= ~unsigned((group) & ~unsigned(fDefault))\n\n// Platform-dependent structure to store file locking information\nstruct SLock {\n    SLock(void) {};\n    SLock(CFileLock::TOffsetType off, size_t len) {\n        Reset(off, len);\n    }\n#if defined(NCBI_OS_MSWIN)\n    void Reset(CFileLock::TOffsetType off, size_t len) \n    {\n        offset_lo = (DWORD)(off & 0xFFFFFFFF);\n        offset_hi = (DWORD)((Int8(off) >> 32) & 0xFFFFFFFF);\n        // Locking a region that goes beyond the current EOF position\n        // is not an error.\n        if (len) {\n            length_lo = (DWORD)(len & 0xFFFFFFFF);\n            length_hi = (DWORD)((Int8(len) >> 32) & 0xFFFFFFFF);\n        } else {\n            // Lock a whole file\n            length_lo = 0;\n            length_hi = 0xFFFFFFFF;\n        }\n    };\n    DWORD offset_lo;\n    DWORD offset_hi;\n    DWORD length_lo;\n    DWORD length_hi;\n#elif defined(NCBI_OS_UNIX)\n    void Reset(CFileLock::TOffsetType off, size_t len) {\n        offset = off;\n        length = len;\n    }\n    off_t  offset;\n    size_t length;\n#endif\n};\n\n\nCFileLock::CFileLock(const string& filename, TFlags flags, EType type,\n                     TOffsetType offset, size_t length)\n    : m_Handle(kInvalidHandle), m_CloseHandle(false), m_Flags(flags),\n      m_IsLocked(false), m_Lock(0)\n{\n    x_Init(filename.c_str(), type, offset, length);\n}\n\n\nCFileLock::CFileLock(const char* filename, TFlags flags, EType type,\n                     TOffsetType offset, size_t length)\n    : m_Handle(kInvalidHandle), m_CloseHandle(false), m_Flags(flags),\n      m_IsLocked(false), m_Lock(0)\n{\n    x_Init(filename, type, offset, length);\n}\n\n\nCFileLock::CFileLock(TFileHandle handle, TFlags flags, EType type,\n                     TOffsetType offset, size_t length)\n    : m_Handle(handle), m_CloseHandle(false), m_Flags(flags),\n      m_IsLocked(false), m_Lock(0)\n{\n    x_Init(0, type, offset, length);\n}\n\n\nvoid CFileLock::x_Init(const char* filename, EType type, TOffsetType offset, size_t length)\n{\n    // Reset redundant flags\n    F_CLEAN_REDUNDANT(fLockNow | fLockLater);\n    F_CLEAN_REDUNDANT(fAutoUnlock | fNoAutoUnlock);\n\n    // Open file\n    if (filename) {\n#if defined(NCBI_OS_MSWIN)\n        m_Handle = ::CreateFile(_T_XCSTRING(filename), GENERIC_READ,\n                                FILE_SHARE_READ, NULL, OPEN_EXISTING, 0, NULL);\n#elif defined(NCBI_OS_UNIX)\n        m_Handle = NcbiSys_open(_T_XCSTRING(filename), O_RDWR);\n#endif\n    }\n    if (m_Handle == kInvalidHandle) {\n        NCBI_THROW(CFileErrnoException, eFileLock,\n                   \"Cannot open file '\" + string(filename) + \"'\");\n    }\n    if (filename) {\n        m_CloseHandle = true;\n    }\n    m_Lock = new SLock;\n\n    // Lock file if necessary\n    if (F_ISSET(m_Flags, fLockNow)) {\n         Lock(type, offset, length);\n    }\n}\n\n\nCFileLock::~CFileLock()\n{\n    if (m_Handle == kInvalidHandle) {\n        return;\n    }\n    try {\n        // Remove lock automaticaly\n        if (F_ISSET(m_Flags, fAutoUnlock)) {\n            Unlock();\n        }\n    }\n    catch (const CException& e) {\n        NCBI_REPORT_EXCEPTION_X(4, \"CFileLock::~CFileLock(): Cannot unlock\", e);\n    }\n\n    if (m_CloseHandle) {\n#if defined(NCBI_OS_MSWIN)\n        ::CloseHandle(m_Handle);\n#elif defined(NCBI_OS_UNIX)\n        ::close(m_Handle);\n#endif\n    }\n    return;\n}\n\n\nvoid CFileLock::Lock(EType type, TOffsetType offset, size_t length)\n{\n    // Remove previous lock\n    if (m_IsLocked) {\n        Unlock();\n    }\n    // Set new one\n    m_Lock->Reset(offset, length);\n    \n#if defined(NCBI_OS_MSWIN)\n    DWORD flags = LOCKFILE_FAIL_IMMEDIATELY;\n    if (type == eExclusive) {\n        flags |= LOCKFILE_EXCLUSIVE_LOCK;\n    }\n    OVERLAPPED overlapped;\n    overlapped.hEvent     = 0;\n    overlapped.Offset     = m_Lock->offset_lo;\n    overlapped.OffsetHigh = m_Lock->offset_hi;\n    bool res = LockFileEx(m_Handle, flags, 0, \n                            m_Lock->length_lo, m_Lock->length_hi,\n                            &overlapped) == TRUE;\n#elif defined(NCBI_OS_UNIX)\n    struct flock fl;\n    fl.l_type   = (type == eShared) ? F_RDLCK : F_WRLCK;\n    fl.l_whence = SEEK_SET;\n    fl.l_start  = m_Lock->offset;\n    fl.l_len    = m_Lock->length;   // 0 - lock to EOF \n    fl.l_pid    = getpid();\n    \n    int err;\n    do {\n        err = fcntl(m_Handle, F_SETLK, &fl);\n    } while (err && (errno == EINTR));\n    bool res = (err == 0);\n\n#endif\n    if (!res) {\n        NCBI_THROW(CFileErrnoException, eFileLock, \"Cannot lock file\");\n    }\n    m_IsLocked = true;\n    return;\n}\n\n\nvoid CFileLock::Unlock(void)\n{\n    if (!m_IsLocked) {\n        return;\n    }\n#if defined(NCBI_OS_MSWIN)\n    OVERLAPPED overlapped;\n    overlapped.hEvent     = 0;\n    overlapped.Offset     = m_Lock->offset_lo;\n    overlapped.OffsetHigh = m_Lock->offset_hi;\n    bool res = UnlockFileEx(m_Handle, 0,\n                            m_Lock->length_lo, m_Lock->length_hi,\n                            &overlapped) == TRUE;\n\n#elif defined(NCBI_OS_UNIX)\n    struct flock fl;\n    fl.l_type   = F_UNLCK;\n    fl.l_whence = SEEK_SET;\n    fl.l_start  = m_Lock->offset;\n    fl.l_len    = m_Lock->length;\n    fl.l_pid    = getpid();\n    \n    int err;\n    do {\n        err = fcntl(m_Handle, F_SETLK, &fl);\n    } while (err && (errno == EINTR));\n    bool res = (err == 0);\n\n#endif\n    if (!res) {\n        NCBI_THROW(CFileErrnoException, eFileLock, \"Cannot unlock\");\n    }\n    m_IsLocked = false;\n    return;\n}\n\n\n//////////////////////////////////////////////////////////////////////////////\n//\n// Misc\n//\n\nvoid CFileAPI::SetLogging(ESwitch on_off_default)\n{\n    NCBI_PARAM_TYPE(NCBI, FileAPILogging)::SetDefault(\n        on_off_default != eDefault ?\n        on_off_default != eOff : DEFAULT_LOGGING_VALUE);\n}\n\nvoid CFileAPI::SetHonorUmask(ESwitch on_off_default)\n{\n    NCBI_PARAM_TYPE(NCBI, FileAPIHonorUmask)::SetDefault(\n        on_off_default != eDefault ?\n        on_off_default != eOff : DEFAULT_HONOR_UMASK_VALUE);\n}\n\nvoid CFileAPI::SetDeleteReadOnlyFiles(ESwitch on_off_default)\n{\n    NCBI_PARAM_TYPE(NCBI, DeleteReadOnlyFiles)::SetDefault(\n        on_off_default == eOn);\n}\n\n\nEND_NCBI_SCOPE\n",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/corelib/ncbidll.cpp": "/*  $Id: ncbidll.cpp 591546 2019-08-16 16:59:06Z vasilche $\n * ===========================================================================\n *\n *                            PUBLIC DOMAIN NOTICE\n *               National Center for Biotechnology Information\n *\n *  This software/database is a \"United States Government Work\" under the\n *  terms of the United States Copyright Act.  It was written as part of\n *  the author's official duties as a United States Government employee and\n *  thus cannot be copyrighted.  This software/database is freely available\n *  to the public for use. The National Library of Medicine and the U.S.\n *  Government have not placed any restriction on its use or reproduction.\n *\n *  Although all reasonable efforts have been taken to ensure the accuracy\n *  and reliability of the software and data, the NLM and the U.S.\n *  Government do not and cannot warrant the performance or results that\n *  may be obtained by using this software or data. The NLM and the U.S.\n *  Government disclaim all warranties, express or implied, including\n *  warranties of performance, merchantability or fitness for any particular\n *  purpose.\n *\n *  Please cite the author in any work or product based on this material.\n *\n * ===========================================================================\n *\n * Author: Vladimir Ivanov, Denis Vakatov\n *\n * File Description:\n *   Portable DLL handling\n *\n */\n\n#include <ncbi_pch.hpp>\n#include <corelib/ncbidll.hpp>\n#include <corelib/ncbifile.hpp>\n#include <corelib/ncbiapp_api.hpp>\n#include <corelib/error_codes.hpp>\n#include \"ncbisys.hpp\"\n\n\n#if defined(NCBI_OS_MSWIN)\n#  include <corelib/ncbi_os_mswin.hpp>\n#elif defined(NCBI_OS_UNIX)\n#  ifdef NCBI_OS_DARWIN\n#    include <mach-o/dyld.h>\n#  endif\n#  ifdef HAVE_DLFCN_H\n#    include <dlfcn.h>\n#    ifndef RTLD_LOCAL /* missing on Cygwin? */\n#      define RTLD_LOCAL 0\n#    endif\n#  endif\n#else\n#  error \"Class CDll defined only for MS Windows and UNIX platforms\"\n#endif\n\n#if defined(NCBI_OS_MSWIN)\n#  pragma warning (disable : 4191)\n#endif\n\n\n#define NCBI_USE_ERRCODE_X   Corelib_Dll\n\n\nBEGIN_NCBI_SCOPE\n\n\n// Platform-dependent DLL handle type definition\nstruct SDllHandle {\n#if defined(NCBI_OS_MSWIN)\n    HMODULE handle;\n#elif defined(NCBI_OS_UNIX)\n    void*   handle;\n#endif\n};\n\n// Check flag bits\n#define F_ISSET(mask) ((m_Flags & (mask)) == (mask))\n// Clean up an all non-default bits in group if all bits are set\n#define F_CLEAN_REDUNDANT(group) \\\n    if (F_ISSET(group)) m_Flags &= ~unsigned((group) & ~unsigned(fDefault))\n\n\nCDll::CDll(const string& name, TFlags flags)\n{\n    x_Init(kEmptyStr, name, flags);\n}\n\nCDll::CDll(const string& path, const string& name, TFlags flags)\n{\n    x_Init(path, name, flags);\n}\n\nCDll::CDll(const string& name, ELoad when_to_load, EAutoUnload auto_unload,\n           EBasename treate_as)\n{\n    x_Init(kEmptyStr, name,\n           TFlags(when_to_load) | TFlags(auto_unload) | TFlags(treate_as));\n}\n\nCDll::CDll(const string& path, const string& name, ELoad when_to_load,\n           EAutoUnload auto_unload, EBasename treate_as)\n{\n    x_Init(path, name,\n           TFlags(when_to_load) | TFlags(auto_unload) | TFlags(treate_as));\n}\n\n\nCDll::~CDll()\n{\n    // Unload DLL automatically\n    if ( F_ISSET(fAutoUnload) ) {\n        try {\n            Unload();\n        } catch(CException& e) {\n            NCBI_REPORT_EXCEPTION_X(1, \"CDll destructor\", e);\n        }\n    }\n    delete m_Handle;\n}\n\n\nvoid CDll::x_Init(const string& path, const string& name, TFlags flags)\n{\n    // Save flags\n    m_Flags = flags;\n\n    // Reset redundant flags\n    F_CLEAN_REDUNDANT(fLoadNow    | fLoadLater);\n    F_CLEAN_REDUNDANT(fAutoUnload | fNoAutoUnload);\n    F_CLEAN_REDUNDANT(fBaseName   | fExactName);\n    F_CLEAN_REDUNDANT(fGlobal     | fLocal);\n\n    // Init members\n    m_Handle = 0;\n    string x_name = name;\n#if defined(NCBI_OS_MSWIN)\n    NStr::ToLower(x_name);\n#endif\n    // Process DLL name\n    if (F_ISSET(fBaseName)  &&\n        name.find_first_of(\":/\\\\\") == NPOS  &&\n        !CDirEntry::MatchesMask(name.c_str(),\n                                NCBI_PLUGIN_PREFIX \"*\" NCBI_PLUGIN_MIN_SUFFIX \"*\")\n        ) {\n        // \"name\" is basename\n        x_name = NCBI_PLUGIN_PREFIX + x_name + NCBI_PLUGIN_SUFFIX;\n    }\n    m_Name = CDirEntry::ConcatPath(path, x_name);\n    // Load DLL now if indicated\n    if (F_ISSET(fLoadNow)) {\n        Load();\n    }\n}\n\n\nvoid CDll::Load(void)\n{\n    // DLL is already loaded\n    if ( m_Handle ) {\n        return;\n    }\n    // Load DLL\n    _TRACE(\"Loading dll: \"<<m_Name);\n#if defined(NCBI_OS_MSWIN)\n    UINT errMode = SetErrorMode(SEM_FAILCRITICALERRORS);\n    HMODULE handle = LoadLibrary(_T_XCSTRING(m_Name));\n    SetErrorMode(errMode);\n#elif defined(NCBI_OS_UNIX)\n#  ifdef HAVE_DLFCN_H\n    int flags = RTLD_LAZY | (F_ISSET(fLocal) ? RTLD_LOCAL : RTLD_GLOBAL);\n    void* handle = dlopen(m_Name.c_str(), flags);\n#  else\n    void* handle = 0;\n#  endif\n#endif\n    if ( !handle ) {\n        x_ThrowException(\"CDll::Load\");\n    }\n    m_Handle = new SDllHandle;\n    m_Handle->handle = handle;\n}\n\n\nvoid CDll::Unload(void)\n{\n    // DLL is not loaded\n    if ( !m_Handle ) {\n        return;\n    }\n    _TRACE(\"Unloading dll: \"<<m_Name);\n    // Unload DLL\n#if defined(NCBI_OS_MSWIN)\n    BOOL unloaded = FreeLibrary(m_Handle->handle);\n#elif defined(NCBI_OS_UNIX)\n#  ifdef HAVE_DLFCN_H\n    bool unloaded = dlclose(m_Handle->handle) == 0;\n#  else\n    bool unloaded = false;\n#  endif\n#endif\n    if ( !unloaded ) {\n        x_ThrowException(\"CDll::Unload\");\n    }\n\n    delete m_Handle;\n    m_Handle = 0;\n}\n\n\nCDll::TEntryPoint CDll::GetEntryPoint(const string& name)\n{\n    // If DLL is not yet loaded\n    if ( !m_Handle ) {\n        Load();\n    }\n    _TRACE(\"Getting entry point: \"<<name);\n    TEntryPoint entry;\n\n    // Return address of entry (function or data)\n#if defined(NCBI_OS_MSWIN)\n    FARPROC ptr = GetProcAddress(m_Handle->handle, name.c_str());\n#elif defined(NCBI_OS_DARWIN)\n    NSModule module = (NSModule)m_Handle->handle;\n    NSSymbol nssymbol = NSLookupSymbolInModule(module, name.c_str());\n    void* ptr = 0;\n    ptr = NSAddressOfSymbol(nssymbol);\n    if (ptr == NULL) {\n        ptr = dlsym (m_Handle->handle, name.c_str());\n    }\n#elif defined(NCBI_OS_UNIX)  &&  defined(HAVE_DLFCN_H)\n    void* ptr = 0;\n    ptr = dlsym(m_Handle->handle, name.c_str());\n#else\n    void* ptr = 0;\n#endif\n    entry.func = (FEntryPoint)ptr;\n    entry.data = ptr;\n    return entry;\n}\n\n\nvoid CDll::x_ThrowException(const string& what)\n{\n#if defined(NCBI_OS_MSWIN)\n    TXChar* ptr = NULL;\n    FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |\n                  FORMAT_MESSAGE_FROM_SYSTEM |\n                  FORMAT_MESSAGE_IGNORE_INSERTS,\n                  NULL, GetLastError(),\n                  MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n                  (TXChar*) &ptr, 0, NULL);\n    string errmsg = ptr ? _T_CSTRING(ptr) : \"unknown reason\";\n    LocalFree(ptr);\n#elif defined(NCBI_OS_UNIX)\n#  ifdef HAVE_DLFCN_H\n    const char* errmsg = dlerror();\n    if ( !errmsg ) {\n        errmsg = \"unknown reason\";\n    }\n#  else\n    const char* errmsg = \"No DLL support on this platform.\";\n#  endif\n#endif\n\n    NCBI_THROW(CCoreException, eDll, what + \" [\" + m_Name +\"]: \" + errmsg);\n}\n\n\nCDllResolver::CDllResolver(const string& entry_point_name,\n                           CDll::EAutoUnload unload)\n    : m_AutoUnloadDll(unload)\n{\n    m_EntryPoinNames.push_back(entry_point_name);\n}\n\nCDllResolver::CDllResolver(const vector<string>& entry_point_names,\n                           CDll::EAutoUnload unload)\n    : m_AutoUnloadDll(unload)\n{\n    m_EntryPoinNames = entry_point_names;\n}\n\nCDllResolver::~CDllResolver()\n{\n    Unload();\n}\n\nbool CDllResolver::TryCandidate(const string& file_name,\n                                const string& driver_name)\n{\n    try {\n        CDll* dll = new CDll(file_name, CDll::fLoadNow | CDll::fNoAutoUnload);\n        CDll::TEntryPoint p;\n\n        SResolvedEntry entry_point(dll);\n\n        ITERATE(vector<string>, it, m_EntryPoinNames) {\n            string entry_point_name;\n\n            const string& dll_name = dll->GetName();\n\n            if ( !dll_name.empty() ) {\n                string base_name;\n                CDirEntry::SplitPath(dll_name, 0, &base_name, 0);\n                NStr::Replace(*it, \"${basename}\", base_name, entry_point_name);\n                if (!driver_name.empty()) {\n                    NStr::Replace(*it, \"${driver}\", driver_name, entry_point_name);\n                }\n            }\n\n            // Check for the BASE library name macro\n\n            if ( entry_point_name.empty() )\n                continue;\n            p = dll->GetEntryPoint(entry_point_name);\n            if ( p.data ) {\n                entry_point.entry_points.push_back(SNamedEntryPoint(entry_point_name, p));\n            }\n        } // ITERATE\n\n        if ( entry_point.entry_points.empty() ) {\n            dll->Unload();\n            delete dll;\n            return false;\n        }\n        m_ResolvedEntries.push_back(entry_point);\n    }\n    catch (CCoreException& ex)\n    {\n        if (ex.GetErrCode() != CCoreException::eDll) {\n            throw;\n        }\n        NCBI_REPORT_EXCEPTION_X(2, \"CDllResolver::TryCandidate() failed\", ex);\n        return false;\n    }\n\n    return true;\n}\n\nstatic inline\nstring s_GetProgramPath(void)\n{\n    string dir;\n    CDirEntry::SplitPath\n        (CNcbiApplication::GetAppName(CNcbiApplication::eFullName), &dir);\n    return dir;\n}\n\nvoid CDllResolver::x_AddExtraDllPath(vector<string>& paths, TExtraDllPath which)\n{\n    if (which == fNoExtraDllPath) {\n        // Nothing to do\n        return;\n    }\n\n    // Add program executable path\n\n    if ((which & fProgramPath) != 0) {\n        string dir = s_GetProgramPath();\n        if ( !dir.empty() ) {\n            paths.push_back(dir);\n        }\n    }\n\n    // Add systems directories\n\n    if ((which & fSystemDllPath) != 0) {\n#if defined(NCBI_OS_MSWIN)\n        // Get Windows system directories\n        TXChar buf[MAX_PATH+1];\n        UINT len = GetSystemDirectory(buf, MAX_PATH+1);\n        if (len>0  &&  len<=MAX_PATH) {\n            paths.push_back(_T_STDSTRING(buf));\n        }\n        len = GetWindowsDirectory(buf, MAX_PATH+1);\n        if (len>0  &&  len<=MAX_PATH) {\n            paths.push_back(_T_STDSTRING(buf));\n        }\n        // Parse PATH environment variable\n        const TXChar* env = NcbiSys_getenv(_TX(\"PATH\"));\n        if (env  &&  *env) {\n            NStr::Split(_T_STDSTRING(env), \";\", paths);\n        }\n\n#elif defined(NCBI_OS_UNIX)\n        // From LD_LIBRARY_PATH environment variable\n        const char* env = getenv(\"LD_LIBRARY_PATH\");\n        if (env  &&  *env) {\n            NStr::Split(env, \":\", paths);\n        }\n#endif\n    }\n\n    // Add hard coded runpath\n\n    if ((which & fToolkitDllPath) != 0) {\n        const char* runpath = NCBI_GetRunpath();\n        if (runpath  &&  *runpath) {\n#  if defined(NCBI_OS_MSWIN)\n            NStr::Split(runpath, \";\", paths);\n#  elif defined(NCBI_OS_UNIX)\n            vector<string> tokenized;\n            NStr::Split(runpath, \":\", tokenized);\n            ITERATE(vector<string>, i, tokenized) {\n                if (i->find(\"$ORIGIN\") == NPOS) {\n                    paths.push_back(*i);\n                } else {\n                    string dir = s_GetProgramPath();\n                    if ( !dir.empty() ) {\n                        // Need to know the $ORIGIN else discard path.\n                        paths.push_back(NStr::Replace(*i, \"$ORIGIN\", dir));\n                    }\n                }\n            }\n#  else\n            paths.push_back(runpath);\n#  endif\n        }\n    }\n\n    return;\n}\n\nvoid CDllResolver::Unload()\n{\n    NON_CONST_ITERATE(TEntries, it, m_ResolvedEntries) {\n        if ( m_AutoUnloadDll == CDll::eAutoUnload ) {\n            it->dll->Unload();\n        }\n        delete it->dll;\n    }\n    m_ResolvedEntries.resize(0);\n}\n\n\nEND_NCBI_SCOPE\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/serial/datatool/testdata/data/set.bin",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/serial/datatool/testdata/res/set.bin",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/util/compress/bzip2/manual.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/util/compress/bzip2/manual.html",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/objtools/blast/seqdb_writer/unit_test/data/writedb_prot.psi",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/objtools/blast/seqdb_writer/unit_test/data/writedb_prot.pin",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/objtools/blast/seqdb_writer/unit_test/data/writedb_nucl.nog",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/objtools/blast/seqdb_writer/unit_test/data/writedb_prot.phr",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/objtools/blast/seqdb_writer/unit_test/data/writedb_nucl.nsi",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/objtools/blast/seqdb_writer/unit_test/data/writedb_nucl_v5.ntf-lock",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/objtools/blast/seqdb_writer/unit_test/data/writedb_nucl.nsq",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/objtools/blast/seqdb_writer/unit_test/data/writedb_nucl_v5.nhr",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/objtools/blast/seqdb_writer/unit_test/data/writedb_prot.pni",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/objtools/blast/seqdb_writer/unit_test/data/writedb_nucl.nhr",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/objtools/blast/seqdb_writer/unit_test/data/writedb_nucl_v5.nog",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/objtools/blast/seqdb_writer/unit_test/data/writedb_nucl_v5.ntf",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/objtools/blast/seqdb_writer/unit_test/data/writedb_nucl_v5.ndb-lock",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/objtools/blast/seqdb_writer/unit_test/data/writedb_nucl.nnd",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/objtools/blast/seqdb_writer/unit_test/data/writedb_prot.pnd",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/objtools/blast/seqdb_writer/unit_test/data/writedb_nucl_v5.nnd",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/objtools/blast/seqdb_writer/unit_test/data/writedb_nucl_v5.nin",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/objtools/blast/seqdb_writer/unit_test/data/writedb_nucl_v5.ndb",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/objtools/blast/seqdb_writer/unit_test/data/writedb_nucl_v5.nsq",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/objtools/blast/seqdb_writer/unit_test/data/writedb_nucl_v5.nos",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/objtools/blast/seqdb_writer/unit_test/data/writedb_nucl_v5.nni",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/objtools/blast/seqdb_writer/unit_test/data/writedb_nucl.nni",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/objtools/blast/seqdb_writer/unit_test/data/writedb_prot.pog",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/objtools/blast/seqdb_writer/unit_test/data/writedb_nucl.nin",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/objtools/blast/seqdb_reader/SeqDB-design-1.sxi",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/objtools/blast/blastdb_format/unit_test/data/test_pdb_v5.ptf",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/objtools/blast/blastdb_format/unit_test/data/test_pdb_v5.pog",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/objtools/blast/blastdb_format/unit_test/data/mask-data-db.pab",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/objtools/blast/blastdb_format/unit_test/data/seqp.psi",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/objtools/blast/blastdb_format/unit_test/data/mask-data-db.paa",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/objtools/blast/blastdb_format/unit_test/data/test_pdb_v5.pos",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/objtools/blast/blastdb_format/unit_test/data/mask-data-db.pnd",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/objtools/blast/blastdb_format/unit_test/data/seqp.pnd",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/objtools/blast/blastdb_format/unit_test/data/mask-data-db.pac",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/objtools/blast/blastdb_format/unit_test/data/seqp.phr",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/objtools/blast/blastdb_format/unit_test/data/seqp.pin",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/objtools/blast/blastdb_format/unit_test/data/mask-data-db.pin",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/objtools/blast/blastdb_format/unit_test/data/test_pdb_v5.pin",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/objtools/blast/blastdb_format/unit_test/data/test_pdb_v5.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/objtools/blast/blastdb_format/unit_test/data/seqp.pni",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/objtools/blast/blastdb_format/unit_test/data/mask-data-db.pni",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/objtools/blast/blastdb_format/unit_test/data/mask-data-db.phr",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/objtools/blast/blastdb_format/unit_test/data/test_pdb_v5.phr",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/objtools/blast/gene_info_reader/unit_test/data/geneinfo.g2o",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/objtools/blast/gene_info_reader/unit_test/data/geneinfo.i2o",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/objects/general/Dbtag.cpp",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/build-system/project_tree_builder_gui/bin/ptbgui.jar",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/build-system/project_tree_builder_gui/bin/lib/swing-layout-1.0.4.jar",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/build-system/project_tree_builder_gui/bin/lib/swing-layout-1.0.3.jar",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/build-system/cmake/ncbilogo.ico",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/build-system/project_tree_builder/ncbilogo.ico",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/long-tis.nin",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/nrshort.old.phr",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/seqn.nhr",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/seqp_v5.pdb-lock",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/vols_v5.00.nhr",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/ipg_test.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/15_seqs_v5.ndb",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/long-tis.nsq",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/mask-data-db.pab",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/big_gi.pni",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/user-column-db.pog",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/ntshort.old.nsq",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/seqp.psi",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/alias.seqidlist.bsl",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/mini-gnomon.psi",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/seqn.nnd",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/wp_nr_v5.pot",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/test_v5.pog",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/sparse_id.nhr",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/ipg_test.pnd",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/seqp_v5.pos",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/wp_nr_v5.pni",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/mask-data-db.paa",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/15_seqs_v5.nog",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/wp_nr.ppd",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/ntshort.nsi",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/long-tis.nhr",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/ntshort.nhr",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/wgs.ABDC.gil",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/test.entries.bsl",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/seqn.nni",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/user-column-db.pni",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/test_v5.pos",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/prot345b.gil",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/user-column-db.pin",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/nrshort.old.pni",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/test_v4.pni",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/test_v5.ptf-lock",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/test_v5.pnd",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/empty-mask-data-db.nin",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/ipg_test.pin",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/15_seqs_v5.nsq",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/vols_v5.01.nhr",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/test_v5.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/mask-data-db.pnd",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/vols_v5.01.nin",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/seqp_v5.pni",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/test_v4.pog",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/vols_v5.ntf",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/ntshort.old.nni",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/wp_nr.psi",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/vols_v5.ndb",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/nrshort.pog",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/ipg_test.pni",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/ntshort.old.nnd",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/broken-mask-data-db.phr",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/mini-gnomon.pin",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/wp_nr_v5.ppi",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/ntshort.nin",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/sparse_id.nin",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/wp_nr.pnd",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/seqp_v5.pog",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/wp_nr_v5.pdb-lock",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/empty-mask-data-db.nog",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/nrshort.old.psi",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/test_v4.phr",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/nrshort.old.pin",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/broken-mask-data-db.psi",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/mini-gnomon.phr",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/empty-mask-data-db.nsq",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/15_seqs.gil",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/ipg_test.pot",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/test_v5.pni",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/15_seqs_v5.nin",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/seqp.pnd",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/mask-data-db.pac",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/test_v5.phr",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/big_gi.pnd",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/wp_nr_v5.ptf",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/seqn.nin",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/empty-mask-data-db.nsi",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/15_seqs_v5.nhr",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/wp_nr.pni",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/ntshort.nnd",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/wp_nr_v5.pog",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/ipg_test.ppd",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/seqp.phr",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/vols_v5.00.nni",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/test_v4.psi",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/f555.nhr",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/vols_v5.00.nnd",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/user-column-db.psi",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/vols_v5.01.nog",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/ntshort.nni",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/ipg_test.ppi",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/15_seqs_v5.not",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/user-column-db.pnd",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/seqp_v5.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/test_v4.pnd",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/wp_nr.phr",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/mask-data-db.pog",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/test_v5.pin",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/broken-mask-data-db.pni",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/nrshort.old.pog",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/testfile1.sqlite",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/seqp.pin",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/seqp.pog",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/wp_nr.pin",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/wp_nr.ppi",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/15_seqs_v5.ntf",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/seqn.nsi",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/seqn.nog",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/seqp_v5.pnd",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/f556.nsq",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/f556.nhr",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/short-tis.nsq",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/ntshort.nsq",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/mask-data-db.pin",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/nrshort.old.pnd",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/broken-mask-data-db.pin",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/nrshort.pnd",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/seqp_v5.ptf",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/seqp_v5.ptf-lock",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/empty-mask-data-db.nhr",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/short-tis.nhr",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/test_v5.ptf",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/sparse_id.nsq",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/wgs.AADN.gil",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/wp_nr_v5.ptf-lock",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/vols_v5.00.nog",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/ipg_test.pog",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/ntshort.old.nhr",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/long-tis.nti",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/ntshort.nog",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/f555.nsq",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/wp_nr_v5.pnd",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/wp_nr.pog",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/vols_v5.not",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/nrshort.psi",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/seqp.pni",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/broken-mask-data-db.pnd",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/nrshort.phr",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/15_seqs_v5.nos",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/15_seqs_v5.nni",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/seqp_v5.pin",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/mask-data-db.pni",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/short-tis.nti",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/wp_nr_v5.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/test_v5.pdb-lock",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/vols_v5.00.nin",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/vols_v5.00.nsq",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/mask-data-db.phr",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/short-tis.ntd",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/user-column-db.phr",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/ipg_test.phr",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/seqn.nsq",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/wp_nr_v5.phr",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/ntshort.old.nog",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/ipg_test.ptf",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/long-tis.ntd",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/mini-gnomon.pog",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/short-tis.nin",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/broken-mask-data-db.pab",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/wp_nr_v5.pin",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/test_v4.pin",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/ntshort.old.nin",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/wp_nr_v5.ppd",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/sparse_id.nni",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/vols_v5.01.nnd",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/f555.nin",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/vols_v5.01.nsq",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/seqp_v5.phr",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/15_seqs_v5.nnd",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/nrshort.pni",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/nrshort.pin",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/vols_v5.01.nni",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/seqdb_reader/data/ranges/evenp.msk",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/rpstest_be.pnd",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/seqn.nhr",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/nt.41646578.nab",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/seqp.psi",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/seqn.nnd",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/rpstest_le.rps",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/deltatest_nocbs.pin",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/rpstest_be.loo",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/deltatest.freq",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/seqn.nni",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/rpstest_le.pin",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/deltatest.pin",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/nt.41646578.nin",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/deltatest_nocbs.phr",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/pombe.nin",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/rpstest_be.phr",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/nt.41646578.nsq",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/deltatest.rps",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/deltatest_nocbs.rps",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/nt.41646578.naa",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/seqp.pnd",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/deltatest.loo",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/seqn.nin",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/long_seqs.ntf",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/rpstest_le.freq",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/seqp.phr",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/deltatest_nocbs.obsr",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/rpstest_le.pnd",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/long_seqs.ndb",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/pombe.nsq",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/rpstest_be.rps",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/seqp.pin",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/seqn.nsi",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/rpstest_le.pni",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/rpstest_le.loo",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/pombe.nhr",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/nt.41646578.nog",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/long_seqs.nog",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/rpstest_be.pin",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/pombe.nog",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/seqp.pni",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/deltatest.obsr",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/rpstest_be.pni",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/nt.41646578.nac",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/long_seqs.nsq",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/long_seqs.nhr",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/nt.41646578.nhr",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/deltatest_nocbs.wcounts",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/seqn.nsq",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/rpstest_le.phr",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/long_seqs.nin",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/deltatest_nocbs.loo",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/deltatest.phr",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/unit_tests/api/data/deltatest.wcounts",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/proteinkmer/unit_test/data/nr_test.pnd",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/proteinkmer/unit_test/data/XP_001468867.pnd",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/proteinkmer/unit_test/data/nr_test.psi",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/proteinkmer/unit_test/data/nr_test.pkd",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/proteinkmer/unit_test/data/manyXs.pog",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/proteinkmer/unit_test/data/nr_test.phr",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/proteinkmer/unit_test/data/nr_test.pni",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/proteinkmer/unit_test/data/nr_test.pog",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/proteinkmer/unit_test/data/XP_001468867.pog",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/proteinkmer/unit_test/data/nr_test.pki",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/proteinkmer/unit_test/data/manyXs.phr",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/proteinkmer/unit_test/data/nr_test.pin",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/proteinkmer/unit_test/data/XP_001468867.phr",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/proteinkmer/unit_test/data/XP_001468867.pni",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/dbindex/README.usage",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/blastinput/unit_test/data/pdb_test.pot",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/blastinput/unit_test/data/pdb_test.pog",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/blastinput/unit_test/data/pdb_test.phr",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/blastinput/unit_test/data/pdb_test.pdb",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/blastinput/unit_test/data/pdb_test.pos",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/blastinput/unit_test/data/pdb_test.pto",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/blastinput/unit_test/data/WGS_test.nog",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/blastinput/unit_test/data/WGS_test.ndb",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/blastinput/unit_test/data/WGS_test.ntf",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/blastinput/unit_test/data/WGS_test.nhr",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/blastinput/unit_test/data/pdb_test.pin",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/blastinput/unit_test/data/WGS_test.nin",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/blastinput/unit_test/data/pdb_test.ptf",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/src/algo/blast/blastinput/unit_test/data/WGS_test.nsq",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/include/objtools/cleanup/cleanup.hpp",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/compilers/vs2015/ncbilogo.ico",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/compilers/vs2017/ncbilogo.ico",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/scripts/projects/blast/post_build/win/ncbilogo.ico",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/scripts/projects/blast/post_build/macosx/large-Blue_ncbi_logo.tiff",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/scripts/projects/blast/post_build/macosx/uninstall_ncbi_blast.zip",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/scripts/projects/quickblastp/post_build/win/ncbilogo.ico",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/scripts/projects/quickblastp/post_build/macosx/large-Blue_ncbi_logo.tiff",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/scripts/projects/quickblastp/post_build/macosx/uninstall_ncbi_magicblast.zip",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/scripts/projects/cobalt/post_build/win/ncbilogo.ico",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/scripts/projects/cobalt/post_build/macosx/large-Blue_ncbi_logo.tiff",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/scripts/projects/cobalt/post_build/macosx/uninstall_ncbi_cobalt.zip",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/scripts/projects/magicblast/post_build/win/ncbilogo.ico",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/scripts/projects/magicblast/post_build/macosx/large-Blue_ncbi_logo.tiff",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/scripts/projects/magicblast/post_build/macosx/uninstall_ncbi_magicblast.zip",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/scripts/projects/igblast/post_build/win/ncbilogo.ico",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/scripts/projects/igblast/post_build/macosx/large-Blue_ncbi_logo.tiff",
        "/tmp/vanessa/spack-stage/spack-stage-blast-plus-2.11.0-cbyte57buyvkwiyq4jxltq7jnmij5cmx/spack-src/c++/scripts/projects/igblast/post_build/macosx/uninstall_ncbi_igblast.zip"
    ],
    "total_files": 5971
}