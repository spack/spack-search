{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-watch-master-rbge43aeb6b22jpwxmvck4uuyyaonhf4/spack-src/ps/output.c": "/*\n * output.c - ps output definitions\n * Copyright 1999-2004 by Albert Cahalan\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n/*\n * This file is really gross, and I know it. I looked into several\n * alternate ways to deal with the mess, and they were all ugly.\n *\n * FreeBSD has a fancy hack using offsets into a struct -- that\n * saves code but it is _really_ gross. See the PO macro below.\n *\n * We could have a second column width for wide output format.\n * For example, Digital prints the real-time signals.\n */\n\n/*\n * Data table idea:\n *\n * table 1 maps aix to specifier\n * table 2 maps shortsort to specifier\n * table 3 maps macro to specifiers\n * table 4 maps specifier to title,datatype,offset,vendor,helptext\n * table 5 maps datatype to justification,width,widewidth,sorting,printing\n *\n * Here, \"datatype\" could be user,uid,u16,pages,deltaT,signals,tty,longtty...\n * It must be enough to determine printing and sorting.\n *\n * After the tables, increase width as needed to fit the header.\n *\n * Table 5 could go in a file with the output functions.\n */\n\n#include <ctype.h>\n#if ENABLE_LIBSELINUX\n#include <dlfcn.h>\n#endif\n#include <fcntl.h>\n#include <grp.h>\n#include <limits.h>\n#include <pwd.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n#include <unistd.h>\n\n#include <sys/ioctl.h>\n#include <sys/mman.h>\n#include <sys/resource.h>\n#include <sys/types.h>\n\n#include \"../proc/readproc.h\"\n#include \"../proc/sysinfo.h\"\n#include \"../proc/wchan.h\"\n#include \"../proc/procps.h\"\n#include \"../proc/devname.h\"\n#include \"../proc/escape.h\"\n#include \"../proc/numa.h\"\n\n#include \"common.h\"\n\n/* TODO:\n * Stop assuming system time is local time.\n */\n\n#define COLWID 240 /* satisfy snprintf, which is faster than sprintf */\n\nstatic unsigned max_rightward = OUTBUF_SIZE-1; /* space for RIGHT stuff */\nstatic unsigned max_leftward = OUTBUF_SIZE-1; /* space for LEFT stuff */\n\n\n\nstatic int wide_signals;  /* true if we have room */\n\nstatic time_t seconds_since_1970;\n\n\n/*************************************************************************/\n/************ Lots of sort functions, starting with the NOP **************/\n\nstatic int sr_nop(const proc_t* a, const proc_t* b){\n  (void)a;(void)b; /* shut up gcc */\n  return 0;\n}\n\nstatic int sr_cgroup(const proc_t* a, const proc_t* b)\n{\n    /* This is a \"vector\" of one */\n    if (*a->cgroup == NULL || *b->cgroup == NULL)\n        return 0;\n    return strcmp(*a->cgroup, *b->cgroup);\n}\n\n#define CMP_STR(NAME) \\\nstatic int sr_ ## NAME(const proc_t* P, const proc_t* Q) { \\\n    return strcmp(P->NAME, Q->NAME); \\\n}\n\n#define CMP_INT(NAME) \\\nstatic int sr_ ## NAME (const proc_t* P, const proc_t* Q) { \\\n    if (P->NAME < Q->NAME) return -1; \\\n    if (P->NAME > Q->NAME) return  1; \\\n    return 0; \\\n}\n\n/* fast versions, for values which either:\n * a. differ by no more than 0x7fffffff\n * b. only need to be grouped same w/ same\n */\n#define CMP_SMALL(NAME) \\\nstatic int sr_ ## NAME (const proc_t* P, const proc_t* Q) { \\\n    return (int)(P->NAME) - (int)(Q->NAME); \\\n}\n#define CMP_SMALL2(NAME,WHAT) \\\nstatic int sr_ ## NAME (const proc_t* P, const proc_t* Q) { \\\n    return (int)(P->WHAT) - (int)(Q->WHAT); \\\n}\n\n#define cook_time(P) (P->utime + P->stime) / Hertz\n\n#define cook_etime(P) (((unsigned long long)seconds_since_boot >= (P->start_time / Hertz)) ? ((unsigned long long)seconds_since_boot - (P->start_time / Hertz)) : 0)\n\n#define CMP_COOKED_TIME(NAME) \\\nstatic int sr_ ## NAME (const proc_t* P, const proc_t* Q) { \\\n    unsigned long p_time,q_time; \\\n    p_time=cook_ ##NAME (P); \\\n    q_time=cook_ ##NAME (Q); \\\n    if (p_time < q_time) return -1; \\\n    if (p_time > q_time) return 1; \\\n    return 0; \\\n}\n\n#define CMP_NS(NAME, ID) \\\nstatic int sr_ ## NAME (const proc_t* P, const proc_t* Q) { \\\n    if ((unsigned long)P->ns[ID] < (unsigned long)Q->ns[ID]) return -1; \\\n    if ((unsigned long)P->ns[ID] > (unsigned long)Q->ns[ID]) return  1; \\\n    return 0; \\\n}\n\nCMP_INT(rtprio)\nCMP_SMALL(sched)\nCMP_INT(cutime)\nCMP_SMALL(priority)                                             /* nice */\nCMP_SMALL(nlwp)\nCMP_SMALL(nice)                                                 /* priority */\nCMP_INT(rss)      /* resident set size from stat file */ /* vm_rss, resident */\nCMP_INT(alarm)\nCMP_INT(size)      /* total pages */                     /* vm_size, vsize */\nCMP_INT(resident)  /* resident pages */                     /* vm_rss, rss */\nCMP_INT(share)     /* shared pages */\nCMP_INT(trs)       /* executable pages */\nCMP_INT(lrs)       /* obsolete \"library\" pages above 0x60000000 */\nCMP_INT(drs)       /* other pages (assumed data?) */\nCMP_INT(dt)        /* dirty pages */\n\nCMP_INT(vm_size)    /* kB VM */                             /* size, vsize */\nCMP_INT(vm_lock)    /* kB locked */\nCMP_INT(vm_rss)     /* kB rss */                          /* rss, resident */\nCMP_INT(vm_data)    /* kB \"data\" == data-stack */\nCMP_INT(vm_stack)   /* kB stack */\nCMP_INT(vm_exe)     /* kB \"exec\" == exec-lib */\nCMP_INT(vm_lib)     /* kB \"libraries\" */\nCMP_INT(vsize)      /* pages VM */                        /* size, vm_size */\nCMP_INT(rss_rlim)\nCMP_SMALL(flags)\nCMP_INT(min_flt)\nCMP_INT(maj_flt)\nCMP_INT(cmin_flt)\nCMP_INT(cmaj_flt)\nCMP_INT(utime)\nCMP_INT(stime)    /* Old: sort by systime. New: show start time. Uh oh. */\nCMP_INT(start_code)\nCMP_INT(end_code)\nCMP_INT(start_stack)\nCMP_INT(kstk_esp)\nCMP_INT(kstk_eip)\nCMP_INT(start_time)\nCMP_INT(wchan)\n\n/* CMP_STR(*environ) */\n/* CMP_STR(*cmdline) */\n\nCMP_STR(ruser)\nCMP_STR(euser)\nCMP_STR(suser)\nCMP_STR(fuser)\nCMP_STR(rgroup)\nCMP_STR(egroup)\nCMP_STR(sgroup)\nCMP_STR(fgroup)\nCMP_STR(cmd)\n/* CMP_STR(ttyc) */    /* FIXME -- use strncmp with 8 max */\n\nCMP_INT(ruid)\nCMP_INT(rgid)\nCMP_INT(euid)\nCMP_INT(egid)\nCMP_INT(suid)\nCMP_INT(sgid)\nCMP_INT(fuid)\nCMP_INT(fgid)\nCMP_SMALL2(procs,tgid)\nCMP_SMALL2(tasks,tid)\nCMP_SMALL(ppid)\nCMP_SMALL(pgrp)\nCMP_SMALL(session)\nCMP_INT(tty)\nCMP_SMALL(tpgid)\n\nCMP_SMALL(pcpu)\n\nCMP_SMALL(state)\n\nCMP_COOKED_TIME(time)\nCMP_COOKED_TIME(etime)\n\nCMP_NS(ipcns, IPCNS);\nCMP_NS(mntns, MNTNS);\nCMP_NS(netns, NETNS);\nCMP_NS(pidns, PIDNS);\nCMP_NS(userns, USERNS);\nCMP_NS(utsns, UTSNS);\n\nCMP_STR(lxcname)\nCMP_STR(cgname)\n\n/* approximation to: kB of address space that could end up in swap */\nstatic int sr_swapable(const proc_t* P, const proc_t* Q) {\n  unsigned long p_swapable = P->vm_data + P->vm_stack;\n  unsigned long q_swapable = Q->vm_data + Q->vm_stack;\n  if (p_swapable < q_swapable) return -1;\n  if (p_swapable > q_swapable) return  1;\n  return 0;\n}\n\n\n/***************************************************************************/\n/************ Lots of format functions, starting with the NOP **************/\n\n// so popular it can't be \"static\"\nint pr_nop(char *restrict const outbuf, const proc_t *restrict const pp){\n  (void)pp;\n  return snprintf(outbuf, COLWID, \"%c\", '-');\n}\n\n\n/********* Unix 98 ************/\n\n/***\n\nOnly comm and args are allowed to contain blank characters; all others are\nnot. Any implementation-dependent variables will be specified in the system\ndocumentation along with the default header and indicating if the field\nmay contain blank characters.\n\nSome headers do not have a standardized specifier!\n\n%CPU\tpcpu\tThe % of cpu time used recently, with unspecified \"recently\".\nADDR\t\tThe address of the process.\nC\t\tProcessor utilisation for scheduling.\nCMD\t\tThe command name, or everything with -f.\nCOMMAND\targs\tCommand + args. May chop as desired. May use either version.\nCOMMAND\tcomm\targv[0]\nELAPSED\tetime\tElapsed time since the process was started. [[dd-]hh:]mm:ss\nF\t\tFlags (octal and additive)\nGROUP\tgroup\tEffective group ID, prefer text over decimal.\nNI\tnice\tDecimal system scheduling priority, see nice(1).\nPGID\tpgid\tThe decimal value of the process group ID.\nPID\tpid\tDecimal PID.\nPPID\tppid\tDecimal PID.\nPRI\t\tPriority. Higher numbers mean lower priority.\nRGROUP\trgroup\tReal group ID, prefer text over decimal.\nRUSER\truser\tReal user ID, prefer text over decimal.\nS\t\tThe state of the process.\nSTIME\t\tStarting time of the process.\nSZ\t\tThe size in blocks of the core image of the process.\nTIME\ttime\tCumulative CPU time. [dd-]hh:mm:ss\nTT\ttty\tName of tty in format used by who(1).\nTTY\t\tThe controlling terminal for the process.\nUID\t\tUID, or name when -f\nUSER\tuser\tEffective user ID, prefer text over decimal.\nVSZ\tvsz\tVirtual memory size in decimal kB.\nWCHAN\t\tWhere waiting/sleeping or blank if running.\n\nThe nice value is used to compute the priority.\n\nFor some undefined ones, Digital does:\n\nF       flag    Process flags -- but in hex!\nPRI     pri     Process priority\nS       state   Symbolic process status\nTTY     tt,tty,tname,longtname  -- all do \"ttyp1\", \"console\", \"??\"\nUID     uid     Process user ID (effective UID)\nWCHAN   wchan   Address of event on which a\n\nFor some undefined ones, Sun does:\n\nADDR\taddr\tmemory address of the process\nC\tc\tProcessor utilization  for  scheduling  (obsolete).\nCMD\nF\tf\nS\ts\tstate: OSRZT\nSTIME\t\tstart time, printed w/o blanks. If 24h old, months & days\nSZ\t\tsize (in pages) of the swappable process's image in main memory\nTTY\nUID\tuid\nWCHAN\twchan\n\nFor some undefined ones, SCO does:\nADDR\taddr\tVirtual address of the process' entry in the process table.\nSZ\t\tswappable size in kB of the virtual data and stack\nSTIME\tstime\thms or md time format\n***/\n\n/* Source & destination are known. Return bytes or screen characters? */\n//\n//       OldLinux   FreeBSD    HPUX\n// ' '    '    '     '  '      '  '\n// 'L'    ' \\_ '     '`-'      '  '\n// '+'    ' \\_ '     '|-'      '  '\n// '|'    ' |  '     '| '      '  '\n//\nstatic int forest_helper(char *restrict const outbuf){\n  char *p = forest_prefix;\n  char *q = outbuf;\n  int rightward = max_rightward < OUTBUF_SIZE ? max_rightward : OUTBUF_SIZE-1;\n  *q = '\\0';\n  if(!*p) return 0;\n  /* Arrrgh! somebody defined unix as 1 */\n  if(forest_type == 'u') goto unixy;\n  while(*p){\n    if (rightward < 4) break;\n    switch(*p){\n    case ' ': strcpy(q, \"    \");  break;\n    case 'L': strcpy(q, \" \\\\_ \"); break;\n    case '+': strcpy(q, \" \\\\_ \"); break;\n    case '|': strcpy(q, \" |  \");  break;\n    case '\\0': return q-outbuf;    /* redundant & not used */\n    }\n    q += 4;\n    rightward -= 4;\n    p++;\n  }\n  return q-outbuf;   /* gcc likes this here */\nunixy:\n  while(*p){\n    if (rightward < 2) break;\n    switch(*p){\n    case ' ': strcpy(q, \"  \"); break;\n    case 'L': strcpy(q, \"  \"); break;\n    case '+': strcpy(q, \"  \"); break;\n    case '|': strcpy(q, \"  \"); break;\n    case '\\0': return q-outbuf;    /* redundant & not used */\n    }\n    q += 2;\n    rightward -= 2;\n    p++;\n  }\n  return q-outbuf;   /* gcc likes this here */\n}\n\n\n/* XPG4-UNIX, according to Digital:\nThe \"args\" and \"command\" specifiers show what was passed to the command.\nModifications to the arguments are not shown.\n*/\n\n/*\n * pp->cmd       short accounting name (comm & ucomm)\n * pp->cmdline   long name with args (args & command)\n * pp->environ   environment\n */\n\n// FIXME: some of these may hit the guard page in forest mode\n\n#define OUTBUF_SIZE_AT(endp) \\\n  (((endp) >= outbuf && (endp) < outbuf + OUTBUF_SIZE) ? (outbuf + OUTBUF_SIZE) - (endp) : 0)\n\n/*\n * \"args\", \"cmd\", \"command\" are all the same:  long  unless  c\n * \"comm\", \"ucmd\", \"ucomm\"  are all the same:  short unless -f\n * ( determinations are made in display.c, we mostly deal with results ) */\nstatic int pr_args(char *restrict const outbuf, const proc_t *restrict const pp){\n  char *endp = outbuf;\n  int rightward = max_rightward;\n  int fh = forest_helper(outbuf);\n\n  endp += fh;\n  rightward -= fh;\n\n  if(pp->cmdline && !bsd_c_option)\n    endp += escape_str(endp, *pp->cmdline, OUTBUF_SIZE_AT(endp), &rightward);\n  else\n    endp += escape_command(endp, pp, OUTBUF_SIZE_AT(endp), &rightward, ESC_DEFUNCT);\n\n  if(bsd_e_option && rightward>1 && OUTBUF_SIZE_AT(endp)>1) {\n    if(pp->environ && *pp->environ) {\n      *endp++ = ' ';\n      rightward--;\n      endp += escape_strlist(endp, pp->environ, OUTBUF_SIZE_AT(endp), &rightward);\n    }\n  }\n  return max_rightward-rightward;\n}\n\n/*\n * \"args\", \"cmd\", \"command\" are all the same:  long  unless  c\n * \"comm\", \"ucmd\", \"ucomm\"  are all the same:  short unless -f\n * ( determinations are made in display.c, we mostly deal with results ) */\nstatic int pr_comm(char *restrict const outbuf, const proc_t *restrict const pp){\n  char *endp = outbuf;\n  int rightward = max_rightward;\n  int fh = forest_helper(outbuf);\n\n  endp += fh;\n  rightward -= fh;\n\n  if(pp->cmdline && unix_f_option)\n    endp += escape_str(endp, *pp->cmdline, OUTBUF_SIZE_AT(endp), &rightward);\n  else\n    endp += escape_command(endp, pp, OUTBUF_SIZE_AT(endp), &rightward, ESC_DEFUNCT);\n\n  if(bsd_e_option && rightward>1 && OUTBUF_SIZE_AT(endp)>1) {\n    if(pp->environ && *pp->environ) {\n      *endp++ = ' ';\n      rightward--;\n      endp += escape_strlist(endp, pp->environ, OUTBUF_SIZE_AT(endp), &rightward);\n    }\n  }\n  return max_rightward-rightward;\n}\n\nstatic int pr_cgname(char *restrict const outbuf, const proc_t *restrict const pp){\n  int rightward = max_rightward;\n\n  escape_str(outbuf, pp->cgname, OUTBUF_SIZE, &rightward);\n  return max_rightward-rightward;\n}\n\nstatic int pr_cgroup(char *restrict const outbuf,const proc_t *restrict const pp) {\n  int rightward = max_rightward;\n\n  escape_str(outbuf, *pp->cgroup, OUTBUF_SIZE, &rightward);\n  return max_rightward-rightward;\n}\n\n/* Non-standard, from SunOS 5 */\nstatic int pr_fname(char *restrict const outbuf, const proc_t *restrict const pp){\n  char *endp = outbuf;\n  int rightward = max_rightward;\n  int fh = forest_helper(outbuf);\n\n  endp += fh;\n  rightward -= fh;\n\n  if (rightward>8)  /* 8=default, but forest maybe feeds more */\n    rightward = 8;\n\n  endp += escape_str(endp, pp->cmd, OUTBUF_SIZE_AT(endp), &rightward);\n  //return endp - outbuf;\n  return max_rightward-rightward;\n}\n\n#undef OUTBUF_SIZE_AT\n\n/* elapsed wall clock time, [[dd-]hh:]mm:ss format (not same as \"time\") */\nstatic int pr_etime(char *restrict const outbuf, const proc_t *restrict const pp){\n  unsigned long t;\n  unsigned dd,hh,mm,ss;\n  char *cp = outbuf;\n  t = cook_etime(pp);\n  ss = t%60;\n  t /= 60;\n  mm = t%60;\n  t /= 60;\n  hh = t%24;\n  t /= 24;\n  dd = t;\n  cp +=(     dd      ?  snprintf(cp, COLWID, \"%u-\", dd)           :  0 );\n  cp +=( (dd || hh)  ?  snprintf(cp, COLWID, \"%02u:\", hh)         :  0 );\n  cp +=                 snprintf(cp, COLWID, \"%02u:%02u\", mm, ss)       ;\n  return (int)(cp-outbuf);\n}\n\n/* elapsed wall clock time in seconds */\nstatic int pr_etimes(char *restrict const outbuf, const proc_t *restrict const pp){\n  unsigned t = cook_etime(pp);\n  return snprintf(outbuf, COLWID, \"%u\", t);\n}\n\n/* \"Processor utilisation for scheduling.\"  --- we use %cpu w/o fraction */\nstatic int pr_c(char *restrict const outbuf, const proc_t *restrict const pp){\n  unsigned long long total_time;   /* jiffies used by this process */\n  unsigned pcpu = 0;               /* scaled %cpu, 99 means 99% */\n  unsigned long long seconds;      /* seconds of process life */\n  total_time = pp->utime + pp->stime;\n  if(include_dead_children) total_time += (pp->cutime + pp->cstime);\n  seconds = cook_etime(pp);\n  if(seconds) pcpu = (total_time * 100ULL / Hertz) / seconds;\n  if (pcpu > 99U) pcpu = 99U;\n  return snprintf(outbuf, COLWID, \"%2u\", pcpu);\n}\n/* normal %CPU in ##.# format. */\nstatic int pr_pcpu(char *restrict const outbuf, const proc_t *restrict const pp){\n  unsigned long long total_time;   /* jiffies used by this process */\n  unsigned pcpu = 0;               /* scaled %cpu, 999 means 99.9% */\n  unsigned long long seconds;      /* seconds of process life */\n  total_time = pp->utime + pp->stime;\n  if(include_dead_children) total_time += (pp->cutime + pp->cstime);\n  seconds = cook_etime(pp);\n  if(seconds) pcpu = (total_time * 1000ULL / Hertz) / seconds;\n  if (pcpu > 999U)\n    return snprintf(outbuf, COLWID, \"%u\", pcpu/10U);\n  return snprintf(outbuf, COLWID, \"%u.%u\", pcpu/10U, pcpu%10U);\n}\n/* this is a \"per-mill\" format, like %cpu with no decimal point */\nstatic int pr_cp(char *restrict const outbuf, const proc_t *restrict const pp){\n  unsigned long long total_time;   /* jiffies used by this process */\n  unsigned pcpu = 0;               /* scaled %cpu, 999 means 99.9% */\n  unsigned long long seconds;      /* seconds of process life */\n  total_time = pp->utime + pp->stime;\n  if(include_dead_children) total_time += (pp->cutime + pp->cstime);\n  seconds = cook_etime(pp);\n  if(seconds) pcpu = (total_time * 1000ULL / Hertz) / seconds;\n  if (pcpu > 999U) pcpu = 999U;\n  return snprintf(outbuf, COLWID, \"%3u\", pcpu);\n}\n\nstatic int pr_pgid(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%u\", pp->pgrp);\n}\nstatic int pr_ppid(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%u\", pp->ppid);\n}\n\n\n/* cumulative CPU time, [dd-]hh:mm:ss format (not same as \"etime\") */\nstatic int pr_time(char *restrict const outbuf, const proc_t *restrict const pp){\n  unsigned long t;\n  unsigned dd,hh,mm,ss;\n  int c;\n  t = cook_time(pp);\n  ss = t%60;\n  t /= 60;\n  mm = t%60;\n  t /= 60;\n  hh = t%24;\n  t /= 24;\n  dd = t;\n  c  =( dd ? snprintf(outbuf, COLWID, \"%u-\", dd) : 0              );\n  c +=( snprintf(outbuf+c, COLWID, \"%02u:%02u:%02u\", hh, mm, ss)    );\n  return c;\n}\n\n/* cumulative CPU time in seconds (not same as \"etimes\") */\nstatic int pr_times(char *restrict const outbuf, const proc_t *restrict const pp){\n  unsigned t = cook_time(pp);\n  return snprintf(outbuf, COLWID, \"%u\", t);\n}\n\n/* HP-UX puts this (I forget, vsz or vsize?) in kB and uses \"sz\" for pages.\n * Unix98 requires \"vsz\" to be kB.\n * Tru64 does both vsize and vsz like \"1.23M\"\n *\n * Our pp->vm_size is kB and our pp->vsize is pages.\n *\n * TODO: add flag for \"1.23M\" behavior, on this and other columns.\n */\nstatic int pr_vsz(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%lu\", pp->vm_size);\n}\n\n//////////////////////////////////////////////////////////////////////////////////////\n\n// \"PRI\" is created by \"opri\", or by \"pri\" when -c is used.\n//\n// Unix98 only specifies that a high \"PRI\" is low priority.\n// Sun and SCO add the -c behavior. Sun defines \"pri\" and \"opri\".\n// Linux may use \"priority\" for historical purposes.\n//\n// According to the kernel's fs/proc/array.c and kernel/sched.c source,\n// the kernel reports it in /proc via this:\n//        p->prio - MAX_RT_PRIO\n// such that \"RT tasks are offset by -200. Normal tasks are centered\n// around 0, value goes from -16 to +15\" but who knows if that is\n// before or after the conversion...\n//\n// <linux/sched.h> says:\n// MAX_RT_PRIO is currently 100.       (so we see 0 in /proc)\n// RT tasks have a p->prio of 0 to 99. (so we see -100 to -1)\n// non-RT tasks are from 100 to 139.   (so we see 0 to 39)\n// Lower values have higher priority, as in the UNIX standard.\n//\n// In any case, pp->priority+100 should get us back to what the kernel\n// has for p->prio.\n//\n// Test results with the \"yes\" program on a 2.6.x kernel:\n//\n// # ps -C19,_20 -o pri,opri,intpri,priority,ni,pcpu,pid,comm\n// PRI PRI PRI PRI  NI %CPU  PID COMMAND\n//   0  99  99  39  19 10.6 8686 19\n//  34  65  65   5 -20 94.7 8687 _20\n//\n// Grrr. So the UNIX standard \"PRI\" must NOT be from \"pri\".\n// Either of the others will do. We use \"opri\" for this.\n// (and use \"pri\" when the \"-c\" option is used)\n// Probably we should have Linux-specific \"pri_for_l\" and \"pri_for_lc\"\n//\n// sched_get_priority_min.2 says the Linux static priority is\n// 1..99 for RT and 0 for other... maybe 100 is kernel-only?\n//\n// A nice range would be -99..0 for RT and 1..40 for normal,\n// which is pp->priority+1. (3-digit max, positive is normal,\n// negative or 0 is RT, and meets the standard for PRI)\n//\n\n// legal as UNIX \"PRI\"\n// \"priority\"         (was -20..20, now -100..39)\nstatic int pr_priority(char *restrict const outbuf, const proc_t *restrict const pp){    /* -20..20 */\n    return snprintf(outbuf, COLWID, \"%ld\", pp->priority);\n}\n\n// legal as UNIX \"PRI\"\n// \"intpri\" and \"opri\" (was 39..79, now  -40..99)\nstatic int pr_opri(char *restrict const outbuf, const proc_t *restrict const pp){        /* 39..79 */\n    return snprintf(outbuf, COLWID, \"%ld\", 60 + pp->priority);\n}\n\n// legal as UNIX \"PRI\"\n// \"pri_foo\"   --  match up w/ nice values of sleeping processes (-120..19)\nstatic int pr_pri_foo(char *restrict const outbuf, const proc_t *restrict const pp){\n    return snprintf(outbuf, COLWID, \"%ld\", pp->priority - 20);\n}\n\n// legal as UNIX \"PRI\"\n// \"pri_bar\"   --  makes RT pri show as negative       (-99..40)\nstatic int pr_pri_bar(char *restrict const outbuf, const proc_t *restrict const pp){\n    return snprintf(outbuf, COLWID, \"%ld\", pp->priority + 1);\n}\n\n// legal as UNIX \"PRI\"\n// \"pri_baz\"   --  the kernel's ->prio value, as of Linux 2.6.8     (1..140)\nstatic int pr_pri_baz(char *restrict const outbuf, const proc_t *restrict const pp){\n    return snprintf(outbuf, COLWID, \"%ld\", pp->priority + 100);\n}\n\n\n// not legal as UNIX \"PRI\"\n// \"pri\"               (was 20..60, now    0..139)\nstatic int pr_pri(char *restrict const outbuf, const proc_t *restrict const pp){         /* 20..60 */\n    return snprintf(outbuf, COLWID, \"%ld\", 39 - pp->priority);\n}\n\n// not legal as UNIX \"PRI\"\n// \"pri_api\"   --  match up w/ RT API    (-40..99)\nstatic int pr_pri_api(char *restrict const outbuf, const proc_t *restrict const pp){\n    return snprintf(outbuf, COLWID, \"%ld\", -1 - pp->priority);\n}\n\n// Linux applies nice value in the scheduling policies (classes)\n// SCHED_OTHER(0) and SCHED_BATCH(3).  Ref: sched_setscheduler(2).\n// Also print nice value for old kernels which didn't use scheduling\n// policies (-1).\nstatic int pr_nice(char *restrict const outbuf, const proc_t *restrict const pp){\n  if(pp->sched!=0 && pp->sched!=3 && pp->sched!=-1) return snprintf(outbuf, COLWID, \"-\");\n  return snprintf(outbuf, COLWID, \"%ld\", pp->nice);\n}\n\n// HP-UX   \"cls\": RT RR RR2 ???? HPUX FIFO KERN\n// Solaris \"class\": SYS TS FX IA RT FSS (FIFO is RR w/ Inf quant)\n//                  FIFO+RR share RT; FIFO has Inf quant\n//                  IA=interactive; FX=fixed; TS=timeshare; SYS=system\n//                  FSS=fairshare; INTS=interrupts\n// Tru64   \"policy\": FF RR TS\n// IRIX    \"class\": RT TS B BC WL GN\n//                  RT=real-time; TS=time-share; B=batch; BC=batch-critical\n//                  WL=weightless; GN=gang-scheduled\n//                  see miser(1) for this; PRI has some letter codes too\nstatic int pr_class(char *restrict const outbuf, const proc_t *restrict const pp){\n  switch(pp->sched){\n  case -1: return snprintf(outbuf, COLWID, \"-\");   // not reported\n  case  0: return snprintf(outbuf, COLWID, \"TS\");  // SCHED_OTHER SCHED_NORMAL\n  case  1: return snprintf(outbuf, COLWID, \"FF\");  // SCHED_FIFO\n  case  2: return snprintf(outbuf, COLWID, \"RR\");  // SCHED_RR\n  case  3: return snprintf(outbuf, COLWID, \"B\");   // SCHED_BATCH\n  case  4: return snprintf(outbuf, COLWID, \"ISO\"); // reserved for SCHED_ISO (Con Kolivas)\n  case  5: return snprintf(outbuf, COLWID, \"IDL\"); // SCHED_IDLE\n  case  6: return snprintf(outbuf, COLWID, \"DLN\"); // SCHED_DEADLINE\n  case  7: return snprintf(outbuf, COLWID, \"#7\");  //\n  case  8: return snprintf(outbuf, COLWID, \"#8\");  //\n  case  9: return snprintf(outbuf, COLWID, \"#9\");  //\n  default: return snprintf(outbuf, COLWID, \"?\");   // unknown value\n  }\n}\n// Based on \"type\", FreeBSD would do:\n//    REALTIME  \"real:%u\", prio\n//    NORMAL    \"normal\"\n//    IDLE      \"idle:%u\", prio\n//    default   \"%u:%u\", type, prio\n// We just print the priority, and have other keywords for type.\nstatic int pr_rtprio(char *restrict const outbuf, const proc_t *restrict const pp){\n  if(pp->sched==0 || pp->sched==(unsigned long)-1) return snprintf(outbuf, COLWID, \"-\");\n  return snprintf(outbuf, COLWID, \"%ld\", pp->rtprio);\n}\nstatic int pr_sched(char *restrict const outbuf, const proc_t *restrict const pp){\n  if(pp->sched==(unsigned long)-1) return snprintf(outbuf, COLWID, \"-\");\n  return snprintf(outbuf, COLWID, \"%ld\", pp->sched);\n}\n\n////////////////////////////////////////////////////////////////////////////////\n\nstatic int pr_wchan(char *restrict const outbuf, const proc_t *restrict const pp){\n/*\n * Unix98 says \"blank if running\" and also \"no blanks\"! :-(\n * Unix98 also says to use '-' if something is meaningless.\n * Digital uses both '*' and '-', with undocumented differences.\n * (the '*' for -1 (rare) and the '-' for 0)\n * Sun claims to use a blank AND use '-', in the same man page.\n * Perhaps \"blank\" should mean '-'.\n *\n * AIX uses '-' for running processes, the location when there is\n * only one thread waiting in the kernel, and '*' when there is\n * more than one thread waiting in the kernel.\n *\n * The output should be truncated to maximal columns width -- overflow\n * is not supported for the \"wchan\".\n */\n  const char *w;\n  size_t len;\n  if(!(pp->wchan & 0xffffff)) return memcpy(outbuf,\"-\",2),1;\n  if(wchan_is_number) return snprintf(outbuf, COLWID, \"%x\", (unsigned)(pp->wchan) & 0xffffffu);\n  w = lookup_wchan(pp->XXXID);\n  len = strlen(w);\n  if(len>max_rightward) len=max_rightward;\n  memcpy(outbuf, w, len);\n  outbuf[len] = '\\0';\n  return len;\n}\n\nstatic int pr_wname(char *restrict const outbuf, const proc_t *restrict const pp){\n/* SGI's IRIX always uses a number for \"wchan\", so \"wname\" is provided too.\n *\n * We use '-' for running processes, the location when there is\n * only one thread waiting in the kernel, and '*' when there is\n * more than one thread waiting in the kernel.\n *\n * The output should be truncated to maximal columns width -- overflow\n * is not supported for the \"wchan\".\n */\n  const char *w;\n  size_t len;\n  if(!(pp->wchan & 0xffffff)) return memcpy(outbuf,\"-\",2),1;\n  w = lookup_wchan(pp->XXXID);\n  len = strlen(w);\n  if(len>max_rightward) len=max_rightward;\n  memcpy(outbuf, w, len);\n  outbuf[len] = '\\0';\n  return len;\n}\n\nstatic int pr_nwchan(char *restrict const outbuf, const proc_t *restrict const pp){\n  if(!(pp->wchan & 0xffffff)) return memcpy(outbuf,\"-\",2),1;\n  return snprintf(outbuf, COLWID, \"%x\", (unsigned)(pp->wchan) & 0xffffffu);\n}\n\n/* Terrible trunctuation, like BSD crap uses: I999 J999 K999 */\n/* FIXME: disambiguate /dev/tty69 and /dev/pts/69. */\nstatic int pr_tty4(char *restrict const outbuf, const proc_t *restrict const pp){\n/* snprintf(outbuf, COLWID, \"%02x:%02x\", pp->tty>>8, pp->tty&0xff); */\n  return dev_to_tty(outbuf, 4, pp->tty, pp->XXXID, ABBREV_DEV|ABBREV_TTY|ABBREV_PTS);\n}\n\n/* Unix98: format is unspecified, but must match that used by who(1). */\nstatic int pr_tty8(char *restrict const outbuf, const proc_t *restrict const pp){\n/* snprintf(outbuf, COLWID, \"%02x:%02x\", pp->tty>>8, pp->tty&0xff); */\n  return dev_to_tty(outbuf, COLWID, pp->tty, pp->XXXID, ABBREV_DEV);\n}\n\n#if 0\n/* This BSD state display may contain spaces, which is illegal. */\nstatic int pr_oldstate(char *restrict const outbuf, const proc_t *restrict const pp){\n    return snprintf(outbuf, COLWID, \"%s\", status(pp));\n}\n#endif\n\n// This state display is Unix98 compliant and has lots of info like BSD.\nstatic int pr_stat(char *restrict const outbuf, const proc_t *restrict const pp){\n    int end = 0;\n    outbuf[end++] = pp->state;\n//  if(pp->rss==0 && pp->state!='Z')  outbuf[end++] = 'W'; // useless \"swapped out\"\n    if(pp->nice < 0)                  outbuf[end++] = '<';\n    if(pp->nice > 0)                  outbuf[end++] = 'N';\n// In this order, NetBSD would add:\n//     traced   'X'\n//     systrace 'x'\n//     exiting  'E' (not printed for zombies)\n//     vforked  'V'\n//     system   'K' (and do not print 'L' too)\n    if(pp->vm_lock)                   outbuf[end++] = 'L';\n    if(pp->session == pp->tgid)       outbuf[end++] = 's'; // session leader\n    if(pp->nlwp > 1)                  outbuf[end++] = 'l'; // multi-threaded\n    if(pp->pgrp == pp->tpgid)         outbuf[end++] = '+'; // in foreground process group\n    outbuf[end] = '\\0';\n    return end;\n}\n\n/* This minimal state display is Unix98 compliant, like SCO and SunOS 5 */\nstatic int pr_s(char *restrict const outbuf, const proc_t *restrict const pp){\n    outbuf[0] = pp->state;\n    outbuf[1] = '\\0';\n    return 1;\n}\n\nstatic int pr_flag(char *restrict const outbuf, const proc_t *restrict const pp){\n    /* Unix98 requires octal flags */\n    /* this user-hostile and volatile junk gets 1 character */\n    return snprintf(outbuf, COLWID, \"%o\", (unsigned)(pp->flags>>6U)&0x7U);\n}\n\n// plus these: euid,ruid,egroup,rgroup (elsewhere in this file)\n\n/*********** non-standard ***********/\n\n/*** BSD\nsess\tsession pointer\n(SCO has:Process session leader ID as a decimal value. (SESSION))\njobc\tjob control count\ncpu\tshort-term cpu usage factor (for scheduling)\nsl\tsleep time (in seconds; 127 = infinity)\nre\tcore residency time (in seconds; 127 = infinity)\npagein\tpageins (same as majflt)\nlim\tsoft memory limit\ntsiz\ttext size (in Kbytes)\n***/\n\nstatic int pr_stackp(char *restrict const outbuf, const proc_t *restrict const pp){\n    return snprintf(outbuf, COLWID, \"%0*lx\", (int)(2*sizeof(long)), pp->start_stack);\n}\n\nstatic int pr_esp(char *restrict const outbuf, const proc_t *restrict const pp){\n    return snprintf(outbuf, COLWID, \"%0*lx\", (int)(2*sizeof(long)), pp->kstk_esp);\n}\n\nstatic int pr_eip(char *restrict const outbuf, const proc_t *restrict const pp){\n    return snprintf(outbuf, COLWID, \"%0*lx\", (int)(2*sizeof(long)), pp->kstk_eip);\n}\n\n/* This function helps print old-style time formats */\nstatic int old_time_helper(char *dst, unsigned long long t, unsigned long long rel) {\n  if(!t)            return snprintf(dst, COLWID, \"    -\");\n  if(t == ~0ULL)    return snprintf(dst, COLWID, \"   xx\");\n  if((long long)(t-=rel) < 0)  t=0ULL;\n  if(t>9999ULL)     return snprintf(dst, COLWID, \"%5llu\", t/100ULL);\n  else              return snprintf(dst, COLWID, \"%2u.%02u\", (unsigned)t/100U, (unsigned)t%100U);\n}\n\nstatic int pr_bsdtime(char *restrict const outbuf, const proc_t *restrict const pp){\n    unsigned long long t;\n    unsigned u;\n    t = pp->utime + pp->stime;\n    if(include_dead_children) t += (pp->cutime + pp->cstime);\n    u = t / Hertz;\n    return snprintf(outbuf, COLWID, \"%3u:%02u\", u/60U, u%60U);\n}\n\nstatic int pr_bsdstart(char *restrict const outbuf, const proc_t *restrict const pp){\n  time_t start;\n  time_t seconds_ago;\n  start = getbtime() + pp->start_time / Hertz;\n  seconds_ago = seconds_since_1970 - start;\n  if(seconds_ago < 0) seconds_ago=0;\n  if(seconds_ago > 3600*24)  snprintf(outbuf, COLWID, \"%s\", ctime(&start)+4);\n  else                       snprintf(outbuf, COLWID, \"%s\", ctime(&start)+10);\n  outbuf[6] = '\\0';\n  return 6;\n}\n\nstatic int pr_alarm(char *restrict const outbuf, const proc_t *restrict const pp){\n    return old_time_helper(outbuf, pp->alarm, 0ULL);\n}\n\n/* HP-UX puts this in pages and uses \"vsz\" for kB */\nstatic int pr_sz(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%lu\", (pp->vm_size)/(page_size/1024));\n}\n\n\n/*\n * FIXME: trs,drs,tsiz,dsiz,m_trs,m_drs,vm_exe,vm_data,trss\n * I suspect some/all of those are broken. They seem to have been\n * inherited by Linux and AIX from early BSD systems. FreeBSD only\n * retains tsiz. The prefixed versions come from Debian.\n * Sun and Digital have none of this crap. The code here comes\n * from an old Linux ps, and might not be correct for ELF executables.\n *\n * AIX            TRS    size of resident-set (real memory) of text\n * AIX            TSIZ   size of text (shared-program) image\n * FreeBSD        tsiz   text size (in Kbytes)\n * 4.3BSD NET/2   trss   text resident set size (in Kbytes)\n * 4.3BSD NET/2   tsiz   text size (in Kbytes)\n */\n\n/* kB data size. See drs, tsiz & trs. */\nstatic int pr_dsiz(char *restrict const outbuf, const proc_t *restrict const pp){\n    long dsiz = 0;\n    if(pp->vsize) dsiz += (pp->vsize - pp->end_code + pp->start_code) >> 10;\n    return snprintf(outbuf, COLWID, \"%ld\", dsiz);\n}\n\n/* kB text (code) size. See trs, dsiz & drs. */\nstatic int pr_tsiz(char *restrict const outbuf, const proc_t *restrict const pp){\n    long tsiz = 0;\n    if(pp->vsize) tsiz += (pp->end_code - pp->start_code) >> 10;\n    return snprintf(outbuf, COLWID, \"%ld\", tsiz);\n}\n\n/* kB _resident_ data size. See dsiz, tsiz & trs. */\nstatic int pr_drs(char *restrict const outbuf, const proc_t *restrict const pp){\n    long drs = 0;\n    if(pp->vsize) drs += (pp->vsize - pp->end_code + pp->start_code) >> 10;\n    return snprintf(outbuf, COLWID, \"%ld\", drs);\n}\n\n/* kB text _resident_ (code) size. See tsiz, dsiz & drs. */\nstatic int pr_trs(char *restrict const outbuf, const proc_t *restrict const pp){\n    long trs = 0;\n    if(pp->vsize) trs += (pp->end_code - pp->start_code) >> 10;\n    return snprintf(outbuf, COLWID, \"%ld\", trs);\n}\n\n/* approximation to: kB of address space that could end up in swap */\nstatic int pr_swapable(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%ld\", pp->vm_data + pp->vm_stack);\n}\n\n/* nasty old Debian thing */\nstatic int pr_size(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%ld\", pp->size);\n}\n\n\nstatic int pr_minflt(char *restrict const outbuf, const proc_t *restrict const pp){\n    long flt = pp->min_flt;\n    if(include_dead_children) flt += pp->cmin_flt;\n    return snprintf(outbuf, COLWID, \"%ld\", flt);\n}\n\nstatic int pr_majflt(char *restrict const outbuf, const proc_t *restrict const pp){\n    long flt = pp->maj_flt;\n    if(include_dead_children) flt += pp->cmaj_flt;\n    return snprintf(outbuf, COLWID, \"%ld\", flt);\n}\n\nstatic int pr_lim(char *restrict const outbuf, const proc_t *restrict const pp){\n    if(pp->rss_rlim == RLIM_INFINITY){\n      outbuf[0] = 'x';\n      outbuf[1] = 'x';\n      outbuf[2] = '\\0';\n      return 2;\n    }\n    return snprintf(outbuf, COLWID, \"%5ld\", pp->rss_rlim >> 10);\n}\n\n/* should print leading tilde ('~') if process is bound to the CPU */\nstatic int pr_psr(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%d\", pp->processor);\n}\n\nstatic int pr_numa(char *restrict const outbuf, const proc_t *restrict const pp){\n  static int first = 1;\n  if (first) { numa_init(); first = 0; }   // we'll keep this dependency local\n  return snprintf(outbuf, COLWID, \"%d\", numa_node_of_cpu(pp->processor));\n}\n\nstatic int pr_rss(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%lu\", pp->vm_rss);\n}\n\n/* pp->vm_rss * 1000 would overflow on 32-bit systems with 64 GB memory */\nstatic int pr_pmem(char *restrict const outbuf, const proc_t *restrict const pp){\n  unsigned long pmem = 0;\n  pmem = pp->vm_rss * 1000ULL / kb_main_total;\n  if (pmem > 999) pmem = 999;\n  return snprintf(outbuf, COLWID, \"%2u.%u\", (unsigned)(pmem/10), (unsigned)(pmem%10));\n}\n\nstatic int pr_lstart(char *restrict const outbuf, const proc_t *restrict const pp){\n  time_t t;\n  t = getbtime() + pp->start_time / Hertz;\n  return snprintf(outbuf, COLWID, \"%24.24s\", ctime(&t));\n}\n\n/* Unix98 specifies a STIME header for a column that shows the start\n * time of the process, but does not specify a format or format specifier.\n * From the general Unix98 rules, we know there must not be any spaces.\n * Most systems violate that rule, though the Solaris documentation\n * claims to print the column without spaces. (NOT!)\n *\n * So this isn't broken, but could be renamed to u98_std_stime,\n * as long as it still shows as STIME when using the -f option.\n */\nstatic int pr_stime(char *restrict const outbuf, const proc_t *restrict const pp){\n  struct tm *proc_time;\n  struct tm *our_time;\n  time_t t;\n  const char *fmt;\n  int tm_year;\n  int tm_yday;\n  size_t len;\n  our_time = localtime(&seconds_since_1970);   /* not reentrant */\n  tm_year = our_time->tm_year;\n  tm_yday = our_time->tm_yday;\n  t = getbtime() + pp->start_time / Hertz;\n  proc_time = localtime(&t); /* not reentrant, this corrupts our_time */\n  fmt = \"%H:%M\";                                   /* 03:02 23:59 */\n  if(tm_yday != proc_time->tm_yday) fmt = \"%b%d\";  /* Jun06 Aug27 */\n  if(tm_year != proc_time->tm_year) fmt = \"%Y\";    /* 1991 2001 */\n  len = strftime(outbuf, COLWID, fmt, proc_time);\n  if(len <= 0 || len >= COLWID) outbuf[len = 0] = '\\0';\n  return len;\n}\n\nstatic int pr_start(char *restrict const outbuf, const proc_t *restrict const pp){\n  time_t t;\n  char *str;\n  t = getbtime() + pp->start_time / Hertz;\n  str = ctime(&t);\n  if(str[8]==' ')  str[8]='0';\n  if(str[11]==' ') str[11]='0';\n  if((unsigned long)t+60*60*24 > (unsigned long)seconds_since_1970)\n    return snprintf(outbuf, COLWID, \"%8.8s\", str+11);\n  return snprintf(outbuf, COLWID, \"  %6.6s\", str+4);\n}\n\n\n#ifdef SIGNAL_STRING\nstatic int help_pr_sig(char *restrict const outbuf, const char *restrict const sig){\n  const size_t len = strlen(sig);\n  if(wide_signals){\n    if(len>8) return snprintf(outbuf, COLWID, \"%s\", sig);\n    return snprintf(outbuf, COLWID, \"00000000%s\", sig);\n  }\n  if(len-strspn(sig,\"0\") > 8)\n    return snprintf(outbuf, COLWID, \"<%s\", sig+len-8);\n  if(len < 8)\n    return snprintf(outbuf, COLWID, \"%s%s\", \"00000000\"+len, sig);\n  return snprintf(outbuf, COLWID,  \"%s\", sig+len-8);\n}\n#else\nstatic int help_pr_sig(unsigned long long sig){\n  if(wide_signals) return snprintf(outbuf, COLWID, \"%016Lx\", sig);\n  if(sig>>32)      return snprintf(outbuf, COLWID, \"<%08Lx\", sig&0xffffffffLL);\n  return                  snprintf(outbuf, COLWID,  \"%08Lx\", sig&0xffffffffLL);\n}\n#endif\n\n// This one is always thread-specific pending. (from Dragonfly BSD)\nstatic int pr_tsig(char *restrict const outbuf, const proc_t *restrict const pp){\n  return help_pr_sig(outbuf, pp->_sigpnd);\n}\n// This one is (wrongly?) thread-specific when printing thread lines,\n// but process-pending otherwise.\nstatic int pr_sig(char *restrict const outbuf, const proc_t *restrict const pp){\n  return help_pr_sig(outbuf, pp->signal);\n}\nstatic int pr_sigmask(char *restrict const outbuf, const proc_t *restrict const pp){\n  return help_pr_sig(outbuf, pp->blocked);\n}\nstatic int pr_sigignore(char *restrict const outbuf, const proc_t *restrict const pp){\n  return help_pr_sig(outbuf, pp->sigignore);\n}\nstatic int pr_sigcatch(char *restrict const outbuf, const proc_t *restrict const pp){\n  return help_pr_sig(outbuf, pp->sigcatch);\n}\n\n\n////////////////////////////////////////////////////////////////////////////////\n\n/*\n * internal terms:  ruid  euid  suid  fuid\n * kernel vars:      uid  euid  suid fsuid\n * command args:    ruid   uid svuid   n/a\n */\n\nstatic int pr_egid(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%d\", pp->egid);\n}\nstatic int pr_rgid(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%d\", pp->rgid);\n}\nstatic int pr_sgid(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%d\", pp->sgid);\n}\nstatic int pr_fgid(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%d\", pp->fgid);\n}\n\nstatic int pr_euid(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%d\", pp->euid);\n}\nstatic int pr_ruid(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%d\", pp->ruid);\n}\nstatic int pr_suid(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%d\", pp->suid);\n}\nstatic int pr_fuid(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%d\", pp->fuid);\n}\n\n// The Open Group Base Specifications Issue 6 (IEEE Std 1003.1, 2004 Edition)\n// requires that user and group names print as decimal numbers if there is\n// not enough room in the column.  However, we will now truncate such names\n// and provide a visual hint of such truncation.  Hopefully, this will reduce\n// the volume of bug reports regarding that former 'feature'.\n//\n// The UNIX and POSIX way to change column width is to rename it:\n//      ps -o pid,user=CumbersomeUserNames -o comm\n// The easy way is to directly specify the desired width:\n//      ps -o pid,user:19,comm\n//\nstatic int do_pr_name(char *restrict const outbuf, const char *restrict const name, unsigned u){\n  if(!user_is_number){\n    int rightward = OUTBUF_SIZE;\t/* max cells */\n    int len;\t\t\t\t/* real cells */\n\n    escape_str(outbuf, name, OUTBUF_SIZE, &rightward);\n    len = OUTBUF_SIZE-rightward;\n\n    if(len <= (int)max_rightward)\n      return len;  /* returns number of cells */\n\n    // only use '+' when not on a multi-byte char, else show uid\n    if (max_rightward >= 1 && (unsigned)outbuf[max_rightward-1] < 127) {\n      len = max_rightward-1;\n      outbuf[len++] = '+';\n      outbuf[len] = 0;\n      return len;\n    }\n  }\n  return snprintf(outbuf, COLWID, \"%u\", u);\n}\n\nstatic int pr_ruser(char *restrict const outbuf, const proc_t *restrict const pp){\n  return do_pr_name(outbuf, pp->ruser, pp->ruid);\n}\nstatic int pr_euser(char *restrict const outbuf, const proc_t *restrict const pp){\n  return do_pr_name(outbuf, pp->euser, pp->euid);\n}\nstatic int pr_fuser(char *restrict const outbuf, const proc_t *restrict const pp){\n  return do_pr_name(outbuf, pp->fuser, pp->fuid);\n}\nstatic int pr_suser(char *restrict const outbuf, const proc_t *restrict const pp){\n  return do_pr_name(outbuf, pp->suser, pp->suid);\n}\nstatic int pr_egroup(char *restrict const outbuf, const proc_t *restrict const pp){\n  return do_pr_name(outbuf, pp->egroup, pp->egid);\n}\nstatic int pr_rgroup(char *restrict const outbuf, const proc_t *restrict const pp){\n  return do_pr_name(outbuf, pp->rgroup, pp->rgid);\n}\nstatic int pr_fgroup(char *restrict const outbuf, const proc_t *restrict const pp){\n  return do_pr_name(outbuf, pp->fgroup, pp->fgid);\n}\nstatic int pr_sgroup(char *restrict const outbuf, const proc_t *restrict const pp){\n  return do_pr_name(outbuf, pp->sgroup, pp->sgid);\n}\n\n//////////////////////////////////////////////////////////////////////////////////\n\n// PID pid, TGID tgid\nstatic int pr_procs(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%u\", pp->tgid);\n}\n// LWP lwp, SPID spid, TID tid\nstatic int pr_tasks(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%u\", pp->tid);\n}\n// thcount THCNT\nstatic int pr_nlwp(char *restrict const outbuf, const proc_t *restrict const pp){\n    return snprintf(outbuf, COLWID, \"%d\", pp->nlwp);\n}\n\nstatic int pr_sess(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%u\", pp->session);\n}\n\nstatic int pr_supgid(char *restrict const outbuf, const proc_t *restrict const pp){\n  int rightward = max_rightward;\n  escaped_copy(outbuf, pp->supgid, OUTBUF_SIZE, &rightward);\n  return max_rightward-rightward;\n}\n\nstatic int pr_supgrp(char *restrict const outbuf, const proc_t *restrict const pp){\n  int rightward = max_rightward;\n  escape_str(outbuf, pp->supgrp, OUTBUF_SIZE, &rightward);\n  return max_rightward-rightward;\n}\n\nstatic int pr_tpgid(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%d\", pp->tpgid);\n}\n\n/* SGI uses \"cpu\" to print the processor ID with header \"P\" */\nstatic int pr_sgi_p(char *restrict const outbuf, const proc_t *restrict const pp){          /* FIXME */\n  if(pp->state == 'R') return snprintf(outbuf, COLWID, \"%d\", pp->processor);\n  return snprintf(outbuf, COLWID, \"*\");\n}\n\n/* LoginID implementation */\nstatic int pr_luid(char *restrict const outbuf, const proc_t *restrict const pp){\n    char filename[48];\n    ssize_t num_read;\n    int fd;\n    u_int32_t luid;\n\n    snprintf(filename, sizeof filename, \"/proc/%d/loginuid\", pp->tgid);\n\n    if ((fd = open(filename, O_RDONLY, 0)) != -1) {\n        num_read = read(fd, outbuf, OUTBUF_SIZE - 1);\n        close(fd);\n        if (num_read > 0) {\n            outbuf[num_read] = '\\0';\n\n            // processes born before audit have no LoginID set\n            luid = (u_int32_t) atoi(outbuf);\n            if (luid != -1)\n                return num_read;\n        }\n    }\n    outbuf[0] = '-';\n    outbuf[1] = '\\0';\n    num_read = 1;\n    return num_read;\n}\n\n\n/* full path to executable */\nstatic int pr_exe(char *restrict const outbuf, const proc_t *restrict const pp){\n    char filename[48];\n    ssize_t num_read;\n\n    snprintf(filename, sizeof filename, \"/proc/%d/exe\", pp->tgid);\n\n    num_read = readlink(filename, outbuf, OUTBUF_SIZE-1);\n    if (num_read > 0) {\n        outbuf[num_read] = '\\0';\n    }\n    else {\n        outbuf[0] = '-';\n        outbuf[1] = '\\0';\n        num_read = 1;\n    }\n\n    return num_read;\n}\n\n/************************* Systemd stuff ********************************/\nstatic int pr_sd_unit(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%s\", pp->sd_unit);\n}\n\nstatic int pr_sd_session(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%s\", pp->sd_sess);\n}\n\nstatic int pr_sd_ouid(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%s\", pp->sd_ouid);\n}\n\nstatic int pr_sd_machine(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%s\", pp->sd_mach);\n}\n\nstatic int pr_sd_uunit(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%s\", pp->sd_uunit);\n}\n\nstatic int pr_sd_seat(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%s\", pp->sd_seat);\n}\n\nstatic int pr_sd_slice(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%s\", pp->sd_slice);\n}\n/************************ Linux namespaces ******************************/\n\n#define _pr_ns(NAME, ID)\\\nstatic int pr_##NAME(char *restrict const outbuf, const proc_t *restrict const pp) {\\\n  if (pp->ns[ID])\\\n    return snprintf(outbuf, COLWID, \"%lu\", (unsigned long)pp->ns[ID]);\\\n  else\\\n    return snprintf(outbuf, COLWID, \"-\");\\\n}\n_pr_ns(ipcns, IPCNS);\n_pr_ns(mntns, MNTNS);\n_pr_ns(netns, NETNS);\n_pr_ns(pidns, PIDNS);\n_pr_ns(userns, USERNS);\n_pr_ns(utsns, UTSNS);\n\n/************************ Linux containers ******************************/\nstatic int pr_lxcname(char *restrict const outbuf, const proc_t *restrict const pp){\n  return snprintf(outbuf, COLWID, \"%s\", pp->lxcname);\n}\n\n/****************** FLASK & seLinux security stuff **********************/\n// move the bulk of this to libproc sometime\n\n// This needs more study, considering:\n// 1. the static linking option (maybe disable this in that case)\n// 2. the -z and -Z option issue\n// 3. width of output\nstatic int pr_context(char *restrict const outbuf, const proc_t *restrict const pp){\n  static void (*ps_freecon)(char*) = 0;\n  static int (*ps_getpidcon)(pid_t pid, char **context) = 0;\n  static int selinux_enabled = 0;\n  size_t len;\n  char *context;\n\n#if ENABLE_LIBSELINUX\n  static int (*ps_is_selinux_enabled)(void) = 0;\n  static int tried_load = 0;\n\n  if(!ps_getpidcon && !tried_load){\n    void *handle = dlopen(\"libselinux.so.1\", RTLD_NOW);\n    if(handle){\n      ps_freecon = dlsym(handle, \"freecon\");\n      if(dlerror())\n        ps_freecon = 0;\n      dlerror();\n      ps_getpidcon = dlsym(handle, \"getpidcon\");\n      if(dlerror())\n        ps_getpidcon = 0;\n      ps_is_selinux_enabled = dlsym(handle, \"is_selinux_enabled\");\n      if(dlerror())\n        ps_is_selinux_enabled = 0;\n      else\n        selinux_enabled = ps_is_selinux_enabled();\n    }\n    tried_load++;\n  }\n#endif\n  if(ps_getpidcon && selinux_enabled && !ps_getpidcon(pp->tgid, &context)){\n    size_t max_len = OUTBUF_SIZE-1;\n    len = strlen(context);\n    if(len > max_len) len = max_len;\n    memcpy(outbuf, context, len);\n    if (len >= 1 && outbuf[len-1] == '\\n') --len;\n    outbuf[len] = '\\0';\n    ps_freecon(context);\n  }else{\n    char filename[48];\n    ssize_t num_read;\n    int fd;\n\n// wchan file is suitable for testing\n//snprintf(filename, sizeof filename, \"/proc/%d/wchan\", pp->tgid);\n    snprintf(filename, sizeof filename, \"/proc/%d/attr/current\", pp->tgid);\n\n    if ((fd = open(filename, O_RDONLY, 0)) != -1) {\n      num_read = read(fd, outbuf, OUTBUF_SIZE-1);\n      close(fd);\n      if (num_read > 0) {\n        outbuf[num_read] = '\\0';\n        len = 0;\n        while(isprint(outbuf[len]))\n          len++;\n        outbuf[len] = '\\0';\n        if(len)\n          return len;\n      }\n    }\n    outbuf[0] = '-';\n    outbuf[1] = '\\0';\n    len = 1;\n  }\n  return len;\n}\n\n////////////////////////////// Test code /////////////////////////////////\n\n// like \"args\"\nstatic int pr_t_unlimited(char *restrict const outbuf, const proc_t *restrict const pp){\n  static const char *const vals[] = {\"[123456789-12345] <defunct>\",\"ps\",\"123456789-123456\"};\n  (void)pp;\n  snprintf(outbuf, max_rightward+1, \"%s\", vals[lines_to_next_header%3u]);\n  return strlen(outbuf);\n}\nstatic int pr_t_unlimited2(char *restrict const outbuf, const proc_t *restrict const pp){\n  static const char *const vals[] = {\"unlimited\", \"[123456789-12345] <defunct>\",\"ps\",\"123456789-123456\"};\n  (void)pp;\n  snprintf(outbuf, max_rightward+1, \"%s\", vals[lines_to_next_header%4u]);\n  return strlen(outbuf);\n}\n\n// like \"etime\"\nstatic int pr_t_right(char *restrict const outbuf, const proc_t *restrict const pp){\n  static const char *const vals[] = {\"999-23:59:59\",\"99-23:59:59\",\"9-23:59:59\",\"59:59\"};\n  (void)pp;\n  return snprintf(outbuf, COLWID, \"%s\", vals[lines_to_next_header%4u]);\n}\nstatic int pr_t_right2(char *restrict const outbuf, const proc_t *restrict const pp){\n  static const char *const vals[] = {\"999-23:59:59\",\"99-23:59:59\",\"9-23:59:59\"};\n  (void)pp;\n  return snprintf(outbuf, COLWID, \"%s\", vals[lines_to_next_header%3u]);\n}\n\n// like \"tty\"\nstatic int pr_t_left(char *restrict const outbuf, const proc_t *restrict const pp){\n  static const char *const vals[] = {\"tty7\",\"pts/9999\",\"iseries/vtty42\",\"ttySMX0\",\"3270/tty4\"};\n  (void)pp;\n  return snprintf(outbuf, COLWID, \"%s\", vals[lines_to_next_header%5u]);\n}\nstatic int pr_t_left2(char *restrict const outbuf, const proc_t *restrict const pp){\n  static const char *const vals[] = {\"tty7\",\"pts/9999\",\"ttySMX0\",\"3270/tty4\"};\n  (void)pp;\n  return snprintf(outbuf, COLWID, \"%s\", vals[lines_to_next_header%4u]);\n}\n\n/***************************************************************************/\n/*************************** other stuff ***********************************/\n\n/*\n * Old header specifications.\n *\n * short   Up  \"  PID TTY STAT  TIME COMMAND\"\n * long  l Pp  \" FLAGS   UID   PID  PPID PRI  NI   SIZE   RSS WCHAN       STA TTY TIME COMMAND\n * user  u up  \"USER       PID %CPU %MEM  SIZE   RSS TTY STAT START   TIME COMMAND\n * jobs  j gPp \" PPID   PID  PGID   SID TTY TPGID  STAT   UID   TIME COMMAND\n * sig   s p   \"  UID   PID SIGNAL   BLOCKED  IGNORED  CATCHED  STAT TTY   TIME COMMAND\n * vm    v r   \"  PID TTY STAT  TIME  PAGEIN TSIZ DSIZ  RSS   LIM %MEM COMMAND\n * m     m r   \"  PID TTY MAJFLT MINFLT   TRS   DRS  SIZE  SWAP   RSS  SHRD   LIB  DT COMMAND\n * regs  X p   \"NR   PID    STACK      ESP      EIP TMOUT ALARM STAT TTY   TIME COMMAND\n */\n\n/*\n * Unix98 requires that the heading for tty is TT, though XPG4, Digital,\n * and BSD use TTY. The Unix98 headers are:\n *              args,comm,etime,group,nice,pcpu,pgid\n *              pid,ppid,rgroup,ruser,time,tty,user,vsz\n *\n * BSD c:   \"command\" becomes accounting name (\"comm\" or \"ucomm\")\n * BSD n:   \"user\" becomes \"uid\" and \"wchan\" becomes \"nwchan\" (number)\n */\n\n/* Justification control for flags field. */\n#define USER      CF_USER   // left if text, right if numeric\n#define LEFT      CF_LEFT\n#define RIGHT     CF_RIGHT\n#define UNLIMITED CF_UNLIMITED\n#define WCHAN     CF_WCHAN  // left if text, right if numeric\n#define SIGNAL    CF_SIGNAL // right in 9, or 16 if room\n#define PIDMAX    CF_PIDMAX\n#define TO        CF_PRINT_THREAD_ONLY\n#define PO        CF_PRINT_PROCESS_ONLY\n#define ET        CF_PRINT_EVERY_TIME\n#define AN        CF_PRINT_AS_NEEDED // no idea\n\n/* short names to save space */\n#define MEM PROC_FILLMEM     /* read statm  */\n#define ARG PROC_FILLARG     /* read cmdline (cleared if c option) */\n#define COM PROC_FILLCOM     /* read cmdline (cleared if not -f option) */\n#define ENV PROC_FILLENV     /* read environ */\n#define USR PROC_FILLUSR     /* uid_t -> user names */\n#define GRP PROC_FILLGRP     /* gid_t -> group names */\n#define NS  PROC_FILLNS      /* read namespace information */\n#define LXC PROC_FILL_LXC    /* value the lxc name field */\n#define SD  PROC_FILLSYSTEMD /* retrieve systemd stuff */\n#define SGRP PROC_FILLSTATUS | PROC_FILLSUPGRP  /* supgid -> supgrp (names) */\n#define CGRP PROC_FILLCGROUP | PROC_EDITCGRPCVT /* read cgroup */\n\n/* TODO\n *      pull out annoying BSD aliases into another table (to macro table?)\n *      add sorting functions here (to unify names)\n */\n\n/* temporary hack -- mark new stuff grabbed from Debian ps */\n#define LNx LNX\n\n/* there are about 211 listed */\n\n/* Many of these are placeholders for unsupported options. */\nstatic const format_struct format_array[] = {\n/* code       header     print()      sort()    width need vendor flags  */\n{\"%cpu\",      \"%CPU\",    pr_pcpu,     sr_pcpu,    4,   0,    BSD, ET|RIGHT}, /*pcpu*/\n{\"%mem\",      \"%MEM\",    pr_pmem,     sr_rss,     4,   0,    BSD, PO|RIGHT}, /*pmem*/\n{\"_left\",     \"LLLLLLLL\", pr_t_left,  NULL,       8,   0,    TST, ET|LEFT},\n{\"_left2\",    \"L2L2L2L2\", pr_t_left2, NULL,       8,   0,    TST, ET|LEFT},\n{\"_right\",    \"RRRRRRRRRRR\", pr_t_right, NULL,   11,   0,    TST, ET|RIGHT},\n{\"_right2\",   \"R2R2R2R2R2R\", pr_t_right2, NULL,   11,  0,    TST, ET|RIGHT},\n{\"_unlimited\",\"U\",   pr_t_unlimited,  NULL,      16,   0,    TST, ET|UNLIMITED},\n{\"_unlimited2\",\"U2\", pr_t_unlimited2, NULL,      16,   0,    TST, ET|UNLIMITED},\n{\"acflag\",    \"ACFLG\",   pr_nop,      sr_nop,     5,   0,    XXX, AN|RIGHT}, /*acflg*/\n{\"acflg\",     \"ACFLG\",   pr_nop,      sr_nop,     5,   0,    BSD, AN|RIGHT}, /*acflag*/\n{\"addr\",      \"ADDR\",    pr_nop,      sr_nop,     4,   0,    XXX, AN|RIGHT},\n{\"addr_1\",    \"ADDR\",    pr_nop,      sr_nop,     1,   0,    LNX, AN|LEFT},\n{\"alarm\",     \"ALARM\",   pr_alarm,    sr_alarm,   5,   0,    LNX, AN|RIGHT},\n{\"argc\",      \"ARGC\",    pr_nop,      sr_nop,     4,   0,    LNX, PO|RIGHT},\n{\"args\",      \"COMMAND\", pr_args,     sr_cmd,    27, ARG,    U98, PO|UNLIMITED}, /*command*/\n{\"atime\",     \"TIME\",    pr_time,     sr_time,    8,   0,    SOE, ET|RIGHT}, /*cputime*/ /* was 6 wide */\n{\"blocked\",   \"BLOCKED\", pr_sigmask,  NULL,       9,   0,    BSD, TO|SIGNAL}, /*sigmask*/\n{\"bnd\",       \"BND\",     pr_nop,      sr_nop,     1,   0,    AIX, TO|RIGHT},\n{\"bsdstart\",  \"START\",   pr_bsdstart, NULL,       6,   0,    LNX, ET|RIGHT},\n{\"bsdtime\",   \"TIME\",    pr_bsdtime,  NULL,       6,   0,    LNX, ET|RIGHT},\n{\"c\",         \"C\",       pr_c,        sr_pcpu,    2,   0,    SUN, ET|RIGHT},\n{\"caught\",    \"CAUGHT\",  pr_sigcatch, NULL,       9,   0,    BSD, TO|SIGNAL}, /*sigcatch*/\n{\"cgname\",    \"CGNAME\",  pr_cgname,   sr_cgname, 27,CGRP,    LNX, PO|UNLIMITED},\n{\"cgroup\",    \"CGROUP\",  pr_cgroup,   sr_cgroup, 27,CGRP,    LNX, PO|UNLIMITED},\n{\"class\",     \"CLS\",     pr_class,    sr_sched,   3,   0,    XXX, TO|LEFT},\n{\"cls\",       \"CLS\",     pr_class,    sr_sched,   3,   0,    HPU, TO|RIGHT}, /*says HPUX or RT*/\n{\"cmaj_flt\",  \"-\",       pr_nop,      sr_cmaj_flt, 1,  0,    LNX, AN|RIGHT},\n{\"cmd\",       \"CMD\",     pr_args,     sr_cmd,    27, ARG,    DEC, PO|UNLIMITED}, /*ucomm*/\n{\"cmin_flt\",  \"-\",       pr_nop,      sr_cmin_flt, 1,  0,    LNX, AN|RIGHT},\n{\"cnswap\",    \"-\",       pr_nop,      sr_nop,     1,   0,    LNX, AN|RIGHT},\n{\"comm\",      \"COMMAND\", pr_comm,     sr_cmd,    15, COM,    U98, PO|UNLIMITED}, /*ucomm*/\n{\"command\",   \"COMMAND\", pr_args,     sr_cmd,    27, ARG,    XXX, PO|UNLIMITED}, /*args*/\n{\"context\",   \"CONTEXT\", pr_context,  NULL,      31,   0,    LNX, ET|LEFT},\n{\"cp\",        \"CP\",      pr_cp,       sr_pcpu,    3,   0,    DEC, ET|RIGHT}, /*cpu*/\n{\"cpu\",       \"CPU\",     pr_nop,      sr_nop,     3,   0,    BSD, AN|RIGHT}, /* FIXME ... HP-UX wants this as the CPU number for SMP? */\n{\"cpuid\",     \"CPUID\",   pr_psr,      NULL,       5,   0,    BSD, TO|RIGHT}, // OpenBSD: 8 wide!\n{\"cputime\",   \"TIME\",    pr_time,     sr_time,    8,   0,    DEC, ET|RIGHT}, /*time*/\n{\"cputimes\",  \"TIME\",    pr_times,    sr_time,    8,   0,    LNX, ET|RIGHT}, /*time*/\n{\"ctid\",      \"CTID\",    pr_nop,      sr_nop,     5,   0,    SUN, ET|RIGHT}, // resource contracts?\n{\"cursig\",    \"CURSIG\",  pr_nop,      sr_nop,     6,   0,    DEC, AN|RIGHT},\n{\"cutime\",    \"-\",       pr_nop,      sr_cutime,  1,   0,    LNX, AN|RIGHT},\n{\"cwd\",       \"CWD\",     pr_nop,      sr_nop,     3,   0,    LNX, AN|LEFT},\n{\"drs\",       \"DRS\",     pr_drs,      sr_drs,     5, MEM,    LNX, PO|RIGHT},\n{\"dsiz\",      \"DSIZ\",    pr_dsiz,     NULL,       4,   0,    LNX, PO|RIGHT},\n{\"egid\",      \"EGID\",    pr_egid,     sr_egid,    5,   0,    LNX, ET|RIGHT},\n{\"egroup\",    \"EGROUP\",  pr_egroup,   sr_egroup,  8, GRP,    LNX, ET|USER},\n{\"eip\",       \"EIP\",     pr_eip,      sr_kstk_eip, (int)(2*sizeof(long)), 0, LNX, TO|RIGHT},\n{\"emul\",      \"EMUL\",    pr_nop,      sr_nop,    13,   0,    BSD, PO|LEFT}, /* \"FreeBSD ELF32\" and such */\n{\"end_code\",  \"E_CODE\",  pr_nop,      sr_end_code, (int)(2*sizeof(long)), 0, LNx, PO|RIGHT},\n{\"environ\",\"ENVIRONMENT\",pr_nop,      sr_nop,    11, ENV,    LNx, PO|UNLIMITED},\n{\"esp\",       \"ESP\",     pr_esp,      sr_kstk_esp, (int)(2*sizeof(long)), 0, LNX, TO|RIGHT},\n{\"etime\",     \"ELAPSED\", pr_etime,    sr_etime,  11,   0,    U98, ET|RIGHT}, /* was 7 wide */\n{\"etimes\",    \"ELAPSED\", pr_etimes,   sr_etime,   7,   0,    BSD, ET|RIGHT}, /* FreeBSD */\n{\"euid\",      \"EUID\",    pr_euid,     sr_euid,    5,   0,    LNX, ET|RIGHT},\n{\"euser\",     \"EUSER\",   pr_euser,    sr_euser,   8, USR,    LNX, ET|USER},\n{\"exe\",       \"EXE\",     pr_exe,      sr_nop,    27,   0,    LNX, PO|UNLIMITED},\n{\"f\",         \"F\",       pr_flag,     sr_flags,   1,   0,    XXX, ET|RIGHT}, /*flags*/\n{\"fgid\",      \"FGID\",    pr_fgid,     sr_fgid,    5,   0,    LNX, ET|RIGHT},\n{\"fgroup\",    \"FGROUP\",  pr_fgroup,   sr_fgroup,  8, GRP,    LNX, ET|USER},\n{\"flag\",      \"F\",       pr_flag,     sr_flags,   1,   0,    DEC, ET|RIGHT},\n{\"flags\",     \"F\",       pr_flag,     sr_flags,   1,   0,    BSD, ET|RIGHT}, /*f*/ /* was FLAGS, 8 wide */\n{\"fname\",     \"COMMAND\", pr_fname,    NULL,       8,   0,    SUN, PO|LEFT},\n{\"fsgid\",     \"FSGID\",   pr_fgid,     sr_fgid,    5,   0,    LNX, ET|RIGHT},\n{\"fsgroup\",   \"FSGROUP\", pr_fgroup,   sr_fgroup,  8, GRP,    LNX, ET|USER},\n{\"fsuid\",     \"FSUID\",   pr_fuid,     sr_fuid,    5,   0,    LNX, ET|RIGHT},\n{\"fsuser\",    \"FSUSER\",  pr_fuser,    sr_fuser,   8, USR,    LNX, ET|USER},\n{\"fuid\",      \"FUID\",    pr_fuid,     sr_fuid,    5,   0,    LNX, ET|RIGHT},\n{\"fuser\",     \"FUSER\",   pr_fuser,    sr_fuser,   8, USR,    LNX, ET|USER},\n{\"gid\",       \"GID\",     pr_egid,     sr_egid,    5,   0,    SUN, ET|RIGHT},\n{\"group\",     \"GROUP\",   pr_egroup,   sr_egroup,  8, GRP,    U98, ET|USER},\n{\"ignored\",   \"IGNORED\", pr_sigignore,NULL,       9,   0,    BSD, TO|SIGNAL}, /*sigignore*/\n{\"inblk\",     \"INBLK\",   pr_nop,      sr_nop,     5,   0,    BSD, AN|RIGHT}, /*inblock*/\n{\"inblock\",   \"INBLK\",   pr_nop,      sr_nop,     5,   0,    DEC, AN|RIGHT}, /*inblk*/\n{\"intpri\",    \"PRI\",     pr_opri,     sr_priority, 3,  0,    HPU, TO|RIGHT},\n{\"ipcns\",     \"IPCNS\",   pr_ipcns,    sr_ipcns,  10,  NS,    LNX, ET|RIGHT},\n{\"jid\",       \"JID\",     pr_nop,      sr_nop,     1,   0,    SGI, PO|RIGHT},\n{\"jobc\",      \"JOBC\",    pr_nop,      sr_nop,     4,   0,    XXX, AN|RIGHT},\n{\"ktrace\",    \"KTRACE\",  pr_nop,      sr_nop,     8,   0,    BSD, AN|RIGHT},\n{\"ktracep\",   \"KTRACEP\", pr_nop,      sr_nop,     8,   0,    BSD, AN|RIGHT},\n{\"label\",     \"LABEL\",   pr_context,  NULL,      31,   0,    SGI, ET|LEFT},\n{\"lastcpu\",   \"C\",       pr_psr,      NULL,       3,   0,    BSD, TO|RIGHT}, // DragonFly\n{\"lim\",       \"LIM\",     pr_lim,      sr_rss_rlim, 5,  0,    BSD, AN|RIGHT},\n{\"login\",     \"LOGNAME\", pr_nop,      sr_nop,     8,   0,    BSD, AN|LEFT}, /*logname*/   /* double check */\n{\"logname\",   \"LOGNAME\", pr_nop,      sr_nop,     8,   0,    XXX, AN|LEFT}, /*login*/\n{\"longtname\", \"TTY\",     pr_tty8,     sr_tty,     8,   0,    DEC, PO|LEFT},\n{\"lsession\",  \"SESSION\", pr_sd_session, NULL,    11,  SD,    LNX, ET|LEFT},\n{\"lstart\",    \"STARTED\", pr_lstart,   NULL,      24,   0,    XXX, ET|RIGHT},\n{\"luid\",      \"LUID\",    pr_luid,     NULL,       5,   0,    LNX, ET|RIGHT}, /* login ID */\n{\"luser\",     \"LUSER\",   pr_nop,      sr_nop,     8, USR,    LNX, ET|USER}, /* login USER */\n{\"lwp\",       \"LWP\",     pr_tasks,    sr_tasks,   5,   0,    SUN, TO|PIDMAX|RIGHT},\n{\"lxc\",       \"LXC\",     pr_lxcname,  sr_lxcname, 8, LXC,    LNX, ET|LEFT},\n{\"m_drs\",     \"DRS\",     pr_drs,      sr_drs,     5, MEM,    LNx, PO|RIGHT},\n{\"m_dt\",      \"DT\",      pr_nop,      sr_dt,      4, MEM,    LNx, PO|RIGHT},\n{\"m_lrs\",     \"LRS\",     pr_nop,      sr_lrs,     5, MEM,    LNx, PO|RIGHT},\n{\"m_resident\", \"RES\",    pr_nop,      sr_resident, 5,MEM,    LNx, PO|RIGHT},\n{\"m_share\",   \"SHRD\",    pr_nop,      sr_share,   5, MEM,    LNx, PO|RIGHT},\n{\"m_size\",    \"SIZE\",    pr_size,     sr_size,    5, MEM,    LNX, PO|RIGHT},\n{\"m_swap\",    \"SWAP\",    pr_nop,      sr_nop,     5,   0,    LNx, PO|RIGHT},\n{\"m_trs\",     \"TRS\",     pr_trs,      sr_trs,     5, MEM,    LNx, PO|RIGHT},\n{\"machine\",   \"MACHINE\", pr_sd_machine, NULL,    31,  SD,    LNX, ET|LEFT},\n{\"maj_flt\",   \"MAJFL\",   pr_majflt,   sr_maj_flt, 6,   0,    LNX, AN|RIGHT},\n{\"majflt\",    \"MAJFLT\",  pr_majflt,   sr_maj_flt, 6,   0,    XXX, AN|RIGHT},\n{\"min_flt\",   \"MINFL\",   pr_minflt,   sr_min_flt, 6,   0,    LNX, AN|RIGHT},\n{\"minflt\",    \"MINFLT\",  pr_minflt,   sr_min_flt, 6,   0,    XXX, AN|RIGHT},\n{\"mntns\",     \"MNTNS\",   pr_mntns,    sr_mntns,  10,  NS,    LNX, ET|RIGHT},\n{\"msgrcv\",    \"MSGRCV\",  pr_nop,      sr_nop,     6,   0,    XXX, AN|RIGHT},\n{\"msgsnd\",    \"MSGSND\",  pr_nop,      sr_nop,     6,   0,    XXX, AN|RIGHT},\n{\"mwchan\",    \"MWCHAN\",  pr_nop,      sr_nop,     6,   0,    BSD, TO|WCHAN}, /* mutex (FreeBSD) */\n{\"netns\",     \"NETNS\",   pr_netns,    sr_netns,  10,  NS,    LNX, ET|RIGHT},\n{\"ni\",        \"NI\",      pr_nice,     sr_nice,    3,   0,    BSD, TO|RIGHT}, /*nice*/\n{\"nice\",      \"NI\",      pr_nice,     sr_nice,    3,   0,    U98, TO|RIGHT}, /*ni*/\n{\"nivcsw\",    \"IVCSW\",   pr_nop,      sr_nop,     5,   0,    XXX, AN|RIGHT},\n{\"nlwp\",      \"NLWP\",    pr_nlwp,     sr_nlwp,    4,   0,    SUN, PO|RIGHT},\n{\"nsignals\",  \"NSIGS\",   pr_nop,      sr_nop,     5,   0,    DEC, AN|RIGHT}, /*nsigs*/\n{\"nsigs\",     \"NSIGS\",   pr_nop,      sr_nop,     5,   0,    BSD, AN|RIGHT}, /*nsignals*/\n{\"nswap\",     \"NSWAP\",   pr_nop,      sr_nop,     5,   0,    XXX, AN|RIGHT},\n{\"numa\",      \"NUMA\",    pr_numa,     NULL,       4,   0,    XXX, AN|RIGHT},\n{\"nvcsw\",     \"VCSW\",    pr_nop,      sr_nop,     5,   0,    XXX, AN|RIGHT},\n{\"nwchan\",    \"WCHAN\",   pr_nwchan,   NULL,       6,   0,    XXX, TO|RIGHT},\n{\"opri\",      \"PRI\",     pr_opri,     sr_priority, 3,  0,    SUN, TO|RIGHT},\n{\"osz\",       \"SZ\",      pr_nop,      sr_nop,     2,   0,    SUN, PO|RIGHT},\n{\"oublk\",     \"OUBLK\",   pr_nop,      sr_nop,     5,   0,    BSD, AN|RIGHT}, /*oublock*/\n{\"oublock\",   \"OUBLK\",   pr_nop,      sr_nop,     5,   0,    DEC, AN|RIGHT}, /*oublk*/\n{\"ouid\",      \"OWNER\",   pr_sd_ouid,  NULL,       5,  SD,    LNX, ET|LEFT},\n{\"p_ru\",      \"P_RU\",    pr_nop,      sr_nop,     6,   0,    BSD, AN|RIGHT},\n{\"paddr\",     \"PADDR\",   pr_nop,      sr_nop,     6,   0,    BSD, AN|RIGHT},\n{\"pagein\",    \"PAGEIN\",  pr_majflt,   sr_maj_flt, 6,   0,    XXX, AN|RIGHT},\n{\"pcpu\",      \"%CPU\",    pr_pcpu,     sr_pcpu,    4,   0,    U98, ET|RIGHT}, /*%cpu*/\n{\"pending\",   \"PENDING\", pr_sig,      NULL,       9,   0,    BSD, ET|SIGNAL}, /*sig*/\n{\"pgid\",      \"PGID\",    pr_pgid,     sr_pgrp,    5,   0,    U98, PO|PIDMAX|RIGHT},\n{\"pgrp\",      \"PGRP\",    pr_pgid,     sr_pgrp,    5,   0,    LNX, PO|PIDMAX|RIGHT},\n{\"pid\",       \"PID\",     pr_procs,    sr_procs,   5,   0,    U98, PO|PIDMAX|RIGHT},\n{\"pidns\",     \"PIDNS\",   pr_pidns,    sr_pidns,  10,  NS,    LNX, ET|RIGHT},\n{\"pmem\",      \"%MEM\",    pr_pmem,     sr_rss,     4,   0,    XXX, PO|RIGHT}, /*%mem*/\n{\"poip\",      \"-\",       pr_nop,      sr_nop,     1,   0,    BSD, AN|RIGHT},\n{\"policy\",    \"POL\",     pr_class,    sr_sched,   3,   0,    DEC, TO|LEFT},\n{\"ppid\",      \"PPID\",    pr_ppid,     sr_ppid,    5,   0,    U98, PO|PIDMAX|RIGHT},\n{\"pri\",       \"PRI\",     pr_pri,      NULL,       3,   0,    XXX, TO|RIGHT},\n{\"pri_api\",   \"API\",     pr_pri_api,  NULL,       3,   0,    LNX, TO|RIGHT},\n{\"pri_bar\",   \"BAR\",     pr_pri_bar,  NULL,       3,   0,    LNX, TO|RIGHT},\n{\"pri_baz\",   \"BAZ\",     pr_pri_baz,  NULL,       3,   0,    LNX, TO|RIGHT},\n{\"pri_foo\",   \"FOO\",     pr_pri_foo,  NULL,       3,   0,    LNX, TO|RIGHT},\n{\"priority\",  \"PRI\",     pr_priority, sr_priority, 3,  0,    LNX, TO|RIGHT},\n{\"prmgrp\",    \"PRMGRP\",  pr_nop,      sr_nop,    12,   0,    HPU, PO|RIGHT},\n{\"prmid\",     \"PRMID\",   pr_nop,      sr_nop,    12,   0,    HPU, PO|RIGHT},\n{\"project\",   \"PROJECT\", pr_nop,      sr_nop,    12,   0,    SUN, PO|LEFT}, // see prm* andctid\n{\"projid\",    \"PROJID\",  pr_nop,      sr_nop,     5,   0,    SUN, PO|RIGHT},\n{\"pset\",      \"PSET\",    pr_nop,      sr_nop,     4,   0,    DEC, TO|RIGHT},\n{\"psr\",       \"PSR\",     pr_psr,      NULL,       3,   0,    DEC, TO|RIGHT},\n{\"psxpri\",    \"PPR\",     pr_nop,      sr_nop,     3,   0,    DEC, TO|RIGHT},\n{\"re\",        \"RE\",      pr_nop,      sr_nop,     3,   0,    BSD, AN|RIGHT},\n{\"resident\",  \"RES\",     pr_nop,      sr_resident, 5,MEM,    LNX, PO|RIGHT},\n{\"rgid\",      \"RGID\",    pr_rgid,     sr_rgid,    5,   0,    XXX, ET|RIGHT},\n{\"rgroup\",    \"RGROUP\",  pr_rgroup,   sr_rgroup,  8, GRP,    U98, ET|USER}, /* was 8 wide */\n{\"rlink\",     \"RLINK\",   pr_nop,      sr_nop,     8,   0,    BSD, AN|RIGHT},\n{\"rss\",       \"RSS\",     pr_rss,      sr_rss,     5,   0,    XXX, PO|RIGHT}, /* was 5 wide */\n{\"rssize\",    \"RSS\",     pr_rss,      sr_vm_rss,  5,   0,    DEC, PO|RIGHT}, /*rsz*/\n{\"rsz\",       \"RSZ\",     pr_rss,      sr_vm_rss,  5,   0,    BSD, PO|RIGHT}, /*rssize*/\n{\"rtprio\",    \"RTPRIO\",  pr_rtprio,   sr_rtprio,  6,   0,    BSD, TO|RIGHT},\n{\"ruid\",      \"RUID\",    pr_ruid,     sr_ruid,    5,   0,    XXX, ET|RIGHT},\n{\"ruser\",     \"RUSER\",   pr_ruser,    sr_ruser,   8, USR,    U98, ET|USER},\n{\"s\",         \"S\",       pr_s,        sr_state,   1,   0,    SUN, TO|LEFT}, /*stat,state*/\n{\"sched\",     \"SCH\",     pr_sched,    sr_sched,   3,   0,    AIX, TO|RIGHT},\n{\"scnt\",      \"SCNT\",    pr_nop,      sr_nop,     4,   0,    DEC, AN|RIGHT},  /* man page misspelling of scount? */\n{\"scount\",    \"SC\",      pr_nop,      sr_nop,     4,   0,    AIX, AN|RIGHT},  /* scnt==scount, DEC claims both */\n{\"seat\",      \"SEAT\",    pr_sd_seat,  NULL,      11,  SD,    LNX, ET|LEFT},\n{\"sess\",      \"SESS\",    pr_sess,     sr_session, 5,   0,    XXX, PO|PIDMAX|RIGHT},\n{\"session\",   \"SESS\",    pr_sess,     sr_session, 5,   0,    LNX, PO|PIDMAX|RIGHT},\n{\"sgi_p\",     \"P\",       pr_sgi_p,    NULL,       1,   0,    LNX, TO|RIGHT}, /* \"cpu\" number */\n{\"sgi_rss\",   \"RSS\",     pr_rss,      NULL,       4,   0,    LNX, PO|LEFT}, /* SZ:RSS */\n{\"sgid\",      \"SGID\",    pr_sgid,     sr_sgid,    5,   0,    LNX, ET|RIGHT},\n{\"sgroup\",    \"SGROUP\",  pr_sgroup,   sr_sgroup,  8, GRP,    LNX, ET|USER},\n{\"share\",     \"-\",       pr_nop,      sr_share,   1, MEM,    LNX, PO|RIGHT},\n{\"sid\",       \"SID\",     pr_sess,     sr_session, 5,   0,    XXX, PO|PIDMAX|RIGHT}, /* Sun & HP */\n{\"sig\",       \"PENDING\", pr_sig,      NULL,       9,   0,    XXX, ET|SIGNAL}, /*pending -- Dragonfly uses this for whole-proc and \"tsig\" for thread */\n{\"sig_block\", \"BLOCKED\",  pr_sigmask, NULL,       9,   0,    LNX, TO|SIGNAL},\n{\"sig_catch\", \"CATCHED\", pr_sigcatch, NULL,       9,   0,    LNX, TO|SIGNAL},\n{\"sig_ignore\", \"IGNORED\",pr_sigignore,NULL,       9,   0,    LNX, TO|SIGNAL},\n{\"sig_pend\",  \"SIGNAL\",   pr_sig,     NULL,       9,   0,    LNX, ET|SIGNAL},\n{\"sigcatch\",  \"CAUGHT\",  pr_sigcatch, NULL,       9,   0,    XXX, TO|SIGNAL}, /*caught*/\n{\"sigignore\", \"IGNORED\", pr_sigignore,NULL,       9,   0,    XXX, TO|SIGNAL}, /*ignored*/\n{\"sigmask\",   \"BLOCKED\", pr_sigmask,  NULL,       9,   0,    XXX, TO|SIGNAL}, /*blocked*/\n{\"size\",      \"SIZE\",    pr_swapable, sr_swapable, 5,  0,    SCO, PO|RIGHT},\n{\"sl\",        \"SL\",      pr_nop,      sr_nop,     3,   0,    XXX, AN|RIGHT},\n{\"slice\",      \"SLICE\",  pr_sd_slice, NULL,      31,  SD,    LNX, ET|LEFT},\n{\"spid\",      \"SPID\",    pr_tasks,    sr_tasks,   5,   0,    SGI, TO|PIDMAX|RIGHT},\n{\"stackp\",    \"STACKP\",  pr_stackp,   sr_start_stack, (int)(2*sizeof(long)), 0, LNX, PO|RIGHT}, /*start_stack*/\n{\"start\",     \"STARTED\", pr_start,    NULL,       8,   0,    XXX, ET|RIGHT},\n{\"start_code\", \"S_CODE\",  pr_nop,     sr_start_code,  (int)(2*sizeof(long)), 0, LNx, PO|RIGHT},\n{\"start_stack\", \"STACKP\", pr_stackp,  sr_start_stack, (int)(2*sizeof(long)), 0, LNX, PO|RIGHT}, /*stackp*/\n{\"start_time\", \"START\",  pr_stime,    sr_start_time, 5, 0,   LNx, ET|RIGHT},\n{\"stat\",      \"STAT\",    pr_stat,     sr_state,   4,   0,    BSD, TO|LEFT}, /*state,s*/\n{\"state\",     \"S\",       pr_s,        sr_state,   1,   0,    XXX, TO|LEFT}, /*stat,s*/ /* was STAT */\n{\"status\",    \"STATUS\",  pr_nop,      sr_nop,     6,   0,    DEC, AN|RIGHT},\n{\"stime\",     \"STIME\",   pr_stime,    sr_stime,   5,   0,    XXX, ET|RIGHT}, /* was 6 wide */\n{\"suid\",      \"SUID\",    pr_suid,     sr_suid,    5,   0,    LNx, ET|RIGHT},\n{\"supgid\",    \"SUPGID\",  pr_supgid,   NULL,      20,   0,    LNX, PO|UNLIMITED},\n{\"supgrp\",    \"SUPGRP\",  pr_supgrp,   NULL,      40,SGRP,    LNX, PO|UNLIMITED},\n{\"suser\",     \"SUSER\",   pr_suser,    sr_suser,   8, USR,    LNx, ET|USER},\n{\"svgid\",     \"SVGID\",   pr_sgid,     sr_sgid,    5,   0,    XXX, ET|RIGHT},\n{\"svgroup\",   \"SVGROUP\", pr_sgroup,   sr_sgroup,  8, GRP,    LNX, ET|USER},\n{\"svuid\",     \"SVUID\",   pr_suid,     sr_suid,    5,   0,    XXX, ET|RIGHT},\n{\"svuser\",    \"SVUSER\",  pr_suser,    sr_suser,   8, USR,    LNX, ET|USER},\n{\"systime\",   \"SYSTEM\",  pr_nop,      sr_nop,     6,   0,    DEC, ET|RIGHT},\n{\"sz\",        \"SZ\",      pr_sz,       NULL,       5,   0,    HPU, PO|RIGHT},\n{\"taskid\",    \"TASKID\",  pr_nop,      sr_nop,     5,   0,    SUN, TO|PIDMAX|RIGHT}, // is this a thread ID?\n{\"tdev\",      \"TDEV\",    pr_nop,      sr_nop,     4,   0,    XXX, AN|RIGHT},\n{\"tgid\",      \"TGID\",    pr_procs,    sr_procs,   5,   0,    LNX, PO|PIDMAX|RIGHT},\n{\"thcount\",   \"THCNT\",   pr_nlwp,     sr_nlwp,    5,   0,    AIX, PO|RIGHT},\n{\"tid\",       \"TID\",     pr_tasks,    sr_tasks,   5,   0,    AIX, TO|PIDMAX|RIGHT},\n{\"time\",      \"TIME\",    pr_time,     sr_time,    8,   0,    U98, ET|RIGHT}, /*cputime*/ /* was 6 wide */\n{\"timeout\",   \"TMOUT\",   pr_nop,      sr_nop,     5,   0,    LNX, AN|RIGHT}, // 2.0.xx era\n{\"times\",     \"TIME\",    pr_times,    sr_time,    8,   0,    LNX, ET|RIGHT},\n{\"tmout\",     \"TMOUT\",   pr_nop,      sr_nop,     5,   0,    LNX, AN|RIGHT}, // 2.0.xx era\n{\"tname\",     \"TTY\",     pr_tty8,     sr_tty,     8,   0,    DEC, PO|LEFT},\n{\"tpgid\",     \"TPGID\",   pr_tpgid,    sr_tpgid,   5,   0,    XXX, PO|PIDMAX|RIGHT},\n{\"trs\",       \"TRS\",     pr_trs,      sr_trs,     4, MEM,    AIX, PO|RIGHT},\n{\"trss\",      \"TRSS\",    pr_trs,      sr_trs,     4, MEM,    BSD, PO|RIGHT}, /* 4.3BSD NET/2 */\n{\"tsess\",     \"TSESS\",   pr_nop,      sr_nop,     5,   0,    BSD, PO|PIDMAX|RIGHT},\n{\"tsession\",  \"TSESS\",   pr_nop,      sr_nop,     5,   0,    DEC, PO|PIDMAX|RIGHT},\n{\"tsid\",      \"TSID\",    pr_nop,      sr_nop,     5,   0,    BSD, PO|PIDMAX|RIGHT},\n{\"tsig\",      \"PENDING\", pr_tsig,     NULL,       9,   0,    BSD, ET|SIGNAL}, /* Dragonfly used this for thread-specific, and \"sig\" for whole-proc */\n{\"tsiz\",      \"TSIZ\",    pr_tsiz,     NULL,       4,   0,    BSD, PO|RIGHT},\n{\"tt\",        \"TT\",      pr_tty8,     sr_tty,     8,   0,    BSD, PO|LEFT},\n{\"tty\",       \"TT\",      pr_tty8,     sr_tty,     8,   0,    U98, PO|LEFT}, /* Unix98 requires \"TT\" but has \"TTY\" too. :-( */  /* was 3 wide */\n{\"tty4\",      \"TTY\",     pr_tty4,     sr_tty,     4,   0,    LNX, PO|LEFT},\n{\"tty8\",      \"TTY\",     pr_tty8,     sr_tty,     8,   0,    LNX, PO|LEFT},\n{\"u_procp\",   \"UPROCP\",  pr_nop,      sr_nop,     6,   0,    DEC, AN|RIGHT},\n{\"ucmd\",      \"CMD\",     pr_comm,     sr_cmd,    15, COM,    DEC, PO|UNLIMITED}, /*ucomm*/\n{\"ucomm\",     \"COMMAND\", pr_comm,     sr_cmd,    15, COM,    XXX, PO|UNLIMITED}, /*comm*/\n{\"uid\",       \"UID\",     pr_euid,     sr_euid,    5,   0,    XXX, ET|RIGHT},\n{\"uid_hack\",  \"UID\",     pr_euser,    sr_euser,   8, USR,    XXX, ET|USER},\n{\"umask\",     \"UMASK\",   pr_nop,      sr_nop,     5,   0,    DEC, AN|RIGHT},\n{\"uname\",     \"USER\",    pr_euser,    sr_euser,   8, USR,    DEC, ET|USER}, /* man page misspelling of user? */\n{\"unit\",      \"UNIT\",    pr_sd_unit,  NULL,      31,  SD,    LNX, ET|LEFT},\n{\"upr\",       \"UPR\",     pr_nop,      sr_nop,     3,   0,    BSD, TO|RIGHT}, /*usrpri*/\n{\"uprocp\",    \"UPROCP\",  pr_nop,      sr_nop,     8,   0,    BSD, AN|RIGHT},\n{\"user\",      \"USER\",    pr_euser,    sr_euser,   8, USR,    U98, ET|USER}, /* BSD n forces this to UID */\n{\"userns\",    \"USERNS\",  pr_userns,   sr_userns, 10,  NS,    LNX, ET|RIGHT},\n{\"usertime\",  \"USER\",    pr_nop,      sr_nop,     4,   0,    DEC, ET|RIGHT},\n{\"usrpri\",    \"UPR\",     pr_nop,      sr_nop,     3,   0,    DEC, TO|RIGHT}, /*upr*/\n{\"util\",      \"C\",       pr_c,        sr_pcpu,    2,   0,    SGI, ET|RIGHT}, // not sure about \"C\"\n{\"utime\",     \"UTIME\",   pr_nop,      sr_utime,   6,   0,    LNx, ET|RIGHT},\n{\"utsns\",     \"UTSNS\",   pr_utsns,    sr_utsns,  10,  NS,    LNX, ET|RIGHT},\n{\"uunit\",     \"UUNIT\",   pr_sd_uunit, NULL,      31,  SD,    LNX, ET|LEFT},\n{\"vm_data\",   \"DATA\",    pr_nop,      sr_vm_data, 5,   0,    LNx, PO|RIGHT},\n{\"vm_exe\",    \"EXE\",     pr_nop,      sr_vm_exe,  5,   0,    LNx, PO|RIGHT},\n{\"vm_lib\",    \"LIB\",     pr_nop,      sr_vm_lib,  5,   0,    LNx, PO|RIGHT},\n{\"vm_lock\",   \"LCK\",     pr_nop,      sr_vm_lock, 3,   0,    LNx, PO|RIGHT},\n{\"vm_stack\",  \"STACK\",   pr_nop,      sr_vm_stack, 5,  0,    LNx, PO|RIGHT},\n{\"vsize\",     \"VSZ\",     pr_vsz,      sr_vsize,   6,   0,    DEC, PO|RIGHT}, /*vsz*/\n{\"vsz\",       \"VSZ\",     pr_vsz,      sr_vm_size, 6,   0,    U98, PO|RIGHT}, /*vsize*/\n{\"wchan\",     \"WCHAN\",   pr_wchan,    sr_wchan,   6,   0,    XXX, TO|WCHAN}, /* BSD n forces this to nwchan */ /* was 10 wide */\n{\"wname\",     \"WCHAN\",   pr_wname,    NULL,       6,   0,    SGI, TO|WCHAN}, /* opposite of nwchan */\n{\"xstat\",     \"XSTAT\",   pr_nop,      sr_nop,     5,   0,    BSD, AN|RIGHT},\n{\"zone\",      \"ZONE\",    pr_context,  NULL,      31,   0,    SUN, ET|LEFT}, // Solaris zone == Linux context?\n{\"zoneid\",    \"ZONEID\",  pr_nop,      sr_nop,    31,   0,    SUN, ET|RIGHT},// Linux only offers context names\n{\"~\",         \"-\",       pr_nop,      sr_nop,     1,   0,    LNX, AN|RIGHT}  /* NULL would ruin alphabetical order */\n};\n\n#undef USER\n#undef LEFT\n#undef RIGHT\n#undef UNLIMITED\n#undef WCHAN\n#undef SIGNAL\n#undef PIDMAX\n#undef PO\n#undef TO\n#undef AN\n#undef ET\n\nstatic const int format_array_count = sizeof(format_array)/sizeof(format_struct);\n\n\n/****************************** Macro formats *******************************/\n/* First X field may be NR, which is p->start_code>>26 printed with %2ld */\n/* That seems useless though, and Debian already killed it. */\n/* The ones marked \"Digital\" have the name defined, not just the data. */\nstatic const macro_struct macro_array[] = {\n{\"DFMT\",     \"pid,tname,state,cputime,cmd\"},         /* Digital's default */\n{\"DefBSD\",   \"pid,tname,stat,bsdtime,args\"},               /* Our BSD default */\n{\"DefSysV\",  \"pid,tname,time,cmd\"},                     /* Our SysV default */\n{\"END_BSD\",  \"state,tname,cputime,comm\"},                 /* trailer for O */\n{\"END_SYS5\", \"state,tname,time,command\"},                 /* trailer for -O */\n{\"F5FMT\",    \"uname,pid,ppid,c,start,tname,time,cmd\"},       /* Digital -f */\n\n{\"FB_\",      \"pid,tt,stat,time,command\"},                          /* FreeBSD default */\n{\"FB_j\",     \"user,pid,ppid,pgid,sess,jobc,stat,tt,time,command\"},     /* FreeBSD j */\n{\"FB_l\",     \"uid,pid,ppid,cpu,pri,nice,vsz,rss,wchan,stat,tt,time,command\"},   /* FreeBSD l */\n{\"FB_u\",     \"user,pid,pcpu,pmem,vsz,rss,tt,stat,start,time,command\"},     /* FreeBSD u */\n{\"FB_v\",     \"pid,stat,time,sl,re,pagein,vsz,rss,lim,tsiz,pcpu,pmem,command\"},   /* FreeBSD v */\n\n{\"FD_\",      \"pid,tty,time,comm\"},                                 /* Fictional Debian SysV default */\n{\"FD_f\",     \"user,pid,ppid,start_time,tty,time,comm\"},                /* Fictional Debian -f */\n{\"FD_fj\",    \"user,pid,ppid,start_time,tty,time,pgid,sid,comm\"},        /* Fictional Debian -jf */\n{\"FD_j\",     \"pid,tty,time,pgid,sid,comm\"},                                  /* Fictional Debian -j */\n{\"FD_l\",     \"flags,state,uid,pid,ppid,priority,nice,vsz,wchan,tty,time,comm\"},    /* Fictional Debian -l */\n{\"FD_lj\",    \"flags,state,uid,pid,ppid,priority,nice,vsz,wchan,tty,time,pgid,sid,comm\"}, /* Fictional Debian -jl */\n\n{\"FL5FMT\",   \"f,state,uid,pid,ppid,pcpu,pri,nice,rss,wchan,start,time,command\"},  /* Digital -fl */\n\n{\"FLASK_context\",   \"pid,context,command\"},  /* Flask Linux context, --context */\n\n{\"HP_\",      \"pid,tty,time,comm\"},  /* HP default */\n{\"HP_f\",     \"user,pid,ppid,cpu,stime,tty,time,args\"},  /* HP -f */\n{\"HP_fl\",    \"flags,state,user,pid,ppid,cpu,intpri,nice,addr,sz,wchan,stime,tty,time,args\"},  /* HP -fl */\n{\"HP_l\",     \"flags,state,uid,pid,ppid,cpu,intpri,nice,addr,sz,wchan,tty,time,comm\"},  /* HP -l */\n\n{\"J390\",     \"pid,sid,pgrp,tname,atime,args\"},   /* OS/390 -j */\n{\"JFMT\",     \"user,pid,ppid,pgid,sess,jobc,state,tname,cputime,command\"},   /* Digital j and -j */\n{\"L5FMT\",    \"f,state,uid,pid,ppid,c,pri,nice,addr,sz,wchan,tt,time,ucmd\"},   /* Digital -l */\n{\"LFMT\",     \"uid,pid,ppid,cp,pri,nice,vsz,rss,wchan,state,tname,cputime,command\"},   /* Digital l */\n\n{\"OL_X\",     \"pid,start_stack,esp,eip,timeout,alarm,stat,tname,bsdtime,args\"},      /* Old i386 Linux X */\n{\"OL_j\",     \"ppid,pid,pgid,sid,tname,tpgid,stat,uid,bsdtime,args\"},                   /* Old Linux j */\n{\"OL_l\",     \"flags,uid,pid,ppid,priority,nice,vsz,rss,wchan,stat,tname,bsdtime,args\"},     /* Old Linux l */\n{\"OL_m\",     \"pid,tname,majflt,minflt,m_trs,m_drs,m_size,m_swap,rss,m_share,vm_lib,m_dt,args\"}, /* Old Linux m */\n{\"OL_s\",     \"uid,pid,pending,sig_block,sig_ignore,caught,stat,tname,bsdtime,args\"},  /* Old Linux s */\n{\"OL_u\",     \"user,pid,pcpu,pmem,vsz,rss,tname,stat,start_time,bsdtime,args\"},       /* Old Linux u */\n{\"OL_v\",     \"pid,tname,stat,bsdtime,maj_flt,m_trs,m_drs,rss,pmem,args\"},            /* Old Linux v */\n\n{\"RD_\",      \"pid,tname,state,bsdtime,comm\"},                                       /* Real Debian default */\n{\"RD_f\",     \"uid,pid,ppid,start_time,tname,bsdtime,args\"},                         /* Real Debian -f */\n{\"RD_fj\",    \"uid,pid,ppid,start_time,tname,bsdtime,pgid,sid,args\"},                /* Real Debian -jf */\n{\"RD_j\",     \"pid,tname,state,bsdtime,pgid,sid,comm\"},                               /* Real Debian -j */\n{\"RD_l\",     \"flags,state,uid,pid,ppid,priority,nice,wchan,tname,bsdtime,comm\"},           /* Real Debian -l */\n{\"RD_lj\",    \"flags,state,uid,pid,ppid,priority,nice,wchan,tname,bsdtime,pgid,sid,comm\"},  /* Real Debian -jl */\n\n{\"RUSAGE\",   \"minflt,majflt,nswap,inblock,oublock,msgsnd,msgrcv,nsigs,nvcsw,nivcsw\"}, /* Digital -o \"RUSAGE\" */\n{\"SCHED\",    \"user,pcpu,pri,usrpri,nice,psxpri,psr,policy,pset\"},                /* Digital -o \"SCHED\" */\n{\"SFMT\",     \"uid,pid,cursig,sig,sigmask,sigignore,sigcatch,stat,tname,command\"},  /* Digital s */\n\n{\"Std_f\",    \"uid_hack,pid,ppid,c,stime,tname,time,cmd\"},                     /* new -f */\n{\"Std_fl\",   \"f,s,uid_hack,pid,ppid,c,opri,ni,addr,sz,wchan,stime,tname,time,cmd\"}, /* -fl */\n{\"Std_l\",    \"f,s,uid,pid,ppid,c,opri,ni,addr,sz,wchan,tname,time,ucmd\"},  /* new -l */\n\n{\"THREAD\",   \"user,pcpu,pri,scnt,wchan,usertime,systime\"},                /* Digital -o \"THREAD\" */\n{\"UFMT\",     \"uname,pid,pcpu,pmem,vsz,rss,tt,state,start,time,command\"},   /* Digital u */\n{\"VFMT\",     \"pid,tt,state,time,sl,pagein,vsz,rss,pcpu,pmem,command\"},   /* Digital v */\n{\"~\", \"~\"} /* NULL would ruin alphabetical order */\n};\n\nstatic const int macro_array_count = sizeof(macro_array)/sizeof(macro_struct);\n\n\n/*************************** AIX formats ********************/\n/* Convert AIX format codes to normal format specifiers. */\nstatic const aix_struct aix_array[] = {\n{'C', \"pcpu\",   \"%CPU\"},\n{'G', \"group\",  \"GROUP\"},\n{'P', \"ppid\",   \"PPID\"},\n{'U', \"user\",   \"USER\"},\n{'a', \"args\",   \"COMMAND\"},\n{'c', \"comm\",   \"COMMAND\"},\n{'g', \"rgroup\", \"RGROUP\"},\n{'n', \"nice\",   \"NI\"},\n{'p', \"pid\",    \"PID\"},\n{'r', \"pgid\",   \"PGID\"},\n{'t', \"etime\",  \"ELAPSED\"},\n{'u', \"ruser\",  \"RUSER\"},\n{'x', \"time\",   \"TIME\"},\n{'y', \"tty\",    \"TTY\"},\n{'z', \"vsz\",    \"VSZ\"},\n{'~', \"~\",      \"~\"} /* NULL would ruin alphabetical order */\n};\n//static const int aix_array_count = sizeof(aix_array)/sizeof(aix_struct);\n\n\n/********************* sorting ***************************/\n/* Convert short sorting codes to normal format specifiers. */\nstatic const shortsort_struct shortsort_array[] = {\n{'C', \"pcpu\"       },\n{'G', \"tpgid\"      },\n{'J', \"cstime\"     },\n/* {'K', \"stime\"      }, */  /* conflict, system vs. start time */\n{'M', \"maj_flt\"    },\n{'N', \"cmaj_flt\"   },\n{'P', \"ppid\"       },\n{'R', \"resident\"   },\n{'S', \"share\"      },\n{'T', \"start_time\" },\n{'U', \"uid\"        }, /* euid */\n{'c', \"cmd\"        },\n{'f', \"flags\"      },\n{'g', \"pgrp\"       },\n{'j', \"cutime\"     },\n{'k', \"utime\"      },\n{'m', \"min_flt\"    },\n{'n', \"cmin_flt\"   },\n{'o', \"session\"    },\n{'p', \"pid\"        },\n{'r', \"rss\"        },\n{'s', \"size\"       },\n{'t', \"tty\"        },\n{'u', \"user\"       },\n{'v', \"vsize\"      },\n{'y', \"priority\"   }, /* nice */\n{'~', \"~\"          } /* NULL would ruin alphabetical order */\n};\n//static const int shortsort_array_count = sizeof(shortsort_array)/sizeof(shortsort_struct);\n\n\n/*********** print format_array **********/\n/* called by the parser in another file */\nvoid print_format_specifiers(void){\n  const format_struct *walk = format_array;\n  while(*(walk->spec) != '~'){\n    if(walk->pr != pr_nop) printf(\"%-12.12s %-8.8s\\n\", walk->spec, walk->head);\n    walk++;\n  }\n}\n\n/************ comparison functions for bsearch *************/\n\nstatic int compare_format_structs(const void *a, const void *b){\n  return strcmp(((const format_struct*)a)->spec,((const format_struct*)b)->spec);\n}\n\nstatic int compare_macro_structs(const void *a, const void *b){\n  return strcmp(((const macro_struct*)a)->spec,((const macro_struct*)b)->spec);\n}\n\n/******** look up structs as needed by the sort & format parsers ******/\n\nconst shortsort_struct *search_shortsort_array(const int findme){\n  const shortsort_struct *walk = shortsort_array;\n  while(walk->desc != '~'){\n    if(walk->desc == findme) return walk;\n    walk++;\n  }\n  return NULL;\n}\n\nconst aix_struct *search_aix_array(const int findme){\n  const aix_struct *walk = aix_array;\n  while(walk->desc != '~'){\n    if(walk->desc == findme) return walk;\n    walk++;\n  }\n  return NULL;\n}\n\nconst format_struct *search_format_array(const char *findme){\n  format_struct key;\n  key.spec = findme;\n  return bsearch(&key, format_array, format_array_count,\n    sizeof(format_struct), compare_format_structs\n  );\n}\n\nconst macro_struct *search_macro_array(const char *findme){\n  macro_struct key;\n  key.spec = findme;\n  return bsearch(&key, macro_array, macro_array_count,\n    sizeof(macro_struct), compare_macro_structs\n  );\n}\n\nstatic unsigned int active_cols;  /* some multiple of screen_cols */\n\n/***** Last chance, avoid needless trunctuation. */\nstatic void check_header_width(void){\n  format_node *walk = format_list;\n  unsigned int total = 0;\n  int was_normal = 0;\n  unsigned int i = 0;\n  unsigned int sigs = 0;\n  while(walk){\n    switch((walk->flags) & CF_JUST_MASK){\n    default:\n      total += walk->width;\n      total += was_normal;\n      was_normal = 1;\n      break;\n    case CF_SIGNAL:\n      sigs++;\n      total += walk->width;\n      total += was_normal;\n      was_normal = 1;\n      break;\n    case CF_UNLIMITED:  /* could chop this a bit */\n      if(walk->next) total += walk->width;\n      else total += 3; /* not strlen(walk->name) */\n      total += was_normal;\n      was_normal = 1;\n      break;\n    case 0:  /* AIX */\n      total += walk->width;\n      was_normal = 0;\n      break;\n    }\n    walk = walk->next;\n  }\n  for(;;){\n    i++;\n    active_cols = screen_cols * i;\n    if(active_cols>=total) break;\n    if(screen_cols*i >= OUTBUF_SIZE/2) break; /* can't go over */\n  }\n  wide_signals = (total+sigs*7 <= active_cols);\n}\n\n\n/********** show one process (NULL proc prints header) **********/\n\n//#define SPACE_AMOUNT page_size\n#define SPACE_AMOUNT 144\n\nstatic char *saved_outbuf;\n\nvoid show_one_proc(const proc_t *restrict const p, const format_node *restrict fmt){\n  /* unknown: maybe set correct & actual to 1, remove +/- 1 below */\n  int correct  = 0;  /* screen position we should be at */\n  int actual   = 0;  /* screen position we are at */\n  int amount   = 0;  /* amount of text that this data is */\n  int leftpad  = 0;  /* amount of space this column _could_ need */\n  int space    = 0;  /* amount of space we actually need to print */\n  int dospace  = 0;  /* previous column determined that we need a space */\n  int legit    = 0;  /* legitimately stolen extra space */\n  int sz       = 0;  /* real size of data in outbuffer */\n  int tmpspace = 0;\n  char *restrict const outbuf = saved_outbuf;\n  static int did_stuff = 0;  /* have we ever printed anything? */\n\n  if(unlikely(-1==(long)p)){    /* true only once, at the end */\n    if(did_stuff) return;\n    /* have _never_ printed anything, but might need a header */\n    if(!--lines_to_next_header){\n      lines_to_next_header = header_gap;\n      show_one_proc(NULL,fmt);\n    }\n    /* fprintf(stderr, \"No processes available.\\n\"); */  /* legal? */\n    exit(1);\n  }\n  if(likely(p)){  /* not header, maybe we should call ourselves for it */\n    if(unlikely(!--lines_to_next_header)){\n      lines_to_next_header = header_gap;\n      show_one_proc(NULL,fmt);\n    }\n  }\n  did_stuff = 1;\n  if(unlikely(active_cols>(int)OUTBUF_SIZE)) fprintf(stderr,_(\"fix bigness error\\n\"));\n\n  /* print row start sequence */\n  for(;;){\n    legit = 0;\n    /* set width suggestion which might be ignored */\n//    if(likely(fmt->next)) max_rightward = fmt->width;\n//    else max_rightward = active_cols-((correct>actual) ? correct : actual);\n\n    if(likely(fmt->next)){\n      max_rightward = fmt->width;\n      tmpspace = 0;\n    }else{\n      tmpspace = correct-actual;\n      if (tmpspace<1){\n        tmpspace = dospace;\n        max_rightward = active_cols-actual-tmpspace;\n      }else{\n\tmax_rightward = active_cols - ( (correct>actual) ? correct : actual );\n      }\n    }\n    if(max_rightward <= 0) max_rightward = 0;\n    else if(max_rightward >= OUTBUF_SIZE) max_rightward = OUTBUF_SIZE-1;\n\n    max_leftward  = fmt->width + actual - correct; /* TODO check this */\n    if(max_leftward <= 0) max_leftward = 0;\n    else if(max_leftward >= OUTBUF_SIZE) max_leftward = OUTBUF_SIZE-1;\n\n//    fprintf(stderr, \"cols: %d, max_rightward: %d, max_leftward: %d, actual: %d, correct: %d\\n\",\n//\t\t    active_cols, max_rightward, max_leftward, actual, correct);\n\n    /* prepare data and calculate leftpad */\n    if(likely(p) && likely(fmt->pr)) amount = (*fmt->pr)(outbuf,p);\n    else amount = snprintf(outbuf, OUTBUF_SIZE, \"%s\", fmt->name); /* AIX or headers */\n\n    if(amount < 0) outbuf[amount = 0] = '\\0';\n    else if(amount >= OUTBUF_SIZE) outbuf[amount = OUTBUF_SIZE-1] = '\\0';\n\n    switch((fmt->flags) & CF_JUST_MASK){\n    case 0:  /* for AIX, assigned outside this file */\n      leftpad = 0;\n      break;\n    case CF_LEFT:          /* bad */\n      leftpad = 0;\n      break;\n    case CF_RIGHT:     /* OK */\n      leftpad = fmt->width - amount;\n      if(leftpad < 0) leftpad = 0;\n      break;\n    case CF_SIGNAL:\n      /* if the screen is wide enough, use full 16-character output */\n      if(wide_signals){\n        leftpad = 16 - amount;\n        legit = 7;\n      }else{\n        leftpad =  9 - amount;\n      }\n      if(leftpad < 0) leftpad = 0;\n      break;\n    case CF_USER:       /* bad */\n      leftpad = fmt->width - amount;\n      if(leftpad < 0) leftpad = 0;\n      if(!user_is_number) leftpad = 0;\n      break;\n    case CF_WCHAN:       /* bad */\n      if(wchan_is_number){\n        leftpad = fmt->width - amount;\n        if(leftpad < 0) leftpad = 0;\n        break;\n      }else{\n        if ((active_cols-actual-tmpspace)<1)\n          outbuf[1] = '\\0';  /* oops, we (mostly) lose this column... */\n        leftpad = 0;\n        break;\n      }\n    case CF_UNLIMITED:\n    {\n      if(active_cols-actual-tmpspace < 1)\n        outbuf[1] = '\\0';    /* oops, we (mostly) lose this column... */\n      leftpad = 0;\n      break;\n    }\n    default:\n      fprintf(stderr, _(\"bad alignment code\\n\"));\n      break;\n    }\n    /* At this point:\n     *\n     * correct   from previous column\n     * actual    from previous column\n     * amount    not needed (garbage due to chopping)\n     * leftpad   left padding for this column alone (not make-up or gap)\n     * space     not needed (will recalculate now)\n     * dospace   if we require space between this and the prior column\n     * legit     space we were allowed to steal, and thus did steal\n     */\n    space = correct - actual + leftpad;\n    if(space<1) space=dospace;\n    if(unlikely(space>SPACE_AMOUNT)) space=SPACE_AMOUNT;  // only so much available\n\n    /* real size -- don't forget in 'amount' is number of cells */\n    outbuf[OUTBUF_SIZE-1] = '\\0';\n    sz = strlen(outbuf);\n\n    /* print data, set x position stuff */\n    if(unlikely(!fmt->next)){\n      /* Last column. Write padding + data + newline all together. */\n      outbuf[sz] = '\\n';\n      fwrite(outbuf-space, space+sz+1, 1, stdout);\n      break;\n    }\n    /* Not the last column. Write padding + data together. */\n    fwrite(outbuf-space, space+sz, 1, stdout);\n    actual  += space+amount;\n    correct += fmt->width;\n    correct += legit;        /* adjust for SIGNAL expansion */\n    if(fmt->pr && fmt->next->pr){ /* neither is AIX filler */\n      correct++;\n      dospace = 1;\n    }else{\n      dospace = 0;\n    }\n    fmt = fmt->next;\n    /* At this point:\n     *\n     * correct   screen position we should be at\n     * actual    screen position we are at\n     * amount    not needed\n     * leftpad   not needed\n     * space     not needed\n     * dospace   if have determined that we need a space next time\n     * legit     not needed\n     */\n  }\n}\n\n\nvoid init_output(void){\n  int outbuf_pages;\n  char *outbuf;\n\n  // add page_size-1 to round up\n  outbuf_pages = (OUTBUF_SIZE+SPACE_AMOUNT+page_size-1)/page_size;\n  outbuf = mmap(\n    0,\n    page_size * (outbuf_pages+1), // 1 more, for guard page at high addresses\n    PROT_READ | PROT_WRITE,\n    MAP_PRIVATE | MAP_ANONYMOUS,\n    -1,\n    0\n  );\n  if(outbuf == MAP_FAILED)\n    catastrophic_failure(__FILE__, __LINE__, _(\"please report this bug\"));\n\n  memset(outbuf, ' ', SPACE_AMOUNT);\n  if(SPACE_AMOUNT==page_size) mprotect(outbuf, page_size, PROT_READ);\n  mprotect(outbuf + page_size*outbuf_pages, page_size, PROT_NONE); // guard page\n  saved_outbuf = outbuf + SPACE_AMOUNT;\n  // available space:  page_size*outbuf_pages-SPACE_AMOUNT\n\n  seconds_since_1970 = time(NULL);\n\n  meminfo();\n\n  check_header_width();\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-watch-master-rbge43aeb6b22jpwxmvck4uuyyaonhf4/spack-src/proc/numa.c": "/*\n * NUMA node support for <PIDS> & <STAT> interfaces\n * Copyright 2017 by James C. Warmer\n *\n * This library is free software; you can redistribute it and/or\n * modify it under the terms of the GNU Lesser General Public\n * License as published by the Free Software Foundation; either\n * version 2.1 of the License, or (at your option) any later version.\n *\n * This library is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n * Lesser General Public License for more details.\n *\n * You should have received a copy of the GNU Lesser General Public\n * License along with this library; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA\n */\n\n#ifndef NUMA_DISABLE\n#include <dlfcn.h>\n#endif\n#include <stdlib.h>\n\n#include \"numa.h\"\n\n/*\n * We're structured so that if numa_init() is NOT called or that ./configure |\n * --disable-numa WAS specified, then calls to both of our primary functions |\n * of numa_max_node() plus numa_node_of_cpu() would always return a negative |\n * 1 which signifies that NUMA information isn't available. That ./configure |\n * option might be required when libdl.so (necessary for dlopen) is missing. |\n */\n\n\n/* ------------------------------------------------------------------------- +\n   a strictly development #define, existing specifically for the top program |\n   ( and it has no affect if ./configure --disable-numa has been specified ) | */\n//#define PRETEND_NUMA     // pretend there are 3 'discontiguous' numa nodes |\n// ------------------------------------------------------------------------- +\n\n\nstatic int null_max_node (void) { return -1; }\nstatic int null_node_of_cpu (int n) { (void)n; return -1; }\n\n\n#ifndef NUMA_DISABLE\n #ifdef PRETEND_NUMA\nstatic int fake_max_node (void) { return 3; }\nstatic int fake_node_of_cpu (int n) { return (1 == (n % 4)) ? 0 : (n % 4); }\n #endif\n#endif\n\n\n#ifndef NUMA_DISABLE\nstatic void *libnuma_handle;\n#endif\nint (*numa_max_node) (void)   = null_max_node;\nint (*numa_node_of_cpu) (int) = null_node_of_cpu;\n\n\nvoid numa_init (void) {\n    static int initialized;\n\n    if (initialized)\n        return;\n\n#ifndef NUMA_DISABLE\n #ifndef PRETEND_NUMA\n    // we'll try for the most recent version, then a version we know works...\n    if ((libnuma_handle = dlopen(\"libnuma.so\", RTLD_LAZY))\n    || (libnuma_handle = dlopen(\"libnuma.so.1\", RTLD_LAZY))) {\n        numa_max_node = dlsym(libnuma_handle, \"numa_max_node\");\n        numa_node_of_cpu = dlsym(libnuma_handle, \"numa_node_of_cpu\");\n        if (numa_max_node == NULL\n        || (numa_node_of_cpu == NULL)) {\n            // this dlclose is safe - we've yet to call numa_node_of_cpu\n            // ( there's one other dlclose which has now been disabled )\n            dlclose(libnuma_handle);\n            libnuma_handle = NULL;\n            numa_max_node = null_max_node;\n            numa_node_of_cpu = null_node_of_cpu;\n        }\n    }\n #else\n    libnuma_handle = (void *)-1;\n    numa_max_node = fake_max_node;\n    numa_node_of_cpu = fake_node_of_cpu;\n #endif\n#endif\n    initialized = 1;\n} // end: numa_init\n\n\nvoid numa_uninit (void) {\n#ifndef PRETEND_NUMA\n    /* note: we'll skip a dlcose() to avoid the following libnuma memory\n     *       leak which is triggered after a call to numa_node_of_cpu():\n     *         ==1234== LEAK SUMMARY:\n     *         ==1234==    definitely lost: 512 bytes in 1 blocks\n     *         ==1234==    indirectly lost: 48 bytes in 2 blocks\n     *         ==1234==    ...\n     * [ thanks very much libnuma for all the pains you have caused us ]\n     */\n//  if (libnuma_handle)\n//      dlclose(libnuma_handle);\n#endif\n} // end: numa_uninit\n\n\n#if defined(PRETEND_NUMA) && defined(NUMA_DISABLE)\n# warning 'PRETEND_NUMA' ignored, 'NUMA_DISABLE' is active\n#endif\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-watch-master-rbge43aeb6b22jpwxmvck4uuyyaonhf4/spack-src/lib/strverscmp.c",
        "/tmp/vanessa/spack-stage/spack-stage-watch-master-rbge43aeb6b22jpwxmvck4uuyyaonhf4/spack-src/.git/objects/pack/pack-b10f81fd7ee3d5d8f75048747ef36306a727ce5a.pack",
        "/tmp/vanessa/spack-stage/spack-stage-watch-master-rbge43aeb6b22jpwxmvck4uuyyaonhf4/spack-src/.git/objects/pack/pack-b10f81fd7ee3d5d8f75048747ef36306a727ce5a.idx",
        "/tmp/vanessa/spack-stage/spack-stage-watch-master-rbge43aeb6b22jpwxmvck4uuyyaonhf4/spack-src/top/top.h"
    ],
    "total_files": 175
}