{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/lib/gssapi/mechglue/g_set_cred_option.c": "/*\n * Copyright 2008-2010 by the Massachusetts Institute of Technology.\n * All Rights Reserved.\n *\n * Export of this software from the United States of America may\n *   require a specific license from the United States Government.\n *   It is the responsibility of any person or organization contemplating\n *   export to obtain such a license before exporting.\n *\n * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and\n * distribute this software and its documentation for any purpose and\n * without fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright notice and\n * this permission notice appear in supporting documentation, and that\n * the name of M.I.T. not be used in advertising or publicity pertaining\n * to distribution of the software without specific, written prior\n * permission.  Furthermore if you modify this software you must label\n * your software as modified software and not distribute it in such a\n * fashion that it might be confused with the original M.I.T. software.\n * M.I.T. makes no representations about the suitability of\n * this software for any purpose.  It is provided \"as is\" without express\n * or implied warranty.\n */\n\n/* Glue routine for gssspi_set_cred_option */\n\n#include \"mglueP.h\"\n#include <stdio.h>\n#ifdef HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n#include <string.h>\n#include <time.h>\n\nstatic OM_uint32\nalloc_union_cred(OM_uint32 *minor_status,\n\t\t gss_mechanism mech,\n\t\t gss_cred_id_t mech_cred,\n\t\t gss_union_cred_t *pcred)\n{\n    OM_uint32\t\tstatus;\n    OM_uint32\t\ttemp_minor_status;\n    gss_union_cred_t\tcred = NULL;\n\n    *pcred = NULL;\n\n    status = GSS_S_FAILURE;\n\n    cred = calloc(1, sizeof(*cred));\n    if (cred == NULL) {\n\t*minor_status = ENOMEM;\n\tgoto cleanup;\n    }\n\n    cred->loopback = cred;\n    cred->count = 1;\n\n    cred->cred_array = calloc(cred->count, sizeof(gss_cred_id_t));\n    if (cred->cred_array == NULL) {\n\t*minor_status = ENOMEM;\n\tgoto cleanup;\n    }\n    cred->cred_array[0] = mech_cred;\n\n    status = generic_gss_copy_oid(minor_status,\n                                  &mech->mech_type,\n                                  &cred->mechs_array);\n    if (status != GSS_S_COMPLETE)\n        goto cleanup;\n\n    status = GSS_S_COMPLETE;\n    *pcred = cred;\n\ncleanup:\n    if (status != GSS_S_COMPLETE)\n\tgss_release_cred(&temp_minor_status, (gss_cred_id_t *)&cred);\n\n    return status;\n}\n\n/*\n * This differs from gssspi_set_cred_option() as shipped in 1.7, in that\n * it can return a cred handle. To denote this change we have changed the\n * name of the function from gssspi_set_cred_option() to gss_set_cred_option().\n * However, the dlsym() entry point is still gssspi_set_cred_option(). This\n * fixes a separate issue, namely that a dynamically loaded mechanism could\n * not itself call set_cred_option() without calling its own implementation\n * instead of the mechanism glue's. (This is useful where a mechanism wishes\n * to export a mechanism-specific API that is a wrapper around this function.)\n */\nOM_uint32 KRB5_CALLCONV\ngss_set_cred_option(OM_uint32 *minor_status,\n\t            gss_cred_id_t *cred_handle,\n\t            const gss_OID desired_object,\n\t            const gss_buffer_t value)\n{\n    gss_union_cred_t\tunion_cred;\n    gss_mechanism\tmech;\n    int\t\t\ti;\n    OM_uint32\t\tstatus;\n    OM_uint32\t\tmech_status;\n    OM_uint32\t\tmech_minor_status;\n\n    if (minor_status == NULL)\n\treturn GSS_S_CALL_INACCESSIBLE_WRITE;\n    *minor_status = 0;\n\n    if (cred_handle == NULL)\n\treturn GSS_S_CALL_INACCESSIBLE_WRITE;\n\n    status = GSS_S_UNAVAILABLE;\n\n    if (*cred_handle == GSS_C_NO_CREDENTIAL) {\n\tgss_cred_id_t mech_cred = GSS_C_NO_CREDENTIAL;\n\n\t/*\n\t * We need to give a mechanism the opportunity to allocate a\n\t * credentials handle. Unfortunately this does mean that only\n\t * the default mechanism can allocate a credentials handle.\n\t */\n        mech = gssint_get_mechanism(NULL);\n        if (mech == NULL)\n            return GSS_S_BAD_MECH;\n\n\tif (mech->gssspi_set_cred_option == NULL)\n\t    return GSS_S_UNAVAILABLE;\n\n\tstatus = mech->gssspi_set_cred_option(minor_status,\n\t\t\t\t\t      &mech_cred,\n\t\t\t\t\t      desired_object,\n\t\t\t\t\t      value);\n\tif (status != GSS_S_COMPLETE) {\n\t    map_error(minor_status, mech);\n\t    return status;\n\t}\n\n\tif (mech_cred != GSS_C_NO_CREDENTIAL) {\n\t    status = alloc_union_cred(minor_status,\n\t\t\t\t      mech,\n\t\t\t\t      mech_cred,\n\t\t\t\t      &union_cred);\n\t    if (status != GSS_S_COMPLETE)\n\t\treturn status;\n\t    *cred_handle = (gss_cred_id_t)union_cred;\n\t}\n    } else {\n\tunion_cred = (gss_union_cred_t)*cred_handle;\n\n\tfor (i = 0; i < union_cred->count; i++) {\n\t    mech = gssint_get_mechanism(&union_cred->mechs_array[i]);\n\t    if (mech == NULL) {\n\t\tstatus = GSS_S_BAD_MECH;\n\t\tbreak;\n\t    }\n\n\t    if (mech->gssspi_set_cred_option == NULL)\n\t\tcontinue;\n\n\t    mech_status = mech->gssspi_set_cred_option(&mech_minor_status,\n\t\t\t\t\t\t       &union_cred->cred_array[i],\n\t\t\t\t\t\t       desired_object,\n\t\t\t\t\t\t       value);\n\t    if (mech_status == GSS_S_UNAVAILABLE)\n\t\tcontinue;\n\t    else {\n\t\tstatus = mech_status;\n\t\t*minor_status = mech_minor_status;\n\t    }\n\t    if (status != GSS_S_COMPLETE) {\n\t\tmap_error(minor_status, mech);\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    return status;\n}\n\n/*\n * Provide this for backward ABI compatibility, but remove it from the\n * header.\n */\nOM_uint32 KRB5_CALLCONV\ngssspi_set_cred_option(OM_uint32 *minor_status,\n\t               gss_cred_id_t cred,\n\t               const gss_OID desired_object,\n\t               const gss_buffer_t value);\n\nOM_uint32 KRB5_CALLCONV\ngssspi_set_cred_option(OM_uint32 *minor_status,\n\t               gss_cred_id_t cred,\n\t               const gss_OID desired_object,\n\t               const gss_buffer_t value)\n{\n    return gss_set_cred_option(minor_status, &cred,\n                               desired_object, value);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/lib/gssapi/mechglue/g_initialize.c": "/* #pragma ident\t\"@(#)g_initialize.c\t1.36\t05/02/02 SMI\" */\n\n/*\n * Copyright 1996 by Sun Microsystems, Inc.\n *\n * Permission to use, copy, modify, distribute, and sell this software\n * and its documentation for any purpose is hereby granted without fee,\n * provided that the above copyright notice appears in all copies and\n * that both that copyright notice and this permission notice appear in\n * supporting documentation, and that the name of Sun Microsystems not be used\n * in advertising or publicity pertaining to distribution of the software\n * without specific, written prior permission. Sun Microsystems makes no\n * representations about the suitability of this software for any\n * purpose.  It is provided \"as is\" without express or implied warranty.\n *\n * SUN MICROSYSTEMS DISCLAIMS ALL WARRANTIES WITH REGARD TO THIS SOFTWARE,\n * INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS, IN NO\n * EVENT SHALL SUN MICROSYSTEMS BE LIABLE FOR ANY SPECIAL, INDIRECT OR\n * CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF\n * USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\n * OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\n * PERFORMANCE OF THIS SOFTWARE.\n */\n\n/*\n * This function will initialize the gssapi mechglue library\n */\n\n#include \"mglueP.h\"\n#ifdef HAVE_STDLIB_H\n#include <stdlib.h>\n#endif\n#ifdef HAVE_SYS_STAT_H\n#include <sys/stat.h>\n#endif\n#ifdef HAVE_SYS_PARAM_H\n#include <sys/param.h>\n#endif\n\n#include <stdio.h>\n#include <string.h>\n#include <ctype.h>\n#include <errno.h>\n#ifndef _WIN32\n#include <glob.h>\n#endif\n\n#define\tM_DEFAULT\t\"default\"\n\n#include \"k5-thread.h\"\n#include \"k5-plugin.h\"\n#include \"osconf.h\"\n#ifdef _GSS_STATIC_LINK\n#include \"gssapiP_krb5.h\"\n#include \"gssapiP_spnego.h\"\n#endif\n\n#define MECH_SYM \"gss_mech_initialize\"\n#define MECH_INTERPOSER_SYM \"gss_mech_interposer\"\n\n#ifndef MECH_CONF\n#define\tMECH_CONF \"/etc/gss/mech\"\n#endif\n#define MECH_CONF_PATTERN MECH_CONF \".d/*.conf\"\n\n/* Local functions */\nstatic void addConfigEntry(const char *oidStr, const char *oid,\n\t\t\t   const char *sharedLib, const char *kernMod,\n\t\t\t   const char *modOptions, const char *modType);\nstatic gss_mech_info searchMechList(gss_const_OID);\nstatic void loadConfigFile(const char *);\n#if defined(_WIN32)\n#ifndef MECH_KEY\n#define MECH_KEY \"SOFTWARE\\\\gss\\\\mech\"\n#endif\nstatic time_t getRegKeyModTime(HKEY hBaseKey, const char *keyPath);\nstatic time_t getRegConfigModTime(const char *keyPath);\nstatic void getRegKeyValue(HKEY key, const char *keyPath, const char *valueName, void **data, DWORD *dataLen);\nstatic void loadConfigFromRegistry(HKEY keyBase, const char *keyPath);\n#endif\nstatic void updateMechList(void);\nstatic void initMechList(void);\nstatic void loadInterMech(gss_mech_info aMech);\nstatic void freeMechList(void);\n\nstatic OM_uint32 build_mechSet(void);\nstatic void free_mechSet(void);\n\n/*\n * list of mechanism libraries and their entry points.\n * the list also maintains state of the mech libraries (loaded or not).\n */\nstatic gss_mech_info g_mechList = NULL;\nstatic gss_mech_info g_mechListTail = NULL;\nstatic k5_mutex_t g_mechListLock = K5_MUTEX_PARTIAL_INITIALIZER;\nstatic time_t g_confFileModTime = (time_t)0;\nstatic time_t g_confLastCall = (time_t)0;\n\nstatic gss_OID_set_desc g_mechSet = { 0, NULL };\nstatic k5_mutex_t g_mechSetLock = K5_MUTEX_PARTIAL_INITIALIZER;\n\nMAKE_INIT_FUNCTION(gssint_mechglue_init);\nMAKE_FINI_FUNCTION(gssint_mechglue_fini);\n\nint\ngssint_mechglue_init(void)\n{\n\tint err;\n\n#ifdef SHOW_INITFINI_FUNCS\n\tprintf(\"gssint_mechglue_init\\n\");\n#endif\n\n\tadd_error_table(&et_ggss_error_table);\n\n\terr = k5_mutex_finish_init(&g_mechSetLock);\n\tif (err)\n\t\treturn err;\n\terr = k5_mutex_finish_init(&g_mechListLock);\n\tif (err)\n\t\treturn err;\n\n#ifdef _GSS_STATIC_LINK\n\terr = gss_krb5int_lib_init();\n\tif (err)\n\t\treturn err;\n\terr = gss_spnegoint_lib_init();\n\tif (err)\n\t\treturn err;\n#endif\n\n\terr = gssint_mecherrmap_init();\n\treturn err;\n}\n\nvoid\ngssint_mechglue_fini(void)\n{\n\tif (!INITIALIZER_RAN(gssint_mechglue_init) || PROGRAM_EXITING()) {\n#ifdef SHOW_INITFINI_FUNCS\n\t\tprintf(\"gssint_mechglue_fini: skipping\\n\");\n#endif\n\t\treturn;\n\t}\n\n#ifdef SHOW_INITFINI_FUNCS\n\tprintf(\"gssint_mechglue_fini\\n\");\n#endif\n#ifdef _GSS_STATIC_LINK\n\tgss_spnegoint_lib_fini();\n\tgss_krb5int_lib_fini();\n#endif\n\tk5_mutex_destroy(&g_mechSetLock);\n\tk5_mutex_destroy(&g_mechListLock);\n\tfree_mechSet();\n\tfreeMechList();\n\tremove_error_table(&et_ggss_error_table);\n\tgssint_mecherrmap_destroy();\n}\n\nint\ngssint_mechglue_initialize_library(void)\n{\n\treturn CALL_INIT_FUNCTION(gssint_mechglue_init);\n}\n\n/*\n * function used to reclaim the memory used by a gss_OID structure.\n * This routine requires direct access to the mechList.\n */\nOM_uint32 KRB5_CALLCONV\ngss_release_oid(minor_status, oid)\nOM_uint32 *minor_status;\ngss_OID *oid;\n{\n\tOM_uint32 major;\n\tgss_mech_info aMech;\n\n\tif (minor_status != NULL)\n\t    *minor_status = 0;\n\n\tif (minor_status == NULL || oid == NULL)\n\t\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n\t*minor_status = gssint_mechglue_initialize_library();\n\tif (*minor_status != 0)\n\t\treturn (GSS_S_FAILURE);\n\n\tk5_mutex_lock(&g_mechListLock);\n\taMech = g_mechList;\n\twhile (aMech != NULL) {\n\n\t\t/*\n\t\t * look through the loaded mechanism libraries for\n\t\t * gss_internal_release_oid until one returns success.\n\t\t * gss_internal_release_oid will only return success when\n\t\t * the OID was recognized as an internal mechanism OID. if no\n\t\t * mechanisms recognize the OID, then call the generic version.\n\t\t */\n\t\tif (aMech->mech && aMech->mech->gss_internal_release_oid) {\n\t\t\tmajor = aMech->mech->gss_internal_release_oid(\n\t\t\t\t\tminor_status, oid);\n\t\t\tif (major == GSS_S_COMPLETE) {\n\t\t\t\tk5_mutex_unlock(&g_mechListLock);\n\t\t\t\treturn (GSS_S_COMPLETE);\n\t\t\t}\n\t\t\tmap_error(minor_status, aMech->mech);\n\t\t}\n\t\taMech = aMech->next;\n\t} /* while */\n\tk5_mutex_unlock(&g_mechListLock);\n\n\treturn (generic_gss_release_oid(minor_status, oid));\n} /* gss_release_oid */\n\n/*\n * Wrapper around inquire_attrs_for_mech to determine whether a mechanism has\n * the deprecated attribute.  Must be called without g_mechSetLock since it\n * will call into the mechglue.\n */\nstatic int\nis_deprecated(gss_OID element)\n{\n\tOM_uint32 major, minor;\n\tgss_OID_set mech_attrs = GSS_C_NO_OID_SET;\n\tint deprecated = 0;\n\n\tmajor = gss_inquire_attrs_for_mech(&minor, element, &mech_attrs, NULL);\n\tif (major == GSS_S_COMPLETE) {\n\t\tgss_test_oid_set_member(&minor, (gss_OID)GSS_C_MA_DEPRECATED,\n\t\t\t\t\tmech_attrs, &deprecated);\n\t}\n\n\tif (mech_attrs != GSS_C_NO_OID_SET)\n\t\tgss_release_oid_set(&minor, &mech_attrs);\n\n\treturn deprecated;\n}\n\n/*\n * Removes mechs with the deprecated attribute from an OID set.  Must be\n * called without g_mechSetLock held since it calls into the mechglue.\n */\nstatic void\nprune_deprecated(gss_OID_set mech_set)\n{\n\tOM_uint32 i, j;\n\n\tj = 0;\n\tfor (i = 0; i < mech_set->count; i++) {\n\t    if (!is_deprecated(&mech_set->elements[i]))\n\t\tmech_set->elements[j++] = mech_set->elements[i];\n\t    else\n\t\tgssalloc_free(mech_set->elements[i].elements);\n\t}\n\tmech_set->count = j;\n}\n\n/*\n * this function will return an oid set indicating available mechanisms.\n * The set returned is based on configuration file entries and\n * NOT on the loaded mechanisms.  This function does not check if any\n * of these can actually be loaded.\n * Deprecated mechanisms will not be returned.\n * This routine needs direct access to the mechanism list.\n * To avoid reading the configuration file each call, we will save a\n * a mech oid set, and only update it once the file has changed.\n */\nOM_uint32 KRB5_CALLCONV\ngss_indicate_mechs(minorStatus, mechSet_out)\nOM_uint32 *minorStatus;\ngss_OID_set *mechSet_out;\n{\n\tOM_uint32 status;\n\n\t/* Initialize outputs. */\n\n\tif (minorStatus != NULL)\n\t\t*minorStatus = 0;\n\n\tif (mechSet_out != NULL)\n\t\t*mechSet_out = GSS_C_NO_OID_SET;\n\n\t/* Validate arguments. */\n\tif (minorStatus == NULL || mechSet_out == NULL)\n\t\treturn (GSS_S_CALL_INACCESSIBLE_WRITE);\n\n\t*minorStatus = gssint_mechglue_initialize_library();\n\tif (*minorStatus != 0)\n\t\treturn (GSS_S_FAILURE);\n\n\tif (build_mechSet())\n\t\treturn GSS_S_FAILURE;\n\n\t/*\n\t * need to lock the g_mechSet in case someone tries to update it while\n\t * I'm copying it.\n\t */\n\tk5_mutex_lock(&g_mechSetLock);\n\tstatus = generic_gss_copy_oid_set(minorStatus, &g_mechSet, mechSet_out);\n\tk5_mutex_unlock(&g_mechSetLock);\n\n\tif (*mechSet_out != GSS_C_NO_OID_SET)\n\t\tprune_deprecated(*mechSet_out);\n\n\treturn (status);\n} /* gss_indicate_mechs */\n\n\n/* Call with g_mechSetLock held, or during final cleanup.  */\nstatic void\nfree_mechSet(void)\n{\n\tunsigned int i;\n\n\tif (g_mechSet.count != 0) {\n\t\tfor (i = 0; i < g_mechSet.count; i++)\n\t\t\tfree(g_mechSet.elements[i].elements);\n\t\tfree(g_mechSet.elements);\n\t\tg_mechSet.elements = NULL;\n\t\tg_mechSet.count = 0;\n\t}\n}\n\nstatic OM_uint32\nbuild_mechSet(void)\n{\n\tgss_mech_info mList;\n\tsize_t i;\n\tsize_t count;\n\tgss_OID curItem;\n\n\t/*\n\t * lock the mutex since we will be updating\n\t * the mechList structure\n\t * we need to keep the lock while we build the mechanism list\n\t * since we are accessing parts of the mechList which could be\n\t * modified.\n\t */\n\tk5_mutex_lock(&g_mechListLock);\n\n\tupdateMechList();\n\n\t/*\n\t * we need to lock the mech set so that no one else will\n\t * try to read it as we are re-creating it\n\t */\n\tk5_mutex_lock(&g_mechSetLock);\n\n\t/* if the oid list already exists we must free it first */\n\tfree_mechSet();\n\n\t/* determine how many elements to have in the list */\n\tmList = g_mechList;\n\tcount = 0;\n\twhile (mList != NULL) {\n\t\tcount++;\n\t\tmList = mList->next;\n\t}\n\n\t/* this should always be true, but.... */\n\tif (count > 0) {\n\t\tg_mechSet.elements =\n\t\t\t(gss_OID) calloc(count, sizeof (gss_OID_desc));\n\t\tif (g_mechSet.elements == NULL) {\n\t\t\tk5_mutex_unlock(&g_mechSetLock);\n\t\t\tk5_mutex_unlock(&g_mechListLock);\n\t\t\treturn (GSS_S_FAILURE);\n\t\t}\n\n\t\t(void) memset(g_mechSet.elements, 0,\n\t\t\t      count * sizeof (gss_OID_desc));\n\n\t\t/* now copy each oid element */\n\t\tcount = 0;\n\t\tfor (mList = g_mechList; mList != NULL; mList = mList->next) {\n\t\t\t/* Don't expose interposer mechanisms. */\n\t\t\tif (mList->is_interposer)\n\t\t\t\tcontinue;\n\t\t\tcurItem = &(g_mechSet.elements[count]);\n\t\t\tcurItem->elements = (void*)\n\t\t\t\tmalloc(mList->mech_type->length);\n\t\t\tif (curItem->elements == NULL) {\n\t\t\t\t/*\n\t\t\t\t * this is nasty - we must delete the\n\t\t\t\t * part of the array already copied\n\t\t\t\t */\n\t\t\t\tfor (i = 0; i < count; i++) {\n\t\t\t\t\tfree(g_mechSet.elements[i].\n\t\t\t\t\t     elements);\n\t\t\t\t}\n\t\t\t\tfree(g_mechSet.elements);\n\t\t\t\tg_mechSet.count = 0;\n\t\t\t\tg_mechSet.elements = NULL;\n\t\t\t\tk5_mutex_unlock(&g_mechSetLock);\n\t\t\t\tk5_mutex_unlock(&g_mechListLock);\n\t\t\t\treturn (GSS_S_FAILURE);\n\t\t\t}\n\t\t\tg_OID_copy(curItem, mList->mech_type);\n\t\t\tcount++;\n\t\t}\n\t\tg_mechSet.count = count;\n\t}\n\n\tk5_mutex_unlock(&g_mechSetLock);\n\tk5_mutex_unlock(&g_mechListLock);\n\n\treturn GSS_S_COMPLETE;\n}\n\n\n/*\n * this function has been added for use by modules that need to\n * know what (if any) optional parameters are supplied in the\n * config file (MECH_CONF).\n * It will return the option string for a specified mechanism.\n * caller is responsible for freeing the memory\n */\nchar *\ngssint_get_modOptions(oid)\nconst gss_OID oid;\n{\n\tgss_mech_info aMech;\n\tchar *modOptions = NULL;\n\n\tif (gssint_mechglue_initialize_library() != 0)\n\t\treturn (NULL);\n\n\t/* make sure we have fresh data */\n\tk5_mutex_lock(&g_mechListLock);\n\tupdateMechList();\n\n\tif ((aMech = searchMechList(oid)) == NULL ||\n\t\taMech->optionStr == NULL) {\n\t\tk5_mutex_unlock(&g_mechListLock);\n\t\treturn (NULL);\n\t}\n\n\tif (aMech->optionStr)\n\t\tmodOptions = strdup(aMech->optionStr);\n\tk5_mutex_unlock(&g_mechListLock);\n\n\treturn (modOptions);\n} /* gssint_get_modOptions */\n\n/* Return the mtime of filename or its eventual symlink target (if it is a\n * symlink), whichever is larger.  Return (time_t)-1 if lstat or stat fails. */\nstatic time_t\ncheck_link_mtime(const char *filename, time_t *mtime_out)\n{\n\tstruct stat st1, st2;\n\n\tif (lstat(filename, &st1) != 0)\n\t\treturn (time_t)-1;\n\tif (!S_ISLNK(st1.st_mode))\n\t\treturn st1.st_mtime;\n\tif (stat(filename, &st2) != 0)\n\t\treturn (time_t)-1;\n\treturn (st1.st_mtime > st2.st_mtime) ? st1.st_mtime : st2.st_mtime;\n}\n\n/* Load pathname if it is newer than last.  Update *highest to the maximum of\n * its current value and pathname's mod time. */\nstatic void\nload_if_changed(const char *pathname, time_t last, time_t *highest)\n{\n\ttime_t mtime;\n\n\tmtime = check_link_mtime(pathname, &mtime);\n\tif (mtime == (time_t)-1)\n\t\treturn;\n\tif (mtime > *highest)\n\t\t*highest = mtime;\n\tif (mtime > last)\n\t\tloadConfigFile(pathname);\n}\n\n#ifndef _WIN32\n/* Try to load any config files which have changed since the last call.  Config\n * files are MECH_CONF and any files matching MECH_CONF_PATTERN. */\nstatic void\nloadConfigFiles()\n{\n\tglob_t globbuf;\n\ttime_t highest = 0, now;\n\tchar **path;\n\tconst char *val;\n\n\t/* Don't glob and stat more than once per second. */\n\tif (time(&now) == (time_t)-1 || now == g_confLastCall)\n\t\treturn;\n\tg_confLastCall = now;\n\n\tval = secure_getenv(\"GSS_MECH_CONFIG\");\n\tif (val != NULL) {\n\t\tload_if_changed(val, g_confFileModTime, &g_confFileModTime);\n\t\treturn;\n\t}\n\n\tload_if_changed(MECH_CONF, g_confFileModTime, &highest);\n\n\tmemset(&globbuf, 0, sizeof(globbuf));\n\tif (glob(MECH_CONF_PATTERN, 0, NULL, &globbuf) == 0) {\n\t\tfor (path = globbuf.gl_pathv; *path != NULL; path++)\n\t\t\tload_if_changed(*path, g_confFileModTime, &highest);\n\t}\n\tglobfree(&globbuf);\n\n\tg_confFileModTime = highest;\n}\n#endif\n\n/*\n * determines if the mechList needs to be updated from file\n * and performs the update.\n * this functions must be called with a lock of g_mechListLock\n */\nstatic void\nupdateMechList(void)\n{\n\tgss_mech_info minfo;\n\n#if defined(_WIN32)\n\ttime_t lastConfModTime = getRegConfigModTime(MECH_KEY);\n\tif (g_confFileModTime >= lastConfModTime)\n\t\treturn;\n\tg_confFileModTime = lastConfModTime;\n\tloadConfigFromRegistry(HKEY_CURRENT_USER, MECH_KEY);\n\tloadConfigFromRegistry(HKEY_LOCAL_MACHINE, MECH_KEY);\n#else /* _WIN32 */\n\tloadConfigFiles();\n#endif /* !_WIN32 */\n\n\t/* Load any unloaded interposer mechanisms immediately, to make sure we\n\t * interpose other mechanisms before they are used. */\n\tfor (minfo = g_mechList; minfo != NULL; minfo = minfo->next) {\n\t\tif (minfo->is_interposer && minfo->mech == NULL)\n\t\t\tloadInterMech(minfo);\n\t}\n} /* updateMechList */\n\n/* Update the mech list from system configuration if we have never done so.\n * Must be invoked with the g_mechListLock mutex held. */\nstatic void\ninitMechList(void)\n{\n\tstatic int lazy_init = 0;\n\n\tif (lazy_init == 0) {\n\t\tupdateMechList();\n\t\tlazy_init = 1;\n\t}\n}\n\nstatic void\nreleaseMechInfo(gss_mech_info *pCf)\n{\n\tgss_mech_info cf;\n\tOM_uint32 minor_status;\n\n\tif (*pCf == NULL) {\n\t\treturn;\n\t}\n\n\tcf = *pCf;\n\n\tif (cf->kmodName != NULL)\n\t\tfree(cf->kmodName);\n\tif (cf->uLibName != NULL)\n\t\tfree(cf->uLibName);\n\tif (cf->mechNameStr != NULL)\n\t\tfree(cf->mechNameStr);\n\tif (cf->optionStr != NULL)\n\t\tfree(cf->optionStr);\n\tif (cf->mech_type != GSS_C_NO_OID &&\n\t    cf->mech_type != &cf->mech->mech_type)\n\t\tgeneric_gss_release_oid(&minor_status, &cf->mech_type);\n\tif (cf->freeMech)\n\t\tzapfree(cf->mech, sizeof(*cf->mech));\n\tif (cf->dl_handle != NULL)\n\t\tkrb5int_close_plugin(cf->dl_handle);\n\tif (cf->int_mech_type != GSS_C_NO_OID)\n\t\tgeneric_gss_release_oid(&minor_status, &cf->int_mech_type);\n\n\tmemset(cf, 0, sizeof(*cf));\n\tfree(cf);\n\n\t*pCf = NULL;\n}\n\n#ifdef _GSS_STATIC_LINK\n/*\n * Register a mechanism.  Called with g_mechListLock held.\n */\nint\ngssint_register_mechinfo(gss_mech_info template)\n{\n\tgss_mech_info cf, new_cf;\n\n\tnew_cf = calloc(1, sizeof(*new_cf));\n\tif (new_cf == NULL) {\n\t\treturn ENOMEM;\n\t}\n\n\tnew_cf->dl_handle = template->dl_handle;\n\t/* copy mech so we can rewrite canonical mechanism OID */\n\tnew_cf->mech = (gss_mechanism)calloc(1, sizeof(struct gss_config));\n\tif (new_cf->mech == NULL) {\n\t\treleaseMechInfo(&new_cf);\n\t\treturn ENOMEM;\n\t}\n\t*new_cf->mech = *template->mech;\n\tif (template->mech_type != NULL)\n\t\tnew_cf->mech->mech_type = *(template->mech_type);\n\tnew_cf->mech_type = &new_cf->mech->mech_type;\n\tnew_cf->priority = template->priority;\n\tnew_cf->freeMech = 1;\n\tnew_cf->next = NULL;\n\n\tif (template->kmodName != NULL) {\n\t\tnew_cf->kmodName = strdup(template->kmodName);\n\t\tif (new_cf->kmodName == NULL) {\n\t\t\treleaseMechInfo(&new_cf);\n\t\t\treturn ENOMEM;\n\t\t}\n\t}\n\tif (template->uLibName != NULL) {\n\t\tnew_cf->uLibName = strdup(template->uLibName);\n\t\tif (new_cf->uLibName == NULL) {\n\t\t\treleaseMechInfo(&new_cf);\n\t\t\treturn ENOMEM;\n\t\t}\n\t}\n\tif (template->mechNameStr != NULL) {\n\t\tnew_cf->mechNameStr = strdup(template->mechNameStr);\n\t\tif (new_cf->mechNameStr == NULL) {\n\t\t\treleaseMechInfo(&new_cf);\n\t\t\treturn ENOMEM;\n\t\t}\n\t}\n\tif (template->optionStr != NULL) {\n\t\tnew_cf->optionStr = strdup(template->optionStr);\n\t\tif (new_cf->optionStr == NULL) {\n\t\t\treleaseMechInfo(&new_cf);\n\t\t\treturn ENOMEM;\n\t\t}\n\t}\n\tif (g_mechList == NULL) {\n\t\tg_mechList = new_cf;\n\t\tg_mechListTail = new_cf;\n\t\treturn 0;\n\t} else if (new_cf->priority < g_mechList->priority) {\n\t\tnew_cf->next = g_mechList;\n\t\tg_mechList = new_cf;\n\t\treturn 0;\n\t}\n\n\tfor (cf = g_mechList; cf != NULL; cf = cf->next) {\n\t\tif (cf->next == NULL ||\n\t\t    new_cf->priority < cf->next->priority) {\n\t\t\tnew_cf->next = cf->next;\n\t\t\tcf->next = new_cf;\n\t\t\tif (g_mechListTail == cf) {\n\t\t\t\tg_mechListTail = new_cf;\n\t\t\t}\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn 0;\n}\n#endif /* _GSS_STATIC_LINK */\n\n#define GSS_ADD_DYNAMIC_METHOD(_dl, _mech, _symbol) \\\n\tdo { \\\n\t\tstruct errinfo errinfo; \\\n\t\t\\\n\t\tmemset(&errinfo, 0, sizeof(errinfo)); \\\n\t\tif (krb5int_get_plugin_func(_dl, \\\n\t\t\t\t\t    #_symbol, \\\n\t\t\t\t\t    (void (**)())&(_mech)->_symbol, \\\n\t\t\t\t\t    &errinfo) || errinfo.code) {  \\\n\t\t\t(_mech)->_symbol = NULL; \\\n\t\t\tk5_clear_error(&errinfo); \\\n\t\t\t} \\\n\t} while (0)\n\n/*\n * If _symbol is undefined in the shared object but the shared object\n * is linked against the mechanism glue, it's possible for dlsym() to\n * return the mechanism glue implementation. Guard against that.\n */\n#define GSS_ADD_DYNAMIC_METHOD_NOLOOP(_dl, _mech, _symbol)\t\\\n\tdo {\t\t\t\t\t\t\t\\\n\t\tGSS_ADD_DYNAMIC_METHOD(_dl, _mech, _symbol);\t\\\n\t\tif ((_mech)->_symbol == _symbol)\t\t\\\n\t\t    (_mech)->_symbol = NULL;\t\t\t\\\n\t} while (0)\n\nstatic gss_mechanism\nbuild_dynamicMech(void *dl, const gss_OID mech_type)\n{\n\tgss_mechanism mech;\n\n\tmech = (gss_mechanism)calloc(1, sizeof(*mech));\n\tif (mech == NULL) {\n\t\treturn NULL;\n\t}\n\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_acquire_cred);\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_release_cred);\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_init_sec_context);\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_accept_sec_context);\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_process_context_token);\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_delete_sec_context);\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_context_time);\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_get_mic);\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_verify_mic);\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_wrap);\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_unwrap);\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_display_status);\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_indicate_mechs);\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_compare_name);\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_display_name);\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_import_name);\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_release_name);\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_inquire_cred);\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_add_cred);\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_export_sec_context);\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_import_sec_context);\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_inquire_cred_by_mech);\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_inquire_names_for_mech);\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_inquire_context);\n\tGSS_ADD_DYNAMIC_METHOD(dl, mech, gss_internal_release_oid);\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_wrap_size_limit);\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_localname);\n\tGSS_ADD_DYNAMIC_METHOD(dl, mech, gssspi_authorize_localname);\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_export_name);\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_duplicate_name);\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_store_cred);\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_inquire_sec_context_by_oid);\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_inquire_cred_by_oid);\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_set_sec_context_option);\n\tGSS_ADD_DYNAMIC_METHOD(dl, mech, gssspi_set_cred_option);\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gssspi_mech_invoke);\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_wrap_aead);\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_unwrap_aead);\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_wrap_iov);\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_unwrap_iov);\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_wrap_iov_length);\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_complete_auth_token);\n\t/* Services4User (introduced in 1.8) */\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_acquire_cred_impersonate_name);\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_add_cred_impersonate_name);\n\t/* Naming extensions (introduced in 1.8) */\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_display_name_ext);\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_inquire_name);\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_get_name_attribute);\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_set_name_attribute);\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_delete_name_attribute);\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_export_name_composite);\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_map_name_to_any);\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_release_any_name_mapping);\n        /* RFC 4401 (introduced in 1.8) */\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_pseudo_random);\n\t/* RFC 4178 (introduced in 1.8; gss_get_neg_mechs not implemented) */\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_set_neg_mechs);\n        /* draft-ietf-sasl-gs2 */\n        GSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_inquire_saslname_for_mech);\n        GSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_inquire_mech_for_saslname);\n        /* RFC 5587 */\n        GSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_inquire_attrs_for_mech);\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_acquire_cred_from);\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_store_cred_into);\n\tGSS_ADD_DYNAMIC_METHOD(dl, mech, gssspi_acquire_cred_with_password);\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_export_cred);\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gss_import_cred);\n\tGSS_ADD_DYNAMIC_METHOD(dl, mech, gssspi_import_sec_context_by_mech);\n\tGSS_ADD_DYNAMIC_METHOD(dl, mech, gssspi_import_name_by_mech);\n\tGSS_ADD_DYNAMIC_METHOD(dl, mech, gssspi_import_cred_by_mech);\n\t/* draft-zhu-negoex */\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gssspi_query_meta_data);\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gssspi_exchange_meta_data);\n\tGSS_ADD_DYNAMIC_METHOD_NOLOOP(dl, mech, gssspi_query_mechanism_info);\n\n\tassert(mech_type != GSS_C_NO_OID);\n\n\tmech->mech_type = *(mech_type);\n\n\treturn mech;\n}\n\n#define RESOLVE_GSSI_SYMBOL(_dl, _mech, _psym, _nsym)\t\t\t\\\n\tdo {\t\t\t\t\t\t\t\t\\\n\t\tstruct errinfo errinfo;\t\t\t\t\t\\\n\t\tmemset(&errinfo, 0, sizeof(errinfo));\t\t\t\\\n\t\tif (krb5int_get_plugin_func(_dl,\t\t\t\\\n\t\t\t\t\t    \"gssi\" #_nsym,\t\t\\\n\t\t\t\t\t    (void (**)())&(_mech)->_psym \\\n\t\t\t\t\t    ## _nsym,\t\t\t\\\n\t\t\t\t\t    &errinfo) || errinfo.code) { \\\n\t\t\t(_mech)->_psym ## _nsym = NULL;\t\t\t\\\n\t\t\tk5_clear_error(&errinfo);\t\t\t\\\n\t\t}\t\t\t\t\t\t\t\\\n\t} while (0)\n\n/* Build an interposer mechanism function table from dl. */\nstatic gss_mechanism\nbuild_interMech(void *dl, const gss_OID mech_type)\n{\n\tgss_mechanism mech;\n\n\tmech = calloc(1, sizeof(*mech));\n\tif (mech == NULL) {\n\t\treturn NULL;\n\t}\n\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _acquire_cred);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _release_cred);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _init_sec_context);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _accept_sec_context);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _process_context_token);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _delete_sec_context);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _context_time);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _get_mic);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _verify_mic);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _wrap);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _unwrap);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _display_status);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _indicate_mechs);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _compare_name);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _display_name);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _import_name);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _release_name);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _inquire_cred);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _add_cred);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _export_sec_context);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _import_sec_context);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _inquire_cred_by_mech);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _inquire_names_for_mech);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _inquire_context);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _internal_release_oid);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _wrap_size_limit);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _localname);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gssspi, _authorize_localname);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _export_name);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _duplicate_name);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _store_cred);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _inquire_sec_context_by_oid);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _inquire_cred_by_oid);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _set_sec_context_option);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gssspi, _set_cred_option);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gssspi, _mech_invoke);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _wrap_aead);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _unwrap_aead);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _wrap_iov);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _unwrap_iov);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _wrap_iov_length);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _complete_auth_token);\n\t/* Services4User (introduced in 1.8) */\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _acquire_cred_impersonate_name);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _add_cred_impersonate_name);\n\t/* Naming extensions (introduced in 1.8) */\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _display_name_ext);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _inquire_name);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _get_name_attribute);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _set_name_attribute);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _delete_name_attribute);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _export_name_composite);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _map_name_to_any);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _release_any_name_mapping);\n\t/* RFC 4401 (introduced in 1.8) */\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _pseudo_random);\n\t/* RFC 4178 (introduced in 1.8; get_neg_mechs not implemented) */\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _set_neg_mechs);\n\t/* draft-ietf-sasl-gs2 */\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _inquire_saslname_for_mech);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _inquire_mech_for_saslname);\n\t/* RFC 5587 */\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _inquire_attrs_for_mech);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _acquire_cred_from);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _store_cred_into);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gssspi, _acquire_cred_with_password);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _export_cred);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gss, _import_cred);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gssspi, _import_sec_context_by_mech);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gssspi, _import_name_by_mech);\n\tRESOLVE_GSSI_SYMBOL(dl, mech, gssspi, _import_cred_by_mech);\n\n\tmech->mech_type = *mech_type;\n\treturn mech;\n}\n\n/*\n * Concatenate an interposer mech OID and a real mech OID to create an\n * identifier for the interposed mech.  (The concatenation will not be a valid\n * DER OID encoding, but the OID is only used internally.)\n */\nstatic gss_OID\ninterposed_oid(gss_OID pre, gss_OID real)\n{\n\tgss_OID o;\n\n\to = (gss_OID)malloc(sizeof(gss_OID_desc));\n\tif (!o)\n\t\treturn NULL;\n\n\to->length = pre->length + real->length;\n\to->elements = malloc(o->length);\n\tif (!o->elements) {\n\t\tfree(o);\n\t\treturn NULL;\n\t}\n\n\tmemcpy(o->elements, pre->elements, pre->length);\n\tmemcpy((char *)o->elements + pre->length, real->elements,\n\t       real->length);\n\n\treturn o;\n}\n\nstatic void\nloadInterMech(gss_mech_info minfo)\n{\n\tstruct plugin_file_handle *dl = NULL;\n\tstruct errinfo errinfo;\n\tgss_OID_set (*isym)(const gss_OID);\n\tgss_OID_set list;\n\tgss_OID oid;\n\tOM_uint32 min;\n\tgss_mech_info mi;\n\tsize_t i;\n\n\tmemset(&errinfo, 0, sizeof(errinfo));\n\n\tif (krb5int_open_plugin(minfo->uLibName, &dl, &errinfo) != 0 ||\n\t    errinfo.code != 0) {\n\t\treturn;\n\t}\n\n\tif (krb5int_get_plugin_func(dl, MECH_INTERPOSER_SYM,\n\t\t\t\t    (void (**)())&isym, &errinfo) != 0)\n\t\tgoto cleanup;\n\n\t/* Get a list of mechs to interpose. */\n\tlist = (*isym)(minfo->mech_type);\n\tif (!list)\n\t\tgoto cleanup;\n\tminfo->mech = build_interMech(dl, minfo->mech_type);\n\tif (minfo->mech == NULL)\n\t\tgoto cleanup;\n\tminfo->freeMech = 1;\n\n\t/* Add interposer fields for each interposed mech. */\n\tfor (i = 0; i < list->count; i++) {\n\t\t/* Skip this mech if it doesn't exist or is already\n\t\t * interposed. */\n\t\toid = &list->elements[i];\n\t\tmi = searchMechList(oid);\n\t\tif (mi == NULL || mi->int_mech_type != NULL)\n\t\t\tcontinue;\n\n\t\t/* Construct a special OID to represent the interposed mech. */\n\t\tmi->int_mech_type = interposed_oid(minfo->mech_type, oid);\n\t\tif (mi->int_mech_type == NULL)\n\t\t\tcontinue;\n\n\t\t/* Save an alias to the interposer's function table. */\n\t\tmi->int_mech = minfo->mech;\n\t}\n\t(void)gss_release_oid_set(&min, &list);\n\n\tminfo->dl_handle = dl;\n\tdl = NULL;\n\ncleanup:\n\tif (dl != NULL)\n\t\tkrb5int_close_plugin(dl);\n\tk5_clear_error(&errinfo);\n}\n\nstatic void\nfreeMechList(void)\n{\n\tgss_mech_info cf, next_cf;\n\n\tfor (cf = g_mechList; cf != NULL; cf = next_cf) {\n\t\tnext_cf = cf->next;\n\t\treleaseMechInfo(&cf);\n\t}\n}\n\n/*\n * Determine the mechanism to use for a caller-specified mech OID.  For the\n * real mech OID of an interposed mech, return the interposed OID.  For an\n * interposed mech OID (which an interposer mech uses when re-entering the\n * mechglue), return the real mech OID.  The returned OID is an alias and\n * should not be modified or freed.\n */\nOM_uint32\ngssint_select_mech_type(OM_uint32 *minor, gss_const_OID oid,\n\t\t\tgss_OID *selected_oid)\n{\n\tgss_mech_info minfo;\n\tOM_uint32 status;\n\n\t*selected_oid = GSS_C_NO_OID;\n\n\tif (gssint_mechglue_initialize_library() != 0)\n\t\treturn GSS_S_FAILURE;\n\n\tk5_mutex_lock(&g_mechListLock);\n\n\t/* Read conf file at least once so that interposer plugins have a\n\t * chance of getting initialized. */\n\tinitMechList();\n\n\tminfo = g_mechList;\n\tif (oid == GSS_C_NULL_OID)\n\t\toid = minfo->mech_type;\n\twhile (minfo != NULL) {\n\t\tif (g_OID_equal(minfo->mech_type, oid)) {\n\t\t\tif (minfo->int_mech_type != GSS_C_NO_OID)\n\t\t\t\t*selected_oid = minfo->int_mech_type;\n\t\t\telse\n\t\t\t\t*selected_oid = minfo->mech_type;\n\t\t\tstatus = GSS_S_COMPLETE;\n\t\t\tgoto done;\n\t\t} else if ((minfo->int_mech_type != GSS_C_NO_OID) &&\n\t\t\t   (g_OID_equal(minfo->int_mech_type, oid))) {\n\t\t\t*selected_oid = minfo->mech_type;\n\t\t\tstatus = GSS_S_COMPLETE;\n\t\t\tgoto done;\n\t\t}\n\t\tminfo = minfo->next;\n\t}\n\tstatus = GSS_S_BAD_MECH;\n\ndone:\n\tk5_mutex_unlock(&g_mechListLock);\n\treturn status;\n}\n\n/* If oid is an interposed OID, return the corresponding real mech OID.  If\n * it's a real mech OID, return it unmodified.  Otherwised return null. */\ngss_OID\ngssint_get_public_oid(gss_const_OID oid)\n{\n\tgss_mech_info minfo;\n\tgss_OID public_oid = GSS_C_NO_OID;\n\n\t/* if oid is null -> then get default which is the first in the list */\n\tif (oid == GSS_C_NO_OID)\n\t\treturn GSS_C_NO_OID;\n\n\tif (gssint_mechglue_initialize_library() != 0)\n\t\treturn GSS_C_NO_OID;\n\n\tk5_mutex_lock(&g_mechListLock);\n\n\tfor (minfo = g_mechList; minfo != NULL; minfo = minfo->next) {\n\t\tif (minfo->is_interposer)\n\t\t\tcontinue;\n\t\tif (g_OID_equal(minfo->mech_type, oid) ||\n\t\t    ((minfo->int_mech_type != GSS_C_NO_OID) &&\n\t\t     (g_OID_equal(minfo->int_mech_type, oid)))) {\n\t\t\tpublic_oid = minfo->mech_type;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tk5_mutex_unlock(&g_mechListLock);\n\treturn public_oid;\n}\n\n/* Translate a vector of oids (as from a union cred struct) into a set of\n * public OIDs using gssint_get_public_oid. */\nOM_uint32\ngssint_make_public_oid_set(OM_uint32 *minor_status, gss_OID oids, int count,\n\t\t\t   gss_OID_set *public_set)\n{\n\tOM_uint32 status, tmpmin;\n\tgss_OID_set set;\n\tgss_OID public_oid;\n\tint i;\n\n\t*public_set = GSS_C_NO_OID_SET;\n\n\tstatus = generic_gss_create_empty_oid_set(minor_status, &set);\n\tif (GSS_ERROR(status))\n\t\treturn status;\n\n\tfor (i = 0; i < count; i++) {\n\t\tpublic_oid = gssint_get_public_oid(&oids[i]);\n\t\tif (public_oid == GSS_C_NO_OID)\n\t\t\tcontinue;\n\t\tstatus = generic_gss_add_oid_set_member(minor_status,\n\t\t\t\t\t\t\tpublic_oid, &set);\n\t\tif (GSS_ERROR(status)) {\n\t\t\t(void) generic_gss_release_oid_set(&tmpmin, &set);\n\t\t\treturn status;\n\t\t}\n\t}\n\n\t*public_set = set;\n\treturn GSS_S_COMPLETE;\n}\n\n/*\n * Register a mechanism.  Called with g_mechListLock held.\n */\n\n/*\n * given the mechanism type, return the mechanism structure\n * containing the mechanism library entry points.\n * will return NULL if mech type is not found\n * This function will also trigger the loading of the mechanism\n * module if it has not been already loaded.\n */\ngss_mechanism\ngssint_get_mechanism(gss_const_OID oid)\n{\n\tgss_mech_info aMech;\n\tgss_mechanism (*sym)(const gss_OID);\n\tstruct plugin_file_handle *dl;\n\tstruct errinfo errinfo;\n\n\tif (gssint_mechglue_initialize_library() != 0)\n\t\treturn (NULL);\n\n\tk5_mutex_lock(&g_mechListLock);\n\n\t/* Check if the mechanism is already loaded. */\n\taMech = g_mechList;\n\tif (oid == GSS_C_NULL_OID)\n\t\toid = aMech->mech_type;\n\twhile (aMech != NULL) {\n\t\tif (g_OID_equal(aMech->mech_type, oid) && aMech->mech) {\n\t\t\tk5_mutex_unlock(&g_mechListLock);\n\t\t\treturn aMech->mech;\n\t\t} else if (aMech->int_mech_type != GSS_C_NO_OID &&\n\t\t\t   g_OID_equal(aMech->int_mech_type, oid)) {\n\t\t\tk5_mutex_unlock(&g_mechListLock);\n\t\t\treturn aMech->int_mech;\n\t\t}\n\t\taMech = aMech->next;\n\t}\n\n\t/*\n\t * might need to re-read the configuration file before loading\n\t * the mechanism to ensure we have the latest info.\n\t */\n\tupdateMechList();\n\n\taMech = searchMechList(oid);\n\n\t/* is the mechanism present in the list ? */\n\tif (aMech == NULL) {\n\t\tk5_mutex_unlock(&g_mechListLock);\n\t\treturn ((gss_mechanism)NULL);\n\t}\n\n\t/* has another thread loaded the mech */\n\tif (aMech->mech) {\n\t\tk5_mutex_unlock(&g_mechListLock);\n\t\treturn (aMech->mech);\n\t}\n\n\tmemset(&errinfo, 0, sizeof(errinfo));\n\n\tif (krb5int_open_plugin(aMech->uLibName, &dl, &errinfo) != 0 ||\n\t    errinfo.code != 0) {\n\t\tk5_clear_error(&errinfo);\n\t\tk5_mutex_unlock(&g_mechListLock);\n\t\treturn ((gss_mechanism)NULL);\n\t}\n\n\tif (krb5int_get_plugin_func(dl, MECH_SYM, (void (**)())&sym,\n\t\t\t\t    &errinfo) == 0) {\n\t\t/* Call the symbol to get the mechanism table */\n\t\taMech->mech = (*sym)(aMech->mech_type);\n\t} else {\n\t\t/* Try dynamic dispatch table */\n\t\tk5_clear_error(&errinfo);\n\t\taMech->mech = build_dynamicMech(dl, aMech->mech_type);\n\t\taMech->freeMech = 1;\n\t}\n\tif (aMech->mech == NULL) {\n\t\t(void) krb5int_close_plugin(dl);\n\t\tk5_mutex_unlock(&g_mechListLock);\n\t\treturn ((gss_mechanism)NULL);\n\t}\n\n\taMech->dl_handle = dl;\n\n\tk5_mutex_unlock(&g_mechListLock);\n\treturn (aMech->mech);\n} /* gssint_get_mechanism */\n\n/*\n * this routine is used for searching the list of mechanism data.\n *\n * this needs to be called with g_mechListLock held.\n */\nstatic gss_mech_info searchMechList(gss_const_OID oid)\n{\n\tgss_mech_info aMech = g_mechList;\n\n\t/* if oid is null -> then get default which is the first in the list */\n\tif (oid == GSS_C_NULL_OID)\n\t\treturn (aMech);\n\n\twhile (aMech != NULL) {\n\t\tif (g_OID_equal(aMech->mech_type, oid))\n\t\t\treturn (aMech);\n\t\taMech = aMech->next;\n\t}\n\n\t/* none found */\n\treturn ((gss_mech_info) NULL);\n} /* searchMechList */\n\n/* Return the first non-whitespace character starting from str. */\nstatic char *\nskip_whitespace(char *str)\n{\n\twhile (isspace(*str))\n\t\tstr++;\n\treturn str;\n}\n\n/* Truncate str at the first whitespace character and return the first\n * non-whitespace character after that point. */\nstatic char *\ndelimit_ws(char *str)\n{\n\twhile (*str != '\\0' && !isspace(*str))\n\t\tstr++;\n\tif (*str != '\\0')\n\t\t*str++ = '\\0';\n\treturn skip_whitespace(str);\n}\n\n/* Truncate str at the first occurrence of delimiter and return the first\n * non-whitespace character after that point. */\nstatic char *\ndelimit(char *str, char delimiter)\n{\n\twhile (*str != '\\0' && *str != delimiter)\n\t\tstr++;\n\tif (*str != '\\0')\n\t\t*str++ = '\\0';\n\treturn skip_whitespace(str);\n}\n\n/*\n * loads the configuration file\n * this is called while having a mutex lock on the mechanism list\n * entries for libraries that have been loaded can't be modified\n * mechNameStr and mech_type fields are not updated during updates\n */\nstatic void\nloadConfigFile(const char *fileName)\n{\n\tchar *sharedLib, *kernMod, *modOptions, *modType, *oid, *next;\n\tchar buffer[BUFSIZ], *oidStr;\n\tFILE *confFile;\n\n\tif ((confFile = fopen(fileName, \"r\")) == NULL) {\n\t\treturn;\n\t}\n\n\t(void) memset(buffer, 0, sizeof (buffer));\n\twhile (fgets(buffer, BUFSIZ, confFile) != NULL) {\n\n\t\t/* ignore lines beginning with # */\n\t\tif (*buffer == '#')\n\t\t\tcontinue;\n\n\t\t/* Parse out the name, oid, and shared library path. */\n\t\toidStr = buffer;\n\t\toid = delimit_ws(oidStr);\n\t\tif (*oid == '\\0')\n\t\t\tcontinue;\n\t\tsharedLib = delimit_ws(oid);\n\t\tif (*sharedLib == '\\0')\n\t\t\tcontinue;\n\t\tnext = delimit_ws(sharedLib);\n\n\t\t/* Parse out the kernel module name if present. */\n\t\tif (*next != '\\0' && *next != '[' && *next != '<') {\n\t\t\tkernMod = next;\n\t\t\tnext = delimit_ws(kernMod);\n\t\t} else {\n\t\t\tkernMod = NULL;\n\t\t}\n\n\t\t/* Parse out the module options if present. */\n\t\tif (*next == '[') {\n\t\t\tmodOptions = next + 1;\n\t\t\tnext = delimit(modOptions, ']');\n\t\t} else {\n\t\t\tmodOptions = NULL;\n\t\t}\n\n\t\t/* Parse out the module type if present. */\n\t\tif (*next == '<') {\n\t\t\tmodType = next + 1;\n\t\t\t(void)delimit(modType, '>');\n\t\t} else {\n\t\t\tmodType = NULL;\n\t\t}\n\n\t\taddConfigEntry(oidStr, oid, sharedLib, kernMod, modOptions,\n\t\t\t       modType);\n\t} /* while */\n\t(void) fclose(confFile);\n} /* loadConfigFile */\n\n#if defined(_WIN32)\n\nstatic time_t\nfiletimeToTimet(const FILETIME *ft)\n{\n\tULARGE_INTEGER ull;\n\n\tull.LowPart = ft->dwLowDateTime;\n\tull.HighPart = ft->dwHighDateTime;\n\treturn (time_t)(ull.QuadPart / 10000000ULL - 11644473600ULL);\n}\n\nstatic time_t\ngetRegConfigModTime(const char *keyPath)\n{\n\ttime_t currentUserModTime = getRegKeyModTime(HKEY_CURRENT_USER,\n\t\t\t\t\t\t     keyPath);\n\ttime_t localMachineModTime = getRegKeyModTime(HKEY_LOCAL_MACHINE,\n\t\t\t\t\t\t      keyPath);\n\n\treturn currentUserModTime > localMachineModTime ? currentUserModTime :\n\t\tlocalMachineModTime;\n}\n\nstatic time_t\ngetRegKeyModTime(HKEY hBaseKey, const char *keyPath)\n{\n\tHKEY hConfigKey;\n\tHRESULT rc;\n\tint iSubKey = 0;\n\ttime_t modTime = 0, keyModTime;\n\tFILETIME keyLastWriteTime;\n\tchar subKeyName[256];\n\n\tif ((rc = RegOpenKeyEx(hBaseKey, keyPath, 0, KEY_ENUMERATE_SUB_KEYS,\n\t\t\t       &hConfigKey)) != ERROR_SUCCESS) {\n\t\t/* TODO: log error message */\n\t\treturn 0;\n\t}\n\tdo {\n\t\tint subKeyNameSize=sizeof(subKeyName)/sizeof(subKeyName[0]);\n\t\tif ((rc = RegEnumKeyEx(hConfigKey, iSubKey++, subKeyName,\n\t\t\t\t       &subKeyNameSize, NULL, NULL, NULL,\n\t\t\t\t       &keyLastWriteTime)) != ERROR_SUCCESS) {\n\t\t\tbreak;\n\t\t}\n\t\tkeyModTime = filetimeToTimet(&keyLastWriteTime);\n\t\tif (modTime < keyModTime) {\n\t\t\tmodTime = keyModTime;\n\t\t}\n\t} while (1);\n\tRegCloseKey(hConfigKey);\n\treturn modTime;\n}\n\nstatic void\ngetRegKeyValue(HKEY hKey, const char *keyPath, const char *valueName,\n\t       void **data, DWORD* dataLen)\n{\n\tDWORD sizeRequired=*dataLen;\n\tHRESULT hr;\n\t/* Get data length required */\n\tif ((hr = RegGetValue(hKey, keyPath, valueName, RRF_RT_REG_SZ, NULL,\n\t\t\t      NULL, &sizeRequired)) != ERROR_SUCCESS) {\n\t\t/* TODO: LOG registry error */\n\t\treturn;\n\t}\n\t/* adjust data buffer size if necessary */\n\tif (*dataLen < sizeRequired) {\n\t\t*dataLen = sizeRequired;\n\t\t*data = realloc(*data, sizeRequired);\n\t\tif (!*data) {\n\t\t\t*dataLen = 0;\n\t\t\t/* TODO: LOG OOM ERROR! */\n\t\t\treturn;\n\t\t}\n\t}\n\t/* get data */\n\tif ((hr = RegGetValue(hKey, keyPath, valueName, RRF_RT_REG_SZ, NULL,\n\t\t\t      *data, &sizeRequired)) != ERROR_SUCCESS) {\n\t\t/* LOG registry error */\n\t\treturn;\n\t}\n}\n\nstatic void\nloadConfigFromRegistry(HKEY hBaseKey, const char *keyPath)\n{\n\tHKEY hConfigKey;\n\tDWORD iSubKey, nSubKeys, maxSubKeyNameLen, modTypeLen;\n\tchar *oidStr = NULL, *oid = NULL, *sharedLib = NULL, *kernMod = NULL;\n\tchar *modOptions = NULL, *modType = NULL;\n\tDWORD oidStrLen = 0, oidLen = 0, sharedLibLen = 0, kernModLen = 0;\n\tDWORD modOptionsLen = 0;\n\tHRESULT rc;\n\n\tif ((rc = RegOpenKeyEx(hBaseKey, keyPath, 0,\n\t\t\t       KEY_ENUMERATE_SUB_KEYS|KEY_QUERY_VALUE,\n\t\t\t       &hConfigKey)) != ERROR_SUCCESS) {\n\t\t/* TODO: log registry error */\n\t\treturn;\n\t}\n\n\tif ((rc = RegQueryInfoKey(hConfigKey,\n\t\tNULL, /* lpClass */\n\t\tNULL, /* lpcClass */\n\t\tNULL, /* lpReserved */\n\t\t&nSubKeys,\n\t\t&maxSubKeyNameLen,\n\t\tNULL, /* lpcMaxClassLen */\n\t\tNULL, /* lpcValues */\n\t\tNULL, /* lpcMaxValueNameLen */\n\t\tNULL, /* lpcMaxValueLen */\n\t\tNULL, /* lpcbSecurityDescriptor */\n\t\tNULL  /* lpftLastWriteTime */ )) != ERROR_SUCCESS) {\n\t\tgoto cleanup;\n\t}\n\toidStr = malloc(++maxSubKeyNameLen);\n\tif (!oidStr) {\n\t\tgoto cleanup;\n\t}\n\tfor (iSubKey=0; iSubKey<nSubKeys; iSubKey++) {\n\t\toidStrLen = maxSubKeyNameLen;\n\t\tif ((rc = RegEnumKeyEx(hConfigKey, iSubKey, oidStr, &oidStrLen,\n\t\t\t\t       NULL, NULL, NULL, NULL)) !=\n\t\t    ERROR_SUCCESS) {\n\t\t\t/* TODO: log registry error */\n\t\t\tcontinue;\n\t\t}\n\t\tgetRegKeyValue(hConfigKey, oidStr, \"OID\", &oid, &oidLen);\n\t\tgetRegKeyValue(hConfigKey, oidStr, \"Shared Library\",\n\t\t\t       &sharedLib, &sharedLibLen);\n\t\tgetRegKeyValue(hConfigKey, oidStr, \"Kernel Module\", &kernMod,\n\t\t\t       &kernModLen);\n\t\tgetRegKeyValue(hConfigKey, oidStr, \"Options\", &modOptions,\n\t\t\t       &modOptionsLen);\n\t\tgetRegKeyValue(hConfigKey, oidStr, \"Type\", &modType,\n\t\t\t       &modTypeLen);\n\t\taddConfigEntry(oidStr, oid, sharedLib, kernMod, modOptions,\n\t\t\t       modType);\n\t}\ncleanup:\n\tRegCloseKey(hConfigKey);\n\tif (oidStr) {\n\t\tfree(oidStr);\n\t}\n\tif (oid) {\n\t\tfree(oid);\n\t}\n\tif (sharedLib) {\n\t\tfree(sharedLib);\n\t}\n\tif (kernMod) {\n\t\tfree(kernMod);\n\t}\n\tif (modOptions) {\n\t\tfree(modOptions);\n\t}\n}\n#endif\n\nstatic void\naddConfigEntry(const char *oidStr, const char *oid, const char *sharedLib,\n\t       const char *kernMod, const char *modOptions,\n\t       const char *modType)\n{\n#if defined(_WIN32)\n\tconst char *sharedPath;\n#else\n\tchar sharedPath[sizeof (MECH_LIB_PREFIX) + BUFSIZ];\n#endif\n\tchar *tmpStr;\n\tgss_OID mechOid;\n\tgss_mech_info aMech, tmp;\n\tOM_uint32 minor;\n\tgss_buffer_desc oidBuf;\n\n\tif ((!oid) || (!oidStr)) {\n\t\treturn;\n\t}\n\t/*\n\t * check if an entry for this oid already exists\n\t * if it does, and the library is already loaded then\n\t * we can't modify it, so skip it\n\t */\n\toidBuf.value = (void *)oid;\n\toidBuf.length = strlen(oid);\n\tif (generic_gss_str_to_oid(&minor, &oidBuf, &mechOid)\n\t\t!= GSS_S_COMPLETE) {\n\t\treturn;\n\t}\n\n\taMech = searchMechList(mechOid);\n\tif (aMech && aMech->mech) {\n\t\tgeneric_gss_release_oid(&minor, &mechOid);\n\t\treturn;\n\t}\n\n\t/*\n\t * If that's all, then this is a corrupt entry. Skip it.\n\t */\n\tif (! *sharedLib) {\n\t\tgeneric_gss_release_oid(&minor, &mechOid);\n\t\treturn;\n\t}\n#if defined(_WIN32)\n\tsharedPath = sharedLib;\n#else\n\tif (sharedLib[0] == '/')\n\t\tsnprintf(sharedPath, sizeof(sharedPath), \"%s\", sharedLib);\n\telse\n\t\tsnprintf(sharedPath, sizeof(sharedPath), \"%s%s\",\n\t\t\t MECH_LIB_PREFIX, sharedLib);\n#endif\n\t/*\n\t * are we creating a new mechanism entry or\n\t * just modifying existing (non loaded) mechanism entry\n\t */\n\tif (aMech) {\n\t\t/*\n\t\t * delete any old values and set new\n\t\t * mechNameStr and mech_type are not modified\n\t\t */\n\t\tif (aMech->kmodName) {\n\t\t\tfree(aMech->kmodName);\n\t\t\taMech->kmodName = NULL;\n\t\t}\n\n\t\tif (aMech->optionStr) {\n\t\t\tfree(aMech->optionStr);\n\t\t\taMech->optionStr = NULL;\n\t\t}\n\n\t\tif ((tmpStr = strdup(sharedPath)) != NULL) {\n\t\t\tif (aMech->uLibName)\n\t\t\t\tfree(aMech->uLibName);\n\t\t\taMech->uLibName = tmpStr;\n\t\t}\n\n\t\tif (kernMod) /* this is an optional parameter */\n\t\t\taMech->kmodName = strdup(kernMod);\n\n\t\tif (modOptions) /* optional module options */\n\t\t\taMech->optionStr = strdup(modOptions);\n\n\t\t/* the oid is already set */\n\t\tgeneric_gss_release_oid(&minor, &mechOid);\n\t\treturn;\n\t}\n\n\t/* adding a new entry */\n\taMech = calloc(1, sizeof (struct gss_mech_config));\n\tif (aMech == NULL) {\n\t\tgeneric_gss_release_oid(&minor, &mechOid);\n\t\treturn;\n\t}\n\taMech->mech_type = mechOid;\n\taMech->uLibName = strdup(sharedPath);\n\taMech->mechNameStr = strdup(oidStr);\n\taMech->freeMech = 0;\n\n\t/* check if any memory allocations failed - bad news */\n\tif (aMech->uLibName == NULL || aMech->mechNameStr == NULL) {\n\t\tif (aMech->uLibName)\n\t\t\tfree(aMech->uLibName);\n\t\tif (aMech->mechNameStr)\n\t\t\tfree(aMech->mechNameStr);\n\t\tgeneric_gss_release_oid(&minor, &mechOid);\n\t\tfree(aMech);\n\t\treturn;\n\t}\n\tif (kernMod)\t/* this is an optional parameter */\n\t\taMech->kmodName = strdup(kernMod);\n\n\tif (modOptions)\n\t\taMech->optionStr = strdup(modOptions);\n\n\tif (modType && strcmp(modType, \"interposer\") == 0)\n\t\taMech->is_interposer = 1;\n\n\t/*\n\t * add the new entry to the end of the list - make sure\n\t * that only complete entries are added because other\n\t * threads might currently be searching the list.\n\t */\n\ttmp = g_mechListTail;\n\tg_mechListTail = aMech;\n\n\tif (tmp != NULL)\n\t\ttmp->next = aMech;\n\n\tif (g_mechList == NULL)\n\t\tg_mechList = aMech;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/include/k5-thread.h": "/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* include/k5-thread.h - Preliminary portable thread support */\n/*\n * Copyright 2004,2005,2006,2007,2008 by the Massachusetts Institute of Technology.\n * All Rights Reserved.\n *\n * Export of this software from the United States of America may\n *   require a specific license from the United States Government.\n *   It is the responsibility of any person or organization contemplating\n *   export to obtain such a license before exporting.\n *\n * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and\n * distribute this software and its documentation for any purpose and\n * without fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright notice and\n * this permission notice appear in supporting documentation, and that\n * the name of M.I.T. not be used in advertising or publicity pertaining\n * to distribution of the software without specific, written prior\n * permission.  Furthermore if you modify this software you must label\n * your software as modified software and not distribute it in such a\n * fashion that it might be confused with the original M.I.T. software.\n * M.I.T. makes no representations about the suitability of\n * this software for any purpose.  It is provided \"as is\" without express\n * or implied warranty.\n */\n\n#ifndef K5_THREAD_H\n#define K5_THREAD_H\n\n#include \"autoconf.h\"\n#ifndef KRB5_CALLCONV\n# define KRB5_CALLCONV\n#endif\n#ifndef KRB5_CALLCONV_C\n# define KRB5_CALLCONV_C\n#endif\n\n/* Interface (tentative):\n\n     Mutex support:\n\n     // Between these two, we should be able to do pure compile-time\n     // and pure run-time initialization.\n     //   POSIX:   partial initializer is PTHREAD_MUTEX_INITIALIZER,\n     //            finish does nothing\n     //   Windows: partial initializer is an invalid handle,\n     //            finish does the real initialization work\n     k5_mutex_t foo_mutex = K5_MUTEX_PARTIAL_INITIALIZER;\n     int k5_mutex_finish_init(k5_mutex_t *);\n     // for dynamic allocation\n     int k5_mutex_init(k5_mutex_t *);\n     // Must work for both kinds of alloc, even if it means adding flags.\n     int k5_mutex_destroy(k5_mutex_t *);\n\n     // As before.\n     int k5_mutex_lock(k5_mutex_t *);\n     int k5_mutex_unlock(k5_mutex_t *);\n\n     In each library, one new function to finish the static mutex init,\n     and any other library-wide initialization that might be desired.\n     On POSIX, this function would be called via the second support\n     function (see below).  On Windows, it would be called at library\n     load time.  These functions, or functions they calls, should be the\n     only places that k5_mutex_finish_init gets called.\n\n     A second function or macro called at various possible \"first\" entry\n     points which either calls pthread_once on the first function\n     (POSIX), or checks some flag set by the first function (Windows),\n     and possibly returns an error.  (In the non-threaded case, a simple\n     flag can be used to avoid multiple invocations, and the mutexes\n     don't need run-time initialization anyways.)\n\n     A third function for library termination calls mutex_destroy on\n     each mutex for the library.  This function would be called\n     automatically at library unload time.  If it turns out to be needed\n     at exit time for libraries that don't get unloaded, perhaps we\n     should also use atexit().  Any static mutexes should be cleaned up\n     with k5_mutex_destroy here.\n\n     How does that second support function invoke the first support\n     function only once?  Through something modelled on pthread_once\n     that I haven't written up yet.  Probably:\n\n     k5_once_t foo_once = K5_ONCE_INIT;\n     k5_once(k5_once_t *, void (*)(void));\n\n     For POSIX: Map onto pthread_once facility.\n     For non-threaded case: A simple flag.\n     For Windows: Not needed; library init code takes care of it.\n\n     XXX: A general k5_once mechanism isn't possible for Windows,\n     without faking it through named mutexes or mutexes initialized at\n     startup.  I was only using it in one place outside these headers,\n     so I'm dropping the general scheme.  Eventually the existing uses\n     in k5-thread.h and k5-platform.h will be converted to pthread_once\n     or static variables.\n\n\n     Thread-specific data:\n\n     // TSD keys are limited in number in gssapi/krb5/com_err; enumerate\n     // them all.  This allows support code init to allocate the\n     // necessary storage for pointers all at once, and avoids any\n     // possible error in key creation.\n     enum { ... } k5_key_t;\n     // Register destructor function.  Called in library init code.\n     int k5_key_register(k5_key_t, void (*destructor)(void *));\n     // Returns NULL or data.\n     void *k5_getspecific(k5_key_t);\n     // Returns error if key out of bounds, or the pointer table can't\n     // be allocated.  A call to k5_key_register must have happened first.\n     // This may trigger the calling of pthread_setspecific on POSIX.\n     int k5_setspecific(k5_key_t, void *);\n     // Called in library termination code.\n     // Trashes data in all threads, calling the registered destructor\n     // (but calling it from the current thread).\n     int k5_key_delete(k5_key_t);\n\n     For the non-threaded version, the support code will have a static\n     array indexed by k5_key_t values, and get/setspecific simply access\n     the array elements.\n\n     The TSD destructor table is global state, protected by a mutex if\n     threads are enabled.\n\n\n     Any actual external symbols will use the krb5int_ prefix.  The k5_\n     names will be simple macros or inline functions to rename the\n     external symbols, or slightly more complex ones to expand the\n     implementation inline (e.g., map to POSIX versions and/or debug\n     code using __FILE__ and the like).\n\n\n     More to be added, perhaps.  */\n\n#include <assert.h>\n#ifndef NDEBUG\n#include <stdio.h>\n#include <string.h>\n#endif\n\n/* The mutex structure we use, k5_mutex_t, is defined to some\n   OS-specific bits.  The use of multiple layers of typedefs are an\n   artifact resulting from debugging code we once used, implemented as\n   wrappers around the OS mutex scheme.\n\n   The OS specific bits, in k5_os_mutex, break down into three primary\n   implementations, POSIX threads, Windows threads, and no thread\n   support.  However, the POSIX thread version is further subdivided:\n   In one case, we can determine at run time whether the thread\n   library is linked into the application, and use it only if it is\n   present; in the other case, we cannot, and the thread library must\n   be linked in always, but can be used unconditionally.  In the\n   former case, the k5_os_mutex structure needs to hold both the POSIX\n   and the non-threaded versions.\n\n   The various k5_os_mutex_* operations are the OS-specific versions,\n   applied to the OS-specific data, and k5_mutex_* uses k5_os_mutex_*\n   to do the OS-specific parts of the work.  */\n\n/* Define the OS mutex bit.  */\n\ntypedef char k5_os_nothread_mutex;\n# define K5_OS_NOTHREAD_MUTEX_PARTIAL_INITIALIZER       0\n/* Empty inline functions avoid the \"statement with no effect\"\n   warnings, and do better type-checking than functions that don't use\n   their arguments.  */\nstatic inline int k5_os_nothread_mutex_finish_init(k5_os_nothread_mutex *m) {\n    return 0;\n}\nstatic inline int k5_os_nothread_mutex_init(k5_os_nothread_mutex *m) {\n    return 0;\n}\nstatic inline int k5_os_nothread_mutex_destroy(k5_os_nothread_mutex *m) {\n    return 0;\n}\nstatic inline int k5_os_nothread_mutex_lock(k5_os_nothread_mutex *m) {\n    return 0;\n}\nstatic inline int k5_os_nothread_mutex_unlock(k5_os_nothread_mutex *m) {\n    return 0;\n}\n\n/* Values:\n   2 - function has not been run\n   3 - function has been run\n   4 - function is being run -- deadlock detected */\ntypedef unsigned char k5_os_nothread_once_t;\n# define K5_OS_NOTHREAD_ONCE_INIT       2\n# define k5_os_nothread_once(O,F)                               \\\n    (*(O) == 3 ? 0                                              \\\n     : *(O) == 2 ? (*(O) = 4, (F)(), *(O) = 3, 0)               \\\n     : (assert(*(O) != 4), assert(*(O) == 2 || *(O) == 3), 0))\n\n\n\n#ifndef ENABLE_THREADS\n\ntypedef k5_os_nothread_mutex k5_os_mutex;\n# define K5_OS_MUTEX_PARTIAL_INITIALIZER        \\\n    K5_OS_NOTHREAD_MUTEX_PARTIAL_INITIALIZER\n# define k5_os_mutex_finish_init        k5_os_nothread_mutex_finish_init\n# define k5_os_mutex_init               k5_os_nothread_mutex_init\n# define k5_os_mutex_destroy            k5_os_nothread_mutex_destroy\n# define k5_os_mutex_lock               k5_os_nothread_mutex_lock\n# define k5_os_mutex_unlock             k5_os_nothread_mutex_unlock\n\n# define k5_once_t                      k5_os_nothread_once_t\n# define K5_ONCE_INIT                   K5_OS_NOTHREAD_ONCE_INIT\n# define k5_once                        k5_os_nothread_once\n\n#elif HAVE_PTHREAD\n\n# include <pthread.h>\n\n/* Weak reference support, etc.\n\n   Linux: Stub mutex routines exist, but pthread_once does not.\n\n   Solaris <10: In libc there's a pthread_once that doesn't seem to do\n   anything.  Bleah.  But pthread_mutexattr_setrobust_np is defined\n   only in libpthread.  However, some version of GNU libc (Red Hat's\n   Fedora Core 5, reportedly) seems to have that function, but no\n   declaration, so we'd have to declare it in order to test for its\n   address.  We now have tests to see if pthread_once actually works,\n   so stick with that for now.\n\n   Solaris 10: The real thread support now lives in libc, and\n   libpthread is just a filter object.  So we might as well use the\n   real functions unconditionally.  Since we haven't got a test for\n   this property yet, we use NO_WEAK_PTHREADS defined in aclocal.m4\n   depending on the OS type.\n\n   IRIX 6.5 stub pthread support in libc is really annoying.  The\n   pthread_mutex_lock function returns ENOSYS for a program not linked\n   against -lpthread.  No link-time failure, no weak symbols, etc.\n   The C library doesn't provide pthread_once; we can use weak\n   reference support for that.\n\n   If weak references are not available, then for now, we assume that\n   the pthread support routines will always be available -- either the\n   real thing, or functional stubs that merely prohibit creating\n   threads.\n\n   If we find a platform with non-functional stubs and no weak\n   references, we may have to resort to some hack like dlsym on the\n   symbol tables of the current process.  */\n\n#if defined(HAVE_PRAGMA_WEAK_REF) && !defined(NO_WEAK_PTHREADS)\n# define USE_CONDITIONAL_PTHREADS\n#endif\n\n#ifdef USE_CONDITIONAL_PTHREADS\n\n/* Can't rely on useful stubs -- see above regarding Solaris.  */\ntypedef struct {\n    pthread_once_t o;\n    k5_os_nothread_once_t n;\n} k5_once_t;\n# define K5_ONCE_INIT   { PTHREAD_ONCE_INIT, K5_OS_NOTHREAD_ONCE_INIT }\n\nint k5_once(k5_once_t *once, void (*fn)(void));\n#else\n\n/* no pragma weak support */\n\ntypedef pthread_once_t k5_once_t;\n# define K5_ONCE_INIT   PTHREAD_ONCE_INIT\n# define k5_once        pthread_once\n\n#endif\n\n#if defined(__mips) && defined(__sgi) && (defined(_SYSTYPE_SVR4) || defined(__SYSTYPE_SVR4__))\n# ifndef HAVE_PRAGMA_WEAK_REF\n#  if defined(__GNUC__) && __GNUC__ < 3\n#   error \"Please update to a newer gcc with weak symbol support, or switch to native cc, reconfigure and recompile.\"\n#  else\n#   error \"Weak reference support is required\"\n#  endif\n# endif\n#endif\n\ntypedef pthread_mutex_t k5_os_mutex;\n# define K5_OS_MUTEX_PARTIAL_INITIALIZER        \\\n    PTHREAD_MUTEX_INITIALIZER\n\n#ifdef USE_CONDITIONAL_PTHREADS\n\n# define k5_os_mutex_finish_init(M)             (0)\nint k5_os_mutex_init(k5_os_mutex *m);\nint k5_os_mutex_destroy(k5_os_mutex *m);\nint k5_os_mutex_lock(k5_os_mutex *m);\nint k5_os_mutex_unlock(k5_os_mutex *m);\n\n#else\n\nstatic inline int k5_os_mutex_finish_init(k5_os_mutex *m) { return 0; }\n# define k5_os_mutex_init(M)            pthread_mutex_init((M), 0)\n# define k5_os_mutex_destroy(M)         pthread_mutex_destroy((M))\n# define k5_os_mutex_lock(M)            pthread_mutex_lock(M)\n# define k5_os_mutex_unlock(M)          pthread_mutex_unlock(M)\n\n#endif /* is pthreads always available? */\n\n#elif defined _WIN32\n\n# define k5_once_t k5_os_nothread_once_t\n\ntypedef struct {\n    HANDLE h;\n    int is_locked;\n} k5_os_mutex;\n\n# define K5_OS_MUTEX_PARTIAL_INITIALIZER { INVALID_HANDLE_VALUE, 0 }\n\n# define k5_os_mutex_finish_init(M)                                     \\\n    (assert((M)->h == INVALID_HANDLE_VALUE),                            \\\n     ((M)->h = CreateMutex(NULL, FALSE, NULL)) ? 0 : GetLastError())\n# define k5_os_mutex_init(M)                                            \\\n    ((M)->is_locked = 0,                                                \\\n     ((M)->h = CreateMutex(NULL, FALSE, NULL)) ? 0 : GetLastError())\n# define k5_os_mutex_destroy(M)                                 \\\n    (CloseHandle((M)->h) ? ((M)->h = 0, 0) : GetLastError())\n# define k5_os_mutex_lock k5_win_mutex_lock\n\nstatic inline int k5_win_mutex_lock(k5_os_mutex *m)\n{\n    DWORD res;\n    res = WaitForSingleObject(m->h, INFINITE);\n    if (res == WAIT_FAILED)\n        return GetLastError();\n    /* Eventually these should be turned into some reasonable error\n       code.  */\n    assert(res != WAIT_TIMEOUT);\n    assert(res != WAIT_ABANDONED);\n    assert(res == WAIT_OBJECT_0);\n    /* Avoid locking twice.  */\n    assert(m->is_locked == 0);\n    m->is_locked = 1;\n    return 0;\n}\n\n# define k5_os_mutex_unlock(M)                  \\\n    (assert((M)->is_locked == 1),               \\\n     (M)->is_locked = 0,                        \\\n     ReleaseMutex((M)->h) ? 0 : GetLastError())\n\n#else\n\n# error \"Thread support enabled, but thread system unknown\"\n\n#endif\n\ntypedef k5_os_mutex k5_mutex_t;\n#define K5_MUTEX_PARTIAL_INITIALIZER    K5_OS_MUTEX_PARTIAL_INITIALIZER\nstatic inline int k5_mutex_init(k5_mutex_t *m)\n{\n    return k5_os_mutex_init(m);\n}\nstatic inline int k5_mutex_finish_init(k5_mutex_t *m)\n{\n    return k5_os_mutex_finish_init(m);\n}\n#define k5_mutex_destroy(M)                     \\\n    (k5_os_mutex_destroy(M))\n\nstatic inline void k5_mutex_lock(k5_mutex_t *m)\n{\n    int r = k5_os_mutex_lock(m);\n#ifndef NDEBUG\n    if (r != 0) {\n        fprintf(stderr, \"k5_mutex_lock: Received error %d (%s)\\n\",\n                r, strerror(r));\n    }\n#endif\n    assert(r == 0);\n}\n\nstatic inline void k5_mutex_unlock(k5_mutex_t *m)\n{\n    int r = k5_os_mutex_unlock(m);\n#ifndef NDEBUG\n    if (r != 0) {\n        fprintf(stderr, \"k5_mutex_unlock: Received error %d (%s)\\n\",\n                r, strerror(r));\n    }\n#endif\n    assert(r == 0);\n}\n\n#define k5_mutex_assert_locked(M)       ((void)(M))\n#define k5_mutex_assert_unlocked(M)     ((void)(M))\n#define k5_assert_locked        k5_mutex_assert_locked\n#define k5_assert_unlocked      k5_mutex_assert_unlocked\n\n/* Thread-specific data; implemented in a support file, because we'll\n   need to keep track of some global data for cleanup purposes.\n\n   Note that the callback function type is such that the C library\n   routine free() is a valid callback.  */\ntypedef enum {\n    K5_KEY_COM_ERR,\n    K5_KEY_GSS_KRB5_SET_CCACHE_OLD_NAME,\n    K5_KEY_GSS_KRB5_CCACHE_NAME,\n    K5_KEY_GSS_KRB5_ERROR_MESSAGE,\n    K5_KEY_GSS_SPNEGO_STATUS,\n#if defined(__MACH__) && defined(__APPLE__)\n    K5_KEY_IPC_CONNECTION_INFO,\n#endif\n    K5_KEY_MAX\n} k5_key_t;\n/* rename shorthand symbols for export */\n#define k5_key_register krb5int_key_register\n#define k5_getspecific  krb5int_getspecific\n#define k5_setspecific  krb5int_setspecific\n#define k5_key_delete   krb5int_key_delete\nextern int k5_key_register(k5_key_t, void (*)(void *));\nextern void *k5_getspecific(k5_key_t);\nextern int k5_setspecific(k5_key_t, void *);\nextern int k5_key_delete(k5_key_t);\n\nextern int  KRB5_CALLCONV krb5int_mutex_alloc  (k5_mutex_t **);\nextern void KRB5_CALLCONV krb5int_mutex_free   (k5_mutex_t *);\nextern void KRB5_CALLCONV krb5int_mutex_lock   (k5_mutex_t *);\nextern void KRB5_CALLCONV krb5int_mutex_unlock (k5_mutex_t *);\n\n/* In time, many of the definitions above should move into the support\n   library, and this file should be greatly simplified.  For type\n   definitions, that'll take some work, since other data structures\n   incorporate mutexes directly, and our mutex type is dependent on\n   configuration options and system attributes.  For most functions,\n   though, it should be relatively easy.\n\n   For now, plugins should use the exported functions, and not the\n   above macros, and use krb5int_mutex_alloc for allocations.  */\n#if defined(PLUGIN) || (defined(CONFIG_SMALL) && !defined(THREAD_SUPPORT_IMPL))\n#undef k5_mutex_lock\n#define k5_mutex_lock krb5int_mutex_lock\n#undef k5_mutex_unlock\n#define k5_mutex_unlock krb5int_mutex_unlock\n#endif\n\n#endif /* multiple inclusion? */\n",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/tests/shlib/t_loader.c": "/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* tests/shlib/t_loader.c */\n/*\n * Copyright (C) 2005 by the Massachusetts Institute of Technology.\n * All rights reserved.\n *\n * Export of this software from the United States of America may\n *   require a specific license from the United States Government.\n *   It is the responsibility of any person or organization contemplating\n *   export to obtain such a license before exporting.\n *\n * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and\n * distribute this software and its documentation for any purpose and\n * without fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright notice and\n * this permission notice appear in supporting documentation, and that\n * the name of M.I.T. not be used in advertising or publicity pertaining\n * to distribution of the software without specific, written prior\n * permission.  Furthermore if you modify this software you must label\n * your software as modified software and not distribute it in such a\n * fashion that it might be confused with the original M.I.T. software.\n * M.I.T. makes no representations about the suitability of\n * this software for any purpose.  It is provided \"as is\" without express\n * or implied warranty.\n */\n\n#include \"k5-platform.h\"\n#include \"krb5.h\"\n#include \"gssapi/gssapi.h\"\n#define HAVE_DLOPEN 1\n\nstatic int verbose = 1;\n\n#ifdef HAVE_DLFCN_H\n# include <dlfcn.h>\n#endif\n/* Solaris man page recommends link.h too */\n\n/* lazy = 1 means resolve symbols later, 0 means now; any\n   other flags we should be testing?  On Windows, maybe?\n\n   Return value is the library handle.  On error, print a message and\n   exit.  */\n#define do_open(LIB,REV,FLAGS) do_open_1(LIB,REV,FLAGS,__LINE__)\nstatic void *do_open_1(const char *libname, const char *rev, int lazy, int line);\n\n/* Look up a function symbol in the library and return a pointer.\n\n   The return value may need casting to the correct type.  On error,\n   print a message and exit.  */\nstatic void *get_sym_1(void *libhandle, const char *sym, int line);\n#define get_sym(LIB, NAME) get_sym_1(LIB, NAME, __LINE__)\n#define GET_FSYM(TYPE, LIB, NAME) ((TYPE) get_sym(LIB, NAME))\n#define get_gfun(LIB, NAME) ((OM_uint32 KRB5_CALLCONV(*)()) get_sym(LIB, NAME))\n\n/* Close dynamically-opened library.\n\n   If the OS reports an error in doing so, print a message and\n   exit.  */\n#define do_close(X) do_close_1(X, __LINE__)\nstatic void do_close_1(void *libhandle, int line);\n\n#ifdef HAVE_DLOPEN\n\n#ifdef _AIX\n# define SHLIB_SUFFIX \".a\"\n#else\n# define SHLIB_SUFFIX \".so\"\n#endif\n\n#define HORIZ 25\n\nstatic void *do_open_1(const char *libname, const char *rev,\n                       int lazy, int line)\n{\n    void *p;\n    char *namebuf;\n    int r;\n\n    if (verbose)\n        printf(\"from line %d: do_open(%s)...%*s\", line, libname,\n               HORIZ-strlen(libname), \"\");\n#ifdef _AIX\n    r = asprintf(&namebuf, \"lib%s%s\", libname, SHLIB_SUFFIX);\n#else\n    r = asprintf(&namebuf, \"lib%s%s(shr.o.%s)\", libname, SHLIB_SUFFIX, rev);\n#endif\n    if (r < 0) {\n        perror(\"asprintf\");\n        exit(1);\n    }\n\n#ifndef RTLD_MEMBER\n#define RTLD_MEMBER 0\n#endif\n    p = dlopen(namebuf, (lazy ? RTLD_LAZY : RTLD_NOW) | RTLD_MEMBER);\n    if (p == 0) {\n        fprintf(stderr, \"dlopen of %s failed: %s\\n\", namebuf, dlerror());\n        exit(1);\n    }\n    free(namebuf);\n    if (verbose)\n        printf(\"done: %p\\n\", p);\n    return p;\n}\n\n#define SYM_PREFIX \"\"\nstatic void *get_sym_1(void *libhandle, const char *symname, int line)\n{\n    void *s;\n\n    /* Bah.  Fix this later, if we care.  */\n    assert(strlen(SYM_PREFIX) == 0);\n\n    if (verbose)\n        printf(\"from line %d: get_sym(%s)...%*s\", line, symname,\n               HORIZ-strlen(symname), \"\");\n\n    s = dlsym(libhandle, symname);\n    if (s == 0) {\n        fprintf(stderr, \"symbol %s not found\\n\", symname);\n        exit(1);\n    }\n    if (verbose)\n        printf(\"done: %p\\n\", s);\n    return s;\n}\n\nstatic void do_close_1(void *libhandle, int line)\n{\n    if (verbose) {\n        char pbuf[3*sizeof(libhandle)+4];\n        snprintf(pbuf, sizeof(pbuf), \"%p\", libhandle);\n        printf(\"from line %d: do_close(%s)...%*s\", line, pbuf,\n               HORIZ-1-strlen(pbuf), \"\");\n    }\n    if (dlclose(libhandle) != 0) {\n        fprintf(stderr, \"dlclose failed: %s\\n\", dlerror());\n        exit(1);\n    }\n    if (verbose)\n        printf(\"done\\n\");\n}\n\n#elif defined _WIN32\n\nstatic void *do_open(const char *libname, int lazy)\n{\n    /* To be written?  */\n    abort();\n}\n\nstatic void *get_sym(void *libhandle, const char *symname)\n{\n    abort();\n}\n\nstatic void do_close(void *libhandle)\n{\n    abort();\n}\n\n#else\n\nstatic void *do_open(const char *libname, int lazy)\n{\n    printf(\"don't know how to do dynamic loading here, punting\\n\");\n    exit(0);\n}\n\nstatic void *get_sym(void *libhandle, const char *symname)\n{\n    abort();\n}\n\nstatic void do_close(void *libhandle)\n{\n    abort();\n}\n\n#endif\n\nint main()\n{\n    void *celib, *k5lib, *gsslib, *celib2;\n\n    (void) setvbuf(stdout, 0, _IONBF, 0);\n\n    celib = do_open(\"com_err\", \"3.0\", 0);\n    k5lib = do_open(\"krb5\", \"3.2\", 0);\n    gsslib = do_open(\"gssapi_krb5\", \"2.2\", 0);\n    celib2 = do_open(\"com_err\", \"3.0\", 0);\n    do_close(celib2);\n    {\n        typedef krb5_error_code KRB5_CALLCONV (*ict)(krb5_context *);\n        typedef void KRB5_CALLCONV (*fct)(krb5_context);\n\n        ict init_context = (ict) get_sym(k5lib, \"krb5_init_context\");\n        fct free_context = (fct) get_sym(k5lib, \"krb5_free_context\");\n        krb5_context ctx;\n        krb5_error_code err;\n\n#define CALLING(S) (verbose ? printf(\"at   line %d: calling %s...%*s\", __LINE__, #S, (int)(HORIZ+1-strlen(#S)), \"\") : 0)\n#define DONE() (verbose ? printf(\"done\\n\") : 0)\n\n        CALLING(krb5_init_context);\n        err = init_context(&ctx);\n        DONE();\n        if (err) {\n            fprintf(stderr, \"error 0x%lx initializing context\\n\",\n                    (unsigned long) err);\n            exit(1);\n        }\n        CALLING(krb5_free_context);\n        free_context(ctx);\n        DONE();\n    }\n    celib2 = do_open(\"com_err\", \"3.0\", 0);\n    do_close(celib);\n    do_close(k5lib);\n    do_close(celib2);\n    do_close(gsslib);\n\n    /* Test gssapi_krb5 without having loaded anything else.  */\n    gsslib = do_open(\"gssapi_krb5\", \"2.2\", 1);\n    {\n        OM_uint32 KRB5_CALLCONV (*init_sec_context)(OM_uint32 *, gss_cred_id_t,\n                                                    gss_ctx_id_t *, gss_name_t,\n                                                    gss_OID,\n                                                    OM_uint32, OM_uint32,\n                                                    gss_channel_bindings_t,\n                                                    gss_buffer_t, gss_OID *,\n                                                    gss_buffer_t,\n                                                    OM_uint32 *, OM_uint32 *)\n            = get_gfun(gsslib, \"gss_init_sec_context\");\n        OM_uint32 KRB5_CALLCONV (*import_name)(OM_uint32 *, gss_buffer_t,\n                                               gss_OID, gss_name_t *)\n            = get_gfun(gsslib, \"gss_import_name\");\n        OM_uint32 KRB5_CALLCONV (*release_buffer)(OM_uint32 *, gss_buffer_t)\n            = get_gfun(gsslib, \"gss_release_buffer\");\n        OM_uint32 KRB5_CALLCONV (*release_name)(OM_uint32 *, gss_name_t *)\n            = get_gfun(gsslib, \"gss_release_name\");\n        OM_uint32 KRB5_CALLCONV (*delete_sec_context)(OM_uint32 *,\n                                                      gss_ctx_id_t *,\n                                                      gss_buffer_t)\n            = get_gfun(gsslib, \"gss_delete_sec_context\");\n\n        OM_uint32 gmaj, gmin;\n        OM_uint32 retflags;\n        gss_ctx_id_t gctx = GSS_C_NO_CONTEXT;\n        gss_buffer_desc token;\n        gss_name_t target;\n        static gss_buffer_desc target_name_buf = {\n            9, \"x@mit.edu\"\n        };\n        static gss_OID_desc service_name = {\n            10, \"\\x2a\\x86\\x48\\x86\\xf7\\x12\\x01\\x02\\x01\\x04\"\n        };\n\n        CALLING(gss_import_name);\n        gmaj = import_name(&gmin, &target_name_buf, &service_name, &target);\n        DONE();\n        if (gmaj != GSS_S_COMPLETE) {\n            fprintf(stderr,\n                    \"import_name reports error major 0x%lx minor 0x%lx(%ld)\\n\",\n                    (unsigned long) gmaj, (unsigned long) gmin,\n                    (signed long) gmin);\n            exit(1);\n        }\n        /* This will probably get different errors, depending on\n           whether we have tickets at the time.  Doesn't matter much,\n           we're ignoring the error and testing whether we're doing\n           cleanup properly.  (Though the internal cleanup needed in\n           the two cases might be different.)  */\n        CALLING(gss_init_sec_context);\n        gmaj = init_sec_context(&gmin, GSS_C_NO_CREDENTIAL, &gctx, target,\n                                GSS_C_NULL_OID, 0, 0, NULL, GSS_C_NO_BUFFER,\n                                NULL, &token, &retflags, NULL);\n        DONE();\n        /* Ignore success/failure indication.  */\n        if (token.length) {\n            CALLING(gss_release_buffer);\n            release_buffer(&gmin, &token);\n            DONE();\n        }\n        CALLING(gss_release_name);\n        release_name(&gmin, &target);\n        DONE();\n        if (gctx != GSS_C_NO_CONTEXT) {\n            CALLING(gss_delete_sec_context);\n            delete_sec_context(&gmin, gctx, GSS_C_NO_BUFFER);\n            DONE();\n        }\n    }\n    do_close(gsslib);\n\n    /* Test gssapi_krb5 with com_err already loaded, then unload\n       com_err first.  */\n    celib = do_open(\"com_err\", \"3.0\", 1);\n    gsslib = do_open(\"gssapi_krb5\", \"2.2\", 1);\n    {\n        OM_uint32 KRB5_CALLCONV (*init_sec_context)(OM_uint32 *, gss_cred_id_t,\n                                                    gss_ctx_id_t *, gss_name_t,\n                                                    gss_OID,\n                                                    OM_uint32, OM_uint32,\n                                                    gss_channel_bindings_t,\n                                                    gss_buffer_t, gss_OID *,\n                                                    gss_buffer_t,\n                                                    OM_uint32 *, OM_uint32 *)\n            = get_gfun(gsslib, \"gss_init_sec_context\");\n        OM_uint32 KRB5_CALLCONV (*import_name)(OM_uint32 *, gss_buffer_t,\n                                               gss_OID, gss_name_t *)\n            = get_gfun(gsslib, \"gss_import_name\");\n        OM_uint32 KRB5_CALLCONV (*release_buffer)(OM_uint32 *, gss_buffer_t)\n            = get_gfun(gsslib, \"gss_release_buffer\");\n        OM_uint32 KRB5_CALLCONV (*release_name)(OM_uint32 *, gss_name_t *)\n            = get_gfun(gsslib, \"gss_release_name\");\n        OM_uint32 KRB5_CALLCONV (*delete_sec_context)(OM_uint32 *,\n                                                      gss_ctx_id_t *,\n                                                      gss_buffer_t)\n            = get_gfun(gsslib, \"gss_delete_sec_context\");\n\n        OM_uint32 gmaj, gmin;\n        OM_uint32 retflags;\n        gss_ctx_id_t gctx = GSS_C_NO_CONTEXT;\n        gss_buffer_desc token;\n        gss_name_t target;\n        static gss_buffer_desc target_name_buf = {\n            9, \"x@mit.edu\"\n        };\n        static gss_OID_desc service_name = {\n            10, \"\\x2a\\x86\\x48\\x86\\xf7\\x12\\x01\\x02\\x01\\x04\"\n        };\n\n        CALLING(gss_import_name);\n        gmaj = import_name(&gmin, &target_name_buf, &service_name, &target);\n        DONE();\n        if (gmaj != GSS_S_COMPLETE) {\n            fprintf(stderr,\n                    \"import_name reports error major 0x%lx minor 0x%lx(%ld)\\n\",\n                    (unsigned long) gmaj, (unsigned long) gmin,\n                    (signed long) gmin);\n            exit(1);\n        }\n        /* This will probably get different errors, depending on\n           whether we have tickets at the time.  Doesn't matter much,\n           we're ignoring the error and testing whether we're doing\n           cleanup properly.  (Though the internal cleanup needed in\n           the two cases might be different.)  */\n        CALLING(gss_init_sec_context);\n        gmaj = init_sec_context(&gmin, GSS_C_NO_CREDENTIAL, &gctx, target,\n                                GSS_C_NULL_OID, 0, 0, NULL, GSS_C_NO_BUFFER,\n                                NULL, &token, &retflags, NULL);\n        DONE();\n        /* Ignore success/failure indication.  */\n        if (token.length) {\n            CALLING(gss_release_buffer);\n            release_buffer(&gmin, &token);\n            DONE();\n        }\n        CALLING(gss_release_name);\n        release_name(&gmin, &target);\n        DONE();\n        if (gctx != GSS_C_NO_CONTEXT) {\n            CALLING(gss_delete_sec_context);\n            delete_sec_context(&gmin, gctx, GSS_C_NO_BUFFER);\n            DONE();\n        }\n    }\n    do_close(celib);\n    do_close(gsslib);\n\n    return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/plugins/preauth/pkinit/pkinit_crypto_openssl.c": "/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/*\n * COPYRIGHT (C) 2006,2007\n * THE REGENTS OF THE UNIVERSITY OF MICHIGAN\n * ALL RIGHTS RESERVED\n *\n * Permission is granted to use, copy, create derivative works\n * and redistribute this software and such derivative works\n * for any purpose, so long as the name of The University of\n * Michigan is not used in any advertising or publicity\n * pertaining to the use of distribution of this software\n * without specific, written prior authorization.  If the\n * above copyright notice or any other identification of the\n * University of Michigan is included in any copy of any\n * portion of this software, then the disclaimer below must\n * also be included.\n *\n * THIS SOFTWARE IS PROVIDED AS IS, WITHOUT REPRESENTATION\n * FROM THE UNIVERSITY OF MICHIGAN AS TO ITS FITNESS FOR ANY\n * PURPOSE, AND WITHOUT WARRANTY BY THE UNIVERSITY OF\n * MICHIGAN OF ANY KIND, EITHER EXPRESS OR IMPLIED, INCLUDING\n * WITHOUT LIMITATION THE IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE. THE\n * REGENTS OF THE UNIVERSITY OF MICHIGAN SHALL NOT BE LIABLE\n * FOR ANY DAMAGES, INCLUDING SPECIAL, INDIRECT, INCIDENTAL, OR\n * CONSEQUENTIAL DAMAGES, WITH RESPECT TO ANY CLAIM ARISING\n * OUT OF OR IN CONNECTION WITH THE USE OF THE SOFTWARE, EVEN\n * IF IT HAS BEEN OR IS HEREAFTER ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGES.\n */\n\n#include \"k5-int.h\"\n#include \"pkinit_crypto_openssl.h\"\n#include \"k5-buf.h\"\n#include \"k5-hex.h\"\n#include <dlfcn.h>\n#include <unistd.h>\n#include <dirent.h>\n#include <arpa/inet.h>\n\nstatic krb5_error_code pkinit_init_pkinit_oids(pkinit_plg_crypto_context );\nstatic void pkinit_fini_pkinit_oids(pkinit_plg_crypto_context );\n\nstatic krb5_error_code pkinit_init_dh_params(pkinit_plg_crypto_context );\nstatic void pkinit_fini_dh_params(pkinit_plg_crypto_context );\n\nstatic krb5_error_code pkinit_init_certs(pkinit_identity_crypto_context ctx);\nstatic void pkinit_fini_certs(pkinit_identity_crypto_context ctx);\n\nstatic krb5_error_code pkinit_init_pkcs11(pkinit_identity_crypto_context ctx);\nstatic void pkinit_fini_pkcs11(pkinit_identity_crypto_context ctx);\n\nstatic krb5_error_code pkinit_encode_dh_params\n(const BIGNUM *, const BIGNUM *, const BIGNUM *, uint8_t **, unsigned int *);\nstatic DH *decode_dh_params(const uint8_t *, unsigned int );\nstatic int pkinit_check_dh_params(DH *dh1, DH *dh2);\n\nstatic krb5_error_code pkinit_sign_data\n(krb5_context context, pkinit_identity_crypto_context cryptoctx,\n unsigned char *data, unsigned int data_len,\n unsigned char **sig, unsigned int *sig_len);\n\nstatic krb5_error_code create_signature\n(unsigned char **, unsigned int *, unsigned char *, unsigned int,\n EVP_PKEY *pkey);\n\nstatic krb5_error_code pkinit_decode_data\n(krb5_context context, pkinit_identity_crypto_context cryptoctx,\n const uint8_t *data, unsigned int data_len, uint8_t **decoded,\n unsigned int *decoded_len);\n\n#ifdef DEBUG_DH\nstatic void print_dh(DH *, char *);\nstatic void print_pubkey(BIGNUM *, char *);\n#endif\n\nstatic int prepare_enc_data\n(const uint8_t *indata, int indata_len, uint8_t **outdata, int *outdata_len);\n\nstatic int openssl_callback (int, X509_STORE_CTX *);\nstatic int openssl_callback_ignore_crls (int, X509_STORE_CTX *);\n\nstatic int pkcs7_decrypt\n(krb5_context context, pkinit_identity_crypto_context id_cryptoctx, PKCS7 *p7,\n unsigned char **data_out, unsigned int *len_out);\n\nstatic ASN1_OBJECT * pkinit_pkcs7type2oid\n(pkinit_plg_crypto_context plg_cryptoctx, int pkcs7_type);\n\nstatic krb5_error_code pkinit_create_sequence_of_principal_identifiers\n(krb5_context context, pkinit_plg_crypto_context plg_cryptoctx,\n pkinit_req_crypto_context req_cryptoctx,\n pkinit_identity_crypto_context id_cryptoctx,\n int type, krb5_pa_data ***e_data_out);\n\n#ifndef WITHOUT_PKCS11\nstatic krb5_error_code pkinit_find_private_key\n(pkinit_identity_crypto_context, CK_ATTRIBUTE_TYPE usage,\n CK_OBJECT_HANDLE *objp);\nstatic krb5_error_code pkinit_login\n(krb5_context context, pkinit_identity_crypto_context id_cryptoctx,\n CK_TOKEN_INFO *tip, const char *password);\nstatic krb5_error_code pkinit_open_session\n(krb5_context context, pkinit_identity_crypto_context id_cryptoctx);\nstatic void * pkinit_C_LoadModule(const char *modname, CK_FUNCTION_LIST_PTR_PTR p11p);\nstatic CK_RV pkinit_C_UnloadModule(void *handle);\n#ifdef SILLYDECRYPT\nCK_RV pkinit_C_Decrypt\n(pkinit_identity_crypto_context id_cryptoctx,\n CK_BYTE_PTR pEncryptedData, CK_ULONG  ulEncryptedDataLen,\n CK_BYTE_PTR pData, CK_ULONG_PTR pulDataLen);\n#endif\n\nstatic krb5_error_code pkinit_sign_data_pkcs11\n(krb5_context context, pkinit_identity_crypto_context id_cryptoctx,\n unsigned char *data, unsigned int data_len,\n unsigned char **sig, unsigned int *sig_len);\nstatic krb5_error_code pkinit_decode_data_pkcs11\n(krb5_context context, pkinit_identity_crypto_context id_cryptoctx,\n const uint8_t *data, unsigned int data_len, uint8_t **decoded_data,\n unsigned int *decoded_data_len);\n#endif  /* WITHOUT_PKCS11 */\n\nstatic krb5_error_code pkinit_sign_data_fs\n(krb5_context context, pkinit_identity_crypto_context id_cryptoctx,\n unsigned char *data, unsigned int data_len,\n unsigned char **sig, unsigned int *sig_len);\nstatic krb5_error_code pkinit_decode_data_fs\n(krb5_context context, pkinit_identity_crypto_context id_cryptoctx,\n const uint8_t *data, unsigned int data_len, uint8_t **decoded_data,\n unsigned int *decoded_data_len);\n\nstatic krb5_error_code\ncreate_krb5_invalidCertificates(krb5_context context,\n                                pkinit_plg_crypto_context plg_cryptoctx,\n                                pkinit_req_crypto_context req_cryptoctx,\n                                pkinit_identity_crypto_context id_cryptoctx,\n                                krb5_external_principal_identifier *** ids);\n\nstatic krb5_error_code\ncreate_identifiers_from_stack(STACK_OF(X509) *sk,\n                              krb5_external_principal_identifier *** ids);\nstatic int\nwrap_signeddata(unsigned char *data, unsigned int data_len,\n                unsigned char **out, unsigned int *out_len);\n\nstatic char *\npkinit_pkcs11_code_to_text(int err);\n\n\n#ifdef HAVE_OPENSSL_CMS\n/* Use CMS support present in OpenSSL. */\n#include <openssl/cms.h>\n#define pkinit_CMS_get0_content_signed(_cms) CMS_get0_content(_cms)\n#define pkinit_CMS_get0_content_data(_cms) CMS_get0_content(_cms)\n#define pkinit_CMS_free1_crls(_sk_x509crl)              \\\n    sk_X509_CRL_pop_free((_sk_x509crl), X509_CRL_free)\n#define pkinit_CMS_free1_certs(_sk_x509)        \\\n    sk_X509_pop_free((_sk_x509), X509_free)\n#define pkinit_CMS_SignerInfo_get_cert(_cms,_si,_x509_pp)       \\\n    CMS_SignerInfo_get0_algs(_si,NULL,_x509_pp,NULL,NULL)\n#else\n/* Fake up CMS support using PKCS7. */\n#define pkinit_CMS_free1_crls(_stack_of_x509crls)   /* Don't free these */\n#define pkinit_CMS_free1_certs(_stack_of_x509certs) /* Don't free these */\n#define CMS_NO_SIGNER_CERT_VERIFY PKCS7_NOVERIFY\n#define CMS_NOATTR PKCS7_NOATTR\n#define CMS_ContentInfo PKCS7\n#define CMS_SignerInfo PKCS7_SIGNER_INFO\n#define d2i_CMS_ContentInfo d2i_PKCS7\n#define CMS_get0_type(_p7) ((_p7)->type)\n#define pkinit_CMS_get0_content_signed(_p7) (&((_p7)->d.sign->contents->d.other->value.octet_string))\n#define pkinit_CMS_get0_content_data(_p7) (&((_p7)->d.other->value.octet_string))\n#define CMS_set1_signers_certs(_p7,_stack_of_x509,_uint)\n#define CMS_get0_SignerInfos PKCS7_get_signer_info\n#define stack_st_CMS_SignerInfo stack_st_PKCS7_SIGNER_INFO\n#undef  sk_CMS_SignerInfo_value\n#define sk_CMS_SignerInfo_value sk_PKCS7_SIGNER_INFO_value\n#define CMS_get0_eContentType(_p7) (_p7->d.sign->contents->type)\n#define CMS_verify PKCS7_verify\n#define CMS_get1_crls(_p7) (_p7->d.sign->crl)\n#define CMS_get1_certs(_p7) (_p7->d.sign->cert)\n#define CMS_ContentInfo_free(_p7) PKCS7_free(_p7)\n#define pkinit_CMS_SignerInfo_get_cert(_p7,_si,_x509_pp)        \\\n    (*_x509_pp) = PKCS7_cert_from_signer_info(_p7,_si)\n#endif\n\n#if OPENSSL_VERSION_NUMBER < 0x10100000L\n\n/* 1.1 standardizes constructor and destructor names, renaming\n * EVP_MD_CTX_{create,destroy} and deprecating ASN1_STRING_data. */\n\n#define EVP_MD_CTX_new EVP_MD_CTX_create\n#define EVP_MD_CTX_free EVP_MD_CTX_destroy\n#define ASN1_STRING_get0_data ASN1_STRING_data\n\n/* 1.1 makes many handle types opaque and adds accessors.  Add compatibility\n * versions of the new accessors we use for pre-1.1. */\n\n#define OBJ_get0_data(o) ((o)->data)\n#define OBJ_length(o) ((o)->length)\n\n#define DH_set0_pqg compat_dh_set0_pqg\nstatic int compat_dh_set0_pqg(DH *dh, BIGNUM *p, BIGNUM *q, BIGNUM *g)\n{\n    /* The real function frees the old values and does argument checking, but\n     * our code doesn't need that. */\n    dh->p = p;\n    dh->q = q;\n    dh->g = g;\n    return 1;\n}\n\n#define DH_get0_pqg compat_dh_get0_pqg\nstatic void compat_dh_get0_pqg(const DH *dh, const BIGNUM **p,\n                               const BIGNUM **q, const BIGNUM **g)\n{\n    if (p != NULL)\n        *p = dh->p;\n    if (q != NULL)\n        *q = dh->q;\n    if (g != NULL)\n        *g = dh->g;\n}\n\n#define DH_get0_key compat_dh_get0_key\nstatic void compat_dh_get0_key(const DH *dh, const BIGNUM **pub,\n                               const BIGNUM **priv)\n{\n    if (pub != NULL)\n        *pub = dh->pub_key;\n    if (priv != NULL)\n        *priv = dh->priv_key;\n}\n\n/* Return true if the cert c includes a key usage which doesn't include u.\n * Define using direct member access for pre-1.1. */\n#define ku_reject(c, u)                                                 \\\n    (((c)->ex_flags & EXFLAG_KUSAGE) && !((c)->ex_kusage & (u)))\n\n#else /* OPENSSL_VERSION_NUMBER >= 0x10100000L */\n\n/* Return true if the cert x includes a key usage which doesn't include u. */\n#define ku_reject(c, u) (!(X509_get_key_usage(c) & (u)))\n\n#endif\n\nstatic struct pkcs11_errstrings {\n    short code;\n    char *text;\n} pkcs11_errstrings[] = {\n    { 0x0,      \"ok\" },\n    { 0x1,      \"cancel\" },\n    { 0x2,      \"host memory\" },\n    { 0x3,      \"slot id invalid\" },\n    { 0x5,      \"general error\" },\n    { 0x6,      \"function failed\" },\n    { 0x7,      \"arguments bad\" },\n    { 0x8,      \"no event\" },\n    { 0x9,      \"need to create threads\" },\n    { 0xa,      \"cant lock\" },\n    { 0x10,     \"attribute read only\" },\n    { 0x11,     \"attribute sensitive\" },\n    { 0x12,     \"attribute type invalid\" },\n    { 0x13,     \"attribute value invalid\" },\n    { 0x20,     \"data invalid\" },\n    { 0x21,     \"data len range\" },\n    { 0x30,     \"device error\" },\n    { 0x31,     \"device memory\" },\n    { 0x32,     \"device removed\" },\n    { 0x40,     \"encrypted data invalid\" },\n    { 0x41,     \"encrypted data len range\" },\n    { 0x50,     \"function canceled\" },\n    { 0x51,     \"function not parallel\" },\n    { 0x54,     \"function not supported\" },\n    { 0x60,     \"key handle invalid\" },\n    { 0x62,     \"key size range\" },\n    { 0x63,     \"key type inconsistent\" },\n    { 0x64,     \"key not needed\" },\n    { 0x65,     \"key changed\" },\n    { 0x66,     \"key needed\" },\n    { 0x67,     \"key indigestible\" },\n    { 0x68,     \"key function not permitted\" },\n    { 0x69,     \"key not wrappable\" },\n    { 0x6a,     \"key unextractable\" },\n    { 0x70,     \"mechanism invalid\" },\n    { 0x71,     \"mechanism param invalid\" },\n    { 0x82,     \"object handle invalid\" },\n    { 0x90,     \"operation active\" },\n    { 0x91,     \"operation not initialized\" },\n    { 0xa0,     \"pin incorrect\" },\n    { 0xa1,     \"pin invalid\" },\n    { 0xa2,     \"pin len range\" },\n    { 0xa3,     \"pin expired\" },\n    { 0xa4,     \"pin locked\" },\n    { 0xb0,     \"session closed\" },\n    { 0xb1,     \"session count\" },\n    { 0xb3,     \"session handle invalid\" },\n    { 0xb4,     \"session parallel not supported\" },\n    { 0xb5,     \"session read only\" },\n    { 0xb6,     \"session exists\" },\n    { 0xb7,     \"session read only exists\" },\n    { 0xb8,     \"session read write so exists\" },\n    { 0xc0,     \"signature invalid\" },\n    { 0xc1,     \"signature len range\" },\n    { 0xd0,     \"template incomplete\" },\n    { 0xd1,     \"template inconsistent\" },\n    { 0xe0,     \"token not present\" },\n    { 0xe1,     \"token not recognized\" },\n    { 0xe2,     \"token write protected\" },\n    { 0xf0,     \"unwrapping key handle invalid\" },\n    { 0xf1,     \"unwrapping key size range\" },\n    { 0xf2,     \"unwrapping key type inconsistent\" },\n    { 0x100,    \"user already logged in\" },\n    { 0x101,    \"user not logged in\" },\n    { 0x102,    \"user pin not initialized\" },\n    { 0x103,    \"user type invalid\" },\n    { 0x104,    \"user another already logged in\" },\n    { 0x105,    \"user too many types\" },\n    { 0x110,    \"wrapped key invalid\" },\n    { 0x112,    \"wrapped key len range\" },\n    { 0x113,    \"wrapping key handle invalid\" },\n    { 0x114,    \"wrapping key size range\" },\n    { 0x115,    \"wrapping key type inconsistent\" },\n    { 0x120,    \"random seed not supported\" },\n    { 0x121,    \"random no rng\" },\n    { 0x130,    \"domain params invalid\" },\n    { 0x150,    \"buffer too small\" },\n    { 0x160,    \"saved state invalid\" },\n    { 0x170,    \"information sensitive\" },\n    { 0x180,    \"state unsaveable\" },\n    { 0x190,    \"cryptoki not initialized\" },\n    { 0x191,    \"cryptoki already initialized\" },\n    { 0x1a0,    \"mutex bad\" },\n    { 0x1a1,    \"mutex not locked\" },\n    { 0x200,    \"function rejected\" },\n    { -1,       NULL }\n};\n\n/* DH parameters */\nstatic uint8_t oakley_1024[128] = {\n    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n    0xC9, 0x0F, 0xDA, 0xA2, 0x21, 0x68, 0xC2, 0x34,\n    0xC4, 0xC6, 0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1,\n    0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74,\n    0x02, 0x0B, 0xBE, 0xA6, 0x3B, 0x13, 0x9B, 0x22,\n    0x51, 0x4A, 0x08, 0x79, 0x8E, 0x34, 0x04, 0xDD,\n    0xEF, 0x95, 0x19, 0xB3, 0xCD, 0x3A, 0x43, 0x1B,\n    0x30, 0x2B, 0x0A, 0x6D, 0xF2, 0x5F, 0x14, 0x37,\n    0x4F, 0xE1, 0x35, 0x6D, 0x6D, 0x51, 0xC2, 0x45,\n    0xE4, 0x85, 0xB5, 0x76, 0x62, 0x5E, 0x7E, 0xC6,\n    0xF4, 0x4C, 0x42, 0xE9, 0xA6, 0x37, 0xED, 0x6B,\n    0x0B, 0xFF, 0x5C, 0xB6, 0xF4, 0x06, 0xB7, 0xED,\n    0xEE, 0x38, 0x6B, 0xFB, 0x5A, 0x89, 0x9F, 0xA5,\n    0xAE, 0x9F, 0x24, 0x11, 0x7C, 0x4B, 0x1F, 0xE6,\n    0x49, 0x28, 0x66, 0x51, 0xEC, 0xE6, 0x53, 0x81,\n    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF\n};\n\nstatic uint8_t oakley_2048[2048/8] = {\n    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n    0xC9, 0x0F, 0xDA, 0xA2, 0x21, 0x68, 0xC2, 0x34,\n    0xC4, 0xC6, 0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1,\n    0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74,\n    0x02, 0x0B, 0xBE, 0xA6, 0x3B, 0x13, 0x9B, 0x22,\n    0x51, 0x4A, 0x08, 0x79, 0x8E, 0x34, 0x04, 0xDD,\n    0xEF, 0x95, 0x19, 0xB3, 0xCD, 0x3A, 0x43, 0x1B,\n    0x30, 0x2B, 0x0A, 0x6D, 0xF2, 0x5F, 0x14, 0x37,\n    0x4F, 0xE1, 0x35, 0x6D, 0x6D, 0x51, 0xC2, 0x45,\n    0xE4, 0x85, 0xB5, 0x76, 0x62, 0x5E, 0x7E, 0xC6,\n    0xF4, 0x4C, 0x42, 0xE9, 0xA6, 0x37, 0xED, 0x6B,\n    0x0B, 0xFF, 0x5C, 0xB6, 0xF4, 0x06, 0xB7, 0xED,\n    0xEE, 0x38, 0x6B, 0xFB, 0x5A, 0x89, 0x9F, 0xA5,\n    0xAE, 0x9F, 0x24, 0x11, 0x7C, 0x4B, 0x1F, 0xE6,\n    0x49, 0x28, 0x66, 0x51, 0xEC, 0xE4, 0x5B, 0x3D,\n    0xC2, 0x00, 0x7C, 0xB8, 0xA1, 0x63, 0xBF, 0x05,\n    0x98, 0xDA, 0x48, 0x36, 0x1C, 0x55, 0xD3, 0x9A,\n    0x69, 0x16, 0x3F, 0xA8, 0xFD, 0x24, 0xCF, 0x5F,\n    0x83, 0x65, 0x5D, 0x23, 0xDC, 0xA3, 0xAD, 0x96,\n    0x1C, 0x62, 0xF3, 0x56, 0x20, 0x85, 0x52, 0xBB,\n    0x9E, 0xD5, 0x29, 0x07, 0x70, 0x96, 0x96, 0x6D,\n    0x67, 0x0C, 0x35, 0x4E, 0x4A, 0xBC, 0x98, 0x04,\n    0xF1, 0x74, 0x6C, 0x08, 0xCA, 0x18, 0x21, 0x7C,\n    0x32, 0x90, 0x5E, 0x46, 0x2E, 0x36, 0xCE, 0x3B,\n    0xE3, 0x9E, 0x77, 0x2C, 0x18, 0x0E, 0x86, 0x03,\n    0x9B, 0x27, 0x83, 0xA2, 0xEC, 0x07, 0xA2, 0x8F,\n    0xB5, 0xC5, 0x5D, 0xF0, 0x6F, 0x4C, 0x52, 0xC9,\n    0xDE, 0x2B, 0xCB, 0xF6, 0x95, 0x58, 0x17, 0x18,\n    0x39, 0x95, 0x49, 0x7C, 0xEA, 0x95, 0x6A, 0xE5,\n    0x15, 0xD2, 0x26, 0x18, 0x98, 0xFA, 0x05, 0x10,\n    0x15, 0x72, 0x8E, 0x5A, 0x8A, 0xAC, 0xAA, 0x68,\n    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF\n};\n\nstatic uint8_t oakley_4096[4096/8] = {\n    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,\n    0xC9, 0x0F, 0xDA, 0xA2, 0x21, 0x68, 0xC2, 0x34,\n    0xC4, 0xC6, 0x62, 0x8B, 0x80, 0xDC, 0x1C, 0xD1,\n    0x29, 0x02, 0x4E, 0x08, 0x8A, 0x67, 0xCC, 0x74,\n    0x02, 0x0B, 0xBE, 0xA6, 0x3B, 0x13, 0x9B, 0x22,\n    0x51, 0x4A, 0x08, 0x79, 0x8E, 0x34, 0x04, 0xDD,\n    0xEF, 0x95, 0x19, 0xB3, 0xCD, 0x3A, 0x43, 0x1B,\n    0x30, 0x2B, 0x0A, 0x6D, 0xF2, 0x5F, 0x14, 0x37,\n    0x4F, 0xE1, 0x35, 0x6D, 0x6D, 0x51, 0xC2, 0x45,\n    0xE4, 0x85, 0xB5, 0x76, 0x62, 0x5E, 0x7E, 0xC6,\n    0xF4, 0x4C, 0x42, 0xE9, 0xA6, 0x37, 0xED, 0x6B,\n    0x0B, 0xFF, 0x5C, 0xB6, 0xF4, 0x06, 0xB7, 0xED,\n    0xEE, 0x38, 0x6B, 0xFB, 0x5A, 0x89, 0x9F, 0xA5,\n    0xAE, 0x9F, 0x24, 0x11, 0x7C, 0x4B, 0x1F, 0xE6,\n    0x49, 0x28, 0x66, 0x51, 0xEC, 0xE4, 0x5B, 0x3D,\n    0xC2, 0x00, 0x7C, 0xB8, 0xA1, 0x63, 0xBF, 0x05,\n    0x98, 0xDA, 0x48, 0x36, 0x1C, 0x55, 0xD3, 0x9A,\n    0x69, 0x16, 0x3F, 0xA8, 0xFD, 0x24, 0xCF, 0x5F,\n    0x83, 0x65, 0x5D, 0x23, 0xDC, 0xA3, 0xAD, 0x96,\n    0x1C, 0x62, 0xF3, 0x56, 0x20, 0x85, 0x52, 0xBB,\n    0x9E, 0xD5, 0x29, 0x07, 0x70, 0x96, 0x96, 0x6D,\n    0x67, 0x0C, 0x35, 0x4E, 0x4A, 0xBC, 0x98, 0x04,\n    0xF1, 0x74, 0x6C, 0x08, 0xCA, 0x18, 0x21, 0x7C,\n    0x32, 0x90, 0x5E, 0x46, 0x2E, 0x36, 0xCE, 0x3B,\n    0xE3, 0x9E, 0x77, 0x2C, 0x18, 0x0E, 0x86, 0x03,\n    0x9B, 0x27, 0x83, 0xA2, 0xEC, 0x07, 0xA2, 0x8F,\n    0xB5, 0xC5, 0x5D, 0xF0, 0x6F, 0x4C, 0x52, 0xC9,\n    0xDE, 0x2B, 0xCB, 0xF6, 0x95, 0x58, 0x17, 0x18,\n    0x39, 0x95, 0x49, 0x7C, 0xEA, 0x95, 0x6A, 0xE5,\n    0x15, 0xD2, 0x26, 0x18, 0x98, 0xFA, 0x05, 0x10,\n    0x15, 0x72, 0x8E, 0x5A, 0x8A, 0xAA, 0xC4, 0x2D,\n    0xAD, 0x33, 0x17, 0x0D, 0x04, 0x50, 0x7A, 0x33,\n    0xA8, 0x55, 0x21, 0xAB, 0xDF, 0x1C, 0xBA, 0x64,\n    0xEC, 0xFB, 0x85, 0x04, 0x58, 0xDB, 0xEF, 0x0A,\n    0x8A, 0xEA, 0x71, 0x57, 0x5D, 0x06, 0x0C, 0x7D,\n    0xB3, 0x97, 0x0F, 0x85, 0xA6, 0xE1, 0xE4, 0xC7,\n    0xAB, 0xF5, 0xAE, 0x8C, 0xDB, 0x09, 0x33, 0xD7,\n    0x1E, 0x8C, 0x94, 0xE0, 0x4A, 0x25, 0x61, 0x9D,\n    0xCE, 0xE3, 0xD2, 0x26, 0x1A, 0xD2, 0xEE, 0x6B,\n    0xF1, 0x2F, 0xFA, 0x06, 0xD9, 0x8A, 0x08, 0x64,\n    0xD8, 0x76, 0x02, 0x73, 0x3E, 0xC8, 0x6A, 0x64,\n    0x52, 0x1F, 0x2B, 0x18, 0x17, 0x7B, 0x20, 0x0C,\n    0xBB, 0xE1, 0x17, 0x57, 0x7A, 0x61, 0x5D, 0x6C,\n    0x77, 0x09, 0x88, 0xC0, 0xBA, 0xD9, 0x46, 0xE2,\n    0x08, 0xE2, 0x4F, 0xA0, 0x74, 0xE5, 0xAB, 0x31,\n    0x43, 0xDB, 0x5B, 0xFC, 0xE0, 0xFD, 0x10, 0x8E,\n    0x4B, 0x82, 0xD1, 0x20, 0xA9, 0x21, 0x08, 0x01,\n    0x1A, 0x72, 0x3C, 0x12, 0xA7, 0x87, 0xE6, 0xD7,\n    0x88, 0x71, 0x9A, 0x10, 0xBD, 0xBA, 0x5B, 0x26,\n    0x99, 0xC3, 0x27, 0x18, 0x6A, 0xF4, 0xE2, 0x3C,\n    0x1A, 0x94, 0x68, 0x34, 0xB6, 0x15, 0x0B, 0xDA,\n    0x25, 0x83, 0xE9, 0xCA, 0x2A, 0xD4, 0x4C, 0xE8,\n    0xDB, 0xBB, 0xC2, 0xDB, 0x04, 0xDE, 0x8E, 0xF9,\n    0x2E, 0x8E, 0xFC, 0x14, 0x1F, 0xBE, 0xCA, 0xA6,\n    0x28, 0x7C, 0x59, 0x47, 0x4E, 0x6B, 0xC0, 0x5D,\n    0x99, 0xB2, 0x96, 0x4F, 0xA0, 0x90, 0xC3, 0xA2,\n    0x23, 0x3B, 0xA1, 0x86, 0x51, 0x5B, 0xE7, 0xED,\n    0x1F, 0x61, 0x29, 0x70, 0xCE, 0xE2, 0xD7, 0xAF,\n    0xB8, 0x1B, 0xDD, 0x76, 0x21, 0x70, 0x48, 0x1C,\n    0xD0, 0x06, 0x91, 0x27, 0xD5, 0xB0, 0x5A, 0xA9,\n    0x93, 0xB4, 0xEA, 0x98, 0x8D, 0x8F, 0xDD, 0xC1,\n    0x86, 0xFF, 0xB7, 0xDC, 0x90, 0xA6, 0xC0, 0x8F,\n    0x4D, 0xF4, 0x35, 0xC9, 0x34, 0x06, 0x31, 0x99,\n    0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF\n};\n\nMAKE_INIT_FUNCTION(pkinit_openssl_init);\n\nstatic krb5_error_code oerr(krb5_context context, krb5_error_code code,\n                            const char *fmt, ...)\n#if !defined(__cplusplus) && (__GNUC__ > 2)\n    __attribute__((__format__(__printf__, 3, 4)))\n#endif\n    ;\n\n/*\n * Set an error string containing the formatted arguments and the first pending\n * OpenSSL error.  Write the formatted arguments and all pending OpenSSL error\n * messages to the trace log.  Return code, or KRB5KDC_ERR_PREAUTH_FAILED if\n * code is 0.\n */\nstatic krb5_error_code\noerr(krb5_context context, krb5_error_code code, const char *fmt, ...)\n{\n    unsigned long err;\n    va_list ap;\n    char *str, buf[128];\n    int r;\n\n    if (!code)\n        code = KRB5KDC_ERR_PREAUTH_FAILED;\n\n    va_start(ap, fmt);\n    r = vasprintf(&str, fmt, ap);\n    va_end(ap);\n    if (r < 0)\n        return code;\n\n    err = ERR_peek_error();\n    if (err) {\n        krb5_set_error_message(context, code, _(\"%s: %s\"), str,\n                               ERR_reason_error_string(err));\n    } else {\n        krb5_set_error_message(context, code, \"%s\", str);\n    }\n\n    TRACE_PKINIT_OPENSSL_ERROR(context, str);\n    while ((err = ERR_get_error()) != 0) {\n        ERR_error_string_n(err, buf, sizeof(buf));\n        TRACE_PKINIT_OPENSSL_ERROR(context, buf);\n    }\n\n    free(str);\n    return code;\n}\n\n/*\n * Set an appropriate error string containing msg for a certificate\n * verification failure from certctx.  Write the message and all pending\n * OpenSSL error messages to the trace log.  Return code, or\n * KRB5KDC_ERR_PREAUTH_FAILED if code is 0.\n */\nstatic krb5_error_code\noerr_cert(krb5_context context, krb5_error_code code, X509_STORE_CTX *certctx,\n          const char *msg)\n{\n    int depth = X509_STORE_CTX_get_error_depth(certctx);\n    int err = X509_STORE_CTX_get_error(certctx);\n    const char *errstr = X509_verify_cert_error_string(err);\n\n    return oerr(context, code, _(\"%s (depth %d): %s\"), msg, depth, errstr);\n}\n\nkrb5_error_code\npkinit_init_plg_crypto(pkinit_plg_crypto_context *cryptoctx)\n{\n    krb5_error_code retval = ENOMEM;\n    pkinit_plg_crypto_context ctx = NULL;\n\n    (void)CALL_INIT_FUNCTION(pkinit_openssl_init);\n\n    ctx = malloc(sizeof(*ctx));\n    if (ctx == NULL)\n        goto out;\n    memset(ctx, 0, sizeof(*ctx));\n\n    pkiDebug(\"%s: initializing openssl crypto context at %p\\n\",\n             __FUNCTION__, ctx);\n    retval = pkinit_init_pkinit_oids(ctx);\n    if (retval)\n        goto out;\n\n    retval = pkinit_init_dh_params(ctx);\n    if (retval)\n        goto out;\n\n    *cryptoctx = ctx;\n\nout:\n    if (retval && ctx != NULL)\n        pkinit_fini_plg_crypto(ctx);\n\n    return retval;\n}\n\nvoid\npkinit_fini_plg_crypto(pkinit_plg_crypto_context cryptoctx)\n{\n    pkiDebug(\"%s: freeing context at %p\\n\", __FUNCTION__, cryptoctx);\n\n    if (cryptoctx == NULL)\n        return;\n    pkinit_fini_pkinit_oids(cryptoctx);\n    pkinit_fini_dh_params(cryptoctx);\n    free(cryptoctx);\n}\n\nkrb5_error_code\npkinit_init_identity_crypto(pkinit_identity_crypto_context *idctx)\n{\n    krb5_error_code retval = ENOMEM;\n    pkinit_identity_crypto_context ctx = NULL;\n\n    ctx = malloc(sizeof(*ctx));\n    if (ctx == NULL)\n        goto out;\n    memset(ctx, 0, sizeof(*ctx));\n\n    ctx->identity = NULL;\n\n    retval = pkinit_init_certs(ctx);\n    if (retval)\n        goto out;\n\n    retval = pkinit_init_pkcs11(ctx);\n    if (retval)\n        goto out;\n\n    pkiDebug(\"%s: returning ctx at %p\\n\", __FUNCTION__, ctx);\n    *idctx = ctx;\n\nout:\n    if (retval) {\n        if (ctx)\n            pkinit_fini_identity_crypto(ctx);\n    }\n\n    return retval;\n}\n\nvoid\npkinit_fini_identity_crypto(pkinit_identity_crypto_context idctx)\n{\n    if (idctx == NULL)\n        return;\n\n    pkiDebug(\"%s: freeing ctx at %p\\n\", __FUNCTION__, idctx);\n    if (idctx->deferred_ids != NULL)\n        pkinit_free_deferred_ids(idctx->deferred_ids);\n    free(idctx->identity);\n    pkinit_fini_certs(idctx);\n    pkinit_fini_pkcs11(idctx);\n    free(idctx);\n}\n\nkrb5_error_code\npkinit_init_req_crypto(pkinit_req_crypto_context *cryptoctx)\n{\n    krb5_error_code retval = ENOMEM;\n    pkinit_req_crypto_context ctx = NULL;\n\n    ctx = malloc(sizeof(*ctx));\n    if (ctx == NULL)\n        goto out;\n    memset(ctx, 0, sizeof(*ctx));\n\n    ctx->dh = NULL;\n    ctx->received_cert = NULL;\n\n    *cryptoctx = ctx;\n\n    pkiDebug(\"%s: returning ctx at %p\\n\", __FUNCTION__, ctx);\n    retval = 0;\nout:\n    if (retval)\n        free(ctx);\n\n    return retval;\n}\n\nvoid\npkinit_fini_req_crypto(pkinit_req_crypto_context req_cryptoctx)\n{\n    if (req_cryptoctx == NULL)\n        return;\n\n    pkiDebug(\"%s: freeing ctx at %p\\n\", __FUNCTION__, req_cryptoctx);\n    if (req_cryptoctx->dh != NULL)\n        DH_free(req_cryptoctx->dh);\n    if (req_cryptoctx->received_cert != NULL)\n        X509_free(req_cryptoctx->received_cert);\n\n    free(req_cryptoctx);\n}\n\nstatic krb5_error_code\npkinit_init_pkinit_oids(pkinit_plg_crypto_context ctx)\n{\n    ctx->id_pkinit_san = OBJ_txt2obj(\"1.3.6.1.5.2.2\", 1);\n    if (ctx->id_pkinit_san == NULL)\n        return ENOMEM;\n\n    ctx->id_pkinit_authData = OBJ_txt2obj(\"1.3.6.1.5.2.3.1\", 1);\n    if (ctx->id_pkinit_authData == NULL)\n        return ENOMEM;\n\n    ctx->id_pkinit_DHKeyData = OBJ_txt2obj(\"1.3.6.1.5.2.3.2\", 1);\n    if (ctx->id_pkinit_DHKeyData == NULL)\n        return ENOMEM;\n\n    ctx->id_pkinit_rkeyData = OBJ_txt2obj(\"1.3.6.1.5.2.3.3\", 1);\n    if (ctx->id_pkinit_rkeyData == NULL)\n        return ENOMEM;\n\n    ctx->id_pkinit_KPClientAuth = OBJ_txt2obj(\"1.3.6.1.5.2.3.4\", 1);\n    if (ctx->id_pkinit_KPClientAuth == NULL)\n        return ENOMEM;\n\n    ctx->id_pkinit_KPKdc = OBJ_txt2obj(\"1.3.6.1.5.2.3.5\", 1);\n    if (ctx->id_pkinit_KPKdc == NULL)\n        return ENOMEM;\n\n    ctx->id_ms_kp_sc_logon = OBJ_txt2obj(\"1.3.6.1.4.1.311.20.2.2\", 1);\n    if (ctx->id_ms_kp_sc_logon == NULL)\n        return ENOMEM;\n\n    ctx->id_ms_san_upn = OBJ_txt2obj(\"1.3.6.1.4.1.311.20.2.3\", 1);\n    if (ctx->id_ms_san_upn == NULL)\n        return ENOMEM;\n\n    ctx->id_kp_serverAuth = OBJ_txt2obj(\"1.3.6.1.5.5.7.3.1\", 1);\n    if (ctx->id_kp_serverAuth == NULL)\n        return ENOMEM;\n\n    return 0;\n}\n\nstatic krb5_error_code\nget_cert(char *filename, X509 **retcert)\n{\n    X509 *cert = NULL;\n    BIO *tmp = NULL;\n    int code;\n    krb5_error_code retval;\n\n    if (filename == NULL || retcert == NULL)\n        return EINVAL;\n\n    *retcert = NULL;\n\n    tmp = BIO_new(BIO_s_file());\n    if (tmp == NULL)\n        return ENOMEM;\n\n    code = BIO_read_filename(tmp, filename);\n    if (code == 0) {\n        retval = errno;\n        goto cleanup;\n    }\n\n    cert = (X509 *) PEM_read_bio_X509(tmp, NULL, NULL, NULL);\n    if (cert == NULL) {\n        retval = EIO;\n        pkiDebug(\"failed to read certificate from %s\\n\", filename);\n        goto cleanup;\n    }\n    *retcert = cert;\n    retval = 0;\ncleanup:\n    if (tmp != NULL)\n        BIO_free(tmp);\n    return retval;\n}\n\nstruct get_key_cb_data {\n    krb5_context context;\n    pkinit_identity_crypto_context id_cryptoctx;\n    const char *fsname;\n    char *filename;\n    const char *password;\n};\n\nstatic int\nget_key_cb(char *buf, int size, int rwflag, void *userdata)\n{\n    struct get_key_cb_data *data = userdata;\n    pkinit_identity_crypto_context id_cryptoctx;\n    krb5_data rdat;\n    krb5_prompt kprompt;\n    krb5_prompt_type prompt_type;\n    krb5_error_code retval;\n    char *prompt;\n\n    if (data->id_cryptoctx->defer_id_prompt) {\n        /* Supply the identity name to be passed to a responder callback. */\n        pkinit_set_deferred_id(&data->id_cryptoctx->deferred_ids,\n                               data->fsname, 0, NULL);\n        return -1;\n    }\n    if (data->password == NULL) {\n        /* We don't already have a password to use, so prompt for one. */\n        if (data->id_cryptoctx->prompter == NULL)\n            return -1;\n        if (asprintf(&prompt, \"%s %s\", _(\"Pass phrase for\"),\n                     data->filename) < 0)\n            return -1;\n        rdat.data = buf;\n        rdat.length = size;\n        kprompt.prompt = prompt;\n        kprompt.hidden = 1;\n        kprompt.reply = &rdat;\n        prompt_type = KRB5_PROMPT_TYPE_PREAUTH;\n\n        /* PROMPTER_INVOCATION */\n        k5int_set_prompt_types(data->context, &prompt_type);\n        id_cryptoctx = data->id_cryptoctx;\n        retval = (data->id_cryptoctx->prompter)(data->context,\n                                                id_cryptoctx->prompter_data,\n                                                NULL, NULL, 1, &kprompt);\n        k5int_set_prompt_types(data->context, 0);\n        free(prompt);\n        if (retval != 0)\n            return -1;\n    } else {\n        /* Just use the already-supplied password. */\n        rdat.length = strlen(data->password);\n        if ((int)rdat.length >= size)\n            return -1;\n        snprintf(buf, size, \"%s\", data->password);\n    }\n    return (int)rdat.length;\n}\n\nstatic krb5_error_code\nget_key(krb5_context context, pkinit_identity_crypto_context id_cryptoctx,\n        char *filename, const char *fsname, EVP_PKEY **retkey,\n        const char *password)\n{\n    EVP_PKEY *pkey = NULL;\n    BIO *tmp = NULL;\n    struct get_key_cb_data cb_data;\n    int code;\n    krb5_error_code retval;\n\n    if (filename == NULL || retkey == NULL)\n        return EINVAL;\n\n    tmp = BIO_new(BIO_s_file());\n    if (tmp == NULL)\n        return ENOMEM;\n\n    code = BIO_read_filename(tmp, filename);\n    if (code == 0) {\n        retval = errno;\n        goto cleanup;\n    }\n    cb_data.context = context;\n    cb_data.id_cryptoctx = id_cryptoctx;\n    cb_data.filename = filename;\n    cb_data.fsname = fsname;\n    cb_data.password = password;\n    pkey = PEM_read_bio_PrivateKey(tmp, NULL, get_key_cb, &cb_data);\n    if (pkey == NULL && !id_cryptoctx->defer_id_prompt) {\n        retval = EIO;\n        pkiDebug(\"failed to read private key from %s\\n\", filename);\n        goto cleanup;\n    }\n    *retkey = pkey;\n    retval = 0;\ncleanup:\n    if (tmp != NULL)\n        BIO_free(tmp);\n    return retval;\n}\n\nstatic void\npkinit_fini_pkinit_oids(pkinit_plg_crypto_context ctx)\n{\n    if (ctx == NULL)\n        return;\n    ASN1_OBJECT_free(ctx->id_pkinit_san);\n    ASN1_OBJECT_free(ctx->id_pkinit_authData);\n    ASN1_OBJECT_free(ctx->id_pkinit_DHKeyData);\n    ASN1_OBJECT_free(ctx->id_pkinit_rkeyData);\n    ASN1_OBJECT_free(ctx->id_pkinit_KPClientAuth);\n    ASN1_OBJECT_free(ctx->id_pkinit_KPKdc);\n    ASN1_OBJECT_free(ctx->id_ms_kp_sc_logon);\n    ASN1_OBJECT_free(ctx->id_ms_san_upn);\n    ASN1_OBJECT_free(ctx->id_kp_serverAuth);\n}\n\n/* Construct an OpenSSL DH object for an Oakley group. */\nstatic DH *\nmake_oakley_dh(uint8_t *prime, size_t len)\n{\n    DH *dh = NULL;\n    BIGNUM *p = NULL, *q = NULL, *g = NULL;\n\n    p = BN_bin2bn(prime, len, NULL);\n    if (p == NULL)\n        goto cleanup;\n    q = BN_new();\n    if (q == NULL)\n        goto cleanup;\n    if (!BN_rshift1(q, p))\n        goto cleanup;\n    g = BN_new();\n    if (g == NULL)\n        goto cleanup;\n    if (!BN_set_word(g, DH_GENERATOR_2))\n        goto cleanup;\n\n    dh = DH_new();\n    if (dh == NULL)\n        goto cleanup;\n    DH_set0_pqg(dh, p, q, g);\n    p = g = q = NULL;\n\ncleanup:\n    BN_free(p);\n    BN_free(q);\n    BN_free(g);\n    return dh;\n}\n\nstatic krb5_error_code\npkinit_init_dh_params(pkinit_plg_crypto_context plgctx)\n{\n    krb5_error_code retval = ENOMEM;\n\n    plgctx->dh_1024 = make_oakley_dh(oakley_1024, sizeof(oakley_1024));\n    if (plgctx->dh_1024 == NULL)\n        goto cleanup;\n\n    plgctx->dh_2048 = make_oakley_dh(oakley_2048, sizeof(oakley_2048));\n    if (plgctx->dh_2048 == NULL)\n        goto cleanup;\n\n    plgctx->dh_4096 = make_oakley_dh(oakley_4096, sizeof(oakley_4096));\n    if (plgctx->dh_4096 == NULL)\n        goto cleanup;\n\n    retval = 0;\n\ncleanup:\n    if (retval)\n        pkinit_fini_dh_params(plgctx);\n\n    return retval;\n}\n\nstatic void\npkinit_fini_dh_params(pkinit_plg_crypto_context plgctx)\n{\n    if (plgctx->dh_1024 != NULL)\n        DH_free(plgctx->dh_1024);\n    if (plgctx->dh_2048 != NULL)\n        DH_free(plgctx->dh_2048);\n    if (plgctx->dh_4096 != NULL)\n        DH_free(plgctx->dh_4096);\n\n    plgctx->dh_1024 = plgctx->dh_2048 = plgctx->dh_4096 = NULL;\n}\n\nstatic krb5_error_code\npkinit_init_certs(pkinit_identity_crypto_context ctx)\n{\n    krb5_error_code retval = ENOMEM;\n    int i;\n\n    for (i = 0; i < MAX_CREDS_ALLOWED; i++)\n        ctx->creds[i] = NULL;\n    ctx->my_certs = NULL;\n    ctx->cert_index = 0;\n    ctx->my_key = NULL;\n    ctx->trustedCAs = NULL;\n    ctx->intermediateCAs = NULL;\n    ctx->revoked = NULL;\n\n    retval = 0;\n    return retval;\n}\n\nstatic void\npkinit_fini_certs(pkinit_identity_crypto_context ctx)\n{\n    if (ctx == NULL)\n        return;\n\n    if (ctx->my_certs != NULL)\n        sk_X509_pop_free(ctx->my_certs, X509_free);\n\n    if (ctx->my_key != NULL)\n        EVP_PKEY_free(ctx->my_key);\n\n    if (ctx->trustedCAs != NULL)\n        sk_X509_pop_free(ctx->trustedCAs, X509_free);\n\n    if (ctx->intermediateCAs != NULL)\n        sk_X509_pop_free(ctx->intermediateCAs, X509_free);\n\n    if (ctx->revoked != NULL)\n        sk_X509_CRL_pop_free(ctx->revoked, X509_CRL_free);\n}\n\nstatic krb5_error_code\npkinit_init_pkcs11(pkinit_identity_crypto_context ctx)\n{\n    krb5_error_code retval = ENOMEM;\n\n#ifndef WITHOUT_PKCS11\n    ctx->p11_module_name = strdup(PKCS11_MODNAME);\n    if (ctx->p11_module_name == NULL)\n        return retval;\n    ctx->p11_module = NULL;\n    ctx->slotid = PK_NOSLOT;\n    ctx->token_label = NULL;\n    ctx->cert_label = NULL;\n    ctx->session = CK_INVALID_HANDLE;\n    ctx->p11 = NULL;\n#endif\n    ctx->pkcs11_method = 0;\n\n    retval = 0;\n    return retval;\n}\n\nstatic void\npkinit_fini_pkcs11(pkinit_identity_crypto_context ctx)\n{\n#ifndef WITHOUT_PKCS11\n    if (ctx == NULL)\n        return;\n\n    if (ctx->p11 != NULL) {\n        if (ctx->session != CK_INVALID_HANDLE) {\n            ctx->p11->C_CloseSession(ctx->session);\n            ctx->session = CK_INVALID_HANDLE;\n        }\n        ctx->p11->C_Finalize(NULL_PTR);\n        ctx->p11 = NULL;\n    }\n    if (ctx->p11_module != NULL) {\n        pkinit_C_UnloadModule(ctx->p11_module);\n        ctx->p11_module = NULL;\n    }\n    free(ctx->p11_module_name);\n    free(ctx->token_label);\n    free(ctx->cert_id);\n    free(ctx->cert_label);\n#endif\n}\n\nkrb5_error_code\npkinit_identity_set_prompter(pkinit_identity_crypto_context id_cryptoctx,\n                             krb5_prompter_fct prompter,\n                             void *prompter_data)\n{\n    id_cryptoctx->prompter = prompter;\n    id_cryptoctx->prompter_data = prompter_data;\n\n    return 0;\n}\n\n/* Create a CMS ContentInfo of type oid containing the octet string in data. */\nstatic krb5_error_code\ncreate_contentinfo(krb5_context context, ASN1_OBJECT *oid,\n                   unsigned char *data, size_t data_len, PKCS7 **p7_out)\n{\n    PKCS7 *p7 = NULL;\n    ASN1_OCTET_STRING *ostr = NULL;\n\n    *p7_out = NULL;\n\n    ostr = ASN1_OCTET_STRING_new();\n    if (ostr == NULL)\n        goto oom;\n    if (!ASN1_OCTET_STRING_set(ostr, (unsigned char *)data, data_len))\n        goto oom;\n\n    p7 = PKCS7_new();\n    if (p7 == NULL)\n        goto oom;\n    p7->type = OBJ_dup(oid);\n    if (p7->type == NULL)\n        goto oom;\n\n    p7->d.other = ASN1_TYPE_new();\n    if (p7->d.other == NULL)\n        goto oom;\n    p7->d.other->type = V_ASN1_OCTET_STRING;\n    p7->d.other->value.octet_string = ostr;\n\n    *p7_out = p7;\n    return 0;\n\noom:\n    if (ostr != NULL)\n        ASN1_OCTET_STRING_free(ostr);\n    if (p7 != NULL)\n        PKCS7_free(p7);\n    return ENOMEM;\n}\n\nkrb5_error_code\ncms_contentinfo_create(krb5_context context,                          /* IN */\n                       pkinit_plg_crypto_context plg_cryptoctx,       /* IN */\n                       pkinit_req_crypto_context req_cryptoctx,       /* IN */\n                       pkinit_identity_crypto_context id_cryptoctx,   /* IN */\n                       int cms_msg_type,\n                       unsigned char *data, unsigned int data_len,\n                       unsigned char **out_data, unsigned int *out_data_len)\n{\n    krb5_error_code retval = ENOMEM;\n    ASN1_OBJECT *oid;\n    PKCS7 *p7 = NULL;\n    unsigned char *p;\n\n    /* Pick the correct oid for the eContentInfo. */\n    oid = pkinit_pkcs7type2oid(plg_cryptoctx, cms_msg_type);\n    if (oid == NULL)\n        goto cleanup;\n    retval = create_contentinfo(context, oid, data, data_len, &p7);\n    if (retval != 0)\n        goto cleanup;\n    *out_data_len = i2d_PKCS7(p7, NULL);\n    if (!(*out_data_len)) {\n        retval = oerr(context, 0, _(\"Failed to DER encode PKCS7\"));\n        goto cleanup;\n    }\n    retval = ENOMEM;\n    if ((p = *out_data = malloc(*out_data_len)) == NULL)\n        goto cleanup;\n\n    /* DER encode PKCS7 data */\n    retval = i2d_PKCS7(p7, &p);\n    if (!retval) {\n        retval = oerr(context, 0, _(\"Failed to DER encode PKCS7\"));\n        goto cleanup;\n    }\n    retval = 0;\ncleanup:\n    if (p7)\n        PKCS7_free(p7);\n    return retval;\n}\n\n\n\nkrb5_error_code\ncms_signeddata_create(krb5_context context,\n                      pkinit_plg_crypto_context plg_cryptoctx,\n                      pkinit_req_crypto_context req_cryptoctx,\n                      pkinit_identity_crypto_context id_cryptoctx,\n                      int cms_msg_type,\n                      int include_certchain,\n                      unsigned char *data,\n                      unsigned int data_len,\n                      unsigned char **signed_data,\n                      unsigned int *signed_data_len)\n{\n    krb5_error_code retval = ENOMEM;\n    PKCS7  *p7 = NULL, *inner_p7 = NULL;\n    PKCS7_SIGNED *p7s = NULL;\n    PKCS7_SIGNER_INFO *p7si = NULL;\n    unsigned char *p;\n    STACK_OF(X509) * cert_stack = NULL;\n    ASN1_OCTET_STRING *digest_attr = NULL;\n    EVP_MD_CTX *ctx;\n    const EVP_MD *md_tmp = NULL;\n    unsigned char md_data[EVP_MAX_MD_SIZE], md_data2[EVP_MAX_MD_SIZE];\n    unsigned char *digestInfo_buf = NULL, *abuf = NULL;\n    unsigned int md_len, md_len2, alen, digestInfo_len;\n    STACK_OF(X509_ATTRIBUTE) * sk;\n    unsigned char *sig = NULL;\n    unsigned int sig_len = 0;\n    X509_ALGOR *alg = NULL;\n    ASN1_OCTET_STRING *digest = NULL;\n    unsigned int alg_len = 0, digest_len = 0;\n    unsigned char *y = NULL;\n    X509 *cert = NULL;\n    ASN1_OBJECT *oid = NULL, *oid_copy;\n\n    /* Start creating PKCS7 data. */\n    if ((p7 = PKCS7_new()) == NULL)\n        goto cleanup;\n    p7->type = OBJ_nid2obj(NID_pkcs7_signed);\n\n    if ((p7s = PKCS7_SIGNED_new()) == NULL)\n        goto cleanup;\n    p7->d.sign = p7s;\n    if (!ASN1_INTEGER_set(p7s->version, 3))\n        goto cleanup;\n\n    /* pick the correct oid for the eContentInfo */\n    oid = pkinit_pkcs7type2oid(plg_cryptoctx, cms_msg_type);\n    if (oid == NULL)\n        goto cleanup;\n\n    if (id_cryptoctx->my_certs != NULL) {\n        /* create a cert chain that has at least the signer's certificate */\n        if ((cert_stack = sk_X509_new_null()) == NULL)\n            goto cleanup;\n\n        cert = sk_X509_value(id_cryptoctx->my_certs, id_cryptoctx->cert_index);\n        if (!include_certchain) {\n            pkiDebug(\"only including signer's certificate\\n\");\n            sk_X509_push(cert_stack, X509_dup(cert));\n        } else {\n            /* create a cert chain */\n            X509_STORE *certstore = NULL;\n            X509_STORE_CTX *certctx;\n            STACK_OF(X509) *certstack = NULL;\n            char buf[DN_BUF_LEN];\n            unsigned int i = 0, size = 0;\n\n            if ((certstore = X509_STORE_new()) == NULL)\n                goto cleanup;\n            pkiDebug(\"building certificate chain\\n\");\n            X509_STORE_set_verify_cb(certstore, openssl_callback);\n            certctx = X509_STORE_CTX_new();\n            if (certctx == NULL)\n                goto cleanup;\n            X509_STORE_CTX_init(certctx, certstore, cert,\n                                id_cryptoctx->intermediateCAs);\n            X509_STORE_CTX_trusted_stack(certctx, id_cryptoctx->trustedCAs);\n            if (!X509_verify_cert(certctx)) {\n                retval = oerr_cert(context, 0, certctx,\n                                   _(\"Failed to verify own certificate\"));\n                goto cleanup;\n            }\n            certstack = X509_STORE_CTX_get1_chain(certctx);\n            size = sk_X509_num(certstack);\n            pkiDebug(\"size of certificate chain = %d\\n\", size);\n            for(i = 0; i < size - 1; i++) {\n                X509 *x = sk_X509_value(certstack, i);\n                X509_NAME_oneline(X509_get_subject_name(x), buf, sizeof(buf));\n                pkiDebug(\"cert #%d: %s\\n\", i, buf);\n                sk_X509_push(cert_stack, X509_dup(x));\n            }\n            X509_STORE_CTX_free(certctx);\n            X509_STORE_free(certstore);\n            sk_X509_pop_free(certstack, X509_free);\n        }\n        p7s->cert = cert_stack;\n\n        /* fill-in PKCS7_SIGNER_INFO */\n        if ((p7si = PKCS7_SIGNER_INFO_new()) == NULL)\n            goto cleanup;\n        if (!ASN1_INTEGER_set(p7si->version, 1))\n            goto cleanup;\n        if (!X509_NAME_set(&p7si->issuer_and_serial->issuer,\n                           X509_get_issuer_name(cert)))\n            goto cleanup;\n        /* because ASN1_INTEGER_set is used to set a 'long' we will do\n         * things the ugly way. */\n        ASN1_INTEGER_free(p7si->issuer_and_serial->serial);\n        if (!(p7si->issuer_and_serial->serial =\n              ASN1_INTEGER_dup(X509_get_serialNumber(cert))))\n            goto cleanup;\n\n        /* will not fill-out EVP_PKEY because it's on the smartcard */\n\n        /* Set digest algs */\n        p7si->digest_alg->algorithm = OBJ_nid2obj(NID_sha1);\n\n        if (p7si->digest_alg->parameter != NULL)\n            ASN1_TYPE_free(p7si->digest_alg->parameter);\n        if ((p7si->digest_alg->parameter = ASN1_TYPE_new()) == NULL)\n            goto cleanup;\n        p7si->digest_alg->parameter->type = V_ASN1_NULL;\n\n        /* Set sig algs */\n        if (p7si->digest_enc_alg->parameter != NULL)\n            ASN1_TYPE_free(p7si->digest_enc_alg->parameter);\n        p7si->digest_enc_alg->algorithm = OBJ_nid2obj(NID_sha1WithRSAEncryption);\n        if (!(p7si->digest_enc_alg->parameter = ASN1_TYPE_new()))\n            goto cleanup;\n        p7si->digest_enc_alg->parameter->type = V_ASN1_NULL;\n\n        /* add signed attributes */\n        /* compute sha1 digest over the EncapsulatedContentInfo */\n        ctx = EVP_MD_CTX_new();\n        if (ctx == NULL)\n            goto cleanup;\n        EVP_DigestInit_ex(ctx, EVP_sha1(), NULL);\n        EVP_DigestUpdate(ctx, data, data_len);\n        md_tmp = EVP_MD_CTX_md(ctx);\n        EVP_DigestFinal_ex(ctx, md_data, &md_len);\n        EVP_MD_CTX_free(ctx);\n\n        /* create a message digest attr */\n        digest_attr = ASN1_OCTET_STRING_new();\n        ASN1_OCTET_STRING_set(digest_attr, md_data, (int)md_len);\n        PKCS7_add_signed_attribute(p7si, NID_pkcs9_messageDigest,\n                                   V_ASN1_OCTET_STRING, (char *)digest_attr);\n\n        /* create a content-type attr */\n        oid_copy = OBJ_dup(oid);\n        if (oid_copy == NULL)\n            goto cleanup2;\n        PKCS7_add_signed_attribute(p7si, NID_pkcs9_contentType,\n                                   V_ASN1_OBJECT, oid_copy);\n\n        /* create the signature over signed attributes. get DER encoded value */\n        /* This is the place where smartcard signature needs to be calculated */\n        sk = p7si->auth_attr;\n        alen = ASN1_item_i2d((ASN1_VALUE *)sk, &abuf,\n                             ASN1_ITEM_rptr(PKCS7_ATTR_SIGN));\n        if (abuf == NULL)\n            goto cleanup2;\n\n#ifndef WITHOUT_PKCS11\n        /* Some tokens can only do RSAEncryption without sha1 hash */\n        /* to compute sha1WithRSAEncryption, encode the algorithm ID for the hash\n         * function and the hash value into an ASN.1 value of type DigestInfo\n         * DigestInfo::=SEQUENCE {\n         *  digestAlgorithm  AlgorithmIdentifier,\n         *  digest OCTET STRING }\n         */\n        if (id_cryptoctx->pkcs11_method == 1 &&\n            id_cryptoctx->mech == CKM_RSA_PKCS) {\n            pkiDebug(\"mech = CKM_RSA_PKCS\\n\");\n            ctx = EVP_MD_CTX_new();\n            if (ctx == NULL)\n                goto cleanup;\n            EVP_DigestInit_ex(ctx, md_tmp, NULL);\n            EVP_DigestUpdate(ctx, abuf, alen);\n            EVP_DigestFinal_ex(ctx, md_data2, &md_len2);\n            EVP_MD_CTX_free(ctx);\n\n            alg = X509_ALGOR_new();\n            if (alg == NULL)\n                goto cleanup2;\n            X509_ALGOR_set0(alg, OBJ_nid2obj(NID_sha1), V_ASN1_NULL, NULL);\n            alg_len = i2d_X509_ALGOR(alg, NULL);\n\n            digest = ASN1_OCTET_STRING_new();\n            if (digest == NULL)\n                goto cleanup2;\n            ASN1_OCTET_STRING_set(digest, md_data2, (int)md_len2);\n            digest_len = i2d_ASN1_OCTET_STRING(digest, NULL);\n\n            digestInfo_len = ASN1_object_size(1, (int)(alg_len + digest_len),\n                                              V_ASN1_SEQUENCE);\n            y = digestInfo_buf = malloc(digestInfo_len);\n            if (digestInfo_buf == NULL)\n                goto cleanup2;\n            ASN1_put_object(&y, 1, (int)(alg_len + digest_len), V_ASN1_SEQUENCE,\n                            V_ASN1_UNIVERSAL);\n            i2d_X509_ALGOR(alg, &y);\n            i2d_ASN1_OCTET_STRING(digest, &y);\n#ifdef DEBUG_SIG\n            pkiDebug(\"signing buffer\\n\");\n            print_buffer(digestInfo_buf, digestInfo_len);\n            print_buffer_bin(digestInfo_buf, digestInfo_len, \"/tmp/pkcs7_tosign\");\n#endif\n            retval = pkinit_sign_data(context, id_cryptoctx, digestInfo_buf,\n                                      digestInfo_len, &sig, &sig_len);\n        } else\n#endif\n        {\n            pkiDebug(\"mech = %s\\n\",\n                     id_cryptoctx->pkcs11_method == 1 ? \"CKM_SHA1_RSA_PKCS\" : \"FS\");\n            retval = pkinit_sign_data(context, id_cryptoctx, abuf, alen,\n                                      &sig, &sig_len);\n        }\n#ifdef DEBUG_SIG\n        print_buffer(sig, sig_len);\n#endif\n        free(abuf);\n        if (retval)\n            goto cleanup2;\n\n        /* Add signature */\n        if (!ASN1_STRING_set(p7si->enc_digest, (unsigned char *) sig,\n                             (int)sig_len)) {\n            retval = oerr(context, 0, _(\"Failed to add digest attribute\"));\n            goto cleanup2;\n        }\n        /* adder signer_info to pkcs7 signed */\n        if (!PKCS7_add_signer(p7, p7si))\n            goto cleanup2;\n    } /* we have a certificate */\n\n    /* start on adding data to the pkcs7 signed */\n    retval = create_contentinfo(context, oid, data, data_len, &inner_p7);\n    if (p7s->contents != NULL)\n        PKCS7_free(p7s->contents);\n    p7s->contents = inner_p7;\n\n    *signed_data_len = i2d_PKCS7(p7, NULL);\n    if (!(*signed_data_len)) {\n        retval = oerr(context, 0, _(\"Failed to DER encode PKCS7\"));\n        goto cleanup2;\n    }\n    retval = ENOMEM;\n    if ((p = *signed_data = malloc(*signed_data_len)) == NULL)\n        goto cleanup2;\n\n    /* DER encode PKCS7 data */\n    retval = i2d_PKCS7(p7, &p);\n    if (!retval) {\n        retval = oerr(context, 0, _(\"Failed to DER encode PKCS7\"));\n        goto cleanup2;\n    }\n    retval = 0;\n\n#ifdef DEBUG_ASN1\n    if (cms_msg_type == CMS_SIGN_CLIENT) {\n        print_buffer_bin(*signed_data, *signed_data_len,\n                         \"/tmp/client_pkcs7_signeddata\");\n    } else {\n        print_buffer_bin(*signed_data, *signed_data_len,\n                         \"/tmp/kdc_pkcs7_signeddata\");\n    }\n#endif\n\ncleanup2:\n    if (p7si) {\n#ifndef WITHOUT_PKCS11\n        if (id_cryptoctx->pkcs11_method == 1 &&\n            id_cryptoctx->mech == CKM_RSA_PKCS) {\n            free(digestInfo_buf);\n            if (digest != NULL)\n                ASN1_OCTET_STRING_free(digest);\n        }\n#endif\n        if (alg != NULL)\n            X509_ALGOR_free(alg);\n    }\ncleanup:\n    if (p7 != NULL)\n        PKCS7_free(p7);\n    free(sig);\n\n    return retval;\n}\n\nkrb5_error_code\ncms_signeddata_verify(krb5_context context,\n                      pkinit_plg_crypto_context plgctx,\n                      pkinit_req_crypto_context reqctx,\n                      pkinit_identity_crypto_context idctx,\n                      int cms_msg_type,\n                      int require_crl_checking,\n                      unsigned char *signed_data,\n                      unsigned int signed_data_len,\n                      unsigned char **data,\n                      unsigned int *data_len,\n                      unsigned char **authz_data,\n                      unsigned int *authz_data_len,\n                      int *is_signed)\n{\n    /*\n     * Warning: Since most openssl functions do not set retval, large chunks of\n     * this function assume that retval is always a failure and may go to\n     * cleanup without setting retval explicitly. Make sure retval is not set\n     * to 0 or errors such as signature verification failure may be converted\n     * to success with significant security consequences.\n     */\n    krb5_error_code retval = KRB5KDC_ERR_PREAUTH_FAILED;\n    CMS_ContentInfo *cms = NULL;\n    BIO *out = NULL;\n    int flags = CMS_NO_SIGNER_CERT_VERIFY;\n    int valid_oid = 0;\n    unsigned int i = 0;\n    unsigned int vflags = 0, size = 0;\n    const unsigned char *p = signed_data;\n    STACK_OF(CMS_SignerInfo) *si_sk = NULL;\n    CMS_SignerInfo *si = NULL;\n    X509 *x = NULL;\n    X509_STORE *store = NULL;\n    X509_STORE_CTX *cert_ctx;\n    STACK_OF(X509) *signerCerts = NULL;\n    STACK_OF(X509) *intermediateCAs = NULL;\n    STACK_OF(X509_CRL) *signerRevoked = NULL;\n    STACK_OF(X509_CRL) *revoked = NULL;\n    STACK_OF(X509) *verified_chain = NULL;\n    ASN1_OBJECT *oid = NULL;\n    const ASN1_OBJECT *type = NULL, *etype = NULL;\n    ASN1_OCTET_STRING **octets;\n    krb5_external_principal_identifier **krb5_verified_chain = NULL;\n    krb5_data *authz = NULL;\n    char buf[DN_BUF_LEN];\n\n#ifdef DEBUG_ASN1\n    print_buffer_bin(signed_data, signed_data_len,\n                     \"/tmp/client_received_pkcs7_signeddata\");\n#endif\n    if (is_signed)\n        *is_signed = 1;\n\n    oid = pkinit_pkcs7type2oid(plgctx, cms_msg_type);\n    if (oid == NULL)\n        goto cleanup;\n\n    /* decode received CMS message */\n    if ((cms = d2i_CMS_ContentInfo(NULL, &p, (int)signed_data_len)) == NULL) {\n        retval = oerr(context, 0, _(\"Failed to decode CMS message\"));\n        goto cleanup;\n    }\n    etype = CMS_get0_eContentType(cms);\n\n    /*\n     * Prior to 1.10 the MIT client incorrectly emitted the pkinit structure\n     * directly in a CMS ContentInfo rather than using SignedData with no\n     * signers. Handle that case.\n     */\n    type = CMS_get0_type(cms);\n    if (is_signed && !OBJ_cmp(type, oid)) {\n        unsigned char *d;\n        *is_signed = 0;\n        octets = pkinit_CMS_get0_content_data(cms);\n        if (!octets || ((*octets)->type != V_ASN1_OCTET_STRING)) {\n            retval = KRB5KDC_ERR_PREAUTH_FAILED;\n            krb5_set_error_message(context, retval,\n                                   _(\"Invalid pkinit packet: octet string \"\n                                     \"expected\"));\n            goto cleanup;\n        }\n        *data_len = ASN1_STRING_length(*octets);\n        d = malloc(*data_len);\n        if (d == NULL) {\n            retval = ENOMEM;\n            goto cleanup;\n        }\n        memcpy(d, ASN1_STRING_get0_data(*octets), *data_len);\n        *data = d;\n        goto out;\n    } else {\n        /* Verify that the received message is CMS SignedData message. */\n        if (OBJ_obj2nid(type) != NID_pkcs7_signed) {\n            pkiDebug(\"Expected id-signedData CMS msg (received type = %d)\\n\",\n                     OBJ_obj2nid(type));\n            krb5_set_error_message(context, retval, _(\"wrong oid\\n\"));\n            goto cleanup;\n        }\n    }\n\n    /* setup to verify X509 certificate used to sign CMS message */\n    if (!(store = X509_STORE_new()))\n        goto cleanup;\n\n    /* check if we are inforcing CRL checking */\n    vflags = X509_V_FLAG_CRL_CHECK|X509_V_FLAG_CRL_CHECK_ALL;\n    if (require_crl_checking)\n        X509_STORE_set_verify_cb(store, openssl_callback);\n    else\n        X509_STORE_set_verify_cb(store, openssl_callback_ignore_crls);\n    X509_STORE_set_flags(store, vflags);\n\n    /*\n     * Get the signer's information from the CMS message.  Match signer ID\n     * against anchors and intermediate CAs in case no certs are present in the\n     * SignedData.  If we start sending kdcPkId values in requests, we'll need\n     * to match against the source of that information too.\n     */\n    CMS_set1_signers_certs(cms, NULL, 0);\n    CMS_set1_signers_certs(cms, idctx->trustedCAs, CMS_NOINTERN);\n    CMS_set1_signers_certs(cms, idctx->intermediateCAs, CMS_NOINTERN);\n    if (((si_sk = CMS_get0_SignerInfos(cms)) == NULL) ||\n        ((si = sk_CMS_SignerInfo_value(si_sk, 0)) == NULL)) {\n        /* Not actually signed; anonymous case */\n        if (!is_signed)\n            goto cleanup;\n        *is_signed = 0;\n        /* We cannot use CMS_dataInit because there may be no digest */\n        octets = pkinit_CMS_get0_content_signed(cms);\n        if (octets)\n            out = BIO_new_mem_buf((*octets)->data, (*octets)->length);\n        if (out == NULL)\n            goto cleanup;\n    } else {\n        pkinit_CMS_SignerInfo_get_cert(cms, si, &x);\n        if (x == NULL)\n            goto cleanup;\n\n        /* create available CRL information (get local CRLs and include CRLs\n         * received in the CMS message\n         */\n        signerRevoked = CMS_get1_crls(cms);\n        if (idctx->revoked == NULL)\n            revoked = signerRevoked;\n        else if (signerRevoked == NULL)\n            revoked = idctx->revoked;\n        else {\n            size = sk_X509_CRL_num(idctx->revoked);\n            revoked = sk_X509_CRL_new_null();\n            for (i = 0; i < size; i++)\n                sk_X509_CRL_push(revoked, sk_X509_CRL_value(idctx->revoked, i));\n            size = sk_X509_CRL_num(signerRevoked);\n            for (i = 0; i < size; i++)\n                sk_X509_CRL_push(revoked, sk_X509_CRL_value(signerRevoked, i));\n        }\n\n        /* create available intermediate CAs chains (get local intermediateCAs and\n         * include the CA chain received in the CMS message\n         */\n        signerCerts = CMS_get1_certs(cms);\n        if (idctx->intermediateCAs == NULL)\n            intermediateCAs = signerCerts;\n        else if (signerCerts == NULL)\n            intermediateCAs = idctx->intermediateCAs;\n        else {\n            size = sk_X509_num(idctx->intermediateCAs);\n            intermediateCAs = sk_X509_new_null();\n            for (i = 0; i < size; i++) {\n                sk_X509_push(intermediateCAs,\n                             sk_X509_value(idctx->intermediateCAs, i));\n            }\n            size = sk_X509_num(signerCerts);\n            for (i = 0; i < size; i++) {\n                sk_X509_push(intermediateCAs, sk_X509_value(signerCerts, i));\n            }\n        }\n\n        /* initialize x509 context with the received certificate and\n         * trusted and intermediate CA chains and CRLs\n         */\n        cert_ctx = X509_STORE_CTX_new();\n        if (cert_ctx == NULL)\n            goto cleanup;\n        if (!X509_STORE_CTX_init(cert_ctx, store, x, intermediateCAs))\n            goto cleanup;\n\n        X509_STORE_CTX_set0_crls(cert_ctx, revoked);\n\n        /* add trusted CAs certificates for cert verification */\n        if (idctx->trustedCAs != NULL)\n            X509_STORE_CTX_trusted_stack(cert_ctx, idctx->trustedCAs);\n        else {\n            pkiDebug(\"unable to find any trusted CAs\\n\");\n            goto cleanup;\n        }\n#ifdef DEBUG_CERTCHAIN\n        if (intermediateCAs != NULL) {\n            size = sk_X509_num(intermediateCAs);\n            pkiDebug(\"untrusted cert chain of size %d\\n\", size);\n            for (i = 0; i < size; i++) {\n                X509_NAME_oneline(X509_get_subject_name(\n                                      sk_X509_value(intermediateCAs, i)), buf, sizeof(buf));\n                pkiDebug(\"cert #%d: %s\\n\", i, buf);\n            }\n        }\n        if (idctx->trustedCAs != NULL) {\n            size = sk_X509_num(idctx->trustedCAs);\n            pkiDebug(\"trusted cert chain of size %d\\n\", size);\n            for (i = 0; i < size; i++) {\n                X509_NAME_oneline(X509_get_subject_name(\n                                      sk_X509_value(idctx->trustedCAs, i)), buf, sizeof(buf));\n                pkiDebug(\"cert #%d: %s\\n\", i, buf);\n            }\n        }\n        if (revoked != NULL) {\n            size = sk_X509_CRL_num(revoked);\n            pkiDebug(\"CRL chain of size %d\\n\", size);\n            for (i = 0; i < size; i++) {\n                X509_CRL *crl = sk_X509_CRL_value(revoked, i);\n                X509_NAME_oneline(X509_CRL_get_issuer(crl), buf, sizeof(buf));\n                pkiDebug(\"crls by CA #%d: %s\\n\", i , buf);\n            }\n        }\n#endif\n\n        i = X509_verify_cert(cert_ctx);\n        if (i <= 0) {\n            int j = X509_STORE_CTX_get_error(cert_ctx);\n            X509 *cert;\n\n            cert = X509_STORE_CTX_get_current_cert(cert_ctx);\n            reqctx->received_cert = X509_dup(cert);\n            switch(j) {\n            case X509_V_ERR_CERT_REVOKED:\n                retval = KRB5KDC_ERR_REVOKED_CERTIFICATE;\n                break;\n            case X509_V_ERR_UNABLE_TO_GET_CRL:\n                retval = KRB5KDC_ERR_REVOCATION_STATUS_UNKNOWN;\n                break;\n            case X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT:\n            case X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT_LOCALLY:\n                retval = KRB5KDC_ERR_CANT_VERIFY_CERTIFICATE;\n                break;\n            default:\n                retval = KRB5KDC_ERR_INVALID_CERTIFICATE;\n            }\n            (void)oerr_cert(context, retval, cert_ctx,\n                            _(\"Failed to verify received certificate\"));\n            if (reqctx->received_cert == NULL)\n                strlcpy(buf, \"(none)\", sizeof(buf));\n            else\n                X509_NAME_oneline(X509_get_subject_name(reqctx->received_cert),\n                                  buf, sizeof(buf));\n            pkiDebug(\"problem with cert DN = %s (error=%d) %s\\n\", buf, j,\n                     X509_verify_cert_error_string(j));\n#ifdef DEBUG_CERTCHAIN\n            size = sk_X509_num(signerCerts);\n            pkiDebug(\"received cert chain of size %d\\n\", size);\n            for (j = 0; j < size; j++) {\n                X509 *tmp_cert = sk_X509_value(signerCerts, j);\n                X509_NAME_oneline(X509_get_subject_name(tmp_cert), buf, sizeof(buf));\n                pkiDebug(\"cert #%d: %s\\n\", j, buf);\n            }\n#endif\n        } else {\n            /* retrieve verified certificate chain */\n            if (cms_msg_type == CMS_SIGN_CLIENT)\n                verified_chain = X509_STORE_CTX_get1_chain(cert_ctx);\n        }\n        X509_STORE_CTX_free(cert_ctx);\n        if (i <= 0)\n            goto cleanup;\n        out = BIO_new(BIO_s_mem());\n        if (CMS_verify(cms, NULL, store, NULL, out, flags) == 0) {\n            unsigned long err = ERR_peek_error();\n            switch(ERR_GET_REASON(err)) {\n            case PKCS7_R_DIGEST_FAILURE:\n                retval = KRB5KDC_ERR_DIGEST_IN_SIGNED_DATA_NOT_ACCEPTED;\n                break;\n            case PKCS7_R_SIGNATURE_FAILURE:\n            default:\n                retval = KRB5KDC_ERR_INVALID_SIG;\n            }\n            (void)oerr(context, retval, _(\"Failed to verify CMS message\"));\n            goto cleanup;\n        }\n    } /* message was signed */\n    if (!OBJ_cmp(etype, oid))\n        valid_oid = 1;\n\n    if (valid_oid)\n        pkiDebug(\"CMS Verification successful\\n\");\n    else {\n        pkiDebug(\"wrong oid in eContentType\\n\");\n        print_buffer(OBJ_get0_data(etype), OBJ_length(etype));\n        retval = KRB5KDC_ERR_PREAUTH_FAILED;\n        krb5_set_error_message(context, retval, \"wrong oid\\n\");\n        goto cleanup;\n    }\n\n    /* transfer the data from CMS message into return buffer */\n    for (size = 0;;) {\n        int remain;\n        retval = ENOMEM;\n        if ((*data = realloc(*data, size + 1024 * 10)) == NULL)\n            goto cleanup;\n        remain = BIO_read(out, &((*data)[size]), 1024 * 10);\n        if (remain <= 0)\n            break;\n        else\n            size += remain;\n    }\n    *data_len = size;\n\n    if (x) {\n        reqctx->received_cert = X509_dup(x);\n\n        /* generate authorization data */\n        if (cms_msg_type == CMS_SIGN_CLIENT) {\n\n            if (authz_data == NULL || authz_data_len == NULL)\n                goto out;\n\n            *authz_data = NULL;\n            retval = create_identifiers_from_stack(verified_chain,\n                                                   &krb5_verified_chain);\n            if (retval) {\n                pkiDebug(\"create_identifiers_from_stack failed\\n\");\n                goto cleanup;\n            }\n\n            retval = k5int_encode_krb5_td_trusted_certifiers((krb5_external_principal_identifier *const *)krb5_verified_chain, &authz);\n            if (retval) {\n                pkiDebug(\"encode_krb5_td_trusted_certifiers failed\\n\");\n                goto cleanup;\n            }\n#ifdef DEBUG_ASN1\n            print_buffer_bin((unsigned char *)authz->data, authz->length,\n                             \"/tmp/kdc_ad_initial_verified_cas\");\n#endif\n            *authz_data = malloc(authz->length);\n            if (*authz_data == NULL) {\n                retval = ENOMEM;\n                goto cleanup;\n            }\n            memcpy(*authz_data, authz->data, authz->length);\n            *authz_data_len = authz->length;\n        }\n    }\nout:\n    retval = 0;\n\ncleanup:\n    if (out != NULL)\n        BIO_free(out);\n    if (store != NULL)\n        X509_STORE_free(store);\n    if (cms != NULL) {\n        if (signerCerts != NULL)\n            pkinit_CMS_free1_certs(signerCerts);\n        if (idctx->intermediateCAs != NULL && signerCerts)\n            sk_X509_free(intermediateCAs);\n        if (signerRevoked != NULL)\n            pkinit_CMS_free1_crls(signerRevoked);\n        if (idctx->revoked != NULL && signerRevoked)\n            sk_X509_CRL_free(revoked);\n        CMS_ContentInfo_free(cms);\n    }\n    if (verified_chain != NULL)\n        sk_X509_pop_free(verified_chain, X509_free);\n    if (krb5_verified_chain != NULL)\n        free_krb5_external_principal_identifier(&krb5_verified_chain);\n    if (authz != NULL)\n        krb5_free_data(context, authz);\n\n    return retval;\n}\n\nkrb5_error_code\ncms_envelopeddata_create(krb5_context context,\n                         pkinit_plg_crypto_context plgctx,\n                         pkinit_req_crypto_context reqctx,\n                         pkinit_identity_crypto_context idctx,\n                         krb5_preauthtype pa_type,\n                         int include_certchain,\n                         unsigned char *key_pack,\n                         unsigned int key_pack_len,\n                         unsigned char **out,\n                         unsigned int *out_len)\n{\n\n    krb5_error_code retval = ENOMEM;\n    PKCS7 *p7 = NULL;\n    BIO *in = NULL;\n    unsigned char *p = NULL, *signed_data = NULL, *enc_data = NULL;\n    int signed_data_len = 0, enc_data_len = 0, flags = PKCS7_BINARY;\n    STACK_OF(X509) *encerts = NULL;\n    const EVP_CIPHER *cipher = NULL;\n\n    retval = cms_signeddata_create(context, plgctx, reqctx, idctx,\n                                   CMS_ENVEL_SERVER, include_certchain,\n                                   key_pack, key_pack_len, &signed_data,\n                                   (unsigned int *)&signed_data_len);\n    if (retval) {\n        pkiDebug(\"failed to create pkcs7 signed data\\n\");\n        goto cleanup;\n    }\n\n    /* check we have client's certificate */\n    if (reqctx->received_cert == NULL) {\n        retval = KRB5KDC_ERR_PREAUTH_FAILED;\n        goto cleanup;\n    }\n    encerts = sk_X509_new_null();\n    sk_X509_push(encerts, reqctx->received_cert);\n\n    cipher = EVP_des_ede3_cbc();\n    in = BIO_new(BIO_s_mem());\n    prepare_enc_data(signed_data, signed_data_len, &enc_data,\n                     &enc_data_len);\n    retval = BIO_write(in, enc_data, enc_data_len);\n    if (retval != enc_data_len) {\n        pkiDebug(\"BIO_write only wrote %d\\n\", retval);\n        goto cleanup;\n    }\n\n    p7 = PKCS7_encrypt(encerts, in, cipher, flags);\n    if (p7 == NULL) {\n        retval = oerr(context, 0, _(\"Failed to encrypt PKCS7 object\"));\n        goto cleanup;\n    }\n    p7->d.enveloped->enc_data->content_type = OBJ_nid2obj(NID_pkcs7_signed);\n\n    *out_len = i2d_PKCS7(p7, NULL);\n    if (!*out_len || (p = *out = malloc(*out_len)) == NULL) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n    retval = i2d_PKCS7(p7, &p);\n    if (!retval) {\n        retval = oerr(context, 0, _(\"Failed to DER encode PKCS7\"));\n        goto cleanup;\n    }\n    retval = 0;\n\n#ifdef DEBUG_ASN1\n    print_buffer_bin(*out, *out_len, \"/tmp/kdc_enveloped_data\");\n#endif\n\ncleanup:\n    if (p7 != NULL)\n        PKCS7_free(p7);\n    if (in != NULL)\n        BIO_free(in);\n    free(signed_data);\n    free(enc_data);\n    if (encerts != NULL)\n        sk_X509_free(encerts);\n\n    return retval;\n}\n\nkrb5_error_code\ncms_envelopeddata_verify(krb5_context context,\n                         pkinit_plg_crypto_context plg_cryptoctx,\n                         pkinit_req_crypto_context req_cryptoctx,\n                         pkinit_identity_crypto_context id_cryptoctx,\n                         krb5_preauthtype pa_type,\n                         int require_crl_checking,\n                         unsigned char *enveloped_data,\n                         unsigned int enveloped_data_len,\n                         unsigned char **data,\n                         unsigned int *data_len)\n{\n    krb5_error_code retval = KRB5KDC_ERR_PREAUTH_FAILED;\n    PKCS7 *p7 = NULL;\n    const unsigned char *p = enveloped_data;\n    unsigned int tmp_buf_len = 0, tmp_buf2_len = 0, vfy_buf_len = 0;\n    unsigned char *tmp_buf = NULL, *tmp_buf2 = NULL, *vfy_buf = NULL;\n\n#ifdef DEBUG_ASN1\n    print_buffer_bin(enveloped_data, enveloped_data_len,\n                     \"/tmp/client_envelopeddata\");\n#endif\n    /* decode received PKCS7 message */\n    if ((p7 = d2i_PKCS7(NULL, &p, (int)enveloped_data_len)) == NULL) {\n        retval = oerr(context, 0, _(\"Failed to decode PKCS7\"));\n        goto cleanup;\n    }\n\n    /* verify that the received message is PKCS7 EnvelopedData message */\n    if (OBJ_obj2nid(p7->type) != NID_pkcs7_enveloped) {\n        pkiDebug(\"Expected id-enveloped PKCS7 msg (received type = %d)\\n\",\n                 OBJ_obj2nid(p7->type));\n        krb5_set_error_message(context, retval, \"wrong oid\\n\");\n        goto cleanup;\n    }\n\n    /* decrypt received PKCS7 message */\n    if (pkcs7_decrypt(context, id_cryptoctx, p7, &tmp_buf, &tmp_buf_len)) {\n        pkiDebug(\"PKCS7 decryption successful\\n\");\n    } else {\n        retval = oerr(context, 0, _(\"Failed to decrypt PKCS7 message\"));\n        goto cleanup;\n    }\n\n#ifdef DEBUG_ASN1\n    print_buffer_bin(tmp_buf, tmp_buf_len, \"/tmp/client_enc_keypack\");\n#endif\n    /* verify PKCS7 SignedData message */\n    /* Wrap the signed data to make decoding easier in the verify routine. */\n    retval = wrap_signeddata(tmp_buf, tmp_buf_len, &tmp_buf2, &tmp_buf2_len);\n    if (retval) {\n        pkiDebug(\"failed to encode signeddata\\n\");\n        goto cleanup;\n    }\n    vfy_buf = tmp_buf2;\n    vfy_buf_len = tmp_buf2_len;\n\n#ifdef DEBUG_ASN1\n    print_buffer_bin(vfy_buf, vfy_buf_len, \"/tmp/client_enc_keypack2\");\n#endif\n\n    retval = cms_signeddata_verify(context, plg_cryptoctx, req_cryptoctx,\n                                   id_cryptoctx, CMS_ENVEL_SERVER,\n                                   require_crl_checking,\n                                   vfy_buf, vfy_buf_len,\n                                   data, data_len, NULL, NULL, NULL);\n\n    if (!retval)\n        pkiDebug(\"PKCS7 Verification Success\\n\");\n    else {\n        pkiDebug(\"PKCS7 Verification Failure\\n\");\n        goto cleanup;\n    }\n\n    retval = 0;\n\ncleanup:\n\n    if (p7 != NULL)\n        PKCS7_free(p7);\n    free(tmp_buf);\n    free(tmp_buf2);\n\n    return retval;\n}\n\nstatic krb5_error_code\ncrypto_retrieve_X509_sans(krb5_context context,\n                          pkinit_plg_crypto_context plgctx,\n                          pkinit_req_crypto_context reqctx,\n                          X509 *cert,\n                          krb5_principal **princs_ret, char ***upn_ret,\n                          unsigned char ***dns_ret)\n{\n    krb5_error_code retval = EINVAL;\n    char buf[DN_BUF_LEN];\n    int p = 0, u = 0, d = 0, ret = 0, l;\n    krb5_principal *princs = NULL;\n    char **upns = NULL;\n    unsigned char **dnss = NULL;\n    unsigned int i, num_found = 0, num_sans = 0;\n    X509_EXTENSION *ext = NULL;\n    GENERAL_NAMES *ialt = NULL;\n    GENERAL_NAME *gen = NULL;\n\n    if (princs_ret != NULL)\n        *princs_ret = NULL;\n    if (upn_ret != NULL)\n        *upn_ret = NULL;\n    if (dns_ret != NULL)\n        *dns_ret = NULL;\n\n    if (princs_ret == NULL && upn_ret == NULL && dns_ret == NULL) {\n        pkiDebug(\"%s: nowhere to return any values!\\n\", __FUNCTION__);\n        return retval;\n    }\n\n    if (cert == NULL) {\n        pkiDebug(\"%s: no certificate!\\n\", __FUNCTION__);\n        return retval;\n    }\n\n    X509_NAME_oneline(X509_get_subject_name(cert),\n                      buf, sizeof(buf));\n    pkiDebug(\"%s: looking for SANs in cert = %s\\n\", __FUNCTION__, buf);\n\n    l = X509_get_ext_by_NID(cert, NID_subject_alt_name, -1);\n    if (l < 0)\n        return 0;\n\n    if (!(ext = X509_get_ext(cert, l)) || !(ialt = X509V3_EXT_d2i(ext))) {\n        pkiDebug(\"%s: found no subject alt name extensions\\n\", __FUNCTION__);\n        goto cleanup;\n    }\n    num_sans = sk_GENERAL_NAME_num(ialt);\n\n    pkiDebug(\"%s: found %d subject alt name extension(s)\\n\", __FUNCTION__,\n             num_sans);\n\n    /* OK, we're likely returning something. Allocate return values */\n    if (princs_ret != NULL) {\n        princs = calloc(num_sans + 1, sizeof(krb5_principal));\n        if (princs == NULL) {\n            retval = ENOMEM;\n            goto cleanup;\n        }\n    }\n    if (upn_ret != NULL) {\n        upns = calloc(num_sans + 1, sizeof(*upns));\n        if (upns == NULL) {\n            retval = ENOMEM;\n            goto cleanup;\n        }\n    }\n    if (dns_ret != NULL) {\n        dnss = calloc(num_sans + 1, sizeof(*dnss));\n        if (dnss == NULL) {\n            retval = ENOMEM;\n            goto cleanup;\n        }\n    }\n\n    for (i = 0; i < num_sans; i++) {\n        krb5_data name = { 0, 0, NULL };\n\n        gen = sk_GENERAL_NAME_value(ialt, i);\n        switch (gen->type) {\n        case GEN_OTHERNAME:\n            name.length = gen->d.otherName->value->value.sequence->length;\n            name.data = (char *)gen->d.otherName->value->value.sequence->data;\n            if (princs != NULL &&\n                OBJ_cmp(plgctx->id_pkinit_san,\n                        gen->d.otherName->type_id) == 0) {\n#ifdef DEBUG_ASN1\n                print_buffer_bin((unsigned char *)name.data, name.length,\n                                 \"/tmp/pkinit_san\");\n#endif\n                ret = k5int_decode_krb5_principal_name(&name, &princs[p]);\n                if (ret) {\n                    pkiDebug(\"%s: failed decoding pkinit san value\\n\",\n                             __FUNCTION__);\n                } else {\n                    p++;\n                    num_found++;\n                }\n            } else if (upns != NULL &&\n                       OBJ_cmp(plgctx->id_ms_san_upn,\n                               gen->d.otherName->type_id) == 0) {\n                /* Prevent abuse of embedded null characters. */\n                if (memchr(name.data, '\\0', name.length))\n                    break;\n                upns[u] = k5memdup0(name.data, name.length, &ret);\n                if (upns[u] == NULL)\n                    goto cleanup;\n            } else {\n                pkiDebug(\"%s: unrecognized othername oid in SAN\\n\",\n                         __FUNCTION__);\n                continue;\n            }\n\n            break;\n        case GEN_DNS:\n            if (dnss != NULL) {\n                /* Prevent abuse of embedded null characters. */\n                if (memchr(gen->d.dNSName->data, '\\0', gen->d.dNSName->length))\n                    break;\n                pkiDebug(\"%s: found dns name = %s\\n\", __FUNCTION__,\n                         gen->d.dNSName->data);\n                dnss[d] = (unsigned char *)\n                    strdup((char *)gen->d.dNSName->data);\n                if (dnss[d] == NULL) {\n                    pkiDebug(\"%s: failed to duplicate dns name\\n\",\n                             __FUNCTION__);\n                } else {\n                    d++;\n                    num_found++;\n                }\n            }\n            break;\n        default:\n            pkiDebug(\"%s: SAN type = %d expecting %d\\n\", __FUNCTION__,\n                     gen->type, GEN_OTHERNAME);\n        }\n    }\n    sk_GENERAL_NAME_pop_free(ialt, GENERAL_NAME_free);\n\n    retval = 0;\n    if (princs != NULL && *princs != NULL) {\n        *princs_ret = princs;\n        princs = NULL;\n    }\n    if (upns != NULL && *upns != NULL) {\n        *upn_ret = upns;\n        upns = NULL;\n    }\n    if (dnss != NULL && *dnss != NULL) {\n        *dns_ret = dnss;\n        dnss = NULL;\n    }\n\ncleanup:\n    for (i = 0; princs != NULL && princs[i] != NULL; i++)\n        krb5_free_principal(context, princs[i]);\n    free(princs);\n    for (i = 0; upns != NULL && upns[i] != NULL; i++)\n        free(upns[i]);\n    free(upns);\n    for (i = 0; dnss != NULL && dnss[i] != NULL; i++)\n        free(dnss[i]);\n    free(dnss);\n    return retval;\n}\n\nkrb5_error_code\ncrypto_retrieve_signer_identity(krb5_context context,\n                                pkinit_identity_crypto_context id_cryptoctx,\n                                const char **identity)\n{\n    *identity = id_cryptoctx->identity;\n    if (*identity == NULL)\n        return ENOENT;\n    return 0;\n}\n\nkrb5_error_code\ncrypto_retrieve_cert_sans(krb5_context context,\n                          pkinit_plg_crypto_context plgctx,\n                          pkinit_req_crypto_context reqctx,\n                          pkinit_identity_crypto_context idctx,\n                          krb5_principal **princs_ret, char ***upn_ret,\n                          unsigned char ***dns_ret)\n{\n    krb5_error_code retval = EINVAL;\n\n    if (reqctx->received_cert == NULL) {\n        pkiDebug(\"%s: No certificate!\\n\", __FUNCTION__);\n        return retval;\n    }\n\n    return crypto_retrieve_X509_sans(context, plgctx, reqctx,\n                                     reqctx->received_cert, princs_ret,\n                                     upn_ret, dns_ret);\n}\n\nkrb5_error_code\ncrypto_check_cert_eku(krb5_context context,\n                      pkinit_plg_crypto_context plgctx,\n                      pkinit_req_crypto_context reqctx,\n                      pkinit_identity_crypto_context idctx,\n                      int checking_kdc_cert,\n                      int allow_secondary_usage,\n                      int *valid_eku)\n{\n    char buf[DN_BUF_LEN];\n    int found_eku = 0;\n    krb5_error_code retval = EINVAL;\n    int i;\n\n    *valid_eku = 0;\n    if (reqctx->received_cert == NULL)\n        goto cleanup;\n\n    X509_NAME_oneline(X509_get_subject_name(reqctx->received_cert),\n                      buf, sizeof(buf));\n\n    if ((i = X509_get_ext_by_NID(reqctx->received_cert,\n                                 NID_ext_key_usage, -1)) >= 0) {\n        EXTENDED_KEY_USAGE *extusage;\n\n        extusage = X509_get_ext_d2i(reqctx->received_cert, NID_ext_key_usage,\n                                    NULL, NULL);\n        if (extusage) {\n            pkiDebug(\"%s: found eku info in the cert\\n\", __FUNCTION__);\n            for (i = 0; found_eku == 0 && i < sk_ASN1_OBJECT_num(extusage); i++) {\n                ASN1_OBJECT *tmp_oid;\n\n                tmp_oid = sk_ASN1_OBJECT_value(extusage, i);\n                pkiDebug(\"%s: checking eku %d of %d, allow_secondary = %d\\n\",\n                         __FUNCTION__, i+1, sk_ASN1_OBJECT_num(extusage),\n                         allow_secondary_usage);\n                if (checking_kdc_cert) {\n                    if ((OBJ_cmp(tmp_oid, plgctx->id_pkinit_KPKdc) == 0)\n                        || (allow_secondary_usage\n                            && OBJ_cmp(tmp_oid, plgctx->id_kp_serverAuth) == 0))\n                        found_eku = 1;\n                } else {\n                    if ((OBJ_cmp(tmp_oid, plgctx->id_pkinit_KPClientAuth) == 0)\n                        || (allow_secondary_usage\n                            && OBJ_cmp(tmp_oid, plgctx->id_ms_kp_sc_logon) == 0))\n                        found_eku = 1;\n                }\n            }\n        }\n        EXTENDED_KEY_USAGE_free(extusage);\n\n        if (found_eku) {\n            ASN1_BIT_STRING *usage = NULL;\n\n            /* check that digitalSignature KeyUsage is present */\n            X509_check_ca(reqctx->received_cert);\n            if ((usage = X509_get_ext_d2i(reqctx->received_cert,\n                                          NID_key_usage, NULL, NULL))) {\n\n                if (!ku_reject(reqctx->received_cert,\n                               X509v3_KU_DIGITAL_SIGNATURE)) {\n                    TRACE_PKINIT_EKU(context);\n                    *valid_eku = 1;\n                } else\n                    TRACE_PKINIT_EKU_NO_KU(context);\n            }\n            ASN1_BIT_STRING_free(usage);\n        }\n    }\n    retval = 0;\ncleanup:\n    pkiDebug(\"%s: returning retval %d, valid_eku %d\\n\",\n             __FUNCTION__, retval, *valid_eku);\n    return retval;\n}\n\nkrb5_error_code\npkinit_octetstring2key(krb5_context context,\n                       krb5_enctype etype,\n                       unsigned char *key,\n                       unsigned int dh_key_len,\n                       krb5_keyblock *key_block)\n{\n    krb5_error_code retval;\n    unsigned char *buf = NULL;\n    unsigned char md[SHA_DIGEST_LENGTH];\n    unsigned char counter;\n    size_t keybytes, keylength, offset;\n    krb5_data random_data;\n\n    if ((buf = malloc(dh_key_len)) == NULL) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n    memset(buf, 0, dh_key_len);\n\n    counter = 0;\n    offset = 0;\n    do {\n        SHA_CTX c;\n\n        SHA1_Init(&c);\n        SHA1_Update(&c, &counter, 1);\n        SHA1_Update(&c, key, dh_key_len);\n        SHA1_Final(md, &c);\n\n        if (dh_key_len - offset < sizeof(md))\n            memcpy(buf + offset, md, dh_key_len - offset);\n        else\n            memcpy(buf + offset, md, sizeof(md));\n\n        offset += sizeof(md);\n        counter++;\n    } while (offset < dh_key_len);\n\n    key_block->magic = 0;\n    key_block->enctype = etype;\n\n    retval = krb5_c_keylengths(context, etype, &keybytes, &keylength);\n    if (retval)\n        goto cleanup;\n\n    key_block->length = keylength;\n    key_block->contents = malloc(keylength);\n    if (key_block->contents == NULL) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n\n    random_data.length = keybytes;\n    random_data.data = (char *)buf;\n\n    retval = krb5_c_random_to_key(context, etype, &random_data, key_block);\n\ncleanup:\n    free(buf);\n    /* If this is an error return, free the allocated keyblock, if any */\n    if (retval) {\n        krb5_free_keyblock_contents(context, key_block);\n    }\n\n    return retval;\n}\n\n\n/**\n * Given an algorithm_identifier, this function returns the hash length\n * and EVP function associated with that algorithm.\n */\nstatic krb5_error_code\npkinit_alg_values(krb5_context context,\n                  const krb5_data *alg_id,\n                  size_t *hash_bytes,\n                  const EVP_MD *(**func)(void))\n{\n    *hash_bytes = 0;\n    *func = NULL;\n    if ((alg_id->length == krb5_pkinit_sha1_oid_len) &&\n        (0 == memcmp(alg_id->data, &krb5_pkinit_sha1_oid,\n                     krb5_pkinit_sha1_oid_len))) {\n        *hash_bytes = 20;\n        *func = &EVP_sha1;\n        return 0;\n    } else if ((alg_id->length == krb5_pkinit_sha256_oid_len) &&\n               (0 == memcmp(alg_id->data, krb5_pkinit_sha256_oid,\n                            krb5_pkinit_sha256_oid_len))) {\n        *hash_bytes = 32;\n        *func = &EVP_sha256;\n        return 0;\n    } else if ((alg_id->length == krb5_pkinit_sha512_oid_len) &&\n               (0 == memcmp(alg_id->data, krb5_pkinit_sha512_oid,\n                            krb5_pkinit_sha512_oid_len))) {\n        *hash_bytes = 64;\n        *func = &EVP_sha512;\n        return 0;\n    } else {\n        krb5_set_error_message(context, KRB5_ERR_BAD_S2K_PARAMS,\n                               \"Bad algorithm ID passed to PK-INIT KDF.\");\n        return KRB5_ERR_BAD_S2K_PARAMS;\n    }\n} /* pkinit_alg_values() */\n\n\n/* pkinit_alg_agility_kdf() --\n * This function generates a key using the KDF described in\n * draft_ietf_krb_wg_pkinit_alg_agility-04.txt.  The algorithm is\n * described as follows:\n *\n *     1.  reps = keydatalen (K) / hash length (H)\n *\n *     2.  Initialize a 32-bit, big-endian bit string counter as 1.\n *\n *     3.  For i = 1 to reps by 1, do the following:\n *\n *         -  Compute Hashi = H(counter || Z || OtherInfo).\n *\n *         -  Increment counter (modulo 2^32)\n *\n *     4.  Set key = Hash1 || Hash2 || ... so that length of key is K bytes.\n */\nkrb5_error_code\npkinit_alg_agility_kdf(krb5_context context,\n                       krb5_data *secret,\n                       krb5_data *alg_oid,\n                       krb5_const_principal party_u_info,\n                       krb5_const_principal party_v_info,\n                       krb5_enctype enctype,\n                       krb5_data *as_req,\n                       krb5_data *pk_as_rep,\n                       krb5_keyblock *key_block)\n{\n    krb5_error_code retval = 0;\n\n    unsigned int reps = 0;\n    uint32_t counter = 1;       /* Does this type work on Windows? */\n    size_t offset = 0;\n    size_t hash_len = 0;\n    size_t rand_len = 0;\n    size_t key_len = 0;\n    krb5_data random_data;\n    krb5_sp80056a_other_info other_info_fields;\n    krb5_pkinit_supp_pub_info supp_pub_info_fields;\n    krb5_data *other_info = NULL;\n    krb5_data *supp_pub_info = NULL;\n    krb5_algorithm_identifier alg_id;\n    EVP_MD_CTX *ctx = NULL;\n    const EVP_MD *(*EVP_func)(void);\n\n    /* initialize random_data here to make clean-up safe */\n    random_data.length = 0;\n    random_data.data = NULL;\n\n    /* allocate and initialize the key block */\n    key_block->magic = 0;\n    key_block->enctype = enctype;\n    if (0 != (retval = krb5_c_keylengths(context, enctype, &rand_len,\n                                         &key_len)))\n        goto cleanup;\n\n    random_data.length = rand_len;\n    key_block->length = key_len;\n\n    if (NULL == (key_block->contents = malloc(key_block->length))) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n\n    memset (key_block->contents, 0, key_block->length);\n\n    /* If this is anonymous pkinit, use the anonymous principle for party_u_info */\n    if (party_u_info && krb5_principal_compare_any_realm(context, party_u_info,\n                                                         krb5_anonymous_principal()))\n        party_u_info = (krb5_principal)krb5_anonymous_principal();\n\n    if (0 != (retval = pkinit_alg_values(context, alg_oid, &hash_len, &EVP_func)))\n        goto cleanup;\n\n    /* 1.  reps = keydatalen (K) / hash length (H) */\n    reps = key_block->length/hash_len;\n\n    /* ... and round up, if necessary */\n    if (key_block->length > (reps * hash_len))\n        reps++;\n\n    /* Allocate enough space in the random data buffer to hash directly into\n     * it, even if the last hash will make it bigger than the key length. */\n    if (NULL == (random_data.data = malloc(reps * hash_len))) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n\n    /* Encode the ASN.1 octet string for \"SuppPubInfo\" */\n    supp_pub_info_fields.enctype = enctype;\n    supp_pub_info_fields.as_req = *as_req;\n    supp_pub_info_fields.pk_as_rep = *pk_as_rep;\n    if (0 != ((retval = encode_krb5_pkinit_supp_pub_info(&supp_pub_info_fields,\n                                                         &supp_pub_info))))\n        goto cleanup;\n\n    /* Now encode the ASN.1 octet string for \"OtherInfo\" */\n    memset(&alg_id, 0, sizeof alg_id);\n    alg_id.algorithm = *alg_oid; /*alias*/\n\n    other_info_fields.algorithm_identifier = alg_id;\n    other_info_fields.party_u_info = (krb5_principal) party_u_info;\n    other_info_fields.party_v_info = (krb5_principal) party_v_info;\n    other_info_fields.supp_pub_info = *supp_pub_info;\n    if (0 != (retval = encode_krb5_sp80056a_other_info(&other_info_fields, &other_info)))\n        goto cleanup;\n\n    /* 2.  Initialize a 32-bit, big-endian bit string counter as 1.\n     * 3.  For i = 1 to reps by 1, do the following:\n     *     -   Compute Hashi = H(counter || Z || OtherInfo).\n     *     -   Increment counter (modulo 2^32)\n     */\n    for (counter = 1; counter <= reps; counter++) {\n        uint s = 0;\n        uint32_t be_counter = htonl(counter);\n\n        ctx = EVP_MD_CTX_new();\n        if (ctx == NULL) {\n            retval = KRB5_CRYPTO_INTERNAL;\n            goto cleanup;\n        }\n\n        /* -   Compute Hashi = H(counter || Z || OtherInfo). */\n        if (!EVP_DigestInit(ctx, EVP_func())) {\n            krb5_set_error_message(context, KRB5_CRYPTO_INTERNAL,\n                                   \"Call to OpenSSL EVP_DigestInit() returned an error.\");\n            retval = KRB5_CRYPTO_INTERNAL;\n            goto cleanup;\n        }\n\n        if (!EVP_DigestUpdate(ctx, &be_counter, 4) ||\n            !EVP_DigestUpdate(ctx, secret->data, secret->length) ||\n            !EVP_DigestUpdate(ctx, other_info->data, other_info->length)) {\n            krb5_set_error_message(context, KRB5_CRYPTO_INTERNAL,\n                                   \"Call to OpenSSL EVP_DigestUpdate() returned an error.\");\n            retval = KRB5_CRYPTO_INTERNAL;\n            goto cleanup;\n        }\n\n        /* 4.  Set key = Hash1 || Hash2 || ... so that length of key is K bytes. */\n        if (!EVP_DigestFinal(ctx, (uint8_t *)random_data.data + offset, &s)) {\n            krb5_set_error_message(context, KRB5_CRYPTO_INTERNAL,\n                                   \"Call to OpenSSL EVP_DigestUpdate() returned an error.\");\n            retval = KRB5_CRYPTO_INTERNAL;\n            goto cleanup;\n        }\n        offset += s;\n        assert(s == hash_len);\n\n        EVP_MD_CTX_free(ctx);\n        ctx = NULL;\n    }\n\n    retval = krb5_c_random_to_key(context, enctype, &random_data,\n                                  key_block);\n\ncleanup:\n    EVP_MD_CTX_free(ctx);\n\n    /* If this has been an error, free the allocated key_block, if any */\n    if (retval) {\n        krb5_free_keyblock_contents(context, key_block);\n    }\n\n    /* free other allocated resources, either way */\n    if (random_data.data)\n        free(random_data.data);\n    krb5_free_data(context, other_info);\n    krb5_free_data(context, supp_pub_info);\n\n    return retval;\n} /*pkinit_alg_agility_kdf() */\n\n/* Call DH_compute_key() and ensure that we left-pad short results instead of\n * leaving junk bytes at the end of the buffer. */\nstatic void\ncompute_dh(unsigned char *buf, int size, BIGNUM *server_pub_key, DH *dh)\n{\n    int len, pad;\n\n    len = DH_compute_key(buf, server_pub_key, dh);\n    assert(len >= 0 && len <= size);\n    if (len < size) {\n        pad = size - len;\n        memmove(buf + pad, buf, len);\n        memset(buf, 0, pad);\n    }\n}\n\nkrb5_error_code\nclient_create_dh(krb5_context context,\n                 pkinit_plg_crypto_context plg_cryptoctx,\n                 pkinit_req_crypto_context cryptoctx,\n                 pkinit_identity_crypto_context id_cryptoctx,\n                 int dh_size,\n                 unsigned char **dh_params_out,\n                 unsigned int *dh_params_len_out,\n                 unsigned char **dh_pubkey_out,\n                 unsigned int *dh_pubkey_len_out)\n{\n    krb5_error_code retval = KRB5KDC_ERR_PREAUTH_FAILED;\n    unsigned char *buf = NULL;\n    int dh_err = 0;\n    ASN1_INTEGER *pub_key = NULL;\n    const BIGNUM *pubkey_bn, *p, *q, *g;\n    unsigned char *dh_params = NULL, *dh_pubkey = NULL;\n    unsigned int dh_params_len, dh_pubkey_len;\n\n    *dh_params_out = *dh_pubkey_out = NULL;\n    *dh_params_len_out = *dh_pubkey_len_out = 0;\n\n    if (cryptoctx->dh == NULL) {\n        if (dh_size == 1024)\n            cryptoctx->dh = make_oakley_dh(oakley_1024, sizeof(oakley_1024));\n        else if (dh_size == 2048)\n            cryptoctx->dh = make_oakley_dh(oakley_2048, sizeof(oakley_2048));\n        else if (dh_size == 4096)\n            cryptoctx->dh = make_oakley_dh(oakley_4096, sizeof(oakley_4096));\n        if (cryptoctx->dh == NULL)\n            goto cleanup;\n    }\n\n    DH_generate_key(cryptoctx->dh);\n    DH_get0_key(cryptoctx->dh, &pubkey_bn, NULL);\n\n    DH_check(cryptoctx->dh, &dh_err);\n    if (dh_err != 0) {\n        pkiDebug(\"Warning: dh_check failed with %d\\n\", dh_err);\n        if (dh_err & DH_CHECK_P_NOT_PRIME)\n            pkiDebug(\"p value is not prime\\n\");\n        if (dh_err & DH_CHECK_P_NOT_SAFE_PRIME)\n            pkiDebug(\"p value is not a safe prime\\n\");\n        if (dh_err & DH_UNABLE_TO_CHECK_GENERATOR)\n            pkiDebug(\"unable to check the generator value\\n\");\n        if (dh_err & DH_NOT_SUITABLE_GENERATOR)\n            pkiDebug(\"the g value is not a generator\\n\");\n    }\n#ifdef DEBUG_DH\n    print_dh(cryptoctx->dh, \"client's DH params\\n\");\n    print_pubkey(cryptoctx->dh->pub_key, \"client's pub_key=\");\n#endif\n\n    DH_check_pub_key(cryptoctx->dh, pubkey_bn, &dh_err);\n    if (dh_err != 0) {\n        pkiDebug(\"dh_check_pub_key failed with %d\\n\", dh_err);\n        goto cleanup;\n    }\n\n    /* pack DHparams */\n    /* aglo: usually we could just call i2d_DHparams to encode DH params\n     * however, PKINIT requires RFC3279 encoding and openssl does pkcs#3.\n     */\n    DH_get0_pqg(cryptoctx->dh, &p, &q, &g);\n    retval = pkinit_encode_dh_params(p, g, q, &dh_params, &dh_params_len);\n    if (retval)\n        goto cleanup;\n\n    /* pack DH public key */\n    /* Diffie-Hellman public key must be ASN1 encoded as an INTEGER; this\n     * encoding shall be used as the contents (the value) of the\n     * subjectPublicKey component (a BIT STRING) of the SubjectPublicKeyInfo\n     * data element\n     */\n    pub_key = BN_to_ASN1_INTEGER(pubkey_bn, NULL);\n    if (pub_key == NULL) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n    dh_pubkey_len = i2d_ASN1_INTEGER(pub_key, NULL);\n    buf = dh_pubkey = malloc(dh_pubkey_len);\n    if (dh_pubkey == NULL) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n    i2d_ASN1_INTEGER(pub_key, &buf);\n\n    *dh_params_out = dh_params;\n    *dh_params_len_out = dh_params_len;\n    *dh_pubkey_out = dh_pubkey;\n    *dh_pubkey_len_out = dh_pubkey_len;\n    dh_params = dh_pubkey = NULL;\n\n    retval = 0;\n\ncleanup:\n    if (retval) {\n        DH_free(cryptoctx->dh);\n        cryptoctx->dh = NULL;\n    }\n    free(dh_params);\n    free(dh_pubkey);\n    ASN1_INTEGER_free(pub_key);\n    return retval;\n}\n\nkrb5_error_code\nclient_process_dh(krb5_context context,\n                  pkinit_plg_crypto_context plg_cryptoctx,\n                  pkinit_req_crypto_context cryptoctx,\n                  pkinit_identity_crypto_context id_cryptoctx,\n                  unsigned char *subjectPublicKey_data,\n                  unsigned int subjectPublicKey_length,\n                  unsigned char **client_key_out,\n                  unsigned int *client_key_len_out)\n{\n    krb5_error_code retval = KRB5KDC_ERR_PREAUTH_FAILED;\n    BIGNUM *server_pub_key = NULL;\n    ASN1_INTEGER *pub_key = NULL;\n    unsigned char *client_key = NULL;\n    unsigned int client_key_len;\n    const unsigned char *p = NULL;\n\n    *client_key_out = NULL;\n    *client_key_len_out = 0;\n\n    client_key_len = DH_size(cryptoctx->dh);\n    client_key = malloc(client_key_len);\n    if (client_key == NULL) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n    p = subjectPublicKey_data;\n    pub_key = d2i_ASN1_INTEGER(NULL, &p, (long)subjectPublicKey_length);\n    if (pub_key == NULL)\n        goto cleanup;\n    if ((server_pub_key = ASN1_INTEGER_to_BN(pub_key, NULL)) == NULL)\n        goto cleanup;\n\n    compute_dh(client_key, client_key_len, server_pub_key, cryptoctx->dh);\n#ifdef DEBUG_DH\n    print_pubkey(server_pub_key, \"server's pub_key=\");\n    pkiDebug(\"client computed key (%d)= \", client_key_len);\n    print_buffer(client_key, client_key_len);\n#endif\n\n    *client_key_out = client_key;\n    *client_key_len_out = client_key_len;\n    client_key = NULL;\n\n    retval = 0;\n\ncleanup:\n    BN_free(server_pub_key);\n    ASN1_INTEGER_free(pub_key);\n    free(client_key);\n    return retval;\n}\n\n/* Return 1 if dh is a permitted well-known group, otherwise return 0. */\nstatic int\ncheck_dh_wellknown(pkinit_plg_crypto_context cryptoctx, DH *dh, int nbits)\n{\n\n    switch (nbits) {\n    case 1024:\n        /* Oakley MODP group 2 */\n        if (pkinit_check_dh_params(cryptoctx->dh_1024, dh) == 0)\n            return 1;\n        break;\n\n    case 2048:\n        /* Oakley MODP group 14 */\n        if (pkinit_check_dh_params(cryptoctx->dh_2048, dh) == 0)\n            return 1;\n        break;\n\n    case 4096:\n        /* Oakley MODP group 16 */\n        if (pkinit_check_dh_params(cryptoctx->dh_4096, dh) == 0)\n            return 1;\n        break;\n\n    default:\n        break;\n    }\n    return 0;\n}\n\nkrb5_error_code\nserver_check_dh(krb5_context context,\n                pkinit_plg_crypto_context cryptoctx,\n                pkinit_req_crypto_context req_cryptoctx,\n                pkinit_identity_crypto_context id_cryptoctx,\n                krb5_data *dh_params,\n                int minbits)\n{\n    DH *dh = NULL;\n    const BIGNUM *p;\n    int dh_prime_bits;\n    krb5_error_code retval = KRB5KDC_ERR_DH_KEY_PARAMETERS_NOT_ACCEPTED;\n\n    dh = decode_dh_params((uint8_t *)dh_params->data, dh_params->length);\n    if (dh == NULL) {\n        pkiDebug(\"failed to decode dhparams\\n\");\n        goto cleanup;\n    }\n\n    /* KDC SHOULD check to see if the key parameters satisfy its policy */\n    DH_get0_pqg(dh, &p, NULL, NULL);\n    dh_prime_bits = BN_num_bits(p);\n    if (minbits && dh_prime_bits < minbits) {\n        pkiDebug(\"client sent dh params with %d bits, we require %d\\n\",\n                 dh_prime_bits, minbits);\n        goto cleanup;\n    }\n\n    if (check_dh_wellknown(cryptoctx, dh, dh_prime_bits))\n        retval = 0;\n\ncleanup:\n    if (retval == 0)\n        req_cryptoctx->dh = dh;\n    else\n        DH_free(dh);\n\n    return retval;\n}\n\n/* Duplicate a DH handle (parameters only, not public or private key). */\nstatic DH *\ndup_dh_params(const DH *src)\n{\n    const BIGNUM *oldp, *oldq, *oldg;\n    BIGNUM *p = NULL, *q = NULL, *g = NULL;\n    DH *dh;\n\n    DH_get0_pqg(src, &oldp, &oldq, &oldg);\n    p = BN_dup(oldp);\n    q = BN_dup(oldq);\n    g = BN_dup(oldg);\n    dh = DH_new();\n    if (p == NULL || q == NULL || g == NULL || dh == NULL) {\n        BN_free(p);\n        BN_free(q);\n        BN_free(g);\n        DH_free(dh);\n        return NULL;\n    }\n    DH_set0_pqg(dh, p, q, g);\n    return dh;\n}\n\n/* kdc's dh function */\nkrb5_error_code\nserver_process_dh(krb5_context context,\n                  pkinit_plg_crypto_context plg_cryptoctx,\n                  pkinit_req_crypto_context cryptoctx,\n                  pkinit_identity_crypto_context id_cryptoctx,\n                  unsigned char *data,\n                  unsigned int data_len,\n                  unsigned char **dh_pubkey_out,\n                  unsigned int *dh_pubkey_len_out,\n                  unsigned char **server_key_out,\n                  unsigned int *server_key_len_out)\n{\n    krb5_error_code retval = ENOMEM;\n    DH *dh = NULL, *dh_server = NULL;\n    unsigned char *p = NULL;\n    ASN1_INTEGER *pub_key = NULL;\n    BIGNUM *client_pubkey = NULL;\n    const BIGNUM *server_pubkey;\n    unsigned char *dh_pubkey = NULL, *server_key = NULL;\n    unsigned int dh_pubkey_len = 0, server_key_len = 0;\n\n    *dh_pubkey_out = *server_key_out = NULL;\n    *dh_pubkey_len_out = *server_key_len_out = 0;\n\n    /* get client's received DH parameters that we saved in server_check_dh */\n    dh = cryptoctx->dh;\n    dh_server = dup_dh_params(dh);\n    if (dh_server == NULL)\n        goto cleanup;\n\n    /* decode client's public key */\n    p = data;\n    pub_key = d2i_ASN1_INTEGER(NULL, (const unsigned char **)&p, (int)data_len);\n    if (pub_key == NULL)\n        goto cleanup;\n    client_pubkey = ASN1_INTEGER_to_BN(pub_key, NULL);\n    if (client_pubkey == NULL)\n        goto cleanup;\n    ASN1_INTEGER_free(pub_key);\n\n    if (!DH_generate_key(dh_server))\n        goto cleanup;\n    DH_get0_key(dh_server, &server_pubkey, NULL);\n\n    /* generate DH session key */\n    server_key_len = DH_size(dh_server);\n    server_key = malloc(server_key_len);\n    if (server_key == NULL)\n        goto cleanup;\n    compute_dh(server_key, server_key_len, client_pubkey, dh_server);\n\n#ifdef DEBUG_DH\n    print_dh(dh_server, \"client&server's DH params\\n\");\n    print_pubkey(client_pubkey, \"client's pub_key=\");\n    print_pubkey(server_pubkey, \"server's pub_key=\");\n    pkiDebug(\"server computed key=\");\n    print_buffer(server_key, server_key_len);\n#endif\n\n    /* KDC reply */\n    /* pack DH public key */\n    /* Diffie-Hellman public key must be ASN1 encoded as an INTEGER; this\n     * encoding shall be used as the contents (the value) of the\n     * subjectPublicKey component (a BIT STRING) of the SubjectPublicKeyInfo\n     * data element\n     */\n    pub_key = BN_to_ASN1_INTEGER(server_pubkey, NULL);\n    if (pub_key == NULL)\n        goto cleanup;\n    dh_pubkey_len = i2d_ASN1_INTEGER(pub_key, NULL);\n    p = dh_pubkey = malloc(dh_pubkey_len);\n    if (dh_pubkey == NULL)\n        goto cleanup;\n    i2d_ASN1_INTEGER(pub_key, &p);\n    if (pub_key != NULL)\n        ASN1_INTEGER_free(pub_key);\n\n    *dh_pubkey_out = dh_pubkey;\n    *dh_pubkey_len_out = dh_pubkey_len;\n    *server_key_out = server_key;\n    *server_key_len_out = server_key_len;\n    dh_pubkey = server_key = NULL;\n\n    retval = 0;\n\ncleanup:\n    BN_free(client_pubkey);\n    DH_free(dh_server);\n    free(dh_pubkey);\n    free(server_key);\n\n    return retval;\n}\n\nint\npkinit_openssl_init()\n{\n    /* Initialize OpenSSL. */\n    ERR_load_crypto_strings();\n    OpenSSL_add_all_algorithms();\n    return 0;\n}\n\nstatic krb5_error_code\npkinit_encode_dh_params(const BIGNUM *p, const BIGNUM *g, const BIGNUM *q,\n                        uint8_t **buf, unsigned int *buf_len)\n{\n    krb5_error_code retval = ENOMEM;\n    int bufsize = 0, r = 0;\n    unsigned char *tmp = NULL;\n    ASN1_INTEGER *ap = NULL, *ag = NULL, *aq = NULL;\n\n    if ((ap = BN_to_ASN1_INTEGER(p, NULL)) == NULL)\n        goto cleanup;\n    if ((ag = BN_to_ASN1_INTEGER(g, NULL)) == NULL)\n        goto cleanup;\n    if ((aq = BN_to_ASN1_INTEGER(q, NULL)) == NULL)\n        goto cleanup;\n    bufsize = i2d_ASN1_INTEGER(ap, NULL);\n    bufsize += i2d_ASN1_INTEGER(ag, NULL);\n    bufsize += i2d_ASN1_INTEGER(aq, NULL);\n\n    r = ASN1_object_size(1, bufsize, V_ASN1_SEQUENCE);\n\n    tmp = *buf = malloc((size_t) r);\n    if (tmp == NULL)\n        goto cleanup;\n\n    ASN1_put_object(&tmp, 1, bufsize, V_ASN1_SEQUENCE, V_ASN1_UNIVERSAL);\n\n    i2d_ASN1_INTEGER(ap, &tmp);\n    i2d_ASN1_INTEGER(ag, &tmp);\n    i2d_ASN1_INTEGER(aq, &tmp);\n\n    *buf_len = r;\n\n    retval = 0;\n\ncleanup:\n    if (ap != NULL)\n        ASN1_INTEGER_free(ap);\n    if (ag != NULL)\n        ASN1_INTEGER_free(ag);\n    if (aq != NULL)\n        ASN1_INTEGER_free(aq);\n\n    return retval;\n}\n\n#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n\n/*\n * We need to decode DomainParameters from RFC 3279 section 2.3.3.  We would\n * like to just call d2i_DHxparams(), but Microsoft's implementation may omit\n * the q value in violation of the RFC.  Instead we must copy the internal\n * structures and sequence declarations from dh_asn1.c, modified to make the q\n * field optional.\n */\n\ntypedef struct {\n    ASN1_BIT_STRING *seed;\n    BIGNUM *counter;\n} int_dhvparams;\n\ntypedef struct {\n    BIGNUM *p;\n    BIGNUM *q;\n    BIGNUM *g;\n    BIGNUM *j;\n    int_dhvparams *vparams;\n} int_dhx942_dh;\n\nASN1_SEQUENCE(DHvparams) = {\n    ASN1_SIMPLE(int_dhvparams, seed, ASN1_BIT_STRING),\n    ASN1_SIMPLE(int_dhvparams, counter, BIGNUM)\n} static_ASN1_SEQUENCE_END_name(int_dhvparams, DHvparams)\n\nASN1_SEQUENCE(DHxparams) = {\n    ASN1_SIMPLE(int_dhx942_dh, p, BIGNUM),\n    ASN1_SIMPLE(int_dhx942_dh, g, BIGNUM),\n    ASN1_OPT(int_dhx942_dh, q, BIGNUM),\n    ASN1_OPT(int_dhx942_dh, j, BIGNUM),\n    ASN1_OPT(int_dhx942_dh, vparams, DHvparams),\n} static_ASN1_SEQUENCE_END_name(int_dhx942_dh, DHxparams)\n\nstatic DH *\ndecode_dh_params(const uint8_t *p, unsigned int len)\n{\n    int_dhx942_dh *params;\n    DH *dh;\n\n    dh = DH_new();\n    if (dh == NULL)\n        return NULL;\n\n    params = (int_dhx942_dh *)ASN1_item_d2i(NULL, &p, len,\n                                            ASN1_ITEM_rptr(DHxparams));\n    if (params == NULL) {\n        DH_free(dh);\n        return NULL;\n    }\n\n    /* Steal the p, q, and g values from dhparams for dh.  Ignore j and\n     * vparams. */\n    DH_set0_pqg(dh, params->p, params->q, params->g);\n    params->p = params->q = params->g = NULL;\n    ASN1_item_free((ASN1_VALUE *)params, ASN1_ITEM_rptr(DHxparams));\n    return dh;\n}\n\n#else /* OPENSSL_VERSION_NUMBER < 0x10100000L */\n\n/*\n * Do the same decoding (except without decoding j and vparams or checking the\n * sequence length) using the pre-OpenSSL-1.1 asn1_mac.h.  Define an internal\n * function in the form demanded by the macros, then wrap it for caller\n * convenience.\n */\n\nstatic DH *\ndecode_dh_params_int(DH ** a, uint8_t **pp, unsigned int len)\n{\n    ASN1_INTEGER ai, *aip = NULL;\n    long length = (long) len;\n\n    M_ASN1_D2I_vars(a, DH *, DH_new);\n\n    M_ASN1_D2I_Init();\n    M_ASN1_D2I_start_sequence();\n    aip = &ai;\n    ai.data = NULL;\n    ai.length = 0;\n    M_ASN1_D2I_get_x(ASN1_INTEGER, aip, d2i_ASN1_INTEGER);\n    if (aip == NULL)\n        return NULL;\n    else {\n        ret->p = ASN1_INTEGER_to_BN(aip, NULL);\n        if (ret->p == NULL)\n            return NULL;\n        if (ai.data != NULL) {\n            OPENSSL_free(ai.data);\n            ai.data = NULL;\n            ai.length = 0;\n        }\n    }\n    M_ASN1_D2I_get_x(ASN1_INTEGER, aip, d2i_ASN1_INTEGER);\n    if (aip == NULL)\n        return NULL;\n    else {\n        ret->g = ASN1_INTEGER_to_BN(aip, NULL);\n        if (ret->g == NULL)\n            return NULL;\n        if (ai.data != NULL) {\n            OPENSSL_free(ai.data);\n            ai.data = NULL;\n            ai.length = 0;\n        }\n\n    }\n    M_ASN1_D2I_get_opt(aip, d2i_ASN1_INTEGER, V_ASN1_INTEGER);\n    if (aip == NULL || ai.data == NULL)\n        ret->q = NULL;\n    else {\n        ret->q = ASN1_INTEGER_to_BN(aip, NULL);\n        if (ret->q == NULL)\n            return NULL;\n        if (ai.data != NULL) {\n            OPENSSL_free(ai.data);\n            ai.data = NULL;\n            ai.length = 0;\n        }\n\n    }\n    M_ASN1_D2I_end_sequence();\n    M_ASN1_D2I_Finish(a, DH_free, 0);\n\n}\n\nstatic DH *\ndecode_dh_params(const uint8_t *p, unsigned int len)\n{\n    uint8_t *ptr = (uint8_t *)p;\n\n    return decode_dh_params_int(NULL, &ptr, len);\n}\n\n#endif /* OPENSSL_VERSION_NUMBER < 0x10100000L */\n\nstatic krb5_error_code\npkinit_create_sequence_of_principal_identifiers(\n    krb5_context context,\n    pkinit_plg_crypto_context plg_cryptoctx,\n    pkinit_req_crypto_context req_cryptoctx,\n    pkinit_identity_crypto_context id_cryptoctx,\n    int type,\n    krb5_pa_data ***e_data_out)\n{\n    krb5_error_code retval = KRB5KRB_ERR_GENERIC;\n    krb5_external_principal_identifier **krb5_trusted_certifiers = NULL;\n    krb5_data *td_certifiers = NULL;\n    krb5_pa_data **pa_data = NULL;\n\n    switch(type) {\n    case TD_TRUSTED_CERTIFIERS:\n        retval = create_krb5_trustedCertifiers(context, plg_cryptoctx,\n                                               req_cryptoctx, id_cryptoctx, &krb5_trusted_certifiers);\n        if (retval) {\n            pkiDebug(\"create_krb5_trustedCertifiers failed\\n\");\n            goto cleanup;\n        }\n        break;\n    case TD_INVALID_CERTIFICATES:\n        retval = create_krb5_invalidCertificates(context, plg_cryptoctx,\n                                                 req_cryptoctx, id_cryptoctx, &krb5_trusted_certifiers);\n        if (retval) {\n            pkiDebug(\"create_krb5_invalidCertificates failed\\n\");\n            goto cleanup;\n        }\n        break;\n    default:\n        retval = -1;\n        goto cleanup;\n    }\n\n    retval = k5int_encode_krb5_td_trusted_certifiers((krb5_external_principal_identifier *const *)krb5_trusted_certifiers, &td_certifiers);\n    if (retval) {\n        pkiDebug(\"encode_krb5_td_trusted_certifiers failed\\n\");\n        goto cleanup;\n    }\n#ifdef DEBUG_ASN1\n    print_buffer_bin((unsigned char *)td_certifiers->data,\n                     td_certifiers->length, \"/tmp/kdc_td_certifiers\");\n#endif\n    pa_data = malloc(2 * sizeof(krb5_pa_data *));\n    if (pa_data == NULL) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n    pa_data[1] = NULL;\n    pa_data[0] = malloc(sizeof(krb5_pa_data));\n    if (pa_data[0] == NULL) {\n        free(pa_data);\n        retval = ENOMEM;\n        goto cleanup;\n    }\n    pa_data[0]->pa_type = type;\n    pa_data[0]->length = td_certifiers->length;\n    pa_data[0]->contents = (krb5_octet *)td_certifiers->data;\n    *e_data_out = pa_data;\n    retval = 0;\n\ncleanup:\n    if (krb5_trusted_certifiers != NULL)\n        free_krb5_external_principal_identifier(&krb5_trusted_certifiers);\n    free(td_certifiers);\n    return retval;\n}\n\nkrb5_error_code\npkinit_create_td_trusted_certifiers(krb5_context context,\n                                    pkinit_plg_crypto_context plg_cryptoctx,\n                                    pkinit_req_crypto_context req_cryptoctx,\n                                    pkinit_identity_crypto_context id_cryptoctx,\n                                    krb5_pa_data ***e_data_out)\n{\n    krb5_error_code retval = KRB5KRB_ERR_GENERIC;\n\n    retval = pkinit_create_sequence_of_principal_identifiers(context,\n                                                             plg_cryptoctx, req_cryptoctx, id_cryptoctx,\n                                                             TD_TRUSTED_CERTIFIERS, e_data_out);\n\n    return retval;\n}\n\nkrb5_error_code\npkinit_create_td_invalid_certificate(\n    krb5_context context,\n    pkinit_plg_crypto_context plg_cryptoctx,\n    pkinit_req_crypto_context req_cryptoctx,\n    pkinit_identity_crypto_context id_cryptoctx,\n    krb5_pa_data ***e_data_out)\n{\n    krb5_error_code retval = KRB5KRB_ERR_GENERIC;\n\n    retval = pkinit_create_sequence_of_principal_identifiers(context,\n                                                             plg_cryptoctx, req_cryptoctx, id_cryptoctx,\n                                                             TD_INVALID_CERTIFICATES, e_data_out);\n\n    return retval;\n}\n\nkrb5_error_code\npkinit_create_td_dh_parameters(krb5_context context,\n                               pkinit_plg_crypto_context plg_cryptoctx,\n                               pkinit_req_crypto_context req_cryptoctx,\n                               pkinit_identity_crypto_context id_cryptoctx,\n                               pkinit_plg_opts *opts,\n                               krb5_pa_data ***e_data_out)\n{\n    krb5_error_code retval = ENOMEM;\n    unsigned int buf1_len = 0, buf2_len = 0, buf3_len = 0, i = 0;\n    unsigned char *buf1 = NULL, *buf2 = NULL, *buf3 = NULL;\n    krb5_pa_data **pa_data = NULL;\n    krb5_data *encoded_algId = NULL;\n    krb5_algorithm_identifier **algId = NULL;\n    const BIGNUM *p, *q, *g;\n\n    if (opts->dh_min_bits > 4096)\n        goto cleanup;\n\n    if (opts->dh_min_bits <= 1024) {\n        DH_get0_pqg(plg_cryptoctx->dh_1024, &p, &q, &g);\n        retval = pkinit_encode_dh_params(p, g, q, &buf1, &buf1_len);\n        if (retval)\n            goto cleanup;\n    }\n    if (opts->dh_min_bits <= 2048) {\n        DH_get0_pqg(plg_cryptoctx->dh_2048, &p, &q, &g);\n        retval = pkinit_encode_dh_params(p, g, q, &buf2, &buf2_len);\n        if (retval)\n            goto cleanup;\n    }\n    DH_get0_pqg(plg_cryptoctx->dh_4096, &p, &q, &g);\n    retval = pkinit_encode_dh_params(p, g, q, &buf3, &buf3_len);\n    if (retval)\n        goto cleanup;\n\n    if (opts->dh_min_bits <= 1024) {\n        algId = malloc(4 * sizeof(krb5_algorithm_identifier *));\n        if (algId == NULL)\n            goto cleanup;\n        algId[3] = NULL;\n        algId[0] = malloc(sizeof(krb5_algorithm_identifier));\n        if (algId[0] == NULL)\n            goto cleanup;\n        algId[0]->parameters.data = malloc(buf2_len);\n        if (algId[0]->parameters.data == NULL)\n            goto cleanup;\n        memcpy(algId[0]->parameters.data, buf2, buf2_len);\n        algId[0]->parameters.length = buf2_len;\n        algId[0]->algorithm = dh_oid;\n\n        algId[1] = malloc(sizeof(krb5_algorithm_identifier));\n        if (algId[1] == NULL)\n            goto cleanup;\n        algId[1]->parameters.data = malloc(buf3_len);\n        if (algId[1]->parameters.data == NULL)\n            goto cleanup;\n        memcpy(algId[1]->parameters.data, buf3, buf3_len);\n        algId[1]->parameters.length = buf3_len;\n        algId[1]->algorithm = dh_oid;\n\n        algId[2] = malloc(sizeof(krb5_algorithm_identifier));\n        if (algId[2] == NULL)\n            goto cleanup;\n        algId[2]->parameters.data = malloc(buf1_len);\n        if (algId[2]->parameters.data == NULL)\n            goto cleanup;\n        memcpy(algId[2]->parameters.data, buf1, buf1_len);\n        algId[2]->parameters.length = buf1_len;\n        algId[2]->algorithm = dh_oid;\n\n    } else if (opts->dh_min_bits <= 2048) {\n        algId = malloc(3 * sizeof(krb5_algorithm_identifier *));\n        if (algId == NULL)\n            goto cleanup;\n        algId[2] = NULL;\n        algId[0] = malloc(sizeof(krb5_algorithm_identifier));\n        if (algId[0] == NULL)\n            goto cleanup;\n        algId[0]->parameters.data = malloc(buf2_len);\n        if (algId[0]->parameters.data == NULL)\n            goto cleanup;\n        memcpy(algId[0]->parameters.data, buf2, buf2_len);\n        algId[0]->parameters.length = buf2_len;\n        algId[0]->algorithm = dh_oid;\n\n        algId[1] = malloc(sizeof(krb5_algorithm_identifier));\n        if (algId[1] == NULL)\n            goto cleanup;\n        algId[1]->parameters.data = malloc(buf3_len);\n        if (algId[1]->parameters.data == NULL)\n            goto cleanup;\n        memcpy(algId[1]->parameters.data, buf3, buf3_len);\n        algId[1]->parameters.length = buf3_len;\n        algId[1]->algorithm = dh_oid;\n\n    } else if (opts->dh_min_bits <= 4096) {\n        algId = malloc(2 * sizeof(krb5_algorithm_identifier *));\n        if (algId == NULL)\n            goto cleanup;\n        algId[1] = NULL;\n        algId[0] = malloc(sizeof(krb5_algorithm_identifier));\n        if (algId[0] == NULL)\n            goto cleanup;\n        algId[0]->parameters.data = malloc(buf3_len);\n        if (algId[0]->parameters.data == NULL)\n            goto cleanup;\n        memcpy(algId[0]->parameters.data, buf3, buf3_len);\n        algId[0]->parameters.length = buf3_len;\n        algId[0]->algorithm = dh_oid;\n\n    }\n    retval = k5int_encode_krb5_td_dh_parameters((krb5_algorithm_identifier *const *)algId, &encoded_algId);\n    if (retval)\n        goto cleanup;\n#ifdef DEBUG_ASN1\n    print_buffer_bin((unsigned char *)encoded_algId->data,\n                     encoded_algId->length, \"/tmp/kdc_td_dh_params\");\n#endif\n    pa_data = malloc(2 * sizeof(krb5_pa_data *));\n    if (pa_data == NULL) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n    pa_data[1] = NULL;\n    pa_data[0] = malloc(sizeof(krb5_pa_data));\n    if (pa_data[0] == NULL) {\n        free(pa_data);\n        retval = ENOMEM;\n        goto cleanup;\n    }\n    pa_data[0]->pa_type = TD_DH_PARAMETERS;\n    pa_data[0]->length = encoded_algId->length;\n    pa_data[0]->contents = (krb5_octet *)encoded_algId->data;\n    *e_data_out = pa_data;\n    retval = 0;\ncleanup:\n\n    free(buf1);\n    free(buf2);\n    free(buf3);\n    free(encoded_algId);\n\n    if (algId != NULL) {\n        while(algId[i] != NULL) {\n            free(algId[i]->parameters.data);\n            free(algId[i]);\n            i++;\n        }\n        free(algId);\n    }\n\n    return retval;\n}\n\nkrb5_error_code\npkinit_check_kdc_pkid(krb5_context context,\n                      pkinit_plg_crypto_context plg_cryptoctx,\n                      pkinit_req_crypto_context req_cryptoctx,\n                      pkinit_identity_crypto_context id_cryptoctx,\n                      unsigned char *pdid_buf,\n                      unsigned int pkid_len,\n                      int *valid_kdcPkId)\n{\n    PKCS7_ISSUER_AND_SERIAL *is = NULL;\n    const unsigned char *p = pdid_buf;\n    int status = 1;\n    X509 *kdc_cert = sk_X509_value(id_cryptoctx->my_certs, id_cryptoctx->cert_index);\n\n    *valid_kdcPkId = 0;\n    pkiDebug(\"found kdcPkId in AS REQ\\n\");\n    is = d2i_PKCS7_ISSUER_AND_SERIAL(NULL, &p, (int)pkid_len);\n    if (is == NULL)\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n\n    status = X509_NAME_cmp(X509_get_issuer_name(kdc_cert), is->issuer);\n    if (!status) {\n        status = ASN1_INTEGER_cmp(X509_get_serialNumber(kdc_cert), is->serial);\n        if (!status)\n            *valid_kdcPkId = 1;\n    }\n\n    X509_NAME_free(is->issuer);\n    ASN1_INTEGER_free(is->serial);\n    free(is);\n\n    return 0;\n}\n\n/* Check parameters against a well-known DH group. */\nstatic int\npkinit_check_dh_params(DH *dh1, DH *dh2)\n{\n    const BIGNUM *p1, *p2, *g1, *g2;\n\n    DH_get0_pqg(dh1, &p1, NULL, &g1);\n    DH_get0_pqg(dh2, &p2, NULL, &g2);\n    if (BN_cmp(p1, p2) != 0) {\n        pkiDebug(\"p is not well-known group dhparameter\\n\");\n        return -1;\n    }\n    if (BN_cmp(g1, g2) != 0) {\n        pkiDebug(\"bad g dhparameter\\n\");\n        return -1;\n    }\n    pkiDebug(\"good %d dhparams\\n\", BN_num_bits(p1));\n    return 0;\n}\n\nkrb5_error_code\npkinit_process_td_dh_params(krb5_context context,\n                            pkinit_plg_crypto_context cryptoctx,\n                            pkinit_req_crypto_context req_cryptoctx,\n                            pkinit_identity_crypto_context id_cryptoctx,\n                            krb5_algorithm_identifier **algId,\n                            int *new_dh_size)\n{\n    krb5_error_code retval = KRB5KDC_ERR_DH_KEY_PARAMETERS_NOT_ACCEPTED;\n    int i = 0, use_sent_dh = 0, ok = 0;\n\n    pkiDebug(\"dh parameters\\n\");\n\n    while (algId[i] != NULL) {\n        DH *dh = NULL;\n        const BIGNUM *p;\n        int dh_prime_bits = 0;\n\n        if (algId[i]->algorithm.length != dh_oid.length ||\n            memcmp(algId[i]->algorithm.data, dh_oid.data, dh_oid.length))\n            goto cleanup;\n\n        dh = decode_dh_params((uint8_t *)algId[i]->parameters.data,\n                              algId[i]->parameters.length);\n        if (dh == NULL)\n            goto cleanup;\n        DH_get0_pqg(dh, &p, NULL, NULL);\n        dh_prime_bits = BN_num_bits(p);\n        pkiDebug(\"client sent %d DH bits server prefers %d DH bits\\n\",\n                 *new_dh_size, dh_prime_bits);\n        ok = check_dh_wellknown(cryptoctx, dh, dh_prime_bits);\n        if (ok) {\n            *new_dh_size = dh_prime_bits;\n        }\n        if (!ok) {\n            DH_check(dh, &retval);\n            if (retval != 0) {\n                pkiDebug(\"DH parameters provided by server are unacceptable\\n\");\n                retval = KRB5KDC_ERR_DH_KEY_PARAMETERS_NOT_ACCEPTED;\n            }\n            else {\n                use_sent_dh = 1;\n                ok = 1;\n            }\n        }\n        if (!use_sent_dh)\n            DH_free(dh);\n        if (ok) {\n            if (req_cryptoctx->dh != NULL) {\n                DH_free(req_cryptoctx->dh);\n                req_cryptoctx->dh = NULL;\n            }\n            if (use_sent_dh)\n                req_cryptoctx->dh = dh;\n            break;\n        }\n        i++;\n    }\n\n    if (ok)\n        retval = 0;\n\ncleanup:\n    return retval;\n}\n\nstatic int\nopenssl_callback(int ok, X509_STORE_CTX * ctx)\n{\n#ifdef DEBUG\n    if (!ok) {\n        X509 *cert = X509_STORE_CTX_get_current_cert(ctx);\n        int err = X509_STORE_CTX_get_error(ctx);\n        const char *errmsg = X509_verify_cert_error_string(err);\n        char buf[DN_BUF_LEN];\n\n        X509_NAME_oneline(X509_get_subject_name(cert), buf, sizeof(buf));\n        pkiDebug(\"cert = %s\\n\", buf);\n        pkiDebug(\"callback function: %d (%s)\\n\", err, errmsg);\n    }\n#endif\n    return ok;\n}\n\nstatic int\nopenssl_callback_ignore_crls(int ok, X509_STORE_CTX * ctx)\n{\n    if (ok)\n        return ok;\n    return X509_STORE_CTX_get_error(ctx) == X509_V_ERR_UNABLE_TO_GET_CRL;\n}\n\nstatic ASN1_OBJECT *\npkinit_pkcs7type2oid(pkinit_plg_crypto_context cryptoctx, int pkcs7_type)\n{\n    switch (pkcs7_type) {\n    case CMS_SIGN_CLIENT:\n        return cryptoctx->id_pkinit_authData;\n    case CMS_SIGN_SERVER:\n        return cryptoctx->id_pkinit_DHKeyData;\n    case CMS_ENVEL_SERVER:\n        return cryptoctx->id_pkinit_rkeyData;\n    default:\n        return NULL;\n    }\n\n}\n\nstatic int\nwrap_signeddata(unsigned char *data, unsigned int data_len,\n                unsigned char **out, unsigned int *out_len)\n{\n\n    unsigned int orig_len = 0, oid_len = 0, tot_len = 0;\n    ASN1_OBJECT *oid = NULL;\n    unsigned char *p = NULL;\n\n    /* Get length to wrap the original data with SEQUENCE tag */\n    tot_len = orig_len = ASN1_object_size(1, (int)data_len, V_ASN1_SEQUENCE);\n\n    /* Add the signedData OID and adjust lengths */\n    oid = OBJ_nid2obj(NID_pkcs7_signed);\n    oid_len = i2d_ASN1_OBJECT(oid, NULL);\n\n    tot_len = ASN1_object_size(1, (int)(orig_len+oid_len), V_ASN1_SEQUENCE);\n\n    p = *out = malloc(tot_len);\n    if (p == NULL) return -1;\n\n    ASN1_put_object(&p, 1, (int)(orig_len+oid_len),\n                    V_ASN1_SEQUENCE, V_ASN1_UNIVERSAL);\n\n    i2d_ASN1_OBJECT(oid, &p);\n\n    ASN1_put_object(&p, 1, (int)data_len, 0, V_ASN1_CONTEXT_SPECIFIC);\n    memcpy(p, data, data_len);\n\n    *out_len = tot_len;\n\n    return 0;\n}\n\nstatic int\nprepare_enc_data(const uint8_t *indata, int indata_len, uint8_t **outdata,\n                 int *outdata_len)\n{\n    int tag, class;\n    long tlen, slen;\n    const uint8_t *p = indata, *oldp;\n\n    if (ASN1_get_object(&p, &slen, &tag, &class, indata_len) & 0x80)\n        return EINVAL;\n    if (tag != V_ASN1_SEQUENCE)\n        return EINVAL;\n\n    oldp = p;\n    if (ASN1_get_object(&p, &tlen, &tag, &class, slen) & 0x80)\n        return EINVAL;\n    p += tlen;\n    slen -= (p - oldp);\n\n    if (ASN1_get_object(&p, &tlen, &tag, &class, slen) & 0x80)\n        return EINVAL;\n\n    *outdata = malloc(tlen);\n    if (*outdata == NULL)\n        return ENOMEM;\n    memcpy(*outdata, p, tlen);\n    *outdata_len = tlen;\n    return 0;\n}\n\n#ifndef WITHOUT_PKCS11\nstatic void *\npkinit_C_LoadModule(const char *modname, CK_FUNCTION_LIST_PTR_PTR p11p)\n{\n    void *handle;\n    CK_RV (*getflist)(CK_FUNCTION_LIST_PTR_PTR);\n\n    pkiDebug(\"loading module \\\"%s\\\"... \", modname);\n    handle = dlopen(modname, RTLD_NOW);\n    if (handle == NULL) {\n        pkiDebug(\"not found\\n\");\n        return NULL;\n    }\n    getflist = (CK_RV (*)(CK_FUNCTION_LIST_PTR_PTR)) dlsym(handle, \"C_GetFunctionList\");\n    if (getflist == NULL || (*getflist)(p11p) != CKR_OK) {\n        dlclose(handle);\n        pkiDebug(\"failed\\n\");\n        return NULL;\n    }\n    pkiDebug(\"ok\\n\");\n    return handle;\n}\n\nstatic CK_RV\npkinit_C_UnloadModule(void *handle)\n{\n    dlclose(handle);\n    return CKR_OK;\n}\n\nstatic krb5_error_code\npkinit_login(krb5_context context,\n             pkinit_identity_crypto_context id_cryptoctx,\n             CK_TOKEN_INFO *tip, const char *password)\n{\n    krb5_data rdat;\n    char *prompt;\n    const char *warning;\n    krb5_prompt kprompt;\n    krb5_prompt_type prompt_type;\n    int r = 0;\n\n    if (tip->flags & CKF_PROTECTED_AUTHENTICATION_PATH) {\n        rdat.data = NULL;\n        rdat.length = 0;\n    } else if (password != NULL) {\n        rdat.data = strdup(password);\n        rdat.length = strlen(password);\n    } else if (id_cryptoctx->prompter == NULL) {\n        r = KRB5_LIBOS_CANTREADPWD;\n        rdat.data = NULL;\n    } else {\n        if (tip->flags & CKF_USER_PIN_LOCKED)\n            warning = \" (Warning: PIN locked)\";\n        else if (tip->flags & CKF_USER_PIN_FINAL_TRY)\n            warning = \" (Warning: PIN final try)\";\n        else if (tip->flags & CKF_USER_PIN_COUNT_LOW)\n            warning = \" (Warning: PIN count low)\";\n        else\n            warning = \"\";\n        if (asprintf(&prompt, \"%.*s PIN%s\", (int) sizeof (tip->label),\n                     tip->label, warning) < 0)\n            return ENOMEM;\n        rdat.data = malloc(tip->ulMaxPinLen + 2);\n        rdat.length = tip->ulMaxPinLen + 1;\n\n        kprompt.prompt = prompt;\n        kprompt.hidden = 1;\n        kprompt.reply = &rdat;\n        prompt_type = KRB5_PROMPT_TYPE_PREAUTH;\n\n        /* PROMPTER_INVOCATION */\n        k5int_set_prompt_types(context, &prompt_type);\n        r = (*id_cryptoctx->prompter)(context, id_cryptoctx->prompter_data,\n                                      NULL, NULL, 1, &kprompt);\n        k5int_set_prompt_types(context, 0);\n        free(prompt);\n    }\n\n    if (r == 0) {\n        r = id_cryptoctx->p11->C_Login(id_cryptoctx->session, CKU_USER,\n                                       (u_char *) rdat.data, rdat.length);\n\n        if (r != CKR_OK) {\n            pkiDebug(\"C_Login: %s\\n\", pkinit_pkcs11_code_to_text(r));\n            r = KRB5KDC_ERR_PREAUTH_FAILED;\n        }\n    }\n    free(rdat.data);\n\n    return r;\n}\n\nstatic krb5_error_code\npkinit_open_session(krb5_context context,\n                    pkinit_identity_crypto_context cctx)\n{\n    CK_ULONG i, r;\n    unsigned char *cp;\n    size_t label_len;\n    CK_ULONG count = 0;\n    CK_SLOT_ID_PTR slotlist;\n    CK_TOKEN_INFO tinfo;\n    char *p11name;\n    const char *password;\n\n    if (cctx->p11_module != NULL)\n        return 0; /* session already open */\n\n    /* Load module */\n    cctx->p11_module =\n        pkinit_C_LoadModule(cctx->p11_module_name, &cctx->p11);\n    if (cctx->p11_module == NULL)\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n\n    /* Init */\n    if ((r = cctx->p11->C_Initialize(NULL)) != CKR_OK) {\n        pkiDebug(\"C_Initialize: %s\\n\", pkinit_pkcs11_code_to_text(r));\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n\n    /* Get the list of available slots */\n    if (cctx->p11->C_GetSlotList(TRUE, NULL, &count) != CKR_OK)\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    if (count == 0)\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    slotlist = calloc(count, sizeof(CK_SLOT_ID));\n    if (slotlist == NULL)\n        return ENOMEM;\n    if (cctx->p11->C_GetSlotList(TRUE, slotlist, &count) != CKR_OK)\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n\n    /* Look for the given token label, or if none given take the first one */\n    for (i = 0; i < count; i++) {\n        /* Skip slots that don't match the specified slotid, if given. */\n        if (cctx->slotid != PK_NOSLOT && cctx->slotid != slotlist[i])\n            continue;\n\n        /* Open session */\n        if ((r = cctx->p11->C_OpenSession(slotlist[i], CKF_SERIAL_SESSION,\n                                          NULL, NULL, &cctx->session)) != CKR_OK) {\n            pkiDebug(\"C_OpenSession: %s\\n\", pkinit_pkcs11_code_to_text(r));\n            return KRB5KDC_ERR_PREAUTH_FAILED;\n        }\n\n        /* Get token info */\n        if ((r = cctx->p11->C_GetTokenInfo(slotlist[i], &tinfo)) != CKR_OK) {\n            pkiDebug(\"C_GetTokenInfo: %s\\n\", pkinit_pkcs11_code_to_text(r));\n            return KRB5KDC_ERR_PREAUTH_FAILED;\n        }\n\n        /* tinfo.label is zero-filled but not necessarily zero-terminated.\n         * Find the length, ignoring any trailing spaces. */\n        for (cp = tinfo.label + sizeof(tinfo.label); cp > tinfo.label; cp--) {\n            if (cp[-1] != '\\0' && cp[-1] != ' ')\n                break;\n        }\n        label_len = cp - tinfo.label;\n\n        pkiDebug(\"open_session: slotid %d token \\\"%.*s\\\"\\n\",\n                 (int)slotlist[i], (int)label_len, tinfo.label);\n        if (cctx->token_label == NULL ||\n            (strlen(cctx->token_label) == label_len &&\n             memcmp(cctx->token_label, tinfo.label, label_len) == 0))\n            break;\n        cctx->p11->C_CloseSession(cctx->session);\n    }\n    if (i >= count) {\n        free(slotlist);\n        pkiDebug(\"open_session: no matching token found\\n\");\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n    cctx->slotid = slotlist[i];\n    free(slotlist);\n    pkiDebug(\"open_session: slotid %d (%lu of %d)\\n\", (int)cctx->slotid,\n             i + 1, (int) count);\n\n    /* Login if needed */\n    if (tinfo.flags & CKF_LOGIN_REQUIRED) {\n        if (cctx->p11_module_name != NULL) {\n            if (cctx->slotid != PK_NOSLOT) {\n                if (asprintf(&p11name,\n                             \"PKCS11:module_name=%s:slotid=%ld:token=%.*s\",\n                             cctx->p11_module_name, (long)cctx->slotid,\n                             (int)label_len, tinfo.label) < 0)\n                    p11name = NULL;\n            } else {\n                if (asprintf(&p11name,\n                             \"PKCS11:module_name=%s,token=%.*s\",\n                             cctx->p11_module_name,\n                             (int)label_len, tinfo.label) < 0)\n                    p11name = NULL;\n            }\n        } else {\n            p11name = NULL;\n        }\n        if (cctx->defer_id_prompt) {\n            /* Supply the identity name to be passed to the responder. */\n            pkinit_set_deferred_id(&cctx->deferred_ids,\n                                   p11name, tinfo.flags, NULL);\n            free(p11name);\n            return KRB5KRB_ERR_GENERIC;\n        }\n        /* Look up a responder-supplied password for the token. */\n        password = pkinit_find_deferred_id(cctx->deferred_ids, p11name);\n        free(p11name);\n        r = pkinit_login(context, cctx, &tinfo, password);\n    }\n\n    return r;\n}\n\n/*\n * Look for a key that's:\n * 1. private\n * 2. capable of the specified operation (usually signing or decrypting)\n * 3. RSA (this may be wrong but it's all we can do for now)\n * 4. matches the id of the cert we chose\n *\n * You must call pkinit_get_certs before calling pkinit_find_private_key\n * (that's because we need the ID of the private key)\n *\n * pkcs11 says the id of the key doesn't have to match that of the cert, but\n * I can't figure out any other way to decide which key to use.\n *\n * We should only find one key that fits all the requirements.\n * If there are more than one, we just take the first one.\n */\n\nkrb5_error_code\npkinit_find_private_key(pkinit_identity_crypto_context id_cryptoctx,\n                        CK_ATTRIBUTE_TYPE usage,\n                        CK_OBJECT_HANDLE *objp)\n{\n    CK_OBJECT_CLASS cls;\n    CK_ATTRIBUTE attrs[4];\n    CK_ULONG count;\n    CK_KEY_TYPE keytype;\n    unsigned int nattrs = 0;\n    int r;\n#ifdef PKINIT_USE_KEY_USAGE\n    CK_BBOOL true_false;\n#endif\n\n    cls = CKO_PRIVATE_KEY;\n    attrs[nattrs].type = CKA_CLASS;\n    attrs[nattrs].pValue = &cls;\n    attrs[nattrs].ulValueLen = sizeof cls;\n    nattrs++;\n\n#ifdef PKINIT_USE_KEY_USAGE\n    /*\n     * Some cards get confused if you try to specify a key usage,\n     * so don't, and hope for the best. This will fail if you have\n     * several keys with the same id and different usages but I have\n     * not seen this on real cards.\n     */\n    true_false = TRUE;\n    attrs[nattrs].type = usage;\n    attrs[nattrs].pValue = &true_false;\n    attrs[nattrs].ulValueLen = sizeof true_false;\n    nattrs++;\n#endif\n\n    keytype = CKK_RSA;\n    attrs[nattrs].type = CKA_KEY_TYPE;\n    attrs[nattrs].pValue = &keytype;\n    attrs[nattrs].ulValueLen = sizeof keytype;\n    nattrs++;\n\n    attrs[nattrs].type = CKA_ID;\n    attrs[nattrs].pValue = id_cryptoctx->cert_id;\n    attrs[nattrs].ulValueLen = id_cryptoctx->cert_id_len;\n    nattrs++;\n\n    r = id_cryptoctx->p11->C_FindObjectsInit(id_cryptoctx->session, attrs, nattrs);\n    if (r != CKR_OK) {\n        pkiDebug(\"krb5_pkinit_sign_data: C_FindObjectsInit: %s\\n\",\n                 pkinit_pkcs11_code_to_text(r));\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n\n    r = id_cryptoctx->p11->C_FindObjects(id_cryptoctx->session, objp, 1, &count);\n    id_cryptoctx->p11->C_FindObjectsFinal(id_cryptoctx->session);\n    pkiDebug(\"found %d private keys (%s)\\n\", (int) count, pkinit_pkcs11_code_to_text(r));\n    if (r != CKR_OK || count < 1)\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    return 0;\n}\n#endif\n\nstatic krb5_error_code\npkinit_decode_data_fs(krb5_context context,\n                      pkinit_identity_crypto_context id_cryptoctx,\n                      const uint8_t *data, unsigned int data_len,\n                      uint8_t **decoded_data, unsigned int *decoded_data_len)\n{\n    X509 *cert = sk_X509_value(id_cryptoctx->my_certs,\n                               id_cryptoctx->cert_index);\n    EVP_PKEY *pkey = id_cryptoctx->my_key;\n    uint8_t *buf;\n    int buf_len, decrypt_len;\n\n    *decoded_data = NULL;\n    *decoded_data_len = 0;\n\n    if (cert != NULL && !X509_check_private_key(cert, pkey)) {\n        pkiDebug(\"private key does not match certificate\\n\");\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n\n    buf_len = EVP_PKEY_size(pkey);\n    buf = malloc(buf_len + 10);\n    if (buf == NULL)\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n\n    decrypt_len = EVP_PKEY_decrypt_old(buf, data, data_len, pkey);\n    if (decrypt_len <= 0) {\n        pkiDebug(\"unable to decrypt received data (len=%d)\\n\", data_len);\n        free(buf);\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n\n    *decoded_data = buf;\n    *decoded_data_len = decrypt_len;\n    return 0;\n}\n\n#ifndef WITHOUT_PKCS11\n/*\n * When using the ActivCard Linux pkcs11 library (v2.0.1), the decrypt function\n * fails.  By inserting an extra function call, which serves nothing but to\n * change the stack, we were able to work around the issue.  If the ActivCard\n * library is fixed in the future, this function can be inlined back into the\n * caller.\n */\nstatic CK_RV\npkinit_C_Decrypt(pkinit_identity_crypto_context id_cryptoctx,\n                 CK_BYTE_PTR pEncryptedData,\n                 CK_ULONG  ulEncryptedDataLen,\n                 CK_BYTE_PTR pData,\n                 CK_ULONG_PTR pulDataLen)\n{\n    CK_RV rv = CKR_OK;\n\n    rv = id_cryptoctx->p11->C_Decrypt(id_cryptoctx->session, pEncryptedData,\n                                      ulEncryptedDataLen, pData, pulDataLen);\n    if (rv == CKR_OK) {\n        pkiDebug(\"pData %p *pulDataLen %d\\n\", (void *) pData,\n                 (int) *pulDataLen);\n    }\n    return rv;\n}\n\nstatic krb5_error_code\npkinit_decode_data_pkcs11(krb5_context context,\n                          pkinit_identity_crypto_context id_cryptoctx,\n                          const uint8_t *data, unsigned int data_len,\n                          uint8_t **decoded_data,\n                          unsigned int *decoded_data_len)\n{\n    CK_OBJECT_HANDLE obj;\n    CK_ULONG len;\n    CK_MECHANISM mech;\n    uint8_t *cp;\n    int r;\n\n    *decoded_data = NULL;\n    *decoded_data_len = 0;\n\n    if (pkinit_open_session(context, id_cryptoctx)) {\n        pkiDebug(\"can't open pkcs11 session\\n\");\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n\n    pkinit_find_private_key(id_cryptoctx, CKA_DECRYPT, &obj);\n\n    mech.mechanism = CKM_RSA_PKCS;\n    mech.pParameter = NULL;\n    mech.ulParameterLen = 0;\n\n    if ((r = id_cryptoctx->p11->C_DecryptInit(id_cryptoctx->session, &mech,\n                                              obj)) != CKR_OK) {\n        pkiDebug(\"C_DecryptInit: 0x%x\\n\", (int) r);\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n    pkiDebug(\"data_len = %d\\n\", data_len);\n    cp = malloc((size_t) data_len);\n    if (cp == NULL)\n        return ENOMEM;\n    len = data_len;\n    pkiDebug(\"session %p edata %p edata_len %d data %p datalen @%p %d\\n\",\n             (void *) id_cryptoctx->session, (void *) data, (int) data_len,\n             (void *) cp, (void *) &len, (int) len);\n    r = pkinit_C_Decrypt(id_cryptoctx, (CK_BYTE_PTR) data, (CK_ULONG) data_len,\n                         cp, &len);\n    if (r != CKR_OK) {\n        pkiDebug(\"C_Decrypt: %s\\n\", pkinit_pkcs11_code_to_text(r));\n        if (r == CKR_BUFFER_TOO_SMALL)\n            pkiDebug(\"decrypt %d needs %d\\n\", (int) data_len, (int) len);\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n    pkiDebug(\"decrypt %d -> %d\\n\", (int) data_len, (int) len);\n    *decoded_data_len = len;\n    *decoded_data = cp;\n\n    return 0;\n}\n#endif\n\nkrb5_error_code\npkinit_decode_data(krb5_context context,\n                   pkinit_identity_crypto_context id_cryptoctx,\n                   const uint8_t *data, unsigned int data_len,\n                   uint8_t **decoded_data, unsigned int *decoded_data_len)\n{\n    krb5_error_code retval = KRB5KDC_ERR_PREAUTH_FAILED;\n\n    *decoded_data = NULL;\n    *decoded_data_len = 0;\n\n    if (id_cryptoctx->pkcs11_method != 1)\n        retval = pkinit_decode_data_fs(context, id_cryptoctx, data, data_len,\n                                       decoded_data, decoded_data_len);\n#ifndef WITHOUT_PKCS11\n    else\n        retval = pkinit_decode_data_pkcs11(context, id_cryptoctx, data,\n                                           data_len, decoded_data, decoded_data_len);\n#endif\n\n    return retval;\n}\n\nstatic krb5_error_code\npkinit_sign_data_fs(krb5_context context,\n                    pkinit_identity_crypto_context id_cryptoctx,\n                    unsigned char *data,\n                    unsigned int data_len,\n                    unsigned char **sig,\n                    unsigned int *sig_len)\n{\n    if (create_signature(sig, sig_len, data, data_len,\n                         id_cryptoctx->my_key) != 0) {\n        pkiDebug(\"failed to create the signature\\n\");\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n    return 0;\n}\n\n#ifndef WITHOUT_PKCS11\nstatic krb5_error_code\npkinit_sign_data_pkcs11(krb5_context context,\n                        pkinit_identity_crypto_context id_cryptoctx,\n                        unsigned char *data,\n                        unsigned int data_len,\n                        unsigned char **sig,\n                        unsigned int *sig_len)\n{\n    CK_OBJECT_HANDLE obj;\n    CK_ULONG len;\n    CK_MECHANISM mech;\n    unsigned char *cp;\n    int r;\n\n    if (pkinit_open_session(context, id_cryptoctx)) {\n        pkiDebug(\"can't open pkcs11 session\\n\");\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n\n    pkinit_find_private_key(id_cryptoctx, CKA_SIGN, &obj);\n\n    mech.mechanism = id_cryptoctx->mech;\n    mech.pParameter = NULL;\n    mech.ulParameterLen = 0;\n\n    if ((r = id_cryptoctx->p11->C_SignInit(id_cryptoctx->session, &mech,\n                                           obj)) != CKR_OK) {\n        pkiDebug(\"C_SignInit: %s\\n\", pkinit_pkcs11_code_to_text(r));\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n\n    /*\n     * Key len would give an upper bound on sig size, but there's no way to\n     * get that. So guess, and if it's too small, re-malloc.\n     */\n    len = PK_SIGLEN_GUESS;\n    cp = malloc((size_t) len);\n    if (cp == NULL)\n        return ENOMEM;\n\n    r = id_cryptoctx->p11->C_Sign(id_cryptoctx->session, data,\n                                  (CK_ULONG) data_len, cp, &len);\n    if (r == CKR_BUFFER_TOO_SMALL || (r == CKR_OK && len >= PK_SIGLEN_GUESS)) {\n        free(cp);\n        pkiDebug(\"C_Sign realloc %d\\n\", (int) len);\n        cp = malloc((size_t) len);\n        r = id_cryptoctx->p11->C_Sign(id_cryptoctx->session, data,\n                                      (CK_ULONG) data_len, cp, &len);\n    }\n    if (r != CKR_OK) {\n        pkiDebug(\"C_Sign: %s\\n\", pkinit_pkcs11_code_to_text(r));\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n    pkiDebug(\"sign %d -> %d\\n\", (int) data_len, (int) len);\n    *sig_len = len;\n    *sig = cp;\n\n    return 0;\n}\n#endif\n\nkrb5_error_code\npkinit_sign_data(krb5_context context,\n                 pkinit_identity_crypto_context id_cryptoctx,\n                 unsigned char *data,\n                 unsigned int data_len,\n                 unsigned char **sig,\n                 unsigned int *sig_len)\n{\n    krb5_error_code retval = KRB5KDC_ERR_PREAUTH_FAILED;\n\n    if (id_cryptoctx == NULL || id_cryptoctx->pkcs11_method != 1)\n        retval = pkinit_sign_data_fs(context, id_cryptoctx, data, data_len,\n                                     sig, sig_len);\n#ifndef WITHOUT_PKCS11\n    else\n        retval = pkinit_sign_data_pkcs11(context, id_cryptoctx, data, data_len,\n                                         sig, sig_len);\n#endif\n\n    return retval;\n}\n\n\nstatic krb5_error_code\ncreate_signature(unsigned char **sig, unsigned int *sig_len,\n                 unsigned char *data, unsigned int data_len, EVP_PKEY *pkey)\n{\n    krb5_error_code retval = ENOMEM;\n    EVP_MD_CTX *ctx;\n\n    if (pkey == NULL)\n        return retval;\n\n    ctx = EVP_MD_CTX_new();\n    if (ctx == NULL)\n        return ENOMEM;\n    EVP_SignInit(ctx, EVP_sha1());\n    EVP_SignUpdate(ctx, data, data_len);\n    *sig_len = EVP_PKEY_size(pkey);\n    if ((*sig = malloc(*sig_len)) == NULL)\n        goto cleanup;\n    EVP_SignFinal(ctx, *sig, sig_len, pkey);\n\n    retval = 0;\n\ncleanup:\n    EVP_MD_CTX_free(ctx);\n\n    return retval;\n}\n\n/*\n * Note:\n * This is not the routine the KDC uses to get its certificate.\n * This routine is intended to be called by the client\n * to obtain the KDC's certificate from some local storage\n * to be sent as a hint in its request to the KDC.\n */\nkrb5_error_code\npkinit_get_kdc_cert(krb5_context context,\n                    pkinit_plg_crypto_context plg_cryptoctx,\n                    pkinit_req_crypto_context req_cryptoctx,\n                    pkinit_identity_crypto_context id_cryptoctx,\n                    krb5_principal princ)\n{\n    krb5_error_code retval = KRB5KDC_ERR_PREAUTH_FAILED;\n\n    req_cryptoctx->received_cert = NULL;\n    retval = 0;\n    return retval;\n}\n\nstatic char *\nreassemble_pkcs12_name(const char *filename)\n{\n    char *ret;\n\n    if (asprintf(&ret, \"PKCS12:%s\", filename) < 0)\n        return NULL;\n    return ret;\n}\n\nstatic krb5_error_code\npkinit_get_certs_pkcs12(krb5_context context,\n                        pkinit_plg_crypto_context plg_cryptoctx,\n                        pkinit_req_crypto_context req_cryptoctx,\n                        pkinit_identity_opts *idopts,\n                        pkinit_identity_crypto_context id_cryptoctx,\n                        krb5_principal princ)\n{\n    krb5_error_code retval = KRB5KDC_ERR_PREAUTH_FAILED;\n    char *prompt_string = NULL;\n    X509 *x = NULL;\n    PKCS12 *p12 = NULL;\n    int ret;\n    FILE *fp;\n    EVP_PKEY *y = NULL;\n\n    if (idopts->cert_filename == NULL) {\n        pkiDebug(\"%s: failed to get user's cert location\\n\", __FUNCTION__);\n        goto cleanup;\n    }\n\n    if (idopts->key_filename == NULL) {\n        pkiDebug(\"%s: failed to get user's private key location\\n\", __FUNCTION__);\n        goto cleanup;\n    }\n\n    fp = fopen(idopts->cert_filename, \"rb\");\n    if (fp == NULL) {\n        TRACE_PKINIT_PKCS_OPEN_FAIL(context, idopts->cert_filename, errno);\n        goto cleanup;\n    }\n    set_cloexec_file(fp);\n\n    p12 = d2i_PKCS12_fp(fp, NULL);\n    fclose(fp);\n    if (p12 == NULL) {\n        TRACE_PKINIT_PKCS_DECODE_FAIL(context, idopts->cert_filename);\n        goto cleanup;\n    }\n    /*\n     * Try parsing with no pass phrase first.  If that fails,\n     * prompt for the pass phrase and try again.\n     */\n    ret = PKCS12_parse(p12, NULL, &y, &x, NULL);\n    if (ret == 0) {\n        krb5_data rdat;\n        krb5_prompt kprompt;\n        krb5_prompt_type prompt_type;\n        krb5_error_code r;\n        char prompt_reply[128];\n        char *prompt_prefix = _(\"Pass phrase for\");\n        char *p12name = reassemble_pkcs12_name(idopts->cert_filename);\n        const char *tmp;\n\n        TRACE_PKINIT_PKCS_PARSE_FAIL_FIRST(context);\n\n        if (id_cryptoctx->defer_id_prompt) {\n            /* Supply the identity name to be passed to the responder. */\n            pkinit_set_deferred_id(&id_cryptoctx->deferred_ids, p12name, 0,\n                                   NULL);\n            free(p12name);\n            retval = 0;\n            goto cleanup;\n        }\n        /* Try to read a responder-supplied password. */\n        tmp = pkinit_find_deferred_id(id_cryptoctx->deferred_ids, p12name);\n        free(p12name);\n        if (tmp != NULL) {\n            /* Try using the responder-supplied password. */\n            rdat.data = (char *)tmp;\n            rdat.length = strlen(tmp);\n        } else if (id_cryptoctx->prompter == NULL) {\n            /* We can't use a prompter. */\n            goto cleanup;\n        } else {\n            /* Ask using a prompter. */\n            memset(prompt_reply, '\\0', sizeof(prompt_reply));\n            rdat.data = prompt_reply;\n            rdat.length = sizeof(prompt_reply);\n\n            if (asprintf(&prompt_string, \"%s %s\", prompt_prefix,\n                         idopts->cert_filename) < 0) {\n                prompt_string = NULL;\n                goto cleanup;\n            }\n            kprompt.prompt = prompt_string;\n            kprompt.hidden = 1;\n            kprompt.reply = &rdat;\n            prompt_type = KRB5_PROMPT_TYPE_PREAUTH;\n            /* PROMPTER_INVOCATION */\n            k5int_set_prompt_types(context, &prompt_type);\n            r = (*id_cryptoctx->prompter)(context, id_cryptoctx->prompter_data,\n                                          NULL, NULL, 1, &kprompt);\n            k5int_set_prompt_types(context, 0);\n            if (r) {\n                TRACE_PKINIT_PKCS_PROMPT_FAIL(context);\n                goto cleanup;\n            }\n        }\n\n        ret = PKCS12_parse(p12, rdat.data, &y, &x, NULL);\n        if (ret == 0) {\n            TRACE_PKINIT_PKCS_PARSE_FAIL_SECOND(context);\n            goto cleanup;\n        }\n    }\n    id_cryptoctx->creds[0] = malloc(sizeof(struct _pkinit_cred_info));\n    if (id_cryptoctx->creds[0] == NULL)\n        goto cleanup;\n    id_cryptoctx->creds[0]->name =\n        reassemble_pkcs12_name(idopts->cert_filename);\n    id_cryptoctx->creds[0]->cert = x;\n#ifndef WITHOUT_PKCS11\n    id_cryptoctx->creds[0]->cert_id = NULL;\n    id_cryptoctx->creds[0]->cert_id_len = 0;\n#endif\n    id_cryptoctx->creds[0]->key = y;\n    id_cryptoctx->creds[1] = NULL;\n\n    retval = 0;\n\ncleanup:\n    free(prompt_string);\n    if (p12)\n        PKCS12_free(p12);\n    if (retval) {\n        if (x != NULL)\n            X509_free(x);\n        if (y != NULL)\n            EVP_PKEY_free(y);\n    }\n    return retval;\n}\n\nstatic char *\nreassemble_files_name(const char *certfile, const char *keyfile)\n{\n    char *ret;\n\n    if (keyfile != NULL) {\n        if (asprintf(&ret, \"FILE:%s,%s\", certfile, keyfile) < 0)\n            return NULL;\n    } else {\n        if (asprintf(&ret, \"FILE:%s\", certfile) < 0)\n            return NULL;\n    }\n    return ret;\n}\n\nstatic krb5_error_code\npkinit_load_fs_cert_and_key(krb5_context context,\n                            pkinit_identity_crypto_context id_cryptoctx,\n                            char *certname,\n                            char *keyname,\n                            int cindex)\n{\n    krb5_error_code retval;\n    X509 *x = NULL;\n    EVP_PKEY *y = NULL;\n    char *fsname = NULL;\n    const char *password;\n\n    fsname = reassemble_files_name(certname, keyname);\n\n    /* Try to read a responder-supplied password. */\n    password = pkinit_find_deferred_id(id_cryptoctx->deferred_ids, fsname);\n\n    /* Load the certificate. */\n    retval = get_cert(certname, &x);\n    if (retval != 0 || x == NULL) {\n        retval = oerr(context, 0, _(\"Cannot read certificate file '%s'\"),\n                      certname);\n        goto cleanup;\n    }\n    /* Load the key. */\n    retval = get_key(context, id_cryptoctx, keyname, fsname, &y, password);\n    if (retval != 0 || y == NULL) {\n        retval = oerr(context, 0, _(\"Cannot read key file '%s'\"), fsname);\n        goto cleanup;\n    }\n\n    id_cryptoctx->creds[cindex] = malloc(sizeof(struct _pkinit_cred_info));\n    if (id_cryptoctx->creds[cindex] == NULL) {\n        retval = ENOMEM;\n        goto cleanup;\n    }\n    id_cryptoctx->creds[cindex]->name = reassemble_files_name(certname,\n                                                              keyname);\n    id_cryptoctx->creds[cindex]->cert = x;\n#ifndef WITHOUT_PKCS11\n    id_cryptoctx->creds[cindex]->cert_id = NULL;\n    id_cryptoctx->creds[cindex]->cert_id_len = 0;\n#endif\n    id_cryptoctx->creds[cindex]->key = y;\n    id_cryptoctx->creds[cindex+1] = NULL;\n\n    retval = 0;\n\ncleanup:\n    free(fsname);\n    if (retval != 0 || y == NULL) {\n        if (x != NULL)\n            X509_free(x);\n        if (y != NULL)\n            EVP_PKEY_free(y);\n    }\n    return retval;\n}\n\nstatic krb5_error_code\npkinit_get_certs_fs(krb5_context context,\n                    pkinit_plg_crypto_context plg_cryptoctx,\n                    pkinit_req_crypto_context req_cryptoctx,\n                    pkinit_identity_opts *idopts,\n                    pkinit_identity_crypto_context id_cryptoctx,\n                    krb5_principal princ)\n{\n    krb5_error_code retval = KRB5KDC_ERR_PREAUTH_FAILED;\n\n    if (idopts->cert_filename == NULL) {\n        pkiDebug(\"%s: failed to get user's cert location\\n\", __FUNCTION__);\n        goto cleanup;\n    }\n\n    if (idopts->key_filename == NULL) {\n        TRACE_PKINIT_NO_PRIVKEY(context);\n        goto cleanup;\n    }\n\n    retval = pkinit_load_fs_cert_and_key(context, id_cryptoctx,\n                                         idopts->cert_filename,\n                                         idopts->key_filename, 0);\ncleanup:\n    return retval;\n}\n\nstatic krb5_error_code\npkinit_get_certs_dir(krb5_context context,\n                     pkinit_plg_crypto_context plg_cryptoctx,\n                     pkinit_req_crypto_context req_cryptoctx,\n                     pkinit_identity_opts *idopts,\n                     pkinit_identity_crypto_context id_cryptoctx,\n                     krb5_principal princ)\n{\n    krb5_error_code retval = ENOMEM;\n    DIR *d = NULL;\n    struct dirent *dentry = NULL;\n    char certname[1024];\n    char keyname[1024];\n    int i = 0, len;\n    char *dirname, *suf;\n\n    if (idopts->cert_filename == NULL) {\n        TRACE_PKINIT_NO_CERT(context);\n        return ENOENT;\n    }\n\n    dirname = idopts->cert_filename;\n    d = opendir(dirname);\n    if (d == NULL)\n        return errno;\n\n    /*\n     * We'll assume that certs are named XXX.crt and the corresponding\n     * key is named XXX.key\n     */\n    while ((i < MAX_CREDS_ALLOWED) &&  (dentry = readdir(d)) != NULL) {\n        /* Ignore subdirectories and anything starting with a dot */\n#ifdef DT_DIR\n        if (dentry->d_type == DT_DIR)\n            continue;\n#endif\n        if (dentry->d_name[0] == '.')\n            continue;\n        len = strlen(dentry->d_name);\n        if (len < 5)\n            continue;\n        suf = dentry->d_name + (len - 4);\n        if (strncmp(suf, \".crt\", 4) != 0)\n            continue;\n\n        /* Checked length */\n        if (strlen(dirname) + strlen(dentry->d_name) + 2 > sizeof(certname)) {\n            pkiDebug(\"%s: Path too long -- directory '%s' and file '%s'\\n\",\n                     __FUNCTION__, dirname, dentry->d_name);\n            continue;\n        }\n        snprintf(certname, sizeof(certname), \"%s/%s\", dirname, dentry->d_name);\n        snprintf(keyname, sizeof(keyname), \"%s/%s\", dirname, dentry->d_name);\n        len = strlen(keyname);\n        keyname[len - 3] = 'k';\n        keyname[len - 2] = 'e';\n        keyname[len - 1] = 'y';\n\n        retval = pkinit_load_fs_cert_and_key(context, id_cryptoctx,\n                                             certname, keyname, i);\n        if (retval == 0) {\n            TRACE_PKINIT_LOADED_CERT(context, dentry->d_name);\n            i++;\n        }\n        else\n            continue;\n    }\n\n    if (!id_cryptoctx->defer_id_prompt && i == 0) {\n        TRACE_PKINIT_NO_CERT_AND_KEY(context, idopts->cert_filename);\n        retval = ENOENT;\n        goto cleanup;\n    }\n\n    retval = 0;\n\ncleanup:\n    if (d)\n        closedir(d);\n\n    return retval;\n}\n\n#ifndef WITHOUT_PKCS11\nstatic char *\nreassemble_pkcs11_name(pkinit_identity_opts *idopts)\n{\n    struct k5buf buf;\n    int n = 0;\n    char *ret;\n\n    k5_buf_init_dynamic(&buf);\n    k5_buf_add(&buf, \"PKCS11:\");\n    n = 0;\n    if (idopts->p11_module_name != NULL) {\n        k5_buf_add_fmt(&buf, \"%smodule_name=%s\", n++ ? \":\" : \"\",\n                       idopts->p11_module_name);\n    }\n    if (idopts->token_label != NULL) {\n        k5_buf_add_fmt(&buf, \"%stoken=%s\", n++ ? \":\" : \"\",\n                       idopts->token_label);\n    }\n    if (idopts->cert_label != NULL) {\n        k5_buf_add_fmt(&buf, \"%scertlabel=%s\", n++ ? \":\" : \"\",\n                       idopts->cert_label);\n    }\n    if (idopts->cert_id_string != NULL) {\n        k5_buf_add_fmt(&buf, \"%scertid=%s\", n++ ? \":\" : \"\",\n                       idopts->cert_id_string);\n    }\n    if (idopts->slotid != PK_NOSLOT) {\n        k5_buf_add_fmt(&buf, \"%sslotid=%ld\", n++ ? \":\" : \"\",\n                       (long)idopts->slotid);\n    }\n    if (k5_buf_status(&buf) == 0)\n        ret = strdup(buf.data);\n    else\n        ret = NULL;\n    k5_buf_free(&buf);\n    return ret;\n}\n\nstatic krb5_error_code\npkinit_get_certs_pkcs11(krb5_context context,\n                        pkinit_plg_crypto_context plg_cryptoctx,\n                        pkinit_req_crypto_context req_cryptoctx,\n                        pkinit_identity_opts *idopts,\n                        pkinit_identity_crypto_context id_cryptoctx,\n                        krb5_principal princ)\n{\n#ifdef PKINIT_USE_MECH_LIST\n    CK_MECHANISM_TYPE_PTR mechp;\n    CK_MECHANISM_INFO info;\n#endif\n    CK_OBJECT_CLASS cls;\n    CK_OBJECT_HANDLE obj;\n    CK_ATTRIBUTE attrs[4];\n    CK_ULONG count;\n    CK_CERTIFICATE_TYPE certtype;\n    CK_BYTE_PTR cert = NULL, cert_id;\n    const unsigned char *cp;\n    int i, r;\n    unsigned int nattrs;\n    X509 *x = NULL;\n\n    /* Copy stuff from idopts -> id_cryptoctx */\n    if (idopts->p11_module_name != NULL) {\n        free(id_cryptoctx->p11_module_name);\n        id_cryptoctx->p11_module_name = strdup(idopts->p11_module_name);\n        if (id_cryptoctx->p11_module_name == NULL)\n            return ENOMEM;\n    }\n    if (idopts->token_label != NULL) {\n        id_cryptoctx->token_label = strdup(idopts->token_label);\n        if (id_cryptoctx->token_label == NULL)\n            return ENOMEM;\n    }\n    if (idopts->cert_label != NULL) {\n        id_cryptoctx->cert_label = strdup(idopts->cert_label);\n        if (id_cryptoctx->cert_label == NULL)\n            return ENOMEM;\n    }\n    /* Convert the ascii cert_id string into a binary blob */\n    if (idopts->cert_id_string != NULL) {\n        r = k5_hex_decode(idopts->cert_id_string,\n                          &id_cryptoctx->cert_id, &id_cryptoctx->cert_id_len);\n        if (r != 0) {\n            pkiDebug(\"Failed to convert certid string [%s]\\n\",\n                     idopts->cert_id_string);\n            return r;\n        }\n    }\n    id_cryptoctx->slotid = idopts->slotid;\n    id_cryptoctx->pkcs11_method = 1;\n\n    if (pkinit_open_session(context, id_cryptoctx)) {\n        pkiDebug(\"can't open pkcs11 session\\n\");\n        if (!id_cryptoctx->defer_id_prompt)\n            return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n    if (id_cryptoctx->defer_id_prompt) {\n        /*\n         * We need to reset all of the PKCS#11 state, so that the next time we\n         * poke at it, it'll be in as close to the state it was in after we\n         * loaded it the first time as we can make it.\n         */\n        pkinit_fini_pkcs11(id_cryptoctx);\n        pkinit_init_pkcs11(id_cryptoctx);\n        return 0;\n    }\n\n#ifndef PKINIT_USE_MECH_LIST\n    /*\n     * We'd like to use CKM_SHA1_RSA_PKCS for signing if it's available, but\n     * many cards seems to be confused about whether they are capable of\n     * this or not. The safe thing seems to be to ignore the mechanism list,\n     * always use CKM_RSA_PKCS and calculate the sha1 digest ourselves.\n     */\n\n    id_cryptoctx->mech = CKM_RSA_PKCS;\n#else\n    if ((r = id_cryptoctx->p11->C_GetMechanismList(id_cryptoctx->slotid, NULL,\n                                                   &count)) != CKR_OK || count <= 0) {\n        pkiDebug(\"C_GetMechanismList: %s\\n\", pkinit_pkcs11_code_to_text(r));\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n    mechp = malloc(count * sizeof (CK_MECHANISM_TYPE));\n    if (mechp == NULL)\n        return ENOMEM;\n    if ((r = id_cryptoctx->p11->C_GetMechanismList(id_cryptoctx->slotid,\n                                                   mechp, &count)) != CKR_OK)\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    for (i = 0; i < count; i++) {\n        if ((r = id_cryptoctx->p11->C_GetMechanismInfo(id_cryptoctx->slotid,\n                                                       mechp[i], &info)) != CKR_OK)\n            return KRB5KDC_ERR_PREAUTH_FAILED;\n#ifdef DEBUG_MECHINFO\n        pkiDebug(\"mech %x flags %x\\n\", (int) mechp[i], (int) info.flags);\n        if ((info.flags & (CKF_SIGN|CKF_DECRYPT)) == (CKF_SIGN|CKF_DECRYPT))\n            pkiDebug(\"  this mech is good for sign & decrypt\\n\");\n#endif\n        if (mechp[i] == CKM_RSA_PKCS) {\n            /* This seems backwards... */\n            id_cryptoctx->mech =\n                (info.flags & CKF_SIGN) ? CKM_SHA1_RSA_PKCS : CKM_RSA_PKCS;\n        }\n    }\n    free(mechp);\n\n    pkiDebug(\"got %d mechs from card\\n\", (int) count);\n#endif\n\n    cls = CKO_CERTIFICATE;\n    attrs[0].type = CKA_CLASS;\n    attrs[0].pValue = &cls;\n    attrs[0].ulValueLen = sizeof cls;\n\n    certtype = CKC_X_509;\n    attrs[1].type = CKA_CERTIFICATE_TYPE;\n    attrs[1].pValue = &certtype;\n    attrs[1].ulValueLen = sizeof certtype;\n\n    nattrs = 2;\n\n    /* If a cert id and/or label were given, use them too */\n    if (id_cryptoctx->cert_id_len > 0) {\n        attrs[nattrs].type = CKA_ID;\n        attrs[nattrs].pValue = id_cryptoctx->cert_id;\n        attrs[nattrs].ulValueLen = id_cryptoctx->cert_id_len;\n        nattrs++;\n    }\n    if (id_cryptoctx->cert_label != NULL) {\n        attrs[nattrs].type = CKA_LABEL;\n        attrs[nattrs].pValue = id_cryptoctx->cert_label;\n        attrs[nattrs].ulValueLen = strlen(id_cryptoctx->cert_label);\n        nattrs++;\n    }\n\n    r = id_cryptoctx->p11->C_FindObjectsInit(id_cryptoctx->session, attrs, nattrs);\n    if (r != CKR_OK) {\n        pkiDebug(\"C_FindObjectsInit: %s\\n\", pkinit_pkcs11_code_to_text(r));\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    }\n\n    for (i = 0; ; i++) {\n        if (i >= MAX_CREDS_ALLOWED)\n            return KRB5KDC_ERR_PREAUTH_FAILED;\n\n        /* Look for x.509 cert */\n        if ((r = id_cryptoctx->p11->C_FindObjects(id_cryptoctx->session,\n                                                  &obj, 1, &count)) != CKR_OK || count <= 0) {\n            id_cryptoctx->creds[i] = NULL;\n            break;\n        }\n\n        /* Get cert and id len */\n        attrs[0].type = CKA_VALUE;\n        attrs[0].pValue = NULL;\n        attrs[0].ulValueLen = 0;\n\n        attrs[1].type = CKA_ID;\n        attrs[1].pValue = NULL;\n        attrs[1].ulValueLen = 0;\n\n        if ((r = id_cryptoctx->p11->C_GetAttributeValue(id_cryptoctx->session,\n                                                        obj, attrs, 2)) != CKR_OK && r != CKR_BUFFER_TOO_SMALL) {\n            pkiDebug(\"C_GetAttributeValue: %s\\n\", pkinit_pkcs11_code_to_text(r));\n            return KRB5KDC_ERR_PREAUTH_FAILED;\n        }\n        cert = (CK_BYTE_PTR) malloc((size_t) attrs[0].ulValueLen + 1);\n        cert_id = (CK_BYTE_PTR) malloc((size_t) attrs[1].ulValueLen + 1);\n        if (cert == NULL || cert_id == NULL)\n            return ENOMEM;\n\n        /* Read the cert and id off the card */\n\n        attrs[0].type = CKA_VALUE;\n        attrs[0].pValue = cert;\n\n        attrs[1].type = CKA_ID;\n        attrs[1].pValue = cert_id;\n\n        if ((r = id_cryptoctx->p11->C_GetAttributeValue(id_cryptoctx->session,\n                                                        obj, attrs, 2)) != CKR_OK) {\n            pkiDebug(\"C_GetAttributeValue: %s\\n\", pkinit_pkcs11_code_to_text(r));\n            return KRB5KDC_ERR_PREAUTH_FAILED;\n        }\n\n        pkiDebug(\"cert %d size %d id %d idlen %d\\n\", i,\n                 (int) attrs[0].ulValueLen, (int) cert_id[0],\n                 (int) attrs[1].ulValueLen);\n\n        cp = (unsigned char *) cert;\n        x = d2i_X509(NULL, &cp, (int) attrs[0].ulValueLen);\n        if (x == NULL)\n            return KRB5KDC_ERR_PREAUTH_FAILED;\n        id_cryptoctx->creds[i] = malloc(sizeof(struct _pkinit_cred_info));\n        if (id_cryptoctx->creds[i] == NULL)\n            return KRB5KDC_ERR_PREAUTH_FAILED;\n        id_cryptoctx->creds[i]->name = reassemble_pkcs11_name(idopts);\n        id_cryptoctx->creds[i]->cert = x;\n        id_cryptoctx->creds[i]->key = NULL;\n        id_cryptoctx->creds[i]->cert_id = cert_id;\n        id_cryptoctx->creds[i]->cert_id_len = attrs[1].ulValueLen;\n        free(cert);\n    }\n    id_cryptoctx->p11->C_FindObjectsFinal(id_cryptoctx->session);\n    if (cert == NULL)\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n    return 0;\n}\n#endif\n\n\nstatic void\nfree_cred_info(krb5_context context,\n               pkinit_identity_crypto_context id_cryptoctx,\n               struct _pkinit_cred_info *cred)\n{\n    if (cred != NULL) {\n        if (cred->cert != NULL)\n            X509_free(cred->cert);\n        if (cred->key != NULL)\n            EVP_PKEY_free(cred->key);\n#ifndef WITHOUT_PKCS11\n        free(cred->cert_id);\n#endif\n        free(cred->name);\n        free(cred);\n    }\n}\n\nkrb5_error_code\ncrypto_free_cert_info(krb5_context context,\n                      pkinit_plg_crypto_context plg_cryptoctx,\n                      pkinit_req_crypto_context req_cryptoctx,\n                      pkinit_identity_crypto_context id_cryptoctx)\n{\n    int i;\n\n    if (id_cryptoctx == NULL)\n        return EINVAL;\n\n    for (i = 0; i < MAX_CREDS_ALLOWED; i++) {\n        if (id_cryptoctx->creds[i] != NULL) {\n            free_cred_info(context, id_cryptoctx, id_cryptoctx->creds[i]);\n            id_cryptoctx->creds[i] = NULL;\n        }\n    }\n    return 0;\n}\n\nkrb5_error_code\ncrypto_load_certs(krb5_context context,\n                  pkinit_plg_crypto_context plg_cryptoctx,\n                  pkinit_req_crypto_context req_cryptoctx,\n                  pkinit_identity_opts *idopts,\n                  pkinit_identity_crypto_context id_cryptoctx,\n                  krb5_principal princ,\n                  krb5_boolean defer_id_prompts)\n{\n    krb5_error_code retval;\n\n    id_cryptoctx->defer_id_prompt = defer_id_prompts;\n\n    switch(idopts->idtype) {\n    case IDTYPE_FILE:\n        retval = pkinit_get_certs_fs(context, plg_cryptoctx,\n                                     req_cryptoctx, idopts,\n                                     id_cryptoctx, princ);\n        break;\n    case IDTYPE_DIR:\n        retval = pkinit_get_certs_dir(context, plg_cryptoctx,\n                                      req_cryptoctx, idopts,\n                                      id_cryptoctx, princ);\n        break;\n#ifndef WITHOUT_PKCS11\n    case IDTYPE_PKCS11:\n        retval = pkinit_get_certs_pkcs11(context, plg_cryptoctx,\n                                         req_cryptoctx, idopts,\n                                         id_cryptoctx, princ);\n        break;\n#endif\n    case IDTYPE_PKCS12:\n        retval = pkinit_get_certs_pkcs12(context, plg_cryptoctx,\n                                         req_cryptoctx, idopts,\n                                         id_cryptoctx, princ);\n        break;\n    default:\n        retval = EINVAL;\n    }\n    if (retval)\n        goto cleanup;\n\ncleanup:\n    return retval;\n}\n\n/*\n * Get certificate Key Usage and Extended Key Usage\n */\nstatic krb5_error_code\ncrypto_retrieve_X509_key_usage(krb5_context context,\n                               pkinit_plg_crypto_context plgcctx,\n                               pkinit_req_crypto_context reqcctx,\n                               X509 *x,\n                               unsigned int *ret_ku_bits,\n                               unsigned int *ret_eku_bits)\n{\n    krb5_error_code retval = 0;\n    int i;\n    unsigned int eku_bits = 0, ku_bits = 0;\n    ASN1_BIT_STRING *usage = NULL;\n\n    if (ret_ku_bits == NULL && ret_eku_bits == NULL)\n        return EINVAL;\n\n    if (ret_eku_bits)\n        *ret_eku_bits = 0;\n    else {\n        pkiDebug(\"%s: EKUs not requested, not checking\\n\", __FUNCTION__);\n        goto check_kus;\n    }\n\n    /* Start with Extended Key usage */\n    i = X509_get_ext_by_NID(x, NID_ext_key_usage, -1);\n    if (i >= 0) {\n        EXTENDED_KEY_USAGE *eku;\n\n        eku = X509_get_ext_d2i(x, NID_ext_key_usage, NULL, NULL);\n        if (eku) {\n            for (i = 0; i < sk_ASN1_OBJECT_num(eku); i++) {\n                ASN1_OBJECT *certoid;\n                certoid = sk_ASN1_OBJECT_value(eku, i);\n                if ((OBJ_cmp(certoid, plgcctx->id_pkinit_KPClientAuth)) == 0)\n                    eku_bits |= PKINIT_EKU_PKINIT;\n                else if ((OBJ_cmp(certoid, OBJ_nid2obj(NID_ms_smartcard_login))) == 0)\n                    eku_bits |= PKINIT_EKU_MSSCLOGIN;\n                else if ((OBJ_cmp(certoid, OBJ_nid2obj(NID_client_auth))) == 0)\n                    eku_bits |= PKINIT_EKU_CLIENTAUTH;\n                else if ((OBJ_cmp(certoid, OBJ_nid2obj(NID_email_protect))) == 0)\n                    eku_bits |= PKINIT_EKU_EMAILPROTECTION;\n            }\n            EXTENDED_KEY_USAGE_free(eku);\n        }\n    }\n    pkiDebug(\"%s: returning eku 0x%08x\\n\", __FUNCTION__, eku_bits);\n    *ret_eku_bits = eku_bits;\n\ncheck_kus:\n    /* Now the Key Usage bits */\n    if (ret_ku_bits)\n        *ret_ku_bits = 0;\n    else {\n        pkiDebug(\"%s: KUs not requested, not checking\\n\", __FUNCTION__);\n        goto out;\n    }\n\n    /* Make sure usage exists before checking bits */\n    X509_check_ca(x);\n    usage = X509_get_ext_d2i(x, NID_key_usage, NULL, NULL);\n    if (usage) {\n        if (!ku_reject(x, X509v3_KU_DIGITAL_SIGNATURE))\n            ku_bits |= PKINIT_KU_DIGITALSIGNATURE;\n        if (!ku_reject(x, X509v3_KU_KEY_ENCIPHERMENT))\n            ku_bits |= PKINIT_KU_KEYENCIPHERMENT;\n        ASN1_BIT_STRING_free(usage);\n    }\n\n    pkiDebug(\"%s: returning ku 0x%08x\\n\", __FUNCTION__, ku_bits);\n    *ret_ku_bits = ku_bits;\n    retval = 0;\nout:\n    return retval;\n}\n\nstatic krb5_error_code\nrfc2253_name(X509_NAME *name, char **str_out)\n{\n    BIO *b = NULL;\n    char *str;\n\n    *str_out = NULL;\n    b = BIO_new(BIO_s_mem());\n    if (b == NULL)\n        return ENOMEM;\n    if (X509_NAME_print_ex(b, name, 0, XN_FLAG_SEP_COMMA_PLUS) < 0)\n        goto error;\n    str = calloc(BIO_number_written(b) + 1, 1);\n    if (str == NULL)\n        goto error;\n    BIO_read(b, str, BIO_number_written(b));\n    BIO_free(b);\n    *str_out = str;\n    return 0;\n\nerror:\n    BIO_free(b);\n    return ENOMEM;\n}\n\n/*\n * Get number of certificates available after crypto_load_certs()\n */\nstatic krb5_error_code\ncrypto_cert_get_count(pkinit_identity_crypto_context id_cryptoctx,\n                      int *cert_count)\n{\n    int count;\n\n    *cert_count = 0;\n    if (id_cryptoctx == NULL || id_cryptoctx->creds[0] == NULL)\n        return EINVAL;\n\n    for (count = 0;\n         count <= MAX_CREDS_ALLOWED && id_cryptoctx->creds[count] != NULL;\n         count++);\n    *cert_count = count;\n    return 0;\n}\n\nvoid\ncrypto_cert_free_matching_data(krb5_context context,\n                               pkinit_cert_matching_data *md)\n{\n    int i;\n\n    if (md == NULL)\n        return;\n    free(md->subject_dn);\n    free(md->issuer_dn);\n    for (i = 0; md->sans != NULL && md->sans[i] != NULL; i++)\n        krb5_free_principal(context, md->sans[i]);\n    free(md->sans);\n    for (i = 0; md->upns != NULL && md->upns[i] != NULL; i++)\n        free(md->upns[i]);\n    free(md->upns);\n    free(md);\n}\n\n/*\n * Free certificate matching data.\n */\nvoid\ncrypto_cert_free_matching_data_list(krb5_context context,\n                                    pkinit_cert_matching_data **list)\n{\n    int i;\n\n    for (i = 0; list != NULL && list[i] != NULL; i++)\n        crypto_cert_free_matching_data(context, list[i]);\n    free(list);\n}\n\n/*\n * Get certificate matching data for cert.\n */\nstatic krb5_error_code\nget_matching_data(krb5_context context,\n                  pkinit_plg_crypto_context plg_cryptoctx,\n                  pkinit_req_crypto_context req_cryptoctx, X509 *cert,\n                  pkinit_cert_matching_data **md_out)\n{\n    krb5_error_code ret = ENOMEM;\n    pkinit_cert_matching_data *md = NULL;\n\n    *md_out = NULL;\n\n    md = calloc(1, sizeof(*md));\n    if (md == NULL)\n        goto cleanup;\n\n    ret = rfc2253_name(X509_get_subject_name(cert), &md->subject_dn);\n    if (ret)\n        goto cleanup;\n    ret = rfc2253_name(X509_get_issuer_name(cert), &md->issuer_dn);\n    if (ret)\n        goto cleanup;\n\n    /* Get the SAN data. */\n    ret = crypto_retrieve_X509_sans(context, plg_cryptoctx, req_cryptoctx,\n                                    cert, &md->sans, &md->upns, NULL);\n    if (ret)\n        goto cleanup;\n\n    /* Get the KU and EKU data. */\n    ret = crypto_retrieve_X509_key_usage(context, plg_cryptoctx,\n                                         req_cryptoctx, cert, &md->ku_bits,\n                                         &md->eku_bits);\n    if (ret)\n        goto cleanup;\n\n    *md_out = md;\n    md = NULL;\n\ncleanup:\n    crypto_cert_free_matching_data(context, md);\n    return ret;\n}\n\nkrb5_error_code\ncrypto_cert_get_matching_data(krb5_context context,\n                              pkinit_plg_crypto_context plg_cryptoctx,\n                              pkinit_req_crypto_context req_cryptoctx,\n                              pkinit_identity_crypto_context id_cryptoctx,\n                              pkinit_cert_matching_data ***md_out)\n{\n    krb5_error_code ret;\n    pkinit_cert_matching_data **md_list = NULL;\n    int count, i;\n\n    ret = crypto_cert_get_count(id_cryptoctx, &count);\n    if (ret)\n        goto cleanup;\n\n    md_list = calloc(count + 1, sizeof(*md_list));\n    if (md_list == NULL) {\n        ret = ENOMEM;\n        goto cleanup;\n    }\n\n    for (i = 0; i < count; i++) {\n        ret = get_matching_data(context, plg_cryptoctx, req_cryptoctx,\n                                id_cryptoctx->creds[i]->cert, &md_list[i]);\n        if (ret) {\n            pkiDebug(\"%s: crypto_cert_get_matching_data error %d, %s\\n\",\n                     __FUNCTION__, ret, error_message(ret));\n            goto cleanup;\n        }\n    }\n\n    *md_out = md_list;\n    md_list = NULL;\n\ncleanup:\n    crypto_cert_free_matching_data_list(context, md_list);\n    return ret;\n}\n\n/*\n * Set the certificate in idctx->creds[cred_index] as the selected certificate.\n */\nkrb5_error_code\ncrypto_cert_select(krb5_context context, pkinit_identity_crypto_context idctx,\n                   size_t cred_index)\n{\n    pkinit_cred_info ci = NULL;\n\n    if (cred_index >= MAX_CREDS_ALLOWED || idctx->creds[cred_index] == NULL)\n        return ENOENT;\n\n    ci = idctx->creds[cred_index];\n    /* copy the selected cert into our id_cryptoctx */\n    if (idctx->my_certs != NULL)\n        sk_X509_pop_free(idctx->my_certs, X509_free);\n    idctx->my_certs = sk_X509_new_null();\n    sk_X509_push(idctx->my_certs, ci->cert);\n    free(idctx->identity);\n    /* hang on to the selected credential name */\n    if (ci->name != NULL)\n        idctx->identity = strdup(ci->name);\n    else\n        idctx->identity = NULL;\n\n    ci->cert = NULL;       /* Don't free it twice */\n    idctx->cert_index = 0;\n    if (idctx->pkcs11_method != 1) {\n        idctx->my_key = ci->key;\n        ci->key = NULL;    /* Don't free it twice */\n    }\n#ifndef WITHOUT_PKCS11\n    else {\n        idctx->cert_id = ci->cert_id;\n        ci->cert_id = NULL; /* Don't free it twice */\n        idctx->cert_id_len = ci->cert_id_len;\n    }\n#endif\n    return 0;\n}\n\n/*\n * Choose the default certificate as \"the chosen one\"\n */\nkrb5_error_code\ncrypto_cert_select_default(krb5_context context,\n                           pkinit_plg_crypto_context plg_cryptoctx,\n                           pkinit_req_crypto_context req_cryptoctx,\n                           pkinit_identity_crypto_context id_cryptoctx)\n{\n    krb5_error_code retval;\n    int cert_count;\n\n    retval = crypto_cert_get_count(id_cryptoctx, &cert_count);\n    if (retval)\n        goto errout;\n\n    if (cert_count != 1) {\n        TRACE_PKINIT_NO_DEFAULT_CERT(context, cert_count);\n        retval = EINVAL;\n        goto errout;\n    }\n    /* copy the selected cert into our id_cryptoctx */\n    if (id_cryptoctx->my_certs != NULL) {\n        sk_X509_pop_free(id_cryptoctx->my_certs, X509_free);\n    }\n    id_cryptoctx->my_certs = sk_X509_new_null();\n    sk_X509_push(id_cryptoctx->my_certs, id_cryptoctx->creds[0]->cert);\n    id_cryptoctx->creds[0]->cert = NULL;        /* Don't free it twice */\n    id_cryptoctx->cert_index = 0;\n    /* hang on to the selected credential name */\n    if (id_cryptoctx->creds[0]->name != NULL)\n        id_cryptoctx->identity = strdup(id_cryptoctx->creds[0]->name);\n    else\n        id_cryptoctx->identity = NULL;\n\n    if (id_cryptoctx->pkcs11_method != 1) {\n        id_cryptoctx->my_key = id_cryptoctx->creds[0]->key;\n        id_cryptoctx->creds[0]->key = NULL;     /* Don't free it twice */\n    }\n#ifndef WITHOUT_PKCS11\n    else {\n        id_cryptoctx->cert_id = id_cryptoctx->creds[0]->cert_id;\n        id_cryptoctx->creds[0]->cert_id = NULL; /* Don't free it twice */\n        id_cryptoctx->cert_id_len = id_cryptoctx->creds[0]->cert_id_len;\n    }\n#endif\n    retval = 0;\nerrout:\n    return retval;\n}\n\n\n\nstatic krb5_error_code\nload_cas_and_crls(krb5_context context,\n                  pkinit_plg_crypto_context plg_cryptoctx,\n                  pkinit_req_crypto_context req_cryptoctx,\n                  pkinit_identity_crypto_context id_cryptoctx,\n                  int catype,\n                  char *filename)\n{\n    STACK_OF(X509_INFO) *sk = NULL;\n    STACK_OF(X509) *ca_certs = NULL;\n    STACK_OF(X509_CRL) *ca_crls = NULL;\n    BIO *in = NULL;\n    krb5_error_code retval = ENOMEM;\n    int i = 0;\n\n    /* If there isn't already a stack in the context,\n     * create a temporary one now */\n    switch(catype) {\n    case CATYPE_ANCHORS:\n        if (id_cryptoctx->trustedCAs != NULL)\n            ca_certs = id_cryptoctx->trustedCAs;\n        else {\n            ca_certs = sk_X509_new_null();\n            if (ca_certs == NULL)\n                return ENOMEM;\n        }\n        break;\n    case CATYPE_INTERMEDIATES:\n        if (id_cryptoctx->intermediateCAs != NULL)\n            ca_certs = id_cryptoctx->intermediateCAs;\n        else {\n            ca_certs = sk_X509_new_null();\n            if (ca_certs == NULL)\n                return ENOMEM;\n        }\n        break;\n    case CATYPE_CRLS:\n        if (id_cryptoctx->revoked != NULL)\n            ca_crls = id_cryptoctx->revoked;\n        else {\n            ca_crls = sk_X509_CRL_new_null();\n            if (ca_crls == NULL)\n                return ENOMEM;\n        }\n        break;\n    default:\n        return ENOTSUP;\n    }\n\n    if (!(in = BIO_new_file(filename, \"r\"))) {\n        retval = oerr(context, 0, _(\"Cannot open file '%s'\"), filename);\n        goto cleanup;\n    }\n\n    /* This loads from a file, a stack of x509/crl/pkey sets */\n    if ((sk = PEM_X509_INFO_read_bio(in, NULL, NULL, NULL)) == NULL) {\n        pkiDebug(\"%s: error reading file '%s'\\n\", __FUNCTION__, filename);\n        retval = oerr(context, 0, _(\"Cannot read file '%s'\"), filename);\n        goto cleanup;\n    }\n\n    /* scan over the stack created from loading the file contents,\n     * weed out duplicates, and push new ones onto the return stack\n     */\n    for (i = 0; i < sk_X509_INFO_num(sk); i++) {\n        X509_INFO *xi = sk_X509_INFO_value(sk, i);\n        if (xi != NULL && xi->x509 != NULL && catype != CATYPE_CRLS) {\n            int j = 0, size = sk_X509_num(ca_certs), flag = 0;\n\n            if (!size) {\n                sk_X509_push(ca_certs, xi->x509);\n                xi->x509 = NULL;\n                continue;\n            }\n            for (j = 0; j < size; j++) {\n                X509 *x = sk_X509_value(ca_certs, j);\n                flag = X509_cmp(x, xi->x509);\n                if (flag == 0)\n                    break;\n                else\n                    continue;\n            }\n            if (flag != 0) {\n                sk_X509_push(ca_certs, X509_dup(xi->x509));\n            }\n        } else if (xi != NULL && xi->crl != NULL && catype == CATYPE_CRLS) {\n            int j = 0, size = sk_X509_CRL_num(ca_crls), flag = 0;\n            if (!size) {\n                sk_X509_CRL_push(ca_crls, xi->crl);\n                xi->crl = NULL;\n                continue;\n            }\n            for (j = 0; j < size; j++) {\n                X509_CRL *x = sk_X509_CRL_value(ca_crls, j);\n                flag = X509_CRL_cmp(x, xi->crl);\n                if (flag == 0)\n                    break;\n                else\n                    continue;\n            }\n            if (flag != 0) {\n                sk_X509_CRL_push(ca_crls, X509_CRL_dup(xi->crl));\n            }\n        }\n    }\n\n    /* If we added something and there wasn't a stack in the\n     * context before, add the temporary stack to the context.\n     */\n    switch(catype) {\n    case CATYPE_ANCHORS:\n        if (sk_X509_num(ca_certs) == 0) {\n            TRACE_PKINIT_NO_CA_ANCHOR(context, filename);\n            if (id_cryptoctx->trustedCAs == NULL)\n                sk_X509_free(ca_certs);\n        } else {\n            if (id_cryptoctx->trustedCAs == NULL)\n                id_cryptoctx->trustedCAs = ca_certs;\n        }\n        break;\n    case CATYPE_INTERMEDIATES:\n        if (sk_X509_num(ca_certs) == 0) {\n            TRACE_PKINIT_NO_CA_INTERMEDIATE(context, filename);\n            if (id_cryptoctx->intermediateCAs == NULL)\n                sk_X509_free(ca_certs);\n        } else {\n            if (id_cryptoctx->intermediateCAs == NULL)\n                id_cryptoctx->intermediateCAs = ca_certs;\n        }\n        break;\n    case CATYPE_CRLS:\n        if (sk_X509_CRL_num(ca_crls) == 0) {\n            TRACE_PKINIT_NO_CRL(context, filename);\n            if (id_cryptoctx->revoked == NULL)\n                sk_X509_CRL_free(ca_crls);\n        } else {\n            if (id_cryptoctx->revoked == NULL)\n                id_cryptoctx->revoked = ca_crls;\n        }\n        break;\n    default:\n        /* Should have been caught above! */\n        retval = EINVAL;\n        goto cleanup;\n        break;\n    }\n\n    retval = 0;\n\ncleanup:\n    if (in != NULL)\n        BIO_free(in);\n    if (sk != NULL)\n        sk_X509_INFO_pop_free(sk, X509_INFO_free);\n\n    return retval;\n}\n\nstatic krb5_error_code\nload_cas_and_crls_dir(krb5_context context,\n                      pkinit_plg_crypto_context plg_cryptoctx,\n                      pkinit_req_crypto_context req_cryptoctx,\n                      pkinit_identity_crypto_context id_cryptoctx,\n                      int catype,\n                      char *dirname)\n{\n    krb5_error_code retval = EINVAL;\n    DIR *d = NULL;\n    struct dirent *dentry = NULL;\n    char filename[1024];\n\n    if (dirname == NULL)\n        return EINVAL;\n\n    d = opendir(dirname);\n    if (d == NULL)\n        return ENOENT;\n\n    while ((dentry = readdir(d))) {\n        if (strlen(dirname) + strlen(dentry->d_name) + 2 > sizeof(filename)) {\n            pkiDebug(\"%s: Path too long -- directory '%s' and file '%s'\\n\",\n                     __FUNCTION__, dirname, dentry->d_name);\n            goto cleanup;\n        }\n        /* Ignore subdirectories and anything starting with a dot */\n#ifdef DT_DIR\n        if (dentry->d_type == DT_DIR)\n            continue;\n#endif\n        if (dentry->d_name[0] == '.')\n            continue;\n        snprintf(filename, sizeof(filename), \"%s/%s\", dirname, dentry->d_name);\n\n        retval = load_cas_and_crls(context, plg_cryptoctx, req_cryptoctx,\n                                   id_cryptoctx, catype, filename);\n        if (retval)\n            goto cleanup;\n    }\n\n    retval = 0;\n\ncleanup:\n    if (d != NULL)\n        closedir(d);\n\n    return retval;\n}\n\nkrb5_error_code\ncrypto_load_cas_and_crls(krb5_context context,\n                         pkinit_plg_crypto_context plg_cryptoctx,\n                         pkinit_req_crypto_context req_cryptoctx,\n                         pkinit_identity_opts *idopts,\n                         pkinit_identity_crypto_context id_cryptoctx,\n                         int idtype,\n                         int catype,\n                         char *id)\n{\n    switch (idtype) {\n    case IDTYPE_FILE:\n        TRACE_PKINIT_LOAD_FROM_FILE(context);\n        return load_cas_and_crls(context, plg_cryptoctx, req_cryptoctx,\n                                 id_cryptoctx, catype, id);\n        break;\n    case IDTYPE_DIR:\n        TRACE_PKINIT_LOAD_FROM_DIR(context);\n        return load_cas_and_crls_dir(context, plg_cryptoctx, req_cryptoctx,\n                                     id_cryptoctx, catype, id);\n        break;\n    default:\n        return ENOTSUP;\n        break;\n    }\n}\n\nstatic krb5_error_code\ncreate_identifiers_from_stack(STACK_OF(X509) *sk,\n                              krb5_external_principal_identifier *** ids)\n{\n    int i = 0, sk_size = sk_X509_num(sk);\n    krb5_external_principal_identifier **krb5_cas = NULL;\n    X509 *x = NULL;\n    X509_NAME *xn = NULL;\n    unsigned char *p = NULL;\n    int len = 0;\n    PKCS7_ISSUER_AND_SERIAL *is = NULL;\n    char buf[DN_BUF_LEN];\n\n    *ids = NULL;\n\n    krb5_cas = calloc(sk_size + 1, sizeof(*krb5_cas));\n    if (krb5_cas == NULL)\n        return ENOMEM;\n\n    for (i = 0; i < sk_size; i++) {\n        krb5_cas[i] = malloc(sizeof(krb5_external_principal_identifier));\n\n        x = sk_X509_value(sk, i);\n\n        X509_NAME_oneline(X509_get_subject_name(x), buf, sizeof(buf));\n        pkiDebug(\"#%d cert= %s\\n\", i, buf);\n\n        /* fill-in subjectName */\n        krb5_cas[i]->subjectName.magic = 0;\n        krb5_cas[i]->subjectName.length = 0;\n        krb5_cas[i]->subjectName.data = NULL;\n\n        xn = X509_get_subject_name(x);\n        len = i2d_X509_NAME(xn, NULL);\n        if ((p = malloc((size_t) len)) == NULL)\n            goto oom;\n        krb5_cas[i]->subjectName.data = (char *)p;\n        i2d_X509_NAME(xn, &p);\n        krb5_cas[i]->subjectName.length = len;\n\n        /* fill-in issuerAndSerialNumber */\n        krb5_cas[i]->issuerAndSerialNumber.length = 0;\n        krb5_cas[i]->issuerAndSerialNumber.magic = 0;\n        krb5_cas[i]->issuerAndSerialNumber.data = NULL;\n\n        is = PKCS7_ISSUER_AND_SERIAL_new();\n        if (is == NULL)\n            goto oom;\n        X509_NAME_set(&is->issuer, X509_get_issuer_name(x));\n        ASN1_INTEGER_free(is->serial);\n        is->serial = ASN1_INTEGER_dup(X509_get_serialNumber(x));\n        if (is->serial == NULL)\n            goto oom;\n        len = i2d_PKCS7_ISSUER_AND_SERIAL(is, NULL);\n        p = malloc(len);\n        if (p == NULL)\n            goto oom;\n        krb5_cas[i]->issuerAndSerialNumber.data = (char *)p;\n        i2d_PKCS7_ISSUER_AND_SERIAL(is, &p);\n        krb5_cas[i]->issuerAndSerialNumber.length = len;\n\n        /* fill-in subjectKeyIdentifier */\n        krb5_cas[i]->subjectKeyIdentifier.length = 0;\n        krb5_cas[i]->subjectKeyIdentifier.magic = 0;\n        krb5_cas[i]->subjectKeyIdentifier.data = NULL;\n\n        if (X509_get_ext_by_NID(x, NID_subject_key_identifier, -1) >= 0) {\n            ASN1_OCTET_STRING *ikeyid;\n\n            ikeyid = X509_get_ext_d2i(x, NID_subject_key_identifier, NULL,\n                                      NULL);\n            if (ikeyid != NULL) {\n                len = i2d_ASN1_OCTET_STRING(ikeyid, NULL);\n                p = malloc(len);\n                if (p == NULL)\n                    goto oom;\n                krb5_cas[i]->subjectKeyIdentifier.data = (char *)p;\n                i2d_ASN1_OCTET_STRING(ikeyid, &p);\n                krb5_cas[i]->subjectKeyIdentifier.length = len;\n                ASN1_OCTET_STRING_free(ikeyid);\n            }\n        }\n        PKCS7_ISSUER_AND_SERIAL_free(is);\n        is = NULL;\n    }\n\n    *ids = krb5_cas;\n    return 0;\n\noom:\n    free_krb5_external_principal_identifier(&krb5_cas);\n    PKCS7_ISSUER_AND_SERIAL_free(is);\n    return ENOMEM;\n}\n\nstatic krb5_error_code\ncreate_krb5_invalidCertificates(krb5_context context,\n                                pkinit_plg_crypto_context plg_cryptoctx,\n                                pkinit_req_crypto_context req_cryptoctx,\n                                pkinit_identity_crypto_context id_cryptoctx,\n                                krb5_external_principal_identifier *** ids)\n{\n\n    krb5_error_code retval = ENOMEM;\n    STACK_OF(X509) *sk = NULL;\n\n    *ids = NULL;\n    if (req_cryptoctx->received_cert == NULL)\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n\n    sk = sk_X509_new_null();\n    if (sk == NULL)\n        goto cleanup;\n    sk_X509_push(sk, req_cryptoctx->received_cert);\n\n    retval = create_identifiers_from_stack(sk, ids);\n\n    sk_X509_free(sk);\ncleanup:\n\n    return retval;\n}\n\nkrb5_error_code\ncreate_krb5_supportedCMSTypes(krb5_context context,\n                              pkinit_plg_crypto_context plg_cryptoctx,\n                              pkinit_req_crypto_context req_cryptoctx,\n                              pkinit_identity_crypto_context id_cryptoctx,\n                              krb5_algorithm_identifier ***oids)\n{\n\n    krb5_error_code retval = ENOMEM;\n    krb5_algorithm_identifier **loids = NULL;\n    krb5_data des3oid = {0, 8, \"\\x2A\\x86\\x48\\x86\\xF7\\x0D\\x03\\x07\" };\n\n    *oids = NULL;\n    loids = malloc(2 * sizeof(krb5_algorithm_identifier *));\n    if (loids == NULL)\n        goto cleanup;\n    loids[1] = NULL;\n    loids[0] = malloc(sizeof(krb5_algorithm_identifier));\n    if (loids[0] == NULL) {\n        free(loids);\n        goto cleanup;\n    }\n    retval = pkinit_copy_krb5_data(&loids[0]->algorithm, &des3oid);\n    if (retval) {\n        free(loids[0]);\n        free(loids);\n        goto cleanup;\n    }\n    loids[0]->parameters.length = 0;\n    loids[0]->parameters.data = NULL;\n\n    *oids = loids;\n    retval = 0;\ncleanup:\n\n    return retval;\n}\n\nkrb5_error_code\ncreate_krb5_trustedCertifiers(krb5_context context,\n                              pkinit_plg_crypto_context plg_cryptoctx,\n                              pkinit_req_crypto_context req_cryptoctx,\n                              pkinit_identity_crypto_context id_cryptoctx,\n                              krb5_external_principal_identifier *** ids)\n{\n\n    krb5_error_code retval = ENOMEM;\n    STACK_OF(X509) *sk = id_cryptoctx->trustedCAs;\n\n    *ids = NULL;\n    if (id_cryptoctx->trustedCAs == NULL)\n        return KRB5KDC_ERR_PREAUTH_FAILED;\n\n    retval = create_identifiers_from_stack(sk, ids);\n\n    return retval;\n}\n\nkrb5_error_code\ncreate_issuerAndSerial(krb5_context context,\n                       pkinit_plg_crypto_context plg_cryptoctx,\n                       pkinit_req_crypto_context req_cryptoctx,\n                       pkinit_identity_crypto_context id_cryptoctx,\n                       unsigned char **out,\n                       unsigned int *out_len)\n{\n    unsigned char *p = NULL;\n    PKCS7_ISSUER_AND_SERIAL *is = NULL;\n    int len = 0;\n    krb5_error_code retval = ENOMEM;\n    X509 *cert = req_cryptoctx->received_cert;\n\n    *out = NULL;\n    *out_len = 0;\n    if (req_cryptoctx->received_cert == NULL)\n        return 0;\n\n    is = PKCS7_ISSUER_AND_SERIAL_new();\n    X509_NAME_set(&is->issuer, X509_get_issuer_name(cert));\n    ASN1_INTEGER_free(is->serial);\n    is->serial = ASN1_INTEGER_dup(X509_get_serialNumber(cert));\n    len = i2d_PKCS7_ISSUER_AND_SERIAL(is, NULL);\n    if ((p = *out = malloc((size_t) len)) == NULL)\n        goto cleanup;\n    i2d_PKCS7_ISSUER_AND_SERIAL(is, &p);\n    *out_len = len;\n    retval = 0;\n\ncleanup:\n    X509_NAME_free(is->issuer);\n    ASN1_INTEGER_free(is->serial);\n    free(is);\n\n    return retval;\n}\n\nkrb5_error_code\npkinit_process_td_trusted_certifiers(\n    krb5_context context,\n    pkinit_plg_crypto_context plg_cryptoctx,\n    pkinit_req_crypto_context req_cryptoctx,\n    pkinit_identity_crypto_context id_cryptoctx,\n    krb5_external_principal_identifier **krb5_trusted_certifiers,\n    int td_type)\n{\n    krb5_error_code retval = ENOMEM;\n    STACK_OF(X509_NAME) *sk_xn = NULL;\n    X509_NAME *xn = NULL;\n    PKCS7_ISSUER_AND_SERIAL *is = NULL;\n    ASN1_OCTET_STRING *id = NULL;\n    const unsigned char *p = NULL;\n    char buf[DN_BUF_LEN];\n    int i = 0;\n\n    if (td_type == TD_TRUSTED_CERTIFIERS)\n        pkiDebug(\"received trusted certifiers\\n\");\n    else\n        pkiDebug(\"received invalid certificate\\n\");\n\n    sk_xn = sk_X509_NAME_new_null();\n    while(krb5_trusted_certifiers[i] != NULL) {\n        if (krb5_trusted_certifiers[i]->subjectName.data != NULL) {\n            p = (unsigned char *)krb5_trusted_certifiers[i]->subjectName.data;\n            xn = d2i_X509_NAME(NULL, &p,\n                               (int)krb5_trusted_certifiers[i]->subjectName.length);\n            if (xn == NULL)\n                goto cleanup;\n            X509_NAME_oneline(xn, buf, sizeof(buf));\n            if (td_type == TD_TRUSTED_CERTIFIERS)\n                pkiDebug(\"#%d cert = %s is trusted by kdc\\n\", i, buf);\n            else\n                pkiDebug(\"#%d cert = %s is invalid\\n\", i, buf);\n            sk_X509_NAME_push(sk_xn, xn);\n        }\n\n        if (krb5_trusted_certifiers[i]->issuerAndSerialNumber.data != NULL) {\n            p = (unsigned char *)\n                krb5_trusted_certifiers[i]->issuerAndSerialNumber.data;\n            is = d2i_PKCS7_ISSUER_AND_SERIAL(NULL, &p,\n                                             (int)krb5_trusted_certifiers[i]->issuerAndSerialNumber.length);\n            if (is == NULL)\n                goto cleanup;\n            X509_NAME_oneline(is->issuer, buf, sizeof(buf));\n            if (td_type == TD_TRUSTED_CERTIFIERS)\n                pkiDebug(\"#%d issuer = %s serial = %ld is trusted bu kdc\\n\", i,\n                         buf, ASN1_INTEGER_get(is->serial));\n            else\n                pkiDebug(\"#%d issuer = %s serial = %ld is invalid\\n\", i, buf,\n                         ASN1_INTEGER_get(is->serial));\n            PKCS7_ISSUER_AND_SERIAL_free(is);\n        }\n\n        if (krb5_trusted_certifiers[i]->subjectKeyIdentifier.data != NULL) {\n            p = (unsigned char *)\n                krb5_trusted_certifiers[i]->subjectKeyIdentifier.data;\n            id = d2i_ASN1_OCTET_STRING(NULL, &p,\n                                       (int)krb5_trusted_certifiers[i]->subjectKeyIdentifier.length);\n            if (id == NULL)\n                goto cleanup;\n            /* XXX */\n            ASN1_OCTET_STRING_free(id);\n        }\n        i++;\n    }\n    /* XXX Since we not doing anything with received trusted certifiers\n     * return an error. this is the place where we can pick a different\n     * client certificate based on the information in td_trusted_certifiers\n     */\n    retval = KRB5KDC_ERR_PREAUTH_FAILED;\ncleanup:\n    if (sk_xn != NULL)\n        sk_X509_NAME_pop_free(sk_xn, X509_NAME_free);\n\n    return retval;\n}\n\n/* Originally based on OpenSSL's PKCS7_dataDecode(), now modified to remove the\n * use of BIO objects and to fit the PKINIT internal interfaces. */\nstatic int\npkcs7_decrypt(krb5_context context,\n              pkinit_identity_crypto_context id_cryptoctx, PKCS7 *p7,\n              unsigned char **data_out, unsigned int *len_out)\n{\n    krb5_error_code ret;\n    int ok = 0, plaintext_len = 0, final_len;\n    unsigned int keylen = 0, eklen = 0, blocksize;\n    unsigned char *ek = NULL, *tkey = NULL, *plaintext = NULL, *use_key;\n    ASN1_OCTET_STRING *data_body = p7->d.enveloped->enc_data->enc_data;\n    const EVP_CIPHER *evp_cipher;\n    EVP_CIPHER_CTX *evp_ctx = NULL;\n    X509_ALGOR *enc_alg = p7->d.enveloped->enc_data->algorithm;\n    STACK_OF(PKCS7_RECIP_INFO) *rsk = p7->d.enveloped->recipientinfo;\n    PKCS7_RECIP_INFO *ri = NULL;\n\n    *data_out = NULL;\n    *len_out = 0;\n\n    p7->state = PKCS7_S_HEADER;\n\n    /* RFC 4556 section 3.2.3.2 requires that there be exactly one\n     * recipientInfo. */\n    if (sk_PKCS7_RECIP_INFO_num(rsk) != 1) {\n        pkiDebug(\"invalid number of EnvelopedData RecipientInfos\\n\");\n        return 0;\n    }\n    ri = sk_PKCS7_RECIP_INFO_value(rsk, 0);\n\n    evp_cipher = EVP_get_cipherbyobj(enc_alg->algorithm);\n    if (evp_cipher == NULL)\n        goto cleanup;\n    keylen = EVP_CIPHER_key_length(evp_cipher);\n    blocksize = EVP_CIPHER_block_size(evp_cipher);\n\n    evp_ctx = EVP_CIPHER_CTX_new();\n    if (evp_ctx == NULL)\n        goto cleanup;\n    if (!EVP_DecryptInit(evp_ctx, evp_cipher, NULL, NULL) ||\n        EVP_CIPHER_asn1_to_param(evp_ctx, enc_alg->parameter) <= 0)\n        goto cleanup;\n\n    /* Generate a random symmetric key to avoid exposing timing data if RSA\n     * decryption fails the padding check. */\n    tkey = malloc(keylen);\n    if (tkey == NULL || !EVP_CIPHER_CTX_rand_key(evp_ctx, tkey))\n        goto cleanup;\n\n    /* Decrypt the secret key with the private key. */\n    ret = pkinit_decode_data(context, id_cryptoctx,\n                             ASN1_STRING_get0_data(ri->enc_key),\n                             ASN1_STRING_length(ri->enc_key), &ek, &eklen);\n    use_key = (ret || eklen != keylen) ? tkey : ek;\n\n    /* Allocate a plaintext buffer and decrypt data_body into it. */\n    plaintext = malloc(data_body->length + blocksize);\n    if (plaintext == NULL)\n        goto cleanup;\n    if (!EVP_DecryptInit(evp_ctx, NULL, use_key, NULL))\n        goto cleanup;\n    if (!EVP_DecryptUpdate(evp_ctx, plaintext, &plaintext_len,\n                           data_body->data, data_body->length))\n        goto cleanup;\n    if (!EVP_DecryptFinal(evp_ctx, plaintext + plaintext_len, &final_len))\n        goto cleanup;\n    plaintext_len += final_len;\n\n    *len_out = plaintext_len;\n    *data_out = plaintext;\n    plaintext = NULL;\n    ok = 1;\n\ncleanup:\n    EVP_CIPHER_CTX_free(evp_ctx);\n    zapfree(plaintext, plaintext_len);\n    zapfree(ek, eklen);\n    zapfree(tkey, keylen);\n    return ok;\n}\n\n#ifdef DEBUG_DH\nstatic void\nprint_dh(DH * dh, char *msg)\n{\n    BIO *bio_err = NULL;\n\n    bio_err = BIO_new(BIO_s_file());\n    BIO_set_fp(bio_err, stderr, BIO_NOCLOSE | BIO_FP_TEXT);\n\n    if (msg)\n        BIO_puts(bio_err, (const char *)msg);\n    if (dh)\n        DHparams_print(bio_err, dh);\n\n    BIO_puts(bio_err, \"private key: \");\n    BN_print(bio_err, dh->priv_key);\n    BIO_puts(bio_err, (const char *)\"\\n\");\n    BIO_free(bio_err);\n\n}\n\nstatic void\nprint_pubkey(BIGNUM * key, char *msg)\n{\n    BIO *bio_err = NULL;\n\n    bio_err = BIO_new(BIO_s_file());\n    BIO_set_fp(bio_err, stderr, BIO_NOCLOSE | BIO_FP_TEXT);\n\n    if (msg)\n        BIO_puts(bio_err, (const char *)msg);\n    if (key)\n        BN_print(bio_err, key);\n    BIO_puts(bio_err, \"\\n\");\n\n    BIO_free(bio_err);\n\n}\n#endif\n\nstatic char *\npkinit_pkcs11_code_to_text(int err)\n{\n    int i;\n    static char uc[32];\n\n    for (i = 0; pkcs11_errstrings[i].text != NULL; i++)\n        if (pkcs11_errstrings[i].code == err)\n            break;\n    if (pkcs11_errstrings[i].text != NULL)\n        return (pkcs11_errstrings[i].text);\n    snprintf(uc, sizeof(uc), _(\"unknown code 0x%x\"), err);\n    return (uc);\n}\n\n/*\n * Add an item to the pkinit_identity_crypto_context's list of deferred\n * identities.\n */\nkrb5_error_code\ncrypto_set_deferred_id(krb5_context context,\n                       pkinit_identity_crypto_context id_cryptoctx,\n                       const char *identity, const char *password)\n{\n    unsigned long ck_flags;\n\n    ck_flags = pkinit_get_deferred_id_flags(id_cryptoctx->deferred_ids,\n                                            identity);\n    return pkinit_set_deferred_id(&id_cryptoctx->deferred_ids,\n                                  identity, ck_flags, password);\n}\n\n/*\n * Retrieve a read-only copy of the pkinit_identity_crypto_context's list of\n * deferred identities, sure to be valid only until the next time someone calls\n * either pkinit_set_deferred_id() or crypto_set_deferred_id().\n */\nconst pkinit_deferred_id *\ncrypto_get_deferred_ids(krb5_context context,\n                        pkinit_identity_crypto_context id_cryptoctx)\n{\n    pkinit_deferred_id *deferred;\n    const pkinit_deferred_id *ret;\n\n    deferred = id_cryptoctx->deferred_ids;\n    ret = (const pkinit_deferred_id *)deferred;\n    return ret;\n}\n\n/* Return the received certificate as DER-encoded data. */\nkrb5_error_code\ncrypto_encode_der_cert(krb5_context context, pkinit_req_crypto_context reqctx,\n                       uint8_t **der_out, size_t *der_len)\n{\n    int len;\n    unsigned char *der, *p;\n\n    *der_out = NULL;\n    *der_len = 0;\n\n    if (reqctx->received_cert == NULL)\n        return EINVAL;\n    p = NULL;\n    len = i2d_X509(reqctx->received_cert, NULL);\n    if (len <= 0)\n        return EINVAL;\n    p = der = malloc(len);\n    if (der == NULL)\n        return ENOMEM;\n    if (i2d_X509(reqctx->received_cert, &p) <= 0) {\n        free(der);\n        return EINVAL;\n    }\n    *der_out = der;\n    *der_len = len;\n    return 0;\n}\n\n/*\n * Get the certificate matching data from the request certificate.\n */\nkrb5_error_code\ncrypto_req_cert_matching_data(krb5_context context,\n                              pkinit_plg_crypto_context plgctx,\n                              pkinit_req_crypto_context reqctx,\n                              pkinit_cert_matching_data **md_out)\n{\n    *md_out = NULL;\n\n    if (reqctx == NULL || reqctx->received_cert == NULL)\n        return ENOENT;\n\n    return get_matching_data(context, plgctx, reqctx, reqctx->received_cert,\n                             md_out);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/util/exitsleep.c": "/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* util/exitsleep.c */\n/*\n * Copyright (C) 2003 by the Massachusetts Institute of Technology.\n * All rights reserved.\n *\n * Export of this software from the United States of America may\n *   require a specific license from the United States Government.\n *   It is the responsibility of any person or organization contemplating\n *   export to obtain such a license before exporting.\n *\n * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and\n * distribute this software and its documentation for any purpose and\n * without fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright notice and\n * this permission notice appear in supporting documentation, and that\n * the name of M.I.T. not be used in advertising or publicity pertaining\n * to distribution of the software without specific, written prior\n * permission.  Furthermore if you modify this software you must label\n * your software as modified software and not distribute it in such a\n * fashion that it might be confused with the original M.I.T. software.\n * M.I.T. makes no representations about the suitability of\n * this software for any purpose.  It is provided \"as is\" without express\n * or implied warranty.\n */\n\n/*\n * Kludge to sleep 100ms prior to exit on Solaris 9 to work around a\n * pty bug.\n */\n\n#include <sys/types.h>\n#include <sys/time.h>\n#include <unistd.h>\n#include <dlfcn.h>\n#include <link.h>\n\nvoid\nexit(int status)\n{\n    void (*realexit)(int);\n    struct timeval tv;\n\n    tv.tv_sec = 0;\n    tv.tv_usec = 100000;\n    realexit = (void (*)(int))dlsym(RTLD_NEXT, \"exit\");\n    select(0, 0, 0, 0, &tv);\n    realexit(status);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/util/support/plugins.c": "/* -*- mode: c; c-basic-offset: 4; indent-tabs-mode: nil -*- */\n/* util/support/plugins.c - Plugin module support functions */\n/*\n * Copyright 2006, 2008 by the Massachusetts Institute of Technology.\n * All Rights Reserved.\n *\n * Export of this software from the United States of America may\n *   require a specific license from the United States Government.\n *   It is the responsibility of any person or organization contemplating\n *   export to obtain such a license before exporting.\n *\n * WITHIN THAT CONSTRAINT, permission to use, copy, modify, and\n * distribute this software and its documentation for any purpose and\n * without fee is hereby granted, provided that the above copyright\n * notice appear in all copies and that both that copyright notice and\n * this permission notice appear in supporting documentation, and that\n * the name of M.I.T. not be used in advertising or publicity pertaining\n * to distribution of the software without specific, written prior\n * permission.  Furthermore if you modify this software you must label\n * your software as modified software and not distribute it in such a\n * fashion that it might be confused with the original M.I.T. software.\n * M.I.T. makes no representations about the suitability of\n * this software for any purpose.  It is provided \"as is\" without express\n * or implied warranty.\n */\n\n#include \"k5-platform.h\"\n#include \"k5-plugin.h\"\n#if USE_DLOPEN\n#include <dlfcn.h>\n#endif\n#include <sys/types.h>\n#ifdef HAVE_SYS_STAT_H\n#include <sys/stat.h>\n#endif\n#ifdef HAVE_SYS_PARAM_H\n#include <sys/param.h>\n#endif\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\n#if USE_DLOPEN\n#ifdef RTLD_GROUP\n#define GROUP RTLD_GROUP\n#else\n#define GROUP 0\n#endif\n#ifdef RTLD_NODELETE\n#define NODELETE RTLD_NODELETE\n#else\n#define NODELETE 0\n#endif\n#define PLUGIN_DLOPEN_FLAGS (RTLD_NOW | RTLD_LOCAL | GROUP | NODELETE)\n#endif\n\n/*\n * glibc bug 11941, fixed in release 2.25, can cause an assertion failure in\n * dlclose() on process exit.  Our workaround is to leak dlopen() handles\n * (which doesn't typically manifest in leak detection tools because the\n * handles are still reachable via a global table in libdl).  Because we\n * dlopen() with RTLD_NODELETE, we weren't going to unload the plugin objects\n * anyway.\n */\n#ifdef __GLIBC_PREREQ\n#if ! __GLIBC_PREREQ(2, 25)\n#define dlclose(x)\n#endif\n#endif\n\n#if USE_DLOPEN && USE_CFBUNDLE\n#include <CoreFoundation/CoreFoundation.h>\n\n/* Currently CoreFoundation only exists on the Mac so we just use\n * pthreads directly to avoid creating empty function calls on other\n * platforms.  If a thread initializer ever gets created in the common\n * plugin code, move this there */\nstatic pthread_mutex_t krb5int_bundle_mutex = PTHREAD_MUTEX_INITIALIZER;\n#endif\n\n#include <stdarg.h>\nstatic void Tprintf (const char *fmt, ...)\n{\n#ifdef DEBUG\n    va_list va;\n    va_start (va, fmt);\n    vfprintf (stderr, fmt, va);\n    va_end (va);\n#endif\n}\n\nstruct plugin_file_handle {\n#if USE_DLOPEN\n    void *dlhandle;\n#endif\n#ifdef _WIN32\n    HMODULE hinstPlugin;\n#endif\n#if !defined (USE_DLOPEN) && !defined (_WIN32)\n    char dummy;\n#endif\n};\n\n#ifdef _WIN32\nstruct dirent {\n    long d_ino;                 /* inode (always 1 in WIN32) */\n    off_t d_off;                /* offset to this dirent */\n    unsigned short d_reclen;    /* length of d_name */\n    char d_name[_MAX_FNAME+1];  /* filename (null terminated) */\n};\n\ntypedef struct {\n    intptr_t handle;            /* _findfirst/_findnext handle */\n    short offset;               /* offset into directory */\n    short finished;             /* 1 if there are not more files */\n    struct _finddata_t fileinfo;/* from _findfirst/_findnext */\n    char *dir;                  /* the dir we are reading */\n    struct dirent dent;         /* the dirent to return */\n} DIR;\n\nDIR * opendir(const char *dir)\n{\n    DIR *dp;\n    char *filespec;\n    intptr_t handle;\n    int index;\n\n    filespec = malloc(strlen(dir) + 2 + 1);\n    strcpy(filespec, dir);\n    index = strlen(filespec) - 1;\n    if (index >= 0 && (filespec[index] == '/' || filespec[index] == '\\\\'))\n        filespec[index] = '\\0';\n    strcat(filespec, \"/*\");\n\n    dp = (DIR *)malloc(sizeof(DIR));\n    dp->offset = 0;\n    dp->finished = 0;\n    dp->dir = strdup(dir);\n\n    if ((handle = _findfirst(filespec, &(dp->fileinfo))) < 0) {\n        if (errno == ENOENT)\n            dp->finished = 1;\n        else {\n            free(filespec);\n            free(dp->dir);\n            free(dp);\n            return NULL;\n        }\n    }\n\n    dp->handle = handle;\n    free(filespec);\n\n    return dp;\n}\n\nstruct dirent * readdir(DIR *dp)\n{\n    if (!dp || dp->finished) return NULL;\n\n    if (dp->offset != 0) {\n        if (_findnext(dp->handle, &(dp->fileinfo)) < 0) {\n            dp->finished = 1;\n            return NULL;\n        }\n    }\n    dp->offset++;\n\n    strncpy(dp->dent.d_name, dp->fileinfo.name, _MAX_FNAME);\n    dp->dent.d_ino = 1;\n    dp->dent.d_reclen = (unsigned short)strlen(dp->dent.d_name);\n    dp->dent.d_off = dp->offset;\n\n    return &(dp->dent);\n}\n\nint closedir(DIR *dp)\n{\n    if (!dp) return 0;\n    _findclose(dp->handle);\n    free(dp->dir);\n    free(dp);\n\n    return 0;\n}\n#endif\n\nlong KRB5_CALLCONV\nkrb5int_open_plugin (const char *filepath, struct plugin_file_handle **h, struct errinfo *ep)\n{\n    long err = 0;\n    struct stat statbuf;\n    struct plugin_file_handle *htmp = NULL;\n    int got_plugin = 0;\n\n    if (!err) {\n        if (stat (filepath, &statbuf) < 0) {\n            err = errno;\n            Tprintf (\"stat(%s): %s\\n\", filepath, strerror (err));\n            k5_set_error(ep, err, _(\"unable to find plugin [%s]: %s\"),\n                         filepath, strerror(err));\n        }\n    }\n\n    if (!err) {\n        htmp = calloc (1, sizeof (*htmp)); /* calloc initializes ptrs to NULL */\n        if (htmp == NULL) { err = ENOMEM; }\n    }\n\n#if USE_DLOPEN\n    if (!err && ((statbuf.st_mode & S_IFMT) == S_IFREG\n#if USE_CFBUNDLE\n                 || (statbuf.st_mode & S_IFMT) == S_IFDIR\n#endif /* USE_CFBUNDLE */\n        )) {\n        void *handle = NULL;\n\n#if USE_CFBUNDLE\n        char executablepath[MAXPATHLEN];\n\n        if ((statbuf.st_mode & S_IFMT) == S_IFDIR) {\n            int lock_err = 0;\n            CFStringRef pluginString = NULL;\n            CFURLRef pluginURL = NULL;\n            CFBundleRef pluginBundle = NULL;\n            CFURLRef executableURL = NULL;\n\n            /* Lock around CoreFoundation calls since objects are refcounted\n             * and the refcounts are not thread-safe.  Using pthreads directly\n             * because this code is Mac-specific */\n            lock_err = pthread_mutex_lock(&krb5int_bundle_mutex);\n            if (lock_err) { err = lock_err; }\n\n            if (!err) {\n                pluginString = CFStringCreateWithCString (kCFAllocatorDefault,\n                                                          filepath,\n                                                          kCFStringEncodingASCII);\n                if (pluginString == NULL) { err = ENOMEM; }\n            }\n\n            if (!err) {\n                pluginURL = CFURLCreateWithFileSystemPath (kCFAllocatorDefault,\n                                                           pluginString,\n                                                           kCFURLPOSIXPathStyle,\n                                                           true);\n                if (pluginURL == NULL) { err = ENOMEM; }\n            }\n\n            if (!err) {\n                pluginBundle = CFBundleCreate (kCFAllocatorDefault, pluginURL);\n                if (pluginBundle == NULL) { err = ENOENT; } /* XXX need better error */\n            }\n\n            if (!err) {\n                executableURL = CFBundleCopyExecutableURL (pluginBundle);\n                if (executableURL == NULL) { err = ENOMEM; }\n            }\n\n            if (!err) {\n                if (!CFURLGetFileSystemRepresentation (executableURL,\n                                                       true, /* absolute */\n                                                       (UInt8 *)executablepath,\n                                                       sizeof (executablepath))) {\n                    err = ENOMEM;\n                }\n            }\n\n            if (!err) {\n                /* override the path the caller passed in */\n                filepath = executablepath;\n            }\n\n            if (executableURL    != NULL) { CFRelease (executableURL); }\n            if (pluginBundle     != NULL) { CFRelease (pluginBundle); }\n            if (pluginURL        != NULL) { CFRelease (pluginURL); }\n            if (pluginString     != NULL) { CFRelease (pluginString); }\n\n            /* unlock after CFRelease calls since they modify refcounts */\n            if (!lock_err) { pthread_mutex_unlock (&krb5int_bundle_mutex); }\n        }\n#endif /* USE_CFBUNDLE */\n\n        if (!err) {\n            handle = dlopen(filepath, PLUGIN_DLOPEN_FLAGS);\n            if (handle == NULL) {\n                const char *e = dlerror();\n                if (e == NULL)\n                    e = _(\"unknown failure\");\n                Tprintf (\"dlopen(%s): %s\\n\", filepath, e);\n                err = ENOENT; /* XXX */\n                k5_set_error(ep, err, _(\"unable to load plugin [%s]: %s\"),\n                             filepath, e);\n            }\n        }\n\n        if (!err) {\n            got_plugin = 1;\n            htmp->dlhandle = handle;\n            handle = NULL;\n        }\n\n        if (handle != NULL) { dlclose (handle); }\n    }\n#endif /* USE_DLOPEN */\n\n#ifdef _WIN32\n    if (!err && (statbuf.st_mode & S_IFMT) == S_IFREG) {\n        HMODULE handle = NULL;\n\n        handle = LoadLibrary(filepath);\n        if (handle == NULL) {\n            Tprintf (\"Unable to load dll: %s\\n\", filepath);\n            err = ENOENT; /* XXX */\n            k5_set_error(ep, err, _(\"unable to load DLL [%s]\"), filepath);\n        }\n\n        if (!err) {\n            got_plugin = 1;\n            htmp->hinstPlugin = handle;\n            handle = NULL;\n        }\n\n        if (handle != NULL)\n            FreeLibrary(handle);\n    }\n#endif\n\n    if (!err && !got_plugin) {\n        err = ENOENT;  /* no plugin or no way to load plugins */\n        k5_set_error(ep, err, _(\"plugin unavailable: %s\"), strerror(err));\n    }\n\n    if (!err) {\n        *h = htmp;\n        htmp = NULL;  /* h takes ownership */\n    }\n\n    free(htmp);\n\n    return err;\n}\n\nstatic long\nkrb5int_get_plugin_sym (struct plugin_file_handle *h,\n                        const char *csymname, int isfunc, void **ptr,\n                        struct errinfo *ep)\n{\n    long err = 0;\n    void *sym = NULL;\n\n#if USE_DLOPEN\n    if (!err && !sym && (h->dlhandle != NULL)) {\n        /* XXX Do we need to add a leading \"_\" to the symbol name on any\n           modern platforms?  */\n        sym = dlsym (h->dlhandle, csymname);\n        if (sym == NULL) {\n            const char *e = dlerror (); /* XXX copy and save away */\n            if (e == NULL)\n                e = \"unknown failure\";\n            Tprintf (\"dlsym(%s): %s\\n\", csymname, e);\n            err = ENOENT; /* XXX */\n            k5_set_error(ep, err, \"%s\", e);\n        }\n    }\n#endif\n\n#ifdef _WIN32\n    LPVOID lpMsgBuf;\n    DWORD dw;\n\n    if (!err && !sym && (h->hinstPlugin != NULL)) {\n        sym = GetProcAddress(h->hinstPlugin, csymname);\n        if (sym == NULL) {\n            const char *e = \"unable to get dll symbol\"; /* XXX copy and save away */\n            Tprintf (\"GetProcAddress(%s): %i\\n\", csymname, GetLastError());\n            err = ENOENT; /* XXX */\n            k5_set_error(ep, err, \"%s\", e);\n\n            dw = GetLastError();\n            if (FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER |\n                              FORMAT_MESSAGE_FROM_SYSTEM,\n                              NULL,\n                              dw,\n                              MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),\n                              (LPTSTR) &lpMsgBuf,\n                              0, NULL )) {\n\n                fprintf (stderr, \"unable to get dll symbol, %s\\n\", (LPCTSTR)lpMsgBuf);\n                LocalFree(lpMsgBuf);\n            }\n        }\n    }\n#endif\n\n    if (!err && (sym == NULL)) {\n        err = ENOENT;  /* unimplemented */\n    }\n\n    if (!err) {\n        *ptr = sym;\n    }\n\n    return err;\n}\n\nlong KRB5_CALLCONV\nkrb5int_get_plugin_data (struct plugin_file_handle *h, const char *csymname,\n                         void **ptr, struct errinfo *ep)\n{\n    return krb5int_get_plugin_sym (h, csymname, 0, ptr, ep);\n}\n\nlong KRB5_CALLCONV\nkrb5int_get_plugin_func (struct plugin_file_handle *h, const char *csymname,\n                         void (**ptr)(), struct errinfo *ep)\n{\n    void *dptr = NULL;\n    long err = krb5int_get_plugin_sym (h, csymname, 1, &dptr, ep);\n    if (!err) {\n        /* Cast function pointers to avoid code duplication */\n        *ptr = (void (*)()) dptr;\n    }\n    return err;\n}\n\nvoid KRB5_CALLCONV\nkrb5int_close_plugin (struct plugin_file_handle *h)\n{\n#if USE_DLOPEN\n    if (h->dlhandle != NULL) { dlclose(h->dlhandle); }\n#endif\n#ifdef _WIN32\n    if (h->hinstPlugin != NULL) { FreeLibrary(h->hinstPlugin); }\n#endif\n    free (h);\n}\n\n/* autoconf docs suggest using this preference order */\n#if HAVE_DIRENT_H || USE_DIRENT_H\n#include <dirent.h>\n#define NAMELEN(D) strlen((D)->d_name)\n#else\n#ifndef _WIN32\n#define dirent direct\n#define NAMELEN(D) ((D)->d->namlen)\n#else\n#define NAMELEN(D) strlen((D)->d_name)\n#endif\n#if HAVE_SYS_NDIR_H\n# include <sys/ndir.h>\n#elif HAVE_SYS_DIR_H\n# include <sys/dir.h>\n#elif HAVE_NDIR_H\n# include <ndir.h>\n#endif\n#endif\n\nstatic long\nkrb5int_plugin_file_handle_array_init (struct plugin_file_handle ***harray)\n{\n    long err = 0;\n\n    *harray = calloc (1, sizeof (**harray)); /* calloc initializes to NULL */\n    if (*harray == NULL) { err = ENOMEM; }\n\n    return err;\n}\n\nstatic long\nkrb5int_plugin_file_handle_array_add (struct plugin_file_handle ***harray, size_t *count,\n                                      struct plugin_file_handle *p)\n{\n    long err = 0;\n    struct plugin_file_handle **newharray = NULL;\n    size_t newcount = *count + 1;\n\n    newharray = realloc (*harray, ((newcount + 1) * sizeof (**harray))); /* +1 for NULL */\n    if (newharray == NULL) {\n        err = ENOMEM;\n    } else {\n        newharray[newcount - 1] = p;\n        newharray[newcount] = NULL;\n        *count = newcount;\n        *harray = newharray;\n    }\n\n    return err;\n}\n\nstatic void\nkrb5int_plugin_file_handle_array_free (struct plugin_file_handle **harray)\n{\n    if (harray != NULL) {\n        int i;\n        for (i = 0; harray[i] != NULL; i++) {\n            krb5int_close_plugin (harray[i]);\n        }\n        free (harray);\n    }\n}\n\n#if TARGET_OS_MAC\n#define FILEEXTS { \"\", \".bundle\", \".dylib\", \".so\", NULL }\n#elif defined(_WIN32)\n#define FILEEXTS  { \"\", \".dll\", NULL }\n#else\n#define FILEEXTS  { \"\", \".so\", NULL }\n#endif\n\n\nstatic void\nkrb5int_free_plugin_filenames (char **filenames)\n{\n    if (filenames != NULL) {\n        int i;\n        for (i = 0; filenames[i] != NULL; i++) {\n            free (filenames[i]);\n        }\n        free (filenames);\n    }\n}\n\n\nstatic long\nkrb5int_get_plugin_filenames (const char * const *filebases, char ***filenames)\n{\n    long err = 0;\n    static const char *const fileexts[] = FILEEXTS;\n    char **tempnames = NULL;\n    size_t bases_count = 0;\n    size_t exts_count = 0;\n    size_t i;\n\n    if (!filebases) { err = EINVAL; }\n    if (!filenames) { err = EINVAL; }\n\n    if (!err) {\n        for (i = 0; filebases[i]; i++) { bases_count++; }\n        for (i = 0; fileexts[i]; i++) { exts_count++; }\n        tempnames = calloc ((bases_count * exts_count)+1, sizeof (char *));\n        if (!tempnames) { err = ENOMEM; }\n    }\n\n    if (!err) {\n        size_t j;\n        for (i = 0; !err && filebases[i]; i++) {\n            for (j = 0; !err && fileexts[j]; j++) {\n                if (asprintf(&tempnames[(i*exts_count)+j], \"%s%s\",\n                             filebases[i], fileexts[j]) < 0) {\n                    tempnames[(i*exts_count)+j] = NULL;\n                    err = ENOMEM;\n                }\n            }\n        }\n        tempnames[bases_count * exts_count] = NULL; /* NUL-terminate */\n    }\n\n    if (!err) {\n        *filenames = tempnames;\n        tempnames = NULL;\n    }\n\n    krb5int_free_plugin_filenames(tempnames);\n\n    return err;\n}\n\n\n/* Takes a NULL-terminated list of directories.  If filebases is NULL, filebases is ignored\n * all plugins in the directories are loaded.  If filebases is a NULL-terminated array of names,\n * only plugins in the directories with those name (plus any platform extension) are loaded. */\n\nlong KRB5_CALLCONV\nkrb5int_open_plugin_dirs (const char * const *dirnames,\n                          const char * const *filebases,\n                          struct plugin_dir_handle *dirhandle,\n                          struct errinfo *ep)\n{\n    long err = 0;\n    struct plugin_file_handle **h = NULL;\n    size_t count = 0;\n    char **filenames = NULL;\n    int i;\n\n    if (!err) {\n        err = krb5int_plugin_file_handle_array_init (&h);\n    }\n\n    if (!err && (filebases != NULL)) {\n        err = krb5int_get_plugin_filenames (filebases, &filenames);\n    }\n\n    for (i = 0; !err && dirnames[i] != NULL; i++) {\n        if (filenames != NULL) {\n            /* load plugins with names from filenames from each directory */\n            int j;\n\n            for (j = 0; !err && filenames[j] != NULL; j++) {\n                struct plugin_file_handle *handle = NULL;\n                char *filepath = NULL;\n\n                if (!err) {\n                    if (asprintf(&filepath, \"%s/%s\", dirnames[i], filenames[j]) < 0) {\n                        filepath = NULL;\n                        err = ENOMEM;\n                    }\n                }\n\n                if (!err && krb5int_open_plugin(filepath, &handle, ep) == 0) {\n                    err = krb5int_plugin_file_handle_array_add (&h, &count, handle);\n                    if (!err)\n                        handle = NULL; /* h takes ownership */\n                }\n\n                free(filepath);\n                if (handle   != NULL) { krb5int_close_plugin (handle); }\n            }\n        } else {\n            /* load all plugins in each directory */\n            DIR *dir = opendir (dirnames[i]);\n\n            while (dir != NULL && !err) {\n                struct dirent *d = NULL;\n                char *filepath = NULL;\n                struct plugin_file_handle *handle = NULL;\n\n                d = readdir (dir);\n                if (d == NULL) { break; }\n\n                if ((strcmp (d->d_name, \".\") == 0) ||\n                    (strcmp (d->d_name, \"..\") == 0)) {\n                    continue;\n                }\n\n                if (!err) {\n                    int len = NAMELEN (d);\n                    if (asprintf(&filepath, \"%s/%*s\", dirnames[i], len, d->d_name) < 0) {\n                        filepath = NULL;\n                        err = ENOMEM;\n                    }\n                }\n\n                if (!err) {\n                    if (krb5int_open_plugin (filepath, &handle, ep) == 0) {\n                        err = krb5int_plugin_file_handle_array_add (&h, &count, handle);\n                        if (!err) { handle = NULL; }  /* h takes ownership */\n                    }\n                }\n\n                free(filepath);\n                if (handle    != NULL) { krb5int_close_plugin (handle); }\n            }\n\n            if (dir != NULL) { closedir (dir); }\n        }\n    }\n\n    if (err == ENOENT) {\n        err = 0;  /* ran out of plugins -- do nothing */\n    }\n\n    if (!err) {\n        dirhandle->files = h;\n        h = NULL;  /* dirhandle->files takes ownership */\n    }\n\n    if (filenames != NULL) { krb5int_free_plugin_filenames (filenames); }\n    if (h         != NULL) { krb5int_plugin_file_handle_array_free (h); }\n\n    return err;\n}\n\nvoid KRB5_CALLCONV\nkrb5int_close_plugin_dirs (struct plugin_dir_handle *dirhandle)\n{\n    if (dirhandle->files != NULL) {\n        int i;\n        for (i = 0; dirhandle->files[i] != NULL; i++) {\n            krb5int_close_plugin (dirhandle->files[i]);\n        }\n        free (dirhandle->files);\n        dirhandle->files = NULL;\n    }\n}\n\nvoid KRB5_CALLCONV\nkrb5int_free_plugin_dir_data (void **ptrs)\n{\n    /* Nothing special to be done per pointer.  */\n    free(ptrs);\n}\n\nlong KRB5_CALLCONV\nkrb5int_get_plugin_dir_data (struct plugin_dir_handle *dirhandle,\n                             const char *symname,\n                             void ***ptrs,\n                             struct errinfo *ep)\n{\n    long err = 0;\n    void **p = NULL;\n    size_t count = 0;\n\n    /* XXX Do we need to add a leading \"_\" to the symbol name on any\n       modern platforms?  */\n\n    Tprintf(\"get_plugin_data_sym(%s)\\n\", symname);\n\n    if (!err) {\n        p = calloc (1, sizeof (*p)); /* calloc initializes to NULL */\n        if (p == NULL) { err = ENOMEM; }\n    }\n\n    if (!err && (dirhandle != NULL) && (dirhandle->files != NULL)) {\n        int i = 0;\n\n        for (i = 0; !err && (dirhandle->files[i] != NULL); i++) {\n            void *sym = NULL;\n\n            if (krb5int_get_plugin_data (dirhandle->files[i], symname, &sym, ep) == 0) {\n                void **newp = NULL;\n\n                count++;\n                newp = realloc (p, ((count + 1) * sizeof (*p))); /* +1 for NULL */\n                if (newp == NULL) {\n                    err = ENOMEM;\n                } else {\n                    p = newp;\n                    p[count - 1] = sym;\n                    p[count] = NULL;\n                }\n            }\n        }\n    }\n\n    if (!err) {\n        *ptrs = p;\n        p = NULL; /* ptrs takes ownership */\n    }\n\n    free(p);\n\n    return err;\n}\n\nvoid KRB5_CALLCONV\nkrb5int_free_plugin_dir_func (void (**ptrs)(void))\n{\n    /* Nothing special to be done per pointer.  */\n    free(ptrs);\n}\n\nlong KRB5_CALLCONV\nkrb5int_get_plugin_dir_func (struct plugin_dir_handle *dirhandle,\n                             const char *symname,\n                             void (***ptrs)(void),\n                             struct errinfo *ep)\n{\n    long err = 0;\n    void (**p)() = NULL;\n    size_t count = 0;\n\n    /* XXX Do we need to add a leading \"_\" to the symbol name on any\n       modern platforms?  */\n\n    Tprintf(\"get_plugin_data_sym(%s)\\n\", symname);\n\n    if (!err) {\n        p = calloc (1, sizeof (*p)); /* calloc initializes to NULL */\n        if (p == NULL) { err = ENOMEM; }\n    }\n\n    if (!err && (dirhandle != NULL) && (dirhandle->files != NULL)) {\n        int i = 0;\n\n        for (i = 0; !err && (dirhandle->files[i] != NULL); i++) {\n            void (*sym)() = NULL;\n\n            if (krb5int_get_plugin_func (dirhandle->files[i], symname, &sym, ep) == 0) {\n                void (**newp)() = NULL;\n\n                count++;\n                newp = realloc (p, ((count + 1) * sizeof (*p))); /* +1 for NULL */\n                if (newp == NULL) {\n                    err = ENOMEM;\n                } else {\n                    p = newp;\n                    p[count - 1] = sym;\n                    p[count] = NULL;\n                }\n            }\n        }\n    }\n\n    if (!err) {\n        *ptrs = p;\n        p = NULL; /* ptrs takes ownership */\n    }\n\n    free(p);\n\n    return err;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/doc/thread-safe.txt": "[May be out of date.  Last significant update: Jan 2005.]\n\nIn general, it's assumed that the library initialization function (if\ninitialization isn't delayed) and the library finalization function\nare run in some thread-safe fashion, with no other parts of the\nlibrary in question in use.  (If dlopen or dlsym in one thread starts\nrunning the initializer, and then dlopen/dlsym in another thread\nreturns and lets you start accessing functions or data in the library\nbefore the initializer is finished, that really seems like a\ndlopen/dlsym bug.)\n\nIt's also assumed that if library A depends on library B, then library\nB's initializer runs first, and its finalizer last, whether loading\ndynamically at run time or at process startup/exit.  (It appears that\nAIX 4.3.3 may violate this, at least when we use gcc's\nconstructor/destructor attributes in shared libraries.)\n\nSupport for freeing the heap storage allocated by a library has NOT,\nin general, been written.  There are hooks, but often they ignore some\nof the library's local storage, mutexes, etc.\n\nIf shared library finalization code doesn't get run at all at dlclose\ntime, or if we can't use it because the execution order is wrong, then\nyou'll get memory leaks.  Deal with it.\n\nSeveral debugging variables that are not part of our official API are\nnot protected by mutexes.  In general, the only way to set them is by\nchanging the sources and recompiling, which obviously has no run-time\nthread safety issues, or by stopping the process under a debugger,\nwhich we blithely assert is \"safe enough\".\n\nDebug code that we don't normally enable may be less thread safe than\nmight be desired.  For example, multiple printf calls may be made,\nwith the assumption that the output will not be intermixed with output\nfrom some other thread.  Offhand, I'm not aware of any cases where\ndebugging code is \"really\" unsafe, as in likely to crash the program\nor produce insecure results.\n\nVarious libraries may call assert() and abort().  This should only be\nfor \"can't happen\" cases, and indicate programming errors.  In some\ncases, the compiler may be able to infer that the \"can't happen\" cases\nreally can't happen, and drop the calls, but in many cases, this is\nnot possible.\n\nThere are cases (e.g., in the com_err library) where errors arising\nwhen dealing with other errors are handled by calling abort, for lack\nof anything better.  We should probably clean those up someday.\n\nVarious libraries call getenv().  This is perfectly safe, as long as\nnothing is calling setenv or putenv or what have you, while multiple\nthreads are executing.  Of course, that severely curtails the ability\nto control our libraries through that \"interface\".\n\nVarious libraries call the ctype functions/macros (isupper, etc).  It\nis assumed that the program does not call setlocale, or does so only\nwhile the program is still single-threaded or while calls into the\nKerberos libraries are not in progress.\n\nThe Windows thread safety support is unfinished.\n\nI'm assuming that structure fields that are never written to (e.g.,\nafter a structure has been initialized and *then* made possibly\nvisible to multiple threads) are safe to read from one thread while\nanother field is being updated by another thread.  If that's not the\ncase, some more work is needed (and I'd like details on why it's not\nsafe).\n\n----------------\n\nlibcom_err\n\nIssues:\n\nThe callback hook support (set_com_err_hook, reset_com_err_hook, and\ncalls to com_err and com_err_va) uses a mutex to protect the handle on\nthe hook function.  As a side effect of this, if a callback function\nis registered which pops up a window and waits for the users'\nacknowledgement, then other errors cannot be reported by other threads\nuntil after the acknowledgement.  This could be fixed with\nmultiple-reader-one-writer type locks, but that's a bit more\ncomplicated.\n\nThe string returned by error_message may be per-thread storage.  It\ncan be passed off between threads, but it shouldn't be in use by any\nthread by the time the originating thread calls error_message again.\n\nError tables must no longer be in use (including pointers returned by\nerror_message) when the library containing them is unloaded.\n\nTemporary: A flag variable has been created in error_message.c which\nis used to try to catch cases where remove_error_table is called after\nthe library finalization function.  This generally indicates\nout-of-order execution of the library finalization functions.  The\nhandling of this flag is not thread-safe, but if the finalization\nfunction is called, other threads should in theory be finished with\nthis library anyways.\n\nStatics: error_message.c, com_err.c, covered above.\n\n----------------\n\nlibprofile (and its use in libkrb5)\n\nDoes no checks to see if it's opened multiple instances of the same\nfile under different names.  Does not guard against trying to open a\nfile while another thread or process is in the process of replacing\nit, or two threads trying to update a file at the same time.  The\nformer should be pretty safe on UNIX with atomic rename, but on\nWindows there's a race condition; there's a window (so to speak) where\nthe filename does not correspond to an actual file.\n\nStatics: prof_file.c, a list of opened config files and their parse\ntrees, and a mutex to protect it.\n\n----------------\n\nlibk5crypto\n\nUses of the Yarrow code from the krb5 crypto interface are protected\nby a single mutex.  Initialization of the Yarrow state will be done\nonce, the first time these routines are called.  Calls directly to the\nYarrow functions are not protected.\n\nUses ctype macros; what happens if the locale is changed in a\nmulti-threaded program?\n\nDebug var in pbkdf2.c.\n\nStatics: pbkdf2.c: debug variable.\n\nStatics: prng.c: Global Yarrow data and mutex.\n\nStatics: crypto_libinit.c: library initializer aux data.\n\n----------------\n\nlibkrb5\n\n(TBD)\n\nUses: ctype macros\n\nUses: getaddrinfo, getnameinfo.  According to current specifications,\ngetaddrinfo should be thread-safe; some implementations are not, and\nwe're not attempting to figure out which ones.  NetBSD 1.6, for\nexample, had an unsafe implementation.\n\nUses: res_ninit, res_nsearch.  If these aren't available, the non-'n'\nversions will be used, and they are sometimes not thread-safe.\n\nUses: mkstemp, mktemp -- Are these, or our uses of them, likely to be\nthread-safe?\n\nUses: sigaction\n\nThe use of sigaction is in the code prompting for a password; we try\nto catch the keyboard interrupt character being used and turn it into\nan error return from that function.  THIS IS NOT THREAD-SAFE.\n\nUses: tcgetattr, tcsetattr.  This is also in the password-prompting\ncode.  These are fine as long as no other threads are accessing the\nsame terminal at the same time.\n\nUses: fopen.  This is thread-safe, actually, but a multi-threaded\nserver is likely to be using lots of file descriptors.  On 32-bit\nSolaris platforms, fopen will not work if the next available file\ndescriptor number is 256 or higher.  This can cause the keytab code to\nfail.\n\nStatics: prompter.c: interrupt flag\n\nStatics: ccdefops.c: default operations table pointer\n\nStatics: ktdefname.c: variable to override default keytab name, NO\nLOCKING.  DON'T TOUCH THESE VARIABLES, at least in threaded programs.\n\nStatics: conv_creds.c: debug variable\n\nStatics: sendto_kdc.c: debug variable, in export list for KDC\n\nStatics: parse.c: default realm cache, changed to not cache\n\nStatics: krb5_libinit.c: lib init aux data\n\nStatics: osconfig.c: various internal variables, probably should be const\n\nStatics: init_ctx.c: \"brand\" string; not written.\n\nStatics: cc_memory.c: list of caches, with mutex.\n\nStatics: c_ustime.c: last timestamp, to implement \"microseconds must\nalways increment\"\n\nStatics: ktbase.c, ccbase.c, rc_base.c: type registries and mutexes.\n\n----------------\n\nlibgssapi_krb5\n\n(TBD)\n\nUses: ctype macros\n\nStatics: acquire_cred.c: name of keytab to use, and mutex.\n\nStatics: gssapi_krb5.c:\n\nStatics: init_sec_context.c:\n\nStatics: set_ccache.c:\n\nStatics: gssapi_generic.c: OID definitions, non-const by\nspecification.  We probably could make them const anyways.\n\nThe keytab name saved away by krb5_gss_register_acceptor_identity is\nglobal and protected by a mutex; the ccache name stored by\ngss_krb5_ccache_name is per-thread.  This inconsistency is due to the\nanticipated usage patterns.\n\nThe old ccache name returned by gss_krb5_ccache_name if the last\nparameter is not a null pointer is also stored per-thread, and will be\ndiscarded at the next call to that routine from the same thread, or at\nthread termination.\n\nNeeds work: check various objects for thread safety\n\n----------------\n\nlibgssrpc\n\nNew version is in place.  Ignore it for now?\n\n----------------\n\nlibkadm5*\nlibkdb5\n\nSkip these for now.  We may want the KDC libraries to be thread-safe\neventually, so the KDC can take better advantage of hyperthreaded or\nmultiprocessor systems.\n\n----------------\n\nlibapputils\nlibss\n\nUsed by single-threaded programs only (but see above re KDC).  Don't\nbother for now.\n",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/doc/threads.txt": "Thread safety in the MIT Kerberos libraries\n\nThe return value from krb5_cc_default_name is a handle on internal\nstorage from the krb5_context.  It is valid only until\nkrb5_cc_set_default_name or krb5_free_context is called.  If\nkrb5_cc_set_default_name may be called, the calling code must ensure\nthat the storage returned by krb5_cc_default_name is no longer in use\nby that time.\n\nAny use of krb5_context must be confined to one thread at a time by\nthe application code.\n\nUses of credentials caches, replay caches, and keytabs may happen in\nmultiple threads simultaneously as long as none of them destroys the\nobject while other threads may still be using it.  (Any internal data\nmodification in those objects will be protected by mutexes or other\nmeans, within the krb5 library.)\n\nThe simple, exposed data structures in krb5.h like krb5_principal are\nnot protected; they should not be used in one thread while another\nthread might be modifying them.  (TO DO: Build a list of which calls\nkeep references to supplied data or return references to\notherwise-referenced data, as opposed to everything making copies.)\n\n\n\n[ This part is a little outdated already. ]\n\n   // Between these two, we should be able to do pure compile-time\n   // and pure run-time initialization.\n   //   POSIX: partial initializer is PTHREAD_MUTEX_INITIALIZER,\n   //          finish does nothing\n   //   Windows: partial initializer is zero/empty,\n   //            finish does the actual work and runs at load time\n   //   debug: partial initializer sets one magic value,\n   //          finish verifies, sets a new magic value\n   k5_mutex_t foo_mutex = K5_MUTEX_PARTIAL_INITIALIZER;\n   int k5_mutex_finish_init(k5_mutex_t *);\n   // for dynamic allocation\n   int k5_mutex_init(k5_mutex_t *);\n   // Must work for both kinds of allocation, even if it means adding\n   // a flag.\n   int k5_mutex_destroy(k5_mutex_t *);\n   //\n   // Per library, one function to finish the static mutex\n   // initialization.\n   //\n   // A second function called at various possible \"first\" entry\n   // points which either calls pthread_once on the first function\n   // (POSIX), or checks some flag set by the first function (Windows,\n   // debug support), and possibly returns an error.\n   //\n   // A third function for library termination calls mutex_destroy on\n   // each mutex for the library.\n   //\n   // \n   int k5_mutex_lock(k5_mutex_t *);\n   int k5_mutex_unlock(k5_mutex_t *);\n   // Optional (always defined, but need not do anything):\n   void k5_mutex_assert_locked(k5_mutex_t *);\n   void k5_mutex_assert_unlocked(k5_mutex_t *);\n\n\n   k5_key_t key;\n   int k5_key_create(k5_key_t *, void (*destructor)(void *));\n   void *k5_getspecific(k5_key_t);\n   int k5_setspecific(k5_key_t, const void *);\n   ... stuff to signal library termination ...\n\nThis is **NOT** an exported interface, and is subject to change.\n\nOn many platforms with weak reference support, we can declare certain\nsymbols to be weak, and test the addresses before calling them.  The\nreferences generally will be non-null if the application pulls in the\npthread support.  Sometimes stubs are present in the C library for\nsome of these routines, and sometimes they're not functional; if so,\nwe need to figure out which ones, and check for the presence of some\n*other* routines.\n\nAIX 4.3.3 doesn't support weak references.  However, it looks like\ncalling dlsym(NULL) causes the pthread library to get loaded, so we're\ngoing to just go ahead and link against it anyways.\n\nOn Tru64 we also link against the thread library always.\n\n\nFor now, the basic model is:\n\n  If weak references are supported, use them.\n  Else, assume support is present; if that means explicitly pulling in\n  the thread library, so be it.\n\n\n\nThe locking described above may not be sufficient, at least for good\nperformance.  At some point we may want to switch to read/write locks,\nso multiple threads can grovel over a data structure at once as long\nas they don't change it.\n\n\nSee also notes in src/include/k5-thread.h.\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/lib/crypto/crypto_tests/test/katmct.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/lib/krb5/ccache/kcmrpc.defs",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/tests/dejagnu/pkinit-certs/user.p12",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/tests/dejagnu/pkinit-certs/user-upn.p12",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/tests/dejagnu/pkinit-certs/generic.p12",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/tests/dejagnu/pkinit-certs/user-upn3.p12",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/tests/dejagnu/pkinit-certs/user-enc.p12",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/tests/dejagnu/pkinit-certs/user-upn2.p12",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leashdll/res/leash.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leashdll/res/islogo.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/htmlhelp/html/Forget_Principals.htm",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/htmlhelp/html/FAQ.htm",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/htmlhelp/html/Home_Tab.htm",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/htmlhelp/html/Renew_Tickets.htm",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/htmlhelp/html/View_Tickets.htm",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/htmlhelp/html/Kerberos_Terminology.htm",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/htmlhelp/html/Keyboard_Shortcuts.htm",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/htmlhelp/html/Using_Leash_Menus.htm",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/htmlhelp/html/Tickets.htm",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/htmlhelp/html/KINIT.htm",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/htmlhelp/html/Troubleshooting.htm",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/htmlhelp/html/Getting_Started.htm",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/htmlhelp/html/Destroy_Tickets.htm",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/htmlhelp/html/Encryption_Types.htm",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/htmlhelp/html/Options_Tab.htm",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/htmlhelp/html/Kerberos.htm",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/htmlhelp/html/Ticket_Settings.htm",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/htmlhelp/Images/Get_Ticket.PNG",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/htmlhelp/Images/Change_Password.PNG",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/htmlhelp/Images/Home_Tab.PNG",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/htmlhelp/Images/Options_Tab.PNG",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/htmlhelp/Images/Destroy_Ticket.PNG",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/htmlhelp/Images/checkbox.png",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/htmlhelp/Images/Make_Default.PNG",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/htmlhelp/Images/Renew_Ticket.PNG",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/res/getticketlarge.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/res/renew_disabled.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/res/makedefaultlarge.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/res/openlarge.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/res/renew.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/res/new.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/res/Leash2.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/res/Leash_tkt_green.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/res/newlarge.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/res/key.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/res/destroy.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/res/import.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/res/Leash_tickets_orange.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/res/importlarge.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/res/Leash_tickets_out.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/res/refresh.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/res/renewlarge.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/res/Leash_tickets_red.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/res/Leash_user_red.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/res/address.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/res/status_greenK.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/res/Leash_Doc.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/res/password.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/res/Leash_toolbar.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/res/Leash_user_green.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/res/status_yelloK.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/res/Leash_tickets_green.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/res/import_disabled.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/res/status_redK.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/res/import.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/res/exportlarge.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/res/Leash_user_out.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/res/Leash_tkt_red.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/res/Leash.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/res/Leash_user_orange.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/res/refresh_disabled.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/res/destroy_disabled.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/res/password_disabled.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/res/sync.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/res/sync_disabled.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/res/cursor1.cur",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/res/encryption.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/res/Leash_tkt_orange.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/res/destroylarge.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/res/new_disabled.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/res/status_grayK.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/leash/res/cpwlarge.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/installer/wix/Binary/exclamic.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/installer/wix/Binary/removico.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/installer/wix/Binary/new.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/installer/wix/Binary/completi.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/installer/wix/Binary/info.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/installer/wix/Binary/bannrbmp.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/installer/wix/Binary/up.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/installer/wix/Binary/custicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/installer/wix/Binary/repairic.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/installer/wix/Binary/insticon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/src/windows/installer/wix/Binary/dlgbmp.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/doc/pdf/user.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/doc/pdf/plugindev.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/doc/pdf/basic.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/doc/pdf/admin.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/doc/pdf/build.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/doc/pdf/appdev.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/doc/html/objects.inv",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/doc/html/_static/comment-close.png",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/doc/html/_static/down.png",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/doc/html/_static/down-pressed.png",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/doc/html/_static/plus.png",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/doc/html/_static/comment-bright.png",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/doc/html/_static/comment.png",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/doc/html/_static/up-pressed.png",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/doc/html/_static/bgfooter.png",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/doc/html/_static/bgtop.png",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/doc/html/_static/file.png",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/doc/html/_static/ajax-loader.gif",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/doc/html/_static/up.png",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/doc/html/_static/minus.png",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/doc/tools/__pycache__/docmodel.cpython-36.pyc",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/doc/tools/__pycache__/doxybuilder_funcs.cpython-36.pyc",
        "/tmp/vanessa/spack-stage/spack-stage-krb5-1.18.2-oqhwnplcs3r33wlcyzxolcjckfbb6dsj/spack-src/doc/tools/__pycache__/doxybuilder_types.cpython-36.pyc"
    ],
    "total_files": 4310
}