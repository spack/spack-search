{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-libical-3.0.8-zhcncr4jo22ylh5du5qzmeftftf3u3iq/spack-src/src/libicalss/icalset.c": "/*======================================================================\n FILE: icalset.c\n CREATOR: eric 17 Jul 2000\n\n (C) COPYRIGHT 2000, Eric Busboom <eric@civicknowledge.com>\n\n Icalset is the \"base class\" for representations of a collection of\n iCal components. Derived classes (actually delegates) include:\n\n    icalfileset   Store components in a single file\n    icaldirset    Store components in multiple files in a directory\n    icalheapset   Store components on the heap\n    icalmysqlset  Store components in a mysql database.\n\n This library is free software; you can redistribute it and/or modify\n it under the terms of either:\n\n    The LGPL as published by the Free Software Foundation, version\n    2.1, available at: https://www.gnu.org/licenses/lgpl-2.1.html\n\n Or:\n\n    The Mozilla Public License Version 2.0. You may obtain a copy of\n    the License at https://www.mozilla.org/MPL/\n\n The Original Code is eric. The Initial Developer of the Original\n Code is Eric Busboom\n======================================================================*/\n\n#ifdef HAVE_CONFIG_H\n#include <config.h>\n#endif\n\n#include \"icalset.h\"\n#include \"icaldirset.h\"\n#include \"icaldirsetimpl.h\"\n#include \"icalfileset.h\"\n#include \"icalfilesetimpl.h\"\n\n#if defined(HAVE_BDB)\n#include \"icalbdbset.h\"\n#include \"icalbdbsetimpl.h\"\n#endif\n\n#include <errno.h>\n#include <stdlib.h>\n\n/* #define _DLOPEN_TEST */\n#if defined(_DLOPEN_TEST)\n#include <sys/types.h>\n#include <dlfcn.h>\n#include <dirent.h>\n#endif\n\nstatic icalset icalset_dirset_init = {\n    ICAL_DIR_SET,\n    sizeof(icaldirset),\n    NULL,\n    icaldirset_init,\n    icaldirset_free,\n    icaldirset_path,\n    icaldirset_mark,\n    icaldirset_commit,\n    icaldirset_add_component,\n    icaldirset_remove_component,\n    icaldirset_count_components,\n    icaldirset_select,\n    icaldirset_clear,\n    icaldirset_fetch,\n    icaldirset_fetch_match,\n    icaldirset_has_uid,\n    icaldirset_modify,\n    icaldirset_get_current_component,\n    icaldirset_get_first_component,\n    icaldirset_get_next_component,\n    icaldirset_begin_component,\n    icaldirsetiter_to_next,\n    icaldirsetiter_to_prior\n};\n\nstatic icalset icalset_fileset_init = {\n    ICAL_FILE_SET,\n    sizeof(icalfileset),\n    NULL,\n    icalfileset_init,\n    icalfileset_free,\n    icalfileset_path,\n    icalfileset_mark,\n    icalfileset_commit,\n    icalfileset_add_component,\n    icalfileset_remove_component,\n    icalfileset_count_components,\n    icalfileset_select,\n    icalfileset_clear,\n    icalfileset_fetch,\n    icalfileset_fetch_match,\n    icalfileset_has_uid,\n    icalfileset_modify,\n    icalfileset_get_current_component,\n    icalfileset_get_first_component,\n    icalfileset_get_next_component,\n    icalfileset_begin_component,\n    icalfilesetiter_to_next,\n    NULL\n};\n\n#if defined(HAVE_BDB)\nstatic icalset icalset_bdbset_init = {\n    ICAL_BDB_SET,\n    sizeof(icalbdbset),\n    NULL,\n    icalbdbset_init,\n    icalbdbset_free,\n    icalbdbset_path,\n    icalbdbset_mark,\n    icalbdbset_commit,\n    icalbdbset_add_component,\n    icalbdbset_remove_component,\n    icalbdbset_count_components,\n    icalbdbset_select,\n    icalbdbset_clear,\n    icalbdbset_fetch,\n    icalbdbset_fetch_match,\n    icalbdbset_has_uid,\n    icalbdbset_modify,\n    icalbdbset_get_current_component,\n    icalbdbset_get_first_component,\n    icalbdbset_get_next_component,\n    icalbdbset_begin_component,\n    icalbdbsetiter_to_next,\n    NULL\n};\n#endif\n\n#if defined(_DLOPEN_TEST)\nstatic int icalset_init_done = 0;\nstatic pvl_list icalset_kinds = 0;\n\ntypedef icalset *(*fptr) (void);\n\n/**\n * Try to load the file and register any icalset found within.\n */\nstatic int load(const char *file)\n{\n    void *modh;\n    fptr inith;\n    char *dlerr;\n    icalset *icalset_init_ptr;\n\n    if ((modh = dlopen(file, RTLD_NOW)) == 0) {\n        perror(\"dlopen\");\n        return 0;\n    }\n\n    (void)dlerror(); /* clear */\n    inith = (fptr)dlsym(modh, \"InitModule\");\n    dlerr = dlerror();\n    if (dlerr != NULL) {\n        fprintf(stderr, \"dlsym error: %s\\n\", dlerr);\n        dlclose(modh);\n        return 0;\n    }\n\n    while ((icalset_init_ptr = ((inith) ())) != 0) {\n        pvl_push(icalset_kinds, &icalset_init_ptr);\n    }\n\n    (void)dlerror(); /* clear */\n    dlclose(modh);\n    return 1;\n}\n\n/**\n * Look in the given directory for files called mod_*.o and try to\n * load them.\n */\nint icalset_loaddir(const char *path)\n{\n    DIR *d;\n    struct dirent *dp;\n    char buf[PATH_MAX], *bufptr;\n    int tot = 0;\n\n    strcpy(buf, path);\n    bufptr = buf + strlen(buf);\n\n    if (*(bufptr - 1) != '/') {\n        *bufptr++ = '/';\n    }\n\n    if ((d = opendir(path)) == 0) {\n        perror(\"opendir\");\n        return 0;\n    }\n\n    while ((dp = readdir(d)) != 0) {\n        if (strncmp(dp->d_name, \"mod_\", 4)) {\n            continue;\n        }\n\n        strcpy(bufptr, dp->d_name);\n\n        load(buf);\n        tot++;\n    }\n    (void)closedir(d);\n\n    return 1;\n}\n\nint icalset_register_class(icalset *set);\n\nstatic void icalset_init(void)\n{\n    assert(icalset_kinds == 0);\n    icalset_kinds = pvl_newlist();\n\n    pvl_push(icalset_kinds, &icalset_fileset_init);\n    pvl_push(icalset_kinds, &icalset_dirset_init);\n#if defined(HAVE_BDB)\n    pvl_push(icalset_kinds, &icalset_bdb4set_init);\n#endif\n\n    icalset_init_done++;\n}\n\nint icalset_register_class(icalset *set)\n{\n    if (!icalset_init_done) {\n        icalset_init();\n    }\n\n    pvl_push(icalset_kinds, set);\n    return 1;\n}\n\n#endif\n\nicalset *icalset_new(icalset_kind kind, const char *dsn, void *options)\n{\n    icalset *data = NULL;\n    icalset *ret = NULL;\n\n#if defined(_DLOPEN_TEST)\n    pvl_elem e;\n    icalset *impl;\n\n    if (!icalset_init_done) {\n        icalset_init();\n    }\n\n    for (e = pvl_head(icalset_kinds); e != 0; e = pvl_next(e)) {\n        impl = (icalset *)pvl_data(e);\n        if (impl->kind == kind) {\n            break;\n        }\n    }\n    if (e == 0) {\n        icalerror_set_errno(ICAL_UNIMPLEMENTED_ERROR);\n        return (NULL);\n    }\n\n    data = (icalset *)malloc(impl->size);\n    if (data == (icalset *)NULL) {\n        icalerror_set_errno(ICAL_NEWFAILED_ERROR);\n        errno = ENOMEM;\n        return 0;\n    }\n\n    /* The first member of the derived class must be an icalset. */\n    memset(data, 0, impl->size);\n    /* *data = *impl; */\n    memcpy(data, impl, sizeof(icalset));\n\n    data->dsn = strdup(dsn);\n#else\n    switch (kind) {\n    case ICAL_FILE_SET: {\n        icalfileset *fdata;\n        fdata = (icalfileset *)malloc(sizeof(icalfileset));\n        data = (icalset *)fdata;\n        if (data == 0) {\n            icalerror_set_errno(ICAL_NEWFAILED_ERROR);\n            errno = ENOMEM;\n            return 0;\n        }\n        memset(data, 0, sizeof(icalfileset));\n        *data = icalset_fileset_init;\n        break;\n    }\n    case ICAL_DIR_SET: {\n        icaldirset *ddata;\n        ddata = (icaldirset *)malloc(sizeof(icaldirset));\n        data = (icalset *)ddata;\n        if (data == 0) {\n            icalerror_set_errno(ICAL_NEWFAILED_ERROR);\n            errno = ENOMEM;\n            return 0;\n        }\n        memset(data, 0, sizeof(icaldirset));\n        *data = icalset_dirset_init;\n        break;\n    }\n#if defined(HAVE_BDB)\n    case ICAL_BDB_SET: {\n        icalbdbset *bdata;\n        bdata = (icalbdbset *)malloc(sizeof(icalbdbset));\n        data = (icalset *)bdata;\n        if (data == 0) {\n            icalerror_set_errno(ICAL_NEWFAILED_ERROR);\n            errno = ENOMEM;\n            return 0;\n        }\n        memset(data, 0, sizeof(icalbdbset));\n        *data = icalset_bdbset_init;\n        break;\n    }\n#endif\n\n    default:\n        icalerror_set_errno(ICAL_UNIMPLEMENTED_ERROR);\n        /** unimplemented **/\n        return (NULL);\n    }\n\n    data->kind = kind;\n    data->dsn = strdup(dsn);\n#endif\n\n    /** call the implementation specific initializer **/\n    if ((ret = data->init(data, dsn, options)) == NULL) {\n        icalset_free(data);\n    }\n\n    return ret;\n}\n\nicalset *icalset_new_file(const char *path)\n{\n    return icalset_new(ICAL_FILE_SET, path, NULL);\n}\n\nicalset *icalset_new_file_writer(const char *path)\n{\n    return icalfileset_new_writer(path);\n}\n\nicalset *icalset_new_file_reader(const char *path)\n{\n    return icalfileset_new_reader(path);\n}\n\nicalset *icalset_new_dir(const char *path)\n{\n    return icalset_new(ICAL_DIR_SET, path, NULL);\n}\n\nicalset *icalset_new_dir_writer(const char *path)\n{\n    return icaldirset_new_writer(path);\n}\n\nicalset *icalset_new_dir_reader(const char *path)\n{\n    return icaldirset_new_reader(path);\n}\n\n/* Functions for built-in methods */\n\n/**\n *  free memory associated with this icalset\n *  automatically calls the implementation specific free routine\n */\n\nvoid icalset_free(icalset *set)\n{\n    if (set->free) {\n        set->free(set);\n    }\n\n    if (set->dsn) {\n        free(set->dsn);\n    }\n\n    free(set);\n}\n\nconst char *icalset_path(icalset *set)\n{\n    return set->path(set);\n}\n\nvoid icalset_mark(icalset *set)\n{\n    set->mark(set);\n}\n\nicalerrorenum icalset_commit(icalset *set)\n{\n    return set->commit(set);\n}\n\nicalerrorenum icalset_add_component(icalset *set, icalcomponent *comp)\n{\n    return set->add_component(set, comp);\n}\n\nicalerrorenum icalset_remove_component(icalset *set, icalcomponent *comp)\n{\n    return set->remove_component(set, comp);\n}\n\nint icalset_count_components(icalset *set, icalcomponent_kind kind)\n{\n    return set->count_components(set, kind);\n}\n\nicalerrorenum icalset_select(icalset *set, icalgauge *gauge)\n{\n    return set->select(set, gauge);\n}\n\nvoid icalset_clear(icalset *set)\n{\n    set->clear(set);\n}\n\nicalcomponent *icalset_fetch(icalset *set, const char *uid)\n{\n    return set->fetch(set, 0, uid);\n}\n\nicalcomponent *icalset_fetch_match(icalset *set, icalcomponent *comp)\n{\n    return set->fetch_match(set, comp);\n}\n\nint icalset_has_uid(icalset *set, const char *uid)\n{\n    return set->has_uid(set, uid);\n}\n\nicalerrorenum icalset_modify(icalset *set, icalcomponent *old, icalcomponent *new)\n{\n    return set->modify(set, old, new);\n}\n\nicalcomponent *icalset_get_current_component(icalset *set)\n{\n    return set->get_current_component(set);\n}\n\nicalcomponent *icalset_get_first_component(icalset *set)\n{\n    return set->get_first_component(set);\n}\n\nicalcomponent *icalset_get_next_component(icalset *set)\n{\n    return set->get_next_component(set);\n}\n\nicalsetiter icalsetiter_null = { {ICAL_NO_COMPONENT, 0}\n, 0, 0, 0, 0 };\n\nicalsetiter icalset_begin_component(icalset *set,\n                                    icalcomponent_kind kind, icalgauge *gauge, const char *tzid)\n{\n    return set->icalset_begin_component(set, kind, gauge, tzid);\n}\n\nicalcomponent *icalsetiter_next(icalsetiter *itr)\n{\n    icalcomponent *c = 0;\n\n    icalerror_check_arg_rz((itr != NULL), \"i\");\n\n    do {\n        c = icalcompiter_next(&(itr->iter));\n        if (c != 0 && (itr->gauge == 0 || icalgauge_compare(itr->gauge, c) == 1)) {\n            return c;\n        }\n    } while (c != 0);\n\n    return 0;\n}\n\nicalcomponent *icalsetiter_prior(icalsetiter *i)\n{\n    icalcomponent *c = 0;\n\n    icalerror_check_arg_rz((i != NULL), \"i\");\n\n    do {\n        c = icalcompiter_prior(&(i->iter));\n        if (c != 0 && (i->gauge == 0 || icalgauge_compare(i->gauge, c) == 1)) {\n            return c;\n        }\n    } while (c != 0);\n\n    return 0;\n}\n\nicalcomponent *icalsetiter_deref(icalsetiter *i)\n{\n    icalerror_check_arg_rz((i != NULL), \"i\");\n    return (icalcompiter_deref(&(i->iter)));\n}\n\n/* for subclasses that use multiple clusters that require specialized cluster traversal */\nicalcomponent *icalsetiter_to_next(icalset *set, icalsetiter *i)\n{\n    return set->icalsetiter_to_next(set, i);\n}\n\nicalcomponent *icalsetiter_to_prior(icalset *set, icalsetiter *i)\n{\n    return set->icalsetiter_to_prior(set, i);\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-libical-3.0.8-zhcncr4jo22ylh5du5qzmeftftf3u3iq/spack-src/test-data/malloc.ics",
        "/tmp/vanessa/spack-stage/spack-stage-libical-3.0.8-zhcncr4jo22ylh5du5qzmeftftf3u3iq/spack-src/test-data/issue252.ics",
        "/tmp/vanessa/spack-stage/spack-stage-libical-3.0.8-zhcncr4jo22ylh5du5qzmeftftf3u3iq/spack-src/test-data/issue253.ics",
        "/tmp/vanessa/spack-stage/spack-stage-libical-3.0.8-zhcncr4jo22ylh5du5qzmeftftf3u3iq/spack-src/test-data/crash.ics"
    ],
    "total_files": 985
}