{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-talloc-2.1.9-mym4vb4o7y2j237svrlauyjwjdr6fn6r/spack-src/lib/replace/replace.h": "/*\n   Unix SMB/CIFS implementation.\n\n   macros to go along with the lib/replace/ portability layer code\n\n   Copyright (C) Andrew Tridgell 2005\n   Copyright (C) Jelmer Vernooij 2006-2008\n   Copyright (C) Jeremy Allison 2007.\n\n     ** NOTE! The following LGPL license applies to the replace\n     ** library. This does NOT imply that all of Samba is released\n     ** under the LGPL\n\n   This library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation; either\n   version 3 of the License, or (at your option) any later version.\n\n   This library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with this library; if not, see <http://www.gnu.org/licenses/>.\n*/\n\n#ifndef _LIBREPLACE_REPLACE_H\n#define _LIBREPLACE_REPLACE_H\n\n#ifndef NO_CONFIG_H\n#include \"config.h\"\n#endif\n\n#ifdef HAVE_STANDARDS_H\n#include <standards.h>\n#endif\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdarg.h>\n#include <errno.h>\n\n#ifndef HAVE_DECL_EWOULDBLOCK\n#define EWOULDBLOCK EAGAIN\n#endif\n\n#if defined(_MSC_VER) || defined(__MINGW32__)\n#include \"win32_replace.h\"\n#endif\n\n\n#ifdef HAVE_INTTYPES_H\n#define __STDC_FORMAT_MACROS\n#include <inttypes.h>\n#elif HAVE_STDINT_H\n#include <stdint.h>\n/* force off HAVE_INTTYPES_H so that roken doesn't try to include both,\n   which causes a warning storm on irix */\n#undef HAVE_INTTYPES_H\n#endif\n\n#ifdef HAVE_MALLOC_H\n#include <malloc.h>\n#endif\n\n#ifndef __PRI64_PREFIX\n# if __WORDSIZE == 64 && ! defined __APPLE__\n#  define __PRI64_PREFIX\t\"l\"\n# else\n#  define __PRI64_PREFIX\t\"ll\"\n# endif\n#endif\n\n/* Decimal notation.  */\n#ifndef PRId8\n# define PRId8\t\t\"d\"\n#endif\n#ifndef PRId16\n# define PRId16\t\t\"d\"\n#endif\n#ifndef PRId32\n# define PRId32\t\t\"d\"\n#endif\n#ifndef PRId64\n# define PRId64\t\t__PRI64_PREFIX \"d\"\n#endif\n\n#ifndef PRIi8\n# define PRIi8\t\t\"i\"\n#endif\n#ifndef PRIi16\n# define PRIi16\t\t\"i\"\n#endif\n#ifndef PRIi32\n# define PRIi32\t\t\"i\"\n#endif\n#ifndef PRIi64\n# define PRIi64\t\t__PRI64_PREFIX \"i\"\n#endif\n\n#ifndef PRIu8\n# define PRIu8\t\t\"u\"\n#endif\n#ifndef PRIu16\n# define PRIu16\t\t\"u\"\n#endif\n#ifndef PRIu32\n# define PRIu32\t\t\"u\"\n#endif\n#ifndef PRIu64\n# define PRIu64\t\t__PRI64_PREFIX \"u\"\n#endif\n\n#ifndef SCNd8\n# define SCNd8\t\t\"hhd\"\n#endif\n#ifndef SCNd16\n# define SCNd16\t\t\"hd\"\n#endif\n#ifndef SCNd32\n# define SCNd32\t\t\"d\"\n#endif\n#ifndef SCNd64\n# define SCNd64\t\t__PRI64_PREFIX \"d\"\n#endif\n\n#ifndef SCNi8\n# define SCNi8\t\t\"hhi\"\n#endif\n#ifndef SCNi16\n# define SCNi16\t\t\"hi\"\n#endif\n#ifndef SCNi32\n# define SCNi32\t\t\"i\"\n#endif\n#ifndef SCNi64\n# define SCNi64\t\t__PRI64_PREFIX \"i\"\n#endif\n\n#ifndef SCNu8\n# define SCNu8\t\t\"hhu\"\n#endif\n#ifndef SCNu16\n# define SCNu16\t\t\"hu\"\n#endif\n#ifndef SCNu32\n# define SCNu32\t\t\"u\"\n#endif\n#ifndef SCNu64\n# define SCNu64\t\t__PRI64_PREFIX \"u\"\n#endif\n\n#ifdef HAVE_BSD_STRING_H\n#include <bsd/string.h>\n#endif\n\n#ifdef HAVE_BSD_UNISTD_H\n#include <bsd/unistd.h>\n#endif\n\n#ifdef HAVE_STRING_H\n#include <string.h>\n#endif\n\n#ifdef HAVE_STRINGS_H\n#include <strings.h>\n#endif\n\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n\n#ifdef HAVE_SYS_SYSMACROS_H\n#include <sys/sysmacros.h>\n#endif\n\n#ifdef HAVE_SETPROCTITLE_H\n#include <setproctitle.h>\n#endif\n\n#if STDC_HEADERS\n#include <stdlib.h>\n#include <stddef.h>\n#endif\n\n#ifdef HAVE_LINUX_TYPES_H\n/*\n * This is needed as some broken header files require this to be included early\n */\n#include <linux/types.h>\n#endif\n\n#ifndef HAVE_STRERROR\nextern char *sys_errlist[];\n#define strerror(i) sys_errlist[i]\n#endif\n\n#ifndef HAVE_ERRNO_DECL\nextern int errno;\n#endif\n\n#ifndef HAVE_STRDUP\n#define strdup rep_strdup\nchar *rep_strdup(const char *s);\n#endif\n\n#ifndef HAVE_MEMMOVE\n#define memmove rep_memmove\nvoid *rep_memmove(void *dest,const void *src,int size);\n#endif\n\n#ifndef HAVE_MEMMEM\n#define memmem rep_memmem\nvoid *rep_memmem(const void *haystack, size_t haystacklen,\n\t\t const void *needle, size_t needlelen);\n#endif\n\n#ifndef HAVE_MEMALIGN\n#define memalign rep_memalign\nvoid *rep_memalign(size_t boundary, size_t size);\n#endif\n\n#ifndef HAVE_MKTIME\n#define mktime rep_mktime\n/* prototype is in \"system/time.h\" */\n#endif\n\n#ifndef HAVE_TIMEGM\n#define timegm rep_timegm\n/* prototype is in \"system/time.h\" */\n#endif\n\n#ifndef HAVE_UTIME\n#define utime rep_utime\n/* prototype is in \"system/time.h\" */\n#endif\n\n#ifndef HAVE_UTIMES\n#define utimes rep_utimes\n/* prototype is in \"system/time.h\" */\n#endif\n\n#ifndef HAVE_STRLCPY\n#define strlcpy rep_strlcpy\nsize_t rep_strlcpy(char *d, const char *s, size_t bufsize);\n#endif\n\n#ifndef HAVE_STRLCAT\n#define strlcat rep_strlcat\nsize_t rep_strlcat(char *d, const char *s, size_t bufsize);\n#endif\n\n#ifndef HAVE_CLOSEFROM\n#define closefrom rep_closefrom\nint rep_closefrom(int lower);\n#endif\n\n\n#if (defined(BROKEN_STRNDUP) || !defined(HAVE_STRNDUP))\n#undef HAVE_STRNDUP\n#define strndup rep_strndup\nchar *rep_strndup(const char *s, size_t n);\n#endif\n\n#if (defined(BROKEN_STRNLEN) || !defined(HAVE_STRNLEN))\n#undef HAVE_STRNLEN\n#define strnlen rep_strnlen\nsize_t rep_strnlen(const char *s, size_t n);\n#endif\n\n#if !HAVE_DECL_ENVIRON\n#ifdef __APPLE__\n#include <crt_externs.h>\n#define environ (*_NSGetEnviron())\n#else\nextern char **environ;\n#endif\n#endif\n\n#ifndef HAVE_SETENV\n#define setenv rep_setenv\nint rep_setenv(const char *name, const char *value, int overwrite);\n#else\n#ifndef HAVE_SETENV_DECL\nint setenv(const char *name, const char *value, int overwrite);\n#endif\n#endif\n\n#ifndef HAVE_UNSETENV\n#define unsetenv rep_unsetenv\nint rep_unsetenv(const char *name);\n#endif\n\n#ifndef HAVE_SETEUID\n#define seteuid rep_seteuid\nint rep_seteuid(uid_t);\n#endif\n\n#ifndef HAVE_SETEGID\n#define setegid rep_setegid\nint rep_setegid(gid_t);\n#endif\n\n#if (defined(USE_SETRESUID) && !defined(HAVE_SETRESUID_DECL))\n/* stupid glibc */\nint setresuid(uid_t ruid, uid_t euid, uid_t suid);\n#endif\n#if (defined(USE_SETRESUID) && !defined(HAVE_SETRESGID_DECL))\nint setresgid(gid_t rgid, gid_t egid, gid_t sgid);\n#endif\n\n#ifndef HAVE_CHOWN\n#define chown rep_chown\nint rep_chown(const char *path, uid_t uid, gid_t gid);\n#endif\n\n#ifndef HAVE_CHROOT\n#define chroot rep_chroot\nint rep_chroot(const char *dirname);\n#endif\n\n#ifndef HAVE_LINK\n#define link rep_link\nint rep_link(const char *oldpath, const char *newpath);\n#endif\n\n#ifndef HAVE_READLINK\n#define readlink rep_readlink\nssize_t rep_readlink(const char *path, char *buf, size_t bufsize);\n#endif\n\n#ifndef HAVE_SYMLINK\n#define symlink rep_symlink\nint rep_symlink(const char *oldpath, const char *newpath);\n#endif\n\n#ifndef HAVE_REALPATH\n#define realpath rep_realpath\nchar *rep_realpath(const char *path, char *resolved_path);\n#endif\n\n#ifndef HAVE_LCHOWN\n#define lchown rep_lchown\nint rep_lchown(const char *fname,uid_t uid,gid_t gid);\n#endif\n\n#ifdef HAVE_UNIX_H\n#include <unix.h>\n#endif\n\n#ifndef HAVE_SETLINEBUF\n#define setlinebuf rep_setlinebuf\nvoid rep_setlinebuf(FILE *);\n#endif\n\n#ifndef HAVE_STRCASESTR\n#define strcasestr rep_strcasestr\nchar *rep_strcasestr(const char *haystack, const char *needle);\n#endif\n\n#ifndef HAVE_STRSEP\n#define strsep rep_strsep\nchar *rep_strsep(char **pps, const char *delim);\n#endif\n\n#ifndef HAVE_STRTOK_R\n#define strtok_r rep_strtok_r\nchar *rep_strtok_r(char *s, const char *delim, char **save_ptr);\n#endif\n\n\n\n#ifndef HAVE_STRTOLL\n#define strtoll rep_strtoll\nlong long int rep_strtoll(const char *str, char **endptr, int base);\n#else\n#ifdef HAVE_BSD_STRTOLL\n#define strtoll rep_strtoll\nlong long int rep_strtoll(const char *str, char **endptr, int base);\n#endif\n#endif\n\n#ifndef HAVE_STRTOULL\n#define strtoull rep_strtoull\nunsigned long long int rep_strtoull(const char *str, char **endptr, int base);\n#else\n#ifdef HAVE_BSD_STRTOLL /* yes, it's not HAVE_BSD_STRTOULL */\n#define strtoull rep_strtoull\nunsigned long long int rep_strtoull(const char *str, char **endptr, int base);\n#endif\n#endif\n\n#ifndef HAVE_FTRUNCATE\n#define ftruncate rep_ftruncate\nint rep_ftruncate(int,off_t);\n#endif\n\n#ifndef HAVE_INITGROUPS\n#define initgroups rep_initgroups\nint rep_initgroups(char *name, gid_t id);\n#endif\n\n#if !defined(HAVE_BZERO) && defined(HAVE_MEMSET)\n#define bzero(a,b) memset((a),'\\0',(b))\n#endif\n\n#ifndef HAVE_DLERROR\n#define dlerror rep_dlerror\nchar *rep_dlerror(void);\n#endif\n\n#ifndef HAVE_DLOPEN\n#define dlopen rep_dlopen\n#ifdef DLOPEN_TAKES_UNSIGNED_FLAGS\nvoid *rep_dlopen(const char *name, unsigned int flags);\n#else\nvoid *rep_dlopen(const char *name, int flags);\n#endif\n#endif\n\n#ifndef HAVE_DLSYM\n#define dlsym rep_dlsym\nvoid *rep_dlsym(void *handle, const char *symbol);\n#endif\n\n#ifndef HAVE_DLCLOSE\n#define dlclose rep_dlclose\nint rep_dlclose(void *handle);\n#endif\n\n#ifndef HAVE_SOCKETPAIR\n#define socketpair rep_socketpair\n/* prototype is in system/network.h */\n#endif\n\n#ifndef PRINTF_ATTRIBUTE\n#ifdef HAVE___ATTRIBUTE__\n/** Use gcc attribute to check printf fns.  a1 is the 1-based index of\n * the parameter containing the format, and a2 the index of the first\n * argument. Note that some gcc 2.x versions don't handle this\n * properly **/\n#define PRINTF_ATTRIBUTE(a1, a2) __attribute__ ((format (__printf__, a1, a2)))\n#else\n#define PRINTF_ATTRIBUTE(a1, a2)\n#endif\n#endif\n\n#ifndef _DEPRECATED_\n#ifdef HAVE___ATTRIBUTE__\n#define _DEPRECATED_ __attribute__ ((deprecated))\n#else\n#define _DEPRECATED_\n#endif\n#endif\n\n#if !defined(HAVE_VDPRINTF) || !defined(HAVE_C99_VSNPRINTF)\n#define vdprintf rep_vdprintf\nint rep_vdprintf(int fd, const char *format, va_list ap) PRINTF_ATTRIBUTE(2,0);\n#endif\n\n#if !defined(HAVE_DPRINTF) || !defined(HAVE_C99_VSNPRINTF)\n#define dprintf rep_dprintf\nint rep_dprintf(int fd, const char *format, ...) PRINTF_ATTRIBUTE(2,3);\n#endif\n\n#if !defined(HAVE_VASPRINTF) || !defined(HAVE_C99_VSNPRINTF)\n#define vasprintf rep_vasprintf\nint rep_vasprintf(char **ptr, const char *format, va_list ap) PRINTF_ATTRIBUTE(2,0);\n#endif\n\n#if !defined(HAVE_SNPRINTF) || !defined(HAVE_C99_VSNPRINTF)\n#define snprintf rep_snprintf\nint rep_snprintf(char *,size_t ,const char *, ...) PRINTF_ATTRIBUTE(3,4);\n#endif\n\n#if !defined(HAVE_VSNPRINTF) || !defined(HAVE_C99_VSNPRINTF)\n#define vsnprintf rep_vsnprintf\nint rep_vsnprintf(char *,size_t ,const char *, va_list ap) PRINTF_ATTRIBUTE(3,0);\n#endif\n\n#if !defined(HAVE_ASPRINTF) || !defined(HAVE_C99_VSNPRINTF)\n#define asprintf rep_asprintf\nint rep_asprintf(char **,const char *, ...) PRINTF_ATTRIBUTE(2,3);\n#endif\n\n#if !defined(HAVE_C99_VSNPRINTF)\n#ifdef REPLACE_BROKEN_PRINTF\n/*\n * We do not redefine printf by default\n * as it breaks the build if system headers\n * use __attribute__((format(printf, 3, 0)))\n * instead of __attribute__((format(__printf__, 3, 0)))\n */\n#define printf rep_printf\n#endif\nint rep_printf(const char *, ...) PRINTF_ATTRIBUTE(1,2);\n#endif\n\n#if !defined(HAVE_C99_VSNPRINTF)\n#define fprintf rep_fprintf\nint rep_fprintf(FILE *stream, const char *, ...) PRINTF_ATTRIBUTE(2,3);\n#endif\n\n#ifndef HAVE_VSYSLOG\n#ifdef HAVE_SYSLOG\n#define vsyslog rep_vsyslog\nvoid rep_vsyslog (int facility_priority, const char *format, va_list arglist) PRINTF_ATTRIBUTE(2,0);\n#endif\n#endif\n\n/* we used to use these fns, but now we have good replacements\n   for snprintf and vsnprintf */\n#define slprintf snprintf\n\n\n#ifndef HAVE_VA_COPY\n#undef va_copy\n#ifdef HAVE___VA_COPY\n#define va_copy(dest, src) __va_copy(dest, src)\n#else\n#define va_copy(dest, src) (dest) = (src)\n#endif\n#endif\n\n#ifndef HAVE_VOLATILE\n#define volatile\n#endif\n\n#ifndef HAVE_COMPARISON_FN_T\ntypedef int (*comparison_fn_t)(const void *, const void *);\n#endif\n\n#ifndef HAVE_WORKING_STRPTIME\n#define strptime rep_strptime\nstruct tm;\nchar *rep_strptime(const char *buf, const char *format, struct tm *tm);\n#endif\n\n#ifndef HAVE_DUP2\n#define dup2 rep_dup2\nint rep_dup2(int oldfd, int newfd);\n#endif\n\n/* Load header file for dynamic linking stuff */\n#ifdef HAVE_DLFCN_H\n#include <dlfcn.h>\n#endif\n\n#ifndef RTLD_LAZY\n#define RTLD_LAZY 0\n#endif\n#ifndef RTLD_NOW\n#define RTLD_NOW 0\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n#ifndef HAVE_SECURE_MKSTEMP\n#define mkstemp(path) rep_mkstemp(path)\nint rep_mkstemp(char *temp);\n#endif\n\n#ifndef HAVE_MKDTEMP\n#define mkdtemp rep_mkdtemp\nchar *rep_mkdtemp(char *template);\n#endif\n\n#ifndef HAVE_PREAD\n#define pread rep_pread\nssize_t rep_pread(int __fd, void *__buf, size_t __nbytes, off_t __offset);\n#define LIBREPLACE_PREAD_REPLACED 1\n#else\n#define LIBREPLACE_PREAD_NOT_REPLACED 1\n#endif\n\n#ifndef HAVE_PWRITE\n#define pwrite rep_pwrite\nssize_t rep_pwrite(int __fd, const void *__buf, size_t __nbytes, off_t __offset);\n#define LIBREPLACE_PWRITE_REPLACED 1\n#else\n#define LIBREPLACE_PWRITE_NOT_REPLACED 1\n#endif\n\n#if !defined(HAVE_INET_NTOA) || defined(REPLACE_INET_NTOA)\n#define inet_ntoa rep_inet_ntoa\n/* prototype is in \"system/network.h\" */\n#endif\n\n#ifndef HAVE_INET_PTON\n#define inet_pton rep_inet_pton\n/* prototype is in \"system/network.h\" */\n#endif\n\n#ifndef HAVE_INET_NTOP\n#define inet_ntop rep_inet_ntop\n/* prototype is in \"system/network.h\" */\n#endif\n\n#ifndef HAVE_INET_ATON\n#define inet_aton rep_inet_aton\n/* prototype is in \"system/network.h\" */\n#endif\n\n#ifndef HAVE_CONNECT\n#define connect rep_connect\n/* prototype is in \"system/network.h\" */\n#endif\n\n#ifndef HAVE_GETHOSTBYNAME\n#define gethostbyname rep_gethostbyname\n/* prototype is in \"system/network.h\" */\n#endif\n\n#ifndef HAVE_GETIFADDRS\n#define getifaddrs rep_getifaddrs\n/* prototype is in \"system/network.h\" */\n#endif\n\n#ifndef HAVE_FREEIFADDRS\n#define freeifaddrs rep_freeifaddrs\n/* prototype is in \"system/network.h\" */\n#endif\n\n#ifndef HAVE_GET_CURRENT_DIR_NAME\n#define get_current_dir_name rep_get_current_dir_name\nchar *rep_get_current_dir_name(void);\n#endif\n\n#ifndef HAVE_STRERROR_R\n#define strerror_r rep_strerror_r\nint rep_strerror_r(int errnum, char *buf, size_t buflen);\n#endif\n\n#if !defined(HAVE_CLOCK_GETTIME)\n#define clock_gettime rep_clock_gettime\n#endif\n\n#ifdef HAVE_LIMITS_H\n#include <limits.h>\n#endif\n\n#ifdef HAVE_SYS_PARAM_H\n#include <sys/param.h>\n#endif\n\n/* The extra casts work around common compiler bugs.  */\n#define _TYPE_SIGNED(t) (! ((t) 0 < (t) -1))\n/* The outer cast is needed to work around a bug in Cray C 5.0.3.0.\n   It is necessary at least when t == time_t.  */\n#define _TYPE_MINIMUM(t) ((t) (_TYPE_SIGNED (t) \\\n  \t\t\t      ? ~ (t) 0 << (sizeof (t) * CHAR_BIT - 1) : (t) 0))\n#define _TYPE_MAXIMUM(t) ((t) (~ (t) 0 - _TYPE_MINIMUM (t)))\n\n#ifndef UINT16_MAX\n#define UINT16_MAX 65535\n#endif\n\n#ifndef UINT32_MAX\n#define UINT32_MAX (4294967295U)\n#endif\n\n#ifndef UINT64_MAX\n#define UINT64_MAX ((uint64_t)-1)\n#endif\n\n#ifndef INT64_MAX\n#define INT64_MAX 9223372036854775807LL\n#endif\n\n#ifndef CHAR_BIT\n#define CHAR_BIT 8\n#endif\n\n#ifndef INT32_MAX\n#define INT32_MAX _TYPE_MAXIMUM(int32_t)\n#endif\n\n#ifdef HAVE_STDBOOL_H\n#include <stdbool.h>\n#endif\n\n#if !defined(HAVE_BOOL)\n#ifdef HAVE__Bool\n#define bool _Bool\n#else\ntypedef int bool;\n#endif\n#endif\n\n#if !defined(HAVE_INTPTR_T)\ntypedef long long intptr_t ;\n#endif\n\n#if !defined(HAVE_UINTPTR_T)\ntypedef unsigned long long uintptr_t ;\n#endif\n\n#if !defined(HAVE_PTRDIFF_T)\ntypedef unsigned long long ptrdiff_t ;\n#endif\n\n/*\n * to prevent <rpcsvc/yp_prot.h> from doing a redefine of 'bool'\n *\n * IRIX, HPUX, MacOS 10 and Solaris need BOOL_DEFINED\n * Tru64 needs _BOOL_EXISTS\n * AIX needs _BOOL,_TRUE,_FALSE\n */\n#ifndef BOOL_DEFINED\n#define BOOL_DEFINED\n#endif\n#ifndef _BOOL_EXISTS\n#define _BOOL_EXISTS\n#endif\n#ifndef _BOOL\n#define _BOOL\n#endif\n\n#ifndef __bool_true_false_are_defined\n#define __bool_true_false_are_defined\n#endif\n\n#ifndef true\n#define true (1)\n#endif\n#ifndef false\n#define false (0)\n#endif\n\n#ifndef _TRUE\n#define _TRUE true\n#endif\n#ifndef _FALSE\n#define _FALSE false\n#endif\n\n#ifndef HAVE_FUNCTION_MACRO\n#ifdef HAVE_func_MACRO\n#define __FUNCTION__ __func__\n#else\n#define __FUNCTION__ (\"\")\n#endif\n#endif\n\n\n#ifndef MIN\n#define MIN(a,b) ((a)<(b)?(a):(b))\n#endif\n\n#ifndef MAX\n#define MAX(a,b) ((a)>(b)?(a):(b))\n#endif\n\n#if !defined(HAVE_VOLATILE)\n#define volatile\n#endif\n\n/**\n  this is a warning hack. The idea is to use this everywhere that we\n  get the \"discarding const\" warning from gcc. That doesn't actually\n  fix the problem of course, but it means that when we do get to\n  cleaning them up we can do it by searching the code for\n  discard_const.\n\n  It also means that other error types aren't as swamped by the noise\n  of hundreds of const warnings, so we are more likely to notice when\n  we get new errors.\n\n  Please only add more uses of this macro when you find it\n  _really_ hard to fix const warnings. Our aim is to eventually use\n  this function in only a very few places.\n\n  Also, please call this via the discard_const_p() macro interface, as that\n  makes the return type safe.\n*/\n#define discard_const(ptr) ((void *)((uintptr_t)(ptr)))\n\n/** Type-safe version of discard_const */\n#define discard_const_p(type, ptr) ((type *)discard_const(ptr))\n\n#ifndef __STRING\n#define __STRING(x)    #x\n#endif\n\n#ifndef __STRINGSTRING\n#define __STRINGSTRING(x) __STRING(x)\n#endif\n\n#ifndef __LINESTR__\n#define __LINESTR__ __STRINGSTRING(__LINE__)\n#endif\n\n#ifndef __location__\n#define __location__ __FILE__ \":\" __LINESTR__\n#endif\n\n/** \n * zero a structure \n */\n#define ZERO_STRUCT(x) memset((char *)&(x), 0, sizeof(x))\n\n/** \n * zero a structure given a pointer to the structure \n */\n#define ZERO_STRUCTP(x) do { if ((x) != NULL) memset((char *)(x), 0, sizeof(*(x))); } while(0)\n\n/** \n * zero a structure given a pointer to the structure - no zero check \n */\n#define ZERO_STRUCTPN(x) memset((char *)(x), 0, sizeof(*(x)))\n\n/* zero an array - note that sizeof(array) must work - ie. it must not be a\n   pointer */\n#define ZERO_ARRAY(x) memset((char *)(x), 0, sizeof(x))\n\n/**\n * work out how many elements there are in a static array \n */\n#define ARRAY_SIZE(a) (sizeof(a)/sizeof(a[0]))\n\n/** \n * pointer difference macro \n */\n#define PTR_DIFF(p1,p2) ((ptrdiff_t)(((const char *)(p1)) - (const char *)(p2)))\n\n#if MMAP_BLACKLIST\n#undef HAVE_MMAP\n#endif\n\n#ifdef __COMPAR_FN_T\n#define QSORT_CAST (__compar_fn_t)\n#endif\n\n#ifndef QSORT_CAST\n#define QSORT_CAST (int (*)(const void *, const void *))\n#endif\n\n#ifndef PATH_MAX\n#define PATH_MAX 1024\n#endif\n\n#ifndef MAX_DNS_NAME_LENGTH\n#define MAX_DNS_NAME_LENGTH 256 /* Actually 255 but +1 for terminating null. */\n#endif\n\n#ifndef HAVE_CRYPT\nchar *ufc_crypt(const char *key, const char *salt);\n#define crypt ufc_crypt\n#else\n#ifdef HAVE_CRYPT_H\n#include <crypt.h>\n#endif\n#endif\n\n/* these macros gain us a few percent of speed on gcc */\n#if (__GNUC__ >= 3)\n/* the strange !! is to ensure that __builtin_expect() takes either 0 or 1\n   as its first argument */\n#ifndef likely\n#define likely(x)   __builtin_expect(!!(x), 1)\n#endif\n#ifndef unlikely\n#define unlikely(x) __builtin_expect(!!(x), 0)\n#endif\n#else\n#ifndef likely\n#define likely(x) (x)\n#endif\n#ifndef unlikely\n#define unlikely(x) (x)\n#endif\n#endif\n\n#ifndef HAVE_FDATASYNC\n#define fdatasync(fd) fsync(fd)\n#elif !defined(HAVE_DECL_FDATASYNC)\nint fdatasync(int );\n#endif\n\n/* these are used to mark symbols as local to a shared lib, or\n * publicly available via the shared lib API */\n#ifndef _PUBLIC_\n#ifdef HAVE_VISIBILITY_ATTR\n#define _PUBLIC_ __attribute__((visibility(\"default\")))\n#else\n#define _PUBLIC_\n#endif\n#endif\n\n#ifndef _PRIVATE_\n#ifdef HAVE_VISIBILITY_ATTR\n#  define _PRIVATE_ __attribute__((visibility(\"hidden\")))\n#else\n#  define _PRIVATE_\n#endif\n#endif\n\n#ifndef HAVE_POLL\n#define poll rep_poll\n/* prototype is in \"system/network.h\" */\n#endif\n\n#ifndef HAVE_GETPEEREID\n#define getpeereid rep_getpeereid\nint rep_getpeereid(int s, uid_t *uid, gid_t *gid);\n#endif\n\n#ifndef HAVE_USLEEP\n#define usleep rep_usleep\ntypedef long useconds_t;\nint usleep(useconds_t);\n#endif\n\n#ifndef HAVE_SETPROCTITLE\n#define setproctitle rep_setproctitle\nvoid rep_setproctitle(const char *fmt, ...) PRINTF_ATTRIBUTE(1, 2);\n#endif\n\nbool nss_wrapper_enabled(void);\nbool nss_wrapper_hosts_enabled(void);\nbool socket_wrapper_enabled(void);\nbool uid_wrapper_enabled(void);\n\n/* Needed for Solaris atomic_add_XX functions. */\n#if defined(HAVE_SYS_ATOMIC_H)\n#include <sys/atomic.h>\n#endif\n\n#endif /* _LIBREPLACE_REPLACE_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-talloc-2.1.9-mym4vb4o7y2j237svrlauyjwjdr6fn6r/spack-src/lib/replace/dlfcn.c": "/* \n   Unix SMB/CIFS implementation.\n   Samba system utilities\n   Copyright (C) Andrew Tridgell 1992-1998\n   Copyright (C) Jeremy Allison 1998-2002\n   Copyright (C) Jelmer Vernooij 2006\n\n     ** NOTE! The following LGPL license applies to the replace\n     ** library. This does NOT imply that all of Samba is released\n     ** under the LGPL\n   \n   This library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation; either\n   version 3 of the License, or (at your option) any later version.\n\n   This library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with this library; if not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include \"replace.h\"\n#ifdef HAVE_DL_H\n#include <dl.h>\n#endif\n\n#ifndef HAVE_DLOPEN\n#ifdef DLOPEN_TAKES_UNSIGNED_FLAGS\nvoid *rep_dlopen(const char *name, unsigned int flags)\n#else\nvoid *rep_dlopen(const char *name, int flags)\n#endif\n{\n#ifdef HAVE_SHL_LOAD\n\tif (name == NULL)\n\t\treturn PROG_HANDLE;\n\treturn (void *)shl_load(name, flags, 0);\n#else\n\treturn NULL;\n#endif\n}\n#endif\n\n#ifndef HAVE_DLSYM\nvoid *rep_dlsym(void *handle, const char *symbol)\n{\n#ifdef HAVE_SHL_FINDSYM\n\tvoid *sym_addr;\n\tif (!shl_findsym((shl_t *)&handle, symbol, TYPE_UNDEFINED, &sym_addr))\n\t\treturn sym_addr;\n#endif\n    return NULL;\n}\n#endif\n\n#ifndef HAVE_DLERROR\nchar *rep_dlerror(void)\n{\n\treturn \"dynamic loading of objects not supported on this platform\";\n}\n#endif\n\n#ifndef HAVE_DLCLOSE\nint rep_dlclose(void *handle)\n{\n#ifdef HAVE_SHL_CLOSE\n\treturn shl_unload((shl_t)handle);\n#else\n\treturn 0;\n#endif\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-talloc-2.1.9-mym4vb4o7y2j237svrlauyjwjdr6fn6r/spack-src/lib/replace/test/testsuite.c": "/* \n   Unix SMB/CIFS implementation.\n\n   libreplace tests\n\n   Copyright (C) Jelmer Vernooij 2006\n\n     ** NOTE! The following LGPL license applies to the talloc\n     ** library. This does NOT imply that all of Samba is released\n     ** under the LGPL\n   \n   This library is free software; you can redistribute it and/or\n   modify it under the terms of the GNU Lesser General Public\n   License as published by the Free Software Foundation; either\n   version 3 of the License, or (at your option) any later version.\n\n   This library is distributed in the hope that it will be useful,\n   but WITHOUT ANY WARRANTY; without even the implied warranty of\n   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n   Lesser General Public License for more details.\n\n   You should have received a copy of the GNU Lesser General Public\n   License along with this library; if not, see <http://www.gnu.org/licenses/>.\n*/\n\n#include \"replace.h\"\n#include \"replace-test.h\"\n#include \"replace-testsuite.h\"\n\n/*\n  we include all the system/ include files here so that libreplace tests\n  them in the build farm\n*/\n#include \"system/capability.h\"\n#include \"system/dir.h\"\n#include \"system/filesys.h\"\n#include \"system/glob.h\"\n#include \"system/iconv.h\"\n#include \"system/locale.h\"\n#include \"system/network.h\"\n#include \"system/passwd.h\"\n#include \"system/readline.h\"\n#include \"system/select.h\"\n#include \"system/shmem.h\"\n#include \"system/syslog.h\"\n#include \"system/terminal.h\"\n#include \"system/time.h\"\n#include \"system/wait.h\"\n#include \"system/aio.h\"\n\n#define TESTFILE \"testfile.dat\"\n\n\n/*\n  test ftruncate() function\n */\nstatic int test_ftruncate(void)\n{\n\tstruct stat st;\n\tint fd;\n\tconst int size = 1234;\n\tprintf(\"test: ftruncate\\n\");\n\tunlink(TESTFILE);\n\tfd = open(TESTFILE, O_RDWR|O_CREAT, 0600);\n\tif (fd == -1) {\n\t\tprintf(\"failure: ftruncate [\\n\"\n\t\t\t   \"creating '%s' failed - %s\\n]\\n\", TESTFILE, strerror(errno));\n\t\treturn false;\n\t}\n\tif (ftruncate(fd, size) != 0) {\n\t\tprintf(\"failure: ftruncate [\\n%s\\n]\\n\", strerror(errno));\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\tif (fstat(fd, &st) != 0) {\n\t\tprintf(\"failure: ftruncate [\\nfstat failed - %s\\n]\\n\", strerror(errno));\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\tif (st.st_size != size) {\n\t\tprintf(\"failure: ftruncate [\\ngave wrong size %d - expected %d\\n]\\n\",\n\t\t       (int)st.st_size, size);\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\tunlink(TESTFILE);\n\tprintf(\"success: ftruncate\\n\");\n\tclose(fd);\n\treturn true;\n}\n\n/*\n  test strlcpy() function.\n  see http://www.gratisoft.us/todd/papers/strlcpy.html\n */\nstatic int test_strlcpy(void)\n{\n\tchar buf[4];\n\tconst struct {\n\t\tconst char *src;\n\t\tsize_t result;\n\t} tests[] = {\n\t\t{ \"abc\", 3 },\n\t\t{ \"abcdef\", 6 },\n\t\t{ \"abcd\", 4 },\n\t\t{ \"\", 0 },\n\t\t{ NULL, 0 }\n\t};\n\tint i;\n\tprintf(\"test: strlcpy\\n\");\n\tfor (i=0;tests[i].src;i++) {\n\t\tif (strlcpy(buf, tests[i].src, sizeof(buf)) != tests[i].result) {\n\t\t\tprintf(\"failure: strlcpy [\\ntest %d failed\\n]\\n\", i);\n\t\t\treturn false;\n\t\t}\n\t}\n\tprintf(\"success: strlcpy\\n\");\n\treturn true;\n}\n\nstatic int test_strlcat(void)\n{\n\tchar tmp[10];\n\tprintf(\"test: strlcat\\n\");\n\tstrlcpy(tmp, \"\", sizeof(tmp));\n\tif (strlcat(tmp, \"bla\", 3) != 3) {\n\t\tprintf(\"failure: strlcat [\\ninvalid return code\\n]\\n\");\n\t\treturn false;\n\t}\n\tif (strcmp(tmp, \"bl\") != 0) {\n\t\tprintf(\"failure: strlcat [\\nexpected \\\"bl\\\", got \\\"%s\\\"\\n]\\n\", \n\t\t\t   tmp);\n\t\treturn false;\n\t}\n\n\tstrlcpy(tmp, \"da\", sizeof(tmp));\n\tif (strlcat(tmp, \"me\", 4) != 4) {\n\t\tprintf(\"failure: strlcat [\\nexpected \\\"dam\\\", got \\\"%s\\\"\\n]\\n\",\n\t\t\t   tmp);\n\t\treturn false;\n\t}\n\n\tprintf(\"success: strlcat\\n\");\n\treturn true;\n}\n\nstatic int test_mktime(void)\n{\n\t/* FIXME */\n\treturn true;\n}\n\nstatic int test_initgroups(void)\n{\n\t/* FIXME */\n\treturn true;\n}\n\nstatic int test_memmove(void)\n{\n\t/* FIXME */\n\treturn true;\n}\n\nstatic int test_strdup(void)\n{\n\tchar *x;\n\tprintf(\"test: strdup\\n\");\n\tx = strdup(\"bla\");\n\tif (strcmp(\"bla\", x) != 0) {\n\t\tprintf(\"failure: strdup [\\nfailed: expected \\\"bla\\\", got \\\"%s\\\"\\n]\\n\",\n\t\t\t   x);\n\t\treturn false;\n\t}\n\tfree(x);\n\tprintf(\"success: strdup\\n\");\n\treturn true;\n}\t\n\nstatic int test_setlinebuf(void)\n{\n\tprintf(\"test: setlinebuf\\n\");\n\tsetlinebuf(stdout);\n\tprintf(\"success: setlinebuf\\n\");\n\treturn true;\n}\n\nstatic int test_vsyslog(void)\n{\n\t/* FIXME */\n\treturn true;\n}\n\nstatic int test_timegm(void)\n{\n\t/* FIXME */\n\treturn true;\n}\n\nstatic int test_setenv(void)\n{\n#define TEST_SETENV(key, value, overwrite, result) do { \\\n\tint _ret; \\\n\tchar *_v; \\\n\t_ret = setenv(key, value, overwrite); \\\n\tif (_ret != 0) { \\\n\t\tprintf(\"failure: setenv [\\n\" \\\n\t\t\t\"setenv(%s, %s, %d) failed\\n\" \\\n\t\t\t\"]\\n\", \\\n\t\t\tkey, value, overwrite); \\\n\t\treturn false; \\\n\t} \\\n\t_v=getenv(key); \\\n\tif (!_v) { \\\n\t\tprintf(\"failure: setenv [\\n\" \\\n\t\t\t\"getenv(%s) returned NULL\\n\" \\\n\t\t\t\"]\\n\", \\\n\t\t\tkey); \\\n\t\treturn false; \\\n\t} \\\n\tif (strcmp(result, _v) != 0) { \\\n\t\tprintf(\"failure: setenv [\\n\" \\\n\t\t\t\"getenv(%s): '%s' != '%s'\\n\" \\\n\t\t\t\"]\\n\", \\\n\t\t\tkey, result, _v); \\\n\t\treturn false; \\\n\t} \\\n} while(0)\n\n#define TEST_UNSETENV(key) do { \\\n\tchar *_v; \\\n\tunsetenv(key); \\\n\t_v=getenv(key); \\\n\tif (_v) { \\\n\t\tprintf(\"failure: setenv [\\n\" \\\n\t\t\t\"getenv(%s): NULL != '%s'\\n\" \\\n\t\t\t\"]\\n\", \\\n\t\t\tSETENVTEST_KEY, _v); \\\n\t\treturn false; \\\n\t} \\\n} while (0)\n\n#define SETENVTEST_KEY \"SETENVTESTKEY\"\n#define SETENVTEST_VAL \"SETENVTESTVAL\"\n\n\tprintf(\"test: setenv\\n\");\n\tTEST_SETENV(SETENVTEST_KEY, SETENVTEST_VAL\"1\", 0, SETENVTEST_VAL\"1\");\n\tTEST_SETENV(SETENVTEST_KEY, SETENVTEST_VAL\"2\", 0, SETENVTEST_VAL\"1\");\n\tTEST_SETENV(SETENVTEST_KEY, SETENVTEST_VAL\"3\", 1, SETENVTEST_VAL\"3\");\n\tTEST_SETENV(SETENVTEST_KEY, SETENVTEST_VAL\"4\", 1, SETENVTEST_VAL\"4\");\n\tTEST_UNSETENV(SETENVTEST_KEY);\n\tTEST_UNSETENV(SETENVTEST_KEY);\n\tTEST_SETENV(SETENVTEST_KEY, SETENVTEST_VAL\"5\", 0, SETENVTEST_VAL\"5\");\n\tTEST_UNSETENV(SETENVTEST_KEY);\n\tTEST_UNSETENV(SETENVTEST_KEY);\n\tprintf(\"success: setenv\\n\");\n\treturn true;\n}\n\nstatic int test_strndup(void)\n{\n\tchar *x;\n\tprintf(\"test: strndup\\n\");\n\tx = strndup(\"bla\", 0);\n\tif (strcmp(x, \"\") != 0) {\n\t\tprintf(\"failure: strndup [\\ninvalid\\n]\\n\");\n\t\treturn false;\n\t}\n\tfree(x);\n\tx = strndup(\"bla\", 2);\n\tif (strcmp(x, \"bl\") != 0) {\n\t\tprintf(\"failure: strndup [\\ninvalid\\n]\\n\");\n\t\treturn false;\n\t}\n\tfree(x);\n\tx = strndup(\"bla\", 10);\n\tif (strcmp(x, \"bla\") != 0) {\n\t\tprintf(\"failure: strndup [\\ninvalid\\n]\\n\");\n\t\tfree(x);\n\t\treturn false;\n\t}\n\tfree(x);\n\tprintf(\"success: strndup\\n\");\n\treturn true;\n}\n\nstatic int test_strnlen(void)\n{\n\tprintf(\"test: strnlen\\n\");\n\tif (strnlen(\"bla\", 2) != 2) {\n\t\tprintf(\"failure: strnlen [\\nunexpected length\\n]\\n\");\n\t\treturn false;\n\t}\n\n\tif (strnlen(\"some text\\n\", 0) != 0) {\n\t\tprintf(\"failure: strnlen [\\nunexpected length\\n]\\n\");\n\t\treturn false;\n\t}\n\n\tif (strnlen(\"some text\", 20) != 9) {\n\t\tprintf(\"failure: strnlen [\\nunexpected length\\n]\\n\");\n\t\treturn false;\n\t}\n\n\tprintf(\"success: strnlen\\n\");\n\treturn true;\n}\n\nstatic int test_waitpid(void)\n{\n\t/* FIXME */\n\treturn true;\n}\n\nstatic int test_seteuid(void)\n{\n\t/* FIXME */\n\treturn true;\n}\n\nstatic int test_setegid(void)\n{\n\t/* FIXME */\n\treturn true;\n}\n\nstatic int test_asprintf(void)\n{\n\tchar *x;\n\tprintf(\"test: asprintf\\n\");\n\tif (asprintf(&x, \"%d\", 9) != 1) {\n\t\tprintf(\"failure: asprintf [\\ngenerate asprintf\\n]\\n\");\n\t\treturn false;\n\t}\n\tif (strcmp(x, \"9\") != 0) {\n\t\tprintf(\"failure: asprintf [\\ngenerate asprintf\\n]\\n\");\n\t\treturn false;\n\t}\n\tif (asprintf(&x, \"dat%s\", \"a\") != 4) {\n\t\tprintf(\"failure: asprintf [\\ngenerate asprintf\\n]\\n\");\n\t\treturn false;\n\t}\n\tif (strcmp(x, \"data\") != 0) {\n\t\tprintf(\"failure: asprintf [\\ngenerate asprintf\\n]\\n\");\n\t\treturn false;\n\t}\n\tprintf(\"success: asprintf\\n\");\n\treturn true;\n}\n\nstatic int test_snprintf(void)\n{\n\tchar tmp[10];\n\tprintf(\"test: snprintf\\n\");\n\tif (snprintf(tmp, 3, \"foo%d\", 9) != 4) {\n\t\tprintf(\"failure: snprintf [\\nsnprintf return code failed\\n]\\n\");\n\t\treturn false;\n\t}\n\n\tif (strcmp(tmp, \"fo\") != 0) {\n\t\tprintf(\"failure: snprintf [\\nsnprintf failed\\n]\\n\");\n\t\treturn false;\n\t}\n\n\tprintf(\"success: snprintf\\n\");\n\treturn true;\n}\n\nstatic int test_vasprintf(void)\n{\n\t/* FIXME */\n\treturn true;\n}\n\nstatic int test_vsnprintf(void)\n{\n\t/* FIXME */\n\treturn true;\n}\n\nstatic int test_opendir(void)\n{\n\t/* FIXME */\n\treturn true;\n}\n\nstatic int test_readdir(void)\n{\n\tprintf(\"test: readdir\\n\");\n\tif (test_readdir_os2_delete() != 0) {\n\t\treturn false;\n\t}\n\tprintf(\"success: readdir\\n\");\n\treturn true;\n}\n\nstatic int test_telldir(void)\n{\n\t/* FIXME */\n\treturn true;\n}\n\nstatic int test_seekdir(void)\n{\n\t/* FIXME */\n\treturn true;\n}\n\nstatic int test_dlopen(void)\n{\n\t/* FIXME: test dlopen, dlsym, dlclose, dlerror */\n\treturn true;\n}\n\n\nstatic int test_chroot(void)\n{\n\t/* FIXME: chroot() */\n\treturn true;\n}\n\nstatic int test_bzero(void)\n{\n\t/* FIXME: bzero */\n\treturn true;\n}\n\nstatic int test_strerror(void)\n{\n\t/* FIXME */\n\treturn true;\n}\n\nstatic int test_errno(void)\n{\n\tprintf(\"test: errno\\n\");\n\terrno = 3;\n\tif (errno != 3) {\n\t\tprintf(\"failure: errno [\\nerrno failed\\n]\\n\");\n\t\treturn false;\n\t}\n\n\tprintf(\"success: errno\\n\");\n\treturn true;\n}\n\nstatic int test_mkdtemp(void)\n{\n\t/* FIXME */\n\treturn true;\n}\n\nstatic int test_mkstemp(void)\n{\n\t/* FIXME */\n\treturn true;\n}\n\nstatic int test_pread(void)\n{\n\t/* FIXME */\n\treturn true;\n}\n\nstatic int test_pwrite(void)\n{\n\t/* FIXME */\n\treturn true;\n}\n\nstatic int test_inet_ntoa(void)\n{\n\t/* FIXME */\n\treturn true;\n}\n\n#define TEST_STRTO_X(type,fmt,func,str,base,res,diff,rrnoo) do {\\\n\ttype _v; \\\n\tchar _s[64]; \\\n\tchar *_p = NULL;\\\n\tchar *_ep = NULL; \\\n\tstrlcpy(_s, str, sizeof(_s));\\\n\tif (diff >= 0) { \\\n\t\t_ep = &_s[diff]; \\\n\t} \\\n\terrno = 0; \\\n\t_v = func(_s, &_p, base); \\\n\tif (errno != rrnoo) { \\\n\t\tprintf(\"failure: %s [\\n\" \\\n\t\t       \"\\t%s\\n\" \\\n\t\t       \"\\t%s(\\\"%s\\\",%d,%d): \" fmt \" (=/!)= \" fmt \"\\n\" \\\n\t\t       \"\\terrno: %d != %d\\n\" \\\n\t\t       \"]\\n\", \\\n\t\t        __STRING(func), __location__, __STRING(func), \\\n\t\t       str, diff, base, res, _v, rrnoo, errno); \\\n\t\treturn false; \\\n\t} else if (_v != res) { \\\n\t\tprintf(\"failure: %s [\\n\" \\\n\t\t       \"\\t%s\\n\" \\\n\t\t       \"\\t%s(\\\"%s\\\",%d,%d): \" fmt \" != \" fmt \"\\n\" \\\n\t\t       \"]\\n\", \\\n\t\t       __STRING(func), __location__, __STRING(func), \\\n\t\t       str, diff, base, res, _v); \\\n\t\treturn false; \\\n\t} else if (_p != _ep) { \\\n\t\tprintf(\"failure: %s [\\n\" \\\n\t\t       \"\\t%s\\n\" \\\n\t\t       \"\\t%s(\\\"%s\\\",%d,%d): \" fmt \" (=/!)= \" fmt \"\\n\" \\\n\t\t       \"\\tptr: %p - %p = %d != %d\\n\" \\\n\t\t       \"]\\n\", \\\n\t\t       __STRING(func), __location__, __STRING(func), \\\n\t\t       str, diff, base, res, _v, _ep, _p, (int)(diff - (_ep - _p)), diff); \\\n\t\treturn false; \\\n\t} \\\n} while (0)\n\nstatic int test_strtoll(void)\n{\n\tprintf(\"test: strtoll\\n\");\n\n#define TEST_STRTOLL(str,base,res,diff,errnoo) TEST_STRTO_X(long long int, \"%lld\", strtoll,str,base,res,diff,errnoo)\n\n\tTEST_STRTOLL(\"15\",\t10,\t15LL,\t2, 0);\n\tTEST_STRTOLL(\"  15\",\t10,\t15LL,\t4, 0);\n\tTEST_STRTOLL(\"15\",\t0,\t15LL,\t2, 0);\n\tTEST_STRTOLL(\" 15 \",\t0,\t15LL,\t3, 0);\n\tTEST_STRTOLL(\"+15\",\t10,\t15LL,\t3, 0);\n\tTEST_STRTOLL(\"  +15\",\t10,\t15LL,\t5, 0);\n\tTEST_STRTOLL(\"+15\",\t0,\t15LL,\t3, 0);\n\tTEST_STRTOLL(\" +15 \",\t0,\t15LL,\t4, 0);\n\tTEST_STRTOLL(\"-15\",\t10,\t-15LL,\t3, 0);\n\tTEST_STRTOLL(\"  -15\",\t10,\t-15LL,\t5, 0);\n\tTEST_STRTOLL(\"-15\",\t0,\t-15LL,\t3, 0);\n\tTEST_STRTOLL(\" -15 \",\t0,\t-15LL,\t4, 0);\n\tTEST_STRTOLL(\"015\",\t10,\t15LL,\t3, 0);\n\tTEST_STRTOLL(\"  015\",\t10,\t15LL,\t5, 0);\n\tTEST_STRTOLL(\"015\",\t0,\t13LL,\t3, 0);\n\tTEST_STRTOLL(\"  015\",\t0,\t13LL,\t5, 0);\n\tTEST_STRTOLL(\"0x15\",\t10,\t0LL,\t1, 0);\n\tTEST_STRTOLL(\"  0x15\",\t10,\t0LL,\t3, 0);\n\tTEST_STRTOLL(\"0x15\",\t0,\t21LL,\t4, 0);\n\tTEST_STRTOLL(\"  0x15\",\t0,\t21LL,\t6, 0);\n\n\tTEST_STRTOLL(\"10\",\t16,\t16LL,\t2, 0);\n\tTEST_STRTOLL(\"  10 \",\t16,\t16LL,\t4, 0);\n\tTEST_STRTOLL(\"0x10\",\t16,\t16LL,\t4, 0);\n\tTEST_STRTOLL(\"0x10\",\t0,\t16LL,\t4, 0);\n\tTEST_STRTOLL(\" 0x10 \",\t0,\t16LL,\t5, 0);\n\tTEST_STRTOLL(\"+10\",\t16,\t16LL,\t3, 0);\n\tTEST_STRTOLL(\"  +10 \",\t16,\t16LL,\t5, 0);\n\tTEST_STRTOLL(\"+0x10\",\t16,\t16LL,\t5, 0);\n\tTEST_STRTOLL(\"+0x10\",\t0,\t16LL,\t5, 0);\n\tTEST_STRTOLL(\" +0x10 \",\t0,\t16LL,\t6, 0);\n\tTEST_STRTOLL(\"-10\",\t16,\t-16LL,\t3, 0);\n\tTEST_STRTOLL(\"  -10 \",\t16,\t-16LL,\t5, 0);\n\tTEST_STRTOLL(\"-0x10\",\t16,\t-16LL,\t5, 0);\n\tTEST_STRTOLL(\"-0x10\",\t0,\t-16LL,\t5, 0);\n\tTEST_STRTOLL(\" -0x10 \",\t0,\t-16LL,\t6, 0);\n\tTEST_STRTOLL(\"010\",\t16,\t16LL,\t3, 0);\n\tTEST_STRTOLL(\"  010 \",\t16,\t16LL,\t5, 0);\n\tTEST_STRTOLL(\"-010\",\t16,\t-16LL,\t4, 0);\n\n\tTEST_STRTOLL(\"11\",\t8,\t9LL,\t2, 0);\n\tTEST_STRTOLL(\"011\",\t8,\t9LL,\t3, 0);\n\tTEST_STRTOLL(\"011\",\t0,\t9LL,\t3, 0);\n\tTEST_STRTOLL(\"-11\",\t8,\t-9LL,\t3, 0);\n\tTEST_STRTOLL(\"-011\",\t8,\t-9LL,\t4, 0);\n\tTEST_STRTOLL(\"-011\",\t0,\t-9LL,\t4, 0);\n\n\tTEST_STRTOLL(\"011\",\t8,\t9LL,\t3, 0);\n\tTEST_STRTOLL(\"011\",\t0,\t9LL,\t3, 0);\n\tTEST_STRTOLL(\"-11\",\t8,\t-9LL,\t3, 0);\n\tTEST_STRTOLL(\"-011\",\t8,\t-9LL,\t4, 0);\n\tTEST_STRTOLL(\"-011\",\t0,\t-9LL,\t4, 0);\n\n\tTEST_STRTOLL(\"Text\",\t0,\t0LL,\t0, 0);\n\n\tTEST_STRTOLL(\"9223372036854775807\",\t10,\t9223372036854775807LL,\t19, 0);\n\tTEST_STRTOLL(\"9223372036854775807\",\t0,\t9223372036854775807LL,\t19, 0);\n\tTEST_STRTOLL(\"9223372036854775808\",\t0,\t9223372036854775807LL,\t19, ERANGE);\n\tTEST_STRTOLL(\"9223372036854775808\",\t10,\t9223372036854775807LL,\t19, ERANGE);\n\tTEST_STRTOLL(\"0x7FFFFFFFFFFFFFFF\",\t0,\t9223372036854775807LL,\t18, 0);\n\tTEST_STRTOLL(\"0x7FFFFFFFFFFFFFFF\",\t16,\t9223372036854775807LL,\t18, 0);\n\tTEST_STRTOLL(\"7FFFFFFFFFFFFFFF\",\t16,\t9223372036854775807LL,\t16, 0);\n\tTEST_STRTOLL(\"0x8000000000000000\",\t0,\t9223372036854775807LL,\t18, ERANGE);\n\tTEST_STRTOLL(\"0x8000000000000000\",\t16,\t9223372036854775807LL,\t18, ERANGE);\n\tTEST_STRTOLL(\"80000000000000000\",\t16,\t9223372036854775807LL,\t17, ERANGE);\n\tTEST_STRTOLL(\"0777777777777777777777\",\t0,\t9223372036854775807LL,\t22, 0);\n\tTEST_STRTOLL(\"0777777777777777777777\",\t8,\t9223372036854775807LL,\t22, 0);\n\tTEST_STRTOLL(\"777777777777777777777\",\t8,\t9223372036854775807LL,\t21, 0);\n\tTEST_STRTOLL(\"01000000000000000000000\",\t0,\t9223372036854775807LL,\t23, ERANGE);\n\tTEST_STRTOLL(\"01000000000000000000000\",\t8,\t9223372036854775807LL,\t23, ERANGE);\n\tTEST_STRTOLL(\"1000000000000000000000\",\t8,\t9223372036854775807LL,\t22, ERANGE);\n\n\tTEST_STRTOLL(\"-9223372036854775808\",\t10,\t-9223372036854775807LL -1,\t20, 0);\n\tTEST_STRTOLL(\"-9223372036854775808\",\t0,\t-9223372036854775807LL -1,\t20, 0);\n\tTEST_STRTOLL(\"-9223372036854775809\",\t0,\t-9223372036854775807LL -1,\t20, ERANGE);\n\tTEST_STRTOLL(\"-9223372036854775809\",\t10,\t-9223372036854775807LL -1,\t20, ERANGE);\n\tTEST_STRTOLL(\"-0x8000000000000000\",\t0,\t-9223372036854775807LL -1,\t19, 0);\n\tTEST_STRTOLL(\"-0x8000000000000000\",\t16,\t-9223372036854775807LL -1,\t19, 0);\n\tTEST_STRTOLL(\"-8000000000000000\",\t16,\t-9223372036854775807LL -1,\t17, 0);\n\tTEST_STRTOLL(\"-0x8000000000000001\",\t0,\t-9223372036854775807LL -1,\t19, ERANGE);\n\tTEST_STRTOLL(\"-0x8000000000000001\",\t16,\t-9223372036854775807LL -1,\t19, ERANGE);\n\tTEST_STRTOLL(\"-80000000000000001\",\t16,\t-9223372036854775807LL -1,\t18, ERANGE);\n\tTEST_STRTOLL(\"-01000000000000000000000\",0,\t-9223372036854775807LL -1,\t24, 0);\n\tTEST_STRTOLL(\"-01000000000000000000000\",8,\t-9223372036854775807LL -1,\t24, 0);\n\tTEST_STRTOLL(\"-1000000000000000000000\",\t8,\t-9223372036854775807LL -1,\t23, 0);\n\tTEST_STRTOLL(\"-01000000000000000000001\",0,\t-9223372036854775807LL -1,\t24, ERANGE);\n\tTEST_STRTOLL(\"-01000000000000000000001\",8,\t-9223372036854775807LL -1,\t24, ERANGE);\n\tTEST_STRTOLL(\"-1000000000000000000001\",\t8,\t-9223372036854775807LL -1,\t23, ERANGE);\n\n\tprintf(\"success: strtoll\\n\");\n\treturn true;\n}\n\nstatic int test_strtoull(void)\n{\n\tprintf(\"test: strtoull\\n\");\n\n#define TEST_STRTOULL(str,base,res,diff,errnoo) TEST_STRTO_X(long long unsigned int,\"%llu\",strtoull,str,base,res,diff,errnoo)\n\n\tTEST_STRTOULL(\"15\",\t10,\t15LLU,\t2, 0);\n\tTEST_STRTOULL(\"  15\",\t10,\t15LLU,\t4, 0);\n\tTEST_STRTOULL(\"15\",\t0,\t15LLU,\t2, 0);\n\tTEST_STRTOULL(\" 15 \",\t0,\t15LLU,\t3, 0);\n\tTEST_STRTOULL(\"+15\",\t10,\t15LLU,\t3, 0);\n\tTEST_STRTOULL(\"  +15\",\t10,\t15LLU,\t5, 0);\n\tTEST_STRTOULL(\"+15\",\t0,\t15LLU,\t3, 0);\n\tTEST_STRTOULL(\" +15 \",\t0,\t15LLU,\t4, 0);\n\tTEST_STRTOULL(\"-15\",\t10,\t18446744073709551601LLU,\t3, 0);\n\tTEST_STRTOULL(\"  -15\",\t10,\t18446744073709551601LLU,\t5, 0);\n\tTEST_STRTOULL(\"-15\",\t0,\t18446744073709551601LLU,\t3, 0);\n\tTEST_STRTOULL(\" -15 \",\t0,\t18446744073709551601LLU,\t4, 0);\n\tTEST_STRTOULL(\"015\",\t10,\t15LLU,\t3, 0);\n\tTEST_STRTOULL(\"  015\",\t10,\t15LLU,\t5, 0);\n\tTEST_STRTOULL(\"015\",\t0,\t13LLU,\t3, 0);\n\tTEST_STRTOULL(\"  015\",\t0,\t13LLU,\t5, 0);\n\tTEST_STRTOULL(\"0x15\",\t10,\t0LLU,\t1, 0);\n\tTEST_STRTOULL(\"  0x15\",\t10,\t0LLU,\t3, 0);\n\tTEST_STRTOULL(\"0x15\",\t0,\t21LLU,\t4, 0);\n\tTEST_STRTOULL(\"  0x15\",\t0,\t21LLU,\t6, 0);\n\n\tTEST_STRTOULL(\"10\",\t16,\t16LLU,\t2, 0);\n\tTEST_STRTOULL(\"  10 \",\t16,\t16LLU,\t4, 0);\n\tTEST_STRTOULL(\"0x10\",\t16,\t16LLU,\t4, 0);\n\tTEST_STRTOULL(\"0x10\",\t0,\t16LLU,\t4, 0);\n\tTEST_STRTOULL(\" 0x10 \",\t0,\t16LLU,\t5, 0);\n\tTEST_STRTOULL(\"+10\",\t16,\t16LLU,\t3, 0);\n\tTEST_STRTOULL(\"  +10 \",\t16,\t16LLU,\t5, 0);\n\tTEST_STRTOULL(\"+0x10\",\t16,\t16LLU,\t5, 0);\n\tTEST_STRTOULL(\"+0x10\",\t0,\t16LLU,\t5, 0);\n\tTEST_STRTOULL(\" +0x10 \",\t0,\t16LLU,\t6, 0);\n\tTEST_STRTOULL(\"-10\",\t16,\t-16LLU,\t3, 0);\n\tTEST_STRTOULL(\"  -10 \",\t16,\t-16LLU,\t5, 0);\n\tTEST_STRTOULL(\"-0x10\",\t16,\t-16LLU,\t5, 0);\n\tTEST_STRTOULL(\"-0x10\",\t0,\t-16LLU,\t5, 0);\n\tTEST_STRTOULL(\" -0x10 \",\t0,\t-16LLU,\t6, 0);\n\tTEST_STRTOULL(\"010\",\t16,\t16LLU,\t3, 0);\n\tTEST_STRTOULL(\"  010 \",\t16,\t16LLU,\t5, 0);\n\tTEST_STRTOULL(\"-010\",\t16,\t-16LLU,\t4, 0);\n\n\tTEST_STRTOULL(\"11\",\t8,\t9LLU,\t2, 0);\n\tTEST_STRTOULL(\"011\",\t8,\t9LLU,\t3, 0);\n\tTEST_STRTOULL(\"011\",\t0,\t9LLU,\t3, 0);\n\tTEST_STRTOULL(\"-11\",\t8,\t-9LLU,\t3, 0);\n\tTEST_STRTOULL(\"-011\",\t8,\t-9LLU,\t4, 0);\n\tTEST_STRTOULL(\"-011\",\t0,\t-9LLU,\t4, 0);\n\n\tTEST_STRTOULL(\"011\",\t8,\t9LLU,\t3, 0);\n\tTEST_STRTOULL(\"011\",\t0,\t9LLU,\t3, 0);\n\tTEST_STRTOULL(\"-11\",\t8,\t-9LLU,\t3, 0);\n\tTEST_STRTOULL(\"-011\",\t8,\t-9LLU,\t4, 0);\n\tTEST_STRTOULL(\"-011\",\t0,\t-9LLU,\t4, 0);\n\n\tTEST_STRTOULL(\"Text\",\t0,\t0LLU,\t0, 0);\n\n\tTEST_STRTOULL(\"9223372036854775807\",\t10,\t9223372036854775807LLU,\t19, 0);\n\tTEST_STRTOULL(\"9223372036854775807\",\t0,\t9223372036854775807LLU,\t19, 0);\n\tTEST_STRTOULL(\"9223372036854775808\",\t0,\t9223372036854775808LLU,\t19, 0);\n\tTEST_STRTOULL(\"9223372036854775808\",\t10,\t9223372036854775808LLU,\t19, 0);\n\tTEST_STRTOULL(\"0x7FFFFFFFFFFFFFFF\",\t0,\t9223372036854775807LLU,\t18, 0);\n\tTEST_STRTOULL(\"0x7FFFFFFFFFFFFFFF\",\t16,\t9223372036854775807LLU,\t18, 0);\n\tTEST_STRTOULL(\"7FFFFFFFFFFFFFFF\",\t16,\t9223372036854775807LLU,\t16, 0);\n\tTEST_STRTOULL(\"0x8000000000000000\",\t0,\t9223372036854775808LLU,\t18, 0);\n\tTEST_STRTOULL(\"0x8000000000000000\",\t16,\t9223372036854775808LLU,\t18, 0);\n\tTEST_STRTOULL(\"8000000000000000\",\t16,\t9223372036854775808LLU,\t16, 0);\n\tTEST_STRTOULL(\"0777777777777777777777\",\t0,\t9223372036854775807LLU,\t22, 0);\n\tTEST_STRTOULL(\"0777777777777777777777\",\t8,\t9223372036854775807LLU,\t22, 0);\n\tTEST_STRTOULL(\"777777777777777777777\",\t8,\t9223372036854775807LLU,\t21, 0);\n\tTEST_STRTOULL(\"01000000000000000000000\",0,\t9223372036854775808LLU,\t23, 0);\n\tTEST_STRTOULL(\"01000000000000000000000\",8,\t9223372036854775808LLU,\t23, 0);\n\tTEST_STRTOULL(\"1000000000000000000000\",\t8,\t9223372036854775808LLU,\t22, 0);\n\n\tTEST_STRTOULL(\"-9223372036854775808\",\t10,\t9223372036854775808LLU,\t20, 0);\n\tTEST_STRTOULL(\"-9223372036854775808\",\t0,\t9223372036854775808LLU,\t20, 0);\n\tTEST_STRTOULL(\"-9223372036854775809\",\t0,\t9223372036854775807LLU,\t20, 0);\n\tTEST_STRTOULL(\"-9223372036854775809\",\t10,\t9223372036854775807LLU,\t20, 0);\n\tTEST_STRTOULL(\"-0x8000000000000000\",\t0,\t9223372036854775808LLU,\t19, 0);\n\tTEST_STRTOULL(\"-0x8000000000000000\",\t16,\t9223372036854775808LLU,\t19, 0);\n\tTEST_STRTOULL(\"-8000000000000000\",\t16,\t9223372036854775808LLU,\t17, 0);\n\tTEST_STRTOULL(\"-0x8000000000000001\",\t0,\t9223372036854775807LLU,\t19, 0);\n\tTEST_STRTOULL(\"-0x8000000000000001\",\t16,\t9223372036854775807LLU,\t19, 0);\n\tTEST_STRTOULL(\"-8000000000000001\",\t16,\t9223372036854775807LLU,\t17, 0);\n\tTEST_STRTOULL(\"-01000000000000000000000\",0,\t9223372036854775808LLU,\t24, 0);\n\tTEST_STRTOULL(\"-01000000000000000000000\",8,\t9223372036854775808LLU,\t24, 0);\n\tTEST_STRTOULL(\"-1000000000000000000000\",8,\t9223372036854775808LLU,\t23, 0);\n\tTEST_STRTOULL(\"-01000000000000000000001\",0,\t9223372036854775807LLU,\t24, 0);\n\tTEST_STRTOULL(\"-01000000000000000000001\",8,\t9223372036854775807LLU,\t24, 0);\n\tTEST_STRTOULL(\"-1000000000000000000001\",8,\t9223372036854775807LLU,\t23, 0);\n\n\tTEST_STRTOULL(\"18446744073709551615\",\t0,\t18446744073709551615LLU,\t20, 0);\n\tTEST_STRTOULL(\"18446744073709551615\",\t10,\t18446744073709551615LLU,\t20, 0);\n\tTEST_STRTOULL(\"18446744073709551616\",\t0,\t18446744073709551615LLU,\t20, ERANGE);\n\tTEST_STRTOULL(\"18446744073709551616\",\t10,\t18446744073709551615LLU,\t20, ERANGE);\n\tTEST_STRTOULL(\"0xFFFFFFFFFFFFFFFF\",\t0,\t18446744073709551615LLU,\t18, 0);\n\tTEST_STRTOULL(\"0xFFFFFFFFFFFFFFFF\",\t16,\t18446744073709551615LLU,\t18, 0);\n\tTEST_STRTOULL(\"FFFFFFFFFFFFFFFF\",\t16,\t18446744073709551615LLU,\t16, 0);\n\tTEST_STRTOULL(\"0x10000000000000000\",\t0,\t18446744073709551615LLU,\t19, ERANGE);\n\tTEST_STRTOULL(\"0x10000000000000000\",\t16,\t18446744073709551615LLU,\t19, ERANGE);\n\tTEST_STRTOULL(\"10000000000000000\",\t16,\t18446744073709551615LLU,\t17, ERANGE);\n\tTEST_STRTOULL(\"01777777777777777777777\",0,\t18446744073709551615LLU,\t23, 0);\n\tTEST_STRTOULL(\"01777777777777777777777\",8,\t18446744073709551615LLU,\t23, 0);\n\tTEST_STRTOULL(\"1777777777777777777777\",\t8,\t18446744073709551615LLU,\t22, 0);\n\tTEST_STRTOULL(\"02000000000000000000000\",0,\t18446744073709551615LLU,\t23, ERANGE);\n\tTEST_STRTOULL(\"02000000000000000000000\",8,\t18446744073709551615LLU,\t23, ERANGE);\n\tTEST_STRTOULL(\"2000000000000000000000\",\t8,\t18446744073709551615LLU,\t22, ERANGE);\n\n\tTEST_STRTOULL(\"-18446744073709551615\",\t0,\t1LLU,\t\t\t\t21, 0);\n\tTEST_STRTOULL(\"-18446744073709551615\",\t10,\t1LLU,\t\t\t\t21, 0);\n\tTEST_STRTOULL(\"-18446744073709551616\",\t0,\t18446744073709551615LLU,\t21, ERANGE);\n\tTEST_STRTOULL(\"-18446744073709551616\",\t10,\t18446744073709551615LLU,\t21, ERANGE);\n\tTEST_STRTOULL(\"-0xFFFFFFFFFFFFFFFF\",\t0,\t1LLU,\t\t\t\t19, 0);\n\tTEST_STRTOULL(\"-0xFFFFFFFFFFFFFFFF\",\t16,\t1LLU,\t\t\t\t19, 0);\n\tTEST_STRTOULL(\"-FFFFFFFFFFFFFFFF\",\t16,\t1LLU,\t\t\t\t17, 0);\n\tTEST_STRTOULL(\"-0x10000000000000000\",\t0,\t18446744073709551615LLU,\t20, ERANGE);\n\tTEST_STRTOULL(\"-0x10000000000000000\",\t16,\t18446744073709551615LLU,\t20, ERANGE);\n\tTEST_STRTOULL(\"-10000000000000000\",\t16,\t18446744073709551615LLU,\t18, ERANGE);\n\tTEST_STRTOULL(\"-01777777777777777777777\",0,\t1LLU,\t\t\t\t24, 0);\n\tTEST_STRTOULL(\"-01777777777777777777777\",8,\t1LLU,\t\t\t\t24, 0);\n\tTEST_STRTOULL(\"-1777777777777777777777\",8,\t1LLU,\t\t\t\t23, 0);\n\tTEST_STRTOULL(\"-02000000000000000000000\",0,\t18446744073709551615LLU,\t24, ERANGE);\n\tTEST_STRTOULL(\"-02000000000000000000000\",8,\t18446744073709551615LLU,\t24, ERANGE);\n\tTEST_STRTOULL(\"-2000000000000000000000\",8,\t18446744073709551615LLU,\t23, ERANGE);\n\n\tprintf(\"success: strtoull\\n\");\n\treturn true;\n}\n\n/* \nFIXME:\nTypes:\nbool\nsocklen_t\nuint{8,16,32,64}_t\nint{8,16,32,64}_t\nintptr_t\n\nConstants:\nPATH_NAME_MAX\nUINT{16,32,64}_MAX\nINT32_MAX\n*/\n\nstatic int test_va_copy(void)\n{\n\t/* FIXME */\n\treturn true;\n}\n\nstatic int test_FUNCTION(void)\n{\n\tprintf(\"test: FUNCTION\\n\");\n\tif (strcmp(__FUNCTION__, \"test_FUNCTION\") != 0) {\n\t\tprintf(\"failure: FUNCTION [\\nFUNCTION invalid\\n]\\n\");\n\t\treturn false;\n\t}\n\tprintf(\"success: FUNCTION\\n\");\n\treturn true;\n}\n\nstatic int test_MIN(void)\n{\n\tprintf(\"test: MIN\\n\");\n\tif (MIN(20, 1) != 1) {\n\t\tprintf(\"failure: MIN [\\nMIN invalid\\n]\\n\");\n\t\treturn false;\n\t}\n\tif (MIN(1, 20) != 1) {\n\t\tprintf(\"failure: MIN [\\nMIN invalid\\n]\\n\");\n\t\treturn false;\n\t}\n\tprintf(\"success: MIN\\n\");\n\treturn true;\n}\n\nstatic int test_MAX(void)\n{\n\tprintf(\"test: MAX\\n\");\n\tif (MAX(20, 1) != 20) {\n\t\tprintf(\"failure: MAX [\\nMAX invalid\\n]\\n\");\n\t\treturn false;\n\t}\n\tif (MAX(1, 20) != 20) {\n\t\tprintf(\"failure: MAX [\\nMAX invalid\\n]\\n\");\n\t\treturn false;\n\t}\n\tprintf(\"success: MAX\\n\");\n\treturn true;\n}\n\nstatic int test_socketpair(void)\n{\n\tint sock[2];\n\tchar buf[20];\n\n\tprintf(\"test: socketpair\\n\");\n\n\tif (socketpair(AF_UNIX, SOCK_STREAM, 0, sock) == -1) {\n\t\tprintf(\"failure: socketpair [\\n\"\n\t\t\t   \"socketpair() failed\\n\"\n\t\t\t   \"]\\n\");\n\t\treturn false;\n\t}\n\n\tif (write(sock[1], \"automatisch\", 12) == -1) {\n\t\tprintf(\"failure: socketpair [\\n\"\n\t\t\t   \"write() failed: %s\\n\"\n\t\t\t   \"]\\n\", strerror(errno));\n\t\treturn false;\n\t}\n\n\tif (read(sock[0], buf, 12) == -1) {\n\t\tprintf(\"failure: socketpair [\\n\"\n\t\t\t   \"read() failed: %s\\n\"\n\t\t\t   \"]\\n\", strerror(errno));\n\t\treturn false;\n\t}\n\n\tif (strcmp(buf, \"automatisch\") != 0) {\n\t\tprintf(\"failure: socketpair [\\n\"\n\t\t\t   \"expected: automatisch, got: %s\\n\"\n\t\t\t   \"]\\n\", buf);\n\t\treturn false;\n\t}\n\n\tprintf(\"success: socketpair\\n\");\n\n\treturn true;\n}\n\nextern int libreplace_test_strptime(void);\n\nstatic int test_strptime(void)\n{\n\treturn libreplace_test_strptime();\n}\n\nextern int getifaddrs_test(void);\n\nstatic int test_getifaddrs(void)\n{\n\n\tprintf(\"test: getifaddrs\\n\");\n\n\tif (getifaddrs_test() != 0) {\n\t\tprintf(\"failure: getifaddrs\\n\");\n\t\treturn false;\n\t}\n\n\tprintf(\"success: getifaddrs\\n\");\n\treturn true;\n}\n\nstatic int test_utime(void)\n{\n\tstruct utimbuf u;\n\tstruct stat st1, st2, st3;\n\tint fd;\n\n\tprintf(\"test: utime\\n\");\n\tunlink(TESTFILE);\n\n\tfd = open(TESTFILE, O_RDWR|O_CREAT, 0600);\n\tif (fd == -1) {\n\t\tprintf(\"failure: utime [\\n\"\n\t\t       \"creating '%s' failed - %s\\n]\\n\",\n\t\t       TESTFILE, strerror(errno));\n\t\treturn false;\n\t}\n\n\tif (fstat(fd, &st1) != 0) {\n\t\tprintf(\"failure: utime [\\n\"\n\t\t       \"fstat (1) failed - %s\\n]\\n\",\n\t\t       strerror(errno));\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n\tu.actime = st1.st_atime + 300;\n\tu.modtime = st1.st_mtime - 300;\n\tif (utime(TESTFILE, &u) != 0) {\n\t\tprintf(\"failure: utime [\\n\"\n\t\t       \"utime(&u) failed - %s\\n]\\n\",\n\t\t       strerror(errno));\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n\tif (fstat(fd, &st2) != 0) {\n\t\tprintf(\"failure: utime [\\n\"\n\t\t       \"fstat (2) failed - %s\\n]\\n\",\n\t\t       strerror(errno));\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n\tif (utime(TESTFILE, NULL) != 0) {\n\t\tprintf(\"failure: utime [\\n\"\n\t\t       \"utime(NULL) failed - %s\\n]\\n\",\n\t\t       strerror(errno));\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n\tif (fstat(fd, &st3) != 0) {\n\t\tprintf(\"failure: utime [\\n\"\n\t\t       \"fstat (3) failed - %s\\n]\\n\",\n\t\t       strerror(errno));\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n#define CMP_VAL(a,c,b) do { \\\n\tif (a c b) { \\\n\t\tprintf(\"failure: utime [\\n\" \\\n\t\t       \"%s: %s(%d) %s %s(%d)\\n]\\n\", \\\n\t\t       __location__, \\\n\t\t       #a, (int)a, #c, #b, (int)b); \\\n\t\tclose(fd); \\\n\t\treturn false; \\\n\t} \\\n} while(0)\n#define EQUAL_VAL(a,b) CMP_VAL(a,!=,b)\n#define GREATER_VAL(a,b) CMP_VAL(a,<=,b)\n#define LESSER_VAL(a,b) CMP_VAL(a,>=,b)\n\n\tEQUAL_VAL(st2.st_atime, st1.st_atime + 300);\n\tEQUAL_VAL(st2.st_mtime, st1.st_mtime - 300);\n\tLESSER_VAL(st3.st_atime, st2.st_atime);\n\tGREATER_VAL(st3.st_mtime, st2.st_mtime);\n\n#undef CMP_VAL\n#undef EQUAL_VAL\n#undef GREATER_VAL\n#undef LESSER_VAL\n\n\tunlink(TESTFILE);\n\tprintf(\"success: utime\\n\");\n\tclose(fd);\n\treturn true;\n}\n\nstatic int test_utimes(void)\n{\n\tstruct timeval tv[2];\n\tstruct stat st1, st2;\n\tint fd;\n\n\tprintf(\"test: utimes\\n\");\n\tunlink(TESTFILE);\n\n\tfd = open(TESTFILE, O_RDWR|O_CREAT, 0600);\n\tif (fd == -1) {\n\t\tprintf(\"failure: utimes [\\n\"\n\t\t       \"creating '%s' failed - %s\\n]\\n\",\n\t\t       TESTFILE, strerror(errno));\n\t\treturn false;\n\t}\n\n\tif (fstat(fd, &st1) != 0) {\n\t\tprintf(\"failure: utimes [\\n\"\n\t\t       \"fstat (1) failed - %s\\n]\\n\",\n\t\t       strerror(errno));\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n\tZERO_STRUCT(tv);\n\ttv[0].tv_sec = st1.st_atime + 300;\n\ttv[1].tv_sec = st1.st_mtime - 300;\n\tif (utimes(TESTFILE, tv) != 0) {\n\t\tprintf(\"failure: utimes [\\n\"\n\t\t       \"utimes(tv) failed - %s\\n]\\n\",\n\t\t       strerror(errno));\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n\tif (fstat(fd, &st2) != 0) {\n\t\tprintf(\"failure: utimes [\\n\"\n\t\t       \"fstat (2) failed - %s\\n]\\n\",\n\t\t       strerror(errno));\n\t\tclose(fd);\n\t\treturn false;\n\t}\n\n#define EQUAL_VAL(a,b) do { \\\n\tif (a != b) { \\\n\t\tprintf(\"failure: utimes [\\n\" \\\n\t\t       \"%s: %s(%d) != %s(%d)\\n]\\n\", \\\n\t\t       __location__, \\\n\t\t       #a, (int)a, #b, (int)b); \\\n\t\tclose(fd); \\\n\t\treturn false; \\\n\t} \\\n} while(0)\n\n\tEQUAL_VAL(st2.st_atime, st1.st_atime + 300);\n\tEQUAL_VAL(st2.st_mtime, st1.st_mtime - 300);\n\n#undef EQUAL_VAL\n\n\tunlink(TESTFILE);\n\tprintf(\"success: utimes\\n\");\n\tclose(fd);\n\treturn true;\n}\n\nstatic int test_memmem(void)\n{\n\tchar *s;\n\n\tprintf(\"test: memmem\\n\");\n\n\ts = (char *)memmem(\"foo\", 3, \"fo\", 2);\n\tif (strcmp(s, \"foo\") != 0) {\n\t\tprintf(__location__ \": Failed memmem\\n\");\n\t\treturn false;\n\t}\n\n\ts = (char *)memmem(\"foo\", 3, \"\", 0);\n\t/* it is allowable for this to return NULL (as happens on\n\t   FreeBSD) */\n\tif (s && strcmp(s, \"foo\") != 0) {\n\t\tprintf(__location__ \": Failed memmem\\n\");\n\t\treturn false;\n\t}\n\n\ts = (char *)memmem(\"foo\", 4, \"o\", 1);\n\tif (strcmp(s, \"oo\") != 0) {\n\t\tprintf(__location__ \": Failed memmem\\n\");\n\t\treturn false;\n\t}\n\n\ts = (char *)memmem(\"foobarfodx\", 11, \"fod\", 3);\n\tif (strcmp(s, \"fodx\") != 0) {\n\t\tprintf(__location__ \": Failed memmem\\n\");\n\t\treturn false;\n\t}\n\n\tprintf(\"success: memmem\\n\");\n\n\treturn true;\n}\n\nstatic bool test_closefrom(void)\n{\n\tint i, fd;\n\n\tfor (i=0; i<100; i++) {\n\t\tfd = dup(0);\n\t\tif (fd == -1) {\n\t\t\tperror(\"dup failed\");\n\t\t\treturn false;\n\t\t}\n\n\t\t/* 1000 is just an arbitrarily chosen upper bound */\n\n\t\tif (fd >= 1000) {\n\t\t\tprintf(\"fd=%d\\n\", fd);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tclosefrom(3);\n\n\tfor (i=3; i<=fd; i++) {\n\t\toff_t off;\n\t\toff = lseek(i, 0, SEEK_CUR);\n\t\tif ((off != (off_t)-1) || (errno != EBADF)) {\n\t\t\tprintf(\"fd %d not closed\\n\", i);\n\t\t\treturn false;\n\t\t}\n\t}\n\n\treturn true;\n}\n\nbool torture_local_replace(struct torture_context *ctx)\n{\n\tbool ret = true;\n\tret &= test_ftruncate();\n\tret &= test_strlcpy();\n\tret &= test_strlcat();\n\tret &= test_mktime();\n\tret &= test_initgroups();\n\tret &= test_memmove();\n\tret &= test_strdup();\n\tret &= test_setlinebuf();\n\tret &= test_vsyslog();\n\tret &= test_timegm();\n\tret &= test_setenv();\n\tret &= test_strndup();\n\tret &= test_strnlen();\n\tret &= test_waitpid();\n\tret &= test_seteuid();\n\tret &= test_setegid();\n\tret &= test_asprintf();\n\tret &= test_snprintf();\n\tret &= test_vasprintf();\n\tret &= test_vsnprintf();\n\tret &= test_opendir();\n\tret &= test_readdir();\n\tret &= test_telldir();\n\tret &= test_seekdir();\n\tret &= test_dlopen();\n\tret &= test_chroot();\n\tret &= test_bzero();\n\tret &= test_strerror();\n\tret &= test_errno();\n\tret &= test_mkdtemp();\n\tret &= test_mkstemp();\n\tret &= test_pread();\n\tret &= test_pwrite();\n\tret &= test_inet_ntoa();\n\tret &= test_strtoll();\n\tret &= test_strtoull();\n\tret &= test_va_copy();\n\tret &= test_FUNCTION();\n\tret &= test_MIN();\n\tret &= test_MAX();\n\tret &= test_socketpair();\n\tret &= test_strptime();\n\tret &= test_getifaddrs();\n\tret &= test_utime();\n\tret &= test_utimes();\n\tret &= test_memmem();\n\tret &= test_closefrom();\n\n\treturn ret;\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-talloc-2.1.9-mym4vb4o7y2j237svrlauyjwjdr6fn6r/spack-src/lib/replace/timegm.c",
        "/tmp/vanessa/spack-stage/spack-stage-talloc-2.1.9-mym4vb4o7y2j237svrlauyjwjdr6fn6r/spack-src/doc/context.png",
        "/tmp/vanessa/spack-stage/spack-stage-talloc-2.1.9-mym4vb4o7y2j237svrlauyjwjdr6fn6r/spack-src/doc/stealing.png",
        "/tmp/vanessa/spack-stage/spack-stage-talloc-2.1.9-mym4vb4o7y2j237svrlauyjwjdr6fn6r/spack-src/doc/context_tree.png"
    ],
    "total_files": 246
}