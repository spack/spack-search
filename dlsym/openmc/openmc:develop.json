{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/src/source.cpp": "#include \"openmc/source.h\"\n\n#if defined (__unix__) || (defined (__APPLE__) && defined (__MACH__))\n#define HAS_DYNAMIC_LINKING\n#endif\n\n#include <algorithm> // for move\n#include <memory> // for unique_ptr\n\n#ifdef HAS_DYNAMIC_LINKING\n#include <dlfcn.h> // for dlopen, dlsym, dlclose, dlerror\n#endif\n\n#include <fmt/core.h>\n#include \"xtensor/xadapt.hpp\"\n\n#include \"openmc/bank.h\"\n#include \"openmc/cell.h\"\n#include \"openmc/error.h\"\n#include \"openmc/file_utils.h\"\n#include \"openmc/hdf5_interface.h\"\n#include \"openmc/material.h\"\n#include \"openmc/message_passing.h\"\n#include \"openmc/mgxs_interface.h\"\n#include \"openmc/nuclide.h\"\n#include \"openmc/capi.h\"\n#include \"openmc/random_lcg.h\"\n#include \"openmc/search.h\"\n#include \"openmc/settings.h\"\n#include \"openmc/simulation.h\"\n#include \"openmc/state_point.h\"\n#include \"openmc/xml_interface.h\"\n\nnamespace openmc {\n\n//==============================================================================\n// Global variables\n//==============================================================================\n\nnamespace model {\n\nstd::vector<std::unique_ptr<Source>> external_sources;\n\n}\n\n//==============================================================================\n// IndependentSource implementation\n//==============================================================================\n\nIndependentSource::IndependentSource(UPtrSpace space, UPtrAngle angle, UPtrDist energy)\n  : space_{std::move(space)}, angle_{std::move(angle)}, energy_{std::move(energy)} { }\n\nIndependentSource::IndependentSource(pugi::xml_node node)\n{\n  // Check for particle type\n  if (check_for_node(node, \"particle\")) {\n    auto temp_str = get_node_value(node, \"particle\", true, true);\n    if (temp_str == \"neutron\") {\n      particle_ = Particle::Type::neutron;\n    } else if (temp_str == \"photon\") {\n      particle_ = Particle::Type::photon;\n      settings::photon_transport = true;\n    } else {\n      fatal_error(std::string(\"Unknown source particle type: \") + temp_str);\n    }\n  }\n\n  // Check for source strength\n  if (check_for_node(node, \"strength\")) {\n    strength_ = std::stod(get_node_value(node, \"strength\"));\n  }\n\n  // Check for external source file\n  if (check_for_node(node, \"file\")) {\n\n  } else {\n\n    // Spatial distribution for external source\n    if (check_for_node(node, \"space\")) {\n      // Get pointer to spatial distribution\n      pugi::xml_node node_space = node.child(\"space\");\n\n      // Check for type of spatial distribution and read\n      std::string type;\n      if (check_for_node(node_space, \"type\"))\n        type = get_node_value(node_space, \"type\", true, true);\n      if (type == \"cartesian\") {\n        space_ = UPtrSpace{new CartesianIndependent(node_space)};\n      } else if (type == \"cylindrical\") {\n        space_ = UPtrSpace{new CylindricalIndependent(node_space)};\n      } else if (type == \"spherical\") {\n        space_ = UPtrSpace{new SphericalIndependent(node_space)};\n      } else if (type == \"box\") {\n        space_ = UPtrSpace{new SpatialBox(node_space)};\n      } else if (type == \"fission\") {\n        space_ = UPtrSpace{new SpatialBox(node_space, true)};\n      } else if (type == \"point\") {\n        space_ = UPtrSpace{new SpatialPoint(node_space)};\n      } else {\n        fatal_error(fmt::format(\n          \"Invalid spatial distribution for external source: {}\", type));\n      }\n\n    } else {\n      // If no spatial distribution specified, make it a point source\n      space_ = UPtrSpace{new SpatialPoint()};\n    }\n\n    // Determine external source angular distribution\n    if (check_for_node(node, \"angle\")) {\n      // Get pointer to angular distribution\n      pugi::xml_node node_angle = node.child(\"angle\");\n\n      // Check for type of angular distribution\n      std::string type;\n      if (check_for_node(node_angle, \"type\"))\n        type = get_node_value(node_angle, \"type\", true, true);\n      if (type == \"isotropic\") {\n        angle_ = UPtrAngle{new Isotropic()};\n      } else if (type == \"monodirectional\") {\n        angle_ = UPtrAngle{new Monodirectional(node_angle)};\n      } else if (type == \"mu-phi\") {\n        angle_ = UPtrAngle{new PolarAzimuthal(node_angle)};\n      } else {\n        fatal_error(fmt::format(\n          \"Invalid angular distribution for external source: {}\", type));\n      }\n\n    } else {\n      angle_ = UPtrAngle{new Isotropic()};\n    }\n\n    // Determine external source energy distribution\n    if (check_for_node(node, \"energy\")) {\n      pugi::xml_node node_dist = node.child(\"energy\");\n      energy_ = distribution_from_xml(node_dist);\n    } else {\n      // Default to a Watt spectrum with parameters 0.988 MeV and 2.249 MeV^-1\n      energy_ = UPtrDist{new Watt(0.988e6, 2.249e-6)};\n    }\n  }\n}\n\nParticle::Bank IndependentSource::sample(uint64_t* seed) const\n{\n  Particle::Bank site;\n\n  // Set weight to one by default\n  site.wgt = 1.0;\n\n  // Repeat sampling source location until a good site has been found\n  bool found = false;\n  int n_reject = 0;\n  static int n_accept = 0;\n  while (!found) {\n    // Set particle type\n    site.particle = particle_;\n\n    // Sample spatial distribution\n    site.r = space_->sample(seed);\n\n    // Now search to see if location exists in geometry\n    int32_t cell_index, instance;\n    double xyz[] {site.r.x, site.r.y, site.r.z};\n    int err = openmc_find_cell(xyz, &cell_index, &instance);\n    found = (err != OPENMC_E_GEOMETRY);\n\n    // Check if spatial site is in fissionable material\n    if (found) {\n      auto space_box = dynamic_cast<SpatialBox*>(space_.get());\n      if (space_box) {\n        if (space_box->only_fissionable()) {\n          // Determine material\n          const auto& c = model::cells[cell_index];\n          auto mat_index = c->material_.size() == 1\n            ? c->material_[0] : c->material_[instance];\n\n          if (mat_index == MATERIAL_VOID) {\n            found = false;\n          } else {\n            if (!model::materials[mat_index]->fissionable_) found = false;\n          }\n        }\n      }\n    }\n\n    // Check for rejection\n    if (!found) {\n      ++n_reject;\n      if (n_reject >= EXTSRC_REJECT_THRESHOLD &&\n          static_cast<double>(n_accept)/n_reject <= EXTSRC_REJECT_FRACTION) {\n        fatal_error(\"More than 95% of external source sites sampled were \"\n                    \"rejected. Please check your external source definition.\");\n      }\n    }\n  }\n\n  // Increment number of accepted samples\n  ++n_accept;\n\n  // Sample angle\n  site.u = angle_->sample(seed);\n\n  // Check for monoenergetic source above maximum particle energy\n  auto p = static_cast<int>(particle_);\n  auto energy_ptr = dynamic_cast<Discrete*>(energy_.get());\n  if (energy_ptr) {\n    auto energies = xt::adapt(energy_ptr->x());\n    if (xt::any(energies > data::energy_max[p])) {\n      fatal_error(\"Source energy above range of energies of at least \"\n                  \"one cross section table\");\n    } else if (xt::any(energies < data::energy_min[p])) {\n      fatal_error(\"Source energy below range of energies of at least \"\n                  \"one cross section table\");\n    }\n  }\n\n  while (true) {\n    // Sample energy spectrum\n    site.E = energy_->sample(seed);\n\n    // Resample if energy falls outside minimum or maximum particle energy\n    if (site.E < data::energy_max[p] && site.E > data::energy_min[p]) break;\n  }\n\n  // Set delayed group\n  site.delayed_group = 0;\n  // Set surface ID\n  site.surf_id = 0;\n\n  return site;\n}\n\n//==============================================================================\n// FileSource implementation\n//==============================================================================\n\nFileSource::FileSource(std::string path)\n{\n  // Check if source file exists\n  if (!file_exists(path)) {\n    fatal_error(fmt::format(\"Source file '{}' does not exist.\", path));\n  }\n\n  // Read the source from a binary file instead of sampling from some\n  // assumed source distribution\n  write_message(6, \"Reading source file from {}...\", path);\n\n  // Open the binary file\n  hid_t file_id = file_open(path, 'r', true);\n\n  // Check to make sure this is a source file\n  std::string filetype;\n  read_attribute(file_id, \"filetype\", filetype);\n  if (filetype != \"source\" && filetype != \"statepoint\") {\n    fatal_error(\"Specified starting source file not a source file type.\");\n  }\n\n  // Read in the source particles\n  read_source_bank(file_id, sites_, false);\n\n  // Close file\n  file_close(file_id);\n}\n\nParticle::Bank FileSource::sample(uint64_t* seed) const\n{\n  size_t i_site = sites_.size()*prn(seed);\n  return sites_[i_site];\n}\n\n//==============================================================================\n// CustomSourceWrapper implementation\n//==============================================================================\n\nCustomSourceWrapper::CustomSourceWrapper(std::string path, std::string parameters)\n{\n#ifdef HAS_DYNAMIC_LINKING\n  // Open the library\n  shared_library_ = dlopen(path.c_str(), RTLD_LAZY);\n  if (!shared_library_) {\n    fatal_error(\"Couldn't open source library \" + path);\n  }\n\n  // reset errors\n  dlerror();\n\n  // get the function to create the custom source from the library\n  auto create_custom_source = reinterpret_cast<create_custom_source_t*>(\n    dlsym(shared_library_, \"openmc_create_source\"));\n\n  // check for any dlsym errors\n  auto dlsym_error = dlerror();\n  if (dlsym_error) {\n    std::string error_msg = fmt::format(\"Couldn't open the openmc_create_source symbol: {}\", dlsym_error);\n    dlclose(shared_library_);\n    fatal_error(error_msg);\n  }\n\n  // create a pointer to an instance of the custom source\n  custom_source_ = create_custom_source(parameters);\n\n#else\n  fatal_error(\"Custom source libraries have not yet been implemented for \"\n    \"non-POSIX systems\");\n#endif\n}\n\nCustomSourceWrapper::~CustomSourceWrapper()\n{\n  // Make sure custom source is cleared before closing shared library\n  if (custom_source_.get()) custom_source_.reset();\n\n#ifdef HAS_DYNAMIC_LINKING\n  dlclose(shared_library_);\n#else\n  fatal_error(\"Custom source libraries have not yet been implemented for \"\n              \"non-POSIX systems\");\n#endif\n}\n\n//==============================================================================\n// Non-member functions\n//==============================================================================\n\nvoid initialize_source()\n{\n  write_message(\"Initializing source particles...\", 5);\n\n  // Generation source sites from specified distribution in user input\n  #pragma omp parallel for\n  for (int64_t i = 0; i < simulation::work_per_rank; ++i) {\n    // initialize random number seed\n    int64_t id = simulation::total_gen*settings::n_particles +\n      simulation::work_index[mpi::rank] + i + 1;\n    uint64_t seed = init_seed(id, STREAM_SOURCE);\n\n    // sample external source distribution\n    simulation::source_bank[i] = sample_external_source(&seed);\n  }\n\n  // Write out initial source\n  if (settings::write_initial_source) {\n    write_message(\"Writing out initial source...\", 5);\n    std::string filename = settings::path_output + \"initial_source.h5\";\n    hid_t file_id = file_open(filename, 'w', true);\n    write_source_bank(file_id, false);\n    file_close(file_id);\n  }\n}\n\nParticle::Bank sample_external_source(uint64_t* seed)\n{\n  // Determine total source strength\n  double total_strength = 0.0;\n  for (auto& s : model::external_sources)\n    total_strength += s->strength();\n\n  // Sample from among multiple source distributions\n  int i = 0;\n  if (model::external_sources.size() > 1) {\n    double xi = prn(seed)*total_strength;\n    double c = 0.0;\n    for (; i < model::external_sources.size(); ++i) {\n      c += model::external_sources[i]->strength();\n      if (xi < c) break;\n    }\n  }\n\n  // Sample source site from i-th source distribution\n  Particle::Bank site {model::external_sources[i]->sample(seed)};\n\n  // If running in MG, convert site.E to group\n  if (!settings::run_CE) {\n    site.E = lower_bound_index(data::mg.rev_energy_bins_.begin(),\n      data::mg.rev_energy_bins_.end(), site.E);\n    site.E = data::mg.num_energy_groups_ - site.E - 1.;\n  }\n\n  return site;\n}\n\nvoid free_memory_source()\n{\n  model::external_sources.clear();\n}\n\n} // namespace openmc\n",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/tests/regression_tests/source_parameterized_dlopen/parameterized_source_sampling.cpp": "#include \"openmc/source.h\"\n#include \"openmc/particle.h\"\n\nclass CustomSource : public openmc::Source {\n  public:\n    CustomSource(double energy) : energy_(energy) { }\n\n    // Samples from an instance of this class.\n    openmc::Particle::Bank sample(uint64_t* seed) const\n    {\n      openmc::Particle::Bank particle;\n      // wgt\n      particle.particle = openmc::Particle::Type::neutron;\n      particle.wgt = 1.0;\n      // position\n      particle.r.x = 0.0;\n      particle.r.y = 0.0;\n      particle.r.z = 0.0;\n      // angle\n      particle.u = {1.0, 0.0, 0.0};\n      particle.E = this->energy_;\n      particle.delayed_group = 0;\n\n      return particle;\n    }\n\n  private:\n    double energy_;\n};\n\n// A function to create a unique pointer to an instance of this class when generated\n// via a plugin call using dlopen/dlsym.\n// You must have external C linkage here otherwise dlopen will not find the file\nextern \"C\" std::unique_ptr<CustomSource> openmc_create_source(std::string parameter)\n{\n  double energy = std::stod(parameter);\n  return std::make_unique<CustomSource>(energy);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/tests/regression_tests/source_dlopen/source_sampling.cpp": "#include <iostream>\n#include <memory>\n\n#include \"openmc/random_lcg.h\"\n#include \"openmc/source.h\"\n#include \"openmc/particle.h\"\n\nclass CustomSource : public openmc::Source\n{\n  openmc::Particle::Bank sample(uint64_t *seed) const\n  {\n    openmc::Particle::Bank particle;\n    // wgt\n    particle.particle = openmc::Particle::Type::neutron;\n    particle.wgt = 1.0;\n    // position\n\n    particle.r.x = 0.;\n    particle.r.y = 0.;\n    particle.r.z = 0.;\n    // angle\n    particle.u = {1.0, 0.0, 0.0};\n    particle.E = 14.08e6;\n    particle.delayed_group = 0;\n    return particle;\n  }\n};\n\n// A function to create a unique pointer to an instance of this class when generated\n// via a plugin call using dlopen/dlsym.\n// You must have external C linkage here otherwise dlopen will not find the file\nextern \"C\" std::unique_ptr<CustomSource> openmc_create_source(std::string parameters)\n{\n  return std::make_unique<CustomSource>();\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/examples/custom_source/source_ring.cpp": "#include <cmath> // for M_PI\n#include <memory> // for unique_ptr\n\n#include \"openmc/random_lcg.h\"\n#include \"openmc/source.h\"\n#include \"openmc/particle.h\"\n\nclass RingSource : public openmc::Source\n{\n  openmc::Particle::Bank sample(uint64_t* seed) const\n  {\n    openmc::Particle::Bank particle;\n    // wgt\n    particle.particle = openmc::Particle::Type::neutron;\n    particle.wgt = 1.0;\n    // position\n    double angle = 2.0 * M_PI * openmc::prn(seed);\n    double radius = 3.0;\n    particle.r.x = radius * std::cos(angle);\n    particle.r.y = radius * std::sin(angle);\n    particle.r.z = 0.0;\n    // angle\n    particle.u = {1.0, 0.0, 0.0};\n    particle.E = 14.08e6;\n    particle.delayed_group = 0;\n    return particle;\n  }\n};\n\n// A function to create a unique pointer to an instance of this class when generated\n// via a plugin call using dlopen/dlsym.\n// You must have external C linkage here otherwise dlopen will not find the file\nextern \"C\" std::unique_ptr<RingSource> openmc_create_source(std::string parameters)\n{\n  return std::make_unique<RingSource>();\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/examples/parameterized_custom_source/parameterized_source_ring.cpp": "#include <cmath> // for M_PI\n#include <memory> // for unique_ptr\n#include <unordered_map>\n\n#include \"openmc/random_lcg.h\"\n#include \"openmc/source.h\"\n#include \"openmc/particle.h\"\n\nclass RingSource : public openmc::Source {\n  public:\n    RingSource(double radius, double energy) : radius_(radius), energy_(energy) { }\n\n    // Defines a function that can create a unique pointer to a new instance of this class\n    // by extracting the parameters from the provided string.\n    static std::unique_ptr<RingSource> from_string(std::string parameters)\n    {\n      std::unordered_map<std::string, std::string> parameter_mapping;\n\n      std::stringstream ss(parameters);\n      std::string parameter;\n      while (std::getline(ss, parameter, ',')) {\n        parameter.erase(0, parameter.find_first_not_of(' '));\n        std::string key = parameter.substr(0, parameter.find_first_of('='));\n        std::string value = parameter.substr(parameter.find_first_of('=') + 1, parameter.length());\n        parameter_mapping[key] = value;\n      }\n\n      double radius = std::stod(parameter_mapping[\"radius\"]);\n      double energy = std::stod(parameter_mapping[\"energy\"]);\n      return std::make_unique<RingSource>(radius, energy);\n    }\n\n    // Samples from an instance of this class.\n    openmc::Particle::Bank sample(uint64_t* seed) const\n    {\n      openmc::Particle::Bank particle;\n      // wgt\n      particle.particle = openmc::Particle::Type::neutron;\n      particle.wgt = 1.0;\n      // position\n      double angle = 2.0 * M_PI * openmc::prn(seed);\n      double radius = this->radius_;\n      particle.r.x = radius * std::cos(angle);\n      particle.r.y = radius * std::sin(angle);\n      particle.r.z = 0.0;\n      // angle\n      particle.u = {1.0, 0.0, 0.0};\n      particle.E = this->energy_;\n      particle.delayed_group = 0;\n\n      return particle;\n    }\n\n  private:\n    double radius_;\n    double energy_;\n};\n\n// A function to create a unique pointer to an instance of this class when generated\n// via a plugin call using dlopen/dlsym.\n// You must have external C linkage here otherwise dlopen will not find the file\nextern \"C\" std::unique_ptr<RingSource> openmc_create_source(std::string parameters)\n{\n  return RingSource::from_string(parameters);\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/openmc/data/density_effect.h5",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/openmc/data/compton_profiles.h5",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/.git/objects/pack/pack-d96fd578de5c3f22e04642c53e58fc837f4aa07b.pack",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/.git/objects/pack/pack-d96fd578de5c3f22e04642c53e58fc837f4aa07b.idx",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/.git/modules/vendor/xtensor/objects/pack/pack-a90075b4d5ae59d249b9f3cd400ccf9276936c45.pack",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/.git/modules/vendor/xtensor/objects/pack/pack-a90075b4d5ae59d249b9f3cd400ccf9276936c45.idx",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/.git/modules/vendor/gsl-lite/objects/pack/pack-bef735dc20d0808cc91f65e6ad2830341006381d.idx",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/.git/modules/vendor/gsl-lite/objects/pack/pack-bef735dc20d0808cc91f65e6ad2830341006381d.pack",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/.git/modules/vendor/pugixml/objects/pack/pack-e0cc4f2d17e9c273b0761da5683b404ae9039e98.idx",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/.git/modules/vendor/pugixml/objects/pack/pack-e0cc4f2d17e9c273b0761da5683b404ae9039e98.pack",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/.git/modules/vendor/xtl/objects/pack/pack-403a120267d82e14487dfcf090f76b0e5cbe4531.pack",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/.git/modules/vendor/xtl/objects/pack/pack-403a120267d82e14487dfcf090f76b0e5cbe4531.idx",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/.git/modules/vendor/fmt/objects/pack/pack-d433fbf10dc09f126f746cdbcf6ef5b95ad6dae6.idx",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/.git/modules/vendor/fmt/objects/pack/pack-d433fbf10dc09f126f746cdbcf6ef5b95ad6dae6.pack",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/tests/unit_tests/dagmc/dagmc.h5m",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/tests/regression_tests/surface_source/surface_source_true.h5",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/tests/regression_tests/unstructured_mesh/test_mesh_tets.h5m",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/tests/regression_tests/unstructured_mesh/test_mesh_tets_w_holes.h5m",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/tests/regression_tests/deplete/test_reference.h5",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/tests/regression_tests/dagmc/legacy/dagmc.h5m",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/tests/regression_tests/dagmc/uwuw/dagmc.h5m",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/tests/regression_tests/dagmc/refl/dagmc.h5m",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/vendor/xtensor/notebooks/images/xtensor.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/vendor/xtensor/notebooks/images/xtensor-blas.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/vendor/xtensor/test/files/xnpy_files/double_fortran.npy",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/vendor/xtensor/test/files/xnpy_files/unsignedlong_fortran.npy",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/vendor/xtensor/test/files/xnpy_files/bool_fortran.npy",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/vendor/xtensor/test/files/xnpy_files/unsignedlong.npy",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/vendor/xtensor/test/files/xnpy_files/int.npy",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/vendor/xtensor/test/files/xnpy_files/double.npy",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/vendor/xtensor/test/files/xnpy_files/bool.npy",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/vendor/xtensor/docs/source/xeus-cling-screenshot.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/vendor/pugixml/tests/data/utftest_utf16_be_clean.xml",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/vendor/pugixml/tests/data/utftest_utf32_be.xml",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/vendor/pugixml/tests/data/utftest_utf32_be_nodecl.xml",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/vendor/pugixml/tests/data/utftest_utf16_le_clean.xml",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/vendor/pugixml/tests/data/utftest_utf16_be.xml",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/vendor/pugixml/tests/data/utftest_utf32_le_bom.xml",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/vendor/pugixml/tests/data/utftest_utf32_be_clean.xml",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/vendor/pugixml/tests/data/utftest_utf32_le.xml",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/vendor/pugixml/tests/data/utftest_utf16_le_bom.xml",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/vendor/pugixml/tests/data/utftest_utf32_le_nodecl.xml",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/vendor/pugixml/tests/data/utftest_utf16_le.xml",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/vendor/pugixml/tests/data/utftest_utf32_be_bom.xml",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/vendor/pugixml/tests/data/utftest_utf32_le_clean.xml",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/vendor/pugixml/tests/data/utftest_utf16_le_nodecl.xml",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/vendor/pugixml/tests/data/utftest_utf16_be_bom.xml",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/vendor/pugixml/tests/data/latintest_latin1.xml",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/vendor/pugixml/tests/data/utftest_utf16_be_nodecl.xml",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/vendor/pugixml/tests/data_fuzz_parse/utf32.xml",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/vendor/pugixml/tests/data_fuzz_parse/utf16.xml",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/vendor/pugixml/docs/images/dom_tree.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/vendor/pugixml/docs/images/vs2010_link1.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/vendor/pugixml/docs/images/vs2005_pch2.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/vendor/pugixml/docs/images/vs2010_link2.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/vendor/pugixml/docs/images/vs2005_link2.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/vendor/pugixml/docs/images/vs2005_pch3.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/vendor/pugixml/docs/images/vs2005_pch4.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/vendor/pugixml/docs/images/vs2005_pch1.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/vendor/pugixml/docs/images/vs2005_link1.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/vendor/pugixml/docs/samples/weekly-utf-16.xml",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/vendor/pugixml/docs/samples/weekly-shift_jis.xml",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/vendor/fmt/doc/_static/fonts/glyphicons-halflings-regular.woff",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/vendor/fmt/doc/_static/fonts/glyphicons-halflings-regular.eot",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/vendor/fmt/doc/_static/fonts/glyphicons-halflings-regular.ttf",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/examples/jupyter/c5g7.h5",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/examples/jupyter/images/pin_mesh.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/examples/jupyter/images/teapot.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/examples/jupyter/images/manifold_flux.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/examples/jupyter/images/umesh_flux.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/examples/jupyter/images/mgxs.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/examples/jupyter/images/flux3d.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/examples/jupyter/images/mdgxs.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/examples/jupyter/images/manifold-cad.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/examples/jupyter/images/manifold_pnt_cld.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/examples/jupyter/images/umesh_w_assembly.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/examples/jupyter/images/umesh_heating.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/examples/jupyter/images/cylinder_mesh.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/docs/source/_images/cosine-dist.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/docs/source/_images/fork.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/docs/source/_images/plotmeshtally.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/docs/source/_images/fluxplot.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/docs/source/_images/master-slave.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/docs/source/_images/3dba.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/docs/source/_images/meshfig.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/docs/source/_images/loss.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/docs/source/_images/atr.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/docs/source/_images/cmfd_flow.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/docs/source/_images/nearest-neighbor.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/docs/source/_images/prod.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/docs/source/_images/nearest-neighbor-example.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/docs/source/_images/openmc_logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/docs/source/_images/3dcore.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/docs/source/_images/3dgeomplot.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/docs/source/_images/Tracks.png",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/docs/diagrams/overview.dia",
        "/tmp/vanessa/spack-stage/spack-stage-openmc-develop-tw3vx7zvxkcrlmcduhd5zmooxvd5xyns/spack-src/docs/diagrams/cross_sections.dia"
    ],
    "total_files": 2160
}