{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-r-httpuv-1.3.5-cikecoc4mugza3oedeesvrguhboosz33/spack-src/src/libuv/src/win/dl.c": "/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#include \"uv.h\"\n#include \"internal.h\"\n\nstatic int uv__dlerror(uv_lib_t* lib, int errorno);\n\n\nint uv_dlopen(const char* filename, uv_lib_t* lib) {\n  WCHAR filename_w[32768];\n\n  lib->handle = NULL;\n  lib->errmsg = NULL;\n\n  if (!uv_utf8_to_utf16(filename, filename_w, ARRAY_SIZE(filename_w))) {\n    return uv__dlerror(lib, GetLastError());\n  }\n\n  lib->handle = LoadLibraryExW(filename_w, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);\n  if (lib->handle == NULL) {\n    return uv__dlerror(lib, GetLastError());\n  }\n\n  return 0;\n}\n\n\nvoid uv_dlclose(uv_lib_t* lib) {\n  if (lib->errmsg) {\n    LocalFree((void*)lib->errmsg);\n    lib->errmsg = NULL;\n  }\n\n  if (lib->handle) {\n    /* Ignore errors. No good way to signal them without leaking memory. */\n    FreeLibrary(lib->handle);\n    lib->handle = NULL;\n  }\n}\n\n\nint uv_dlsym(uv_lib_t* lib, const char* name, void** ptr) {\n  *ptr = (void*) GetProcAddress(lib->handle, name);\n  return uv__dlerror(lib, *ptr ? 0 : GetLastError());\n}\n\n\nconst char* uv_dlerror(uv_lib_t* lib) {\n  return lib->errmsg ? lib->errmsg : \"no error\";\n}\n\n\nstatic int uv__dlerror(uv_lib_t* lib, int errorno) {\n  if (lib->errmsg) {\n    LocalFree((void*)lib->errmsg);\n    lib->errmsg = NULL;\n  }\n\n  if (errorno) {\n    FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM |\n                   FORMAT_MESSAGE_IGNORE_INSERTS, NULL, errorno,\n                   MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),\n                   (LPSTR)&lib->errmsg, 0, NULL);\n  }\n\n  return errorno ? -1 : 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-r-httpuv-1.3.5-cikecoc4mugza3oedeesvrguhboosz33/spack-src/src/libuv/src/unix/dl.c": "/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#include \"uv.h\"\n#include \"internal.h\"\n\n#include <dlfcn.h>\n#include <errno.h>\n#include <string.h>\n#include <locale.h>\n\nstatic int uv__dlerror(uv_lib_t* lib);\n\n\nint uv_dlopen(const char* filename, uv_lib_t* lib) {\n  dlerror(); /* Reset error status. */\n  lib->errmsg = NULL;\n  lib->handle = dlopen(filename, RTLD_LAZY);\n  return lib->handle ? 0 : uv__dlerror(lib);\n}\n\n\nvoid uv_dlclose(uv_lib_t* lib) {\n  if (lib->errmsg) {\n    free(lib->errmsg);\n    lib->errmsg = NULL;\n  }\n\n  if (lib->handle) {\n    /* Ignore errors. No good way to signal them without leaking memory. */\n    dlclose(lib->handle);\n    lib->handle = NULL;\n  }\n}\n\n\nint uv_dlsym(uv_lib_t* lib, const char* name, void** ptr) {\n  dlerror(); /* Reset error status. */\n  *ptr = dlsym(lib->handle, name);\n  return uv__dlerror(lib);\n}\n\n\nconst char* uv_dlerror(uv_lib_t* lib) {\n  return lib->errmsg ? lib->errmsg : \"no error\";\n}\n\n\nstatic int uv__dlerror(uv_lib_t* lib) {\n  char* errmsg;\n\n  if (lib->errmsg)\n    free(lib->errmsg);\n\n  errmsg = dlerror();\n\n  if (errmsg) {\n    lib->errmsg = strdup(errmsg);\n    return -1;\n  }\n  else {\n    lib->errmsg = NULL;\n    return 0;\n  }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-r-httpuv-1.3.5-cikecoc4mugza3oedeesvrguhboosz33/spack-src/src/libuv/include/uv.h": "/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n/* See http://nikhilm.github.com/uvbook/ for an introduction. */\n\n#ifndef UV_H\n#define UV_H\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifdef _WIN32\n  /* Windows - set up dll import/export decorators. */\n# if defined(BUILDING_UV_SHARED)\n    /* Building shared library. */\n#   define UV_EXTERN __declspec(dllexport)\n# elif defined(USING_UV_SHARED)\n    /* Using shared library. */\n#   define UV_EXTERN __declspec(dllimport)\n# else\n    /* Building static library. */\n#   define UV_EXTERN /* nothing */\n# endif\n#elif __GNUC__ >= 4\n# define UV_EXTERN __attribute__((visibility(\"default\")))\n#else\n# define UV_EXTERN /* nothing */\n#endif\n\n\n#define UV_VERSION_MAJOR 0\n#define UV_VERSION_MINOR 10\n\n\n#if defined(_MSC_VER) && _MSC_VER < 1600\n# include \"uv-private/stdint-msvc2008.h\"\n#else\n# include <stdint.h>\n#endif\n\n#include <sys/types.h> /* size_t */\n\n#if defined(__SVR4) && !defined(__unix__)\n# define __unix__\n#endif\n\n#if defined(__unix__) || defined(__POSIX__) || \\\n    defined(__APPLE__) || defined(_AIX)\n# include \"uv-private/uv-unix.h\"\n#else\n# include \"uv-private/uv-win.h\"\n#endif\n\n/* Expand this list if necessary. */\n#define UV_ERRNO_MAP(XX)                                                      \\\n  XX( -1, UNKNOWN, \"unknown error\")                                           \\\n  XX(  0, OK, \"success\")                                                      \\\n  XX(  1, EOF, \"end of file\")                                                 \\\n  XX(  2, EADDRINFO, \"getaddrinfo error\")                                     \\\n  XX(  3, EACCES, \"permission denied\")                                        \\\n  XX(  4, EAGAIN, \"resource temporarily unavailable\")                         \\\n  XX(  5, EADDRINUSE, \"address already in use\")                               \\\n  XX(  6, EADDRNOTAVAIL, \"address not available\")                             \\\n  XX(  7, EAFNOSUPPORT, \"address family not supported\")                       \\\n  XX(  8, EALREADY, \"connection already in progress\")                         \\\n  XX(  9, EBADF, \"bad file descriptor\")                                       \\\n  XX( 10, EBUSY, \"resource busy or locked\")                                   \\\n  XX( 11, ECONNABORTED, \"software caused connection abort\")                   \\\n  XX( 12, ECONNREFUSED, \"connection refused\")                                 \\\n  XX( 13, ECONNRESET, \"connection reset by peer\")                             \\\n  XX( 14, EDESTADDRREQ, \"destination address required\")                       \\\n  XX( 15, EFAULT, \"bad address in system call argument\")                      \\\n  XX( 16, EHOSTUNREACH, \"host is unreachable\")                                \\\n  XX( 17, EINTR, \"interrupted system call\")                                   \\\n  XX( 18, EINVAL, \"invalid argument\")                                         \\\n  XX( 19, EISCONN, \"socket is already connected\")                             \\\n  XX( 20, EMFILE, \"too many open files\")                                      \\\n  XX( 21, EMSGSIZE, \"message too long\")                                       \\\n  XX( 22, ENETDOWN, \"network is down\")                                        \\\n  XX( 23, ENETUNREACH, \"network is unreachable\")                              \\\n  XX( 24, ENFILE, \"file table overflow\")                                      \\\n  XX( 25, ENOBUFS, \"no buffer space available\")                               \\\n  XX( 26, ENOMEM, \"not enough memory\")                                        \\\n  XX( 27, ENOTDIR, \"not a directory\")                                         \\\n  XX( 28, EISDIR, \"illegal operation on a directory\")                         \\\n  XX( 29, ENONET, \"machine is not on the network\")                            \\\n  XX( 31, ENOTCONN, \"socket is not connected\")                                \\\n  XX( 32, ENOTSOCK, \"socket operation on non-socket\")                         \\\n  XX( 33, ENOTSUP, \"operation not supported on socket\")                       \\\n  XX( 34, ENOENT, \"no such file or directory\")                                \\\n  XX( 35, ENOSYS, \"function not implemented\")                                 \\\n  XX( 36, EPIPE, \"broken pipe\")                                               \\\n  XX( 37, EPROTO, \"protocol error\")                                           \\\n  XX( 38, EPROTONOSUPPORT, \"protocol not supported\")                          \\\n  XX( 39, EPROTOTYPE, \"protocol wrong type for socket\")                       \\\n  XX( 40, ETIMEDOUT, \"connection timed out\")                                  \\\n  XX( 41, ECHARSET, \"invalid Unicode character\")                              \\\n  XX( 42, EAIFAMNOSUPPORT, \"address family for hostname not supported\")       \\\n  XX( 44, EAISERVICE, \"servname not supported for ai_socktype\")               \\\n  XX( 45, EAISOCKTYPE, \"ai_socktype not supported\")                           \\\n  XX( 46, ESHUTDOWN, \"cannot send after transport endpoint shutdown\")         \\\n  XX( 47, EEXIST, \"file already exists\")                                      \\\n  XX( 48, ESRCH, \"no such process\")                                           \\\n  XX( 49, ENAMETOOLONG, \"name too long\")                                      \\\n  XX( 50, EPERM, \"operation not permitted\")                                   \\\n  XX( 51, ELOOP, \"too many symbolic links encountered\")                       \\\n  XX( 52, EXDEV, \"cross-device link not permitted\")                           \\\n  XX( 53, ENOTEMPTY, \"directory not empty\")                                   \\\n  XX( 54, ENOSPC, \"no space left on device\")                                  \\\n  XX( 55, EIO, \"i/o error\")                                                   \\\n  XX( 56, EROFS, \"read-only file system\")                                     \\\n  XX( 57, ENODEV, \"no such device\")                                           \\\n  XX( 58, ESPIPE, \"invalid seek\")                                             \\\n  XX( 59, ECANCELED, \"operation canceled\")                                    \\\n\n\n#define UV_ERRNO_GEN(val, name, s) UV_##name = val,\ntypedef enum {\n  UV_ERRNO_MAP(UV_ERRNO_GEN)\n  UV_MAX_ERRORS\n} uv_err_code;\n#undef UV_ERRNO_GEN\n\n#define UV_HANDLE_TYPE_MAP(XX)                                                \\\n  XX(ASYNC, async)                                                            \\\n  XX(CHECK, check)                                                            \\\n  XX(FS_EVENT, fs_event)                                                      \\\n  XX(FS_POLL, fs_poll)                                                        \\\n  XX(HANDLE, handle)                                                          \\\n  XX(IDLE, idle)                                                              \\\n  XX(NAMED_PIPE, pipe)                                                        \\\n  XX(POLL, poll)                                                              \\\n  XX(PREPARE, prepare)                                                        \\\n  XX(PROCESS, process)                                                        \\\n  XX(STREAM, stream)                                                          \\\n  XX(TCP, tcp)                                                                \\\n  XX(TIMER, timer)                                                            \\\n  XX(TTY, tty)                                                                \\\n  XX(UDP, udp)                                                                \\\n  XX(SIGNAL, signal)                                                          \\\n\n#define UV_REQ_TYPE_MAP(XX)                                                   \\\n  XX(REQ, req)                                                                \\\n  XX(CONNECT, connect)                                                        \\\n  XX(WRITE, write)                                                            \\\n  XX(SHUTDOWN, shutdown)                                                      \\\n  XX(UDP_SEND, udp_send)                                                      \\\n  XX(FS, fs)                                                                  \\\n  XX(WORK, work)                                                              \\\n  XX(GETADDRINFO, getaddrinfo)                                                \\\n\ntypedef enum {\n  UV_UNKNOWN_HANDLE = 0,\n#define XX(uc, lc) UV_##uc,\n  UV_HANDLE_TYPE_MAP(XX)\n#undef XX\n  UV_FILE,\n  UV_HANDLE_TYPE_MAX\n} uv_handle_type;\n\ntypedef enum {\n  UV_UNKNOWN_REQ = 0,\n#define XX(uc, lc) UV_##uc,\n  UV_REQ_TYPE_MAP(XX)\n#undef XX\n  UV_REQ_TYPE_PRIVATE\n  UV_REQ_TYPE_MAX\n} uv_req_type;\n\n\n/* Handle types. */\ntypedef struct uv_loop_s uv_loop_t;\ntypedef struct uv_err_s uv_err_t;\ntypedef struct uv_handle_s uv_handle_t;\ntypedef struct uv_stream_s uv_stream_t;\ntypedef struct uv_tcp_s uv_tcp_t;\ntypedef struct uv_udp_s uv_udp_t;\ntypedef struct uv_pipe_s uv_pipe_t;\ntypedef struct uv_tty_s uv_tty_t;\ntypedef struct uv_poll_s uv_poll_t;\ntypedef struct uv_timer_s uv_timer_t;\ntypedef struct uv_prepare_s uv_prepare_t;\ntypedef struct uv_check_s uv_check_t;\ntypedef struct uv_idle_s uv_idle_t;\ntypedef struct uv_async_s uv_async_t;\ntypedef struct uv_process_s uv_process_t;\ntypedef struct uv_fs_event_s uv_fs_event_t;\ntypedef struct uv_fs_poll_s uv_fs_poll_t;\ntypedef struct uv_signal_s uv_signal_t;\n\n/* Request types. */\ntypedef struct uv_req_s uv_req_t;\ntypedef struct uv_getaddrinfo_s uv_getaddrinfo_t;\ntypedef struct uv_shutdown_s uv_shutdown_t;\ntypedef struct uv_write_s uv_write_t;\ntypedef struct uv_connect_s uv_connect_t;\ntypedef struct uv_udp_send_s uv_udp_send_t;\ntypedef struct uv_fs_s uv_fs_t;\ntypedef struct uv_work_s uv_work_t;\n\n/* None of the above. */\ntypedef struct uv_cpu_info_s uv_cpu_info_t;\ntypedef struct uv_interface_address_s uv_interface_address_t;\n\n\ntypedef enum {\n  UV_RUN_DEFAULT = 0,\n  UV_RUN_ONCE,\n  UV_RUN_NOWAIT\n} uv_run_mode;\n\n\n/*\n * Returns the libuv version packed into a single integer. 8 bits are used for\n * each component, with the patch number stored in the 8 least significant\n * bits. E.g. for libuv 1.2.3 this would return 0x010203.\n */\nUV_EXTERN unsigned int uv_version(void);\n\n/*\n * Returns the libuv version number as a string. For non-release versions\n * \"-pre\" is appended, so the version number could be \"1.2.3-pre\".\n */\nUV_EXTERN const char* uv_version_string(void);\n\n\n/*\n * This function must be called before any other functions in libuv.\n *\n * All functions besides uv_run() are non-blocking.\n *\n * All callbacks in libuv are made asynchronously. That is they are never\n * made by the function that takes them as a parameter.\n */\nUV_EXTERN uv_loop_t* uv_loop_new(void);\nUV_EXTERN void uv_loop_delete(uv_loop_t*);\n\n/*\n * Returns the default loop.\n */\nUV_EXTERN uv_loop_t* uv_default_loop(void);\n\n/*\n * This function runs the event loop. It will act differently depending on the\n * specified mode:\n *  - UV_RUN_DEFAULT: Runs the event loop until the reference count drops to\n *    zero. Always returns zero.\n *  - UV_RUN_ONCE: Poll for new events once. Note that this function blocks if\n *    there are no pending events. Returns zero when done (no active handles\n *    or requests left), or non-zero if more events are expected (meaning you\n *    should run the event loop again sometime in the future).\n *  - UV_RUN_NOWAIT: Poll for new events once but don't block if there are no\n *    pending events.\n */\nUV_EXTERN int uv_run(uv_loop_t*, uv_run_mode mode);\n\n/*\n * This function will stop the event loop by forcing uv_run to end\n * as soon as possible, but not sooner than the next loop iteration.\n * If this function was called before blocking for i/o, the loop won't\n * block for i/o on this iteration.\n */\nUV_EXTERN void uv_stop(uv_loop_t*);\n\n/*\n * Manually modify the event loop's reference count. Useful if the user wants\n * to have a handle or timeout that doesn't keep the loop alive.\n */\nUV_EXTERN void uv_ref(uv_handle_t*);\nUV_EXTERN void uv_unref(uv_handle_t*);\n\n/*\n * Update the event loop's concept of \"now\". Libuv caches the current time\n * at the start of the event loop tick in order to reduce the number of\n * time-related system calls.\n *\n * You won't normally need to call this function unless you have callbacks\n * that block the event loop for longer periods of time, where \"longer\" is\n * somewhat subjective but probably on the order of a millisecond or more.\n */\nUV_EXTERN void uv_update_time(uv_loop_t*);\n\n/*\n * Return the current timestamp in milliseconds. The timestamp is cached at\n * the start of the event loop tick, see |uv_update_time()| for details and\n * rationale.\n *\n * The timestamp increases monotonically from some arbitrary point in time.\n * Don't make assumptions about the starting point, you will only get\n * disappointed.\n *\n * Use uv_hrtime() if you need sub-milliseond granularity.\n */\nUV_EXTERN uint64_t uv_now(uv_loop_t*);\n\n/*\n * Get backend file descriptor. Only kqueue, epoll and event ports are\n * supported.\n *\n * This can be used in conjunction with `uv_run(loop, UV_RUN_NOWAIT)` to\n * poll in one thread and run the event loop's event callbacks in another.\n *\n * Useful for embedding libuv's event loop in another event loop.\n * See test/test-embed.c for an example.\n *\n * Note that embedding a kqueue fd in another kqueue pollset doesn't work on\n * all platforms. It's not an error to add the fd but it never generates\n * events.\n */\nUV_EXTERN int uv_backend_fd(const uv_loop_t*);\n\n/*\n * Get the poll timeout. The return value is in milliseconds, or -1 for no\n * timeout.\n */\nUV_EXTERN int uv_backend_timeout(const uv_loop_t*);\n\n\n/*\n * Should return a buffer that libuv can use to read data into.\n *\n * `suggested_size` is a hint. Returning a buffer that is smaller is perfectly\n * okay as long as `buf.len > 0`.\n */\ntypedef uv_buf_t (*uv_alloc_cb)(uv_handle_t* handle, size_t suggested_size);\n\n/*\n * `nread` is > 0 if there is data available, 0 if libuv is done reading for now\n * or -1 on error.\n *\n * Error details can be obtained by calling uv_last_error(). UV_EOF indicates\n * that the stream has been closed.\n *\n * The callee is responsible for closing the stream when an error happens.\n * Trying to read from the stream again is undefined.\n *\n * The callee is responsible for freeing the buffer, libuv does not reuse it.\n */\ntypedef void (*uv_read_cb)(uv_stream_t* stream, ssize_t nread, uv_buf_t buf);\n\n/*\n * Just like the uv_read_cb except that if the pending parameter is true\n * then you can use uv_accept() to pull the new handle into the process.\n * If no handle is pending then pending will be UV_UNKNOWN_HANDLE.\n */\ntypedef void (*uv_read2_cb)(uv_pipe_t* pipe, ssize_t nread, uv_buf_t buf,\n    uv_handle_type pending);\n\ntypedef void (*uv_write_cb)(uv_write_t* req, int status);\ntypedef void (*uv_connect_cb)(uv_connect_t* req, int status);\ntypedef void (*uv_shutdown_cb)(uv_shutdown_t* req, int status);\ntypedef void (*uv_connection_cb)(uv_stream_t* server, int status);\ntypedef void (*uv_close_cb)(uv_handle_t* handle);\ntypedef void (*uv_poll_cb)(uv_poll_t* handle, int status, int events);\ntypedef void (*uv_timer_cb)(uv_timer_t* handle, int status);\n/* TODO: do these really need a status argument? */\ntypedef void (*uv_async_cb)(uv_async_t* handle, int status);\ntypedef void (*uv_prepare_cb)(uv_prepare_t* handle, int status);\ntypedef void (*uv_check_cb)(uv_check_t* handle, int status);\ntypedef void (*uv_idle_cb)(uv_idle_t* handle, int status);\ntypedef void (*uv_exit_cb)(uv_process_t*, int exit_status, int term_signal);\ntypedef void (*uv_walk_cb)(uv_handle_t* handle, void* arg);\ntypedef void (*uv_fs_cb)(uv_fs_t* req);\ntypedef void (*uv_work_cb)(uv_work_t* req);\ntypedef void (*uv_after_work_cb)(uv_work_t* req, int status);\ntypedef void (*uv_getaddrinfo_cb)(uv_getaddrinfo_t* req,\n                                  int status,\n                                  struct addrinfo* res);\n\n/*\n* This will be called repeatedly after the uv_fs_event_t is initialized.\n* If uv_fs_event_t was initialized with a directory the filename parameter\n* will be a relative path to a file contained in the directory.\n* The events parameter is an ORed mask of enum uv_fs_event elements.\n*/\ntypedef void (*uv_fs_event_cb)(uv_fs_event_t* handle, const char* filename,\n    int events, int status);\n\ntypedef void (*uv_fs_poll_cb)(uv_fs_poll_t* handle,\n                              int status,\n                              const uv_statbuf_t* prev,\n                              const uv_statbuf_t* curr);\n\ntypedef void (*uv_signal_cb)(uv_signal_t* handle, int signum);\n\n\ntypedef enum {\n  UV_LEAVE_GROUP = 0,\n  UV_JOIN_GROUP\n} uv_membership;\n\n\nstruct uv_err_s {\n  /* read-only */\n  uv_err_code code;\n  /* private */\n  int sys_errno_;\n};\n\n\n/*\n * Most functions return boolean: 0 for success and -1 for failure.\n * On error the user should then call uv_last_error() to determine\n * the error code.\n */\nUV_EXTERN uv_err_t uv_last_error(uv_loop_t*);\nUV_EXTERN const char* uv_strerror(uv_err_t err);\nUV_EXTERN const char* uv_err_name(uv_err_t err);\n\n\n#define UV_REQ_FIELDS                                                         \\\n  /* public */                                                                \\\n  void* data;                                                                 \\\n  /* read-only */                                                             \\\n  uv_req_type type;                                                           \\\n  /* private */                                                               \\\n  ngx_queue_t active_queue;                                                   \\\n  UV_REQ_PRIVATE_FIELDS                                                       \\\n\n/* Abstract base class of all requests. */\nstruct uv_req_s {\n  UV_REQ_FIELDS\n};\n\n\n/* Platform-specific request types */\nUV_PRIVATE_REQ_TYPES\n\n\n/*\n * uv_shutdown_t is a subclass of uv_req_t\n *\n * Shutdown the outgoing (write) side of a duplex stream. It waits for\n * pending write requests to complete. The handle should refer to a\n * initialized stream. req should be an uninitialized shutdown request\n * struct. The cb is called after shutdown is complete.\n */\nUV_EXTERN int uv_shutdown(uv_shutdown_t* req, uv_stream_t* handle,\n    uv_shutdown_cb cb);\n\nstruct uv_shutdown_s {\n  UV_REQ_FIELDS\n  uv_stream_t* handle;\n  uv_shutdown_cb cb;\n  UV_SHUTDOWN_PRIVATE_FIELDS\n};\n\n\n#define UV_HANDLE_FIELDS                                                      \\\n  /* public */                                                                \\\n  uv_close_cb close_cb;                                                       \\\n  void* data;                                                                 \\\n  /* read-only */                                                             \\\n  uv_loop_t* loop;                                                            \\\n  uv_handle_type type;                                                        \\\n  /* private */                                                               \\\n  ngx_queue_t handle_queue;                                                   \\\n  UV_HANDLE_PRIVATE_FIELDS                                                    \\\n\n/* The abstract base class of all handles.  */\nstruct uv_handle_s {\n  UV_HANDLE_FIELDS\n};\n\n/*\n * Returns size of various handle types, useful for FFI\n * bindings to allocate correct memory without copying struct\n * definitions\n */\nUV_EXTERN size_t uv_handle_size(uv_handle_type type);\n\n/*\n * Returns size of request types, useful for dynamic lookup with FFI\n */\nUV_EXTERN size_t uv_req_size(uv_req_type type);\n\n/*\n * Returns 1 if the prepare/check/idle/timer handle has been started, 0\n * otherwise. For other handle types this always returns 1.\n */\nUV_EXTERN int uv_is_active(const uv_handle_t* handle);\n\n/*\n * Walk the list of open handles.\n */\nUV_EXTERN void uv_walk(uv_loop_t* loop, uv_walk_cb walk_cb, void* arg);\n\n\n/*\n * Request handle to be closed. close_cb will be called asynchronously after\n * this call. This MUST be called on each handle before memory is released.\n *\n * Note that handles that wrap file descriptors are closed immediately but\n * close_cb will still be deferred to the next iteration of the event loop.\n * It gives you a chance to free up any resources associated with the handle.\n *\n * In-progress requests, like uv_connect_t or uv_write_t, are cancelled and\n * have their callbacks called asynchronously with status=-1 and the error code\n * set to UV_ECANCELED.\n */\nUV_EXTERN void uv_close(uv_handle_t* handle, uv_close_cb close_cb);\n\n\n/*\n * Constructor for uv_buf_t.\n * Due to platform differences the user cannot rely on the ordering of the\n * base and len members of the uv_buf_t struct. The user is responsible for\n * freeing base after the uv_buf_t is done. Return struct passed by value.\n */\nUV_EXTERN uv_buf_t uv_buf_init(char* base, unsigned int len);\n\n\n/*\n * Utility function. Copies up to `size` characters from `src` to `dst`\n * and ensures that `dst` is properly NUL terminated unless `size` is zero.\n */\nUV_EXTERN size_t uv_strlcpy(char* dst, const char* src, size_t size);\n\n/*\n * Utility function. Appends `src` to `dst` and ensures that `dst` is\n * properly NUL terminated unless `size` is zero or `dst` does not\n * contain a NUL byte. `size` is the total length of `dst` so at most\n * `size - strlen(dst) - 1` characters will be copied from `src`.\n */\nUV_EXTERN size_t uv_strlcat(char* dst, const char* src, size_t size);\n\n\n#define UV_STREAM_FIELDS                                                      \\\n  /* number of bytes queued for writing */                                    \\\n  size_t write_queue_size;                                                    \\\n  uv_alloc_cb alloc_cb;                                                       \\\n  uv_read_cb read_cb;                                                         \\\n  uv_read2_cb read2_cb;                                                       \\\n  /* private */                                                               \\\n  UV_STREAM_PRIVATE_FIELDS\n\n/*\n * uv_stream_t is a subclass of uv_handle_t\n *\n * uv_stream is an abstract class.\n *\n * uv_stream_t is the parent class of uv_tcp_t, uv_pipe_t, uv_tty_t, and\n * soon uv_file_t.\n */\nstruct uv_stream_s {\n  UV_HANDLE_FIELDS\n  UV_STREAM_FIELDS\n};\n\nUV_EXTERN int uv_listen(uv_stream_t* stream, int backlog, uv_connection_cb cb);\n\n/*\n * This call is used in conjunction with uv_listen() to accept incoming\n * connections. Call uv_accept after receiving a uv_connection_cb to accept\n * the connection. Before calling uv_accept use uv_*_init() must be\n * called on the client. Non-zero return value indicates an error.\n *\n * When the uv_connection_cb is called it is guaranteed that uv_accept will\n * complete successfully the first time. If you attempt to use it more than\n * once, it may fail. It is suggested to only call uv_accept once per\n * uv_connection_cb call.\n */\nUV_EXTERN int uv_accept(uv_stream_t* server, uv_stream_t* client);\n\n/*\n * Read data from an incoming stream. The callback will be made several\n * several times until there is no more data to read or uv_read_stop is\n * called. When we've reached EOF nread will be set to -1 and the error is\n * set to UV_EOF. When nread == -1 the buf parameter might not point to a\n * valid buffer; in that case buf.len and buf.base are both set to 0.\n * Note that nread might also be 0, which does *not* indicate an error or\n * eof; it happens when libuv requested a buffer through the alloc callback\n * but then decided that it didn't need that buffer.\n */\nUV_EXTERN int uv_read_start(uv_stream_t*, uv_alloc_cb alloc_cb,\n    uv_read_cb read_cb);\n\nUV_EXTERN int uv_read_stop(uv_stream_t*);\n\n/*\n * Extended read methods for receiving handles over a pipe. The pipe must be\n * initialized with ipc == 1.\n */\nUV_EXTERN int uv_read2_start(uv_stream_t*, uv_alloc_cb alloc_cb,\n    uv_read2_cb read_cb);\n\n\n/*\n * Write data to stream. Buffers are written in order. Example:\n *\n *   uv_buf_t a[] = {\n *     { .base = \"1\", .len = 1 },\n *     { .base = \"2\", .len = 1 }\n *   };\n *\n *   uv_buf_t b[] = {\n *     { .base = \"3\", .len = 1 },\n *     { .base = \"4\", .len = 1 }\n *   };\n *\n *   uv_write_t req1;\n *   uv_write_t req2;\n *\n *   // writes \"1234\"\n *   uv_write(&req1, stream, a, 2);\n *   uv_write(&req2, stream, b, 2);\n *\n */\nUV_EXTERN int uv_write(uv_write_t* req, uv_stream_t* handle,\n    uv_buf_t bufs[], int bufcnt, uv_write_cb cb);\n\n/*\n * Extended write function for sending handles over a pipe. The pipe must be\n * initialized with ipc == 1.\n * send_handle must be a TCP socket or pipe, which is a server or a connection\n * (listening or connected state).  Bound sockets or pipes will be assumed to\n * be servers.\n */\nUV_EXTERN int uv_write2(uv_write_t* req, uv_stream_t* handle, uv_buf_t bufs[],\n    int bufcnt, uv_stream_t* send_handle, uv_write_cb cb);\n\n/* uv_write_t is a subclass of uv_req_t */\nstruct uv_write_s {\n  UV_REQ_FIELDS\n  uv_write_cb cb;\n  uv_stream_t* send_handle;\n  uv_stream_t* handle;\n  UV_WRITE_PRIVATE_FIELDS\n};\n\n\n/*\n * Used to determine whether a stream is readable or writable.\n */\nUV_EXTERN int uv_is_readable(const uv_stream_t* handle);\nUV_EXTERN int uv_is_writable(const uv_stream_t* handle);\n\n\n/*\n * Used to determine whether a stream is closing or closed.\n *\n * N.B. is only valid between the initialization of the handle\n *      and the arrival of the close callback, and cannot be used\n *      to validate the handle.\n */\nUV_EXTERN int uv_is_closing(const uv_handle_t* handle);\n\n\n/*\n * uv_tcp_t is a subclass of uv_stream_t\n *\n * Represents a TCP stream or TCP server.\n */\nstruct uv_tcp_s {\n  UV_HANDLE_FIELDS\n  UV_STREAM_FIELDS\n  UV_TCP_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_tcp_init(uv_loop_t*, uv_tcp_t* handle);\n\n/*\n * Opens an existing file descriptor or SOCKET as a tcp handle.\n */\nUV_EXTERN int uv_tcp_open(uv_tcp_t* handle, uv_os_sock_t sock);\n\n/* Enable/disable Nagle's algorithm. */\nUV_EXTERN int uv_tcp_nodelay(uv_tcp_t* handle, int enable);\n\n/*\n * Enable/disable TCP keep-alive.\n *\n * `delay` is the initial delay in seconds, ignored when `enable` is zero.\n */\nUV_EXTERN int uv_tcp_keepalive(uv_tcp_t* handle,\n                               int enable,\n                               unsigned int delay);\n\n/*\n * Enable/disable simultaneous asynchronous accept requests that are\n * queued by the operating system when listening for new tcp connections.\n * This setting is used to tune a tcp server for the desired performance.\n * Having simultaneous accepts can significantly improve the rate of\n * accepting connections (which is why it is enabled by default) but\n * may lead to uneven load distribution in multi-process setups.\n */\nUV_EXTERN int uv_tcp_simultaneous_accepts(uv_tcp_t* handle, int enable);\n\nUV_EXTERN int uv_tcp_bind(uv_tcp_t* handle, struct sockaddr_in);\nUV_EXTERN int uv_tcp_bind6(uv_tcp_t* handle, struct sockaddr_in6);\nUV_EXTERN int uv_tcp_getsockname(uv_tcp_t* handle, struct sockaddr* name,\n    int* namelen);\nUV_EXTERN int uv_tcp_getpeername(uv_tcp_t* handle, struct sockaddr* name,\n    int* namelen);\n\n/*\n * uv_tcp_connect, uv_tcp_connect6\n * These functions establish IPv4 and IPv6 TCP connections. Provide an\n * initialized TCP handle and an uninitialized uv_connect_t*. The callback\n * will be made when the connection is established.\n */\nUV_EXTERN int uv_tcp_connect(uv_connect_t* req, uv_tcp_t* handle,\n    struct sockaddr_in address, uv_connect_cb cb);\nUV_EXTERN int uv_tcp_connect6(uv_connect_t* req, uv_tcp_t* handle,\n    struct sockaddr_in6 address, uv_connect_cb cb);\n\n/* uv_connect_t is a subclass of uv_req_t */\nstruct uv_connect_s {\n  UV_REQ_FIELDS\n  uv_connect_cb cb;\n  uv_stream_t* handle;\n  UV_CONNECT_PRIVATE_FIELDS\n};\n\n\n/*\n * UDP support.\n */\n\nenum uv_udp_flags {\n  /* Disables dual stack mode. Used with uv_udp_bind6(). */\n  UV_UDP_IPV6ONLY = 1,\n  /*\n   * Indicates message was truncated because read buffer was too small. The\n   * remainder was discarded by the OS. Used in uv_udp_recv_cb.\n   */\n  UV_UDP_PARTIAL = 2\n};\n\n/*\n * Called after a uv_udp_send() or uv_udp_send6(). status 0 indicates\n * success otherwise error.\n */\ntypedef void (*uv_udp_send_cb)(uv_udp_send_t* req, int status);\n\n/*\n * Callback that is invoked when a new UDP datagram is received.\n *\n *  handle  UDP handle.\n *  nread   Number of bytes that have been received.\n *          0 if there is no more data to read. You may\n *          discard or repurpose the read buffer.\n *          -1 if a transmission error was detected.\n *  buf     uv_buf_t with the received data.\n *  addr    struct sockaddr_in or struct sockaddr_in6.\n *          Valid for the duration of the callback only.\n *  flags   One or more OR'ed UV_UDP_* constants.\n *          Right now only UV_UDP_PARTIAL is used.\n */\ntypedef void (*uv_udp_recv_cb)(uv_udp_t* handle, ssize_t nread, uv_buf_t buf,\n    struct sockaddr* addr, unsigned flags);\n\n/* uv_udp_t is a subclass of uv_handle_t */\nstruct uv_udp_s {\n  UV_HANDLE_FIELDS\n  UV_UDP_PRIVATE_FIELDS\n};\n\n/* uv_udp_send_t is a subclass of uv_req_t */\nstruct uv_udp_send_s {\n  UV_REQ_FIELDS\n  uv_udp_t* handle;\n  uv_udp_send_cb cb;\n  UV_UDP_SEND_PRIVATE_FIELDS\n};\n\n/*\n * Initialize a new UDP handle. The actual socket is created lazily.\n * Returns 0 on success.\n */\nUV_EXTERN int uv_udp_init(uv_loop_t*, uv_udp_t* handle);\n\n/*\n * Opens an existing file descriptor or SOCKET as a udp handle.\n */\nUV_EXTERN int uv_udp_open(uv_udp_t* handle, uv_os_sock_t sock);\n\n/*\n * Bind to a IPv4 address and port.\n *\n * Arguments:\n *  handle    UDP handle. Should have been initialized with `uv_udp_init`.\n *  addr      struct sockaddr_in with the address and port to bind to.\n *  flags     Unused.\n *\n * Returns:\n *  0 on success, -1 on error.\n */\nUV_EXTERN int uv_udp_bind(uv_udp_t* handle, struct sockaddr_in addr,\n    unsigned flags);\n\n/*\n * Bind to a IPv6 address and port.\n *\n * Arguments:\n *  handle    UDP handle. Should have been initialized with `uv_udp_init`.\n *  addr      struct sockaddr_in with the address and port to bind to.\n *  flags     Should be 0 or UV_UDP_IPV6ONLY.\n *\n * Returns:\n *  0 on success, -1 on error.\n */\nUV_EXTERN int uv_udp_bind6(uv_udp_t* handle, struct sockaddr_in6 addr,\n    unsigned flags);\nUV_EXTERN int uv_udp_getsockname(uv_udp_t* handle, struct sockaddr* name,\n    int* namelen);\n\n/*\n * Set membership for a multicast address\n *\n * Arguments:\n *  handle              UDP handle. Should have been initialized with\n *                      `uv_udp_init`.\n *  multicast_addr      multicast address to set membership for\n *  interface_addr      interface address\n *  membership          Should be UV_JOIN_GROUP or UV_LEAVE_GROUP\n *\n * Returns:\n *  0 on success, -1 on error.\n */\nUV_EXTERN int uv_udp_set_membership(uv_udp_t* handle,\n    const char* multicast_addr, const char* interface_addr,\n    uv_membership membership);\n\n/*\n * Set IP multicast loop flag. Makes multicast packets loop back to\n * local sockets.\n *\n * Arguments:\n *  handle              UDP handle. Should have been initialized with\n *                      `uv_udp_init`.\n *  on                  1 for on, 0 for off\n *\n * Returns:\n *  0 on success, -1 on error.\n */\nUV_EXTERN int uv_udp_set_multicast_loop(uv_udp_t* handle, int on);\n\n/*\n * Set the multicast ttl\n *\n * Arguments:\n *  handle              UDP handle. Should have been initialized with\n *                      `uv_udp_init`.\n *  ttl                 1 through 255\n *\n * Returns:\n *  0 on success, -1 on error.\n */\nUV_EXTERN int uv_udp_set_multicast_ttl(uv_udp_t* handle, int ttl);\n\n/*\n * Set broadcast on or off\n *\n * Arguments:\n *  handle              UDP handle. Should have been initialized with\n *                      `uv_udp_init`.\n *  on                  1 for on, 0 for off\n *\n * Returns:\n *  0 on success, -1 on error.\n */\nUV_EXTERN int uv_udp_set_broadcast(uv_udp_t* handle, int on);\n\n/*\n * Set the time to live\n *\n * Arguments:\n *  handle              UDP handle. Should have been initialized with\n *                      `uv_udp_init`.\n *  ttl                 1 through 255\n *\n * Returns:\n *  0 on success, -1 on error.\n */\nUV_EXTERN int uv_udp_set_ttl(uv_udp_t* handle, int ttl);\n\n/*\n * Send data. If the socket has not previously been bound with `uv_udp_bind`\n * or `uv_udp_bind6`, it is bound to 0.0.0.0 (the \"all interfaces\" address)\n * and a random port number.\n *\n * Arguments:\n *  req       UDP request handle. Need not be initialized.\n *  handle    UDP handle. Should have been initialized with `uv_udp_init`.\n *  bufs      List of buffers to send.\n *  bufcnt    Number of buffers in `bufs`.\n *  addr      Address of the remote peer. See `uv_ip4_addr`.\n *  send_cb   Callback to invoke when the data has been sent out.\n *\n * Returns:\n *  0 on success, -1 on error.\n */\nUV_EXTERN int uv_udp_send(uv_udp_send_t* req, uv_udp_t* handle,\n    uv_buf_t bufs[], int bufcnt, struct sockaddr_in addr,\n    uv_udp_send_cb send_cb);\n\n/*\n * Send data. If the socket has not previously been bound with `uv_udp_bind6`,\n * it is bound to ::0 (the \"all interfaces\" address) and a random port number.\n *\n * Arguments:\n *  req       UDP request handle. Need not be initialized.\n *  handle    UDP handle. Should have been initialized with `uv_udp_init`.\n *  bufs      List of buffers to send.\n *  bufcnt    Number of buffers in `bufs`.\n *  addr      Address of the remote peer. See `uv_ip6_addr`.\n *  send_cb   Callback to invoke when the data has been sent out.\n *\n * Returns:\n *  0 on success, -1 on error.\n */\nUV_EXTERN int uv_udp_send6(uv_udp_send_t* req, uv_udp_t* handle,\n    uv_buf_t bufs[], int bufcnt, struct sockaddr_in6 addr,\n    uv_udp_send_cb send_cb);\n\n/*\n * Receive data. If the socket has not previously been bound with `uv_udp_bind`\n * or `uv_udp_bind6`, it is bound to 0.0.0.0 (the \"all interfaces\" address)\n * and a random port number.\n *\n * Arguments:\n *  handle    UDP handle. Should have been initialized with `uv_udp_init`.\n *  alloc_cb  Callback to invoke when temporary storage is needed.\n *  recv_cb   Callback to invoke with received data.\n *\n * Returns:\n *  0 on success, -1 on error.\n */\nUV_EXTERN int uv_udp_recv_start(uv_udp_t* handle, uv_alloc_cb alloc_cb,\n    uv_udp_recv_cb recv_cb);\n\n/*\n * Stop listening for incoming datagrams.\n *\n * Arguments:\n *  handle    UDP handle. Should have been initialized with `uv_udp_init`.\n *\n * Returns:\n *  0 on success, -1 on error.\n */\nUV_EXTERN int uv_udp_recv_stop(uv_udp_t* handle);\n\n\n/*\n * uv_tty_t is a subclass of uv_stream_t\n *\n * Representing a stream for the console.\n */\nstruct uv_tty_s {\n  UV_HANDLE_FIELDS\n  UV_STREAM_FIELDS\n  UV_TTY_PRIVATE_FIELDS\n};\n\n/*\n * Initialize a new TTY stream with the given file descriptor. Usually the\n * file descriptor will be\n *   0 = stdin\n *   1 = stdout\n *   2 = stderr\n * The last argument, readable, specifies if you plan on calling\n * uv_read_start with this stream. stdin is readable, stdout is not.\n *\n * TTY streams which are not readable have blocking writes.\n */\nUV_EXTERN int uv_tty_init(uv_loop_t*, uv_tty_t*, uv_file fd, int readable);\n\n/*\n * Set mode. 0 for normal, 1 for raw.\n */\nUV_EXTERN int uv_tty_set_mode(uv_tty_t*, int mode);\n\n/*\n * To be called when the program exits. Resets TTY settings to default\n * values for the next process to take over.\n */\nUV_EXTERN void uv_tty_reset_mode(void);\n\n/*\n * Gets the current Window size. On success zero is returned.\n */\nUV_EXTERN int uv_tty_get_winsize(uv_tty_t*, int* width, int* height);\n\n/*\n * Used to detect what type of stream should be used with a given file\n * descriptor. Usually this will be used during initialization to guess the\n * type of the stdio streams.\n * For isatty() functionality use this function and test for UV_TTY.\n */\nUV_EXTERN uv_handle_type uv_guess_handle(uv_file file);\n\n/*\n * uv_pipe_t is a subclass of uv_stream_t\n *\n * Representing a pipe stream or pipe server. On Windows this is a Named\n * Pipe. On Unix this is a UNIX domain socket.\n */\nstruct uv_pipe_s {\n  UV_HANDLE_FIELDS\n  UV_STREAM_FIELDS\n  int ipc; /* non-zero if this pipe is used for passing handles */\n  UV_PIPE_PRIVATE_FIELDS\n};\n\n/*\n * Initialize a pipe. The last argument is a boolean to indicate if\n * this pipe will be used for handle passing between processes.\n */\nUV_EXTERN int uv_pipe_init(uv_loop_t*, uv_pipe_t* handle, int ipc);\n\n/*\n * Opens an existing file descriptor or HANDLE as a pipe.\n */\nUV_EXTERN int uv_pipe_open(uv_pipe_t*, uv_file file);\n\nUV_EXTERN int uv_pipe_bind(uv_pipe_t* handle, const char* name);\n\nUV_EXTERN void uv_pipe_connect(uv_connect_t* req, uv_pipe_t* handle,\n    const char* name, uv_connect_cb cb);\n\n/*\n * This setting applies to Windows only.\n * Set the number of pending pipe instance handles when the pipe server\n * is waiting for connections.\n */\nUV_EXTERN void uv_pipe_pending_instances(uv_pipe_t* handle, int count);\n\n\n/*\n * uv_poll_t is a subclass of uv_handle_t.\n *\n * The uv_poll watcher is used to watch file descriptors for readability and\n * writability, similar to the purpose of poll(2).\n *\n * The purpose of uv_poll is to enable integrating external libraries that\n * rely on the event loop to signal it about the socket status changes, like\n * c-ares or libssh2. Using uv_poll_t for any other other purpose is not\n * recommended; uv_tcp_t, uv_udp_t, etc. provide an implementation that is\n * much faster and more scalable than what can be achieved with uv_poll_t,\n * especially on Windows.\n *\n * It is possible that uv_poll occasionally signals that a file descriptor is\n * readable or writable even when it isn't. The user should therefore always\n * be prepared to handle EAGAIN or equivalent when it attempts to read from or\n * write to the fd.\n *\n * It is not okay to have multiple active uv_poll watchers for the same socket.\n * This can cause libuv to busyloop or otherwise malfunction.\n *\n * The user should not close a file descriptor while it is being polled by an\n * active uv_poll watcher. This can cause the poll watcher to report an error,\n * but it might also start polling another socket. However the fd can be safely\n * closed immediately after a call to uv_poll_stop() or uv_close().\n *\n * On windows only sockets can be polled with uv_poll. On unix any file\n * descriptor that would be accepted by poll(2) can be used with uv_poll.\n */\nstruct uv_poll_s {\n  UV_HANDLE_FIELDS\n  uv_poll_cb poll_cb;\n  UV_POLL_PRIVATE_FIELDS\n};\n\nenum uv_poll_event {\n  UV_READABLE = 1,\n  UV_WRITABLE = 2\n};\n\n/* Initialize the poll watcher using a file descriptor. */\nUV_EXTERN int uv_poll_init(uv_loop_t* loop, uv_poll_t* handle, int fd);\n\n/* Initialize the poll watcher using a socket descriptor. On unix this is */\n/* identical to uv_poll_init. On windows it takes a SOCKET handle. */\nUV_EXTERN int uv_poll_init_socket(uv_loop_t* loop, uv_poll_t* handle,\n    uv_os_sock_t socket);\n\n/*\n * Starts polling the file descriptor. `events` is a bitmask consisting made up\n * of UV_READABLE and UV_WRITABLE. As soon as an event is detected the callback\n * will be called with `status` set to 0, and the detected events set en the\n * `events` field.\n *\n * If an error happens while polling status may be set to -1 and the error\n * code can be retrieved with uv_last_error. The user should not close the\n * socket while uv_poll is active. If the user does that anyway, the callback\n * *may* be called reporting an error status, but this is not guaranteed.\n *\n * Calling uv_poll_start on an uv_poll watcher that is already active is fine.\n * Doing so will update the events mask that is being watched for.\n */\nUV_EXTERN int uv_poll_start(uv_poll_t* handle, int events, uv_poll_cb cb);\n\n/* Stops polling the file descriptor. */\nUV_EXTERN int uv_poll_stop(uv_poll_t* handle);\n\n\n/*\n * uv_prepare_t is a subclass of uv_handle_t.\n *\n * Every active prepare handle gets its callback called exactly once per loop\n * iteration, just before the system blocks to wait for completed i/o.\n */\nstruct uv_prepare_s {\n  UV_HANDLE_FIELDS\n  UV_PREPARE_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_prepare_init(uv_loop_t*, uv_prepare_t* prepare);\n\nUV_EXTERN int uv_prepare_start(uv_prepare_t* prepare, uv_prepare_cb cb);\n\nUV_EXTERN int uv_prepare_stop(uv_prepare_t* prepare);\n\n\n/*\n * uv_check_t is a subclass of uv_handle_t.\n *\n * Every active check handle gets its callback called exactly once per loop\n * iteration, just after the system returns from blocking.\n */\nstruct uv_check_s {\n  UV_HANDLE_FIELDS\n  UV_CHECK_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_check_init(uv_loop_t*, uv_check_t* check);\n\nUV_EXTERN int uv_check_start(uv_check_t* check, uv_check_cb cb);\n\nUV_EXTERN int uv_check_stop(uv_check_t* check);\n\n\n/*\n * uv_idle_t is a subclass of uv_handle_t.\n *\n * Every active idle handle gets its callback called repeatedly until it is\n * stopped. This happens after all other types of callbacks are processed.\n * When there are multiple \"idle\" handles active, their callbacks are called\n * in turn.\n */\nstruct uv_idle_s {\n  UV_HANDLE_FIELDS\n  UV_IDLE_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_idle_init(uv_loop_t*, uv_idle_t* idle);\n\nUV_EXTERN int uv_idle_start(uv_idle_t* idle, uv_idle_cb cb);\n\nUV_EXTERN int uv_idle_stop(uv_idle_t* idle);\n\n\n/*\n * uv_async_t is a subclass of uv_handle_t.\n *\n * uv_async_send wakes up the event loop and calls the async handle's callback.\n * There is no guarantee that every uv_async_send call leads to exactly one\n * invocation of the callback; the only guarantee is that the callback function\n * is called at least once after the call to async_send. Unlike all other\n * libuv functions, uv_async_send can be called from another thread.\n */\nstruct uv_async_s {\n  UV_HANDLE_FIELDS\n  UV_ASYNC_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_async_init(uv_loop_t*, uv_async_t* async,\n    uv_async_cb async_cb);\n\n/*\n * This can be called from other threads to wake up a libuv thread.\n *\n * libuv is single threaded at the moment.\n */\nUV_EXTERN int uv_async_send(uv_async_t* async);\n\n\n/*\n * uv_timer_t is a subclass of uv_handle_t.\n *\n * Used to get woken up at a specified time in the future.\n */\nstruct uv_timer_s {\n  UV_HANDLE_FIELDS\n  UV_TIMER_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_timer_init(uv_loop_t*, uv_timer_t* handle);\n\n/*\n * Start the timer. `timeout` and `repeat` are in milliseconds.\n *\n * If timeout is zero, the callback fires on the next tick of the event loop.\n *\n * If repeat is non-zero, the callback fires first after timeout milliseconds\n * and then repeatedly after repeat milliseconds.\n */\nUV_EXTERN int uv_timer_start(uv_timer_t* handle,\n                             uv_timer_cb cb,\n                             uint64_t timeout,\n                             uint64_t repeat);\n\nUV_EXTERN int uv_timer_stop(uv_timer_t* handle);\n\n/*\n * Stop the timer, and if it is repeating restart it using the repeat value\n * as the timeout. If the timer has never been started before it returns -1 and\n * sets the error to UV_EINVAL.\n */\nUV_EXTERN int uv_timer_again(uv_timer_t* handle);\n\n/*\n * Set the repeat value in milliseconds. Note that if the repeat value is set\n * from a timer callback it does not immediately take effect. If the timer was\n * non-repeating before, it will have been stopped. If it was repeating, then\n * the old repeat value will have been used to schedule the next timeout.\n */\nUV_EXTERN void uv_timer_set_repeat(uv_timer_t* handle, uint64_t repeat);\n\nUV_EXTERN uint64_t uv_timer_get_repeat(const uv_timer_t* handle);\n\n\n/*\n * uv_getaddrinfo_t is a subclass of uv_req_t\n *\n * Request object for uv_getaddrinfo.\n */\nstruct uv_getaddrinfo_s {\n  UV_REQ_FIELDS\n  /* read-only */\n  uv_loop_t* loop;\n  UV_GETADDRINFO_PRIVATE_FIELDS\n};\n\n\n/*\n * Asynchronous getaddrinfo(3).\n *\n * Either node or service may be NULL but not both.\n *\n * hints is a pointer to a struct addrinfo with additional address type\n * constraints, or NULL. Consult `man -s 3 getaddrinfo` for details.\n *\n * Returns 0 on success, -1 on error. Call uv_last_error() to get the error.\n *\n * If successful, your callback gets called sometime in the future with the\n * lookup result, which is either:\n *\n *  a) status == 0, the res argument points to a valid struct addrinfo, or\n *  b) status == -1, the res argument is NULL.\n *\n * On NXDOMAIN, the status code is -1 and uv_last_error() returns UV_ENOENT.\n *\n * Call uv_freeaddrinfo() to free the addrinfo structure.\n */\nUV_EXTERN int uv_getaddrinfo(uv_loop_t* loop,\n                             uv_getaddrinfo_t* req,\n                             uv_getaddrinfo_cb getaddrinfo_cb,\n                             const char* node,\n                             const char* service,\n                             const struct addrinfo* hints);\n\n/*\n * Free the struct addrinfo. Passing NULL is allowed and is a no-op.\n */\nUV_EXTERN void uv_freeaddrinfo(struct addrinfo* ai);\n\n/* uv_spawn() options */\ntypedef enum {\n  UV_IGNORE         = 0x00,\n  UV_CREATE_PIPE    = 0x01,\n  UV_INHERIT_FD     = 0x02,\n  UV_INHERIT_STREAM = 0x04,\n\n  /* When UV_CREATE_PIPE is specified, UV_READABLE_PIPE and UV_WRITABLE_PIPE\n   * determine the direction of flow, from the child process' perspective. Both\n   * flags may be specified to create a duplex data stream.\n   */\n  UV_READABLE_PIPE  = 0x10,\n  UV_WRITABLE_PIPE  = 0x20\n} uv_stdio_flags;\n\ntypedef struct uv_stdio_container_s {\n  uv_stdio_flags flags;\n\n  union {\n    uv_stream_t* stream;\n    int fd;\n  } data;\n} uv_stdio_container_t;\n\ntypedef struct uv_process_options_s {\n  uv_exit_cb exit_cb; /* Called after the process exits. */\n  const char* file; /* Path to program to execute. */\n  /*\n   * Command line arguments. args[0] should be the path to the program. On\n   * Windows this uses CreateProcess which concatenates the arguments into a\n   * string this can cause some strange errors. See the note at\n   * windows_verbatim_arguments.\n   */\n  char** args;\n  /*\n   * This will be set as the environ variable in the subprocess. If this is\n   * NULL then the parents environ will be used.\n   */\n  char** env;\n  /*\n   * If non-null this represents a directory the subprocess should execute\n   * in. Stands for current working directory.\n   */\n  char* cwd;\n  /*\n   * Various flags that control how uv_spawn() behaves. See the definition of\n   * `enum uv_process_flags` below.\n   */\n  unsigned int flags;\n  /*\n   * The `stdio` field points to an array of uv_stdio_container_t structs that\n   * describe the file descriptors that will be made available to the child\n   * process. The convention is that stdio[0] points to stdin, fd 1 is used for\n   * stdout, and fd 2 is stderr.\n   *\n   * Note that on windows file descriptors greater than 2 are available to the\n   * child process only if the child processes uses the MSVCRT runtime.\n   */\n  int stdio_count;\n  uv_stdio_container_t* stdio;\n  /*\n   * Libuv can change the child process' user/group id. This happens only when\n   * the appropriate bits are set in the flags fields. This is not supported on\n   * windows; uv_spawn() will fail and set the error to UV_ENOTSUP.\n   */\n  uv_uid_t uid;\n  uv_gid_t gid;\n} uv_process_options_t;\n\n/*\n * These are the flags that can be used for the uv_process_options.flags field.\n */\nenum uv_process_flags {\n  /*\n   * Set the child process' user id. The user id is supplied in the `uid` field\n   * of the options struct. This does not work on windows; setting this flag\n   * will cause uv_spawn() to fail.\n   */\n  UV_PROCESS_SETUID = (1 << 0),\n  /*\n   * Set the child process' group id. The user id is supplied in the `gid`\n   * field of the options struct. This does not work on windows; setting this\n   * flag will cause uv_spawn() to fail.\n   */\n  UV_PROCESS_SETGID = (1 << 1),\n  /*\n   * Do not wrap any arguments in quotes, or perform any other escaping, when\n   * converting the argument list into a command line string. This option is\n   * only meaningful on Windows systems. On unix it is silently ignored.\n   */\n  UV_PROCESS_WINDOWS_VERBATIM_ARGUMENTS = (1 << 2),\n  /*\n   * Spawn the child process in a detached state - this will make it a process\n   * group leader, and will effectively enable the child to keep running after\n   * the parent exits.  Note that the child process will still keep the\n   * parent's event loop alive unless the parent process calls uv_unref() on\n   * the child's process handle.\n   */\n  UV_PROCESS_DETACHED = (1 << 3),\n  /*\n   * Hide the subprocess console window that would normally be created. This\n   * option is only meaningful on Windows systems. On unix it is silently\n   * ignored.\n   */\n  UV_PROCESS_WINDOWS_HIDE = (1 << 4)\n};\n\n/*\n * uv_process_t is a subclass of uv_handle_t\n */\nstruct uv_process_s {\n  UV_HANDLE_FIELDS\n  uv_exit_cb exit_cb;\n  int pid;\n  UV_PROCESS_PRIVATE_FIELDS\n};\n\n/* Initializes uv_process_t and starts the process. */\nUV_EXTERN int uv_spawn(uv_loop_t*, uv_process_t*,\n    uv_process_options_t options);\n\n\n/*\n * Kills the process with the specified signal. The user must still\n * call uv_close on the process.\n */\nUV_EXTERN int uv_process_kill(uv_process_t*, int signum);\n\n\n/* Kills the process with the specified signal. */\nUV_EXTERN uv_err_t uv_kill(int pid, int signum);\n\n\n/*\n * uv_work_t is a subclass of uv_req_t\n */\nstruct uv_work_s {\n  UV_REQ_FIELDS\n  uv_loop_t* loop;\n  uv_work_cb work_cb;\n  uv_after_work_cb after_work_cb;\n  UV_WORK_PRIVATE_FIELDS\n};\n\n/* Queues a work request to execute asynchronously on the thread pool. */\nUV_EXTERN int uv_queue_work(uv_loop_t* loop, uv_work_t* req,\n    uv_work_cb work_cb, uv_after_work_cb after_work_cb);\n\n/* Cancel a pending request. Fails if the request is executing or has finished\n * executing.\n *\n * Returns 0 on success, -1 on error. The loop error code is not touched.\n *\n * Only cancellation of uv_fs_t, uv_getaddrinfo_t and uv_work_t requests is\n * currently supported.\n *\n * Cancelled requests have their callbacks invoked some time in the future.\n * It's _not_ safe to free the memory associated with the request until your\n * callback is called.\n *\n * Here is how cancellation is reported to your callback:\n *\n * - A uv_fs_t request has its req->errorno field set to UV_ECANCELED.\n *\n * - A uv_work_t or uv_getaddrinfo_t request has its callback invoked with\n *   status == -1 and uv_last_error(loop).code == UV_ECANCELED.\n *\n * This function is currently only implemented on UNIX platforms. On Windows,\n * it always returns -1.\n */\nUV_EXTERN int uv_cancel(uv_req_t* req);\n\n\nstruct uv_cpu_info_s {\n  char* model;\n  int speed;\n  struct uv_cpu_times_s {\n    uint64_t user;\n    uint64_t nice;\n    uint64_t sys;\n    uint64_t idle;\n    uint64_t irq;\n  } cpu_times;\n};\n\nstruct uv_interface_address_s {\n  char* name;\n  int is_internal;\n  union {\n    struct sockaddr_in address4;\n    struct sockaddr_in6 address6;\n  } address;\n};\n\nUV_EXTERN char** uv_setup_args(int argc, char** argv);\nUV_EXTERN uv_err_t uv_get_process_title(char* buffer, size_t size);\nUV_EXTERN uv_err_t uv_set_process_title(const char* title);\nUV_EXTERN uv_err_t uv_resident_set_memory(size_t* rss);\nUV_EXTERN uv_err_t uv_uptime(double* uptime);\n\n/*\n * This allocates cpu_infos array, and sets count.  The array\n * is freed using uv_free_cpu_info().\n */\nUV_EXTERN uv_err_t uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count);\nUV_EXTERN void uv_free_cpu_info(uv_cpu_info_t* cpu_infos, int count);\n\n/*\n * This allocates addresses array, and sets count.  The array\n * is freed using uv_free_interface_addresses().\n */\nUV_EXTERN uv_err_t uv_interface_addresses(uv_interface_address_t** addresses,\n  int* count);\nUV_EXTERN void uv_free_interface_addresses(uv_interface_address_t* addresses,\n  int count);\n\n/*\n * File System Methods.\n *\n * The uv_fs_* functions execute a blocking system call asynchronously (in a\n * thread pool) and call the specified callback in the specified loop after\n * completion. If the user gives NULL as the callback the blocking system\n * call will be called synchronously. req should be a pointer to an\n * uninitialized uv_fs_t object.\n *\n * uv_fs_req_cleanup() must be called after completion of the uv_fs_\n * function to free any internal memory allocations associated with the\n * request.\n */\n\ntypedef enum {\n  UV_FS_UNKNOWN = -1,\n  UV_FS_CUSTOM,\n  UV_FS_OPEN,\n  UV_FS_CLOSE,\n  UV_FS_READ,\n  UV_FS_WRITE,\n  UV_FS_SENDFILE,\n  UV_FS_STAT,\n  UV_FS_LSTAT,\n  UV_FS_FSTAT,\n  UV_FS_FTRUNCATE,\n  UV_FS_UTIME,\n  UV_FS_FUTIME,\n  UV_FS_CHMOD,\n  UV_FS_FCHMOD,\n  UV_FS_FSYNC,\n  UV_FS_FDATASYNC,\n  UV_FS_UNLINK,\n  UV_FS_RMDIR,\n  UV_FS_MKDIR,\n  UV_FS_RENAME,\n  UV_FS_READDIR,\n  UV_FS_LINK,\n  UV_FS_SYMLINK,\n  UV_FS_READLINK,\n  UV_FS_CHOWN,\n  UV_FS_FCHOWN\n} uv_fs_type;\n\n/* uv_fs_t is a subclass of uv_req_t */\nstruct uv_fs_s {\n  UV_REQ_FIELDS\n  uv_fs_type fs_type;\n  uv_loop_t* loop;\n  uv_fs_cb cb;\n  ssize_t result;\n  void* ptr;\n  const char* path;\n  uv_err_code errorno;\n  uv_statbuf_t statbuf;  /* Stores the result of uv_fs_stat and uv_fs_fstat. */\n  UV_FS_PRIVATE_FIELDS\n};\n\nUV_EXTERN void uv_fs_req_cleanup(uv_fs_t* req);\n\nUV_EXTERN int uv_fs_close(uv_loop_t* loop, uv_fs_t* req, uv_file file,\n    uv_fs_cb cb);\n\nUV_EXTERN int uv_fs_open(uv_loop_t* loop, uv_fs_t* req, const char* path,\n    int flags, int mode, uv_fs_cb cb);\n\nUV_EXTERN int uv_fs_read(uv_loop_t* loop, uv_fs_t* req, uv_file file,\n    void* buf, size_t length, int64_t offset, uv_fs_cb cb);\n\nUV_EXTERN int uv_fs_unlink(uv_loop_t* loop, uv_fs_t* req, const char* path,\n    uv_fs_cb cb);\n\nUV_EXTERN int uv_fs_write(uv_loop_t* loop, uv_fs_t* req, uv_file file,\n    void* buf, size_t length, int64_t offset, uv_fs_cb cb);\n\nUV_EXTERN int uv_fs_mkdir(uv_loop_t* loop, uv_fs_t* req, const char* path,\n    int mode, uv_fs_cb cb);\n\nUV_EXTERN int uv_fs_rmdir(uv_loop_t* loop, uv_fs_t* req, const char* path,\n    uv_fs_cb cb);\n\nUV_EXTERN int uv_fs_readdir(uv_loop_t* loop, uv_fs_t* req,\n    const char* path, int flags, uv_fs_cb cb);\n\nUV_EXTERN int uv_fs_stat(uv_loop_t* loop, uv_fs_t* req, const char* path,\n    uv_fs_cb cb);\n\nUV_EXTERN int uv_fs_fstat(uv_loop_t* loop, uv_fs_t* req, uv_file file,\n    uv_fs_cb cb);\n\nUV_EXTERN int uv_fs_rename(uv_loop_t* loop, uv_fs_t* req, const char* path,\n    const char* new_path, uv_fs_cb cb);\n\nUV_EXTERN int uv_fs_fsync(uv_loop_t* loop, uv_fs_t* req, uv_file file,\n    uv_fs_cb cb);\n\nUV_EXTERN int uv_fs_fdatasync(uv_loop_t* loop, uv_fs_t* req, uv_file file,\n    uv_fs_cb cb);\n\nUV_EXTERN int uv_fs_ftruncate(uv_loop_t* loop, uv_fs_t* req, uv_file file,\n    int64_t offset, uv_fs_cb cb);\n\nUV_EXTERN int uv_fs_sendfile(uv_loop_t* loop, uv_fs_t* req, uv_file out_fd,\n    uv_file in_fd, int64_t in_offset, size_t length, uv_fs_cb cb);\n\nUV_EXTERN int uv_fs_chmod(uv_loop_t* loop, uv_fs_t* req, const char* path,\n    int mode, uv_fs_cb cb);\n\nUV_EXTERN int uv_fs_utime(uv_loop_t* loop, uv_fs_t* req, const char* path,\n    double atime, double mtime, uv_fs_cb cb);\n\nUV_EXTERN int uv_fs_futime(uv_loop_t* loop, uv_fs_t* req, uv_file file,\n    double atime, double mtime, uv_fs_cb cb);\n\nUV_EXTERN int uv_fs_lstat(uv_loop_t* loop, uv_fs_t* req, const char* path,\n    uv_fs_cb cb);\n\nUV_EXTERN int uv_fs_link(uv_loop_t* loop, uv_fs_t* req, const char* path,\n    const char* new_path, uv_fs_cb cb);\n\n/*\n * This flag can be used with uv_fs_symlink on Windows\n * to specify whether path argument points to a directory.\n */\n#define UV_FS_SYMLINK_DIR          0x0001\n\n/*\n * This flag can be used with uv_fs_symlink on Windows\n * to specify whether the symlink is to be created using junction points.\n */\n#define UV_FS_SYMLINK_JUNCTION     0x0002\n\nUV_EXTERN int uv_fs_symlink(uv_loop_t* loop, uv_fs_t* req, const char* path,\n    const char* new_path, int flags, uv_fs_cb cb);\n\nUV_EXTERN int uv_fs_readlink(uv_loop_t* loop, uv_fs_t* req, const char* path,\n    uv_fs_cb cb);\n\nUV_EXTERN int uv_fs_fchmod(uv_loop_t* loop, uv_fs_t* req, uv_file file,\n    int mode, uv_fs_cb cb);\n\nUV_EXTERN int uv_fs_chown(uv_loop_t* loop, uv_fs_t* req, const char* path,\n    uv_uid_t uid, uv_gid_t gid, uv_fs_cb cb);\n\nUV_EXTERN int uv_fs_fchown(uv_loop_t* loop, uv_fs_t* req, uv_file file,\n    uv_uid_t uid, uv_gid_t gid, uv_fs_cb cb);\n\n\nenum uv_fs_event {\n  UV_RENAME = 1,\n  UV_CHANGE = 2\n};\n\n\nstruct uv_fs_event_s {\n  UV_HANDLE_FIELDS\n  char* filename;\n  UV_FS_EVENT_PRIVATE_FIELDS\n};\n\n\n/*\n * uv_fs_stat() based polling file watcher.\n */\nstruct uv_fs_poll_s {\n  UV_HANDLE_FIELDS\n  /* Private, don't touch. */\n  void* poll_ctx;\n};\n\nUV_EXTERN int uv_fs_poll_init(uv_loop_t* loop, uv_fs_poll_t* handle);\n\n/*\n * Check the file at `path` for changes every `interval` milliseconds.\n *\n * Your callback i invoked with `status == -1` if `path` does not exist\n * or is inaccessible. The watcher is *not* stopped but your callback is\n * not called again until something changes (e.g. when the file is created\n * or the error reason changes).\n *\n * When `status == 0`, your callback receives pointers to the old and new\n * `uv_statbuf_t` structs. They are valid for the duration of the callback\n * only!\n *\n * For maximum portability, use multi-second intervals. Sub-second intervals\n * will not detect all changes on many file systems.\n */\nUV_EXTERN int uv_fs_poll_start(uv_fs_poll_t* handle,\n                               uv_fs_poll_cb poll_cb,\n                               const char* path,\n                               unsigned int interval);\n\nUV_EXTERN int uv_fs_poll_stop(uv_fs_poll_t* handle);\n\n\n/*\n * UNIX signal handling on a per-event loop basis. The implementation is not\n * ultra efficient so don't go creating a million event loops with a million\n * signal watchers.\n *\n * Note to Linux users: SIGRT0 and SIGRT1 (signals 32 and 33) are used by the\n * NPTL pthreads library to manage threads. Installing watchers for those\n * signals will lead to unpredictable behavior and is strongly discouraged.\n * Future versions of libuv may simply reject them.\n *\n * Some signal support is available on Windows:\n *\n *   SIGINT is normally delivered when the user presses CTRL+C. However, like\n *   on Unix, it is not generated when terminal raw mode is enabled.\n *\n *   SIGBREAK is delivered when the user pressed CTRL+BREAK.\n *\n *   SIGHUP is generated when the user closes the console window. On SIGHUP the\n *   program is given approximately 10 seconds to perform cleanup. After that\n *   Windows will unconditionally terminate it.\n *\n *   SIGWINCH is raised whenever libuv detects that the console has been\n *   resized. SIGWINCH is emulated by libuv when the program uses an uv_tty_t\n *   handle to write to the console. SIGWINCH may not always be delivered in a\n *   timely manner; libuv will only detect size changes when the cursor is\n *   being moved. When a readable uv_tty_handle is used in raw mode, resizing\n *   the console buffer will also trigger a SIGWINCH signal.\n *\n * Watchers for other signals can be successfully created, but these signals\n * are never generated. These signals are: SIGILL, SIGABRT, SIGFPE, SIGSEGV,\n * SIGTERM and SIGKILL.\n *\n * Note that calls to raise() or abort() to programmatically raise a signal are\n * not detected by libuv; these will not trigger a signal watcher.\n */\nstruct uv_signal_s {\n  UV_HANDLE_FIELDS\n  uv_signal_cb signal_cb;\n  int signum;\n  UV_SIGNAL_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_signal_init(uv_loop_t* loop, uv_signal_t* handle);\n\nUV_EXTERN int uv_signal_start(uv_signal_t* handle,\n                              uv_signal_cb signal_cb,\n                              int signum);\n\nUV_EXTERN int uv_signal_stop(uv_signal_t* handle);\n\n\n/*\n * Gets load avg\n * See: http://en.wikipedia.org/wiki/Load_(computing)\n * (Returns [0,0,0] for windows and cygwin)\n */\nUV_EXTERN void uv_loadavg(double avg[3]);\n\n\n/*\n * Flags to be passed to uv_fs_event_init.\n */\nenum uv_fs_event_flags {\n  /*\n   * By default, if the fs event watcher is given a directory name, we will\n   * watch for all events in that directory. This flags overrides this behavior\n   * and makes fs_event report only changes to the directory entry itself. This\n   * flag does not affect individual files watched.\n   * This flag is currently not implemented yet on any backend.\n   */\n UV_FS_EVENT_WATCH_ENTRY = 1,\n\n  /*\n   * By default uv_fs_event will try to use a kernel interface such as inotify\n   * or kqueue to detect events. This may not work on remote filesystems such\n   * as NFS mounts. This flag makes fs_event fall back to calling stat() on a\n   * regular interval.\n   * This flag is currently not implemented yet on any backend.\n   */\n  UV_FS_EVENT_STAT = 2,\n\n  /*\n   * By default, event watcher, when watching directory, is not registering\n   * (is ignoring) changes in it's subdirectories.\n   * This flag will override this behaviour on platforms that support it.\n   */\n  UV_FS_EVENT_RECURSIVE = 3\n};\n\n\nUV_EXTERN int uv_fs_event_init(uv_loop_t* loop, uv_fs_event_t* handle,\n    const char* filename, uv_fs_event_cb cb, int flags);\n\n/* Utility */\n\n/* Convert string ip addresses to binary structures */\nUV_EXTERN struct sockaddr_in uv_ip4_addr(const char* ip, int port);\nUV_EXTERN struct sockaddr_in6 uv_ip6_addr(const char* ip, int port);\n\n/* Convert binary addresses to strings */\nUV_EXTERN int uv_ip4_name(struct sockaddr_in* src, char* dst, size_t size);\nUV_EXTERN int uv_ip6_name(struct sockaddr_in6* src, char* dst, size_t size);\n\n/* Cross-platform IPv6-capable implementation of the 'standard' inet_ntop */\n/* and inet_pton functions. On success they return UV_OK. If an error */\n/* the target of the `dst` pointer is unmodified. */\nUV_EXTERN uv_err_t uv_inet_ntop(int af, const void* src, char* dst, size_t size);\nUV_EXTERN uv_err_t uv_inet_pton(int af, const char* src, void* dst);\n\n/* Gets the executable path */\nUV_EXTERN int uv_exepath(char* buffer, size_t* size);\n\n/* Gets the current working directory */\nUV_EXTERN uv_err_t uv_cwd(char* buffer, size_t size);\n\n/* Changes the current working directory */\nUV_EXTERN uv_err_t uv_chdir(const char* dir);\n\n/* Gets memory info in bytes */\nUV_EXTERN uint64_t uv_get_free_memory(void);\nUV_EXTERN uint64_t uv_get_total_memory(void);\n\n/*\n * Returns the current high-resolution real time. This is expressed in\n * nanoseconds. It is relative to an arbitrary time in the past. It is not\n * related to the time of day and therefore not subject to clock drift. The\n * primary use is for measuring performance between intervals.\n *\n * Note not every platform can support nanosecond resolution; however, this\n * value will always be in nanoseconds.\n */\nUV_EXTERN extern uint64_t uv_hrtime(void);\n\n\n/*\n * Disables inheritance for file descriptors / handles that this process\n * inherited from its parent. The effect is that child processes spawned by\n * this process don't accidentally inherit these handles.\n *\n * It is recommended to call this function as early in your program as possible,\n * before the inherited file descriptors can be closed or duplicated.\n *\n * Note that this function works on a best-effort basis: there is no guarantee\n * that libuv can discover all file descriptors that were inherited. In general\n * it does a better job on Windows than it does on unix.\n */\nUV_EXTERN void uv_disable_stdio_inheritance(void);\n\n/*\n * Opens a shared library. The filename is in utf-8. Returns 0 on success and\n * -1 on error. Call `uv_dlerror(uv_lib_t*)` to get the error message.\n */\nUV_EXTERN int uv_dlopen(const char* filename, uv_lib_t* lib);\n\n/*\n * Close the shared library.\n */\nUV_EXTERN void uv_dlclose(uv_lib_t* lib);\n\n/*\n * Retrieves a data pointer from a dynamic library. It is legal for a symbol to\n * map to NULL. Returns 0 on success and -1 if the symbol was not found.\n */\nUV_EXTERN int uv_dlsym(uv_lib_t* lib, const char* name, void** ptr);\n\n/*\n * Returns the last uv_dlopen() or uv_dlsym() error message.\n */\nUV_EXTERN const char* uv_dlerror(uv_lib_t* lib);\n\n/*\n * The mutex functions return 0 on success, -1 on error\n * (unless the return type is void, of course).\n */\nUV_EXTERN int uv_mutex_init(uv_mutex_t* handle);\nUV_EXTERN void uv_mutex_destroy(uv_mutex_t* handle);\nUV_EXTERN void uv_mutex_lock(uv_mutex_t* handle);\nUV_EXTERN int uv_mutex_trylock(uv_mutex_t* handle);\nUV_EXTERN void uv_mutex_unlock(uv_mutex_t* handle);\n\n/*\n * Same goes for the read/write lock functions.\n */\nUV_EXTERN int uv_rwlock_init(uv_rwlock_t* rwlock);\nUV_EXTERN void uv_rwlock_destroy(uv_rwlock_t* rwlock);\nUV_EXTERN void uv_rwlock_rdlock(uv_rwlock_t* rwlock);\nUV_EXTERN int uv_rwlock_tryrdlock(uv_rwlock_t* rwlock);\nUV_EXTERN void uv_rwlock_rdunlock(uv_rwlock_t* rwlock);\nUV_EXTERN void uv_rwlock_wrlock(uv_rwlock_t* rwlock);\nUV_EXTERN int uv_rwlock_trywrlock(uv_rwlock_t* rwlock);\nUV_EXTERN void uv_rwlock_wrunlock(uv_rwlock_t* rwlock);\n\n/*\n * Same goes for the semaphore functions.\n */\nUV_EXTERN int uv_sem_init(uv_sem_t* sem, unsigned int value);\nUV_EXTERN void uv_sem_destroy(uv_sem_t* sem);\nUV_EXTERN void uv_sem_post(uv_sem_t* sem);\nUV_EXTERN void uv_sem_wait(uv_sem_t* sem);\nUV_EXTERN int uv_sem_trywait(uv_sem_t* sem);\n\n/*\n * Same goes for the condition variable functions.\n */\nUV_EXTERN int uv_cond_init(uv_cond_t* cond);\nUV_EXTERN void uv_cond_destroy(uv_cond_t* cond);\nUV_EXTERN void uv_cond_signal(uv_cond_t* cond);\nUV_EXTERN void uv_cond_broadcast(uv_cond_t* cond);\n/* Waits on a condition variable without a timeout.\n *\n * Note:\n * 1. callers should be prepared to deal with spurious wakeups.\n */\nUV_EXTERN void uv_cond_wait(uv_cond_t* cond, uv_mutex_t* mutex);\n/* Waits on a condition variable with a timeout in nano seconds.\n * Returns 0 for success or -1 on timeout, * aborts when other errors happen.\n *\n * Note:\n * 1. callers should be prepared to deal with spurious wakeups.\n * 2. the granularity of timeout on Windows is never less than one millisecond.\n * 3. uv_cond_timedwait takes a relative timeout, not an absolute time.\n */\nUV_EXTERN int uv_cond_timedwait(uv_cond_t* cond, uv_mutex_t* mutex,\n    uint64_t timeout);\n\nUV_EXTERN int uv_barrier_init(uv_barrier_t* barrier, unsigned int count);\nUV_EXTERN void uv_barrier_destroy(uv_barrier_t* barrier);\nUV_EXTERN void uv_barrier_wait(uv_barrier_t* barrier);\n\n/* Runs a function once and only once. Concurrent calls to uv_once() with the\n * same guard will block all callers except one (it's unspecified which one).\n * The guard should be initialized statically with the UV_ONCE_INIT macro.\n */\nUV_EXTERN void uv_once(uv_once_t* guard, void (*callback)(void));\n\nUV_EXTERN int uv_thread_create(uv_thread_t *tid,\n    void (*entry)(void *arg), void *arg);\nUV_EXTERN unsigned long uv_thread_self(void);\nUV_EXTERN int uv_thread_join(uv_thread_t *tid);\n\n/* the presence of these unions force similar struct layout */\nunion uv_any_handle {\n  uv_handle_t handle;\n  uv_stream_t stream;\n  uv_tcp_t tcp;\n  uv_pipe_t pipe;\n  uv_prepare_t prepare;\n  uv_check_t check;\n  uv_idle_t idle;\n  uv_async_t async;\n  uv_timer_t timer;\n  uv_fs_event_t fs_event;\n  uv_fs_poll_t fs_poll;\n  uv_poll_t poll;\n  uv_process_t process;\n  uv_tty_t tty;\n  uv_udp_t udp;\n};\n\nunion uv_any_req {\n  uv_req_t req;\n  uv_write_t write;\n  uv_connect_t connect;\n  uv_shutdown_t shutdown;\n  uv_fs_t fs_req;\n  uv_work_t work_req;\n  uv_udp_send_t udp_send_req;\n  uv_getaddrinfo_t getaddrinfo_req;\n};\n\n\nstruct uv_loop_s {\n  /* User data - use this for whatever. */\n  void* data;\n  /* The last error */\n  uv_err_t last_err;\n  /* Loop reference counting */\n  unsigned int active_handles;\n  ngx_queue_t handle_queue;\n  ngx_queue_t active_reqs;\n  /* Internal flag to signal loop stop */\n  unsigned int stop_flag;\n  UV_LOOP_PRIVATE_FIELDS\n};\n\n\n/* Don't export the private CPP symbols. */\n#undef UV_HANDLE_TYPE_PRIVATE\n#undef UV_REQ_TYPE_PRIVATE\n#undef UV_REQ_PRIVATE_FIELDS\n#undef UV_STREAM_PRIVATE_FIELDS\n#undef UV_TCP_PRIVATE_FIELDS\n#undef UV_PREPARE_PRIVATE_FIELDS\n#undef UV_CHECK_PRIVATE_FIELDS\n#undef UV_IDLE_PRIVATE_FIELDS\n#undef UV_ASYNC_PRIVATE_FIELDS\n#undef UV_TIMER_PRIVATE_FIELDS\n#undef UV_GETADDRINFO_PRIVATE_FIELDS\n#undef UV_FS_REQ_PRIVATE_FIELDS\n#undef UV_WORK_PRIVATE_FIELDS\n#undef UV_FS_EVENT_PRIVATE_FIELDS\n#undef UV_SIGNAL_PRIVATE_FIELDS\n#undef UV_LOOP_PRIVATE_FIELDS\n#undef UV_LOOP_PRIVATE_PLATFORM_FIELDS\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* UV_H */\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-r-httpuv-1.3.5-cikecoc4mugza3oedeesvrguhboosz33/spack-src/src/libuv/src/win/fs.c"
    ],
    "total_files": 254
}