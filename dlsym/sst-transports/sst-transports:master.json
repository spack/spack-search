{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-sst-transports-master-vyyr2p4k4qxfkfbhioaigxalm7gjy6vh/spack-src/libfabric/src/fabric.c": "/*\n * Copyright (c) 2004, 2005 Topspin Communications.  All rights reserved.\n * Copyright (c) 2006-2016 Cisco Systems, Inc.  All rights reserved.\n * Copyright (c) 2013-2017 Intel Corp., Inc.  All rights reserved.\n *\n * This software is available to you under a choice of one of two\n * licenses.  You may choose to be licensed under the terms of the GNU\n * General Public License (GPL) Version 2, available from the file\n * COPYING in the main directory of this source tree, or the\n * BSD license below:\n *\n *     Redistribution and use in source and binary forms, with or\n *     without modification, are permitted provided that the following\n *     conditions are met:\n *\n *      - Redistributions of source code must retain the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer.\n *\n *      - Redistributions in binary form must reproduce the above\n *        copyright notice, this list of conditions and the following\n *        disclaimer in the documentation and/or other materials\n *        provided with the distribution.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\n * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS\n * BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN\n * ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN\n * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n * SOFTWARE.\n */\n\n#include \"config.h\"\n\n#include <assert.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <dirent.h>\n\n#include <rdma/fi_errno.h>\n#include \"ofi_util.h\"\n#include \"ofi.h\"\n#include \"shared/ofi_str.h\"\n#include \"ofi_prov.h\"\n#include \"ofi_perf.h\"\n\n#ifdef HAVE_LIBDL\n#include <dlfcn.h>\n#endif\n\nstruct ofi_prov {\n\tstruct ofi_prov\t\t*next;\n\tchar\t\t\t*prov_name;\n\tstruct fi_provider\t*provider;\n\tvoid\t\t\t*dlhandle;\n\tbool\t\t\thidden;\n};\n\nstatic struct ofi_prov *prov_head, *prov_tail;\nint ofi_init = 0;\nextern struct ofi_common_locks common_locks;\n\nstatic struct fi_filter prov_filter;\n\nstatic int ofi_find_name(char **names, const char *name)\n{\n\tint i;\n\n\tfor (i = 0; names[i]; i++) {\n\t\tif (!strcasecmp(name, names[i]))\n\t\t\treturn i;\n\t}\n\treturn -1;\n}\n\n/* matches if names[i] == \"xxx;yyy\" and name == \"xxx\" */\nstatic int ofi_find_layered_name(char **names, const char *name)\n{\n\tint i, len;\n\n\tlen = strlen(name);\n\tfor (i = 0; names[i]; i++) {\n\t\tif (!strncasecmp(name, names[i], len) && names[i][len] == ';' )\n\t\t\treturn i;\n\t}\n\treturn -1;\n}\n\n/* matches if names[i] == \"xxx\" and name == \"xxx;yyy\" */\nstatic int ofi_find_core_name(char **names, const char *name)\n{\n\tint i, len;\n\n\tfor (i = 0; names[i]; i++) {\n\t\tlen = strlen(names[i]);\n\t\tif (!strncasecmp(name, names[i], len) && name[len] == ';' )\n\t\t\treturn i;\n\t}\n\treturn -1;\n}\n\nstatic void ofi_closest_prov_names(char *prov_name, char* miss_prov_name, int n)\n{\n\tif (strncasecmp( prov_name, miss_prov_name, n ) == 0 ) {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"Instead misspelled provider: %s, you may want: %s?\\n\",\n\t\t\tmiss_prov_name, prov_name);\n\t}\n}\n\nstatic void ofi_suggest_prov_names(char *name_to_match)\n{\n\tstruct ofi_prov *prov;\n\tfor (prov = prov_head; prov; prov = prov->next) {\n\t\tif (strlen(prov->prov_name) != strlen(name_to_match)\n\t\t    && !strncasecmp(prov->prov_name, name_to_match,\n\t\t\t\t    strlen(name_to_match))) {\n\t\t\tif (strlen(name_to_match) > 5)\n\t\t\t\tofi_closest_prov_names(prov->prov_name,\n\t\t\t\t\t\t       name_to_match, 5);\n\t\t\telse\n\t\t\t\tofi_closest_prov_names(prov->prov_name,\n\t\t\t\t\t\t       name_to_match, 2);\n\t\t}\n\t}\n}\n\nstatic enum ofi_prov_type ofi_prov_type(const struct fi_provider *provider)\n{\n\tconst struct fi_prov_context *ctx;\n\tctx = (const struct fi_prov_context *) &provider->context;\n\treturn ctx->type;\n}\n\nstatic int ofi_is_util_prov(const struct fi_provider *provider)\n{\n\treturn ofi_prov_type(provider) == OFI_PROV_UTIL;\n}\n\nstatic int ofi_is_core_prov(const struct fi_provider *provider)\n{\n\treturn ofi_prov_type(provider) == OFI_PROV_CORE;\n}\n\nstatic int ofi_is_hook_prov(const struct fi_provider *provider)\n{\n\treturn ofi_prov_type(provider) == OFI_PROV_HOOK;\n}\n\nint ofi_apply_filter(struct fi_filter *filter, const char *name)\n{\n\tif (!filter->names)\n\t\treturn 0;\n\n\tif (ofi_find_name(filter->names, name) >= 0)\n\t\treturn filter->negated ? 1 : 0;\n\n\treturn filter->negated ? 0 : 1;\n}\n\n/*\n * The provider init filter is used to filter out unnecessary core providers\n * at the initialization time. Utility providers are not concerned.\n *\n * Special handling is needed for layered provider names:\n *\n * If the filter is not negated, a name \"xxx;yyy\" in the filter should match\n * input \"xxx\" to ensure that the core provider \"xxx\" is included.\n *\n * If the filter is negated, a name \"xxx;yyy\" in the filter should not match\n * input \"xxx\" otherwise the core provider \"xxx\" may be incorrectly filtered\n * out.\n */\nint ofi_apply_prov_init_filter(struct fi_filter *filter, const char *name)\n{\n\tif (!filter->names)\n\t\treturn 0;\n\n\tif (ofi_find_name(filter->names, name) >= 0)\n\t\treturn filter->negated ? 1 : 0;\n\n\tif (filter->negated)\n\t\treturn 0;\n\n\tif (ofi_find_layered_name(filter->names, name) >= 0)\n\t\treturn 0;\n\n\treturn 1;\n}\n\n/*\n * The provider post filter is used to remove unwanted entries from the fi_info\n * list before returning from fi_getinfo().\n *\n * Layered provider names are handled in the same way as non-layered provider\n * names -- requiring full match.\n *\n * In addition, a name \"xxx\" in the filter should be able to match an input\n * \"xxx;yyy\" to allow extra layering on top of what is requested by the user.\n */\nint ofi_apply_prov_post_filter(struct fi_filter *filter, const char *name)\n{\n\tif (!filter->names)\n\t\treturn 0;\n\n\tif (ofi_find_name(filter->names, name) >= 0 ||\n\t    ofi_find_core_name(filter->names, name) >= 0)\n\t\treturn filter->negated ? 1 : 0;\n\n\treturn filter->negated ? 0 : 1;\n}\n\nstatic int ofi_getinfo_filter(const struct fi_provider *provider)\n{\n\t/* Positive filters only apply to core providers.  They must be\n\t * explicitly enabled by the filter.  Other providers (i.e. utility)\n\t * are automatically enabled in this case, so that they can work\n\t * over any enabled core filter.  Negative filters may be used\n\t * to disable any provider.\n\t */\n\tif (!prov_filter.negated && !ofi_is_core_prov(provider))\n\t\treturn 0;\n\n\treturn ofi_apply_prov_init_filter(&prov_filter, provider->name);\n}\n\nstatic void ofi_filter_info(struct fi_info **info)\n{\n\tstruct fi_info *cur, *prev, *tmp;\n\n\tif (!prov_filter.names)\n\t\treturn;\n\n\tprev = NULL;\n\tcur = *info;\n\twhile (cur) {\n\t\tassert(cur->fabric_attr && cur->fabric_attr->prov_name);\n\n\t\tif (ofi_apply_prov_post_filter(&prov_filter, cur->fabric_attr->prov_name)) {\n\t\t\ttmp = cur;\n\t\t\tcur = cur->next;\n\t\t\tif (prev)\n\t\t\t\tprev->next = cur;\n\t\t\telse\n\t\t\t\t*info = cur;\n\t\t\ttmp->next = NULL;\n\t\t\tfi_freeinfo(tmp);\n\t\t} else {\n\t\t\tprev = cur;\n\t\t\tcur = cur->next;\n\t\t}\n\t}\n}\n\nstatic struct ofi_prov *ofi_getprov(const char *prov_name, size_t len)\n{\n\tstruct ofi_prov *prov;\n\n\tfor (prov = prov_head; prov; prov = prov->next) {\n\t\tif ((strlen(prov->prov_name) == len) &&\n\t\t    !strncmp(prov->prov_name, prov_name, len))\n\t\t\treturn prov;\n\t}\n\n\treturn NULL;\n}\n\nstruct fi_provider *ofi_get_hook(const char *name)\n{\n\tstruct ofi_prov *prov;\n\tstruct fi_provider *provider = NULL;\n\tchar *try_name = NULL;\n\tint ret;\n\n\tprov = ofi_getprov(name, strlen(name));\n\tif (!prov) {\n\t\tret = asprintf(&try_name, \"ofi_hook_%s\", name);\n\t\tif (ret > 0)\n\t\t\tprov = ofi_getprov(try_name, ret);\n\t\telse\n\t\t\ttry_name = NULL;\n\t}\n\n\tif (prov) {\n\t\tif (prov->provider && ofi_is_hook_prov(prov->provider)) {\n\t\t\tprovider = prov->provider;\n\t\t} else {\n\t\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\t\"Specified provider is not a hook: %s\\n\", name);\n\t\t}\n\t} else {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"No hook found for: %s\\n\", name);\n\t}\n\n\tfree(try_name);\n\treturn provider;\n}\n\nstatic void cleanup_provider(struct fi_provider *provider, void *dlhandle)\n{\n\tOFI_UNUSED(dlhandle);\n\n\tif (provider) {\n\t\tfi_param_undefine(provider);\n\n\t\tif (provider->cleanup)\n\t\t\tprovider->cleanup();\n\t}\n\n#ifdef HAVE_LIBDL\n\tif (dlhandle)\n\t\tdlclose(dlhandle);\n#endif\n}\n\nstatic struct ofi_prov *ofi_create_prov_entry(const char *prov_name)\n{\n\tstruct ofi_prov *prov = NULL;\n\tprov = calloc(sizeof *prov, 1);\n\tif (!prov) {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"Not enough memory to allocate provider registry\\n\");\n\t\treturn NULL;\n\t}\n\n\tprov->prov_name = strdup(prov_name);\n\tif (!prov->prov_name) {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"Failed to init pre-registered provider name\\n\");\n\t\tfree(prov);\n\t\treturn NULL;\n\t}\n\tif (prov_tail)\n\t\tprov_tail->next = prov;\n\telse\n\t\tprov_head = prov;\n\tprov_tail = prov;\n\n\tprov->hidden = false;\n\n\treturn prov;\n}\n\n/* This is the default order that providers will be reported when a provider\n * is available.  Initialize the socket(s) provider last.  This will result in\n * it being the least preferred provider.\n */\nstatic void ofi_ordered_provs_init(void)\n{\n\tchar *ordered_prov_names[] = {\n\t\t\"sstmac\",\n\t\t/* These are hooking providers only.  Their order\n\t\t * doesn't matter\n\t\t */\n\t\t\"ofi_hook_perf\", \"ofi_hook_debug\", \"ofi_hook_noop\",\n\t};\n\tint num_provs = sizeof(ordered_prov_names)/sizeof(ordered_prov_names[0]), i;\n\n\tfor (i = 0; i < num_provs; i++)\n\t\tofi_create_prov_entry(ordered_prov_names[i]);\n}\n\nstatic void ofi_set_prov_type(struct fi_prov_context *ctx,\n\t\t\t      struct fi_provider *provider)\n{\n\tif (!provider->getinfo)\n\t\tctx->type = OFI_PROV_HOOK;\n\telse if (ofi_has_util_prefix(provider->name))\n\t\tctx->type = OFI_PROV_UTIL;\n\telse\n\t\tctx->type = OFI_PROV_CORE;\n}\n\nstatic int ofi_register_provider(struct fi_provider *provider, void *dlhandle)\n{\n\tstruct fi_prov_context *ctx;\n\tstruct ofi_prov *prov = NULL;\n\tbool hidden = false;\n\tint ret;\n\n\tif (!provider || !provider->name) {\n\t\tFI_DBG(&core_prov, FI_LOG_CORE,\n\t\t       \"no provider structure or name\\n\");\n\t\tret = -FI_EINVAL;\n\t\tgoto cleanup;\n\t}\n\n\tFI_INFO(&core_prov, FI_LOG_CORE,\n\t       \"registering provider: %s (%d.%d)\\n\", provider->name,\n\t       FI_MAJOR(provider->version), FI_MINOR(provider->version));\n\n\tif (!provider->fabric) {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"provider missing mandatory entry points\\n\");\n\t\tret = -FI_EINVAL;\n\t\tgoto cleanup;\n\t}\n\n\t/* The current core implementation is not backward compatible\n\t * with providers that support a release earlier than v1.3.\n\t * See commit 0f4b6651.\n\t */\n\tif (provider->fi_version < FI_VERSION(1, 3)) {\n\t\tFI_INFO(&core_prov, FI_LOG_CORE,\n\t\t\t\"provider has unsupported FI version \"\n\t\t\t\"(provider %d.%d != libfabric %d.%d); ignoring\\n\",\n\t\t\tFI_MAJOR(provider->fi_version),\n\t\t\tFI_MINOR(provider->fi_version), FI_MAJOR_VERSION,\n\t\t\tFI_MINOR_VERSION);\n\n\t\tret = -FI_ENOSYS;\n\t\tgoto cleanup;\n\t}\n\n\tctx = (struct fi_prov_context *) &provider->context;\n\tofi_set_prov_type(ctx, provider);\n\n\tif (ofi_getinfo_filter(provider)) {\n\t\tFI_INFO(&core_prov, FI_LOG_CORE,\n\t\t\t\"\\\"%s\\\" filtered by provider include/exclude \"\n\t\t\t\"list, skipping\\n\", provider->name);\n\t\tret = -FI_ENODEV;\n\t\thidden = true;\n\t}\n\n\tif (ofi_apply_filter(&prov_log_filter, provider->name))\n\t\tctx->disable_logging = 1;\n\n\tprov = ofi_getprov(provider->name, strlen(provider->name));\n\tif (prov) {\n\t\t/* If this provider has not been init yet, then we add the\n\t\t * provider and dlhandle to the struct and exit.\n\t\t */\n\t\tif (prov->provider == NULL)\n\t\t\tgoto update_prov_registry;\n\n\t\t/* If this provider is older than an already-loaded\n\t\t * provider of the same name, then discard this one.\n\t\t */\n\t\tif (FI_VERSION_GE(prov->provider->version, provider->version)) {\n\t\t\tFI_INFO(&core_prov, FI_LOG_CORE,\n\t\t\t\t\"a newer %s provider was already loaded; \"\n\t\t\t\t\"ignoring this one\\n\", provider->name);\n\t\t\tret = -FI_EALREADY;\n\t\t\tgoto cleanup;\n\t\t}\n\n\t\t/* This provider is newer than an already-loaded\n\t\t * provider of the same name, so discard the\n\t\t * already-loaded one.\n\t\t */\n\t\tFI_INFO(&core_prov, FI_LOG_CORE,\n\t\t\t\"an older %s provider was already loaded; \"\n\t\t\t\"keeping this one and ignoring the older one\\n\",\n\t\t\tprovider->name);\n\t\tcleanup_provider(prov->provider, prov->dlhandle);\n\t} else {\n\t\tprov = ofi_create_prov_entry(provider->name);\n\t\tif (!prov) {\n\t\t\tret = -FI_EOTHER;\n\t\t\tgoto cleanup;\n\t\t}\n\t}\n\n\tif (hidden)\n\t\tprov->hidden = true;\n\nupdate_prov_registry:\n\tprov->dlhandle = dlhandle;\n\tprov->provider = provider;\n\treturn 0;\n\ncleanup:\n\tcleanup_provider(provider, dlhandle);\n\treturn ret;\n}\n\n#ifdef HAVE_LIBDL\nstatic int lib_filter(const struct dirent *entry)\n{\n\tsize_t l = strlen(entry->d_name);\n\tsize_t sfx = sizeof (FI_LIB_SUFFIX) - 1;\n\n\tif (l > sfx)\n\t\treturn !strcmp(&(entry->d_name[l-sfx]), FI_LIB_SUFFIX);\n\telse\n\t\treturn 0;\n}\n#endif\n\nstatic int verify_filter_names(char **names)\n{\n\tint i, j;\n\tchar** split_names;\n\tfor (i = 0; names[i]; i++) {\n\t\tsplit_names = ofi_split_and_alloc(names[i], \";\", NULL);\n\t\tif (!split_names) {\n\t\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\t\"unable to parse given filter string\\n\");\n\t\t\treturn -FI_ENODATA;\n\t\t}\n\n\t\tfor(j = 0; split_names[j]; j++) {\n\t\t\tif(!ofi_getprov(split_names[j], strlen(split_names[j]))) {\n\t\t\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\t\t\"provider %s is unknown, misspelled\"\n\t\t\t\t\t\" or DL provider?\\n\", split_names[j]);\n\t\t\t\tofi_suggest_prov_names(split_names[j]);\n\t\t\t}\n\t\t}\n\t\tofi_free_string_array(split_names);\n\t}\n\n\treturn FI_SUCCESS;\n}\n\nvoid ofi_free_filter(struct fi_filter *filter)\n{\n\tofi_free_string_array(filter->names);\n}\n\nvoid ofi_create_filter(struct fi_filter *filter, const char *raw_filter)\n{\n\tmemset(filter, 0, sizeof *filter);\n\tif (raw_filter == NULL)\n\t\treturn;\n\n\tif (*raw_filter == '^') {\n\t\tfilter->negated = 1;\n\t\t++raw_filter;\n\t}\n\n\tfilter->names = ofi_split_and_alloc(raw_filter, \",\", NULL);\n\tif (!filter->names)\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"unable to parse filter from: %s\\n\", raw_filter);\n\n\tif(verify_filter_names(filter->names))\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t        \"unable to verify filter name\\n\");\n}\n\n#ifdef HAVE_LIBDL\nstatic void ofi_ini_dir(const char *dir)\n{\n\tint n = 0;\n\tchar *lib;\n\tvoid *dlhandle;\n\tstruct dirent **liblist = NULL;\n\tstruct fi_provider* (*inif)(void);\n\n\tn = scandir(dir, &liblist, lib_filter, NULL);\n\tif (n < 0)\n\t\tgoto libdl_done;\n\n\twhile (n--) {\n\t\tif (asprintf(&lib, \"%s/%s\", dir, liblist[n]->d_name) < 0) {\n\t\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t       \"asprintf failed to allocate memory\\n\");\n\t\t\tgoto libdl_done;\n\t\t}\n\t\tFI_DBG(&core_prov, FI_LOG_CORE, \"opening provider lib %s\\n\", lib);\n\n\t\tdlhandle = dlopen(lib, RTLD_NOW);\n\t\tfree(liblist[n]);\n\t\tif (dlhandle == NULL) {\n\t\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t       \"dlopen(%s): %s\\n\", lib, dlerror());\n\t\t\tfree(lib);\n\t\t\tcontinue;\n\t\t}\n\t\tfree(lib);\n\n\t\tinif = dlsym(dlhandle, \"fi_prov_ini\");\n\t\tif (inif == NULL) {\n\t\t\tFI_WARN(&core_prov, FI_LOG_CORE, \"dlsym: %s\\n\", dlerror());\n\t\t\tdlclose(dlhandle);\n\t\t} else {\n\t\t\tofi_register_provider((inif)(), dlhandle);\n\t\t}\n\t}\n\nlibdl_done:\n\twhile (n-- > 0)\n\t\tfree(liblist[n]);\n\tfree(liblist);\n}\n#endif\n\nvoid fi_ini(void)\n{\n\tchar *param_val = NULL;\n\n\tpthread_mutex_lock(&common_locks.ini_lock);\n\n\tif (ofi_init)\n\t\tgoto unlock;\n\n\tofi_ordered_provs_init();\n\tfi_param_init();\n\tfi_log_init();\n\tofi_osd_init();\n\tofi_mem_init();\n\tofi_pmem_init();\n\tofi_perf_init();\n\tofi_hook_init();\n\tofi_monitor_init();\n\n\tfi_param_define(NULL, \"provider\", FI_PARAM_STRING,\n\t\t\t\"Only use specified provider (default: all available)\");\n\tfi_param_define(NULL, \"fork_unsafe\", FI_PARAM_BOOL,\n\t\t\t\"Whether use of fork() may be unsafe for some providers\"\n\t\t\t\" (default: no). Setting this to yes could improve\"\n\t\t\t\" performance at the expense of making fork() potentially\"\n\t\t\t\" unsafe\");\n\tfi_param_define(NULL, \"universe_size\", FI_PARAM_SIZE_T,\n\t\t\t\"Defines the maximum number of processes that will be\"\n\t\t\t\" used by distribute OFI application. The provider uses\"\n\t\t\t\" this to optimize resource allocations\"\n\t\t\t\" (default: OFI service specific)\");\n\tfi_param_get_str(NULL, \"provider\", &param_val);\n\tofi_create_filter(&prov_filter, param_val);\n\n#ifdef HAVE_LIBDL\n\tint n = 0;\n\tchar **dirs;\n\tchar *provdir = NULL;\n\tvoid *dlhandle;\n\n\t/* If dlopen fails, assume static linking and just return\n\t   without error */\n\tdlhandle = dlopen(NULL, RTLD_NOW);\n\tif (dlhandle == NULL) {\n\t\tgoto libdl_done;\n\t}\n\tdlclose(dlhandle);\n\n\tfi_param_define(NULL, \"provider_path\", FI_PARAM_STRING,\n\t\t\t\"Search for providers in specific path (default: \"\n\t\t\tPROVDLDIR \")\");\n\tfi_param_get_str(NULL, \"provider_path\", &provdir);\n\tif (!provdir)\n\t\tprovdir = PROVDLDIR;\n\n\tdirs = ofi_split_and_alloc(provdir, \":\", NULL);\n\tif (dirs) {\n\t\tfor (n = 0; dirs[n]; ++n) {\n\t\t\tofi_ini_dir(dirs[n]);\n\t\t}\n\t\tofi_free_string_array(dirs);\n\t}\nlibdl_done:\n#endif\n\n\tofi_register_provider(PSM2_INIT, NULL);\n\tofi_register_provider(PSM_INIT, NULL);\n\tofi_register_provider(USNIC_INIT, NULL);\n\tofi_register_provider(GNI_INIT, NULL);\n\tofi_register_provider(BGQ_INIT, NULL);\n\tofi_register_provider(NETDIR_INIT, NULL);\n\tofi_register_provider(SHM_INIT, NULL);\n\tofi_register_provider(RXM_INIT, NULL);\n\tofi_register_provider(VERBS_INIT, NULL);\n\t/* ofi_register_provider(RSTREAM_INIT, NULL); - no support */\n\tofi_register_provider(MRAIL_INIT, NULL);\n\tofi_register_provider(RXD_INIT, NULL);\n\tofi_register_provider(EFA_INIT, NULL);\n\tofi_register_provider(UDP_INIT, NULL);\n\tofi_register_provider(SOCKETS_INIT, NULL);\n\tofi_register_provider(TCP_INIT, NULL);\n\n\tofi_register_provider(HOOK_PERF_INIT, NULL);\n\tofi_register_provider(HOOK_DEBUG_INIT, NULL);\n\tofi_register_provider(HOOK_NOOP_INIT, NULL);\n\n\tofi_init = 1;\n\nunlock:\n\tpthread_mutex_unlock(&common_locks.ini_lock);\n}\n\nFI_DESTRUCTOR(fi_fini(void))\n{\n\tstruct ofi_prov *prov;\n\n\tif (!ofi_init)\n\t\treturn;\n\n\twhile (prov_head) {\n\t\tprov = prov_head;\n\t\tprov_head = prov->next;\n\t\tcleanup_provider(prov->provider, prov->dlhandle);\n\t\tfree(prov->prov_name);\n\t\tfree(prov);\n\t}\n\n\tofi_free_filter(&prov_filter);\n\tofi_monitor_cleanup();\n\tofi_mem_fini();\n\tfi_log_fini();\n\tfi_param_fini();\n\tofi_osd_fini();\n}\n\n__attribute__((visibility (\"default\"),EXTERNALLY_VISIBLE))\nvoid DEFAULT_SYMVER_PRE(fi_freeinfo)(struct fi_info *info)\n{\n\tstruct fi_info *next;\n\n\tfor (; info; info = next) {\n\t\tnext = info->next;\n\n\t\tfree(info->src_addr);\n\t\tfree(info->dest_addr);\n\t\tfree(info->tx_attr);\n\t\tfree(info->rx_attr);\n\t\tif (info->ep_attr) {\n\t\t\tfree(info->ep_attr->auth_key);\n\t\t\tfree(info->ep_attr);\n\t\t}\n\t\tif (info->domain_attr) {\n\t\t\tfree(info->domain_attr->auth_key);\n\t\t\tfree(info->domain_attr->name);\n\t\t\tfree(info->domain_attr);\n\t\t}\n\t\tif (info->fabric_attr) {\n\t\t\tfree(info->fabric_attr->name);\n\t\t\tfree(info->fabric_attr->prov_name);\n\t\t\tfree(info->fabric_attr);\n\t\t}\n\t\tif (info->nic &&\n\t\t    FI_CHECK_OP(info->nic->fid.ops, struct fi_ops, close)) {\n\t\t\tfi_close(&info->nic->fid);\n\t\t}\n\t\tfree(info);\n\t}\n}\nCURRENT_SYMVER(fi_freeinfo_, fi_freeinfo);\n\n/*\n * Make a dummy info object for each provider, and copy in the\n * provider name and version.  We report utility providers directly\n * to export their version.\n */\nstatic int ofi_getprovinfo(struct fi_info **info)\n{\n\tstruct ofi_prov *prov;\n\tstruct fi_info *tail, *cur;\n\tint ret = -FI_ENODATA;\n\n\t*info = tail = NULL;\n\tfor (prov = prov_head; prov; prov = prov->next) {\n\t\tif (!prov->provider)\n\t\t\tcontinue;\n\n\t\tcur = fi_allocinfo();\n\t\tif (!cur) {\n\t\t\tret = -FI_ENOMEM;\n\t\t\tgoto err;\n\t\t}\n\n\t\tcur->fabric_attr->prov_name = strdup(prov->provider->name);\n\t\tcur->fabric_attr->prov_version = prov->provider->version;\n\n\t\tif (!*info) {\n\t\t\t*info = tail = cur;\n\t\t} else {\n\t\t\ttail->next = cur;\n\t\t}\n\t\ttail = cur;\n\n\t\tret = 0;\n\t}\n\n\treturn ret;\n\nerr:\n\twhile (tail) {\n\t\tcur = tail->next;\n\t\tfi_freeinfo(tail);\n\t\ttail = cur;\n\t}\n\treturn ret;\n}\n\nstatic void ofi_set_prov_attr(struct fi_fabric_attr *attr,\n\t\t\t      struct fi_provider *prov)\n{\n\tchar *core_name;\n\n\tcore_name = attr->prov_name;\n\tif (core_name) {\n\t\tassert(ofi_is_util_prov(prov));\n\t\tattr->prov_name = ofi_strdup_append(core_name, prov->name);\n\t\tfree(core_name);\n\t} else {\n\t\tassert(ofi_is_core_prov(prov));\n\t\tattr->prov_name = strdup(prov->name);\n\t}\n\tattr->prov_version = prov->version;\n}\n\n/*\n * The layering of utility providers over core providers follows these rules.\n * 0. Provider names are delimited by \";\"\n * 1. Rules when # of providers <= 2:\n *    1a. If both are specified, then only return that layering\n *    1b. If a utility provider is specified, return it over any* core provider.\n *    1c. If a core provider is specified, return any utility provider that can\n *        layer over it, plus the core provider itself, if possible.\n *    1d. A utility provider will not layer over the sockets provider unless the\n *        user explicitly requests that combination.\n *    1e. OFI_CORE_PROV_ONLY flag prevents utility providers layering over other\n *        utility providers.\n * 2. If both the providers are utility providers or if more than two providers\n *    are specified, the rightmost provider would be compared.\n * 3. If any provider has a caret symbol \"^\" is prefixed before any provider\n *    name it would be excluded (internal use only). These excluded providers\n *    should be listed only at the end.\n */\nstatic int ofi_layering_ok(const struct fi_provider *provider,\n\t\t\t   char **prov_vec, size_t count,\n\t\t\t   uint64_t flags)\n{\n\tchar *prov_name;\n\tint i;\n\n\t/* Excluded providers must be at the end */\n\tfor (i = count - 1; i >= 0; i--) {\n\t\tif (prov_vec[i][0] != '^')\n\t\t    break;\n\n\t\tif (!strcasecmp(&prov_vec[i][1], provider->name))\n\t\t\treturn 0;\n\t}\n\tcount = i + 1;\n\n\tif (flags & OFI_CORE_PROV_ONLY) {\n\t\tassert((count == 1) || (count == 0));\n\t\tif (!ofi_is_core_prov(provider)) {\n\t\t\tFI_INFO(&core_prov, FI_LOG_CORE,\n\t\t\t\t\"Need core provider, skipping %s\\n\",\n\t\t\t\tprovider->name);\n\t\t\treturn 0;\n\t\t}\n\n\t\tif ((count == 0) && !strcasecmp(provider->name, \"sockets\")) {\n\t\t\tFI_INFO(&core_prov, FI_LOG_CORE,\n\t\t\t\t\"Skipping util;sockets layering\\n\");\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tif (!count)\n\t\treturn 1;\n\n\t/* To maintain backward compatibility with the previous behavior of\n\t * ofi_layering_ok we need to check if the # of providers is two or\n\t * fewer. In such a case, we have to be agnostic to the ordering of\n\t * core and utility providers */\n\n\tif ((count == 1) && ofi_is_util_prov(provider) &&\n\t    !ofi_has_util_prefix(prov_vec[0])) {\n\t\tif (!strcasecmp(prov_vec[0], \"sockets\")) {\n\t\t\tFI_INFO(&core_prov, FI_LOG_CORE,\n\t\t\t\t\"Sockets requested, skipping util layering\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\tif (!strcasecmp(prov_vec[0], \"shm\")) {\n\t\t\tFI_INFO(&core_prov, FI_LOG_CORE,\n\t\t\t\t\"Shm requested, skipping util layering\\n\");\n\t\t\treturn 0;\n\t\t}\n\t\treturn 1;\n\t}\n\n\tif ((count == 2) && ofi_has_util_prefix(prov_vec[0]) &&\n\t    !ofi_has_util_prefix(prov_vec[1]))\n\t\tprov_name = prov_vec[0];\n\telse\n\t\tprov_name = prov_vec[count - 1];\n\n\treturn !strcasecmp(provider->name, prov_name);\n}\n\n__attribute__((visibility (\"default\"),EXTERNALLY_VISIBLE))\nint DEFAULT_SYMVER_PRE(fi_getinfo)(uint32_t version, const char *node,\n\t\tconst char *service, uint64_t flags,\n\t\tconst struct fi_info *hints, struct fi_info **info)\n{\n\tstruct ofi_prov *prov;\n\tstruct fi_info *tail, *cur;\n\tchar **prov_vec = NULL;\n\tsize_t count = 0;\n\tenum fi_log_level level;\n\tint ret;\n\n\tif (!ofi_init)\n\t\tfi_ini();\n\n\tif (FI_VERSION_LT(fi_version(), version)) {\n\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\"Requested version is newer than library\\n\");\n\t\treturn -FI_ENOSYS;\n\t}\n\n\tif (flags == FI_PROV_ATTR_ONLY) {\n\t\treturn ofi_getprovinfo(info);\n\t}\n\n\tif (hints && hints->fabric_attr && hints->fabric_attr->prov_name) {\n\t\tprov_vec = ofi_split_and_alloc(hints->fabric_attr->prov_name,\n\t\t\t\t\t       \";\", &count);\n\t\tif (!prov_vec)\n\t\t\treturn -FI_ENOMEM;\n\t\tFI_DBG(&core_prov, FI_LOG_CORE, \"hints prov_name: %s\\n\",\n\t\t       hints->fabric_attr->prov_name);\n\t}\n\n\t*info = tail = NULL;\n\tfor (prov = prov_head; prov; prov = prov->next) {\n\t\tif (!prov->provider || !prov->provider->getinfo)\n\t\t\tcontinue;\n\n\t\tif (prov->hidden && !(flags & OFI_GETINFO_HIDDEN))\n\t\t\tcontinue;\n\n\t\tif (!ofi_layering_ok(prov->provider, prov_vec, count, flags))\n\t\t\tcontinue;\n\n\t\tif (FI_VERSION_LT(prov->provider->fi_version, version)) {\n\t\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\t\"Provider %s fi_version %d.%d < requested %d.%d\\n\",\n\t\t\t\tprov->provider->name,\n\t\t\t\tFI_MAJOR(prov->provider->fi_version),\n\t\t\t\tFI_MINOR(prov->provider->fi_version),\n\t\t\t\tFI_MAJOR(version), FI_MINOR(version));\n\t\t\tcontinue;\n\t\t}\n\n\t\tret = prov->provider->getinfo(version, node, service, flags,\n\t\t\t\t\t      hints, &cur);\n\t\tif (ret) {\n\t\t\tlevel = ((hints && hints->fabric_attr &&\n\t\t\t\t  hints->fabric_attr->prov_name) ?\n\t\t\t\t FI_LOG_WARN : FI_LOG_INFO);\n\n\t\t\tFI_LOG(&core_prov, level, FI_LOG_CORE,\n\t\t\t       \"fi_getinfo: provider %s returned -%d (%s)\\n\",\n\t\t\t       prov->provider->name, -ret, fi_strerror(-ret));\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (!cur) {\n\t\t\tFI_WARN(&core_prov, FI_LOG_CORE,\n\t\t\t\t\"fi_getinfo: provider %s output empty list\\n\",\n\t\t\t\tprov->provider->name);\n\t\t\tcontinue;\n\t\t}\n\n\t\tFI_DBG(&core_prov, FI_LOG_CORE, \"fi_getinfo: provider %s \"\n\t\t       \"returned success\\n\", prov->provider->name);\n\n\t\tif (!*info)\n\t\t\t*info = cur;\n\t\telse\n\t\t\ttail->next = cur;\n\n\t\tfor (tail = cur; tail->next; tail = tail->next) {\n\t\t\tofi_set_prov_attr(tail->fabric_attr, prov->provider);\n\t\t\ttail->fabric_attr->api_version = version;\n\t\t}\n\t\tofi_set_prov_attr(tail->fabric_attr, prov->provider);\n\t\ttail->fabric_attr->api_version = version;\n\t}\n\tofi_free_string_array(prov_vec);\n\n\tif (!(flags & (OFI_CORE_PROV_ONLY | OFI_GETINFO_INTERNAL |\n\t               OFI_GETINFO_HIDDEN)))\n\t\tofi_filter_info(info);\n\n\treturn *info ? 0 : -FI_ENODATA;\n}\nCURRENT_SYMVER(fi_getinfo_, fi_getinfo);\n\nstruct fi_info *ofi_allocinfo_internal(void)\n{\n\tstruct fi_info *info;\n\n\tinfo = calloc(1, sizeof(*info));\n\tif (!info)\n\t\treturn NULL;\n\n\tinfo->tx_attr = calloc(1, sizeof(*info->tx_attr));\n\tinfo->rx_attr = calloc(1, sizeof(*info->rx_attr));\n\tinfo->ep_attr = calloc(1, sizeof(*info->ep_attr));\n\tinfo->domain_attr = calloc(1, sizeof(*info->domain_attr));\n\tinfo->fabric_attr = calloc(1, sizeof(*info->fabric_attr));\n\tif (!info->tx_attr|| !info->rx_attr || !info->ep_attr ||\n\t    !info->domain_attr || !info->fabric_attr)\n\t\tgoto err;\n\n\treturn info;\nerr:\n\tfi_freeinfo(info);\n\treturn NULL;\n}\n\n\n__attribute__((visibility (\"default\"),EXTERNALLY_VISIBLE))\nstruct fi_info *DEFAULT_SYMVER_PRE(fi_dupinfo)(const struct fi_info *info)\n{\n\tstruct fi_info *dup;\n\tint ret;\n\n\tif (!info)\n\t\treturn ofi_allocinfo_internal();\n\n\tdup = mem_dup(info, sizeof(*dup));\n\tif (dup == NULL) {\n\t\treturn NULL;\n\t}\n\tdup->src_addr = NULL;\n\tdup->dest_addr = NULL;\n\tdup->tx_attr = NULL;\n\tdup->rx_attr = NULL;\n\tdup->ep_attr = NULL;\n\tdup->domain_attr = NULL;\n\tdup->fabric_attr = NULL;\n\tdup->next = NULL;\n\n\tif (info->src_addr != NULL) {\n\t\tdup->src_addr = mem_dup(info->src_addr, info->src_addrlen);\n\t\tif (dup->src_addr == NULL)\n\t\t\tgoto fail;\n\t}\n\tif (info->dest_addr != NULL) {\n\t\tdup->dest_addr = mem_dup(info->dest_addr, info->dest_addrlen);\n\t\tif (dup->dest_addr == NULL)\n\t\t\tgoto fail;\n\t}\n\tif (info->tx_attr != NULL) {\n\t\tdup->tx_attr = mem_dup(info->tx_attr, sizeof(*info->tx_attr));\n\t\tif (dup->tx_attr == NULL)\n\t\t\tgoto fail;\n\t}\n\tif (info->rx_attr != NULL) {\n\t\tdup->rx_attr = mem_dup(info->rx_attr, sizeof(*info->rx_attr));\n\t\tif (dup->rx_attr == NULL)\n\t\t\tgoto fail;\n\t}\n\tif (info->ep_attr != NULL) {\n\t\tdup->ep_attr = mem_dup(info->ep_attr, sizeof(*info->ep_attr));\n\t\tif (dup->ep_attr == NULL)\n\t\t\tgoto fail;\n\t\tif (info->ep_attr->auth_key != NULL) {\n\t\t\tdup->ep_attr->auth_key =\n\t\t\t\tmem_dup(info->ep_attr->auth_key,\n\t\t\t\t\tinfo->ep_attr->auth_key_size);\n\t\t\tif (dup->ep_attr->auth_key == NULL)\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\tif (info->domain_attr) {\n\t\tdup->domain_attr = mem_dup(info->domain_attr,\n\t\t\t\t\t   sizeof(*info->domain_attr));\n\t\tif (dup->domain_attr == NULL)\n\t\t\tgoto fail;\n\t\tdup->domain_attr->name = NULL;\n\t\tdup->domain_attr->auth_key = NULL;\n\t\tif (info->domain_attr->name != NULL) {\n\t\t\tdup->domain_attr->name = strdup(info->domain_attr->name);\n\t\t\tif (dup->domain_attr->name == NULL)\n\t\t\t\tgoto fail;\n\t\t}\n\t\tif (info->domain_attr->auth_key != NULL) {\n\t\t\tdup->domain_attr->auth_key =\n\t\t\t\tmem_dup(info->domain_attr->auth_key,\n\t\t\t\t\tinfo->domain_attr->auth_key_size);\n\t\t\tif (dup->domain_attr->auth_key == NULL)\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\tif (info->fabric_attr) {\n\t\tdup->fabric_attr = mem_dup(info->fabric_attr,\n\t\t\t\t\t   sizeof(*info->fabric_attr));\n\t\tif (dup->fabric_attr == NULL)\n\t\t\tgoto fail;\n\t\tdup->fabric_attr->name = NULL;\n\t\tdup->fabric_attr->prov_name = NULL;\n\t\tif (info->fabric_attr->name != NULL) {\n\t\t\tdup->fabric_attr->name = strdup(info->fabric_attr->name);\n\t\t\tif (dup->fabric_attr->name == NULL)\n\t\t\t\tgoto fail;\n\t\t}\n\t\tif (info->fabric_attr->prov_name != NULL) {\n\t\t\tdup->fabric_attr->prov_name = strdup(info->fabric_attr->prov_name);\n\t\t\tif (dup->fabric_attr->prov_name == NULL)\n\t\t\t\tgoto fail;\n\t\t}\n\t}\n\n\tif (info->nic) {\n\t\tret = fi_control(&info->nic->fid, FI_DUP, &dup->nic);\n\t\tif (ret && ret != -FI_ENOSYS)\n\t\t\tgoto fail;\n\t}\n\n\treturn dup;\n\nfail:\n\tfi_freeinfo(dup);\n\treturn NULL;\n}\nCURRENT_SYMVER(fi_dupinfo_, fi_dupinfo);\n\n__attribute__((visibility (\"default\"),EXTERNALLY_VISIBLE))\nint DEFAULT_SYMVER_PRE(fi_fabric)(struct fi_fabric_attr *attr,\n\t\tstruct fid_fabric **fabric, void *context)\n{\n\tstruct ofi_prov *prov;\n\tconst char *top_name;\n\tint ret;\n\n\tif (!attr || !attr->prov_name || !attr->name)\n\t\treturn -FI_EINVAL;\n\n\tif (!ofi_init)\n\t\tfi_ini();\n\n\ttop_name = strrchr(attr->prov_name, OFI_NAME_DELIM);\n\tif (top_name)\n\t\ttop_name++;\n\telse\n\t\ttop_name = attr->prov_name;\n\n\tif (!top_name)\n\t\treturn -FI_EINVAL;\n\n\tprov = ofi_getprov(top_name, strlen(top_name));\n\tif (!prov || !prov->provider || !prov->provider->fabric)\n\t\treturn -FI_ENODEV;\n\n\tret = prov->provider->fabric(attr, fabric, context);\n\tif (!ret) {\n\t\tif (FI_VERSION_GE(prov->provider->fi_version, FI_VERSION(1, 5)))\n\t\t\t(*fabric)->api_version = attr->api_version;\n\t\tFI_INFO(&core_prov, FI_LOG_CORE, \"Opened fabric: %s\\n\",\n\t\t\tattr->name);\n\n\t\tofi_hook_install(*fabric, fabric, prov->provider);\n\t}\n\n\treturn ret;\n}\nDEFAULT_SYMVER(fi_fabric_, fi_fabric, FABRIC_1.1);\n\n__attribute__((visibility (\"default\"),EXTERNALLY_VISIBLE))\nuint32_t DEFAULT_SYMVER_PRE(fi_version)(void)\n{\n\treturn FI_VERSION(FI_MAJOR_VERSION, FI_MINOR_VERSION);\n}\nDEFAULT_SYMVER(fi_version_, fi_version, FABRIC_1.0);\n\nstatic const char *const errstr[] = {\n\t[FI_EOTHER - FI_ERRNO_OFFSET] = \"Unspecified error\",\n\t[FI_ETOOSMALL - FI_ERRNO_OFFSET] = \"Provided buffer is too small\",\n\t[FI_EOPBADSTATE - FI_ERRNO_OFFSET] = \"Operation not permitted in current state\",\n\t[FI_EAVAIL - FI_ERRNO_OFFSET]  = \"Error available\",\n\t[FI_EBADFLAGS - FI_ERRNO_OFFSET] = \"Flags not supported\",\n\t[FI_ENOEQ - FI_ERRNO_OFFSET] = \"Missing or unavailable event queue\",\n\t[FI_EDOMAIN - FI_ERRNO_OFFSET] = \"Invalid resource domain\",\n\t[FI_ENOCQ - FI_ERRNO_OFFSET] = \"Missing or unavailable completion queue\",\n\t[FI_ECRC - FI_ERRNO_OFFSET] = \"CRC error\",\n\t[FI_ETRUNC - FI_ERRNO_OFFSET] = \"Truncation error\",\n\t[FI_ENOKEY - FI_ERRNO_OFFSET] = \"Required key not available\",\n\t[FI_ENOAV - FI_ERRNO_OFFSET] = \"Missing or unavailable address vector\",\n\t[FI_EOVERRUN - FI_ERRNO_OFFSET] = \"Queue has been overrun\",\n};\n\n__attribute__((visibility (\"default\"),EXTERNALLY_VISIBLE))\nconst char *DEFAULT_SYMVER_PRE(fi_strerror)(int errnum)\n{\n\tif (errnum < FI_ERRNO_OFFSET)\n\t\treturn strerror(errnum);\n\telse if (errnum < FI_ERRNO_MAX)\n\t\treturn errstr[errnum - FI_ERRNO_OFFSET];\n\telse\n\t\treturn errstr[FI_EOTHER - FI_ERRNO_OFFSET];\n}\nDEFAULT_SYMVER(fi_strerror_, fi_strerror, FABRIC_1.0);\n",
        "/tmp/vanessa/spack-stage/spack-stage-sst-transports-master-vyyr2p4k4qxfkfbhioaigxalm7gjy6vh/spack-src/libfabric/prov/util/src/util_mem_hooks.c": "/*\n * Copyright (c) 2016 Los Alamos National Security, LLC. All rights reserved.\n * Copyright (c) 2019 Intel Corporation, Inc.  All rights reserved.\n *\n * License text from Open-MPI (www.open-mpi.org/community/license.php)\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are\n * met:\n *\n * - Redistributions of source code must retain the above copyright\n * notice, this list of conditions and the following disclaimer.\n *\n * - Redistributions in binary form must reproduce the above copyright\n * notice, this list of conditions and the following disclaimer listed\n * in this license in the documentation and/or other materials\n * provided with the distribution.\n *\n * - Neither the name of the copyright holders nor the names of its\n * contributors may be used to endorse or promote products derived from\n * this software without specific prior written permission.\n *\n * The copyright holders provide no reassurances that the source code\n * provided does not infringe any patent, copyright, or any other\n * intellectual property rights of third parties.  The copyright holders\n * disclaim any liability to any recipient for claims brought against\n * recipient by any third party for infringement of that parties\n * intellectual property rights.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n * \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR\n * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT\n * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,\n * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\n * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY\n * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE\n * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n#include <ofi_mr.h>\n\nstruct ofi_memhooks memhooks;\nstruct ofi_mem_monitor *memhooks_monitor = &memhooks.monitor;\n\n\n#if defined(__linux__) && defined(HAVE_ELF_H) && defined(HAVE_SYS_AUXV_H)\n\n#include <elf.h>\n#include <sys/auxv.h>\n#include <sys/mman.h>\n#include <sys/syscall.h>\n#include <sys/types.h>\n#include <sys/shm.h>\n#include <unistd.h>\n#include <dlfcn.h>\n#include <fcntl.h>\n#include <link.h>\n\n\nstruct ofi_intercept {\n\tstruct dlist_entry \t\tentry;\n\tconst char\t\t\t*symbol;\n\tvoid\t\t\t\t*our_func;\n\tstruct dlist_entry\t\tdl_intercept_list;\n};\n\nstruct ofi_dl_intercept {\n\tstruct dlist_entry \t\tentry;\n\tvoid \t\t\t\t**dl_func_addr;\n\tvoid\t\t\t\t*dl_func;\n};\n\nenum {\n\tOFI_INTERCEPT_DLOPEN,\n\tOFI_INTERCEPT_MMAP,\n\tOFI_INTERCEPT_MUNMAP,\n\tOFI_INTERCEPT_MREMAP,\n\tOFI_INTERCEPT_MADVISE,\n\tOFI_INTERCEPT_SHMAT,\n\tOFI_INTERCEPT_SHMDT,\n\tOFI_INTERCEPT_BRK,\n\tOFI_INTERCEPT_MAX\n};\n\nstatic void *ofi_intercept_dlopen(const char *filename, int flag);\nstatic void *ofi_intercept_mmap(void *start, size_t length,\n\t\t\t\tint prot, int flags, int fd, off_t offset);\nstatic int ofi_intercept_munmap(void *start, size_t length);\nstatic void *ofi_intercept_mremap(void *old_address, size_t old_size,\n\t\tsize_t new_size, int flags, void *new_address);\nstatic int ofi_intercept_madvise(void *addr, size_t length, int advice);\nstatic void *ofi_intercept_shmat(int shmid, const void *shmaddr, int shmflg);\nstatic int ofi_intercept_shmdt(const void *shmaddr);\nstatic int ofi_intercept_brk(const void *brkaddr);\n\nstatic struct ofi_intercept intercepts[] = {\n\t[OFI_INTERCEPT_DLOPEN] = { .symbol = \"dlopen\",\n\t\t\t\t.our_func = ofi_intercept_dlopen},\n\t[OFI_INTERCEPT_MMAP] = { .symbol = \"mmap\",\n\t\t\t\t.our_func = ofi_intercept_mmap},\n\t[OFI_INTERCEPT_MUNMAP] = { .symbol = \"munmap\",\n\t\t\t\t.our_func = ofi_intercept_munmap},\n\t[OFI_INTERCEPT_MREMAP] = { .symbol = \"mremap\",\n\t\t\t\t.our_func = ofi_intercept_mremap},\n\t[OFI_INTERCEPT_MADVISE] = { .symbol = \"madvise\",\n\t\t\t\t.our_func = ofi_intercept_madvise},\n\t[OFI_INTERCEPT_SHMAT] = { .symbol = \"shmat\",\n\t\t\t\t.our_func = ofi_intercept_shmat},\n\t[OFI_INTERCEPT_SHMDT] = { .symbol = \"shmdt\",\n\t\t\t\t.our_func = ofi_intercept_shmdt},\n\t[OFI_INTERCEPT_BRK] = { .symbol = \"brk\",\n\t\t\t\t.our_func = ofi_intercept_brk},\n};\n\nstruct ofi_mem_calls {\n\tvoid *(*dlopen) (const char *, int);\n\tvoid *(*mmap)(void *, size_t, int, int, int, off_t);\n\tint (*munmap)(void *, size_t);\n\tvoid *(*mremap)(void *old_address, size_t old_size,\n\t\t\tsize_t new_size, int flags, ... /* void *new_address */ );\n\tint (*madvise)(void *addr, size_t length, int advice);\n\tvoid *(*shmat)(int shmid, const void *shmaddr, int shmflg);\n\tint (*shmdt)(const void *shmaddr);\n\tint (*brk)(const void *brkaddr);\n};\n\nstatic struct ofi_mem_calls real_calls;\n\n\nstatic const ElfW(Phdr) *\nofi_get_phdr_dynamic(const ElfW(Phdr) *phdr, uint16_t phnum, int phent)\n{\n\tuint16_t i;\n\n\tfor (i = 0 ; i < phnum; i++) {\n\t\tif (phdr->p_type == PT_DYNAMIC)\n\t\t\treturn phdr;\n\t\tphdr = (ElfW(Phdr)*) ((intptr_t) phdr + phent);\n\t}\n\n\treturn NULL;\n}\n\nstatic void *ofi_get_dynentry(ElfW(Addr) base, const ElfW(Phdr) *pdyn,\n\t\t\t      ElfW(Sxword) type)\n{\n\tElfW(Dyn) *dyn;\n\n\tfor (dyn = (ElfW(Dyn)*) (base + pdyn->p_vaddr); dyn->d_tag; ++dyn) {\n\t\tif (dyn->d_tag == type)\n\t\t\treturn (void *) (uintptr_t) dyn->d_un.d_val;\n\t}\n\n\treturn NULL;\n}\n\n#if SIZE_MAX > UINT_MAX\n#define OFI_ELF_R_SYM ELF64_R_SYM\n#else\n#define OFI_ELF_R_SYM ELF32_R_SYM\n#endif\n\nstatic void *ofi_dl_func_addr(ElfW(Addr) base, const ElfW(Phdr) *phdr,\n\t\t\t      int16_t phnum, int phent, const char *symbol)\n{\n\tconst ElfW(Phdr) *dphdr;\n\tElfW(Rela) *reloc;\n\tvoid *jmprel, *strtab;\n\tchar *elf_sym;\n\tuint32_t relsymidx;\n\tElfW(Sym) *symtab;\n\tsize_t pltrelsz;\n\n\tdphdr = ofi_get_phdr_dynamic(phdr, phnum, phent);\n\tjmprel = ofi_get_dynentry(base, dphdr, DT_JMPREL);\n\tsymtab = (ElfW(Sym) *) ofi_get_dynentry(base, dphdr, DT_SYMTAB);\n\tstrtab = ofi_get_dynentry (base, dphdr, DT_STRTAB);\n\tpltrelsz = (uintptr_t) ofi_get_dynentry(base, dphdr, DT_PLTRELSZ);\n\n\tfor (reloc = jmprel; (intptr_t) reloc < (intptr_t) jmprel + pltrelsz;\n\t     reloc++) {\n\t\trelsymidx = OFI_ELF_R_SYM(reloc->r_info);\n\t\telf_sym = (char *) strtab + symtab[relsymidx].st_name;\n\t\tif (!strcmp(symbol, elf_sym))\n\t\t\treturn (void *) (base + reloc->r_offset);\n        }\n\n        return NULL;\n}\n\nstatic int ofi_intercept_dl_calls(ElfW(Addr) base, const ElfW(Phdr) *phdr,\n\t\t\t\t  const char *phname, int16_t phnum, int phent,\n\t\t\t\t  struct ofi_intercept *intercept)\n{\n\tstruct ofi_dl_intercept *dl_entry;\n\tlong page_size = ofi_get_page_size();\n\tvoid **func_addr, *page;\n\tint ret;\n\n\tFI_DBG(&core_prov, FI_LOG_MR,\n\t       \"intercepting symbol %s from dl\\n\", intercept->symbol);\n\tfunc_addr = ofi_dl_func_addr(base, phdr, phnum, phent, intercept->symbol);\n\tif (!func_addr)\n\t\treturn FI_SUCCESS;\n\n\tpage = (void *) ((intptr_t) func_addr & ~(page_size - 1));\n\tret = mprotect(page, page_size, PROT_READ | PROT_WRITE);\n\tif (ret < 0)\n\t\treturn -FI_ENOSYS;\n\n\tif (*func_addr != intercept->our_func) {\n\t\tdl_entry = malloc(sizeof(*dl_entry));\n\t\tif (!dl_entry)\n\t\t\treturn -FI_ENOMEM;\n\n\t\tdl_entry->dl_func_addr = func_addr;\n\t\tdl_entry->dl_func = *func_addr;\n\t\t*func_addr = intercept->our_func;\n\t\tdlist_insert_tail(&dl_entry->entry, &intercept->dl_intercept_list);\n\t}\n\n\treturn FI_SUCCESS;\n}\n\nstatic int ofi_intercept_phdr_handler(struct dl_phdr_info *info,\n                                    size_t size, void *data)\n{\n\tstruct ofi_intercept *intercept = data;\n\tint phent, ret;\n\n\tphent = getauxval(AT_PHENT);\n\tif (phent <= 0) {\n\t\tFI_DBG(&core_prov, FI_LOG_MR, \"failed to read phent size\");\n\t\treturn -FI_EINVAL;\n\t}\n\n\tret = ofi_intercept_dl_calls(info->dlpi_addr, info->dlpi_phdr,\n\t\t\t\t     info->dlpi_name, info->dlpi_phnum,\n\t\t\t\t     phent, intercept);\n\treturn ret;\n}\n\nstatic void *ofi_intercept_dlopen(const char *filename, int flag)\n{\n\tstruct ofi_intercept  *intercept;\n\tvoid *handle;\n\n\thandle = real_calls.dlopen(filename, flag);\n\tif (!handle)\n\t\treturn NULL;\n\n\tpthread_mutex_lock(&memhooks_monitor->lock);\n\tdlist_foreach_container(&memhooks.intercept_list, struct ofi_intercept,\n\t\tintercept, entry) {\n\t\tdl_iterate_phdr(ofi_intercept_phdr_handler, intercept);\n\t}\n\tpthread_mutex_unlock(&memhooks_monitor->lock);\n\treturn handle;\n}\n\nstatic int ofi_restore_dl_calls(ElfW(Addr) base, const ElfW(Phdr) *phdr,\n\t\t\t\tconst char *phname, int16_t phnum, int phent,\n\t\t\t\tstruct ofi_intercept *intercept)\n{\n\tstruct ofi_dl_intercept *dl_entry;\n\tlong page_size = ofi_get_page_size();\n\tvoid **func_addr, *page;\n\tint ret;\n\n\tFI_DBG(&core_prov, FI_LOG_MR,\n\t       \"releasing symbol %s from dl\\n\", intercept->symbol);\n\tfunc_addr = ofi_dl_func_addr(base, phdr, phnum, phent, intercept->symbol);\n\tif (!func_addr)\n\t\treturn FI_SUCCESS;\n\n\tpage = (void *) ((intptr_t) func_addr & ~(page_size - 1));\n\tret = mprotect(page, page_size, PROT_READ | PROT_WRITE);\n\tif (ret < 0)\n\t\treturn -FI_ENOSYS;\n\n\tdlist_foreach_container_reverse(&intercept->dl_intercept_list,\n\t\tstruct ofi_dl_intercept, dl_entry, entry) {\n\n\t\tif (dl_entry->dl_func_addr != func_addr)\n\t\t\tcontinue;\n\n\t\tassert(*func_addr == intercept->our_func);\n\t\t*func_addr = dl_entry->dl_func;\n\t\tdlist_remove(&dl_entry->entry);\n\t\tfree(dl_entry);\n\t\tFI_DBG(&core_prov, FI_LOG_MR,\n\t\t       \"dl symbol %s restored\\n\", intercept->symbol);\n\t\tbreak;\n\t}\n\n\treturn FI_SUCCESS;\n}\n\nstatic int ofi_restore_phdr_handler(struct dl_phdr_info *info,\n                                    size_t size, void *data)\n{\n\tstruct ofi_intercept *intercept = data;\n\tint phent, ret;\n\n\tphent = getauxval(AT_PHENT);\n\tif (phent <= 0) {\n\t\tFI_DBG(&core_prov, FI_LOG_MR, \"failed to read phent size\");\n\t\treturn -FI_EINVAL;\n\t}\n\n\tret = ofi_restore_dl_calls(info->dlpi_addr, info->dlpi_phdr,\n\t\t\t\t   info->dlpi_name, info->dlpi_phnum,\n\t\t\t\t   phent, intercept);\n\treturn ret;\n}\n\nstatic void ofi_restore_intercepts(void)\n{\n\tstruct ofi_intercept *intercept;\n\n\tdlist_foreach_container(&memhooks.intercept_list, struct ofi_intercept,\n\t\tintercept, entry) {\n\t\tdl_iterate_phdr(ofi_restore_phdr_handler, intercept);\n\t}\n}\n\nstatic int ofi_intercept_symbol(struct ofi_intercept *intercept, void **real_func)\n{\n\tint ret;\n\n\tFI_DBG(&core_prov, FI_LOG_MR,\n\t       \"intercepting symbol %s\\n\", intercept->symbol);\n\tret = dl_iterate_phdr(ofi_intercept_phdr_handler, intercept);\n\tif (ret)\n\t\treturn ret;\n\n\t*real_func = dlsym(RTLD_DEFAULT, intercept->symbol);\n\tif (*real_func == intercept->our_func) {\n\t\t(void) dlerror();\n\t\t*real_func = dlsym(RTLD_NEXT, intercept->symbol);\n\t}\n\n\tif (!*real_func) {\n\t\tFI_DBG(&core_prov, FI_LOG_MR,\n\t\t       \"could not find symbol %s\\n\", intercept->symbol);\n\t\tret = -FI_ENOMEM;\n\t\treturn ret;\n\t}\n\tdlist_insert_tail(&intercept->entry, &memhooks.intercept_list);\n\n\treturn ret;\n}\n\nvoid ofi_intercept_handler(const void *addr, size_t len)\n{\n\tpthread_mutex_lock(&memhooks_monitor->lock);\n\tofi_monitor_notify(memhooks_monitor, addr, len);\n\tpthread_mutex_unlock(&memhooks_monitor->lock);\n}\n\nstatic void *ofi_intercept_mmap(void *start, size_t length,\n                            int prot, int flags, int fd, off_t offset)\n{\n\tFI_DBG(&core_prov, FI_LOG_MR,\n\t       \"intercepted mmap start %p len %zu\\n\", start, length);\n\tofi_intercept_handler(start, length);\n\n\treturn real_calls.mmap(start, length, prot, flags, fd, offset);\n}\n\nstatic int ofi_intercept_munmap(void *start, size_t length)\n{\n\tFI_DBG(&core_prov, FI_LOG_MR,\n\t       \"intercepted munmap start %p len %zu\\n\", start, length);\n\tofi_intercept_handler(start, length);\n\n\treturn real_calls.munmap(start, length);\n}\n\nstatic void *ofi_intercept_mremap(void *old_address, size_t old_size,\n\t\tsize_t new_size, int flags, void *new_address)\n{\n\tFI_DBG(&core_prov, FI_LOG_MR,\n\t       \"intercepted mremap old_addr %p old_size %zu\\n\",\n\t       old_address, old_size);\n\tofi_intercept_handler(old_address, old_size);\n\n\treturn real_calls.mremap(old_address, old_size, new_size, flags,\n\t\t\t\t new_address);\n}\n\nstatic int ofi_intercept_madvise(void *addr, size_t length, int advice)\n{\n\tFI_DBG(&core_prov, FI_LOG_MR,\n\t       \"intercepted madvise addr %p len %zu\\n\", addr, length);\n\tofi_intercept_handler(addr, length);\n\n\treturn real_calls.madvise(addr, length, advice);\n}\n\nstatic void *ofi_intercept_shmat(int shmid, const void *shmaddr, int shmflg)\n{\n\tstruct shmid_ds ds;\n\tconst void *start;\n\tsize_t len;\n\tint ret;\n\n\tFI_DBG(&core_prov, FI_LOG_MR,\n\t       \"intercepted shmat addr %p\\n\", shmaddr);\n\n\tif (shmflg & SHM_REMAP) {\n\t\tret = shmctl(shmid, IPC_STAT, &ds);\n\t\tlen = (ret < 0) ? 0 : ds.shm_segsz;\n\n\t\tif (shmflg & SHM_RND) {\n\t\t\tstart = (char *) shmaddr + ((uintptr_t) shmaddr) % SHMLBA;\n\t\t\tlen += ((uintptr_t) shmaddr) % SHMLBA;\n\t\t} else {\n\t\t\tstart = shmaddr;\n\t\t}\n\n\t\tofi_intercept_handler(start, len);\n\t}\n\n\treturn real_calls.shmat(shmid, shmaddr, shmflg);\n}\n\nstatic int ofi_intercept_shmdt(const void *shmaddr)\n{\n\tFI_DBG(&core_prov, FI_LOG_MR,\n\t       \"intercepted shmdt addr %p\\n\", shmaddr);\n\t/* Overly aggressive, but simple.  Invalidate everything after shmaddr */\n\tofi_intercept_handler(shmaddr, SIZE_MAX - (uintptr_t) shmaddr);\n\n\treturn real_calls.shmdt(shmaddr);\n}\n\nstatic int ofi_intercept_brk(const void *brkaddr)\n{\n\tvoid *old_addr;\n\n\tFI_DBG(&core_prov, FI_LOG_MR,\n\t      \"intercepted brk addr %p\\n\", brkaddr);\n\n\told_addr = sbrk (0);\n\n\tif(brkaddr > old_addr) {\n\t\tofi_intercept_handler(brkaddr, (intptr_t) brkaddr -\n\t\t\t\t\t\t\t  (intptr_t) old_addr);\n\t}\n\n\treturn real_calls.brk(brkaddr);\n}\n\nstatic int ofi_memhooks_subscribe(struct ofi_mem_monitor *monitor,\n\t\t\t\t const void *addr, size_t len)\n{\n\t/* no-op */\n\treturn FI_SUCCESS;\n}\n\nstatic void ofi_memhooks_unsubscribe(struct ofi_mem_monitor *monitor,\n\t\t\t\t    const void *addr, size_t len)\n{\n\t/* no-op */\n}\n\nint ofi_memhooks_init(void)\n{\n\tint i, ret;\n\n\tif (memhooks_monitor->subscribe == ofi_memhooks_subscribe)\n\t\treturn 0;\n\n\tmemhooks_monitor->subscribe = ofi_memhooks_subscribe;\n\tmemhooks_monitor->unsubscribe = ofi_memhooks_unsubscribe;\n\tdlist_init(&memhooks.intercept_list);\n\n\tfor (i = 0; i < OFI_INTERCEPT_MAX; ++i)\n\t\tdlist_init(&intercepts[i].dl_intercept_list);\n\n\tret = ofi_intercept_symbol(&intercepts[OFI_INTERCEPT_DLOPEN],\n\t\t\t\t   (void **) &real_calls.dlopen);\n\tif (ret) {\n\t\tFI_WARN(&core_prov, FI_LOG_MR,\n\t\t       \"intercept dlopen failed %d %s\\n\", ret, fi_strerror(ret));\n\t\treturn ret;\n\t}\n\n\tret = ofi_intercept_symbol(&intercepts[OFI_INTERCEPT_MMAP],\n\t\t\t\t   (void **) &real_calls.mmap);\n\tif (ret) {\n\t\tFI_WARN(&core_prov, FI_LOG_MR,\n\t\t       \"intercept mmap failed %d %s\\n\", ret, fi_strerror(ret));\n\t\treturn ret;\n\t}\n\n\tret = ofi_intercept_symbol(&intercepts[OFI_INTERCEPT_MUNMAP],\n\t\t\t\t   (void **) &real_calls.munmap);\n\tif (ret) {\n\t\tFI_WARN(&core_prov, FI_LOG_MR,\n\t\t       \"intercept munmap failed %d %s\\n\", ret, fi_strerror(ret));\n\t\treturn ret;\n\t}\n\n\tret = ofi_intercept_symbol(&intercepts[OFI_INTERCEPT_MREMAP],\n\t\t\t\t   (void **) &real_calls.mremap);\n\tif (ret) {\n\t\tFI_WARN(&core_prov, FI_LOG_MR,\n\t\t       \"intercept mremap failed %d %s\\n\", ret, fi_strerror(ret));\n\t\treturn ret;\n\t}\n\n\tret = ofi_intercept_symbol(&intercepts[OFI_INTERCEPT_MADVISE],\n\t\t\t\t   (void **) &real_calls.madvise);\n\tif (ret) {\n\t\tFI_WARN(&core_prov, FI_LOG_MR,\n\t\t       \"intercept madvise failed %d %s\\n\", ret, fi_strerror(ret));\n\t\treturn ret;\n\t}\n\n\tret = ofi_intercept_symbol(&intercepts[OFI_INTERCEPT_SHMAT],\n\t\t\t\t   (void **) &real_calls.shmat);\n\tif (ret) {\n\t\tFI_WARN(&core_prov, FI_LOG_MR,\n\t\t       \"intercept shmat failed %d %s\\n\", ret, fi_strerror(ret));\n\t\treturn ret;\n\t}\n\n\tret = ofi_intercept_symbol(&intercepts[OFI_INTERCEPT_SHMDT],\n\t\t\t\t   (void **) &real_calls.shmdt);\n\tif (ret) {\n\t\tFI_WARN(&core_prov, FI_LOG_MR,\n\t\t       \"intercept shmdt failed %d %s\\n\", ret, fi_strerror(ret));\n\t\treturn ret;\n\t}\n\n\tret = ofi_intercept_symbol(&intercepts[OFI_INTERCEPT_BRK],\n\t\t\t\t   (void **) &real_calls.brk);\n\tif (ret) {\n\t\tFI_WARN(&core_prov, FI_LOG_MR,\n\t\t       \"intercept brk failed %d %s\\n\", ret, fi_strerror(ret));\n\t\treturn ret;\n\t}\n\n\treturn 0;\n}\n\nvoid ofi_memhooks_cleanup(void)\n{\n\tofi_restore_intercepts();\n\tmemhooks_monitor->subscribe = NULL;\n\tmemhooks_monitor->unsubscribe = NULL;\n}\n\n#else\n\nint ofi_memhooks_init(void)\n{\n\treturn -FI_ENOSYS;\n}\n\nvoid ofi_memhooks_cleanup(void)\n{\n}\n\n#endif\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-sst-transports-master-vyyr2p4k4qxfkfbhioaigxalm7gjy6vh/spack-src/.git/objects/pack/pack-96279371ea0624212ee78e7e907e491023e310bd.idx",
        "/tmp/vanessa/spack-stage/spack-stage-sst-transports-master-vyyr2p4k4qxfkfbhioaigxalm7gjy6vh/spack-src/.git/objects/pack/pack-96279371ea0624212ee78e7e907e491023e310bd.pack"
    ],
    "total_files": 171
}