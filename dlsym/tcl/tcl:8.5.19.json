{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-tcl-8.5.19-76icjut2bqpwmf2fnlt35uiqok46hbar/spack-src/compat/dlfcn.h": "/*\n * dlfcn.h --\n *\n *\tThis file provides a replacement for the header file \"dlfcn.h\"\n *\ton systems where dlfcn.h is missing.  It's primary use is for\n *\tAIX, where Tcl emulates the dl library.\n *\n *\tThis file is subject to the following copyright notice, which is\n *\tdifferent from the notice used elsewhere in Tcl but rougly\n *\tequivalent in meaning.\n *\n *\tCopyright (c) 1992,1993,1995,1996, Jens-Uwe Mager, Helios Software GmbH\n *\tNot derived from licensed software.\n *\n *\tPermission is granted to freely use, copy, modify, and redistribute\n *\tthis software, provided that the author is not construed to be liable\n *\tfor any results of using the software, alterations are clearly marked\n *\tas such, and this notice is not modified.\n */\n\n/*\n * This is an unpublished work copyright (c) 1992 HELIOS Software GmbH\n * 30159 Hannover, Germany\n */\n\n#ifndef __dlfcn_h__\n#define __dlfcn_h__\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/*\n * Mode flags for the dlopen routine.\n */\n#define RTLD_LAZY\t1\t/* lazy function call binding */\n#define RTLD_NOW\t2\t/* immediate function call binding */\n#define RTLD_GLOBAL\t0x100\t/* allow symbols to be global */\n\n/*\n * To be able to intialize, a library may provide a dl_info structure\n * that contains functions to be called to initialize and terminate.\n */\nstruct dl_info {\n\tvoid (*init) (void);\n\tvoid (*fini) (void);\n};\n\nvoid *dlopen (const char *path, int mode);\nvoid *dlsym (void *handle, const char *symbol);\nchar *dlerror (void);\nint dlclose (void *handle);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /* __dlfcn_h__ */\n",
        "/tmp/vanessa/spack-stage/spack-stage-tcl-8.5.19-76icjut2bqpwmf2fnlt35uiqok46hbar/spack-src/unix/tclLoadDyld.c": "/*\n * tclLoadDyld.c --\n *\n *\tThis procedure provides a version of the TclLoadFile that works with\n *\tApple's dyld dynamic loading.\n *\tOriginal version of his file (superseded long ago) provided by\n *\tWilfredo Sanchez (wsanchez@apple.com).\n *\n * Copyright (c) 1995 Apple Computer, Inc.\n * Copyright (c) 2001-2007 Daniel A. Steffen <das@users.sourceforge.net>\n *\n * See the file \"license.terms\" for information on usage and redistribution of\n * this file, and for a DISCLAIMER OF ALL WARRANTIES.\n */\n\n#include \"tclInt.h\"\n\n#ifndef MODULE_SCOPE\n#define MODULE_SCOPE extern\n#endif\n\n#ifndef TCL_DYLD_USE_DLFCN\n/*\n * Use preferred dlfcn API on 10.4 and later\n */\n#   if !defined(NO_DLFCN_H) && MAC_OS_X_VERSION_MAX_ALLOWED >= 1040\n#\tdefine TCL_DYLD_USE_DLFCN 1\n#   else\n#\tdefine TCL_DYLD_USE_DLFCN 0\n#   endif\n#endif\n#ifndef TCL_DYLD_USE_NSMODULE\n/*\n * Use deprecated NSModule API only to support 10.3 and earlier:\n */\n#   if MAC_OS_X_VERSION_MIN_REQUIRED < 1040\n#\tdefine TCL_DYLD_USE_NSMODULE 1\n#   else\n#\tdefine TCL_DYLD_USE_NSMODULE 0\n#   endif\n#endif\n\n#if TCL_DYLD_USE_DLFCN\n#include <dlfcn.h>\n#if defined(HAVE_WEAK_IMPORT) && MAC_OS_X_VERSION_MIN_REQUIRED < 1040\n/*\n * Support for weakly importing dlfcn API.\n */\nextern void *dlopen(const char *path, int mode) WEAK_IMPORT_ATTRIBUTE;\nextern void *dlsym(void *handle, const char *symbol) WEAK_IMPORT_ATTRIBUTE;\nextern int dlclose(void *handle) WEAK_IMPORT_ATTRIBUTE;\nextern char *dlerror(void) WEAK_IMPORT_ATTRIBUTE;\n#endif\n#endif\n\n#if TCL_DYLD_USE_NSMODULE || defined(TCL_LOAD_FROM_MEMORY)\n#include <mach-o/dyld.h>\n#include <mach-o/fat.h>\n#include <mach-o/swap.h>\n#include <mach-o/arch.h>\n#include <libkern/OSByteOrder.h>\n#include <mach/mach.h>\n#include <stdbool.h>\n\ntypedef struct Tcl_DyldModuleHandle {\n    struct Tcl_DyldModuleHandle *nextPtr;\n    NSModule module;\n} Tcl_DyldModuleHandle;\n#endif /* TCL_DYLD_USE_NSMODULE */\n\ntypedef struct Tcl_DyldLoadHandle {\n#if TCL_DYLD_USE_DLFCN\n    void *dlHandle;\n#endif\n#if TCL_DYLD_USE_NSMODULE || defined(TCL_LOAD_FROM_MEMORY)\n    const struct mach_header *dyldLibHeader;\n    Tcl_DyldModuleHandle *modulePtr;\n#endif\n} Tcl_DyldLoadHandle;\n\n#if (TCL_DYLD_USE_DLFCN && MAC_OS_X_VERSION_MIN_REQUIRED < 1040) || \\\n\tdefined(TCL_LOAD_FROM_MEMORY)\nMODULE_SCOPE long tclMacOSXDarwinRelease;\n#endif\n\n#ifdef TCL_DEBUG_LOAD\n#define TclLoadDbgMsg(m, ...) do { \\\n\t    fprintf(stderr, \"%s:%d: %s(): \" m \".\\n\", \\\n\t    strrchr(__FILE__, '/')+1, __LINE__, __func__, ##__VA_ARGS__); \\\n\t} while (0)\n#else\n#define TclLoadDbgMsg(m, ...)\n#endif\n\f\n#if TCL_DYLD_USE_NSMODULE || defined(TCL_LOAD_FROM_MEMORY)\n/*\n *----------------------------------------------------------------------\n *\n * DyldOFIErrorMsg --\n *\n *\tConverts a numerical NSObjectFileImage error into an error message\n *\tstring.\n *\n * Results:\n *\tError message string.\n *\n * Side effects:\n *\tNone.\n *\n *----------------------------------------------------------------------\n */\n\nstatic CONST char*\nDyldOFIErrorMsg(\n    int err)\n{\n    switch(err) {\n    case NSObjectFileImageSuccess:\n\treturn NULL;\n    case NSObjectFileImageFailure:\n\treturn \"object file setup failure\";\n    case NSObjectFileImageInappropriateFile:\n\treturn \"not a Mach-O MH_BUNDLE file\";\n    case NSObjectFileImageArch:\n\treturn \"no object for this architecture\";\n    case NSObjectFileImageFormat:\n\treturn \"bad object file format\";\n    case NSObjectFileImageAccess:\n\treturn \"can't read object file\";\n    default:\n\treturn \"unknown error\";\n    }\n}\n#endif /* TCL_DYLD_USE_NSMODULE */\n\f\n/*\n *----------------------------------------------------------------------\n *\n * TclpDlopen --\n *\n *\tDynamically loads a binary code file into memory and returns a handle\n *\tto the new code.\n *\n * Results:\n *\tA standard Tcl completion code. If an error occurs, an error message\n *\tis left in the interpreter's result.\n *\n * Side effects:\n *\tNew code suddenly appears in memory.\n *\n *----------------------------------------------------------------------\n */\n\nMODULE_SCOPE int\nTclpDlopen(\n    Tcl_Interp *interp,\t\t/* Used for error reporting. */\n    Tcl_Obj *pathPtr,\t\t/* Name of the file containing the desired\n\t\t\t\t * code (UTF-8). */\n    Tcl_LoadHandle *loadHandle, /* Filled with token for dynamically loaded\n\t\t\t\t * file which will be passed back to\n\t\t\t\t * (*unloadProcPtr)() to unload the file. */\n    Tcl_FSUnloadFileProc **unloadProcPtr)\n\t\t\t\t/* Filled with address of Tcl_FSUnloadFileProc\n\t\t\t\t * function which should be used for this\n\t\t\t\t * file. */\n{\n    Tcl_DyldLoadHandle *dyldLoadHandle;\n#if TCL_DYLD_USE_DLFCN\n    void *dlHandle = NULL;\n#endif\n#if TCL_DYLD_USE_NSMODULE || defined(TCL_LOAD_FROM_MEMORY)\n    const struct mach_header *dyldLibHeader = NULL;\n    Tcl_DyldModuleHandle *modulePtr = NULL;\n#endif\n#if TCL_DYLD_USE_NSMODULE\n    NSLinkEditErrors editError;\n    int errorNumber;\n    const char *errorName, *objFileImageErrMsg = NULL;\n#endif\n    const char *errMsg = NULL;\n    int result;\n    Tcl_DString ds;\n    char *fileName = NULL;\n    const char *nativePath, *nativeFileName = NULL;\n\n    /*\n     * First try the full path the user gave us. This is particularly\n     * important if the cwd is inside a vfs, and we are trying to load using a\n     * relative path.\n     */\n\n    nativePath = Tcl_FSGetNativePath(pathPtr);\n\n#if TCL_DYLD_USE_DLFCN\n#if MAC_OS_X_VERSION_MIN_REQUIRED < 1040\n    if (tclMacOSXDarwinRelease >= 8)\n#endif\n    {\n    /*\n     * Use (RTLD_NOW|RTLD_LOCAL) always, see [Bug #3216070]\n     */\n\tdlHandle = dlopen(nativePath, RTLD_NOW | RTLD_LOCAL);\n\tif (!dlHandle) {\n\t    /*\n\t     * Let the OS loader examine the binary search path for whatever\n\t     * string the user gave us which hopefully refers to a file on the\n\t     * binary path.\n\t     */\n\n\t    fileName = Tcl_GetString(pathPtr);\n\t    nativeFileName = Tcl_UtfToExternalDString(NULL, fileName, -1, &ds);\n\t    /*\n\t     * Use (RTLD_NOW|RTLD_LOCAL) always, see [Bug #3216070]\n\t     */\n\t    dlHandle = dlopen(nativeFileName, RTLD_NOW | RTLD_LOCAL);\n\t}\n\tif (dlHandle) {\n\t    TclLoadDbgMsg(\"dlopen() successful\");\n\t} else {\n\t    errMsg = dlerror();\n\t    TclLoadDbgMsg(\"dlopen() failed: %s\", errMsg);\n\t}\n    }\n    if (!dlHandle)\n#endif /* TCL_DYLD_USE_DLFCN */\n    {\n#if TCL_DYLD_USE_NSMODULE\n\tdyldLibHeader = NSAddImage(nativePath,\n\t\tNSADDIMAGE_OPTION_RETURN_ON_ERROR);\n\tif (dyldLibHeader) {\n\t    TclLoadDbgMsg(\"NSAddImage() successful\");\n\t} else {\n\t    NSLinkEditError(&editError, &errorNumber, &errorName, &errMsg);\n\t    if (editError == NSLinkEditFileAccessError) {\n\t\t/*\n\t\t * The requested file was not found. Let the OS loader examine\n\t\t * the binary search path for whatever string the user gave us\n\t\t * which hopefully refers to a file on the binary path.\n\t\t */\n\n\t\tif (!fileName) {\n\t\t    fileName = Tcl_GetString(pathPtr);\n\t\t    nativeFileName = Tcl_UtfToExternalDString(NULL, fileName,\n\t\t\t    -1, &ds);\n\t\t}\n\t\tdyldLibHeader = NSAddImage(nativeFileName,\n\t\t\tNSADDIMAGE_OPTION_WITH_SEARCHING |\n\t\t\tNSADDIMAGE_OPTION_RETURN_ON_ERROR);\n\t\tif (dyldLibHeader) {\n\t\t    TclLoadDbgMsg(\"NSAddImage() successful\");\n\t\t} else {\n\t\t    NSLinkEditError(&editError, &errorNumber, &errorName,\n\t\t\t    &errMsg);\n\t\t    TclLoadDbgMsg(\"NSAddImage() failed: %s\", errMsg);\n\t\t}\n\t    } else if ((editError == NSLinkEditFileFormatError\n\t\t    && errorNumber == EBADMACHO)\n\t\t    || editError == NSLinkEditOtherError){\n\t\tNSObjectFileImageReturnCode err;\n\t\tNSObjectFileImage dyldObjFileImage;\n\t\tNSModule module;\n\n\t\t/*\n\t\t * The requested file was found but was not of type MH_DYLIB,\n\t\t * attempt to load it as a MH_BUNDLE.\n\t\t */\n\n\t\terr = NSCreateObjectFileImageFromFile(nativePath,\n\t\t\t&dyldObjFileImage);\n\t\tif (err == NSObjectFileImageSuccess && dyldObjFileImage) {\n\t\t    TclLoadDbgMsg(\"NSCreateObjectFileImageFromFile() \"\n\t\t\t    \"successful\");\n\t\t    module = NSLinkModule(dyldObjFileImage, nativePath,\n\t\t\t    NSLINKMODULE_OPTION_BINDNOW\n\t\t\t    | NSLINKMODULE_OPTION_RETURN_ON_ERROR);\n\t\t    NSDestroyObjectFileImage(dyldObjFileImage);\n\t\t    if (module) {\n\t\t\tmodulePtr = (Tcl_DyldModuleHandle *)\n\t\t\t\tckalloc(sizeof(Tcl_DyldModuleHandle));\n\t\t\tmodulePtr->module = module;\n\t\t\tmodulePtr->nextPtr = NULL;\n\t\t\tTclLoadDbgMsg(\"NSLinkModule() successful\");\n\t\t    } else {\n\t\t\tNSLinkEditError(&editError, &errorNumber, &errorName,\n\t\t\t\t&errMsg);\n\t\t\tTclLoadDbgMsg(\"NSLinkModule() failed: %s\", errMsg);\n\t\t    }\n\t\t} else {\n\t\t    objFileImageErrMsg = DyldOFIErrorMsg(err);\n\t\t    TclLoadDbgMsg(\"NSCreateObjectFileImageFromFile() failed: \"\n\t\t\t    \"%s\", objFileImageErrMsg);\n\t\t}\n\t    }\n\t}\n#endif /* TCL_DYLD_USE_NSMODULE */\n    }\n    if (0\n#if TCL_DYLD_USE_DLFCN\n\t    || dlHandle\n#endif\n#if TCL_DYLD_USE_NSMODULE\n\t    || dyldLibHeader || modulePtr\n#endif\n    ) {\n\tdyldLoadHandle = (Tcl_DyldLoadHandle *)\n\t\tckalloc(sizeof(Tcl_DyldLoadHandle));\n#if TCL_DYLD_USE_DLFCN\n\tdyldLoadHandle->dlHandle = dlHandle;\n#endif\n#if TCL_DYLD_USE_NSMODULE || defined(TCL_LOAD_FROM_MEMORY)\n\tdyldLoadHandle->dyldLibHeader = dyldLibHeader;\n\tdyldLoadHandle->modulePtr = modulePtr;\n#endif\n\t*loadHandle = (Tcl_LoadHandle) dyldLoadHandle;\n\t*unloadProcPtr = &TclpUnloadFile;\n\tresult = TCL_OK;\n    } else {\n\tTcl_AppendResult(interp, errMsg, NULL);\n#if TCL_DYLD_USE_NSMODULE\n\tif (objFileImageErrMsg) {\n\t    Tcl_AppendResult(interp, \"\\nNSCreateObjectFileImageFromFile() \"\n\t\t    \"error: \", objFileImageErrMsg, NULL);\n\t}\n#endif\n\tresult = TCL_ERROR;\n    }\n    if(fileName) {\n\tTcl_DStringFree(&ds);\n    }\n    return result;\n}\n\f\n/*\n *----------------------------------------------------------------------\n *\n * TclpFindSymbol --\n *\n *\tLooks up a symbol, by name, through a handle associated with a\n *\tpreviously loaded piece of code (shared library).\n *\n * Results:\n *\tReturns a pointer to the function associated with 'symbol' if it is\n *\tfound. Otherwise returns NULL and may leave an error message in the\n *\tinterp's result.\n *\n *----------------------------------------------------------------------\n */\n\nMODULE_SCOPE Tcl_PackageInitProc *\nTclpFindSymbol(\n    Tcl_Interp *interp,\t\t/* For error reporting. */\n    Tcl_LoadHandle loadHandle,\t/* Handle from TclpDlopen. */\n    CONST char *symbol)\t\t/* Symbol name to look up. */\n{\n    Tcl_DyldLoadHandle *dyldLoadHandle = (Tcl_DyldLoadHandle *) loadHandle;\n    Tcl_PackageInitProc *proc = NULL;\n    const char *errMsg = NULL;\n    Tcl_DString ds;\n    const char *native;\n\n    native = Tcl_UtfToExternalDString(NULL, symbol, -1, &ds);\n#if TCL_DYLD_USE_DLFCN\n    if (dyldLoadHandle->dlHandle) {\n\tproc = dlsym(dyldLoadHandle->dlHandle, native);\n\tif (proc) {\n\t    TclLoadDbgMsg(\"dlsym() successful\");\n\t} else {\n\t    errMsg = dlerror();\n\t    TclLoadDbgMsg(\"dlsym() failed: %s\", errMsg);\n\t}\n    } else\n#endif /* TCL_DYLD_USE_DLFCN */\n    {\n#if TCL_DYLD_USE_NSMODULE || defined(TCL_LOAD_FROM_MEMORY)\n\tNSSymbol nsSymbol = NULL;\n\tTcl_DString newName;\n\n\t/*\n\t * dyld adds an underscore to the beginning of symbol names.\n\t */\n\n\tTcl_DStringInit(&newName);\n\tTcl_DStringAppend(&newName, \"_\", 1);\n\tnative = Tcl_DStringAppend(&newName, native, -1);\n\tif (dyldLoadHandle->dyldLibHeader) {\n\t    nsSymbol = NSLookupSymbolInImage(dyldLoadHandle->dyldLibHeader,\n\t\t    native, NSLOOKUPSYMBOLINIMAGE_OPTION_BIND_NOW |\n\t\t    NSLOOKUPSYMBOLINIMAGE_OPTION_RETURN_ON_ERROR);\n\t    if (nsSymbol) {\n\t\tTclLoadDbgMsg(\"NSLookupSymbolInImage() successful\");\n#ifdef DYLD_SUPPORTS_DYLIB_UNLOADING\n\t\t/*\n\t\t * Until dyld supports unloading of MY_DYLIB binaries, the\n\t\t * following is not needed.\n\t\t */\n\n\t\tNSModule module = NSModuleForSymbol(nsSymbol);\n\t\tTcl_DyldModuleHandle *modulePtr = dyldLoadHandle->modulePtr;\n\n\t\twhile (modulePtr != NULL) {\n\t\t    if (module == modulePtr->module) {\n\t\t\tbreak;\n\t\t    }\n\t\t    modulePtr = modulePtr->nextPtr;\n\t\t}\n\t\tif (modulePtr == NULL) {\n\t\t    modulePtr = (Tcl_DyldModuleHandle *)\n\t\t\t    ckalloc(sizeof(Tcl_DyldModuleHandle));\n\t\t    modulePtr->module = module;\n\t\t    modulePtr->nextPtr = dyldLoadHandle->modulePtr;\n\t\t    dyldLoadHandle->modulePtr = modulePtr;\n\t\t}\n#endif /* DYLD_SUPPORTS_DYLIB_UNLOADING */\n\t    } else {\n\t\tNSLinkEditErrors editError;\n\t\tint errorNumber;\n\t\tconst char *errorName;\n\n\t\tNSLinkEditError(&editError, &errorNumber, &errorName, &errMsg);\n\t\tTclLoadDbgMsg(\"NSLookupSymbolInImage() failed: %s\", errMsg);\n\t    }\n\t} else if (dyldLoadHandle->modulePtr) {\n\t    nsSymbol = NSLookupSymbolInModule(\n\t\t    dyldLoadHandle->modulePtr->module, native);\n\t    if (nsSymbol) {\n\t\tTclLoadDbgMsg(\"NSLookupSymbolInModule() successful\");\n\t    } else {\n\t\tTclLoadDbgMsg(\"NSLookupSymbolInModule() failed\");\n\t    }\n\t}\n\tif (nsSymbol) {\n\t    proc = NSAddressOfSymbol(nsSymbol);\n\t    if (proc) {\n\t\tTclLoadDbgMsg(\"NSAddressOfSymbol() successful\");\n\t    } else {\n\t\tTclLoadDbgMsg(\"NSAddressOfSymbol() failed\");\n\t    }\n\t}\n\tTcl_DStringFree(&newName);\n#endif /* TCL_DYLD_USE_NSMODULE */\n    }\n    Tcl_DStringFree(&ds);\n    if (errMsg) {\n\tTcl_AppendResult(interp, errMsg, NULL);\n    }\n    return proc;\n}\n\f\n/*\n *----------------------------------------------------------------------\n *\n * TclpUnloadFile --\n *\n *\tUnloads a dynamically loaded binary code file from memory. Code\n *\tpointers in the formerly loaded file are no longer valid after calling\n *\tthis function.\n *\n * Results:\n *\tNone.\n *\n * Side effects:\n *\tCode dissapears from memory. Note that dyld currently only supports\n *\tunloading of binaries of type MH_BUNDLE loaded with NSLinkModule() in\n *\tTclpDlopen() above.\n *\n *----------------------------------------------------------------------\n */\n\nMODULE_SCOPE void\nTclpUnloadFile(\n    Tcl_LoadHandle loadHandle)\t/* loadHandle returned by a previous call to\n\t\t\t\t * TclpDlopen(). The loadHandle is a token\n\t\t\t\t * that represents the loaded file. */\n{\n    Tcl_DyldLoadHandle *dyldLoadHandle = (Tcl_DyldLoadHandle *) loadHandle;\n\n#if TCL_DYLD_USE_DLFCN\n    if (dyldLoadHandle->dlHandle) {\n\tint result;\n\n\tresult = dlclose(dyldLoadHandle->dlHandle);\n\tif (!result) {\n\t    TclLoadDbgMsg(\"dlclose() successful\");\n\t} else {\n\t    TclLoadDbgMsg(\"dlclose() failed: %s\", dlerror());\n\t}\n    } else\n#endif /* TCL_DYLD_USE_DLFCN */\n    {\n#if TCL_DYLD_USE_NSMODULE || defined(TCL_LOAD_FROM_MEMORY)\n\tTcl_DyldModuleHandle *modulePtr = dyldLoadHandle->modulePtr;\n\n\twhile (modulePtr != NULL) {\n\t    void *ptr;\n\t    bool result;\n\n\t    result = NSUnLinkModule(modulePtr->module,\n\t\t    NSUNLINKMODULE_OPTION_RESET_LAZY_REFERENCES);\n\t    if (result) {\n\t\tTclLoadDbgMsg(\"NSUnLinkModule() successful\");\n\t    } else {\n\t\tTclLoadDbgMsg(\"NSUnLinkModule() failed\");\n\t    }\n\t    ptr = modulePtr;\n\t    modulePtr = modulePtr->nextPtr;\n\t    ckfree(ptr);\n\t}\n#endif /* TCL_DYLD_USE_NSMODULE */\n    }\n    ckfree((char*) dyldLoadHandle);\n}\n\f\n/*\n *----------------------------------------------------------------------\n *\n * TclGuessPackageName --\n *\n *\tIf the \"load\" command is invoked without providing a package name,\n *\tthis procedure is invoked to try to figure it out.\n *\n * Results:\n *\tAlways returns 0 to indicate that we couldn't figure out a package\n *\tname; generic code will then try to guess the package from the file\n *\tname. A return value of 1 would have meant that we figured out the\n *\tpackage name and put it in bufPtr.\n *\n * Side effects:\n *\tNone.\n *\n *----------------------------------------------------------------------\n */\n\nint\nTclGuessPackageName(\n    CONST char *fileName,\t/* Name of file containing package (already\n\t\t\t\t * translated to local form if needed). */\n    Tcl_DString *bufPtr)\t/* Initialized empty dstring. Append package\n\t\t\t\t * name to this if possible. */\n{\n    return 0;\n}\n\f\n#ifdef TCL_LOAD_FROM_MEMORY\n/*\n *----------------------------------------------------------------------\n *\n * TclpLoadMemoryGetBuffer --\n *\n *\tAllocate a buffer that can be used with TclpLoadMemory() below.\n *\n * Results:\n *\tPointer to allocated buffer or NULL if an error occurs.\n *\n * Side effects:\n *\tBuffer is allocated.\n *\n *----------------------------------------------------------------------\n */\n\nMODULE_SCOPE void *\nTclpLoadMemoryGetBuffer(\n    Tcl_Interp *interp,\t\t/* Used for error reporting. */\n    int size)\t\t\t/* Size of desired buffer. */\n{\n    void *buffer = NULL;\n\n    /*\n     * NSCreateObjectFileImageFromMemory is available but always fails\n     * prior to Darwin 7.\n     */\n    if (tclMacOSXDarwinRelease >= 7) {\n\t/*\n\t * We must allocate the buffer using vm_allocate, because\n\t * NSCreateObjectFileImageFromMemory will dispose of it using\n\t * vm_deallocate.\n\t */\n\n\tif (vm_allocate(mach_task_self(), (vm_address_t *) &buffer, size, 1)) {\n\t    buffer = NULL;\n\t}\n    }\n    return buffer;\n}\n\f\n/*\n *----------------------------------------------------------------------\n *\n * TclpLoadMemory --\n *\n *\tDynamically loads binary code file from memory and returns a handle to\n *\tthe new code.\n *\n * Results:\n *\tA standard Tcl completion code. If an error occurs, an error message\n *\tis left in the interpreter's result.\n *\n * Side effects:\n *\tNew code is loaded from memory.\n *\n *----------------------------------------------------------------------\n */\n\nMODULE_SCOPE int\nTclpLoadMemory(\n    Tcl_Interp *interp,\t\t/* Used for error reporting. */\n    void *buffer,\t\t/* Buffer containing the desired code\n\t\t\t\t * (allocated with TclpLoadMemoryGetBuffer). */\n    int size,\t\t\t/* Allocation size of buffer. */\n    int codeSize,\t\t/* Size of code data read into buffer or -1 if\n\t\t\t\t * an error occurred and the buffer should\n\t\t\t\t * just be freed. */\n    Tcl_LoadHandle *loadHandle, /* Filled with token for dynamically loaded\n\t\t\t\t * file which will be passed back to\n\t\t\t\t * (*unloadProcPtr)() to unload the file. */\n    Tcl_FSUnloadFileProc **unloadProcPtr)\n\t\t\t\t/* Filled with address of Tcl_FSUnloadFileProc\n\t\t\t\t * function which should be used for this\n\t\t\t\t * file. */\n{\n    Tcl_DyldLoadHandle *dyldLoadHandle;\n    NSObjectFileImage dyldObjFileImage = NULL;\n    Tcl_DyldModuleHandle *modulePtr;\n    NSModule module;\n    const char *objFileImageErrMsg = NULL;\n\n    /*\n     * Try to create an object file image that we can load from.\n     */\n\n    if (codeSize >= 0) {\n\tNSObjectFileImageReturnCode err = NSObjectFileImageSuccess;\n\tconst struct fat_header *fh = buffer;\n\tuint32_t ms = 0;\n#ifndef __LP64__\n\tconst struct mach_header *mh = NULL;\n\t#define mh_size  sizeof(struct mach_header)\n\t#define mh_magic MH_MAGIC\n\t#define arch_abi 0\n#else\n\tconst struct mach_header_64 *mh = NULL;\n\t#define mh_size  sizeof(struct mach_header_64)\n\t#define mh_magic MH_MAGIC_64\n\t#define arch_abi CPU_ARCH_ABI64\n#endif\n\n\tif ((size_t) codeSize >= sizeof(struct fat_header)\n\t\t&& fh->magic == OSSwapHostToBigInt32(FAT_MAGIC)) {\n\t    uint32_t fh_nfat_arch = OSSwapBigToHostInt32(fh->nfat_arch);\n\n\t    /*\n\t     * Fat binary, try to find mach_header for our architecture\n\t     */\n\n\t    TclLoadDbgMsg(\"Fat binary, %d archs\", fh_nfat_arch);\n\t    if ((size_t) codeSize >= sizeof(struct fat_header) +\n\t\t    fh_nfat_arch * sizeof(struct fat_arch)) {\n\t\tvoid *fatarchs = (char*)buffer + sizeof(struct fat_header);\n\t\tconst NXArchInfo *arch = NXGetLocalArchInfo();\n\t\tstruct fat_arch *fa;\n\n\t\tif (fh->magic != FAT_MAGIC) {\n\t\t    swap_fat_arch(fatarchs, fh_nfat_arch, arch->byteorder);\n\t\t}\n\t\tfa = NXFindBestFatArch(arch->cputype | arch_abi,\n\t\t\tarch->cpusubtype, fatarchs, fh_nfat_arch);\n\t\tif (fa) {\n\t\t    TclLoadDbgMsg(\"NXFindBestFatArch() successful: \"\n\t\t\t    \"local cputype %d subtype %d, \"\n\t\t\t    \"fat cputype %d subtype %d\",\n\t\t\t    arch->cputype | arch_abi, arch->cpusubtype,\n\t\t\t    fa->cputype, fa->cpusubtype);\n\t\t    mh = (void*)((char*)buffer + fa->offset);\n\t\t    ms = fa->size;\n\t\t} else {\n\t\t    TclLoadDbgMsg(\"NXFindBestFatArch() failed\");\n\t\t    err = NSObjectFileImageInappropriateFile;\n\t\t}\n\t\tif (fh->magic != FAT_MAGIC) {\n\t\t    swap_fat_arch(fatarchs, fh_nfat_arch, arch->byteorder);\n\t\t}\n\t    } else {\n\t\tTclLoadDbgMsg(\"Fat binary header failure\");\n\t\terr = NSObjectFileImageInappropriateFile;\n\t    }\n\t} else {\n\t    /*\n\t     * Thin binary\n\t     */\n\n\t    TclLoadDbgMsg(\"Thin binary\");\n\t    mh = buffer;\n\t    ms = codeSize;\n\t}\n\tif (ms && !(ms >= mh_size && mh->magic == mh_magic &&\n\t\t mh->filetype == MH_BUNDLE)) {\n\t    TclLoadDbgMsg(\"Inappropriate file: magic %x filetype %d\",\n\t\t    mh->magic, mh->filetype);\n\t    err = NSObjectFileImageInappropriateFile;\n\t}\n\tif (err == NSObjectFileImageSuccess) {\n\t    err = NSCreateObjectFileImageFromMemory(buffer, codeSize,\n\t\t    &dyldObjFileImage);\n\t    if (err == NSObjectFileImageSuccess) {\n\t\tTclLoadDbgMsg(\"NSCreateObjectFileImageFromMemory() \"\n\t\t\t\"successful\");\n\t    } else {\n\t\tobjFileImageErrMsg = DyldOFIErrorMsg(err);\n\t\tTclLoadDbgMsg(\"NSCreateObjectFileImageFromMemory() failed: %s\",\n\t\t\tobjFileImageErrMsg);\n\t    }\n\t} else {\n\t    objFileImageErrMsg = DyldOFIErrorMsg(err);\n\t}\n    }\n\n    /*\n     * If it went wrong (or we were asked to just deallocate), get rid of the\n     * memory block and create an error message.\n     */\n\n    if (dyldObjFileImage == NULL) {\n\tvm_deallocate(mach_task_self(), (vm_address_t) buffer, size);\n\tif (objFileImageErrMsg != NULL) {\n\t    Tcl_AppendResult(interp, \"NSCreateObjectFileImageFromMemory() \"\n\t\t    \"error: \", objFileImageErrMsg, NULL);\n\t}\n\treturn TCL_ERROR;\n    }\n\n    /*\n     * Extract the module we want from the image of the object file.\n     */\n\n    module = NSLinkModule(dyldObjFileImage, \"[Memory Based Bundle]\",\n\t    NSLINKMODULE_OPTION_BINDNOW | NSLINKMODULE_OPTION_RETURN_ON_ERROR);\n    NSDestroyObjectFileImage(dyldObjFileImage);\n    if (module) {\n\tTclLoadDbgMsg(\"NSLinkModule() successful\");\n    } else {\n\tNSLinkEditErrors editError;\n\tint errorNumber;\n\tconst char *errorName, *errMsg;\n\n\tNSLinkEditError(&editError, &errorNumber, &errorName, &errMsg);\n\tTclLoadDbgMsg(\"NSLinkModule() failed: %s\", errMsg);\n\tTcl_AppendResult(interp, errMsg, NULL);\n\treturn TCL_ERROR;\n    }\n\n    /*\n     * Stash the module reference within the load handle we create and return.\n     */\n\n    modulePtr = (Tcl_DyldModuleHandle *) ckalloc(sizeof(Tcl_DyldModuleHandle));\n    modulePtr->module = module;\n    modulePtr->nextPtr = NULL;\n    dyldLoadHandle = (Tcl_DyldLoadHandle *)\n\t    ckalloc(sizeof(Tcl_DyldLoadHandle));\n#if TCL_DYLD_USE_DLFCN\n    dyldLoadHandle->dlHandle = NULL;\n#endif\n    dyldLoadHandle->dyldLibHeader = NULL;\n    dyldLoadHandle->modulePtr = modulePtr;\n    *loadHandle = (Tcl_LoadHandle) dyldLoadHandle;\n    *unloadProcPtr = &TclpUnloadFile;\n    return TCL_OK;\n}\n#endif /* TCL_LOAD_FROM_MEMORY */\n\f\n/*\n * Local Variables:\n * mode: c\n * c-basic-offset: 4\n * fill-column: 79\n * End:\n */\n",
        "/tmp/vanessa/spack-stage/spack-stage-tcl-8.5.19-76icjut2bqpwmf2fnlt35uiqok46hbar/spack-src/unix/tclLoadDl.c": "/*\n * tclLoadDl.c --\n *\n *\tThis procedure provides a version of the TclLoadFile that works with\n *\tthe \"dlopen\" and \"dlsym\" library procedures for dynamic loading.\n *\n * Copyright (c) 1995-1997 Sun Microsystems, Inc.\n *\n * See the file \"license.terms\" for information on usage and redistribution of\n * this file, and for a DISCLAIMER OF ALL WARRANTIES.\n */\n\n#include \"tclInt.h\"\n#ifdef NO_DLFCN_H\n#   include \"../compat/dlfcn.h\"\n#else\n#   include <dlfcn.h>\n#endif\n\n/*\n * In some systems, like SunOS 4.1.3, the RTLD_NOW flag isn't defined and this\n * argument to dlopen must always be 1. The RTLD_LOCAL flag doesn't exist on\n * some platforms; if it doesn't exist, set it to 0 so it has no effect.\n * See [Bug #3216070]\n */\n\n#ifndef RTLD_NOW\n#   define RTLD_NOW 1\n#endif\n\n#ifndef RTLD_LOCAL\n#   define RTLD_LOCAL 0\n#endif\n\f\n/*\n *---------------------------------------------------------------------------\n *\n * TclpDlopen --\n *\n *\tDynamically loads a binary code file into memory and returns a handle\n *\tto the new code.\n *\n * Results:\n *\tA standard Tcl completion code. If an error occurs, an error message\n *\tis left in the interp's result.\n *\n * Side effects:\n *\tNew code suddenly appears in memory.\n *\n *---------------------------------------------------------------------------\n */\n\nint\nTclpDlopen(\n    Tcl_Interp *interp,\t\t/* Used for error reporting. */\n    Tcl_Obj *pathPtr,\t\t/* Name of the file containing the desired\n\t\t\t\t * code (UTF-8). */\n    Tcl_LoadHandle *loadHandle,\t/* Filled with token for dynamically loaded\n\t\t\t\t * file which will be passed back to\n\t\t\t\t * (*unloadProcPtr)() to unload the file. */\n    Tcl_FSUnloadFileProc **unloadProcPtr)\n\t\t\t\t/* Filled with address of Tcl_FSUnloadFileProc\n\t\t\t\t * function which should be used for this\n\t\t\t\t * file. */\n{\n    void *handle;\n    CONST char *native;\n\n    /*\n     * First try the full path the user gave us. This is particularly\n     * important if the cwd is inside a vfs, and we are trying to load using a\n     * relative path.\n     */\n\n    native = Tcl_FSGetNativePath(pathPtr);\n    /*\n     * Use (RTLD_NOW|RTLD_LOCAL) always, see [Bug #3216070]\n     */\n    handle = dlopen(native, RTLD_NOW | RTLD_LOCAL);\n    if (handle == NULL) {\n\t/*\n\t * Let the OS loader examine the binary search path for whatever\n\t * string the user gave us which hopefully refers to a file on the\n\t * binary path.\n\t */\n\n\tTcl_DString ds;\n\tchar *fileName = Tcl_GetString(pathPtr);\n\n\tnative = Tcl_UtfToExternalDString(NULL, fileName, -1, &ds);\n\t/*\n\t * Use (RTLD_NOW|RTLD_LOCAL) always, see [Bug #3216070]\n\t */\n\thandle = dlopen(native, RTLD_NOW | RTLD_LOCAL);\n\tTcl_DStringFree(&ds);\n    }\n\n    if (handle == NULL) {\n\t/*\n\t * Write the string to a variable first to work around a compiler bug\n\t * in the Sun Forte 6 compiler. [Bug 1503729]\n\t */\n\n\tconst char *errorStr = dlerror();\n\n\tTcl_AppendResult(interp, \"couldn't load file \\\"\",\n\t\tTcl_GetString(pathPtr), \"\\\": \", errorStr, NULL);\n\treturn TCL_ERROR;\n    }\n\n    *unloadProcPtr = &TclpUnloadFile;\n    *loadHandle = (Tcl_LoadHandle) handle;\n    return TCL_OK;\n}\n\f\n/*\n *----------------------------------------------------------------------\n *\n * TclpFindSymbol --\n *\n *\tLooks up a symbol, by name, through a handle associated with a\n *\tpreviously loaded piece of code (shared library).\n *\n * Results:\n *\tReturns a pointer to the function associated with 'symbol' if it is\n *\tfound. Otherwise returns NULL and may leave an error message in the\n *\tinterp's result.\n *\n *----------------------------------------------------------------------\n */\n\nTcl_PackageInitProc *\nTclpFindSymbol(\n    Tcl_Interp *interp,\t\t/* Place to put error messages. */\n    Tcl_LoadHandle loadHandle,\t/* Value from TcpDlopen(). */\n    CONST char *symbol)\t\t/* Symbol to look up. */\n{\n    CONST char *native;\n    Tcl_DString newName, ds;\n    VOID *handle = (VOID*)loadHandle;\n    Tcl_PackageInitProc *proc;\n\n    /*\n     * Some platforms still add an underscore to the beginning of symbol\n     * names. If we can't find a name without an underscore, try again with\n     * the underscore.\n     */\n\n    native = Tcl_UtfToExternalDString(NULL, symbol, -1, &ds);\n    proc = (Tcl_PackageInitProc *) dlsym(handle,\t/* INTL: Native. */\n\t    native);\n    if (proc == NULL) {\n\tTcl_DStringInit(&newName);\n\tTcl_DStringAppend(&newName, \"_\", 1);\n\tnative = Tcl_DStringAppend(&newName, native, -1);\n\tproc = (Tcl_PackageInitProc *) dlsym(handle,\t/* INTL: Native. */\n\t\tnative);\n\tTcl_DStringFree(&newName);\n    }\n    Tcl_DStringFree(&ds);\n\n    return proc;\n}\n\f\n/*\n *----------------------------------------------------------------------\n *\n * TclpUnloadFile --\n *\n *\tUnloads a dynamically loaded binary code file from memory. Code\n *\tpointers in the formerly loaded file are no longer valid after calling\n *\tthis function.\n *\n * Results:\n *\tNone.\n *\n * Side effects:\n *\tCode removed from memory.\n *\n *----------------------------------------------------------------------\n */\n\nvoid\nTclpUnloadFile(\n    Tcl_LoadHandle loadHandle)\t/* loadHandle returned by a previous call to\n\t\t\t\t * TclpDlopen(). The loadHandle is a token\n\t\t\t\t * that represents the loaded file. */\n{\n    void *handle;\n\n    handle = (void *) loadHandle;\n    dlclose(handle);\n}\n\f\n/*\n *----------------------------------------------------------------------\n *\n * TclGuessPackageName --\n *\n *\tIf the \"load\" command is invoked without providing a package name,\n *\tthis procedure is invoked to try to figure it out.\n *\n * Results:\n *\tAlways returns 0 to indicate that we couldn't figure out a package\n *\tname; generic code will then try to guess the package from the file\n *\tname. A return value of 1 would have meant that we figured out the\n *\tpackage name and put it in bufPtr.\n *\n * Side effects:\n *\tNone.\n *\n *----------------------------------------------------------------------\n */\n\nint\nTclGuessPackageName(\n    CONST char *fileName,\t/* Name of file containing package (already\n\t\t\t\t * translated to local form if needed). */\n    Tcl_DString *bufPtr)\t/* Initialized empty dstring. Append package\n\t\t\t\t * name to this if possible. */\n{\n    return 0;\n}\n\f\n/*\n * Local Variables:\n * mode: c\n * c-basic-offset: 4\n * fill-column: 78\n * End:\n */\n",
        "/tmp/vanessa/spack-stage/spack-stage-tcl-8.5.19-76icjut2bqpwmf2fnlt35uiqok46hbar/spack-src/unix/tclLoadAix.c": "/*\n * tclLoadAix.c --\n *\n *\tThis file implements the dlopen and dlsym APIs under the AIX operating\n *\tsystem, to enable the Tcl \"load\" command to work. This code was\n *\tprovided by Jens-Uwe Mager.\n *\n *\tThis file is subject to the following copyright notice, which is\n *\tdifferent from the notice used elsewhere in Tcl. The file has been\n *\tmodified to incorporate the file dlfcn.h in-line.\n *\n *\tCopyright (c) 1992,1993,1995,1996, Jens-Uwe Mager, Helios Software GmbH\n *\tNot derived from licensed software.\n *\n *\tPermission is granted to freely use, copy, modify, and redistribute\n *\tthis software, provided that the author is not construed to be liable\n *\tfor any results of using the software, alterations are clearly marked\n *\tas such, and this notice is not modified.\n *\n * Note: this file has been altered from the original in a few ways in order\n * to work properly with Tcl.\n */\n\n/*\n * @(#)dlfcn.c\t1.7 revision of 95/08/14  19:08:38\n * This is an unpublished work copyright (c) 1992 HELIOS Software GmbH\n * 30159 Hannover, Germany\n */\n\n#include <stdio.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <sys/ldr.h>\n#include <a.out.h>\n#include <ldfcn.h>\n#include \"../compat/dlfcn.h\"\n\n/*\n * We simulate dlopen() et al. through a call to load. Because AIX has no call\n * to find an exported symbol we read the loader section of the loaded module\n * and build a list of exported symbols and their virtual address.\n */\n\ntypedef struct {\n    char *name;\t\t\t/* The symbols's name. */\n    void *addr;\t\t\t/* Its relocated virtual address. */\n} Export, *ExportPtr;\n\n/*\n * xlC uses the following structure to list its constructors and destructors.\n * This is gleaned from the output of munch.\n */\n\ntypedef struct {\n    void (*init)(void);\t\t/* call static constructors */\n    void (*term)(void);\t\t/* call static destructors */\n} Cdtor, *CdtorPtr;\n\n/*\n * The void * handle returned from dlopen is actually a ModulePtr.\n */\n\ntypedef struct Module {\n    struct Module *next;\n    char *name;\t\t\t/* module name for refcounting */\n    int refCnt;\t\t\t/* the number of references */\n    void *entry;\t\t/* entry point from load */\n    struct dl_info *info;\t/* optional init/terminate functions */\n    CdtorPtr cdtors;\t\t/* optional C++ constructors */\n    int nExports;\t\t/* the number of exports found */\n    ExportPtr exports;\t\t/* the array of exports */\n} Module, *ModulePtr;\n\n/*\n * We keep a list of all loaded modules to be able to call the fini handlers\n * and destructors at atexit() time.\n */\n\nstatic ModulePtr modList;\n\n/*\n * The last error from one of the dl* routines is kept in static variables\n * here. Each error is returned only once to the caller.\n */\n\nstatic char errbuf[BUFSIZ];\nstatic int errvalid;\n\nstatic void caterr(char *);\nstatic int readExports(ModulePtr);\nstatic void terminate(void);\nstatic void *findMain(void);\n\f\nvoid *\ndlopen(\n    const char *path,\n    int mode)\n{\n    register ModulePtr mp;\n    static void *mainModule;\n\n    /*\n     * Upon the first call register a terminate handler that will close all\n     * libraries. Also get a reference to the main module for use with\n     * loadbind.\n     */\n\n    if (!mainModule) {\n\tmainModule = findMain();\n\tif (mainModule == NULL) {\n\t    return NULL;\n\t}\n\tatexit(terminate);\n    }\n\n    /*\n     * Scan the list of modules if we have the module already loaded.\n     */\n\n    for (mp = modList; mp; mp = mp->next) {\n\tif (strcmp(mp->name, path) == 0) {\n\t    mp->refCnt++;\n\t    return (void *) mp;\n\t}\n    }\n\n    mp = (ModulePtr) calloc(1, sizeof(*mp));\n    if (mp == NULL) {\n\terrvalid++;\n\tstrcpy(errbuf, \"calloc: \");\n\tstrcat(errbuf, strerror(errno));\n\treturn NULL;\n    }\n\n    mp->name = malloc((unsigned) (strlen(path) + 1));\n    strcpy(mp->name, path);\n\n    /*\n     * load should be declared load(const char *...). Thus we cast the path to\n     * a normal char *. Ugly.\n     */\n\n    mp->entry = (void *) load((char *)path, L_NOAUTODEFER, NULL);\n    if (mp->entry == NULL) {\n\tfree(mp->name);\n\tfree(mp);\n\terrvalid++;\n\tstrcpy(errbuf, \"dlopen: \");\n\tstrcat(errbuf, path);\n\tstrcat(errbuf, \": \");\n\n\t/*\n\t * If AIX says the file is not executable, the error can be further\n\t * described by querying the loader about the last error.\n\t */\n\n\tif (errno == ENOEXEC) {\n\t    char *tmp[BUFSIZ/sizeof(char *)], **p;\n\n\t    if (loadquery(L_GETMESSAGES, tmp, sizeof(tmp)) == -1) {\n\t\tstrcpy(errbuf, strerror(errno));\n\t    } else {\n\t\tfor (p=tmp ; *p ; p++) {\n\t\t    caterr(*p);\n\t\t}\n\t    }\n\t} else {\n\t    strcat(errbuf, strerror(errno));\n\t}\n\treturn NULL;\n    }\n\n    mp->refCnt = 1;\n    mp->next = modList;\n    modList = mp;\n\n    if (loadbind(0, mainModule, mp->entry) == -1) {\n    loadbindFailure:\n\tdlclose(mp);\n\terrvalid++;\n\tstrcpy(errbuf, \"loadbind: \");\n\tstrcat(errbuf, strerror(errno));\n\treturn NULL;\n    }\n\n    /*\n     * If the user wants global binding, loadbind against all other loaded\n     * modules.\n     */\n\n    if (mode & RTLD_GLOBAL) {\n\tregister ModulePtr mp1;\n\n\tfor (mp1 = mp->next; mp1; mp1 = mp1->next) {\n\t    if (loadbind(0, mp1->entry, mp->entry) == -1) {\n\t\tgoto loadbindFailure;\n\t    }\n\t}\n    }\n\n    if (readExports(mp) == -1) {\n\tdlclose(mp);\n\treturn NULL;\n    }\n\n    /*\n     * If there is a dl_info structure, call the init function.\n     */\n\n    if (mp->info = (struct dl_info *)dlsym(mp, \"dl_info\")) {\n\tif (mp->info->init) {\n\t    (*mp->info->init)();\n\t}\n    } else {\n\terrvalid = 0;\n    }\n\n    /*\n     * If the shared object was compiled using xlC we will need to call static\n     * constructors (and later on dlclose destructors).\n     */\n\n    if (mp->cdtors = (CdtorPtr) dlsym(mp, \"__cdtors\")) {\n\twhile (mp->cdtors->init) {\n\t    (*mp->cdtors->init)();\n\t    mp->cdtors++;\n\t}\n    } else {\n\terrvalid = 0;\n    }\n\n    return (void *) mp;\n}\n\f\n/*\n * Attempt to decipher an AIX loader error message and append it to our static\n * error message buffer.\n */\n\nstatic void\ncaterr(\n    char *s)\n{\n    register char *p = s;\n\n    while (*p >= '0' && *p <= '9') {\n\tp++;\n    }\n    switch (atoi(s)) {\t\t/* INTL: \"C\", UTF safe. */\n    case L_ERROR_TOOMANY:\n\tstrcat(errbuf, \"to many errors\");\n\tbreak;\n    case L_ERROR_NOLIB:\n\tstrcat(errbuf, \"can't load library\");\n\tstrcat(errbuf, p);\n\tbreak;\n    case L_ERROR_UNDEF:\n\tstrcat(errbuf, \"can't find symbol\");\n\tstrcat(errbuf, p);\n\tbreak;\n    case L_ERROR_RLDBAD:\n\tstrcat(errbuf, \"bad RLD\");\n\tstrcat(errbuf, p);\n\tbreak;\n    case L_ERROR_FORMAT:\n\tstrcat(errbuf, \"bad exec format in\");\n\tstrcat(errbuf, p);\n\tbreak;\n    case L_ERROR_ERRNO:\n\tstrcat(errbuf, strerror(atoi(++p)));\t/* INTL: \"C\", UTF safe. */\n\tbreak;\n    default:\n\tstrcat(errbuf, s);\n\tbreak;\n    }\n}\n\f\nvoid *\ndlsym(\n    void *handle,\n    const char *symbol)\n{\n    register ModulePtr mp = (ModulePtr)handle;\n    register ExportPtr ep;\n    register int i;\n\n    /*\n     * Could speed up the search, but I assume that one assigns the result to\n     * function pointers anyways.\n     */\n\n    for (ep = mp->exports, i = mp->nExports; i; i--, ep++) {\n\tif (strcmp(ep->name, symbol) == 0) {\n\t    return ep->addr;\n\t}\n    }\n\n    errvalid++;\n    strcpy(errbuf, \"dlsym: undefined symbol \");\n    strcat(errbuf, symbol);\n    return NULL;\n}\n\f\nchar *\ndlerror(void)\n{\n    if (errvalid) {\n\terrvalid = 0;\n\treturn errbuf;\n    }\n    return NULL;\n}\n\f\nint\ndlclose(\n    void *handle)\n{\n    register ModulePtr mp = (ModulePtr)handle;\n    int result;\n    register ModulePtr mp1;\n\n    if (--mp->refCnt > 0) {\n\treturn 0;\n    }\n\n    if (mp->info && mp->info->fini) {\n\t(*mp->info->fini)();\n    }\n\n    if (mp->cdtors) {\n\twhile (mp->cdtors->term) {\n\t    (*mp->cdtors->term)();\n\t    mp->cdtors++;\n\t}\n    }\n\n    result = unload(mp->entry);\n    if (result == -1) {\n\terrvalid++;\n\tstrcpy(errbuf, strerror(errno));\n    }\n\n    if (mp->exports) {\n\tregister ExportPtr ep;\n\tregister int i;\n\tfor (ep = mp->exports, i = mp->nExports; i; i--, ep++) {\n\t    if (ep->name) {\n\t\tfree(ep->name);\n\t    }\n\t}\n\tfree(mp->exports);\n    }\n\n    if (mp == modList) {\n\tmodList = mp->next;\n    } else {\n\tfor (mp1 = modList; mp1; mp1 = mp1->next) {\n\t    if (mp1->next == mp) {\n\t\tmp1->next = mp->next;\n\t\tbreak;\n\t    }\n\t}\n    }\n\n    free(mp->name);\n    free(mp);\n    return result;\n}\n\f\nstatic void\nterminate(void)\n{\n    while (modList) {\n\tdlclose(modList);\n    }\n}\n\f\n/*\n * Build the export table from the XCOFF .loader section.\n */\n\nstatic int\nreadExports(\n    ModulePtr mp)\n{\n    LDFILE *ldp = NULL;\n    SCNHDR sh, shdata;\n    LDHDR *lhp;\n    char *ldbuf;\n    LDSYM *ls;\n    int i;\n    ExportPtr ep;\n    const char *errMsg;\n\n#define Error(msg) do{errMsg=(msg);goto error;}while(0)\n#define SysErr() Error(strerror(errno))\n\n    ldp = ldopen(mp->name, ldp);\n    if (ldp == NULL) {\n\tstruct ld_info *lp;\n\tchar *buf;\n\tint size = 0;\n\n\tif (errno != ENOENT) {\n\t    SysErr();\n\t}\n\n\t/*\n\t * The module might be loaded due to the LIBPATH environment variable.\n\t * Search for the loaded module using L_GETINFO.\n\t */\n\n\twhile (1) {\n\t    size += 4 * 1024;\n\t    buf = malloc(size);\n\t    if (buf == NULL) {\n\t\tSysErr();\n\t    }\n\n\t    i = loadquery(L_GETINFO, buf, size);\n\n\t    if (i != -1) {\n\t\tbreak;\n\t    }\n\t    free(buf);\n\t    if (errno != ENOMEM) {\n\t\tSysErr();\n\t    }\n\t}\n\n\t/*\n\t * Traverse the list of loaded modules. The entry point returned by\n\t * load() does actually point to the data segment origin.\n\t */\n\n\tlp = (struct ld_info *) buf;\n\twhile (lp) {\n\t    if (lp->ldinfo_dataorg == mp->entry) {\n\t\tldp = ldopen(lp->ldinfo_filename, ldp);\n\t\tbreak;\n\t    }\n\t    if (lp->ldinfo_next == 0) {\n\t\tlp = NULL;\n\t    } else {\n\t\tlp = (struct ld_info *)((char *)lp + lp->ldinfo_next);\n\t    }\n\t}\n\n\tfree(buf);\n\n\tif (!ldp) {\n\t    SysErr();\n\t}\n    }\n\n    if (TYPE(ldp) != U802TOCMAGIC) {\n\tError(\"bad magic\");\n    }\n\n    /*\n     * Get the padding for the data section. This is needed for AIX 4.1\n     * compilers. This is used when building the final function pointer to the\n     * exported symbol.\n     */\n\n    if (ldnshread(ldp, _DATA, &shdata) != SUCCESS) {\n\tError(\"cannot read data section header\");\n    }\n\n    if (ldnshread(ldp, _LOADER, &sh) != SUCCESS) {\n\tError(\"cannot read loader section header\");\n    }\n\n    /*\n     * We read the complete loader section in one chunk, this makes finding\n     * long symbol names residing in the string table easier.\n     */\n\n    ldbuf = (char *) malloc(sh.s_size);\n    if (ldbuf == NULL) {\n\tSysErr();\n    }\n\n    if (FSEEK(ldp, sh.s_scnptr, BEGINNING) != OKFSEEK) {\n\tfree(ldbuf);\n\tError(\"cannot seek to loader section\");\n    }\n\n    if (FREAD(ldbuf, sh.s_size, 1, ldp) != 1) {\n\tfree(ldbuf);\n\tError(\"cannot read loader section\");\n    }\n\n    lhp = (LDHDR *) ldbuf;\n    ls = (LDSYM *)(ldbuf + LDHDRSZ);\n\n    /*\n     * Count the number of exports to include in our export table.\n     */\n\n    for (i = lhp->l_nsyms; i; i--, ls++) {\n\tif (!LDR_EXPORT(*ls)) {\n\t    continue;\n\t}\n\tmp->nExports++;\n    }\n\n    mp->exports = (ExportPtr) calloc(mp->nExports, sizeof(*mp->exports));\n    if (mp->exports == NULL) {\n\tfree(ldbuf);\n\tSysErr();\n    }\n\n    /*\n     * Fill in the export table. All entries are relative to the entry point\n     * we got from load.\n     */\n\n    ep = mp->exports;\n    ls = (LDSYM *)(ldbuf + LDHDRSZ);\n    for (i=lhp->l_nsyms ; i!=0 ; i--,ls++) {\n\tchar *symname;\n\tchar tmpsym[SYMNMLEN+1];\n\n\tif (!LDR_EXPORT(*ls)) {\n\t    continue;\n\t}\n\n\tif (ls->l_zeroes == 0) {\n\t    symname = ls->l_offset + lhp->l_stoff + ldbuf;\n\t} else {\n\t    /*\n\t     * The l_name member is not zero terminated, we must copy the\n\t     * first SYMNMLEN chars and make sure we have a zero byte at the\n\t     * end.\n\t     */\n\n\t    strncpy(tmpsym, ls->l_name, SYMNMLEN);\n\t    tmpsym[SYMNMLEN] = '\\0';\n\t    symname = tmpsym;\n\t}\n\tep->name = malloc((unsigned) (strlen(symname) + 1));\n\tstrcpy(ep->name, symname);\n\tep->addr = (void *)((unsigned long)\n\t\tmp->entry + ls->l_value - shdata.s_vaddr);\n\tep++;\n    }\n    free(ldbuf);\n    while (ldclose(ldp) == FAILURE) {\n\t/* Empty body */\n    }\n    return 0;\n\n    /*\n     * This is a factoring out of the error-handling code to make the rest of\n     * the function much simpler to read.\n     */\n\n  error:\n    errvalid++;\n    strcpy(errbuf, \"readExports: \");\n    strcat(errbuf, errMsg);\n\n    if (ldp != NULL) {\n\twhile (ldclose(ldp) == FAILURE) {\n\t    /* Empty body */\n\t}\n    }\n    return -1;\n}\n\f\n/*\n * Find the main modules entry point. This is used as export pointer for\n * loadbind() to be able to resolve references to the main part.\n */\n\nstatic void *\nfindMain(void)\n{\n    struct ld_info *lp;\n    char *buf;\n    int size = 4*1024;\n    int i;\n    void *ret;\n\n    buf = malloc(size);\n    if (buf == NULL) {\n\tgoto error;\n    }\n\n    while ((i = loadquery(L_GETINFO, buf, size)) == -1 && errno == ENOMEM) {\n\tfree(buf);\n\tsize += 4*1024;\n\tbuf = malloc(size);\n\tif (buf == NULL) {\n\t    goto error;\n\t}\n    }\n\n    if (i == -1) {\n\tfree(buf);\n\tgoto error;\n    }\n\n    /*\n     * The first entry is the main module. The entry point returned by load()\n     * does actually point to the data segment origin.\n     */\n\n    lp = (struct ld_info *) buf;\n    ret = lp->ldinfo_dataorg;\n    free(buf);\n    return ret;\n\n  error:\n    errvalid++;\n    strcpy(errbuf, \"findMain: \");\n    strcat(errbuf, strerror(errno));\n    return NULL;\n}\n\f\n/*\n * Local Variables:\n * mode: c\n * c-basic-offset: 4\n * fill-column: 78\n * End:\n */\n",
        "/tmp/vanessa/spack-stage/spack-stage-tcl-8.5.19-76icjut2bqpwmf2fnlt35uiqok46hbar/spack-src/macosx/tclMacOSXBundle.c": "/*\n * tclMacOSXBundle.c --\n *\n *\tThis file implements functions that inspect CFBundle structures on\n *\tMacOS X.\n *\n * Copyright 2001-2009, Apple Inc.\n * Copyright (c) 2003-2009 Daniel A. Steffen <das@users.sourceforge.net>\n *\n * See the file \"license.terms\" for information on usage and redistribution of\n * this file, and for a DISCLAIMER OF ALL WARRANTIES.\n */\n\n#include \"tclPort.h\"\n\n#ifdef HAVE_COREFOUNDATION\n#include <CoreFoundation/CoreFoundation.h>\n\n#ifndef TCL_DYLD_USE_DLFCN\n/*\n * Use preferred dlfcn API on 10.4 and later\n */\n#   if !defined(NO_DLFCN_H) && MAC_OS_X_VERSION_MAX_ALLOWED >= 1040\n#\tdefine TCL_DYLD_USE_DLFCN 1\n#   else\n#\tdefine TCL_DYLD_USE_DLFCN 0\n#   endif\n#endif\n\n#ifndef TCL_DYLD_USE_NSMODULE\n/*\n * Use deprecated NSModule API only to support 10.3 and earlier:\n */\n#   if MAC_OS_X_VERSION_MIN_REQUIRED < 1040\n#\tdefine TCL_DYLD_USE_NSMODULE 1\n#   else\n#\tdefine TCL_DYLD_USE_NSMODULE 0\n#   endif\n#endif\n\n#if TCL_DYLD_USE_DLFCN\n#include <dlfcn.h>\n#if defined(HAVE_WEAK_IMPORT) && MAC_OS_X_VERSION_MIN_REQUIRED < 1040\n/*\n * Support for weakly importing dlfcn API.\n */\nextern void *dlsym(void *handle, const char *symbol) WEAK_IMPORT_ATTRIBUTE;\nextern char *dlerror(void) WEAK_IMPORT_ATTRIBUTE;\n#endif\n#endif\n\n#if TCL_DYLD_USE_NSMODULE\n#include <mach-o/dyld.h>\n#endif\n\n#if (TCL_DYLD_USE_DLFCN && MAC_OS_X_VERSION_MIN_REQUIRED < 1040) || \\\n\t(MAC_OS_X_VERSION_MIN_REQUIRED < 1050)\nMODULE_SCOPE long tclMacOSXDarwinRelease;\n#endif\n\n#ifdef TCL_DEBUG_LOAD\n#define TclLoadDbgMsg(m, ...) do { \\\n\t    fprintf(stderr, \"%s:%d: %s(): \" m \".\\n\", \\\n\t    strrchr(__FILE__, '/')+1, __LINE__, __func__, ##__VA_ARGS__); \\\n\t} while (0)\n#else\n#define TclLoadDbgMsg(m, ...)\n#endif\n\n#endif /* HAVE_COREFOUNDATION */\n\n/*\n *----------------------------------------------------------------------\n *\n * Tcl_MacOSXOpenBundleResources --\n *\n *\tGiven the bundle name for a shared library, this routine sets\n *\tlibraryPath to the Resources/Scripts directory in the framework\n *\tpackage. If hasResourceFile is true, it will also open the main\n *\tresource file for the bundle.\n *\n * Results:\n *\tTCL_OK if the bundle could be opened, and the Scripts folder found.\n *\tTCL_ERROR otherwise.\n *\n * Side effects:\n *\tlibraryVariableName may be set, and the resource file opened.\n *\n *----------------------------------------------------------------------\n */\n\nint\nTcl_MacOSXOpenBundleResources(\n    Tcl_Interp *interp,\n    CONST char *bundleName,\n    int hasResourceFile,\n    int maxPathLen,\n    char *libraryPath)\n{\n    return Tcl_MacOSXOpenVersionedBundleResources(interp, bundleName,\n\t    NULL, hasResourceFile, maxPathLen, libraryPath);\n}\n\f\n/*\n *----------------------------------------------------------------------\n *\n * Tcl_MacOSXOpenVersionedBundleResources --\n *\n *\tGiven the bundle and version name for a shared library (version name\n *\tcan be NULL to indicate latest version), this routine sets libraryPath\n *\tto the Resources/Scripts directory in the framework package. If\n *\thasResourceFile is true, it will also open the main resource file for\n *\tthe bundle.\n *\n * Results:\n *\tTCL_OK if the bundle could be opened, and the Scripts folder found.\n *\tTCL_ERROR otherwise.\n *\n * Side effects:\n *\tlibraryVariableName may be set, and the resource file opened.\n *\n *----------------------------------------------------------------------\n */\n\nint\nTcl_MacOSXOpenVersionedBundleResources(\n    Tcl_Interp *interp,\n    CONST char *bundleName,\n    CONST char *bundleVersion,\n    int hasResourceFile,\n    int maxPathLen,\n    char *libraryPath)\n{\n#ifdef HAVE_COREFOUNDATION\n    CFBundleRef bundleRef, versionedBundleRef = NULL;\n    CFStringRef bundleNameRef;\n    CFURLRef libURL;\n\n    libraryPath[0] = '\\0';\n\n    bundleNameRef = CFStringCreateWithCString(NULL, bundleName,\n\t    kCFStringEncodingUTF8);\n\n    bundleRef = CFBundleGetBundleWithIdentifier(bundleNameRef);\n    CFRelease(bundleNameRef);\n\n    if (bundleVersion && bundleRef) {\n\t/*\n\t * Create bundle from bundleVersion subdirectory of 'Versions'.\n\t */\n\n\tCFURLRef bundleURL = CFBundleCopyBundleURL(bundleRef);\n\n\tif (bundleURL) {\n\t    CFStringRef bundleVersionRef = CFStringCreateWithCString(NULL,\n\t\t    bundleVersion, kCFStringEncodingUTF8);\n\n\t    if (bundleVersionRef) {\n\t\tCFComparisonResult versionComparison = kCFCompareLessThan;\n\t\tCFStringRef bundleTailRef = CFURLCopyLastPathComponent(\n\t\t\tbundleURL);\n\n\t\tif (bundleTailRef) {\n\t\t    versionComparison = CFStringCompare(bundleTailRef,\n\t\t\t    bundleVersionRef, 0);\n\t\t    CFRelease(bundleTailRef);\n\t\t}\n\t\tif (versionComparison != kCFCompareEqualTo) {\n\t\t    CFURLRef versURL = CFURLCreateCopyAppendingPathComponent(\n\t\t\t    NULL, bundleURL, CFSTR(\"Versions\"), TRUE);\n\n\t\t    if (versURL) {\n\t\t\tCFURLRef versionedBundleURL =\n\t\t\t\tCFURLCreateCopyAppendingPathComponent(\n\t\t\t\tNULL, versURL, bundleVersionRef, TRUE);\n\n\t\t\tif (versionedBundleURL) {\n\t\t\t    versionedBundleRef = CFBundleCreate(NULL,\n\t\t\t\t    versionedBundleURL);\n\t\t\t    if (versionedBundleRef) {\n\t\t\t\tbundleRef = versionedBundleRef;\n\t\t\t    }\n\t\t\t    CFRelease(versionedBundleURL);\n\t\t\t}\n\t\t\tCFRelease(versURL);\n\t\t    }\n\t\t}\n\t\tCFRelease(bundleVersionRef);\n\t    }\n\t    CFRelease(bundleURL);\n\t}\n    }\n\n    if (bundleRef) {\n\tif (hasResourceFile) {\n\t    /*\n\t     * Dynamically acquire address for CFBundleOpenBundleResourceMap\n\t     * symbol, since it is only present in full CoreFoundation on Mac\n\t     * OS X and not in CFLite on pure Darwin.\n\t     */\n\n\t    static int initialized = FALSE;\n\t    static short (*openresourcemap)(CFBundleRef) = NULL;\n\n\t    if (!initialized) {\n#if TCL_DYLD_USE_DLFCN\n#if MAC_OS_X_VERSION_MIN_REQUIRED < 1040\n\t\tif (tclMacOSXDarwinRelease >= 8)\n#endif\n\t\t{\n\t\t    const char *errMsg = nil;\n\t\t    openresourcemap = dlsym(RTLD_NEXT,\n\t\t\t    \"CFBundleOpenBundleResourceMap\");\n\t\t    if (!openresourcemap) {\n\t\t\terrMsg = dlerror();\n\t\t\tTclLoadDbgMsg(\"dlsym() failed: %s\", errMsg);\n\t\t    }\n\t\t}\n\t\tif (!openresourcemap)\n#endif\n\t\t{\n#if TCL_DYLD_USE_NSMODULE\n\t\t    NSSymbol nsSymbol = NULL;\n\t\t    if (NSIsSymbolNameDefinedWithHint(\n\t\t\t    \"_CFBundleOpenBundleResourceMap\",\n\t\t\t    \"CoreFoundation\")) {\n\t\t\tnsSymbol = NSLookupAndBindSymbolWithHint(\n\t\t\t\t\"_CFBundleOpenBundleResourceMap\",\n\t\t\t\t\"CoreFoundation\");\n\t\t\tif (nsSymbol) {\n\t\t\t    openresourcemap = NSAddressOfSymbol(nsSymbol);\n\t\t\t}\n\t\t    }\n#endif\n\t\t}\n\t\tinitialized = TRUE;\n\t    }\n\n\t    if (openresourcemap) {\n\t\topenresourcemap(bundleRef);\n\t    }\n\t}\n\n\tlibURL = CFBundleCopyResourceURL(bundleRef, CFSTR(\"Scripts\"),\n\t\tNULL, NULL);\n\n\tif (libURL) {\n\t    /*\n\t     * FIXME: This is a quick fix, it is probably not right for\n\t     * internationalization.\n\t     */\n\n\t    CFURLGetFileSystemRepresentation(libURL, TRUE,\n\t\t    (unsigned char*) libraryPath, maxPathLen);\n\t    CFRelease(libURL);\n\t}\n\tif (versionedBundleRef) {\n#if MAC_OS_X_VERSION_MIN_REQUIRED < 1050\n\t    /* Workaround CFBundle bug in Tiger and earlier. [Bug 2569449] */\n\t    if (tclMacOSXDarwinRelease >= 9)\n#endif\n\t    {\n\t\tCFRelease(versionedBundleRef);\n\t    }\n\t}\n    }\n\n    if (libraryPath[0]) {\n\treturn TCL_OK;\n    } else {\n\treturn TCL_ERROR;\n    }\n#else  /* HAVE_COREFOUNDATION */\n    return TCL_ERROR;\n#endif /* HAVE_COREFOUNDATION */\n}\n\f\n/*\n * Local Variables:\n * mode: c\n * c-basic-offset: 4\n * fill-column: 78\n * End:\n */\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-tcl-8.5.19-76icjut2bqpwmf2fnlt35uiqok46hbar/spack-src/tests/stringObj.test",
        "/tmp/vanessa/spack-stage/spack-stage-tcl-8.5.19-76icjut2bqpwmf2fnlt35uiqok46hbar/spack-src/tests/subst.test",
        "/tmp/vanessa/spack-stage/spack-stage-tcl-8.5.19-76icjut2bqpwmf2fnlt35uiqok46hbar/spack-src/win/tclsh.ico",
        "/tmp/vanessa/spack-stage/spack-stage-tcl-8.5.19-76icjut2bqpwmf2fnlt35uiqok46hbar/spack-src/win/tcl.hpj.in",
        "/tmp/vanessa/spack-stage/spack-stage-tcl-8.5.19-76icjut2bqpwmf2fnlt35uiqok46hbar/spack-src/tools/white.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-tcl-8.5.19-76icjut2bqpwmf2fnlt35uiqok46hbar/spack-src/tools/feather.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-tcl-8.5.19-76icjut2bqpwmf2fnlt35uiqok46hbar/spack-src/tools/tcl.hpj.in",
        "/tmp/vanessa/spack-stage/spack-stage-tcl-8.5.19-76icjut2bqpwmf2fnlt35uiqok46hbar/spack-src/tools/tclSplash.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-tcl-8.5.19-76icjut2bqpwmf2fnlt35uiqok46hbar/spack-src/tools/tcl.wse.in"
    ],
    "total_files": 911
}