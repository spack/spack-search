{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-oclgrind-master-4dgp6tfkpqeujvi5onbaegs2odkqelff/spack-src/src/core/Context.cpp": "// Context.cpp (Oclgrind)\n// Copyright (c) 2013-2019, James Price and Simon McIntosh-Smith,\n// University of Bristol. All rights reserved.\n//\n// This program is provided under a three-clause BSD license. For full\n// license terms please see the LICENSE file distributed with this\n// source code.\n\n#include \"common.h\"\n#include \"config.h\"\n\n#if defined(_WIN32) && !defined(__MINGW32__)\n#include <windows.h>\n#undef ERROR\n#else\n#include <dlfcn.h>\n#endif\n\n#include <mutex>\n\n#include \"llvm/IR/DebugInfo.h\"\n#include \"llvm/IR/Instruction.h\"\n#include \"llvm/IR/LLVMContext.h\"\n\n#include \"Context.h\"\n#include \"Kernel.h\"\n#include \"KernelInvocation.h\"\n#include \"Memory.h\"\n#include \"Program.h\"\n#include \"WorkGroup.h\"\n#include \"WorkItem.h\"\n\n#include \"plugins/InstructionCounter.h\"\n#include \"plugins/InteractiveDebugger.h\"\n#include \"plugins/Logger.h\"\n#include \"plugins/MemCheck.h\"\n#include \"plugins/RaceDetector.h\"\n#include \"plugins/Uninitialized.h\"\n\nusing namespace oclgrind;\nusing namespace std;\n\nContext::Context()\n{\n  m_llvmContext = new llvm::LLVMContext;\n\n  m_globalMemory =\n    new Memory(AddrSpaceGlobal, sizeof(size_t) == 8 ? 16 : 8, this);\n  m_kernelInvocation = NULL;\n\n  loadPlugins();\n}\n\nContext::~Context()\n{\n  delete m_llvmContext;\n  delete m_globalMemory;\n\n  unloadPlugins();\n}\n\nbool Context::isThreadSafe() const\n{\n  for (const PluginEntry& p : m_plugins)\n  {\n    if (!p.first->isThreadSafe())\n      return false;\n  }\n  return true;\n}\n\nMemory* Context::getGlobalMemory() const\n{\n  return m_globalMemory;\n}\n\nllvm::LLVMContext* Context::getLLVMContext() const\n{\n  return m_llvmContext;\n}\n\nvoid Context::loadPlugins()\n{\n  // Create core plugins\n  m_plugins.push_back(make_pair(new Logger(this), true));\n  m_plugins.push_back(make_pair(new MemCheck(this), true));\n\n  if (checkEnv(\"OCLGRIND_INST_COUNTS\"))\n    m_plugins.push_back(make_pair(new InstructionCounter(this), true));\n\n  if (checkEnv(\"OCLGRIND_DATA_RACES\"))\n    m_plugins.push_back(make_pair(new RaceDetector(this), true));\n\n  if (checkEnv(\"OCLGRIND_UNINITIALIZED\"))\n    m_plugins.push_back(make_pair(new Uninitialized(this), true));\n\n  if (checkEnv(\"OCLGRIND_INTERACTIVE\"))\n    m_plugins.push_back(make_pair(new InteractiveDebugger(this), true));\n\n  // Load dynamic plugins\n  const char* dynamicPlugins = getenv(\"OCLGRIND_PLUGINS\");\n  if (dynamicPlugins)\n  {\n    std::istringstream ss(dynamicPlugins);\n    std::string libpath;\n    while (std::getline(ss, libpath, ':'))\n    {\n#if defined(_WIN32) && !defined(__MINGW32__)\n      HMODULE library = LoadLibraryA(libpath.c_str());\n      if (!library)\n      {\n        cerr << \"Loading Oclgrind plugin failed (LoadLibrary): \"\n             << GetLastError() << endl;\n        continue;\n      }\n\n      void* initialize = GetProcAddress(library, \"initializePlugins\");\n      if (!initialize)\n      {\n        cerr << \"Loading Oclgrind plugin failed (GetProcAddress): \"\n             << GetLastError() << endl;\n        continue;\n      }\n#else\n      void* library = dlopen(libpath.c_str(), RTLD_NOW);\n      if (!library)\n      {\n        cerr << \"Loading Oclgrind plugin failed (dlopen): \" << dlerror()\n             << endl;\n        continue;\n      }\n\n      void* initialize = dlsym(library, \"initializePlugins\");\n      if (!initialize)\n      {\n        cerr << \"Loading Oclgrind plugin failed (dlsym): \" << dlerror() << endl;\n        continue;\n      }\n#endif\n\n      ((void (*)(Context*))initialize)(this);\n      m_pluginLibraries.push_back(library);\n    }\n  }\n}\n\nvoid Context::unloadPlugins()\n{\n  // Release dynamic plugin libraries\n  list<void*>::iterator plibItr;\n  for (plibItr = m_pluginLibraries.begin(); plibItr != m_pluginLibraries.end();\n       plibItr++)\n  {\n#if defined(_WIN32) && !defined(__MINGW32__)\n    void* release = GetProcAddress((HMODULE)*plibItr, \"releasePlugins\");\n    if (release)\n    {\n      ((void (*)(Context*))release)(this);\n    }\n    FreeLibrary((HMODULE)*plibItr);\n#else\n    void* release = dlsym(*plibItr, \"releasePlugins\");\n    if (release)\n    {\n      ((void (*)(Context*))release)(this);\n    }\n    dlclose(*plibItr);\n#endif\n  }\n\n  // Destroy internal plugins\n  PluginList::iterator pItr;\n  for (pItr = m_plugins.begin(); pItr != m_plugins.end(); pItr++)\n  {\n    if (pItr->second)\n      delete pItr->first;\n  }\n\n  m_plugins.clear();\n}\n\nvoid Context::registerPlugin(Plugin* plugin)\n{\n  m_plugins.push_back(make_pair(plugin, false));\n}\n\nvoid Context::unregisterPlugin(Plugin* plugin)\n{\n  m_plugins.remove(make_pair(plugin, false));\n}\n\nvoid Context::logError(const char* error) const\n{\n  Message msg(ERROR, this);\n  msg << error << endl\n      << msg.INDENT << \"Kernel: \" << msg.CURRENT_KERNEL << endl\n      << \"Entity: \" << msg.CURRENT_ENTITY << endl\n      << msg.CURRENT_LOCATION << endl;\n  msg.send();\n}\n\n#define NOTIFY(function, ...)                                                  \\\n  {                                                                            \\\n    PluginList::const_iterator pluginItr;                                      \\\n    for (pluginItr = m_plugins.begin(); pluginItr != m_plugins.end();          \\\n         pluginItr++)                                                          \\\n    {                                                                          \\\n      pluginItr->first->function(__VA_ARGS__);                                 \\\n    }                                                                          \\\n  }\n\nvoid Context::notifyInstructionExecuted(const WorkItem* workItem,\n                                        const llvm::Instruction* instruction,\n                                        const TypedValue& result) const\n{\n  NOTIFY(instructionExecuted, workItem, instruction, result);\n}\n\nvoid Context::notifyKernelBegin(const KernelInvocation* kernelInvocation) const\n{\n  assert(m_kernelInvocation == NULL);\n  m_kernelInvocation = kernelInvocation;\n\n  NOTIFY(kernelBegin, kernelInvocation);\n}\n\nvoid Context::notifyKernelEnd(const KernelInvocation* kernelInvocation) const\n{\n  NOTIFY(kernelEnd, kernelInvocation);\n\n  assert(m_kernelInvocation == kernelInvocation);\n  m_kernelInvocation = NULL;\n}\n\nvoid Context::notifyMemoryAllocated(const Memory* memory, size_t address,\n                                    size_t size, cl_mem_flags flags,\n                                    const uint8_t* initData) const\n{\n  NOTIFY(memoryAllocated, memory, address, size, flags, initData);\n}\n\nvoid Context::notifyMemoryAtomicLoad(const Memory* memory, AtomicOp op,\n                                     size_t address, size_t size) const\n{\n  if (m_kernelInvocation && m_kernelInvocation->getCurrentWorkItem())\n  {\n    NOTIFY(memoryAtomicLoad, memory, m_kernelInvocation->getCurrentWorkItem(),\n           op, address, size);\n  }\n}\n\nvoid Context::notifyMemoryAtomicStore(const Memory* memory, AtomicOp op,\n                                      size_t address, size_t size) const\n{\n  if (m_kernelInvocation && m_kernelInvocation->getCurrentWorkItem())\n  {\n    NOTIFY(memoryAtomicStore, memory, m_kernelInvocation->getCurrentWorkItem(),\n           op, address, size);\n  }\n}\n\nvoid Context::notifyMemoryDeallocated(const Memory* memory,\n                                      size_t address) const\n{\n  NOTIFY(memoryDeallocated, memory, address);\n}\n\nvoid Context::notifyMemoryLoad(const Memory* memory, size_t address,\n                               size_t size) const\n{\n  if (m_kernelInvocation)\n  {\n    if (m_kernelInvocation->getCurrentWorkItem())\n    {\n      NOTIFY(memoryLoad, memory, m_kernelInvocation->getCurrentWorkItem(),\n             address, size);\n    }\n    else if (m_kernelInvocation->getCurrentWorkGroup())\n    {\n      NOTIFY(memoryLoad, memory, m_kernelInvocation->getCurrentWorkGroup(),\n             address, size);\n    }\n  }\n  else\n  {\n    NOTIFY(hostMemoryLoad, memory, address, size);\n  }\n}\n\nvoid Context::notifyMemoryMap(const Memory* memory, size_t address,\n                              size_t offset, size_t size,\n                              cl_mem_flags flags) const\n{\n  NOTIFY(memoryMap, memory, address, offset, size, flags);\n}\n\nvoid Context::notifyMemoryStore(const Memory* memory, size_t address,\n                                size_t size, const uint8_t* storeData) const\n{\n  if (m_kernelInvocation)\n  {\n    if (m_kernelInvocation->getCurrentWorkItem())\n    {\n      NOTIFY(memoryStore, memory, m_kernelInvocation->getCurrentWorkItem(),\n             address, size, storeData);\n    }\n    else if (m_kernelInvocation->getCurrentWorkGroup())\n    {\n      NOTIFY(memoryStore, memory, m_kernelInvocation->getCurrentWorkGroup(),\n             address, size, storeData);\n    }\n  }\n  else\n  {\n    NOTIFY(hostMemoryStore, memory, address, size, storeData);\n  }\n}\n\nvoid Context::notifyMessage(MessageType type, const char* message) const\n{\n  NOTIFY(log, type, message);\n}\n\nvoid Context::notifyMemoryUnmap(const Memory* memory, size_t address,\n                                const void* ptr) const\n{\n  NOTIFY(memoryUnmap, memory, address, ptr);\n}\n\nvoid Context::notifyWorkGroupBarrier(const WorkGroup* workGroup,\n                                     uint32_t flags) const\n{\n  NOTIFY(workGroupBarrier, workGroup, flags);\n}\n\nvoid Context::notifyWorkGroupBegin(const WorkGroup* workGroup) const\n{\n  NOTIFY(workGroupBegin, workGroup);\n}\n\nvoid Context::notifyWorkGroupComplete(const WorkGroup* workGroup) const\n{\n  NOTIFY(workGroupComplete, workGroup);\n}\n\nvoid Context::notifyWorkItemBegin(const WorkItem* workItem) const\n{\n  NOTIFY(workItemBegin, workItem);\n}\n\nvoid Context::notifyWorkItemComplete(const WorkItem* workItem) const\n{\n  NOTIFY(workItemComplete, workItem);\n}\n\n#undef NOTIFY\n\nContext::Message::Message(MessageType type, const Context* context)\n{\n  m_type = type;\n  m_context = context;\n  m_kernelInvocation = context->m_kernelInvocation;\n}\n\nContext::Message& Context::Message::operator<<(const special& id)\n{\n  switch (id)\n  {\n  case INDENT:\n    m_indentModifiers.push_back(m_stream.tellp());\n    break;\n  case UNINDENT:\n    m_indentModifiers.push_back(-m_stream.tellp());\n    break;\n  case CURRENT_KERNEL:\n    *this << m_kernelInvocation->getKernel()->getName();\n    break;\n  case CURRENT_WORK_ITEM_GLOBAL:\n  {\n    const WorkItem* workItem = m_kernelInvocation->getCurrentWorkItem();\n    if (workItem)\n    {\n      *this << workItem->getGlobalID();\n    }\n    else\n    {\n      *this << \"(none)\";\n    }\n    break;\n  }\n  case CURRENT_WORK_ITEM_LOCAL:\n  {\n    const WorkItem* workItem = m_kernelInvocation->getCurrentWorkItem();\n    if (workItem)\n    {\n      *this << workItem->getLocalID();\n    }\n    else\n    {\n      *this << \"(none)\";\n    }\n    break;\n  }\n  case CURRENT_WORK_GROUP:\n  {\n    const WorkGroup* workGroup = m_kernelInvocation->getCurrentWorkGroup();\n    if (workGroup)\n    {\n      *this << workGroup->getGroupID();\n    }\n    else\n    {\n      *this << \"(none)\";\n    }\n    break;\n  }\n  case CURRENT_ENTITY:\n  {\n    const WorkItem* workItem = m_kernelInvocation->getCurrentWorkItem();\n    const WorkGroup* workGroup = m_kernelInvocation->getCurrentWorkGroup();\n    if (workItem)\n    {\n      *this << \"Global\" << workItem->getGlobalID() << \" Local\"\n            << workItem->getLocalID() << \" \";\n    }\n    if (workGroup)\n    {\n      *this << \"Group\" << workGroup->getGroupID();\n    }\n    if (!workItem && !workGroup)\n    {\n      *this << \"(unknown)\";\n    }\n    break;\n  }\n  case CURRENT_LOCATION:\n  {\n    const llvm::Instruction* instruction = NULL;\n    const WorkItem* workItem = m_kernelInvocation->getCurrentWorkItem();\n    const WorkGroup* workGroup = m_kernelInvocation->getCurrentWorkGroup();\n    if (workItem)\n    {\n      instruction = workItem->getCurrentInstruction();\n    }\n    else if (workGroup)\n    {\n      instruction = workGroup->getCurrentBarrier();\n    }\n\n    *this << instruction;\n    break;\n  }\n  }\n  return *this;\n}\n\nContext::Message&\nContext::Message::operator<<(const llvm::Instruction* instruction)\n{\n  // Use mutex as some part of LLVM used by dumpInstruction() is not thread-safe\n  static std::mutex mtx;\n  std::lock_guard<std::mutex> lock(mtx);\n\n  if (instruction)\n  {\n    // Output instruction\n    dumpInstruction(m_stream, instruction);\n    *this << endl;\n\n    // Output debug information\n    llvm::MDNode* md = instruction->getMetadata(\"dbg\");\n    if (!md)\n    {\n      *this << \"Debugging information not available.\" << endl;\n    }\n    else\n    {\n      llvm::DILocation* loc = (llvm::DILocation*)md;\n      unsigned lineNumber = loc->getLine();\n      unsigned columnNumber = loc->getColumn();\n      llvm::StringRef filename = loc->getFilename();\n\n      *this << \"At line \" << dec << lineNumber << \" (column \" << columnNumber\n            << \")\"\n            << \" of \" << filename.str() << \":\" << endl;\n\n      // Get source line\n      const Program* program = m_kernelInvocation->getKernel()->getProgram();\n      const char* line = program->getSourceLine(lineNumber);\n      if (line)\n      {\n        while (isspace(line[0]))\n          line++;\n        *this << \"  \" << line;\n      }\n      else\n        *this << \"  (source not available)\";\n    }\n  }\n  else\n  {\n    *this << \"(location unknown)\";\n  }\n\n  return *this;\n}\n\nContext::Message&\nContext::Message::operator<<(std::ostream& (*t)(std::ostream&))\n{\n  m_stream << t;\n  return *this;\n}\n\nContext::Message& Context::Message::operator<<(std::ios& (*t)(std::ios&))\n{\n  m_stream << t;\n  return *this;\n}\n\nContext::Message&\nContext::Message::operator<<(std::ios_base& (*t)(std::ios_base&))\n{\n  m_stream << t;\n  return *this;\n}\n\nvoid Context::Message::send() const\n{\n  string msg;\n\n  string line;\n  int currentIndent = 0;\n  list<int>::const_iterator itr = m_indentModifiers.begin();\n\n  m_stream.clear();\n  m_stream.seekg(0);\n  while (m_stream.good())\n  {\n    getline(m_stream, line);\n\n    // TODO: Wrap long lines\n    msg += line;\n\n    // Check for indentation modifiers\n    long pos = m_stream.tellg();\n    if (itr != m_indentModifiers.end() && pos >= abs(*itr))\n    {\n      if (*itr >= 0)\n        currentIndent++;\n      else\n        currentIndent--;\n      itr++;\n    }\n\n    if (!m_stream.eof())\n    {\n      // Add newline and indentation\n      msg += '\\n';\n      for (int i = 0; i < currentIndent; i++)\n        msg += '\\t';\n    }\n  }\n\n  m_context->notifyMessage(m_type, msg.c_str());\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-oclgrind-master-4dgp6tfkpqeujvi5onbaegs2odkqelff/spack-src/src/install/oclgrind-icd.reg",
        "/tmp/vanessa/spack-stage/spack-stage-oclgrind-master-4dgp6tfkpqeujvi5onbaegs2odkqelff/spack-src/.git/objects/pack/pack-1ba79687b7998bf58b787a452df5f2ca8b920362.pack",
        "/tmp/vanessa/spack-stage/spack-stage-oclgrind-master-4dgp6tfkpqeujvi5onbaegs2odkqelff/spack-src/.git/objects/pack/pack-1ba79687b7998bf58b787a452df5f2ca8b920362.idx"
    ],
    "total_files": 383
}