{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Utilities/cmcurl/ldap.c": "/***************************************************************************\n *                      _   _ ____  _\n *  Project         ___| | | |  _ \\| |\n *                 / __| | | | |_) | |\n *                | (__| |_| |  _ <| |___\n *                 \\___|\\___/|_| \\_\\_____|\n *\n * Copyright (C) 1998 - 2007, Daniel Stenberg, <daniel@haxx.se>, et al.\n *\n * This software is licensed as described in the file COPYING, which\n * you should have received as part of this distribution. The terms\n * are also available at http://curl.haxx.se/docs/copyright.html.\n *\n * You may opt to use, copy, modify, merge, publish, distribute and/or sell\n * copies of the Software, and permit persons to whom the Software is\n * furnished to do so, under the terms of the COPYING file.\n *\n * This software is distributed on an \"AS IS\" basis, WITHOUT WARRANTY OF ANY\n * KIND, either express or implied.\n *\n * $Id$\n ***************************************************************************/\n\n#include \"setup.h\"\n\n#ifndef CURL_DISABLE_LDAP\n/* -- WIN32 approved -- */\n#include <stdio.h>\n#include <string.h>\n#include <stdarg.h>\n#include <stdlib.h>\n#include <ctype.h>\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#ifdef HAVE_SYS_STAT_H\n#include <sys/stat.h>\n#endif\n#ifdef NEED_MALLOC_H\n#include <malloc.h>\n#endif\n#include <errno.h>\n\n#if defined(WIN32)\n# include <winldap.h>\n#endif\n\n#ifdef HAVE_UNISTD_H\n# include <unistd.h>\n#endif\n\n#ifdef HAVE_DLFCN_H\n# include <dlfcn.h>\n#endif\n\n#include \"urldata.h\"\n#include <curl/curl.h>\n#include \"sendf.h\"\n#include \"escape.h\"\n#include \"transfer.h\"\n#include \"strequal.h\"\n#include \"strtok.h\"\n#include \"ldap.h\"\n#include \"memory.h\"\n#include \"base64.h\"\n\n#define _MPRINTF_REPLACE /* use our functions only */\n#include <curl/mprintf.h>\n\n#include \"memdebug.h\"\n\n/* WLdap32.dll functions are *not* stdcall. Must call these via __cdecl\n * pointers in case libcurl was compiled as fastcall (cl -Gr). Watcom\n * uses fastcall by default.\n */\n#if !defined(WIN32) && !defined(__cdecl)\n#define __cdecl\n#endif\n\n#ifndef LDAP_SIZELIMIT_EXCEEDED\n#define LDAP_SIZELIMIT_EXCEEDED 4\n#endif\n#ifndef LDAP_VERSION2\n#define LDAP_VERSION2 2\n#endif\n#ifndef LDAP_VERSION3\n#define LDAP_VERSION3 3\n#endif\n#ifndef LDAP_OPT_PROTOCOL_VERSION\n#define LDAP_OPT_PROTOCOL_VERSION 0x0011\n#endif\n\n#define DLOPEN_MODE   RTLD_LAZY  /*! assume all dlopen() implementations have\n                                   this */\n\n#if defined(RTLD_LAZY_GLOBAL)    /* It turns out some systems use this: */\n# undef  DLOPEN_MODE\n# define DLOPEN_MODE  RTLD_LAZY_GLOBAL\n#elif defined(RTLD_GLOBAL)\n# undef  DLOPEN_MODE\n# define DLOPEN_MODE  (RTLD_LAZY | RTLD_GLOBAL)\n#endif\n\n#define DYNA_GET_FUNCTION(type, fnc) do { \\\n          (fnc) = (type)DynaGetFunction(#fnc); \\\n          if ((fnc) == NULL) \\\n             return CURLE_FUNCTION_NOT_FOUND; \\\n        } while (0)\n\n/*! CygWin etc. configure could set these, but we don't want it.\n * Must use WLdap32.dll code.\n */\n#if defined(WIN32)\n#undef HAVE_DLOPEN\n#undef HAVE_LIBDL\n#endif\n\n/* \n * We use this ZERO_NULL to avoid picky compiler warnings,\n * when assigning a NULL pointer to a function pointer var.\n */\n\n#define ZERO_NULL 0\n\ntypedef void * (*dynafunc)(void *input);\n\n/***********************************************************************\n */\n#if defined(HAVE_DLOPEN) || defined(HAVE_LIBDL) || defined(WIN32)\nstatic void *libldap = NULL;\n#if defined(DL_LBER_FILE)\nstatic void *liblber = NULL;\n#endif\n#endif\n\nstruct bv {\n  unsigned long bv_len;\n  char  *bv_val;\n};\n\nstatic int DynaOpen(const char **mod_name)\n{\n#if defined(HAVE_DLOPEN) || defined(HAVE_LIBDL)\n  if (libldap == NULL) {\n    /*\n     * libldap.so can normally resolve its dependency on liblber.so\n     * automatically, but in broken installation it does not so\n     * handle it here by opening liblber.so as global.\n     */\n#ifdef DL_LBER_FILE\n    *mod_name = DL_LBER_FILE;\n    liblber = dlopen(*mod_name, DLOPEN_MODE);\n    if (!liblber)\n      return 0;\n#endif\n\n    /* Assume loading libldap.so will fail if loading of liblber.so failed\n     */\n    *mod_name = DL_LDAP_FILE;\n    libldap = dlopen(*mod_name, RTLD_LAZY);\n  }\n  return (libldap != NULL);\n\n#elif defined(WIN32)\n  *mod_name = DL_LDAP_FILE;\n  if (!libldap)\n    libldap = (void*)LoadLibrary(*mod_name);\n  return (libldap != NULL);\n\n#else\n  *mod_name = \"\";\n  return (0);\n#endif\n}\n\nstatic void DynaClose(void)\n{\n#if defined(HAVE_DLOPEN) || defined(HAVE_LIBDL)\n  if (libldap) {\n    dlclose(libldap);\n    libldap=NULL;\n  }\n#ifdef DL_LBER_FILE\n  if (liblber) {\n    dlclose(liblber);\n    liblber=NULL;\n  }\n#endif\n#elif defined(WIN32)\n  if (libldap) {\n    FreeLibrary ((HMODULE)libldap);\n    libldap = NULL;\n  }\n#endif\n}\n\nstatic dynafunc DynaGetFunction(const char *name)\n{\n  dynafunc func = (dynafunc)ZERO_NULL;\n\n#if defined(HAVE_DLOPEN) || defined(HAVE_LIBDL)\n  if (libldap) {\n    /* This typecast magic below was brought by Joe Halpin. In ISO C, you\n     * cannot typecast a data pointer to a function pointer, but that's\n     * exactly what we need to do here to avoid compiler warnings on picky\n     * compilers! */\n    *(void**) (&func) = dlsym(libldap, name);\n  }\n#elif defined(WIN32)\n  if (libldap) {\n    func = (dynafunc)GetProcAddress((HINSTANCE)libldap, name);\n  }\n#else\n  (void) name;\n#endif\n  return func;\n}\n\n/***********************************************************************\n */\ntypedef struct ldap_url_desc {\n    struct ldap_url_desc *lud_next;\n    char   *lud_scheme;\n    char   *lud_host;\n    int     lud_port;\n    char   *lud_dn;\n    char  **lud_attrs;\n    int     lud_scope;\n    char   *lud_filter;\n    char  **lud_exts;\n    int     lud_crit_exts;\n} LDAPURLDesc;\n\n#ifdef WIN32\nstatic int  _ldap_url_parse (const struct connectdata *conn,\n                             LDAPURLDesc **ludp);\nstatic void _ldap_free_urldesc (LDAPURLDesc *ludp);\n\nstatic void (*ldap_free_urldesc)(LDAPURLDesc *) = _ldap_free_urldesc;\n#endif\n\n#ifdef DEBUG_LDAP\n  #define LDAP_TRACE(x)   do { \\\n                            _ldap_trace (\"%u: \", __LINE__); \\\n                            _ldap_trace x; \\\n                          } while (0)\n\n  static void _ldap_trace (const char *fmt, ...);\n#else\n  #define LDAP_TRACE(x)   ((void)0)\n#endif\n\n\nCURLcode Curl_ldap(struct connectdata *conn, bool *done)\n{\n  CURLcode status = CURLE_OK;\n  int rc = 0;\n#ifndef WIN32\n  int    (*ldap_url_parse)(char *, LDAPURLDesc **);\n  void   (*ldap_free_urldesc)(void *);\n#endif\n  void  *(__cdecl *ldap_init)(char *, int);\n  int    (__cdecl *ldap_simple_bind_s)(void *, char *, char *);\n  int    (__cdecl *ldap_unbind_s)(void *);\n  int    (__cdecl *ldap_search_s)(void *, char *, int, char *, char **,\n                                  int, void **);\n  void  *(__cdecl *ldap_first_entry)(void *, void *);\n  void  *(__cdecl *ldap_next_entry)(void *, void *);\n  char  *(__cdecl *ldap_err2string)(int);\n  char  *(__cdecl *ldap_get_dn)(void *, void *);\n  char  *(__cdecl *ldap_first_attribute)(void *, void *, void **);\n  char  *(__cdecl *ldap_next_attribute)(void *, void *, void *);\n  void **(__cdecl *ldap_get_values_len)(void *, void *, const char *);\n  void   (__cdecl *ldap_value_free_len)(void **);\n  void   (__cdecl *ldap_memfree)(void *);\n  void   (__cdecl *ber_free)(void *, int);\n  int    (__cdecl *ldap_set_option)(void *, int, void *);\n\n  void *server;\n  LDAPURLDesc *ludp = NULL;\n  const char *mod_name;\n  void *result;\n  void *entryIterator;     /*! type should be 'LDAPMessage *' */\n  int num = 0;\n  struct SessionHandle *data=conn->data;\n  int ldap_proto;\n  char *val_b64;\n  size_t val_b64_sz;\n\n  *done = TRUE; /* unconditionally */\n  infof(data, \"LDAP local: %s\\n\", data->change.url);\n\n  if (!DynaOpen(&mod_name)) {\n    failf(data, \"The %s LDAP library/libraries couldn't be opened\", mod_name);\n    return CURLE_LIBRARY_NOT_FOUND;\n  }\n\n  /* The types are needed because ANSI C distinguishes between\n   * pointer-to-object (data) and pointer-to-function.\n   */\n  DYNA_GET_FUNCTION(void *(__cdecl *)(char *, int), ldap_init);\n  DYNA_GET_FUNCTION(int (__cdecl *)(void *, char *, char *),\n                    ldap_simple_bind_s);\n  DYNA_GET_FUNCTION(int (__cdecl *)(void *), ldap_unbind_s);\n#ifndef WIN32\n  DYNA_GET_FUNCTION(int (*)(char *, LDAPURLDesc **), ldap_url_parse);\n  DYNA_GET_FUNCTION(void (*)(void *), ldap_free_urldesc);\n#endif\n  DYNA_GET_FUNCTION(int (__cdecl *)(void *, char *, int, char *, char **, int,\n                                    void **), ldap_search_s);\n  DYNA_GET_FUNCTION(void *(__cdecl *)(void *, void *), ldap_first_entry);\n  DYNA_GET_FUNCTION(void *(__cdecl *)(void *, void *), ldap_next_entry);\n  DYNA_GET_FUNCTION(char *(__cdecl *)(int), ldap_err2string);\n  DYNA_GET_FUNCTION(char *(__cdecl *)(void *, void *), ldap_get_dn);\n  DYNA_GET_FUNCTION(char *(__cdecl *)(void *, void *, void **),\n                    ldap_first_attribute);\n  DYNA_GET_FUNCTION(char *(__cdecl *)(void *, void *, void *),\n                    ldap_next_attribute);\n  DYNA_GET_FUNCTION(void **(__cdecl *)(void *, void *, const char *),\n                    ldap_get_values_len);\n  DYNA_GET_FUNCTION(void (__cdecl *)(void **), ldap_value_free_len);\n  DYNA_GET_FUNCTION(void (__cdecl *)(void *), ldap_memfree);\n  DYNA_GET_FUNCTION(void (__cdecl *)(void *, int), ber_free);\n  DYNA_GET_FUNCTION(int (__cdecl *)(void *, int, void *), ldap_set_option);\n\n  server = (*ldap_init)(conn->host.name, (int)conn->port);\n  if (server == NULL) {\n    failf(data, \"LDAP local: Cannot connect to %s:%d\",\n          conn->host.name, conn->port);\n    status = CURLE_COULDNT_CONNECT;\n    goto quit;\n  }\n\n  ldap_proto = LDAP_VERSION3;\n  (*ldap_set_option)(server, LDAP_OPT_PROTOCOL_VERSION, &ldap_proto);\n  rc = (*ldap_simple_bind_s)(server,\n                             conn->bits.user_passwd ? conn->user : NULL,\n                             conn->bits.user_passwd ? conn->passwd : NULL);\n  if (rc != 0) {\n    ldap_proto = LDAP_VERSION2;\n    (*ldap_set_option)(server, LDAP_OPT_PROTOCOL_VERSION, &ldap_proto);\n    rc = (*ldap_simple_bind_s)(server,\n                               conn->bits.user_passwd ? conn->user : NULL,\n                               conn->bits.user_passwd ? conn->passwd : NULL);\n  }\n  if (rc != 0) {\n     failf(data, \"LDAP local: %s\", (*ldap_err2string)(rc));\n     status = CURLE_LDAP_CANNOT_BIND;\n     goto quit;\n  }\n\n#ifdef WIN32\n  rc = _ldap_url_parse(conn, &ludp);\n#else\n  rc = (*ldap_url_parse)(data->change.url, &ludp);\n#endif\n\n  if (rc != 0) {\n     failf(data, \"LDAP local: %s\", (*ldap_err2string)(rc));\n     status = CURLE_LDAP_INVALID_URL;\n     goto quit;\n  }\n\n  rc = (*ldap_search_s)(server, ludp->lud_dn, ludp->lud_scope,\n                        ludp->lud_filter, ludp->lud_attrs, 0, &result);\n\n  if (rc != 0 && rc != LDAP_SIZELIMIT_EXCEEDED) {\n    failf(data, \"LDAP remote: %s\", (*ldap_err2string)(rc));\n    status = CURLE_LDAP_SEARCH_FAILED;\n    goto quit;\n  }\n\n  for(num = 0, entryIterator = (*ldap_first_entry)(server, result);\n      entryIterator;\n      entryIterator = (*ldap_next_entry)(server, entryIterator), num++)\n  {\n    void  *ber = NULL;      /*! is really 'BerElement **' */\n    void  *attribute;       /*! suspicious that this isn't 'const' */\n    char  *dn = (*ldap_get_dn)(server, entryIterator);\n    int i;\n\n    Curl_client_write(conn, CLIENTWRITE_BODY, (char *)\"DN: \", 4);\n    Curl_client_write(conn, CLIENTWRITE_BODY, (char *)dn, 0);\n    Curl_client_write(conn, CLIENTWRITE_BODY, (char *)\"\\n\", 1);\n\n    for (attribute = (*ldap_first_attribute)(server, entryIterator, &ber);\n         attribute;\n         attribute = (*ldap_next_attribute)(server, entryIterator, ber))\n    {\n      struct bv **vals = (struct bv **)\n        (*ldap_get_values_len)(server, entryIterator, attribute);\n\n      if (vals != NULL)\n      {\n        for (i = 0; (vals[i] != NULL); i++)\n        {\n          Curl_client_write(conn, CLIENTWRITE_BODY, (char *)\"\\t\", 1);\n          Curl_client_write(conn, CLIENTWRITE_BODY, (char *) attribute, 0);\n          Curl_client_write(conn, CLIENTWRITE_BODY, (char *)\": \", 2);\n          if ((strlen(attribute) > 7) &&\n              (strcmp(\";binary\",\n                      (char *)attribute +\n                      (strlen((char *)attribute) - 7)) == 0)) {\n            /* Binary attribute, encode to base64. */\n            val_b64_sz = Curl_base64_encode(conn->data,\n                                            vals[i]->bv_val,\n                                            vals[i]->bv_len,\n                                            &val_b64);\n            if (val_b64_sz > 0) {\n              Curl_client_write(conn, CLIENTWRITE_BODY, val_b64, val_b64_sz);\n              free(val_b64);\n            }\n          } else\n            Curl_client_write(conn, CLIENTWRITE_BODY, vals[i]->bv_val,\n                              vals[i]->bv_len);\n          Curl_client_write(conn, CLIENTWRITE_BODY, (char *)\"\\n\", 0);\n        }\n\n        /* Free memory used to store values */\n        (*ldap_value_free_len)((void **)vals);\n      }\n      Curl_client_write(conn, CLIENTWRITE_BODY, (char *)\"\\n\", 1);\n\n      (*ldap_memfree)(attribute);\n    }\n    (*ldap_memfree)(dn);\n    if (ber)\n       (*ber_free)(ber, 0);\n  }\n\nquit:\n  LDAP_TRACE ((\"Received %d entries\\n\", num));\n  if (rc == LDAP_SIZELIMIT_EXCEEDED)\n     infof(data, \"There are more than %d entries\\n\", num);\n  if (ludp)\n     (*ldap_free_urldesc)(ludp);\n  if (server)\n     (*ldap_unbind_s)(server);\n\n  DynaClose();\n\n  /* no data to transfer */\n  Curl_setup_transfer(conn, -1, -1, FALSE, NULL, -1, NULL);\n  conn->bits.close = TRUE;\n\n  return status;\n}\n\n#ifdef DEBUG_LDAP\nstatic void _ldap_trace (const char *fmt, ...)\n{\n  static int do_trace = -1;\n  va_list args;\n\n  if (do_trace == -1) {\n    const char *env = getenv(\"CURL_TRACE\");\n    do_trace = (env && atoi(env) > 0);\n  }\n  if (!do_trace)\n    return;\n\n  va_start (args, fmt);\n  vfprintf (stderr, fmt, args);\n  va_end (args);\n}\n#endif\n\n#ifdef WIN32\n/*\n * Return scope-value for a scope-string.\n */\nstatic int str2scope (const char *p)\n{\n  if (!stricmp(p, \"one\"))\n     return LDAP_SCOPE_ONELEVEL;\n  if (!stricmp(p, \"onetree\"))\n     return LDAP_SCOPE_ONELEVEL;\n  if (!stricmp(p, \"base\"))\n     return LDAP_SCOPE_BASE;\n  if (!stricmp(p, \"sub\"))\n     return LDAP_SCOPE_SUBTREE;\n  if (!stricmp( p, \"subtree\"))\n     return LDAP_SCOPE_SUBTREE;\n  return (-1);\n}\n\n/*\n * Split 'str' into strings separated by commas.\n * Note: res[] points into 'str'.\n */\nstatic char **split_str (char *str)\n{\n  char **res, *lasts, *s;\n  int  i;\n\n  for (i = 2, s = strchr(str,','); s; i++)\n     s = strchr(++s,',');\n\n  res = calloc(i, sizeof(char*));\n  if (!res)\n    return NULL;\n\n  for (i = 0, s = strtok_r(str, \",\", &lasts); s;\n       s = strtok_r(NULL, \",\", &lasts), i++)\n    res[i] = s;\n  return res;\n}\n\n/*\n * Unescape the LDAP-URL components\n */\nstatic bool unescape_elements (void *data, LDAPURLDesc *ludp)\n{\n  int i;\n\n  if (ludp->lud_filter) {\n    ludp->lud_filter = curl_easy_unescape(data, ludp->lud_filter, 0, NULL);\n    if (!ludp->lud_filter)\n       return (FALSE);\n  }\n\n  for (i = 0; ludp->lud_attrs && ludp->lud_attrs[i]; i++) {\n    ludp->lud_attrs[i] = curl_easy_unescape(data, ludp->lud_attrs[i], 0, NULL);\n    if (!ludp->lud_attrs[i])\n       return (FALSE);\n  }\n\n  for (i = 0; ludp->lud_exts && ludp->lud_exts[i]; i++) {\n    ludp->lud_exts[i] = curl_easy_unescape(data, ludp->lud_exts[i], 0, NULL);\n    if (!ludp->lud_exts[i])\n       return (FALSE);\n  }\n\n  if (ludp->lud_dn) {\n    char *dn = ludp->lud_dn;\n    char *new_dn = curl_easy_unescape(data, dn, 0, NULL);\n\n    free(dn);\n    ludp->lud_dn = new_dn;\n    if (!new_dn)\n       return (FALSE);\n  }\n  return (TRUE);\n}\n\n/*\n * Break apart the pieces of an LDAP URL.\n * Syntax:\n *   ldap://<hostname>:<port>/<base_dn>?<attributes>?<scope>?<filter>?<ext>\n *\n * <hostname> already known from 'conn->host.name'.\n * <port>     already known from 'conn->remote_port'.\n * extract the rest from 'conn->data->reqdata.path+1'. All fields are optional.\n * e.g.\n *   ldap://<hostname>:<port>/?<attributes>?<scope>?<filter>\n * yields ludp->lud_dn = \"\".\n *\n * Ref. http://developer.netscape.com/docs/manuals/dirsdk/csdk30/url.htm#2831915\n */\nstatic int _ldap_url_parse2 (const struct connectdata *conn, LDAPURLDesc *ludp)\n{\n  char *p, *q;\n  int i;\n\n  if (!conn->data ||\n      !conn->data->reqdata.path ||\n       conn->data->reqdata.path[0] != '/' ||\n      !checkprefix(conn->protostr, conn->data->change.url))\n     return LDAP_INVALID_SYNTAX;\n\n  ludp->lud_scope = LDAP_SCOPE_BASE;\n  ludp->lud_port  = conn->remote_port;\n  ludp->lud_host  = conn->host.name;\n\n  /* parse DN (Distinguished Name).\n   */\n  ludp->lud_dn = strdup(conn->data->reqdata.path+1);\n  if (!ludp->lud_dn)\n     return LDAP_NO_MEMORY;\n\n  p = strchr(ludp->lud_dn, '?');\n  LDAP_TRACE ((\"DN '%.*s'\\n\", p ? (size_t)(p-ludp->lud_dn) :\n               strlen(ludp->lud_dn), ludp->lud_dn));\n\n  if (!p)\n     goto success;\n\n  *p++ = '\\0';\n\n  /* parse attributes. skip \"??\".\n   */\n  q = strchr(p, '?');\n  if (q)\n     *q++ = '\\0';\n\n  if (*p && *p != '?') {\n    ludp->lud_attrs = split_str(p);\n    if (!ludp->lud_attrs)\n       return LDAP_NO_MEMORY;\n\n    for (i = 0; ludp->lud_attrs[i]; i++)\n        LDAP_TRACE ((\"attr[%d] '%s'\\n\", i, ludp->lud_attrs[i]));\n  }\n\n  p = q;\n  if (!p)\n     goto success;\n\n  /* parse scope. skip \"??\"\n   */\n  q = strchr(p, '?');\n  if (q)\n     *q++ = '\\0';\n\n  if (*p && *p != '?') {\n    ludp->lud_scope = str2scope(p);\n    if (ludp->lud_scope == -1)\n       return LDAP_INVALID_SYNTAX;\n    LDAP_TRACE ((\"scope %d\\n\", ludp->lud_scope));\n  }\n\n  p = q;\n  if (!p)\n     goto success;\n\n  /* parse filter\n   */\n  q = strchr(p, '?');\n  if (q)\n     *q++ = '\\0';\n  if (!*p)\n     return LDAP_INVALID_SYNTAX;\n\n  ludp->lud_filter = p;\n  LDAP_TRACE ((\"filter '%s'\\n\", ludp->lud_filter));\n\n  p = q;\n  if (!p)\n     goto success;\n\n  /* parse extensions\n   */\n  ludp->lud_exts = split_str(p);\n  if (!ludp->lud_exts)\n     return LDAP_NO_MEMORY;\n\n  for (i = 0; ludp->lud_exts[i]; i++)\n      LDAP_TRACE ((\"exts[%d] '%s'\\n\", i, ludp->lud_exts[i]));\n\nsuccess:\n  if (!unescape_elements(conn->data, ludp))\n     return LDAP_NO_MEMORY;\n  return LDAP_SUCCESS;\n}\n\nstatic int _ldap_url_parse (const struct connectdata *conn,\n                            LDAPURLDesc **ludpp)\n{\n  LDAPURLDesc *ludp = calloc(sizeof(*ludp), 1);\n  int rc;\n\n  *ludpp = NULL;\n  if (!ludp)\n     return LDAP_NO_MEMORY;\n\n  rc = _ldap_url_parse2 (conn, ludp);\n  if (rc != LDAP_SUCCESS) {\n    _ldap_free_urldesc(ludp);\n    ludp = NULL;\n  }\n  *ludpp = ludp;\n  return (rc);\n}\n\nstatic void _ldap_free_urldesc (LDAPURLDesc *ludp)\n{\n  int i;\n\n  if (!ludp)\n     return;\n\n  if (ludp->lud_dn)\n     free(ludp->lud_dn);\n\n  if (ludp->lud_filter)\n     free(ludp->lud_filter);\n\n  if (ludp->lud_attrs) {\n    for (i = 0; ludp->lud_attrs[i]; i++)\n       free(ludp->lud_attrs[i]);\n    free(ludp->lud_attrs);\n  }\n\n  if (ludp->lud_exts) {\n    for (i = 0; ludp->lud_exts[i]; i++)\n       free(ludp->lud_exts[i]);\n    free(ludp->lud_exts);\n  }\n  free (ludp);\n}\n#endif  /* WIN32 */\n#endif  /* CURL_DISABLE_LDAP */\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Source/kwsys/DynamicLoader.cxx": "/*============================================================================\n  KWSys - Kitware System Library\n  Copyright 2000-2009 Kitware, Inc., Insight Software Consortium\n\n  Distributed under the OSI-approved BSD License (the \"License\");\n  see accompanying file Copyright.txt for details.\n\n  This software is distributed WITHOUT ANY WARRANTY; without even the\n  implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n  See the License for more information.\n============================================================================*/\n#include \"kwsysPrivate.h\"\n#include KWSYS_HEADER(DynamicLoader.hxx)\n\n#include KWSYS_HEADER(Configure.hxx)\n\n// Work-around CMake dependency scanning limitation.  This must\n// duplicate the above list of headers.\n#if 0\n# include \"DynamicLoader.hxx.in\"\n# include \"Configure.hxx.in\"\n#endif\n\n// This file is actually 3 different implementations.\n// 1. HP machines which uses shl_load\n// 2. Mac OS X 10.2.x and earlier which uses NSLinkModule\n// 3. Windows which uses LoadLibrary\n// 4. Most unix systems (including Mac OS X 10.3 and later) which use dlopen\n// (default) Each part of the ifdef contains a complete implementation for\n// the static methods of DynamicLoader.\n\n// ---------------------------------------------------------------\n// 1. Implementation for HPUX  machines\n#ifdef __hpux\n#include <errno.h>\n#include <dl.h>\n#define DYNAMICLOADER_DEFINED 1\n\nnamespace KWSYS_NAMESPACE\n{\n\n//----------------------------------------------------------------------------\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(const char* libname )\n{\n  return shl_load(libname, BIND_DEFERRED | DYNAMIC_PATH, 0L);\n}\n\n//----------------------------------------------------------------------------\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  return !shl_unload(lib);\n}\n\n//----------------------------------------------------------------------------\nDynamicLoader::SymbolPointer\nDynamicLoader::GetSymbolAddress(DynamicLoader::LibraryHandle lib, const char* sym)\n{\n  void* addr;\n  int status;\n\n  /* TYPE_PROCEDURE Look for a function or procedure. (This used to be default)\n   * TYPE_DATA      Look for a symbol in the data segment (for example, variables).\n   * TYPE_UNDEFINED Look for any symbol.\n   */\n  status = shl_findsym (&lib, sym, TYPE_UNDEFINED, &addr);\n  void* result = (status < 0) ? (void*)0 : addr;\n\n  // Hack to cast pointer-to-data to pointer-to-function.\n  return *reinterpret_cast<DynamicLoader::SymbolPointer*>(&result);\n}\n\nconst char* DynamicLoader::LastError()\n{\n  // TODO: Need implementation with errno/strerror\n  /* If successful, shl_findsym returns an integer (int) value zero. If\n   * shl_findsym cannot find sym, it returns -1 and sets errno to zero.\n   * If any other errors occur, shl_findsym returns -1 and sets errno to one\n   * of these values (defined in <errno.h>):\n   * ENOEXEC\n   * A format error was detected in the specified library.\n   * ENOSYM\n   * A symbol on which sym depends could not be found.\n   * EINVAL\n   * The specified handle is invalid.\n   */\n\n  if(  errno == ENOEXEC\n    || errno == ENOSYM\n    || errno == EINVAL )\n    {\n    return strerror(errno);\n    }\n  // else\n  return 0;\n}\n\n} // namespace KWSYS_NAMESPACE\n\n#endif //__hpux\n\n\n// ---------------------------------------------------------------\n// 2. Implementation for Mac OS X 10.2.x and earlier\n#ifdef __APPLE__\n#if MAC_OS_X_VERSION_MAX_ALLOWED < 1030\n#include <string.h> // for strlen\n#include <mach-o/dyld.h>\n#define DYNAMICLOADER_DEFINED 1\n\nnamespace KWSYS_NAMESPACE\n{\n\n//----------------------------------------------------------------------------\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(const char* libname )\n{\n  NSObjectFileImageReturnCode rc;\n  NSObjectFileImage image = 0;\n\n  rc = NSCreateObjectFileImageFromFile(libname, &image);\n  // rc == NSObjectFileImageInappropriateFile when trying to load a dylib file\n  if( rc != NSObjectFileImageSuccess )\n    {\n    return 0;\n    }\n  NSModule handle = NSLinkModule(image, libname,\n    NSLINKMODULE_OPTION_BINDNOW|NSLINKMODULE_OPTION_RETURN_ON_ERROR);\n  NSDestroyObjectFileImage(image);\n  return handle;\n}\n\n//----------------------------------------------------------------------------\nint DynamicLoader::CloseLibrary( DynamicLoader::LibraryHandle lib)\n{\n  // NSUNLINKMODULE_OPTION_KEEP_MEMORY_MAPPED\n  // With  this  option  the memory for the module is not deallocated\n  // allowing pointers into the module to still be valid.\n  // You should use this option instead if your code experience some problems\n  // reported against Panther 10.3.9 (fixed in Tiger 10.4.2 and up)\n  bool success = NSUnLinkModule(lib, NSUNLINKMODULE_OPTION_NONE);\n  return success;\n}\n\n//----------------------------------------------------------------------------\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const char* sym)\n{\n  void *result=0;\n  // Need to prepend symbols with '_' on Apple-gcc compilers\n  size_t len = strlen(sym);\n  char *rsym = new char[len + 1 + 1];\n  strcpy(rsym, \"_\");\n  strcat(rsym+1, sym);\n\n  NSSymbol symbol = NSLookupSymbolInModule(lib, rsym);\n  if(symbol)\n    {\n    result = NSAddressOfSymbol(symbol);\n    }\n\n  delete[] rsym;\n  // Hack to cast pointer-to-data to pointer-to-function.\n  return *reinterpret_cast<DynamicLoader::SymbolPointer*>(&result);\n}\n\n//----------------------------------------------------------------------------\nconst char* DynamicLoader::LastError()\n{\n  return 0;\n}\n\n} // namespace KWSYS_NAMESPACE\n\n#endif // MAC_OS_X_VERSION_MAX_ALLOWED < 1030\n#endif // __APPLE__\n\n// ---------------------------------------------------------------\n// 3. Implementation for Windows win32 code but not cygwin\n#if defined(_WIN32) && !defined(__CYGWIN__)\n#include <windows.h>\n#define DYNAMICLOADER_DEFINED 1\n\nnamespace KWSYS_NAMESPACE\n{\n\n//----------------------------------------------------------------------------\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(const char* libname)\n{\n  DynamicLoader::LibraryHandle lh;\n#ifdef UNICODE\n  wchar_t libn[MB_CUR_MAX];\n  mbstowcs(libn, libname, MB_CUR_MAX);\n  lh = LoadLibrary(libn);\n#else\n  lh = LoadLibrary(libname);\n#endif\n  return lh;\n}\n\n//----------------------------------------------------------------------------\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  return (int)FreeLibrary(lib);\n}\n\n//----------------------------------------------------------------------------\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const char* sym)\n{\n  // TODO: The calling convention affects the name of the symbol.  We\n  // should have a tool to help get the symbol with the desired\n  // calling convention.  Currently we assume cdecl.\n  //\n  // Borland:\n  //   __cdecl    = \"_func\" (default)\n  //   __fastcall = \"@_func\"\n  //   __stdcall  = \"func\"\n  //\n  // Watcom:\n  //   __cdecl    = \"_func\"\n  //   __fastcall = \"@_func@X\"\n  //   __stdcall  = \"_func@X\"\n  //   __watcall  = \"func_\" (default)\n  //\n  // MSVC:\n  //   __cdecl    = \"func\" (default)\n  //   __fastcall = \"@_func@X\"\n  //   __stdcall  = \"_func@X\"\n  //\n  // Note that the \"@X\" part of the name above is the total size (in\n  // bytes) of the arguments on the stack.\n  void *result;\n#if defined(__BORLANDC__) || defined(__WATCOMC__)\n  // Need to prepend symbols with '_'\n  size_t len = strlen(sym);\n  char *rsym = new char[len + 1 + 1];\n  strcpy(rsym, \"_\");\n  strcat(rsym, sym);\n#else\n  const char *rsym = sym;\n#endif\n#ifdef UNICODE\n  wchar_t wsym[MB_CUR_MAX];\n  mbstowcs(wsym, rsym, MB_CUR_MAX);\n  result = GetProcAddress(lib, wsym);\n#else\n  result = (void*)GetProcAddress(lib, rsym);\n#endif\n#if defined(__BORLANDC__) || defined(__WATCOMC__)\n  delete[] rsym;\n#endif\n  // Hack to cast pointer-to-data to pointer-to-function.\n#ifdef __WATCOMC__\n  return *(DynamicLoader::SymbolPointer*)(&result);\n#else\n  return *reinterpret_cast<DynamicLoader::SymbolPointer*>(&result);\n#endif\n}\n\n//----------------------------------------------------------------------------\nconst char* DynamicLoader::LastError()\n{\n  LPVOID lpMsgBuf=NULL;\n\n  FormatMessage(\n    FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,\n    NULL,\n    GetLastError(),\n    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language\n    (LPTSTR) &lpMsgBuf,\n    0,\n    NULL\n    );\n\n  if(!lpMsgBuf)\n    {\n    return NULL;\n    }\n\n  static char* str = 0;\n  delete [] str;\n  str = strcpy(new char[strlen((char*)lpMsgBuf)+1], (char*)lpMsgBuf);\n  // Free the buffer.\n  LocalFree( lpMsgBuf );\n  return str;\n}\n\n} // namespace KWSYS_NAMESPACE\n\n#endif //_WIN32\n\n// ---------------------------------------------------------------\n// 4. Implementation for BeOS\n#if defined __BEOS__\n\n#include <string.h> // for strerror()\n\n#include <be/kernel/image.h>\n#include <be/support/Errors.h>\n\n#define DYNAMICLOADER_DEFINED 1\n\nnamespace KWSYS_NAMESPACE\n{\n\nstatic image_id last_dynamic_err = B_OK;\n\n//----------------------------------------------------------------------------\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(const char* libname )\n{\n  // image_id's are integers, errors are negative. Add one just in case we\n  //  get a valid image_id of zero (is that even possible?).\n  image_id rc = load_add_on(libname);\n  if (rc < 0)\n    {\n    last_dynamic_err = rc;\n    return 0;\n    }\n\n  return rc+1;\n}\n\n//----------------------------------------------------------------------------\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  if (!lib)\n    {\n      last_dynamic_err = B_BAD_VALUE;\n      return 0;\n    }\n  else\n    {\n    // The function dlclose() returns 0 on success, and non-zero on error.\n    status_t rc = unload_add_on(lib-1);\n    if (rc != B_OK)\n      {\n      last_dynamic_err = rc;\n      return 0;\n      }\n    }\n\n  return 1;\n}\n\n//----------------------------------------------------------------------------\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const char* sym)\n{\n  // Hack to cast pointer-to-data to pointer-to-function.\n  union \n  {\n    void* pvoid;\n    DynamicLoader::SymbolPointer psym;\n  } result;\n\n  result.psym = NULL;\n\n  if (!lib)\n    {\n      last_dynamic_err = B_BAD_VALUE;\n    }\n  else\n    {\n    // !!! FIXME: BeOS can do function-only lookups...does this ever\n    // !!! FIXME:  actually _want_ a data symbol lookup, or was this union\n    // !!! FIXME:  a leftover of dlsym()? (s/ANY/TEXT for functions only).\n    status_t rc = get_image_symbol(lib-1,sym,B_SYMBOL_TYPE_ANY,&result.pvoid);\n    if (rc != B_OK)\n      {\n      last_dynamic_err = rc;\n      result.psym = NULL;\n      }\n    }\n  return result.psym;\n}\n\n//----------------------------------------------------------------------------\nconst char* DynamicLoader::LastError()\n{\n  const char *retval = strerror(last_dynamic_err);\n  last_dynamic_err = B_OK;\n  return retval;\n}\n\n} // namespace KWSYS_NAMESPACE\n#endif\n\n// ---------------------------------------------------------------\n// 5. Implementation for systems without dynamic libs\n// __gnu_blrts__ is IBM BlueGene/L\n// __LIBCATAMOUNT__ is defined on Catamount on Cray compute nodes\n#if defined(__gnu_blrts__) || defined(__LIBCATAMOUNT__) || defined(__CRAYXT_COMPUTE_LINUX_TARGET)\n#include <string.h> // for strerror()\n#define DYNAMICLOADER_DEFINED 1\n\nnamespace KWSYS_NAMESPACE\n{\n\n//----------------------------------------------------------------------------\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(const char* libname )\n{\n  return 0;\n}\n\n//----------------------------------------------------------------------------\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  if (!lib)\n    {\n    return 0;\n    }\n\n  return 1;\n}\n\n//----------------------------------------------------------------------------\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n    DynamicLoader::LibraryHandle lib, const char* sym)\n{\n  return 0;\n}\n\n//----------------------------------------------------------------------------\nconst char* DynamicLoader::LastError()\n  {\n  return \"General error\";\n  }\n\n} // namespace KWSYS_NAMESPACE\n#endif\n\n// ---------------------------------------------------------------\n// 6. Implementation for default UNIX machines.\n// if nothing has been defined then use this\n#ifndef DYNAMICLOADER_DEFINED\n#define DYNAMICLOADER_DEFINED 1\n// Setup for most unix machines\n#include <dlfcn.h>\n\nnamespace KWSYS_NAMESPACE\n{\n\n//----------------------------------------------------------------------------\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(const char* libname )\n{\n  return dlopen(libname, RTLD_LAZY);\n}\n\n//----------------------------------------------------------------------------\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  if (lib)\n    {\n    // The function dlclose() returns 0 on success, and non-zero on error.\n    return !dlclose(lib);\n    }\n  // else\n  return 0;\n}\n\n//----------------------------------------------------------------------------\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const char* sym)\n{\n  // Hack to cast pointer-to-data to pointer-to-function.\n  union \n  {\n    void* pvoid;\n    DynamicLoader::SymbolPointer psym;\n  } result;\n  result.pvoid = dlsym(lib, sym);\n  return result.psym;\n}\n\n//----------------------------------------------------------------------------\nconst char* DynamicLoader::LastError()\n{\n  return dlerror();\n}\n\n} // namespace KWSYS_NAMESPACE\n\n#endif\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/CMakeLogo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/ChangeLog.txt",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Templates/CMakeVSMacros2.vsmacros",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Templates/CMakeVSMacros1.vsmacros",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Tests/ExternalProject/gitrepo.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Tests/ExternalProject/Step1NoDir.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Tests/ExternalProject/Step1.zip",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Tests/ExternalProject/hgrepo.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Tests/ExternalProject/Step1.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Tests/ExternalProject/Step1NoDir.zip",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Tests/ExternalProject/Step1NoDir.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Tests/ExternalProject/svnrepo.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Tests/ExternalProject/cvsrepo.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Tests/ExternalProject/Step1.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Tests/CFBundleTest/Localized.rsrc",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Tests/CMakeTests/FileDownloadInput.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Tests/CMakeTests/ELF/elf64lsb.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Tests/CMakeTests/ELF/elf32lsb.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Tests/CMakeTests/ELF/elf32msb.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Tests/CMakeTests/ELF/elf64msb.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Tests/MFC/mfc1/res/Toolbar.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Tests/MFC/mfc1/res/mfc1Doc.ico",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Tests/MFC/mfc1/res/mfc1.ico",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Tests/BundleGeneratorTest/CustomVolumeIcon.icns",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Tests/BundleGeneratorTest/BundleIcon.icns",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Tests/ObjectLibrary/dummy.obj",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Utilities/cmbzip2/sample2.tst",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Utilities/cmbzip2/sample1.tst",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Utilities/cmbzip2/sample3.rb2",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Utilities/cmbzip2/libbz2.lib",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Utilities/cmbzip2/manual.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Utilities/cmbzip2/libbz2.dsp",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Utilities/cmbzip2/manual.html",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Utilities/cmbzip2/sample2.ref",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Utilities/cmbzip2/sample1.rb2",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Utilities/cmbzip2/sample1.ref",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Utilities/cmbzip2/sample2.rb2",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Utilities/cmbzip2/dlltest.dsp",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Utilities/cmcurl/krb4.c",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Utilities/cmcurl/security.c",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Utilities/cmcurl/cookie.c",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Utilities/Release/CMakeLogo.ico",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Utilities/Release/CMakeInstall.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Source/QtDialog/Plus16.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Source/QtDialog/Delete16.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Source/QtDialog/CMakeSetup128.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Source/QtDialog/CMakeSetup32.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Source/QtDialog/CMakeSetup.ico",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Source/QtDialog/CMakeSetup.icns",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Source/CPack/OSXLauncherScript.scpt",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Source/kwsys/testSystemTools.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Modules/CPack.OSXScriptLauncher.rsrc.in",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Modules/CPack.DS_Store.in",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Modules/CPack.background.png.in",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Modules/CPack.OSXX11.main.scpt.in",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Modules/CPack.OSXScriptLauncher.in",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-2.8.10.2-dyptflayilicknjitoa3um6ckhu3u3yz/spack-src/Modules/CPack.VolumeIcon.icns.in"
    ],
    "total_files": 3568
}