{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/Plugin/src/DynamicLoader.cxx": "/* Distributed under the OSI-approved BSD 3-Clause License.\n   See https://cmake.org/licensing#kwsys for details.  */\n#if defined(_WIN32)\n#  define NOMINMAX // hide min,max to not conflict with <limits>\n#endif\n\n#include <DynamicLoader.hxx>\n\n#if defined(__hpux)\n#  include <dl.h>\n\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(\n  const std::string& libname)\n{\n  return shl_load(libname.c_str(), BIND_DEFERRED | DYNAMIC_PATH, 0L);\n}\n\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  if (!lib) {\n    return 0;\n  }\n  return !shl_unload(lib);\n}\n\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const std::string& sym)\n{\n  void* addr;\n  int status;\n\n  /* TYPE_PROCEDURE Look for a function or procedure. (This used to be default)\n   * TYPE_DATA      Look for a symbol in the data segment (for example,\n   * variables).\n   * TYPE_UNDEFINED Look for any symbol.\n   */\n  status = shl_findsym(&lib, sym.c_str(), TYPE_UNDEFINED, &addr);\n  void* result = (status < 0) ? (void*)0 : addr;\n\n  // Hack to cast pointer-to-data to pointer-to-function.\n  return *reinterpret_cast<DynamicLoader::SymbolPointer*>(&result);\n}\n\n#elif defined(__APPLE__) && (MAC_OS_X_VERSION_MAX_ALLOWED < 1030)\n#  include <mach-o/dyld.h>\n\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(\n  const std::string& libname)\n{\n  NSObjectFileImageReturnCode rc;\n  NSObjectFileImage image = 0;\n\n  rc = NSCreateObjectFileImageFromFile(libname.c_str(), &image);\n  // rc == NSObjectFileImageInappropriateFile when trying to load a dylib file\n  if (rc != NSObjectFileImageSuccess) {\n    return 0;\n  }\n  NSModule handle = NSLinkModule(image, libname.c_str(),\n                                 NSLINKMODULE_OPTION_BINDNOW |\n                                   NSLINKMODULE_OPTION_RETURN_ON_ERROR);\n  NSDestroyObjectFileImage(image);\n  return handle;\n}\n\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  bool success = NSUnLinkModule(lib, NSUNLINKMODULE_OPTION_NONE);\n  return success;\n}\n\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const std::string& sym)\n{\n  void* result = 0;\n  // Need to prepend symbols with '_' on Apple-gcc compilers\n  std::string rsym = '_' + sym;\n\n  NSSymbol symbol = NSLookupSymbolInModule(lib, rsym.c_str());\n  if (symbol) {\n    result = NSAddressOfSymbol(symbol);\n  }\n\n  // Hack to cast pointer-to-data to pointer-to-function.\n  return *reinterpret_cast<DynamicLoader::SymbolPointer*>(&result);\n}\n\n#elif defined(_WIN32) && !defined(__CYGWIN__)\n#  include <windows.h>\n\n#  include <stdio.h>\n\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(\n  const std::string& libname)\n{\n  DynamicLoader::LibraryHandle lh;\n  int length = MultiByteToWideChar(CP_UTF8, 0, libname.c_str(), -1, NULL, 0);\n  wchar_t* wchars = new wchar_t[length + 1];\n  wchars[0] = '\\0';\n  MultiByteToWideChar(CP_UTF8, 0, libname.c_str(), -1, wchars, length);\n  lh = LoadLibraryW(wchars);\n  delete[] wchars;\n  return lh;\n}\n\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  return (int)FreeLibrary(lib);\n}\n\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const std::string& sym)\n{\n  void* result;\n#  if defined(__BORLANDC__) || defined(__WATCOMC__)\n  // Need to prepend symbols with '_'\n  std::string ssym = '_' + sym;\n  const char* rsym = ssym.c_str();\n#  else\n  const char* rsym = sym.c_str();\n#  endif\n  result = (void*)GetProcAddress(lib, rsym);\n// Hack to cast pointer-to-data to pointer-to-function.\n#  ifdef __WATCOMC__\n  return *(DynamicLoader::SymbolPointer*)(&result);\n#  else\n  return *reinterpret_cast<DynamicLoader::SymbolPointer*>(&result);\n#  endif\n}\n\n#elif defined(__BEOS__)\n#  include <be/kernel/image.h>\n#  include <be/support/Errors.h>\n\nstatic image_id last_dynamic_err = B_OK;\n\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(\n  const std::string& libname)\n{\n  // image_id's are integers, errors are negative. Add one just in case we\n  //  get a valid image_id of zero (is that even possible?).\n  image_id rc = load_add_on(libname.c_str());\n  if (rc < 0) {\n    last_dynamic_err = rc;\n    return 0;\n  }\n\n  return rc + 1;\n}\n\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  if (!lib) {\n    last_dynamic_err = B_BAD_VALUE;\n    return 0;\n  } else {\n    // The function dlclose() returns 0 on success, and non-zero on error.\n    status_t rc = unload_add_on(lib - 1);\n    if (rc != B_OK) {\n      last_dynamic_err = rc;\n      return 0;\n    }\n  }\n\n  return 1;\n}\n\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const std::string& sym)\n{\n  // Hack to cast pointer-to-data to pointer-to-function.\n  union\n  {\n    void* pvoid;\n    DynamicLoader::SymbolPointer psym;\n  } result;\n\n  result.psym = NULL;\n\n  if (!lib) {\n    last_dynamic_err = B_BAD_VALUE;\n  } else {\n    // !!! FIXME: BeOS can do function-only lookups...does this ever\n    // !!! FIXME:  actually _want_ a data symbol lookup, or was this union\n    // !!! FIXME:  a leftover of dlsym()? (s/ANY/TEXT for functions only).\n    status_t rc =\n      get_image_symbol(lib - 1, sym.c_str(), B_SYMBOL_TYPE_ANY, &result.pvoid);\n    if (rc != B_OK) {\n      last_dynamic_err = rc;\n      result.psym = NULL;\n    }\n  }\n  return result.psym;\n}\n\n#elif defined(__MINT__)\n#  define _GNU_SOURCE /* for program_invocation_name */\n#  include <dld.h>\n#  include <errno.h>\n#  include <malloc.h>\n\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(\n  const std::string& libname)\n{\n  char* name = (char*)calloc(1, libname.size() + 1);\n  dld_init(program_invocation_name);\n  strncpy(name, libname.c_str(), libname.size());\n  dld_link(libname.c_str());\n  return (void*)name;\n}\n\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  dld_unlink_by_file((char*)lib, 0);\n  free(lib);\n  return 0;\n}\n\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const std::string& sym)\n{\n  // Hack to cast pointer-to-data to pointer-to-function.\n  union\n  {\n    void* pvoid;\n    DynamicLoader::SymbolPointer psym;\n  } result;\n  result.pvoid = dld_get_symbol(sym.c_str());\n  return result.psym;\n}\n\n#else\n#  include <dlfcn.h>\n\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(\n  const std::string& libname)\n{\n  return dlopen(libname.c_str(), RTLD_LAZY);\n}\n\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  if (lib) {\n    // The function dlclose() returns 0 on success, and non-zero on error.\n    return !dlclose(lib);\n  }\n  // else\n  return 0;\n}\n\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const std::string& sym)\n{\n  // Hack to cast pointer-to-data to pointer-to-function.\n  union\n  {\n    void* pvoid;\n    DynamicLoader::SymbolPointer psym;\n  } result;\n  result.pvoid = dlsym(lib, sym.c_str());\n  return result.psym;\n}\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Utilities/cmlibuv/src/win/dl.c": "/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#include \"uv.h\"\n#include \"internal.h\"\n\nstatic int uv__dlerror(uv_lib_t* lib, const char* filename, DWORD errorno);\n\n\nint uv_dlopen(const char* filename, uv_lib_t* lib) {\n  WCHAR filename_w[32768];\n\n  lib->handle = NULL;\n  lib->errmsg = NULL;\n\n  if (!MultiByteToWideChar(CP_UTF8,\n                           0,\n                           filename,\n                           -1,\n                           filename_w,\n                           ARRAY_SIZE(filename_w))) {\n    return uv__dlerror(lib, filename, GetLastError());\n  }\n\n  lib->handle = LoadLibraryExW(filename_w, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);\n  if (lib->handle == NULL) {\n    return uv__dlerror(lib, filename, GetLastError());\n  }\n\n  return 0;\n}\n\n\nvoid uv_dlclose(uv_lib_t* lib) {\n  if (lib->errmsg) {\n    LocalFree((void*)lib->errmsg);\n    lib->errmsg = NULL;\n  }\n\n  if (lib->handle) {\n    /* Ignore errors. No good way to signal them without leaking memory. */\n    FreeLibrary(lib->handle);\n    lib->handle = NULL;\n  }\n}\n\n\nint uv_dlsym(uv_lib_t* lib, const char* name, void** ptr) {\n  /* Cast though integer to suppress pedantic warning about forbidden cast. */\n  *ptr = (void*)(uintptr_t) GetProcAddress(lib->handle, name);\n  return uv__dlerror(lib, \"\", *ptr ? 0 : GetLastError());\n}\n\n\nconst char* uv_dlerror(const uv_lib_t* lib) {\n  return lib->errmsg ? lib->errmsg : \"no error\";\n}\n\n\nstatic void uv__format_fallback_error(uv_lib_t* lib, int errorno){\n  static const CHAR fallback_error[] = \"error: %1!d!\";\n  DWORD_PTR args[1];\n  args[0] = (DWORD_PTR) errorno;\n\n  FormatMessageA(FORMAT_MESSAGE_FROM_STRING |\n                 FORMAT_MESSAGE_ARGUMENT_ARRAY |\n                 FORMAT_MESSAGE_ALLOCATE_BUFFER,\n                 fallback_error, 0, 0,\n                 (LPSTR) &lib->errmsg,\n                 0, (va_list*) args);\n}\n\n\n\nstatic int uv__dlerror(uv_lib_t* lib, const char* filename, DWORD errorno) {\n  DWORD_PTR arg;\n  DWORD res;\n  char* msg;\n\n  if (lib->errmsg) {\n    LocalFree(lib->errmsg);\n    lib->errmsg = NULL;\n  }\n\n  if (errorno == 0)\n    return 0;\n\n  res = FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER |\n                       FORMAT_MESSAGE_FROM_SYSTEM |\n                       FORMAT_MESSAGE_IGNORE_INSERTS, NULL, errorno,\n                       MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),\n                       (LPSTR) &lib->errmsg, 0, NULL);\n\n  if (!res && (GetLastError() == ERROR_MUI_FILE_NOT_FOUND ||\n               GetLastError() == ERROR_RESOURCE_TYPE_NOT_FOUND)) {\n    res = FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER |\n                         FORMAT_MESSAGE_FROM_SYSTEM |\n                         FORMAT_MESSAGE_IGNORE_INSERTS, NULL, errorno,\n                         0, (LPSTR) &lib->errmsg, 0, NULL);\n  }\n\n  if (res && errorno == ERROR_BAD_EXE_FORMAT && strstr(lib->errmsg, \"%1\")) {\n    msg = lib->errmsg;\n    lib->errmsg = NULL;\n    arg = (DWORD_PTR) filename;\n    res = FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER |\n                         FORMAT_MESSAGE_ARGUMENT_ARRAY |\n                         FORMAT_MESSAGE_FROM_STRING,\n                         msg,\n                         0, 0, (LPSTR) &lib->errmsg, 0, (va_list*) &arg);\n    LocalFree(msg);\n  }\n\n  if (!res)\n    uv__format_fallback_error(lib, errorno);\n\n  return -1;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Utilities/cmlibuv/src/unix/darwin-proctitle.c": "/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#include \"uv.h\"\n#include \"internal.h\"\n\n#include <dlfcn.h>\n#include <errno.h>\n#include <pthread.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <TargetConditionals.h>\n\n#if !TARGET_OS_IPHONE\n#include \"darwin-stub.h\"\n#endif\n\n\nstatic int uv__pthread_setname_np(const char* name) {\n  char namebuf[64];  /* MAXTHREADNAMESIZE */\n  int err;\n\n  strncpy(namebuf, name, sizeof(namebuf) - 1);\n  namebuf[sizeof(namebuf) - 1] = '\\0';\n\n  err = pthread_setname_np(namebuf);\n  if (err)\n    return UV__ERR(err);\n\n  return 0;\n}\n\n\nint uv__set_process_title(const char* title) {\n#if TARGET_OS_IPHONE\n  return uv__pthread_setname_np(title);\n#else\n  CFStringRef (*pCFStringCreateWithCString)(CFAllocatorRef,\n                                            const char*,\n                                            CFStringEncoding);\n  CFBundleRef (*pCFBundleGetBundleWithIdentifier)(CFStringRef);\n  void *(*pCFBundleGetDataPointerForName)(CFBundleRef, CFStringRef);\n  void *(*pCFBundleGetFunctionPointerForName)(CFBundleRef, CFStringRef);\n  CFTypeRef (*pLSGetCurrentApplicationASN)(void);\n  OSStatus (*pLSSetApplicationInformationItem)(int,\n                                               CFTypeRef,\n                                               CFStringRef,\n                                               CFStringRef,\n                                               CFDictionaryRef*);\n  void* application_services_handle;\n  void* core_foundation_handle;\n  CFBundleRef launch_services_bundle;\n  CFStringRef* display_name_key;\n  CFDictionaryRef (*pCFBundleGetInfoDictionary)(CFBundleRef);\n  CFBundleRef (*pCFBundleGetMainBundle)(void);\n  CFDictionaryRef (*pLSApplicationCheckIn)(int, CFDictionaryRef);\n  void (*pLSSetApplicationLaunchServicesServerConnectionStatus)(uint64_t,\n                                                                void*);\n  CFTypeRef asn;\n  int err;\n\n  err = UV_ENOENT;\n  application_services_handle = dlopen(\"/System/Library/Frameworks/\"\n                                       \"ApplicationServices.framework/\"\n                                       \"Versions/A/ApplicationServices\",\n                                       RTLD_LAZY | RTLD_LOCAL);\n  core_foundation_handle = dlopen(\"/System/Library/Frameworks/\"\n                                  \"CoreFoundation.framework/\"\n                                  \"Versions/A/CoreFoundation\",\n                                  RTLD_LAZY | RTLD_LOCAL);\n\n  if (application_services_handle == NULL || core_foundation_handle == NULL)\n    goto out;\n\n  *(void **)(&pCFStringCreateWithCString) =\n      dlsym(core_foundation_handle, \"CFStringCreateWithCString\");\n  *(void **)(&pCFBundleGetBundleWithIdentifier) =\n      dlsym(core_foundation_handle, \"CFBundleGetBundleWithIdentifier\");\n  *(void **)(&pCFBundleGetDataPointerForName) =\n      dlsym(core_foundation_handle, \"CFBundleGetDataPointerForName\");\n  *(void **)(&pCFBundleGetFunctionPointerForName) =\n      dlsym(core_foundation_handle, \"CFBundleGetFunctionPointerForName\");\n\n  if (pCFStringCreateWithCString == NULL ||\n      pCFBundleGetBundleWithIdentifier == NULL ||\n      pCFBundleGetDataPointerForName == NULL ||\n      pCFBundleGetFunctionPointerForName == NULL) {\n    goto out;\n  }\n\n#define S(s) pCFStringCreateWithCString(NULL, (s), kCFStringEncodingUTF8)\n\n  launch_services_bundle =\n      pCFBundleGetBundleWithIdentifier(S(\"com.apple.LaunchServices\"));\n\n  if (launch_services_bundle == NULL)\n    goto out;\n\n  *(void **)(&pLSGetCurrentApplicationASN) =\n      pCFBundleGetFunctionPointerForName(launch_services_bundle,\n                                         S(\"_LSGetCurrentApplicationASN\"));\n\n  if (pLSGetCurrentApplicationASN == NULL)\n    goto out;\n\n  *(void **)(&pLSSetApplicationInformationItem) =\n      pCFBundleGetFunctionPointerForName(launch_services_bundle,\n                                         S(\"_LSSetApplicationInformationItem\"));\n\n  if (pLSSetApplicationInformationItem == NULL)\n    goto out;\n\n  display_name_key = pCFBundleGetDataPointerForName(launch_services_bundle,\n                                                    S(\"_kLSDisplayNameKey\"));\n\n  if (display_name_key == NULL || *display_name_key == NULL)\n    goto out;\n\n  *(void **)(&pCFBundleGetInfoDictionary) = dlsym(core_foundation_handle,\n                                     \"CFBundleGetInfoDictionary\");\n  *(void **)(&pCFBundleGetMainBundle) = dlsym(core_foundation_handle,\n                                 \"CFBundleGetMainBundle\");\n  if (pCFBundleGetInfoDictionary == NULL || pCFBundleGetMainBundle == NULL)\n    goto out;\n\n  *(void **)(&pLSApplicationCheckIn) = pCFBundleGetFunctionPointerForName(\n      launch_services_bundle,\n      S(\"_LSApplicationCheckIn\"));\n\n  if (pLSApplicationCheckIn == NULL)\n    goto out;\n\n  *(void **)(&pLSSetApplicationLaunchServicesServerConnectionStatus) =\n      pCFBundleGetFunctionPointerForName(\n          launch_services_bundle,\n          S(\"_LSSetApplicationLaunchServicesServerConnectionStatus\"));\n\n  if (pLSSetApplicationLaunchServicesServerConnectionStatus == NULL)\n    goto out;\n\n  pLSSetApplicationLaunchServicesServerConnectionStatus(0, NULL);\n\n  /* Check into process manager?! */\n  pLSApplicationCheckIn(-2,\n                        pCFBundleGetInfoDictionary(pCFBundleGetMainBundle()));\n\n  asn = pLSGetCurrentApplicationASN();\n\n  err = UV_EBUSY;\n  if (asn == NULL)\n    goto out;\n\n  err = UV_EINVAL;\n  if (pLSSetApplicationInformationItem(-2,  /* Magic value. */\n                                       asn,\n                                       *display_name_key,\n                                       S(title),\n                                       NULL) != noErr) {\n    goto out;\n  }\n\n  uv__pthread_setname_np(title);  /* Don't care if it fails. */\n  err = 0;\n\nout:\n  if (core_foundation_handle != NULL)\n    dlclose(core_foundation_handle);\n\n  if (application_services_handle != NULL)\n    dlclose(application_services_handle);\n\n  return err;\n#endif  /* !TARGET_OS_IPHONE */\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Utilities/cmlibuv/src/unix/fsevents.c": "/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#include \"uv.h\"\n#include \"internal.h\"\n\n#if TARGET_OS_IPHONE || MAC_OS_X_VERSION_MAX_ALLOWED < 1070\n\n/* iOS (currently) doesn't provide the FSEvents-API (nor CoreServices) */\n/* macOS prior to 10.7 doesn't provide the full FSEvents API so use kqueue */\n\nint uv__fsevents_init(uv_fs_event_t* handle) {\n  return 0;\n}\n\n\nint uv__fsevents_close(uv_fs_event_t* handle) {\n  return 0;\n}\n\n\nvoid uv__fsevents_loop_delete(uv_loop_t* loop) {\n}\n\n#else /* TARGET_OS_IPHONE */\n\n#include \"darwin-stub.h\"\n\n#include <dlfcn.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <pthread.h>\n\nstatic const int kFSEventsModified =\n    kFSEventStreamEventFlagItemChangeOwner |\n    kFSEventStreamEventFlagItemFinderInfoMod |\n    kFSEventStreamEventFlagItemInodeMetaMod |\n    kFSEventStreamEventFlagItemModified |\n    kFSEventStreamEventFlagItemXattrMod;\n\nstatic const int kFSEventsRenamed =\n    kFSEventStreamEventFlagItemCreated |\n    kFSEventStreamEventFlagItemRemoved |\n    kFSEventStreamEventFlagItemRenamed;\n\nstatic const int kFSEventsSystem =\n    kFSEventStreamEventFlagUserDropped |\n    kFSEventStreamEventFlagKernelDropped |\n    kFSEventStreamEventFlagEventIdsWrapped |\n    kFSEventStreamEventFlagHistoryDone |\n    kFSEventStreamEventFlagMount |\n    kFSEventStreamEventFlagUnmount |\n    kFSEventStreamEventFlagRootChanged;\n\ntypedef struct uv__fsevents_event_s uv__fsevents_event_t;\ntypedef struct uv__cf_loop_signal_s uv__cf_loop_signal_t;\ntypedef struct uv__cf_loop_state_s uv__cf_loop_state_t;\n\nenum uv__cf_loop_signal_type_e {\n  kUVCFLoopSignalRegular,\n  kUVCFLoopSignalClosing\n};\ntypedef enum uv__cf_loop_signal_type_e uv__cf_loop_signal_type_t;\n\nstruct uv__cf_loop_signal_s {\n  QUEUE member;\n  uv_fs_event_t* handle;\n  uv__cf_loop_signal_type_t type;\n};\n\nstruct uv__fsevents_event_s {\n  QUEUE member;\n  int events;\n  char path[1];\n};\n\nstruct uv__cf_loop_state_s {\n  CFRunLoopRef loop;\n  CFRunLoopSourceRef signal_source;\n  int fsevent_need_reschedule;\n  FSEventStreamRef fsevent_stream;\n  uv_sem_t fsevent_sem;\n  uv_mutex_t fsevent_mutex;\n  void* fsevent_handles[2];\n  unsigned int fsevent_handle_count;\n};\n\n/* Forward declarations */\nstatic void uv__cf_loop_cb(void* arg);\nstatic void* uv__cf_loop_runner(void* arg);\nstatic int uv__cf_loop_signal(uv_loop_t* loop,\n                              uv_fs_event_t* handle,\n                              uv__cf_loop_signal_type_t type);\n\n/* Lazy-loaded by uv__fsevents_global_init(). */\nstatic CFArrayRef (*pCFArrayCreate)(CFAllocatorRef,\n                                    const void**,\n                                    CFIndex,\n                                    const CFArrayCallBacks*);\nstatic void (*pCFRelease)(CFTypeRef);\nstatic void (*pCFRunLoopAddSource)(CFRunLoopRef,\n                                   CFRunLoopSourceRef,\n                                   CFStringRef);\nstatic CFRunLoopRef (*pCFRunLoopGetCurrent)(void);\nstatic void (*pCFRunLoopRemoveSource)(CFRunLoopRef,\n                                      CFRunLoopSourceRef,\n                                      CFStringRef);\nstatic void (*pCFRunLoopRun)(void);\nstatic CFRunLoopSourceRef (*pCFRunLoopSourceCreate)(CFAllocatorRef,\n                                                    CFIndex,\n                                                    CFRunLoopSourceContext*);\nstatic void (*pCFRunLoopSourceSignal)(CFRunLoopSourceRef);\nstatic void (*pCFRunLoopStop)(CFRunLoopRef);\nstatic void (*pCFRunLoopWakeUp)(CFRunLoopRef);\nstatic CFStringRef (*pCFStringCreateWithFileSystemRepresentation)(\n    CFAllocatorRef,\n    const char*);\nstatic CFStringEncoding (*pCFStringGetSystemEncoding)(void);\nstatic CFStringRef (*pkCFRunLoopDefaultMode);\nstatic FSEventStreamRef (*pFSEventStreamCreate)(CFAllocatorRef,\n                                                FSEventStreamCallback,\n                                                FSEventStreamContext*,\n                                                CFArrayRef,\n                                                FSEventStreamEventId,\n                                                CFTimeInterval,\n                                                FSEventStreamCreateFlags);\nstatic void (*pFSEventStreamFlushSync)(FSEventStreamRef);\nstatic void (*pFSEventStreamInvalidate)(FSEventStreamRef);\nstatic void (*pFSEventStreamRelease)(FSEventStreamRef);\nstatic void (*pFSEventStreamScheduleWithRunLoop)(FSEventStreamRef,\n                                                 CFRunLoopRef,\n                                                 CFStringRef);\nstatic int (*pFSEventStreamStart)(FSEventStreamRef);\nstatic void (*pFSEventStreamStop)(FSEventStreamRef);\n\n#define UV__FSEVENTS_PROCESS(handle, block)                                   \\\n    do {                                                                      \\\n      QUEUE events;                                                           \\\n      QUEUE* q;                                                               \\\n      uv__fsevents_event_t* event;                                            \\\n      int err;                                                                \\\n      uv_mutex_lock(&(handle)->cf_mutex);                                     \\\n      /* Split-off all events and empty original queue */                     \\\n      QUEUE_MOVE(&(handle)->cf_events, &events);                              \\\n      /* Get error (if any) and zero original one */                          \\\n      err = (handle)->cf_error;                                               \\\n      (handle)->cf_error = 0;                                                 \\\n      uv_mutex_unlock(&(handle)->cf_mutex);                                   \\\n      /* Loop through events, deallocating each after processing */           \\\n      while (!QUEUE_EMPTY(&events)) {                                         \\\n        q = QUEUE_HEAD(&events);                                              \\\n        event = QUEUE_DATA(q, uv__fsevents_event_t, member);                  \\\n        QUEUE_REMOVE(q);                                                      \\\n        /* NOTE: Checking uv__is_active() is required here, because handle    \\\n         * callback may close handle and invoking it after it will lead to    \\\n         * incorrect behaviour */                                             \\\n        if (!uv__is_closing((handle)) && uv__is_active((handle)))             \\\n          block                                                               \\\n        /* Free allocated data */                                             \\\n        uv__free(event);                                                      \\\n      }                                                                       \\\n      if (err != 0 && !uv__is_closing((handle)) && uv__is_active((handle)))   \\\n        (handle)->cb((handle), NULL, 0, err);                                 \\\n    } while (0)\n\n\n/* Runs in UV loop's thread, when there're events to report to handle */\nstatic void uv__fsevents_cb(uv_async_t* cb) {\n  uv_fs_event_t* handle;\n\n  handle = cb->data;\n\n  UV__FSEVENTS_PROCESS(handle, {\n    handle->cb(handle, event->path[0] ? event->path : NULL, event->events, 0);\n  });\n}\n\n\n/* Runs in CF thread, pushed event into handle's event list */\nstatic void uv__fsevents_push_event(uv_fs_event_t* handle,\n                                    QUEUE* events,\n                                    int err) {\n  assert(events != NULL || err != 0);\n  uv_mutex_lock(&handle->cf_mutex);\n\n  /* Concatenate two queues */\n  if (events != NULL)\n    QUEUE_ADD(&handle->cf_events, events);\n\n  /* Propagate error */\n  if (err != 0)\n    handle->cf_error = err;\n  uv_mutex_unlock(&handle->cf_mutex);\n\n  uv_async_send(handle->cf_cb);\n}\n\n\n/* Runs in CF thread, when there're events in FSEventStream */\nstatic void uv__fsevents_event_cb(const FSEventStreamRef streamRef,\n                                  void* info,\n                                  size_t numEvents,\n                                  void* eventPaths,\n                                  const FSEventStreamEventFlags eventFlags[],\n                                  const FSEventStreamEventId eventIds[]) {\n  size_t i;\n  int len;\n  char** paths;\n  char* path;\n  char* pos;\n  uv_fs_event_t* handle;\n  QUEUE* q;\n  uv_loop_t* loop;\n  uv__cf_loop_state_t* state;\n  uv__fsevents_event_t* event;\n  FSEventStreamEventFlags flags;\n  QUEUE head;\n\n  loop = info;\n  state = loop->cf_state;\n  assert(state != NULL);\n  paths = eventPaths;\n\n  /* For each handle */\n  uv_mutex_lock(&state->fsevent_mutex);\n  QUEUE_FOREACH(q, &state->fsevent_handles) {\n    handle = QUEUE_DATA(q, uv_fs_event_t, cf_member);\n    QUEUE_INIT(&head);\n\n    /* Process and filter out events */\n    for (i = 0; i < numEvents; i++) {\n      flags = eventFlags[i];\n\n      /* Ignore system events */\n      if (flags & kFSEventsSystem)\n        continue;\n\n      path = paths[i];\n      len = strlen(path);\n\n      if (handle->realpath_len == 0)\n        continue; /* This should be unreachable */\n\n      /* Filter out paths that are outside handle's request */\n      if (len < handle->realpath_len)\n        continue;\n\n      /* Make sure that realpath actually named a directory,\n       * (unless watching root, which alone keeps a trailing slash on the realpath)\n       * or that we matched the whole string */\n      if (handle->realpath_len != len &&\n          handle->realpath_len > 1 &&\n          path[handle->realpath_len] != '/')\n        continue;\n\n      if (memcmp(path, handle->realpath, handle->realpath_len) != 0)\n        continue;\n\n      if (!(handle->realpath_len == 1 && handle->realpath[0] == '/')) {\n        /* Remove common prefix, unless the watched folder is \"/\" */\n        path += handle->realpath_len;\n        len -= handle->realpath_len;\n\n        /* Ignore events with path equal to directory itself */\n        if (len <= 1 && (flags & kFSEventStreamEventFlagItemIsDir))\n          continue;\n\n        if (len == 0) {\n          /* Since we're using fsevents to watch the file itself,\n           * realpath == path, and we now need to get the basename of the file back\n           * (for commonality with other codepaths and platforms). */\n          while (len < handle->realpath_len && path[-1] != '/') {\n            path--;\n            len++;\n          }\n          /* Created and Removed seem to be always set, but don't make sense */\n          flags &= ~kFSEventsRenamed;\n        } else {\n          /* Skip forward slash */\n          path++;\n          len--;\n        }\n      }\n\n      /* Do not emit events from subdirectories (without option set) */\n      if ((handle->cf_flags & UV_FS_EVENT_RECURSIVE) == 0 && *path != '\\0') {\n        pos = strchr(path + 1, '/');\n        if (pos != NULL)\n          continue;\n      }\n\n      event = uv__malloc(sizeof(*event) + len);\n      if (event == NULL)\n        break;\n\n      memset(event, 0, sizeof(*event));\n      memcpy(event->path, path, len + 1);\n      event->events = UV_RENAME;\n\n      if (0 == (flags & kFSEventsRenamed)) {\n        if (0 != (flags & kFSEventsModified) ||\n            0 == (flags & kFSEventStreamEventFlagItemIsDir))\n          event->events = UV_CHANGE;\n      }\n\n      QUEUE_INSERT_TAIL(&head, &event->member);\n    }\n\n    if (!QUEUE_EMPTY(&head))\n      uv__fsevents_push_event(handle, &head, 0);\n  }\n  uv_mutex_unlock(&state->fsevent_mutex);\n}\n\n\n/* Runs in CF thread */\nstatic int uv__fsevents_create_stream(uv_loop_t* loop, CFArrayRef paths) {\n  uv__cf_loop_state_t* state;\n  FSEventStreamContext ctx;\n  FSEventStreamRef ref;\n  CFAbsoluteTime latency;\n  FSEventStreamCreateFlags flags;\n\n  /* Initialize context */\n  memset(&ctx, 0, sizeof(ctx));\n  ctx.info = loop;\n\n  latency = 0.05;\n\n  /* Explanation of selected flags:\n   * 1. NoDefer - without this flag, events that are happening continuously\n   *    (i.e. each event is happening after time interval less than `latency`,\n   *    counted from previous event), will be deferred and passed to callback\n   *    once they'll either fill whole OS buffer, or when this continuous stream\n   *    will stop (i.e. there'll be delay between events, bigger than\n   *    `latency`).\n   *    Specifying this flag will invoke callback after `latency` time passed\n   *    since event.\n   * 2. FileEvents - fire callback for file changes too (by default it is firing\n   *    it only for directory changes).\n   */\n  flags = kFSEventStreamCreateFlagNoDefer | kFSEventStreamCreateFlagFileEvents;\n\n  /*\n   * NOTE: It might sound like a good idea to remember last seen StreamEventId,\n   * but in reality one dir might have last StreamEventId less than, the other,\n   * that is being watched now. Which will cause FSEventStream API to report\n   * changes to files from the past.\n   */\n  ref = pFSEventStreamCreate(NULL,\n                             &uv__fsevents_event_cb,\n                             &ctx,\n                             paths,\n                             kFSEventStreamEventIdSinceNow,\n                             latency,\n                             flags);\n  assert(ref != NULL);\n\n  state = loop->cf_state;\n  pFSEventStreamScheduleWithRunLoop(ref,\n                                    state->loop,\n                                    *pkCFRunLoopDefaultMode);\n  if (!pFSEventStreamStart(ref)) {\n    pFSEventStreamInvalidate(ref);\n    pFSEventStreamRelease(ref);\n    return UV_EMFILE;\n  }\n\n  state->fsevent_stream = ref;\n  return 0;\n}\n\n\n/* Runs in CF thread */\nstatic void uv__fsevents_destroy_stream(uv_loop_t* loop) {\n  uv__cf_loop_state_t* state;\n\n  state = loop->cf_state;\n\n  if (state->fsevent_stream == NULL)\n    return;\n\n  /* Stop emitting events */\n  pFSEventStreamStop(state->fsevent_stream);\n\n  /* Release stream */\n  pFSEventStreamInvalidate(state->fsevent_stream);\n  pFSEventStreamRelease(state->fsevent_stream);\n  state->fsevent_stream = NULL;\n}\n\n\n/* Runs in CF thread, when there're new fsevent handles to add to stream */\nstatic void uv__fsevents_reschedule(uv_fs_event_t* handle,\n                                    uv__cf_loop_signal_type_t type) {\n  uv__cf_loop_state_t* state;\n  QUEUE* q;\n  uv_fs_event_t* curr;\n  CFArrayRef cf_paths;\n  CFStringRef* paths;\n  unsigned int i;\n  int err;\n  unsigned int path_count;\n\n  state = handle->loop->cf_state;\n  paths = NULL;\n  cf_paths = NULL;\n  err = 0;\n  /* NOTE: `i` is used in deallocation loop below */\n  i = 0;\n\n  /* Optimization to prevent O(n^2) time spent when starting to watch\n   * many files simultaneously\n   */\n  uv_mutex_lock(&state->fsevent_mutex);\n  if (state->fsevent_need_reschedule == 0) {\n    uv_mutex_unlock(&state->fsevent_mutex);\n    goto final;\n  }\n  state->fsevent_need_reschedule = 0;\n  uv_mutex_unlock(&state->fsevent_mutex);\n\n  /* Destroy previous FSEventStream */\n  uv__fsevents_destroy_stream(handle->loop);\n\n  /* Any failure below will be a memory failure */\n  err = UV_ENOMEM;\n\n  /* Create list of all watched paths */\n  uv_mutex_lock(&state->fsevent_mutex);\n  path_count = state->fsevent_handle_count;\n  if (path_count != 0) {\n    paths = uv__malloc(sizeof(*paths) * path_count);\n    if (paths == NULL) {\n      uv_mutex_unlock(&state->fsevent_mutex);\n      goto final;\n    }\n\n    q = &state->fsevent_handles;\n    for (; i < path_count; i++) {\n      q = QUEUE_NEXT(q);\n      assert(q != &state->fsevent_handles);\n      curr = QUEUE_DATA(q, uv_fs_event_t, cf_member);\n\n      assert(curr->realpath != NULL);\n      paths[i] =\n          pCFStringCreateWithFileSystemRepresentation(NULL, curr->realpath);\n      if (paths[i] == NULL) {\n        uv_mutex_unlock(&state->fsevent_mutex);\n        goto final;\n      }\n    }\n  }\n  uv_mutex_unlock(&state->fsevent_mutex);\n  err = 0;\n\n  if (path_count != 0) {\n    /* Create new FSEventStream */\n    cf_paths = pCFArrayCreate(NULL, (const void**) paths, path_count, NULL);\n    if (cf_paths == NULL) {\n      err = UV_ENOMEM;\n      goto final;\n    }\n    err = uv__fsevents_create_stream(handle->loop, cf_paths);\n  }\n\nfinal:\n  /* Deallocate all paths in case of failure */\n  if (err != 0) {\n    if (cf_paths == NULL) {\n      while (i != 0)\n        pCFRelease(paths[--i]);\n      uv__free(paths);\n    } else {\n      /* CFArray takes ownership of both strings and original C-array */\n      pCFRelease(cf_paths);\n    }\n\n    /* Broadcast error to all handles */\n    uv_mutex_lock(&state->fsevent_mutex);\n    QUEUE_FOREACH(q, &state->fsevent_handles) {\n      curr = QUEUE_DATA(q, uv_fs_event_t, cf_member);\n      uv__fsevents_push_event(curr, NULL, err);\n    }\n    uv_mutex_unlock(&state->fsevent_mutex);\n  }\n\n  /*\n   * Main thread will block until the removal of handle from the list,\n   * we must tell it when we're ready.\n   *\n   * NOTE: This is coupled with `uv_sem_wait()` in `uv__fsevents_close`\n   */\n  if (type == kUVCFLoopSignalClosing)\n    uv_sem_post(&state->fsevent_sem);\n}\n\n\nstatic int uv__fsevents_global_init(void) {\n  static pthread_mutex_t global_init_mutex = PTHREAD_MUTEX_INITIALIZER;\n  static void* core_foundation_handle;\n  static void* core_services_handle;\n  int err;\n\n  err = 0;\n  pthread_mutex_lock(&global_init_mutex);\n  if (core_foundation_handle != NULL)\n    goto out;\n\n  /* The libraries are never unloaded because we currently don't have a good\n   * mechanism for keeping a reference count. It's unlikely to be an issue\n   * but if it ever becomes one, we can turn the dynamic library handles into\n   * per-event loop properties and have the dynamic linker keep track for us.\n   */\n  err = UV_ENOSYS;\n  core_foundation_handle = dlopen(\"/System/Library/Frameworks/\"\n                                  \"CoreFoundation.framework/\"\n                                  \"Versions/A/CoreFoundation\",\n                                  RTLD_LAZY | RTLD_LOCAL);\n  if (core_foundation_handle == NULL)\n    goto out;\n\n  core_services_handle = dlopen(\"/System/Library/Frameworks/\"\n                                \"CoreServices.framework/\"\n                                \"Versions/A/CoreServices\",\n                                RTLD_LAZY | RTLD_LOCAL);\n  if (core_services_handle == NULL)\n    goto out;\n\n  err = UV_ENOENT;\n#define V(handle, symbol)                                                     \\\n  do {                                                                        \\\n    *(void **)(&p ## symbol) = dlsym((handle), #symbol);                      \\\n    if (p ## symbol == NULL)                                                  \\\n      goto out;                                                               \\\n  }                                                                           \\\n  while (0)\n  V(core_foundation_handle, CFArrayCreate);\n  V(core_foundation_handle, CFRelease);\n  V(core_foundation_handle, CFRunLoopAddSource);\n  V(core_foundation_handle, CFRunLoopGetCurrent);\n  V(core_foundation_handle, CFRunLoopRemoveSource);\n  V(core_foundation_handle, CFRunLoopRun);\n  V(core_foundation_handle, CFRunLoopSourceCreate);\n  V(core_foundation_handle, CFRunLoopSourceSignal);\n  V(core_foundation_handle, CFRunLoopStop);\n  V(core_foundation_handle, CFRunLoopWakeUp);\n  V(core_foundation_handle, CFStringCreateWithFileSystemRepresentation);\n  V(core_foundation_handle, CFStringGetSystemEncoding);\n  V(core_foundation_handle, kCFRunLoopDefaultMode);\n  V(core_services_handle, FSEventStreamCreate);\n  V(core_services_handle, FSEventStreamFlushSync);\n  V(core_services_handle, FSEventStreamInvalidate);\n  V(core_services_handle, FSEventStreamRelease);\n  V(core_services_handle, FSEventStreamScheduleWithRunLoop);\n  V(core_services_handle, FSEventStreamStart);\n  V(core_services_handle, FSEventStreamStop);\n#undef V\n  err = 0;\n\nout:\n  if (err && core_services_handle != NULL) {\n    dlclose(core_services_handle);\n    core_services_handle = NULL;\n  }\n\n  if (err && core_foundation_handle != NULL) {\n    dlclose(core_foundation_handle);\n    core_foundation_handle = NULL;\n  }\n\n  pthread_mutex_unlock(&global_init_mutex);\n  return err;\n}\n\n\n/* Runs in UV loop */\nstatic int uv__fsevents_loop_init(uv_loop_t* loop) {\n  CFRunLoopSourceContext ctx;\n  uv__cf_loop_state_t* state;\n  pthread_attr_t attr_storage;\n  pthread_attr_t* attr;\n  int err;\n\n  if (loop->cf_state != NULL)\n    return 0;\n\n  err = uv__fsevents_global_init();\n  if (err)\n    return err;\n\n  state = uv__calloc(1, sizeof(*state));\n  if (state == NULL)\n    return UV_ENOMEM;\n\n  err = uv_mutex_init(&loop->cf_mutex);\n  if (err)\n    goto fail_mutex_init;\n\n  err = uv_sem_init(&loop->cf_sem, 0);\n  if (err)\n    goto fail_sem_init;\n\n  QUEUE_INIT(&loop->cf_signals);\n\n  err = uv_sem_init(&state->fsevent_sem, 0);\n  if (err)\n    goto fail_fsevent_sem_init;\n\n  err = uv_mutex_init(&state->fsevent_mutex);\n  if (err)\n    goto fail_fsevent_mutex_init;\n\n  QUEUE_INIT(&state->fsevent_handles);\n  state->fsevent_need_reschedule = 0;\n  state->fsevent_handle_count = 0;\n\n  memset(&ctx, 0, sizeof(ctx));\n  ctx.info = loop;\n  ctx.perform = uv__cf_loop_cb;\n  state->signal_source = pCFRunLoopSourceCreate(NULL, 0, &ctx);\n  if (state->signal_source == NULL) {\n    err = UV_ENOMEM;\n    goto fail_signal_source_create;\n  }\n\n  /* In the unlikely event that pthread_attr_init() fails, create the thread\n   * with the default stack size. We'll use a little more address space but\n   * that in itself is not a fatal error.\n   */\n  attr = &attr_storage;\n  if (pthread_attr_init(attr))\n    attr = NULL;\n\n  if (attr != NULL)\n    if (pthread_attr_setstacksize(attr, 4 * PTHREAD_STACK_MIN))\n      abort();\n\n  loop->cf_state = state;\n\n  /* uv_thread_t is an alias for pthread_t. */\n  err = UV__ERR(pthread_create(&loop->cf_thread, attr, uv__cf_loop_runner, loop));\n\n  if (attr != NULL)\n    pthread_attr_destroy(attr);\n\n  if (err)\n    goto fail_thread_create;\n\n  /* Synchronize threads */\n  uv_sem_wait(&loop->cf_sem);\n  return 0;\n\nfail_thread_create:\n  loop->cf_state = NULL;\n\nfail_signal_source_create:\n  uv_mutex_destroy(&state->fsevent_mutex);\n\nfail_fsevent_mutex_init:\n  uv_sem_destroy(&state->fsevent_sem);\n\nfail_fsevent_sem_init:\n  uv_sem_destroy(&loop->cf_sem);\n\nfail_sem_init:\n  uv_mutex_destroy(&loop->cf_mutex);\n\nfail_mutex_init:\n  uv__free(state);\n  return err;\n}\n\n\n/* Runs in UV loop */\nvoid uv__fsevents_loop_delete(uv_loop_t* loop) {\n  uv__cf_loop_signal_t* s;\n  uv__cf_loop_state_t* state;\n  QUEUE* q;\n\n  if (loop->cf_state == NULL)\n    return;\n\n  if (uv__cf_loop_signal(loop, NULL, kUVCFLoopSignalRegular) != 0)\n    abort();\n\n  uv_thread_join(&loop->cf_thread);\n  uv_sem_destroy(&loop->cf_sem);\n  uv_mutex_destroy(&loop->cf_mutex);\n\n  /* Free any remaining data */\n  while (!QUEUE_EMPTY(&loop->cf_signals)) {\n    q = QUEUE_HEAD(&loop->cf_signals);\n    s = QUEUE_DATA(q, uv__cf_loop_signal_t, member);\n    QUEUE_REMOVE(q);\n    uv__free(s);\n  }\n\n  /* Destroy state */\n  state = loop->cf_state;\n  uv_sem_destroy(&state->fsevent_sem);\n  uv_mutex_destroy(&state->fsevent_mutex);\n  pCFRelease(state->signal_source);\n  uv__free(state);\n  loop->cf_state = NULL;\n}\n\n\n/* Runs in CF thread. This is the CF loop's body */\nstatic void* uv__cf_loop_runner(void* arg) {\n  uv_loop_t* loop;\n  uv__cf_loop_state_t* state;\n\n  loop = arg;\n  state = loop->cf_state;\n  state->loop = pCFRunLoopGetCurrent();\n\n  pCFRunLoopAddSource(state->loop,\n                      state->signal_source,\n                      *pkCFRunLoopDefaultMode);\n\n  uv_sem_post(&loop->cf_sem);\n\n  pCFRunLoopRun();\n  pCFRunLoopRemoveSource(state->loop,\n                         state->signal_source,\n                         *pkCFRunLoopDefaultMode);\n\n  state->loop = NULL;\n\n  return NULL;\n}\n\n\n/* Runs in CF thread, executed after `uv__cf_loop_signal()` */\nstatic void uv__cf_loop_cb(void* arg) {\n  uv_loop_t* loop;\n  uv__cf_loop_state_t* state;\n  QUEUE* item;\n  QUEUE split_head;\n  uv__cf_loop_signal_t* s;\n\n  loop = arg;\n  state = loop->cf_state;\n\n  uv_mutex_lock(&loop->cf_mutex);\n  QUEUE_MOVE(&loop->cf_signals, &split_head);\n  uv_mutex_unlock(&loop->cf_mutex);\n\n  while (!QUEUE_EMPTY(&split_head)) {\n    item = QUEUE_HEAD(&split_head);\n    QUEUE_REMOVE(item);\n\n    s = QUEUE_DATA(item, uv__cf_loop_signal_t, member);\n\n    /* This was a termination signal */\n    if (s->handle == NULL)\n      pCFRunLoopStop(state->loop);\n    else\n      uv__fsevents_reschedule(s->handle, s->type);\n\n    uv__free(s);\n  }\n}\n\n\n/* Runs in UV loop to notify CF thread */\nint uv__cf_loop_signal(uv_loop_t* loop,\n                       uv_fs_event_t* handle,\n                       uv__cf_loop_signal_type_t type) {\n  uv__cf_loop_signal_t* item;\n  uv__cf_loop_state_t* state;\n\n  item = uv__malloc(sizeof(*item));\n  if (item == NULL)\n    return UV_ENOMEM;\n\n  item->handle = handle;\n  item->type = type;\n\n  uv_mutex_lock(&loop->cf_mutex);\n  QUEUE_INSERT_TAIL(&loop->cf_signals, &item->member);\n\n  state = loop->cf_state;\n  assert(state != NULL);\n  pCFRunLoopSourceSignal(state->signal_source);\n  pCFRunLoopWakeUp(state->loop);\n\n  uv_mutex_unlock(&loop->cf_mutex);\n\n  return 0;\n}\n\n\n/* Runs in UV loop to initialize handle */\nint uv__fsevents_init(uv_fs_event_t* handle) {\n  int err;\n  uv__cf_loop_state_t* state;\n\n  err = uv__fsevents_loop_init(handle->loop);\n  if (err)\n    return err;\n\n  /* Get absolute path to file */\n  handle->realpath = realpath(handle->path, NULL);\n  if (handle->realpath == NULL)\n    return UV__ERR(errno);\n  handle->realpath_len = strlen(handle->realpath);\n\n  /* Initialize event queue */\n  QUEUE_INIT(&handle->cf_events);\n  handle->cf_error = 0;\n\n  /*\n   * Events will occur in other thread.\n   * Initialize callback for getting them back into event loop's thread\n   */\n  handle->cf_cb = uv__malloc(sizeof(*handle->cf_cb));\n  if (handle->cf_cb == NULL) {\n    err = UV_ENOMEM;\n    goto fail_cf_cb_malloc;\n  }\n\n  handle->cf_cb->data = handle;\n  uv_async_init(handle->loop, handle->cf_cb, uv__fsevents_cb);\n  handle->cf_cb->flags |= UV_HANDLE_INTERNAL;\n  uv_unref((uv_handle_t*) handle->cf_cb);\n\n  err = uv_mutex_init(&handle->cf_mutex);\n  if (err)\n    goto fail_cf_mutex_init;\n\n  /* Insert handle into the list */\n  state = handle->loop->cf_state;\n  uv_mutex_lock(&state->fsevent_mutex);\n  QUEUE_INSERT_TAIL(&state->fsevent_handles, &handle->cf_member);\n  state->fsevent_handle_count++;\n  state->fsevent_need_reschedule = 1;\n  uv_mutex_unlock(&state->fsevent_mutex);\n\n  /* Reschedule FSEventStream */\n  assert(handle != NULL);\n  err = uv__cf_loop_signal(handle->loop, handle, kUVCFLoopSignalRegular);\n  if (err)\n    goto fail_loop_signal;\n\n  return 0;\n\nfail_loop_signal:\n  uv_mutex_destroy(&handle->cf_mutex);\n\nfail_cf_mutex_init:\n  uv__free(handle->cf_cb);\n  handle->cf_cb = NULL;\n\nfail_cf_cb_malloc:\n  uv__free(handle->realpath);\n  handle->realpath = NULL;\n  handle->realpath_len = 0;\n\n  return err;\n}\n\n\n/* Runs in UV loop to de-initialize handle */\nint uv__fsevents_close(uv_fs_event_t* handle) {\n  int err;\n  uv__cf_loop_state_t* state;\n\n  if (handle->cf_cb == NULL)\n    return UV_EINVAL;\n\n  /* Remove handle from  the list */\n  state = handle->loop->cf_state;\n  uv_mutex_lock(&state->fsevent_mutex);\n  QUEUE_REMOVE(&handle->cf_member);\n  state->fsevent_handle_count--;\n  state->fsevent_need_reschedule = 1;\n  uv_mutex_unlock(&state->fsevent_mutex);\n\n  /* Reschedule FSEventStream */\n  assert(handle != NULL);\n  err = uv__cf_loop_signal(handle->loop, handle, kUVCFLoopSignalClosing);\n  if (err)\n    return UV__ERR(err);\n\n  /* Wait for deinitialization */\n  uv_sem_wait(&state->fsevent_sem);\n\n  uv_close((uv_handle_t*) handle->cf_cb, (uv_close_cb) uv__free);\n  handle->cf_cb = NULL;\n\n  /* Free data in queue */\n  UV__FSEVENTS_PROCESS(handle, {\n    /* NOP */\n  });\n\n  uv_mutex_destroy(&handle->cf_mutex);\n  uv__free(handle->realpath);\n  handle->realpath = NULL;\n  handle->realpath_len = 0;\n\n  return 0;\n}\n\n#endif /* TARGET_OS_IPHONE */\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Utilities/cmlibuv/src/unix/fs.c": "/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n/* Caveat emptor: this file deviates from the libuv convention of returning\n * negated errno codes. Most uv_fs_*() functions map directly to the system\n * call of the same name. For more complex wrappers, it's easier to just\n * return -1 with errno set. The dispatcher in uv__fs_work() takes care of\n * getting the errno to the right place (req->result or as the return value.)\n */\n\n#include \"uv.h\"\n#include \"internal.h\"\n\n#include <errno.h>\n#include <dlfcn.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <limits.h> /* PATH_MAX */\n\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/stat.h>\n#include <sys/time.h>\n#include <sys/uio.h>\n#include <pthread.h>\n#include <unistd.h>\n#include <fcntl.h>\n#include <poll.h>\n\n#if defined(__DragonFly__)        ||                                      \\\n    defined(__FreeBSD__)          ||                                      \\\n    defined(__FreeBSD_kernel__)   ||                                      \\\n    defined(__OpenBSD__)          ||                                      \\\n    defined(__NetBSD__)\n# define HAVE_PREADV 1\n#else\n# define HAVE_PREADV 0\n#endif\n\n#if defined(__linux__) || defined(__sun)\n# include <sys/sendfile.h>\n#endif\n\n#if defined(__APPLE__)\n# include <sys/sysctl.h>\n#elif defined(__linux__) && !defined(FICLONE)\n# include <sys/ioctl.h>\n# define FICLONE _IOW(0x94, 9, int)\n#endif\n\n#if defined(_AIX) && !defined(_AIX71)\n# include <utime.h>\n#endif\n\n#if defined(__APPLE__)            ||                                      \\\n    defined(__DragonFly__)        ||                                      \\\n    defined(__FreeBSD__)          ||                                      \\\n    defined(__FreeBSD_kernel__)   ||                                      \\\n    defined(__OpenBSD__)          ||                                      \\\n    defined(__NetBSD__)\n# include <sys/param.h>\n# include <sys/mount.h>\n#elif defined(__sun)      || \\\n      defined(__MVS__)    || \\\n      defined(__NetBSD__) || \\\n      defined(__HAIKU__)  || \\\n      defined(__QNX__)\n# include <sys/statvfs.h>\n#else\n# include <sys/statfs.h>\n#endif\n\n#if defined(_AIX) && _XOPEN_SOURCE <= 600\nextern char *mkdtemp(char *template); /* See issue #740 on AIX < 7 */\n#endif\n\n#define INIT(subtype)                                                         \\\n  do {                                                                        \\\n    if (req == NULL)                                                          \\\n      return UV_EINVAL;                                                       \\\n    UV_REQ_INIT(req, UV_FS);                                                  \\\n    req->fs_type = UV_FS_ ## subtype;                                         \\\n    req->result = 0;                                                          \\\n    req->ptr = NULL;                                                          \\\n    req->loop = loop;                                                         \\\n    req->path = NULL;                                                         \\\n    req->new_path = NULL;                                                     \\\n    req->bufs = NULL;                                                         \\\n    req->cb = cb;                                                             \\\n  }                                                                           \\\n  while (0)\n\n#define PATH                                                                  \\\n  do {                                                                        \\\n    assert(path != NULL);                                                     \\\n    if (cb == NULL) {                                                         \\\n      req->path = path;                                                       \\\n    } else {                                                                  \\\n      req->path = uv__strdup(path);                                           \\\n      if (req->path == NULL)                                                  \\\n        return UV_ENOMEM;                                                     \\\n    }                                                                         \\\n  }                                                                           \\\n  while (0)\n\n#define PATH2                                                                 \\\n  do {                                                                        \\\n    if (cb == NULL) {                                                         \\\n      req->path = path;                                                       \\\n      req->new_path = new_path;                                               \\\n    } else {                                                                  \\\n      size_t path_len;                                                        \\\n      size_t new_path_len;                                                    \\\n      path_len = strlen(path) + 1;                                            \\\n      new_path_len = strlen(new_path) + 1;                                    \\\n      req->path = uv__malloc(path_len + new_path_len);                        \\\n      if (req->path == NULL)                                                  \\\n        return UV_ENOMEM;                                                     \\\n      req->new_path = req->path + path_len;                                   \\\n      memcpy((void*) req->path, path, path_len);                              \\\n      memcpy((void*) req->new_path, new_path, new_path_len);                  \\\n    }                                                                         \\\n  }                                                                           \\\n  while (0)\n\n#define POST                                                                  \\\n  do {                                                                        \\\n    if (cb != NULL) {                                                         \\\n      uv__req_register(loop, req);                                            \\\n      uv__work_submit(loop,                                                   \\\n                      &req->work_req,                                         \\\n                      UV__WORK_FAST_IO,                                       \\\n                      uv__fs_work,                                            \\\n                      uv__fs_done);                                           \\\n      return 0;                                                               \\\n    }                                                                         \\\n    else {                                                                    \\\n      uv__fs_work(&req->work_req);                                            \\\n      return req->result;                                                     \\\n    }                                                                         \\\n  }                                                                           \\\n  while (0)\n\n\nstatic int uv__fs_close(int fd) {\n  int rc;\n\n  rc = uv__close_nocancel(fd);\n  if (rc == -1)\n    if (errno == EINTR || errno == EINPROGRESS)\n      rc = 0;  /* The close is in progress, not an error. */\n\n  return rc;\n}\n\n\nstatic ssize_t uv__fs_fsync(uv_fs_t* req) {\n#if defined(__APPLE__)\n  /* Apple's fdatasync and fsync explicitly do NOT flush the drive write cache\n   * to the drive platters. This is in contrast to Linux's fdatasync and fsync\n   * which do, according to recent man pages. F_FULLFSYNC is Apple's equivalent\n   * for flushing buffered data to permanent storage. If F_FULLFSYNC is not\n   * supported by the file system we fall back to F_BARRIERFSYNC or fsync().\n   * This is the same approach taken by sqlite, except sqlite does not issue\n   * an F_BARRIERFSYNC call.\n   */\n  int r;\n\n  r = fcntl(req->file, F_FULLFSYNC);\n  if (r != 0)\n    r = fcntl(req->file, 85 /* F_BARRIERFSYNC */);  /* fsync + barrier */\n  if (r != 0)\n    r = fsync(req->file);\n  return r;\n#else\n  return fsync(req->file);\n#endif\n}\n\n\nstatic ssize_t uv__fs_fdatasync(uv_fs_t* req) {\n#if defined(__linux__) || defined(__sun) || defined(__NetBSD__)\n  return fdatasync(req->file);\n#elif defined(__APPLE__)\n  /* See the comment in uv__fs_fsync. */\n  return uv__fs_fsync(req);\n#else\n  return fsync(req->file);\n#endif\n}\n\n\nUV_UNUSED(static struct timespec uv__fs_to_timespec(double time)) {\n  struct timespec ts;\n  ts.tv_sec  = time;\n  ts.tv_nsec = (uint64_t)(time * 1000000) % 1000000 * 1000;\n  return ts;\n}\n\nUV_UNUSED(static struct timeval uv__fs_to_timeval(double time)) {\n  struct timeval tv;\n  tv.tv_sec  = time;\n  tv.tv_usec = (uint64_t)(time * 1000000) % 1000000;\n  return tv;\n}\n\nstatic ssize_t uv__fs_futime(uv_fs_t* req) {\n#if defined(__linux__)                                                        \\\n    || defined(_AIX71)                                                        \\\n    || defined(__HAIKU__)\n  /* utimesat() has nanosecond resolution but we stick to microseconds\n   * for the sake of consistency with other platforms.\n   */\n  struct timespec ts[2];\n  ts[0] = uv__fs_to_timespec(req->atime);\n  ts[1] = uv__fs_to_timespec(req->mtime);\n  return futimens(req->file, ts);\n#elif defined(__APPLE__)                                                      \\\n    || defined(__DragonFly__)                                                 \\\n    || defined(__FreeBSD__)                                                   \\\n    || defined(__FreeBSD_kernel__)                                            \\\n    || defined(__NetBSD__)                                                    \\\n    || defined(__OpenBSD__)                                                   \\\n    || defined(__sun)\n  struct timeval tv[2];\n  tv[0] = uv__fs_to_timeval(req->atime);\n  tv[1] = uv__fs_to_timeval(req->mtime);\n# if defined(__sun)\n  return futimesat(req->file, NULL, tv);\n# else\n  return futimes(req->file, tv);\n# endif\n#elif defined(__MVS__)\n  attrib_t atr;\n  memset(&atr, 0, sizeof(atr));\n  atr.att_mtimechg = 1;\n  atr.att_atimechg = 1;\n  atr.att_mtime = req->mtime;\n  atr.att_atime = req->atime;\n  return __fchattr(req->file, &atr, sizeof(atr));\n#else\n  errno = ENOSYS;\n  return -1;\n#endif\n}\n\n#if (defined(__sun) || defined(__hpux)) && (_XOPEN_SOURCE < 600 || defined(CMAKE_BOOTSTRAP))\nstatic char* uv__mkdtemp(char *template)\n{\n  if (!mktemp(template) || mkdir(template, 0700))\n    return NULL;\n  return template;\n}\n#else\n#define uv__mkdtemp mkdtemp\n#endif\n\nstatic ssize_t uv__fs_mkdtemp(uv_fs_t* req) {\n  return uv__mkdtemp((char*) req->path) ? 0 : -1;\n}\n\n\nstatic int (*uv__mkostemp)(char*, int);\n\n\nstatic void uv__mkostemp_initonce(void) {\n  /* z/os doesn't have RTLD_DEFAULT but that's okay\n   * because it doesn't have mkostemp(O_CLOEXEC) either.\n   */\n#ifdef RTLD_DEFAULT\n  uv__mkostemp = (int (*)(char*, int)) dlsym(RTLD_DEFAULT, \"mkostemp\");\n\n  /* We don't care about errors, but we do want to clean them up.\n   * If there has been no error, then dlerror() will just return\n   * NULL.\n   */\n  dlerror();\n#endif  /* RTLD_DEFAULT */\n}\n\n\nstatic int uv__fs_mkstemp(uv_fs_t* req) {\n  static uv_once_t once = UV_ONCE_INIT;\n  int r;\n#ifdef O_CLOEXEC\n  static int no_cloexec_support;\n#endif\n  static const char pattern[] = \"XXXXXX\";\n  static const size_t pattern_size = sizeof(pattern) - 1;\n  char* path;\n  size_t path_length;\n\n  path = (char*) req->path;\n  path_length = strlen(path);\n\n  /* EINVAL can be returned for 2 reasons:\n      1. The template's last 6 characters were not XXXXXX\n      2. open() didn't support O_CLOEXEC\n     We want to avoid going to the fallback path in case\n     of 1, so it's manually checked before. */\n  if (path_length < pattern_size ||\n      strcmp(path + path_length - pattern_size, pattern)) {\n    errno = EINVAL;\n    r = -1;\n    goto clobber;\n  }\n\n  uv_once(&once, uv__mkostemp_initonce);\n\n#ifdef O_CLOEXEC\n  if (uv__load_relaxed(&no_cloexec_support) == 0 && uv__mkostemp != NULL) {\n    r = uv__mkostemp(path, O_CLOEXEC);\n\n    if (r >= 0)\n      return r;\n\n    /* If mkostemp() returns EINVAL, it means the kernel doesn't\n       support O_CLOEXEC, so we just fallback to mkstemp() below. */\n    if (errno != EINVAL)\n      goto clobber;\n\n    /* We set the static variable so that next calls don't even\n       try to use mkostemp. */\n    uv__store_relaxed(&no_cloexec_support, 1);\n  }\n#endif  /* O_CLOEXEC */\n\n  if (req->cb != NULL)\n    uv_rwlock_rdlock(&req->loop->cloexec_lock);\n\n  r = mkstemp(path);\n\n  /* In case of failure `uv__cloexec` will leave error in `errno`,\n   * so it is enough to just set `r` to `-1`.\n   */\n  if (r >= 0 && uv__cloexec(r, 1) != 0) {\n    r = uv__close(r);\n    if (r != 0)\n      abort();\n    r = -1;\n  }\n\n  if (req->cb != NULL)\n    uv_rwlock_rdunlock(&req->loop->cloexec_lock);\n\nclobber:\n  if (r < 0)\n    path[0] = '\\0';\n  return r;\n}\n\n\nstatic ssize_t uv__fs_open(uv_fs_t* req) {\n#ifdef O_CLOEXEC\n  return open(req->path, req->flags | O_CLOEXEC, req->mode);\n#else  /* O_CLOEXEC */\n  int r;\n\n  if (req->cb != NULL)\n    uv_rwlock_rdlock(&req->loop->cloexec_lock);\n\n  r = open(req->path, req->flags, req->mode);\n\n  /* In case of failure `uv__cloexec` will leave error in `errno`,\n   * so it is enough to just set `r` to `-1`.\n   */\n  if (r >= 0 && uv__cloexec(r, 1) != 0) {\n    r = uv__close(r);\n    if (r != 0)\n      abort();\n    r = -1;\n  }\n\n  if (req->cb != NULL)\n    uv_rwlock_rdunlock(&req->loop->cloexec_lock);\n\n  return r;\n#endif  /* O_CLOEXEC */\n}\n\n\n#if !HAVE_PREADV\nstatic ssize_t uv__fs_preadv(uv_file fd,\n                             uv_buf_t* bufs,\n                             unsigned int nbufs,\n                             off_t off) {\n  uv_buf_t* buf;\n  uv_buf_t* end;\n  ssize_t result;\n  ssize_t rc;\n  size_t pos;\n\n  assert(nbufs > 0);\n\n  result = 0;\n  pos = 0;\n  buf = bufs + 0;\n  end = bufs + nbufs;\n\n  for (;;) {\n    do\n      rc = pread(fd, buf->base + pos, buf->len - pos, off + result);\n    while (rc == -1 && errno == EINTR);\n\n    if (rc == 0)\n      break;\n\n    if (rc == -1 && result == 0)\n      return UV__ERR(errno);\n\n    if (rc == -1)\n      break;  /* We read some data so return that, ignore the error. */\n\n    pos += rc;\n    result += rc;\n\n    if (pos < buf->len)\n      continue;\n\n    pos = 0;\n    buf += 1;\n\n    if (buf == end)\n      break;\n  }\n\n  return result;\n}\n#endif\n\n\nstatic ssize_t uv__fs_read(uv_fs_t* req) {\n#if defined(__linux__)\n  static int no_preadv;\n#endif\n  unsigned int iovmax;\n  ssize_t result;\n\n  iovmax = uv__getiovmax();\n  if (req->nbufs > iovmax)\n    req->nbufs = iovmax;\n\n  if (req->off < 0) {\n    if (req->nbufs == 1)\n      result = read(req->file, req->bufs[0].base, req->bufs[0].len);\n    else\n      result = readv(req->file, (struct iovec*) req->bufs, req->nbufs);\n  } else {\n    if (req->nbufs == 1) {\n      result = pread(req->file, req->bufs[0].base, req->bufs[0].len, req->off);\n      goto done;\n    }\n\n#if HAVE_PREADV\n    result = preadv(req->file, (struct iovec*) req->bufs, req->nbufs, req->off);\n#else\n# if defined(__linux__)\n    if (uv__load_relaxed(&no_preadv)) retry:\n# endif\n    {\n      result = uv__fs_preadv(req->file, req->bufs, req->nbufs, req->off);\n    }\n# if defined(__linux__)\n    else {\n      result = uv__preadv(req->file,\n                          (struct iovec*)req->bufs,\n                          req->nbufs,\n                          req->off);\n      if (result == -1 && errno == ENOSYS) {\n        uv__store_relaxed(&no_preadv, 1);\n        goto retry;\n      }\n    }\n# endif\n#endif\n  }\n\ndone:\n  /* Early cleanup of bufs allocation, since we're done with it. */\n  if (req->bufs != req->bufsml)\n    uv__free(req->bufs);\n\n  req->bufs = NULL;\n  req->nbufs = 0;\n\n#ifdef __PASE__\n  /* PASE returns EOPNOTSUPP when reading a directory, convert to EISDIR */\n  if (result == -1 && errno == EOPNOTSUPP) {\n    struct stat buf;\n    ssize_t rc;\n    rc = fstat(req->file, &buf);\n    if (rc == 0 && S_ISDIR(buf.st_mode)) {\n      errno = EISDIR;\n    }\n  }\n#endif\n\n  return result;\n}\n\n\n#if defined(__APPLE__) && !defined(MAC_OS_X_VERSION_10_8)\n#define UV_CONST_DIRENT uv__dirent_t\n#else\n#define UV_CONST_DIRENT const uv__dirent_t\n#endif\n\n\nstatic int uv__fs_scandir_filter(UV_CONST_DIRENT* dent) {\n  return strcmp(dent->d_name, \".\") != 0 && strcmp(dent->d_name, \"..\") != 0;\n}\n\n\nstatic int uv__fs_scandir_sort(UV_CONST_DIRENT** a, UV_CONST_DIRENT** b) {\n  return strcmp((*a)->d_name, (*b)->d_name);\n}\n\n\nstatic ssize_t uv__fs_scandir(uv_fs_t* req) {\n  uv__dirent_t** dents;\n  int n;\n\n  dents = NULL;\n  n = scandir(req->path, &dents, uv__fs_scandir_filter, uv__fs_scandir_sort);\n\n  /* NOTE: We will use nbufs as an index field */\n  req->nbufs = 0;\n\n  if (n == 0) {\n    /* OS X still needs to deallocate some memory.\n     * Memory was allocated using the system allocator, so use free() here.\n     */\n    free(dents);\n    dents = NULL;\n  } else if (n == -1) {\n    return n;\n  }\n\n  req->ptr = dents;\n\n  return n;\n}\n\nstatic int uv__fs_opendir(uv_fs_t* req) {\n  uv_dir_t* dir;\n\n  dir = uv__malloc(sizeof(*dir));\n  if (dir == NULL)\n    goto error;\n\n  dir->dir = opendir(req->path);\n  if (dir->dir == NULL)\n    goto error;\n\n  req->ptr = dir;\n  return 0;\n\nerror:\n  uv__free(dir);\n  req->ptr = NULL;\n  return -1;\n}\n\nstatic int uv__fs_readdir(uv_fs_t* req) {\n  uv_dir_t* dir;\n  uv_dirent_t* dirent;\n  struct dirent* res;\n  unsigned int dirent_idx;\n  unsigned int i;\n\n  dir = req->ptr;\n  dirent_idx = 0;\n\n  while (dirent_idx < dir->nentries) {\n    /* readdir() returns NULL on end of directory, as well as on error. errno\n       is used to differentiate between the two conditions. */\n    errno = 0;\n    res = readdir(dir->dir);\n\n    if (res == NULL) {\n      if (errno != 0)\n        goto error;\n      break;\n    }\n\n    if (strcmp(res->d_name, \".\") == 0 || strcmp(res->d_name, \"..\") == 0)\n      continue;\n\n    dirent = &dir->dirents[dirent_idx];\n    dirent->name = uv__strdup(res->d_name);\n\n    if (dirent->name == NULL)\n      goto error;\n\n    dirent->type = uv__fs_get_dirent_type(res);\n    ++dirent_idx;\n  }\n\n  return dirent_idx;\n\nerror:\n  for (i = 0; i < dirent_idx; ++i) {\n    uv__free((char*) dir->dirents[i].name);\n    dir->dirents[i].name = NULL;\n  }\n\n  return -1;\n}\n\nstatic int uv__fs_closedir(uv_fs_t* req) {\n  uv_dir_t* dir;\n\n  dir = req->ptr;\n\n  if (dir->dir != NULL) {\n    closedir(dir->dir);\n    dir->dir = NULL;\n  }\n\n  uv__free(req->ptr);\n  req->ptr = NULL;\n  return 0;\n}\n\nstatic int uv__fs_statfs(uv_fs_t* req) {\n  uv_statfs_t* stat_fs;\n#if defined(__sun)      || \\\n    defined(__MVS__)    || \\\n    defined(__NetBSD__) || \\\n    defined(__HAIKU__)  || \\\n    defined(__QNX__)\n  struct statvfs buf;\n\n  if (0 != statvfs(req->path, &buf))\n#else\n  struct statfs buf;\n\n  if (0 != statfs(req->path, &buf))\n#endif /* defined(__sun) */\n    return -1;\n\n  stat_fs = uv__malloc(sizeof(*stat_fs));\n  if (stat_fs == NULL) {\n    errno = ENOMEM;\n    return -1;\n  }\n\n#if defined(__sun)        || \\\n    defined(__MVS__)      || \\\n    defined(__OpenBSD__)  || \\\n    defined(__NetBSD__)   || \\\n    defined(__HAIKU__)    || \\\n    defined(__QNX__)\n  stat_fs->f_type = 0;  /* f_type is not supported. */\n#else\n  stat_fs->f_type = buf.f_type;\n#endif\n  stat_fs->f_bsize = buf.f_bsize;\n  stat_fs->f_blocks = buf.f_blocks;\n  stat_fs->f_bfree = buf.f_bfree;\n  stat_fs->f_bavail = buf.f_bavail;\n  stat_fs->f_files = buf.f_files;\n  stat_fs->f_ffree = buf.f_ffree;\n  req->ptr = stat_fs;\n  return 0;\n}\n\nstatic ssize_t uv__fs_pathmax_size(const char* path) {\n  ssize_t pathmax;\n\n  pathmax = pathconf(path, _PC_PATH_MAX);\n\n  if (pathmax == -1)\n    pathmax = UV__PATH_MAX;\n\n  return pathmax;\n}\n\nstatic ssize_t uv__fs_readlink(uv_fs_t* req) {\n  ssize_t maxlen;\n  ssize_t len;\n  char* buf;\n\n#if defined(_POSIX_PATH_MAX) || defined(PATH_MAX)\n  maxlen = uv__fs_pathmax_size(req->path);\n#else\n  /* We may not have a real PATH_MAX.  Read size of link.  */\n  struct stat st;\n  int ret;\n  ret = lstat(req->path, &st);\n  if (ret != 0)\n    return -1;\n  if (!S_ISLNK(st.st_mode)) {\n    errno = EINVAL;\n    return -1;\n  }\n\n  maxlen = st.st_size;\n\n  /* According to readlink(2) lstat can report st_size == 0\n     for some symlinks, such as those in /proc or /sys.  */\n  if (maxlen == 0)\n    maxlen = uv__fs_pathmax_size(req->path);\n#endif\n\n  buf = uv__malloc(maxlen);\n\n  if (buf == NULL) {\n    errno = ENOMEM;\n    return -1;\n  }\n\n#if defined(__MVS__)\n  len = os390_readlink(req->path, buf, maxlen);\n#else\n  len = readlink(req->path, buf, maxlen);\n#endif\n\n  if (len == -1) {\n    uv__free(buf);\n    return -1;\n  }\n\n  /* Uncommon case: resize to make room for the trailing nul byte. */\n  if (len == maxlen) {\n    buf = uv__reallocf(buf, len + 1);\n\n    if (buf == NULL)\n      return -1;\n  }\n\n  buf[len] = '\\0';\n  req->ptr = buf;\n\n  return 0;\n}\n\nstatic ssize_t uv__fs_realpath(uv_fs_t* req) {\n  char* buf;\n\n#if defined(_POSIX_VERSION) && _POSIX_VERSION >= 200809L\n  buf = realpath(req->path, NULL);\n  if (buf == NULL)\n    return -1;\n#else\n  ssize_t len;\n\n  len = uv__fs_pathmax_size(req->path);\n  buf = uv__malloc(len + 1);\n\n  if (buf == NULL) {\n    errno = ENOMEM;\n    return -1;\n  }\n\n  if (realpath(req->path, buf) == NULL) {\n    uv__free(buf);\n    return -1;\n  }\n#endif\n\n  req->ptr = buf;\n\n  return 0;\n}\n\nstatic ssize_t uv__fs_sendfile_emul(uv_fs_t* req) {\n  struct pollfd pfd;\n  int use_pread;\n  off_t offset;\n  ssize_t nsent;\n  ssize_t nread;\n  ssize_t nwritten;\n  size_t buflen;\n  size_t len;\n  ssize_t n;\n  int in_fd;\n  int out_fd;\n  char buf[8192];\n\n  len = req->bufsml[0].len;\n  in_fd = req->flags;\n  out_fd = req->file;\n  offset = req->off;\n  use_pread = 1;\n\n  /* Here are the rules regarding errors:\n   *\n   * 1. Read errors are reported only if nsent==0, otherwise we return nsent.\n   *    The user needs to know that some data has already been sent, to stop\n   *    them from sending it twice.\n   *\n   * 2. Write errors are always reported. Write errors are bad because they\n   *    mean data loss: we've read data but now we can't write it out.\n   *\n   * We try to use pread() and fall back to regular read() if the source fd\n   * doesn't support positional reads, for example when it's a pipe fd.\n   *\n   * If we get EAGAIN when writing to the target fd, we poll() on it until\n   * it becomes writable again.\n   *\n   * FIXME: If we get a write error when use_pread==1, it should be safe to\n   *        return the number of sent bytes instead of an error because pread()\n   *        is, in theory, idempotent. However, special files in /dev or /proc\n   *        may support pread() but not necessarily return the same data on\n   *        successive reads.\n   *\n   * FIXME: There is no way now to signal that we managed to send *some* data\n   *        before a write error.\n   */\n  for (nsent = 0; (size_t) nsent < len; ) {\n    buflen = len - nsent;\n\n    if (buflen > sizeof(buf))\n      buflen = sizeof(buf);\n\n    do\n      if (use_pread)\n        nread = pread(in_fd, buf, buflen, offset);\n      else\n        nread = read(in_fd, buf, buflen);\n    while (nread == -1 && errno == EINTR);\n\n    if (nread == 0)\n      goto out;\n\n    if (nread == -1) {\n      if (use_pread && nsent == 0 && (errno == EIO || errno == ESPIPE)) {\n        use_pread = 0;\n        continue;\n      }\n\n      if (nsent == 0)\n        nsent = -1;\n\n      goto out;\n    }\n\n    for (nwritten = 0; nwritten < nread; ) {\n      do\n        n = write(out_fd, buf + nwritten, nread - nwritten);\n      while (n == -1 && errno == EINTR);\n\n      if (n != -1) {\n        nwritten += n;\n        continue;\n      }\n\n      if (errno != EAGAIN && errno != EWOULDBLOCK) {\n        nsent = -1;\n        goto out;\n      }\n\n      pfd.fd = out_fd;\n      pfd.events = POLLOUT;\n      pfd.revents = 0;\n\n      do\n        n = poll(&pfd, 1, -1);\n      while (n == -1 && errno == EINTR);\n\n      if (n == -1 || (pfd.revents & ~POLLOUT) != 0) {\n        errno = EIO;\n        nsent = -1;\n        goto out;\n      }\n    }\n\n    offset += nread;\n    nsent += nread;\n  }\n\nout:\n  if (nsent != -1)\n    req->off = offset;\n\n  return nsent;\n}\n\n\nstatic ssize_t uv__fs_sendfile(uv_fs_t* req) {\n  int in_fd;\n  int out_fd;\n\n  in_fd = req->flags;\n  out_fd = req->file;\n\n#if defined(__linux__) || defined(__sun)\n  {\n    off_t off;\n    ssize_t r;\n\n    off = req->off;\n\n#ifdef __linux__\n    {\n      static int copy_file_range_support = 1;\n\n      if (copy_file_range_support) {\n        r = uv__fs_copy_file_range(in_fd, NULL, out_fd, &off, req->bufsml[0].len, 0);\n\n        if (r == -1 && errno == ENOSYS) {\n          errno = 0;\n          copy_file_range_support = 0;\n        } else {\n          goto ok;\n        }\n      }\n    }\n#endif\n\n    r = sendfile(out_fd, in_fd, &off, req->bufsml[0].len);\n\nok:\n    /* sendfile() on SunOS returns EINVAL if the target fd is not a socket but\n     * it still writes out data. Fortunately, we can detect it by checking if\n     * the offset has been updated.\n     */\n    if (r != -1 || off > req->off) {\n      r = off - req->off;\n      req->off = off;\n      return r;\n    }\n\n    if (errno == EINVAL ||\n        errno == EIO ||\n        errno == ENOTSOCK ||\n        errno == EXDEV) {\n      errno = 0;\n      return uv__fs_sendfile_emul(req);\n    }\n\n    return -1;\n  }\n#elif defined(__APPLE__)           || \\\n      defined(__DragonFly__)       || \\\n      defined(__FreeBSD__)         || \\\n      defined(__FreeBSD_kernel__)\n  {\n    off_t len;\n    ssize_t r;\n\n    /* sendfile() on FreeBSD and Darwin returns EAGAIN if the target fd is in\n     * non-blocking mode and not all data could be written. If a non-zero\n     * number of bytes have been sent, we don't consider it an error.\n     */\n\n#if defined(__FreeBSD__) || defined(__DragonFly__)\n    len = 0;\n    r = sendfile(in_fd, out_fd, req->off, req->bufsml[0].len, NULL, &len, 0);\n#elif defined(__FreeBSD_kernel__)\n    len = 0;\n    r = bsd_sendfile(in_fd,\n                     out_fd,\n                     req->off,\n                     req->bufsml[0].len,\n                     NULL,\n                     &len,\n                     0);\n#else\n    /* The darwin sendfile takes len as an input for the length to send,\n     * so make sure to initialize it with the caller's value. */\n    len = req->bufsml[0].len;\n    r = sendfile(in_fd, out_fd, req->off, &len, NULL, 0);\n#endif\n\n     /*\n     * The man page for sendfile(2) on DragonFly states that `len` contains\n     * a meaningful value ONLY in case of EAGAIN and EINTR.\n     * Nothing is said about it's value in case of other errors, so better\n     * not depend on the potential wrong assumption that is was not modified\n     * by the syscall.\n     */\n    if (r == 0 || ((errno == EAGAIN || errno == EINTR) && len != 0)) {\n      req->off += len;\n      return (ssize_t) len;\n    }\n\n    if (errno == EINVAL ||\n        errno == EIO ||\n        errno == ENOTSOCK ||\n        errno == EXDEV) {\n      errno = 0;\n      return uv__fs_sendfile_emul(req);\n    }\n\n    return -1;\n  }\n#else\n  /* Squelch compiler warnings. */\n  (void) &in_fd;\n  (void) &out_fd;\n\n  return uv__fs_sendfile_emul(req);\n#endif\n}\n\n\nstatic ssize_t uv__fs_utime(uv_fs_t* req) {\n#if defined(__linux__)                                                         \\\n    || defined(_AIX71)                                                         \\\n    || defined(__sun)                                                          \\\n    || defined(__HAIKU__)\n  /* utimesat() has nanosecond resolution but we stick to microseconds\n   * for the sake of consistency with other platforms.\n   */\n  struct timespec ts[2];\n  ts[0] = uv__fs_to_timespec(req->atime);\n  ts[1] = uv__fs_to_timespec(req->mtime);\n  return utimensat(AT_FDCWD, req->path, ts, 0);\n#elif defined(__APPLE__)                                                      \\\n    || defined(__DragonFly__)                                                 \\\n    || defined(__FreeBSD__)                                                   \\\n    || defined(__FreeBSD_kernel__)                                            \\\n    || defined(__NetBSD__)                                                    \\\n    || defined(__OpenBSD__)\n  struct timeval tv[2];\n  tv[0] = uv__fs_to_timeval(req->atime);\n  tv[1] = uv__fs_to_timeval(req->mtime);\n  return utimes(req->path, tv);\n#elif defined(_AIX)                                                           \\\n    && !defined(_AIX71)\n  struct utimbuf buf;\n  buf.actime = req->atime;\n  buf.modtime = req->mtime;\n  return utime(req->path, &buf);\n#elif defined(__MVS__)\n  attrib_t atr;\n  memset(&atr, 0, sizeof(atr));\n  atr.att_mtimechg = 1;\n  atr.att_atimechg = 1;\n  atr.att_mtime = req->mtime;\n  atr.att_atime = req->atime;\n  return __lchattr((char*) req->path, &atr, sizeof(atr));\n#else\n  errno = ENOSYS;\n  return -1;\n#endif\n}\n\n\nstatic ssize_t uv__fs_lutime(uv_fs_t* req) {\n#if defined(__linux__)            ||                                           \\\n    defined(_AIX71)               ||                                           \\\n    defined(__sun)                ||                                           \\\n    defined(__HAIKU__)\n  struct timespec ts[2];\n  ts[0] = uv__fs_to_timespec(req->atime);\n  ts[1] = uv__fs_to_timespec(req->mtime);\n  return utimensat(AT_FDCWD, req->path, ts, AT_SYMLINK_NOFOLLOW);\n#elif defined(__APPLE__)          ||                                          \\\n      defined(__DragonFly__)      ||                                          \\\n      defined(__FreeBSD__)        ||                                          \\\n      defined(__FreeBSD_kernel__) ||                                          \\\n      defined(__NetBSD__)\n  struct timeval tv[2];\n  tv[0] = uv__fs_to_timeval(req->atime);\n  tv[1] = uv__fs_to_timeval(req->mtime);\n  return lutimes(req->path, tv);\n#else\n  errno = ENOSYS;\n  return -1;\n#endif\n}\n\n\nstatic ssize_t uv__fs_write(uv_fs_t* req) {\n#if defined(__linux__)\n  static int no_pwritev;\n#endif\n  ssize_t r;\n\n  /* Serialize writes on OS X, concurrent write() and pwrite() calls result in\n   * data loss. We can't use a per-file descriptor lock, the descriptor may be\n   * a dup().\n   */\n#if defined(__APPLE__)\n  static pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;\n\n  if (pthread_mutex_lock(&lock))\n    abort();\n#endif\n\n  if (req->off < 0) {\n    if (req->nbufs == 1)\n      r = write(req->file, req->bufs[0].base, req->bufs[0].len);\n    else\n      r = writev(req->file, (struct iovec*) req->bufs, req->nbufs);\n  } else {\n    if (req->nbufs == 1) {\n      r = pwrite(req->file, req->bufs[0].base, req->bufs[0].len, req->off);\n      goto done;\n    }\n#if HAVE_PREADV\n    r = pwritev(req->file, (struct iovec*) req->bufs, req->nbufs, req->off);\n#else\n# if defined(__linux__)\n    if (no_pwritev) retry:\n# endif\n    {\n      r = pwrite(req->file, req->bufs[0].base, req->bufs[0].len, req->off);\n    }\n# if defined(__linux__)\n    else {\n      r = uv__pwritev(req->file,\n                      (struct iovec*) req->bufs,\n                      req->nbufs,\n                      req->off);\n      if (r == -1 && errno == ENOSYS) {\n        no_pwritev = 1;\n        goto retry;\n      }\n    }\n# endif\n#endif\n  }\n\ndone:\n#if defined(__APPLE__)\n  if (pthread_mutex_unlock(&lock))\n    abort();\n#endif\n\n  return r;\n}\n\nstatic ssize_t uv__fs_copyfile(uv_fs_t* req) {\n  uv_fs_t fs_req;\n  uv_file srcfd;\n  uv_file dstfd;\n  struct stat src_statsbuf;\n  struct stat dst_statsbuf;\n  int dst_flags;\n  int result;\n  int err;\n  off_t bytes_to_send;\n  off_t in_offset;\n  off_t bytes_written;\n  size_t bytes_chunk;\n\n  dstfd = -1;\n  err = 0;\n\n  /* Open the source file. */\n  srcfd = uv_fs_open(NULL, &fs_req, req->path, O_RDONLY, 0, NULL);\n  uv_fs_req_cleanup(&fs_req);\n\n  if (srcfd < 0)\n    return srcfd;\n\n  /* Get the source file's mode. */\n  if (fstat(srcfd, &src_statsbuf)) {\n    err = UV__ERR(errno);\n    goto out;\n  }\n\n  dst_flags = O_WRONLY | O_CREAT;\n\n  if (req->flags & UV_FS_COPYFILE_EXCL)\n    dst_flags |= O_EXCL;\n\n  /* Open the destination file. */\n  dstfd = uv_fs_open(NULL,\n                     &fs_req,\n                     req->new_path,\n                     dst_flags,\n                     src_statsbuf.st_mode,\n                     NULL);\n  uv_fs_req_cleanup(&fs_req);\n\n  if (dstfd < 0) {\n    err = dstfd;\n    goto out;\n  }\n\n  /* If the file is not being opened exclusively, verify that the source and\n     destination are not the same file. If they are the same, bail out early. */\n  if ((req->flags & UV_FS_COPYFILE_EXCL) == 0) {\n    /* Get the destination file's mode. */\n    if (fstat(dstfd, &dst_statsbuf)) {\n      err = UV__ERR(errno);\n      goto out;\n    }\n\n    /* Check if srcfd and dstfd refer to the same file */\n    if (src_statsbuf.st_dev == dst_statsbuf.st_dev &&\n        src_statsbuf.st_ino == dst_statsbuf.st_ino) {\n      goto out;\n    }\n\n    /* Truncate the file in case the destination already existed. */\n    if (ftruncate(dstfd, 0) != 0) {\n      err = UV__ERR(errno);\n      goto out;\n    }\n  }\n\n  if (fchmod(dstfd, src_statsbuf.st_mode) == -1) {\n    err = UV__ERR(errno);\n#ifdef __linux__\n    if (err != UV_EPERM)\n      goto out;\n\n    {\n      struct statfs s;\n\n      /* fchmod() on CIFS shares always fails with EPERM unless the share is\n       * mounted with \"noperm\". As fchmod() is a meaningless operation on such\n       * shares anyway, detect that condition and squelch the error.\n       */\n      if (fstatfs(dstfd, &s) == -1)\n        goto out;\n\n      if (s.f_type != /* CIFS */ 0xFF534D42u)\n        goto out;\n    }\n\n    err = 0;\n#else  /* !__linux__ */\n    goto out;\n#endif  /* !__linux__ */\n  }\n\n#ifdef FICLONE\n  if (req->flags & UV_FS_COPYFILE_FICLONE ||\n      req->flags & UV_FS_COPYFILE_FICLONE_FORCE) {\n    if (ioctl(dstfd, FICLONE, srcfd) == 0) {\n      /* ioctl() with FICLONE succeeded. */\n      goto out;\n    }\n    /* If an error occurred and force was set, return the error to the caller;\n     * fall back to sendfile() when force was not set. */\n    if (req->flags & UV_FS_COPYFILE_FICLONE_FORCE) {\n      err = UV__ERR(errno);\n      goto out;\n    }\n  }\n#else\n  if (req->flags & UV_FS_COPYFILE_FICLONE_FORCE) {\n    err = UV_ENOSYS;\n    goto out;\n  }\n#endif\n\n  bytes_to_send = src_statsbuf.st_size;\n  in_offset = 0;\n  while (bytes_to_send != 0) {\n    bytes_chunk = SSIZE_MAX;\n    if (bytes_to_send < (off_t) bytes_chunk)\n      bytes_chunk = bytes_to_send;\n    uv_fs_sendfile(NULL, &fs_req, dstfd, srcfd, in_offset, bytes_chunk, NULL);\n    bytes_written = fs_req.result;\n    uv_fs_req_cleanup(&fs_req);\n\n    if (bytes_written < 0) {\n      err = bytes_written;\n      break;\n    }\n\n    bytes_to_send -= bytes_written;\n    in_offset += bytes_written;\n  }\n\nout:\n  if (err < 0)\n    result = err;\n  else\n    result = 0;\n\n  /* Close the source file. */\n  err = uv__close_nocheckstdio(srcfd);\n\n  /* Don't overwrite any existing errors. */\n  if (err != 0 && result == 0)\n    result = err;\n\n  /* Close the destination file if it is open. */\n  if (dstfd >= 0) {\n    err = uv__close_nocheckstdio(dstfd);\n\n    /* Don't overwrite any existing errors. */\n    if (err != 0 && result == 0)\n      result = err;\n\n    /* Remove the destination file if something went wrong. */\n    if (result != 0) {\n      uv_fs_unlink(NULL, &fs_req, req->new_path, NULL);\n      /* Ignore the unlink return value, as an error already happened. */\n      uv_fs_req_cleanup(&fs_req);\n    }\n  }\n\n  if (result == 0)\n    return 0;\n\n  errno = UV__ERR(result);\n  return -1;\n}\n\nstatic void uv__to_stat(struct stat* src, uv_stat_t* dst) {\n  dst->st_dev = src->st_dev;\n  dst->st_mode = src->st_mode;\n  dst->st_nlink = src->st_nlink;\n  dst->st_uid = src->st_uid;\n  dst->st_gid = src->st_gid;\n  dst->st_rdev = src->st_rdev;\n  dst->st_ino = src->st_ino;\n  dst->st_size = src->st_size;\n  dst->st_blksize = src->st_blksize;\n  dst->st_blocks = src->st_blocks;\n\n#if defined(__APPLE__)\n  dst->st_atim.tv_sec = src->st_atimespec.tv_sec;\n  dst->st_atim.tv_nsec = src->st_atimespec.tv_nsec;\n  dst->st_mtim.tv_sec = src->st_mtimespec.tv_sec;\n  dst->st_mtim.tv_nsec = src->st_mtimespec.tv_nsec;\n  dst->st_ctim.tv_sec = src->st_ctimespec.tv_sec;\n  dst->st_ctim.tv_nsec = src->st_ctimespec.tv_nsec;\n  dst->st_birthtim.tv_sec = src->st_birthtimespec.tv_sec;\n  dst->st_birthtim.tv_nsec = src->st_birthtimespec.tv_nsec;\n  dst->st_flags = src->st_flags;\n  dst->st_gen = src->st_gen;\n#elif defined(__ANDROID__)\n  dst->st_atim.tv_sec = src->st_atime;\n  dst->st_atim.tv_nsec = src->st_atimensec;\n  dst->st_mtim.tv_sec = src->st_mtime;\n  dst->st_mtim.tv_nsec = src->st_mtimensec;\n  dst->st_ctim.tv_sec = src->st_ctime;\n  dst->st_ctim.tv_nsec = src->st_ctimensec;\n  dst->st_birthtim.tv_sec = src->st_ctime;\n  dst->st_birthtim.tv_nsec = src->st_ctimensec;\n  dst->st_flags = 0;\n  dst->st_gen = 0;\n#elif !defined(_AIX) && (       \\\n    defined(__DragonFly__)   || \\\n    defined(__FreeBSD__)     || \\\n    defined(__OpenBSD__)     || \\\n    defined(__NetBSD__)      || \\\n    defined(_GNU_SOURCE)     || \\\n    defined(_BSD_SOURCE)     || \\\n    defined(_SVID_SOURCE)    || \\\n    defined(_XOPEN_SOURCE)   || \\\n    defined(_DEFAULT_SOURCE))\n  dst->st_atim.tv_sec = src->st_atim.tv_sec;\n  dst->st_atim.tv_nsec = src->st_atim.tv_nsec;\n  dst->st_mtim.tv_sec = src->st_mtim.tv_sec;\n  dst->st_mtim.tv_nsec = src->st_mtim.tv_nsec;\n  dst->st_ctim.tv_sec = src->st_ctim.tv_sec;\n  dst->st_ctim.tv_nsec = src->st_ctim.tv_nsec;\n# if defined(__FreeBSD__)    || \\\n     defined(__NetBSD__)\n  dst->st_birthtim.tv_sec = src->st_birthtim.tv_sec;\n  dst->st_birthtim.tv_nsec = src->st_birthtim.tv_nsec;\n  dst->st_flags = src->st_flags;\n  dst->st_gen = src->st_gen;\n# else\n  dst->st_birthtim.tv_sec = src->st_ctim.tv_sec;\n  dst->st_birthtim.tv_nsec = src->st_ctim.tv_nsec;\n  dst->st_flags = 0;\n  dst->st_gen = 0;\n# endif\n#else\n  dst->st_atim.tv_sec = src->st_atime;\n  dst->st_atim.tv_nsec = 0;\n  dst->st_mtim.tv_sec = src->st_mtime;\n  dst->st_mtim.tv_nsec = 0;\n  dst->st_ctim.tv_sec = src->st_ctime;\n  dst->st_ctim.tv_nsec = 0;\n  dst->st_birthtim.tv_sec = src->st_ctime;\n  dst->st_birthtim.tv_nsec = 0;\n  dst->st_flags = 0;\n  dst->st_gen = 0;\n#endif\n}\n\n\nstatic int uv__fs_statx(int fd,\n                        const char* path,\n                        int is_fstat,\n                        int is_lstat,\n                        uv_stat_t* buf) {\n  STATIC_ASSERT(UV_ENOSYS != -1);\n#ifdef __linux__\n  static int no_statx;\n  struct uv__statx statxbuf;\n  int dirfd;\n  int flags;\n  int mode;\n  int rc;\n\n  if (uv__load_relaxed(&no_statx))\n    return UV_ENOSYS;\n\n  dirfd = AT_FDCWD;\n  flags = 0; /* AT_STATX_SYNC_AS_STAT */\n  mode = 0xFFF; /* STATX_BASIC_STATS + STATX_BTIME */\n\n  if (is_fstat) {\n    dirfd = fd;\n    flags |= 0x1000; /* AT_EMPTY_PATH */\n  }\n\n  if (is_lstat)\n    flags |= AT_SYMLINK_NOFOLLOW;\n\n  rc = uv__statx(dirfd, path, flags, mode, &statxbuf);\n\n  switch (rc) {\n  case 0:\n    break;\n  case -1:\n    /* EPERM happens when a seccomp filter rejects the system call.\n     * Has been observed with libseccomp < 2.3.3 and docker < 18.04.\n     */\n    if (errno != EINVAL && errno != EPERM && errno != ENOSYS)\n      return -1;\n    /* Fall through. */\n  default:\n    /* Normally on success, zero is returned and On error, -1 is returned.\n     * Observed on S390 RHEL running in a docker container with statx not\n     * implemented, rc might return 1 with 0 set as the error code in which\n     * case we return ENOSYS.\n     */\n    uv__store_relaxed(&no_statx, 1);\n    return UV_ENOSYS;\n  }\n\n  buf->st_dev = 256 * statxbuf.stx_dev_major + statxbuf.stx_dev_minor;\n  buf->st_mode = statxbuf.stx_mode;\n  buf->st_nlink = statxbuf.stx_nlink;\n  buf->st_uid = statxbuf.stx_uid;\n  buf->st_gid = statxbuf.stx_gid;\n  buf->st_rdev = statxbuf.stx_rdev_major;\n  buf->st_ino = statxbuf.stx_ino;\n  buf->st_size = statxbuf.stx_size;\n  buf->st_blksize = statxbuf.stx_blksize;\n  buf->st_blocks = statxbuf.stx_blocks;\n  buf->st_atim.tv_sec = statxbuf.stx_atime.tv_sec;\n  buf->st_atim.tv_nsec = statxbuf.stx_atime.tv_nsec;\n  buf->st_mtim.tv_sec = statxbuf.stx_mtime.tv_sec;\n  buf->st_mtim.tv_nsec = statxbuf.stx_mtime.tv_nsec;\n  buf->st_ctim.tv_sec = statxbuf.stx_ctime.tv_sec;\n  buf->st_ctim.tv_nsec = statxbuf.stx_ctime.tv_nsec;\n  buf->st_birthtim.tv_sec = statxbuf.stx_btime.tv_sec;\n  buf->st_birthtim.tv_nsec = statxbuf.stx_btime.tv_nsec;\n  buf->st_flags = 0;\n  buf->st_gen = 0;\n\n  return 0;\n#else\n  return UV_ENOSYS;\n#endif /* __linux__ */\n}\n\n\nstatic int uv__fs_stat(const char *path, uv_stat_t *buf) {\n  struct stat pbuf;\n  int ret;\n\n  ret = uv__fs_statx(-1, path, /* is_fstat */ 0, /* is_lstat */ 0, buf);\n  if (ret != UV_ENOSYS)\n    return ret;\n\n  ret = stat(path, &pbuf);\n  if (ret == 0)\n    uv__to_stat(&pbuf, buf);\n\n  return ret;\n}\n\n\nstatic int uv__fs_lstat(const char *path, uv_stat_t *buf) {\n  struct stat pbuf;\n  int ret;\n\n  ret = uv__fs_statx(-1, path, /* is_fstat */ 0, /* is_lstat */ 1, buf);\n  if (ret != UV_ENOSYS)\n    return ret;\n\n  ret = lstat(path, &pbuf);\n  if (ret == 0)\n    uv__to_stat(&pbuf, buf);\n\n  return ret;\n}\n\n\nstatic int uv__fs_fstat(int fd, uv_stat_t *buf) {\n  struct stat pbuf;\n  int ret;\n\n  ret = uv__fs_statx(fd, \"\", /* is_fstat */ 1, /* is_lstat */ 0, buf);\n  if (ret != UV_ENOSYS)\n    return ret;\n\n  ret = fstat(fd, &pbuf);\n  if (ret == 0)\n    uv__to_stat(&pbuf, buf);\n\n  return ret;\n}\n\nstatic size_t uv__fs_buf_offset(uv_buf_t* bufs, size_t size) {\n  size_t offset;\n  /* Figure out which bufs are done */\n  for (offset = 0; size > 0 && bufs[offset].len <= size; ++offset)\n    size -= bufs[offset].len;\n\n  /* Fix a partial read/write */\n  if (size > 0) {\n    bufs[offset].base += size;\n    bufs[offset].len -= size;\n  }\n  return offset;\n}\n\nstatic ssize_t uv__fs_write_all(uv_fs_t* req) {\n  unsigned int iovmax;\n  unsigned int nbufs;\n  uv_buf_t* bufs;\n  ssize_t total;\n  ssize_t result;\n\n  iovmax = uv__getiovmax();\n  nbufs = req->nbufs;\n  bufs = req->bufs;\n  total = 0;\n\n  while (nbufs > 0) {\n    req->nbufs = nbufs;\n    if (req->nbufs > iovmax)\n      req->nbufs = iovmax;\n\n    do\n      result = uv__fs_write(req);\n    while (result < 0 && errno == EINTR);\n\n    if (result <= 0) {\n      if (total == 0)\n        total = result;\n      break;\n    }\n\n    if (req->off >= 0)\n      req->off += result;\n\n    req->nbufs = uv__fs_buf_offset(req->bufs, result);\n    req->bufs += req->nbufs;\n    nbufs -= req->nbufs;\n    total += result;\n  }\n\n  if (bufs != req->bufsml)\n    uv__free(bufs);\n\n  req->bufs = NULL;\n  req->nbufs = 0;\n\n  return total;\n}\n\n\nstatic void uv__fs_work(struct uv__work* w) {\n  int retry_on_eintr;\n  uv_fs_t* req;\n  ssize_t r;\n\n  req = container_of(w, uv_fs_t, work_req);\n  retry_on_eintr = !(req->fs_type == UV_FS_CLOSE ||\n                     req->fs_type == UV_FS_READ);\n\n  do {\n    errno = 0;\n\n#define X(type, action)                                                       \\\n  case UV_FS_ ## type:                                                        \\\n    r = action;                                                               \\\n    break;\n\n    switch (req->fs_type) {\n    X(ACCESS, access(req->path, req->flags));\n    X(CHMOD, chmod(req->path, req->mode));\n    X(CHOWN, chown(req->path, req->uid, req->gid));\n    X(CLOSE, uv__fs_close(req->file));\n    X(COPYFILE, uv__fs_copyfile(req));\n    X(FCHMOD, fchmod(req->file, req->mode));\n    X(FCHOWN, fchown(req->file, req->uid, req->gid));\n    X(LCHOWN, lchown(req->path, req->uid, req->gid));\n    X(FDATASYNC, uv__fs_fdatasync(req));\n    X(FSTAT, uv__fs_fstat(req->file, &req->statbuf));\n    X(FSYNC, uv__fs_fsync(req));\n    X(FTRUNCATE, ftruncate(req->file, req->off));\n    X(FUTIME, uv__fs_futime(req));\n    X(LUTIME, uv__fs_lutime(req));\n    X(LSTAT, uv__fs_lstat(req->path, &req->statbuf));\n    X(LINK, link(req->path, req->new_path));\n    X(MKDIR, mkdir(req->path, req->mode));\n    X(MKDTEMP, uv__fs_mkdtemp(req));\n    X(MKSTEMP, uv__fs_mkstemp(req));\n    X(OPEN, uv__fs_open(req));\n    X(READ, uv__fs_read(req));\n    X(SCANDIR, uv__fs_scandir(req));\n    X(OPENDIR, uv__fs_opendir(req));\n    X(READDIR, uv__fs_readdir(req));\n    X(CLOSEDIR, uv__fs_closedir(req));\n    X(READLINK, uv__fs_readlink(req));\n    X(REALPATH, uv__fs_realpath(req));\n    X(RENAME, rename(req->path, req->new_path));\n    X(RMDIR, rmdir(req->path));\n    X(SENDFILE, uv__fs_sendfile(req));\n    X(STAT, uv__fs_stat(req->path, &req->statbuf));\n    X(STATFS, uv__fs_statfs(req));\n    X(SYMLINK, symlink(req->path, req->new_path));\n    X(UNLINK, unlink(req->path));\n    X(UTIME, uv__fs_utime(req));\n    X(WRITE, uv__fs_write_all(req));\n    default: abort();\n    }\n#undef X\n  } while (r == -1 && errno == EINTR && retry_on_eintr);\n\n  if (r == -1)\n    req->result = UV__ERR(errno);\n  else\n    req->result = r;\n\n  if (r == 0 && (req->fs_type == UV_FS_STAT ||\n                 req->fs_type == UV_FS_FSTAT ||\n                 req->fs_type == UV_FS_LSTAT)) {\n    req->ptr = &req->statbuf;\n  }\n}\n\n\nstatic void uv__fs_done(struct uv__work* w, int status) {\n  uv_fs_t* req;\n\n  req = container_of(w, uv_fs_t, work_req);\n  uv__req_unregister(req->loop, req);\n\n  if (status == UV_ECANCELED) {\n    assert(req->result == 0);\n    req->result = UV_ECANCELED;\n  }\n\n  req->cb(req);\n}\n\n\nint uv_fs_access(uv_loop_t* loop,\n                 uv_fs_t* req,\n                 const char* path,\n                 int flags,\n                 uv_fs_cb cb) {\n  INIT(ACCESS);\n  PATH;\n  req->flags = flags;\n  POST;\n}\n\n\nint uv_fs_chmod(uv_loop_t* loop,\n                uv_fs_t* req,\n                const char* path,\n                int mode,\n                uv_fs_cb cb) {\n  INIT(CHMOD);\n  PATH;\n  req->mode = mode;\n  POST;\n}\n\n\nint uv_fs_chown(uv_loop_t* loop,\n                uv_fs_t* req,\n                const char* path,\n                uv_uid_t uid,\n                uv_gid_t gid,\n                uv_fs_cb cb) {\n  INIT(CHOWN);\n  PATH;\n  req->uid = uid;\n  req->gid = gid;\n  POST;\n}\n\n\nint uv_fs_close(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb) {\n  INIT(CLOSE);\n  req->file = file;\n  POST;\n}\n\n\nint uv_fs_fchmod(uv_loop_t* loop,\n                 uv_fs_t* req,\n                 uv_file file,\n                 int mode,\n                 uv_fs_cb cb) {\n  INIT(FCHMOD);\n  req->file = file;\n  req->mode = mode;\n  POST;\n}\n\n\nint uv_fs_fchown(uv_loop_t* loop,\n                 uv_fs_t* req,\n                 uv_file file,\n                 uv_uid_t uid,\n                 uv_gid_t gid,\n                 uv_fs_cb cb) {\n  INIT(FCHOWN);\n  req->file = file;\n  req->uid = uid;\n  req->gid = gid;\n  POST;\n}\n\n\nint uv_fs_lchown(uv_loop_t* loop,\n                 uv_fs_t* req,\n                 const char* path,\n                 uv_uid_t uid,\n                 uv_gid_t gid,\n                 uv_fs_cb cb) {\n  INIT(LCHOWN);\n  PATH;\n  req->uid = uid;\n  req->gid = gid;\n  POST;\n}\n\n\nint uv_fs_fdatasync(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb) {\n  INIT(FDATASYNC);\n  req->file = file;\n  POST;\n}\n\n\nint uv_fs_fstat(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb) {\n  INIT(FSTAT);\n  req->file = file;\n  POST;\n}\n\n\nint uv_fs_fsync(uv_loop_t* loop, uv_fs_t* req, uv_file file, uv_fs_cb cb) {\n  INIT(FSYNC);\n  req->file = file;\n  POST;\n}\n\n\nint uv_fs_ftruncate(uv_loop_t* loop,\n                    uv_fs_t* req,\n                    uv_file file,\n                    int64_t off,\n                    uv_fs_cb cb) {\n  INIT(FTRUNCATE);\n  req->file = file;\n  req->off = off;\n  POST;\n}\n\n\nint uv_fs_futime(uv_loop_t* loop,\n                 uv_fs_t* req,\n                 uv_file file,\n                 double atime,\n                 double mtime,\n                 uv_fs_cb cb) {\n  INIT(FUTIME);\n  req->file = file;\n  req->atime = atime;\n  req->mtime = mtime;\n  POST;\n}\n\nint uv_fs_lutime(uv_loop_t* loop,\n                 uv_fs_t* req,\n                 const char* path,\n                 double atime,\n                 double mtime,\n                 uv_fs_cb cb) {\n  INIT(LUTIME);\n  PATH;\n  req->atime = atime;\n  req->mtime = mtime;\n  POST;\n}\n\n\nint uv_fs_lstat(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb) {\n  INIT(LSTAT);\n  PATH;\n  POST;\n}\n\n\nint uv_fs_link(uv_loop_t* loop,\n               uv_fs_t* req,\n               const char* path,\n               const char* new_path,\n               uv_fs_cb cb) {\n  INIT(LINK);\n  PATH2;\n  POST;\n}\n\n\nint uv_fs_mkdir(uv_loop_t* loop,\n                uv_fs_t* req,\n                const char* path,\n                int mode,\n                uv_fs_cb cb) {\n  INIT(MKDIR);\n  PATH;\n  req->mode = mode;\n  POST;\n}\n\n\nint uv_fs_mkdtemp(uv_loop_t* loop,\n                  uv_fs_t* req,\n                  const char* tpl,\n                  uv_fs_cb cb) {\n  INIT(MKDTEMP);\n  req->path = uv__strdup(tpl);\n  if (req->path == NULL)\n    return UV_ENOMEM;\n  POST;\n}\n\n\nint uv_fs_mkstemp(uv_loop_t* loop,\n                  uv_fs_t* req,\n                  const char* tpl,\n                  uv_fs_cb cb) {\n  INIT(MKSTEMP);\n  req->path = uv__strdup(tpl);\n  if (req->path == NULL)\n    return UV_ENOMEM;\n  POST;\n}\n\n\nint uv_fs_open(uv_loop_t* loop,\n               uv_fs_t* req,\n               const char* path,\n               int flags,\n               int mode,\n               uv_fs_cb cb) {\n  INIT(OPEN);\n  PATH;\n  req->flags = flags;\n  req->mode = mode;\n  POST;\n}\n\n\nint uv_fs_read(uv_loop_t* loop, uv_fs_t* req,\n               uv_file file,\n               const uv_buf_t bufs[],\n               unsigned int nbufs,\n               int64_t off,\n               uv_fs_cb cb) {\n  INIT(READ);\n\n  if (bufs == NULL || nbufs == 0)\n    return UV_EINVAL;\n\n  req->file = file;\n\n  req->nbufs = nbufs;\n  req->bufs = req->bufsml;\n  if (nbufs > ARRAY_SIZE(req->bufsml))\n    req->bufs = uv__malloc(nbufs * sizeof(*bufs));\n\n  if (req->bufs == NULL)\n    return UV_ENOMEM;\n\n  memcpy(req->bufs, bufs, nbufs * sizeof(*bufs));\n\n  req->off = off;\n  POST;\n}\n\n\nint uv_fs_scandir(uv_loop_t* loop,\n                  uv_fs_t* req,\n                  const char* path,\n                  int flags,\n                  uv_fs_cb cb) {\n  INIT(SCANDIR);\n  PATH;\n  req->flags = flags;\n  POST;\n}\n\nint uv_fs_opendir(uv_loop_t* loop,\n                  uv_fs_t* req,\n                  const char* path,\n                  uv_fs_cb cb) {\n  INIT(OPENDIR);\n  PATH;\n  POST;\n}\n\nint uv_fs_readdir(uv_loop_t* loop,\n                  uv_fs_t* req,\n                  uv_dir_t* dir,\n                  uv_fs_cb cb) {\n  INIT(READDIR);\n\n  if (dir == NULL || dir->dir == NULL || dir->dirents == NULL)\n    return UV_EINVAL;\n\n  req->ptr = dir;\n  POST;\n}\n\nint uv_fs_closedir(uv_loop_t* loop,\n                   uv_fs_t* req,\n                   uv_dir_t* dir,\n                   uv_fs_cb cb) {\n  INIT(CLOSEDIR);\n\n  if (dir == NULL)\n    return UV_EINVAL;\n\n  req->ptr = dir;\n  POST;\n}\n\nint uv_fs_readlink(uv_loop_t* loop,\n                   uv_fs_t* req,\n                   const char* path,\n                   uv_fs_cb cb) {\n  INIT(READLINK);\n  PATH;\n  POST;\n}\n\n\nint uv_fs_realpath(uv_loop_t* loop,\n                  uv_fs_t* req,\n                  const char * path,\n                  uv_fs_cb cb) {\n  INIT(REALPATH);\n  PATH;\n  POST;\n}\n\n\nint uv_fs_rename(uv_loop_t* loop,\n                 uv_fs_t* req,\n                 const char* path,\n                 const char* new_path,\n                 uv_fs_cb cb) {\n  INIT(RENAME);\n  PATH2;\n  POST;\n}\n\n\nint uv_fs_rmdir(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb) {\n  INIT(RMDIR);\n  PATH;\n  POST;\n}\n\n\nint uv_fs_sendfile(uv_loop_t* loop,\n                   uv_fs_t* req,\n                   uv_file out_fd,\n                   uv_file in_fd,\n                   int64_t off,\n                   size_t len,\n                   uv_fs_cb cb) {\n  INIT(SENDFILE);\n  req->flags = in_fd; /* hack */\n  req->file = out_fd;\n  req->off = off;\n  req->bufsml[0].len = len;\n  POST;\n}\n\n\nint uv_fs_stat(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb) {\n  INIT(STAT);\n  PATH;\n  POST;\n}\n\n\nint uv_fs_symlink(uv_loop_t* loop,\n                  uv_fs_t* req,\n                  const char* path,\n                  const char* new_path,\n                  int flags,\n                  uv_fs_cb cb) {\n  INIT(SYMLINK);\n  PATH2;\n  req->flags = flags;\n  POST;\n}\n\n\nint uv_fs_unlink(uv_loop_t* loop, uv_fs_t* req, const char* path, uv_fs_cb cb) {\n  INIT(UNLINK);\n  PATH;\n  POST;\n}\n\n\nint uv_fs_utime(uv_loop_t* loop,\n                uv_fs_t* req,\n                const char* path,\n                double atime,\n                double mtime,\n                uv_fs_cb cb) {\n  INIT(UTIME);\n  PATH;\n  req->atime = atime;\n  req->mtime = mtime;\n  POST;\n}\n\n\nint uv_fs_write(uv_loop_t* loop,\n                uv_fs_t* req,\n                uv_file file,\n                const uv_buf_t bufs[],\n                unsigned int nbufs,\n                int64_t off,\n                uv_fs_cb cb) {\n  INIT(WRITE);\n\n  if (bufs == NULL || nbufs == 0)\n    return UV_EINVAL;\n\n  req->file = file;\n\n  req->nbufs = nbufs;\n  req->bufs = req->bufsml;\n  if (nbufs > ARRAY_SIZE(req->bufsml))\n    req->bufs = uv__malloc(nbufs * sizeof(*bufs));\n\n  if (req->bufs == NULL)\n    return UV_ENOMEM;\n\n  memcpy(req->bufs, bufs, nbufs * sizeof(*bufs));\n\n  req->off = off;\n  POST;\n}\n\n\nvoid uv_fs_req_cleanup(uv_fs_t* req) {\n  if (req == NULL)\n    return;\n\n  /* Only necessary for asychronous requests, i.e., requests with a callback.\n   * Synchronous ones don't copy their arguments and have req->path and\n   * req->new_path pointing to user-owned memory.  UV_FS_MKDTEMP and\n   * UV_FS_MKSTEMP are the exception to the rule, they always allocate memory.\n   */\n  if (req->path != NULL &&\n      (req->cb != NULL ||\n        req->fs_type == UV_FS_MKDTEMP || req->fs_type == UV_FS_MKSTEMP))\n    uv__free((void*) req->path);  /* Memory is shared with req->new_path. */\n\n  req->path = NULL;\n  req->new_path = NULL;\n\n  if (req->fs_type == UV_FS_READDIR && req->ptr != NULL)\n    uv__fs_readdir_cleanup(req);\n\n  if (req->fs_type == UV_FS_SCANDIR && req->ptr != NULL)\n    uv__fs_scandir_cleanup(req);\n\n  if (req->bufs != req->bufsml)\n    uv__free(req->bufs);\n  req->bufs = NULL;\n\n  if (req->fs_type != UV_FS_OPENDIR && req->ptr != &req->statbuf)\n    uv__free(req->ptr);\n  req->ptr = NULL;\n}\n\n\nint uv_fs_copyfile(uv_loop_t* loop,\n                   uv_fs_t* req,\n                   const char* path,\n                   const char* new_path,\n                   int flags,\n                   uv_fs_cb cb) {\n  INIT(COPYFILE);\n\n  if (flags & ~(UV_FS_COPYFILE_EXCL |\n                UV_FS_COPYFILE_FICLONE |\n                UV_FS_COPYFILE_FICLONE_FORCE)) {\n    return UV_EINVAL;\n  }\n\n  PATH2;\n  req->flags = flags;\n  POST;\n}\n\n\nint uv_fs_statfs(uv_loop_t* loop,\n                 uv_fs_t* req,\n                 const char* path,\n                 uv_fs_cb cb) {\n  INIT(STATFS);\n  PATH;\n  POST;\n}\n\nint uv_fs_get_system_error(const uv_fs_t* req) {\n  return -req->result;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Utilities/cmlibuv/src/unix/random-getentropy.c": "/* Copyright libuv contributors. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#include \"uv.h\"\n#include \"internal.h\"\n\n#include <stddef.h>\n#include <dlfcn.h>\n\ntypedef int (*uv__getentropy_cb)(void *, size_t);\n\nstatic uv__getentropy_cb uv__getentropy;\nstatic uv_once_t once = UV_ONCE_INIT;\n\n\nstatic void uv__random_getentropy_init(void) {\n  uv__getentropy = (uv__getentropy_cb) dlsym(RTLD_DEFAULT, \"getentropy\");\n}\n\n\nint uv__random_getentropy(void* buf, size_t buflen) {\n  size_t pos;\n  size_t stride;\n\n  uv_once(&once, uv__random_getentropy_init);\n\n  if (uv__getentropy == NULL)\n    return UV_ENOSYS;\n\n  /* getentropy() returns an error for requests > 256 bytes. */\n  for (pos = 0, stride = 256; pos + stride < buflen; pos += stride)\n    if (uv__getentropy((char *) buf + pos, stride))\n      return UV__ERR(errno);\n\n  if (uv__getentropy((char *) buf + pos, buflen - pos))\n    return UV__ERR(errno);\n\n  return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Utilities/cmlibuv/src/unix/dl.c": "/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#include \"uv.h\"\n#include \"internal.h\"\n\n#include <dlfcn.h>\n#include <errno.h>\n#include <string.h>\n#include <locale.h>\n\nstatic int uv__dlerror(uv_lib_t* lib);\n\n\nint uv_dlopen(const char* filename, uv_lib_t* lib) {\n  dlerror(); /* Reset error status. */\n  lib->errmsg = NULL;\n  lib->handle = dlopen(filename, RTLD_LAZY);\n  return lib->handle ? 0 : uv__dlerror(lib);\n}\n\n\nvoid uv_dlclose(uv_lib_t* lib) {\n  uv__free(lib->errmsg);\n  lib->errmsg = NULL;\n\n  if (lib->handle) {\n    /* Ignore errors. No good way to signal them without leaking memory. */\n    dlclose(lib->handle);\n    lib->handle = NULL;\n  }\n}\n\n\nint uv_dlsym(uv_lib_t* lib, const char* name, void** ptr) {\n  dlerror(); /* Reset error status. */\n  *ptr = dlsym(lib->handle, name);\n  return uv__dlerror(lib);\n}\n\n\nconst char* uv_dlerror(const uv_lib_t* lib) {\n  return lib->errmsg ? lib->errmsg : \"no error\";\n}\n\n\nstatic int uv__dlerror(uv_lib_t* lib) {\n  const char* errmsg;\n\n  uv__free(lib->errmsg);\n\n  errmsg = dlerror();\n\n  if (errmsg) {\n    lib->errmsg = uv__strdup(errmsg);\n    return -1;\n  }\n  else {\n    lib->errmsg = NULL;\n    return 0;\n  }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Utilities/cmlibuv/src/unix/random-getrandom.c": "/* Copyright libuv contributors. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#include \"uv.h\"\n#include \"internal.h\"\n\n#ifdef __linux__\n\n#include \"linux-syscalls.h\"\n\n#define uv__random_getrandom_init() 0\n\n#else  /* !__linux__ */\n\n#include <stddef.h>\n#include <dlfcn.h>\n\ntypedef ssize_t (*uv__getrandom_cb)(void *, size_t, unsigned);\n\nstatic uv__getrandom_cb uv__getrandom;\nstatic uv_once_t once = UV_ONCE_INIT;\n\nstatic void uv__random_getrandom_init_once(void) {\n  uv__getrandom = (uv__getrandom_cb) dlsym(RTLD_DEFAULT, \"getrandom\");\n}\n\nstatic int uv__random_getrandom_init(void) {\n  uv_once(&once, uv__random_getrandom_init_once);\n\n  if (uv__getrandom == NULL)\n    return UV_ENOSYS;\n\n  return 0;\n}\n\n#endif  /* !__linux__ */\n\nint uv__random_getrandom(void* buf, size_t buflen) {\n  ssize_t n;\n  size_t pos;\n  int rc;\n\n  rc = uv__random_getrandom_init();\n  if (rc != 0)\n    return rc;\n\n  for (pos = 0; pos != buflen; pos += n) {\n    do {\n      n = buflen - pos;\n\n      /* Most getrandom() implementations promise that reads <= 256 bytes\n       * will always succeed and won't be interrupted by signals.\n       * It's therefore useful to split it up in smaller reads because\n       * one big read may, in theory, continuously fail with EINTR.\n       */\n      if (n > 256)\n        n = 256;\n\n      n = uv__getrandom((char *) buf + pos, n, 0);\n    } while (n == -1 && errno == EINTR);\n\n    if (n == -1)\n      return UV__ERR(errno);\n\n    if (n == 0)\n      return UV_EIO;\n  }\n\n  return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Utilities/cmlibuv/src/unix/darwin.c": "/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#include \"uv.h\"\n#include \"internal.h\"\n\n#include <assert.h>\n#include <stdint.h>\n#include <errno.h>\n\n#include <dlfcn.h>\n#include <mach/mach.h>\n#include <mach/mach_time.h>\n#include <mach-o/dyld.h> /* _NSGetExecutablePath */\n#include <sys/resource.h>\n#include <sys/sysctl.h>\n#include <unistd.h>  /* sysconf */\n\n#if !TARGET_OS_IPHONE\n#include \"darwin-stub.h\"\n#endif\n\nstatic uv_once_t once = UV_ONCE_INIT;\nstatic uint64_t (*time_func)(void);\nstatic mach_timebase_info_data_t timebase;\n\ntypedef unsigned char UInt8;\n\nint uv__platform_loop_init(uv_loop_t* loop) {\n  loop->cf_state = NULL;\n\n  if (uv__kqueue_init(loop))\n    return UV__ERR(errno);\n\n  return 0;\n}\n\n\nvoid uv__platform_loop_delete(uv_loop_t* loop) {\n  uv__fsevents_loop_delete(loop);\n}\n\n\nstatic void uv__hrtime_init_once(void) {\n  if (KERN_SUCCESS != mach_timebase_info(&timebase))\n    abort();\n\n  time_func = (uint64_t (*)(void)) dlsym(RTLD_DEFAULT, \"mach_continuous_time\");\n  if (time_func == NULL)\n    time_func = mach_absolute_time;\n}\n\n\nuint64_t uv__hrtime(uv_clocktype_t type) {\n  uv_once(&once, uv__hrtime_init_once);\n  return time_func() * timebase.numer / timebase.denom;\n}\n\n\nint uv_exepath(char* buffer, size_t* size) {\n  /* realpath(exepath) may be > PATH_MAX so double it to be on the safe side. */\n  char abspath[PATH_MAX * 2 + 1];\n  char exepath[PATH_MAX + 1];\n  uint32_t exepath_size;\n  size_t abspath_size;\n\n  if (buffer == NULL || size == NULL || *size == 0)\n    return UV_EINVAL;\n\n  exepath_size = sizeof(exepath);\n  if (_NSGetExecutablePath(exepath, &exepath_size))\n    return UV_EIO;\n\n  if (realpath(exepath, abspath) != abspath)\n    return UV__ERR(errno);\n\n  abspath_size = strlen(abspath);\n  if (abspath_size == 0)\n    return UV_EIO;\n\n  *size -= 1;\n  if (*size > abspath_size)\n    *size = abspath_size;\n\n  memcpy(buffer, abspath, *size);\n  buffer[*size] = '\\0';\n\n  return 0;\n}\n\n\nuint64_t uv_get_free_memory(void) {\n  vm_statistics_data_t info;\n  mach_msg_type_number_t count = sizeof(info) / sizeof(integer_t);\n\n  if (host_statistics(mach_host_self(), HOST_VM_INFO,\n                      (host_info_t)&info, &count) != KERN_SUCCESS) {\n    return UV_EINVAL;  /* FIXME(bnoordhuis) Translate error. */\n  }\n\n  return (uint64_t) info.free_count * sysconf(_SC_PAGESIZE);\n}\n\n\nuint64_t uv_get_total_memory(void) {\n  uint64_t info;\n  int which[] = {CTL_HW, HW_MEMSIZE};\n  size_t size = sizeof(info);\n\n  if (sysctl(which, ARRAY_SIZE(which), &info, &size, NULL, 0))\n    return UV__ERR(errno);\n\n  return (uint64_t) info;\n}\n\n\nuint64_t uv_get_constrained_memory(void) {\n  return 0;  /* Memory constraints are unknown. */\n}\n\n\nvoid uv_loadavg(double avg[3]) {\n  struct loadavg info;\n  size_t size = sizeof(info);\n  int which[] = {CTL_VM, VM_LOADAVG};\n\n  if (sysctl(which, ARRAY_SIZE(which), &info, &size, NULL, 0) < 0) return;\n\n  avg[0] = (double) info.ldavg[0] / info.fscale;\n  avg[1] = (double) info.ldavg[1] / info.fscale;\n  avg[2] = (double) info.ldavg[2] / info.fscale;\n}\n\n\nint uv_resident_set_memory(size_t* rss) {\n  mach_msg_type_number_t count;\n  task_basic_info_data_t info;\n  kern_return_t err;\n\n  count = TASK_BASIC_INFO_COUNT;\n  err = task_info(mach_task_self(),\n                  TASK_BASIC_INFO,\n                  (task_info_t) &info,\n                  &count);\n  (void) &err;\n  /* task_info(TASK_BASIC_INFO) cannot really fail. Anything other than\n   * KERN_SUCCESS implies a libuv bug.\n   */\n  assert(err == KERN_SUCCESS);\n  *rss = info.resident_size;\n\n  return 0;\n}\n\n\nint uv_uptime(double* uptime) {\n  time_t now;\n  struct timeval info;\n  size_t size = sizeof(info);\n  static int which[] = {CTL_KERN, KERN_BOOTTIME};\n\n  if (sysctl(which, ARRAY_SIZE(which), &info, &size, NULL, 0))\n    return UV__ERR(errno);\n\n  now = time(NULL);\n  *uptime = now - info.tv_sec;\n\n  return 0;\n}\n\nstatic int uv__get_cpu_speed(uint64_t* speed) {\n  /* IOKit */\n  void (*pIOObjectRelease)(io_object_t);\n  kern_return_t (*pIOMasterPort)(mach_port_t, mach_port_t*);\n  CFMutableDictionaryRef (*pIOServiceMatching)(const char*);\n  kern_return_t (*pIOServiceGetMatchingServices)(mach_port_t,\n                                                 CFMutableDictionaryRef,\n                                                 io_iterator_t*);\n  io_service_t (*pIOIteratorNext)(io_iterator_t);\n  CFTypeRef (*pIORegistryEntryCreateCFProperty)(io_registry_entry_t,\n                                                CFStringRef,\n                                                CFAllocatorRef,\n                                                IOOptionBits);\n\n  /* CoreFoundation */\n  CFStringRef (*pCFStringCreateWithCString)(CFAllocatorRef,\n                                            const char*,\n                                            CFStringEncoding);\n  CFStringEncoding (*pCFStringGetSystemEncoding)(void);\n  UInt8 *(*pCFDataGetBytePtr)(CFDataRef);\n  CFIndex (*pCFDataGetLength)(CFDataRef);\n  void (*pCFDataGetBytes)(CFDataRef, CFRange, UInt8*);\n  void (*pCFRelease)(CFTypeRef);\n\n  void* core_foundation_handle;\n  void* iokit_handle;\n  int err;\n\n  kern_return_t kr;\n  mach_port_t mach_port;\n  io_iterator_t it;\n  io_object_t service;\n\n  mach_port = 0;\n\n  err = UV_ENOENT;\n  core_foundation_handle = dlopen(\"/System/Library/Frameworks/\"\n                                  \"CoreFoundation.framework/\"\n                                  \"Versions/A/CoreFoundation\",\n                                  RTLD_LAZY | RTLD_LOCAL);\n  iokit_handle = dlopen(\"/System/Library/Frameworks/IOKit.framework/\"\n                        \"Versions/A/IOKit\",\n                        RTLD_LAZY | RTLD_LOCAL);\n\n  if (core_foundation_handle == NULL || iokit_handle == NULL)\n    goto out;\n\n#define V(handle, symbol)                                                     \\\n  do {                                                                        \\\n    *(void **)(&p ## symbol) = dlsym((handle), #symbol);                      \\\n    if (p ## symbol == NULL)                                                  \\\n      goto out;                                                               \\\n  }                                                                           \\\n  while (0)\n  V(iokit_handle, IOMasterPort);\n  V(iokit_handle, IOServiceMatching);\n  V(iokit_handle, IOServiceGetMatchingServices);\n  V(iokit_handle, IOIteratorNext);\n  V(iokit_handle, IOObjectRelease);\n  V(iokit_handle, IORegistryEntryCreateCFProperty);\n  V(core_foundation_handle, CFStringCreateWithCString);\n  V(core_foundation_handle, CFStringGetSystemEncoding);\n  V(core_foundation_handle, CFDataGetBytePtr);\n  V(core_foundation_handle, CFDataGetLength);\n  V(core_foundation_handle, CFDataGetBytes);\n  V(core_foundation_handle, CFRelease);\n#undef V\n\n#define S(s) pCFStringCreateWithCString(NULL, (s), kCFStringEncodingUTF8)\n\n  kr = pIOMasterPort(MACH_PORT_NULL, &mach_port);\n  assert(kr == KERN_SUCCESS);\n  CFMutableDictionaryRef classes_to_match\n      = pIOServiceMatching(\"IOPlatformDevice\");\n  kr = pIOServiceGetMatchingServices(mach_port, classes_to_match, &it);\n  assert(kr == KERN_SUCCESS);\n  service = pIOIteratorNext(it);\n\n  CFStringRef device_type_str = S(\"device_type\");\n  CFStringRef clock_frequency_str = S(\"clock-frequency\");\n\n  while (service != 0) {\n    CFDataRef data;\n    data = pIORegistryEntryCreateCFProperty(service,\n                                            device_type_str,\n                                            NULL,\n                                            0);\n    if (data) {\n      const UInt8* raw = pCFDataGetBytePtr(data);\n      if (strncmp((char*)raw, \"cpu\", 3) == 0 ||\n          strncmp((char*)raw, \"processor\", 9) == 0) {\n        CFDataRef freq_ref;\n        freq_ref = pIORegistryEntryCreateCFProperty(service,\n                                                    clock_frequency_str,\n                                                    NULL,\n                                                    0);\n        if (freq_ref) {\n          uint32_t freq;\n          CFIndex len = pCFDataGetLength(freq_ref);\n          CFRange range;\n          range.location = 0;\n          range.length = len;\n\n          pCFDataGetBytes(freq_ref, range, (UInt8*)&freq);\n          *speed = freq;\n          pCFRelease(freq_ref);\n          pCFRelease(data);\n          break;\n        }\n      }\n      pCFRelease(data);\n    }\n\n    service = pIOIteratorNext(it);\n  }\n\n  pIOObjectRelease(it);\n\n  err = 0;\nout:\n  if (core_foundation_handle != NULL)\n    dlclose(core_foundation_handle);\n\n  if (iokit_handle != NULL)\n    dlclose(iokit_handle);\n\n  mach_port_deallocate(mach_task_self(), mach_port);\n\n  return err;\n}\n\nint uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count) {\n  unsigned int ticks = (unsigned int)sysconf(_SC_CLK_TCK),\n               multiplier = ((uint64_t)1000L / ticks);\n  char model[512];\n  size_t size;\n  unsigned int i;\n  natural_t numcpus;\n  mach_msg_type_number_t msg_type;\n  processor_cpu_load_info_data_t *info;\n  uv_cpu_info_t* cpu_info;\n  uint64_t cpuspeed;\n  int err;\n\n  size = sizeof(model);\n  if (sysctlbyname(\"machdep.cpu.brand_string\", &model, &size, NULL, 0) &&\n      sysctlbyname(\"hw.model\", &model, &size, NULL, 0)) {\n    return UV__ERR(errno);\n  }\n\n  err = uv__get_cpu_speed(&cpuspeed);\n  if (err < 0)\n    return err;\n\n  if (host_processor_info(mach_host_self(), PROCESSOR_CPU_LOAD_INFO, &numcpus,\n                          (processor_info_array_t*)&info,\n                          &msg_type) != KERN_SUCCESS) {\n    return UV_EINVAL;  /* FIXME(bnoordhuis) Translate error. */\n  }\n\n  *cpu_infos = uv__malloc(numcpus * sizeof(**cpu_infos));\n  if (!(*cpu_infos)) {\n    vm_deallocate(mach_task_self(), (vm_address_t)info, msg_type);\n    return UV_ENOMEM;\n  }\n\n  *count = numcpus;\n\n  for (i = 0; i < numcpus; i++) {\n    cpu_info = &(*cpu_infos)[i];\n\n    cpu_info->cpu_times.user = (uint64_t)(info[i].cpu_ticks[0]) * multiplier;\n    cpu_info->cpu_times.nice = (uint64_t)(info[i].cpu_ticks[3]) * multiplier;\n    cpu_info->cpu_times.sys = (uint64_t)(info[i].cpu_ticks[1]) * multiplier;\n    cpu_info->cpu_times.idle = (uint64_t)(info[i].cpu_ticks[2]) * multiplier;\n    cpu_info->cpu_times.irq = 0;\n\n    cpu_info->model = uv__strdup(model);\n    cpu_info->speed = cpuspeed/1000000;\n  }\n  vm_deallocate(mach_task_self(), (vm_address_t)info, msg_type);\n\n  return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Utilities/cmlibuv/include/uv.h": "/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n/* See https://github.com/libuv/libuv#documentation for documentation. */\n\n#ifndef UV_H\n#define UV_H\n\n/* Include KWSys Large File Support configuration. */\n#include <cmsys/Configure.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#if defined(BUILDING_UV_SHARED) && defined(USING_UV_SHARED)\n#error \"Define either BUILDING_UV_SHARED or USING_UV_SHARED, not both.\"\n#endif\n\n#ifdef _WIN32\n  /* Windows - set up dll import/export decorators. */\n# if defined(BUILDING_UV_SHARED)\n    /* Building shared library. */\n#   define UV_EXTERN __declspec(dllexport)\n# elif defined(USING_UV_SHARED)\n    /* Using shared library. */\n#   define UV_EXTERN __declspec(dllimport)\n# else\n    /* Building static library. */\n#   define UV_EXTERN /* nothing */\n# endif\n#elif __GNUC__ >= 4\n# define UV_EXTERN __attribute__((visibility(\"default\")))\n#else\n# define UV_EXTERN /* nothing */\n#endif\n\n#include \"uv/errno.h\"\n#include \"uv/version.h\"\n#include <stddef.h>\n#include <stdio.h>\n\n#if defined(_MSC_VER) && _MSC_VER < 1600\n# include \"uv/stdint-msvc2008.h\"\n#else\n# include <stdint.h>\n#endif\n\n#if defined(_WIN32)\n# include \"uv/win.h\"\n#else\n# include \"uv/unix.h\"\n#endif\n\n/* Expand this list if necessary. */\n#define UV_ERRNO_MAP(XX)                                                      \\\n  XX(E2BIG, \"argument list too long\")                                         \\\n  XX(EACCES, \"permission denied\")                                             \\\n  XX(EADDRINUSE, \"address already in use\")                                    \\\n  XX(EADDRNOTAVAIL, \"address not available\")                                  \\\n  XX(EAFNOSUPPORT, \"address family not supported\")                            \\\n  XX(EAGAIN, \"resource temporarily unavailable\")                              \\\n  XX(EAI_ADDRFAMILY, \"address family not supported\")                          \\\n  XX(EAI_AGAIN, \"temporary failure\")                                          \\\n  XX(EAI_BADFLAGS, \"bad ai_flags value\")                                      \\\n  XX(EAI_BADHINTS, \"invalid value for hints\")                                 \\\n  XX(EAI_CANCELED, \"request canceled\")                                        \\\n  XX(EAI_FAIL, \"permanent failure\")                                           \\\n  XX(EAI_FAMILY, \"ai_family not supported\")                                   \\\n  XX(EAI_MEMORY, \"out of memory\")                                             \\\n  XX(EAI_NODATA, \"no address\")                                                \\\n  XX(EAI_NONAME, \"unknown node or service\")                                   \\\n  XX(EAI_OVERFLOW, \"argument buffer overflow\")                                \\\n  XX(EAI_PROTOCOL, \"resolved protocol is unknown\")                            \\\n  XX(EAI_SERVICE, \"service not available for socket type\")                    \\\n  XX(EAI_SOCKTYPE, \"socket type not supported\")                               \\\n  XX(EALREADY, \"connection already in progress\")                              \\\n  XX(EBADF, \"bad file descriptor\")                                            \\\n  XX(EBUSY, \"resource busy or locked\")                                        \\\n  XX(ECANCELED, \"operation canceled\")                                         \\\n  XX(ECHARSET, \"invalid Unicode character\")                                   \\\n  XX(ECONNABORTED, \"software caused connection abort\")                        \\\n  XX(ECONNREFUSED, \"connection refused\")                                      \\\n  XX(ECONNRESET, \"connection reset by peer\")                                  \\\n  XX(EDESTADDRREQ, \"destination address required\")                            \\\n  XX(EEXIST, \"file already exists\")                                           \\\n  XX(EFAULT, \"bad address in system call argument\")                           \\\n  XX(EFBIG, \"file too large\")                                                 \\\n  XX(EHOSTUNREACH, \"host is unreachable\")                                     \\\n  XX(EINTR, \"interrupted system call\")                                        \\\n  XX(EINVAL, \"invalid argument\")                                              \\\n  XX(EIO, \"i/o error\")                                                        \\\n  XX(EISCONN, \"socket is already connected\")                                  \\\n  XX(EISDIR, \"illegal operation on a directory\")                              \\\n  XX(ELOOP, \"too many symbolic links encountered\")                            \\\n  XX(EMFILE, \"too many open files\")                                           \\\n  XX(EMSGSIZE, \"message too long\")                                            \\\n  XX(ENAMETOOLONG, \"name too long\")                                           \\\n  XX(ENETDOWN, \"network is down\")                                             \\\n  XX(ENETUNREACH, \"network is unreachable\")                                   \\\n  XX(ENFILE, \"file table overflow\")                                           \\\n  XX(ENOBUFS, \"no buffer space available\")                                    \\\n  XX(ENODEV, \"no such device\")                                                \\\n  XX(ENOENT, \"no such file or directory\")                                     \\\n  XX(ENOMEM, \"not enough memory\")                                             \\\n  XX(ENONET, \"machine is not on the network\")                                 \\\n  XX(ENOPROTOOPT, \"protocol not available\")                                   \\\n  XX(ENOSPC, \"no space left on device\")                                       \\\n  XX(ENOSYS, \"function not implemented\")                                      \\\n  XX(ENOTCONN, \"socket is not connected\")                                     \\\n  XX(ENOTDIR, \"not a directory\")                                              \\\n  XX(ENOTEMPTY, \"directory not empty\")                                        \\\n  XX(ENOTSOCK, \"socket operation on non-socket\")                              \\\n  XX(ENOTSUP, \"operation not supported on socket\")                            \\\n  XX(EPERM, \"operation not permitted\")                                        \\\n  XX(EPIPE, \"broken pipe\")                                                    \\\n  XX(EPROTO, \"protocol error\")                                                \\\n  XX(EPROTONOSUPPORT, \"protocol not supported\")                               \\\n  XX(EPROTOTYPE, \"protocol wrong type for socket\")                            \\\n  XX(ERANGE, \"result too large\")                                              \\\n  XX(EROFS, \"read-only file system\")                                          \\\n  XX(ESHUTDOWN, \"cannot send after transport endpoint shutdown\")              \\\n  XX(ESPIPE, \"invalid seek\")                                                  \\\n  XX(ESRCH, \"no such process\")                                                \\\n  XX(ETIMEDOUT, \"connection timed out\")                                       \\\n  XX(ETXTBSY, \"text file is busy\")                                            \\\n  XX(EXDEV, \"cross-device link not permitted\")                                \\\n  XX(UNKNOWN, \"unknown error\")                                                \\\n  XX(EOF, \"end of file\")                                                      \\\n  XX(ENXIO, \"no such device or address\")                                      \\\n  XX(EMLINK, \"too many links\")                                                \\\n  XX(EHOSTDOWN, \"host is down\")                                               \\\n  XX(EREMOTEIO, \"remote I/O error\")                                           \\\n  XX(ENOTTY, \"inappropriate ioctl for device\")                                \\\n  XX(EFTYPE, \"inappropriate file type or format\")                             \\\n  XX(EILSEQ, \"illegal byte sequence\")                                         \\\n\n#define UV_HANDLE_TYPE_MAP(XX)                                                \\\n  XX(ASYNC, async)                                                            \\\n  XX(CHECK, check)                                                            \\\n  XX(FS_EVENT, fs_event)                                                      \\\n  XX(FS_POLL, fs_poll)                                                        \\\n  XX(HANDLE, handle)                                                          \\\n  XX(IDLE, idle)                                                              \\\n  XX(NAMED_PIPE, pipe)                                                        \\\n  XX(POLL, poll)                                                              \\\n  XX(PREPARE, prepare)                                                        \\\n  XX(PROCESS, process)                                                        \\\n  XX(STREAM, stream)                                                          \\\n  XX(TCP, tcp)                                                                \\\n  XX(TIMER, timer)                                                            \\\n  XX(TTY, tty)                                                                \\\n  XX(UDP, udp)                                                                \\\n  XX(SIGNAL, signal)                                                          \\\n\n#define UV_REQ_TYPE_MAP(XX)                                                   \\\n  XX(REQ, req)                                                                \\\n  XX(CONNECT, connect)                                                        \\\n  XX(WRITE, write)                                                            \\\n  XX(SHUTDOWN, shutdown)                                                      \\\n  XX(UDP_SEND, udp_send)                                                      \\\n  XX(FS, fs)                                                                  \\\n  XX(WORK, work)                                                              \\\n  XX(GETADDRINFO, getaddrinfo)                                                \\\n  XX(GETNAMEINFO, getnameinfo)                                                \\\n  XX(RANDOM, random)                                                          \\\n\ntypedef enum {\n#define XX(code, _) UV_ ## code = UV__ ## code,\n  UV_ERRNO_MAP(XX)\n#undef XX\n  UV_ERRNO_MAX = UV__EOF - 1\n} uv_errno_t;\n\ntypedef enum {\n  UV_UNKNOWN_HANDLE = 0,\n#define XX(uc, lc) UV_##uc,\n  UV_HANDLE_TYPE_MAP(XX)\n#undef XX\n  UV_FILE,\n  UV_HANDLE_TYPE_MAX\n} uv_handle_type;\n\ntypedef enum {\n  UV_UNKNOWN_REQ = 0,\n#define XX(uc, lc) UV_##uc,\n  UV_REQ_TYPE_MAP(XX)\n#undef XX\n  UV_REQ_TYPE_PRIVATE\n  UV_REQ_TYPE_MAX\n} uv_req_type;\n\n\n/* Handle types. */\ntypedef struct uv_loop_s uv_loop_t;\ntypedef struct uv_handle_s uv_handle_t;\ntypedef struct uv_dir_s uv_dir_t;\ntypedef struct uv_stream_s uv_stream_t;\ntypedef struct uv_tcp_s uv_tcp_t;\ntypedef struct uv_udp_s uv_udp_t;\ntypedef struct uv_pipe_s uv_pipe_t;\ntypedef struct uv_tty_s uv_tty_t;\ntypedef struct uv_poll_s uv_poll_t;\ntypedef struct uv_timer_s uv_timer_t;\ntypedef struct uv_prepare_s uv_prepare_t;\ntypedef struct uv_check_s uv_check_t;\ntypedef struct uv_idle_s uv_idle_t;\ntypedef struct uv_async_s uv_async_t;\ntypedef struct uv_process_s uv_process_t;\ntypedef struct uv_fs_event_s uv_fs_event_t;\ntypedef struct uv_fs_poll_s uv_fs_poll_t;\ntypedef struct uv_signal_s uv_signal_t;\n\n/* Request types. */\ntypedef struct uv_req_s uv_req_t;\ntypedef struct uv_getaddrinfo_s uv_getaddrinfo_t;\ntypedef struct uv_getnameinfo_s uv_getnameinfo_t;\ntypedef struct uv_shutdown_s uv_shutdown_t;\ntypedef struct uv_write_s uv_write_t;\ntypedef struct uv_connect_s uv_connect_t;\ntypedef struct uv_udp_send_s uv_udp_send_t;\ntypedef struct uv_fs_s uv_fs_t;\ntypedef struct uv_work_s uv_work_t;\ntypedef struct uv_random_s uv_random_t;\n\n/* None of the above. */\ntypedef struct uv_env_item_s uv_env_item_t;\ntypedef struct uv_cpu_info_s uv_cpu_info_t;\ntypedef struct uv_interface_address_s uv_interface_address_t;\ntypedef struct uv_dirent_s uv_dirent_t;\ntypedef struct uv_passwd_s uv_passwd_t;\ntypedef struct uv_utsname_s uv_utsname_t;\ntypedef struct uv_statfs_s uv_statfs_t;\n\ntypedef enum {\n  UV_LOOP_BLOCK_SIGNAL = 0,\n  UV_METRICS_IDLE_TIME\n} uv_loop_option;\n\ntypedef enum {\n  UV_RUN_DEFAULT = 0,\n  UV_RUN_ONCE,\n  UV_RUN_NOWAIT\n} uv_run_mode;\n\n\nUV_EXTERN unsigned int uv_version(void);\nUV_EXTERN const char* uv_version_string(void);\n\ntypedef void* (*uv_malloc_func)(size_t size);\ntypedef void* (*uv_realloc_func)(void* ptr, size_t size);\ntypedef void* (*uv_calloc_func)(size_t count, size_t size);\ntypedef void (*uv_free_func)(void* ptr);\n\nUV_EXTERN void uv_library_shutdown(void);\n\nUV_EXTERN int uv_replace_allocator(uv_malloc_func malloc_func,\n                                   uv_realloc_func realloc_func,\n                                   uv_calloc_func calloc_func,\n                                   uv_free_func free_func);\n\nUV_EXTERN uv_loop_t* uv_default_loop(void);\nUV_EXTERN int uv_loop_init(uv_loop_t* loop);\nUV_EXTERN int uv_loop_close(uv_loop_t* loop);\n/*\n * NOTE:\n *  This function is DEPRECATED (to be removed after 0.12), users should\n *  allocate the loop manually and use uv_loop_init instead.\n */\nUV_EXTERN uv_loop_t* uv_loop_new(void);\n/*\n * NOTE:\n *  This function is DEPRECATED (to be removed after 0.12). Users should use\n *  uv_loop_close and free the memory manually instead.\n */\nUV_EXTERN void uv_loop_delete(uv_loop_t*);\nUV_EXTERN size_t uv_loop_size(void);\nUV_EXTERN int uv_loop_alive(const uv_loop_t* loop);\nUV_EXTERN int uv_loop_configure(uv_loop_t* loop, uv_loop_option option, ...);\nUV_EXTERN int uv_loop_fork(uv_loop_t* loop);\n\nUV_EXTERN int uv_run(uv_loop_t*, uv_run_mode mode);\nUV_EXTERN void uv_stop(uv_loop_t*);\n\nUV_EXTERN void uv_ref(uv_handle_t*);\nUV_EXTERN void uv_unref(uv_handle_t*);\nUV_EXTERN int uv_has_ref(const uv_handle_t*);\n\nUV_EXTERN void uv_update_time(uv_loop_t*);\nUV_EXTERN uint64_t uv_now(const uv_loop_t*);\n\nUV_EXTERN int uv_backend_fd(const uv_loop_t*);\nUV_EXTERN int uv_backend_timeout(const uv_loop_t*);\n\ntypedef void (*uv_alloc_cb)(uv_handle_t* handle,\n                            size_t suggested_size,\n                            uv_buf_t* buf);\ntypedef void (*uv_read_cb)(uv_stream_t* stream,\n                           ssize_t nread,\n                           const uv_buf_t* buf);\ntypedef void (*uv_write_cb)(uv_write_t* req, int status);\ntypedef void (*uv_connect_cb)(uv_connect_t* req, int status);\ntypedef void (*uv_shutdown_cb)(uv_shutdown_t* req, int status);\ntypedef void (*uv_connection_cb)(uv_stream_t* server, int status);\ntypedef void (*uv_close_cb)(uv_handle_t* handle);\ntypedef void (*uv_poll_cb)(uv_poll_t* handle, int status, int events);\ntypedef void (*uv_timer_cb)(uv_timer_t* handle);\ntypedef void (*uv_async_cb)(uv_async_t* handle);\ntypedef void (*uv_prepare_cb)(uv_prepare_t* handle);\ntypedef void (*uv_check_cb)(uv_check_t* handle);\ntypedef void (*uv_idle_cb)(uv_idle_t* handle);\ntypedef void (*uv_exit_cb)(uv_process_t*, int64_t exit_status, int term_signal);\ntypedef void (*uv_walk_cb)(uv_handle_t* handle, void* arg);\ntypedef void (*uv_fs_cb)(uv_fs_t* req);\ntypedef void (*uv_work_cb)(uv_work_t* req);\ntypedef void (*uv_after_work_cb)(uv_work_t* req, int status);\ntypedef void (*uv_getaddrinfo_cb)(uv_getaddrinfo_t* req,\n                                  int status,\n                                  struct addrinfo* res);\ntypedef void (*uv_getnameinfo_cb)(uv_getnameinfo_t* req,\n                                  int status,\n                                  const char* hostname,\n                                  const char* service);\ntypedef void (*uv_random_cb)(uv_random_t* req,\n                             int status,\n                             void* buf,\n                             size_t buflen);\n\ntypedef struct {\n  long tv_sec;\n  long tv_nsec;\n} uv_timespec_t;\n\n\ntypedef struct {\n  uint64_t st_dev;\n  uint64_t st_mode;\n  uint64_t st_nlink;\n  uint64_t st_uid;\n  uint64_t st_gid;\n  uint64_t st_rdev;\n  uint64_t st_ino;\n  uint64_t st_size;\n  uint64_t st_blksize;\n  uint64_t st_blocks;\n  uint64_t st_flags;\n  uint64_t st_gen;\n  uv_timespec_t st_atim;\n  uv_timespec_t st_mtim;\n  uv_timespec_t st_ctim;\n  uv_timespec_t st_birthtim;\n} uv_stat_t;\n\n\ntypedef void (*uv_fs_event_cb)(uv_fs_event_t* handle,\n                               const char* filename,\n                               int events,\n                               int status);\n\ntypedef void (*uv_fs_poll_cb)(uv_fs_poll_t* handle,\n                              int status,\n                              const uv_stat_t* prev,\n                              const uv_stat_t* curr);\n\ntypedef void (*uv_signal_cb)(uv_signal_t* handle, int signum);\n\n\ntypedef enum {\n  UV_LEAVE_GROUP = 0,\n  UV_JOIN_GROUP\n} uv_membership;\n\n\nUV_EXTERN int uv_translate_sys_error(int sys_errno);\n\nUV_EXTERN const char* uv_strerror(int err);\nUV_EXTERN char* uv_strerror_r(int err, char* buf, size_t buflen);\n\nUV_EXTERN const char* uv_err_name(int err);\nUV_EXTERN char* uv_err_name_r(int err, char* buf, size_t buflen);\n\n\n#define UV_REQ_FIELDS                                                         \\\n  /* public */                                                                \\\n  void* data;                                                                 \\\n  /* read-only */                                                             \\\n  uv_req_type type;                                                           \\\n  /* private */                                                               \\\n  void* reserved[6];                                                          \\\n  UV_REQ_PRIVATE_FIELDS                                                       \\\n\n/* Abstract base class of all requests. */\nstruct uv_req_s {\n  UV_REQ_FIELDS\n};\n\n\n/* Platform-specific request types. */\nUV_PRIVATE_REQ_TYPES\n\n\nUV_EXTERN int uv_shutdown(uv_shutdown_t* req,\n                          uv_stream_t* handle,\n                          uv_shutdown_cb cb);\n\nstruct uv_shutdown_s {\n  UV_REQ_FIELDS\n  uv_stream_t* handle;\n  uv_shutdown_cb cb;\n  UV_SHUTDOWN_PRIVATE_FIELDS\n};\n\n\n#define UV_HANDLE_FIELDS                                                      \\\n  /* public */                                                                \\\n  void* data;                                                                 \\\n  /* read-only */                                                             \\\n  uv_loop_t* loop;                                                            \\\n  uv_handle_type type;                                                        \\\n  /* private */                                                               \\\n  uv_close_cb close_cb;                                                       \\\n  void* handle_queue[2];                                                      \\\n  union {                                                                     \\\n    int fd;                                                                   \\\n    void* reserved[4];                                                        \\\n  } u;                                                                        \\\n  UV_HANDLE_PRIVATE_FIELDS                                                    \\\n\n/* The abstract base class of all handles. */\nstruct uv_handle_s {\n  UV_HANDLE_FIELDS\n};\n\nUV_EXTERN size_t uv_handle_size(uv_handle_type type);\nUV_EXTERN uv_handle_type uv_handle_get_type(const uv_handle_t* handle);\nUV_EXTERN const char* uv_handle_type_name(uv_handle_type type);\nUV_EXTERN void* uv_handle_get_data(const uv_handle_t* handle);\nUV_EXTERN uv_loop_t* uv_handle_get_loop(const uv_handle_t* handle);\nUV_EXTERN void uv_handle_set_data(uv_handle_t* handle, void* data);\n\nUV_EXTERN size_t uv_req_size(uv_req_type type);\nUV_EXTERN void* uv_req_get_data(const uv_req_t* req);\nUV_EXTERN void uv_req_set_data(uv_req_t* req, void* data);\nUV_EXTERN uv_req_type uv_req_get_type(const uv_req_t* req);\nUV_EXTERN const char* uv_req_type_name(uv_req_type type);\n\nUV_EXTERN int uv_is_active(const uv_handle_t* handle);\n\nUV_EXTERN void uv_walk(uv_loop_t* loop, uv_walk_cb walk_cb, void* arg);\n\n/* Helpers for ad hoc debugging, no API/ABI stability guaranteed. */\nUV_EXTERN void uv_print_all_handles(uv_loop_t* loop, FILE* stream);\nUV_EXTERN void uv_print_active_handles(uv_loop_t* loop, FILE* stream);\n\nUV_EXTERN void uv_close(uv_handle_t* handle, uv_close_cb close_cb);\n\nUV_EXTERN int uv_send_buffer_size(uv_handle_t* handle, int* value);\nUV_EXTERN int uv_recv_buffer_size(uv_handle_t* handle, int* value);\n\nUV_EXTERN int uv_fileno(const uv_handle_t* handle, uv_os_fd_t* fd);\n\nUV_EXTERN uv_buf_t uv_buf_init(char* base, unsigned int len);\n\n\n#define UV_STREAM_FIELDS                                                      \\\n  /* number of bytes queued for writing */                                    \\\n  size_t write_queue_size;                                                    \\\n  uv_alloc_cb alloc_cb;                                                       \\\n  uv_read_cb read_cb;                                                         \\\n  /* private */                                                               \\\n  UV_STREAM_PRIVATE_FIELDS\n\n/*\n * uv_stream_t is a subclass of uv_handle_t.\n *\n * uv_stream is an abstract class.\n *\n * uv_stream_t is the parent class of uv_tcp_t, uv_pipe_t and uv_tty_t.\n */\nstruct uv_stream_s {\n  UV_HANDLE_FIELDS\n  UV_STREAM_FIELDS\n};\n\nUV_EXTERN size_t uv_stream_get_write_queue_size(const uv_stream_t* stream);\n\nUV_EXTERN int uv_listen(uv_stream_t* stream, int backlog, uv_connection_cb cb);\nUV_EXTERN int uv_accept(uv_stream_t* server, uv_stream_t* client);\n\nUV_EXTERN int uv_read_start(uv_stream_t*,\n                            uv_alloc_cb alloc_cb,\n                            uv_read_cb read_cb);\nUV_EXTERN int uv_read_stop(uv_stream_t*);\n\nUV_EXTERN int uv_write(uv_write_t* req,\n                       uv_stream_t* handle,\n                       const uv_buf_t bufs[],\n                       unsigned int nbufs,\n                       uv_write_cb cb);\nUV_EXTERN int uv_write2(uv_write_t* req,\n                        uv_stream_t* handle,\n                        const uv_buf_t bufs[],\n                        unsigned int nbufs,\n                        uv_stream_t* send_handle,\n                        uv_write_cb cb);\nUV_EXTERN int uv_try_write(uv_stream_t* handle,\n                           const uv_buf_t bufs[],\n                           unsigned int nbufs);\n\n/* uv_write_t is a subclass of uv_req_t. */\nstruct uv_write_s {\n  UV_REQ_FIELDS\n  uv_write_cb cb;\n  uv_stream_t* send_handle; /* TODO: make private and unix-only in v2.x. */\n  uv_stream_t* handle;\n  UV_WRITE_PRIVATE_FIELDS\n};\n\n\nUV_EXTERN int uv_is_readable(const uv_stream_t* handle);\nUV_EXTERN int uv_is_writable(const uv_stream_t* handle);\n\nUV_EXTERN int uv_stream_set_blocking(uv_stream_t* handle, int blocking);\n\nUV_EXTERN int uv_is_closing(const uv_handle_t* handle);\n\n\n/*\n * uv_tcp_t is a subclass of uv_stream_t.\n *\n * Represents a TCP stream or TCP server.\n */\nstruct uv_tcp_s {\n  UV_HANDLE_FIELDS\n  UV_STREAM_FIELDS\n  UV_TCP_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_tcp_init(uv_loop_t*, uv_tcp_t* handle);\nUV_EXTERN int uv_tcp_init_ex(uv_loop_t*, uv_tcp_t* handle, unsigned int flags);\nUV_EXTERN int uv_tcp_open(uv_tcp_t* handle, uv_os_sock_t sock);\nUV_EXTERN int uv_tcp_nodelay(uv_tcp_t* handle, int enable);\nUV_EXTERN int uv_tcp_keepalive(uv_tcp_t* handle,\n                               int enable,\n                               unsigned int delay);\nUV_EXTERN int uv_tcp_simultaneous_accepts(uv_tcp_t* handle, int enable);\n\nenum uv_tcp_flags {\n  /* Used with uv_tcp_bind, when an IPv6 address is used. */\n  UV_TCP_IPV6ONLY = 1\n};\n\nUV_EXTERN int uv_tcp_bind(uv_tcp_t* handle,\n                          const struct sockaddr* addr,\n                          unsigned int flags);\nUV_EXTERN int uv_tcp_getsockname(const uv_tcp_t* handle,\n                                 struct sockaddr* name,\n                                 int* namelen);\nUV_EXTERN int uv_tcp_getpeername(const uv_tcp_t* handle,\n                                 struct sockaddr* name,\n                                 int* namelen);\nUV_EXTERN int uv_tcp_close_reset(uv_tcp_t* handle, uv_close_cb close_cb);\nUV_EXTERN int uv_tcp_connect(uv_connect_t* req,\n                             uv_tcp_t* handle,\n                             const struct sockaddr* addr,\n                             uv_connect_cb cb);\n\n/* uv_connect_t is a subclass of uv_req_t. */\nstruct uv_connect_s {\n  UV_REQ_FIELDS\n  uv_connect_cb cb;\n  uv_stream_t* handle;\n  UV_CONNECT_PRIVATE_FIELDS\n};\n\n\n/*\n * UDP support.\n */\n\nenum uv_udp_flags {\n  /* Disables dual stack mode. */\n  UV_UDP_IPV6ONLY = 1,\n  /*\n   * Indicates message was truncated because read buffer was too small. The\n   * remainder was discarded by the OS. Used in uv_udp_recv_cb.\n   */\n  UV_UDP_PARTIAL = 2,\n  /*\n   * Indicates if SO_REUSEADDR will be set when binding the handle.\n   * This sets the SO_REUSEPORT socket flag on the BSDs and OS X. On other\n   * Unix platforms, it sets the SO_REUSEADDR flag.  What that means is that\n   * multiple threads or processes can bind to the same address without error\n   * (provided they all set the flag) but only the last one to bind will receive\n   * any traffic, in effect \"stealing\" the port from the previous listener.\n   */\n  UV_UDP_REUSEADDR = 4,\n  /*\n   * Indicates that the message was received by recvmmsg, so the buffer provided\n   * must not be freed by the recv_cb callback.\n   */\n  UV_UDP_MMSG_CHUNK = 8,\n  /*\n   * Indicates that the buffer provided has been fully utilized by recvmmsg and\n   * that it should now be freed by the recv_cb callback. When this flag is set\n   * in uv_udp_recv_cb, nread will always be 0 and addr will always be NULL.\n   */\n  UV_UDP_MMSG_FREE = 16,\n\n  /*\n   * Indicates that recvmmsg should be used, if available.\n   */\n  UV_UDP_RECVMMSG = 256\n};\n\ntypedef void (*uv_udp_send_cb)(uv_udp_send_t* req, int status);\ntypedef void (*uv_udp_recv_cb)(uv_udp_t* handle,\n                               ssize_t nread,\n                               const uv_buf_t* buf,\n                               const struct sockaddr* addr,\n                               unsigned flags);\n\n/* uv_udp_t is a subclass of uv_handle_t. */\nstruct uv_udp_s {\n  UV_HANDLE_FIELDS\n  /* read-only */\n  /*\n   * Number of bytes queued for sending. This field strictly shows how much\n   * information is currently queued.\n   */\n  size_t send_queue_size;\n  /*\n   * Number of send requests currently in the queue awaiting to be processed.\n   */\n  size_t send_queue_count;\n  UV_UDP_PRIVATE_FIELDS\n};\n\n/* uv_udp_send_t is a subclass of uv_req_t. */\nstruct uv_udp_send_s {\n  UV_REQ_FIELDS\n  uv_udp_t* handle;\n  uv_udp_send_cb cb;\n  UV_UDP_SEND_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_udp_init(uv_loop_t*, uv_udp_t* handle);\nUV_EXTERN int uv_udp_init_ex(uv_loop_t*, uv_udp_t* handle, unsigned int flags);\nUV_EXTERN int uv_udp_open(uv_udp_t* handle, uv_os_sock_t sock);\nUV_EXTERN int uv_udp_bind(uv_udp_t* handle,\n                          const struct sockaddr* addr,\n                          unsigned int flags);\nUV_EXTERN int uv_udp_connect(uv_udp_t* handle, const struct sockaddr* addr);\n\nUV_EXTERN int uv_udp_getpeername(const uv_udp_t* handle,\n                                 struct sockaddr* name,\n                                 int* namelen);\nUV_EXTERN int uv_udp_getsockname(const uv_udp_t* handle,\n                                 struct sockaddr* name,\n                                 int* namelen);\nUV_EXTERN int uv_udp_set_membership(uv_udp_t* handle,\n                                    const char* multicast_addr,\n                                    const char* interface_addr,\n                                    uv_membership membership);\nUV_EXTERN int uv_udp_set_source_membership(uv_udp_t* handle,\n                                           const char* multicast_addr,\n                                           const char* interface_addr,\n                                           const char* source_addr,\n                                           uv_membership membership);\nUV_EXTERN int uv_udp_set_multicast_loop(uv_udp_t* handle, int on);\nUV_EXTERN int uv_udp_set_multicast_ttl(uv_udp_t* handle, int ttl);\nUV_EXTERN int uv_udp_set_multicast_interface(uv_udp_t* handle,\n                                             const char* interface_addr);\nUV_EXTERN int uv_udp_set_broadcast(uv_udp_t* handle, int on);\nUV_EXTERN int uv_udp_set_ttl(uv_udp_t* handle, int ttl);\nUV_EXTERN int uv_udp_send(uv_udp_send_t* req,\n                          uv_udp_t* handle,\n                          const uv_buf_t bufs[],\n                          unsigned int nbufs,\n                          const struct sockaddr* addr,\n                          uv_udp_send_cb send_cb);\nUV_EXTERN int uv_udp_try_send(uv_udp_t* handle,\n                              const uv_buf_t bufs[],\n                              unsigned int nbufs,\n                              const struct sockaddr* addr);\nUV_EXTERN int uv_udp_recv_start(uv_udp_t* handle,\n                                uv_alloc_cb alloc_cb,\n                                uv_udp_recv_cb recv_cb);\nUV_EXTERN int uv_udp_using_recvmmsg(const uv_udp_t* handle);\nUV_EXTERN int uv_udp_recv_stop(uv_udp_t* handle);\nUV_EXTERN size_t uv_udp_get_send_queue_size(const uv_udp_t* handle);\nUV_EXTERN size_t uv_udp_get_send_queue_count(const uv_udp_t* handle);\n\n\n/*\n * uv_tty_t is a subclass of uv_stream_t.\n *\n * Representing a stream for the console.\n */\nstruct uv_tty_s {\n  UV_HANDLE_FIELDS\n  UV_STREAM_FIELDS\n  UV_TTY_PRIVATE_FIELDS\n};\n\ntypedef enum {\n  /* Initial/normal terminal mode */\n  UV_TTY_MODE_NORMAL,\n  /* Raw input mode (On Windows, ENABLE_WINDOW_INPUT is also enabled) */\n  UV_TTY_MODE_RAW,\n  /* Binary-safe I/O mode for IPC (Unix-only) */\n  UV_TTY_MODE_IO\n} uv_tty_mode_t;\n\ntypedef enum {\n  /*\n   * The console supports handling of virtual terminal sequences\n   * (Windows10 new console, ConEmu)\n   */\n  UV_TTY_SUPPORTED,\n  /* The console cannot process the virtual terminal sequence.  (Legacy\n   * console)\n   */\n  UV_TTY_UNSUPPORTED\n} uv_tty_vtermstate_t;\n\n\nUV_EXTERN int uv_tty_init(uv_loop_t*, uv_tty_t*, uv_file fd, int readable);\nUV_EXTERN int uv_tty_set_mode(uv_tty_t*, uv_tty_mode_t mode);\nUV_EXTERN int uv_tty_reset_mode(void);\nUV_EXTERN int uv_tty_get_winsize(uv_tty_t*, int* width, int* height);\nUV_EXTERN void uv_tty_set_vterm_state(uv_tty_vtermstate_t state);\nUV_EXTERN int uv_tty_get_vterm_state(uv_tty_vtermstate_t* state);\n\n#ifdef __cplusplus\nextern \"C++\" {\n\ninline int uv_tty_set_mode(uv_tty_t* handle, int mode) {\n  return uv_tty_set_mode(handle, static_cast<uv_tty_mode_t>(mode));\n}\n\n}\n#endif\n\nUV_EXTERN uv_handle_type uv_guess_handle(uv_file file);\n\n/*\n * uv_pipe_t is a subclass of uv_stream_t.\n *\n * Representing a pipe stream or pipe server. On Windows this is a Named\n * Pipe. On Unix this is a Unix domain socket.\n */\nstruct uv_pipe_s {\n  UV_HANDLE_FIELDS\n  UV_STREAM_FIELDS\n  int ipc; /* non-zero if this pipe is used for passing handles */\n  UV_PIPE_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_pipe_init(uv_loop_t*, uv_pipe_t* handle, int ipc);\nUV_EXTERN int uv_pipe_open(uv_pipe_t*, uv_file file);\nUV_EXTERN int uv_pipe_bind(uv_pipe_t* handle, const char* name);\nUV_EXTERN void uv_pipe_connect(uv_connect_t* req,\n                               uv_pipe_t* handle,\n                               const char* name,\n                               uv_connect_cb cb);\nUV_EXTERN int uv_pipe_getsockname(const uv_pipe_t* handle,\n                                  char* buffer,\n                                  size_t* size);\nUV_EXTERN int uv_pipe_getpeername(const uv_pipe_t* handle,\n                                  char* buffer,\n                                  size_t* size);\nUV_EXTERN void uv_pipe_pending_instances(uv_pipe_t* handle, int count);\nUV_EXTERN int uv_pipe_pending_count(uv_pipe_t* handle);\nUV_EXTERN uv_handle_type uv_pipe_pending_type(uv_pipe_t* handle);\nUV_EXTERN int uv_pipe_chmod(uv_pipe_t* handle, int flags);\n\n\nstruct uv_poll_s {\n  UV_HANDLE_FIELDS\n  uv_poll_cb poll_cb;\n  UV_POLL_PRIVATE_FIELDS\n};\n\nenum uv_poll_event {\n  UV_READABLE = 1,\n  UV_WRITABLE = 2,\n  UV_DISCONNECT = 4,\n  UV_PRIORITIZED = 8\n};\n\nUV_EXTERN int uv_poll_init(uv_loop_t* loop, uv_poll_t* handle, int fd);\nUV_EXTERN int uv_poll_init_socket(uv_loop_t* loop,\n                                  uv_poll_t* handle,\n                                  uv_os_sock_t socket);\nUV_EXTERN int uv_poll_start(uv_poll_t* handle, int events, uv_poll_cb cb);\nUV_EXTERN int uv_poll_stop(uv_poll_t* handle);\n\n\nstruct uv_prepare_s {\n  UV_HANDLE_FIELDS\n  UV_PREPARE_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_prepare_init(uv_loop_t*, uv_prepare_t* prepare);\nUV_EXTERN int uv_prepare_start(uv_prepare_t* prepare, uv_prepare_cb cb);\nUV_EXTERN int uv_prepare_stop(uv_prepare_t* prepare);\n\n\nstruct uv_check_s {\n  UV_HANDLE_FIELDS\n  UV_CHECK_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_check_init(uv_loop_t*, uv_check_t* check);\nUV_EXTERN int uv_check_start(uv_check_t* check, uv_check_cb cb);\nUV_EXTERN int uv_check_stop(uv_check_t* check);\n\n\nstruct uv_idle_s {\n  UV_HANDLE_FIELDS\n  UV_IDLE_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_idle_init(uv_loop_t*, uv_idle_t* idle);\nUV_EXTERN int uv_idle_start(uv_idle_t* idle, uv_idle_cb cb);\nUV_EXTERN int uv_idle_stop(uv_idle_t* idle);\n\n\nstruct uv_async_s {\n  UV_HANDLE_FIELDS\n  UV_ASYNC_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_async_init(uv_loop_t*,\n                            uv_async_t* async,\n                            uv_async_cb async_cb);\nUV_EXTERN int uv_async_send(uv_async_t* async);\n\n\n/*\n * uv_timer_t is a subclass of uv_handle_t.\n *\n * Used to get woken up at a specified time in the future.\n */\nstruct uv_timer_s {\n  UV_HANDLE_FIELDS\n  UV_TIMER_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_timer_init(uv_loop_t*, uv_timer_t* handle);\nUV_EXTERN int uv_timer_start(uv_timer_t* handle,\n                             uv_timer_cb cb,\n                             uint64_t timeout,\n                             uint64_t repeat);\nUV_EXTERN int uv_timer_stop(uv_timer_t* handle);\nUV_EXTERN int uv_timer_again(uv_timer_t* handle);\nUV_EXTERN void uv_timer_set_repeat(uv_timer_t* handle, uint64_t repeat);\nUV_EXTERN uint64_t uv_timer_get_repeat(const uv_timer_t* handle);\nUV_EXTERN uint64_t uv_timer_get_due_in(const uv_timer_t* handle);\n\n\n/*\n * uv_getaddrinfo_t is a subclass of uv_req_t.\n *\n * Request object for uv_getaddrinfo.\n */\nstruct uv_getaddrinfo_s {\n  UV_REQ_FIELDS\n  /* read-only */\n  uv_loop_t* loop;\n  /* struct addrinfo* addrinfo is marked as private, but it really isn't. */\n  UV_GETADDRINFO_PRIVATE_FIELDS\n};\n\n\nUV_EXTERN int uv_getaddrinfo(uv_loop_t* loop,\n                             uv_getaddrinfo_t* req,\n                             uv_getaddrinfo_cb getaddrinfo_cb,\n                             const char* node,\n                             const char* service,\n                             const struct addrinfo* hints);\nUV_EXTERN void uv_freeaddrinfo(struct addrinfo* ai);\n\n\n/*\n* uv_getnameinfo_t is a subclass of uv_req_t.\n*\n* Request object for uv_getnameinfo.\n*/\nstruct uv_getnameinfo_s {\n  UV_REQ_FIELDS\n  /* read-only */\n  uv_loop_t* loop;\n  /* host and service are marked as private, but they really aren't. */\n  UV_GETNAMEINFO_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_getnameinfo(uv_loop_t* loop,\n                             uv_getnameinfo_t* req,\n                             uv_getnameinfo_cb getnameinfo_cb,\n                             const struct sockaddr* addr,\n                             int flags);\n\n\n/* uv_spawn() options. */\ntypedef enum {\n  UV_IGNORE         = 0x00,\n  UV_CREATE_PIPE    = 0x01,\n  UV_INHERIT_FD     = 0x02,\n  UV_INHERIT_STREAM = 0x04,\n\n  /*\n   * When UV_CREATE_PIPE is specified, UV_READABLE_PIPE and UV_WRITABLE_PIPE\n   * determine the direction of flow, from the child process' perspective. Both\n   * flags may be specified to create a duplex data stream.\n   */\n  UV_READABLE_PIPE  = 0x10,\n  UV_WRITABLE_PIPE  = 0x20,\n\n  /*\n   * Open the child pipe handle in overlapped mode on Windows.\n   * On Unix it is silently ignored.\n   */\n  UV_OVERLAPPED_PIPE = 0x40\n} uv_stdio_flags;\n\ntypedef struct uv_stdio_container_s {\n  uv_stdio_flags flags;\n\n  union {\n    uv_stream_t* stream;\n    int fd;\n  } data;\n} uv_stdio_container_t;\n\ntypedef struct uv_process_options_s {\n  uv_exit_cb exit_cb; /* Called after the process exits. */\n  const char* file;   /* Path to program to execute. */\n  /*\n   * Command line arguments. args[0] should be the path to the program. On\n   * Windows this uses CreateProcess which concatenates the arguments into a\n   * string this can cause some strange errors. See the note at\n   * windows_verbatim_arguments.\n   */\n  char** args;\n  /*\n   * This will be set as the environ variable in the subprocess. If this is\n   * NULL then the parents environ will be used.\n   */\n  char** env;\n  /*\n   * If non-null this represents a directory the subprocess should execute\n   * in. Stands for current working directory.\n   */\n  const char* cwd;\n  /*\n   * Various flags that control how uv_spawn() behaves. See the definition of\n   * `enum uv_process_flags` below.\n   */\n  unsigned int flags;\n  /*\n   * The `stdio` field points to an array of uv_stdio_container_t structs that\n   * describe the file descriptors that will be made available to the child\n   * process. The convention is that stdio[0] points to stdin, fd 1 is used for\n   * stdout, and fd 2 is stderr.\n   *\n   * Note that on windows file descriptors greater than 2 are available to the\n   * child process only if the child processes uses the MSVCRT runtime.\n   */\n  int stdio_count;\n  uv_stdio_container_t* stdio;\n  /*\n   * Libuv can change the child process' user/group id. This happens only when\n   * the appropriate bits are set in the flags fields. This is not supported on\n   * windows; uv_spawn() will fail and set the error to UV_ENOTSUP.\n   */\n  uv_uid_t uid;\n  uv_gid_t gid;\n  /*\n    Libuv can set the child process' CPU affinity mask.  This happens when\n    `cpumask` is non-NULL.  It must point to an array of char values\n    of length `cpumask_size`, whose value must be at least that returned by\n    uv_cpumask_size().  Each byte in the mask can be either zero (false)\n    or non-zero (true) to indicate whether the corresponding processor at\n    that index is included.\n\n    If enabled on an unsupported platform, uv_spawn() will fail with\n    UV_ENOTSUP.\n   */\n  char* cpumask;\n  size_t cpumask_size;\n} uv_process_options_t;\n\n/*\n * These are the flags that can be used for the uv_process_options.flags field.\n */\nenum uv_process_flags {\n  /*\n   * Set the child process' user id. The user id is supplied in the `uid` field\n   * of the options struct. This does not work on windows; setting this flag\n   * will cause uv_spawn() to fail.\n   */\n  UV_PROCESS_SETUID = (1 << 0),\n  /*\n   * Set the child process' group id. The user id is supplied in the `gid`\n   * field of the options struct. This does not work on windows; setting this\n   * flag will cause uv_spawn() to fail.\n   */\n  UV_PROCESS_SETGID = (1 << 1),\n  /*\n   * Do not wrap any arguments in quotes, or perform any other escaping, when\n   * converting the argument list into a command line string. This option is\n   * only meaningful on Windows systems. On Unix it is silently ignored.\n   */\n  UV_PROCESS_WINDOWS_VERBATIM_ARGUMENTS = (1 << 2),\n  /*\n   * Spawn the child process in a detached state - this will make it a process\n   * group leader, and will effectively enable the child to keep running after\n   * the parent exits.  Note that the child process will still keep the\n   * parent's event loop alive unless the parent process calls uv_unref() on\n   * the child's process handle.\n   */\n  UV_PROCESS_DETACHED = (1 << 3),\n  /*\n   * Hide the subprocess window that would normally be created. This option is\n   * only meaningful on Windows systems. On Unix it is silently ignored.\n   */\n  UV_PROCESS_WINDOWS_HIDE = (1 << 4),\n  /*\n   * Hide the subprocess console window that would normally be created. This\n   * option is only meaningful on Windows systems. On Unix it is silently\n   * ignored.\n   */\n  UV_PROCESS_WINDOWS_HIDE_CONSOLE = (1 << 5),\n  /*\n   * Hide the subprocess GUI window that would normally be created. This\n   * option is only meaningful on Windows systems. On Unix it is silently\n   * ignored.\n   */\n  UV_PROCESS_WINDOWS_HIDE_GUI = (1 << 6)\n};\n\n/*\n * uv_process_t is a subclass of uv_handle_t.\n */\nstruct uv_process_s {\n  UV_HANDLE_FIELDS\n  uv_exit_cb exit_cb;\n  int pid;\n  UV_PROCESS_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_spawn(uv_loop_t* loop,\n                       uv_process_t* handle,\n                       const uv_process_options_t* options);\nUV_EXTERN int uv_process_kill(uv_process_t*, int signum);\nUV_EXTERN int uv_kill(int pid, int signum);\nUV_EXTERN uv_pid_t uv_process_get_pid(const uv_process_t*);\n\n\n/*\n * uv_work_t is a subclass of uv_req_t.\n */\nstruct uv_work_s {\n  UV_REQ_FIELDS\n  uv_loop_t* loop;\n  uv_work_cb work_cb;\n  uv_after_work_cb after_work_cb;\n  UV_WORK_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_queue_work(uv_loop_t* loop,\n                            uv_work_t* req,\n                            uv_work_cb work_cb,\n                            uv_after_work_cb after_work_cb);\n\nUV_EXTERN int uv_cancel(uv_req_t* req);\n\n\nstruct uv_cpu_times_s {\n  uint64_t user; /* milliseconds */\n  uint64_t nice; /* milliseconds */\n  uint64_t sys; /* milliseconds */\n  uint64_t idle; /* milliseconds */\n  uint64_t irq; /* milliseconds */\n};\n\nstruct uv_cpu_info_s {\n  char* model;\n  int speed;\n  struct uv_cpu_times_s cpu_times;\n};\n\nstruct uv_interface_address_s {\n  char* name;\n  char phys_addr[6];\n  int is_internal;\n  union {\n    struct sockaddr_in address4;\n    struct sockaddr_in6 address6;\n  } address;\n  union {\n    struct sockaddr_in netmask4;\n    struct sockaddr_in6 netmask6;\n  } netmask;\n};\n\nstruct uv_passwd_s {\n  char* username;\n  long uid;\n  long gid;\n  char* shell;\n  char* homedir;\n};\n\nstruct uv_utsname_s {\n  char sysname[256];\n  char release[256];\n  char version[256];\n  char machine[256];\n  /* This struct does not contain the nodename and domainname fields present in\n     the utsname type. domainname is a GNU extension. Both fields are referred\n     to as meaningless in the docs. */\n};\n\nstruct uv_statfs_s {\n  uint64_t f_type;\n  uint64_t f_bsize;\n  uint64_t f_blocks;\n  uint64_t f_bfree;\n  uint64_t f_bavail;\n  uint64_t f_files;\n  uint64_t f_ffree;\n  uint64_t f_spare[4];\n};\n\ntypedef enum {\n  UV_DIRENT_UNKNOWN,\n  UV_DIRENT_FILE,\n  UV_DIRENT_DIR,\n  UV_DIRENT_LINK,\n  UV_DIRENT_FIFO,\n  UV_DIRENT_SOCKET,\n  UV_DIRENT_CHAR,\n  UV_DIRENT_BLOCK\n} uv_dirent_type_t;\n\nstruct uv_dirent_s {\n  const char* name;\n  uv_dirent_type_t type;\n};\n\nUV_EXTERN char** uv_setup_args(int argc, char** argv);\nUV_EXTERN int uv_get_process_title(char* buffer, size_t size);\nUV_EXTERN int uv_set_process_title(const char* title);\nUV_EXTERN int uv_resident_set_memory(size_t* rss);\nUV_EXTERN int uv_uptime(double* uptime);\nUV_EXTERN uv_os_fd_t uv_get_osfhandle(int fd);\nUV_EXTERN int uv_open_osfhandle(uv_os_fd_t os_fd);\n\ntypedef struct {\n  long tv_sec;\n  long tv_usec;\n} uv_timeval_t;\n\ntypedef struct {\n  int64_t tv_sec;\n  int32_t tv_usec;\n} uv_timeval64_t;\n\ntypedef struct {\n   uv_timeval_t ru_utime; /* user CPU time used */\n   uv_timeval_t ru_stime; /* system CPU time used */\n   uint64_t ru_maxrss;    /* maximum resident set size */\n   uint64_t ru_ixrss;     /* integral shared memory size */\n   uint64_t ru_idrss;     /* integral unshared data size */\n   uint64_t ru_isrss;     /* integral unshared stack size */\n   uint64_t ru_minflt;    /* page reclaims (soft page faults) */\n   uint64_t ru_majflt;    /* page faults (hard page faults) */\n   uint64_t ru_nswap;     /* swaps */\n   uint64_t ru_inblock;   /* block input operations */\n   uint64_t ru_oublock;   /* block output operations */\n   uint64_t ru_msgsnd;    /* IPC messages sent */\n   uint64_t ru_msgrcv;    /* IPC messages received */\n   uint64_t ru_nsignals;  /* signals received */\n   uint64_t ru_nvcsw;     /* voluntary context switches */\n   uint64_t ru_nivcsw;    /* involuntary context switches */\n} uv_rusage_t;\n\nUV_EXTERN int uv_getrusage(uv_rusage_t* rusage);\n\nUV_EXTERN int uv_os_homedir(char* buffer, size_t* size);\nUV_EXTERN int uv_os_tmpdir(char* buffer, size_t* size);\nUV_EXTERN int uv_os_get_passwd(uv_passwd_t* pwd);\nUV_EXTERN void uv_os_free_passwd(uv_passwd_t* pwd);\nUV_EXTERN uv_pid_t uv_os_getpid(void);\nUV_EXTERN uv_pid_t uv_os_getppid(void);\n\n#if defined(__PASE__)\n/* On IBM i PASE, the highest process priority is -10 */\n# define UV_PRIORITY_LOW 39          /* RUNPTY(99) */\n# define UV_PRIORITY_BELOW_NORMAL 15 /* RUNPTY(50) */\n# define UV_PRIORITY_NORMAL 0        /* RUNPTY(20) */\n# define UV_PRIORITY_ABOVE_NORMAL -4 /* RUNTY(12) */\n# define UV_PRIORITY_HIGH -7         /* RUNPTY(6) */\n# define UV_PRIORITY_HIGHEST -10     /* RUNPTY(1) */\n#else\n# define UV_PRIORITY_LOW 19\n# define UV_PRIORITY_BELOW_NORMAL 10\n# define UV_PRIORITY_NORMAL 0\n# define UV_PRIORITY_ABOVE_NORMAL -7\n# define UV_PRIORITY_HIGH -14\n# define UV_PRIORITY_HIGHEST -20\n#endif\n\nUV_EXTERN int uv_os_getpriority(uv_pid_t pid, int* priority);\nUV_EXTERN int uv_os_setpriority(uv_pid_t pid, int priority);\n\nUV_EXTERN int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count);\nUV_EXTERN void uv_free_cpu_info(uv_cpu_info_t* cpu_infos, int count);\nUV_EXTERN int uv_cpumask_size(void);\n\nUV_EXTERN int uv_interface_addresses(uv_interface_address_t** addresses,\n                                     int* count);\nUV_EXTERN void uv_free_interface_addresses(uv_interface_address_t* addresses,\n                                           int count);\n\nstruct uv_env_item_s {\n  char* name;\n  char* value;\n};\n\nUV_EXTERN int uv_os_environ(uv_env_item_t** envitems, int* count);\nUV_EXTERN void uv_os_free_environ(uv_env_item_t* envitems, int count);\nUV_EXTERN int uv_os_getenv(const char* name, char* buffer, size_t* size);\nUV_EXTERN int uv_os_setenv(const char* name, const char* value);\nUV_EXTERN int uv_os_unsetenv(const char* name);\n\n#ifdef MAXHOSTNAMELEN\n# define UV_MAXHOSTNAMESIZE (MAXHOSTNAMELEN + 1)\n#else\n  /*\n    Fallback for the maximum hostname size, including the null terminator. The\n    Windows gethostname() documentation states that 256 bytes will always be\n    large enough to hold the null-terminated hostname.\n  */\n# define UV_MAXHOSTNAMESIZE 256\n#endif\n\nUV_EXTERN int uv_os_gethostname(char* buffer, size_t* size);\n\nUV_EXTERN int uv_os_uname(uv_utsname_t* buffer);\n\nUV_EXTERN uint64_t uv_metrics_idle_time(uv_loop_t* loop);\n\ntypedef enum {\n  UV_FS_UNKNOWN = -1,\n  UV_FS_CUSTOM,\n  UV_FS_OPEN,\n  UV_FS_CLOSE,\n  UV_FS_READ,\n  UV_FS_WRITE,\n  UV_FS_SENDFILE,\n  UV_FS_STAT,\n  UV_FS_LSTAT,\n  UV_FS_FSTAT,\n  UV_FS_FTRUNCATE,\n  UV_FS_UTIME,\n  UV_FS_FUTIME,\n  UV_FS_ACCESS,\n  UV_FS_CHMOD,\n  UV_FS_FCHMOD,\n  UV_FS_FSYNC,\n  UV_FS_FDATASYNC,\n  UV_FS_UNLINK,\n  UV_FS_RMDIR,\n  UV_FS_MKDIR,\n  UV_FS_MKDTEMP,\n  UV_FS_RENAME,\n  UV_FS_SCANDIR,\n  UV_FS_LINK,\n  UV_FS_SYMLINK,\n  UV_FS_READLINK,\n  UV_FS_CHOWN,\n  UV_FS_FCHOWN,\n  UV_FS_REALPATH,\n  UV_FS_COPYFILE,\n  UV_FS_LCHOWN,\n  UV_FS_OPENDIR,\n  UV_FS_READDIR,\n  UV_FS_CLOSEDIR,\n  UV_FS_STATFS,\n  UV_FS_MKSTEMP,\n  UV_FS_LUTIME\n} uv_fs_type;\n\nstruct uv_dir_s {\n  uv_dirent_t* dirents;\n  size_t nentries;\n  void* reserved[4];\n  UV_DIR_PRIVATE_FIELDS\n};\n\n/* uv_fs_t is a subclass of uv_req_t. */\nstruct uv_fs_s {\n  UV_REQ_FIELDS\n  uv_fs_type fs_type;\n  uv_loop_t* loop;\n  uv_fs_cb cb;\n  ssize_t result;\n  void* ptr;\n  const char* path;\n  uv_stat_t statbuf;  /* Stores the result of uv_fs_stat() and uv_fs_fstat(). */\n  UV_FS_PRIVATE_FIELDS\n};\n\nUV_EXTERN uv_fs_type uv_fs_get_type(const uv_fs_t*);\nUV_EXTERN ssize_t uv_fs_get_result(const uv_fs_t*);\nUV_EXTERN int uv_fs_get_system_error(const uv_fs_t*);\nUV_EXTERN void* uv_fs_get_ptr(const uv_fs_t*);\nUV_EXTERN const char* uv_fs_get_path(const uv_fs_t*);\nUV_EXTERN uv_stat_t* uv_fs_get_statbuf(uv_fs_t*);\n\nUV_EXTERN void uv_fs_req_cleanup(uv_fs_t* req);\nUV_EXTERN int uv_fs_close(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          uv_file file,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_open(uv_loop_t* loop,\n                         uv_fs_t* req,\n                         const char* path,\n                         int flags,\n                         int mode,\n                         uv_fs_cb cb);\nUV_EXTERN int uv_fs_read(uv_loop_t* loop,\n                         uv_fs_t* req,\n                         uv_file file,\n                         const uv_buf_t bufs[],\n                         unsigned int nbufs,\n                         int64_t offset,\n                         uv_fs_cb cb);\nUV_EXTERN int uv_fs_unlink(uv_loop_t* loop,\n                           uv_fs_t* req,\n                           const char* path,\n                           uv_fs_cb cb);\nUV_EXTERN int uv_fs_write(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          uv_file file,\n                          const uv_buf_t bufs[],\n                          unsigned int nbufs,\n                          int64_t offset,\n                          uv_fs_cb cb);\n/*\n * This flag can be used with uv_fs_copyfile() to return an error if the\n * destination already exists.\n */\n#define UV_FS_COPYFILE_EXCL   0x0001\n\n/*\n * This flag can be used with uv_fs_copyfile() to attempt to create a reflink.\n * If copy-on-write is not supported, a fallback copy mechanism is used.\n */\n#define UV_FS_COPYFILE_FICLONE 0x0002\n\n/*\n * This flag can be used with uv_fs_copyfile() to attempt to create a reflink.\n * If copy-on-write is not supported, an error is returned.\n */\n#define UV_FS_COPYFILE_FICLONE_FORCE 0x0004\n\nUV_EXTERN int uv_fs_copyfile(uv_loop_t* loop,\n                             uv_fs_t* req,\n                             const char* path,\n                             const char* new_path,\n                             int flags,\n                             uv_fs_cb cb);\nUV_EXTERN int uv_fs_mkdir(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          const char* path,\n                          int mode,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_mkdtemp(uv_loop_t* loop,\n                            uv_fs_t* req,\n                            const char* tpl,\n                            uv_fs_cb cb);\nUV_EXTERN int uv_fs_mkstemp(uv_loop_t* loop,\n                            uv_fs_t* req,\n                            const char* tpl,\n                            uv_fs_cb cb);\nUV_EXTERN int uv_fs_rmdir(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          const char* path,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_scandir(uv_loop_t* loop,\n                            uv_fs_t* req,\n                            const char* path,\n                            int flags,\n                            uv_fs_cb cb);\nUV_EXTERN int uv_fs_scandir_next(uv_fs_t* req,\n                                 uv_dirent_t* ent);\nUV_EXTERN int uv_fs_opendir(uv_loop_t* loop,\n                            uv_fs_t* req,\n                            const char* path,\n                            uv_fs_cb cb);\nUV_EXTERN int uv_fs_readdir(uv_loop_t* loop,\n                            uv_fs_t* req,\n                            uv_dir_t* dir,\n                            uv_fs_cb cb);\nUV_EXTERN int uv_fs_closedir(uv_loop_t* loop,\n                             uv_fs_t* req,\n                             uv_dir_t* dir,\n                             uv_fs_cb cb);\nUV_EXTERN int uv_fs_stat(uv_loop_t* loop,\n                         uv_fs_t* req,\n                         const char* path,\n                         uv_fs_cb cb);\nUV_EXTERN int uv_fs_fstat(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          uv_file file,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_rename(uv_loop_t* loop,\n                           uv_fs_t* req,\n                           const char* path,\n                           const char* new_path,\n                           uv_fs_cb cb);\nUV_EXTERN int uv_fs_fsync(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          uv_file file,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_fdatasync(uv_loop_t* loop,\n                              uv_fs_t* req,\n                              uv_file file,\n                              uv_fs_cb cb);\nUV_EXTERN int uv_fs_ftruncate(uv_loop_t* loop,\n                              uv_fs_t* req,\n                              uv_file file,\n                              int64_t offset,\n                              uv_fs_cb cb);\nUV_EXTERN int uv_fs_sendfile(uv_loop_t* loop,\n                             uv_fs_t* req,\n                             uv_file out_fd,\n                             uv_file in_fd,\n                             int64_t in_offset,\n                             size_t length,\n                             uv_fs_cb cb);\nUV_EXTERN int uv_fs_access(uv_loop_t* loop,\n                           uv_fs_t* req,\n                           const char* path,\n                           int mode,\n                           uv_fs_cb cb);\nUV_EXTERN int uv_fs_chmod(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          const char* path,\n                          int mode,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_utime(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          const char* path,\n                          double atime,\n                          double mtime,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_futime(uv_loop_t* loop,\n                           uv_fs_t* req,\n                           uv_file file,\n                           double atime,\n                           double mtime,\n                           uv_fs_cb cb);\nUV_EXTERN int uv_fs_lutime(uv_loop_t* loop,\n                           uv_fs_t* req,\n                           const char* path,\n                           double atime,\n                           double mtime,\n                           uv_fs_cb cb);\nUV_EXTERN int uv_fs_lstat(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          const char* path,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_link(uv_loop_t* loop,\n                         uv_fs_t* req,\n                         const char* path,\n                         const char* new_path,\n                         uv_fs_cb cb);\n\n/*\n * This flag can be used with uv_fs_symlink() on Windows to specify whether\n * path argument points to a directory.\n */\n#define UV_FS_SYMLINK_DIR          0x0001\n\n/*\n * This flag can be used with uv_fs_symlink() on Windows to specify whether\n * the symlink is to be created using junction points.\n */\n#define UV_FS_SYMLINK_JUNCTION     0x0002\n\nUV_EXTERN int uv_fs_symlink(uv_loop_t* loop,\n                            uv_fs_t* req,\n                            const char* path,\n                            const char* new_path,\n                            int flags,\n                            uv_fs_cb cb);\nUV_EXTERN int uv_fs_readlink(uv_loop_t* loop,\n                             uv_fs_t* req,\n                             const char* path,\n                             uv_fs_cb cb);\nUV_EXTERN int uv_fs_realpath(uv_loop_t* loop,\n                             uv_fs_t* req,\n                             const char* path,\n                             uv_fs_cb cb);\nUV_EXTERN int uv_fs_fchmod(uv_loop_t* loop,\n                           uv_fs_t* req,\n                           uv_file file,\n                           int mode,\n                           uv_fs_cb cb);\nUV_EXTERN int uv_fs_chown(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          const char* path,\n                          uv_uid_t uid,\n                          uv_gid_t gid,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_fchown(uv_loop_t* loop,\n                           uv_fs_t* req,\n                           uv_file file,\n                           uv_uid_t uid,\n                           uv_gid_t gid,\n                           uv_fs_cb cb);\nUV_EXTERN int uv_fs_lchown(uv_loop_t* loop,\n                           uv_fs_t* req,\n                           const char* path,\n                           uv_uid_t uid,\n                           uv_gid_t gid,\n                           uv_fs_cb cb);\nUV_EXTERN int uv_fs_statfs(uv_loop_t* loop,\n                           uv_fs_t* req,\n                           const char* path,\n                           uv_fs_cb cb);\n\n\nenum uv_fs_event {\n  UV_RENAME = 1,\n  UV_CHANGE = 2\n};\n\n\nstruct uv_fs_event_s {\n  UV_HANDLE_FIELDS\n  /* private */\n  char* path;\n  UV_FS_EVENT_PRIVATE_FIELDS\n};\n\n\n/*\n * uv_fs_stat() based polling file watcher.\n */\nstruct uv_fs_poll_s {\n  UV_HANDLE_FIELDS\n  /* Private, don't touch. */\n  void* poll_ctx;\n};\n\nUV_EXTERN int uv_fs_poll_init(uv_loop_t* loop, uv_fs_poll_t* handle);\nUV_EXTERN int uv_fs_poll_start(uv_fs_poll_t* handle,\n                               uv_fs_poll_cb poll_cb,\n                               const char* path,\n                               unsigned int interval);\nUV_EXTERN int uv_fs_poll_stop(uv_fs_poll_t* handle);\nUV_EXTERN int uv_fs_poll_getpath(uv_fs_poll_t* handle,\n                                 char* buffer,\n                                 size_t* size);\n\n\nstruct uv_signal_s {\n  UV_HANDLE_FIELDS\n  uv_signal_cb signal_cb;\n  int signum;\n  UV_SIGNAL_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_signal_init(uv_loop_t* loop, uv_signal_t* handle);\nUV_EXTERN int uv_signal_start(uv_signal_t* handle,\n                              uv_signal_cb signal_cb,\n                              int signum);\nUV_EXTERN int uv_signal_start_oneshot(uv_signal_t* handle,\n                                      uv_signal_cb signal_cb,\n                                      int signum);\nUV_EXTERN int uv_signal_stop(uv_signal_t* handle);\n\nUV_EXTERN void uv_loadavg(double avg[3]);\n\n\n/*\n * Flags to be passed to uv_fs_event_start().\n */\nenum uv_fs_event_flags {\n  /*\n   * By default, if the fs event watcher is given a directory name, we will\n   * watch for all events in that directory. This flags overrides this behavior\n   * and makes fs_event report only changes to the directory entry itself. This\n   * flag does not affect individual files watched.\n   * This flag is currently not implemented yet on any backend.\n   */\n  UV_FS_EVENT_WATCH_ENTRY = 1,\n\n  /*\n   * By default uv_fs_event will try to use a kernel interface such as inotify\n   * or kqueue to detect events. This may not work on remote filesystems such\n   * as NFS mounts. This flag makes fs_event fall back to calling stat() on a\n   * regular interval.\n   * This flag is currently not implemented yet on any backend.\n   */\n  UV_FS_EVENT_STAT = 2,\n\n  /*\n   * By default, event watcher, when watching directory, is not registering\n   * (is ignoring) changes in it's subdirectories.\n   * This flag will override this behaviour on platforms that support it.\n   */\n  UV_FS_EVENT_RECURSIVE = 4\n};\n\n\nUV_EXTERN int uv_fs_event_init(uv_loop_t* loop, uv_fs_event_t* handle);\nUV_EXTERN int uv_fs_event_start(uv_fs_event_t* handle,\n                                uv_fs_event_cb cb,\n                                const char* path,\n                                unsigned int flags);\nUV_EXTERN int uv_fs_event_stop(uv_fs_event_t* handle);\nUV_EXTERN int uv_fs_event_getpath(uv_fs_event_t* handle,\n                                  char* buffer,\n                                  size_t* size);\n\nUV_EXTERN int uv_ip4_addr(const char* ip, int port, struct sockaddr_in* addr);\nUV_EXTERN int uv_ip6_addr(const char* ip, int port, struct sockaddr_in6* addr);\n\nUV_EXTERN int uv_ip4_name(const struct sockaddr_in* src, char* dst, size_t size);\nUV_EXTERN int uv_ip6_name(const struct sockaddr_in6* src, char* dst, size_t size);\n\nUV_EXTERN int uv_inet_ntop(int af, const void* src, char* dst, size_t size);\nUV_EXTERN int uv_inet_pton(int af, const char* src, void* dst);\n\n\nstruct uv_random_s {\n  UV_REQ_FIELDS\n  /* read-only */\n  uv_loop_t* loop;\n  /* private */\n  int status;\n  void* buf;\n  size_t buflen;\n  uv_random_cb cb;\n  struct uv__work work_req;\n};\n\nUV_EXTERN int uv_random(uv_loop_t* loop,\n                        uv_random_t* req,\n                        void *buf,\n                        size_t buflen,\n                        unsigned flags,  /* For future extension; must be 0. */\n                        uv_random_cb cb);\n\n#if defined(IF_NAMESIZE)\n# define UV_IF_NAMESIZE (IF_NAMESIZE + 1)\n#elif defined(IFNAMSIZ)\n# define UV_IF_NAMESIZE (IFNAMSIZ + 1)\n#else\n# define UV_IF_NAMESIZE (16 + 1)\n#endif\n\nUV_EXTERN int uv_if_indextoname(unsigned int ifindex,\n                                char* buffer,\n                                size_t* size);\nUV_EXTERN int uv_if_indextoiid(unsigned int ifindex,\n                               char* buffer,\n                               size_t* size);\n\nUV_EXTERN int uv_exepath(char* buffer, size_t* size);\n\nUV_EXTERN int uv_cwd(char* buffer, size_t* size);\n\nUV_EXTERN int uv_chdir(const char* dir);\n\nUV_EXTERN uint64_t uv_get_free_memory(void);\nUV_EXTERN uint64_t uv_get_total_memory(void);\nUV_EXTERN uint64_t uv_get_constrained_memory(void);\n\nUV_EXTERN uint64_t uv_hrtime(void);\nUV_EXTERN void uv_sleep(unsigned int msec);\n\nUV_EXTERN void uv_disable_stdio_inheritance(void);\n\nUV_EXTERN int uv_dlopen(const char* filename, uv_lib_t* lib);\nUV_EXTERN void uv_dlclose(uv_lib_t* lib);\nUV_EXTERN int uv_dlsym(uv_lib_t* lib, const char* name, void** ptr);\nUV_EXTERN const char* uv_dlerror(const uv_lib_t* lib);\n\nUV_EXTERN int uv_mutex_init(uv_mutex_t* handle);\nUV_EXTERN int uv_mutex_init_recursive(uv_mutex_t* handle);\nUV_EXTERN void uv_mutex_destroy(uv_mutex_t* handle);\nUV_EXTERN void uv_mutex_lock(uv_mutex_t* handle);\nUV_EXTERN int uv_mutex_trylock(uv_mutex_t* handle);\nUV_EXTERN void uv_mutex_unlock(uv_mutex_t* handle);\n\nUV_EXTERN int uv_rwlock_init(uv_rwlock_t* rwlock);\nUV_EXTERN void uv_rwlock_destroy(uv_rwlock_t* rwlock);\nUV_EXTERN void uv_rwlock_rdlock(uv_rwlock_t* rwlock);\nUV_EXTERN int uv_rwlock_tryrdlock(uv_rwlock_t* rwlock);\nUV_EXTERN void uv_rwlock_rdunlock(uv_rwlock_t* rwlock);\nUV_EXTERN void uv_rwlock_wrlock(uv_rwlock_t* rwlock);\nUV_EXTERN int uv_rwlock_trywrlock(uv_rwlock_t* rwlock);\nUV_EXTERN void uv_rwlock_wrunlock(uv_rwlock_t* rwlock);\n\nUV_EXTERN int uv_sem_init(uv_sem_t* sem, unsigned int value);\nUV_EXTERN void uv_sem_destroy(uv_sem_t* sem);\nUV_EXTERN void uv_sem_post(uv_sem_t* sem);\nUV_EXTERN void uv_sem_wait(uv_sem_t* sem);\nUV_EXTERN int uv_sem_trywait(uv_sem_t* sem);\n\nUV_EXTERN int uv_cond_init(uv_cond_t* cond);\nUV_EXTERN void uv_cond_destroy(uv_cond_t* cond);\nUV_EXTERN void uv_cond_signal(uv_cond_t* cond);\nUV_EXTERN void uv_cond_broadcast(uv_cond_t* cond);\n\nUV_EXTERN int uv_barrier_init(uv_barrier_t* barrier, unsigned int count);\nUV_EXTERN void uv_barrier_destroy(uv_barrier_t* barrier);\nUV_EXTERN int uv_barrier_wait(uv_barrier_t* barrier);\n\nUV_EXTERN void uv_cond_wait(uv_cond_t* cond, uv_mutex_t* mutex);\nUV_EXTERN int uv_cond_timedwait(uv_cond_t* cond,\n                                uv_mutex_t* mutex,\n                                uint64_t timeout);\n\nUV_EXTERN void uv_once(uv_once_t* guard, void (*callback)(void));\n\nUV_EXTERN int uv_key_create(uv_key_t* key);\nUV_EXTERN void uv_key_delete(uv_key_t* key);\nUV_EXTERN void* uv_key_get(uv_key_t* key);\nUV_EXTERN void uv_key_set(uv_key_t* key, void* value);\n\nUV_EXTERN int uv_gettimeofday(uv_timeval64_t* tv);\n\ntypedef void (*uv_thread_cb)(void* arg);\n\nUV_EXTERN int uv_thread_create(uv_thread_t* tid, uv_thread_cb entry, void* arg);\n\ntypedef enum {\n  UV_THREAD_NO_FLAGS = 0x00,\n  UV_THREAD_HAS_STACK_SIZE = 0x01\n} uv_thread_create_flags;\n\nstruct uv_thread_options_s {\n  unsigned int flags;\n  size_t stack_size;\n  /* More fields may be added at any time. */\n};\n\ntypedef struct uv_thread_options_s uv_thread_options_t;\n\nUV_EXTERN int uv_thread_create_ex(uv_thread_t* tid,\n                                  const uv_thread_options_t* params,\n                                  uv_thread_cb entry,\n                                  void* arg);\nUV_EXTERN uv_thread_t uv_thread_self(void);\nUV_EXTERN int uv_thread_join(uv_thread_t *tid);\nUV_EXTERN int uv_thread_equal(const uv_thread_t* t1, const uv_thread_t* t2);\n\n/* The presence of these unions force similar struct layout. */\n#define XX(_, name) uv_ ## name ## _t name;\nunion uv_any_handle {\n  UV_HANDLE_TYPE_MAP(XX)\n};\n\nunion uv_any_req {\n  UV_REQ_TYPE_MAP(XX)\n};\n#undef XX\n\n\nstruct uv_loop_s {\n  /* User data - use this for whatever. */\n  void* data;\n  /* Loop reference counting. */\n  unsigned int active_handles;\n  void* handle_queue[2];\n  union {\n    void* unused;\n    unsigned int count;\n  } active_reqs;\n  /* Internal storage for future extensions. */\n  void* internal_fields;\n  /* Internal flag to signal loop stop. */\n  unsigned int stop_flag;\n  UV_LOOP_PRIVATE_FIELDS\n};\n\nUV_EXTERN void* uv_loop_get_data(const uv_loop_t*);\nUV_EXTERN void uv_loop_set_data(uv_loop_t*, void* data);\n\n/* Don't export the private CPP symbols. */\n#undef UV_HANDLE_TYPE_PRIVATE\n#undef UV_REQ_TYPE_PRIVATE\n#undef UV_REQ_PRIVATE_FIELDS\n#undef UV_STREAM_PRIVATE_FIELDS\n#undef UV_TCP_PRIVATE_FIELDS\n#undef UV_PREPARE_PRIVATE_FIELDS\n#undef UV_CHECK_PRIVATE_FIELDS\n#undef UV_IDLE_PRIVATE_FIELDS\n#undef UV_ASYNC_PRIVATE_FIELDS\n#undef UV_TIMER_PRIVATE_FIELDS\n#undef UV_GETADDRINFO_PRIVATE_FIELDS\n#undef UV_GETNAMEINFO_PRIVATE_FIELDS\n#undef UV_FS_REQ_PRIVATE_FIELDS\n#undef UV_WORK_PRIVATE_FIELDS\n#undef UV_FS_EVENT_PRIVATE_FIELDS\n#undef UV_SIGNAL_PRIVATE_FIELDS\n#undef UV_LOOP_PRIVATE_FIELDS\n#undef UV_LOOP_PRIVATE_PLATFORM_FIELDS\n#undef UV__ERR\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* UV_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Source/kwsys/DynamicLoader.cxx": "/* Distributed under the OSI-approved BSD 3-Clause License.  See accompanying\n   file Copyright.txt or https://cmake.org/licensing#kwsys for details.  */\n#if defined(_WIN32)\n#  define NOMINMAX // hide min,max to not conflict with <limits>\n#endif\n\n#include \"kwsysPrivate.h\"\n#include KWSYS_HEADER(DynamicLoader.hxx)\n\n#include KWSYS_HEADER(Configure.hxx)\n#include KWSYS_HEADER(Encoding.hxx)\n\n// Work-around CMake dependency scanning limitation.  This must\n// duplicate the above list of headers.\n#if 0\n#  include \"Configure.hxx.in\"\n#  include \"DynamicLoader.hxx.in\"\n#endif\n\n// This file actually contains several different implementations:\n// * NOOP for environments without dynamic libs\n// * HP machines which uses shl_load\n// * Mac OS X 10.2.x and earlier which uses NSLinkModule\n// * Windows which uses LoadLibrary\n// * BeOS / Haiku\n// * FreeMiNT for Atari\n// * Default implementation for *NIX systems (including Mac OS X 10.3 and\n//   later) which use dlopen\n//\n// Each part of the ifdef contains a complete implementation for\n// the static methods of DynamicLoader.\n\n#define CHECK_OPEN_FLAGS(var, supported, ret)                                 \\\n  do {                                                                        \\\n    /* Check for unknown flags. */                                            \\\n    if ((var & AllOpenFlags) != var) {                                        \\\n      return ret;                                                             \\\n    }                                                                         \\\n                                                                              \\\n    /* Check for unsupported flags. */                                        \\\n    if ((var & (supported)) != var) {                                         \\\n      return ret;                                                             \\\n    }                                                                         \\\n  } while (0)\n\nnamespace KWSYS_NAMESPACE {\n\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(\n  const std::string& libname)\n{\n  return DynamicLoader::OpenLibrary(libname, 0);\n}\n}\n\n#if !KWSYS_SUPPORTS_SHARED_LIBS\n// Implementation for environments without dynamic libs\n#  include <string.h> // for strerror()\n\nnamespace KWSYS_NAMESPACE {\n\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(\n  const std::string& libname, int flags)\n{\n  return 0;\n}\n\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  if (!lib) {\n    return 0;\n  }\n\n  return 1;\n}\n\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const std::string& sym)\n{\n  return 0;\n}\n\nconst char* DynamicLoader::LastError()\n{\n  return \"General error\";\n}\n\n} // namespace KWSYS_NAMESPACE\n\n#elif defined(__hpux)\n// Implementation for HPUX machines\n#  include <dl.h>\n#  include <errno.h>\n\nnamespace KWSYS_NAMESPACE {\n\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(\n  const std::string& libname, int flags)\n{\n  CHECK_OPEN_FLAGS(flags, 0, 0);\n\n  return shl_load(libname.c_str(), BIND_DEFERRED | DYNAMIC_PATH, 0L);\n}\n\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  if (!lib) {\n    return 0;\n  }\n  return !shl_unload(lib);\n}\n\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const std::string& sym)\n{\n  void* addr;\n  int status;\n\n  /* TYPE_PROCEDURE Look for a function or procedure. (This used to be default)\n   * TYPE_DATA      Look for a symbol in the data segment (for example,\n   * variables).\n   * TYPE_UNDEFINED Look for any symbol.\n   */\n  status = shl_findsym(&lib, sym.c_str(), TYPE_UNDEFINED, &addr);\n  void* result = (status < 0) ? (void*)0 : addr;\n\n  // Hack to cast pointer-to-data to pointer-to-function.\n  return *reinterpret_cast<DynamicLoader::SymbolPointer*>(&result);\n}\n\nconst char* DynamicLoader::LastError()\n{\n  // TODO: Need implementation with errno/strerror\n  /* If successful, shl_findsym returns an integer (int) value zero. If\n   * shl_findsym cannot find sym, it returns -1 and sets errno to zero.\n   * If any other errors occur, shl_findsym returns -1 and sets errno to one\n   * of these values (defined in <errno.h>):\n   * ENOEXEC\n   * A format error was detected in the specified library.\n   * ENOSYM\n   * A symbol on which sym depends could not be found.\n   * EINVAL\n   * The specified handle is invalid.\n   */\n\n  if (errno == ENOEXEC || errno == ENOSYM || errno == EINVAL) {\n    return strerror(errno);\n  }\n  // else\n  return 0;\n}\n\n} // namespace KWSYS_NAMESPACE\n\n#elif defined(__APPLE__) && (MAC_OS_X_VERSION_MAX_ALLOWED < 1030)\n// Implementation for Mac OS X 10.2.x and earlier\n#  include <mach-o/dyld.h>\n#  include <string.h> // for strlen\n\nnamespace KWSYS_NAMESPACE {\n\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(\n  const std::string& libname, int flags)\n{\n  CHECK_OPEN_FLAGS(flags, 0, 0);\n\n  NSObjectFileImageReturnCode rc;\n  NSObjectFileImage image = 0;\n\n  rc = NSCreateObjectFileImageFromFile(libname.c_str(), &image);\n  // rc == NSObjectFileImageInappropriateFile when trying to load a dylib file\n  if (rc != NSObjectFileImageSuccess) {\n    return 0;\n  }\n  NSModule handle = NSLinkModule(image, libname.c_str(),\n                                 NSLINKMODULE_OPTION_BINDNOW |\n                                   NSLINKMODULE_OPTION_RETURN_ON_ERROR);\n  NSDestroyObjectFileImage(image);\n  return handle;\n}\n\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  // NSUNLINKMODULE_OPTION_KEEP_MEMORY_MAPPED\n  // With  this  option  the memory for the module is not deallocated\n  // allowing pointers into the module to still be valid.\n  // You should use this option instead if your code experience some problems\n  // reported against Panther 10.3.9 (fixed in Tiger 10.4.2 and up)\n  bool success = NSUnLinkModule(lib, NSUNLINKMODULE_OPTION_NONE);\n  return success;\n}\n\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const std::string& sym)\n{\n  void* result = 0;\n  // Need to prepend symbols with '_' on Apple-gcc compilers\n  std::string rsym = '_' + sym;\n\n  NSSymbol symbol = NSLookupSymbolInModule(lib, rsym.c_str());\n  if (symbol) {\n    result = NSAddressOfSymbol(symbol);\n  }\n\n  // Hack to cast pointer-to-data to pointer-to-function.\n  return *reinterpret_cast<DynamicLoader::SymbolPointer*>(&result);\n}\n\nconst char* DynamicLoader::LastError()\n{\n  return 0;\n}\n\n} // namespace KWSYS_NAMESPACE\n\n#elif defined(_WIN32) && !defined(__CYGWIN__)\n// Implementation for Windows win32 code but not cygwin\n#  include <windows.h>\n\n#  include <stdio.h>\n\nnamespace KWSYS_NAMESPACE {\n\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(\n  const std::string& libname, int flags)\n{\n  CHECK_OPEN_FLAGS(flags, SearchBesideLibrary, nullptr);\n\n  DWORD llFlags = 0;\n  if (flags & SearchBesideLibrary) {\n    llFlags |= LOAD_WITH_ALTERED_SEARCH_PATH;\n  }\n\n  return LoadLibraryExW(Encoding::ToWindowsExtendedPath(libname).c_str(),\n                        nullptr, llFlags);\n}\n\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  return (int)FreeLibrary(lib);\n}\n\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const std::string& sym)\n{\n  // TODO: The calling convention affects the name of the symbol.  We\n  // should have a tool to help get the symbol with the desired\n  // calling convention.  Currently we assume cdecl.\n  //\n  // MSVC:\n  //   __cdecl    = \"func\" (default)\n  //   __fastcall = \"@_func@X\"\n  //   __stdcall  = \"_func@X\"\n  //\n  // Note that the \"@X\" part of the name above is the total size (in\n  // bytes) of the arguments on the stack.\n  void* result;\n  const char* rsym = sym.c_str();\n  result = (void*)GetProcAddress(lib, rsym);\n  return *reinterpret_cast<DynamicLoader::SymbolPointer*>(&result);\n}\n\n#  define DYNLOAD_ERROR_BUFFER_SIZE 1024\n\nconst char* DynamicLoader::LastError()\n{\n  wchar_t lpMsgBuf[DYNLOAD_ERROR_BUFFER_SIZE + 1];\n\n  DWORD error = GetLastError();\n  DWORD length = FormatMessageW(\n    FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS, nullptr, error,\n    MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language\n    lpMsgBuf, DYNLOAD_ERROR_BUFFER_SIZE, nullptr);\n\n  static char str[DYNLOAD_ERROR_BUFFER_SIZE + 1];\n\n  if (length < 1) {\n    /* FormatMessage failed.  Use a default message.  */\n    _snprintf(str, DYNLOAD_ERROR_BUFFER_SIZE,\n              \"DynamicLoader encountered error 0x%X.  \"\n              \"FormatMessage failed with error 0x%X\",\n              error, GetLastError());\n    return str;\n  }\n\n  if (!WideCharToMultiByte(CP_UTF8, 0, lpMsgBuf, -1, str,\n                           DYNLOAD_ERROR_BUFFER_SIZE, nullptr, nullptr)) {\n    /* WideCharToMultiByte failed.  Use a default message.  */\n    _snprintf(str, DYNLOAD_ERROR_BUFFER_SIZE,\n              \"DynamicLoader encountered error 0x%X.  \"\n              \"WideCharToMultiByte failed with error 0x%X\",\n              error, GetLastError());\n  }\n\n  return str;\n}\n\n} // namespace KWSYS_NAMESPACE\n\n#elif defined(__BEOS__)\n// Implementation for BeOS / Haiku\n#  include <string.h> // for strerror()\n\n#  include <be/kernel/image.h>\n#  include <be/support/Errors.h>\n\nnamespace KWSYS_NAMESPACE {\n\nstatic image_id last_dynamic_err = B_OK;\n\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(\n  const std::string& libname, int flags)\n{\n  CHECK_OPEN_FLAGS(flags, 0, 0);\n\n  // image_id's are integers, errors are negative. Add one just in case we\n  //  get a valid image_id of zero (is that even possible?).\n  image_id rc = load_add_on(libname.c_str());\n  if (rc < 0) {\n    last_dynamic_err = rc;\n    return 0;\n  }\n\n  return rc + 1;\n}\n\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  if (!lib) {\n    last_dynamic_err = B_BAD_VALUE;\n    return 0;\n  } else {\n    // The function dlclose() returns 0 on success, and non-zero on error.\n    status_t rc = unload_add_on(lib - 1);\n    if (rc != B_OK) {\n      last_dynamic_err = rc;\n      return 0;\n    }\n  }\n\n  return 1;\n}\n\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const std::string& sym)\n{\n  // Hack to cast pointer-to-data to pointer-to-function.\n  union\n  {\n    void* pvoid;\n    DynamicLoader::SymbolPointer psym;\n  } result;\n\n  result.psym = nullptr;\n\n  if (!lib) {\n    last_dynamic_err = B_BAD_VALUE;\n  } else {\n    // !!! FIXME: BeOS can do function-only lookups...does this ever\n    // !!! FIXME:  actually _want_ a data symbol lookup, or was this union\n    // !!! FIXME:  a leftover of dlsym()? (s/ANY/TEXT for functions only).\n    status_t rc =\n      get_image_symbol(lib - 1, sym.c_str(), B_SYMBOL_TYPE_ANY, &result.pvoid);\n    if (rc != B_OK) {\n      last_dynamic_err = rc;\n      result.psym = nullptr;\n    }\n  }\n  return result.psym;\n}\n\nconst char* DynamicLoader::LastError()\n{\n  const char* retval = strerror(last_dynamic_err);\n  last_dynamic_err = B_OK;\n  return retval;\n}\n\n} // namespace KWSYS_NAMESPACE\n\n#elif defined(__MINT__)\n// Implementation for FreeMiNT on Atari\n#  define _GNU_SOURCE /* for program_invocation_name */\n#  include <dld.h>\n#  include <errno.h>\n#  include <malloc.h>\n#  include <string.h>\n\nnamespace KWSYS_NAMESPACE {\n\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(\n  const std::string& libname, int flags)\n{\n  CHECK_OPEN_FLAGS(flags, 0, nullptr);\n\n  char* name = (char*)calloc(1, libname.size() + 1);\n  dld_init(program_invocation_name);\n  strncpy(name, libname.c_str(), libname.size());\n  dld_link(libname.c_str());\n  return (void*)name;\n}\n\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  dld_unlink_by_file((char*)lib, 0);\n  free(lib);\n  return 0;\n}\n\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const std::string& sym)\n{\n  // Hack to cast pointer-to-data to pointer-to-function.\n  union\n  {\n    void* pvoid;\n    DynamicLoader::SymbolPointer psym;\n  } result;\n  result.pvoid = dld_get_symbol(sym.c_str());\n  return result.psym;\n}\n\nconst char* DynamicLoader::LastError()\n{\n  return dld_strerror(dld_errno);\n}\n\n} // namespace KWSYS_NAMESPACE\n\n#else\n// Default implementation for *NIX systems (including Mac OS X 10.3 and\n// later) which use dlopen\n#  include <dlfcn.h>\n\nnamespace KWSYS_NAMESPACE {\n\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(\n  const std::string& libname, int flags)\n{\n  CHECK_OPEN_FLAGS(flags, 0, nullptr);\n\n  return dlopen(libname.c_str(), RTLD_LAZY);\n}\n\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  if (lib) {\n    // The function dlclose() returns 0 on success, and non-zero on error.\n    return !dlclose(lib);\n  }\n  // else\n  return 0;\n}\n\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const std::string& sym)\n{\n  // Hack to cast pointer-to-data to pointer-to-function.\n  union\n  {\n    void* pvoid;\n    DynamicLoader::SymbolPointer psym;\n  } result;\n  result.pvoid = dlsym(lib, sym.c_str());\n  return result.psym;\n}\n\nconst char* DynamicLoader::LastError()\n{\n  return dlerror();\n}\n\n} // namespace KWSYS_NAMESPACE\n#endif\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/CMakeLogo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Help/guide/user-interaction/GUI-Source-Binary.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Help/guide/user-interaction/GUI-Add-Entry.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Help/guide/user-interaction/VS-Choose-Arch.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Help/guide/user-interaction/GUI-Configure-Dialog.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Help/guide/user-interaction/GUI-Choose-Generator.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Templates/CMakeVSMacros2.vsmacros",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Templates/CMakeVSMacros1.vsmacros",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Templates/Windows/Windows_TemporaryKey.pfx",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Templates/Windows/Logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Templates/Windows/SmallLogo44x44.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Templates/Windows/SplashScreen.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Templates/Windows/ApplicationIcon.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Templates/Windows/SmallLogo.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Templates/Windows/StoreLogo.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/CPackNSISGenerator/header-icon.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/CPackNSISGenerator/install.ico",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/CPackNSISGenerator/header-image.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/ExternalProjectLocal/Step1NoDir.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/ExternalProjectLocal/Step1.zip",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/ExternalProjectLocal/Step1.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/ExternalProjectLocal/Step1NoDir.zip",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/ExternalProjectLocal/Step1NoDir.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/ExternalProjectLocal/Step1.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/ExternalProject/gitrepo.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/ExternalProject/hgrepo.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/ExternalProject/gitrepo-sub.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/ExternalProject/gitrepo-sub-rec.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/ExternalProject/svnrepo.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/ExternalProject/cvsrepo.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/CFBundleTest/Localized.rsrc",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/CMakeTests/FileDownloadInput.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/CMakeTests/ELF/elf64lsb.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/CMakeTests/ELF/elf32lsb.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/CMakeTests/ELF/elf32msb.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/CMakeTests/ELF/elf64msb.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/MFC/mfc1/res/Toolbar.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/MFC/mfc1/res/mfc1Doc.ico",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/MFC/mfc1/res/mfc1.ico",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/BundleGeneratorTest/CustomVolumeIcon.icns",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/BundleGeneratorTest/BundleIcon.icns",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/StringFileTest/test.utf8",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/RunCMake/CommandLine/E_cat_good_binary_cat-stdout.txt",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/RunCMake/CommandLine/cmake_depends/test_UTF-16LE.h",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/RunCMake/CommandLine/E_cat_binary_files/binary.obj",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/RunCMake/Syntax/BOM-UTF-32-LE.cmake",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/RunCMake/Syntax/BOM-UTF-32-BE.cmake",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/RunCMake/Syntax/BOM-UTF-16-BE.cmake",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/RunCMake/Syntax/BOM-UTF-16-LE.cmake",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/RunCMake/configure_file/UTF32LE-BOM.txt.in",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/RunCMake/configure_file/UTF16LE-BOM.txt.in",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/RunCMake/configure_file/UTF16BE-BOM.txt.in",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/RunCMake/configure_file/UTF32BE-BOM.txt.in",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/RunCMake/string/UTF-32BE.txt",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/RunCMake/string/UTF-32LE.txt",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/RunCMake/string/UTF-16BE.txt",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/RunCMake/string/UTF-16LE.txt",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/ExternalProjectUpdate/gitrepo.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/ObjectLibrary/dummy.obj",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/VSWinStorePhone/Direct3DApp1/SimplePixelShader.cso",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Direct3DApp1_TemporaryKey.pfx",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/VSWinStorePhone/Direct3DApp1/SimpleVertexShader.cso",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/Logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/SmallLogo44x44.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/SplashScreen.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/ApplicationIcon.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/SmallLogo.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/StoreLogo.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/Tiles/FlipCycleTileMedium.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/Tiles/IconicTileSmall.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/Tiles/IconicTileMediumLarge.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/Tiles/FlipCycleTileSmall.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/Tiles/FlipCycleTileLarge.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/VSXaml/VSXaml_TemporaryKey.pfx",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/VSXaml/Assets/SmallLogo.scale-100.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/VSXaml/Assets/Logo.scale-100.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/VSXaml/Assets/StoreLogo.scale-100.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Tests/VSXaml/Assets/SplashScreen.scale-100.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Utilities/Sphinx/static/cmake-logo-16.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Utilities/Sphinx/static/cmake-favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Utilities/Release/CMakeLogo.ico",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Utilities/Release/CMakeInstall.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Utilities/Release/WiX/ui_dialog.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Utilities/Release/WiX/ui_banner.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Source/QtDialog/Plus16.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Source/QtDialog/Delete16.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Source/QtDialog/CMakeSetup128.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Source/QtDialog/CMakeSetup32.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Source/QtDialog/CMakeSetup.ico",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Source/QtDialog/CMakeSetup.icns",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Source/QtDialog/CMakeSetup64.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Source/CPack/OSXLauncherScript.scpt",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Source/kwsys/testSystemTools.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Packaging/CMakeDMGBackground.tif",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Modules/Internal/CPack/CPack.OSXScriptLauncher.rsrc.in",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Modules/Internal/CPack/CPack.DS_Store.in",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Modules/Internal/CPack/CPack.background.png.in",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Modules/Internal/CPack/CPack.OSXX11.main.scpt.in",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Modules/Internal/CPack/CPack.OSXScriptLauncher.in",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.19.4-rtdl2zdxmrkr7ayzqdfqdtwqvgfjx3xf/spack-src/Modules/Internal/CPack/CPack.VolumeIcon.icns.in"
    ],
    "total_files": 17814
}