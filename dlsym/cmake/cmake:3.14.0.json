{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Utilities/cmlibuv/src/win/dl.c": "/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#include \"uv.h\"\n#include \"internal.h\"\n\nstatic int uv__dlerror(uv_lib_t* lib, const char* filename, DWORD errorno);\n\n\nint uv_dlopen(const char* filename, uv_lib_t* lib) {\n  WCHAR filename_w[32768];\n\n  lib->handle = NULL;\n  lib->errmsg = NULL;\n\n  if (!MultiByteToWideChar(CP_UTF8,\n                           0,\n                           filename,\n                           -1,\n                           filename_w,\n                           ARRAY_SIZE(filename_w))) {\n    return uv__dlerror(lib, filename, GetLastError());\n  }\n\n  lib->handle = LoadLibraryExW(filename_w, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);\n  if (lib->handle == NULL) {\n    return uv__dlerror(lib, filename, GetLastError());\n  }\n\n  return 0;\n}\n\n\nvoid uv_dlclose(uv_lib_t* lib) {\n  if (lib->errmsg) {\n    LocalFree((void*)lib->errmsg);\n    lib->errmsg = NULL;\n  }\n\n  if (lib->handle) {\n    /* Ignore errors. No good way to signal them without leaking memory. */\n    FreeLibrary(lib->handle);\n    lib->handle = NULL;\n  }\n}\n\n\nint uv_dlsym(uv_lib_t* lib, const char* name, void** ptr) {\n  /* Cast though integer to suppress pedantic warning about forbidden cast. */\n  *ptr = (void*)(uintptr_t) GetProcAddress(lib->handle, name);\n  return uv__dlerror(lib, \"\", *ptr ? 0 : GetLastError());\n}\n\n\nconst char* uv_dlerror(const uv_lib_t* lib) {\n  return lib->errmsg ? lib->errmsg : \"no error\";\n}\n\n\nstatic void uv__format_fallback_error(uv_lib_t* lib, int errorno){\n  static const CHAR fallback_error[] = \"error: %1!d!\";\n  DWORD_PTR args[1];\n  args[0] = (DWORD_PTR) errorno;\n\n  FormatMessageA(FORMAT_MESSAGE_FROM_STRING |\n                 FORMAT_MESSAGE_ARGUMENT_ARRAY |\n                 FORMAT_MESSAGE_ALLOCATE_BUFFER,\n                 fallback_error, 0, 0,\n                 (LPSTR) &lib->errmsg,\n                 0, (va_list*) args);\n}\n\n\n\nstatic int uv__dlerror(uv_lib_t* lib, const char* filename, DWORD errorno) {\n  DWORD_PTR arg;\n  DWORD res;\n  char* msg;\n\n  if (lib->errmsg) {\n    LocalFree(lib->errmsg);\n    lib->errmsg = NULL;\n  }\n\n  if (errorno == 0)\n    return 0;\n\n  res = FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER |\n                       FORMAT_MESSAGE_FROM_SYSTEM |\n                       FORMAT_MESSAGE_IGNORE_INSERTS, NULL, errorno,\n                       MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_US),\n                       (LPSTR) &lib->errmsg, 0, NULL);\n\n  if (!res && (GetLastError() == ERROR_MUI_FILE_NOT_FOUND ||\n               GetLastError() == ERROR_RESOURCE_TYPE_NOT_FOUND)) {\n    res = FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER |\n                         FORMAT_MESSAGE_FROM_SYSTEM |\n                         FORMAT_MESSAGE_IGNORE_INSERTS, NULL, errorno,\n                         0, (LPSTR) &lib->errmsg, 0, NULL);\n  }\n\n  if (res && errorno == ERROR_BAD_EXE_FORMAT && strstr(lib->errmsg, \"%1\")) {\n    msg = lib->errmsg;\n    lib->errmsg = NULL;\n    arg = (DWORD_PTR) filename;\n    res = FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER |\n                         FORMAT_MESSAGE_ARGUMENT_ARRAY |\n                         FORMAT_MESSAGE_FROM_STRING,\n                         msg,\n                         0, 0, (LPSTR) &lib->errmsg, 0, (va_list*) &arg);\n    LocalFree(msg);\n  }\n\n  if (!res)\n    uv__format_fallback_error(lib, errorno);\n\n  return -1;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Utilities/cmlibuv/src/unix/darwin-proctitle.c": "/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#include \"uv.h\"\n#include \"internal.h\"\n\n#include <dlfcn.h>\n#include <errno.h>\n#include <stdlib.h>\n#include <string.h>\n\n#include <TargetConditionals.h>\n\n#if !TARGET_OS_IPHONE\n# include <CoreFoundation/CoreFoundation.h>\n# include <ApplicationServices/ApplicationServices.h>\n#endif\n\n#define S(s) pCFStringCreateWithCString(NULL, (s), kCFStringEncodingUTF8)\n\n\nstatic int (*dynamic_pthread_setname_np)(const char* name);\n#if !TARGET_OS_IPHONE\nstatic CFStringRef (*pCFStringCreateWithCString)(CFAllocatorRef,\n                                                 const char*,\n                                                 CFStringEncoding);\nstatic CFBundleRef (*pCFBundleGetBundleWithIdentifier)(CFStringRef);\nstatic void *(*pCFBundleGetDataPointerForName)(CFBundleRef, CFStringRef);\nstatic void *(*pCFBundleGetFunctionPointerForName)(CFBundleRef, CFStringRef);\nstatic CFTypeRef (*pLSGetCurrentApplicationASN)(void);\nstatic OSStatus (*pLSSetApplicationInformationItem)(int,\n                                                    CFTypeRef,\n                                                    CFStringRef,\n                                                    CFStringRef,\n                                                    CFDictionaryRef*);\nstatic void* application_services_handle;\nstatic void* core_foundation_handle;\nstatic CFBundleRef launch_services_bundle;\nstatic CFStringRef* display_name_key;\nstatic CFDictionaryRef (*pCFBundleGetInfoDictionary)(CFBundleRef);\nstatic CFBundleRef (*pCFBundleGetMainBundle)(void);\nstatic CFBundleRef hi_services_bundle;\nstatic OSStatus (*pSetApplicationIsDaemon)(int);\nstatic CFDictionaryRef (*pLSApplicationCheckIn)(int, CFDictionaryRef);\nstatic void (*pLSSetApplicationLaunchServicesServerConnectionStatus)(uint64_t,\n                                                                     void*);\n\n\nUV_DESTRUCTOR(static void uv__set_process_title_platform_fini(void)) {\n  if (core_foundation_handle != NULL) {\n    dlclose(core_foundation_handle);\n    core_foundation_handle = NULL;\n  }\n\n  if (application_services_handle != NULL) {\n    dlclose(application_services_handle);\n    application_services_handle = NULL;\n  }\n}\n#endif  /* !TARGET_OS_IPHONE */\n\n\nvoid uv__set_process_title_platform_init(void) {\n  /* pthread_setname_np() first appeared in OS X 10.6 and iOS 3.2. */\n  *(void **)(&dynamic_pthread_setname_np) =\n      dlsym(RTLD_DEFAULT, \"pthread_setname_np\");\n\n#if !TARGET_OS_IPHONE\n  application_services_handle = dlopen(\"/System/Library/Frameworks/\"\n                                       \"ApplicationServices.framework/\"\n                                       \"Versions/A/ApplicationServices\",\n                                       RTLD_LAZY | RTLD_LOCAL);\n  core_foundation_handle = dlopen(\"/System/Library/Frameworks/\"\n                                  \"CoreFoundation.framework/\"\n                                  \"Versions/A/CoreFoundation\",\n                                  RTLD_LAZY | RTLD_LOCAL);\n\n  if (application_services_handle == NULL || core_foundation_handle == NULL)\n    goto out;\n\n  *(void **)(&pCFStringCreateWithCString) =\n      dlsym(core_foundation_handle, \"CFStringCreateWithCString\");\n  *(void **)(&pCFBundleGetBundleWithIdentifier) =\n      dlsym(core_foundation_handle, \"CFBundleGetBundleWithIdentifier\");\n  *(void **)(&pCFBundleGetDataPointerForName) =\n      dlsym(core_foundation_handle, \"CFBundleGetDataPointerForName\");\n  *(void **)(&pCFBundleGetFunctionPointerForName) =\n      dlsym(core_foundation_handle, \"CFBundleGetFunctionPointerForName\");\n\n  if (pCFStringCreateWithCString == NULL ||\n      pCFBundleGetBundleWithIdentifier == NULL ||\n      pCFBundleGetDataPointerForName == NULL ||\n      pCFBundleGetFunctionPointerForName == NULL) {\n    goto out;\n  }\n\n  launch_services_bundle =\n      pCFBundleGetBundleWithIdentifier(S(\"com.apple.LaunchServices\"));\n\n  if (launch_services_bundle == NULL)\n    goto out;\n\n  *(void **)(&pLSGetCurrentApplicationASN) =\n      pCFBundleGetFunctionPointerForName(launch_services_bundle,\n                                         S(\"_LSGetCurrentApplicationASN\"));\n\n  if (pLSGetCurrentApplicationASN == NULL)\n    goto out;\n\n  *(void **)(&pLSSetApplicationInformationItem) =\n      pCFBundleGetFunctionPointerForName(launch_services_bundle,\n                                         S(\"_LSSetApplicationInformationItem\"));\n\n  if (pLSSetApplicationInformationItem == NULL)\n    goto out;\n\n  display_name_key = pCFBundleGetDataPointerForName(launch_services_bundle,\n                                                    S(\"_kLSDisplayNameKey\"));\n\n  if (display_name_key == NULL || *display_name_key == NULL)\n    goto out;\n\n  *(void **)(&pCFBundleGetInfoDictionary) = dlsym(core_foundation_handle,\n                                     \"CFBundleGetInfoDictionary\");\n  *(void **)(&pCFBundleGetMainBundle) = dlsym(core_foundation_handle,\n                                 \"CFBundleGetMainBundle\");\n\n  if (pCFBundleGetInfoDictionary == NULL || pCFBundleGetMainBundle == NULL)\n    goto out;\n\n  /* Black 10.9 magic, to remove (Not responding) mark in Activity Monitor */\n  hi_services_bundle =\n      pCFBundleGetBundleWithIdentifier(S(\"com.apple.HIServices\"));\n\n  if (hi_services_bundle == NULL)\n    goto out;\n\n  *(void **)(&pSetApplicationIsDaemon) = pCFBundleGetFunctionPointerForName(\n      hi_services_bundle,\n      S(\"SetApplicationIsDaemon\"));\n  *(void **)(&pLSApplicationCheckIn) = pCFBundleGetFunctionPointerForName(\n      launch_services_bundle,\n      S(\"_LSApplicationCheckIn\"));\n  *(void **)(&pLSSetApplicationLaunchServicesServerConnectionStatus) =\n      pCFBundleGetFunctionPointerForName(\n          launch_services_bundle,\n          S(\"_LSSetApplicationLaunchServicesServerConnectionStatus\"));\n\n  if (pSetApplicationIsDaemon == NULL ||\n      pLSApplicationCheckIn == NULL ||\n      pLSSetApplicationLaunchServicesServerConnectionStatus == NULL) {\n    goto out;\n  }\n\n  return;\n\nout:\n  uv__set_process_title_platform_fini();\n#endif  /* !TARGET_OS_IPHONE */\n}\n\n\nvoid uv__set_process_title(const char* title) {\n#if !TARGET_OS_IPHONE\n  if (core_foundation_handle != NULL && pSetApplicationIsDaemon(1) != noErr) {\n    CFTypeRef asn;\n    pLSSetApplicationLaunchServicesServerConnectionStatus(0, NULL);\n    pLSApplicationCheckIn(/* Magic value */ -2,\n                          pCFBundleGetInfoDictionary(pCFBundleGetMainBundle()));\n    asn = pLSGetCurrentApplicationASN();\n    pLSSetApplicationInformationItem(/* Magic value */ -2, asn,\n                                     *display_name_key, S(title), NULL);\n  }\n#endif  /* !TARGET_OS_IPHONE */\n\n  if (dynamic_pthread_setname_np != NULL) {\n    char namebuf[64];  /* MAXTHREADNAMESIZE */\n    uv__strscpy(namebuf, title, sizeof(namebuf));\n    dynamic_pthread_setname_np(namebuf);\n  }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Utilities/cmlibuv/src/unix/fsevents.c": "/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#include \"uv.h\"\n#include \"internal.h\"\n\n#if TARGET_OS_IPHONE\n\n/* iOS (currently) doesn't provide the FSEvents-API (nor CoreServices) */\n\nint uv__fsevents_init(uv_fs_event_t* handle) {\n  return 0;\n}\n\n\nint uv__fsevents_close(uv_fs_event_t* handle) {\n  return 0;\n}\n\n\nvoid uv__fsevents_loop_delete(uv_loop_t* loop) {\n}\n\n#else /* TARGET_OS_IPHONE */\n\n#include <dlfcn.h>\n#include <assert.h>\n#include <stdlib.h>\n#include <pthread.h>\n\n#include <CoreFoundation/CFRunLoop.h>\n#include <CoreServices/CoreServices.h>\n\n/* These are macros to avoid \"initializer element is not constant\" errors\n * with old versions of gcc.\n */\n#define kFSEventsModified (kFSEventStreamEventFlagItemFinderInfoMod |         \\\n                           kFSEventStreamEventFlagItemModified |              \\\n                           kFSEventStreamEventFlagItemInodeMetaMod |          \\\n                           kFSEventStreamEventFlagItemChangeOwner |           \\\n                           kFSEventStreamEventFlagItemXattrMod)\n\n#define kFSEventsRenamed  (kFSEventStreamEventFlagItemCreated |               \\\n                           kFSEventStreamEventFlagItemRemoved |               \\\n                           kFSEventStreamEventFlagItemRenamed)\n\n#define kFSEventsSystem   (kFSEventStreamEventFlagUserDropped |               \\\n                           kFSEventStreamEventFlagKernelDropped |             \\\n                           kFSEventStreamEventFlagEventIdsWrapped |           \\\n                           kFSEventStreamEventFlagHistoryDone |               \\\n                           kFSEventStreamEventFlagMount |                     \\\n                           kFSEventStreamEventFlagUnmount |                   \\\n                           kFSEventStreamEventFlagRootChanged)\n\ntypedef struct uv__fsevents_event_s uv__fsevents_event_t;\ntypedef struct uv__cf_loop_signal_s uv__cf_loop_signal_t;\ntypedef struct uv__cf_loop_state_s uv__cf_loop_state_t;\n\nenum uv__cf_loop_signal_type_e {\n  kUVCFLoopSignalRegular,\n  kUVCFLoopSignalClosing\n};\ntypedef enum uv__cf_loop_signal_type_e uv__cf_loop_signal_type_t;\n\nstruct uv__cf_loop_signal_s {\n  QUEUE member;\n  uv_fs_event_t* handle;\n  uv__cf_loop_signal_type_t type;\n};\n\nstruct uv__fsevents_event_s {\n  QUEUE member;\n  int events;\n  char path[1];\n};\n\nstruct uv__cf_loop_state_s {\n  CFRunLoopRef loop;\n  CFRunLoopSourceRef signal_source;\n  int fsevent_need_reschedule;\n  FSEventStreamRef fsevent_stream;\n  uv_sem_t fsevent_sem;\n  uv_mutex_t fsevent_mutex;\n  void* fsevent_handles[2];\n  unsigned int fsevent_handle_count;\n};\n\n/* Forward declarations */\nstatic void uv__cf_loop_cb(void* arg);\nstatic void* uv__cf_loop_runner(void* arg);\nstatic int uv__cf_loop_signal(uv_loop_t* loop,\n                              uv_fs_event_t* handle,\n                              uv__cf_loop_signal_type_t type);\n\n/* Lazy-loaded by uv__fsevents_global_init(). */\nstatic CFArrayRef (*pCFArrayCreate)(CFAllocatorRef,\n                                    const void**,\n                                    CFIndex,\n                                    const CFArrayCallBacks*);\nstatic void (*pCFRelease)(CFTypeRef);\nstatic void (*pCFRunLoopAddSource)(CFRunLoopRef,\n                                   CFRunLoopSourceRef,\n                                   CFStringRef);\nstatic CFRunLoopRef (*pCFRunLoopGetCurrent)(void);\nstatic void (*pCFRunLoopRemoveSource)(CFRunLoopRef,\n                                      CFRunLoopSourceRef,\n                                      CFStringRef);\nstatic void (*pCFRunLoopRun)(void);\nstatic CFRunLoopSourceRef (*pCFRunLoopSourceCreate)(CFAllocatorRef,\n                                                    CFIndex,\n                                                    CFRunLoopSourceContext*);\nstatic void (*pCFRunLoopSourceSignal)(CFRunLoopSourceRef);\nstatic void (*pCFRunLoopStop)(CFRunLoopRef);\nstatic void (*pCFRunLoopWakeUp)(CFRunLoopRef);\nstatic CFStringRef (*pCFStringCreateWithFileSystemRepresentation)(\n    CFAllocatorRef,\n    const char*);\nstatic CFStringEncoding (*pCFStringGetSystemEncoding)(void);\nstatic CFStringRef (*pkCFRunLoopDefaultMode);\nstatic FSEventStreamRef (*pFSEventStreamCreate)(CFAllocatorRef,\n                                                FSEventStreamCallback,\n                                                FSEventStreamContext*,\n                                                CFArrayRef,\n                                                FSEventStreamEventId,\n                                                CFTimeInterval,\n                                                FSEventStreamCreateFlags);\nstatic void (*pFSEventStreamFlushSync)(FSEventStreamRef);\nstatic void (*pFSEventStreamInvalidate)(FSEventStreamRef);\nstatic void (*pFSEventStreamRelease)(FSEventStreamRef);\nstatic void (*pFSEventStreamScheduleWithRunLoop)(FSEventStreamRef,\n                                                 CFRunLoopRef,\n                                                 CFStringRef);\nstatic Boolean (*pFSEventStreamStart)(FSEventStreamRef);\nstatic void (*pFSEventStreamStop)(FSEventStreamRef);\n\n#define UV__FSEVENTS_PROCESS(handle, block)                                   \\\n    do {                                                                      \\\n      QUEUE events;                                                           \\\n      QUEUE* q;                                                               \\\n      uv__fsevents_event_t* event;                                            \\\n      int err;                                                                \\\n      uv_mutex_lock(&(handle)->cf_mutex);                                     \\\n      /* Split-off all events and empty original queue */                     \\\n      QUEUE_MOVE(&(handle)->cf_events, &events);                              \\\n      /* Get error (if any) and zero original one */                          \\\n      err = (handle)->cf_error;                                               \\\n      (handle)->cf_error = 0;                                                 \\\n      uv_mutex_unlock(&(handle)->cf_mutex);                                   \\\n      /* Loop through events, deallocating each after processing */           \\\n      while (!QUEUE_EMPTY(&events)) {                                         \\\n        q = QUEUE_HEAD(&events);                                              \\\n        event = QUEUE_DATA(q, uv__fsevents_event_t, member);                  \\\n        QUEUE_REMOVE(q);                                                      \\\n        /* NOTE: Checking uv__is_active() is required here, because handle    \\\n         * callback may close handle and invoking it after it will lead to    \\\n         * incorrect behaviour */                                             \\\n        if (!uv__is_closing((handle)) && uv__is_active((handle)))             \\\n          block                                                               \\\n        /* Free allocated data */                                             \\\n        uv__free(event);                                                      \\\n      }                                                                       \\\n      if (err != 0 && !uv__is_closing((handle)) && uv__is_active((handle)))   \\\n        (handle)->cb((handle), NULL, 0, err);                                 \\\n    } while (0)\n\n\n/* Runs in UV loop's thread, when there're events to report to handle */\nstatic void uv__fsevents_cb(uv_async_t* cb) {\n  uv_fs_event_t* handle;\n\n  handle = cb->data;\n\n  UV__FSEVENTS_PROCESS(handle, {\n    handle->cb(handle, event->path[0] ? event->path : NULL, event->events, 0);\n  });\n}\n\n\n/* Runs in CF thread, pushed event into handle's event list */\nstatic void uv__fsevents_push_event(uv_fs_event_t* handle,\n                                    QUEUE* events,\n                                    int err) {\n  assert(events != NULL || err != 0);\n  uv_mutex_lock(&handle->cf_mutex);\n\n  /* Concatenate two queues */\n  if (events != NULL)\n    QUEUE_ADD(&handle->cf_events, events);\n\n  /* Propagate error */\n  if (err != 0)\n    handle->cf_error = err;\n  uv_mutex_unlock(&handle->cf_mutex);\n\n  uv_async_send(handle->cf_cb);\n}\n\n\n/* Runs in CF thread, when there're events in FSEventStream */\nstatic void uv__fsevents_event_cb(ConstFSEventStreamRef streamRef,\n                                  void* info,\n                                  size_t numEvents,\n                                  void* eventPaths,\n                                  const FSEventStreamEventFlags eventFlags[],\n                                  const FSEventStreamEventId eventIds[]) {\n  size_t i;\n  int len;\n  char** paths;\n  char* path;\n  char* pos;\n  uv_fs_event_t* handle;\n  QUEUE* q;\n  uv_loop_t* loop;\n  uv__cf_loop_state_t* state;\n  uv__fsevents_event_t* event;\n  FSEventStreamEventFlags flags;\n  QUEUE head;\n\n  loop = info;\n  state = loop->cf_state;\n  assert(state != NULL);\n  paths = eventPaths;\n\n  /* For each handle */\n  uv_mutex_lock(&state->fsevent_mutex);\n  QUEUE_FOREACH(q, &state->fsevent_handles) {\n    handle = QUEUE_DATA(q, uv_fs_event_t, cf_member);\n    QUEUE_INIT(&head);\n\n    /* Process and filter out events */\n    for (i = 0; i < numEvents; i++) {\n      flags = eventFlags[i];\n\n      /* Ignore system events */\n      if (flags & kFSEventsSystem)\n        continue;\n\n      path = paths[i];\n      len = strlen(path);\n\n      if (handle->realpath_len == 0)\n        continue; /* This should be unreachable */\n\n      /* Filter out paths that are outside handle's request */\n      if (len < handle->realpath_len)\n        continue;\n\n      if (handle->realpath_len != len &&\n          path[handle->realpath_len] != '/')\n        /* Make sure that realpath actually named a directory,\n         * or that we matched the whole string */\n        continue;\n\n      if (memcmp(path, handle->realpath, handle->realpath_len) != 0)\n        continue;\n\n      if (!(handle->realpath_len == 1 && handle->realpath[0] == '/')) {\n        /* Remove common prefix, unless the watched folder is \"/\" */\n        path += handle->realpath_len;\n        len -= handle->realpath_len;\n\n        /* Ignore events with path equal to directory itself */\n        if (len <= 1 && (flags & kFSEventStreamEventFlagItemIsDir))\n          continue;\n\n        if (len == 0) {\n          /* Since we're using fsevents to watch the file itself,\n           * realpath == path, and we now need to get the basename of the file back\n           * (for commonality with other codepaths and platforms). */\n          while (len < handle->realpath_len && path[-1] != '/') {\n            path--;\n            len++;\n          }\n          /* Created and Removed seem to be always set, but don't make sense */\n          flags &= ~kFSEventsRenamed;\n        } else {\n          /* Skip forward slash */\n          path++;\n          len--;\n        }\n      }\n\n      /* Do not emit events from subdirectories (without option set) */\n      if ((handle->cf_flags & UV_FS_EVENT_RECURSIVE) == 0 && *path != '\\0') {\n        pos = strchr(path + 1, '/');\n        if (pos != NULL)\n          continue;\n      }\n\n      event = uv__malloc(sizeof(*event) + len);\n      if (event == NULL)\n        break;\n\n      memset(event, 0, sizeof(*event));\n      memcpy(event->path, path, len + 1);\n      event->events = UV_RENAME;\n\n      if (0 == (flags & kFSEventsRenamed)) {\n        if (0 != (flags & kFSEventsModified) ||\n            0 == (flags & kFSEventStreamEventFlagItemIsDir))\n          event->events = UV_CHANGE;\n      }\n\n      QUEUE_INSERT_TAIL(&head, &event->member);\n    }\n\n    if (!QUEUE_EMPTY(&head))\n      uv__fsevents_push_event(handle, &head, 0);\n  }\n  uv_mutex_unlock(&state->fsevent_mutex);\n}\n\n\n/* Runs in CF thread */\nstatic int uv__fsevents_create_stream(uv_loop_t* loop, CFArrayRef paths) {\n  uv__cf_loop_state_t* state;\n  FSEventStreamContext ctx;\n  FSEventStreamRef ref;\n  CFAbsoluteTime latency;\n  FSEventStreamCreateFlags flags;\n\n  /* Initialize context */\n  ctx.version = 0;\n  ctx.info = loop;\n  ctx.retain = NULL;\n  ctx.release = NULL;\n  ctx.copyDescription = NULL;\n\n  latency = 0.05;\n\n  /* Explanation of selected flags:\n   * 1. NoDefer - without this flag, events that are happening continuously\n   *    (i.e. each event is happening after time interval less than `latency`,\n   *    counted from previous event), will be deferred and passed to callback\n   *    once they'll either fill whole OS buffer, or when this continuous stream\n   *    will stop (i.e. there'll be delay between events, bigger than\n   *    `latency`).\n   *    Specifying this flag will invoke callback after `latency` time passed\n   *    since event.\n   * 2. FileEvents - fire callback for file changes too (by default it is firing\n   *    it only for directory changes).\n   */\n  flags = kFSEventStreamCreateFlagNoDefer | kFSEventStreamCreateFlagFileEvents;\n\n  /*\n   * NOTE: It might sound like a good idea to remember last seen StreamEventId,\n   * but in reality one dir might have last StreamEventId less than, the other,\n   * that is being watched now. Which will cause FSEventStream API to report\n   * changes to files from the past.\n   */\n  ref = pFSEventStreamCreate(NULL,\n                             &uv__fsevents_event_cb,\n                             &ctx,\n                             paths,\n                             kFSEventStreamEventIdSinceNow,\n                             latency,\n                             flags);\n  assert(ref != NULL);\n\n  state = loop->cf_state;\n  pFSEventStreamScheduleWithRunLoop(ref,\n                                    state->loop,\n                                    *pkCFRunLoopDefaultMode);\n  if (!pFSEventStreamStart(ref)) {\n    pFSEventStreamInvalidate(ref);\n    pFSEventStreamRelease(ref);\n    return UV_EMFILE;\n  }\n\n  state->fsevent_stream = ref;\n  return 0;\n}\n\n\n/* Runs in CF thread */\nstatic void uv__fsevents_destroy_stream(uv_loop_t* loop) {\n  uv__cf_loop_state_t* state;\n\n  state = loop->cf_state;\n\n  if (state->fsevent_stream == NULL)\n    return;\n\n  /* Stop emitting events */\n  pFSEventStreamStop(state->fsevent_stream);\n\n  /* Release stream */\n  pFSEventStreamInvalidate(state->fsevent_stream);\n  pFSEventStreamRelease(state->fsevent_stream);\n  state->fsevent_stream = NULL;\n}\n\n\n/* Runs in CF thread, when there're new fsevent handles to add to stream */\nstatic void uv__fsevents_reschedule(uv_fs_event_t* handle,\n                                    uv__cf_loop_signal_type_t type) {\n  uv__cf_loop_state_t* state;\n  QUEUE* q;\n  uv_fs_event_t* curr;\n  CFArrayRef cf_paths;\n  CFStringRef* paths;\n  unsigned int i;\n  int err;\n  unsigned int path_count;\n\n  state = handle->loop->cf_state;\n  paths = NULL;\n  cf_paths = NULL;\n  err = 0;\n  /* NOTE: `i` is used in deallocation loop below */\n  i = 0;\n\n  /* Optimization to prevent O(n^2) time spent when starting to watch\n   * many files simultaneously\n   */\n  uv_mutex_lock(&state->fsevent_mutex);\n  if (state->fsevent_need_reschedule == 0) {\n    uv_mutex_unlock(&state->fsevent_mutex);\n    goto final;\n  }\n  state->fsevent_need_reschedule = 0;\n  uv_mutex_unlock(&state->fsevent_mutex);\n\n  /* Destroy previous FSEventStream */\n  uv__fsevents_destroy_stream(handle->loop);\n\n  /* Any failure below will be a memory failure */\n  err = UV_ENOMEM;\n\n  /* Create list of all watched paths */\n  uv_mutex_lock(&state->fsevent_mutex);\n  path_count = state->fsevent_handle_count;\n  if (path_count != 0) {\n    paths = uv__malloc(sizeof(*paths) * path_count);\n    if (paths == NULL) {\n      uv_mutex_unlock(&state->fsevent_mutex);\n      goto final;\n    }\n\n    q = &state->fsevent_handles;\n    for (; i < path_count; i++) {\n      q = QUEUE_NEXT(q);\n      assert(q != &state->fsevent_handles);\n      curr = QUEUE_DATA(q, uv_fs_event_t, cf_member);\n\n      assert(curr->realpath != NULL);\n      paths[i] =\n          pCFStringCreateWithFileSystemRepresentation(NULL, curr->realpath);\n      if (paths[i] == NULL) {\n        uv_mutex_unlock(&state->fsevent_mutex);\n        goto final;\n      }\n    }\n  }\n  uv_mutex_unlock(&state->fsevent_mutex);\n  err = 0;\n\n  if (path_count != 0) {\n    /* Create new FSEventStream */\n    cf_paths = pCFArrayCreate(NULL, (const void**) paths, path_count, NULL);\n    if (cf_paths == NULL) {\n      err = UV_ENOMEM;\n      goto final;\n    }\n    err = uv__fsevents_create_stream(handle->loop, cf_paths);\n  }\n\nfinal:\n  /* Deallocate all paths in case of failure */\n  if (err != 0) {\n    if (cf_paths == NULL) {\n      while (i != 0)\n        pCFRelease(paths[--i]);\n      uv__free(paths);\n    } else {\n      /* CFArray takes ownership of both strings and original C-array */\n      pCFRelease(cf_paths);\n    }\n\n    /* Broadcast error to all handles */\n    uv_mutex_lock(&state->fsevent_mutex);\n    QUEUE_FOREACH(q, &state->fsevent_handles) {\n      curr = QUEUE_DATA(q, uv_fs_event_t, cf_member);\n      uv__fsevents_push_event(curr, NULL, err);\n    }\n    uv_mutex_unlock(&state->fsevent_mutex);\n  }\n\n  /*\n   * Main thread will block until the removal of handle from the list,\n   * we must tell it when we're ready.\n   *\n   * NOTE: This is coupled with `uv_sem_wait()` in `uv__fsevents_close`\n   */\n  if (type == kUVCFLoopSignalClosing)\n    uv_sem_post(&state->fsevent_sem);\n}\n\n\nstatic int uv__fsevents_global_init(void) {\n  static pthread_mutex_t global_init_mutex = PTHREAD_MUTEX_INITIALIZER;\n  static void* core_foundation_handle;\n  static void* core_services_handle;\n  int err;\n\n  err = 0;\n  pthread_mutex_lock(&global_init_mutex);\n  if (core_foundation_handle != NULL)\n    goto out;\n\n  /* The libraries are never unloaded because we currently don't have a good\n   * mechanism for keeping a reference count. It's unlikely to be an issue\n   * but if it ever becomes one, we can turn the dynamic library handles into\n   * per-event loop properties and have the dynamic linker keep track for us.\n   */\n  err = UV_ENOSYS;\n  core_foundation_handle = dlopen(\"/System/Library/Frameworks/\"\n                                  \"CoreFoundation.framework/\"\n                                  \"Versions/A/CoreFoundation\",\n                                  RTLD_LAZY | RTLD_LOCAL);\n  if (core_foundation_handle == NULL)\n    goto out;\n\n  core_services_handle = dlopen(\"/System/Library/Frameworks/\"\n                                \"CoreServices.framework/\"\n                                \"Versions/A/CoreServices\",\n                                RTLD_LAZY | RTLD_LOCAL);\n  if (core_services_handle == NULL)\n    goto out;\n\n  err = UV_ENOENT;\n#define V(handle, symbol)                                                     \\\n  do {                                                                        \\\n    *(void **)(&p ## symbol) = dlsym((handle), #symbol);                      \\\n    if (p ## symbol == NULL)                                                  \\\n      goto out;                                                               \\\n  }                                                                           \\\n  while (0)\n  V(core_foundation_handle, CFArrayCreate);\n  V(core_foundation_handle, CFRelease);\n  V(core_foundation_handle, CFRunLoopAddSource);\n  V(core_foundation_handle, CFRunLoopGetCurrent);\n  V(core_foundation_handle, CFRunLoopRemoveSource);\n  V(core_foundation_handle, CFRunLoopRun);\n  V(core_foundation_handle, CFRunLoopSourceCreate);\n  V(core_foundation_handle, CFRunLoopSourceSignal);\n  V(core_foundation_handle, CFRunLoopStop);\n  V(core_foundation_handle, CFRunLoopWakeUp);\n  V(core_foundation_handle, CFStringCreateWithFileSystemRepresentation);\n  V(core_foundation_handle, CFStringGetSystemEncoding);\n  V(core_foundation_handle, kCFRunLoopDefaultMode);\n  V(core_services_handle, FSEventStreamCreate);\n  V(core_services_handle, FSEventStreamFlushSync);\n  V(core_services_handle, FSEventStreamInvalidate);\n  V(core_services_handle, FSEventStreamRelease);\n  V(core_services_handle, FSEventStreamScheduleWithRunLoop);\n  V(core_services_handle, FSEventStreamStart);\n  V(core_services_handle, FSEventStreamStop);\n#undef V\n  err = 0;\n\nout:\n  if (err && core_services_handle != NULL) {\n    dlclose(core_services_handle);\n    core_services_handle = NULL;\n  }\n\n  if (err && core_foundation_handle != NULL) {\n    dlclose(core_foundation_handle);\n    core_foundation_handle = NULL;\n  }\n\n  pthread_mutex_unlock(&global_init_mutex);\n  return err;\n}\n\n\n/* Runs in UV loop */\nstatic int uv__fsevents_loop_init(uv_loop_t* loop) {\n  CFRunLoopSourceContext ctx;\n  uv__cf_loop_state_t* state;\n  pthread_attr_t attr_storage;\n  pthread_attr_t* attr;\n  int err;\n\n  if (loop->cf_state != NULL)\n    return 0;\n\n  err = uv__fsevents_global_init();\n  if (err)\n    return err;\n\n  state = uv__calloc(1, sizeof(*state));\n  if (state == NULL)\n    return UV_ENOMEM;\n\n  err = uv_mutex_init(&loop->cf_mutex);\n  if (err)\n    goto fail_mutex_init;\n\n  err = uv_sem_init(&loop->cf_sem, 0);\n  if (err)\n    goto fail_sem_init;\n\n  QUEUE_INIT(&loop->cf_signals);\n\n  err = uv_sem_init(&state->fsevent_sem, 0);\n  if (err)\n    goto fail_fsevent_sem_init;\n\n  err = uv_mutex_init(&state->fsevent_mutex);\n  if (err)\n    goto fail_fsevent_mutex_init;\n\n  QUEUE_INIT(&state->fsevent_handles);\n  state->fsevent_need_reschedule = 0;\n  state->fsevent_handle_count = 0;\n\n  memset(&ctx, 0, sizeof(ctx));\n  ctx.info = loop;\n  ctx.perform = uv__cf_loop_cb;\n  state->signal_source = pCFRunLoopSourceCreate(NULL, 0, &ctx);\n  if (state->signal_source == NULL) {\n    err = UV_ENOMEM;\n    goto fail_signal_source_create;\n  }\n\n  /* In the unlikely event that pthread_attr_init() fails, create the thread\n   * with the default stack size. We'll use a little more address space but\n   * that in itself is not a fatal error.\n   */\n  attr = &attr_storage;\n  if (pthread_attr_init(attr))\n    attr = NULL;\n\n  if (attr != NULL)\n    if (pthread_attr_setstacksize(attr, 4 * PTHREAD_STACK_MIN))\n      abort();\n\n  loop->cf_state = state;\n\n  /* uv_thread_t is an alias for pthread_t. */\n  err = UV__ERR(pthread_create(&loop->cf_thread, attr, uv__cf_loop_runner, loop));\n\n  if (attr != NULL)\n    pthread_attr_destroy(attr);\n\n  if (err)\n    goto fail_thread_create;\n\n  /* Synchronize threads */\n  uv_sem_wait(&loop->cf_sem);\n  return 0;\n\nfail_thread_create:\n  loop->cf_state = NULL;\n\nfail_signal_source_create:\n  uv_mutex_destroy(&state->fsevent_mutex);\n\nfail_fsevent_mutex_init:\n  uv_sem_destroy(&state->fsevent_sem);\n\nfail_fsevent_sem_init:\n  uv_sem_destroy(&loop->cf_sem);\n\nfail_sem_init:\n  uv_mutex_destroy(&loop->cf_mutex);\n\nfail_mutex_init:\n  uv__free(state);\n  return err;\n}\n\n\n/* Runs in UV loop */\nvoid uv__fsevents_loop_delete(uv_loop_t* loop) {\n  uv__cf_loop_signal_t* s;\n  uv__cf_loop_state_t* state;\n  QUEUE* q;\n\n  if (loop->cf_state == NULL)\n    return;\n\n  if (uv__cf_loop_signal(loop, NULL, kUVCFLoopSignalRegular) != 0)\n    abort();\n\n  uv_thread_join(&loop->cf_thread);\n  uv_sem_destroy(&loop->cf_sem);\n  uv_mutex_destroy(&loop->cf_mutex);\n\n  /* Free any remaining data */\n  while (!QUEUE_EMPTY(&loop->cf_signals)) {\n    q = QUEUE_HEAD(&loop->cf_signals);\n    s = QUEUE_DATA(q, uv__cf_loop_signal_t, member);\n    QUEUE_REMOVE(q);\n    uv__free(s);\n  }\n\n  /* Destroy state */\n  state = loop->cf_state;\n  uv_sem_destroy(&state->fsevent_sem);\n  uv_mutex_destroy(&state->fsevent_mutex);\n  pCFRelease(state->signal_source);\n  uv__free(state);\n  loop->cf_state = NULL;\n}\n\n\n/* Runs in CF thread. This is the CF loop's body */\nstatic void* uv__cf_loop_runner(void* arg) {\n  uv_loop_t* loop;\n  uv__cf_loop_state_t* state;\n\n  loop = arg;\n  state = loop->cf_state;\n  state->loop = pCFRunLoopGetCurrent();\n\n  pCFRunLoopAddSource(state->loop,\n                      state->signal_source,\n                      *pkCFRunLoopDefaultMode);\n\n  uv_sem_post(&loop->cf_sem);\n\n  pCFRunLoopRun();\n  pCFRunLoopRemoveSource(state->loop,\n                         state->signal_source,\n                         *pkCFRunLoopDefaultMode);\n\n  return NULL;\n}\n\n\n/* Runs in CF thread, executed after `uv__cf_loop_signal()` */\nstatic void uv__cf_loop_cb(void* arg) {\n  uv_loop_t* loop;\n  uv__cf_loop_state_t* state;\n  QUEUE* item;\n  QUEUE split_head;\n  uv__cf_loop_signal_t* s;\n\n  loop = arg;\n  state = loop->cf_state;\n\n  uv_mutex_lock(&loop->cf_mutex);\n  QUEUE_MOVE(&loop->cf_signals, &split_head);\n  uv_mutex_unlock(&loop->cf_mutex);\n\n  while (!QUEUE_EMPTY(&split_head)) {\n    item = QUEUE_HEAD(&split_head);\n    QUEUE_REMOVE(item);\n\n    s = QUEUE_DATA(item, uv__cf_loop_signal_t, member);\n\n    /* This was a termination signal */\n    if (s->handle == NULL)\n      pCFRunLoopStop(state->loop);\n    else\n      uv__fsevents_reschedule(s->handle, s->type);\n\n    uv__free(s);\n  }\n}\n\n\n/* Runs in UV loop to notify CF thread */\nint uv__cf_loop_signal(uv_loop_t* loop,\n                       uv_fs_event_t* handle,\n                       uv__cf_loop_signal_type_t type) {\n  uv__cf_loop_signal_t* item;\n  uv__cf_loop_state_t* state;\n\n  item = uv__malloc(sizeof(*item));\n  if (item == NULL)\n    return UV_ENOMEM;\n\n  item->handle = handle;\n  item->type = type;\n\n  uv_mutex_lock(&loop->cf_mutex);\n  QUEUE_INSERT_TAIL(&loop->cf_signals, &item->member);\n  uv_mutex_unlock(&loop->cf_mutex);\n\n  state = loop->cf_state;\n  assert(state != NULL);\n  pCFRunLoopSourceSignal(state->signal_source);\n  pCFRunLoopWakeUp(state->loop);\n\n  return 0;\n}\n\n\n/* Runs in UV loop to initialize handle */\nint uv__fsevents_init(uv_fs_event_t* handle) {\n  int err;\n  uv__cf_loop_state_t* state;\n\n  err = uv__fsevents_loop_init(handle->loop);\n  if (err)\n    return err;\n\n  /* Get absolute path to file */\n  handle->realpath = realpath(handle->path, NULL);\n  if (handle->realpath == NULL)\n    return UV__ERR(errno);\n  handle->realpath_len = strlen(handle->realpath);\n\n  /* Initialize event queue */\n  QUEUE_INIT(&handle->cf_events);\n  handle->cf_error = 0;\n\n  /*\n   * Events will occur in other thread.\n   * Initialize callback for getting them back into event loop's thread\n   */\n  handle->cf_cb = uv__malloc(sizeof(*handle->cf_cb));\n  if (handle->cf_cb == NULL) {\n    err = UV_ENOMEM;\n    goto fail_cf_cb_malloc;\n  }\n\n  handle->cf_cb->data = handle;\n  uv_async_init(handle->loop, handle->cf_cb, uv__fsevents_cb);\n  handle->cf_cb->flags |= UV_HANDLE_INTERNAL;\n  uv_unref((uv_handle_t*) handle->cf_cb);\n\n  err = uv_mutex_init(&handle->cf_mutex);\n  if (err)\n    goto fail_cf_mutex_init;\n\n  /* Insert handle into the list */\n  state = handle->loop->cf_state;\n  uv_mutex_lock(&state->fsevent_mutex);\n  QUEUE_INSERT_TAIL(&state->fsevent_handles, &handle->cf_member);\n  state->fsevent_handle_count++;\n  state->fsevent_need_reschedule = 1;\n  uv_mutex_unlock(&state->fsevent_mutex);\n\n  /* Reschedule FSEventStream */\n  assert(handle != NULL);\n  err = uv__cf_loop_signal(handle->loop, handle, kUVCFLoopSignalRegular);\n  if (err)\n    goto fail_loop_signal;\n\n  return 0;\n\nfail_loop_signal:\n  uv_mutex_destroy(&handle->cf_mutex);\n\nfail_cf_mutex_init:\n  uv__free(handle->cf_cb);\n  handle->cf_cb = NULL;\n\nfail_cf_cb_malloc:\n  uv__free(handle->realpath);\n  handle->realpath = NULL;\n  handle->realpath_len = 0;\n\n  return err;\n}\n\n\n/* Runs in UV loop to de-initialize handle */\nint uv__fsevents_close(uv_fs_event_t* handle) {\n  int err;\n  uv__cf_loop_state_t* state;\n\n  if (handle->cf_cb == NULL)\n    return UV_EINVAL;\n\n  /* Remove handle from  the list */\n  state = handle->loop->cf_state;\n  uv_mutex_lock(&state->fsevent_mutex);\n  QUEUE_REMOVE(&handle->cf_member);\n  state->fsevent_handle_count--;\n  state->fsevent_need_reschedule = 1;\n  uv_mutex_unlock(&state->fsevent_mutex);\n\n  /* Reschedule FSEventStream */\n  assert(handle != NULL);\n  err = uv__cf_loop_signal(handle->loop, handle, kUVCFLoopSignalClosing);\n  if (err)\n    return UV__ERR(err);\n\n  /* Wait for deinitialization */\n  uv_sem_wait(&state->fsevent_sem);\n\n  uv_close((uv_handle_t*) handle->cf_cb, (uv_close_cb) uv__free);\n  handle->cf_cb = NULL;\n\n  /* Free data in queue */\n  UV__FSEVENTS_PROCESS(handle, {\n    /* NOP */\n  });\n\n  uv_mutex_destroy(&handle->cf_mutex);\n  uv__free(handle->realpath);\n  handle->realpath = NULL;\n  handle->realpath_len = 0;\n\n  return 0;\n}\n\n#endif /* TARGET_OS_IPHONE */\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Utilities/cmlibuv/src/unix/core.c": "/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#include \"uv.h\"\n#include \"internal.h\"\n\n#include <stddef.h> /* NULL */\n#include <stdio.h> /* printf */\n#include <stdlib.h>\n#include <string.h> /* strerror */\n#include <errno.h>\n#include <assert.h>\n#include <unistd.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <sys/ioctl.h>\n#include <sys/socket.h>\n#include <sys/un.h>\n#include <netinet/in.h>\n#include <arpa/inet.h>\n#include <limits.h> /* INT_MAX, PATH_MAX, IOV_MAX */\n#include <sys/uio.h> /* writev */\n#include <sys/resource.h> /* getrusage */\n#include <pwd.h>\n#include <sched.h>\n#include <sys/utsname.h>\n\n#ifdef __sun\n# include <netdb.h> /* MAXHOSTNAMELEN on Solaris */\n# include <sys/filio.h>\n# include <sys/types.h>\n# include <sys/wait.h>\n#endif\n\n#ifdef __APPLE__\n# include <mach-o/dyld.h> /* _NSGetExecutablePath */\n# include <sys/filio.h>\n# if defined(O_CLOEXEC)\n#  define UV__O_CLOEXEC O_CLOEXEC\n# endif\n#endif\n\n#if defined(__DragonFly__)      || \\\n    defined(__FreeBSD__)        || \\\n    defined(__FreeBSD_kernel__) || \\\n    defined(__NetBSD__)\n# include <sys/sysctl.h>\n# include <sys/filio.h>\n# include <sys/wait.h>\n# include <sys/param.h>\n# include <sys/cpuset.h>\n# define UV__O_CLOEXEC O_CLOEXEC\n# if defined(__FreeBSD__) && __FreeBSD__ >= 10\n#  define uv__accept4 accept4\n# endif\n# if defined(__NetBSD__)\n#  define uv__accept4(a, b, c, d) paccept((a), (b), (c), NULL, (d))\n# endif\n# if (defined(__FreeBSD__) && __FreeBSD__ >= 10) || defined(__NetBSD__)\n#  define UV__SOCK_NONBLOCK SOCK_NONBLOCK\n#  define UV__SOCK_CLOEXEC  SOCK_CLOEXEC\n# endif\n# if !defined(F_DUP2FD_CLOEXEC) && defined(_F_DUP2FD_CLOEXEC)\n#  define F_DUP2FD_CLOEXEC  _F_DUP2FD_CLOEXEC\n# endif\n#endif\n\n#if defined(__ANDROID_API__) && __ANDROID_API__ < 21\n# include <dlfcn.h>  /* for dlsym */\n#endif\n\n#if defined(__MVS__)\n#include <sys/ioctl.h>\n#endif\n\n#if !defined(__MVS__)\n#include <sys/param.h> /* MAXHOSTNAMELEN on Linux and the BSDs */\n#endif\n\n/* Fallback for the maximum hostname length */\n#ifndef MAXHOSTNAMELEN\n# define MAXHOSTNAMELEN 256\n#endif\n\nstatic int uv__run_pending(uv_loop_t* loop);\n\n/* Verify that uv_buf_t is ABI-compatible with struct iovec. */\nSTATIC_ASSERT(sizeof(uv_buf_t) == sizeof(struct iovec));\nSTATIC_ASSERT(sizeof(&((uv_buf_t*) 0)->base) ==\n              sizeof(((struct iovec*) 0)->iov_base));\nSTATIC_ASSERT(sizeof(&((uv_buf_t*) 0)->len) ==\n              sizeof(((struct iovec*) 0)->iov_len));\nSTATIC_ASSERT(offsetof(uv_buf_t, base) == offsetof(struct iovec, iov_base));\nSTATIC_ASSERT(offsetof(uv_buf_t, len) == offsetof(struct iovec, iov_len));\n\n\nuint64_t uv_hrtime(void) {\n  return uv__hrtime(UV_CLOCK_PRECISE);\n}\n\n\nvoid uv_close(uv_handle_t* handle, uv_close_cb close_cb) {\n  assert(!uv__is_closing(handle));\n\n  handle->flags |= UV_HANDLE_CLOSING;\n  handle->close_cb = close_cb;\n\n  switch (handle->type) {\n  case UV_NAMED_PIPE:\n    uv__pipe_close((uv_pipe_t*)handle);\n    break;\n\n  case UV_TTY:\n    uv__stream_close((uv_stream_t*)handle);\n    break;\n\n  case UV_TCP:\n    uv__tcp_close((uv_tcp_t*)handle);\n    break;\n\n  case UV_UDP:\n    uv__udp_close((uv_udp_t*)handle);\n    break;\n\n  case UV_PREPARE:\n    uv__prepare_close((uv_prepare_t*)handle);\n    break;\n\n  case UV_CHECK:\n    uv__check_close((uv_check_t*)handle);\n    break;\n\n  case UV_IDLE:\n    uv__idle_close((uv_idle_t*)handle);\n    break;\n\n  case UV_ASYNC:\n    uv__async_close((uv_async_t*)handle);\n    break;\n\n  case UV_TIMER:\n    uv__timer_close((uv_timer_t*)handle);\n    break;\n\n  case UV_PROCESS:\n    uv__process_close((uv_process_t*)handle);\n    break;\n\n  case UV_FS_EVENT:\n    uv__fs_event_close((uv_fs_event_t*)handle);\n    break;\n\n  case UV_POLL:\n    uv__poll_close((uv_poll_t*)handle);\n    break;\n\n  case UV_FS_POLL:\n    uv__fs_poll_close((uv_fs_poll_t*)handle);\n    break;\n\n  case UV_SIGNAL:\n    uv__signal_close((uv_signal_t*) handle);\n    /* Signal handles may not be closed immediately. The signal code will\n     * itself close uv__make_close_pending whenever appropriate. */\n    return;\n\n  default:\n    assert(0);\n  }\n\n  uv__make_close_pending(handle);\n}\n\nint uv__socket_sockopt(uv_handle_t* handle, int optname, int* value) {\n  int r;\n  int fd;\n  socklen_t len;\n\n  if (handle == NULL || value == NULL)\n    return UV_EINVAL;\n\n  if (handle->type == UV_TCP || handle->type == UV_NAMED_PIPE)\n    fd = uv__stream_fd((uv_stream_t*) handle);\n  else if (handle->type == UV_UDP)\n    fd = ((uv_udp_t *) handle)->io_watcher.fd;\n  else\n    return UV_ENOTSUP;\n\n  len = sizeof(*value);\n\n  if (*value == 0)\n    r = getsockopt(fd, SOL_SOCKET, optname, value, &len);\n  else\n    r = setsockopt(fd, SOL_SOCKET, optname, (const void*) value, len);\n\n  if (r < 0)\n    return UV__ERR(errno);\n\n  return 0;\n}\n\nvoid uv__make_close_pending(uv_handle_t* handle) {\n  assert(handle->flags & UV_HANDLE_CLOSING);\n  assert(!(handle->flags & UV_HANDLE_CLOSED));\n  handle->next_closing = handle->loop->closing_handles;\n  handle->loop->closing_handles = handle;\n}\n\nint uv__getiovmax(void) {\n#if defined(IOV_MAX)\n  return IOV_MAX;\n#elif defined(_SC_IOV_MAX)\n  static int iovmax = -1;\n  if (iovmax == -1) {\n    iovmax = sysconf(_SC_IOV_MAX);\n    /* On some embedded devices (arm-linux-uclibc based ip camera),\n     * sysconf(_SC_IOV_MAX) can not get the correct value. The return\n     * value is -1 and the errno is EINPROGRESS. Degrade the value to 1.\n     */\n    if (iovmax == -1) iovmax = 1;\n  }\n  return iovmax;\n#else\n  return 1024;\n#endif\n}\n\n\nstatic void uv__finish_close(uv_handle_t* handle) {\n  /* Note: while the handle is in the UV_HANDLE_CLOSING state now, it's still\n   * possible for it to be active in the sense that uv__is_active() returns\n   * true.\n   *\n   * A good example is when the user calls uv_shutdown(), immediately followed\n   * by uv_close(). The handle is considered active at this point because the\n   * completion of the shutdown req is still pending.\n   */\n  assert(handle->flags & UV_HANDLE_CLOSING);\n  assert(!(handle->flags & UV_HANDLE_CLOSED));\n  handle->flags |= UV_HANDLE_CLOSED;\n\n  switch (handle->type) {\n    case UV_PREPARE:\n    case UV_CHECK:\n    case UV_IDLE:\n    case UV_ASYNC:\n    case UV_TIMER:\n    case UV_PROCESS:\n    case UV_FS_EVENT:\n    case UV_FS_POLL:\n    case UV_POLL:\n    case UV_SIGNAL:\n      break;\n\n    case UV_NAMED_PIPE:\n    case UV_TCP:\n    case UV_TTY:\n      uv__stream_destroy((uv_stream_t*)handle);\n      break;\n\n    case UV_UDP:\n      uv__udp_finish_close((uv_udp_t*)handle);\n      break;\n\n    default:\n      assert(0);\n      break;\n  }\n\n  uv__handle_unref(handle);\n  QUEUE_REMOVE(&handle->handle_queue);\n\n  if (handle->close_cb) {\n    handle->close_cb(handle);\n  }\n}\n\n\nstatic void uv__run_closing_handles(uv_loop_t* loop) {\n  uv_handle_t* p;\n  uv_handle_t* q;\n\n  p = loop->closing_handles;\n  loop->closing_handles = NULL;\n\n  while (p) {\n    q = p->next_closing;\n    uv__finish_close(p);\n    p = q;\n  }\n}\n\n\nint uv_is_closing(const uv_handle_t* handle) {\n  return uv__is_closing(handle);\n}\n\n\nint uv_backend_fd(const uv_loop_t* loop) {\n  return loop->backend_fd;\n}\n\n\nint uv_backend_timeout(const uv_loop_t* loop) {\n  if (loop->stop_flag != 0)\n    return 0;\n\n  if (!uv__has_active_handles(loop) && !uv__has_active_reqs(loop))\n    return 0;\n\n  if (!QUEUE_EMPTY(&loop->idle_handles))\n    return 0;\n\n  if (!QUEUE_EMPTY(&loop->pending_queue))\n    return 0;\n\n  if (loop->closing_handles)\n    return 0;\n\n  return uv__next_timeout(loop);\n}\n\n\nstatic int uv__loop_alive(const uv_loop_t* loop) {\n  return uv__has_active_handles(loop) ||\n         uv__has_active_reqs(loop) ||\n         loop->closing_handles != NULL;\n}\n\n\nint uv_loop_alive(const uv_loop_t* loop) {\n    return uv__loop_alive(loop);\n}\n\n\nint uv_run(uv_loop_t* loop, uv_run_mode mode) {\n  int timeout;\n  int r;\n  int ran_pending;\n\n  r = uv__loop_alive(loop);\n  if (!r)\n    uv__update_time(loop);\n\n  while (r != 0 && loop->stop_flag == 0) {\n    uv__update_time(loop);\n    uv__run_timers(loop);\n    ran_pending = uv__run_pending(loop);\n    uv__run_idle(loop);\n    uv__run_prepare(loop);\n\n    timeout = 0;\n    if ((mode == UV_RUN_ONCE && !ran_pending) || mode == UV_RUN_DEFAULT)\n      timeout = uv_backend_timeout(loop);\n\n    uv__io_poll(loop, timeout);\n    uv__run_check(loop);\n    uv__run_closing_handles(loop);\n\n    if (mode == UV_RUN_ONCE) {\n      /* UV_RUN_ONCE implies forward progress: at least one callback must have\n       * been invoked when it returns. uv__io_poll() can return without doing\n       * I/O (meaning: no callbacks) when its timeout expires - which means we\n       * have pending timers that satisfy the forward progress constraint.\n       *\n       * UV_RUN_NOWAIT makes no guarantees about progress so it's omitted from\n       * the check.\n       */\n      uv__update_time(loop);\n      uv__run_timers(loop);\n    }\n\n    r = uv__loop_alive(loop);\n    if (mode == UV_RUN_ONCE || mode == UV_RUN_NOWAIT)\n      break;\n  }\n\n  /* The if statement lets gcc compile it to a conditional store. Avoids\n   * dirtying a cache line.\n   */\n  if (loop->stop_flag != 0)\n    loop->stop_flag = 0;\n\n  return r;\n}\n\n\nvoid uv_update_time(uv_loop_t* loop) {\n  uv__update_time(loop);\n}\n\n\nint uv_is_active(const uv_handle_t* handle) {\n  return uv__is_active(handle);\n}\n\n\n/* Open a socket in non-blocking close-on-exec mode, atomically if possible. */\nint uv__socket(int domain, int type, int protocol) {\n  int sockfd;\n  int err;\n\n#if defined(SOCK_NONBLOCK) && defined(SOCK_CLOEXEC)\n  sockfd = socket(domain, type | SOCK_NONBLOCK | SOCK_CLOEXEC, protocol);\n  if (sockfd != -1)\n    return sockfd;\n\n  if (errno != EINVAL)\n    return UV__ERR(errno);\n#endif\n\n  sockfd = socket(domain, type, protocol);\n  if (sockfd == -1)\n    return UV__ERR(errno);\n\n  err = uv__nonblock(sockfd, 1);\n  if (err == 0)\n    err = uv__cloexec(sockfd, 1);\n\n  if (err) {\n    uv__close(sockfd);\n    return err;\n  }\n\n#if defined(SO_NOSIGPIPE)\n  {\n    int on = 1;\n    setsockopt(sockfd, SOL_SOCKET, SO_NOSIGPIPE, &on, sizeof(on));\n  }\n#endif\n\n  return sockfd;\n}\n\n/* get a file pointer to a file in read-only and close-on-exec mode */\nFILE* uv__open_file(const char* path) {\n  int fd;\n  FILE* fp;\n\n  fd = uv__open_cloexec(path, O_RDONLY);\n  if (fd < 0)\n    return NULL;\n\n   fp = fdopen(fd, \"r\");\n   if (fp == NULL)\n     uv__close(fd);\n\n   return fp;\n}\n\n\nint uv__accept(int sockfd) {\n  int peerfd;\n  int err;\n\n  assert(sockfd >= 0);\n\n  while (1) {\n#if defined(__linux__)                          || \\\n    (defined(__FreeBSD__) && __FreeBSD__ >= 10) || \\\n    defined(__NetBSD__)\n    static int no_accept4;\n\n    if (no_accept4)\n      goto skip;\n\n    peerfd = uv__accept4(sockfd,\n                         NULL,\n                         NULL,\n                         UV__SOCK_NONBLOCK|UV__SOCK_CLOEXEC);\n    if (peerfd != -1)\n      return peerfd;\n\n    if (errno == EINTR)\n      continue;\n\n    if (errno != ENOSYS)\n      return UV__ERR(errno);\n\n    no_accept4 = 1;\nskip:\n#endif\n\n    peerfd = accept(sockfd, NULL, NULL);\n    if (peerfd == -1) {\n      if (errno == EINTR)\n        continue;\n      return UV__ERR(errno);\n    }\n\n    err = uv__cloexec(peerfd, 1);\n    if (err == 0)\n      err = uv__nonblock(peerfd, 1);\n\n    if (err) {\n      uv__close(peerfd);\n      return err;\n    }\n\n    return peerfd;\n  }\n}\n\n\nint uv__close_nocheckstdio(int fd) {\n  int saved_errno;\n  int rc;\n\n  assert(fd > -1);  /* Catch uninitialized io_watcher.fd bugs. */\n\n  saved_errno = errno;\n  rc = close(fd);\n  if (rc == -1) {\n    rc = UV__ERR(errno);\n    if (rc == UV_EINTR || rc == UV__ERR(EINPROGRESS))\n      rc = 0;    /* The close is in progress, not an error. */\n    errno = saved_errno;\n  }\n\n  return rc;\n}\n\n\nint uv__close(int fd) {\n  assert(fd > STDERR_FILENO);  /* Catch stdio close bugs. */\n#if defined(__MVS__)\n  SAVE_ERRNO(epoll_file_close(fd));\n#endif\n  return uv__close_nocheckstdio(fd);\n}\n\n\nint uv__nonblock_ioctl(int fd, int set) {\n  int r;\n\n  do\n    r = ioctl(fd, FIONBIO, &set);\n  while (r == -1 && errno == EINTR);\n\n  if (r)\n    return UV__ERR(errno);\n\n  return 0;\n}\n\n\n#if !defined(__CYGWIN__) && !defined(__MSYS__)\nint uv__cloexec_ioctl(int fd, int set) {\n  int r;\n\n  do\n    r = ioctl(fd, set ? FIOCLEX : FIONCLEX);\n  while (r == -1 && errno == EINTR);\n\n  if (r)\n    return UV__ERR(errno);\n\n  return 0;\n}\n#endif\n\n\nint uv__nonblock_fcntl(int fd, int set) {\n  int flags;\n  int r;\n\n  do\n    r = fcntl(fd, F_GETFL);\n  while (r == -1 && errno == EINTR);\n\n  if (r == -1)\n    return UV__ERR(errno);\n\n  /* Bail out now if already set/clear. */\n  if (!!(r & O_NONBLOCK) == !!set)\n    return 0;\n\n  if (set)\n    flags = r | O_NONBLOCK;\n  else\n    flags = r & ~O_NONBLOCK;\n\n  do\n    r = fcntl(fd, F_SETFL, flags);\n  while (r == -1 && errno == EINTR);\n\n  if (r)\n    return UV__ERR(errno);\n\n  return 0;\n}\n\n\nint uv__cloexec_fcntl(int fd, int set) {\n  int flags;\n  int r;\n\n  do\n    r = fcntl(fd, F_GETFD);\n  while (r == -1 && errno == EINTR);\n\n  if (r == -1)\n    return UV__ERR(errno);\n\n  /* Bail out now if already set/clear. */\n  if (!!(r & FD_CLOEXEC) == !!set)\n    return 0;\n\n  if (set)\n    flags = r | FD_CLOEXEC;\n  else\n    flags = r & ~FD_CLOEXEC;\n\n  do\n    r = fcntl(fd, F_SETFD, flags);\n  while (r == -1 && errno == EINTR);\n\n  if (r)\n    return UV__ERR(errno);\n\n  return 0;\n}\n\n\nssize_t uv__recvmsg(int fd, struct msghdr* msg, int flags) {\n  struct cmsghdr* cmsg;\n  ssize_t rc;\n  int* pfd;\n  int* end;\n#if defined(__linux__)\n  static int no_msg_cmsg_cloexec;\n  if (no_msg_cmsg_cloexec == 0) {\n    rc = recvmsg(fd, msg, flags | 0x40000000);  /* MSG_CMSG_CLOEXEC */\n    if (rc != -1)\n      return rc;\n    if (errno != EINVAL)\n      return UV__ERR(errno);\n    rc = recvmsg(fd, msg, flags);\n    if (rc == -1)\n      return UV__ERR(errno);\n    no_msg_cmsg_cloexec = 1;\n  } else {\n    rc = recvmsg(fd, msg, flags);\n  }\n#else\n  rc = recvmsg(fd, msg, flags);\n#endif\n  if (rc == -1)\n    return UV__ERR(errno);\n  if (msg->msg_controllen == 0)\n    return rc;\n  for (cmsg = CMSG_FIRSTHDR(msg); cmsg != NULL; cmsg = CMSG_NXTHDR(msg, cmsg))\n    if (cmsg->cmsg_type == SCM_RIGHTS)\n      for (pfd = (int*) CMSG_DATA(cmsg),\n           end = (int*) ((char*) cmsg + cmsg->cmsg_len);\n           pfd < end;\n           pfd += 1)\n        uv__cloexec(*pfd, 1);\n  return rc;\n}\n\n\nint uv_cwd(char* buffer, size_t* size) {\n  if (buffer == NULL || size == NULL)\n    return UV_EINVAL;\n\n  if (getcwd(buffer, *size) == NULL)\n    return UV__ERR(errno);\n\n  *size = strlen(buffer);\n  if (*size > 1 && buffer[*size - 1] == '/') {\n    buffer[*size-1] = '\\0';\n    (*size)--;\n  }\n\n  return 0;\n}\n\n\nint uv_chdir(const char* dir) {\n  if (chdir(dir))\n    return UV__ERR(errno);\n\n  return 0;\n}\n\n\nvoid uv_disable_stdio_inheritance(void) {\n  int fd;\n\n  /* Set the CLOEXEC flag on all open descriptors. Unconditionally try the\n   * first 16 file descriptors. After that, bail out after the first error.\n   */\n  for (fd = 0; ; fd++)\n    if (uv__cloexec(fd, 1) && fd > 15)\n      break;\n}\n\n\nint uv_fileno(const uv_handle_t* handle, uv_os_fd_t* fd) {\n  int fd_out;\n\n  switch (handle->type) {\n  case UV_TCP:\n  case UV_NAMED_PIPE:\n  case UV_TTY:\n    fd_out = uv__stream_fd((uv_stream_t*) handle);\n    break;\n\n  case UV_UDP:\n    fd_out = ((uv_udp_t *) handle)->io_watcher.fd;\n    break;\n\n  case UV_POLL:\n    fd_out = ((uv_poll_t *) handle)->io_watcher.fd;\n    break;\n\n  default:\n    return UV_EINVAL;\n  }\n\n  if (uv__is_closing(handle) || fd_out == -1)\n    return UV_EBADF;\n\n  *fd = fd_out;\n  return 0;\n}\n\n\nstatic int uv__run_pending(uv_loop_t* loop) {\n  QUEUE* q;\n  QUEUE pq;\n  uv__io_t* w;\n\n  if (QUEUE_EMPTY(&loop->pending_queue))\n    return 0;\n\n  QUEUE_MOVE(&loop->pending_queue, &pq);\n\n  while (!QUEUE_EMPTY(&pq)) {\n    q = QUEUE_HEAD(&pq);\n    QUEUE_REMOVE(q);\n    QUEUE_INIT(q);\n    w = QUEUE_DATA(q, uv__io_t, pending_queue);\n    w->cb(loop, w, POLLOUT);\n  }\n\n  return 1;\n}\n\n\nstatic unsigned int next_power_of_two(unsigned int val) {\n  val -= 1;\n  val |= val >> 1;\n  val |= val >> 2;\n  val |= val >> 4;\n  val |= val >> 8;\n  val |= val >> 16;\n  val += 1;\n  return val;\n}\n\nstatic void maybe_resize(uv_loop_t* loop, unsigned int len) {\n  uv__io_t** watchers;\n  void* fake_watcher_list;\n  void* fake_watcher_count;\n  unsigned int nwatchers;\n  unsigned int i;\n\n  if (len <= loop->nwatchers)\n    return;\n\n  /* Preserve fake watcher list and count at the end of the watchers */\n  if (loop->watchers != NULL) {\n    fake_watcher_list = loop->watchers[loop->nwatchers];\n    fake_watcher_count = loop->watchers[loop->nwatchers + 1];\n  } else {\n    fake_watcher_list = NULL;\n    fake_watcher_count = NULL;\n  }\n\n  nwatchers = next_power_of_two(len + 2) - 2;\n  watchers = uv__realloc(loop->watchers,\n                         (nwatchers + 2) * sizeof(loop->watchers[0]));\n\n  if (watchers == NULL)\n    abort();\n  for (i = loop->nwatchers; i < nwatchers; i++)\n    watchers[i] = NULL;\n  watchers[nwatchers] = fake_watcher_list;\n  watchers[nwatchers + 1] = fake_watcher_count;\n\n  loop->watchers = watchers;\n  loop->nwatchers = nwatchers;\n}\n\n\nvoid uv__io_init(uv__io_t* w, uv__io_cb cb, int fd) {\n  assert(cb != NULL);\n  assert(fd >= -1);\n  QUEUE_INIT(&w->pending_queue);\n  QUEUE_INIT(&w->watcher_queue);\n  w->cb = cb;\n  w->fd = fd;\n  w->events = 0;\n  w->pevents = 0;\n\n#if defined(UV_HAVE_KQUEUE)\n  w->rcount = 0;\n  w->wcount = 0;\n#endif /* defined(UV_HAVE_KQUEUE) */\n}\n\n\nvoid uv__io_start(uv_loop_t* loop, uv__io_t* w, unsigned int events) {\n  assert(0 == (events & ~(POLLIN | POLLOUT | UV__POLLRDHUP | UV__POLLPRI)));\n  assert(0 != events);\n  assert(w->fd >= 0);\n  assert(w->fd < INT_MAX);\n\n  w->pevents |= events;\n  maybe_resize(loop, w->fd + 1);\n\n#if !defined(__sun)\n  /* The event ports backend needs to rearm all file descriptors on each and\n   * every tick of the event loop but the other backends allow us to\n   * short-circuit here if the event mask is unchanged.\n   */\n  if (w->events == w->pevents)\n    return;\n#endif\n\n  if (QUEUE_EMPTY(&w->watcher_queue))\n    QUEUE_INSERT_TAIL(&loop->watcher_queue, &w->watcher_queue);\n\n  if (loop->watchers[w->fd] == NULL) {\n    loop->watchers[w->fd] = w;\n    loop->nfds++;\n  }\n}\n\n\nvoid uv__io_stop(uv_loop_t* loop, uv__io_t* w, unsigned int events) {\n  assert(0 == (events & ~(POLLIN | POLLOUT | UV__POLLRDHUP | UV__POLLPRI)));\n  assert(0 != events);\n\n  if (w->fd == -1)\n    return;\n\n  assert(w->fd >= 0);\n\n  /* Happens when uv__io_stop() is called on a handle that was never started. */\n  if ((unsigned) w->fd >= loop->nwatchers)\n    return;\n\n  w->pevents &= ~events;\n\n  if (w->pevents == 0) {\n    QUEUE_REMOVE(&w->watcher_queue);\n    QUEUE_INIT(&w->watcher_queue);\n\n    if (loop->watchers[w->fd] != NULL) {\n      assert(loop->watchers[w->fd] == w);\n      assert(loop->nfds > 0);\n      loop->watchers[w->fd] = NULL;\n      loop->nfds--;\n      w->events = 0;\n    }\n  }\n  else if (QUEUE_EMPTY(&w->watcher_queue))\n    QUEUE_INSERT_TAIL(&loop->watcher_queue, &w->watcher_queue);\n}\n\n\nvoid uv__io_close(uv_loop_t* loop, uv__io_t* w) {\n  uv__io_stop(loop, w, POLLIN | POLLOUT | UV__POLLRDHUP | UV__POLLPRI);\n  QUEUE_REMOVE(&w->pending_queue);\n\n  /* Remove stale events for this file descriptor */\n  uv__platform_invalidate_fd(loop, w->fd);\n}\n\n\nvoid uv__io_feed(uv_loop_t* loop, uv__io_t* w) {\n  if (QUEUE_EMPTY(&w->pending_queue))\n    QUEUE_INSERT_TAIL(&loop->pending_queue, &w->pending_queue);\n}\n\n\nint uv__io_active(const uv__io_t* w, unsigned int events) {\n  assert(0 == (events & ~(POLLIN | POLLOUT | UV__POLLRDHUP | UV__POLLPRI)));\n  assert(0 != events);\n  return 0 != (w->pevents & events);\n}\n\n\nint uv__fd_exists(uv_loop_t* loop, int fd) {\n  return (unsigned) fd < loop->nwatchers && loop->watchers[fd] != NULL;\n}\n\n\nint uv_getrusage(uv_rusage_t* rusage) {\n  struct rusage usage;\n\n  if (getrusage(RUSAGE_SELF, &usage))\n    return UV__ERR(errno);\n\n  rusage->ru_utime.tv_sec = usage.ru_utime.tv_sec;\n  rusage->ru_utime.tv_usec = usage.ru_utime.tv_usec;\n\n  rusage->ru_stime.tv_sec = usage.ru_stime.tv_sec;\n  rusage->ru_stime.tv_usec = usage.ru_stime.tv_usec;\n\n#if !defined(__MVS__)\n  rusage->ru_maxrss = usage.ru_maxrss;\n  rusage->ru_ixrss = usage.ru_ixrss;\n  rusage->ru_idrss = usage.ru_idrss;\n  rusage->ru_isrss = usage.ru_isrss;\n  rusage->ru_minflt = usage.ru_minflt;\n  rusage->ru_majflt = usage.ru_majflt;\n  rusage->ru_nswap = usage.ru_nswap;\n  rusage->ru_inblock = usage.ru_inblock;\n  rusage->ru_oublock = usage.ru_oublock;\n  rusage->ru_msgsnd = usage.ru_msgsnd;\n  rusage->ru_msgrcv = usage.ru_msgrcv;\n  rusage->ru_nsignals = usage.ru_nsignals;\n  rusage->ru_nvcsw = usage.ru_nvcsw;\n  rusage->ru_nivcsw = usage.ru_nivcsw;\n#endif\n\n  return 0;\n}\n\n\nint uv__open_cloexec(const char* path, int flags) {\n  int err;\n  int fd;\n\n#if defined(UV__O_CLOEXEC)\n  static int no_cloexec;\n\n  if (!no_cloexec) {\n    fd = open(path, flags | UV__O_CLOEXEC);\n    if (fd != -1)\n      return fd;\n\n    if (errno != EINVAL)\n      return UV__ERR(errno);\n\n    /* O_CLOEXEC not supported. */\n    no_cloexec = 1;\n  }\n#endif\n\n  fd = open(path, flags);\n  if (fd == -1)\n    return UV__ERR(errno);\n\n  err = uv__cloexec(fd, 1);\n  if (err) {\n    uv__close(fd);\n    return err;\n  }\n\n  return fd;\n}\n\n\nint uv__dup2_cloexec(int oldfd, int newfd) {\n  int r;\n#if (defined(__FreeBSD__) && __FreeBSD__ >= 10) || defined(__NetBSD__)\n  r = dup3(oldfd, newfd, O_CLOEXEC);\n  if (r == -1)\n    return UV__ERR(errno);\n  return r;\n#elif defined(__FreeBSD__) && defined(F_DUP2FD_CLOEXEC)\n  r = fcntl(oldfd, F_DUP2FD_CLOEXEC, newfd);\n  if (r != -1)\n    return r;\n  if (errno != EINVAL)\n    return UV__ERR(errno);\n  /* Fall through. */\n#elif defined(__linux__)\n  static int no_dup3;\n  if (!no_dup3) {\n    do\n      r = uv__dup3(oldfd, newfd, UV__O_CLOEXEC);\n    while (r == -1 && errno == EBUSY);\n    if (r != -1)\n      return r;\n    if (errno != ENOSYS)\n      return UV__ERR(errno);\n    /* Fall through. */\n    no_dup3 = 1;\n  }\n#endif\n  {\n    int err;\n    do\n      r = dup2(oldfd, newfd);\n#if defined(__linux__)\n    while (r == -1 && errno == EBUSY);\n#else\n    while (0);  /* Never retry. */\n#endif\n\n    if (r == -1)\n      return UV__ERR(errno);\n\n    err = uv__cloexec(newfd, 1);\n    if (err) {\n      uv__close(newfd);\n      return err;\n    }\n\n    return r;\n  }\n}\n\n\nint uv_os_homedir(char* buffer, size_t* size) {\n  uv_passwd_t pwd;\n  size_t len;\n  int r;\n\n  /* Check if the HOME environment variable is set first. The task of\n     performing input validation on buffer and size is taken care of by\n     uv_os_getenv(). */\n  r = uv_os_getenv(\"HOME\", buffer, size);\n\n  if (r != UV_ENOENT)\n    return r;\n\n  /* HOME is not set, so call uv__getpwuid_r() */\n  r = uv__getpwuid_r(&pwd);\n\n  if (r != 0) {\n    return r;\n  }\n\n  len = strlen(pwd.homedir);\n\n  if (len >= *size) {\n    *size = len + 1;\n    uv_os_free_passwd(&pwd);\n    return UV_ENOBUFS;\n  }\n\n  memcpy(buffer, pwd.homedir, len + 1);\n  *size = len;\n  uv_os_free_passwd(&pwd);\n\n  return 0;\n}\n\n\nint uv_os_tmpdir(char* buffer, size_t* size) {\n  const char* buf;\n  size_t len;\n\n  if (buffer == NULL || size == NULL || *size == 0)\n    return UV_EINVAL;\n\n#define CHECK_ENV_VAR(name)                                                   \\\n  do {                                                                        \\\n    buf = getenv(name);                                                       \\\n    if (buf != NULL)                                                          \\\n      goto return_buffer;                                                     \\\n  }                                                                           \\\n  while (0)\n\n  /* Check the TMPDIR, TMP, TEMP, and TEMPDIR environment variables in order */\n  CHECK_ENV_VAR(\"TMPDIR\");\n  CHECK_ENV_VAR(\"TMP\");\n  CHECK_ENV_VAR(\"TEMP\");\n  CHECK_ENV_VAR(\"TEMPDIR\");\n\n#undef CHECK_ENV_VAR\n\n  /* No temp environment variables defined */\n  #if defined(__ANDROID__)\n    buf = \"/data/local/tmp\";\n  #else\n    buf = \"/tmp\";\n  #endif\n\nreturn_buffer:\n  len = strlen(buf);\n\n  if (len >= *size) {\n    *size = len + 1;\n    return UV_ENOBUFS;\n  }\n\n  /* The returned directory should not have a trailing slash. */\n  if (len > 1 && buf[len - 1] == '/') {\n    len--;\n  }\n\n  memcpy(buffer, buf, len + 1);\n  buffer[len] = '\\0';\n  *size = len;\n\n  return 0;\n}\n\n\nint uv__getpwuid_r(uv_passwd_t* pwd) {\n  struct passwd pw;\n  struct passwd* result;\n  char* buf;\n  uid_t uid;\n  size_t bufsize;\n  size_t name_size;\n  size_t homedir_size;\n  size_t shell_size;\n  long initsize;\n  int r;\n#if defined(__ANDROID_API__) && __ANDROID_API__ < 21\n  int (*getpwuid_r)(uid_t, struct passwd*, char*, size_t, struct passwd**);\n\n  getpwuid_r = dlsym(RTLD_DEFAULT, \"getpwuid_r\");\n  if (getpwuid_r == NULL)\n    return UV_ENOSYS;\n#endif\n\n  if (pwd == NULL)\n    return UV_EINVAL;\n\n  initsize = sysconf(_SC_GETPW_R_SIZE_MAX);\n\n  if (initsize <= 0)\n    bufsize = 4096;\n  else\n    bufsize = (size_t) initsize;\n\n  uid = geteuid();\n  buf = NULL;\n\n  for (;;) {\n    uv__free(buf);\n    buf = uv__malloc(bufsize);\n\n    if (buf == NULL)\n      return UV_ENOMEM;\n\n    r = getpwuid_r(uid, &pw, buf, bufsize, &result);\n\n    if (r != ERANGE)\n      break;\n\n    bufsize *= 2;\n  }\n\n  if (r != 0) {\n    uv__free(buf);\n    return -r;\n  }\n\n  if (result == NULL) {\n    uv__free(buf);\n    return UV_ENOENT;\n  }\n\n  /* Allocate memory for the username, shell, and home directory */\n  name_size = strlen(pw.pw_name) + 1;\n  homedir_size = strlen(pw.pw_dir) + 1;\n  shell_size = strlen(pw.pw_shell) + 1;\n  pwd->username = uv__malloc(name_size + homedir_size + shell_size);\n\n  if (pwd->username == NULL) {\n    uv__free(buf);\n    return UV_ENOMEM;\n  }\n\n  /* Copy the username */\n  memcpy(pwd->username, pw.pw_name, name_size);\n\n  /* Copy the home directory */\n  pwd->homedir = pwd->username + name_size;\n  memcpy(pwd->homedir, pw.pw_dir, homedir_size);\n\n  /* Copy the shell */\n  pwd->shell = pwd->homedir + homedir_size;\n  memcpy(pwd->shell, pw.pw_shell, shell_size);\n\n  /* Copy the uid and gid */\n  pwd->uid = pw.pw_uid;\n  pwd->gid = pw.pw_gid;\n\n  uv__free(buf);\n\n  return 0;\n}\n\n\nvoid uv_os_free_passwd(uv_passwd_t* pwd) {\n  if (pwd == NULL)\n    return;\n\n  /*\n    The memory for name, shell, and homedir are allocated in a single\n    uv__malloc() call. The base of the pointer is stored in pwd->username, so\n    that is the field that needs to be freed.\n  */\n  uv__free(pwd->username);\n  pwd->username = NULL;\n  pwd->shell = NULL;\n  pwd->homedir = NULL;\n}\n\n\nint uv_os_get_passwd(uv_passwd_t* pwd) {\n  return uv__getpwuid_r(pwd);\n}\n\n\nint uv_translate_sys_error(int sys_errno) {\n  /* If < 0 then it's already a libuv error. */\n  return sys_errno <= 0 ? sys_errno : -sys_errno;\n}\n\n\nint uv_os_getenv(const char* name, char* buffer, size_t* size) {\n  char* var;\n  size_t len;\n\n  if (name == NULL || buffer == NULL || size == NULL || *size == 0)\n    return UV_EINVAL;\n\n  var = getenv(name);\n\n  if (var == NULL)\n    return UV_ENOENT;\n\n  len = strlen(var);\n\n  if (len >= *size) {\n    *size = len + 1;\n    return UV_ENOBUFS;\n  }\n\n  memcpy(buffer, var, len + 1);\n  *size = len;\n\n  return 0;\n}\n\n\nint uv_os_setenv(const char* name, const char* value) {\n  if (name == NULL || value == NULL)\n    return UV_EINVAL;\n\n  if (setenv(name, value, 1) != 0)\n    return UV__ERR(errno);\n\n  return 0;\n}\n\n\nint uv_os_unsetenv(const char* name) {\n  if (name == NULL)\n    return UV_EINVAL;\n\n  if (unsetenv(name) != 0)\n    return UV__ERR(errno);\n\n  return 0;\n}\n\n\nint uv_os_gethostname(char* buffer, size_t* size) {\n  /*\n    On some platforms, if the input buffer is not large enough, gethostname()\n    succeeds, but truncates the result. libuv can detect this and return ENOBUFS\n    instead by creating a large enough buffer and comparing the hostname length\n    to the size input.\n  */\n  char buf[MAXHOSTNAMELEN + 1];\n  size_t len;\n\n  if (buffer == NULL || size == NULL || *size == 0)\n    return UV_EINVAL;\n\n  if (gethostname(buf, sizeof(buf)) != 0)\n    return UV__ERR(errno);\n\n  buf[sizeof(buf) - 1] = '\\0'; /* Null terminate, just to be safe. */\n  len = strlen(buf);\n\n  if (len >= *size) {\n    *size = len + 1;\n    return UV_ENOBUFS;\n  }\n\n  memcpy(buffer, buf, len + 1);\n  *size = len;\n  return 0;\n}\n\n\nint uv_cpumask_size(void) {\n#if defined(__linux__) || defined(__FreeBSD__)\n  return CPU_SETSIZE;\n#else\n  return UV_ENOTSUP;\n#endif\n}\n\n\nuv_os_fd_t uv_get_osfhandle(int fd) {\n  return fd;\n}\n\nint uv_open_osfhandle(uv_os_fd_t os_fd) {\n  return os_fd;\n}\n\nuv_pid_t uv_os_getpid(void) {\n  return getpid();\n}\n\n\nuv_pid_t uv_os_getppid(void) {\n  return getppid();\n}\n\n\nint uv_os_getpriority(uv_pid_t pid, int* priority) {\n  int r;\n\n  if (priority == NULL)\n    return UV_EINVAL;\n\n  errno = 0;\n  r = getpriority(PRIO_PROCESS, (int) pid);\n\n  if (r == -1 && errno != 0)\n    return UV__ERR(errno);\n\n  *priority = r;\n  return 0;\n}\n\n\nint uv_os_setpriority(uv_pid_t pid, int priority) {\n  if (priority < UV_PRIORITY_HIGHEST || priority > UV_PRIORITY_LOW)\n    return UV_EINVAL;\n\n  if (setpriority(PRIO_PROCESS, (int) pid, priority) != 0)\n    return UV__ERR(errno);\n\n  return 0;\n}\n\n\nint uv_os_uname(uv_utsname_t* buffer) {\n  struct utsname buf;\n  int r;\n\n  if (buffer == NULL)\n    return UV_EINVAL;\n\n  if (uname(&buf) == -1) {\n    r = UV__ERR(errno);\n    goto error;\n  }\n\n  r = uv__strscpy(buffer->sysname, buf.sysname, sizeof(buffer->sysname));\n  if (r == UV_E2BIG)\n    goto error;\n\n#ifdef _AIX\n  r = snprintf(buffer->release,\n               sizeof(buffer->release),\n               \"%s.%s\",\n               buf.version,\n               buf.release);\n  if (r >= sizeof(buffer->release)) {\n    r = UV_E2BIG;\n    goto error;\n  }\n#else\n  r = uv__strscpy(buffer->release, buf.release, sizeof(buffer->release));\n  if (r == UV_E2BIG)\n    goto error;\n#endif\n\n  r = uv__strscpy(buffer->version, buf.version, sizeof(buffer->version));\n  if (r == UV_E2BIG)\n    goto error;\n\n#if defined(_AIX) || defined(__PASE__)\n  r = uv__strscpy(buffer->machine, \"ppc64\", sizeof(buffer->machine));\n#else\n  r = uv__strscpy(buffer->machine, buf.machine, sizeof(buffer->machine));\n#endif\n\n  if (r == UV_E2BIG)\n    goto error;\n\n  return 0;\n\nerror:\n  buffer->sysname[0] = '\\0';\n  buffer->release[0] = '\\0';\n  buffer->version[0] = '\\0';\n  buffer->machine[0] = '\\0';\n  return r;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Utilities/cmlibuv/src/unix/dl.c": "/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n#include \"uv.h\"\n#include \"internal.h\"\n\n#include <dlfcn.h>\n#include <errno.h>\n#include <string.h>\n#include <locale.h>\n\nstatic int uv__dlerror(uv_lib_t* lib);\n\n\nint uv_dlopen(const char* filename, uv_lib_t* lib) {\n  dlerror(); /* Reset error status. */\n  lib->errmsg = NULL;\n  lib->handle = dlopen(filename, RTLD_LAZY);\n  return lib->handle ? 0 : uv__dlerror(lib);\n}\n\n\nvoid uv_dlclose(uv_lib_t* lib) {\n  uv__free(lib->errmsg);\n  lib->errmsg = NULL;\n\n  if (lib->handle) {\n    /* Ignore errors. No good way to signal them without leaking memory. */\n    dlclose(lib->handle);\n    lib->handle = NULL;\n  }\n}\n\n\nint uv_dlsym(uv_lib_t* lib, const char* name, void** ptr) {\n  dlerror(); /* Reset error status. */\n  *ptr = dlsym(lib->handle, name);\n  return uv__dlerror(lib);\n}\n\n\nconst char* uv_dlerror(const uv_lib_t* lib) {\n  return lib->errmsg ? lib->errmsg : \"no error\";\n}\n\n\nstatic int uv__dlerror(uv_lib_t* lib) {\n  const char* errmsg;\n\n  uv__free(lib->errmsg);\n\n  errmsg = dlerror();\n\n  if (errmsg) {\n    lib->errmsg = uv__strdup(errmsg);\n    return -1;\n  }\n  else {\n    lib->errmsg = NULL;\n    return 0;\n  }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Utilities/cmlibuv/include/uv.h": "/* Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the \"Software\"), to\n * deal in the Software without restriction, including without limitation the\n * rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n * sell copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n *\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n * IN THE SOFTWARE.\n */\n\n/* See https://github.com/libuv/libuv#documentation for documentation. */\n\n#ifndef UV_H\n#define UV_H\n\n/* Include KWSys Large File Support configuration. */\n#include <cmsys/Configure.h>\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n#ifdef _WIN32\n  /* Windows - set up dll import/export decorators. */\n# if defined(BUILDING_UV_SHARED)\n    /* Building shared library. */\n#   define UV_EXTERN __declspec(dllexport)\n# elif defined(USING_UV_SHARED)\n    /* Using shared library. */\n#   define UV_EXTERN __declspec(dllimport)\n# else\n    /* Building static library. */\n#   define UV_EXTERN /* nothing */\n# endif\n#elif __GNUC__ >= 4\n# define UV_EXTERN __attribute__((visibility(\"default\")))\n#else\n# define UV_EXTERN /* nothing */\n#endif\n\n#include \"uv/errno.h\"\n#include \"uv/version.h\"\n#include <stddef.h>\n#include <stdio.h>\n\n#if defined(_MSC_VER) && _MSC_VER < 1600\n# include \"uv/stdint-msvc2008.h\"\n#else\n# include <stdint.h>\n#endif\n\n#if defined(_WIN32)\n# include \"uv/win.h\"\n#else\n# include \"uv/unix.h\"\n#endif\n\n/* Expand this list if necessary. */\n#define UV_ERRNO_MAP(XX)                                                      \\\n  XX(E2BIG, \"argument list too long\")                                         \\\n  XX(EACCES, \"permission denied\")                                             \\\n  XX(EADDRINUSE, \"address already in use\")                                    \\\n  XX(EADDRNOTAVAIL, \"address not available\")                                  \\\n  XX(EAFNOSUPPORT, \"address family not supported\")                            \\\n  XX(EAGAIN, \"resource temporarily unavailable\")                              \\\n  XX(EAI_ADDRFAMILY, \"address family not supported\")                          \\\n  XX(EAI_AGAIN, \"temporary failure\")                                          \\\n  XX(EAI_BADFLAGS, \"bad ai_flags value\")                                      \\\n  XX(EAI_BADHINTS, \"invalid value for hints\")                                 \\\n  XX(EAI_CANCELED, \"request canceled\")                                        \\\n  XX(EAI_FAIL, \"permanent failure\")                                           \\\n  XX(EAI_FAMILY, \"ai_family not supported\")                                   \\\n  XX(EAI_MEMORY, \"out of memory\")                                             \\\n  XX(EAI_NODATA, \"no address\")                                                \\\n  XX(EAI_NONAME, \"unknown node or service\")                                   \\\n  XX(EAI_OVERFLOW, \"argument buffer overflow\")                                \\\n  XX(EAI_PROTOCOL, \"resolved protocol is unknown\")                            \\\n  XX(EAI_SERVICE, \"service not available for socket type\")                    \\\n  XX(EAI_SOCKTYPE, \"socket type not supported\")                               \\\n  XX(EALREADY, \"connection already in progress\")                              \\\n  XX(EBADF, \"bad file descriptor\")                                            \\\n  XX(EBUSY, \"resource busy or locked\")                                        \\\n  XX(ECANCELED, \"operation canceled\")                                         \\\n  XX(ECHARSET, \"invalid Unicode character\")                                   \\\n  XX(ECONNABORTED, \"software caused connection abort\")                        \\\n  XX(ECONNREFUSED, \"connection refused\")                                      \\\n  XX(ECONNRESET, \"connection reset by peer\")                                  \\\n  XX(EDESTADDRREQ, \"destination address required\")                            \\\n  XX(EEXIST, \"file already exists\")                                           \\\n  XX(EFAULT, \"bad address in system call argument\")                           \\\n  XX(EFBIG, \"file too large\")                                                 \\\n  XX(EHOSTUNREACH, \"host is unreachable\")                                     \\\n  XX(EINTR, \"interrupted system call\")                                        \\\n  XX(EINVAL, \"invalid argument\")                                              \\\n  XX(EIO, \"i/o error\")                                                        \\\n  XX(EISCONN, \"socket is already connected\")                                  \\\n  XX(EISDIR, \"illegal operation on a directory\")                              \\\n  XX(ELOOP, \"too many symbolic links encountered\")                            \\\n  XX(EMFILE, \"too many open files\")                                           \\\n  XX(EMSGSIZE, \"message too long\")                                            \\\n  XX(ENAMETOOLONG, \"name too long\")                                           \\\n  XX(ENETDOWN, \"network is down\")                                             \\\n  XX(ENETUNREACH, \"network is unreachable\")                                   \\\n  XX(ENFILE, \"file table overflow\")                                           \\\n  XX(ENOBUFS, \"no buffer space available\")                                    \\\n  XX(ENODEV, \"no such device\")                                                \\\n  XX(ENOENT, \"no such file or directory\")                                     \\\n  XX(ENOMEM, \"not enough memory\")                                             \\\n  XX(ENONET, \"machine is not on the network\")                                 \\\n  XX(ENOPROTOOPT, \"protocol not available\")                                   \\\n  XX(ENOSPC, \"no space left on device\")                                       \\\n  XX(ENOSYS, \"function not implemented\")                                      \\\n  XX(ENOTCONN, \"socket is not connected\")                                     \\\n  XX(ENOTDIR, \"not a directory\")                                              \\\n  XX(ENOTEMPTY, \"directory not empty\")                                        \\\n  XX(ENOTSOCK, \"socket operation on non-socket\")                              \\\n  XX(ENOTSUP, \"operation not supported on socket\")                            \\\n  XX(EPERM, \"operation not permitted\")                                        \\\n  XX(EPIPE, \"broken pipe\")                                                    \\\n  XX(EPROTO, \"protocol error\")                                                \\\n  XX(EPROTONOSUPPORT, \"protocol not supported\")                               \\\n  XX(EPROTOTYPE, \"protocol wrong type for socket\")                            \\\n  XX(ERANGE, \"result too large\")                                              \\\n  XX(EROFS, \"read-only file system\")                                          \\\n  XX(ESHUTDOWN, \"cannot send after transport endpoint shutdown\")              \\\n  XX(ESPIPE, \"invalid seek\")                                                  \\\n  XX(ESRCH, \"no such process\")                                                \\\n  XX(ETIMEDOUT, \"connection timed out\")                                       \\\n  XX(ETXTBSY, \"text file is busy\")                                            \\\n  XX(EXDEV, \"cross-device link not permitted\")                                \\\n  XX(UNKNOWN, \"unknown error\")                                                \\\n  XX(EOF, \"end of file\")                                                      \\\n  XX(ENXIO, \"no such device or address\")                                      \\\n  XX(EMLINK, \"too many links\")                                                \\\n  XX(EHOSTDOWN, \"host is down\")                                               \\\n  XX(EREMOTEIO, \"remote I/O error\")                                           \\\n  XX(ENOTTY, \"inappropriate ioctl for device\")                                \\\n  XX(EFTYPE, \"inappropriate file type or format\")                             \\\n\n#define UV_HANDLE_TYPE_MAP(XX)                                                \\\n  XX(ASYNC, async)                                                            \\\n  XX(CHECK, check)                                                            \\\n  XX(FS_EVENT, fs_event)                                                      \\\n  XX(FS_POLL, fs_poll)                                                        \\\n  XX(HANDLE, handle)                                                          \\\n  XX(IDLE, idle)                                                              \\\n  XX(NAMED_PIPE, pipe)                                                        \\\n  XX(POLL, poll)                                                              \\\n  XX(PREPARE, prepare)                                                        \\\n  XX(PROCESS, process)                                                        \\\n  XX(STREAM, stream)                                                          \\\n  XX(TCP, tcp)                                                                \\\n  XX(TIMER, timer)                                                            \\\n  XX(TTY, tty)                                                                \\\n  XX(UDP, udp)                                                                \\\n  XX(SIGNAL, signal)                                                          \\\n\n#define UV_REQ_TYPE_MAP(XX)                                                   \\\n  XX(REQ, req)                                                                \\\n  XX(CONNECT, connect)                                                        \\\n  XX(WRITE, write)                                                            \\\n  XX(SHUTDOWN, shutdown)                                                      \\\n  XX(UDP_SEND, udp_send)                                                      \\\n  XX(FS, fs)                                                                  \\\n  XX(WORK, work)                                                              \\\n  XX(GETADDRINFO, getaddrinfo)                                                \\\n  XX(GETNAMEINFO, getnameinfo)                                                \\\n\ntypedef enum {\n#define XX(code, _) UV_ ## code = UV__ ## code,\n  UV_ERRNO_MAP(XX)\n#undef XX\n  UV_ERRNO_MAX = UV__EOF - 1\n} uv_errno_t;\n\ntypedef enum {\n  UV_UNKNOWN_HANDLE = 0,\n#define XX(uc, lc) UV_##uc,\n  UV_HANDLE_TYPE_MAP(XX)\n#undef XX\n  UV_FILE,\n  UV_HANDLE_TYPE_MAX\n} uv_handle_type;\n\ntypedef enum {\n  UV_UNKNOWN_REQ = 0,\n#define XX(uc, lc) UV_##uc,\n  UV_REQ_TYPE_MAP(XX)\n#undef XX\n  UV_REQ_TYPE_PRIVATE\n  UV_REQ_TYPE_MAX\n} uv_req_type;\n\n\n/* Handle types. */\ntypedef struct uv_loop_s uv_loop_t;\ntypedef struct uv_handle_s uv_handle_t;\ntypedef struct uv_stream_s uv_stream_t;\ntypedef struct uv_tcp_s uv_tcp_t;\ntypedef struct uv_udp_s uv_udp_t;\ntypedef struct uv_pipe_s uv_pipe_t;\ntypedef struct uv_tty_s uv_tty_t;\ntypedef struct uv_poll_s uv_poll_t;\ntypedef struct uv_timer_s uv_timer_t;\ntypedef struct uv_prepare_s uv_prepare_t;\ntypedef struct uv_check_s uv_check_t;\ntypedef struct uv_idle_s uv_idle_t;\ntypedef struct uv_async_s uv_async_t;\ntypedef struct uv_process_s uv_process_t;\ntypedef struct uv_fs_event_s uv_fs_event_t;\ntypedef struct uv_fs_poll_s uv_fs_poll_t;\ntypedef struct uv_signal_s uv_signal_t;\n\n/* Request types. */\ntypedef struct uv_req_s uv_req_t;\ntypedef struct uv_getaddrinfo_s uv_getaddrinfo_t;\ntypedef struct uv_getnameinfo_s uv_getnameinfo_t;\ntypedef struct uv_shutdown_s uv_shutdown_t;\ntypedef struct uv_write_s uv_write_t;\ntypedef struct uv_connect_s uv_connect_t;\ntypedef struct uv_udp_send_s uv_udp_send_t;\ntypedef struct uv_fs_s uv_fs_t;\ntypedef struct uv_work_s uv_work_t;\n\n/* None of the above. */\ntypedef struct uv_cpu_info_s uv_cpu_info_t;\ntypedef struct uv_interface_address_s uv_interface_address_t;\ntypedef struct uv_dirent_s uv_dirent_t;\ntypedef struct uv_passwd_s uv_passwd_t;\ntypedef struct uv_utsname_s uv_utsname_t;\n\ntypedef enum {\n  UV_LOOP_BLOCK_SIGNAL\n} uv_loop_option;\n\ntypedef enum {\n  UV_RUN_DEFAULT = 0,\n  UV_RUN_ONCE,\n  UV_RUN_NOWAIT\n} uv_run_mode;\n\n\nUV_EXTERN unsigned int uv_version(void);\nUV_EXTERN const char* uv_version_string(void);\n\ntypedef void* (*uv_malloc_func)(size_t size);\ntypedef void* (*uv_realloc_func)(void* ptr, size_t size);\ntypedef void* (*uv_calloc_func)(size_t count, size_t size);\ntypedef void (*uv_free_func)(void* ptr);\n\nUV_EXTERN int uv_replace_allocator(uv_malloc_func malloc_func,\n                                   uv_realloc_func realloc_func,\n                                   uv_calloc_func calloc_func,\n                                   uv_free_func free_func);\n\nUV_EXTERN uv_loop_t* uv_default_loop(void);\nUV_EXTERN int uv_loop_init(uv_loop_t* loop);\nUV_EXTERN int uv_loop_close(uv_loop_t* loop);\n/*\n * NOTE:\n *  This function is DEPRECATED (to be removed after 0.12), users should\n *  allocate the loop manually and use uv_loop_init instead.\n */\nUV_EXTERN uv_loop_t* uv_loop_new(void);\n/*\n * NOTE:\n *  This function is DEPRECATED (to be removed after 0.12). Users should use\n *  uv_loop_close and free the memory manually instead.\n */\nUV_EXTERN void uv_loop_delete(uv_loop_t*);\nUV_EXTERN size_t uv_loop_size(void);\nUV_EXTERN int uv_loop_alive(const uv_loop_t* loop);\nUV_EXTERN int uv_loop_configure(uv_loop_t* loop, uv_loop_option option, ...);\nUV_EXTERN int uv_loop_fork(uv_loop_t* loop);\n\nUV_EXTERN int uv_run(uv_loop_t*, uv_run_mode mode);\nUV_EXTERN void uv_stop(uv_loop_t*);\n\nUV_EXTERN void uv_ref(uv_handle_t*);\nUV_EXTERN void uv_unref(uv_handle_t*);\nUV_EXTERN int uv_has_ref(const uv_handle_t*);\n\nUV_EXTERN void uv_update_time(uv_loop_t*);\nUV_EXTERN uint64_t uv_now(const uv_loop_t*);\n\nUV_EXTERN int uv_backend_fd(const uv_loop_t*);\nUV_EXTERN int uv_backend_timeout(const uv_loop_t*);\n\ntypedef void (*uv_alloc_cb)(uv_handle_t* handle,\n                            size_t suggested_size,\n                            uv_buf_t* buf);\ntypedef void (*uv_read_cb)(uv_stream_t* stream,\n                           ssize_t nread,\n                           const uv_buf_t* buf);\ntypedef void (*uv_write_cb)(uv_write_t* req, int status);\ntypedef void (*uv_connect_cb)(uv_connect_t* req, int status);\ntypedef void (*uv_shutdown_cb)(uv_shutdown_t* req, int status);\ntypedef void (*uv_connection_cb)(uv_stream_t* server, int status);\ntypedef void (*uv_close_cb)(uv_handle_t* handle);\ntypedef void (*uv_poll_cb)(uv_poll_t* handle, int status, int events);\ntypedef void (*uv_timer_cb)(uv_timer_t* handle);\ntypedef void (*uv_async_cb)(uv_async_t* handle);\ntypedef void (*uv_prepare_cb)(uv_prepare_t* handle);\ntypedef void (*uv_check_cb)(uv_check_t* handle);\ntypedef void (*uv_idle_cb)(uv_idle_t* handle);\ntypedef void (*uv_exit_cb)(uv_process_t*, int64_t exit_status, int term_signal);\ntypedef void (*uv_walk_cb)(uv_handle_t* handle, void* arg);\ntypedef void (*uv_fs_cb)(uv_fs_t* req);\ntypedef void (*uv_work_cb)(uv_work_t* req);\ntypedef void (*uv_after_work_cb)(uv_work_t* req, int status);\ntypedef void (*uv_getaddrinfo_cb)(uv_getaddrinfo_t* req,\n                                  int status,\n                                  struct addrinfo* res);\ntypedef void (*uv_getnameinfo_cb)(uv_getnameinfo_t* req,\n                                  int status,\n                                  const char* hostname,\n                                  const char* service);\n\ntypedef struct {\n  long tv_sec;\n  long tv_nsec;\n} uv_timespec_t;\n\n\ntypedef struct {\n  uint64_t st_dev;\n  uint64_t st_mode;\n  uint64_t st_nlink;\n  uint64_t st_uid;\n  uint64_t st_gid;\n  uint64_t st_rdev;\n  uint64_t st_ino;\n  uint64_t st_size;\n  uint64_t st_blksize;\n  uint64_t st_blocks;\n  uint64_t st_flags;\n  uint64_t st_gen;\n  uv_timespec_t st_atim;\n  uv_timespec_t st_mtim;\n  uv_timespec_t st_ctim;\n  uv_timespec_t st_birthtim;\n} uv_stat_t;\n\n\ntypedef void (*uv_fs_event_cb)(uv_fs_event_t* handle,\n                               const char* filename,\n                               int events,\n                               int status);\n\ntypedef void (*uv_fs_poll_cb)(uv_fs_poll_t* handle,\n                              int status,\n                              const uv_stat_t* prev,\n                              const uv_stat_t* curr);\n\ntypedef void (*uv_signal_cb)(uv_signal_t* handle, int signum);\n\n\ntypedef enum {\n  UV_LEAVE_GROUP = 0,\n  UV_JOIN_GROUP\n} uv_membership;\n\n\nUV_EXTERN int uv_translate_sys_error(int sys_errno);\n\nUV_EXTERN const char* uv_strerror(int err);\nUV_EXTERN char* uv_strerror_r(int err, char* buf, size_t buflen);\n\nUV_EXTERN const char* uv_err_name(int err);\nUV_EXTERN char* uv_err_name_r(int err, char* buf, size_t buflen);\n\n\n#define UV_REQ_FIELDS                                                         \\\n  /* public */                                                                \\\n  void* data;                                                                 \\\n  /* read-only */                                                             \\\n  uv_req_type type;                                                           \\\n  /* private */                                                               \\\n  void* reserved[6];                                                          \\\n  UV_REQ_PRIVATE_FIELDS                                                       \\\n\n/* Abstract base class of all requests. */\nstruct uv_req_s {\n  UV_REQ_FIELDS\n};\n\n\n/* Platform-specific request types. */\nUV_PRIVATE_REQ_TYPES\n\n\nUV_EXTERN int uv_shutdown(uv_shutdown_t* req,\n                          uv_stream_t* handle,\n                          uv_shutdown_cb cb);\n\nstruct uv_shutdown_s {\n  UV_REQ_FIELDS\n  uv_stream_t* handle;\n  uv_shutdown_cb cb;\n  UV_SHUTDOWN_PRIVATE_FIELDS\n};\n\n\n#define UV_HANDLE_FIELDS                                                      \\\n  /* public */                                                                \\\n  void* data;                                                                 \\\n  /* read-only */                                                             \\\n  uv_loop_t* loop;                                                            \\\n  uv_handle_type type;                                                        \\\n  /* private */                                                               \\\n  uv_close_cb close_cb;                                                       \\\n  void* handle_queue[2];                                                      \\\n  union {                                                                     \\\n    int fd;                                                                   \\\n    void* reserved[4];                                                        \\\n  } u;                                                                        \\\n  UV_HANDLE_PRIVATE_FIELDS                                                    \\\n\n/* The abstract base class of all handles. */\nstruct uv_handle_s {\n  UV_HANDLE_FIELDS\n};\n\nUV_EXTERN size_t uv_handle_size(uv_handle_type type);\nUV_EXTERN uv_handle_type uv_handle_get_type(const uv_handle_t* handle);\nUV_EXTERN const char* uv_handle_type_name(uv_handle_type type);\nUV_EXTERN void* uv_handle_get_data(const uv_handle_t* handle);\nUV_EXTERN uv_loop_t* uv_handle_get_loop(const uv_handle_t* handle);\nUV_EXTERN void uv_handle_set_data(uv_handle_t* handle, void* data);\n\nUV_EXTERN size_t uv_req_size(uv_req_type type);\nUV_EXTERN void* uv_req_get_data(const uv_req_t* req);\nUV_EXTERN void uv_req_set_data(uv_req_t* req, void* data);\nUV_EXTERN uv_req_type uv_req_get_type(const uv_req_t* req);\nUV_EXTERN const char* uv_req_type_name(uv_req_type type);\n\nUV_EXTERN int uv_is_active(const uv_handle_t* handle);\n\nUV_EXTERN void uv_walk(uv_loop_t* loop, uv_walk_cb walk_cb, void* arg);\n\n/* Helpers for ad hoc debugging, no API/ABI stability guaranteed. */\nUV_EXTERN void uv_print_all_handles(uv_loop_t* loop, FILE* stream);\nUV_EXTERN void uv_print_active_handles(uv_loop_t* loop, FILE* stream);\n\nUV_EXTERN void uv_close(uv_handle_t* handle, uv_close_cb close_cb);\n\nUV_EXTERN int uv_send_buffer_size(uv_handle_t* handle, int* value);\nUV_EXTERN int uv_recv_buffer_size(uv_handle_t* handle, int* value);\n\nUV_EXTERN int uv_fileno(const uv_handle_t* handle, uv_os_fd_t* fd);\n\nUV_EXTERN uv_buf_t uv_buf_init(char* base, unsigned int len);\n\n\n#define UV_STREAM_FIELDS                                                      \\\n  /* number of bytes queued for writing */                                    \\\n  size_t write_queue_size;                                                    \\\n  uv_alloc_cb alloc_cb;                                                       \\\n  uv_read_cb read_cb;                                                         \\\n  /* private */                                                               \\\n  UV_STREAM_PRIVATE_FIELDS\n\n/*\n * uv_stream_t is a subclass of uv_handle_t.\n *\n * uv_stream is an abstract class.\n *\n * uv_stream_t is the parent class of uv_tcp_t, uv_pipe_t and uv_tty_t.\n */\nstruct uv_stream_s {\n  UV_HANDLE_FIELDS\n  UV_STREAM_FIELDS\n};\n\nUV_EXTERN size_t uv_stream_get_write_queue_size(const uv_stream_t* stream);\n\nUV_EXTERN int uv_listen(uv_stream_t* stream, int backlog, uv_connection_cb cb);\nUV_EXTERN int uv_accept(uv_stream_t* server, uv_stream_t* client);\n\nUV_EXTERN int uv_read_start(uv_stream_t*,\n                            uv_alloc_cb alloc_cb,\n                            uv_read_cb read_cb);\nUV_EXTERN int uv_read_stop(uv_stream_t*);\n\nUV_EXTERN int uv_write(uv_write_t* req,\n                       uv_stream_t* handle,\n                       const uv_buf_t bufs[],\n                       unsigned int nbufs,\n                       uv_write_cb cb);\nUV_EXTERN int uv_write2(uv_write_t* req,\n                        uv_stream_t* handle,\n                        const uv_buf_t bufs[],\n                        unsigned int nbufs,\n                        uv_stream_t* send_handle,\n                        uv_write_cb cb);\nUV_EXTERN int uv_try_write(uv_stream_t* handle,\n                           const uv_buf_t bufs[],\n                           unsigned int nbufs);\n\n/* uv_write_t is a subclass of uv_req_t. */\nstruct uv_write_s {\n  UV_REQ_FIELDS\n  uv_write_cb cb;\n  uv_stream_t* send_handle; /* TODO: make private and unix-only in v2.x. */\n  uv_stream_t* handle;\n  UV_WRITE_PRIVATE_FIELDS\n};\n\n\nUV_EXTERN int uv_is_readable(const uv_stream_t* handle);\nUV_EXTERN int uv_is_writable(const uv_stream_t* handle);\n\nUV_EXTERN int uv_stream_set_blocking(uv_stream_t* handle, int blocking);\n\nUV_EXTERN int uv_is_closing(const uv_handle_t* handle);\n\n\n/*\n * uv_tcp_t is a subclass of uv_stream_t.\n *\n * Represents a TCP stream or TCP server.\n */\nstruct uv_tcp_s {\n  UV_HANDLE_FIELDS\n  UV_STREAM_FIELDS\n  UV_TCP_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_tcp_init(uv_loop_t*, uv_tcp_t* handle);\nUV_EXTERN int uv_tcp_init_ex(uv_loop_t*, uv_tcp_t* handle, unsigned int flags);\nUV_EXTERN int uv_tcp_open(uv_tcp_t* handle, uv_os_sock_t sock);\nUV_EXTERN int uv_tcp_nodelay(uv_tcp_t* handle, int enable);\nUV_EXTERN int uv_tcp_keepalive(uv_tcp_t* handle,\n                               int enable,\n                               unsigned int delay);\nUV_EXTERN int uv_tcp_simultaneous_accepts(uv_tcp_t* handle, int enable);\n\nenum uv_tcp_flags {\n  /* Used with uv_tcp_bind, when an IPv6 address is used. */\n  UV_TCP_IPV6ONLY = 1\n};\n\nUV_EXTERN int uv_tcp_bind(uv_tcp_t* handle,\n                          const struct sockaddr* addr,\n                          unsigned int flags);\nUV_EXTERN int uv_tcp_getsockname(const uv_tcp_t* handle,\n                                 struct sockaddr* name,\n                                 int* namelen);\nUV_EXTERN int uv_tcp_getpeername(const uv_tcp_t* handle,\n                                 struct sockaddr* name,\n                                 int* namelen);\nUV_EXTERN int uv_tcp_connect(uv_connect_t* req,\n                             uv_tcp_t* handle,\n                             const struct sockaddr* addr,\n                             uv_connect_cb cb);\n\n/* uv_connect_t is a subclass of uv_req_t. */\nstruct uv_connect_s {\n  UV_REQ_FIELDS\n  uv_connect_cb cb;\n  uv_stream_t* handle;\n  UV_CONNECT_PRIVATE_FIELDS\n};\n\n\n/*\n * UDP support.\n */\n\nenum uv_udp_flags {\n  /* Disables dual stack mode. */\n  UV_UDP_IPV6ONLY = 1,\n  /*\n   * Indicates message was truncated because read buffer was too small. The\n   * remainder was discarded by the OS. Used in uv_udp_recv_cb.\n   */\n  UV_UDP_PARTIAL = 2,\n  /*\n   * Indicates if SO_REUSEADDR will be set when binding the handle.\n   * This sets the SO_REUSEPORT socket flag on the BSDs and OS X. On other\n   * Unix platforms, it sets the SO_REUSEADDR flag.  What that means is that\n   * multiple threads or processes can bind to the same address without error\n   * (provided they all set the flag) but only the last one to bind will receive\n   * any traffic, in effect \"stealing\" the port from the previous listener.\n   */\n  UV_UDP_REUSEADDR = 4\n};\n\ntypedef void (*uv_udp_send_cb)(uv_udp_send_t* req, int status);\ntypedef void (*uv_udp_recv_cb)(uv_udp_t* handle,\n                               ssize_t nread,\n                               const uv_buf_t* buf,\n                               const struct sockaddr* addr,\n                               unsigned flags);\n\n/* uv_udp_t is a subclass of uv_handle_t. */\nstruct uv_udp_s {\n  UV_HANDLE_FIELDS\n  /* read-only */\n  /*\n   * Number of bytes queued for sending. This field strictly shows how much\n   * information is currently queued.\n   */\n  size_t send_queue_size;\n  /*\n   * Number of send requests currently in the queue awaiting to be processed.\n   */\n  size_t send_queue_count;\n  UV_UDP_PRIVATE_FIELDS\n};\n\n/* uv_udp_send_t is a subclass of uv_req_t. */\nstruct uv_udp_send_s {\n  UV_REQ_FIELDS\n  uv_udp_t* handle;\n  uv_udp_send_cb cb;\n  UV_UDP_SEND_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_udp_init(uv_loop_t*, uv_udp_t* handle);\nUV_EXTERN int uv_udp_init_ex(uv_loop_t*, uv_udp_t* handle, unsigned int flags);\nUV_EXTERN int uv_udp_open(uv_udp_t* handle, uv_os_sock_t sock);\nUV_EXTERN int uv_udp_bind(uv_udp_t* handle,\n                          const struct sockaddr* addr,\n                          unsigned int flags);\n\nUV_EXTERN int uv_udp_getsockname(const uv_udp_t* handle,\n                                 struct sockaddr* name,\n                                 int* namelen);\nUV_EXTERN int uv_udp_set_membership(uv_udp_t* handle,\n                                    const char* multicast_addr,\n                                    const char* interface_addr,\n                                    uv_membership membership);\nUV_EXTERN int uv_udp_set_multicast_loop(uv_udp_t* handle, int on);\nUV_EXTERN int uv_udp_set_multicast_ttl(uv_udp_t* handle, int ttl);\nUV_EXTERN int uv_udp_set_multicast_interface(uv_udp_t* handle,\n                                             const char* interface_addr);\nUV_EXTERN int uv_udp_set_broadcast(uv_udp_t* handle, int on);\nUV_EXTERN int uv_udp_set_ttl(uv_udp_t* handle, int ttl);\nUV_EXTERN int uv_udp_send(uv_udp_send_t* req,\n                          uv_udp_t* handle,\n                          const uv_buf_t bufs[],\n                          unsigned int nbufs,\n                          const struct sockaddr* addr,\n                          uv_udp_send_cb send_cb);\nUV_EXTERN int uv_udp_try_send(uv_udp_t* handle,\n                              const uv_buf_t bufs[],\n                              unsigned int nbufs,\n                              const struct sockaddr* addr);\nUV_EXTERN int uv_udp_recv_start(uv_udp_t* handle,\n                                uv_alloc_cb alloc_cb,\n                                uv_udp_recv_cb recv_cb);\nUV_EXTERN int uv_udp_recv_stop(uv_udp_t* handle);\nUV_EXTERN size_t uv_udp_get_send_queue_size(const uv_udp_t* handle);\nUV_EXTERN size_t uv_udp_get_send_queue_count(const uv_udp_t* handle);\n\n\n/*\n * uv_tty_t is a subclass of uv_stream_t.\n *\n * Representing a stream for the console.\n */\nstruct uv_tty_s {\n  UV_HANDLE_FIELDS\n  UV_STREAM_FIELDS\n  UV_TTY_PRIVATE_FIELDS\n};\n\ntypedef enum {\n  /* Initial/normal terminal mode */\n  UV_TTY_MODE_NORMAL,\n  /* Raw input mode (On Windows, ENABLE_WINDOW_INPUT is also enabled) */\n  UV_TTY_MODE_RAW,\n  /* Binary-safe I/O mode for IPC (Unix-only) */\n  UV_TTY_MODE_IO\n} uv_tty_mode_t;\n\nUV_EXTERN int uv_tty_init(uv_loop_t*, uv_tty_t*, uv_file fd, int readable);\nUV_EXTERN int uv_tty_set_mode(uv_tty_t*, uv_tty_mode_t mode);\nUV_EXTERN int uv_tty_reset_mode(void);\nUV_EXTERN int uv_tty_get_winsize(uv_tty_t*, int* width, int* height);\n\n#ifdef __cplusplus\nextern \"C++\" {\n\ninline int uv_tty_set_mode(uv_tty_t* handle, int mode) {\n  return uv_tty_set_mode(handle, static_cast<uv_tty_mode_t>(mode));\n}\n\n}\n#endif\n\nUV_EXTERN uv_handle_type uv_guess_handle(uv_file file);\n\n/*\n * uv_pipe_t is a subclass of uv_stream_t.\n *\n * Representing a pipe stream or pipe server. On Windows this is a Named\n * Pipe. On Unix this is a Unix domain socket.\n */\nstruct uv_pipe_s {\n  UV_HANDLE_FIELDS\n  UV_STREAM_FIELDS\n  int ipc; /* non-zero if this pipe is used for passing handles */\n  UV_PIPE_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_pipe_init(uv_loop_t*, uv_pipe_t* handle, int ipc);\nUV_EXTERN int uv_pipe_open(uv_pipe_t*, uv_file file);\nUV_EXTERN int uv_pipe_bind(uv_pipe_t* handle, const char* name);\nUV_EXTERN void uv_pipe_connect(uv_connect_t* req,\n                               uv_pipe_t* handle,\n                               const char* name,\n                               uv_connect_cb cb);\nUV_EXTERN int uv_pipe_getsockname(const uv_pipe_t* handle,\n                                  char* buffer,\n                                  size_t* size);\nUV_EXTERN int uv_pipe_getpeername(const uv_pipe_t* handle,\n                                  char* buffer,\n                                  size_t* size);\nUV_EXTERN void uv_pipe_pending_instances(uv_pipe_t* handle, int count);\nUV_EXTERN int uv_pipe_pending_count(uv_pipe_t* handle);\nUV_EXTERN uv_handle_type uv_pipe_pending_type(uv_pipe_t* handle);\nUV_EXTERN int uv_pipe_chmod(uv_pipe_t* handle, int flags);\n\n\nstruct uv_poll_s {\n  UV_HANDLE_FIELDS\n  uv_poll_cb poll_cb;\n  UV_POLL_PRIVATE_FIELDS\n};\n\nenum uv_poll_event {\n  UV_READABLE = 1,\n  UV_WRITABLE = 2,\n  UV_DISCONNECT = 4,\n  UV_PRIORITIZED = 8\n};\n\nUV_EXTERN int uv_poll_init(uv_loop_t* loop, uv_poll_t* handle, int fd);\nUV_EXTERN int uv_poll_init_socket(uv_loop_t* loop,\n                                  uv_poll_t* handle,\n                                  uv_os_sock_t socket);\nUV_EXTERN int uv_poll_start(uv_poll_t* handle, int events, uv_poll_cb cb);\nUV_EXTERN int uv_poll_stop(uv_poll_t* handle);\n\n\nstruct uv_prepare_s {\n  UV_HANDLE_FIELDS\n  UV_PREPARE_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_prepare_init(uv_loop_t*, uv_prepare_t* prepare);\nUV_EXTERN int uv_prepare_start(uv_prepare_t* prepare, uv_prepare_cb cb);\nUV_EXTERN int uv_prepare_stop(uv_prepare_t* prepare);\n\n\nstruct uv_check_s {\n  UV_HANDLE_FIELDS\n  UV_CHECK_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_check_init(uv_loop_t*, uv_check_t* check);\nUV_EXTERN int uv_check_start(uv_check_t* check, uv_check_cb cb);\nUV_EXTERN int uv_check_stop(uv_check_t* check);\n\n\nstruct uv_idle_s {\n  UV_HANDLE_FIELDS\n  UV_IDLE_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_idle_init(uv_loop_t*, uv_idle_t* idle);\nUV_EXTERN int uv_idle_start(uv_idle_t* idle, uv_idle_cb cb);\nUV_EXTERN int uv_idle_stop(uv_idle_t* idle);\n\n\nstruct uv_async_s {\n  UV_HANDLE_FIELDS\n  UV_ASYNC_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_async_init(uv_loop_t*,\n                            uv_async_t* async,\n                            uv_async_cb async_cb);\nUV_EXTERN int uv_async_send(uv_async_t* async);\n\n\n/*\n * uv_timer_t is a subclass of uv_handle_t.\n *\n * Used to get woken up at a specified time in the future.\n */\nstruct uv_timer_s {\n  UV_HANDLE_FIELDS\n  UV_TIMER_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_timer_init(uv_loop_t*, uv_timer_t* handle);\nUV_EXTERN int uv_timer_start(uv_timer_t* handle,\n                             uv_timer_cb cb,\n                             uint64_t timeout,\n                             uint64_t repeat);\nUV_EXTERN int uv_timer_stop(uv_timer_t* handle);\nUV_EXTERN int uv_timer_again(uv_timer_t* handle);\nUV_EXTERN void uv_timer_set_repeat(uv_timer_t* handle, uint64_t repeat);\nUV_EXTERN uint64_t uv_timer_get_repeat(const uv_timer_t* handle);\n\n\n/*\n * uv_getaddrinfo_t is a subclass of uv_req_t.\n *\n * Request object for uv_getaddrinfo.\n */\nstruct uv_getaddrinfo_s {\n  UV_REQ_FIELDS\n  /* read-only */\n  uv_loop_t* loop;\n  /* struct addrinfo* addrinfo is marked as private, but it really isn't. */\n  UV_GETADDRINFO_PRIVATE_FIELDS\n};\n\n\nUV_EXTERN int uv_getaddrinfo(uv_loop_t* loop,\n                             uv_getaddrinfo_t* req,\n                             uv_getaddrinfo_cb getaddrinfo_cb,\n                             const char* node,\n                             const char* service,\n                             const struct addrinfo* hints);\nUV_EXTERN void uv_freeaddrinfo(struct addrinfo* ai);\n\n\n/*\n* uv_getnameinfo_t is a subclass of uv_req_t.\n*\n* Request object for uv_getnameinfo.\n*/\nstruct uv_getnameinfo_s {\n  UV_REQ_FIELDS\n  /* read-only */\n  uv_loop_t* loop;\n  /* host and service are marked as private, but they really aren't. */\n  UV_GETNAMEINFO_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_getnameinfo(uv_loop_t* loop,\n                             uv_getnameinfo_t* req,\n                             uv_getnameinfo_cb getnameinfo_cb,\n                             const struct sockaddr* addr,\n                             int flags);\n\n\n/* uv_spawn() options. */\ntypedef enum {\n  UV_IGNORE         = 0x00,\n  UV_CREATE_PIPE    = 0x01,\n  UV_INHERIT_FD     = 0x02,\n  UV_INHERIT_STREAM = 0x04,\n\n  /*\n   * When UV_CREATE_PIPE is specified, UV_READABLE_PIPE and UV_WRITABLE_PIPE\n   * determine the direction of flow, from the child process' perspective. Both\n   * flags may be specified to create a duplex data stream.\n   */\n  UV_READABLE_PIPE  = 0x10,\n  UV_WRITABLE_PIPE  = 0x20,\n\n  /*\n   * Open the child pipe handle in overlapped mode on Windows.\n   * On Unix it is silently ignored.\n   */\n  UV_OVERLAPPED_PIPE = 0x40\n} uv_stdio_flags;\n\ntypedef struct uv_stdio_container_s {\n  uv_stdio_flags flags;\n\n  union {\n    uv_stream_t* stream;\n    int fd;\n  } data;\n} uv_stdio_container_t;\n\ntypedef struct uv_process_options_s {\n  uv_exit_cb exit_cb; /* Called after the process exits. */\n  const char* file;   /* Path to program to execute. */\n  /*\n   * Command line arguments. args[0] should be the path to the program. On\n   * Windows this uses CreateProcess which concatenates the arguments into a\n   * string this can cause some strange errors. See the note at\n   * windows_verbatim_arguments.\n   */\n  char** args;\n  /*\n   * This will be set as the environ variable in the subprocess. If this is\n   * NULL then the parents environ will be used.\n   */\n  char** env;\n  /*\n   * If non-null this represents a directory the subprocess should execute\n   * in. Stands for current working directory.\n   */\n  const char* cwd;\n  /*\n   * Various flags that control how uv_spawn() behaves. See the definition of\n   * `enum uv_process_flags` below.\n   */\n  unsigned int flags;\n  /*\n   * The `stdio` field points to an array of uv_stdio_container_t structs that\n   * describe the file descriptors that will be made available to the child\n   * process. The convention is that stdio[0] points to stdin, fd 1 is used for\n   * stdout, and fd 2 is stderr.\n   *\n   * Note that on windows file descriptors greater than 2 are available to the\n   * child process only if the child processes uses the MSVCRT runtime.\n   */\n  int stdio_count;\n  uv_stdio_container_t* stdio;\n  /*\n   * Libuv can change the child process' user/group id. This happens only when\n   * the appropriate bits are set in the flags fields. This is not supported on\n   * windows; uv_spawn() will fail and set the error to UV_ENOTSUP.\n   */\n  uv_uid_t uid;\n  uv_gid_t gid;\n  /*\n    Libuv can set the child process' CPU affinity mask.  This happens when\n    `cpumask` is non-NULL.  It must point to an array of char values\n    of length `cpumask_size`, whose value must be at least that returned by\n    uv_cpumask_size().  Each byte in the mask can be either zero (false)\n    or non-zero (true) to indicate whether the corresponding processor at\n    that index is included.\n\n    If enabled on an unsupported platform, uv_spawn() will fail with\n    UV_ENOTSUP.\n   */\n  char* cpumask;\n  size_t cpumask_size;\n} uv_process_options_t;\n\n/*\n * These are the flags that can be used for the uv_process_options.flags field.\n */\nenum uv_process_flags {\n  /*\n   * Set the child process' user id. The user id is supplied in the `uid` field\n   * of the options struct. This does not work on windows; setting this flag\n   * will cause uv_spawn() to fail.\n   */\n  UV_PROCESS_SETUID = (1 << 0),\n  /*\n   * Set the child process' group id. The user id is supplied in the `gid`\n   * field of the options struct. This does not work on windows; setting this\n   * flag will cause uv_spawn() to fail.\n   */\n  UV_PROCESS_SETGID = (1 << 1),\n  /*\n   * Do not wrap any arguments in quotes, or perform any other escaping, when\n   * converting the argument list into a command line string. This option is\n   * only meaningful on Windows systems. On Unix it is silently ignored.\n   */\n  UV_PROCESS_WINDOWS_VERBATIM_ARGUMENTS = (1 << 2),\n  /*\n   * Spawn the child process in a detached state - this will make it a process\n   * group leader, and will effectively enable the child to keep running after\n   * the parent exits.  Note that the child process will still keep the\n   * parent's event loop alive unless the parent process calls uv_unref() on\n   * the child's process handle.\n   */\n  UV_PROCESS_DETACHED = (1 << 3),\n  /*\n   * Hide the subprocess window that would normally be created. This option is\n   * only meaningful on Windows systems. On Unix it is silently ignored.\n   */\n  UV_PROCESS_WINDOWS_HIDE = (1 << 4),\n  /*\n   * Hide the subprocess console window that would normally be created. This\n   * option is only meaningful on Windows systems. On Unix it is silently\n   * ignored.\n   */\n  UV_PROCESS_WINDOWS_HIDE_CONSOLE = (1 << 5),\n  /*\n   * Hide the subprocess GUI window that would normally be created. This\n   * option is only meaningful on Windows systems. On Unix it is silently\n   * ignored.\n   */\n  UV_PROCESS_WINDOWS_HIDE_GUI = (1 << 6)\n};\n\n/*\n * uv_process_t is a subclass of uv_handle_t.\n */\nstruct uv_process_s {\n  UV_HANDLE_FIELDS\n  uv_exit_cb exit_cb;\n  int pid;\n  UV_PROCESS_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_spawn(uv_loop_t* loop,\n                       uv_process_t* handle,\n                       const uv_process_options_t* options);\nUV_EXTERN int uv_process_kill(uv_process_t*, int signum);\nUV_EXTERN int uv_kill(int pid, int signum);\nUV_EXTERN uv_pid_t uv_process_get_pid(const uv_process_t*);\n\n\n/*\n * uv_work_t is a subclass of uv_req_t.\n */\nstruct uv_work_s {\n  UV_REQ_FIELDS\n  uv_loop_t* loop;\n  uv_work_cb work_cb;\n  uv_after_work_cb after_work_cb;\n  UV_WORK_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_queue_work(uv_loop_t* loop,\n                            uv_work_t* req,\n                            uv_work_cb work_cb,\n                            uv_after_work_cb after_work_cb);\n\nUV_EXTERN int uv_cancel(uv_req_t* req);\n\n\nstruct uv_cpu_times_s {\n  uint64_t user;\n  uint64_t nice;\n  uint64_t sys;\n  uint64_t idle;\n  uint64_t irq;\n};\n\nstruct uv_cpu_info_s {\n  char* model;\n  int speed;\n  struct uv_cpu_times_s cpu_times;\n};\n\nstruct uv_interface_address_s {\n  char* name;\n  char phys_addr[6];\n  int is_internal;\n  union {\n    struct sockaddr_in address4;\n    struct sockaddr_in6 address6;\n  } address;\n  union {\n    struct sockaddr_in netmask4;\n    struct sockaddr_in6 netmask6;\n  } netmask;\n};\n\nstruct uv_passwd_s {\n  char* username;\n  long uid;\n  long gid;\n  char* shell;\n  char* homedir;\n};\n\nstruct uv_utsname_s {\n  char sysname[256];\n  char release[256];\n  char version[256];\n  char machine[256];\n  /* This struct does not contain the nodename and domainname fields present in\n     the utsname type. domainname is a GNU extension. Both fields are referred\n     to as meaningless in the docs. */\n};\n\ntypedef enum {\n  UV_DIRENT_UNKNOWN,\n  UV_DIRENT_FILE,\n  UV_DIRENT_DIR,\n  UV_DIRENT_LINK,\n  UV_DIRENT_FIFO,\n  UV_DIRENT_SOCKET,\n  UV_DIRENT_CHAR,\n  UV_DIRENT_BLOCK\n} uv_dirent_type_t;\n\nstruct uv_dirent_s {\n  const char* name;\n  uv_dirent_type_t type;\n};\n\nUV_EXTERN char** uv_setup_args(int argc, char** argv);\nUV_EXTERN int uv_get_process_title(char* buffer, size_t size);\nUV_EXTERN int uv_set_process_title(const char* title);\nUV_EXTERN int uv_resident_set_memory(size_t* rss);\nUV_EXTERN int uv_uptime(double* uptime);\nUV_EXTERN uv_os_fd_t uv_get_osfhandle(int fd);\nUV_EXTERN int uv_open_osfhandle(uv_os_fd_t os_fd);\n\ntypedef struct {\n  long tv_sec;\n  long tv_usec;\n} uv_timeval_t;\n\ntypedef struct {\n   uv_timeval_t ru_utime; /* user CPU time used */\n   uv_timeval_t ru_stime; /* system CPU time used */\n   uint64_t ru_maxrss;    /* maximum resident set size */\n   uint64_t ru_ixrss;     /* integral shared memory size */\n   uint64_t ru_idrss;     /* integral unshared data size */\n   uint64_t ru_isrss;     /* integral unshared stack size */\n   uint64_t ru_minflt;    /* page reclaims (soft page faults) */\n   uint64_t ru_majflt;    /* page faults (hard page faults) */\n   uint64_t ru_nswap;     /* swaps */\n   uint64_t ru_inblock;   /* block input operations */\n   uint64_t ru_oublock;   /* block output operations */\n   uint64_t ru_msgsnd;    /* IPC messages sent */\n   uint64_t ru_msgrcv;    /* IPC messages received */\n   uint64_t ru_nsignals;  /* signals received */\n   uint64_t ru_nvcsw;     /* voluntary context switches */\n   uint64_t ru_nivcsw;    /* involuntary context switches */\n} uv_rusage_t;\n\nUV_EXTERN int uv_getrusage(uv_rusage_t* rusage);\n\nUV_EXTERN int uv_os_homedir(char* buffer, size_t* size);\nUV_EXTERN int uv_os_tmpdir(char* buffer, size_t* size);\nUV_EXTERN int uv_os_get_passwd(uv_passwd_t* pwd);\nUV_EXTERN void uv_os_free_passwd(uv_passwd_t* pwd);\nUV_EXTERN uv_pid_t uv_os_getpid(void);\nUV_EXTERN uv_pid_t uv_os_getppid(void);\n\n#define UV_PRIORITY_LOW 19\n#define UV_PRIORITY_BELOW_NORMAL 10\n#define UV_PRIORITY_NORMAL 0\n#define UV_PRIORITY_ABOVE_NORMAL -7\n#define UV_PRIORITY_HIGH -14\n#define UV_PRIORITY_HIGHEST -20\n\nUV_EXTERN int uv_os_getpriority(uv_pid_t pid, int* priority);\nUV_EXTERN int uv_os_setpriority(uv_pid_t pid, int priority);\n\nUV_EXTERN int uv_cpu_info(uv_cpu_info_t** cpu_infos, int* count);\nUV_EXTERN void uv_free_cpu_info(uv_cpu_info_t* cpu_infos, int count);\nUV_EXTERN int uv_cpumask_size(void);\n\nUV_EXTERN int uv_interface_addresses(uv_interface_address_t** addresses,\n                                     int* count);\nUV_EXTERN void uv_free_interface_addresses(uv_interface_address_t* addresses,\n                                           int count);\n\nUV_EXTERN int uv_os_getenv(const char* name, char* buffer, size_t* size);\nUV_EXTERN int uv_os_setenv(const char* name, const char* value);\nUV_EXTERN int uv_os_unsetenv(const char* name);\n\nUV_EXTERN int uv_os_gethostname(char* buffer, size_t* size);\n\nUV_EXTERN int uv_os_uname(uv_utsname_t* buffer);\n\n\ntypedef enum {\n  UV_FS_UNKNOWN = -1,\n  UV_FS_CUSTOM,\n  UV_FS_OPEN,\n  UV_FS_CLOSE,\n  UV_FS_READ,\n  UV_FS_WRITE,\n  UV_FS_SENDFILE,\n  UV_FS_STAT,\n  UV_FS_LSTAT,\n  UV_FS_FSTAT,\n  UV_FS_FTRUNCATE,\n  UV_FS_UTIME,\n  UV_FS_FUTIME,\n  UV_FS_ACCESS,\n  UV_FS_CHMOD,\n  UV_FS_FCHMOD,\n  UV_FS_FSYNC,\n  UV_FS_FDATASYNC,\n  UV_FS_UNLINK,\n  UV_FS_RMDIR,\n  UV_FS_MKDIR,\n  UV_FS_MKDTEMP,\n  UV_FS_RENAME,\n  UV_FS_SCANDIR,\n  UV_FS_LINK,\n  UV_FS_SYMLINK,\n  UV_FS_READLINK,\n  UV_FS_CHOWN,\n  UV_FS_FCHOWN,\n  UV_FS_REALPATH,\n  UV_FS_COPYFILE,\n  UV_FS_LCHOWN\n} uv_fs_type;\n\n/* uv_fs_t is a subclass of uv_req_t. */\nstruct uv_fs_s {\n  UV_REQ_FIELDS\n  uv_fs_type fs_type;\n  uv_loop_t* loop;\n  uv_fs_cb cb;\n  ssize_t result;\n  void* ptr;\n  const char* path;\n  uv_stat_t statbuf;  /* Stores the result of uv_fs_stat() and uv_fs_fstat(). */\n  UV_FS_PRIVATE_FIELDS\n};\n\nUV_EXTERN uv_fs_type uv_fs_get_type(const uv_fs_t*);\nUV_EXTERN ssize_t uv_fs_get_result(const uv_fs_t*);\nUV_EXTERN void* uv_fs_get_ptr(const uv_fs_t*);\nUV_EXTERN const char* uv_fs_get_path(const uv_fs_t*);\nUV_EXTERN uv_stat_t* uv_fs_get_statbuf(uv_fs_t*);\n\nUV_EXTERN void uv_fs_req_cleanup(uv_fs_t* req);\nUV_EXTERN int uv_fs_close(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          uv_file file,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_open(uv_loop_t* loop,\n                         uv_fs_t* req,\n                         const char* path,\n                         int flags,\n                         int mode,\n                         uv_fs_cb cb);\nUV_EXTERN int uv_fs_read(uv_loop_t* loop,\n                         uv_fs_t* req,\n                         uv_file file,\n                         const uv_buf_t bufs[],\n                         unsigned int nbufs,\n                         int64_t offset,\n                         uv_fs_cb cb);\nUV_EXTERN int uv_fs_unlink(uv_loop_t* loop,\n                           uv_fs_t* req,\n                           const char* path,\n                           uv_fs_cb cb);\nUV_EXTERN int uv_fs_write(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          uv_file file,\n                          const uv_buf_t bufs[],\n                          unsigned int nbufs,\n                          int64_t offset,\n                          uv_fs_cb cb);\n/*\n * This flag can be used with uv_fs_copyfile() to return an error if the\n * destination already exists.\n */\n#define UV_FS_COPYFILE_EXCL   0x0001\n\n/*\n * This flag can be used with uv_fs_copyfile() to attempt to create a reflink.\n * If copy-on-write is not supported, a fallback copy mechanism is used.\n */\n#define UV_FS_COPYFILE_FICLONE 0x0002\n\n/*\n * This flag can be used with uv_fs_copyfile() to attempt to create a reflink.\n * If copy-on-write is not supported, an error is returned.\n */\n#define UV_FS_COPYFILE_FICLONE_FORCE 0x0004\n\nUV_EXTERN int uv_fs_copyfile(uv_loop_t* loop,\n                             uv_fs_t* req,\n                             const char* path,\n                             const char* new_path,\n                             int flags,\n                             uv_fs_cb cb);\nUV_EXTERN int uv_fs_mkdir(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          const char* path,\n                          int mode,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_mkdtemp(uv_loop_t* loop,\n                            uv_fs_t* req,\n                            const char* tpl,\n                            uv_fs_cb cb);\nUV_EXTERN int uv_fs_rmdir(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          const char* path,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_scandir(uv_loop_t* loop,\n                            uv_fs_t* req,\n                            const char* path,\n                            int flags,\n                            uv_fs_cb cb);\nUV_EXTERN int uv_fs_scandir_next(uv_fs_t* req,\n                                 uv_dirent_t* ent);\nUV_EXTERN int uv_fs_stat(uv_loop_t* loop,\n                         uv_fs_t* req,\n                         const char* path,\n                         uv_fs_cb cb);\nUV_EXTERN int uv_fs_fstat(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          uv_file file,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_rename(uv_loop_t* loop,\n                           uv_fs_t* req,\n                           const char* path,\n                           const char* new_path,\n                           uv_fs_cb cb);\nUV_EXTERN int uv_fs_fsync(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          uv_file file,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_fdatasync(uv_loop_t* loop,\n                              uv_fs_t* req,\n                              uv_file file,\n                              uv_fs_cb cb);\nUV_EXTERN int uv_fs_ftruncate(uv_loop_t* loop,\n                              uv_fs_t* req,\n                              uv_file file,\n                              int64_t offset,\n                              uv_fs_cb cb);\nUV_EXTERN int uv_fs_sendfile(uv_loop_t* loop,\n                             uv_fs_t* req,\n                             uv_file out_fd,\n                             uv_file in_fd,\n                             int64_t in_offset,\n                             size_t length,\n                             uv_fs_cb cb);\nUV_EXTERN int uv_fs_access(uv_loop_t* loop,\n                           uv_fs_t* req,\n                           const char* path,\n                           int mode,\n                           uv_fs_cb cb);\nUV_EXTERN int uv_fs_chmod(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          const char* path,\n                          int mode,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_utime(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          const char* path,\n                          double atime,\n                          double mtime,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_futime(uv_loop_t* loop,\n                           uv_fs_t* req,\n                           uv_file file,\n                           double atime,\n                           double mtime,\n                           uv_fs_cb cb);\nUV_EXTERN int uv_fs_lstat(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          const char* path,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_link(uv_loop_t* loop,\n                         uv_fs_t* req,\n                         const char* path,\n                         const char* new_path,\n                         uv_fs_cb cb);\n\n/*\n * This flag can be used with uv_fs_symlink() on Windows to specify whether\n * path argument points to a directory.\n */\n#define UV_FS_SYMLINK_DIR          0x0001\n\n/*\n * This flag can be used with uv_fs_symlink() on Windows to specify whether\n * the symlink is to be created using junction points.\n */\n#define UV_FS_SYMLINK_JUNCTION     0x0002\n\nUV_EXTERN int uv_fs_symlink(uv_loop_t* loop,\n                            uv_fs_t* req,\n                            const char* path,\n                            const char* new_path,\n                            int flags,\n                            uv_fs_cb cb);\nUV_EXTERN int uv_fs_readlink(uv_loop_t* loop,\n                             uv_fs_t* req,\n                             const char* path,\n                             uv_fs_cb cb);\nUV_EXTERN int uv_fs_realpath(uv_loop_t* loop,\n                             uv_fs_t* req,\n                             const char* path,\n                             uv_fs_cb cb);\nUV_EXTERN int uv_fs_fchmod(uv_loop_t* loop,\n                           uv_fs_t* req,\n                           uv_file file,\n                           int mode,\n                           uv_fs_cb cb);\nUV_EXTERN int uv_fs_chown(uv_loop_t* loop,\n                          uv_fs_t* req,\n                          const char* path,\n                          uv_uid_t uid,\n                          uv_gid_t gid,\n                          uv_fs_cb cb);\nUV_EXTERN int uv_fs_fchown(uv_loop_t* loop,\n                           uv_fs_t* req,\n                           uv_file file,\n                           uv_uid_t uid,\n                           uv_gid_t gid,\n                           uv_fs_cb cb);\nUV_EXTERN int uv_fs_lchown(uv_loop_t* loop,\n                           uv_fs_t* req,\n                           const char* path,\n                           uv_uid_t uid,\n                           uv_gid_t gid,\n                           uv_fs_cb cb);\n\n\nenum uv_fs_event {\n  UV_RENAME = 1,\n  UV_CHANGE = 2\n};\n\n\nstruct uv_fs_event_s {\n  UV_HANDLE_FIELDS\n  /* private */\n  char* path;\n  UV_FS_EVENT_PRIVATE_FIELDS\n};\n\n\n/*\n * uv_fs_stat() based polling file watcher.\n */\nstruct uv_fs_poll_s {\n  UV_HANDLE_FIELDS\n  /* Private, don't touch. */\n  void* poll_ctx;\n};\n\nUV_EXTERN int uv_fs_poll_init(uv_loop_t* loop, uv_fs_poll_t* handle);\nUV_EXTERN int uv_fs_poll_start(uv_fs_poll_t* handle,\n                               uv_fs_poll_cb poll_cb,\n                               const char* path,\n                               unsigned int interval);\nUV_EXTERN int uv_fs_poll_stop(uv_fs_poll_t* handle);\nUV_EXTERN int uv_fs_poll_getpath(uv_fs_poll_t* handle,\n                                 char* buffer,\n                                 size_t* size);\n\n\nstruct uv_signal_s {\n  UV_HANDLE_FIELDS\n  uv_signal_cb signal_cb;\n  int signum;\n  UV_SIGNAL_PRIVATE_FIELDS\n};\n\nUV_EXTERN int uv_signal_init(uv_loop_t* loop, uv_signal_t* handle);\nUV_EXTERN int uv_signal_start(uv_signal_t* handle,\n                              uv_signal_cb signal_cb,\n                              int signum);\nUV_EXTERN int uv_signal_start_oneshot(uv_signal_t* handle,\n                                      uv_signal_cb signal_cb,\n                                      int signum);\nUV_EXTERN int uv_signal_stop(uv_signal_t* handle);\n\nUV_EXTERN void uv_loadavg(double avg[3]);\n\n\n/*\n * Flags to be passed to uv_fs_event_start().\n */\nenum uv_fs_event_flags {\n  /*\n   * By default, if the fs event watcher is given a directory name, we will\n   * watch for all events in that directory. This flags overrides this behavior\n   * and makes fs_event report only changes to the directory entry itself. This\n   * flag does not affect individual files watched.\n   * This flag is currently not implemented yet on any backend.\n   */\n  UV_FS_EVENT_WATCH_ENTRY = 1,\n\n  /*\n   * By default uv_fs_event will try to use a kernel interface such as inotify\n   * or kqueue to detect events. This may not work on remote filesystems such\n   * as NFS mounts. This flag makes fs_event fall back to calling stat() on a\n   * regular interval.\n   * This flag is currently not implemented yet on any backend.\n   */\n  UV_FS_EVENT_STAT = 2,\n\n  /*\n   * By default, event watcher, when watching directory, is not registering\n   * (is ignoring) changes in it's subdirectories.\n   * This flag will override this behaviour on platforms that support it.\n   */\n  UV_FS_EVENT_RECURSIVE = 4\n};\n\n\nUV_EXTERN int uv_fs_event_init(uv_loop_t* loop, uv_fs_event_t* handle);\nUV_EXTERN int uv_fs_event_start(uv_fs_event_t* handle,\n                                uv_fs_event_cb cb,\n                                const char* path,\n                                unsigned int flags);\nUV_EXTERN int uv_fs_event_stop(uv_fs_event_t* handle);\nUV_EXTERN int uv_fs_event_getpath(uv_fs_event_t* handle,\n                                  char* buffer,\n                                  size_t* size);\n\nUV_EXTERN int uv_ip4_addr(const char* ip, int port, struct sockaddr_in* addr);\nUV_EXTERN int uv_ip6_addr(const char* ip, int port, struct sockaddr_in6* addr);\n\nUV_EXTERN int uv_ip4_name(const struct sockaddr_in* src, char* dst, size_t size);\nUV_EXTERN int uv_ip6_name(const struct sockaddr_in6* src, char* dst, size_t size);\n\nUV_EXTERN int uv_inet_ntop(int af, const void* src, char* dst, size_t size);\nUV_EXTERN int uv_inet_pton(int af, const char* src, void* dst);\n\n#if defined(IF_NAMESIZE)\n# define UV_IF_NAMESIZE (IF_NAMESIZE + 1)\n#elif defined(IFNAMSIZ)\n# define UV_IF_NAMESIZE (IFNAMSIZ + 1)\n#else\n# define UV_IF_NAMESIZE (16 + 1)\n#endif\n\nUV_EXTERN int uv_if_indextoname(unsigned int ifindex,\n                                char* buffer,\n                                size_t* size);\nUV_EXTERN int uv_if_indextoiid(unsigned int ifindex,\n                               char* buffer,\n                               size_t* size);\n\nUV_EXTERN int uv_exepath(char* buffer, size_t* size);\n\nUV_EXTERN int uv_cwd(char* buffer, size_t* size);\n\nUV_EXTERN int uv_chdir(const char* dir);\n\nUV_EXTERN uint64_t uv_get_free_memory(void);\nUV_EXTERN uint64_t uv_get_total_memory(void);\n\nUV_EXTERN uint64_t uv_hrtime(void);\n\nUV_EXTERN void uv_disable_stdio_inheritance(void);\n\nUV_EXTERN int uv_dlopen(const char* filename, uv_lib_t* lib);\nUV_EXTERN void uv_dlclose(uv_lib_t* lib);\nUV_EXTERN int uv_dlsym(uv_lib_t* lib, const char* name, void** ptr);\nUV_EXTERN const char* uv_dlerror(const uv_lib_t* lib);\n\nUV_EXTERN int uv_mutex_init(uv_mutex_t* handle);\nUV_EXTERN int uv_mutex_init_recursive(uv_mutex_t* handle);\nUV_EXTERN void uv_mutex_destroy(uv_mutex_t* handle);\nUV_EXTERN void uv_mutex_lock(uv_mutex_t* handle);\nUV_EXTERN int uv_mutex_trylock(uv_mutex_t* handle);\nUV_EXTERN void uv_mutex_unlock(uv_mutex_t* handle);\n\nUV_EXTERN int uv_rwlock_init(uv_rwlock_t* rwlock);\nUV_EXTERN void uv_rwlock_destroy(uv_rwlock_t* rwlock);\nUV_EXTERN void uv_rwlock_rdlock(uv_rwlock_t* rwlock);\nUV_EXTERN int uv_rwlock_tryrdlock(uv_rwlock_t* rwlock);\nUV_EXTERN void uv_rwlock_rdunlock(uv_rwlock_t* rwlock);\nUV_EXTERN void uv_rwlock_wrlock(uv_rwlock_t* rwlock);\nUV_EXTERN int uv_rwlock_trywrlock(uv_rwlock_t* rwlock);\nUV_EXTERN void uv_rwlock_wrunlock(uv_rwlock_t* rwlock);\n\nUV_EXTERN int uv_sem_init(uv_sem_t* sem, unsigned int value);\nUV_EXTERN void uv_sem_destroy(uv_sem_t* sem);\nUV_EXTERN void uv_sem_post(uv_sem_t* sem);\nUV_EXTERN void uv_sem_wait(uv_sem_t* sem);\nUV_EXTERN int uv_sem_trywait(uv_sem_t* sem);\n\nUV_EXTERN int uv_cond_init(uv_cond_t* cond);\nUV_EXTERN void uv_cond_destroy(uv_cond_t* cond);\nUV_EXTERN void uv_cond_signal(uv_cond_t* cond);\nUV_EXTERN void uv_cond_broadcast(uv_cond_t* cond);\n\nUV_EXTERN int uv_barrier_init(uv_barrier_t* barrier, unsigned int count);\nUV_EXTERN void uv_barrier_destroy(uv_barrier_t* barrier);\nUV_EXTERN int uv_barrier_wait(uv_barrier_t* barrier);\n\nUV_EXTERN void uv_cond_wait(uv_cond_t* cond, uv_mutex_t* mutex);\nUV_EXTERN int uv_cond_timedwait(uv_cond_t* cond,\n                                uv_mutex_t* mutex,\n                                uint64_t timeout);\n\nUV_EXTERN void uv_once(uv_once_t* guard, void (*callback)(void));\n\nUV_EXTERN int uv_key_create(uv_key_t* key);\nUV_EXTERN void uv_key_delete(uv_key_t* key);\nUV_EXTERN void* uv_key_get(uv_key_t* key);\nUV_EXTERN void uv_key_set(uv_key_t* key, void* value);\n\ntypedef void (*uv_thread_cb)(void* arg);\n\nUV_EXTERN int uv_thread_create(uv_thread_t* tid, uv_thread_cb entry, void* arg);\nUV_EXTERN uv_thread_t uv_thread_self(void);\nUV_EXTERN int uv_thread_join(uv_thread_t *tid);\nUV_EXTERN int uv_thread_equal(const uv_thread_t* t1, const uv_thread_t* t2);\n\n/* The presence of these unions force similar struct layout. */\n#define XX(_, name) uv_ ## name ## _t name;\nunion uv_any_handle {\n  UV_HANDLE_TYPE_MAP(XX)\n};\n\nunion uv_any_req {\n  UV_REQ_TYPE_MAP(XX)\n};\n#undef XX\n\n\nstruct uv_loop_s {\n  /* User data - use this for whatever. */\n  void* data;\n  /* Loop reference counting. */\n  unsigned int active_handles;\n  void* handle_queue[2];\n  union {\n    void* unused[2];\n    unsigned int count;\n  } active_reqs;\n  /* Internal flag to signal loop stop. */\n  unsigned int stop_flag;\n  UV_LOOP_PRIVATE_FIELDS\n};\n\nUV_EXTERN void* uv_loop_get_data(const uv_loop_t*);\nUV_EXTERN void uv_loop_set_data(uv_loop_t*, void* data);\n\n/* Don't export the private CPP symbols. */\n#undef UV_HANDLE_TYPE_PRIVATE\n#undef UV_REQ_TYPE_PRIVATE\n#undef UV_REQ_PRIVATE_FIELDS\n#undef UV_STREAM_PRIVATE_FIELDS\n#undef UV_TCP_PRIVATE_FIELDS\n#undef UV_PREPARE_PRIVATE_FIELDS\n#undef UV_CHECK_PRIVATE_FIELDS\n#undef UV_IDLE_PRIVATE_FIELDS\n#undef UV_ASYNC_PRIVATE_FIELDS\n#undef UV_TIMER_PRIVATE_FIELDS\n#undef UV_GETADDRINFO_PRIVATE_FIELDS\n#undef UV_GETNAMEINFO_PRIVATE_FIELDS\n#undef UV_FS_REQ_PRIVATE_FIELDS\n#undef UV_WORK_PRIVATE_FIELDS\n#undef UV_FS_EVENT_PRIVATE_FIELDS\n#undef UV_SIGNAL_PRIVATE_FIELDS\n#undef UV_LOOP_PRIVATE_FIELDS\n#undef UV_LOOP_PRIVATE_PLATFORM_FIELDS\n#undef UV__ERR\n\n#ifdef __cplusplus\n}\n#endif\n#endif /* UV_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Source/kwsys/DynamicLoader.cxx": "/* Distributed under the OSI-approved BSD 3-Clause License.  See accompanying\n   file Copyright.txt or https://cmake.org/licensing#kwsys for details.  */\n#include \"kwsysPrivate.h\"\n#include KWSYS_HEADER(DynamicLoader.hxx)\n\n#include KWSYS_HEADER(Configure.hxx)\n\n// Work-around CMake dependency scanning limitation.  This must\n// duplicate the above list of headers.\n#if 0\n#  include \"Configure.hxx.in\"\n#  include \"DynamicLoader.hxx.in\"\n#endif\n\n// This file actually contains several different implementations:\n// * NOOP for environments without dynamic libs\n// * HP machines which uses shl_load\n// * Mac OS X 10.2.x and earlier which uses NSLinkModule\n// * Windows which uses LoadLibrary\n// * BeOS / Haiku\n// * FreeMiNT for Atari\n// * Default implementation for *NIX systems (including Mac OS X 10.3 and\n//   later) which use dlopen\n//\n// Each part of the ifdef contains a complete implementation for\n// the static methods of DynamicLoader.\n\n#if !KWSYS_SUPPORTS_SHARED_LIBS\n// Implementation for environments without dynamic libs\n#  include <string.h> // for strerror()\n\nnamespace KWSYS_NAMESPACE {\n\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(\n  const std::string& libname)\n{\n  return 0;\n}\n\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  if (!lib) {\n    return 0;\n  }\n\n  return 1;\n}\n\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const std::string& sym)\n{\n  return 0;\n}\n\nconst char* DynamicLoader::LastError()\n{\n  return \"General error\";\n}\n\n} // namespace KWSYS_NAMESPACE\n\n#elif defined(__hpux)\n// Implementation for HPUX machines\n#  include <dl.h>\n#  include <errno.h>\n\nnamespace KWSYS_NAMESPACE {\n\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(\n  const std::string& libname)\n{\n  return shl_load(libname.c_str(), BIND_DEFERRED | DYNAMIC_PATH, 0L);\n}\n\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  if (!lib) {\n    return 0;\n  }\n  return !shl_unload(lib);\n}\n\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const std::string& sym)\n{\n  void* addr;\n  int status;\n\n  /* TYPE_PROCEDURE Look for a function or procedure. (This used to be default)\n   * TYPE_DATA      Look for a symbol in the data segment (for example,\n   * variables).\n   * TYPE_UNDEFINED Look for any symbol.\n   */\n  status = shl_findsym(&lib, sym.c_str(), TYPE_UNDEFINED, &addr);\n  void* result = (status < 0) ? (void*)0 : addr;\n\n  // Hack to cast pointer-to-data to pointer-to-function.\n  return *reinterpret_cast<DynamicLoader::SymbolPointer*>(&result);\n}\n\nconst char* DynamicLoader::LastError()\n{\n  // TODO: Need implementation with errno/strerror\n  /* If successful, shl_findsym returns an integer (int) value zero. If\n   * shl_findsym cannot find sym, it returns -1 and sets errno to zero.\n   * If any other errors occur, shl_findsym returns -1 and sets errno to one\n   * of these values (defined in <errno.h>):\n   * ENOEXEC\n   * A format error was detected in the specified library.\n   * ENOSYM\n   * A symbol on which sym depends could not be found.\n   * EINVAL\n   * The specified handle is invalid.\n   */\n\n  if (errno == ENOEXEC || errno == ENOSYM || errno == EINVAL) {\n    return strerror(errno);\n  }\n  // else\n  return 0;\n}\n\n} // namespace KWSYS_NAMESPACE\n\n#elif defined(__APPLE__) && (MAC_OS_X_VERSION_MAX_ALLOWED < 1030)\n// Implementation for Mac OS X 10.2.x and earlier\n#  include <mach-o/dyld.h>\n#  include <string.h> // for strlen\n\nnamespace KWSYS_NAMESPACE {\n\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(\n  const std::string& libname)\n{\n  NSObjectFileImageReturnCode rc;\n  NSObjectFileImage image = 0;\n\n  rc = NSCreateObjectFileImageFromFile(libname.c_str(), &image);\n  // rc == NSObjectFileImageInappropriateFile when trying to load a dylib file\n  if (rc != NSObjectFileImageSuccess) {\n    return 0;\n  }\n  NSModule handle = NSLinkModule(image, libname.c_str(),\n                                 NSLINKMODULE_OPTION_BINDNOW |\n                                   NSLINKMODULE_OPTION_RETURN_ON_ERROR);\n  NSDestroyObjectFileImage(image);\n  return handle;\n}\n\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  // NSUNLINKMODULE_OPTION_KEEP_MEMORY_MAPPED\n  // With  this  option  the memory for the module is not deallocated\n  // allowing pointers into the module to still be valid.\n  // You should use this option instead if your code experience some problems\n  // reported against Panther 10.3.9 (fixed in Tiger 10.4.2 and up)\n  bool success = NSUnLinkModule(lib, NSUNLINKMODULE_OPTION_NONE);\n  return success;\n}\n\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const std::string& sym)\n{\n  void* result = 0;\n  // Need to prepend symbols with '_' on Apple-gcc compilers\n  std::string rsym = '_' + sym;\n\n  NSSymbol symbol = NSLookupSymbolInModule(lib, rsym.c_str());\n  if (symbol) {\n    result = NSAddressOfSymbol(symbol);\n  }\n\n  // Hack to cast pointer-to-data to pointer-to-function.\n  return *reinterpret_cast<DynamicLoader::SymbolPointer*>(&result);\n}\n\nconst char* DynamicLoader::LastError()\n{\n  return 0;\n}\n\n} // namespace KWSYS_NAMESPACE\n\n#elif defined(_WIN32) && !defined(__CYGWIN__)\n// Implementation for Windows win32 code but not cygwin\n#  include <windows.h>\n\nnamespace KWSYS_NAMESPACE {\n\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(\n  const std::string& libname)\n{\n  DynamicLoader::LibraryHandle lh;\n  int length = MultiByteToWideChar(CP_UTF8, 0, libname.c_str(), -1, NULL, 0);\n  wchar_t* wchars = new wchar_t[length + 1];\n  wchars[0] = '\\0';\n  MultiByteToWideChar(CP_UTF8, 0, libname.c_str(), -1, wchars, length);\n  lh = LoadLibraryW(wchars);\n  delete[] wchars;\n  return lh;\n}\n\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  return (int)FreeLibrary(lib);\n}\n\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const std::string& sym)\n{\n  // TODO: The calling convention affects the name of the symbol.  We\n  // should have a tool to help get the symbol with the desired\n  // calling convention.  Currently we assume cdecl.\n  //\n  // Borland:\n  //   __cdecl    = \"_func\" (default)\n  //   __fastcall = \"@_func\"\n  //   __stdcall  = \"func\"\n  //\n  // Watcom:\n  //   __cdecl    = \"_func\"\n  //   __fastcall = \"@_func@X\"\n  //   __stdcall  = \"_func@X\"\n  //   __watcall  = \"func_\" (default)\n  //\n  // MSVC:\n  //   __cdecl    = \"func\" (default)\n  //   __fastcall = \"@_func@X\"\n  //   __stdcall  = \"_func@X\"\n  //\n  // Note that the \"@X\" part of the name above is the total size (in\n  // bytes) of the arguments on the stack.\n  void* result;\n#  if defined(__BORLANDC__) || defined(__WATCOMC__)\n  // Need to prepend symbols with '_'\n  std::string ssym = '_' + sym;\n  const char* rsym = ssym.c_str();\n#  else\n  const char* rsym = sym.c_str();\n#  endif\n  result = (void*)GetProcAddress(lib, rsym);\n// Hack to cast pointer-to-data to pointer-to-function.\n#  ifdef __WATCOMC__\n  return *(DynamicLoader::SymbolPointer*)(&result);\n#  else\n  return *reinterpret_cast<DynamicLoader::SymbolPointer*>(&result);\n#  endif\n}\n\nconst char* DynamicLoader::LastError()\n{\n  LPVOID lpMsgBuf = NULL;\n\n  FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM,\n                NULL, GetLastError(),\n                MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT), // Default language\n                (LPTSTR)&lpMsgBuf, 0, NULL);\n\n  if (!lpMsgBuf) {\n    return NULL;\n  }\n\n  static char* str = 0;\n  delete[] str;\n  str = strcpy(new char[strlen((char*)lpMsgBuf) + 1], (char*)lpMsgBuf);\n  // Free the buffer.\n  LocalFree(lpMsgBuf);\n  return str;\n}\n\n} // namespace KWSYS_NAMESPACE\n\n#elif defined(__BEOS__)\n// Implementation for BeOS / Haiku\n#  include <string.h> // for strerror()\n\n#  include <be/kernel/image.h>\n#  include <be/support/Errors.h>\n\nnamespace KWSYS_NAMESPACE {\n\nstatic image_id last_dynamic_err = B_OK;\n\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(\n  const std::string& libname)\n{\n  // image_id's are integers, errors are negative. Add one just in case we\n  //  get a valid image_id of zero (is that even possible?).\n  image_id rc = load_add_on(libname.c_str());\n  if (rc < 0) {\n    last_dynamic_err = rc;\n    return 0;\n  }\n\n  return rc + 1;\n}\n\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  if (!lib) {\n    last_dynamic_err = B_BAD_VALUE;\n    return 0;\n  } else {\n    // The function dlclose() returns 0 on success, and non-zero on error.\n    status_t rc = unload_add_on(lib - 1);\n    if (rc != B_OK) {\n      last_dynamic_err = rc;\n      return 0;\n    }\n  }\n\n  return 1;\n}\n\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const std::string& sym)\n{\n  // Hack to cast pointer-to-data to pointer-to-function.\n  union\n  {\n    void* pvoid;\n    DynamicLoader::SymbolPointer psym;\n  } result;\n\n  result.psym = NULL;\n\n  if (!lib) {\n    last_dynamic_err = B_BAD_VALUE;\n  } else {\n    // !!! FIXME: BeOS can do function-only lookups...does this ever\n    // !!! FIXME:  actually _want_ a data symbol lookup, or was this union\n    // !!! FIXME:  a leftover of dlsym()? (s/ANY/TEXT for functions only).\n    status_t rc =\n      get_image_symbol(lib - 1, sym.c_str(), B_SYMBOL_TYPE_ANY, &result.pvoid);\n    if (rc != B_OK) {\n      last_dynamic_err = rc;\n      result.psym = NULL;\n    }\n  }\n  return result.psym;\n}\n\nconst char* DynamicLoader::LastError()\n{\n  const char* retval = strerror(last_dynamic_err);\n  last_dynamic_err = B_OK;\n  return retval;\n}\n\n} // namespace KWSYS_NAMESPACE\n\n#elif defined(__MINT__)\n// Implementation for FreeMiNT on Atari\n#  define _GNU_SOURCE /* for program_invocation_name */\n#  include <dld.h>\n#  include <errno.h>\n#  include <malloc.h>\n#  include <string.h>\n\nnamespace KWSYS_NAMESPACE {\n\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(\n  const std::string& libname)\n{\n  char* name = (char*)calloc(1, libname.size() + 1);\n  dld_init(program_invocation_name);\n  strncpy(name, libname.c_str(), libname.size());\n  dld_link(libname.c_str());\n  return (void*)name;\n}\n\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  dld_unlink_by_file((char*)lib, 0);\n  free(lib);\n  return 0;\n}\n\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const std::string& sym)\n{\n  // Hack to cast pointer-to-data to pointer-to-function.\n  union\n  {\n    void* pvoid;\n    DynamicLoader::SymbolPointer psym;\n  } result;\n  result.pvoid = dld_get_symbol(sym.c_str());\n  return result.psym;\n}\n\nconst char* DynamicLoader::LastError()\n{\n  return dld_strerror(dld_errno);\n}\n\n} // namespace KWSYS_NAMESPACE\n\n#else\n// Default implementation for *NIX systems (including Mac OS X 10.3 and\n// later) which use dlopen\n#  include <dlfcn.h>\n\nnamespace KWSYS_NAMESPACE {\n\nDynamicLoader::LibraryHandle DynamicLoader::OpenLibrary(\n  const std::string& libname)\n{\n  return dlopen(libname.c_str(), RTLD_LAZY);\n}\n\nint DynamicLoader::CloseLibrary(DynamicLoader::LibraryHandle lib)\n{\n  if (lib) {\n    // The function dlclose() returns 0 on success, and non-zero on error.\n    return !dlclose(lib);\n  }\n  // else\n  return 0;\n}\n\nDynamicLoader::SymbolPointer DynamicLoader::GetSymbolAddress(\n  DynamicLoader::LibraryHandle lib, const std::string& sym)\n{\n  // Hack to cast pointer-to-data to pointer-to-function.\n  union\n  {\n    void* pvoid;\n    DynamicLoader::SymbolPointer psym;\n  } result;\n  result.pvoid = dlsym(lib, sym.c_str());\n  return result.psym;\n}\n\nconst char* DynamicLoader::LastError()\n{\n  return dlerror();\n}\n\n} // namespace KWSYS_NAMESPACE\n#endif\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/CMakeLogo.gif",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Templates/CMakeVSMacros2.vsmacros",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Templates/CMakeVSMacros1.vsmacros",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Templates/Windows/Windows_TemporaryKey.pfx",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Templates/Windows/Logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Templates/Windows/SmallLogo44x44.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Templates/Windows/SplashScreen.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Templates/Windows/ApplicationIcon.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Templates/Windows/SmallLogo.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Templates/Windows/StoreLogo.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/ExternalProjectLocal/Step1NoDir.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/ExternalProjectLocal/Step1.zip",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/ExternalProjectLocal/Step1.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/ExternalProjectLocal/Step1NoDir.zip",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/ExternalProjectLocal/Step1NoDir.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/ExternalProjectLocal/Step1.tar.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/ExternalProject/gitrepo.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/ExternalProject/hgrepo.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/ExternalProject/gitrepo-sub.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/ExternalProject/svnrepo.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/ExternalProject/cvsrepo.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/CFBundleTest/Localized.rsrc",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/CMakeTests/FileDownloadInput.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/CMakeTests/ELF/elf64lsb.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/CMakeTests/ELF/elf32lsb.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/CMakeTests/ELF/elf32msb.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/CMakeTests/ELF/elf64msb.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/MFC/mfc1/res/Toolbar.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/MFC/mfc1/res/mfc1Doc.ico",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/MFC/mfc1/res/mfc1.ico",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/BundleGeneratorTest/CustomVolumeIcon.icns",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/BundleGeneratorTest/BundleIcon.icns",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/StringFileTest/test.utf8",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/RunCMake/FileAPI/check_index.pyc",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/RunCMake/CommandLine/cmake_depends/test_UTF-16LE.h",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/RunCMake/Syntax/BOM-UTF-32-LE.cmake",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/RunCMake/Syntax/BOM-UTF-32-BE.cmake",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/RunCMake/Syntax/BOM-UTF-16-BE.cmake",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/RunCMake/Syntax/BOM-UTF-16-LE.cmake",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/RunCMake/CTestCommandLine/show_only_json_check.pyc",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/RunCMake/configure_file/UTF32LE-BOM.txt.in",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/RunCMake/configure_file/UTF16LE-BOM.txt.in",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/RunCMake/configure_file/UTF16BE-BOM.txt.in",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/RunCMake/configure_file/UTF32BE-BOM.txt.in",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/RunCMake/string/UTF-32BE.txt",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/RunCMake/string/UTF-32LE.txt",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/RunCMake/string/UTF-16BE.txt",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/RunCMake/string/UTF-16LE.txt",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/ExternalProjectUpdate/gitrepo.tgz",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/ObjectLibrary/dummy.obj",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/VSWinStorePhone/Direct3DApp1/SimplePixelShader.cso",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Direct3DApp1_TemporaryKey.pfx",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/VSWinStorePhone/Direct3DApp1/SimpleVertexShader.cso",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/Logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/SmallLogo44x44.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/SplashScreen.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/ApplicationIcon.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/SmallLogo.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/StoreLogo.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/Tiles/FlipCycleTileMedium.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/Tiles/IconicTileSmall.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/Tiles/IconicTileMediumLarge.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/Tiles/FlipCycleTileSmall.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/VSWinStorePhone/Direct3DApp1/Assets/Tiles/FlipCycleTileLarge.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/VSXaml/VSXaml_TemporaryKey.pfx",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/VSXaml/Assets/SmallLogo.scale-100.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/VSXaml/Assets/Logo.scale-100.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/VSXaml/Assets/StoreLogo.scale-100.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Tests/VSXaml/Assets/SplashScreen.scale-100.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Utilities/Sphinx/static/cmake-logo-16.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Utilities/Sphinx/static/cmake-favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Utilities/cmbzip2/sample2.tst",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Utilities/cmbzip2/sample1.tst",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Utilities/cmbzip2/sample3.rb2",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Utilities/cmbzip2/libbz2.lib",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Utilities/cmbzip2/manual.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Utilities/cmbzip2/manual.html",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Utilities/cmbzip2/sample2.ref",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Utilities/cmbzip2/sample1.rb2",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Utilities/cmbzip2/sample1.ref",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Utilities/cmbzip2/sample2.rb2",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Utilities/Release/CMakeLogo.ico",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Utilities/Release/CMakeInstall.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Utilities/Release/WiX/ui_dialog.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Utilities/Release/WiX/ui_banner.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Source/QtDialog/Plus16.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Source/QtDialog/Delete16.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Source/QtDialog/CMakeSetup128.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Source/QtDialog/CMakeSetup32.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Source/QtDialog/CMakeSetup.ico",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Source/QtDialog/CMakeSetup.icns",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Source/QtDialog/CMakeSetup64.png",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Source/CPack/OSXLauncherScript.scpt",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Source/kwsys/testSystemTools.bin",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Packaging/CMakeDMGBackground.tif",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Modules/CPack.OSXScriptLauncher.rsrc.in",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Modules/CPack.DS_Store.in",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Modules/CPack.background.png.in",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Modules/CPack.OSXX11.main.scpt.in",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Modules/CPack.OSXScriptLauncher.in",
        "/tmp/vanessa/spack-stage/spack-stage-cmake-3.14.0-wx57xexgsnnceukb2lkdsnnf7umeoxuc/spack-src/Modules/CPack.VolumeIcon.icns.in"
    ],
    "total_files": 13500
}