{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/include/fmgr.h": "/*-------------------------------------------------------------------------\n *\n * fmgr.h\n *\t  Definitions for the Postgres function manager and function-call\n *\t  interface.\n *\n * This file must be included by all Postgres modules that either define\n * or call fmgr-callable functions.\n *\n *\n * Portions Copyright (c) 1996-2009, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * $PostgreSQL: pgsql/src/include/fmgr.h,v 1.62 2009/01/01 17:23:55 momjian Exp $\n *\n *-------------------------------------------------------------------------\n */\n#ifndef FMGR_H\n#define FMGR_H\n\n/* We don't want to include primnodes.h here, so make a stub reference */\ntypedef struct Node *fmNodePtr;\n\n/* Likewise, avoid including stringinfo.h here */\ntypedef struct StringInfoData *fmStringInfo;\n\n\n/*\n * All functions that can be called directly by fmgr must have this signature.\n * (Other functions can be called by using a handler that does have this\n * signature.)\n */\n\ntypedef struct FunctionCallInfoData *FunctionCallInfo;\n\ntypedef Datum (*PGFunction) (FunctionCallInfo fcinfo);\n\n/*\n * This struct holds the system-catalog information that must be looked up\n * before a function can be called through fmgr.  If the same function is\n * to be called multiple times, the lookup need be done only once and the\n * info struct saved for re-use.\n */\ntypedef struct FmgrInfo\n{\n\tPGFunction\tfn_addr;\t\t/* pointer to function or handler to be called */\n\tOid\t\t\tfn_oid;\t\t\t/* OID of function (NOT of handler, if any) */\n\tshort\t\tfn_nargs;\t\t/* 0..FUNC_MAX_ARGS, or -1 if variable arg\n\t\t\t\t\t\t\t\t * count */\n\tbool\t\tfn_strict;\t\t/* function is \"strict\" (NULL in => NULL out) */\n\tbool\t\tfn_retset;\t\t/* function returns a set */\n\tunsigned char fn_stats;\t\t/* collect stats if track_functions > this */\n\tvoid\t   *fn_extra;\t\t/* extra space for use by handler */\n\tMemoryContext fn_mcxt;\t\t/* memory context to store fn_extra in */\n\tfmNodePtr\tfn_expr;\t\t/* expression parse tree for call, or NULL */\n} FmgrInfo;\n\n/*\n * This struct is the data actually passed to an fmgr-called function.\n */\ntypedef struct FunctionCallInfoData\n{\n\tFmgrInfo   *flinfo;\t\t\t/* ptr to lookup info used for this call */\n\tfmNodePtr\tcontext;\t\t/* pass info about context of call */\n\tfmNodePtr\tresultinfo;\t\t/* pass or return extra info about result */\n\tbool\t\tisnull;\t\t\t/* function must set true if result is NULL */\n\tshort\t\tnargs;\t\t\t/* # arguments actually passed */\n\tDatum\t\targ[FUNC_MAX_ARGS];\t\t/* Arguments passed to function */\n\tbool\t\targnull[FUNC_MAX_ARGS]; /* T if arg[i] is actually NULL */\n} FunctionCallInfoData;\n\n/*\n * This routine fills a FmgrInfo struct, given the OID\n * of the function to be called.\n */\nextern void fmgr_info(Oid functionId, FmgrInfo *finfo);\n\n/*\n * Same, when the FmgrInfo struct is in a memory context longer-lived than\n * CurrentMemoryContext.  The specified context will be set as fn_mcxt\n * and used to hold all subsidiary data of finfo.\n */\nextern void fmgr_info_cxt(Oid functionId, FmgrInfo *finfo,\n\t\t\t  MemoryContext mcxt);\n\n/*\n * Copy an FmgrInfo struct\n */\nextern void fmgr_info_copy(FmgrInfo *dstinfo, FmgrInfo *srcinfo,\n\t\t\t   MemoryContext destcxt);\n\n/*\n * This macro initializes all the fields of a FunctionCallInfoData except\n * for the arg[] and argnull[] arrays.\tPerformance testing has shown that\n * the fastest way to set up argnull[] for small numbers of arguments is to\n * explicitly set each required element to false, so we don't try to zero\n * out the argnull[] array in the macro.\n */\n#define InitFunctionCallInfoData(Fcinfo, Flinfo, Nargs, Context, Resultinfo) \\\n\tdo { \\\n\t\t(Fcinfo).flinfo = (Flinfo); \\\n\t\t(Fcinfo).context = (Context); \\\n\t\t(Fcinfo).resultinfo = (Resultinfo); \\\n\t\t(Fcinfo).isnull = false; \\\n\t\t(Fcinfo).nargs = (Nargs); \\\n\t} while (0)\n\n/*\n * This macro invokes a function given a filled-in FunctionCallInfoData\n * struct.\tThe macro result is the returned Datum --- but note that\n * caller must still check fcinfo->isnull!\tAlso, if function is strict,\n * it is caller's responsibility to verify that no null arguments are present\n * before calling.\n */\n#define FunctionCallInvoke(fcinfo)\t((* (fcinfo)->flinfo->fn_addr) (fcinfo))\n\n\n/*-------------------------------------------------------------------------\n *\t\tSupport macros to ease writing fmgr-compatible functions\n *\n * A C-coded fmgr-compatible function should be declared as\n *\n *\t\tDatum\n *\t\tfunction_name(PG_FUNCTION_ARGS)\n *\t\t{\n *\t\t\t...\n *\t\t}\n *\n * It should access its arguments using appropriate PG_GETARG_xxx macros\n * and should return its result using PG_RETURN_xxx.\n *\n *-------------------------------------------------------------------------\n */\n\n/* Standard parameter list for fmgr-compatible functions */\n#define PG_FUNCTION_ARGS\tFunctionCallInfo fcinfo\n\n/*\n * Get number of arguments passed to function.\n */\n#define PG_NARGS() (fcinfo->nargs)\n\n/*\n * If function is not marked \"proisstrict\" in pg_proc, it must check for\n * null arguments using this macro.  Do not try to GETARG a null argument!\n */\n#define PG_ARGISNULL(n)  (fcinfo->argnull[n])\n\n/*\n * Support for fetching detoasted copies of toastable datatypes (all of\n * which are varlena types).  pg_detoast_datum() gives you either the input\n * datum (if not toasted) or a detoasted copy allocated with palloc().\n * pg_detoast_datum_copy() always gives you a palloc'd copy --- use it\n * if you need a modifiable copy of the input.\tCaller is expected to have\n * checked for null inputs first, if necessary.\n *\n * pg_detoast_datum_packed() will return packed (1-byte header) datums\n * unmodified.\tIt will still expand an externally toasted or compressed datum.\n * The resulting datum can be accessed using VARSIZE_ANY() and VARDATA_ANY()\n * (beware of multiple evaluations in those macros!)\n *\n * WARNING: It is only safe to use pg_detoast_datum_packed() and\n * VARDATA_ANY() if you really don't care about the alignment. Either because\n * you're working with something like text where the alignment doesn't matter\n * or because you're not going to access its constituent parts and just use\n * things like memcpy on it anyways.\n *\n * Note: it'd be nice if these could be macros, but I see no way to do that\n * without evaluating the arguments multiple times, which is NOT acceptable.\n */\nextern struct varlena *pg_detoast_datum(struct varlena * datum);\nextern struct varlena *pg_detoast_datum_copy(struct varlena * datum);\nextern struct varlena *pg_detoast_datum_slice(struct varlena * datum,\n\t\t\t\t\t   int32 first, int32 count);\nextern struct varlena *pg_detoast_datum_packed(struct varlena * datum);\n\n#define PG_DETOAST_DATUM(datum) \\\n\tpg_detoast_datum((struct varlena *) DatumGetPointer(datum))\n#define PG_DETOAST_DATUM_COPY(datum) \\\n\tpg_detoast_datum_copy((struct varlena *) DatumGetPointer(datum))\n#define PG_DETOAST_DATUM_SLICE(datum,f,c) \\\n\t\tpg_detoast_datum_slice((struct varlena *) DatumGetPointer(datum), \\\n\t\t(int32) (f), (int32) (c))\n/* WARNING -- unaligned pointer */\n#define PG_DETOAST_DATUM_PACKED(datum) \\\n\tpg_detoast_datum_packed((struct varlena *) DatumGetPointer(datum))\n\n/*\n * Support for cleaning up detoasted copies of inputs.\tThis must only\n * be used for pass-by-ref datatypes, and normally would only be used\n * for toastable types.  If the given pointer is different from the\n * original argument, assume it's a palloc'd detoasted copy, and pfree it.\n * NOTE: most functions on toastable types do not have to worry about this,\n * but we currently require that support functions for indexes not leak\n * memory.\n */\n#define PG_FREE_IF_COPY(ptr,n) \\\n\tdo { \\\n\t\tif ((Pointer) (ptr) != PG_GETARG_POINTER(n)) \\\n\t\t\tpfree(ptr); \\\n\t} while (0)\n\n/* Macros for fetching arguments of standard types */\n\n#define PG_GETARG_DATUM(n)\t (fcinfo->arg[n])\n#define PG_GETARG_INT32(n)\t DatumGetInt32(PG_GETARG_DATUM(n))\n#define PG_GETARG_UINT32(n)  DatumGetUInt32(PG_GETARG_DATUM(n))\n#define PG_GETARG_INT16(n)\t DatumGetInt16(PG_GETARG_DATUM(n))\n#define PG_GETARG_UINT16(n)  DatumGetUInt16(PG_GETARG_DATUM(n))\n#define PG_GETARG_CHAR(n)\t DatumGetChar(PG_GETARG_DATUM(n))\n#define PG_GETARG_BOOL(n)\t DatumGetBool(PG_GETARG_DATUM(n))\n#define PG_GETARG_OID(n)\t DatumGetObjectId(PG_GETARG_DATUM(n))\n#define PG_GETARG_POINTER(n) DatumGetPointer(PG_GETARG_DATUM(n))\n#define PG_GETARG_CSTRING(n) DatumGetCString(PG_GETARG_DATUM(n))\n#define PG_GETARG_NAME(n)\t DatumGetName(PG_GETARG_DATUM(n))\n/* these macros hide the pass-by-reference-ness of the datatype: */\n#define PG_GETARG_FLOAT4(n)  DatumGetFloat4(PG_GETARG_DATUM(n))\n#define PG_GETARG_FLOAT8(n)  DatumGetFloat8(PG_GETARG_DATUM(n))\n#define PG_GETARG_INT64(n)\t DatumGetInt64(PG_GETARG_DATUM(n))\n/* use this if you want the raw, possibly-toasted input datum: */\n#define PG_GETARG_RAW_VARLENA_P(n)\t((struct varlena *) PG_GETARG_POINTER(n))\n/* use this if you want the input datum de-toasted: */\n#define PG_GETARG_VARLENA_P(n) PG_DETOAST_DATUM(PG_GETARG_DATUM(n))\n/* and this if you can handle 1-byte-header datums: */\n#define PG_GETARG_VARLENA_PP(n) PG_DETOAST_DATUM_PACKED(PG_GETARG_DATUM(n))\n/* DatumGetFoo macros for varlena types will typically look like this: */\n#define PG_GETARG_TID(n)\t (*((ItemPointer) DatumGetPointer(PG_GETARG_DATUM(n))))\n#define DatumGetByteaP(X)\t\t\t((bytea *) PG_DETOAST_DATUM(X))\n#define DatumGetByteaPP(X)\t\t\t((bytea *) PG_DETOAST_DATUM_PACKED(X))\n#define DatumGetTextP(X)\t\t\t((text *) PG_DETOAST_DATUM(X))\n#define DatumGetTextPP(X)\t\t\t((text *) PG_DETOAST_DATUM_PACKED(X))\n#define DatumGetBpCharP(X)\t\t\t((BpChar *) PG_DETOAST_DATUM(X))\n#define DatumGetBpCharPP(X)\t\t\t((BpChar *) PG_DETOAST_DATUM_PACKED(X))\n#define DatumGetVarCharP(X)\t\t\t((VarChar *) PG_DETOAST_DATUM(X))\n#define DatumGetVarCharPP(X)\t\t((VarChar *) PG_DETOAST_DATUM_PACKED(X))\n#define DatumGetHeapTupleHeader(X)\t((HeapTupleHeader) PG_DETOAST_DATUM(X))\n/* And we also offer variants that return an OK-to-write copy */\n#define DatumGetByteaPCopy(X)\t\t((bytea *) PG_DETOAST_DATUM_COPY(X))\n#define DatumGetTextPCopy(X)\t\t((text *) PG_DETOAST_DATUM_COPY(X))\n#define DatumGetBpCharPCopy(X)\t\t((BpChar *) PG_DETOAST_DATUM_COPY(X))\n#define DatumGetVarCharPCopy(X)\t\t((VarChar *) PG_DETOAST_DATUM_COPY(X))\n#define DatumGetHeapTupleHeaderCopy(X)\t((HeapTupleHeader) PG_DETOAST_DATUM_COPY(X))\n/* Variants which return n bytes starting at pos. m */\n#define DatumGetByteaPSlice(X,m,n)\t((bytea *) PG_DETOAST_DATUM_SLICE(X,m,n))\n#define DatumGetTextPSlice(X,m,n)\t((text *) PG_DETOAST_DATUM_SLICE(X,m,n))\n#define DatumGetBpCharPSlice(X,m,n) ((BpChar *) PG_DETOAST_DATUM_SLICE(X,m,n))\n#define DatumGetVarCharPSlice(X,m,n) ((VarChar *) PG_DETOAST_DATUM_SLICE(X,m,n))\n\n/* GETARG macros for varlena types will typically look like this: */\n#define PG_GETARG_BYTEA_P(n)\t\tDatumGetByteaP(PG_GETARG_DATUM(n))\n#define PG_GETARG_BYTEA_PP(n)\t\tDatumGetByteaPP(PG_GETARG_DATUM(n))\n#define PG_GETARG_TEXT_P(n)\t\t\tDatumGetTextP(PG_GETARG_DATUM(n))\n#define PG_GETARG_TEXT_PP(n)\t\tDatumGetTextPP(PG_GETARG_DATUM(n))\n#define PG_GETARG_BPCHAR_P(n)\t\tDatumGetBpCharP(PG_GETARG_DATUM(n))\n#define PG_GETARG_BPCHAR_PP(n)\t\tDatumGetBpCharPP(PG_GETARG_DATUM(n))\n#define PG_GETARG_VARCHAR_P(n)\t\tDatumGetVarCharP(PG_GETARG_DATUM(n))\n#define PG_GETARG_VARCHAR_PP(n)\t\tDatumGetVarCharPP(PG_GETARG_DATUM(n))\n#define PG_GETARG_HEAPTUPLEHEADER(n)\tDatumGetHeapTupleHeader(PG_GETARG_DATUM(n))\n/* And we also offer variants that return an OK-to-write copy */\n#define PG_GETARG_BYTEA_P_COPY(n)\tDatumGetByteaPCopy(PG_GETARG_DATUM(n))\n#define PG_GETARG_TEXT_P_COPY(n)\tDatumGetTextPCopy(PG_GETARG_DATUM(n))\n#define PG_GETARG_BPCHAR_P_COPY(n)\tDatumGetBpCharPCopy(PG_GETARG_DATUM(n))\n#define PG_GETARG_VARCHAR_P_COPY(n) DatumGetVarCharPCopy(PG_GETARG_DATUM(n))\n#define PG_GETARG_HEAPTUPLEHEADER_COPY(n)\tDatumGetHeapTupleHeaderCopy(PG_GETARG_DATUM(n))\n\n/* And a b-byte slice from position a -also OK to write */\n#define PG_GETARG_BYTEA_P_SLICE(n,a,b) DatumGetByteaPSlice(PG_GETARG_DATUM(n),a,b)\n#define PG_GETARG_TEXT_P_SLICE(n,a,b)  DatumGetTextPSlice(PG_GETARG_DATUM(n),a,b)\n#define PG_GETARG_BPCHAR_P_SLICE(n,a,b) DatumGetBpCharPSlice(PG_GETARG_DATUM(n),a,b)\n#define PG_GETARG_VARCHAR_P_SLICE(n,a,b) DatumGetVarCharPSlice(PG_GETARG_DATUM(n),a,b)\n\n/* To return a NULL do this: */\n#define PG_RETURN_NULL()  \\\n\tdo { fcinfo->isnull = true; return (Datum) 0; } while (0)\n\n/* A few internal functions return void (which is not the same as NULL!) */\n#define PG_RETURN_VOID()\t return (Datum) 0\n\n/* Macros for returning results of standard types */\n\n#define PG_RETURN_DATUM(x)\t return (x)\n#define PG_RETURN_INT32(x)\t return Int32GetDatum(x)\n#define PG_RETURN_UINT32(x)  return UInt32GetDatum(x)\n#define PG_RETURN_INT16(x)\t return Int16GetDatum(x)\n#define PG_RETURN_CHAR(x)\t return CharGetDatum(x)\n#define PG_RETURN_BOOL(x)\t return BoolGetDatum(x)\n#define PG_RETURN_OID(x)\t return ObjectIdGetDatum(x)\n#define PG_RETURN_POINTER(x) return PointerGetDatum(x)\n#define PG_RETURN_CSTRING(x) return CStringGetDatum(x)\n#define PG_RETURN_NAME(x)\t return NameGetDatum(x)\n/* these macros hide the pass-by-reference-ness of the datatype: */\n#define PG_RETURN_FLOAT4(x)  return Float4GetDatum(x)\n#define PG_RETURN_FLOAT8(x)  return Float8GetDatum(x)\n#define PG_RETURN_INT64(x)\t return Int64GetDatum(x)\n/* RETURN macros for other pass-by-ref types will typically look like this: */\n#define PG_RETURN_BYTEA_P(x)   PG_RETURN_POINTER(x)\n#define PG_RETURN_TEXT_P(x)    PG_RETURN_POINTER(x)\n#define PG_RETURN_BPCHAR_P(x)  PG_RETURN_POINTER(x)\n#define PG_RETURN_VARCHAR_P(x) PG_RETURN_POINTER(x)\n#define PG_RETURN_HEAPTUPLEHEADER(x)  PG_RETURN_POINTER(x)\n#define PG_RETURN_XID(x)\t return TransactionIdGetDatum(x)\n\n\n/*-------------------------------------------------------------------------\n *\t\tSupport for detecting call convention of dynamically-loaded functions\n *\n * Dynamically loaded functions may use either the version-1 (\"new style\")\n * or version-0 (\"old style\") calling convention.  Version 1 is the call\n * convention defined in this header file; version 0 is the old \"plain C\"\n * convention.\tA version-1 function must be accompanied by the macro call\n *\n *\t\tPG_FUNCTION_INFO_V1(function_name);\n *\n * Note that internal functions do not need this decoration since they are\n * assumed to be version-1.\n *\n *-------------------------------------------------------------------------\n */\n\ntypedef struct\n{\n\tint\t\t\tapi_version;\t/* specifies call convention version number */\n\t/* More fields may be added later, for version numbers > 1. */\n} Pg_finfo_record;\n\n/* Expected signature of an info function */\ntypedef const Pg_finfo_record *(*PGFInfoFunction) (void);\n\n/*\n *\tMacro to build an info function associated with the given function name.\n *\tWin32 loadable functions usually link with 'dlltool --export-all', but it\n *\tdoesn't hurt to add PGDLLIMPORT in case they don't.\n */\n#define PG_FUNCTION_INFO_V1(funcname) \\\nextern PGDLLIMPORT const Pg_finfo_record * CppConcat(pg_finfo_,funcname)(void); \\\nconst Pg_finfo_record * \\\nCppConcat(pg_finfo_,funcname) (void) \\\n{ \\\n\tstatic const Pg_finfo_record my_finfo = { 1 }; \\\n\treturn &my_finfo; \\\n} \\\nextern int no_such_variable\n\n\n/*-------------------------------------------------------------------------\n *\t\tSupport for verifying backend compatibility of loaded modules\n *\n * We require dynamically-loaded modules to include the macro call\n *\t\tPG_MODULE_MAGIC;\n * so that we can check for obvious incompatibility, such as being compiled\n * for a different major PostgreSQL version.\n *\n * To compile with versions of PostgreSQL that do not support this,\n * you may put an #ifdef/#endif test around it.  Note that in a multiple-\n * source-file module, the macro call should only appear once.\n *\n * The specific items included in the magic block are intended to be ones that\n * are custom-configurable and especially likely to break dynamically loaded\n * modules if they were compiled with other values.  Also, the length field\n * can be used to detect definition changes.\n *\n * Note: we compare magic blocks with memcmp(), so there had better not be\n * any alignment pad bytes in them.\n *\n * Note: when changing the contents of magic blocks, be sure to adjust the\n * incompatible_module_error() function in dfmgr.c.\n *-------------------------------------------------------------------------\n */\n\n/* Definition of the magic block structure */\ntypedef struct\n{\n\tint\t\t\tlen;\t\t\t/* sizeof(this struct) */\n\tint\t\t\tversion;\t\t/* product major version */\n\tint\t\t\tfuncmaxargs;\t/* FUNC_MAX_ARGS */\n\tint\t\t\tindexmaxkeys;\t/* INDEX_MAX_KEYS */\n\tint\t\t\tnamedatalen;\t/* NAMEDATALEN */\n\tint\t\t\tfloat4byval;\t/* FLOAT4PASSBYVAL */\n\tint\t\t\tfloat8byval;\t/* FLOAT8PASSBYVAL */\n\tint         product;        /* magic product code */\n\tint         headerversion;/* header version number to force recompilation of libraries */\n} Pg_magic_struct;\n\n/*\n * List of product codes for products that support some level of compatability\n * with the postgres contrib module format. \n *\n * GPDB: A patch for this has been supplied to Postgres in the hope of improved\n * cross product compatibility.  It is currently unknown if they will accept\n * the patch.\n */\ntypedef enum {\n\tPgMagicProductNone\t\t   = 0,\n\tPgMagicProductPostgres\t   = 1,\n\tPgMagicProductGreenplum\t   = 2180,     /* 'GPDB' cast to an integer */\n} Pg_magic_product_code;\n\n/* The header version to force recompilation of third party libraries */\n#define GP_HEADER_VERSION_NUM 1\n\n/* The actual data block contents */\n#define PG_MODULE_MAGIC_DATA \\\n{ \\\n\tsizeof(Pg_magic_struct), \\\n\tGP_VERSION_NUM / 100, \\\n\tFUNC_MAX_ARGS, \\\n\tINDEX_MAX_KEYS, \\\n\tNAMEDATALEN, \\\n\tFLOAT4PASSBYVAL, \\\n\tFLOAT8PASSBYVAL, \\\n\tPgMagicProductGreenplum, \\\n\tGP_HEADER_VERSION_NUM, \\\n}\n\n#ifndef FLOAT4PASSBYVAL\n#define FLOAT4PASSBYVAL 1\n#endif\n#ifndef FLOAT8PASSBYVAL\n#define FLOAT8PASSBYVAL 1\n#endif\n/*\n * Declare the module magic function.  It needs to be a function as the dlsym\n * in the backend is only guaranteed to work on functions, not data\n */\ntypedef const Pg_magic_struct *(*PGModuleMagicFunction) (void);\n\n#define PG_MAGIC_FUNCTION_NAME Pg_magic_func\n#define PG_MAGIC_FUNCTION_NAME_STRING \"Pg_magic_func\"\n\n#define PG_MODULE_MAGIC \\\nextern PGDLLIMPORT const Pg_magic_struct *PG_MAGIC_FUNCTION_NAME(void); \\\nconst Pg_magic_struct * \\\nPG_MAGIC_FUNCTION_NAME(void) \\\n{ \\\n\tstatic const Pg_magic_struct Pg_magic_data = PG_MODULE_MAGIC_DATA; \\\n\treturn &Pg_magic_data; \\\n} \\\nextern int no_such_variable\n\n\n/*-------------------------------------------------------------------------\n *\t\tSupport routines and macros for callers of fmgr-compatible functions\n *-------------------------------------------------------------------------\n */\n\n/* These are for invocation of a specifically named function with a\n * directly-computed parameter list.  Note that neither arguments nor result\n * are allowed to be NULL.\n */\nextern Datum DirectFunctionCall1(PGFunction func, Datum arg1);\nextern Datum DirectFunctionCall2(PGFunction func, Datum arg1, Datum arg2);\nextern Datum DirectFunctionCall3(PGFunction func, Datum arg1, Datum arg2,\n\t\t\t\t\tDatum arg3);\nextern Datum DirectFunctionCall4(PGFunction func, Datum arg1, Datum arg2,\n\t\t\t\t\tDatum arg3, Datum arg4);\nextern Datum DirectFunctionCall5(PGFunction func, Datum arg1, Datum arg2,\n\t\t\t\t\tDatum arg3, Datum arg4, Datum arg5);\nextern Datum DirectFunctionCall6(PGFunction func, Datum arg1, Datum arg2,\n\t\t\t\t\tDatum arg3, Datum arg4, Datum arg5,\n\t\t\t\t\tDatum arg6);\nextern Datum DirectFunctionCall7(PGFunction func, Datum arg1, Datum arg2,\n\t\t\t\t\tDatum arg3, Datum arg4, Datum arg5,\n\t\t\t\t\tDatum arg6, Datum arg7);\nextern Datum DirectFunctionCall8(PGFunction func, Datum arg1, Datum arg2,\n\t\t\t\t\tDatum arg3, Datum arg4, Datum arg5,\n\t\t\t\t\tDatum arg6, Datum arg7, Datum arg8);\nextern Datum DirectFunctionCall9(PGFunction func, Datum arg1, Datum arg2,\n\t\t\t\t\tDatum arg3, Datum arg4, Datum arg5,\n\t\t\t\t\tDatum arg6, Datum arg7, Datum arg8,\n\t\t\t\t\tDatum arg9);\n\n/* These are for invocation of a previously-looked-up function with a\n * directly-computed parameter list.  Note that neither arguments nor result\n * are allowed to be NULL.\n */\nextern Datum FunctionCall1(FmgrInfo *flinfo, Datum arg1);\nextern Datum FunctionCall2(FmgrInfo *flinfo, Datum arg1, Datum arg2);\nextern Datum FunctionCall3(FmgrInfo *flinfo, Datum arg1, Datum arg2,\n\t\t\t  Datum arg3);\nextern Datum FunctionCall4(FmgrInfo *flinfo, Datum arg1, Datum arg2,\n\t\t\t  Datum arg3, Datum arg4);\nextern Datum FunctionCall5(FmgrInfo *flinfo, Datum arg1, Datum arg2,\n\t\t\t  Datum arg3, Datum arg4, Datum arg5);\nextern Datum FunctionCall6(FmgrInfo *flinfo, Datum arg1, Datum arg2,\n\t\t\t  Datum arg3, Datum arg4, Datum arg5,\n\t\t\t  Datum arg6);\nextern Datum FunctionCall7(FmgrInfo *flinfo, Datum arg1, Datum arg2,\n\t\t\t  Datum arg3, Datum arg4, Datum arg5,\n\t\t\t  Datum arg6, Datum arg7);\nextern Datum FunctionCall8(FmgrInfo *flinfo, Datum arg1, Datum arg2,\n\t\t\t  Datum arg3, Datum arg4, Datum arg5,\n\t\t\t  Datum arg6, Datum arg7, Datum arg8);\nextern Datum FunctionCall9(FmgrInfo *flinfo, Datum arg1, Datum arg2,\n\t\t\t  Datum arg3, Datum arg4, Datum arg5,\n\t\t\t  Datum arg6, Datum arg7, Datum arg8,\n\t\t\t  Datum arg9);\n\n/* These are for invocation of a function identified by OID with a\n * directly-computed parameter list.  Note that neither arguments nor result\n * are allowed to be NULL.\tThese are essentially FunctionLookup() followed\n * by FunctionCallN().\tIf the same function is to be invoked repeatedly,\n * do the FunctionLookup() once and then use FunctionCallN().\n */\nextern Datum OidFunctionCall1(Oid functionId, Datum arg1);\nextern Datum OidFunctionCall2(Oid functionId, Datum arg1, Datum arg2);\nextern Datum OidFunctionCall3(Oid functionId, Datum arg1, Datum arg2,\n\t\t\t\t Datum arg3);\nextern Datum OidFunctionCall4(Oid functionId, Datum arg1, Datum arg2,\n\t\t\t\t Datum arg3, Datum arg4);\nextern Datum OidFunctionCall5(Oid functionId, Datum arg1, Datum arg2,\n\t\t\t\t Datum arg3, Datum arg4, Datum arg5);\nextern Datum OidFunctionCall6(Oid functionId, Datum arg1, Datum arg2,\n\t\t\t\t Datum arg3, Datum arg4, Datum arg5,\n\t\t\t\t Datum arg6);\nextern Datum OidFunctionCall7(Oid functionId, Datum arg1, Datum arg2,\n\t\t\t\t Datum arg3, Datum arg4, Datum arg5,\n\t\t\t\t Datum arg6, Datum arg7);\nextern Datum OidFunctionCall8(Oid functionId, Datum arg1, Datum arg2,\n\t\t\t\t Datum arg3, Datum arg4, Datum arg5,\n\t\t\t\t Datum arg6, Datum arg7, Datum arg8);\nextern Datum OidFunctionCall9(Oid functionId, Datum arg1, Datum arg2,\n\t\t\t\t Datum arg3, Datum arg4, Datum arg5,\n\t\t\t\t Datum arg6, Datum arg7, Datum arg8,\n\t\t\t\t Datum arg9);\n\n/* Special cases for convenient invocation of datatype I/O functions. */\nextern Datum InputFunctionCall(FmgrInfo *flinfo, char *str,\n\t\t\t\t  Oid typioparam, int32 typmod);\nextern Datum OidInputFunctionCall(Oid functionId, char *str,\n\t\t\t\t\t Oid typioparam, int32 typmod);\nextern char *OutputFunctionCall(FmgrInfo *flinfo, Datum val);\nextern char *OidOutputFunctionCall(Oid functionId, Datum val);\nextern Datum ReceiveFunctionCall(FmgrInfo *flinfo, fmStringInfo buf,\n\t\t\t\t\tOid typioparam, int32 typmod);\nextern Datum OidReceiveFunctionCall(Oid functionId, fmStringInfo buf,\n\t\t\t\t\t   Oid typioparam, int32 typmod);\nextern bytea *SendFunctionCall(FmgrInfo *flinfo, Datum val);\nextern bytea *OidSendFunctionCall(Oid functionId, Datum val);\n\n\n/*\n * Routines in fmgr.c\n */\nextern const Pg_finfo_record *fetch_finfo_record(void *filehandle, char *funcname);\nextern void clear_external_function_hash(void *filehandle);\nextern Oid\tfmgr_internal_function(const char *proname);\nextern Oid\tget_fn_expr_rettype(FmgrInfo *flinfo);\nextern Oid\tget_fn_expr_argtype(FmgrInfo *flinfo, int argnum);\nextern Oid\tget_call_expr_argtype(fmNodePtr expr, int argnum);\nextern bool CheckFunctionValidatorAccess(Oid validatorOid, Oid functionOid);\n\n/*\n * Routines in dfmgr.c\n */\nextern char *Dynamic_library_path;\n\nextern PGFunction load_external_function(char *filename, char *funcname,\n\t\t\t\t\t   bool signalNotFound, void **filehandle);\nextern PGFunction lookup_external_function(void *filehandle, char *funcname);\nextern void load_file(const char *filename, bool restricted);\nextern void **find_rendezvous_variable(const char *varName);\n\n/*\n * Support for aggregate functions\n *\n * This is actually in executor/nodeAgg.c, but we declare it here since the\n * whole point is for callers of it to not be overly friendly with nodeAgg.\n */\n\n/* AggCheckCallContext can return one of the following codes, or 0: */\n#define AGG_CONTEXT_AGGREGATE   1       /* regular aggregate */\n#define AGG_CONTEXT_WINDOW      2       /* window function */\n\nextern int AggCheckCallContext(FunctionCallInfo fcinfo,\n                    MemoryContext *aggcontext);\n\n#endif   /* FMGR_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/include/utils/dynamic_loader.h": "/*-------------------------------------------------------------------------\n *\n * dynamic_loader.h\n *\n *\n *\n * Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * $PostgreSQL: pgsql/src/include/utils/dynamic_loader.h,v 1.28 2008/01/01 19:45:59 momjian Exp $\n *\n *-------------------------------------------------------------------------\n */\n#ifndef DYNAMIC_LOADER_H\n#define DYNAMIC_LOADER_H\n\n#include \"fmgr.h\"\n\n\nextern void *pg_dlopen(char *filename);\nextern PGFunction pg_dlsym(void *handle, char *funcname);\nextern void pg_dlclose(void *handle);\nextern char *pg_dlerror(void);\n\n#endif   /* DYNAMIC_LOADER_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/backend/port/dynloader/win32.h": "/*\n * $PostgreSQL: pgsql/src/backend/port/dynloader/win32.h,v 1.5 2009/06/11 14:49:00 momjian Exp $\n */\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include \"utils/dynamic_loader.h\"\n\n#define pg_dlopen(f)\tdlopen((f), 1)\n#define pg_dlsym\t\tdlsym\n#define pg_dlclose\t\tdlclose\n#define pg_dlerror\t\tdlerror\n\nchar\t   *dlerror(void);\nint\t\t\tdlclose(void *handle);\nvoid\t   *dlsym(void *handle, const char *symbol);\nvoid\t   *dlopen(const char *path, int mode);\n\n#endif   /* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/backend/port/dynloader/dgux.h": "/*-------------------------------------------------------------------------\n *\n * dgux.h\n *\n * Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * $PostgreSQL: pgsql/src/backend/port/dynloader/dgux.h,v 1.22 2008/01/01 19:45:51 momjian Exp $\n *\n *-------------------------------------------------------------------------\n */\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include <dlfcn.h>\n#include \"utils/dynamic_loader.h\"\n\n/*\n * Dynamic Loader on DG/UX.\n *\n * this dynamic loader uses the system dynamic loading interface for shared\n * libraries (ie. dlopen/dlsym/dlclose). The user must specify a shared\n * library as the file to be dynamically loaded.\n */\n\n/*\n * In some older systems, the RTLD_NOW flag isn't defined and the mode\n * argument to dlopen must always be 1.  The RTLD_GLOBAL flag is wanted\n * if available, but it doesn't exist everywhere.\n * If it doesn't exist, set it to 0 so it has no effect.\n */\n#ifndef RTLD_NOW\n#define RTLD_NOW 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n#define pg_dlopen(f)\tdlopen((f), RTLD_NOW | RTLD_GLOBAL)\n#define pg_dlsym\t\tdlsym\n#define pg_dlclose\t\tdlclose\n#define pg_dlerror\t\tdlerror\n\n#endif   /* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/backend/port/dynloader/sunos4.h": "/*-------------------------------------------------------------------------\n *\n * sunos4.h\n *\t  port-specific prototypes for SunOS 4\n *\n *\n * Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * $PostgreSQL: pgsql/src/backend/port/dynloader/sunos4.h,v 1.21 2008/01/01 19:45:51 momjian Exp $\n *\n *-------------------------------------------------------------------------\n */\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include <dlfcn.h>\n#include \"utils/dynamic_loader.h\"\n\n/*\n * Dynamic Loader on SunOS 4.\n *\n * this dynamic loader uses the system dynamic loading interface for shared\n * libraries (ie. dlopen/dlsym/dlclose). The user must specify a shared\n * library as the file to be dynamically loaded.\n */\n\n/*\n * In some older systems, the RTLD_NOW flag isn't defined and the mode\n * argument to dlopen must always be 1.  The RTLD_GLOBAL flag is wanted\n * if available, but it doesn't exist everywhere.\n * If it doesn't exist, set it to 0 so it has no effect.\n */\n#ifndef RTLD_NOW\n#define RTLD_NOW 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n#define pg_dlopen(f)\tdlopen((f), RTLD_NOW | RTLD_GLOBAL)\n#define pg_dlsym\t\tdlsym\n#define pg_dlclose\t\tdlclose\n#define pg_dlerror\t\tdlerror\n\n#endif   /* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/backend/port/dynloader/cygwin.h": "/*-------------------------------------------------------------------------\n *\n * Dynamic loader declarations for Cygwin\n *\n * Portions Copyright (c) 1996-2009, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * $PostgreSQL: pgsql/src/backend/port/dynloader/cygwin.h,v 1.9 2009/01/01 17:23:46 momjian Exp $\n *\n *-------------------------------------------------------------------------\n  */\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include <dlfcn.h>\n#include \"utils/dynamic_loader.h\"\n\n/*\n * In some older systems, the RTLD_NOW flag isn't defined and the mode\n * argument to dlopen must always be 1.  The RTLD_GLOBAL flag is wanted\n * if available, but it doesn't exist everywhere.\n * If it doesn't exist, set it to 0 so it has no effect.\n */\n#ifndef RTLD_NOW\n#define RTLD_NOW 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n#define pg_dlopen(f)\tdlopen((f), RTLD_NOW | RTLD_GLOBAL)\n#define pg_dlsym\t\tdlsym\n#define pg_dlclose\t\tdlclose\n#define pg_dlerror\t\tdlerror\n\n#endif   /* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/backend/port/dynloader/freebsd.h": "/*-------------------------------------------------------------------------\n *\n * freebsd.h\n *\t  port-specific prototypes for FreeBSD\n *\n * Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * $PostgreSQL: pgsql/src/backend/port/dynloader/freebsd.h,v 1.23 2008/01/01 19:45:51 momjian Exp $\n *\n *-------------------------------------------------------------------------\n */\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include <sys/types.h>\n#include <nlist.h>\n#include <link.h>\n#include <dlfcn.h>\n\n#include \"utils/dynamic_loader.h\"\n\n/*\n * Dynamic Loader on NetBSD 1.0.\n *\n * this dynamic loader uses the system dynamic loading interface for shared\n * libraries (ie. dlopen/dlsym/dlclose). The user must specify a shared\n * library as the file to be dynamically loaded.\n *\n * agc - I know this is all a bit crufty, but it does work, is fairly\n * portable, and works (the stipulation that the d.l. function must\n * begin with an underscore is fairly tricky, and some versions of\n * NetBSD (like 1.0, and 1.0A pre June 1995) have no dlerror.)\n */\n\n/*\n * In some older systems, the RTLD_NOW flag isn't defined and the mode\n * argument to dlopen must always be 1.  The RTLD_GLOBAL flag is wanted\n * if available, but it doesn't exist everywhere.\n * If it doesn't exist, set it to 0 so it has no effect.\n */\n#ifndef RTLD_NOW\n#define RTLD_NOW 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n#define\t\t   pg_dlopen(f)    BSD44_derived_dlopen((f), RTLD_NOW | RTLD_GLOBAL)\n#define\t\t   pg_dlsym\t\t   BSD44_derived_dlsym\n#define\t\t   pg_dlclose\t   BSD44_derived_dlclose\n#define\t\t   pg_dlerror\t   BSD44_derived_dlerror\n\nchar\t   *BSD44_derived_dlerror(void);\nvoid\t   *BSD44_derived_dlopen(const char *filename, int num);\nvoid\t   *BSD44_derived_dlsym(void *handle, const char *name);\nvoid\t\tBSD44_derived_dlclose(void *handle);\n\n#endif   /* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/backend/port/dynloader/darwin.h": "/* $PostgreSQL: pgsql/src/backend/port/dynloader/darwin.h,v 1.5 2003/11/29 19:51:54 pgsql Exp $ */\n\n#include \"fmgr.h\"\n\nvoid\t   *pg_dlopen(char *filename);\nPGFunction\tpg_dlsym(void *handle, char *funcname);\nvoid\t\tpg_dlclose(void *handle);\nchar\t   *pg_dlerror(void);\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/backend/port/dynloader/sco.h": "/*-------------------------------------------------------------------------\n *\n * sco.h\n *\t  port-specific prototypes for SCO 3.2v5.2\n *\n *\n * Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * $PostgreSQL: pgsql/src/backend/port/dynloader/sco.h,v 1.20 2008/01/01 19:45:51 momjian Exp $\n *\n *-------------------------------------------------------------------------\n */\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include <dlfcn.h>\n#include \"utils/dynamic_loader.h\"\n\n/*\n * Dynamic Loader on SCO 3.2v5.0.2\n *\n * this dynamic loader uses the system dynamic loading interface for shared\n * libraries (ie. dlopen/dlsym/dlclose). The user must specify a shared\n * library as the file to be dynamically loaded.\n */\n\n/*\n * In some older systems, the RTLD_NOW flag isn't defined and the mode\n * argument to dlopen must always be 1.  The RTLD_GLOBAL flag is wanted\n * if available, but it doesn't exist everywhere.\n * If it doesn't exist, set it to 0 so it has no effect.\n */\n#ifndef RTLD_NOW\n#define RTLD_NOW 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n#define pg_dlopen(f)\tdlopen((f), RTLD_NOW | RTLD_GLOBAL)\n#define pg_dlsym\t\tdlsym\n#define pg_dlclose\t\tdlclose\n#define pg_dlerror\t\tdlerror\n\n#endif   /* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/backend/port/dynloader/win32.c": "/* $PostgreSQL: pgsql/src/backend/port/dynloader/win32.c,v 1.9 2006/12/04 22:23:40 momjian Exp $ */\n\n#include \"postgres.h\"\n\nchar\t   *dlerror(void);\nint\t\t\tdlclose(void *handle);\nvoid\t   *dlsym(void *handle, const char *symbol);\nvoid\t   *dlopen(const char *path, int mode);\n\nstatic char last_dyn_error[512];\n\nstatic void\nset_dl_error(void)\n{\n\tDWORD\t\terr = GetLastError();\n\n\tif (FormatMessage(FORMAT_MESSAGE_IGNORE_INSERTS |\n\t\t\t\t\t  FORMAT_MESSAGE_FROM_SYSTEM,\n\t\t\t\t\t  NULL,\n\t\t\t\t\t  err,\n\t\t\t\t\t  MAKELANGID(LANG_ENGLISH, SUBLANG_DEFAULT),\n\t\t\t\t\t  last_dyn_error,\n\t\t\t\t\t  sizeof(last_dyn_error) - 1,\n\t\t\t\t\t  NULL) == 0)\n\t{\n\t\tsnprintf(last_dyn_error, sizeof(last_dyn_error) - 1,\n\t\t\t\t \"unknown error %lu\", err);\n\t}\n}\n\nchar *\ndlerror(void)\n{\n\tif (last_dyn_error[0])\n\t\treturn last_dyn_error;\n\telse\n\t\treturn NULL;\n}\n\nint\ndlclose(void *handle)\n{\n\tif (!FreeLibrary((HMODULE) handle))\n\t{\n\t\tset_dl_error();\n\t\treturn 1;\n\t}\n\tlast_dyn_error[0] = 0;\n\treturn 0;\n}\n\nvoid *\ndlsym(void *handle, const char *symbol)\n{\n\tvoid\t   *ptr;\n\n\tptr = GetProcAddress((HMODULE) handle, symbol);\n\tif (!ptr)\n\t{\n\t\tset_dl_error();\n\t\treturn NULL;\n\t}\n\tlast_dyn_error[0] = 0;\n\treturn ptr;\n}\n\nvoid *\ndlopen(const char *path, int mode)\n{\n\tHMODULE\t\th;\n\tint\t\t\tprevmode;\n\n\t/* Disable popup error messages when loading DLLs */\n\tprevmode = SetErrorMode(SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);\n\th = LoadLibrary(path);\n\tSetErrorMode(prevmode);\n\n\tif (!h)\n\t{\n\t\tset_dl_error();\n\t\treturn NULL;\n\t}\n\tlast_dyn_error[0] = 0;\n\treturn (void *) h;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/backend/port/dynloader/bsdi.h": "/*-------------------------------------------------------------------------\n *\n * bsdi.h\n *\t\tDynamic loader interface for BSD/OS\n *\n * Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * $PostgreSQL: pgsql/src/backend/port/dynloader/bsdi.h,v 1.25 2008/01/01 19:45:51 momjian Exp $\n *\n *-------------------------------------------------------------------------\n */\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include \"utils/dynamic_loader.h\"\n\n\n#ifdef HAVE_DLOPEN\n\n#include <dlfcn.h>\n\n/*\n * In some older systems, the RTLD_NOW flag isn't defined and the mode\n * argument to dlopen must always be 1.  The RTLD_GLOBAL flag is wanted\n * if available, but it doesn't exist everywhere.\n * If it doesn't exist, set it to 0 so it has no effect.\n */\n#ifndef RTLD_NOW\n#define RTLD_NOW 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n#define\t\t  pg_dlopen(f)\t  dlopen((f), RTLD_NOW | RTLD_GLOBAL)\n#define\t\t  pg_dlsym\t\t  dlsym\n#define\t\t  pg_dlclose\t  dlclose\n#define\t\t  pg_dlerror\t  dlerror\n#else\t\t\t\t\t\t\t/* not HAVE_DLOPEN */\n\n#define pg_dlsym(handle, funcname)\t  ((PGFunction) dld_get_func((funcname)))\n#define pg_dlclose(handle) \\\ndo { \\\n\tdld_unlink_by_file(handle, 1); \\\n\tfree(handle); \\\n} while (0)\n#endif   /* not HAVE_DLOPEN */\n\n#endif   /* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/backend/port/dynloader/hpux.h": "/*-------------------------------------------------------------------------\n *\n * dynloader.h\n *\t  dynamic loader for HP-UX using the shared library mechanism\n *\n * Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n *\n * IDENTIFICATION\n *\t  $PostgreSQL: pgsql/src/backend/port/dynloader/hpux.h,v 1.14 2008/01/01 19:45:51 momjian Exp $\n *\n *\tNOTES\n *\t\tall functions are defined here -- it's impossible to trace the\n *\t\tshl_* routines from the bundled HP-UX debugger.\n *\n *-------------------------------------------------------------------------\n */\n/* System includes */\n#include \"fmgr.h\"\n\nextern void *pg_dlopen(char *filename);\nextern PGFunction pg_dlsym(void *handle, char *funcname);\nextern void pg_dlclose(void *handle);\nextern char *pg_dlerror(void);\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/backend/port/dynloader/osf.h": "/*-------------------------------------------------------------------------\n *\n * osf.h\n *\t  prototypes for OSF/1-specific routines\n *\n *\n * Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * $PostgreSQL: pgsql/src/backend/port/dynloader/osf.h,v 1.16 2008/01/01 19:45:51 momjian Exp $\n *\n *-------------------------------------------------------------------------\n */\n\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include <dlfcn.h>\n#include \"utils/dynamic_loader.h\"\n\n/*\n * Dynamic Loader on Alpha OSF/1.x\n *\n * this dynamic loader uses the system dynamic loading interface for shared\n * libraries (ie. dlopen/dlsym/dlclose). The user must specify a shared\n * library as the file to be dynamically loaded.\n */\n\n/*\n * In some older systems, the RTLD_NOW flag isn't defined and the mode\n * argument to dlopen must always be 1.  The RTLD_GLOBAL flag is wanted\n * if available, but it doesn't exist everywhere.\n * If it doesn't exist, set it to 0 so it has no effect.\n */\n#ifndef RTLD_NOW\n#define RTLD_NOW 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n#define  pg_dlopen(f)\tdlopen((f), RTLD_NOW | RTLD_GLOBAL)\n#define  pg_dlsym(h, f) ((PGFunction) dlsym(h, f))\n#define  pg_dlclose(h)\tdlclose(h)\n#define  pg_dlerror()\tdlerror()\n\n#endif   /* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/backend/port/dynloader/solaris.h": "/*-------------------------------------------------------------------------\n *\n * solaris.h\n *\t  port-specific prototypes for Solaris\n *\n *\n * Portions Copyright (c) 1996-2009, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * $PostgreSQL: pgsql/src/backend/port/dynloader/solaris.h,v 1.17 2009/01/01 17:23:46 momjian Exp $\n *\n *-------------------------------------------------------------------------\n */\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include <dlfcn.h>\n#include \"utils/dynamic_loader.h\"\n\n/*\n * In some older systems, the RTLD_NOW flag isn't defined and the mode\n * argument to dlopen must always be 1.  The RTLD_GLOBAL flag is wanted\n * if available, but it doesn't exist everywhere.\n * If it doesn't exist, set it to 0 so it has no effect.\n */\n#ifndef RTLD_NOW\n#define RTLD_NOW 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n#define pg_dlopen(f)\tdlopen((f), RTLD_NOW | RTLD_GLOBAL)\n#define pg_dlsym\t\tdlsym\n#define pg_dlclose\t\tdlclose\n#define pg_dlerror\t\tdlerror\n\n#endif   /* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/backend/port/dynloader/nextstep.h": "/*-------------------------------------------------------------------------\n *\n * port_protos.h\n *\t  port-specific prototypes for NeXT\n *\n * $PostgreSQL: pgsql/src/backend/port/dynloader/nextstep.h,v 1.9 2006/03/11 04:38:31 momjian Exp $\n */\n\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include \"utils/dynamic_loader.h\"\n\nvoid\t   *next_dlopen(char *name);\nint\t\t\tnext_dlclose(void *handle);\nvoid\t   *next_dlsym(void *handle, char *symbol);\nchar\t   *next_dlerror(void);\n\n#define pg_dlopen(f)\tnext_dlopen\n#define pg_dlsym\t\tnext_dlsym\n#define pg_dlclose\t\tnext_dlclose\n#define pg_dlerror\t\tnext_dlerror\n\n/* port.c */\n\n#endif   /* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/backend/port/dynloader/netbsd.c": "/*\n * Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group\n * Portions Copyright (c) 1990 The Regents of the University of California.\n * All rights reserved.\n *\n * $PostgreSQL: pgsql/src/backend/port/dynloader/netbsd.c,v 1.22.2.1 2008/03/05 21:20:47 alvherre Exp $\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *\t  notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *\t  notice, this list of conditions and the following disclaimer in the\n *\t  documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the University nor the names of its contributors\n *\t  may be used to endorse or promote products derived from this software\n *\t  without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.\tIN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#if defined(LIBC_SCCS) && !defined(lint)\nstatic char sccsid[] = \"@(#)dl.c\t5.4 (Berkeley) 2/23/91\";\n#endif   /* LIBC_SCCS and not lint */\n\n#include \"postgres.h\"\n\n#include <nlist.h>\n#include <link.h>\n#include <dlfcn.h>\n\n#include \"dynloader.h\"\n\nstatic char error_message[BUFSIZ];\n\nchar *\nBSD44_derived_dlerror(void)\n{\n\tstatic char ret[BUFSIZ];\n\n\tstrcpy(ret, error_message);\n\terror_message[0] = 0;\n\treturn (ret[0] == 0) ? NULL : ret;\n}\n\nvoid *\nBSD44_derived_dlopen(const char *file, int num)\n{\n#if !defined(HAVE_DLOPEN)\n\tsnprintf(error_message, sizeof(error_message),\n\t\t\t \"dlopen (%s) not supported\", file);\n\treturn NULL;\n#else\n\tvoid\t   *vp;\n\n\tif ((vp = dlopen((char *) file, num)) == NULL)\n\t\tsnprintf(error_message, sizeof(error_message),\n\t\t\t\t \"dlopen (%s) failed: %s\", file, dlerror());\n\treturn vp;\n#endif\n}\n\nvoid *\nBSD44_derived_dlsym(void *handle, const char *name)\n{\n#if !defined(HAVE_DLOPEN)\n\tsnprintf(error_message, sizeof(error_message),\n\t\t\t \"dlsym (%s) failed\", name);\n\treturn NULL;\n#else\n\tvoid\t   *vp;\n\n#ifndef __ELF__\n\tchar\t\tbuf[BUFSIZ];\n\n\tif (*name != '_')\n\t{\n\t\tsnprintf(buf, sizeof(buf), \"_%s\", name);\n\t\tname = buf;\n\t}\n#endif /* !__ELF__ */\n\tif ((vp = dlsym(handle, (char *) name)) == NULL)\n\t\tsnprintf(error_message, sizeof(error_message),\n\t\t\t\t \"dlsym (%s) failed\", name);\n\treturn vp;\n#endif\n}\n\nvoid\nBSD44_derived_dlclose(void *handle)\n{\n#if defined(HAVE_DLOPEN)\n\tdlclose(handle);\n#endif\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/backend/port/dynloader/aix.h": "/*-------------------------------------------------------------------------\n *\n * aix.h\n *\t  prototypes for AIX-specific routines\n *\n *\n * Portions Copyright (c) 1996-2009, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * $PostgreSQL: pgsql/src/backend/port/dynloader/aix.h,v 1.14 2009/04/21 21:15:50 tgl Exp $\n *\n *-------------------------------------------------------------------------\n */\n\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include <dlfcn.h>\n#include \"utils/dynamic_loader.h\"\n\n/*\n * In some older systems, the RTLD_NOW flag isn't defined and the mode\n * argument to dlopen must always be 1.  The RTLD_GLOBAL flag is wanted\n * if available, but it doesn't exist everywhere.\n * If it doesn't exist, set it to 0 so it has no effect.\n */\n#ifndef RTLD_NOW\n#define RTLD_NOW 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n#define  pg_dlopen(f)\tdlopen((f), RTLD_NOW | RTLD_GLOBAL)\n#define  pg_dlsym(h, f) ((PGFunction) dlsym(h, f))\n#define  pg_dlclose(h)\tdlclose(h)\n#define  pg_dlerror()\tdlerror()\n\n#endif   /* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/backend/port/dynloader/netbsd.h": "/*-------------------------------------------------------------------------\n *\n * netbsd.h\n *\t  port-specific prototypes for NetBSD\n *\n *\n * Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * $PostgreSQL: pgsql/src/backend/port/dynloader/netbsd.h,v 1.17 2008/01/01 19:45:51 momjian Exp $\n *\n *-------------------------------------------------------------------------\n */\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include <sys/types.h>\n#include <nlist.h>\n#include <link.h>\n#include <dlfcn.h>\n\n#include \"utils/dynamic_loader.h\"\n\n/*\n * Dynamic Loader on NetBSD 1.0.\n *\n * this dynamic loader uses the system dynamic loading interface for shared\n * libraries (ie. dlopen/dlsym/dlclose). The user must specify a shared\n * library as the file to be dynamically loaded.\n *\n * agc - I know this is all a bit crufty, but it does work, is fairly\n * portable, and works (the stipulation that the d.l. function must\n * begin with an underscore is fairly tricky, and some versions of\n * NetBSD (like 1.0, and 1.0A pre June 1995) have no dlerror.)\n */\n\n/*\n * In some older systems, the RTLD_NOW flag isn't defined and the mode\n * argument to dlopen must always be 1.  The RTLD_GLOBAL flag is wanted\n * if available, but it doesn't exist everywhere.\n * If it doesn't exist, set it to 0 so it has no effect.\n */\n#ifndef RTLD_NOW\n#define RTLD_NOW 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n#define\t\t   pg_dlopen(f)    BSD44_derived_dlopen((f), RTLD_NOW | RTLD_GLOBAL)\n#define\t\t   pg_dlsym\t\t   BSD44_derived_dlsym\n#define\t\t   pg_dlclose\t   BSD44_derived_dlclose\n#define\t\t   pg_dlerror\t   BSD44_derived_dlerror\n\nchar\t   *BSD44_derived_dlerror(void);\nvoid\t   *BSD44_derived_dlopen(const char *filename, int num);\nvoid\t   *BSD44_derived_dlsym(void *handle, const char *name);\nvoid\t\tBSD44_derived_dlclose(void *handle);\n\n#endif   /* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/backend/port/dynloader/unixware.h": "/*-------------------------------------------------------------------------\n *\n * unixware.h\n *\t  port-specific prototypes for Intel x86/UNIXWARE 7\n *\n *\n * Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * unixware.h,v 1.2 1995/03/17 06:40:18 andrew Exp\n *\n *-------------------------------------------------------------------------\n  */\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include <dlfcn.h>\n#include \"utils/dynamic_loader.h\"\n\n/*\n * Dynamic Loader on Intel x86/Intel SVR4.\n *\n * this dynamic loader uses the system dynamic loading interface for shared\n * libraries (ie. dlopen/dlsym/dlclose). The user must specify a shared\n * library as the file to be dynamically loaded.\n */\n\n/*\n * In some older systems, the RTLD_NOW flag isn't defined and the mode\n * argument to dlopen must always be 1.  The RTLD_GLOBAL flag is wanted\n * if available, but it doesn't exist everywhere.\n * If it doesn't exist, set it to 0 so it has no effect.\n */\n#ifndef RTLD_NOW\n#define RTLD_NOW 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n#define pg_dlopen(f)\tdlopen((f), RTLD_NOW | RTLD_GLOBAL)\n#define pg_dlsym\t\tdlsym\n#define pg_dlclose\t\tdlclose\n#define pg_dlerror\t\tdlerror\n\n#endif   /* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/backend/port/dynloader/svr4.h": "/*-------------------------------------------------------------------------\n *\n * svr4.h\n *\t  port-specific prototypes for Intel x86/Intel SVR4\n *\n *\n * Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * $PostgreSQL: pgsql/src/backend/port/dynloader/svr4.h,v 1.20 2008/01/01 19:45:51 momjian Exp $\n *\n *-------------------------------------------------------------------------\n */\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include <dlfcn.h>\n#include \"utils/dynamic_loader.h\"\n\n/*\n * Dynamic Loader on Intel x86/Intel SVR4.\n *\n * this dynamic loader uses the system dynamic loading interface for shared\n * libraries (ie. dlopen/dlsym/dlclose). The user must specify a shared\n * library as the file to be dynamically loaded.\n */\n\n/*\n * In some older systems, the RTLD_NOW flag isn't defined and the mode\n * argument to dlopen must always be 1.  The RTLD_GLOBAL flag is wanted\n * if available, but it doesn't exist everywhere.\n * If it doesn't exist, set it to 0 so it has no effect.\n */\n#ifndef RTLD_NOW\n#define RTLD_NOW 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n#define pg_dlopen(f)\tdlopen((f), RTLD_NOW | RTLD_GLOBAL)\n#define pg_dlsym\t\tdlsym\n#define pg_dlclose\t\tdlclose\n#define pg_dlerror\t\tdlerror\n\n#endif   /* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/backend/port/dynloader/openbsd.h": "/*-------------------------------------------------------------------------\n *\n * openbsd.h\n *\t  port-specific prototypes for OpenBSD\n *\n * Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * $PostgreSQL: pgsql/src/backend/port/dynloader/openbsd.h,v 1.18 2008/01/01 19:45:51 momjian Exp $\n *\n *-------------------------------------------------------------------------\n */\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include <sys/types.h>\n#include <nlist.h>\n#include <link.h>\n#include <dlfcn.h>\n\n#include \"utils/dynamic_loader.h\"\n\n/*\n * Dynamic Loader on NetBSD 1.0.\n *\n * this dynamic loader uses the system dynamic loading interface for shared\n * libraries (ie. dlopen/dlsym/dlclose). The user must specify a shared\n * library as the file to be dynamically loaded.\n *\n * agc - I know this is all a bit crufty, but it does work, is fairly\n * portable, and works (the stipulation that the d.l. function must\n * begin with an underscore is fairly tricky, and some versions of\n * NetBSD (like 1.0, and 1.0A pre June 1995) have no dlerror.)\n */\n\n/*\n * In some older systems, the RTLD_NOW flag isn't defined and the mode\n * argument to dlopen must always be 1.  The RTLD_GLOBAL flag is wanted\n * if available, but it doesn't exist everywhere.\n * If it doesn't exist, set it to 0 so it has no effect.\n */\n#ifndef RTLD_NOW\n#define RTLD_NOW 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n#define\t\t   pg_dlopen(f)    BSD44_derived_dlopen((f), RTLD_NOW | RTLD_GLOBAL)\n#define\t\t   pg_dlsym\t\t   BSD44_derived_dlsym\n#define\t\t   pg_dlclose\t   BSD44_derived_dlclose\n#define\t\t   pg_dlerror\t   BSD44_derived_dlerror\n\nchar\t   *BSD44_derived_dlerror(void);\nvoid\t   *BSD44_derived_dlopen(const char *filename, int num);\nvoid\t   *BSD44_derived_dlsym(void *handle, const char *name);\nvoid\t\tBSD44_derived_dlclose(void *handle);\n\n#endif   /* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/backend/port/dynloader/linux.c": "/*-------------------------------------------------------------------------\n *\n * linux.c\n *\t  Dynamic Loader for Postgres for Linux, generated from those for\n *\t  Ultrix.\n *\n *\t  You need to install the dld library on your Linux system!\n *\n * Portions Copyright (c) 1996-2009, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n *\n * IDENTIFICATION\n *\t  $PostgreSQL: pgsql/src/backend/port/dynloader/linux.c,v 1.35 2009/01/01 17:23:46 momjian Exp $\n *\n *-------------------------------------------------------------------------\n */\n\n#include \"postgres.h\"\n\n#ifdef HAVE_DLD_H\n#include <dld.h>\n#endif\n\n#include \"dynloader.h\"\n#include \"miscadmin.h\"\n\n\n#ifndef HAVE_DLOPEN\n\nvoid *\npg_dlopen(char *filename)\n{\n#ifndef HAVE_DLD_H\n\telog(ERROR, \"dynamic load not supported\");\n\treturn NULL;\n#else\n\tstatic int\tdl_initialized = 0;\n\n\t/*\n\t * initializes the dynamic loader with the executable's pathname. (only\n\t * needs to do this the first time pg_dlopen is called.)\n\t */\n\tif (!dl_initialized)\n\t{\n\t\tif (dld_init(dld_find_executable(my_exec_path)))\n\t\t\treturn NULL;\n\n\t\t/*\n\t\t * if there are undefined symbols, we want dl to search from the\n\t\t * following libraries also.\n\t\t */\n\t\tdl_initialized = 1;\n\t}\n\n\t/*\n\t * link the file, then check for undefined symbols!\n\t */\n\tif (dld_link(filename))\n\t\treturn NULL;\n\n\t/*\n\t * If undefined symbols: try to link with the C and math libraries! This\n\t * could be smarter, if the dynamic linker was able to handle shared libs!\n\t */\n\tif (dld_undefined_sym_count > 0)\n\t{\n\t\tif (dld_link(\"/usr/lib/libc.a\"))\n\t\t{\n\t\t\telog(WARNING, \"could not link C library\");\n\t\t\treturn NULL;\n\t\t}\n\t\tif (dld_undefined_sym_count > 0)\n\t\t{\n\t\t\tif (dld_link(\"/usr/lib/libm.a\"))\n\t\t\t{\n\t\t\t\telog(WARNING, \"could not link math library\");\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t\tif (dld_undefined_sym_count > 0)\n\t\t\t{\n\t\t\t\tint\t\t\tcount = dld_undefined_sym_count;\n\t\t\t\tchar\t  **list = dld_list_undefined_sym();\n\n\t\t\t\t/* list the undefined symbols, if any */\n\t\t\t\tdo\n\t\t\t\t{\n\t\t\t\t\telog(WARNING, \"\\\"%s\\\" is undefined\", *list);\n\t\t\t\t\tlist++;\n\t\t\t\t\tcount--;\n\t\t\t\t} while (count > 0);\n\n\t\t\t\tdld_unlink_by_file(filename, 1);\n\t\t\t\treturn NULL;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn (void *) strdup(filename);\n#endif\n}\n\nPGFunction\npg_dlsym(void *handle, char *funcname)\n{\n#ifndef HAVE_DLD_H\n\treturn NULL;\n#else\n\treturn (PGFunction) dld_get_func((funcname));\n#endif\n}\n\nvoid\npg_dlclose(void *handle)\n{\n#ifndef HAVE_DLD_H\n#else\n\tdld_unlink_by_file(handle, 1);\n\tfree(handle);\n#endif\n}\n\nchar *\npg_dlerror(void)\n{\n#ifndef HAVE_DLD_H\n\treturn \"dynaloader unspported\";\n#else\n\treturn dld_strerror(dld_errno);\n#endif\n}\n\n#endif   /* !HAVE_DLOPEN */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/backend/port/dynloader/freebsd.c": "/* $PostgreSQL: pgsql/src/backend/port/dynloader/freebsd.c,v 1.28 2008/01/01 19:45:51 momjian Exp $ */\n\n/*\n * Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group\n * Portions Copyright (c) 1990 The Regents of the University of California.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *\t  notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *\t  notice, this list of conditions and the following disclaimer in the\n *\t  documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the University nor the names of its contributors\n *\t  may be used to endorse or promote products derived from this software\n *\t  without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.\tIN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#if defined(LIBC_SCCS) && !defined(lint)\nstatic char sccsid[] = \"@(#)dl.c\t5.4 (Berkeley) 2/23/91\";\n#endif   /* LIBC_SCCS and not lint */\n\n#include \"postgres.h\"\n\n#include <nlist.h>\n#include <link.h>\n#include <dlfcn.h>\n\n#include \"dynloader.h\"\n\nstatic char error_message[BUFSIZ];\n\nchar *\nBSD44_derived_dlerror(void)\n{\n\tstatic char ret[BUFSIZ];\n\n\tstrcpy(ret, error_message);\n\terror_message[0] = 0;\n\treturn (ret[0] == 0) ? NULL : ret;\n}\n\nvoid *\nBSD44_derived_dlopen(const char *file, int num)\n{\n#if !defined(HAVE_DLOPEN)\n\tsnprintf(error_message, sizeof(error_message),\n\t\t\t \"dlopen (%s) not supported\", file);\n\treturn NULL;\n#else\n\tvoid\t   *vp;\n\n\tif ((vp = dlopen((char *) file, num)) == NULL)\n\t\tsnprintf(error_message, sizeof(error_message),\n\t\t\t\t \"dlopen (%s) failed: %s\", file, dlerror());\n\treturn vp;\n#endif\n}\n\nvoid *\nBSD44_derived_dlsym(void *handle, const char *name)\n{\n#if !defined(HAVE_DLOPEN)\n\tsnprintf(error_message, sizeof(error_message),\n\t\t\t \"dlsym (%s) failed\", name);\n\treturn NULL;\n#else\n\tvoid\t   *vp;\n\n#ifndef __ELF__\n\tchar\t\tbuf[BUFSIZ];\n\n\tif (*name != '_')\n\t{\n\t\tsnprintf(buf, sizeof(buf), \"_%s\", name);\n\t\tname = buf;\n\t}\n#endif /* !__ELF__ */\n\tif ((vp = dlsym(handle, (char *) name)) == NULL)\n\t\tsnprintf(error_message, sizeof(error_message),\n\t\t\t\t \"dlsym (%s) failed\", name);\n\treturn vp;\n#endif\n}\n\nvoid\nBSD44_derived_dlclose(void *handle)\n{\n#if defined(HAVE_DLOPEN)\n\tdlclose(handle);\n#endif\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/backend/port/dynloader/nextstep.c": "/* $PostgreSQL: pgsql/src/backend/port/dynloader/nextstep.c,v 1.6 2006/03/11 04:38:31 momjian Exp $ */\n\n#include \"postgres.h\"\n\n#include \"mach-o/rld.h\"\n#include \"streams/streams.h\"\n\nstatic char *lastError = NULL;\n\nstatic NXStream *\nOpenError()\n{\n\treturn NXOpenMemory(NULL, 0, NX_WRITEONLY);\n}\n\nstatic void\nCloseError(NXStream * s)\n{\n\tif (s)\n\t\tNXCloseMemory(s, NX_FREEBUFFER);\n}\n\nstatic void\nTransferError(NXStream * s)\n{\n\tchar\t   *buffer;\n\tint\t\t\tlen,\n\t\t\t\tmaxlen;\n\n\tif (lastError)\n\t\tfree(lastError);\n\tNXGetMemoryBuffer(s, &buffer, &len, &maxlen);\n\tlastError = malloc(len + 1);\n\tif(!lastError)\n\t\tereport(ERROR, errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\terrmsg(\"Transer error failed: out of memory\"));\n\n\tstrcpy(lastError, buffer);\n}\n\nvoid *\nnext_dlopen(char *name)\n{\n\tint\t\t\trld_success;\n\tNXStream   *errorStream;\n\tchar\t   *result = NULL;\n\tchar\t  **p;\n\n\terrorStream = OpenError();\n\tp = calloc(2, sizeof(void *));\n\tp[0] = name;\n\trld_success = rld_load(errorStream, NULL, p, NULL);\n\tfree(p);\n\n\tif (!rld_success)\n\t{\n\t\tTransferError(errorStream);\n\t\tresult = (char *) 1;\n\t}\n\tCloseError(errorStream);\n\treturn result;\n}\n\nint\nnext_dlclose(void *handle)\n{\n\treturn 0;\n}\n\nvoid *\nnext_dlsym(void *handle, char *symbol)\n{\n\tNXStream   *errorStream = OpenError();\n\tchar\t\tsymbuf[1024];\n\tunsigned long symref = 0;\n\n\tsnprintf(symbuf, sizeof(symbuf), \"_%s\", symbol);\n\tif (!rld_lookup(errorStream, symbuf, &symref))\n\t\tTransferError(errorStream);\n\tCloseError(errorStream);\n\treturn (void *) symref;\n}\n\nchar *\nnext_dlerror(void)\n{\n\treturn lastError;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/backend/port/dynloader/openbsd.c": "/*\n * Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group\n * Portions Copyright (c) 1990 The Regents of the University of California.\n * All rights reserved.\n *\n * $PostgreSQL: pgsql/src/backend/port/dynloader/openbsd.c,v 1.22 2008/01/01 19:45:51 momjian Exp $\n *\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions\n * are met:\n * 1. Redistributions of source code must retain the above copyright\n *\t  notice, this list of conditions and the following disclaimer.\n * 2. Redistributions in binary form must reproduce the above copyright\n *\t  notice, this list of conditions and the following disclaimer in the\n *\t  documentation and/or other materials provided with the distribution.\n * 3. Neither the name of the University nor the names of its contributors\n *\t  may be used to endorse or promote products derived from this software\n *\t  without specific prior written permission.\n *\n * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED.\tIN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE\n * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\n * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS\n * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)\n * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY\n * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF\n * SUCH DAMAGE.\n */\n\n#if defined(LIBC_SCCS) && !defined(lint)\nstatic char sccsid[] = \"@(#)dl.c\t5.4 (Berkeley) 2/23/91\";\n#endif   /* LIBC_SCCS and not lint */\n\n#include \"postgres.h\"\n\n#include <nlist.h>\n#include <link.h>\n#include <dlfcn.h>\n\n#include \"dynloader.h\"\n\nstatic char error_message[BUFSIZ];\n\nchar *\nBSD44_derived_dlerror(void)\n{\n\tstatic char ret[BUFSIZ];\n\n\tstrcpy(ret, error_message);\n\terror_message[0] = 0;\n\treturn (ret[0] == 0) ? NULL : ret;\n}\n\nvoid *\nBSD44_derived_dlopen(const char *file, int num)\n{\n#if !defined(HAVE_DLOPEN)\n\tsnprintf(error_message, sizeof(error_message),\n\t\t\t \"dlopen (%s) not supported\", file);\n\treturn NULL;\n#else\n\tvoid\t   *vp;\n\n\tif ((vp = dlopen((char *) file, num)) == NULL)\n\t\tsnprintf(error_message, sizeof(error_message),\n\t\t\t\t \"dlopen (%s) failed: %s\", file, dlerror());\n\treturn vp;\n#endif\n}\n\nvoid *\nBSD44_derived_dlsym(void *handle, const char *name)\n{\n#if !defined(HAVE_DLOPEN)\n\tsnprintf(error_message, sizeof(error_message),\n\t\t\t \"dlsym (%s) failed\", name);\n\treturn NULL;\n#else\n\tvoid\t   *vp;\n\n#ifndef __ELF__\n\tchar\t\tbuf[BUFSIZ];\n\n\tif (*name != '_')\n\t{\n\t\tsnprintf(buf, sizeof(buf), \"_%s\", name);\n\t\tname = buf;\n\t}\n#endif /* !__ELF__ */\n\tif ((vp = dlsym(handle, (char *) name)) == NULL)\n\t\tsnprintf(error_message, sizeof(error_message),\n\t\t\t\t \"dlsym (%s) failed\", name);\n\treturn vp;\n#endif\n}\n\nvoid\nBSD44_derived_dlclose(void *handle)\n{\n#if defined(HAVE_DLOPEN)\n\tdlclose(handle);\n#endif\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/backend/port/dynloader/univel.h": "/*-------------------------------------------------------------------------\n *\n * univel.h\n *\t  port-specific prototypes for Intel x86/UNIXWARE\n *\n *\n * Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * univel.h,v 1.2 1995/03/17 06:40:18 andrew Exp\n *\n *-------------------------------------------------------------------------\n  */\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include <dlfcn.h>\n#include \"utils/dynamic_loader.h\"\n\n/*\n * Dynamic Loader on Intel x86/Intel SVR4.\n *\n * this dynamic loader uses the system dynamic loading interface for shared\n * libraries (ie. dlopen/dlsym/dlclose). The user must specify a shared\n * library as the file to be dynamically loaded.\n */\n\n/*\n * In some older systems, the RTLD_NOW flag isn't defined and the mode\n * argument to dlopen must always be 1.  The RTLD_GLOBAL flag is wanted\n * if available, but it doesn't exist everywhere.\n * If it doesn't exist, set it to 0 so it has no effect.\n */\n#ifndef RTLD_NOW\n#define RTLD_NOW 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n#define pg_dlopen(f)\tdlopen((f), RTLD_NOW | RTLD_GLOBAL)\n#define pg_dlsym\t\tdlsym\n#define pg_dlclose\t\tdlclose\n#define pg_dlerror\t\tdlerror\n\n#endif   /* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/backend/port/dynloader/README.dlfcn.aix": "libdl.a\n-------\n\nThis is an emulation library to emulate the SunOS/System V.4 functions\nto access the runtime linker. The functions are emulated by using the\nAIX load() function and by reading the .loader section of the loaded\nmodule to find the exports. The to be loaded module should be linked as\nfollows (if using AIX 3):\n\n\tcc -o module.so -bM:SRE -bE:module.exp -e _nostart $(OBJS)\n\nFor AIX 4:\n\n\tcc -o module.so -bM:SRE -bE:module.exp -bnoentry $(OBJS)\n\nThe module export file contains the symbols to be exported. Because\nthis library uses the loader section, the final module.so file can be\nstripped. C++ users should build their shared objects using the script\nmakeC++SharedLib (part of the IBM C++ compiler), this will make sure\nthat constructors and destructors for static and global objects will be\ncalled upon loading and unloading the module.\n\nUsage\n-----\n\nvoid *dlopen(const char *path, int mode);\n\nThis routine loads the module pointed to by path and reads its export\ntable. If the path does not contain a '/' character, dlopen will search\nfor the module using the LIBPATH environment variable. It returns an\nopaque handle to the module or NULL on error. The mode parameter can be\neither RTLD_LAZY (for lazy function binding) or RTLD_NOW for immediate\nfunction binding. The AIX implementation currently behaves as RTLD_NOW\neven if RTLD_LAZY is specified. The flag RTLD_GLOBAL might be or'ed into the\nmode parameter to allow loaded modules to bind to global variables or\nfunctions in other loaded modules loaded by dlopen(). If RTLD_GLOBAL is\nnot specified, only globals from the main part of the executable or\nshared libraries are used to look for undefined symbols in loaded\nmodules.\n\n\nvoid *dlsym(void *handle, const char *symbol);\n\nThis routine searches for the symbol in the module referred to by\nhandle and returns its address. If the symbol could not be found, the\nfunction returns NULL. The return value must be casted to a proper\nfunction pointer before it can be used. SunOS/System V.4 allow handle\nto be a NULL pointer to refer to the module the call is made from, this\nis not implemented.\n\nint dlclose(void *handle);\n\nThis routine unloads the module referred to by the handle and disposes\nof any local storage. this function returns -1 on failure.\n\nchar *dlerror(void);\n\nThis routine can be used to retrieve a text message describing the most\nrecent error that occured on on of the above routines. This function\nreturns NULL if there is not error information.\n\nInitialization and termination handlers\n---------------------------------------\n\nThe emulation provides for an initialization and a termination\nhandler.  The dlfcn.h file contains a structure declaration named\ndl_info with following members:\n\n\tvoid (*init)(void);\n\tvoid (*fini)(void);\n\nThe init function is called upon first referencing the library. The\nfini function is called at dlclose() time or when the process exits.\nThe module should declare a variable named dl_info that contains this\nstructure which must be exported.  These functions correspond to the\ndocumented _init() and _fini() functions of SunOS 4.x, but these are\nappearently not implemented in SunOS.  When using SunOS 5.0, these\ncorrespond to #pragma init and #pragma fini respectively. At the same\ntime any static or global C++ object's constructors or destructors will\nbe called.\n\nJens-Uwe Mager\n\nHELIOS Software GmbH\nLavesstr. 80\n30159 Hannover\nGermany\n\nPhone:\t\t+49 511 36482-0\nFAX:\t\t+49 511 36482-69\nAppleLink:\thelios.de\tAttn: Jens-Uwe Mager\nInternet:\tjum@helios.de\n\nRevison History\n---------------\n\nSCCS/s.dlfcn.h:\n\nD 1.4 95/04/25 09:36:52 jum 4 3\t00018/00004/00028\nMRs:\nCOMMENTS:\nadded RTLD_GLOBAL, include and C++ guards\n\nD 1.3 92/12/27 20:58:32 jum 3 2\t00001/00001/00031\nMRs:\nCOMMENTS:\nwe always have prototypes on RS/6000\n\nD 1.2 92/08/16 17:45:11 jum 2 1\t00009/00000/00023\nMRs:\nCOMMENTS:\nadded dl_info structure to implement initialize and terminate functions\n\nD 1.1 92/08/02 18:08:45 jum 1 0\t00023/00000/00000\nMRs:\nCOMMENTS:\nErstellungsdatum und -uhrzeit 92/08/02 18:08:45 von jum\n\nSCCS/s.dlfcn.c:\n\nD 1.7 95/08/14 19:08:38 jum 8 6\t00026/00004/00502\nMRs:\nCOMMENTS:\nIntegrated the fixes from Kirk Benell (kirk@rsinc.com) to allow loading of\nshared objects generated under AIX 4. Fixed bug that symbols with exactly\n8 characters would use garbage characters from the following symbol value.\n\nD 1.6 95/04/25 09:38:03 jum 6 5\t00046/00006/00460\nMRs:\nCOMMENTS:\nadded handling of C++ static constructors and destructors, added RTLD_GLOBAL to bind against other loaded modules\n\nD 1.5 93/02/14 20:14:17 jum 5 4\t00002/00000/00464\nMRs:\nCOMMENTS:\nadded path to dlopen error message to make clear where there error occured.\n\nD 1.4 93/01/03 19:13:56 jum 4 3\t00061/00005/00403\nMRs:\nCOMMENTS:\nto allow calling symbols in the main module call load with L_NOAUTODEFER and \ndo a loadbind later with the main module.\n\nD 1.3 92/12/27 20:59:55 jum 3 2\t00066/00008/00342\nMRs:\nCOMMENTS:\nadded search by L_GETINFO if module got loaded by LIBPATH\n\nD 1.2 92/08/16 17:45:43 jum 2 1\t00074/00006/00276\nMRs:\nCOMMENTS:\nimplemented initialize and terminate functions, added reference counting to avoid multiple loads of the same library\n\nD 1.1 92/08/02 18:08:45 jum 1 0\t00282/00000/00000\nMRs:\nCOMMENTS:\nErstellungsdatum und -uhrzeit 92/08/02 18:08:45 von jum\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/backend/port/dynloader/irix.h": "/*-------------------------------------------------------------------------\n *\n * irix.h\n *\t  port-specific prototypes for Irix\n *\n *\n * Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * $PostgreSQL: pgsql/src/backend/port/dynloader/irix.h,v 1.6 2008/01/01 19:45:51 momjian Exp $\n *\n *-------------------------------------------------------------------------\n */\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include <dlfcn.h>\n#include \"utils/dynamic_loader.h\"\n\n/*\n * Dynamic Loader on SunOS 4.\n *\n * this dynamic loader uses the system dynamic loading interface for shared\n * libraries (ie. dlopen/dlsym/dlclose). The user must specify a shared\n * library as the file to be dynamically loaded.\n */\n\n/*\n * In some older systems, the RTLD_NOW flag isn't defined and the mode\n * argument to dlopen must always be 1.  The RTLD_GLOBAL flag is wanted\n * if available, but it doesn't exist everywhere.\n * If it doesn't exist, set it to 0 so it has no effect.\n */\n#ifndef RTLD_NOW\n#define RTLD_NOW 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n#define pg_dlopen(f)\tdlopen((f), RTLD_NOW | RTLD_GLOBAL)\n#define pg_dlsym\t\tdlsym\n#define pg_dlclose\t\tdlclose\n#define pg_dlerror\t\tdlerror\n\n#endif   /* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/backend/port/dynloader/hpux.c": "/*-------------------------------------------------------------------------\n *\n * dynloader.c\n *\t  dynamic loader for HP-UX using the shared library mechanism\n *\n * Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n *\n * IDENTIFICATION\n *\t  $PostgreSQL: pgsql/src/backend/port/dynloader/hpux.c,v 1.31 2008/01/01 19:45:51 momjian Exp $\n *\n *\tNOTES\n *\t\tall functions are defined here -- it's impossible to trace the\n *\t\tshl_* routines from the bundled HP-UX debugger.\n *\n *-------------------------------------------------------------------------\n */\n#include \"postgres.h\"\n\n/* System includes */\n#include <a.out.h>\n#include <dl.h>\n\n#include \"dynloader.h\"\n#include \"utils/dynamic_loader.h\"\n\nvoid *\npg_dlopen(char *filename)\n{\n\t/*\n\t * Use BIND_IMMEDIATE so that undefined symbols cause a failure return\n\t * from shl_load(), rather than an abort() later on when we attempt to\n\t * call the library!\n\t */\n\tshl_t\t\thandle = shl_load(filename,\n\t\t\t\t\t\t\t\tBIND_IMMEDIATE | BIND_VERBOSE | DYNAMIC_PATH,\n\t\t\t\t\t\t\t\t  0L);\n\n\treturn (void *) handle;\n}\n\nPGFunction\npg_dlsym(void *handle, char *funcname)\n{\n\tPGFunction\tf;\n\n\tif (shl_findsym((shl_t *) & handle, funcname, TYPE_PROCEDURE, &f) == -1)\n\t\tf = (PGFunction) NULL;\n\treturn f;\n}\n\nvoid\npg_dlclose(void *handle)\n{\n\tshl_unload((shl_t) handle);\n}\n\nchar *\npg_dlerror(void)\n{\n\tstatic char errmsg[] = \"shl_load failed\";\n\n\tif (errno)\n\t\treturn strerror(errno);\n\n\treturn errmsg;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/backend/port/dynloader/linux.h": "/*-------------------------------------------------------------------------\n *\n * linux.h\n *\t\tPort-specific prototypes for Linux\n *\n *\n * Portions Copyright (c) 1996-2009, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n * $PostgreSQL: pgsql/src/backend/port/dynloader/linux.h,v 1.28 2009/01/01 17:23:46 momjian Exp $\n *\n *-------------------------------------------------------------------------\n */\n#ifndef PORT_PROTOS_H\n#define PORT_PROTOS_H\n\n#include \"utils/dynamic_loader.h\"\n#ifdef HAVE_DLOPEN\n#include <dlfcn.h>\n#endif\n\n\n#ifdef HAVE_DLOPEN\n\n/*\n * In some older systems, the RTLD_NOW flag isn't defined and the mode\n * argument to dlopen must always be 1.  The RTLD_GLOBAL flag is wanted\n * if available, but it doesn't exist everywhere.\n * If it doesn't exist, set it to 0 so it has no effect.\n */\n#ifndef RTLD_NOW\n#define RTLD_NOW 1\n#endif\n#ifndef RTLD_GLOBAL\n#define RTLD_GLOBAL 0\n#endif\n\n#define pg_dlopen(f)\tdlopen((f), RTLD_NOW | RTLD_GLOBAL)\n#define pg_dlsym\t\tdlsym\n#define pg_dlclose\t\tdlclose\n#define pg_dlerror\t\tdlerror\n#endif   /* HAVE_DLOPEN */\n\n#endif   /* PORT_PROTOS_H */\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/backend/utils/fmgr/dfmgr.c": "/*-------------------------------------------------------------------------\n *\n * dfmgr.c\n *\t  Dynamic function manager code.\n *\n * Portions Copyright (c) 1996-2009, PostgreSQL Global Development Group\n * Portions Copyright (c) 1994, Regents of the University of California\n *\n *\n * IDENTIFICATION\n *\t  $PostgreSQL: pgsql/src/backend/utils/fmgr/dfmgr.c,v 1.99.2.1 2009/09/03 22:11:13 tgl Exp $\n *\n *-------------------------------------------------------------------------\n */\n#include \"postgres.h\"\n\n#include <sys/stat.h>\n\n#ifndef WIN32_ONLY_COMPILER\n#include \"dynloader.h\"\n#else\n#include \"port/dynloader/win32.h\"\n#endif\n#include \"lib/stringinfo.h\"\n#include \"miscadmin.h\"\n#include \"utils/dynamic_loader.h\"\n#include \"utils/hsearch.h\"\n\n\n/* signatures for PostgreSQL-specific library init/fini functions */\ntypedef void (*PG_init_t) (void);\ntypedef void (*PG_fini_t) (void);\n\n/* hashtable entry for rendezvous variables */\ntypedef struct\n{\n\tchar\t\tvarName[NAMEDATALEN];\t/* hash key (must be first) */\n\tvoid\t   *varValue;\n} rendezvousHashEntry;\n\n/*\n * List of dynamically loaded files (kept in malloc'd memory).\n */\n\ntypedef struct df_files\n{\n\tstruct df_files *next;\t\t/* List link */\n\tdev_t\t\tdevice;\t\t\t/* Device file is on */\n#ifndef WIN32\t\t\t\t\t/* ensures we never again depend on this under\n\t\t\t\t\t\t\t\t * win32 */\n\tino_t\t\tinode;\t\t\t/* Inode number of file */\n#endif\n\tvoid\t   *handle;\t\t\t/* a handle for pg_dl* functions */\n\tchar\t\tfilename[1];\t/* Full pathname of file */\n\n\t/*\n\t * we allocate the block big enough for actual length of pathname.\n\t * filename[] must be last item in struct!\n\t */\n} DynamicFileList;\n\nstatic DynamicFileList *file_list = NULL;\nstatic DynamicFileList *file_tail = NULL;\n\n/* stat() call under Win32 returns an st_ino field, but it has no meaning */\n#ifndef WIN32\n#define SAME_INODE(A,B) ((A).st_ino == (B).inode && (A).st_dev == (B).device)\n#else\n#define SAME_INODE(A,B) false\n#endif\n\nchar\t   *Dynamic_library_path;\n\nstatic void *internal_load_library(const char *libname);\nstatic void incompatible_module_error(const char *libname,\n\t\t\t\t\t\t  const Pg_magic_struct *module_magic_data);\nstatic void internal_unload_library(const char *libname);\nstatic bool file_exists(const char *name);\nstatic char *expand_dynamic_library_name(const char *name);\nstatic void check_restricted_library_name(const char *name);\nstatic char *substitute_libpath_macro(const char *name);\nstatic char *find_in_dynamic_libpath(const char *basename);\nstatic const char *get_magic_product(const Pg_magic_struct *module_magic_data);\n\n/* Magic structure that module needs to match to be accepted */\nstatic const Pg_magic_struct magic_data = PG_MODULE_MAGIC_DATA;\n\n\n/*\n * Load the specified dynamic-link library file, and look for a function\n * named funcname in it.\n *\n * If the function is not found, we raise an error if signalNotFound is true,\n * else return (PGFunction) NULL.  Note that errors in loading the library\n * will provoke ereport() regardless of signalNotFound.\n *\n * If filehandle is not NULL, then *filehandle will be set to a handle\n * identifying the library file.  The filehandle can be used with\n * lookup_external_function to lookup additional functions in the same file\n * at less cost than repeating load_external_function.\n */\nPGFunction\nload_external_function(char *filename, char *funcname,\n\t\t\t\t\t   bool signalNotFound, void **filehandle)\n{\n\tchar\t   *fullname;\n\tvoid\t   *lib_handle;\n\tPGFunction\tretval;\n\n\t/* Expand the possibly-abbreviated filename to an exact path name */\n\tfullname = expand_dynamic_library_name(filename);\n\n\t/* Load the shared library, unless we already did */\n\tlib_handle = internal_load_library(fullname);\n\n\t/* Return handle if caller wants it */\n\tif (filehandle)\n\t\t*filehandle = lib_handle;\n\n\t/* Look up the function within the library */\n\tretval = (PGFunction) pg_dlsym(lib_handle, funcname);\n\n\tif (retval == NULL && signalNotFound)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_UNDEFINED_FUNCTION),\n\t\t\t\t errmsg(\"could not find function \\\"%s\\\" in file \\\"%s\\\"\",\n\t\t\t\t\t\tfuncname, fullname)));\n\n\tpfree(fullname);\n\treturn retval;\n}\n\n/*\n * This function loads a shlib file without looking up any particular\n * function in it.\tIf the same shlib has previously been loaded,\n * unload and reload it.\n *\n * When 'restricted' is true, only libraries in the presumed-secure\n * directory $libdir/plugins may be referenced.\n */\nvoid\nload_file(const char *filename, bool restricted)\n{\n\tchar\t   *fullname;\n\n\t/* Apply security restriction if requested */\n\tif (restricted)\n\t\tcheck_restricted_library_name(filename);\n\n\t/* Expand the possibly-abbreviated filename to an exact path name */\n\tfullname = expand_dynamic_library_name(filename);\n\n\t/* Unload the library if currently loaded */\n\tinternal_unload_library(fullname);\n\n\t/* Load the shared library */\n\t(void) internal_load_library(fullname);\n\n\tpfree(fullname);\n}\n\n/*\n * Lookup a function whose library file is already loaded.\n * Return (PGFunction) NULL if not found.\n */\nPGFunction\nlookup_external_function(void *filehandle, char *funcname)\n{\n\treturn (PGFunction) pg_dlsym(filehandle, funcname);\n}\n\n\n/*\n * Load the specified dynamic-link library file, unless it already is\n * loaded.\tReturn the pg_dl* handle for the file.\n *\n * Note: libname is expected to be an exact name for the library file.\n */\nstatic void *\ninternal_load_library(const char *libname)\n{\n\tDynamicFileList *file_scanner;\n\tPGModuleMagicFunction magic_func;\n\tchar\t   *load_error;\n\tstruct stat stat_buf;\n\tPG_init_t\tPG_init;\n\n\t/*\n\t * Scan the list of loaded FILES to see if the file has been loaded.\n\t */\n\tfor (file_scanner = file_list;\n\t\t file_scanner != NULL &&\n\t\t strcmp(libname, file_scanner->filename) != 0;\n\t\t file_scanner = file_scanner->next)\n\t\t;\n\n\tif (file_scanner == NULL)\n\t{\n\t\t/*\n\t\t * Check for same files - different paths (ie, symlink or link)\n\t\t */\n\t\tif (stat(libname, &stat_buf) == -1)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not access file \\\"%s\\\": %m\",\n\t\t\t\t\t\t\tlibname)));\n\n\t\tfor (file_scanner = file_list;\n\t\t\t file_scanner != NULL &&\n\t\t\t !SAME_INODE(stat_buf, *file_scanner);\n\t\t\t file_scanner = file_scanner->next)\n\t\t\t;\n\t}\n\n\tif (file_scanner == NULL)\n\t{\n\t\t/*\n\t\t * File not loaded yet.\n\t\t */\n\t\tfile_scanner = (DynamicFileList *)\n\t\t\tmalloc(sizeof(DynamicFileList) + strlen(libname));\n\t\tif (file_scanner == NULL)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_OUT_OF_MEMORY),\n\t\t\t\t\t errmsg(\"out of memory\")));\n\n\t\tMemSet(file_scanner, 0, sizeof(DynamicFileList));\n\t\tstrcpy(file_scanner->filename, libname);\n\t\tfile_scanner->device = stat_buf.st_dev;\n#ifndef WIN32\n\t\tfile_scanner->inode = stat_buf.st_ino;\n#endif\n\t\tfile_scanner->next = NULL;\n\n\t\tfile_scanner->handle = pg_dlopen(file_scanner->filename);\n\t\tif (file_scanner->handle == NULL)\n\t\t{\n\t\t\tload_error = (char *) pg_dlerror();\n\t\t\tfree((char *) file_scanner);\n\t\t\t/* errcode_for_file_access might not be appropriate here? */\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t\t errmsg(\"could not load library \\\"%s\\\": %s\",\n\t\t\t\t\t\t\tlibname, load_error)));\n\t\t}\n\n\t\t/* Check the magic function to determine compatibility */\n\t\tmagic_func = (PGModuleMagicFunction)\n\t\t\tpg_dlsym(file_scanner->handle, PG_MAGIC_FUNCTION_NAME_STRING);\n\t\tif (magic_func)\n\t\t{\n\t\t\tconst Pg_magic_struct *magic_data_ptr = (*magic_func) ();\n\n\t\t\tif (magic_data_ptr->len != magic_data.len ||\n\t\t\t\tmemcmp(magic_data_ptr, &magic_data, magic_data.len) != 0)\n\t\t\t{\n\t\t\t\t/* copy data block before unlinking library */\n\t\t\t\tPg_magic_struct module_magic_data = *magic_data_ptr;\n\n\t\t\t\t/* try to unlink library */\n\t\t\t\tpg_dlclose(file_scanner->handle);\n\t\t\t\tfree((char *) file_scanner);\n\n\t\t\t\t/* issue suitable complaint */\n\t\t\t\tincompatible_module_error(libname, &module_magic_data);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\t/* try to unlink library */\n\t\t\tpg_dlclose(file_scanner->handle);\n\t\t\tfree((char *) file_scanner);\n\t\t\t/* complain */\n\t\t\tereport(ERROR,\n\t\t\t\t  (errmsg(\"incompatible library \\\"%s\\\": missing magic block\",\n\t\t\t\t\t\t  libname),\n\t\t\t\t   errhint(\"Extension libraries are required to use the PG_MODULE_MAGIC macro.\")));\n\t\t}\n\n\t\t/*\n\t\t * If the library has a _PG_init() function, call it.\n\t\t */\n\t\tPG_init = (PG_init_t) pg_dlsym(file_scanner->handle, \"_PG_init\");\n\t\tif (PG_init)\n\t\t\t(*PG_init) ();\n\n\t\t/* OK to link it into list */\n\t\tif (file_list == NULL)\n\t\t\tfile_list = file_scanner;\n\t\telse\n\t\t\tfile_tail->next = file_scanner;\n\t\tfile_tail = file_scanner;\n\t}\n\n\treturn file_scanner->handle;\n}\n\n/*\n * Identify what product a particular magic data was compiled for.\n */\nstatic const char*\nget_magic_product(const Pg_magic_struct *module_magic_data)\n{\n\t/*\n\t * Assume that any magic_data context that does not contain a product code\n\t * must be Postgres, probably.\n\t */\n\tif (module_magic_data->len <= offsetof(Pg_magic_struct, product))\n\t\treturn \"PostgreSQL\";\n\t\n\tswitch (module_magic_data->product)\n\t{\n\t\tcase PgMagicProductNone:\n\t\tcase PgMagicProductPostgres:\n\t\t\treturn \"PostgreSQL\";\n\n\t\tcase PgMagicProductGreenplum:\n\t\t\treturn \"Greenplum\";\n\n\t\t/* Handle Unrecognized product codes */\n\t\tdefault:\n\t\t\treturn psprintf(\"Product(%d)\", module_magic_data->product);\n\t}\n}\n\n\n/*\n * Report a suitable error for an incompatible magic block.\n */\nstatic void\nincompatible_module_error(const char *libname,\n\t\t\t\t\t\t  const Pg_magic_struct *module_magic_data)\n{\n\tStringInfoData details;\n\tconst char *magic_product     = get_magic_product(&magic_data);\n\tconst char *mod_magic_product = get_magic_product(module_magic_data);\n\n\t/*\n\t * The default header version for module_magic_data is assumed to be 0\n\t * as it may not be recent enough to have the headerversion field\n\t */\n\tint lib_internal_version = 0;\n\n\t/* module_magic_data is recent enough to provide its own header version */\n\tif (module_magic_data->len > offsetof(Pg_magic_struct, headerversion))\n\t{\n\t\tlib_internal_version = module_magic_data->headerversion;\n\t}\n\n\t/*\n\t * If the version doesn't match, just report that, because the rest of the\n\t * block might not even have the fields we expect.\n\t */\n\tif (magic_data.version != module_magic_data->version ||\n\t\tmagic_data.product != module_magic_data->product ||\n\t\tmagic_data.headerversion != lib_internal_version)\n\t{\n\t\tereport(ERROR,\n\t\t\t\t(errmsg(\"incompatible library \\\"%s\\\": version mismatch\",\n\t\t\t\t\t\tlibname),\n\t\t\t  errdetail(\"Server version is %s %d.%d (header version: %d), library is %s %d.%d (header version: %d).\",\n\t\t\t\t\t\tmagic_product,\n\t\t\t\t\t\tmagic_data.version / 100,\n\t\t\t\t\t\tmagic_data.version % 100,\n\t\t\t\t\t\tmagic_data.headerversion,\n\t\t\t\t\t\tmod_magic_product,\n\t\t\t\t\t\tmodule_magic_data->version / 100,\n\t\t\t\t\t\tmodule_magic_data->version % 100,\n\t\t\t\t\t\tlib_internal_version)\n\t\t\t\t)\n\t\t);\n\t}\n\n\t/*\n\t * Otherwise, spell out which fields don't agree.\n\t *\n\t * XXX this code has to be adjusted any time the set of fields in a magic\n\t * block change!\n\t */\n\tinitStringInfo(&details);\n\n\tif (module_magic_data->funcmaxargs != magic_data.funcmaxargs)\n\t{\n\t\tif (details.len)\n\t\t{\n\t\t\tappendStringInfoChar(&details, '\\n');\n\t\t}\n\t\tappendStringInfo(&details,\n\t\t\t\t\t\t _(\"Server has FUNC_MAX_ARGS = %d, library has %d.\"),\n\t\t\t\t\t\t magic_data.funcmaxargs,\n\t\t\t\t\t\t module_magic_data->funcmaxargs);\n\t}\n\tif (module_magic_data->indexmaxkeys != magic_data.indexmaxkeys)\n\t{\n\t\tif (details.len)\n\t\t{\n\t\t\tappendStringInfoChar(&details, '\\n');\n\t\t}\n\t\tappendStringInfo(&details,\n\t\t\t\t\t\t _(\"Server has INDEX_MAX_KEYS = %d, library has %d.\"),\n\t\t\t\t\t\t magic_data.indexmaxkeys,\n\t\t\t\t\t\t module_magic_data->indexmaxkeys);\n\t}\n\tif (module_magic_data->namedatalen != magic_data.namedatalen)\n\t{\n\t\tif (details.len)\n\t\t{\n\t\t\tappendStringInfoChar(&details, '\\n');\n\t\t}\n\t\tappendStringInfo(&details,\n\t\t\t\t\t\t _(\"Server has NAMEDATALEN = %d, library has %d.\"),\n\t\t\t\t\t\t magic_data.namedatalen,\n\t\t\t\t\t\t module_magic_data->namedatalen);\n\t}\n\tif (module_magic_data->float4byval != magic_data.float4byval)\n\t{\n\t\tif (details.len)\n\t\t{\n\t\t\tappendStringInfoChar(&details, '\\n');\n\t\t}\n\t\tappendStringInfo(&details,\n\t\t\t\t\t   _(\"Server has FLOAT4PASSBYVAL = %s, library has %s.\"),\n\t\t\t\t\t\t magic_data.float4byval ? \"true\" : \"false\",\n\t\t\t\t\t\t module_magic_data->float4byval ? \"true\" : \"false\");\n\t}\n\tif (module_magic_data->float8byval != magic_data.float8byval)\n\t{\n\t\tif (details.len)\n\t\t{\n\t\t\tappendStringInfoChar(&details, '\\n');\n\t\t}\n\t\tappendStringInfo(&details,\n\t\t\t\t\t   _(\"Server has FLOAT8PASSBYVAL = %s, library has %s.\"),\n\t\t\t\t\t\t magic_data.float8byval ? \"true\" : \"false\",\n\t\t\t\t\t\t module_magic_data->float8byval ? \"true\" : \"false\");\n\t}\n\n\tif (details.len == 0)\n\t{\n\t\tappendStringInfo(&details,\n\t\t\t  _(\"Magic block has unexpected length or padding difference.\"));\n\t}\n\n\tereport(ERROR,\n\t\t\t(errmsg(\"incompatible library \\\"%s\\\": magic block mismatch\",\n\t\t\t\t\tlibname),\n\t\t\t errdetail(\"%s\", details.data)));\n}\n\n/*\n * Unload the specified dynamic-link library file, if it is loaded.\n *\n * Note: libname is expected to be an exact name for the library file.\n *\n * XXX for the moment, this is disabled, resulting in LOAD of an already-loaded\n * library always being a no-op.  We might re-enable it someday if we can\n * convince ourselves we have safe protocols for un-hooking from hook function\n * pointers, releasing custom GUC variables, and perhaps other things that\n * are definitely unsafe currently.\n */\nstatic void\ninternal_unload_library(const char *libname)\n{\n#ifdef NOT_USED\n\tDynamicFileList *file_scanner,\n\t\t\t   *prv,\n\t\t\t   *nxt;\n\tstruct stat stat_buf;\n\tPG_fini_t\tPG_fini;\n\n\t/*\n\t * We need to do stat() in order to determine whether this is the same\n\t * file as a previously loaded file; it's also handy so as to give a good\n\t * error message if bogus file name given.\n\t */\n\tif (stat(libname, &stat_buf) == -1)\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not access file \\\"%s\\\": %m\", libname)));\n\n\t/*\n\t * We have to zap all entries in the list that match on either filename or\n\t * inode, else internal_load_library() will still think it's present.\n\t */\n\tprv = NULL;\n\tfor (file_scanner = file_list; file_scanner != NULL; file_scanner = nxt)\n\t{\n\t\tnxt = file_scanner->next;\n\t\tif (strcmp(libname, file_scanner->filename) == 0 ||\n\t\t\tSAME_INODE(stat_buf, *file_scanner))\n\t\t{\n\t\t\tif (prv)\n\t\t\t\tprv->next = nxt;\n\t\t\telse\n\t\t\t\tfile_list = nxt;\n\n\t\t\t/*\n\t\t\t * If the library has a _PG_fini() function, call it.\n\t\t\t */\n\t\t\tPG_fini = (PG_fini_t) pg_dlsym(file_scanner->handle, \"_PG_fini\");\n\t\t\tif (PG_fini)\n\t\t\t\t(*PG_fini) ();\n\n\t\t\tclear_external_function_hash(file_scanner->handle);\n\t\t\tpg_dlclose(file_scanner->handle);\n\t\t\tfree((char *) file_scanner);\n\t\t\t/* prv does not change */\n\t\t}\n\t\telse\n\t\t\tprv = file_scanner;\n\t}\n#endif /* NOT_USED */\n}\n\nstatic bool\nfile_exists(const char *name)\n{\n\tstruct stat st;\n\n\tAssertArg(name != NULL);\n\n\tif (stat(name, &st) == 0)\n\t\treturn S_ISDIR(st.st_mode) ? false : true;\n\telse if (!(errno == ENOENT || errno == ENOTDIR || errno == EACCES))\n\t\tereport(ERROR,\n\t\t\t\t(errcode_for_file_access(),\n\t\t\t\t errmsg(\"could not access file \\\"%s\\\": %m\", name)));\n\n\treturn false;\n}\n\n\n/* Example format: \".so\" */\n#ifndef DLSUFFIX\n#error \"DLSUFFIX must be defined to compile this file.\"\n#endif\n\n/*\n * If name contains a slash, check if the file exists, if so return\n * the name.  Else (no slash) try to expand using search path (see\n * find_in_dynamic_libpath below); if that works, return the fully\n * expanded file name.\tIf the previous failed, append DLSUFFIX and\n * try again.  If all fails, just return the original name.\n *\n * The result will always be freshly palloc'd.\n */\nstatic char *\nexpand_dynamic_library_name(const char *name)\n{\n\tbool\t\thave_slash;\n\tchar\t   *new;\n\tchar\t   *full;\n\n\tAssertArg(name);\n\n\thave_slash = (first_dir_separator(name) != NULL);\n\n\tif (!have_slash)\n\t{\n\t\tfull = find_in_dynamic_libpath(name);\n\t\tif (full)\n\t\t\treturn full;\n\t}\n\telse\n\t{\n\t\tfull = substitute_libpath_macro(name);\n\t\tif (file_exists(full))\n\t\t\treturn full;\n\t\tpfree(full);\n\t}\n\n\tnew = palloc(strlen(name) + strlen(DLSUFFIX) + 1);\n\tstrcpy(new, name);\n\tstrcat(new, DLSUFFIX);\n\n\tif (!have_slash)\n\t{\n\t\tfull = find_in_dynamic_libpath(new);\n\t\tpfree(new);\n\t\tif (full)\n\t\t\treturn full;\n\t}\n\telse\n\t{\n\t\tfull = substitute_libpath_macro(new);\n\t\tpfree(new);\n\t\tif (file_exists(full))\n\t\t\treturn full;\n\t\tpfree(full);\n\t}\n\n\t/*\n\t * If we can't find the file, just return the string as-is. The ensuing\n\t * load attempt will fail and report a suitable message.\n\t */\n\treturn pstrdup(name);\n}\n\n/*\n * Check a restricted library name.  It must begin with \"$libdir/plugins/\"\n * and there must not be any directory separators after that (this is\n * sufficient to prevent \"..\" style attacks).\n */\nstatic void\ncheck_restricted_library_name(const char *name)\n{\n\tif (strncmp(name, \"$libdir/plugins/\", 16) != 0 ||\n\t\tfirst_dir_separator(name + 16) != NULL)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INSUFFICIENT_PRIVILEGE),\n\t\t\t\t errmsg(\"access to library \\\"%s\\\" is not allowed\",\n\t\t\t\t\t\tname)));\n}\n\n/*\n * Substitute for any macros appearing in the given string.\n * Result is always freshly palloc'd.\n */\nstatic char *\nsubstitute_libpath_macro(const char *name)\n{\n\tconst char *sep_ptr;\n\tchar\t   *ret;\n\n\tAssertArg(name != NULL);\n\n\t/* Currently, we only recognize $libdir at the start of the string */\n\tif (name[0] != '$')\n\t\treturn pstrdup(name);\n\n\tif ((sep_ptr = first_dir_separator(name)) == NULL)\n\t\tsep_ptr = name + strlen(name);\n\n\tif (strlen(\"$libdir\") != sep_ptr - name ||\n\t\tstrncmp(name, \"$libdir\", strlen(\"$libdir\")) != 0)\n\t\tereport(ERROR,\n\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t errmsg(\"invalid macro name in dynamic library path: %s\",\n\t\t\t\t\t\tname)));\n\n\tret = palloc(strlen(pkglib_path) + strlen(sep_ptr) + 1);\n\n\tstrcpy(ret, pkglib_path);\n\tstrcat(ret, sep_ptr);\n\n\treturn ret;\n}\n\n\n/*\n * Search for a file called 'basename' in the colon-separated search\n * path Dynamic_library_path.  If the file is found, the full file name\n * is returned in freshly palloc'd memory.  If the file is not found,\n * return NULL.\n */\nstatic char *\nfind_in_dynamic_libpath(const char *basename)\n{\n\tconst char *p;\n\tsize_t\t\tbaselen;\n\n\tAssertArg(basename != NULL);\n\tAssertArg(first_dir_separator(basename) == NULL);\n\tAssertState(Dynamic_library_path != NULL);\n\n\tp = Dynamic_library_path;\n\tif (strlen(p) == 0)\n\t\treturn NULL;\n\n\tbaselen = strlen(basename);\n\n\tfor (;;)\n\t{\n\t\tsize_t\t\tlen;\n\t\tchar\t   *piece;\n\t\tchar\t   *mangled;\n\t\tchar\t   *full;\n\n\t\tpiece = first_path_separator(p);\n\t\tif (piece == p)\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t\t errmsg(\"zero-length component in parameter \\\"dynamic_library_path\\\"\")));\n\n\t\tif (piece == 0)\n\t\t\tlen = strlen(p);\n\t\telse\n\t\t\tlen = piece - p;\n\n\t\tpiece = palloc(len + 1);\n\t\tstrlcpy(piece, p, len + 1);\n\n\t\tmangled = substitute_libpath_macro(piece);\n\t\tpfree(piece);\n\n\t\tcanonicalize_path(mangled);\n\n\t\t/* only absolute paths */\n\t\tif (!is_absolute_path(mangled))\n\t\t\tereport(ERROR,\n\t\t\t\t\t(errcode(ERRCODE_INVALID_NAME),\n\t\t\t\t\t errmsg(\"component in parameter \\\"dynamic_library_path\\\" is not an absolute path\")));\n\n\t\tfull = palloc(strlen(mangled) + 1 + baselen + 1);\n\t\tsprintf(full, \"%s/%s\", mangled, basename);\n\t\tpfree(mangled);\n\n\t\telog(DEBUG3, \"find_in_dynamic_libpath: trying \\\"%s\\\"\", full);\n\n\t\tif (file_exists(full))\n\t\t\treturn full;\n\n\t\tpfree(full);\n\n\t\tif (p[len] == '\\0')\n\t\t\tbreak;\n\t\telse\n\t\t\tp += len + 1;\n\t}\n\n\treturn NULL;\n}\n\n\n/*\n * Find (or create) a rendezvous variable that one dynamically\n * loaded library can use to meet up with another.\n *\n * On the first call of this function for a particular varName,\n * a \"rendezvous variable\" is created with the given name.\n * The value of the variable is a void pointer (initially set to NULL).\n * Subsequent calls with the same varName just return the address of\n * the existing variable.  Once created, a rendezvous variable lasts\n * for the life of the process.\n *\n * Dynamically loaded libraries can use rendezvous variables\n * to find each other and share information: they just need to agree\n * on the variable name and the data it will point to.\n */\nvoid\t  **\nfind_rendezvous_variable(const char *varName)\n{\n\tstatic HTAB *rendezvousHash = NULL;\n\n\trendezvousHashEntry *hentry;\n\tbool\t\tfound;\n\n\t/* Create a hashtable if we haven't already done so in this process */\n\tif (rendezvousHash == NULL)\n\t{\n\t\tHASHCTL\t\tctl;\n\n\t\tMemSet(&ctl, 0, sizeof(ctl));\n\t\tctl.keysize = NAMEDATALEN;\n\t\tctl.entrysize = sizeof(rendezvousHashEntry);\n\t\trendezvousHash = hash_create(\"Rendezvous variable hash\",\n\t\t\t\t\t\t\t\t\t 16,\n\t\t\t\t\t\t\t\t\t &ctl,\n\t\t\t\t\t\t\t\t\t HASH_ELEM);\n\t}\n\n\t/* Find or create the hashtable entry for this varName */\n\thentry = (rendezvousHashEntry *) hash_search(rendezvousHash,\n\t\t\t\t\t\t\t\t\t\t\t\t varName,\n\t\t\t\t\t\t\t\t\t\t\t\t HASH_ENTER,\n\t\t\t\t\t\t\t\t\t\t\t\t &found);\n\n\t/* Initialize to NULL if first time */\n\tif (!found)\n\t\thentry->varValue = NULL;\n\n\treturn &hentry->varValue;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/tinc/tincrepo/mpp/gpdb/tests/storage/walrepl/oom/lib/oom_malloc.c": "#include <errno.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <unistd.h>\n\n#define __USE_GNU\n#include <dlfcn.h>\n\nstatic void* (*real_malloc)(size_t) = NULL;\n\nvoid *\nmalloc(size_t size)\n{\n\tvoid *p;\n\tstruct stat path_buf;\n\tint saved_errno;\n\tint lstat_result;\n\n\tif (real_malloc == NULL)\n\t\treal_malloc = dlsym(RTLD_NEXT, \"malloc\");\n\n\tp = real_malloc(size);\n\n\tsaved_errno = errno;\n\tlstat_result = lstat(\"oom_malloc\", &path_buf);\n\terrno = saved_errno;\n\n\tif (lstat_result == 0)\n\t\treturn NULL;\n\n\treturn p;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/contrib/pg_upgrade/page.c": "/*\n *\tpage.c\n *\n *\tper-page conversion operations\n *\n *\tCopyright (c) 2010, PostgreSQL Global Development Group\n *\t$PostgreSQL: pgsql/contrib/pg_upgrade/page.c,v 1.5 2010/07/03 16:33:14 momjian Exp $\n */\n\n#include \"pg_upgrade.h\"\n\n#include \"storage/bufpage.h\"\n\n\n#ifdef PAGE_CONVERSION\n\n\nstatic const char *getPageVersion(migratorContext *ctx,\n\t\t\t   uint16 *version, const char *pathName);\nstatic pageCnvCtx *loadConverterPlugin(migratorContext *ctx,\n\t\t\t\t\tuint16 newPageVersion, uint16 oldPageVersion);\n\n\n/*\n * setupPageConverter()\n *\n *\tThis function determines the PageLayoutVersion of the old cluster and\n *\tthe PageLayoutVersion of the new cluster.  If the versions differ, this\n *\tfunction loads a converter plugin and returns a pointer to a pageCnvCtx\n *\tobject (in *result) that knows how to convert pages from the old format\n *\tto the new format.  If the versions are identical, this function just\n *\treturns a NULL pageCnvCtx pointer to indicate that page-by-page conversion\n *\tis not required.\n *\n *\tIf successful this function sets *result and returns NULL.  If an error\n *\toccurs, this function returns an error message in the form of an null-terminated\n *\tstring.\n */\nconst char *\nsetupPageConverter(migratorContext *ctx, pageCnvCtx **result)\n{\n\tuint16\t\toldPageVersion;\n\tuint16\t\tnewPageVersion;\n\tpageCnvCtx *converter;\n\tconst char *msg;\n\tchar\t\tdstName[MAXPGPATH];\n\tchar\t\tsrcName[MAXPGPATH];\n\n\tsnprintf(dstName, sizeof(dstName), \"%s/global/%u\", ctx->new.pgdata,\n\t\t\t ctx->new.pg_database_oid);\n\tsnprintf(srcName, sizeof(srcName), \"%s/global/%u\", ctx->old.pgdata,\n\t\t\t ctx->old.pg_database_oid);\n\n\tif ((msg = getPageVersion(ctx, &oldPageVersion, srcName)) != NULL)\n\t\treturn msg;\n\n\tif ((msg = getPageVersion(ctx, &newPageVersion, dstName)) != NULL)\n\t\treturn msg;\n\n\t/*\n\t * If the old cluster and new cluster use the same page layouts, then we\n\t * don't need a page converter.\n\t */\n\tif (newPageVersion == oldPageVersion)\n\t{\n\t\t*result = NULL;\n\t\treturn NULL;\n\t}\n\n\t/*\n\t * The clusters use differing page layouts, see if we can find a plugin\n\t * that knows how to convert from the old page layout to the new page\n\t * layout.\n\t */\n\n\tif ((converter = loadConverterPlugin(ctx, newPageVersion, oldPageVersion)) == NULL)\n\t\treturn \"can't find plugin to convert from old page layout to new page layout\";\n\telse\n\t{\n\t\t*result = converter;\n\t\treturn NULL;\n\t}\n}\n\n\n/*\n * getPageVersion()\n *\n *\tRetrieves the PageLayoutVersion for the given relation.\n *\n *\tReturns NULL on success (and stores the PageLayoutVersion at *version),\n *\tif an error occurs, this function returns an error message (in the form\n *\tof a null-terminated string).\n */\nstatic const char *\ngetPageVersion(migratorContext *ctx, uint16 *version, const char *pathName)\n{\n\tint\t\t\trelfd;\n\tPageHeaderData page;\n\tssize_t\t\tbytesRead;\n\n\tif ((relfd = open(pathName, O_RDONLY, 0)) < 0)\n\t\treturn \"can't open relation\";\n\n\tif ((bytesRead = read(relfd, &page, sizeof(page))) != sizeof(page))\n\t{\n\t\tclose(relfd);\n\t\treturn \"can't read page header\";\n\t}\n\n\t*version = PageGetPageLayoutVersion(&page);\n\n\tclose(relfd);\n\n\treturn NULL;\n}\n\n\n/*\n * loadConverterPlugin()\n *\n *\tThis function loads a page-converter plugin library and grabs a\n *\tpointer to each of the (interesting) functions provided by that\n *\tplugin.  The name of the plugin library is derived from the given\n *\tnewPageVersion and oldPageVersion.  If a plugin is found, this\n *\tfunction returns a pointer to a pageCnvCtx object (which will contain\n *\ta collection of plugin function pointers). If the required plugin\n *\tis not found, this function returns NULL.\n */\nstatic pageCnvCtx *\nloadConverterPlugin(migratorContext *ctx, uint16 newPageVersion, uint16 oldPageVersion)\n{\n\tchar\t\tpluginName[MAXPGPATH];\n\tvoid\t   *plugin;\n\n\t/*\n\t * Try to find a plugin that can convert pages of oldPageVersion into\n\t * pages of newPageVersion.  For example, if we oldPageVersion = 3 and\n\t * newPageVersion is 4, we search for a plugin named:\n\t * plugins/convertLayout_3_to_4.dll\n\t */\n\n\t/*\n\t * FIXME: we are searching for plugins relative to the current directory,\n\t * we should really search relative to our own executable instead.\n\t */\n\tsnprintf(pluginName, sizeof(pluginName), \"./plugins/convertLayout_%d_to_%d%s\",\n\t\t\t oldPageVersion, newPageVersion, DLSUFFIX);\n\n\tif ((plugin = pg_dlopen(pluginName)) == NULL)\n\t\treturn NULL;\n\telse\n\t{\n\t\tpageCnvCtx *result = (pageCnvCtx *) pg_malloc(ctx, sizeof(*result));\n\n\t\tresult->old.PageVersion = oldPageVersion;\n\t\tresult->new.PageVersion = newPageVersion;\n\n\t\tresult->startup = (pluginStartup) pg_dlsym(plugin, \"init\");\n\t\tresult->convertFile = (pluginConvertFile) pg_dlsym(plugin, \"convertFile\");\n\t\tresult->convertPage = (pluginConvertPage) pg_dlsym(plugin, \"convertPage\");\n\t\tresult->shutdown = (pluginShutdown) pg_dlsym(plugin, \"fini\");\n\t\tresult->pluginData = NULL;\n\n\t\t/*\n\t\t * If the plugin has exported an initializer, go ahead and invoke it.\n\t\t */\n\t\tif (result->startup)\n\t\t\tresult->startup(MIGRATOR_API_VERSION, &result->pluginVersion,\n\t\t\t\t\t\tnewPageVersion, oldPageVersion, &result->pluginData);\n\n\t\treturn result;\n\t}\n}\n\n\n\n#endif\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/bin/gpfdist/regress/data/exttab1/nation.tbl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/bin/gpfdist/regress/data/gpfdist2/lineitem.tbl.bz2",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/bin/gpfdist/regress/data/gpfdist2/lineitem.tbl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/timezone/tznames/Europe.txt",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/backend/port/dynloader/darwin.c",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/backend/utils/mb/conversion_procs/README.euc_jp",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/port/win32.ico",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/mb/expected/big5.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/mb/expected/mule_internal.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/mb/expected/euc_kr.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/mb/expected/sjis.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/mb/expected/euc_jp.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/mb/expected/euc_cn.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/mb/expected/euc_tw.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/mb/sql/big5.sql",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/mb/sql/euc_cn.sql",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/mb/sql/euc_jp.sql",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/mb/sql/mule_internal.sql",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/mb/sql/euc_tw.sql",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/mb/sql/sjis.sql",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/mb/sql/euc_kr.sql",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/regress/expected/mule_internal.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/regress/expected/euc_kr.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/regress/expected/euc_jp.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/regress/expected/euc_cn.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/regress/expected/euc_tw.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/regress/sql/euc_cn.sql",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/regress/sql/euc_jp.sql",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/regress/sql/mule_internal.sql",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/regress/sql/euc_tw.sql",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/regress/sql/euc_kr.sql",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/tinc/tincrepo/mpp/gpdb/lib/datagen/query_execution_db/compressed_data/mpp18457.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/locale/gr_GR.ISO8859-7/test-gr-sort.in",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/locale/gr_GR.ISO8859-7/test-gr-select.sql.in",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/locale/gr_GR.ISO8859-7/test-gr.sql.in",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/locale/gr_GR.ISO8859-7/expected/test-gr-sort.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/locale/gr_GR.ISO8859-7/expected/gr-ctype.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/locale/gr_GR.ISO8859-7/expected/test-gr-varchar.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/locale/gr_GR.ISO8859-7/expected/test-gr-char.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/locale/gr_GR.ISO8859-7/expected/test-gr-text.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/locale/gr_GR.ISO8859-7/expected/test-gr-select.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/locale/koi8-to-win1251/test-koi8.sql.in",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/locale/koi8-to-win1251/test-koi8-sort.in",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/locale/koi8-to-win1251/test-koi8-select.sql.in",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/locale/koi8-to-win1251/expected/test-koi8-varchar.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/locale/koi8-to-win1251/expected/test-koi8-sort.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/locale/koi8-to-win1251/expected/test-koi8-text.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/locale/koi8-to-win1251/expected/test-koi8-select.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/locale/koi8-to-win1251/expected/test-koi8-char.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/locale/de_DE.ISO8859-1/test-de-sort.in",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/locale/de_DE.ISO8859-1/test-de.sql.in",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/locale/de_DE.ISO8859-1/test-de-upper.sql.in",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/locale/de_DE.ISO8859-1/test-de-select.sql.in",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/locale/de_DE.ISO8859-1/expected/test-de-upper-char.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/locale/de_DE.ISO8859-1/expected/test-de-select.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/locale/de_DE.ISO8859-1/expected/test-de-text.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/locale/de_DE.ISO8859-1/expected/de-ctype.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/locale/de_DE.ISO8859-1/expected/test-de-sort.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/locale/de_DE.ISO8859-1/expected/test-de-upper-text.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/locale/de_DE.ISO8859-1/expected/test-de-upper-varchar.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/locale/de_DE.ISO8859-1/expected/test-de-char.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/locale/de_DE.ISO8859-1/expected/test-de-varchar.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/locale/koi8-r/test-koi8.sql.in",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/locale/koi8-r/test-koi8-sort.in",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/locale/koi8-r/test-koi8-select.sql.in",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/locale/koi8-r/expected/test-koi8-varchar.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/locale/koi8-r/expected/koi8-ctype.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/locale/koi8-r/expected/test-koi8-sort.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/locale/koi8-r/expected/test-koi8-text.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/locale/koi8-r/expected/test-koi8-select.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/test/locale/koi8-r/expected/test-koi8-char.sql.out",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/tools/backend/flow.gif",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/src/tools/vagrant/pictures/gpdb_processes.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/markdown/cloud/graphics/gcp-disk-rates.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/markdown/pxf/graphics/pxfarch.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/markdown/pxf/graphics/pxfreadwrite.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/book/master_middleman/source/images/favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/best_practices/graphics/group-mirrors.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/best_practices/graphics/block-mirrors-4x8.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/best_practices/graphics/spread-mirrors.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/ref_guide/graphics/mapreducejob.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/admin_guide/graphics/recovermatrix.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/admin_guide/graphics/gp_query_priority2.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/admin_guide/graphics/resource_queues.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/admin_guide/graphics/slice_plan.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/admin_guide/graphics/queryscreen.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/admin_guide/graphics/gangs.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/admin_guide/graphics/parallel_plan.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/admin_guide/graphics/gp_restore.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/admin_guide/graphics/kerb-ms-ad-attribute-editor.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/admin_guide/graphics/pg_admin_III_callout.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/admin_guide/graphics/spread-mirroring.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/admin_guide/graphics/highlevel_arch.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/admin_guide/graphics/kerb-ms-ad-new-object-2.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/admin_guide/graphics/resgroupmem.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/admin_guide/graphics/ext_tables_multinic.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/admin_guide/graphics/gptransfer-slow.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/admin_guide/graphics/kerb-aginity-config.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/admin_guide/graphics/memory.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/admin_guide/graphics/pg3_queryplan.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/admin_guide/graphics/kerb-ms-ad-new-object.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/admin_guide/graphics/ext_tables.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/admin_guide/graphics/kerb-odbc-config.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/admin_guide/graphics/resource_queue_examp.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/admin_guide/graphics/targeted_dispatch.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/admin_guide/graphics/gp_dump.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/admin_guide/graphics/green-checkbox.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/admin_guide/graphics/gp_query_priority1.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/admin_guide/graphics/nonpar_restore.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/admin_guide/graphics/partitions.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/admin_guide/graphics/group-mirroring.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/admin_guide/graphics/kerb-pgadmin-config.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/admin_guide/graphics/standby_master.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/admin_guide/graphics/cc_arch_gpdb.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/admin_guide/graphics/02-pipeline.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/admin_guide/graphics/ext_tables_hadoop.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/admin_guide/graphics/gptransfer-fast.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/admin_guide/graphics/ext-tables-xml.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/admin_guide/graphics/piv-opt.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/admin_guide/graphics/03-gpload-files.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/recovermatrix.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/gp_query_priority2.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/resource_queues.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/slice_plan.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/gangs.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/parallel_plan.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/gp_restore.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/kerb-ms-ad-attribute-editor.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/spread-mirroring.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/highlevel_arch.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/kerb-ms-ad-new-object-2.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/mapreducejob.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/ext_tables_multinic.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/gptransfer-slow.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/kerb-aginity-config.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/memory.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/mirrorsegs.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/kerb-ms-ad-new-object.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/ext_tables.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/kerb-odbc-config.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/resource_queue_examp.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/targeted_dispatch.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/gp_dump.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/green-checkbox.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/gp_query_priority1.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/nonpar_restore.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/partitions.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/group-mirroring.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/standby_master.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/cc_arch_gpdb.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/02-pipeline.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/gptransfer-fast.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/ext-tables-xml.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/piv-opt.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/03-gpload-files.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/source_files/spread-mirroring.graffle",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/source_files/piv-opt.pptx",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/source_files/slice_plan.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/source_files/sne_arch.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/source_files/multi_switch_arch.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/source_files/build_gp_graphics.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/source_files/mapreducejob.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/source_files/hardware_stack.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/source_files/gp_dump.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/source_files/resource_queues.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/source_files/partitions.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/source_files/ext_tables.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/source_files/group-mirroring.graffle",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/source_files/highlevel_arch.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/source_files/mirrorsegs.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/source_files/standby_master.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/source_files/multi_nic_arch.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/source_files/disk_raid.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/source_files/physical_storage.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/source_files/star_schema.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/source_files/gp_restore.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/source_files/targeted_plan.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/source_files/recovermatrix.graffle",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/source_files/gp_graphics.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/source_files/ext_tables_multinic.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/source_files/gangs.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/source_files/rack_diagrams.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/source_files/mapred_flow.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/source_files/parallel_plan.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/source_files/nonpar_restore.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/source_files/gp_query_priority.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/source_files/monitor_arch.vsd",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/source_files/load-xml.graffle/data.plist",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpdb-doc/dita/graphics/source_files/memory.graffle/data.plist",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpAux/releng/images/logo-greenplum.png",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpAux/extensions/gphdfs/src/test/data/decimal.pq",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpAux/extensions/gphdfs/src/test/data/short.parquet",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpAux/extensions/gphdfs/src/test/data/short.avro",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpAux/extensions/gphdfs/src/test/data/alertlog.avro",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpAux/extensions/gphdfs/regression/integrate/data/optional_parquet.parquet",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpAux/client/install/src/windows/Binary/info.ico",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpAux/client/install/src/windows/Binary/exclamic.ico",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpAux/client/install/src/windows/Binary/Up.ico",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpAux/client/install/src/windows/Binary/removico.ico",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpAux/client/install/src/windows/Binary/completi.ico",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpAux/client/install/src/windows/Binary/New.ico",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpAux/client/install/src/windows/Binary/bannrbmp.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpAux/client/install/src/windows/Binary/Thumbs.db",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpAux/client/install/src/windows/Binary/custicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpAux/client/install/src/windows/Binary/repairic.ico",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpAux/client/install/src/windows/Binary/insticon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpAux/client/install/src/windows/Binary/dlgbmp.bmp",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/contrib/formatter_fixedwidth/data/fixedwidth_small_correct.tbl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/contrib/pg_upgrade/test/upgrade-test-cluster-4.3.tar.xz",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/contrib/isn/isn.h",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/contrib/isn/isn.c",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/contrib/pgrowlocks/README.pgrowlocks.euc_jp",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/contrib/xlogdump/test/xlog.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/contrib/xlogdump/doc/xlogdump.1",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/doc/src/sgml/ref/create_type.sgml",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/doc/src/sgml/ref/drop_external_table.sgml",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/doc/src/sgml/ref/create_external_table.sgml",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpMgmt/demo/gppkg/sample-sources.tar.gz",
        "/tmp/vanessa/spack-stage/spack-stage-gpdb-5.24.0-lvixare7cvc2rtxmuumukov33vsxnpv3/spack-src/gpMgmt/test/behave/mgmt_utils/steps/data/sample.gppkg"
    ],
    "total_files": 13904
}