{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/src/SWI-Prolog.h": "/*  Part of SWI-Prolog\n\n    Author:        Jan Wielemaker\n    E-mail:        J.Wielemaker@vu.nl\n    WWW:           http://www.swi-prolog.org\n    Copyright (c)  2008-2017, University of Amsterdam\n                              VU University Amsterdam\n    All rights reserved.\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n    1. Redistributions of source code must retain the above copyright\n       notice, this list of conditions and the following disclaimer.\n\n    2. Redistributions in binary form must reproduce the above copyright\n       notice, this list of conditions and the following disclaimer in\n       the documentation and/or other materials provided with the\n       distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n    COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n    ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n    POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#ifndef _FLI_H_INCLUDED\n#define _FLI_H_INCLUDED\n\n#ifndef __SWI_PROLOG__\t/* use this to switch on Prolog dialect */\n#define __SWI_PROLOG__\t/* normally defined by the swipl-ld compiler driver */\n#endif\n\n#ifndef __WINDOWS__\n#if defined(_MSC_VER) || defined(__MINGW32__)\n#define __WINDOWS__ 1\n#endif\n#endif\n\n#include <stdarg.h>\n#include <stdlib.h>\t\t\t/* get size_t */\n#include <stddef.h>\n#ifdef _MSC_VER\ntypedef __int64 int64_t;\ntypedef unsigned __int64 uint64_t;\n#if (_MSC_VER < 1300)\ntypedef long intptr_t;\ntypedef unsigned long uintptr_t;\n#endif\n#else\n#include <inttypes.h>\t\t\t/* more portable than stdint.h */\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* PLVERSION: 10000 * <Major> + 100 * <Minor> + <Patch> */\n/* PLVERSION_TAG: a string, normally \"\", but for example \"rc1\" */\n\n#ifndef PLVERSION\n#define PLVERSION 80003\n#endif\n#ifndef PLVERSION_TAG\n#define PLVERSION_TAG \"\"\n#endif\n\n\n\t\t /*******************************\n\t\t *\t       EXPORT\t\t*\n\t\t *******************************/\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nTraditional and ELF-based Unix systems  don't   need  all this, but COFF\nbased systems need  to  import  and   export  symbols  explicitely  from\nexecutables and shared objects (DLL). On some systems (e.g. AIX) this is\nachieved using import/export files, on Windows   this  is achieved using\nspecial  declarations  on  exported  symbols.  So,  a  symbol  is  local\n(static), shared between the objects building   an executable or DLL (no\nspecial declaration) or exported from the executable or DLL.\n\nBoth using native Microsoft MSVC as well   as recent Cygwin (tested 1.1)\ncompilers support __declspec(...) for exporting symbols.\n\nAs SWI-Prolog.h can be included seperately or together with this file we\nduplicated this stuff.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n#ifndef _PL_EXPORT_DONE\n#define _PL_EXPORT_DONE\n\n#if (defined(__WINDOWS__) || defined(__CYGWIN__)) && !defined(__LCC__)\n#define HAVE_DECLSPEC\n#endif\n\n#ifdef HAVE_DECLSPEC\n# ifdef PL_KERNEL\n#define PL_EXPORT(type)\t\t__declspec(dllexport) type\n#define PL_EXPORT_DATA(type)\t__declspec(dllexport) type\n#define install_t\t\tvoid\n# else\n#  ifdef __BORLANDC__\n#define PL_EXPORT(type)\t\ttype _stdcall\n#define PL_EXPORT_DATA(type)\textern type\n#  else\n#   ifdef __MINGW32__\n#define PL_EXPORT(type)\t\textern type\n#define PL_EXPORT_DATA(type)\textern type\n#   else\n#define PL_EXPORT(type)\t\textern type\n#define PL_EXPORT_DATA(type)\t__declspec(dllimport) type\n#   endif\n#  endif\n#define install_t\t\t__declspec(dllexport) void\n# endif\n#else /*HAVE_DECLSPEC*/\n#define PL_EXPORT(type)\t\textern type\n#define PL_EXPORT_DATA(type)\textern type\n#define install_t\t\tvoid\n#endif /*HAVE_DECLSPEC*/\n#endif /*_PL_EXPORT_DONE*/\n\n\n\t\t /*******************************\n\t\t *\t  GCC ATTRIBUTES\t*\n\t\t *******************************/\n\n#if __GNUC__ >= 4\n#define WUNUSED __attribute__((warn_unused_result))\n#else\n#define WUNUSED\n#endif\n\n\n\t\t /*******************************\n\t\t *\t       TYPES\t\t*\n\t\t *******************************/\n\n#ifdef _PL_INCLUDE_H\ntypedef Module\t\tmodule_t;\t/* a module */\ntypedef Procedure\tpredicate_t;\t/* a predicate handle */\ntypedef Record\t\trecord_t;\t/* handle to a recorded term */\ntypedef struct PL_local_data *PL_engine_t; /* handle to a engine */\n#else\ntypedef\tuintptr_t\tatom_t;\t\t/* Prolog atom */\ntypedef uintptr_t\tfunctor_t;\t/* Name/arity pair */\ntypedef void *\t\tmodule_t;\t/* Prolog module */\ntypedef void *\t\tpredicate_t;\t/* Prolog procedure */\ntypedef void *\t\trecord_t;\t/* Prolog recorded term */\n#ifndef PL_HAVE_TERM_T\n#define PL_HAVE_TERM_T\ntypedef uintptr_t\tterm_t;\t\t/* opaque term handle */\n#endif\ntypedef uintptr_t\tqid_t;\t\t/* opaque query handle */\ntypedef uintptr_t\tPL_fid_t;\t/* opaque foreign context handle */\ntypedef void *\t\tcontrol_t;\t/* non-deterministic control arg */\ntypedef void *\t\tPL_engine_t;\t/* opaque engine handle */\n#endif\ntypedef uintptr_t\tPL_atomic_t;\t/* same a word */\ntypedef uintptr_t\tforeign_t;\t/* return type of foreign functions */\ntypedef wchar_t\t        pl_wchar_t;\t/* Prolog wide character */\n#ifdef __cplusplus\ntypedef void *\t\tpl_function_t;      /* pass function as void* */\n#else\ntypedef foreign_t\t(*pl_function_t)(); /* foreign language functions */\n#endif\n\n#ifndef NORETURN\n#define NORETURN\n#endif\n\n#define fid_t PL_fid_t\t\t\t/* avoid AIX name-clash */\n\n\t\t\t\t\t/* values for PL_get_term_value() */\ntypedef union\n{ int64_t i;\t\t\t\t/* PL_INTEGER */\n  double f;\t\t\t\t/* PL_FLOAT */\n  char * s;\t\t\t\t/* PL_STRING */\n  atom_t a;\t\t\t\t/* PL_ATOM */\n  struct\t\t\t\t/* PL_TERM */\n  { atom_t name;\n    size_t arity;\n  } t;\n} term_value_t;\n\n#ifndef TRUE\n#define TRUE\t(1)\n#define FALSE\t(0)\n#endif\n\n\t\t /*******************************\n\t\t *      TERM-TYPE CONSTANTS\t*\n\t\t *******************************/\n\t\t\t\t\t/* PL_unify_term() arguments */\n#define\tPL_VARIABLE\t (1)\t\t/* nothing */\n#define PL_ATOM\t\t (2)\t\t/* const char * */\n#define PL_INTEGER\t (3)\t\t/* int */\n#define PL_FLOAT\t (4)\t\t/* double */\n#define PL_STRING\t (5)\t\t/* const char * */\n#define PL_TERM\t\t (6)\n\n#define PL_NIL\t\t (7)\t\t/* The constant [] */\n#define PL_BLOB\t\t (8)\t\t/* non-atom blob */\n#define PL_LIST_PAIR\t (9)\t\t/* [_|_] term */\n\n\t\t\t\t\t/* PL_unify_term() */\n#define PL_FUNCTOR\t (10)\t\t/* functor_t, arg ... */\n#define PL_LIST\t\t (11)\t\t/* length, arg ... */\n#define PL_CHARS\t (12)\t\t/* const char * */\n#define PL_POINTER\t (13)\t\t/* void * */\n\t\t\t\t\t/* PlArg::PlArg(text, type) */\n#define PL_CODE_LIST\t (14)\t\t/* [ascii...] */\n#define PL_CHAR_LIST\t (15)\t\t/* [h,e,l,l,o] */\n#define PL_BOOL\t\t (16)\t\t/* PL_set_prolog_flag() */\n#define PL_FUNCTOR_CHARS (17)\t\t/* PL_unify_term() */\n#define _PL_PREDICATE_INDICATOR (18)\t/* predicate_t (Procedure) */\n#define PL_SHORT\t (19)\t\t/* short */\n#define PL_INT\t\t (20)\t\t/* int */\n#define PL_LONG\t\t (21)\t\t/* long */\n#define PL_DOUBLE\t (22)\t\t/* double */\n#define PL_NCHARS\t (23)\t\t/* size_t, const char * */\n#define PL_UTF8_CHARS\t (24)\t\t/* const char * */\n#define PL_UTF8_STRING\t (25)\t\t/* const char * */\n#define PL_INT64\t (26)\t\t/* int64_t */\n#define PL_NUTF8_CHARS\t (27)\t\t/* size_t, const char * */\n#define PL_NUTF8_CODES\t (29)\t\t/* size_t, const char * */\n#define PL_NUTF8_STRING\t (30)\t\t/* size_t, const char * */\n#define PL_NWCHARS\t (31)\t\t/* size_t, const wchar_t * */\n#define PL_NWCODES\t (32)\t\t/* size_t, const wchar_t * */\n#define PL_NWSTRING\t (33)\t\t/* size_t, const wchar_t * */\n#define PL_MBCHARS\t (34)\t\t/* const char * */\n#define PL_MBCODES\t (35)\t\t/* const char * */\n#define PL_MBSTRING\t (36)\t\t/* const char * */\n#define PL_INTPTR\t (37)\t\t/* intptr_t */\n#define PL_CHAR\t\t (38)\t\t/* int */\n#define PL_CODE\t\t (39)\t\t/* int */\n#define PL_BYTE\t\t (40)\t\t/* int */\n\t\t\t\t\t/* PL_skip_list() */\n#define PL_PARTIAL_LIST\t (41)\t\t/* a partial list */\n#define PL_CYCLIC_TERM\t (42)\t\t/* a cyclic list/term */\n#define PL_NOT_A_LIST\t (43)\t\t/* Object is not a list */\n\t\t\t\t\t/* dicts */\n#define PL_DICT\t\t (44)\n\n/* Or'ed flags for PL_set_prolog_flag() */\n/* MUST fit in a short int! */\n#define FF_READONLY\t 0x1000\t\t/* Read-only prolog flag */\n#define FF_KEEP\t\t 0x2000\t\t/* keep prolog flag if already set */\n#define FF_NOCREATE\t 0x4000\t\t/* Fail if flag is non-existent */\n#define FF_FORCE\t 0x8000\t\t/* Force setting, overwrite READONLY */\n#define FF_MASK\t\t 0xf000\n\n\n\t\t/********************************\n\t\t*    DETERMINISTIC CALL/RETURN  *\n\t\t*********************************/\n\n#define\tPL_succeed\treturn TRUE\t/* succeed deterministically */\n#define PL_fail\t\treturn FALSE\t/* fail */\n\n\n\t\t/********************************\n\t\t* NON-DETERMINISTIC CALL/RETURN *\n\t\t*********************************/\n\n/*  Note 1: Non-deterministic foreign functions may also use the deterministic\n    return methods PL_succeed and PL_fail.\n\n    Note 2: The argument to PL_retry is a sizeof(ptr)-2 bits signed\n    integer (use type intptr_t).\n*/\n\n#define PL_FIRST_CALL\t\t(0)\n#define PL_CUTTED\t\t(1)\t/* deprecated */\n#define PL_PRUNED\t\t(1)\n#define PL_REDO\t\t\t(2)\n\n#define PL_retry(n)\t\treturn _PL_retry(n)\n#define PL_retry_address(a)\treturn _PL_retry_address(a)\n\nPL_EXPORT(foreign_t)\t_PL_retry(intptr_t);\nPL_EXPORT(foreign_t)\t_PL_retry_address(void *);\nPL_EXPORT(int)\t\tPL_foreign_control(control_t);\nPL_EXPORT(intptr_t)\tPL_foreign_context(control_t);\nPL_EXPORT(void *)\tPL_foreign_context_address(control_t);\nPL_EXPORT(predicate_t)\tPL_foreign_context_predicate(control_t);\n\n\n\t\t/********************************\n\t\t*      REGISTERING FOREIGNS     *\n\t\t*********************************/\n\ntypedef struct PL_extension\n{ const char   *predicate_name;\t\t/* Name of the predicate */\n  short\t\tarity;\t\t\t/* Arity of the predicate */\n  pl_function_t\tfunction;\t\t/* Implementing functions */\n  short\t\tflags;\t\t\t/* Or of PL_FA_... */\n} PL_extension;\n\n#define PL_FA_NOTRACE\t\t(0x01)\t/* foreign cannot be traced */\n#define PL_FA_TRANSPARENT\t(0x02)\t/* foreign is module transparent */\n#define PL_FA_NONDETERMINISTIC\t(0x04)\t/* foreign is non-deterministic */\n#define PL_FA_VARARGS\t\t(0x08)\t/* call using t0, ac, ctx */\n#define PL_FA_CREF\t\t(0x10)\t/* Internal: has clause-reference */\n#define PL_FA_ISO\t\t(0x20)\t/* Internal: ISO core predicate */\n#define PL_FA_META\t\t(0x40)\t/* Additional meta-argument spec */\n\nextern\t\t\tPL_extension PL_extensions[]; /* not Win32! */\nPL_EXPORT(void)\t\tPL_register_extensions(const PL_extension *e);\nPL_EXPORT(void)\t\tPL_register_extensions_in_module(const char *module, const PL_extension *e);\nPL_EXPORT(int)\t\tPL_register_foreign(const char *name, int arity,\n\t\t\t\t\t    pl_function_t func,\n\t\t\t\t\t    int flags, ...);\nPL_EXPORT(int)\t\tPL_register_foreign_in_module(const char *module,\n\t\t\t\t\t\t      const char *name, int arity,\n\t\t\t\t\t\t      pl_function_t func,\n\t\t\t\t\t\t      int flags, ...);\nPL_EXPORT(void)\t\tPL_load_extensions(const PL_extension *e);\n\n\t\t /*******************************\n\t\t *\t      LICENSE\t\t*\n\t\t *******************************/\n\nPL_EXPORT(void)\t\tPL_license(const char *license, const char *module);\n\n\t\t/********************************\n\t\t*            MODULES            *\n\t\t*********************************/\n\nPL_EXPORT(module_t)\tPL_context(void);\nPL_EXPORT(atom_t)\tPL_module_name(module_t module);\nPL_EXPORT(module_t)\tPL_new_module(atom_t name);\nPL_EXPORT(int)\t\tPL_strip_module(term_t in, module_t *m, term_t out) WUNUSED;\n\n\t\t /*******************************\n\t\t *\t     CONSTANTS\t\t*\n\t\t *******************************/\n\nPL_EXPORT(const atom_t) *_PL_atoms(void); /* base of reserved (meta-)atoms */\n#ifndef PL_KERNEL\n#define ATOM_nil\t(_PL_atoms()[0]) /* `[]` */\n#define ATOM_dot\t(_PL_atoms()[1]) /* `.` */\n#endif /*PL_KERNEL*/\n\n\n\t\t /*******************************\n\t\t *\t     CALL-BACK\t\t*\n\t\t *******************************/\n\n#ifdef PL_KERNEL\n#define PL_Q_DEBUG\t\t0x0001\t/* = TRUE for backward compatibility */\n#endif\n#define PL_Q_NORMAL\t\t0x0002\t/* normal usage */\n#define PL_Q_NODEBUG\t\t0x0004\t/* use this one */\n#define PL_Q_CATCH_EXCEPTION\t0x0008\t/* handle exceptions in C */\n#define PL_Q_PASS_EXCEPTION\t0x0010\t/* pass to parent environment */\n#define PL_Q_ALLOW_YIELD\t0x0020\t/* Support I_YIELD */\n#define PL_Q_EXT_STATUS\t\t0x0040\t/* Return extended status */\n#ifdef PL_KERNEL\n#define PL_Q_DETERMINISTIC\t0x0100\t/* call was deterministic */\n#endif\n\n\t\t\t\t\t/* PL_Q_EXT_STATUS return codes */\n#define PL_S_EXCEPTION\t       -1\t/* Query raised exception */\n#define PL_S_FALSE\t\t0\t/* Query failed */\n#define PL_S_TRUE\t\t1\t/* Query succeeded with choicepoint */\n#define PL_S_LAST\t\t2\t/* Query succeeded without CP */\n\n\n\t\t\t/* Foreign context frames */\nPL_EXPORT(fid_t)\tPL_open_foreign_frame(void);\nPL_EXPORT(void)\t\tPL_rewind_foreign_frame(fid_t cid);\nPL_EXPORT(void)\t\tPL_close_foreign_frame(fid_t cid);\nPL_EXPORT(void)\t\tPL_discard_foreign_frame(fid_t cid);\n\n\t\t\t/* Finding predicates */\nPL_EXPORT(predicate_t)\tPL_pred(functor_t f, module_t m);\nPL_EXPORT(predicate_t)\tPL_predicate(const char *name, int arity,\n\t\t\t\t     const char* module);\nPL_EXPORT(int)\t\tPL_predicate_info(predicate_t pred,\n\t\t\t\t\t  atom_t *name, size_t *arity,\n\t\t\t\t\t  module_t *module);\n\n\t\t\t/* Call-back */\nPL_EXPORT(qid_t)\tPL_open_query(module_t m, int flags,\n\t\t\t\t      predicate_t pred, term_t t0);\nPL_EXPORT(int)\t\tPL_next_solution(qid_t qid) WUNUSED;\nPL_EXPORT(int)\t\tPL_close_query(qid_t qid);\nPL_EXPORT(int)\t\tPL_cut_query(qid_t qid);\nPL_EXPORT(qid_t)\tPL_current_query(void);\n\n\t\t\t/* Simplified (but less flexible) call-back */\nPL_EXPORT(int)\t\tPL_call(term_t t, module_t m);\nPL_EXPORT(int)\t\tPL_call_predicate(module_t m, int debug,\n\t\t\t\t\t  predicate_t pred, term_t t0);\n\t\t\t/* Handling exceptions */\nPL_EXPORT(term_t)\tPL_exception(qid_t qid);\nPL_EXPORT(int)\t\tPL_raise_exception(term_t exception);\nPL_EXPORT(int)\t\tPL_throw(term_t exception);\nPL_EXPORT(void)\t\tPL_clear_exception(void);\n\t\t\t/* Engine-based coroutining */\nPL_EXPORT(term_t)\tPL_yielded(qid_t qid);\n\n\n\t\t /*******************************\n\t\t *        TERM-REFERENCES\t*\n\t\t *******************************/\n\n\t\t\t/* Creating and destroying term-refs */\nPL_EXPORT(term_t)\tPL_new_term_refs(int n);\nPL_EXPORT(term_t)\tPL_new_term_ref(void);\nPL_EXPORT(term_t)\tPL_copy_term_ref(term_t from);\nPL_EXPORT(void)\t\tPL_reset_term_refs(term_t r);\n\n\t\t\t/* Constants */\nPL_EXPORT(atom_t)\tPL_new_atom(const char *s);\nPL_EXPORT(atom_t)\tPL_new_atom_nchars(size_t len, const char *s);\nPL_EXPORT(atom_t)\tPL_new_atom_wchars(size_t len, const pl_wchar_t *s);\nPL_EXPORT(atom_t)\tPL_new_atom_mbchars(int rep, size_t len, const char *s);\nPL_EXPORT(const char *)\tPL_atom_chars(atom_t a);\nPL_EXPORT(const char *)\tPL_atom_nchars(atom_t a, size_t *len);\nPL_EXPORT(const wchar_t *)\tPL_atom_wchars(atom_t a, size_t *len);\n#ifndef O_DEBUG_ATOMGC\nPL_EXPORT(void)\t\tPL_register_atom(atom_t a);\nPL_EXPORT(void)\t\tPL_unregister_atom(atom_t a);\n#endif\nPL_EXPORT(functor_t)\tPL_new_functor_sz(atom_t f, size_t a);\nPL_EXPORT(functor_t)\tPL_new_functor(atom_t f, int a);\nPL_EXPORT(atom_t)\tPL_functor_name(functor_t f);\nPL_EXPORT(int)\t\tPL_functor_arity(functor_t f);\nPL_EXPORT(size_t)\tPL_functor_arity_sz(functor_t f);\n\n\t\t\t/* Get C-values from Prolog terms */\nPL_EXPORT(int)\t\tPL_get_atom(term_t t, atom_t *a) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_bool(term_t t, int *value) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_atom_chars(term_t t, char **a) WUNUSED;\n#define PL_get_string_chars(t, s, l) PL_get_string(t,s,l)\n\t\t\t\t\t/* PL_get_string() is deprecated */\nPL_EXPORT(int)\t\tPL_get_string(term_t t, char **s, size_t *len) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_chars(term_t t, char **s, unsigned int flags) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_list_chars(term_t l, char **s,\n\t\t\t\t\t  unsigned int flags) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_atom_nchars(term_t t, size_t *len, char **a) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_list_nchars(term_t l,\n\t\t\t\t\t   size_t *len, char **s,\n\t\t\t\t\t   unsigned int flags) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_nchars(term_t t,\n\t\t\t\t      size_t *len, char **s,\n\t\t\t\t      unsigned int flags) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_integer(term_t t, int *i) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_long(term_t t, long *i) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_intptr(term_t t, intptr_t *i) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_pointer(term_t t, void **ptr) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_float(term_t t, double *f) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_functor(term_t t, functor_t *f) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_name_arity_sz(term_t t, atom_t *name,\n\t\t\t\t\t     size_t *arity) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_compound_name_arity_sz(term_t t, atom_t *name,\n\t\t\t\t\t\t      size_t *arity) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_name_arity(term_t t, atom_t *name,\n\t\t\t\t\t  int *arity) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_compound_name_arity(term_t t, atom_t *name,\n\t\t\t\t\t\t   int *arity) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_module(term_t t, module_t *module) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_arg_sz(size_t index, term_t t, term_t a) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_arg(int index, term_t t, term_t a) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_list(term_t l, term_t h, term_t t) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_head(term_t l, term_t h) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_tail(term_t l, term_t t) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_nil(term_t l) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_term_value(term_t t, term_value_t *v) WUNUSED;\nPL_EXPORT(char *)\tPL_quote(int chr, const char *data);\n\n\t\t\t/* Verify types */\nPL_EXPORT(int)\t\tPL_term_type(term_t t);\nPL_EXPORT(int)\t\tPL_is_variable(term_t t);\nPL_EXPORT(int)\t\tPL_is_ground(term_t t);\nPL_EXPORT(int)\t\tPL_is_atom(term_t t);\nPL_EXPORT(int)\t\tPL_is_integer(term_t t);\nPL_EXPORT(int)\t\tPL_is_string(term_t t);\nPL_EXPORT(int)\t\tPL_is_float(term_t t);\nPL_EXPORT(int)\t\tPL_is_rational(term_t t);\nPL_EXPORT(int)\t\tPL_is_compound(term_t t);\nPL_EXPORT(int)\t\tPL_is_callable(term_t t);\nPL_EXPORT(int)\t\tPL_is_functor(term_t t, functor_t f);\nPL_EXPORT(int)\t\tPL_is_list(term_t t);\nPL_EXPORT(int)\t\tPL_is_pair(term_t t);\nPL_EXPORT(int)\t\tPL_is_atomic(term_t t);\nPL_EXPORT(int)\t\tPL_is_number(term_t t);\nPL_EXPORT(int)\t\tPL_is_acyclic(term_t t);\n\n\t\t\t/* Assign to term-references */\nPL_EXPORT(int)\t\tPL_put_variable(term_t t);\nPL_EXPORT(int)\t\tPL_put_atom(term_t t, atom_t a);\nPL_EXPORT(int)\t\tPL_put_bool(term_t t, int val);\nPL_EXPORT(int)\t\tPL_put_atom_chars(term_t t, const char *chars);\nPL_EXPORT(int)\t\tPL_put_string_chars(term_t t, const char *chars) WUNUSED;\nPL_EXPORT(int)\t\tPL_put_chars(term_t t, int flags,\n\t\t\t\t     size_t len, const char *chars) WUNUSED;\nPL_EXPORT(int)\t\tPL_put_list_chars(term_t t, const char *chars) WUNUSED;\nPL_EXPORT(int)\t\tPL_put_list_codes(term_t t, const char *chars) WUNUSED;\nPL_EXPORT(int)\t\tPL_put_atom_nchars(term_t t, size_t l, const char *chars);\nPL_EXPORT(int)\t\tPL_put_string_nchars(term_t t, size_t len, const char *chars) WUNUSED;\nPL_EXPORT(int)\t\tPL_put_list_nchars(term_t t, size_t l, const char *chars) WUNUSED;\nPL_EXPORT(int)\t\tPL_put_list_ncodes(term_t t, size_t l, const char *chars) WUNUSED;\nPL_EXPORT(int)\t\tPL_put_integer(term_t t, long i) WUNUSED;\nPL_EXPORT(int)\t\tPL_put_pointer(term_t t, void *ptr) WUNUSED;\nPL_EXPORT(int)\t\tPL_put_float(term_t t, double f) WUNUSED;\nPL_EXPORT(int)\t\tPL_put_functor(term_t t, functor_t functor) WUNUSED;\nPL_EXPORT(int)\t\tPL_put_list(term_t l) WUNUSED;\nPL_EXPORT(int)\t\tPL_put_nil(term_t l);\nPL_EXPORT(int)\t\tPL_put_term(term_t t1, term_t t2);\n\n\t\t\t/* construct a functor or list-cell */\nPL_EXPORT(int)\t\tPL_cons_functor(term_t h, functor_t f, ...) WUNUSED;\nPL_EXPORT(int)\t\tPL_cons_functor_v(term_t h, functor_t fd, term_t a0) WUNUSED;\nPL_EXPORT(int)\t\tPL_cons_list(term_t l, term_t h, term_t t) WUNUSED;\n\n\t\t\t/* Unify term-references */\nPL_EXPORT(int)\t\tPL_unify(term_t t1, term_t t2) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_atom(term_t t, atom_t a) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_atom_chars(term_t t, const char *chars) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_list_chars(term_t t, const char *chars) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_list_codes(term_t t, const char *chars) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_string_chars(term_t t, const char *chars) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_atom_nchars(term_t t, size_t l, const char *s) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_list_ncodes(term_t t, size_t l, const char *s) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_list_nchars(term_t t, size_t l, const char *s) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_string_nchars(term_t t,\n\t\t\t\t\t       size_t len,\n\t\t\t\t\t       const char *chars) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_bool(term_t t, int n) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_integer(term_t t, intptr_t n) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_float(term_t t, double f) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_pointer(term_t t, void *ptr) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_functor(term_t t, functor_t f) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_compound(term_t t, functor_t f) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_list(term_t l, term_t h, term_t t) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_nil(term_t l) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_arg_sz(size_t index, term_t t, term_t a) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_arg(int index, term_t t, term_t a) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_term(term_t t, ...) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_chars(term_t t, int flags,\n\t\t\t\t       size_t len, const char *s) WUNUSED;\n\n\t\t /*******************************\n\t\t *\t       LISTS\t\t*\n\t\t *******************************/\n\nPL_EXPORT(int)\t\tPL_skip_list(term_t list, term_t tail, size_t *len);\n\n\n\t\t /*******************************\n\t\t *    WIDE CHARACTER VERSIONS\t*\n\t\t *******************************/\n\nPL_EXPORT(int)\t\tPL_unify_wchars(term_t t, int type,\n\t\t\t\t\tsize_t len, const pl_wchar_t *s) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_wchars_diff(term_t t, term_t tail, int type,\n\t\t\t\t\tsize_t len, const pl_wchar_t *s) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_wchars(term_t l,\n\t\t\t\t      size_t *length, pl_wchar_t **s,\n\t\t\t\t      unsigned flags) WUNUSED;\nPL_EXPORT(size_t)\tPL_utf8_strlen(const char *s, size_t len) WUNUSED;\n\n\n\t\t /*******************************\n\t\t *\t   WIDE INTEGERS\t*\n\t\t *******************************/\n\n\nPL_EXPORT(int)\t\tPL_get_int64(term_t t, int64_t *i) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_int64(term_t t, int64_t value) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_uint64(term_t t, uint64_t value) WUNUSED;\nPL_EXPORT(int)\t\tPL_put_int64(term_t t, int64_t i) WUNUSED;\n\n\n\t\t /*******************************\n\t\t *     ATTRIBUTED VARIABLES\t*\n\t\t *******************************/\n\nPL_EXPORT(int)\t\tPL_is_attvar(term_t t);\nPL_EXPORT(int)\t\tPL_get_attr(term_t v, term_t a);\n\n\n\t\t /*******************************\n\t\t *\t      ERRORS\t\t*\n\t\t *******************************/\n\nPL_EXPORT(int)\t\tPL_get_atom_ex(term_t t, atom_t *a);\nPL_EXPORT(int)\t\tPL_get_integer_ex(term_t t, int *i);\nPL_EXPORT(int)\t\tPL_get_long_ex(term_t t, long *i);\nPL_EXPORT(int)\t\tPL_get_int64_ex(term_t t, int64_t *i);\nPL_EXPORT(int)\t\tPL_get_intptr_ex(term_t t, intptr_t *i);\nPL_EXPORT(int)\t\tPL_get_size_ex(term_t t, size_t *i);\nPL_EXPORT(int)\t\tPL_get_bool_ex(term_t t, int *i);\nPL_EXPORT(int)\t\tPL_get_float_ex(term_t t, double *f);\nPL_EXPORT(int)\t\tPL_get_char_ex(term_t t, int *p, int eof);\nPL_EXPORT(int)\t\tPL_unify_bool_ex(term_t t, int val);\nPL_EXPORT(int)\t\tPL_get_pointer_ex(term_t t, void **addrp);\nPL_EXPORT(int)\t\tPL_unify_list_ex(term_t l, term_t h, term_t t);\nPL_EXPORT(int)\t\tPL_unify_nil_ex(term_t l);\nPL_EXPORT(int)\t\tPL_get_list_ex(term_t l, term_t h, term_t t);\nPL_EXPORT(int)\t\tPL_get_nil_ex(term_t l);\n\nPL_EXPORT(int)\t\tPL_instantiation_error(term_t culprit);\nPL_EXPORT(int)\t\tPL_uninstantiation_error(term_t culprit);\nPL_EXPORT(int)\t\tPL_representation_error(const char *resource);\nPL_EXPORT(int)\t\tPL_type_error(const char *expected, term_t culprit);\nPL_EXPORT(int)\t\tPL_domain_error(const char *expected, term_t culprit);\nPL_EXPORT(int)\t\tPL_existence_error(const char *type, term_t culprit);\nPL_EXPORT(int)\t\tPL_permission_error(const char *operation,\n\t\t\t\t\t    const char *type, term_t culprit);\nPL_EXPORT(int)\t\tPL_resource_error(const char *resource);\n#ifdef SIO_MAGIC\nPL_EXPORT(int)\t\tPL_syntax_error(const char *msg, IOSTREAM *in);\n#else\nPL_EXPORT(int)\t\tPL_syntax_error(const char *msg, void *in);\n#endif\n\n\t\t /*******************************\n\t\t *\t       BLOBS\t\t*\n\t\t *******************************/\n\n#define PL_BLOB_MAGIC_B\t0x75293a00\t/* Magic to validate a blob-type */\n#define PL_BLOB_VERSION 1\t\t/* Current version */\n#define PL_BLOB_MAGIC\t(PL_BLOB_MAGIC_B|PL_BLOB_VERSION)\n\n#define PL_BLOB_UNIQUE\t0x01\t\t/* Blob content is unique */\n#define PL_BLOB_TEXT\t0x02\t\t/* blob contains text */\n#define PL_BLOB_NOCOPY\t0x04\t\t/* do not copy the data */\n#define PL_BLOB_WCHAR\t0x08\t\t/* wide character string */\n\ntypedef struct PL_blob_t\n{ uintptr_t\t\tmagic;\t\t/* PL_BLOB_MAGIC */\n  uintptr_t\t\tflags;\t\t/* PL_BLOB_* */\n  char *\t\tname;\t\t/* name of the type */\n  int\t\t\t(*release)(atom_t a);\n  int\t\t\t(*compare)(atom_t a, atom_t b);\n#ifdef SIO_MAGIC\n  int\t\t\t(*write)(IOSTREAM *s, atom_t a, int flags);\n#else\n  int\t\t\t(*write)(void *s, atom_t a, int flags);\n#endif\n  void\t\t\t(*acquire)(atom_t a);\n#ifdef SIO_MAGIC\n  int\t\t\t(*save)(atom_t a, IOSTREAM *s);\n  atom_t\t\t(*load)(IOSTREAM *s);\n#else\n  int\t\t\t(*save)(atom_t a, void*);\n  atom_t\t\t(*load)(void *s);\n#endif\n  size_t\t\tpadding;\t/* Required 0-padding */\n\t\t\t\t\t/* private */\n  void *\t\treserved[9];\t/* for future extension */\n  int\t\t\tregistered;\t/* Already registered? */\n  int\t\t\trank;\t\t/* Rank for ordering atoms */\n  struct PL_blob_t *    next;\t\t/* next in registered type-chain */\n  atom_t\t\tatom_name;\t/* Name as atom */\n} PL_blob_t;\n\nPL_EXPORT(int)\t\tPL_is_blob(term_t t, PL_blob_t **type);\nPL_EXPORT(int)\t\tPL_unify_blob(term_t t, void *blob, size_t len,\n\t\t\t\t      PL_blob_t *type);\nPL_EXPORT(int)\t\tPL_put_blob(term_t t, void *blob, size_t len,\n\t\t\t\t    PL_blob_t *type);\nPL_EXPORT(int)\t\tPL_get_blob(term_t t, void **blob, size_t *len,\n\t\t\t\t    PL_blob_t **type);\n\nPL_EXPORT(void*)\tPL_blob_data(atom_t a,\n\t\t\t\t     size_t *len,\n\t\t\t\t     struct PL_blob_t **type);\n\nPL_EXPORT(void)\t\tPL_register_blob_type(PL_blob_t *type);\nPL_EXPORT(PL_blob_t*)\tPL_find_blob_type(const char* name);\nPL_EXPORT(int)\t\tPL_unregister_blob_type(PL_blob_t *type);\n\n\n#ifdef __GNU_MP__\n\n\t\t /*******************************\n\t\t *\t       GMP\t\t*\n\t\t *******************************/\n\nPL_EXPORT(int)\tPL_get_mpz(term_t t, mpz_t mpz) WUNUSED;\nPL_EXPORT(int)\tPL_get_mpq(term_t t,  mpq_t mpq) WUNUSED;\nPL_EXPORT(int)\tPL_unify_mpz(term_t t, mpz_t mpz) WUNUSED;\nPL_EXPORT(int)\tPL_unify_mpq(term_t t, mpq_t mpq) WUNUSED;\n\n#endif /*__GNU_MP__*/\n\n\t\t /*******************************\n\t\t *\t  FILENAME SUPPORT\t*\n\t\t *******************************/\n\n#define PL_FILE_ABSOLUTE\t0x01\t/* return absolute path */\n#define PL_FILE_OSPATH\t\t0x02\t/* return path in OS notation */\n#define PL_FILE_SEARCH\t\t0x04\t/* use file_search_path */\n#define PL_FILE_EXIST\t\t0x08\t/* demand file to exist */\n#define PL_FILE_READ\t\t0x10\t/* demand read-access */\n#define PL_FILE_WRITE\t\t0x20\t/* demand write-access */\n#define PL_FILE_EXECUTE\t\t0x40\t/* demand execute-access */\n#define PL_FILE_NOERRORS\t0x80\t/* do not raise exceptions */\n\nPL_EXPORT(int)\t\tPL_get_file_name(term_t n, char **name, int flags);\nPL_EXPORT(int)\t\tPL_get_file_nameW(term_t n, wchar_t **name, int flags);\nPL_EXPORT(void)\t\tPL_changed_cwd(void); /* foreign code changed CWD */\nPL_EXPORT(char *)\tPL_cwd(char *buf, size_t buflen);\n\n\n\t\t /*******************************\n\t\t *    QUINTUS/SICSTUS WRAPPER\t*\n\t\t *******************************/\n\nPL_EXPORT(int)\t\tPL_cvt_i_char(term_t p, char *c);\nPL_EXPORT(int)\t\tPL_cvt_i_uchar(term_t p, unsigned char *c);\nPL_EXPORT(int)\t\tPL_cvt_i_short(term_t p, short *s);\nPL_EXPORT(int)\t\tPL_cvt_i_ushort(term_t p, unsigned short *s);\nPL_EXPORT(int)\t\tPL_cvt_i_int(term_t p, int *c);\nPL_EXPORT(int)\t\tPL_cvt_i_uint(term_t p, unsigned int *c);\nPL_EXPORT(int)\t\tPL_cvt_i_long(term_t p, long *c);\nPL_EXPORT(int)\t\tPL_cvt_i_ulong(term_t p, unsigned long *c);\nPL_EXPORT(int)\t\tPL_cvt_i_int64(term_t p, int64_t *c);\nPL_EXPORT(int)\t\tPL_cvt_i_uint64(term_t p, uint64_t *c);\nPL_EXPORT(int)\t\tPL_cvt_i_size_t(term_t p, size_t *c);\nPL_EXPORT(int)\t\tPL_cvt_i_float(term_t p, double *c);\nPL_EXPORT(int)\t\tPL_cvt_i_single(term_t p, float *c);\nPL_EXPORT(int)\t\tPL_cvt_i_string(term_t p, char **c);\nPL_EXPORT(int)\t\tPL_cvt_i_codes(term_t p, char **c);\nPL_EXPORT(int)\t\tPL_cvt_i_atom(term_t p, atom_t *c);\nPL_EXPORT(int)\t\tPL_cvt_i_address(term_t p, void *c);\nPL_EXPORT(int)\t\tPL_cvt_o_int64(int64_t c, term_t p);\nPL_EXPORT(int)\t\tPL_cvt_o_float(double c, term_t p);\nPL_EXPORT(int)\t\tPL_cvt_o_single(float c, term_t p);\nPL_EXPORT(int)\t\tPL_cvt_o_string(const char *c, term_t p);\nPL_EXPORT(int)\t\tPL_cvt_o_codes(const char *c, term_t p);\nPL_EXPORT(int)\t\tPL_cvt_o_atom(atom_t c, term_t p);\nPL_EXPORT(int)\t\tPL_cvt_o_address(void *address, term_t p);\nPL_EXPORT(term_t)\tPL_new_nil_ref(void);\n\n/* set/get encoding for PL_cvt_*_string() functions.  The default\n   is UTF-8 (REP_UTF8)\n*/\n\nPL_EXPORT(int)\t\tPL_cvt_encoding(void);\nPL_EXPORT(int)\t\tPL_cvt_set_encoding(int enc);\nPL_EXPORT(void)\t\tSP_set_state(int state);\nPL_EXPORT(int)\t\tSP_get_state(void);\n\n\n\t\t /*******************************\n\t\t *\t     COMPARE\t\t*\n\t\t *******************************/\n\nPL_EXPORT(int)\t\tPL_compare(term_t t1, term_t t2);\nPL_EXPORT(int)\t\tPL_same_compound(term_t t1, term_t t2);\n\n\t\t /*******************************\n\t\t *\t     MESSAGES\t\t*\n\t\t *******************************/\n\nPL_EXPORT(int)\t\tPL_warning(const char *fmt, ...);\nPL_EXPORT(void)\t\tPL_fatal_error(const char *fmt, ...);\n\n\t\t /*******************************\n\t\t *      RECORDED DATABASE\t*\n\t\t *******************************/\n\nPL_EXPORT(record_t)\tPL_record(term_t term);\nPL_EXPORT(int)\t\tPL_recorded(record_t record, term_t term);\nPL_EXPORT(void)\t\tPL_erase(record_t record);\nPL_EXPORT(record_t)\tPL_duplicate_record(record_t r);\n\nPL_EXPORT(char *)\tPL_record_external(term_t t, size_t *size);\nPL_EXPORT(int)\t\tPL_recorded_external(const char *rec, term_t term);\nPL_EXPORT(int)\t\tPL_erase_external(char *rec);\n\n\t\t /*******************************\n\t\t *\t   PROLOG FLAGS\t\t*\n\t\t *******************************/\n\n#define PL_set_feature  PL_set_prolog_flag /* compatibility */\nPL_EXPORT(int)\t\tPL_set_prolog_flag(const char *name, int type, ...);\n\n\n\t\t /*******************************\n\t\t *\tINTERNAL FUNCTIONS\t*\n\t\t *******************************/\n\nPL_EXPORT(PL_atomic_t)\t_PL_get_atomic(term_t t);\nPL_EXPORT(void)\t\t_PL_put_atomic(term_t t, PL_atomic_t a);\nPL_EXPORT(int)\t\t_PL_unify_atomic(term_t t, PL_atomic_t a);\nPL_EXPORT(void)\t\t_PL_get_arg_sz(size_t index, term_t t, term_t a);\nPL_EXPORT(void)\t\t_PL_get_arg(int index, term_t t, term_t a);\n\n\n\t\t /*******************************\n\t\t *\t    CHAR BUFFERS\t*\n\t\t *******************************/\n\n#define CVT_ATOM\t0x0001\n#define CVT_STRING\t0x0002\n#define CVT_LIST\t0x0004\n#define CVT_INTEGER\t0x0008\n#define CVT_FLOAT\t0x0010\n#define CVT_VARIABLE\t0x0020\n#define CVT_NUMBER\t(CVT_INTEGER|CVT_FLOAT)\n#define CVT_ATOMIC\t(CVT_NUMBER|CVT_ATOM|CVT_STRING)\n#define CVT_WRITE\t0x0040\n#define CVT_WRITE_CANONICAL 0x0080\n#define CVT_WRITEQ\t0x00C0\n#define CVT_ALL\t\t(CVT_ATOMIC|CVT_LIST)\n#define CVT_MASK\t0x00ff\n\n#define BUF_DISCARDABLE\t0x0000\n#define BUF_RING\t0x0100\n#define BUF_MALLOC\t0x0200\n#define BUF_ALLOW_STACK\t0x0400\t\t/* allow pointer into (global) stack */\n\n#define CVT_EXCEPTION\t0x10000\t\t/* throw exception on error */\n#define CVT_VARNOFAIL\t0x20000\t\t/* return 2 if argument is unbound */\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nOutput   representation   for   PL_get_chars()     and    friends.   The\nprepresentation type REP_FN is for   PL_get_file_name()  and friends. On\nWindows we use UTF-8 which is translated   by the `XOS' layer to Windows\nUNICODE file functions.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n#define REP_ISO_LATIN_1 0x0000\t\t/* output representation */\n#define REP_UTF8\t0x1000\n#define REP_MB\t\t0x2000\n#ifdef __WINDOWS__\n#define REP_FN\t\tREP_UTF8\n#else\n#define REP_FN\t\tREP_MB\n#endif\n\n#define PL_DIFF_LIST\t0x20000\t\t/* PL_unify_chars() */\n\n\n#ifdef SIO_MAGIC\t\t\t/* defined from <SWI-Stream.h> */\n\t\t /*******************************\n\t\t *\t  STREAM SUPPORT\t*\n\t\t *******************************/\n\n\t\t\t\t\t/* Make IOSTREAM known to Prolog */\n#define PL_open_stream  PL_unify_stream\t/* compatibility */\nPL_EXPORT(int)\t\tPL_unify_stream(term_t t, IOSTREAM *s);\nPL_EXPORT(int)\t\tPL_get_stream_handle(term_t t, IOSTREAM **s);\nPL_EXPORT(int)\t\tPL_get_stream(term_t t, IOSTREAM **s, int flags);\nPL_EXPORT(IOSTREAM*)\tPL_acquire_stream(IOSTREAM *s);\nPL_EXPORT(int)\t\tPL_release_stream(IOSTREAM *s);\nPL_EXPORT(int)\t\tPL_release_stream_noerror(IOSTREAM *s);\nPL_EXPORT(IOSTREAM *)\tPL_open_resource(module_t m,\n\t\t\t\t\t const char *name,\n\t\t\t\t\t const char *rc_class,\n\t\t\t\t\t const char *mode);\n\nPL_EXPORT(IOSTREAM *)*_PL_streams(void);\t/* base of streams */\n#ifndef PL_KERNEL\n#define Suser_input     (_PL_streams()[0])\n#define Suser_output    (_PL_streams()[1])\n#define Suser_error     (_PL_streams()[2])\n#define Scurrent_input  (_PL_streams()[3])\n#define Scurrent_output (_PL_streams()[4])\n#endif\n\n#define PL_WRT_QUOTED\t\t0x01\t/* quote atoms */\n#define PL_WRT_IGNOREOPS\t0x02\t/* ignore list/operators */\n#define PL_WRT_NUMBERVARS\t0x04\t/* print $VAR(N) as a variable */\n#define PL_WRT_PORTRAY\t\t0x08\t/* call portray */\n#define PL_WRT_CHARESCAPES\t0x10\t/* Output ISO escape sequences */\n#define PL_WRT_BACKQUOTED_STRING 0x20\t/* Write strings as `...` */\n\t\t\t\t\t/* Write attributed variables */\n#define PL_WRT_ATTVAR_IGNORE\t0x040\t/* Default: just write the var */\n#define PL_WRT_ATTVAR_DOTS\t0x080\t/* Write as Var{...} */\n#define PL_WRT_ATTVAR_WRITE\t0x100\t/* Write as Var{Attributes} */\n#define PL_WRT_ATTVAR_PORTRAY\t0x200\t/* Use Module:portray_attrs/2 */\n#define PL_WRT_ATTVAR_MASK \\\n\t(PL_WRT_ATTVAR_IGNORE | \\\n\t PL_WRT_ATTVAR_DOTS | \\\n\t PL_WRT_ATTVAR_WRITE | \\\n\t PL_WRT_ATTVAR_PORTRAY)\n#define PL_WRT_BLOB_PORTRAY\t0x400\t/* Use portray to emit non-text blobs */\n#define PL_WRT_NO_CYCLES\t0x800\t/* Never emit @(Template,Subst) */\n#define PL_WRT_NEWLINE\t       0x2000\t/* Add a newline */\n#define PL_WRT_VARNAMES\t       0x4000\t/* Internal: variable_names(List)  */\n#define PL_WRT_BACKQUOTE_IS_SYMBOL 0x8000 /* ` is a symbol char */\n#define PL_WRT_DOTLISTS\t       0x10000\t/* Write lists as .(A,B) */\n#define PL_WRT_BRACETERMS      0x20000\t/* Write {A} as {}(A) */\n#define PL_WRT_NODICT\t       0x40000\t/* Do not write dicts in pretty syntax */\n#define PL_WRT_NODOTINATOM     0x80000\t/* never write a.b unquoted */\n\nPL_EXPORT(int)\tPL_write_term(IOSTREAM *s,\n\t\t\t     term_t term,\n\t\t\t     int precedence,\n\t\t\t     int flags);\n\n\t\t\t\t\t/* PL_ttymode() results */\n#define PL_NOTTY\t0\t\t/* -tty in effect */\n#define PL_RAWTTY\t1\t\t/* get_single_char/1 */\n#define PL_COOKEDTTY\t2\t\t/* normal input */\n\nPL_EXPORT(int)\t\tPL_ttymode(IOSTREAM *s);\n\n#endif /*SIO_MAGIC*/\n\nPL_EXPORT(int)  PL_put_term_from_chars(term_t t, int flags,\n\t\t\t\t       size_t len, const char *s);\nPL_EXPORT(int)\tPL_chars_to_term(const char *chars,\n\t\t\t\tterm_t term);\nPL_EXPORT(int)\tPL_wchars_to_term(const pl_wchar_t *chars,\n\t\t\t\t term_t term);\n\n\n\t\t /*******************************\n\t\t *\t    EMBEDDING\t\t*\n\t\t *******************************/\n\nPL_EXPORT(int)\t\tPL_initialise(int argc, char **argv);\nPL_EXPORT(int)\t\tPL_is_initialised(int *argc, char ***argv);\nPL_EXPORT(int)\t\tPL_set_resource_db_mem(const unsigned char *data,\n\t\t\t\t\t       size_t size);\nPL_EXPORT(int)\t\tPL_toplevel(void);\nPL_EXPORT(int)\t\tPL_cleanup(int status);\nPL_EXPORT(void)\t\tPL_cleanup_fork();\nPL_EXPORT(int)\t\tPL_halt(int status);\n\n\t\t /*******************************\n\t\t *\t  DYNAMIC LINKING\t*\n\t\t *******************************/\n\nPL_EXPORT(void *)\tPL_dlopen(const char *file, int flags);\nPL_EXPORT(const char *) PL_dlerror(void);\nPL_EXPORT(void *)\tPL_dlsym(void *handle, char *symbol);\nPL_EXPORT(int)\t\tPL_dlclose(void *handle);\n\n\n\t\t /*******************************\n\t\t *      INPUT/PROMPT/ETC\t*\n\t\t *******************************/\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nNOTE: the functions in this section are   not  documented, as as yet not\nadviced for public usage.  They  are   intended  to  provide an abstract\ninterface for the GNU readline  interface   as  defined  in the readline\npackage.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\t\t\t\t\t/* PL_dispatch() modes */\n#define PL_DISPATCH_NOWAIT    0\t\t/* Dispatch only once */\n#define PL_DISPATCH_WAIT      1\t\t/* Dispatch till input available */\n#define PL_DISPATCH_INSTALLED 2\t\t/* dispatch function installed? */\n\nPL_EXPORT(int)\t\tPL_dispatch(int fd, int wait);\nPL_EXPORT(void)\t\tPL_add_to_protocol(const char *buf, size_t count);\nPL_EXPORT(char *)\tPL_prompt_string(int fd);\nPL_EXPORT(void)\t\tPL_write_prompt(int dowrite);\nPL_EXPORT(void)\t\tPL_prompt_next(int fd);\nPL_EXPORT(char *)\tPL_atom_generator(const char *prefix, int state);\nPL_EXPORT(pl_wchar_t*)\tPL_atom_generator_w(const pl_wchar_t *pref,\n\t\t\t\t\t    pl_wchar_t *buffer,\n\t\t\t\t\t    size_t buflen,\n\t\t\t\t\t    int state);\n\n\n\t\t /*******************************\n\t\t *\tMEMORY ALLOCATION\t*\n\t\t *******************************/\n\nPL_EXPORT(void *)\tPL_malloc(size_t size);\nPL_EXPORT(void *)\tPL_malloc_atomic(size_t size);\nPL_EXPORT(void *)\tPL_malloc_uncollectable(size_t size);\nPL_EXPORT(void *)\tPL_malloc_atomic_uncollectable(size_t size);\nPL_EXPORT(void *)\tPL_realloc(void *mem, size_t size);\nPL_EXPORT(void *)\tPL_malloc_unmanaged(size_t size);\nPL_EXPORT(void *)\tPL_malloc_atomic_unmanaged(size_t size);\nPL_EXPORT(void)\t\tPL_free(void *mem);\nPL_EXPORT(int)\t\tPL_linger(void *mem);\n\n\n\t\t/********************************\n\t\t*             HOOKS\t\t*\n\t\t********************************/\n\n#define PL_DISPATCH_INPUT   0\t\t/* There is input available */\n#define PL_DISPATCH_TIMEOUT 1\t\t/* Dispatch timeout */\n\ntypedef int  (*PL_dispatch_hook_t)(int fd);\ntypedef void (*PL_abort_hook_t)(void);\ntypedef void (*PL_initialise_hook_t)(int argc, char **argv);\ntypedef int  (*PL_agc_hook_t)(atom_t a);\n\nPL_EXPORT(PL_dispatch_hook_t)\tPL_dispatch_hook(PL_dispatch_hook_t);\nPL_EXPORT(void)\t\t\tPL_abort_hook(PL_abort_hook_t);\nPL_EXPORT(void)\t\t\tPL_initialise_hook(PL_initialise_hook_t);\nPL_EXPORT(int)\t\t\tPL_abort_unhook(PL_abort_hook_t);\nPL_EXPORT(PL_agc_hook_t)\tPL_agc_hook(PL_agc_hook_t);\n\n\n\t\t/********************************\n\t\t*            SIGNALS            *\n\t\t*********************************/\n\n/* PL_signal() masks (deprecated) */\n#define PL_SIGSYNC\t0x00010000\t/* call handler synchronously */\n#define PL_SIGNOFRAME\t0x00020000\t/* Do not create a Prolog frame */\n\n#define PLSIG_THROW     0x0002\t\t/* throw signal(num, name) */\n#define PLSIG_SYNC      0x0004\t\t/* call synchronously */\n#define PLSIG_NOFRAME   0x0008\t\t/* Do not create a Prolog frame */\n\n\n\n\ntypedef struct pl_sigaction\n{ void        (*sa_cfunction)(int);\t/* traditional C function */\n  predicate_t sa_predicate;\t\t/* call a predicate */\n  int\t      sa_flags;\t\t\t/* additional flags */\n  void       *reserved[2];\t\t/* future extentions */\n} pl_sigaction_t;\n\n\nPL_EXPORT(void) (*PL_signal(int sig, void (*func)(int)))(int);\nPL_EXPORT(int)  PL_sigaction(int sig, pl_sigaction_t *act, pl_sigaction_t *old);\nPL_EXPORT(void)\tPL_interrupt(int sig);\nPL_EXPORT(int)\tPL_raise(int sig);\nPL_EXPORT(int)\tPL_handle_signals(void);\nPL_EXPORT(int)\tPL_get_signum_ex(term_t sig, int *n);\n\n\n\t\t/********************************\n\t\t*      PROLOG ACTION/QUERY      *\n\t\t*********************************/\n\n#define\tPL_ACTION_TRACE\t\t1\t/* switch to trace mode */\n#define PL_ACTION_DEBUG\t\t2\t/* switch to debug mode */\n#define PL_ACTION_BACKTRACE\t3\t/* show a backtrace (stack dump) */\n#define PL_ACTION_BREAK\t\t4\t/* create a break environment */\n#define PL_ACTION_HALT\t\t5\t/* halt Prolog execution */\n#define PL_ACTION_ABORT\t\t6\t/* generate a Prolog abort */\n\t\t\t\t\t/* 7: Obsolete PL_ACTION_SYMBOLFILE */\n#define PL_ACTION_WRITE\t\t8\t/* write via Prolog i/o buffer */\n#define PL_ACTION_FLUSH\t\t9\t/* Flush Prolog i/o buffer */\n#define PL_ACTION_GUIAPP\t10\t/* Win32: set when this is a gui */\n#define PL_ACTION_ATTACH_CONSOLE 11\t/* MT: Attach a console */\n#define PL_GMP_SET_ALLOC_FUNCTIONS 12\t/* GMP: do not change allocation functions */\n#define PL_ACTION_TRADITIONAL\t13\t/* Set --traditional */\n\n#define PL_BT_SAFE\t\t0x1\t/* Do not try to print goals */\n#define PL_BT_USER\t\t0x2\t/* Only show user-goals */\n\nPL_EXPORT(int)\tPL_action(int, ...);\t/* perform some action */\nPL_EXPORT(void)\tPL_on_halt(int (*)(int, void *), void *);\nPL_EXPORT(void)\tPL_exit_hook(int (*)(int, void *), void *);\nPL_EXPORT(void)\tPL_backtrace(int depth, int flags);\nPL_EXPORT(char *) PL_backtrace_string(int depth, int flags);\nPL_EXPORT(int)\tPL_check_data(term_t data);\nPL_EXPORT(int)\tPL_check_stacks(void);\nPL_EXPORT(int)\tPL_current_prolog_flag(atom_t name, int type, void *ptr);\n\n\n\t\t/********************************\n\t\t*         QUERY PROLOG          *\n\t\t*********************************/\n\n#define PL_QUERY_ARGC\t\t1\t/* return main() argc */\n#define PL_QUERY_ARGV\t\t2\t/* return main() argv */\n\t\t\t\t\t/* 3: Obsolete PL_QUERY_SYMBOLFILE */\n\t\t\t\t\t/* 4: Obsolete PL_QUERY_ORGSYMBOLFILE*/\n#define PL_QUERY_GETC\t\t5\t/* Read character from terminal */\n#define PL_QUERY_MAX_INTEGER\t6\t/* largest integer */\n#define PL_QUERY_MIN_INTEGER\t7\t/* smallest integer */\n#define PL_QUERY_MAX_TAGGED_INT\t8\t/* largest tagged integer */\n#define PL_QUERY_MIN_TAGGED_INT\t9\t/* smallest tagged integer */\n#define PL_QUERY_VERSION        10\t/* 207006 = 2.7.6 */\n#define PL_QUERY_MAX_THREADS\t11\t/* maximum thread count */\n#define PL_QUERY_ENCODING\t12\t/* I/O encoding */\n#define PL_QUERY_USER_CPU\t13\t/* User CPU in milliseconds */\n#define PL_QUERY_HALTING\t14\t/* If TRUE, we are in PL_cleanup() */\n\nPL_EXPORT(intptr_t)\tPL_query(int);\t/* get information from Prolog */\n\n\n\t\t /*******************************\n\t\t *\t  PROLOG THREADS\t*\n\t\t *******************************/\n\n#define PL_THREAD_NO_DEBUG\t0x01\t/* Start thread in nodebug mode */\n#define PL_THREAD_NOT_DETACHED\t0x02\t/* Allow Prolog to join */\n\ntypedef enum\n{ PL_THREAD_CANCEL_FAILED = FALSE,\t/* failed to cancel; try abort */\n  PL_THREAD_CANCEL_JOINED = TRUE,\t/* cancelled and joined */\n  PL_THREAD_CANCEL_MUST_JOIN\t\t/* cancelled, must join */\n} rc_cancel;\n\ntypedef struct\n{ size_t    stack_limit;\t\t/* Total stack limit (bytes) */\n  size_t    table_space;\t\t/* Total tabling space limit (bytes) */\n  char *    alias;\t\t\t/* alias name */\n  rc_cancel (*cancel)(int id);\t\t/* cancel function */\n  intptr_t  flags;\t\t\t/* PL_THREAD_* flags */\n  size_t    max_queue_size;\t\t/* Max size of associated queue */\n  void *    reserved[3];\t\t/* reserved for extensions */\n} PL_thread_attr_t;\n\n\nPL_EXPORT(int)\tPL_thread_self(void);\t/* Prolog thread id (-1 if none) */\nPL_EXPORT(int)\tPL_unify_thread_id(term_t t, int i);\nPL_EXPORT(int)\tPL_get_thread_id_ex(term_t t, int *idp);\nPL_EXPORT(int)\tPL_get_thread_alias(int tid, atom_t *alias);\t/* Locks alias */\nPL_EXPORT(int)\tPL_thread_attach_engine(PL_thread_attr_t *attr);\nPL_EXPORT(int)\tPL_thread_destroy_engine(void);\nPL_EXPORT(int)\tPL_thread_at_exit(void (*function)(void *),\n\t\t\t\t  void *closure,\n\t\t\t\t  int global);\nPL_EXPORT(int)\tPL_thread_raise(int tid, int sig);\n#if defined(_WINDOWS_) || defined(_WINDOWS_H)\t/* <windows.h> is included */\nPL_EXPORT(int)\tPL_w32thread_raise(DWORD dwTid, int sig);\nPL_EXPORT(int)\tPL_wait_for_console_input(void *handle);\nPL_EXPORT(int)\tPL_w32_wrap_ansi_console(void);\nPL_EXPORT(const char*) PL_w32_running_under_wine(void);\n#endif\n\n\t\t /*******************************\n\t\t *\t ENGINES (MT-ONLY)\t*\n\t\t *******************************/\n\n#define PL_ENGINE_MAIN\t  ((PL_engine_t)0x1)\n#define PL_ENGINE_CURRENT ((PL_engine_t)0x2)\n\n#define PL_ENGINE_SET   0\t\t/* engine set successfully */\n#define PL_ENGINE_INVAL\t2\t\t/* engine doesn't exist */\n#define PL_ENGINE_INUSE\t3\t\t/* engine is in use */\n\nPL_EXPORT(PL_engine_t)\tPL_create_engine(PL_thread_attr_t *attributes);\nPL_EXPORT(int)\t\tPL_set_engine(PL_engine_t engine, PL_engine_t *old);\nPL_EXPORT(int)\t\tPL_destroy_engine(PL_engine_t engine);\n\n\n\t\t /*******************************\n\t\t *\t     PROFILER\t\t*\n\t\t *******************************/\n\ntypedef struct\n{ int\t(*unify)(term_t t, void *handle);\t/* implementation --> Prolog */\n  int   (*get)(term_t t, void **handle);\t/* Prolog --> implementation */\n  void\t(*activate)(int active);\t\t/* (de)activate */\n  intptr_t\tmagic;\t\t\t\t\t/* PROFTYPE_MAGIC */\n} PL_prof_type_t;\n\nPL_EXPORT(int)\t\tPL_register_profile_type(PL_prof_type_t *type);\nPL_EXPORT(void*)\tPL_prof_call(void *handle, PL_prof_type_t *type);\nPL_EXPORT(void)\t\tPL_prof_exit(void *node);\n\n\n\t\t /*******************************\n\t\t *\t WINDOWS MESSAGES\t*\n\t\t *******************************/\n\n#if defined(_WINDOWS_) || defined(_WINDOWS_H)\t/* <windows.h> is included */\n#define PL_MSG_EXCEPTION_RAISED -1\n#define PL_MSG_IGNORED 0\n#define PL_MSG_HANDLED 1\n\nPL_EXPORT(LRESULT)\tPL_win_message_proc(HWND hwnd,\n\t\t\t\t\t    UINT message,\n\t\t\t\t\t    WPARAM wParam,\n\t\t\t\t\t    LPARAM lParam);\n#endif /* _WINDOWS_/_WINDOWS_H */\n\n\n\t\t /*******************************\n\t\t *       FAST XPCE SUPPORT\t*\n\t\t *******************************/\n\ntypedef struct\n{ int type;\t\t\t\t/* PL_INTEGER or PL_ATOM */\n  union\n  { uintptr_t i;\t\t\t/* integer reference value */\n    atom_t\t  a;\t\t\t/* atom reference value */\n  } value;\n} xpceref_t;\n\nPL_EXPORT(int)\t_PL_get_xpce_reference(term_t t, xpceref_t *ref);\nPL_EXPORT(int)\t_PL_unify_xpce_reference(term_t t, xpceref_t *ref);\nPL_EXPORT(int)\t_PL_put_xpce_reference_i(term_t t, uintptr_t r);\nPL_EXPORT(int)\t_PL_put_xpce_reference_a(term_t t, atom_t name);\n\n\n\n\t\t /*******************************\n\t\t *         TRACE SUPPORT\t*\n\t\t *******************************/\n\n#ifndef _PL_INCLUDE_H\ntypedef void *QueryFrame;\ntypedef void *LocalFrame;\ntypedef void *Code;\n#endif\n\ntypedef struct pl_context_t\n{ PL_engine_t   ld;\t\t\t/* Engine */\n  QueryFrame\tqf;\t\t\t/* Current query */\n  LocalFrame\tfr;\t\t\t/* Current localframe */\n  Code\t\tpc;\t\t\t/* Code pointer */\n  void *\treserved[10];\t\t/* Reserved for extensions */\n} pl_context_t;\n\nPL_EXPORT(int)\tPL_get_context(struct pl_context_t *c, int thead_id);\nPL_EXPORT(int)\tPL_step_context(struct pl_context_t *c);\nPL_EXPORT(int)\tPL_describe_context(struct pl_context_t *c,\n\t\t\t\t    char *buf, size_t len);\n\n#ifdef PL_ARITY_AS_SIZE\n#define PL_new_functor(f,a) PL_new_functor_sz(f,a)\n#define PL_functor_arity(f) PL_functor_arity_sz(f)\n#define PL_get_name_arity(t,n,a) PL_get_name_arity_sz(t,n,a)\n#define PL_get_compound_name_arity(t,n,a) PL_get_compound_name_arity_sz(t,n,a)\n#define PL_get_arg(i,t,a) PL_get_arg_sz(i,t,a)\n#define PL_unify_arg(i,t,a) PL_unify_arg_sz(i,t,a)\n#ifndef _PL_INCLUDE_H\n#define _PL_get_arg(i,t,a) _PL_get_arg_sz(i,t,a)\n#endif\n#else\n//Considered too alarming\n//#warning \"Term arity has changed from int to size_t.\"\n//#warning \"Please update your code and use #define PL_ARITY_AS_SIZE 1.\"\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /*_FLI_H_INCLUDED*/\n",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/src/pl-nt.c": "/*  Part of SWI-Prolog\n\n    Author:        Jan Wielemaker\n    E-mail:        J.Wielemaker@vu.nl\n    WWW:           http://www.swi-prolog.org\n    Copyright (c)  1995-2016, University of Amsterdam\n    All rights reserved.\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n    1. Redistributions of source code must retain the above copyright\n       notice, this list of conditions and the following disclaimer.\n\n    2. Redistributions in binary form must reproduce the above copyright\n       notice, this list of conditions and the following disclaimer in\n       the documentation and/or other materials provided with the\n       distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n    COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n    ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n    POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#ifdef __WINDOWS__\n#define WINVER 0x0501\n#if (_MSC_VER >= 1300) || __MINGW32__\n#include <winsock2.h>\t\t\t/* Needed on VC8 */\n#include <windows.h>\n#else\n#include <windows.h>\t\t\t/* Needed for MSVC 5&6 */\n#include <winsock2.h>\n#endif\n\n#ifdef __MINGW32__\n#ifndef _WIN32_IE\n#define _WIN32_IE 0x0400\n#endif\n/* FIXME: these are copied from SWI-Prolog.h. */\n#define PL_MSG_EXCEPTION_RAISED -1\n#define PL_MSG_IGNORED 0\n#define PL_MSG_HANDLED 1\n#endif\n\n#include \"pl-incl.h\"\n#include \"os/pl-utf8.h\"\n#include <process.h>\n#include \"os/pl-ctype.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include \"os/SWI-Stream.h\"\n#include <process.h>\n#include <winbase.h>\n#ifdef HAVE_CRTDBG_H\n#include <crtdbg.h>\n#endif\n\n\n\t\t /*******************************\n\t\t *\t       CONSOLE\t\t*\n\t\t *******************************/\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nThere is no way to tell which subsystem   an app belongs too, except for\npeeking in its executable-header. This is a bit too much ...\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\nint\nhasConsole(void)\n{ HANDLE h;\n\n  if ( GD->os.gui_app == FALSE )\t/* has been set explicitly */\n    succeed;\n\n\t\t\t\t\t/* I found a console */\n  if ( (h = GetStdHandle(STD_OUTPUT_HANDLE)) != INVALID_HANDLE_VALUE )\n  { DWORD mode;\n\n    if ( GetConsoleMode(h, &mode) )\n      succeed;\n  }\n\n\t\t\t\t\t/* assume we are GUI */\n  fail;\n}\n\n\nint\nPL_wait_for_console_input(void *handle)\n{ BOOL rc;\n  HANDLE hConsole = handle;\n\n  for(;;)\n  { rc = MsgWaitForMultipleObjects(1,\n\t\t\t\t   &hConsole,\n\t\t\t\t   FALSE,\t/* wait for either event */\n\t\t\t\t   INFINITE,\n\t\t\t\t   QS_ALLINPUT);\n\n    if ( rc == WAIT_OBJECT_0+1 )\n    { MSG msg;\n\n      while( PeekMessage(&msg, NULL, 0, 0, PM_REMOVE) )\n      { TranslateMessage(&msg);\n\tDispatchMessage(&msg);\n      }\n    } else if ( rc == WAIT_OBJECT_0 )\n    { return TRUE;\n    } else\n    { Sdprintf(\"MsgWaitForMultipleObjects(): 0x%x\\n\", rc);\n    }\n  }\n}\n\n\n\t\t /*******************************\n\t\t *\t    MESSAGE BOX\t\t*\n\t\t *******************************/\n\nvoid\nPlMessage(const char *fm, ...)\n{ va_list(args);\n\n  va_start(args, fm);\n\n  if ( hasConsole() )\n  { Sfprintf(Serror, \"SWI-Prolog: \");\n    Svfprintf(Serror, fm, args);\n    Sfprintf(Serror, \"\\n\");\n  } else\n  { char buf[1024];\n    int64_t hwndi;\n    HWND hwnd = NULL;\n    static atom_t ATOM_hwnd = 0;\n\n    if ( !ATOM_hwnd )\n      ATOM_hwnd = PL_new_atom(\"hwnd\");\n\n    if ( PL_current_prolog_flag(ATOM_hwnd, PL_INTEGER, &hwndi) )\n      hwnd = (HWND)(uintptr_t)hwndi;\n\n    vsprintf(buf, fm, args);\n    MessageBox(hwnd, buf, \"SWI-Prolog\", MB_OK|MB_TASKMODAL);\n  }\n\n  va_end(args);\n}\n\n\n\n\t\t /*******************************\n\t\t *\tWinAPI ERROR CODES\t*\n\t\t *******************************/\n\nconst char *\nWinError(void)\n{ int id = GetLastError();\n  char *msg;\n  static WORD lang;\n  static int lang_initialised = 0;\n\n  if ( !lang_initialised )\n    lang = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_UK);\n\nagain:\n  if ( FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER|\n\t\t     FORMAT_MESSAGE_IGNORE_INSERTS|\n\t\t     FORMAT_MESSAGE_FROM_SYSTEM,\n\t\t     NULL,\t\t\t/* source */\n\t\t     id,\t\t\t/* identifier */\n\t\t     lang,\n\t\t     (LPTSTR) &msg,\n\t\t     0,\t\t\t\t/* size */\n\t\t     NULL) )\t\t\t/* arguments */\n  { atom_t a = PL_new_atom(msg);\n\n    LocalFree(msg);\n    lang_initialised = 1;\n\n    return stringAtom(a);\n  } else\n  { if ( lang_initialised == 0 )\n    { lang = MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT);\n      lang_initialised = 1;\n      goto again;\n    }\n\n    return \"Unknown Windows error\";\n  }\n}\n\n\n\t\t /*******************************\n\t\t *\t  SLEEP/1 SUPPORT\t*\n\t\t *******************************/\n\nint\nPause(double t)\n{ HANDLE h;\n\n  if ( (h = CreateWaitableTimer(NULL, TRUE, NULL)) )\n  { LARGE_INTEGER ft;\n\n    ft.QuadPart = -(LONGLONG)(t * 10000000.0); /* 100 nanosecs per tick */\n\n    SetWaitableTimer(h, &ft, 0, NULL, NULL, FALSE);\n    for(;;)\n    { int rc = MsgWaitForMultipleObjects(1,\n\t\t\t\t\t &h,\n\t\t\t\t\t FALSE,\n\t\t\t\t\t INFINITE,\n\t\t\t\t\t QS_ALLINPUT);\n      if ( rc == WAIT_OBJECT_0+1 )\n      { MSG msg;\n\n\twhile( PeekMessage(&msg, NULL, 0, 0, PM_REMOVE) )\n\t{ TranslateMessage(&msg);\n\t  DispatchMessage(&msg);\n\t}\n\n\tif ( PL_handle_signals() < 0 )\n\t{ CloseHandle(h);\n\t  return FALSE;\n\t}\n      } else\n\tbreak;\n    }\n    CloseHandle(h);\n\n    return TRUE;\n  } else\t\t\t\t/* Pre NT implementation */\n  { DWORD msecs = (DWORD)(t * 1000.0);\n\n    while( msecs >= 100 )\n    { Sleep(100);\n      if ( PL_handle_signals() < 0 )\n\treturn FALSE;\n      msecs -= 100;\n    }\n    if ( msecs > 0 )\n      Sleep(msecs);\n\n    return TRUE;\n  }\n}\n\n\n\t\t /*******************************\n\t\t *\t  SET FILE SIZE\t\t*\n\t\t *******************************/\n\n#ifndef HAVE_FTRUNCATE\n\nint\nftruncate(int fileno, int64_t length)\n{ errno_t e;\n\n  if ( (e=_chsize_s(fileno, length)) == 0 )\n    return 0;\n\n  errno = e;\n  return -1;\n}\n\n#endif\n\n\n\t\t /*******************************\n\t\t *\t QUERY CPU TIME\t\t*\n\t\t *******************************/\n\n#define nano * 0.0000001\n#define ntick 1.0\t\t\t/* manual says 100.0 ??? */\n\ndouble\nCpuTime(cputime_kind which)\n{ double t;\n  HANDLE proc = GetCurrentProcess();\n  FILETIME created, exited, kerneltime, usertime;\n\n  if ( GetProcessTimes(proc, &created, &exited, &kerneltime, &usertime) )\n  { FILETIME *p;\n\n    switch ( which )\n    { case CPU_USER:\n\tp = &usertime;\n\tbreak;\n      case CPU_SYSTEM:\n\tp = &kerneltime;\n        break;\n      default:\n\tassert(0);\n        return 0.0;\n    }\n    t = (double)p->dwHighDateTime * (4294967296.0 * ntick nano);\n    t += (double)p->dwLowDateTime  * (ntick nano);\n  } else\t\t\t\t/* '95, Windows 3.1/win32s */\n  { t = 0.0;\n  }\n\n  return t;\n}\n\n\nint\nCpuCount(void)\n{ SYSTEM_INFO si;\n\n  GetSystemInfo(&si);\n\n  return si.dwNumberOfProcessors;\n}\n\n\nvoid\nsetOSPrologFlags(void)\n{ PL_set_prolog_flag(\"cpu_count\", PL_INTEGER, CpuCount());\n}\n\n\nchar *\nfindExecutable(const char *module, char *exe, size_t exelen)\n{ int n;\n  wchar_t wbuf[MAXPATHLEN];\n  HMODULE hmod;\n\n  if ( module )\n  { if ( !(hmod = GetModuleHandle(module)) )\n    { hmod = GetModuleHandle(\"libswipl.dll\");\n      DEBUG(0,\n\t    Sdprintf(\"Warning: could not find module from \\\"%s\\\"\\n\"\n\t\t     \"Warning: Trying %s to find home\\n\",\n\t\t     module,\n\t\t     hmod ? \"\\\"LIBPL.DLL\\\"\" : \"executable\"));\n    }\n  } else\n    hmod = NULL;\n\n  if ( (n = GetModuleFileNameW(hmod, wbuf, MAXPATHLEN)) > 0 )\n  { wbuf[n] = EOS;\n    return _xos_long_file_name_toA(wbuf, exe, exelen);\n  } else if ( module )\n  { return PrologPath(module, exe, exelen);\n  } else\n    *exe = EOS;\n\n  return exe;\n}\n\n\t\t /*******************************\n\t\t *     SUPPORT FOR SHELL/2\t*\n\t\t *******************************/\n\ntypedef struct\n{ const char *name;\n  UINT        id;\n} showtype;\n\nstatic int\nget_showCmd(term_t show, UINT *cmd)\n{ char *s;\n  showtype *st;\n  static showtype types[] =\n  { { \"hide\",\t\t SW_HIDE },\n    { \"maximize\",\t SW_MAXIMIZE },\n    { \"minimize\",\t SW_MINIMIZE },\n    { \"restore\",\t SW_RESTORE },\n    { \"show\",\t\t SW_SHOW },\n    { \"showdefault\",\t SW_SHOWDEFAULT },\n    { \"showmaximized\",   SW_SHOWMAXIMIZED },\n    { \"showminimized\",   SW_SHOWMINIMIZED },\n    { \"showminnoactive\", SW_SHOWMINNOACTIVE },\n    { \"showna\",          SW_SHOWNA },\n    { \"shownoactive\",    SW_SHOWNOACTIVATE },\n    { \"shownormal\",      SW_SHOWNORMAL },\n\t\t\t\t\t/* compatibility */\n    { \"normal\",\t\t SW_SHOWNORMAL },\n    { \"iconic\",\t\t SW_MINIMIZE },\n    { NULL, 0 },\n  };\n\n  if ( show == 0 )\n  { *cmd = SW_SHOWNORMAL;\n    succeed;\n  }\n\n  if ( !PL_get_chars(show, &s, CVT_ATOM|CVT_EXCEPTION) )\n    fail;\n  for(st=types; st->name; st++)\n  { if ( streq(st->name, s) )\n    { *cmd = st->id;\n      succeed;\n    }\n  }\n\n  return PL_error(NULL, 0, NULL, ERR_DOMAIN,\n\t\t  PL_new_atom(\"win_show\"), show);\n}\n\n\n\nstatic int\nwin_exec(size_t len, const wchar_t *cmd, UINT show)\n{ GET_LD\n  STARTUPINFOW startup;\n  PROCESS_INFORMATION info;\n  int rval;\n  wchar_t *wcmd;\n\n  memset(&startup, 0, sizeof(startup));\n  startup.cb = sizeof(startup);\n  startup.wShowWindow = show;\n\n\t\t\t\t\t/* ensure 0-terminated */\n  wcmd = PL_malloc((len+1)*sizeof(wchar_t));\n  memcpy(wcmd, cmd, len*sizeof(wchar_t));\n  wcmd[len] = 0;\n\n  rval = CreateProcessW(NULL,\t\t/* app */\n\t\t\twcmd,\n\t\t\tNULL, NULL,\t/* security */\n\t\t\tFALSE,\t\t/* inherit handles */\n\t\t\t0,\t\t/* flags */\n\t\t\tNULL,\t\t/* environment */\n\t\t\tNULL,\t\t/* Directory */\n\t\t\t&startup,\n\t\t\t&info);\t\t/* process info */\n  PL_free(wcmd);\n\n  if ( rval )\n  { CloseHandle(info.hProcess);\n    CloseHandle(info.hThread);\n\n    succeed;\n  } else\n  { term_t tmp = PL_new_term_ref();\n\n    return ( PL_unify_wchars(tmp, PL_ATOM, len, cmd) &&\n\t     PL_error(NULL, 0, WinError(), ERR_SHELL_FAILED, tmp)\n\t   );\n  }\n}\n\n\nstatic void\nutf8towcs(wchar_t *o, const char *src)\n{ for( ; *src; )\n  { int wc;\n\n    src = utf8_get_char(src, &wc);\n    *o++ = wc;\n  }\n  *o = 0;\n}\n\n\nint\nSystem(char *command)\t\t\t/* command is a UTF-8 string */\n{ STARTUPINFOW sinfo;\n  PROCESS_INFORMATION pinfo;\n  int shell_rval;\n  size_t len;\n  wchar_t *wcmd;\n\n  memset(&sinfo, 0, sizeof(sinfo));\n  sinfo.cb = sizeof(sinfo);\n\n  len = utf8_strlen(command, strlen(command));\n  wcmd = PL_malloc((len+1)*sizeof(wchar_t));\n  utf8towcs(wcmd, command);\n\n  if ( CreateProcessW(NULL,\t\t\t/* module */\n\t\t      wcmd,\t\t\t/* command line */\n\t\t      NULL,\t\t\t/* Security stuff */\n\t\t      NULL,\t\t\t/* Thread security stuff */\n\t\t      FALSE,\t\t\t/* Inherit handles */\n\t\t      CREATE_NO_WINDOW,\t\t/* flags */\n\t\t      NULL,\t\t\t/* environment */\n\t\t      NULL,\t\t\t/* CWD */\n\t\t      &sinfo,\t\t\t/* startup info */\n\t\t      &pinfo) )\t\t\t/* process into */\n  { BOOL rval;\n    DWORD code;\n\n    CloseHandle(pinfo.hThread);\t\t\t/* don't need this */\n    PL_free(wcmd);\n\n    do\n    { MSG msg;\n\n      if ( PeekMessage(&msg, NULL, 0, 0, PM_REMOVE) )\n      { TranslateMessage(&msg);\n\tDispatchMessage(&msg);\n      } else\n\tSleep(50);\n\n      rval = GetExitCodeProcess(pinfo.hProcess, &code);\n    } while(rval == TRUE && code == STILL_ACTIVE);\n\n    shell_rval = (rval == TRUE ? code : -1);\n    CloseHandle(pinfo.hProcess);\n  } else\n  { PL_free(wcmd);\n    return shell_rval = -1;\n  }\n\n  return shell_rval;\n}\n\n\nword\npl_win_exec(term_t cmd, term_t how)\n{ wchar_t *s;\n  size_t len;\n  UINT h;\n\n  if ( PL_get_wchars(cmd, &len, &s, CVT_ALL|CVT_EXCEPTION) &&\n       get_showCmd(how, &h) )\n  { return win_exec(len, s, h);\n  } else\n    fail;\n}\n\ntypedef struct\n{ int   eno;\n  const char *message;\n} shell_error;\n\nstatic const shell_error se_errors[] =\n{ { 0 ,                     \"Out of memory or resources\" },\n  { ERROR_FILE_NOT_FOUND,   \"File not found\" },\n  { ERROR_PATH_NOT_FOUND,   \"path not found\" },\n  { ERROR_BAD_FORMAT,\t    \"Invalid .EXE\" },\n  { SE_ERR_ACCESSDENIED,    \"Access denied\" },\n  { SE_ERR_ASSOCINCOMPLETE, \"Incomplete association\" },\n  { SE_ERR_DDEBUSY,\t    \"DDE server busy\" },\n  { SE_ERR_DDEFAIL,         \"DDE transaction failed\" },\n  { SE_ERR_DDETIMEOUT,\t    \"DDE request timed out\" },\n  { SE_ERR_DLLNOTFOUND,\t    \"DLL not found\" },\n  { SE_ERR_FNF,\t\t    \"File not found (FNF)\" },\n  { SE_ERR_NOASSOC,\t    \"No association\" },\n  { SE_ERR_OOM,\t\t    \"Not enough memory\" },\n  { SE_ERR_PNF,\t\t    \"Path not found (PNF)\" },\n  { SE_ERR_SHARE,\t    \"Sharing violation\" },\n  { 0,\t\t\t    NULL }\n};\n\n\nstatic int\nwin_shell(term_t op, term_t file, term_t how)\n{ size_t lo, lf;\n  wchar_t *o, *f;\n  UINT h;\n  HINSTANCE instance;\n\n  if ( !PL_get_wchars(op,   &lo, &o, CVT_ALL|CVT_EXCEPTION|BUF_RING) ||\n       !PL_get_wchars(file, &lf, &f, CVT_ALL|CVT_EXCEPTION|BUF_RING) ||\n       !get_showCmd(how, &h) )\n    fail;\n\n  instance = ShellExecuteW(NULL, o, f, NULL, NULL, h);\n\n  if ( (intptr_t)instance <= 32 )\n  { const shell_error *se;\n\n    for(se = se_errors; se->message; se++)\n      { if ( se->eno == (int)(intptr_t)instance )\n\treturn PL_error(NULL, 0, se->message, ERR_SHELL_FAILED, file);\n    }\n    PL_error(NULL, 0, NULL, ERR_SHELL_FAILED, file);\n  }\n\n  succeed;\n}\n\n\nstatic\nPRED_IMPL(\"win_shell\", 2, win_shell2, 0)\n{ return win_shell(A1, A2, 0);\n}\n\n\nstatic\nPRED_IMPL(\"win_shell\", 3, win_shell3, 0)\n{ return win_shell(A1, A2, A3);\n}\n\n\nforeign_t\npl_win_module_file(term_t module, term_t file)\n{ char buf[MAXPATHLEN];\n  char *m;\n  char *f;\n\n  if ( !PL_get_chars(module, &m, CVT_ALL|CVT_EXCEPTION) )\n    fail;\n  if ( (f = findExecutable(m, buf, sizeof(buf))) )\n    return PL_unify_atom_chars(file, f);\n\n  fail;\n}\n\n\t\t /*******************************\n\t\t *\t  WINDOWS MESSAGES\t*\n\t\t *******************************/\n\nLRESULT\nPL_win_message_proc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)\n{\n#ifdef O_PLMT\n  if ( hwnd == NULL &&\n       message == WM_SIGNALLED &&\n       wParam == 0 &&\t\t\t/* or another constant? */\n       lParam == 0 )\n  { if ( PL_handle_signals() < 0 )\n      return PL_MSG_EXCEPTION_RAISED;\n\n    return PL_MSG_HANDLED;\n  }\n#endif\n\n  return PL_MSG_IGNORED;\n}\n\n\n\t\t /*******************************\n\t\t *\tDLOPEN AND FRIENDS\t*\n\t\t *******************************/\n\n#ifdef EMULATE_DLOPEN\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nThese functions emulate the bits from the ELF shared object interface we\nneed. They are used  by  pl-load.c,   which  defines  the  actual Prolog\ninterface.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n#ifdef HAVE_LIBLOADERAPI_H\n#include <LibLoaderAPI.h>\n#else\n#ifndef LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR\n#define LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR 0x00000100\n#endif\n#ifndef LOAD_LIBRARY_SEARCH_DEFAULT_DIRS\n#define LOAD_LIBRARY_SEARCH_DEFAULT_DIRS 0x00001000\n#endif\ntypedef void * DLL_DIRECTORY_COOKIE;\n#endif\n\nstatic const char *dlmsg;\nstatic DLL_DIRECTORY_COOKIE WINAPI (*f_AddDllDirectoryW)(wchar_t* dir);\nstatic BOOL WINAPI (*f_RemoveDllDirectory)(DLL_DIRECTORY_COOKIE);\n\nstatic DWORD\nload_library_search_flags(void)\n{ static int done = FALSE;\n  static DWORD flags = 0;\n\n  if ( !done )\n  { HMODULE kernel = GetModuleHandle(TEXT(\"kernel32.dll\"));\n\n    if ( (f_AddDllDirectoryW   = (void*)GetProcAddress(kernel, \"AddDllDirectory\")) &&\n\t (f_RemoveDllDirectory = (void*)GetProcAddress(kernel, \"RemoveDllDirectory\")) )\n    { flags = ( LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR|\n\t\tLOAD_LIBRARY_SEARCH_DEFAULT_DIRS );\n    }\n    done = TRUE;\n  }\n\n  return flags;\n}\n\n\nstatic\nPRED_IMPL(\"win_add_dll_directory\", 2, win_add_dll_directory, 0)\n{ PRED_LD\n  char *dirs;\n\n  if ( PL_get_file_name(A1, &dirs, REP_UTF8) )\n  { size_t len = utf8_strlen(dirs, strlen(dirs));\n    wchar_t *dirw = alloca((len+10)*sizeof(wchar_t));\n    DLL_DIRECTORY_COOKIE cookie;\n\n    if ( _xos_os_filenameW(dirs, dirw, len+10) == NULL )\n      return PL_representation_error(\"file_name\");\n    if ( load_library_search_flags() )\n    { if ( (cookie = (*f_AddDllDirectoryW)(dirw)) )\n\treturn PL_unify_int64(A2, (int64_t)(uintptr_t)cookie);\n      return PL_error(NULL, 0, WinError(), ERR_SYSCALL, \"AddDllDirectory()\");\n    } else\n      return FALSE;\n  } else\n    return FALSE;\n}\n\n\nstatic\nPRED_IMPL(\"win_remove_dll_directory\", 1, win_remove_dll_directory, 0)\n{ int64_t icookie;\n\n  if ( PL_get_int64_ex(A1, &icookie) )\n  { if ( f_RemoveDllDirectory )\n    { if ( (*f_RemoveDllDirectory)((DLL_DIRECTORY_COOKIE)(uintptr_t)icookie) )\n\treturn TRUE;\n\n      return PL_error(NULL, 0, WinError(), ERR_SYSCALL, \"RemoveDllDirectory()\");\n    } else\n      return FALSE;\n  } else\n    return FALSE;\n}\n\n\nstatic int\nis_windows_abs_path(const wchar_t *path)\n{ if ( path[1] == ':' && path[0] < 0x80 && iswalpha(path[0]) )\n    return TRUE;\t\t\t/* drive */\n  if ( path[0] == '\\\\' && path[1] == '\\\\' )\n    return TRUE;\t\t\t/* UNC */\n\n  return FALSE;\n}\n\nvoid *\nPL_dlopen(const char *file, int flags)\t/* file is in UTF-8, POSIX path */\n{ HINSTANCE h;\n  DWORD llflags = 0;\n  size_t len = utf8_strlen(file, strlen(file));\n  wchar_t *wfile = alloca((len+10)*sizeof(wchar_t));\n\n  if ( !wfile )\n  { dlmsg = \"No memory\";\n    return NULL;\n  }\n\n  if ( _xos_os_filenameW(file, wfile, len+10) == NULL )\n  { dlmsg = \"Name too long\";\n    return NULL;\n  }\n\n  if ( is_windows_abs_path(wfile) )\n    llflags |= load_library_search_flags();\n\n  if ( (h = LoadLibraryExW(wfile, NULL, llflags)) )\n  { dlmsg = \"No Error\";\n    return (void *)h;\n  }\n\n  dlmsg = WinError();\n  return NULL;\n}\n\n\nconst char *\nPL_dlerror(void)\n{ return dlmsg;\n}\n\n\nvoid *\nPL_dlsym(void *handle, char *symbol)\n{ void *addr = GetProcAddress(handle, symbol);\n\n  if ( addr )\n  { dlmsg = \"No Error\";\n    return addr;\n  }\n\n  dlmsg = WinError();\n  return NULL;\n}\n\n\nint\nPL_dlclose(void *handle)\n{ FreeLibrary(handle);\n\n  return 0;\n}\n\n#endif /*EMULATE_DLOPEN*/\n\n\n\t\t /*******************************\n\t\t *\t SNPRINTF MADNESS\t*\n\t\t *******************************/\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nMS-Windows _snprintf() may look like C99 snprintf(), but is is not quite\nthe same: on overflow, the buffer is   *not* 0-terminated and the return\nis negative (unspecified how negative).  The   code  below  works around\nthis, returning count on overflow. This is still not the same as the C99\nversion that returns the  number  of   characters  that  would have been\nwritten, but it seems to be enough for our purposes.\n\nSee http://www.di-mgt.com.au/cprog.html#snprintf\n\nThe above came from the provided link, but it is even worse (copied from\nVS2005 docs):\n\n  - If len < count, then len characters are stored in buffer, a\n  null-terminator is appended, and len is returned.\n\n  - If len = count, then len characters are stored in buffer, no\n  null-terminator is appended, and len is returned.\n\n  - If len > count, then count characters are stored in buffer, no\n  null-terminator is appended, and a negative value is returned.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\nint\nms_snprintf(char *buffer, size_t count, const char *fmt, ...)\n{ va_list ap;\n  int ret;\n\n  va_start(ap, fmt);\n  ret = _vsnprintf(buffer, count-1, fmt, ap);\n  va_end(ap);\n\n  if ( ret < 0 || ret == count )\n  { ret = (int)count;\n    buffer[count-1] = '\\0';\n  }\n\n  return ret;\n}\n\n\n\n\t\t /*******************************\n\t\t *\t      FOLDERS\t\t*\n\t\t *******************************/\n\n#ifdef HAVE_SHLOBJ_H\n#include <shlobj.h>\n#endif\n\ntypedef struct folderid\n{ int csidl;\n  const char *name;\n} folderid;\n\nstatic const folderid folderids[] =\n{ { CSIDL_COMMON_ALTSTARTUP, \"common_altstartup\" },\n  { CSIDL_ALTSTARTUP, \"altstartup\" },\n  { CSIDL_APPDATA, \"appdata\" },\n  { CSIDL_CONTROLS, \"controls\" },\n  { CSIDL_COOKIES, \"cookies\" },\n  { CSIDL_DESKTOP, \"desktop\" },\n  { CSIDL_COMMON_DESKTOPDIRECTORY, \"common_desktopdirectory\" },\n  { CSIDL_DESKTOPDIRECTORY, \"desktopdirectory\" },\n  { CSIDL_COMMON_FAVORITES, \"common_favorites\" },\n  { CSIDL_FAVORITES, \"favorites\" },\n  { CSIDL_FONTS, \"fonts\" },\n  { CSIDL_HISTORY, \"history\" },\n  { CSIDL_INTERNET_CACHE, \"internet_cache\" },\n  { CSIDL_INTERNET, \"internet\" },\n  { CSIDL_DRIVES, \"drives\" },\n  { CSIDL_PERSONAL, \"personal\" },\n  { CSIDL_NETWORK, \"network\" },\n  { CSIDL_NETHOOD, \"nethood\" },\n  { CSIDL_PERSONAL, \"personal\" },\n  { CSIDL_PRINTERS, \"printers\" },\n  { CSIDL_PRINTHOOD, \"printhood\" },\n  { CSIDL_COMMON_PROGRAMS, \"common_programs\" },\n  { CSIDL_PROGRAMS, \"programs\" },\n  { CSIDL_RECENT, \"recent\" },\n  { CSIDL_BITBUCKET, \"bitbucket\" },\n  { CSIDL_SENDTO, \"sendto\" },\n  { CSIDL_COMMON_STARTMENU, \"common_startmenu\" },\n  { CSIDL_STARTMENU, \"startmenu\" },\n  { CSIDL_COMMON_STARTUP, \"common_startup\" },\n  { CSIDL_STARTUP, \"startup\" },\n  { CSIDL_TEMPLATES, \"templates\" },\n  { 0, NULL }\n};\n\n\nstatic int\nunify_csidl_path(term_t t, int csidl)\n{ wchar_t buf[MAX_PATH];\n\n  if ( SHGetSpecialFolderPathW(0, buf, csidl, FALSE) )\n  { wchar_t *p;\n\n    for(p=buf; *p; p++)\n    { if ( *p == '\\\\' )\n\t*p = '/';\n    }\n\n    return PL_unify_wchars(t, PL_ATOM, -1, buf);\n  } else\n    return PL_error(NULL, 0, WinError(), ERR_SYSCALL, \"SHGetSpecialFolderPath\");\n}\n\n\nstatic\nPRED_IMPL(\"win_folder\", 2, win_folder, PL_FA_NONDETERMINISTIC)\n{ GET_LD\n  int n;\n\n  switch( CTX_CNTRL )\n  { case FRG_FIRST_CALL:\n      if ( PL_is_variable(A1) )\n      { n = 0;\n\tgoto generate;\n      } else\n      { char *s;\n\n\tif ( PL_get_chars(A1, &s, CVT_ATOM|CVT_EXCEPTION) )\n\t{ const folderid *fid;\n\n\t  for(fid = folderids; fid->name; fid++)\n\t  { if ( streq(s, fid->name) )\n\t      return unify_csidl_path(A2, fid->csidl);\n\t  }\n\n\t  { atom_t dom = PL_new_atom(\"win_folder\");\n\n\t    PL_error(NULL, 0, NULL, ERR_DOMAIN, dom, A1);\n\t    PL_unregister_atom(dom);\n\t    return FALSE;\n\t  }\n\t} else\n\t  return FALSE;\n      }\n    case FRG_REDO:\n    { fid_t fid;\n\n      n = (int)CTX_INT+1;\n\n      generate:\n\tfid = PL_open_foreign_frame();\n\tfor(; folderids[n].name; n++)\n\t{ if ( unify_csidl_path(A2, folderids[n].csidl) &&\n\t       PL_unify_atom_chars(A1, folderids[n].name) )\n\t  { PL_close_foreign_frame(fid);\n\t    ForeignRedoInt(n);\n\t  }\n\t  PL_rewind_foreign_frame(fid);\n\t}\n\tPL_close_foreign_frame(fid);\n\treturn FALSE;\n    }\n    default:\n      succeed;\n  }\n}\n\n\n\n\t\t /*******************************\n\t\t *\t      REGISTRY\t\t*\n\t\t *******************************/\n\n#define wstreq(s,q) (wcscmp((s), (q)) == 0)\n\nstatic HKEY\nreg_open_key(const wchar_t *which, int create)\n{ HKEY key = HKEY_CURRENT_USER;\n  DWORD disp;\n  LONG rval;\n\n  while(*which)\n  { wchar_t buf[256];\n    wchar_t *s;\n    HKEY tmp;\n\n    for(s=buf; *which && !(*which == '/' || *which == '\\\\'); )\n      *s++ = *which++;\n    *s = '\\0';\n    if ( *which )\n      which++;\n\n    if ( wstreq(buf, L\"HKEY_CLASSES_ROOT\") )\n    { key = HKEY_CLASSES_ROOT;\n      continue;\n    } else if ( wstreq(buf, L\"HKEY_CURRENT_USER\") )\n    { key = HKEY_CURRENT_USER;\n      continue;\n    } else if ( wstreq(buf, L\"HKEY_LOCAL_MACHINE\") )\n    { key = HKEY_LOCAL_MACHINE;\n      continue;\n    } else if ( wstreq(buf, L\"HKEY_USERS\") )\n    { key = HKEY_USERS;\n      continue;\n    }\n\n    DEBUG(2, Sdprintf(\"Trying %s\\n\", buf));\n    if ( RegOpenKeyExW(key, buf, 0L, KEY_READ, &tmp) == ERROR_SUCCESS )\n    { RegCloseKey(key);\n      key = tmp;\n      continue;\n    }\n\n    if ( !create )\n      return NULL;\n\n    rval = RegCreateKeyExW(key, buf, 0, L\"\", 0,\n\t\t\t  KEY_ALL_ACCESS, NULL, &tmp, &disp);\n    RegCloseKey(key);\n    if ( rval == ERROR_SUCCESS )\n      key = tmp;\n    else\n      return NULL;\n  }\n\n  return key;\n}\n\n#define MAXREGSTRLEN 1024\n\nstatic\nPRED_IMPL(\"win_registry_get_value\", 3, win_registry_get_value, 0)\n{ GET_LD\n  DWORD type;\n  union\n  { BYTE bytes[MAXREGSTRLEN];\n    wchar_t wchars[MAXREGSTRLEN/sizeof(wchar_t)];\n    DWORD dword;\n  } data;\n  DWORD len = sizeof(data);\n  size_t klen, namlen;\n  wchar_t *k, *name;\n  HKEY key;\n\n  term_t Key = A1;\n  term_t Name = A2;\n  term_t Value = A3;\n\n  if ( !PL_get_wchars(Key, &klen, &k, CVT_ATOM|CVT_EXCEPTION) ||\n       !PL_get_wchars(Name, &namlen, &name, CVT_ATOM|CVT_ATOM) )\n    return FALSE;\n  if ( !(key=reg_open_key(k, FALSE)) )\n    return PL_error(NULL, 0, NULL, ERR_EXISTENCE, ATOM_key, Key);\n\n  DEBUG(9, Sdprintf(\"key = %p, name = %s\\n\", key, name));\n  if ( RegQueryValueExW(key, name, NULL, &type, data.bytes, &len)\n\t\t\t\t\t\t\t== ERROR_SUCCESS )\n  { RegCloseKey(key);\n\n    switch(type)\n    { case REG_SZ:\n\treturn PL_unify_wchars(Value, PL_ATOM,\n\t\t\t       len/sizeof(wchar_t)-1, data.wchars);\n      case REG_DWORD:\n\treturn PL_unify_integer(Value, data.dword);\n      default:\n\twarning(\"get_registry_value/2: Unknown registery-type: %d\", type);\n        fail;\n    }\n  }\n\n  return FALSE;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nGet the local, global,  trail  and   argument-stack  defaults  from  the\nregistry.  They  can  be  on  the   HKEY_CURRENT_USER  as  well  as  the\nHKEY_LOCAL_MACHINE  registries  to  allow   for    both   user-only  and\nsystem-wide settings.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\nstatic struct regdef\n{ const char *name;\n  size_t     *address;\n} const regdefs[] =\n{ { \"stackLimit\",   &GD->defaults.stack_limit },\n  { \"tableSpace\",   &GD->defaults.table_space },\n  { NULL,           NULL }\n};\n\n\nstatic void\nsetStacksFromKey(HKEY key)\n{ DWORD type;\n  union\n  { BYTE bytes[128];\n    DWORD dword;\n  } data;\n  DWORD len = sizeof(data);\n  const struct regdef *rd;\n\n  for(rd = regdefs; rd->name; rd++)\n  { if ( RegQueryValueEx(key, rd->name, NULL, &type, data.bytes, &len) ==\n\t\t\t\t\t\t\tERROR_SUCCESS &&\n\t type == REG_DWORD )\n    { DWORD v = data.dword;\n\n      *rd->address = (size_t)v;\n    }\n  }\n}\n\n\nvoid\ngetDefaultsFromRegistry(void)\n{ HKEY key;\n\n  if ( (key = reg_open_key(L\"HKEY_LOCAL_MACHINE/Software/SWI/Prolog\", FALSE)) )\n  { setStacksFromKey(key);\n    RegCloseKey(key);\n  }\n  if ( (key = reg_open_key(L\"HKEY_CURRENT_USER/Software/SWI/Prolog\", FALSE)) )\n  { setStacksFromKey(key);\n    RegCloseKey(key);\n  }\n}\n\n\nconst char *\nPL_w32_running_under_wine(void)\n{ static const char * (CDECL *pwine_get_version)(void);\n  HMODULE hntdll = GetModuleHandle(\"ntdll.dll\");\n\n  if ( !hntdll )\n  { return NULL;\n  }\n\n  if ( (pwine_get_version = (void *)GetProcAddress(hntdll, \"wine_get_version\")) )\n    return pwine_get_version();\n\n  return NULL;\n}\n\n\n\t\t /*******************************\n\t\t *      PUBLISH PREDICATES\t*\n\t\t *******************************/\n\nBeginPredDefs(win)\n  PRED_DEF(\"win_shell\", 2, win_shell2, 0)\n  PRED_DEF(\"win_shell\", 3, win_shell3, 0)\n  PRED_DEF(\"win_registry_get_value\", 3, win_registry_get_value, 0)\n  PRED_DEF(\"win_folder\", 2, win_folder, PL_FA_NONDETERMINISTIC)\n  PRED_DEF(\"win_add_dll_directory\", 2, win_add_dll_directory, 0)\n  PRED_DEF(\"win_remove_dll_directory\", 1, win_remove_dll_directory, 0)\nEndPredDefs\n\n#endif /*__WINDOWS__*/\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/src/pl-load.c": "/*  Part of SWI-Prolog\n\n    Author:        Jan Wielemaker\n    E-mail:        J.Wielemaker@vu.nl\n    WWW:           http://www.swi-prolog.org\n    Copyright (c)  1985-2018, University of Amsterdam\n                              VU University Amsterdam\n    All rights reserved.\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n    1. Redistributions of source code must retain the above copyright\n       notice, this list of conditions and the following disclaimer.\n\n    2. Redistributions in binary form must reproduce the above copyright\n       notice, this list of conditions and the following disclaimer in\n       the documentation and/or other materials provided with the\n       distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n    COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n    ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n    POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#include \"pl-incl.h\"\n#ifndef MAXPATHLEN\n#define MAXPATHLEN 1024\n#endif\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nSWI-Prolog interface for runtime loading of foreign code (plugins).\n\nCurrently, this interface is implemented only  for ELF systems (based on\ndlopen()) and HPUX (based on slh_load()).   Despite, this covers a large\nnumber of modern Unix platforms. To name a few: Solaris, Linux, freeBSD,\nIRIX, HPUX, MacOS X.\n\nFor some platforms we emulate the ELF   interface and set the cpp symbol\nEMULATE_DLOPEN. You find examples in pl-nt.c   (for Win32) and pl-beos.c\n(for BeOS).\n\nBasically, 3 operations are required:\n\n\topen_shared_object(+File, [+Options], -Handle)\n\t    Load a shared object into the current image.\n\n\tcall_shared_object_function(+Handle, +FunctionName)\n\t    Call a named function without arguments.  Return value\n\t    is ignored too.\n\n\tclose_shared_object(+Handle)\n\t    Unload a shared object.\n\nFeel free to add this functionality for your favorite OS and mail me the\ncontributions.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n\n\t\t /*******************************\n\t\t *     DLOPEN() AND FRIENDS\t*\n\t\t *******************************/\n\n#ifndef EMULATE_DLOPEN\n#ifdef HAVE_DLOPEN\t\t\t/* sysvr4, elf binaries */\n\n#ifdef HAVE_DLFCN_H\n#include <dlfcn.h>\n#endif\n\n#else /*HAVE_DLOPEN*/\n\n#ifdef HAVE_SHL_LOAD\t\t\t/* HPUX */\n\n#include <dl.h>\n#define dlopen(path, flags) shl_load((path), (flags), 0L)\n#define dlclose(handle)\t    shl_unload((handle))\n#define dlerror()\t    OsError()\n\nvoid *\ndlsym(void *handle, const char *name)\n{ void *value;\n  shl_t h = handle;\n\n  if ( shl_findsym(&h, name, TYPE_PROCEDURE, &value) < 0 )\n    return NULL;\n\n  return value;\n}\n\n#define RTLD_LAZY\tBIND_DEFERRED\n#ifdef BIND_IMMEDIATE\n#define RTLD_NOW\tBIND_IMMEDIATE\n#endif\n\n#endif /*HAVE_SHL_LOAD*/\n#endif /*HAVE_DLOPEN*/\n#endif /*EMULATE_DLOPEN*/\n\n#if defined(HAVE_DLOPEN) || defined(HAVE_SHL_LOAD) || defined(EMULATE_DLOPEN)\n#define HAVE_SHARED_OBJECTS\n\n#ifndef RTLD_GLOBAL\t\t\t/* solaris defines this */\n#define RTLD_GLOBAL 0\n#endif\n#ifndef RTLD_NOW\t\t\t/* implicit on some versions */\n#define RTLD_NOW 0\n#endif\n#ifndef RTLD_LAZY\t\t\t/* freeBSD doesn't have this? */\n#define RTLD_LAZY 0\n#endif\n\ntypedef int (*dl_funcptr)();\n\ntypedef struct dl_entry *DlEntry;\nstruct dl_entry\n{ int\t  id;\t\t\t\t/* Prolog's identifier */\n  void   *dlhandle;\t\t\t/* DL libraries identifier */\n  atom_t  file;\t\t\t\t/* Loaded filed */\n  DlEntry next;\t\t\t\t/* Next in table */\n};\n\nint\tdl_plid;\t\t\t/* next id to give */\nDlEntry dl_head;\t\t\t/* loaded DL's */\nDlEntry dl_tail;\t\t\t/* end of this chain */\n\n#define DL_NOW\t  0x1\n#define DL_GLOBAL 0x2\n\n#ifndef EMULATE_DLOPEN\nvoid *\nPL_dlopen(const char *file, int flags)\n{ return dlopen(file, flags);\n}\n\nconst char *\nPL_dlerror(void)\n{ return dlerror();\n}\n\nvoid *\nPL_dlsym(void *handle, char *symbol)\n{ return dlsym(handle, symbol);\n}\n\nint\nPL_dlclose(void *handle)\n{ return dlclose(handle);\n}\n\n#endif /*EMULATE_DLOPEN*/\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nunder_valgrind()\n\nTrue if we are running under valgrind.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n#ifdef HAVE_VALGRIND_VALGRIND_H\n#include <valgrind/valgrind.h>\n#else\n#define RUNNING_ON_VALGRIND (getenv(\"VALGRIND_OPTS\") != NULL)\n#endif\n\nstatic int\nunder_valgrind(void)\n{ static int vg = -1;\n\n  if ( vg == -1 )\n  {\n#ifdef RUNNING_ON_VALGRIND\n    if ( RUNNING_ON_VALGRIND )\n      vg = TRUE;\n    else\n#endif\n      vg = FALSE;\n  }\n\n  return vg;\n}\n\n\nstatic\nPRED_IMPL(\"$open_shared_object\", 3, open_shared_object, 0)\n{ PRED_LD\n  void *dlhandle;\n  char *fn;\n  atom_t afile;\n  DlEntry e;\n  int dlflags;\n  int n;\n\n  term_t file     = A1;\n  term_t plhandle = A2;\n  term_t flags    = A3;\n\n\n  if ( PL_get_integer(flags, &n) )\n  { dlflags = (n & DL_NOW) ? RTLD_NOW : RTLD_LAZY;\n    if ( n & DL_GLOBAL )\n      dlflags |= RTLD_GLOBAL;\n  } else\n    dlflags = RTLD_LAZY;\n\n  if ( !PL_get_atom_ex(file, &afile) ||\n       !PL_get_file_name(file, &fn, 0) )\n    fail;\n  if ( !(dlhandle = PL_dlopen(fn, dlflags)) )\n    return PL_error(NULL, 0, NULL, ERR_SHARED_OBJECT_OP,\n\t\t    ATOM_open, PL_dlerror());\n\n  e = allocHeapOrHalt(sizeof(struct dl_entry));\n\n  PL_LOCK(L_FOREIGN);\n  e->id       = ++dl_plid;\n  e->dlhandle = dlhandle;\n  e->file     = afile;\n  e->next     = NULL;\n\n  if ( !dl_tail )\n  { dl_tail = e;\n    dl_head = e;\n  } else\n  { dl_tail->next = e;\n    dl_tail = e;\n  }\n  PL_UNLOCK(L_FOREIGN);\n\n  return PL_unify_integer(plhandle, e->id);\n}\n\n\nstatic DlEntry\nfind_dl_entry(term_t h)\n{ GET_LD\n  DlEntry e;\n  int id;\n\n  if ( PL_get_integer(h, &id) )\n  { for(e = dl_head; e; e = e->next)\n    { if ( e->id == id )\n\treturn e;\n    }\n    PL_error(NULL, 0, NULL, ERR_EXISTENCE, ATOM_shared_object_handle, h);\n    return NULL;\n  }\n\n  PL_error(NULL, 0, NULL, ERR_TYPE, ATOM_shared_object_handle, h);\n\n  return NULL;\n}\n\n\nstatic\nPRED_IMPL(\"close_shared_object\", 1, close_shared_object, 0)\n{ DlEntry e = find_dl_entry(A1);\n\n  if ( e && e->dlhandle)\n  { if ( !under_valgrind() )\n      PL_dlclose(e->dlhandle);\n    e->dlhandle = NULL;\n\n    succeed;\n  }\n\n  fail;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nSome systems (notably MacOS X) prefixes symbols with _. In some version\nof this OS, dlsym() adds an _, in others not.  We'll try to work around\nthis junk with a runtime test ...\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\nstatic\nPRED_IMPL(\"call_shared_object_function\", 2, call_shared_object_function,\n\t  PL_FA_TRANSPARENT)\n{ DlEntry e = find_dl_entry(A1);\n  char *fname;\n  dl_funcptr ef;\n\n  if ( !e || !e->dlhandle ||\n       !PL_get_chars(A2, &fname, CVT_ALL|CVT_EXCEPTION) )\n    fail;\n\n#ifdef LD_SYMBOL_PREFIX\t\t\t/* first try plain anyway */\n  if ( !(ef = (dl_funcptr) PL_dlsym(e->dlhandle, fname)) )\n  { char symname[MAXSYMBOLLEN+1];\n\n    if ( strlen(fname)+strlen(LD_SYMBOL_PREFIX) > MAXSYMBOLLEN )\n      return PL_error(NULL, 0,\n\t\t      \"Symbol too long\",\n\t\t      ERR_REPRESENTATION,\n\t\t      PL_new_atom(\"symbol\"));\n\n    strcpy(symname, LD_SYMBOL_PREFIX);\n    strcat(symname, fname);\n    ef = (dl_funcptr) dlsym(e->dlhandle, symname);\n  }\n#else\n  ef = (dl_funcptr) PL_dlsym(e->dlhandle, fname);\n#endif\n  if ( ef )\n  { (*ef)();\n    succeed;\n  } else\n    fail;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nUnload all foreign libraries.  As we are doing this at the very end of\nthe cleanup, it should be safe now.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\nvoid\ncleanupForeign(void)\n{ DlEntry e, next;\n\n  for(e = dl_head; e; e = next)\n  { next = e->next;\n\n    if ( e->dlhandle )\n    { if ( !under_valgrind() )\n\tPL_dlclose(e->dlhandle);\n    }\n\n    freeHeap(e, sizeof(*e));\n  }\n\n  dl_plid = 0;\n  dl_head = dl_tail = NULL;\n}\n\n#else /*HAVE_DLOPEN*/\n\n/* No-op stub for pl-init.c to call. */\nvoid\ncleanupForeign(void)\n{}\n\nstatic\nPRED_IMPL(\"$open_shared_object\", 3, open_shared_object, 0)\n{ return notImplemented(\"open_shared_object\", 3);\n}\n\n#endif /*HAVE_DLOPEN*/\n\n\t\t /*******************************\n\t\t *      PUBLISH PREDICATES\t*\n\t\t *******************************/\n\nBeginPredDefs(dlopen)\n  PRED_DEF(\"$open_shared_object\", 3, open_shared_object, 0)\n#ifdef HAVE_SHARED_OBJECTS\n  PRED_DEF(\"close_shared_object\", 1, close_shared_object, 0)\n  PRED_DEF(\"call_shared_object_function\", 2, call_shared_object_function,\n\t   PL_FA_TRANSPARENT)\n#endif\nEndPredDefs\n",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/src/pl-beos.c": "/*  Part of SWI-Prolog\n\n    Author:        Alex D\u00f6rfler\n    E-mail:        axeld@pinc-software.de\n    WWW:           http://www.swi-prolog.org\n    Copyright (c)  2002-2018, University of Amsterdam\n    All rights reserved.\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n    1. Redistributions of source code must retain the above copyright\n       notice, this list of conditions and the following disclaimer.\n\n    2. Redistributions in binary form must reproduce the above copyright\n       notice, this list of conditions and the following disclaimer in\n       the documentation and/or other materials provided with the\n       distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n    COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n    ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n    POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nThis module is  written  by   Alex  D\u00f6rfler,  axeld@pinc-software.de and\nintegrated into SWI-Prolog by Jan Wielemaker.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n#ifdef __BEOS__\n#include \"pl-incl.h\"\n\n\n\t\t /*******************************\n\t\t *\tDLOPEN AND FRIENDS\t*\n\t\t *******************************/\n\n#ifdef EMULATE_DLOPEN\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nThese functions emulate the bits from the ELF shared object interface we\nneed. They are used  by  pl-load.c,   which  defines  the  actual Prolog\ninterface.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\nvoid *\nPL_dlopen(const char *file, int flags)\n{ image_id image = load_add_on(file);\n\n  if ( image < B_OK )\n  { LD->os.dl_error = image;\n    return NULL;\n  }\n\n  LD->os.dl_error = B_OK;\n  return (void *)image;\n}\n\n\nconst char *\nPL_dlerror()\n{ return strerror(LD->os.dl_error);\n}\n\n\nvoid *\nPL_dlsym(void *handle, char *symbol)\n{ void *address;\n\n  LD->os.dl_error = get_image_symbol((image_id)handle,\n\t\t\t\t     symbol,\n\t\t\t\t     B_SYMBOL_TYPE_TEXT,\n\t\t\t\t     &address);\n  if ( LD->os.dl_error == B_OK )\n    return address;\n\n  return NULL;\n}\n\n\nint\nPL_dlclose(void *handle)\n{ return unload_add_on((image_id)handle);\n}\n\n#endif\t/* EMULATE_DLOPEN */\n\n#endif\t/* __BEOS__ */\n",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/src/x11/x11-compat.c": "/*  Part of XPCE --- The SWI-Prolog GUI toolkit\n\n    Author:        Jan Wielemaker and Anjo Anjewierden\n    E-mail:        jan@swi.psy.uva.nl\n    WWW:           http://www.swi.psy.uva.nl/projects/xpce/\n    Copyright (c)  1985-2002, University of Amsterdam\n    All rights reserved.\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n    1. Redistributions of source code must retain the above copyright\n       notice, this list of conditions and the following disclaimer.\n\n    2. Redistributions in binary form must reproduce the above copyright\n       notice, this list of conditions and the following disclaimer in\n       the documentation and/or other materials provided with the\n       distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n    COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n    ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n    POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#include <h/kernel.h>\n#include <h/graphics.h>\n\n\t\t/********************************\n\t\t*            HACKS ...\t\t*\n\t\t********************************/\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nWho  the   hell is using  these!?   It doesn't  seem  to be  the X11R5\nlibraries.  It certainly ain't PCE itself.  Nevertheless someone seems\nto refer  to them.  Unfortunately they only  in a dynamic library  and\nthus cannot be loaded through many foreign  language interfaces.  What\nto do????\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n#if !defined(HAVE_LIBDL) && defined(__sun__) && XT_REVISION == 5\n\nvoid *\ndlopen(char *path, int mode)\n{ Cprintf(\"dlopen(%s, %d)\\n\", path, mode);\n\n  return NULL;\n}\n\n\nvoid *\ndlsym(void *handle, char *symbol)\n{ Cprintf(\"dlsym(%p, %s)\\n\", handle, symbol);\n\n  return NULL;\n}\n\n\nvoid *\ndlclose(void *handle)\n{ Cprintf(\"dlclose (%p)\\n\", handle);\n\n  return NULL;\n}\n\n#endif\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nMore of this nonsens.  RS6000 this time ...\n\n\tnm -pgo /usr/lib/libX11.a | grep _iconv_open\n\tshr4.o:         U __iconv_open\n\tshr4.o:0000fc18 T .__iconv_open\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n#if _AIX\nvoid *\n__iconv_open()\n{ Cprintf(\"_iconv_open() called\\n\");\n\n  return NULL;\n}\n#endif\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/src/swipl.ico",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/src/minizip/file.zip",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/src/libtai/leapsecs.dat",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/src/Tests/charset/UTF-8-test.txt",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/man/figs/xrefchatdep.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/man/figs/broadcast.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/man/figs/swipl.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/man/figs/xrefchatfile.gif",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/man/figs/by-sa.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/man/figs/broadcast.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/man/figs/profnode.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/man/figs/profnode.gif",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/man/figs/swipl.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/man/figs/by-sa.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/man/figs/xrefchatfile.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/man/figs/xrefchatdep.gif",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/ssl/etc/client/client-cert.p12",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/RDF/suite/t38.rdf",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/ltx2htm/icons/next.gif",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/ltx2htm/icons/prev.gif",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/ltx2htm/icons/home.gif",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/ltx2htm/icons/index.gif",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/ltx2htm/icons/yellow_pages.gif",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/ltx2htm/icons/up.gif",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/ltx2htm/icons/info.gif",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/swipl-win/swipl.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/swipl-win/swipl.icns",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/table/test.dat",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/zlib/tests/binary-file.gz",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/zlib/tests/ascii-file.gz",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/zlib/tests/utf8-file.gz",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/zlib/tests/multipart-file.gz",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/zlib/tests/empty-file.gz",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/zlib/tests/low-compression.gz",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/zlib/tests/high-compression.gz",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/semweb/modules.gif",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/semweb/figs/modules.pd",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/semweb/figs/modules.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/semweb/Tests/test-002.rdf.gz",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/protobufs/golden_message.2.5.0",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/protobufs/golden_message.2.3.0",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/pldoc/editpred.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/pldoc/multi-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/pldoc/source.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/pldoc/priv-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/pldoc/private.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/pldoc/reload.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/pldoc/h1-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/pldoc/public.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/pldoc/edit.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/pldoc/favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/pldoc/h2-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/pldoc/up.gif",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/pldoc/pub-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/lib/x11.crs",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/prolog/lib/man/classification.dat",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/prolog/lib/trace/pltracer.hlp",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/appl-help/emacs.hlp",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/appl-help/event_monitor.hlp",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/appl-help/pcefaq.hlp",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/appl-help/pcedraw.hlp",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/appl-help/dialog.hlp",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/appl-help/help.hlp",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/appl-help/customise.hlp",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/appl-help/plprefs.hlp",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/swipl/swipl.ico",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/TeX/figs/manpce.gif",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/TeX/figs/swi.pd",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/userguide/figs/classbrowser.pd",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/userguide/figs/classhierarchy.pd",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/userguide/figs/vishierarchy.pd",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/userguide/figs/layoutmgr.pd",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/userguide/figs/docclasses.pd",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/userguide/figs/broadcast.pd",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/tools.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/topics.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/errors.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/bug_fixes.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/predicates.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/groups.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/objects.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/changes.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/examples.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/constraint.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/colour.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/identity.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/table.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/attribute.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/stream.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/text.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/relation_table.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/modifier.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/parser.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/format.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/obtain.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/function.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/tuple.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/while.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/and.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/graphical.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/button.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/text_item.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/@=.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/table_column.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/browser_select_gesture.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/gesture.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/regex.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/pixmap.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/get_method.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/code.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/send_method.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/variable.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/not.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/syntax_table.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/box.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/tile_adjuster.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/equal.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/text_image.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/visual.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/class_variable.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/lesseq.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/char_array.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/point.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/bezier_curve.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/chain_hyper.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/table_cell.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/chain.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/label_box.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/binary_condition.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/tree.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/tile.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/grbox.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/socket.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/event_node.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/resize_outline_gesture.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/hyper.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/greateq.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/label.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/when.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/vector.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/device.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/relation.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/move_gesture.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/process.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/style.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/tbox.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/number.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/slider.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/view.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/arrow.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/prolog_term.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/region.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/dict_item.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/bool.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/pce.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/recogniser.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/c_pointer.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/message.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/dialog_group.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/popup_gesture.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/circle.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/source_location.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/editor.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/list_browser.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/win_metafile.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/elevation.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/name.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/click_gesture.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/browser.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/binary_expression.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/lbox.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/line.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/hash_table.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/handle.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/file.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/string.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/dialog.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/less.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/sheet.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/program_object.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/resource.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/picture.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/scroll_bar.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/quote_function.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/timer.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/event_tree.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/text_margin.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/layout_manager.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/win_printer.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/bitmap.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/path.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/display.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/handler_group.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/resize_table_slice_gesture.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/date.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/tab.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/figure.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/if.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/image.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/host_data.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/nameref.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/ellipse.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/rubber.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/joint.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/noteq.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/plus.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/text_cursor.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/assign.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/size.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/eq.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/key_binding.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/connect_gesture.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/code_vector.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/dict.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/dialog_item.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/popup.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/minus.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/block.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/event.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/create.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/or.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/operator.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/progn.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/connection.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/window.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/error.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/tab_stack.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/vmi.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/constant.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/int_item.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/arc.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/text_buffer.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/frame.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/cursor.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/divide.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/class.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/greater.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/font.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/host.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/fragment.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/menu_bar.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/object.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/var.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/parbox.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/method.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/spatial.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/chain_table.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/binding.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/times.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/source_sink.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/window_decorator.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/table_slice.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/hbox.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/menu.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/link.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/type.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/node.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/colour_map.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/display_manager.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/application.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/directory.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/area.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/resize_gesture.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/real.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/menu_item.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/table_row.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/monitor.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/tokeniser.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/move_outline_gesture.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/handler.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/reference/class/behaviour.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/course/figs/hello.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/course/figs/ftp.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/xpce/man/course/figs/control.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/pengines/pltpsynch.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/pengines/penarch.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/pengines/pltpruncolour.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/pengines/examples/web/queen.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/jpl/web/jpl.war",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/jpl/docs/images/screendump.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/jpl/docs/files/libjpl.dylib",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/http/web/icons/generic.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/http/web/icons/folder.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/http/web/icons/compressed.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/http/web/icons/back.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/http/web/icons/openid-logo-square.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/http/web/icons/layout.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/http/web/icons/c.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.0.3-ivkij3jmxssiqm3aomp34vxhuzwdffy7/spack-src/packages/http/web/icons/openid-logo-tiny.png"
    ],
    "total_files": 3902
}