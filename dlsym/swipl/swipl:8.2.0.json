{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/src/SWI-Prolog.h": "/*  Part of SWI-Prolog\n\n    Author:        Jan Wielemaker\n    E-mail:        J.Wielemaker@vu.nl\n    WWW:           http://www.swi-prolog.org\n    Copyright (c)  2008-2020, University of Amsterdam\n                              VU University Amsterdam\n    All rights reserved.\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n    1. Redistributions of source code must retain the above copyright\n       notice, this list of conditions and the following disclaimer.\n\n    2. Redistributions in binary form must reproduce the above copyright\n       notice, this list of conditions and the following disclaimer in\n       the documentation and/or other materials provided with the\n       distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n    COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n    ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n    POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#ifndef _FLI_H_INCLUDED\n#define _FLI_H_INCLUDED\n\n#ifndef __SWI_PROLOG__\t/* use this to switch on Prolog dialect */\n#define __SWI_PROLOG__\t/* normally defined by the swipl-ld compiler driver */\n#endif\n\n#ifndef __WINDOWS__\n#if defined(_MSC_VER) || defined(__MINGW32__)\n#define __WINDOWS__ 1\n#endif\n#endif\n\n#include <stdarg.h>\n#include <stdlib.h>\t\t\t/* get size_t */\n#include <stddef.h>\n#ifdef _MSC_VER\ntypedef __int64 int64_t;\ntypedef unsigned __int64 uint64_t;\n#if (_MSC_VER < 1300)\ntypedef long intptr_t;\ntypedef unsigned long uintptr_t;\n#endif\n#else\n#include <inttypes.h>\t\t\t/* more portable than stdint.h */\n#endif\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/* PLVERSION: 10000 * <Major> + 100 * <Minor> + <Patch> */\n/* PLVERSION_TAG: a string, normally \"\", but for example \"rc1\" */\n\n#ifndef PLVERSION\n#define PLVERSION 80200\n#endif\n#ifndef PLVERSION_TAG\n#define PLVERSION_TAG \"\"\n#endif\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nThis number is incremented when the   SWI-Prolog PL_*() functions or one\nof the data types is modified such that old binary extensions cannot run\nreliably with the  current  version.  This   version  is  introduced  in\nSWI-Prolog 8.1.30. The  most  recent   violation  of  compatibility  was\nbetween versions 8.1.21 and 8.1.22  with   the  introduction of rational\nnumbers are atomic type.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n#define PL_FLI_VERSION      2\t\t/* PL_*() functions */\n#define\tPL_REC_VERSION      3\t\t/* PL_record_external(), fastrw */\n#define PL_QLF_LOADVERSION 67\t\t/* load all versions later >= X */\n#define PL_QLF_VERSION     67\t\t/* save version number */\n\n\n\t\t /*******************************\n\t\t *\t       EXPORT\t\t*\n\t\t *******************************/\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nTraditional and ELF-based Unix systems  don't   need  all this, but COFF\nbased systems need  to  import  and   export  symbols  explicitely  from\nexecutables and shared objects (DLL). On some systems (e.g. AIX) this is\nachieved using import/export files, on Windows   this  is achieved using\nspecial  declarations  on  exported  symbols.  So,  a  symbol  is  local\n(static), shared between the objects building   an executable or DLL (no\nspecial declaration) or exported from the executable or DLL.\n\nBoth using native Microsoft MSVC as well   as recent Cygwin (tested 1.1)\ncompilers support __declspec(...) for exporting symbols.\n\nAs SWI-Prolog.h can be included separately or together with this file we\nduplicated this stuff.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n#ifndef _PL_EXPORT_DONE\n#define _PL_EXPORT_DONE\n\n#if (defined(__WINDOWS__) || defined(__CYGWIN__)) && !defined(__LCC__)\n#define HAVE_DECLSPEC\n#endif\n\n#ifdef HAVE_DECLSPEC\n# ifdef PL_KERNEL\n#define PL_EXPORT(type)\t\t__declspec(dllexport) type\n#define PL_EXPORT_DATA(type)\t__declspec(dllexport) type\n#define install_t\t\tvoid\n# else\n#  ifdef __BORLANDC__\n#define PL_EXPORT(type)\t\ttype _stdcall\n#define PL_EXPORT_DATA(type)\textern type\n#  else\n#   ifdef __MINGW32__\n#define PL_EXPORT(type)\t\textern type\n#define PL_EXPORT_DATA(type)\textern type\n#   else\n#define PL_EXPORT(type)\t\textern type\n#define PL_EXPORT_DATA(type)\t__declspec(dllimport) type\n#   endif\n#  endif\n#define install_t\t\t__declspec(dllexport) void\n# endif\n#else /*HAVE_DECLSPEC*/\n#define PL_EXPORT(type)\t\textern type\n#define PL_EXPORT_DATA(type)\textern type\n#define install_t\t\tvoid\n#endif /*HAVE_DECLSPEC*/\n#endif /*_PL_EXPORT_DONE*/\n\n\n\t\t /*******************************\n\t\t *\t  GCC ATTRIBUTES\t*\n\t\t *******************************/\n\n#if __GNUC__ >= 4\n#define WUNUSED __attribute__((warn_unused_result))\n#else\n#define WUNUSED\n#endif\n\n\n\t\t /*******************************\n\t\t *\t       TYPES\t\t*\n\t\t *******************************/\n\n#ifdef _PL_INCLUDE_H\ntypedef Module\t\tmodule_t;\t/* a module */\ntypedef Procedure\tpredicate_t;\t/* a predicate handle */\ntypedef Record\t\trecord_t;\t/* handle to a recorded term */\ntypedef struct PL_local_data *PL_engine_t; /* handle to a engine */\n#else\ntypedef\tuintptr_t\tatom_t;\t\t/* Prolog atom */\ntypedef uintptr_t\tfunctor_t;\t/* Name/arity pair */\ntypedef void *\t\tmodule_t;\t/* Prolog module */\ntypedef void *\t\tpredicate_t;\t/* Prolog procedure */\ntypedef void *\t\trecord_t;\t/* Prolog recorded term */\n#ifndef PL_HAVE_TERM_T\n#define PL_HAVE_TERM_T\ntypedef uintptr_t\tterm_t;\t\t/* opaque term handle */\n#endif\ntypedef uintptr_t\tqid_t;\t\t/* opaque query handle */\ntypedef uintptr_t\tPL_fid_t;\t/* opaque foreign context handle */\ntypedef void *\t\tcontrol_t;\t/* non-deterministic control arg */\ntypedef void *\t\tPL_engine_t;\t/* opaque engine handle */\n#endif\ntypedef uintptr_t\tPL_atomic_t;\t/* same a word */\ntypedef uintptr_t\tforeign_t;\t/* return type of foreign functions */\ntypedef wchar_t\t        pl_wchar_t;\t/* Prolog wide character */\n#ifdef __cplusplus\ntypedef void *\t\tpl_function_t;      /* pass function as void* */\n#else\ntypedef foreign_t\t(*pl_function_t)(); /* foreign language functions */\n#endif\ntypedef uintptr_t\tbuf_mark_t;\t/* buffer mark handle */\n\n#ifndef NORETURN\n#define NORETURN\n#endif\n\n#define fid_t PL_fid_t\t\t\t/* avoid AIX name-clash */\n\n\t\t\t\t\t/* values for PL_get_term_value() */\ntypedef union\n{ int64_t i;\t\t\t\t/* PL_INTEGER */\n  double f;\t\t\t\t/* PL_FLOAT */\n  char * s;\t\t\t\t/* PL_STRING */\n  atom_t a;\t\t\t\t/* PL_ATOM */\n  struct\t\t\t\t/* PL_TERM */\n  { atom_t name;\n    size_t arity;\n  } t;\n} term_value_t;\n\n\n#ifndef TRUE\n#define TRUE\t(1)\n#define FALSE\t(0)\n#endif\n\n\t\t /*******************************\n\t\t *      TERM-TYPE CONSTANTS\t*\n\t\t *******************************/\n\t\t\t\t\t/* PL_unify_term() arguments */\n#define\tPL_VARIABLE\t (1)\t\t/* nothing */\n#define PL_ATOM\t\t (2)\t\t/* const char * */\n#define PL_INTEGER\t (3)\t\t/* int */\n#define PL_RATIONAL\t (4)\t\t/* rational number */\n#define PL_FLOAT\t (5)\t\t/* double */\n#define PL_STRING\t (6)\t\t/* const char * */\n#define PL_TERM\t\t (7)\n\n#define PL_NIL\t\t (8)\t\t/* The constant [] */\n#define PL_BLOB\t\t (9)\t\t/* non-atom blob */\n#define PL_LIST_PAIR\t (10)\t\t/* [_|_] term */\n\n\t\t\t\t\t/* PL_unify_term() */\n#define PL_FUNCTOR\t (11)\t\t/* functor_t, arg ... */\n#define PL_LIST\t\t (12)\t\t/* length, arg ... */\n#define PL_CHARS\t (13)\t\t/* const char * */\n#define PL_POINTER\t (14)\t\t/* void * */\n\t\t\t\t\t/* PlArg::PlArg(text, type) */\n#define PL_CODE_LIST\t (15)\t\t/* [ascii...] */\n#define PL_CHAR_LIST\t (16)\t\t/* [h,e,l,l,o] */\n#define PL_BOOL\t\t (17)\t\t/* PL_set_prolog_flag() */\n#define PL_FUNCTOR_CHARS (18)\t\t/* PL_unify_term() */\n#define _PL_PREDICATE_INDICATOR (19)\t/* predicate_t (Procedure) */\n#define PL_SHORT\t (20)\t\t/* short */\n#define PL_INT\t\t (21)\t\t/* int */\n#define PL_LONG\t\t (22)\t\t/* long */\n#define PL_DOUBLE\t (23)\t\t/* double */\n#define PL_NCHARS\t (24)\t\t/* size_t, const char * */\n#define PL_UTF8_CHARS\t (25)\t\t/* const char * */\n#define PL_UTF8_STRING\t (26)\t\t/* const char * */\n#define PL_INT64\t (27)\t\t/* int64_t */\n#define PL_NUTF8_CHARS\t (28)\t\t/* size_t, const char * */\n#define PL_NUTF8_CODES\t (29)\t\t/* size_t, const char * */\n#define PL_NUTF8_STRING\t (30)\t\t/* size_t, const char * */\n#define PL_NWCHARS\t (31)\t\t/* size_t, const wchar_t * */\n#define PL_NWCODES\t (32)\t\t/* size_t, const wchar_t * */\n#define PL_NWSTRING\t (33)\t\t/* size_t, const wchar_t * */\n#define PL_MBCHARS\t (34)\t\t/* const char * */\n#define PL_MBCODES\t (35)\t\t/* const char * */\n#define PL_MBSTRING\t (36)\t\t/* const char * */\n#define PL_INTPTR\t (37)\t\t/* intptr_t */\n#define PL_CHAR\t\t (38)\t\t/* int */\n#define PL_CODE\t\t (39)\t\t/* int */\n#define PL_BYTE\t\t (40)\t\t/* int */\n\t\t\t\t\t/* PL_skip_list() */\n#define PL_PARTIAL_LIST\t (41)\t\t/* a partial list */\n#define PL_CYCLIC_TERM\t (42)\t\t/* a cyclic list/term */\n#define PL_NOT_A_LIST\t (43)\t\t/* Object is not a list */\n\t\t\t\t\t/* dicts */\n#define PL_DICT\t\t (44)\n\n/* Or'ed flags for PL_set_prolog_flag() */\n/* MUST fit in a short int! */\n#define FF_READONLY\t 0x1000\t\t/* Read-only prolog flag */\n#define FF_KEEP\t\t 0x2000\t\t/* keep prolog flag if already set */\n#define FF_NOCREATE\t 0x4000\t\t/* Fail if flag is non-existent */\n#define FF_FORCE\t 0x8000\t\t/* Force setting, overwrite READONLY */\n#define FF_MASK\t\t 0xf000\n\n\n\t\t/********************************\n\t\t*    DETERMINISTIC CALL/RETURN  *\n\t\t*********************************/\n\n#define\tPL_succeed\treturn TRUE\t/* succeed deterministically */\n#define PL_fail\t\treturn FALSE\t/* fail */\n\n\n\t\t/********************************\n\t\t* NON-DETERMINISTIC CALL/RETURN *\n\t\t*********************************/\n\n/*  Note 1: Non-deterministic foreign functions may also use the deterministic\n    return methods PL_succeed and PL_fail.\n\n    Note 2: The argument to PL_retry is a sizeof(ptr)-2 bits signed\n    integer (use type intptr_t).\n*/\n\n#define PL_FIRST_CALL\t\t(0)\n#define PL_CUTTED\t\t(1)\t/* deprecated */\n#define PL_PRUNED\t\t(1)\n#define PL_REDO\t\t\t(2)\n\n#define PL_retry(n)\t\treturn _PL_retry(n)\n#define PL_retry_address(a)\treturn _PL_retry_address(a)\n\nPL_EXPORT(foreign_t)\t_PL_retry(intptr_t);\nPL_EXPORT(foreign_t)\t_PL_retry_address(void *);\nPL_EXPORT(int)\t\tPL_foreign_control(control_t);\nPL_EXPORT(intptr_t)\tPL_foreign_context(control_t);\nPL_EXPORT(void *)\tPL_foreign_context_address(control_t);\nPL_EXPORT(predicate_t)\tPL_foreign_context_predicate(control_t);\n\n\n\t\t/********************************\n\t\t*      REGISTERING FOREIGNS     *\n\t\t*********************************/\n\ntypedef struct PL_extension\n{ const char   *predicate_name;\t\t/* Name of the predicate */\n  short\t\tarity;\t\t\t/* Arity of the predicate */\n  pl_function_t\tfunction;\t\t/* Implementing functions */\n  short\t\tflags;\t\t\t/* Or of PL_FA_... */\n} PL_extension;\n\n#define PL_FA_NOTRACE\t\t(0x01)\t/* foreign cannot be traced */\n#define PL_FA_TRANSPARENT\t(0x02)\t/* foreign is module transparent */\n#define PL_FA_NONDETERMINISTIC\t(0x04)\t/* foreign is non-deterministic */\n#define PL_FA_VARARGS\t\t(0x08)\t/* call using t0, ac, ctx */\n#define PL_FA_CREF\t\t(0x10)\t/* Internal: has clause-reference */\n#define PL_FA_ISO\t\t(0x20)\t/* Internal: ISO core predicate */\n#define PL_FA_META\t\t(0x40)\t/* Additional meta-argument spec */\n\nextern\t\t\tPL_extension PL_extensions[]; /* not Win32! */\nPL_EXPORT(void)\t\tPL_register_extensions(const PL_extension *e);\nPL_EXPORT(void)\t\tPL_register_extensions_in_module(const char *module, const PL_extension *e);\nPL_EXPORT(int)\t\tPL_register_foreign(const char *name, int arity,\n\t\t\t\t\t    pl_function_t func,\n\t\t\t\t\t    int flags, ...);\nPL_EXPORT(int)\t\tPL_register_foreign_in_module(const char *module,\n\t\t\t\t\t\t      const char *name, int arity,\n\t\t\t\t\t\t      pl_function_t func,\n\t\t\t\t\t\t      int flags, ...);\nPL_EXPORT(void)\t\tPL_load_extensions(const PL_extension *e);\n\n\t\t /*******************************\n\t\t *\t      LICENSE\t\t*\n\t\t *******************************/\n\nPL_EXPORT(void)\t\tPL_license(const char *license, const char *module);\n\n\t\t/********************************\n\t\t*            MODULES            *\n\t\t*********************************/\n\nPL_EXPORT(module_t)\tPL_context(void);\nPL_EXPORT(atom_t)\tPL_module_name(module_t module);\nPL_EXPORT(module_t)\tPL_new_module(atom_t name);\nPL_EXPORT(int)\t\tPL_strip_module(term_t in, module_t *m, term_t out) WUNUSED;\n\n\t\t /*******************************\n\t\t *\t     CONSTANTS\t\t*\n\t\t *******************************/\n\nPL_EXPORT(const atom_t) *_PL_atoms(void); /* base of reserved (meta-)atoms */\n#ifndef PL_KERNEL\n#define ATOM_nil\t(_PL_atoms()[0]) /* `[]` */\n#define ATOM_dot\t(_PL_atoms()[1]) /* `.` */\n#endif /*PL_KERNEL*/\n\n\n\t\t /*******************************\n\t\t *\t     CALL-BACK\t\t*\n\t\t *******************************/\n\n#ifdef PL_KERNEL\n#define PL_Q_DEBUG\t\t0x0001\t/* = TRUE for backward compatibility */\n#endif\n#define PL_Q_NORMAL\t\t0x0002\t/* normal usage */\n#define PL_Q_NODEBUG\t\t0x0004\t/* use this one */\n#define PL_Q_CATCH_EXCEPTION\t0x0008\t/* handle exceptions in C */\n#define PL_Q_PASS_EXCEPTION\t0x0010\t/* pass to parent environment */\n#define PL_Q_ALLOW_YIELD\t0x0020\t/* Support I_YIELD */\n#define PL_Q_EXT_STATUS\t\t0x0040\t/* Return extended status */\n#ifdef PL_KERNEL\n#define PL_Q_DETERMINISTIC\t0x0100\t/* call was deterministic */\n#endif\n\n\t\t\t\t\t/* PL_Q_EXT_STATUS return codes */\n#define PL_S_EXCEPTION\t       -1\t/* Query raised exception */\n#define PL_S_FALSE\t\t0\t/* Query failed */\n#define PL_S_TRUE\t\t1\t/* Query succeeded with choicepoint */\n#define PL_S_LAST\t\t2\t/* Query succeeded without CP */\n\n\n\t\t\t/* Foreign context frames */\nPL_EXPORT(fid_t)\tPL_open_foreign_frame(void);\nPL_EXPORT(void)\t\tPL_rewind_foreign_frame(fid_t cid);\nPL_EXPORT(void)\t\tPL_close_foreign_frame(fid_t cid);\nPL_EXPORT(void)\t\tPL_discard_foreign_frame(fid_t cid);\n\n\t\t\t/* Finding predicates */\nPL_EXPORT(predicate_t)\tPL_pred(functor_t f, module_t m);\nPL_EXPORT(predicate_t)\tPL_predicate(const char *name, int arity,\n\t\t\t\t     const char* module);\nPL_EXPORT(int)\t\tPL_predicate_info(predicate_t pred,\n\t\t\t\t\t  atom_t *name, size_t *arity,\n\t\t\t\t\t  module_t *module);\n\n\t\t\t/* Call-back */\nPL_EXPORT(qid_t)\tPL_open_query(module_t m, int flags,\n\t\t\t\t      predicate_t pred, term_t t0);\nPL_EXPORT(int)\t\tPL_next_solution(qid_t qid) WUNUSED;\nPL_EXPORT(int)\t\tPL_close_query(qid_t qid);\nPL_EXPORT(int)\t\tPL_cut_query(qid_t qid);\nPL_EXPORT(qid_t)\tPL_current_query(void);\n\n\t\t\t/* Simplified (but less flexible) call-back */\nPL_EXPORT(int)\t\tPL_call(term_t t, module_t m);\nPL_EXPORT(int)\t\tPL_call_predicate(module_t m, int debug,\n\t\t\t\t\t  predicate_t pred, term_t t0);\n\t\t\t/* Handling exceptions */\nPL_EXPORT(term_t)\tPL_exception(qid_t qid);\nPL_EXPORT(int)\t\tPL_raise_exception(term_t exception);\nPL_EXPORT(int)\t\tPL_throw(term_t exception);\nPL_EXPORT(void)\t\tPL_clear_exception(void);\n\t\t\t/* Engine-based coroutining */\nPL_EXPORT(term_t)\tPL_yielded(qid_t qid);\n\n\n\t\t /*******************************\n\t\t *\t      ASSERT\t\t*\n\t\t *******************************/\n\n#define PL_ASSERTZ\t\t0x0000\n#define PL_ASSERTA\t\t0x0001\n#define PL_CREATE_THREAD_LOCAL\t0x0010\n#define PL_CREATE_INCREMENTAL\t0x0020\n\nPL_EXPORT(int)\t\tPL_assert(term_t term, module_t m, int flags);\n\n\n\n\n\t\t /*******************************\n\t\t *        TERM-REFERENCES\t*\n\t\t *******************************/\n\n\t\t\t/* Creating and destroying term-refs */\nPL_EXPORT(term_t)\tPL_new_term_refs(int n);\nPL_EXPORT(term_t)\tPL_new_term_ref(void);\nPL_EXPORT(term_t)\tPL_copy_term_ref(term_t from);\nPL_EXPORT(void)\t\tPL_reset_term_refs(term_t r);\n\n\t\t\t/* Constants */\nPL_EXPORT(atom_t)\tPL_new_atom(const char *s);\nPL_EXPORT(atom_t)\tPL_new_atom_nchars(size_t len, const char *s);\nPL_EXPORT(atom_t)\tPL_new_atom_wchars(size_t len, const pl_wchar_t *s);\nPL_EXPORT(atom_t)\tPL_new_atom_mbchars(int rep, size_t len, const char *s);\nPL_EXPORT(const char *)\tPL_atom_chars(atom_t a);\nPL_EXPORT(const char *)\tPL_atom_nchars(atom_t a, size_t *len);\nPL_EXPORT(const wchar_t *)\tPL_atom_wchars(atom_t a, size_t *len);\n#ifdef O_DEBUG_ATOMGC\n#define PL_register_atom(a) \\\n\t_PL_debug_register_atom(a, __FILE__, __LINE__, __PRETTY_FUNCTION__)\n#define PL_unregister_atom(a) \\\n\t_PL_debug_unregister_atom(a, __FILE__, __LINE__, __PRETTY_FUNCTION__)\nPL_EXPORT(void)\t\t_PL_debug_register_atom(atom_t a,\n\t\t\t\t\t\tconst char *file, int line,\n\t\t\t\t\t\tconst char *func);\nPL_EXPORT(void)\t\t_PL_debug_unregister_atom(atom_t a,\n\t\t\t\t\t\t  const char *file, int line,\n\t\t\t\t\t\t  const char *func);\n#else\nPL_EXPORT(void)\t\tPL_register_atom(atom_t a);\nPL_EXPORT(void)\t\tPL_unregister_atom(atom_t a);\n#endif\nPL_EXPORT(functor_t)\tPL_new_functor_sz(atom_t f, size_t a);\nPL_EXPORT(functor_t)\tPL_new_functor(atom_t f, int a);\nPL_EXPORT(atom_t)\tPL_functor_name(functor_t f);\nPL_EXPORT(int)\t\tPL_functor_arity(functor_t f);\nPL_EXPORT(size_t)\tPL_functor_arity_sz(functor_t f);\n\n\t\t\t/* Get C-values from Prolog terms */\nPL_EXPORT(int)\t\tPL_get_atom(term_t t, atom_t *a) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_bool(term_t t, int *value) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_atom_chars(term_t t, char **a) WUNUSED;\n#define PL_get_string_chars(t, s, l) PL_get_string(t,s,l)\n\t\t\t\t\t/* PL_get_string() is deprecated */\nPL_EXPORT(int)\t\tPL_get_string(term_t t, char **s, size_t *len) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_chars(term_t t, char **s, unsigned int flags) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_list_chars(term_t l, char **s,\n\t\t\t\t\t  unsigned int flags) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_atom_nchars(term_t t, size_t *len, char **a) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_list_nchars(term_t l,\n\t\t\t\t\t   size_t *len, char **s,\n\t\t\t\t\t   unsigned int flags) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_nchars(term_t t,\n\t\t\t\t      size_t *len, char **s,\n\t\t\t\t      unsigned int flags) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_integer(term_t t, int *i) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_long(term_t t, long *i) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_intptr(term_t t, intptr_t *i) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_pointer(term_t t, void **ptr) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_float(term_t t, double *f) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_functor(term_t t, functor_t *f) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_name_arity_sz(term_t t, atom_t *name,\n\t\t\t\t\t     size_t *arity) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_compound_name_arity_sz(term_t t, atom_t *name,\n\t\t\t\t\t\t      size_t *arity) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_name_arity(term_t t, atom_t *name,\n\t\t\t\t\t  int *arity) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_compound_name_arity(term_t t, atom_t *name,\n\t\t\t\t\t\t   int *arity) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_module(term_t t, module_t *module) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_arg_sz(size_t index, term_t t, term_t a) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_arg(int index, term_t t, term_t a) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_dict_key(atom_t key, term_t dict, term_t value);\nPL_EXPORT(int)\t\tPL_get_list(term_t l, term_t h, term_t t) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_head(term_t l, term_t h) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_tail(term_t l, term_t t) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_nil(term_t l) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_term_value(term_t t, term_value_t *v) WUNUSED;\nPL_EXPORT(char *)\tPL_quote(int chr, const char *data);\n\n\t\t\t/* Verify types */\nPL_EXPORT(int)\t\tPL_term_type(term_t t);\nPL_EXPORT(int)\t\tPL_is_variable(term_t t);\nPL_EXPORT(int)\t\tPL_is_ground(term_t t);\nPL_EXPORT(int)\t\tPL_is_atom(term_t t);\nPL_EXPORT(int)\t\tPL_is_integer(term_t t);\nPL_EXPORT(int)\t\tPL_is_string(term_t t);\nPL_EXPORT(int)\t\tPL_is_float(term_t t);\nPL_EXPORT(int)\t\tPL_is_rational(term_t t);\nPL_EXPORT(int)\t\tPL_is_compound(term_t t);\nPL_EXPORT(int)\t\tPL_is_callable(term_t t);\nPL_EXPORT(int)\t\tPL_is_functor(term_t t, functor_t f);\nPL_EXPORT(int)\t\tPL_is_list(term_t t);\nPL_EXPORT(int)\t\tPL_is_dict(term_t t);\nPL_EXPORT(int)\t\tPL_is_pair(term_t t);\nPL_EXPORT(int)\t\tPL_is_atomic(term_t t);\nPL_EXPORT(int)\t\tPL_is_number(term_t t);\nPL_EXPORT(int)\t\tPL_is_acyclic(term_t t);\n\n\t\t\t/* Assign to term-references */\nPL_EXPORT(int)\t\tPL_put_variable(term_t t);\nPL_EXPORT(int)\t\tPL_put_atom(term_t t, atom_t a);\nPL_EXPORT(int)\t\tPL_put_bool(term_t t, int val);\nPL_EXPORT(int)\t\tPL_put_atom_chars(term_t t, const char *chars);\nPL_EXPORT(int)\t\tPL_put_string_chars(term_t t, const char *chars) WUNUSED;\nPL_EXPORT(int)\t\tPL_put_chars(term_t t, int flags,\n\t\t\t\t     size_t len, const char *chars) WUNUSED;\nPL_EXPORT(int)\t\tPL_put_list_chars(term_t t, const char *chars) WUNUSED;\nPL_EXPORT(int)\t\tPL_put_list_codes(term_t t, const char *chars) WUNUSED;\nPL_EXPORT(int)\t\tPL_put_atom_nchars(term_t t, size_t l, const char *chars);\nPL_EXPORT(int)\t\tPL_put_string_nchars(term_t t, size_t len, const char *chars) WUNUSED;\nPL_EXPORT(int)\t\tPL_put_list_nchars(term_t t, size_t l, const char *chars) WUNUSED;\nPL_EXPORT(int)\t\tPL_put_list_ncodes(term_t t, size_t l, const char *chars) WUNUSED;\nPL_EXPORT(int)\t\tPL_put_integer(term_t t, long i) WUNUSED;\nPL_EXPORT(int)\t\tPL_put_pointer(term_t t, void *ptr) WUNUSED;\nPL_EXPORT(int)\t\tPL_put_float(term_t t, double f) WUNUSED;\nPL_EXPORT(int)\t\tPL_put_functor(term_t t, functor_t functor) WUNUSED;\nPL_EXPORT(int)\t\tPL_put_list(term_t l) WUNUSED;\nPL_EXPORT(int)\t\tPL_put_nil(term_t l);\nPL_EXPORT(int)\t\tPL_put_term(term_t t1, term_t t2);\nPL_EXPORT(int)\t\tPL_put_dict(term_t t, atom_t tag, size_t len,\n\t\t\t\t    const atom_t *keys, term_t values);\n\n\t\t\t/* construct a functor or list-cell */\nPL_EXPORT(int)\t\tPL_cons_functor(term_t h, functor_t f, ...) WUNUSED;\nPL_EXPORT(int)\t\tPL_cons_functor_v(term_t h, functor_t fd, term_t a0) WUNUSED;\nPL_EXPORT(int)\t\tPL_cons_list(term_t l, term_t h, term_t t) WUNUSED;\n\n\t\t\t/* Unify term-references */\nPL_EXPORT(int)\t\tPL_unify(term_t t1, term_t t2) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_atom(term_t t, atom_t a) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_atom_chars(term_t t, const char *chars) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_list_chars(term_t t, const char *chars) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_list_codes(term_t t, const char *chars) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_string_chars(term_t t, const char *chars) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_atom_nchars(term_t t, size_t l, const char *s) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_list_ncodes(term_t t, size_t l, const char *s) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_list_nchars(term_t t, size_t l, const char *s) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_string_nchars(term_t t,\n\t\t\t\t\t       size_t len,\n\t\t\t\t\t       const char *chars) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_bool(term_t t, int n) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_integer(term_t t, intptr_t n) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_float(term_t t, double f) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_pointer(term_t t, void *ptr) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_functor(term_t t, functor_t f) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_compound(term_t t, functor_t f) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_list(term_t l, term_t h, term_t t) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_nil(term_t l) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_arg_sz(size_t index, term_t t, term_t a) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_arg(int index, term_t t, term_t a) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_term(term_t t, ...) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_chars(term_t t, int flags,\n\t\t\t\t       size_t len, const char *s) WUNUSED;\n\n\t\t /*******************************\n\t\t *\t       LISTS\t\t*\n\t\t *******************************/\n\nPL_EXPORT(int)\t\tPL_skip_list(term_t list, term_t tail, size_t *len);\n\n\n\t\t /*******************************\n\t\t *    WIDE CHARACTER VERSIONS\t*\n\t\t *******************************/\n\nPL_EXPORT(int)\t\tPL_unify_wchars(term_t t, int type,\n\t\t\t\t\tsize_t len, const pl_wchar_t *s) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_wchars_diff(term_t t, term_t tail, int type,\n\t\t\t\t\tsize_t len, const pl_wchar_t *s) WUNUSED;\nPL_EXPORT(int)\t\tPL_get_wchars(term_t l,\n\t\t\t\t      size_t *length, pl_wchar_t **s,\n\t\t\t\t      unsigned flags) WUNUSED;\nPL_EXPORT(size_t)\tPL_utf8_strlen(const char *s, size_t len) WUNUSED;\n\n\n\t\t /*******************************\n\t\t *\t   WIDE INTEGERS\t*\n\t\t *******************************/\n\n\nPL_EXPORT(int)\t\tPL_get_int64(term_t t, int64_t *i) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_int64(term_t t, int64_t value) WUNUSED;\nPL_EXPORT(int)\t\tPL_unify_uint64(term_t t, uint64_t value) WUNUSED;\nPL_EXPORT(int)\t\tPL_put_int64(term_t t, int64_t i) WUNUSED;\nPL_EXPORT(int)\t\tPL_put_uint64(term_t t, uint64_t i) WUNUSED;\n\n\n\t\t /*******************************\n\t\t *     ATTRIBUTED VARIABLES\t*\n\t\t *******************************/\n\nPL_EXPORT(int)\t\tPL_is_attvar(term_t t);\nPL_EXPORT(int)\t\tPL_get_attr(term_t v, term_t a);\n\n\n\t\t /*******************************\n\t\t *\t      ERRORS\t\t*\n\t\t *******************************/\n\nPL_EXPORT(int)\t\tPL_get_atom_ex(term_t t, atom_t *a);\nPL_EXPORT(int)\t\tPL_get_integer_ex(term_t t, int *i);\nPL_EXPORT(int)\t\tPL_get_long_ex(term_t t, long *i);\nPL_EXPORT(int)\t\tPL_get_int64_ex(term_t t, int64_t *i);\nPL_EXPORT(int)\t\tPL_get_intptr_ex(term_t t, intptr_t *i);\nPL_EXPORT(int)\t\tPL_get_size_ex(term_t t, size_t *i);\nPL_EXPORT(int)\t\tPL_get_bool_ex(term_t t, int *i);\nPL_EXPORT(int)\t\tPL_get_float_ex(term_t t, double *f);\nPL_EXPORT(int)\t\tPL_get_char_ex(term_t t, int *p, int eof);\nPL_EXPORT(int)\t\tPL_unify_bool_ex(term_t t, int val);\nPL_EXPORT(int)\t\tPL_get_pointer_ex(term_t t, void **addrp);\nPL_EXPORT(int)\t\tPL_unify_list_ex(term_t l, term_t h, term_t t);\nPL_EXPORT(int)\t\tPL_unify_nil_ex(term_t l);\nPL_EXPORT(int)\t\tPL_get_list_ex(term_t l, term_t h, term_t t);\nPL_EXPORT(int)\t\tPL_get_nil_ex(term_t l);\n\nPL_EXPORT(int)\t\tPL_instantiation_error(term_t culprit);\nPL_EXPORT(int)\t\tPL_uninstantiation_error(term_t culprit);\nPL_EXPORT(int)\t\tPL_representation_error(const char *resource);\nPL_EXPORT(int)\t\tPL_type_error(const char *expected, term_t culprit);\nPL_EXPORT(int)\t\tPL_domain_error(const char *expected, term_t culprit);\nPL_EXPORT(int)\t\tPL_existence_error(const char *type, term_t culprit);\nPL_EXPORT(int)\t\tPL_permission_error(const char *operation,\n\t\t\t\t\t    const char *type, term_t culprit);\nPL_EXPORT(int)\t\tPL_resource_error(const char *resource);\n#ifdef SIO_MAGIC\nPL_EXPORT(int)\t\tPL_syntax_error(const char *msg, IOSTREAM *in);\n#else\nPL_EXPORT(int)\t\tPL_syntax_error(const char *msg, void *in);\n#endif\n\n\t\t /*******************************\n\t\t *\t       BLOBS\t\t*\n\t\t *******************************/\n\n#define PL_BLOB_MAGIC_B\t0x75293a00\t/* Magic to validate a blob-type */\n#define PL_BLOB_VERSION 1\t\t/* Current version */\n#define PL_BLOB_MAGIC\t(PL_BLOB_MAGIC_B|PL_BLOB_VERSION)\n\n#define PL_BLOB_UNIQUE\t0x01\t\t/* Blob content is unique */\n#define PL_BLOB_TEXT\t0x02\t\t/* blob contains text */\n#define PL_BLOB_NOCOPY\t0x04\t\t/* do not copy the data */\n#define PL_BLOB_WCHAR\t0x08\t\t/* wide character string */\n\ntypedef struct PL_blob_t\n{ uintptr_t\t\tmagic;\t\t/* PL_BLOB_MAGIC */\n  uintptr_t\t\tflags;\t\t/* PL_BLOB_* */\n  char *\t\tname;\t\t/* name of the type */\n  int\t\t\t(*release)(atom_t a);\n  int\t\t\t(*compare)(atom_t a, atom_t b);\n#ifdef SIO_MAGIC\n  int\t\t\t(*write)(IOSTREAM *s, atom_t a, int flags);\n#else\n  int\t\t\t(*write)(void *s, atom_t a, int flags);\n#endif\n  void\t\t\t(*acquire)(atom_t a);\n#ifdef SIO_MAGIC\n  int\t\t\t(*save)(atom_t a, IOSTREAM *s);\n  atom_t\t\t(*load)(IOSTREAM *s);\n#else\n  int\t\t\t(*save)(atom_t a, void*);\n  atom_t\t\t(*load)(void *s);\n#endif\n  size_t\t\tpadding;\t/* Required 0-padding */\n\t\t\t\t\t/* private */\n  void *\t\treserved[9];\t/* for future extension */\n  int\t\t\tregistered;\t/* Already registered? */\n  int\t\t\trank;\t\t/* Rank for ordering atoms */\n  struct PL_blob_t *    next;\t\t/* next in registered type-chain */\n  atom_t\t\tatom_name;\t/* Name as atom */\n} PL_blob_t;\n\nPL_EXPORT(int)\t\tPL_is_blob(term_t t, PL_blob_t **type);\nPL_EXPORT(int)\t\tPL_unify_blob(term_t t, void *blob, size_t len,\n\t\t\t\t      PL_blob_t *type);\nPL_EXPORT(int)\t\tPL_put_blob(term_t t, void *blob, size_t len,\n\t\t\t\t    PL_blob_t *type);\nPL_EXPORT(int)\t\tPL_get_blob(term_t t, void **blob, size_t *len,\n\t\t\t\t    PL_blob_t **type);\n\nPL_EXPORT(void*)\tPL_blob_data(atom_t a,\n\t\t\t\t     size_t *len,\n\t\t\t\t     struct PL_blob_t **type);\n\nPL_EXPORT(void)\t\tPL_register_blob_type(PL_blob_t *type);\nPL_EXPORT(PL_blob_t*)\tPL_find_blob_type(const char* name);\nPL_EXPORT(int)\t\tPL_unregister_blob_type(PL_blob_t *type);\n\n\n#ifdef __GNU_MP__\n\n\t\t /*******************************\n\t\t *\t       GMP\t\t*\n\t\t *******************************/\n\nPL_EXPORT(int)\tPL_get_mpz(term_t t, mpz_t mpz) WUNUSED;\nPL_EXPORT(int)\tPL_get_mpq(term_t t,  mpq_t mpq) WUNUSED;\nPL_EXPORT(int)\tPL_unify_mpz(term_t t, mpz_t mpz) WUNUSED;\nPL_EXPORT(int)\tPL_unify_mpq(term_t t, mpq_t mpq) WUNUSED;\n\n#endif /*__GNU_MP__*/\n\n\t\t /*******************************\n\t\t *\t  FILENAME SUPPORT\t*\n\t\t *******************************/\n\n#define PL_FILE_ABSOLUTE\t0x01\t/* return absolute path */\n#define PL_FILE_OSPATH\t\t0x02\t/* return path in OS notation */\n#define PL_FILE_SEARCH\t\t0x04\t/* use file_search_path */\n#define PL_FILE_EXIST\t\t0x08\t/* demand file to exist */\n#define PL_FILE_READ\t\t0x10\t/* demand read-access */\n#define PL_FILE_WRITE\t\t0x20\t/* demand write-access */\n#define PL_FILE_EXECUTE\t\t0x40\t/* demand execute-access */\n#define PL_FILE_NOERRORS\t0x80\t/* do not raise exceptions */\n\nPL_EXPORT(int)\t\tPL_get_file_name(term_t n, char **name, int flags);\nPL_EXPORT(int)\t\tPL_get_file_nameW(term_t n, wchar_t **name, int flags);\nPL_EXPORT(void)\t\tPL_changed_cwd(void); /* foreign code changed CWD */\nPL_EXPORT(char *)\tPL_cwd(char *buf, size_t buflen);\n\n\n\t\t /*******************************\n\t\t *    QUINTUS/SICSTUS WRAPPER\t*\n\t\t *******************************/\n\nPL_EXPORT(int)\t\tPL_cvt_i_char(term_t p, char *c);\nPL_EXPORT(int)\t\tPL_cvt_i_uchar(term_t p, unsigned char *c);\nPL_EXPORT(int)\t\tPL_cvt_i_short(term_t p, short *s);\nPL_EXPORT(int)\t\tPL_cvt_i_ushort(term_t p, unsigned short *s);\nPL_EXPORT(int)\t\tPL_cvt_i_int(term_t p, int *c);\nPL_EXPORT(int)\t\tPL_cvt_i_uint(term_t p, unsigned int *c);\nPL_EXPORT(int)\t\tPL_cvt_i_long(term_t p, long *c);\nPL_EXPORT(int)\t\tPL_cvt_i_ulong(term_t p, unsigned long *c);\nPL_EXPORT(int)\t\tPL_cvt_i_int64(term_t p, int64_t *c);\nPL_EXPORT(int)\t\tPL_cvt_i_uint64(term_t p, uint64_t *c);\nPL_EXPORT(int)\t\tPL_cvt_i_size_t(term_t p, size_t *c);\nPL_EXPORT(int)\t\tPL_cvt_i_float(term_t p, double *c);\nPL_EXPORT(int)\t\tPL_cvt_i_single(term_t p, float *c);\nPL_EXPORT(int)\t\tPL_cvt_i_string(term_t p, char **c);\nPL_EXPORT(int)\t\tPL_cvt_i_codes(term_t p, char **c);\nPL_EXPORT(int)\t\tPL_cvt_i_atom(term_t p, atom_t *c);\nPL_EXPORT(int)\t\tPL_cvt_i_address(term_t p, void *c);\nPL_EXPORT(int)\t\tPL_cvt_o_int64(int64_t c, term_t p);\nPL_EXPORT(int)\t\tPL_cvt_o_float(double c, term_t p);\nPL_EXPORT(int)\t\tPL_cvt_o_single(float c, term_t p);\nPL_EXPORT(int)\t\tPL_cvt_o_string(const char *c, term_t p);\nPL_EXPORT(int)\t\tPL_cvt_o_codes(const char *c, term_t p);\nPL_EXPORT(int)\t\tPL_cvt_o_atom(atom_t c, term_t p);\nPL_EXPORT(int)\t\tPL_cvt_o_address(void *address, term_t p);\nPL_EXPORT(term_t)\tPL_new_nil_ref(void);\n\n/* set/get encoding for PL_cvt_*_string() functions.  The default\n   is UTF-8 (REP_UTF8)\n*/\n\nPL_EXPORT(int)\t\tPL_cvt_encoding(void);\nPL_EXPORT(int)\t\tPL_cvt_set_encoding(int enc);\nPL_EXPORT(void)\t\tSP_set_state(int state);\nPL_EXPORT(int)\t\tSP_get_state(void);\n\n\n\t\t /*******************************\n\t\t *\t     COMPARE\t\t*\n\t\t *******************************/\n\nPL_EXPORT(int)\t\tPL_compare(term_t t1, term_t t2);\nPL_EXPORT(int)\t\tPL_same_compound(term_t t1, term_t t2);\n\n\t\t /*******************************\n\t\t *\t     MESSAGES\t\t*\n\t\t *******************************/\n\nPL_EXPORT(int)\t\tPL_warning(const char *fmt, ...);\nPL_EXPORT(void)\t\tPL_fatal_error(const char *fmt, ...);\n\n\t\t /*******************************\n\t\t *      RECORDED DATABASE\t*\n\t\t *******************************/\n\nPL_EXPORT(record_t)\tPL_record(term_t term);\nPL_EXPORT(int)\t\tPL_recorded(record_t record, term_t term);\nPL_EXPORT(void)\t\tPL_erase(record_t record);\nPL_EXPORT(record_t)\tPL_duplicate_record(record_t r);\n\nPL_EXPORT(char *)\tPL_record_external(term_t t, size_t *size);\nPL_EXPORT(int)\t\tPL_recorded_external(const char *rec, term_t term);\nPL_EXPORT(int)\t\tPL_erase_external(char *rec);\n\n\t\t /*******************************\n\t\t *\t   PROLOG FLAGS\t\t*\n\t\t *******************************/\n\n#define PL_set_feature  PL_set_prolog_flag /* compatibility */\nPL_EXPORT(int)\t\tPL_set_prolog_flag(const char *name, int type, ...);\n\n\n\t\t /*******************************\n\t\t *\tINTERNAL FUNCTIONS\t*\n\t\t *******************************/\n\nPL_EXPORT(PL_atomic_t)\t_PL_get_atomic(term_t t);\nPL_EXPORT(void)\t\t_PL_put_atomic(term_t t, PL_atomic_t a);\nPL_EXPORT(int)\t\t_PL_unify_atomic(term_t t, PL_atomic_t a);\nPL_EXPORT(int)\t\t_PL_get_arg_sz(size_t index, term_t t, term_t a);\nPL_EXPORT(int)\t\t_PL_get_arg(int index, term_t t, term_t a);\n\n\n\t\t /*******************************\n\t\t *\t    CHAR BUFFERS\t*\n\t\t *******************************/\n\n#define CVT_ATOM\t    0x00000001\n#define CVT_STRING\t    0x00000002\n#define CVT_LIST\t    0x00000004\n#define CVT_INTEGER\t    0x00000008\n#define CVT_RATIONAL\t    0x00000010\n#define CVT_FLOAT\t    0x00000020\n#define CVT_VARIABLE\t    0x00000040\n#define CVT_NUMBER\t    (CVT_RATIONAL|CVT_FLOAT)\n#define CVT_ATOMIC\t    (CVT_NUMBER|CVT_ATOM|CVT_STRING)\n#define CVT_WRITE\t    0x00000080\n#define CVT_WRITE_CANONICAL 0x00000080\n#define CVT_WRITEQ\t    0x000000C0\n#define CVT_ALL\t\t    (CVT_ATOMIC|CVT_LIST)\n#define CVT_MASK\t    0x00000fff\n\n#define CVT_EXCEPTION\t    0x00001000\t/* throw exception on error */\n#define CVT_VARNOFAIL\t    0x00002000\t/* return 2 if argument is unbound */\n\n#define BUF_DISCARDABLE\t    0x00000000\t/* Store in single thread-local buffer */\n#define BUF_STACK\t    0x00010000\t/* Store in stack of buffers */\n#define BUF_MALLOC\t    0x00020000\t/* Store using PL_malloc() */\n#define BUF_ALLOW_STACK\t    0x00040000\t/* Allow pointer into (global) stack */\n\n#define BUF_RING\t    BUF_STACK   /* legacy ring buffer */\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nOutput   representation   for   PL_get_chars()     and    friends.   The\nprepresentation type REP_FN is for   PL_get_file_name()  and friends. On\nWindows we use UTF-8 which is translated   by the `XOS' layer to Windows\nUNICODE file functions.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n#define REP_ISO_LATIN_1\t    0x00000000\t/* output representation */\n#define REP_UTF8\t    0x00100000\n#define REP_MB\t\t    0x00200000\n#ifdef __WINDOWS__\n#define REP_FN\t\t    REP_UTF8\n#else\n#define REP_FN\t\t    REP_MB\n#endif\n\n#define PL_DIFF_LIST\t    0x01000000\t/* PL_unify_chars() */\n\n\n                /*******************************\n                *         STRING BUFFERS       *\n                *******************************/\n\n#define PL_STRINGS_MARK() \\\n\t{ buf_mark_t __PL_mark; \\\n\t  PL_mark_string_buffers(&__PL_mark);\n#define PL_STRINGS_RELEASE() \\\n\t  PL_release_string_buffers_from_mark(__PL_mark); \\\n\t}\n\nPL_EXPORT(void)\t\tPL_mark_string_buffers(buf_mark_t *mark);\nPL_EXPORT(void)         PL_release_string_buffers_from_mark(buf_mark_t mark);\n\n\n#ifdef SIO_MAGIC\t\t\t/* defined from <SWI-Stream.h> */\n\t\t /*******************************\n\t\t *\t  STREAM SUPPORT\t*\n\t\t *******************************/\n\n\t\t\t\t\t/* Make IOSTREAM known to Prolog */\n#define PL_open_stream  PL_unify_stream\t/* compatibility */\nPL_EXPORT(int)\t\tPL_unify_stream(term_t t, IOSTREAM *s);\nPL_EXPORT(int)\t\tPL_get_stream_handle(term_t t, IOSTREAM **s);\nPL_EXPORT(int)\t\tPL_get_stream(term_t t, IOSTREAM **s, int flags);\nPL_EXPORT(IOSTREAM*)\tPL_acquire_stream(IOSTREAM *s);\nPL_EXPORT(int)\t\tPL_release_stream(IOSTREAM *s);\nPL_EXPORT(int)\t\tPL_release_stream_noerror(IOSTREAM *s);\nPL_EXPORT(IOSTREAM *)\tPL_open_resource(module_t m,\n\t\t\t\t\t const char *name,\n\t\t\t\t\t const char *rc_class,\n\t\t\t\t\t const char *mode);\n\nPL_EXPORT(IOSTREAM *)*_PL_streams(void);\t/* base of streams */\n#ifndef PL_KERNEL\n#define Suser_input     (_PL_streams()[0])\n#define Suser_output    (_PL_streams()[1])\n#define Suser_error     (_PL_streams()[2])\n#define Scurrent_input  (_PL_streams()[3])\n#define Scurrent_output (_PL_streams()[4])\n#endif\n\n#define PL_WRT_QUOTED\t\t0x01\t/* quote atoms */\n#define PL_WRT_IGNOREOPS\t0x02\t/* ignore list/operators */\n#define PL_WRT_NUMBERVARS\t0x04\t/* print $VAR(N) as a variable */\n#define PL_WRT_PORTRAY\t\t0x08\t/* call portray */\n#define PL_WRT_CHARESCAPES\t0x10\t/* Output ISO escape sequences */\n#define PL_WRT_BACKQUOTED_STRING 0x20\t/* Write strings as `...` */\n\t\t\t\t\t/* Write attributed variables */\n#define PL_WRT_ATTVAR_IGNORE\t0x040\t/* Default: just write the var */\n#define PL_WRT_ATTVAR_DOTS\t0x080\t/* Write as Var{...} */\n#define PL_WRT_ATTVAR_WRITE\t0x100\t/* Write as Var{Attributes} */\n#define PL_WRT_ATTVAR_PORTRAY\t0x200\t/* Use Module:portray_attrs/2 */\n#define PL_WRT_ATTVAR_MASK \\\n\t(PL_WRT_ATTVAR_IGNORE | \\\n\t PL_WRT_ATTVAR_DOTS | \\\n\t PL_WRT_ATTVAR_WRITE | \\\n\t PL_WRT_ATTVAR_PORTRAY)\n#define PL_WRT_BLOB_PORTRAY\t0x400\t/* Use portray to emit non-text blobs */\n#define PL_WRT_NO_CYCLES\t0x800\t/* Never emit @(Template,Subst) */\n#define PL_WRT_NEWLINE\t       0x2000\t/* Add a newline */\n#define PL_WRT_VARNAMES\t       0x4000\t/* Internal: variable_names(List)  */\n#define PL_WRT_BACKQUOTE_IS_SYMBOL 0x8000 /* ` is a symbol char */\n#define PL_WRT_DOTLISTS\t       0x10000\t/* Write lists as .(A,B) */\n#define PL_WRT_BRACETERMS      0x20000\t/* Write {A} as {}(A) */\n#define PL_WRT_NODICT\t       0x40000\t/* Do not write dicts in pretty syntax */\n#define PL_WRT_NODOTINATOM     0x80000\t/* never write a.b unquoted */\n#define PL_WRT_NO_LISTS\t       0x100000\t/* Do not write lists as [...] */\n#define PL_WRT_RAT_NATURAL     0x200000\t/* Write rationals as 1/3 */\n\nPL_EXPORT(int)\tPL_write_term(IOSTREAM *s,\n\t\t\t     term_t term,\n\t\t\t     int precedence,\n\t\t\t     int flags);\n\n\t\t\t\t\t/* PL_ttymode() results */\n#define PL_NOTTY\t0\t\t/* -tty in effect */\n#define PL_RAWTTY\t1\t\t/* get_single_char/1 */\n#define PL_COOKEDTTY\t2\t\t/* normal input */\n\nPL_EXPORT(int)\t\tPL_ttymode(IOSTREAM *s);\n\n#endif /*SIO_MAGIC*/\n\nPL_EXPORT(int)  PL_put_term_from_chars(term_t t, int flags,\n\t\t\t\t       size_t len, const char *s);\nPL_EXPORT(int)\tPL_chars_to_term(const char *chars,\n\t\t\t\tterm_t term);\nPL_EXPORT(int)\tPL_wchars_to_term(const pl_wchar_t *chars,\n\t\t\t\t term_t term);\n\n\n\t\t /*******************************\n\t\t *\t    EMBEDDING\t\t*\n\t\t *******************************/\n\nPL_EXPORT(int)\t\tPL_initialise(int argc, char **argv);\nPL_EXPORT(int)\t\tPL_is_initialised(int *argc, char ***argv);\nPL_EXPORT(int)\t\tPL_set_resource_db_mem(const unsigned char *data,\n\t\t\t\t\t       size_t size);\nPL_EXPORT(int)\t\tPL_toplevel(void);\nPL_EXPORT(int)\t\tPL_cleanup(int status);\nPL_EXPORT(void)\t\tPL_cleanup_fork();\nPL_EXPORT(int)\t\tPL_halt(int status);\n\n\t\t /*******************************\n\t\t *\t  DYNAMIC LINKING\t*\n\t\t *******************************/\n\nPL_EXPORT(void *)\tPL_dlopen(const char *file, int flags);\nPL_EXPORT(const char *) PL_dlerror(void);\nPL_EXPORT(void *)\tPL_dlsym(void *handle, char *symbol);\nPL_EXPORT(int)\t\tPL_dlclose(void *handle);\n\n\n\t\t /*******************************\n\t\t *      INPUT/PROMPT/ETC\t*\n\t\t *******************************/\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nNOTE: the functions in this section are   not  documented, as as yet not\nadviced for public usage.  They  are   intended  to  provide an abstract\ninterface for the GNU readline  interface   as  defined  in the readline\npackage.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\t\t\t\t\t/* PL_dispatch() modes */\n#define PL_DISPATCH_NOWAIT    0\t\t/* Dispatch only once */\n#define PL_DISPATCH_WAIT      1\t\t/* Dispatch till input available */\n#define PL_DISPATCH_INSTALLED 2\t\t/* dispatch function installed? */\n\nPL_EXPORT(int)\t\tPL_dispatch(int fd, int wait);\nPL_EXPORT(void)\t\tPL_add_to_protocol(const char *buf, size_t count);\nPL_EXPORT(char *)\tPL_prompt_string(int fd);\nPL_EXPORT(void)\t\tPL_write_prompt(int dowrite);\nPL_EXPORT(void)\t\tPL_prompt_next(int fd);\nPL_EXPORT(char *)\tPL_atom_generator(const char *prefix, int state);\nPL_EXPORT(pl_wchar_t*)\tPL_atom_generator_w(const pl_wchar_t *pref,\n\t\t\t\t\t    pl_wchar_t *buffer,\n\t\t\t\t\t    size_t buflen,\n\t\t\t\t\t    int state);\n\n\n\t\t /*******************************\n\t\t *\tMEMORY ALLOCATION\t*\n\t\t *******************************/\n\nPL_EXPORT(void *)\tPL_malloc(size_t size);\nPL_EXPORT(void *)\tPL_malloc_atomic(size_t size);\nPL_EXPORT(void *)\tPL_malloc_uncollectable(size_t size);\nPL_EXPORT(void *)\tPL_malloc_atomic_uncollectable(size_t size);\nPL_EXPORT(void *)\tPL_realloc(void *mem, size_t size);\nPL_EXPORT(void *)\tPL_malloc_unmanaged(size_t size);\nPL_EXPORT(void *)\tPL_malloc_atomic_unmanaged(size_t size);\nPL_EXPORT(void)\t\tPL_free(void *mem);\nPL_EXPORT(int)\t\tPL_linger(void *mem);\n\n\n\t\t/********************************\n\t\t*             HOOKS\t\t*\n\t\t********************************/\n\n#define PL_DISPATCH_INPUT   0\t\t/* There is input available */\n#define PL_DISPATCH_TIMEOUT 1\t\t/* Dispatch timeout */\n\ntypedef int  (*PL_dispatch_hook_t)(int fd);\ntypedef void (*PL_abort_hook_t)(void);\ntypedef void (*PL_initialise_hook_t)(int argc, char **argv);\ntypedef int  (*PL_agc_hook_t)(atom_t a);\n\nPL_EXPORT(PL_dispatch_hook_t)\tPL_dispatch_hook(PL_dispatch_hook_t);\nPL_EXPORT(void)\t\t\tPL_abort_hook(PL_abort_hook_t);\nPL_EXPORT(void)\t\t\tPL_initialise_hook(PL_initialise_hook_t);\nPL_EXPORT(int)\t\t\tPL_abort_unhook(PL_abort_hook_t);\nPL_EXPORT(PL_agc_hook_t)\tPL_agc_hook(PL_agc_hook_t);\n\n\n\t\t/********************************\n\t\t*            SIGNALS            *\n\t\t*********************************/\n\n/* PL_signal() masks (deprecated) */\n#define PL_SIGSYNC\t0x00010000\t/* call handler synchronously */\n#define PL_SIGNOFRAME\t0x00020000\t/* Do not create a Prolog frame */\n\n#define PLSIG_THROW     0x0002\t\t/* throw signal(num, name) */\n#define PLSIG_SYNC      0x0004\t\t/* call synchronously */\n#define PLSIG_NOFRAME   0x0008\t\t/* Do not create a Prolog frame */\n\n\n\n\ntypedef struct pl_sigaction\n{ void        (*sa_cfunction)(int);\t/* traditional C function */\n  predicate_t sa_predicate;\t\t/* call a predicate */\n  int\t      sa_flags;\t\t\t/* additional flags */\n  void       *reserved[2];\t\t/* future extentions */\n} pl_sigaction_t;\n\n\nPL_EXPORT(void) (*PL_signal(int sig, void (*func)(int)))(int);\nPL_EXPORT(int)  PL_sigaction(int sig, pl_sigaction_t *act, pl_sigaction_t *old);\nPL_EXPORT(void)\tPL_interrupt(int sig);\nPL_EXPORT(int)\tPL_raise(int sig);\nPL_EXPORT(int)\tPL_handle_signals(void);\nPL_EXPORT(int)\tPL_get_signum_ex(term_t sig, int *n);\n\n\n\t\t/********************************\n\t\t*      PROLOG ACTION/QUERY      *\n\t\t*********************************/\n\n#define\tPL_ACTION_TRACE\t\t1\t/* switch to trace mode */\n#define PL_ACTION_DEBUG\t\t2\t/* switch to debug mode */\n#define PL_ACTION_BACKTRACE\t3\t/* show a backtrace (stack dump) */\n#define PL_ACTION_BREAK\t\t4\t/* create a break environment */\n#define PL_ACTION_HALT\t\t5\t/* halt Prolog execution */\n#define PL_ACTION_ABORT\t\t6\t/* generate a Prolog abort */\n\t\t\t\t\t/* 7: Obsolete PL_ACTION_SYMBOLFILE */\n#define PL_ACTION_WRITE\t\t8\t/* write via Prolog i/o buffer */\n#define PL_ACTION_FLUSH\t\t9\t/* Flush Prolog i/o buffer */\n#define PL_ACTION_GUIAPP\t10\t/* Win32: set when this is a gui */\n#define PL_ACTION_ATTACH_CONSOLE 11\t/* MT: Attach a console */\n#define PL_GMP_SET_ALLOC_FUNCTIONS 12\t/* GMP: do not change allocation functions */\n#define PL_ACTION_TRADITIONAL\t13\t/* Set --traditional */\n\n#define PL_BT_SAFE\t\t0x1\t/* Do not try to print goals */\n#define PL_BT_USER\t\t0x2\t/* Only show user-goals */\n\nPL_EXPORT(int)\tPL_action(int, ...);\t/* perform some action */\nPL_EXPORT(void)\tPL_on_halt(int (*)(int, void *), void *);\nPL_EXPORT(void)\tPL_exit_hook(int (*)(int, void *), void *);\nPL_EXPORT(void)\tPL_backtrace(int depth, int flags);\nPL_EXPORT(char *) PL_backtrace_string(int depth, int flags);\nPL_EXPORT(int)\tPL_check_data(term_t data);\nPL_EXPORT(int)\tPL_check_stacks(void);\nPL_EXPORT(int)\tPL_current_prolog_flag(atom_t name, int type, void *ptr);\n\n\n\t\t /*******************************\n\t\t *\t      VERSIONS\t\t*\n\t\t *******************************/\n\n#define PL_VERSION_SYSTEM\t1\t/* Prolog version */\n#define PL_VERSION_FLI\t\t2\t/* PL_* compatibility */\n#define PL_VERSION_REC\t\t3\t/* PL_record_external() compatibility */\n#define PL_VERSION_QLF\t\t4\t/* Saved QLF format version */\n#define PL_VERSION_QLF_LOAD\t5\t/* Min loadable QLF format version */\n#define PL_VERSION_VM\t\t6\t/* VM signature */\n#define PL_VERSION_BUILT_IN\t7\t/* Built-in predicate signature */\n\nPL_EXPORT(unsigned int) PL_version(int which);\n\n\n\t\t/********************************\n\t\t*         QUERY PROLOG          *\n\t\t*********************************/\n\n#define PL_QUERY_ARGC\t\t1\t/* return main() argc */\n#define PL_QUERY_ARGV\t\t2\t/* return main() argv */\n\t\t\t\t\t/* 3: Obsolete PL_QUERY_SYMBOLFILE */\n\t\t\t\t\t/* 4: Obsolete PL_QUERY_ORGSYMBOLFILE*/\n#define PL_QUERY_GETC\t\t5\t/* Read character from terminal */\n#define PL_QUERY_MAX_INTEGER\t6\t/* largest integer */\n#define PL_QUERY_MIN_INTEGER\t7\t/* smallest integer */\n#define PL_QUERY_MAX_TAGGED_INT\t8\t/* largest tagged integer */\n#define PL_QUERY_MIN_TAGGED_INT\t9\t/* smallest tagged integer */\n#define PL_QUERY_VERSION        10\t/* 207006 = 2.7.6 */\n#define PL_QUERY_MAX_THREADS\t11\t/* maximum thread count */\n#define PL_QUERY_ENCODING\t12\t/* I/O encoding */\n#define PL_QUERY_USER_CPU\t13\t/* User CPU in milliseconds */\n#define PL_QUERY_HALTING\t14\t/* If TRUE, we are in PL_cleanup() */\n\nPL_EXPORT(intptr_t)\tPL_query(int);\t/* get information from Prolog */\n\n\n\t\t /*******************************\n\t\t *\t  PROLOG THREADS\t*\n\t\t *******************************/\n\n#define PL_THREAD_NO_DEBUG\t0x01\t/* Start thread in nodebug mode */\n#define PL_THREAD_NOT_DETACHED\t0x02\t/* Allow Prolog to join */\n\ntypedef enum\n{ PL_THREAD_CANCEL_FAILED = FALSE,\t/* failed to cancel; try abort */\n  PL_THREAD_CANCEL_JOINED = TRUE,\t/* cancelled and joined */\n  PL_THREAD_CANCEL_MUST_JOIN\t\t/* cancelled, must join */\n} rc_cancel;\n\ntypedef struct\n{ size_t    stack_limit;\t\t/* Total stack limit (bytes) */\n  size_t    table_space;\t\t/* Total tabling space limit (bytes) */\n  char *    alias;\t\t\t/* alias name */\n  rc_cancel (*cancel)(int id);\t\t/* cancel function */\n  intptr_t  flags;\t\t\t/* PL_THREAD_* flags */\n  size_t    max_queue_size;\t\t/* Max size of associated queue */\n  void *    reserved[3];\t\t/* reserved for extensions */\n} PL_thread_attr_t;\n\n\nPL_EXPORT(int)\tPL_thread_self(void);\t/* Prolog thread id (-1 if none) */\nPL_EXPORT(int)\tPL_unify_thread_id(term_t t, int i);\nPL_EXPORT(int)\tPL_get_thread_id_ex(term_t t, int *idp);\nPL_EXPORT(int)\tPL_get_thread_alias(int tid, atom_t *alias);\t/* Locks alias */\nPL_EXPORT(int)\tPL_thread_attach_engine(PL_thread_attr_t *attr);\nPL_EXPORT(int)\tPL_thread_destroy_engine(void);\nPL_EXPORT(int)\tPL_thread_at_exit(void (*function)(void *),\n\t\t\t\t  void *closure,\n\t\t\t\t  int global);\nPL_EXPORT(int)\tPL_thread_raise(int tid, int sig);\n#if defined(_WINDOWS_) || defined(_WINDOWS_H)\t/* <windows.h> is included */\nPL_EXPORT(int)\tPL_w32thread_raise(DWORD dwTid, int sig);\nPL_EXPORT(int)\tPL_wait_for_console_input(void *handle);\nPL_EXPORT(int)\tPL_w32_wrap_ansi_console(void);\nPL_EXPORT(const char*) PL_w32_running_under_wine(void);\n#endif\n\n\t\t /*******************************\n\t\t *\t ENGINES (MT-ONLY)\t*\n\t\t *******************************/\n\n#define PL_ENGINE_MAIN\t  ((PL_engine_t)0x1)\n#define PL_ENGINE_CURRENT ((PL_engine_t)0x2)\n\n#define PL_ENGINE_SET   0\t\t/* engine set successfully */\n#define PL_ENGINE_INVAL\t2\t\t/* engine doesn't exist */\n#define PL_ENGINE_INUSE\t3\t\t/* engine is in use */\n\nPL_EXPORT(PL_engine_t)\tPL_create_engine(PL_thread_attr_t *attributes);\nPL_EXPORT(int)\t\tPL_set_engine(PL_engine_t engine, PL_engine_t *old);\nPL_EXPORT(int)\t\tPL_destroy_engine(PL_engine_t engine);\n\n\n\t\t /*******************************\n\t\t *\t     PROFILER\t\t*\n\t\t *******************************/\n\ntypedef struct\n{ int\t(*unify)(term_t t, void *handle);\t/* implementation --> Prolog */\n  int   (*get)(term_t t, void **handle);\t/* Prolog --> implementation */\n  void\t(*activate)(int active);\t\t/* (de)activate */\n  intptr_t\tmagic;\t\t\t\t\t/* PROFTYPE_MAGIC */\n} PL_prof_type_t;\n\nPL_EXPORT(int)\t\tPL_register_profile_type(PL_prof_type_t *type);\nPL_EXPORT(void*)\tPL_prof_call(void *handle, PL_prof_type_t *type);\nPL_EXPORT(void)\t\tPL_prof_exit(void *node);\n\n\n\t\t /*******************************\n\t\t *\t      DEBUG\t\t*\n\t\t *******************************/\n\nPL_EXPORT(int)\t\tPL_prolog_debug(const char *topic);\nPL_EXPORT(int)\t\tPL_prolog_nodebug(const char *topic);\n\n\n\t\t /*******************************\n\t\t *\t WINDOWS MESSAGES\t*\n\t\t *******************************/\n\n#if defined(_WINDOWS_) || defined(_WINDOWS_H)\t/* <windows.h> is included */\n#define PL_MSG_EXCEPTION_RAISED -1\n#define PL_MSG_IGNORED 0\n#define PL_MSG_HANDLED 1\n\nPL_EXPORT(LRESULT)\tPL_win_message_proc(HWND hwnd,\n\t\t\t\t\t    UINT message,\n\t\t\t\t\t    WPARAM wParam,\n\t\t\t\t\t    LPARAM lParam);\n#endif /* _WINDOWS_/_WINDOWS_H */\n\n\n\t\t /*******************************\n\t\t *       FAST XPCE SUPPORT\t*\n\t\t *******************************/\n\ntypedef struct\n{ int type;\t\t\t\t/* PL_INTEGER or PL_ATOM */\n  union\n  { uintptr_t i;\t\t\t/* integer reference value */\n    atom_t\t  a;\t\t\t/* atom reference value */\n  } value;\n} xpceref_t;\n\nPL_EXPORT(int)\t_PL_get_xpce_reference(term_t t, xpceref_t *ref);\nPL_EXPORT(int)\t_PL_unify_xpce_reference(term_t t, xpceref_t *ref);\nPL_EXPORT(int)\t_PL_put_xpce_reference_i(term_t t, uintptr_t r);\nPL_EXPORT(int)\t_PL_put_xpce_reference_a(term_t t, atom_t name);\n\n\n\n\t\t /*******************************\n\t\t *         TRACE SUPPORT\t*\n\t\t *******************************/\n\n#ifndef _PL_INCLUDE_H\ntypedef void *QueryFrame;\ntypedef void *LocalFrame;\ntypedef void *Code;\n#endif\n\ntypedef struct pl_context_t\n{ PL_engine_t   ld;\t\t\t/* Engine */\n  QueryFrame\tqf;\t\t\t/* Current query */\n  LocalFrame\tfr;\t\t\t/* Current localframe */\n  Code\t\tpc;\t\t\t/* Code pointer */\n  void *\treserved[10];\t\t/* Reserved for extensions */\n} pl_context_t;\n\nPL_EXPORT(int)\tPL_get_context(struct pl_context_t *c, int thead_id);\nPL_EXPORT(int)\tPL_step_context(struct pl_context_t *c);\nPL_EXPORT(int)\tPL_describe_context(struct pl_context_t *c,\n\t\t\t\t    char *buf, size_t len);\n\n/* Define as 1 if undefined or defined as empty */\n#if !defined(PL_ARITY_AS_SIZE) || (0-PL_ARITY_AS_SIZE-1)==1\n#undef PL_ARITY_AS_SIZE\n#define PL_ARITY_AS_SIZE 1\n#endif\n\n#if PL_ARITY_AS_SIZE\n#define PL_new_functor(f,a) PL_new_functor_sz(f,a)\n#define PL_functor_arity(f) PL_functor_arity_sz(f)\n#define PL_get_name_arity(t,n,a) PL_get_name_arity_sz(t,n,a)\n#define PL_get_compound_name_arity(t,n,a) PL_get_compound_name_arity_sz(t,n,a)\n#define PL_get_arg(i,t,a) PL_get_arg_sz(i,t,a)\n#define PL_unify_arg(i,t,a) PL_unify_arg_sz(i,t,a)\n#ifndef _PL_INCLUDE_H\n#define _PL_get_arg(i,t,a) _PL_get_arg_sz(i,t,a)\n#endif\n#else\n#warning \"Term arity has changed from int to size_t.\"\n#warning \"Please update your code or use #define PL_ARITY_AS_SIZE 0.\"\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif /*_FLI_H_INCLUDED*/\n",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/src/pl-nt.c": "/*  Part of SWI-Prolog\n\n    Author:        Jan Wielemaker\n    E-mail:        J.Wielemaker@vu.nl\n    WWW:           http://www.swi-prolog.org\n    Copyright (c)  1995-2019, University of Amsterdam\n\t\t\t      CWI, Amsterdam\n    All rights reserved.\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n    1. Redistributions of source code must retain the above copyright\n       notice, this list of conditions and the following disclaimer.\n\n    2. Redistributions in binary form must reproduce the above copyright\n       notice, this list of conditions and the following disclaimer in\n       the documentation and/or other materials provided with the\n       distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n    COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n    ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n    POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#ifdef __WINDOWS__\n#include <winsock2.h>\t\t\t/* Needed on VC8 */\n#include <windows.h>\n\n#ifdef __MINGW32__\n#ifndef _WIN32_IE\n#define _WIN32_IE 0x0400\n#endif\n/* FIXME: these are copied from SWI-Prolog.h. */\n#define PL_MSG_EXCEPTION_RAISED -1\n#define PL_MSG_IGNORED 0\n#define PL_MSG_HANDLED 1\n#endif\n\n#include \"pl-incl.h\"\n#include \"os/pl-utf8.h\"\n#include <process.h>\n#include \"os/pl-ctype.h\"\n#include <stdio.h>\n#include <stdarg.h>\n#include \"os/SWI-Stream.h\"\n#include <process.h>\n#include <winbase.h>\n#ifdef HAVE_CRTDBG_H\n#include <crtdbg.h>\n#endif\n\n\n\t\t /*******************************\n\t\t *\t       CONSOLE\t\t*\n\t\t *******************************/\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nThere is no way to tell which subsystem   an app belongs too, except for\npeeking in its executable-header. This is a bit too much ...\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\nint\nhasConsole(void)\n{ HANDLE h;\n\n  if ( GD->os.gui_app == FALSE )\t/* has been set explicitly */\n    succeed;\n\n\t\t\t\t\t/* I found a console */\n  if ( (h = GetStdHandle(STD_OUTPUT_HANDLE)) != INVALID_HANDLE_VALUE )\n  { DWORD mode;\n\n    if ( GetConsoleMode(h, &mode) )\n      succeed;\n  }\n\n\t\t\t\t\t/* assume we are GUI */\n  fail;\n}\n\n\nint\nPL_wait_for_console_input(void *handle)\n{ BOOL rc;\n  HANDLE hConsole = handle;\n\n  for(;;)\n  { rc = MsgWaitForMultipleObjects(1,\n\t\t\t\t   &hConsole,\n\t\t\t\t   FALSE,\t/* wait for either event */\n\t\t\t\t   INFINITE,\n\t\t\t\t   QS_ALLINPUT);\n\n    if ( rc == WAIT_OBJECT_0+1 )\n    { MSG msg;\n\n      while( PeekMessage(&msg, NULL, 0, 0, PM_REMOVE) )\n      { TranslateMessage(&msg);\n\tDispatchMessage(&msg);\n      }\n    } else if ( rc == WAIT_OBJECT_0 )\n    { return TRUE;\n    } else\n    { DEBUG(MSG_WIN_API,\n\t    Sdprintf(\"MsgWaitForMultipleObjects(): 0x%x\\n\", rc));\n    }\n  }\n}\n\n\n\t\t /*******************************\n\t\t *\t    MESSAGE BOX\t\t*\n\t\t *******************************/\n\nvoid\nPlMessage(const char *fm, ...)\n{ va_list(args);\n\n  va_start(args, fm);\n\n  if ( hasConsole() )\n  { Sfprintf(Serror, \"SWI-Prolog: \");\n    Svfprintf(Serror, fm, args);\n    Sfprintf(Serror, \"\\n\");\n  } else\n  { char buf[1024];\n    int64_t hwndi;\n    HWND hwnd = NULL;\n    static atom_t ATOM_hwnd = 0;\n\n    if ( !ATOM_hwnd )\n      ATOM_hwnd = PL_new_atom(\"hwnd\");\n\n    if ( PL_current_prolog_flag(ATOM_hwnd, PL_INTEGER, &hwndi) )\n      hwnd = (HWND)(uintptr_t)hwndi;\n\n    vsprintf(buf, fm, args);\n    MessageBox(hwnd, buf, \"SWI-Prolog\", MB_OK|MB_TASKMODAL);\n  }\n\n  va_end(args);\n}\n\n\n\n\t\t /*******************************\n\t\t *\tWinAPI ERROR CODES\t*\n\t\t *******************************/\n\nconst char *\nWinError(void)\n{ int id = GetLastError();\n  char *msg;\n  static WORD lang;\n  static int lang_initialised = 0;\n\n  if ( !lang_initialised )\n    lang = MAKELANGID(LANG_ENGLISH, SUBLANG_ENGLISH_UK);\n\nagain:\n  if ( FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER|\n\t\t     FORMAT_MESSAGE_IGNORE_INSERTS|\n\t\t     FORMAT_MESSAGE_FROM_SYSTEM,\n\t\t     NULL,\t\t\t/* source */\n\t\t     id,\t\t\t/* identifier */\n\t\t     lang,\n\t\t     (LPTSTR) &msg,\n\t\t     0,\t\t\t\t/* size */\n\t\t     NULL) )\t\t\t/* arguments */\n  { atom_t a = PL_new_atom(msg);\n\n    LocalFree(msg);\n    lang_initialised = 1;\n\n    return stringAtom(a);\n  } else\n  { if ( lang_initialised == 0 )\n    { lang = MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT);\n      lang_initialised = 1;\n      goto again;\n    }\n\n    return \"Unknown Windows error\";\n  }\n}\n\n\n\t\t /*******************************\n\t\t *\t  SLEEP/1 SUPPORT\t*\n\t\t *******************************/\n\nint\nPause(double t)\n{ HANDLE h;\n\n  if ( (h = CreateWaitableTimer(NULL, TRUE, NULL)) )\n  { LARGE_INTEGER ft;\n\n    ft.QuadPart = -(LONGLONG)(t * 10000000.0); /* 100 nanosecs per tick */\n\n    SetWaitableTimer(h, &ft, 0, NULL, NULL, FALSE);\n    for(;;)\n    { int rc = MsgWaitForMultipleObjects(1,\n\t\t\t\t\t &h,\n\t\t\t\t\t FALSE,\n\t\t\t\t\t INFINITE,\n\t\t\t\t\t QS_ALLINPUT);\n      if ( rc == WAIT_OBJECT_0+1 )\n      { MSG msg;\n\n\twhile( PeekMessage(&msg, NULL, 0, 0, PM_REMOVE) )\n\t{ TranslateMessage(&msg);\n\t  DispatchMessage(&msg);\n\t}\n\n\tif ( PL_handle_signals() < 0 )\n\t{ CloseHandle(h);\n\t  return FALSE;\n\t}\n      } else\n\tbreak;\n    }\n    CloseHandle(h);\n\n    return TRUE;\n  } else\t\t\t\t/* Pre NT implementation */\n  { DWORD msecs = (DWORD)(t * 1000.0);\n\n    while( msecs >= 100 )\n    { Sleep(100);\n      if ( PL_handle_signals() < 0 )\n\treturn FALSE;\n      msecs -= 100;\n    }\n    if ( msecs > 0 )\n      Sleep(msecs);\n\n    return TRUE;\n  }\n}\n\n\n\t\t /*******************************\n\t\t *\t  SET FILE SIZE\t\t*\n\t\t *******************************/\n\n#ifndef HAVE_FTRUNCATE\n\nint\nftruncate(int fileno, int64_t length)\n{ errno_t e;\n\n  if ( (e=_chsize_s(fileno, length)) == 0 )\n    return 0;\n\n  errno = e;\n  return -1;\n}\n\n#endif\n\n\n\t\t /*******************************\n\t\t *\t QUERY CPU TIME\t\t*\n\t\t *******************************/\n\n#define nano * 0.0000001\n#define ntick 1.0\t\t\t/* manual says 100.0 ??? */\n\ndouble\nCpuTime(cputime_kind which)\n{ double t;\n  HANDLE proc = GetCurrentProcess();\n  FILETIME created, exited, kerneltime, usertime;\n\n  if ( GetProcessTimes(proc, &created, &exited, &kerneltime, &usertime) )\n  { FILETIME *p;\n\n    switch ( which )\n    { case CPU_USER:\n\tp = &usertime;\n\tbreak;\n      case CPU_SYSTEM:\n\tp = &kerneltime;\n        break;\n      default:\n\tassert(0);\n        return 0.0;\n    }\n    t = (double)p->dwHighDateTime * (4294967296.0 * ntick nano);\n    t += (double)p->dwLowDateTime  * (ntick nano);\n  } else\t\t\t\t/* '95, Windows 3.1/win32s */\n  { t = 0.0;\n  }\n\n  return t;\n}\n\n\nint\nCpuCount(void)\n{ SYSTEM_INFO si;\n\n  GetSystemInfo(&si);\n\n  return si.dwNumberOfProcessors;\n}\n\n\nvoid\nsetOSPrologFlags(void)\n{ PL_set_prolog_flag(\"cpu_count\", PL_INTEGER, CpuCount());\n}\n\n\nchar *\nfindExecutable(const char *module, char *exe, size_t exelen)\n{ int n;\n  wchar_t wbuf[MAXPATHLEN];\n  HMODULE hmod;\n\n  if ( module )\n  { if ( !(hmod = GetModuleHandle(module)) )\n    { hmod = GetModuleHandle(\"libswipl.dll\");\n      DEBUG(MSG_WIN_API,\n\t    Sdprintf(\"Warning: could not find module from \\\"%s\\\"\\n\"\n\t\t     \"Warning: Trying %s to find home\\n\",\n\t\t     module,\n\t\t     hmod ? \"\\\"LIBPL.DLL\\\"\" : \"executable\"));\n    }\n  } else\n    hmod = NULL;\n\n  if ( (n = GetModuleFileNameW(hmod, wbuf, MAXPATHLEN)) > 0 )\n  { wbuf[n] = EOS;\n    return _xos_long_file_name_toA(wbuf, exe, exelen);\n  } else if ( module )\n  { return PrologPath(module, exe, exelen);\n  } else\n    *exe = EOS;\n\n  return exe;\n}\n\n\t\t /*******************************\n\t\t *     SUPPORT FOR SHELL/2\t*\n\t\t *******************************/\n\ntypedef struct\n{ const char *name;\n  UINT        id;\n} showtype;\n\nstatic int\nget_showCmd(term_t show, UINT *cmd)\n{ char *s;\n  showtype *st;\n  static showtype types[] =\n  { { \"hide\",\t\t SW_HIDE },\n    { \"maximize\",\t SW_MAXIMIZE },\n    { \"minimize\",\t SW_MINIMIZE },\n    { \"restore\",\t SW_RESTORE },\n    { \"show\",\t\t SW_SHOW },\n    { \"showdefault\",\t SW_SHOWDEFAULT },\n    { \"showmaximized\",   SW_SHOWMAXIMIZED },\n    { \"showminimized\",   SW_SHOWMINIMIZED },\n    { \"showminnoactive\", SW_SHOWMINNOACTIVE },\n    { \"showna\",          SW_SHOWNA },\n    { \"shownoactive\",    SW_SHOWNOACTIVATE },\n    { \"shownormal\",      SW_SHOWNORMAL },\n\t\t\t\t\t/* compatibility */\n    { \"normal\",\t\t SW_SHOWNORMAL },\n    { \"iconic\",\t\t SW_MINIMIZE },\n    { NULL, 0 },\n  };\n\n  if ( show == 0 )\n  { *cmd = SW_SHOWNORMAL;\n    succeed;\n  }\n\n  if ( !PL_get_chars(show, &s, CVT_ATOM|CVT_EXCEPTION) )\n    fail;\n  for(st=types; st->name; st++)\n  { if ( streq(st->name, s) )\n    { *cmd = st->id;\n      succeed;\n    }\n  }\n\n  return PL_error(NULL, 0, NULL, ERR_DOMAIN,\n\t\t  PL_new_atom(\"win_show\"), show);\n}\n\n\n\nstatic int\nwin_exec(size_t len, const wchar_t *cmd, UINT show)\n{ GET_LD\n  STARTUPINFOW startup;\n  PROCESS_INFORMATION info;\n  int rval;\n  wchar_t *wcmd;\n\n  memset(&startup, 0, sizeof(startup));\n  startup.cb = sizeof(startup);\n  startup.wShowWindow = show;\n\n\t\t\t\t\t/* ensure 0-terminated */\n  wcmd = PL_malloc((len+1)*sizeof(wchar_t));\n  memcpy(wcmd, cmd, len*sizeof(wchar_t));\n  wcmd[len] = 0;\n\n  rval = CreateProcessW(NULL,\t\t/* app */\n\t\t\twcmd,\n\t\t\tNULL, NULL,\t/* security */\n\t\t\tFALSE,\t\t/* inherit handles */\n\t\t\t0,\t\t/* flags */\n\t\t\tNULL,\t\t/* environment */\n\t\t\tNULL,\t\t/* Directory */\n\t\t\t&startup,\n\t\t\t&info);\t\t/* process info */\n  PL_free(wcmd);\n\n  if ( rval )\n  { CloseHandle(info.hProcess);\n    CloseHandle(info.hThread);\n\n    succeed;\n  } else\n  { term_t tmp = PL_new_term_ref();\n\n    return ( PL_unify_wchars(tmp, PL_ATOM, len, cmd) &&\n\t     PL_error(NULL, 0, WinError(), ERR_SHELL_FAILED, tmp)\n\t   );\n  }\n}\n\n\nstatic void\nutf8towcs(wchar_t *o, const char *src)\n{ for( ; *src; )\n  { int wc;\n\n    src = utf8_get_char(src, &wc);\n    *o++ = wc;\n  }\n  *o = 0;\n}\n\n\nint\nSystem(char *command)\t\t\t/* command is a UTF-8 string */\n{ STARTUPINFOW sinfo;\n  PROCESS_INFORMATION pinfo;\n  int shell_rval;\n  size_t len;\n  wchar_t *wcmd;\n\n  memset(&sinfo, 0, sizeof(sinfo));\n  sinfo.cb = sizeof(sinfo);\n\n  len = utf8_strlen(command, strlen(command));\n  wcmd = PL_malloc((len+1)*sizeof(wchar_t));\n  utf8towcs(wcmd, command);\n\n  if ( CreateProcessW(NULL,\t\t\t/* module */\n\t\t      wcmd,\t\t\t/* command line */\n\t\t      NULL,\t\t\t/* Security stuff */\n\t\t      NULL,\t\t\t/* Thread security stuff */\n\t\t      FALSE,\t\t\t/* Inherit handles */\n\t\t      CREATE_NO_WINDOW,\t\t/* flags */\n\t\t      NULL,\t\t\t/* environment */\n\t\t      NULL,\t\t\t/* CWD */\n\t\t      &sinfo,\t\t\t/* startup info */\n\t\t      &pinfo) )\t\t\t/* process into */\n  { BOOL rval;\n    DWORD code;\n\n    CloseHandle(pinfo.hThread);\t\t\t/* don't need this */\n    PL_free(wcmd);\n\n    do\n    { MSG msg;\n\n      if ( PeekMessage(&msg, NULL, 0, 0, PM_REMOVE) )\n      { TranslateMessage(&msg);\n\tDispatchMessage(&msg);\n      } else\n\tSleep(50);\n\n      rval = GetExitCodeProcess(pinfo.hProcess, &code);\n    } while(rval == TRUE && code == STILL_ACTIVE);\n\n    shell_rval = (rval == TRUE ? code : -1);\n    CloseHandle(pinfo.hProcess);\n  } else\n  { PL_free(wcmd);\n    return shell_rval = -1;\n  }\n\n  return shell_rval;\n}\n\n\nword\npl_win_exec(term_t cmd, term_t how)\n{ wchar_t *s;\n  size_t len;\n  UINT h;\n\n  if ( PL_get_wchars(cmd, &len, &s, CVT_ALL|CVT_EXCEPTION) &&\n       get_showCmd(how, &h) )\n  { return win_exec(len, s, h);\n  } else\n    fail;\n}\n\ntypedef struct\n{ int   eno;\n  const char *message;\n} shell_error;\n\nstatic const shell_error se_errors[] =\n{ { 0 ,                     \"Out of memory or resources\" },\n  { ERROR_FILE_NOT_FOUND,   \"File not found\" },\n  { ERROR_PATH_NOT_FOUND,   \"path not found\" },\n  { ERROR_BAD_FORMAT,\t    \"Invalid .EXE\" },\n  { SE_ERR_ACCESSDENIED,    \"Access denied\" },\n  { SE_ERR_ASSOCINCOMPLETE, \"Incomplete association\" },\n  { SE_ERR_DDEBUSY,\t    \"DDE server busy\" },\n  { SE_ERR_DDEFAIL,         \"DDE transaction failed\" },\n  { SE_ERR_DDETIMEOUT,\t    \"DDE request timed out\" },\n  { SE_ERR_DLLNOTFOUND,\t    \"DLL not found\" },\n  { SE_ERR_FNF,\t\t    \"File not found (FNF)\" },\n  { SE_ERR_NOASSOC,\t    \"No association\" },\n  { SE_ERR_OOM,\t\t    \"Not enough memory\" },\n  { SE_ERR_PNF,\t\t    \"Path not found (PNF)\" },\n  { SE_ERR_SHARE,\t    \"Sharing violation\" },\n  { 0,\t\t\t    NULL }\n};\n\n\nstatic int\nwin_shell(term_t op, term_t file, term_t how)\n{ size_t lo, lf;\n  wchar_t *o, *f;\n  UINT h;\n  HINSTANCE instance;\n\n  if ( !PL_get_wchars(op,   &lo, &o, CVT_ALL|CVT_EXCEPTION|BUF_STACK) ||\n       !PL_get_wchars(file, &lf, &f, CVT_ALL|CVT_EXCEPTION|BUF_STACK) ||\n       !get_showCmd(how, &h) )\n    fail;\n\n  instance = ShellExecuteW(NULL, o, f, NULL, NULL, h);\n\n  if ( (intptr_t)instance <= 32 )\n  { const shell_error *se;\n\n    for(se = se_errors; se->message; se++)\n      { if ( se->eno == (int)(intptr_t)instance )\n\treturn PL_error(NULL, 0, se->message, ERR_SHELL_FAILED, file);\n    }\n    PL_error(NULL, 0, NULL, ERR_SHELL_FAILED, file);\n  }\n\n  succeed;\n}\n\n\nstatic\nPRED_IMPL(\"win_shell\", 2, win_shell2, 0)\n{ return win_shell(A1, A2, 0);\n}\n\n\nstatic\nPRED_IMPL(\"win_shell\", 3, win_shell3, 0)\n{ return win_shell(A1, A2, A3);\n}\n\n\nforeign_t\npl_win_module_file(term_t module, term_t file)\n{ char buf[MAXPATHLEN];\n  char *m;\n  char *f;\n\n  if ( !PL_get_chars(module, &m, CVT_ALL|CVT_EXCEPTION) )\n    fail;\n  if ( (f = findExecutable(m, buf, sizeof(buf))) )\n    return PL_unify_atom_chars(file, f);\n\n  fail;\n}\n\n\t\t /*******************************\n\t\t *\t  WINDOWS MESSAGES\t*\n\t\t *******************************/\n\nLRESULT\nPL_win_message_proc(HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)\n{\n#ifdef O_PLMT\n  if ( hwnd == NULL &&\n       message == WM_SIGNALLED &&\n       wParam == 0 &&\t\t\t/* or another constant? */\n       lParam == 0 )\n  { if ( PL_handle_signals() < 0 )\n      return PL_MSG_EXCEPTION_RAISED;\n\n    return PL_MSG_HANDLED;\n  }\n#endif\n\n  return PL_MSG_IGNORED;\n}\n\n\n\t\t /*******************************\n\t\t *\tDLOPEN AND FRIENDS\t*\n\t\t *******************************/\n\n#ifdef EMULATE_DLOPEN\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nThese functions emulate the bits from the ELF shared object interface we\nneed. They are used  by  pl-load.c,   which  defines  the  actual Prolog\ninterface.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n#ifdef HAVE_LIBLOADERAPI_H\n#include <LibLoaderAPI.h>\n#else\n#ifndef LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR\n#define LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR 0x00000100\n#endif\n#ifndef LOAD_LIBRARY_SEARCH_DEFAULT_DIRS\n#define LOAD_LIBRARY_SEARCH_DEFAULT_DIRS 0x00001000\n#endif\ntypedef void * DLL_DIRECTORY_COOKIE;\n#endif\n\nstatic const char *dlmsg;\nstatic DLL_DIRECTORY_COOKIE (WINAPI *f_AddDllDirectoryW)(wchar_t* dir);\nstatic BOOL (WINAPI *f_RemoveDllDirectory)(DLL_DIRECTORY_COOKIE);\n\nstatic DWORD\nload_library_search_flags(void)\n{ static int done = FALSE;\n  static DWORD flags = 0;\n\n  if ( !done )\n  { HMODULE kernel = GetModuleHandle(TEXT(\"kernel32.dll\"));\n\n    if ( (f_AddDllDirectoryW   = (void*)GetProcAddress(kernel, \"AddDllDirectory\")) &&\n\t (f_RemoveDllDirectory = (void*)GetProcAddress(kernel, \"RemoveDllDirectory\")) )\n    { flags = ( LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR|\n\t\tLOAD_LIBRARY_SEARCH_DEFAULT_DIRS );\n      DEBUG(MSG_WIN_API,\n\t    Sdprintf(\"LoadLibraryExW() flags are supported\\n\"));\n    } else\n    { DEBUG(MSG_WIN_API,\n\t    Sdprintf(\"LoadLibraryExW() flags are NOT supported\\n\"));\n    }\n    done = TRUE;\n  }\n\n  return flags;\n}\n\n\nstatic\nPRED_IMPL(\"win_add_dll_directory\", 2, win_add_dll_directory, 0)\n{ PRED_LD\n  char *dirs;\n\n  if ( PL_get_file_name(A1, &dirs, REP_UTF8) )\n  { size_t len = utf8_strlen(dirs, strlen(dirs));\n    wchar_t *dirw = alloca((len+10)*sizeof(wchar_t));\n    DLL_DIRECTORY_COOKIE cookie;\n\n    if ( _xos_os_filenameW(dirs, dirw, len+10) == NULL )\n      return PL_representation_error(\"file_name\");\n    if ( load_library_search_flags() )\n    { if ( (cookie = (*f_AddDllDirectoryW)(dirw)) )\n      { DEBUG(MSG_WIN_API,\n\t      Sdprintf(\"AddDllDirectory(%Ws) ok\\n\", dirw));\n\n\treturn PL_unify_int64(A2, (int64_t)(uintptr_t)cookie);\n      }\n      return PL_error(NULL, 0, WinError(), ERR_SYSCALL, \"AddDllDirectory()\");\n    } else\n      return FALSE;\n  } else\n    return FALSE;\n}\n\n\nstatic\nPRED_IMPL(\"win_remove_dll_directory\", 1, win_remove_dll_directory, 0)\n{ int64_t icookie;\n\n  if ( PL_get_int64_ex(A1, &icookie) )\n  { if ( f_RemoveDllDirectory )\n    { if ( (*f_RemoveDllDirectory)((DLL_DIRECTORY_COOKIE)(uintptr_t)icookie) )\n\treturn TRUE;\n\n      return PL_error(NULL, 0, WinError(), ERR_SYSCALL, \"RemoveDllDirectory()\");\n    } else\n      return FALSE;\n  } else\n    return FALSE;\n}\n\n\nstatic int\nis_windows_abs_path(const wchar_t *path)\n{ if ( path[1] == ':' && path[0] < 0x80 && iswalpha(path[0]) )\n    return TRUE;\t\t\t/* drive */\n  if ( path[0] == '\\\\' && path[1] == '\\\\' )\n    return TRUE;\t\t\t/* UNC */\n\n  return FALSE;\n}\n\nvoid *\nPL_dlopen(const char *file, int flags)\t/* file is in UTF-8, POSIX path */\n{ HINSTANCE h;\n  DWORD llflags = 0;\n  size_t len = utf8_strlen(file, strlen(file));\n  wchar_t *wfile = alloca((len+10)*sizeof(wchar_t));\n\n  if ( !wfile )\n  { dlmsg = \"No memory\";\n    return NULL;\n  }\n\n  if ( _xos_os_filenameW(file, wfile, len+10) == NULL )\n  { dlmsg = \"Name too long\";\n    return NULL;\n  }\n\n  DEBUG(MSG_WIN_API, Sdprintf(\"dlopen(%Ws)\\n\", wfile));\n\n  if ( is_windows_abs_path(wfile) )\n    llflags |= load_library_search_flags();\n\n  if ( (h = LoadLibraryExW(wfile, NULL, llflags)) )\n  { dlmsg = \"No Error\";\n    return (void *)h;\n  }\n\n  dlmsg = WinError();\n  return NULL;\n}\n\n\nconst char *\nPL_dlerror(void)\n{ return dlmsg;\n}\n\n\nvoid *\nPL_dlsym(void *handle, char *symbol)\n{ void *addr = GetProcAddress(handle, symbol);\n\n  if ( addr )\n  { dlmsg = \"No Error\";\n    return addr;\n  }\n\n  dlmsg = WinError();\n  return NULL;\n}\n\n\nint\nPL_dlclose(void *handle)\n{ FreeLibrary(handle);\n\n  return 0;\n}\n\n#endif /*EMULATE_DLOPEN*/\n\n\n\t\t /*******************************\n\t\t *\t SNPRINTF MADNESS\t*\n\t\t *******************************/\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nMS-Windows _snprintf() may look like C99 snprintf(), but is is not quite\nthe same: on overflow, the buffer is   *not* 0-terminated and the return\nis negative (unspecified how negative).  The   code  below  works around\nthis, returning count on overflow. This is still not the same as the C99\nversion that returns the  number  of   characters  that  would have been\nwritten, but it seems to be enough for our purposes.\n\nSee http://www.di-mgt.com.au/cprog.html#snprintf\n\nThe above came from the provided link, but it is even worse (copied from\nVS2005 docs):\n\n  - If len < count, then len characters are stored in buffer, a\n  null-terminator is appended, and len is returned.\n\n  - If len = count, then len characters are stored in buffer, no\n  null-terminator is appended, and len is returned.\n\n  - If len > count, then count characters are stored in buffer, no\n  null-terminator is appended, and a negative value is returned.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\nint\nms_snprintf(char *buffer, size_t count, const char *fmt, ...)\n{ va_list ap;\n  int ret;\n\n  va_start(ap, fmt);\n  ret = _vsnprintf(buffer, count-1, fmt, ap);\n  va_end(ap);\n\n  if ( ret < 0 || ret == count )\n  { ret = (int)count;\n    buffer[count-1] = '\\0';\n  }\n\n  return ret;\n}\n\n\n\n\t\t /*******************************\n\t\t *\t      FOLDERS\t\t*\n\t\t *******************************/\n\n#ifdef HAVE_SHLOBJ_H\n#include <shlobj.h>\n#endif\n\ntypedef struct folderid\n{ int csidl;\n  const char *name;\n} folderid;\n\nstatic const folderid folderids[] =\n{ { CSIDL_COMMON_ALTSTARTUP, \"common_altstartup\" },\n  { CSIDL_ALTSTARTUP, \"altstartup\" },\n  { CSIDL_APPDATA, \"appdata\" },\n  { CSIDL_COMMON_APPDATA, \"common_appdata\" },\n  { CSIDL_LOCAL_APPDATA, \"local_appdata\" },\n  { CSIDL_CONTROLS, \"controls\" },\n  { CSIDL_COOKIES, \"cookies\" },\n  { CSIDL_DESKTOP, \"desktop\" },\n  { CSIDL_COMMON_DESKTOPDIRECTORY, \"common_desktopdirectory\" },\n  { CSIDL_DESKTOPDIRECTORY, \"desktopdirectory\" },\n  { CSIDL_COMMON_FAVORITES, \"common_favorites\" },\n  { CSIDL_FAVORITES, \"favorites\" },\n  { CSIDL_FONTS, \"fonts\" },\n  { CSIDL_HISTORY, \"history\" },\n  { CSIDL_INTERNET_CACHE, \"internet_cache\" },\n  { CSIDL_INTERNET, \"internet\" },\n  { CSIDL_DRIVES, \"drives\" },\n  { CSIDL_PERSONAL, \"personal\" },\n  { CSIDL_NETWORK, \"network\" },\n  { CSIDL_NETHOOD, \"nethood\" },\n  { CSIDL_PERSONAL, \"personal\" },\n  { CSIDL_PRINTERS, \"printers\" },\n  { CSIDL_PRINTHOOD, \"printhood\" },\n  { CSIDL_COMMON_PROGRAMS, \"common_programs\" },\n  { CSIDL_PROGRAMS, \"programs\" },\n  { CSIDL_RECENT, \"recent\" },\n  { CSIDL_BITBUCKET, \"bitbucket\" },\n  { CSIDL_SENDTO, \"sendto\" },\n  { CSIDL_COMMON_STARTMENU, \"common_startmenu\" },\n  { CSIDL_STARTMENU, \"startmenu\" },\n  { CSIDL_COMMON_STARTUP, \"common_startup\" },\n  { CSIDL_STARTUP, \"startup\" },\n  { CSIDL_TEMPLATES, \"templates\" },\n  { 0, NULL }\n};\n\n\nstatic int\nunify_csidl_path(term_t t, int csidl)\n{ wchar_t buf[MAX_PATH];\n\n  if ( SHGetSpecialFolderPathW(0, buf, csidl, FALSE) )\n  { wchar_t *p;\n\n    for(p=buf; *p; p++)\n    { if ( *p == '\\\\' )\n\t*p = '/';\n    }\n\n    return PL_unify_wchars(t, PL_ATOM, -1, buf);\n  } else\n    return PL_error(NULL, 0, WinError(), ERR_SYSCALL, \"SHGetSpecialFolderPath\");\n}\n\n\nstatic\nPRED_IMPL(\"win_folder\", 2, win_folder, PL_FA_NONDETERMINISTIC)\n{ GET_LD\n  int n;\n\n  switch( CTX_CNTRL )\n  { case FRG_FIRST_CALL:\n      if ( PL_is_variable(A1) )\n      { n = 0;\n\tgoto generate;\n      } else\n      { char *s;\n\n\tif ( PL_get_chars(A1, &s, CVT_ATOM|CVT_EXCEPTION) )\n\t{ const folderid *fid;\n\n\t  for(fid = folderids; fid->name; fid++)\n\t  { if ( streq(s, fid->name) )\n\t      return unify_csidl_path(A2, fid->csidl);\n\t  }\n\n\t  { atom_t dom = PL_new_atom(\"win_folder\");\n\n\t    PL_error(NULL, 0, NULL, ERR_DOMAIN, dom, A1);\n\t    PL_unregister_atom(dom);\n\t    return FALSE;\n\t  }\n\t} else\n\t  return FALSE;\n      }\n    case FRG_REDO:\n    { fid_t fid;\n\n      n = (int)CTX_INT+1;\n\n      generate:\n\tfid = PL_open_foreign_frame();\n\tfor(; folderids[n].name; n++)\n\t{ if ( unify_csidl_path(A2, folderids[n].csidl) &&\n\t       PL_unify_atom_chars(A1, folderids[n].name) )\n\t  { PL_close_foreign_frame(fid);\n\t    ForeignRedoInt(n);\n\t  }\n\t  if ( PL_exception(0) )\n\t    PL_clear_exception();\n\t  PL_rewind_foreign_frame(fid);\n\t}\n\tPL_close_foreign_frame(fid);\n\treturn FALSE;\n    }\n    default:\n      succeed;\n  }\n}\n\n\n\n\t\t /*******************************\n\t\t *\t      REGISTRY\t\t*\n\t\t *******************************/\n\n#define wstreq(s,q) (wcscmp((s), (q)) == 0)\n\nstatic HKEY\nreg_open_key(const wchar_t *which, int create)\n{ HKEY key = HKEY_CURRENT_USER;\n  DWORD disp;\n  LONG rval;\n\n  while(*which)\n  { wchar_t buf[256];\n    wchar_t *s;\n    HKEY tmp;\n\n    for(s=buf; *which && !(*which == '/' || *which == '\\\\'); )\n      *s++ = *which++;\n    *s = '\\0';\n    if ( *which )\n      which++;\n\n    if ( wstreq(buf, L\"HKEY_CLASSES_ROOT\") )\n    { key = HKEY_CLASSES_ROOT;\n      continue;\n    } else if ( wstreq(buf, L\"HKEY_CURRENT_USER\") )\n    { key = HKEY_CURRENT_USER;\n      continue;\n    } else if ( wstreq(buf, L\"HKEY_LOCAL_MACHINE\") )\n    { key = HKEY_LOCAL_MACHINE;\n      continue;\n    } else if ( wstreq(buf, L\"HKEY_USERS\") )\n    { key = HKEY_USERS;\n      continue;\n    }\n\n    DEBUG(2, Sdprintf(\"Trying %s\\n\", buf));\n    if ( RegOpenKeyExW(key, buf, 0L, KEY_READ, &tmp) == ERROR_SUCCESS )\n    { RegCloseKey(key);\n      key = tmp;\n      continue;\n    }\n\n    if ( !create )\n      return NULL;\n\n    rval = RegCreateKeyExW(key, buf, 0, L\"\", 0,\n\t\t\t  KEY_ALL_ACCESS, NULL, &tmp, &disp);\n    RegCloseKey(key);\n    if ( rval == ERROR_SUCCESS )\n      key = tmp;\n    else\n      return NULL;\n  }\n\n  return key;\n}\n\n#define MAXREGSTRLEN 1024\n\nstatic\nPRED_IMPL(\"win_registry_get_value\", 3, win_registry_get_value, 0)\n{ GET_LD\n  DWORD type;\n  union\n  { BYTE bytes[MAXREGSTRLEN];\n    wchar_t wchars[MAXREGSTRLEN/sizeof(wchar_t)];\n    DWORD dword;\n  } data;\n  DWORD len = sizeof(data);\n  size_t klen, namlen;\n  wchar_t *k, *name;\n  HKEY key;\n\n  term_t Key = A1;\n  term_t Name = A2;\n  term_t Value = A3;\n\n  if ( !PL_get_wchars(Key, &klen, &k, CVT_ATOM|CVT_EXCEPTION) ||\n       !PL_get_wchars(Name, &namlen, &name, CVT_ATOM|CVT_ATOM) )\n    return FALSE;\n  if ( !(key=reg_open_key(k, FALSE)) )\n    return PL_error(NULL, 0, NULL, ERR_EXISTENCE, ATOM_key, Key);\n\n  DEBUG(9, Sdprintf(\"key = %p, name = %s\\n\", key, name));\n  if ( RegQueryValueExW(key, name, NULL, &type, data.bytes, &len)\n\t\t\t\t\t\t\t== ERROR_SUCCESS )\n  { RegCloseKey(key);\n\n    switch(type)\n    { case REG_SZ:\n\treturn PL_unify_wchars(Value, PL_ATOM,\n\t\t\t       len/sizeof(wchar_t)-1, data.wchars);\n      case REG_DWORD:\n\treturn PL_unify_integer(Value, data.dword);\n      default:\n\twarning(\"get_registry_value/2: Unknown registery-type: %d\", type);\n        fail;\n    }\n  }\n\n  return FALSE;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nGet the local, global,  trail  and   argument-stack  defaults  from  the\nregistry.  They  can  be  on  the   HKEY_CURRENT_USER  as  well  as  the\nHKEY_LOCAL_MACHINE  registries  to  allow   for    both   user-only  and\nsystem-wide settings.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\nstatic struct regdef\n{ const char *name;\n  size_t     *address;\n} const regdefs[] =\n{ { \"stackLimit\",   &GD->defaults.stack_limit },\n  { \"tableSpace\",   &GD->defaults.table_space },\n  { NULL,           NULL }\n};\n\n\nstatic void\nsetStacksFromKey(HKEY key)\n{ DWORD type;\n  union\n  { BYTE bytes[128];\n    DWORD dword;\n  } data;\n  DWORD len = sizeof(data);\n  const struct regdef *rd;\n\n  for(rd = regdefs; rd->name; rd++)\n  { if ( RegQueryValueEx(key, rd->name, NULL, &type, data.bytes, &len) ==\n\t\t\t\t\t\t\tERROR_SUCCESS &&\n\t type == REG_DWORD )\n    { DWORD v = data.dword;\n\n      *rd->address = (size_t)v;\n    }\n  }\n}\n\n\nvoid\ngetDefaultsFromRegistry(void)\n{ HKEY key;\n\n  if ( (key = reg_open_key(L\"HKEY_LOCAL_MACHINE/Software/SWI/Prolog\", FALSE)) )\n  { setStacksFromKey(key);\n    RegCloseKey(key);\n  }\n  if ( (key = reg_open_key(L\"HKEY_CURRENT_USER/Software/SWI/Prolog\", FALSE)) )\n  { setStacksFromKey(key);\n    RegCloseKey(key);\n  }\n}\n\n\nconst char *\nPL_w32_running_under_wine(void)\n{ static const char * (CDECL *pwine_get_version)(void);\n  HMODULE hntdll = GetModuleHandle(\"ntdll.dll\");\n\n  if ( !hntdll )\n  { return NULL;\n  }\n\n  if ( (pwine_get_version = (void *)GetProcAddress(hntdll, \"wine_get_version\")) )\n    return pwine_get_version();\n\n  return NULL;\n}\n\n\n\t\t /*******************************\n\t\t *      PUBLISH PREDICATES\t*\n\t\t *******************************/\n\nBeginPredDefs(win)\n  PRED_DEF(\"win_shell\", 2, win_shell2, 0)\n  PRED_DEF(\"win_shell\", 3, win_shell3, 0)\n  PRED_DEF(\"win_registry_get_value\", 3, win_registry_get_value, 0)\n  PRED_DEF(\"win_folder\", 2, win_folder, PL_FA_NONDETERMINISTIC)\n  PRED_DEF(\"win_add_dll_directory\", 2, win_add_dll_directory, 0)\n  PRED_DEF(\"win_remove_dll_directory\", 1, win_remove_dll_directory, 0)\nEndPredDefs\n\n#endif /*__WINDOWS__*/\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/src/pl-load.c": "/*  Part of SWI-Prolog\n\n    Author:        Jan Wielemaker\n    E-mail:        J.Wielemaker@vu.nl\n    WWW:           http://www.swi-prolog.org\n    Copyright (c)  1985-2020, University of Amsterdam\n                              VU University Amsterdam\n    All rights reserved.\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n    1. Redistributions of source code must retain the above copyright\n       notice, this list of conditions and the following disclaimer.\n\n    2. Redistributions in binary form must reproduce the above copyright\n       notice, this list of conditions and the following disclaimer in\n       the documentation and/or other materials provided with the\n       distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n    COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n    ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n    POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#include \"pl-incl.h\"\n#ifndef MAXPATHLEN\n#define MAXPATHLEN 1024\n#endif\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nSWI-Prolog interface for runtime loading of foreign code (plugins).\n\nCurrently, this interface is implemented only  for ELF systems (based on\ndlopen()) and HPUX (based on slh_load()).   Despite, this covers a large\nnumber of modern Unix platforms. To name a few: Solaris, Linux, freeBSD,\nIRIX, HPUX, MacOS X.\n\nFor some platforms we emulate the ELF   interface and set the cpp symbol\nEMULATE_DLOPEN. You find examples in pl-nt.c   (for Win32) and pl-beos.c\n(for BeOS).\n\nBasically, 3 operations are required:\n\n\topen_shared_object(+File, [+Options], -Handle)\n\t    Load a shared object into the current image.\n\n\tcall_shared_object_function(+Handle, +FunctionName)\n\t    Call a named function without arguments.  Return value\n\t    is ignored too.\n\n\tclose_shared_object(+Handle)\n\t    Unload a shared object.\n\nFeel free to add this functionality for your favorite OS and mail me the\ncontributions.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n\n\t\t /*******************************\n\t\t *     DLOPEN() AND FRIENDS\t*\n\t\t *******************************/\n\n#ifndef EMULATE_DLOPEN\n#ifdef HAVE_DLOPEN\t\t\t/* sysvr4, elf binaries */\n\n#ifdef HAVE_DLFCN_H\n#define _GNU_SOURCE\t\t\t/* get RTLD_DEFAULT */\n#include <dlfcn.h>\n#endif\n\n#else /*HAVE_DLOPEN*/\n\n#ifdef HAVE_SHL_LOAD\t\t\t/* HPUX */\n\n#include <dl.h>\n#define dlopen(path, flags) shl_load((path), (flags), 0L)\n#define dlclose(handle)\t    shl_unload((handle))\n#define dlerror()\t    OsError()\n\nvoid *\ndlsym(void *handle, const char *name)\n{ void *value;\n  shl_t h = handle;\n\n  if ( shl_findsym(&h, name, TYPE_PROCEDURE, &value) < 0 )\n    return NULL;\n\n  return value;\n}\n\n#define RTLD_LAZY\tBIND_DEFERRED\n#ifdef BIND_IMMEDIATE\n#define RTLD_NOW\tBIND_IMMEDIATE\n#endif\n\n#endif /*HAVE_SHL_LOAD*/\n#endif /*HAVE_DLOPEN*/\n#endif /*EMULATE_DLOPEN*/\n\n#if defined(HAVE_DLOPEN) || defined(HAVE_SHL_LOAD) || defined(EMULATE_DLOPEN)\n#define HAVE_SHARED_OBJECTS\n\n#ifndef RTLD_GLOBAL\t\t\t/* solaris defines this */\n#define RTLD_GLOBAL 0\n#endif\n#ifndef RTLD_NOW\t\t\t/* implicit on some versions */\n#define RTLD_NOW 0\n#endif\n#ifndef RTLD_LAZY\t\t\t/* freeBSD doesn't have this? */\n#define RTLD_LAZY 0\n#endif\n\ntypedef int (*dl_funcptr)();\n\ntypedef struct dl_entry *DlEntry;\nstruct dl_entry\n{ int\t  id;\t\t\t\t/* Prolog's identifier */\n  void   *dlhandle;\t\t\t/* DL libraries identifier */\n  atom_t  file;\t\t\t\t/* Loaded filed */\n  DlEntry next;\t\t\t\t/* Next in table */\n};\n\nint\tdl_plid;\t\t\t/* next id to give */\nDlEntry dl_head;\t\t\t/* loaded DL's */\nDlEntry dl_tail;\t\t\t/* end of this chain */\n\n#define DL_NOW\t  0x1\n#define DL_GLOBAL 0x2\n\n#ifndef EMULATE_DLOPEN\nvoid *\nPL_dlopen(const char *file, int flags)\n{ return dlopen(file, flags);\n}\n\nconst char *\nPL_dlerror(void)\n{ return dlerror();\n}\n\nvoid *\nPL_dlsym(void *handle, char *symbol)\n{\n#ifdef RTLD_DEFAULT\n  if ( !handle )\n    handle = RTLD_DEFAULT;\n#endif\n  return dlsym(handle, symbol);\n}\n\nint\nPL_dlclose(void *handle)\n{ return dlclose(handle);\n}\n\n#endif /*EMULATE_DLOPEN*/\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nunder_valgrind()\n\nTrue if we are running under valgrind.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n#ifdef HAVE_VALGRIND_VALGRIND_H\n#include <valgrind/valgrind.h>\n#else\n#define RUNNING_ON_VALGRIND (getenv(\"VALGRIND_OPTS\") != NULL)\n#endif\n\nstatic int\nunder_valgrind(void)\n{ static int vg = -1;\n\n  if ( vg == -1 )\n  {\n#ifdef RUNNING_ON_VALGRIND\n    if ( RUNNING_ON_VALGRIND )\n      vg = TRUE;\n    else\n#endif\n      vg = FALSE;\n  }\n\n  return vg;\n}\n\n\nstatic\nPRED_IMPL(\"$open_shared_object\", 3, open_shared_object, 0)\n{ PRED_LD\n  void *dlhandle;\n  char *fn;\n  atom_t afile;\n  DlEntry e;\n  int dlflags;\n  int n;\n\n  term_t file     = A1;\n  term_t plhandle = A2;\n  term_t flags    = A3;\n\n\n  if ( PL_get_integer(flags, &n) )\n  { dlflags = (n & DL_NOW) ? RTLD_NOW : RTLD_LAZY;\n    if ( n & DL_GLOBAL )\n      dlflags |= RTLD_GLOBAL;\n  } else\n    dlflags = RTLD_LAZY;\n\n  if ( !PL_get_atom_ex(file, &afile) ||\n       !PL_get_file_name(file, &fn, 0) )\n    fail;\n  if ( !(dlhandle = PL_dlopen(fn, dlflags)) )\n    return PL_error(NULL, 0, NULL, ERR_SHARED_OBJECT_OP,\n\t\t    ATOM_open, PL_dlerror());\n\n  e = allocHeapOrHalt(sizeof(struct dl_entry));\n\n  PL_LOCK(L_FOREIGN);\n  e->id       = ++dl_plid;\n  e->dlhandle = dlhandle;\n  e->file     = afile;\n  e->next     = NULL;\n\n  if ( !dl_tail )\n  { dl_tail = e;\n    dl_head = e;\n  } else\n  { dl_tail->next = e;\n    dl_tail = e;\n  }\n  PL_UNLOCK(L_FOREIGN);\n\n  return PL_unify_integer(plhandle, e->id);\n}\n\n\nstatic DlEntry\nfind_dl_entry(term_t h)\n{ GET_LD\n  DlEntry e;\n  int id;\n\n  if ( PL_get_integer(h, &id) )\n  { for(e = dl_head; e; e = e->next)\n    { if ( e->id == id )\n\treturn e;\n    }\n    PL_error(NULL, 0, NULL, ERR_EXISTENCE, ATOM_shared_object_handle, h);\n    return NULL;\n  }\n\n  PL_error(NULL, 0, NULL, ERR_TYPE, ATOM_shared_object_handle, h);\n\n  return NULL;\n}\n\n\nstatic\nPRED_IMPL(\"close_shared_object\", 1, close_shared_object, 0)\n{ DlEntry e = find_dl_entry(A1);\n\n  if ( e && e->dlhandle)\n  { if ( !under_valgrind() )\n      PL_dlclose(e->dlhandle);\n    e->dlhandle = NULL;\n\n    succeed;\n  }\n\n  fail;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nSome systems (notably MacOS X) prefixes symbols with _. In some version\nof this OS, dlsym() adds an _, in others not.  We'll try to work around\nthis junk with a runtime test ...\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\nstatic\nPRED_IMPL(\"call_shared_object_function\", 2, call_shared_object_function,\n\t  PL_FA_TRANSPARENT)\n{ DlEntry e = find_dl_entry(A1);\n  char *fname;\n  dl_funcptr ef;\n\n  if ( !e || !e->dlhandle ||\n       !PL_get_chars(A2, &fname, CVT_ALL|CVT_EXCEPTION) )\n    fail;\n\n#ifdef LD_SYMBOL_PREFIX\t\t\t/* first try plain anyway */\n  if ( !(ef = (dl_funcptr) PL_dlsym(e->dlhandle, fname)) )\n  { char symname[MAXSYMBOLLEN+1];\n\n    if ( strlen(fname)+strlen(LD_SYMBOL_PREFIX) > MAXSYMBOLLEN )\n      return PL_error(NULL, 0,\n\t\t      \"Symbol too long\",\n\t\t      ERR_REPRESENTATION,\n\t\t      PL_new_atom(\"symbol\"));\n\n    strcpy(symname, LD_SYMBOL_PREFIX);\n    strcat(symname, fname);\n    ef = (dl_funcptr) dlsym(e->dlhandle, symname);\n  }\n#else\n  ef = (dl_funcptr) PL_dlsym(e->dlhandle, fname);\n#endif\n  if ( ef )\n  { (*ef)();\n    succeed;\n  } else\n    fail;\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nUnload all foreign libraries.  As we are doing this at the very end of\nthe cleanup, it should be safe now.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\nvoid\ncleanupForeign(void)\n{ DlEntry e, next;\n\n  for(e = dl_head; e; e = next)\n  { next = e->next;\n\n    if ( e->dlhandle )\n    { if ( !under_valgrind() )\n\tPL_dlclose(e->dlhandle);\n    }\n\n    freeHeap(e, sizeof(*e));\n  }\n\n  dl_plid = 0;\n  dl_head = dl_tail = NULL;\n}\n\n#else /*HAVE_DLOPEN*/\n\n/* No-op stub for pl-init.c to call. */\nvoid\ncleanupForeign(void)\n{}\n\nstatic\nPRED_IMPL(\"$open_shared_object\", 3, open_shared_object, 0)\n{ return notImplemented(\"open_shared_object\", 3);\n}\n\n#endif /*HAVE_DLOPEN*/\n\n\t\t /*******************************\n\t\t *      PUBLISH PREDICATES\t*\n\t\t *******************************/\n\nBeginPredDefs(dlopen)\n  PRED_DEF(\"$open_shared_object\", 3, open_shared_object, 0)\n#ifdef HAVE_SHARED_OBJECTS\n  PRED_DEF(\"close_shared_object\", 1, close_shared_object, 0)\n  PRED_DEF(\"call_shared_object_function\", 2, call_shared_object_function,\n\t   PL_FA_TRANSPARENT)\n#endif\nEndPredDefs\n",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/src/pl-alloc.c": "/*  Part of SWI-Prolog\n\n    Author:        Jan Wielemaker\n    E-mail:        J.Wielemaker@vu.nl\n    WWW:           http://www.swi-prolog.org\n    Copyright (c)  1985-2020, University of Amsterdam\n                              VU University Amsterdam\n\t\t\t      CWI, Amsterdam\n    All rights reserved.\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n    1. Redistributions of source code must retain the above copyright\n       notice, this list of conditions and the following disclaimer.\n\n    2. Redistributions in binary form must reproduce the above copyright\n       notice, this list of conditions and the following disclaimer in\n       the documentation and/or other materials provided with the\n       distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n    COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n    ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n    POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#include \"pl-incl.h\"\n#include \"os/pl-cstack.h\"\n#include \"pl-dict.h\"\n#include <math.h>\n#ifdef HAVE_SYS_MMAN_H\n#define MMAP_STACK 1\n#include <sys/mman.h>\n#include <unistd.h>\n#ifndef MAP_ANONYMOUS\n#ifdef MAP_ANON\n#define MAP_ANONYMOUS MAP_ANON\n#else\n#define MAP_ANONYMOUS 0\n#endif\n#endif\n#endif\n\n#undef LD\n#define LD LOCAL_LD\n\n#if ALLOC_DEBUG\n#define ALLOC_FREE_MAGIC 0xFB\n#define ALLOC_NEW_MAGIC  0xF9\n#endif\n\n\n\t\t /*******************************\n\t\t *\t    USE BOEHM GC\t*\n\t\t *******************************/\n\n#if !defined(PL_ALLOC_DONE) && defined(HAVE_BOEHM_GC)\n#define PL_ALLOC_DONE 1\n#undef HAVE_MTRACE\n\nvoid *\nallocHeap(size_t n)\n{ void *mem = GC_MALLOC(n);\n\n#if ALLOC_DEBUG\n  if ( mem )\n    memset(mem, ALLOC_NEW_MAGIC, n);\n#endif\n\n  return mem;\n}\n\n\nvoid *\nallocHeapOrHalt(size_t n)\n{ void *mem = allocHeap(n);\n\n  if ( !mem )\n    outOfCore();\n\n  return mem;\n}\n\n\nvoid\nfreeHeap(void *mem, size_t n)\n{\n#if ALLOC_DEBUG\n  if ( mem )\n    memset(mem, ALLOC_FREE_MAGIC, n);\n#endif\n\n  GC_FREE(mem);\n}\n\n\n#ifdef GC_DEBUG\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nTo debug the  interaction  between  Boehm-GC   and  Prolog,  we  run the\ncollector in leak-detection mode.  Reported leaks can have three causes:\n\n  - They are real leaks. We would like to fix these, at least for the\n    non-GC version.\n  - They are caused by lacking traceable pointers.  This must be fixed\n    to run reliably under Boehm-GC.\n  - The are place that can currently not be safely removed.  We call\n    GC_LINGER() on such pointers.  These will be left to GC, but in\n    leak-detection mode we give them a reference to silence the leak\n    detector.\n\nGC_linger() is called to keep track of objects we would like to leave to\nGC because we are not sure they can be reclaimed safely now. We use this\nas a debugging aid if GC_DEBUG is enabled.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\ntypedef struct linger\n{ struct linger *next;\n  void\t        *object;\n} linger;\n\nlinger *GC_lingering = NULL;\n\nvoid\nGC_linger(void *ptr)\n{ linger *l = GC_MALLOC_UNCOLLECTABLE(sizeof(*l));\n\n  l->object = ptr;\n  PL_LOCK(L_ALLOC);\n  l->next = GC_lingering;\n  GC_lingering = l->next;\n  PL_UNLOCK(L_ALLOC);\n}\n\n#endif /*GC_DEBUG*/\n#endif /*HAVE_BOEHM_GC*/\n\n\n\t\t /*******************************\n\t\t *   USE PLAIN SYSTEM MALLOC\t*\n\t\t *******************************/\n\n#ifndef PL_ALLOC_DONE\n#if defined(HAVE_MTRACE) && defined(O_MAINTENANCE)\n#include <mcheck.h>\n#endif\n\nvoid *\nallocHeap(size_t n)\n{ void *mem = malloc(n);\n\n#if ALLOC_DEBUG\n  if ( mem )\n    memset((char *) mem, ALLOC_NEW_MAGIC, n);\n#endif\n\n  return mem;\n}\n\n\nvoid *\nallocHeapOrHalt(size_t n)\n{ if ( n )\n  { void *mem = allocHeap(n);\n\n    if ( !mem )\n      outOfCore();\n\n    return mem;\n  }\n\n  return NULL;\n}\n\n\nvoid\nfreeHeap(void *mem, size_t n)\n{\n#if ALLOC_DEBUG\n  memset((char *) mem, ALLOC_FREE_MAGIC, n);\n#else\n  (void)n;\n#endif\n\n  free(mem);\n}\n\n#endif /*PL_ALLOC_DONE*/\n\n\n\t\t /*******************************\n\t\t *\t LINGERING OBJECTS\t*\n\t\t *******************************/\n\nvoid\nlinger(linger_list** list, void (*unalloc)(void *), void *object)\n{ linger_list *c = allocHeapOrHalt(sizeof(*c));\n  linger_list *o;\n\n  c->generation\t= global_generation();\n  c->object\t= object;\n  c->unalloc\t= unalloc;\n\n  do\n  { o = *list;\n    c->next = o;\n  } while( !COMPARE_AND_SWAP_PTR(list, o, c) );\n}\n\nvoid\nfree_lingering(linger_list **list, gen_t generation)\n{ linger_list **p = list;\n  linger_list *c = *list;\n\n  while ( c )\n  { if ( c->generation < generation )\n    { while ( !COMPARE_AND_SWAP_PTR(p, c, c->next) )\n      { p = &(*p)->next;\n      }\n      (*c->unalloc)(c->object);\n      freeHeap(c, sizeof(*c));\n    } else\n    { p = &(*p)->next;\n    }\n    c = *p;\n  }\n}\n\n\t\t/********************************\n\t\t*             STACKS            *\n\t\t*********************************/\n\nint\nenableSpareStack(Stack s, int always)\n{ if ( s->spare && (roomStackP(s) < s->def_spare || always) )\n  { DEBUG(MSG_SPARE_STACK,\n\t  Sdprintf(\"Enabling spare on %s: %zd bytes\\n\", s->name, s->spare));\n    s->max = addPointer(s->max, s->spare);\n    s->spare = 0;\n    return TRUE;\n  }\n\n  return FALSE;\n}\n\n\nvoid\nenableSpareStacks(void)\n{ GET_LD\n\n  enableSpareStack((Stack)&LD->stacks.local,  FALSE);\n  enableSpareStack((Stack)&LD->stacks.global, FALSE);\n  enableSpareStack((Stack)&LD->stacks.trail,  FALSE);\n}\n\n\nstatic intptr_t\nenv_frames(LocalFrame fr)\n{ intptr_t count = 0;\n\n  while(fr)\n  { count++;\n    fr = parentFrame(fr);\n  }\n\n  return count;\n}\n\n\nstatic intptr_t\nchoice_points(Choice chp)\n{ GET_LD\n\n  intptr_t count = 0;\n  QueryFrame qfr = LD->query;\n\n  while( chp )\n  { count++;\n\n    if ( chp->parent )\n    { chp = chp->parent;\n    } else if ( qfr )\n    { assert(qfr->magic == QID_MAGIC);\n      chp = qfr->saved_bfr;\n      qfr = qfr->parent;\n    }\n  }\n\n  return count;\n}\n\n\n#define MAX_CYCLE     20\n#define CYCLE_CTX      1\n#define MAX_PRE_LOOP  20\n#define MIN_REPEAT   100\n\ntypedef struct cycle_entry\n{ LocalFrame frame;\n} cycle_entry;\n\nstatic int\nis_variant_frame(LocalFrame fr1, LocalFrame fr2 ARG_LD)\n{ if ( fr1->predicate == fr2->predicate )\n  { size_t arity = fr1->predicate->functor->arity;\n    size_t i;\n\n    for(i=0; i<arity; i++)\n    { if ( !is_variant_ptr(argFrameP(fr1, i), argFrameP(fr2, i) PASS_LD) )\n\treturn FALSE;\n    }\n\n    return TRUE;\n  }\n\n  return FALSE;\n}\n\n\nstatic int\nnon_terminating_recursion(LocalFrame fr0,\n\t\t\t  cycle_entry ce[MAX_CYCLE],\n\t\t\t  int *is_cycle\n\t\t\t  ARG_LD)\n{ int depth, mindepth = 1, repeat;\n  LocalFrame fr, ctx;\n\n  ce[0].frame = fr0;\n\nagain:\n  for( fr=parentFrame(fr0), depth=1;\n       fr && depth<MAX_CYCLE;\n       depth++, fr = parentFrame(fr) )\n  { if ( fr->predicate == fr0->predicate && depth >= mindepth )\n      break;\n    ce[depth].frame = fr;\n  }\n\n  if ( !fr || depth >= MAX_CYCLE )\n    return 0;\n\n  *is_cycle = is_variant_frame(fr0, fr PASS_LD);\n  ctx = fr;\n\n  for(repeat=MIN_REPEAT; fr && --repeat > 0; )\n  { int i;\n\n    for(i=0; fr && i<depth; i++, fr = parentFrame(fr))\n    { if ( fr->predicate != ce[i].frame->predicate )\n      { mindepth = depth+1;\n\tif ( mindepth > MAX_CYCLE )\n\t  return 0;\n\t// Sdprintf(\"Cycle not repeated at %d\\n\", i);\n\tgoto again;\n      }\n    }\n  }\n\n  if ( repeat == 0 )\n  { int nctx = CYCLE_CTX;\n\n    for(fr=ctx; fr && nctx-- > 0; fr = parentFrame(fr))\n      ce[depth++].frame = fr;\n\n    return depth;\n  }\n\n  return 0;\n}\n\nstatic int\nfind_non_terminating_recursion(LocalFrame fr, cycle_entry ce[MAX_CYCLE],\n\t\t\t       int *is_cycle ARG_LD)\n{ int max_pre_loop = MAX_PRE_LOOP;\n\n  for(; fr && max_pre_loop; fr = parentFrame(fr), max_pre_loop--)\n  { int len;\n\n    if ( (len=non_terminating_recursion(fr, ce, is_cycle PASS_LD)) )\n      return len;\n  }\n\n  return 0;\n}\n\n\nstatic int\ntop_of_stack(LocalFrame fr, cycle_entry ce[MAX_CYCLE], int maxdepth ARG_LD)\n{ int depth;\n\n  for(depth = 0; fr && depth < maxdepth; fr = parentFrame(fr), depth++)\n  { ce[depth].frame = fr;\n  }\n\n  return depth;\n}\n\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nPush a goal to the stack. This   code uses low-level primitives to avoid\nstack shifts. The goal is a term `Module:Head`, where each Head argument\nis a primitive (var, atom, number, string), a term `[Length]` for a list\nof length Length, a term `[cyclic_term]` if the list is cyclic otherwise\na term `Name/Arity` to indicate the principal functor.\n\nReturns `0` if there is no enough space to store this term.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\nstatic size_t\nsize_frame_term(LocalFrame fr)\n{ GET_LD\n  size_t arity = fr->predicate->functor->arity;\n  size_t size = 4 + 3 + arity+1;\n  size_t i;\n\n  for(i=0; i<arity; i++)\n  { Word p = argFrameP(fr, i);\n    deRef(p);\n\n    if ( isTerm(*p) )\n      size += 3;\t\t\t\t/* one of f/n, [Len] or [c] */\n  }\n\n  return size;\n}\n\n\nstatic word\npush_goal(LocalFrame fr)\n{ GET_LD\n  size_t arity = fr->predicate->functor->arity;\n  size_t i;\n  Word p = gTop;\n  word r = consPtr(p, STG_GLOBAL|TAG_COMPOUND);\n\n  p[0] = FUNCTOR_frame3;\n  p[1] = consInt(fr->level);\n  p[2] = consPtr(&p[4], STG_GLOBAL|TAG_COMPOUND);\n  p[3] = ATOM_nil;\t\t\t\t/* reserved */\n  p += 4;\n\n  p[0] = FUNCTOR_colon2;\n  p[1] = fr->predicate->module->name;\n  if ( arity > 0 )\n  { Word ad;\t\t\t\t\t/* argument descriptions */\n\n    p[2] = consPtr(&p[3], STG_GLOBAL|TAG_COMPOUND);\n    p += 3;\n    p[0] = fr->predicate->functor->functor;\n    p++;\n    ad = p+arity;\n    for(i=0; i<arity; i++)\n    { Word a = argFrameP(fr, i);\n\n      deRef(a);\n      if ( isTerm(*a) )\n      { *p++ = consPtr(ad, STG_GLOBAL|TAG_COMPOUND);\n\n\tif ( isList(*a) )\n\t{ Word tail;\n\t  intptr_t len = skip_list(a, &tail PASS_LD);\n\n\t  *ad++ = FUNCTOR_dot2;\n\t  deRef(tail);\n\t  if ( isList(*tail) )\n\t  { *ad++ = ATOM_cyclic_term;\n\t    *ad++ = ATOM_nil;\n\t  } else\n\t  { *ad++ = consInt(len);\n\t    *ad++ = *tail;\n\t  }\n\t} else\n\t{ FunctorDef f = valueFunctor(functorTerm(*a));\n\n\t  *ad++ = FUNCTOR_divide2;\n\t  *ad++ = f->name;\n\t  *ad++ = consInt(f->arity);\n\t}\n      } else\n      { *p++ = *a;\n      }\n    }\n    gTop = ad;\n  } else\n  { p[2] = fr->predicate->functor->name;\n    gTop = &p[3];\n  }\n\n  return r;\n}\n\n\nstatic word\npush_cycle(cycle_entry ce[MAX_CYCLE], int depth)\n{ GET_LD\n  size_t size = depth*3;\n  int i;\n\n  for(i=0; i<depth; i++)\n  { size += size_frame_term(ce[i].frame);\n  }\n\n  if ( gTop+size < gMax )\n  { Word p  = gTop;\n    word r  = consPtr(p, STG_GLOBAL|TAG_COMPOUND);\n\n    gTop = p+depth*3;\n    for(i=0; i<depth; i++, p+=3)\n    { p[0] = FUNCTOR_dot2;\n      p[1] = push_goal(ce[i].frame);\n      if ( i+1 < depth )\n\tp[2] = consPtr(&p[3], STG_GLOBAL|TAG_COMPOUND);\n      else\n\tp[2] = ATOM_nil;\n    }\n\n    return r;\n  } else\n    return 0;\n}\n\n\nstatic void\npush_stack(cycle_entry ce[MAX_CYCLE], int depth, atom_t name, Word *pp ARG_LD)\n{ word w;\n  Word p = *pp;\n\n  gTop = p+2;\n  if ( (w=push_cycle(ce, depth)) )\n  { *p++ = w;\n    *p++ = name;\n  } else\n  { gTop = p;\n  }\n\n  *pp = p;\n}\n\n\n\nstatic word\npush_overflow_context(Stack stack, int extra)\n{ GET_LD\n  int keys = 7;\n\n  if ( gTop+2*keys+extra < gMax )\n  { Word p = gTop;\n    Word dict = p;\n    cycle_entry ce[MAX_CYCLE+CYCLE_CTX];\n    int depth;\n\n    *p++ = dict_functor(1);\n    *p++ = ATOM_stack_overflow;\t\t\t/* dict tag */\n    *p++ = consInt(LD->stacks.limit/1024);\n    *p++ = ATOM_stack_limit;\t\t\t/* overflow */\n    *p++ = consInt(usedStack(local)/1024);\t/* K-bytes to avoid small int */\n    *p++ = ATOM_localused;\n    *p++ = consInt(usedStack(global)/1024);\n    *p++ = ATOM_globalused;\n    *p++ = consInt(usedStack(trail)/1024);\n    *p++ = ATOM_trailused;\n    if ( environment_frame )\n    { *p++ = consUInt(environment_frame->level);\n      *p++ = ATOM_depth;\n    }\n    *p++ = consInt(env_frames(environment_frame));\n    *p++ = ATOM_environments;\n    *p++ = consInt(choice_points(BFR));\n    *p++ = ATOM_choicepoints;\n    gTop = p;\n\n    if ( roomStack(local) < LD->stacks.local.def_spare + LOCAL_MARGIN )\n    { int is_cycle;\n\n      if ( (depth=find_non_terminating_recursion(environment_frame, ce,\n\t\t\t\t\t\t &is_cycle PASS_LD)) )\n      { push_stack(ce, depth, is_cycle ? ATOM_cycle : ATOM_non_terminating,\n\t\t   &p PASS_LD);\n      } else if ( (depth=top_of_stack(environment_frame, ce, 5 PASS_LD)) )\n      { push_stack(ce, depth, ATOM_stack, &p PASS_LD);\n      }\n    } else if ( (depth=top_of_stack(environment_frame, ce, 5 PASS_LD)) )\n    { push_stack(ce, depth, ATOM_stack, &p PASS_LD);\n    }\n\n    *dict = dict_functor((p-dict-2)/2);\t\t/* final functor */\n\n    dict_order(dict, FALSE PASS_LD);\n\n    return consPtr(dict, STG_GLOBAL|TAG_COMPOUND);\n  } else\n    return PL_new_atom(stack->name); /* The stack names are built-in atoms */\n}\n\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n(*)  outOfStack(stack,  how)  is  called  to   raise  a  stack  overflow\nexception. This can happen from two  placed:   the  VM and foreign code.\nWhen the error is thrown from the VM,  we have to be careful because the\nstate of the VM is unknown. Notably, we   might be in `body write' mode,\nwhich implies we are writing terms to   the  local stack above lTop. For\nthis reason, we cannot use  PL_open_foreign_frame().   So,  we build the\nerror term using low-level primitives that   only touch the global stack\nwith  a  few  cells   and   also    avoid   the   term   duplication  of\nPL_raise_exception().\n\nFIXME: We could consider reserving some space   on  the global stack for\nresource exceptions near the bottom. That would   also avoid the need to\nfreeze the global stack. One  problem  is   that  the  user  migh keep a\nreference to this reserved exception term,  which makes it impossible to\nreuse.\n\nOut of stack exception context:\n  - Stack sizes (Local, Global, Trail)\n  - Goal stack depth\n  - Ratio choice points/stack frames?\n  - Is there unbound recursion?\n  - Ratio global data reachable through environments and\n    choice points (requires running GC)\n  - Global storage only reachable through choice points\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\nint\noutOfStack(void *stack, stack_overflow_action how)\n{ GET_LD\n  Stack s = stack;\n  const char *msg = \"out-of-stack\";\n\n  if ( LD->outofstack == stack )\n  { Sdprintf(\"[Thread %d]: failed to recover from %s-overflow\\n\",\n\t     PL_thread_self(), s->name);\n    print_backtrace_named(msg);\n    save_backtrace(\"crash\");\n    print_backtrace_named(\"crash\");\n    fatalError(\"Sorry, cannot continue\");\n\n    return FALSE;\t\t\t\t/* NOTREACHED */\n  }\n\n  save_backtrace(msg);\n\n  if ( s->spare < s->def_spare/4 )\n  { Sdprintf(\"[Thread %d]: %s-overflow: spare=%ld (def=%ld)\\n\"\n\t     \"Last resource exception:\\n\",\n\t     PL_thread_self(), s->name, (long)s->spare, (long)s->def_spare);\n    print_backtrace_named(msg);\n  }\n\n  enableSpareStacks();\n  LD->trim_stack_requested = TRUE;\n  LD->exception.processing = TRUE;\n  LD->outofstack = stack;\n\n  switch(how)\n  { case STACK_OVERFLOW_THROW:\n    case STACK_OVERFLOW_RAISE:\n    { word ctx = push_overflow_context(s, 6);\n\n      if ( gTop+5 < gMax )\n      { Word p = gTop;\n\n\tp[0] = FUNCTOR_error2;\t\t\t/* see (*) above */\n\tp[1] = consPtr(&p[3], TAG_COMPOUND|STG_GLOBAL);\n\tp[2] = ctx;\n\tp[3] = FUNCTOR_resource_error1;\n\tp[4] = ATOM_stack;\n\tgTop += 5;\n\n\t*valTermRef(LD->exception.bin) = consPtr(p, TAG_COMPOUND|STG_GLOBAL);\n\tfreezeGlobal(PASS_LD1);\n      } else\n      { Sdprintf(\"ERROR: Out of global-stack.\\n\"\n\t\t \"ERROR: No room for exception term.  Aborting.\\n\");\n\t*valTermRef(LD->exception.bin) = ATOM_aborted;\n      }\n      exception_term = exception_bin;\n\n      if ( how == STACK_OVERFLOW_THROW &&\n\t   LD->exception.throw_environment )\n      {\t\t\t\t\t\t/* see PL_throw() */\n\tlongjmp(LD->exception.throw_environment->exception_jmp_env, 1);\n      }\n\n      return FALSE;\n    }\n    default:\n      assert(0);\n      fail;\n  }\n}\n\n\nint\nraiseStackOverflow(int overflow)\n{ GET_LD\n  Stack s;\n\n  switch(overflow)\n  { case LOCAL_OVERFLOW:    s = (Stack)&LD->stacks.local;    break;\n    case GLOBAL_OVERFLOW:   s = (Stack)&LD->stacks.global;   break;\n    case TRAIL_OVERFLOW:    s = (Stack)&LD->stacks.trail;    break;\n    case STACK_OVERFLOW:    s = &GD->combined_stack;         break;\n    case ARGUMENT_OVERFLOW: s = (Stack)&LD->stacks.argument; break;\n    case MEMORY_OVERFLOW:\n      return PL_error(NULL, 0, NULL, ERR_NOMEM);\n    case FALSE:\t\t\t\t/* some other error is pending */\n      return FALSE;\n    default:\n      s = NULL;\n      assert(0);\n  }\n\n  return outOfStack(s, STACK_OVERFLOW_RAISE);\n}\n\n\nvoid\npushArgumentStack__LD(Word p ARG_LD)\n{ Word *newbase;\n  size_t newsize = nextStackSize((Stack)&LD->stacks.argument, 1);\n\n  if ( newsize &&\n       (newsize = stack_nalloc(newsize)) &&\n       (newbase = stack_realloc(aBase, newsize)) )\n  { intptr_t as = newbase - aBase;\n\n    if ( as )\n    { QueryFrame qf;\n\n      aTop += as;\n      aBase = newbase;\n\n      for(qf=LD->query; qf; qf = qf->parent)\n\tqf->aSave += as;\n    }\n    aMax  = addPointer(newbase,  newsize);\n    *aTop++ = p;\n  } else\n    outOfStack((Stack)&LD->stacks.argument, STACK_OVERFLOW_THROW);\n}\n\n\nvoid\noutOfCore(void)\n{ fatalError(\"Could not allocate memory: %s\", OsError());\n}\n\n\n\t\t/********************************\n\t\t*        GLOBAL STACK           *\n\t\t*********************************/\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nallocGlobal() allocates on the global stack.  Many  functions  do  this\ninline  as  it is simple and usualy very time critical.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\nWord\nallocGlobal__LD(size_t n ARG_LD)\n{ Word result;\n\n  if ( !hasGlobalSpace(n) )\n  { int rc;\n\n    if ( (rc=ensureGlobalSpace(n, ALLOW_GC)) != TRUE )\n    { raiseStackOverflow(rc);\n      return NULL;\n    }\n  }\n\n  result = gTop;\n  gTop += n;\n\n  return result;\n}\n\nWord\nallocGlobalNoShift__LD(size_t n ARG_LD)\n{ Word result;\n\n  if ( gTop+n > gMax )\n    return NULL;\n\n  result = gTop;\n  gTop += n;\n\n  return result;\n}\n\n\nWord\nnewTerm(void)\n{ GET_LD\n  Word t = allocGlobal(1);\n\n  setVar(*t);\n\n  return t;\n}\n\n\t\t /*******************************\n\t\t *    OPERATIONS ON INTEGERS\t*\n\t\t *******************************/\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nTranslate  a  64-bit  integer  into   a    Prolog   cell.   Uses  tagged\nrepresentation if possible or allocates 64-bits on the global stack.\n\nReturn is one of:\n\n\tTRUE:\t\t Success\n\tFALSE:\t\t Interrupt\n\tGLOBAL_OVERFLOW: Stack overflow\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\nint\nput_int64(Word at, int64_t l, int flags ARG_LD)\n{ Word p;\n  word r, m;\n  int req;\n\n  r = consInt(l);\n  if ( valInt(r) == l )\n  { *at = r;\n    return TRUE;\n  }\n\n#if SIZEOF_VOIDP == 8\n  req = 3;\n#elif SIZEOF_VOIDP == 4\n  req = 4;\n#else\n#error \"FIXME: Unsupported sizeof word\"\n#endif\n\n  if ( !hasGlobalSpace(req) )\n  { int rc = ensureGlobalSpace(req, flags);\n\n    if ( rc != TRUE )\n      return rc;\n  }\n  p = gTop;\n  gTop += req;\n\n#if SIZEOF_VOIDP == 8\n  r = consPtr(p, TAG_INTEGER|STG_GLOBAL);\n  m = mkIndHdr(1, TAG_INTEGER);\n\n  *p++ = m;\n  *p++ = l;\n  *p   = m;\n#else\n#if SIZEOF_VOIDP == 4\n  r = consPtr(p, TAG_INTEGER|STG_GLOBAL);\n  m = mkIndHdr(2, TAG_INTEGER);\n\n  *p++ = m;\n#ifdef WORDS_BIGENDIAN\n  *p++ = (word)(l>>32);\n  *p++ = (word)l;\n#else\n  *p++ = (word)l;\n  *p++ = (word)(l>>32);\n#endif\n  *p   = m;\n#else\n#error \"FIXME: Unsupported sizeof intptr_t.\"\n#endif\n#endif\n\n  *at = r;\n  return TRUE;\n}\n\n\n\t\t /*******************************\n\t\t *    OPERATIONS ON STRINGS\t*\n\t\t *******************************/\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nTo distinguish between byte and wide strings,   the system adds a 'B' or\n'W' in front of the real string. For   a  'W', the following 3 bytes are\nignored to avoid alignment restriction problems.\n\nNote that these functions can trigger GC\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\nWord\nallocString(size_t len ARG_LD)\n{ size_t lw = (len+sizeof(word))/sizeof(word);\n  int pad = (int)(lw*sizeof(word) - len);\n  Word p = allocGlobal(2 + lw);\n  word m = mkStrHdr(lw, pad);\n\n  if ( !p )\n    return NULL;\n\n  p[0]    = m;\n  p[lw]   = 0L;\t\t\t\t/* zero the pad bytes */\n  p[lw+1] = m;\n\n  return p;\n}\n\n\nword\nglobalString(size_t len, const char *s)\n{ GET_LD\n  Word p = allocString(len+1 PASS_LD);\n\n  if ( p )\n  { char *q = (char *)&p[1];\n\n    *q++ = 'B';\n    memcpy(q, s, len);\n\n    return consPtr(p, TAG_STRING|STG_GLOBAL);\n  }\n\n  return 0;\n}\n\n\nword\nglobalWString(size_t len, const pl_wchar_t *s)\n{ GET_LD\n  const pl_wchar_t *e = &s[len];\n  const pl_wchar_t *p;\n  Word g;\n\n  for(p=s; p<e; p++)\n  { if ( *p > 0xff )\n      break;\n  }\n\n  if ( p == e )\t\t\t\t/* 8-bit string */\n  { unsigned char *t;\n\n    if ( !(g = allocString(len+1 PASS_LD)) )\n      return 0;\n    t = (unsigned char *)&g[1];\n    *t++ = 'B';\n    for(p=s; p<e; )\n      *t++ = (unsigned char)(*p++ & 0xff);\n  } else\t\t\t\t/* wide string */\n  { char *t;\n    pl_wchar_t *w;\n\n    if ( !(g = allocString((len+1)*sizeof(pl_wchar_t) PASS_LD)) )\n      return 0;\n    t = (char *)&g[1];\n    w = (pl_wchar_t*)t;\n    w[0] = 0;\n    *t = 'W';\n    memcpy(&w[1], s, len*sizeof(pl_wchar_t));\n  }\n\n  return consPtr(g, TAG_STRING|STG_GLOBAL);\n}\n\n\nchar *\ngetCharsString__LD(word w, size_t *len ARG_LD)\n{ Word p = valPtr(w);\n  word m = *p;\n  size_t wn  = wsizeofInd(m);\n  size_t pad = padHdr(m);\n  char *s;\n\n  if ( len )\n    *len = wn*sizeof(word) - pad - 1;\t/* -1 for the 'B' */\n\n  s = (char *)&p[1];\n\n  if ( *s == 'B' )\n    return s+1;\n\n  assert(*s == 'W');\n  return NULL;\n}\n\n\npl_wchar_t *\ngetCharsWString__LD(word w, size_t *len ARG_LD)\n{ Word p = valPtr(w);\n  word m = *p;\n  size_t wn  = wsizeofInd(m);\n  size_t pad = padHdr(m);\n  char *s;\n  pl_wchar_t *ws;\n\n  s = (char *)&p[1];\n  if ( *s != 'W' )\n    return NULL;\n\n  if ( len )\n    *len = ((wn*sizeof(word) - pad)/sizeof(pl_wchar_t)) - 1;\n\n  ws = (pl_wchar_t *)&p[1];\n  return ws+1;\n}\n\n\n\n\t\t /*******************************\n\t\t *     OPERATIONS ON DOUBLES\t*\n\t\t *******************************/\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nStorage of floats (doubles) on the  stacks   and  heap.  Such values are\npacked into two `guards words'. We  cannot   just  copy the double as it\nmight not be properly aligned.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\nint\nput_double(Word at, double d, int flags ARG_LD)\n{ Word p;\n  word m = mkIndHdr(WORDS_PER_DOUBLE, TAG_FLOAT);\n\n  if ( flags != ALLOW_CHECKED && !hasGlobalSpace(2+WORDS_PER_DOUBLE) )\n  { int rc = ensureGlobalSpace(2+WORDS_PER_DOUBLE, flags);\n\n    if ( rc != TRUE )\n      return rc;\n  }\n  p = gTop;\n  gTop += 2+WORDS_PER_DOUBLE;\n\n  *at = consPtr(p, TAG_FLOAT|STG_GLOBAL);\n\n  if ( isnan(d) )\n    d = PL_nan();\t\t\t/* SWI-Prolog canonical 1.5NaN */\n\n  *p++ = m;\n  memcpy(p, &d, sizeof(d));\n  p += WORDS_PER_DOUBLE;\n  *p = m;\n\n  return TRUE;\n}\n\n\n\t\t /*******************************\n\t\t *\t  64-BIT INTEGERS\t*\n\t\t *******************************/\n\n#if ALIGNOF_INT64_T != ALIGNOF_VOIDP\n\nint64_t\t\t\t\t\t/* take care of alignment! */\nvalBignum__LD(word w ARG_LD)\n{ Word p = valIndirectP(w);\n  union\n  { int64_t i;\n    word w[WORDS_PER_INT64];\n  } val;\n\n#if ( SIZEOF_VOIDP == 4 )\n  val.w[0] = p[0];\n  val.w[1] = p[1];\n#else\n#error \"Unsupported int64_t alignment conversion\"\n#endif\n\n  return val.i;\n}\n\n#endif\n\n\t\t /*******************************\n\t\t *  GENERIC INDIRECT OPERATIONS\t*\n\t\t *******************************/\n\nint\nequalIndirect(word w1, word w2)\n{ GET_LD\n  Word p1 = addressIndirect(w1);\n  Word p2 = addressIndirect(w2);\n\n  if ( *p1 == *p2 )\n  { size_t n = wsizeofInd(*p1);\n\n    while( n-- > 0 )\n    { if ( *++p1 != *++p2 )\n\tfail;\n    }\n\n    succeed;\n  }\n\n  fail;\n}\n\n\nsize_t\t\t\t\t\t/* size in cells */\ngsizeIndirectFromCode(Code pc)\n{ return wsizeofInd(pc[0]) + 2;\n}\n\n\nword\nglobalIndirectFromCode(Code *PC)\n{ GET_LD\n  Code pc = *PC;\n  word m = *pc++;\n  size_t n = wsizeofInd(m);\n  Word p = allocGlobal(n+2);\n\n  if ( p )\n  { word r = consPtr(p, tag(m)|STG_GLOBAL);\n\n    *p++ = m;\n    while(n-- > 0)\n      *p++ = *pc++;\n    *p++ = m;\n\n    *PC = pc;\n    return r;\n  } else\n    return 0;\n}\n\n\nstatic int\t\t\t\t/* used in pl-wam.c */\nequalIndirectFromCode(word a, Code *PC)\n{ GET_LD\n  Word pc = *PC;\n  Word pa = addressIndirect(a);\n\n  if ( *pc == *pa )\n  { size_t n = wsizeofInd(*pc);\n\n    while(n-- > 0)\n    { if ( *++pc != *++pa )\n\tfail;\n    }\n    pc++;\n    *PC = pc;\n    succeed;\n  }\n\n  fail;\n}\n\n\n\t\t /*******************************\n\t\t *\t     GNU MALLOC\t\t*\n\t\t *******************************/\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nThese functions are used by various   GNU-libraries and -when not linked\nwith the GNU C-library lead to   undefined  symbols. Therefore we define\nthem in SWI-Prolog so that we can   also  give consistent warnings. Note\nthat we must call plain system malloc as the library will call free() on\nit.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n#if !defined(xmalloc) && defined(O_XMALLOC)\n\nvoid *\nxmalloc(size_t size)\n{ void *mem;\n\n  if ( (mem = malloc(size)) )\n    return mem;\n  if ( size )\n    outOfCore();\n\n  return NULL;\n}\n\n\nvoid *\nxrealloc(void *mem, size_t size)\n{ void *newmem;\n\n  newmem = mem ? realloc(mem, size) : malloc(size);\n  if ( newmem )\n    return newmem;\n  if ( size )\n    outOfCore();\n\n  return NULL;\n}\n\n#endif /*xmalloc*/\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nAllocation on behalf of foreign code. There  is generally no need to use\nthis, unless malloced data is returned by Prolog and the foreign routine\nwants to free it (e.g. using BUF_MALLOC).\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\nvoid *\nPL_malloc(size_t size)\n{ void *mem;\n\n  if ( (mem = GC_MALLOC(size)) )\n    return mem;\n\n  outOfCore();\n\n  return NULL;\n}\n\n\nvoid *\nPL_malloc_atomic(size_t size)\n{ void *mem;\n\n  if ( (mem = GC_MALLOC_ATOMIC(size)) )\n    return mem;\n\n  outOfCore();\n\n  return NULL;\n}\n\n\nvoid *\nPL_malloc_uncollectable(size_t size)\n{ void *mem;\n\n  if ( (mem = GC_MALLOC_UNCOLLECTABLE(size)) )\n    return mem;\n\n  outOfCore();\n\n  return NULL;\n}\n\n\nvoid *\nPL_malloc_atomic_uncollectable(size_t size)\n{ void *mem;\n\n  if ( (mem = GC_MALLOC_ATOMIC_UNCOLLECTABLE(size)) )\n    return mem;\n\n  outOfCore();\n\n  return NULL;\n}\n\n\nvoid *\nPL_malloc_unmanaged(size_t size)\n{ void *mem;\n\n  if ( (mem = GC_MALLOC(size)) )\n  {\n#if defined(HAVE_BOEHM_GC) && defined(GC_FLAG_UNCOLLECTABLE)\n    GC_SET_FLAGS(mem, GC_FLAG_UNCOLLECTABLE);\n#endif\n    return mem;\n  }\n\n  outOfCore();\n\n  return NULL;\n}\n\n\nvoid *\nPL_malloc_atomic_unmanaged(size_t size)\n{ void *mem;\n\n  if ( (mem = GC_MALLOC_ATOMIC(size)) )\n  {\n#if defined(HAVE_BOEHM_GC) && defined(GC_FLAG_UNCOLLECTABLE)\n    GC_SET_FLAGS(mem, GC_FLAG_UNCOLLECTABLE);\n#endif\n    return mem;\n  }\n\n  outOfCore();\n\n  return NULL;\n}\n\n\nvoid *\nPL_realloc(void *mem, size_t size)\n{ void *newmem;\n\n  if ( !(newmem = GC_REALLOC(mem, size)) )\n    outOfCore();\n\n  return newmem;\n}\n\n\nvoid\nPL_free(void *mem)\n{ GC_FREE(mem);\n}\n\n\nint\nPL_linger(void *mem)\n{\n#if defined(HAVE_BOEHM_GC) && defined(GC_FLAG_UNCOLLECTABLE)\n  if ( mem )\n  { GC_CLEAR_FLAGS(mem, GC_FLAG_UNCOLLECTABLE);\n#ifdef GC_DEBUG\n    GC_linger(mem);\n#endif\n  }\n  return TRUE;\n#else\n  return FALSE;\n#endif\n}\n\n\n\t\t /*******************************\n\t\t *\t       INIT\t\t*\n\t\t *******************************/\n\n#ifdef HAVE_BOEHM_GC\nstatic void\nheap_gc_warn_proc(char *msg, GC_word arg)\n{\n#if ALLOC_DEBUG\n  Sdprintf(msg, arg);\n  save_backtrace(\"heap-gc-warning\");\n  print_backtrace_named(\"heap-gc-warning\");\n#endif\n}\n#endif\n\nstatic void\ninitHBase(void)\n{ void *p = GC_MALLOC(sizeof(void*));\n  uintptr_t base = (uintptr_t)p;\n\n  GC_FREE(p);\t\t\t\t/* Keep leak-detection happy */\n  base &= ~0xfffff;\t\t\t/* round down 1m */\n  GD->heap_base = base;\t\t\t/* for pointer <-> int conversion */\n}\n\n\nvoid\ninitAlloc(void)\n{ static int done = FALSE;\n\n  if ( done )\n    return;\n  done = TRUE;\n\n#if defined(_DEBUG) && defined(__WINDOWS__) && 0\n  _CrtSetDbgFlag(_CRTDBG_ALLOC_MEM_DF|\n\t\t _CRTDBG_CHECK_CRT_DF|\n\t\t //_CRTDBG_CHECK_ALWAYS_DF|\t/* very expensive */\n\t\t //_CRTDBG_DELAY_FREE_MEM_DF|   /* does not reuse freed mem */\n\t\t //_CRTDBG_LEAK_CHECK_DF|\n\t\t 0);\n#endif\n\n#ifdef HAVE_BOEHM_GC\n  GC_INIT();\n  GC_set_warn_proc(heap_gc_warn_proc);\n#endif\n\n#if defined(HAVE_MTRACE) && defined(O_MAINTENANCE)\n  if ( getenv(\"MALLOC_TRACE\") )\t\t/* glibc malloc tracer */\n    mtrace();\n#endif\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nFORCED_MALLOC_BASE is a debugging aid for  me   to  force  the system to\nallocate memory starting from a specific   address.  Probably only works\nproperly on Linux. Don't bother with it.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n#ifdef FORCED_MALLOC_BASE\n  start_memory((void *)FORCED_MALLOC_BASE);\n  Sdprintf(\"FORCED_MALLOC_BASE at 0x%08x\\n\", FORCED_MALLOC_BASE);\n#endif\n#if O_MALLOC_DEBUG\n  malloc_debug(O_MALLOC_DEBUG);\n#endif\n\n  initHBase();\n}\n\n\t\t /*******************************\n\t\t *\t    MMAP STACKS\t\t*\n\t\t *******************************/\n\n#ifdef  MMAP_STACK\n#define MMAP_THRESHOLD 32768\n\ntypedef struct\n{ size_t size;\t\t\t\t/* Size (including header) */\n  int\t mmapped;\t\t\t/* Is mmapped? */\n  double data[1];\t\t\t/* ensure alignment */\n} map_region;\n\n#define SA_OFFSET offsetof(map_region, data)\n\nstatic size_t\npgsize(void)\n{ static size_t sz = 0;\n\n  if ( !sz )\n    sz = sysconf(_SC_PAGESIZE);\n\n  return sz;\n}\n\nstatic inline size_t\nroundpgsize(size_t sz)\n{ size_t r = pgsize();\n\n  return ((sz+r-1)/r)*r;\n}\n\nsize_t\ntmp_nalloc(size_t req)\n{ if ( req < MMAP_THRESHOLD-SA_OFFSET )\n    return req;\n\n  return roundpgsize(req+SA_OFFSET)-SA_OFFSET;\n}\n\nsize_t\ntmp_nrealloc(void *mem, size_t req)\n{ if ( mem )\n  { map_region *reg = (map_region *)((char*)mem-SA_OFFSET);\n\n    if ( !reg->mmapped && req < MMAP_THRESHOLD-SA_OFFSET )\n      return req;\n\n    return roundpgsize(req+SA_OFFSET)-SA_OFFSET;\n  }\n\n  return tmp_nalloc(req);\n}\n\n\nsize_t\ntmp_malloc_size(void *mem)\n{ if ( mem )\n  { map_region *reg = (map_region *)((char*)mem-SA_OFFSET);\n    return reg->size-SA_OFFSET;\n  }\n\n  return 0;\n}\n\nvoid *\ntmp_malloc(size_t req)\n{ map_region *reg;\n  int mmapped;\n\n  req += SA_OFFSET;\n  if ( req < MMAP_THRESHOLD )\n  { reg = malloc(req);\n    mmapped = FALSE;\n  } else\n  { req = roundpgsize(req);\n\n    reg = mmap(NULL, req,\n\t       (PROT_READ|PROT_WRITE),\n\t       (MAP_PRIVATE|MAP_ANONYMOUS),\n\t       -1, 0);\n    if ( reg == MAP_FAILED )\n      reg = NULL;\n    mmapped = TRUE;\n  }\n\n  if ( reg )\n  { reg->size    = req;\n    reg->mmapped = mmapped;\n#ifdef O_DEBUG\n    memset(reg->data, 0xFB, req-SA_OFFSET);\n#endif\n\n    return reg->data;\n  }\n\n  return NULL;\n}\n\n\nvoid *\ntmp_realloc(void *mem, size_t req)\n{ if ( mem )\n  { map_region *reg = (map_region *)((char*)mem-SA_OFFSET);\n\n    req += SA_OFFSET;\n    if ( !reg->mmapped )\n    { if ( req < MMAP_THRESHOLD )\n      { map_region *nw = realloc(reg, req);\n\tif ( nw )\n\t{ nw->size = req;\n\t  return nw->data;\n\t}\n\treturn NULL;\n      } else\t\t\t\t/* malloc --> mmap */\n      { void *nw = tmp_malloc(req-SA_OFFSET);\n\tif ( nw )\n\t{ size_t copy = reg->size;\n\n\t  if ( copy > req )\n\t    copy = req;\n\n\t  memcpy(nw, mem, copy-SA_OFFSET);\n\t  free(reg);\n\t}\n\treturn nw;\n      }\n    } else\n    { req = roundpgsize(req);\n\n      if ( reg->size != req )\n      { if ( reg->size > req )\n\t{ size_t trunk = reg->size-req;\n\n\t  munmap((char*)reg+req, trunk);\n\t  reg->size = req;\n\n\t  return reg->data;\n\t} else\n\t{ void *ra = tmp_malloc(req);\n\n\t  if ( ra )\n\t  { memcpy(ra, mem, reg->size-SA_OFFSET);\n#ifdef O_DEBUG\n\t    memset((char*)ra+reg->size-SA_OFFSET, 0xFB,\n\t\t   req-(reg->size-SA_OFFSET));\n#endif\n\t    tmp_free(mem);\n\t  }\n\n\t  return ra;\n\t}\n      } else\n      { return mem;\n      }\n    }\n  } else\n  { return tmp_malloc(req);\n  }\n}\n\n\nvoid\ntmp_free(void *mem)\n{ if ( mem )\n  { map_region *reg = (map_region *)((char*)mem-SA_OFFSET);\n\n    if ( reg->mmapped )\n      munmap(reg, reg->size);\n    else\n      free(reg);\n  }\n}\n\n#else /*MMAP_STACK*/\n\nsize_t\ntmp_nalloc(size_t req)\n{ return req;\n}\n\nsize_t\ntmp_nrealloc(void *mem, size_t req)\n{ (void)mem;\n\n  return req;\n}\n\nsize_t\ntmp_malloc_size(void *mem)\n{ if ( mem )\n  { size_t *sp = mem;\n    return sp[-1];\n  }\n\n  return 0;\n}\n\nvoid *\ntmp_malloc(size_t size)\n{ void *mem = malloc(size+sizeof(size_t));\n\n  if ( mem )\n  { size_t *sp = mem;\n    *sp++ = size;\n#ifdef O_DEBUG\n    memset(sp, 0xFB, size);\n#endif\n\n    return sp;\n  }\n\n  return NULL;\n}\n\nvoid *\ntmp_realloc(void *old, size_t size)\n{ size_t *sp = old;\n  size_t osize = *--sp;\n  void *mem;\n\n#ifdef O_DEBUG\n  if ( (mem = tmp_malloc(size)) )\n  { memcpy(mem, old, (size>osize?osize:size));\n    tmp_free(old);\n    return mem;\n  }\n#else\n  (void)osize;\n  if ( (mem = realloc(sp, size+sizeof(size_t))) )\n  { sp = mem;\n    *sp++ = size;\n    return sp;\n  }\n#endif\n\n  return NULL;\n}\n\nvoid\ntmp_free(void *mem)\n{ size_t *sp = mem;\n  size_t osize = *--sp;\n\n#ifdef O_DEBUG\n  memset(sp, 0xFB, osize+sizeof(size_t));\n#else\n  (void)osize;\n#endif\n  free(sp);\n}\n\n#endif /*MMAP_STACK*/\n\nvoid *\nstack_malloc(size_t size)\n{ void *ptr = tmp_malloc(size);\n\n  if ( ptr )\n    ATOMIC_ADD(&GD->statistics.stack_space, tmp_malloc_size(ptr));\n\n  return ptr;\n}\n\nvoid *\nstack_realloc(void *mem, size_t size)\n{ size_t osize = tmp_malloc_size(mem);\n  void *ptr = tmp_realloc(mem, size);\n\n  if ( ptr )\n  { size = tmp_malloc_size(ptr);\n\n    if ( osize > size )\n      ATOMIC_SUB(&GD->statistics.stack_space, osize-size);\n    else\n      ATOMIC_ADD(&GD->statistics.stack_space, size-osize);\n  }\n\n  return ptr;\n}\n\nvoid\nstack_free(void *mem)\n{ size_t size = tmp_malloc_size(mem);\n\n  ATOMIC_SUB(&GD->statistics.stack_space, size);\n  tmp_free(mem);\n}\n\nsize_t\nstack_nalloc(size_t req)\n{ return tmp_nalloc(req);\n}\n\nsize_t\nstack_nrealloc(void *mem, size_t req)\n{ return tmp_nrealloc(mem, req);\n}\n\n\n\t\t /*******************************\n\t\t *\t       TCMALLOC\t\t*\n\t\t *******************************/\n\nstatic int (*fMallocExtension_GetNumericProperty)(const char *, size_t *);\nstatic int (*fMallocExtension_SetNumericProperty)(const char *, size_t);\nstatic void (*fMallocExtension_MarkThreadIdle)(void) = NULL;\nstatic void (*fMallocExtension_MarkThreadTemporarilyIdle)(void) = NULL;\nstatic void (*fMallocExtension_MarkThreadBusy)(void) = NULL;\n\nstatic const char* tcmalloc_properties[] =\n{ \"generic.current_allocated_bytes\",\n  \"generic.heap_size\",\n  \"tcmalloc.max_total_thread_cache_bytes\",\n  \"tcmalloc.current_total_thread_cache_bytes\",\n  \"tcmalloc.central_cache_free_bytes\",\n  \"tcmalloc.transfer_cache_free_bytes\",\n  \"tcmalloc.thread_cache_free_bytes\",\n  \"tcmalloc.pageheap_free_bytes\",\n  \"tcmalloc.pageheap_unmapped_bytes\",\n  NULL\n};\n\nstatic foreign_t\nmalloc_property(term_t prop, control_t handle)\n{ GET_LD\n  const char **pname;\n\n  switch( PL_foreign_control(handle) )\n  { case PL_FIRST_CALL:\n    { atom_t name;\n      size_t arity;\n\n      if ( PL_get_name_arity(prop, &name, &arity) && arity == 1 )\n      { const char *s = PL_atom_nchars(name, NULL);\n\n\tif ( s )\n\t{ pname = tcmalloc_properties;\n\n\t  for(; *pname; pname++)\n\t  { if ( streq(s, *pname) )\n\t    { size_t val;\n\n\t      if ( fMallocExtension_GetNumericProperty(*pname, &val) )\n\t      { term_t a = PL_new_term_ref();\n\t\t_PL_get_arg(1, prop, a);\n\t\treturn PL_unify_uint64(a, val);\n\t      }\n\t    }\n\t  }\n\t}\n\n\treturn FALSE;\n      } else if ( PL_is_variable(prop) )\n      { pname = tcmalloc_properties;\n\tgoto enumerate;\n      }\n    }\n    case PL_REDO:\n    { fid_t fid;\n\n      pname = PL_foreign_context_address(handle);\n    enumerate:\n\n      fid = PL_open_foreign_frame();\n      for(; *pname; pname++)\n      { size_t val;\n\n\tif ( fMallocExtension_GetNumericProperty(*pname, &val) )\n\t{ if ( PL_unify_term(prop, PL_FUNCTOR_CHARS, *pname, 1,\n\t\t\t             PL_INT64, val) )\n\t  { PL_close_foreign_frame(fid);\n\t    pname++;\n\t    if ( *pname )\n\t      PL_retry_address(pname);\n\t    else\n\t      return TRUE;\n\t  }\n\t}\n\n\tif ( PL_exception(0) )\n\t  return FALSE;\n\tPL_rewind_foreign_frame(fid);\n      }\n      PL_close_foreign_frame(fid);\n\n      return FALSE;\n    }\n    case PL_CUTTED:\n    { return TRUE;\n    }\n    default:\n    { assert(0);\n      return FALSE;\n    }\n  }\n}\n\nstatic foreign_t\nset_malloc(term_t prop)\n{ GET_LD\n  atom_t name;\n  size_t arity;\n\n  if ( PL_get_name_arity(prop, &name, &arity) && arity == 1 )\n  { const char *s = PL_atom_nchars(name, NULL);\n    term_t a = PL_new_term_ref();\n    size_t val;\n\n    if ( !PL_get_arg(1, prop, a) ||\n\t !PL_get_size_ex(a, &val) )\n      return FALSE;\n\n    if ( s )\n    { const char **pname = tcmalloc_properties;\n\n      for(; *pname; pname++)\n      { if ( streq(s, *pname) )\n\t{ if ( fMallocExtension_SetNumericProperty(*pname, val) )\n\t    return TRUE;\n\t  else\n\t    return PL_permission_error(\"set\", \"malloc_property\", prop);\n\t}\n      }\n\n      return PL_domain_error(\"malloc_property\", prop);\n    }\n  }\n\n  return PL_type_error(\"malloc_property\", prop);\n}\n\n\nsize_t\nheapUsed(void)\n{ size_t val;\n\n  if (fMallocExtension_GetNumericProperty &&\n      fMallocExtension_GetNumericProperty(\"generic.current_allocated_bytes\", &val))\n  {\n#ifdef MMAP_STACK\n    val += GD->statistics.stack_space;\n#endif\n\n    return val;\n  }\n\n  return 0;\n}\n\n\nint\ninitTCMalloc(void)\n{ static int done = FALSE;\n  int set = 0;\n\n  if ( done )\n    return !!fMallocExtension_GetNumericProperty;\n  done = TRUE;\n\n  if ( (fMallocExtension_GetNumericProperty =\n\t\tPL_dlsym(NULL, \"MallocExtension_GetNumericProperty\")) )\n  { PL_register_foreign_in_module(\"system\", \"malloc_property\", 1, malloc_property,\n\t\t\tPL_FA_NONDETERMINISTIC);\n    set++;\n  }\n  if ( (fMallocExtension_SetNumericProperty =\n\t\tPL_dlsym(NULL, \"MallocExtension_SetNumericProperty\")) )\n  { PL_register_foreign_in_module(\"system\", \"set_malloc\", 1, set_malloc, 0);\n    set++;\n  }\n\n  fMallocExtension_MarkThreadIdle =\n    PL_dlsym(NULL, \"MallocExtension_MarkThreadIdle\");\n  fMallocExtension_MarkThreadTemporarilyIdle =\n    PL_dlsym(NULL, \"MallocExtension_MarkThreadTemporarilyIdle\");\n  fMallocExtension_MarkThreadBusy =\n    PL_dlsym(NULL, \"MallocExtension_MarkThreadBusy\");\n\n  return set;\n}\n\n\n/** thread_idle(:Goal, +How)\n *\n */\n\nstatic\nPRED_IMPL(\"thread_idle\", 2, thread_idle, PL_FA_TRANSPARENT)\n{ PRED_LD\n  int rc;\n  atom_t how;\n\n  if ( !PL_get_atom_ex(A2, &how) )\n    return FALSE;\n\n  if ( how == ATOM_short )\n  { trimStacks(TRUE PASS_LD);\n    if ( fMallocExtension_MarkThreadTemporarilyIdle &&\n\t fMallocExtension_MarkThreadBusy )\n      fMallocExtension_MarkThreadTemporarilyIdle();\n  } else if ( how == ATOM_long )\n  { LD->trim_stack_requested = TRUE;\n    garbageCollect(GC_USER);\n    LD->trim_stack_requested = FALSE;\n    if ( fMallocExtension_MarkThreadIdle  &&\n\t fMallocExtension_MarkThreadBusy )\n      fMallocExtension_MarkThreadIdle();\n  }\n\n  rc = callProlog(NULL, A1, PL_Q_PASS_EXCEPTION, NULL);\n\n  if ( fMallocExtension_MarkThreadBusy )\n    fMallocExtension_MarkThreadBusy();\n\n  return rc;\n}\n\n\n\n\t\t /*******************************\n\t\t *\t      PREDICATES\t*\n\t\t *******************************/\n\n#ifdef HAVE_BOEHM_GC\nstatic\nPRED_IMPL(\"garbage_collect_heap\", 0, garbage_collect_heap, 0)\n{ GC_gcollect();\n\n  return TRUE;\n}\n#endif\n\nBeginPredDefs(alloc)\n#ifdef HAVE_BOEHM_GC\n  PRED_DEF(\"garbage_collect_heap\", 0, garbage_collect_heap, 0)\n#endif\n  PRED_DEF(\"thread_idle\", 2, thread_idle, PL_FA_TRANSPARENT)\nEndPredDefs\n",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/src/pl-beos.c": "/*  Part of SWI-Prolog\n\n    Author:        Alex D\u00f6rfler\n    E-mail:        axeld@pinc-software.de\n    WWW:           http://www.swi-prolog.org\n    Copyright (c)  2002-2018, University of Amsterdam\n    All rights reserved.\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n    1. Redistributions of source code must retain the above copyright\n       notice, this list of conditions and the following disclaimer.\n\n    2. Redistributions in binary form must reproduce the above copyright\n       notice, this list of conditions and the following disclaimer in\n       the documentation and/or other materials provided with the\n       distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n    COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n    ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n    POSSIBILITY OF SUCH DAMAGE.\n*/\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nThis module is  written  by   Alex  D\u00f6rfler,  axeld@pinc-software.de and\nintegrated into SWI-Prolog by Jan Wielemaker.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n#ifdef __BEOS__\n#include \"pl-incl.h\"\n\n\n\t\t /*******************************\n\t\t *\tDLOPEN AND FRIENDS\t*\n\t\t *******************************/\n\n#ifdef EMULATE_DLOPEN\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nThese functions emulate the bits from the ELF shared object interface we\nneed. They are used  by  pl-load.c,   which  defines  the  actual Prolog\ninterface.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\nvoid *\nPL_dlopen(const char *file, int flags)\n{ image_id image = load_add_on(file);\n\n  if ( image < B_OK )\n  { LD->os.dl_error = image;\n    return NULL;\n  }\n\n  LD->os.dl_error = B_OK;\n  return (void *)image;\n}\n\n\nconst char *\nPL_dlerror()\n{ return strerror(LD->os.dl_error);\n}\n\n\nvoid *\nPL_dlsym(void *handle, char *symbol)\n{ void *address;\n\n  LD->os.dl_error = get_image_symbol((image_id)handle,\n\t\t\t\t     symbol,\n\t\t\t\t     B_SYMBOL_TYPE_TEXT,\n\t\t\t\t     &address);\n  if ( LD->os.dl_error == B_OK )\n    return address;\n\n  return NULL;\n}\n\n\nint\nPL_dlclose(void *handle)\n{ return unload_add_on((image_id)handle);\n}\n\n#endif\t/* EMULATE_DLOPEN */\n\n#endif\t/* __BEOS__ */\n",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/src/x11/x11-compat.c": "/*  Part of XPCE --- The SWI-Prolog GUI toolkit\n\n    Author:        Jan Wielemaker and Anjo Anjewierden\n    E-mail:        jan@swi.psy.uva.nl\n    WWW:           http://www.swi.psy.uva.nl/projects/xpce/\n    Copyright (c)  1985-2002, University of Amsterdam\n    All rights reserved.\n\n    Redistribution and use in source and binary forms, with or without\n    modification, are permitted provided that the following conditions\n    are met:\n\n    1. Redistributions of source code must retain the above copyright\n       notice, this list of conditions and the following disclaimer.\n\n    2. Redistributions in binary form must reproduce the above copyright\n       notice, this list of conditions and the following disclaimer in\n       the documentation and/or other materials provided with the\n       distribution.\n\n    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n    \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n    FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n    COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n    INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n    BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n    LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n    CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n    LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n    ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n    POSSIBILITY OF SUCH DAMAGE.\n*/\n\n#include <h/kernel.h>\n#include <h/graphics.h>\n\n\t\t/********************************\n\t\t*            HACKS ...\t\t*\n\t\t********************************/\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nWho  the   hell is using  these!?   It doesn't  seem  to be  the X11R5\nlibraries.  It certainly ain't PCE itself.  Nevertheless someone seems\nto refer  to them.  Unfortunately they only  in a dynamic library  and\nthus cannot be loaded through many foreign  language interfaces.  What\nto do????\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n#if !defined(HAVE_LIBDL) && defined(__sun__) && XT_REVISION == 5\n\nvoid *\ndlopen(char *path, int mode)\n{ Cprintf(\"dlopen(%s, %d)\\n\", path, mode);\n\n  return NULL;\n}\n\n\nvoid *\ndlsym(void *handle, char *symbol)\n{ Cprintf(\"dlsym(%p, %s)\\n\", handle, symbol);\n\n  return NULL;\n}\n\n\nvoid *\ndlclose(void *handle)\n{ Cprintf(\"dlclose (%p)\\n\", handle);\n\n  return NULL;\n}\n\n#endif\n\n/* - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\nMore of this nonsens.  RS6000 this time ...\n\n\tnm -pgo /usr/lib/libX11.a | grep _iconv_open\n\tshr4.o:         U __iconv_open\n\tshr4.o:0000fc18 T .__iconv_open\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - */\n\n#if _AIX\nvoid *\n__iconv_open()\n{ Cprintf(\"_iconv_open() called\\n\");\n\n  return NULL;\n}\n#endif\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/src/swipl.ico",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/src/minizip/file.zip",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/src/libtai/leapsecs.dat",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/src/Tests/xsb/sub_tests/Data/decker_facts.P",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/src/Tests/charset/UTF-8-test.txt",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/snap/gui/swipl.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/man/figs/xrefchatdep.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/man/figs/broadcast.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/man/figs/swipl.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/man/figs/xrefchatfile.gif",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/man/figs/by-sa.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/man/figs/broadcast.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/man/figs/profnode.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/man/figs/profnode.gif",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/man/figs/swipl.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/man/figs/by-sa.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/man/figs/xrefchatfile.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/man/figs/xrefchatdep.gif",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/ssl/etc/client/client-cert.p12",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/RDF/suite/t38.rdf",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/ltx2htm/icons/next.gif",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/ltx2htm/icons/prev.gif",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/ltx2htm/icons/home.gif",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/ltx2htm/icons/index.gif",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/ltx2htm/icons/yellow_pages.gif",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/ltx2htm/icons/up.gif",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/ltx2htm/icons/info.gif",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/swipl-win/swipl.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/swipl-win/swipl.icns",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/table/test.dat",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/zlib/tests/binary-file.gz",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/zlib/tests/ascii-file.gz",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/zlib/tests/utf8-file.gz",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/zlib/tests/multipart-file.gz",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/zlib/tests/empty-file.gz",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/zlib/tests/low-compression.gz",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/zlib/tests/high-compression.gz",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/semweb/modules.gif",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/semweb/figs/modules.pd",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/semweb/figs/modules.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/semweb/Tests/test-002.rdf.gz",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/protobufs/golden_message.2.5.0",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/protobufs/golden_message.2.3.0",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/pldoc/editpred.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/pldoc/multi-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/pldoc/source.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/pldoc/priv-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/pldoc/private.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/pldoc/reload.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/pldoc/h1-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/pldoc/public.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/pldoc/edit.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/pldoc/favicon.ico",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/pldoc/h2-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/pldoc/up.gif",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/pldoc/pub-bg.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/lib/x11.crs",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/prolog/lib/man/classification.dat",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/prolog/lib/trace/pltracer.hlp",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/appl-help/emacs.hlp",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/appl-help/event_monitor.hlp",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/appl-help/pcefaq.hlp",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/appl-help/pcedraw.hlp",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/appl-help/dialog.hlp",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/appl-help/help.hlp",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/appl-help/customise.hlp",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/appl-help/plprefs.hlp",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/swipl/swipl.ico",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/TeX/figs/manpce.gif",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/TeX/figs/swi.pd",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/userguide/figs/classbrowser.pd",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/userguide/figs/classhierarchy.pd",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/userguide/figs/vishierarchy.pd",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/userguide/figs/layoutmgr.pd",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/userguide/figs/docclasses.pd",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/userguide/figs/broadcast.pd",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/tools.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/topics.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/errors.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/bug_fixes.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/predicates.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/groups.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/objects.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/changes.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/examples.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/constraint.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/colour.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/identity.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/table.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/attribute.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/stream.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/text.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/relation_table.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/modifier.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/parser.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/format.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/obtain.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/function.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/tuple.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/while.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/and.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/graphical.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/button.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/text_item.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/@=.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/table_column.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/browser_select_gesture.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/gesture.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/regex.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/pixmap.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/get_method.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/code.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/send_method.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/variable.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/not.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/syntax_table.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/box.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/tile_adjuster.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/equal.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/text_image.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/visual.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/class_variable.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/lesseq.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/char_array.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/point.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/bezier_curve.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/chain_hyper.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/table_cell.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/chain.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/label_box.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/binary_condition.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/tree.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/tile.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/grbox.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/socket.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/event_node.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/resize_outline_gesture.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/hyper.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/greateq.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/label.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/when.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/vector.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/device.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/relation.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/move_gesture.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/process.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/style.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/tbox.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/number.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/slider.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/view.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/arrow.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/prolog_term.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/region.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/dict_item.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/bool.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/pce.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/recogniser.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/c_pointer.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/message.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/dialog_group.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/popup_gesture.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/circle.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/source_location.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/editor.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/list_browser.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/win_metafile.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/elevation.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/name.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/click_gesture.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/browser.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/binary_expression.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/lbox.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/line.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/hash_table.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/handle.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/file.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/string.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/dialog.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/less.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/sheet.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/program_object.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/resource.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/picture.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/scroll_bar.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/quote_function.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/timer.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/event_tree.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/text_margin.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/layout_manager.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/win_printer.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/bitmap.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/path.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/display.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/handler_group.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/resize_table_slice_gesture.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/date.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/tab.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/figure.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/if.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/image.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/host_data.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/nameref.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/ellipse.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/rubber.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/joint.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/noteq.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/plus.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/text_cursor.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/assign.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/size.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/eq.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/key_binding.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/connect_gesture.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/code_vector.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/dict.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/dialog_item.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/popup.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/minus.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/block.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/event.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/create.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/or.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/operator.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/progn.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/connection.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/window.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/error.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/tab_stack.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/vmi.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/constant.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/int_item.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/arc.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/text_buffer.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/frame.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/cursor.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/divide.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/class.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/greater.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/font.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/host.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/fragment.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/menu_bar.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/object.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/var.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/parbox.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/method.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/spatial.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/chain_table.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/binding.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/times.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/source_sink.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/window_decorator.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/table_slice.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/hbox.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/menu.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/link.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/type.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/node.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/colour_map.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/display_manager.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/application.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/directory.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/area.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/resize_gesture.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/real.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/menu_item.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/table_row.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/monitor.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/tokeniser.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/move_outline_gesture.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/handler.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/reference/class/behaviour.doc",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/course/figs/hello.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/course/figs/ftp.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/xpce/man/course/figs/control.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/pengines/pltpsynch.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/pengines/penarch.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/pengines/pltpruncolour.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/pengines/examples/web/queen.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/jpl/web/jpl.war",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/jpl/docs/images/screendump.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/jpl/docs/files/libjpl.dylib",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/http/web/icons/generic.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/http/web/icons/folder.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/http/web/icons/compressed.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/http/web/icons/back.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/http/web/icons/openid-logo-square.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/http/web/icons/layout.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/http/web/icons/c.png",
        "/tmp/vanessa/spack-stage/spack-stage-swipl-8.2.0-rd2n665cv2xx2aldz6jzivijt34uenih/spack-src/packages/http/web/icons/openid-logo-tiny.png"
    ],
    "total_files": 4437
}