{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-6oyen5r2v7u3o6slkiermq47zyfmu5sx/spack-src/preload/pip_preload.c": "/*\n * $PIP_license: <Simplified BSD License>\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * \n *     Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n * \n *     Redistributions in binary form must reproduce the above copyright notice,\n *     this list of conditions and the following disclaimer in the documentation\n *     and/or other materials provided with the distribution.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n * $\n * $RIKEN_copyright: Riken Center for Computational Sceience (R-CCS),\n * System Software Development Team, 2016-2021\n * $\n * $PIP_VERSION: Version 3.0.0$\n *\n * $Author: Atsushi Hori (R-CCS)\n * Query:   procinproc-info@googlegroups.com\n * User ML: procinproc-users@googlegroups.com\n * $\n */\n\n#include <pip/pip_internal.h>\n#include <pip/pip_clone.h>\n\n#include <sys/syscall.h>\n#include <dlfcn.h>\n\n//#define DEBUG\n\npip_clone_t pip_clone_info = { 0 }; /* refered by piplib */\n\nstatic clone_syscall_t pip_clone_orig;\n\nstatic pid_t pip_gettid_preloaded( void ) {\n  return (pid_t) syscall( (long int) SYS_gettid );\n}\n\nstatic clone_syscall_t pip_get_clone( void ) {\n  if( pip_clone_orig == NULL ) {\n    pip_clone_orig = (clone_syscall_t) dlsym( RTLD_NEXT, \"__clone\" );\n  }\n  return pip_clone_orig;\n}\n\nint __clone( int(*fn)(void*), void *child_stack, int flags, void *args, ... ) {\n  pid_t\t\t tid = pip_gettid_preloaded();\n  pip_spinlock_t oldval;\n  int \t\t retval = -1;\n\n  oldval = pip_clone_lock( tid, &pip_clone_info.lock );\n  do {\n    va_list ap;\n    va_start( ap, args );\n    pid_t *ptid = va_arg( ap, pid_t*);\n    void  *tls  = va_arg( ap, void*);\n    pid_t *ctid = va_arg( ap, pid_t*);\n\n    if( pip_clone_orig == NULL ) {\n      if( ( pip_clone_orig = pip_get_clone() ) == NULL ) {\n\terrno = ENOSYS;\n\tgoto error;\n      }\n    }\n    if( oldval == tid ) {\n      flags = pip_clone_flags( flags );\n    }\n    errno = 0;\n    retval = pip_clone_orig( fn, child_stack, flags, args, ptid, tls, ctid );\n    va_end( ap );\n  } while( 0 );\n error:\n  pip_clone_unlock( &pip_clone_info.lock );\n  return retval;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-6oyen5r2v7u3o6slkiermq47zyfmu5sx/spack-src/PiP-Testsuite/PiP-Testsuite/compat/pip_dlopen.c": "/*\n * $PIP_license: <Simplified BSD License>\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n *\n *     Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n *\n *     Redistributions in binary form must reproduce the above copyright notice,\n *     this list of conditions and the following disclaimer in the documentation\n *     and/or other materials provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n * $\n * $RIKEN_copyright: Riken Center for Computational Sceience (R-CCS),\n * System Software Development Team, 2016-2020\n * $\n * $PIP_TESTSUITE: Version 1.0.0$\n *\n * $Author: Atsushi Hori (R-CCS) mailto: ahori@riken.jp or ahori@me.com\n * $\n */\n\n#include <libgen.h>\n#include <limits.h>\n#include <test.h>\n\n#define LIBNAME \t\"./libnull.so\"\n\nvoid *pip_dlopen( const char*, int );\nvoid *pip_dlsym( void*, const char* );\nint   pip_dlclose( void* );\n\nint main( int argc, char **argv ) {\n  void *handle;\n  int(*foo)(void);\n\n  CHECK( pip_init(NULL,NULL,NULL,0), RV, return(EXIT_FAIL) );\n  CHECK( handle = pip_dlopen( LIBNAME, RTLD_LAZY ),\n\t handle==NULL,\n\t return(EXIT_FAIL) );\n  CHECK( ( foo = pip_dlsym( handle, \"foo\" ) ), foo==0, return(EXIT_FAIL) );\n  CHECK( foo(),                                    RV, return(EXIT_FAIL) );\n  //CHECK( pip_dlclose( handle ),                    RV, return(EXIT_FAIL) );\n  return 0;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-6oyen5r2v7u3o6slkiermq47zyfmu5sx/spack-src/lib/pip_clone.c": "/*\n * $PIP_license: <Simplified BSD License>\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * \n *     Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n * \n *     Redistributions in binary form must reproduce the above copyright notice,\n *     this list of conditions and the following disclaimer in the documentation\n *     and/or other materials provided with the distribution.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n * $\n * $RIKEN_copyright: Riken Center for Computational Sceience (R-CCS),\n * System Software Development Team, 2016-2021\n * $\n * $PIP_VERSION: Version 3.0.0$\n *\n * $Author: Atsushi Hori (R-CCS)\n * Query:   procinproc-info@googlegroups.com\n * User ML: procinproc-users@googlegroups.com\n * $\n */\n\n#include <pip/pip_internal.h>\n#include <pip/pip_dlfcn.h>\n\npip_clone_syscall_t\tpip_clone_orig;\npip_spinlock_t \t\tpip_lock_got_clone PIP_PRIVATE;\n\nstatic pip_spinlock_t pip_lock_clone( pid_t tid ) {\n  pip_spinlock_t oldval;\n\n  while( 1 ) {\n    oldval = pip_spin_trylock_wv( &pip_lock_got_clone, PIP_LOCK_OTHERWISE );\n    if( oldval == tid ) {\n      /* called and locked by PiP lib */\n      break;\n    }\n    if( oldval == PIP_LOCK_UNLOCKED ) { /* lock succeeds */\n      /* not called by PiP lib */\n      break;\n    }\n  }\n  return oldval;\n}\n\nstatic int\npip_clone( int(*fn)(void*), void *child_stack, int flags, void *args, ... ) {\n  pid_t\t\t tid = pip_gettid();\n  pip_spinlock_t oldval;\n  int \t\t retval = -1;\n\n  ENTER;\n  oldval = pip_lock_clone( tid );\n  do {\n    va_list ap;\n    va_start( ap, args );\n    pid_t *ptid = va_arg( ap, pid_t* );\n    void  *tls  = va_arg( ap, void*  );\n    pid_t *ctid = va_arg( ap, pid_t* );\n\n    if( oldval == tid ) {\n      flags = pip_clone_flags( flags );\n    }\n    retval = pip_clone_orig( fn, child_stack, flags, args, ptid, tls, ctid );\n    va_end( ap );\n  } while( 0 );\n  pip_spin_unlock( &pip_lock_got_clone );\n  RETURN_NE( retval );\n}\n\nint pip_wrap_clone( void ) {\n  int pip_patch_GOT( char*, char*, void* );\n\n  ENTER;\n  pip_clone_orig = pip_dlsym( RTLD_DEFAULT, \"__clone\" );\n  if( pip_clone_orig == NULL ) RETURN( ENOSYS );\n  RETURN( !pip_patch_GOT( \"libpthread.so\", \"__clone\", pip_clone ) );\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-6oyen5r2v7u3o6slkiermq47zyfmu5sx/spack-src/lib/pip_spawn.c": "/*\n * $PIP_license: <Simplified BSD License>\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * \n *     Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n * \n *     Redistributions in binary form must reproduce the above copyright notice,\n *     this list of conditions and the following disclaimer in the documentation\n *     and/or other materials provided with the distribution.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n * $\n * $RIKEN_copyright: Riken Center for Computational Sceience (R-CCS),\n * System Software Development Team, 2016-2021\n * $\n * $PIP_VERSION: Version 3.0.0$\n *\n * $Author: Atsushi Hori (R-CCS)\n * Query:   procinproc-info@googlegroups.com\n * User ML: procinproc-users@googlegroups.com\n * $\n */\n\n#define _GNU_SOURCE\n\n//#define PIP_NO_MALLOPT\n//#define PRINT_MAPS\n//#define PRINT_FDS\n\n/* the EVAL define symbol is to measure the time for calling dlmopen() */\n//#define EVAL\n\n#include <pip/pip_internal.h>\n#include <pip/pip_dlfcn.h>\n#include <pip/pip_gdbif_func.h>\n\n#include <time.h>\n#include <malloc.h> \t\t/* needed for mallopt(M_MMAP_THRESHOLD) */\n\npip_spinlock_t *pip_lock_clone PIP_PRIVATE;\n\nint pip_count_vec( char **vecsrc ) {\n  int n = 0;\n  if( vecsrc != NULL ) {\n    for( ; vecsrc[n]!= NULL; n++ );\n  }\n  return( n );\n}\n\nstatic int pip_copy_vec( char **vecadd,\n\t\t\t char **vecsrc,\t\t   /* input */\n\t\t\t pip_char_vec_t *cvecp ) { /* output */\n  char \t\t**vecdst, *p, *strs;\n  size_t\tveccc, sz;\n  int \t\tvecln, i, j;\n\n  vecln = 0;\n  veccc = 0;\n  if( vecadd != NULL ) {\n    for( i=0; vecadd[i]!=NULL; i++ ) {\n      vecln ++;\n      veccc += strlen( vecadd[i] ) + 1;\n    }\n  }\n  for( i=0; vecsrc[i]!=NULL; i++ ) {\n    vecln ++;\n    veccc += strlen( vecsrc[i] ) + 1;\n  }\n  vecln ++;\t\t/* plus final NULL */\n\n  sz = sizeof(char*) * vecln;\n  if( ( vecdst = (char**) PIP_MALLOC( sz    ) ) == NULL ) {\n    return ENOMEM;\n  }\n  if( ( strs   = (char*)  PIP_MALLOC( veccc ) ) == NULL ) {\n    PIP_FREE( vecdst );\n    return ENOMEM;\n  }\n  p = strs;\n  j = 0;\n  if( vecadd != NULL ) {\n    for( i=0; vecadd[i]!=NULL; i++ ) {\n      vecdst[j++] = p;\n      p = stpcpy( p, vecadd[i] ) + 1;\n      ASSERTD( j      > vecln );\n      ASSERTD( p-strs > veccc );\n    }\n  }\n  for( i=0; vecsrc[i]!=NULL; i++ ) {\n    vecdst[j++] = p;\n    p = stpcpy( p, vecsrc[i] ) + 1;\n    ASSERTD( j      > vecln );\n    ASSERTD( p-strs > veccc );\n  }\n  vecdst[j] = NULL;\n  cvecp->vec  = vecdst;\n  cvecp->strs = strs;\n  return 0;\n}\n\n#define ENVLEN\t(64)\nstatic int pip_copy_env( char **envsrc, int pipid,\n\t\t\t pip_char_vec_t *vecp ) {\n  char rootenv[ENVLEN], taskenv[ENVLEN];\n  char *preload_env = getenv( \"LD_PRELOAD\" );\n  char *addenv[4] = { rootenv, taskenv, preload_env, NULL };\n\n  ASSERTS( snprintf( rootenv, ENVLEN, \"%s=%p\", PIP_ROOT_ENV, pip_root ) <= 0 );\n  ASSERTS( snprintf( taskenv, ENVLEN, \"%s=%d\", PIP_TASK_ENV, pipid    ) <= 0 );\n  return pip_copy_vec( addenv, envsrc, vecp );\n}\n\nsize_t pip_stack_size( void ) {\n  char \t\t*env, *endptr;\n  ssize_t \ts, sz, scale, smax;\n  struct rlimit rlimit;\n\n  if( ( sz = pip_root->stack_size_blt ) == 0 ) {\n    if( ( env = getenv( PIP_ENV_STACKSZ ) ) == NULL &&\n\t( env = getenv( \"KMP_STACKSIZE\" ) ) == NULL &&\n\t( env = getenv( \"OMP_STACKSIZE\" ) ) == NULL ) {\n      sz = PIP_STACK_SIZE;\t/* default */\n    } else {\n      if( ( sz = (ssize_t) strtoll( env, &endptr, 10 ) ) <= 0 ) {\n\tpip_err_mesg( \"stacksize: '%s' is illegal and \"\n\t\t      \"default size (%lu KiB) is set\",\n\t\t      env,\n\t\t      PIP_STACK_SIZE / 1024 );\n\tsz = PIP_STACK_SIZE;\t/* default */\n      } else {\n\tif( getrlimit( RLIMIT_STACK, &rlimit ) != 0 ) {\n\t  smax = PIP_STACK_SIZE_MAX;\n\t} else {\n\t  smax = rlimit.rlim_cur;\n\t}\n\tscale = 1;\n\tswitch( *endptr ) {\n\tcase 'T': case 't':\n\t  scale *= 1024;\n\t  /* fall through */\n\tcase 'G': case 'g':\n\t  scale *= 1024;\n\t  /* fall through */\n\tcase 'M': case 'm':\n\t  scale *= 1024;\n\t  /* fall through */\n\tcase 'K': case 'k':\n\tcase '\\0':\t\t/* default is KiB */\n\t  scale *= 1024;\n\t  sz *= scale;\n\t  break;\n\tcase 'B': case 'b':\n\t  for( s=PIP_STACK_SIZE_MIN; s<sz && s<smax; s*=2 );\n\t  break;\n\tdefault:\n\t  sz = PIP_STACK_SIZE;\n\t  pip_err_mesg( \"stacksize: '%s' is illegal and \"\n\t\t\t\"default size (%ldB) is used instead\",\n\t\t\tenv, sz );\n\t  break;\n\t}\n\tsz = ( sz < PIP_STACK_SIZE_MIN ) ? PIP_STACK_SIZE_MIN : sz;\n\tsz = ( sz > smax               ) ? smax               : sz;\n      }\n    }\n    pip_root->stack_size_blt = sz;\n  }\n  return sz;\n}\n\nint pip_isa_coefd( int fd ) {\n  int flags = fcntl( fd, F_GETFD );\n  return( ( flags > 0 ) && ( flags & FD_CLOEXEC ) );\n}\n\n#define PROCFD_PATH\t\t\"/proc/self/fd\"\nstatic int pip_list_coe_fds( int *fd_listp[] ) {\n  DIR *dir;\n  struct dirent *direntp;\n  int *fdlist;\n  int i, fd, err = 0;\n\n  ENTER;\n  if( ( dir = opendir( PROCFD_PATH ) ) == NULL ) {\n    err = errno;\n  } else {\n    int fd_dir = dirfd( dir );\n    int nfds = 0;\n\n    while( ( direntp = readdir( dir ) ) != NULL ) {\n      if( direntp->d_name[0] != '.'                         &&\n\t  ( fd = strtol( direntp->d_name, NULL, 10 ) ) >= 0 &&\n\t  errno == 0\t\t\t\t\t    &&\n\t  fd != fd_dir                                      &&\n\t  pip_isa_coefd( fd ) ) {\n\tnfds ++;\n      }\n    }\n    if( nfds > 0 ) {\n      fdlist = (int*) PIP_MALLOC( sizeof(int) * ( nfds + 1 ) );\n      if( fdlist == NULL ) {\n\terr = ENOMEM;\n      } else {\n\trewinddir( dir );\n\ti = 0;\n\twhile( ( direntp = readdir( dir ) ) != NULL ) {\n\t  errno = 0;\n\t  if( direntp->d_name[0] != '.'             \t\t&&\n\t      ( fd = strtol( direntp->d_name, NULL, 10 ) ) >= 0\t&&\n\t      errno == 0\t\t\t\t\t&&\n\t      fd != fd_dir                         \t\t&&\n\t      pip_isa_coefd( fd ) ) {\n\t    fdlist[i++] = fd;\n\t  }\n\t}\n\tfdlist[i] = -1;\n\t*fd_listp = fdlist;\n      }\n    }\n    (void) closedir( dir );\n    (void) close( fd_dir );\n  }\n  RETURN( err );\n}\n\nstatic int pip_find_user_symbols( pip_spawn_program_t *progp,\n\t\t\t\t  void *handle,\n\t\t\t\t  pip_task_internal_t *taski ) {\n  pip_symbols_t *symp = &MA(taski)->symbols;\n  int err = 0;\n\n  pip_glibc_lock();\t\t/* to protect dlsym */\n  {\n    if( progp->funcname == NULL ) {\n      symp->main           = dlsym( handle, \"main\"                  );\n    } else {\n      symp->start          = dlsym( handle, progp->funcname         );\n    }\n  }\n  pip_glibc_unlock();\n\n  DBGF( \"func(%s):%p  main:%p\", progp->funcname, symp->start, symp->main );\n\n  /* check start function */\n  if( progp->funcname == NULL ) {\n    if( symp->main == NULL ) {\n      pip_err_mesg( \"Unable to find main \"\n\t\t    \"(possibly not linked with '-rdynamic' option)\" );\n      err = ENOEXEC;\n    }\n  } else if( symp->start == NULL ) {\n    pip_err_mesg( \"Unable to find start function (%s)\",\n\t\t  progp->funcname );\n    err = ENOEXEC;\n  }\n  RETURN( err );\n}\n\n\n#ifdef RTLD_DEEPBIND\n#define DLMOPEN_FLAGS\t  (RTLD_NOW | RTLD_DEEPBIND)\n#else\n#define DLMOPEN_FLAGS\t  (RTLD_NOW)\n#endif\n\nstatic int pip_load_glibc( pip_task_internal_t *taski, Lmid_t lmid ) {\n  pip_symbols_t *symp = &MA(taski)->symbols;\n  void\t*handle;\n  int \terr = 0;\n\n  pip_glibc_lock();\t\t/* to protect dlsym */\n  {\n    if( ( handle = dlmopen( lmid, PIP_INSTALL_GLIBC, DLMOPEN_FLAGS ) ) == NULL ) {\n      pip_glibc_unlock();\n      DBGF( \"dlmopen: %s\", dlerror() );\n      err = ENXIO;\n      RETURN( err );\n    }\n    /* the GLIBC _init() seems not callable. It seems that */\n    /* dlmopen()ed name space does not setup VDSO properly */\n    //symp->libc_init        = dlsym( handle, \"_init\"           );\n    //symp->res_init         = dlsym( handle, \"__res_init\"      );\n    symp->ctype_init       = dlsym( handle, \"__ctype_init\"    );\n    symp->mallopt          = dlsym( handle, \"mallopt\"         );\n    symp->libc_fflush      = dlsym( handle, \"fflush\"          );\n    symp->malloc_hook      = dlsym( handle, \"__malloc_hook\"   );\n    symp->exit\t           = dlsym( handle, \"exit\"            );\n    symp->pthread_exit     = dlsym( handle, \"pthread_exit\"    );\n    if( symp->libc_init == NULL ) {\n      /* GLIBC variables */\n      symp->libc_argcp     = dlsym( handle, \"__libc_argc\"     );\n      symp->libc_argvp     = dlsym( handle, \"__libc_argv\"     );\n      symp->environ        = dlsym( handle, \"environ\"         );\n      /* GLIBC misc. variables */\n      symp->prog           = dlsym( handle, \"__progname\"      );\n      symp->prog_full      = dlsym( handle, \"__progname_full\" );\n    }\n  }\n  pip_glibc_unlock();\n\n  /* check mandatory symbols */\n  if( symp->libc_init == NULL && symp->environ == NULL ) {\n    err = ENOEXEC;\n  }\n  if( err ) pip_dlclose( handle );\n  RETURN( err );\n}\n\nstatic char *pip_find_newer_libpipinit( void ) {\n  struct stat\tstb_install, stb_build;\n  char\t\t*newer = NULL;\n\n  DBGF( \"%s\", PIP_INSTALL_LIBPIPINIT );\n  DBGF( \"%s\", PIP_BUILD_LIBPIPINIT );\n  memset( &stb_install, 0, sizeof(struct stat) );\n  memset( &stb_build,   0, sizeof(struct stat) );\n  if( stat( PIP_INSTALL_LIBPIPINIT, &stb_install ) != 0 ) {\n    /* not found in install dir */\n    if( stat( PIP_BUILD_LIBPIPINIT, &stb_build   ) != 0 ) {\n      /* nowhere */\n      return NULL;\n    }\n    newer = PIP_BUILD_LIBPIPINIT;\n  } else if( stat( PIP_BUILD_LIBPIPINIT, &stb_build ) != 0 ) {\n    /* not found in build dir, but install dir */\n    newer = PIP_INSTALL_LIBPIPINIT;\n  } else {\n    /* both found, take the newer one */\n    if( stb_install.st_mtime > stb_build.st_mtime ) {\n      newer = PIP_INSTALL_LIBPIPINIT;\n    } else {\n      newer = PIP_BUILD_LIBPIPINIT;\n    }\n  }\n  return newer;\n}\n\nvoid pip_load_libpip( pip_task_internal_t *taski, Lmid_t lmid ) {\n  void\t\t*loaded = MA(taski)->loaded;\n  void\t\t*ld_pipinit = NULL;\n  char\t\t*libpipinit = NULL;\n  pip_init_t\timpinit     = NULL;\n\n  /* call pip_init_task_implicitly */\n  /*** we cannot call pip_ini_task_implicitly() directly here  ***/\n  /*** the name space contexts of here and there are different ***/\n  impinit = (pip_init_t) pip_dlsym( loaded, \"pip_init_task_implicitly\" );\n  if( impinit == NULL ) {\n    DBGF( \"dlsym: %s\", pip_dlerror() );\n    if( ( libpipinit = pip_find_newer_libpipinit() ) != NULL ) {\n      DBGF( \"libpipinit: %s\", libpipinit );\n      if( ( ld_pipinit = pip_dlmopen( lmid, libpipinit, DLMOPEN_FLAGS ) ) == NULL ) {\n\tpip_warn_mesg( \"Unable to load %s: %s\", libpipinit, pip_dlerror() );\n      } else {\n\timpinit = (pip_init_t) pip_dlsym( ld_pipinit, \"pip_init_task_implicitly\" );\n\tDBGF( \"dlsym: %s\", pip_dlerror() );\n      }\n    }\n  }\n  MA(taski)->symbols.pip_init = impinit;\n  MA(taski)->symbols.named_export_fin =\n    pip_dlsym( loaded, \"pip_named_export_fin\" );\n}\n\nstatic int\npip_load_dsos( pip_spawn_program_t *progp, pip_task_internal_t *taski ) {\n  const char \t*prog = progp->prog;\n  Lmid_t\tlmid = LM_ID_NEWLM;\n  void \t\t*loaded = NULL;\n  int\t\terr = 0;\n\n  ENTERF( \"prog: %s\", prog );\n  if( ( loaded = pip_dlmopen( lmid, prog, DLMOPEN_FLAGS ) ) == NULL ) {\n    char *dle = pip_dlerror();\n    if( ( err = pip_check_pie( prog, 1 ) ) != 0 ) goto error;\n    pip_err_mesg( \"dlmopen(%s): %s\", prog, dle );\n    err = ENOEXEC;\n    goto error;\n  }\n  if( ( err = pip_find_user_symbols( progp, loaded, taski ) ) ) {\n    goto error;\n  }\n  if( pip_dlinfo( loaded, RTLD_DI_LMID, &lmid ) != 0 ) {\n    pip_err_mesg( \"Unable to obtain Lmid - %s\", pip_dlerror() );\n    err = ENXIO;\n    goto error;\n  }\n  MA(taski)->loaded = loaded;\n\n  DBGF( \"lmid: %d\", (int) lmid );\n  /* load libc explicitly */\n  if( ( err = pip_load_glibc( taski, lmid ) ) ) {\n    goto error;\n  }\n  pip_load_libpip( taski, lmid );\n  RETURN( 0 );\n\n error:\n  if( loaded != NULL ) pip_dlclose( loaded );\n  RETURN( err );\n}\n\nstatic int pip_load_prog( pip_spawn_program_t *progp,\n\t\t\t  pip_spawn_args_t *args,\n\t\t\t  pip_task_internal_t *taski ) {\n  int \terr;\n\n  ENTERF( \"prog: %s\", progp->prog );\n\n  PIP_ACCUM( time_load_dso,\n\t     ( err = pip_load_dsos( progp, taski ) ) == 0 );\n  if( err == 0 ) pip_gdbif_load( taski );\n  RETURN( err );\n}\n\nint pip_do_corebind( pid_t tid, uint32_t coreno, cpu_set_t *oldsetp ) {\n  cpu_set_t cpuset;\n  int flags  = coreno & PIP_CPUCORE_FLAG_MASK;\n  int i, err = 0;\n\n  ENTER;\n  /* PIP_CPUCORE_* flags are exclusive */\n  if( ( flags & PIP_CPUCORE_ASIS ) != flags &&\n      ( flags & PIP_CPUCORE_ABS  ) != flags ) RETURN( EINVAL );\n  if( flags & PIP_CPUCORE_ASIS ) RETURN( 0 );\n  coreno &= PIP_CPUCORE_CORENO_MASK;\n  if( coreno >= PIP_CPUCORE_CORENO_MAX ) RETURN( EINVAL );\n  if( tid == 0 ) tid = pip_gettid();\n\n  if( oldsetp != NULL ) {\n    if( sched_getaffinity( tid, sizeof(cpuset), oldsetp ) != 0 ) {\n      RETURN( errno );\n    }\n  }\n\n  if( flags == 0 ) {\n    int ncores, nth;\n\n    if( sched_getaffinity( tid, sizeof(cpuset), &cpuset ) != 0 ) {\n      RETURN( errno );\n    }\n    if( ( ncores = CPU_COUNT( &cpuset ) ) ==  0 ) RETURN( 0 );\n    coreno %= ncores;\n    nth = coreno;\n    for( i=0; ; i++ ) {\n      if( !CPU_ISSET( i, &cpuset ) ) continue;\n      if( nth-- == 0 ) {\n\tCPU_ZERO( &cpuset );\n\tCPU_SET( i, &cpuset );\n\tif( sched_setaffinity( tid, sizeof(cpuset), &cpuset ) != 0 ) {\n\t  err = errno;\n\t}\n\tbreak;\n      }\n    }\n  } else if( ( flags & PIP_CPUCORE_ABS ) == PIP_CPUCORE_ABS ) {\n    CPU_ZERO( &cpuset );\n    CPU_SET( coreno, &cpuset );\n    /* here, do not call pthread_setaffinity(). This MAY fail */\n    /* because pd->tid is NOT set yet.  I do not know why.    */\n    /* But it is OK to call sched_setaffinity() with tid.     */\n    if( sched_setaffinity( tid, sizeof(cpuset), &cpuset ) != 0 ) {\n      RETURN( errno );\n    }\n  }\n  RETURN( err );\n}\n\nstatic int pip_undo_corebind( pid_t tid, uint32_t coreno, cpu_set_t *oldsetp ) {\n  int flags = coreno >> PIP_CPUCORE_FLAG_SHIFT;\n  int err = 0;\n\n  ENTER;\n  if( flags != PIP_CPUCORE_ASIS ) {\n    if( tid == 0 ) tid = pip_gettid();\n    /* here, do not call pthread_setaffinity().  See above comment. */\n    if( sched_setaffinity( tid, sizeof(cpu_set_t), oldsetp ) != 0 ) {\n      err = errno;\n    }\n  }\n  RETURN( err );\n}\n\nint pip_get_dso( int pipid, void **loaded ) {\n  pip_task_internal_t *task;\n  int err;\n\n  if( ( err = pip_check_pipid( &pipid ) ) != 0 ) RETURN( err );\n  task = pip_get_task( pipid );\n  if( loaded != NULL ) *loaded = MA(task)->loaded;\n  RETURN( 0 );\n}\n\nstatic void pip_glibc_init( pip_symbols_t *symbols,\n\t\t\t    pip_spawn_args_t *args ) {\n  /* setting GLIBC variables */\n  if( symbols->libc_init != NULL ) {\n    DBGF( \">> _init@%p\", symbols->libc_init );\n    symbols->libc_init( args->argc,\n\t\t\targs->argvec.vec,\n\t\t\targs->envvec.vec );\n    DBGF( \"<< _init@%p\", symbols->libc_init );\n  } else {\n    if( symbols->libc_argcp != NULL ) {\n      DBGF( \"&__libc_argc=%p\", symbols->libc_argcp );\n      *symbols->libc_argcp = args->argc;\n    }\n    if( symbols->libc_argvp != NULL ) {\n      DBGF( \"&__libc_argv=%p\", symbols->libc_argvp );\n      *symbols->libc_argvp = args->argvec.vec;\n    }\n    if( symbols->prog_full != NULL ) {\n      *symbols->prog_full = args->prog_full;\n    }\n    if( symbols->environ != NULL ) {\n      *symbols->environ = args->envvec.vec;\t/* setting environment vars */\n    }\n    if( symbols->prog != NULL ) {\n      *symbols->prog = args->prog;\n    }\n    if( symbols->ctype_init != NULL ) {\n      DBGF( \">> __ctype_init@%p\", symbols->ctype_init );\n      symbols->ctype_init();\n      DBGF( \"<< __ctype_init@%p\", symbols->ctype_init );\n    }\n  }\n\n#ifndef PIP_NO_MALLOPT\n  /* heap (using brk or sbrk) is not safe in PiP */\n  if( symbols->mallopt != NULL ) {\n#ifdef M_MMAP_THRESHOLD\n    if( symbols->mallopt( M_MMAP_THRESHOLD, 1 ) == 1 ) {\n      DBGF( \"mallopt(M_MMAP_THRESHOLD): succeeded\" );\n    } else {\n      pip_warn_mesg( \"mallopt(M_MMAP_THRESHOLD): failed !!!!!!\" );\n    }\n#endif\n  }\n#endif\n  if( symbols->malloc_hook != 0x0 ) { /* Kaiming Patch */\n    *symbols->malloc_hook = 0x0;\n  }\n}\n\nextern char **environ;\n\nstatic int pip_call_before_hook( pip_task_internal_t *taski ) {\n  int err = 0;\n\n  if( MA(taski)->hook_before != NULL ) {\n    char **env_save = environ;\n    environ = MA(taski)->args.envvec.vec;\n    err = MA(taski)->hook_before( MA(taski)->hook_arg );\n    MA(taski)->args.envvec.vec = environ;\n    environ = env_save;\n    if( err ) {\n      pip_err_mesg( \"PIPID:%d before-hook returns %d\", TA(taski)->pipid, err );\n    }\n  }\n  return err;\n}\n\nint pip_call_after_hook( pip_task_internal_t *taski, int extval ) {\n  int err = 0;\n  if( MA(taski)->hook_after != NULL ) {\n    char **env_save = environ;\n    environ = MA(taski)->args.envvec.vec;\n    err = MA(taski)->hook_after( MA(taski)->hook_arg );\n    MA(taski)->args.envvec.vec = environ;\n    environ = env_save;\n    if( err ) {\n      pip_err_mesg( \"PIPID:%d after-hook returns %d\", TA(taski)->pipid, err );\n      if( extval == 0 ) extval = err;\n    }\n  }\n  return extval;\n}\n\nstatic void pip_set_extval( pip_task_internal_t *taski, int extval ) {\n  pip_task_annex_t\t*annex = AA(taski);\n  ENTER;\n  if( !annex->flag_exit ) {\n    annex->flag_exit = PIP_EXITED;\n    DBGF( \"PIPID:%d/%d extval:%d\",\n\t  TA(taski)->pipid, TA(TA(taski)->task_sched)->pipid, extval );\n    if( annex->status == 0 ) {\n      annex->status = PIP_W_EXITCODE( extval, 0 );\n    }\n    pip_gdbif_exit( taski, extval );\n    pip_memory_barrier();\n    pip_gdbif_hook_after( taski );\n  }\n  DBGF( \"extval: 0x%x(0x%x)\", extval, annex->status );\n  RETURNV;\n}\n\nstatic int pip_unknown_tid( void ) {\n  pip_task_internal_t *taski;\n  pid_t tid = pip_gettid();\n  int   id;\n\n  for( id=0; id<pip_root->ntasks; id++ ) {\n    taski = &pip_root->tasks[id];\n    if( tid == AA(taski)->tid ) return 0;\n  }\n  return 1;\n}\n\nstatic void pip_return_from_start_func( pip_task_internal_t *taski,\n\t\t\t\t\tint extval ) {\n  if( pip_unknown_tid() ) {\n    /* when a PiP task fork()s and returns */\n    /* from main this case happens         */\n    DBGF( \"return from a fork()ed process?\" );\n    /* here we have to call the exit() in the same context */\n    if( MA(taski)->symbols.exit != NULL ) {\n      MA(taski)->symbols.exit( WEXITSTATUS(AA(taski)->status) );\n    } else {\n      exit( WEXITSTATUS(AA(taski)->status) );\n    }\n  } else {\n    extval = pip_call_after_hook( taski, extval );\n    pip_set_extval( taski, extval );\n    pip_do_exit( taski );\n  }\n  NEVER_REACH_HERE;\n}\n\nvoid pip_exit( int extval ) {\n  DBGF( \"extval:%d\", extval );\n  if( !pip_is_initialized() ) {\n    exit( extval );\n  } else if( pip_isa_root() ) {\n    exit( extval );\n  } else {\n    pip_return_from_start_func( pip_task, extval );\n  }\n  NEVER_REACH_HERE;\n}\n\nstatic void pip_reset_signal_handler( int sig ) {\n  if( !pip_is_threaded_() ) {\n    struct sigaction\tsigact;\n    memset( &sigact, 0, sizeof( sigact ) );\n    sigact.sa_sigaction = (void(*)(int,siginfo_t*,void*)) SIG_DFL;\n    ASSERTS( sigaction( sig, &sigact, NULL ) != 0 );\n  } else {\n    sigset_t sigmask;\n    (void) sigemptyset( &sigmask );\n    (void) sigaddset( &sigmask, sig );\n    ASSERTS( pthread_sigmask( SIG_BLOCK, &sigmask, NULL ) != 0 );\n  }\n}\n\nstatic void pip_start_cb( void *tsk ) {\n  pip_task_internal_t *taski = (pip_task_internal_t*) tsk;\n  pip_glibc_unlock();\n  /* let pip-gdb know */\n  pip_gdbif_task_commit( taski );\n  /* let root proc know the task is running (or enqueued) */\n  pip_sem_post( &AA(taski)->task_root->sync_spawn );\n}\n\nstatic void pip_start_user_func( pip_spawn_args_t *args,\n\t\t\t\t pip_task_internal_t *self ) {\n  pip_task_queue_t *queue = args->queue;\n  char **argv     = args->argvec.vec;\n  char **envv     = args->envvec.vec;\n  void *start_arg = args->start_arg;\n  char *env_stop;\n  int\textval, i, err = 0;\n\n  ENTER;\n  DBGF( \"fd_list:%p\", args->fd_list );\n  if( args->fd_list != NULL ) {\n    for( i=0; args->fd_list[i]>=0; i++ ) { /* Close-on-exec FDs */\n      DBGF( \"COE: %d\", args->fd_list[i] );\n      (void) close( args->fd_list[i] );\n    }\n  }\n  pip_glibc_init( &MA(self)->symbols, args );\n  pip_gdbif_hook_before( self );\n\n  DBGF( \"pip_impinit:%p\", MA(self)->symbols.pip_init );\n  if( MA(self)->symbols.pip_init != NULL ) {\n    int rv = MA(self)->symbols.pip_init( AA(self)->task_root, self );\n    if( rv ) {\n      err = EPERM;\n      switch( rv ) {\n      case 1:\n\tpip_err_mesg( \"Invalid PiP root\" );\n\tbreak;\n      case 2:\n\tpip_err_mesg( \"Magic number error\" );\n\tbreak;\n      case 3:\n\tpip_err_mesg( \"Version miss-match between PiP root and task\" );\n\tbreak;\n      case 4:\n\tpip_err_mesg( \"Size miss-match between PiP root and task\" );\n\tbreak;\n      default:\n\tpip_err_mesg( \"Something wrong with PiP root and task\" );\n\tbreak;\n      }\n    }\n  }\n  if( err ) {\n    extval = err;\n  } else {\n    err = pip_call_before_hook( self );\n    if( !err ) {\n      if( AA(self)->opts & PIP_TASK_INACTIVE ) {\n\tDBGF( \"INACTIVE\" );\n\tpip_suspend_and_enqueue_generic( self,\n\t\t\t\t\t queue,\n\t\t\t\t\t 1, /* lock flag */\n\t\t\t\t\t pip_start_cb,\n\t\t\t\t\t self );\n\t/* resumed */\n      } else {\n\tDBGF( \"ACTIVE\" );\n\tif( queue != NULL ) {\n\t  int n = PIP_TASK_ALL;\n\t  err = pip_dequeue_and_resume_multiple( queue, self, &n );\n\t}\n\t/* since there is no callback, the cb func is called explicitly */\n\tpip_start_cb( (void*) self );\n      }\n    }\n    if( err ) {\n      extval = err;\n    } else {\n      if( ( env_stop = pip_root->envs.stop_on_start ) != NULL &&\n\t  env_stop[0] != '\\0' ) {\n\tint pipid_stop = strtol( env_stop, NULL, 10 );\n\tif( pipid_stop < 0 || pipid_stop == TA(self)->pipid ) {\n\t  pip_info_mesg( \"PiP task[%d] is SIGSTOPed (%s=%s)\",\n\t\t\t TA(self)->pipid, PIP_ENV_STOP_ON_START, env_stop );\n\t  pip_kill( TA(self)->pipid, SIGSTOP );\n\t} else {\n\t  pip_warn_mesg( \"PiP task[%d] %s=%s: out of range\",\n\t\t\t TA(self)->pipid, PIP_ENV_STOP_ON_START, env_stop );\n\t}\n      }\n      if( MA(self)->symbols.start == NULL ) {\n\t/* calling hook function, if any */\n\tDBGF( \"[%d] >> main@%p(%d,%s,%s,...)\",\n\t      TA(self)->pipid, MA(self)->symbols.main, args->argc, argv[0], argv[1] );\n\textval = MA(self)->symbols.main( args->argc, argv, envv );\n\tDBGF( \"[%d] << main@%p(%d,%s,%s,...) = %d\",\n\t      TA(self)->pipid, MA(self)->symbols.main, args->argc, argv[0], argv[1],\n\t      extval );\n      } else {\n\tDBGF( \"[%d] >> %s:%p(%p)\",\n\t      TA(self)->pipid, args->funcname,\n\t      MA(self)->symbols.start, start_arg );\n\textval = MA(self)->symbols.start( start_arg );\n\tDBGF( \"[%d] << %s:%p(%p) = %d\",\n\t      args->pipid, args->funcname,\n\t      MA(self)->symbols.start, start_arg, extval );\n      }\n    }\n  }\n  pip_return_from_start_func( self, extval );\n  NEVER_REACH_HERE;\n}\n\nstatic void pip_sigquit_handler( int, void(*)(), struct sigaction* )\n  NORETURN;\nstatic void pip_sigquit_handler( int sig,\n\t\t\t\t void(*handler)(),\n\t\t\t\t struct sigaction *oldp ) {\n  ENTER;\n  pthread_exit( NULL );\n  NEVER_REACH_HERE;\n}\n\nstatic void *pip_spawn_top( void *thargs )  {\n  /* The context of this function is of the root task                */\n  /* so the global var; pip_task (and pip_root) are of the root task */\n  /* and do not call malloc() and free() in this contxt !!!!         */\n  pip_spawn_args_t\t*args  = (pip_spawn_args_t*) thargs;\n  int\t \t\tpipid  = args->pipid;\n  int \t\t\tcoreno = args->coreno;\n  pip_task_internal_t \t*self  = &pip_root->tasks[pipid];\n  int\t\t\terr    = 0;\n\n  AA(self)->tid    = pip_gettid();\n  MA(self)->thread = pthread_self();\n  ENTER;\n  pip_set_name( self );\n  pip_save_tls( &TA(self)->tls );\n  pip_memory_barrier();\n\n  if( !pip_is_threaded_() ) {\n    pip_reset_signal_handler( SIGCHLD );\n    pip_reset_signal_handler( SIGTERM );\n    (void) setpgid( 0, (pid_t) AA(pip_root->task_root)->tid );\n  } else {\n    pip_set_signal_handler( SIGQUIT, pip_sigquit_handler, NULL );\n  }\n  if( ( err = pip_do_corebind( 0, coreno, NULL ) ) != 0 ) {\n    pip_warn_mesg( \"failed to bound CPU core:%d (%d)\", coreno, err );\n  }\n  PIP_RUN( self );\n  pip_start_user_func( args, self );\n\n  NEVER_REACH_HERE;\n  return( NULL );\t\t/* dummy */\n}\n\nstatic int pip_find_a_free_task( int *pipidp ) {\n  int pipid = *pipidp;\n  int i, err = 0;\n\n  if( pip_root->ntasks_accum >= PIP_NTASKS_MAX ) RETURN( EOVERFLOW );\n  if( pipid < PIP_PIPID_ANY || pipid >= pip_root->ntasks ) {\n    DBGF( \"pipid=%d\", pipid );\n    RETURN( EINVAL );\n  }\n\n  pip_spin_lock( &pip_root->lock_tasks );\n  /*** begin lock region ***/\n  do {\n    DBGF( \"pipid:%d  ntasks:%d  pipid_curr:%d\",\n\t  pipid, pip_root->ntasks, pip_root->pipid_curr );\n    if( pipid != PIP_PIPID_ANY ) {\n      if( TA(&pip_root->tasks[pipid])->pipid != PIP_PIPID_NULL ) {\n\terr = EAGAIN;\n\tgoto unlock;\n      }\n    } else {\n      for( i=pip_root->pipid_curr; i<pip_root->ntasks; i++ ) {\n\tif( TA(&pip_root->tasks[i])->pipid == PIP_PIPID_NULL ) {\n\t  pipid = i;\n\t  goto found;\n\t}\n      }\n      for( i=0; i<=pip_root->pipid_curr; i++ ) {\n\tif( TA(&pip_root->tasks[i])->pipid == PIP_PIPID_NULL ) {\n\t  pipid = i;\n\t  goto found;\n\t}\n      }\n      err = EAGAIN;\n      goto unlock;\n    }\n  found:\n    TA(&pip_root->tasks[pipid])->pipid = pipid;\t/* mark it as occupied */\n    pip_root->pipid_curr = pipid + 1;\n    *pipidp = pipid;\n\n  } while( 0 );\n unlock:\n  /*** end lock region ***/\n  pip_spin_unlock( &pip_root->lock_tasks );\n\n  RETURN( err );\n}\n\nstatic int pip_check_active_flag( uint32_t flags ) {\n  uint32_t f = flags & PIP_TASK_MASK;\n\n  DBGF( \"flags:0x%x\", flags );\n  if( f ) {\n    if( pip_are_flags_exclusive( f, PIP_TASK_ACTIVE   ) ) goto OK;\n    if( pip_are_flags_exclusive( f, PIP_TASK_INACTIVE ) ) goto OK;\n    return 1;\n  }\n OK:\n  return 0;\n}\n\nstatic int pip_do_task_spawn( pip_spawn_program_t *progp,\n\t\t\t      int pipid,\n\t\t\t      int coreno,\n\t\t\t      uint32_t opts,\n\t\t\t      pip_task_t **bltp,\n\t\t\t      pip_task_queue_t *queue,\n\t\t\t      pip_spawn_hook_t *hookp ) {\n  cpu_set_t \t\tcpuset;\n  pip_spawn_args_t\t*args = NULL;\n  pip_task_internal_t\t*task = NULL;\n  size_t\t\tstack_size;\n  int \t\t\terr = 0;\n\n  ENTER;\n  if( !pip_is_initialized()   ) RETURN( EPERM  );\n  if( !pip_isa_root()         ) RETURN( EPERM  );\n  if( progp           == NULL ) RETURN( EINVAL );\n  if( progp->prog     == NULL ) RETURN( EINVAL );\n\n  if( pip_check_sync_flag(  &opts ) ) RETURN( EINVAL );\n  if( pip_check_active_flag( opts ) ) RETURN( EINVAL );\n\n  /* starting from main */\n  if( progp->funcname == NULL &&\n      ( progp->argv == NULL || progp->argv[0] == NULL ) ) {\n    RETURN( EINVAL );\n  }\n  /* starting from an arbitrary func */\n  if( progp->funcname == NULL && progp->prog == NULL ) {\n    progp->prog = progp->argv[0];\n  }\n  if( pipid == PIP_PIPID_MYSELF ||\n      pipid == PIP_PIPID_NULL ) {\n    RETURN( EINVAL );\n  }\n  if( pipid != PIP_PIPID_ANY ) {\n    if( pipid < 0 || pipid > pip_root->ntasks ) RETURN( EINVAL );\n  }\n  if( ( err = pip_find_a_free_task( &pipid ) ) != 0 ) GOTO_ERROR;\n  task = &pip_root->tasks[pipid];\n  pip_reset_task_struct( task );\n  TA(task)->pipid      = pipid;\t/* mark it as occupied */\n  TA(task)->type       = PIP_TYPE_TASK;\n  TA(task)->task_sched = task;\n  SETCURR( task, task );\n\n  AA(task)->opts          = opts;\n  AA(task)->task_root     = pip_root;\n  AA(task)->aux           = progp->aux;\n  if( progp->exp != NULL ) {\n    AA(task)->import_root = progp->exp;\n  } else {\n    AA(task)->import_root = pip_root->export_root;\n  }\n  if( hookp != NULL ) {\n    MA(task)->hook_before = hookp->before;\n    MA(task)->hook_after  = hookp->after;\n    MA(task)->hook_arg    = hookp->hookarg;\n  }\n  /* allocate stack for sleeping */\n  pip_page_alloc( pip_root->stack_size_trampoline,\n\t\t  &AA(task)->stack_trampoline );\n\n  args = &MA(task)->args;\n  args->pipid     = pipid;\n  args->coreno    = coreno;\n  args->queue     = queue;\n  { \t\t\t\t/* GLIBC/misc/init-misc.c */\n    char *prog = progp->prog;\n    char *p = strrchr( prog, '/' );\n    if( p == NULL ) {\n      args->prog      = prog;\n    } else {\n      args->prog      = p + 1;\n      args->prog_full = prog;\n    }\n    DBGF( \"prog:%s full:%s\", args->prog, args->prog_full );\n  }\n  err = pip_copy_env( progp->envv, pipid, &args->envvec );\n  if( err ) GOTO_ERR( err );\n\n  if( progp->funcname == NULL ) {\n    err = pip_copy_vec( NULL, progp->argv, &args->argvec );\n    if( err ) GOTO_ERR( err );\n    args->argc = pip_count_vec( args->argvec.vec );\n  } else {\n    if( ( args->funcname = strdup( progp->funcname ) ) == NULL ) {\n      GOTO_ERR( ENOMEM );\n    }\n    args->start_arg = progp->arg;\n  }\n  if( pip_is_shared_fd_() ) {\n    args->fd_list = NULL;\n  } else if( ( err = pip_list_coe_fds( &args->fd_list ) ) != 0 ) {\n    GOTO_ERR( err );\n  }\n  /* must be called before calling dlmopen() */\n  pip_gdbif_task_new( task );\n\n  if( ( err = pip_do_corebind( 0, coreno, &cpuset ) ) == 0 ) {\n    char **env_save = environ;\n    environ = args->envvec.vec;\n    /* corebinding should take place before loading solibs,       */\n    /* hoping anon maps would be mapped onto the closer numa node */\n    PIP_ACCUM( time_load_prog,\n\t       ( err = pip_load_prog( progp, args, task ) ) == 0 );\n    args->envvec.vec = environ;\n    environ = env_save;\n    /* and of course, the corebinding must be undone */\n    (void) pip_undo_corebind( 0, coreno, &cpuset );\n  }\n  if( err ) GOTO_ERROR;\n\n  stack_size = pip_stack_size();\n\n  if( ( pip_root->opts & PIP_MODE_PROCESS_PIPCLONE ) ==\n      PIP_MODE_PROCESS_PIPCLONE ) {\n    int flags = pip_clone_flags( CLONE_PARENT_SETTID |\n\t\t\t\t CLONE_CHILD_CLEARTID |\n\t\t\t\t CLONE_SYSVSEM );\n    pid_t pid;\n\n    /* we need lock on ldlinux. supposedly glibc does someting */\n    /* before calling main function */\n    pip_glibc_lock();\n    err = pip_clone_mostly_pthread_ptr( (pthread_t*) &MA(task)->thread,\n\t\t\t\t\tflags,\n\t\t\t\t\t-1,\n\t\t\t\t\tstack_size,\n\t\t\t\t\t(void*(*)(void*)) pip_spawn_top,\n\t\t\t\t\targs,\n\t\t\t\t\t&pid );\n    DBGF( \"pip_clone_mostly_pthread_ptr()=%d\", err );\n    if( err ) pip_glibc_unlock();\n\n  } else {\n    pthread_t\t\tthr;\n    pthread_attr_t \tattr;\n    pid_t\t\ttid = pip_gettid();\n\n    if( ( err = pthread_attr_init( &attr ) ) == 0 ) {\n      err = pthread_attr_setdetachstate( &attr, PTHREAD_CREATE_JOINABLE );\n      DBGF( \"pthread_attr_setdetachstate(JOINABLE)= %d\", err );\n      if( err ) goto error;\n      err = pthread_attr_setstacksize( &attr, stack_size );\n      DBGF( \"pthread_attr_setstacksize( %ld )= %d\", stack_size, err );\n      if( err ) goto error;\n\n      /* we need lock on ldlinux. supposedly glibc does someting */\n      /* before calling main function */\n      pip_glibc_lock();\n      {\n\tif( pip_lock_clone != NULL ) {\n\t  /* lock is needed, because the pip_clone()\n\t     might also be called from outside of PiP lib. */\n\t  pip_spin_lock_wv( pip_lock_clone, tid );\n\t}\n\t/* unlocking pip_lock_clone  is done in the wrapper function */\n\terr = pthread_create( &thr,\n\t\t\t      &attr,\n\t\t\t      (void*(*)(void*)) pip_spawn_top,\n\t\t\t      (void*) args );\n\tDBGF( \"pthread_create()=%d\", err );\n      }\n      if( err ) pip_glibc_unlock();\n    }\n  }\n  if( err == 0 ) {\n    /* wait until task starts running or enqueues */\n    pip_sem_wait( &pip_root->sync_spawn );\n    pip_root->ntasks_count ++;\n    pip_root->ntasks_accum ++;\n    if( bltp != NULL ) *bltp = (pip_task_t*) task;\n\n    DBGF( \"task (PIPID:%d,TID:%d) is created and running\",\n\t  TA(task)->pipid, AA(task)->tid );\n\n  } else {\n  error:\t\t\t/* undo */\n    if( args != NULL ) {\n      PIP_FREE( args->funcname    );\n      PIP_FREE( args->argvec.vec  );\n      PIP_FREE( args->argvec.strs );\n      PIP_FREE( args->envvec.vec  );\n      PIP_FREE( args->envvec.strs );\n      PIP_FREE( args->fd_list     );\n    }\n    if( task != NULL ) {\n      if( MA(task)->loaded != NULL ) {\n\tpip_dlclose( MA(task)->loaded );\n      }\n      pip_reset_task_struct( task );\n    }\n  }\n  DBGF( \"pip_task_spawn(pipid=%d)\", pipid );\n  RETURN( err );\n}\n\n/*\n * The following functions must be called at root process\n */\n\nint pip_task_spawn( pip_spawn_program_t *progp,\n\t\t    uint32_t coreno,\n\t\t    uint32_t opts,\n\t\t    int *pipidp,\n\t\t    pip_spawn_hook_t *hookp ) {\n  pip_task_t\t*task;\n  int \t\tpipid;\n  int \t\terr;\n\n  ENTER;\n  if( pipidp == NULL ) {\n    pipid = PIP_PIPID_ANY;\n  } else {\n    pipid = *pipidp;\n  }\n  err = pip_do_task_spawn( progp, pipid, coreno, opts, &task, NULL, hookp );\n  if( !err ) {\n    if( pipidp != NULL ) *pipidp = TA(PIP_TASKI(task))->pipid;\n  }\n  RETURN( err );\n}\n\nint pip_blt_spawn_( pip_spawn_program_t *progp,\n\t\t    uint32_t coreno,\n\t\t    uint32_t opts,\n\t\t    int *pipidp,\n\t\t    pip_task_t **bltp,\n\t\t    pip_task_queue_t *queue,\n\t\t    pip_spawn_hook_t *hookp ) {\n  pip_task_t \t*blt;\n  int \t\tpipid, err;\n\n  ENTER;\n  if( pipidp == NULL ) {\n    pipid = PIP_PIPID_ANY;\n  } else {\n    pipid = *pipidp;\n  }\n  err = pip_do_task_spawn( progp, pipid, coreno, opts, &blt, queue, hookp );\n  if( !err ) {\n    if( pipidp != NULL ) *pipidp = TA(PIP_TASKI(blt))->pipid;\n    if( bltp   != NULL ) *bltp   = blt;\n  }\n  RETURN( err );\n}\n\nint pip_spawn( char *prog,\n\t       char **argv,\n\t       char **envv,\n\t       uint32_t coreno,\n\t       int  *pipidp,\n\t       pip_spawnhook_t before,\n\t       pip_spawnhook_t after,\n\t       void *hookarg ) {\n  pip_spawn_program_t program;\n  pip_spawn_hook_t hook;\n\n  ENTER;\n  if( prog == NULL ) return EINVAL;\n  pip_spawn_from_main( &program, prog, argv, envv, NULL, NULL );\n  pip_spawn_hook( &hook, before, after, hookarg );\n  RETURN( pip_task_spawn( &program, coreno, 0, pipidp, &hook ) );\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-6oyen5r2v7u3o6slkiermq47zyfmu5sx/spack-src/lib/pip_dlfcn.c": "/*\n * $PIP_license: <Simplified BSD License>\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * \n *     Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n * \n *     Redistributions in binary form must reproduce the above copyright notice,\n *     this list of conditions and the following disclaimer in the documentation\n *     and/or other materials provided with the distribution.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n * $\n * $RIKEN_copyright: Riken Center for Computational Sceience (R-CCS),\n * System Software Development Team, 2016-2021\n * $\n * $PIP_VERSION: Version 3.0.0$\n *\n * $Author: Atsushi Hori (R-CCS)\n * Query:   procinproc-info@googlegroups.com\n * User ML: procinproc-users@googlegroups.com\n * $\n */\n\n/* the EVAL define symbol is to measure the time for calling dlmopen() */\n//#define EVAL\n\n#include <pip/pip_internal.h>\n#include <pip/pip_dlfcn.h>\n\n/* locked dl* functions */\n\nvoid *pip_dlopen( const char *filename, int flag ) {\n  void *handle;\n  pip_glibc_lock();\n  handle = dlopen( filename, flag );\n  pip_glibc_unlock();\n  return handle;\n}\n\nvoid *pip_dlmopen( long lmid, const char *path, int flag ) {\n  void *handle;\n  pip_glibc_lock();\n  handle = dlmopen( lmid, path, flag );\n  pip_glibc_unlock();\n  return handle;\n}\n\nint pip_dlinfo( void *handle, int request, void *info ) {\n  int rv;\n  pip_glibc_lock();\n  rv = dlinfo( handle, request, info );\n  pip_glibc_unlock();\n  return rv;\n}\n\nvoid *pip_dlsym( void *handle, const char *symbol ) {\n  void *addr;\n  pip_glibc_lock();\n  addr = dlsym( handle, symbol );\n  pip_glibc_unlock();\n  return addr;\n}\n\nint pip_dladdr( void *addr, void *info ) {\n  Dl_info *dlinfo = (Dl_info*) info;\n  int rv;\n  pip_glibc_lock();\n  rv = dladdr( addr, dlinfo );\n  pip_glibc_unlock();\n  return rv;\n}\n\nint pip_dlclose( void *handle ) {\n  int rv = 0;\n  pip_glibc_lock();\n  rv = dlclose( handle );\n  pip_glibc_unlock();\n  return rv;\n}\n\nchar *pip_dlerror( void ) {\n  char *dlerr;\n  pip_glibc_lock();\n  dlerr = dlerror();\n  pip_glibc_unlock();\n  return dlerr;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-6oyen5r2v7u3o6slkiermq47zyfmu5sx/spack-src/lib/pip.c": "/*\n * $PIP_license: <Simplified BSD License>\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * \n *     Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n * \n *     Redistributions in binary form must reproduce the above copyright notice,\n *     this list of conditions and the following disclaimer in the documentation\n *     and/or other materials provided with the distribution.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n * $\n * $RIKEN_copyright: Riken Center for Computational Sceience (R-CCS),\n * System Software Development Team, 2016-2021\n * $\n * $PIP_VERSION: Version 3.0.0$\n *\n * $Author: Atsushi Hori (R-CCS)\n * Query:   procinproc-info@googlegroups.com\n * User ML: procinproc-users@googlegroups.com\n * $\n */\n\n//#define DEBUG\n//#define PRINT_MAPS\n//#define PRINT_FDS\n\n/* the EVAL define symbol is to measure the time for calling dlmopen() */\n//#define EVAL\n\n#include <pip/pip_internal.h>\n#include <pip/pip_dlfcn.h>\n#include <pip/pip_gdbif_func.h>\n\n#include <limits.h>\t\t/* for PTHREAD_STACK_MIN */\n#define PIP_TRAMPOLINE_STACKSZ\t(PTHREAD_STACK_MIN)\n\nextern char \t\t**environ;\nextern pip_spinlock_t \t*pip_lock_clone;\n\n pip_clone_mostly_pthread_t pip_clone_mostly_pthread_ptr = NULL;\n\n/*** note that the following static variables are   ***/\n/*** located at each PIP task and the root process. ***/\n\nstatic pip_clone_t*\tpip_cloneinfo = NULL;\n\nstatic void pip_set_magic( pip_root_t *root ) {\n  memcpy( root->magic, PIP_MAGIC_WORD, PIP_MAGIC_WLEN );\n}\n\n#define NITERS\t\t(100)\n#define FACTOR_INIT\t(10)\nstatic uint64_t pip_measure_yieldtime( void ) {\n  double dt, xt;\n  uint64_t c;\n  int i;\n\n  for( i=0; i<NITERS/10; i++ ) pip_system_yield();\n  dt = -pip_gettime();\n  for( i=0; i<NITERS; i++ ) pip_system_yield();\n  dt += pip_gettime();\n  DBGF( \"DT:%g\", dt );\n\n  for( i=0; i<NITERS/10; i++ ) pip_pause();\n  xt = 0.0;\n  for( c=FACTOR_INIT; ; c*=2 ) {\n    xt = -pip_gettime();\n    for( i=0; i<NITERS*c; i++ ) pip_pause();\n    xt += pip_gettime();\n    DBGF( \"c:%lu  XT:%g  DT:%g\", c, xt, dt );\n    if( xt > dt ) break;\n  }\n  c *= 10;\n  DBGF( \"yield:%lu\", c );\n  return c;\n}\n\nstatic int pip_check_opt_and_env( uint32_t *optsp ) {\n  extern pip_spinlock_t pip_lock_got_clone;\n  int opts   = *optsp;\n  int mode   = ( opts & PIP_MODE_MASK );\n  int newmod = 0;\n  char *env  = getenv( PIP_ENV_MODE );\n\n  enum PIP_MODE_BITS {\n    PIP_MODE_PTHREAD_BIT          = 1,\n    PIP_MODE_PROCESS_PRELOAD_BIT  = 2,\n    PIP_MODE_PROCESS_GOT_BIT      = 4,\n    PIP_MODE_PROCESS_PIPCLONE_BIT = 8\n  } desired = 0;\n\n  if( ( opts & ~PIP_VALID_OPTS ) != 0 ) {\n    /* unknown option(s) specified */\n    RETURN( EINVAL );\n  }\n  /* check if pip_preload.so is pre-loaded. if so, */\n  /* PIP_MODE_PROCESS_PRELOAD is the only choice   */\n  if( pip_cloneinfo == NULL ) {\n    pip_cloneinfo = (pip_clone_t*) dlsym( RTLD_DEFAULT, \"pip_clone_info\");\n  }\n  DBGF( \"cloneinfo:%p\", pip_cloneinfo );\n  if( pip_cloneinfo != NULL ) {\n    DBGF( \"mode:0x%x\", mode );\n    if( mode == 0 || \n\t( mode & PIP_MODE_PROCESS_PRELOAD ) == mode ) {\n      newmod = PIP_MODE_PROCESS_PRELOAD;\n      pip_lock_clone = &pip_cloneinfo->lock;\n      goto done;\n    }\n    if( mode & ~PIP_MODE_PROCESS_PRELOAD ) {\n      pip_err_mesg( \"pip_preload.so is already loaded by LD_PRELOAD and \"\n\t\t    \"process:preload must be specified at pip_init()\" );\n      RETURN( EPERM );\n    }\n    if( env == NULL || env[0] == '\\0' ) {\n      newmod = PIP_MODE_PROCESS_PRELOAD;\n      pip_lock_clone = &pip_cloneinfo->lock;\n      goto done;\n    }\n    if( strcasecmp( env, PIP_ENV_MODE_PROCESS_PRELOAD ) == 0 ||\n\tstrcasecmp( env, PIP_ENV_MODE_PROCESS         ) == 0 ) {\n      newmod = PIP_MODE_PROCESS_PRELOAD;\n      pip_lock_clone = &pip_cloneinfo->lock;\n      goto done;\n    } else {\n      pip_err_mesg( \"pip_preload.so is already loaded by LD_PRELOAD and \"\n\t\t    \"process:preload is the only valid choice of PIP_MODE environment\" );\n      RETURN( EPERM );\n    }\n  } else {\n    /* pip_preload.so is not loaded. i.e., LD_PRELOAD does not include pip_preload.so */\n    if( mode != 0 &&\n\t( mode & PIP_MODE_PROCESS_PRELOAD ) == PIP_MODE_PROCESS_PRELOAD ) {\n      pip_err_mesg( \"pip_preload.so is not loaded by LD_PRELOAD and \"\n\t\t    \"process:preload might be a wrong choice\" );\n      RETURN( EPERM );\n    }\n    if( env != NULL && strcasecmp( env, PIP_ENV_MODE_PROCESS_PRELOAD ) == 0 ) {\n      pip_err_mesg( \"pip_preload.so is not loaded by LD_PRELOAD and \"\n\t\t    \"process:preload is a wrong choice of PIP_MODE environment\" );\n      RETURN( EPERM );\n    }\n  }\n\n  switch( mode ) {\n  case 0:\n    if( env == NULL || env[0] == '\\0' ) {\n      desired = PIP_MODE_PTHREAD_BIT     |\n\t        PIP_MODE_PROCESS_GOT_BIT |\n\t        PIP_MODE_PROCESS_PIPCLONE_BIT;\n    } else if( strcasecmp( env, PIP_ENV_MODE_THREAD  ) == 0 ||\n\t       strcasecmp( env, PIP_ENV_MODE_PTHREAD ) == 0 ) {\n      desired = PIP_MODE_PTHREAD_BIT;\n    } else if( strcasecmp( env, PIP_ENV_MODE_PROCESS ) == 0 ) {\n      desired = PIP_MODE_PROCESS_GOT_BIT |\n\t        PIP_MODE_PROCESS_PIPCLONE_BIT;\n    } else if( strcasecmp( env, PIP_ENV_MODE_PROCESS_GOT      ) == 0 ) {\n      desired = PIP_MODE_PROCESS_GOT_BIT;\n    } else if( strcasecmp( env, PIP_ENV_MODE_PROCESS_PIPCLONE ) == 0 ) {\n      desired = PIP_MODE_PROCESS_PIPCLONE_BIT;\n    } else {\n      pip_warn_mesg( \"unknown environment setting PIP_MODE='%s'\", env );\n      RETURN( EPERM );\n    }\n    break;\n  case PIP_MODE_PTHREAD:\n    desired = PIP_MODE_PTHREAD_BIT;\n    break;\n  case PIP_MODE_PROCESS:\n    if( env == NULL || env[0] == '\\0' ) {\n      desired = PIP_MODE_PROCESS_GOT_BIT |\n\t        PIP_MODE_PROCESS_PIPCLONE_BIT;\n    } else if( strcasecmp( env, PIP_ENV_MODE_PROCESS_GOT      ) == 0 ) {\n      desired = PIP_MODE_PROCESS_GOT_BIT;\n    } else if( strcasecmp( env, PIP_ENV_MODE_PROCESS_PIPCLONE ) == 0 ) {\n      desired = PIP_MODE_PROCESS_PIPCLONE_BIT;\n    } else {\n      pip_warn_mesg( \"unknown environment setting PIP_MODE='%s'\", env );\n      RETURN( EPERM );\n    }\n    break;\n  case PIP_MODE_PROCESS_GOT:\n    desired = PIP_MODE_PROCESS_GOT_BIT;\n    break;\n  case PIP_MODE_PROCESS_PIPCLONE:\n    desired = PIP_MODE_PROCESS_PIPCLONE_BIT;\n    break;\n  default:\n    RETURN( EINVAL );\n  }\n\n  if( desired & PIP_MODE_PROCESS_GOT_BIT ) {\n    int pip_wrap_clone( void );\n    if( pip_wrap_clone() == 0 ) {\n      newmod = PIP_MODE_PROCESS_GOT;\n      pip_lock_clone = &pip_lock_got_clone;\n      goto done;\n    } else if( !( desired & ( PIP_MODE_PTHREAD_BIT |\n\t\t\t      PIP_MODE_PROCESS_PIPCLONE_BIT ) ) ) {\n      RETURN( EPERM );\n    }\n  }\n  if( desired & PIP_MODE_PROCESS_PIPCLONE_BIT ) {\n    if ( pip_clone_mostly_pthread_ptr == NULL )\n      pip_clone_mostly_pthread_ptr =\n\tdlsym( RTLD_DEFAULT, \"pip_clone_mostly_pthread\" );\n    if ( pip_clone_mostly_pthread_ptr != NULL ) {\n      newmod = PIP_MODE_PROCESS_PIPCLONE;\n      goto done;\n    } else if( !( desired & PIP_MODE_PTHREAD_BIT) ) {\n      pip_err_mesg( \"%s mode is requested but pip_clone_mostly_pthread() \"\n\t\t    \"cannot not be found in (PiP-)glibc\",\n\t\t    PIP_ENV_MODE_PROCESS_PIPCLONE );\n      RETURN( EPERM );\n    }\n  }\n  if( desired & PIP_MODE_PTHREAD_BIT ) {\n    newmod = PIP_MODE_PTHREAD;\n  }\n\n done:\n  *optsp = ( opts & ~PIP_MODE_MASK ) | newmod;\n  RETURN( 0 );\n}\n\nstatic pip_task_internal_t *pip_get_myself( void ) {\n  pip_task_internal_t *taski;\n  if( pip_isa_root() ) {\n    taski = pip_root->task_root;\n  } else {\n    taski = pip_task;\n  }\n  return taski;\n}\n\n/* internal funcs */\n\nvoid pip_reset_task_struct( pip_task_internal_t *taski ) {\n  pip_task_annex_t \t*annex = AA(taski);\n  pip_task_misc_t \t*misc = annex->misc;\n  void\t\t\t*stack_trampoline = annex->stack_trampoline;\n  void\t\t\t*namexp = annex->named_exptab;\n\n  //memset( (void*) taski, 0, offsetof( pip_task_internal_t, annex ) );\n  PIP_TASKQ_INIT( &TA(taski)->queue  );\n  PIP_TASKQ_INIT( &TA(taski)->schedq );\n  PIP_TASKQ_INIT( &TA(taski)->oodq   );\n  TA(taski)->type  = PIP_TYPE_NULL;\n  TA(taski)->pipid = PIP_PIPID_NULL;\n  pip_spin_init( &TA(taski)->lock_oodq );\n\n  //memset( (void*) annex, 0, sizeof( pip_task_annex_t ) );\n  annex->flag_exit        = 0;\n  annex->stack_trampoline = stack_trampoline;\n  annex->named_exptab     = namexp;\n  annex->tid              = -1; /* pip_gdbif_init_task_struct() refers this */\n  annex->misc             = misc;\n  pip_sem_init( &annex->sleep );\n}\n\nint pip_check_sync_flag( uint32_t *optsp ) {\n  int opts = *optsp;\n  uint32_t f = opts & PIP_SYNC_MASK;\n\n  DBGF( \"flags:0x%x\", f );\n  if( f ) {\n    if( pip_are_flags_exclusive( f, PIP_SYNC_AUTO     ) ) goto OK;\n    if( pip_are_flags_exclusive( f, PIP_SYNC_BUSYWAIT ) ) goto OK;\n    if( pip_are_flags_exclusive( f, PIP_SYNC_YIELD    ) ) goto OK;\n    if( pip_are_flags_exclusive( f, PIP_SYNC_BLOCKING ) ) goto OK;\n    return -1;\n  } else {\n    char *env = getenv( PIP_ENV_SYNC );\n    if( env == NULL ) {\n      f = PIP_SYNC_AUTO;\n    } else if( strcasecmp( env, PIP_ENV_SYNC_AUTO     ) == 0 ) {\n      f = PIP_SYNC_AUTO;\n    } else if( strcasecmp( env, PIP_ENV_SYNC_BUSY     ) == 0 ||\n\t       strcasecmp( env, PIP_ENV_SYNC_BUSYWAIT ) == 0 ) {\n      f = PIP_SYNC_BUSYWAIT;\n    } else if( strcasecmp( env, PIP_ENV_SYNC_YIELD    ) == 0 ) {\n      f = PIP_SYNC_YIELD;\n    } else if( strcasecmp( env, PIP_ENV_SYNC_BLOCK    ) == 0 ||\n\t       strcasecmp( env, PIP_ENV_SYNC_BLOCKING ) == 0 ) {\n      f = PIP_SYNC_BLOCKING;\n    }\n  }\n OK:\n  *optsp = ( opts & ~PIP_SYNC_MASK ) | f;\n  DBGF( \"sync-flag %x | %x => %x\", f, opts, *optsp );\n  return 0;\n}\n\nvoid pip_set_signal_handler( int sig,\n\t\t\t     void(*handler)(),\n\t\t\t     struct sigaction *oldp ) {\n  struct sigaction\tsigact;\n\n  memset( &sigact, 0, sizeof( sigact ) );\n  sigact.sa_sigaction = handler;\n  ASSERTS( sigemptyset( &sigact.sa_mask )    != 0 );\n  ASSERTS( sigaddset( &sigact.sa_mask, sig ) != 0 );\n  ASSERTS( sigaction( sig, &sigact, oldp )   != 0 );\n}\n\nvoid pip_unset_signal_handler( int sig, struct sigaction *oldp ) {\n  ASSERTS( sigaction( sig, oldp, NULL ) != 0 );\n}\n\n/* save PiP environments */\n\nstatic void pip_save_debug_envs( pip_root_t *root ) {\n  char *env;\n\n  if( ( env = getenv( PIP_ENV_STOP_ON_START ) ) != NULL )\n    root->envs.stop_on_start = strdup( env );\n  if( ( env = getenv( PIP_ENV_GDB_PATH      ) ) != NULL )\n    root->envs.gdb_path      = strdup( env );\n  if( ( env = getenv( PIP_ENV_GDB_COMMAND   ) ) != NULL )\n    root->envs.gdb_command   = strdup( env );\n  if( ( env = getenv( PIP_ENV_GDB_SIGNALS   ) ) != NULL )\n    root->envs.gdb_signals   = strdup( env );\n  if( ( env = getenv( PIP_ENV_SHOW_MAPS     ) ) != NULL )\n    root->envs.show_maps     = strdup( env );\n  if( ( env = getenv( PIP_ENV_SHOW_PIPS     ) ) != NULL )\n    root->envs.show_pips    = strdup( env );\n}\n\n/* signal handlers */\n\nstatic void pip_sigchld_handler( int sig, siginfo_t *info, void *extra ) {}\n\nstatic void pip_sigterm_handler( int sig, siginfo_t *info, void *extra ) {\n  ENTER;\n  ASSERTD( TA(pip_task)->pipid != PIP_PIPID_ROOT );\n  (void) pip_kill_all_tasks();\n  (void) kill( getpid(), SIGKILL );\n}\n\nvoid pip_set_sigmask( int sig ) {\n  sigset_t sigmask;\n\n  ASSERTS( sigemptyset( &sigmask ) );\n  ASSERTS( sigaddset(   &sigmask, sig ) );\n  ASSERTS( sigprocmask( SIG_BLOCK, &sigmask, &pip_root->old_sigmask ) );\n}\n\nvoid pip_unset_sigmask( void ) {\n  ASSERTS( sigprocmask( SIG_SETMASK, &pip_root->old_sigmask, NULL ) );\n}\n\n/* API */\n\nint pip_init( int *pipidp, int *ntasksp, void **rt_expp, uint32_t opts ) {\n  pip_root_t\t\t*root;\n  pip_task_internal_t\t*taski;\n  pip_task_misc_t\t*misc;\n  size_t\t\tsz;\n  char\t\t\t*envroot, *envtask;\n  int\t\t\tntasks, pipid;\n  int\t\t\ti, err = 0;\n\n#ifdef DO_MCHECK\n  mcheck( NULL );\n#endif\n\n  if(( envroot = getenv( PIP_ROOT_ENV ) ) == NULL ) {\n    /* root process */\n    if( pip_root != NULL ) RETURN( EBUSY ); /* already initialized */\n    if( ntasksp == NULL ) {\n      ntasks = PIP_NTASKS_MAX;\n    } else {\n      ntasks = *ntasksp;\n    }\n\n    if( ntasks <= 0             ) RETURN( EINVAL );\n    if( ntasks > PIP_NTASKS_MAX ) RETURN( EOVERFLOW );\n\n    if( ( err = pip_check_opt_and_env( &opts ) ) != 0 ) RETURN( err );\n    if( pip_check_sync_flag(   &opts )  < 0 ) RETURN( EINVAL );\n\n#ifndef PIP_CONCAT_STRUCT\n    sz = sizeof(pip_root_t) +\n      sizeof(pip_task_internal_t) * ( ntasks + 1 ) +\n      sizeof(pip_task_annex_t   ) * ( ntasks + 1 ) +\n      sizeof(pip_task_misc_t    ) * ( ntasks + 1 );\n    pip_page_alloc( sz, (void**) &root );\n    (void) memset( root, 0, sz );\n    pip_task_annex_t *annex = (pip_task_annex_t*)\n      ( ((intptr_t)root) +\n\tsizeof(pip_root_t) +\n\tsizeof(pip_task_internal_t) * ( ntasks + 1 ) );\n    misc = (pip_task_misc_t*)\n      ( ((intptr_t)root) +\n\tsizeof(pip_root_t) +\n\tsizeof(pip_task_internal_t) * ( ntasks + 1 ) +\n\tsizeof(pip_task_annex_t)    * ( ntasks + 1 ) );\n    for( i=0; i<ntasks+1; i++ ) {\n      root->tasks[i].annex       = &annex[i];\n      root->tasks[i].annex->misc = &misc[i];\n    }\n#else\n    sz = sizeof(pip_root_t) +\n      sizeof(pip_task_internal_t) * ( ntasks + 1 ) +\n      sizeof(pip_task_misc_t)     * ( ntasks + 1 );\n    pip_page_alloc( sz, (void**) &root );\n    (void) memset( root, 0, sz );\n    pip_task_internal_t\t*tasks = (pip_task_internal_t*)\n      ( ((intptr_t)root) + sizeof(pip_root_t) );\n    misc = (pip_task_misc_t*)\n      ( ((intptr_t)tasks) + sizeof(pip_task_internal_t) * ( ntasks + 1 ) );\n    for( i=0; i<ntasks+1; i++ ) {\n      root->tasks[i].annex.misc = &misc[i];\n    }\n#endif\n    root->size_whole = sz;\n    root->size_root  = sizeof( pip_root_t );\n    root->size_task  = sizeof( pip_task_internal_t );\n    root->size_annex = sizeof( pip_task_annex_t );\n    root->size_misc  = sizeof( pip_task_misc_t );\n\n    DBGF( \"ROOTROOT (%p)\", root );\n\n    pip_spin_init( &root->lock_tasks );\n    pip_spin_init( &root->lock_bt    );\n\n    pip_sem_init( &root->lock_glibc );\n    pip_sem_post( &root->lock_glibc );\n    pip_sem_init( &root->sync_spawn );\n\n    pipid = PIP_PIPID_ROOT;\n    pip_set_magic( root );\n    root->version               = PIP_API_VERSION;\n    root->ntasks                = ntasks;\n    root->ntasks_count          = 1; /* root is also a PiP task */\n    root->cloneinfo             = pip_cloneinfo;\n    root->opts                  = opts;\n    root->yield_iters           = pip_measure_yieldtime();\n    root->stack_size_trampoline = PIP_TRAMPOLINE_STACKSZ;\n    root->task_root             = &root->tasks[ntasks];\n    if( rt_expp != NULL ) {\n      root->export_root = *rt_expp;\n    }\n    for( i=0; i<ntasks+1; i++ ) {\n      pip_named_export_init( &root->tasks[i] );\n      pip_reset_task_struct( &root->tasks[i] );\n    }\n\n    taski = root->task_root;\n    TA(taski)->type       = PIP_TYPE_ROOT;\n    TA(taski)->pipid      = pipid;\n    TA(taski)->task_sched = taski;\n    SETCURR( taski, taski );\n    PIP_RUN( taski );\n\n    AA(taski)->task_root = root;\n    AA(taski)->tid       = pip_gettid();\n    MA(taski)->loaded = dlopen( NULL, RTLD_NOW );\n    MA(taski)->thread = pthread_self();\n\n#ifdef PIP_SAVE_TLS\n    pip_save_tls( &TA(taski)->tls );\n#endif\n    pip_page_alloc( root->stack_size_trampoline,\n\t\t    &AA(taski)->stack_trampoline );\n    if( AA(taski)->stack_trampoline == NULL ) {\n      free( root );\n      RETURN( err );\n    }\n    pip_root = root;\n    pip_task = taski;\n\n    pip_set_name( taski );\n\n    pip_set_sigmask( SIGCHLD );\n    pip_set_signal_handler( SIGCHLD,\n\t\t\t    pip_sigchld_handler,\n\t\t\t    &root->old_sigchld );\n    pip_set_signal_handler( SIGTERM,\n\t\t\t    pip_sigterm_handler,\n\t\t\t    &root->old_sigterm );\n\n    pip_save_debug_envs( root );\n\n    pip_gdbif_initialize_root( ntasks );\n    pip_gdbif_task_commit( taski );\n    pip_debug_on_exceptions( taski );\n\n    DBGF( \"PiP Execution Mode: %s\", pip_get_mode_str() );\n\n  } else if( ( envtask = getenv( PIP_TASK_ENV ) ) != NULL ) {\n    /* child task */\n    int\trv;\n\n    root  = (pip_root_t*) strtoll( envroot, NULL, 16 );\n    pipid = (int) strtol( envtask, NULL, 10 );\n    ASSERTS( pipid < 0 || pipid > root->ntasks );\n    taski = &pip_root->tasks[pipid];\n    if( ( rv = pip_init_task_implicitly( root, taski ) ) == 0 ) {\n      ntasks = root->ntasks;\n      /* succeeded */\n      if( ntasksp != NULL ) *ntasksp = ntasks;\n      if( rt_expp != NULL ) {\n\t*rt_expp = AA(taski)->import_root;\n      }\n      unsetenv( PIP_ROOT_ENV );\n      unsetenv( PIP_TASK_ENV );\n    } else {\n      switch( rv ) {\n      case 1:\n\tpip_err_mesg( \"Invalid PiP root\" );\n\tbreak;\n      case 2:\n\tpip_err_mesg( \"Magic number error\" );\n\tbreak;\n      case 3:\n\tpip_err_mesg( \"Version miss-match between PiP root and task\" );\n\tbreak;\n      case 4:\n\tpip_err_mesg( \"Size miss-match between PiP root and task\" );\n\tbreak;\n      default:\n\tpip_err_mesg( \"Something wrong with PiP root and task\" );\n\tbreak;\n      }\n      RETURN( EINVAL );\n    }\n  } else {\n    RETURN( EPERM );\n  }\n  DBGF( \"pip_root=%p  pip_task=%p\", pip_root, pip_task );\n  /* root and child */\n  if( pipidp != NULL ) *pipidp = pipid;\n  RETURN( err );\n}\n\nint pip_fin( void ) {\n  int ntasks, i;\n\n  ENTER;\n  if( !pip_is_initialized() ) RETURN( EPERM );\n  if( pip_isa_root() ) {\t\t/* root */\n    ntasks = pip_root->ntasks;\n    for( i=0; i<ntasks; i++ ) {\n      pip_task_internal_t *taski = &pip_root->tasks[i];\n      if( TA(taski)->type != PIP_TYPE_NULL ) {\n\tDBGF( \"%d/%d [pipid=%d (type=0x%x)] -- BUSY\",\n\t      i, ntasks, TA(taski)->pipid, TA(taski)->type );\n\tRETURN( EBUSY );\n      }\n    }\n    pip_named_export_fin_all();\n    /* report accumulated timer values, if set */\n    PIP_REPORT( time_load_dso  );\n    PIP_REPORT( time_load_prog );\n    PIP_REPORT( time_dlmopen   );\n\n    pip_sem_fin( &pip_root->lock_glibc );\n    pip_sem_fin( &pip_root->sync_spawn );\n    /* SIGCHLD */\n    pip_unset_sigmask();\n    pip_unset_signal_handler( SIGCHLD,\n\t\t\t      &pip_root->old_sigchld );\n    /* SIGTERM */\n    pip_unset_signal_handler( SIGTERM,\n\t\t\t      &pip_root->old_sigterm );\n\n    if( pip_root->envs.stop_on_start != NULL )\n      free( pip_root->envs.stop_on_start );\n    if( pip_root->envs.gdb_path      != NULL )\n      free( pip_root->envs.gdb_path      );\n    if( pip_root->envs.gdb_command   != NULL )\n      free( pip_root->envs.gdb_command   );\n    if( pip_root->envs.gdb_signals   != NULL )\n      free( pip_root->envs.gdb_signals   );\n    if( pip_root->envs.show_maps     != NULL )\n      free( pip_root->envs.show_maps     );\n    if( pip_root->envs.show_pips     != NULL )\n      free( pip_root->envs.show_pips     );\n\n    memset( pip_root, 0, pip_root->size_whole );\n    /* after this point DBG(F) macros cannot be used */\n    free( pip_root );\n    pip_root = NULL;\n    pip_task = NULL;\n\n    pip_undo_patch_GOT();\n  }\n  RETURN( 0 );\n}\n\nint pip_export( void *exp ) {\n  if( !pip_is_initialized() ) RETURN( EPERM );\n  AA(pip_get_myself())->exp = exp;\n  RETURN( 0 );\n}\n\nint pip_import( int pipid, void **expp  ) {\n  pip_task_internal_t *taski;\n  int err;\n\n  if( ( err = pip_check_pipid( &pipid ) ) != 0 ) RETURN( err );\n  taski = pip_get_task( pipid );\n  if( expp != NULL ) *expp = (void*) AA(taski)->exp;\n  RETURN( 0 );\n}\n\nint pip_isa_task( void ) {\n  return\n    pip_is_initialized() &&\n    PIP_ISA_TASK( pip_task ) && /* root is also a task */\n    !PIP_ISA_ROOT( pip_task );\n}\n\nint pip_get_pipid( int *pipidp ) {\n  int pipid;\n  pipid = pip_get_pipid_();\n  if( pipid == PIP_PIPID_NULL ) RETURN( EPERM );\n  if( pipidp != NULL ) *pipidp = pipid;\n  RETURN( 0 );\n}\n\nint pip_get_ntasks( int *ntasksp ) {\n  if( pip_root == NULL ) return( EPERM  ); /* intentionally small return */\n  if( ntasksp != NULL ) {\n    *ntasksp = pip_root->ntasks;\n  }\n  RETURN( 0 );\n}\n\nint pip_get_mode( int *modep ) {\n  if( pip_root == NULL ) RETURN( EPERM  );\n  if( modep != NULL ) {\n    *modep = ( pip_root->opts & PIP_MODE_MASK );\n  }\n  RETURN( 0 );\n}\n\nconst char *pip_get_mode_str( void ) {\n  char *mode;\n\n  if( pip_root == NULL ) return NULL;\n  switch( pip_root->opts & PIP_MODE_MASK ) {\n  case PIP_MODE_PTHREAD:\n    mode = PIP_ENV_MODE_PTHREAD;\n    break;\n  case PIP_MODE_PROCESS:\n    mode = PIP_ENV_MODE_PROCESS;\n    break;\n  case PIP_MODE_PROCESS_PRELOAD:\n    mode = PIP_ENV_MODE_PROCESS_PRELOAD;\n    break;\n  case PIP_MODE_PROCESS_GOT:\n    mode = PIP_ENV_MODE_PROCESS_GOT;\n    break;\n  case PIP_MODE_PROCESS_PIPCLONE:\n    mode = PIP_ENV_MODE_PROCESS_PIPCLONE;\n    break;\n  default:\n    mode = \"(unknown)\";\n  }\n  return mode;\n}\n\nint pip_is_threaded( int *flagp ) {\n  if( pip_is_threaded_() ) {\n    *flagp = 1;\n  } else {\n    *flagp = 0;\n  }\n  return 0;\n}\n\nint pip_is_shared_fd_( void ) {\n  return pip_is_threaded_();\n}\n\nint pip_is_shared_fd( int *flagp ) {\n  if( pip_root == NULL ) RETURN( EPERM  );\n  if( pip_is_shared_fd_() ) {\n    if( flagp != NULL ) *flagp = 1;\n  } else {\n    if( flagp != NULL ) *flagp = 0;\n  }\n  return 0;\n}\n\nint pip_kill_all_tasks( void ) {\n  int pipid, i, err = 0;\n\n  if( !pip_is_initialized() ) {\n    err = EPERM;\n  } else if( !pip_isa_root() ) {\n    err = EPERM;\n  } else {\n    for( i=0; i<pip_root->ntasks; i++ ) {\n      pipid = i;\n      if( pip_check_pipid( &pipid ) == 0 ) {\n\tif( pip_is_threaded_() ) {\n\t  pip_task_internal_t *taski = &pip_root->tasks[pipid];\n\t  AA(taski)->status = PIP_W_EXITCODE( 0, SIGTERM );\n\t    (void) pip_kill( pipid, SIGQUIT );\n\t} else {\n\t  (void) pip_kill( pipid, SIGKILL );\n\t}\n      }\n    }\n  }\n  return err;\n}\n\nint pip_get_system_id( int pipid, pip_id_t *idp ) {\n  pip_task_internal_t *taski;\n  int err;\n\n  if( ( err = pip_check_pipid( &pipid ) ) != 0 ) RETURN( err );\n  if( idp != NULL ) {\n    taski = pip_get_task( pipid );\n    /* Do not call gettid() nor pthread_self() for tbis                */\n    /* if a task is a BLT then gettid() returns the scheduling task ID */\n    if( pip_is_threaded_() ) {\n      *idp = (intptr_t) AA(TA(taski)->task_sched)->misc->thread;\n    } else {\n      *idp = (intptr_t) AA(taski)->tid;\n    }\n  }\n  RETURN( 0 );\n}\n\n/* energy-saving spin-lock */\nvoid pip_glibc_lock( void ) __attribute__ ((unused));\n/* actually this is being used */\nvoid pip_glibc_lock( void ) {\n  if( pip_root != NULL ) pip_sem_wait( &pip_root->lock_glibc );\n}\n\nvoid pip_glibc_unlock( void ) __attribute__ ((unused));\n/* actually this is being used */\nvoid pip_glibc_unlock( void ) {\n  if( pip_root != NULL ) pip_sem_post( &pip_root->lock_glibc );\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-6oyen5r2v7u3o6slkiermq47zyfmu5sx/spack-src/include/pip/pip_dlfcn.h": "/*\n * $PIP_license: <Simplified BSD License>\n * Redistribution and use in source and binary forms, with or without\n * modification, are permitted provided that the following conditions are met:\n * \n *     Redistributions of source code must retain the above copyright notice,\n *     this list of conditions and the following disclaimer.\n * \n *     Redistributions in binary form must reproduce the above copyright notice,\n *     this list of conditions and the following disclaimer in the documentation\n *     and/or other materials provided with the distribution.\n * \n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n * THE POSSIBILITY OF SUCH DAMAGE.\n * $\n * $RIKEN_copyright: Riken Center for Computational Sceience (R-CCS),\n * System Software Development Team, 2016-2021\n * $\n * $PIP_VERSION: Version 3.0.0$\n *\n * $Author: Atsushi Hori (R-CCS)\n * Query:   procinproc-info@googlegroups.com\n * User ML: procinproc-users@googlegroups.com\n * $\n */\n\n#ifndef _pip_dlfcn_h_\n#define _pip_dlfcn_h_\n\n#ifndef DOXYGEN_INPROGRESS\n\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n  /* locked dl* functions */\n  void *pip_dlopen( const char *filename, int flag );\n  void *pip_dlmopen( long lmid, const char *path, int flag );\n  int   pip_dlinfo( void *handle, int request, void *info );\n  void *pip_dlsym( void *handle, const char *symbol );\n  int   pip_dladdr( void *addr, void *info );\n  int   pip_dlclose( void *handle );\n  char *pip_dlerror( void );\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n#endif\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-6oyen5r2v7u3o6slkiermq47zyfmu5sx/spack-src/PiP-Testsuite/PiP-Testsuite/.git/objects/pack/pack-2314cb1416a2c0694ca37197809b7079cf097db8.idx",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-6oyen5r2v7u3o6slkiermq47zyfmu5sx/spack-src/PiP-Testsuite/PiP-Testsuite/.git/objects/pack/pack-2314cb1416a2c0694ca37197809b7079cf097db8.pack",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-6oyen5r2v7u3o6slkiermq47zyfmu5sx/spack-src/.git/objects/pack/pack-ef866222aa82df017f7026dfa242fbbd38bfe8af.idx",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-6oyen5r2v7u3o6slkiermq47zyfmu5sx/spack-src/.git/objects/pack/pack-ef866222aa82df017f7026dfa242fbbd38bfe8af.pack",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-6oyen5r2v7u3o6slkiermq47zyfmu5sx/spack-src/doc/tutorial/tex/listings.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-6oyen5r2v7u3o6slkiermq47zyfmu5sx/spack-src/doc/html/ftv2mo.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-6oyen5r2v7u3o6slkiermq47zyfmu5sx/spack-src/doc/html/ftv2splitbar.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-6oyen5r2v7u3o6slkiermq47zyfmu5sx/spack-src/doc/html/nav_g.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-6oyen5r2v7u3o6slkiermq47zyfmu5sx/spack-src/doc/html/ftv2pnode.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-6oyen5r2v7u3o6slkiermq47zyfmu5sx/spack-src/doc/html/ftv2doc.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-6oyen5r2v7u3o6slkiermq47zyfmu5sx/spack-src/doc/html/tab_h.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-6oyen5r2v7u3o6slkiermq47zyfmu5sx/spack-src/doc/html/tab_s.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-6oyen5r2v7u3o6slkiermq47zyfmu5sx/spack-src/doc/html/ftv2mlastnode.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-6oyen5r2v7u3o6slkiermq47zyfmu5sx/spack-src/doc/html/ftv2folderopen.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-6oyen5r2v7u3o6slkiermq47zyfmu5sx/spack-src/doc/html/tab_a.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-6oyen5r2v7u3o6slkiermq47zyfmu5sx/spack-src/doc/html/ftv2plastnode.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-6oyen5r2v7u3o6slkiermq47zyfmu5sx/spack-src/doc/html/ftv2vertline.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-6oyen5r2v7u3o6slkiermq47zyfmu5sx/spack-src/doc/html/ftv2lastnode.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-6oyen5r2v7u3o6slkiermq47zyfmu5sx/spack-src/doc/html/sync_on.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-6oyen5r2v7u3o6slkiermq47zyfmu5sx/spack-src/doc/html/ftv2blank.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-6oyen5r2v7u3o6slkiermq47zyfmu5sx/spack-src/doc/html/ftv2link.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-6oyen5r2v7u3o6slkiermq47zyfmu5sx/spack-src/doc/html/nav_f.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-6oyen5r2v7u3o6slkiermq47zyfmu5sx/spack-src/doc/html/tab_b.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-6oyen5r2v7u3o6slkiermq47zyfmu5sx/spack-src/doc/html/open.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-6oyen5r2v7u3o6slkiermq47zyfmu5sx/spack-src/doc/html/ftv2folderclosed.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-6oyen5r2v7u3o6slkiermq47zyfmu5sx/spack-src/doc/html/bdwn.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-6oyen5r2v7u3o6slkiermq47zyfmu5sx/spack-src/doc/html/bc_s.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-6oyen5r2v7u3o6slkiermq47zyfmu5sx/spack-src/doc/html/nav_h.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-6oyen5r2v7u3o6slkiermq47zyfmu5sx/spack-src/doc/html/ftv2ns.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-6oyen5r2v7u3o6slkiermq47zyfmu5sx/spack-src/doc/html/ftv2cl.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-6oyen5r2v7u3o6slkiermq47zyfmu5sx/spack-src/doc/html/sync_off.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-6oyen5r2v7u3o6slkiermq47zyfmu5sx/spack-src/doc/html/ftv2mnode.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-6oyen5r2v7u3o6slkiermq47zyfmu5sx/spack-src/doc/html/closed.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-6oyen5r2v7u3o6slkiermq47zyfmu5sx/spack-src/doc/html/doxygen.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-6oyen5r2v7u3o6slkiermq47zyfmu5sx/spack-src/doc/html/ftv2node.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-6oyen5r2v7u3o6slkiermq47zyfmu5sx/spack-src/doc/html/search/close.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-6oyen5r2v7u3o6slkiermq47zyfmu5sx/spack-src/doc/html/search/search_m.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-6oyen5r2v7u3o6slkiermq47zyfmu5sx/spack-src/doc/html/search/search_r.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-6oyen5r2v7u3o6slkiermq47zyfmu5sx/spack-src/doc/html/search/mag_sel.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-6oyen5r2v7u3o6slkiermq47zyfmu5sx/spack-src/doc/html/search/search_l.png",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-6oyen5r2v7u3o6slkiermq47zyfmu5sx/spack-src/doc/latex-inuse/libpip-manpages.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-6oyen5r2v7u3o6slkiermq47zyfmu5sx/spack-src/doc/man/index.db",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-6oyen5r2v7u3o6slkiermq47zyfmu5sx/spack-src/doc/slides/HPDC18-ROSS.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-6oyen5r2v7u3o6slkiermq47zyfmu5sx/spack-src/doc/slides/HPDC18.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-6oyen5r2v7u3o6slkiermq47zyfmu5sx/spack-src/doc/slides/IPDPS-RADR-2020.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-process-in-process-3-6oyen5r2v7u3o6slkiermq47zyfmu5sx/spack-src/doc/logo/PiP.pdf"
    ],
    "total_files": 730
}