{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/src/nosyscallsreal.c": "/****************************************************************************\n *   Copyright (C) 2006-2010 by Jason Ansel, Kapil Arya, and Gene Cooperman *\n *   jansel@csail.mit.edu, kapil@ccs.neu.edu, gene@ccs.neu.edu              *\n *                                                                          *\n *  This file is part of DMTCP.                                             *\n *                                                                          *\n *  DMTCP is free software: you can redistribute it and/or                  *\n *  modify it under the terms of the GNU Lesser General Public License as   *\n *  published by the Free Software Foundation, either version 3 of the      *\n *  License, or (at your option) any later version.                         *\n *                                                                          *\n *  DMTCP is distributed in the hope that it will be useful,                *\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of          *\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *\n *  GNU Lesser General Public License for more details.                     *\n *                                                                          *\n *  You should have received a copy of the GNU Lesser General Public        *\n *  License along with DMTCP:dmtcp/src.  If not, see                        *\n *  <http://www.gnu.org/licenses/>.                                         *\n ****************************************************************************/\n\n\n#define _GNU_SOURCE\n#define _XOPEN_SOURCE 500\n// These next two are defined in features.h based on the user macros above.\n// #define GNU_SRC\n// #define __USE_UNIX98\n\n// FIXME:  See comment in syscallwrappers.h about how to remove the need for\n//         this extra declaration.\n#define FOR_SYSCALLSREAL_C\n\n#include <pthread.h>\n// We should not need dlopen/dlsym\n// #include <dlfcn.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <sys/syscall.h>\n#include <sys/ioctl.h>\n#include <unistd.h>\n#include <ctype.h>\n#include <syslog.h>\n#include \"constants.h\"\n#include \"syscallwrappers.h\"\n\n// See syscallsreal.c for original model.  In libdmtcp.so, system calls\n//   for XXX() in jalib call a wrapper which modifies it and calls\n//   syscallsreal.c:_real_XXX(), to directly calls kernel.\n// For other functions (dmtcp_launch, dmtcp_restart, etc.),\n//   we want their invocations of jalib to directly call glibc with no wrappers.\n// Jalib has some calls to real_XXX() to avoid going through the wrapper.\n//   Those are defined in syscallsreal.cpp, but this is a simpler interface\n//   that avoids calling on dlsym() and syscallsreal.cpp (by calling this\n//   smaller image, jnosyscallsreal.cpp), in order to keep those\n//   binaries smaller, and to keep the code simpler and more maintainable.\n//   Can add wrapper code for libhijack.so without fear of contaminating\n//   the other DMTCP executables with that wrapper.\n\n// NOTE:  An alternative to this strategy would be to put this in a file,\n//   nosyscallwrappers.h and #define away the real_XXX() calls.\n//   But some files like uniquepid.cpp and connection.cpp could be\n//   linked either to libdmtcp.so or to dmtcp_restart.\n\n/// FIXME:  dmtcpworker.cpp is linked into some ordinary executables.\n///         It should be modified to avoid this, so we don't need gratuitous\n///         extra reall_syscalls here like dmtcp_unsetenv(), dmtcp_lock()\n\n//////////////////////////\n//// DEFINE REAL VERSIONS OF NEEDED FUNCTIONS (based on syscallsreal.cpp)\n//// (Define only functions needed for dmtcp_launch, dmtcp_restart, etc.\n\nstatic pthread_mutex_t theMutex = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;\n\n#define REAL_FUNC_PASSTHROUGH(name) return name\n\n#define REAL_FUNC_PASSTHROUGH_TYPED(type, name) REAL_FUNC_PASSTHROUGH(name)\n#define REAL_FUNC_PASSTHROUGH_TYPED_DLSYM(type, name) return dlsym(RTLD_NEXT, #name)\n\n#define REAL_FUNC_PASSTHROUGH_PID_T(name) REAL_FUNC_PASSTHROUGH(name)\n\n// No return statement for functions returning void:\n#define REAL_FUNC_PASSTHROUGH_VOID(name) name\n\n#define SYMBOL_NOT_FOUND_ERROR(name) \\\n  fprintf(stderr, \"ERROR: DMTCP internal error.\\n\" \\\n                  \"  Symbol %s not found!\\n\", #name); \\\n  abort(); \\\n  return -1;\n\nvoid _dmtcp_lock() { pthread_mutex_lock (&theMutex); }\nvoid _dmtcp_unlock() { pthread_mutex_unlock (&theMutex); }\n\nvoid initialize_wrappers() {\n  return;\n}\n\nint _real_pthread_mutex_lock(pthread_mutex_t *mutex) {\n  REAL_FUNC_PASSTHROUGH_TYPED (int,pthread_mutex_lock) (mutex);\n}\n\nint _real_pthread_mutex_trylock(pthread_mutex_t *mutex) {\n  REAL_FUNC_PASSTHROUGH_TYPED (int,pthread_mutex_trylock) (mutex);\n}\n\nint _real_pthread_mutex_unlock(pthread_mutex_t *mutex) {\n  REAL_FUNC_PASSTHROUGH_TYPED (int,pthread_mutex_unlock) (mutex);\n}\n\nint _real_pthread_rwlock_unlock(pthread_rwlock_t *rwlock) {\n  REAL_FUNC_PASSTHROUGH_TYPED (int,pthread_rwlock_unlock) (rwlock);\n}\n\nint _real_pthread_rwlock_rdlock(pthread_rwlock_t *rwlock) {\n  REAL_FUNC_PASSTHROUGH_TYPED (int,pthread_rwlock_rdlock) (rwlock);\n}\n\nint _real_pthread_rwlock_wrlock(pthread_rwlock_t *rwlock) {\n  REAL_FUNC_PASSTHROUGH_TYPED (int,pthread_rwlock_wrlock) (rwlock);\n}\n\nssize_t _real_read(int fd, void *buf, size_t count) {\n  REAL_FUNC_PASSTHROUGH (read) (fd,buf,count);\n}\n\nssize_t _real_write(int fd, const void *buf, size_t count) {\n  REAL_FUNC_PASSTHROUGH_TYPED (ssize_t,write) (fd,buf,count);\n}\n\nint _real_select(int nfds, fd_set *readfds, fd_set *writefds,\n                 fd_set *exceptfds, struct timeval *timeout) {\n  REAL_FUNC_PASSTHROUGH (select) (nfds,readfds,writefds,exceptfds,timeout);\n}\n\n/// call the libc version of this function via dlopen/dlsym\nint _real_socket (int domain, int type, int protocol)\n{\n  REAL_FUNC_PASSTHROUGH (socket) (domain,type,protocol);\n}\n\n/// call the libc version of this function via dlopen/dlsym\nint _real_connect (int sockfd,  const  struct sockaddr *serv_addr, socklen_t addrlen)\n{\n  REAL_FUNC_PASSTHROUGH (connect) (sockfd,serv_addr,addrlen);\n}\n\n/// call the libc version of this function via dlopen/dlsym\nint _real_bind (int sockfd,  const struct  sockaddr  *my_addr,  socklen_t addrlen)\n{\n  REAL_FUNC_PASSTHROUGH (bind) (sockfd,my_addr,addrlen);\n}\n\n/// call the libc version of this function via dlopen/dlsym\nint _real_listen (int sockfd, int backlog)\n{\n  REAL_FUNC_PASSTHROUGH (listen) (sockfd,backlog);\n}\n\n/// call the libc version of this function via dlopen/dlsym\nint _real_accept (int sockfd, struct sockaddr *addr, socklen_t *addrlen)\n{\n  REAL_FUNC_PASSTHROUGH (accept) (sockfd,addr,addrlen);\n}\n\n/// call the libc version of this function via dlopen/dlsym\nint _real_setsockopt (int s, int  level,  int  optname,  const  void  *optval,\n                       socklen_t optlen)\n{\n  REAL_FUNC_PASSTHROUGH (setsockopt) (s,level,optname,optval,optlen);\n}\n\nint _real_getsockopt (int s, int  level,  int  optname,  void  *optval,\n                       socklen_t* optlen)\n{\n  REAL_FUNC_PASSTHROUGH (getsockopt) (s,level,optname,optval,optlen);\n}\n\nint _real_execve (const char *filename, char *const argv[],\n                   char *const envp[])\n{\n  REAL_FUNC_PASSTHROUGH (execve) (filename,argv,envp);\n}\n\nint _real_execv (const char *path, char *const argv[])\n{\n  REAL_FUNC_PASSTHROUGH (execv) (path,argv);\n}\n\nint _real_execvp (const char *file, char *const argv[])\n{\n  REAL_FUNC_PASSTHROUGH (execvp) (file,argv);\n}\n\nint _real_system (const char *cmd)\n{\n  REAL_FUNC_PASSTHROUGH (system) (cmd);\n}\n\npid_t _real_fork(void)\n{\n  REAL_FUNC_PASSTHROUGH_PID_T (fork) ();\n}\n\nint _real_close (int fd)\n{\n  REAL_FUNC_PASSTHROUGH (close) (fd);\n}\n\nint _real_fclose (FILE *fp)\n{\n  REAL_FUNC_PASSTHROUGH (fclose) (fp);\n}\n\nint _real_dup (int oldfd)\n{\n  REAL_FUNC_PASSTHROUGH (dup) (oldfd);\n}\n\nint _real_dup2 (int oldfd, int newfd)\n{\n  REAL_FUNC_PASSTHROUGH (dup2) (oldfd, newfd);\n}\n\n//int _real_dup3 (int oldfd, int newfd, int flags)\n//{\n//  REAL_FUNC_PASSTHROUGH (dup3) (oldfd, newfd, flags);\n//}\n\nvoid _real_exit (int status)\n{\n  REAL_FUNC_PASSTHROUGH_VOID (exit) (status);\n}\n\nLIB_PRIVATE\nint _real_fcntl(int fd, int cmd, void *arg)\n{\n  REAL_FUNC_PASSTHROUGH (fcntl) (fd, cmd, arg);\n}\n\nint _real_ptsname_r (int fd, char * buf, size_t buflen)\n{\n  REAL_FUNC_PASSTHROUGH (ptsname_r) (fd, buf, buflen);\n}\n\nint _real_socketpair (int d, int type, int protocol, int sv[2])\n{\n  REAL_FUNC_PASSTHROUGH (socketpair) (d,type,protocol,sv);\n}\n\nvoid _real_openlog (const char *ident, int option, int facility)\n{\n  REAL_FUNC_PASSTHROUGH_VOID (openlog) (ident,option,facility);\n}\n\nvoid _real_closelog (void)\n{\n  REAL_FUNC_PASSTHROUGH_VOID (closelog) ();\n}\n\nint _dmtcp_unsetenv(const char *name) {\n  REAL_FUNC_PASSTHROUGH (unsetenv) (name);\n}\n\noff_t _real_lseek(int fd, off_t offset, int whence) {\n  REAL_FUNC_PASSTHROUGH_TYPED (off_t,lseek) (fd,offset,whence);\n}\n\npid_t _real_getpid(void) {\n  REAL_FUNC_PASSTHROUGH_PID_T (getpid) ();\n}\n\npid_t _real_getppid(void) {\n  REAL_FUNC_PASSTHROUGH_PID_T (getppid) ();\n}\n\nint _real_tcsetpgrp(int fd, pid_t pgrp) {\n  REAL_FUNC_PASSTHROUGH (tcsetpgrp) (fd, pgrp);\n}\n\nint _real_tcgetpgrp(int fd) {\n  REAL_FUNC_PASSTHROUGH (tcgetpgrp) (fd);\n}\n\npid_t _real_getpgrp(void) {\n  REAL_FUNC_PASSTHROUGH_PID_T (getpgrp) ();\n}\n\npid_t _real_setpgrp(void) {\n  REAL_FUNC_PASSTHROUGH_PID_T (setpgrp) ();\n}\n\npid_t _real_getpgid(pid_t pid) {\n  REAL_FUNC_PASSTHROUGH_PID_T (getpgid) (pid);\n}\n\nint   _real_setpgid(pid_t pid, pid_t pgid) {\n  REAL_FUNC_PASSTHROUGH (setpgid) (pid, pgid);\n}\n\npid_t _real_getsid(pid_t pid) {\n  REAL_FUNC_PASSTHROUGH_PID_T (getsid) (pid);\n}\n\npid_t _real_setsid(void) {\n  REAL_FUNC_PASSTHROUGH_PID_T (setsid) ();\n}\n\nint   _real_kill(pid_t pid, int sig) {\n  REAL_FUNC_PASSTHROUGH (kill) (pid, sig);\n}\n\npid_t _real_wait(__WAIT_STATUS stat_loc) {\n  REAL_FUNC_PASSTHROUGH_PID_T (wait) (stat_loc);\n}\n\npid_t _real_waitpid(pid_t pid, int *stat_loc, int options) {\n  REAL_FUNC_PASSTHROUGH_PID_T (waitpid) (pid, stat_loc, options);\n}\n\nint   _real_waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options) {\n  REAL_FUNC_PASSTHROUGH (waitid) (idtype, id, infop, options);\n}\n\npid_t _real_wait3(__WAIT_STATUS status, int options, struct rusage *rusage) {\n  REAL_FUNC_PASSTHROUGH_PID_T (wait3) (status, options, rusage);\n}\n\npid_t _real_wait4(pid_t pid, __WAIT_STATUS status, int options, struct rusage *rusage) {\n  REAL_FUNC_PASSTHROUGH_PID_T (wait4) (pid, status, options, rusage);\n}\n\nint send_sigwinch; /* not used.  Only version in pidwrappers.cpp is used */\nint _real_ioctl(int d, unsigned long int request, ...) {\n  void * arg;\n  va_list ap;\n\n  // Most calls to ioctl take 'void *', 'int' or no extra argument\n  // A few specialized ones take more args, but we don't need to handle those.\n  va_start(ap, request);\n  arg = va_arg(ap, void *);\n  va_end(ap);\n\n  // /usr/include/unistd.h says syscall returns long int (contrary to man page)\n  REAL_FUNC_PASSTHROUGH_TYPED (int, ioctl) (d, request, arg);\n}\n\nLIB_PRIVATE\nvoid *_real_mmap(void *addr, size_t length, int prot, int flags,\n    int fd, off_t offset) {\n  REAL_FUNC_PASSTHROUGH_TYPED (void*, mmap) (addr,length,prot,flags,fd,offset);\n}\n\nLIB_PRIVATE\nint _real_munmap(void *addr, size_t length) {\n  REAL_FUNC_PASSTHROUGH_TYPED (int, munmap) (addr, length);\n}\n\n\n// Needed for _real_gettid, etc.\nlong _real_syscall(long sys_num, ...) {\n  int i;\n  void * arg[7];\n  va_list ap;\n\n  va_start(ap, sys_num);\n  for (i = 0; i < 7; i++)\n    arg[i] = va_arg(ap, void *);\n  va_end(ap);\n\n  // /usr/include/unistd.h says syscall returns long int (contrary to man page)\n  REAL_FUNC_PASSTHROUGH_TYPED (long, syscall) (sys_num, arg[0],\n                                               arg[1], arg[2],\n                                               arg[3], arg[4],\n                                               arg[5], arg[6]);\n}\n\nLIB_PRIVATE pid_t dmtcp_gettid() {\n  return syscall(SYS_gettid);\n}\nLIB_PRIVATE int dmtcp_tkill(int tid, int sig) {\n  return syscall(SYS_tkill, tid, sig);\n}\nLIB_PRIVATE int dmtcp_tgkill(int tgid, int tid, int sig) {\n  return syscall(SYS_tgkill, tgid, tid, sig);\n}\n\nint _real_open (const char *pathname, int flags, ...) {\n  mode_t mode = 0;\n  // Handling the variable number of arguments\n  if (flags & O_CREAT) {\n    va_list arg;\n    va_start (arg, flags);\n    mode = va_arg (arg, int);\n    va_end (arg);\n  }\n  REAL_FUNC_PASSTHROUGH (open) (pathname, flags, mode);\n}\n\nint _real_open64 (const char *pathname, int flags, ...) {\n  mode_t mode = 0;\n  // Handling the variable number of arguments\n  if (flags & O_CREAT) {\n    va_list arg;\n    va_start (arg, flags);\n    mode = va_arg (arg, int);\n    va_end (arg);\n  }\n  REAL_FUNC_PASSTHROUGH (open) (pathname, flags, mode);\n}\n\nFILE * _real_fopen(const char *path, const char *mode) {\n  REAL_FUNC_PASSTHROUGH_TYPED (FILE *, fopen) (path, mode);\n}\n\nFILE * _real_fopen64(const char *path, const char *mode) {\n  REAL_FUNC_PASSTHROUGH_TYPED (FILE *, fopen64) (path, mode);\n}\n\nint _real_shmget (key_t key, size_t size, int shmflg) {\n  REAL_FUNC_PASSTHROUGH (shmget) (key, size, shmflg);\n}\n\nvoid* _real_shmat (int shmid, const void *shmaddr, int shmflg) {\n  REAL_FUNC_PASSTHROUGH_TYPED (void*, shmat) (shmid, shmaddr, shmflg);\n}\n\nint _real_shmdt (const void *shmaddr) {\n  REAL_FUNC_PASSTHROUGH (shmdt) (shmaddr);\n}\n\nint _real_shmctl (int shmid, int cmd, struct shmid_ds *buf) {\n  REAL_FUNC_PASSTHROUGH (shmctl) (shmid, cmd, buf);\n}\n\nLIB_PRIVATE\nint _real_poll(struct pollfd *fds, nfds_t nfds, int timeout) {\n  REAL_FUNC_PASSTHROUGH (poll) (fds, nfds, timeout);\n}\n\nssize_t _real_readlink(const char *path, char *buf, size_t bufsiz) {\n  REAL_FUNC_PASSTHROUGH_TYPED (ssize_t, readlink) (path, buf, bufsiz);\n}\n\n// Used for wrappers for mmap, sbrk\nvoid _dmtcp_setup_trampolines() {}\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/src/shareddata.cpp": "/****************************************************************************\n *   Copyright (C) 2006-2013 by Jason Ansel, Kapil Arya, and Gene Cooperman *\n *   jansel@csail.mit.edu, kapil@ccs.neu.edu, gene@ccs.neu.edu              *\n *                                                                          *\n *  This file is part of DMTCP.                                             *\n *                                                                          *\n *  DMTCP is free software: you can redistribute it and/or                  *\n *  modify it under the terms of the GNU Lesser General Public License as   *\n *  published by the Free Software Foundation, either version 3 of the      *\n *  License, or (at your option) any later version.                         *\n *                                                                          *\n *  DMTCP is distributed in the hope that it will be useful,                *\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of          *\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *\n *  GNU Lesser General Public License for more details.                     *\n *                                                                          *\n *  You should have received a copy of the GNU Lesser General Public        *\n *  License along with DMTCP:dmtcp/src.  If not, see                        *\n *  <http://www.gnu.org/licenses/>.                                         *\n ****************************************************************************/\n\n#include <stdlib.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <sys/ipc.h>\n\n#include \"constants.h\"\n#include \"protectedfds.h\"\n#include \"dmtcpalloc.h\"\n#include \"uniquepid.h\"\n#include \"syscallwrappers.h\"\n#include \"util.h\"\n#include \"membarrier.h\"\n#include \"coordinatorapi.h\"\n#include \"shareddata.h\"\n#include \"../jalib/jassert.h\"\n#include \"../jalib/jconvert.h\"\n\n#define SHM_MAX_SIZE (sizeof(SharedData::Header))\n\nusing namespace dmtcp;\nstatic struct SharedData::Header *sharedDataHeader = NULL;\nstatic uint32_t nextVirtualPtyId = (uint32_t)-1;\n\nvoid SharedData::initializeHeader(const char *tmpDir,\n                                  const char *installDir,\n                                  DmtcpUniqueProcessId *compId,\n                                  CoordinatorInfo *coordInfo,\n                                  struct in_addr *localIPAddr)\n{\n  JASSERT(tmpDir && installDir && compId && coordInfo && localIPAddr);\n\n  off_t size = CEIL(SHM_MAX_SIZE , Util::pageSize());\n  JASSERT(lseek(PROTECTED_SHM_FD, size, SEEK_SET) == size)\n    (JASSERT_ERRNO);\n  Util::writeAll(PROTECTED_SHM_FD, \"\", 1);\n  memset(sharedDataHeader, 0, size);\n\n  strcpy(sharedDataHeader->versionStr, SHM_VERSION_STR);\n#if 0\n  sharedDataHeader->coordHost[0] = '\\0';\n  sharedDataHeader->coordPort = -1;\n  sharedDataHeader->ckptInterval = -1;\n#endif\n  sharedDataHeader->dlsymOffset = 0;\n  sharedDataHeader->dlsymOffset_m32 = 0;\n  sharedDataHeader->numSysVShmIdMaps = 0;\n  sharedDataHeader->numSysVSemIdMaps = 0;\n  sharedDataHeader->numSysVMsqIdMaps = 0;\n  sharedDataHeader->numSysVShmKeyMaps = 0;\n  sharedDataHeader->numPtraceIdMaps = 0;\n  sharedDataHeader->numPtyNameMaps = 0;\n  sharedDataHeader->initialized = true;\n  sharedDataHeader->numIncomingConMaps = 0;\n  memcpy(&sharedDataHeader->compId, compId, sizeof(*compId));\n  memcpy(&sharedDataHeader->coordInfo, coordInfo, sizeof (*coordInfo));\n  memcpy(&sharedDataHeader->localIPAddr, localIPAddr, sizeof (*localIPAddr));\n  // The current implementation simply increments the last count and returns it.\n  // Although highly unlikely, this can cause a problem if the counter resets to\n  // zero. In that case we should have some more sophisticated code which checks\n  // to see if the value pointed by counter is in use or not.\n  if (nextVirtualPtyId != (uint32_t)-1) {\n    sharedDataHeader->nextVirtualPtyId = nextVirtualPtyId;\n  } else {\n    sharedDataHeader->nextVirtualPtyId = 0;\n  }\n  JASSERT(strlen(tmpDir) < sizeof(sharedDataHeader->tmpDir) - 1) (tmpDir);\n  strcpy(sharedDataHeader->tmpDir, tmpDir);\n\n  JASSERT(strlen(installDir) < sizeof(sharedDataHeader->installDir) - 1)\n    (installDir);\n  strcpy(sharedDataHeader->installDir, installDir);\n}\n\nbool SharedData::initialized()\n{\n  return sharedDataHeader != NULL;\n}\n\nvoid SharedData::initialize(const char *tmpDir = NULL,\n                            const char *installDir = NULL,\n                            DmtcpUniqueProcessId *compId = NULL,\n                            CoordinatorInfo *coordInfo = NULL,\n                            struct in_addr *localIPAddr = NULL)\n{\n  /* FIXME: If the coordinator timestamp resolution is 1 second, during\n   * subsequent restart, the coordinator timestamp may have the same value\n   * causing conflict with SharedData file. In future, a better fix would be to\n   * delete the file associated with SharedData in preCkpt phase and recreate\n   * it in postCkpt/postRestart phase.\n   */\n  bool needToInitialize = false;\n  JASSERT((coordInfo != NULL && localIPAddr != NULL) ||\n          Util::isValidFd(PROTECTED_SHM_FD));\n  if (!Util::isValidFd(PROTECTED_SHM_FD)) {\n    JASSERT(tmpDir != NULL);\n    ostringstream o;\n    o << tmpDir << \"/dmtcpSharedArea.\"\n      << *compId << \".\" << std::hex << coordInfo->timeStamp;\n    // THIS IS A DUP OF initializeHeader AND OF size, below; Pass this in as an\n    // argument to it.\n    off_t size = CEIL(SHM_MAX_SIZE, Util::pageSize());\n\n    int fd = _real_open(o.str().c_str(), O_RDWR | O_CREAT | O_EXCL, 0600);\n    if (fd == -1 && errno == EEXIST) {\n      fd = _real_open(o.str().c_str(), O_RDWR, 0600);\n    } else {\n      // Extend file to size before 'mmap'\n      JASSERT( truncate(o.str().c_str(), size) == 0);\n      needToInitialize = true;\n    }\n    JASSERT(fd != -1) (JASSERT_ERRNO);\n    JASSERT(_real_dup2(fd, PROTECTED_SHM_FD) == PROTECTED_SHM_FD)\n      (JASSERT_ERRNO);\n    _real_close(fd);\n  }\n\n  size_t size = CEIL(SHM_MAX_SIZE , Util::pageSize());\n  void *addr = _real_mmap((void*) sharedDataHeader, size,\n                          PROT_READ | PROT_WRITE, MAP_SHARED,\n                          PROTECTED_SHM_FD, 0);\n  JASSERT(addr != MAP_FAILED) (JASSERT_ERRNO)\n    .Text(\"Unable to find shared area.\");\n\n#if __arm__\n  WMB;  // Ensure store to memory by kernel mmap call has completed\n#endif\n\n  sharedDataHeader = (struct Header*) addr;\n\n  if (needToInitialize) {\n    Util::lockFile(PROTECTED_SHM_FD);\n    initializeHeader(tmpDir, installDir, compId, coordInfo, localIPAddr);\n    Util::unlockFile(PROTECTED_SHM_FD);\n  } else {\n    struct stat statbuf;\n    while (1) {\n      bool initialized = false;\n      Util::lockFile(PROTECTED_SHM_FD);\n      JASSERT(fstat(PROTECTED_SHM_FD, &statbuf) != -1) (JASSERT_ERRNO);\n      initialized = sharedDataHeader->initialized;\n      Util::unlockFile(PROTECTED_SHM_FD);\n      // If we got here, it implies that needtoinitialize was false, and\n      // so some other peer won the race and is initializing the shared data\n      // area header. The peer will set initialized last.  If initialized\n      // is true, then we're ready to go.  If initialized is false,\n      // then we will sleep a little longer and then test again inside the\n      // while loop to see if the peer has now set 'initialized'.  As a\n      // performance optimization, we could use a SysV // semaphore/condition\n      // variable, instead of sleeping and re-trying inside the loop.\n      // NOTE:  This code is correct under total store order or seq. consist.\n      //   But the relaxed consstency model, partial store order, ouuld create a\n      //   theoretically possible bug if initialized does not reach memory last.\n      if (statbuf.st_size > 0 && initialized) {\n        break;\n      }\n      struct timespec sleepTime = {0, 100*1000*1000};\n      nanosleep(&sleepTime, NULL);\n    }\n\n    Util::lockFile(PROTECTED_SHM_FD);\n    if (!Util::strStartsWith(sharedDataHeader->versionStr,\n                                    SHM_VERSION_STR)) {\n      JASSERT(false) (sharedDataHeader->versionStr) (SHM_VERSION_STR)\n        .Text(\"Wrong signature\");\n    }\n    Util::unlockFile(PROTECTED_SHM_FD);\n  }\n  JTRACE(\"Shared area mapped\") (sharedDataHeader);\n}\n\nbool SharedData::isSharedDataRegion(void *addr)\n{\n  return addr == (void*) sharedDataHeader;\n}\n\n\n// Here we reset some counters that are used by IPC plugin for local\n// name-service database, etc. during ckpt/resume/restart phases.\nvoid SharedData::prepareForCkpt()\n{\n  sharedDataHeader->numInodeConnIdMaps = 0;\n  sharedDataHeader->numIncomingConMaps = 0;\n  WMB;\n}\n\nvoid SharedData::writeCkpt()\n{\n  nextVirtualPtyId = sharedDataHeader->nextVirtualPtyId;\n}\n\nvoid SharedData::postRestart()\n{\n  initialize();\n}\n\nstring SharedData::coordHost()\n{\n  if (sharedDataHeader == NULL) initialize();\n  const struct sockaddr_in *sin =\n    (const struct sockaddr_in*) &sharedDataHeader->coordInfo.addr;\n  string remoteIP = inet_ntoa(sin->sin_addr);\n  return remoteIP;\n}\n\nuint32_t SharedData::coordPort()\n{\n  if (sharedDataHeader == NULL) initialize();\n  const struct sockaddr_in *sin =\n    (const struct sockaddr_in*) &sharedDataHeader->coordInfo.addr;\n  return ntohs(sin->sin_port);\n}\n\nstring SharedData::getTmpDir()\n{\n  if (sharedDataHeader == NULL) initialize();\n  JASSERT(sharedDataHeader->tmpDir[0] != '\\0');\n  return string(sharedDataHeader->tmpDir);\n}\n\nchar *SharedData::getTmpDir(char *buf, uint32_t len)\n{\n  if (sharedDataHeader == NULL) initialize();\n  JASSERT(sharedDataHeader->tmpDir[0] != '\\0');\n  if (len <= strlen(sharedDataHeader->tmpDir)) {\n    return NULL;\n  }\n  strcpy(buf, sharedDataHeader->tmpDir);\n  return buf;\n}\n\nstring SharedData::getInstallDir()\n{\n  if (sharedDataHeader == NULL) initialize();\n  return sharedDataHeader->installDir;\n}\n\nuint32_t SharedData::getCkptInterval()\n{\n  if (sharedDataHeader == NULL) initialize();\n  return sharedDataHeader->coordInfo.interval;\n}\n\nvoid SharedData::updateGeneration(uint32_t generation)\n{\n  if (sharedDataHeader == NULL) initialize();\n  sharedDataHeader->compId._computation_generation = generation;\n}\nDmtcpUniqueProcessId SharedData::getCompId()\n{\n  if (sharedDataHeader == NULL) initialize();\n  return sharedDataHeader->compId;\n}\n\nDmtcpUniqueProcessId SharedData::getCoordId()\n{\n  if (sharedDataHeader == NULL) initialize();\n  return sharedDataHeader->coordInfo.id;\n}\n\nuint64_t SharedData::getCoordTimeStamp()\n{\n  if (sharedDataHeader == NULL) initialize();\n  return sharedDataHeader->coordInfo.timeStamp;\n}\n\nvoid SharedData::getCoordAddr(struct sockaddr *addr, uint32_t *len)\n{\n  if (sharedDataHeader == NULL) initialize();\n  JASSERT(addr != NULL);\n  *len = sharedDataHeader->coordInfo.addrLen;\n  memcpy(addr, &sharedDataHeader->coordInfo.addr, *len);\n}\n\nvoid SharedData::setCoordHost(struct in_addr *in)\n{\n  if (sharedDataHeader == NULL) initialize();\n  JASSERT(in != NULL);\n  struct sockaddr_in *sin =\n    (struct sockaddr_in*) &sharedDataHeader->coordInfo.addr;\n  memcpy(&sin->sin_addr, in, sizeof sin->sin_addr);\n}\n\nvoid SharedData::getLocalIPAddr(struct in_addr *in)\n{\n  if (sharedDataHeader == NULL) initialize();\n  JASSERT(in != NULL);\n  memcpy(in, &sharedDataHeader->localIPAddr, sizeof *in);\n}\n\nvoid SharedData::updateDlsymOffset(int32_t dlsymOffset,\n                                   int32_t dlsymOffset_m32)\n{\n  if (sharedDataHeader == NULL) initialize();\n  JASSERT(sharedDataHeader->dlsymOffset == 0 ||\n          sharedDataHeader->dlsymOffset == dlsymOffset)\n    (dlsymOffset) (sharedDataHeader->dlsymOffset);\n\n  JASSERT(sharedDataHeader->dlsymOffset_m32 == 0 ||\n          sharedDataHeader->dlsymOffset_m32 == dlsymOffset_m32)\n    (dlsymOffset_m32) (sharedDataHeader->dlsymOffset_m32);\n  sharedDataHeader->dlsymOffset = dlsymOffset;\n  sharedDataHeader->dlsymOffset_m32 =  dlsymOffset_m32;\n}\n\nint32_t SharedData::getDlsymOffset(void)\n{\n  if (sharedDataHeader == NULL) initialize();\n  return sharedDataHeader->dlsymOffset;\n}\n\nint32_t SharedData::getDlsymOffset_m32(void)\n{\n  if (sharedDataHeader == NULL) initialize();\n  return sharedDataHeader->dlsymOffset_m32;\n}\n\npid_t SharedData::getRealPid(pid_t virt)\n{\n  pid_t res = -1;\n  if (sharedDataHeader == NULL) initialize();\n  Util::lockFile(PROTECTED_SHM_FD);\n  for (size_t i = 0; i < sharedDataHeader->numPidMaps; i++) {\n    if (sharedDataHeader->pidMap[i].virt == virt) {\n      res = sharedDataHeader->pidMap[i].real;\n    }\n  }\n  Util::unlockFile(PROTECTED_SHM_FD);\n  return res;\n}\n\nvoid SharedData::setPidMap(pid_t virt, pid_t real)\n{\n  size_t i;\n  if (sharedDataHeader == NULL) initialize();\n  Util::lockFile(PROTECTED_SHM_FD);\n  for (i = 0; i < sharedDataHeader->numPidMaps; i++) {\n    if (sharedDataHeader->pidMap[i].virt == virt) {\n      sharedDataHeader->pidMap[i].real = real;\n      break;\n    }\n  }\n  if (i == sharedDataHeader->numPidMaps) {\n    JASSERT(sharedDataHeader->numPidMaps < MAX_PID_MAPS);\n    sharedDataHeader->pidMap[i].virt = virt;\n    sharedDataHeader->pidMap[i].real = real;\n    sharedDataHeader->numPidMaps++;\n  }\n  Util::unlockFile(PROTECTED_SHM_FD);\n}\n\nint32_t SharedData::getRealIPCId(int type, int32_t virt)\n{\n  int32_t res = -1;\n  uint32_t nmaps = 0;\n  IPCIdMap *map = NULL;\n  if (sharedDataHeader == NULL) initialize();\n  Util::lockFile(PROTECTED_SHM_FD);\n  switch (type) {\n    case SYSV_SHM_ID:\n      nmaps = sharedDataHeader->numSysVShmIdMaps;\n      map = sharedDataHeader->sysvShmIdMap;\n      break;\n\n    case SYSV_SEM_ID:\n      nmaps = sharedDataHeader->numSysVSemIdMaps;\n      map = sharedDataHeader->sysvSemIdMap;\n      break;\n\n    case SYSV_MSQ_ID:\n      nmaps = sharedDataHeader->numSysVMsqIdMaps;\n      map = sharedDataHeader->sysvMsqIdMap;\n      break;\n\n    case SYSV_SHM_KEY:\n      nmaps = sharedDataHeader->numSysVShmKeyMaps;\n      map = sharedDataHeader->sysvShmKeyMap;\n      break;\n\n    default:\n      JASSERT(false) (type) .Text(\"Unknown IPC-Id type.\");\n      break;\n  }\n  for (size_t i = 0; i < nmaps; i++) {\n    if (map[i].virt == virt) {\n      res = map[i].real;\n    }\n  }\n  Util::unlockFile(PROTECTED_SHM_FD);\n  return res;\n}\n\nvoid SharedData::setIPCIdMap(int type, int32_t virt, int32_t real)\n{\n  size_t i;\n  uint64_t *nmaps = NULL;\n  IPCIdMap *map = NULL;\n  if (sharedDataHeader == NULL) initialize();\n  Util::lockFile(PROTECTED_SHM_FD);\n  switch (type) {\n    case SYSV_SHM_ID:\n      nmaps = &sharedDataHeader->numSysVShmIdMaps;\n      map = sharedDataHeader->sysvShmIdMap;\n      break;\n\n    case SYSV_SEM_ID:\n      nmaps = &sharedDataHeader->numSysVSemIdMaps;\n      map = sharedDataHeader->sysvSemIdMap;\n      break;\n\n    case SYSV_MSQ_ID:\n      nmaps = &sharedDataHeader->numSysVMsqIdMaps;\n      map = sharedDataHeader->sysvMsqIdMap;\n      break;\n\n    case SYSV_SHM_KEY:\n      nmaps = &sharedDataHeader->numSysVShmKeyMaps;\n      map = sharedDataHeader->sysvShmKeyMap;\n      break;\n\n    default:\n      JASSERT(false) (type) .Text(\"Unknown IPC-Id type.\");\n      break;\n  }\n  for (i = 0; i < *nmaps; i++) {\n    if (map[i].virt == virt) {\n      map[i].real = real;\n      break;\n    }\n  }\n  if (i == *nmaps) {\n    JASSERT(*nmaps < MAX_IPC_ID_MAPS);\n    map[i].virt = virt;\n    map[i].real = real;\n    *nmaps += 1;\n  }\n  Util::unlockFile(PROTECTED_SHM_FD);\n}\n\npid_t SharedData::getPtraceVirtualId(pid_t tracerId)\n{\n  pid_t childId = -1;\n  if (sharedDataHeader == NULL) initialize();\n  Util::lockFile(PROTECTED_SHM_FD);\n  for (size_t i = 0; i < sharedDataHeader->numPtraceIdMaps; i++) {\n    if (sharedDataHeader->ptraceIdMap[i].tracerId == tracerId) {\n      childId = sharedDataHeader->ptraceIdMap[i].childId;\n      sharedDataHeader->ptraceIdMap[i] =\n        sharedDataHeader->ptraceIdMap[sharedDataHeader->numPtraceIdMaps];\n      sharedDataHeader->numPtraceIdMaps--;\n    }\n  }\n  Util::unlockFile(PROTECTED_SHM_FD);\n  return childId;\n}\n\nvoid SharedData::setPtraceVirtualId(pid_t tracerId, pid_t childId)\n{\n  size_t i;\n  if (sharedDataHeader == NULL) initialize();\n  Util::lockFile(PROTECTED_SHM_FD);\n  for (i = 0; i < sharedDataHeader->numPtraceIdMaps; i++) {\n    if (sharedDataHeader->ptraceIdMap[i].tracerId == tracerId) {\n      break;\n    }\n  }\n\n  if (i == sharedDataHeader->numPtraceIdMaps) {\n    JASSERT(sharedDataHeader->numPtraceIdMaps < MAX_PTRACE_ID_MAPS);\n    sharedDataHeader->numPtraceIdMaps++;\n  }\n  sharedDataHeader->ptraceIdMap[i].tracerId = tracerId;\n  sharedDataHeader->ptraceIdMap[i].childId = childId;\n  Util::unlockFile(PROTECTED_SHM_FD);\n}\n\nvoid SharedData::createVirtualPtyName(const char* real, char *out, uint32_t len)\n{\n  if (sharedDataHeader == NULL) initialize();\n  JASSERT(sharedDataHeader->nextVirtualPtyId != (unsigned) -1);\n\n  Util::lockFile(PROTECTED_SHM_FD);\n  string virt = VIRT_PTS_PREFIX_STR +\n                       jalib::XToString(sharedDataHeader->nextVirtualPtyId++);\n  // FIXME: We should be removing ptys once they are gone.\n  JASSERT(sharedDataHeader->numPtyNameMaps < MAX_PTY_NAME_MAPS);\n  size_t n = sharedDataHeader->numPtyNameMaps++;\n  JASSERT(strlen(real) < PTS_PATH_MAX);\n  JASSERT(virt.length() < PTS_PATH_MAX);\n  strcpy(sharedDataHeader->ptyNameMap[n].real, real);\n  strcpy(sharedDataHeader->ptyNameMap[n].virt, virt.c_str());\n  JASSERT(len > virt.length());\n  strcpy(out, virt.c_str());\n  Util::unlockFile(PROTECTED_SHM_FD);\n}\n\nuint32_t SharedData::getVirtualPtyId()\n{\n  return sharedDataHeader->nextVirtualPtyId;\n}\n\nvoid SharedData::setVirtualPtyId(uint32_t id)\n{\n  Util::lockFile(PROTECTED_SHM_FD);\n  if (id != (uint32_t)-1 && id > sharedDataHeader->nextVirtualPtyId) {\n    sharedDataHeader->nextVirtualPtyId = id;\n  }\n  Util::unlockFile(PROTECTED_SHM_FD);\n}\n\nvoid SharedData::getRealPtyName(const char* virt, char *out, uint32_t len)\n{\n  if (sharedDataHeader == NULL) initialize();\n  *out = '\\0';\n  Util::lockFile(PROTECTED_SHM_FD);\n  for (size_t i = 0; i < sharedDataHeader->numPtyNameMaps; i++) {\n    if (strcmp(virt, sharedDataHeader->ptyNameMap[i].virt) == 0) {\n      JASSERT(strlen(sharedDataHeader->ptyNameMap[i].real) < len);\n      strcpy(out, sharedDataHeader->ptyNameMap[i].real);\n      break;\n    }\n  }\n  Util::unlockFile(PROTECTED_SHM_FD);\n}\n\nvoid SharedData::getVirtPtyName(const char* real, char *out, uint32_t len)\n{\n  if (sharedDataHeader == NULL) initialize();\n  *out = '\\0';\n  Util::lockFile(PROTECTED_SHM_FD);\n  for (size_t i = 0; i < sharedDataHeader->numPtyNameMaps; i++) {\n    if (strcmp(real, sharedDataHeader->ptyNameMap[i].real) == 0) {\n      JASSERT(strlen(sharedDataHeader->ptyNameMap[i].virt) < len);\n      strcpy(out, sharedDataHeader->ptyNameMap[i].virt);\n      break;\n    }\n  }\n  Util::unlockFile(PROTECTED_SHM_FD);\n}\n\nvoid SharedData::insertPtyNameMap(const char* virt, const char* real)\n{\n  if (sharedDataHeader == NULL) initialize();\n  Util::lockFile(PROTECTED_SHM_FD);\n  size_t n = sharedDataHeader->numPtyNameMaps++;\n  JASSERT(strlen(virt) < PTS_PATH_MAX);\n  JASSERT(strlen(real) < PTS_PATH_MAX);\n  strcpy(sharedDataHeader->ptyNameMap[n].real, real);\n  strcpy(sharedDataHeader->ptyNameMap[n].virt, virt);\n  Util::unlockFile(PROTECTED_SHM_FD);\n}\n\nvoid SharedData::registerIncomingCons(vector<const char*>& ids,\n                                     struct sockaddr_un receiverAddr,\n                                     socklen_t len)\n{\n  if (sharedDataHeader == NULL) initialize();\n  Util::lockFile(PROTECTED_SHM_FD);\n  for (size_t i = 0; i < ids.size(); i++) {\n    size_t n = sharedDataHeader->numIncomingConMaps++;\n    memcpy(sharedDataHeader->incomingConMap[n].id, ids[i], CON_ID_LEN);\n    memcpy(&sharedDataHeader->incomingConMap[n].addr, &receiverAddr, len);\n    sharedDataHeader->incomingConMap[n].len = len;\n  }\n  Util::unlockFile(PROTECTED_SHM_FD);\n}\n\nvoid SharedData::getMissingConMaps(IncomingConMap **map, uint32_t *nmaps)\n{\n  if (sharedDataHeader == NULL) initialize();\n  *map = sharedDataHeader->incomingConMap;\n  *nmaps = sharedDataHeader->numIncomingConMaps;\n}\n\nvoid SharedData::insertInodeConnIdMaps(vector<InodeConnIdMap>& maps)\n{\n  if (sharedDataHeader == NULL) initialize();\n  Util::lockFile(PROTECTED_SHM_FD);\n  size_t startIdx = sharedDataHeader->numInodeConnIdMaps;\n  sharedDataHeader->numInodeConnIdMaps += maps.size();\n  Util::unlockFile(PROTECTED_SHM_FD);\n\n  for (size_t i = 0; i < maps.size(); i++) {\n    sharedDataHeader->inodeConnIdMap[startIdx + i] = maps[i];\n  }\n}\n\nbool SharedData::getCkptLeaderForFile(dev_t devnum, ino_t inode, void *id)\n{\n  if (sharedDataHeader == NULL) initialize();\n  JASSERT(id != NULL);\n  if (sharedDataHeader->numInodeConnIdMaps > 0) {\n    for (int i = sharedDataHeader->numInodeConnIdMaps - 1; i >= 0; i--) {\n      InodeConnIdMap& map = sharedDataHeader->inodeConnIdMap[i];\n      if (map.devnum == devnum && map.inode== inode) {\n        memcpy(id, map.id, sizeof(map.id));\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nuint32_t\nSharedData::getLogMask(void)\n{\n  uint32_t logMask = jassert_internal::JTRACE;\n  if (initialized()) {\n    logMask |= sharedDataHeader->logMask;\n  }\n  return logMask;\n}\n\nvoid\nSharedData::setLogMask(uint32_t mask)\n{\n  if (initialized()) {\n    initialize();\n  }\n  Util::lockFile(PROTECTED_SHM_FD);\n  sharedDataHeader->logMask = mask;\n  Util::unlockFile(PROTECTED_SHM_FD);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/src/syscallsreal.c": "/****************************************************************************\n *   Copyright (C) 2006-2010 by Jason Ansel, Kapil Arya, and Gene Cooperman *\n *   jansel@csail.mit.edu, kapil@ccs.neu.edu, gene@ccs.neu.edu              *\n *                                                                          *\n *  This file is part of DMTCP.                                             *\n *                                                                          *\n *  DMTCP is free software: you can redistribute it and/or                  *\n *  modify it under the terms of the GNU Lesser General Public License as   *\n *  published by the Free Software Foundation, either version 3 of the      *\n *  License, or (at your option) any later version.                         *\n *                                                                          *\n *  DMTCP is distributed in the hope that it will be useful,                *\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of          *\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *\n *  GNU Lesser General Public License for more details.                     *\n *                                                                          *\n *  You should have received a copy of the GNU Lesser General Public        *\n *  License along with DMTCP:dmtcp/src.  If not, see                        *\n *  <http://www.gnu.org/licenses/>.                                         *\n ****************************************************************************/\n\n#define _GNU_SOURCE\n#define _XOPEN_SOURCE 500\n// These next two are defined in features.h based on the user macros above.\n// #define GNU_SRC\n// #define __USE_UNIX98\n\n// FIXME:  See comment in syscallsreal.h about how to remove the need for\n//         this extra declaration.\n#define FOR_SYSCALLSREAL_C\n\n#include <assert.h>\n#include <ctype.h>\n#include <dlfcn.h>\n#include <fcntl.h>\n#include <malloc.h>\n#include <poll.h>\n#include <pthread.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/select.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#include <sys/types.h>\n#include <sys/syscall.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include \"constants.h\"\n#include \"dmtcp_dlsym.h\"\n#include \"syscallwrappers.h\"\n#include \"trampolines.h\"\n\ntypedef int (*funcptr_t) ();\ntypedef pid_t (*funcptr_pid_t) ();\ntypedef funcptr_t (*signal_funcptr_t) ();\n\nstatic pthread_mutex_t theMutex = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;\n\n// gettid / tkill / tgkill are not defined in libc.\nLIB_PRIVATE pid_t dmtcp_gettid() {\n  return _real_syscall(SYS_gettid);\n}\nLIB_PRIVATE int dmtcp_tkill(int tid, int sig) {\n  return _real_syscall(SYS_tkill, tid, sig);\n}\nLIB_PRIVATE int dmtcp_tgkill(int tgid, int tid, int sig) {\n  return _real_syscall(SYS_tgkill, tgid, tid, sig);\n}\n\n// FIXME: Are these primitives (_dmtcp_lock, _dmtcp_unlock) required anymore?\nvoid _dmtcp_lock() { _real_pthread_mutex_lock (&theMutex); }\nvoid _dmtcp_unlock() { _real_pthread_mutex_unlock (&theMutex); }\n\nvoid _dmtcp_remutex_on_fork() {\n  pthread_mutexattr_t attr;\n  pthread_mutexattr_init(&attr);\n  pthread_mutexattr_settype(&attr, PTHREAD_MUTEX_RECURSIVE_NP);\n  pthread_mutex_init (&theMutex, &attr);\n  pthread_mutexattr_destroy(&attr);\n}\n/*\n * DMTCP puts wrappers around several libc (also libpthread, libdl etc.)\n * functions in order to work. In these wrappers, DMTCP has to do some work\n * before and after the real function is called in libc.\n *\n * In order to call the real function in libc, DMTCP calculates the address of\n * the function in libc and calls that address directly. There are several\n * techniques of calculating the address of the libc function. In this\n * document, we briefly discuss the techniques that DMTCP has used in past and\n * how it evolved into the current design.\n *\n * History:\n * 1. dlopen/dlsym: Once upon a time :-), DMTCP used to dlopen \"libc.so\" and\n *    then call dlsym() on the libc handle to find the addresses of the libc\n *    functions wrapped by DMTCP.\n *\n * This worked great for a while until we needed wrappers for\n * malloc/calloc/free, etc. The reason was the fact that dlopen/dlsym/dlerror\n * internally call calloc to allocate a small buffer. As can be seen, dlopen\n * calls calloc which * goes to the DMTCP wrapper for calloc, which in turn\n * needs to call dlopen() to find the address of libc calloc and so this goes\n * into an infinite recursion.\n *\n * 2a. Libc-offsets - take 1: To counter the problems related to malloc/calloc\n *     wrappers, DMTCP was modified to not use dlopen/dlsym. Instead, a new\n *     mechanism was implemented.\n *\n *     While executing dmtcp_launch, for each function wrapped by DMTCP, we\n *     calculated it's offset, in libc, from a known base-function (toupper, a\n *     function not wrapped by DMTCP) in libc, i.e. we do:\n *       open_offset = &open - &toupper;\n *     The offsets were passed along to libdmtcp.so in an environment\n *     variable. To calculate the address of libc function now becomes very\n *     easy -- calculate the address of base-function, and add to it the offset\n *     of the required function i.e.\n *       open_libc_address = &toupper + open_offset;\n *\n *     The environment variable holding the offsets was made available to each\n *     and every new process created via fork/exec.\n *\n * This worked fine until we discovered that some applications put a wrapper\n * around toupper as well :(.\n *\n * 2b. Libc-offsets - take 2:2b. Libc-offsets - take 2: In the next iteration,\n *     we decided to use a heuristic based approach of using a pool of libc\n *     base-functions instead of just one. An average address of base-functions\n *     was calculated and that was used in offset calculations.\n *\n * This approach was fine until we decided to support process migration. If a\n * process is migrated to a different machine with a different version of libc,\n * the offsets that are stored in memory aren't correct anymore and so if the\n * migrated process creates a child process, the offsets won't work.\n *\n * 3. dlsym(RTLD_NEXT, symbol): This is the current approach. In the _real_XYZ\n *    function, we call dlsym(RTLD_NEXT, \"XYZ\") to calculate the address of\n *    function in the libraries that come after the current library in the\n *    search order (see man dlsym for more details).\n *\n * There are three problems with this scheme:\n * a) As with scheme 1 (dlopen/dlsym) -- if there are wrappers around\n *    calloc/free, it goes into an infinite recursion, and\n * b) Even if we don't have wrappers around calloc, there can be a problem if\n *     some application uses the malloc_hooks.\n *     (see http://www.gnu.org/s/hello/manual/libc/Hooks-for-Malloc.html).\n *     One notable example is libopen-pal.so (part of Open MPI) which uses\n *     malloc_hooks and in the malloc hook, it called xstat() which landed in\n *     the DMTCP wrapper for xstat() and hence an infinite recursive loop.\n * c) Certain libpthread symbols are also defined in libc. For example, 'nm\n *    libc.so' reveals that 'pthread_cond_broadcast', 'pthread_cond_signal',\n *    and others are defined in libc.so. Thus, depending on the library load\n *    order, RTLD_NEXT might instead resolve to the libc version, which has\n *    been shown to cause problems (e.g. in the FReD record-replay plugin,\n *    which has wrappers around those functions).\n *\n * The work around to these problems is described in the following section.\n *\n * ***************************************************************************\n *\n * Current Workaround:\n *\n * In order to deal with the situation where we have malloc/calloc wrappers and\n * a potential application with malloc_hooks, we need to do the following:\n *\n * 0. Initialize all wrappers (calculate libc addr) before DMTCP does anything\n *    else i.e. do it at the beginning of the DmtcpWorker constructor.\n * 1. Define a variable dmtcp_wrappers_initializing, which is set to '1' while\n *    it is initializing and '0' after the * initialization has completed.\n * 2. Always have wrappers for malloc/calloc/free.\n * 3. In the wrappers for malloc/calloc/free, make sure that malloc hooks are\n *    never called. One way to do this is to disable malloc_hooks, but since\n *    they are not thread-safe, this is not a desired solution. Also note that\n *    malloc hooks have been deprecated in glibc 2.14 and will be removed in\n *    glibc 2.15.\n *\n *    Another way to avoid malloc hooks is to allocate memory using JALLOC to\n *    avoid calling libc:malloc. But we don't want to do this for all\n *    malloc/calloc calls, and so the call to JALLOC should be made only if\n *    dmtcp_wrappers_initializing is set to '1'.\n *\n *    There is a problem with the JALLOC approach too when using RECORD_REPLAY.\n *    RECORD_REPLAY puts wrappers around mmap() etc. and JALLOC uses mmap() to\n *    allocate memory :-(and as one can guess, it gets into a infinite\n *    recursion.\n * 4. The solution is to use static buffer when dlsym() calls calloc() during\n *    wrapper-initialization. It was noted that, calloc() is called only once\n *    with buf-size of 32, during dlsym() execution and thus it is safe to keep\n *    a small static buffer and pass on its address to the caller. The\n *    subsequent call to free() is ignored.\n *\n * In order to deal with the fact that libc.so contains some definition of\n * several pthread_* functions, we do the following. In initializing the\n * libpthread wrappers, we explicitly call dlopen() on libpthread.so. Then we\n * are guaranteed to resolve the symbol to the correct libpthread symbol.\n *\n * This solution is imperfect: if the user program also defines wrappers for\n * these functions, then using dlopen()/dlsym() explicitly on libpthread will\n * cause the user wrappers to be skipped. We have not yet run into a program\n * which does this, but it may occur in the future.\n *\n * ***************************************************************************\n * ***************************************************************************\n *\n * Update: Using the pthread_getspecific wrapper\n *   dlsym() uses pthread_getspecific to find a thread local buffer. On the\n *   very first call pthread_getspecific() return NULL. The dlsym function then\n *   calls calloc to allocate a buffer, followed by a call to\n *   pthread_setspecific. Any subsequent pthread_getspecific calls would return\n *   the buffer allocated earlier.\n *\n *   We put a wrapper around pthread_getspecific and return a static buffer to\n *   dlsym() on the very first call. This allows us to proceed further without\n *   having to worry about the calloc wrapper.\n *\n * Update: Using dmtcp_dlsym()\n *   The use of dmtcp_dlsym() to resolve symbols for wrappers within DMTCP allows\n *   us to avoid all of the problems and their workarounds as described above.\n *\n */\n\n#if TRACK_DLOPEN_DLSYM_FOR_LOCKS\nLIB_PRIVATE void dmtcp_setThreadPerformingDlopenDlsym();\nLIB_PRIVATE void dmtcp_unsetThreadPerformingDlopenDlsym();\n#endif\n\nstatic void *_real_func_addr[numLibcWrappers];\nstatic int dmtcp_wrappers_initialized = 0;\n\n#define GET_FUNC_ADDR(name) \\\n  _real_func_addr[ENUM(name)] = dmtcp_dlsym(RTLD_NEXT, #name);\n\nstatic void initialize_libc_wrappers()\n{\n  FOREACH_DMTCP_WRAPPER(GET_FUNC_ADDR);\n#ifdef __i386__\n  /* On i386 systems, there are two pthread_create symbols. We want the one\n   * with GLIBC_2.1 version. On 64-bit machines, there is only one\n   * pthread_create symbol (GLIBC_2.2.5), so no worries there.\n   */\n  _real_func_addr[ENUM(pthread_create)] = dmtcp_dlvsym(RTLD_NEXT,\n                                                       \"pthread_create\",\n                                                       \"GLIBC_2.1\");\n#endif\n\n  /* On some arm machines, the newest pthread_create has version GLIBC_2.4 */\n  void *addr = dmtcp_dlvsym(RTLD_NEXT, \"pthread_create\", \"GLIBC_2.4\");\n  if (addr != NULL) {\n    _real_func_addr[ENUM(pthread_create)] = addr;\n  }\n}\n\n#ifdef ENABLE_PTHREAD_COND_WRAPPERS\n# define GET_LIBPTHREAD_FUNC_ADDR(name) \\\n  _real_func_addr[ENUM(name)] = dlvsym(RTLD_NEXT, #name, pthread_sym_ver);\n\n/*\n * WARNING: By using this method to initialize libpthread wrappers (direct\n * dlopen()/dlsym()) we are are overriding any user wrappers for these\n * functions. If this is a problem in the future we need to think of a new way\n * to do this.\n * EDIT: On some ARM machines, the symbol version is 2.4. Try that first and\n *       fallback to 2.3.4 on failure.\n */\nstatic void initialize_libpthread_wrappers()\n{\n  const char *ver_2_4 = \"GLIBC_2.4\";\n  const char *ver_2_3_2 = \"GLIBC_2.3.2\";\n  const char *pthread_sym_ver = NULL;\n\n  void *addr = dmtcp_dlvsym(RTLD_NEXT, \"pthread_cond_signal\", ver_2_4);\n  if (addr != NULL) {\n    pthread_sym_ver = ver_2_4;\n  } else {\n    pthread_sym_ver = ver_2_3_2;\n  }\n\n  FOREACH_LIBPTHREAD_WRAPPERS(GET_LIBPTHREAD_FUNC_ADDR);\n}\n#endif // #ifdef ENABLE_PTHREAD_COND_WRAPPERS\n\nvoid dmtcp_prepare_wrappers(void)\n{\n  if (!dmtcp_wrappers_initialized) {\n    initialize_libc_wrappers();\n    dmtcp_wrappers_initialized = 1;\n#ifdef ENABLE_PTHREAD_COND_WRAPPERS\n    initialize_libpthread_wrappers();\n#endif // #ifdef ENABLE_PTHREAD_COND_WRAPPERS\n  }\n}\n\n//////////////////////////\n//// FIRST DEFINE REAL VERSIONS OF NEEDED FUNCTIONS\n\n#define REAL_FUNC_PASSTHROUGH(name)  REAL_FUNC_PASSTHROUGH_TYPED(int, name)\n\n#define REAL_FUNC_PASSTHROUGH_WORK(name) \\\n  if (fn == NULL) { \\\n    if (_real_func_addr[ENUM(name)] == NULL) dmtcp_initialize(); \\\n    fn = _real_func_addr[ENUM(name)]; \\\n    if (fn == NULL) { \\\n      fprintf(stderr, \"*** DMTCP: Error: lookup failed for %s.\\n\" \\\n                      \"           The symbol wasn't found in current library\" \\\n                      \" loading sequence.\\n\" \\\n                      \"    Aborting.\\n\", #name); \\\n      abort(); \\\n    } \\\n  }\n\n#define REAL_FUNC_PASSTHROUGH_TYPED(type,name) \\\n  static type (*fn)() = NULL;                  \\\n  REAL_FUNC_PASSTHROUGH_WORK(name)             \\\n  return (*fn)\n\n#define REAL_FUNC_PASSTHROUGH_VOID(name) \\\n  static void (*fn)() = NULL;            \\\n  REAL_FUNC_PASSTHROUGH_WORK(name)       \\\n  (*fn)\n\n#define REAL_FUNC_PASSTHROUGH_NORETURN(name)                 \\\n  static void (*fn)() __attribute__ ((__noreturn__)) = NULL; \\\n  REAL_FUNC_PASSTHROUGH_WORK(name)                           \\\n  (*fn)\n\ntypedef void* (*dlsym_fnptr_t) (void *handle, const char *symbol);\nvoid *dmtcp_get_libc_dlsym_addr(void);\n\nLIB_PRIVATE\nvoid *_real_dlsym (void *handle, const char *symbol) {\n  static dlsym_fnptr_t _libc_dlsym_fnptr = NULL;\n  if (_libc_dlsym_fnptr == NULL) {\n    _libc_dlsym_fnptr = dmtcp_dlsym;\n  }\n\n#if TRACK_DLOPEN_DLSYM_FOR_LOCKS\n  // Avoid calling WRAPPER_EXECUTION_DISABLE_CKPT() in calloc() wrapper. See\n  // comment in miscwrappers for more details.\n  // EDIT: Now that we are using pthread_getspecific trick, calloc will not be\n  // called and so we do not need to disable locking for calloc.\n  dmtcp_setThreadPerformingDlopenDlsym();\n#endif\n  void *res = (*_libc_dlsym_fnptr) (handle, symbol);\n#if TRACK_DLOPEN_DLSYM_FOR_LOCKS\n  dmtcp_unsetThreadPerformingDlopenDlsym();\n#endif\n  return res;\n}\n\n/* In libdmtcp.so code always use this function instead of unsetenv.\n * Bash has its own implementation of getenv/setenv/unsetenv and keeps its own\n * environment equivalent to its shell variables. If DMTCP uses the bash\n * unsetenv, bash will unset its internal environment variable but won't remove\n * the process environment variable and yet on the next getenv, bash will\n * return the process environment variable.\n * This is arguably a bug in bash-3.2.\n */\nLIB_PRIVATE\nint _dmtcp_unsetenv(const char *name) {\n  unsetenv (name);\n  // One can fix this by doing a getenv() here and put a '\\0' byte\n  // at the start of the returned value, but that is not correct as if you do\n  // another getenv after this, it would return \"\", which is not the same as\n  // NULL.\n  REAL_FUNC_PASSTHROUGH (unsetenv) (name);\n}\n\nLIB_PRIVATE\nvoid *_real_dlopen(const char *filename, int flag) {\n  REAL_FUNC_PASSTHROUGH_TYPED (void*, dlopen) (filename, flag);\n}\n\nLIB_PRIVATE\nint _real_dlclose(void *handle) {\n  REAL_FUNC_PASSTHROUGH_TYPED (int, dlclose) (handle);\n}\n\nLIB_PRIVATE\nint _real_pthread_mutex_lock(pthread_mutex_t *mutex) {\n  REAL_FUNC_PASSTHROUGH_TYPED (int,pthread_mutex_lock) (mutex);\n}\n\nLIB_PRIVATE\nint _real_pthread_mutex_trylock(pthread_mutex_t *mutex) {\n  REAL_FUNC_PASSTHROUGH_TYPED (int,pthread_mutex_trylock) (mutex);\n}\n\nLIB_PRIVATE\nint _real_pthread_mutex_unlock(pthread_mutex_t *mutex) {\n  REAL_FUNC_PASSTHROUGH_TYPED (int,pthread_mutex_unlock) (mutex);\n}\n\nLIB_PRIVATE\nint _real_pthread_rwlock_unlock(pthread_rwlock_t *rwlock) {\n  REAL_FUNC_PASSTHROUGH_TYPED (int,pthread_rwlock_unlock) (rwlock);\n}\n\nLIB_PRIVATE\nint _real_pthread_rwlock_rdlock(pthread_rwlock_t *rwlock) {\n  REAL_FUNC_PASSTHROUGH_TYPED (int,pthread_rwlock_rdlock) (rwlock);\n}\n\nLIB_PRIVATE\nint _real_pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock) {\n  REAL_FUNC_PASSTHROUGH_TYPED (int,pthread_rwlock_tryrdlock) (rwlock);\n}\n\nLIB_PRIVATE\nint _real_pthread_rwlock_wrlock(pthread_rwlock_t *rwlock) {\n  REAL_FUNC_PASSTHROUGH_TYPED (int,pthread_rwlock_wrlock) (rwlock);\n}\n\nLIB_PRIVATE\nint _real_pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock) {\n  REAL_FUNC_PASSTHROUGH_TYPED (int,pthread_rwlock_trywrlock) (rwlock);\n}\n\n#ifdef ENABLE_PTHREAD_COND_WRAPPERS\nLIB_PRIVATE\nint _real_pthread_cond_broadcast(pthread_cond_t *cond)\n{\n#if __aarch64__\n  int result = NEXT_FNC_DEFAULT(pthread_cond_broadcast)(cond);\n  return result;\n#else\n  REAL_FUNC_PASSTHROUGH_TYPED (int,pthread_cond_broadcast) (cond);\n#endif\n}\n\nLIB_PRIVATE\nint _real_pthread_cond_destroy(pthread_cond_t *cond)\n{\n#if __aarch64__\n  int result = NEXT_FNC_DEFAULT(pthread_cond_destroy)(cond);\n  return result;\n#else\n  REAL_FUNC_PASSTHROUGH_TYPED (int,pthread_cond_destroy) (cond);\n#endif\n}\n\nLIB_PRIVATE\nint _real_pthread_cond_init(pthread_cond_t *cond,\n                            const pthread_condattr_t *attr)\n{\n#if __aarch64__\n  int result = NEXT_FNC_DEFAULT(pthread_cond_init)(cond,attr);\n  return result;\n#else\n  REAL_FUNC_PASSTHROUGH_TYPED (int,pthread_cond_init) (cond,attr);\n#endif\n}\n\nLIB_PRIVATE\nint _real_pthread_cond_signal(pthread_cond_t *cond)\n{\n#if __aarch64__\n  int result = NEXT_FNC_DEFAULT(pthread_cond_signal)(cond);\n  return result;\n#else\n  REAL_FUNC_PASSTHROUGH_TYPED (int,pthread_cond_signal) (cond);\n#endif\n}\n\nLIB_PRIVATE\nint _real_pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex,\n                                 const struct timespec *abstime)\n{\n#if __aarch64__\n  int result = NEXT_FNC_DEFAULT(pthread_cond_timedwait)(cond, mutex, abstime);\n  return result;\n#else\n  REAL_FUNC_PASSTHROUGH_TYPED (int,pthread_cond_timedwait) (cond,mutex,abstime);\n#endif\n}\n\nLIB_PRIVATE\nint _real_pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex)\n{\n#if __aarch64__\n  int result = NEXT_FNC_DEFAULT(pthread_cond_wait)(cond,mutex);\n  return result;\n#else\n  REAL_FUNC_PASSTHROUGH_TYPED (int,pthread_cond_wait) (cond,mutex);\n#endif\n}\n#endif // #ifdef ENABLE_PTHREAD_COND_WRAPPERS\n\nLIB_PRIVATE\nssize_t _real_read(int fd, void *buf, size_t count) {\n  REAL_FUNC_PASSTHROUGH (read) (fd,buf,count);\n}\n\nLIB_PRIVATE\nssize_t _real_write(int fd, const void *buf, size_t count) {\n  REAL_FUNC_PASSTHROUGH_TYPED (ssize_t,write) (fd,buf,count);\n}\n\nLIB_PRIVATE\nint _real_select(int nfds, fd_set *readfds, fd_set *writefds,\n                 fd_set *exceptfds, struct timeval *timeout) {\n  REAL_FUNC_PASSTHROUGH (select) (nfds,readfds,writefds,exceptfds,timeout);\n}\n\nLIB_PRIVATE\nint _real_socket (int domain, int type, int protocol)\n{\n  REAL_FUNC_PASSTHROUGH (socket) (domain,type,protocol);\n}\n\nLIB_PRIVATE\nint _real_connect (int sockfd, const struct sockaddr *serv_addr,\n                    socklen_t addrlen)\n{\n  REAL_FUNC_PASSTHROUGH (connect) (sockfd,serv_addr,addrlen);\n}\n\nLIB_PRIVATE\nint _real_bind (int sockfd, const struct sockaddr *my_addr,\n                 socklen_t addrlen)\n{\n  REAL_FUNC_PASSTHROUGH (bind) (sockfd,my_addr,addrlen);\n}\n\nLIB_PRIVATE\nint _real_listen (int sockfd, int backlog)\n{\n  REAL_FUNC_PASSTHROUGH (listen) (sockfd,backlog);\n}\n\nLIB_PRIVATE\nint _real_accept (int sockfd, struct sockaddr *addr, socklen_t *addrlen)\n{\n  REAL_FUNC_PASSTHROUGH (accept) (sockfd,addr,addrlen);\n}\n\nLIB_PRIVATE\nint _real_accept4 (int sockfd, struct sockaddr *addr, socklen_t *addrlen,\n                    int flags)\n{\n  REAL_FUNC_PASSTHROUGH (accept4) (sockfd,addr,addrlen,flags);\n}\n\nLIB_PRIVATE\nint _real_setsockopt (int s, int level, int optname, const void *optval,\n                       socklen_t optlen)\n{\n  REAL_FUNC_PASSTHROUGH (setsockopt) (s,level,optname,optval,optlen);\n}\n\nLIB_PRIVATE\nint _real_getsockopt (int s, int level, int optname, void *optval,\n                       socklen_t *optlen)\n{\n  REAL_FUNC_PASSTHROUGH (getsockopt) (s,level,optname,optval,optlen);\n}\n\nLIB_PRIVATE\nint _real_fexecve (int fd, char *const argv[], char *const envp[])\n{\n  REAL_FUNC_PASSTHROUGH (fexecve) (fd,argv,envp);\n}\n\nLIB_PRIVATE\nint _real_execve (const char *filename, char *const argv[],\n                   char *const envp[])\n{\n  REAL_FUNC_PASSTHROUGH (execve) (filename,argv,envp);\n}\n\nLIB_PRIVATE\nint _real_execv (const char *path, char *const argv[])\n{\n  REAL_FUNC_PASSTHROUGH (execv) (path,argv);\n}\n\nLIB_PRIVATE\nint _real_execvp (const char *file, char *const argv[])\n{\n  REAL_FUNC_PASSTHROUGH (execvp) (file,argv);\n}\nLIB_PRIVATE\nint _real_execvpe(const char *file, char *const argv[], char *const envp[]) {\n  REAL_FUNC_PASSTHROUGH (execvpe) (file, argv, envp);\n}\n\nLIB_PRIVATE\nint _real_system (const char *cmd)\n{\n  REAL_FUNC_PASSTHROUGH (system) (cmd);\n}\n\nLIB_PRIVATE\nFILE *_real_popen(const char *command, const char *mode) {\n  REAL_FUNC_PASSTHROUGH_TYPED (FILE*, popen) (command, mode);\n}\n\nLIB_PRIVATE\nint _real_pclose(FILE *fp) {\n  REAL_FUNC_PASSTHROUGH(pclose) (fp);\n}\n\nLIB_PRIVATE\npid_t _real_fork(void)\n{\n  REAL_FUNC_PASSTHROUGH_TYPED (pid_t, fork) ();\n}\n\nLIB_PRIVATE\nint _real_close (int fd)\n{\n  REAL_FUNC_PASSTHROUGH (close) (fd);\n}\n\nLIB_PRIVATE\nint _real_fclose (FILE *fp)\n{\n  REAL_FUNC_PASSTHROUGH (fclose) (fp);\n}\n\nLIB_PRIVATE\nint _real_dup (int oldfd)\n{\n  REAL_FUNC_PASSTHROUGH (dup) (oldfd);\n}\n\nLIB_PRIVATE\nint _real_dup2 (int oldfd, int newfd)\n{\n  REAL_FUNC_PASSTHROUGH (dup2) (oldfd, newfd);\n}\n\nLIB_PRIVATE\nint _real_dup3 (int oldfd, int newfd, int flags)\n{\n  REAL_FUNC_PASSTHROUGH (dup3) (oldfd, newfd, flags);\n}\n\nLIB_PRIVATE\nvoid _real_exit (int status)\n{\n  REAL_FUNC_PASSTHROUGH_VOID (exit) (status);\n}\n\nLIB_PRIVATE\nint _real_fcntl(int fd, int cmd, void *arg)\n{\n  REAL_FUNC_PASSTHROUGH (fcntl) (fd, cmd, arg);\n}\n\nLIB_PRIVATE\nint _real_getpt (void)\n{\n  REAL_FUNC_PASSTHROUGH (getpt) ();\n}\n\nLIB_PRIVATE\nint _real_posix_openpt (int flags)\n{\n  REAL_FUNC_PASSTHROUGH (posix_openpt) (flags);\n}\n\nLIB_PRIVATE\nint _real_ptsname_r (int fd, char * buf, size_t buflen)\n{\n  REAL_FUNC_PASSTHROUGH (ptsname_r) (fd, buf, buflen);\n}\n\nint _real_ttyname_r (int fd, char * buf, size_t buflen)\n{\n  REAL_FUNC_PASSTHROUGH (ttyname_r) (fd, buf, buflen);\n}\n\nLIB_PRIVATE\nint _real_socketpair (int d, int type, int protocol, int sv[2])\n{\n  REAL_FUNC_PASSTHROUGH (socketpair) (d,type,protocol,sv);\n}\n\nLIB_PRIVATE\nvoid _real_openlog (const char *ident, int option, int facility)\n{\n  REAL_FUNC_PASSTHROUGH_VOID (openlog) (ident,option,facility);\n}\n\nLIB_PRIVATE\nvoid _real_closelog (void)\n{\n  REAL_FUNC_PASSTHROUGH_VOID (closelog) ();\n}\n\n//set the handler\nLIB_PRIVATE\nsighandler_t _real_signal(int signum, sighandler_t handler) {\n  REAL_FUNC_PASSTHROUGH_TYPED (sighandler_t, signal) (signum, handler);\n}\nLIB_PRIVATE\nint _real_sigaction(int signum, const struct sigaction *act, struct sigaction *oldact) {\n  REAL_FUNC_PASSTHROUGH (sigaction) (signum, act, oldact);\n}\n\n#if !__GLIBC_PREREQ(2,21)\nLIB_PRIVATE\nint _real_sigvec(int signum, const struct sigvec *vec, struct sigvec *ovec) {\n  REAL_FUNC_PASSTHROUGH (sigvec) (signum, vec, ovec);\n}\n#endif\n\n//set the mask\nLIB_PRIVATE\nint _real_sigblock(int mask) {\n  REAL_FUNC_PASSTHROUGH (sigblock) (mask);\n}\nLIB_PRIVATE\nint _real_sigsetmask(int mask) {\n  REAL_FUNC_PASSTHROUGH (sigsetmask) (mask);\n}\nLIB_PRIVATE\nint _real_siggetmask(void) {\n  REAL_FUNC_PASSTHROUGH (siggetmask)();\n}\nLIB_PRIVATE\nint _real_sigprocmask(int how, const sigset_t *a, sigset_t *b) {\n  REAL_FUNC_PASSTHROUGH (sigprocmask) (how, a, b);\n}\nLIB_PRIVATE\nint _real_pthread_sigmask(int how, const sigset_t *a, sigset_t *b) {\n  REAL_FUNC_PASSTHROUGH_TYPED (int, pthread_sigmask) (how, a, b);\n}\n\nLIB_PRIVATE\nvoid *_real_pthread_getspecific(pthread_key_t key)\n{\n  REAL_FUNC_PASSTHROUGH_TYPED(void*, pthread_getspecific)(key);\n}\n\nLIB_PRIVATE\nint _real_sigsuspend(const sigset_t *mask) {\n  REAL_FUNC_PASSTHROUGH (sigsuspend) (mask);\n}\nLIB_PRIVATE\nsighandler_t _real_sigset(int sig, sighandler_t disp)\n{\n  REAL_FUNC_PASSTHROUGH_TYPED (sighandler_t, sigset) (sig, disp);\n}\nLIB_PRIVATE\nint _real_sighold(int sig) {\n  REAL_FUNC_PASSTHROUGH (sighold) (sig);\n}\nLIB_PRIVATE\nint _real_sigignore(int sig) {\n  REAL_FUNC_PASSTHROUGH (sigignore) (sig);\n}\n// See 'man sigpause':  signal.h defines two possible versions for sigpause.\nLIB_PRIVATE\nint _real__sigpause(int __sig_or_mask, int __is_sig) {\n  REAL_FUNC_PASSTHROUGH (__sigpause) (__sig_or_mask, __is_sig);\n}\nLIB_PRIVATE\nint _real_sigpause(int sig) {\n  REAL_FUNC_PASSTHROUGH (sigpause) (sig);\n}\nLIB_PRIVATE\nint _real_sigrelse(int sig) {\n  REAL_FUNC_PASSTHROUGH (sigrelse) (sig);\n}\n\nLIB_PRIVATE\nint _real_sigwait(const sigset_t *set, int *sig) {\n  REAL_FUNC_PASSTHROUGH (sigwait) (set, sig);\n}\nLIB_PRIVATE\nint _real_sigwaitinfo(const sigset_t *set, siginfo_t *info) {\n  REAL_FUNC_PASSTHROUGH (sigwaitinfo) (set, info);\n}\nLIB_PRIVATE\nint _real_sigtimedwait(const sigset_t *set, siginfo_t *info,\n                       const struct timespec *timeout) {\n  REAL_FUNC_PASSTHROUGH (sigtimedwait) (set, info, timeout);\n}\n\nLIB_PRIVATE\nint _real_open(const char *pathname, int flags, ...) {\n  mode_t mode = 0;\n  // Handling the variable number of arguments\n  if (flags & O_CREAT) {\n    va_list arg;\n    va_start (arg, flags);\n    mode = va_arg (arg, int);\n    va_end (arg);\n  }\n  REAL_FUNC_PASSTHROUGH (open) (pathname, flags, mode);\n}\n\nLIB_PRIVATE\nint _real_waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options) {\n  REAL_FUNC_PASSTHROUGH (waitid) (idtype, id, infop, options);\n}\n\nLIB_PRIVATE\npid_t _real_wait4(pid_t pid, __WAIT_STATUS status, int options,\n                  struct rusage *rusage) {\n  REAL_FUNC_PASSTHROUGH_TYPED (pid_t, wait4) (pid, status, options, rusage);\n}\n\nLIB_PRIVATE\nint _real_open64(const char *pathname, int flags, ...) {\n  mode_t mode = 0;\n  // Handling the variable number of arguments\n  if (flags & O_CREAT) {\n    va_list arg;\n    va_start (arg, flags);\n    mode = va_arg (arg, int);\n    va_end (arg);\n  }\n  REAL_FUNC_PASSTHROUGH (open) (pathname, flags, mode);\n}\n\nLIB_PRIVATE\nFILE * _real_fopen(const char *path, const char *mode) {\n  REAL_FUNC_PASSTHROUGH_TYPED (FILE *, fopen) (path, mode);\n}\n\nLIB_PRIVATE\nFILE * _real_fopen64(const char *path, const char *mode) {\n  REAL_FUNC_PASSTHROUGH_TYPED (FILE *, fopen64) (path, mode);\n}\n\nLIB_PRIVATE\nint _real_openat(int dirfd, const char *pathname, int flags, mode_t mode) {\n  REAL_FUNC_PASSTHROUGH (openat) (dirfd, pathname, flags, mode);\n}\n\nLIB_PRIVATE\nint _real_openat64(int dirfd, const char *pathname, int flags, mode_t mode) {\n  REAL_FUNC_PASSTHROUGH (openat64) (dirfd, pathname, flags, mode);\n}\n\nLIB_PRIVATE\nDIR* _real_opendir(const char *name) {\n  REAL_FUNC_PASSTHROUGH_TYPED (DIR*, opendir) (name);\n}\n\nLIB_PRIVATE\nint _real_closedir(DIR *dir) {\n  REAL_FUNC_PASSTHROUGH (closedir) (dir);\n}\n\nLIB_PRIVATE\nint _real_setrlimit(int resource, const struct rlimit *rlim) {\n  REAL_FUNC_PASSTHROUGH (setrlimit) (resource, rlim);\n}\n\nLIB_PRIVATE\nint _real_mkstemp(char *template) {\n  REAL_FUNC_PASSTHROUGH (mkstemp) (template);\n}\n\n/* See comments for syscall wrapper */\nLIB_PRIVATE\nlong _real_syscall(long sys_num, ...) {\n  int i;\n  void * arg[7];\n  va_list ap;\n\n  va_start(ap, sys_num);\n  for (i = 0; i < 7; i++)\n    arg[i] = va_arg(ap, void *);\n  va_end(ap);\n\n  // /usr/include/unistd.h says syscall returns long int (contrary to man page)\n  REAL_FUNC_PASSTHROUGH_TYPED (long, syscall) (sys_num, arg[0], arg[1],\n                                               arg[2], arg[3], arg[4],\n                                               arg[5], arg[6]);\n}\n\nLIB_PRIVATE\nint _real_xstat(int vers, const char *path, struct stat *buf) {\n  REAL_FUNC_PASSTHROUGH (__xstat) (vers, path, buf);\n}\n\nLIB_PRIVATE\nint _real_xstat64(int vers, const char *path, struct stat64 *buf) {\n  REAL_FUNC_PASSTHROUGH (__xstat64) (vers, path, buf);\n}\n\nLIB_PRIVATE\nint _real_lxstat(int vers, const char *path, struct stat *buf) {\n  REAL_FUNC_PASSTHROUGH (__lxstat) (vers, path, buf);\n}\n\nLIB_PRIVATE\nint _real_lxstat64(int vers, const char *path, struct stat64 *buf) {\n  REAL_FUNC_PASSTHROUGH (__lxstat64) (vers, path, buf);\n}\n\nLIB_PRIVATE\nssize_t _real_readlink(const char *path, char *buf, size_t bufsiz) {\n  REAL_FUNC_PASSTHROUGH_TYPED (ssize_t, readlink) (path, buf, bufsiz);\n}\n\nLIB_PRIVATE\nint _real_clone (int (*function) (void *), void *child_stack, int flags, void *arg, int *parent_tidptr, struct user_desc *newtls, int *child_tidptr)\n{\n  REAL_FUNC_PASSTHROUGH (__clone) (function, child_stack, flags, arg,\n                                      parent_tidptr, newtls, child_tidptr);\n}\n\nLIB_PRIVATE\nint _real_pthread_tryjoin_np(pthread_t thread, void **retval) {\n  REAL_FUNC_PASSTHROUGH_TYPED (int, pthread_tryjoin_np) (thread, retval);\n}\n\nLIB_PRIVATE\nint _real_pthread_timedjoin_np(pthread_t thread, void **retval,\n                                 const struct timespec *abstime) {\n  REAL_FUNC_PASSTHROUGH_TYPED (int, pthread_timedjoin_np) (thread, retval, abstime);\n}\n\nLIB_PRIVATE\nint _real_pthread_create(pthread_t *thread, const pthread_attr_t *attr,\n                         void *(*start_routine)(void*), void *arg) {\n  REAL_FUNC_PASSTHROUGH_TYPED (int, pthread_create)\n    (thread,attr,start_routine,arg);\n}\n\n//void _real_pthread_exit(void *retval) __attribute__ ((__noreturn__));\nLIB_PRIVATE\nvoid _real_pthread_exit(void *retval) {\n  REAL_FUNC_PASSTHROUGH_NORETURN (pthread_exit) (retval);\n}\n\nLIB_PRIVATE\nint _real_shmget (int key, size_t size, int shmflg) {\n  REAL_FUNC_PASSTHROUGH (shmget) (key, size, shmflg);\n}\n\nLIB_PRIVATE\nvoid* _real_shmat (int shmid, const void *shmaddr, int shmflg) {\n  REAL_FUNC_PASSTHROUGH_TYPED (void*, shmat) (shmid, shmaddr, shmflg);\n}\n\nLIB_PRIVATE\nint _real_shmdt (const void *shmaddr) {\n  REAL_FUNC_PASSTHROUGH (shmdt) (shmaddr);\n}\n\n/* glibc provides two versions of shmctl: 2.0 and 2.2. For some reason, the\n * dlsym(RTLD_NEXT,...) is getting us the 2.0 version causing the wrong\n * function call. For i386 architecture, we need to pass IPC_64 to the system\n * call in order to work properly. Please refer to NOTES section of shmctl\n * manpage.\n */\n#ifndef IPC_64\n// Taken from <linux/ipc.h>\n# define IPC_64  0x0100  /* New version (support 32-bit UIDs, bigger\n                          message sizes, etc. */\n#endif\n#ifdef __i386__\n# define IPC64_FLAG IPC_64\n#else\n# define IPC64_FLAG 0\n#endif\n\nLIB_PRIVATE\nint _real_shmctl (int shmid, int cmd, struct shmid_ds *buf) {\n  REAL_FUNC_PASSTHROUGH (shmctl) (shmid, cmd | IPC64_FLAG, buf);\n}\n\nLIB_PRIVATE\nint _real_semget(key_t key, int nsems, int semflg) {\n  REAL_FUNC_PASSTHROUGH (semget) (key, nsems, semflg);\n}\n\nLIB_PRIVATE\nint _real_semop(int semid, struct sembuf *sops, size_t nsops) {\n  REAL_FUNC_PASSTHROUGH (semop) (semid, sops, nsops);\n}\n\nLIB_PRIVATE\nint _real_semtimedop(int semid, struct sembuf *sops, size_t nsops,\n                     const struct timespec *timeout) {\n  REAL_FUNC_PASSTHROUGH (semtimedop) (semid, sops, nsops, timeout);\n}\n\nLIB_PRIVATE\nint _real_semctl(int semid, int semnum, int cmd, ...) {\n  union semun uarg;\n  va_list arg;\n  va_start (arg, cmd);\n  uarg = va_arg (arg, union semun);\n  va_end (arg);\n  REAL_FUNC_PASSTHROUGH (semctl) (semid, semnum, cmd | IPC64_FLAG, uarg);\n}\n\nLIB_PRIVATE\nint _real_msgget(key_t key, int msgflg) {\n  REAL_FUNC_PASSTHROUGH (msgget) (key, msgflg);\n}\n\nLIB_PRIVATE\nint _real_msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg) {\n  REAL_FUNC_PASSTHROUGH (msgsnd) (msqid, msgp, msgsz, msgflg);\n}\n\nLIB_PRIVATE\nssize_t _real_msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,\n                     int msgflg) {\n  REAL_FUNC_PASSTHROUGH (msgrcv) (msqid, msgp, msgsz, msgtyp, msgflg);\n}\n\nLIB_PRIVATE\nint _real_msgctl(int msqid, int cmd, struct msqid_ds *buf) {\n  REAL_FUNC_PASSTHROUGH (msgctl) (msqid, cmd | IPC64_FLAG, buf);\n}\n\n\nLIB_PRIVATE\nmqd_t _real_mq_open(const char *name, int oflag, mode_t mode,\n                      struct mq_attr *attr) {\n  REAL_FUNC_PASSTHROUGH_TYPED (mqd_t, mq_open) (name, oflag, mode, attr);\n}\n\nLIB_PRIVATE\nint _real_mq_close(mqd_t mqdes) {\n  REAL_FUNC_PASSTHROUGH (mq_close) (mqdes);\n}\n\nLIB_PRIVATE\nint _real_mq_notify(mqd_t mqdes, const struct sigevent *sevp) {\n  REAL_FUNC_PASSTHROUGH (mq_notify) (mqdes, sevp);\n}\n\nLIB_PRIVATE\nssize_t _real_mq_timedreceive(mqd_t mqdes, char *msg_ptr, size_t msg_len,\n                              unsigned int *msg_prio,\n                              const struct timespec *abs_timeout) {\n  REAL_FUNC_PASSTHROUGH_TYPED (ssize_t, mq_timedreceive) (mqdes, msg_ptr,\n                                                          msg_len, msg_prio,\n                                                          abs_timeout);\n}\n\nLIB_PRIVATE\nint _real_mq_timedsend(mqd_t mqdes, const char *msg_ptr, size_t msg_len,\n                       unsigned int msg_prio,\n                       const struct timespec *abs_timeout) {\n  REAL_FUNC_PASSTHROUGH (mq_timedsend) (mqdes, msg_ptr, msg_len, msg_prio,\n                                        abs_timeout);\n}\n\nLIB_PRIVATE\nvoid *_real_mmap(void *addr, size_t length, int prot, int flags,\n    int fd, off_t offset) {\n  REAL_FUNC_PASSTHROUGH_TYPED (void*, mmap) (addr,length,prot,flags,fd,offset);\n}\n\nLIB_PRIVATE\nvoid *_real_mmap64(void *addr, size_t length, int prot, int flags,\n    int fd, __off64_t offset) {\n  REAL_FUNC_PASSTHROUGH_TYPED (void*,mmap64) (addr,length,prot,flags,fd,offset);\n}\n\n#if __GLIBC_PREREQ (2,4)\nLIB_PRIVATE\nvoid *_real_mremap(void *old_address, size_t old_size, size_t new_size,\n    int flags, ... /* void *new_address*/) {\n  if (flags == MREMAP_FIXED) {\n    va_list ap;\n    va_start(ap, flags);\n    void *new_address = va_arg (ap, void *);\n    va_end (ap);\n    REAL_FUNC_PASSTHROUGH_TYPED (void*, mremap)\n      (old_address, old_size, new_size, flags, new_address);\n  } else {\n    REAL_FUNC_PASSTHROUGH_TYPED (void*, mremap)\n      (old_address, old_size, new_size, flags);\n  }\n}\n#else\nLIB_PRIVATE\nvoid *_real_mremap(void *old_address, size_t old_size, size_t new_size,\n    int flags) {\n  REAL_FUNC_PASSTHROUGH_TYPED (void*, mremap)\n    (old_address, old_size, new_size, flags);\n}\n#endif\n\nLIB_PRIVATE\nint _real_munmap(void *addr, size_t length) {\n  REAL_FUNC_PASSTHROUGH_TYPED (int, munmap) (addr, length);\n}\n\nLIB_PRIVATE\nint _real_poll(struct pollfd *fds, nfds_t nfds, int timeout) {\n  REAL_FUNC_PASSTHROUGH (poll) (fds, nfds, timeout);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/src/processinfo.cpp": "/****************************************************************************\n *   Copyright (C) 2006-2013 by Jason Ansel, Kapil Arya, and Gene Cooperman *\n *   jansel@csail.mit.edu, kapil@ccs.neu.edu, gene@ccs.neu.edu              *\n *                                                                          *\n *  This file is part of DMTCP.                                             *\n *                                                                          *\n *  DMTCP is free software: you can redistribute it and/or                  *\n *  modify it under the terms of the GNU Lesser General Public License as   *\n *  published by the Free Software Foundation, either version 3 of the      *\n *  License, or (at your option) any later version.                         *\n *                                                                          *\n *  DMTCP is distributed in the hope that it will be useful,                *\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of          *\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *\n *  GNU Lesser General Public License for more details.                     *\n *                                                                          *\n *  You should have received a copy of the GNU Lesser General Public        *\n *  License along with DMTCP:dmtcp/src.  If not, see                        *\n *  <http://www.gnu.org/licenses/>.                                         *\n ****************************************************************************/\n\n#include <fenv.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/syscall.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#include \"util.h\"\n#include \"dmtcp_dlsym.h\"\n#include \"syscallwrappers.h\"\n#include \"uniquepid.h\"\n#include \"processinfo.h\"\n#include \"procselfmaps.h\"\n#include \"coordinatorapi.h\"\n#include  \"../jalib/jconvert.h\"\n#include  \"../jalib/jfilesystem.h\"\n\nusing namespace dmtcp;\n\nEXTERNC int dmtcp_get_max_user_fd() __attribute__((weak));\n\nstatic pthread_mutex_t tblLock = PTHREAD_MUTEX_INITIALIZER;\n\nstatic int roundingMode = -1;\nstatic fenv_t envp;\nstatic rlim_t rlim_cur_nofile = 0;\nstatic rlim_t rlim_cur_stack = 0;\n\nstatic void _do_lock_tbl()\n{\n  JASSERT(_real_pthread_mutex_lock(&tblLock) == 0) (JASSERT_ERRNO);\n}\n\nstatic void _do_unlock_tbl()\n{\n  JASSERT(_real_pthread_mutex_unlock(&tblLock) == 0) (JASSERT_ERRNO);\n}\n\nvoid dmtcp_ProcessInfo_EventHook(DmtcpEvent_t event, DmtcpEventData_t *data)\n{\n  switch (event) {\n    case DMTCP_EVENT_INIT:\n      ProcessInfo::instance().init();\n      break;\n\n    case DMTCP_EVENT_PRE_EXEC:\n      {\n        jalib::JBinarySerializeWriterRaw wr(\"\", data->serializerInfo.fd);\n        ProcessInfo::instance().refresh();\n        ProcessInfo::instance().serialize(wr);\n      }\n      break;\n\n    case DMTCP_EVENT_POST_EXEC:\n      {\n        jalib::JBinarySerializeReaderRaw rd(\"\", data->serializerInfo.fd);\n        ProcessInfo::instance().serialize(rd);\n        ProcessInfo::instance().postExec();\n      }\n      break;\n\n    case DMTCP_EVENT_DRAIN:\n      ProcessInfo::instance().refresh();\n      break;\n\n    case DMTCP_EVENT_RESTART:\n      fesetenv(&envp);\n      fesetround(roundingMode);\n\n      { struct rlimit rlim = {0, 0};\n        getrlimit(RLIMIT_NOFILE, &rlim);\n        JWARNING(rlim_cur_nofile <= rlim.rlim_max)\n          (rlim_cur_nofile) (rlim.rlim_max)\n          .Text(\"Prev. soft limit of RLIMIT_NOFILE lowered to new hard limit\");\n        rlim.rlim_cur = rlim_cur_nofile;\n        JASSERT(setrlimit(RLIMIT_NOFILE, &rlim) == 0);\n\n        getrlimit(RLIMIT_STACK, &rlim);\n        JWARNING(rlim_cur_stack <= rlim.rlim_max)\n          (rlim_cur_stack) (rlim.rlim_max)\n          .Text(\"Prev. soft limit of RLIMIT_STACK lowered to new hard limit\");\n        rlim.rlim_cur = rlim_cur_stack;\n        JASSERT(setrlimit(RLIMIT_STACK, &rlim) == 0);\n      }\n      ProcessInfo::instance().restart();\n      break;\n\n    case DMTCP_EVENT_REFILL:\n      if (data->refillInfo.isRestart) {\n        ProcessInfo::instance().restoreProcessGroupInfo();\n      }\n      break;\n\n    case DMTCP_EVENT_THREADS_SUSPEND:\n      roundingMode = fegetround();\n      fegetenv(&envp);\n\n      { struct rlimit rlim = {0, 0};\n        getrlimit(RLIMIT_NOFILE, &rlim);\n        rlim_cur_nofile = rlim.rlim_cur;\n\n        getrlimit(RLIMIT_STACK, &rlim);\n        rlim_cur_stack = rlim.rlim_cur;\n      }\n      break;\n\n    case DMTCP_EVENT_THREADS_RESUME:\n      if (data->refillInfo.isRestart) {\n        _real_close(PROTECTED_ENVIRON_FD);\n      }\n      break;\n\n    default:\n      break;\n  }\n}\n\nProcessInfo::ProcessInfo()\n{\n  char buf[PATH_MAX];\n  _do_lock_tbl();\n  _pid = -1;\n  _ppid = -1;\n  _gid = -1;\n  _sid = -1;\n  _isRootOfProcessTree = false;\n  _noCoordinator = false;\n  _generation = 0;\n    // _generation, above, is per-process.\n    // This contrasts with DmtcpUniqueProcessId:_computation_generation, which is\n    //   shared among all process on a node; used in variable sharedDataHeader.\n    // _generation is updated when _this_ process begins its checkpoint.\n  _childTable.clear();\n  _pthreadJoinId.clear();\n  _procSelfExe = jalib::Filesystem::ResolveSymlink(\"/proc/self/exe\");\n  _maxUserFd = -1;\n  _uppid = UniquePid();\n  JASSERT(getcwd(buf, sizeof buf) != NULL);\n  _launchCWD = buf;\n#ifdef CONFIG_M32\n  _elfType = Elf_32;\n#else\n  _elfType = Elf_64;\n#endif\n  _restoreBufLen = RESTORE_TOTAL_SIZE;\n  _restoreBufAddr = 0;\n  _do_unlock_tbl();\n}\n\nstatic ProcessInfo *pInfo = NULL;\nProcessInfo& ProcessInfo::instance()\n{\n  if (pInfo == NULL) {\n    pInfo = new ProcessInfo();\n  }\n  return *pInfo;\n}\n\nvoid ProcessInfo::findMiscAreas()\n{\n  // Find the current stack area, heap, stack, vDSO and vvar areas.\n  ProcMapsArea area;\n  ProcSelfMaps procSelfMaps;\n  while (procSelfMaps.getNextArea(&area)) {\n    if (strcmp(area.name, \"[heap]\") == 0) {\n      // Record start of heap which will later be used to restore heap\n      _savedHeapStart = (unsigned long) area.addr;\n    } else if (strcmp(area.name, \"[vdso]\") == 0) {\n      _vdsoStart = (unsigned long) area.addr;\n      _vdsoEnd = (unsigned long) area.endAddr;\n    } else if (strcmp(area.name, \"[vvar]\") == 0) {\n      _vvarStart = (unsigned long) area.addr;\n      _vvarEnd = (unsigned long) area.endAddr;\n    } else if ((VA) &area >= area.addr && (VA) &area < area.endAddr) {\n      /* Modern kernels label this '[stack]', but testing '&area' is more\n       * reliable.\n       */\n      JLOG(DMTCP)(\"Original stack area\") ((void*)area.addr) (area.size);\n       /*\n       * Record only end address (higher) of stack as it can grow downwards and\n       * start address will then changed.\n       */\n      _stackEnd = (uintptr_t) area.endAddr;\n      /*\n       * When using Matlab with dmtcp_launch, sometimes the bottom most\n       * page of stack (the page with highest address) which contains the\n       * environment strings and the argv[] was not shown in /proc/self/maps.\n       * This is arguably a bug in the Linux kernel as of version 2.6.32, etc.\n       * This happens on some odd combination of environment passed on to\n       * Matlab process. As a result, the page was not checkpointed and hence\n       * the process segfaulted on restart. The fix is to try to mprotect this\n       * page with RWX permission to make the page visible again. This call\n       * will fail if no stack page was invisible to begin with.\n       */\n      // FIXME : If the area following the stack is not empty, don't\n      //         exercise this path.\n      int ret = mprotect(area.addr + area.size, 0x1000,\n                         PROT_READ | PROT_WRITE | PROT_EXEC);\n      if (ret == 0) {\n        JNOTE(\"bottom-most page of stack (page with highest address) was\\n\"\n              \"  invisible in /proc/self/maps. It is made visible again now.\");\n      }\n    }\n  }\n}\n\nvoid ProcessInfo::init()\n{\n  if (_pid == -1) {\n    // This is a brand new process.\n    _pid = getpid();\n    _ppid = getppid();\n    _isRootOfProcessTree = true;\n    _uppid = UniquePid();\n    _procSelfExe = jalib::Filesystem::ResolveSymlink(\"/proc/self/exe\");\n    _maxUserFd = -1;\n  }\n\n#ifdef CONFIG_M32\n  _elfType = Elf_32;\n#else\n  _elfType = Elf_64;\n#endif\n\n  _vdsoStart = _vdsoEnd = _vvarStart = _vvarEnd = _stackEnd = 0;\n\n  processRlimit();\n\n  findMiscAreas();\n\n  // Reserve space for restoreBuf\n  _restoreBufLen = RESTORE_TOTAL_SIZE;\n\n  _restoreBufAddr = (uint64_t) mmap(NULL, _restoreBufLen, PROT_NONE,\n                    MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);\n  JASSERT(_restoreBufLen != (uint64_t) MAP_FAILED) (JASSERT_ERRNO);\n\n  if (_ckptDir.empty()) {\n    updateCkptDirFileSubdir();\n  }\n}\n\nvoid ProcessInfo::processRlimit()\n{\n#ifdef __i386__\n  // Match work begun in dmtcpPrepareForExec()\n# if 0\n  if (getenv(\"DMTCP_ADDR_COMPAT_LAYOUT\")) {\n    _dmtcp_unsetenv(\"DMTCP_ADDR_COMPAT_LAYOUT\");\n    // DMTCP had set ADDR_COMPAT_LAYOUT.  Now unset it.\n    personality((unsigned long)personality(0xffffffff) ^ ADDR_COMPAT_LAYOUT);\n    JLOG(DMTCP)(\"unsetting ADDR_COMPAT_LAYOUT\");\n  }\n# else\n  { char * rlim_cur_char = getenv(\"DMTCP_RLIMIT_STACK\");\n    if (rlim_cur_char != NULL) {\n      struct rlimit rlim;\n      getrlimit(RLIMIT_STACK, &rlim);\n      rlim.rlim_cur = atol(rlim_cur_char);\n      JLOG(DMTCP)(\"rlim_cur for RLIMIT_STACK being restored.\") (rlim.rlim_cur);\n      setrlimit(RLIMIT_STACK, &rlim);\n      _dmtcp_unsetenv(\"DMTCP_RLIMIT_STACK\");\n    }\n  }\n# endif\n#endif\n}\n\nvoid ProcessInfo::calculateArgvAndEnvSize()\n{\n  vector<string> args = jalib::Filesystem::GetProgramArgs();\n  _argvSize = 0;\n  for (size_t i = 0; i < args.size(); i++) {\n    _argvSize += args[i].length() + 1;\n  }\n\n  _envSize = 0;\n  if (environ != NULL) {\n    char *ptr = environ[0];\n    while (*ptr != '\\0' && args[0].compare(ptr) != 0) {\n      _envSize += strlen(ptr) + 1;\n      ptr += strlen(ptr) + 1;\n    }\n  }\n  _envSize += args[0].length();\n}\n\nvoid ProcessInfo::updateCkptDirFileSubdir(string newCkptDir)\n{\n  if (newCkptDir != \"\") {\n    _ckptDir = newCkptDir;\n  }\n\n  if (_ckptDir.empty()) {\n    const char *dir = getenv(ENV_VAR_CHECKPOINT_DIR);\n    if (dir == NULL) {\n      dir = \".\";\n    }\n    _ckptDir = dir;\n  }\n\n  ostringstream o;\n  o << _ckptDir << \"/\"\n    << CKPT_FILE_PREFIX\n    << jalib::Filesystem::GetProgramName()\n    << '_' << UniquePid::ThisProcess();\n\n  _ckptFileName = o.str() + CKPT_FILE_SUFFIX;\n  _ckptFilesSubDir = o.str() + CKPT_FILES_SUBDIR_SUFFIX;\n}\n\nvoid ProcessInfo::postExec()\n{\n  _procname   = jalib::Filesystem::GetProgramName();\n  _procSelfExe = jalib::Filesystem::ResolveSymlink(\"/proc/self/exe\");\n  _maxUserFd = -1;\n  _upid       = UniquePid::ThisProcess();\n  _uppid      = UniquePid::ParentProcess();\n  updateCkptDirFileSubdir();\n}\n\nvoid ProcessInfo::resetOnFork()\n{\n  pthread_mutex_t newlock = PTHREAD_MUTEX_INITIALIZER;\n  tblLock = newlock;\n  _ppid = _pid;\n  _pid = getpid();\n  _isRootOfProcessTree = false;\n  _childTable.clear();\n  _pthreadJoinId.clear();\n  _ckptFileName.clear();\n  _ckptFilesSubDir.clear();\n  updateCkptDirFileSubdir();\n}\n\nvoid ProcessInfo::restoreHeap()\n{\n  /* If the original start of heap is lower than the current end of heap, we\n   * want to mmap the area between _savedBrk and current break. This\n   * happens when the size of checkpointed program is smaller then the size of\n   * mtcp_restart program.\n   */\n  uint64_t curBrk = (uint64_t) sbrk(0);\n  if (curBrk > _savedBrk) {\n    JNOTE(\"Area between saved_break and curr_break not mapped, mapping it now\")\n      (_savedBrk) (curBrk);\n    size_t oldsize = _savedBrk - _savedHeapStart;\n    size_t newsize = curBrk - _savedHeapStart;\n\n    JASSERT(mremap((void*) _savedHeapStart, oldsize, newsize, 0) != NULL)\n      (_savedBrk) (curBrk)\n      .Text(\"mremap failed to map area between saved break and current break\");\n  } else if (curBrk < _savedBrk) {\n    if (brk((void*)_savedBrk) != 0) {\n      JNOTE(\"Failed to restore area between saved_break and curr_break.\")\n        (_savedBrk) (curBrk) (JASSERT_ERRNO);\n    }\n  }\n}\n\nvoid ProcessInfo::restart()\n{\n  // Unmap the restore buffer and remap it with PROT_NONE. We do munmap followed\n  // mmap to ensure that the kernel releases the backing physical pages.\n  JASSERT(munmap((void *)_restoreBufAddr, _restoreBufLen) == 0)\n    ((void *)_restoreBufAddr) (_restoreBufLen) (JASSERT_ERRNO);\n\n  JASSERT(mmap((void*) _restoreBufAddr , _restoreBufLen, PROT_NONE,\n               MAP_PRIVATE | MAP_ANONYMOUS, -1, 0) != MAP_FAILED)\n    ((void *)_restoreBufAddr) (_restoreBufLen) (JASSERT_ERRNO);\n\n  restoreHeap();\n\n  // Update the ckptDir\n  string ckptDir = jalib::Filesystem::GetDeviceName(PROTECTED_CKPT_DIR_FD);\n  JASSERT(ckptDir.length() > 0);\n  _real_close(PROTECTED_CKPT_DIR_FD);\n  updateCkptDirFileSubdir(ckptDir);\n\n  if (_launchCWD != _ckptCWD) {\n    string rpath = \"\";\n    size_t llen = _launchCWD.length();\n    if (Util::strStartsWith(_ckptCWD.c_str(), _launchCWD.c_str()) &&\n        _ckptCWD[llen] == '/') {\n      // _launchCWD = \"/A/B\"; _ckptCWD = \"/A/B/C\" -> rpath = \"./c\"\n      rpath = \"./\" + _ckptCWD.substr(llen + 1);\n      if (chdir(rpath.c_str()) == 0) {\n        JLOG(DMTCP)(\"Changed cwd\") (_launchCWD) (_ckptCWD) (_launchCWD + rpath);\n      } else {\n        JWARNING(chdir(_ckptCWD.c_str()) == 0) (_ckptCWD) (_launchCWD)\n          (JASSERT_ERRNO) .Text(\"Failed to change directory to _ckptCWD\");\n      }\n    }\n  }\n}\n\nvoid ProcessInfo::restoreProcessGroupInfo()\n{\n  // Restore group assignment\n  if (dmtcp_virtual_to_real_pid && dmtcp_virtual_to_real_pid(_gid) != _gid) {\n    pid_t cgid = getpgid(0);\n    // Group ID is known inside checkpointed processes\n    if (_gid != cgid) {\n      JLOG(DMTCP)(\"Restore Group Assignment\")\n        (_gid) (_fgid) (cgid) (_pid) (_ppid) (getppid());\n      JWARNING(setpgid(0, _gid) == 0) (_gid) (JASSERT_ERRNO)\n        .Text(\"Cannot change group information\");\n    } else {\n      JLOG(DMTCP)(\"Group is already assigned\") (_gid) (cgid);\n    }\n  } else {\n    JLOG(DMTCP)(\"SKIP Group information, GID unknown\");\n  }\n}\n\nvoid ProcessInfo::insertChild(pid_t pid, UniquePid uniquePid)\n{\n  _do_lock_tbl();\n  iterator i = _childTable.find(pid);\n  JWARNING(i == _childTable.end()) (pid) (uniquePid) (i->second)\n    .Text(\"child pid already exists!\");\n\n  _childTable[pid] = uniquePid;\n  _do_unlock_tbl();\n\n  JLOG(DMTCP)(\"Creating new virtualPid -> realPid mapping.\") (pid) (uniquePid);\n}\n\nvoid ProcessInfo::eraseChild(pid_t virtualPid)\n{\n  _do_lock_tbl();\n  iterator i = _childTable.find(virtualPid);\n  if (i != _childTable.end())\n    _childTable.erase(virtualPid);\n  _do_unlock_tbl();\n}\n\nbool ProcessInfo::isChild(const UniquePid& upid)\n{\n  bool res = false;\n  _do_lock_tbl();\n  for (iterator i = _childTable.begin(); i != _childTable.end(); i++) {\n    if (i->second == upid) {\n      res = true;\n      break;\n    }\n  }\n  _do_unlock_tbl();\n  return res;\n}\n\nbool ProcessInfo::beginPthreadJoin(pthread_t thread)\n{\n  bool res = false;\n  _do_lock_tbl();\n  map<pthread_t, pthread_t>::iterator i = _pthreadJoinId.find(thread);\n  if (i == _pthreadJoinId.end()) {\n    _pthreadJoinId[thread] = pthread_self();\n    res = true;\n  }\n  _do_unlock_tbl();\n  return res;\n}\n\nvoid ProcessInfo::clearPthreadJoinState(pthread_t thread)\n{\n  _do_lock_tbl();\n  if (_pthreadJoinId.find(thread) != _pthreadJoinId.end()) {\n    _pthreadJoinId.erase(thread);\n  }\n  _do_unlock_tbl();\n}\n\nvoid ProcessInfo::endPthreadJoin(pthread_t thread)\n{\n  _do_lock_tbl();\n  if (_pthreadJoinId.find(thread) != _pthreadJoinId.end() &&\n      pthread_equal(_pthreadJoinId[thread], pthread_self())) {\n    _pthreadJoinId.erase(thread);\n  }\n  _do_unlock_tbl();\n}\n\nvoid ProcessInfo::setCkptFilename(const char *filename)\n{\n  JASSERT(filename != NULL);\n  if (filename[0] == '/') {\n    _ckptDir = jalib::Filesystem::DirName(filename);\n    _ckptFileName = filename;\n  } else {\n    _ckptFileName = _ckptDir + \"/\" + filename;\n  }\n\n  if (Util::strEndsWith(_ckptFileName, CKPT_FILE_SUFFIX)) {\n    string ckptFileBaseName =\n      _ckptFileName.substr(0, _ckptFileName.length() - CKPT_FILE_SUFFIX_LEN);\n    _ckptFilesSubDir = ckptFileBaseName +CKPT_FILES_SUBDIR_SUFFIX;\n  } else {\n    _ckptFilesSubDir = _ckptFileName + CKPT_FILES_SUBDIR_SUFFIX;\n  }\n}\n\n\nvoid ProcessInfo::setCkptDir(const char *dir)\n{\n  JASSERT(dir != NULL);\n  _ckptDir = dir;\n  _ckptFileName = _ckptDir + \"/\" + jalib::Filesystem::BaseName(_ckptFileName);\n  _ckptFilesSubDir = _ckptDir + \"/\" + jalib::Filesystem::BaseName(_ckptFilesSubDir);\n\n  JLOG(DMTCP)(\"setting ckptdir\") (_ckptDir) (_ckptFilesSubDir);\n  //JASSERT(access(_ckptDir.c_str(), X_OK|W_OK) == 0) (_ckptDir)\n    //.Text(\"Missing execute- or write-access to checkpoint dir.\");\n}\n\nvoid ProcessInfo::refresh()\n{\n  JASSERT(_pid == getpid()) (_pid) (getpid());\n\n  _gid = getpgid(0);\n  _sid = getsid(0);\n\n  _fgid = -1;\n  // Try to open the controlling terminal\n  int tfd = _real_open(\"/dev/tty\", O_RDWR);\n  if (tfd != -1) {\n    _fgid = tcgetpgrp(tfd);\n    _real_close(tfd);\n  }\n\n  if (_ppid != getppid()) {\n    // Our original parent died; we are the root of the process tree now.\n    //\n    // On older systems, a process is inherited by init (pid = 1) after its\n    // parent dies. However, with the new per-user init process, the parent\n    // pid is no longer \"1\"; it's the pid of the user-specific init process.\n    _ppid = getppid();\n    _isRootOfProcessTree = true;\n    _uppid = UniquePid();\n  } else {\n    _uppid = UniquePid::ParentProcess();\n  }\n\n  _procname = jalib::Filesystem::GetProgramName();\n  _procSelfExe = jalib::Filesystem::ResolveSymlink(\"/proc/self/exe\");\n  _maxUserFd = -1;\n  _hostname = jalib::Filesystem::GetCurrentHostname();\n  _upid = UniquePid::ThisProcess();\n  _noCoordinator = dmtcp_no_coordinator();\n\n  char buf[PATH_MAX];\n  JASSERT(getcwd(buf, sizeof buf) != NULL);\n  _ckptCWD = buf;\n\n  _sessionIds.clear();\n  refreshChildTable();\n\n  JLOG(DMTCP)(\"CHECK GROUP PID\")(_gid)(_fgid)(_ppid)(_pid);\n}\n\nvoid ProcessInfo::refreshChildTable()\n{\n  iterator i = _childTable.begin();\n  while (i != _childTable.end()) {\n    pid_t pid = i->first;\n    iterator j = i++;\n    /* Check to see if the child process is alive*/\n    if (kill(pid, 0) == -1 && errno == ESRCH) {\n      _childTable.erase(j);\n    } else {\n      _sessionIds[pid] = getsid(pid);\n    }\n  }\n}\n\nvoid ProcessInfo::updateMaxUserFd(int fd)\n{\n  if (fd > _maxUserFd) {\n    _maxUserFd = fd;\n  }\n}\n\nbool ProcessInfo::vdsoOffsetMismatch(ptrdiff_t f1, ptrdiff_t f2,\n                                     ptrdiff_t f3, ptrdiff_t f4)\n{\n  return (f1 != _clock_gettime_offset) || (f2 != _getcpu_offset) ||\n         (f3 != _gettimeofday_offset) || (f4 != _time_offset);\n}\n\nvoid ProcessInfo::serialize(jalib::JBinarySerializer& o)\n{\n  JSERIALIZE_ASSERT_POINT(\"ProcessInfo:\");\n  _savedBrk = (uint64_t) sbrk(0);\n  _clock_gettime_offset = dmtcp_dlsym_lib_fnc_offset(\"linux-vdso\",\n                                                     \"__vdso_clock_gettime\");\n  _getcpu_offset = dmtcp_dlsym_lib_fnc_offset(\"linux-vdso\",\n                                              \"__vdso_getcpu\");\n  _gettimeofday_offset = dmtcp_dlsym_lib_fnc_offset(\"linux-vdso\",\n                                                    \"__vdso_gettimeofday\");\n  _time_offset = dmtcp_dlsym_lib_fnc_offset(\"linux-vdso\", \"__vdso_time\");\n\n  o & _elfType;\n  o & _isRootOfProcessTree & _pid & _sid & _ppid & _gid & _fgid & _generation;\n  o & _procname & _procSelfExe & _hostname & _launchCWD & _ckptCWD & _upid & _uppid;\n  o & _clock_gettime_offset & _getcpu_offset\n    & _gettimeofday_offset & _time_offset;\n  o & _compGroup & _numPeers & _noCoordinator & _argvSize & _envSize;\n  o & _restoreBufAddr & _maxUserFd & _savedHeapStart & _savedBrk;\n  o & _vdsoStart & _vdsoEnd & _vvarStart & _vvarEnd & _stackEnd;\n  o & _ckptDir & _ckptFileName & _ckptFilesSubDir;\n\n  JLOG(DMTCP)(\"Serialized process information\")\n    (_sid) (_ppid) (_gid) (_fgid) (_isRootOfProcessTree)\n    (_procname) (_hostname) (_launchCWD) (_ckptCWD) (_upid) (_uppid)\n    (_compGroup) (_numPeers) (_noCoordinator) (_argvSize) (_envSize) (_elfType);\n\n  JASSERT(!_noCoordinator || _numPeers == 1) (_noCoordinator) (_numPeers);\n\n  if (_isRootOfProcessTree) {\n    JLOG(DMTCP)(\"This process is Root of Process Tree\");\n  }\n\n  JLOG(DMTCP)(\"Serializing ChildPid Table\") (_childTable.size()) (o.filename());\n  o.serializeMap(_childTable);\n\n  JSERIALIZE_ASSERT_POINT(\"EOF\");\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/src/syscallwrappers.h": "/****************************************************************************\n *   Copyright (C) 2006-2008 by Jason Ansel, Kapil Arya, and Gene Cooperman *\n *   jansel@csail.mit.edu, kapil@ccs.neu.edu, gene@ccs.neu.edu              *\n *                                                                          *\n *  This file is part of DMTCP.                                             *\n *                                                                          *\n *  DMTCP is free software: you can redistribute it and/or                  *\n *  modify it under the terms of the GNU Lesser General Public License as   *\n *  published by the Free Software Foundation, either version 3 of the      *\n *  License, or (at your option) any later version.                         *\n *                                                                          *\n *  DMTCP is distributed in the hope that it will be useful,                *\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of          *\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *\n *  GNU Lesser General Public License for more details.                     *\n *                                                                          *\n *  You should have received a copy of the GNU Lesser General Public        *\n *  License along with DMTCP:dmtcp/src.  If not, see                        *\n *  <http://www.gnu.org/licenses/>.                                         *\n ****************************************************************************/\n\n#ifndef SYSCALLWRAPPERS_H\n#define SYSCALLWRAPPERS_H\n\n// FIXME:  Why are we adding all these includes here, if we're declaring\n//         only our own _real_XXX() functions?  Some *wrappers.cpp files\n//         use these includes.  But, then we should split up these includes\n//         among the individual *wrappers.cpp files that actually need them,\n//         and not declare every possible include in one giant .h file.\n#include <features.h>\n#include <pthread.h>\n#include <stdio.h>\n#include <sys/resource.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <signal.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <poll.h>\n#include <stdarg.h>\n#include <sys/shm.h>\n#include <sys/sem.h>\n// FIXME:  The SLES 10 (glibc-2.4) declaration for msgctl differs from\n//         our wrapper's declaration, which uses the POSIX declaration.\n//         If for syscallsreal.c, use the local (e.g., SLES 10) decl.\n//         Otherwise, skip declaration, and use decl. in pidwrappers.h\n//         or in syscallwrappers.h.  The correct solution should be to fix\n//         the way that *wrappers.h get their decl. of msgctl().\n#ifdef FOR_SYSCALLSREAL_C\n# include <sys/msg.h>\n#endif\n#ifdef __cplusplus\n# include <sys/stat.h>\n#else\n# ifndef __USE_LARGEFILE64\n#  define __USE_LARGEFILE64_not_defined\n#  define __USE_LARGEFILE64\n#  include <sys/stat.h>\n#  ifdef __USE_LARGEFILE64_not_defined\n#   undef __USE_LARGEFILE64_not_defined\n#   undef __USE_LARGEFILE64\n#  endif\n# endif\n#endif\n#include <sys/mman.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <mqueue.h>\n#ifdef HAVE_SYS_INOTIFY_H\n# include <sys/inotify.h>\n#endif\n\n#include \"constants.h\"\n#include \"dmtcp.h\"\n#include \"mtcp/ldt.h\"\n#include \"config.h\"\n\n#ifdef HAVE_SYS_EPOLL_H\n# include <sys/epoll.h>\n#else\n  /* KEEP THIS IN SYNC WITH connection.h */\n# ifndef _SYS_EPOLL_H\n#  define _SYS_EPOLL_H    1\n   struct epoll_event {int dummy;};\n   /* Valid opcodes (\"op\" parameter) to issue to epoll_ctl().  */\n#  define EPOLL_CTL_ADD 1 /* Add a file descriptor to the interface.  */\n#  define EPOLL_CTL_DEL 2 /* Remove a file descriptor from the interface.  */\n#  define EPOLL_CTL_MOD 3 /* Change file descriptor epoll_event structure.  */\n# endif\n#endif\n\nvoid _dmtcp_setup_trampolines();\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n#if defined(__arm__) || defined(__aarch64__)\n# define DISABLE_PTHREAD_GETSPECIFIC_TRICK\n#endif\n\nLIB_PRIVATE pid_t dmtcp_gettid();\nLIB_PRIVATE int dmtcp_tkill(int tid, int sig);\nLIB_PRIVATE int dmtcp_tgkill(int tgid, int tid, int sig);\n\nextern int dmtcp_wrappers_initializing;\n\nLIB_PRIVATE extern __thread int thread_performing_dlopen_dlsym;\n\n#define FOREACH_GLIBC_MALLOC_FAMILY_WRAPPERS(MACRO)\\\n  MACRO(calloc)                             \\\n  MACRO(malloc)                             \\\n  MACRO(free)                               \\\n  MACRO(__libc_memalign)                    \\\n  MACRO(realloc)                            \\\n  MACRO(mmap)                               \\\n  MACRO(mmap64)                             \\\n  MACRO(mremap)                             \\\n  MACRO(munmap)\n\n#define FOREACH_GLIBC_WRAPPERS(MACRO)       \\\n  MACRO(dlopen)                             \\\n  MACRO(dlclose)                            \\\n  MACRO(getpid)                             \\\n  MACRO(getppid)                            \\\n  MACRO(kill)                               \\\n                                            \\\n  MACRO(tcgetpgrp)                          \\\n  MACRO(tcsetpgrp)                          \\\n  MACRO(getpgrp)                            \\\n  MACRO(setpgrp)                            \\\n                                            \\\n  MACRO(getpgid)                            \\\n  MACRO(setpgid)                            \\\n  MACRO(getsid)                             \\\n  MACRO(setsid)                             \\\n  MACRO(setgid)                             \\\n  MACRO(setuid)                             \\\n                                            \\\n  MACRO(wait)                               \\\n  MACRO(waitpid)                            \\\n  MACRO(waitid)                             \\\n  MACRO(wait3)                              \\\n  MACRO(wait4)                              \\\n  MACRO(ioctl)                              \\\n  MACRO(fcntl)                              \\\n                                            \\\n  MACRO(socket)                             \\\n  MACRO(connect)                            \\\n  MACRO(bind)                               \\\n  MACRO(listen)                             \\\n  MACRO(accept)                             \\\n  MACRO(accept4)                            \\\n  MACRO(setsockopt)                         \\\n  MACRO(getsockopt)                         \\\n  MACRO(socketpair)                         \\\n                                            \\\n  MACRO(fexecve)                            \\\n  MACRO(execve)                             \\\n  MACRO(execv)                              \\\n  MACRO(execvp)                             \\\n  MACRO(execvpe)                            \\\n  MACRO(execl)                              \\\n  MACRO(execlp)                             \\\n  MACRO(execle)                             \\\n  MACRO(system)                             \\\n  MACRO(popen)                              \\\n  MACRO(pclose)                             \\\n                                            \\\n  MACRO(signal)                             \\\n  MACRO(sigaction)                          \\\n  MACRO(sigvec)                             \\\n                                            \\\n  MACRO(sigset)                             \\\n  MACRO(sigblock)                           \\\n  MACRO(sigsetmask)                         \\\n  MACRO(siggetmask)                         \\\n  MACRO(sigprocmask)                        \\\n                                            \\\n  MACRO(sigsuspend)                         \\\n  MACRO(sighold)                            \\\n  MACRO(sigignore)                          \\\n  MACRO(__sigpause)                         \\\n  MACRO(sigpause)                           \\\n  MACRO(sigrelse)                           \\\n                                            \\\n  MACRO(sigwait)                            \\\n  MACRO(sigwaitinfo)                        \\\n  MACRO(sigtimedwait)                       \\\n                                            \\\n  MACRO(fork)                               \\\n  MACRO(__clone)                            \\\n  MACRO(open)                               \\\n  MACRO(open64)                             \\\n  MACRO(fopen)                              \\\n  MACRO(fopen64)                            \\\n  MACRO(openat)                             \\\n  MACRO(openat64)                           \\\n  MACRO(opendir)                            \\\n  MACRO(mkstemp)                            \\\n  MACRO(close)                              \\\n  MACRO(fclose)                             \\\n  MACRO(closedir)                           \\\n  MACRO(setrlimit)                          \\\n  MACRO(dup)                                \\\n  MACRO(dup2)                               \\\n  MACRO(dup3)                               \\\n  MACRO(__xstat)                            \\\n  MACRO(__xstat64)                          \\\n  MACRO(__lxstat)                           \\\n  MACRO(__lxstat64)                         \\\n  MACRO(readlink)                           \\\n  MACRO(exit)                               \\\n  MACRO(syscall)                            \\\n  MACRO(unsetenv)                           \\\n  MACRO(ptsname_r)                          \\\n  MACRO(ttyname_r)                          \\\n  MACRO(getpt)                              \\\n  MACRO(posix_openpt)                       \\\n  MACRO(openlog)                            \\\n  MACRO(closelog)                           \\\n                                            \\\n  MACRO(shmget)                             \\\n  MACRO(shmat)                              \\\n  MACRO(shmdt)                              \\\n  MACRO(shmctl)                             \\\n                                            \\\n  MACRO(semget)                             \\\n  MACRO(semctl)                             \\\n  MACRO(semop)                              \\\n  MACRO(semtimedop)                         \\\n                                            \\\n  MACRO(msgget)                             \\\n  MACRO(msgctl)                             \\\n  MACRO(msgsnd)                             \\\n  MACRO(msgrcv)                             \\\n                                            \\\n  MACRO(mq_open)                            \\\n  MACRO(mq_close)                           \\\n  MACRO(mq_timedsend)                       \\\n  MACRO(mq_timedreceive)                    \\\n  MACRO(mq_notify)                          \\\n                                            \\\n  MACRO(read)                               \\\n  MACRO(write)                              \\\n                                            \\\n  MACRO(select)                             \\\n  MACRO(poll)                               \\\n                                            \\\n  MACRO(pthread_create)                     \\\n  MACRO(pthread_exit)                       \\\n  MACRO(pthread_tryjoin_np)                 \\\n  MACRO(pthread_timedjoin_np)               \\\n  MACRO(pthread_sigmask)                    \\\n  MACRO(pthread_getspecific)                \\\n  MACRO(pthread_mutex_lock)                 \\\n  MACRO(pthread_mutex_trylock)              \\\n  MACRO(pthread_mutex_unlock)               \\\n  MACRO(pthread_rwlock_unlock)              \\\n  MACRO(pthread_rwlock_rdlock)              \\\n  MACRO(pthread_rwlock_tryrdlock)           \\\n  MACRO(pthread_rwlock_wrlock)              \\\n  MACRO(pthread_rwlock_trywrlock)\n\n#define FOREACH_LIBPTHREAD_WRAPPERS(MACRO)  \\\n  MACRO(pthread_cond_broadcast)             \\\n  MACRO(pthread_cond_destroy)               \\\n  MACRO(pthread_cond_init)                  \\\n  MACRO(pthread_cond_signal)                \\\n  MACRO(pthread_cond_timedwait)             \\\n  MACRO(pthread_cond_wait)\n\n#define FOREACH_DMTCP_WRAPPER(MACRO)            \\\n  FOREACH_GLIBC_WRAPPERS(MACRO)                 \\\n  FOREACH_GLIBC_MALLOC_FAMILY_WRAPPERS(MACRO)\n\n# define ENUM(x) enum_ ## x\n# define GEN_ENUM(x) ENUM(x),\n  typedef enum {\n    FOREACH_DMTCP_WRAPPER(GEN_ENUM)\n#ifdef ENABLE_PTHREAD_COND_WRAPPERS\n    FOREACH_LIBPTHREAD_WRAPPERS(GEN_ENUM)\n#endif // #ifdef ENABLE_PTHREAD_COND_WRAPPERS\n    numLibcWrappers\n  } LibcWrapperOffset;\n\n  union semun {\n    int              val;    /* Value for SETVAL */\n    struct semid_ds *buf;    /* Buffer for IPC_STAT, IPC_SET */\n    unsigned short  *array;  /* Array for GETALL, SETALL */\n    struct seminfo  *__buf;  /* Buffer for IPC_INFO (Linux-specific) */\n  };\n\n  void _dmtcp_lock();\n  void _dmtcp_unlock();\n\n  void _dmtcp_remutex_on_fork();\n  LIB_PRIVATE void dmtcpResetTid(pid_t tid);\n  LIB_PRIVATE void dmtcpResetPidPpid();\n\n  int _dmtcp_unsetenv(const char *name);\n  void dmtcp_prepare_wrappers();\n\n  int _real_socket (int domain, int type, int protocol);\n  int _real_connect (int sockfd,  const  struct sockaddr *serv_addr,\n                      socklen_t addrlen);\n  int _real_bind (int sockfd,  const struct  sockaddr  *my_addr,\n                   socklen_t addrlen);\n  int _real_listen (int sockfd, int backlog);\n  int _real_accept (int sockfd, struct sockaddr *addr, socklen_t *addrlen);\n  int _real_accept4 (int sockfd, struct sockaddr *addr, socklen_t *addrlen,\n                      int flags);\n  int _real_setsockopt (int s, int level, int optname, const void *optval,\n                         socklen_t optlen);\n  int _real_getsockopt (int s, int level, int optname, void *optval,\n                         socklen_t *optlen);\n\n  int _real_fexecve (int fd, char *const argv[], char *const envp[]);\n  int _real_execve (const char *filename, char *const argv[], char *const envp[]);\n  int _real_execv (const char *path, char *const argv[]);\n  int _real_execvp (const char *file, char *const argv[]);\n  int _real_execvpe(const char *file, char *const argv[], char *const envp[]);\n// int _real_execl(const char *path, const char *arg, ...);\n// int _real_execlp(const char *file, const char *arg, ...);\n// int _real_execle(const char *path, const char *arg, ..., char * const envp[]);\n  int _real_system (const char * cmd);\n  FILE *_real_popen(const char *command, const char *mode);\n  int _real_pclose(FILE *fp);\n\n  pid_t _real_fork();\n  int _real_clone (int (*fn) (void *arg), void *child_stack, int flags, void *arg, int *parent_tidptr, struct user_desc *newtls, int *child_tidptr);\n\n  int _real_open(const char *pathname, int flags, ...);\n  int _real_open64(const char *pathname, int flags, ...);\n  FILE* _real_fopen(const char *path, const char *mode);\n  FILE* _real_fopen64(const char *path, const char *mode);\n  int _real_openat(int dirfd, const char *pathname, int flags, mode_t mode);\n  int _real_openat64(int dirfd, const char *pathname, int flags, mode_t mode);\n  DIR* _real_opendir(const char *name);\n  int _real_mkstemp(char *ttemplate);\n  int _real_close (int fd);\n  int _real_fclose (FILE *fp);\n  int _real_closedir (DIR *dir);\n  int _real_setrlimit(int resource, const struct rlimit *rlim);\n  void _real_exit (int status);\n  int _real_dup (int oldfd);\n  int _real_dup2 (int oldfd, int newfd);\n  int _real_dup3 (int oldfd, int newfd, int flags);\n  int _real_fcntl(int fd, int cmd, void *arg);\n\n  int _real_ttyname_r (int fd, char *buf, size_t buflen);\n  int _real_ptsname_r (int fd, char * buf, size_t buflen);\n  int _real_getpt (void);\n  int _real_posix_openpt (int flags);\n\n  int _real_socketpair (int d, int type, int protocol, int sv[2]);\n\n  void _real_openlog (const char *ident, int option, int facility);\n  void _real_closelog (void);\n\n  // Despite what 'man signal' says, signal.h already defines sighandler_t\n  // But signal.h defines this only because we define GNU_SOURCE (or __USE_GNU_\n  typedef void (*sighandler_t)(int);  /* POSIX has user define this type */\n\n  //set the handler\n  sighandler_t _real_signal(int signum, sighandler_t handler);\n  int _real_sigaction(int signum, const struct sigaction *act,\n                      struct sigaction *oldact);\n  int _real_rt_sigaction(int signum, const struct sigaction *act,\n                         struct sigaction *oldact);\n#if !__GLIBC_PREREQ(2,21)\n  int _real_sigvec(int sig, const struct sigvec *vec, struct sigvec *ovec);\n#endif\n\n  //set the mask\n  int _real_sigblock(int mask);\n  int _real_sigsetmask(int mask);\n  int _real_siggetmask(void);\n  int _real_sigprocmask(int how, const sigset_t *set, sigset_t *oldset);\n  int _real_rt_sigprocmask(int how, const sigset_t *set, sigset_t *oldset);\n  int _real_pthread_sigmask(int how, const sigset_t *newmask,\n                            sigset_t *oldmask);\n  void *_real_pthread_getspecific(pthread_key_t key);\n\n  int _real_sigsuspend(const sigset_t *mask);\n  int _real_sighold(int sig);\n  int _real_sigignore(int sig);\n  int _real__sigpause(int __sig_or_mask, int __is_sig);\n  int _real_sigpause(int sig);\n  int _real_sigrelse(int sig);\n  sighandler_t _real_sigset(int sig, sighandler_t disp);\n\n  int _real_sigwait(const sigset_t *set, int *sig);\n  int _real_sigwaitinfo(const sigset_t *set, siginfo_t *info);\n  int _real_sigtimedwait(const sigset_t *set, siginfo_t *info,\n                         const struct timespec *timeout);\n\n  long _real_syscall(long sys_num, ...);\n\n  int _real_pthread_create(pthread_t *thread, const pthread_attr_t *attr,\n      void *(*start_routine)(void*), void *arg);\n  void _real_pthread_exit(void *retval) __attribute__ ((__noreturn__));\n  int _real_pthread_tryjoin_np(pthread_t thread, void **retval);\n  int _real_pthread_timedjoin_np(pthread_t thread, void **retval,\n                                 const struct timespec *abstime);\n\n  int _real_xstat(int vers, const char *path, struct stat *buf);\n  int _real_xstat64(int vers, const char *path, struct stat64 *buf);\n  int _real_lxstat(int vers, const char *path, struct stat *buf);\n  int _real_lxstat64(int vers, const char *path, struct stat64 *buf);\n  ssize_t _real_readlink(const char *path, char *buf, size_t bufsiz);\n  void * _real_dlsym (void *handle, const char *symbol);\n\n  void *_real_dlopen(const char *filename, int flag);\n  int _real_dlclose(void *handle);\n\n  void *_real_calloc(size_t nmemb, size_t size);\n  void *_real_malloc(size_t size);\n  void  _real_free(void *ptr);\n  void *_real_realloc(void *ptr, size_t size);\n  void *_real_libc_memalign(size_t boundary, size_t size);\n  void *_real_mmap(void *addr, size_t length, int prot, int flags,\n      int fd, off_t offset);\n  void *_real_mmap64(void *addr, size_t length, int prot, int flags,\n      int fd, __off64_t offset);\n#if __GLIBC_PREREQ (2,4)\n  void *_real_mremap(void *old_address, size_t old_size, size_t new_size,\n      int flags, ... /* void *new_address */);\n#else\n  void *_real_mremap(void *old_address, size_t old_size, size_t new_size,\n      int flags);\n#endif\n  int _real_munmap(void *addr, size_t length);\n\n  ssize_t _real_read(int fd, void *buf, size_t count);\n  ssize_t _real_write(int fd, const void *buf, size_t count);\n  int _real_select(int nfds, fd_set *readfds, fd_set *writefds,\n                   fd_set *exceptfds, struct timeval *timeout);\n  off_t _real_lseek(int fd, off_t offset, int whence);\n  int _real_unlink(const char *pathname);\n\n  int _real_pthread_mutex_lock(pthread_mutex_t *mutex);\n  int _real_pthread_mutex_trylock(pthread_mutex_t *mutex);\n  int _real_pthread_mutex_unlock(pthread_mutex_t *mutex);\n  int _real_pthread_rwlock_unlock(pthread_rwlock_t *rwlock);\n  int _real_pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);\n  int _real_pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock);\n  int _real_pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);\n  int _real_pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock);\n\n#ifdef ENABLE_PTHREAD_COND_WRAPPERS\n  int _real_pthread_cond_broadcast(pthread_cond_t *cond);\n  int _real_pthread_cond_destroy(pthread_cond_t *cond);\n  int _real_pthread_cond_init(pthread_cond_t *cond,\n                              const pthread_condattr_t *attr);\n  int _real_pthread_cond_signal(pthread_cond_t *cond);\n  int _real_pthread_cond_timedwait(pthread_cond_t *cond, pthread_mutex_t *mutex,\n                                   const struct timespec *abstime);\n  int _real_pthread_cond_wait(pthread_cond_t *cond, pthread_mutex_t *mutex);\n#endif // #ifdef ENABLE_PTHREAD_COND_WRAPPERS\n\n  int _real_poll(struct pollfd *fds, nfds_t nfds, int timeout);\n\n  int   _real_waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);\n  pid_t _real_wait4(pid_t pid, __WAIT_STATUS status, int options,\n                    struct rusage *rusage);\n\n  int _real_shmget (int key, size_t size, int shmflg);\n  void* _real_shmat (int shmid, const void *shmaddr, int shmflg);\n  int _real_shmdt (const void *shmaddr);\n  int _real_shmctl (int shmid, int cmd, struct shmid_ds *buf);\n  int _real_semget(key_t key, int nsems, int semflg);\n  int _real_semop(int semid, struct sembuf *sops, size_t nsops);\n  int _real_semtimedop(int semid, struct sembuf *sops, size_t nsops,\n                       const struct timespec *timeout);\n  int _real_semctl(int semid, int semnum, int cmd, ...);\n\n  int _real_msgget(key_t key, int msgflg);\n  int _real_msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg);\n  ssize_t _real_msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp,\n                       int msgflg);\n  int _real_msgctl(int msqid, int cmd, struct msqid_ds *buf);\n\n\n  mqd_t _real_mq_open(const char *name, int oflag, mode_t mode,\n                      struct mq_attr *attr);\n  int _real_mq_close(mqd_t mqdes);\n  int _real_mq_notify(mqd_t mqdes, const struct sigevent *sevp);\n  ssize_t _real_mq_timedreceive(mqd_t mqdes, char *msg_ptr, size_t msg_len,\n                                unsigned int *msg_prio,\n                                const struct timespec *abs_timeout);\n  int _real_mq_timedsend(mqd_t mqdes, const char *msg_ptr, size_t msg_len,\n                         unsigned int msg_prio,\n                         const struct timespec *abs_timeout);\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/src/dmtcp_restart.cpp": "/****************************************************************************\n *   Copyright (C) 2006-2013 by Jason Ansel, Kapil Arya, and Gene Cooperman *\n *   jansel@csail.mit.edu, kapil@ccs.neu.edu, gene@ccs.neu.edu              *\n *                                                                          *\n *  This file is part of DMTCP.                                             *\n *                                                                          *\n *  DMTCP is free software: you can redistribute it and/or                  *\n *  modify it under the terms of the GNU Lesser General Public License as   *\n *  published by the Free Software Foundation, either version 3 of the      *\n *  License, or (at your option) any later version.                         *\n *                                                                          *\n *  DMTCP is distributed in the hope that it will be useful,                *\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of          *\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *\n *  GNU Lesser General Public License for more details.                     *\n *                                                                          *\n *  You should have received a copy of the GNU Lesser General Public        *\n *  License along with DMTCP:dmtcp/src.  If not, see                        *\n *  <http://www.gnu.org/licenses/>.                                         *\n ****************************************************************************/\n\n#include <stdio.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <sys/fcntl.h>\n#include <sys/wait.h>\n#include <sys/mman.h>\n#include <limits.h>\n#include <elf.h>\n#include \"config.h\"\n#ifdef HAS_PR_SET_PTRACER\n# include <sys/prctl.h>\n#endif\n\n#include \"constants.h\"\n#include \"coordinatorapi.h\"\n#include \"util.h\"\n#include \"uniquepid.h\"\n#include \"dmtcp_dlsym.h\"\n#include \"processinfo.h\"\n#include \"shareddata.h\"\n#include  \"../jalib/jassert.h\"\n#include  \"../jalib/jfilesystem.h\"\n\n#define BINARY_NAME \"dmtcp_restart\"\n#define MTCP_RESTART_BINARY \"mtcp_restart\"\n\nusing namespace dmtcp;\n\n// Copied from mtcp/mtcp_restart.c.\n#define DMTCP_MAGIC_FIRST 'D'\n#define GZIP_FIRST 037\n#ifdef HBICT_DELTACOMP\n#define HBICT_FIRST 'H'\n#endif\n\nstatic void setEnvironFd();\n\nstring tmpDir = \"/DMTCP/Uninitialized/Tmp/Dir\";\n\n// gcc-4.3.4 -Wformat=2 issues false positives for warnings unless the format\n// string has at least one format specifier with corresponding format argument.\n// Ubuntu 9.01 uses -Wformat=2 by default.\nstatic const char* theUsage =\n  \"Usage: dmtcp_restart [OPTIONS] <ckpt1.dmtcp> [ckpt2.dmtcp...]\\n\\n\"\n  \"Restart processes from a checkpoint image.\\n\\n\"\n  \"Connecting to the DMTCP Coordinator:\\n\"\n  \"  -h, --coord-host HOSTNAME (environment variable DMTCP_COORD_HOST)\\n\"\n  \"              Hostname where dmtcp_coordinator is run (default: localhost)\\n\"\n  \"  -p, --coord-port PORT_NUM (environment variable DMTCP_COORD_PORT)\\n\"\n  \"              Port where dmtcp_coordinator is run (default: \"\n                                                  STRINGIFY(DEFAULT_PORT) \")\\n\"\n  \"  --port-file FILENAME\\n\"\n  \"              File to write listener port number.\\n\"\n  \"              (Useful with '--port 0', which is used to assign a random port)\\n\"\n  \"  -j, --join-coordinator\\n\"\n  \"              Join an existing coordinator, raise error if one doesn't\\n\"\n  \"              already exist\\n\"\n  \"  --new-coordinator\\n\"\n  \"              Create a new coordinator at the given port. Fail if one\\n\"\n  \"              already exists on the given port. The port can be specified\\n\"\n  \"              with --coord-port, or with environment variable DMTCP_COORD_PORT.\\n\"\n  \"              If no port is specified, start coordinator at a random port\\n\"\n  \"              (same as specifying port '0').\\n\"\n  \"  -i, --interval SECONDS (environment variable DMTCP_CHECKPOINT_INTERVAL)\\n\"\n  \"              Time in seconds between automatic checkpoints.\\n\"\n  \"              0 implies never (manual ckpt only); if not set and no env var,\\n\"\n  \"              use default value set in dmtcp_coordinator or dmtcp_command.\\n\"\n  \"              Not allowed if --join-coordinator is specified\\n\"\n  \"\\n\"\n  \"Other options:\\n\"\n  \"  --no-strict-checking\\n\"\n  \"              Disable uid checking for checkpoint image. Allow checkpoint\\n\"\n  \"              image to be restarted by a different user than the one\\n\"\n  \"              that created it.  And suppress warning about running as root.\\n\"\n  \"              (environment variable DMTCP_DISABLE_STRICT_CHECKING)\\n\"\n  \"  --ckptdir (environment variable DMTCP_CHECKPOINT_DIR):\\n\"\n  \"              Directory to store checkpoint images\\n\"\n  \"              (default: use the same directory used in previous checkpoint)\\n\"\n  \"  --tmpdir PATH (environment variable DMTCP_TMPDIR)\\n\"\n  \"              Directory to store temporary files (default: $TMDPIR or /tmp)\\n\"\n  \"  -q, --quiet (or set environment variable DMTCP_QUIET = 0, 1, or 2)\\n\"\n  \"              Skip NOTE messages; if given twice, also skip WARNINGs\\n\"\n  \"  --coord-logfile PATH (environment variable DMTCP_COORD_LOG_FILENAME\\n\"\n  \"              Coordinator will dump its logs to the given file\\n\"\n  \"  --debug-restart-pause (or set env. var. DMTCP_RESTART_PAUSE =1,2,3 or 4)\\n\"\n  \"              dmtcp_restart will pause early to debug with:  GDB attach\\n\"\n  \"  --help\\n\"\n  \"              Print this message and exit.\\n\"\n  \"  --version\\n\"\n  \"              Print version information and exit.\\n\"\n  \"\\n\"\n  HELP_AND_CONTACT_INFO\n  \"\\n\"\n;\n\nstatic int requestedDebugLevel = 0;\nstatic uint32_t mask = jassert_internal::UNKNOWN;\n\nclass RestoreTarget;\n\ntypedef map<UniquePid, RestoreTarget*> RestoreTargetMap;\nRestoreTargetMap targets;\nRestoreTargetMap independentProcessTreeRoots;\nbool noStrictChecking = false;\nstatic string thePortFile;\nCoordinatorMode allowedModes = COORD_ANY;\n\nstatic void setEnvironFd();\nstatic void runMtcpRestart(int is32bitElf, int fd, ProcessInfo *pInfo);\nstatic int readCkptHeader(const string& path, ProcessInfo *pInfo);\nstatic int openCkptFileToRead(const string& path);\n\nclass RestoreTarget\n{\n  public:\n    RestoreTarget(const string& path)\n      : _path(path)\n    {\n      JASSERT(jalib::Filesystem::FileExists(_path)) (_path)\n        .Text ( \"checkpoint file missing\" );\n\n      _fd = readCkptHeader(_path, &_pInfo);\n      ptrdiff_t clock_gettime_offset =\n                            dmtcp_dlsym_lib_fnc_offset(\"linux-vdso\",\n                                                       \"__vdso_clock_gettime\");\n      ptrdiff_t getcpu_offset = dmtcp_dlsym_lib_fnc_offset(\"linux-vdso\",\n                                                           \"__vdso_getcpu\");\n      ptrdiff_t gettimeofday_offset =\n                              dmtcp_dlsym_lib_fnc_offset(\"linux-vdso\",\n                                                         \"__vdso_gettimeofday\");\n      ptrdiff_t time_offset = dmtcp_dlsym_lib_fnc_offset(\"linux-vdso\",\n                                                         \"__vdso_time\");\n      JWARNING(!_pInfo.vdsoOffsetMismatch(clock_gettime_offset, getcpu_offset,\n                                          gettimeofday_offset, time_offset))\n              .Text(\"The vDSO section on the current system is different than\"\n                    \" the host where the checkpoint image was generated. \"\n                    \"Restart may fail if the program calls a function in to\"\n                    \" vDSO, like, gettimeofday(), clock_gettime(), etc.\");\n      JTRACE(\"restore target\") (_path) (_pInfo.numPeers()) (_pInfo.compGroup());\n      JASSERT(_pInfo.getMaxUserFd() < PROTECTED_FD_START)\n             (_pInfo.getMaxUserFd())(PROTECTED_FD_START)\n             .Text(\"The fd limit on the system is lower \"\n\t           \"than required for restart\");\n    }\n\n    int fd() const { return _fd; }\n    const UniquePid& upid() const { return _pInfo.upid(); }\n    pid_t pid() const { return _pInfo.pid(); }\n    pid_t sid() const { return _pInfo.sid(); }\n    const string& procSelfExe() const { return _pInfo.procSelfExe(); }\n    bool isRootOfProcessTree() const {\n      return _pInfo.isRootOfProcessTree();\n    }\n\n    bool isOrphan() {\n        return _pInfo.isOrphan();\n    }\n\n    string procname() { return _pInfo.procname(); }\n    UniquePid compGroup() { return _pInfo.compGroup(); }\n    int numPeers() { return _pInfo.numPeers(); }\n    bool noCoordinator() { return _pInfo.noCoordinator(); }\n\n    void restoreGroup()\n    {\n      if (_pInfo.isGroupLeader()) {\n        // create new Group where this process becomes a leader\n        JTRACE(\"Create new Group.\");\n        setpgid(0, 0);\n      }\n    }\n\n    void createDependentChildProcess()\n    {\n      pid_t pid = fork();\n      JASSERT(pid != -1);\n      if (pid != 0) {\n        return;\n      }\n      createProcess();\n    }\n\n    void createDependentNonChildProcess()\n    {\n      pid_t pid = fork();\n      JASSERT(pid != -1);\n      if (pid == 0) {\n        pid_t gchild = fork();\n        JASSERT(gchild != -1);\n        if (gchild != 0) {\n          exit(0);\n        }\n        createProcess();\n      } else {\n        JASSERT(waitpid(pid, NULL, 0) == pid);\n      }\n    }\n\n    void createOrphanedProcess(bool createIndependentRootProcesses = false)\n    {\n      pid_t pid = fork();\n      JASSERT(pid != -1);\n      if (pid == 0) {\n        pid_t gchild = fork();\n        JASSERT(gchild != -1);\n        if (gchild != 0) {\n          exit(0);\n        }\n        createProcess(createIndependentRootProcesses);\n      } else {\n        JASSERT(waitpid(pid, NULL, 0) == pid);\n        exit(0);\n      }\n    }\n\n    void createProcess(bool createIndependentRootProcesses = false)\n    {\n      UniquePid::ThisProcess() = _pInfo.upid();\n      UniquePid::ParentProcess() = _pInfo.uppid();\n\n      if (createIndependentRootProcesses) {\n        DmtcpUniqueProcessId compId = _pInfo.compGroup().upid();\n        CoordinatorInfo coordInfo;\n        struct in_addr localIPAddr;\n        if (_pInfo.noCoordinator()) {\n          allowedModes = COORD_NONE;\n        }\n\n        // dmtcp_restart sets ENV_VAR_NAME_HOST/PORT, even if cmd line flag used\n        string host = \"\";\n        int port = UNINITIALIZED_PORT;\n        Util::getCoordHostAndPort(allowedModes, host, &port);\n        // FIXME:  We will use the new HOST and PORT here, but after restart,,\n        //           we will use the old HOST and PORT from the ckpt image.\n        CoordinatorAPI::instance().connectToCoordOnRestart(allowedModes,\n                                                           _pInfo.procname(),\n                                                           _pInfo.compGroup(),\n                                                           _pInfo.numPeers(),\n                                                           &coordInfo,\n                                                           host.c_str(),\n                                                           port,\n                                                           &localIPAddr);\n        // If port was 0, we'll get new random port when coordinator starts up.\n        Util::getCoordHostAndPort(allowedModes, host, &port);\n        Util::writeCoordPortToFile(port, thePortFile.c_str());\n\n        string installDir =\n          jalib::Filesystem::DirName(jalib::Filesystem::GetProgramDir());\n\n#if defined(__i386__) || defined(__arm__)\n        if (Util::strEndsWith(installDir, \"/lib/dmtcp/32\")) {\n          // If dmtcp_launch was compiled for 32 bits in 64-bit O/S, then note:\n          // DMTCP_ROOT/bin/dmtcp_launch is a symbolic link to:\n          //    DMTCP_ROOT/bin/dmtcp_launch/lib/dmtcp/32/bin\n          // GetProgramDir() followed the link.  So, need to remove the suffix.\n          char *str = const_cast<char*>(installDir.c_str());\n          str[strlen(str) - strlen(\"/lib/dmtcp/32\")] = '\\0';\n          installDir = str;\n        }\n#endif\n\n        /* We need to initialize SharedData here to make sure that it is\n         * initialized with the correct coordinator timestamp.  The coordinator\n         * timestamp is updated only during postCkpt callback. However, the\n         * SharedData area may be initialized earlier (for example, while\n         * recreating threads), causing it to use *older* timestamp.\n         */\n        SharedData::initialize(tmpDir.c_str(),\n                               installDir.c_str(),\n                               &compId,\n                               &coordInfo,\n                               &localIPAddr);\n        SharedData::setLogMask(mask);\n        Util::initializeLogFile(SharedData::getTmpDir(), _pInfo.procname());\n\n        Util::prepareDlsymWrapper();\n      }\n\n      JTRACE(\"Creating process during restart\") (upid()) (_pInfo.procname());\n\n      RestoreTargetMap::iterator it;\n      for (it = targets.begin(); it != targets.end(); it++) {\n        RestoreTarget *t = it->second;\n        if (_pInfo.upid() == t->_pInfo.upid()) {\n          continue;\n        } else if (_pInfo.isChild(t->upid()) &&\n                   t->_pInfo.sid() != _pInfo.pid()) {\n          t->createDependentChildProcess();\n        }\n      }\n\n      if (createIndependentRootProcesses) {\n        RestoreTargetMap::iterator it;\n        for (it = independentProcessTreeRoots.begin();\n             it != independentProcessTreeRoots.end();\n             it++) {\n          RestoreTarget *t = it->second;\n          if (t != this) {\n            t->createDependentNonChildProcess();\n          }\n        }\n      }\n\n      // If we were the session leader, become one now.\n      if (_pInfo.sid() == _pInfo.pid()) {\n        if (getsid(0) != _pInfo.pid()) {\n          JWARNING(setsid() != -1) (getsid(0)) (JASSERT_ERRNO)\n            .Text(\"Failed to restore this process as session leader.\");\n        }\n      }\n\n      // Now recreate processes with sid == _pid\n      for (it = targets.begin(); it != targets.end(); it++) {\n        RestoreTarget *t = it->second;\n        if (_pInfo.upid() == t->_pInfo.upid()) {\n          continue;\n        } else if (t->_pInfo.sid() == _pInfo.pid()) {\n          if (_pInfo.isChild(t->upid())) {\n            t->createDependentChildProcess();\n          } else if (t->isRootOfProcessTree()) {\n            t->createDependentNonChildProcess();\n          }\n        }\n      }\n\n      // Now close all open fds except _fd;\n      for (it = targets.begin(); it != targets.end(); it++) {\n        RestoreTarget *t = it->second;\n        if (t != this) {\n          close(t->fd());\n        }\n      }\n\n      string ckptDir = jalib::Filesystem::GetDeviceName(PROTECTED_CKPT_DIR_FD);\n      if (ckptDir.length() == 0) {\n        // Create the ckpt-dir fd so that the restarted process can know about\n        // the abs-path of ckpt-image.\n        string dirName = jalib::Filesystem::DirName(_path);\n        int dirfd = open(dirName.c_str(), O_RDONLY);\n        JASSERT(dirfd != -1) (JASSERT_ERRNO);\n        if (dirfd != PROTECTED_CKPT_DIR_FD) {\n          JASSERT(dup2(dirfd, PROTECTED_CKPT_DIR_FD) == PROTECTED_CKPT_DIR_FD);\n          close(dirfd);\n        }\n      }\n\n      if (!createIndependentRootProcesses) {\n        // dmtcp_restart sets ENV_VAR_NAME_HOST/PORT, even if cmd line flag used\n        string host = \"\";\n        int port = UNINITIALIZED_PORT;\n        int *port_p = &port;\n        Util::getCoordHostAndPort(allowedModes, host, port_p);\n        CoordinatorAPI::instance().connectToCoordOnRestart(allowedModes,\n                                                           _pInfo.procname(),\n                                                           _pInfo.compGroup(),\n                                                           _pInfo.numPeers(),\n                                                           NULL,\n                                                           host.c_str(),\n                                                           port,\n                                                           NULL);\n      }\n\n      setEnvironFd();\n      int is32bitElf = 0;\n\n#if defined(__x86_64__) || defined(__aarch64__)\n      is32bitElf = (_pInfo.elfType() == ProcessInfo::Elf_32);\n#elif defined(__i386__) || defined(__arm__)\n      is32bitElf = true;\n#endif\n\n\n      runMtcpRestart(is32bitElf, _fd, &_pInfo);\n\n      JASSERT ( false ).Text ( \"unreachable\" );\n    }\n\n  private:\n    string _path;\n    ProcessInfo _pInfo;\n    int _fd;\n};\n\nstatic void runMtcpRestart(int is32bitElf, int fd, ProcessInfo *pInfo)\n{\n  char fdBuf[8];\n  char stderrFdBuf[8];\n  sprintf(fdBuf, \"%d\", fd);\n  sprintf(stderrFdBuf, \"%u\", (unsigned int)PROTECTED_STDERR_FD);\n\n#ifdef HAS_PR_SET_PTRACER\n  if (getenv(\"DMTCP_GDB_ATTACH_ON_RESTART\")) {\n    JNOTE(\"\\n     *******************************************************\\n\"\n          \"     *** Environment variable, DMTCP_GDB_ATTACH_ON_RESTART is set\\n\"\n          \"     *** You can attach to the running process as follows:\\n\"\n          \"     ***     gdb _PROGRAM_NAME_ PID  [See below for PID.]\\n\"\n          \"     *** NOTE:  This mode can be a security risk.\\n\"\n          \"     ***        Do not set the env. variable normally.\\n\"\n          \"     *******************************************************\")\n         (getpid());\n    prctl(PR_SET_PTRACER, PR_SET_PTRACER_ANY, 0, 0, 0); // Allow 'gdb attach'\n  }\n#endif\n\n  if (requestedDebugLevel > 0) {\n    int debugPipe[2];\n    socketpair(AF_UNIX, SOCK_STREAM, 0, debugPipe);\n    pid_t pid = fork();\n    if (pid > 0) {\n      int currentDebugLevel = 0;\n      int rc = -1;\n      close(debugPipe[1]);\n      do {\n        rc = read(debugPipe[0], &currentDebugLevel, sizeof(currentDebugLevel));\n        if (rc < 0) break;\n        rc = write(debugPipe[0], &requestedDebugLevel, sizeof(currentDebugLevel));\n        if (rc < 0) break;\n      } while (currentDebugLevel != requestedDebugLevel);\n      if (rc < 0) {\n        int status;\n        waitpid(pid, &status, 0);\n      }\n      char cpid[11]; // XXX: Is 10 digits for long PID plus a terminating null\n      snprintf(cpid, 11, \"%ld\", (long unsigned)pid);\n      char* const cmdArgs[] = {const_cast<char*>(pInfo->procSelfExe().c_str()),\n                               cpid,\n                               NULL};\n      execvp(\"gdb\", cmdArgs);\n    } else if (pid == 0) {\n      close(debugPipe[0]); // child doesn't need the read end\n      JASSERT(dup2(debugPipe[1], PROTECTED_DEBUG_SOCKET_FD)\n              == PROTECTED_DEBUG_SOCKET_FD)(JASSERT_ERRNO);\n      close(debugPipe[1]);\n    } else {\n     JASSERT(false)(JASSERT_ERRNO).Text(\"Fork failed\");\n    }\n  }\n\n  static string mtcprestart = Util::getPath (\"mtcp_restart\");\n\n#if defined(__x86_64__) || defined(__aarch64__) || defined(CONFIG_M32)\n  // FIXME: This is needed for CONFIG_M32 only because getPath(\"mtcp_restart\")\n  //        fails to return the absolute path for mtcprestart.  We should fix\n  //        the bug in Util::getPath() and remove CONFIG_M32 condition in #if.\n  if (is32bitElf) {\n    mtcprestart = Util::getPath(\"mtcp_restart-32\", is32bitElf);\n  }\n#endif\n\n  /* If DMTCP_RESTART_PAUSE>1, mtcp_restart will loop until gdb attach.*/\n  int mtcp_restart_pause = 0;\n  char * pause_param = getenv(\"DMTCP_RESTART_PAUSE\");\n  if (pause_param == NULL) {\n    pause_param = getenv(\"MTCP_RESTART_PAUSE\");\n  }\n  if (pause_param != NULL && pause_param[0] >= '1' && pause_param[0] <= '4'\n                          && pause_param[1] == '\\0') {\n#ifdef HAS_PR_SET_PTRACER\n    prctl(PR_SET_PTRACER, PR_SET_PTRACER_ANY, 0, 0, 0); // For: gdb attach\n#endif // ifdef HAS_PR_SET_PTRACER\n    mtcp_restart_pause = pause_param[0] - '0';\n    // If mtcp_restart_pause == true, mtcp_restart will invoke\n    //     postRestartDebug() in the checkpoint image instead of postRestart().\n  }\n\n  char *const newArgs[] = {\n    (char *)mtcprestart.c_str(),\n    const_cast<char *>(\"--fd\"), fdBuf,\n    const_cast<char *>(\"--stderr-fd\"), stderrFdBuf,\n    // These two flag must be last, since they may become NULL\n    ( mtcp_restart_pause ? const_cast<char *>(\"--mtcp-restart-pause\") : NULL ),\n    ( mtcp_restart_pause ? pause_param : NULL ),\n    NULL\n  };\n\n  execve (newArgs[0], newArgs, environ);\n  JASSERT (false) (newArgs[0]) (newArgs[1]) (JASSERT_ERRNO)\n    .Text (\"exec() failed\");\n}\n\n// ************************ For reading checkpoint files *****************\n\nint readCkptHeader(const string& path, ProcessInfo *pInfo)\n{\n  int fd = openCkptFileToRead(path);\n  const size_t len = strlen(DMTCP_FILE_HEADER);\n\n  jalib::JBinarySerializeReaderRaw rdr(\"\", fd);\n  pInfo->serialize(rdr);\n  size_t numRead = len + rdr.bytes();\n\n  // We must read in multiple of PAGE_SIZE\n  const ssize_t pagesize = Util::pageSize();\n  ssize_t remaining = pagesize - (numRead % pagesize);\n  char buf[remaining];\n  JASSERT(Util::readAll(fd, buf, remaining) == remaining);\n  return fd;\n}\n\nstatic char first_char(const char *filename)\n{\n  int fd, rc;\n  char c;\n\n  fd = open(filename, O_RDONLY);\n  JASSERT(fd >= 0) (filename) .Text(\"ERROR: Cannot open filename\");\n\n  rc = read(fd, &c, 1);\n  JASSERT(rc == 1) (filename) .Text(\"ERROR: Error reading from filename\");\n\n  close(fd);\n  return c;\n}\n\n// Copied from mtcp/mtcp_restart.c.\n// Let's keep this code close to MTCP code to avoid maintenance problems.\n// MTCP code in:  mtcp/mtcp_restart.c:open_ckpt_to_read()\n// A previous version tried to replace this with popen, causing a regression:\n//   (no call to pclose, and possibility of using a wrong fd).\n// Returns fd;\nstatic int open_ckpt_to_read(const char *filename)\n{\n  int fd;\n  int fds[2];\n  char fc;\n  const char *decomp_path;\n  const char **decomp_args;\n  const char *gzip_path = \"gzip\";\n  static const char * gzip_args[] = {\n    const_cast<char*> (\"gzip\"),\n    const_cast<char*> (\"-d\"),\n    const_cast<char*> (\"-\"),\n    NULL\n  };\n#ifdef HBICT_DELTACOMP\n  const char *hbict_path = const_cast<char*> (\"hbict\");\n  static const char *hbict_args[] = {\n    const_cast<char*> (\"hbict\"),\n    const_cast<char*> (\"-r\"),\n    NULL\n  };\n#endif\n  pid_t cpid;\n\n  fc = first_char(filename);\n  fd = open(filename, O_RDONLY);\n  JASSERT(fd>=0)(filename).Text(\"Failed to open file.\");\n\n  if (fc == DMTCP_MAGIC_FIRST) { /* no compression */\n    return fd;\n  }\n  else if (fc == GZIP_FIRST\n#ifdef HBICT_DELTACOMP\n           || fc == HBICT_FIRST\n#endif\n          ) {\n    if (fc == GZIP_FIRST) {\n      decomp_path = gzip_path;\n      decomp_args = gzip_args;\n    }\n#ifdef HBICT_DELTACOMP\n    else {\n      decomp_path = hbict_path;\n      decomp_args = hbict_args;\n    }\n#endif\n\n    JASSERT(pipe(fds) != -1) (filename)\n      .Text(\"Cannot create pipe to execute gunzip to decompress ckpt file!\");\n\n    cpid = fork();\n\n    JASSERT(cpid != -1)\n      .Text(\"ERROR: Cannot fork to execute gunzip to decompress ckpt file!\");\n    if (cpid > 0) { /* parent process */\n      JTRACE(\"created child process to uncompress checkpoint file\") (cpid);\n      close(fd);\n      close(fds[1]);\n      // Wait for child process\n      JASSERT(waitpid(cpid, NULL, 0) == cpid);\n      return fds[0];\n    } else { /* child process */\n      /* Fork a grandchild process and kill the parent. This way the grandchild\n       * process never becomes a zombie.\n       *\n       * Sometimes dmtcp_restart is called with multiple ckpt images. In that\n       * situation, the dmtcp_restart process creates gzip processes and only\n       * later forks mtcp_restart processes. The gzip processes can not be\n       * wait()'d upon by the corresponding mtcp_restart processes because\n       * their parent is the original dmtcp_restart process and thus they\n       * become zombie.\n       */\n      cpid = fork();\n      JASSERT(cpid != -1);\n      if (cpid > 0) {\n        // Use _exit() instead of exit() to avoid popping atexit() handlers\n        // registered by the parent process.\n        _exit(0);\n      }\n\n      // Grandchild process\n      JTRACE ( \"child process, will exec into external de-compressor\");\n      fd = dup(dup(dup(fd)));\n      fds[1] = dup(fds[1]);\n      close(fds[0]);\n      JASSERT(fd != -1);\n      JASSERT(dup2(fd, STDIN_FILENO) == STDIN_FILENO);\n      close(fd);\n      JASSERT(dup2(fds[1], STDOUT_FILENO) == STDOUT_FILENO);\n      close(fds[1]);\n      execvp(decomp_path, (char **)decomp_args);\n      JASSERT(decomp_path!=NULL) (decomp_path)\n        .Text(\"Failed to launch gzip.\");\n      /* should not get here */\n      JASSERT(false)\n        .Text(\"Decompression failed!  No restoration will be performed!\");\n    }\n  } else { /* invalid magic number */\n    JASSERT(false)\n      .Text(\"ERROR: Invalid magic number in this checkpoint file!\");\n  }\n  return -1;\n}\n\n// See comments above for open_ckpt_to_read()\nint openCkptFileToRead(const string& path)\n{\n  char buf[1024];\n  int fd = open_ckpt_to_read(path.c_str());\n  // The rest of this function is for compatibility with original definition.\n  JASSERT(fd >= 0) (path) .Text(\"Failed to open file.\");\n  const int len = strlen(DMTCP_FILE_HEADER);\n  JASSERT(read(fd, buf, len) == len)(path) .Text(\"read() failed\");\n  if (strncmp(buf, DMTCP_FILE_HEADER, len) == 0) {\n    JTRACE(\"opened checkpoint file [uncompressed]\")(path);\n  } else {\n    close(fd);\n    fd = open_ckpt_to_read(path.c_str()); /* Re-open from beginning */\n    JASSERT(fd >= 0) (path) .Text(\"Failed to open file.\");\n  }\n  return fd;\n}\n// ************************ End of for reading checkpoint files *************\n\n\nstatic void setEnvironFd()\n{\n  char envFile[PATH_MAX];\n  sprintf(envFile, \"%s/envFile.XXXXXX\", tmpDir.c_str());\n  int fd = mkstemp(envFile);\n  JASSERT(fd != -1) (envFile) (JASSERT_ERRNO);\n  JASSERT(unlink(envFile) == 0) (envFile) (JASSERT_ERRNO);\n  JASSERT(dup2(fd, PROTECTED_ENVIRON_FD) == PROTECTED_ENVIRON_FD)\n    (JASSERT_ERRNO);\n  JASSERT(close(fd) == 0);\n  fd = PROTECTED_ENVIRON_FD;\n\n  char **env = environ;\n  while (*env != NULL) {\n    Util::writeAll(fd, *env, strlen(*env) + 1); // Also write null character\n    env++;\n  }\n  Util::writeAll(fd, *env, 1); // Write final null character\n}\n\nstatic void setNewCkptDir(char *path)\n{\n  struct stat st;\n  if (stat(path, &st) == -1) {\n    JASSERT(mkdir(path, S_IRWXU) == 0 || errno == EEXIST)\n      (JASSERT_ERRNO) (path)\n      .Text(\"Error creating checkpoint directory\");\n    JASSERT(0 == access(path, X_OK|W_OK)) (path)\n      .Text(\"ERROR: Missing execute- or write-access to checkpoint dir\");\n  } else {\n    JASSERT(S_ISDIR(st.st_mode)) (path) .Text(\"ckptdir not a directory\");\n  }\n\n  int fd = open(path, O_RDONLY);\n  JASSERT(fd != -1) (path);\n  JASSERT(dup2(fd, PROTECTED_CKPT_DIR_FD) == PROTECTED_CKPT_DIR_FD)\n    (fd) (path);\n  if (fd != PROTECTED_CKPT_DIR_FD) {\n    close(fd);\n  }\n}\n\n//shift args\n#define shift argc--,argv++\n\nint main(int argc, char** argv)\n{\n  char *tmpdir_arg = NULL;\n  char *ckptdir_arg = NULL;\n\n  Util::setProtectedFdBase();\n\n  initializeJalib();\n\n  if (!getenv(ENV_VAR_QUIET)) {\n    setenv(ENV_VAR_QUIET, \"0\", 0);\n  }\n\n  if (getenv(ENV_VAR_DISABLE_STRICT_CHECKING)) {\n    noStrictChecking = true;\n  }\n\n  if (getenv(ENV_VAR_CHECKPOINT_DIR)) {\n    ckptdir_arg = getenv(ENV_VAR_CHECKPOINT_DIR);\n  }\n\n  if (argc == 1) {\n    printf(\"%s\", DMTCP_VERSION_AND_COPYRIGHT_INFO);\n    printf(\"(For help: %s --help)\\n\\n\", argv[0]);\n    return DMTCP_FAIL_RC;\n  }\n\n  //process args\n  shift;\n  while (true) {\n    string s = argc>0 ? argv[0] : \"--help\";\n    if (s == \"--help\" && argc == 1) {\n      printf(\"%s\", theUsage);\n      return DMTCP_FAIL_RC;\n    } else if ((s == \"--version\") && argc == 1) {\n      printf(\"%s\", DMTCP_VERSION_AND_COPYRIGHT_INFO);\n      return DMTCP_FAIL_RC;\n    } else if (s == \"-j\" || s == \"--join-coordinator\" || s == \"--join\") {\n      allowedModes = COORD_JOIN;\n      shift;\n    } else if (s == \"--new-coordinator\") {\n      allowedModes = COORD_NEW;\n      shift;\n    } else if (s == \"--no-strict-checking\") {\n      noStrictChecking = true;\n      shift;\n    } else if (s == \"-i\" || s == \"--interval\") {\n      setenv(ENV_VAR_CKPT_INTR, argv[1], 1);\n      shift; shift;\n    } else if (s == \"--coord-logfile\") {\n      setenv(ENV_VAR_COORD_LOGFILE, argv[1], 1);\n      shift; shift;\n    } else if (s == \"--debug-logs\") {\n      mask = Util::processDebugLogsArg(argv[1]);\n    } else if (s == \"--debug-restart-pause\") {\n      JASSERT(argv[1] && argv[1][0] >= '1' && argv[1][0] <= '4'\n                      && argv[1][1] == '\\0')\n        .Text(\"--debug-restart-pause requires arg. of '1', '2', '3' or '4'\");\n      setenv(\"DMTCP_RESTART_PAUSE\", argv[1], 1);\n      shift; shift;\n    } else if (argv[0][0] == '-' && argv[0][1] == 'i' &&\n               isdigit(argv[0][2])) { // else if -i5, for example\n      setenv(ENV_VAR_CKPT_INTR, argv[0]+2, 1);\n      shift;\n    } else if (argc > 1 && (s == \"-h\" || s == \"--coord-host\" || s == \"--host\")){\n      setenv(ENV_VAR_NAME_HOST, argv[1], 1);\n      shift; shift;\n    } else if (argc>1 && (s == \"-p\" || s == \"--coord-port\" || s == \"--port\")) {\n      setenv(ENV_VAR_NAME_PORT, argv[1], 1);\n      shift; shift;\n    } else if (argv[0][0] == '-' && argv[0][1] == 'p' &&\n               isdigit(argv[0][2])) { // else if -p0, for example\n      setenv(ENV_VAR_NAME_PORT, argv[0]+2, 1);\n      shift;\n    } else if (argc>1 && s == \"--port-file\"){\n      thePortFile = argv[1];\n      shift; shift;\n    } else if (argc > 1 && (s == \"-c\" || s == \"--ckptdir\")) {\n      ckptdir_arg = argv[1];\n      shift; shift;\n    } else if (argc > 1 && (s == \"-t\" || s == \"--tmpdir\")) {\n      tmpdir_arg = argv[1];\n      shift; shift;\n    } else if (argc > 1 && (s == \"--gdb\")) {\n      requestedDebugLevel = atoi(argv[1]);\n      shift; shift;\n    } else if (s == \"-q\" || s == \"--quiet\") {\n      *getenv(ENV_VAR_QUIET) = *getenv(ENV_VAR_QUIET) + 1;\n      // Just in case a non-standard version of setenv is being used:\n      setenv(ENV_VAR_QUIET, getenv(ENV_VAR_QUIET), 1);\n      shift;\n    } else if ((s.length() > 2 && s.substr(0, 2) == \"--\") ||\n               (s.length() > 1 && s.substr(0, 1) == \"-\")) {\n      printf(\"Invalid Argument\\n%s\", theUsage);\n      return DMTCP_FAIL_RC;\n    } else if (argc > 1 && s == \"--\") {\n      shift;\n      break;\n    } else {\n      break;\n    }\n  }\n\n  tmpDir = Util::calcTmpDir(tmpdir_arg);\n  if (ckptdir_arg) {\n    setNewCkptDir(ckptdir_arg);\n  }\n\n  jassert_quiet = *getenv(ENV_VAR_QUIET) - '0';\n\n  //make sure JASSERT initializes now, rather than during restart\n  Util::initializeLogFile(tmpDir);\n\n  if (!noStrictChecking && jassert_quiet < 2 &&\n      (getuid() == 0 || geteuid() == 0)) {\n    JASSERT_STDERR <<\n      \"WARNING:  Running dmtcp_restart as root can be dangerous.\\n\"\n      \"  An unknown checkpoint image or bugs in DMTCP may lead to unforeseen\\n\"\n      \"  consequences.  Continuing as root ....\\n\";\n  }\n\n  JTRACE(\"New dmtcp_restart process; _argc_ ckpt images\") (argc);\n\n  bool doAbort = false;\n  for (; argc > 0; shift) {\n    string restorename(argv[0]);\n    struct stat buf;\n    int rc = stat(restorename.c_str(), &buf);\n    if (Util::strEndsWith(restorename, \"_files\")) {\n      continue;\n    } else if (!Util::strEndsWith(restorename, \".dmtcp\")) {\n      JNOTE(\"File doesn't have .dmtcp extension. Check Usage.\") (restorename);\n      // Don't test for --quiet here.  We're aborting.  We need to say why.\n      JASSERT_STDERR << theUsage;\n      doAbort = true;\n    } else if (rc == -1) {\n      char error_msg[1024];\n      sprintf(error_msg, \"\\ndmtcp_restart: ckpt image %s\", restorename.c_str());\n      perror(error_msg);\n      doAbort = true;\n    } else if (buf.st_uid != getuid() && !noStrictChecking) {\n      /*Could also run if geteuid() matches*/\n      printf(\"\\nProcess uid (%d) doesn't match uid (%d) of\\n\" \\\n             \"checkpoint image (%s).\\n\" \\\n\t     \"This is dangerous.  Aborting for security reasons.\\n\" \\\n             \"If you still want to do this, then re-run dmtcp_restart\\n\" \\\n             \"  with the --no-strict-checking flag.\\n\",\n             getuid(), buf.st_uid, restorename.c_str());\n      doAbort = true;\n    }\n    if (doAbort) {\n      exit(DMTCP_FAIL_RC);\n    }\n\n    JTRACE(\"Will restart ckpt image\") (argv[0]);\n    RestoreTarget *t = new RestoreTarget(argv[0]);\n    targets[t->upid()] = t;\n  }\n\n  // Prepare list of independent process tree roots\n  RestoreTargetMap::iterator i;\n  for (i = targets.begin(); i != targets.end(); i++) {\n    RestoreTarget *t1 = i->second;\n    if (t1->isRootOfProcessTree()) {\n      RestoreTargetMap::iterator j;\n      for (j = targets.begin(); j != targets.end(); j++) {\n        RestoreTarget *t2 = j->second;\n        if (t1 == t2) continue;\n        if (t1->sid() == t2->pid()) {\n          break;\n        }\n      }\n      if (j == targets.end()) {\n        independentProcessTreeRoots[t1->upid()] = t1;\n      }\n    }\n  }\n  JASSERT(independentProcessTreeRoots.size() > 0)\n    .Text(\"There must be at least one process tree that doesn't have\\n\"\n          \"  a different process as session leader.\");\n\n  WorkerState::setCurrentState(WorkerState::RESTARTING);\n\n  /* Try to find non-orphaned process in independent procs list */\n  RestoreTarget *t = NULL;\n  bool foundNonOrphan = false;\n  RestoreTargetMap::iterator it;\n  for (it = independentProcessTreeRoots.begin();\n       it != independentProcessTreeRoots.end();\n       it++) {\n    t = it->second;\n    if ( !t->isOrphan() ) {\n      foundNonOrphan = true;\n      break;\n    }\n  }\n\n  JASSERT(t != NULL);\n  JASSERT(t->pid() != 0);\n  JASSERT(!t->noCoordinator() || allowedModes == COORD_ANY)\n   .Text(\"Process had no coordinator prior to checkpoint;\\n\"\n         \"  but either --join-coordinator or --new-coordinator was specified.\");\n\n  if( foundNonOrphan ){\n    t->createProcess(true);\n  } else {\n      /* we were unable to find any non-orphaned procs.\n       * pick the first one and orphan it */\n      t = independentProcessTreeRoots.begin()->second;\n      t->createOrphanedProcess(true);\n  }\n\n  JASSERT(false).Text(\"unreachable\");\n  return -1;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/src/dmtcp_dlsym.cpp": "/****************************************************************************\n *   Copyright (C) 2014 by Gene Cooperman                                   *\n *   gene@ccs.neu.edu                                                       *\n *                                                                          *\n *  This file is part of DMTCP.                                             *\n *                                                                          *\n *  DMTCP is free software: you can redistribute it and/or                  *\n *  modify it under the terms of the GNU Lesser General Public License as   *\n *  published by the Free Software Foundation, either version 3 of the      *\n *  License, or (at your option) any later version.                         *\n *                                                                          *\n *  DMTCP is distributed in the hope that it will be useful,                *\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of          *\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *\n *  GNU Lesser General Public License for more details.                     *\n *                                                                          *\n *  You should have received a copy of the GNU Lesser General Public        *\n *  License along with DMTCP:dmtcp/src.  If not, see                        *\n *  <http://www.gnu.org/licenses/>.                                         *\n ****************************************************************************/\n\n/* USAGE:\n * #include \"dmtcp_dlsym.h\"\n * ... dmtcp_dlsym(RTLD_NEXT, ...) ...\n */\n\n/* THEORY:  A versioned symbol consists of multiple symbols, one for\n * each version.  Each symbol entry in the dynsym section (which becomes the\n * same as the symtab section when loaded in memory) should have a\n * corresponding entry in the symtab section.  So, the dynsym array values\n * can be viewed as an extra field of the symtab array of structs.\n * The dynsym entry (value) is a version index to the version string\n * for that symbol.  The version string is indicated by an entry in the\n * versym section with the same version index.  (versym is an array of strings)\n *     The dynsym entry can also have the 'hidden' bit (bit 15) set.  For a\n * given * symbol name, there should be exactly one symbol of that name for\n * which the hidden bit is not set.  This is the default version.  The normal\n * \"static linker\" (at load time) should only link to the base version (version\n * given by index 1 or 2 in the versym section).  The \"dynamic linker\"\n * (invoked by dlopen) tries first for a base version, and if not found,\n * then hopes for a unique versioned symbol.  (It seems that in all of\n * the above, the linker will always ignore a hidden symbol for these\n * purposes.  Unfortunately, dlsym doesn't follow the same policy as the\n * static or dynamic linker.  Hence, dmtcp_dlsym tries to replicate\n * that policy of preferring non-hidden symbols always.)\n *     The symbol pthread_cond_broadcast is a good test case.  It seems to\n * have its base version referenced as a hidden symbol, and only a non-base\n * version exists as unhidden.  Unfortunately, dlsym still chooses the\n * hidden base definition.\n *     Is this a bug in dlsym?  Or maybe just a bug in the 'man dlsym'\n * description?  Since versioning is not POSIX, it's difficult to say.\n */\n\n// Uncomment this to see what symbols and versions are chosen.\n// #define VERBOSE\n\n#ifndef _GNU_SOURCE\n# define _GNU_SOURCE\n#endif\n#include <link.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#ifndef _GNU_SOURCE\n# define _GNU_SOURCE\n#endif\n#include <dlfcn.h>\n\n#include \"dmtcp_dlsym.h\"\n#include \"jassert.h\"\n#include \"config.h\"\n\n// ***** NOTE:  link.h invokes elf.h, which:\n// *****        expands ElfW(Word)  to  Elf64_Word; and then defines:\n// *****        typedef uint32_t Elf63_Word;\n\n// older sysv standard\nstatic unsigned long elf_hash(const char *name) {\n  unsigned long h = 0, g;\n  while (*name) {\n    h = (h << 4) + *name++;\n    if ((g = h & 0xf0000000)) {\n      h ^= g >> 24;\n    }\n    h &= ~g;\n  }\n  return h;\n}\n\n// For GNU standard, below, see:\n//   https://blogs.oracle.com/ali/entry/gnu_hash_elf_sections\n//   http://deroko.phearless.org/dt_gnu_hash.txt\n//   glibc:elf/dl-lookup.c:do_lookup_x()\n//     See:  dl_setup_hash()  and  Elf32_Word bucket = map->l_gnu_buckets  ...\n\n// GNU standard\n#if 0\nstatic uint32_t elf_gnu_hash(const char *s) {\n  uint32_t h = 5381;\n  unsigned char c;\n  for (c = *s; c != '\\0'; c = *++s)\n    h = h * 33 + c;\n  return h;\n}\n#elif 0\n// From binutils:bfd/elf.c:bfd_elf_gnu_hash()\nunsigned long elf_gnu_hash (const char *namearg)\n{\n  const unsigned char *name = (const unsigned char *) namearg;\n  unsigned long h = 5381;\n  unsigned char ch;\n\n  while ((ch = *name++) != '\\0')\n    h = (h << 5) + h + ch;\n  return h & 0xffffffff;\n}\n#else\n// From glibc-2.19\nstatic uint_fast32_t elf_gnu_hash (const char *s)\n{\n  uint_fast32_t h = 5381;\n  unsigned char c;\n  for (c = *s; c != '\\0'; c = *++s)\n    h = h * 33 + c;\n  return h & 0xffffffff;\n}\n#endif\n\nstatic Elf32_Word hash_first(const char *name, Elf32_Word *hash_table,\n                             int use_gnu_hash) {\n  if (use_gnu_hash) {\n    uint32_t nbuckets = ((uint32_t*)hash_table)[0];\n    // uint32_t symndx = ((uint32_t*)hash_table)[1];\n    uint32_t maskwords = ((uint32_t*)hash_table)[2];\n    uint32_t *buckets = (uint32_t *)\n      ((char *)hash_table + 4*sizeof(uint32_t) + maskwords*sizeof(long unsigned int));\n    // uint32_t *hashval = & buckets[nbuckets];\n    if (buckets[elf_gnu_hash(name) % nbuckets])\n      return buckets[elf_gnu_hash(name) % nbuckets];\n    else\n      return STN_UNDEF;\n  } else {\n    // http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#hash\n    Elf32_Word nbucket = *hash_table++;\n    hash_table++; // Elf32_Word nchain = *hash_table++; // Note: nchain same as n_symtab\n    Elf32_Word *bucket = hash_table;\n    // Elf32_Word *chain = hash_table + nbucket;\n    return bucket[elf_hash(name) % nbucket]; // return index into symbol table\n  }\n}\n\nstatic Elf32_Word hash_next(Elf32_Word index, Elf32_Word *hash_table,\n                            int use_gnu_hash) {\n  if (use_gnu_hash) {\n    JASSERT( index > STN_UNDEF );\n    uint32_t nbuckets = ((uint32_t*)hash_table)[0];\n    uint32_t symndx = ((uint32_t*)hash_table)[1];\n    uint32_t maskwords = ((uint32_t*)hash_table)[2];\n    uint32_t *hashval = (uint32_t *)\n      ((char *)hash_table + 4*sizeof(uint32_t) /* sizeof header */\n       + maskwords*sizeof(long unsigned int) /* sizeof Bloom filter */\n       + nbuckets*sizeof(Elf32_Word) /* sizeof hash buckets */\n      );\n    if (hashval[index - symndx] & 1)\n      return STN_UNDEF;  // end-of-chain indicator\n    else\n      return index+1;\n  } else {\n    Elf32_Word nbucket = *hash_table++;\n    hash_table++; // Elf32_Word nchain = *hash_table++;\n    // Elf32_Word *bucket = hash_table;\n    Elf32_Word *chain = hash_table + nbucket;\n    return chain[index]; // If this returns STN_UNDEF, then it's end of chain\n  }\n}\n\ntypedef struct dt_tag{\n    char *base_addr; /* Base address shared object is loaded at. */\n    // ElfW(Sym) *dynsym; // On disk, dynsym would be dynamic symbols only\n    ElfW(Sym) *symtab; // Same as dynsym, for in-memory symbol table.\n    // ElfW(Word) n_symtab;\n    ElfW(Half) *versym;\n    /* elf.h lies.  DT_VERDEF is offset from base_addr, not addr. */\n    ElfW(Verdef) *verdef;\n    ElfW(Word) verdefnum;\n    // ElfW(Word) first_ext_def;\n    char *strtab;\n    Elf32_Word *hash;\n    Elf32_Word *gnu_hash;\n} dt_tag;\n\nstatic char *symbol_name(int i, dt_tag *tags) {\n  return tags->strtab + tags->symtab[i].st_name;\n}\n\nstatic char *version_name(ElfW(Word) version_ndx, dt_tag *tags) {\n    ElfW(Verdef) *cur, *prev;\n\n    // Remove hidden bit, if it's set.\n    if (version_ndx & (1<<15))\n      version_ndx -= (1<<15);\n    // Walk the list of all versions.\n    for (prev = NULL, cur = tags->verdef;\n         // Could alternatively use verdefnum (DT_VERDEFNUM) here.\n         cur != prev;\n         prev = cur, cur = (ElfW(Verdef)*)(((char *)cur)+cur->vd_next))\n    {\n      JASSERT (cur->vd_version == 1);\n      if (cur->vd_ndx == version_ndx) {\n        ElfW(Verdaux) *first = (ElfW(Verdaux) *)(((char *)cur)+cur->vd_aux);\n        return tags->strtab + first->vda_name;\n      }\n    }\n    return NULL;  // failed to find version name\n}\n\n// Note that the dynamic section is usually also a segment by itself.\n// [ 'readelf -l libXXX.so' to verify. ]\n// So, we don't need the object handle.  Its base address is enough,\n//   and we can then read the program header to get the right segment.\n// Also, the _DYNAMIC symbol in a section should also be a pointer to\n//   the address of the dynamic section.  (See comment in /usr/include/link.h)\nstatic void get_dt_tags(void *handle, dt_tag *tags) {\n    struct link_map *lmap;  // from /usr/include/link.h\n\n    /* The handle we get here is either from an earlier call to\n     * dlopen(), or from a call to dladdr(). In both the cases,\n     * the handle corresponds to a link_map node.\n     */\n    lmap = (link_map *) handle;\n    ElfW(Dyn) * dyn = lmap->l_ld;     // from /usr/include/link.h\n    // http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#dynamic_section\n    /* Base address shared object is loaded at. (from /usr/include/lnik.h) */\n    tags->base_addr = (char *)(lmap->l_addr);\n\n    tags->symtab = NULL;\n    tags->versym = NULL;\n    tags->verdef = NULL;\n    tags->strtab = NULL;\n    tags->hash = NULL;\n    tags->gnu_hash = NULL;\n    tags->verdefnum = 0;\n\n    ElfW(Dyn) *cur_dyn;\n\n/*\n * This code extends dmtcp_dlsym to work on VDSO, while in libc, they have a\n * separate internal vdso_dlsym function for this purpose.\n *\n * For libraries loaded by RTLD, the DT_* entries are patched at load time.\n * Here's an example call trace:\n *   _start()\n *     ...\n *     dl_main()\n *       ...\n *       _dl_map_object()\n *         _dl_map_object_from_fd()\n *           _dl_map_segments()\n *           elf_get_dynamic_info()\n *\n * The elf_get_dynamic_info() function changes the DT_* entries from\n * relative offsets to absolute addresses.\n *\n * For cases where the DSO is *not* loaded by RTLD, like vDSO (with read-only\n * data), we need to manually adjust at access time.\n */\n\n// Note that the dynamic tags for the sections of the virtual\n//   library, linux-vdso.so, have to be handled specially, since their d_ptr\n//   is an offset, and not an absolute address.\n// QUESTION:\n//   Since we handle linux-vdso.so directly, what is the \"else\" condition for?\n#define ADJUST_DYN_INFO_RO(dst, map, dyn)                   \\\n  if ( strstr(map->l_name, \"linux-vdso.so\") ) {             \\\n    dst = (__typeof(dst))(map->l_addr + dyn->d_un.d_ptr);   \\\n  } else if (dyn->d_un.d_ptr > map->l_addr) {               \\\n    dst = (__typeof(dst))dyn->d_un.d_ptr;                   \\\n  } else {                                                  \\\n    dst = (__typeof(dst))(map->l_addr + dyn->d_un.d_ptr);   \\\n  }\n\n    // The _DYNAMIC symbol should be pointer to address of the dynamic section.\n    // printf(\"dyn: %p; _DYNAMIC: %p\\n\", dyn, _DYNAMIC);\n    for (cur_dyn = dyn; cur_dyn->d_tag != DT_NULL;  cur_dyn++) {\n      if (cur_dyn->d_tag == DT_VERSYM) {\n        ADJUST_DYN_INFO_RO(tags->versym, lmap, cur_dyn);\n      }\n      if (cur_dyn->d_tag == DT_VERDEF) {\n        ADJUST_DYN_INFO_RO(tags->verdef, lmap, cur_dyn);\n      }\n      if (cur_dyn->d_tag == DT_VERDEFNUM)\n        tags->verdefnum = (ElfW(Word))cur_dyn->d_un.d_val;\n      if (cur_dyn->d_tag == DT_STRTAB && tags->strtab == 0) {\n        ADJUST_DYN_INFO_RO(tags->strtab, lmap, cur_dyn);\n      }\n      // Not DT_DYNSYM, since only dynsym section loaded into RAM; not symtab.??\n      //   So, DT_SYMTAB refers to dynsym section ??\n      if (cur_dyn->d_tag == DT_SYMTAB) {\n        ADJUST_DYN_INFO_RO(tags->symtab, lmap, cur_dyn);\n      }\n      if (cur_dyn->d_tag == DT_HASH) {\n        ADJUST_DYN_INFO_RO(tags->hash, lmap, cur_dyn);\n      }\n#ifdef HAS_GNU_HASH\n      if (cur_dyn->d_tag == DT_GNU_HASH) {\n        ADJUST_DYN_INFO_RO(tags->gnu_hash, lmap, cur_dyn);\n      }\n#endif\n      //if (cur_dyn->d_tag == DT_MIPS_SYMTABNO) // Number of DYNSYM entries\n      //  n_symtab = (ElfW(Word))cur_dyn->d_un.d_val;\n      //if (cur_dyn->d_tag == DT_MIPS_UNREFEXTNO)  // First external DYNSYM\n      //  first_ext_def = (ElfW(Word))cur_dyn->d_un.d_val;  // first dynsym entry??\n    }\n}\n\n// Given a handle for a library (not RTLD_DEFAULT or RTLD_NEXT), retrieves the\n// default symbol for the given symbol if it exists in that library.\n// Also sets the tags and default_symbol_index for usage later\nvoid *dlsym_default_internal_library_handler(void *handle, const char*symbol,\n                                             const char *version,\n                                             dt_tag *tags_p,\n                                             Elf32_Word *default_symbol_index_p)\n{\n  dt_tag tags;\n  Elf32_Word default_symbol_index = 0;\n  Elf32_Word i;\n  uint32_t numNonHiddenSymbols = 0;\n\n  get_dt_tags(handle, &tags);\n  JASSERT(tags.hash != NULL || tags.gnu_hash != NULL);\n  int use_gnu_hash = (tags.hash == NULL);\n  Elf32_Word *hash = (use_gnu_hash ? tags.gnu_hash : tags.hash);\n  for (i = hash_first(symbol, hash, use_gnu_hash); i != STN_UNDEF;\n       i = hash_next(i, hash, use_gnu_hash)) {\n    if (tags.symtab[i].st_name == 0 || tags.symtab[i].st_value == 0)\n      continue;\n    if (strcmp(symbol_name(i, &tags), symbol) != 0) // If different symbol name\n      continue;\n    char *symversion = version_name(tags.versym[i], &tags);\n    if (version && symversion && strcmp(symversion, version) == 0) {\n      default_symbol_index = i;\n      break;\n    }\n    // We have a symbol of the same name.  Let's look at the version number.\n    if ( version == NULL) {\n      if (!(tags.versym[i] & (1<<15)) ) { // If hidden bit is not set.\n        numNonHiddenSymbols++;\n      }\n      // If default symbol not set or if new version later than old one.\n      // Notice that default_symbol_index will be set first to the\n      //  base definition (1 for unversioned symbols; 2 for versioned symbols)\n      if (default_symbol_index && numNonHiddenSymbols > 1) {\n        JWARNING(false)(symbol).Text(\"More than one default symbol version.\");\n      }\n      char *defaultSymVersion = version_name(tags.versym[default_symbol_index],\n                                             &tags);\n      if (default_symbol_index == 0 ||\n          // Could look at version dependencies, but using strcmp instead.\n          (symversion && defaultSymVersion &&\n           strcmp(symversion, defaultSymVersion) > 0)) {\n        default_symbol_index = i;\n      }\n    }\n  }\n  *tags_p = tags;\n  *default_symbol_index_p = default_symbol_index;\n\n  if (default_symbol_index) {\n#if __GLIBC_PREREQ(2, 11)\n    // See https://gcc.gnu.org/onlinedocs/gcc-4.9.2/gcc/Function-Attributes.html\n    if (ELF64_ST_TYPE(tags.symtab[default_symbol_index].st_info) ==\n        STT_GNU_IFUNC) {\n      typedef void* (*fnc)();\n      fnc f =  (fnc)(tags.base_addr +\n                     tags.symtab[default_symbol_index].st_value);\n      return f();\n    }\n#endif\n    return tags.base_addr + tags.symtab[default_symbol_index].st_value;\n  } else {\n    return NULL;\n  }\n}\n\n// Given a pseudo-handle, symbol name, and addr, returns the address of the symbol\n// with the given name of a default version found by the search order of the given\n// handle which is either RTLD_DEFAULT or RTLD_NEXT.\nvoid *dlsym_default_internal_flag_handler(void* handle, const char *libname,\n                                          const char* symbol,\n                                          const char *version,\n                                          void* addr, dt_tag *tags_p,\n                                          Elf32_Word *default_symbol_index_p)\n{\n  Dl_info info;\n  struct link_map* map;\n  void* result = NULL;\n\n  // Retrieve the link_map for the library given by addr\n  int ret = dladdr1(addr, &info, (void**)&map, RTLD_DL_LINKMAP);\n  if (!ret) {\n    JWARNING(false)(symbol)\n            .Text(\"dladdr1 could not find shared object for address\");\n    return NULL;\n  }\n\n\n  // Handle RTLD_DEFAULT starts search at first loaded object\n  if (handle == RTLD_DEFAULT || libname != NULL) {\n    while (map->l_prev) {\n      // Rewinding to search by load order\n      map = map->l_prev;\n    }\n  }\n\n  // Handle RTLD_NEXT starts search after current library\n  if (handle == RTLD_NEXT) {\n    // Skip current library\n    if (!map->l_next) {\n      JTRACE(\"There are no libraries after the current library.\");\n      return NULL;\n    }\n    map = map->l_next;\n  }\n\n  // Search through libraries until end of list is reached or symbol is found.\n  while (map) {\n    // printf(\"l_name: %s\\n\", map->l_name);\n    /* If the caller specified a specific library name, only search through\n     * that.\n     */\n    if (libname == NULL ||\n        (strlen(map->l_name) > 0 && strstr(map->l_name, libname)))  {\n      // Search current library\n      result = dlsym_default_internal_library_handler((void*) map,\n                                                      symbol,\n                                                      version,\n                                                      tags_p,\n                                                      default_symbol_index_p);\n    }\n    if (result) {\n      return result;\n    }\n\n    // Change link map to next library\n    map = map->l_next;\n  }\n  return NULL;\n}\n\n// Produces an error message and hard fails if no default_symbol was found.\nstatic void print_debug_messages(dt_tag tags, Elf32_Word default_symbol_index,\n                                 const char *symbol)\n{\n#ifdef VERBOSE\n  if (default_symbol_index) {\n    JTRACE(\"** st_value: \")\n          (tags.base_addr + tags.symtab[default_symbol_index].st_value);\n    JTRACE(\"** symbol version: \")\n          (version_name(tags.versym[default_symbol_index], &tags));\n  }\n#endif\n  if (!default_symbol_index) {\n    JTRACE(\"ERROR:  No default symbol version found\"\n           \"        Extend code to look for hidden symbols?\")(symbol);\n  }\n}\n\n// Like dlsym but finds the 'default' symbol of a library (the symbol that the\n// dynamic executable automatically links to) rather than the oldest version\n// which is what dlsym finds\n\n/*\n * This implementation tries to mimic the behavior of the linking-loader,\n * as opposed to dlsym().  In particular, if no versioned symbol exists,\n * then the standard symbol is returned.  If more than one versioned symbol\n * exists, and all but one have the hidden bit set, then the version without\n * the hidden bit is returned.  If only one versioned symbol exists, then\n * it is returned whether the hidden bit is set or not.  From examples\n * in various libraries, it seems that when only one versioned symbol\n * exists, it has the hidden bit set.  If two or more versions of the\n * symbol exist, and the hidden bit is set in all cases, then the newest\n * version is returned.  If two or more versions of the symbol exist in\n * which the hidden bit is not set, then the behavior is undefined. [\n * OR DO WE HAVE A FIXED BEHAVIOR HERE? I THINK THIS CASE DOESN'T OCCUR\n * IN THE ACTUAL LIBRARIES. ] If the unversioned symbol and the versioned\n * symbol both exist, then the versioned symbol is preferred. [LET'S CHECK\n * THE CORRECTNESS OF THIS LAST RULE.]  Note that dlsym() in libdl.so seems\n * to follow the unusual rule of ignoring the hidden bit, and choosing a\n * somewhat arbtrary version that is often the oldest version.\n */\n\nEXTERNC void *dmtcp_dlsym(void *handle, const char*symbol) {\n  dt_tag tags;\n  Elf32_Word default_symbol_index = 0;\n\n#ifdef __USE_GNU\n  if (handle == RTLD_NEXT || handle == RTLD_DEFAULT) {\n    // Determine where this function will return\n    void* return_address = __builtin_return_address(0);\n    // Search for symbol using given pseudo-handle order\n    void *result = dlsym_default_internal_flag_handler(handle, NULL, symbol,\n                                                       NULL,\n                                                       return_address, &tags,\n                                                       &default_symbol_index);\n    print_debug_messages(tags, default_symbol_index, symbol);\n    return result;\n  }\n#endif\n\n  void *result = dlsym_default_internal_library_handler(handle, symbol,\n                                                        NULL, &tags,\n                                                        &default_symbol_index);\n  print_debug_messages(tags, default_symbol_index, symbol);\n  return result;\n}\n\nEXTERNC void * dmtcp_dlvsym(void *handle, char *symbol, const char *version)\n{\n  dt_tag tags;\n  Elf32_Word default_symbol_index = 0;\n\n#ifdef __USE_GNU\n  if (handle == RTLD_NEXT || handle == RTLD_DEFAULT) {\n    // Determine where this function will return\n    void* return_address = __builtin_return_address(0);\n    // Search for symbol using given pseudo-handle order\n    void *result = dlsym_default_internal_flag_handler(handle, NULL, symbol,\n                                                       version,\n                                                       return_address, &tags,\n                                                       &default_symbol_index);\n    return result;\n  }\n#endif\n\n  void *result = dlsym_default_internal_library_handler(handle, symbol, version,\n                                                        &tags,\n                                                        &default_symbol_index);\n  return result;\n}\n\nEXTERNC void *\ndmtcp_dlsym_lib(const char *libname, const char *symbol)\n{\n  dt_tag tags;\n  Elf32_Word default_symbol_index = 0;\n\n  // Determine where this function will return\n  void* return_address = __builtin_return_address(0);\n  void *result = dlsym_default_internal_flag_handler(NULL, libname, symbol,\n                                                     NULL,\n                                                     return_address, &tags,\n                                                     &default_symbol_index);\n  return result;\n}\n\n/*\n * Returns the offset of the given function within the given shared library\n * or -1 if the function does not exist in the library\n */\nEXTERNC ptrdiff_t\ndmtcp_dlsym_lib_fnc_offset(const char *libname, const char *symbol)\n{\n  dt_tag tags;\n  ptrdiff_t ret = -1;\n  Elf32_Word default_symbol_index = 0;\n\n  // Determine where this function will return\n  void* return_address = __builtin_return_address(0);\n  void *result = dlsym_default_internal_flag_handler(NULL, libname, symbol,\n                                                     NULL,\n                                                     return_address, &tags,\n                                                     &default_symbol_index);\n  if (result) {\n    ret = (char*)result - tags.base_addr;\n  }\n  return ret;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/src/dmtcpplugin.cpp": "/****************************************************************************\n *   Copyright (C) 2006-2013 by Jason Ansel, Kapil Arya, and Gene Cooperman *\n *   jansel@csail.mit.edu, kapil@ccs.neu.edu, gene@ccs.neu.edu              *\n *                                                                          *\n *  This file is part of DMTCP.                                             *\n *                                                                          *\n *  DMTCP is free software: you can redistribute it and/or                  *\n *  modify it under the terms of the GNU Lesser General Public License as   *\n *  published by the Free Software Foundation, either version 3 of the      *\n *  License, or (at your option) any later version.                         *\n *                                                                          *\n *  DMTCP is distributed in the hope that it will be useful,                *\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of          *\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *\n *  GNU Lesser General Public License for more details.                     *\n *                                                                          *\n *  You should have received a copy of the GNU Lesser General Public        *\n *  License along with DMTCP:dmtcp/src.  If not, see                        *\n *  <http://www.gnu.org/licenses/>.                                         *\n ****************************************************************************/\n\n#include <stdlib.h>\n#include \"dmtcp.h\"\n#include \"dmtcpplugin.h\"\n#include \"dmtcpworker.h\"\n#include \"coordinatorapi.h\"\n#include \"syscallwrappers.h\"\n#include \"processinfo.h\"\n#include \"shareddata.h\"\n#include \"threadsync.h\"\n#include \"mtcpinterface.h\"\n#include \"util.h\"\n\n#undef dmtcp_is_enabled\n#undef dmtcp_checkpoint\n#undef dmtcp_disable_ckpt\n#undef dmtcp_enable_ckpt\n#undef dmtcp_get_coordinator_status\n#undef dmtcp_get_local_status\n#undef dmtcp_get_uniquepid_str\n#undef dmtcp_get_ckpt_filename\n#undef dmtcp_set_coord_ckpt_dir\n#undef dmtcp_get_coord_ckpt_dir\n#undef dmtcp_set_ckpt_dir\n#undef dmtcp_get_ckpt_dir\n#undef dmtcp_set_global_ckpt_dir\n\nusing namespace dmtcp;\n\n//global counters\nstatic int numCheckpoints = 0;\nstatic int numRestarts    = 0;\n\n//I wish we could use pthreads for the trickery in this file, but much of our\n//code is executed before the thread we want to wake is restored.  Thus we do\n//it the bad way.\n#if defined(__i386__) || defined(__x86_64__)\nstatic inline void memfence(){  asm volatile (\"mfence\" ::: \"memory\"); }\n#elif defined(__arm__)\nstatic inline void memfence(){  asm volatile (\"dmb\" ::: \"memory\"); }\n#elif defined(__aarch64__)\n# include \"membarrier.h\"\nstatic inline void memfence(){  RMB; WMB; }\n#else\n# define memfence() __sync_synchronize()\n#endif\n\nEXTERNC int dmtcp_is_enabled() { return 1; }\n\nstatic void runCoordinatorCmd(char c,\n                              int *coordCmdStatus = NULL,\n                              int *numPeers = NULL,\n                              int *isRunning = NULL)\n{\n  _dmtcp_lock();\n  {\n    CoordinatorAPI coordinatorAPI;\n\n    dmtcp_disable_ckpt();\n    coordinatorAPI.connectAndSendUserCommand(c, coordCmdStatus, numPeers,\n                                             isRunning);\n    dmtcp_enable_ckpt();\n  }\n  _dmtcp_unlock();\n}\n\nstatic int dmtcpRunCommand(char command)\n{\n  int coordCmdStatus;\n  int i = 0;\n  while (i < 100) {\n    runCoordinatorCmd(command, &coordCmdStatus);\n  // if we got error result - check it\n\t// There is possibility that checkpoint thread\n\t// did not send state=RUNNING yet or Coordinator did not receive it\n\t// -- Artem\n    if (coordCmdStatus == CoordCmdStatus::ERROR_NOT_RUNNING_STATE) {\n      struct timespec t;\n      t.tv_sec = 0;\n      t.tv_nsec = 1000000;\n      nanosleep(&t, NULL);\n      //printf(\"\\nWAIT FOR CHECKPOINT ABLE\\n\\n\");\n    } else {\n//      printf(\"\\nEverything is OK - return\\n\");\n      break;\n    }\n    i++;\n  }\n  return coordCmdStatus == CoordCmdStatus::NOERROR;\n}\n\nEXTERNC int dmtcp_checkpoint()\n{\n  int rv = 0;\n  int oldNumRestarts    = numRestarts;\n  int oldNumCheckpoints = numCheckpoints;\n  memfence(); //make sure the reads above don't get reordered\n\n  if(dmtcpRunCommand('c')){ //request checkpoint\n    //and wait for the checkpoint\n    while(oldNumRestarts==numRestarts && oldNumCheckpoints==numCheckpoints){\n      //nanosleep should get interrupted by checkpointing with an EINTR error\n      //though there is a race to get to nanosleep() before the checkpoint\n      struct timespec t = {1,0};\n      nanosleep(&t, NULL);\n      memfence();  //make sure the loop condition doesn't get optimized\n    }\n    rv = (oldNumRestarts==numRestarts ? DMTCP_AFTER_CHECKPOINT : DMTCP_AFTER_RESTART);\n  }else{\n  \t/// TODO: Maybe we need to process it in some way????\n    /// EXIT????\n    /// -- Artem\n    //\tprintf(\"\\n\\n\\nError requesting checkpoint\\n\\n\\n\");\n  }\n\n  return rv;\n}\n\nEXTERNC int dmtcp_get_coordinator_status(int *numPeers, int *isRunning)\n{\n  int coordCmdStatus;\n  runCoordinatorCmd('s', &coordCmdStatus, numPeers, isRunning);\n  return DMTCP_IS_PRESENT;;\n}\n\nEXTERNC int dmtcp_get_local_status(int *nCheckpoints, int *nRestarts)\n{\n  *nCheckpoints = numCheckpoints;\n  *nRestarts = numRestarts;\n  return DMTCP_IS_PRESENT;;\n}\n\nEXTERNC int dmtcp_disable_ckpt()\n{\n  ThreadSync::delayCheckpointsLock();\n  return 1;\n}\n\nEXTERNC int dmtcp_enable_ckpt()\n{\n  ThreadSync::delayCheckpointsUnlock();\n  return 1;\n}\n\nEXTERNC int dmtcp_get_ckpt_signal(void)\n{\n  const int ckpt_signal = DmtcpWorker::determineCkptSignal();\n  return ckpt_signal;\n}\n\nEXTERNC const char* dmtcp_get_tmpdir(void)\n{\n  static char tmpdir[PATH_MAX];\n  JASSERT(SharedData::getTmpDir(tmpdir, sizeof(tmpdir)) != NULL);\n  return tmpdir;\n}\n\n//EXTERNC void dmtcp_set_tmpdir(const char* dir)\n//{\n//  if (dir != NULL) {\n//    UniquePid::setTmpDir(dir);\n//  }\n//}\n\nEXTERNC const char* dmtcp_get_ckpt_dir()\n{\n  static string tmpdir;\n  tmpdir = ProcessInfo::instance().getCkptDir();\n  return tmpdir.c_str();\n}\n\nEXTERNC int dmtcp_set_ckpt_dir(const char* dir)\n{\n  if (dir != NULL) {\n    ProcessInfo::instance().setCkptDir(dir);\n  }\n  return DMTCP_IS_PRESENT;\n}\n\nEXTERNC int dmtcp_set_global_ckpt_dir(const char *dir)\n{\n  dmtcp_disable_ckpt();\n  if (dir != NULL) {\n    if(!CoordinatorAPI::instance().updateGlobalCkptDir(dir)) {\n      JNOTE(\"Failed to set global checkpoint dir. \"\n            \"Most probably this is because DMTCP is in the middle \"\n            \"of a checkpoint. Please try again later\") (dir);\n      dmtcp_enable_ckpt();\n      return -1;\n    }\n  }\n  dmtcp_enable_ckpt();\n  return DMTCP_IS_PRESENT;\n}\n\n// Returns a zero-length string when there's no\n// coordinator or a checkpoint is in progress.\nEXTERNC const char* dmtcp_get_coord_ckpt_dir(void)\n{\n  static string dir;\n  CoordinatorAPI coordinatorAPI;\n  dmtcp_disable_ckpt();\n  dir = coordinatorAPI.getCoordCkptDir();\n  dmtcp_enable_ckpt();\n  return dir.c_str();\n}\n\nEXTERNC int dmtcp_set_coord_ckpt_dir(const char* dir)\n{\n  if (dir != NULL) {\n    CoordinatorAPI::instance().updateCoordCkptDir(dir);\n  }\n  return DMTCP_IS_PRESENT;\n}\n\nEXTERNC void dmtcp_set_ckpt_file(const char *filename)\n{\n  ProcessInfo::instance().setCkptFilename(filename);\n}\n\nEXTERNC const char* dmtcp_get_ckpt_filename(void)\n{\n  static string filename;\n  filename = ProcessInfo::instance().getCkptFilename();\n  return filename.c_str();\n}\n\nEXTERNC const char* dmtcp_get_ckpt_files_subdir(void)\n{\n  static string tmpdir;\n  tmpdir = ProcessInfo::instance().getCkptFilesSubDir();\n  return tmpdir.c_str();\n}\n\nEXTERNC int dmtcp_should_ckpt_open_files(void)\n{\n  return getenv(ENV_VAR_CKPT_OPEN_FILES) != NULL;\n}\n\nEXTERNC int dmtcp_allow_overwrite_with_ckpted_files(void)\n{\n  return getenv(ENV_VAR_ALLOW_OVERWRITE_WITH_CKPTED_FILES) != NULL;\n}\n\nEXTERNC const char* dmtcp_get_executable_path(void)\n{\n  return ProcessInfo::instance().procSelfExe().c_str();\n}\n\nEXTERNC const char* dmtcp_get_uniquepid_str(void)\n{\n  static string *uniquepid_str = NULL;\n  uniquepid_str =\n    new string(UniquePid::ThisProcess(true).toString());\n  return uniquepid_str->c_str();\n}\n\nEXTERNC DmtcpUniqueProcessId dmtcp_get_uniquepid(void)\n{\n  return UniquePid::ThisProcess().upid();\n}\n\nEXTERNC DmtcpUniqueProcessId dmtcp_get_computation_id(void)\n{\n  return SharedData::getCompId();\n}\n\nEXTERNC const char* dmtcp_get_computation_id_str(void)\n{\n  static string *compid_str = NULL;\n  if (compid_str == NULL) {\n    UniquePid compId = SharedData::getCompId();\n    compid_str = new string(compId.toString());\n  }\n  return compid_str->c_str();\n}\n\nEXTERNC DmtcpUniqueProcessId dmtcp_get_coord_id(void)\n{\n  return SharedData::getCoordId();\n}\n\nEXTERNC int dmtcp_unique_pids_equal(DmtcpUniqueProcessId a,\n                                    DmtcpUniqueProcessId b)\n{\n  return a._hostid == b._hostid &&\n         a._pid == b._pid &&\n         a._time == b._time &&\n         a._computation_generation == b._computation_generation;\n}\n\nEXTERNC uint64_t dmtcp_get_coordinator_timestamp(void)\n{\n  return SharedData::getCoordTimeStamp();\n}\n\nEXTERNC uint32_t dmtcp_get_generation(void)\n{\n  return ProcessInfo::instance().get_generation();\n}\n\nEXTERNC int checkpoint_is_pending(void)\n{\n  return SharedData::getCompId()._computation_generation >\n           ProcessInfo::instance().get_generation();\n}\n\nEXTERNC int dmtcp_is_running_state(void)\n{\n  return WorkerState::currentState() == WorkerState::RUNNING;\n}\n\nEXTERNC int dmtcp_is_protected_fd(int fd)\n{\n  return DMTCP_IS_PROTECTED_FD(fd);\n}\n\nEXTERNC int dmtcp_protected_environ_fd(void)\n{\n  return PROTECTED_ENVIRON_FD;\n}\n\nEXTERNC void dmtcp_close_protected_fd(int fd)\n{\n  JASSERT(DMTCP_IS_PROTECTED_FD(fd));\n  _real_close(fd);\n}\n\n// EXTERNC int dmtcp_get_restart_env(char *name, char *value, int maxvaluelen);\n// USAGE:\n//   char value[RESTART_ENV_MAXSIZE];\n//   dmtcp_get_restart_env(name, value, RESTART_ENV_MAXSIZE);\n//  Returns 0 on success, -1 if name not found; -2 if value > RESTART_ENV_MAXSIZE\n// NOTE: This implementation assumes that a \"name=value\" string will be\n//   no more than RESTART_ENV_MAXSIZE bytes.\n\nEXTERNC int\ndmtcp_get_restart_env(const char *name,   // IN\n                      char *value,        // OUT\n                      size_t maxvaluelen)\n{\n  int env_fd = dup(dmtcp_protected_environ_fd());\n  JASSERT(env_fd != -1)(env_fd)(dmtcp_protected_environ_fd());\n  lseek(env_fd, 0, SEEK_SET);\n\n  int rc = RESTART_ENV_NOTFOUND; // Default is -1: name not found\n\n  char env_buf[RESTART_ENV_MAXSIZE] = {0}; // All \"name=val\" strings must be shorter than this.\n\n  if (name == NULL || value == NULL) {\n    close(env_fd);\n    return RESTART_ENV_NULL_PTR;\n  }\n\n  int namelen = strlen(name);\n  *value = '\\0'; // Default is null string\n  char *pos = NULL;\n\n  while (rc == RESTART_ENV_NOTFOUND) {\n   memset(env_buf, 0, RESTART_ENV_MAXSIZE);\n   // read a flattened name-value pairs list\n   int count = Util::readLine(env_fd, env_buf, RESTART_ENV_MAXSIZE);\n   if (count == 0) {\n     break;\n   } else if (count == -1) {\n     rc = RESTART_ENV_INTERNAL_ERROR;\n   } else if (count == -2) {\n     rc = RESTART_ENV_DMTCP_BUF_TOO_SMALL;\n   } else {\n     char *start_ptr = env_buf;\n     // iterate over the flattened list of name-value pairs\n     while (start_ptr - env_buf < (int) sizeof(env_buf)) {\n       pos = NULL;\n       if (strncmp(start_ptr, name, namelen) == 0) {\n         if ((pos = strchr(start_ptr, '='))) {\n           strncpy(value, pos + 1, maxvaluelen);\n           if (strlen(pos+1) >= maxvaluelen) {\n             rc = RESTART_ENV_TOOLONG; // value does not fit in the user-provided value buffer\n             break;\n           }\n         }\n         rc = RESTART_ENV_SUCCESS;\n         break;\n       }\n       // skip over a name-value pair\n       start_ptr += strlen(start_ptr) + 1;\n     }\n   }\n  }\n\n  close(env_fd);\n  JWARNING (rc != RESTART_ENV_DMTCP_BUF_TOO_SMALL)\n    (name) (sizeof(env_buf)) .Text(\"Resize env_buf[]\");\n  return rc;\n}\n\nEXTERNC int dmtcp_get_readlog_fd(void)\n{\n  return PROTECTED_READLOG_FD;\n}\n\nEXTERNC int dmtcp_get_ptrace_fd(void)\n{\n  return PROTECTED_PTRACE_FD;\n}\n\nLIB_PRIVATE int32_t dmtcp_dlsym_offset = -1;\ntypedef void* (*dlsym_fnptr_t) (void *handle, const char *symbol);\nEXTERNC void *dmtcp_get_libc_dlsym_addr(void)\n{\n  static dlsym_fnptr_t _libc_dlsym_fnptr = NULL;\n#ifndef CONFIG_M32\n  const char *evar = ENV_VAR_DLSYM_OFFSET;\n#else\n  const char *evar = ENV_VAR_DLSYM_OFFSET_M32;\n#endif\n\n  if (_libc_dlsym_fnptr == NULL) {\n    if (getenv(evar) == NULL) {\n      fprintf(stderr,\n              \"%s:%d DMTCP Internal Error: Env var DMTCP_DLSYM_OFFSET not set.\\n\"\n              \"      Aborting.\\n\\n\",\n              __FILE__, __LINE__);\n      abort();\n    }\n\n    dmtcp_dlsym_offset = (int32_t) strtol(getenv(evar), NULL, 10);\n\n    _libc_dlsym_fnptr = (dlsym_fnptr_t)((char *)&LIBDL_BASE_FUNC +\n                                        dmtcp_dlsym_offset);\n  }\n\n  return (void*) _libc_dlsym_fnptr;\n}\n\nEXTERNC void dmtcp_block_ckpt_signal(void)\n{\n  static sigset_t signals_set;\n  static bool initialized = false;\n  if (!initialized) {\n    sigemptyset (&signals_set);\n    sigaddset (&signals_set, dmtcp_get_ckpt_signal());\n    initialized = true;\n  }\n\n  JASSERT(_real_pthread_sigmask (SIG_BLOCK, &signals_set, NULL) == 0);\n}\n\nEXTERNC void dmtcp_unblock_ckpt_signal(void)\n{\n  static sigset_t signals_set;\n  static bool initialized = false;\n  if (!initialized) {\n    sigemptyset (&signals_set);\n    sigaddset (&signals_set, dmtcp_get_ckpt_signal());\n    initialized = true;\n  }\n\n  JASSERT(_real_pthread_sigmask (SIG_UNBLOCK, &signals_set, NULL) == 0);\n}\n\nEXTERNC int dmtcp_send_key_val_pair_to_coordinator(const char *id,\n                                                   const void *key,\n                                                   uint32_t key_len,\n                                                   const void *val,\n                                                   uint32_t val_len)\n{\n  return CoordinatorAPI::instance().sendKeyValPairToCoordinator(id, key, key_len,\n                                                                val, val_len);\n}\n\nEXTERNC int dmtcp_send_key_val_pair_to_coordinator_sync(const char *id,\n                                                        const void *key,\n                                                        uint32_t key_len,\n                                                        const void *val,\n                                                        uint32_t val_len)\n{\n  return CoordinatorAPI::instance().sendKeyValPairToCoordinator(id, key, key_len,\n                                                                val, val_len,\n\t\t\t\t\t\t\t\t1);\n}\n\n// On input, val points to a buffer in user memory and *val_len is the maximum\n//   size of that buffer (the memory allocated by user).\n// On output, we copy data to val, and set *val_len to the actual buffer size\n//   (to the size of the data that we copied to the user buffer).\nEXTERNC int dmtcp_send_query_to_coordinator(const char *id,\n                                            const void *key, uint32_t key_len,\n                                            void *val, uint32_t *val_len)\n{\n  return CoordinatorAPI::instance().sendQueryToCoordinator(id, key, key_len,\n                                                           val, val_len);\n}\n\nEXTERNC int dmtcp_get_unique_id_from_coordinator(const char *id,    // DB name\n                                                 const void *key,   // hostid, pid, etc.\n                                                 uint32_t key_len,  // Length of the key\n                                                 void *val,         // Result\n                                                 uint32_t offset,   // unique id offset\n                                                 uint32_t val_len)  // Expected val length\n{\n  return CoordinatorAPI::instance().getUniqueIdFromCoordinator(id, key, key_len,\n                                                               val, &val_len,\n                                                               offset);\n}\n\nEXTERNC void dmtcp_get_local_ip_addr(struct in_addr *in)\n{\n  SharedData::getLocalIPAddr(in);\n}\n\nEXTERNC int dmtcp_no_coordinator(void)\n{\n  return CoordinatorAPI::noCoordinator();\n}\n\nEXTERNC void dmtcp_update_max_required_fd(int fd)\n{\n  ProcessInfo::instance().updateMaxUserFd(fd);\n}\n\nvoid dmtcp::increment_counters(int isRestart)\n{\n  if (isRestart) {\n    numRestarts++;\n  } else {\n    numCheckpoints++;\n  }\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/src/coordinatorapi.cpp": "/****************************************************************************\n *   Copyright (C) 2006-2013 by Jason Ansel, Kapil Arya, and Gene Cooperman *\n *   jansel@csail.mit.edu, kapil@ccs.neu.edu, gene@ccs.neu.edu              *\n *                                                                          *\n *  This file is part of DMTCP.                                             *\n *                                                                          *\n *  DMTCP is free software: you can redistribute it and/or                  *\n *  modify it under the terms of the GNU Lesser General Public License as   *\n *  published by the Free Software Foundation, either version 3 of the      *\n *  License, or (at your option) any later version.                         *\n *                                                                          *\n *  DMTCP is distributed in the hope that it will be useful,                *\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of          *\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *\n *  GNU Lesser General Public License for more details.                     *\n *                                                                          *\n *  You should have received a copy of the GNU Lesser General Public        *\n *  License along with DMTCP:dmtcp/src.  If not, see                        *\n *  <http://www.gnu.org/licenses/>.                                         *\n ****************************************************************************/\n\n// CAN REMOVE BOOL enableCheckpointing ARG OF DmtcpWorker WHEN WE'RE DONE.\n// DmtcpWorker CAN INHERIT THIS CLASS, CoordinatorAPI\n\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <sys/time.h>\n#include <sys/types.h>\n#include <poll.h>\n#include <unistd.h>\n#include \"coordinatorapi.h\"\n#include \"dmtcp.h\"\n#include \"util.h\"\n#include \"syscallwrappers.h\"\n#include \"util.h\"\n#include \"shareddata.h\"\n#include \"processinfo.h\"\n#include  \"../jalib/jconvert.h\"\n#include  \"../jalib/jfilesystem.h\"\n#include <fcntl.h>\n#include <semaphore.h> // for sem_post(&sem_launch)\n\n// sem_launch is used in threadlist.cpp\n// sem_launch_first_time will be set just before pthread_create(checkpointhread)\nLIB_PRIVATE bool sem_launch_first_time = false;\nLIB_PRIVATE sem_t sem_launch;\n\nusing namespace dmtcp;\n\nvoid dmtcp_CoordinatorAPI_EventHook(DmtcpEvent_t event, DmtcpEventData_t *data)\n{\n  if (CoordinatorAPI::noCoordinator()) return;\n  switch (event) {\n    case DMTCP_EVENT_INIT:\n      CoordinatorAPI::instance().init();\n      break;\n\n    case DMTCP_EVENT_THREADS_SUSPEND:\n      JASSERT(CoordinatorAPI::instance().isValid());\n      break;\n\n    case DMTCP_EVENT_RESTART:\n      CoordinatorAPI::restart();\n      break;\n\n    case DMTCP_EVENT_RESUME:\n      CoordinatorAPI::instance().sendCkptFilename();\n      break;\n\n    case DMTCP_EVENT_EXIT:\n      JLOG(DMTCP)(\"exit() in progress, disconnecting from dmtcp coordinator\");\n      CoordinatorAPI::instance().closeConnection();\n      break;\n\n    default:\n      break;\n  }\n}\n\nvoid CoordinatorAPI::restart()\n{\n  instance()._nsSock.close();\n}\n\nstatic uint32_t getCkptInterval()\n{\n  uint32_t ret = DMTCPMESSAGE_SAME_CKPT_INTERVAL;\n  const char* interval = getenv (ENV_VAR_CKPT_INTR);\n  /* DmtcpMessage constructor default:\n   *   hello_local.theCheckpointInterval: DMTCPMESSAGE_SAME_CKPT_INTERVAL\n   */\n  if (interval != NULL) {\n    ret = jalib::StringToInt (interval);\n  }\n  // Tell the coordinator the ckpt interval only once.  It can change later.\n  _dmtcp_unsetenv (ENV_VAR_CKPT_INTR);\n  return ret;\n}\n\nstatic jalib::JSocket createNewSocketToCoordinator(CoordinatorMode mode)\n{\n  string host = \"\";\n  int port = UNINITIALIZED_PORT;\n\n  Util::getCoordHostAndPort(COORD_ANY, host, &port);\n  return jalib::JClientSocket(host.c_str(), port);\n}\n\n//CoordinatorAPI::CoordinatorAPI (int sockfd)\n  //: _coordinatorSocket(sockfd)\n//{ }\n\nstatic CoordinatorAPI *coordAPIInst = NULL;\nCoordinatorAPI& CoordinatorAPI::instance()\n{\n  //static SysVIPC *inst = new SysVIPC(); return *inst;\n  if (coordAPIInst == NULL) {\n    coordAPIInst = new CoordinatorAPI();\n    if (noCoordinator()) {\n      coordAPIInst->_coordinatorSocket = jalib::JSocket(PROTECTED_COORD_FD);\n    }\n  }\n  return *coordAPIInst;\n}\n\nvoid CoordinatorAPI::init()\n{\n  JLOG(DMTCP)(\"Informing coordinator of new process\") (UniquePid::ThisProcess());\n\n  DmtcpMessage msg (DMT_UPDATE_PROCESS_INFO_AFTER_INIT_OR_EXEC);\n  string progname = jalib::Filesystem::GetProgramName();\n  msg.extraBytes = progname.length() + 1;\n\n  JASSERT(Util::isValidFd(PROTECTED_COORD_FD));\n  instance()._coordinatorSocket = jalib::JSocket(PROTECTED_COORD_FD);\n  instance()._coordinatorSocket << msg;\n  instance()._coordinatorSocket.writeAll(progname.c_str(),\n                                         progname.length() + 1);\n  // The coordinator won't send any msg in response to DMT_UPDATE... so no need\n  // to call recvCoordinatorHandshake().\n}\n\nvoid CoordinatorAPI::resetOnFork(CoordinatorAPI& coordAPI)\n{\n  JASSERT(coordAPI._coordinatorSocket.isValid());\n  JASSERT(coordAPI._coordinatorSocket.sockfd() != PROTECTED_COORD_FD);\n  instance() = coordAPI;\n  instance()._coordinatorSocket.changeFd(PROTECTED_COORD_FD);\n\n  JLOG(DMTCP)(\"Informing coordinator of new process\") (UniquePid::ThisProcess());\n\n  DmtcpMessage msg (DMT_UPDATE_PROCESS_INFO_AFTER_FORK);\n  if (dmtcp_virtual_to_real_pid) {\n    msg.realPid = dmtcp_virtual_to_real_pid(getpid());\n  } else {\n    msg.realPid = getpid();\n  }\n  instance()._coordinatorSocket << msg;\n  // The coordinator won't send any msg in response to DMT_UPDATE... so no need\n  // to call recvCoordinatorHandshake().\n  instance()._nsSock.close();\n}\n\n/* Recompute the protected coordinator fd and reset the coordiantor socket.\n *\n * Used to handle the case where protectedFdBase() has changed, for example,\n * on restart.\n * */\nvoid CoordinatorAPI::resetCoordSocketFd()\n{\n  _coordinatorSocket = jalib::JSocket(PROTECTED_COORD_FD);\n}\n\n// FIXME:  Does \"virtual coordinator\" mean coordinator built into the\n//         the current process (no separate process?)\nvoid CoordinatorAPI::setupVirtualCoordinator(CoordinatorInfo *coordInfo,\n                                             struct in_addr  *localIP)\n{\n  string host = \"\";\n  int port = UNINITIALIZED_PORT;\n  Util::getCoordHostAndPort(COORD_NONE, host, &port);\n  _coordinatorSocket = jalib::JServerSocket(jalib::JSockAddr::ANY, port);\n  JASSERT(_coordinatorSocket.isValid()) (port) (JASSERT_ERRNO)\n    .Text(\"Failed to create listen socket.\");\n  _coordinatorSocket.changeFd(PROTECTED_COORD_FD);\n  Util::setCoordPort(_coordinatorSocket.port());\n\n  pid_t ppid = getppid();\n  Util::setVirtualPidEnvVar(INITIAL_VIRTUAL_PID, ppid, ppid);\n\n  UniquePid coordId = UniquePid(INITIAL_VIRTUAL_PID,\n                                UniquePid::ThisProcess().hostid(),\n                                UniquePid::ThisProcess().time());\n\n  coordInfo->id = coordId.upid();\n  coordInfo->timeStamp = coordId.time();\n  coordInfo->addrLen = 0;\n  if (getenv(ENV_VAR_CKPT_INTR) != NULL) {\n    coordInfo->interval = (uint32_t) strtol(getenv(ENV_VAR_CKPT_INTR), NULL, 0);\n  } else {\n    coordInfo->interval = 0;\n  }\n  memset(&coordInfo->addr, 0, sizeof(coordInfo->addr));\n  memset(localIP, 0, sizeof(*localIP));\n}\n\nvoid CoordinatorAPI::waitForCheckpointCommand()\n{\n  uint32_t ckptInterval = SharedData::getCkptInterval();\n  struct timeval tmptime={0,0};\n  long remaining = ckptInterval;\n  do {\n    struct timeval *timeout = NULL;\n    struct timeval start;\n    if (ckptInterval > 0) {\n      timeout = &tmptime;\n      timeout->tv_sec = remaining;\n      JASSERT(gettimeofday(&start, NULL) == 0) (JASSERT_ERRNO);\n    }\n\n    // This call to poll() does nothing and returns.\n    // But we want to find address of poll() using dlsym/libc before\n    //   allowing the user thread to continue.\n    poll(NULL, 0, 0);\n    if (sem_launch_first_time) {\n      // Release user thread now that we've initialized the checkpoint thread.\n      // This code is reached if the --no-coordinator flag is used.\n      sem_post(&sem_launch);\n      sem_launch_first_time = false;\n    }\n\n    struct pollfd socketFd = {0};\n    socketFd.fd = PROTECTED_COORD_FD;\n    socketFd.events = POLLIN;\n    uint64_t millis = timeout ? ((timeout->tv_sec * (uint64_t)1000) +\n                                 (timeout->tv_usec / 1000))\n                              : -1;\n    int retval = poll(&socketFd, 1, millis);\n    if (retval == 0) { // timeout expired, time for checkpoint\n      JLOG(DMTCP)(\"Timeout expired, checkpointing now.\");\n      return;\n    } else if (retval > 0) {\n      JASSERT(socketFd.revents & POLLIN);\n      JLOG(DMTCP)(\"Connect request on virtual coordinator socket.\");\n      break;\n    }\n    JASSERT(errno == EINTR) (JASSERT_ERRNO); /* EINTR: a signal was caught */\n    if (ckptInterval > 0) {\n      struct timeval end;\n      JASSERT(gettimeofday(&end, NULL) == 0) (JASSERT_ERRNO);\n      remaining -= end.tv_sec - start.tv_sec;\n      // If the remaining time is negative, we can checkpoint now\n      if (remaining < 0) {\n        return;\n      }\n    }\n  } while (remaining > 0);\n\n  jalib::JSocket cmdSock(-1);\n  DmtcpMessage msg;\n  DmtcpMessage reply(DMT_USER_CMD_RESULT);\n  do {\n    cmdSock.close();\n    cmdSock = _coordinatorSocket.accept();\n    msg.poison();\n    JLOG(DMTCP)(\"Reading from incoming connection...\");\n    cmdSock >> msg;\n  } while (!cmdSock.isValid());\n\n  JASSERT(msg.type == DMT_USER_CMD) (msg.type)\n    .Text(\"Unexpected connection.\");\n\n  reply.coordCmdStatus = CoordCmdStatus::NOERROR;\n\n  bool exitWhenDone = false;\n  switch (msg.coordCmd) {\n//    case 'b': case 'B':  // prefix blocking command, prior to checkpoint command\n//      JLOG(DMTCP)(\"blocking checkpoint beginning...\");\n//      blockUntilDone = true;\n//      break;\n    case 's': case 'S':\n      JLOG(DMTCP)(\"Received status command\");\n      reply.numPeers = 1;\n      reply.isRunning = 1;\n      break;\n    case 'c': case 'C':\n      JLOG(DMTCP)(\"checkpointing...\");\n      break;\n    case 'k': case 'K':\n    case 'q': case 'Q':\n      JLOG(DMTCP)(\"Received KILL command from user, exiting\");\n      exitWhenDone = true;\n      break;\n    default:\n      JLOG(DMTCP)(\"unhandled user command\") (msg.coordCmd);\n      reply.coordCmdStatus = CoordCmdStatus::ERROR_INVALID_COMMAND;\n  }\n  cmdSock << reply;\n  cmdSock.close();\n  if (exitWhenDone) {\n    _real_exit(0);\n  }\n  return;\n}\n\nbool CoordinatorAPI::noCoordinator()\n{\n  static int virtualCoordinator = -1;\n  if (virtualCoordinator == -1) {\n    int optVal = -1;\n    socklen_t optLen = sizeof(optVal);\n    int ret = _real_getsockopt(PROTECTED_COORD_FD, SOL_SOCKET,\n                               SO_ACCEPTCONN, &optVal, &optLen);\n    if (ret == 0 && optVal == 1) {\n      virtualCoordinator = 1;\n    } else {\n      virtualCoordinator = 0;\n    }\n  }\n  return virtualCoordinator;\n}\n\nchar* CoordinatorAPI::connectAndSendUserCommand(char c,\n                                                int *coordCmdStatus,\n                                                int *numPeers,\n                                                int *isRunning,\n                                                int *ckptInterval,\n                                                uint32_t logMask)\n{\n  char *replyData = NULL;\n  _coordinatorSocket = createNewSocketToCoordinator(COORD_ANY);\n  if (!_coordinatorSocket.isValid()) {\n    *coordCmdStatus = CoordCmdStatus::ERROR_COORDINATOR_NOT_FOUND;\n    return replyData;\n  }\n\n  //tell the coordinator to run given user command\n  DmtcpMessage msg, reply;\n\n  //send\n  msg.type = DMT_USER_CMD;\n  msg.coordCmd = c;\n  msg.logMask = logMask;\n\n  if (c == 'i') {\n    const char* interval = getenv (ENV_VAR_CKPT_INTR);\n    if (interval != NULL){\n      msg.theCheckpointInterval = jalib::StringToInt (interval);\n    }\n  }\n\n  _coordinatorSocket << msg;\n\n  //the coordinator will violently close our socket...\n  if (c=='q' || c=='Q') {\n    *coordCmdStatus = CoordCmdStatus::NOERROR;\n    return replyData;\n  }\n\n  //receive REPLY\n  reply.poison();\n  recvMsgFromCoordinator(&reply, (void**)&replyData);\n  reply.assertValid();\n  JASSERT(reply.type == DMT_USER_CMD_RESULT);\n\n  if (coordCmdStatus != NULL) {\n    *coordCmdStatus =  reply.coordCmdStatus;\n  }\n  if (numPeers != NULL) {\n    *numPeers =  reply.numPeers;\n  }\n  if (isRunning != NULL) {\n    *isRunning = reply.isRunning;\n  }\n  if (ckptInterval != NULL) {\n    *ckptInterval = reply.theCheckpointInterval;\n  }\n\n  _coordinatorSocket.close();\n\n  return replyData;\n}\n\nstring CoordinatorAPI::getCoordCkptDir(void)\n{\n  // FIXME: Add a test for make-check.\n  int coordCmdStatus = CoordCmdStatus::NOERROR;\n  if (noCoordinator()) return \"\";\n  string coordCkptDir = connectAndSendUserCommand('e', &coordCmdStatus);\n  return coordCkptDir;\n}\n\nvoid CoordinatorAPI::updateCoordCkptDir(const char *dir)\n{\n  if (noCoordinator()) return;\n  JASSERT(dir != NULL);\n  DmtcpMessage msg(DMT_UPDATE_CKPT_DIR);\n  msg.extraBytes = strlen(dir) + 1;\n  _coordinatorSocket << msg;\n  _coordinatorSocket.writeAll(dir, strlen(dir) + 1);\n}\n\n// Invoked by the application or a plugin via\n// dmtcp.h:dmtcp_set_global_ckpt_dir() and\n// via dmtcpplugin.cpp:dmtcp_set_global_ckpt_dir()\nbool CoordinatorAPI::updateGlobalCkptDir(const char *dir)\n{\n  if (noCoordinator()) return false;\n  JASSERT(dir != NULL);\n  jalib::JSocket sock = createNewSocketToCoordinator(COORD_ANY);\n  JASSERT(sock.isValid());\n  DmtcpMessage msg(DMT_UPDATE_GLOBAL_CKPT_DIR);\n  msg.extraBytes = strlen(dir) + 1;\n  sock << msg;\n  sock.writeAll(dir, msg.extraBytes);\n\n  msg.poison();\n  sock >> msg;\n  sock.close();\n\n  if (msg.type == DMT_UPDATE_GLOBAL_CKPT_DIR_SUCCEED) {\n    JTRACE(\"Updated global checkpoint dir\") (dir);\n    return true;\n  } else {\n    JTRACE(\"Failed to update global checkpoint dir\") (dir);\n    return false;\n  }\n}\n\nvoid CoordinatorAPI::sendMsgToCoordinator(const DmtcpMessage &msg,\n                                          const void *extraData,\n                                          size_t len)\n{\n  if (noCoordinator()) return;\n  _coordinatorSocket << msg;\n  if (msg.extraBytes > 0) {\n    JASSERT(extraData != NULL);\n    JASSERT(len == msg.extraBytes);\n    _coordinatorSocket.writeAll((const char *)extraData, msg.extraBytes);\n  }\n}\n\nvoid CoordinatorAPI::recvMsgFromCoordinator(DmtcpMessage *msg, void **extraData)\n{\n  JASSERT(!noCoordinator()).Text(\"internal error\");\n  if (sem_launch_first_time) {\n    // Release user thread now that we've initialized the checkpoint thread.\n    // This code is reached if the --no-coordinator flag is not used.\n    // FIXME:  Technically, some rare type of software could still execute\n    //   between here and when we readall() from coord, thus creating a race.\n    sem_post(&sem_launch);\n    sem_launch_first_time = false;\n  }\n  msg->poison();\n  _coordinatorSocket >> (*msg);\n\n  if (extraData != NULL && msg->extraBytes > 0) {\n    msg->assertValid();\n    // Caller must free this buffer\n    void *buf = JALLOC_HELPER_MALLOC(msg->extraBytes);\n    _coordinatorSocket.readAll((char*)buf, msg->extraBytes);\n    JASSERT(extraData != NULL);\n    *extraData = buf;\n  }\n}\n\nvoid CoordinatorAPI::startNewCoordinator(CoordinatorMode mode)\n{\n  string host = \"\";\n  int port = UNINITIALIZED_PORT;\n  Util::getCoordHostAndPort(mode, host, &port);\n\n  JASSERT(strcmp(host.c_str(), \"localhost\") == 0 ||\n          strcmp(host.c_str(), \"127.0.0.1\") == 0 ||\n          jalib::Filesystem::GetCurrentHostname() == host)\n    (host) (jalib::Filesystem::GetCurrentHostname())\n    .Text(\"Won't automatically start coordinator because DMTCP_HOST\"\n          \" is set to a remote host.\");\n  // Create a socket and bind it to an unused port.\n  errno = 0;\n  jalib::JServerSocket coordinatorListenerSocket(jalib::JSockAddr::ANY,\n                                                 port, 128);\n  JASSERT(coordinatorListenerSocket.isValid())\n    (coordinatorListenerSocket.port()) (JASSERT_ERRNO) (host) (port)\n    .Text(\"Failed to create socket to coordinator port.\"\n          \"\\nIf the above message (sterror) is:\"\n          \"\\n           \\\"Address already in use\\\" or \\\"Bad file descriptor\\\",\"\n          \"\\n  then this may be an old coordinator.\"\n          \"\\nEither try again a few seconds or a minute later,\"\n          \"\\nOr kill other coordinator (using same host and port):\"\n          \"\\n    dmtcp_command ---coord-host XXX --coord-port YYY --quit\"\n          \"\\nOr specify --join-coordinator if joining existing computation.\");\n  // Now dup the sockfd to\n  coordinatorListenerSocket.changeFd(PROTECTED_COORD_FD);\n  Util::setCoordPort(coordinatorListenerSocket.port());\n\n  JLOG(DMTCP)(\"Starting a new coordinator automatically.\")\n        (coordinatorListenerSocket.port());\n\n  if (fork() == 0) {\n    /* NOTE:  This code assumes that dmtcp_launch (the current program)\n     *  and dmtcp_coordinator are in the same directory.  Namely,\n     *  GetProgramDir() gets the dir of the current program (dmtcp_launch).\n     *  Hence, if dmtcp_coordinator is in a different directory, then\n     *     jalib::Filesystem::GetProgramDir() + \"/dmtcp_coordinator\"\n     *  will not exist, and the child will fail.\n     */\n    // We can't use Util::getPath() here since the SharedData has not been\n    // initialized yet.\n    string coordinator =\n      jalib::Filesystem::GetProgramDir() + \"/dmtcp_coordinator\";\n\n    char *modeStr = (char *)\"--daemon\";\n    char * args[] = {\n      (char*)coordinator.c_str(),\n      (char*)\"--quiet\",\n      /* If we wish to also suppress coordinator warnings, call --quiet twice */\n      (char*)\"--exit-on-last\",\n      modeStr,\n      NULL\n    };\n    execv(args[0], args);\n    JASSERT(false)(coordinator)(JASSERT_ERRNO) .Text(\"exec(dmtcp_coordinator) failed\");\n  } else {\n    int status;\n    _real_close(PROTECTED_COORD_FD);\n    JASSERT(wait(&status) > 0) (JASSERT_ERRNO);\n  }\n}\n\nvoid CoordinatorAPI::createNewConnToCoord(CoordinatorMode mode)\n{\n  if (mode & COORD_JOIN) {\n    _coordinatorSocket = createNewSocketToCoordinator(mode);\n    JASSERT(_coordinatorSocket.isValid()) (JASSERT_ERRNO)\n     .Text(\"Coordinator not found, but --join-coordinator specified. Exiting.\");\n  } else if (mode & COORD_NEW) {\n    startNewCoordinator(mode);\n    _coordinatorSocket = createNewSocketToCoordinator(mode);\n    JASSERT(_coordinatorSocket.isValid()) (JASSERT_ERRNO)\n      .Text(\"Error connecting to newly started coordinator.\");\n  } else if (mode & COORD_ANY) {\n    _coordinatorSocket = createNewSocketToCoordinator(mode);\n    if (!_coordinatorSocket.isValid()) {\n      JLOG(DMTCP)(\"Coordinator not found, trying to start a new one.\");\n      startNewCoordinator(mode);\n      _coordinatorSocket = createNewSocketToCoordinator(mode);\n      JASSERT(_coordinatorSocket.isValid()) (JASSERT_ERRNO)\n        .Text(\"Error connecting to newly started coordinator.\");\n    }\n  } else {\n    JASSERT(false) .Text(\"Not Reached\");\n  }\n  _coordinatorSocket.changeFd(PROTECTED_COORD_FD);\n}\n\nDmtcpMessage CoordinatorAPI::sendRecvHandshake(DmtcpMessage msg,\n                                               string progname,\n                                               UniquePid *compId)\n{\n  if (dmtcp_virtual_to_real_pid) {\n    msg.realPid = dmtcp_virtual_to_real_pid(getpid());\n  } else {\n    msg.realPid = getpid();\n  }\n\n  msg.theCheckpointInterval = getCkptInterval();\n  string hostname = jalib::Filesystem::GetCurrentHostname();\n  msg.extraBytes = hostname.length() + 1 + progname.length() + 1;\n\n  _coordinatorSocket << msg;\n  _coordinatorSocket.writeAll(hostname.c_str(), hostname.length() + 1);\n  _coordinatorSocket.writeAll(progname.c_str(), progname.length() + 1);\n\n  msg.poison();\n  _coordinatorSocket >> msg;\n  msg.assertValid();\n  if (msg.type == DMT_KILL_PEER) {\n    JLOG(DMTCP)(\"Received KILL message from coordinator, exiting\");\n    _real_exit (0);\n  }\n  if (msg.type == DMT_REJECT_NOT_RUNNING) {\n    JASSERT(false)\n      .Text(\"Connection rejected by the coordinator.\\n\"\n            \"Reason: Current computation not in RUNNING state.\\n\"\n            \"         Is a checkpoint/restart in progress?\");\n  } else if (msg.type == DMT_REJECT_WRONG_COMP) {\n    JASSERT(compId != NULL);\n    JASSERT(false) (*compId)\n      .Text(\"Connection rejected by the coordinator.\\n\"\n            \" Reason: This process has a different computation group.\");\n  }\n  // Coordinator also prints this, but its stderr may go to /dev/null\n  if (msg.type == DMT_REJECT_NOT_RESTARTING) {\n    string coordinatorHost = \"\"; // C++ magic code; \"\" to be invisibly replaced\n    int coordinatorPort = 0;\n    Util::getCoordHostAndPort(COORD_ANY, coordinatorHost, &coordinatorPort);\n    JNOTE (\"\\n\\n*** Computation not in RESTARTING or CHECKPOINTED state.\"\n        \"\\n***Can't join the existing coordinator, as it is serving a\"\n        \"\\n***different computation.  Consider launching a new coordinator.\"\n        \"\\n***Consider, also, checking with:  dmtcp_command --status\")\n        (coordinatorPort);\n  }\n  JASSERT(msg.type == DMT_ACCEPT)(msg.type);\n  return msg;\n}\n\nvoid CoordinatorAPI::connectToCoordOnStartup(CoordinatorMode mode,\n                                             string progname,\n                                             DmtcpUniqueProcessId *compId,\n                                             CoordinatorInfo *coordInfo,\n                                             struct in_addr  *localIP)\n{\n  JASSERT(compId != NULL && localIP != NULL && coordInfo != NULL);\n\n  if (mode & COORD_NONE) {\n    setupVirtualCoordinator(coordInfo, localIP);\n    *compId = coordInfo->id;\n    return;\n  }\n\n  createNewConnToCoord(mode);\n  JLOG(DMTCP)(\"sending coordinator handshake\")(UniquePid::ThisProcess());\n  DmtcpMessage hello_local(DMT_NEW_WORKER);\n  hello_local.virtualPid = -1;\n\n  DmtcpMessage hello_remote = sendRecvHandshake(hello_local, progname);\n\n  JASSERT(hello_remote.virtualPid != -1);\n  JLOG(DMTCP)(\"Got virtual pid from coordinator\") (hello_remote.virtualPid);\n\n  pid_t ppid = getppid();\n  Util::setVirtualPidEnvVar(hello_remote.virtualPid, ppid, ppid);\n\n  JASSERT(compId != NULL && localIP != NULL && coordInfo != NULL);\n  *compId = hello_remote.compGroup.upid();\n  coordInfo->id = hello_remote.from.upid();\n  coordInfo->timeStamp = hello_remote.coordTimeStamp;\n  coordInfo->addrLen = sizeof (coordInfo->addr);\n  JASSERT(getpeername(_coordinatorSocket.sockfd(),\n                      (struct sockaddr*) &coordInfo->addr,\n                      &coordInfo->addrLen) == 0)\n    (JASSERT_ERRNO);\n  memcpy(localIP, &hello_remote.ipAddr, sizeof hello_remote.ipAddr);\n}\n\nvoid CoordinatorAPI::createNewConnectionBeforeFork(string& progname)\n{\n  JASSERT(!noCoordinator())\n    .Text(\"Process attempted to call fork() while in --no-coordinator mode\\n\"\n          \"  Because the coordinator is embedded in a single process,\\n\"\n          \"    DMTCP will not work with multiple processes.\");\n  struct sockaddr_storage addr;\n  uint32_t len;\n  SharedData::getCoordAddr((struct sockaddr *)&addr, &len);\n  socklen_t addrlen = len;\n  _coordinatorSocket = jalib::JClientSocket((struct sockaddr *)&addr, addrlen);\n  JASSERT(_coordinatorSocket.isValid());\n\n  DmtcpMessage hello_local(DMT_NEW_WORKER);\n  DmtcpMessage hello_remote = sendRecvHandshake(hello_local, progname);\n  JASSERT(hello_remote.virtualPid != -1);\n\n  if (dmtcp_virtual_to_real_pid) {\n    JLOG(DMTCP)(\"Got virtual pid from coordinator\") (hello_remote.virtualPid);\n    pid_t pid = getpid();\n    pid_t realPid = dmtcp_virtual_to_real_pid(pid);\n    Util::setVirtualPidEnvVar(hello_remote.virtualPid, pid, realPid);\n  }\n}\n\nvoid CoordinatorAPI::connectToCoordOnRestart(CoordinatorMode  mode,\n                                             string progname,\n                                             UniquePid compGroup,\n                                             int np,\n                                             CoordinatorInfo *coordInfo,\n                                             const char *host,\n                                             int port,\n                                             struct in_addr  *localIP)\n{\n  if (mode & COORD_NONE) {\n    setupVirtualCoordinator(coordInfo, localIP);\n    return;\n  }\n\n  createNewConnToCoord(mode);\n  JLOG(DMTCP)(\"sending coordinator handshake\")(UniquePid::ThisProcess());\n  DmtcpMessage hello_local(DMT_RESTART_WORKER);\n  hello_local.virtualPid = -1;\n  hello_local.numPeers = np;\n  hello_local.compGroup = compGroup;\n\n  DmtcpMessage hello_remote = sendRecvHandshake(hello_local, progname,\n                                                &compGroup);\n\n  if (coordInfo != NULL) {\n    coordInfo->id = hello_remote.from.upid();\n    coordInfo->timeStamp = hello_remote.coordTimeStamp;\n    coordInfo->addrLen = sizeof (coordInfo->addr);\n    JASSERT(getpeername(_coordinatorSocket.sockfd(),\n                        (struct sockaddr*) &coordInfo->addr,\n                        &coordInfo->addrLen) == 0)\n      (JASSERT_ERRNO);\n  }\n  if (localIP != NULL) {\n    memcpy(localIP, &hello_remote.ipAddr, sizeof hello_remote.ipAddr);\n  }\n\n  JLOG(DMTCP)(\"Coordinator handshake RECEIVED!!!!!\");\n}\n\nvoid CoordinatorAPI::sendCkptFilename()\n{\n  if (noCoordinator()) return;\n  // Tell coordinator to record our filename in the restart script\n  string ckptFilename = ProcessInfo::instance().getCkptFilename();\n  string hostname = jalib::Filesystem::GetCurrentHostname();\n  DmtcpMessage msg;\n  if (dmtcp_unique_ckpt_enabled && dmtcp_unique_ckpt_enabled()) {\n    msg.type = DMT_UNIQUE_CKPT_FILENAME;\n  } else {\n    msg.type = DMT_CKPT_FILENAME;\n  }\n  // Tell coordinator type of remote shell command used ssh/rsh\n  const char* shellType = \"\";\n  const char *remoteShellType = getenv(ENV_VAR_REMOTE_SHELL_CMD);\n  if(remoteShellType != NULL) {\n    shellType = remoteShellType;\n  }\n\n  JLOG(DMTCP)(\"recording filenames\") (ckptFilename) (hostname) (shellType);\n  msg.extraBytes = ckptFilename.length() + 1 + hostname.length() + 1+ strlen(shellType) + 1;\n \n  _coordinatorSocket << msg;\n  _coordinatorSocket.writeAll(ckptFilename.c_str(), ckptFilename.length() + 1);\n  _coordinatorSocket.writeAll(shellType, strlen(shellType) + 1);\n  _coordinatorSocket.writeAll(hostname.c_str(), hostname.length() + 1);\n}\n\n\nint CoordinatorAPI::sendKeyValPairToCoordinator(const char *id,\n                                                const void *key,\n                                                uint32_t key_len,\n                                                const void *val,\n                                                uint32_t val_len,\n                                                int sync)\n{\n  DmtcpMessage msg (DMT_REGISTER_NAME_SERVICE_DATA);\n  if (sync) {\n    msg.type = DMT_REGISTER_NAME_SERVICE_DATA_SYNC;\n  }\n  JWARNING(strlen(id) < sizeof(msg.nsid));\n  strncpy(msg.nsid, id, sizeof msg.nsid);\n  msg.keyLen = key_len;\n  msg.valLen = val_len;\n  msg.extraBytes = key_len + val_len;\n  jalib::JSocket sock = _coordinatorSocket;\n  if (dmtcp_is_running_state()) {\n    if (_nsSock.sockfd() == -1) {\n      _nsSock = createNewSocketToCoordinator(COORD_ANY);\n      JASSERT(_nsSock.isValid());\n      _nsSock.changeFd(PROTECTED_NS_FD);\n      DmtcpMessage m(DMT_NAME_SERVICE_WORKER);\n      _nsSock << m;\n    }\n    sock = _nsSock;\n    JASSERT(sock.isValid());\n  }\n\n  sock << msg;\n  sock.writeAll((const char *)key, key_len);\n  sock.writeAll((const char *)val, val_len);\n  if (sync) {\n    msg.poison();\n    sock >> msg;\n    JASSERT(msg.type == DMT_REGISTER_NAME_SERVICE_DATA_SYNC_RESPONSE)(msg.type);\n\n  }\n  return 1;\n}\n\n// On input, val points to a buffer in user memory and *val_len is the maximum\n//   size of that buffer (the memory allocated by user).\n// On output, we copy data to val, and set *val_len to the actual buffer size\n//   (to the size of the data that we copied to the user buffer).\nint CoordinatorAPI::sendQueryToCoordinator(const char *id,\n                                           const void *key,\n                                           uint32_t key_len,\n                                           void *val,\n                                           uint32_t *val_len)\n{\n  DmtcpMessage msg (DMT_NAME_SERVICE_QUERY);\n  JWARNING(strlen(id) < sizeof(msg.nsid));\n  strncpy(msg.nsid, id, sizeof msg.nsid);\n  msg.keyLen = key_len;\n  msg.valLen = 0;\n  msg.extraBytes = key_len;\n  jalib::JSocket sock = _coordinatorSocket;\n\n  if (key == NULL || key_len == 0 || val == NULL || val_len == 0) {\n    return 0;\n  }\n\n  if (dmtcp_is_running_state()) {\n    if (!_nsSock.isValid()) {\n      _nsSock = createNewSocketToCoordinator(COORD_ANY);\n      JASSERT(_nsSock.isValid());\n      _nsSock.changeFd(PROTECTED_NS_FD);\n      DmtcpMessage m(DMT_NAME_SERVICE_WORKER);\n      _nsSock << m;\n    }\n    sock = _nsSock;\n    JASSERT(sock.isValid());\n  }\n\n  sock << msg;\n  sock.writeAll((const char *)key, key_len);\n\n  msg.poison();\n  sock >> msg;\n  msg.assertValid();\n  JASSERT(msg.type == DMT_NAME_SERVICE_QUERY_RESPONSE &&\n          msg.extraBytes == msg.valLen);\n\n  JASSERT (*val_len >= msg.valLen);\n  *val_len = msg.valLen;\n  if (*val_len > 0) {\n    sock.readAll((char*)val, *val_len);\n  }\n\n  return *val_len;\n}\n\nint CoordinatorAPI::getUniqueIdFromCoordinator(const char *id,\n                                               const void *key,\n                                               uint32_t key_len,\n                                               void *val,\n                                               uint32_t *val_len,\n                                               uint32_t offset /* = 1 */)\n{\n  DmtcpMessage msg(DMT_NAME_SERVICE_GET_UNIQUE_ID);\n\n  JWARNING(strlen(id) < sizeof(msg.nsid));\n  strncpy(msg.nsid, id, sizeof msg.nsid);\n  msg.keyLen = key_len;\n  msg.valLen = 0;\n  msg.extraBytes = key_len;\n  msg.uniqueIdOffset = offset;\n  jalib::JSocket sock = _coordinatorSocket;\n\n  if (key == NULL || key_len == 0 || val == NULL || val_len == 0) {\n    return 0;\n  }\n\n  msg.valLen = *val_len;\n\n  if (dmtcp_is_running_state()) {\n    if (!_nsSock.isValid()) {\n      _nsSock = createNewSocketToCoordinator(COORD_ANY);\n      JASSERT(_nsSock.isValid());\n      _nsSock.changeFd(PROTECTED_NS_FD);\n      DmtcpMessage m(DMT_NAME_SERVICE_WORKER);\n      _nsSock << m;\n    }\n    sock = _nsSock;\n    JASSERT(sock.isValid());\n  }\n\n  JASSERT(Util::writeAll(sock, &msg, sizeof(msg)) == sizeof(msg));\n  JASSERT(Util::writeAll(sock, key, key_len) == key_len);\n\n  msg.poison();\n\n  JASSERT(Util::readAll(sock, &msg, sizeof(msg)) == sizeof(msg));\n  msg.assertValid();\n  JASSERT(msg.type == DMT_NAME_SERVICE_GET_UNIQUE_ID_RESPONSE &&\n          msg.extraBytes == msg.valLen);\n\n  JASSERT(*val_len >= msg.valLen);\n  *val_len = msg.valLen;\n  JASSERT(Util::readAll(sock, val, *val_len) == *val_len);\n\n  return *val_len;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/src/Makefile.am": "# We should disable AM_MAINTAINER_MODE since otherwise a re-build by the\n#  end-user may require local tools, which may be missing or whose version is\n#  incompatible with these tools (e.g. autoheader).  Instead, we run NMI and\n#  openSUSE build services to test compatibility with end-user machines.\n#  The developers should run autoconf, automake, etc., as needed, but\n#  not propagate to the svn-generated tools that may be incompatible\n#  with the user's local tools.  - Gene\n# See http://www.gnu.org/s/hello/manual/automake/CVS.html#CVS\n# AM_MAINTAINER_MDE([disable])\n\n# not a GNU package. You can remove this line, if\n# have all needed files, that a GNU package needs\n# TODO(kapil): Add 'subdir-objects after automake 1.16 has been released.\nAUTOMAKE_OPTIONS = foreign\n\njalibdir=$(top_srcdir)/jalib\ndmtcpincludedir=$(top_srcdir)/include\ndmtcplibdir = $(pkglibdir)\n\nSUBDIRS = mtcp plugin\n\nPICFLAGS=-fPIC\nAM_CFLAGS = $(PICFLAGS)\nAM_CXXFLAGS = $(PICFLAGS)\nAM_LDFLAGS = $(PICFLAGS)\n\nif CONFIG_M32\nd_libdir = $(top_builddir)/lib/$(PACKAGE)/32/lib/$(PACKAGE)\nd_bindir = $(top_builddir)/lib/$(PACKAGE)/32/bin\nelse\nd_libdir = $(top_builddir)/lib/$(PACKAGE)\nd_bindir = $(top_builddir)/bin\nendif\n\nif FAST_RST_VIA_MMAP\n  AM_CXXFLAGS += -DFAST_RST_VIA_MMAP\nendif\n\n#HEADERS\n#set the include path found by configure\nAM_CPPFLAGS= -I$(dmtcpincludedir) -I$(jalibdir)\n\n# targets:\nnoinst_LIBRARIES = libdmtcpinternal.a\t\t\t\t\\\n\t\t   libsyscallsreal.a\t\t\t\t\\\n\t\t   libnohijack.a\t\t\t\t\\\n\t\t   libjalib.a\n\nbin_PROGRAMS = $(d_bindir)/dmtcp_launch\t\t\t\t\\\n\t       $(d_bindir)/dmtcp_command\t\t\t\\\n\t       $(d_bindir)/dmtcp_coordinator\t\t\t\\\n\t       $(d_bindir)/dmtcp_restart\t\t\t\\\n\t       $(d_bindir)/dmtcp_nocheckpoint\n\ndmtcplib_PROGRAMS = $(d_libdir)/libdmtcp.so\ninclude_HEADERS = $(srcdir)/../include/dmtcp.h\n\n# headers:\nnobase_noinst_HEADERS = constants.h \\\n\t$(jalibdir)/jassert.h $(jalibdir)/jalloc.h $(jalibdir)/jalib.h \\\n\t$(jalibdir)/jbuffer.h $(jalibdir)/jconvert.h $(jalibdir)/jfilesystem.h \\\n\t$(jalibdir)/jserialize.h $(jalibdir)/jsocket.h $(jalibdir)/jtimer.h \\\n\t$(dmtcpincludedir)/dmtcpalloc.h $(dmtcpincludedir)/dmtcp.h \\\n\t$(dmtcpincludedir)/dmtcpplugin.h \\\n\t$(dmtcpincludedir)/protectedfds.h $(dmtcpincludedir)/shareddata.h \\\n\t$(dmtcpincludedir)/trampolines.h $(dmtcpincludedir)/util.h \\\n\t$(dmtcpincludedir)/virtualidtable.h $(dmtcpincludedir)/procmapsarea.h \\\n\t$(dmtcpincludedir)/procselfmaps.h \\\n\trestartscript.h \\\n\tdmtcp_coordinator.h dmtcpmessagetypes.h workerstate.h lookup_service.h \\\n\tdmtcpworker.h threadsync.h coordinatorapi.h \\\n\tmtcpinterface.h syscallwrappers.h \\\n\tthreadlist.h threadinfo.h siginfo.h \\\n\tuniquepid.h processinfo.h ckptserializer.h \\\n\tmtcp/ldt.h mtcp/restore_libc.h mtcp/tlsutil.h\n\n# Note that libdmtcpinternal.a does not include wrappers.\n# dmtcp_launch, dmtcp_command, dmtcp_coordinator, etc.\n#   should not need wrappers.\nlibdmtcpinternal_a_SOURCES = dmtcpmessagetypes.cpp  coordinatorapi.cpp \\\n\t\t\t     workerstate.cpp \\\n\t\t\t     dmtcp_dlsym.cpp \\\n\t\t\t     uniquepid.cpp shareddata.cpp \\\n\t\t\t     util_exec.cpp util_misc.cpp util_init.cpp \\\n\t\t\t     jalibinterface.cpp processinfo.cpp procselfmaps.cpp\n\nlibjalib_a_SOURCES = $(jalibdir)/jalib.cpp $(jalibdir)/jassert.cpp \\\n\t\t     $(jalibdir)/jbuffer.cpp $(jalibdir)/jfilesystem.cpp \\\n\t\t     $(jalibdir)/jserialize.cpp $(jalibdir)/jsocket.cpp \\\n\t\t     $(jalibdir)/jtimer.cpp $(jalibdir)/jalloc.cpp\n\n# FIXME:  Rename libsyscallsreal.a to libhijack.a\n# An executable should use either libsyscallsreal.a or libnohijack.a -- not both\nlibsyscallsreal_a_SOURCES = syscallsreal.c trampolines.cpp\nlibnohijack_a_SOURCES = nosyscallsreal.c dmtcpnohijackstubs.cpp\n\n__d_bindir__dmtcp_coordinator_SOURCES = dmtcp_coordinator.cpp lookup_service.cpp restartscript.cpp\n\n__d_bindir__dmtcp_nocheckpoint_SOURCES = dmtcp_nocheckpoint.c\n\n__d_bindir__dmtcp_restart_SOURCES = dmtcp_restart.cpp util_exec.cpp\n\n__d_bindir__dmtcp_command_SOURCES = dmtcp_command.cpp\n\n__d_libdir__libdmtcp_so_SOURCES = dmtcpworker.cpp threadsync.cpp \\\n\t\t      coordinatorapi.cpp execwrappers.cpp \\\n\t\t      mtcpinterface.cpp signalwrappers.cpp \\\n\t\t      terminal.cpp \\\n\t\t      alarm.cpp \\\n\t\t      threadwrappers.cpp \\\n\t\t      miscwrappers.cpp ckptserializer.cpp writeckpt.cpp \\\n\t\t      glibcsystem.cpp \\\n\t\t      threadlist.cpp siginfo.cpp \\\n\t\t      dmtcpplugin.cpp popen.cpp syslogwrappers.cpp \\\n\t\t      dmtcp_dlsym.cpp\n\n__d_libdir__libdmtcp_so_LDFLAGS = -shared -Xlinker -znow\n\n# Note that an ELF object uses libsyscallsreal.a or libnohijack.a\n#  but not both.  libnohijack.a has stub definitions for same symbols.\n__d_libdir__libdmtcp_so_LDADD = libdmtcpinternal.a libjalib.a \\\n\t\t\t\tlibsyscallsreal.a mtcp/libmtcp.a \\\n\t\t\t\t-ldl -lpthread -lrt\n\n__d_bindir__dmtcp_coordinator_LDADD = libdmtcpinternal.a libjalib.a \\\n\t\t\t  libnohijack.a -lpthread -lrt\n__d_bindir__dmtcp_launch_LDADD  = libdmtcpinternal.a libjalib.a \\\n\t\t\t  libnohijack.a -lpthread -lrt -ldl\n__d_bindir__dmtcp_restart_LDADD     = libdmtcpinternal.a libjalib.a \\\n\t\t\t  libnohijack.a -lpthread -lrt -ldl\n__d_bindir__dmtcp_command_LDADD     = libdmtcpinternal.a libjalib.a \\\n\t\t\t  libnohijack.a -lpthread -lrt -ldl\n\n__d_bindir__dmtcp_launch_SOURCES = dmtcp_launch.cpp\n\nmtcp/libmtcp.a:\n\tcd mtcp && ${MAKE} libmtcp.a\n\ninstall-libs: install-dmtcplibPROGRAMS\n\t(cd mtcp && ${MAKE} install-libs)\n\t(cd plugin && ${MAKE} install-libs)\n\nuninstall-libs: uninstall-dmtcplibPROGRAMS\n\t(cd mtcp && ${MAKE} uninstall-libs)\n\t(cd plugin && ${MAKE} uninstall-libs)\n\n.PHONY: install-libs uninstall-libs\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/src/util_exec.cpp": "/****************************************************************************\n *   Copyright (C) 2006-2013 by Jason Ansel, Kapil Arya, and Gene Cooperman *\n *   jansel@csail.mit.edu, kapil@ccs.neu.edu, gene@ccs.neu.edu              *\n *                                                                          *\n *  This file is part of DMTCP.                                             *\n *                                                                          *\n *  DMTCP is free software: you can redistribute it and/or                  *\n *  modify it under the terms of the GNU Lesser General Public License as   *\n *  published by the Free Software Foundation, either version 3 of the      *\n *  License, or (at your option) any later version.                         *\n *                                                                          *\n *  DMTCP is distributed in the hope that it will be useful,                *\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of          *\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *\n *  GNU Lesser General Public License for more details.                     *\n *                                                                          *\n *  You should have received a copy of the GNU Lesser General Public        *\n *  License along with DMTCP:dmtcp/src.  If not, see                        *\n *  <http://www.gnu.org/licenses/>.                                         *\n ****************************************************************************/\n\n#include <string.h>\n#include <fcntl.h>\n#include <sys/time.h>\n#include <sys/resource.h>\n#include  \"util.h\"\n#include  \"syscallwrappers.h\"\n#include  \"uniquepid.h\"\n#include  \"protectedfds.h\"\n#include  \"shareddata.h\"\n#include  \"../jalib/jassert.h\"\n#include  \"../jalib/jfilesystem.h\"\n#include  \"../jalib/jconvert.h\"\n\nusing namespace dmtcp;\n\nstatic int32_t getDlsymOffset();\nstatic int32_t getDlsymOffset_m32();\n\nvoid Util::setVirtualPidEnvVar(pid_t pid, pid_t virtPpid, pid_t realPpid)\n{\n  // We want to use setenv() only once. For all later changes, we manipulate\n  // the buffer in place. This was done to avoid a bug when using Perl. Perl\n  // implements its own setenv by keeping a private copy libc:environ and never\n  // refers to libc:private, thus libc:setenv is outdated and calling setenv()\n  // can cause segfault.\n  char buf1[80];\n  char buf2[80];\n  memset(buf2, '#', sizeof(buf2));\n  buf2[sizeof(buf2) - 1] = '\\0';\n\n  sprintf(buf1, \"%d:%d:%d:\", pid, virtPpid, realPpid);\n\n  if (getenv(ENV_VAR_VIRTUAL_PID) == NULL) {\n    memcpy(buf2, buf1, strlen(buf1));\n    setenv(ENV_VAR_VIRTUAL_PID, buf2, 1);\n  } else {\n    char *envStr = (char*) getenv(ENV_VAR_VIRTUAL_PID);\n    memcpy(envStr, buf1, strlen(buf1));\n  }\n}\n\n// 'screen' requires directory with permissions 0700\nstatic int isdir0700(const char *pathname)\n{\n  struct stat st;\n  stat(pathname, &st);\n  return (S_ISDIR(st.st_mode) == 1\n          && (st.st_mode & 0777) == 0700\n          && st.st_uid == getuid()\n          && access(pathname, R_OK | W_OK | X_OK) == 0\n      );\n}\n\nint Util::safeMkdir(const char *pathname, mode_t mode)\n{\n  // If it exists and we can give it the right permissions, do it.\n  chmod(pathname, 0700);\n  if (isdir0700(pathname))\n    return 0;\n  // else start over\n  unlink(pathname);\n  rmdir(pathname); // Maybe it was an empty directory\n  mkdir(pathname, 0700);\n  return isdir0700(pathname);\n}\n\nint Util::safeSystem(const char *command)\n{\n  char *str = getenv(\"LD_PRELOAD\");\n  string dmtcphjk;\n  if (str != NULL)\n    dmtcphjk = str;\n  unsetenv(\"LD_PRELOAD\");\n  int rc = _real_system(command);\n  if (str != NULL)\n    setenv(\"LD_PRELOAD\", dmtcphjk.c_str(), 1);\n  return rc;\n}\n\nint Util::expandPathname(const char *inpath, char * const outpath,\n                                size_t size)\n{\n  bool success = false;\n  if (*inpath == '/' || strstr(inpath, \"/\") != NULL) {\n    strncpy(outpath, inpath, size);\n    success = true;\n  } else if (strStartsWith(inpath, \"~/\")) {\n    snprintf(outpath, size, \"%s%s\", getenv(\"HOME\"), &inpath[1]);\n    success = true;\n  } else if (strStartsWith(inpath, \"~\")) {\n    snprintf(outpath, size, \"/home/%s\", &inpath[1]);\n    success = true;\n  } else if (strStartsWith(inpath, \".\")) {\n    snprintf(outpath, size, \"%s/%s\", jalib::Filesystem::GetCWD().c_str(),\n                                     inpath);\n    success = true;\n  } else {\n    char *pathVar = getenv(\"PATH\");\n    outpath[0] = '\\0';\n    if (pathVar == NULL) {\n      pathVar = (char*) \":/bin:/usr/bin\";\n    }\n    while (*pathVar != '\\0') {\n      char *nextPtr;\n      nextPtr = strchrnul(pathVar, ':');\n      if (nextPtr == pathVar) {\n        /* Two adjacent colons, or a colon at the beginning or the end\n           of `PATH' means to search the current directory.  */\n        strcpy(outpath, jalib::Filesystem::GetCWD().c_str());\n      } else {\n        strncpy(outpath, pathVar, nextPtr - pathVar);\n        outpath[nextPtr-pathVar] = '\\0';\n      }\n\n      JASSERT(size > strlen(outpath) + strlen(inpath) + 1)\n        (size) (outpath) (strlen(outpath)) (inpath) (strlen(inpath))\n         .Text(\"Pathname too long; Use larger buffer.\");\n\n      strcat(outpath, \"/\");\n      strcat(outpath, inpath);\n\n      if (*nextPtr  == '\\0')\n        pathVar = nextPtr;\n      else // else *nextPtr == ':'\n        pathVar = nextPtr + 1; // prepare for next iteration\n      if (access(outpath, X_OK) == 0) {\n\tsuccess = true;\n\tbreak;\n      }\n    }\n  }\n  return (success ? 0 : -1);\n}\n\nint Util::elfType(const char *pathname, bool *isElf, bool *is32bitElf)\n{\n  const char *magic_elf = \"\\177ELF\"; // Magic number for ELF\n  const char *magic_elf32 = \"\\177ELF\\001\"; // Magic number for ELF 32-bit\n  // Magic number for ELF 64-bit is \"\\177ELF\\002\"\n  const int len = strlen(magic_elf32);\n  char argv_buf[len + 1];\n  char full_path[PATH_MAX];\n  expandPathname(pathname, full_path, sizeof(full_path));\n  int fd = _real_open(full_path, O_RDONLY, 0);\n  if (fd == -1) {\n    return -1;\n  }\n  ssize_t ret = readAll(fd, argv_buf, len);\n  close (fd);\n  if (ret != len) {\n    return -1;\n  }\n  *isElf = (memcmp(magic_elf, argv_buf, strlen(magic_elf)) == 0);\n  *is32bitElf = (memcmp(magic_elf32, argv_buf, strlen(magic_elf32)) == 0);\n  return 0;\n}\n\nstatic string ld_linux_so_path(int version, bool is32bitElf = false)\n{\n  char buf[80];\n#if (defined(__x86_64__) || defined(__aarch64__)) && !defined(CONFIG_M32)\n  if (is32bitElf) {\n    sprintf(buf, \"/lib/ld-linux.so.%d\", version);\n  } else {\n    sprintf(buf, ELF_INTERPRETER);\n  }\n#else\n  sprintf(buf, ELF_INTERPRETER);\n#endif\n\n  string cmd = buf;\n  return cmd;\n}\n\nbool Util::isStaticallyLinked(const char *filename)\n{\n  bool isElf, is32bitElf;\n  char pathname[PATH_MAX];\n  expandPathname(filename, pathname, sizeof(pathname));\n  elfType(pathname, &isElf, &is32bitElf);\n\n  int version = 2;\n  string cmd;\n  do {\n    cmd = ld_linux_so_path(version, is32bitElf);\n    version++;\n  } while (!jalib::Filesystem::FileExists(cmd) && version < 10);\n\n  cmd = cmd + \" --verify \" + pathname + \" > /dev/null\";\n\n  // FIXME:  When tested on dmtcp/test/pty.c, 'ld.so -verify' returns\n  // nonzero status.  Why is this?  It's dynamically linked.\n  if (isElf && safeSystem(cmd.c_str())) {\n    return true;\n  }\n  return false;\n}\n\nbool Util::isScreen(const char *filename)\n{\n  return jalib::Filesystem::BaseName(filename) == \"screen\" &&\n         isSetuid(filename);\n}\n\n//NOTE:  This routine is called only if 'screen' is setuid.\n// In Ubuntu 9.10, an unprivileged 'screen' (no setuid) will ckpt and restart\n// fine if SCREENDIR is set to the file $USER/tmp4 when $USER/tmp4 doesn't exist\n// Arguably this is a bug in screen-4.0.  Should we take advantage of it?\nvoid Util::setScreenDir() {\n  if (getenv(\"SCREENDIR\") == NULL) {\n    // This will flash by, but the user will see it again on exiting screen.\n    JASSERT_STDERR <<\"*** WARNING: Environment variable SCREENDIR is not set!\\n\"\n                   << \"***  Set this to a safe location, and if restarting on\\n\"\n                   << \"***  a new host, copy your SCREENDIR directory there.\\n\"\n                   << \"***  DMTCP will use\"\n                            \" $DMTCP_TMPDIR/dmtcp-USER@HOST/uscreens for now,\\n\"\n                   << \"***  but this directory may not survive a re-boot!\\n\"\n                   << \"***      As of DMTCP-1.2.3, emacs23 not yet supported\\n\"\n                   << \"***  inside screen.  Please use emacs22 for now.  This\\n\"\n                   << \"***  will be fixed in a future version of DMTCP.\\n\\n\";\n    setenv(\"SCREENDIR\", Util::getScreenDir().c_str(), 1);\n  } else {\n    if (access(getenv(\"SCREENDIR\"), R_OK|W_OK|X_OK) != 0)\n      JASSERT_STDERR << \"*** WARNING: Environment variable SCREENDIR is set\\n\"\n                     << \"***  to directory with improper permissions.\\n\"\n                     << \"***  Please use a SCREENDIR with permission 700.\"\n                     << \"  [ SCREENDIR = \" << getenv(\"SCREENDIR\") << \" ]\\n\"\n                     << \"***  Continuing anyway, and hoping for the best.\\n\";\n  }\n\n}\n\nstring Util::getScreenDir()\n{\n  string tmpdir = string(dmtcp_get_tmpdir()) + \"/\" + \"uscreens\";\n  safeMkdir(tmpdir.c_str(), 0700);\n  return tmpdir;\n}\n\nbool Util::isSetuid(const char *filename)\n{\n  char pathname[PATH_MAX];\n  if (expandPathname(filename, pathname, sizeof(pathname)) ==  0) {\n    struct stat buf;\n    if (stat(pathname, &buf) == 0 && (buf.st_mode & S_ISUID ||\n                                      buf.st_mode & S_ISGID)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nvoid Util::patchArgvIfSetuid(const char* filename, char *const origArgv[],\n                             char ***newArgv)\n{\n  if (isSetuid(filename) == false) return;\n\n  char realFilename[PATH_MAX];\n  memset(realFilename, 0, sizeof(realFilename));\n  expandPathname(filename, realFilename, sizeof (realFilename));\n  //char expandedFilename[PATH_MAX];\n//  expandPathname(filename, expandedFilename, sizeof (expandedFilename));\n//  JASSERT(readlink(expandedFilename, realFilename, PATH_MAX - 1) != -1)\n//    (filename) (expandedFilename) (realFilename) (JASSERT_ERRNO);\n\n  size_t newArgc = 0;\n  while (origArgv[newArgc] != NULL) newArgc++;\n  newArgc += 2;\n  size_t newArgvSize = newArgc * sizeof(char*);\n\n  // IS THIS A MEMORY LEAK?  WHEN DO WE FREE buf?  - Gene\n  void *buf = JALLOC_HELPER_MALLOC(newArgvSize + 2 + PATH_MAX);\n  memset(buf, 0, newArgvSize + 2 + PATH_MAX);\n\n  *newArgv = (char**) buf;\n  char *newFilename = (char*)buf + newArgvSize + 1;\n\n#define COPY_BINARY\n#ifdef COPY_BINARY\n  // cp /usr/bin/screen /tmp/dmtcp-USER@HOST/screen\n  char cpCmdBuf[PATH_MAX * 2 + 8];\n\n  snprintf(newFilename, PATH_MAX, \"%s/%s\",\n                                  dmtcp_get_tmpdir(),\n                                  jalib::Filesystem::BaseName(realFilename).c_str());\n\n  snprintf(cpCmdBuf, sizeof(cpCmdBuf),\n           \"/bin/cp %s %s\", realFilename, newFilename);\n\n  // Remove any stale copy, just in case it's not right.\n  JASSERT(unlink(newFilename) == 0 || errno == ENOENT) (newFilename);\n\n  JASSERT(safeSystem(cpCmdBuf) == 0)(cpCmdBuf)\n    .Text(\"call to system(cpCmdBuf) failed\");\n\n  JASSERT(access(newFilename, X_OK) == 0) (newFilename) (JASSERT_ERRNO);\n\n  (*newArgv)[0] = newFilename;\n  int i;\n  for (i = 1; origArgv[i] != NULL; i++)\n    (*newArgv)[i] = (char*)origArgv[i];\n  (*newArgv)[i] = origArgv[i];  // copy final NULL pointer.\n\n  return;\n#else\n  // FIXME : This might fail to compile. Will fix later. -- Kapil\n  // Translate: screen   to: /lib/ld-linux.so /usr/bin/screen\n  // This version is more general, but has a bug on restart:\n  //    memory layout is altered on restart, and so brk() doesn't match.\n  // Switch argvPtr from ptr to input to ptr to output now.\n  *argvPtr = (char **)(cmdBuf + strlen(cmdBuf) + 1); // ... + 1 for '\\0'\n  // Use /lib64 if 64-bit O/S and not 32-bit app:\n\n  char *ldStrPtr = NULL;\n#if (defined(__x86_64__) || defined(__aarch64__)) && !defined(CONFIG_M32)\n  bool isElf, is32bitElf;\n  elfType(cmdBuf, &isElf, &is32bitElf);\n  if (is32bitElf)\n    ldStrPtr = (char *)\"/lib/ld-linux.so.2\";\n  else\n    ldStrPtr = (char *)ELF_INTERPRETER;\n# else\n  ldStrPtr = (char *)ELF_INTERPRETER;\n# endif\n\n  JASSERT(newArgv0Len > strlen(origPath) + 1)\n    (newArgv0Len) (origPath) (strlen(origPath)) .Text(\"Buffer not large enough\");\n\n  strncpy(newArgv0, origPath, newArgv0Len);\n\n  size_t origArgvLen = 0;\n  while (origArgv[origArgvLen] != NULL)\n    origArgvLen++;\n\n  JASSERT(newArgvLen >= origArgvLen + 1) (origArgvLen) (newArgvLen)\n    .Text(\"newArgv not large enough to hold the expanded argv\");\n\n  // ISN'T THIS A BUG?  newArgv WAS DECLARED 'char ***'.\n  newArgv[0] = ldStrPtr;\n  newArgv[1] = newArgv0;\n  for (int i = 1; origArgv[i] != NULL; i++)\n    newArgv[i+1] = origArgv[i];\n  newArgv[i+1] = origArgv[i]; // Copy final NULL pointer.\n#endif\n  return;\n}\n\nvoid Util::freePatchedArgv(char **newArgv)\n{\n  JALLOC_HELPER_FREE(*newArgv);\n}\n\n// FIXME: ENV_VAR_DLSYM_OFFSET should be reset in _real_dlsym and it should be\n// recalculated/reset right before returning from prepareForExec to support\n// process migration (the offset might have changed after the process had\n// migrated to a new machine with different ld.so.\nvoid Util::prepareDlsymWrapper()\n{\n  /* For the sake of dlsym wrapper. We compute the address of _real_dlsym by\n   * adding dlsym_offset to the address of dlopen after the exec into the user\n   * application. */\n  uint32_t offset = SharedData::getDlsymOffset();\n  uint32_t offset_m32 = SharedData::getDlsymOffset_m32();\n\n  if (offset == 0) {\n    offset = getDlsymOffset();\n    offset_m32 = getDlsymOffset_m32();\n    SharedData::updateDlsymOffset(offset, offset_m32);\n  }\n\n  char str[21] = {0};\n  sprintf(str, \"%d\", offset);\n  setenv(ENV_VAR_DLSYM_OFFSET, str, 1);\n  sprintf(str, \"%d\", offset_m32);\n  setenv(ENV_VAR_DLSYM_OFFSET_M32, str, 1);\n}\n\nstatic int32_t getDlsymOffset()\n{\n  void* base_addr = NULL;\n  void* dlsym_addr = NULL;\n  int32_t offset;\n  void* handle = NULL;\n  handle = dlopen(LIBDL_FILENAME, RTLD_NOW);\n  JASSERT(handle != NULL) (dlerror());\n\n  /* Earlier, we used to compute the offset of \"dlsym\" from \"dlerror\" by\n   * computing the address of the two symbols using '&' operator. However, in\n   * some distros (for ex. SLES 9), '&dlsym' might give the address of the\n   * symbol defined in binary's PLT. Thus, to compute the correct offset, we\n   * use dlopen/dlsym.\n   */\n  base_addr = dlsym(handle, LIBDL_BASE_FUNC_STR);\n  dlsym_addr = dlsym(handle, \"dlsym\");\n  dlclose(handle);\n  offset = (char *)dlsym_addr - (char *)base_addr;\n  return offset;\n}\n\nstatic int32_t getDlsymOffset_m32()\n{\n  uint64_t base_addr = 0;\n  uint64_t dlsym_addr = 0;\n  int32_t offset;\n  FILE *fp;\n  char buf[PATH_MAX];\n  string cmd1, cmd2, libdl, libdmtcp32;\n\n  libdmtcp32 = Util::getPath(\"libdmtcp.so\", true);\n  if (libdmtcp32 == \"libdmtcp.so\") return 0;\n\n  cmd1 = \"ldd \" + libdmtcp32 + \" | grep \" + LIBDL_FILENAME\n       + \" | tr '\\t' ' ' | tr -s ' '| cut -d' ' -f4\";\n  fp = popen(cmd1.c_str(), \"r\");\n  JASSERT(fp != NULL);\n  JASSERT(fscanf(fp, \"%s\", (char*) &buf) == 1);\n  pclose(fp);\n  JASSERT(buf[0] == '/');\n\n  libdl = buf;\n\n  cmd2 = \"nm -D -g \" + libdl + \" | grep '\" + LIBDL_BASE_FUNC_STR + \"'\";\n  fp = popen(cmd2.c_str(), \"r\");\n  JASSERT(fp != NULL);\n  // fread returns the total number of bytes read only when 'size' is 1.\n  JASSERT(fread(buf, 1, sizeof(buf), fp) > 0);\n  base_addr = strtoull(buf, NULL, 16);\n  JASSERT(base_addr != 0);\n  pclose(fp);\n\n  cmd2 = \"nm -D -g \" + libdl + \" | grep 'dlsym'\";\n  fp = popen(cmd2.c_str(), \"r\");\n  JASSERT(fp != NULL);\n  JASSERT(fread(buf, 1, sizeof(buf), fp) > 0);\n  dlsym_addr = strtoull(buf, NULL, 16);\n  JASSERT(base_addr != 0);\n  pclose(fp);\n\n  offset = (int32_t) ((char *)dlsym_addr - (char *)base_addr);\n  return offset;\n}\n\nvoid Util::runMtcpRestore(int is32bitElf, const char* path, int fd,\n                                 size_t argvSize, size_t envSize)\n{\n  static string mtcprestart = Util::getPath (\"mtcp_restart\");\n\n  if (is32bitElf) {\n    mtcprestart = Util::getPath(\"mtcp_restart-32\", is32bitElf);\n  }\n\n  // Tell mtcp_restart process to write its debugging information to\n  // PROTECTED_STDERR_FD. This way we prevent it from spitting out garbage onto\n  // FD_STDERR if it is being used by the user process in a special way.\n  char protected_stderr_fd_str[16];\n  sprintf(protected_stderr_fd_str, \"%d\", PROTECTED_STDERR_FD);\n\n  char buf[64];\n  sprintf(buf, \"%d\", fd);\n\n  char* newArgs[] = {\n    (char*) mtcprestart.c_str(),\n    (char*) \"--stderr-fd\",\n    protected_stderr_fd_str,\n    (char*) \"--fd\",\n    buf,\n    NULL\n  };\n  JLOG(DMTCP) (\"launching mtcp_restart --fd\")(fd)(path);\n\n  // Create the placeholder for \"MTCP_OLDPERS\" environment.\n  // setenv(\"MTCP_OLDPERS_DUMMY\", \"XXXXXXXXXXXXXXXX\", 1);\n  // FIXME: Put an explanation of the logic below.   -- Kapil\n#define ENV_PTR(x) ((char*) (getenv(x) - strlen(x) - 1))\n  char* dummyEnviron = NULL;\n  const int pathIndex = 0; // index in newEnv[]\n  const int dummyEnvironIndex = 1; // index in newEnv[]\n  // Eventually, newEnv = {ENV_PTR(\"MTCP_OLDPERS\"), ENV_PTR(\"PATH\"), NULL}\n  // newEnv[2] = NULL; newEnv[3] and newEnv[4] are available so that\n  //    they can easily be used to modify envp inside mtcp_restart.c:main().\n  //    for debugging in GDB.  These appear _after_ final NULL  of newEnv[].\n  char* newEnv[7] = {NULL, NULL, NULL,\n                     const_cast<char *> (\"MTCP_RESTART_PAUSE=1\"),\n                     const_cast<char *> (\"DMTCP_RESTART_PAUSE=1\"),\n                     const_cast<char *> (\"MTCP_RESTART_PAUSE2=1\"),\n                     const_cast<char *> (\"DMTCP_RESTART_PAUSE2=1\")};\n  // Will put ENV_PTR(\"MTCP_OLDPERS\") here.\n  newEnv[dummyEnvironIndex] = (char*) dummyEnviron;\n  newEnv[pathIndex] = (getenv(\"PATH\") ? ENV_PTR(\"PATH\") : NULL);\n\n  size_t newArgsSize = 0;\n  for (int i = 0; newArgs[i] != 0; i++) {\n    newArgsSize += strlen(newArgs[i]) + 1;\n  }\n  size_t newEnvSize = 0;\n  for (int i = 0; newEnv[i] != 0; i++) {\n    newEnvSize += strlen(newEnv[i]) + 1;\n  }\n  size_t originalArgvEnvSize = argvSize + envSize;\n  size_t newArgvEnvSize = newArgsSize + newEnvSize + strlen(newArgs[0]);\n  size_t argvSizeDiff = originalArgvEnvSize - newArgvEnvSize;\n  if (argvSizeDiff > 0) {\n    dummyEnviron = (char*) malloc(argvSizeDiff);\n    memset(dummyEnviron, '0', argvSizeDiff - 1 );\n    strncpy(dummyEnviron,\n            ENV_VAR_DMTCP_DUMMY \"=\",\n            strlen(ENV_VAR_DMTCP_DUMMY \"=\"));\n    dummyEnviron[argvSizeDiff - 1] = '\\0';\n    newEnv[dummyEnvironIndex] = dummyEnviron;\n  }\n\n  JLOG(DMTCP)(\"Args/Env Sizes\")\n    (newArgsSize) (newEnvSize) (argvSize) (envSize) (argvSizeDiff);\n\n  execve (newArgs[0], newArgs, newEnv);\n  JASSERT (false) (newArgs[0]) (newArgs[1]) (JASSERT_ERRNO)\n          .Text (\"exec() failed\");\n}\n\nvoid Util::adjustRlimitStack()\n{\n#ifdef __i386__\n  // This is needed in 32-bit Ubuntu 9.10, to fix bug with test/dmtcp5.c\n  // NOTE:  Setting personality() is cleanest way to force legacy_va_layout,\n  //   but there's currently a bug on restart in the sequence:\n  //   checkpoint -> restart -> checkpoint -> restart\n# if 0\n  { unsigned long oldPersonality = personality(0xffffffffL);\n    if (! (oldPersonality & ADDR_COMPAT_LAYOUT)) {\n      // Force ADDR_COMPAT_LAYOUT for libs in high mem, to avoid vdso conflict\n      personality(oldPersonality & ADDR_COMPAT_LAYOUT);\n      JLOG(DMTCP)(\"setting ADDR_COMPAT_LAYOUT\");\n      setenv(\"DMTCP_ADDR_COMPAT_LAYOUT\", \"temporarily is set\", 1);\n    }\n  }\n# else\n  { struct rlimit rlim;\n    getrlimit(RLIMIT_STACK, &rlim);\n    if (rlim.rlim_cur != RLIM_INFINITY) {\n      char buf[100];\n      sprintf(buf, \"%lu\", rlim.rlim_cur); // \"%llu\" for BSD/Mac OS\n      JLOG(DMTCP)(\"setting rlim_cur for RLIMIT_STACK\") (rlim.rlim_cur);\n      setenv(\"DMTCP_RLIMIT_STACK\", buf, 1);\n      // Force kernel's internal compat_va_layout to 0; Force libs to high mem.\n      rlim.rlim_cur = rlim.rlim_max;\n      // FIXME: if rlim.rlim_cur != RLIM_INFINITY, then we should warn the user.\n      setrlimit(RLIMIT_STACK, &rlim);\n      // After exec, process will restore DMTCP_RLIMIT_STACK in DmtcpWorker()\n    }\n  }\n# endif\n#endif\n}\n\n// TODO(kapil): rewrite getPath to remove dependency on jalib.\nstring Util::getPath(string cmd, bool is32bit)\n{\n  // search relative to base dir of dmtcp installation.\n  const char *p1[] = {\n    \"/bin/\",\n    \"/lib64/dmtcp/\",\n    \"/lib/dmtcp/\",\n  };\n\n  string suffixFor32Bits;\n#if defined(__x86_64__) || defined(__aarch64__)\n  if (is32bit) {  // if this is a multi-architecture build\n    string basename = jalib::Filesystem::BaseName(cmd);\n    if (cmd == \"mtcp_restart-32\") {\n      suffixFor32Bits = \"32/bin/\";\n    } else {\n      suffixFor32Bits = \"32/lib/dmtcp/\";\n    }\n  }\n#endif\n\n  // Search relative to dir of this command (bin/dmtcp_launch), (using p1).\n  string udir = SharedData::getInstallDir();\n  for (size_t i = 0; i < sizeof(p1) / sizeof(char*); i++) {\n    string pth = udir + p1[i] + suffixFor32Bits + cmd;\n    if (jalib::Filesystem::FileExists(pth)) {\n      return pth;\n    }\n  }\n\n  return cmd;\n}\n\nvoid Util::getDmtcpArgs(vector<string> &dmtcp_args)\n{\n  const char * sigckpt              = getenv (ENV_VAR_SIGCKPT);\n  const char * compression          = getenv (ENV_VAR_COMPRESSION);\n  const char * allocPlugin          = getenv (ENV_VAR_ALLOC_PLUGIN);\n  const char * dlPlugin             = getenv (ENV_VAR_DL_PLUGIN);\n#ifdef HBICT_DELTACOMP\n  const char * deltacompression     = getenv (ENV_VAR_DELTACOMPRESSION);\n#endif\n  const char * ckptOpenFiles        = getenv (ENV_VAR_CKPT_OPEN_FILES);\n  const char * ckptDir              = getenv (ENV_VAR_CHECKPOINT_DIR);\n  const char * tmpDir               = getenv (ENV_VAR_TMPDIR);\n  const char * plugins              = getenv (ENV_VAR_PLUGIN);\n  const char * plugins_32           = getenv (ENV_VAR_PLUGIN_32);\n\n  //modify the command\n  dmtcp_args.clear();\n  dmtcp_args.push_back(\"--coord-host\");\n  dmtcp_args.push_back(SharedData::coordHost());\n  dmtcp_args.push_back(\"--coord-port\");\n  dmtcp_args.push_back(jalib::XToString(SharedData::coordPort()));\n\n  if (jassert_quiet == 1) {\n    dmtcp_args.push_back(\"-q\");\n  } else if (jassert_quiet == 2) {\n    dmtcp_args.push_back(\"-q -q\");\n  }\n\n  if (sigckpt != NULL) {\n    dmtcp_args.push_back(\"--ckpt-signal\");\n    dmtcp_args.push_back(sigckpt);\n  }\n\n  if (ckptDir != NULL) {\n    dmtcp_args.push_back(\"--ckptdir\");\n    dmtcp_args.push_back(ckptDir);\n  }\n\n  if (tmpDir != NULL) {\n    dmtcp_args.push_back(\"--tmpdir\");\n    dmtcp_args.push_back(tmpDir);\n  }\n\n  if (ckptOpenFiles != NULL) {\n    dmtcp_args.push_back(\"--checkpoint-open-files\");\n  }\n\n  if (plugins != NULL) {\n    dmtcp_args.push_back(\"--with-plugin\");\n    dmtcp_args.push_back(plugins);\n  }\n\n  if (plugins_32 != NULL) {\n    dmtcp_args.push_back(\"--with-plugin-32\");\n    dmtcp_args.push_back(plugins_32);\n  }\n\n  if (compression != NULL) {\n    if (strcmp (compression, \"1\") == 0)\n      dmtcp_args.push_back(\"--no-gzip\");\n    else\n      dmtcp_args.push_back(\"--gzip\");\n  }\n\n  if (allocPlugin != NULL && strcmp(allocPlugin, \"0\") == 0) {\n    dmtcp_args.push_back(\"--disable-alloc-plugin\");\n  }\n\n  if (dlPlugin != NULL && strcmp(dlPlugin, \"0\") == 0) {\n    dmtcp_args.push_back(\"--disable-dl-plugin\");\n  }\n\n  if (dmtcp_ptrace_enabled != NULL && dmtcp_ptrace_enabled()) {\n    dmtcp_args.push_back(\"--ptrace\");\n  }\n\n  if (dmtcp_modify_env_enabled != NULL && dmtcp_modify_env_enabled()) {\n    dmtcp_args.push_back(\"--modify-env\");\n  }\n\n  if (dmtcp_infiniband_enabled != NULL && dmtcp_infiniband_enabled()) {\n    dmtcp_args.push_back(\"--infiniband\");\n  }\n\n  if (dmtcp_batch_queue_enabled != NULL && dmtcp_batch_queue_enabled()) {\n    dmtcp_args.push_back(\"--batch-queue\");\n  }\n\n  if (dmtcp_pathvirt_enabled != NULL && dmtcp_pathvirt_enabled()) {\n    dmtcp_args.push_back(\"--pathvirt\");\n  }\n\n#ifdef HBICT_DELTACOMP\n  if (deltacompression != NULL) {\n    if (strcmp(deltacompression, \"0\") == 0)\n      dmtcp_args.push_back(\"--no-hbict\");\n    else\n      dmtcp_args.push_back(\"--hbict\");\n  }\n#endif\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/src/Makefile.in": "# Makefile.in generated by automake 1.13.4 from Makefile.am.\n# @configure_input@\n\n# Copyright (C) 1994-2013 Free Software Foundation, Inc.\n\n# This Makefile.in is free software; the Free Software Foundation\n# gives unlimited permission to copy and/or distribute it,\n# with or without modifications, as long as this notice is preserved.\n\n# This program is distributed in the hope that it will be useful,\n# but WITHOUT ANY WARRANTY, to the extent permitted by law; without\n# even the implied warranty of MERCHANTABILITY or FITNESS FOR A\n# PARTICULAR PURPOSE.\n\n@SET_MAKE@\n\n# We should disable AM_MAINTAINER_MODE since otherwise a re-build by the\n#  end-user may require local tools, which may be missing or whose version is\n#  incompatible with these tools (e.g. autoheader).  Instead, we run NMI and\n#  openSUSE build services to test compatibility with end-user machines.\n#  The developers should run autoconf, automake, etc., as needed, but\n#  not propagate to the svn-generated tools that may be incompatible\n#  with the user's local tools.  - Gene\n# See http://www.gnu.org/s/hello/manual/automake/CVS.html#CVS\n# AM_MAINTAINER_MDE([disable])\n\n\n\nVPATH = @srcdir@\nam__is_gnu_make = test -n '$(MAKEFILE_LIST)' && test -n '$(MAKELEVEL)'\nam__make_running_with_option = \\\n  case $${target_option-} in \\\n      ?) ;; \\\n      *) echo \"am__make_running_with_option: internal error: invalid\" \\\n              \"target option '$${target_option-}' specified\" >&2; \\\n         exit 1;; \\\n  esac; \\\n  has_opt=no; \\\n  sane_makeflags=$$MAKEFLAGS; \\\n  if $(am__is_gnu_make); then \\\n    sane_makeflags=$$MFLAGS; \\\n  else \\\n    case $$MAKEFLAGS in \\\n      *\\\\[\\ \\\t]*) \\\n        bs=\\\\; \\\n        sane_makeflags=`printf '%s\\n' \"$$MAKEFLAGS\" \\\n          | sed \"s/$$bs$$bs[$$bs $$bs\t]*//g\"`;; \\\n    esac; \\\n  fi; \\\n  skip_next=no; \\\n  strip_trailopt () \\\n  { \\\n    flg=`printf '%s\\n' \"$$flg\" | sed \"s/$$1.*$$//\"`; \\\n  }; \\\n  for flg in $$sane_makeflags; do \\\n    test $$skip_next = yes && { skip_next=no; continue; }; \\\n    case $$flg in \\\n      *=*|--*) continue;; \\\n        -*I) strip_trailopt 'I'; skip_next=yes;; \\\n      -*I?*) strip_trailopt 'I';; \\\n        -*O) strip_trailopt 'O'; skip_next=yes;; \\\n      -*O?*) strip_trailopt 'O';; \\\n        -*l) strip_trailopt 'l'; skip_next=yes;; \\\n      -*l?*) strip_trailopt 'l';; \\\n      -[dEDm]) skip_next=yes;; \\\n      -[JT]) skip_next=yes;; \\\n    esac; \\\n    case $$flg in \\\n      *$$target_option*) has_opt=yes; break;; \\\n    esac; \\\n  done; \\\n  test $$has_opt = yes\nam__make_dryrun = (target_option=n; $(am__make_running_with_option))\nam__make_keepgoing = (target_option=k; $(am__make_running_with_option))\npkgdatadir = $(datadir)/@PACKAGE@\npkgincludedir = $(includedir)/@PACKAGE@\npkglibdir = $(libdir)/@PACKAGE@\npkglibexecdir = $(libexecdir)/@PACKAGE@\nam__cd = CDPATH=\"$${ZSH_VERSION+.}$(PATH_SEPARATOR)\" && cd\ninstall_sh_DATA = $(install_sh) -c -m 644\ninstall_sh_PROGRAM = $(install_sh) -c\ninstall_sh_SCRIPT = $(install_sh) -c\nINSTALL_HEADER = $(INSTALL_DATA)\ntransform = $(program_transform_name)\nNORMAL_INSTALL = :\nPRE_INSTALL = :\nPOST_INSTALL = :\nNORMAL_UNINSTALL = :\nPRE_UNINSTALL = :\nPOST_UNINSTALL = :\nbuild_triplet = @build@\nhost_triplet = @host@\n@FAST_RST_VIA_MMAP_TRUE@am__append_1 = -DFAST_RST_VIA_MMAP\nbin_PROGRAMS = $(d_bindir)/dmtcp_launch$(EXEEXT) \\\n\t$(d_bindir)/dmtcp_command$(EXEEXT) \\\n\t$(d_bindir)/dmtcp_coordinator$(EXEEXT) \\\n\t$(d_bindir)/dmtcp_restart$(EXEEXT) \\\n\t$(d_bindir)/dmtcp_nocheckpoint$(EXEEXT)\ndmtcplib_PROGRAMS = $(d_libdir)/libdmtcp.so$(EXEEXT)\nsubdir = src\nDIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/Makefile.am \\\n\t$(top_srcdir)/depcomp $(include_HEADERS) \\\n\t$(nobase_noinst_HEADERS)\nACLOCAL_M4 = $(top_srcdir)/aclocal.m4\nam__aclocal_m4_deps = $(top_srcdir)/configure.ac\nam__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \\\n\t$(ACLOCAL_M4)\nmkinstalldirs = $(install_sh) -d\nCONFIG_HEADER = $(top_builddir)/include/config.h\nCONFIG_CLEAN_FILES =\nCONFIG_CLEAN_VPATH_FILES =\nLIBRARIES = $(noinst_LIBRARIES)\nAR = ar\nAM_V_AR = $(am__v_AR_@AM_V@)\nam__v_AR_ = $(am__v_AR_@AM_DEFAULT_V@)\nam__v_AR_0 = @echo \"  AR      \" $@;\nam__v_AR_1 = \nlibdmtcpinternal_a_AR = $(AR) $(ARFLAGS)\nlibdmtcpinternal_a_LIBADD =\nam_libdmtcpinternal_a_OBJECTS = dmtcpmessagetypes.$(OBJEXT) \\\n\tcoordinatorapi.$(OBJEXT) workerstate.$(OBJEXT) \\\n\tdmtcp_dlsym.$(OBJEXT) uniquepid.$(OBJEXT) shareddata.$(OBJEXT) \\\n\tutil_exec.$(OBJEXT) util_misc.$(OBJEXT) util_init.$(OBJEXT) \\\n\tjalibinterface.$(OBJEXT) processinfo.$(OBJEXT) \\\n\tprocselfmaps.$(OBJEXT)\nlibdmtcpinternal_a_OBJECTS = $(am_libdmtcpinternal_a_OBJECTS)\nlibjalib_a_AR = $(AR) $(ARFLAGS)\nlibjalib_a_LIBADD =\nam_libjalib_a_OBJECTS = jalib.$(OBJEXT) jassert.$(OBJEXT) \\\n\tjbuffer.$(OBJEXT) jfilesystem.$(OBJEXT) jserialize.$(OBJEXT) \\\n\tjsocket.$(OBJEXT) jtimer.$(OBJEXT) jalloc.$(OBJEXT)\nlibjalib_a_OBJECTS = $(am_libjalib_a_OBJECTS)\nlibnohijack_a_AR = $(AR) $(ARFLAGS)\nlibnohijack_a_LIBADD =\nam_libnohijack_a_OBJECTS = nosyscallsreal.$(OBJEXT) \\\n\tdmtcpnohijackstubs.$(OBJEXT)\nlibnohijack_a_OBJECTS = $(am_libnohijack_a_OBJECTS)\nlibsyscallsreal_a_AR = $(AR) $(ARFLAGS)\nlibsyscallsreal_a_LIBADD =\nam_libsyscallsreal_a_OBJECTS = syscallsreal.$(OBJEXT) \\\n\ttrampolines.$(OBJEXT)\nlibsyscallsreal_a_OBJECTS = $(am_libsyscallsreal_a_OBJECTS)\nam__installdirs = \"$(DESTDIR)$(bindir)\" \"$(DESTDIR)$(dmtcplibdir)\" \\\n\t\"$(DESTDIR)$(includedir)\"\nPROGRAMS = $(bin_PROGRAMS) $(dmtcplib_PROGRAMS)\nam___d_bindir__dmtcp_command_OBJECTS = dmtcp_command.$(OBJEXT)\n__d_bindir__dmtcp_command_OBJECTS =  \\\n\t$(am___d_bindir__dmtcp_command_OBJECTS)\n__d_bindir__dmtcp_command_DEPENDENCIES = libdmtcpinternal.a libjalib.a \\\n\tlibnohijack.a\nam__dirstamp = $(am__leading_dot)dirstamp\nam___d_bindir__dmtcp_coordinator_OBJECTS =  \\\n\tdmtcp_coordinator.$(OBJEXT) lookup_service.$(OBJEXT) \\\n\trestartscript.$(OBJEXT)\n__d_bindir__dmtcp_coordinator_OBJECTS =  \\\n\t$(am___d_bindir__dmtcp_coordinator_OBJECTS)\n__d_bindir__dmtcp_coordinator_DEPENDENCIES = libdmtcpinternal.a \\\n\tlibjalib.a libnohijack.a\nam___d_bindir__dmtcp_launch_OBJECTS = dmtcp_launch.$(OBJEXT)\n__d_bindir__dmtcp_launch_OBJECTS =  \\\n\t$(am___d_bindir__dmtcp_launch_OBJECTS)\n__d_bindir__dmtcp_launch_DEPENDENCIES = libdmtcpinternal.a libjalib.a \\\n\tlibnohijack.a\nam___d_bindir__dmtcp_nocheckpoint_OBJECTS =  \\\n\tdmtcp_nocheckpoint.$(OBJEXT)\n__d_bindir__dmtcp_nocheckpoint_OBJECTS =  \\\n\t$(am___d_bindir__dmtcp_nocheckpoint_OBJECTS)\n__d_bindir__dmtcp_nocheckpoint_LDADD = $(LDADD)\nam___d_bindir__dmtcp_restart_OBJECTS = dmtcp_restart.$(OBJEXT) \\\n\tutil_exec.$(OBJEXT)\n__d_bindir__dmtcp_restart_OBJECTS =  \\\n\t$(am___d_bindir__dmtcp_restart_OBJECTS)\n__d_bindir__dmtcp_restart_DEPENDENCIES = libdmtcpinternal.a libjalib.a \\\n\tlibnohijack.a\nam___d_libdir__libdmtcp_so_OBJECTS = dmtcpworker.$(OBJEXT) \\\n\tthreadsync.$(OBJEXT) coordinatorapi.$(OBJEXT) \\\n\texecwrappers.$(OBJEXT) mtcpinterface.$(OBJEXT) \\\n\tsignalwrappers.$(OBJEXT) terminal.$(OBJEXT) alarm.$(OBJEXT) \\\n\tthreadwrappers.$(OBJEXT) miscwrappers.$(OBJEXT) \\\n\tckptserializer.$(OBJEXT) writeckpt.$(OBJEXT) \\\n\tglibcsystem.$(OBJEXT) threadlist.$(OBJEXT) siginfo.$(OBJEXT) \\\n\tdmtcpplugin.$(OBJEXT) popen.$(OBJEXT) syslogwrappers.$(OBJEXT) \\\n\tdmtcp_dlsym.$(OBJEXT)\n__d_libdir__libdmtcp_so_OBJECTS =  \\\n\t$(am___d_libdir__libdmtcp_so_OBJECTS)\n__d_libdir__libdmtcp_so_DEPENDENCIES = libdmtcpinternal.a libjalib.a \\\n\tlibsyscallsreal.a mtcp/libmtcp.a\n__d_libdir__libdmtcp_so_LINK = $(CXXLD) $(AM_CXXFLAGS) $(CXXFLAGS) \\\n\t$(__d_libdir__libdmtcp_so_LDFLAGS) $(LDFLAGS) -o $@\nAM_V_P = $(am__v_P_@AM_V@)\nam__v_P_ = $(am__v_P_@AM_DEFAULT_V@)\nam__v_P_0 = false\nam__v_P_1 = :\nAM_V_GEN = $(am__v_GEN_@AM_V@)\nam__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)\nam__v_GEN_0 = @echo \"  GEN     \" $@;\nam__v_GEN_1 = \nAM_V_at = $(am__v_at_@AM_V@)\nam__v_at_ = $(am__v_at_@AM_DEFAULT_V@)\nam__v_at_0 = @\nam__v_at_1 = \nDEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)/include\ndepcomp = $(SHELL) $(top_srcdir)/depcomp\nam__depfiles_maybe = depfiles\nam__mv = mv -f\nCOMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \\\n\t$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\nAM_V_CC = $(am__v_CC_@AM_V@)\nam__v_CC_ = $(am__v_CC_@AM_DEFAULT_V@)\nam__v_CC_0 = @echo \"  CC      \" $@;\nam__v_CC_1 = \nCCLD = $(CC)\nLINK = $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) $(LDFLAGS) -o $@\nAM_V_CCLD = $(am__v_CCLD_@AM_V@)\nam__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)\nam__v_CCLD_0 = @echo \"  CCLD    \" $@;\nam__v_CCLD_1 = \nAM_V_lt = $(am__v_lt_@AM_V@)\nam__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)\nam__v_lt_0 = --silent\nam__v_lt_1 = \nCXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)\nAM_V_CXX = $(am__v_CXX_@AM_V@)\nam__v_CXX_ = $(am__v_CXX_@AM_DEFAULT_V@)\nam__v_CXX_0 = @echo \"  CXX     \" $@;\nam__v_CXX_1 = \nCXXLD = $(CXX)\nCXXLINK = $(CXXLD) $(AM_CXXFLAGS) $(CXXFLAGS) $(AM_LDFLAGS) $(LDFLAGS) \\\n\t-o $@\nAM_V_CXXLD = $(am__v_CXXLD_@AM_V@)\nam__v_CXXLD_ = $(am__v_CXXLD_@AM_DEFAULT_V@)\nam__v_CXXLD_0 = @echo \"  CXXLD   \" $@;\nam__v_CXXLD_1 = \nSOURCES = $(libdmtcpinternal_a_SOURCES) $(libjalib_a_SOURCES) \\\n\t$(libnohijack_a_SOURCES) $(libsyscallsreal_a_SOURCES) \\\n\t$(__d_bindir__dmtcp_command_SOURCES) \\\n\t$(__d_bindir__dmtcp_coordinator_SOURCES) \\\n\t$(__d_bindir__dmtcp_launch_SOURCES) \\\n\t$(__d_bindir__dmtcp_nocheckpoint_SOURCES) \\\n\t$(__d_bindir__dmtcp_restart_SOURCES) \\\n\t$(__d_libdir__libdmtcp_so_SOURCES)\nDIST_SOURCES = $(libdmtcpinternal_a_SOURCES) $(libjalib_a_SOURCES) \\\n\t$(libnohijack_a_SOURCES) $(libsyscallsreal_a_SOURCES) \\\n\t$(__d_bindir__dmtcp_command_SOURCES) \\\n\t$(__d_bindir__dmtcp_coordinator_SOURCES) \\\n\t$(__d_bindir__dmtcp_launch_SOURCES) \\\n\t$(__d_bindir__dmtcp_nocheckpoint_SOURCES) \\\n\t$(__d_bindir__dmtcp_restart_SOURCES) \\\n\t$(__d_libdir__libdmtcp_so_SOURCES)\nRECURSIVE_TARGETS = all-recursive check-recursive cscopelist-recursive \\\n\tctags-recursive dvi-recursive html-recursive info-recursive \\\n\tinstall-data-recursive install-dvi-recursive \\\n\tinstall-exec-recursive install-html-recursive \\\n\tinstall-info-recursive install-pdf-recursive \\\n\tinstall-ps-recursive install-recursive installcheck-recursive \\\n\tinstalldirs-recursive pdf-recursive ps-recursive \\\n\ttags-recursive uninstall-recursive\nam__can_run_installinfo = \\\n  case $$AM_UPDATE_INFO_DIR in \\\n    n|no|NO) false;; \\\n    *) (install-info --version) >/dev/null 2>&1;; \\\n  esac\nam__vpath_adj_setup = srcdirstrip=`echo \"$(srcdir)\" | sed 's|.|.|g'`;\nam__vpath_adj = case $$p in \\\n    $(srcdir)/*) f=`echo \"$$p\" | sed \"s|^$$srcdirstrip/||\"`;; \\\n    *) f=$$p;; \\\n  esac;\nam__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;\nam__install_max = 40\nam__nobase_strip_setup = \\\n  srcdirstrip=`echo \"$(srcdir)\" | sed 's/[].[^$$\\\\*|]/\\\\\\\\&/g'`\nam__nobase_strip = \\\n  for p in $$list; do echo \"$$p\"; done | sed -e \"s|$$srcdirstrip/||\"\nam__nobase_list = $(am__nobase_strip_setup); \\\n  for p in $$list; do echo \"$$p $$p\"; done | \\\n  sed \"s| $$srcdirstrip/| |;\"' / .*\\//!s/ .*/ ./; s,\\( .*\\)/[^/]*$$,\\1,' | \\\n  $(AWK) 'BEGIN { files[\".\"] = \"\" } { files[$$2] = files[$$2] \" \" $$1; \\\n    if (++n[$$2] == $(am__install_max)) \\\n      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = \"\" } } \\\n    END { for (dir in files) print dir, files[dir] }'\nam__base_list = \\\n  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\\n/ /g' | \\\n  sed '$$!N;$$!N;$$!N;$$!N;s/\\n/ /g'\nam__uninstall_files_from_dir = { \\\n  test -z \"$$files\" \\\n    || { test ! -d \"$$dir\" && test ! -f \"$$dir\" && test ! -r \"$$dir\"; } \\\n    || { echo \" ( cd '$$dir' && rm -f\" $$files \")\"; \\\n         $(am__cd) \"$$dir\" && rm -f $$files; }; \\\n  }\nHEADERS = $(include_HEADERS) $(nobase_noinst_HEADERS)\nRECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive\t\\\n  distclean-recursive maintainer-clean-recursive\nam__recursive_targets = \\\n  $(RECURSIVE_TARGETS) \\\n  $(RECURSIVE_CLEAN_TARGETS) \\\n  $(am__extra_recursive_targets)\nAM_RECURSIVE_TARGETS = $(am__recursive_targets:-recursive=) TAGS CTAGS \\\n\tdistdir\nam__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP)\n# Read a list of newline-separated strings from the standard input,\n# and print each of them once, without duplicates.  Input order is\n# *not* preserved.\nam__uniquify_input = $(AWK) '\\\n  BEGIN { nonempty = 0; } \\\n  { items[$$0] = 1; nonempty = 1; } \\\n  END { if (nonempty) { for (i in items) print i; }; } \\\n'\n# Make sure the list of sources is unique.  This is necessary because,\n# e.g., the same source file might be shared among _SOURCES variables\n# for different programs/libraries.\nam__define_uniq_tagged_files = \\\n  list='$(am__tagged_files)'; \\\n  unique=`for i in $$list; do \\\n    if test -f \"$$i\"; then echo $$i; else echo $(srcdir)/$$i; fi; \\\n  done | $(am__uniquify_input)`\nETAGS = etags\nCTAGS = ctags\nDIST_SUBDIRS = $(SUBDIRS)\nDISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)\nam__relativize = \\\n  dir0=`pwd`; \\\n  sed_first='s,^\\([^/]*\\)/.*$$,\\1,'; \\\n  sed_rest='s,^[^/]*/*,,'; \\\n  sed_last='s,^.*/\\([^/]*\\)$$,\\1,'; \\\n  sed_butlast='s,/*[^/]*$$,,'; \\\n  while test -n \"$$dir1\"; do \\\n    first=`echo \"$$dir1\" | sed -e \"$$sed_first\"`; \\\n    if test \"$$first\" != \".\"; then \\\n      if test \"$$first\" = \"..\"; then \\\n        dir2=`echo \"$$dir0\" | sed -e \"$$sed_last\"`/\"$$dir2\"; \\\n        dir0=`echo \"$$dir0\" | sed -e \"$$sed_butlast\"`; \\\n      else \\\n        first2=`echo \"$$dir2\" | sed -e \"$$sed_first\"`; \\\n        if test \"$$first2\" = \"$$first\"; then \\\n          dir2=`echo \"$$dir2\" | sed -e \"$$sed_rest\"`; \\\n        else \\\n          dir2=\"../$$dir2\"; \\\n        fi; \\\n        dir0=\"$$dir0\"/\"$$first\"; \\\n      fi; \\\n    fi; \\\n    dir1=`echo \"$$dir1\" | sed -e \"$$sed_rest\"`; \\\n  done; \\\n  reldir=\"$$dir2\"\nAARCH64_HOST = @AARCH64_HOST@\nACLOCAL = @ACLOCAL@\nAMTAR = @AMTAR@\nAM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@\nARFLAGS = @ARFLAGS@\nARM_HOST = @ARM_HOST@\nAUTOCONF = @AUTOCONF@\nAUTOHEADER = @AUTOHEADER@\nAUTOMAKE = @AUTOMAKE@\nAWK = @AWK@\nCC = @CC@\nCCDEPMODE = @CCDEPMODE@\nCFLAGS = @CFLAGS@\nCILKC = @CILKC@\nCPP = @CPP@\nCPPFLAGS = @CPPFLAGS@\nCXX = @CXX@\nCXXDEPMODE = @CXXDEPMODE@\nCXXFLAGS = @CXXFLAGS@\nCYGPATH_W = @CYGPATH_W@\nDEBUG = @DEBUG@\nDEFS = @DEFS@\nDEPDIR = @DEPDIR@\nECHO_C = @ECHO_C@\nECHO_N = @ECHO_N@\nECHO_T = @ECHO_T@\nEGREP = @EGREP@\nEXEEXT = @EXEEXT@\nFAST_RST_VIA_MMAP = @FAST_RST_VIA_MMAP@\nGCL = @GCL@\nGREP = @GREP@\nHAS_CILK = @HAS_CILK@\nHAS_CMA = @HAS_CMA@\nHAS_DASH = @HAS_DASH@\nHAS_EMACS = @HAS_EMACS@\nHAS_EMACS_NOX = @HAS_EMACS_NOX@\nHAS_EPOLL_CREATE1 = @HAS_EPOLL_CREATE1@\nHAS_GCL = @HAS_GCL@\nHAS_GDB = @HAS_GDB@\nHAS_GZIP = @HAS_GZIP@\nHAS_JAVA = @HAS_JAVA@\nHAS_JAVAC = @HAS_JAVAC@\nHAS_MATLAB = @HAS_MATLAB@\nHAS_MPICH = @HAS_MPICH@\nHAS_MUTEX_WRAPPERS = @HAS_MUTEX_WRAPPERS@\nHAS_OPENMPI = @HAS_OPENMPI@\nHAS_PS = @HAS_PS@\nHAS_PYTHON = @HAS_PYTHON@\nHAS_READLINE = @HAS_READLINE@\nHAS_SCREEN = @HAS_SCREEN@\nHAS_SCRIPT = @HAS_SCRIPT@\nHAS_SSH_LOCALHOST = @HAS_SSH_LOCALHOST@\nHAS_STRACE = @HAS_STRACE@\nHAS_TCSH = @HAS_TCSH@\nHAS_VIM = @HAS_VIM@\nHAS_ZSH = @HAS_ZSH@\nHBICT_DELTACOMP = @HBICT_DELTACOMP@\nINFINIBAND_SUPPORT = @INFINIBAND_SUPPORT@\nINSTALL = @INSTALL@\nINSTALL_DATA = @INSTALL_DATA@\nINSTALL_PROGRAM = @INSTALL_PROGRAM@\nINSTALL_SCRIPT = @INSTALL_SCRIPT@\nINSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@\nLDFLAGS = @LDFLAGS@\nLIBOBJS = @LIBOBJS@\nLIBS = @LIBS@\nLN_S = @LN_S@\nLOGGING = @LOGGING@\nLTLIBOBJS = @LTLIBOBJS@\nM32 = @M32@\nMAINT = @MAINT@\nMAKEINFO = @MAKEINFO@\nMATLAB = @MATLAB@\nMKDIR_P = @MKDIR_P@\nMPICH_MPD = @MPICH_MPD@\nMPICH_MPDALLEXIT = @MPICH_MPDALLEXIT@\nMPICH_MPDBOOT = @MPICH_MPDBOOT@\nMPICH_MPDCLEANUP = @MPICH_MPDCLEANUP@\nMPICH_MPICC = @MPICH_MPICC@\nMPICH_MPIEXEC = @MPICH_MPIEXEC@\nOBJEXT = @OBJEXT@\nOPENMPI_MPICC = @OPENMPI_MPICC@\nOPENMPI_MPIRUN = @OPENMPI_MPIRUN@\nOPENMP_CFLAGS = @OPENMP_CFLAGS@\nOPENMP_CXXFLAGS = @OPENMP_CXXFLAGS@\nPACKAGE = @PACKAGE@\nPACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@\nPACKAGE_NAME = @PACKAGE_NAME@\nPACKAGE_STRING = @PACKAGE_STRING@\nPACKAGE_TARNAME = @PACKAGE_TARNAME@\nPACKAGE_URL = @PACKAGE_URL@\nPACKAGE_VERSION = @PACKAGE_VERSION@\nPATH_SEPARATOR = @PATH_SEPARATOR@\nRANLIB = @RANLIB@\nSCREEN = @SCREEN@\nSET_MAKE = @SET_MAKE@\nSHELL = @SHELL@\nSTRIP = @STRIP@\nTEST_POSIX_MQ = @TEST_POSIX_MQ@\nUSE_TEST_SUITE = @USE_TEST_SUITE@\nVERSION = @VERSION@\nVIM = @VIM@\nabs_builddir = @abs_builddir@\nabs_srcdir = @abs_srcdir@\nabs_top_builddir = @abs_top_builddir@\nabs_top_srcdir = @abs_top_srcdir@\nac_ct_CC = @ac_ct_CC@\nac_ct_CXX = @ac_ct_CXX@\nam__include = @am__include@\nam__leading_dot = @am__leading_dot@\nam__quote = @am__quote@\nam__tar = @am__tar@\nam__untar = @am__untar@\nbindir = @bindir@\nbuild = @build@\nbuild_alias = @build_alias@\nbuild_cpu = @build_cpu@\nbuild_os = @build_os@\nbuild_vendor = @build_vendor@\nbuilddir = @builddir@\ndatadir = @datadir@\ndatarootdir = @datarootdir@\ndocdir = @docdir@\ndvidir = @dvidir@\nexec_prefix = @exec_prefix@\nhost = @host@\nhost_alias = @host_alias@\nhost_cpu = @host_cpu@\nhost_os = @host_os@\nhost_vendor = @host_vendor@\nhtmldir = @htmldir@\nincludedir = @includedir@\ninfodir = @infodir@\ninstall_sh = @install_sh@\nlibdir = @libdir@\nlibexecdir = @libexecdir@\nlocaledir = @localedir@\nlocalstatedir = @localstatedir@\nmandir = @mandir@\nmkdir_p = @mkdir_p@\noldincludedir = @oldincludedir@\npdfdir = @pdfdir@\nprefix = @prefix@\nprogram_transform_name = @program_transform_name@\npsdir = @psdir@\nsbindir = @sbindir@\nsharedstatedir = @sharedstatedir@\nsrcdir = @srcdir@\nsysconfdir = @sysconfdir@\ntarget_alias = @target_alias@\ntop_build_prefix = @top_build_prefix@\ntop_builddir = @top_builddir@\ntop_srcdir = @top_srcdir@\n\n# not a GNU package. You can remove this line, if\n# have all needed files, that a GNU package needs\n# TODO(kapil): Add 'subdir-objects after automake 1.16 has been released.\nAUTOMAKE_OPTIONS = foreign\njalibdir = $(top_srcdir)/jalib\ndmtcpincludedir = $(top_srcdir)/include\ndmtcplibdir = $(pkglibdir)\nSUBDIRS = mtcp plugin\nPICFLAGS = -fPIC\nAM_CFLAGS = $(PICFLAGS)\nAM_CXXFLAGS = $(PICFLAGS) $(am__append_1)\nAM_LDFLAGS = $(PICFLAGS)\n@CONFIG_M32_FALSE@d_libdir = $(top_builddir)/lib/$(PACKAGE)\n@CONFIG_M32_TRUE@d_libdir = $(top_builddir)/lib/$(PACKAGE)/32/lib/$(PACKAGE)\n@CONFIG_M32_FALSE@d_bindir = $(top_builddir)/bin\n@CONFIG_M32_TRUE@d_bindir = $(top_builddir)/lib/$(PACKAGE)/32/bin\n\n#HEADERS\n#set the include path found by configure\nAM_CPPFLAGS = -I$(dmtcpincludedir) -I$(jalibdir)\n\n# targets:\nnoinst_LIBRARIES = libdmtcpinternal.a\t\t\t\t\\\n\t\t   libsyscallsreal.a\t\t\t\t\\\n\t\t   libnohijack.a\t\t\t\t\\\n\t\t   libjalib.a\n\ninclude_HEADERS = $(srcdir)/../include/dmtcp.h\n\n# headers:\nnobase_noinst_HEADERS = constants.h \\\n\t$(jalibdir)/jassert.h $(jalibdir)/jalloc.h $(jalibdir)/jalib.h \\\n\t$(jalibdir)/jbuffer.h $(jalibdir)/jconvert.h $(jalibdir)/jfilesystem.h \\\n\t$(jalibdir)/jserialize.h $(jalibdir)/jsocket.h $(jalibdir)/jtimer.h \\\n\t$(dmtcpincludedir)/dmtcpalloc.h $(dmtcpincludedir)/dmtcp.h \\\n\t$(dmtcpincludedir)/dmtcpplugin.h \\\n\t$(dmtcpincludedir)/protectedfds.h $(dmtcpincludedir)/shareddata.h \\\n\t$(dmtcpincludedir)/trampolines.h $(dmtcpincludedir)/util.h \\\n\t$(dmtcpincludedir)/virtualidtable.h $(dmtcpincludedir)/procmapsarea.h \\\n\t$(dmtcpincludedir)/procselfmaps.h \\\n\trestartscript.h \\\n\tdmtcp_coordinator.h dmtcpmessagetypes.h workerstate.h lookup_service.h \\\n\tdmtcpworker.h threadsync.h coordinatorapi.h \\\n\tmtcpinterface.h syscallwrappers.h \\\n\tthreadlist.h threadinfo.h siginfo.h \\\n\tuniquepid.h processinfo.h ckptserializer.h \\\n\tmtcp/ldt.h mtcp/restore_libc.h mtcp/tlsutil.h\n\n\n# Note that libdmtcpinternal.a does not include wrappers.\n# dmtcp_launch, dmtcp_command, dmtcp_coordinator, etc.\n#   should not need wrappers.\nlibdmtcpinternal_a_SOURCES = dmtcpmessagetypes.cpp  coordinatorapi.cpp \\\n\t\t\t     workerstate.cpp \\\n\t\t\t     dmtcp_dlsym.cpp \\\n\t\t\t     uniquepid.cpp shareddata.cpp \\\n\t\t\t     util_exec.cpp util_misc.cpp util_init.cpp \\\n\t\t\t     jalibinterface.cpp processinfo.cpp procselfmaps.cpp\n\nlibjalib_a_SOURCES = $(jalibdir)/jalib.cpp $(jalibdir)/jassert.cpp \\\n\t\t     $(jalibdir)/jbuffer.cpp $(jalibdir)/jfilesystem.cpp \\\n\t\t     $(jalibdir)/jserialize.cpp $(jalibdir)/jsocket.cpp \\\n\t\t     $(jalibdir)/jtimer.cpp $(jalibdir)/jalloc.cpp\n\n\n# FIXME:  Rename libsyscallsreal.a to libhijack.a\n# An executable should use either libsyscallsreal.a or libnohijack.a -- not both\nlibsyscallsreal_a_SOURCES = syscallsreal.c trampolines.cpp\nlibnohijack_a_SOURCES = nosyscallsreal.c dmtcpnohijackstubs.cpp\n__d_bindir__dmtcp_coordinator_SOURCES = dmtcp_coordinator.cpp lookup_service.cpp restartscript.cpp\n__d_bindir__dmtcp_nocheckpoint_SOURCES = dmtcp_nocheckpoint.c\n__d_bindir__dmtcp_restart_SOURCES = dmtcp_restart.cpp util_exec.cpp\n__d_bindir__dmtcp_command_SOURCES = dmtcp_command.cpp\n__d_libdir__libdmtcp_so_SOURCES = dmtcpworker.cpp threadsync.cpp \\\n\t\t      coordinatorapi.cpp execwrappers.cpp \\\n\t\t      mtcpinterface.cpp signalwrappers.cpp \\\n\t\t      terminal.cpp \\\n\t\t      alarm.cpp \\\n\t\t      threadwrappers.cpp \\\n\t\t      miscwrappers.cpp ckptserializer.cpp writeckpt.cpp \\\n\t\t      glibcsystem.cpp \\\n\t\t      threadlist.cpp siginfo.cpp \\\n\t\t      dmtcpplugin.cpp popen.cpp syslogwrappers.cpp \\\n\t\t      dmtcp_dlsym.cpp\n\n__d_libdir__libdmtcp_so_LDFLAGS = -shared -Xlinker -znow\n\n# Note that an ELF object uses libsyscallsreal.a or libnohijack.a\n#  but not both.  libnohijack.a has stub definitions for same symbols.\n__d_libdir__libdmtcp_so_LDADD = libdmtcpinternal.a libjalib.a \\\n\t\t\t\tlibsyscallsreal.a mtcp/libmtcp.a \\\n\t\t\t\t-ldl -lpthread -lrt\n\n__d_bindir__dmtcp_coordinator_LDADD = libdmtcpinternal.a libjalib.a \\\n\t\t\t  libnohijack.a -lpthread -lrt\n\n__d_bindir__dmtcp_launch_LDADD = libdmtcpinternal.a libjalib.a \\\n\t\t\t  libnohijack.a -lpthread -lrt -ldl\n\n__d_bindir__dmtcp_restart_LDADD = libdmtcpinternal.a libjalib.a \\\n\t\t\t  libnohijack.a -lpthread -lrt -ldl\n\n__d_bindir__dmtcp_command_LDADD = libdmtcpinternal.a libjalib.a \\\n\t\t\t  libnohijack.a -lpthread -lrt -ldl\n\n__d_bindir__dmtcp_launch_SOURCES = dmtcp_launch.cpp\nall: all-recursive\n\n.SUFFIXES:\n.SUFFIXES: .c .cpp .o .obj\n$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)\n\t@for dep in $?; do \\\n\t  case '$(am__configure_deps)' in \\\n\t    *$$dep*) \\\n\t      ( cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh ) \\\n\t        && { if test -f $@; then exit 0; else break; fi; }; \\\n\t      exit 1;; \\\n\t  esac; \\\n\tdone; \\\n\techo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign src/Makefile'; \\\n\t$(am__cd) $(top_srcdir) && \\\n\t  $(AUTOMAKE) --foreign src/Makefile\n.PRECIOUS: Makefile\nMakefile: $(srcdir)/Makefile.in $(top_builddir)/config.status\n\t@case '$?' in \\\n\t  *config.status*) \\\n\t    cd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh;; \\\n\t  *) \\\n\t    echo ' cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe)'; \\\n\t    cd $(top_builddir) && $(SHELL) ./config.status $(subdir)/$@ $(am__depfiles_maybe);; \\\n\tesac;\n\n$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)\n\tcd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh\n\n$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)\n\tcd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh\n$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)\n\tcd $(top_builddir) && $(MAKE) $(AM_MAKEFLAGS) am--refresh\n$(am__aclocal_m4_deps):\n\nclean-noinstLIBRARIES:\n\t-test -z \"$(noinst_LIBRARIES)\" || rm -f $(noinst_LIBRARIES)\n\nlibdmtcpinternal.a: $(libdmtcpinternal_a_OBJECTS) $(libdmtcpinternal_a_DEPENDENCIES) $(EXTRA_libdmtcpinternal_a_DEPENDENCIES) \n\t$(AM_V_at)-rm -f libdmtcpinternal.a\n\t$(AM_V_AR)$(libdmtcpinternal_a_AR) libdmtcpinternal.a $(libdmtcpinternal_a_OBJECTS) $(libdmtcpinternal_a_LIBADD)\n\t$(AM_V_at)$(RANLIB) libdmtcpinternal.a\n\nlibjalib.a: $(libjalib_a_OBJECTS) $(libjalib_a_DEPENDENCIES) $(EXTRA_libjalib_a_DEPENDENCIES) \n\t$(AM_V_at)-rm -f libjalib.a\n\t$(AM_V_AR)$(libjalib_a_AR) libjalib.a $(libjalib_a_OBJECTS) $(libjalib_a_LIBADD)\n\t$(AM_V_at)$(RANLIB) libjalib.a\n\nlibnohijack.a: $(libnohijack_a_OBJECTS) $(libnohijack_a_DEPENDENCIES) $(EXTRA_libnohijack_a_DEPENDENCIES) \n\t$(AM_V_at)-rm -f libnohijack.a\n\t$(AM_V_AR)$(libnohijack_a_AR) libnohijack.a $(libnohijack_a_OBJECTS) $(libnohijack_a_LIBADD)\n\t$(AM_V_at)$(RANLIB) libnohijack.a\n\nlibsyscallsreal.a: $(libsyscallsreal_a_OBJECTS) $(libsyscallsreal_a_DEPENDENCIES) $(EXTRA_libsyscallsreal_a_DEPENDENCIES) \n\t$(AM_V_at)-rm -f libsyscallsreal.a\n\t$(AM_V_AR)$(libsyscallsreal_a_AR) libsyscallsreal.a $(libsyscallsreal_a_OBJECTS) $(libsyscallsreal_a_LIBADD)\n\t$(AM_V_at)$(RANLIB) libsyscallsreal.a\ninstall-binPROGRAMS: $(bin_PROGRAMS)\n\t@$(NORMAL_INSTALL)\n\t@list='$(bin_PROGRAMS)'; test -n \"$(bindir)\" || list=; \\\n\tif test -n \"$$list\"; then \\\n\t  echo \" $(MKDIR_P) '$(DESTDIR)$(bindir)'\"; \\\n\t  $(MKDIR_P) \"$(DESTDIR)$(bindir)\" || exit 1; \\\n\tfi; \\\n\tfor p in $$list; do echo \"$$p $$p\"; done | \\\n\tsed 's/$(EXEEXT)$$//' | \\\n\twhile read p p1; do if test -f $$p \\\n\t  ; then echo \"$$p\"; echo \"$$p\"; else :; fi; \\\n\tdone | \\\n\tsed -e 'p;s,.*/,,;n;h' \\\n\t    -e 's|.*|.|' \\\n\t    -e 'p;x;s,.*/,,;s/$(EXEEXT)$$//;$(transform);s/$$/$(EXEEXT)/' | \\\n\tsed 'N;N;N;s,\\n, ,g' | \\\n\t$(AWK) 'BEGIN { files[\".\"] = \"\"; dirs[\".\"] = 1 } \\\n\t  { d=$$3; if (dirs[d] != 1) { print \"d\", d; dirs[d] = 1 } \\\n\t    if ($$2 == $$4) files[d] = files[d] \" \" $$1; \\\n\t    else { print \"f\", $$3 \"/\" $$4, $$1; } } \\\n\t  END { for (d in files) print \"f\", d, files[d] }' | \\\n\twhile read type dir files; do \\\n\t    if test \"$$dir\" = .; then dir=; else dir=/$$dir; fi; \\\n\t    test -z \"$$files\" || { \\\n\t      echo \" $(INSTALL_PROGRAM_ENV) $(INSTALL_PROGRAM) $$files '$(DESTDIR)$(bindir)$$dir'\"; \\\n\t      $(INSTALL_PROGRAM_ENV) $(INSTALL_PROGRAM) $$files \"$(DESTDIR)$(bindir)$$dir\" || exit $$?; \\\n\t    } \\\n\t; done\n\nuninstall-binPROGRAMS:\n\t@$(NORMAL_UNINSTALL)\n\t@list='$(bin_PROGRAMS)'; test -n \"$(bindir)\" || list=; \\\n\tfiles=`for p in $$list; do echo \"$$p\"; done | \\\n\t  sed -e 'h;s,^.*/,,;s/$(EXEEXT)$$//;$(transform)' \\\n\t      -e 's/$$/$(EXEEXT)/' \\\n\t`; \\\n\ttest -n \"$$list\" || exit 0; \\\n\techo \" ( cd '$(DESTDIR)$(bindir)' && rm -f\" $$files \")\"; \\\n\tcd \"$(DESTDIR)$(bindir)\" && rm -f $$files\n\nclean-binPROGRAMS:\n\t-test -z \"$(bin_PROGRAMS)\" || rm -f $(bin_PROGRAMS)\ninstall-dmtcplibPROGRAMS: $(dmtcplib_PROGRAMS)\n\t@$(NORMAL_INSTALL)\n\t@list='$(dmtcplib_PROGRAMS)'; test -n \"$(dmtcplibdir)\" || list=; \\\n\tif test -n \"$$list\"; then \\\n\t  echo \" $(MKDIR_P) '$(DESTDIR)$(dmtcplibdir)'\"; \\\n\t  $(MKDIR_P) \"$(DESTDIR)$(dmtcplibdir)\" || exit 1; \\\n\tfi; \\\n\tfor p in $$list; do echo \"$$p $$p\"; done | \\\n\tsed 's/$(EXEEXT)$$//' | \\\n\twhile read p p1; do if test -f $$p \\\n\t  ; then echo \"$$p\"; echo \"$$p\"; else :; fi; \\\n\tdone | \\\n\tsed -e 'p;s,.*/,,;n;h' \\\n\t    -e 's|.*|.|' \\\n\t    -e 'p;x;s,.*/,,;s/$(EXEEXT)$$//;$(transform);s/$$/$(EXEEXT)/' | \\\n\tsed 'N;N;N;s,\\n, ,g' | \\\n\t$(AWK) 'BEGIN { files[\".\"] = \"\"; dirs[\".\"] = 1 } \\\n\t  { d=$$3; if (dirs[d] != 1) { print \"d\", d; dirs[d] = 1 } \\\n\t    if ($$2 == $$4) files[d] = files[d] \" \" $$1; \\\n\t    else { print \"f\", $$3 \"/\" $$4, $$1; } } \\\n\t  END { for (d in files) print \"f\", d, files[d] }' | \\\n\twhile read type dir files; do \\\n\t    if test \"$$dir\" = .; then dir=; else dir=/$$dir; fi; \\\n\t    test -z \"$$files\" || { \\\n\t      echo \" $(INSTALL_PROGRAM_ENV) $(INSTALL_PROGRAM) $$files '$(DESTDIR)$(dmtcplibdir)$$dir'\"; \\\n\t      $(INSTALL_PROGRAM_ENV) $(INSTALL_PROGRAM) $$files \"$(DESTDIR)$(dmtcplibdir)$$dir\" || exit $$?; \\\n\t    } \\\n\t; done\n\nuninstall-dmtcplibPROGRAMS:\n\t@$(NORMAL_UNINSTALL)\n\t@list='$(dmtcplib_PROGRAMS)'; test -n \"$(dmtcplibdir)\" || list=; \\\n\tfiles=`for p in $$list; do echo \"$$p\"; done | \\\n\t  sed -e 'h;s,^.*/,,;s/$(EXEEXT)$$//;$(transform)' \\\n\t      -e 's/$$/$(EXEEXT)/' \\\n\t`; \\\n\ttest -n \"$$list\" || exit 0; \\\n\techo \" ( cd '$(DESTDIR)$(dmtcplibdir)' && rm -f\" $$files \")\"; \\\n\tcd \"$(DESTDIR)$(dmtcplibdir)\" && rm -f $$files\n\nclean-dmtcplibPROGRAMS:\n\t-test -z \"$(dmtcplib_PROGRAMS)\" || rm -f $(dmtcplib_PROGRAMS)\n$(d_bindir)/$(am__dirstamp):\n\t@$(MKDIR_P) $(d_bindir)\n\t@: > $(d_bindir)/$(am__dirstamp)\n\n$(d_bindir)/dmtcp_command$(EXEEXT): $(__d_bindir__dmtcp_command_OBJECTS) $(__d_bindir__dmtcp_command_DEPENDENCIES) $(EXTRA___d_bindir__dmtcp_command_DEPENDENCIES) $(d_bindir)/$(am__dirstamp)\n\t@rm -f $(d_bindir)/dmtcp_command$(EXEEXT)\n\t$(AM_V_CXXLD)$(CXXLINK) $(__d_bindir__dmtcp_command_OBJECTS) $(__d_bindir__dmtcp_command_LDADD) $(LIBS)\n\n$(d_bindir)/dmtcp_coordinator$(EXEEXT): $(__d_bindir__dmtcp_coordinator_OBJECTS) $(__d_bindir__dmtcp_coordinator_DEPENDENCIES) $(EXTRA___d_bindir__dmtcp_coordinator_DEPENDENCIES) $(d_bindir)/$(am__dirstamp)\n\t@rm -f $(d_bindir)/dmtcp_coordinator$(EXEEXT)\n\t$(AM_V_CXXLD)$(CXXLINK) $(__d_bindir__dmtcp_coordinator_OBJECTS) $(__d_bindir__dmtcp_coordinator_LDADD) $(LIBS)\n\n$(d_bindir)/dmtcp_launch$(EXEEXT): $(__d_bindir__dmtcp_launch_OBJECTS) $(__d_bindir__dmtcp_launch_DEPENDENCIES) $(EXTRA___d_bindir__dmtcp_launch_DEPENDENCIES) $(d_bindir)/$(am__dirstamp)\n\t@rm -f $(d_bindir)/dmtcp_launch$(EXEEXT)\n\t$(AM_V_CXXLD)$(CXXLINK) $(__d_bindir__dmtcp_launch_OBJECTS) $(__d_bindir__dmtcp_launch_LDADD) $(LIBS)\n\n$(d_bindir)/dmtcp_nocheckpoint$(EXEEXT): $(__d_bindir__dmtcp_nocheckpoint_OBJECTS) $(__d_bindir__dmtcp_nocheckpoint_DEPENDENCIES) $(EXTRA___d_bindir__dmtcp_nocheckpoint_DEPENDENCIES) $(d_bindir)/$(am__dirstamp)\n\t@rm -f $(d_bindir)/dmtcp_nocheckpoint$(EXEEXT)\n\t$(AM_V_CCLD)$(LINK) $(__d_bindir__dmtcp_nocheckpoint_OBJECTS) $(__d_bindir__dmtcp_nocheckpoint_LDADD) $(LIBS)\n\n$(d_bindir)/dmtcp_restart$(EXEEXT): $(__d_bindir__dmtcp_restart_OBJECTS) $(__d_bindir__dmtcp_restart_DEPENDENCIES) $(EXTRA___d_bindir__dmtcp_restart_DEPENDENCIES) $(d_bindir)/$(am__dirstamp)\n\t@rm -f $(d_bindir)/dmtcp_restart$(EXEEXT)\n\t$(AM_V_CXXLD)$(CXXLINK) $(__d_bindir__dmtcp_restart_OBJECTS) $(__d_bindir__dmtcp_restart_LDADD) $(LIBS)\n$(d_libdir)/$(am__dirstamp):\n\t@$(MKDIR_P) $(d_libdir)\n\t@: > $(d_libdir)/$(am__dirstamp)\n\n$(d_libdir)/libdmtcp.so$(EXEEXT): $(__d_libdir__libdmtcp_so_OBJECTS) $(__d_libdir__libdmtcp_so_DEPENDENCIES) $(EXTRA___d_libdir__libdmtcp_so_DEPENDENCIES) $(d_libdir)/$(am__dirstamp)\n\t@rm -f $(d_libdir)/libdmtcp.so$(EXEEXT)\n\t$(AM_V_CXXLD)$(__d_libdir__libdmtcp_so_LINK) $(__d_libdir__libdmtcp_so_OBJECTS) $(__d_libdir__libdmtcp_so_LDADD) $(LIBS)\n\nmostlyclean-compile:\n\t-rm -f *.$(OBJEXT)\n\ndistclean-compile:\n\t-rm -f *.tab.c\n\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/alarm.Po@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/ckptserializer.Po@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/coordinatorapi.Po@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dmtcp_command.Po@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dmtcp_coordinator.Po@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dmtcp_dlsym.Po@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dmtcp_launch.Po@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dmtcp_nocheckpoint.Po@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dmtcp_restart.Po@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dmtcpmessagetypes.Po@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dmtcpnohijackstubs.Po@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dmtcpplugin.Po@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/dmtcpworker.Po@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/execwrappers.Po@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/glibcsystem.Po@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/jalib.Po@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/jalibinterface.Po@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/jalloc.Po@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/jassert.Po@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/jbuffer.Po@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/jfilesystem.Po@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/jserialize.Po@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/jsocket.Po@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/jtimer.Po@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/lookup_service.Po@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/miscwrappers.Po@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/mtcpinterface.Po@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/nosyscallsreal.Po@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/popen.Po@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/processinfo.Po@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/procselfmaps.Po@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/restartscript.Po@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/shareddata.Po@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/siginfo.Po@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/signalwrappers.Po@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/syscallsreal.Po@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/syslogwrappers.Po@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/terminal.Po@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/threadlist.Po@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/threadsync.Po@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/threadwrappers.Po@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/trampolines.Po@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/uniquepid.Po@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/util_exec.Po@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/util_init.Po@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/util_misc.Po@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/workerstate.Po@am__quote@\n@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/writeckpt.Po@am__quote@\n\n.c.o:\n@am__fastdepCC_TRUE@\t$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n@am__fastdepCC_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n@AMDEP_TRUE@@am__fastdepCC_FALSE@\t$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n@am__fastdepCC_FALSE@\t$(AM_V_CC@am__nodep@)$(COMPILE) -c $<\n\n.c.obj:\n@am__fastdepCC_TRUE@\t$(AM_V_CC)$(COMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`\n@am__fastdepCC_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n@AMDEP_TRUE@@am__fastdepCC_FALSE@\t$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n@am__fastdepCC_FALSE@\t$(AM_V_CC@am__nodep@)$(COMPILE) -c `$(CYGPATH_W) '$<'`\n\n.cpp.o:\n@am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n@am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n@AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n@am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(CXXCOMPILE) -c -o $@ $<\n\n.cpp.obj:\n@am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`\n@am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n@AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n@am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(CXXCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`\n\njalib.o: $(jalibdir)/jalib.cpp\n@am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT jalib.o -MD -MP -MF $(DEPDIR)/jalib.Tpo -c -o jalib.o `test -f '$(jalibdir)/jalib.cpp' || echo '$(srcdir)/'`$(jalibdir)/jalib.cpp\n@am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/jalib.Tpo $(DEPDIR)/jalib.Po\n@AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='$(jalibdir)/jalib.cpp' object='jalib.o' libtool=no @AMDEPBACKSLASH@\n@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n@am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o jalib.o `test -f '$(jalibdir)/jalib.cpp' || echo '$(srcdir)/'`$(jalibdir)/jalib.cpp\n\njalib.obj: $(jalibdir)/jalib.cpp\n@am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT jalib.obj -MD -MP -MF $(DEPDIR)/jalib.Tpo -c -o jalib.obj `if test -f '$(jalibdir)/jalib.cpp'; then $(CYGPATH_W) '$(jalibdir)/jalib.cpp'; else $(CYGPATH_W) '$(srcdir)/$(jalibdir)/jalib.cpp'; fi`\n@am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/jalib.Tpo $(DEPDIR)/jalib.Po\n@AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='$(jalibdir)/jalib.cpp' object='jalib.obj' libtool=no @AMDEPBACKSLASH@\n@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n@am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o jalib.obj `if test -f '$(jalibdir)/jalib.cpp'; then $(CYGPATH_W) '$(jalibdir)/jalib.cpp'; else $(CYGPATH_W) '$(srcdir)/$(jalibdir)/jalib.cpp'; fi`\n\njassert.o: $(jalibdir)/jassert.cpp\n@am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT jassert.o -MD -MP -MF $(DEPDIR)/jassert.Tpo -c -o jassert.o `test -f '$(jalibdir)/jassert.cpp' || echo '$(srcdir)/'`$(jalibdir)/jassert.cpp\n@am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/jassert.Tpo $(DEPDIR)/jassert.Po\n@AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='$(jalibdir)/jassert.cpp' object='jassert.o' libtool=no @AMDEPBACKSLASH@\n@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n@am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o jassert.o `test -f '$(jalibdir)/jassert.cpp' || echo '$(srcdir)/'`$(jalibdir)/jassert.cpp\n\njassert.obj: $(jalibdir)/jassert.cpp\n@am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT jassert.obj -MD -MP -MF $(DEPDIR)/jassert.Tpo -c -o jassert.obj `if test -f '$(jalibdir)/jassert.cpp'; then $(CYGPATH_W) '$(jalibdir)/jassert.cpp'; else $(CYGPATH_W) '$(srcdir)/$(jalibdir)/jassert.cpp'; fi`\n@am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/jassert.Tpo $(DEPDIR)/jassert.Po\n@AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='$(jalibdir)/jassert.cpp' object='jassert.obj' libtool=no @AMDEPBACKSLASH@\n@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n@am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o jassert.obj `if test -f '$(jalibdir)/jassert.cpp'; then $(CYGPATH_W) '$(jalibdir)/jassert.cpp'; else $(CYGPATH_W) '$(srcdir)/$(jalibdir)/jassert.cpp'; fi`\n\njbuffer.o: $(jalibdir)/jbuffer.cpp\n@am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT jbuffer.o -MD -MP -MF $(DEPDIR)/jbuffer.Tpo -c -o jbuffer.o `test -f '$(jalibdir)/jbuffer.cpp' || echo '$(srcdir)/'`$(jalibdir)/jbuffer.cpp\n@am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/jbuffer.Tpo $(DEPDIR)/jbuffer.Po\n@AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='$(jalibdir)/jbuffer.cpp' object='jbuffer.o' libtool=no @AMDEPBACKSLASH@\n@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n@am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o jbuffer.o `test -f '$(jalibdir)/jbuffer.cpp' || echo '$(srcdir)/'`$(jalibdir)/jbuffer.cpp\n\njbuffer.obj: $(jalibdir)/jbuffer.cpp\n@am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT jbuffer.obj -MD -MP -MF $(DEPDIR)/jbuffer.Tpo -c -o jbuffer.obj `if test -f '$(jalibdir)/jbuffer.cpp'; then $(CYGPATH_W) '$(jalibdir)/jbuffer.cpp'; else $(CYGPATH_W) '$(srcdir)/$(jalibdir)/jbuffer.cpp'; fi`\n@am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/jbuffer.Tpo $(DEPDIR)/jbuffer.Po\n@AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='$(jalibdir)/jbuffer.cpp' object='jbuffer.obj' libtool=no @AMDEPBACKSLASH@\n@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n@am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o jbuffer.obj `if test -f '$(jalibdir)/jbuffer.cpp'; then $(CYGPATH_W) '$(jalibdir)/jbuffer.cpp'; else $(CYGPATH_W) '$(srcdir)/$(jalibdir)/jbuffer.cpp'; fi`\n\njfilesystem.o: $(jalibdir)/jfilesystem.cpp\n@am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT jfilesystem.o -MD -MP -MF $(DEPDIR)/jfilesystem.Tpo -c -o jfilesystem.o `test -f '$(jalibdir)/jfilesystem.cpp' || echo '$(srcdir)/'`$(jalibdir)/jfilesystem.cpp\n@am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/jfilesystem.Tpo $(DEPDIR)/jfilesystem.Po\n@AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='$(jalibdir)/jfilesystem.cpp' object='jfilesystem.o' libtool=no @AMDEPBACKSLASH@\n@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n@am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o jfilesystem.o `test -f '$(jalibdir)/jfilesystem.cpp' || echo '$(srcdir)/'`$(jalibdir)/jfilesystem.cpp\n\njfilesystem.obj: $(jalibdir)/jfilesystem.cpp\n@am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT jfilesystem.obj -MD -MP -MF $(DEPDIR)/jfilesystem.Tpo -c -o jfilesystem.obj `if test -f '$(jalibdir)/jfilesystem.cpp'; then $(CYGPATH_W) '$(jalibdir)/jfilesystem.cpp'; else $(CYGPATH_W) '$(srcdir)/$(jalibdir)/jfilesystem.cpp'; fi`\n@am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/jfilesystem.Tpo $(DEPDIR)/jfilesystem.Po\n@AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='$(jalibdir)/jfilesystem.cpp' object='jfilesystem.obj' libtool=no @AMDEPBACKSLASH@\n@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n@am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o jfilesystem.obj `if test -f '$(jalibdir)/jfilesystem.cpp'; then $(CYGPATH_W) '$(jalibdir)/jfilesystem.cpp'; else $(CYGPATH_W) '$(srcdir)/$(jalibdir)/jfilesystem.cpp'; fi`\n\njserialize.o: $(jalibdir)/jserialize.cpp\n@am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT jserialize.o -MD -MP -MF $(DEPDIR)/jserialize.Tpo -c -o jserialize.o `test -f '$(jalibdir)/jserialize.cpp' || echo '$(srcdir)/'`$(jalibdir)/jserialize.cpp\n@am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/jserialize.Tpo $(DEPDIR)/jserialize.Po\n@AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='$(jalibdir)/jserialize.cpp' object='jserialize.o' libtool=no @AMDEPBACKSLASH@\n@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n@am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o jserialize.o `test -f '$(jalibdir)/jserialize.cpp' || echo '$(srcdir)/'`$(jalibdir)/jserialize.cpp\n\njserialize.obj: $(jalibdir)/jserialize.cpp\n@am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT jserialize.obj -MD -MP -MF $(DEPDIR)/jserialize.Tpo -c -o jserialize.obj `if test -f '$(jalibdir)/jserialize.cpp'; then $(CYGPATH_W) '$(jalibdir)/jserialize.cpp'; else $(CYGPATH_W) '$(srcdir)/$(jalibdir)/jserialize.cpp'; fi`\n@am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/jserialize.Tpo $(DEPDIR)/jserialize.Po\n@AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='$(jalibdir)/jserialize.cpp' object='jserialize.obj' libtool=no @AMDEPBACKSLASH@\n@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n@am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o jserialize.obj `if test -f '$(jalibdir)/jserialize.cpp'; then $(CYGPATH_W) '$(jalibdir)/jserialize.cpp'; else $(CYGPATH_W) '$(srcdir)/$(jalibdir)/jserialize.cpp'; fi`\n\njsocket.o: $(jalibdir)/jsocket.cpp\n@am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT jsocket.o -MD -MP -MF $(DEPDIR)/jsocket.Tpo -c -o jsocket.o `test -f '$(jalibdir)/jsocket.cpp' || echo '$(srcdir)/'`$(jalibdir)/jsocket.cpp\n@am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/jsocket.Tpo $(DEPDIR)/jsocket.Po\n@AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='$(jalibdir)/jsocket.cpp' object='jsocket.o' libtool=no @AMDEPBACKSLASH@\n@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n@am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o jsocket.o `test -f '$(jalibdir)/jsocket.cpp' || echo '$(srcdir)/'`$(jalibdir)/jsocket.cpp\n\njsocket.obj: $(jalibdir)/jsocket.cpp\n@am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT jsocket.obj -MD -MP -MF $(DEPDIR)/jsocket.Tpo -c -o jsocket.obj `if test -f '$(jalibdir)/jsocket.cpp'; then $(CYGPATH_W) '$(jalibdir)/jsocket.cpp'; else $(CYGPATH_W) '$(srcdir)/$(jalibdir)/jsocket.cpp'; fi`\n@am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/jsocket.Tpo $(DEPDIR)/jsocket.Po\n@AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='$(jalibdir)/jsocket.cpp' object='jsocket.obj' libtool=no @AMDEPBACKSLASH@\n@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n@am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o jsocket.obj `if test -f '$(jalibdir)/jsocket.cpp'; then $(CYGPATH_W) '$(jalibdir)/jsocket.cpp'; else $(CYGPATH_W) '$(srcdir)/$(jalibdir)/jsocket.cpp'; fi`\n\njtimer.o: $(jalibdir)/jtimer.cpp\n@am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT jtimer.o -MD -MP -MF $(DEPDIR)/jtimer.Tpo -c -o jtimer.o `test -f '$(jalibdir)/jtimer.cpp' || echo '$(srcdir)/'`$(jalibdir)/jtimer.cpp\n@am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/jtimer.Tpo $(DEPDIR)/jtimer.Po\n@AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='$(jalibdir)/jtimer.cpp' object='jtimer.o' libtool=no @AMDEPBACKSLASH@\n@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n@am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o jtimer.o `test -f '$(jalibdir)/jtimer.cpp' || echo '$(srcdir)/'`$(jalibdir)/jtimer.cpp\n\njtimer.obj: $(jalibdir)/jtimer.cpp\n@am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT jtimer.obj -MD -MP -MF $(DEPDIR)/jtimer.Tpo -c -o jtimer.obj `if test -f '$(jalibdir)/jtimer.cpp'; then $(CYGPATH_W) '$(jalibdir)/jtimer.cpp'; else $(CYGPATH_W) '$(srcdir)/$(jalibdir)/jtimer.cpp'; fi`\n@am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/jtimer.Tpo $(DEPDIR)/jtimer.Po\n@AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='$(jalibdir)/jtimer.cpp' object='jtimer.obj' libtool=no @AMDEPBACKSLASH@\n@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n@am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o jtimer.obj `if test -f '$(jalibdir)/jtimer.cpp'; then $(CYGPATH_W) '$(jalibdir)/jtimer.cpp'; else $(CYGPATH_W) '$(srcdir)/$(jalibdir)/jtimer.cpp'; fi`\n\njalloc.o: $(jalibdir)/jalloc.cpp\n@am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT jalloc.o -MD -MP -MF $(DEPDIR)/jalloc.Tpo -c -o jalloc.o `test -f '$(jalibdir)/jalloc.cpp' || echo '$(srcdir)/'`$(jalibdir)/jalloc.cpp\n@am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/jalloc.Tpo $(DEPDIR)/jalloc.Po\n@AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='$(jalibdir)/jalloc.cpp' object='jalloc.o' libtool=no @AMDEPBACKSLASH@\n@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n@am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o jalloc.o `test -f '$(jalibdir)/jalloc.cpp' || echo '$(srcdir)/'`$(jalibdir)/jalloc.cpp\n\njalloc.obj: $(jalibdir)/jalloc.cpp\n@am__fastdepCXX_TRUE@\t$(AM_V_CXX)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -MT jalloc.obj -MD -MP -MF $(DEPDIR)/jalloc.Tpo -c -o jalloc.obj `if test -f '$(jalibdir)/jalloc.cpp'; then $(CYGPATH_W) '$(jalibdir)/jalloc.cpp'; else $(CYGPATH_W) '$(srcdir)/$(jalibdir)/jalloc.cpp'; fi`\n@am__fastdepCXX_TRUE@\t$(AM_V_at)$(am__mv) $(DEPDIR)/jalloc.Tpo $(DEPDIR)/jalloc.Po\n@AMDEP_TRUE@@am__fastdepCXX_FALSE@\t$(AM_V_CXX)source='$(jalibdir)/jalloc.cpp' object='jalloc.obj' libtool=no @AMDEPBACKSLASH@\n@AMDEP_TRUE@@am__fastdepCXX_FALSE@\tDEPDIR=$(DEPDIR) $(CXXDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n@am__fastdepCXX_FALSE@\t$(AM_V_CXX@am__nodep@)$(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS) -c -o jalloc.obj `if test -f '$(jalibdir)/jalloc.cpp'; then $(CYGPATH_W) '$(jalibdir)/jalloc.cpp'; else $(CYGPATH_W) '$(srcdir)/$(jalibdir)/jalloc.cpp'; fi`\ninstall-includeHEADERS: $(include_HEADERS)\n\t@$(NORMAL_INSTALL)\n\t@list='$(include_HEADERS)'; test -n \"$(includedir)\" || list=; \\\n\tif test -n \"$$list\"; then \\\n\t  echo \" $(MKDIR_P) '$(DESTDIR)$(includedir)'\"; \\\n\t  $(MKDIR_P) \"$(DESTDIR)$(includedir)\" || exit 1; \\\n\tfi; \\\n\tfor p in $$list; do \\\n\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n\t  echo \"$$d$$p\"; \\\n\tdone | $(am__base_list) | \\\n\twhile read files; do \\\n\t  echo \" $(INSTALL_HEADER) $$files '$(DESTDIR)$(includedir)'\"; \\\n\t  $(INSTALL_HEADER) $$files \"$(DESTDIR)$(includedir)\" || exit $$?; \\\n\tdone\n\nuninstall-includeHEADERS:\n\t@$(NORMAL_UNINSTALL)\n\t@list='$(include_HEADERS)'; test -n \"$(includedir)\" || list=; \\\n\tfiles=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \\\n\tdir='$(DESTDIR)$(includedir)'; $(am__uninstall_files_from_dir)\n\n# This directory's subdirectories are mostly independent; you can cd\n# into them and run 'make' without going through this Makefile.\n# To change the values of 'make' variables: instead of editing Makefiles,\n# (1) if the variable is set in 'config.status', edit 'config.status'\n#     (which will cause the Makefiles to be regenerated when you run 'make');\n# (2) otherwise, pass the desired values on the 'make' command line.\n$(am__recursive_targets):\n\t@fail=; \\\n\tif $(am__make_keepgoing); then \\\n\t  failcom='fail=yes'; \\\n\telse \\\n\t  failcom='exit 1'; \\\n\tfi; \\\n\tdot_seen=no; \\\n\ttarget=`echo $@ | sed s/-recursive//`; \\\n\tcase \"$@\" in \\\n\t  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \\\n\t  *) list='$(SUBDIRS)' ;; \\\n\tesac; \\\n\tfor subdir in $$list; do \\\n\t  echo \"Making $$target in $$subdir\"; \\\n\t  if test \"$$subdir\" = \".\"; then \\\n\t    dot_seen=yes; \\\n\t    local_target=\"$$target-am\"; \\\n\t  else \\\n\t    local_target=\"$$target\"; \\\n\t  fi; \\\n\t  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \\\n\t  || eval $$failcom; \\\n\tdone; \\\n\tif test \"$$dot_seen\" = \"no\"; then \\\n\t  $(MAKE) $(AM_MAKEFLAGS) \"$$target-am\" || exit 1; \\\n\tfi; test -z \"$$fail\"\n\nID: $(am__tagged_files)\n\t$(am__define_uniq_tagged_files); mkid -fID $$unique\ntags: tags-recursive\nTAGS: tags\n\ntags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)\n\tset x; \\\n\there=`pwd`; \\\n\tif ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \\\n\t  include_option=--etags-include; \\\n\t  empty_fix=.; \\\n\telse \\\n\t  include_option=--include; \\\n\t  empty_fix=; \\\n\tfi; \\\n\tlist='$(SUBDIRS)'; for subdir in $$list; do \\\n\t  if test \"$$subdir\" = .; then :; else \\\n\t    test ! -f $$subdir/TAGS || \\\n\t      set \"$$@\" \"$$include_option=$$here/$$subdir/TAGS\"; \\\n\t  fi; \\\n\tdone; \\\n\t$(am__define_uniq_tagged_files); \\\n\tshift; \\\n\tif test -z \"$(ETAGS_ARGS)$$*$$unique\"; then :; else \\\n\t  test -n \"$$unique\" || unique=$$empty_fix; \\\n\t  if test $$# -gt 0; then \\\n\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n\t      \"$$@\" $$unique; \\\n\t  else \\\n\t    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \\\n\t      $$unique; \\\n\t  fi; \\\n\tfi\nctags: ctags-recursive\n\nCTAGS: ctags\nctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)\n\t$(am__define_uniq_tagged_files); \\\n\ttest -z \"$(CTAGS_ARGS)$$unique\" \\\n\t  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \\\n\t     $$unique\n\nGTAGS:\n\there=`$(am__cd) $(top_builddir) && pwd` \\\n\t  && $(am__cd) $(top_srcdir) \\\n\t  && gtags -i $(GTAGS_ARGS) \"$$here\"\ncscopelist: cscopelist-recursive\n\ncscopelist-am: $(am__tagged_files)\n\tlist='$(am__tagged_files)'; \\\n\tcase \"$(srcdir)\" in \\\n\t  [\\\\/]* | ?:[\\\\/]*) sdir=\"$(srcdir)\" ;; \\\n\t  *) sdir=$(subdir)/$(srcdir) ;; \\\n\tesac; \\\n\tfor i in $$list; do \\\n\t  if test -f \"$$i\"; then \\\n\t    echo \"$(subdir)/$$i\"; \\\n\t  else \\\n\t    echo \"$$sdir/$$i\"; \\\n\t  fi; \\\n\tdone >> $(top_builddir)/cscope.files\n\ndistclean-tags:\n\t-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags\n\ndistdir: $(DISTFILES)\n\t@srcdirstrip=`echo \"$(srcdir)\" | sed 's/[].[^$$\\\\*]/\\\\\\\\&/g'`; \\\n\ttopsrcdirstrip=`echo \"$(top_srcdir)\" | sed 's/[].[^$$\\\\*]/\\\\\\\\&/g'`; \\\n\tlist='$(DISTFILES)'; \\\n\t  dist_files=`for file in $$list; do echo $$file; done | \\\n\t  sed -e \"s|^$$srcdirstrip/||;t\" \\\n\t      -e \"s|^$$topsrcdirstrip/|$(top_builddir)/|;t\"`; \\\n\tcase $$dist_files in \\\n\t  */*) $(MKDIR_P) `echo \"$$dist_files\" | \\\n\t\t\t   sed '/\\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \\\n\t\t\t   sort -u` ;; \\\n\tesac; \\\n\tfor file in $$dist_files; do \\\n\t  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \\\n\t  if test -d $$d/$$file; then \\\n\t    dir=`echo \"/$$file\" | sed -e 's,/[^/]*$$,,'`; \\\n\t    if test -d \"$(distdir)/$$file\"; then \\\n\t      find \"$(distdir)/$$file\" -type d ! -perm -700 -exec chmod u+rwx {} \\;; \\\n\t    fi; \\\n\t    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \\\n\t      cp -fpR $(srcdir)/$$file \"$(distdir)$$dir\" || exit 1; \\\n\t      find \"$(distdir)/$$file\" -type d ! -perm -700 -exec chmod u+rwx {} \\;; \\\n\t    fi; \\\n\t    cp -fpR $$d/$$file \"$(distdir)$$dir\" || exit 1; \\\n\t  else \\\n\t    test -f \"$(distdir)/$$file\" \\\n\t    || cp -p $$d/$$file \"$(distdir)/$$file\" \\\n\t    || exit 1; \\\n\t  fi; \\\n\tdone\n\t@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \\\n\t  if test \"$$subdir\" = .; then :; else \\\n\t    $(am__make_dryrun) \\\n\t      || test -d \"$(distdir)/$$subdir\" \\\n\t      || $(MKDIR_P) \"$(distdir)/$$subdir\" \\\n\t      || exit 1; \\\n\t    dir1=$$subdir; dir2=\"$(distdir)/$$subdir\"; \\\n\t    $(am__relativize); \\\n\t    new_distdir=$$reldir; \\\n\t    dir1=$$subdir; dir2=\"$(top_distdir)\"; \\\n\t    $(am__relativize); \\\n\t    new_top_distdir=$$reldir; \\\n\t    echo \" (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) top_distdir=\"$$new_top_distdir\" distdir=\"$$new_distdir\" \\\\\"; \\\n\t    echo \"     am__remove_distdir=: am__skip_length_check=: am__skip_mode_fix=: distdir)\"; \\\n\t    ($(am__cd) $$subdir && \\\n\t      $(MAKE) $(AM_MAKEFLAGS) \\\n\t        top_distdir=\"$$new_top_distdir\" \\\n\t        distdir=\"$$new_distdir\" \\\n\t\tam__remove_distdir=: \\\n\t\tam__skip_length_check=: \\\n\t\tam__skip_mode_fix=: \\\n\t        distdir) \\\n\t      || exit 1; \\\n\t  fi; \\\n\tdone\ncheck-am: all-am\ncheck: check-recursive\nall-am: Makefile $(LIBRARIES) $(PROGRAMS) $(HEADERS)\ninstalldirs: installdirs-recursive\ninstalldirs-am:\n\tfor dir in \"$(DESTDIR)$(bindir)\" \"$(DESTDIR)$(dmtcplibdir)\" \"$(DESTDIR)$(includedir)\"; do \\\n\t  test -z \"$$dir\" || $(MKDIR_P) \"$$dir\"; \\\n\tdone\ninstall: install-recursive\ninstall-exec: install-exec-recursive\ninstall-data: install-data-recursive\nuninstall: uninstall-recursive\n\ninstall-am: all-am\n\t@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am\n\ninstallcheck: installcheck-recursive\ninstall-strip:\n\tif test -z '$(STRIP)'; then \\\n\t  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n\t    install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n\t      install; \\\n\telse \\\n\t  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" \\\n\t    install_sh_PROGRAM=\"$(INSTALL_STRIP_PROGRAM)\" INSTALL_STRIP_FLAG=-s \\\n\t    \"INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'\" install; \\\n\tfi\nmostlyclean-generic:\n\nclean-generic:\n\ndistclean-generic:\n\t-test -z \"$(CONFIG_CLEAN_FILES)\" || rm -f $(CONFIG_CLEAN_FILES)\n\t-test . = \"$(srcdir)\" || test -z \"$(CONFIG_CLEAN_VPATH_FILES)\" || rm -f $(CONFIG_CLEAN_VPATH_FILES)\n\t-test -z \"$(d_bindir)/$(am__dirstamp)\" || rm -f $(d_bindir)/$(am__dirstamp)\n\t-test -z \"$(d_libdir)/$(am__dirstamp)\" || rm -f $(d_libdir)/$(am__dirstamp)\n\nmaintainer-clean-generic:\n\t@echo \"This command is intended for maintainers to use\"\n\t@echo \"it deletes files that may require special tools to rebuild.\"\nclean: clean-recursive\n\nclean-am: clean-binPROGRAMS clean-dmtcplibPROGRAMS clean-generic \\\n\tclean-noinstLIBRARIES mostlyclean-am\n\ndistclean: distclean-recursive\n\t-rm -rf ./$(DEPDIR)\n\t-rm -f Makefile\ndistclean-am: clean-am distclean-compile distclean-generic \\\n\tdistclean-tags\n\ndvi: dvi-recursive\n\ndvi-am:\n\nhtml: html-recursive\n\nhtml-am:\n\ninfo: info-recursive\n\ninfo-am:\n\ninstall-data-am: install-dmtcplibPROGRAMS install-includeHEADERS\n\ninstall-dvi: install-dvi-recursive\n\ninstall-dvi-am:\n\ninstall-exec-am: install-binPROGRAMS\n\ninstall-html: install-html-recursive\n\ninstall-html-am:\n\ninstall-info: install-info-recursive\n\ninstall-info-am:\n\ninstall-man:\n\ninstall-pdf: install-pdf-recursive\n\ninstall-pdf-am:\n\ninstall-ps: install-ps-recursive\n\ninstall-ps-am:\n\ninstallcheck-am:\n\nmaintainer-clean: maintainer-clean-recursive\n\t-rm -rf ./$(DEPDIR)\n\t-rm -f Makefile\nmaintainer-clean-am: distclean-am maintainer-clean-generic\n\nmostlyclean: mostlyclean-recursive\n\nmostlyclean-am: mostlyclean-compile mostlyclean-generic\n\npdf: pdf-recursive\n\npdf-am:\n\nps: ps-recursive\n\nps-am:\n\nuninstall-am: uninstall-binPROGRAMS uninstall-dmtcplibPROGRAMS \\\n\tuninstall-includeHEADERS\n\n.MAKE: $(am__recursive_targets) install-am install-strip\n\n.PHONY: $(am__recursive_targets) CTAGS GTAGS TAGS all all-am check \\\n\tcheck-am clean clean-binPROGRAMS clean-dmtcplibPROGRAMS \\\n\tclean-generic clean-noinstLIBRARIES cscopelist-am ctags \\\n\tctags-am distclean distclean-compile distclean-generic \\\n\tdistclean-tags distdir dvi dvi-am html html-am info info-am \\\n\tinstall install-am install-binPROGRAMS install-data \\\n\tinstall-data-am install-dmtcplibPROGRAMS install-dvi \\\n\tinstall-dvi-am install-exec install-exec-am install-html \\\n\tinstall-html-am install-includeHEADERS install-info \\\n\tinstall-info-am install-man install-pdf install-pdf-am \\\n\tinstall-ps install-ps-am install-strip installcheck \\\n\tinstallcheck-am installdirs installdirs-am maintainer-clean \\\n\tmaintainer-clean-generic mostlyclean mostlyclean-compile \\\n\tmostlyclean-generic pdf pdf-am ps ps-am tags tags-am uninstall \\\n\tuninstall-am uninstall-binPROGRAMS uninstall-dmtcplibPROGRAMS \\\n\tuninstall-includeHEADERS\n\n\nmtcp/libmtcp.a:\n\tcd mtcp && ${MAKE} libmtcp.a\n\ninstall-libs: install-dmtcplibPROGRAMS\n\t(cd mtcp && ${MAKE} install-libs)\n\t(cd plugin && ${MAKE} install-libs)\n\nuninstall-libs: uninstall-dmtcplibPROGRAMS\n\t(cd mtcp && ${MAKE} uninstall-libs)\n\t(cd plugin && ${MAKE} uninstall-libs)\n\n.PHONY: install-libs uninstall-libs\n\n# Tell versions [3.59,3.63) of GNU make to not export all variables.\n# Otherwise a system limit (for SysV at least) may be exceeded.\n.NOEXPORT:\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/src/plugin/alloc/alloc.h": "/****************************************************************************\n *   Copyright (C) 2006-2008 by Jason Ansel, Kapil Arya, and Gene Cooperman *\n *   jansel@csail.mit.edu, kapil@ccs.neu.edu, gene@ccs.neu.edu              *\n *                                                                          *\n *   This file is part of the dmtcp/src module of DMTCP (DMTCP:dmtcp/src).  *\n *                                                                          *\n *  DMTCP:dmtcp/src is free software: you can redistribute it and/or        *\n *  modify it under the terms of the GNU Lesser General Public License as   *\n *  published by the Free Software Foundation, either version 3 of the      *\n *  License, or (at your option) any later version.                         *\n *                                                                          *\n *  DMTCP:dmtcp/src is distributed in the hope that it will be useful,      *\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of          *\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *\n *  GNU Lesser General Public License for more details.                     *\n *                                                                          *\n *  You should have received a copy of the GNU Lesser General Public        *\n *  License along with DMTCP:dmtcp/src.  If not, see                        *\n *  <http://www.gnu.org/licenses/>.                                         *\n ****************************************************************************/\n\n#ifndef ALLOC_H\n#define ALLOC_H\n\n#include <stdlib.h>\n#include <sys/mman.h>\n#include \"dmtcp.h\"\n#include \"dmtcp_dlsym.h\"\n\nextern \"C\" void *__libc_memalign(size_t boundary, size_t size);\n\n#define _real_malloc  NEXT_FNC_DEFAULT(malloc)\n#define _real_calloc  NEXT_FNC_DEFAULT(calloc)\n#define _real_valloc  NEXT_FNC_DEFAULT(valloc)\n#define _real_realloc NEXT_FNC_DEFAULT(realloc)\n#define _real_free    NEXT_FNC_DEFAULT(free)\n#define _real_memalign NEXT_FNC_DEFAULT(memalign)\n#define _real_posix_memalign NEXT_FNC_DEFAULT(posix_memalign)\n#define _real_libc_memalign NEXT_FNC_DEFAULT(__libc_memalign)\n\n#define _real_mmap NEXT_FNC_DEFAULT(mmap)\n#define _real_mmap64 NEXT_FNC_DEFAULT(mmap64)\n#define _real_munmap NEXT_FNC_DEFAULT(munmap)\n#define _real_mremap NEXT_FNC_DEFAULT(mremap)\n#endif //ALLOC_H\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/src/plugin/pid/pidwrappers.h": "/****************************************************************************\n *   Copyright (C) 2006-2008 by Jason Ansel, Kapil Arya, and Gene Cooperman *\n *   jansel@csail.mit.edu, kapil@ccs.neu.edu, gene@ccs.neu.edu              *\n *                                                                          *\n *   This file is part of the dmtcp/src module of DMTCP (DMTCP:dmtcp/src).  *\n *                                                                          *\n *  DMTCP:dmtcp/src is free software: you can redistribute it and/or        *\n *  modify it under the terms of the GNU Lesser General Public License as   *\n *  published by the Free Software Foundation, either version 3 of the      *\n *  License, or (at your option) any later version.                         *\n *                                                                          *\n *  DMTCP:dmtcp/src is distributed in the hope that it will be useful,      *\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of          *\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *\n *  GNU Lesser General Public License for more details.                     *\n *                                                                          *\n *  You should have received a copy of the GNU Lesser General Public        *\n *  License along with DMTCP:dmtcp/src.  If not, see                        *\n *  <http://www.gnu.org/licenses/>.                                         *\n ****************************************************************************/\n\n#ifndef PIDWRAPPERS_H\n#define PIDWRAPPERS_H\n\n#ifndef _GNU_SOURCE\n#define _GNU_SOURCE\n#endif\n\n// FIXME:  Why are we adding all these includes here, if we're declaring\n//         only our own _real_XXX() functions?  Some *wrappers.cpp files\n//         use these includes.  But, then we should split up these includes\n//         among the individual *wrappers.cpp files that actually need them,\n//         and not declare every possible include in one giant .h file.\n#include <sched.h>\n#include <stdio.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <signal.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <sys/ptrace.h>\n#include <linux/version.h>\n#include \"config.h\"\n// To support CMA (Cross Memory Attach)\n#ifdef HAS_CMA\n# include <sys/uio.h>\n#endif\n// This was needed for 64-bit SUSE LINUX Enterprise Server 9 (Linux 2.6.5):\n#ifndef PTRACE_GETEVENTMSG\n# include <sys/ptrace.h>\n#endif\n#include <stdarg.h>\n#if defined(__arm__) || defined(__aarch64__)\nstruct user_desc {int dummy;}; /* <asm/ldt.h> is missing in Ubuntu 14.04 */\n#else\n# include <asm/ldt.h> // Needed for 'struct user_desc' (arg 6 of __clone)\n#endif\n#include <stdio.h>\n#include <thread_db.h>\n#include <sys/procfs.h>\n#include <syslog.h>\n#include <sys/ipc.h>\n#include <sys/shm.h>\n#include <sys/sem.h>\n// FIXME:   We define _real_msgctl() in terms of msgctl() here.  So,\n//          we need sys/msg.h.  But sys/msg.h also declares msgrcv().\n//          SLES 10 declares msgrcv() one way, and others define it differently.\n//          So, we need this patch.  Do we really need msgctl() defined here?\n//          (pidwrappers.cpp doesn't use msgctl().)\n// msgrcv has conflicting return types on some systems (e.g. SLES 10)\n// So, we temporarily rename it so that type declarations are not for msgrcv.\n#define msgrcv msgrcv_glibc\n# include <sys/msg.h>\n#undef msgrcv\n#include <sys/stat.h>\n#include <sys/mman.h>\n#include <sys/epoll.h>\n#include <dirent.h>\n#include <unistd.h>\n#include <pwd.h>\n#include <grp.h>\n#include <netdb.h>\n#include <mqueue.h>\n\n#include \"dmtcp.h\"\n\n// Keep in sync with dmtcp/src/constants.h\n#define ENV_VAR_VIRTUAL_PID \"DMTCP_VIRTUAL_PID\"\n\n#ifdef __cplusplus\nextern \"C\"\n{\n#endif\n\n  union semun {\n    int              val;    /* Value for SETVAL */\n    struct semid_ds *buf;    /* Buffer for IPC_STAT, IPC_SET */\n    unsigned short  *array;  /* Array for GETALL, SETALL */\n    struct seminfo  *__buf;  /* Buffer for IPC_INFO (Linux-specific) */\n  };\n\n  void dmtcpResetPidPpid();\n  void dmtcpResetTid(pid_t tid);\n\n  LIB_PRIVATE void *_real_dlsym(void *handle, const char *symbol);\n\n/* The following function are defined in pidwrappers.cpp */\n  LIB_PRIVATE pid_t dmtcp_gettid();\n  LIB_PRIVATE int dmtcp_tkill(int tid, int sig);\n  LIB_PRIVATE int dmtcp_tgkill(int tgid, int tid, int sig);\n\n#define FOREACH_PIDVIRT_WRAPPER(MACRO)\\\n  MACRO(fork)               \\\n  MACRO(__clone)            \\\n  MACRO(gettid)             \\\n  MACRO(tkill)              \\\n  MACRO(tgkill)             \\\n  MACRO(syscall)            \\\n  MACRO(shmget)             \\\n  MACRO(shmat)              \\\n  MACRO(shmdt)              \\\n  MACRO(mq_notify)          \\\n  MACRO(clock_getcpuclockid)\\\n  MACRO(timer_create)       \\\n  MACRO(getppid)            \\\n  MACRO(tcgetsid)           \\\n  MACRO(tcgetpgrp)          \\\n  MACRO(tcsetpgrp)          \\\n  MACRO(getpgrp)            \\\n  MACRO(setpgrp)            \\\n  MACRO(getpgid)            \\\n  MACRO(setpgid)            \\\n  MACRO(getsid)             \\\n  MACRO(setsid)             \\\n  MACRO(kill)               \\\n  MACRO(wait)               \\\n  MACRO(waitpid)            \\\n  MACRO(waitid)             \\\n  MACRO(wait3)              \\\n  MACRO(wait4)              \\\n  MACRO(ioctl)              \\\n  MACRO(setgid)             \\\n  MACRO(setuid)             \\\n  MACRO(ptrace )            \\\n  MACRO(pthread_exit )      \\\n  MACRO(fcntl)              \\\n  MACRO(open)               \\\n  MACRO(open64)             \\\n  MACRO(close)              \\\n  MACRO(dup2)               \\\n  MACRO(fopen64)            \\\n  MACRO(opendir)            \\\n  MACRO(__xstat)            \\\n  MACRO(__xstat64)          \\\n  MACRO(__lxstat)           \\\n  MACRO(__lxstat64)         \\\n  MACRO(readlink)\n\n#define FOREACH_SYSVIPC_CTL_WRAPPER(MACRO)\\\n  MACRO(shmctl)             \\\n  MACRO(semctl)             \\\n  MACRO(msgctl)\n\n#define FOREACH_FOPEN_WRAPPER(MACRO)\\\n  MACRO(fopen)              \\\n  MACRO(fclose)\n\n#define FOREACH_SCHED_WRAPPER(MACRO)\\\n  MACRO(sched_setaffinity) \\\n  MACRO(sched_getaffinity)  \\\n  MACRO(sched_setscheduler) \\\n  MACRO(sched_getscheduler) \\\n  MACRO(sched_setparam) \\\n  MACRO(sched_getparam) \\\n  MACRO(sched_setattr) \\\n  MACRO(sched_getattr)\n\n#ifdef HAS_CMA\n# define FOREACH_CMA_WRAPPER(MACRO)\\\n   MACRO(process_vm_readv)   \\\n   MACRO(process_vm_writev)\n#endif\n\n# define PIDVIRT_ENUM(x) pid_enum_ ## x\n# define PIDVIRT_GEN_ENUM(x) PIDVIRT_ENUM(x),\n  typedef enum {\n    FOREACH_PIDVIRT_WRAPPER(PIDVIRT_GEN_ENUM)\n    FOREACH_SYSVIPC_CTL_WRAPPER(PIDVIRT_GEN_ENUM)\n    FOREACH_FOPEN_WRAPPER(PIDVIRT_GEN_ENUM)\n    FOREACH_SCHED_WRAPPER(PIDVIRT_GEN_ENUM)\n#ifdef HAS_CMA\n    FOREACH_CMA_WRAPPER(PIDVIRT_GEN_ENUM)\n#endif\n    numPidVirtWrappers\n  } PidVirtWrapperOffset;\n\n  pid_t _real_fork();\n  int _real_clone ( int ( *fn ) ( void *arg ), void *child_stack, int flags,\n                    void *arg, int *parent_tidptr, struct user_desc *newtls,\n                    int *child_tidptr );\n\n  pid_t _real_gettid(void);\n  int   _real_tkill(int tid, int sig);\n  int   _real_tgkill(int tgid, int tid, int sig);\n\n  long int _real_syscall(long int sys_num, ... );\n\n  /* System V shared memory */\n  int _real_shmget(key_t key, size_t size, int shmflg);\n  void* _real_shmat(int shmid, const void *shmaddr, int shmflg);\n  int _real_shmdt(const void *shmaddr);\n  int _real_shmctl(int shmid, int cmd, struct shmid_ds *buf);\n  int _real_semctl(int semid, int semnum, int cmd, ...);\n  int _real_msgctl(int msqid, int cmd, struct msqid_ds *buf);\n  int _real_mq_notify(mqd_t mqdes, const struct sigevent *sevp);\n  int _real_clock_getcpuclockid(pid_t pid, clockid_t *clock_id);\n  int _real_timer_create(clockid_t clockid,\n                         struct sigevent *sevp,\n                         timer_t *timerid);\n\n  pid_t _real_getpid(void);\n  pid_t _real_getppid(void);\n\n  pid_t _real_tcgetsid(int fd);\n  pid_t _real_tcgetpgrp(int fd);\n  int   _real_tcsetpgrp(int fd, pid_t pgrp);\n\n  pid_t _real_getpgrp(void);\n  pid_t _real_setpgrp(void);\n\n  pid_t _real_getpgid(pid_t pid);\n  int   _real_setpgid(pid_t pid, pid_t pgid);\n\n  pid_t _real_getsid(pid_t pid);\n  pid_t _real_setsid(void);\n\n  int   _real_kill(pid_t pid, int sig);\n\n  pid_t _real_wait(__WAIT_STATUS stat_loc);\n  pid_t _real_waitpid(pid_t pid, int *stat_loc, int options);\n  int   _real_waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);\n\n  pid_t _real_wait3(__WAIT_STATUS status, int options, struct rusage *rusage);\n  pid_t _real_wait4(pid_t pid, __WAIT_STATUS status, int options,\n                    struct rusage *rusage);\n  LIB_PRIVATE extern int send_sigwinch;\n  int _real_ioctl(int d,  unsigned long int request, ...) __THROW;\n\n  int _real_setgid(gid_t gid);\n  int _real_setuid(uid_t uid);\n\n  long _real_ptrace ( enum __ptrace_request request, pid_t pid, void *addr,\n                    void *data);\n\n  void _real_pthread_exit (void *retval);\n  int _real_fcntl(int fd, int cmd, void *arg);\n\n  int _real_open(const char *pathname, int flags, ...);\n  int _real_open64(const char *pathname, int flags, ...);\n  int _real_close(int fd);\n  int _real_dup2(int fd1, int fd2);\n  FILE* _real_fopen(const char *path, const char *mode);\n  FILE* _real_fopen64(const char *path, const char *mode);\n  int _real_fclose(FILE *fp);\n  DIR* _real_opendir(const char* name);\n  int _real_xstat(int vers, const char *path, struct stat *buf);\n  int _real_xstat64(int vers, const char *path, struct stat64 *buf);\n  int _real_lxstat(int vers, const char *path, struct stat *buf);\n  int _real_lxstat64(int vers, const char *path, struct stat64 *buf);\n  ssize_t _real_readlink(const char *path, char *buf, size_t bufsiz);\n#ifdef HAS_CMA\n  ssize_t _real_process_vm_readv(pid_t pid,\n                                 const struct iovec *local_iov,\n                                 unsigned long liovcnt,\n                                 const struct iovec *remote_iov,\n                                 unsigned long riovcnt,\n                                 unsigned long flags);\n  ssize_t _real_process_vm_writev(pid_t pid,\n                                  const struct iovec *local_iov,\n                                  unsigned long liovcnt,\n                                  const struct iovec *remote_iov,\n                                  unsigned long riovcnt,\n                                  unsigned long flags);\n#endif\n\n  int _real_sched_setaffinity(pid_t pid, size_t cpusetsize, const cpu_set_t *mask);\n  int _real_sched_getaffinity(pid_t pid, size_t cpusetsize, cpu_set_t *mask);\n  int _real_sched_setscheduler(pid_t pid, int policy, const struct sched_param *param);\n  int _real_sched_getscheduler(pid_t pid);\n  int _real_sched_setparam(pid_t pid, const struct sched_param *param);\n  int _real_sched_getparam(pid_t pid, struct sched_param *param);\n#if 0\n  int _real_sched_setattr(pid_t pid, const struct sched_attr *attr, unsigned int flags);\n  int _real_sched_getattr(pid_t pid, const struct sched_attr *attr, unsigned int size, unsigned int flags);\n#endif\n\n#ifdef __cplusplus\n}\n#endif\n\n#endif\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/src/plugin/pid/pid.h": "#include \"dmtcp.h\"\n\n// Defines NEXT_FNC_DEFAULT\n// Needed to handle GNU symbol versioning.\n#include \"dmtcp_dlsym.h\"\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/src/plugin/pid/pid_mutexwrappers.cpp": "#include <stdlib.h>\n#include <unistd.h>\n#include <stdio.h>\n#include <pthread.h>\n#include <time.h>\n#include <syscall.h>\n#include <sys/types.h>\n#include <vector>\n#include <cassert>\n\n#include \"jassert.h\"\n#include \"pidwrappers.h\"\n#include \"dmtcp_dlsym.h\" // for NEXT_FNC_DEFAULT macro\n\n#define __real_pthread_mutex_lock       NEXT_FNC(pthread_mutex_lock)\n#define __real_pthread_mutex_trylock    NEXT_FNC(pthread_mutex_trylock)\n#define __real_pthread_mutex_timedlock  NEXT_FNC(pthread_mutex_timedlock)\n#define __real_pthread_mutex_unlock     NEXT_FNC(pthread_mutex_unlock)\n#define __real_pthread_mutex_consistent NEXT_FNC(pthread_mutex_consistent)\n\n// For explanation why we need NEXT_FNC_DEFAULT see [1]\n#define __real_pthread_cond_wait        NEXT_FNC_DEFAULT(pthread_cond_wait)\n#define __real_pthread_cond_timedwait   NEXT_FNC_DEFAULT(pthread_cond_timedwait)\n\n// |=-------------------------------=[ GOAL ]=--------------------------------=|\n//\n// Record mutex ownership to support checkpointing and restoring of locked\n// mutex objects.\n// This is specific to glibc's NPTL, which encodes mutex ownership through the\n// real TID. Since the real TID changes on restore, this owner field must be\n// patched in 'struct pthread_mutex_t' after restore.\n//\n//\n// |=-----------------------------=[ ALGORITHM ]=-----------------------------=|\n//\n// In the case where a thread acquires a mutex, we record the mutex handle\n// with the corresponding virtual TID of the locking thread.\n// Once a mutex gets unlocked we remove the reference to the mutex.\n//\n// On restore, we go over all the recorded entries and look up the new TID that\n// corresponds to the recorded virtual TID for the mutex handle. We use this\n// new TID to patch the owner in the mutex object (following the mutex handle).\n//\n// Robust mutex objects need some special treatment. Therefore, see the\n// ROBUST MUTEX background and the annotations in the code below.\n//\n//\n// |=---------------------------=[ ROBUST MUTEX ]=----------------------------=|\n//\n// pthread_mutex_*lock()\n//   If the mutex is a robust mutex\n//   (pthread_mutex_setrobust(PTHREAD_MUTEX_ROBUST)), attempts to lock the mutex\n//   can return EOWNERDEAD. This is the case if the owner dies without unlocking\n//   the mutex.\n//   The thread receiving the return value EOWNERDEAD has the lock. However the\n//   mutex is marked as inconsistent (PTHREAD_MUTEX_INCONSISTENT) and the thread\n//   is not the owner. The thread needs to call pthread_mutex_consistent() to\n//   make itself the owner of the mutex.\n//\n//   It is the application's responsibility to recover the mutex after receiving\n//   EOWNERDEAD. If the application can't recover the mutex, it needs to call\n//   pthread_mutex_unlock(), which marks the mutex as notrecoverable\n//   (PTHREAD_MUTEX_NOTRECOVERABLE).\n//\n//\n// |=------------------------=[ CONDITION VARIABLE ]=-------------------------=|\n//\n// From 'man 3p pthread_cond_wait'\n//   pthread_cond_timedwait() and pthread_cond_wait() ... shall be called with\n//   mutex locked by the calling thread or undefined behavior results.\n//\n//   These functions atomically release mutex and cause the calling thread to\n//   block on the condition variable ...\n//\n//   Upon successful return, the mutex shall have been locked and shall be\n//   owned by the calling thread.\n//\n// Putting this words from the man page into a picture, we get the following:\n//\n//          Th1                      Th2\n//         -----                    -----\n//           |                        |\n//      lock mutex (M)                |             /// Th1 owns mutex M.\n//           |                        |\n//   wait for cond (C,M) ->           |             /// Th1 unlocks mutex M\n//           |                        |             /// when waiting for cond C.\n//           |                        |\n//           |                 lock mutex (M)       /// Th2 owns mutex M.\n//           |                        |\n//           |                  fire cond (C)\n//           |                unlock mutex (M)\n//           |                        |\n//   wait for cond (C,M) <-           |             /// Th1 owns mutex M\n//           |                        |             /// after return from\n//          ...                      ...            /// wait for cond C.\n//\n// As the pthread_cond_wait(3p)/pthread_cond_timedwait(3p) APIs don't go through\n// the public pthread_mutex_* APIs to lock the mutex once the condition variable\n// has been fired, we explicitly need to update the entry in our ownernership\n// record for the mutex which is associated with the condition variable.\n\n\n/* Globals structs */\n/* This maps mutex addresses to the virtual tid of the owner thread.\n * STL map isn't thread-safe. We use an adaptive mutex to guard modification of\n * this map, since the time of holding the lock should be very short.\n */\ndmtcp::map<pthread_mutex_t*, pid_t>& mapMutexVirtTid();\n\nnamespace {\n  // Mutex to protect access to mapMutexVirtTid\n  pthread_mutex_t mutex_mapMutexVirtTid =\n    PTHREAD_ADAPTIVE_MUTEX_INITIALIZER_NP;\n\n  struct ScopedMutex_mapMutexVirtTid {\n    ScopedMutex_mapMutexVirtTid() {\n      assert(__real_pthread_mutex_lock(&mutex_mapMutexVirtTid) == 0);\n    }\n    ~ScopedMutex_mapMutexVirtTid() {\n      assert(__real_pthread_mutex_unlock(&mutex_mapMutexVirtTid) == 0);\n    }\n  };\n\n  inline void follow_mutex(pthread_mutex_t* mutex) {\n    ScopedMutex_mapMutexVirtTid lock;\n    mapMutexVirtTid()[mutex] = dmtcp_gettid();\n  }\n\n  inline void unfollow_mutex(pthread_mutex_t* mutex) {\n    // We only remove the entry if we are the last recorded owner. This is\n    // necessary to solve the potential modification race condition after\n    // returning from pthread_mutex_lock() and pthread_mutex_unlock()\n    // library calls.\n    //\n    //          Th1                            Th2\n    //         -----                          -----\n    //           |                              |\n    //         lock M                           |\n    //           |                              |\n    //          ...                             |\n    //           |                            lock M  <- blocking\n    //        unlock M                          |\n    //           |                              |\n    //      return from                    return from\n    //  pthread_mutex_unlock            pthread_mutex_lock\n    //     delegate call                  delegate call\n    //           \\                              /\n    //     in the wrapper functions both threads race to get\n    //         mutex_mapMutexVirtTid and modify the map\n    //\n    // Case 1: Th1 gets mutex_mapMutexVirtTid first\n    //   Th1 removes the entry from the map and Th2 adds the entry with the\n    //   correct ownership.\n    //\n    // Case 2: Th2 gets mutex_mapMutexVirtTid first\n    //   Th2 updates the entry with itself as the new owner (which is the\n    //   correct state after returning from pthread_mutex_lock), but then Th1\n    //   comes and removes the entry resulting in a faulty state.\n\n    ScopedMutex_mapMutexVirtTid lock;\n    dmtcp::map<pthread_mutex_t*, pid_t>::iterator it =\n      mapMutexVirtTid().find(mutex);\n    if (it != mapMutexVirtTid().end() && it->second == dmtcp_gettid()) {\n        mapMutexVirtTid().erase(it);\n    }\n  }\n\n  inline void post_lock(int ret, pthread_mutex_t* mutex) {\n    if ((ret == 0 || ret == EOWNERDEAD)\n        && dmtcp_is_running_state()) {\n      if (ret == 0) {\n        follow_mutex(mutex);\n      } else if (ret == EOWNERDEAD) {\n        // Mutex owner died or the mutex was marked inconsistent by the owner.\n        // We acquire the lock but we are not the owner of the mutex now.\n        // If the application can recover the Mutex state it needs to call\n        // pthread_mutex_consistent(). In that case we follow the mutex again.\n        // For details, see above in ROBUST MUTEX explanation\n        unfollow_mutex(mutex);\n      }\n    }\n  }\n}\n\nextern \"C\" int pthread_mutex_lock(pthread_mutex_t *mutex) {\n  int rc;\n\n  rc = __real_pthread_mutex_lock(mutex);\n  post_lock(rc, mutex);\n\n  return rc;\n}\n\nextern \"C\" int pthread_mutex_trylock(pthread_mutex_t *mutex) {\n  int rc;\n\n  rc = __real_pthread_mutex_trylock(mutex);\n  post_lock(rc, mutex);\n\n  return rc;\n}\n\nextern \"C\" int pthread_mutex_timedlock(pthread_mutex_t *mutex,\n                                       const struct timespec * abs_timeout) {\n  int rc;\n\n  rc = __real_pthread_mutex_timedlock(mutex, abs_timeout);\n  post_lock(rc, mutex);\n\n  return rc;\n}\n\nextern \"C\" int pthread_mutex_consistent(pthread_mutex_t *mutex) {\n  int rc;\n\n  rc = __real_pthread_mutex_consistent(mutex);\n  if (rc == 0 && dmtcp_is_running_state()) {\n    follow_mutex(mutex);\n  }\n\n  return rc;\n}\n\nextern \"C\" int pthread_mutex_unlock(pthread_mutex_t *mutex) {\n  int rc;\n\n  rc = __real_pthread_mutex_unlock(mutex);\n  if (rc == 0\n     // FIXME:\n     // Potential issue in future: We use glibc internals and assume the mutex\n     // is not owned anymore when the __owner is set to '0'.\n     //\n     // There is a race condition here. When we return from unlock\n     // and some other thread directly locks the mutex, then __owner\n     // might be !=0. However it is okay here to not remove the entry,\n     // since the other thread records itself as the owner.\n     && mutex->__data.__owner == 0) {\n    unfollow_mutex(mutex);\n  }\n\n  return rc;\n}\n\nextern \"C\" int pthread_cond_wait(pthread_cond_t* cond, pthread_mutex_t* mutex) {\n  int rc;\n\n  // pthread_cond_wait will unlock the mutex, but we skip unfollowing for\n  // simplicity & runtime performance and in case we checkpoint while waiting\n  // in pthread_cond_wait we build on the __owner==0 check on restore\n\n  rc = __real_pthread_cond_wait(cond, mutex);\n  if (rc == 0 && dmtcp_is_running_state()) {\n    follow_mutex(mutex);\n  }\n\n  return rc;\n}\n\nextern \"C\" int pthread_cond_timedwait(pthread_cond_t* cond,\n                                      pthread_mutex_t* mutex,\n                                      const struct timespec* abstime) {\n  int rc;\n\n  // pthread_cond_timedwait will unlock the mutex, but we skip unfollowing for\n  // simplicity & runtime performance and in case we checkpoint while waiting\n  // in pthread_cond_wait we build on the __owner==0 check on restore\n\n  rc = __real_pthread_cond_timedwait(cond, mutex, abstime);\n  // Even the call timed out we have the lock and own the mutex.\n  if ((rc == 0 || rc == ETIMEDOUT) && dmtcp_is_running_state()) {\n    follow_mutex(mutex);\n  }\n\n  return rc;\n}\n\n// [1] NEXT_FNC_DEFAULT for pthread_cond_wait(3p)/pthread_cond_timedwait(3p)\n// ----------------------------------------------------------------------------\n//\n// glibc provides two different implementations for these functions, one\n// for LinuxThreads and one for POSIX Threads. A dlsym lookup would return a\n// function pointer to the oldest symbol defined which in this case is the\n// implementation for LinuxThreads.\n//\n// What's behind that magic is glibc's symbol versioning.\n//   nm /lib64/libpthread.so.0 | grep pthread_cond_wait\n//     000000000000c140 T pthread_cond_wait@GLIBC_2.2.5\n//     000000000000b5c0 T pthread_cond_wait@@GLIBC_2.3.2\n// where in this case the symbol with version 2.2.5 is the LinuxThread\n// implementation and the symbol with version 2.3.2 is the POSIX Thread\n// implementation.\n//\n// A symbol that has the '@@' tag in its version information is declared as\n// the default symbol for that library. Programs that link against this library\n// will be linked against the default version of the symbol.\n// This can be seen by executing the following snippet on the cmd line:\n//   echo \"\n//   #include <pthread.h>\n//   void foo() { pthread_cond_wait(0,0); }\n//   void main() {}\" |\n//   gcc -O2 -o tmp.o -xc -lpthread -; nm tmp.o | grep pthread_cond_wait;\n//     rm -f tmp.o\n// which returns:\n//   U pthread_cond_wait@@GLIBC_2.3.2\n//\n// It is important that even '@@' denotes the default symbol, this is only true\n// for programs that link directly against the library, not for lookups done\n// with dlsym(3).\n// dlsym(3) makes an \"unversioned\" lookup for the symbol, which by default will\n// match the oldest symbol version in the library (this is because glibc\n// guarantees strong runtime backwards compatibility!).\n//\n// Since this implementation handles POSIX mutexes & condition variables we want\n// to delegate to the POSIX Thread implemenation from our wrapper functions\n// for pthread_cond_*wait(3p).\n// As these are the default version for that symbols we use the\n// NEXT_FNC_DEFAULT macro provided by dmtcp to find the next \"default\" symbol\n// in the link map chain.\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/src/plugin/pid/pid_syscallsreal.c": "/****************************************************************************\n *   Copyright (C) 2006-2013 by Jason Ansel, Kapil Arya, and Gene Cooperman *\n *   jansel@csail.mit.edu, kapil@ccs.neu.edu, gene@ccs.neu.edu              *\n *                                                                          *\n *   This file is part of the dmtcp/src module of DMTCP (DMTCP:dmtcp/src).  *\n *                                                                          *\n *  DMTCP:dmtcp/src is free software: you can redistribute it and/or        *\n *  modify it under the terms of the GNU Lesser General Public License as   *\n *  published by the Free Software Foundation, either version 3 of the      *\n *  License, or (at your option) any later version.                         *\n *                                                                          *\n *  DMTCP:dmtcp/src is distributed in the hope that it will be useful,      *\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of          *\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *\n *  GNU Lesser General Public License for more details.                     *\n *                                                                          *\n *  You should have received a copy of the GNU Lesser General Public        *\n *  License along with DMTCP:dmtcp/src.  If not, see                        *\n *  <http://www.gnu.org/licenses/>.                                         *\n ****************************************************************************/\n\n\n#define _GNU_SOURCE\n#define _XOPEN_SOURCE 500\n// These next two are defined in features.h based on the user macros above.\n// #define GNU_SRC\n// #define __USE_UNIX98\n#include <dlfcn.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/syscall.h>\n#include <unistd.h>\n#include \"pidwrappers.h\"\n#include \"dmtcp_dlsym.h\"\n\n#include \"config.h\" // for HAS_CMA\n\ntypedef int ( *funcptr_t ) ();\ntypedef pid_t ( *funcptr_pid_t ) ();\ntypedef funcptr_t ( *signal_funcptr_t ) ();\ntypedef void* (*dlsym_fnptr_t) (void *handle, const char *symbol);\n\nstatic void *pid_real_func_addr[numPidVirtWrappers];\nstatic int pid_wrappers_initialized = 0;\n\n#define GET_FUNC_ADDR(name) \\\n  pid_real_func_addr[PIDVIRT_ENUM(name)] = _real_dlsym(RTLD_NEXT, #name);\n\n#define GET_FUNC_ADDR_V(name, v) \\\n  pid_real_func_addr[PIDVIRT_ENUM(name)] = dmtcp_dlvsym(RTLD_NEXT, #name, v); \\\n  if (pid_real_func_addr[PIDVIRT_ENUM(name)] == NULL) { \\\n    /* Symbol version not found, try the default and hope for the best */ \\\n    GET_FUNC_ADDR(name); \\\n  }\n\n#ifdef __i386__\n// On 32-bit Linuxes, glibc provides two versions (GLIBC_2.0 and GLIBC_2.2) for\n// semctl, msgctl and shmctl. dlsym(RTLD_NEXT, ...) returns the address of the\n// GLIBC_2.0 version, whereas we need the GLIBC_2.2 version. In 64-bit glibc,\n// there is only one version.\n// Similarly, for fopen/fclose/fdopen, there is a GLIBC_2.1 in addition to\n// GLIBC_2.0 version.\n# define GET_SYSVIPC_CTL_FUNC_ADDR(name) GET_FUNC_ADDR_V(name, \"GLIBC_2.2\")\n# define GET_FOPEN_FUNC_ADDR(name) GET_FUNC_ADDR_V(name, \"GLIBC_2.1\")\n#else\n# define GET_SYSVIPC_CTL_FUNC_ADDR(name) GET_FUNC_ADDR(name)\n# define GET_FOPEN_FUNC_ADDR(name) GET_FUNC_ADDR(name)\n#endif\n\nLIB_PRIVATE\nvoid pid_initialize_wrappers()\n{\n  if (!pid_wrappers_initialized) {\n    FOREACH_PIDVIRT_WRAPPER(GET_FUNC_ADDR);\n    FOREACH_SYSVIPC_CTL_WRAPPER(GET_SYSVIPC_CTL_FUNC_ADDR);\n    FOREACH_FOPEN_WRAPPER(GET_FOPEN_FUNC_ADDR);\n    FOREACH_SCHED_WRAPPER(GET_FUNC_ADDR);\n#if HAS_CMA\n    FOREACH_CMA_WRAPPER(GET_FUNC_ADDR);\n#endif\n    pid_wrappers_initialized = 1;\n  }\n}\n\n\n#define REAL_FUNC_PASSTHROUGH_WORK(name) \\\n  if (fn == NULL) { \\\n    if (pid_real_func_addr[PIDVIRT_ENUM(name)] == NULL) \\\n      pid_initialize_wrappers(); \\\n    fn = pid_real_func_addr[PIDVIRT_ENUM(name)]; \\\n    if (fn == NULL) { \\\n      fprintf(stderr, \"%s:%d: *** DMTCP: Error: lookup failed for %s.\\n\" \\\n                      \"           The symbol wasn't found in current library\" \\\n                      \" loading sequence.\\n\" \\\n                      \"    Aborting.\\n\", __FILE__, __LINE__, #name); \\\n      abort(); \\\n    } \\\n  }\n\n#define REAL_FUNC_PASSTHROUGH(name)  REAL_FUNC_PASSTHROUGH_TYPED(int, name)\n\n#define REAL_FUNC_PASSTHROUGH_TYPED(type,name) \\\n  static type (*fn)() = NULL;                  \\\n  REAL_FUNC_PASSTHROUGH_WORK(name)             \\\n  return (*fn)\n\n#define REAL_FUNC_PASSTHROUGH_VOID(name) \\\n  static void (*fn)() = NULL;            \\\n  REAL_FUNC_PASSTHROUGH_WORK(name)       \\\n  (*fn)\n\n#define REAL_FUNC_PASSTHROUGH_NORETURN(name)                 \\\n  static void (*fn)() __attribute__ ((__noreturn__)) = NULL; \\\n  REAL_FUNC_PASSTHROUGH_WORK(name)                           \\\n  (*fn)\n\nvoid *dmtcp_get_libc_dlsym_addr();\n\nLIB_PRIVATE\nvoid *_real_dlsym ( void *handle, const char *symbol ) {\n  static dlsym_fnptr_t _libc_dlsym_fnptr = NULL;\n  if (_libc_dlsym_fnptr == NULL) {\n    _libc_dlsym_fnptr = (dlsym_fnptr_t) dmtcp_dlsym;\n  }\n\n  return (void*) (*_libc_dlsym_fnptr) ( handle, symbol );\n}\n\n// Also copied into src/threadlist.cpp, so that libdmtcp.sp\n//   won't depend on libdmtcp_pid.sp\nLIB_PRIVATE\npid_t _real_getpid(void){\n  // libc caches pid of the process and hence after restart, libc:getpid()\n  // returns the pre-ckpt value.\n  return (pid_t) _real_syscall(SYS_getpid);\n}\n\nLIB_PRIVATE\npid_t _real_getppid(void){\n  // libc caches ppid of the process and hence after restart, libc:getppid()\n  // returns the pre-ckpt value.\n  return (pid_t) _real_syscall(SYS_getppid);\n}\n\nLIB_PRIVATE\npid_t _real_tcgetsid(int fd){\n  REAL_FUNC_PASSTHROUGH ( tcgetsid ) ( fd );\n}\n\nLIB_PRIVATE\nint _real_tcsetpgrp(int fd, pid_t pgrp){\n  REAL_FUNC_PASSTHROUGH ( tcsetpgrp ) ( fd, pgrp );\n}\n\nLIB_PRIVATE\npid_t _real_tcgetpgrp(int fd) {\n  REAL_FUNC_PASSTHROUGH ( tcgetpgrp ) ( fd );\n}\n\nLIB_PRIVATE\npid_t _real_getpgrp(void) {\n  REAL_FUNC_PASSTHROUGH_TYPED ( pid_t, getpgrp ) ( );\n}\n\nLIB_PRIVATE\npid_t _real_setpgrp(void) {\n  REAL_FUNC_PASSTHROUGH_TYPED ( pid_t, setpgrp ) ( );\n}\n\nLIB_PRIVATE\npid_t _real_getpgid(pid_t pid) {\n  REAL_FUNC_PASSTHROUGH_TYPED ( pid_t, getpgid ) ( pid );\n}\n\nLIB_PRIVATE\nint   _real_setpgid(pid_t pid, pid_t pgid) {\n  REAL_FUNC_PASSTHROUGH ( setpgid ) ( pid, pgid );\n}\n\nLIB_PRIVATE\npid_t _real_getsid(pid_t pid) {\n  REAL_FUNC_PASSTHROUGH_TYPED ( pid_t, getsid ) ( pid );\n}\n\nLIB_PRIVATE\npid_t _real_setsid(void) {\n  REAL_FUNC_PASSTHROUGH_TYPED ( pid_t, setsid ) ( );\n}\n\nLIB_PRIVATE\nint   _real_kill(pid_t pid, int sig) {\n  REAL_FUNC_PASSTHROUGH ( kill ) ( pid, sig );\n}\n\nLIB_PRIVATE\npid_t _real_wait(__WAIT_STATUS stat_loc) {\n  REAL_FUNC_PASSTHROUGH_TYPED ( pid_t, wait ) ( stat_loc );\n}\n\nLIB_PRIVATE\npid_t _real_waitpid(pid_t pid, int *stat_loc, int options) {\n  REAL_FUNC_PASSTHROUGH_TYPED ( pid_t, waitpid ) ( pid, stat_loc, options );\n}\n\nLIB_PRIVATE\nint   _real_waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options) {\n  REAL_FUNC_PASSTHROUGH ( waitid ) ( idtype, id, infop, options );\n}\n\nLIB_PRIVATE\npid_t _real_wait3(__WAIT_STATUS status, int options, struct rusage *rusage) {\n  REAL_FUNC_PASSTHROUGH_TYPED ( pid_t, wait3 ) ( status, options, rusage );\n}\n\nLIB_PRIVATE\npid_t _real_wait4(pid_t pid, __WAIT_STATUS status, int options, struct rusage *rusage) {\n  REAL_FUNC_PASSTHROUGH_TYPED ( pid_t, wait4 ) ( pid, status, options, rusage );\n}\n\nLIB_PRIVATE\nint _real_ioctl(int d, unsigned long int request, ...) {\n  void * arg;\n  va_list ap;\n\n  // Most calls to ioctl take 'void *', 'int' or no extra argument\n  // A few specialized ones take more args, but we don't need to handle those.\n  va_start(ap, request);\n  arg = va_arg(ap, void *);\n  va_end(ap);\n\n  // /usr/include/unistd.h says syscall returns long int (contrary to man page)\n  REAL_FUNC_PASSTHROUGH_TYPED ( int, ioctl ) ( d, request, arg );\n}\n\nLIB_PRIVATE\nint _real_setgid(gid_t gid) {\n  REAL_FUNC_PASSTHROUGH( setgid ) (gid);\n}\n\nLIB_PRIVATE\nint _real_setuid(uid_t uid) {\n  REAL_FUNC_PASSTHROUGH( setuid ) (uid);\n}\n\nLIB_PRIVATE\nlong _real_ptrace(enum __ptrace_request request, pid_t pid, void *addr,\n                  void *data) {\n  REAL_FUNC_PASSTHROUGH_TYPED ( long, ptrace ) ( request, pid, addr, data );\n}\n\n// gettid / tkill / tgkill are not defined in libc.\nLIB_PRIVATE\npid_t _real_gettid(void){\n  // No glibc wrapper for gettid, although even if it had one, we would have\n  // the issues similar to getpid/getppid().\n  return (pid_t) _real_syscall(SYS_gettid);\n}\n\nLIB_PRIVATE\nint   _real_tkill(int tid, int sig) {\n  // No glibc wrapper for tkill, although even if it had one, we would have\n  // the issues similar to getpid/getppid().\n  return (int) _real_syscall(SYS_tkill, tid, sig);\n}\n\nLIB_PRIVATE\nint   _real_tgkill(int tgid, int tid, int sig) {\n  // No glibc wrapper for tgkill, although even if it had one, we would have\n  // the issues similar to getpid/getppid().\n  return (int) _real_syscall(SYS_tgkill, tgid, tid, sig);\n}\n\nLIB_PRIVATE\nlong _real_syscall(long sys_num, ... ) {\n  int i;\n  void * arg[7];\n  va_list ap;\n\n  va_start(ap, sys_num);\n  for (i = 0; i < 7; i++)\n    arg[i] = va_arg(ap, void *);\n  va_end(ap);\n\n  // /usr/include/unistd.h says syscall returns long int (contrary to man page)\n  REAL_FUNC_PASSTHROUGH_TYPED ( long, syscall ) (sys_num, arg[0], arg[1],\n                                                 arg[2], arg[3], arg[4],\n                                                 arg[5], arg[6] );\n}\n\nLIB_PRIVATE\npid_t _real_fork() {\n  REAL_FUNC_PASSTHROUGH_TYPED ( pid_t, fork ) ();\n}\n\nLIB_PRIVATE\nint _real_clone ( int ( *function ) (void *), void *child_stack, int flags, void *arg, int *parent_tidptr, struct user_desc *newtls, int *child_tidptr )\n{\n  REAL_FUNC_PASSTHROUGH ( __clone ) ( function, child_stack, flags, arg,\n                                      parent_tidptr, newtls, child_tidptr );\n}\n\nLIB_PRIVATE\nint _real_shmget (key_t key, size_t size, int shmflg) {\n  REAL_FUNC_PASSTHROUGH ( shmget ) (key, size, shmflg);\n}\n\nLIB_PRIVATE\nvoid* _real_shmat (int shmid, const void *shmaddr, int shmflg) {\n  REAL_FUNC_PASSTHROUGH_TYPED ( void*, shmat ) (shmid, shmaddr, shmflg);\n}\n\nLIB_PRIVATE\nint _real_shmdt (const void *shmaddr) {\n  REAL_FUNC_PASSTHROUGH ( shmdt ) (shmaddr);\n}\n\nLIB_PRIVATE\nint _real_shmctl (int shmid, int cmd, struct shmid_ds *buf) {\n  REAL_FUNC_PASSTHROUGH ( shmctl ) (shmid, cmd, buf);\n}\n\nLIB_PRIVATE\nint _real_semctl(int semid, int semnum, int cmd, ...) {\n  union semun uarg;\n  va_list arg;\n  va_start (arg, cmd);\n  uarg = va_arg (arg, union semun);\n  va_end (arg);\n  REAL_FUNC_PASSTHROUGH ( semctl ) (semid, semnum, cmd, uarg);\n}\n\nLIB_PRIVATE\nint _real_msgctl(int msqid, int cmd, struct msqid_ds *buf)\n{\n  REAL_FUNC_PASSTHROUGH (msgctl) (msqid, cmd, buf);\n}\n\nLIB_PRIVATE\nint _real_mq_notify(mqd_t mqdes, const struct sigevent *sevp) {\n  REAL_FUNC_PASSTHROUGH (mq_notify) (mqdes, sevp);\n}\n\nLIB_PRIVATE\nint _real_clock_getcpuclockid(pid_t pid, clockid_t *clock_id) {\n  REAL_FUNC_PASSTHROUGH (clock_getcpuclockid) (pid, clock_id);\n}\n\nLIB_PRIVATE\nint _real_timer_create(clockid_t clockid,\n                       struct sigevent *sevp,\n                       timer_t *timerid) {\n  REAL_FUNC_PASSTHROUGH (timer_create) (clockid, sevp, timerid);\n}\n\nLIB_PRIVATE\nvoid _real_pthread_exit (void *retval) {\n  REAL_FUNC_PASSTHROUGH_VOID ( pthread_exit ) (retval);\n}\n\nLIB_PRIVATE\nint _real_fcntl(int fd, int cmd, void *arg) {\n  REAL_FUNC_PASSTHROUGH (fcntl) (fd, cmd, arg);\n}\n\n\nint _real_open(const char *path, int flags, ...) {\n  mode_t mode = 0;\n  // Handling the variable number of arguments\n  if (flags & O_CREAT) {\n    va_list arg;\n    va_start (arg, flags);\n    mode = va_arg (arg, int);\n    va_end (arg);\n  }\n  REAL_FUNC_PASSTHROUGH(open) (path, flags, mode);\n}\n\nint _real_open64(const char *path, int flags, ...) {\n  mode_t mode = 0;\n  // Handling the variable number of arguments\n  if (flags & O_CREAT) {\n    va_list arg;\n    va_start (arg, flags);\n    mode = va_arg (arg, int);\n    va_end (arg);\n  }\n  REAL_FUNC_PASSTHROUGH(open64) (path, flags, mode);\n}\n\nLIB_PRIVATE\nint _real_close(int fd)\n{\n  REAL_FUNC_PASSTHROUGH(close) (fd);\n}\n\nLIB_PRIVATE\nint _real_dup2(int fd1, int fd2)\n{\n  REAL_FUNC_PASSTHROUGH(dup2) (fd1, fd2);\n}\n\nFILE* _real_fopen(const char *path, const char *mode) {\n  REAL_FUNC_PASSTHROUGH_TYPED(FILE*, fopen) (path, mode);\n}\n\nFILE* _real_fopen64(const char *path, const char *mode) {\n  REAL_FUNC_PASSTHROUGH_TYPED(FILE*, fopen) (path, mode);\n}\n\nint _real_fclose(FILE *fp) {\n  REAL_FUNC_PASSTHROUGH(fclose) (fp);\n}\n\nLIB_PRIVATE DIR* _real_opendir(const char* name)\n{\n  REAL_FUNC_PASSTHROUGH_TYPED(DIR*, opendir) (name);\n}\n\nint _real_xstat(int vers, const char *path, struct stat *buf) {\n  REAL_FUNC_PASSTHROUGH(__xstat) (vers, path, buf);\n}\n\nint _real_xstat64(int vers, const char *path, struct stat64 *buf) {\n  REAL_FUNC_PASSTHROUGH(__xstat64) (vers, path, buf);\n}\n\nint _real_lxstat(int vers, const char *path, struct stat *buf) {\n  REAL_FUNC_PASSTHROUGH(__lxstat) (vers, path, buf);\n}\n\nint _real_lxstat64(int vers, const char *path, struct stat64 *buf) {\n  REAL_FUNC_PASSTHROUGH(__lxstat64) (vers, path, buf);\n}\n\nssize_t _real_readlink(const char *path, char *buf, size_t bufsiz) {\n  REAL_FUNC_PASSTHROUGH(readlink) (path, buf, bufsiz);\n}\n\nLIB_PRIVATE\nint _real_sched_setaffinity(pid_t pid, size_t cpusetsize, const cpu_set_t *mask)\n{\n  REAL_FUNC_PASSTHROUGH(sched_setaffinity) (pid, cpusetsize, mask);\n}\n\nLIB_PRIVATE\nint _real_sched_getaffinity(pid_t pid, size_t cpusetsize, cpu_set_t *mask)\n{\n  REAL_FUNC_PASSTHROUGH(sched_getaffinity) (pid, cpusetsize, mask);\n}\n\nLIB_PRIVATE\nint _real_sched_setscheduler(pid_t pid, int policy, const struct sched_param *param)\n{\n  REAL_FUNC_PASSTHROUGH(sched_setscheduler) (pid, policy, param);\n}\n\nLIB_PRIVATE\nint _real_sched_getscheduler(pid_t pid)\n{\n  REAL_FUNC_PASSTHROUGH(sched_getscheduler) (pid);\n}\n\nLIB_PRIVATE\nint _real_sched_setparam(pid_t pid, const struct sched_param *param)\n{\n  REAL_FUNC_PASSTHROUGH(sched_setparam) (pid);\n}\n\nLIB_PRIVATE\nint _real_sched_getparam(pid_t pid, struct sched_param *param)\n{\n  REAL_FUNC_PASSTHROUGH(sched_getparam) (pid, param);\n}\n\n#if 0\nLIB_PRIVATE\nint _real_sched_setattr(pid_t pid, const struct sched_attr *attr, unsigned int flags)\n{\n  REAL_FUNC_PASSTHROUGH(sched_setattr) (pid, attr, flags);\n}\n\nLIB_PRIVATE\nint _real_sched_getattr(pid_t pid, const struct sched_attr *attr, unsigned int size, unsigned int flags)\n{\n  REAL_FUNC_PASSTHROUGH(sched_getattr) (pid, attr, size, flags);\n}\n#endif\n\n#if HAS_CMA\nssize_t _real_process_vm_readv(pid_t pid,\n                               const struct iovec *local_iov,\n                               unsigned long liovcnt,\n                               const struct iovec *remote_iov,\n                               unsigned long riovcnt,\n                               unsigned long flags) {\n  REAL_FUNC_PASSTHROUGH(process_vm_readv) (pid, local_iov, liovcnt,\n                                           remote_iov, riovcnt, flags);\n}\n\nssize_t _real_process_vm_writev(pid_t pid,\n                                const struct iovec *local_iov,\n                                unsigned long liovcnt,\n                                const struct iovec *remote_iov,\n                                unsigned long riovcnt,\n                                unsigned long flags) {\n  REAL_FUNC_PASSTHROUGH(process_vm_writev) (pid, local_iov, liovcnt,\n                                            remote_iov, riovcnt, flags);\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/src/plugin/svipc/sysvipcwrappers.cpp": "/****************************************************************************\n *   Copyright (C) 2006-2010 by Jason Ansel, Kapil Arya, and Gene Cooperman *\n *   jansel@csail.mit.edu, kapil@ccs.neu.edu, gene@ccs.neu.edu              *\n *                                                                          *\n *   This file is part of the dmtcp/src module of DMTCP (DMTCP:dmtcp/src).  *\n *                                                                          *\n *  DMTCP:dmtcp/src is free software: you can redistribute it and/or        *\n *  modify it under the terms of the GNU Lesser General Public License as   *\n *  published by the Free Software Foundation, either version 3 of the      *\n *  License, or (at your option) any later version.                         *\n *                                                                          *\n *  DMTCP:dmtcp/src is distributed in the hope that it will be useful,      *\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of          *\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *\n *  GNU Lesser General Public License for more details.                     *\n *                                                                          *\n *  You should have received a copy of the GNU Lesser General Public        *\n *  License along with DMTCP:dmtcp/src.  If not, see                        *\n *  <http://www.gnu.org/licenses/>.                                         *\n ****************************************************************************/\n\n// msgrcv has conflicting return types on some systems (e.g. SLES 10)\n// So, we temporarily rename it so that type declarations are not for msgrcv.\n#define msgrcv msgrcv_glibc\n\n#include <sys/ipc.h>\n#include <sys/shm.h>\n#include <stdarg.h>\n#include <sys/msg.h>\n\n#undef msgrcv\n\n#include \"dmtcp.h\"\n#include \"sysvipc.h\"\n#include \"sysvipcwrappers.h\"\n#include \"jassert.h\"\n\nusing namespace dmtcp;\n\nstatic struct timespec ts_100ms = {0, 100 * 1000 * 1000};\n\n/*\n * In OpenMPI 2.0, shmdt() is intercepted by modifying libraries' global offset\n * table, meaning that _real_shmdt() will be redirected into OpenMPI's hook\n * function, instead of libc's shmdt(). The hook function finally calls syscall()\n * with the corresponding syscall number. The inside_shmdt variable indicates\n * if the code is inside our shmdt() wrapper. If so, our syscall wrapper simply\n * calls _real_syscall(), avoiding the recursive call to the shmdt() wrapper.\n * See the wrapper of syscall() in miscwrappers.cpp and pid_miscwrappers.cpp.\n *\n * FIXME: for the long term, we need to think about the case where user code\n * modifies its own global offset table.\n *\n * */\nstatic __thread bool inside_shmdt = false;\n\n/******************************************************************************\n *\n * SysV Shm Methods\n *\n *****************************************************************************/\n\nextern \"C\"\nint shmget(key_t key, size_t size, int shmflg)\n{\n  int realId = -1;\n  int virtId = -1;\n  DMTCP_PLUGIN_DISABLE_CKPT();\n  key_t realKey = VIRTUAL_TO_REAL_SHM_KEY(key);\n  if (realKey == -1) {\n    realKey = key + dmtcp_virtual_to_real_pid(getpid());\n  }\n  realId = _real_shmget(realKey, size, shmflg);\n  if (realId != -1) {\n    SysVShm::instance().on_shmget(realId, realKey, key, size, shmflg);\n    virtId = REAL_TO_VIRTUAL_SHM_ID(realId);\n    JLOG(SYSV)(\"Creating new Shared memory segment\")\n      (key) (size) (shmflg) (realId) (virtId);\n  }\n  DMTCP_PLUGIN_ENABLE_CKPT();\n  return virtId;\n}\n\nextern \"C\"\nvoid *shmat(int shmid, const void *shmaddr, int shmflg)\n{\n  DMTCP_PLUGIN_DISABLE_CKPT();\n  int realShmid = VIRTUAL_TO_REAL_SHM_ID(shmid);\n  JASSERT(realShmid != -1) .Text(\"Not Implemented\");\n  void *ret = _real_shmat(realShmid, shmaddr, shmflg);\n#ifdef __arm__\n  // This is arguably a bug in Linux kernel 2.6.28, 2.6.29, 3.0 - 3.2 and others\n  // See:  https://bugs.kde.org/show_bug.cgi?id=222545\n  //     On ARM, SHMLBA == 4*PAGE_SIZE instead of PAGESIZE\n  //     So, this fails:\n  //    shmaddr = shmat(shmid, NULL, 0); smdt(shmaddr); shmat(shmid, shaddr, 0);\n  //       when shmaddr % 0x4000 != 0 (when shmaddr not multiple of SMLBA)\n  // Workaround for bug in Linux kernel for ARM follows.\n  // WHEN KERNEL FIX IS AVAILABLE, DO THIS ONLY FOR BUGGY KERNEL VERSIONS.\n  if (((long)ret % 0x4000 != 0) && (ret != (void *)-1)) { // if ret%SHMLBA != 0\n    void *ret_addr[20];\n    unsigned int i;\n    for (i = 0; i < sizeof(ret_addr) / sizeof(ret_addr[0]) ; i++) {\n      ret_addr[i] = ret; // Save bad address for detaching later\n      ret = _real_shmat(realShmid, shmaddr, shmflg); // Try again\n      // if ret % SHMLBA == 0 { ... }\n      if (((long)ret % 0x4000 == 0) || (ret == (void *)-1))\n        break; // Good address (or error return)\n    }\n    // Detach all the bad addresses that are not SHMLBA-aligned.\n    if (i < sizeof(ret_addr) / sizeof(ret_addr[0]))\n      for (unsigned int j = 0; j < i+1; j++)\n        _real_shmdt( ret_addr[j] );\n    JASSERT((long)ret % 0x4000 == 0)\n      (shmaddr) (shmflg) (getpid())\n      .Text (\"Failed to get SHMLBA-aligned address after 20 tries\");\n  }\n#elif defined(__aarch64__)\n# warning \"TODO: Implementation for ARM64.\"\n#endif\n\n  if (ret != (void *) -1) {\n    SysVShm::instance().on_shmat(shmid, shmaddr, shmflg, ret);\n    JLOG(SYSV)(\"Mapping Shared memory segment\") (shmid) (realShmid) (shmflg) (ret);\n  }\n  DMTCP_PLUGIN_ENABLE_CKPT();\n  return ret;\n}\n\nEXTERNC bool\ndmtcp_svipc_inside_shmdt()\n{\n  return inside_shmdt;\n}\n\nextern \"C\"\nint shmdt(const void *shmaddr)\n{\n  DMTCP_PLUGIN_DISABLE_CKPT();\n  inside_shmdt = true;\n  int ret = _real_shmdt(shmaddr);\n  if (ret != -1) {\n    SysVShm::instance().on_shmdt(shmaddr);\n    JLOG(SYSV)(\"Unmapping Shared memory segment\") (shmaddr);\n  }\n  inside_shmdt = false;\n  DMTCP_PLUGIN_ENABLE_CKPT();\n  return ret;\n}\n\n// Open MPI 2.x uses dlsym() to locate the address of certain functions\n// in order to install its own hooks. For us, shmdt() is the only interesting\n// one. Instead of giving the address of our wrapper to the hook library, we\n// want to return the address in libc. See PR #472 for details.\nextern \"C\"\nvoid *dlsym(void *handle, const char *symbol)\n{\n  DMTCP_PLUGIN_DISABLE_CKPT();\n  void *ret = _real_dlsym(handle, symbol);\n  DMTCP_PLUGIN_ENABLE_CKPT();\n  return ret;\n}\n\nextern \"C\"\nint shmctl(int shmid, int cmd, struct shmid_ds *buf)\n{\n  DMTCP_PLUGIN_DISABLE_CKPT();\n  int realShmid = VIRTUAL_TO_REAL_SHM_ID(shmid);\n  JASSERT(realShmid != -1);\n  int ret = _real_shmctl(realShmid, cmd, buf);\n  DMTCP_PLUGIN_ENABLE_CKPT();\n  return ret;\n}\n\n/******************************************************************************\n *\n * SysV Semaphore Methods\n *\n *****************************************************************************/\n\nextern \"C\"\nint semget(key_t key, int nsems, int semflg)\n{\n  int realId = -1;\n  int virtId = -1;\n  DMTCP_PLUGIN_DISABLE_CKPT();\n  realId = _real_semget (key, nsems, semflg);\n  if (realId != -1) {\n    SysVSem::instance().on_semget(realId, key, nsems, semflg);\n    virtId = REAL_TO_VIRTUAL_SEM_ID(realId);\n    JLOG(SYSV)(\"Creating new SysV Semaphore\") (key) (nsems) (semflg);\n  }\n  DMTCP_PLUGIN_ENABLE_CKPT();\n  return virtId;\n}\n\nextern \"C\"\nint semop(int semid, struct sembuf *sops, size_t nsops)\n{\n  return semtimedop(semid, sops, nsops, NULL);\n}\n\nextern \"C\"\nint semtimedop(int semid, struct sembuf *sops, size_t nsops,\n               const struct timespec *timeout)\n{\n  struct timespec totaltime = {0, 0};\n  int ret;\n  int realId;\n  bool ipc_nowait_specified = false;\n\n  for (size_t i = 0; i < nsops; i++) {\n    if (sops[i].sem_flg & IPC_NOWAIT) {\n      ipc_nowait_specified = true;\n      break;\n    }\n  }\n\n  if (ipc_nowait_specified ||\n      (timeout != NULL && TIMESPEC_CMP(timeout, &ts_100ms, <))) {\n    DMTCP_PLUGIN_DISABLE_CKPT();\n    realId = VIRTUAL_TO_REAL_SEM_ID(semid);\n    JASSERT(realId != -1);\n    ret = _real_semtimedop(realId, sops, nsops, timeout);\n    if (ret == 0) {\n      SysVSem::instance().on_semop(semid, sops, nsops);\n    }\n    DMTCP_PLUGIN_ENABLE_CKPT();\n    return ret;\n  }\n\n  /*\n   * We continue to call pthread_tryjoin_np (and sleep) until we have gone past\n   * the abstime provided by the caller\n   */\n  while (timeout == NULL || TIMESPEC_CMP(&totaltime, timeout, <)) {\n    ret = EAGAIN;\n    DMTCP_PLUGIN_DISABLE_CKPT();\n    realId = VIRTUAL_TO_REAL_SEM_ID(semid);\n    JASSERT(realId != -1);\n    ret = _real_semtimedop(realId, sops, nsops, &ts_100ms);\n    if (ret == 0) {\n      SysVSem::instance().on_semop(semid, sops, nsops);\n    }\n    DMTCP_PLUGIN_ENABLE_CKPT();\n\n    // TODO Handle EIDRM\n    if (ret == 0 ||\n        (ret == -1 && errno != EAGAIN)) {\n      return ret;\n    }\n\n    TIMESPEC_ADD(&totaltime, &ts_100ms, &totaltime);\n  }\n  errno = EAGAIN;\n  return -1;\n}\n\nextern \"C\"\nint semctl(int semid, int semnum, int cmd, ...)\n{\n  union semun uarg;\n  va_list arg;\n  va_start (arg, cmd);\n  uarg = va_arg (arg, union semun);\n  va_end (arg);\n  int ret = -1;\n\n  if (cmd == SEM_INFO || cmd == IPC_INFO) {\n    return _real_semctl(semid, semnum, cmd, uarg);\n  }\n\n  DMTCP_PLUGIN_DISABLE_CKPT();\n  int realId = VIRTUAL_TO_REAL_SEM_ID(semid);\n  JASSERT(realId != -1) (semid) (semnum) (cmd);\n  ret = _real_semctl(realId, semnum, cmd, uarg);\n  if (ret != -1) {\n    SysVSem::instance().on_semctl(semid, semnum, cmd, uarg);\n  }\n  DMTCP_PLUGIN_ENABLE_CKPT();\n\n  return ret;\n}\n/******************************************************************************\n *\n * SysV Msg Queue Methods\n *\n *****************************************************************************/\n\nextern \"C\"\nint msgget(key_t key, int msgflg)\n{\n  int realId = -1;\n  int virtId = -1;\n  DMTCP_PLUGIN_DISABLE_CKPT();\n  realId = _real_msgget (key, msgflg);\n  if (realId != -1) {\n    SysVMsq::instance().on_msgget(realId, key, msgflg);\n    virtId = REAL_TO_VIRTUAL_MSQ_ID(realId);\n    JLOG(SYSV)(\"Creating new SysV Msg Queue\") (key) (msgflg);\n  }\n  DMTCP_PLUGIN_ENABLE_CKPT();\n  return virtId;\n}\n\nextern \"C\"\nint msgsnd(int msqid, const void *msgp, size_t msgsz, int msgflg)\n{\n  int ret;\n  int realId;\n\n  /*\n   * We continue to call msgsnd with IPC_NOWAIT (and sleep) until we succeed\n   * or fail with something other than EAGAIN\n   * If IPC_NOWAIT was specified and msgsnd fails with EAGAIN, return.\n   */\n  while (true) {\n    DMTCP_PLUGIN_DISABLE_CKPT();\n    realId = VIRTUAL_TO_REAL_MSQ_ID(msqid);\n    JASSERT(realId != -1);\n    ret = _real_msgsnd(realId, msgp, msgsz, msgflg | IPC_NOWAIT);\n    if (ret == 0) {\n      SysVMsq::instance().on_msgsnd(msqid, msgp, msgsz, msgflg);\n    }\n    DMTCP_PLUGIN_ENABLE_CKPT();\n\n    // TODO Handle EIDRM\n    if ((ret == 0) ||\n        (ret == -1 && errno != EAGAIN) ||\n        (msgflg & IPC_NOWAIT)) {\n      return ret;\n    }\n\n    nanosleep(&ts_100ms, NULL);\n  }\n  JASSERT(false) .Text(\"Not Reached\");\n  return -1;\n}\n\nextern \"C\"\nssize_t msgrcv(int msqid, void *msgp, size_t msgsz, long msgtyp, int msgflg)\n{\n  int ret;\n  int realId;\n\n  /*\n   * We continue to call msgrcv with IPC_NOWAIT (and sleep) until we succeed\n   * or fail with something other than EAGAIN\n   * If IPC_NOWAIT was specified and msgsnd fails with EAGAIN, return.\n   */\n  while (true) {\n    DMTCP_PLUGIN_DISABLE_CKPT();\n    realId = VIRTUAL_TO_REAL_MSQ_ID(msqid);\n    JASSERT(realId != -1);\n    ret = _real_msgrcv(realId, msgp, msgsz, msgtyp, msgflg | IPC_NOWAIT);\n    if (ret == 0) {\n      SysVMsq::instance().on_msgrcv(msqid, msgp, msgsz, msgtyp, msgflg);\n    }\n    DMTCP_PLUGIN_ENABLE_CKPT();\n\n    // TODO Handle EIDRM\n    if ((ret >= 0) ||\n        (ret == -1 && errno != ENOMSG) ||\n        (msgflg & IPC_NOWAIT)) {\n      return ret;\n    }\n\n    nanosleep(&ts_100ms, NULL);\n  }\n  JASSERT(false) .Text(\"Not Reached\");\n  return -1;\n}\n\n\nextern \"C\"\nint msgctl(int msqid, int cmd, struct msqid_ds *buf)\n{\n  DMTCP_PLUGIN_DISABLE_CKPT();\n  int realId = VIRTUAL_TO_REAL_MSQ_ID(msqid);\n  JASSERT(realId != -1);\n  int ret = _real_msgctl(realId, cmd, buf);\n  if (ret != -1) {\n    SysVMsq::instance().on_msgctl(msqid, cmd, buf);\n  }\n  DMTCP_PLUGIN_ENABLE_CKPT();\n  return ret;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/src/plugin/svipc/sysvipcwrappers.h": "/****************************************************************************\n *   Copyright (C) 2006-2010 by Jason Ansel, Kapil Arya, and Gene Cooperman *\n *   jansel@csail.mit.edu, kapil@ccs.neu.edu, gene@ccs.neu.edu              *\n *                                                                          *\n *   This file is part of the dmtcp/src module of DMTCP (DMTCP:dmtcp/src).  *\n *                                                                          *\n *  DMTCP:dmtcp/src is free software: you can redistribute it and/or        *\n *  modify it under the terms of the GNU Lesser General Public License as   *\n *  published by the Free Software Foundation, either version 3 of the      *\n *  License, or (at your option) any later version.                         *\n *                                                                          *\n *  DMTCP:dmtcp/src is distributed in the hope that it will be useful,      *\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of          *\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *\n *  GNU Lesser General Public License for more details.                     *\n *                                                                          *\n *  You should have received a copy of the GNU Lesser General Public        *\n *  License along with DMTCP:dmtcp/src.  If not, see                        *\n *  <http://www.gnu.org/licenses/>.                                         *\n ****************************************************************************/\n\n#pragma once\n#ifndef SYSVIPC_WRAPPERS_H\n#define SYSVIPC_WRAPPERS_H\n\n#include \"dmtcp.h\"\n\n#define _real_shmget NEXT_FNC(shmget)\n#define _real_shmat  NEXT_FNC(shmat)\n#define _real_shmdt  NEXT_FNC(shmdt)\n#define _real_shmctl NEXT_FNC(shmctl)\n\n#define _real_semget NEXT_FNC(semget)\n#define _real_semctl NEXT_FNC(semctl)\n#define _real_semop  NEXT_FNC(semop)\n#define _real_semtimedop NEXT_FNC(semtimedop)\n\n#define _real_msgget NEXT_FNC(msgget)\n#define _real_msgctl NEXT_FNC(msgctl)\n#define _real_msgsnd NEXT_FNC(msgsnd)\n#define _real_msgrcv NEXT_FNC(msgrcv)\n\n#define _real_pthread_mutex_lock NEXT_FNC(pthread_mutex_lock)\n#define _real_pthread_mutex_unlock NEXT_FNC(pthread_mutex_unlock)\n\n#define _real_dlsym NEXT_FNC(dlsym)\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/src/plugin/timer/timerwrappers.h": "/****************************************************************************\n *   Copyright (C) 2006-2010 by Jason Ansel, Kapil Arya, and Gene Cooperman *\n *   jansel@csail.mit.edu, kapil@ccs.neu.edu, gene@ccs.neu.edu              *\n *                                                                          *\n *   This file is part of the dmtcp/src module of DMTCP (DMTCP:dmtcp/src).  *\n *                                                                          *\n *  DMTCP:dmtcp/src is free software: you can redistribute it and/or        *\n *  modify it under the terms of the GNU Lesser General Public License as   *\n *  published by the Free Software Foundation, either version 3 of the      *\n *  License, or (at your option) any later version.                         *\n *                                                                          *\n *  DMTCP:dmtcp/src is distributed in the hope that it will be useful,      *\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of          *\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *\n *  GNU Lesser General Public License for more details.                     *\n *                                                                          *\n *  You should have received a copy of the GNU Lesser General Public        *\n *  License along with DMTCP:dmtcp/src.  If not, see                        *\n *  <http://www.gnu.org/licenses/>.                                         *\n ****************************************************************************/\n\n#pragma once\n#ifndef TIMER_WRAPPERS_H\n#define TIMER_WRAPPERS_H\n\n#include <signal.h>\n#include <time.h>\n#include \"dmtcp.h\"\n#include \"dmtcp_dlsym.h\"\n\n#define _real_timer_create NEXT_FNC_DEFAULT(timer_create)\n#define _real_timer_delete NEXT_FNC_DEFAULT(timer_delete)\n#define _real_timer_gettime NEXT_FNC_DEFAULT(timer_gettime)\n#define _real_timer_settime NEXT_FNC_DEFAULT(timer_settime)\n#define _real_timer_getoverrun NEXT_FNC_DEFAULT(timer_getoverrun)\n\n#define _real_clock_getcpuclockid NEXT_FNC_DEFAULT(clock_getcpuclockid)\n#define _real_pthread_getcpuclockid NEXT_FNC_DEFAULT(pthread_getcpuclockid)\n#define _real_clock_getres NEXT_FNC_DEFAULT(clock_getres)\n#define _real_clock_gettime NEXT_FNC_DEFAULT(clock_gettime)\n#define _real_clock_settime NEXT_FNC_DEFAULT(clock_settime)\n\n#define _real_pthread_mutex_lock NEXT_FNC_DEFAULT(pthread_mutex_lock)\n#define _real_pthread_mutex_unlock NEXT_FNC_DEFAULT(pthread_mutex_unlock)\n\nint timer_create_sigev_thread(clockid_t clock_id,\n                              struct sigevent *evp,\n                              timer_t *timerid,\n                              struct sigevent *sevOut);\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/src/plugin/dl/dlwrappers.cpp": "/****************************************************************************\n *   Copyright (C) 2006-2013 by Jason Ansel, Kapil Arya, and Gene Cooperman *\n *   jansel@csail.mit.edu, kapil@ccs.neu.edu, gene@ccs.neu.edu              *\n *                                                                          *\n *   This file is part of the dmtcp/src module of DMTCP (DMTCP:dmtcp/src).  *\n *                                                                          *\n *  DMTCP:dmtcp/src is free software: you can redistribute it and/or        *\n *  modify it under the terms of the GNU Lesser General Public License as   *\n *  published by the Free Software Foundation, either version 3 of the      *\n *  License, or (at your option) any later version.                         *\n *                                                                          *\n *  DMTCP:dmtcp/src is distributed in the hope that it will be useful,      *\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of          *\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *\n *  GNU Lesser General Public License for more details.                     *\n *                                                                          *\n *  You should have received a copy of the GNU Lesser General Public        *\n *  License along with DMTCP:dmtcp/src.  If not, see                        *\n *  <http://www.gnu.org/licenses/>.                                         *\n ****************************************************************************/\n\n#include <stdlib.h>\n#include <unistd.h>\n#include \"dmtcp.h\"\n#include \"../jalib/jassert.h\"\n\n#define _real_dlopen  NEXT_FNC(dlopen)\n#define _real_dlclose NEXT_FNC(dlclose)\n\nextern \"C\" int dmtcp_libdlLockLock();\nextern \"C\" void dmtcp_libdlLockUnlock();\n\n/* Reason for using thread_performing_dlopen_dlsym:\n *\n * dlsym/dlopen/dlclose make a call to calloc() internally. We do not want to\n * checkpoint while we are in the midst of dlopen etc. as it can lead to\n * undesired behavior. To do so, we use WRAPPER_EXECUTION_DISABLE_CKPT() at the\n * beginning of the funtion. However, if a checkpoint request is received right\n * after WRAPPER_EXECUTION_DISABLE_CKPT(), the ckpt-thread is queued for wrlock\n * on the pthread-rwlock and any subsequent request for rdlock by other threads\n * will have to wait until the ckpt-thread releases the lock. However, in this\n * scenario, dlopen calls calloc, which then calls\n * WRAPPER_EXECUTION_DISABLE_CKPT() and hence resulting in a deadlock.\n *\n * We set this variable to true, once we are inside the dlopen/dlsym/dlerror\n * wrapper, so that the calling thread won't try to acquire the lock later on.\n *\n * EDIT: Instead of acquiring wrapperExecutionLock, we acquire libdlLock.\n * libdlLock is a higher priority lock than wrapperExectionLock i.e. during\n * checkpointing this lock is acquired before wrapperExecutionLock by the\n * ckpt-thread.\n * Rationale behind not using wrapperExecutionLock and creating an extra lock:\n *   When loading a shared library, dlopen will initialize the static objects\n *   in the shared library by calling their corresponding constructors.\n *   Further, the constructor might call fork/exec to create new\n *   process/program. Finally, fork/exec require the wrapperExecutionLock in\n *   exclusive mode (writer lock). However, if dlopen wrapper acquires the\n *   wrapperExecutionLock, the fork wrapper will deadlock when trying to get\n *   writer lock.\n *\n * EDIT: The dlopen() wrappers causes the problems with the semantics of RPATH\n * associated with the caller library. In future, we can work without this\n * plugin by detecting if we are in the middle of a dlopen by looking up the\n * stack frames.\n */\n\nextern \"C\"\nvoid *dlopen(const char *filename, int flag)\n{\n  bool lockAcquired = dmtcp_libdlLockLock();\n  void *ret = _real_dlopen(filename, flag);\n  if (lockAcquired) {\n    dmtcp_libdlLockUnlock();\n  }\n  JWARNING(ret) (filename) (flag)\n    .Text(\"dlopen failed.  You may also see a message 'ERROR: ld.so:'\\n\"\n    \"from libdl.so.  If this happens only under DMTCP, then consider setting\\n\"\n    \"the environment variable DMTCP_DL_PLUGIN to \\\"0\\\" before 'dmtcp_launch'.\\n\"\n    \"If the problem persists, please write to the DMTCP developers.\\n\");\n  return ret;\n}\n\nextern \"C\"\nint dlclose(void *handle)\n{\n  bool lockAcquired = dmtcp_libdlLockLock();\n  int ret = _real_dlclose(handle);\n  if (lockAcquired) {\n    dmtcp_libdlLockUnlock();\n  }\n  return ret;\n}\n\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/include/dmtcp.h": "/****************************************************************************\n * TODO: Replace this header with appropriate header showing MIT OR BSD     *\n *       License                                                            *\n *   Copyright (C) 2006-2008 by Jason Ansel, Kapil Arya, and Gene Cooperman *\n *   jansel@csail.mit.edu, kapil@ccs.neu.edu, gene@ccs.neu.edu              *\n *                                                                          *\n * This file, dmtcp.h, is placed in the public domain.                *\n * The motivation for this is to allow anybody to freely use this file      *\n * without restriction to statically link this file with any software.      *\n * This allows that software to communicate with the DMTCP libraries.       *\n * -  Jason Ansel, Kapil Arya, and Gene Cooperman                           *\n *      jansel@csail.mit.edu, kapil@ccs.neu.edu, gene@ccs.neu.edu           *\n ****************************************************************************/\n\n#ifndef DMTCP_H\n#define DMTCP_H\n\n#include <stdio.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/ip.h>\n\n#ifndef __USE_GNU\n# define __USE_GNU_NOT_SET\n# define __USE_GNU\n#endif\n#include <dlfcn.h>  /* for NEXT_FNC() */\n#ifdef __USE_GNU_NOT_SET\n# undef __USE_GNU_NOT_SET\n# undef __USE_GNU\n#endif\n\n#ifndef EXTERNC\n# ifdef __cplusplus\n#  define EXTERNC extern \"C\"\n# else\n#  define EXTERNC\n# endif\n#endif\n\n// C++ takes null arg, while C takes void arg.\n#ifdef __cplusplus\n# define DMTCP_VOID\n#else\n# define DMTCP_VOID void\n#endif\n\n#define LIB_PRIVATE __attribute__ ((visibility (\"hidden\")))\n\ntypedef enum eDmtcpEvent {\n  //DMTCP_EVENT_WRAPPER_INIT, // Future Work :-).\n  DMTCP_EVENT_INIT,\n  DMTCP_EVENT_EXIT,\n\n  DMTCP_EVENT_PRE_EXEC,\n  DMTCP_EVENT_POST_EXEC,\n\n  DMTCP_EVENT_ATFORK_PREPARE,\n  DMTCP_EVENT_ATFORK_PARENT,\n  DMTCP_EVENT_ATFORK_CHILD,\n\n  DMTCP_EVENT_WAIT_FOR_SUSPEND_MSG,\n  DMTCP_EVENT_THREADS_SUSPEND,\n  DMTCP_EVENT_LEADER_ELECTION,\n  DMTCP_EVENT_PRE_CKPT_NAME_SERVICE_DATA_REGISTER,\n  DMTCP_EVENT_PRE_CKPT_NAME_SERVICE_DATA_QUERY,\n  DMTCP_EVENT_DRAIN,\n  DMTCP_EVENT_WRITE_CKPT,\n\n  DMTCP_EVENT_RESTART,\n  DMTCP_EVENT_RESUME,\n  DMTCP_EVENT_REGISTER_NAME_SERVICE_DATA,\n  DMTCP_EVENT_SEND_QUERIES,\n  DMTCP_EVENT_REFILL,\n  DMTCP_EVENT_THREADS_RESUME,\n\n  DMTCP_EVENT_PRE_SUSPEND_USER_THREAD,\n  DMTCP_EVENT_RESUME_USER_THREAD,\n\n  DMTCP_EVENT_THREAD_START,\n  DMTCP_EVENT_THREAD_CREATED,\n\n  DMTCP_EVENT_PTHREAD_START,\n  DMTCP_EVENT_PTHREAD_EXIT,\n  DMTCP_EVENT_PTHREAD_RETURN,\n\n  nDmtcpEvents\n} DmtcpEvent_t;\n\ntypedef union _DmtcpEventData_t {\n  struct {\n    int fd;\n  } serializerInfo;\n\n  struct {\n    int isRestart;\n  } resumeUserThreadInfo, refillInfo, resumeInfo, nameserviceInfo;\n} DmtcpEventData_t;\n\ntypedef struct DmtcpUniqueProcessId {\n  uint64_t  _hostid; //gethostid()\n  uint64_t _time; //time()\n  pid_t _pid; //getpid()\n  uint32_t _computation_generation; //computationGeneration()\n} DmtcpUniqueProcessId;\n\nEXTERNC int dmtcp_unique_pids_equal(DmtcpUniqueProcessId a,\n                                    DmtcpUniqueProcessId b);\n\n//FIXME:\n// If a plugin is not compiled with defined(__PIC__) and we can verify\n// that we're using DMTCP (environment variables), and dmtcp_is_enabled\n// or dmtcp_checkpoint expands to 0, then we should print a warning\n// at run-time.\n\n// These utility functions require compiling the target app with -fPIC\n\n/**\n * Returns 1 if executing under dmtcp_launch, 0 otherwise\n * See: test/plugin/applic-initiated-ckpt and applic-delayed-ckpt\n *      directories for exammples:\n */\nEXTERNC int dmtcp_is_enabled(DMTCP_VOID) __attribute ((weak));\n#define dmtcp_is_enabled() (dmtcp_is_enabled ? dmtcp_is_enabled() : 0)\n\n/**\n * Checkpoint the entire distributed computation\n *   (Does not necessarily block until checkpoint is complete.\n *    Use dmtcp_get_generation() to test if checkpoint is complete.)\n * + returns DMTCP_AFTER_CHECKPOINT if the checkpoint succeeded.\n * + returns DMTCP_AFTER_RESTART    after a restart.\n * + returns <=0 on error.\n * See: test/plugin/applic-initiated-ckpt directory for an exammple:\n */\nEXTERNC int dmtcp_checkpoint(DMTCP_VOID) __attribute__ ((weak));\n#define dmtcp_checkpoint() \\\n  (dmtcp_checkpoint ? dmtcp_checkpoint() : DMTCP_NOT_PRESENT)\n\n/**\n * Prevent a checkpoint from starting until dmtcp_enable_checkpoint() is\n * called.\n * + Has (recursive) lock semantics, only one thread may acquire it at time.\n * + Only prevents checkpoints locally, remote processes may be suspended.\n *   Thus, send or recv to another checkpointed process may create deadlock.\n * + Returns 1 on success, <=0 on error\n * See: test/plugin/applic-delayed-ckpt directory for an exammple:\n */\nEXTERNC int dmtcp_disable_ckpt(DMTCP_VOID) __attribute__ ((weak));\n#define dmtcp_disable_ckpt() \\\n (dmtcp_disable_ckpt ? dmtcp_disable_ckpt() : DMTCP_NOT_PRESENT)\n\n/**\n * Re-allow checkpoints, opposite of dmtcp_disable_ckpt().\n * + Returns 1 on success, <=0 on error\n * See: test/plugin/applic-delayed-ckpt directory for an exammple:\n */\nEXTERNC int dmtcp_enable_ckpt(DMTCP_VOID) __attribute__ ((weak));\n#define dmtcp_enable_ckpt() \\\n (dmtcp_enable_ckpt ? dmtcp_enable_ckpt() : DMTCP_NOT_PRESENT)\n\n// See: test/plugin/sleep1 dir and sibling directories for examples:\nEXTERNC void dmtcp_event_hook(DmtcpEvent_t event, DmtcpEventData_t *data)\n  __attribute((weak));\n\n// See: test/plugin/example-db dir for an example:\nEXTERNC int dmtcp_send_key_val_pair_to_coordinator(const char *id,\n                                                   const void *key,\n                                                   uint32_t key_len,\n                                                   const void *val,\n                                                   uint32_t val_len);\nEXTERNC int dmtcp_send_key_val_pair_to_coordinator_sync(const char *id,\n                                                        const void *key,\n                                                        uint32_t key_len,\n                                                        const void *val,\n                                                        uint32_t val_len);\nEXTERNC int dmtcp_send_query_to_coordinator(const char *id,\n                                            const void *key, uint32_t key_len,\n                                            void *val, uint32_t *val_len);\n/*\n * This API can be used to create a new NS database, generate a unique\n * id, populate the database with the unique id, and return the generated\n * unique id. This allows one to use the API first at launch time to get\n * unique ids, and then use the regular NS API later for querying and\n * publishing.\n *\n * To use this API, one needs to specify the following parameters:\n *  - a nameservice database name;\n *  - a key, which could be a host-id (if you wanted per-host unique ids,\n *    e.g., lids for IB), or a pid (if you wanted per process unique ids,\n *    e.g., QP numbers for IB);\n *  - key_len, which is the length of the key (in bytes);\n *  - val, which is the return value, (in other words, the unique id\n *    generated by the coordinator);\n *  - offset, which determines the difference between two ids\n *   (e.g., a difference of 10 between two lids); and\n *  - val_len, which is the max. length in bytes for the unique id\n *    (e.g., 2 bytes for a lid).\n */\nEXTERNC int dmtcp_get_unique_id_from_coordinator(const char *id,    // DB name\n                                                 const void *key,   // Key: can be hostid, pid, etc.\n                                                 uint32_t key_len,  // Length of the key\n                                                 void *val,         // Result\n                                                 uint32_t offset,   // unique id offset\n                                                 uint32_t val_len); // Expected value length\n\nEXTERNC void dmtcp_get_local_ip_addr(struct in_addr *in);\n\nEXTERNC const char* dmtcp_get_tmpdir(void);\n//EXTERNC void dmtcp_set_tmpdir(const char *);\n\nEXTERNC const char* dmtcp_get_ckpt_dir(void) __attribute ((weak));\n#define dmtcp_get_ckpt_dir() \\\n (dmtcp_get_ckpt_dir ? dmtcp_get_ckpt_dir() : NULL)\nEXTERNC int dmtcp_set_ckpt_dir(const char *) __attribute ((weak));\n#define dmtcp_set_ckpt_dir(d) \\\n (dmtcp_set_ckpt_dir ? dmtcp_set_ckpt_dir(d) : DMTCP_NOT_PRESENT)\n\n// One peer can request a change to a global ckpt dir while another requests\n// a checkpoint. If a peer can send a global ckpt dir request before being\n// suspended, then the coordinator will recognize this request, and pass on\n// to all peers the new global ckpt dir. Upon restart, all peers will remember\n// the current ckpt dir (whether the original local one or a change to a\n// global one).\nEXTERNC int dmtcp_set_global_ckpt_dir(const char *) __attribute__ ((weak));\n#define dmtcp_set_global_ckpt_dir(d) \\\n (dmtcp_set_global_ckpt_dir ? dmtcp_set_global_ckpt_dir(d) : DMTCP_NOT_PRESENT)\nEXTERNC const char* dmtcp_get_coord_ckpt_dir(void) __attribute__ ((weak));\n#define dmtcp_get_coord_ckpt_dir() \\\n (dmtcp_get_coord_ckpt_dir ? dmtcp_get_coord_ckpt_dir() : NULL)\nEXTERNC int dmtcp_set_coord_ckpt_dir(const char* dir) __attribute__ ((weak));\n#define dmtcp_set_coord_ckpt_dir(d) \\\n (dmtcp_set_coord_ckpt_dir ? dmtcp_set_coord_ckpt_dir(d) : DMTCP_NOT_PRESENT)\nEXTERNC const char* dmtcp_get_ckpt_filename(void) __attribute__((weak));\nEXTERNC const char* dmtcp_get_ckpt_files_subdir(void);\nEXTERNC int dmtcp_should_ckpt_open_files(void);\nEXTERNC int dmtcp_allow_overwrite_with_ckpted_files(void);\n\nEXTERNC int dmtcp_get_ckpt_signal(void);\nEXTERNC const char* dmtcp_get_uniquepid_str(void) __attribute__((weak));\n\n/*\n * ComputationID\n *   ComputationID of a computation is the unique-pid of the first process of\n *   the computation. Even if that process dies, the rest of the computation\n *   retains the same computation ID.\n *\n *   With --enable-unique-checkpoint-filenames, the ComputationID also includes\n *   the checkpoint generation number (starting from 1 for the first\n *   checkpoint).  This number is the same for the entire computation at a\n *   given point in time.  Dmtcp coordinator increments this number prior\n *   to sending the SUSPEND message, and it is sent to the workers as a part\n *   of the SUSPEND message.\n */\nEXTERNC const char* dmtcp_get_computation_id_str(void);\nEXTERNC uint64_t dmtcp_get_coordinator_timestamp(void);\n// Generation is 0 before first checkpoint, and then successively incremented.\nEXTERNC uint32_t dmtcp_get_generation(void) __attribute__((weak));\nEXTERNC int checkpoint_is_pending(void) __attribute__((weak));\n\n/**\n * Gets the coordinator-specific status of DMTCP.\n * - Returns DMTCP_IS_PRESENT if running under DMTCP and DMTCP_NOT_PRESENT\n *   otherwise.\n * - Side effects: modifies the arguments\n *\n * Args:\n *   numPeers: Number of processes connected to dmtcp_coordinator\n *   isRunning: 1 if all processes connected to dmtcp_coordinator are in a\n *              running state\n */\nEXTERNC int dmtcp_get_coordinator_status(int *numPeers, int *isRunning)\n  __attribute__((weak));\n#define dmtcp_get_coordinator_status(p,r) \\\n  (dmtcp_get_coordinator_status ? dmtcp_get_coordinator_status(p,r) \\\n                             : DMTCP_NOT_PRESENT)\n\n/**\n * Queries local state of this process, not global state seen by DMTCP coord.\n * - Returns DMTCP_IS_PRESENT if running under DMTCP and DMTCP_NOT_PRESENT\n *   otherwise.\n * - Side effects: modifies the arguments\n *\n * Args:\n *   numCheckpoints: The number of times this process has been checkpointed\n *                   (excludes restarts)\n *   numRestarts: The number of times this process has been restarted\n */\nEXTERNC int dmtcp_get_local_status(int *numCheckpoints, int *numRestarts)\n  __attribute__((weak));\n#define dmtcp_get_local_status(c,r) \\\n  (dmtcp_get_local_status ? dmtcp_get_local_status(c,r) : DMTCP_NOT_PRESENT)\n\n// Is DMTCP in the running state?\n//   (e.g., not in pre-ckpt, post-ckpt, post-restart event)?\nEXTERNC int dmtcp_is_running_state(void);\n// Primarily for use by the modify-env plugin.\nEXTERNC int dmtcp_get_restart_env(const char *name,\n                                  char *value, size_t maxvaluelen);\n// Get pathname of target executable under DMTCP control.\nEXTERNC const char* dmtcp_get_executable_path();\n// True if dmtcp_launch called with --no-coordinator\nEXTERNC int dmtcp_no_coordinator(void);\n/* If your plugin invokes wrapper functions before DMTCP is initialized,\n *   then call this prior to your first wrapper function call.\n */\nEXTERNC void dmtcp_prepare_wrappers(void) __attribute((weak));\n\n// FOR EXPERTS ONLY:\nEXTERNC int dmtcp_is_protected_fd(int fd);\nEXTERNC DmtcpUniqueProcessId dmtcp_get_uniquepid();\nEXTERNC DmtcpUniqueProcessId dmtcp_get_coord_id();\nEXTERNC DmtcpUniqueProcessId dmtcp_get_computation_id();\n\n// FOR EXPERTS ONLY:\nEXTERNC int dmtcp_get_ptrace_fd(void);\nEXTERNC int dmtcp_get_readlog_fd(void);\nEXTERNC void dmtcp_block_ckpt_signal(void);\nEXTERNC void dmtcp_unblock_ckpt_signal(void);\n\n// FOR EXPERTS ONLY:\nEXTERNC void *dmtcp_get_libc_dlsym_addr(void);\nEXTERNC void dmtcp_close_protected_fd(int fd);\nEXTERNC int dmtcp_protected_environ_fd(void);\n\n/* FOR EXPERTS ONLY:\n *   The DMTCP internal pid plugin ensures that the application sees only\n *  a virtual pid, which can be translated to the current real pid\n *  assigned to the kernel on a restart.  The pid plugin places wrappers\n *  around all system calls referring to a pid.  If your application\n *  discovers a pid without going through a system call (e.g., through\n *  the proc filesystem), use this to virtualize the pid.\n */\nEXTERNC pid_t dmtcp_real_to_virtual_pid(pid_t realPid) __attribute((weak));\nEXTERNC pid_t dmtcp_virtual_to_real_pid(pid_t virtualPid) __attribute((weak));\n\nEXTERNC void dmtcp_update_max_required_fd(int fd) __attribute((weak));\n\n// bq_file -> \"batch queue file\"; used only by batch-queue plugin\nEXTERNC int dmtcp_is_bq_file(const char *path)\n  __attribute((weak));\nEXTERNC int dmtcp_bq_should_ckpt_file(const char *path, int *type)\n  __attribute((weak));\nEXTERNC int dmtcp_bq_restore_file(const char *path, const char *savedFilePath,\n                                  int fcntlFlags, int type)\n  __attribute((weak));\n\n/*  These next two functions are defined in contrib/ckptfile/ckptfile.cpp\n *  But they are currently used only in src/plugin/ipc/file/fileconnection.cpp\n *    and in a trivial fashion.  These are intended for future extensions.\n */\nEXTERNC int dmtcp_must_ckpt_file(const char *path) __attribute((weak));\nEXTERNC void dmtcp_get_new_file_path(const char *abspath, const char *cwd,\n                                     char *newpath)\n  __attribute((weak));\nEXTERNC int dmtcp_must_overwrite_file(const char *path) __attribute((weak));\n\n#define dmtcp_process_event(e,d) \\\n    __REPLACE_dmtcp_process_event_WITH_dmtcp_event_hook()__\n\n// These are part of the internal implementation of DMTCP plugins\nEXTERNC int dmtcp_plugin_disable_ckpt(void);\n#define DMTCP_PLUGIN_DISABLE_CKPT() \\\n  int __dmtcp_plugin_ckpt_disabled = dmtcp_plugin_disable_ckpt()\n\nEXTERNC void dmtcp_plugin_enable_ckpt(void);\n#define DMTCP_PLUGIN_ENABLE_CKPT() \\\n  if (__dmtcp_plugin_ckpt_disabled) dmtcp_plugin_enable_ckpt()\n\nEXTERNC void dmtcp_initialize() __attribute ((weak));\n\n#define NEXT_FNC(func)                                                      \\\n  ({                                                                        \\\n     static __typeof__(&func) _real_##func = (__typeof__(&func)) -1;        \\\n     if (_real_##func == (__typeof__(&func)) -1) {                          \\\n       if (dmtcp_initialize) dmtcp_initialize();                            \\\n       __typeof__(&dlsym) dlsym_fnptr;                                      \\\n       dlsym_fnptr = (__typeof__(&dlsym)) dmtcp_get_libc_dlsym_addr();      \\\n       _real_##func = (__typeof__(&func)) (*dlsym_fnptr) (RTLD_NEXT, #func);\\\n     }                                                                      \\\n   _real_##func;})\n\n#define DMTCP_NEXT_EVENT_HOOK(event, data)                                  \\\n  do {                                                                      \\\n    static __typeof__(&dmtcp_event_hook) fn                                 \\\n      = (__typeof__(&dmtcp_event_hook)) -1;                                 \\\n    if ((void*) fn == (void*) -1) {                                         \\\n      fn = NEXT_FNC(dmtcp_event_hook);                                      \\\n    }                                                                       \\\n    if (fn != NULL) {                                                       \\\n      (*fn) (event, data);                                                  \\\n    }                                                                       \\\n  } while (0)\n\n#if defined(__clang__) && __clang_major__ < 3 || \\\n    __clang_major__ == 3 && __clang_minor__ <= 4\n/***************************************************************************\n * This workaround is required for what is arguably a bug in clang-3.4.1\n *   under Ubuntu 13.10.\n * We don't see a problem with clang-3.4.2 under Ubuntu 14.04.  So, eventually\n *   we can deprecate this patch, when most distros use a later clang.\n * clang-3.4 declares fn and dmtcp_event_hook as weak symbols (\"V\")\n *   when these variables are declared inside the function dmtcp_event_hook().\n *   This workaround declares them outside of dmtcp_event_hook().\n *   If the bug in clang gets fixed, we should expand this macro inline\n *     for the non-clang case.\n ***************************************************************************/\n# define DECLARE_TYPEOF_FNC(fnc_type,fnc) \\\nstatic __typeof__(&fnc_type) fnc          \\\n      = (__typeof__(&fnc_type)) -1\n\n// For clang, declare these at top level, instead of inside a function.\nDECLARE_TYPEOF_FNC(dmtcp_event_hook,fn);\nDECLARE_TYPEOF_FNC(dmtcp_event_hook,_real_dmtcp_event_hook);\n# undef DECLARE_TYPEOF_FNC\n// This removes the declarations from NEXT_FNC2() and DMTCP_NEXT_EVENT_HOOK()\n// Those macros are invoked from inside dmtcp_next_event_hook(), which\n//   is declare in dmtcp.h as a weak function.\n//   clang-3.4.1 seems to declare these inner fnc pointer types as weak\n//     because the outer function is weak.  Arguably, this is a bug.\n# define DECLARE_TYPEOF_FNC(fnc_type,fnc)\n\n# define NEXT_FNC2(func)                                                    \\\n  ({                                                                        \\\n     /* static __typeof__(&func) _real_##func = (__typeof__(&func)) -1; */  \\\n     DECLARE_TYPEOF_FNC(func,_real_##func);                                 \\\n     if (_real_##func == (__typeof__(&func)) -1) {                          \\\n       if (dmtcp_prepare_wrappers) dmtcp_prepare_wrappers();                \\\n       __typeof__(&dlsym) dlsym_fnptr;                                      \\\n       dlsym_fnptr = (__typeof__(&dlsym)) dmtcp_get_libc_dlsym_addr();      \\\n       _real_##func = (__typeof__(&func)) (*dlsym_fnptr) (RTLD_NEXT, #func);\\\n     }                                                                      \\\n   _real_##func;})\n\n# undef DMTCP_NEXT_EVENT_HOOK\n# define DMTCP_NEXT_EVENT_HOOK(event, data)                                 \\\n  do {                                                                      \\\n    /* static __typeof__(&dmtcp_event_hook) fn                              \\\n        = (__typeof__(&dmtcp_event_hook)) -1; */                            \\\n    DECLARE_TYPEOF_FNC(dmtcp_event_hook,fn);                                \\\n    if ((void*) fn == (void*) -1) {                                         \\\n      fn = NEXT_FNC2(dmtcp_event_hook);                                     \\\n    }                                                                       \\\n    if (fn != NULL) {                                                       \\\n      (*fn) (event, data);                                                  \\\n    }                                                                       \\\n  } while (0)\n\n// End of patches for clang-3.4.1\n#endif\n\n//===================================================================\n// DMTCP utilities\n\n#ifndef DMTCP_AFTER_CHECKPOINT\n  // Return value of dmtcp_checkpoint\n# define DMTCP_AFTER_CHECKPOINT 1\n  // Return value of dmtcp_checkpoint\n# define DMTCP_AFTER_RESTART    2\n#endif\n#ifndef DMTCP_NOT_PRESENT\n# define DMTCP_NOT_PRESENT 3\n#endif\n#ifndef DMTCP_IS_PRESENT\n# define DMTCP_IS_PRESENT 4\n#endif\n\n#define dmtcp_get_ckpt_filename() \\\n  (dmtcp_get_ckpt_filename ? dmtcp_get_ckpt_filename() : NULL)\n\n#define dmtcp_get_uniquepid_str() \\\n  (dmtcp_get_uniquepid_str ? dmtcp_get_uniquepid_str() : NULL)\n\n/* dmtcp_launch, dmtcp_restart return a unique rc (default: 99)\n * TYPICAL USAGE:  exit(DMTCP_FAIL_RC)\n * Use this to distinguish DMTCP failing versus the target application failing.\n */\n#define DMTCP_FAIL_RC                                         \\\n  (getenv(\"DMTCP_FAIL_RC\") && atoi(getenv(\"DMTCP_FAIL_RC\"))   \\\n     ? atoi(getenv(\"DMTCP_FAIL_RC\"))                          \\\n     : 99)\n\n/// Pointer to a \"void foo();\" function\ntypedef void (*dmtcp_fnptr_t)(void);\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/include/trampolines.h": "/****************************************************************************\n *   Copyright (C) 2006-2010 by Tyler Denniston and Kapil Arya              *\n *   tyler@ccs.neu.edu and kapil@ccs.neu.edu                                *\n *                                                                          *\n *   This file is part of the dmtcp/src module of DMTCP (DMTCP:dmtcp/src).  *\n *                                                                          *\n *  DMTCP is free software: you can redistribute it and/or        *\n *  modify it under the terms of the GNU Lesser General Public License as   *\n *  published by the Free Software Foundation, either version 3 of the      *\n *  License, or (at your option) any later version.                         *\n *                                                                          *\n *  DMTCP is distributed in the hope that it will be useful,      *\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of          *\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *\n *  GNU Lesser General Public License for more details.                     *\n *                                                                          *\n *  You should have received a copy of the GNU Lesser General Public        *\n *  License along with DMTCP:dmtcp/src.  If not, see                        *\n *  <http://www.gnu.org/licenses/>.                                         *\n ****************************************************************************/\n\n#ifndef TRAMPOLINES_H\n#define TRAMPOLINES_H\n\n#include <string.h>\n#include <sys/syscall.h>\n#include <sys/mman.h>\n#include <dlfcn.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include \"constants.h\"\n\n#ifdef __x86_64__\nstatic unsigned char asm_jump[] = {\n    // mov    $0x1234567812345678,%rax\n    0x48, 0xb8, 0x78, 0x56, 0x34, 0x12, 0x78, 0x56, 0x34, 0x12,\n    // jmpq   *%rax\n    0xff, 0xe0\n};\n// Beginning of address in asm_jump:\n# define ADDR_OFFSET 2\n#else\nstatic unsigned char asm_jump[] = {\n    0xb8, 0x78, 0x56, 0x34, 0x12, // mov    $0x12345678,%eax\n    0xff, 0xe0                    // jmp    *%eax\n};\n// Beginning of address in asm_jump:\n# define ADDR_OFFSET 1\n#endif\n\n#define ASM_JUMP_LEN sizeof(asm_jump)\n\ntypedef struct trampoline_info {\n  void *addr;\n  char jump[ASM_JUMP_LEN];\n  char displaced_instructions[ASM_JUMP_LEN];\n} trampoline_info_t;\n\n\n#define INSTALL_TRAMPOLINE(info) \\\n  memcpy((info).addr, (info).jump, ASM_JUMP_LEN)\n\n#define UNINSTALL_TRAMPOLINE(info) \\\n  memcpy((info).addr, (info).displaced_instructions, ASM_JUMP_LEN)\n\nstatic void dmtcp_setup_trampoline(const char *func_name, void *trampoline_fn,\n                                   trampoline_info_t *info);\n\nstatic void dmtcp_setup_trampoline_by_addr(void *addr, void *trampoline_fn,\n                                           trampoline_info_t *info)\n{\n  unsigned long pagesize = sysconf(_SC_PAGESIZE);\n  unsigned long pagemask = ~(pagesize - 1);\n  void *page_base;\n  info->addr = addr;\n  /* Base address of page where func resides. */\n  page_base = (void*) ((unsigned long)info->addr & pagemask);\n  /* Give that whole page RWX permissions. */\n  int retval = mprotect(page_base, pagesize,\n                        PROT_READ | PROT_WRITE | PROT_EXEC);\n  if (retval == -1) {\n    fprintf(stderr, \"*** %s:%d DMTCP Internal Error: mprotect() failed.\\n\",\n            __FILE__, __LINE__);\n    abort();\n  }\n  /************ Set up trampoline injection code. ***********/\n  /* Trick to get \"free\" conversion of a long value to the\n     character-array representation of that value. Different sizes of\n     long and endian-ness are handled automatically. */\n  union u {\n    void *val;\n    char bytes[sizeof(void*)];\n  } data;\n\n  data.val = trampoline_fn;\n  memcpy(info->jump, asm_jump, ASM_JUMP_LEN);\n  /* Insert real trampoline address into injection code. */\n  memcpy(info->jump + ADDR_OFFSET, data.bytes, sizeof(data.bytes));\n  /* Save displaced instructions for later restoration. */\n  memcpy(info->displaced_instructions, info->addr, ASM_JUMP_LEN);\n  /* Inject trampoline. */\n  INSTALL_TRAMPOLINE(*info);\n\n  (void)dmtcp_setup_trampoline; // Suppress unused function warning.\n}\n\nstatic void dmtcp_setup_trampoline(const char *func_name, void *trampoline_fn,\n                                   trampoline_info_t *info)\n{\n  /* Find libc func\n     We assume that no one is wrapping func yet. */\n  void *handle = dlopen(LIBC_FILENAME, RTLD_NOW);\n  if (handle == NULL) {\n    fprintf(stderr, \"*** %s:%d DMTCP Internal Error: dlopen() failed.\\n\",\n            __FILE__, __LINE__);\n    abort();\n  }\n  void *addr = dlsym(handle, func_name);\n  if (addr == NULL) {\n    fprintf(stderr, \"*** %s:%d DMTCP Internal Error: dlsym() failed.\\n\",\n            __FILE__, __LINE__);\n    abort();\n  }\n  dlclose(handle);\n  dmtcp_setup_trampoline_by_addr(addr, trampoline_fn, info);\n}\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/include/dmtcp_dlsym.h": "/****************************************************************************\n *   Copyright (C) 2014 by Gene Cooperman                                   *\n *   gene@ccs.neu.edu                                                       *\n *                                                                          *\n *  This file is part of DMTCP.                                             *\n *                                                                          *\n *  DMTCP is free software: you can redistribute it and/or                  *\n *  modify it under the terms of the GNU Lesser General Public License as   *\n *  published by the Free Software Foundation, either version 3 of the      *\n *  License, or (at your option) any later version.                         *\n *                                                                          *\n *  DMTCP is distributed in the hope that it will be useful,                *\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of          *\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *\n *  GNU Lesser General Public License for more details.                     *\n *                                                                          *\n *  You should have received a copy of the GNU Lesser General Public        *\n *  License along with DMTCP:dmtcp/src.  If not, see                        *\n *  <http://www.gnu.org/licenses/>.                                         *\n ****************************************************************************/\n\n#include <stddef.h>\n#include <stdio.h>\n#include <pthread.h>\n\n#include \"dmtcp.h\"\n\n#ifndef __USE_GNU\n# define __USE_GNU_NOT_SET\n# define __USE_GNU\n#endif\n#include <dlfcn.h>  /* for NEXT_FNC() */\n#ifdef __USE_GNU_NOT_SET\n# undef __USE_GNU_NOT_SET\n# undef __USE_GNU\n#endif\n\nEXTERNC void *dmtcp_dlsym(void *handle, const char *symbol);\nEXTERNC void *dmtcp_dlvsym(void *handle, char *symbol, const char *version);\nEXTERNC void *dmtcp_dlsym_lib(const char *libname, const char *symbol);\n/*\n * Returns the offset of the given function within the given shared library\n * or -1 if the function does not exist in the library\n */\nEXTERNC ptrdiff_t dmtcp_dlsym_lib_fnc_offset(const char *libname,\n                                             const char *symbol);\n\n#ifndef STANDALONE\n// This implementation mirrors dmtcp.h:NEXT_FNC() for DMTCP.\n// It uses dmtcp_dlsym to get default version, in case of symbol versioning\n# define NEXT_FNC_DEFAULT(func)                                             \\\n  ({                                                                        \\\n     static __typeof__(&func) _real_##func = (__typeof__(&func)) -1;        \\\n     if (_real_##func == (__typeof__(&func)) -1) {                          \\\n       if (dmtcp_initialize) dmtcp_initialize();                            \\\n       _real_##func = (__typeof__(&func)) dmtcp_dlsym(RTLD_NEXT, #func);    \\\n     }                                                                      \\\n   _real_##func;})\n\n/*\n * It uses dmtcp_dlvsym to get the function with the specified version in the\n * next library in the library-search order.\n */\n# define NEXT_FNC_DEFAULTV(func, ver)                                          \\\n  ({                                                                           \\\n     static __typeof__(&func) _real_##func = (__typeof__(&func)) -1;           \\\n     if (_real_##func == (__typeof__(&func)) -1) {                             \\\n       if (dmtcp_initialize) dmtcp_initialize();                               \\\n       _real_##func = (__typeof__(&func)) dmtcp_dlsym(RTLD_NEXT, #func, ver);  \\\n     }                                                                         \\\n   _real_##func;})\n\n/*\n * It uses dmtcp_dlsym to get the default function (in case of symbol\n * versioning) in the library with the given name.\n *\n * One possible usecase could be for bypassing the plugin layers and directly\n * jumping to a symbol in libc.\n */\n# define NEXT_FNC_DEFAULT_LIB(lib, func)                                       \\\n  ({                                                                           \\\n    static __typeof__(&func) _real_##func = (__typeof__(&func)) -1;            \\\n    if (_real_##func == (__typeof__(&func)) -1) {                              \\\n      if (dmtcp_initialize) {                                                  \\\n        dmtcp_initialize();                                                    \\\n      }                                                                        \\\n      _real_##func = (__typeof__(&func)) dmtcp_dlsym_lib(lib,  #func);         \\\n    }                                                                          \\\n    _real_##func;                                                              \\\n  })\n#endif // ifndef STANDALONE\n\n#ifdef STANDALONE\n// For standalone testing.\n// Copy this .h file to tmp.c file for standalone testing, and:\n//   g++ -DSTANDALONE ../src/dmtcp_dlsym.cpp tmp.c -ldl\nint main() {\n  void *fnc;\n  printf(\"pthread_cond_broadcast (via normal linker): %p\\n\",\n         pthread_cond_broadcast);\n\n  printf(\"================ dlsym ================\\n\");\n  fnc = dlsym(RTLD_DEFAULT, \"pthread_cond_broadcast\");\n  printf(\"pthread_cond_broadcast (via RTLD_DEFAULT): %p\\n\", fnc);\n  fnc = dlsym(RTLD_NEXT, \"pthread_cond_broadcast\");\n  printf(\"pthread_cond_broadcast (via RTLD_NEXT): %p\\n\", fnc);\n\n  printf(\"================ dmtcp_dlsym ================\\n\");\n  // NOTE: RTLD_DEFAULT would try to use this a.out, and fail to find a library\n  // fnc = dmtcp_dlsym(RTLD_DEFAULT, \"pthread_cond_broadcast\");\n  // printf(\"pthread_cond_broadcast (via RTLD_DEFAULT): %p\\n\", fnc);\n  fnc = dmtcp_dlsym(RTLD_NEXT, \"pthread_cond_broadcast\");\n  printf(\"pthread_cond_broadcast (via RTLD_NEXT): %p\\n\", fnc);\n\n  return 0;\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/include/shareddata.h": "/****************************************************************************\n *   Copyright (C) 2012-2014 by Jason Ansel, Kapil Arya, and Gene Cooperman *\n *   jansel@csail.mit.edu, kapil@ccs.neu.edu, gene@ccs.neu.edu              *\n *                                                                          *\n *  This file is part of DMTCP.                                             *\n *                                                                          *\n *  DMTCP is free software: you can redistribute it and/or                  *\n *  modify it under the terms of the GNU Lesser General Public License as   *\n *  published by the Free Software Foundation, either version 3 of the      *\n *  License, or (at your option) any later version.                         *\n *                                                                          *\n *  DMTCP is distributed in the hope that it will be useful,                *\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of          *\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *\n *  GNU Lesser General Public License for more details.                     *\n *                                                                          *\n *  You should have received a copy of the GNU Lesser General Public        *\n *  License along with DMTCP:dmtcp/src.  If not, see                        *\n *  <http://www.gnu.org/licenses/>.                                         *\n ****************************************************************************/\n\n#ifndef SHARED_DATA_H\n#define SHARED_DATA_H\n\n#include <sys/types.h>\n#include <sys/un.h>\n#include <netdb.h>\n#include <arpa/inet.h>\n#include <linux/limits.h>\n#include \"dmtcp.h\"\n#include \"dmtcpalloc.h\"\n\n#define PTS_PATH_MAX 32\n#define MAX_PID_MAPS 32768\n#define MAX_IPC_ID_MAPS 256\n#define MAX_PTY_NAME_MAPS 256\n#define MAX_PTRACE_ID_MAPS 256\n#define MAX_INCOMING_CONNECTIONS 10240\n#define MAX_INODE_PID_MAPS 10240\n#define CON_ID_LEN \\\n  (sizeof(DmtcpUniqueProcessId) + sizeof(int64_t))\n\n#define SHM_VERSION_STR \"DMTCP_GLOBAL_AREA_V0.99\"\n#define VIRT_PTS_PREFIX_STR \"/dev/pts/v\"\n\n#define SYSV_SHM_ID 1\n#define SYSV_SEM_ID 2\n#define SYSV_MSQ_ID 3\n#define SYSV_SHM_KEY 4\n\nnamespace dmtcp {\n\n  typedef struct CoordinatorInfo {\n    DmtcpUniqueProcessId     id;\n    uint64_t                 timeStamp;\n    uint32_t                 interval;\n    uint32_t                 addrLen;\n    struct sockaddr_storage  addr;\n  } CoordinatorInfo;\n\n  namespace SharedData {\n\n    struct PidMap {\n      pid_t virt;\n      pid_t real;\n    };\n\n    struct IPCIdMap {\n      int32_t virt;\n      int32_t real;\n    };\n\n    struct PtyNameMap {\n      char virt[PTS_PATH_MAX];\n      char real[PTS_PATH_MAX];\n    };\n\n    struct IncomingConMap {\n      char                 id[CON_ID_LEN];\n      struct sockaddr_un   addr;\n      socklen_t            len;\n    };\n\n    struct PtraceIdMaps {\n      pid_t tracerId;\n      pid_t childId;\n    };\n\n    typedef struct InodeConnIdMap {\n      uint64_t devnum;\n      uint64_t inode;\n      char  id[CON_ID_LEN];\n    } InodeConnIdMap;\n\n    struct Header {\n      char                 tmpDir[PATH_MAX];\n      char                 installDir[PATH_MAX];\n\n      uint64_t             initialized;\n      struct in_addr       localIPAddr;\n\n      int64_t              dlsymOffset;\n      int64_t              dlsymOffset_m32;\n\n      uint64_t             numPidMaps;\n      uint64_t             numPtraceIdMaps;\n\n      uint64_t             numSysVShmIdMaps;\n      uint64_t             numSysVSemIdMaps;\n      uint64_t             numSysVMsqIdMaps;\n      uint64_t             numSysVShmKeyMaps;\n\n      uint64_t             numPtyNameMaps;\n      uint64_t             nextPtyName;\n      uint64_t             nextVirtualPtyId;\n\n      uint64_t             numIncomingConMaps;\n      uint64_t             numInodeConnIdMaps;\n\n      uint64_t             logMask;\n\n      struct PidMap        pidMap[MAX_PID_MAPS];\n      struct IPCIdMap      sysvShmIdMap[MAX_IPC_ID_MAPS];\n      struct IPCIdMap      sysvSemIdMap[MAX_IPC_ID_MAPS];\n      struct IPCIdMap      sysvMsqIdMap[MAX_IPC_ID_MAPS];\n      struct IPCIdMap      sysvShmKeyMap[MAX_IPC_ID_MAPS];\n      struct PtraceIdMaps  ptraceIdMap[MAX_PTRACE_ID_MAPS];\n      struct PtyNameMap    ptyNameMap[MAX_PTY_NAME_MAPS];\n      struct IncomingConMap incomingConMap[MAX_INCOMING_CONNECTIONS];\n      InodeConnIdMap       inodeConnIdMap[MAX_INODE_PID_MAPS];\n\n      char                 versionStr[32];\n      DmtcpUniqueProcessId compId;\n      CoordinatorInfo      coordInfo;\n      //char                 coordHost[NI_MAXHOST];\n    };\n\n    bool initialized();\n\n    void initialize(const char *tmpDir,\n                    const char *installDir,\n                    DmtcpUniqueProcessId *compId,\n                    CoordinatorInfo *coordInfo,\n                    struct in_addr *localIP);\n    void initializeHeader(const char *tmpDir,\n                          const char *installDir,\n                          DmtcpUniqueProcessId *compId,\n                          CoordinatorInfo *coordInfo,\n                          struct in_addr *localIP);\n\n    bool isSharedDataRegion(void *addr);\n    void prepareForCkpt();\n    void writeCkpt();\n    void postRestart();\n\n    string coordHost();\n    uint32_t coordPort();\n    void getCoordAddr(struct sockaddr *addr, uint32_t *len);\n    void setCoordHost(struct in_addr *in);\n    uint64_t getCoordTimeStamp();\n\n    string getTmpDir();\n    char *getTmpDir(char *buf, uint32_t len);\n    string getInstallDir();\n    uint32_t getCkptInterval();\n    void updateGeneration(uint32_t generation);\n    DmtcpUniqueProcessId getCompId();\n    DmtcpUniqueProcessId getCoordId();\n\n    void getLocalIPAddr(struct in_addr *in);\n\n    void updateDlsymOffset(int32_t dlsymOffset, int32_t dlsymOffset_m32 = 0);\n    int32_t getDlsymOffset(void);\n    int32_t getDlsymOffset_m32(void);\n\n    int32_t  getRealIPCId(int type, int32_t virt);\n    void setIPCIdMap(int type, int32_t virt, int32_t real);\n\n    pid_t  getRealPid(pid_t virt);\n    void setPidMap(pid_t virt, pid_t real);\n\n    pid_t getPtraceVirtualId(pid_t tracerId);\n    void setPtraceVirtualId(pid_t tracerId, pid_t childId);\n\n    void getRealPtyName(const char* virt, char* out, uint32_t len);\n    void getVirtPtyName(const char* real, char *out, uint32_t len);\n    void createVirtualPtyName(const char* real, char *out, uint32_t len);\n    void setVirtualPtyId(uint32_t id);\n    uint32_t getVirtualPtyId();\n    void insertPtyNameMap(const char* virt, const char* real);\n\n    void registerIncomingCons(vector<const char*>& ids,\n                             struct sockaddr_un receiverAddr,\n                             socklen_t len);\n    void getMissingConMaps(struct IncomingConMap **map, uint32_t *nmaps);\n\n    void insertInodeConnIdMaps(vector<InodeConnIdMap>& maps);\n    bool getCkptLeaderForFile(dev_t devnum, ino_t inode, void *id);\n    uint32_t getLogMask(void);\n    void setLogMask(uint32_t mask);\n  }\n}\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/plugin/ptrace/ptracewrappers.cpp": "/*****************************************************************************\n *   Copyright (C) 2008-2013 Ana-Maria Visan, Kapil Arya, and Gene Cooperman *\n *   amvisan@cs.neu.edu, kapil@cs.neu.edu, and gene@ccs.neu.edu              *\n *                                                                           *\n *  This file is part of the PTRACE plugin of DMTCP (DMTCP:plugin/ptrace).   *\n *                                                                           *\n *  DMTCP:mtcp is free software: you can redistribute it and/or              *\n *  modify it under the terms of the GNU Lesser General Public License as    *\n *  published by the Free Software Foundation, either version 3 of the       *\n *  License, or (at your option) any later version.                          *\n *                                                                           *\n *  DMTCP:plugin/ptrace is distributed in the hope that it will be useful,   *\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of           *\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the            *\n *  GNU Lesser General Public License for more details.                      *\n *                                                                           *\n *  You should have received a copy of the GNU Lesser General Public         *\n *  License along with DMTCP:dmtcp/src.  If not, see                         *\n *  <http://www.gnu.org/licenses/>.                                          *\n *****************************************************************************/\n\n/************************************************************************\n * For ARM, ptrace support, and especially PTRACE_SINGLESTEP was added\n * only recently (3/2013):\n *     https://bugs.eclipse.org/bugs/show_bug.cgi?id=403422\n *     https://bugs.eclipse.org/bugs/show_bug.cgi?id=404253\n *     http://stackoverflow.com/questions/16806276/how-ptrace-implemented-in-arm\n ************************************************************************/\n\n#ifndef _GNU_SOURCE\n# define _GNU_SOURCE /* Needed for syscall declaration */\n#endif\n#define _XOPEN_SOURCE 500 /* _XOPEN_SOURCE >= 500 needed for getsid */\n#include <pthread.h>\n#include <semaphore.h>\n#include <unistd.h>\n#include <sys/syscall.h>\n#include <stdio.h>\n#include <errno.h>\n#include <string.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <sched.h>\n#include <sys/user.h>\n#include <sys/syscall.h>\n#include <sys/mman.h>\n#include <sys/stat.h>\n#include <sys/resource.h>\n#include <fcntl.h>\n#include <thread_db.h>\n\n#include \"ptrace.h\"\n#include \"ptraceinfo.h\"\n#include \"dmtcp.h\"\n#include \"jassert.h\"\n#include \"jfilesystem.h\"\n#include \"util.h\"\n\n// Match up this definition with the one in src/constants.h\n#define DMTCP_FAKE_SYSCALL 1023\n\n#define EFLAGS_OFFSET (64)\n#ifdef __x86_64__\n// Found in /usr/include/asm/ptrace.h for struct pt_regs (alias for user_regs?)\n# define AX_REG rax\n# define ORIG_AX_REG orig_rax\n# define SP_REG rsp\n# define IP_REG rip\n// SIGRETURN_INST_16 is the machine code for the assembly statement syscall.\n// The specific syscall to be detected is sigreturn.\n# define SIGRETURN_INST_16 0x050f\n#elif __i386__\n# define AX_REG eax\n# define ORIG_AX_REG orig_eax\n# define SP_REG esp\n# define IP_REG eip\n// SIGRETURN_INST_16 is the machine code for the assembly statement syscall.\n// The specific syscall to be detected is sigreturn.\n# define SIGRETURN_INST_16 0x80cd\n#elif __arm__\n// Found in /usr/include/asm/ptrace.h, called from /usr/include/linux/ptrace.h\n# define ARM_r0      uregs[0]\n# define ARM_ORIG_r0 uregs[17]\n# define ARM_sp      uregs[13]\n# define ARM_lr      uregs[14]\n# define ARM_pc      uregs[15]\n# define ARM_cpsr    uregs[16]\n// FIXME:  ARM also uses sigreturn.  however, more debugging is needed before\n//         ptrace works for ARM.\n# define SIGRETURN_INST_16 -1\n#elif __aarch64__\n# warning \"TODO: Implementation for ARM64.\"\n/* AArch64 uses PTRACE_GETREGSET */\n# undef PTRACE_GETREGS\n# define PTRACE_GETREGS PTRACE_GETREGSET\n# define SIGRETURN_INST_16 -1\n#define NUM_ARM_REGS 18\n#else\n# error Unknown architecture\n#endif\n\nusing namespace dmtcp;\n\nstatic const unsigned char DMTCP_SYS_sigreturn =  0x77;\nstatic const unsigned char DMTCP_SYS_rt_sigreturn = 0xad;\nstatic const unsigned char linux_syscall[] = { 0xcd, 0x80 };\n\nstatic void ptrace_detach_user_threads ();\nstatic void ptrace_attach_threads(int isRestart);\nstatic void ptrace_wait_for_inferior_to_reach_syscall(pid_t inf, int sysno);\nstatic void ptrace_single_step_thread(Inferior *infInfo, int isRestart);\nstatic PtraceProcState procfs_state(int tid);\n\nextern \"C\" int dmtcp_is_ptracing()\n{\n  return PtraceInfo::instance().isPtracing();\n}\n\nvoid ptrace_process_pre_suspend_user_thread()\n{\n  if (PtraceInfo::instance().isPtracing()) {\n    ptrace_detach_user_threads();\n  }\n}\n\nvoid ptrace_process_resume_user_thread(int isRestart)\n{\n  if (PtraceInfo::instance().isPtracing()) {\n    ptrace_attach_threads(isRestart);\n  }\n  JTRACE(\"Waiting for Sup Attach\") (GETTID());\n  PtraceInfo::instance().waitForSuperiorAttach();\n  JTRACE(\"Done Waiting for Sup Attach\") (GETTID());\n}\n\nstatic void ptrace_attach_threads(int isRestart)\n{\n  pid_t inferior;\n  int status;\n  vector<pid_t> inferiors;\n  Inferior *inf;\n\n  inferiors = PtraceInfo::instance().getInferiorVector(GETTID());\n  if (inferiors.size() == 0) {\n    return;\n  }\n\n  JTRACE(\"Attaching to inferior threads\") (GETTID()) (inferiors.size());\n\n  // Attach to all inferior user threads.\n  for (size_t i = 0; i < inferiors.size(); i++) {\n    inferior = inferiors[i];\n    inf = PtraceInfo::instance().getInferior(inferiors[i]);\n    JASSERT(inf->state() != PTRACE_PROC_INVALID) (GETTID()) (inferior);\n    if (!inf->isCkptThread()) {\n      JASSERT(_real_ptrace(PTRACE_ATTACH, inferior, 0, 0) != -1)\n        (GETTID()) (inferior) (JASSERT_ERRNO);\n      JASSERT(_real_wait4(inferior, &status, __WALL, NULL) != -1)\n        (inferior) (JASSERT_ERRNO);\n      JASSERT(_real_ptrace(PTRACE_SETOPTIONS, inferior, 0,\n                           inf->getPtraceOptions()) != -1)\n        (GETTID()) (inferior) (inf->getPtraceOptions()) (JASSERT_ERRNO);\n\n      // Run all user threads until the end of syscall(DMTCP_FAKE_SYSCALL)\n      PtraceInfo::instance().processPreResumeAttach(inferior);\n      ptrace_wait_for_inferior_to_reach_syscall(inferior, DMTCP_FAKE_SYSCALL);\n    }\n  }\n\n  // Attach to and run all user ckpthreads until the end of syscall(DMTCP_FAKE_SYSCALL)\n  for (size_t i = 0; i < inferiors.size(); i++) {\n    inf = PtraceInfo::instance().getInferior(inferiors[i]);\n    inferior = inferiors[i];\n    if (inf->isCkptThread()) {\n      JASSERT(_real_ptrace(PTRACE_ATTACH, inferior, 0, 0) != -1)\n        (GETTID()) (inferior) (JASSERT_ERRNO);\n      JASSERT(_real_wait4(inferior, &status, __WALL, NULL) != -1)\n        (inferior) (JASSERT_ERRNO);\n      JASSERT(_real_ptrace(PTRACE_SETOPTIONS, inferior, 0,\n                           inf->getPtraceOptions()) != -1)\n        (GETTID()) (inferior) (inf->getPtraceOptions()) (JASSERT_ERRNO);\n\n      // Wait for all inferiors to execute dummy syscall 'DMTCP_FAKE_SYSCALL'.\n      PtraceInfo::instance().processPreResumeAttach(inferior);\n      ptrace_wait_for_inferior_to_reach_syscall(inferior, DMTCP_FAKE_SYSCALL);\n    }\n  }\n\n  // Singlestep all user threads out of the signal handler\n  for (size_t i = 0; i < inferiors.size(); i++) {\n    inferior = inferiors[i];\n    inf = PtraceInfo::instance().getInferior(inferiors[i]);\n    int lastCmd = inf->lastCmd();\n    if (!inf->isCkptThread()) {\n      /* After attach, the superior needs to singlestep the inferior out of\n       * stopthisthread, aka the signal handler. */\n      ptrace_single_step_thread(inf, isRestart);\n      if (inf->isStopped() && (lastCmd == PTRACE_CONT ||\n                                        lastCmd == PTRACE_SYSCALL)) {\n        JASSERT(_real_ptrace(lastCmd, inferior, 0, 0) != -1)\n          (GETTID()) (inferior) (JASSERT_ERRNO);\n      }\n    }\n  }\n\n  // Move ckpthreads to next step (depending on state)\n  for (size_t i = 0; i < inferiors.size(); i++) {\n    inferior = inferiors[i];\n    inf = PtraceInfo::instance().getInferior(inferiors[i]);\n    int lastCmd = inf->lastCmd();\n    if (inf->isCkptThread() && !inf->isStopped() &&\n        (lastCmd == PTRACE_CONT || lastCmd == PTRACE_SYSCALL)) {\n      JASSERT(_real_ptrace(lastCmd, inferior, 0, 0) != -1)\n        (GETTID()) (inferior) (JASSERT_ERRNO);\n    }\n  }\n\n  JTRACE(\"thread done\") (GETTID());\n}\n\nstatic void ptrace_wait_for_inferior_to_reach_syscall(pid_t inferior, int sysno)\n{\n#if defined(__i386__) || defined(__x86_64__)\n  struct user_regs_struct regs;\n#elif defined(__arm__)\n  struct user_regs regs;\n#elif defined(__aarch64__)\n  struct user_pt_regs aarch64_regs;\n  struct iovec iov;\n  iov.iov_base = &aarch64_regs;\n  iov.iov_len = sizeof(aarch64_regs);\n#endif\n  int syscall_number;\n  int status;\n  int count = 0;\n  while (1) {\n    count ++;\n    JASSERT(_real_ptrace(PTRACE_SYSCALL, inferior, 0, 0) == 0)\n      (inferior) (JASSERT_ERRNO);\n    JASSERT(_real_wait4(inferior, &status, __WALL, NULL) == inferior)\n      (inferior) (JASSERT_ERRNO);\n\n#if defined(__aarch64__)\n    JASSERT(_real_ptrace(PTRACE_GETREGS, inferior, 0, (void *)&iov) == 0)\n      (inferior) (JASSERT_ERRNO);\n#else\n    JASSERT(_real_ptrace(PTRACE_GETREGS, inferior, 0, &regs) == 0)\n      (inferior) (JASSERT_ERRNO);\n#endif\n\n#if defined(__i386__) || defined(__x86_64__)\n    syscall_number = regs.ORIG_AX_REG;\n#elif(__arm__)\n    syscall_number = regs.ARM_ORIG_r0;\n#elif(__aarch64__)\n    /* iov.iov_base points to &aarch64_regs, so it's\n     * okay to use it directly here for readability.\n     */\n    syscall_number = aarch64_regs.regs[8];\n#endif\n    if (syscall_number == sysno) {\n      JASSERT(_real_ptrace(PTRACE_SYSCALL, inferior, 0, (void*) 0) == 0)\n        (inferior) (JASSERT_ERRNO);\n      JASSERT(_real_wait4(inferior, &status, __WALL, NULL) == inferior)\n        (inferior) (JASSERT_ERRNO);\n      break;\n    }\n  }\n  return;\n}\n\nstatic void ptrace_single_step_thread(Inferior *inferiorInfo,\n                                      int isRestart)\n{\n#if defined(__i386__) || defined(__x86_64__)\n  struct user_regs_struct regs;\n#elif defined(__arm__)\n  struct user_regs regs;\n#elif defined(__aarch64__)\n  static struct user_pt_regs aarch64_regs;\n  struct iovec iov;\n  iov.iov_base = &aarch64_regs;\n  iov.iov_len = sizeof(aarch64_regs);\n#endif\n  long peekdata;\n  unsigned long addr;\n  unsigned long int eflags;\n\n  pid_t inferior = inferiorInfo->tid();\n  pid_t superior = GETTID();\n  int last_command = inferiorInfo->lastCmd();\n  char inferior_st = inferiorInfo->state();\n\n  while(1) {\n    int status;\n    JASSERT(_real_ptrace(PTRACE_SINGLESTEP, inferior, 0, 0) != -1)\n      (superior) (inferior) (JASSERT_ERRNO);\n    if (_real_wait4(inferior, &status, 0, NULL) == -1) {\n      JASSERT(_real_wait4(inferior, &status, __WCLONE, NULL) != -1)\n        (superior) (inferior) (JASSERT_ERRNO);\n    }\n    if (WIFEXITED(status)) {\n      JTRACE(\"thread is dead\") (inferior) (WEXITSTATUS(status));\n    } else if(WIFSIGNALED(status)) {\n      JTRACE(\"thread terminated by signal\") (inferior);\n    }\n\n#if defined(__aarch64__)\n    JASSERT(_real_ptrace(PTRACE_GETREGS, inferior, 0, (void *)&iov) != -1)\n      (superior) (inferior) (JASSERT_ERRNO);\n#else\n    JASSERT(_real_ptrace(PTRACE_GETREGS, inferior, 0, &regs) != -1)\n      (superior) (inferior) (JASSERT_ERRNO);\n#endif\n\n#ifdef __x86_64__\n    /* For 64 bit architectures. */\n    peekdata = _real_ptrace(PTRACE_PEEKDATA, inferior, (void*) regs.IP_REG, 0);\n    long inst = peekdata & 0xffff;\n    if (inst == SIGRETURN_INST_16 && regs.AX_REG == 0xf)\n#elif __i386__\n    /* For 32 bit architectures.*/\n    peekdata = _real_ptrace(PTRACE_PEEKDATA, inferior, (void*) regs.IP_REG, 0);\n    long inst = peekdata & 0xffff;\n    if (inst == SIGRETURN_INST_16 && (regs.AX_REG == DMTCP_SYS_sigreturn ||\n                                      regs.AX_REG == DMTCP_SYS_rt_sigreturn))\n#elif __arm__\n    /* For ARM architectures. */\n    peekdata = _real_ptrace(PTRACE_PEEKDATA, inferior, (void*) regs.ARM_pc, 0);\n    long inst = peekdata & 0xffff;\n    if (inst == SIGRETURN_INST_16 && regs.ARM_r0 == 0xf)\n#elif __aarch64__\n    /* For ARM64 architectures. */\n    /* Check if we are returning from a checkpoint signal.\n     */\n# warning \"TODO: Implementation for ARM64.\"\n    peekdata = _real_ptrace(PTRACE_PEEKDATA, inferior, (void*) aarch64_regs.pc, 0);\n    long inst = peekdata & 0xffff;\n    if (inst == SIGRETURN_INST_16 && aarch64_regs.regs[0] == 0xf)\n#endif\n    {\n      if (isRestart) { /* Restart time. */\n        // FIXME: TODO:\n        if (last_command == PTRACE_SINGLESTEP) {\n#if defined(__i386__) || defined(__x86_64__)\n          if (regs.AX_REG != DMTCP_SYS_rt_sigreturn) {\n            addr = regs.SP_REG;\n          } else {\n            addr = regs.SP_REG + 8;\n            addr = _real_ptrace(PTRACE_PEEKDATA, inferior, (void*) addr, 0);\n            addr += 20;\n          }\n#elif defined(__arm__)\n          if (regs.ARM_r0 != DMTCP_SYS_rt_sigreturn) {\n            addr = regs.ARM_sp;\n          } else {\n            addr = regs.ARM_sp + 8;\n            addr = _real_ptrace(PTRACE_PEEKDATA, inferior, (void*) addr, 0);\n            addr += 20;\n          }\n#endif\n          addr += EFLAGS_OFFSET;\n          errno = 0;\n          JASSERT ((int) (eflags = _real_ptrace(PTRACE_PEEKDATA, inferior,\n                                         (void *)addr, 0)) != -1)\n            (superior) (inferior) (JASSERT_ERRNO);\n          eflags |= 0x0100;\n          JASSERT(_real_ptrace(PTRACE_POKEDATA, inferior, (void *)addr,\n                              (void*) eflags) != -1)\n            (superior) (inferior) (JASSERT_ERRNO);\n        } else if (inferior_st != PTRACE_PROC_TRACING_STOP) {\n          /* TODO: remove in future as GROUP restore becames stable\n           *                                                    - Artem */\n          JASSERT(_real_ptrace(PTRACE_CONT, inferior, 0, 0) != -1)\n            (superior) (inferior) (JASSERT_ERRNO);\n        }\n      } else { /* Resume time. */\n        if (inferior_st != PTRACE_PROC_TRACING_STOP) {\n          JASSERT(_real_ptrace(PTRACE_CONT, inferior, 0, 0) != -1)\n            (superior) (inferior) (JASSERT_ERRNO);\n        }\n      }\n\n      /* In case we have checkpointed at a breakpoint, we don't want to\n       * hit the same breakpoint twice. Thus this code. */\n      // TODO: FIXME: Replace this code with a raise(SIGTRAP) and see what happens\n      if (inferior_st == PTRACE_PROC_TRACING_STOP) {\n        JASSERT(_real_ptrace(PTRACE_SINGLESTEP, inferior, 0, 0) != -1)\n          (superior) (inferior) (JASSERT_ERRNO);\n        if (_real_wait4(inferior, &status, 0, NULL) == -1) {\n          JASSERT(_real_wait4(inferior, &status, __WCLONE, NULL) != -1)\n            (superior) (inferior) (JASSERT_ERRNO);\n        }\n      }\n      break;\n    }\n  } //while(1)\n}\n\n/* This function detaches the user threads. */\nstatic void ptrace_detach_user_threads ()\n{\n  PtraceProcState pstate;\n  int status;\n  struct rusage rusage;\n  vector<pid_t> inferiors;\n  Inferior *inf;\n\n  inferiors = PtraceInfo::instance().getInferiorVector(GETTID());\n\n  for (size_t i = 0; i < inferiors.size(); i++) {\n    pid_t inferior = inferiors[i];\n    inf = PtraceInfo::instance().getInferior(inferiors[i]);\n    void *data = (void*) (unsigned long) dmtcp_get_ckpt_signal();\n    pstate = procfs_state(inferiors[i]);\n    if (pstate == PTRACE_PROC_INVALID) {\n      JTRACE(\"Inferior does not exist.\") (inferior);\n      PtraceInfo::instance().eraseInferior(inferior);\n      continue;\n    }\n    inf->setState(pstate);\n    inf->semInit();\n\n    if (inf->isCkptThread()) {\n      data = NULL;\n    }\n    int ret = _real_wait4(inferior, &status, __WALL | WNOHANG, &rusage);\n    if (ret > 0) {\n      if (!WIFSTOPPED(status) || WSTOPSIG(status) != dmtcp_get_ckpt_signal()) {\n        inf->setWait4Status(&status, &rusage);\n      }\n    }\n    pstate = procfs_state(inferiors[i]);\n    if (pstate == PTRACE_PROC_RUNNING || pstate == PTRACE_PROC_SLEEPING) {\n      syscall(SYS_tkill, inferior, SIGSTOP);\n      _real_wait4(inferior, &status, __WALL, NULL);\n      JASSERT(_real_wait4(inferior, &status, __WALL | WNOHANG, NULL) == 0)\n        (inferior) (JASSERT_ERRNO);\n    }\n    if (_real_ptrace(PTRACE_DETACH, inferior, 0, data) == -1) {\n      JASSERT(errno == ESRCH)\n        (GETTID()) (inferior) (JASSERT_ERRNO);\n      PtraceInfo::instance().eraseInferior(inferior);\n      continue;\n    }\n    pstate = procfs_state(inferiors[i]);\n    if (pstate == PTRACE_PROC_STOPPED) {\n      kill(inferior, SIGCONT);\n    }\n    JTRACE(\"Detached thread\") (inferior);\n  }\n}\n\nstatic PtraceProcState procfs_state(int pid)\n{\n  int fd;\n  char buf[512];\n  char *str;\n  const char *key = \"State:\";\n  int len = strlen(key);\n\n  snprintf (buf, sizeof (buf), \"/proc/%d/status\", (int) pid);\n  fd = _real_open (buf, O_RDONLY, 0);\n  if (fd < 0) {\n    JTRACE(\"open() failed\") (buf);\n    return PTRACE_PROC_INVALID;\n  }\n\n\n  Util::readAll(fd, buf, sizeof buf);\n  close(fd);\n  str = strstr(buf, key);\n  JASSERT(str != NULL);\n  str += len;\n\n  while (*str == ' ' || *str == '\\t') {\n    str++;\n  }\n\n  if (strcasestr(str, \"T (stopped)\") != NULL) {\n    return PTRACE_PROC_STOPPED;\n  } else if (strcasestr(str, \"T (tracing stop)\") != NULL) {\n    return PTRACE_PROC_TRACING_STOP;\n  } else if (strcasestr(str, \"S (sleeping)\") != NULL ||\n             strcasestr(str, \"D (disk sleep)\") != NULL) {\n    return PTRACE_PROC_SLEEPING;\n  } else if (strcasestr(str, \"R (running)\") != NULL) {\n    return PTRACE_PROC_RUNNING;\n  }\n  return PTRACE_PROC_UNDEFINED;\n}\n\n\n/*****************************************************************************\n ****************************************************************************/\n\nextern \"C\" pid_t waitpid(pid_t pid, int *stat, int options)\n{\n  return wait4(pid, stat, options, NULL);\n}\n\nextern \"C\" pid_t wait4(pid_t pid, void *stat, int options,\n                       struct rusage *rusage)\n{\n  int status;\n  struct rusage rusagebuf;\n  pid_t retval;\n  int *stat_loc = (int*) stat;\n  bool repeat = false;\n\n  if (stat_loc == NULL) {\n    stat_loc = &status;\n  }\n\n  if (rusage == NULL) {\n    rusage = &rusagebuf;\n  }\n\n  retval = PtraceInfo::instance().getWait4Status(pid, stat_loc, rusage);\n  if (retval != -1) {\n    return retval;\n  }\n\n  do {\n    retval = _real_wait4(pid, stat_loc, options, rusage);\n    DMTCP_PLUGIN_DISABLE_CKPT();\n    if (retval > 0 && PtraceInfo::instance().isInferior(retval)) {\n      if (WIFSTOPPED(*stat_loc) && WSTOPSIG(*stat_loc) == dmtcp_get_ckpt_signal()) {\n        /* Inferior got STOPSIGNAL, this should not be passed to gdb process as\n         * we are performing checkpoint at this time. We should reexecute the\n         * _real_wait4 to get the status that the gdb process would want to\n         * process.\n         */\n        repeat = true;\n      } else if (WIFSTOPPED(*stat_loc)) {\n        PtraceInfo::instance().setLastCmd(retval, -1);\n      } else if (WIFEXITED(*stat_loc) || WIFSIGNALED(*stat_loc)) {\n        PtraceInfo::instance().eraseInferior(retval);\n      }\n    }\n    DMTCP_PLUGIN_ENABLE_CKPT();\n  } while (repeat);\n\n  return retval;\n}\n\nextern \"C\" long ptrace (enum __ptrace_request request, ...)\n{\n  va_list ap;\n  pid_t pid;\n  void *addr;\n  void *data;\n\n  va_start(ap, request);\n  pid = va_arg(ap, pid_t);\n  addr = va_arg(ap, void *);\n  data = va_arg(ap, void *);\n  va_end(ap);\n\n  DMTCP_PLUGIN_DISABLE_CKPT();\n  PtraceInfo::instance().setPtracing();\n\n  long ptrace_ret =  _real_ptrace(request, pid, addr, data);\n\n  if (ptrace_ret != -1) {\n    PtraceInfo::instance().processSuccessfulPtraceCmd(request, pid,\n                                                             addr, data);\n  }\n\n  DMTCP_PLUGIN_ENABLE_CKPT();\n  return ptrace_ret;\n}\n\n/*****************************************************************************\n ****************************************************************************/\ntypedef td_err_e (*td_thr_get_info_funcptr_t)(const td_thrhandle_t *,\n                                              td_thrinfo_t *);\nstatic td_thr_get_info_funcptr_t td_thr_get_info_funcptr = NULL;\n\nstatic td_err_e dmtcp_td_thr_get_info (const td_thrhandle_t *th_p,\n                                       td_thrinfo_t *ti_p)\n{\n  td_err_e td_err;\n\n  td_err = (*td_thr_get_info_funcptr)(th_p, ti_p);\n\n  if (th_p->th_unique != 0 || (int) ti_p->ti_lid < 40000) {\n    JASSERT(dmtcp_real_to_virtual_pid != NULL);\n    pid_t virtPid =  dmtcp_real_to_virtual_pid((int)ti_p->ti_lid);\n    JASSERT(virtPid != (int) ti_p->ti_lid) (virtPid);\n    ti_p->ti_lid  =  (lwpid_t) virtPid;\n  }\n\n  //ti_p->ti_lid  =  (lwpid_t) REAL_TO_VIRTUAL_PID ((int) ti_p->ti_lid);\n  //ti_p->ti_tid =  (thread_t) REAL_TO_VIRTUAL_PID ((int) ti_p->ti_tid);\n  return td_err;\n}\n\n/* gdb calls dlsym on td_thr_get_info.  We need to wrap td_thr_get_info for\n   tid virtualization. It should be safe to comment this out if you don't\n   need to checkpoint gdb.\n*/\nextern \"C\" void *dlsym (void *handle, const char *symbol)\n{\n  static __typeof__(&dlsym) libc_dlsym_fnptr = NULL;\n  if (libc_dlsym_fnptr == NULL) {\n    libc_dlsym_fnptr = (__typeof__(&dlsym)) dmtcp_get_libc_dlsym_addr();\n  }\n\n  void *fptr = libc_dlsym_fnptr(handle, symbol);\n\n  if (strcmp (symbol, \"td_thr_get_info\") == 0 && fptr != NULL) {\n    td_thr_get_info_funcptr = (td_thr_get_info_funcptr_t) fptr;\n    return (void *) &dmtcp_td_thr_get_info;\n  }\n\n  return fptr;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/plugin/batch-queue/rm_torque.cpp": "/****************************************************************************\n *  Copyright (C) 2012-2014 by Artem Y. Polyakov <artpol84@gmail.com>       *\n *                                                                          *\n *  This file is part of the RM plugin for DMTCP                            *\n *                                                                          *\n *  RM plugin is free software: you can redistribute it and/or              *\n *  modify it under the terms of the GNU Lesser General Public License as   *\n *  published by the Free Software Foundation, either version 3 of the      *\n *  License, or (at your option) any later version.                         *\n *                                                                          *\n *  RM plugin is distributed in the hope that it will be useful,            *\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of          *\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *\n *  GNU Lesser General Public License for more details.                     *\n *                                                                          *\n *  You should have received a copy of the GNU Lesser General Public        *\n *  License along with DMTCP:dmtcp/src.  If not, see                        *\n *  <http://www.gnu.org/licenses/>.                                         *\n ****************************************************************************/\n\n/* Update by Kapil Arya to create the Torque DMTCP plugin. */\n\n/* The Torque PBS resource manager supporting code.\n\n   Torque PBS contains the libtorque library, which provides an API for\n   communication with the MOM Node management servers.  The library obtains\n   information about the allocated resources and uses it.  In particular the\n   spawn programs on the remote nodes use tm_spawn.\n\n   To keep track of and control all processes spawned using any method (such as\n   exec, ssh), we also need to wrap the tm_spawn function.\n*/\n\n\n#include <stdlib.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <pthread.h>\n#include <vector>\n#include <list>\n#include <string>\n#include \"util.h\"\n#include \"procmapsarea.h\"\n#include \"jalib.h\"\n#include \"jassert.h\"\n#include \"jconvert.h\"\n#include \"jfilesystem.h\"\n#include \"rm_main.h\"\n#include \"rm_utils.h\"\n#include \"rm_torque.h\"\n\n// -------------------- Torque PBS tm.h definitions -------------------------//\n// Keep in sync with \"tm.h\" file in the libtorque library of the Torque PBS\n//   resource manager.\n#define TM_SUCCESS  0\n#define TM_ESYSTEM  17000\n#define TM_ENOEVENT  17001\n#define TM_ENOTCONNECTED 17002\n#define TM_EUNKNOWNCMD  17003\n#define TM_ENOTIMPLEMENTED 17004\n#define TM_EBADENVIRONMENT 17005\n#define TM_ENOTFOUND  17006\n#define TM_BADINIT  17007\n\nusing namespace dmtcp;\n\ntypedef int tm_node_id;\ntypedef int tm_task_id;\ntypedef int  tm_event_t;\n\nstatic pthread_mutex_t _libtorque_mutex = PTHREAD_MUTEX_INITIALIZER;\nstatic void *_libtorque_handle = NULL;\ntypedef int (*tm_spawn_t)(int argc, char **argv, char **envp, tm_node_id where, tm_task_id *tid, tm_event_t *event);\ntm_spawn_t tm_spawn_ptr;\n\nstatic void setup_job();\nstatic string torque_home_nodefile(char *ptr);\nstatic void setup_torque_env();\n\nstatic string &torque_home(){\n  static string inst = \"\"; return inst;\n}\n\nstatic string &torque_jobname(){\n  static string inst = \"\"; return inst;\n}\nunsigned long torque_jobid = 0;\n\n//--------------------- Torque/PBS initialization  -------------//\n\nvoid dmtcp::probeTorque()\n{\n  JTRACE(\"Start\");\n  if( (getenv(\"PBS_ENVIRONMENT\") != NULL) && (NULL != getenv(\"PBS_JOBID\")) ){\n    JTRACE(\"We run under Torque PBS!\");\n    // TODO: Do we need locking here?\n    //JASSERT(_real_pthread_mutex_lock(&global_mutex) == 0);\n    _set_rmgr_type(torque);\n    // Set up the Torque PBS home dir.\n    setup_torque_env();\n    setup_job();\n    // TODO: Do we need locking here?\n    //JASSERT(_real_pthread_mutex_unlock(&global_mutex) == 0);\n  }\n}\n\nstatic int queryPbsConfig(string option, string &pbs_config)\n{\n  int fds[2];\n  const char *pbs_config_path = \"pbs-config\";\n  static const char *pbs_config_args[] = { \"pbs-config\", option.c_str(), NULL };\n  int cpid;\n\n  if( pipe(fds) == -1){\n    // Just go away - we cannot serve this request.\n    JTRACE(\"Cannot create pipe to execute pbs-config to find Torque/PBS library!\");\n    return -1;\n  }\n\n  cpid = _real_fork();\n\n  if( cpid < 0 ){\n    JTRACE( \"ERROR: cannot execute pbs-config. Will not run tm_spawn!\");\n    return -1;\n  }\n  if( cpid == 0 ){\n    JTRACE ( \"child process, will exec into external de-compressor\");\n    fds[1] = _real_dup(_real_dup(_real_dup(fds[1])));\n    close(fds[0]);\n    JASSERT(_real_dup2(fds[1], STDOUT_FILENO) == STDOUT_FILENO);\n    close(fds[1]);\n    _real_execvp(pbs_config_path, (char **)pbs_config_args);\n    /* should not get here */\n    JASSERT(false)(\"ERROR: Failed to exec pbs-config. tm_spawn will fail with TM_BADINIT\")(strerror(errno));\n    exit(0);\n  }\n\n  /* parent process */\n  JTRACE ( \"created child process for pbs-config\")(cpid);\n  int status;\n  if( waitpid(cpid,&status,0) < 0 ){\n    return -1;\n  }\n  if( !( WIFEXITED(status) && WEXITSTATUS(status) == 0 ) ){\n    return -1;\n  }\n\n  // set descriptor as non-blocking\n  // JTRACE ( \"Set pipe fds[0] as non-blocking\");\n  int flags = fcntl(fds[0], F_GETFL);\n  fcntl(fds[0], F_SETFL, flags | O_NONBLOCK);\n\n  //JTRACE ( \"Read pbs-config output from pipe\");\n  pbs_config = \"\";\n  char buf[256];\n  int count = 0;\n  while( (count = read(fds[0], buf, 255)) > 0 ){\n    buf[count] = '\\0';\n    pbs_config += string() + buf;\n  }\n\n  JTRACE ( \"pbs-config output:\")(pbs_config);\n  return 0;\n}\n\nint findLibTorque_pbsconfig(string &libpath)\n{\n  // Config looks like: \"-L<libpath> -l<libname> -Wl,--rpath -Wl,<libpath>\"\n  // We will search for the first libpath and the first libname.\n  string libname, config;\n\n  if( queryPbsConfig(\"--libs\",config) ){\n    // failed to read pbs-config\n    return -1;\n  }\n\n  bool name_found = false, path_found = false;\n  vector<string> params;\n  string delim = \" \\n\\t\";\n  params.clear();\n  libpath = \" \";\n  libname = \" \";\n\n  size_t first = config.find_first_not_of(delim);\n  while( first != string::npos ){\n    size_t last = config.find_first_of(delim,first);\n    if( last != string::npos ){\n      string s(config,first,last-first);\n      params.push_back(s);\n      first = config.find_first_not_of(delim,last);\n    }else{\n      first = string::npos;\n    }\n  }\n\n  // get -L & -l arguments\n  for (size_t i = 0; i < params.size(); i++) {\n    string &s = params[i];\n    if (s[0] == '-') {\n      if (s[1] == 'L') {\n        string tmp(s,2,s.size() - 2);\n        libpath = tmp;\n        path_found = true;\n      } else if (s[1] == 'l') {\n        string tmp(s,2,s.size() - 2);\n        libname = tmp;\n        name_found = true;\n      }\n    }\n  }\n\n  if( name_found && path_found ){\n      // construct full torque library path\n    libpath += \"/lib\" + libname + \".so\";\n    JTRACE(\"Torque PBS libpath\")(libpath);\n    return 0;\n  } else {\n    return -1;\n  }\n}\n\nint findLibTorque(string &libpath)\n{\n  bool found = false;\n  string pattern = \"libtorque\";\n  if( !findLib_byname(pattern, libpath) ){\n    found = true;\n  }else if( !findLibTorque_pbsconfig(libpath) ){\n    found = true;\n  }\n\n  JTRACE(\"Torque PBS libpath\")(libpath);\n  return !found;\n}\n\n// -------------- This functions probably should run with global_mutex locked! -----------------------//\n\nstatic void setup_job()\n{\n  char *ptr;\n  if ((ptr = getenv(\"PBS_JOBID\"))){\n    string str = ptr, digits = \"0123456789\";\n    size_t pos = str.find_first_not_of(digits);\n    char *eptr;\n    str = str.substr(0,pos);\n    torque_jobid = strtoul(str.c_str(),&eptr,10);\n  }\n\n  if ((ptr = getenv(\"PBS_JOBNAME\"))) {\n    torque_jobname() = ptr;\n  }\n  JTRACE(\"Result:\")(torque_jobid)(torque_jobname());\n}\n\n\nstatic string torque_home_nodefile(char *ptr)\n{\n  // Usual nodefile path is: $PBS_HOME/aux/nodefile-name\n  string nodefile = ptr;\n  // clear nodefile path from duplicated slashes\n  _rm_clear_path(nodefile);\n\n  // start of file name entry\n  size_t file_start = nodefile.find_last_of(\"/\\\\\");\n  if( file_start == string::npos || file_start == 0 ){\n    JTRACE(\"No slashes in the nodefile path\");\n    return \"\";\n  }\n  // start of aux entry\n  size_t aux_start = nodefile.find_last_of(\"/\\\\\", file_start-1);\n  if( aux_start == string::npos || aux_start == 0 ){\n    JTRACE(\"Only one slash exist in nodefile path\");\n    return \"\";\n  }\n\n  string aux_name = nodefile.substr(aux_start+1, file_start - (aux_start+1));\n\n  JTRACE(\"Looks like we can grap PBS_HOME from PBS_NODEFILE\")(nodefile)(file_start)(aux_start)(aux_name);\n\n  // Last check: if lowest file directory is \"aux\"\n  if( aux_name != \"aux\" ){\n    JTRACE(\"Wrong aux name\");\n    return \"\";\n  }\n\n  return nodefile.substr(0,aux_start);\n}\n\nstatic void setup_torque_env()\n{\n  char *ptr;\n  if ((ptr = getenv(\"PBS_HOME\"))) {\n    torque_home() = ptr;\n  }else if ((ptr = getenv(\"PBS_SERVER_HOME\"))) {\n    torque_home() = ptr;\n  } else if ((ptr = getenv(\"PBS_NODEFILE\"))) {\n      torque_home() = torque_home_nodefile(ptr);\n  }\n\n  if( torque_home().size() ){\n    _rm_clear_path(torque_home());\n    _rm_del_trailing_slash(torque_home());\n  }\n}\n\n// -------------- (END) This functions probably should run with global_mutex locked! (END) -----------------------//\n\n\nbool dmtcp::isTorqueFile(string relpath, string &path)\n{\n  JTRACE(\"Start\");\n  switch( _get_rmgr_type() ){\n  case Empty:\n    probeTorque();\n    if( _get_rmgr_type() != torque )\n      return false;\n    break;\n  case torque:\n    break;\n  default:\n    return false;\n  }\n\n  if( torque_home().size() == 0 )\n    return false;\n\n  string abspath = torque_home() + \"/\" + relpath;\n  JTRACE(\"Compare path with\")(path)(abspath);\n  if( path.size() < abspath.size() )\n    return false;\n\n  if( path.substr(0,abspath.size()) == abspath )\n    return true;\n\n  return false;\n}\n\nbool dmtcp::isTorqueHomeFile(string &path)\n{\n  // Check if the file is in the home directory.\n  char *ptr;\n  string hpath = \"\";\n\n  if ((ptr = getenv(\"HOME\"))) {\n    hpath = string() + ptr;\n    JTRACE(\"Home directory:\")(hpath)(path);\n  }else{\n    JTRACE(\"Cannot determine user HOME directory!\");\n    return false;\n  }\n\n  if( hpath.size() >= path.size() ){\n    JTRACE(\"Length of path is less than home dir\");\n    return false;\n  }\n\n  if( path.substr(0,hpath.size()) != hpath ){\n    JTRACE(\"prefix of path is not home directory\")(path)(hpath);\n    return false;\n  }\n\n  string suffix1 = \".OU\", suffix2 = \".ER\";\n\n  if( !( (path.substr(path.size() - suffix1.size()) == suffix1) ||\n        (path.substr(path.size() - suffix2.size()) == suffix2) ) ){\n    JTRACE(\"path has no .OU or .ER suffix\")(path);\n    return false;\n  }\n\n  char jobid[256];\n  sprintf(jobid,\"%lu\",torque_jobid);\n  string spool_path = hpath + \"/.pbs_spool/\" + jobid;\n  string home_path = hpath + jobid;\n\n  if( path.substr(0,spool_path.size()) == spool_path ){\n    JTRACE(\"File is located in $HOME/.pbs_spool/. It is Torque/PBS stdio file\")(path);\n    return true;\n  }\n\n  if( path.substr(0,home_path.size()) == home_path ){\n    JTRACE(\"File is located in $HOME/. It is Torque/PBS stdio file\")(path);\n    return true;\n  }\n\n  return false;\n}\n\nbool dmtcp::isTorqueIOFile(string &path)\n{\n  // Check if the file is located in $PBS_HOME/spool\n  // If so, it is the Torque stdio file.\n  if( isTorqueFile(\"spool\", path) )\n    return true;\n\n  if( isTorqueHomeFile(path) ){\n    // Torque can be configured to write directly into a user's home directory.\n    // In this case, we need to check the file pattern:\n  }\n  return false;\n}\n\nbool dmtcp::isTorqueStdout(string &path)\n{\n  if( !isTorqueIOFile(path) )\n    return false;\n\n  string suffix = \".OU\";\n\n  if( (path.substr(path.size() - suffix.size()) == suffix) ){\n    return true;\n  }\n\n  return false;\n}\n\nbool dmtcp::isTorqueStderr(string &path)\n{\n  if( !isTorqueIOFile(path) )\n    return false;\n\n  string suffix = \".ER\";\n\n  if( (path.substr(path.size() - suffix.size()) == suffix) ){\n    return true;\n  }\n\n  return false;\n}\n\nbool dmtcp::isTorqueNodeFile(string &path)\n{\n  // If this file is not located in the $PBS_HOME/aux/ directory,\n  // it can't be node_file.\n  return isTorqueFile(\"aux\", path);\n}\n\n\n//--------------------- Torque/PBS tm_spawn remote exec wrapper -------------//\n\nstatic int libtorque_init()\n{\n  int ret = 0;\n\n  // lock _libtorque_handle\n  JASSERT(_real_pthread_mutex_lock(&_libtorque_mutex) == 0);\n  if( _libtorque_handle == NULL ){\n    // find library using pbs-config\n    string libpath;\n    if( findLibTorque(libpath) ){\n      ret = -1;\n      goto unlock;\n    }\n    // initialize tm_spawn_ptr\n    JTRACE(\"Initialize libtorque dlopen handler\")(libpath);\n    char *error = NULL;\n    _libtorque_handle = _real_dlopen(libpath.c_str(),RTLD_LAZY);\n    if( !_libtorque_handle ){\n      error = dlerror();\n      if( error )\n        JTRACE(\"Cannot open libtorque.so. Will not wrap tm_spawn\")(error);\n      else\n        JTRACE(\"Cannot open libtorque.so. Will not wrap tm_spawn\");\n      ret = -1;\n      goto unlock;\n    }\n\n    dlerror();\n    tm_spawn_ptr = (tm_spawn_t)_real_dlsym(_libtorque_handle, \"tm_spawn\");\n    if( tm_spawn_ptr == NULL ){\n      error = dlerror();\n      if( error )\n        JTRACE(\"Cannot load tm_spawn from libtorque.so. Will not wrap it!\")(error);\n      else\n        JTRACE(\"Cannot load tm_spawn from libtorque.so. Will not wrap it!\");\n      ret = -1;\n      goto unlock;\n    }\n  }\nunlock:\n  JASSERT(_real_pthread_mutex_unlock(&_libtorque_mutex) == 0);\n  return ret;\n}\n\nextern \"C\" int tm_spawn(int argc, char **argv, char **envp, tm_node_id where,\n                        tm_task_id *tid, tm_event_t *event)\n{\n  int ret;\n  JTRACE(\"In tm_spawn wrapper\");\n  if( libtorque_init() )\n    return TM_BADINIT;\n\n  char dmtcpCkptPath[PATH_MAX] = \"\";\n  string ckptCmdPath = Util::getPath(\"dmtcp_launch\");\n  ret = Util::expandPathname(ckptCmdPath.c_str(),\n                                    dmtcpCkptPath, sizeof(dmtcpCkptPath));\n\n  JTRACE(\"Expand dmtcp_launch path\")(dmtcpCkptPath);\n\n  vector<string> dmtcp_args;\n  Util::getDmtcpArgs(dmtcp_args);\n  unsigned int dsize = dmtcp_args.size();\n  const char *new_argv[ argc + (dsize + 1)]; // (dsize+1) args are for DMTCP, including dmtcpCkptPath.\n  string cmdline;\n  size_t i;\n\n  for(i = 0; i < (unsigned) argc; i++){\n      JTRACE(\"arg[i]:\")(i)(argv[i]);\n  }\n\n  new_argv[0] = dmtcpCkptPath;\n  for (i = 0; i < dsize; i++) {\n    new_argv[1 + i] = dmtcp_args[i].c_str();\n  }\n  for (int j = 0; j < argc; j++) {\n    new_argv[(1 + dsize) + j] = argv[j];\n  }\n  for (i = 0; i< dsize + argc + 1; i++ ) {\n    cmdline +=  string() + new_argv[i] + \" \";\n  }\n\n  JTRACE( \"call Torque PBS tm_spawn API to run command on remote host\" )\n        ( argv[0] ) (where);\n  JTRACE(\"CMD:\")(cmdline);\n  ret = tm_spawn_ptr(argc + dsize + 1,(char **)new_argv,envp,where,tid,event);\n\n  return ret;\n}\n\nint dmtcp::torqueShouldCkptFile(const char *path, int *type)\n{\n  string str(path);\n\n  if (isTorqueIOFile(str)) {\n    *type = TORQUE_IO;\n    return 1;\n  } else if (isTorqueNodeFile(str) || *type == TORQUE_NODE) {\n    *type = TORQUE_NODE;\n    return 1;\n  }\n  return 0;\n}\n\n\nint dmtcp::torqueRestoreFile(const char *path, const char *savedFilePath,\n                                     int fcntlFlags, int type)\n{\n  string newpath;\n\n  int tempfd = -1;\n  if (type == TORQUE_NODE) {\n    JTRACE(\"Restore Torque Node file\");\n    char newpath_tmpl[] = \"/tmp/dmtcp_torque_nodefile.XXXXXX\";\n    if (mkstemp(newpath_tmpl) == -1) {\n      strcpy(newpath_tmpl,\"/tmp/dmtcp_torque_nodefile\");\n    }\n    newpath = newpath_tmpl;\n    tempfd = _real_open(newpath.c_str(), O_CREAT | O_WRONLY,\n            (S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP) );\n    JASSERT(tempfd != -1) (path)(newpath)(JASSERT_ERRNO) .Text(\"open() failed\");\n  } else if (type == TORQUE_IO) {\n    string str(path);\n    JTRACE(\"Restore Torque IO file\");\n    if (isTorqueStdout(str)) {\n      JTRACE(\"Restore Torque STDOUT file\");\n      tempfd = 1;\n    } else if (isTorqueStderr(str)) {\n      JTRACE(\"Restore Torque STDERR file\");\n      tempfd = 2;\n    } else{\n      return -1;\n    }\n\n    // get new file name\n    string procpath = \"/proc/self/fd/\" + jalib::XToString(tempfd);\n    newpath = jalib::Filesystem::ResolveSymlink(procpath);\n  }\n\n  JTRACE(\"Copying saved Resource Manager file to NEW location\")\n    (savedFilePath) (newpath);\n\n  string command = \"cat \";\n  command.append(savedFilePath).append(\" > \").append(newpath);\n  JASSERT(_real_system(command.c_str()) != -1);\n\n  // Reopen with initial flags\n  if( type == TORQUE_NODE) {\n    _real_close(tempfd);\n    tempfd = _real_open(newpath.c_str(), fcntlFlags);\n    JASSERT(tempfd != -1) (path)(newpath)(JASSERT_ERRNO) .Text(\"open() failed\");\n  }\n\n  return tempfd;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/plugin/batch-queue/rm_utils.cpp": "/****************************************************************************\n *  Copyright (C) 2012-2014 by Artem Y. Polyakov <artpol84@gmail.com>       *\n *                                                                          *\n *  This file is part of the RM plugin for DMTCP                            *\n *                                                                          *\n *  RM plugin is free software: you can redistribute it and/or              *\n *  modify it under the terms of the GNU Lesser General Public License as   *\n *  published by the Free Software Foundation, either version 3 of the      *\n *  License, or (at your option) any later version.                         *\n *                                                                          *\n *  RM plugin is distributed in the hope that it will be useful,            *\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of          *\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *\n *  GNU Lesser General Public License for more details.                     *\n *                                                                          *\n *  You should have received a copy of the GNU Lesser General Public        *\n *  License along with DMTCP:dmtcp/src.  If not, see                        *\n *  <http://www.gnu.org/licenses/>.                                         *\n ****************************************************************************/\n\n#include <stdlib.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <pthread.h>\n#include <vector>\n#include <list>\n#include <string>\n#include \"util.h\"\n#include \"procmapsarea.h\"\n#include \"procselfmaps.h\"\n#include \"jalib.h\"\n#include \"jassert.h\"\n#include \"jconvert.h\"\n#include \"jfilesystem.h\"\n#include \"rm_main.h\"\n#include \"rm_utils.h\"\n\nusing namespace dmtcp;\n\nint dmtcp::findLib_byname(string pattern, string &libpath)\n{\n  // /proc/self/maps looks like: \"<start addr>-<end addr> <mode> <offset> <device> <inode> <libpath>\n  // we need to extract libpath\n  ProcMapsArea area;\n  int ret = -1;\n\n  ProcSelfMaps procSelfMaps;\n  while (procSelfMaps.getNextArea(&area)) {\n    libpath = area.name;\n    //JTRACE(\"Inspect new /proc/seft/maps line\")(libpath);\n    if( libpath.size() == 0 ){\n      //JTRACE(\"anonymous region, skip\");\n      continue;\n    }\n\n    if( libpath.find(pattern) != string::npos ){\n      // This is the library path that contains libtorque.  This is what we need.\n      //JTRACE(\"Found libpath\")(pattern)(libpath);\n      ret = 0;\n      break;\n    }else{\n      //JTRACE(\"Libpath not found\")(pattern)(libpath);\n    }\n  }\n\n  return ret;\n}\n\nint dmtcp::findLib_byfunc(string fname, string &libpath)\n{\n  // /proc/self/maps looks like: \"<start addr>-<end addr> <mode> <offset> <device> <inode> <libpath>\n  // We need to extract libpath.\n  ProcMapsArea area;\n  int ret = -1;\n\n  ProcSelfMaps procSelfMaps;\n  while (procSelfMaps.getNextArea(&area)) {\n    libpath = area.name;\n    //JTRACE(\"Inspect new /proc/seft/maps line\")(libpath);\n    if( libpath.size() == 0 ){\n      //JTRACE(\"anonymous region, skip\");\n      continue;\n    }\n\n    if( libpath.find(\"libdmtcp\") != string::npos ){\n      //JTRACE(\"dmtcp plugin, skip\")(libpath);\n      continue;\n    }\n\n    void *handle = _real_dlopen(libpath.c_str(),RTLD_LAZY);\n    if( handle == NULL ){\n      //JTRACE(\"Cannot open libpath, skip\")(libpath);\n      continue;\n    }\n    void *fptr = _real_dlsym(handle,fname.c_str());\n    if( fptr != NULL ){\n      // Able to find the requested symbol.\n      //JTRACE(\"Found libpath by content:\")(fname)(libpath);\n      dlclose(handle);\n      ret = 0;\n      break;\n    }\n    dlclose(handle);\n    //JTRACE(\"Function not found in Libpath\")(fname)(libpath);\n  }\n\n  return ret;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/plugin/batch-queue/rm_pmi.cpp": "/****************************************************************************\n *  Copyright (C) 2012-2014 by Artem Y. Polyakov <artpol84@gmail.com>       *\n *                                                                          *\n *  This file is part of the RM plugin for DMTCP                            *\n *                                                                          *\n *  RM plugin is free software: you can redistribute it and/or              *\n *  modify it under the terms of the GNU Lesser General Public License as   *\n *  published by the Free Software Foundation, either version 3 of the      *\n *  License, or (at your option) any later version.                         *\n *                                                                          *\n *  RM plugin is distributed in the hope that it will be useful,            *\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of          *\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *\n *  GNU Lesser General Public License for more details.                     *\n *                                                                          *\n *  You should have received a copy of the GNU Lesser General Public        *\n *  License along with DMTCP:dmtcp/src.  If not, see                        *\n *  <http://www.gnu.org/licenses/>.                                         *\n ****************************************************************************/\n\n#include <stdlib.h>\n#include <linux/limits.h>\n#include <sys/wait.h>\n#include <pthread.h>\n#include <vector>\n#include <list>\n#include <string>\n#include \"util.h\"\n#include \"procmapsarea.h\"\n#include \"jalib.h\"\n#include \"jassert.h\"\n#include \"jconvert.h\"\n#include \"jfilesystem.h\"\n#include \"rm_main.h\"\n#include \"rm_utils.h\"\n#include \"rm_pmi.h\"\n\n#define PMI_SUCCESS                  0\n#define PMI_FAIL                    -1\n#define PMI_ERR_INIT                 1\n#define PMI_ERR_NOMEM                2\n#define PMI_ERR_INVALID_ARG          3\n#define PMI_ERR_INVALID_KEY          4\n#define PMI_ERR_INVALID_KEY_LENGTH   5\n#define PMI_ERR_INVALID_VAL          6\n#define PMI_ERR_INVALID_VAL_LENGTH   7\n#define PMI_ERR_INVALID_LENGTH       8\n#define PMI_ERR_INVALID_NUM_ARGS     9\n#define PMI_ERR_INVALID_ARGS        10\n#define PMI_ERR_INVALID_NUM_PARSED  11\n#define PMI_ERR_INVALID_KEYVALP     12\n#define PMI_ERR_INVALID_SIZE        13\n#define PMI_ERR_INVALID_KVS         14\n\nusing namespace dmtcp;\n\nstatic pthread_mutex_t _lock_lib, _lock_flag;\nstatic void do_lock_lib() {\n  JASSERT(pthread_mutex_lock(&_lock_lib) == 0);\n}\nstatic void do_unlock_lib() {\n  JASSERT(pthread_mutex_unlock(&_lock_lib) == 0);\n}\n\nstatic void do_lock_flag() {\n  JASSERT(pthread_mutex_lock(&_lock_flag) == 0);\n}\nstatic void do_unlock_flag() {\n  JASSERT(pthread_mutex_unlock(&_lock_flag) == 0);\n}\n\nstatic void *handle = NULL;\ntypedef int (*_PMI_Init_t)( int *t );\ntypedef int (*_PMI_Fini_t)(  );\ntypedef int (*_PMI_Barrier_t)(  );\ntypedef int PMI_BOOL;\n#define PMI_TRUE     1\n#define PMI_FALSE    0\ntypedef int (*_PMI_Initialized_t)( PMI_BOOL * );\nstatic _PMI_Init_t _real_PMI_Init = NULL;\nstatic _PMI_Fini_t _real_PMI_Fini = NULL;\nstatic _PMI_Barrier_t _real_PMI_Barrier = NULL;\nstatic _PMI_Initialized_t _real_PMI_Initialized = NULL;\n\nstatic bool pmi_is_used = false;\nstatic bool explicit_srun = false;\n\nstatic bool want_pmi_shutdown()\n{\n    return pmi_is_used && (_get_rmgr_type() == slurm && !explicit_srun );\n}\n\nvoid rm_init_pmi(){\n\n    do_lock_lib();\n    if( !handle ){\n      string pattern = \"libpmi\";\n      string libpath;\n      if( findLib_byname(pattern,libpath) != 0 ){\n        JASSERT( findLib_byfunc(\"PMI_Init\",libpath) == 0);\n      }\n      JTRACE(\"\")(libpath);\n      handle = _real_dlopen(libpath.c_str(),RTLD_LAZY);\n      JASSERT( handle != NULL );\n      _real_PMI_Init = (_PMI_Init_t)_real_dlsym(handle,\"PMI_Init\");\n      JASSERT( _real_PMI_Init != NULL );\n      _real_PMI_Fini = (_PMI_Fini_t)_real_dlsym(handle,\"PMI_Finalize\");\n      JASSERT( _real_PMI_Fini != NULL );\n      _real_PMI_Barrier = (_PMI_Barrier_t)_real_dlsym(handle,\"PMI_Barrier\");\n      JASSERT( _real_PMI_Barrier != NULL );\n      _real_PMI_Initialized = (_PMI_Initialized_t)_real_dlsym(handle,\"PMI_Initialized\");\n      if( _real_PMI_Initialized == NULL ){\n        // eventually smpd of MPICH2 and Intel-MPI uses iPMI_Initialized function\n        _real_PMI_Initialized = (_PMI_Initialized_t)_real_dlsym(handle,\"iPMI_Initialized\");\n      }\n      JASSERT( _real_PMI_Initialized != NULL );\n      if (getenv( ENV_VAR_EXPLICIT_SRUN ) != NULL) {\n        explicit_srun = true;\n      }\n    }\n    do_unlock_lib();\n    JTRACE(\"\")(handle);\n}\n\nextern \"C\" int PMI_Init( int *spawned )\n{\n    if( !_real_PMI_Init ){\n      rm_init_pmi();\n    }\n\n    if( ! pmi_is_used ){\n      do_lock_flag();\n      pmi_is_used = true;\n      do_unlock_flag();\n    }\n    int ret = _real_PMI_Init(spawned);\n    JTRACE(\"\")(_real_PMI_Init)(ret);\n    return ret;\n}\n\n// Intel MPI uses dlopen() and dlsym() to find pmi functions.\n// We need to redirect PMI_Init() to our wrapper, so that\n// pmi is correctly initialized.\nextern \"C\" void *dlsym(void *handle, const char *symbol)\n{\n  // Suppress nonnull_compare errors, by using new_symbol.\n  const char* new_symbol = symbol;\n  if (new_symbol && strcmp(symbol, \"PMI_Init\") == 0) {\n    return (void *)PMI_Init;\n  }\n  return _real_dlsym(handle, symbol);\n}\n\nint rm_shutdown_pmi()\n{\n  int ret = 0;\n\n  JTRACE(\"Start, internal pmi capable\");\n  if( want_pmi_shutdown() ){\n    JTRACE(\"Perform shutdown\");\n\n    PMI_BOOL en;\n    if( !_real_PMI_Fini || ! _real_PMI_Initialized ){\n      rm_init_pmi();\n    }\n    JASSERT( _real_PMI_Initialized(&en) == PMI_SUCCESS );\n    if( en == PMI_TRUE ){\n      JASSERT( _real_PMI_Fini() == PMI_SUCCESS );\n    }\n    JTRACE(\"Shutdown PMI connection before checkpoint:\")(ret);\n  }\n  return ret;\n}\n\n\nint rm_restore_pmi()\n{\n  int ret = 0;\n\n  JTRACE(\"Start, internal pmi capable\");\n  if( want_pmi_shutdown()  ){\n    JTRACE(\"Perform restore\");\n    if( !_real_PMI_Init || ! _real_PMI_Initialized ){\n      rm_init_pmi();\n    }\n    PMI_BOOL en;\n    int spawned;\n    JASSERT( _real_PMI_Initialized(&en) == PMI_SUCCESS );\n    if( en == PMI_FALSE ){\n      JASSERT( _real_PMI_Init(&spawned) == PMI_SUCCESS );\n    }\n    JTRACE(\"Restore PMI connection:\")(ret);\n    JASSERT( _real_PMI_Barrier() == PMI_SUCCESS );\n    JTRACE(\"After PMI_Barrier()\")(ret);\n  }\n  return ret;\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/plugin/batch-queue/rm_main.h": "/****************************************************************************\n *  Copyright (C) 2012-2014 by Artem Y. Polyakov <artpol84@gmail.com>       *\n *                                                                          *\n *  This file is part of the RM plugin for DMTCP                            *\n *                                                                          *\n *  RM plugin is free software: you can redistribute it and/or              *\n *  modify it under the terms of the GNU Lesser General Public License as   *\n *  published by the Free Software Foundation, either version 3 of the      *\n *  License, or (at your option) any later version.                         *\n *                                                                          *\n *  RM plugin is distributed in the hope that it will be useful,            *\n *  but WITHOUT ANY WARRANTY; without even the implied warranty of          *\n *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the           *\n *  GNU Lesser General Public License for more details.                     *\n *                                                                          *\n *  You should have received a copy of the GNU Lesser General Public        *\n *  License along with DMTCP:dmtcp/src.  If not, see                        *\n *  <http://www.gnu.org/licenses/>.                                         *\n ****************************************************************************/\n\n#ifndef RESOURCE_MANAGER_H\n#define RESOURCE_MANAGER_H\n\n#include \"dmtcpalloc.h\"\n#include \"dmtcp.h\"\n\n#define _real_fork NEXT_FNC(fork)\n#define _real_execve NEXT_FNC(execve)\n#define _real_execvp NEXT_FNC(execvp)\n#define _real_execvpe NEXT_FNC(execvpe)\n#define _real_open NEXT_FNC(open)\n#define _real_close NEXT_FNC(close)\n#define _real_dup NEXT_FNC(dup)\n#define _real_dup2 NEXT_FNC(dup2)\n#define _real_fcntl NEXT_FNC(fcntl)\n#define _real_pthread_mutex_lock NEXT_FNC(pthread_mutex_lock)\n#define _real_pthread_mutex_unlock NEXT_FNC(pthread_mutex_unlock)\n#define _real_dlopen NEXT_FNC(dlopen)\n#define _real_dlsym NEXT_FNC(dlsym)\n#define _real_system NEXT_FNC(system)\n\n#define _real_socket NEXT_FNC(socket)\n#define _real_connect NEXT_FNC(connect)\n#define _real_bind NEXT_FNC(bind)\n\nnamespace dmtcp {\n\n// General\nbool runUnderRMgr();\nenum rmgr_type_t { Empty, None, torque, sge, lsf, slurm };\n\nrmgr_type_t _get_rmgr_type();\nvoid _set_rmgr_type(rmgr_type_t nval);\n\nvoid _rm_clear_path(string &path);\nvoid _rm_del_trailing_slash(string &path);\n\nenum ResMgrFileType\n{\n  TORQUE_IO,\n  TORQUE_NODE,\n  SLURM_TMPDIR\n};\n}\n\n#define FWD_TO_DEV_NULL(fd) \\\n{ \\\n  int tmp = open(\"/dev/null\", O_CREAT|O_RDWR|O_TRUNC, 0666); \\\n  if (tmp >= 0 && tmp != fd ) { \\\n  dup2(tmp, fd); \\\n  close(tmp); \\\n  } \\\n}\n\n#define CHECK_FWD_TO_DEV_NULL(fd) \\\n{ \\\n  if( fcntl(fd,F_GETFL) == -1 ){ \\\n    FWD_TO_DEV_NULL(fd) \\\n  } \\\n}\n\n#define DMTCP_SRUN_HELPER_ADDR_ENV \"DMTCP_SRUN_HELPER_ADDR\"\n#define DMTCP_SRUN_HELPER_SYNC_ENV \"DMTCP_SRUN_HELPER_SYNCFILE\"\n\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/plugin/batch-queue/pmi-drafts/hijack.cpp": "#include <dlfcn.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include \"pmi_hijack_log.h\"\n#include <fstream>\n\nstatic void *handle = NULL;\nstatic pmi_hijack_log *log;\nstatic int count = 0;\n\nchar fprefix[256] = \"pmidb\";\n\nvoid init_handle(){\n    if( !handle )\n\thandle = dlopen(\"/user/artempol/OpenMPI/pmi_support/lib/libpmi.so\",RTLD_NOW);\n    printf(\"handle=%p\\n\",handle);\n    if( !log )\n        log = new pmi_hijack_log;\n}\n\nint init_fprefix()\n{\n    char *jid = getenv(\"SLURM_JOBID\");\n    char *nid = getenv(\"SLURM_NODEID\");\n    char *lid = getenv(\"SLURM_LOCALID\");\n    sprintf(fprefix,\"%s.%s.%s.%s\",fprefix,jid,nid,lid);\n}\n\n__attribute__((constructor)) void initLib(void) {\n    char *p = getenv(\"LD_PRELOAD\");\n    printf(\"library loaded. LD_PRELOAD=%s\\n\",p);\n    init_fprefix();\n}\n\n\nextern \"C\"{\n\nint PMI_Init( int *length )\n{\n    typedef int (*_PMI_Init_t)( int *t );\n    static _PMI_Init_t _real = NULL;\n    if( !_real ){\n\tinit_handle();\n      _real = (_PMI_Init_t)dlsym(handle,\"PMI_Init\");\n    }\n    int ret = _real(length);\n    printf(\"MYPMI_Init: %p. ret = %d\\n\",_real,ret);\n    return ret;\n}\n\nint PMI_Initialized( int *length )\n{\n    typedef int (*_PMI_Initialized_t)( int *t );\n    static _PMI_Initialized_t _real = NULL;\n    if( !_real ){\n      init_handle();\n      _real = (_PMI_Initialized_t)dlsym(handle,\"PMI_Initialized\");\n    }\n    int ret = _real(length);\n    return ret;\n}\n\nint PMI_Finalize( void )\n{\n    typedef int (*_PMI_Finalize_t)( );\n    static _PMI_Finalize_t _real = NULL;\n    typedef int (*_PMI_KVS_Get_name_length_max_t)( int *t );\n    static _PMI_KVS_Get_name_length_max_t _kvsname_max = NULL;\n    typedef int (*_PMI_KVS_Get_key_length_max_t)( int *t );\n    static _PMI_KVS_Get_key_length_max_t _key_max = NULL;\n    typedef int (*_PMI_KVS_Get_value_length_max_t)( int *t );\n    static _PMI_KVS_Get_value_length_max_t _val_max = NULL;\n\n    if( !_real ){\n\tinit_handle();\n      _real = (_PMI_Finalize_t)dlsym(handle,\"PMI_Finalize\");\n      _kvsname_max = (_PMI_KVS_Get_name_length_max_t)dlsym(handle,\"PMI_KVS_Get_name_length_max\");\n      _key_max = (_PMI_KVS_Get_key_length_max_t)dlsym(handle,\"PMI_KVS_Get_key_length_max\");\n      _val_max = (_PMI_KVS_Get_value_length_max_t)dlsym(handle,\"PMI_KVS_Get_value_length_max\");\n    }\n    /*\n    std::fstream out;\n    out.open(\"pmi_base.ckpt\", std::ios_base::out);\n    int kvsname_max, key_max, val_max;\n    _kvsname_max( &kvsname_max );\n    _key_max( &key_max );\n    _val_max( &val_max );\n    log->serialize(out, kvsname_max, key_max, val_max);\n    */\n    int ret = _real();\n    printf(\"MYPMI_Finalize: %p. ret = %d\\n\",_real,ret);\n    return ret;\n}\n\n\nint PMI_KVS_Put( const char kvsname[], const char key[], const char value[])\n{\n    typedef int (*_PMI_KVS_Put_t)( const char kvsname[], const char key[], const char value[] );\n    static _PMI_KVS_Put_t _real = NULL;\n    if( !_real ){\n      init_handle();\n      _real = (_PMI_KVS_Put_t)dlsym(handle,\"PMI_KVS_Put\");\n    }\n    int ret = _real(kvsname,key,value);\n    ret = ret * !(log->kvs_put(kvsname,key,value));\n    return ret;\n}\n\nint PMI_KVS_Commit(char kvsname[], int length )\n{\n    typedef int (*_PMI_KVS_Commit_t)(char kvsname[] );\n    static _PMI_KVS_Commit_t _real = NULL;\n    if( !_real ){\n\tinit_handle();\n      _real = (_PMI_KVS_Commit_t)dlsym(handle,\"PMI_KVS_Commit\");\n    }\n    int size, rc;\n    log->kvs_commit(kvsname);\n    return _real(kvsname);\n}\n\nint PMI_KVS_Create(char kvsname[], int length )\n{\n    typedef int (*_PMI_KVS_Create_t)(char kvsname[], int length );\n    static _PMI_KVS_Create_t _real = NULL;\n    if( !_real ){\n\tinit_handle();\n      _real = (_PMI_KVS_Create_t)dlsym(handle,\"PMI_KVS_Create\");\n    }\n    int ret;\n    ret = _real(kvsname,length);\n    log->kvs_create(kvsname);\n    return ret;\n}\n\nint PMI_KVS_Destroy( char kvsname[] )\n{\n    typedef int (*_PMI_KVS_Destroy_t)(char kvsname[] );\n    static _PMI_KVS_Destroy_t _real = NULL;\n    if( !_real ){\n\tinit_handle();\n      _real = (_PMI_KVS_Destroy_t)dlsym(handle,\"PMI_Destroy\");\n    }\n    log->kvs_create(kvsname);\n    return _real(kvsname);\n}\n\nint PMI_Barrier( void )\n{\n    typedef int (*_PMI_Barrier_t)(void);\n    static _PMI_Barrier_t _real = NULL;\n    typedef int (*_PMI_KVS_Get_name_length_max_t)( int *t );\n    static _PMI_KVS_Get_name_length_max_t _kvsname_max = NULL;\n    typedef int (*_PMI_KVS_Get_key_length_max_t)( int *t );\n    static _PMI_KVS_Get_key_length_max_t _key_max = NULL;\n    typedef int (*_PMI_KVS_Get_value_length_max_t)( int *t );\n    static _PMI_KVS_Get_value_length_max_t _val_max = NULL;\n\n\n    if( !_real ){\n\tinit_handle();\n      _real = (_PMI_Barrier_t)dlsym(handle,\"PMI_Barrier\");\n      _kvsname_max = (_PMI_KVS_Get_name_length_max_t)dlsym(handle,\"PMI_KVS_Get_name_length_max\");\n      _key_max = (_PMI_KVS_Get_key_length_max_t)dlsym(handle,\"PMI_KVS_Get_key_length_max\");\n      _val_max = (_PMI_KVS_Get_value_length_max_t)dlsym(handle,\"PMI_KVS_Get_value_length_max\");\n    }\n\n    std::fstream out;\n    out.open(fprefix, std::ios_base::out);\n    int kvsname_max, key_max, val_max;\n    _kvsname_max( &kvsname_max );\n    _key_max( &key_max );\n    _val_max( &val_max );\n    log->serialize(out, kvsname_max, key_max, val_max);\n    out.close();\n\n    return _real();\n}\n\n}",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/test/dlopen2.cpp": "/* To compile, use -DLIB3 to create libdlopen-lib3.so, -DLIB4 for\n * libdlopen-lib4.so, and define neither to create executable.\n * To run, do:  LD_LIBRARY_PATH=. ./dlopen2\n */\n\n# include <dlfcn.h>\n# include <unistd.h>\n# include <stdio.h>\n# include <stdio.h>\n# include <stdlib.h>\n# include <assert.h>\n\n#if !defined(LIB3) && !defined(LIB4)\nint (*fnc)(int result[2]);\n\nint main(int argc, char* argv[])\n{\n  int lib = 1;\n  void *handle = NULL;\n  int result[2] = {0, 0};\n  int i, answer;\n  int cnt1 = 0, cnt2 = 0;\n\n  printf(\"0: \"); fflush(stdout);\n  while (1) {\n    if (handle != NULL)\n      dlclose(handle);\n\n    if (lib == 1) {\n      handle = dlopen(\"libdlopen-lib3.so\", RTLD_NOW);\n      if (handle == NULL) {\n        fprintf(stderr, \"dlopen failed: %s\\n\", dlerror());\n        exit(1);\n      }\n      /* See 'man dlopen' for example:  POSIX.1-2002 prefers this workaround */\n      *(void **) (&fnc) = dlsym(handle, \"fnc\");\n    }\n\n    if (lib == 2) {\n      handle = dlopen(\"libdlopen-lib4.so\", RTLD_LAZY);\n      if (handle == NULL) {\n        fprintf(stderr, \"dlopen failed: %s\\n\", dlerror());\n        exit(1);\n      }\n      /* See 'man dlopen' for example:  POSIX.1-2002 prefers this workaround */\n      *(void **) (&fnc) = dlsym(handle, \"fnc\");\n    }\n\n    assert(lib == 1 || lib == 2);\n    for (i = 0; i < 5; i++) {\n      answer = fnc(result);\n      if (answer != result[lib - 1]) {\n        fprintf(stderr, \"lib %d returned wrong answer.\\n\", lib);\n        exit(1);\n      }\n    }\n    if (++cnt1 % 1000 == 0) {\n      cnt2++;\n      cnt1 = 0;\n      printf(\".\"); fflush(stdout);\n      if (cnt2 % 50 == 0)\n        printf(\"\\n%d: \", cnt2 / 50);\n      fflush(stdout);\n    }\n    lib = 3 - lib; /* switch libraries to load */\n\n  }\n  return 0;\n}\n\n#elif defined(LIB3)\nextern \"C\" int fnc(int result[2]) {\n    return ++(result[0]);\n}\n\nextern \"C\" int print_constructor() {\n  int dummy = system(\"echo '    In LIB3::print_constructor'\");\n  if (dummy == -1) {\n    perror(\"system failed.\");\n  }\n  sleep(1);\n  return 0;\n}\n\n#elif defined(LIB4)\nextern \"C\" int fnc(int result[2]) {\n    return ++(result[1]);\n}\n\nextern \"C\" int print_constructor() {\n  int dummy = system(\"echo '    In LIB4::print_constructor'\");\n  if (dummy == -1) {\n    perror(\"system failed.\");\n  }\n  sleep(1);\n  return 0;\n}\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/test/dlopen1.c": "/* To compile, use -DLIB1 to create libdlopen-lib1.so, -DLIB2 for\n *   libdlopen-lib2.so, and define neither to create executable.\n * To run, do:  LD_LIBRARY_PATH=. ./dlopen1\n */\n\n#if !defined(LIB1) && !defined(LIB2)\n# include <dlfcn.h>\n# include <stdio.h>\n# include <stdlib.h>\n# include <assert.h>\n\nint (*fnc)(int result[2]);\n\nint main(int argc, char* argv[])\n{\n  int lib = 1;\n  void *handle = NULL;\n  int result[2] = {0, 0};\n  int i, answer;\n  int cnt1 = 0, cnt2 = 0;\n\n  printf(\"0: \"); fflush(stdout);\n  while (1) {\n    if (handle != NULL)\n      dlclose(handle);\n\n    if (lib == 1) {\n      handle = dlopen(\"libdlopen-lib1.so\", RTLD_NOW);\n      if (handle == NULL) {\n        fprintf(stderr, \"dlopen failed: %s\\n\", dlerror());\n        exit(1);\n      }\n      /* See 'man dlopen' for example:  POSIX.1-2002 prefers this workaround */\n      *(void **) (&fnc) = dlsym(handle, \"fnc\");\n    }\n\n    if (lib == 2) {\n      handle = dlopen(\"libdlopen-lib2.so\", RTLD_LAZY);\n      if (handle == NULL) {\n        fprintf(stderr, \"dlopen failed: %s\\n\", dlerror());\n        exit(1);\n      }\n      /* See 'man dlopen' for example:  POSIX.1-2002 prefers this workaround */\n      *(void **) (&fnc) = dlsym(handle, \"fnc\");\n    }\n\n    assert(lib == 1 || lib == 2);\n    for (i = 0; i < 5; i++) {\n      answer = fnc(result);\n      if (answer != result[lib - 1]) {\n        fprintf(stderr, \"lib %d returned wrong answer.\\n\", lib);\n        exit(1);\n      }\n    }\n    if (++cnt1 % 1000 == 0) {\n      cnt2++;\n      cnt1 = 0;\n      printf(\".\"); fflush(stdout);\n      if (cnt2 % 50 == 0)\n        printf(\"\\n%d: \", cnt2 / 50);\n      fflush(stdout);\n    }\n    lib = 3 - lib; /* switch libraries to load */\n  }\n  return 0;\n}\n\n#elif defined(LIB1)\nint fnc(int result[2]) {\n    return ++(result[0]);\n}\n\n#elif defined(LIB2)\nint fnc(int result[2]) {\n    return ++(result[1]);\n}\n\n#endif\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/test/plugin/sleep2/sleep2.c": "#include <stdio.h>\n#include <sys/time.h>\n#include \"dmtcp.h\"\n\nvoid print_time() {\n  struct timeval val;\n  gettimeofday(&val, NULL);\n  printf(\"%ld %ld\", (long)val.tv_sec, (long)val.tv_usec);\n}\n\nunsigned int sleep(unsigned int seconds) {\n  printf(\"(sleep2: \"); print_time(); printf(\" ... \");\n  unsigned int result = NEXT_FNC(sleep)(seconds);\n  print_time(); printf(\") \");\n\n  return result;\n}\n\n/* If your code wants to avoid the wrapper above, call this version */\nunsigned int real_sleep(unsigned int seconds) {\n  static unsigned int (*real_fnc)() = NULL; /* Same type signature as sleep */\n  static void *handle = NULL;\n\n  if (! handle)\n    handle = dlopen(\"libc.so.6\", RTLD_NOW);\n  if (! real_fnc)\n    real_fnc = (__typeof__(real_fnc)) dlsym(handle, \"sleep\");\n  return (*real_fnc)(seconds);\n}\n\nvoid dmtcp_event_hook(DmtcpEvent_t event, DmtcpEventData_t *data)\n{\n  static void (*next_fnc)() = NULL;/* Same type signature as this fnc */\n\n  /* NOTE:  See warning in plugin/README about calls to printf here. */\n  switch (event) {\n  case DMTCP_EVENT_WRITE_CKPT:\n    printf(\"*** The plugin %s is being called before checkpointing. ***\\n\",\n\t   __FILE__);\n    real_sleep(1);\n    printf(\"*** Finished calling real_sleep() for 1 second. ***\\n\");\n    break;\n  case DMTCP_EVENT_RESUME:\n    printf(\"*** The plugin %s has now been checkpointed. ***\\n\", __FILE__);\n    break;\n  default:\n    ;\n  }\n\n  /* Call this next line in order to pass DMTCP events to later plugins. */\n  DMTCP_NEXT_EVENT_HOOK(event, data);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/contrib/infiniband/infinibandtrace.c": "#define __USE_GNU\n#define _GNU_SOURCE\n#include <dlfcn.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <sys/select.h>\n#include <sys/un.h>\n#include <arpa/inet.h>\n#include <pthread.h>\n/* According to earlier standards */\n#include <sys/types.h>\n#include <unistd.h>\n#include <errno.h>\n#include <infiniband/verbs.h>\n#include \"infinibandreals.h\"\n\n\n/* This macro requires a static local declaration of \"next_fnc\". */\n#define NEXT_FNC(symbol) \\\n    (next_fnc ? *next_fnc : *(next_fnc = dlsym(RTLD_NEXT, #symbol)))\n\n\n\n//: REMOVE THS\n#undef JNOTE\n#define JNOTE(X) printf(X); printf(\"\\n\");\n\nstruct ibv_device **ibv_get_device_list(int *num_devices)\n{\n  JNOTE(\"****** WRAPPER for ibv_get_device_list\");\n\n  return _real_ibv_get_device_list(num_devices);\n}\n\nconst char *ibv_get_device_name(struct ibv_device *dev)\n{\n  JNOTE(\"****** WRAPPER for ibv_get_device_name\");\n\n  return _real_ibv_get_device_name(dev);\n}\n\nstruct ibv_context *ibv_open_device(struct ibv_device *dev)\n{\n  JNOTE(\"******* WRAPPER for begin of ibv_open_device\");\n\n  return _real_ibv_open_device(dev);\n}\n\nint ibv_query_device(struct ibv_context *context, struct ibv_device_attr *device_attr)\n{\n  JNOTE(\"******* WRAPPER for begin of ibv_query_device\");\n\n  return _real_ibv_query_device(context, device_attr);\n}\n\nint ibv_query_pkey(struct ibv_context *context, uint8_t port_num,  int index, uint16_t *pkey)\n{\n  JNOTE(\"******* WRAPPER for begin of ibv_query_pkey\");\n\n  return ibv_query_pkey(context, port_num, index, pkey);\n}\n\nint ibv_query_gid(struct ibv_context *context, uint8_t port_num, int index, union ibv_gid *gid)\n{\n  JNOTE(\"******* WRAPPER for begin of ibv_query_gid\");\n\n  return _real_ibv_query_gid(context, port_num, index, gid);\n}\n\nuint64_t ibv_get_device_guid(struct ibv_device *device)\n{\n  JNOTE(\"******* WRAPPER for ibv_get_device_guid\");\n\n  return _real_ibv_get_device_guid(device);\n}\n\n\nstruct ibv_comp_channel *ibv_create_comp_channel(struct ibv_context\n                                                                *context)\n{\n  JNOTE(\"******* WRAPPER for ibv_create_comp_channel\");\n\n  return _real_ibv_create_comp_channel(context);\n}\n\nint ibv_destroy_comp_channel(struct ibv_comp_channel *channel)\n{\n  JNOTE(\"****** WRAPPER for ibv_destroy_comp_channel\");\n\n  return _real_ibv_destroy_comp_channel(channel);\n}\n\nstruct ibv_pd *ibv_alloc_pd(struct ibv_context *context)\n{\n  JNOTE(\"******* WRAPPER FOR ibv_alloc_pd\");\n\n  return _real_ibv_alloc_pd(context);\n}\n\nstruct ibv_mr *ibv_reg_mr(struct ibv_pd *pd, void *addr,\n                          size_t length,\n                          int access) //int access)\n{\n  JNOTE(\"******** WRAPPER for ibv_reg_mr\");\n\n  return _real_ibv_reg_mr(pd, addr, length, access);\n}\n\nstruct ibv_cq *ibv_create_cq(struct ibv_context *context, int cqe,\n                             void *cq_context,\n                             struct ibv_comp_channel *channel,\n                             int comp_vector)\n{\n  JNOTE(\"******** WRAPPER for ibv_create_cq\");\n\n  return _real_ibv_create_cq(context, cqe, cq_context, channel, comp_vector);\n}\n\nstruct ibv_qp *ibv_create_qp(struct ibv_pd *pd, struct ibv_qp_init_attr *qp_init_attr)\n{\n  JNOTE(\"******** WRAPPER for ibv_create_qp\");\n\n  return _real_ibv_create_qp(pd, qp_init_attr);\n}\n\nint ibv_modify_qp(struct ibv_qp *qp, struct ibv_qp_attr *attr,\n                   int attr_mask) //int attr_mask)\n{\n  JNOTE(\"********* WRAPPER for ibv_modify_qp\");\n  attr->rq_psn = attr->rq_psn & 0xffffff;\n  attr->sq_psn = attr->sq_psn & 0xffffff;\n  if (attr_mask & IBV_QP_RQ_PSN) {\n    printf(\"1RQ_PSN is %x\\n\", attr->rq_psn);\n  }\n\n  if (attr_mask & IBV_QP_SQ_PSN) {\n    printf(\"1SQ_PSN is %x\\n\", attr->sq_psn);\n  }\n\n  if (attr_mask & IBV_QP_STATE) {\n    if (attr->qp_state == IBV_QPS_RTR) {\n      printf(\"RQ_PSN is %x\\n\", attr->rq_psn);\n    } else if (attr->qp_state == IBV_QPS_RTS) {\n      printf(\"SQ_PSN is %x\\n\", attr->sq_psn);\n    }\n  }\n\n  int rslt =  _real_ibv_modify_qp(qp, attr, attr_mask);\n\n\n  struct ibv_qp_attr query_attr;\n  struct ibv_qp_init_attr init_attr;\n  int foo = _real_ibv_query_qp(qp, &query_attr, attr_mask, &init_attr);\n\n  if (attr_mask & IBV_QP_RQ_PSN) {\n    printf(\"attr.rq_psn is %x\\n\", query_attr.rq_psn);\n  }\n\n  if (attr_mask & IBV_QP_SQ_PSN) {\n    printf(\"attr.sq_psn is %x\\n\", query_attr.sq_psn);\n  }\n\n  if (attr_mask & IBV_QP_STATE) {\n    printf(\"qp state set attr.sq_psn is %x\\n\", query_attr.sq_psn);\n    printf(\"qp state set attr.rq_psn is %x\\n\", query_attr.rq_psn);\n  }\n\n  return rslt;\n}\n\nint ibv_get_cq_event(struct ibv_comp_channel *channel, struct ibv_cq **cq,\n                        void **cq_context)\n{\n//  JNOTE(\"******** WRAPPER for ibv_get_cq_event\");\n\n  return _real_ibv_get_cq_event(channel, cq, cq_context);\n}\n\nint ibv_query_qp(struct ibv_qp *qp, struct ibv_qp_attr *attr,\n                 int attr_mask, struct ibv_qp_init_attr *init_attr)\n{\n  JNOTE(\"******** WRAPPER FOR ibv_query_qp\");\n\n  return _real_ibv_query_qp(qp, attr, attr_mask, init_attr);\n}\n\nint ibv_get_async_event(struct ibv_context *context, struct ibv_async_event *event)\n{\n  JNOTE(\"******** WRAPPER FOR ibv_get_async_event\");\n\n  return _real_ibv_get_async_event(context, event);\n}\n\nvoid ibv_ack_async_event(struct ibv_async_event *event)\n{\n  JNOTE(\"******* WRAPPER FOR ibv_ack_async_event\");\n\n  _real_ibv_ack_async_event(event);\n}\n\nint ibv_resize_cq(struct ibv_cq *cq, int cqe)\n{\n  JNOTE(\"****** WRAPPER for ibv_resize_cq\");\n\n  return _real_ibv_resize_cq(cq, cqe);\n}\n\nint ibv_destroy_cq(struct ibv_cq *cq)\n{\n  JNOTE(\"****** WRAPPER for ibv_destroy_cq\");\n\n  return _real_ibv_destroy_cq(cq);\n}\n\nint ibv_destroy_qp(struct ibv_qp *qp)\n{\n  JNOTE(\"****** WRAPPER2 for ibv_destroy qp\");\n\n  return _real_ibv_destroy_qp(qp);\n}\n\nint ibv_dereg_mr(struct ibv_mr *mr)\n{\n  JNOTE(\"****** WRAPPER for ibv_dereg_mr\");\n\n  return _real_ibv_dereg_mr(mr);\n}\n\nint ibv_dealloc_pd(struct ibv_pd *pd)\n{\n  JNOTE(\"****** WRAPPER for ibv_dealloc_pd\");\n\n  return _real_ibv_dealloc_pd(pd);\n}\n\nint ibv_close_device(struct ibv_context *context)\n{\n  JNOTE(\"***** WRAPPER for ibv_close_device\");\n\n  return _real_ibv_close_device(context);\n}\n\nvoid ibv_free_device_list(struct ibv_device **list)\n{\n  JNOTE(\"********* WRAPPER for ibv_free_device_list\");\n\n  _real_ibv_free_device_list(list);\n}\n\nvoid ibv_ack_cq_events(struct ibv_cq *cq, unsigned int nevents)\n{\n  JNOTE(\"******** WRAPPER for ibv_ack_cq_events\");\n\n  _real_ibv_ack_cq_events(cq, nevents);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/doc/dmtcp_dlsym.txt": "\t\tA Better dlsym() :  Returning the Default Version\n\nThis is intended as one of a series of informal documents to describe\nand partially document some of the more subtle DMTCP data structures\nand algorithms.  These documents are snapshots in time, and they\nmay become somewhat out-of-date over time (and hopefully also refreshed\nto re-sync them with the code again).\n\nThe GNU extension of the POSIX system call, dlsym(), was designed\nto support the concept of wrapper functions around a library,\nby using the pseudo-handle, RTLD_NEXT.  See 'man 3 dlopen' for details.\nIn summary, something like the following example should work:\n  int fnc() {\n    void *handle = dlopen(RTLD_NEXT, RTLD_LAZY);\n    void *fnc_real = dlsym(handle, \"fnc\");\n    int (*fnc_ptr)() = fnc_real;\n    return (*fnc_ptr)();\n  }\n\nThis does work, except in some situations where symbol versioning\nis used.  Symbol versioning is also a GNU extension.  It includes\na concept of the \"default version\", and libraries that don't specify\na particular version will invoke the default version.  Unfortunately,\nin the code above, dlsym will usually return the oldest version instead\nof the default version.  This behavior is not documented in 'man dlsym',\nbut it is easily seen in tests.\n\nDMTCP has implemented DLSYM_DEFAULT(), a replacement for dlsym(),\nwhich will return the _default version_, which is presumably the\ndesired behavior for most users calling this.\n\nThese notes will help to understand the concepts and background for\nthe implementations of src/dmtcp_dlsym.cpp.\n\nSUGGESTED READING:\n  http://refspecs.linuxfoundation.org/LSB_3.2.0/LSB-Core-generic/LSB-Core-generic/symversion.html#SYMRESOLUTION\n\nEXPLANATION:\nThe \"default version\" doesn't seem to be a concept explicitly defined\nin the standard.  But in practice, references to the \"default version\"\nrefer to the _unique_ symbol version, which is not a hidden symbol.\nSo, we stop to define \"hidden symbol\".\n\nA hidden symbol is a symbol in the lookup table for which the \"hidden\nbit\" is set.  The intention was that only one symbol version (the\ndefault version) should be visible to linkers that don't know about\nsymbol versioning.  All other versions should be hidden.\n\nSo, a software package links to the \"default version\", unless it\nexplicitly asks for a specific hidden version.  The function dlsym()\nunfortunately usually links to the oldest version, instead of the\n\nIt depends on each\nsoftware package to define at most one non-hidden symbol.\n newest version\n(the one on which no other version depends; and the versioning standard\ndefines dependencies among version numbers).\ndefault version.  GNU provides the alternative function, dlvsym,\nwhich will link to a specific version of a symbol.  But then to link\nto the default version, a programmer must first know the name (or\nversion number) of the default version.  There is no GNU extension\nto automatically discover the default version number.  Further,\ndifferent Linux distros may be using different default versions.\nSo, the default version number is not a universally fixed value.\n\n====\nBACKGROUND DETAILS OF THE ELF LINKER:\n\nThe rest of this note explains how the macro DLSYM_DEFAULT()\n(and the function dlsym_default_internal()) find the default symbol.\nThis is done in src/dmtcp_dlsym.cpp.\n\nThe versym ELF section defines the symbol version strings of that file (and it\nstates if a symbol version depends on a different one).  The versym ELF\nsection is an extension of the dynsym (Dynamic Symbol) section.  It is\nthe same length as the dynsym version.  The dynsym section is an array\nof structs and the versym section is an array of \"version indexes\".\nThus it acts as an extra field in the dynsym section.  (This way,\nversioning can stay hidden from linkers that don't know about versioning.)\n\nThe dynsym section is itself a subset of the symbol section, including only\nthose symbols needed for dynamic linking.  That's why \"nm -D\" may\nshow symbols when \"nm -S\" fails (when the object was stripped).\nA stripped object must keep its dynamic symbols or it can never be\nused for dynamic linking.\n\nIf the high order bit (bit number 15) of the version symbol is set, the\nobject cannot be used and the static linker shall ignore the symbol's\npresence in the object.  This bit is sometimes known as a \"hidden bit\",\nbecause an outside object can link to it only if it explicitly requests\nthe specific version string.  Hence, if there is only one version\nof a symbol without a hidden bit, then that version is the default version\nfor that symbol.\n\nIf an unversioned symbol reference is linked with an object that has\nversioned symbols, then it is only allowed to link with the version\nindex 1 (aka \"GLOBAL\", used for unversioned symbols) or version index\n2 (typically defined within an object file as the oldest version string of\nthat file).  These two versions are known as the base definition.  (An\nunversioned symbol will have index 1 for its base definition, while\na versioned symbol will have index 2 for its base definition.)\nThe above are the rules for the \"static linker\" (linking done at load-time).\n\nIn calls to dlopen, the \"dynamic linker\" is called.  If the dynamic linker\ndoes not find a base definition for a symbol, and if only one version\nis defined, it can link to that version.  (I'm not sure if that's allowed\nthen the one defined version has the hidden bit set in the versym entry.\n\n====\nIMPLEMENTATION DETAILS:\n\nStrings can be compared using strcmp.  But one can also use the\nhash ELF section for symbol names.  This entry specifies the hash function\nto use:\n  http://www.sco.com/developers/gabi/latest/ch5.dynamic.html#hash\n\n====\nThe following exist:\n  http://refspecs.linuxbase.org/LSB_3.1.1/LSB-Core-generic/LSB-Core-generic/elf-generic.html\n  http://refspecs.linuxbase.org/LSB_3.1.1/\n\nBut the prior Sun/Oracle documents are sometimes more readable:\n  http://docs.oracle.com/cd/E19683-01/817-1983/6mhm6r4fj/index.html#chapter6-79797\n\n====\nThe following are very rough notes taken in writing the implementation.\nNo promises about readability:\n\nThe base definition is for the filename (VER_FLG_BASE in vd_flags)!\n\nShould read the version definition (DT_VERDEF) section.\nThat has a series of ElfXX_Verdef structs\nEach one has a vd_cnt of the number of versions in the vd_aux,\n  and a vd_aux entry with\n    vda_name:\n      The string table offset to a null-terminated string, giving the name of the version definition\n    and vda_next for the offset to a dependency of this versioned symbol\n\t(for dependencies of this version definition:  each dependency\n\t will have its own version definition)\n    The first vda definition is the version name for this entry (each verdef\n\tentry may be for a different version of same symbol)\n  and a vd_next pointing to the next ElfXX_Verdef entry\n  and a vd_ndx index that uniquely associates it with a versym entry of the\n\tsame index.  (This just a unique index which matches the _value_\n\tin the versym array.  It is not an array index.  The versym array\n\tis meant to add an extra field into the symtab section (array of\n\tstructs).  The field is a unique index corresponding to vd_ndx for\n\tsome version def.  Since the versym section and symtab section are\n\tthe same length, you can also use the same array index for both.)\n\nThe versym section has a number of symbols the same as in the symbols section.\n  It's an array of ElfXX_Versym half-words.  If it's VER_NDX_GLOBAL (= 1),\n  then it's the base definition (default version); Otherwise, it's a\n  user-defined version definition (for constant greater than 1)\n  (Could it be that number 2 is for default version and number 1 for base?)\n  Maybe user must specify higher integer for each extra version, so that\n  this acts as a kind of numeric index for the version name??\n  And version references start where version definitions leave off.\n\nThis link was also useful for documenting the ELF symbol table.\nhttp://docs.oracle.com/cd/E19683-01/817-1983/6mhm6r4fj/index.html#chapter6-79797\nThe SYMTAB section has a st_name which is an index into the symbol string table.\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/doc/multi-arch.txt": "Support for mixed mode applications.\n\nOn a 64-bit machine, DMTCP can be used to checkpoint a\ncomputation consisting of both 64-bit and 32-bit applications.\n\nThe DMTCP binaries (dmtcp_launch, dmtcp_coordinator, dmtcp_restart, etc.) are\ncompiled and built only for the 64-bit architecture.  These binaries can launch\nprocesses for 32-bit applications as well. An exception is mtcp_restart, which\nmust be compiled and build for each supported architecture.\n\nThe libraries (libdmtcp.so, libdmtcp_pid.so, etc.) are built separately for all\nsupported architectures.\n\nThe installation goes as follows:\n<prefix>/bin: binaries for primary architecture\n<prefix>/lib/dmtcp: libraries for primary architecture\n<prefix>/lib/dmtcp/32/bin: mtcp_restart binary for given secondary arch.\n<prefix>/lib/dmtcp/32/lib/dmtcp: libraries for given secondary arch.\n\nRest of the data files (headers, docs, manpages, etc) go to their usual\nlocations.\n\nA. Compiling DMTCP for multi-arch support:\n=========================================\n\n1. Do the 32-bit compilation (with -m32)\n   ./configure --enable-m32\n   make clean\n   make\n2. Do the usual 64-bit compilation\n   ./configure\n   make clean\n   make\n\nOptionally, add 'make install' at the end of each of the above stages,\nif you want to install a multi-arch implementation.\n\nUse \"./configure --prefix=$PWD/build\" if you wish to build a local copy,\ninstead of installing globally.\n\nNote that \"--enable-m32\" will not create the necessary DMTCP commands\non a 64-bit Linux.  So, _on a 64-bit Linux_, you will still need the\n64-bit install, even if you intend only to run with 32-bit targets.\n\n\nB. IMPLEMENTATION NOTE: Handling dlsym offset:\n=============================================\nDMTCP relies on dlsym offset (calculated as the relative offset of dlsym from\ndlinfo in libdl.so) for calling the libdl:dlsym() function. This is to allow\nthe plugins to put wrappers around dlsym() function itself.\n\nAs can be seen, the dlsym offset may be different for 32-bit and 64-bit\nversions of libdl.so. To handle this, we calculate the offset for both\narchitectures beforehand (while executing in dmtcp_launch and dmtcp_restart)\nand set the environment variables DMTCP_DLSYM_OFFSET (and\nDMTCP_DLSYM_OFFSET_M32). These offsets are also stored in SharedData area (see\nshareddata.h).\n\nWhile exec'ing a new program, the process cannot rely on the current value\nof the env vars as the values might be outdated. Thus, in prepareForExec(), the\nenv vars are updated from the current values in SharedData.\n",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/doc/src/architecture-of-dmtcp.tex": "\\documentclass{article}\n\\usepackage{fullpage}\n\\usepackage{graphicx}\n\\usepackage[noend]{algorithmic}\n\\usepackage{algorithm}\n\n\n\\title{Architecture of DMTCP}\n\\author{Gene Cooperman}\n\\date{March, 2015}\n\n\\begin{document}\n\\maketitle\n\nThis is intended as a gentle introduction to the architecture of DMTCP.\nShorter descriptions are possible.  For a low-level description with\nreferences to code in the implementation, see\n{\\tt doc/restart\\_algorithm.txt}~.  For the general use of plugins,\nsee {\\tt doc/plugin-tutorial.pdf}~.  DMTCP uses plugins internally\nfrom {\\tt DMTCP\\_ROOT/src/plugin}.  DMTCP also offers optional plugins\n(not enabled by default) to end users.  Thes come in two flavors:\n{\\tt DMTCP\\_ROOT/plugin}\n(fully supported) and {\\tt DMTCP\\_ROOT/contrib} (newer plugins,\npossibly contributed by third parties).\n\n\\subsection*{1. Usage of DTMCP:}\n\\begin{algorithmic}[1]\n\\STATE {\\tt dmtcp\\_launch a.out}\n\\STATE {\\tt dmtcp\\_command --checkpoint} \\newline\n\\hbox{\\ \\ \\ \\ } $\\hookrightarrow$ ckpt\\_a.out.*.dmtcp\n\\STATE {\\tt dmtcp\\_restart ckpt\\_a.out.*.dmtcp}\n\\end{algorithmic}\n\n\\bigskip\n\\noindent\nDMTCP offers a {\\tt --help} command line option along with additional options\nboth for {\\tt configure} and for the individual DMTCP commands.\nTo use DMTCP, just prefix your command line with {\\tt dmtcp\\_launch}.\n\n\\subsection*{2. dmtcp\\_launch a.out}\n\nThe command {\\tt dmtcp\\_launch a.out} is roughly equivalent to:\n\n\\begin{algorithmic}[1]\n\\STATE {\\tt dmtcp\\_coordinator --background}  (if not already running)\n\\STATE {\\tt LD\\_PRELOAD=libdmtcp.so a.out} \\\\ ({\\tt LD\\_PRELOAD} causes\n   {\\tt libdmtcp.so} to be loaded first, and initialized before the call to\n   {\\tt main} in {\\tt a.out}.)\n\\end{algorithmic}\n\nThe {\\tt dmtcp\\_launch} command will cause a coordinator process\nto be launched on the local host with the default DMTCP port (if one is\nnot already available).\n\nDMTCP includes a special coordinator process so that DMTCP can also checkpoint\ndistributed computations across many computers.  The user can issue a command\nto the coordinator, which will then relay the command to each of\nthe user processes of the distributed computation.\n\nNote that a {\\em DMTCP computation} is defined to be a coordinator process\nand the set of user processes connected to that coordinator.  Therefore,\none can have more than one DMTCP computation on a single computer,\neach computation having its own unique coordinator.  Each coordinator\nis defined by its unique network address, ``(hostname, port)'', which\ndefaults to ``(localhost, 7779)''.\n\n\\begin{center}\n\\includegraphics[scale=0.5]{coord-client.eps}\n\\end{center}\n\nThe coordinator is {\\em stateless}.  If the computation is ever killed,\none needs only to start an entirely new coordinator, and then restart\nusing the latest checkpoint images for each user process.\n\nLD\\_PRELOAD is a special environment variable known to the loader.\nWhen the loader tries to load a binary (a.out, in this case), the loader\nwill first check if LD\\_PRELOAD is set (see `man ld.so').  If it is\nset, the loader will load the binary (a.out) and then the preload library\n(libdmtcp.so) before running the `main()' routine in a.out.\n(In fact, dmtcp\\_launch may also preload some plugin libraries,\n such as pidvirt.so (starting with DMTCP-2.0) and set some\n environment variables such as DMTCP\\_DLSYM\\_OFFSET.)\n\nWhen the library libdmtcp.so is loaded, any top-level variables\nare initialized, before calling the user main().  If the top-level variable\nis a C++ object, then the C++ constructor is called before the\nuser main.  In DMTCP, the first code to execute is the code\nbelow, inside libdmtcp.so:\n\n{\\tt\ndmtcp::DmtcpWorker dmtcp::DmtcpWorker::theInstance;\n}\n\nThis initializes the global variable, {\\tt theInstance} via a call\nto {\\tt new dmtcp::DmtcpWorker::DmtcpWorker()}.  (Here, {\\tt dmtcp}\nis a C++ namespace, and the first {\\tt DmtcpWorker} is the class name,\nwhile the second {\\tt DmtcpWorker} is the constructor function.  If DMTCP were\nnot using C++, then it would use GNU gcc attributes\nto directly run a constructor function.)\n\nNote that DMTCP is organized in at least two layers.  The lowest layer\nis MTCP (mtcp subdirectory), which handles single-process checkpointing.\nThe higher layer is again called DMTCP (dmtcp subdirectory), and delegates\nto MTCP when it needs to checkpoint one process.  MTCP does not require\na separate DMTCP coordinator.\n\nSo, at startup, we see:\n\n\\begin{algorithmic}[1]\n\\STATE a.out process:\n\\STATE {\\ \\ } primary user thread:\n\\STATE {\\ \\ \\ \\ } new DmtcpWorker():\n\\STATE {\\ \\ \\ \\ \\ \\ } Create a socket to the coordinator\n\\STATE {\\ \\ \\ \\ \\ \\ } Register the signal handler that will be\n\tused for checkpoints. \\newline\n\\hbox{\\ \\ \\ \\ \\ \\ \\ \\ } The signal handler is\n\t\t src/threadlist.cpp:stopthisthread(sig)\\newline\n\\hbox{\\ \\ \\ \\ \\ \\ \\ \\ } The default signal is src/siginfo.cpp:STOPSIGNAL\n\t\t (default: SIGUSR2)\\newline\n\\hbox{\\ \\ \\ \\ \\ \\ \\ \\ } The signal handler for STOPSIGNAL is registered by\n\t {\\tt SigInfo::setupCkptSigHandler(\\&stopthisthread)}\n\\hbox{\\ \\ \\ \\ \\ \\ \\ \\ } in src/threadlist.cpp\n\\STATE {\\ \\ \\ \\ \\ \\ } Create the checkpoint thread: \\newline\n\\hbox{\\ \\ \\ \\ \\ \\ \\ \\ } Call\n\t{\\tt pthread\\_create (\\&checkpointhreadid, NULL, checkpointhread, NULL)}\n\tin src/threadlist.cpp\n\\STATE {\\ \\ \\ \\ \\ \\ } Wait until the checkpoint thread has initialized.\n\\newline\n\\STATE {\\ \\ } checkpoint thread:\n\\STATE {\\ \\ \\ \\ } checkpointhread(dummy):  [from src/threadlist.cpp]\n\\STATE {\\ \\ \\ \\ \\ \\ } Register a.out process with coordinator\n\\STATE {\\ \\ \\ \\ \\ \\ } Tell user thread we're done\n\\STATE {\\ \\ \\ \\ \\ \\ } Call select() on socket to coordinator\n\\newline\n\\STATE {\\ \\ } primary user thread:\n\\STATE {\\ \\ \\ \\ } new DmtcpWorker():  [continued from above invocation]\n\\STATE {\\ \\ \\ \\ \\ \\ } Checkpoint thread is now initialized.  Return.\n\\STATE {\\ \\ \\ \\ } main()  [User code now executes.]\n\\end{algorithmic}\n\n\\bigskip\n\\noindent\nPRINCIPLE:  At any given moment either the user threads are active and\n\tthe checkpoint thread is blocked on {\\tt select()}, or\n\tthe checkpoint thread is active and the user threads are\n\tblocked inside the signal handler, stopthisthread().\n\n\n\n\n\\newpage\n\n\\subsection*{3. Execute a Checkpoint:}\n\n\\begin{center}\n\\includegraphics[scale=0.5]{dmtcp-ckpt.eps}\n\\end{center}\n\n\\begin{algorithmic}[1]\n\\STATE checkpoint thread:\n\\STATE   return from {\\tt DmtcpWorker::waitForCoordinatorMsg()}\n\t   in src/dmtcpworker.cpp\n\\STATE   receive CKPT message\n\\STATE   send STOPSIGNAL (SIGUSR2) to each user thread \\\\\n  See:  {\\tt THREAD\\_TGKILL(motherpid, thread->tid, SigInfo::ckptSignal()}\n                in the section \\\\\n                ~~labeled {\\tt case~ST\\_RUNNING:} in src/threadlist.cpp \\\\\n  See {\\tt Thread\\_UpdateState(curThread, ST\\_SUSPINPROG, ST\\_SIGNALED)} \\\\\n  ~~and {\\tt Thread\\_UpdateState(curThread, ST\\_SUSPENDED, ST\\_SUSPINPROG)}\n\tin src/threadlist.cpp\n\\STATE   Recall that dmtcpWorker created a signal handler,\n            {\\tt stopthisthread()}, for STOPSIGNAL (default: SIGUSR2)\n\\STATE   Each user thread in that signal handler will\n           execute {\\tt sem\\_wait(\\&semWaitForCkptThreadSignal)} and block.\n\\STATE   The checkpoint thread does the checkpoint.\n\\newline\n\\STATE   Release each thread from its mutex\n           by calling {sem\\_post(\\&semWaitForCkptThreadSignal)}\n           inside {\\tt resumeThreads()}.\n\\STATE  Each thread updates its state from {\\tt ST\\_SUSPENDED}\n           to {\\tt ST\\_RUNNING}: \\\\\n       See {\\tt Thread\\_UpdateState(curThread, ST\\_RUNNING, ST\\_SUSPENDED)}\n\tin src/threadlist.cpp\n\\STATE  Call {\\tt DmtcpWorker::waitForCoordinatorMsg()} using the socket\n          to the coordinator and again wait for\n\t  messages from the coordinator.\n\\end{algorithmic}\n\n\\subsection*{4. Checkpoint strategy (overview)}\n\n\\begin{algorithmic}[1]\n\\STATE Quiesce all user threads (using STOPSIGNAL (SIGUSR2), as above)\n\\STATE Drain sockets \\newline\n  \\hbox{\\ \\ } (a) Sender sends a ``cookie'' \\newline\n  \\hbox{\\ \\ } (b) Receiver receives until it sees the ``cookie'' \\newline\n  Note:  Usually all sockets are ``internal'' --- within the current\n    computation.  Heuristics are provided for the case of ``external'' sockets.\n\\STATE Interrogate kernel state (open file descriptors, file descriptor offset, etc.)\n\\STATE Save register values using setcontext (similar to setjmp) in mtcp/mtcp.c\n\\STATE Copy all user-space memory to checkpoint image\n  To find all user-space memory, one can execute: \\newline\n  \\hbox{\\ \\ } {\\tt cat /proc/self/maps}\n\\STATE Unblock all use threads\n\\end{algorithmic}\n\n\\subsection*{5. Restart strategy (overview)}\n\n{\\bf This section will be revised in the future.}\n\nThe key ideas are that {\\tt dmtcp\\_restart} exec's into {\\tt\nmtcp\\_restart}.  The program {\\tt mtcp\\_restart} (source code in\nsrc/mtcp/) is created specially so that the process will consist of a\nsingle relocatable memory segment.  The program relocates itself into\na ``hole'' in memory not occupied by the checkpoint image.  It then\ncalls\\linebreak[4] {\\tt src/mtcp/mtcp\\_restart.c:restorememoryareas()}.\nThis maps the memory areas of the checkpoint image into their original\nmemory addresses.  (``Bits are bits.'')\n\nWhile still in {\\tt restorememoryareas()}, it calls {restore\\_libc()} to\nupdate the information in memory about the different threads.  Finally,\nit calls a function pointer, {\\tt restore\\_info.post\\_restart}, which\nin fact is bound to {\\tt ThreadList::postRestart()} in src/threadlist.cpp.\n\nIt is then the job of {\\tt ThreadList::postRestart()} to create the\nremaining threads and set their state correctly.  Each remaining thread\nfinds itself inside the signal handler again (After all, ``bits are\nbits.''), and the checkpoint thread then releases each thread, as\ndescribed in the previous section.\n\n\n\\subsection*{6. Principle:  DMTCP is contagious}\n\nNew Linux ``tasks'' are created in one of three ways:\n\\begin{enumerate}\n  \\item new thread: created by pthread\\_create() or clone()\n  \\item new process: created by fork()\n  \\item new remote process: typically created by the `system' system call: \\\\\n\t{\\tt system(\"ssh REMOTE\\_HOST a.out\");}\n\\end{enumerate}\n\nDMTCP makes sure to load itself using wrapper functions.\n\n\n\\subsection*{7. Principle:  One DMTCP Coordinator for each DMTCP Computation}\n\nOne may wish to run multiple DMTCP-based computations on a single host.\nThis is easily done by using the {\\tt --host} and {\\tt --port} flags\nof {\\tt dmtcp\\_launch} or of {\\tt dmtcp\\_coordinator}.  If not specified,\nthe default values are localhost and port~7779.  By using {\\tt dmtcp\\_command},\none can communicate a checkpoint or other request to one's\npreferred coordinator (again by specifying host and port, if one is\nnot using the default coordinator).\n\nIn the simplest case, the user invokes only {\\tt dmtcp\\_launch}, with no\nflags.  The {\\tt dmtcp\\_launch} command then looks for an existing\ncoordinator at localhost:7779.  If none is found, {\\tt dmtcp\\_launch}\ninvokes {\\tt dmtcp\\_coordinator} with those default values, localhost:7779.\n\nThus, an occasional issue occurs when two users on the same host each\ninvoke {\\tt dmtcp\\_launch} with default parameters.  They cannot both use\nthe same coordinator.  Similarly, a single user may want to launch two\nindependent computations, and independently checkpoint them.  If the user\ninvokes {\\tt dmtcp\\_launch} (default parameters) for both computation,\nthen there will only be one coordinator.  So, in the view of DMTCP,\nthere will only be a single computation, and a checkpoint command will\ncheckpoint the processes of both computations.\n\n\\subsection*{8. Plugins and other End-User Customizations}\n\nDMTCP offers a rich set of features for customizing the behavior of\nDMTCP.  In this short overview, we will point to examples that can\neasily be modified by an end-user.  See {\\tt doc/plugin-tutorial.pdf}\nfor a more extensive description of plugins.\n\n\\paragraph{DMTCP Plugins.}\n\n{\\em DMTCP plugins\\/} are the most general way to customize DMTCP.  Examples\nare in {\\tt DMTCP\\_ROOT/test/plugin/}.  A dynamic library~({\\tt *.so})\nfile is created to modify the behavior of DMTCP.  The library can\nwrite additional wrapper functions (and even define wrappers around\nprevious wrapper functions).  The library can also register\nto be notified of {\\em DMTCP events}.  In this case, DMTCP will\ncall any plugin functions registered for each event.\nExamples of important events are\n\\hbox{e.g.}~prior to checkpoint, after resume, and after restart\nfrom a checkpoint image.  As of this writing, there is no central\nlist of all DMTCP events, and names of events are still subject to change.\n\nPlugin libraries are preloaded after libdmtcp.so.  As with all\npreloaded libraries, they can initialize themselves before the user's\n``main'' function, and at run-time, plugin wrapper functions will\nbe found in standard Linux library search order prior to ordinary\nlibrary functions in libc.so and elsewhere.\n\nFor example, the sleep2 plugin example uses two plugins.  After building\nthe plugins, it might be called as follows: \\newline\n{\\tt\n\\hbox{\\ \\ }  dmtcp\\_launch --with-plugin $\\backslash$ \\newline\n\\hbox{\\ \\ \\ \\ }\n PATH/sleep1/dmtcp\\_sleep1hijack.so:PATH/sleep2/dmtcp\\_sleep2hijack.so a.out}\n \\newline\nwhere {\\tt PATH} is {\\tt DMTCP\\_ROOT/test/plugin}\n\nIn a more involved example, whenever {\\tt ./configure\n--enable-ptrace-support} is specified, then DMTCP will use the plugin\n{\\tt DMTCP\\_ROOT/plugin/ptrace/ptracehijack.so}.  A new plugin to\nprovide PID/TID virtualization is currently planned.  As with support\nfor ptrace, a more modular structure for PID/TID virtualization will be\neasier to maintain.\n\n\\paragraph{MTCP.}\n\nIn DMTCP-2.1 and earlier, the MTCP component of DMTCP could be compiled\nto run standalone, with opportunities for hook functions using weak symbols.\nMTCP has now been almost entirely re-written, and is now tightly integrated\nwith DMTCP.  {\\em For thos who wished to use the prior MTCP architecture\n(just the checkpoint thread, but no separate coordinator), a plugin\nwith those features is planned for the future.}\n\n\\subsection*{9. Implementation of Plugins}\n\nThe implementation techniques of wrapper functions and pid/tid virtualization\nwe part of the DMTCP implementation not too long after the\ninitial offering of DMTCP.  More recently, this functionality was\nwrapped into a high level abstraction, plugins.  This section emphasizes\nthe implementation of these features.  For information on using plugins,\nand writing your own, see {\\tt doc/plugin-tutorial.pdf}~.\n\n\\subsubsection*{a. Wrapper functions}\n\nWrapper functions are functions around functions.  DMTCP creates\nfunctions around libc.so functions.\nWrapper functions\nare typically created using dlopen/dlsym.  For example, to define\na wrapper around libc:fork(), one defines a function fork()\nin libdmtcp.so (see {\\tt extern \"C\" pid\\_t fork()} in execwrappers.cpp).\n\nContinuing this example, if the user code calls fork(), then we see\nthe following progression.\n\na.out:call to fork() $\\longrightarrow$ libdmtcp.so:fork() $\\longrightarrow$ libc.so:fork()\n\nThe symbol libdmtcp.so:fork appears before libc.so:fork in the\nlibrary search order because libdmtcp.so was loaded before libc.so\n(due to LD\\_PRELOAD).\n\nNext, the wrapper around {\\tt pthread\\_create} remembers the thread id\nof the new thread created.  The wrapper around {\\tt fork} ensures\nthat the environment variable LD\\_PRELOAD is still set to libdmtcp.so.\nIf LD\\_PRELOAD does not currently include libdmtcp.so, then it is\nreset to include libdmtcp.so before the call to fork(), and then\nLD\\_PRELOAD is reset to the original user value after fork().\n\nThe wrapper around {\\tt system} (in the case of creating remote processes)\nis perhaps the most interesting one.  See {\\tt `man system'} for a description\nof the call {\\tt system}.  It looks at an argument, for example\n{\\tt \"ssh REMOTE\\_HOST a.out\"}, and then edits the argument to\n{\\tt \"ssh REMOTE\\_HOST dmtcp\\_launch a.out\"} before calling {\\tt system}.\nOf course, this works only if dmtcp\\_launch is in the user's path\non {\\tt REMOTE\\_HOST}.  This is the responsibility of the user or the\nsystem administrator.\n\n\\subsubsection*{b. PID/TID Virtualization}\n\nAny system calls that refer to a process id (pid) or thread id (tid) requires\na wrapper.  DMTCP then translates between a virtual pid/tid an the\nreal pid/tid.  The user code always sees the virtual pid/tid, while\nthe kernel always sees the real pid/tid.\n\n\\subsubsection*{c. Publish/Subscribe}\n\nPlugins also offer a publish/subscribe service for situations where\na DMTCP computation contains more than one process, and the user\nprocesses must coordinate with each other.  Details are in\n{\\tt doc/plugin-tutorial.pdf}~.\n\n\\end{document}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/include/dmtcpalloc.h",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/test/credentials/conf3.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/test/credentials/conf7.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/test/credentials/conf5.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/test/credentials/conf6.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/test/credentials/conf4.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/test/credentials/conf2.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/contrib/condor/condor-dmtcp-overview.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/doc/architecture-of-dmtcp.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/doc/plugin-tutorial.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/manpages/dmtcp_restart.1.gz",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/manpages/dmtcp_srun_helper.1.gz",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/manpages/dmtcp_coordinator.1.gz",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/manpages/dmtcp_launch.1.gz",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/manpages/dmtcp.1.gz",
        "/tmp/vanessa/spack-stage/spack-stage-dmtcp-2.6.0-hqfho4hkshw6y77vp7d2ir2rvqfcoqb3/spack-src/manpages/dmtcp_command.1.gz"
    ],
    "total_files": 653
}