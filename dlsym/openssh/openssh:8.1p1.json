{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-openssh-8.1p1-zfi2cra5nntkevt3zbx3qsr4hgihce6g/spack-src/configure.ac": "#\n# Copyright (c) 1999-2004 Damien Miller\n#\n# Permission to use, copy, modify, and distribute this software for any\n# purpose with or without fee is hereby granted, provided that the above\n# copyright notice and this permission notice appear in all copies.\n#\n# THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n\nAC_INIT([OpenSSH], [Portable], [openssh-unix-dev@mindrot.org])\nAC_REVISION($Revision: 1.583 $)\nAC_CONFIG_SRCDIR([ssh.c])\nAC_LANG([C])\n\nAC_CONFIG_HEADER([config.h])\nAC_PROG_CC([cc gcc])\nAC_CANONICAL_HOST\nAC_C_BIGENDIAN\n\n# Checks for programs.\nAC_PROG_AWK\nAC_PROG_CPP\nAC_PROG_RANLIB\nAC_PROG_INSTALL\nAC_PROG_EGREP\nAC_PROG_MKDIR_P\nAC_CHECK_TOOLS([AR], [ar])\nAC_PATH_PROG([CAT], [cat])\nAC_PATH_PROG([KILL], [kill])\nAC_PATH_PROG([SED], [sed])\nAC_PATH_PROG([ENT], [ent])\nAC_SUBST([ENT])\nAC_PATH_PROG([TEST_MINUS_S_SH], [bash])\nAC_PATH_PROG([TEST_MINUS_S_SH], [ksh])\nAC_PATH_PROG([TEST_MINUS_S_SH], [sh])\nAC_PATH_PROG([SH], [sh])\nAC_PATH_PROG([GROFF], [groff])\nAC_PATH_PROG([NROFF], [nroff awf])\nAC_PATH_PROG([MANDOC], [mandoc])\nAC_SUBST([TEST_SHELL], [sh])\n\ndnl select manpage formatter to be used to build \"cat\" format pages.\nif test \"x$MANDOC\" != \"x\" ; then\n\tMANFMT=\"$MANDOC\"\nelif test \"x$NROFF\" != \"x\" ; then\n\tMANFMT=\"$NROFF -mandoc\"\nelif test \"x$GROFF\" != \"x\" ; then\n\tMANFMT=\"$GROFF -mandoc -Tascii\"\nelse\n\tAC_MSG_WARN([no manpage formatter found])\n\tMANFMT=\"false\"\nfi\nAC_SUBST([MANFMT])\n\ndnl for buildpkg.sh\nAC_PATH_PROG([PATH_GROUPADD_PROG], [groupadd], [groupadd],\n\t[/usr/sbin${PATH_SEPARATOR}/etc])\nAC_PATH_PROG([PATH_USERADD_PROG], [useradd], [useradd],\n\t[/usr/sbin${PATH_SEPARATOR}/etc])\nAC_CHECK_PROG([MAKE_PACKAGE_SUPPORTED], [pkgmk], [yes], [no])\nif test -x /sbin/sh; then\n\tAC_SUBST([STARTUP_SCRIPT_SHELL], [/sbin/sh])\nelse\n\tAC_SUBST([STARTUP_SCRIPT_SHELL], [/bin/sh])\nfi\n\n# System features\nAC_SYS_LARGEFILE\n\nif test -z \"$AR\" ; then\n\tAC_MSG_ERROR([*** 'ar' missing, please install or fix your \\$PATH ***])\nfi\n\nAC_PATH_PROG([PATH_PASSWD_PROG], [passwd])\nif test ! -z \"$PATH_PASSWD_PROG\" ; then\n\tAC_DEFINE_UNQUOTED([_PATH_PASSWD_PROG], [\"$PATH_PASSWD_PROG\"],\n\t\t[Full path of your \"passwd\" program])\nfi\n\ndnl Since autoconf doesn't support it very well,  we no longer allow users to\ndnl override LD, however keeping the hook here for now in case there's a use\ndnl use case we overlooked and someone needs to re-enable it.  Unless a good\ndnl reason is found we'll be removing this in future.\nLD=\"$CC\"\nAC_SUBST([LD])\n\nAC_C_INLINE\n\nAC_CHECK_DECL([LLONG_MAX], [have_llong_max=1], , [#include <limits.h>])\nAC_CHECK_DECL([SYSTR_POLICY_KILL], [have_systr_policy_kill=1], , [\n\t#include <sys/types.h>\n\t#include <sys/param.h>\n\t#include <dev/systrace.h>\n])\nAC_CHECK_DECL([RLIMIT_NPROC],\n    [AC_DEFINE([HAVE_RLIMIT_NPROC], [], [sys/resource.h has RLIMIT_NPROC])], , [\n\t#include <sys/types.h>\n\t#include <sys/resource.h>\n])\nAC_CHECK_DECL([PR_SET_NO_NEW_PRIVS], [have_linux_no_new_privs=1], , [\n\t#include <sys/types.h>\n\t#include <linux/prctl.h>\n])\n\nopenssl=yes\nAC_ARG_WITH([openssl],\n\t[  --without-openssl       Disable use of OpenSSL; use only limited internal crypto **EXPERIMENTAL** ],\n\t[  if test \"x$withval\" = \"xno\" ; then\n\t\topenssl=no\n\t   fi\n\t]\n)\nAC_MSG_CHECKING([whether OpenSSL will be used for cryptography])\nif test \"x$openssl\" = \"xyes\" ; then\n\tAC_MSG_RESULT([yes])\n\tAC_DEFINE_UNQUOTED([WITH_OPENSSL], [1], [use libcrypto for cryptography])\nelse\n\tAC_MSG_RESULT([no])\nfi\n\nuse_stack_protector=1\nuse_toolchain_hardening=1\nAC_ARG_WITH([stackprotect],\n    [  --without-stackprotect  Don't use compiler's stack protection], [\n    if test \"x$withval\" = \"xno\"; then\n\tuse_stack_protector=0\n    fi ])\nAC_ARG_WITH([hardening],\n    [  --without-hardening     Don't use toolchain hardening flags], [\n    if test \"x$withval\" = \"xno\"; then\n\tuse_toolchain_hardening=0\n    fi ])\n\n# We use -Werror for the tests only so that we catch warnings like \"this is\n# on by default\" for things like -fPIE.\nAC_MSG_CHECKING([if $CC supports -Werror])\nsaved_CFLAGS=\"$CFLAGS\"\nCFLAGS=\"$CFLAGS -Werror\"\nAC_COMPILE_IFELSE([AC_LANG_SOURCE([[int main(void) { return 0; }]])],\n\t[ AC_MSG_RESULT([yes])\n\t  WERROR=\"-Werror\"],\n\t[ AC_MSG_RESULT([no])\n\t  WERROR=\"\" ]\n)\nCFLAGS=\"$saved_CFLAGS\"\n\nif test \"$GCC\" = \"yes\" || test \"$GCC\" = \"egcs\"; then\n\tOSSH_CHECK_CFLAG_COMPILE([-pipe])\n\tOSSH_CHECK_CFLAG_COMPILE([-Wunknown-warning-option])\n\tOSSH_CHECK_CFLAG_COMPILE([-Wno-error=format-truncation])\n\tOSSH_CHECK_CFLAG_COMPILE([-Qunused-arguments])\n\tOSSH_CHECK_CFLAG_COMPILE([-Wall])\n\tOSSH_CHECK_CFLAG_COMPILE([-Wextra])\n\tOSSH_CHECK_CFLAG_COMPILE([-Wpointer-arith])\n\tOSSH_CHECK_CFLAG_COMPILE([-Wuninitialized])\n\tOSSH_CHECK_CFLAG_COMPILE([-Wsign-compare])\n\tOSSH_CHECK_CFLAG_COMPILE([-Wformat-security])\n\tOSSH_CHECK_CFLAG_COMPILE([-Wsizeof-pointer-memaccess])\n\tOSSH_CHECK_CFLAG_COMPILE([-Wpointer-sign], [-Wno-pointer-sign])\n\tOSSH_CHECK_CFLAG_COMPILE([-Wunused-result], [-Wno-unused-result])\n\tOSSH_CHECK_CFLAG_COMPILE([-fno-strict-aliasing])\n    if test \"x$use_toolchain_hardening\" = \"x1\"; then\n\tOSSH_CHECK_CFLAG_COMPILE([-mretpoline]) # clang\n\tOSSH_CHECK_LDFLAG_LINK([-Wl,-z,retpolineplt])\n\tOSSH_CHECK_CFLAG_COMPILE([-D_FORTIFY_SOURCE=2])\n\tOSSH_CHECK_LDFLAG_LINK([-Wl,-z,relro])\n\tOSSH_CHECK_LDFLAG_LINK([-Wl,-z,now])\n\tOSSH_CHECK_LDFLAG_LINK([-Wl,-z,noexecstack])\n\t# NB. -ftrapv expects certain support functions to be present in\n\t# the compiler library (libgcc or similar) to detect integer operations\n\t# that can overflow. We must check that the result of enabling it\n\t# actually links. The test program compiled/linked includes a number\n\t# of integer operations that should exercise this.\n\tOSSH_CHECK_CFLAG_LINK([-ftrapv])\n    fi\n\tAC_MSG_CHECKING([gcc version])\n\tGCC_VER=`$CC -v 2>&1 | $AWK '/gcc version /{print $3}'`\n\tcase $GCC_VER in\n\t\t1.*) no_attrib_nonnull=1 ;;\n\t\t2.8* | 2.9*)\n\t\t     no_attrib_nonnull=1\n\t\t     ;;\n\t\t2.*) no_attrib_nonnull=1 ;;\n\t\t*) ;;\n\tesac\n\tAC_MSG_RESULT([$GCC_VER])\n\n\tAC_MSG_CHECKING([if $CC accepts -fno-builtin-memset])\n\tsaved_CFLAGS=\"$CFLAGS\"\n\tCFLAGS=\"$CFLAGS -fno-builtin-memset\"\n\tAC_LINK_IFELSE([AC_LANG_PROGRAM([[ #include <string.h> ]],\n\t\t\t[[ char b[10]; memset(b, 0, sizeof(b)); ]])],\n\t\t[ AC_MSG_RESULT([yes]) ],\n\t\t[ AC_MSG_RESULT([no])\n\t\t  CFLAGS=\"$saved_CFLAGS\" ]\n\t)\n\n\t# -fstack-protector-all doesn't always work for some GCC versions\n\t# and/or platforms, so we test if we can.  If it's not supported\n\t# on a given platform gcc will emit a warning so we use -Werror.\n\tif test \"x$use_stack_protector\" = \"x1\"; then\n\t    for t in -fstack-protector-strong -fstack-protector-all \\\n\t\t    -fstack-protector; do\n\t\tAC_MSG_CHECKING([if $CC supports $t])\n\t\tsaved_CFLAGS=\"$CFLAGS\"\n\t\tsaved_LDFLAGS=\"$LDFLAGS\"\n\t\tCFLAGS=\"$CFLAGS $t -Werror\"\n\t\tLDFLAGS=\"$LDFLAGS $t -Werror\"\n\t\tAC_LINK_IFELSE(\n\t\t\t[AC_LANG_PROGRAM([[ #include <stdio.h> ]],\n\t\t\t[[\n\tchar x[256];\n\tsnprintf(x, sizeof(x), \"XXX\");\n\t\t\t ]])],\n\t\t    [ AC_MSG_RESULT([yes])\n\t\t      CFLAGS=\"$saved_CFLAGS $t\"\n\t\t      LDFLAGS=\"$saved_LDFLAGS $t\"\n\t\t      AC_MSG_CHECKING([if $t works])\n\t\t      AC_RUN_IFELSE(\n\t\t\t[AC_LANG_PROGRAM([[ #include <stdio.h> ]],\n\t\t\t[[\n\tchar x[256];\n\tsnprintf(x, sizeof(x), \"XXX\");\n\t\t\t]])],\n\t\t\t[ AC_MSG_RESULT([yes])\n\t\t\t  break ],\n\t\t\t[ AC_MSG_RESULT([no]) ],\n\t\t\t[ AC_MSG_WARN([cross compiling: cannot test])\n\t\t\t  break ]\n\t\t      )\n\t\t    ],\n\t\t    [ AC_MSG_RESULT([no]) ]\n\t\t)\n\t\tCFLAGS=\"$saved_CFLAGS\"\n\t\tLDFLAGS=\"$saved_LDFLAGS\"\n\t    done\n\tfi\n\n\tif test -z \"$have_llong_max\"; then\n\t\t# retry LLONG_MAX with -std=gnu99, needed on some Linuxes\n\t\tunset ac_cv_have_decl_LLONG_MAX\n\t\tsaved_CFLAGS=\"$CFLAGS\"\n\t\tCFLAGS=\"$CFLAGS -std=gnu99\"\n\t\tAC_CHECK_DECL([LLONG_MAX],\n\t\t    [have_llong_max=1],\n\t\t    [CFLAGS=\"$saved_CFLAGS\"],\n\t\t    [#include <limits.h>]\n\t\t)\n\tfi\nfi\n\nAC_MSG_CHECKING([if compiler allows __attribute__ on return types])\nAC_COMPILE_IFELSE(\n    [AC_LANG_PROGRAM([[\n#include <stdlib.h>\n__attribute__((__unused__)) static void foo(void){return;}]],\n    [[ exit(0); ]])],\n    [ AC_MSG_RESULT([yes]) ],\n    [ AC_MSG_RESULT([no])\n      AC_DEFINE(NO_ATTRIBUTE_ON_RETURN_TYPE, 1,\n\t [compiler does not accept __attribute__ on return types]) ]\n)\n\nAC_MSG_CHECKING([if compiler allows __attribute__ prototype args])\nAC_COMPILE_IFELSE(\n    [AC_LANG_PROGRAM([[\n#include <stdlib.h>\ntypedef void foo(const char *, ...) __attribute__((format(printf, 1, 2)));]],\n    [[ exit(0); ]])],\n    [ AC_MSG_RESULT([yes]) ],\n    [ AC_MSG_RESULT([no])\n      AC_DEFINE(NO_ATTRIBUTE_ON_PROTOTYPE_ARGS, 1,\n\t [compiler does not accept __attribute__ on prototype args]) ]\n)\n\nif test \"x$no_attrib_nonnull\" != \"x1\" ; then\n\tAC_DEFINE([HAVE_ATTRIBUTE__NONNULL__], [1], [Have attribute nonnull])\nfi\n\nAC_ARG_WITH([rpath],\n\t[  --without-rpath         Disable auto-added -R linker paths],\n\t[\n\t\tif test \"x$withval\" = \"xno\" ; then\n\t\t\trpath_opt=\"\"\n\t\telif test \"x$withval\" = \"xyes\" ; then\n\t\t\trpath_opt=\"-R\"\n\t\telse\n\t\t\trpath_opt=\"$withval\"\n\t\tfi\n\t]\n)\n\n# Allow user to specify flags\nAC_ARG_WITH([cflags],\n\t[  --with-cflags           Specify additional flags to pass to compiler],\n\t[\n\t\tif test -n \"$withval\"  &&  test \"x$withval\" != \"xno\"  &&  \\\n\t\t    test \"x${withval}\" != \"xyes\"; then\n\t\t\tCFLAGS=\"$CFLAGS $withval\"\n\t\tfi\n\t]\n)\n\nAC_ARG_WITH([cflags-after],\n\t[  --with-cflags-after     Specify additional flags to pass to compiler after configure],\n\t[\n\t\tif test -n \"$withval\"  &&  test \"x$withval\" != \"xno\"  &&  \\\n\t\t    test \"x${withval}\" != \"xyes\"; then\n\t\t\tCFLAGS_AFTER=\"$withval\"\n\t\tfi\n\t]\n)\nAC_ARG_WITH([cppflags],\n\t[  --with-cppflags         Specify additional flags to pass to preprocessor] ,\n\t[\n\t\tif test -n \"$withval\"  &&  test \"x$withval\" != \"xno\"  &&  \\\n\t\t    test \"x${withval}\" != \"xyes\"; then\n\t\t\tCPPFLAGS=\"$CPPFLAGS $withval\"\n\t\tfi\n\t]\n)\nAC_ARG_WITH([ldflags],\n\t[  --with-ldflags          Specify additional flags to pass to linker],\n\t[\n\t\tif test -n \"$withval\"  &&  test \"x$withval\" != \"xno\"  &&  \\\n\t\t    test \"x${withval}\" != \"xyes\"; then\n\t\t\tLDFLAGS=\"$LDFLAGS $withval\"\n\t\tfi\n\t]\n)\nAC_ARG_WITH([ldflags-after],\n\t[  --with-ldflags-after    Specify additional flags to pass to linker after configure],\n\t[\n\t\tif test -n \"$withval\"  &&  test \"x$withval\" != \"xno\"  &&  \\\n\t\t    test \"x${withval}\" != \"xyes\"; then\n\t\t\tLDFLAGS_AFTER=\"$withval\"\n\t\tfi\n\t]\n)\nAC_ARG_WITH([libs],\n\t[  --with-libs             Specify additional libraries to link with],\n\t[\n\t\tif test -n \"$withval\"  &&  test \"x$withval\" != \"xno\"  &&  \\\n\t\t    test \"x${withval}\" != \"xyes\"; then\n\t\t\tLIBS=\"$LIBS $withval\"\n\t\tfi\n\t]\n)\nAC_ARG_WITH([Werror],\n\t[  --with-Werror           Build main code with -Werror],\n\t[\n\t\tif test -n \"$withval\"  &&  test \"x$withval\" != \"xno\"; then\n\t\t\twerror_flags=\"-Werror\"\n\t\t\tif test \"x${withval}\" != \"xyes\"; then\n\t\t\t\twerror_flags=\"$withval\"\n\t\t\tfi\n\t\tfi\n\t]\n)\n\nAC_CHECK_HEADERS([ \\\n\tblf.h \\\n\tbstring.h \\\n\tcrypt.h \\\n\tcrypto/sha2.h \\\n\tdirent.h \\\n\tendian.h \\\n\telf.h \\\n\terr.h \\\n\tfeatures.h \\\n\tfcntl.h \\\n\tfloatingpoint.h \\\n\tgetopt.h \\\n\tglob.h \\\n\tia.h \\\n\tiaf.h \\\n\tifaddrs.h \\\n\tinttypes.h \\\n\tlanginfo.h \\\n\tlimits.h \\\n\tlocale.h \\\n\tlogin.h \\\n\tmaillock.h \\\n\tndir.h \\\n\tnet/if_tun.h \\\n\tnetdb.h \\\n\tnetgroup.h \\\n\tpam/pam_appl.h \\\n\tpaths.h \\\n\tpoll.h \\\n\tpty.h \\\n\treadpassphrase.h \\\n\trpc/types.h \\\n\tsecurity/pam_appl.h \\\n\tsha2.h \\\n\tshadow.h \\\n\tstddef.h \\\n\tstdint.h \\\n\tstring.h \\\n\tstrings.h \\\n\tsys/bitypes.h \\\n\tsys/bsdtty.h \\\n\tsys/cdefs.h \\\n\tsys/dir.h \\\n\tsys/file.h \\\n\tsys/mman.h \\\n\tsys/label.h \\\n\tsys/ndir.h \\\n\tsys/poll.h \\\n\tsys/prctl.h \\\n\tsys/pstat.h \\\n\tsys/ptrace.h \\\n\tsys/random.h \\\n\tsys/select.h \\\n\tsys/stat.h \\\n\tsys/stream.h \\\n\tsys/stropts.h \\\n\tsys/strtio.h \\\n\tsys/statvfs.h \\\n\tsys/sysmacros.h \\\n\tsys/time.h \\\n\tsys/timers.h \\\n\tsys/vfs.h \\\n\ttime.h \\\n\ttmpdir.h \\\n\tttyent.h \\\n\tucred.h \\\n\tunistd.h \\\n\tusersec.h \\\n\tutil.h \\\n\tutime.h \\\n\tutmp.h \\\n\tutmpx.h \\\n\tvis.h \\\n\twchar.h \\\n])\n\n# On some platforms (eg SunOS4) sys/audit.h requires sys/[time|types|label.h]\n# to be included first.\nAC_CHECK_HEADERS([sys/audit.h], [], [], [\n#ifdef HAVE_SYS_TIME_H\n# include <sys/time.h>\n#endif\n#ifdef HAVE_SYS_TYPES_H\n# include <sys/types.h>\n#endif\n#ifdef HAVE_SYS_LABEL_H\n# include <sys/label.h>\n#endif\n])\n\n# sys/capsicum.h requires sys/types.h\nAC_CHECK_HEADERS([sys/capsicum.h], [], [], [\n#ifdef HAVE_SYS_TYPES_H\n# include <sys/types.h>\n#endif\n])\n\n# net/route.h requires sys/socket.h and sys/types.h.\n# sys/sysctl.h also requires sys/param.h\nAC_CHECK_HEADERS([net/route.h sys/sysctl.h], [], [], [\n#ifdef HAVE_SYS_TYPES_H\n# include <sys/types.h>\n#endif\n#include <sys/param.h>\n#include <sys/socket.h>\n])\n\n# lastlog.h requires sys/time.h to be included first on Solaris\nAC_CHECK_HEADERS([lastlog.h], [], [], [\n#ifdef HAVE_SYS_TIME_H\n# include <sys/time.h>\n#endif\n])\n\n# sys/ptms.h requires sys/stream.h to be included first on Solaris\nAC_CHECK_HEADERS([sys/ptms.h], [], [], [\n#ifdef HAVE_SYS_STREAM_H\n# include <sys/stream.h>\n#endif\n])\n\n# login_cap.h requires sys/types.h on NetBSD\nAC_CHECK_HEADERS([login_cap.h], [], [], [\n#include <sys/types.h>\n])\n\n# older BSDs need sys/param.h before sys/mount.h\nAC_CHECK_HEADERS([sys/mount.h], [], [], [\n#include <sys/param.h>\n])\n\n# Android requires sys/socket.h to be included before sys/un.h\nAC_CHECK_HEADERS([sys/un.h], [], [], [\n#include <sys/types.h>\n#include <sys/socket.h>\n])\n\n# Messages for features tested for in target-specific section\nSIA_MSG=\"no\"\nSPC_MSG=\"no\"\nSP_MSG=\"no\"\nSPP_MSG=\"no\"\n\n# Support for Solaris/Illumos privileges (this test is used by both\n# the --with-solaris-privs option and --with-sandbox=solaris).\nSOLARIS_PRIVS=\"no\"\n\n# Check for some target-specific stuff\ncase \"$host\" in\n*-*-aix*)\n\t# Some versions of VAC won't allow macro redefinitions at\n\t# -qlanglevel=ansi, and autoconf 2.60 sometimes insists on using that\n\t# particularly with older versions of vac or xlc.\n\t# It also throws errors about null macro arguments, but these are\n\t# not fatal.\n\tAC_MSG_CHECKING([if compiler allows macro redefinitions])\n\tAC_COMPILE_IFELSE(\n\t    [AC_LANG_PROGRAM([[\n#define testmacro foo\n#define testmacro bar]],\n\t    [[ exit(0); ]])],\n\t    [ AC_MSG_RESULT([yes]) ],\n\t    [ AC_MSG_RESULT([no])\n\t      CC=\"`echo $CC | sed 's/-qlanglvl\\=ansi//g'`\"\n\t      CFLAGS=\"`echo $CFLAGS | sed 's/-qlanglvl\\=ansi//g'`\"\n\t      CPPFLAGS=\"`echo $CPPFLAGS | sed 's/-qlanglvl\\=ansi//g'`\"\n\t    ]\n\t)\n\n\tAC_MSG_CHECKING([how to specify blibpath for linker ($LD)])\n\tif (test -z \"$blibpath\"); then\n\t\tblibpath=\"/usr/lib:/lib\"\n\tfi\n\tsaved_LDFLAGS=\"$LDFLAGS\"\n\tif test \"$GCC\" = \"yes\"; then\n\t\tflags=\"-Wl,-blibpath: -Wl,-rpath, -blibpath:\"\n\telse\n\t\tflags=\"-blibpath: -Wl,-blibpath: -Wl,-rpath,\"\n\tfi\n\tfor tryflags in $flags ;do\n\t\tif (test -z \"$blibflags\"); then\n\t\t\tLDFLAGS=\"$saved_LDFLAGS $tryflags$blibpath\"\n\t\t\tAC_LINK_IFELSE([AC_LANG_PROGRAM([[]], [[]])],\n\t\t\t[blibflags=$tryflags], [])\n\t\tfi\n\tdone\n\tif (test -z \"$blibflags\"); then\n\t\tAC_MSG_RESULT([not found])\n\t\tAC_MSG_ERROR([*** must be able to specify blibpath on AIX - check config.log])\n\telse\n\t\tAC_MSG_RESULT([$blibflags])\n\tfi\n\tLDFLAGS=\"$saved_LDFLAGS\"\n\tdnl Check for authenticate.  Might be in libs.a on older AIXes\n\tAC_CHECK_FUNC([authenticate], [AC_DEFINE([WITH_AIXAUTHENTICATE], [1],\n\t\t[Define if you want to enable AIX4's authenticate function])],\n\t\t[AC_CHECK_LIB([s], [authenticate],\n\t\t\t[ AC_DEFINE([WITH_AIXAUTHENTICATE])\n\t\t\t\tLIBS=\"$LIBS -ls\"\n\t\t\t])\n\t\t])\n\tdnl Check for various auth function declarations in headers.\n\tAC_CHECK_DECLS([authenticate, loginrestrictions, loginsuccess,\n\t    passwdexpired, setauthdb], , , [#include <usersec.h>])\n\tdnl Check if loginfailed is declared and takes 4 arguments (AIX >= 5.2)\n\tAC_CHECK_DECLS([loginfailed],\n\t    [AC_MSG_CHECKING([if loginfailed takes 4 arguments])\n\t    AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[ #include <usersec.h> ]],\n\t\t[[ (void)loginfailed(\"user\",\"host\",\"tty\",0); ]])],\n\t\t[AC_MSG_RESULT([yes])\n\t\tAC_DEFINE([AIX_LOGINFAILED_4ARG], [1],\n\t\t\t[Define if your AIX loginfailed() function\n\t\t\ttakes 4 arguments (AIX >= 5.2)])], [AC_MSG_RESULT([no])\n\t    ])],\n\t    [],\n\t    [#include <usersec.h>]\n\t)\n\tAC_CHECK_FUNCS([getgrset setauthdb])\n\tAC_CHECK_DECL([F_CLOSEM],\n\t    AC_DEFINE([HAVE_FCNTL_CLOSEM], [1], [Use F_CLOSEM fcntl for closefrom]),\n\t    [],\n\t    [ #include <limits.h>\n\t      #include <fcntl.h> ]\n\t)\n\tcheck_for_aix_broken_getaddrinfo=1\n\tAC_DEFINE([SETEUID_BREAKS_SETUID], [1],\n\t    [Define if your platform breaks doing a seteuid before a setuid])\n\tAC_DEFINE([BROKEN_SETREUID], [1], [Define if your setreuid() is broken])\n\tAC_DEFINE([BROKEN_SETREGID], [1], [Define if your setregid() is broken])\n\tdnl AIX handles lastlog as part of its login message\n\tAC_DEFINE([DISABLE_LASTLOG], [1], [Define if you don't want to use lastlog])\n\tAC_DEFINE([LOGIN_NEEDS_UTMPX], [1],\n\t\t[Some systems need a utmpx entry for /bin/login to work])\n\tAC_DEFINE([SPT_TYPE], [SPT_REUSEARGV],\n\t\t[Define to a Set Process Title type if your system is\n\t\tsupported by bsd-setproctitle.c])\n\tAC_DEFINE([SSHPAM_CHAUTHTOK_NEEDS_RUID], [1],\n\t    [AIX 5.2 and 5.3 (and presumably newer) require this])\n\tAC_DEFINE([PTY_ZEROREAD], [1], [read(1) can return 0 for a non-closed fd])\n\tAC_DEFINE([PLATFORM_SYS_DIR_UID], 2, [System dirs owned by bin (uid 2)])\n\tAC_DEFINE([BROKEN_STRNDUP], 1, [strndup broken, see APAR IY61211])\n\tAC_DEFINE([BROKEN_STRNLEN], 1, [strnlen broken, see APAR IY62551])\n\t;;\n*-*-android*)\n\tAC_DEFINE([DISABLE_UTMP], [1], [Define if you don't want to use utmp])\n\tAC_DEFINE([DISABLE_WTMP], [1], [Define if you don't want to use wtmp])\n\t;;\n*-*-cygwin*)\n\tcheck_for_libcrypt_later=1\n\tLIBS=\"$LIBS /usr/lib/textreadmode.o\"\n\tAC_DEFINE([HAVE_CYGWIN], [1], [Define if you are on Cygwin])\n\tAC_DEFINE([USE_PIPES], [1], [Use PIPES instead of a socketpair()])\n\tAC_DEFINE([NO_UID_RESTORATION_TEST], [1],\n\t\t[Define to disable UID restoration test])\n\tAC_DEFINE([DISABLE_SHADOW], [1],\n\t\t[Define if you want to disable shadow passwords])\n\tAC_DEFINE([NO_X11_UNIX_SOCKETS], [1],\n\t\t[Define if X11 doesn't support AF_UNIX sockets on that system])\n\tAC_DEFINE([DISABLE_FD_PASSING], [1],\n\t\t[Define if your platform needs to skip post auth\n\t\tfile descriptor passing])\n\tAC_DEFINE([SSH_IOBUFSZ], [65535], [Windows is sensitive to read buffer size])\n\tAC_DEFINE([FILESYSTEM_NO_BACKSLASH], [1], [File names may not contain backslash characters])\n\t# Cygwin defines optargs, optargs as declspec(dllimport) for historical\n\t# reasons which cause compile warnings, so we disable those warnings.\n\tOSSH_CHECK_CFLAG_COMPILE([-Wno-attributes])\n\t;;\n*-*-dgux*)\n\tAC_DEFINE([IP_TOS_IS_BROKEN], [1],\n\t\t[Define if your system choked on IP TOS setting])\n\tAC_DEFINE([SETEUID_BREAKS_SETUID])\n\tAC_DEFINE([BROKEN_SETREUID])\n\tAC_DEFINE([BROKEN_SETREGID])\n\t;;\n*-*-darwin*)\n\tuse_pie=auto\n\tAC_MSG_CHECKING([if we have working getaddrinfo])\n\tAC_RUN_IFELSE([AC_LANG_SOURCE([[ #include <mach-o/dyld.h>\nmain() { if (NSVersionOfRunTimeLibrary(\"System\") >= (60 << 16))\n\t\texit(0);\n\telse\n\t\texit(1);\n}\n\t\t\t]])],\n\t[AC_MSG_RESULT([working])],\n\t[AC_MSG_RESULT([buggy])\n\tAC_DEFINE([BROKEN_GETADDRINFO], [1],\n\t\t[getaddrinfo is broken (if present)])\n\t],\n\t[AC_MSG_RESULT([assume it is working])])\n\tAC_DEFINE([SETEUID_BREAKS_SETUID])\n\tAC_DEFINE([BROKEN_SETREUID])\n\tAC_DEFINE([BROKEN_SETREGID])\n\tAC_DEFINE([BROKEN_GLOB], [1], [OS X glob does not do what we expect])\n\tAC_DEFINE_UNQUOTED([BIND_8_COMPAT], [1],\n\t\t[Define if your resolver libs need this for getrrsetbyname])\n\tAC_DEFINE([SSH_TUN_FREEBSD], [1], [Open tunnel devices the FreeBSD way])\n\tAC_DEFINE([SSH_TUN_COMPAT_AF], [1],\n\t    [Use tunnel device compatibility to OpenBSD])\n\tAC_DEFINE([SSH_TUN_PREPEND_AF], [1],\n\t    [Prepend the address family to IP tunnel traffic])\n\tm4_pattern_allow([AU_IPv])\n\tAC_CHECK_DECL([AU_IPv4], [],\n\t    AC_DEFINE([AU_IPv4], [0], [System only supports IPv4 audit records])\n\t    [#include <bsm/audit.h>]\n\tAC_DEFINE([LASTLOG_WRITE_PUTUTXLINE], [1],\n\t    [Define if pututxline updates lastlog too])\n\t)\n\tAC_DEFINE([SPT_TYPE], [SPT_REUSEARGV],\n\t\t[Define to a Set Process Title type if your system is\n\t\tsupported by bsd-setproctitle.c])\n\tAC_CHECK_FUNCS([sandbox_init])\n\tAC_CHECK_HEADERS([sandbox.h])\n\tAC_CHECK_LIB([sandbox], [sandbox_apply], [\n\t    SSHDLIBS=\"$SSHDLIBS -lsandbox\"\n\t])\n\t# proc_pidinfo()-based closefrom() replacement.\n\tAC_CHECK_HEADERS([libproc.h])\n\tAC_CHECK_FUNCS([proc_pidinfo])\n\t;;\n*-*-dragonfly*)\n\tSSHDLIBS=\"$SSHDLIBS -lcrypt\"\n\tTEST_MALLOC_OPTIONS=\"AFGJPRX\"\n\t;;\n*-*-haiku*)\n\tLIBS=\"$LIBS -lbsd \"\n\tAC_CHECK_LIB([network], [socket])\n\tAC_DEFINE([HAVE_U_INT64_T])\n\tMANTYPE=man\n\t;;\n*-*-hpux*)\n\t# first we define all of the options common to all HP-UX releases\n\tCPPFLAGS=\"$CPPFLAGS -D_HPUX_SOURCE -D_XOPEN_SOURCE -D_XOPEN_SOURCE_EXTENDED=1\"\n\tIPADDR_IN_DISPLAY=yes\n\tAC_DEFINE([USE_PIPES])\n\tAC_DEFINE([LOGIN_NEEDS_UTMPX])\n\tAC_DEFINE([LOCKED_PASSWD_STRING], [\"*\"],\n\t\t[String used in /etc/passwd to denote locked account])\n\tAC_DEFINE([SPT_TYPE], [SPT_PSTAT])\n\tAC_DEFINE([PLATFORM_SYS_DIR_UID], 2, [System dirs owned by bin (uid 2)])\n\tmaildir=\"/var/mail\"\n\tLIBS=\"$LIBS -lsec\"\n\tAC_CHECK_LIB([xnet], [t_error], ,\n\t    [AC_MSG_ERROR([*** -lxnet needed on HP-UX - check config.log ***])])\n\n\t# next, we define all of the options specific to major releases\n\tcase \"$host\" in\n\t*-*-hpux10*)\n\t\tif test -z \"$GCC\"; then\n\t\t\tCFLAGS=\"$CFLAGS -Ae\"\n\t\tfi\n\t\t;;\n\t*-*-hpux11*)\n\t\tAC_DEFINE([PAM_SUN_CODEBASE], [1],\n\t\t\t[Define if you are using Solaris-derived PAM which\n\t\t\tpasses pam_messages to the conversation function\n\t\t\twith an extra level of indirection])\n\t\tAC_DEFINE([DISABLE_UTMP], [1],\n\t\t\t[Define if you don't want to use utmp])\n\t\tAC_DEFINE([USE_BTMP], [1], [Use btmp to log bad logins])\n\t\tcheck_for_hpux_broken_getaddrinfo=1\n\t\tcheck_for_conflicting_getspnam=1\n\t\t;;\n\tesac\n\n\t# lastly, we define options specific to minor releases\n\tcase \"$host\" in\n\t*-*-hpux10.26)\n\t\tAC_DEFINE([HAVE_SECUREWARE], [1],\n\t\t\t[Define if you have SecureWare-based\n\t\t\tprotected password database])\n\t\tdisable_ptmx_check=yes\n\t\tLIBS=\"$LIBS -lsecpw\"\n\t\t;;\n\tesac\n\t;;\n*-*-irix5*)\n\tPATH=\"$PATH:/usr/etc\"\n\tAC_DEFINE([BROKEN_INET_NTOA], [1],\n\t\t[Define if you system's inet_ntoa is busted\n\t\t(e.g. Irix gcc issue)])\n\tAC_DEFINE([SETEUID_BREAKS_SETUID])\n\tAC_DEFINE([BROKEN_SETREUID])\n\tAC_DEFINE([BROKEN_SETREGID])\n\tAC_DEFINE([WITH_ABBREV_NO_TTY], [1],\n\t\t[Define if you shouldn't strip 'tty' from your\n\t\tttyname in [uw]tmp])\n\tAC_DEFINE([LOCKED_PASSWD_STRING], [\"*LK*\"])\n\t;;\n*-*-irix6*)\n\tPATH=\"$PATH:/usr/etc\"\n\tAC_DEFINE([WITH_IRIX_ARRAY], [1],\n\t\t[Define if you have/want arrays\n\t\t(cluster-wide session management, not C arrays)])\n\tAC_DEFINE([WITH_IRIX_PROJECT], [1],\n\t\t[Define if you want IRIX project management])\n\tAC_DEFINE([WITH_IRIX_AUDIT], [1],\n\t\t[Define if you want IRIX audit trails])\n\tAC_CHECK_FUNC([jlimit_startjob], [AC_DEFINE([WITH_IRIX_JOBS], [1],\n\t\t[Define if you want IRIX kernel jobs])])\n\tAC_DEFINE([BROKEN_INET_NTOA])\n\tAC_DEFINE([SETEUID_BREAKS_SETUID])\n\tAC_DEFINE([BROKEN_SETREUID])\n\tAC_DEFINE([BROKEN_SETREGID])\n\tAC_DEFINE([BROKEN_UPDWTMPX], [1], [updwtmpx is broken (if present)])\n\tAC_DEFINE([WITH_ABBREV_NO_TTY])\n\tAC_DEFINE([LOCKED_PASSWD_STRING], [\"*LK*\"])\n\t;;\n*-*-k*bsd*-gnu | *-*-kopensolaris*-gnu)\n\tcheck_for_libcrypt_later=1\n\tAC_DEFINE([PAM_TTY_KLUDGE])\n\tAC_DEFINE([LOCKED_PASSWD_PREFIX], [\"!\"])\n\tAC_DEFINE([SPT_TYPE], [SPT_REUSEARGV])\n\tAC_DEFINE([_PATH_BTMP], [\"/var/log/btmp\"], [log for bad login attempts])\n\tAC_DEFINE([USE_BTMP], [1], [Use btmp to log bad logins])\n\t;;\n*-*-linux*)\n\tno_dev_ptmx=1\n\tuse_pie=auto\n\tcheck_for_libcrypt_later=1\n\tcheck_for_openpty_ctty_bug=1\n\tdnl Target SUSv3/POSIX.1-2001 plus BSD specifics.\n\tdnl _DEFAULT_SOURCE is the new name for _BSD_SOURCE\n\tCPPFLAGS=\"$CPPFLAGS -D_XOPEN_SOURCE=600 -D_BSD_SOURCE -D_DEFAULT_SOURCE\"\n\tAC_DEFINE([PAM_TTY_KLUDGE], [1],\n\t\t[Work around problematic Linux PAM modules handling of PAM_TTY])\n\tAC_DEFINE([LOCKED_PASSWD_PREFIX], [\"!\"],\n\t\t[String used in /etc/passwd to denote locked account])\n\tAC_DEFINE([SPT_TYPE], [SPT_REUSEARGV])\n\tAC_DEFINE([LINK_OPNOTSUPP_ERRNO], [EPERM],\n\t\t[Define to whatever link() returns for \"not supported\"\n\t\tif it doesn't return EOPNOTSUPP.])\n\tAC_DEFINE([_PATH_BTMP], [\"/var/log/btmp\"], [log for bad login attempts])\n\tAC_DEFINE([USE_BTMP])\n\tAC_DEFINE([LINUX_OOM_ADJUST], [1], [Adjust Linux out-of-memory killer])\n\tinet6_default_4in6=yes\n\tcase `uname -r` in\n\t1.*|2.0.*)\n\t\tAC_DEFINE([BROKEN_CMSG_TYPE], [1],\n\t\t\t[Define if cmsg_type is not passed correctly])\n\t\t;;\n\tesac\n\t# tun(4) forwarding compat code\n\tAC_CHECK_HEADERS([linux/if_tun.h])\n\tif test \"x$ac_cv_header_linux_if_tun_h\" = \"xyes\" ; then\n\t\tAC_DEFINE([SSH_TUN_LINUX], [1],\n\t\t    [Open tunnel devices the Linux tun/tap way])\n\t\tAC_DEFINE([SSH_TUN_COMPAT_AF], [1],\n\t\t    [Use tunnel device compatibility to OpenBSD])\n\t\tAC_DEFINE([SSH_TUN_PREPEND_AF], [1],\n\t\t    [Prepend the address family to IP tunnel traffic])\n\tfi\n\tAC_CHECK_HEADER([linux/if.h],\n\t    AC_DEFINE([SYS_RDOMAIN_LINUX], [1],\n\t\t[Support routing domains using Linux VRF]), [], [\n#ifdef HAVE_SYS_TYPES_H\n# include <sys/types.h>\n#endif\n\t    ])\n\tAC_CHECK_HEADERS([linux/seccomp.h linux/filter.h linux/audit.h], [],\n\t    [], [#include <linux/types.h>])\n\t# Obtain MIPS ABI\n\tcase \"$host\" in\n\tmips*)\n\t\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#if _MIPS_SIM != _ABIO32\n#error\n#endif\n\t\t\t]])],[mips_abi=\"o32\"],[AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#if _MIPS_SIM != _ABIN32\n#error\n#endif\n\t\t\t\t]])],[mips_abi=\"n32\"],[AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#if _MIPS_SIM != _ABI64\n#error\n#endif\n\t\t\t\t\t]])],[mips_abi=\"n64\"],[AC_MSG_ERROR([unknown MIPS ABI])\n\t\t\t\t])\n\t\t\t])\n\t\t])\n\t\t;;\n\tesac\n\tAC_MSG_CHECKING([for seccomp architecture])\n\tseccomp_audit_arch=\n\tcase \"$host\" in\n\tx86_64-*)\n\t\tseccomp_audit_arch=AUDIT_ARCH_X86_64\n\t\t;;\n\ti*86-*)\n\t\tseccomp_audit_arch=AUDIT_ARCH_I386\n\t\t;;\n\tarm*-*)\n\t\tseccomp_audit_arch=AUDIT_ARCH_ARM\n\t\t;;\n\taarch64*-*)\n\t\tseccomp_audit_arch=AUDIT_ARCH_AARCH64\n\t\t;;\n\ts390x-*)\n\t\tseccomp_audit_arch=AUDIT_ARCH_S390X\n\t\t;;\n\ts390-*)\n\t\tseccomp_audit_arch=AUDIT_ARCH_S390\n\t\t;;\n\tpowerpc64-*)\n\t\tseccomp_audit_arch=AUDIT_ARCH_PPC64\n\t\t;;\n\tpowerpc64le-*)\n\t\tseccomp_audit_arch=AUDIT_ARCH_PPC64LE\n\t\t;;\n\tmips-*)\n\t\tseccomp_audit_arch=AUDIT_ARCH_MIPS\n\t\t;;\n\tmipsel-*)\n\t\tseccomp_audit_arch=AUDIT_ARCH_MIPSEL\n\t\t;;\n\tmips64-*)\n\t\tcase \"$mips_abi\" in\n\t\t\"n32\")\n\t\t\tseccomp_audit_arch=AUDIT_ARCH_MIPS64N32\n\t\t\t;;\n\t\t\"n64\")\n\t\t\tseccomp_audit_arch=AUDIT_ARCH_MIPS64\n\t\t\t;;\n\t\tesac\n\t\t;;\n\tmips64el-*)\n\t\tcase \"$mips_abi\" in\n\t\t\"n32\")\n\t\t\tseccomp_audit_arch=AUDIT_ARCH_MIPSEL64N32\n\t\t\t;;\n\t\t\"n64\")\n\t\t\tseccomp_audit_arch=AUDIT_ARCH_MIPSEL64\n\t\t\t;;\n\t\tesac\n\t\t;;\n\tesac\n\tif test \"x$seccomp_audit_arch\" != \"x\" ; then\n\t\tAC_MSG_RESULT([\"$seccomp_audit_arch\"])\n\t\tAC_DEFINE_UNQUOTED([SECCOMP_AUDIT_ARCH], [$seccomp_audit_arch],\n\t\t    [Specify the system call convention in use])\n\telse\n\t\tAC_MSG_RESULT([architecture not supported])\n\tfi\n\t;;\nmips-sony-bsd|mips-sony-newsos4)\n\tAC_DEFINE([NEED_SETPGRP], [1], [Need setpgrp to acquire controlling tty])\n\tSONY=1\n\t;;\n*-*-netbsd*)\n\tcheck_for_libcrypt_before=1\n\tif test \"x$withval\" != \"xno\" ; then\n\t\trpath_opt=\"-R\"\n\tfi\n\tCPPFLAGS=\"$CPPFLAGS -D_OPENBSD_SOURCE\"\n\tAC_DEFINE([SSH_TUN_FREEBSD], [1], [Open tunnel devices the FreeBSD way])\n\tAC_CHECK_HEADER([net/if_tap.h], ,\n\t    AC_DEFINE([SSH_TUN_NO_L2], [1], [No layer 2 tunnel support]))\n\tAC_DEFINE([SSH_TUN_PREPEND_AF], [1],\n\t    [Prepend the address family to IP tunnel traffic])\n\tTEST_MALLOC_OPTIONS=\"AJRX\"\n\tAC_DEFINE([BROKEN_READ_COMPARISON], [1],\n\t    [NetBSD read function is sometimes redirected, breaking atomicio comparisons against it])\n\t;;\n*-*-freebsd*)\n\tcheck_for_libcrypt_later=1\n\tAC_DEFINE([LOCKED_PASSWD_PREFIX], [\"*LOCKED*\"], [Account locked with pw(1)])\n\tAC_DEFINE([SSH_TUN_FREEBSD], [1], [Open tunnel devices the FreeBSD way])\n\tAC_CHECK_HEADER([net/if_tap.h], ,\n\t    AC_DEFINE([SSH_TUN_NO_L2], [1], [No layer 2 tunnel support]))\n\tAC_DEFINE([BROKEN_GLOB], [1], [FreeBSD glob does not do what we need])\n\tTEST_MALLOC_OPTIONS=\"AJRX\"\n\t# Preauth crypto occasionally uses file descriptors for crypto offload\n\t# and will crash if they cannot be opened.\n\tAC_DEFINE([SANDBOX_SKIP_RLIMIT_NOFILE], [1],\n\t    [define if setrlimit RLIMIT_NOFILE breaks things])\n\t;;\n*-*-bsdi*)\n\tAC_DEFINE([SETEUID_BREAKS_SETUID])\n\tAC_DEFINE([BROKEN_SETREUID])\n\tAC_DEFINE([BROKEN_SETREGID])\n\t;;\n*-next-*)\n\tconf_lastlog_location=\"/usr/adm/lastlog\"\n\tconf_utmp_location=/etc/utmp\n\tconf_wtmp_location=/usr/adm/wtmp\n\tmaildir=/usr/spool/mail\n\tAC_DEFINE([HAVE_NEXT], [1], [Define if you are on NeXT])\n\tAC_DEFINE([USE_PIPES])\n\tAC_DEFINE([BROKEN_SAVED_UIDS], [1], [Needed for NeXT])\n\t;;\n*-*-openbsd*)\n\tuse_pie=auto\n\tAC_DEFINE([HAVE_ATTRIBUTE__SENTINEL__], [1], [OpenBSD's gcc has sentinel])\n\tAC_DEFINE([HAVE_ATTRIBUTE__BOUNDED__], [1], [OpenBSD's gcc has bounded])\n\tAC_DEFINE([SSH_TUN_OPENBSD], [1], [Open tunnel devices the OpenBSD way])\n\tAC_DEFINE([SYSLOG_R_SAFE_IN_SIGHAND], [1],\n\t    [syslog_r function is safe to use in in a signal handler])\n\tTEST_MALLOC_OPTIONS=\"AFGJPRX\"\n\t;;\n*-*-solaris*)\n\tif test \"x$withval\" != \"xno\" ; then\n\t\trpath_opt=\"-R\"\n\tfi\n\tAC_DEFINE([PAM_SUN_CODEBASE])\n\tAC_DEFINE([LOGIN_NEEDS_UTMPX])\n\tAC_DEFINE([PAM_TTY_KLUDGE])\n\tAC_DEFINE([SSHPAM_CHAUTHTOK_NEEDS_RUID], [1],\n\t\t[Define if pam_chauthtok wants real uid set\n\t\tto the unpriv'ed user])\n\tAC_DEFINE([LOCKED_PASSWD_STRING], [\"*LK*\"])\n\t# Pushing STREAMS modules will cause sshd to acquire a controlling tty.\n\tAC_DEFINE([SSHD_ACQUIRES_CTTY], [1],\n\t\t[Define if sshd somehow reacquires a controlling TTY\n\t\tafter setsid()])\n\tAC_DEFINE([PASSWD_NEEDS_USERNAME], [1], [must supply username to passwd\n\t\tin case the name is longer than 8 chars])\n\tAC_DEFINE([BROKEN_TCGETATTR_ICANON], [1], [tcgetattr with ICANON may hang])\n\texternal_path_file=/etc/default/login\n\t# hardwire lastlog location (can't detect it on some versions)\n\tconf_lastlog_location=\"/var/adm/lastlog\"\n\tAC_MSG_CHECKING([for obsolete utmp and wtmp in solaris2.x])\n\tsol2ver=`echo \"$host\"| sed -e 's/.*[[0-9]]\\.//'`\n\tif test \"$sol2ver\" -ge 8; then\n\t\tAC_MSG_RESULT([yes])\n\t\tAC_DEFINE([DISABLE_UTMP])\n\t\tAC_DEFINE([DISABLE_WTMP], [1],\n\t\t\t[Define if you don't want to use wtmp])\n\telse\n\t\tAC_MSG_RESULT([no])\n\tfi\n\tAC_CHECK_FUNCS([setpflags])\n\tAC_CHECK_FUNCS([setppriv])\n\tAC_CHECK_FUNCS([priv_basicset])\n\tAC_CHECK_HEADERS([priv.h])\n\tAC_ARG_WITH([solaris-contracts],\n\t\t[  --with-solaris-contracts Enable Solaris process contracts (experimental)],\n\t\t[\n\t\tAC_CHECK_LIB([contract], [ct_tmpl_activate],\n\t\t\t[ AC_DEFINE([USE_SOLARIS_PROCESS_CONTRACTS], [1],\n\t\t\t\t[Define if you have Solaris process contracts])\n\t\t\t  LIBS=\"$LIBS -lcontract\"\n\t\t\t  SPC_MSG=\"yes\" ], )\n\t\t],\n\t)\n\tAC_ARG_WITH([solaris-projects],\n\t\t[  --with-solaris-projects Enable Solaris projects (experimental)],\n\t\t[\n\t\tAC_CHECK_LIB([project], [setproject],\n\t\t\t[ AC_DEFINE([USE_SOLARIS_PROJECTS], [1],\n\t\t\t\t[Define if you have Solaris projects])\n\t\t\tLIBS=\"$LIBS -lproject\"\n\t\t\tSP_MSG=\"yes\" ], )\n\t\t],\n\t)\n\tAC_ARG_WITH([solaris-privs],\n\t\t[  --with-solaris-privs    Enable Solaris/Illumos privileges (experimental)],\n\t\t[\n\t\tAC_MSG_CHECKING([for Solaris/Illumos privilege support])\n\t\tif test \"x$ac_cv_func_setppriv\" = \"xyes\" -a \\\n\t\t\t\"x$ac_cv_header_priv_h\" = \"xyes\" ; then\n\t\t\tSOLARIS_PRIVS=yes\n\t\t\tAC_MSG_RESULT([found])\n\t\t\tAC_DEFINE([NO_UID_RESTORATION_TEST], [1],\n\t\t\t\t[Define to disable UID restoration test])\n\t\t\tAC_DEFINE([USE_SOLARIS_PRIVS], [1],\n\t\t\t\t[Define if you have Solaris privileges])\n\t\t\tSPP_MSG=\"yes\"\n\t\telse\n\t\t\tAC_MSG_RESULT([not found])\n\t\t\tAC_MSG_ERROR([*** must have support for Solaris privileges to use --with-solaris-privs])\n\t\tfi\n\t\t],\n\t)\n\tTEST_SHELL=$SHELL\t# let configure find us a capable shell\n\t;;\n*-*-sunos4*)\n\tCPPFLAGS=\"$CPPFLAGS -DSUNOS4\"\n\tAC_CHECK_FUNCS([getpwanam])\n\tAC_DEFINE([PAM_SUN_CODEBASE])\n\tconf_utmp_location=/etc/utmp\n\tconf_wtmp_location=/var/adm/wtmp\n\tconf_lastlog_location=/var/adm/lastlog\n\tAC_DEFINE([USE_PIPES])\n\tAC_DEFINE([DISABLE_UTMPX], [1], [no utmpx])\n\t;;\n*-ncr-sysv*)\n\tLIBS=\"$LIBS -lc89\"\n\tAC_DEFINE([USE_PIPES])\n\tAC_DEFINE([SSHD_ACQUIRES_CTTY])\n\tAC_DEFINE([SETEUID_BREAKS_SETUID])\n\tAC_DEFINE([BROKEN_SETREUID])\n\tAC_DEFINE([BROKEN_SETREGID])\n\t;;\n*-sni-sysv*)\n\t# /usr/ucblib MUST NOT be searched on ReliantUNIX\n\tAC_CHECK_LIB([dl], [dlsym], ,)\n\t# -lresolv needs to be at the end of LIBS or DNS lookups break\n\tAC_CHECK_LIB([resolv], [res_query], [ LIBS=\"$LIBS -lresolv\" ])\n\tIPADDR_IN_DISPLAY=yes\n\tAC_DEFINE([USE_PIPES])\n\tAC_DEFINE([IP_TOS_IS_BROKEN])\n\tAC_DEFINE([SETEUID_BREAKS_SETUID])\n\tAC_DEFINE([BROKEN_SETREUID])\n\tAC_DEFINE([BROKEN_SETREGID])\n\tAC_DEFINE([SSHD_ACQUIRES_CTTY])\n\texternal_path_file=/etc/default/login\n\t# /usr/ucblib/libucb.a no longer needed on ReliantUNIX\n\t# Attention: always take care to bind libsocket and libnsl before libc,\n\t# otherwise you will find lots of \"SIOCGPGRP errno 22\" on syslog\n\t;;\n# UnixWare 1.x, UnixWare 2.x, and others based on code from Univel.\n*-*-sysv4.2*)\n\tAC_DEFINE([USE_PIPES])\n\tAC_DEFINE([SETEUID_BREAKS_SETUID])\n\tAC_DEFINE([BROKEN_SETREUID])\n\tAC_DEFINE([BROKEN_SETREGID])\n\tAC_DEFINE([PASSWD_NEEDS_USERNAME], [1], [must supply username to passwd])\n\tAC_DEFINE([LOCKED_PASSWD_STRING], [\"*LK*\"])\n\tTEST_SHELL=$SHELL\t# let configure find us a capable shell\n\t;;\n# UnixWare 7.x, OpenUNIX 8\n*-*-sysv5*)\n\tCPPFLAGS=\"$CPPFLAGS -Dvsnprintf=_xvsnprintf -Dsnprintf=_xsnprintf\"\n\tAC_DEFINE([UNIXWARE_LONG_PASSWORDS], [1], [Support passwords > 8 chars])\n\tAC_DEFINE([USE_PIPES])\n\tAC_DEFINE([SETEUID_BREAKS_SETUID])\n\tAC_DEFINE([BROKEN_GETADDRINFO])\n\tAC_DEFINE([BROKEN_SETREUID])\n\tAC_DEFINE([BROKEN_SETREGID])\n\tAC_DEFINE([PASSWD_NEEDS_USERNAME])\n\tAC_DEFINE([BROKEN_TCGETATTR_ICANON])\n\tTEST_SHELL=$SHELL\t# let configure find us a capable shell\n\tcheck_for_libcrypt_later=1\n\tcase \"$host\" in\n\t*-*-sysv5SCO_SV*)\t# SCO OpenServer 6.x\n\t\tmaildir=/var/spool/mail\n\t\tAC_DEFINE([BROKEN_UPDWTMPX])\n\t\tAC_CHECK_LIB([prot], [getluid], [ LIBS=\"$LIBS -lprot\"\n\t\t\tAC_CHECK_FUNCS([getluid setluid], , , [-lprot])\n\t\t\t], , )\n\t\t;;\n\t*)\tAC_DEFINE([LOCKED_PASSWD_STRING], [\"*LK*\"])\n\t\t;;\n\tesac\n\t;;\n*-*-sysv*)\n\t;;\n# SCO UNIX and OEM versions of SCO UNIX\n*-*-sco3.2v4*)\n\tAC_MSG_ERROR(\"This Platform is no longer supported.\")\n\t;;\n# SCO OpenServer 5.x\n*-*-sco3.2v5*)\n\tif test -z \"$GCC\"; then\n\t\tCFLAGS=\"$CFLAGS -belf\"\n\tfi\n\tLIBS=\"$LIBS -lprot -lx -ltinfo -lm\"\n\tno_dev_ptmx=1\n\tAC_DEFINE([USE_PIPES])\n\tAC_DEFINE([HAVE_SECUREWARE])\n\tAC_DEFINE([DISABLE_SHADOW])\n\tAC_DEFINE([DISABLE_FD_PASSING])\n\tAC_DEFINE([SETEUID_BREAKS_SETUID])\n\tAC_DEFINE([BROKEN_GETADDRINFO])\n\tAC_DEFINE([BROKEN_SETREUID])\n\tAC_DEFINE([BROKEN_SETREGID])\n\tAC_DEFINE([WITH_ABBREV_NO_TTY])\n\tAC_DEFINE([BROKEN_UPDWTMPX])\n\tAC_DEFINE([PASSWD_NEEDS_USERNAME])\n\tAC_CHECK_FUNCS([getluid setluid])\n\tMANTYPE=man\n\tTEST_SHELL=$SHELL\t# let configure find us a capable shell\n\tSKIP_DISABLE_LASTLOG_DEFINE=yes\n\t;;\n*-dec-osf*)\n\tAC_MSG_CHECKING([for Digital Unix SIA])\n\tno_osfsia=\"\"\n\tAC_ARG_WITH([osfsia],\n\t\t[  --with-osfsia           Enable Digital Unix SIA],\n\t\t[\n\t\t\tif test \"x$withval\" = \"xno\" ; then\n\t\t\t\tAC_MSG_RESULT([disabled])\n\t\t\t\tno_osfsia=1\n\t\t\tfi\n\t\t],\n\t)\n\tif test -z \"$no_osfsia\" ; then\n\t\tif test -f /etc/sia/matrix.conf; then\n\t\t\tAC_MSG_RESULT([yes])\n\t\t\tAC_DEFINE([HAVE_OSF_SIA], [1],\n\t\t\t\t[Define if you have Digital Unix Security\n\t\t\t\tIntegration Architecture])\n\t\t\tAC_DEFINE([DISABLE_LOGIN], [1],\n\t\t\t\t[Define if you don't want to use your\n\t\t\t\tsystem's login() call])\n\t\t\tAC_DEFINE([DISABLE_FD_PASSING])\n\t\t\tLIBS=\"$LIBS -lsecurity -ldb -lm -laud\"\n\t\t\tSIA_MSG=\"yes\"\n\t\telse\n\t\t\tAC_MSG_RESULT([no])\n\t\t\tAC_DEFINE([LOCKED_PASSWD_SUBSTR], [\"Nologin\"],\n\t\t\t  [String used in /etc/passwd to denote locked account])\n\t\tfi\n\tfi\n\tAC_DEFINE([BROKEN_GETADDRINFO])\n\tAC_DEFINE([SETEUID_BREAKS_SETUID])\n\tAC_DEFINE([BROKEN_SETREUID])\n\tAC_DEFINE([BROKEN_SETREGID])\n\tAC_DEFINE([BROKEN_READV_COMPARISON], [1], [Can't do comparisons on readv])\n\t;;\n\n*-*-nto-qnx*)\n\tAC_DEFINE([USE_PIPES])\n\tAC_DEFINE([NO_X11_UNIX_SOCKETS])\n\tAC_DEFINE([DISABLE_LASTLOG])\n\tAC_DEFINE([SSHD_ACQUIRES_CTTY])\n\tAC_DEFINE([BROKEN_SHADOW_EXPIRE], [1], [QNX shadow support is broken])\n\tenable_etc_default_login=no\t# has incompatible /etc/default/login\n\tcase \"$host\" in\n\t*-*-nto-qnx6*)\n\t\tAC_DEFINE([DISABLE_FD_PASSING])\n\t\t;;\n\tesac\n\t;;\n\n*-*-ultrix*)\n\tAC_DEFINE([BROKEN_GETGROUPS], [1], [getgroups(0,NULL) will return -1])\n\tAC_DEFINE([NEED_SETPGRP])\n\tAC_DEFINE([HAVE_SYS_SYSLOG_H], [1], [Force use of sys/syslog.h on Ultrix])\n\t;;\n\n*-*-lynxos)\n\tCFLAGS=\"$CFLAGS -D__NO_INCLUDE_WARN__\"\n\tAC_DEFINE([BROKEN_SETVBUF], [1],\n\t    [LynxOS has broken setvbuf() implementation])\n\t;;\nesac\n\nAC_MSG_CHECKING([compiler and flags for sanity])\nAC_RUN_IFELSE([AC_LANG_PROGRAM([[ #include <stdio.h> ]], [[ exit(0); ]])],\n\t[\tAC_MSG_RESULT([yes]) ],\n\t[\n\t\tAC_MSG_RESULT([no])\n\t\tAC_MSG_ERROR([*** compiler cannot create working executables, check config.log ***])\n\t],\n\t[\tAC_MSG_WARN([cross compiling: not checking compiler sanity]) ]\n)\n\ndnl Checks for header files.\n# Checks for libraries.\nAC_CHECK_FUNC([setsockopt], , [AC_CHECK_LIB([socket], [setsockopt])])\n\ndnl IRIX and Solaris 2.5.1 have dirname() in libgen\nAC_CHECK_FUNCS([dirname], [AC_CHECK_HEADERS([libgen.h])] , [\n\tAC_CHECK_LIB([gen], [dirname], [\n\t\tAC_CACHE_CHECK([for broken dirname],\n\t\t\tac_cv_have_broken_dirname, [\n\t\t\tsave_LIBS=\"$LIBS\"\n\t\t\tLIBS=\"$LIBS -lgen\"\n\t\t\tAC_RUN_IFELSE(\n\t\t\t\t[AC_LANG_SOURCE([[\n#include <libgen.h>\n#include <string.h>\n\nint main(int argc, char **argv) {\n    char *s, buf[32];\n\n    strncpy(buf,\"/etc\", 32);\n    s = dirname(buf);\n    if (!s || strncmp(s, \"/\", 32) != 0) {\n\texit(1);\n    } else {\n\texit(0);\n    }\n}\n\t\t\t\t]])],\n\t\t\t\t[ ac_cv_have_broken_dirname=\"no\" ],\n\t\t\t\t[ ac_cv_have_broken_dirname=\"yes\" ],\n\t\t\t\t[ ac_cv_have_broken_dirname=\"no\" ],\n\t\t\t)\n\t\t\tLIBS=\"$save_LIBS\"\n\t\t])\n\t\tif test \"x$ac_cv_have_broken_dirname\" = \"xno\" ; then\n\t\t\tLIBS=\"$LIBS -lgen\"\n\t\t\tAC_DEFINE([HAVE_DIRNAME])\n\t\t\tAC_CHECK_HEADERS([libgen.h])\n\t\tfi\n\t])\n])\n\nAC_CHECK_FUNC([getspnam], ,\n\t[AC_CHECK_LIB([gen], [getspnam], [LIBS=\"$LIBS -lgen\"])])\nAC_SEARCH_LIBS([basename], [gen], [AC_DEFINE([HAVE_BASENAME], [1],\n\t[Define if you have the basename function.])])\n\ndnl zlib is required\nAC_ARG_WITH([zlib],\n\t[  --with-zlib=PATH        Use zlib in PATH],\n\t[ if test \"x$withval\" = \"xno\" ; then\n\t\tAC_MSG_ERROR([*** zlib is required ***])\n\t  elif test \"x$withval\" != \"xyes\"; then\n\t\tif test -d \"$withval/lib\"; then\n\t\t\tif test -n \"${rpath_opt}\"; then\n\t\t\t\tLDFLAGS=\"-L${withval}/lib ${rpath_opt}${withval}/lib ${LDFLAGS}\"\n\t\t\telse\n\t\t\t\tLDFLAGS=\"-L${withval}/lib ${LDFLAGS}\"\n\t\t\tfi\n\t\telse\n\t\t\tif test -n \"${rpath_opt}\"; then\n\t\t\t\tLDFLAGS=\"-L${withval} ${rpath_opt}${withval} ${LDFLAGS}\"\n\t\t\telse\n\t\t\t\tLDFLAGS=\"-L${withval} ${LDFLAGS}\"\n\t\t\tfi\n\t\tfi\n\t\tif test -d \"$withval/include\"; then\n\t\t\tCPPFLAGS=\"-I${withval}/include ${CPPFLAGS}\"\n\t\telse\n\t\t\tCPPFLAGS=\"-I${withval} ${CPPFLAGS}\"\n\t\tfi\n\tfi ]\n)\n\nAC_CHECK_HEADER([zlib.h], ,[AC_MSG_ERROR([*** zlib.h missing - please install first or check config.log ***])])\nAC_CHECK_LIB([z], [deflate], ,\n\t[\n\t\tsaved_CPPFLAGS=\"$CPPFLAGS\"\n\t\tsaved_LDFLAGS=\"$LDFLAGS\"\n\t\tsave_LIBS=\"$LIBS\"\n\t\tdnl Check default zlib install dir\n\t\tif test -n \"${rpath_opt}\"; then\n\t\t\tLDFLAGS=\"-L/usr/local/lib ${rpath_opt}/usr/local/lib ${saved_LDFLAGS}\"\n\t\telse\n\t\t\tLDFLAGS=\"-L/usr/local/lib ${saved_LDFLAGS}\"\n\t\tfi\n\t\tCPPFLAGS=\"-I/usr/local/include ${saved_CPPFLAGS}\"\n\t\tLIBS=\"$LIBS -lz\"\n\t\tAC_TRY_LINK_FUNC([deflate], [AC_DEFINE([HAVE_LIBZ])],\n\t\t\t[\n\t\t\t\tAC_MSG_ERROR([*** zlib missing - please install first or check config.log ***])\n\t\t\t]\n\t\t)\n\t]\n)\n\nAC_ARG_WITH([zlib-version-check],\n\t[  --without-zlib-version-check Disable zlib version check],\n\t[  if test \"x$withval\" = \"xno\" ; then\n\t\tzlib_check_nonfatal=1\n\t   fi\n\t]\n)\n\nAC_MSG_CHECKING([for possibly buggy zlib])\nAC_RUN_IFELSE([AC_LANG_PROGRAM([[\n#include <stdio.h>\n#include <stdlib.h>\n#include <zlib.h>\n\t]],\n\t[[\n\tint a=0, b=0, c=0, d=0, n, v;\n\tn = sscanf(ZLIB_VERSION, \"%d.%d.%d.%d\", &a, &b, &c, &d);\n\tif (n != 3 && n != 4)\n\t\texit(1);\n\tv = a*1000000 + b*10000 + c*100 + d;\n\tfprintf(stderr, \"found zlib version %s (%d)\\n\", ZLIB_VERSION, v);\n\n\t/* 1.1.4 is OK */\n\tif (a == 1 && b == 1 && c >= 4)\n\t\texit(0);\n\n\t/* 1.2.3 and up are OK */\n\tif (v >= 1020300)\n\t\texit(0);\n\n\texit(2);\n\t]])],\n\tAC_MSG_RESULT([no]),\n\t[ AC_MSG_RESULT([yes])\n\t  if test -z \"$zlib_check_nonfatal\" ; then\n\t\tAC_MSG_ERROR([*** zlib too old - check config.log ***\nYour reported zlib version has known security problems.  It's possible your\nvendor has fixed these problems without changing the version number.  If you\nare sure this is the case, you can disable the check by running\n\"./configure --without-zlib-version-check\".\nIf you are in doubt, upgrade zlib to version 1.2.3 or greater.\nSee http://www.gzip.org/zlib/ for details.])\n\t  else\n\t\tAC_MSG_WARN([zlib version may have security problems])\n\t  fi\n\t],\n\t[\tAC_MSG_WARN([cross compiling: not checking zlib version]) ]\n)\n\ndnl UnixWare 2.x\nAC_CHECK_FUNC([strcasecmp],\n\t[], [ AC_CHECK_LIB([resolv], [strcasecmp], [LIBS=\"$LIBS -lresolv\"]) ]\n)\nAC_CHECK_FUNCS([utimes],\n\t[], [ AC_CHECK_LIB([c89], [utimes], [AC_DEFINE([HAVE_UTIMES])\n\t\t\t\t\tLIBS=\"$LIBS -lc89\"]) ]\n)\n\ndnl    Checks for libutil functions\nAC_CHECK_HEADERS([bsd/libutil.h libutil.h])\nAC_SEARCH_LIBS([fmt_scaled], [util bsd])\nAC_SEARCH_LIBS([scan_scaled], [util bsd])\nAC_SEARCH_LIBS([login], [util bsd])\nAC_SEARCH_LIBS([logout], [util bsd])\nAC_SEARCH_LIBS([logwtmp], [util bsd])\nAC_SEARCH_LIBS([openpty], [util bsd])\nAC_SEARCH_LIBS([updwtmp], [util bsd])\nAC_CHECK_FUNCS([fmt_scaled scan_scaled login logout openpty updwtmp logwtmp])\n\n# On some platforms, inet_ntop and gethostbyname may be found in libresolv\n# or libnsl.\nAC_SEARCH_LIBS([inet_ntop], [resolv nsl])\nAC_SEARCH_LIBS([gethostbyname], [resolv nsl])\n\n# \"Particular Function Checks\"\n# see https://www.gnu.org/software/autoconf/manual/autoconf-2.69/html_node/Particular-Functions.html\nAC_FUNC_STRFTIME\nAC_FUNC_MALLOC\nAC_FUNC_REALLOC\n# autoconf doesn't have AC_FUNC_CALLOC so fake it if malloc returns NULL;\nAC_MSG_CHECKING([if calloc(0, N) returns non-null])\nAC_RUN_IFELSE(\n\t[AC_LANG_PROGRAM(\n\t\t[[ #include <stdlib.h> ]],\n\t\t[[ void *p = calloc(0, 1); exit(p == NULL); ]]\n\t)],\n\t[ func_calloc_0_nonnull=yes ],\n\t[ func_calloc_0_nonnull=no ],\n\t[ AC_MSG_WARN([cross compiling: assuming same as malloc])\n\t  func_calloc_0_nonnull=\"$ac_cv_func_malloc_0_nonnull\"]\n)\nAC_MSG_RESULT([$func_calloc_0_nonnull])\n\nif test \"x$func_calloc_0_nonnull\" = \"xyes\"; then\n\tAC_DEFINE(HAVE_CALLOC, 1, [calloc(0, x) returns non-null])\nelse\n\tAC_DEFINE(HAVE_CALLOC, 0, [calloc(0, x) returns NULL])\n\tAC_DEFINE(calloc, rpl_calloc,\n\t    [Define to rpl_calloc if the replacement function should be used.])\nfi\n\n# Check for ALTDIRFUNC glob() extension\nAC_MSG_CHECKING([for GLOB_ALTDIRFUNC support])\nAC_EGREP_CPP([FOUNDIT],\n\t[\n\t\t#include <glob.h>\n\t\t#ifdef GLOB_ALTDIRFUNC\n\t\tFOUNDIT\n\t\t#endif\n\t],\n\t[\n\t\tAC_DEFINE([GLOB_HAS_ALTDIRFUNC], [1],\n\t\t\t[Define if your system glob() function has\n\t\t\tthe GLOB_ALTDIRFUNC extension])\n\t\tAC_MSG_RESULT([yes])\n\t],\n\t[\n\t\tAC_MSG_RESULT([no])\n\t]\n)\n\n# Check for g.gl_matchc glob() extension\nAC_MSG_CHECKING([for gl_matchc field in glob_t])\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[ #include <glob.h> ]],\n\t[[ glob_t g; g.gl_matchc = 1; ]])],\n\t[\n\t\tAC_DEFINE([GLOB_HAS_GL_MATCHC], [1],\n\t\t\t[Define if your system glob() function has\n\t\t\tgl_matchc options in glob_t])\n\t\tAC_MSG_RESULT([yes])\n\t], [\n\t\tAC_MSG_RESULT([no])\n])\n\n# Check for g.gl_statv glob() extension\nAC_MSG_CHECKING([for gl_statv and GLOB_KEEPSTAT extensions for glob])\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[ #include <glob.h> ]], [[\n#ifndef GLOB_KEEPSTAT\n#error \"glob does not support GLOB_KEEPSTAT extension\"\n#endif\nglob_t g;\ng.gl_statv = NULL;\n]])],\n\t[\n\t\tAC_DEFINE([GLOB_HAS_GL_STATV], [1],\n\t\t\t[Define if your system glob() function has\n\t\t\tgl_statv options in glob_t])\n\t\tAC_MSG_RESULT([yes])\n\t], [\n\t\tAC_MSG_RESULT([no])\n\n])\n\nAC_CHECK_DECLS([GLOB_NOMATCH], , , [#include <glob.h>])\n\nAC_CHECK_DECL([VIS_ALL], ,\n    AC_DEFINE(BROKEN_STRNVIS, 1, [missing VIS_ALL]), [#include <vis.h>])\n\nAC_MSG_CHECKING([whether struct dirent allocates space for d_name])\nAC_RUN_IFELSE(\n\t[AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <dirent.h>]],\n\t[[\n\tstruct dirent d;\n\texit(sizeof(d.d_name)<=sizeof(char));\n\t]])],\n\t[AC_MSG_RESULT([yes])],\n\t[\n\t\tAC_MSG_RESULT([no])\n\t\tAC_DEFINE([BROKEN_ONE_BYTE_DIRENT_D_NAME], [1],\n\t\t\t[Define if your struct dirent expects you to\n\t\t\tallocate extra space for d_name])\n\t],\n\t[\n\t\tAC_MSG_WARN([cross compiling: assuming BROKEN_ONE_BYTE_DIRENT_D_NAME])\n\t\tAC_DEFINE([BROKEN_ONE_BYTE_DIRENT_D_NAME])\n\t]\n)\n\nAC_MSG_CHECKING([for /proc/pid/fd directory])\nif test -d \"/proc/$$/fd\" ; then\n\tAC_DEFINE([HAVE_PROC_PID], [1], [Define if you have /proc/$pid/fd])\n\tAC_MSG_RESULT([yes])\nelse\n\tAC_MSG_RESULT([no])\nfi\n\n# Check whether user wants to use ldns\nLDNS_MSG=\"no\"\nAC_ARG_WITH(ldns,\n\t[  --with-ldns[[=PATH]]      Use ldns for DNSSEC support (optionally in PATH)],\n\t[\n\tldns=\"\"\n\tif test \"x$withval\" = \"xyes\" ; then\n\t\tAC_PATH_TOOL([LDNSCONFIG], [ldns-config], [no])\n\t\tif test \"x$LDNSCONFIG\" = \"xno\"; then\n\t\t\tCPPFLAGS=\"$CPPFLAGS -I${withval}/include\"\n\t\t\tLDFLAGS=\"$LDFLAGS -L${withval}/lib\"\n\t\t\tLIBS=\"-lldns $LIBS\"\n\t\t\tldns=yes\n\t\telse\n\t\t\tLIBS=\"$LIBS `$LDNSCONFIG --libs`\"\n\t\t\tCPPFLAGS=\"$CPPFLAGS `$LDNSCONFIG --cflags`\"\n\t\t\tldns=yes\n\t\tfi\n\telif test \"x$withval\" != \"xno\" ; then\n\t\t\tCPPFLAGS=\"$CPPFLAGS -I${withval}/include\"\n\t\t\tLDFLAGS=\"$LDFLAGS -L${withval}/lib\"\n\t\t\tLIBS=\"-lldns $LIBS\"\n\t\t\tldns=yes\n\tfi\n\n\t# Verify that it works.\n\tif test \"x$ldns\" = \"xyes\" ; then\n\t\tAC_DEFINE(HAVE_LDNS, 1, [Define if you want ldns support])\n\t\tLDNS_MSG=\"yes\"\n\t\tAC_MSG_CHECKING([for ldns support])\n\t\tAC_LINK_IFELSE(\n\t\t\t[AC_LANG_SOURCE([[\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n#include <ldns/ldns.h>\nint main() { ldns_status status = ldns_verify_trusted(NULL, NULL, NULL, NULL); status=LDNS_STATUS_OK; exit(0); }\n\t\t\t]])\n\t\t],\n\t\t\t[AC_MSG_RESULT(yes)],\n\t\t\t\t[\n\t\t\t\t\tAC_MSG_RESULT(no)\n\t\t\t\t\tAC_MSG_ERROR([** Incomplete or missing ldns libraries.])\n\t\t\t\t])\n\tfi\n])\n\n# Check whether user wants libedit support\nLIBEDIT_MSG=\"no\"\nAC_ARG_WITH([libedit],\n\t[  --with-libedit[[=PATH]]   Enable libedit support for sftp],\n\t[ if test \"x$withval\" != \"xno\" ; then\n\t\tif test \"x$withval\" = \"xyes\" ; then\n\t\t\tAC_PATH_TOOL([PKGCONFIG], [pkg-config], [no])\n\t\t\tif test \"x$PKGCONFIG\" != \"xno\"; then\n\t\t\t\tAC_MSG_CHECKING([if $PKGCONFIG knows about libedit])\n\t\t\t\tif \"$PKGCONFIG\" libedit; then\n\t\t\t\t\tAC_MSG_RESULT([yes])\n\t\t\t\t\tuse_pkgconfig_for_libedit=yes\n\t\t\t\telse\n\t\t\t\t\tAC_MSG_RESULT([no])\n\t\t\t\tfi\n\t\t\tfi\n\t\telse\n\t\t\tCPPFLAGS=\"$CPPFLAGS -I${withval}/include\"\n\t\t\tif test -n \"${rpath_opt}\"; then\n\t\t\t\tLDFLAGS=\"-L${withval}/lib ${rpath_opt}${withval}/lib ${LDFLAGS}\"\n\t\t\telse\n\t\t\t\tLDFLAGS=\"-L${withval}/lib ${LDFLAGS}\"\n\t\t\tfi\n\t\tfi\n\t\tif test \"x$use_pkgconfig_for_libedit\" = \"xyes\"; then\n\t\t\tLIBEDIT=`$PKGCONFIG --libs libedit`\n\t\t\tCPPFLAGS=\"$CPPFLAGS `$PKGCONFIG --cflags libedit`\"\n\t\telse\n\t\t\tLIBEDIT=\"-ledit -lcurses\"\n\t\tfi\n\t\tOTHERLIBS=`echo $LIBEDIT | sed 's/-ledit//'`\n\t\tAC_CHECK_LIB([edit], [el_init],\n\t\t\t[ AC_DEFINE([USE_LIBEDIT], [1], [Use libedit for sftp])\n\t\t\t  LIBEDIT_MSG=\"yes\"\n\t\t\t  AC_SUBST([LIBEDIT])\n\t\t\t],\n\t\t\t[ AC_MSG_ERROR([libedit not found]) ],\n\t\t\t[ $OTHERLIBS ]\n\t\t)\n\t\tAC_MSG_CHECKING([if libedit version is compatible])\n\t\tAC_COMPILE_IFELSE(\n\t\t    [AC_LANG_PROGRAM([[ #include <histedit.h> ]],\n\t\t    [[\n\tint i = H_SETSIZE;\n\tel_init(\"\", NULL, NULL, NULL);\n\texit(0);\n\t\t    ]])],\n\t\t    [ AC_MSG_RESULT([yes]) ],\n\t\t    [ AC_MSG_RESULT([no])\n\t\t      AC_MSG_ERROR([libedit version is not compatible]) ]\n\t\t)\n\tfi ]\n)\n\nAUDIT_MODULE=none\nAC_ARG_WITH([audit],\n\t[  --with-audit=module     Enable audit support (modules=debug,bsm,linux)],\n\t[\n\t  AC_MSG_CHECKING([for supported audit module])\n\t  case \"$withval\" in\n\t  bsm)\n\t\tAC_MSG_RESULT([bsm])\n\t\tAUDIT_MODULE=bsm\n\t\tdnl    Checks for headers, libs and functions\n\t\tAC_CHECK_HEADERS([bsm/audit.h], [],\n\t\t    [AC_MSG_ERROR([BSM enabled and bsm/audit.h not found])],\n\t\t    [\n#ifdef HAVE_TIME_H\n# include <time.h>\n#endif\n\t\t    ]\n)\n\t\tAC_CHECK_LIB([bsm], [getaudit], [],\n\t\t    [AC_MSG_ERROR([BSM enabled and required library not found])])\n\t\tAC_CHECK_FUNCS([getaudit], [],\n\t\t    [AC_MSG_ERROR([BSM enabled and required function not found])])\n\t\t# These are optional\n\t\tAC_CHECK_FUNCS([getaudit_addr aug_get_machine])\n\t\tAC_DEFINE([USE_BSM_AUDIT], [1], [Use BSM audit module])\n\t\tif test \"$sol2ver\" -ge 11; then\n\t\t\tSSHDLIBS=\"$SSHDLIBS -lscf\"\n\t\t\tAC_DEFINE([BROKEN_BSM_API], [1],\n\t\t\t\t[The system has incomplete BSM API])\n\t\tfi\n\t\t;;\n\t  linux)\n\t\tAC_MSG_RESULT([linux])\n\t\tAUDIT_MODULE=linux\n\t\tdnl    Checks for headers, libs and functions\n\t\tAC_CHECK_HEADERS([libaudit.h])\n\t\tSSHDLIBS=\"$SSHDLIBS -laudit\"\n\t\tAC_DEFINE([USE_LINUX_AUDIT], [1], [Use Linux audit module])\n\t\t;;\n\t  debug)\n\t\tAUDIT_MODULE=debug\n\t\tAC_MSG_RESULT([debug])\n\t\tAC_DEFINE([SSH_AUDIT_EVENTS], [1], [Use audit debugging module])\n\t\t;;\n\t  no)\n\t\tAC_MSG_RESULT([no])\n\t\t;;\n\t  *)\n\t\tAC_MSG_ERROR([Unknown audit module $withval])\n\t\t;;\n\tesac ]\n)\n\nAC_ARG_WITH([pie],\n    [  --with-pie              Build Position Independent Executables if possible], [\n\tif test \"x$withval\" = \"xno\"; then\n\t\tuse_pie=no\n\tfi\n\tif test \"x$withval\" = \"xyes\"; then\n\t\tuse_pie=yes\n\tfi\n    ]\n)\nif test \"x$use_pie\" = \"x\"; then\n\tuse_pie=no\nfi\nif test \"x$use_toolchain_hardening\" != \"x1\" && test \"x$use_pie\" = \"xauto\"; then\n\t# Turn off automatic PIE when toolchain hardening is off.\n\tuse_pie=no\nfi\nif test \"x$use_pie\" = \"xauto\"; then\n\t# Automatic PIE requires gcc >= 4.x\n\tAC_MSG_CHECKING([for gcc >= 4.x])\n\tAC_COMPILE_IFELSE([AC_LANG_SOURCE([[\n#if !defined(__GNUC__) || __GNUC__ < 4\n#error gcc is too old\n#endif\n]])],\n\t[ AC_MSG_RESULT([yes]) ],\n\t[ AC_MSG_RESULT([no])\n\t  use_pie=no ]\n)\nfi\nif test \"x$use_pie\" != \"xno\"; then\n\tSAVED_CFLAGS=\"$CFLAGS\"\n\tSAVED_LDFLAGS=\"$LDFLAGS\"\n\tOSSH_CHECK_CFLAG_COMPILE([-fPIE])\n\tOSSH_CHECK_LDFLAG_LINK([-pie])\n\t# We use both -fPIE and -pie or neither.\n\tAC_MSG_CHECKING([whether both -fPIE and -pie are supported])\n\tif echo \"x $CFLAGS\"  | grep ' -fPIE' >/dev/null 2>&1 && \\\n\t   echo \"x $LDFLAGS\" | grep ' -pie'  >/dev/null 2>&1 ; then\n\t\tAC_MSG_RESULT([yes])\n\telse\n\t\tAC_MSG_RESULT([no])\n\t\tCFLAGS=\"$SAVED_CFLAGS\"\n\t\tLDFLAGS=\"$SAVED_LDFLAGS\"\n\tfi\nfi\n\ndnl    Checks for library functions. Please keep in alphabetical order\nAC_CHECK_FUNCS([ \\\n\tBlowfish_initstate \\\n\tBlowfish_expandstate \\\n\tBlowfish_expand0state \\\n\tBlowfish_stream2word \\\n\tSHA256Update \\\n\tSHA384Update \\\n\tSHA512Update \\\n\tasprintf \\\n\tb64_ntop \\\n\t__b64_ntop \\\n\tb64_pton \\\n\t__b64_pton \\\n\tbcopy \\\n\tbcrypt_pbkdf \\\n\tbindresvport_sa \\\n\tblf_enc \\\n\tbzero \\\n\tcap_rights_limit \\\n\tclock \\\n\tclosefrom \\\n\tdirfd \\\n\tendgrent \\\n\terr \\\n\terrx \\\n\texplicit_bzero \\\n\tfchmod \\\n\tfchmodat \\\n\tfchown \\\n\tfchownat \\\n\tflock \\\n\tfreeaddrinfo \\\n\tfreezero \\\n\tfstatfs \\\n\tfstatvfs \\\n\tfutimes \\\n\tgetaddrinfo \\\n\tgetcwd \\\n\tgetgrouplist \\\n\tgetline \\\n\tgetnameinfo \\\n\tgetopt \\\n\tgetpagesize \\\n\tgetpeereid \\\n\tgetpeerucred \\\n\tgetpgid \\\n\t_getpty \\\n\tgetrlimit \\\n\tgetrandom \\\n\tgetsid \\\n\tgetttyent \\\n\tglob \\\n\tgroup_from_gid \\\n\tinet_aton \\\n\tinet_ntoa \\\n\tinet_ntop \\\n\tinnetgr \\\n\tllabs \\\n\tlogin_getcapbool \\\n\tmd5_crypt \\\n\tmemmem \\\n\tmemmove \\\n\tmemset_s \\\n\tmkdtemp \\\n\tngetaddrinfo \\\n\tnsleep \\\n\togetaddrinfo \\\n\topenlog_r \\\n\tpledge \\\n\tpoll \\\n\tprctl \\\n\tpstat \\\n\traise \\\n\treadpassphrase \\\n\treallocarray \\\n\trecvmsg \\\n\trecallocarray \\\n\trresvport_af \\\n\tsendmsg \\\n\tsetdtablesize \\\n\tsetegid \\\n\tsetenv \\\n\tseteuid \\\n\tsetgroupent \\\n\tsetgroups \\\n\tsetlinebuf \\\n\tsetlogin \\\n\tsetpassent\\\n\tsetpcred \\\n\tsetproctitle \\\n\tsetregid \\\n\tsetreuid \\\n\tsetrlimit \\\n\tsetsid \\\n\tsetvbuf \\\n\tsigaction \\\n\tsigvec \\\n\tsnprintf \\\n\tsocketpair \\\n\tstatfs \\\n\tstatvfs \\\n\tstrcasestr \\\n\tstrdup \\\n\tstrerror \\\n\tstrlcat \\\n\tstrlcpy \\\n\tstrmode \\\n\tstrndup \\\n\tstrnlen \\\n\tstrnvis \\\n\tstrptime \\\n\tstrsignal \\\n\tstrtonum \\\n\tstrtoll \\\n\tstrtoul \\\n\tstrtoull \\\n\tswap32 \\\n\tsysconf \\\n\ttcgetpgrp \\\n\ttimingsafe_bcmp \\\n\ttruncate \\\n\tunsetenv \\\n\tupdwtmpx \\\n\tutimensat \\\n\tuser_from_uid \\\n\tusleep \\\n\tvasprintf \\\n\tvsnprintf \\\n\twaitpid \\\n\twarn \\\n])\n\nAC_CHECK_DECLS([bzero])\n\ndnl Wide character support.\nAC_CHECK_FUNCS([mblen mbtowc nl_langinfo wcwidth])\n\nTEST_SSH_UTF8=${TEST_SSH_UTF8:=yes}\nAC_MSG_CHECKING([for utf8 locale support])\nAC_RUN_IFELSE(\n\t[AC_LANG_PROGRAM([[\n#include <locale.h>\n#include <stdlib.h>\n\t]], [[\n\tchar *loc = setlocale(LC_CTYPE, \"en_US.UTF-8\");\n\tif (loc != NULL)\n\t\texit(0);\n\texit(1);\n\t]])],\n\tAC_MSG_RESULT(yes),\n\t[AC_MSG_RESULT(no)\n\t TEST_SSH_UTF8=no],\n\tAC_MSG_WARN([cross compiling: assuming yes])\n)\n\nAC_LINK_IFELSE(\n        [AC_LANG_PROGRAM(\n           [[ #include <ctype.h> ]],\n           [[ return (isblank('a')); ]])],\n\t[AC_DEFINE([HAVE_ISBLANK], [1], [Define if you have isblank(3C).])\n])\n\ndisable_pkcs11=\nAC_ARG_ENABLE([pkcs11],\n\t[  --disable-pkcs11        disable PKCS#11 support code [no]],\n\t[\n\t\tif test \"x$enableval\" = \"xno\" ; then\n\t\t\tdisable_pkcs11=1\n\t\tfi\n\t]\n)\n\n# PKCS11 depends on OpenSSL.\nif test \"x$openssl\" = \"xyes\" && test \"x$disable_pkcs11\" = \"x\"; then\n\t# PKCS#11 support requires dlopen() and co\n\tAC_SEARCH_LIBS([dlopen], [dl],\n\t    AC_CHECK_DECL([RTLD_NOW],\n\t\tAC_DEFINE([ENABLE_PKCS11], [], [Enable for PKCS#11 support]),\n\t\t[], [#include <dlfcn.h>]\n\t    )\n\t)\nfi\n\n# IRIX has a const char return value for gai_strerror()\nAC_CHECK_FUNCS([gai_strerror], [\n\tAC_DEFINE([HAVE_GAI_STRERROR])\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netdb.h>\n\nconst char *gai_strerror(int);\n\t\t\t]], [[\n\tchar *str;\n\tstr = gai_strerror(0);\n\t\t\t]])], [\n\t\tAC_DEFINE([HAVE_CONST_GAI_STRERROR_PROTO], [1],\n\t\t[Define if gai_strerror() returns const char *])], [])])\n\nAC_SEARCH_LIBS([nanosleep], [rt posix4], [AC_DEFINE([HAVE_NANOSLEEP], [1],\n\t[Some systems put nanosleep outside of libc])])\n\nAC_SEARCH_LIBS([clock_gettime], [rt],\n\t[AC_DEFINE([HAVE_CLOCK_GETTIME], [1], [Have clock_gettime])])\n\ndnl Make sure prototypes are defined for these before using them.\nAC_CHECK_DECL([strsep],\n\t[AC_CHECK_FUNCS([strsep])],\n\t[],\n\t[\n#ifdef HAVE_STRING_H\n# include <string.h>\n#endif\n\t])\n\ndnl tcsendbreak might be a macro\nAC_CHECK_DECL([tcsendbreak],\n\t[AC_DEFINE([HAVE_TCSENDBREAK])],\n\t[AC_CHECK_FUNCS([tcsendbreak])],\n\t[#include <termios.h>]\n)\n\nAC_CHECK_DECLS([h_errno], , ,[#include <netdb.h>])\n\nAC_CHECK_DECLS([SHUT_RD], , ,\n\t[\n#include <sys/types.h>\n#include <sys/socket.h>\n\t])\n\nAC_CHECK_DECLS([O_NONBLOCK], , ,\n\t[\n#include <sys/types.h>\n#ifdef HAVE_SYS_STAT_H\n# include <sys/stat.h>\n#endif\n#ifdef HAVE_FCNTL_H\n# include <fcntl.h>\n#endif\n\t])\n\nAC_CHECK_DECLS([readv, writev], , , [\n#include <sys/types.h>\n#include <sys/uio.h>\n#include <unistd.h>\n\t])\n\nAC_CHECK_DECLS([MAXSYMLINKS], , , [\n#include <sys/param.h>\n\t])\n\nAC_CHECK_DECLS([offsetof], , , [\n#include <stddef.h>\n\t])\n\n# extra bits for select(2)\nAC_CHECK_DECLS([howmany, NFDBITS], [], [], [[\n#include <sys/param.h>\n#include <sys/types.h>\n#ifdef HAVE_SYS_SYSMACROS_H\n#include <sys/sysmacros.h>\n#endif\n#ifdef HAVE_SYS_SELECT_H\n#include <sys/select.h>\n#endif\n#ifdef HAVE_SYS_TIME_H\n#include <sys/time.h>\n#endif\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\t]])\nAC_CHECK_TYPES([fd_mask], [], [], [[\n#include <sys/param.h>\n#include <sys/types.h>\n#ifdef HAVE_SYS_SELECT_H\n#include <sys/select.h>\n#endif\n#ifdef HAVE_SYS_TIME_H\n#include <sys/time.h>\n#endif\n#ifdef HAVE_UNISTD_H\n#include <unistd.h>\n#endif\n\t]])\n\nAC_CHECK_FUNCS([setresuid], [\n\tdnl Some platorms have setresuid that isn't implemented, test for this\n\tAC_MSG_CHECKING([if setresuid seems to work])\n\tAC_RUN_IFELSE(\n\t\t[AC_LANG_PROGRAM([[\n#include <stdlib.h>\n#include <errno.h>\n\t\t]], [[\n\terrno=0;\n\tsetresuid(0,0,0);\n\tif (errno==ENOSYS)\n\t\texit(1);\n\telse\n\t\texit(0);\n\t\t]])],\n\t\t[AC_MSG_RESULT([yes])],\n\t\t[AC_DEFINE([BROKEN_SETRESUID], [1],\n\t\t\t[Define if your setresuid() is broken])\n\t\t AC_MSG_RESULT([not implemented])],\n\t\t[AC_MSG_WARN([cross compiling: not checking setresuid])]\n\t)\n])\n\nAC_CHECK_FUNCS([setresgid], [\n\tdnl Some platorms have setresgid that isn't implemented, test for this\n\tAC_MSG_CHECKING([if setresgid seems to work])\n\tAC_RUN_IFELSE(\n\t\t[AC_LANG_PROGRAM([[\n#include <stdlib.h>\n#include <errno.h>\n\t\t]], [[\n\terrno=0;\n\tsetresgid(0,0,0);\n\tif (errno==ENOSYS)\n\t\texit(1);\n\telse\n\t\texit(0);\n\t\t]])],\n\t\t[AC_MSG_RESULT([yes])],\n\t\t[AC_DEFINE([BROKEN_SETRESGID], [1],\n\t\t\t[Define if your setresgid() is broken])\n\t\t AC_MSG_RESULT([not implemented])],\n\t\t[AC_MSG_WARN([cross compiling: not checking setresuid])]\n\t)\n])\n\nAC_MSG_CHECKING([for working fflush(NULL)])\nAC_RUN_IFELSE(\n\t[AC_LANG_PROGRAM([[#include <stdio.h>]], [[fflush(NULL); exit(0);]])],\n\tAC_MSG_RESULT([yes]),\n\t[AC_MSG_RESULT([no])\n\t AC_DEFINE([FFLUSH_NULL_BUG], [1],\n\t    [define if fflush(NULL) does not work])],\n\tAC_MSG_WARN([cross compiling: assuming working])\n)\n\ndnl    Checks for time functions\nAC_CHECK_FUNCS([gettimeofday time])\ndnl    Checks for utmp functions\nAC_CHECK_FUNCS([endutent getutent getutid getutline pututline setutent])\nAC_CHECK_FUNCS([utmpname])\ndnl    Checks for utmpx functions\nAC_CHECK_FUNCS([endutxent getutxent getutxid getutxline getutxuser pututxline])\nAC_CHECK_FUNCS([setutxdb setutxent utmpxname])\ndnl    Checks for lastlog functions\nAC_CHECK_FUNCS([getlastlogxbyname])\n\nAC_CHECK_FUNC([daemon],\n\t[AC_DEFINE([HAVE_DAEMON], [1], [Define if your libraries define daemon()])],\n\t[AC_CHECK_LIB([bsd], [daemon],\n\t\t[LIBS=\"$LIBS -lbsd\"; AC_DEFINE([HAVE_DAEMON])])]\n)\n\nAC_CHECK_FUNC([getpagesize],\n\t[AC_DEFINE([HAVE_GETPAGESIZE], [1],\n\t\t[Define if your libraries define getpagesize()])],\n\t[AC_CHECK_LIB([ucb], [getpagesize],\n\t\t[LIBS=\"$LIBS -lucb\"; AC_DEFINE([HAVE_GETPAGESIZE])])]\n)\n\n# Check for broken snprintf\nif test \"x$ac_cv_func_snprintf\" = \"xyes\" ; then\n\tAC_MSG_CHECKING([whether snprintf correctly terminates long strings])\n\tAC_RUN_IFELSE(\n\t\t[AC_LANG_PROGRAM([[ #include <stdio.h> ]],\n\t\t[[\n\tchar b[5];\n\tsnprintf(b,5,\"123456789\");\n\texit(b[4]!='\\0');\n\t\t]])],\n\t\t[AC_MSG_RESULT([yes])],\n\t\t[\n\t\t\tAC_MSG_RESULT([no])\n\t\t\tAC_DEFINE([BROKEN_SNPRINTF], [1],\n\t\t\t\t[Define if your snprintf is busted])\n\t\t\tAC_MSG_WARN([****** Your snprintf() function is broken, complain to your vendor])\n\t\t],\n\t\t[ AC_MSG_WARN([cross compiling: Assuming working snprintf()]) ]\n\t)\nfi\n\nif test \"x$ac_cv_func_snprintf\" = \"xyes\" ; then\n\tAC_MSG_CHECKING([whether snprintf understands %zu])\n\tAC_RUN_IFELSE(\n\t\t[AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <stdio.h>\n\t\t]],\n\t\t[[\n\tsize_t a = 1, b = 2;\n\tchar z[128];\n\tsnprintf(z, sizeof z, \"%zu%zu\", a, b);\n\texit(strcmp(z, \"12\"));\n\t\t]])],\n\t\t[AC_MSG_RESULT([yes])],\n\t\t[\n\t\t\tAC_MSG_RESULT([no])\n\t\t\tAC_DEFINE([BROKEN_SNPRINTF], [1],\n\t\t\t\t[snprintf does not understand %zu])\n\t\t],\n\t\t[ AC_MSG_WARN([cross compiling: Assuming working snprintf()]) ]\n\t)\nfi\n\n# We depend on vsnprintf returning the right thing on overflow: the\n# number of characters it tried to create (as per SUSv3)\nif test \"x$ac_cv_func_vsnprintf\" = \"xyes\" ; then\n\tAC_MSG_CHECKING([whether vsnprintf returns correct values on overflow])\n\tAC_RUN_IFELSE(\n\t\t[AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <stdio.h>\n#include <stdarg.h>\n\nint x_snprintf(char *str, size_t count, const char *fmt, ...)\n{\n\tsize_t ret;\n\tva_list ap;\n\n\tva_start(ap, fmt);\n\tret = vsnprintf(str, count, fmt, ap);\n\tva_end(ap);\n\treturn ret;\n}\n\t\t]], [[\nchar x[1];\nif (x_snprintf(x, 1, \"%s %d\", \"hello\", 12345) != 11)\n\treturn 1;\nif (x_snprintf(NULL, 0, \"%s %d\", \"hello\", 12345) != 11)\n\treturn 1;\nreturn 0;\n\t\t]])],\n\t\t[AC_MSG_RESULT([yes])],\n\t\t[\n\t\t\tAC_MSG_RESULT([no])\n\t\t\tAC_DEFINE([BROKEN_SNPRINTF], [1],\n\t\t\t\t[Define if your snprintf is busted])\n\t\t\tAC_MSG_WARN([****** Your vsnprintf() function is broken, complain to your vendor])\n\t\t],\n\t\t[ AC_MSG_WARN([cross compiling: Assuming working vsnprintf()]) ]\n\t)\nfi\n\n# On systems where [v]snprintf is broken, but is declared in stdio,\n# check that the fmt argument is const char * or just char *.\n# This is only useful for when BROKEN_SNPRINTF\nAC_MSG_CHECKING([whether snprintf can declare const char *fmt])\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <stdio.h>\nint snprintf(char *a, size_t b, const char *c, ...) { return 0; }\n\t\t]], [[\n\tsnprintf(0, 0, 0);\n\t\t]])],\n   [AC_MSG_RESULT([yes])\n    AC_DEFINE([SNPRINTF_CONST], [const],\n              [Define as const if snprintf() can declare const char *fmt])],\n   [AC_MSG_RESULT([no])\n    AC_DEFINE([SNPRINTF_CONST], [/* not const */])])\n\n# Check for missing getpeereid (or equiv) support\nNO_PEERCHECK=\"\"\nif test \"x$ac_cv_func_getpeereid\" != \"xyes\" -a \"x$ac_cv_func_getpeerucred\" != \"xyes\"; then\n\tAC_MSG_CHECKING([whether system supports SO_PEERCRED getsockopt])\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <sys/socket.h>]], [[int i = SO_PEERCRED;]])],\n\t\t[ AC_MSG_RESULT([yes])\n\t\t  AC_DEFINE([HAVE_SO_PEERCRED], [1], [Have PEERCRED socket option])\n\t\t], [AC_MSG_RESULT([no])\n\t\tNO_PEERCHECK=1\n        ])\nfi\n\ndnl see whether mkstemp() requires XXXXXX\nif test \"x$ac_cv_func_mkdtemp\" = \"xyes\" ; then\nAC_MSG_CHECKING([for (overly) strict mkstemp])\nAC_RUN_IFELSE(\n\t[AC_LANG_PROGRAM([[\n#include <stdlib.h>\n\t]], [[\n\tchar template[]=\"conftest.mkstemp-test\";\n\tif (mkstemp(template) == -1)\n\t\texit(1);\n\tunlink(template);\n\texit(0);\n\t]])],\n\t[\n\t\tAC_MSG_RESULT([no])\n\t],\n\t[\n\t\tAC_MSG_RESULT([yes])\n\t\tAC_DEFINE([HAVE_STRICT_MKSTEMP], [1], [Silly mkstemp()])\n\t],\n\t[\n\t\tAC_MSG_RESULT([yes])\n\t\tAC_DEFINE([HAVE_STRICT_MKSTEMP])\n\t]\n)\nfi\n\ndnl make sure that openpty does not reacquire controlling terminal\nif test ! -z \"$check_for_openpty_ctty_bug\"; then\n\tAC_MSG_CHECKING([if openpty correctly handles controlling tty])\n\tAC_RUN_IFELSE(\n\t\t[AC_LANG_PROGRAM([[\n#include <stdio.h>\n#include <sys/fcntl.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n\t\t]], [[\n\tpid_t pid;\n\tint fd, ptyfd, ttyfd, status;\n\n\tpid = fork();\n\tif (pid < 0) {\t\t/* failed */\n\t\texit(1);\n\t} else if (pid > 0) {\t/* parent */\n\t\twaitpid(pid, &status, 0);\n\t\tif (WIFEXITED(status))\n\t\t\texit(WEXITSTATUS(status));\n\t\telse\n\t\t\texit(2);\n\t} else {\t\t/* child */\n\t\tclose(0); close(1); close(2);\n\t\tsetsid();\n\t\topenpty(&ptyfd, &ttyfd, NULL, NULL, NULL);\n\t\tfd = open(\"/dev/tty\", O_RDWR | O_NOCTTY);\n\t\tif (fd >= 0)\n\t\t\texit(3);\t/* Acquired ctty: broken */\n\t\telse\n\t\t\texit(0);\t/* Did not acquire ctty: OK */\n\t}\n\t\t]])],\n\t\t[\n\t\t\tAC_MSG_RESULT([yes])\n\t\t],\n\t\t[\n\t\t\tAC_MSG_RESULT([no])\n\t\t\tAC_DEFINE([SSHD_ACQUIRES_CTTY])\n\t\t],\n\t\t[\n\t\t\tAC_MSG_RESULT([cross-compiling, assuming yes])\n\t\t]\n\t)\nfi\n\nif test \"x$ac_cv_func_getaddrinfo\" = \"xyes\" && \\\n    test \"x$check_for_hpux_broken_getaddrinfo\" = \"x1\"; then\n\tAC_MSG_CHECKING([if getaddrinfo seems to work])\n\tAC_RUN_IFELSE(\n\t\t[AC_LANG_PROGRAM([[\n#include <stdio.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/in.h>\n\n#define TEST_PORT \"2222\"\n\t\t]], [[\n\tint err, sock;\n\tstruct addrinfo *gai_ai, *ai, hints;\n\tchar ntop[NI_MAXHOST], strport[NI_MAXSERV], *name = NULL;\n\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = PF_UNSPEC;\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_flags = AI_PASSIVE;\n\n\terr = getaddrinfo(name, TEST_PORT, &hints, &gai_ai);\n\tif (err != 0) {\n\t\tfprintf(stderr, \"getaddrinfo failed (%s)\", gai_strerror(err));\n\t\texit(1);\n\t}\n\n\tfor (ai = gai_ai; ai != NULL; ai = ai->ai_next) {\n\t\tif (ai->ai_family != AF_INET6)\n\t\t\tcontinue;\n\n\t\terr = getnameinfo(ai->ai_addr, ai->ai_addrlen, ntop,\n\t\t    sizeof(ntop), strport, sizeof(strport),\n\t\t    NI_NUMERICHOST|NI_NUMERICSERV);\n\n\t\tif (err != 0) {\n\t\t\tif (err == EAI_SYSTEM)\n\t\t\t\tperror(\"getnameinfo EAI_SYSTEM\");\n\t\t\telse\n\t\t\t\tfprintf(stderr, \"getnameinfo failed: %s\\n\",\n\t\t\t\t    gai_strerror(err));\n\t\t\texit(2);\n\t\t}\n\n\t\tsock = socket(ai->ai_family, ai->ai_socktype, ai->ai_protocol);\n\t\tif (sock < 0)\n\t\t\tperror(\"socket\");\n\t\tif (bind(sock, ai->ai_addr, ai->ai_addrlen) < 0) {\n\t\t\tif (errno == EBADF)\n\t\t\t\texit(3);\n\t\t}\n\t}\n\texit(0);\n\t\t]])],\n\t\t[\n\t\t\tAC_MSG_RESULT([yes])\n\t\t],\n\t\t[\n\t\t\tAC_MSG_RESULT([no])\n\t\t\tAC_DEFINE([BROKEN_GETADDRINFO])\n\t\t],\n\t\t[\n\t\t\tAC_MSG_RESULT([cross-compiling, assuming yes])\n\t\t]\n\t)\nfi\n\nif test \"x$ac_cv_func_getaddrinfo\" = \"xyes\" && \\\n    test \"x$check_for_aix_broken_getaddrinfo\" = \"x1\"; then\n\tAC_MSG_CHECKING([if getaddrinfo seems to work])\n\tAC_RUN_IFELSE(\n\t\t[AC_LANG_PROGRAM([[\n#include <stdio.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <errno.h>\n#include <netinet/in.h>\n\n#define TEST_PORT \"2222\"\n\t\t]], [[\n\tint err, sock;\n\tstruct addrinfo *gai_ai, *ai, hints;\n\tchar ntop[NI_MAXHOST], strport[NI_MAXSERV], *name = NULL;\n\n\tmemset(&hints, 0, sizeof(hints));\n\thints.ai_family = PF_UNSPEC;\n\thints.ai_socktype = SOCK_STREAM;\n\thints.ai_flags = AI_PASSIVE;\n\n\terr = getaddrinfo(name, TEST_PORT, &hints, &gai_ai);\n\tif (err != 0) {\n\t\tfprintf(stderr, \"getaddrinfo failed (%s)\", gai_strerror(err));\n\t\texit(1);\n\t}\n\n\tfor (ai = gai_ai; ai != NULL; ai = ai->ai_next) {\n\t\tif (ai->ai_family != AF_INET && ai->ai_family != AF_INET6)\n\t\t\tcontinue;\n\n\t\terr = getnameinfo(ai->ai_addr, ai->ai_addrlen, ntop,\n\t\t    sizeof(ntop), strport, sizeof(strport),\n\t\t    NI_NUMERICHOST|NI_NUMERICSERV);\n\n\t\tif (ai->ai_family == AF_INET && err != 0) {\n\t\t\tperror(\"getnameinfo\");\n\t\t\texit(2);\n\t\t}\n\t}\n\texit(0);\n\t\t]])],\n\t\t[\n\t\t\tAC_MSG_RESULT([yes])\n\t\t\tAC_DEFINE([AIX_GETNAMEINFO_HACK], [1],\n\t\t\t\t[Define if you have a getaddrinfo that fails\n\t\t\t\tfor the all-zeros IPv6 address])\n\t\t],\n\t\t[\n\t\t\tAC_MSG_RESULT([no])\n\t\t\tAC_DEFINE([BROKEN_GETADDRINFO])\n\t\t],\n\t\t[\n\t\t\tAC_MSG_RESULT([cross-compiling, assuming no])\n\t\t]\n\t)\nfi\n\nif test \"x$ac_cv_func_getaddrinfo\" = \"xyes\"; then\n\tAC_CHECK_DECLS(AI_NUMERICSERV, , ,\n\t    [#include <sys/types.h>\n\t     #include <sys/socket.h>\n\t     #include <netdb.h>])\nfi\n\nif test \"x$check_for_conflicting_getspnam\" = \"x1\"; then\n\tAC_MSG_CHECKING([for conflicting getspnam in shadow.h])\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[ #include <shadow.h> ]],\n\t\t[[ exit(0); ]])],\n\t\t[\n\t\t\tAC_MSG_RESULT([no])\n\t\t],\n\t\t[\n\t\t\tAC_MSG_RESULT([yes])\n\t\t\tAC_DEFINE([GETSPNAM_CONFLICTING_DEFS], [1],\n\t\t\t    [Conflicting defs for getspnam])\n\t\t]\n\t)\nfi\n\ndnl NetBSD added an strnvis and unfortunately made it incompatible with the\ndnl existing one in OpenBSD and Linux's libbsd (the former having existed\ndnl for over ten years). Despite this incompatibility being reported during\ndnl development (see http://gnats.netbsd.org/44977) they still shipped it.\ndnl Even more unfortunately FreeBSD and later MacOS picked up this incompatible\ndnl implementation.  Try to detect this mess, and assume the only safe option\ndnl if we're cross compiling.\ndnl\ndnl OpenBSD, 2001: strnvis(char *dst, const char *src, size_t dlen, int flag);\ndnl NetBSD: 2012,  strnvis(char *dst, size_t dlen, const char *src, int flag);\nif test \"x$ac_cv_func_strnvis\" = \"xyes\"; then\n\tAC_MSG_CHECKING([for working strnvis])\n\tAC_RUN_IFELSE(\n\t\t[AC_LANG_PROGRAM([[\n#include <signal.h>\n#include <stdlib.h>\n#include <string.h>\n#include <vis.h>\nstatic void sighandler(int sig) { _exit(1); }\n\t\t]], [[\n\tchar dst[16];\n\n\tsignal(SIGSEGV, sighandler);\n\tif (strnvis(dst, \"src\", 4, 0) && strcmp(dst, \"src\") == 0)\n\t\texit(0);\n\texit(1)\n\t\t]])],\n\t\t[AC_MSG_RESULT([yes])],\n\t\t[AC_MSG_RESULT([no])\n\t\t AC_DEFINE([BROKEN_STRNVIS], [1], [strnvis detected broken])],\n\t\t[AC_MSG_WARN([cross compiling: assuming broken])\n\t\t AC_DEFINE([BROKEN_STRNVIS], [1], [strnvis assumed broken])]\n\t)\nfi\n\nAC_CHECK_FUNCS([getpgrp],[\n\tAC_MSG_CHECKING([if getpgrp accepts zero args])\n\tAC_COMPILE_IFELSE(\n\t\t[AC_LANG_PROGRAM([[$ac_includes_default]], [[ getpgrp(); ]])],\n\t\t[ AC_MSG_RESULT([yes])\n\t\t  AC_DEFINE([GETPGRP_VOID], [1], [getpgrp takes zero args])],\n\t\t[ AC_MSG_RESULT([no])\n\t\t  AC_DEFINE([GETPGRP_VOID], [0], [getpgrp takes one arg])]\n\t)\n])\n\n# Search for OpenSSL\nsaved_CPPFLAGS=\"$CPPFLAGS\"\nsaved_LDFLAGS=\"$LDFLAGS\"\nAC_ARG_WITH([ssl-dir],\n\t[  --with-ssl-dir=PATH     Specify path to OpenSSL installation ],\n\t[\n\t\tif test \"x$openssl\" = \"xno\" ; then\n\t\t\tAC_MSG_ERROR([cannot use --with-ssl-dir when OpenSSL disabled])\n\t\tfi\n\t\tif test \"x$withval\" != \"xno\" ; then\n\t\t\tcase \"$withval\" in\n\t\t\t\t# Relative paths\n\t\t\t\t./*|../*)\twithval=\"`pwd`/$withval\"\n\t\t\tesac\n\t\t\tif test -d \"$withval/lib\"; then\n\t\t\t\tif test -n \"${rpath_opt}\"; then\n\t\t\t\t\tLDFLAGS=\"-L${withval}/lib ${rpath_opt}${withval}/lib ${LDFLAGS}\"\n\t\t\t\telse\n\t\t\t\t\tLDFLAGS=\"-L${withval}/lib ${LDFLAGS}\"\n\t\t\t\tfi\n\t\t\telif test -d \"$withval/lib64\"; then\n\t\t\t\tif test -n \"${rpath_opt}\"; then\n\t\t\t\t\tLDFLAGS=\"-L${withval}/lib64 ${rpath_opt}${withval}/lib64 ${LDFLAGS}\"\n\t\t\t\telse\n\t\t\t\t\tLDFLAGS=\"-L${withval}/lib64 ${LDFLAGS}\"\n\t\t\t\tfi\n\t\t\telse\n\t\t\t\tif test -n \"${rpath_opt}\"; then\n\t\t\t\t\tLDFLAGS=\"-L${withval} ${rpath_opt}${withval} ${LDFLAGS}\"\n\t\t\t\telse\n\t\t\t\t\tLDFLAGS=\"-L${withval} ${LDFLAGS}\"\n\t\t\t\tfi\n\t\t\tfi\n\t\t\tif test -d \"$withval/include\"; then\n\t\t\t\tCPPFLAGS=\"-I${withval}/include ${CPPFLAGS}\"\n\t\t\telse\n\t\t\t\tCPPFLAGS=\"-I${withval} ${CPPFLAGS}\"\n\t\t\tfi\n\t\tfi\n\t]\n)\n\nAC_ARG_WITH([openssl-header-check],\n\t[  --without-openssl-header-check Disable OpenSSL version consistency check],\n\t[\n\t\tif test \"x$withval\" = \"xno\" ; then\n\t\t\topenssl_check_nonfatal=1\n\t\tfi\n\t]\n)\n\nopenssl_engine=no\nAC_ARG_WITH([ssl-engine],\n\t[  --with-ssl-engine       Enable OpenSSL (hardware) ENGINE support ],\n\t[\n\t\tif test \"x$withval\" != \"xno\" ; then\n\t\t\tif test \"x$openssl\" = \"xno\" ; then\n\t\t\t\tAC_MSG_ERROR([cannot use --with-ssl-engine when OpenSSL disabled])\n\t\t\tfi\n\t\t\topenssl_engine=yes\n\t\tfi\n\t]\n)\n\nif test \"x$openssl\" = \"xyes\" ; then\n\tLIBS=\"-lcrypto $LIBS\"\n\tAC_TRY_LINK_FUNC([RAND_add], ,\n\t    [AC_MSG_ERROR([*** working libcrypto not found, check config.log])])\n\tAC_CHECK_HEADER([openssl/opensslv.h], ,\n\t    [AC_MSG_ERROR([*** OpenSSL headers missing - please install first or check config.log ***])])\n\n\t# Determine OpenSSL header version\n\tAC_MSG_CHECKING([OpenSSL header version])\n\tAC_RUN_IFELSE(\n\t\t[AC_LANG_PROGRAM([[\n\t#include <stdlib.h>\n\t#include <stdio.h>\n\t#include <string.h>\n\t#include <openssl/opensslv.h>\n\t#define DATA \"conftest.sslincver\"\n\t\t]], [[\n\t\tFILE *fd;\n\t\tint rc;\n\n\t\tfd = fopen(DATA,\"w\");\n\t\tif(fd == NULL)\n\t\t\texit(1);\n\n\t\tif ((rc = fprintf(fd, \"%08lx (%s)\\n\",\n\t\t    (unsigned long)OPENSSL_VERSION_NUMBER,\n\t\t     OPENSSL_VERSION_TEXT)) < 0)\n\t\t\texit(1);\n\n\t\texit(0);\n\t\t]])],\n\t\t[\n\t\t\tssl_header_ver=`cat conftest.sslincver`\n\t\t\tAC_MSG_RESULT([$ssl_header_ver])\n\t\t],\n\t\t[\n\t\t\tAC_MSG_RESULT([not found])\n\t\t\tAC_MSG_ERROR([OpenSSL version header not found.])\n\t\t],\n\t\t[\n\t\t\tAC_MSG_WARN([cross compiling: not checking])\n\t\t]\n\t)\n\n\t# Determining OpenSSL library version is version dependent.\n\tAC_CHECK_FUNCS([OpenSSL_version OpenSSL_version_num])\n\n\t# Determine OpenSSL library version\n\tAC_MSG_CHECKING([OpenSSL library version])\n\tAC_RUN_IFELSE(\n\t\t[AC_LANG_PROGRAM([[\n\t#include <stdio.h>\n\t#include <string.h>\n\t#include <openssl/opensslv.h>\n\t#include <openssl/crypto.h>\n\t#define DATA \"conftest.ssllibver\"\n\t\t]], [[\n\t\tFILE *fd;\n\t\tint rc;\n\n\t\tfd = fopen(DATA,\"w\");\n\t\tif(fd == NULL)\n\t\t\texit(1);\n#ifndef OPENSSL_VERSION\n# define OPENSSL_VERSION SSLEAY_VERSION\n#endif\n#ifndef HAVE_OPENSSL_VERSION\n# define OpenSSL_version\tSSLeay_version\n#endif\n#ifndef HAVE_OPENSSL_VERSION_NUM\n# define OpenSSL_version_num\tSSLeay\n#endif\n\t\tif ((rc = fprintf(fd, \"%08lx (%s)\\n\",\n\t\t    (unsigned long)OpenSSL_version_num(),\n\t\t    OpenSSL_version(OPENSSL_VERSION))) < 0)\n\t\t\texit(1);\n\n\t\texit(0);\n\t\t]])],\n\t\t[\n\t\t\tssl_library_ver=`cat conftest.ssllibver`\n\t\t\t# Check version is supported.\n\t\t\tcase \"$ssl_library_ver\" in\n\t\t\t10000*|0*)\n\t\t\t\tAC_MSG_ERROR([OpenSSL >= 1.0.1 required (have \"$ssl_library_ver\")])\n\t\t                ;;\n\t\t\t100*)   ;; # 1.0.x\n\t\t\t101000[[0123456]]*)\n\t\t\t\t# https://github.com/openssl/openssl/pull/4613\n\t\t\t\tAC_MSG_ERROR([OpenSSL 1.1.x versions prior to 1.1.0g have a bug that breaks their use with OpenSSH (have \"$ssl_library_ver\")])\n\t\t\t\t;;\n\t\t\t101*)   ;; # 1.1.x\n\t\t\t200*)   ;; # LibreSSL\n\t\t\t300*)   ;; # OpenSSL development branch.\n\t\t        *)\n\t\t\t\tAC_MSG_ERROR([Unknown/unsupported OpenSSL version (\"$ssl_library_ver\")])\n\t\t                ;;\n\t\t\tesac\n\t\t\tAC_MSG_RESULT([$ssl_library_ver])\n\t\t],\n\t\t[\n\t\t\tAC_MSG_RESULT([not found])\n\t\t\tAC_MSG_ERROR([OpenSSL library not found.])\n\t\t],\n\t\t[\n\t\t\tAC_MSG_WARN([cross compiling: not checking])\n\t\t]\n\t)\n\n\t# Sanity check OpenSSL headers\n\tAC_MSG_CHECKING([whether OpenSSL's headers match the library])\n\tAC_RUN_IFELSE(\n\t\t[AC_LANG_PROGRAM([[\n\t#include <string.h>\n\t#include <openssl/opensslv.h>\n\t#include <openssl/crypto.h>\n\t\t]], [[\n#ifndef HAVE_OPENSSL_VERSION_NUM\n# define OpenSSL_version_num\tSSLeay\n#endif\n\t\texit(OpenSSL_version_num() == OPENSSL_VERSION_NUMBER ? 0 : 1);\n\t\t]])],\n\t\t[\n\t\t\tAC_MSG_RESULT([yes])\n\t\t],\n\t\t[\n\t\t\tAC_MSG_RESULT([no])\n\t\t\tif test \"x$openssl_check_nonfatal\" = \"x\"; then\n\t\t\t\tAC_MSG_ERROR([Your OpenSSL headers do not match your\n\tlibrary. Check config.log for details.\n\tIf you are sure your installation is consistent, you can disable the check\n\tby running \"./configure --without-openssl-header-check\".\n\tAlso see contrib/findssl.sh for help identifying header/library mismatches.\n\t])\n\t\t\telse\n\t\t\t\tAC_MSG_WARN([Your OpenSSL headers do not match your\n\tlibrary. Check config.log for details.\n\tAlso see contrib/findssl.sh for help identifying header/library mismatches.])\n\t\t\tfi\n\t\t],\n\t\t[\n\t\t\tAC_MSG_WARN([cross compiling: not checking])\n\t\t]\n\t)\n\n\tAC_MSG_CHECKING([if programs using OpenSSL functions will link])\n\tAC_LINK_IFELSE(\n\t\t[AC_LANG_PROGRAM([[ #include <openssl/err.h> ]],\n\t\t[[ ERR_load_crypto_strings(); ]])],\n\t\t[\n\t\t\tAC_MSG_RESULT([yes])\n\t\t],\n\t\t[\n\t\t\tAC_MSG_RESULT([no])\n\t\t\tsaved_LIBS=\"$LIBS\"\n\t\t\tLIBS=\"$LIBS -ldl\"\n\t\t\tAC_MSG_CHECKING([if programs using OpenSSL need -ldl])\n\t\t\tAC_LINK_IFELSE(\n\t\t\t\t[AC_LANG_PROGRAM([[ #include <openssl/err.h> ]],\n\t\t\t\t[[ ERR_load_crypto_strings(); ]])],\n\t\t\t\t[\n\t\t\t\t\tAC_MSG_RESULT([yes])\n\t\t\t\t],\n\t\t\t\t[\n\t\t\t\t\tAC_MSG_RESULT([no])\n\t\t\t\t\tLIBS=\"$saved_LIBS\"\n\t\t\t\t]\n\t\t\t)\n\t\t]\n\t)\n\n\tAC_CHECK_FUNCS([ \\\n\t\tBN_is_prime_ex \\\n\t\tDSA_generate_parameters_ex \\\n\t\tEVP_CIPHER_CTX_ctrl \\\n\t\tEVP_DigestFinal_ex \\\n\t\tEVP_DigestInit_ex \\\n\t\tEVP_MD_CTX_cleanup \\\n\t\tEVP_MD_CTX_copy_ex \\\n\t\tEVP_MD_CTX_init \\\n\t\tHMAC_CTX_init \\\n\t\tRSA_generate_key_ex \\\n\t\tRSA_get_default_method \\\n\t])\n\n\t# OpenSSL_add_all_algorithms may be a macro.\n\tAC_CHECK_FUNC(OpenSSL_add_all_algorithms,\n\t    AC_DEFINE(HAVE_OPENSSL_ADD_ALL_ALGORITHMS, 1, [as a function]),\n\t    AC_CHECK_DECL(OpenSSL_add_all_algorithms,\n\t\tAC_DEFINE(HAVE_OPENSSL_ADD_ALL_ALGORITHMS, 1, [as a macro]), ,\n\t\t[[#include <openssl/evp.h>]]\n\t    )\n\t)\n\n\t# LibreSSL/OpenSSL 1.1x API\n\tAC_CHECK_FUNCS([ \\\n\t\tOPENSSL_init_crypto \\\n\t\tDH_get0_key \\\n\t\tDH_get0_pqg \\\n\t\tDH_set0_key \\\n\t\tDH_set_length \\\n\t\tDH_set0_pqg \\\n\t\tDSA_get0_key \\\n\t\tDSA_get0_pqg \\\n\t\tDSA_set0_key \\\n\t\tDSA_set0_pqg \\\n\t\tDSA_SIG_get0 \\\n\t\tDSA_SIG_set0 \\\n\t\tECDSA_SIG_get0 \\\n\t\tECDSA_SIG_set0 \\\n\t\tEVP_CIPHER_CTX_iv \\\n\t\tEVP_CIPHER_CTX_iv_noconst \\\n\t\tEVP_CIPHER_CTX_get_iv \\\n\t\tEVP_CIPHER_CTX_set_iv \\\n\t\tRSA_get0_crt_params \\\n\t\tRSA_get0_factors \\\n\t\tRSA_get0_key \\\n\t\tRSA_set0_crt_params \\\n\t\tRSA_set0_factors \\\n\t\tRSA_set0_key \\\n\t\tRSA_meth_free \\\n\t\tRSA_meth_dup \\\n\t\tRSA_meth_set1_name \\\n\t\tRSA_meth_get_finish \\\n\t\tRSA_meth_set_priv_enc \\\n\t\tRSA_meth_set_priv_dec \\\n\t\tRSA_meth_set_finish \\\n\t\tEVP_PKEY_get0_RSA \\\n\t\tEVP_MD_CTX_new \\\n\t\tEVP_MD_CTX_free \\\n\t])\n\n\tif test \"x$openssl_engine\" = \"xyes\" ; then\n\t\tAC_MSG_CHECKING([for OpenSSL ENGINE support])\n\t\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n\t#include <openssl/engine.h>\n\t\t\t]], [[\n\t\t\t\tENGINE_load_builtin_engines();\n\t\t\t\tENGINE_register_all_complete();\n\t\t\t]])],\n\t\t\t[ AC_MSG_RESULT([yes])\n\t\t\t  AC_DEFINE([USE_OPENSSL_ENGINE], [1],\n\t\t\t     [Enable OpenSSL engine support])\n\t\t\t], [ AC_MSG_ERROR([OpenSSL ENGINE support not found])\n\t\t])\n\tfi\n\n\t# Check for OpenSSL without EVP_aes_{192,256}_cbc\n\tAC_MSG_CHECKING([whether OpenSSL has crippled AES support])\n\tAC_LINK_IFELSE(\n\t\t[AC_LANG_PROGRAM([[\n\t#include <string.h>\n\t#include <openssl/evp.h>\n\t\t]], [[\n\t\texit(EVP_aes_192_cbc() == NULL || EVP_aes_256_cbc() == NULL);\n\t\t]])],\n\t\t[\n\t\t\tAC_MSG_RESULT([no])\n\t\t],\n\t\t[\n\t\t\tAC_MSG_RESULT([yes])\n\t\t\tAC_DEFINE([OPENSSL_LOBOTOMISED_AES], [1],\n\t\t\t    [libcrypto is missing AES 192 and 256 bit functions])\n\t\t]\n\t)\n\n\t# Check for OpenSSL with EVP_aes_*ctr\n\tAC_MSG_CHECKING([whether OpenSSL has AES CTR via EVP])\n\tAC_LINK_IFELSE(\n\t\t[AC_LANG_PROGRAM([[\n\t#include <string.h>\n\t#include <openssl/evp.h>\n\t\t]], [[\n\t\texit(EVP_aes_128_ctr() == NULL ||\n\t\t    EVP_aes_192_cbc() == NULL ||\n\t\t    EVP_aes_256_cbc() == NULL);\n\t\t]])],\n\t\t[\n\t\t\tAC_MSG_RESULT([yes])\n\t\t\tAC_DEFINE([OPENSSL_HAVE_EVPCTR], [1],\n\t\t\t    [libcrypto has EVP AES CTR])\n\t\t],\n\t\t[\n\t\t\tAC_MSG_RESULT([no])\n\t\t]\n\t)\n\n\t# Check for OpenSSL with EVP_aes_*gcm\n\tAC_MSG_CHECKING([whether OpenSSL has AES GCM via EVP])\n\tAC_LINK_IFELSE(\n\t\t[AC_LANG_PROGRAM([[\n\t#include <string.h>\n\t#include <openssl/evp.h>\n\t\t]], [[\n\t\texit(EVP_aes_128_gcm() == NULL ||\n\t\t    EVP_aes_256_gcm() == NULL ||\n\t\t    EVP_CTRL_GCM_SET_IV_FIXED == 0 ||\n\t\t    EVP_CTRL_GCM_IV_GEN == 0 ||\n\t\t    EVP_CTRL_GCM_SET_TAG == 0 ||\n\t\t    EVP_CTRL_GCM_GET_TAG == 0 ||\n\t\t    EVP_CIPHER_CTX_ctrl(NULL, 0, 0, NULL) == 0);\n\t\t]])],\n\t\t[\n\t\t\tAC_MSG_RESULT([yes])\n\t\t\tAC_DEFINE([OPENSSL_HAVE_EVPGCM], [1],\n\t\t\t    [libcrypto has EVP AES GCM])\n\t\t],\n\t\t[\n\t\t\tAC_MSG_RESULT([no])\n\t\t\tunsupported_algorithms=\"$unsupported_cipers \\\n\t\t\t   aes128-gcm@openssh.com \\\n\t\t\t   aes256-gcm@openssh.com\"\n\t\t]\n\t)\n\n\tAC_MSG_CHECKING([if EVP_DigestUpdate returns an int])\n\tAC_LINK_IFELSE(\n\t\t[AC_LANG_PROGRAM([[\n\t#include <string.h>\n\t#include <openssl/evp.h>\n\t\t]], [[\n\t\tif(EVP_DigestUpdate(NULL, NULL,0))\n\t\t\texit(0);\n\t\t]])],\n\t\t[\n\t\t\tAC_MSG_RESULT([yes])\n\t\t],\n\t\t[\n\t\t\tAC_MSG_RESULT([no])\n\t\t\tAC_DEFINE([OPENSSL_EVP_DIGESTUPDATE_VOID], [1],\n\t\t\t    [Define if EVP_DigestUpdate returns void])\n\t\t]\n\t)\n\n\t# Some systems want crypt() from libcrypt, *not* the version in OpenSSL,\n\t# because the system crypt() is more featureful.\n\tif test \"x$check_for_libcrypt_before\" = \"x1\"; then\n\t\tAC_CHECK_LIB([crypt], [crypt])\n\tfi\n\n\t# Some Linux systems (Slackware) need crypt() from libcrypt, *not* the\n\t# version in OpenSSL.\n\tif test \"x$check_for_libcrypt_later\" = \"x1\"; then\n\t\tAC_CHECK_LIB([crypt], [crypt], [LIBS=\"$LIBS -lcrypt\"])\n\tfi\n\tAC_CHECK_FUNCS([crypt DES_crypt])\n\n\t# Check for SHA256, SHA384 and SHA512 support in OpenSSL\n\tAC_CHECK_FUNCS([EVP_sha256 EVP_sha384 EVP_sha512])\n\n\t# Search for RIPE-MD support in OpenSSL\n\tAC_CHECK_FUNCS([EVP_ripemd160], ,\n\t    [unsupported_algorithms=\"$unsupported_algorithms \\\n\t\thmac-ripemd160 \\\n\t\thmac-ripemd160@openssh.com \\\n\t\thmac-ripemd160-etm@openssh.com\"\n\t     ]\n\t)\n\n\t# Check complete ECC support in OpenSSL\n\tAC_MSG_CHECKING([whether OpenSSL has NID_X9_62_prime256v1])\n\tAC_LINK_IFELSE(\n\t\t[AC_LANG_PROGRAM([[\n\t#include <openssl/ec.h>\n\t#include <openssl/ecdh.h>\n\t#include <openssl/ecdsa.h>\n\t#include <openssl/evp.h>\n\t#include <openssl/objects.h>\n\t#include <openssl/opensslv.h>\n\t\t]], [[\n\t\tEC_KEY *e = EC_KEY_new_by_curve_name(NID_X9_62_prime256v1);\n\t\tconst EVP_MD *m = EVP_sha256(); /* We need this too */\n\t\t]])],\n\t\t[ AC_MSG_RESULT([yes])\n\t\t  enable_nistp256=1 ],\n\t\t[ AC_MSG_RESULT([no]) ]\n\t)\n\n\tAC_MSG_CHECKING([whether OpenSSL has NID_secp384r1])\n\tAC_LINK_IFELSE(\n\t\t[AC_LANG_PROGRAM([[\n\t#include <openssl/ec.h>\n\t#include <openssl/ecdh.h>\n\t#include <openssl/ecdsa.h>\n\t#include <openssl/evp.h>\n\t#include <openssl/objects.h>\n\t#include <openssl/opensslv.h>\n\t\t]], [[\n\t\tEC_KEY *e = EC_KEY_new_by_curve_name(NID_secp384r1);\n\t\tconst EVP_MD *m = EVP_sha384(); /* We need this too */\n\t\t]])],\n\t\t[ AC_MSG_RESULT([yes])\n\t\t  enable_nistp384=1 ],\n\t\t[ AC_MSG_RESULT([no]) ]\n\t)\n\n\tAC_MSG_CHECKING([whether OpenSSL has NID_secp521r1])\n\tAC_LINK_IFELSE(\n\t\t[AC_LANG_PROGRAM([[\n\t#include <openssl/ec.h>\n\t#include <openssl/ecdh.h>\n\t#include <openssl/ecdsa.h>\n\t#include <openssl/evp.h>\n\t#include <openssl/objects.h>\n\t#include <openssl/opensslv.h>\n\t\t]], [[\n\t\tEC_KEY *e = EC_KEY_new_by_curve_name(NID_secp521r1);\n\t\tconst EVP_MD *m = EVP_sha512(); /* We need this too */\n\t\t]])],\n\t\t[ AC_MSG_RESULT([yes])\n\t\t  AC_MSG_CHECKING([if OpenSSL's NID_secp521r1 is functional])\n\t\t  AC_RUN_IFELSE(\n\t\t\t[AC_LANG_PROGRAM([[\n\t#include <openssl/ec.h>\n\t#include <openssl/ecdh.h>\n\t#include <openssl/ecdsa.h>\n\t#include <openssl/evp.h>\n\t#include <openssl/objects.h>\n\t#include <openssl/opensslv.h>\n\t\t\t]],[[\n\t\t\tEC_KEY *e = EC_KEY_new_by_curve_name(NID_secp521r1);\n\t\t\tconst EVP_MD *m = EVP_sha512(); /* We need this too */\n\t\t\texit(e == NULL || m == NULL);\n\t\t\t]])],\n\t\t\t[ AC_MSG_RESULT([yes])\n\t\t\t  enable_nistp521=1 ],\n\t\t\t[ AC_MSG_RESULT([no]) ],\n\t\t\t[ AC_MSG_WARN([cross-compiling: assuming yes])\n\t\t\t  enable_nistp521=1 ]\n\t\t  )],\n\t\tAC_MSG_RESULT([no])\n\t)\n\n\tCOMMENT_OUT_ECC=\"#no ecc#\"\n\tTEST_SSH_ECC=no\n\n\tif test x$enable_nistp256 = x1 || test x$enable_nistp384 = x1 || \\\n\t    test x$enable_nistp521 = x1; then\n\t\tAC_DEFINE(OPENSSL_HAS_ECC, [1], [OpenSSL has ECC])\n\t\tAC_CHECK_FUNCS([EC_KEY_METHOD_new])\n\tfi\n\tif test x$enable_nistp256 = x1; then\n\t\tAC_DEFINE([OPENSSL_HAS_NISTP256], [1],\n\t\t    [libcrypto has NID_X9_62_prime256v1])\n\t\tTEST_SSH_ECC=yes\n\t\tCOMMENT_OUT_ECC=\"\"\n\telse\n\t\tunsupported_algorithms=\"$unsupported_algorithms \\\n\t\t\tecdsa-sha2-nistp256 \\\n\t\t\tecdh-sha2-nistp256 \\\n\t\t\tecdsa-sha2-nistp256-cert-v01@openssh.com\"\n\tfi\n\tif test x$enable_nistp384 = x1; then\n\t\tAC_DEFINE([OPENSSL_HAS_NISTP384], [1], [libcrypto has NID_secp384r1])\n\t\tTEST_SSH_ECC=yes\n\t\tCOMMENT_OUT_ECC=\"\"\n\telse\n\t\tunsupported_algorithms=\"$unsupported_algorithms \\\n\t\t\tecdsa-sha2-nistp384 \\\n\t\t\tecdh-sha2-nistp384 \\\n\t\t\tecdsa-sha2-nistp384-cert-v01@openssh.com\"\n\tfi\n\tif test x$enable_nistp521 = x1; then\n\t\tAC_DEFINE([OPENSSL_HAS_NISTP521], [1], [libcrypto has NID_secp521r1])\n\t\tTEST_SSH_ECC=yes\n\t\tCOMMENT_OUT_ECC=\"\"\n\telse\n\t\tunsupported_algorithms=\"$unsupported_algorithms \\\n\t\t\tecdh-sha2-nistp521 \\\n\t\t\tecdsa-sha2-nistp521 \\\n\t\t\tecdsa-sha2-nistp521-cert-v01@openssh.com\"\n\tfi\n\n\tAC_SUBST([TEST_SSH_ECC])\n\tAC_SUBST([COMMENT_OUT_ECC])\nelse\n\tAC_CHECK_LIB([crypt], [crypt], [LIBS=\"$LIBS -lcrypt\"])\n\tAC_CHECK_FUNCS([crypt])\nfi\n\nAC_CHECK_FUNCS([ \\\n\tarc4random \\\n\tarc4random_buf \\\n\tarc4random_stir \\\n\tarc4random_uniform \\\n])\n\nsaved_LIBS=\"$LIBS\"\nAC_CHECK_LIB([iaf], [ia_openinfo], [\n\tLIBS=\"$LIBS -liaf\"\n\tAC_CHECK_FUNCS([set_id], [SSHDLIBS=\"$SSHDLIBS -liaf\"\n\t\t\t\tAC_DEFINE([HAVE_LIBIAF], [1],\n\t\t\t[Define if system has libiaf that supports set_id])\n\t\t\t\t])\n])\nLIBS=\"$saved_LIBS\"\n\n### Configure cryptographic random number support\n\n# Check whether OpenSSL seeds itself\nif test \"x$openssl\" = \"xyes\" ; then\n\tAC_MSG_CHECKING([whether OpenSSL's PRNG is internally seeded])\n\tAC_RUN_IFELSE(\n\t\t[AC_LANG_PROGRAM([[\n\t#include <string.h>\n\t#include <openssl/rand.h>\n\t\t]], [[\n\t\texit(RAND_status() == 1 ? 0 : 1);\n\t\t]])],\n\t\t[\n\t\t\tOPENSSL_SEEDS_ITSELF=yes\n\t\t\tAC_MSG_RESULT([yes])\n\t\t],\n\t\t[\n\t\t\tAC_MSG_RESULT([no])\n\t\t],\n\t\t[\n\t\t\tAC_MSG_WARN([cross compiling: assuming yes])\n\t\t\t# This is safe, since we will fatal() at runtime if\n\t\t\t# OpenSSL is not seeded correctly.\n\t\t\tOPENSSL_SEEDS_ITSELF=yes\n\t\t]\n\t)\nfi\n\n# PRNGD TCP socket\nAC_ARG_WITH([prngd-port],\n\t[  --with-prngd-port=PORT  read entropy from PRNGD/EGD TCP localhost:PORT],\n\t[\n\t\tcase \"$withval\" in\n\t\tno)\n\t\t\twithval=\"\"\n\t\t\t;;\n\t\t[[0-9]]*)\n\t\t\t;;\n\t\t*)\n\t\t\tAC_MSG_ERROR([You must specify a numeric port number for --with-prngd-port])\n\t\t\t;;\n\t\tesac\n\t\tif test ! -z \"$withval\" ; then\n\t\t\tPRNGD_PORT=\"$withval\"\n\t\t\tAC_DEFINE_UNQUOTED([PRNGD_PORT], [$PRNGD_PORT],\n\t\t\t\t[Port number of PRNGD/EGD random number socket])\n\t\tfi\n\t]\n)\n\n# PRNGD Unix domain socket\nAC_ARG_WITH([prngd-socket],\n\t[  --with-prngd-socket=FILE read entropy from PRNGD/EGD socket FILE (default=/var/run/egd-pool)],\n\t[\n\t\tcase \"$withval\" in\n\t\tyes)\n\t\t\twithval=\"/var/run/egd-pool\"\n\t\t\t;;\n\t\tno)\n\t\t\twithval=\"\"\n\t\t\t;;\n\t\t/*)\n\t\t\t;;\n\t\t*)\n\t\t\tAC_MSG_ERROR([You must specify an absolute path to the entropy socket])\n\t\t\t;;\n\t\tesac\n\n\t\tif test ! -z \"$withval\" ; then\n\t\t\tif test ! -z \"$PRNGD_PORT\" ; then\n\t\t\t\tAC_MSG_ERROR([You may not specify both a PRNGD/EGD port and socket])\n\t\t\tfi\n\t\t\tif test ! -r \"$withval\" ; then\n\t\t\t\tAC_MSG_WARN([Entropy socket is not readable])\n\t\t\tfi\n\t\t\tPRNGD_SOCKET=\"$withval\"\n\t\t\tAC_DEFINE_UNQUOTED([PRNGD_SOCKET], [\"$PRNGD_SOCKET\"],\n\t\t\t\t[Location of PRNGD/EGD random number socket])\n\t\tfi\n\t],\n\t[\n\t\t# Check for existing socket only if we don't have a random device already\n\t\tif test \"x$OPENSSL_SEEDS_ITSELF\" != \"xyes\" ; then\n\t\t\tAC_MSG_CHECKING([for PRNGD/EGD socket])\n\t\t\t# Insert other locations here\n\t\t\tfor sock in /var/run/egd-pool /dev/egd-pool /etc/entropy; do\n\t\t\t\tif test -r $sock && $TEST_MINUS_S_SH -c \"test -S $sock -o -p $sock\" ; then\n\t\t\t\t\tPRNGD_SOCKET=\"$sock\"\n\t\t\t\t\tAC_DEFINE_UNQUOTED([PRNGD_SOCKET], [\"$PRNGD_SOCKET\"])\n\t\t\t\t\tbreak;\n\t\t\t\tfi\n\t\t\tdone\n\t\t\tif test ! -z \"$PRNGD_SOCKET\" ; then\n\t\t\t\tAC_MSG_RESULT([$PRNGD_SOCKET])\n\t\t\telse\n\t\t\t\tAC_MSG_RESULT([not found])\n\t\t\tfi\n\t\tfi\n\t]\n)\n\n# Which randomness source do we use?\nif test ! -z \"$PRNGD_PORT\" ; then\n\tRAND_MSG=\"PRNGd port $PRNGD_PORT\"\nelif test ! -z \"$PRNGD_SOCKET\" ; then\n\tRAND_MSG=\"PRNGd socket $PRNGD_SOCKET\"\nelif test ! -z \"$OPENSSL_SEEDS_ITSELF\" ; then\n\tAC_DEFINE([OPENSSL_PRNG_ONLY], [1],\n\t\t[Define if you want the OpenSSL internally seeded PRNG only])\n\tRAND_MSG=\"OpenSSL internal ONLY\"\nelif test \"x$openssl\" = \"xno\" ; then\n\tAC_MSG_WARN([OpenSSH will use /dev/urandom as a source of random numbers. It will fail if this device is not supported or accessible])\nelse\n\tAC_MSG_ERROR([OpenSSH has no source of random numbers. Please configure OpenSSL with an entropy source or re-run configure using one of the --with-prngd-port or --with-prngd-socket options])\nfi\n\n# Check for PAM libs\nPAM_MSG=\"no\"\nAC_ARG_WITH([pam],\n\t[  --with-pam              Enable PAM support ],\n\t[\n\t\tif test \"x$withval\" != \"xno\" ; then\n\t\t\tif test \"x$ac_cv_header_security_pam_appl_h\" != \"xyes\" && \\\n\t\t\t   test \"x$ac_cv_header_pam_pam_appl_h\" != \"xyes\" ; then\n\t\t\t\tAC_MSG_ERROR([PAM headers not found])\n\t\t\tfi\n\n\t\t\tsaved_LIBS=\"$LIBS\"\n\t\t\tAC_CHECK_LIB([dl], [dlopen], , )\n\t\t\tAC_CHECK_LIB([pam], [pam_set_item], , [AC_MSG_ERROR([*** libpam missing])])\n\t\t\tAC_CHECK_FUNCS([pam_getenvlist])\n\t\t\tAC_CHECK_FUNCS([pam_putenv])\n\t\t\tLIBS=\"$saved_LIBS\"\n\n\t\t\tPAM_MSG=\"yes\"\n\n\t\t\tSSHDLIBS=\"$SSHDLIBS -lpam\"\n\t\t\tAC_DEFINE([USE_PAM], [1],\n\t\t\t\t[Define if you want to enable PAM support])\n\n\t\t\tif test $ac_cv_lib_dl_dlopen = yes; then\n\t\t\t\tcase \"$LIBS\" in\n\t\t\t\t*-ldl*)\n\t\t\t\t\t# libdl already in LIBS\n\t\t\t\t\t;;\n\t\t\t\t*)\n\t\t\t\t\tSSHDLIBS=\"$SSHDLIBS -ldl\"\n\t\t\t\t\t;;\n\t\t\t\tesac\n\t\t\tfi\n\t\tfi\n\t]\n)\n\nAC_ARG_WITH([pam-service],\n\t[  --with-pam-service=name Specify PAM service name ],\n\t[\n\t\tif test \"x$withval\" != \"xno\" && \\\n\t\t   test \"x$withval\" != \"xyes\" ; then\n\t\t\tAC_DEFINE_UNQUOTED([SSHD_PAM_SERVICE],\n\t\t\t\t[\"$withval\"], [sshd PAM service name])\n\t\tfi\n\t]\n)\n\n# Check for older PAM\nif test \"x$PAM_MSG\" = \"xyes\" ; then\n\t# Check PAM strerror arguments (old PAM)\n\tAC_MSG_CHECKING([whether pam_strerror takes only one argument])\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <stdlib.h>\n#if defined(HAVE_SECURITY_PAM_APPL_H)\n#include <security/pam_appl.h>\n#elif defined (HAVE_PAM_PAM_APPL_H)\n#include <pam/pam_appl.h>\n#endif\n\t\t]], [[\n(void)pam_strerror((pam_handle_t *)NULL, -1);\n\t\t]])], [AC_MSG_RESULT([no])], [\n\t\t\tAC_DEFINE([HAVE_OLD_PAM], [1],\n\t\t\t\t[Define if you have an old version of PAM\n\t\t\t\twhich takes only one argument to pam_strerror])\n\t\t\tAC_MSG_RESULT([yes])\n\t\t\tPAM_MSG=\"yes (old library)\"\n\n\t])\nfi\n\ncase \"$host\" in\n*-*-cygwin*)\n\tSSH_PRIVSEP_USER=CYGWIN_SSH_PRIVSEP_USER\n\t;;\n*)\n\tSSH_PRIVSEP_USER=sshd\n\t;;\nesac\nAC_ARG_WITH([privsep-user],\n\t[  --with-privsep-user=user Specify non-privileged user for privilege separation],\n\t[\n\t\tif test -n \"$withval\"  &&  test \"x$withval\" != \"xno\"  &&  \\\n\t\t    test \"x${withval}\" != \"xyes\"; then\n\t\t\tSSH_PRIVSEP_USER=$withval\n\t\tfi\n\t]\n)\nif test \"x$SSH_PRIVSEP_USER\" = \"xCYGWIN_SSH_PRIVSEP_USER\" ; then\n\tAC_DEFINE_UNQUOTED([SSH_PRIVSEP_USER], [CYGWIN_SSH_PRIVSEP_USER],\n\t\t[Cygwin function to fetch non-privileged user for privilege separation])\nelse\n\tAC_DEFINE_UNQUOTED([SSH_PRIVSEP_USER], [\"$SSH_PRIVSEP_USER\"],\n\t\t[non-privileged user for privilege separation])\nfi\nAC_SUBST([SSH_PRIVSEP_USER])\n\nif test \"x$have_linux_no_new_privs\" = \"x1\" ; then\nAC_CHECK_DECL([SECCOMP_MODE_FILTER], [have_seccomp_filter=1], , [\n\t#include <sys/types.h>\n\t#include <linux/seccomp.h>\n])\nfi\nif test \"x$have_seccomp_filter\" = \"x1\" ; then\nAC_MSG_CHECKING([kernel for seccomp_filter support])\nAC_LINK_IFELSE([AC_LANG_PROGRAM([[\n\t\t#include <errno.h>\n\t\t#include <elf.h>\n\t\t#include <linux/audit.h>\n\t\t#include <linux/seccomp.h>\n\t\t#include <stdlib.h>\n\t\t#include <sys/prctl.h>\n\t]],\n\t[[ int i = $seccomp_audit_arch;\n\t   errno = 0;\n\t   prctl(PR_SET_SECCOMP, SECCOMP_MODE_FILTER, NULL, 0, 0);\n\t   exit(errno == EFAULT ? 0 : 1); ]])],\n\t[ AC_MSG_RESULT([yes]) ], [\n\t\tAC_MSG_RESULT([no])\n\t\t# Disable seccomp filter as a target\n\t\thave_seccomp_filter=0\n\t]\n)\nfi\n\n# Decide which sandbox style to use\nsandbox_arg=\"\"\nAC_ARG_WITH([sandbox],\n\t[  --with-sandbox=style    Specify privilege separation sandbox (no, capsicum, darwin, rlimit, seccomp_filter, systrace, pledge)],\n\t[\n\t\tif test \"x$withval\" = \"xyes\" ; then\n\t\t\tsandbox_arg=\"\"\n\t\telse\n\t\t\tsandbox_arg=\"$withval\"\n\t\tfi\n\t]\n)\n\n# Some platforms (seems to be the ones that have a kernel poll(2)-type\n# function with which they implement select(2)) use an extra file descriptor\n# when calling select(2), which means we can't use the rlimit sandbox.\nAC_MSG_CHECKING([if select works with descriptor rlimit])\nAC_RUN_IFELSE(\n\t[AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#ifdef HAVE_SYS_TIME_H\n# include <sys/time.h>\n#endif\n#include <sys/resource.h>\n#ifdef HAVE_SYS_SELECT_H\n# include <sys/select.h>\n#endif\n#include <errno.h>\n#include <fcntl.h>\n#include <stdlib.h>\n\t]],[[\n\tstruct rlimit rl_zero;\n\tint fd, r;\n\tfd_set fds;\n\tstruct timeval tv;\n\n\tfd = open(\"/dev/null\", O_RDONLY);\n\tFD_ZERO(&fds);\n\tFD_SET(fd, &fds);\n\trl_zero.rlim_cur = rl_zero.rlim_max = 0;\n\tsetrlimit(RLIMIT_FSIZE, &rl_zero);\n\tsetrlimit(RLIMIT_NOFILE, &rl_zero);\n\ttv.tv_sec = 1;\n\ttv.tv_usec = 0;\n\tr = select(fd+1, &fds, NULL, NULL, &tv);\n\texit (r == -1 ? 1 : 0);\n\t]])],\n\t[AC_MSG_RESULT([yes])\n\t select_works_with_rlimit=yes],\n\t[AC_MSG_RESULT([no])\n\t select_works_with_rlimit=no],\n\t[AC_MSG_WARN([cross compiling: assuming yes])\n\t select_works_with_rlimit=yes]\n)\n\nAC_MSG_CHECKING([if setrlimit(RLIMIT_NOFILE,{0,0}) works])\nAC_RUN_IFELSE(\n\t[AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#ifdef HAVE_SYS_TIME_H\n# include <sys/time.h>\n#endif\n#include <sys/resource.h>\n#include <errno.h>\n#include <stdlib.h>\n\t]],[[\n\tstruct rlimit rl_zero;\n\tint r;\n\n\trl_zero.rlim_cur = rl_zero.rlim_max = 0;\n\tr = setrlimit(RLIMIT_NOFILE, &rl_zero);\n\texit (r == -1 ? 1 : 0);\n\t]])],\n\t[AC_MSG_RESULT([yes])\n\t rlimit_nofile_zero_works=yes],\n\t[AC_MSG_RESULT([no])\n\t rlimit_nofile_zero_works=no],\n\t[AC_MSG_WARN([cross compiling: assuming yes])\n\t rlimit_nofile_zero_works=yes]\n)\n\nAC_MSG_CHECKING([if setrlimit RLIMIT_FSIZE works])\nAC_RUN_IFELSE(\n\t[AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <sys/resource.h>\n#include <stdlib.h>\n\t]],[[\n\t\tstruct rlimit rl_zero;\n\n\t\trl_zero.rlim_cur = rl_zero.rlim_max = 0;\n\t\texit(setrlimit(RLIMIT_FSIZE, &rl_zero) != 0);\n\t]])],\n\t[AC_MSG_RESULT([yes])],\n\t[AC_MSG_RESULT([no])\n\t AC_DEFINE(SANDBOX_SKIP_RLIMIT_FSIZE, 1,\n\t    [setrlimit RLIMIT_FSIZE works])],\n\t[AC_MSG_WARN([cross compiling: assuming yes])]\n)\n\nif test \"x$sandbox_arg\" = \"xpledge\" || \\\n   ( test -z \"$sandbox_arg\" && test \"x$ac_cv_func_pledge\" = \"xyes\" ) ; then\n\ttest \"x$ac_cv_func_pledge\" != \"xyes\" && \\\n\t\tAC_MSG_ERROR([pledge sandbox requires pledge(2) support])\n\tSANDBOX_STYLE=\"pledge\"\n\tAC_DEFINE([SANDBOX_PLEDGE], [1], [Sandbox using pledge(2)])\nelif test \"x$sandbox_arg\" = \"xsystrace\" || \\\n   ( test -z \"$sandbox_arg\" && test \"x$have_systr_policy_kill\" = \"x1\" ) ; then\n\ttest \"x$have_systr_policy_kill\" != \"x1\" && \\\n\t\tAC_MSG_ERROR([systrace sandbox requires systrace headers and SYSTR_POLICY_KILL support])\n\tSANDBOX_STYLE=\"systrace\"\n\tAC_DEFINE([SANDBOX_SYSTRACE], [1], [Sandbox using systrace(4)])\nelif test \"x$sandbox_arg\" = \"xdarwin\" || \\\n     ( test -z \"$sandbox_arg\" && test \"x$ac_cv_func_sandbox_init\" = \"xyes\" && \\\n       test \"x$ac_cv_header_sandbox_h\" = \"xyes\") ; then\n\ttest \"x$ac_cv_func_sandbox_init\" != \"xyes\" -o \\\n\t     \"x$ac_cv_header_sandbox_h\" != \"xyes\" && \\\n\t\tAC_MSG_ERROR([Darwin seatbelt sandbox requires sandbox.h and sandbox_init function])\n\tSANDBOX_STYLE=\"darwin\"\n\tAC_DEFINE([SANDBOX_DARWIN], [1], [Sandbox using Darwin sandbox_init(3)])\nelif test \"x$sandbox_arg\" = \"xseccomp_filter\" || \\\n     ( test -z \"$sandbox_arg\" && \\\n       test \"x$have_seccomp_filter\" = \"x1\" && \\\n       test \"x$ac_cv_header_elf_h\" = \"xyes\" && \\\n       test \"x$ac_cv_header_linux_audit_h\" = \"xyes\" && \\\n       test \"x$ac_cv_header_linux_filter_h\" = \"xyes\" && \\\n       test \"x$seccomp_audit_arch\" != \"x\" && \\\n       test \"x$have_linux_no_new_privs\" = \"x1\" && \\\n       test \"x$ac_cv_func_prctl\" = \"xyes\" ) ; then\n\ttest \"x$seccomp_audit_arch\" = \"x\" && \\\n\t\tAC_MSG_ERROR([seccomp_filter sandbox not supported on $host])\n\ttest \"x$have_linux_no_new_privs\" != \"x1\" && \\\n\t\tAC_MSG_ERROR([seccomp_filter sandbox requires PR_SET_NO_NEW_PRIVS])\n\ttest \"x$have_seccomp_filter\" != \"x1\" && \\\n\t\tAC_MSG_ERROR([seccomp_filter sandbox requires seccomp headers])\n\ttest \"x$ac_cv_func_prctl\" != \"xyes\" && \\\n\t\tAC_MSG_ERROR([seccomp_filter sandbox requires prctl function])\n\tSANDBOX_STYLE=\"seccomp_filter\"\n\tAC_DEFINE([SANDBOX_SECCOMP_FILTER], [1], [Sandbox using seccomp filter])\nelif test \"x$sandbox_arg\" = \"xcapsicum\" || \\\n     ( test -z \"$sandbox_arg\" && \\\n       test \"x$ac_cv_header_sys_capsicum_h\" = \"xyes\" && \\\n       test \"x$ac_cv_func_cap_rights_limit\" = \"xyes\") ; then\n       test \"x$ac_cv_header_sys_capsicum_h\" != \"xyes\" && \\\n\t\tAC_MSG_ERROR([capsicum sandbox requires sys/capsicum.h header])\n       test \"x$ac_cv_func_cap_rights_limit\" != \"xyes\" && \\\n\t\tAC_MSG_ERROR([capsicum sandbox requires cap_rights_limit function])\n       SANDBOX_STYLE=\"capsicum\"\n       AC_DEFINE([SANDBOX_CAPSICUM], [1], [Sandbox using capsicum])\nelif test \"x$sandbox_arg\" = \"xrlimit\" || \\\n     ( test -z \"$sandbox_arg\" && test \"x$ac_cv_func_setrlimit\" = \"xyes\" && \\\n       test \"x$select_works_with_rlimit\" = \"xyes\" && \\\n       test \"x$rlimit_nofile_zero_works\" = \"xyes\" ) ; then\n\ttest \"x$ac_cv_func_setrlimit\" != \"xyes\" && \\\n\t\tAC_MSG_ERROR([rlimit sandbox requires setrlimit function])\n\ttest \"x$select_works_with_rlimit\" != \"xyes\" && \\\n\t\tAC_MSG_ERROR([rlimit sandbox requires select to work with rlimit])\n\tSANDBOX_STYLE=\"rlimit\"\n\tAC_DEFINE([SANDBOX_RLIMIT], [1], [Sandbox using setrlimit(2)])\nelif test \"x$sandbox_arg\" = \"xsolaris\" || \\\n   ( test -z \"$sandbox_arg\" && test \"x$SOLARIS_PRIVS\" = \"xyes\" ) ; then\n\tSANDBOX_STYLE=\"solaris\"\n\tAC_DEFINE([SANDBOX_SOLARIS], [1], [Sandbox using Solaris/Illumos privileges])\nelif test -z \"$sandbox_arg\" || test \"x$sandbox_arg\" = \"xno\" || \\\n     test \"x$sandbox_arg\" = \"xnone\" || test \"x$sandbox_arg\" = \"xnull\" ; then\n\tSANDBOX_STYLE=\"none\"\n\tAC_DEFINE([SANDBOX_NULL], [1], [no privsep sandboxing])\nelse\n\tAC_MSG_ERROR([unsupported --with-sandbox])\nfi\n\n# Cheap hack to ensure NEWS-OS libraries are arranged right.\nif test ! -z \"$SONY\" ; then\n  LIBS=\"$LIBS -liberty\";\nfi\n\n# Check for  long long datatypes\nAC_CHECK_TYPES([long long, unsigned long long, long double])\n\n# Check datatype sizes\nAC_CHECK_SIZEOF([short int])\nAC_CHECK_SIZEOF([int])\nAC_CHECK_SIZEOF([long int])\nAC_CHECK_SIZEOF([long long int])\n\n# Sanity check long long for some platforms (AIX)\nif test \"x$ac_cv_sizeof_long_long_int\" = \"x4\" ; then\n\tac_cv_sizeof_long_long_int=0\nfi\n\n# compute LLONG_MIN and LLONG_MAX if we don't know them.\nif test -z \"$have_llong_max\"; then\n\tAC_MSG_CHECKING([for max value of long long])\n\tAC_RUN_IFELSE(\n\t\t[AC_LANG_PROGRAM([[\n#include <stdio.h>\n/* Why is this so damn hard? */\n#ifdef __GNUC__\n# undef __GNUC__\n#endif\n#define __USE_ISOC99\n#include <limits.h>\n#define DATA \"conftest.llminmax\"\n#define my_abs(a) ((a) < 0 ? ((a) * -1) : (a))\n\n/*\n * printf in libc on some platforms (eg old Tru64) does not understand %lld so\n * we do this the hard way.\n */\nstatic int\nfprint_ll(FILE *f, long long n)\n{\n\tunsigned int i;\n\tint l[sizeof(long long) * 8];\n\n\tif (n < 0)\n\t\tif (fprintf(f, \"-\") < 0)\n\t\t\treturn -1;\n\tfor (i = 0; n != 0; i++) {\n\t\tl[i] = my_abs(n % 10);\n\t\tn /= 10;\n\t}\n\tdo {\n\t\tif (fprintf(f, \"%d\", l[--i]) < 0)\n\t\t\treturn -1;\n\t} while (i != 0);\n\tif (fprintf(f, \" \") < 0)\n\t\treturn -1;\n\treturn 0;\n}\n\t\t]], [[\n\tFILE *f;\n\tlong long i, llmin, llmax = 0;\n\n\tif((f = fopen(DATA,\"w\")) == NULL)\n\t\texit(1);\n\n#if defined(LLONG_MIN) && defined(LLONG_MAX)\n\tfprintf(stderr, \"Using system header for LLONG_MIN and LLONG_MAX\\n\");\n\tllmin = LLONG_MIN;\n\tllmax = LLONG_MAX;\n#else\n\tfprintf(stderr, \"Calculating  LLONG_MIN and LLONG_MAX\\n\");\n\t/* This will work on one's complement and two's complement */\n\tfor (i = 1; i > llmax; i <<= 1, i++)\n\t\tllmax = i;\n\tllmin = llmax + 1LL;\t/* wrap */\n#endif\n\n\t/* Sanity check */\n\tif (llmin + 1 < llmin || llmin - 1 < llmin || llmax + 1 > llmax\n\t    || llmax - 1 > llmax || llmin == llmax || llmin == 0\n\t    || llmax == 0 || llmax < LONG_MAX || llmin > LONG_MIN) {\n\t\tfprintf(f, \"unknown unknown\\n\");\n\t\texit(2);\n\t}\n\n\tif (fprint_ll(f, llmin) < 0)\n\t\texit(3);\n\tif (fprint_ll(f, llmax) < 0)\n\t\texit(4);\n\tif (fclose(f) < 0)\n\t\texit(5);\n\texit(0);\n\t\t]])],\n\t\t[\n\t\t\tllong_min=`$AWK '{print $1}' conftest.llminmax`\n\t\t\tllong_max=`$AWK '{print $2}' conftest.llminmax`\n\n\t\t\tAC_MSG_RESULT([$llong_max])\n\t\t\tAC_DEFINE_UNQUOTED([LLONG_MAX], [${llong_max}LL],\n\t\t\t    [max value of long long calculated by configure])\n\t\t\tAC_MSG_CHECKING([for min value of long long])\n\t\t\tAC_MSG_RESULT([$llong_min])\n\t\t\tAC_DEFINE_UNQUOTED([LLONG_MIN], [${llong_min}LL],\n\t\t\t    [min value of long long calculated by configure])\n\t\t],\n\t\t[\n\t\t\tAC_MSG_RESULT([not found])\n\t\t],\n\t\t[\n\t\t\tAC_MSG_WARN([cross compiling: not checking])\n\t\t]\n\t)\nfi\n\n\n# More checks for data types\nAC_CACHE_CHECK([for u_int type], ac_cv_have_u_int, [\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[ #include <sys/types.h> ]],\n\t[[ u_int a; a = 1;]])],\n\t[ ac_cv_have_u_int=\"yes\" ], [ ac_cv_have_u_int=\"no\"\n\t])\n])\nif test \"x$ac_cv_have_u_int\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE_U_INT], [1], [define if you have u_int data type])\n\thave_u_int=1\nfi\n\nAC_CACHE_CHECK([for intXX_t types], ac_cv_have_intxx_t, [\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[ #include <sys/types.h> ]],\n\t[[ int8_t a; int16_t b; int32_t c; a = b = c = 1;]])],\n\t[ ac_cv_have_intxx_t=\"yes\" ], [ ac_cv_have_intxx_t=\"no\"\n\t])\n])\nif test \"x$ac_cv_have_intxx_t\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE_INTXX_T], [1], [define if you have intxx_t data type])\n\thave_intxx_t=1\nfi\n\nif (test -z \"$have_intxx_t\" && \\\n\t   test \"x$ac_cv_header_stdint_h\" = \"xyes\")\nthen\n    AC_MSG_CHECKING([for intXX_t types in stdint.h])\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[ #include <stdint.h> ]],\n\t[[ int8_t a; int16_t b; int32_t c; a = b = c = 1;]])],\n\t\t[\n\t\t\tAC_DEFINE([HAVE_INTXX_T])\n\t\t\tAC_MSG_RESULT([yes])\n\t\t], [ AC_MSG_RESULT([no])\n\t])\nfi\n\nAC_CACHE_CHECK([for int64_t type], ac_cv_have_int64_t, [\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#ifdef HAVE_STDINT_H\n# include <stdint.h>\n#endif\n#include <sys/socket.h>\n#ifdef HAVE_SYS_BITYPES_H\n# include <sys/bitypes.h>\n#endif\n\t\t]], [[\nint64_t a; a = 1;\n\t\t]])],\n\t[ ac_cv_have_int64_t=\"yes\" ], [ ac_cv_have_int64_t=\"no\"\n\t])\n])\nif test \"x$ac_cv_have_int64_t\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE_INT64_T], [1], [define if you have int64_t data type])\nfi\n\nAC_CACHE_CHECK([for u_intXX_t types], ac_cv_have_u_intxx_t, [\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[ #include <sys/types.h> ]],\n\t[[ u_int8_t a; u_int16_t b; u_int32_t c; a = b = c = 1;]])],\n\t[ ac_cv_have_u_intxx_t=\"yes\" ], [ ac_cv_have_u_intxx_t=\"no\"\n\t])\n])\nif test \"x$ac_cv_have_u_intxx_t\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE_U_INTXX_T], [1], [define if you have u_intxx_t data type])\n\thave_u_intxx_t=1\nfi\n\nif test -z \"$have_u_intxx_t\" ; then\n    AC_MSG_CHECKING([for u_intXX_t types in sys/socket.h])\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[ #include <sys/socket.h> ]],\n\t[[ u_int8_t a; u_int16_t b; u_int32_t c; a = b = c = 1;]])],\n\t\t[\n\t\t\tAC_DEFINE([HAVE_U_INTXX_T])\n\t\t\tAC_MSG_RESULT([yes])\n\t\t], [ AC_MSG_RESULT([no])\n\t])\nfi\n\nAC_CACHE_CHECK([for u_int64_t types], ac_cv_have_u_int64_t, [\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[ #include <sys/types.h> ]],\n\t[[ u_int64_t a; a = 1;]])],\n\t[ ac_cv_have_u_int64_t=\"yes\" ], [ ac_cv_have_u_int64_t=\"no\"\n\t])\n])\nif test \"x$ac_cv_have_u_int64_t\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE_U_INT64_T], [1], [define if you have u_int64_t data type])\n\thave_u_int64_t=1\nfi\n\nif (test -z \"$have_u_int64_t\" && \\\n\t   test \"x$ac_cv_header_sys_bitypes_h\" = \"xyes\")\nthen\n    AC_MSG_CHECKING([for u_int64_t type in sys/bitypes.h])\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[ #include <sys/bitypes.h> ]],\n\t[[ u_int64_t a; a = 1]])],\n\t\t[\n\t\t\tAC_DEFINE([HAVE_U_INT64_T])\n\t\t\tAC_MSG_RESULT([yes])\n\t\t], [ AC_MSG_RESULT([no])\n\t])\nfi\n\nif test -z \"$have_u_intxx_t\" ; then\n\tAC_CACHE_CHECK([for uintXX_t types], ac_cv_have_uintxx_t, [\n\t\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <sys/types.h>\n\t\t\t]], [[\n\tuint8_t a;\n\tuint16_t b;\n\tuint32_t c;\n\ta = b = c = 1;\n\t\t\t]])],\n\t\t[ ac_cv_have_uintxx_t=\"yes\" ], [ ac_cv_have_uintxx_t=\"no\"\n\t\t])\n\t])\n\tif test \"x$ac_cv_have_uintxx_t\" = \"xyes\" ; then\n\t\tAC_DEFINE([HAVE_UINTXX_T], [1],\n\t\t\t[define if you have uintxx_t data type])\n\tfi\nfi\n\nif (test -z \"$have_uintxx_t\" && \\\n\t   test \"x$ac_cv_header_stdint_h\" = \"xyes\")\nthen\n    AC_MSG_CHECKING([for uintXX_t types in stdint.h])\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[ #include <stdint.h> ]],\n\t[[ uint8_t a; uint16_t b; uint32_t c; a = b = c = 1;]])],\n\t\t[\n\t\t\tAC_DEFINE([HAVE_UINTXX_T])\n\t\t\tAC_MSG_RESULT([yes])\n\t\t], [ AC_MSG_RESULT([no])\n\t])\nfi\n\nif (test -z \"$have_uintxx_t\" && \\\n\t   test \"x$ac_cv_header_inttypes_h\" = \"xyes\")\nthen\n    AC_MSG_CHECKING([for uintXX_t types in inttypes.h])\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[ #include <inttypes.h> ]],\n\t[[ uint8_t a; uint16_t b; uint32_t c; a = b = c = 1;]])],\n\t\t[\n\t\t\tAC_DEFINE([HAVE_UINTXX_T])\n\t\t\tAC_MSG_RESULT([yes])\n\t\t], [ AC_MSG_RESULT([no])\n\t])\nfi\n\nif (test -z \"$have_u_intxx_t\" || test -z \"$have_intxx_t\" && \\\n\t   test \"x$ac_cv_header_sys_bitypes_h\" = \"xyes\")\nthen\n\tAC_MSG_CHECKING([for intXX_t and u_intXX_t types in sys/bitypes.h])\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <sys/bitypes.h>\n\t\t]], [[\n\t\t\tint8_t a; int16_t b; int32_t c;\n\t\t\tu_int8_t e; u_int16_t f; u_int32_t g;\n\t\t\ta = b = c = e = f = g = 1;\n\t\t]])],\n\t\t[\n\t\t\tAC_DEFINE([HAVE_U_INTXX_T])\n\t\t\tAC_DEFINE([HAVE_INTXX_T])\n\t\t\tAC_MSG_RESULT([yes])\n\t\t], [AC_MSG_RESULT([no])\n\t])\nfi\n\n\nAC_CACHE_CHECK([for u_char], ac_cv_have_u_char, [\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[ #include <sys/types.h> ]],\n\t[[ u_char foo; foo = 125; ]])],\n\t[ ac_cv_have_u_char=\"yes\" ], [ ac_cv_have_u_char=\"no\"\n\t])\n])\nif test \"x$ac_cv_have_u_char\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE_U_CHAR], [1], [define if you have u_char data type])\nfi\n\nAC_CHECK_TYPES([intmax_t, uintmax_t], , , [\n#include <sys/types.h>\n#include <stdint.h>\n])\n\nTYPE_SOCKLEN_T\n\nAC_CHECK_TYPES([sig_atomic_t], , , [#include <signal.h>])\nAC_CHECK_TYPES([fsblkcnt_t, fsfilcnt_t], , , [\n#include <sys/types.h>\n#ifdef HAVE_SYS_BITYPES_H\n#include <sys/bitypes.h>\n#endif\n#ifdef HAVE_SYS_STATFS_H\n#include <sys/statfs.h>\n#endif\n#ifdef HAVE_SYS_STATVFS_H\n#include <sys/statvfs.h>\n#endif\n])\n\nAC_CHECK_MEMBERS([struct statfs.f_flags], [], [], [[\n#include <sys/types.h>\n#ifdef HAVE_SYS_BITYPES_H\n#include <sys/bitypes.h>\n#endif\n#ifdef HAVE_SYS_STATFS_H\n#include <sys/statfs.h>\n#endif\n#ifdef HAVE_SYS_STATVFS_H\n#include <sys/statvfs.h>\n#endif\n#ifdef HAVE_SYS_VFS_H\n#include <sys/vfs.h>\n#endif\n]])\n\n\nAC_CHECK_TYPES([in_addr_t, in_port_t], , ,\n[#include <sys/types.h>\n#include <netinet/in.h>])\n\nAC_CACHE_CHECK([for size_t], ac_cv_have_size_t, [\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[ #include <sys/types.h> ]],\n\t[[ size_t foo; foo = 1235; ]])],\n\t[ ac_cv_have_size_t=\"yes\" ], [ ac_cv_have_size_t=\"no\"\n\t])\n])\nif test \"x$ac_cv_have_size_t\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE_SIZE_T], [1], [define if you have size_t data type])\nfi\n\nAC_CACHE_CHECK([for ssize_t], ac_cv_have_ssize_t, [\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[ #include <sys/types.h> ]],\n\t[[ ssize_t foo; foo = 1235; ]])],\n\t[ ac_cv_have_ssize_t=\"yes\" ], [ ac_cv_have_ssize_t=\"no\"\n\t])\n])\nif test \"x$ac_cv_have_ssize_t\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE_SSIZE_T], [1], [define if you have ssize_t data type])\nfi\n\nAC_CACHE_CHECK([for clock_t], ac_cv_have_clock_t, [\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[ #include <time.h> ]],\n\t[[ clock_t foo; foo = 1235; ]])],\n\t[ ac_cv_have_clock_t=\"yes\" ], [ ac_cv_have_clock_t=\"no\"\n\t])\n])\nif test \"x$ac_cv_have_clock_t\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE_CLOCK_T], [1], [define if you have clock_t data type])\nfi\n\nAC_CACHE_CHECK([for sa_family_t], ac_cv_have_sa_family_t, [\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <sys/socket.h>\n\t\t]], [[ sa_family_t foo; foo = 1235; ]])],\n\t[ ac_cv_have_sa_family_t=\"yes\" ],\n\t[ AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netinet/in.h>\n\t\t]], [[ sa_family_t foo; foo = 1235; ]])],\n\t\t[ ac_cv_have_sa_family_t=\"yes\" ],\n\t\t[ ac_cv_have_sa_family_t=\"no\" ]\n\t)\n\t])\n])\nif test \"x$ac_cv_have_sa_family_t\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE_SA_FAMILY_T], [1],\n\t\t[define if you have sa_family_t data type])\nfi\n\nAC_CACHE_CHECK([for pid_t], ac_cv_have_pid_t, [\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[ #include <sys/types.h> ]],\n\t[[ pid_t foo; foo = 1235; ]])],\n\t[ ac_cv_have_pid_t=\"yes\" ], [ ac_cv_have_pid_t=\"no\"\n\t])\n])\nif test \"x$ac_cv_have_pid_t\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE_PID_T], [1], [define if you have pid_t data type])\nfi\n\nAC_CACHE_CHECK([for mode_t], ac_cv_have_mode_t, [\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[ #include <sys/types.h> ]],\n\t[[ mode_t foo; foo = 1235; ]])],\n\t[ ac_cv_have_mode_t=\"yes\" ], [ ac_cv_have_mode_t=\"no\"\n\t])\n])\nif test \"x$ac_cv_have_mode_t\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE_MODE_T], [1], [define if you have mode_t data type])\nfi\n\n\nAC_CACHE_CHECK([for struct sockaddr_storage], ac_cv_have_struct_sockaddr_storage, [\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <sys/socket.h>\n\t\t]], [[ struct sockaddr_storage s; ]])],\n\t[ ac_cv_have_struct_sockaddr_storage=\"yes\" ],\n\t[ ac_cv_have_struct_sockaddr_storage=\"no\"\n\t])\n])\nif test \"x$ac_cv_have_struct_sockaddr_storage\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE_STRUCT_SOCKADDR_STORAGE], [1],\n\t\t[define if you have struct sockaddr_storage data type])\nfi\n\nAC_CACHE_CHECK([for struct sockaddr_in6], ac_cv_have_struct_sockaddr_in6, [\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <netinet/in.h>\n\t\t]], [[ struct sockaddr_in6 s; s.sin6_family = 0; ]])],\n\t[ ac_cv_have_struct_sockaddr_in6=\"yes\" ],\n\t[ ac_cv_have_struct_sockaddr_in6=\"no\"\n\t])\n])\nif test \"x$ac_cv_have_struct_sockaddr_in6\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE_STRUCT_SOCKADDR_IN6], [1],\n\t\t[define if you have struct sockaddr_in6 data type])\nfi\n\nAC_CACHE_CHECK([for struct in6_addr], ac_cv_have_struct_in6_addr, [\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <netinet/in.h>\n\t\t]], [[ struct in6_addr s; s.s6_addr[0] = 0; ]])],\n\t[ ac_cv_have_struct_in6_addr=\"yes\" ],\n\t[ ac_cv_have_struct_in6_addr=\"no\"\n\t])\n])\nif test \"x$ac_cv_have_struct_in6_addr\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE_STRUCT_IN6_ADDR], [1],\n\t\t[define if you have struct in6_addr data type])\n\ndnl Now check for sin6_scope_id\n\tAC_CHECK_MEMBERS([struct sockaddr_in6.sin6_scope_id], , ,\n\t\t[\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#include <netinet/in.h>\n\t\t])\nfi\n\nAC_CACHE_CHECK([for struct addrinfo], ac_cv_have_struct_addrinfo, [\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netdb.h>\n\t\t]], [[ struct addrinfo s; s.ai_flags = AI_PASSIVE; ]])],\n\t[ ac_cv_have_struct_addrinfo=\"yes\" ],\n\t[ ac_cv_have_struct_addrinfo=\"no\"\n\t])\n])\nif test \"x$ac_cv_have_struct_addrinfo\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE_STRUCT_ADDRINFO], [1],\n\t\t[define if you have struct addrinfo data type])\nfi\n\nAC_CACHE_CHECK([for struct timeval], ac_cv_have_struct_timeval, [\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[ #include <sys/time.h> ]],\n\t[[ struct timeval tv; tv.tv_sec = 1;]])],\n\t[ ac_cv_have_struct_timeval=\"yes\" ],\n\t[ ac_cv_have_struct_timeval=\"no\"\n\t])\n])\nif test \"x$ac_cv_have_struct_timeval\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE_STRUCT_TIMEVAL], [1], [define if you have struct timeval])\n\thave_struct_timeval=1\nfi\n\nAC_CHECK_TYPES([struct timespec])\n\n# We need int64_t or else certain parts of the compile will fail.\nif test \"x$ac_cv_have_int64_t\" = \"xno\" && \\\n\ttest \"x$ac_cv_sizeof_long_int\" != \"x8\" && \\\n\ttest \"x$ac_cv_sizeof_long_long_int\" = \"x0\" ; then\n\techo \"OpenSSH requires int64_t support.  Contact your vendor or install\"\n\techo \"an alternative compiler (I.E., GCC) before continuing.\"\n\techo \"\"\n\texit 1;\nelse\ndnl test snprintf (broken on SCO w/gcc)\n\tAC_RUN_IFELSE(\n\t\t[AC_LANG_SOURCE([[\n#include <stdio.h>\n#include <string.h>\n#ifdef HAVE_SNPRINTF\nmain()\n{\n\tchar buf[50];\n\tchar expected_out[50];\n\tint mazsize = 50 ;\n#if (SIZEOF_LONG_INT == 8)\n\tlong int num = 0x7fffffffffffffff;\n#else\n\tlong long num = 0x7fffffffffffffffll;\n#endif\n\tstrcpy(expected_out, \"9223372036854775807\");\n\tsnprintf(buf, mazsize, \"%lld\", num);\n\tif(strcmp(buf, expected_out) != 0)\n\t\texit(1);\n\texit(0);\n}\n#else\nmain() { exit(0); }\n#endif\n\t\t]])], [ true ], [ AC_DEFINE([BROKEN_SNPRINTF]) ],\n\t\tAC_MSG_WARN([cross compiling: Assuming working snprintf()])\n\t)\nfi\n\ndnl Checks for structure members\nOSSH_CHECK_HEADER_FOR_FIELD([ut_host], [utmp.h], [HAVE_HOST_IN_UTMP])\nOSSH_CHECK_HEADER_FOR_FIELD([ut_host], [utmpx.h], [HAVE_HOST_IN_UTMPX])\nOSSH_CHECK_HEADER_FOR_FIELD([syslen], [utmpx.h], [HAVE_SYSLEN_IN_UTMPX])\nOSSH_CHECK_HEADER_FOR_FIELD([ut_pid], [utmp.h], [HAVE_PID_IN_UTMP])\nOSSH_CHECK_HEADER_FOR_FIELD([ut_type], [utmp.h], [HAVE_TYPE_IN_UTMP])\nOSSH_CHECK_HEADER_FOR_FIELD([ut_type], [utmpx.h], [HAVE_TYPE_IN_UTMPX])\nOSSH_CHECK_HEADER_FOR_FIELD([ut_tv], [utmp.h], [HAVE_TV_IN_UTMP])\nOSSH_CHECK_HEADER_FOR_FIELD([ut_id], [utmp.h], [HAVE_ID_IN_UTMP])\nOSSH_CHECK_HEADER_FOR_FIELD([ut_id], [utmpx.h], [HAVE_ID_IN_UTMPX])\nOSSH_CHECK_HEADER_FOR_FIELD([ut_addr], [utmp.h], [HAVE_ADDR_IN_UTMP])\nOSSH_CHECK_HEADER_FOR_FIELD([ut_addr], [utmpx.h], [HAVE_ADDR_IN_UTMPX])\nOSSH_CHECK_HEADER_FOR_FIELD([ut_addr_v6], [utmp.h], [HAVE_ADDR_V6_IN_UTMP])\nOSSH_CHECK_HEADER_FOR_FIELD([ut_addr_v6], [utmpx.h], [HAVE_ADDR_V6_IN_UTMPX])\nOSSH_CHECK_HEADER_FOR_FIELD([ut_exit], [utmp.h], [HAVE_EXIT_IN_UTMP])\nOSSH_CHECK_HEADER_FOR_FIELD([ut_time], [utmp.h], [HAVE_TIME_IN_UTMP])\nOSSH_CHECK_HEADER_FOR_FIELD([ut_time], [utmpx.h], [HAVE_TIME_IN_UTMPX])\nOSSH_CHECK_HEADER_FOR_FIELD([ut_tv], [utmpx.h], [HAVE_TV_IN_UTMPX])\n\nAC_CHECK_MEMBERS([struct stat.st_blksize])\nAC_CHECK_MEMBERS([struct stat.st_mtim])\nAC_CHECK_MEMBERS([struct stat.st_mtime])\nAC_CHECK_MEMBERS([struct passwd.pw_gecos, struct passwd.pw_class,\nstruct passwd.pw_change, struct passwd.pw_expire],\n[], [], [[\n#include <sys/types.h>\n#include <pwd.h>\n]])\n\nAC_CHECK_MEMBER([struct __res_state.retrans], [], [AC_DEFINE([__res_state], [state],\n\t[Define if we don't have struct __res_state in resolv.h])],\n[[\n#include <stdio.h>\n#if HAVE_SYS_TYPES_H\n# include <sys/types.h>\n#endif\n#include <netinet/in.h>\n#include <arpa/nameser.h>\n#include <resolv.h>\n]])\n\nAC_CACHE_CHECK([for ss_family field in struct sockaddr_storage],\n\t\tac_cv_have_ss_family_in_struct_ss, [\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <sys/socket.h>\n\t\t]], [[ struct sockaddr_storage s; s.ss_family = 1; ]])],\n\t[ ac_cv_have_ss_family_in_struct_ss=\"yes\" ],\n\t[ ac_cv_have_ss_family_in_struct_ss=\"no\" ])\n])\nif test \"x$ac_cv_have_ss_family_in_struct_ss\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE_SS_FAMILY_IN_SS], [1], [Fields in struct sockaddr_storage])\nfi\n\nAC_CACHE_CHECK([for __ss_family field in struct sockaddr_storage],\n\t\tac_cv_have___ss_family_in_struct_ss, [\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <sys/socket.h>\n\t\t]], [[ struct sockaddr_storage s; s.__ss_family = 1; ]])],\n\t[ ac_cv_have___ss_family_in_struct_ss=\"yes\" ],\n\t[ ac_cv_have___ss_family_in_struct_ss=\"no\"\n\t])\n])\nif test \"x$ac_cv_have___ss_family_in_struct_ss\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE___SS_FAMILY_IN_SS], [1],\n\t\t[Fields in struct sockaddr_storage])\nfi\n\ndnl make sure we're using the real structure members and not defines\nAC_CACHE_CHECK([for msg_accrights field in struct msghdr],\n\t\tac_cv_have_accrights_in_msghdr, [\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/uio.h>\n\t\t]], [[\n#ifdef msg_accrights\n#error \"msg_accrights is a macro\"\nexit(1);\n#endif\nstruct msghdr m;\nm.msg_accrights = 0;\nexit(0);\n\t\t]])],\n\t\t[ ac_cv_have_accrights_in_msghdr=\"yes\" ],\n\t\t[ ac_cv_have_accrights_in_msghdr=\"no\" ]\n\t)\n])\nif test \"x$ac_cv_have_accrights_in_msghdr\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE_ACCRIGHTS_IN_MSGHDR], [1],\n\t\t[Define if your system uses access rights style\n\t\tfile descriptor passing])\nfi\n\nAC_MSG_CHECKING([if struct statvfs.f_fsid is integral type])\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <sys/param.h>\n#include <sys/stat.h>\n#ifdef HAVE_SYS_TIME_H\n# include <sys/time.h>\n#endif\n#ifdef HAVE_SYS_MOUNT_H\n#include <sys/mount.h>\n#endif\n#ifdef HAVE_SYS_STATVFS_H\n#include <sys/statvfs.h>\n#endif\n\t]], [[ struct statvfs s; s.f_fsid = 0; ]])],\n\t[ AC_MSG_RESULT([yes]) ],\n\t[ AC_MSG_RESULT([no])\n\n\tAC_MSG_CHECKING([if fsid_t has member val])\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <sys/statvfs.h>\n\t]], [[ fsid_t t; t.val[0] = 0; ]])],\n\t[ AC_MSG_RESULT([yes])\n\t  AC_DEFINE([FSID_HAS_VAL], [1], [fsid_t has member val]) ],\n\t[ AC_MSG_RESULT([no]) ])\n\n\tAC_MSG_CHECKING([if f_fsid has member __val])\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <sys/statvfs.h>\n\t]], [[ fsid_t t; t.__val[0] = 0; ]])],\n\t[ AC_MSG_RESULT([yes])\n\t  AC_DEFINE([FSID_HAS___VAL], [1], [fsid_t has member __val]) ],\n\t[ AC_MSG_RESULT([no]) ])\n])\n\nAC_CACHE_CHECK([for msg_control field in struct msghdr],\n\t\tac_cv_have_control_in_msghdr, [\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <sys/uio.h>\n\t\t]], [[\n#ifdef msg_control\n#error \"msg_control is a macro\"\nexit(1);\n#endif\nstruct msghdr m;\nm.msg_control = 0;\nexit(0);\n\t\t]])],\n\t\t[ ac_cv_have_control_in_msghdr=\"yes\" ],\n\t\t[ ac_cv_have_control_in_msghdr=\"no\" ]\n\t)\n])\nif test \"x$ac_cv_have_control_in_msghdr\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE_CONTROL_IN_MSGHDR], [1],\n\t\t[Define if your system uses ancillary data style\n\t\tfile descriptor passing])\nfi\n\nAC_CACHE_CHECK([if libc defines __progname], ac_cv_libc_defines___progname, [\n\tAC_LINK_IFELSE([AC_LANG_PROGRAM([[]],\n\t\t[[ extern char *__progname; printf(\"%s\", __progname); ]])],\n\t[ ac_cv_libc_defines___progname=\"yes\" ],\n\t[ ac_cv_libc_defines___progname=\"no\"\n\t])\n])\nif test \"x$ac_cv_libc_defines___progname\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE___PROGNAME], [1], [Define if libc defines __progname])\nfi\n\nAC_CACHE_CHECK([whether $CC implements __FUNCTION__], ac_cv_cc_implements___FUNCTION__, [\n\tAC_LINK_IFELSE([AC_LANG_PROGRAM([[ #include <stdio.h> ]],\n\t\t[[ printf(\"%s\", __FUNCTION__); ]])],\n\t[ ac_cv_cc_implements___FUNCTION__=\"yes\" ],\n\t[ ac_cv_cc_implements___FUNCTION__=\"no\"\n\t])\n])\nif test \"x$ac_cv_cc_implements___FUNCTION__\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE___FUNCTION__], [1],\n\t\t[Define if compiler implements __FUNCTION__])\nfi\n\nAC_CACHE_CHECK([whether $CC implements __func__], ac_cv_cc_implements___func__, [\n\tAC_LINK_IFELSE([AC_LANG_PROGRAM([[ #include <stdio.h> ]],\n\t\t[[ printf(\"%s\", __func__); ]])],\n\t[ ac_cv_cc_implements___func__=\"yes\" ],\n\t[ ac_cv_cc_implements___func__=\"no\"\n\t])\n])\nif test \"x$ac_cv_cc_implements___func__\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE___func__], [1], [Define if compiler implements __func__])\nfi\n\nAC_CACHE_CHECK([whether va_copy exists], ac_cv_have_va_copy, [\n\tAC_LINK_IFELSE([AC_LANG_PROGRAM([[\n#include <stdarg.h>\nva_list x,y;\n\t\t]], [[ va_copy(x,y); ]])],\n\t[ ac_cv_have_va_copy=\"yes\" ],\n\t[ ac_cv_have_va_copy=\"no\"\n\t])\n])\nif test \"x$ac_cv_have_va_copy\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE_VA_COPY], [1], [Define if va_copy exists])\nfi\n\nAC_CACHE_CHECK([whether __va_copy exists], ac_cv_have___va_copy, [\n\tAC_LINK_IFELSE([AC_LANG_PROGRAM([[\n#include <stdarg.h>\nva_list x,y;\n\t\t]], [[ __va_copy(x,y); ]])],\n\t[ ac_cv_have___va_copy=\"yes\" ], [ ac_cv_have___va_copy=\"no\"\n\t])\n])\nif test \"x$ac_cv_have___va_copy\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE___VA_COPY], [1], [Define if __va_copy exists])\nfi\n\nAC_CACHE_CHECK([whether getopt has optreset support],\n\t\tac_cv_have_getopt_optreset, [\n\tAC_LINK_IFELSE([AC_LANG_PROGRAM([[ #include <getopt.h> ]],\n\t\t[[ extern int optreset; optreset = 0; ]])],\n\t[ ac_cv_have_getopt_optreset=\"yes\" ],\n\t[ ac_cv_have_getopt_optreset=\"no\"\n\t])\n])\nif test \"x$ac_cv_have_getopt_optreset\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE_GETOPT_OPTRESET], [1],\n\t\t[Define if your getopt(3) defines and uses optreset])\nfi\n\nAC_CACHE_CHECK([if libc defines sys_errlist], ac_cv_libc_defines_sys_errlist, [\n\tAC_LINK_IFELSE([AC_LANG_PROGRAM([[]],\n[[ extern const char *const sys_errlist[]; printf(\"%s\", sys_errlist[0]);]])],\n\t[ ac_cv_libc_defines_sys_errlist=\"yes\" ],\n\t[ ac_cv_libc_defines_sys_errlist=\"no\"\n\t])\n])\nif test \"x$ac_cv_libc_defines_sys_errlist\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE_SYS_ERRLIST], [1],\n\t\t[Define if your system defines sys_errlist[]])\nfi\n\n\nAC_CACHE_CHECK([if libc defines sys_nerr], ac_cv_libc_defines_sys_nerr, [\n\tAC_LINK_IFELSE([AC_LANG_PROGRAM([[]],\n[[ extern int sys_nerr; printf(\"%i\", sys_nerr);]])],\n\t[ ac_cv_libc_defines_sys_nerr=\"yes\" ],\n\t[ ac_cv_libc_defines_sys_nerr=\"no\"\n\t])\n])\nif test \"x$ac_cv_libc_defines_sys_nerr\" = \"xyes\" ; then\n\tAC_DEFINE([HAVE_SYS_NERR], [1], [Define if your system defines sys_nerr])\nfi\n\n# Check libraries needed by DNS fingerprint support\nAC_SEARCH_LIBS([getrrsetbyname], [resolv],\n\t[AC_DEFINE([HAVE_GETRRSETBYNAME], [1],\n\t\t[Define if getrrsetbyname() exists])],\n\t[\n\t\t# Needed by our getrrsetbyname()\n\t\tAC_SEARCH_LIBS([res_query], [resolv])\n\t\tAC_SEARCH_LIBS([dn_expand], [resolv])\n\t\tAC_MSG_CHECKING([if res_query will link])\n\t\tAC_LINK_IFELSE([AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <netinet/in.h>\n#include <arpa/nameser.h>\n#include <netdb.h>\n#include <resolv.h>\n\t\t\t\t]], [[\n\tres_query (0, 0, 0, 0, 0);\n\t\t\t\t]])],\n\t\t    AC_MSG_RESULT([yes]),\n\t\t   [AC_MSG_RESULT([no])\n\t\t    saved_LIBS=\"$LIBS\"\n\t\t    LIBS=\"$LIBS -lresolv\"\n\t\t    AC_MSG_CHECKING([for res_query in -lresolv])\n\t\t    AC_LINK_IFELSE([AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <netinet/in.h>\n#include <arpa/nameser.h>\n#include <netdb.h>\n#include <resolv.h>\n\t\t\t\t]], [[\n\tres_query (0, 0, 0, 0, 0);\n\t\t\t\t]])],\n\t\t\t[AC_MSG_RESULT([yes])],\n\t\t\t[LIBS=\"$saved_LIBS\"\n\t\t\t AC_MSG_RESULT([no])])\n\t\t    ])\n\t\tAC_CHECK_FUNCS([_getshort _getlong])\n\t\tAC_CHECK_DECLS([_getshort, _getlong], , ,\n\t\t    [#include <sys/types.h>\n\t\t    #include <arpa/nameser.h>])\n\t\tAC_CHECK_MEMBER([HEADER.ad],\n\t\t\t[AC_DEFINE([HAVE_HEADER_AD], [1],\n\t\t\t    [Define if HEADER.ad exists in arpa/nameser.h])], ,\n\t\t\t[#include <arpa/nameser.h>])\n\t])\n\nAC_MSG_CHECKING([if struct __res_state _res is an extern])\nAC_LINK_IFELSE([AC_LANG_PROGRAM([[\n#include <stdio.h>\n#if HAVE_SYS_TYPES_H\n# include <sys/types.h>\n#endif\n#include <netinet/in.h>\n#include <arpa/nameser.h>\n#include <resolv.h>\nextern struct __res_state _res;\n\t\t]], [[\nstruct __res_state *volatile p = &_res;  /* force resolution of _res */\nreturn 0;\n\t\t]],)],\n\t\t[AC_MSG_RESULT([yes])\n\t\t AC_DEFINE([HAVE__RES_EXTERN], [1],\n\t\t    [Define if you have struct __res_state _res as an extern])\n\t\t],\n\t\t[ AC_MSG_RESULT([no]) ]\n)\n\n# Check whether user wants SELinux support\nSELINUX_MSG=\"no\"\nLIBSELINUX=\"\"\nAC_ARG_WITH([selinux],\n\t[  --with-selinux          Enable SELinux support],\n\t[ if test \"x$withval\" != \"xno\" ; then\n\t\tsave_LIBS=\"$LIBS\"\n\t\tAC_DEFINE([WITH_SELINUX], [1],\n\t\t\t[Define if you want SELinux support.])\n\t\tSELINUX_MSG=\"yes\"\n\t\tAC_CHECK_HEADER([selinux/selinux.h], ,\n\t\t\tAC_MSG_ERROR([SELinux support requires selinux.h header]))\n\t\tAC_CHECK_LIB([selinux], [setexeccon],\n\t\t\t[ LIBSELINUX=\"-lselinux\"\n\t\t\t  LIBS=\"$LIBS -lselinux\"\n\t\t\t],\n\t\t\tAC_MSG_ERROR([SELinux support requires libselinux library]))\n\t\tSSHLIBS=\"$SSHLIBS $LIBSELINUX\"\n\t\tSSHDLIBS=\"$SSHDLIBS $LIBSELINUX\"\n\t\tAC_CHECK_FUNCS([getseuserbyname get_default_context_with_level])\n\t\tLIBS=\"$save_LIBS\"\n\tfi ]\n)\nAC_SUBST([SSHLIBS])\nAC_SUBST([SSHDLIBS])\n\n# Check whether user wants Kerberos 5 support\nKRB5_MSG=\"no\"\nAC_ARG_WITH([kerberos5],\n\t[  --with-kerberos5=PATH   Enable Kerberos 5 support],\n\t[ if test \"x$withval\" != \"xno\" ; then\n\t\tif test \"x$withval\" = \"xyes\" ; then\n\t\t\tKRB5ROOT=\"/usr/local\"\n\t\telse\n\t\t\tKRB5ROOT=${withval}\n\t\tfi\n\n\t\tAC_DEFINE([KRB5], [1], [Define if you want Kerberos 5 support])\n\t\tKRB5_MSG=\"yes\"\n\n\t\tAC_PATH_TOOL([KRB5CONF], [krb5-config],\n\t\t\t     [$KRB5ROOT/bin/krb5-config],\n\t\t\t     [$KRB5ROOT/bin:$PATH])\n\t\tif test -x $KRB5CONF ; then\n\t\t\tK5CFLAGS=\"`$KRB5CONF --cflags`\"\n\t\t\tK5LIBS=\"`$KRB5CONF --libs`\"\n\t\t\tCPPFLAGS=\"$CPPFLAGS $K5CFLAGS\"\n\n\t\t\tAC_MSG_CHECKING([for gssapi support])\n\t\t\tif $KRB5CONF | grep gssapi >/dev/null ; then\n\t\t\t\tAC_MSG_RESULT([yes])\n\t\t\t\tAC_DEFINE([GSSAPI], [1],\n\t\t\t\t\t[Define this if you want GSSAPI\n\t\t\t\t\tsupport in the version 2 protocol])\n\t\t\t\tGSSCFLAGS=\"`$KRB5CONF --cflags gssapi`\"\n\t\t\t\tGSSLIBS=\"`$KRB5CONF --libs gssapi`\"\n\t\t\t\tCPPFLAGS=\"$CPPFLAGS $GSSCFLAGS\"\n\t\t\telse\n\t\t\t\tAC_MSG_RESULT([no])\n\t\t\tfi\n\t\t\tAC_MSG_CHECKING([whether we are using Heimdal])\n\t\t\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[ #include <krb5.h>\n\t\t\t\t]], [[ char *tmp = heimdal_version; ]])],\n\t\t\t\t[ AC_MSG_RESULT([yes])\n\t\t\t\tAC_DEFINE([HEIMDAL], [1],\n\t\t\t\t[Define this if you are using the Heimdal\n\t\t\t\tversion of Kerberos V5]) ],\n\t\t\t\t[AC_MSG_RESULT([no])\n\t\t\t])\n\t\telse\n\t\t\tCPPFLAGS=\"$CPPFLAGS -I${KRB5ROOT}/include\"\n\t\t\tLDFLAGS=\"$LDFLAGS -L${KRB5ROOT}/lib\"\n\t\t\tAC_MSG_CHECKING([whether we are using Heimdal])\n\t\t\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[ #include <krb5.h>\n\t\t\t\t]], [[ char *tmp = heimdal_version; ]])],\n\t\t\t\t\t[ AC_MSG_RESULT([yes])\n\t\t\t\t\t AC_DEFINE([HEIMDAL])\n\t\t\t\t\t K5LIBS=\"-lkrb5\"\n\t\t\t\t\t K5LIBS=\"$K5LIBS -lcom_err -lasn1\"\n\t\t\t\t\t AC_CHECK_LIB([roken], [net_write],\n\t\t\t\t\t   [K5LIBS=\"$K5LIBS -lroken\"])\n\t\t\t\t\t AC_CHECK_LIB([des], [des_cbc_encrypt],\n\t\t\t\t\t   [K5LIBS=\"$K5LIBS -ldes\"])\n\t\t\t\t       ], [ AC_MSG_RESULT([no])\n\t\t\t\t\t K5LIBS=\"-lkrb5 -lk5crypto -lcom_err\"\n\t\t\t])\n\t\t\tAC_SEARCH_LIBS([dn_expand], [resolv])\n\n\t\t\tAC_CHECK_LIB([gssapi_krb5], [gss_init_sec_context],\n\t\t\t\t[ AC_DEFINE([GSSAPI])\n\t\t\t\t  GSSLIBS=\"-lgssapi_krb5\" ],\n\t\t\t\t[ AC_CHECK_LIB([gssapi], [gss_init_sec_context],\n\t\t\t\t\t[ AC_DEFINE([GSSAPI])\n\t\t\t\t\t  GSSLIBS=\"-lgssapi\" ],\n\t\t\t\t\t[ AC_CHECK_LIB([gss], [gss_init_sec_context],\n\t\t\t\t\t\t[ AC_DEFINE([GSSAPI])\n\t\t\t\t\t\t  GSSLIBS=\"-lgss\" ],\n\t\t\t\t\t\tAC_MSG_WARN([Cannot find any suitable gss-api library - build may fail]))\n\t\t\t\t\t])\n\t\t\t\t])\n\n\t\t\tAC_CHECK_HEADER([gssapi.h], ,\n\t\t\t\t[ unset ac_cv_header_gssapi_h\n\t\t\t\t  CPPFLAGS=\"$CPPFLAGS -I${KRB5ROOT}/include/gssapi\"\n\t\t\t\t  AC_CHECK_HEADERS([gssapi.h], ,\n\t\t\t\t\tAC_MSG_WARN([Cannot find any suitable gss-api header - build may fail])\n\t\t\t\t  )\n\t\t\t\t]\n\t\t\t)\n\n\t\t\toldCPP=\"$CPPFLAGS\"\n\t\t\tCPPFLAGS=\"$CPPFLAGS -I${KRB5ROOT}/include/gssapi\"\n\t\t\tAC_CHECK_HEADER([gssapi_krb5.h], ,\n\t\t\t\t\t[ CPPFLAGS=\"$oldCPP\" ])\n\n\t\tfi\n\t\tif test -n \"${rpath_opt}\" ; then\n\t\t\tLDFLAGS=\"$LDFLAGS ${rpath_opt}${KRB5ROOT}/lib\"\n\t\tfi\n\t\tif test ! -z \"$blibpath\" ; then\n\t\t\tblibpath=\"$blibpath:${KRB5ROOT}/lib\"\n\t\tfi\n\n\t\tAC_CHECK_HEADERS([gssapi.h gssapi/gssapi.h])\n\t\tAC_CHECK_HEADERS([gssapi_krb5.h gssapi/gssapi_krb5.h])\n\t\tAC_CHECK_HEADERS([gssapi_generic.h gssapi/gssapi_generic.h])\n\n\t\tAC_SEARCH_LIBS([k_hasafs], [kafs], [AC_DEFINE([USE_AFS], [1],\n\t\t\t[Define this if you want to use libkafs' AFS support])])\n\n\t\tAC_CHECK_DECLS([GSS_C_NT_HOSTBASED_SERVICE], [], [], [[\n#ifdef HAVE_GSSAPI_H\n# include <gssapi.h>\n#elif defined(HAVE_GSSAPI_GSSAPI_H)\n# include <gssapi/gssapi.h>\n#endif\n\n#ifdef HAVE_GSSAPI_GENERIC_H\n# include <gssapi_generic.h>\n#elif defined(HAVE_GSSAPI_GSSAPI_GENERIC_H)\n# include <gssapi/gssapi_generic.h>\n#endif\n\t\t]])\n\t\tsaved_LIBS=\"$LIBS\"\n\t\tLIBS=\"$LIBS $K5LIBS\"\n\t\tAC_CHECK_FUNCS([krb5_cc_new_unique krb5_get_error_message krb5_free_error_message])\n\t\tLIBS=\"$saved_LIBS\"\n\n\tfi\n\t]\n)\nAC_SUBST([GSSLIBS])\nAC_SUBST([K5LIBS])\n\n# Looking for programs, paths and files\n\nPRIVSEP_PATH=/var/empty\nAC_ARG_WITH([privsep-path],\n\t[  --with-privsep-path=xxx Path for privilege separation chroot (default=/var/empty)],\n\t[\n\t\tif test -n \"$withval\"  &&  test \"x$withval\" != \"xno\"  &&  \\\n\t\t    test \"x${withval}\" != \"xyes\"; then\n\t\t\tPRIVSEP_PATH=$withval\n\t\tfi\n\t]\n)\nAC_SUBST([PRIVSEP_PATH])\n\nAC_ARG_WITH([xauth],\n\t[  --with-xauth=PATH       Specify path to xauth program ],\n\t[\n\t\tif test -n \"$withval\"  &&  test \"x$withval\" != \"xno\"  &&  \\\n\t\t    test \"x${withval}\" != \"xyes\"; then\n\t\t\txauth_path=$withval\n\t\tfi\n\t],\n\t[\n\t\tTestPath=\"$PATH\"\n\t\tTestPath=\"${TestPath}${PATH_SEPARATOR}/usr/X/bin\"\n\t\tTestPath=\"${TestPath}${PATH_SEPARATOR}/usr/bin/X11\"\n\t\tTestPath=\"${TestPath}${PATH_SEPARATOR}/usr/X11R6/bin\"\n\t\tTestPath=\"${TestPath}${PATH_SEPARATOR}/usr/openwin/bin\"\n\t\tAC_PATH_PROG([xauth_path], [xauth], , [$TestPath])\n\t\tif (test ! -z \"$xauth_path\" && test -x \"/usr/openwin/bin/xauth\") ; then\n\t\t\txauth_path=\"/usr/openwin/bin/xauth\"\n\t\tfi\n\t]\n)\n\nSTRIP_OPT=-s\nAC_ARG_ENABLE([strip],\n\t[  --disable-strip         Disable calling strip(1) on install],\n\t[\n\t\tif test \"x$enableval\" = \"xno\" ; then\n\t\t\tSTRIP_OPT=\n\t\tfi\n\t]\n)\nAC_SUBST([STRIP_OPT])\n\nif test -z \"$xauth_path\" ; then\n\tXAUTH_PATH=\"undefined\"\n\tAC_SUBST([XAUTH_PATH])\nelse\n\tAC_DEFINE_UNQUOTED([XAUTH_PATH], [\"$xauth_path\"],\n\t\t[Define if xauth is found in your path])\n\tXAUTH_PATH=$xauth_path\n\tAC_SUBST([XAUTH_PATH])\nfi\n\ndnl # --with-maildir=/path/to/mail gets top priority.\ndnl # if maildir is set in the platform case statement above we use that.\ndnl # Otherwise we run a program to get the dir from system headers.\ndnl # We first look for _PATH_MAILDIR then MAILDIR then _PATH_MAIL\ndnl # If we find _PATH_MAILDIR we do nothing because that is what\ndnl # session.c expects anyway. Otherwise we set to the value found\ndnl # stripping any trailing slash. If for some strage reason our program\ndnl # does not find what it needs, we default to /var/spool/mail.\n# Check for mail directory\nAC_ARG_WITH([maildir],\n    [  --with-maildir=/path/to/mail    Specify your system mail directory],\n    [\n\tif test \"X$withval\" != X  &&  test \"x$withval\" != xno  &&  \\\n\t    test \"x${withval}\" != xyes; then\n\t\tAC_DEFINE_UNQUOTED([MAIL_DIRECTORY], [\"$withval\"],\n            [Set this to your mail directory if you do not have _PATH_MAILDIR])\n\t    fi\n     ],[\n\tif test \"X$maildir\" != \"X\"; then\n\t    AC_DEFINE_UNQUOTED([MAIL_DIRECTORY], [\"$maildir\"])\n\telse\n\t    AC_MSG_CHECKING([Discovering system mail directory])\n\t    AC_RUN_IFELSE(\n\t\t[AC_LANG_PROGRAM([[\n#include <stdio.h>\n#include <string.h>\n#ifdef HAVE_PATHS_H\n#include <paths.h>\n#endif\n#ifdef HAVE_MAILLOCK_H\n#include <maillock.h>\n#endif\n#define DATA \"conftest.maildir\"\n\t]], [[\n\tFILE *fd;\n\tint rc;\n\n\tfd = fopen(DATA,\"w\");\n\tif(fd == NULL)\n\t\texit(1);\n\n#if defined (_PATH_MAILDIR)\n\tif ((rc = fprintf(fd ,\"_PATH_MAILDIR:%s\\n\", _PATH_MAILDIR)) <0)\n\t\texit(1);\n#elif defined (MAILDIR)\n\tif ((rc = fprintf(fd ,\"MAILDIR:%s\\n\", MAILDIR)) <0)\n\t\texit(1);\n#elif defined (_PATH_MAIL)\n\tif ((rc = fprintf(fd ,\"_PATH_MAIL:%s\\n\", _PATH_MAIL)) <0)\n\t\texit(1);\n#else\n\texit (2);\n#endif\n\n\texit(0);\n\t\t]])],\n\t\t[\n\t\t    maildir_what=`awk -F: '{print $1}' conftest.maildir`\n\t\t    maildir=`awk -F: '{print $2}' conftest.maildir \\\n\t\t\t| sed 's|/$||'`\n\t\t    AC_MSG_RESULT([Using: $maildir from $maildir_what])\n\t\t    if test \"x$maildir_what\" != \"x_PATH_MAILDIR\"; then\n\t\t\tAC_DEFINE_UNQUOTED([MAIL_DIRECTORY], [\"$maildir\"])\n\t\t    fi\n\t\t],\n\t\t[\n\t\t    if test \"X$ac_status\" = \"X2\";then\n# our test program didn't find it. Default to /var/spool/mail\n\t\t\tAC_MSG_RESULT([Using: default value of /var/spool/mail])\n\t\t\tAC_DEFINE_UNQUOTED([MAIL_DIRECTORY], [\"/var/spool/mail\"])\n\t\t     else\n\t\t\tAC_MSG_RESULT([*** not found ***])\n\t\t     fi\n\t\t],\n\t\t[\n\t\t\tAC_MSG_WARN([cross compiling: use --with-maildir=/path/to/mail])\n\t\t]\n\t    )\n\tfi\n    ]\n) # maildir\n\nif test ! -z \"$cross_compiling\" && test \"x$cross_compiling\" = \"xyes\"; then\n\tAC_MSG_WARN([cross compiling: Disabling /dev/ptmx test])\n\tdisable_ptmx_check=yes\nfi\nif test -z \"$no_dev_ptmx\" ; then\n\tif test \"x$disable_ptmx_check\" != \"xyes\" ; then\n\t\tAC_CHECK_FILE([\"/dev/ptmx\"],\n\t\t\t[\n\t\t\t\tAC_DEFINE_UNQUOTED([HAVE_DEV_PTMX], [1],\n\t\t\t\t\t[Define if you have /dev/ptmx])\n\t\t\t\thave_dev_ptmx=1\n\t\t\t]\n\t\t)\n\tfi\nfi\n\nif test ! -z \"$cross_compiling\" && test \"x$cross_compiling\" != \"xyes\"; then\n\tAC_CHECK_FILE([\"/dev/ptc\"],\n\t\t[\n\t\t\tAC_DEFINE_UNQUOTED([HAVE_DEV_PTS_AND_PTC], [1],\n\t\t\t\t[Define if you have /dev/ptc])\n\t\t\thave_dev_ptc=1\n\t\t]\n\t)\nelse\n\tAC_MSG_WARN([cross compiling: Disabling /dev/ptc test])\nfi\n\n# Options from here on. Some of these are preset by platform above\nAC_ARG_WITH([mantype],\n\t[  --with-mantype=man|cat|doc  Set man page type],\n\t[\n\t\tcase \"$withval\" in\n\t\tman|cat|doc)\n\t\t\tMANTYPE=$withval\n\t\t\t;;\n\t\t*)\n\t\t\tAC_MSG_ERROR([invalid man type: $withval])\n\t\t\t;;\n\t\tesac\n\t]\n)\nif test -z \"$MANTYPE\"; then\n\tif ${MANDOC} ${srcdir}/ssh.1 >/dev/null 2>&1; then\n\t\tMANTYPE=doc\n\telif ${NROFF} -mdoc ${srcdir}/ssh.1 >/dev/null 2>&1; then\n\t\tMANTYPE=doc\n\telif ${NROFF} -man ${srcdir}/ssh.1 >/dev/null 2>&1; then\n\t\tMANTYPE=man\n\telse\n\t\tMANTYPE=cat\n\tfi\nfi\nAC_SUBST([MANTYPE])\nif test \"$MANTYPE\" = \"doc\"; then\n\tmansubdir=man;\nelse\n\tmansubdir=$MANTYPE;\nfi\nAC_SUBST([mansubdir])\n\n# Check whether to enable MD5 passwords\nMD5_MSG=\"no\"\nAC_ARG_WITH([md5-passwords],\n\t[  --with-md5-passwords    Enable use of MD5 passwords],\n\t[\n\t\tif test \"x$withval\" != \"xno\" ; then\n\t\t\tAC_DEFINE([HAVE_MD5_PASSWORDS], [1],\n\t\t\t\t[Define if you want to allow MD5 passwords])\n\t\t\tMD5_MSG=\"yes\"\n\t\tfi\n\t]\n)\n\n# Whether to disable shadow password support\nAC_ARG_WITH([shadow],\n\t[  --without-shadow        Disable shadow password support],\n\t[\n\t\tif test \"x$withval\" = \"xno\" ; then\n\t\t\tAC_DEFINE([DISABLE_SHADOW])\n\t\t\tdisable_shadow=yes\n\t\tfi\n\t]\n)\n\nif test -z \"$disable_shadow\" ; then\n\tAC_MSG_CHECKING([if the systems has expire shadow information])\n\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <shadow.h>\nstruct spwd sp;\n\t\t]], [[ sp.sp_expire = sp.sp_lstchg = sp.sp_inact = 0; ]])],\n\t\t[ sp_expire_available=yes ], [\n\t])\n\n\tif test \"x$sp_expire_available\" = \"xyes\" ; then\n\t\tAC_MSG_RESULT([yes])\n\t\tAC_DEFINE([HAS_SHADOW_EXPIRE], [1],\n\t\t    [Define if you want to use shadow password expire field])\n\telse\n\t\tAC_MSG_RESULT([no])\n\tfi\nfi\n\n# Use ip address instead of hostname in $DISPLAY\nif test ! -z \"$IPADDR_IN_DISPLAY\" ; then\n\tDISPLAY_HACK_MSG=\"yes\"\n\tAC_DEFINE([IPADDR_IN_DISPLAY], [1],\n\t\t[Define if you need to use IP address\n\t\tinstead of hostname in $DISPLAY])\nelse\n\tDISPLAY_HACK_MSG=\"no\"\n\tAC_ARG_WITH([ipaddr-display],\n\t\t[  --with-ipaddr-display   Use ip address instead of hostname in $DISPLAY],\n\t\t[\n\t\t\tif test \"x$withval\" != \"xno\" ; then\n\t\t\t\tAC_DEFINE([IPADDR_IN_DISPLAY])\n\t\t\t\tDISPLAY_HACK_MSG=\"yes\"\n\t\t\tfi\n\t\t]\n\t)\nfi\n\n# check for /etc/default/login and use it if present.\nAC_ARG_ENABLE([etc-default-login],\n\t[  --disable-etc-default-login Disable using PATH from /etc/default/login [no]],\n\t[ if test \"x$enableval\" = \"xno\"; then\n\t\tAC_MSG_NOTICE([/etc/default/login handling disabled])\n\t\tetc_default_login=no\n\t  else\n\t\tetc_default_login=yes\n\t  fi ],\n\t[ if test ! -z \"$cross_compiling\" && test \"x$cross_compiling\" = \"xyes\";\n\t  then\n\t\tAC_MSG_WARN([cross compiling: not checking /etc/default/login])\n\t\tetc_default_login=no\n\t  else\n\t\tetc_default_login=yes\n\t  fi ]\n)\n\nif test \"x$etc_default_login\" != \"xno\"; then\n\tAC_CHECK_FILE([\"/etc/default/login\"],\n\t    [ external_path_file=/etc/default/login ])\n\tif test \"x$external_path_file\" = \"x/etc/default/login\"; then\n\t\tAC_DEFINE([HAVE_ETC_DEFAULT_LOGIN], [1],\n\t\t\t[Define if your system has /etc/default/login])\n\tfi\nfi\n\ndnl BSD systems use /etc/login.conf so --with-default-path= has no effect\nif test $ac_cv_func_login_getcapbool = \"yes\" && \\\n\ttest $ac_cv_header_login_cap_h = \"yes\" ; then\n\texternal_path_file=/etc/login.conf\nfi\n\n# Whether to mess with the default path\nSERVER_PATH_MSG=\"(default)\"\nAC_ARG_WITH([default-path],\n\t[  --with-default-path=    Specify default $PATH environment for server],\n\t[\n\t\tif test \"x$external_path_file\" = \"x/etc/login.conf\" ; then\n\t\t\tAC_MSG_WARN([\n--with-default-path=PATH has no effect on this system.\nEdit /etc/login.conf instead.])\n\t\telif test \"x$withval\" != \"xno\" ; then\n\t\t\tif test ! -z \"$external_path_file\" ; then\n\t\t\t\tAC_MSG_WARN([\n--with-default-path=PATH will only be used if PATH is not defined in\n$external_path_file .])\n\t\t\tfi\n\t\t\tuser_path=\"$withval\"\n\t\t\tSERVER_PATH_MSG=\"$withval\"\n\t\tfi\n\t],\n\t[ if test \"x$external_path_file\" = \"x/etc/login.conf\" ; then\n\t\tAC_MSG_WARN([Make sure the path to scp is in /etc/login.conf])\n\telse\n\t\tif test ! -z \"$external_path_file\" ; then\n\t\t\tAC_MSG_WARN([\nIf PATH is defined in $external_path_file, ensure the path to scp is included,\notherwise scp will not work.])\n\t\tfi\n\t\tAC_RUN_IFELSE(\n\t\t\t[AC_LANG_PROGRAM([[\n/* find out what STDPATH is */\n#include <stdio.h>\n#ifdef HAVE_PATHS_H\n# include <paths.h>\n#endif\n#ifndef _PATH_STDPATH\n# ifdef _PATH_USERPATH\t/* Irix */\n#  define _PATH_STDPATH _PATH_USERPATH\n# else\n#  define _PATH_STDPATH \"/usr/bin:/bin:/usr/sbin:/sbin\"\n# endif\n#endif\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#define DATA \"conftest.stdpath\"\n\t\t\t]], [[\n\tFILE *fd;\n\tint rc;\n\n\tfd = fopen(DATA,\"w\");\n\tif(fd == NULL)\n\t\texit(1);\n\n\tif ((rc = fprintf(fd,\"%s\", _PATH_STDPATH)) < 0)\n\t\texit(1);\n\n\texit(0);\n\t\t]])],\n\t\t[ user_path=`cat conftest.stdpath` ],\n\t\t[ user_path=\"/usr/bin:/bin:/usr/sbin:/sbin\" ],\n\t\t[ user_path=\"/usr/bin:/bin:/usr/sbin:/sbin\" ]\n\t)\n# make sure $bindir is in USER_PATH so scp will work\n\t\tt_bindir=\"${bindir}\"\n\t\twhile echo \"${t_bindir}\" | egrep '\\$\\{|NONE/' >/dev/null 2>&1; do\n\t\t\tt_bindir=`eval echo ${t_bindir}`\n\t\t\tcase $t_bindir in\n\t\t\t\tNONE/*) t_bindir=`echo $t_bindir | sed \"s~NONE~$prefix~\"` ;;\n\t\t\tesac\n\t\t\tcase $t_bindir in\n\t\t\t\tNONE/*) t_bindir=`echo $t_bindir | sed \"s~NONE~$ac_default_prefix~\"` ;;\n\t\t\tesac\n\t\tdone\n\t\techo $user_path | grep \":$t_bindir\"  > /dev/null 2>&1\n\t\tif test $? -ne 0  ; then\n\t\t\techo $user_path | grep \"^$t_bindir\"  > /dev/null 2>&1\n\t\t\tif test $? -ne 0  ; then\n\t\t\t\tuser_path=$user_path:$t_bindir\n\t\t\t\tAC_MSG_RESULT([Adding $t_bindir to USER_PATH so scp will work])\n\t\t\tfi\n\t\tfi\n\tfi ]\n)\nif test \"x$external_path_file\" != \"x/etc/login.conf\" ; then\n\tAC_DEFINE_UNQUOTED([USER_PATH], [\"$user_path\"], [Specify default $PATH])\n\tAC_SUBST([user_path])\nfi\n\n# Set superuser path separately to user path\nAC_ARG_WITH([superuser-path],\n\t[  --with-superuser-path=  Specify different path for super-user],\n\t[\n\t\tif test -n \"$withval\"  &&  test \"x$withval\" != \"xno\"  &&  \\\n\t\t    test \"x${withval}\" != \"xyes\"; then\n\t\t\tAC_DEFINE_UNQUOTED([SUPERUSER_PATH], [\"$withval\"],\n\t\t\t\t[Define if you want a different $PATH\n\t\t\t\tfor the superuser])\n\t\t\tsuperuser_path=$withval\n\t\tfi\n\t]\n)\n\n\nAC_MSG_CHECKING([if we need to convert IPv4 in IPv6-mapped addresses])\nIPV4_IN6_HACK_MSG=\"no\"\nAC_ARG_WITH(4in6,\n\t[  --with-4in6             Check for and convert IPv4 in IPv6 mapped addresses],\n\t[\n\t\tif test \"x$withval\" != \"xno\" ; then\n\t\t\tAC_MSG_RESULT([yes])\n\t\t\tAC_DEFINE([IPV4_IN_IPV6], [1],\n\t\t\t\t[Detect IPv4 in IPv6 mapped addresses\n\t\t\t\tand treat as IPv4])\n\t\t\tIPV4_IN6_HACK_MSG=\"yes\"\n\t\telse\n\t\t\tAC_MSG_RESULT([no])\n\t\tfi\n\t], [\n\t\tif test \"x$inet6_default_4in6\" = \"xyes\"; then\n\t\t\tAC_MSG_RESULT([yes (default)])\n\t\t\tAC_DEFINE([IPV4_IN_IPV6])\n\t\t\tIPV4_IN6_HACK_MSG=\"yes\"\n\t\telse\n\t\t\tAC_MSG_RESULT([no (default)])\n\t\tfi\n\t]\n)\n\n# Whether to enable BSD auth support\nBSD_AUTH_MSG=no\nAC_ARG_WITH([bsd-auth],\n\t[  --with-bsd-auth         Enable BSD auth support],\n\t[\n\t\tif test \"x$withval\" != \"xno\" ; then\n\t\t\tAC_DEFINE([BSD_AUTH], [1],\n\t\t\t\t[Define if you have BSD auth support])\n\t\t\tBSD_AUTH_MSG=yes\n\t\tfi\n\t]\n)\n\n# Where to place sshd.pid\npiddir=/var/run\n# make sure the directory exists\nif test ! -d $piddir ; then\n\tpiddir=`eval echo ${sysconfdir}`\n\tcase $piddir in\n\t\tNONE/*) piddir=`echo $piddir | sed \"s~NONE~$ac_default_prefix~\"` ;;\n\tesac\nfi\n\nAC_ARG_WITH([pid-dir],\n\t[  --with-pid-dir=PATH     Specify location of sshd.pid file],\n\t[\n\t\tif test -n \"$withval\"  &&  test \"x$withval\" != \"xno\"  &&  \\\n\t\t    test \"x${withval}\" != \"xyes\"; then\n\t\t\tpiddir=$withval\n\t\t\tif test ! -d $piddir ; then\n\t\t\tAC_MSG_WARN([** no $piddir directory on this system **])\n\t\t\tfi\n\t\tfi\n\t]\n)\n\nAC_DEFINE_UNQUOTED([_PATH_SSH_PIDDIR], [\"$piddir\"],\n\t[Specify location of ssh.pid])\nAC_SUBST([piddir])\n\ndnl allow user to disable some login recording features\nAC_ARG_ENABLE([lastlog],\n\t[  --disable-lastlog       disable use of lastlog even if detected [no]],\n\t[\n\t\tif test \"x$enableval\" = \"xno\" ; then\n\t\t\tAC_DEFINE([DISABLE_LASTLOG])\n\t\tfi\n\t]\n)\nAC_ARG_ENABLE([utmp],\n\t[  --disable-utmp          disable use of utmp even if detected [no]],\n\t[\n\t\tif test \"x$enableval\" = \"xno\" ; then\n\t\t\tAC_DEFINE([DISABLE_UTMP])\n\t\tfi\n\t]\n)\nAC_ARG_ENABLE([utmpx],\n\t[  --disable-utmpx         disable use of utmpx even if detected [no]],\n\t[\n\t\tif test \"x$enableval\" = \"xno\" ; then\n\t\t\tAC_DEFINE([DISABLE_UTMPX], [1],\n\t\t\t\t[Define if you don't want to use utmpx])\n\t\tfi\n\t]\n)\nAC_ARG_ENABLE([wtmp],\n\t[  --disable-wtmp          disable use of wtmp even if detected [no]],\n\t[\n\t\tif test \"x$enableval\" = \"xno\" ; then\n\t\t\tAC_DEFINE([DISABLE_WTMP])\n\t\tfi\n\t]\n)\nAC_ARG_ENABLE([wtmpx],\n\t[  --disable-wtmpx         disable use of wtmpx even if detected [no]],\n\t[\n\t\tif test \"x$enableval\" = \"xno\" ; then\n\t\t\tAC_DEFINE([DISABLE_WTMPX], [1],\n\t\t\t\t[Define if you don't want to use wtmpx])\n\t\tfi\n\t]\n)\nAC_ARG_ENABLE([libutil],\n\t[  --disable-libutil       disable use of libutil (login() etc.) [no]],\n\t[\n\t\tif test \"x$enableval\" = \"xno\" ; then\n\t\t\tAC_DEFINE([DISABLE_LOGIN])\n\t\tfi\n\t]\n)\nAC_ARG_ENABLE([pututline],\n\t[  --disable-pututline     disable use of pututline() etc. ([uw]tmp) [no]],\n\t[\n\t\tif test \"x$enableval\" = \"xno\" ; then\n\t\t\tAC_DEFINE([DISABLE_PUTUTLINE], [1],\n\t\t\t\t[Define if you don't want to use pututline()\n\t\t\t\tetc. to write [uw]tmp])\n\t\tfi\n\t]\n)\nAC_ARG_ENABLE([pututxline],\n\t[  --disable-pututxline    disable use of pututxline() etc. ([uw]tmpx) [no]],\n\t[\n\t\tif test \"x$enableval\" = \"xno\" ; then\n\t\t\tAC_DEFINE([DISABLE_PUTUTXLINE], [1],\n\t\t\t\t[Define if you don't want to use pututxline()\n\t\t\t\tetc. to write [uw]tmpx])\n\t\tfi\n\t]\n)\nAC_ARG_WITH([lastlog],\n  [  --with-lastlog=FILE|DIR specify lastlog location [common locations]],\n\t[\n\t\tif test \"x$withval\" = \"xno\" ; then\n\t\t\tAC_DEFINE([DISABLE_LASTLOG])\n\t\telif test -n \"$withval\"  &&  test \"x${withval}\" != \"xyes\"; then\n\t\t\tconf_lastlog_location=$withval\n\t\tfi\n\t]\n)\n\ndnl lastlog, [uw]tmpx? detection\ndnl  NOTE: set the paths in the platform section to avoid the\ndnl   need for command-line parameters\ndnl lastlog and [uw]tmp are subject to a file search if all else fails\n\ndnl lastlog detection\ndnl  NOTE: the code itself will detect if lastlog is a directory\nAC_MSG_CHECKING([if your system defines LASTLOG_FILE])\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <utmp.h>\n#ifdef HAVE_LASTLOG_H\n#  include <lastlog.h>\n#endif\n#ifdef HAVE_PATHS_H\n#  include <paths.h>\n#endif\n#ifdef HAVE_LOGIN_H\n# include <login.h>\n#endif\n\t]], [[ char *lastlog = LASTLOG_FILE; ]])],\n\t\t[ AC_MSG_RESULT([yes]) ],\n\t\t[\n\t\tAC_MSG_RESULT([no])\n\t\tAC_MSG_CHECKING([if your system defines _PATH_LASTLOG])\n\t\tAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <utmp.h>\n#ifdef HAVE_LASTLOG_H\n#  include <lastlog.h>\n#endif\n#ifdef HAVE_PATHS_H\n#  include <paths.h>\n#endif\n\t\t]], [[ char *lastlog = _PATH_LASTLOG; ]])],\n\t\t[ AC_MSG_RESULT([yes]) ],\n\t\t[\n\t\t\tAC_MSG_RESULT([no])\n\t\t\tsystem_lastlog_path=no\n\t\t])\n])\n\nif test -z \"$conf_lastlog_location\"; then\n\tif test x\"$system_lastlog_path\" = x\"no\" ; then\n\t\tfor f in /var/log/lastlog /usr/adm/lastlog /var/adm/lastlog /etc/security/lastlog ; do\n\t\t\t\tif (test -d \"$f\" || test -f \"$f\") ; then\n\t\t\t\t\tconf_lastlog_location=$f\n\t\t\t\tfi\n\t\tdone\n\t\tif test -z \"$conf_lastlog_location\"; then\n\t\t\tAC_MSG_WARN([** Cannot find lastlog **])\n\t\t\tdnl Don't define DISABLE_LASTLOG - that means we don't try wtmp/wtmpx\n\t\tfi\n\tfi\nfi\n\nif test -n \"$conf_lastlog_location\"; then\n\tAC_DEFINE_UNQUOTED([CONF_LASTLOG_FILE], [\"$conf_lastlog_location\"],\n\t\t[Define if you want to specify the path to your lastlog file])\nfi\n\ndnl utmp detection\nAC_MSG_CHECKING([if your system defines UTMP_FILE])\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <utmp.h>\n#ifdef HAVE_PATHS_H\n#  include <paths.h>\n#endif\n\t]], [[ char *utmp = UTMP_FILE; ]])],\n\t[ AC_MSG_RESULT([yes]) ],\n\t[ AC_MSG_RESULT([no])\n\t  system_utmp_path=no\n])\nif test -z \"$conf_utmp_location\"; then\n\tif test x\"$system_utmp_path\" = x\"no\" ; then\n\t\tfor f in /etc/utmp /usr/adm/utmp /var/run/utmp; do\n\t\t\tif test -f $f ; then\n\t\t\t\tconf_utmp_location=$f\n\t\t\tfi\n\t\tdone\n\t\tif test -z \"$conf_utmp_location\"; then\n\t\t\tAC_DEFINE([DISABLE_UTMP])\n\t\tfi\n\tfi\nfi\nif test -n \"$conf_utmp_location\"; then\n\tAC_DEFINE_UNQUOTED([CONF_UTMP_FILE], [\"$conf_utmp_location\"],\n\t\t[Define if you want to specify the path to your utmp file])\nfi\n\ndnl wtmp detection\nAC_MSG_CHECKING([if your system defines WTMP_FILE])\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <utmp.h>\n#ifdef HAVE_PATHS_H\n#  include <paths.h>\n#endif\n\t]], [[ char *wtmp = WTMP_FILE; ]])],\n\t[ AC_MSG_RESULT([yes]) ],\n\t[ AC_MSG_RESULT([no])\n\t  system_wtmp_path=no\n])\nif test -z \"$conf_wtmp_location\"; then\n\tif test x\"$system_wtmp_path\" = x\"no\" ; then\n\t\tfor f in /usr/adm/wtmp /var/log/wtmp; do\n\t\t\tif test -f $f ; then\n\t\t\t\tconf_wtmp_location=$f\n\t\t\tfi\n\t\tdone\n\t\tif test -z \"$conf_wtmp_location\"; then\n\t\t\tAC_DEFINE([DISABLE_WTMP])\n\t\tfi\n\tfi\nfi\nif test -n \"$conf_wtmp_location\"; then\n\tAC_DEFINE_UNQUOTED([CONF_WTMP_FILE], [\"$conf_wtmp_location\"],\n\t\t[Define if you want to specify the path to your wtmp file])\nfi\n\ndnl wtmpx detection\nAC_MSG_CHECKING([if your system defines WTMPX_FILE])\nAC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n#include <sys/types.h>\n#include <utmp.h>\n#ifdef HAVE_UTMPX_H\n#include <utmpx.h>\n#endif\n#ifdef HAVE_PATHS_H\n#  include <paths.h>\n#endif\n\t]], [[ char *wtmpx = WTMPX_FILE; ]])],\n\t[ AC_MSG_RESULT([yes]) ],\n\t[ AC_MSG_RESULT([no])\n\t  system_wtmpx_path=no\n])\nif test -z \"$conf_wtmpx_location\"; then\n\tif test x\"$system_wtmpx_path\" = x\"no\" ; then\n\t\tAC_DEFINE([DISABLE_WTMPX])\n\tfi\nelse\n\tAC_DEFINE_UNQUOTED([CONF_WTMPX_FILE], [\"$conf_wtmpx_location\"],\n\t\t[Define if you want to specify the path to your wtmpx file])\nfi\n\n\nif test ! -z \"$blibpath\" ; then\n\tLDFLAGS=\"$LDFLAGS $blibflags$blibpath\"\n\tAC_MSG_WARN([Please check and edit blibpath in LDFLAGS in Makefile])\nfi\n\nAC_CHECK_MEMBER([struct lastlog.ll_line], [], [\n    if test x$SKIP_DISABLE_LASTLOG_DEFINE != \"xyes\" ; then\n\tAC_DEFINE([DISABLE_LASTLOG])\n    fi\n\t], [\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#ifdef HAVE_UTMP_H\n#include <utmp.h>\n#endif\n#ifdef HAVE_UTMPX_H\n#include <utmpx.h>\n#endif\n#ifdef HAVE_LASTLOG_H\n#include <lastlog.h>\n#endif\n\t])\n\nAC_CHECK_MEMBER([struct utmp.ut_line], [], [\n\tAC_DEFINE([DISABLE_UTMP])\n\tAC_DEFINE([DISABLE_WTMP])\n\t], [\n#ifdef HAVE_SYS_TYPES_H\n#include <sys/types.h>\n#endif\n#ifdef HAVE_UTMP_H\n#include <utmp.h>\n#endif\n#ifdef HAVE_UTMPX_H\n#include <utmpx.h>\n#endif\n#ifdef HAVE_LASTLOG_H\n#include <lastlog.h>\n#endif\n\t])\n\ndnl Adding -Werror to CFLAGS early prevents configure tests from running.\ndnl Add now.\nCFLAGS=\"$CFLAGS $werror_flags\"\n\nif test \"x$ac_cv_func_getaddrinfo\" != \"xyes\" ; then\n\tTEST_SSH_IPV6=no\nelse\n\tTEST_SSH_IPV6=yes\nfi\nAC_CHECK_DECL([BROKEN_GETADDRINFO],  [TEST_SSH_IPV6=no])\nAC_SUBST([TEST_SSH_IPV6], [$TEST_SSH_IPV6])\nAC_SUBST([TEST_SSH_UTF8], [$TEST_SSH_UTF8])\nAC_SUBST([TEST_MALLOC_OPTIONS], [$TEST_MALLOC_OPTIONS])\nAC_SUBST([UNSUPPORTED_ALGORITHMS], [$unsupported_algorithms])\nAC_SUBST([DEPEND], [$(cat $srcdir/.depend)])\n\nCFLAGS=\"${CFLAGS} ${CFLAGS_AFTER}\"\nLDFLAGS=\"${LDFLAGS} ${LDFLAGS_AFTER}\"\n\nAC_EXEEXT\nAC_CONFIG_FILES([Makefile buildpkg.sh opensshd.init openssh.xml \\\n\topenbsd-compat/Makefile openbsd-compat/regress/Makefile \\\n\tsurvey.sh])\nAC_OUTPUT\n\n# Print summary of options\n\n# Someone please show me a better way :)\nA=`eval echo ${prefix}` ; A=`eval echo ${A}`\nB=`eval echo ${bindir}` ; B=`eval echo ${B}`\nC=`eval echo ${sbindir}` ; C=`eval echo ${C}`\nD=`eval echo ${sysconfdir}` ; D=`eval echo ${D}`\nE=`eval echo ${libexecdir}/ssh-askpass` ; E=`eval echo ${E}`\nF=`eval echo ${mandir}/${mansubdir}X` ; F=`eval echo ${F}`\nG=`eval echo ${piddir}` ; G=`eval echo ${G}`\nH=`eval echo ${PRIVSEP_PATH}` ; H=`eval echo ${H}`\nI=`eval echo ${user_path}` ; I=`eval echo ${I}`\nJ=`eval echo ${superuser_path}` ; J=`eval echo ${J}`\n\necho \"\"\necho \"OpenSSH has been configured with the following options:\"\necho \"                     User binaries: $B\"\necho \"                   System binaries: $C\"\necho \"               Configuration files: $D\"\necho \"                   Askpass program: $E\"\necho \"                      Manual pages: $F\"\necho \"                          PID file: $G\"\necho \"  Privilege separation chroot path: $H\"\nif test \"x$external_path_file\" = \"x/etc/login.conf\" ; then\necho \"   At runtime, sshd will use the path defined in $external_path_file\"\necho \"   Make sure the path to scp is present, otherwise scp will not work\"\nelse\necho \"            sshd default user PATH: $I\"\n\tif test ! -z \"$external_path_file\"; then\necho \"   (If PATH is set in $external_path_file it will be used instead. If\"\necho \"   used, ensure the path to scp is present, otherwise scp will not work.)\"\n\tfi\nfi\nif test ! -z \"$superuser_path\" ; then\necho \"          sshd superuser user PATH: $J\"\nfi\necho \"                    Manpage format: $MANTYPE\"\necho \"                       PAM support: $PAM_MSG\"\necho \"                   OSF SIA support: $SIA_MSG\"\necho \"                 KerberosV support: $KRB5_MSG\"\necho \"                   SELinux support: $SELINUX_MSG\"\necho \"              MD5 password support: $MD5_MSG\"\necho \"                   libedit support: $LIBEDIT_MSG\"\necho \"                   libldns support: $LDNS_MSG\"\necho \"  Solaris process contract support: $SPC_MSG\"\necho \"           Solaris project support: $SP_MSG\"\necho \"         Solaris privilege support: $SPP_MSG\"\necho \"       IP address in \\$DISPLAY hack: $DISPLAY_HACK_MSG\"\necho \"           Translate v4 in v6 hack: $IPV4_IN6_HACK_MSG\"\necho \"                  BSD Auth support: $BSD_AUTH_MSG\"\necho \"              Random number source: $RAND_MSG\"\necho \"             Privsep sandbox style: $SANDBOX_STYLE\"\n\necho \"\"\n\necho \"              Host: ${host}\"\necho \"          Compiler: ${CC}\"\necho \"    Compiler flags: ${CFLAGS}\"\necho \"Preprocessor flags: ${CPPFLAGS}\"\necho \"      Linker flags: ${LDFLAGS}\"\necho \"         Libraries: ${LIBS}\"\nif test ! -z \"${SSHDLIBS}\"; then\necho \"         +for sshd: ${SSHDLIBS}\"\nfi\nif test ! -z \"${SSHLIBS}\"; then\necho \"          +for ssh: ${SSHLIBS}\"\nfi\n\necho \"\"\n\nif test \"x$MAKE_PACKAGE_SUPPORTED\" = \"xyes\" ; then\n\techo \"SVR4 style packages are supported with \\\"make package\\\"\"\n\techo \"\"\nfi\n\nif test \"x$PAM_MSG\" = \"xyes\" ; then\n\techo \"PAM is enabled. You may need to install a PAM control file \"\n\techo \"for sshd, otherwise password authentication may fail. \"\n\techo \"Example PAM control files can be found in the contrib/ \"\n\techo \"subdirectory\"\n\techo \"\"\nfi\n\nif test ! -z \"$NO_PEERCHECK\" ; then\n\techo \"WARNING: the operating system that you are using does not\"\n\techo \"appear to support getpeereid(), getpeerucred() or the\"\n\techo \"SO_PEERCRED getsockopt() option. These facilities are used to\"\n\techo \"enforce security checks to prevent unauthorised connections to\"\n\techo \"ssh-agent. Their absence increases the risk that a malicious\"\n\techo \"user can connect to your agent.\"\n\techo \"\"\nfi\n\nif test \"$AUDIT_MODULE\" = \"bsm\" ; then\n\techo \"WARNING: BSM audit support is currently considered EXPERIMENTAL.\"\n\techo \"See the Solaris section in README.platform for details.\"\nfi\n",
        "/tmp/vanessa/spack-stage/spack-stage-openssh-8.1p1-zfi2cra5nntkevt3zbx3qsr4hgihce6g/spack-src/ssh-pkcs11.c": "/* $OpenBSD: ssh-pkcs11.c,v 1.46 2019/10/01 10:22:53 djm Exp $ */\n/*\n * Copyright (c) 2010 Markus Friedl.  All rights reserved.\n * Copyright (c) 2014 Pedro Martelletto. All rights reserved.\n *\n * Permission to use, copy, modify, and distribute this software for any\n * purpose with or without fee is hereby granted, provided that the above\n * copyright notice and this permission notice appear in all copies.\n *\n * THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n */\n\n#include \"includes.h\"\n\n#ifdef ENABLE_PKCS11\n\n#ifdef HAVE_SYS_TIME_H\n# include <sys/time.h>\n#endif\n\n#include <sys/types.h>\n#include <stdarg.h>\n#include <stdio.h>\n\n#include <ctype.h>\n#include <string.h>\n#include <dlfcn.h>\n\n#include \"openbsd-compat/sys-queue.h\"\n#include \"openbsd-compat/openssl-compat.h\"\n\n#include <openssl/ecdsa.h>\n#include <openssl/x509.h>\n#include <openssl/err.h>\n\n#define CRYPTOKI_COMPAT\n#include \"pkcs11.h\"\n\n#include \"log.h\"\n#include \"misc.h\"\n#include \"sshkey.h\"\n#include \"ssh-pkcs11.h\"\n#include \"xmalloc.h\"\n\nstruct pkcs11_slotinfo {\n\tCK_TOKEN_INFO\t\ttoken;\n\tCK_SESSION_HANDLE\tsession;\n\tint\t\t\tlogged_in;\n};\n\nstruct pkcs11_provider {\n\tchar\t\t\t*name;\n\tvoid\t\t\t*handle;\n\tCK_FUNCTION_LIST\t*function_list;\n\tCK_INFO\t\t\tinfo;\n\tCK_ULONG\t\tnslots;\n\tCK_SLOT_ID\t\t*slotlist;\n\tstruct pkcs11_slotinfo\t*slotinfo;\n\tint\t\t\tvalid;\n\tint\t\t\trefcount;\n\tTAILQ_ENTRY(pkcs11_provider) next;\n};\n\nTAILQ_HEAD(, pkcs11_provider) pkcs11_providers;\n\nstruct pkcs11_key {\n\tstruct pkcs11_provider\t*provider;\n\tCK_ULONG\t\tslotidx;\n\tchar\t\t\t*keyid;\n\tint\t\t\tkeyid_len;\n};\n\nint pkcs11_interactive = 0;\n\n#ifdef HAVE_EC_KEY_METHOD_NEW\nstatic void\nossl_error(const char *msg)\n{\n\tunsigned long    e;\n\n\terror(\"%s: %s\", __func__, msg);\n\twhile ((e = ERR_get_error()) != 0)\n\t\terror(\"%s: libcrypto error: %.100s\", __func__,\n\t\t    ERR_error_string(e, NULL));\n}\n#endif /* HAVE_EC_KEY_METHOD_NEW */\n\nint\npkcs11_init(int interactive)\n{\n\tpkcs11_interactive = interactive;\n\tTAILQ_INIT(&pkcs11_providers);\n\treturn (0);\n}\n\n/*\n * finalize a provider shared library, it's no longer usable.\n * however, there might still be keys referencing this provider,\n * so the actual freeing of memory is handled by pkcs11_provider_unref().\n * this is called when a provider gets unregistered.\n */\nstatic void\npkcs11_provider_finalize(struct pkcs11_provider *p)\n{\n\tCK_RV rv;\n\tCK_ULONG i;\n\n\tdebug(\"pkcs11_provider_finalize: %p refcount %d valid %d\",\n\t    p, p->refcount, p->valid);\n\tif (!p->valid)\n\t\treturn;\n\tfor (i = 0; i < p->nslots; i++) {\n\t\tif (p->slotinfo[i].session &&\n\t\t    (rv = p->function_list->C_CloseSession(\n\t\t    p->slotinfo[i].session)) != CKR_OK)\n\t\t\terror(\"C_CloseSession failed: %lu\", rv);\n\t}\n\tif ((rv = p->function_list->C_Finalize(NULL)) != CKR_OK)\n\t\terror(\"C_Finalize failed: %lu\", rv);\n\tp->valid = 0;\n\tp->function_list = NULL;\n\tdlclose(p->handle);\n}\n\n/*\n * remove a reference to the provider.\n * called when a key gets destroyed or when the provider is unregistered.\n */\nstatic void\npkcs11_provider_unref(struct pkcs11_provider *p)\n{\n\tdebug(\"pkcs11_provider_unref: %p refcount %d\", p, p->refcount);\n\tif (--p->refcount <= 0) {\n\t\tif (p->valid)\n\t\t\terror(\"pkcs11_provider_unref: %p still valid\", p);\n\t\tfree(p->name);\n\t\tfree(p->slotlist);\n\t\tfree(p->slotinfo);\n\t\tfree(p);\n\t}\n}\n\n/* unregister all providers, keys might still point to the providers */\nvoid\npkcs11_terminate(void)\n{\n\tstruct pkcs11_provider *p;\n\n\twhile ((p = TAILQ_FIRST(&pkcs11_providers)) != NULL) {\n\t\tTAILQ_REMOVE(&pkcs11_providers, p, next);\n\t\tpkcs11_provider_finalize(p);\n\t\tpkcs11_provider_unref(p);\n\t}\n}\n\n/* lookup provider by name */\nstatic struct pkcs11_provider *\npkcs11_provider_lookup(char *provider_id)\n{\n\tstruct pkcs11_provider *p;\n\n\tTAILQ_FOREACH(p, &pkcs11_providers, next) {\n\t\tdebug(\"check %p %s\", p, p->name);\n\t\tif (!strcmp(provider_id, p->name))\n\t\t\treturn (p);\n\t}\n\treturn (NULL);\n}\n\n/* unregister provider by name */\nint\npkcs11_del_provider(char *provider_id)\n{\n\tstruct pkcs11_provider *p;\n\n\tif ((p = pkcs11_provider_lookup(provider_id)) != NULL) {\n\t\tTAILQ_REMOVE(&pkcs11_providers, p, next);\n\t\tpkcs11_provider_finalize(p);\n\t\tpkcs11_provider_unref(p);\n\t\treturn (0);\n\t}\n\treturn (-1);\n}\n\nstatic RSA_METHOD *rsa_method;\nstatic int rsa_idx = 0;\n#ifdef HAVE_EC_KEY_METHOD_NEW\nstatic EC_KEY_METHOD *ec_key_method;\nstatic int ec_key_idx = 0;\n#endif\n\n/* release a wrapped object */\nstatic void\npkcs11_k11_free(void *parent, void *ptr, CRYPTO_EX_DATA *ad, int idx,\n    long argl, void *argp)\n{\n\tstruct pkcs11_key\t*k11 = ptr;\n\n\tdebug(\"%s: parent %p ptr %p idx %d\", __func__, parent, ptr, idx);\n\tif (k11 == NULL)\n\t\treturn;\n\tif (k11->provider)\n\t\tpkcs11_provider_unref(k11->provider);\n\tfree(k11->keyid);\n\tfree(k11);\n}\n\n/* find a single 'obj' for given attributes */\nstatic int\npkcs11_find(struct pkcs11_provider *p, CK_ULONG slotidx, CK_ATTRIBUTE *attr,\n    CK_ULONG nattr, CK_OBJECT_HANDLE *obj)\n{\n\tCK_FUNCTION_LIST\t*f;\n\tCK_SESSION_HANDLE\tsession;\n\tCK_ULONG\t\tnfound = 0;\n\tCK_RV\t\t\trv;\n\tint\t\t\tret = -1;\n\n\tf = p->function_list;\n\tsession = p->slotinfo[slotidx].session;\n\tif ((rv = f->C_FindObjectsInit(session, attr, nattr)) != CKR_OK) {\n\t\terror(\"C_FindObjectsInit failed (nattr %lu): %lu\", nattr, rv);\n\t\treturn (-1);\n\t}\n\tif ((rv = f->C_FindObjects(session, obj, 1, &nfound)) != CKR_OK ||\n\t    nfound != 1) {\n\t\tdebug(\"C_FindObjects failed (nfound %lu nattr %lu): %lu\",\n\t\t    nfound, nattr, rv);\n\t} else\n\t\tret = 0;\n\tif ((rv = f->C_FindObjectsFinal(session)) != CKR_OK)\n\t\terror(\"C_FindObjectsFinal failed: %lu\", rv);\n\treturn (ret);\n}\n\nstatic int\npkcs11_login_slot(struct pkcs11_provider *provider, struct pkcs11_slotinfo *si,\n    CK_USER_TYPE type)\n{\n\tchar\t\t\t*pin = NULL, prompt[1024];\n\tCK_RV\t\t\t rv;\n\n\tif (provider == NULL || si == NULL || !provider->valid) {\n\t\terror(\"no pkcs11 (valid) provider found\");\n\t\treturn (-1);\n\t}\n\n\tif (!pkcs11_interactive) {\n\t\terror(\"need pin entry%s\",\n\t\t    (si->token.flags & CKF_PROTECTED_AUTHENTICATION_PATH) ?\n\t\t    \" on reader keypad\" : \"\");\n\t\treturn (-1);\n\t}\n\tif (si->token.flags & CKF_PROTECTED_AUTHENTICATION_PATH)\n\t\tverbose(\"Deferring PIN entry to reader keypad.\");\n\telse {\n\t\tsnprintf(prompt, sizeof(prompt), \"Enter PIN for '%s': \",\n\t\t    si->token.label);\n\t\tif ((pin = read_passphrase(prompt, RP_ALLOW_EOF)) == NULL) {\n\t\t\tdebug(\"%s: no pin specified\", __func__);\n\t\t\treturn (-1);\t/* bail out */\n\t\t}\n\t}\n\trv = provider->function_list->C_Login(si->session, type, (u_char *)pin,\n\t    (pin != NULL) ? strlen(pin) : 0);\n\tif (pin != NULL)\n\t\tfreezero(pin, strlen(pin));\n\tif (rv != CKR_OK && rv != CKR_USER_ALREADY_LOGGED_IN) {\n\t\terror(\"C_Login failed: %lu\", rv);\n\t\treturn (-1);\n\t}\n\tsi->logged_in = 1;\n\treturn (0);\n}\n\nstatic int\npkcs11_login(struct pkcs11_key *k11, CK_USER_TYPE type)\n{\n\tif (k11 == NULL || k11->provider == NULL || !k11->provider->valid) {\n\t\terror(\"no pkcs11 (valid) provider found\");\n\t\treturn (-1);\n\t}\n\n\treturn pkcs11_login_slot(k11->provider,\n\t    &k11->provider->slotinfo[k11->slotidx], type);\n}\n\n\nstatic int\npkcs11_check_obj_bool_attrib(struct pkcs11_key *k11, CK_OBJECT_HANDLE obj,\n    CK_ATTRIBUTE_TYPE type, int *val)\n{\n\tstruct pkcs11_slotinfo\t*si;\n\tCK_FUNCTION_LIST\t*f;\n\tCK_BBOOL\t\tflag = 0;\n\tCK_ATTRIBUTE\t\tattr;\n\tCK_RV\t\t\t rv;\n\n\t*val = 0;\n\n\tif (!k11->provider || !k11->provider->valid) {\n\t\terror(\"no pkcs11 (valid) provider found\");\n\t\treturn (-1);\n\t}\n\n\tf = k11->provider->function_list;\n\tsi = &k11->provider->slotinfo[k11->slotidx];\n\n\tattr.type = type;\n\tattr.pValue = &flag;\n\tattr.ulValueLen = sizeof(flag);\n\n\trv = f->C_GetAttributeValue(si->session, obj, &attr, 1);\n\tif (rv != CKR_OK) {\n\t\terror(\"C_GetAttributeValue failed: %lu\", rv);\n\t\treturn (-1);\n\t}\n\t*val = flag != 0;\n\tdebug(\"%s: provider %p slot %lu object %lu: attrib %lu = %d\",\n\t    __func__, k11->provider, k11->slotidx, obj, type, *val);\n\treturn (0);\n}\n\nstatic int\npkcs11_get_key(struct pkcs11_key *k11, CK_MECHANISM_TYPE mech_type)\n{\n\tstruct pkcs11_slotinfo\t*si;\n\tCK_FUNCTION_LIST\t*f;\n\tCK_OBJECT_HANDLE\t obj;\n\tCK_RV\t\t\t rv;\n\tCK_OBJECT_CLASS\t\t private_key_class;\n\tCK_BBOOL\t\t true_val;\n\tCK_MECHANISM\t\t mech;\n\tCK_ATTRIBUTE\t\t key_filter[3];\n\tint\t\t\t always_auth = 0;\n\tint\t\t\t did_login = 0;\n\n\tif (!k11->provider || !k11->provider->valid) {\n\t\terror(\"no pkcs11 (valid) provider found\");\n\t\treturn (-1);\n\t}\n\n\tf = k11->provider->function_list;\n\tsi = &k11->provider->slotinfo[k11->slotidx];\n\n\tif ((si->token.flags & CKF_LOGIN_REQUIRED) && !si->logged_in) {\n\t\tif (pkcs11_login(k11, CKU_USER) < 0) {\n\t\t\terror(\"login failed\");\n\t\t\treturn (-1);\n\t\t}\n\t\tdid_login = 1;\n\t}\n\n\tmemset(&key_filter, 0, sizeof(key_filter));\n\tprivate_key_class = CKO_PRIVATE_KEY;\n\tkey_filter[0].type = CKA_CLASS;\n\tkey_filter[0].pValue = &private_key_class;\n\tkey_filter[0].ulValueLen = sizeof(private_key_class);\n\n\tkey_filter[1].type = CKA_ID;\n\tkey_filter[1].pValue = k11->keyid;\n\tkey_filter[1].ulValueLen = k11->keyid_len;\n\n\ttrue_val = CK_TRUE;\n\tkey_filter[2].type = CKA_SIGN;\n\tkey_filter[2].pValue = &true_val;\n\tkey_filter[2].ulValueLen = sizeof(true_val);\n\n\t/* try to find object w/CKA_SIGN first, retry w/o */\n\tif (pkcs11_find(k11->provider, k11->slotidx, key_filter, 3, &obj) < 0 &&\n\t    pkcs11_find(k11->provider, k11->slotidx, key_filter, 2, &obj) < 0) {\n\t\terror(\"cannot find private key\");\n\t\treturn (-1);\n\t}\n\n\tmemset(&mech, 0, sizeof(mech));\n\tmech.mechanism = mech_type;\n\tmech.pParameter = NULL_PTR;\n\tmech.ulParameterLen = 0;\n\n\tif ((rv = f->C_SignInit(si->session, &mech, obj)) != CKR_OK) {\n\t\terror(\"C_SignInit failed: %lu\", rv);\n\t\treturn (-1);\n\t}\n\n\tpkcs11_check_obj_bool_attrib(k11, obj, CKA_ALWAYS_AUTHENTICATE,\n\t    &always_auth); /* ignore errors here */\n\tif (always_auth && !did_login) {\n\t\tdebug(\"%s: always-auth key\", __func__);\n\t\tif (pkcs11_login(k11, CKU_CONTEXT_SPECIFIC) < 0) {\n\t\t\terror(\"login failed for always-auth key\");\n\t\t\treturn (-1);\n\t\t}\n\t}\n\n\treturn (0);\n}\n\n/* openssl callback doing the actual signing operation */\nstatic int\npkcs11_rsa_private_encrypt(int flen, const u_char *from, u_char *to, RSA *rsa,\n    int padding)\n{\n\tstruct pkcs11_key\t*k11;\n\tstruct pkcs11_slotinfo\t*si;\n\tCK_FUNCTION_LIST\t*f;\n\tCK_ULONG\t\ttlen = 0;\n\tCK_RV\t\t\trv;\n\tint\t\t\trval = -1;\n\n\tif ((k11 = RSA_get_ex_data(rsa, rsa_idx)) == NULL) {\n\t\terror(\"RSA_get_ex_data failed for rsa %p\", rsa);\n\t\treturn (-1);\n\t}\n\n\tif (pkcs11_get_key(k11, CKM_RSA_PKCS) == -1) {\n\t\terror(\"pkcs11_get_key failed\");\n\t\treturn (-1);\n\t}\n\n\tf = k11->provider->function_list;\n\tsi = &k11->provider->slotinfo[k11->slotidx];\n\ttlen = RSA_size(rsa);\n\n\t/* XXX handle CKR_BUFFER_TOO_SMALL */\n\trv = f->C_Sign(si->session, (CK_BYTE *)from, flen, to, &tlen);\n\tif (rv == CKR_OK)\n\t\trval = tlen;\n\telse\n\t\terror(\"C_Sign failed: %lu\", rv);\n\n\treturn (rval);\n}\n\nstatic int\npkcs11_rsa_private_decrypt(int flen, const u_char *from, u_char *to, RSA *rsa,\n    int padding)\n{\n\treturn (-1);\n}\n\nstatic int\npkcs11_rsa_start_wrapper(void)\n{\n\tif (rsa_method != NULL)\n\t\treturn (0);\n\trsa_method = RSA_meth_dup(RSA_get_default_method());\n\tif (rsa_method == NULL)\n\t\treturn (-1);\n\trsa_idx = RSA_get_ex_new_index(0, \"ssh-pkcs11-rsa\",\n\t    NULL, NULL, pkcs11_k11_free);\n\tif (rsa_idx == -1)\n\t\treturn (-1);\n\tif (!RSA_meth_set1_name(rsa_method, \"pkcs11\") ||\n\t    !RSA_meth_set_priv_enc(rsa_method, pkcs11_rsa_private_encrypt) ||\n\t    !RSA_meth_set_priv_dec(rsa_method, pkcs11_rsa_private_decrypt)) {\n\t\terror(\"%s: setup pkcs11 method failed\", __func__);\n\t\treturn (-1);\n\t}\n\treturn (0);\n}\n\n/* redirect private key operations for rsa key to pkcs11 token */\nstatic int\npkcs11_rsa_wrap(struct pkcs11_provider *provider, CK_ULONG slotidx,\n    CK_ATTRIBUTE *keyid_attrib, RSA *rsa)\n{\n\tstruct pkcs11_key\t*k11;\n\n\tif (pkcs11_rsa_start_wrapper() == -1)\n\t\treturn (-1);\n\n\tk11 = xcalloc(1, sizeof(*k11));\n\tk11->provider = provider;\n\tprovider->refcount++;\t/* provider referenced by RSA key */\n\tk11->slotidx = slotidx;\n\t/* identify key object on smartcard */\n\tk11->keyid_len = keyid_attrib->ulValueLen;\n\tif (k11->keyid_len > 0) {\n\t\tk11->keyid = xmalloc(k11->keyid_len);\n\t\tmemcpy(k11->keyid, keyid_attrib->pValue, k11->keyid_len);\n\t}\n\n\tRSA_set_method(rsa, rsa_method);\n\tRSA_set_ex_data(rsa, rsa_idx, k11);\n\treturn (0);\n}\n\n#ifdef HAVE_EC_KEY_METHOD_NEW\n/* openssl callback doing the actual signing operation */\nstatic ECDSA_SIG *\necdsa_do_sign(const unsigned char *dgst, int dgst_len, const BIGNUM *inv,\n    const BIGNUM *rp, EC_KEY *ec)\n{\n\tstruct pkcs11_key\t*k11;\n\tstruct pkcs11_slotinfo\t*si;\n\tCK_FUNCTION_LIST\t*f;\n\tCK_ULONG\t\tsiglen = 0, bnlen;\n\tCK_RV\t\t\trv;\n\tECDSA_SIG\t\t*ret = NULL;\n\tu_char\t\t\t*sig;\n\tBIGNUM\t\t\t*r = NULL, *s = NULL;\n\n\tif ((k11 = EC_KEY_get_ex_data(ec, ec_key_idx)) == NULL) {\n\t\tossl_error(\"EC_KEY_get_key_method_data failed for ec\");\n\t\treturn (NULL);\n\t}\n\n\tif (pkcs11_get_key(k11, CKM_ECDSA) == -1) {\n\t\terror(\"pkcs11_get_key failed\");\n\t\treturn (NULL);\n\t}\n\n\tf = k11->provider->function_list;\n\tsi = &k11->provider->slotinfo[k11->slotidx];\n\n\tsiglen = ECDSA_size(ec);\n\tsig = xmalloc(siglen);\n\n\t/* XXX handle CKR_BUFFER_TOO_SMALL */\n\trv = f->C_Sign(si->session, (CK_BYTE *)dgst, dgst_len, sig, &siglen);\n\tif (rv != CKR_OK) {\n\t\terror(\"C_Sign failed: %lu\", rv);\n\t\tgoto done;\n\t}\n\tif (siglen < 64 || siglen > 132 || siglen % 2) {\n\t\tossl_error(\"d2i_ECDSA_SIG failed\");\n\t\tgoto done;\n\t}\n\tbnlen = siglen/2;\n\tif ((ret = ECDSA_SIG_new()) == NULL) {\n\t\terror(\"ECDSA_SIG_new failed\");\n\t\tgoto done;\n\t}\n\tif ((r = BN_bin2bn(sig, bnlen, NULL)) == NULL ||\n\t    (s = BN_bin2bn(sig+bnlen, bnlen, NULL)) == NULL) {\n\t\tossl_error(\"d2i_ECDSA_SIG failed\");\n\t\tECDSA_SIG_free(ret);\n\t\tret = NULL;\n\t\tgoto done;\n\t}\n\tif (!ECDSA_SIG_set0(ret, r, s)) {\n\t\terror(\"%s: ECDSA_SIG_set0 failed\", __func__);\n\t\tECDSA_SIG_free(ret);\n\t\tret = NULL;\n\t\tgoto done;\n\t}\n\tr = s = NULL; /* now owned by ret */\n\t/* success */\n done:\n\tBN_free(r);\n\tBN_free(s);\n\tfree(sig);\n\n\treturn (ret);\n}\n\nstatic int\npkcs11_ecdsa_start_wrapper(void)\n{\n\tint (*orig_sign)(int, const unsigned char *, int, unsigned char *,\n\t    unsigned int *, const BIGNUM *, const BIGNUM *, EC_KEY *) = NULL;\n\n\tif (ec_key_method != NULL)\n\t\treturn (0);\n\tec_key_idx = EC_KEY_get_ex_new_index(0, \"ssh-pkcs11-ecdsa\",\n\t    NULL, NULL, pkcs11_k11_free);\n\tif (ec_key_idx == -1)\n\t\treturn (-1);\n\tec_key_method = EC_KEY_METHOD_new(EC_KEY_OpenSSL());\n\tif (ec_key_method == NULL)\n\t\treturn (-1);\n\tEC_KEY_METHOD_get_sign(ec_key_method, &orig_sign, NULL, NULL);\n\tEC_KEY_METHOD_set_sign(ec_key_method, orig_sign, NULL, ecdsa_do_sign);\n\treturn (0);\n}\n\nstatic int\npkcs11_ecdsa_wrap(struct pkcs11_provider *provider, CK_ULONG slotidx,\n    CK_ATTRIBUTE *keyid_attrib, EC_KEY *ec)\n{\n\tstruct pkcs11_key\t*k11;\n\n\tif (pkcs11_ecdsa_start_wrapper() == -1)\n\t\treturn (-1);\n\n\tk11 = xcalloc(1, sizeof(*k11));\n\tk11->provider = provider;\n\tprovider->refcount++;\t/* provider referenced by ECDSA key */\n\tk11->slotidx = slotidx;\n\t/* identify key object on smartcard */\n\tk11->keyid_len = keyid_attrib->ulValueLen;\n\tk11->keyid = xmalloc(k11->keyid_len);\n\tmemcpy(k11->keyid, keyid_attrib->pValue, k11->keyid_len);\n\n\tEC_KEY_set_method(ec, ec_key_method);\n\tEC_KEY_set_ex_data(ec, ec_key_idx, k11);\n\n\treturn (0);\n}\n#endif /* HAVE_EC_KEY_METHOD_NEW */\n\n/* remove trailing spaces */\nstatic void\nrmspace(u_char *buf, size_t len)\n{\n\tsize_t i;\n\n\tif (!len)\n\t\treturn;\n\tfor (i = len - 1;  i > 0; i--)\n\t\tif (i == len - 1 || buf[i] == ' ')\n\t\t\tbuf[i] = '\\0';\n\t\telse\n\t\t\tbreak;\n}\n\n/*\n * open a pkcs11 session and login if required.\n * if pin == NULL we delay login until key use\n */\nstatic int\npkcs11_open_session(struct pkcs11_provider *p, CK_ULONG slotidx, char *pin,\n    CK_ULONG user)\n{\n\tstruct pkcs11_slotinfo\t*si;\n\tCK_FUNCTION_LIST\t*f;\n\tCK_RV\t\t\trv;\n\tCK_SESSION_HANDLE\tsession;\n\tint\t\t\tlogin_required, ret;\n\n\tf = p->function_list;\n\tsi = &p->slotinfo[slotidx];\n\n\tlogin_required = si->token.flags & CKF_LOGIN_REQUIRED;\n\n\t/* fail early before opening session */\n\tif (login_required && !pkcs11_interactive &&\n\t    (pin == NULL || strlen(pin) == 0)) {\n\t\terror(\"pin required\");\n\t\treturn (-SSH_PKCS11_ERR_PIN_REQUIRED);\n\t}\n\tif ((rv = f->C_OpenSession(p->slotlist[slotidx], CKF_RW_SESSION|\n\t    CKF_SERIAL_SESSION, NULL, NULL, &session)) != CKR_OK) {\n\t\terror(\"C_OpenSession failed: %lu\", rv);\n\t\treturn (-1);\n\t}\n\tif (login_required && pin != NULL && strlen(pin) != 0) {\n\t\trv = f->C_Login(session, user, (u_char *)pin, strlen(pin));\n\t\tif (rv != CKR_OK && rv != CKR_USER_ALREADY_LOGGED_IN) {\n\t\t\terror(\"C_Login failed: %lu\", rv);\n\t\t\tret = (rv == CKR_PIN_LOCKED) ?\n\t\t\t    -SSH_PKCS11_ERR_PIN_LOCKED :\n\t\t\t    -SSH_PKCS11_ERR_LOGIN_FAIL;\n\t\t\tif ((rv = f->C_CloseSession(session)) != CKR_OK)\n\t\t\t\terror(\"C_CloseSession failed: %lu\", rv);\n\t\t\treturn (ret);\n\t\t}\n\t\tsi->logged_in = 1;\n\t}\n\tsi->session = session;\n\treturn (0);\n}\n\nstatic int\npkcs11_key_included(struct sshkey ***keysp, int *nkeys, struct sshkey *key)\n{\n\tint i;\n\n\tfor (i = 0; i < *nkeys; i++)\n\t\tif (sshkey_equal(key, (*keysp)[i]))\n\t\t\treturn (1);\n\treturn (0);\n}\n\n#ifdef HAVE_EC_KEY_METHOD_NEW\nstatic struct sshkey *\npkcs11_fetch_ecdsa_pubkey(struct pkcs11_provider *p, CK_ULONG slotidx,\n    CK_OBJECT_HANDLE *obj)\n{\n\tCK_ATTRIBUTE\t\t key_attr[3];\n\tCK_SESSION_HANDLE\t session;\n\tCK_FUNCTION_LIST\t*f = NULL;\n\tCK_RV\t\t\t rv;\n\tASN1_OCTET_STRING\t*octet = NULL;\n\tEC_KEY\t\t\t*ec = NULL;\n\tEC_GROUP\t\t*group = NULL;\n\tstruct sshkey\t\t*key = NULL;\n\tconst unsigned char\t*attrp = NULL;\n\tint\t\t\t i;\n\tint\t\t\t nid;\n\n\tmemset(&key_attr, 0, sizeof(key_attr));\n\tkey_attr[0].type = CKA_ID;\n\tkey_attr[1].type = CKA_EC_POINT;\n\tkey_attr[2].type = CKA_EC_PARAMS;\n\n\tsession = p->slotinfo[slotidx].session;\n\tf = p->function_list;\n\n\t/* figure out size of the attributes */\n\trv = f->C_GetAttributeValue(session, *obj, key_attr, 3);\n\tif (rv != CKR_OK) {\n\t\terror(\"C_GetAttributeValue failed: %lu\", rv);\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * Allow CKA_ID (always first attribute) to be empty, but\n\t * ensure that none of the others are zero length.\n\t * XXX assumes CKA_ID is always first.\n\t */\n\tif (key_attr[1].ulValueLen == 0 ||\n\t    key_attr[2].ulValueLen == 0) {\n\t\terror(\"invalid attribute length\");\n\t\treturn (NULL);\n\t}\n\n\t/* allocate buffers for attributes */\n\tfor (i = 0; i < 3; i++)\n\t\tif (key_attr[i].ulValueLen > 0)\n\t\t\tkey_attr[i].pValue = xcalloc(1, key_attr[i].ulValueLen);\n\n\t/* retrieve ID, public point and curve parameters of EC key */\n\trv = f->C_GetAttributeValue(session, *obj, key_attr, 3);\n\tif (rv != CKR_OK) {\n\t\terror(\"C_GetAttributeValue failed: %lu\", rv);\n\t\tgoto fail;\n\t}\n\n\tec = EC_KEY_new();\n\tif (ec == NULL) {\n\t\terror(\"EC_KEY_new failed\");\n\t\tgoto fail;\n\t}\n\n\tattrp = key_attr[2].pValue;\n\tgroup = d2i_ECPKParameters(NULL, &attrp, key_attr[2].ulValueLen);\n\tif (group == NULL) {\n\t\tossl_error(\"d2i_ECPKParameters failed\");\n\t\tgoto fail;\n\t}\n\n\tif (EC_KEY_set_group(ec, group) == 0) {\n\t\tossl_error(\"EC_KEY_set_group failed\");\n\t\tgoto fail;\n\t}\n\n\tif (key_attr[1].ulValueLen <= 2) {\n\t\terror(\"CKA_EC_POINT too small\");\n\t\tgoto fail;\n\t}\n\n\tattrp = key_attr[1].pValue;\n\toctet = d2i_ASN1_OCTET_STRING(NULL, &attrp, key_attr[1].ulValueLen);\n\tif (octet == NULL) {\n\t\tossl_error(\"d2i_ASN1_OCTET_STRING failed\");\n\t\tgoto fail;\n\t}\n\tattrp = octet->data;\n\tif (o2i_ECPublicKey(&ec, &attrp, octet->length) == NULL) {\n\t\tossl_error(\"o2i_ECPublicKey failed\");\n\t\tgoto fail;\n\t}\n\n\tnid = sshkey_ecdsa_key_to_nid(ec);\n\tif (nid < 0) {\n\t\terror(\"couldn't get curve nid\");\n\t\tgoto fail;\n\t}\n\n\tif (pkcs11_ecdsa_wrap(p, slotidx, &key_attr[0], ec))\n\t\tgoto fail;\n\n\tkey = sshkey_new(KEY_UNSPEC);\n\tif (key == NULL) {\n\t\terror(\"sshkey_new failed\");\n\t\tgoto fail;\n\t}\n\n\tkey->ecdsa = ec;\n\tkey->ecdsa_nid = nid;\n\tkey->type = KEY_ECDSA;\n\tkey->flags |= SSHKEY_FLAG_EXT;\n\tec = NULL;\t/* now owned by key */\n\nfail:\n\tfor (i = 0; i < 3; i++)\n\t\tfree(key_attr[i].pValue);\n\tif (ec)\n\t\tEC_KEY_free(ec);\n\tif (group)\n\t\tEC_GROUP_free(group);\n\tif (octet)\n\t\tASN1_OCTET_STRING_free(octet);\n\n\treturn (key);\n}\n#endif /* HAVE_EC_KEY_METHOD_NEW */\n\nstatic struct sshkey *\npkcs11_fetch_rsa_pubkey(struct pkcs11_provider *p, CK_ULONG slotidx,\n    CK_OBJECT_HANDLE *obj)\n{\n\tCK_ATTRIBUTE\t\t key_attr[3];\n\tCK_SESSION_HANDLE\t session;\n\tCK_FUNCTION_LIST\t*f = NULL;\n\tCK_RV\t\t\t rv;\n\tRSA\t\t\t*rsa = NULL;\n\tBIGNUM\t\t\t*rsa_n, *rsa_e;\n\tstruct sshkey\t\t*key = NULL;\n\tint\t\t\t i;\n\n\tmemset(&key_attr, 0, sizeof(key_attr));\n\tkey_attr[0].type = CKA_ID;\n\tkey_attr[1].type = CKA_MODULUS;\n\tkey_attr[2].type = CKA_PUBLIC_EXPONENT;\n\n\tsession = p->slotinfo[slotidx].session;\n\tf = p->function_list;\n\n\t/* figure out size of the attributes */\n\trv = f->C_GetAttributeValue(session, *obj, key_attr, 3);\n\tif (rv != CKR_OK) {\n\t\terror(\"C_GetAttributeValue failed: %lu\", rv);\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * Allow CKA_ID (always first attribute) to be empty, but\n\t * ensure that none of the others are zero length.\n\t * XXX assumes CKA_ID is always first.\n\t */\n\tif (key_attr[1].ulValueLen == 0 ||\n\t    key_attr[2].ulValueLen == 0) {\n\t\terror(\"invalid attribute length\");\n\t\treturn (NULL);\n\t}\n\n\t/* allocate buffers for attributes */\n\tfor (i = 0; i < 3; i++)\n\t\tif (key_attr[i].ulValueLen > 0)\n\t\t\tkey_attr[i].pValue = xcalloc(1, key_attr[i].ulValueLen);\n\n\t/* retrieve ID, modulus and public exponent of RSA key */\n\trv = f->C_GetAttributeValue(session, *obj, key_attr, 3);\n\tif (rv != CKR_OK) {\n\t\terror(\"C_GetAttributeValue failed: %lu\", rv);\n\t\tgoto fail;\n\t}\n\n\trsa = RSA_new();\n\tif (rsa == NULL) {\n\t\terror(\"RSA_new failed\");\n\t\tgoto fail;\n\t}\n\n\trsa_n = BN_bin2bn(key_attr[1].pValue, key_attr[1].ulValueLen, NULL);\n\trsa_e = BN_bin2bn(key_attr[2].pValue, key_attr[2].ulValueLen, NULL);\n\tif (rsa_n == NULL || rsa_e == NULL) {\n\t\terror(\"BN_bin2bn failed\");\n\t\tgoto fail;\n\t}\n\tif (!RSA_set0_key(rsa, rsa_n, rsa_e, NULL))\n\t\tfatal(\"%s: set key\", __func__);\n\trsa_n = rsa_e = NULL; /* transferred */\n\n\tif (pkcs11_rsa_wrap(p, slotidx, &key_attr[0], rsa))\n\t\tgoto fail;\n\n\tkey = sshkey_new(KEY_UNSPEC);\n\tif (key == NULL) {\n\t\terror(\"sshkey_new failed\");\n\t\tgoto fail;\n\t}\n\n\tkey->rsa = rsa;\n\tkey->type = KEY_RSA;\n\tkey->flags |= SSHKEY_FLAG_EXT;\n\trsa = NULL;\t/* now owned by key */\n\nfail:\n\tfor (i = 0; i < 3; i++)\n\t\tfree(key_attr[i].pValue);\n\tRSA_free(rsa);\n\n\treturn (key);\n}\n\nstatic struct sshkey *\npkcs11_fetch_x509_pubkey(struct pkcs11_provider *p, CK_ULONG slotidx,\n    CK_OBJECT_HANDLE *obj)\n{\n\tCK_ATTRIBUTE\t\t cert_attr[3];\n\tCK_SESSION_HANDLE\t session;\n\tCK_FUNCTION_LIST\t*f = NULL;\n\tCK_RV\t\t\t rv;\n\tX509\t\t\t*x509 = NULL;\n\tEVP_PKEY\t\t*evp;\n\tRSA\t\t\t*rsa = NULL;\n#ifdef OPENSSL_HAS_ECC\n\tEC_KEY\t\t\t*ec = NULL;\n#endif\n\tstruct sshkey\t\t*key = NULL;\n\tint\t\t\t i;\n#ifdef HAVE_EC_KEY_METHOD_NEW\n\tint\t\t\t nid;\n#endif\n\tconst u_char\t\t *cp;\n\n\tmemset(&cert_attr, 0, sizeof(cert_attr));\n\tcert_attr[0].type = CKA_ID;\n\tcert_attr[1].type = CKA_SUBJECT;\n\tcert_attr[2].type = CKA_VALUE;\n\n\tsession = p->slotinfo[slotidx].session;\n\tf = p->function_list;\n\n\t/* figure out size of the attributes */\n\trv = f->C_GetAttributeValue(session, *obj, cert_attr, 3);\n\tif (rv != CKR_OK) {\n\t\terror(\"C_GetAttributeValue failed: %lu\", rv);\n\t\treturn (NULL);\n\t}\n\n\t/*\n\t * Allow CKA_ID (always first attribute) to be empty, but\n\t * ensure that none of the others are zero length.\n\t * XXX assumes CKA_ID is always first.\n\t */\n\tif (cert_attr[1].ulValueLen == 0 ||\n\t    cert_attr[2].ulValueLen == 0) {\n\t\terror(\"invalid attribute length\");\n\t\treturn (NULL);\n\t}\n\n\t/* allocate buffers for attributes */\n\tfor (i = 0; i < 3; i++)\n\t\tif (cert_attr[i].ulValueLen > 0)\n\t\t\tcert_attr[i].pValue = xcalloc(1, cert_attr[i].ulValueLen);\n\n\t/* retrieve ID, subject and value of certificate */\n\trv = f->C_GetAttributeValue(session, *obj, cert_attr, 3);\n\tif (rv != CKR_OK) {\n\t\terror(\"C_GetAttributeValue failed: %lu\", rv);\n\t\tgoto fail;\n\t}\n\n\tx509 = X509_new();\n\tif (x509 == NULL) {\n\t\terror(\"x509_new failed\");\n\t\tgoto fail;\n\t}\n\n\tcp = cert_attr[2].pValue;\n\tif (d2i_X509(&x509, &cp, cert_attr[2].ulValueLen) == NULL) {\n\t\terror(\"d2i_x509 failed\");\n\t\tgoto fail;\n\t}\n\n\tevp = X509_get_pubkey(x509);\n\tif (evp == NULL) {\n\t\terror(\"X509_get_pubkey failed\");\n\t\tgoto fail;\n\t}\n\n\tif (EVP_PKEY_base_id(evp) == EVP_PKEY_RSA) {\n\t\tif (EVP_PKEY_get0_RSA(evp) == NULL) {\n\t\t\terror(\"invalid x509; no rsa key\");\n\t\t\tgoto fail;\n\t\t}\n\t\tif ((rsa = RSAPublicKey_dup(EVP_PKEY_get0_RSA(evp))) == NULL) {\n\t\t\terror(\"RSAPublicKey_dup failed\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (pkcs11_rsa_wrap(p, slotidx, &cert_attr[0], rsa))\n\t\t\tgoto fail;\n\n\t\tkey = sshkey_new(KEY_UNSPEC);\n\t\tif (key == NULL) {\n\t\t\terror(\"sshkey_new failed\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tkey->rsa = rsa;\n\t\tkey->type = KEY_RSA;\n\t\tkey->flags |= SSHKEY_FLAG_EXT;\n\t\trsa = NULL;\t/* now owned by key */\n#ifdef HAVE_EC_KEY_METHOD_NEW\n\t} else if (EVP_PKEY_base_id(evp) == EVP_PKEY_EC) {\n\t\tif (EVP_PKEY_get0_EC_KEY(evp) == NULL) {\n\t\t\terror(\"invalid x509; no ec key\");\n\t\t\tgoto fail;\n\t\t}\n\t\tif ((ec = EC_KEY_dup(EVP_PKEY_get0_EC_KEY(evp))) == NULL) {\n\t\t\terror(\"EC_KEY_dup failed\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tnid = sshkey_ecdsa_key_to_nid(ec);\n\t\tif (nid < 0) {\n\t\t\terror(\"couldn't get curve nid\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tif (pkcs11_ecdsa_wrap(p, slotidx, &cert_attr[0], ec))\n\t\t\tgoto fail;\n\n\t\tkey = sshkey_new(KEY_UNSPEC);\n\t\tif (key == NULL) {\n\t\t\terror(\"sshkey_new failed\");\n\t\t\tgoto fail;\n\t\t}\n\n\t\tkey->ecdsa = ec;\n\t\tkey->ecdsa_nid = nid;\n\t\tkey->type = KEY_ECDSA;\n\t\tkey->flags |= SSHKEY_FLAG_EXT;\n\t\tec = NULL;\t/* now owned by key */\n#endif /* HAVE_EC_KEY_METHOD_NEW */\n\t} else\n\t\terror(\"unknown certificate key type\");\n\nfail:\n\tfor (i = 0; i < 3; i++)\n\t\tfree(cert_attr[i].pValue);\n\tX509_free(x509);\n\tRSA_free(rsa);\n#ifdef OPENSSL_HAS_ECC\n\tEC_KEY_free(ec);\n#endif\n\n\treturn (key);\n}\n\n#if 0\nstatic int\nhave_rsa_key(const RSA *rsa)\n{\n\tconst BIGNUM *rsa_n, *rsa_e;\n\n\tRSA_get0_key(rsa, &rsa_n, &rsa_e, NULL);\n\treturn rsa_n != NULL && rsa_e != NULL;\n}\n#endif\n\n/*\n * lookup certificates for token in slot identified by slotidx,\n * add 'wrapped' public keys to the 'keysp' array and increment nkeys.\n * keysp points to an (possibly empty) array with *nkeys keys.\n */\nstatic int\npkcs11_fetch_certs(struct pkcs11_provider *p, CK_ULONG slotidx,\n    struct sshkey ***keysp, int *nkeys)\n{\n\tstruct sshkey\t\t*key = NULL;\n\tCK_OBJECT_CLASS\t\t key_class;\n\tCK_ATTRIBUTE\t\t key_attr[1];\n\tCK_SESSION_HANDLE\t session;\n\tCK_FUNCTION_LIST\t*f = NULL;\n\tCK_RV\t\t\t rv;\n\tCK_OBJECT_HANDLE\t obj;\n\tCK_ULONG\t\t n = 0;\n\tint\t\t\t ret = -1;\n\n\tmemset(&key_attr, 0, sizeof(key_attr));\n\tmemset(&obj, 0, sizeof(obj));\n\n\tkey_class = CKO_CERTIFICATE;\n\tkey_attr[0].type = CKA_CLASS;\n\tkey_attr[0].pValue = &key_class;\n\tkey_attr[0].ulValueLen = sizeof(key_class);\n\n\tsession = p->slotinfo[slotidx].session;\n\tf = p->function_list;\n\n\trv = f->C_FindObjectsInit(session, key_attr, 1);\n\tif (rv != CKR_OK) {\n\t\terror(\"C_FindObjectsInit failed: %lu\", rv);\n\t\tgoto fail;\n\t}\n\n\twhile (1) {\n\t\tCK_CERTIFICATE_TYPE\tck_cert_type;\n\n\t\trv = f->C_FindObjects(session, &obj, 1, &n);\n\t\tif (rv != CKR_OK) {\n\t\t\terror(\"C_FindObjects failed: %lu\", rv);\n\t\t\tgoto fail;\n\t\t}\n\t\tif (n == 0)\n\t\t\tbreak;\n\n\t\tmemset(&ck_cert_type, 0, sizeof(ck_cert_type));\n\t\tmemset(&key_attr, 0, sizeof(key_attr));\n\t\tkey_attr[0].type = CKA_CERTIFICATE_TYPE;\n\t\tkey_attr[0].pValue = &ck_cert_type;\n\t\tkey_attr[0].ulValueLen = sizeof(ck_cert_type);\n\n\t\trv = f->C_GetAttributeValue(session, obj, key_attr, 1);\n\t\tif (rv != CKR_OK) {\n\t\t\terror(\"C_GetAttributeValue failed: %lu\", rv);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tswitch (ck_cert_type) {\n\t\tcase CKC_X_509:\n\t\t\tkey = pkcs11_fetch_x509_pubkey(p, slotidx, &obj);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\t/* XXX print key type? */\n\t\t\tkey = NULL;\n\t\t\terror(\"skipping unsupported certificate type\");\n\t\t}\n\n\t\tif (key == NULL) {\n\t\t\terror(\"failed to fetch key\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pkcs11_key_included(keysp, nkeys, key)) {\n\t\t\tsshkey_free(key);\n\t\t} else {\n\t\t\t/* expand key array and add key */\n\t\t\t*keysp = xrecallocarray(*keysp, *nkeys,\n\t\t\t    *nkeys + 1, sizeof(struct sshkey *));\n\t\t\t(*keysp)[*nkeys] = key;\n\t\t\t*nkeys = *nkeys + 1;\n\t\t\tdebug(\"have %d keys\", *nkeys);\n\t\t}\n\t}\n\n\tret = 0;\nfail:\n\trv = f->C_FindObjectsFinal(session);\n\tif (rv != CKR_OK) {\n\t\terror(\"C_FindObjectsFinal failed: %lu\", rv);\n\t\tret = -1;\n\t}\n\n\treturn (ret);\n}\n\n/*\n * lookup public keys for token in slot identified by slotidx,\n * add 'wrapped' public keys to the 'keysp' array and increment nkeys.\n * keysp points to an (possibly empty) array with *nkeys keys.\n */\nstatic int\npkcs11_fetch_keys(struct pkcs11_provider *p, CK_ULONG slotidx,\n    struct sshkey ***keysp, int *nkeys)\n{\n\tstruct sshkey\t\t*key = NULL;\n\tCK_OBJECT_CLASS\t\t key_class;\n\tCK_ATTRIBUTE\t\t key_attr[1];\n\tCK_SESSION_HANDLE\t session;\n\tCK_FUNCTION_LIST\t*f = NULL;\n\tCK_RV\t\t\t rv;\n\tCK_OBJECT_HANDLE\t obj;\n\tCK_ULONG\t\t n = 0;\n\tint\t\t\t ret = -1;\n\n\tmemset(&key_attr, 0, sizeof(key_attr));\n\tmemset(&obj, 0, sizeof(obj));\n\n\tkey_class = CKO_PUBLIC_KEY;\n\tkey_attr[0].type = CKA_CLASS;\n\tkey_attr[0].pValue = &key_class;\n\tkey_attr[0].ulValueLen = sizeof(key_class);\n\n\tsession = p->slotinfo[slotidx].session;\n\tf = p->function_list;\n\n\trv = f->C_FindObjectsInit(session, key_attr, 1);\n\tif (rv != CKR_OK) {\n\t\terror(\"C_FindObjectsInit failed: %lu\", rv);\n\t\tgoto fail;\n\t}\n\n\twhile (1) {\n\t\tCK_KEY_TYPE\tck_key_type;\n\n\t\trv = f->C_FindObjects(session, &obj, 1, &n);\n\t\tif (rv != CKR_OK) {\n\t\t\terror(\"C_FindObjects failed: %lu\", rv);\n\t\t\tgoto fail;\n\t\t}\n\t\tif (n == 0)\n\t\t\tbreak;\n\n\t\tmemset(&ck_key_type, 0, sizeof(ck_key_type));\n\t\tmemset(&key_attr, 0, sizeof(key_attr));\n\t\tkey_attr[0].type = CKA_KEY_TYPE;\n\t\tkey_attr[0].pValue = &ck_key_type;\n\t\tkey_attr[0].ulValueLen = sizeof(ck_key_type);\n\n\t\trv = f->C_GetAttributeValue(session, obj, key_attr, 1);\n\t\tif (rv != CKR_OK) {\n\t\t\terror(\"C_GetAttributeValue failed: %lu\", rv);\n\t\t\tgoto fail;\n\t\t}\n\n\t\tswitch (ck_key_type) {\n\t\tcase CKK_RSA:\n\t\t\tkey = pkcs11_fetch_rsa_pubkey(p, slotidx, &obj);\n\t\t\tbreak;\n#ifdef HAVE_EC_KEY_METHOD_NEW\n\t\tcase CKK_ECDSA:\n\t\t\tkey = pkcs11_fetch_ecdsa_pubkey(p, slotidx, &obj);\n\t\t\tbreak;\n#endif /* HAVE_EC_KEY_METHOD_NEW */\n\t\tdefault:\n\t\t\t/* XXX print key type? */\n\t\t\tkey = NULL;\n\t\t\terror(\"skipping unsupported key type\");\n\t\t}\n\n\t\tif (key == NULL) {\n\t\t\terror(\"failed to fetch key\");\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (pkcs11_key_included(keysp, nkeys, key)) {\n\t\t\tsshkey_free(key);\n\t\t} else {\n\t\t\t/* expand key array and add key */\n\t\t\t*keysp = xrecallocarray(*keysp, *nkeys,\n\t\t\t    *nkeys + 1, sizeof(struct sshkey *));\n\t\t\t(*keysp)[*nkeys] = key;\n\t\t\t*nkeys = *nkeys + 1;\n\t\t\tdebug(\"have %d keys\", *nkeys);\n\t\t}\n\t}\n\n\tret = 0;\nfail:\n\trv = f->C_FindObjectsFinal(session);\n\tif (rv != CKR_OK) {\n\t\terror(\"C_FindObjectsFinal failed: %lu\", rv);\n\t\tret = -1;\n\t}\n\n\treturn (ret);\n}\n\n#ifdef WITH_PKCS11_KEYGEN\n#define FILL_ATTR(attr, idx, typ, val, len) \\\n\t{ (attr[idx]).type=(typ); (attr[idx]).pValue=(val); (attr[idx]).ulValueLen=len; idx++; }\n\nstatic struct sshkey *\npkcs11_rsa_generate_private_key(struct pkcs11_provider *p, CK_ULONG slotidx,\n    char *label, CK_ULONG bits, CK_BYTE keyid, u_int32_t *err)\n{\n\tstruct pkcs11_slotinfo\t*si;\n\tchar\t\t\t*plabel = label ? label : \"\";\n\tint\t\t\t npub = 0, npriv = 0;\n\tCK_RV\t\t\t rv;\n\tCK_FUNCTION_LIST\t*f;\n\tCK_SESSION_HANDLE\t session;\n\tCK_BBOOL\t\t true_val = CK_TRUE, false_val = CK_FALSE;\n\tCK_OBJECT_HANDLE\t pubKey, privKey;\n\tCK_ATTRIBUTE\t\t tpub[16], tpriv[16];\n\tCK_MECHANISM\t\t mech = {\n\t    CKM_RSA_PKCS_KEY_PAIR_GEN, NULL_PTR, 0\n\t};\n\tCK_BYTE\t\t\t pubExponent[] = {\n\t    0x01, 0x00, 0x01 /* RSA_F4 in bytes */\n\t};\n\tpubkey_filter[0].pValue = &pubkey_class;\n\tcert_filter[0].pValue = &cert_class;\n\n\t*err = 0;\n\n\tFILL_ATTR(tpub, npub, CKA_TOKEN, &true_val, sizeof(true_val));\n\tFILL_ATTR(tpub, npub, CKA_LABEL, plabel, strlen(plabel));\n\tFILL_ATTR(tpub, npub, CKA_ENCRYPT, &false_val, sizeof(false_val));\n\tFILL_ATTR(tpub, npub, CKA_VERIFY, &true_val, sizeof(true_val));\n\tFILL_ATTR(tpub, npub, CKA_VERIFY_RECOVER, &false_val,\n\t    sizeof(false_val));\n\tFILL_ATTR(tpub, npub, CKA_WRAP, &false_val, sizeof(false_val));\n\tFILL_ATTR(tpub, npub, CKA_DERIVE, &false_val, sizeof(false_val));\n\tFILL_ATTR(tpub, npub, CKA_MODULUS_BITS, &bits, sizeof(bits));\n\tFILL_ATTR(tpub, npub, CKA_PUBLIC_EXPONENT, pubExponent,\n\t    sizeof(pubExponent));\n\tFILL_ATTR(tpub, npub, CKA_ID, &keyid, sizeof(keyid));\n\n\tFILL_ATTR(tpriv, npriv, CKA_TOKEN,  &true_val, sizeof(true_val));\n\tFILL_ATTR(tpriv, npriv, CKA_LABEL,  plabel, strlen(plabel));\n\tFILL_ATTR(tpriv, npriv, CKA_PRIVATE,  &true_val, sizeof(true_val));\n\tFILL_ATTR(tpriv, npriv, CKA_SENSITIVE,  &true_val, sizeof(true_val));\n\tFILL_ATTR(tpriv, npriv, CKA_DECRYPT,  &false_val, sizeof(false_val));\n\tFILL_ATTR(tpriv, npriv, CKA_SIGN,  &true_val, sizeof(true_val));\n\tFILL_ATTR(tpriv, npriv, CKA_SIGN_RECOVER,  &false_val,\n\t    sizeof(false_val));\n\tFILL_ATTR(tpriv, npriv, CKA_UNWRAP,  &false_val, sizeof(false_val));\n\tFILL_ATTR(tpriv, npriv, CKA_DERIVE,  &false_val, sizeof(false_val));\n\tFILL_ATTR(tpriv, npriv, CKA_ID, &keyid, sizeof(keyid));\n\n\tf = p->function_list;\n\tsi = &p->slotinfo[slotidx];\n\tsession = si->session;\n\n\tif ((rv = f->C_GenerateKeyPair(session, &mech, tpub, npub, tpriv, npriv,\n\t    &pubKey, &privKey)) != CKR_OK) {\n\t\terror(\"%s: key generation failed: error 0x%lx\", __func__, rv);\n\t\t*err = rv;\n\t\treturn NULL;\n\t}\n\n\treturn pkcs11_fetch_rsa_pubkey(p, slotidx, &pubKey);\n}\n\nstatic int\npkcs11_decode_hex(const char *hex, unsigned char **dest, size_t *rlen)\n{\n\tsize_t\ti, len;\n\tchar\tptr[3];\n\n\tif (dest)\n\t\t*dest = NULL;\n\tif (rlen)\n\t\t*rlen = 0;\n\n\tif ((len = strlen(hex)) % 2)\n\t\treturn -1;\n\tlen /= 2;\n\n\t*dest = xmalloc(len);\n\n\tptr[2] = '\\0';\n\tfor (i = 0; i < len; i++) {\n\t\tptr[0] = hex[2 * i];\n\t\tptr[1] = hex[(2 * i) + 1];\n\t\tif (!isxdigit(ptr[0]) || !isxdigit(ptr[1]))\n\t\t\treturn -1;\n\t\t(*dest)[i] = (unsigned char)strtoul(ptr, NULL, 16);\n\t}\n\n\tif (rlen)\n\t\t*rlen = len;\n\n\treturn 0;\n}\n\nstatic struct ec_curve_info {\n\tconst char\t*name;\n\tconst char\t*oid;\n\tconst char\t*oid_encoded;\n\tsize_t\t\t size;\n} ec_curve_infos[] = {\n\t{\"prime256v1\",\t\"1.2.840.10045.3.1.7\",\t\"06082A8648CE3D030107\", 256},\n\t{\"secp384r1\",\t\"1.3.132.0.34\",\t\t\"06052B81040022\",\t384},\n\t{\"secp521r1\",\t\"1.3.132.0.35\",\t\t\"06052B81040023\",\t521},\n\t{NULL,\t\tNULL,\t\t\tNULL,\t\t\t0},\n};\n\nstatic struct sshkey *\npkcs11_ecdsa_generate_private_key(struct pkcs11_provider *p, CK_ULONG slotidx,\n    char *label, CK_ULONG bits, CK_BYTE keyid, u_int32_t *err)\n{\n\tstruct pkcs11_slotinfo\t*si;\n\tchar\t\t\t*plabel = label ? label : \"\";\n\tint\t\t\t i;\n\tsize_t\t\t\t ecparams_size;\n\tunsigned char\t\t*ecparams = NULL;\n\tint\t\t\t npub = 0, npriv = 0;\n\tCK_RV\t\t\t rv;\n\tCK_FUNCTION_LIST\t*f;\n\tCK_SESSION_HANDLE\t session;\n\tCK_BBOOL\t\t true_val = CK_TRUE, false_val = CK_FALSE;\n\tCK_OBJECT_HANDLE\t pubKey, privKey;\n\tCK_MECHANISM\t\t mech = {\n\t    CKM_EC_KEY_PAIR_GEN, NULL_PTR, 0\n\t};\n\tCK_ATTRIBUTE\t\t tpub[16], tpriv[16];\n\n\t*err = 0;\n\n\tfor (i = 0; ec_curve_infos[i].name; i++) {\n\t\tif (ec_curve_infos[i].size == bits)\n\t\t\tbreak;\n\t}\n\tif (!ec_curve_infos[i].name) {\n\t\terror(\"%s: invalid key size %lu\", __func__, bits);\n\t\treturn NULL;\n\t}\n\tif (pkcs11_decode_hex(ec_curve_infos[i].oid_encoded, &ecparams,\n\t    &ecparams_size) == -1) {\n\t\terror(\"%s: invalid oid\", __func__);\n\t\treturn NULL;\n\t}\n\n\tFILL_ATTR(tpub, npub, CKA_TOKEN, &true_val, sizeof(true_val));\n\tFILL_ATTR(tpub, npub, CKA_LABEL, plabel, strlen(plabel));\n\tFILL_ATTR(tpub, npub, CKA_ENCRYPT, &false_val, sizeof(false_val));\n\tFILL_ATTR(tpub, npub, CKA_VERIFY, &true_val, sizeof(true_val));\n\tFILL_ATTR(tpub, npub, CKA_VERIFY_RECOVER, &false_val,\n\t    sizeof(false_val));\n\tFILL_ATTR(tpub, npub, CKA_WRAP, &false_val, sizeof(false_val));\n\tFILL_ATTR(tpub, npub, CKA_DERIVE, &false_val, sizeof(false_val));\n\tFILL_ATTR(tpub, npub, CKA_EC_PARAMS, ecparams, ecparams_size);\n\tFILL_ATTR(tpub, npub, CKA_ID, &keyid, sizeof(keyid));\n\n\tFILL_ATTR(tpriv, npriv, CKA_TOKEN, &true_val, sizeof(true_val));\n\tFILL_ATTR(tpriv, npriv, CKA_LABEL, plabel, strlen(plabel));\n\tFILL_ATTR(tpriv, npriv, CKA_PRIVATE, &true_val, sizeof(true_val));\n\tFILL_ATTR(tpriv, npriv, CKA_SENSITIVE, &true_val, sizeof(true_val));\n\tFILL_ATTR(tpriv, npriv, CKA_DECRYPT, &false_val, sizeof(false_val));\n\tFILL_ATTR(tpriv, npriv, CKA_SIGN, &true_val, sizeof(true_val));\n\tFILL_ATTR(tpriv, npriv, CKA_SIGN_RECOVER, &false_val,\n\t    sizeof(false_val));\n\tFILL_ATTR(tpriv, npriv, CKA_UNWRAP, &false_val, sizeof(false_val));\n\tFILL_ATTR(tpriv, npriv, CKA_DERIVE, &false_val, sizeof(false_val));\n\tFILL_ATTR(tpriv, npriv, CKA_ID, &keyid, sizeof(keyid));\n\n\tf = p->function_list;\n\tsi = &p->slotinfo[slotidx];\n\tsession = si->session;\n\n\tif ((rv = f->C_GenerateKeyPair(session, &mech, tpub, npub, tpriv, npriv,\n\t    &pubKey, &privKey)) != CKR_OK) {\n\t\terror(\"%s: key generation failed: error 0x%lx\", __func__, rv);\n\t\t*err = rv;\n\t\treturn NULL;\n\t}\n\n\treturn pkcs11_fetch_ecdsa_pubkey(p, slotidx, &pubKey);\n}\n#endif /* WITH_PKCS11_KEYGEN */\n\n/*\n * register a new provider, fails if provider already exists. if\n * keyp is provided, fetch keys.\n */\nstatic int\npkcs11_register_provider(char *provider_id, char *pin, struct sshkey ***keyp,\n    struct pkcs11_provider **providerp, CK_ULONG user)\n{\n\tint nkeys, need_finalize = 0;\n\tint ret = -1;\n\tstruct pkcs11_provider *p = NULL;\n\tvoid *handle = NULL;\n\tCK_RV (*getfunctionlist)(CK_FUNCTION_LIST **);\n\tCK_RV rv;\n\tCK_FUNCTION_LIST *f = NULL;\n\tCK_TOKEN_INFO *token;\n\tCK_ULONG i;\n\n\tif (providerp == NULL)\n\t\tgoto fail;\n\t*providerp = NULL;\n\n\tif (keyp != NULL)\n\t\t*keyp = NULL;\n\n\tif (pkcs11_provider_lookup(provider_id) != NULL) {\n\t\tdebug(\"%s: provider already registered: %s\",\n\t\t    __func__, provider_id);\n\t\tgoto fail;\n\t}\n\t/* open shared pkcs11-library */\n\tif ((handle = dlopen(provider_id, RTLD_NOW)) == NULL) {\n\t\terror(\"dlopen %s failed: %s\", provider_id, dlerror());\n\t\tgoto fail;\n\t}\n\tif ((getfunctionlist = dlsym(handle, \"C_GetFunctionList\")) == NULL) {\n\t\terror(\"dlsym(C_GetFunctionList) failed: %s\", dlerror());\n\t\tgoto fail;\n\t}\n\tp = xcalloc(1, sizeof(*p));\n\tp->name = xstrdup(provider_id);\n\tp->handle = handle;\n\t/* setup the pkcs11 callbacks */\n\tif ((rv = (*getfunctionlist)(&f)) != CKR_OK) {\n\t\terror(\"C_GetFunctionList for provider %s failed: %lu\",\n\t\t    provider_id, rv);\n\t\tgoto fail;\n\t}\n\tp->function_list = f;\n\tif ((rv = f->C_Initialize(NULL)) != CKR_OK) {\n\t\terror(\"C_Initialize for provider %s failed: %lu\",\n\t\t    provider_id, rv);\n\t\tgoto fail;\n\t}\n\tneed_finalize = 1;\n\tif ((rv = f->C_GetInfo(&p->info)) != CKR_OK) {\n\t\terror(\"C_GetInfo for provider %s failed: %lu\",\n\t\t    provider_id, rv);\n\t\tgoto fail;\n\t}\n\trmspace(p->info.manufacturerID, sizeof(p->info.manufacturerID));\n\trmspace(p->info.libraryDescription, sizeof(p->info.libraryDescription));\n\tdebug(\"provider %s: manufacturerID <%s> cryptokiVersion %d.%d\"\n\t    \" libraryDescription <%s> libraryVersion %d.%d\",\n\t    provider_id,\n\t    p->info.manufacturerID,\n\t    p->info.cryptokiVersion.major,\n\t    p->info.cryptokiVersion.minor,\n\t    p->info.libraryDescription,\n\t    p->info.libraryVersion.major,\n\t    p->info.libraryVersion.minor);\n\tif ((rv = f->C_GetSlotList(CK_TRUE, NULL, &p->nslots)) != CKR_OK) {\n\t\terror(\"C_GetSlotList failed: %lu\", rv);\n\t\tgoto fail;\n\t}\n\tif (p->nslots == 0) {\n\t\tdebug(\"%s: provider %s returned no slots\", __func__,\n\t\t    provider_id);\n\t\tret = -SSH_PKCS11_ERR_NO_SLOTS;\n\t\tgoto fail;\n\t}\n\tp->slotlist = xcalloc(p->nslots, sizeof(CK_SLOT_ID));\n\tif ((rv = f->C_GetSlotList(CK_TRUE, p->slotlist, &p->nslots))\n\t    != CKR_OK) {\n\t\terror(\"C_GetSlotList for provider %s failed: %lu\",\n\t\t    provider_id, rv);\n\t\tgoto fail;\n\t}\n\tp->slotinfo = xcalloc(p->nslots, sizeof(struct pkcs11_slotinfo));\n\tp->valid = 1;\n\tnkeys = 0;\n\tfor (i = 0; i < p->nslots; i++) {\n\t\ttoken = &p->slotinfo[i].token;\n\t\tif ((rv = f->C_GetTokenInfo(p->slotlist[i], token))\n\t\t    != CKR_OK) {\n\t\t\terror(\"C_GetTokenInfo for provider %s slot %lu \"\n\t\t\t    \"failed: %lu\", provider_id, (unsigned long)i, rv);\n\t\t\tcontinue;\n\t\t}\n\t\tif ((token->flags & CKF_TOKEN_INITIALIZED) == 0) {\n\t\t\tdebug2(\"%s: ignoring uninitialised token in \"\n\t\t\t    \"provider %s slot %lu\", __func__,\n\t\t\t    provider_id, (unsigned long)i);\n\t\t\tcontinue;\n\t\t}\n\t\trmspace(token->label, sizeof(token->label));\n\t\trmspace(token->manufacturerID, sizeof(token->manufacturerID));\n\t\trmspace(token->model, sizeof(token->model));\n\t\trmspace(token->serialNumber, sizeof(token->serialNumber));\n\t\tdebug(\"provider %s slot %lu: label <%s> manufacturerID <%s> \"\n\t\t    \"model <%s> serial <%s> flags 0x%lx\",\n\t\t    provider_id, (unsigned long)i,\n\t\t    token->label, token->manufacturerID, token->model,\n\t\t    token->serialNumber, token->flags);\n\t\t/*\n\t\t * open session, login with pin and retrieve public\n\t\t * keys (if keyp is provided)\n\t\t */\n\t\tif ((ret = pkcs11_open_session(p, i, pin, user)) != 0 ||\n\t\t    keyp == NULL)\n\t\t\tcontinue;\n\t\tpkcs11_fetch_keys(p, i, keyp, &nkeys);\n\t\tpkcs11_fetch_certs(p, i, keyp, &nkeys);\n\t\tif (nkeys == 0 && !p->slotinfo[i].logged_in &&\n\t\t    pkcs11_interactive) {\n\t\t\t/*\n\t\t\t * Some tokens require login before they will\n\t\t\t * expose keys.\n\t\t\t */\n\t\t\tif (pkcs11_login_slot(p, &p->slotinfo[i],\n\t\t\t    CKU_USER) < 0) {\n\t\t\t\terror(\"login failed\");\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tpkcs11_fetch_keys(p, i, keyp, &nkeys);\n\t\t\tpkcs11_fetch_certs(p, i, keyp, &nkeys);\n\t\t}\n\t}\n\n\t/* now owned by caller */\n\t*providerp = p;\n\n\tTAILQ_INSERT_TAIL(&pkcs11_providers, p, next);\n\tp->refcount++;\t/* add to provider list */\n\n\treturn (nkeys);\nfail:\n\tif (need_finalize && (rv = f->C_Finalize(NULL)) != CKR_OK)\n\t\terror(\"C_Finalize for provider %s failed: %lu\",\n\t\t    provider_id, rv);\n\tif (p) {\n\t\tfree(p->name);\n\t\tfree(p->slotlist);\n\t\tfree(p->slotinfo);\n\t\tfree(p);\n\t}\n\tif (handle)\n\t\tdlclose(handle);\n\treturn (ret);\n}\n\n/*\n * register a new provider and get number of keys hold by the token,\n * fails if provider already exists\n */\nint\npkcs11_add_provider(char *provider_id, char *pin, struct sshkey ***keyp)\n{\n\tstruct pkcs11_provider *p = NULL;\n\tint nkeys;\n\n\tnkeys = pkcs11_register_provider(provider_id, pin, keyp, &p, CKU_USER);\n\n\t/* no keys found or some other error, de-register provider */\n\tif (nkeys <= 0 && p != NULL) {\n\t\tTAILQ_REMOVE(&pkcs11_providers, p, next);\n\t\tpkcs11_provider_finalize(p);\n\t\tpkcs11_provider_unref(p);\n\t}\n\tif (nkeys == 0)\n\t\tdebug(\"%s: provider %s returned no keys\", __func__,\n\t\t    provider_id);\n\n\treturn (nkeys);\n}\n\n#ifdef WITH_PKCS11_KEYGEN\nstruct sshkey *\npkcs11_gakp(char *provider_id, char *pin, unsigned int slotidx, char *label,\n    unsigned int type, unsigned int bits, unsigned char keyid, u_int32_t *err)\n{\n\tstruct pkcs11_provider\t*p = NULL;\n\tstruct pkcs11_slotinfo\t*si;\n\tCK_FUNCTION_LIST\t*f;\n\tCK_SESSION_HANDLE\t session;\n\tstruct sshkey\t\t*k = NULL;\n\tint\t\t\t ret = -1, reset_pin = 0, reset_provider = 0;\n\tCK_RV\t\t\t rv;\n\n\t*err = 0;\n\n\tif ((p = pkcs11_provider_lookup(provider_id)) != NULL)\n\t\tdebug(\"%s: provider \\\"%s\\\" available\", __func__, provider_id);\n\telse if ((ret = pkcs11_register_provider(provider_id, pin, NULL, &p,\n\t    CKU_SO)) < 0) {\n\t\tdebug(\"%s: could not register provider %s\", __func__,\n\t\t    provider_id);\n\t\tgoto out;\n\t} else\n\t\treset_provider = 1;\n\n\tf = p->function_list;\n\tsi = &p->slotinfo[slotidx];\n\tsession = si->session;\n\n\tif ((rv = f->C_SetOperationState(session , pin, strlen(pin),\n\t    CK_INVALID_HANDLE, CK_INVALID_HANDLE)) != CKR_OK) {\n\t\tdebug(\"%s: could not supply SO pin: %lu\", __func__, rv);\n\t\treset_pin = 0;\n\t} else\n\t\treset_pin = 1;\n\n\tswitch (type) {\n\tcase KEY_RSA:\n\t\tif ((k = pkcs11_rsa_generate_private_key(p, slotidx, label,\n\t\t    bits, keyid, err)) == NULL) {\n\t\t\tdebug(\"%s: failed to generate RSA key\", __func__);\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tcase KEY_ECDSA:\n\t\tif ((k = pkcs11_ecdsa_generate_private_key(p, slotidx, label,\n\t\t    bits, keyid, err)) == NULL) {\n\t\t\tdebug(\"%s: failed to generate ECDSA key\", __func__);\n\t\t\tgoto out;\n\t\t}\n\t\tbreak;\n\tdefault:\n\t\t*err = SSH_PKCS11_ERR_GENERIC;\n\t\tdebug(\"%s: unknown type %d\", __func__, type);\n\t\tgoto out;\n\t}\n\nout:\n\tif (reset_pin)\n\t\tf->C_SetOperationState(session , NULL, 0, CK_INVALID_HANDLE,\n\t\t    CK_INVALID_HANDLE);\n\n\tif (reset_provider)\n\t\tpkcs11_del_provider(provider_id);\n\n\treturn (k);\n}\n\nstruct sshkey *\npkcs11_destroy_keypair(char *provider_id, char *pin, unsigned long slotidx,\n    unsigned char keyid, u_int32_t *err)\n{\n\tstruct pkcs11_provider\t*p = NULL;\n\tstruct pkcs11_slotinfo\t*si;\n\tstruct sshkey\t\t*k = NULL;\n\tint\t\t\t reset_pin = 0, reset_provider = 0;\n\tCK_ULONG\t\t nattrs;\n\tCK_FUNCTION_LIST\t*f;\n\tCK_SESSION_HANDLE\t session;\n\tCK_ATTRIBUTE\t\t attrs[16];\n\tCK_OBJECT_CLASS\t\t key_class;\n\tCK_KEY_TYPE\t\t key_type;\n\tCK_OBJECT_HANDLE\t obj = CK_INVALID_HANDLE;\n\tCK_RV\t\t\t rv;\n\n\t*err = 0;\n\n\tif ((p = pkcs11_provider_lookup(provider_id)) != NULL) {\n\t\tdebug(\"%s: using provider \\\"%s\\\"\", __func__, provider_id);\n\t} else if (pkcs11_register_provider(provider_id, pin, NULL, &p,\n\t    CKU_SO) < 0) {\n\t\tdebug(\"%s: could not register provider %s\", __func__,\n\t\t    provider_id);\n\t\tgoto out;\n\t} else\n\t\treset_provider = 1;\n\n\tf = p->function_list;\n\tsi = &p->slotinfo[slotidx];\n\tsession = si->session;\n\n\tif ((rv = f->C_SetOperationState(session , pin, strlen(pin),\n\t    CK_INVALID_HANDLE, CK_INVALID_HANDLE)) != CKR_OK) {\n\t\tdebug(\"%s: could not supply SO pin: %lu\", __func__, rv);\n\t\treset_pin = 0;\n\t} else\n\t\treset_pin = 1;\n\n\t/* private key */\n\tnattrs = 0;\n\tkey_class = CKO_PRIVATE_KEY;\n\tFILL_ATTR(attrs, nattrs, CKA_CLASS, &key_class, sizeof(key_class));\n\tFILL_ATTR(attrs, nattrs, CKA_ID, &keyid, sizeof(keyid));\n\n\tif (pkcs11_find(p, slotidx, attrs, nattrs, &obj) == 0 &&\n\t    obj != CK_INVALID_HANDLE) {\n\t\tif ((rv = f->C_DestroyObject(session, obj)) != CKR_OK) {\n\t\t\tdebug(\"%s: could not destroy private key 0x%hhx\",\n\t\t\t    __func__, keyid);\n\t\t\t*err = rv;\n\t\t\tgoto out;\n\t\t}\n\t}\n\n\t/* public key */\n\tnattrs = 0;\n\tkey_class = CKO_PUBLIC_KEY;\n\tFILL_ATTR(attrs, nattrs, CKA_CLASS, &key_class, sizeof(key_class));\n\tFILL_ATTR(attrs, nattrs, CKA_ID, &keyid, sizeof(keyid));\n\n\tif (pkcs11_find(p, slotidx, attrs, nattrs, &obj) == 0 &&\n\t    obj != CK_INVALID_HANDLE) {\n\n\t\t/* get key type */\n\t\tnattrs = 0;\n\t\tFILL_ATTR(attrs, nattrs, CKA_KEY_TYPE, &key_type,\n\t\t    sizeof(key_type));\n\t\trv = f->C_GetAttributeValue(session, obj, attrs, nattrs);\n\t\tif (rv != CKR_OK) {\n\t\t\tdebug(\"%s: could not get key type of public key 0x%hhx\",\n\t\t\t    __func__, keyid);\n\t\t\t*err = rv;\n\t\t\tkey_type = -1;\n\t\t}\n\t\tif (key_type == CKK_RSA)\n\t\t\tk = pkcs11_fetch_rsa_pubkey(p, slotidx, &obj);\n\t\telse if (key_type == CKK_ECDSA)\n\t\t\tk = pkcs11_fetch_ecdsa_pubkey(p, slotidx, &obj);\n\n\t\tif ((rv = f->C_DestroyObject(session, obj)) != CKR_OK) {\n\t\t\tdebug(\"%s: could not destroy public key 0x%hhx\",\n\t\t\t    __func__, keyid);\n\t\t\t*err = rv;\n\t\t\tgoto out;\n\t\t}\n\t}\n\nout:\n\tif (reset_pin)\n\t\tf->C_SetOperationState(session , NULL, 0, CK_INVALID_HANDLE,\n\t\t    CK_INVALID_HANDLE);\n\n\tif (reset_provider)\n\t\tpkcs11_del_provider(provider_id);\n\n\treturn (k);\n}\n#endif /* WITH_PKCS11_KEYGEN */\n#else /* ENABLE_PKCS11 */\n\n#include <sys/types.h>\n#include <stdarg.h>\n#include <stdio.h>\n\n#include \"log.h\"\n#include \"sshkey.h\"\n\nint\npkcs11_init(int interactive)\n{\n\terror(\"%s: dlopen() not supported\", __func__);\n\treturn (-1);\n}\n\nint\npkcs11_add_provider(char *provider_id, char *pin, struct sshkey ***keyp)\n{\n\terror(\"%s: dlopen() not supported\", __func__);\n\treturn (-1);\n}\n\nvoid\npkcs11_terminate(void)\n{\n\terror(\"%s: dlopen() not supported\", __func__);\n}\n#endif /* ENABLE_PKCS11 */\n"
    },
    "skipped": [],
    "total_files": 675
}