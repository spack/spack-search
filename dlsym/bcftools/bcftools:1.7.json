{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-bcftools-1.7-zhzmf2i3yok7bgtj5c5johzkk5aoof3l/spack-src/vcfplugin.c": "/*  vcfplugin.c -- plugin modules for operating on VCF/BCF files.\n\n    Copyright (C) 2013-2017 Genome Research Ltd.\n\n    Author: Petr Danecek <pd3@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.  */\n\n#include \"config.h\"\n#include <stdio.h>\n#include <strings.h>\n#include <unistd.h>\n#include <getopt.h>\n#include <ctype.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/stat.h>\n#include <sys/types.h>\n#include <dirent.h>\n#include <math.h>\n#include <htslib/vcf.h>\n#include <htslib/synced_bcf_reader.h>\n#include <htslib/kseq.h>\n#include <htslib/khash_str2int.h>\n#include <dlfcn.h>\n#include \"bcftools.h\"\n#include \"vcmp.h\"\n#include \"filter.h\"\n\n#ifdef ENABLE_BCF_PLUGINS\n\ntypedef struct _plugin_t plugin_t;\n\n/**\n *   Plugin API:\n *   ----------\n *   const char *about(void)\n *      - short description used by 'bcftools plugin -lv'\n *\n *   const char *usage(void)\n *      - longer description used by 'bcftools +name -h'\n *\n *   int run(int argc, char **argv)\n *      - if implemented, the control is immediately handed over to the plugin,\n *      none of the init/process/destroy functions is called.  Return 0 on\n *      success or non-zero value on error.\n *\n *   int init(int argc, char **argv, bcf_hdr_t *in_hdr, bcf_hdr_t *out_hdr)\n *      - called once at startup, allows to initialize local variables.\n *      Return 1 to suppress normal VCF/BCF header output, -1 on critical\n *      errors, 0 otherwise.\n *\n *   bcf1_t *process(bcf1_t *rec)\n *      - called for each VCF record, return NULL for no output\n *\n *   void destroy(void)\n *      - called after all lines have been processed to clean up\n */\ntypedef void (*dl_version_f) (const char **, const char **);\ntypedef int (*dl_run_f) (int, char **);\ntypedef int (*dl_init_f) (int, char **, bcf_hdr_t *, bcf_hdr_t *);\ntypedef char* (*dl_about_f) (void);\ntypedef char* (*dl_usage_f) (void);\ntypedef bcf1_t* (*dl_process_f) (bcf1_t *);\ntypedef void (*dl_destroy_f) (void);\n\nstruct _plugin_t\n{\n    int argc;\n    char *name, **argv;\n    dl_version_f version;\n    dl_run_f run;\n    dl_init_f init;\n    dl_about_f about;\n    dl_usage_f usage;\n    dl_process_f process;\n    dl_destroy_f destroy;\n    void *handle;\n};\n\n\nstruct _args_t;\n\ntypedef struct _rm_tag_t\n{\n    char *key;\n    int hdr_id;\n    void (*handler)(struct _args_t *, bcf1_t *, struct _rm_tag_t *);\n}\nrm_tag_t;\n\ntypedef struct\n{\n    char **cols;\n    int ncols, mcols;\n    char **als;\n    int nals, mals;\n    kstring_t line;\n    int rid, start, end;\n}\nannot_line_t;\n\ntypedef struct _annot_col_t\n{\n    int icol, replace;\n    char *hdr_key;\n    int (*setter)(struct _args_t *, bcf1_t *, struct _annot_col_t *, void*);\n}\nannot_col_t;\n\n// Logic of the filters: include or exclude sites which match the filters?\n#define FLT_INCLUDE 1\n#define FLT_EXCLUDE 2\n\ntypedef struct _args_t\n{\n    bcf_srs_t *files;\n    bcf_hdr_t *hdr, *hdr_out;\n    htsFile *out_fh;\n    int output_type, n_threads;\n\n    filter_t *filter;\n    char *filter_str;\n    int filter_logic;   // include or exclude sites which match the filters? One of FLT_INCLUDE/FLT_EXCLUDE\n\n    plugin_t plugin;\n    int nplugin_paths;\n    char **plugin_paths;\n\n    char **argv, *output_fname, *regions_list, *targets_list;\n    int argc, drop_header, verbose, record_cmd_line;\n}\nargs_t;\n\nchar *msprintf(const char *fmt, ...);\n\nstatic void add_plugin_paths(args_t *args, const char *path)\n{\n    while (1)\n    {\n        size_t len = strcspn(path, \":\");\n\n        if ( len == 0 )\n        {\n#ifdef PLUGINPATH\n            add_plugin_paths(args, PLUGINPATH);\n#endif\n        }\n        else\n        {\n            char *dir = (char *) malloc(len + 1);\n            strncpy(dir, path, len);\n            dir[len] = '\\0';\n\n            struct stat st;\n            if ( stat(dir, &st) == 0 )\n            {\n                args->plugin_paths = (char**) realloc(args->plugin_paths,sizeof(char*)*(args->nplugin_paths+1));\n                args->plugin_paths[args->nplugin_paths] = dir;\n                args->nplugin_paths++;\n                if ( args->verbose > 1 ) fprintf(stderr, \"plugin directory %s .. ok\\n\", dir);\n            }\n            else\n            {\n                if ( args->verbose > 1 ) fprintf(stderr, \"plugin directory %s .. %s\\n\", dir, strerror(errno));\n                free(dir);\n            }\n\n        }\n\n        path += len;\n        if ( *path == ':' ) path++;\n        else break;\n    }\n}\n\nstatic void init_plugin_paths(args_t *args)\n{\n    if ( args->nplugin_paths!=-1 ) return;\n\n    args->nplugin_paths = 0;\n    args->plugin_paths = NULL;\n\n    char *path = getenv(\"BCFTOOLS_PLUGINS\");\n    add_plugin_paths(args, path ? path : \"\");\n}\n\nstatic void *dlopen_plugin(args_t *args, const char *fname)\n{\n    init_plugin_paths(args);\n\n    void *handle;\n    char *tmp;\n    if ( fname[0]!='/' )    // not an absolute path\n    {\n        int i;\n        for (i=0; i<args->nplugin_paths; i++)\n        {\n\t    tmp = msprintf(\"%s/%s%s\", args->plugin_paths[i], fname, PLUGIN_EXT);\n            handle = dlopen(tmp, RTLD_NOW); // valgrind complains about unfreed memory, not our problem though\n            if ( args->verbose > 1 )\n            {\n                if ( !handle ) fprintf(stderr,\"%s:\\n\\tdlopen   .. %s\\n\", tmp,dlerror());\n                else fprintf(stderr,\"%s:\\n\\tdlopen   .. ok\\n\", tmp);\n            }\n            free(tmp);\n            if ( handle ) return handle;\n        }\n    }\n\n    handle = dlopen(fname, RTLD_NOW);\n    if ( args->verbose > 1 )\n    {\n        if ( !handle ) fprintf(stderr,\"%s:\\n\\tdlopen   .. %s\\n\", fname,dlerror());\n        else fprintf(stderr,\"%s:\\n\\tdlopen   .. ok\\n\", fname);\n    }\n\n    return handle;\n}\n\nstatic void print_plugin_usage_hint(void)\n{\n    fprintf(stderr, \"\\nNo functional bcftools plugins were found\");\n    if ( !getenv(\"BCFTOOLS_PLUGINS\") )\n        fprintf(stderr,\". The environment variable BCFTOOLS_PLUGINS is not set.\\n\\n\");\n    else\n        fprintf(stderr,\n                \" in\\n\\tBCFTOOLS_PLUGINS=\\\"%s\\\".\\n\\n\"\n                \"- Is the plugin path correct?\\n\\n\"\n                \"- Run \\\"bcftools plugin -lv\\\" for more detailed error output.\\n\"\n                \"\\n\",\n                getenv(\"BCFTOOLS_PLUGINS\")\n               );\n}\n\nstatic int load_plugin(args_t *args, const char *fname, int exit_on_error, plugin_t *plugin)\n{\n    plugin->name = strdup(fname);\n\n    plugin->handle = dlopen_plugin(args, fname);\n    if ( !plugin->handle )\n    {\n        if ( exit_on_error )\n        {\n            print_plugin_usage_hint();\n            error(\"Could not load \\\"%s\\\".\\n\\n\", fname);\n        }\n        return -1;\n    }\n\n    dlerror();\n    plugin->init = (dl_init_f) dlsym(plugin->handle, \"init\");\n    char *ret = dlerror();\n    if ( ret )\n        plugin->init = NULL;\n    else\n        if ( args->verbose > 1 ) fprintf(stderr,\"\\tinit     .. ok\\n\");\n\n    plugin->run = (dl_run_f) dlsym(plugin->handle, \"run\");\n    ret = dlerror();\n    if ( ret )\n        plugin->run = NULL;\n    else\n        if ( args->verbose > 1 ) fprintf(stderr,\"\\trun      .. ok\\n\");\n\n    if ( !plugin->init && !plugin->run )\n    {\n        if ( exit_on_error ) error(\"Could not initialize %s, neither run or init found \\n\", plugin->name);\n        else if ( args->verbose > 1 ) fprintf(stderr,\"\\tinit/run .. not found\\n\");\n        return -1;\n    }\n\n    plugin->version = (dl_version_f) dlsym(plugin->handle, \"version\");\n    ret = dlerror();\n    if ( ret )\n    {\n        if ( exit_on_error ) error(\"Could not initialize %s, version string not found\\n\", plugin->name);\n        else if ( args->verbose > 1 ) fprintf(stderr,\"\\tversion  .. not found\\n\");\n        return -1;\n    }\n\n    plugin->about = (dl_about_f) dlsym(plugin->handle, \"about\");\n    ret = dlerror();\n    if ( ret )\n    {\n        if ( exit_on_error ) error(\"Could not initialize %s: %s\\n\", plugin->name, ret);\n        return -1;\n    }\n\n    plugin->usage = (dl_about_f) dlsym(plugin->handle, \"usage\");\n    ret = dlerror();\n    if ( ret )\n        plugin->usage = plugin->about;\n\n    if ( plugin->run ) return 0;\n\n    plugin->process = (dl_process_f) dlsym(plugin->handle, \"process\");\n    ret = dlerror();\n    if ( ret )\n    {\n        if ( exit_on_error ) error(\"Could not initialize %s: %s\\n\", plugin->name, ret);\n        return -1;\n    }\n\n    plugin->destroy = (dl_destroy_f) dlsym(plugin->handle, \"destroy\");\n    ret = dlerror();\n    if ( ret )\n    {\n        if ( exit_on_error ) error(\"Could not initialize %s: %s\\n\", plugin->name, ret);\n        return -1;\n    }\n\n    return 0;\n}\n\nstatic void init_plugin(args_t *args)\n{\n    static int warned_bcftools = 0, warned_htslib = 0;\n\n    int ret = args->plugin.init(args->plugin.argc,args->plugin.argv,args->hdr,args->hdr_out);\n    if ( ret<0 ) error(\"The plugin exited with an error.\\n\");\n    const char *bver, *hver;\n    args->plugin.version(&bver, &hver);\n    if ( strcmp(bver,bcftools_version()) && !warned_bcftools )\n    {\n        fprintf(stderr,\"WARNING: bcftools version mismatch .. bcftools at %s, the plugin \\\"%s\\\" at %s\\n\", bcftools_version(),args->plugin.name,bver);\n        warned_bcftools = 1;\n    }\n    if ( strcmp(hver,hts_version()) && !warned_htslib )\n    {\n        fprintf(stderr,\"WARNING: htslib version mismatch .. bcftools at %s, the plugin \\\"%s\\\" at %s\\n\", hts_version(),args->plugin.name,hver);\n        warned_htslib = 1;\n    }\n    args->drop_header += ret;\n}\n\nstatic int cmp_plugin_name(const void *p1, const void *p2)\n{\n    plugin_t *a = (plugin_t*) p1;\n    plugin_t *b = (plugin_t*) p2;\n    return strcmp(a->name,b->name);\n}\n\nstatic int list_plugins(args_t *args)\n{\n    plugin_t *plugins = NULL;\n    int nplugins = 0, mplugins = 0;\n\n    init_plugin_paths(args);\n\n    kstring_t str = {0,0,0};\n    int plugin_ext_len = strlen(PLUGIN_EXT);\n    int i;\n    for (i=0; i<args->nplugin_paths; i++)\n    {\n        DIR *dp = opendir(args->plugin_paths[i]);\n        if ( dp==NULL ) continue;\n\n        struct dirent *ep;\n        while ( (ep=readdir(dp)) )\n        {\n            int len = strlen(ep->d_name);\n            if ( strcasecmp(PLUGIN_EXT,ep->d_name+len-plugin_ext_len) ) continue;\n            str.l = 0;\n            ksprintf(&str,\"%s/%s\", args->plugin_paths[i],ep->d_name);\n            hts_expand(plugin_t, nplugins+1, mplugins, plugins);\n            if ( load_plugin(args, str.s, 0, &plugins[nplugins]) < 0 ) continue;\n            nplugins++;\n            str.l = 0;\n            kputs(ep->d_name, &str);\n            int l = str.l - 1;\n            while ( l>=0 && str.s[l]!='.' ) l--;\n            if ( l>=0 ) str.s[l] = 0;\n            free(plugins[nplugins-1].name);\n            plugins[nplugins-1].name = strdup(str.s);  // use a short name\n        }\n        closedir(dp);\n    }\n    if ( nplugins )\n    {\n        qsort(plugins, nplugins, sizeof(plugins[0]), cmp_plugin_name);\n\n        for (i=0; i<nplugins; i++)\n        {\n            if ( args->verbose )\n                printf(\"\\n-- %s --\\n%s\", plugins[i].name, plugins[i].about());\n            else\n                printf(\"%s\\n\", plugins[i].name);\n        }\n        if ( args->verbose ) printf(\"\\n\");\n    }\n    else\n        print_plugin_usage_hint();\n    free(str.s);\n    return nplugins ? 0 : 1;\n}\n\nstatic void init_data(args_t *args)\n{\n    args->hdr = args->files->readers[0].header;\n    args->hdr_out = bcf_hdr_dup(args->hdr);\n\n    init_plugin(args);\n\n    if ( args->filter_str )\n        args->filter = filter_init(args->hdr, args->filter_str);\n\n    if (args->record_cmd_line) bcf_hdr_append_version(args->hdr_out, args->argc, args->argv, \"bcftools_plugin\");\n    if ( !args->drop_header )\n    {\n        args->out_fh = hts_open(args->output_fname,hts_bcf_wmode(args->output_type));\n        if ( args->out_fh == NULL ) error(\"Can't write to \\\"%s\\\": %s\\n\", args->output_fname, strerror(errno));\n        if ( args->n_threads ) hts_set_threads(args->out_fh, args->n_threads);\n        bcf_hdr_write(args->out_fh, args->hdr_out);\n    }\n}\n\nstatic void destroy_data(args_t *args)\n{\n    free(args->plugin.name);\n    if ( args->plugin.destroy ) args->plugin.destroy();\n    dlclose(args->plugin.handle);\n    if ( args->hdr_out ) bcf_hdr_destroy(args->hdr_out);\n    if ( args->nplugin_paths>0 )\n    {\n        int i;\n        for (i=0; i<args->nplugin_paths; i++) free(args->plugin_paths[i]);\n        free(args->plugin_paths);\n    }\n    if ( args->filter )\n        filter_destroy(args->filter);\n    if (args->out_fh) hts_close(args->out_fh);\n}\n\nstatic void usage(args_t *args)\n{\n    fprintf(stderr, \"\\n\");\n    fprintf(stderr, \"About:   Run user defined plugin\\n\");\n    fprintf(stderr, \"Usage:   bcftools plugin <name> [OPTIONS] <file> [-- PLUGIN_OPTIONS]\\n\");\n    fprintf(stderr, \"         bcftools +name [OPTIONS] <file>  [-- PLUGIN_OPTIONS]\\n\");\n    fprintf(stderr, \"\\n\");\n    fprintf(stderr, \"VCF input options:\\n\");\n    fprintf(stderr, \"   -e, --exclude <expr>        exclude sites for which the expression is true\\n\");\n    fprintf(stderr, \"   -i, --include <expr>        select sites for which the expression is true\\n\");\n    fprintf(stderr, \"   -r, --regions <region>      restrict to comma-separated list of regions\\n\");\n    fprintf(stderr, \"   -R, --regions-file <file>   restrict to regions listed in a file\\n\");\n    fprintf(stderr, \"   -t, --targets <region>      similar to -r but streams rather than index-jumps\\n\");\n    fprintf(stderr, \"   -T, --targets-file <file>   similar to -R but streams rather than index-jumps\\n\");\n    fprintf(stderr, \"VCF output options:\\n\");\n    fprintf(stderr, \"       --no-version            do not append version and command line to the header\\n\");\n    fprintf(stderr, \"   -o, --output <file>         write output to a file [standard output]\\n\");\n    fprintf(stderr, \"   -O, --output-type <type>    'b' compressed BCF; 'u' uncompressed BCF; 'z' compressed VCF; 'v' uncompressed VCF [v]\\n\");\n    fprintf(stderr, \"       --threads <int>         number of extra output compression threads [0]\\n\");\n    fprintf(stderr, \"Plugin options:\\n\");\n    fprintf(stderr, \"   -h, --help                  list plugin's options\\n\");\n    fprintf(stderr, \"   -l, --list-plugins          list available plugins. See BCFTOOLS_PLUGINS environment variable and man page for details\\n\");\n    fprintf(stderr, \"   -v, --verbose               print verbose information, -vv increases verbosity\\n\");\n    fprintf(stderr, \"   -V, --version               print version string and exit\\n\");\n    fprintf(stderr, \"\\n\");\n    exit(1);\n}\n\nstatic int is_verbose(int argc, char *argv[])\n{\n    int c, verbose = 0, opterr_ori = opterr;\n    static struct option loptions[] =\n    {\n        {\"verbose\",no_argument,NULL,'v'},\n        {NULL,0,NULL,0}\n    };\n    opterr = 0;\n    while ((c = getopt_long(argc, argv, \"-v\",loptions,NULL)) >= 0)\n    {\n        switch (c) {\n            case 'v': verbose++; break;\n            case 1:\n            default: break;\n        }\n    }\n    opterr = opterr_ori;\n    optind = 0;\n    return verbose;\n}\nint main_plugin(int argc, char *argv[])\n{\n    int c;\n    args_t *args  = (args_t*) calloc(1,sizeof(args_t));\n    args->argc    = argc; args->argv = argv;\n    args->output_fname = \"-\";\n    args->output_type = FT_VCF;\n    args->n_threads = 0;\n    args->record_cmd_line = 1;\n    args->nplugin_paths = -1;\n    int regions_is_file = 0, targets_is_file = 0, plist_only = 0, usage_only = 0, version_only = 0;\n\n    if ( argc==1 ) usage(args);\n\n    char *plugin_name = NULL;\n    if ( argv[1][0]!='-' )\n    {\n        args->verbose = is_verbose(argc, argv);\n        plugin_name = argv[1]; \n        argc--; \n        argv++; \n        load_plugin(args, plugin_name, 1, &args->plugin);\n        if ( args->plugin.run )\n        {\n            int ret = args->plugin.run(argc, argv);\n            destroy_data(args);\n            free(args);\n            return ret;\n        }\n    }\n\n    static struct option loptions[] =\n    {\n        {\"version\",no_argument,NULL,'V'},\n        {\"verbose\",no_argument,NULL,'v'},\n        {\"help\",no_argument,NULL,'h'},\n        {\"list-plugins\",no_argument,NULL,'l'},\n        {\"output\",required_argument,NULL,'o'},\n        {\"output-type\",required_argument,NULL,'O'},\n        {\"threads\",required_argument,NULL,9},\n        {\"include\",required_argument,NULL,'i'},\n        {\"exclude\",required_argument,NULL,'e'},\n        {\"regions\",required_argument,NULL,'r'},\n        {\"regions-file\",required_argument,NULL,'R'},\n        {\"targets\",required_argument,NULL,'t'},\n        {\"targets-file\",required_argument,NULL,'T'},\n        {\"no-version\",no_argument,NULL,8},\n        {NULL,0,NULL,0}\n    };\n    while ((c = getopt_long(argc, argv, \"h?o:O:r:R:t:T:li:e:vV\",loptions,NULL)) >= 0)\n    {\n        switch (c) {\n            case 'V': version_only = 1; break;\n            case 'v': args->verbose++; break;\n            case 'o': args->output_fname = optarg; break;\n            case 'O':\n                switch (optarg[0]) {\n                    case 'b': args->output_type = FT_BCF_GZ; break;\n                    case 'u': args->output_type = FT_BCF; break;\n                    case 'z': args->output_type = FT_VCF_GZ; break;\n                    case 'v': args->output_type = FT_VCF; break;\n                    default: error(\"The output type \\\"%s\\\" not recognised\\n\", optarg);\n                };\n                break;\n            case 'e': args->filter_str = optarg; args->filter_logic |= FLT_EXCLUDE; break;\n            case 'i': args->filter_str = optarg; args->filter_logic |= FLT_INCLUDE; break;\n            case 'r': args->regions_list = optarg; break;\n            case 'R': args->regions_list = optarg; regions_is_file = 1; break;\n            case 't': args->targets_list = optarg; break;\n            case 'T': args->targets_list = optarg; targets_is_file = 1; break;\n            case 'l': plist_only = 1; break;\n            case  9 : args->n_threads = strtol(optarg, 0, 0); break;\n            case  8 : args->record_cmd_line = 0; break;\n            case '?':\n            case 'h': usage_only = 1; break;\n            default: error(\"Unknown argument: %s\\n\", optarg);\n        }\n    }\n    if ( plist_only )  return list_plugins(args);\n    if ( usage_only && ! plugin_name ) usage(args);\n\n    if ( version_only )\n    {\n        const char *bver, *hver;\n        args->plugin.version(&bver, &hver);\n        printf(\"bcftools  %s using htslib %s\\n\", bcftools_version(), hts_version());\n        printf(\"plugin at %s using htslib %s\\n\\n\", bver, hver);\n        return 0;\n    }\n\n    if ( usage_only )\n    {\n        if ( args->plugin.usage )\n            fprintf(stderr,\"%s\",args->plugin.usage());\n        else\n            fprintf(stderr,\"Usage: bcftools +%s [General Options] -- [Plugin Options]\\n\",plugin_name);\n        return 0;\n    }\n\n    char *fname = NULL;\n    if ( optind>=argc || argv[optind][0]=='-' )\n    {\n        if ( !isatty(fileno((FILE *)stdin)) ) fname = \"-\";  // reading from stdin\n        else usage(args);\n        args->plugin.argc = argc - optind + 1;\n        args->plugin.argv = argv + optind - 1;\n    }\n    else\n    {\n        fname = argv[optind];\n        args->plugin.argc = argc - optind;\n        args->plugin.argv = argv + optind;\n    }\n    optind = 0;\n\n    args->files = bcf_sr_init();\n    if ( args->regions_list )\n    {\n        if ( bcf_sr_set_regions(args->files, args->regions_list, regions_is_file)<0 )\n            error(\"Failed to read the regions: %s\\n\", args->regions_list);\n    }\n    if ( args->targets_list )\n    {\n        if ( bcf_sr_set_targets(args->files, args->targets_list, targets_is_file, 0)<0 )\n            error(\"Failed to read the targets: %s\\n\", args->targets_list);\n        args->files->collapse |= COLLAPSE_SOME;\n    }\n    if ( !bcf_sr_add_reader(args->files, fname) ) error(\"Failed to open %s: %s\\n\", fname,bcf_sr_strerror(args->files->errnum));\n\n    init_data(args);\n    while ( bcf_sr_next_line(args->files) )\n    {\n        bcf1_t *line = bcf_sr_get_line(args->files,0);\n        if ( args->filter )\n        {\n            int pass = filter_test(args->filter, line, NULL);\n            if ( args->filter_logic & FLT_EXCLUDE ) pass = pass ? 0 : 1;\n            if ( !pass ) continue;\n        }\n        line = args->plugin.process(line);\n        if ( line )\n        {\n            if ( line->errcode ) error(\"[E::main_plugin] Unchecked error (%d), exiting\\n\",line->errcode);\n            bcf_write1(args->out_fh, args->hdr_out, line);\n        }\n    }\n    destroy_data(args);\n    bcf_sr_destroy(args->files);\n    free(args);\n    return 0;\n}\n\n#else /* ENABLE_BCF_PLUGINS */\n\nint main_plugin(int argc, char *argv[])\n{\n    fprintf(stderr, \"bcftools plugins are disabled.  To use them, you will need to rebuild\\n\"\n\t    \"bcftools from the source distribution with plugins enabled.\\n\");\n    return 1;\n}\n\n#endif /* ENABLE_BCF_PLUGINS */\n",
        "/tmp/vanessa/spack-stage/spack-stage-bcftools-1.7-zhzmf2i3yok7bgtj5c5johzkk5aoof3l/spack-src/htslib-1.7/plugin.c": "/*  plugin.c -- low-level path parsing and plugin functions.\n\n    Copyright (C) 2015 Genome Research Ltd.\n\n    Author: John Marshall <jm18@sanger.ac.uk>\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL\nTHE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\nFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\nDEALINGS IN THE SOFTWARE.  */\n\n#include <config.h>\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n\n#include <dirent.h>\n#include <dlfcn.h>\n\n#include \"hts_internal.h\"\n#include \"htslib/kstring.h\"\n\n#ifndef PLUGINPATH\n#define PLUGINPATH \"\"\n#endif\n\nstatic DIR *open_nextdir(struct hts_path_itr *itr)\n{\n    DIR *dir;\n\n    while (1) {\n        const char *colon = strchr(itr->pathdir, ':');\n        if (colon == NULL) return NULL;\n\n        itr->entry.l = 0;\n        kputsn(itr->pathdir, colon - itr->pathdir, &itr->entry);\n        itr->pathdir = &colon[1];\n        if (itr->entry.l == 0) continue;\n\n        dir = opendir(itr->entry.s);\n        if (dir) break;\n\n        if (hts_verbose >= 4)\n            fprintf(stderr,\n                    \"[W::hts_path_itr] can't scan directory \\\"%s\\\": %s\\n\",\n                    itr->entry.s, strerror(errno));\n    }\n\n    if (itr->entry.s[itr->entry.l-1] != '/') kputc('/', &itr->entry);\n    itr->entry_dir_l = itr->entry.l;\n    return dir;\n}\n\nvoid hts_path_itr_setup(struct hts_path_itr *itr, const char *path,\n        const char *builtin_path, const char *prefix, size_t prefix_len,\n        const char *suffix, size_t suffix_len)\n{\n    itr->prefix = prefix;\n    itr->prefix_len = prefix_len;\n\n    if (suffix) itr->suffix = suffix, itr->suffix_len = suffix_len;\n    else itr->suffix = PLUGIN_EXT, itr->suffix_len = strlen(PLUGIN_EXT);\n\n    itr->path.l = itr->path.m = 0; itr->path.s = NULL;\n    itr->entry.l = itr->entry.m = 0; itr->entry.s = NULL;\n\n    if (! builtin_path) builtin_path = PLUGINPATH;\n    if (! path) {\n        path = getenv(\"HTS_PATH\");\n        if (! path) path = \"\";\n    }\n\n    while (1) {\n        size_t len = strcspn(path, \":\");\n        if (len == 0) kputs(builtin_path, &itr->path);\n        else kputsn(path, len, &itr->path);\n        kputc(':', &itr->path);\n\n        path += len;\n        if (*path == ':') path++;\n        else break;\n    }\n\n    // Note that ':' now terminates entries rather than separates them\n    itr->pathdir = itr->path.s;\n    itr->dirv = open_nextdir(itr);\n}\n\nconst char *hts_path_itr_next(struct hts_path_itr *itr)\n{\n    while (itr->dirv) {\n        struct dirent *e;\n        while ((e = readdir((DIR *) itr->dirv)) != NULL) {\n            size_t d_name_len = strlen(e->d_name);\n            if (strncmp(e->d_name, itr->prefix, itr->prefix_len) == 0 &&\n                d_name_len >= itr->suffix_len &&\n                strncmp(e->d_name + d_name_len - itr->suffix_len, itr->suffix,\n                        itr->suffix_len) == 0) {\n                itr->entry.l = itr->entry_dir_l;\n                kputs(e->d_name, &itr->entry);\n                return itr->entry.s;\n            }\n        }\n\n        closedir((DIR *) itr->dirv);\n        itr->dirv = open_nextdir(itr);\n    }\n\n    itr->pathdir = NULL;\n    free(itr->path.s); itr->path.s = NULL;\n    free(itr->entry.s); itr->entry.s = NULL;\n    return NULL;\n}\n\n\n#ifndef RTLD_NOLOAD\n#define RTLD_NOLOAD 0\n#endif\n\nvoid *load_plugin(void **pluginp, const char *filename, const char *symbol)\n{\n    void *lib = dlopen(filename, RTLD_NOW | RTLD_LOCAL);\n    if (lib == NULL) goto error;\n\n    void *sym = dlsym(lib, symbol);\n    if (sym == NULL) {\n        // Reopen the plugin with RTLD_GLOBAL and check for uniquified symbol\n        void *libg = dlopen(filename, RTLD_NOLOAD | RTLD_NOW | RTLD_GLOBAL);\n        if (libg == NULL) goto error;\n        dlclose(lib);\n        lib = libg;\n\n        kstring_t symbolg = { 0, 0, NULL };\n        kputs(symbol, &symbolg);\n        kputc('_', &symbolg);\n        const char *slash = strrchr(filename, '/');\n        const char *basename = slash? slash+1 : filename;\n        kputsn(basename, strcspn(basename, \".-+\"), &symbolg);\n\n        sym = dlsym(lib, symbolg.s);\n        free(symbolg.s);\n        if (sym == NULL) goto error;\n    }\n\n    *pluginp = lib;\n    return sym;\n\nerror:\n    if (hts_verbose >= 4)\n        fprintf(stderr, \"[W::%s] can't load plugin \\\"%s\\\": %s\\n\",\n                __func__, filename, dlerror());\n    if (lib) dlclose(lib);\n    return NULL;\n}\n\nvoid *plugin_sym(void *plugin, const char *name, const char **errmsg)\n{\n    void *sym = dlsym(plugin, name);\n    if (sym == NULL) *errmsg = dlerror();\n    return sym;\n}\n\nvoid close_plugin(void *plugin)\n{\n    if (dlclose(plugin) != 0) {\n        if (hts_verbose >= 4)\n            fprintf(stderr, \"[W::%s] dlclose() failed: %s\\n\",\n                    __func__, dlerror());\n    }\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-bcftools-1.7-zhzmf2i3yok7bgtj5c5johzkk5aoof3l/spack-src/htslib-1.7/test/xx#large_aux_java.cram",
        "/tmp/vanessa/spack-stage/spack-stage-bcftools-1.7-zhzmf2i3yok7bgtj5c5johzkk5aoof3l/spack-src/htslib-1.7/test/auxf#values_java.cram",
        "/tmp/vanessa/spack-stage/spack-stage-bcftools-1.7-zhzmf2i3yok7bgtj5c5johzkk5aoof3l/spack-src/htslib-1.7/test/bgziptest.txt.gz.gzi",
        "/tmp/vanessa/spack-stage/spack-stage-bcftools-1.7-zhzmf2i3yok7bgtj5c5johzkk5aoof3l/spack-src/htslib-1.7/test/ce#5b_java.cram",
        "/tmp/vanessa/spack-stage/spack-stage-bcftools-1.7-zhzmf2i3yok7bgtj5c5johzkk5aoof3l/spack-src/htslib-1.7/test/bgziptest.txt.gz",
        "/tmp/vanessa/spack-stage/spack-stage-bcftools-1.7-zhzmf2i3yok7bgtj5c5johzkk5aoof3l/spack-src/test/ex1.gtf.gz",
        "/tmp/vanessa/spack-stage/spack-stage-bcftools-1.7-zhzmf2i3yok7bgtj5c5johzkk5aoof3l/spack-src/test/mpileup/mpileup.1.bam",
        "/tmp/vanessa/spack-stage/spack-stage-bcftools-1.7-zhzmf2i3yok7bgtj5c5johzkk5aoof3l/spack-src/test/mpileup/mpileup.3.cram",
        "/tmp/vanessa/spack-stage/spack-stage-bcftools-1.7-zhzmf2i3yok7bgtj5c5johzkk5aoof3l/spack-src/test/mpileup/mpileup.2.cram",
        "/tmp/vanessa/spack-stage/spack-stage-bcftools-1.7-zhzmf2i3yok7bgtj5c5johzkk5aoof3l/spack-src/test/mpileup/mpileup.2.bam.bai",
        "/tmp/vanessa/spack-stage/spack-stage-bcftools-1.7-zhzmf2i3yok7bgtj5c5johzkk5aoof3l/spack-src/test/mpileup/indel-AD.1.cram",
        "/tmp/vanessa/spack-stage/spack-stage-bcftools-1.7-zhzmf2i3yok7bgtj5c5johzkk5aoof3l/spack-src/test/mpileup/mpileup.3.bam.bai",
        "/tmp/vanessa/spack-stage/spack-stage-bcftools-1.7-zhzmf2i3yok7bgtj5c5johzkk5aoof3l/spack-src/test/mpileup/mpileup.1.cram.crai",
        "/tmp/vanessa/spack-stage/spack-stage-bcftools-1.7-zhzmf2i3yok7bgtj5c5johzkk5aoof3l/spack-src/test/mpileup/mpileup.4.cram",
        "/tmp/vanessa/spack-stage/spack-stage-bcftools-1.7-zhzmf2i3yok7bgtj5c5johzkk5aoof3l/spack-src/test/mpileup/mpileup.1.bam.bai",
        "/tmp/vanessa/spack-stage/spack-stage-bcftools-1.7-zhzmf2i3yok7bgtj5c5johzkk5aoof3l/spack-src/test/mpileup/indel-AD.1.bam",
        "/tmp/vanessa/spack-stage/spack-stage-bcftools-1.7-zhzmf2i3yok7bgtj5c5johzkk5aoof3l/spack-src/test/mpileup/mpileup.4.bam",
        "/tmp/vanessa/spack-stage/spack-stage-bcftools-1.7-zhzmf2i3yok7bgtj5c5johzkk5aoof3l/spack-src/test/mpileup/mpileup.2.bam",
        "/tmp/vanessa/spack-stage/spack-stage-bcftools-1.7-zhzmf2i3yok7bgtj5c5johzkk5aoof3l/spack-src/test/mpileup/mpileup.3.bam",
        "/tmp/vanessa/spack-stage/spack-stage-bcftools-1.7-zhzmf2i3yok7bgtj5c5johzkk5aoof3l/spack-src/test/mpileup/mpileup.3.cram.crai",
        "/tmp/vanessa/spack-stage/spack-stage-bcftools-1.7-zhzmf2i3yok7bgtj5c5johzkk5aoof3l/spack-src/test/mpileup/mpileup.1.cram",
        "/tmp/vanessa/spack-stage/spack-stage-bcftools-1.7-zhzmf2i3yok7bgtj5c5johzkk5aoof3l/spack-src/test/mpileup/mpileup.2.cram.crai"
    ],
    "total_files": 1071
}