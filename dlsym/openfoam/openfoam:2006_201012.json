{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/src/OSspecific/POSIX/POSIX.C": "/*---------------------------------------------------------------------------*\\\n  =========                 |\n  \\\\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox\n   \\\\    /   O peration     |\n    \\\\  /    A nd           | www.openfoam.com\n     \\\\/     M anipulation  |\n-------------------------------------------------------------------------------\n    Copyright (C) 2011-2017 OpenFOAM Foundation\n    Copyright (C) 2016-2020 OpenCFD Ltd.\n-------------------------------------------------------------------------------\nLicense\n    This file is part of OpenFOAM.\n\n    OpenFOAM is free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n    for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.\n\nDescription\n    POSIX versions of the functions declared in OSspecific.H\n\n\\*---------------------------------------------------------------------------*/\n\n#if defined(__sun__) && defined(__GNUC__)\n    // Not certain if this is still required\n    #define _SYS_VNODE_H\n#endif\n\n#include \"OSspecific.H\"\n#include \"POSIX.H\"\n#include \"fileName.H\"\n#include \"fileStat.H\"\n#include \"timer.H\"\n#include \"DynamicList.H\"\n#include \"CStringList.H\"\n#include \"IOstreams.H\"\n#include \"Pstream.H\"\n\n#include <fstream>\n#include <cstdlib>\n#include <cctype>\n\n#include <cstdio>\n#include <unistd.h>\n#include <dirent.h>\n#include <pwd.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/wait.h>\n#include <sys/stat.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <netinet/in.h>\n#include <dlfcn.h>\n\n#ifdef __APPLE__\n    #define EXT_SO  \"dylib\"\n    #include <mach-o/dyld.h>\n#else\n    #define EXT_SO  \"so\"\n\n    // PGI does not have __int128_t\n    #ifdef __PGIC__\n        #define __ILP32__\n    #endif\n\n    #include <link.h>\n#endif\n\n\n// * * * * * * * * * * * * * * Static Data Members * * * * * * * * * * * * * //\n\nnamespace Foam\n{\n    defineTypeNameAndDebug(POSIX, 0);\n}\n\nstatic bool cwdPreference_(Foam::debug::optimisationSwitch(\"cwd\", 0));\n\n\n// * * * * * * * * * * * * * * * Local Functions * * * * * * * * * * * * * * //\n\n// After a fork in system(), before the exec() do the following\n// - close stdin when executing in background (daemon-like)\n// - redirect stdout to stderr when infoDetailLevel == 0\nstatic inline void redirects(const bool bg)\n{\n    if (bg)\n    {\n        // Close stdin(0) - unchecked return value\n        (void) ::close(STDIN_FILENO);\n    }\n\n    // Redirect stdout(1) to stderr(2) '1>&2'\n    if (Foam::infoDetailLevel == 0)\n    {\n        // This is correct.  1>&2 means dup2(2, 1);\n        (void) ::dup2(STDERR_FILENO, STDOUT_FILENO);\n    }\n}\n\n\n// * * * * * * * * * * * * * * * * Local Classes * * * * * * * * * * * * * * //\n\nnamespace Foam\n{\nnamespace POSIX\n{\n\n//- A simple directory contents iterator\nclass directoryIterator\n{\n    DIR* dirptr_;\n\n    bool exists_;\n\n    bool hidden_;\n\n    std::string item_;\n\n    //- Accept file/dir name\n    inline bool accept() const\n    {\n        return\n        (\n            item_.size() && item_ != \".\" && item_ != \"..\"\n         && (hidden_ || item_[0] != '.')\n        );\n    }\n\n\npublic:\n\n    // Constructors\n\n        //- Construct for dirName, optionally allowing hidden files/dirs\n        directoryIterator(const fileName& dirName, bool allowHidden = false)\n        :\n            dirptr_(nullptr),\n            exists_(false),\n            hidden_(allowHidden),\n            item_()\n        {\n            if (!dirName.empty())\n            {\n                dirptr_ = ::opendir(dirName.c_str());\n                exists_ = (dirptr_ != nullptr);\n                next(); // Move to first element\n            }\n        }\n\n\n    //- Destructor\n    ~directoryIterator()\n    {\n        close();\n    }\n\n\n    // Member Functions\n\n        //- Directory open succeeded\n        bool exists() const\n        {\n            return exists_;\n        }\n\n        //- Directory pointer is valid\n        bool good() const\n        {\n            return dirptr_;\n        }\n\n        //- Close directory\n        void close()\n        {\n            if (dirptr_)\n            {\n                ::closedir(dirptr_);\n                dirptr_ = nullptr;\n            }\n        }\n\n        //- The current item\n        const std::string& val() const\n        {\n            return item_;\n        }\n\n        //- Read next item, always ignoring \".\" and \"..\" entries.\n        //  Normally also ignore hidden files/dirs (beginning with '.')\n        //  Automatically close when there are no more items\n        bool next()\n        {\n            struct dirent *list;\n\n            while (dirptr_ && (list = ::readdir(dirptr_)) != nullptr)\n            {\n                item_ = list->d_name;\n\n                if (accept())\n                {\n                    return true;\n                }\n            }\n            close(); // No more items\n\n            return false;\n        }\n\n\n    // Member Operators\n\n        //- Same as good()\n        operator bool() const\n        {\n            return good();\n        }\n\n        //- Same as val()\n        const std::string& operator*() const\n        {\n            return val();\n        }\n\n        //- Same as next()\n        directoryIterator& operator++()\n        {\n            next();\n            return *this;\n        }\n};\n\n} // End namespace POSIX\n} // End namespace Foam\n\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //\n\npid_t Foam::pid()\n{\n    return ::getpid();\n}\n\n\npid_t Foam::ppid()\n{\n    return ::getppid();\n}\n\n\npid_t Foam::pgid()\n{\n    return ::getpgrp();\n}\n\n\nbool Foam::hasEnv(const std::string& envName)\n{\n    // An empty envName => always false\n    return !envName.empty() && ::getenv(envName.c_str()) != nullptr;\n}\n\n\nFoam::string Foam::getEnv(const std::string& envName)\n{\n    // Ignore an empty envName => always \"\"\n    char* env = envName.empty() ? nullptr : ::getenv(envName.c_str());\n\n    if (env)\n    {\n        return string(env);\n    }\n\n    // Return null-constructed string rather than string::null\n    // to avoid cyclic dependencies in the construction of globals\n    return string();\n}\n\n\nbool Foam::setEnv\n(\n    const word& envName,\n    const std::string& value,\n    const bool overwrite\n)\n{\n    // Ignore an empty envName => always false\n    return\n    (\n        !envName.empty()\n     && ::setenv(envName.c_str(), value.c_str(), overwrite) == 0\n    );\n}\n\n\nFoam::string Foam::hostName(bool full)\n{\n    char buf[128];\n    ::gethostname(buf, sizeof(buf));\n\n    // implementation as per hostname from net-tools\n    if (full)\n    {\n        struct hostent *hp = ::gethostbyname(buf);\n        if (hp)\n        {\n            return hp->h_name;\n        }\n    }\n\n    return buf;\n}\n\n\nFoam::string Foam::domainName()\n{\n    char buf[128];\n    ::gethostname(buf, sizeof(buf));\n\n    // implementation as per hostname from net-tools\n    struct hostent *hp = ::gethostbyname(buf);\n    if (hp)\n    {\n        char *p = ::strchr(hp->h_name, '.');\n        if (p)\n        {\n            ++p;\n            return p;\n        }\n    }\n\n    return string::null;\n}\n\n\nFoam::string Foam::userName()\n{\n    struct passwd* pw = ::getpwuid(::getuid());\n    if (pw != nullptr)\n    {\n        return pw->pw_name;\n    }\n\n    return string();\n}\n\n\nbool Foam::isAdministrator()\n{\n    return (::geteuid() == 0);\n}\n\n\nFoam::fileName Foam::home()\n{\n    char* env = ::getenv(\"HOME\");\n    if (env)\n    {\n        return fileName(env);\n    }\n\n    struct passwd* pw = ::getpwuid(::getuid());\n    if (pw)\n    {\n        return pw->pw_dir;\n    }\n\n    return fileName();\n}\n\n\nFoam::fileName Foam::home(const std::string& userName)\n{\n    // An empty userName => same as home()\n    if (userName.empty())\n    {\n        return Foam::home();\n    }\n\n    struct passwd* pw = ::getpwnam(userName.c_str());\n    if (pw)\n    {\n        return pw->pw_dir;\n    }\n\n    return fileName();\n}\n\n\nnamespace Foam\n{\n\n//- The physical current working directory path name (pwd -P).\nstatic Foam::fileName cwd_P()\n{\n    label pathLengthLimit = POSIX::pathLengthChunk;\n    List<char> path(pathLengthLimit);\n\n    // Resize path if getcwd fails with an ERANGE error\n    while (pathLengthLimit == path.size())\n    {\n        if (::getcwd(path.data(), path.size()))\n        {\n            return path.data();\n        }\n        else if (errno == ERANGE)\n        {\n            // Increment path length up to the pathLengthMax limit\n            if\n            (\n                (pathLengthLimit += POSIX::pathLengthChunk)\n             >= POSIX::pathLengthMax\n            )\n            {\n                FatalErrorInFunction\n                    << \"Attempt to increase path length beyond limit of \"\n                    << POSIX::pathLengthMax\n                    << exit(FatalError);\n            }\n\n            path.resize(pathLengthLimit);\n        }\n        else\n        {\n            break;\n        }\n    }\n\n    FatalErrorInFunction\n        << \"Couldn't get the current working directory\"\n        << exit(FatalError);\n\n    return fileName();\n}\n\n\n//- The logical current working directory path name.\n// From the PWD environment, same as pwd -L.\nstatic Foam::fileName cwd_L()\n{\n    const char* env = ::getenv(\"PWD\");\n\n    // Basic check\n    if (!env || env[0] != '/')\n    {\n        WarningInFunction\n            << \"PWD is invalid - reverting to physical description\"\n            << nl;\n\n        return cwd_P();\n    }\n\n    fileName dir(env);\n\n    // Check for \"/.\"\n    for\n    (\n        std::string::size_type pos = 0;\n        std::string::npos != (pos = dir.find(\"/.\", pos));\n        /*nil*/\n    )\n    {\n        pos += 2;\n\n        if\n        (\n            // Ends in \"/.\" or has \"/./\"\n            !dir[pos] || dir[pos] == '/'\n\n            // Ends in \"/..\" or has \"/../\"\n         || (dir[pos] == '.' && (!dir[pos+1] || dir[pos+1] == '/'))\n        )\n        {\n            WarningInFunction\n                << \"PWD contains /. or /.. - reverting to physical description\"\n                << nl;\n\n            return cwd_P();\n        }\n    }\n\n    // Finally, verify that PWD actually corresponds to the \".\" directory\n    if (!fileStat(dir, true).sameINode(fileStat(\".\", true)))\n    {\n        WarningInFunction\n            << \"PWD is not the cwd() - reverting to physical description\"\n            << nl;\n\n        return cwd_P();\n    }\n\n\n    return fileName(dir);\n}\n\n} // End namespace Foam\n\n\nFoam::fileName Foam::cwd()\n{\n    return cwd(cwdPreference_);\n}\n\n\nFoam::fileName Foam::cwd(bool logical)\n{\n    if (logical)\n    {\n        return cwd_L();\n    }\n\n    return cwd_P();\n}\n\n\nbool Foam::chDir(const fileName& dir)\n{\n    // Ignore an empty dir name => always false\n    return !dir.empty() && ::chdir(dir.c_str()) == 0;\n}\n\n\nbool Foam::mkDir(const fileName& pathName, mode_t mode)\n{\n    if (POSIX::debug)\n    {\n        Pout<< FUNCTION_NAME << \" : pathName:\" << pathName << \" mode:\" << mode\n            << endl;\n        if ((POSIX::debug & 2) && !Pstream::master())\n        {\n            error::printStack(Pout);\n        }\n    }\n\n    // empty names are meaningless\n    if (pathName.empty())\n    {\n        return false;\n    }\n\n    // Construct path directory if does not exist\n    if (::mkdir(pathName.c_str(), mode) == 0)\n    {\n        // Directory made OK so return true\n        return true;\n    }\n\n    switch (errno)\n    {\n        case EPERM:\n        {\n            FatalErrorInFunction\n                << \"The filesystem containing \" << pathName\n                << \" does not support the creation of directories.\"\n                << exit(FatalError);\n            break;\n        }\n\n        case EEXIST:\n        {\n            // Directory already exists so simply return true\n            return true;\n        }\n\n        case EFAULT:\n        {\n            FatalErrorInFunction\n                << \"\" << pathName\n                << \" points outside your accessible address space.\"\n                << exit(FatalError);\n            break;\n        }\n\n        case EACCES:\n        {\n            FatalErrorInFunction\n                << \"The parent directory does not allow write \"\n                   \"permission to the process,\"<< nl\n                << \" or one of the directories in \" << pathName\n                << \" did not allow search (execute) permission.\"\n                << exit(FatalError);\n            break;\n        }\n\n        case ENAMETOOLONG:\n        {\n            FatalErrorInFunction\n                << \"\" << pathName << \" is too long.\"\n                << exit(FatalError);\n            break;\n        }\n\n        case ENOENT:\n        {\n            // Part of the path does not exist so try to create it\n            if (pathName.path().size() && mkDir(pathName.path(), mode))\n            {\n                return mkDir(pathName, mode);\n            }\n\n            FatalErrorInFunction\n                << \"Couldn't create directory \" << pathName\n                << exit(FatalError);\n            break;\n        }\n\n        case ENOTDIR:\n        {\n            FatalErrorInFunction\n                << \"A component used as a directory in \" << pathName\n                << \" is not, in fact, a directory.\"\n                << exit(FatalError);\n            break;\n        }\n\n        case ENOMEM:\n        {\n            FatalErrorInFunction\n                << \"Insufficient kernel memory was available to make directory \"\n                << pathName << '.'\n                << exit(FatalError);\n            break;\n        }\n\n        case EROFS:\n        {\n            FatalErrorInFunction\n                << \"\" << pathName\n                << \" refers to a file on a read-only filesystem.\"\n                << exit(FatalError);\n            break;\n        }\n\n        case ELOOP:\n        {\n            FatalErrorInFunction\n                << \"Too many symbolic links were encountered in resolving \"\n                << pathName << '.'\n                << exit(FatalError);\n            break;\n        }\n\n        case ENOSPC:\n        {\n            FatalErrorInFunction\n                << \"The device containing \" << pathName\n                << \" has no room for the new directory or \"\n                << \"the user's disk quota is exhausted.\"\n                << exit(FatalError);\n            break;\n        }\n\n        default:\n        {\n            FatalErrorInFunction\n                << \"Couldn't create directory \" << pathName\n                << exit(FatalError);\n            break;\n        }\n    }\n\n    return false;\n}\n\n\nbool Foam::chMod(const fileName& name, const mode_t m)\n{\n    if (POSIX::debug)\n    {\n        Pout<< FUNCTION_NAME << \" : name:\" << name << endl;\n        if ((POSIX::debug & 2) && !Pstream::master())\n        {\n            error::printStack(Pout);\n        }\n    }\n\n    // Ignore an empty name => always false\n    return !name.empty() && ::chmod(name.c_str(), m) == 0;\n}\n\n\nmode_t Foam::mode(const fileName& name, const bool followLink)\n{\n    if (POSIX::debug)\n    {\n        Pout<< FUNCTION_NAME << \" : name:\" << name << endl;\n        if ((POSIX::debug & 2) && !Pstream::master())\n        {\n            error::printStack(Pout);\n        }\n    }\n\n    // Ignore an empty name => always 0\n    if (!name.empty())\n    {\n        fileStat fileStatus(name, followLink);\n        if (fileStatus.valid())\n        {\n            return fileStatus.status().st_mode;\n        }\n    }\n\n    return 0;\n}\n\n\nFoam::fileName::Type Foam::type(const fileName& name, const bool followLink)\n{\n    // Ignore an empty name => always UNDEFINED\n    if (name.empty())\n    {\n        return fileName::UNDEFINED;\n    }\n\n    if (POSIX::debug)\n    {\n        Pout<< FUNCTION_NAME << \" : name:\" << name << endl;\n    }\n\n    mode_t m = mode(name, followLink);\n\n    if (S_ISREG(m))\n    {\n        return fileName::FILE;\n    }\n    else if (S_ISLNK(m))\n    {\n        return fileName::LINK;\n    }\n    else if (S_ISDIR(m))\n    {\n        return fileName::DIRECTORY;\n    }\n\n    return fileName::UNDEFINED;\n}\n\n\nbool Foam::exists\n(\n    const fileName& name,\n    const bool checkGzip,\n    const bool followLink\n)\n{\n    if (POSIX::debug)\n    {\n        Pout<< FUNCTION_NAME << \" : name:\" << name << \" checkGzip:\" << checkGzip\n            << endl;\n        if ((POSIX::debug & 2) && !Pstream::master())\n        {\n            error::printStack(Pout);\n        }\n    }\n\n    // Ignore an empty name => always false\n    return\n    (\n        !name.empty()\n     && (mode(name, followLink) || isFile(name, checkGzip, followLink))\n    );\n}\n\n\nbool Foam::isDir(const fileName& name, const bool followLink)\n{\n    if (POSIX::debug)\n    {\n        Pout<< FUNCTION_NAME << \" : name:\" << name << endl;\n        if ((POSIX::debug & 2) && !Pstream::master())\n        {\n            error::printStack(Pout);\n        }\n    }\n\n    // Ignore an empty name => always false\n    return !name.empty() && S_ISDIR(mode(name, followLink));\n}\n\n\nbool Foam::isFile\n(\n    const fileName& name,\n    const bool checkGzip,\n    const bool followLink\n)\n{\n    if (POSIX::debug)\n    {\n        Pout<< FUNCTION_NAME << \" : name:\" << name << \" checkGzip:\" << checkGzip\n            << endl;\n        if ((POSIX::debug & 2) && !Pstream::master())\n        {\n            error::printStack(Pout);\n        }\n    }\n\n    // Ignore an empty name => always false\n    return\n    (\n        !name.empty()\n     && (\n            S_ISREG(mode(name, followLink))\n         || (checkGzip && S_ISREG(mode(name + \".gz\", followLink)))\n        )\n    );\n}\n\n\noff_t Foam::fileSize(const fileName& name, const bool followLink)\n{\n    if (POSIX::debug)\n    {\n        Pout<< FUNCTION_NAME << \" : name:\" << name << endl;\n        if ((POSIX::debug & 2) && !Pstream::master())\n        {\n            error::printStack(Pout);\n        }\n    }\n\n    // Ignore an empty name\n    if (!name.empty())\n    {\n        fileStat fileStatus(name, followLink);\n        if (fileStatus.valid())\n        {\n            return fileStatus.status().st_size;\n        }\n    }\n\n    return -1;\n}\n\n\ntime_t Foam::lastModified(const fileName& name, const bool followLink)\n{\n    if (POSIX::debug)\n    {\n        Pout<< FUNCTION_NAME << \" : name:\" << name << endl;\n        if ((POSIX::debug & 2) && !Pstream::master())\n        {\n            error::printStack(Pout);\n        }\n    }\n\n    // Ignore an empty name\n    return name.empty() ? 0 : fileStat(name, followLink).modTime();\n}\n\n\ndouble Foam::highResLastModified(const fileName& name, const bool followLink)\n{\n    if (POSIX::debug)\n    {\n        Pout<< FUNCTION_NAME << \" : name:\" << name << endl;\n        if ((POSIX::debug & 2) && !Pstream::master())\n        {\n            error::printStack(Pout);\n        }\n    }\n\n    // Ignore an empty name\n    return name.empty() ? 0 : fileStat(name, followLink).dmodTime();\n}\n\n\nFoam::fileNameList Foam::readDir\n(\n    const fileName& directory,\n    const fileName::Type type,\n    const bool filtergz,\n    const bool followLink\n)\n{\n    // Initial filename list size and the increment when resizing the list\n    constexpr int maxNnames = 100;\n\n    // Basic sanity: cannot strip '.gz' from directory names\n    const bool stripgz = filtergz && (type != fileName::DIRECTORY);\n    const word extgz(\"gz\");\n\n    fileNameList dirEntries;\n\n    // Iterate contents (ignores an empty directory name)\n\n    POSIX::directoryIterator dirIter(directory);\n    if (!dirIter.exists())\n    {\n        if (POSIX::debug)\n        {\n            InfoInFunction\n                << \"cannot open directory \" << directory << endl;\n        }\n\n        return dirEntries;\n    }\n\n    if (POSIX::debug)\n    {\n        // InfoInFunction\n        Pout<< FUNCTION_NAME << \" : reading directory \" << directory << endl;\n        if ((POSIX::debug & 2) && !Pstream::master())\n        {\n            error::printStack(Pout);\n        }\n    }\n\n    label nFailed = 0;     // Entries with invalid characters\n    label nEntries = 0;    // Number of selected entries\n    dirEntries.resize(maxNnames);\n\n    // Process the directory entries\n    for (/*nil*/; dirIter; ++dirIter)\n    {\n        const std::string& item = *dirIter;\n\n        // Validate filename without spaces, quotes, etc in the name.\n        // No duplicate slashes to strip - dirent will not have them anyhow.\n\n        const fileName name(fileName::validate(item));\n        if (name != item)\n        {\n            ++nFailed;\n        }\n        else if\n        (\n            (type == fileName::DIRECTORY)\n         || (type == fileName::FILE && !fileName::isBackup(name))\n        )\n        {\n            if ((directory/name).type(followLink) == type)\n            {\n                if (nEntries >= dirEntries.size())\n                {\n                    dirEntries.resize(dirEntries.size() + maxNnames);\n                }\n\n                if (stripgz && name.hasExt(extgz))\n                {\n                    dirEntries[nEntries++] = name.lessExt();\n                }\n                else\n                {\n                    dirEntries[nEntries++] = name;\n                }\n            }\n        }\n    }\n\n    // Finalize the length of the entries list\n    dirEntries.resize(nEntries);\n\n    if (nFailed && POSIX::debug)\n    {\n        std::cerr\n            << \"Foam::readDir() : reading directory \" << directory << nl\n            << nFailed << \" entries with invalid characters in their name\"\n            << std::endl;\n    }\n\n    return dirEntries;\n}\n\n\nbool Foam::cp(const fileName& src, const fileName& dest, const bool followLink)\n{\n    if (POSIX::debug)\n    {\n        Pout<< FUNCTION_NAME << \" : src:\" << src << \" dest:\" << dest << endl;\n        if ((POSIX::debug & 2) && !Pstream::master())\n        {\n            error::printStack(Pout);\n        }\n    }\n\n    // Make sure source exists - this also handles an empty source name\n    if (!exists(src))\n    {\n        return false;\n    }\n\n    const fileName::Type srcType = src.type(followLink);\n\n    fileName destFile(dest);\n\n    // Check type of source file.\n    if (srcType == fileName::FILE)\n    {\n        // If dest is a directory, create the destination file name.\n        if (destFile.type() == fileName::DIRECTORY)\n        {\n            destFile /= src.name();\n        }\n\n        // Make sure the destination directory exists.\n        if (!isDir(destFile.path()) && !mkDir(destFile.path()))\n        {\n            return false;\n        }\n\n        // Open and check streams. Enforce binary for extra safety\n        std::ifstream srcStream(src, ios_base::in | ios_base::binary);\n        if (!srcStream)\n        {\n            return false;\n        }\n\n        std::ofstream destStream(destFile, ios_base::out | ios_base::binary);\n        if (!destStream)\n        {\n            return false;\n        }\n\n        // Copy character data.\n        char ch;\n        while (srcStream.get(ch))\n        {\n            destStream.put(ch);\n        }\n\n        // Final check.\n        if (!srcStream.eof() || !destStream)\n        {\n            return false;\n        }\n    }\n    else if (srcType == fileName::LINK)\n    {\n        // If dest is a directory, create the destination file name.\n        if (destFile.type() == fileName::DIRECTORY)\n        {\n            destFile /= src.name();\n        }\n\n        // Make sure the destination directory exists.\n        if (!isDir(destFile.path()) && !mkDir(destFile.path()))\n        {\n            return false;\n        }\n\n        ln(src, destFile);\n    }\n    else if (srcType == fileName::DIRECTORY)\n    {\n        // If dest is a directory, create the destination file name.\n        if (destFile.type() == fileName::DIRECTORY)\n        {\n            destFile /= src.components().last();\n        }\n\n        // Make sure the destination directory exists.\n        if (!isDir(destFile) && !mkDir(destFile))\n        {\n            return false;\n        }\n\n        char* realSrcPath = realpath(src.c_str(), nullptr);\n        char* realDestPath = realpath(destFile.c_str(), nullptr);\n        const bool samePath = strcmp(realSrcPath, realDestPath) == 0;\n\n        if (POSIX::debug && samePath)\n        {\n            InfoInFunction\n                << \"Attempt to copy \" << realSrcPath << \" to itself\" << endl;\n        }\n\n        if (realSrcPath)\n        {\n            free(realSrcPath);\n        }\n\n        if (realDestPath)\n        {\n            free(realDestPath);\n        }\n\n        // Do not copy over self when src is actually a link to dest\n        if (samePath)\n        {\n            return false;\n        }\n\n        // Copy files\n        fileNameList files = readDir(src, fileName::FILE, false, followLink);\n        for (const fileName& item : files)\n        {\n            if (POSIX::debug)\n            {\n                InfoInFunction\n                    << \"Copying : \" << src/item\n                    << \" to \" << destFile/item << endl;\n            }\n\n            // File to file.\n            cp(src/item, destFile/item, followLink);\n        }\n\n        // Copy sub directories.\n        fileNameList dirs = readDir\n        (\n            src,\n            fileName::DIRECTORY,\n            false,\n            followLink\n        );\n\n        for (const fileName& item : dirs)\n        {\n            if (POSIX::debug)\n            {\n                InfoInFunction\n                    << \"Copying : \" << src/item\n                    << \" to \" << destFile << endl;\n            }\n\n            // Dir to Dir.\n            cp(src/item, destFile, followLink);\n        }\n    }\n    else\n    {\n        return false;\n    }\n\n    return true;\n}\n\n\nbool Foam::ln(const fileName& src, const fileName& dst)\n{\n    if (POSIX::debug)\n    {\n        //InfoInFunction\n        Pout<< FUNCTION_NAME\n            << \" : Create softlink from : \" << src << \" to \" << dst << endl;\n        if ((POSIX::debug & 2) && !Pstream::master())\n        {\n            error::printStack(Pout);\n        }\n    }\n\n    if (src.empty())\n    {\n        WarningInFunction\n            << \"source name is empty: not linking.\" << endl;\n        return false;\n    }\n\n    if (dst.empty())\n    {\n        WarningInFunction\n            << \"destination name is empty: not linking.\" << endl;\n        return false;\n    }\n\n    if (exists(dst))\n    {\n        WarningInFunction\n            << \"destination \" << dst << \" already exists. Not linking.\"\n            << endl;\n        return false;\n    }\n\n    if (src.isAbsolute() && !exists(src))\n    {\n        WarningInFunction\n            << \"source \" << src << \" does not exist.\" << endl;\n        return false;\n    }\n\n    if (::symlink(src.c_str(), dst.c_str()) == 0)\n    {\n        return true;\n    }\n\n    WarningInFunction\n        << \"symlink from \" << src << \" to \" << dst << \" failed.\" << endl;\n    return false;\n}\n\n\nbool Foam::mv(const fileName& src, const fileName& dst, const bool followLink)\n{\n    if (POSIX::debug)\n    {\n        //InfoInFunction\n        Pout<< FUNCTION_NAME << \" : Move : \" << src << \" to \" << dst << endl;\n        if ((POSIX::debug & 2) && !Pstream::master())\n        {\n            error::printStack(Pout);\n        }\n    }\n\n    // Ignore an empty names => always false\n    if (src.empty() || dst.empty())\n    {\n        return false;\n    }\n\n    if\n    (\n        dst.type() == fileName::DIRECTORY\n     && src.type(followLink) != fileName::DIRECTORY\n    )\n    {\n        const fileName dstName(dst/src.name());\n\n        return (0 == std::rename(src.c_str(), dstName.c_str()));\n    }\n\n    return (0 == std::rename(src.c_str(), dst.c_str()));\n}\n\n\nbool Foam::mvBak(const fileName& src, const std::string& ext)\n{\n    if (POSIX::debug)\n    {\n        //InfoInFunction\n        Pout<< FUNCTION_NAME\n            << \" : moving : \" << src << \" to extension \" << ext << endl;\n        if ((POSIX::debug & 2) && !Pstream::master())\n        {\n            error::printStack(Pout);\n        }\n    }\n\n    // Ignore an empty name or extension => always false\n    if (src.empty() || ext.empty())\n    {\n        return false;\n    }\n\n    if (exists(src, false))\n    {\n        constexpr const int maxIndex = 99;\n        char index[3];\n\n        for (int n = 0; n <= maxIndex; ++n)\n        {\n            fileName dstName(src + \".\" + ext);\n            if (n)\n            {\n                ::sprintf(index, \"%02d\", n);\n                dstName += index;\n            }\n\n            // avoid overwriting existing files, except for the last\n            // possible index where we have no choice\n            if (!exists(dstName, false) || n == maxIndex)\n            {\n                return (0 == std::rename(src.c_str(), dstName.c_str()));\n            }\n        }\n    }\n\n    // fallthrough: nothing to do\n    return false;\n}\n\n\nbool Foam::rm(const fileName& file)\n{\n    if (POSIX::debug)\n    {\n        //InfoInFunction\n        Pout<< FUNCTION_NAME << \" : Removing : \" << file << endl;\n        if ((POSIX::debug & 2) && !Pstream::master())\n        {\n            error::printStack(Pout);\n        }\n    }\n\n    // Ignore an empty name => always false\n    if (file.empty())\n    {\n        return false;\n    }\n\n    // If removal of plain file name fails, try with .gz\n\n    return\n    (\n        0 == ::remove(file.c_str())\n     || 0 == ::remove((file + \".gz\").c_str())\n    );\n}\n\n\nbool Foam::rmDir(const fileName& directory, const bool silent)\n{\n    // Iterate contents (ignores an empty directory name)\n    // Also retain hidden files/dirs for removal\n\n    POSIX::directoryIterator dirIter(directory, true);\n    if (!dirIter.exists())\n    {\n        if (!silent)\n        {\n            WarningInFunction\n                << \"cannot open directory \" << directory << endl;\n        }\n\n        return false;\n    }\n\n    if (POSIX::debug)\n    {\n        //InfoInFunction\n        Pout<< FUNCTION_NAME << \" : removing directory \" << directory << endl;\n        if ((POSIX::debug & 2) && !Pstream::master())\n        {\n            error::printStack(Pout);\n        }\n    }\n\n    // Process each directory entry, counting any errors encountered\n    label nErrors = 0;\n\n    for (/*nil*/; dirIter; ++dirIter)\n    {\n        const std::string& item = *dirIter;\n\n        // Allow invalid characters (spaces, quotes, etc),\n        // otherwise we cannot remove subdirs with these types of names.\n        // -> const fileName path = directory/name; <-\n\n        const fileName path(fileName::concat(directory, item));\n\n        if (path.type(false) == fileName::DIRECTORY)\n        {\n            if (!rmDir(path, true))  // Only report errors at the top-level\n            {\n                ++nErrors;\n            }\n        }\n        else\n        {\n            if (!rm(path))\n            {\n                ++nErrors;\n            }\n        }\n    }\n\n    if (nErrors)\n    {\n        if (!silent)\n        {\n            WarningInFunction\n                << \"failed to remove directory \" << directory << nl\n                << \"could not remove \" << nErrors << \" sub-entries\" << endl;\n        }\n    }\n    else\n    {\n        if (!rm(directory))\n        {\n            ++nErrors;\n            if (!silent)\n            {\n                WarningInFunction\n                    << \"failed to remove directory \" << directory << endl;\n            }\n        }\n    }\n\n    // clean up\n    return !nErrors;\n}\n\n\nunsigned int Foam::sleep(const unsigned int sec)\n{\n    return ::sleep(sec);\n}\n\n\nvoid Foam::fdClose(const int fd)\n{\n    if (close(fd) != 0)\n    {\n        FatalErrorInFunction\n            << \"close error on \" << fd << endl\n            << abort(FatalError);\n    }\n}\n\n\nbool Foam::ping\n(\n    const std::string& destName,\n    const label destPort,\n    const label timeOut\n)\n{\n    struct hostent *hostPtr;\n    volatile int sockfd;\n    struct sockaddr_in destAddr;      // will hold the destination addr\n    u_int addr;\n\n    if ((hostPtr = ::gethostbyname(destName.c_str())) == nullptr)\n    {\n        FatalErrorInFunction\n            << \"gethostbyname error \" << h_errno << \" for host \" << destName\n            << abort(FatalError);\n    }\n\n    // Get first of the SLL of addresses\n    addr = (reinterpret_cast<struct in_addr*>(*(hostPtr->h_addr_list)))->s_addr;\n\n    // Allocate socket\n    sockfd = ::socket(AF_INET, SOCK_STREAM, 0);\n    if (sockfd < 0)\n    {\n        FatalErrorInFunction\n            << \"socket error\"\n            << abort(FatalError);\n    }\n\n    // Fill sockaddr_in structure with dest address and port\n    std::memset(reinterpret_cast<char *>(&destAddr), '\\0', sizeof(destAddr));\n    destAddr.sin_family = AF_INET;\n    destAddr.sin_port = htons(ushort(destPort));\n    destAddr.sin_addr.s_addr = addr;\n\n\n    timer myTimer(timeOut);\n\n    if (timedOut(myTimer))\n    {\n        // Setjmp from timer jumps back to here\n        fdClose(sockfd);\n        return false;\n    }\n\n    if\n    (\n        ::connect\n        (\n            sockfd,\n            reinterpret_cast<struct sockaddr*>(&destAddr),\n            sizeof(struct sockaddr)\n        ) != 0\n    )\n    {\n        // Connection refused. Check if network was actually used or not.\n\n        int connectErr = errno;\n\n        fdClose(sockfd);\n\n        if (connectErr == ECONNREFUSED)\n        {\n            return true;\n        }\n        //perror(\"connect\");\n\n        return false;\n    }\n\n    fdClose(sockfd);\n\n    return true;\n}\n\n\nbool Foam::ping(const std::string& host, const label timeOut)\n{\n    return ping(host, 222, timeOut) || ping(host, 22, timeOut);\n}\n\n\nnamespace Foam\n{\n//! \\cond fileScope\nstatic int waitpid(const pid_t pid)\n{\n    // child status, return code from the exec etc.\n    int status = 0;\n\n    // in parent - blocking wait\n    // modest treatment of signals (in child)\n    // treat 'stopped' like exit (suspend/continue)\n\n    while (true)\n    {\n        pid_t wpid = ::waitpid(pid, &status, WUNTRACED);\n\n        if (wpid == -1)\n        {\n            FatalErrorInFunction\n                << \"some error occurred in child\"\n                << exit(FatalError);\n            break;\n        }\n\n        if (WIFEXITED(status))\n        {\n            // child exited, get its return status\n            return WEXITSTATUS(status);\n        }\n\n        if (WIFSIGNALED(status))\n        {\n            // child terminated by some signal\n            return WTERMSIG(status);\n        }\n\n        if (WIFSTOPPED(status))\n        {\n            // child stopped by some signal\n            return WSTOPSIG(status);\n        }\n\n        FatalErrorInFunction\n            << \"programming error, status from waitpid() not handled: \"\n            << status\n            << exit(FatalError);\n    }\n\n    return -1;  // should not happen\n}\n//! \\endcond\n}\n\n\nint Foam::system(const std::string& command, const bool bg)\n{\n    if (command.empty())\n    {\n        // Treat an empty command as a successful no-op.\n        // From 'man sh' POSIX (man sh):\n        //   \"If the command_string operand is an empty string,\n        //    sh shall exit with a zero exit status.\"\n        return 0;\n    }\n\n    const pid_t child_pid = ::vfork();   // NB: vfork, not fork!\n\n    if (child_pid == -1)\n    {\n        FatalErrorInFunction\n            << \"vfork() failed for system command \" << command\n            << exit(FatalError);\n\n        return -1;  // fallback error value\n    }\n    else if (child_pid == 0)\n    {\n        // In child\n\n        // Close or redirect file descriptors\n        redirects(bg);\n\n        // execl uses the current environ\n        (void) ::execl\n        (\n            \"/bin/sh\",          // Path of the shell\n            \"sh\",               // Command-name (name for the shell)\n            \"-c\",               // Read commands from command_string operand\n            command.c_str(),    // Command string\n            reinterpret_cast<char*>(0)\n        );\n\n        // Obviously failed, since exec should not return\n        FatalErrorInFunction\n            << \"exec failed: \" << command\n            << exit(FatalError);\n\n        return -1;  // fallback error value\n    }\n\n\n    // In parent\n    // - started as background process, or blocking wait for the child\n\n    return (bg ? 0 : waitpid(child_pid));\n}\n\n\nint Foam::system(const CStringList& command, const bool bg)\n{\n    if (command.empty())\n    {\n        // Treat an empty command as a successful no-op.\n        // For consistency with POSIX (man sh) behaviour for (sh -c command),\n        // which is what is mostly being replicated here.\n        return 0;\n    }\n\n    // NB: use vfork, not fork!\n    // vfork behaves more like a thread and avoids copy-on-write problems\n    // triggered by fork.\n    // The normal system() command has a fork buried in it that causes\n    // issues with infiniband and openmpi etc.\n\n    const pid_t child_pid = ::vfork();\n\n    if (child_pid == -1)\n    {\n        FatalErrorInFunction\n            << \"vfork() failed for system command \" << command[0]\n            << exit(FatalError);\n\n        return -1;  // fallback error value\n    }\n    else if (child_pid == 0)\n    {\n        // In child\n\n        // Close or redirect file descriptors\n        redirects(bg);\n\n        // execvp searches the path, uses the current environ\n        (void) ::execvp(command[0], command.strings());\n\n        // Obviously failed, since exec should not return\n        FatalErrorInFunction\n            << \"exec(\" << command[0] << \", ...) failed\"\n            << exit(FatalError);\n\n        return -1;  // fallback error value\n    }\n\n\n    // In parent\n    // - started as background process, or blocking wait for the child\n\n    return (bg ? 0 : waitpid(child_pid));\n}\n\n\nint Foam::system(const Foam::UList<Foam::string>& command, const bool bg)\n{\n    if (command.empty())\n    {\n        // Treat an empty command as a successful no-op.\n        return 0;\n    }\n\n    // Make a deep copy as C-strings\n    const CStringList cmd(command);\n    return Foam::system(cmd, bg);\n}\n\n\nvoid* Foam::dlOpen(const fileName& libName, const bool check)\n{\n    constexpr int ldflags = (RTLD_LAZY|RTLD_GLOBAL);\n\n    if (POSIX::debug)\n    {\n        std::cout\n            << \"dlOpen(const fileName&)\"\n            << \" : dlopen of \" << libName << std::endl;\n    }\n\n    void* handle = ::dlopen(libName.c_str(), ldflags);\n\n    if (!handle)\n    {\n        fileName libso;\n\n        if\n        (\n            libName.find('/') == std::string::npos\n         && !libName.starts_with(\"lib\")\n        )\n        {\n            // Try with 'lib' prefix\n            libso = \"lib\" + libName;\n            handle = ::dlopen(libso.c_str(), ldflags);\n\n            if (POSIX::debug)\n            {\n                std::cout\n                    << \"dlOpen(const fileName&)\"\n                    << \" : dlopen of \" << libso << std::endl;\n            }\n        }\n        else\n        {\n            libso = libName;\n        }\n\n        // With canonical library extension (\"so\" or \"dylib\"), which remaps\n        // \"libXX\" to \"libXX.so\" as well as \"libXX.so\" -> \"libXX.dylib\"\n        if (!handle && !libso.hasExt(EXT_SO))\n        {\n            libso = libso.lessExt().ext(EXT_SO);\n            handle = ::dlopen(libso.c_str(), ldflags);\n\n            if (POSIX::debug)\n            {\n                std::cout\n                    << \"dlOpen(const fileName&)\"\n                    << \" : dlopen of \" << libso << std::endl;\n            }\n        }\n    }\n\n    if (!handle && check)\n    {\n        WarningInFunction\n            << \"dlopen error : \" << ::dlerror() << endl;\n    }\n\n    if (POSIX::debug)\n    {\n        std::cout\n            << \"dlOpen(const fileName&)\"\n            << \" : dlopen of \" << libName\n            << \" handle \" << handle << std::endl;\n    }\n\n    return handle;\n}\n\n\nvoid* Foam::dlOpen(const fileName& libName, std::string& errorMsg)\n{\n    // Call without emitting error message - we capture that ourselves\n    void* handle = Foam::dlOpen(libName, false);\n\n    if (!handle)\n    {\n        // Capture error message\n        errorMsg = ::dlerror();\n    }\n    else\n    {\n        // No errors\n        errorMsg.clear();\n    }\n\n    return handle;\n}\n\n\nFoam::label Foam::dlOpen\n(\n    std::initializer_list<fileName> libNames,\n    const bool check\n)\n{\n    label nLoaded = 0;\n\n    for (const fileName& libName : libNames)\n    {\n        if (Foam::dlOpen(libName, check))\n        {\n            ++nLoaded;\n        }\n    }\n\n    return nLoaded;\n}\n\n\nbool Foam::dlClose(void* handle)\n{\n    if (POSIX::debug)\n    {\n        std::cout\n            << \"dlClose(void*)\"\n            << \" : dlclose of handle \" << handle << std::endl;\n    }\n    return ::dlclose(handle) == 0;\n}\n\n\nvoid* Foam::dlSymFind(void* handle, const std::string& symbol, bool required)\n{\n    if (!required && (!handle || symbol.empty()))\n    {\n        return nullptr;\n    }\n\n    if (POSIX::debug)\n    {\n        std::cout\n            << \"dlSymFind(void*, const std::string&, bool)\"\n            << \" : dlsym of \" << symbol << std::endl;\n    }\n\n    // Clear any old errors - see manpage dlopen\n    (void) ::dlerror();\n\n    // Get address of symbol\n    void* fun = ::dlsym(handle, symbol.c_str());\n\n    // Any error?\n    char *err = ::dlerror();\n\n    if (err)\n    {\n        if (!required)\n        {\n            return nullptr;\n        }\n\n        WarningInFunction\n            << \"Cannot lookup symbol \" << symbol << \" : \" << err\n            << endl;\n    }\n\n    return fun;\n}\n\n\n#ifndef __APPLE__\nstatic int collectLibsCallback\n(\n    struct dl_phdr_info *info,\n    size_t size,\n    void *data\n)\n{\n    Foam::DynamicList<Foam::fileName>* ptr =\n        reinterpret_cast<Foam::DynamicList<Foam::fileName>*>(data);\n    ptr->append(info->dlpi_name);\n    return 0;\n}\n#endif\n\n\nFoam::fileNameList Foam::dlLoaded()\n{\n    DynamicList<fileName> libs;\n    #ifdef __APPLE__\n    for (uint32_t i=0; i < _dyld_image_count(); ++i)\n    {\n       libs.append(_dyld_get_image_name(i));\n    }\n    #else\n    dl_iterate_phdr(collectLibsCallback, &libs);\n    #endif\n\n    if (POSIX::debug)\n    {\n        std::cout\n            << \"dlLoaded()\"\n            << \" : determined loaded libraries :\" << libs.size() << std::endl;\n    }\n    return libs;\n}\n\n\n// ************************************************************************* //\n",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/src/OSspecific/MSwindows/MSwindows.C": "/*---------------------------------------------------------------------------*\\\n  =========                 |\n  \\\\      /  F ield         | OpenFOAM: The Open Source CFD Toolbox\n   \\\\    /   O peration     |\n    \\\\  /    A nd           | www.openfoam.com\n     \\\\/     M anipulation  |\n-------------------------------------------------------------------------------\n    Copyright (C) 2011-2017 OpenFOAM Foundation\n    Copyright (C) 2011 Symscape\n    Copyright (C) 2016-2020 OpenCFD Ltd.\n-------------------------------------------------------------------------------\nLicense\n    This file is part of OpenFOAM.\n\n    OpenFOAM is free software: you can redistribute it and/or modify it\n    under the terms of the GNU General Public License as published by\n    the Free Software Foundation, either version 3 of the License, or\n    (at your option) any later version.\n\n    OpenFOAM is distributed in the hope that it will be useful, but WITHOUT\n    ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n    FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n    for more details.\n\n    You should have received a copy of the GNU General Public License\n    along with OpenFOAM.  If not, see <http://www.gnu.org/licenses/>.\n\nDescription\n    MS-Windows versions of the functions declared in OSspecific.H\n\n\\*---------------------------------------------------------------------------*/\n\n#include \"OSspecific.H\"\n#include \"MSwindows.H\"\n#include \"fileName.H\"\n#include \"fileStat.H\"\n#include \"DynamicList.H\"\n#include \"CStringList.H\"\n#include \"IOstreams.H\"\n#include \"Pstream.H\"\n#undef DebugInfo    // Windows name clash with OpenFOAM messageStream\n\n#include <cassert>\n#include <cstdlib>\n#include <fstream>\n#include <unordered_map>\n\n// Windows headers\n#define WIN32_LEAN_AND_MEAN\n#include <csignal>\n#include <io.h>     // For _close\n#include <windows.h>\n\n#define EXT_SO  \"dll\"\n\n\n// * * * * * * * * * * * * * * Static Data Members * * * * * * * * * * * * * //\n\nnamespace Foam\n{\n    defineTypeNameAndDebug(MSwindows, 0);\n}\n\n\nnamespace Foam\n{\n    // Don't abort under windows, causes abort dialog to popup.\n    // Instead just exit with exitCode.\n    static void sigAbortHandler(int exitCode)\n    {\n        ::exit(exitCode);\n    }\n\n    static bool installAbortHandler()\n    {\n        // If it didn't succeed there's not much we can do,\n        // so don't check result.\n        ::signal(SIGABRT, &sigAbortHandler);\n        return true;\n    }\n\n    static bool const abortHandlerInstalled = installAbortHandler();\n\n\n    // Move file, overwriting existing\n    static bool renameFile(const fileName& src, const fileName& dst)\n    {\n        constexpr const int flags\n        (\n            MOVEFILE_COPY_ALLOWED\n          | MOVEFILE_REPLACE_EXISTING\n          | MOVEFILE_WRITE_THROUGH\n        );\n\n        // TODO: handle extra-long paths with ::MoveFileExW\n\n        return ::MoveFileExA(src.c_str(), dst.c_str(), flags);\n    }\n\n} // End namespace Foam\n\n\n// * * * * * * * * * * * * * * * * Local Classes * * * * * * * * * * * * * * //\n\nnamespace Foam\n{\nnamespace MSwindows\n{\n\n//- A simple directory contents iterator\nclass directoryIterator\n{\n    HANDLE handle_;\n\n    bool exists_;\n\n    bool hidden_;\n\n    std::string item_;\n\n    //- Accept file/dir name\n    inline bool accept() const\n    {\n        return\n        (\n            item_.size() && item_ != \".\" && item_ != \"..\"\n         && (hidden_ || item_[0] != '.')\n        );\n    }\n\n\npublic:\n\n    //- Construct for dirName, optionally allowing hidden files/dirs\n    directoryIterator(const fileName& dirName, bool allowHidden = false)\n    :\n        handle_(INVALID_HANDLE_VALUE),\n        exists_(false),\n        hidden_(allowHidden),\n        item_()\n    {\n        if (!dirName.empty())\n        {\n            WIN32_FIND_DATA findData;\n\n            handle_ = ::FindFirstFile((dirName/\"*\").c_str(), &findData);\n\n            if (good())\n            {\n                exists_ = true;\n                item_ = findData.cFileName;\n\n                // If first element is not acceptable, get another one\n                if (!accept())\n                {\n                    next();\n                }\n            }\n        }\n    }\n\n\n    //- Destructor\n    ~directoryIterator()\n    {\n        close();\n    }\n\n\n    // Member Functions\n\n        //- Directory existed for opening\n        bool exists() const\n        {\n            return exists_;\n        }\n\n        //- Directory pointer is valid\n        bool good() const\n        {\n            return (INVALID_HANDLE_VALUE != handle_);\n        }\n\n        //- Close directory\n        void close()\n        {\n            if (good())\n            {\n                ::FindClose(handle_);\n                handle_ = INVALID_HANDLE_VALUE;\n            }\n        }\n\n        //- The current item\n        const std::string& val() const\n        {\n            return item_;\n        }\n\n        //- Read next item, always ignoring \".\" and \"..\" entries.\n        //  Normally also ignore hidden files/dirs (beginning with '.')\n        //  Automatically close when it runs out of items\n        bool next()\n        {\n            if (good())\n            {\n                WIN32_FIND_DATA findData;\n\n                while (::FindNextFile(handle_, &findData))\n                {\n                    item_ = findData.cFileName;\n\n                    if (accept())\n                    {\n                        return true;\n                    }\n                }\n                close();  // No more items\n            }\n\n            return false;\n        }\n\n\n    // Member Operators\n\n        //- Same as good()\n        operator bool() const\n        {\n            return good();\n        }\n\n        //- Same as val()\n        const std::string& operator*() const\n        {\n            return val();\n        }\n\n        //- Same as next()\n        directoryIterator& operator++()\n        {\n            next();\n            return *this;\n        }\n};\n\n} // End namespace MSwindows\n} // End namespace Foam\n\n\n// * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * //\n\nstd::string Foam::MSwindows::lastError()\n{\n    // Retrieve the system error message for the last-error code\n\n    // Based on an example at:\n    // http://msdn2.microsoft.com/en-us/library/ms680582(VS.85).aspx\n\n    LPVOID lpMsgBuf;\n    DWORD dw = GetLastError();\n\n    FormatMessage\n    (\n        FORMAT_MESSAGE_ALLOCATE_BUFFER |\n        FORMAT_MESSAGE_FROM_SYSTEM |\n        FORMAT_MESSAGE_IGNORE_INSERTS,\n        NULL,  // source\n        dw,    // message-id\n        MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),  // language-id\n        reinterpret_cast<LPTSTR>(&lpMsgBuf),\n        0, NULL\n    );\n\n    const char* fmt = \"Error %d: %s\";\n\n    // Use snprintf with zero to establish the size (without '\\0') required\n    std::string output;\n\n    int n = ::snprintf(nullptr, 0, fmt, static_cast<LPCTSTR>(lpMsgBuf));\n\n    if (n > 0)\n    {\n        output.resize(n+1);\n\n        // Print directly into buffer\n        n = ::snprintf(&(output[0]), n+1, fmt, static_cast<LPCTSTR>(lpMsgBuf));\n        output.resize(n);\n    }\n\n    LocalFree(lpMsgBuf);\n\n    return output;\n}\n\n\nstd::string Foam::MSwindows::userName()\n{\n    const DWORD bufLen = 256;\n    TCHAR buf[bufLen];\n    DWORD len = bufLen;\n\n    if (::GetUserName(buf, &len))\n    {\n        return buf;\n    }\n\n    std::string str;\n\n    if\n    (\n        ERROR_INSUFFICIENT_BUFFER == ::GetLastError()\n     && len < 2048\n    )\n    {\n        // The len is with trailing '\\0'\n        str.resize(len);\n\n        // Retrieve directly into buffer\n        ::GetUserName(&(str[0]), &len);\n\n        // Without trailing '\\0'\n        str.resize(len-1);\n    }\n\n    return str;\n}\n\n\npid_t Foam::pid()\n{\n    const DWORD processId = ::GetCurrentProcessId();\n    return processId;\n}\n\n\npid_t Foam::ppid()\n{\n    // No equivalent under windows.\n\n    if (MSwindows::debug)\n    {\n        Info<< \"ppid not supported under MSwindows\" << endl;\n    }\n\n    return 0;\n}\n\n\npid_t Foam::pgid()\n{\n    // No equivalent under windows.\n\n    if (MSwindows::debug)\n    {\n        Info<< \"pgid not supported under MSwindows\" << endl;\n    }\n\n    return 0;\n}\n\n\nbool Foam::hasEnv(const std::string& envName)\n{\n    // An empty envName => always false\n    return !envName.empty() &&\n        ::GetEnvironmentVariable(envName.c_str(), nullptr, 0);\n}\n\n\nFoam::string Foam::getEnv(const std::string& envName)\n{\n    std::string env;\n\n    auto len = ::GetEnvironmentVariable(envName.c_str(), nullptr, 0);\n\n    // len [return] = size with trailing nul char, or zero on failure\n    if (len)\n    {\n        env.resize(len);\n\n        // len [in] = size with trailing nul char\n        // len [return] = size without trailing nul char\n        len = ::GetEnvironmentVariable(envName.c_str(), &(env[0]), len);\n\n        env.resize(len);\n        return fileName::validate(env);\n    }\n\n    return env;\n}\n\n\nbool Foam::setEnv\n(\n    const word& envName,\n    const std::string& value,\n    const bool overwrite\n)\n{\n    // Ignore an empty envName => always false\n    return\n    (\n        !envName.empty()\n     && ::SetEnvironmentVariable(envName.c_str(), value.c_str())\n    );\n}\n\n\nFoam::string Foam::hostName(bool)\n{\n    const DWORD bufLen = MAX_COMPUTERNAME_LENGTH + 1;\n    TCHAR buf[bufLen];\n    DWORD len = bufLen;\n\n    return ::GetComputerName(buf, &len) ? buf : string();\n}\n\n\nFoam::string Foam::domainName()\n{\n    // Could use ::gethostname and ::gethostbyname like POSIX.C, but would\n    // then need to link against ws_32. Prefer to minimize dependencies.\n\n    return string::null;\n}\n\n\nFoam::string Foam::userName()\n{\n    string name = Foam::getEnv(\"USERNAME\");\n\n    if (name.empty())\n    {\n        name = MSwindows::userName();\n    }\n\n    return name;\n}\n\n\nbool Foam::isAdministrator()\n{\n    // Assume worst case\n    return true;\n}\n\n\nFoam::fileName Foam::home()\n{\n    fileName env = Foam::getEnv(\"HOME\");\n\n    if (env.empty())\n    {\n        env  = Foam::getEnv(\"USERPROFILE\");\n    }\n\n    return env;\n}\n\n\nFoam::fileName Foam::home(const std::string& userName)\n{\n    return Foam::home();\n}\n\n\nFoam::fileName Foam::cwd()\n{\n    string path;\n    auto len = ::GetCurrentDirectory(0, nullptr);\n\n    // len [return] = size with trailing nul char, or zero on failure\n    if (len)\n    {\n        path.resize(len);\n\n        // len [in] = size with trailing nul char\n        // len [return] = size without trailing nul char\n        len = ::GetCurrentDirectory(len, &(path[0]));\n\n        path.resize(len);\n        return fileName::validate(path);\n    }\n\n    FatalErrorInFunction\n        << \"Couldn't get the current working directory\"\n        << exit(FatalError);\n\n    return fileName();\n}\n\n\nFoam::fileName Foam::cwd(bool logical)\n{\n    return Foam::cwd();\n}\n\n\nbool Foam::chDir(const fileName& dir)\n{\n    // Ignore an empty dir name => always false\n    return !dir.empty() && ::SetCurrentDirectory(dir.c_str());;\n}\n\n\nbool Foam::mkDir(const fileName& pathName, const mode_t mode)\n{\n    // empty names are meaningless\n    if (pathName.empty())\n    {\n        return false;\n    }\n\n    bool ok = ::CreateDirectory(pathName.c_str(), NULL);\n\n    if (ok)\n    {\n        Foam::chMod(pathName, mode);\n        return true;\n    }\n\n    const DWORD error = ::GetLastError();\n    switch (error)\n    {\n        case ERROR_ALREADY_EXISTS:\n        {\n            ok = true;\n            break;\n        }\n\n        case ERROR_PATH_NOT_FOUND:\n        {\n            // Part of the path does not exist so try to create it\n            const fileName& parentName = pathName.path();\n\n            if (parentName.size() && mkDir(parentName, mode))\n            {\n                ok = mkDir(pathName, mode);\n            }\n            break;\n        }\n    }\n\n    if (!ok)\n    {\n        FatalErrorInFunction\n            << \"Couldn't create directory: \" << pathName\n            << \" \" << MSwindows::lastError()\n            << exit(FatalError);\n    }\n\n    return ok;\n}\n\n\nbool Foam::chMod(const fileName& name, const mode_t m)\n{\n    // Ignore an empty name => always false\n    return !name.empty() && _chmod(name.c_str(), m) == 0;\n}\n\n\nmode_t Foam::mode(const fileName& name, const bool followLink)\n{\n    // Ignore an empty name => always 0\n    if (!name.empty())\n    {\n        fileStat fileStatus(name, followLink);\n        if (fileStatus.valid())\n        {\n            return fileStatus.status().st_mode;\n        }\n    }\n\n    return 0;\n}\n\n\n// Windows equivalent to S_ISDIR\n#define ms_isdir(a) \\\n    ((m != INVALID_FILE_ATTRIBUTES) && (m & FILE_ATTRIBUTE_DIRECTORY))\n\n// Windows equivalent to S_ISREG\n#define ms_isreg(s) \\\n    ((m != INVALID_FILE_ATTRIBUTES) && !(m & FILE_ATTRIBUTE_DIRECTORY))\n\n\nFoam::fileName::Type Foam::type\n(\n    const fileName& name,\n    const bool /* followLink */\n)\n{\n    // Ignore an empty name => always UNDEFINED\n    if (name.empty())\n    {\n        return fileName::UNDEFINED;\n    }\n\n    const DWORD m = ::GetFileAttributes(name.c_str());\n\n    if (ms_isreg(m))\n    {\n        return fileName::FILE;\n    }\n    else if (ms_isdir(m))\n    {\n        return fileName::DIRECTORY;\n    }\n\n    return fileName::UNDEFINED;\n}\n\n\n// Local check for gz file\nstatic bool isGzFile(const std::string& name)\n{\n    const DWORD m = ::GetFileAttributes((name + \".gz\").c_str());\n    return ms_isreg(m);\n}\n\n\nbool Foam::exists\n(\n    const fileName& name,\n    const bool checkGzip,\n    const bool followLink\n)\n{\n    // Ignore an empty name => always false\n    if (name.empty())\n    {\n        return false;\n    }\n\n    const DWORD m = ::GetFileAttributes(name.c_str());\n\n    return (ms_isdir(m) || ms_isreg(m) || (checkGzip && isGzFile(name)));\n}\n\n\nbool Foam::isDir(const fileName& name, const bool followLink)\n{\n    // Ignore an empty name => always false\n    if (name.empty())\n    {\n        return false;\n    }\n\n    const DWORD m = ::GetFileAttributes(name.c_str());\n\n    return ms_isdir(m);\n}\n\n\nbool Foam::isFile\n(\n    const fileName& name,\n    const bool checkGzip,\n    const bool followLink\n)\n{\n    // Ignore an empty name => always false\n    if (name.empty())\n    {\n        return false;\n    }\n\n    const DWORD m = ::GetFileAttributes(name.c_str());\n\n    return (ms_isreg(m) || (!ms_isdir(m) && checkGzip && isGzFile(name)));\n}\n\n\noff_t Foam::fileSize(const fileName& name, const bool followLink)\n{\n    // Ignore an empty name\n    if (!name.empty())\n    {\n        fileStat fileStatus(name, followLink);\n        if (fileStatus.valid())\n        {\n            return fileStatus.status().st_size;\n        }\n    }\n\n    return -1;\n}\n\n\ntime_t Foam::lastModified(const fileName& name, const bool followLink)\n{\n    // Ignore an empty name\n    return name.empty() ? 0 : fileStat(name, followLink).modTime();\n}\n\n\ndouble Foam::highResLastModified(const fileName& name, const bool followLink)\n{\n    // Ignore an empty name\n    return name.empty() ? 0 : fileStat(name, followLink).dmodTime();\n}\n\n\nFoam::fileNameList Foam::readDir\n(\n    const fileName& directory,\n    const fileName::Type type,\n    const bool filtergz,\n    const bool followLink\n)\n{\n    // Initial filename list size\n    // also used as increment if initial size found to be insufficient\n    static constexpr int maxNnames = 100;\n\n    // Basic sanity: cannot strip '.gz' from directory names\n    const bool stripgz = filtergz && (type != fileName::DIRECTORY);\n    const word extgz(\"gz\");\n\n    fileNameList dirEntries;\n\n    // Iterate contents (ignores an empty directory name)\n\n    MSwindows::directoryIterator dirIter(directory);\n\n    if (!dirIter.exists())\n    {\n        if (MSwindows::debug)\n        {\n            InfoInFunction\n                << \"cannot open directory \" << directory << endl;\n        }\n\n        return dirEntries;\n    }\n\n    if (MSwindows::debug)\n    {\n        InfoInFunction\n            << \" : reading directory \" << directory << endl;\n    }\n\n    label nFailed = 0;     // Entries with invalid characters\n    label nEntries = 0;    // Number of selected entries\n    dirEntries.resize(maxNnames);\n\n    // Process all the directory entries\n    for (/*nil*/; dirIter; ++dirIter)\n    {\n        const std::string& item = *dirIter;\n\n        // Validate filename without quotes, etc in the name.\n        // No duplicate slashes to strip - dirent will not have them anyhow.\n\n        const fileName name(fileName::validate(item));\n        if (name != item)\n        {\n            ++nFailed;\n        }\n        else if\n        (\n            (type == fileName::DIRECTORY)\n         || (type == fileName::FILE && !fileName::isBackup(name))\n        )\n        {\n            if ((directory/name).type() == type)\n            {\n                if (nEntries >= dirEntries.size())\n                {\n                    dirEntries.resize(dirEntries.size() + maxNnames);\n                }\n\n                if (stripgz && name.hasExt(extgz))\n                {\n                    dirEntries[nEntries++] = name.lessExt();\n                }\n                else\n                {\n                    dirEntries[nEntries++] = name;\n                }\n            }\n        }\n    }\n\n    // Finalize the length of the entries list\n    dirEntries.resize(nEntries);\n\n    if (nFailed && MSwindows::debug)\n    {\n        std::cerr\n            << \"Foam::readDir() : reading directory \" << directory << nl\n            << nFailed << \" entries with invalid characters in their name\"\n            << std::endl;\n    }\n\n    return dirEntries;\n}\n\n\nbool Foam::cp(const fileName& src, const fileName& dest, const bool followLink)\n{\n    // Make sure source exists - this also handles an empty source name\n    if (!exists(src))\n    {\n        return false;\n    }\n\n    fileName destFile(dest);\n\n    const fileName::Type srcType = src.type(followLink);\n\n    // Check type of source file.\n    if (srcType == fileName::FILE)\n    {\n        // If dest is a directory, create the destination file name.\n        if (destFile.type() == fileName::DIRECTORY)\n        {\n            destFile = destFile/src.name();\n        }\n\n        // Make sure the destination directory exists.\n        if (!isDir(destFile.path()) && !mkDir(destFile.path()))\n        {\n            return false;\n        }\n\n        // Open and check streams.\n        // - use binary mode to avoid any issues\n        std::ifstream srcStream(src, ios_base::in | ios_base::binary);\n        if (!srcStream)\n        {\n            return false;\n        }\n\n        // - use binary mode to avoid any issues\n        std::ofstream destStream(destFile, ios_base::out | ios_base::binary);\n        if (!destStream)\n        {\n            return false;\n        }\n\n        // Copy character data.\n        char ch;\n        while (srcStream.get(ch))\n        {\n            destStream.put(ch);\n        }\n\n        // Final check.\n        if (!srcStream.eof() || !destStream)\n        {\n            return false;\n        }\n    }\n    else if (srcType == fileName::DIRECTORY)\n    {\n        // If dest is a directory, create the destination file name.\n        if (destFile.type() == fileName::DIRECTORY)\n        {\n            destFile /= src.components().last();\n        }\n\n        // Make sure the destination directory extists.\n        if (!isDir(destFile) && !mkDir(destFile))\n        {\n            return false;\n        }\n\n        // Copy files\n        fileNameList files = readDir(src, fileName::FILE, false, followLink);\n        for (const fileName& item : files)\n        {\n            if (MSwindows::debug)\n            {\n                Info<< \"Copying : \" << src/item\n                    << \" to \" << destFile/item << endl;\n            }\n\n            // File to file.\n            Foam::cp(src/item, destFile/item);\n        }\n\n        // Copy sub directories.\n        fileNameList dirs = readDir\n        (\n            src,\n            fileName::DIRECTORY,\n            false,\n            followLink\n        );\n\n        for (const fileName& item : dirs)\n        {\n            if (MSwindows::debug)\n            {\n                Info<< \"Copying : \" << src/item\n                    << \" to \" << destFile << endl;\n            }\n\n            // Dir to Dir.\n            Foam::cp(src/item, destFile);\n        }\n    }\n    else\n    {\n        return false;\n    }\n\n    return true;\n}\n\n\nbool Foam::ln(const fileName& src, const fileName& dst)\n{\n    // links are poorly supported, or need administrator privileges.\n    // Skip for now.\n\n    if (MSwindows::debug)\n    {\n        Info<< \"MSwindows does not support ln - softlinking\" << endl;\n    }\n\n    return false;\n}\n\n\nbool Foam::mv(const fileName& src, const fileName& dst, const bool followLink)\n{\n    if (MSwindows::debug)\n    {\n        Info<< \"Move : \" << src << \" to \" << dst << endl;\n    }\n\n    // Ignore an empty names => always false\n    if (src.empty() || dst.empty())\n    {\n        return false;\n    }\n\n\n    if\n    (\n        dst.type() == fileName::DIRECTORY\n     && src.type(followLink) != fileName::DIRECTORY\n    )\n    {\n        const fileName dstName(dst/src.name());\n\n        return renameFile(src, dstName);\n    }\n\n    return renameFile(src, dst);\n}\n\n\nbool Foam::mvBak(const fileName& src, const std::string& ext)\n{\n    // Ignore an empty name or extension => always false\n    if (src.empty() || ext.empty())\n    {\n        return false;\n    }\n\n    if (exists(src, false))\n    {\n        constexpr const int maxIndex = 99;\n        char index[3];\n\n        for (int n = 0; n <= maxIndex; ++n)\n        {\n            fileName dstName(src + \".\" + ext);\n            if (n)\n            {\n                sprintf(index, \"%02d\", n);\n                dstName += index;\n            }\n\n            // avoid overwriting existing files, except for the last\n            // possible index where we have no choice\n            if (!exists(dstName, false) || n == maxIndex)\n            {\n                return renameFile(src, dstName);\n            }\n        }\n    }\n\n    // fall-through: nothing to do\n    return false;\n}\n\n\nbool Foam::rm(const fileName& file)\n{\n    if (MSwindows::debug)\n    {\n        Info<< \"Removing : \" << file << endl;\n    }\n\n    // Ignore an empty name => always false\n    if (file.empty())\n    {\n        return false;\n    }\n\n\n    // If removal of plain file name failed, try with .gz\n\n    return\n    (\n        0 == std::remove(file.c_str())\n     || 0 == std::remove((file + \".gz\").c_str())\n    );\n}\n\n\nbool Foam::rmDir(const fileName& directory, const bool silent)\n{\n    // Iterate contents (ignores an empty directory name)\n    // Also retain hidden files/dirs for removal\n\n    MSwindows::directoryIterator dirIter(directory, true);\n\n    if (!dirIter.exists())\n    {\n        if (!silent)\n        {\n            WarningInFunction\n                << \"cannot open directory \" << directory << endl;\n        }\n    }\n\n    if (MSwindows::debug)\n    {\n        InfoInFunction\n            << \" : removing directory \" << directory << endl;\n    }\n\n\n    // Process each directory entry, counting any errors encountered\n    label nErrors = 0;\n\n    for (/*nil*/; dirIter; ++dirIter)\n    {\n        const std::string& item = *dirIter;\n\n        // Allow invalid characters (spaces, quotes, etc),\n        // otherwise we cannot remove subdirs with these types of names.\n        // -> const fileName path = directory/name; <-\n\n        const fileName path(fileName::concat(directory, item));\n\n        if (path.type(false) == fileName::DIRECTORY)\n        {\n            if (!rmDir(path, true))  // Only report errors at the top-level\n            {\n                ++nErrors;\n            }\n        }\n        else\n        {\n            if (!rm(path))\n            {\n                ++nErrors;\n            }\n        }\n    }\n\n    if (nErrors)\n    {\n        if (!silent)\n        {\n            WarningInFunction\n                << \"failed to remove directory \" << directory << nl\n                << \"could not remove \" << nErrors << \" sub-entries\" << endl;\n        }\n    }\n    else\n    {\n        if (!::RemoveDirectory(directory.c_str()))\n        {\n            ++nErrors;\n            if (!silent)\n            {\n                WarningInFunction\n                    << \"failed to remove directory \" << directory << endl;\n            }\n        }\n    }\n\n    return !nErrors;\n}\n\n\nunsigned int Foam::sleep(const unsigned int sec)\n{\n    ::Sleep(1000*sec);  // in milliseconds\n\n    return 0;\n}\n\n\nvoid Foam::fdClose(const int fd)\n{\n    if (::_close(fd) != 0)\n    {\n        FatalErrorInFunction\n            << \"close error on \" << fd << endl\n            << abort(FatalError);\n    }\n}\n\n\nbool Foam::ping\n(\n    const std::string& destName,\n    const label destPort,\n    const label timeOut\n)\n{\n    // Appears that socket calls require administrator privileges.\n    // Skip for now.\n\n    if (MSwindows::debug)\n    {\n        Info<< \"MSwindows does not support ping\" << endl;\n    }\n\n    return false;\n}\n\n\nbool Foam::ping(const std::string& host, const label timeOut)\n{\n    return ping(host, 222, timeOut) || ping(host, 22, timeOut);\n}\n\n\nint Foam::system(const std::string& command, const bool bg)\n{\n    if (MSwindows::debug && bg)\n    {\n        InfoInFunction\n            << \"MSwindows does not support background (fork) tasks\" << endl;\n    }\n\n    return std::system(command.c_str());\n}\n\n\nint Foam::system(const CStringList& command, const bool bg)\n{\n    if (command.empty())\n    {\n        // Treat an empty command as a successful no-op.\n        // For consistency with POSIX (man sh) behaviour for (sh -c command),\n        // which is what is mostly being replicated here.\n        return 0;\n    }\n\n    const int count = command.size();\n\n    std::string cmd;\n\n    for (int i = 0; i < count; ++i)\n    {\n        if (i) cmd += ' ';\n        cmd += command[i];\n    }\n\n    return system(cmd, bg);\n}\n\n\nint Foam::system(const UList<Foam::string>& command, const bool bg)\n{\n    if (command.empty())\n    {\n        // Treat an empty command as a successful no-op.\n        return 0;\n    }\n\n    const int count = command.size();\n\n    std::string cmd;\n\n    for (int i = 0; i < count; ++i)\n    {\n        if (i) cmd += ' ';\n        cmd += command[i];\n    }\n\n    return system(cmd, bg);\n}\n\n\n// Explicitly track loaded libraries, rather than use\n// EnumerateLoadedModules64 and have to link against\n// Dbghelp.dll\n// Details at http://msdn.microsoft.com/en-us/library/ms679316(v=vs.85).aspx\n\nstatic std::unordered_map<void*, std::string> libsLoaded;\n\n\nvoid* Foam::dlOpen(const fileName& libName, const bool check)\n{\n    if (MSwindows::debug)\n    {\n        std::cout\n            << \"dlOpen(const fileName&)\"\n            << \" : dlopen of \" << libName << std::endl;\n    }\n\n    // Always remap \"libXX.so\" and \"libXX\" to \"libXX.dll\"\n    fileName libso(libName.lessExt().ext(EXT_SO));\n\n    void* handle = ::LoadLibrary(libso.c_str());\n\n    if\n    (\n        !handle\n     && libName.find('/') == std::string::npos\n     && !libso.starts_with(\"lib\")\n    )\n    {\n        // Try with 'lib' prefix\n        libso = \"lib\" + libso;\n        handle = ::LoadLibrary(libso.c_str());\n\n        if (MSwindows::debug)\n        {\n            std::cout\n                << \"dlOpen(const fileName&)\"\n                << \" : dlopen of \" << libso << std::endl;\n        }\n    }\n\n    if (handle)\n    {\n        libsLoaded[handle] = libso.lessExt();\n    }\n    else if (check)\n    {\n        WarningInFunction\n            << \"dlopen error : \" << MSwindows::lastError() << endl;\n    }\n\n    if (MSwindows::debug)\n    {\n        std::cout\n            << \"dlOpen(const fileName&)\"\n            << \" : dlopen of \" << libName\n            << \" handle \" << handle << std::endl;\n    }\n\n    return handle;\n}\n\n\nvoid* Foam::dlOpen(const fileName& libName, std::string& errorMsg)\n{\n    // Call without emitting error message - we capture that ourselves\n    void* handle = Foam::dlOpen(libName, false);\n\n    if (!handle)\n    {\n        // Capture error message\n        errorMsg = MSwindows::lastError();\n    }\n    else\n    {\n        // No errors\n        errorMsg.clear();\n    }\n\n    return handle;\n}\n\n\nFoam::label Foam::dlOpen\n(\n    std::initializer_list<fileName> libNames,\n    const bool check\n)\n{\n    label nLoaded = 0;\n\n    for (const fileName& libName : libNames)\n    {\n        if (Foam::dlOpen(libName, check))\n        {\n            ++nLoaded;\n        }\n    }\n\n    return nLoaded;\n}\n\n\nbool Foam::dlClose(void* const handle)\n{\n    if (MSwindows::debug)\n    {\n        std::cout\n            << \"dlClose(void*)\"\n            << \" : dlclose of handle \" << handle << std::endl;\n    }\n\n    const bool ok = ::FreeLibrary(static_cast<HMODULE>(handle));\n\n    if (ok)\n    {\n        libsLoaded.erase(handle);\n    }\n\n    return ok;\n}\n\n\nvoid* Foam::dlSymFind(void* handle, const std::string& symbol, bool required)\n{\n    if (!required && (!handle || symbol.empty()))\n    {\n        return nullptr;\n    }\n\n    if (MSwindows::debug)\n    {\n        std::cout\n            << \"dlSymFind(void*, const std::string&, bool)\"\n            << \" : dlsym of \" << symbol << std::endl;\n    }\n\n    // Get address of symbol, or nullptr on failure\n    void* fun =\n        reinterpret_cast<void *>\n        (\n            ::GetProcAddress(static_cast<HMODULE>(handle), symbol.c_str())\n        );\n\n    // Any error?\n    if (!fun && required)\n    {\n        WarningInFunction\n            << \"Cannot lookup symbol \" << symbol << \" : \"\n            << MSwindows::lastError() << endl;\n    }\n\n    return fun;\n}\n\n\nFoam::fileNameList Foam::dlLoaded()\n{\n    DynamicList<fileName> libs(libsLoaded.size());\n\n    for (const auto& item : libsLoaded)\n    {\n        libs.append(item.second);\n    }\n\n    if (MSwindows::debug)\n    {\n        std::cout\n            << \"dlLoaded()\"\n            << \" : determined loaded libraries :\" << libs.size() << std::endl;\n    }\n\n    return libs;\n}\n\n\n// ************************************************************************* //\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/pimpleFoam/LES/channel395/0/p.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/pimpleFoam/LES/channel395/0/B.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/pimpleFoam/LES/channel395/0/nuTilda.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/pimpleFoam/LES/channel395/0/U.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/pimpleFoam/LES/channel395/0/nut.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/pimpleFoam/LES/channel395/0/k.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/pimpleFoam/RAS/rotatingFanInRoom/constant/triSurface/fan.blend1",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/pimpleFoam/RAS/rotatingFanInRoom/constant/triSurface/fan.blend",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/simpleFoam/windAroundBuildings/constant/triSurface/buildings.obj.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/sensitivityMaps/sbend/turbulent/lowRe/multiPoint/constant/polyMesh/boundary.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/sensitivityMaps/sbend/turbulent/lowRe/multiPoint/constant/polyMesh/neighbour.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/sensitivityMaps/sbend/turbulent/lowRe/multiPoint/constant/polyMesh/faces.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/sensitivityMaps/sbend/turbulent/lowRe/multiPoint/constant/polyMesh/points.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/sensitivityMaps/sbend/turbulent/lowRe/multiPoint/constant/polyMesh/owner.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/resources/meshes/sbend/polyMesh/boundary.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/resources/meshes/sbend/polyMesh/neighbour.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/resources/meshes/sbend/polyMesh/faces.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/resources/meshes/sbend/polyMesh/points.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/resources/meshes/sbend/polyMesh/owner.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/resources/meshes/naca0012/polyMesh/boundary.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/resources/meshes/naca0012/polyMesh/neighbour.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/resources/meshes/naca0012/polyMesh/faces.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/resources/meshes/naca0012/polyMesh/points.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/resources/meshes/naca0012/polyMesh/owner.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/resources/param/sbend/dxidXj_23.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/resources/param/sbend/dxidXj_13.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/resources/param/sbend/dxidXj_12.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/resources/param/sbend/dxidXj_8.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/resources/param/sbend/dxidXj_15.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/resources/param/sbend/dxidXj_21.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/resources/param/sbend/dxidXj_0.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/resources/param/sbend/dxidXj_5.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/resources/param/sbend/dxidXj_17.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/resources/param/sbend/dxidXj_16.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/resources/param/sbend/dxidXj_20.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/resources/param/sbend/dxidXj_2.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/resources/param/sbend/dxidXj_1.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/resources/param/sbend/dxidXj_6.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/resources/param/sbend/dxidXj_7.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/resources/param/sbend/dxidXj_4.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/resources/param/sbend/dxidXj_19.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/resources/param/sbend/dxidXj_3.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/resources/param/sbend/dxidXj_14.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/resources/param/sbend/dxidXj_11.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/resources/param/sbend/dxidXj_10.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/resources/param/sbend/dxidXj_18.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/resources/param/sbend/dxidXj_22.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/resources/param/sbend/dxidXj_9.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/resources/param/naca0012/dxidXj_13.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/resources/param/naca0012/dxidXj_12.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/resources/param/naca0012/dxidXj_8.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/resources/param/naca0012/dxidXj_15.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/resources/param/naca0012/dxidXj_0.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/resources/param/naca0012/dxidXj_5.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/resources/param/naca0012/dxidXj_2.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/resources/param/naca0012/dxidXj_1.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/resources/param/naca0012/dxidXj_6.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/resources/param/naca0012/dxidXj_7.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/resources/param/naca0012/dxidXj_4.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/resources/param/naca0012/dxidXj_3.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/resources/param/naca0012/dxidXj_14.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/resources/param/naca0012/dxidXj_11.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/resources/param/naca0012/dxidXj_10.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/incompressible/adjointOptimisationFoam/resources/param/naca0012/dxidXj_9.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/multiphase/driftFluxFoam/RAS/tank3D/constant/polyMesh.orig/boundary.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/multiphase/driftFluxFoam/RAS/tank3D/constant/polyMesh.orig/cells.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/multiphase/driftFluxFoam/RAS/tank3D/constant/polyMesh.orig/neighbour.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/multiphase/driftFluxFoam/RAS/tank3D/constant/polyMesh.orig/faces.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/multiphase/driftFluxFoam/RAS/tank3D/constant/polyMesh.orig/points.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/multiphase/driftFluxFoam/RAS/tank3D/constant/polyMesh.orig/owner.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/resources/geometry/bullet.stl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/resources/geometry/sloshingCylinder.obj.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/resources/geometry/wigley-scaled-oriented.stl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/resources/geometry/motorBike-passenger-helmet.obj.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/resources/geometry/membrane-membrane.stl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/resources/geometry/wigley.stl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/resources/geometry/DTC-scaled.stl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/resources/geometry/seaweed.stl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/resources/geometry/flange.stl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/resources/geometry/blob.stl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/resources/geometry/motorBike.obj.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/resources/geometry/cyclone.stl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/resources/geometry/membrane-boundaries.stl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/resources/geometry/mixerVesselAMI/shaftRotating.stl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/resources/geometry/mixerVesselAMI/rotating.stl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/resources/geometry/mixerVesselAMI/problemFaces.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/resources/geometry/mixerVesselAMI/gasInlet.stl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/resources/geometry/mixerVesselAMI/outlet.stl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/resources/geometry/mixerVesselAMI/shaft.stl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/resources/geometry/mixerVesselAMI/sparger.stl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/resources/geometry/mixerVesselAMI/stirrer.stl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/resources/geometry/mixerVesselAMI/vessel.stl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/resources/geometry/mixerVesselAMI/baffles.stl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/resources/geometry/propeller/propellerStem2.obj.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/resources/geometry/propeller/propellerTip.obj.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/resources/geometry/propeller/innerCylinderSmall.obj.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/resources/geometry/propeller/innerCylinder.obj.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/resources/geometry/propeller/propellerStem1.obj.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/resources/geometry/propeller/outerCylinder.obj.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/resources/geometry/propeller/propellerStem3.obj.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/resources/geometry/nacaAirfoil/nacaAirfoil.vrt.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/resources/geometry/nacaAirfoil/nacaAirfoil.bnd.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/resources/geometry/nacaAirfoil/nacaAirfoil.cel.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/verificationAndValidation/atmosphericModels/atmFlatTerrain/successor/constant/polyMesh.orig/faceZones.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/verificationAndValidation/atmosphericModels/atmFlatTerrain/successor/constant/polyMesh.orig/boundary.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/verificationAndValidation/atmosphericModels/atmFlatTerrain/successor/constant/polyMesh.orig/neighbour.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/verificationAndValidation/atmosphericModels/atmFlatTerrain/successor/constant/polyMesh.orig/faces.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/verificationAndValidation/atmosphericModels/atmFlatTerrain/successor/constant/polyMesh.orig/points.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/verificationAndValidation/atmosphericModels/atmFlatTerrain/successor/constant/polyMesh.orig/pointZones.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/verificationAndValidation/atmosphericModels/atmFlatTerrain/successor/constant/polyMesh.orig/cellZones.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/verificationAndValidation/atmosphericModels/atmFlatTerrain/successor/constant/polyMesh.orig/owner.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/mesh/moveDynamicMesh/SnakeRiverCanyon/constant/triSurface/AcrossRiver.stl.gz",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/tutorials/mesh/moveDynamicMesh/SnakeRiverCanyon/constant/triSurface/ACROSSCYN.JPG",
        "/tmp/vanessa/spack-stage/spack-stage-openfoam-2006_201012-n2xhcmks2tziaa6o7ntb76zg7kz4gd5v/spack-src/doc/Doxygen/OpenFOAMlogo.png"
    ],
    "total_files": 12163
}