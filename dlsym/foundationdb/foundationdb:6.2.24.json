{
    "matches": {
        "/tmp/vanessa/spack-stage/spack-stage-foundationdb-6.2.24-ivypaqw232so4ki6gkkpzsm3swadt3su/spack-src/FDBLibTLS/plugin-test.cpp": "/*\n * plugin-test.cpp\n *\n * This source file is part of the FoundationDB open source project\n *\n * Copyright 2013-2018 Apple Inc. and the FoundationDB project authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include <exception>\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n\n#include <stdarg.h>\n#include <dlfcn.h>\n\n#include <boost/circular_buffer.hpp>\n\n#include \"fdbrpc/ITLSPlugin.h\"\n\n#include \"FDBLibTLS/FDBLibTLSPlugin.h\"\n\n#define TESTDATA \"./testdata/\"\n\nstatic std::string load_file(std::string path)\n{\n\tstd::ifstream fs(path);\n\tstd::stringstream ss;\n\n\tss << fs.rdbuf();\n\tfs.close();\n\n\treturn ss.str();\n}\n\nstruct client_server_test {\n\tstd::string ca_path;\n\n\tbool client_success;\n\tstd::string client_path;\n\tconst char* client_password;\n\tstd::vector<std::string> client_verify;\n\tconst char* servername;\n\n\tbool server_success;\n\tstd::string server_path;\n\tconst char* server_password;\n\tstd::vector<std::string> server_verify;\n};\n\nstruct FDBLibTLSPluginTest {\n\tFDBLibTLSPluginTest(Reference<ITLSPlugin> plugin);\n\t~FDBLibTLSPluginTest();\n\n\tReference<ITLSPlugin> plugin;\n\n\tboost::circular_buffer<uint8_t> client_buffer;\n\tboost::circular_buffer<uint8_t> server_buffer;\n\n\tint circular_read(boost::circular_buffer<uint8_t> *cb, uint8_t* buf, int len);\n\tint circular_write(boost::circular_buffer<uint8_t> *cb, const uint8_t* buf, int len);\n\tint client_read(uint8_t* buf, int len);\n\tint client_write(const uint8_t* buf, int len);\n\tint server_read(uint8_t* buf, int len);\n\tint server_write(const uint8_t* buf, int len);\n\n\tReference<ITLSPolicy> create_policy(void);\n\tReference<ITLSSession> create_client_session(Reference<ITLSPolicy> policy, const char* servername);\n\tReference<ITLSSession> create_server_session(Reference<ITLSPolicy> policy);\n\n\tvoid circular_reset(void);\n\tvoid circular_self_test(void);\n\n\tint client_server_test(const struct client_server_test *cst);\n\tint set_cert_data_test(void);\n};\n\nFDBLibTLSPluginTest::FDBLibTLSPluginTest(Reference<ITLSPlugin> plugin) :\n\tplugin(plugin)\n{\n\tcircular_reset();\n\tcircular_self_test();\n}\n\nFDBLibTLSPluginTest::~FDBLibTLSPluginTest()\n{\n}\n\nint FDBLibTLSPluginTest::circular_read(boost::circular_buffer<uint8_t> *cb, uint8_t* buf, int len)\n{\n\tint n = 0;\n\n\tfor (n = 0; n < len; n++) {\n\t\tif (cb->empty())\n\t\t\tbreak;\n\t\tbuf[n] = (*cb)[0];\n\t\tcb->pop_front();\n\t}\n\n\treturn n;\n}\n\nint FDBLibTLSPluginTest::circular_write(boost::circular_buffer<uint8_t> *cb, const uint8_t* buf, int len)\n{\n\tint n = 0;\n\n\tfor (n = 0; n < len; n++) {\n\t\tif (cb->full())\n\t\t\tbreak;\n\t\tcb->push_back(buf[n]);\n\t}\n\n\treturn n;\n}\n\nint FDBLibTLSPluginTest::client_read(uint8_t* buf, int len)\n{\n\t// Read bytes from the server from the client's buffer.\n\treturn circular_read(&client_buffer, buf, len);\n}\n\nint FDBLibTLSPluginTest::client_write(const uint8_t* buf, int len)\n{\n\t// Write bytes from the client into the server's buffer.\n\treturn circular_write(&server_buffer, buf, len);\n}\n\nint FDBLibTLSPluginTest::server_read(uint8_t* buf, int len)\n{\n\t// Read bytes from the client from the server's buffer.\n\treturn circular_read(&server_buffer, buf, len);\n}\n\nint FDBLibTLSPluginTest::server_write(const uint8_t* buf, int len)\n{\n\t// Write bytes from the server into the client's buffer.\n\treturn circular_write(&client_buffer, buf, len);\n}\n\nvoid FDBLibTLSPluginTest::circular_reset()\n{\n\tclient_buffer = boost::circular_buffer<uint8_t>(1024);\n\tserver_buffer = boost::circular_buffer<uint8_t>(1024);\n}\n\nvoid FDBLibTLSPluginTest::circular_self_test()\n{\n\tuint8_t buf[1024] = {1, 2, 3};\n\n\tstd::cerr << \"INFO: running circular buffer self tests...\\n\";\n\n\tassert(server_read(buf, 3) == 0);\n\n\tbuf[0] = 1, buf[1] = 2, buf[2] = 3;\n\tassert(client_write(buf, 2) == 2);\n\n\tbuf[0] = buf[1] = buf[2] = 255;\n\tassert(server_read(buf, 3) == 2);\n\tassert(buf[0] == 1 && buf[1] == 2 && buf[2] == 255);\n\n\tassert(client_write(buf, 1024) == 1024);\n\tassert(client_write(buf, 1) == 0);\n\tassert(server_read(buf, 1) == 1);\n\tassert(client_write(buf, 1) == 1);\n\tassert(client_write(buf, 1) == 0);\n\tassert(server_read(buf, 1024) == 1024);\n\tassert(server_read(buf, 1024) == 0);\n\n\tassert(client_read(buf, 3) == 0);\n\n\tbuf[0] = 1, buf[1] = 2, buf[2] = 3;\n\tassert(server_write(buf, 2) == 2);\n\n\tbuf[0] = buf[1] = buf[2] = 255;\n\tassert(client_read(buf, 3) == 2);\n\tassert(buf[0] == 1 && buf[1] == 2 && buf[2] == 255);\n\n\tassert(server_write(buf, 1024) == 1024);\n\tassert(server_write(buf, 1) == 0);\n\tassert(client_read(buf, 1) == 1);\n\tassert(server_write(buf, 1) == 1);\n\tassert(server_write(buf, 1) == 0);\n\tassert(client_read(buf, 1024) == 1024);\n\tassert(client_read(buf, 1024) == 0);\n}\n\nReference<ITLSPolicy> FDBLibTLSPluginTest::create_policy(void)\n{\n\treturn Reference<ITLSPolicy>(plugin->create_policy());\n}\n\nstatic int client_send_func(void* ctx, const uint8_t* buf, int len) {\n\tFDBLibTLSPluginTest *pt = (FDBLibTLSPluginTest *)ctx;\n\ttry {\n\t\treturn pt->client_write(buf, len);\n\t} catch ( const std::runtime_error& e ) {\n\t\treturn -1;\n\t}\n}\n\nstatic int client_recv_func(void* ctx, uint8_t* buf, int len) {\n\tFDBLibTLSPluginTest *pt = (FDBLibTLSPluginTest *)ctx;\n\ttry {\n\t\treturn pt->client_read(buf, len);\n\t} catch ( const std::runtime_error& e ) {\n\t\treturn -1;\n\t}\n}\n\nReference<ITLSSession> FDBLibTLSPluginTest::create_client_session(Reference<ITLSPolicy> policy, const char* servername)\n{\n\treturn Reference<ITLSSession>(policy->create_session(true, servername, client_send_func, this, client_recv_func, this, NULL));\n}\n\nstatic int server_send_func(void* ctx, const uint8_t* buf, int len) {\n\tFDBLibTLSPluginTest *pt = (FDBLibTLSPluginTest *)ctx;\n\ttry {\n\t\treturn pt->server_write(buf, len);\n\t} catch ( const std::runtime_error& e ) {\n\t\treturn -1;\n\t}\n}\n\nstatic int server_recv_func(void* ctx, uint8_t* buf, int len) {\n\tFDBLibTLSPluginTest *pt = (FDBLibTLSPluginTest *)ctx;\n\ttry {\n\t\treturn pt->server_read(buf, len);\n\t} catch ( const std::runtime_error& e ) {\n\t\treturn -1;\n\t}\n}\n\nReference<ITLSSession> FDBLibTLSPluginTest::create_server_session(Reference<ITLSPolicy> policy)\n{\n\treturn Reference<ITLSSession>(policy->create_session(false, NULL, server_send_func, this, server_recv_func, this, NULL));\n}\n\n#define MAX_VERIFY_RULES 5\n\nstatic void convert_verify_peers(const std::vector<std::string> *verify_rules, const uint8_t *verify_peers[], int verify_peers_len[]) {\n\tif (verify_rules->size() > MAX_VERIFY_RULES)\n\t\tthrow std::runtime_error(\"verify\");\n\tint i = 0;\n\tfor (auto &verify_rule: *verify_rules) {\n\t\tverify_peers[i] = (const uint8_t *)&verify_rule[0];\n\t\tverify_peers_len[i] = verify_rule.size();\n\t\ti++;\n\t}\n}\n\nint FDBLibTLSPluginTest::client_server_test(const struct client_server_test* cst)\n{\n\tconst uint8_t *verify_peers[MAX_VERIFY_RULES];\n\tint verify_peers_len[MAX_VERIFY_RULES];\n\n\tcircular_reset();\n\n\tstd::string ca_data = load_file(TESTDATA + cst->ca_path);\n\tstd::string client_data = load_file(TESTDATA + cst->client_path);\n\tstd::string server_data = load_file(TESTDATA + cst->server_path);\n\n\tReference<ITLSPolicy> client_policy = create_policy();\n\tif (!client_policy->set_ca_data((const uint8_t*)&ca_data[0], ca_data.size())) {\n\t\tstd::cerr << \"FAIL: failed to set client ca data\\n\";\n\t\treturn 1;\n\t}\n\tif (!client_policy->set_cert_data((const uint8_t*)&client_data[0], client_data.size())) {\n\t\tstd::cerr << \"FAIL: failed to set client cert data\\n\";\n\t\treturn 1;\n\t}\n\tif (!client_policy->set_key_data((const uint8_t*)&client_data[0], client_data.size(), cst->client_password)) {\n\t\tstd::cerr << \"FAIL: failed to set client key data\\n\";\n\t\treturn 1;\n\t}\n\tif (!cst->client_verify.empty()) {\n\t\tconvert_verify_peers(&cst->client_verify, verify_peers, verify_peers_len);\n\t\tif (!client_policy->set_verify_peers(cst->client_verify.size(), verify_peers, verify_peers_len)) {\n\t\t\tstd::cerr << \"FAIL: failed to set client verify peers\\n\";\n\t\t\treturn 1;\n\t\t}\n\t}\n\n\tReference<ITLSPolicy> server_policy = create_policy();\n\tif (!server_policy->set_ca_data((const uint8_t*)&ca_data[0], ca_data.size())) {\n\t\tstd::cerr << \"FAIL: failed to set server ca data\\n\";\n\t\treturn 1;\n\t}\n\tif (!server_policy->set_cert_data((const uint8_t*)&server_data[0], server_data.size())) {\n\t\tstd::cerr << \"FAIL: failed to set server cert data\\n\";\n\t\treturn 1;\n\t}\n\tif (!server_policy->set_key_data((const uint8_t*)&server_data[0], server_data.size(), cst->server_password)) {\n\t\tstd::cerr << \"FAIL: failed to set server key data\\n\";\n\t\treturn 1;\n\t}\n\tconvert_verify_peers(&cst->server_verify, verify_peers, verify_peers_len);\n\tif (!server_policy->set_verify_peers(cst->server_verify.size(), verify_peers, verify_peers_len)) {\n\t\tstd::cerr << \"FAIL: failed to set server verify peers\\n\";\n\t\treturn 1;\n\t}\n\n\tReference<ITLSSession> client_session = create_client_session(client_policy, cst->servername);\n\tReference<ITLSSession> server_session = create_server_session(server_policy);\n\n\tif (client_session.getPtr() == NULL || server_session.getPtr() == NULL)\n\t\treturn 1;\n\n\tstd::cerr << \"INFO: starting TLS handshake...\\n\";\n\n\tbool client_done = false, server_done = false;\n\tbool client_failed = false, server_failed = false;\n\tint rc, i = 0;\n\tdo {\n\t\tif (!client_done) {\n\t\t\trc = client_session->handshake();\n\t\t\tif (rc == ITLSSession::SUCCESS) {\n\t\t\t\tclient_done = true;\n\t\t\t} else if (rc == ITLSSession::FAILED) {\n\t\t\t\tif (cst->client_success) {\n\t\t\t\t\tstd::cerr << \"FAIL: failed to complete client handshake\\n\";\n\t\t\t\t\treturn 1;\n\t\t\t\t} else {\n\t\t\t\t\tstd::cerr << \"INFO: failed to complete client handshake (as expected)\\n\";\n\t\t\t\t\tclient_failed = true;\n\t\t\t\t\tclient_done = true;\n\t\t\t\t}\n\t\t\t} else if (rc != ITLSSession::WANT_READ && rc != ITLSSession::WANT_WRITE) {\n\t\t\t\tstd::cerr << \"FAIL: client handshake returned unknown value: \" << rc << \"\\n\";\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tif (!server_done) {\n\t\t\trc = server_session->handshake();\n\t\t\tif (rc == ITLSSession::SUCCESS) {\n\t\t\t\tserver_done = true;\n\t\t\t} else if (rc == ITLSSession::FAILED) {\n\t\t\t\tif (cst->server_success) {\n\t\t\t\t\tstd::cerr << \"FAIL: failed to complete server handshake\\n\";\n\t\t\t\t\treturn 1;\n\t\t\t\t} else {\n\t\t\t\t\tstd::cerr << \"INFO: failed to complete server handshake (as expected)\\n\";\n\t\t\t\t\tserver_failed = true;\n\t\t\t\t\tserver_done = true;\n\t\t\t\t}\n\t\t\t} else if (rc != ITLSSession::WANT_READ && rc != ITLSSession::WANT_WRITE) {\n\t\t\t\tstd::cerr << \"FAIL: server handshake returned unknown value: \" << rc << \"\\n\";\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t} while (i++ < 100 && (!client_done || !server_done));\n\n\tif (!client_done || !server_done) {\n\t\tstd::cerr << \"FAIL: failed to complete handshake\\n\";\n\t\treturn 1;\n\t}\n\n\tif (!cst->client_success && !client_failed) {\n\t\tstd::cerr << \"FAIL: client handshake succeeded when it should have failed\\n\";\n\t\treturn 1;\n\t}\n\tif (!cst->server_success && !server_failed) {\n\t\tstd::cerr << \"FAIL: server handshake succeeded when it should have failed\\n\";\n\t\treturn 1;\n\t}\n\tif (!cst->client_success || !cst->server_success)\n\t\treturn 0;\n\n\tstd::cerr << \"INFO: handshake completed successfully\\n\";\n\n\t//\n\t// Write on client and read on server.\n\t//\n\tstd::cerr << \"INFO: starting client write test...\\n\";\n\n\tstd::string client_msg(\"FDBLibTLSPlugin Client Write Test\");\n\tstd::string server_msg;\n\tsize_t cn = 0, sn = 0;\n\tuint8_t buf[16];\n\n\tclient_done = false, server_done = false;\n\ti = 0;\n\tdo {\n\t\tif (!client_done) {\n\t\t\trc = client_session->write((const uint8_t*)&client_msg[cn], client_msg.size()-cn);\n\t\t\tif (rc > 0) {\n\t\t\t\tcn += rc;\n\t\t\t\tif (cn >= client_msg.size())\n\t\t\t\t\tclient_done = true;\n\t\t\t} else if (rc == ITLSSession::FAILED) {\n\t\t\t\tstd::cerr << \"FAIL: failed to complete client write\\n\";\n\t\t\t\treturn 1;\n\t\t\t} else if (rc != ITLSSession::WANT_READ && rc != ITLSSession::WANT_WRITE) {\n\t\t\t\tstd::cerr << \"FAIL: client write returned unknown value: \" << rc << \"\\n\";\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tif (!server_done) {\n\t\t\trc = server_session->read(buf, sizeof(buf));\n\t\t\tif (rc > 0) {\n\t\t\t\tsn += rc;\n\t\t\t\tfor (int j = 0; j < rc; j++)\n\t\t\t\t\tserver_msg += buf[j];\n\t\t\t\tif (sn >= client_msg.size())\n\t\t\t\t\tserver_done = true;\n\t\t\t} else if (rc == ITLSSession::FAILED) {\n\t\t\t\tstd::cerr << \"FAIL: failed to complete server read\\n\";\n\t\t\t\treturn 1;\n\t\t\t} else if (rc != ITLSSession::WANT_READ && rc != ITLSSession::WANT_WRITE) {\n\t\t\t\tstd::cerr << \"FAIL: server read returned unknown value: \" << rc << \"\\n\";\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t} while (i++ < 100 && (!client_done || !server_done));\n\n\tif (client_msg != server_msg) {\n\t\tstd::cerr << \"FAIL: got client msg '\" << server_msg << \"' want '\" << client_msg << \"'\\n\";\n\t\treturn 1;\n\t}\n\n\tstd::cerr << \"INFO: client write test completed successfully\\n\";\n\n\t//\n\t// Write on server and read on client.\n\t//\n\tstd::cerr << \"INFO: starting server write test...\\n\";\n\n\tserver_msg = \"FDBLibTLSPlugin Server Write Test\";\n\tclient_msg.clear();\n\tcn = 0, sn = 0;\n\n\tclient_done = false, server_done = false;\n\ti = 0;\n\tdo {\n\t\tif (!server_done) {\n\t\t\trc = server_session->write((const uint8_t*)&server_msg[cn], server_msg.size()-cn);\n\t\t\tif (rc > 0) {\n\t\t\t\tcn += rc;\n\t\t\t\tif (cn >= server_msg.size())\n\t\t\t\t\tserver_done = true;\n\t\t\t} else if (rc == ITLSSession::FAILED) {\n\t\t\t\tstd::cerr << \"FAIL: failed to complete server write\\n\";\n\t\t\t\treturn 1;\n\t\t\t} else if (rc != ITLSSession::WANT_READ && rc != ITLSSession::WANT_WRITE) {\n\t\t\t\tstd::cerr << \"FAIL: server write returned unknown value: \" << rc << \"\\n\";\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t\tif (!client_done) {\n\t\t\trc = client_session->read(buf, sizeof(buf));\n\t\t\tif (rc > 0) {\n\t\t\t\tsn += rc;\n\t\t\t\tfor (int j = 0; j < rc; j++)\n\t\t\t\t\tclient_msg += buf[j];\n\t\t\t\tif (sn >= server_msg.size())\n\t\t\t\t\tclient_done = true;\n\t\t\t} else if (rc == ITLSSession::FAILED) {\n\t\t\t\tstd::cerr << \"FAIL: failed to complete client read\\n\";\n\t\t\t\treturn 1;\n\t\t\t} else if (rc != ITLSSession::WANT_READ && rc != ITLSSession::WANT_WRITE) {\n\t\t\t\tstd::cerr << \"FAIL: client read returned unknown value: \" << rc << \"\\n\";\n\t\t\t\treturn 1;\n\t\t\t}\n\t\t}\n\t} while (i++ < 100 && (!client_done || !server_done));\n\n\tif (server_msg != client_msg) {\n\t\tstd::cerr << \"FAIL: got server msg '\" << client_msg << \"' want '\" << server_msg << \"'\\n\";\n\t\treturn 1;\n\t}\n\n\tstd::cerr << \"INFO: server write test completed successfully\\n\";\n\n\treturn 0;\n}\n\nstatic void logf(const char* event, void* uid, bool is_error, ...) {\n\tva_list args;\n\n\tstd::string log_type (\"INFO\");\n\tif (is_error)\n\t\tlog_type = \"ERROR\";\n\n\tstd::cerr << log_type << \": \" << event;\n\n\tva_start(args, is_error);\n\n\tconst char *s = va_arg(args, const char *);\n\twhile (s != NULL) {\n\t\tstd::cerr << \" \" << s;\n\t\ts = va_arg(args, const char *);\n\t}\n\n\tstd::cerr << \"\\n\";\n\n\tva_end(args);\n}\n\nconst struct client_server_test client_server_tests[] = {\n\t// Single root CA.\n\t{\n\t\t.ca_path = \"test-ca-1.pem\",\n\t\t.client_success = true,\n\t\t.client_path = \"test-client-1.pem\",\n\t\t.client_password = NULL,\n\t\t.client_verify = {\"\"},\n\t\t.servername = NULL,\n\t\t.server_success = true,\n\t\t.server_path = \"test-server-1.pem\",\n\t\t.server_password = NULL,\n\t\t.server_verify = {\"\"},\n\t},\n\t{\n\t\t.ca_path = \"test-ca-1.pem\",\n\t\t.client_success = true,\n\t\t.client_path = \"test-client-1.pem\",\n\t\t.client_password = NULL,\n\t\t.client_verify = {\"\"},\n\t\t.servername = NULL,\n\t\t.server_success = true,\n\t\t.server_path = \"test-server-2.pem\",\n\t\t.server_password = NULL,\n\t\t.server_verify = {\"\"},\n\t},\n\t{\n\t\t.ca_path = \"test-ca-1.pem\",\n\t\t.client_success = true,\n\t\t.client_path = \"test-client-2.pem\",\n\t\t.client_password = NULL,\n\t\t.client_verify = {\"\"},\n\t\t.servername = NULL,\n\t\t.server_success = true,\n\t\t.server_path = \"test-server-1.pem\",\n\t\t.server_password = NULL,\n\t\t.server_verify = {\"\"},\n\t},\n\t{\n\t\t.ca_path = \"test-ca-1.pem\",\n\t\t.client_success = true,\n\t\t.client_path = \"test-client-2.pem\",\n\t\t.client_password = NULL,\n\t\t.client_verify = {\"\"},\n\t\t.servername = NULL,\n\t\t.server_success = true,\n\t\t.server_path = \"test-server-2.pem\",\n\t\t.server_password = NULL,\n\t\t.server_verify = {\"\"},\n\t},\n\n\t// Multiple root CAs.\n\t{\n\t\t.ca_path = \"test-ca-all.pem\",\n\t\t.client_success = true,\n\t\t.client_path = \"test-client-1.pem\",\n\t\t.client_password = NULL,\n\t\t.client_verify = {\"\"},\n\t\t.servername = NULL,\n\t\t.server_success = true,\n\t\t.server_path = \"test-server-4.pem\",\n\t\t.server_password = \"fdb123\",\n\t\t.server_verify = {\"\"},\n\t},\n\t{\n\t\t.ca_path = \"test-ca-all.pem\",\n\t\t.client_success = true,\n\t\t.client_path = \"test-client-4.pem\",\n\t\t.client_password = \"fdb321\",\n\t\t.client_verify = {\"\"},\n\t\t.servername = NULL,\n\t\t.server_success = true,\n\t\t.server_path = \"test-server-1.pem\",\n\t\t.server_password = \"fdb123\",\n\t\t.server_verify = {\"\"},\n\t},\n\t{\n\t\t.ca_path = \"test-ca-1.pem\",\n\t\t.client_success = false,\n\t\t.client_path = \"test-client-1.pem\",\n\t\t.client_password = NULL,\n\t\t.client_verify = {\"\"},\n\t\t.servername = NULL,\n\t\t.server_success = true,\n\t\t.server_path = \"test-server-4.pem\",\n\t\t.server_password = \"fdb123\",\n\t\t.server_verify = {\"\"},\n\t},\n\t{\n\t\t.ca_path = \"test-ca-2.pem\",\n\t\t.client_success = true,\n\t\t.client_path = \"test-client-1.pem\",\n\t\t.client_password = NULL,\n\t\t.client_verify = {\"\"},\n\t\t.servername = NULL,\n\t\t.server_success = false,\n\t\t.server_path = \"test-server-4.pem\",\n\t\t.server_password = \"fdb123\",\n\t\t.server_verify = {\"\"},\n\t},\n\n\t// Expired certificates.\n\t{\n\t\t.ca_path = \"test-ca-1.pem\",\n\t\t.client_success = false,\n\t\t.client_path = \"test-client-1.pem\",\n\t\t.client_password = NULL,\n\t\t.client_verify = {\"\"},\n\t\t.servername = NULL,\n\t\t.server_success = true,\n\t\t.server_path = \"test-server-3.pem\",\n\t\t.server_password = NULL,\n\t\t.server_verify = {\"\"},\n\t},\n\t{\n\t\t.ca_path = \"test-ca-1.pem\",\n\t\t.client_success = true,\n\t\t.client_path = \"test-client-3.pem\",\n\t\t.client_password = NULL,\n\t\t.client_verify = {\"\"},\n\t\t.servername = NULL,\n\t\t.server_success = false,\n\t\t.server_path = \"test-server-1.pem\",\n\t\t.server_password = NULL,\n\t\t.server_verify = {\"\"},\n\t},\n\t{\n\t\t.ca_path = \"test-ca-1.pem\",\n\t\t.client_success = true,\n\t\t.client_path = \"test-client-1.pem\",\n\t\t.client_password = NULL,\n\t\t.client_verify = {\"Check.Unexpired=0\"},\n\t\t.servername = NULL,\n\t\t.server_success = true,\n\t\t.server_path = \"test-server-3.pem\",\n\t\t.server_password = NULL,\n\t\t.server_verify = {\"\"},\n\t},\n\t{\n\t\t.ca_path = \"test-ca-1.pem\",\n\t\t.client_success = true,\n\t\t.client_path = \"test-client-3.pem\",\n\t\t.client_password = NULL,\n\t\t.client_verify = {\"\"},\n\t\t.servername = NULL,\n\t\t.server_success = true,\n\t\t.server_path = \"test-server-1.pem\",\n\t\t.server_password = NULL,\n\t\t.server_verify = {\"Check.Unexpired=0\"},\n\t},\n\t{\n\t\t.ca_path = \"test-ca-1.pem\",\n\t\t.client_success = true,\n\t\t.client_path = \"test-client-1.pem\",\n\t\t.client_password = NULL,\n\t\t.client_verify = {\"Check.Valid=0\"},\n\t\t.servername = NULL,\n\t\t.server_success = true,\n\t\t.server_path = \"test-server-3.pem\",\n\t\t.server_password = NULL,\n\t\t.server_verify = {\"\"},\n\t},\n\t{\n\t\t.ca_path = \"test-ca-1.pem\",\n\t\t.client_success = true,\n\t\t.client_path = \"test-client-3.pem\",\n\t\t.client_password = NULL,\n\t\t.client_verify = {\"\"},\n\t\t.servername = NULL,\n\t\t.server_success = true,\n\t\t.server_path = \"test-server-1.pem\",\n\t\t.server_password = NULL,\n\t\t.server_verify = {\"Check.Valid=0\"},\n\t},\n\t{\n\t\t.ca_path = \"test-ca-1.pem\",\n\t\t.client_success = false,\n\t\t.client_path = \"test-client-1.pem\",\n\t\t.client_password = NULL,\n\t\t.client_verify = {\"I.CN=FDB LibTLS Plugin Test Intermediate CA 1\", \"I.CN=FDB LibTLS Plugin Test Intermediate CA 2,Check.Unexpired=0\"},\n\t\t.servername = NULL,\n\t\t.server_success = true,\n\t\t.server_path = \"test-server-3.pem\",\n\t\t.server_password = NULL,\n\t\t.server_verify = {\"\"},\n\t},\n\t{\n\t\t.ca_path = \"test-ca-1.pem\",\n\t\t.client_success = true,\n\t\t.client_path = \"test-client-1.pem\",\n\t\t.client_password = NULL,\n\t\t.client_verify = {\"I.CN=FDB LibTLS Plugin Test Intermediate CA 1,Check.Unexpired=0\", \"I.CN=FDB LibTLS Plugin Test Intermediate CA 2\"},\n\t\t.servername = NULL,\n\t\t.server_success = true,\n\t\t.server_path = \"test-server-3.pem\",\n\t\t.server_password = NULL,\n\t\t.server_verify = {\"\"},\n\t},\n\n\t// Match on specific subject and/or issuer.\n\t{\n\t\t.ca_path = \"test-ca-1.pem\",\n\t\t.client_success = true,\n\t\t.client_path = \"test-client-1.pem\",\n\t\t.client_password = NULL,\n\t\t.client_verify = {\"C=US\"},\n\t\t.servername = NULL,\n\t\t.server_success = true,\n\t\t.server_path = \"test-server-1.pem\",\n\t\t.server_password = NULL,\n\t\t.server_verify = {\"\"},\n\t},\n\t{\n\t\t.ca_path = \"test-ca-1.pem\",\n\t\t.client_success = false,\n\t\t.client_path = \"test-client-1.pem\",\n\t\t.client_password = NULL,\n\t\t.client_verify = {\"C=US\"},\n\t\t.servername = NULL,\n\t\t.server_success = true,\n\t\t.server_path = \"test-server-2.pem\",\n\t\t.server_password = NULL,\n\t\t.server_verify = {\"\"},\n\t},\n\t{\n\t\t.ca_path = \"test-ca-1.pem\",\n\t\t.client_success = true,\n\t\t.client_path = \"test-client-1.pem\",\n\t\t.client_password = NULL,\n\t\t.client_verify = {\"C=AU\"},\n\t\t.servername = NULL,\n\t\t.server_success = true,\n\t\t.server_path = \"test-server-2.pem\",\n\t\t.server_password = NULL,\n\t\t.server_verify = {\"\"},\n\t},\n\t{\n\t\t.ca_path = \"test-ca-1.pem\",\n\t\t.client_success = true,\n\t\t.client_path = \"test-client-1.pem\",\n\t\t.client_password = NULL,\n\t\t.client_verify = {\"C=US\", \"C=AU\"},\n\t\t.servername = NULL,\n\t\t.server_success = true,\n\t\t.server_path = \"test-server-2.pem\",\n\t\t.server_password = NULL,\n\t\t.server_verify = {\"\"},\n\t},\n\t{\n\t\t.ca_path = \"test-ca-1.pem\",\n\t\t.client_success = false,\n\t\t.client_path = \"test-client-1.pem\",\n\t\t.client_password = NULL,\n\t\t.client_verify = {\"C=US\", \"C=JP\"},\n\t\t.servername = NULL,\n\t\t.server_success = true,\n\t\t.server_path = \"test-server-2.pem\",\n\t\t.server_password = NULL,\n\t\t.server_verify = {\"\"},\n\t},\n\t{\n\t\t.ca_path = \"test-ca-1.pem\",\n\t\t.client_success = true,\n\t\t.client_path = \"test-client-1.pem\",\n\t\t.client_password = NULL,\n\t\t.client_verify = {\"CN=FDB LibTLS Plugin Test Server 2\\\\, \\\\80 \\\\<\\\\01\\\\+\\\\02=\\\\03\\\\>\"},\n\t\t.servername = NULL,\n\t\t.server_success = true,\n\t\t.server_path = \"test-server-2.pem\",\n\t\t.server_password = NULL,\n\t\t.server_verify = {\"\"},\n\t},\n\t{\n\t\t.ca_path = \"test-ca-1.pem\",\n\t\t.client_success = false,\n\t\t.client_path = \"test-client-1.pem\",\n\t\t.client_password = NULL,\n\t\t.client_verify = {\"CN=FDB LibTLS Plugin Test Server 2\\\\, \\\\80 \\\\<\\\\01\\\\+\\\\02=\\\\04\\\\>\"},\n\t\t.servername = NULL,\n\t\t.server_success = true,\n\t\t.server_path = \"test-server-2.pem\",\n\t\t.server_password = NULL,\n\t\t.server_verify = {\"\"},\n\t},\n\t{\n\t\t.ca_path = \"test-ca-1.pem\",\n\t\t.client_success = false,\n\t\t.client_path = \"test-client-1.pem\",\n\t\t.client_password = NULL,\n\t\t.client_verify = {\"CN=FDB LibTLS Plugin Test Server 2\\\\, \\\\81 \\\\<\\\\01\\\\+\\\\02=\\\\04\\\\>\"},\n\t\t.servername = NULL,\n\t\t.server_success = true,\n\t\t.server_path = \"test-server-2.pem\",\n\t\t.server_password = NULL,\n\t\t.server_verify = {\"\"},\n\t},\n\t{\n\t\t.ca_path = \"test-ca-1.pem\",\n\t\t.client_success = false,\n\t\t.client_path = \"test-client-1.pem\",\n\t\t.client_password = NULL,\n\t\t.client_verify = {\"CN=FDB LibTLS Plugin Test Server 2\\\\, \\\\80 \\\\<\\\\01\\\\+\\\\02=\\\\04\"},\n\t\t.servername = NULL,\n\t\t.server_success = true,\n\t\t.server_path = \"test-server-2.pem\",\n\t\t.server_password = NULL,\n\t\t.server_verify = {\"\"},\n\t},\n\t{\n\t\t.ca_path = \"test-ca-1.pem\",\n\t\t.client_success = true,\n\t\t.client_path = \"test-client-1.pem\",\n\t\t.client_password = NULL,\n\t\t.client_verify = {\"CN=FDB LibTLS Plugin Test Server 2\\\\, \\\\80 \\\\<\\\\01\\\\+\\\\02=\\\\03\\\\>\"},\n\t\t.servername = NULL,\n\t\t.server_success = true,\n\t\t.server_path = \"test-server-2.pem\",\n\t\t.server_password = NULL,\n\t\t.server_verify = {\"CN=FDB LibTLS Plugin Test Client 1\"},\n\t},\n\t{\n\t\t.ca_path = \"test-ca-1.pem\",\n\t\t.client_success = true,\n\t\t.client_path = \"test-client-1.pem\",\n\t\t.client_password = NULL,\n\t\t.client_verify = {\"\"},\n\t\t.servername = NULL,\n\t\t.server_success = true,\n\t\t.server_path = \"test-server-1.pem\",\n\t\t.server_password = NULL,\n\t\t.server_verify = {\"CN=FDB LibTLS Plugin Test Client 1\"},\n\t},\n\t{\n\t\t.ca_path = \"test-ca-1.pem\",\n\t\t.client_success = true,\n\t\t.client_path = \"test-client-2.pem\",\n\t\t.client_password = NULL,\n\t\t.client_verify = {\"\"},\n\t\t.servername = NULL,\n\t\t.server_success = false,\n\t\t.server_path = \"test-server-1.pem\",\n\t\t.server_password = NULL,\n\t\t.server_verify = {\"O=Apple Pty Limited,OU=FDC Team\"},\n\t},\n\t{\n\t\t.ca_path = \"test-ca-1.pem\",\n\t\t.client_success = true,\n\t\t.client_path = \"test-client-2.pem\",\n\t\t.client_password = NULL,\n\t\t.client_verify = {\"O=Apple Inc.,OU=FDB Team\"},\n\t\t.servername = NULL,\n\t\t.server_success = true,\n\t\t.server_path = \"test-server-1.pem\",\n\t\t.server_password = NULL,\n\t\t.server_verify = {\"O=Apple Pty Limited,OU=FDB Team\"},\n\t},\n\t{\n\t\t.ca_path = \"test-ca-1.pem\",\n\t\t.client_success = false,\n\t\t.client_path = \"test-client-2.pem\",\n\t\t.client_password = NULL,\n\t\t.client_verify = {\"O=Apple Inc.,OU=FDC Team\"},\n\t\t.servername = NULL,\n\t\t.server_success = false,\n\t\t.server_path = \"test-server-1.pem\",\n\t\t.server_password = NULL,\n\t\t.server_verify = {\"O=Apple Pty Limited,OU=FDC Team\"},\n\t},\n\t{\n\t\t.ca_path = \"test-ca-1.pem\",\n\t\t.client_success = true,\n\t\t.client_path = \"test-client-1.pem\",\n\t\t.client_password = NULL,\n\t\t.client_verify = {\"I.C=US,I.ST=California,I.L=Cupertino,I.O=Apple Inc.,I.OU=FDB Team\"},\n\t\t.servername = NULL,\n\t\t.server_success = true,\n\t\t.server_path = \"test-server-1.pem\",\n\t\t.server_password = NULL,\n\t\t.server_verify = {\"I.C=US,I.ST=California,I.L=Cupertino,I.O=Apple Inc.,I.OU=FDB Team\"},\n\t},\n\t{\n\t\t.ca_path = \"test-ca-1.pem\",\n\t\t.client_success = false,\n\t\t.client_path = \"test-client-1.pem\",\n\t\t.client_password = NULL,\n\t\t.client_verify = {\"I.C=US,I.ST=California,I.L=Cupertino,I.O=Apple Inc.,I.OU=FDC Team\"},\n\t\t.servername = NULL,\n\t\t.server_success = false,\n\t\t.server_path = \"test-server-1.pem\",\n\t\t.server_password = NULL,\n\t\t.server_verify = {\"I.C=US,I.ST=California,I.L=Cupertino,I.O=Apple Inc.,I.OU=FDC Team\"},\n\t},\n\t{\n\t\t.ca_path = \"test-ca-1.pem\",\n\t\t.client_success = true,\n\t\t.client_path = \"test-client-1.pem\",\n\t\t.client_password = NULL,\n\t\t.client_verify = {\"I.CN=FDB LibTLS Plugin Test Intermediate CA 1\"},\n\t\t.servername = NULL,\n\t\t.server_success = true,\n\t\t.server_path = \"test-server-1.pem\",\n\t\t.server_password = NULL,\n\t\t.server_verify = {\"I.CN=FDB LibTLS Plugin Test Intermediate CA 1\"},\n\t},\n\t{\n\t\t.ca_path = \"test-ca-1.pem\",\n\t\t.client_success = false,\n\t\t.client_path = \"test-client-1.pem\",\n\t\t.client_password = NULL,\n\t\t.client_verify = {\"I.CN=FDB LibTLS Plugin Test Intermediate CA 2\"},\n\t\t.servername = NULL,\n\t\t.server_success = true,\n\t\t.server_path = \"test-server-1.pem\",\n\t\t.server_password = NULL,\n\t\t.server_verify = {\"I.CN=FDB LibTLS Plugin Test Intermediate CA 1\"},\n\t},\n\t{\n\t\t.ca_path = \"test-ca-1.pem\",\n\t\t.client_success = true,\n\t\t.client_path = \"test-client-1.pem\",\n\t\t.client_password = NULL,\n\t\t.client_verify = {\"I.CN=FDB LibTLS Plugin Test Intermediate CA 2\"},\n\t\t.servername = NULL,\n\t\t.server_success = true,\n\t\t.server_path = \"test-server-2.pem\",\n\t\t.server_password = NULL,\n\t\t.server_verify = {\"I.CN=FDB LibTLS Plugin Test Intermediate CA 1\"},\n\t},\n\t{\n\t\t.ca_path = \"test-ca-1.pem\",\n\t\t.client_success = true,\n\t\t.client_path = \"test-client-1.pem\",\n\t\t.client_password = NULL,\n\t\t.client_verify = {\"CN=FDB LibTLS Plugin Test Server 2\\\\, \\\\80 \\\\<\\\\01\\\\+\\\\02=\\\\03\\\\>,I.CN=FDB LibTLS Plugin Test Intermediate CA 2\"},\n\t\t.servername = NULL,\n\t\t.server_success = true,\n\t\t.server_path = \"test-server-2.pem\",\n\t\t.server_password = NULL,\n\t\t.server_verify = {\"I.CN=FDB LibTLS Plugin Test Intermediate CA 1,O=Apple Inc.,I.C=US,S.C=US\"},\n\t},\n\t{\n\t\t.ca_path = \"test-ca-1.pem\",\n\t\t.client_success = false,\n\t\t.client_path = \"test-client-1.pem\",\n\t\t.client_password = NULL,\n\t\t.client_verify = {\"CN=FDB LibTLS Plugin Test Server 2\\\\, \\\\80 \\\\<\\\\01\\\\+\\\\02=\\\\03\\\\>,I.CN=FDB LibTLS Plugin Test Intermediate CA 1\"},\n\t\t.servername = NULL,\n\t\t.server_success = true,\n\t\t.server_path = \"test-server-2.pem\",\n\t\t.server_password = NULL,\n\t\t.server_verify = {\"I.CN=FDB LibTLS Plugin Test Intermediate CA 1,O=Apple Inc.,I.C=US,S.C=US\"},\n\t},\n\t{\n\t\t.ca_path = \"test-ca-1.pem\",\n\t\t.client_success = true,\n\t\t.client_path = \"test-client-1.pem\",\n\t\t.client_password = NULL,\n\t\t.client_verify = {\"R.CN=FDB LibTLS Plugin Test Root CA 1\"},\n\t\t.servername = NULL,\n\t\t.server_success = true,\n\t\t.server_path = \"test-server-2.pem\",\n\t\t.server_password = NULL,\n\t\t.server_verify = {\"R.CN=FDB LibTLS Plugin Test Root CA 1\"},\n\t},\n\t{\n\t\t.ca_path = \"test-ca-all.pem\",\n\t\t.client_success = false,\n\t\t.client_path = \"test-client-1.pem\",\n\t\t.client_password = NULL,\n\t\t.client_verify = {\"R.CN=FDB LibTLS Plugin Test Root CA 1\"},\n\t\t.servername = NULL,\n\t\t.server_success = true,\n\t\t.server_path = \"test-server-4.pem\",\n\t\t.server_password = \"fdb123\",\n\t\t.server_verify = {\"R.CN=FDB LibTLS Plugin Test Root CA 1\"},\n\t},\n\t{\n\t\t.ca_path = \"test-ca-all.pem\",\n\t\t.client_success = true,\n\t\t.client_path = \"test-client-1.pem\",\n\t\t.client_password = NULL,\n\t\t.client_verify = {\"R.CN=FDB LibTLS Plugin Test Root CA 1\", \"R.CN=FDB LibTLS Plugin Test Root CA 2\"},\n\t\t.servername = NULL,\n\t\t.server_success = true,\n\t\t.server_path = \"test-server-4.pem\",\n\t\t.server_password = \"fdb123\",\n\t\t.server_verify = {\"R.CN=FDB LibTLS Plugin Test Root CA 1\"},\n\t},\n\t{\n\t\t.ca_path = \"test-ca-all.pem\",\n\t\t.client_success = true,\n\t\t.client_path = \"test-client-1.pem\",\n\t\t.client_password = NULL,\n\t\t.client_verify = {\"R.CN=FDB LibTLS Plugin Test Root CA 2\"},\n\t\t.servername = NULL,\n\t\t.server_success = true,\n\t\t.server_path = \"test-server-4.pem\",\n\t\t.server_password = \"fdb123\",\n\t\t.server_verify = {\"R.CN=FDB LibTLS Plugin Test Root CA 1\"},\n\t},\n\t{\n\t\t.ca_path = \"test-ca-all.pem\",\n\t\t.client_success = true,\n\t\t.client_path = \"test-client-1.pem\",\n\t\t.client_password = NULL,\n\t\t.client_verify = {\"R.OU=FDB Team\"},\n\t\t.servername = NULL,\n\t\t.server_success = true,\n\t\t.server_path = \"test-server-4.pem\",\n\t\t.server_password = \"fdb123\",\n\t\t.server_verify = {\"R.OU=FDB Team\"},\n\t},\n\n\t// Client performing name validation via servername.\n\t{\n\t\t.ca_path = \"test-ca-1.pem\",\n\t\t.client_success = true,\n\t\t.client_path = \"test-client-1.pem\",\n\t\t.client_password = NULL,\n\t\t.client_verify = {},\n\t\t.servername = \"test.foundationdb.org\",\n\t\t.server_success = true,\n\t\t.server_path = \"test-server-1.pem\",\n\t\t.server_password = NULL,\n\t\t.server_verify = {\"\"},\n\t},\n\t{\n\t\t.ca_path = \"test-ca-1.pem\",\n\t\t.client_success = false,\n\t\t.client_path = \"test-client-1.pem\",\n\t\t.client_password = NULL,\n\t\t.client_verify = {},\n\t\t.servername = \"www.foundationdb.org\",\n\t\t.server_success = true,\n\t\t.server_path = \"test-server-1.pem\",\n\t\t.server_password = NULL,\n\t\t.server_verify = {\"\"},\n\t},\n\n\t// Prefix and Suffix Matching\n\t{\n\t\t.ca_path = \"test-ca-1.pem\",\n\t\t.client_success = true,\n\t\t.client_path = \"test-client-2.pem\",\n\t\t.client_password = NULL,\n\t\t.client_verify = {\"O>=Apple Inc.,OU>=FDB\"},\n\t\t.servername = NULL,\n\t\t.server_success = true,\n\t\t.server_path = \"test-server-1.pem\",\n\t\t.server_password = NULL,\n\t\t.server_verify = {\"O<=Limited,OU<=Team\"},\n\t},\n\t{\n\t\t.ca_path = \"test-ca-1.pem\",\n\t\t.client_success = false,\n\t\t.client_path = \"test-client-2.pem\",\n\t\t.client_password = NULL,\n\t\t.client_verify = {\"O<=Apple Inc.,OU<=FDB\"},\n\t\t.servername = NULL,\n\t\t.server_success = false,\n\t\t.server_path = \"test-server-1.pem\",\n\t\t.server_password = NULL,\n\t\t.server_verify = {\"O>=Limited,OU>=Team\"},\n\t},\n\n\t// Subject Alternative Name\n\t{\n\t\t.ca_path = \"test-ca-1.pem\",\n\t\t.client_success = true,\n\t\t.client_path = \"test-client-2.pem\",\n\t\t.client_password = NULL,\n\t\t.client_verify = {\"S.subjectAltName=DNS:test.foundationdb.org\"},\n\t\t.servername = NULL,\n\t\t.server_success = true,\n\t\t.server_path = \"test-server-1.pem\",\n\t\t.server_password = NULL,\n\t\t.server_verify = {\"Check.Valid=0\"},\n\t},\n\t{\n\t\t.ca_path = \"test-ca-1.pem\",\n\t\t.client_success = true,\n\t\t.client_path = \"test-client-2.pem\",\n\t\t.client_password = NULL,\n\t\t.client_verify = {\"S.subjectAltName>=DNS:test.\"},\n\t\t.servername = NULL,\n\t\t.server_success = true,\n\t\t.server_path = \"test-server-1.pem\",\n\t\t.server_password = NULL,\n\t\t.server_verify = {\"Check.Valid=0\"},\n\t},\n\t{\n\t\t.ca_path = \"test-ca-1.pem\",\n\t\t.client_success = true,\n\t\t.client_path = \"test-client-2.pem\",\n\t\t.client_password = NULL,\n\t\t.client_verify = {\"S.subjectAltName<=DNS:.org\"},\n\t\t.servername = NULL,\n\t\t.server_success = true,\n\t\t.server_path = \"test-server-1.pem\",\n\t\t.server_password = NULL,\n\t\t.server_verify = {\"Check.Valid=0\"},\n\t},\n\t{\n\t\t.ca_path = \"test-ca-1.pem\",\n\t\t.client_success = false,\n\t\t.client_path = \"test-client-2.pem\",\n\t\t.client_password = NULL,\n\t\t.client_verify = {\"S.subjectAltName<=DNS:.com\"},\n\t\t.servername = NULL,\n\t\t.server_success = true,\n\t\t.server_path = \"test-server-1.pem\",\n\t\t.server_password = NULL,\n\t\t.server_verify = {\"Check.Valid=0\"},\n\t},\n\t{\n\t\t.ca_path = \"test-ca-1.pem\",\n\t\t.client_success = false,\n\t\t.client_path = \"test-client-2.pem\",\n\t\t.client_password = NULL,\n\t\t.client_verify = {\"S.subjectAltName<=EMAIL:.com\"},\n\t\t.servername = NULL,\n\t\t.server_success = true,\n\t\t.server_path = \"test-server-1.pem\",\n\t\t.server_password = NULL,\n\t\t.server_verify = {\"Check.Valid=0\"},\n\t},\n};\n\nint main(int argc, char **argv)\n{\n\tvoid *pluginSO = NULL;\n\tvoid *(*getPlugin)(const char*);\n\tint failed = 0;\n\n\tif (argc != 2) {\n\t\tstd::cerr << \"usage: \" << argv[0] << \" <plugin_path>\\n\";\n\t\texit(1);\n\t}\n\n\tpluginSO = dlopen(argv[1], RTLD_LAZY | RTLD_LOCAL);\n\tif (pluginSO == NULL) {\n\t\tstd::cerr << \"failed to load plugin '\" << argv[1] << \"': \" << dlerror() << \"\\n\";\n\t\texit(1);\n\t}\n\n\tgetPlugin = (void*(*)(const char*))dlsym( pluginSO, \"get_plugin\" );\n\tif (getPlugin == NULL) {\n\t\tstd::cerr << \"plugin '\" << argv[1] << \"' does not provide get_plugin()\\n\";\n\t\texit(1);\n\t}\n\n\tReference<ITLSPlugin> plugin = Reference<ITLSPlugin>((ITLSPlugin *)getPlugin(ITLSPlugin::get_plugin_type_name_and_version()));\n\n\tFDBLibTLSPluginTest *pt = new FDBLibTLSPluginTest(plugin);\n\n\tint test_num = 1;\n\tfor (auto &cst: client_server_tests) {\n\t\tstd::cerr << \"== Test \" << test_num++ << \" ==\\n\";\n\t\tfailed |= pt->client_server_test(&cst);\n\t}\n\n\tdelete pt;\n\n\treturn (failed);\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-foundationdb-6.2.24-ivypaqw232so4ki6gkkpzsm3swadt3su/spack-src/flow/Platform.cpp": "/*\n * Platform.cpp\n *\n * This source file is part of the FoundationDB open source project\n *\n * Copyright 2013-2018 Apple Inc. and the FoundationDB project authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#ifdef _WIN32\n// This has to come as the first include on Win32 for rand_s() to be found\n#define _CRT_RAND_S\n#include <stdlib.h>\n#include <math.h> // For _set_FMA3_enable workaround in platformInit\n#endif\n\n#include \"flow/Platform.h\"\n#include \"flow/Arena.h\"\n\n#include \"flow/Trace.h\"\n#include \"flow/Error.h\"\n\n#include \"flow/Knobs.h\"\n\n#include <iostream>\n#include <fstream>\n#include <sstream>\n#include <cstring>\n#include <algorithm>\n\n#include <sys/types.h>\n#include <time.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include \"flow/UnitTest.h\"\n#include \"flow/FaultInjection.h\"\n\n#ifdef _WIN32\n#define NOMINMAX\n#include <windows.h>\n#include <winioctl.h>\n#include <io.h>\n#include <psapi.h>\n#include <stdio.h>\n#include <conio.h>\n#include <direct.h>\n#include <pdh.h>\n#include <pdhmsg.h>\n#pragma comment(lib, \"pdh.lib\")\n\n// for SHGetFolderPath\n#include <ShlObj.h>\n#pragma comment(lib, \"Shell32.lib\")\n\n#define CANONICAL_PATH_SEPARATOR '\\\\'\n#define PATH_MAX MAX_PATH\n#endif\n\n#ifdef __unixish__\n#define CANONICAL_PATH_SEPARATOR '/'\n\n#include <dirent.h>\n#include <sys/time.h>\n#include <sys/mman.h>\n#include <unistd.h>\n#include <ftw.h>\n#include <pwd.h>\n#include <sched.h>\n\n/* Needed for disk capacity */\n#include <sys/statvfs.h>\n\n/* getifaddrs */\n#include <sys/socket.h>\n#include <ifaddrs.h>\n#include <arpa/inet.h>\n\n#include \"flow/stacktrace.h\"\n\n#ifdef __linux__\n/* Needed for memory allocation */\n#include <linux/mman.h>\n/* Needed for processor affinity */\n#include <sched.h>\n/* Needed for getProcessorTime* and setpriority */\n#include <sys/syscall.h>\n/* Needed for setpriority */\n#include <sys/resource.h>\n/* Needed for crash handler */\n#include <signal.h>\n/* Needed for gnu_dev_{major,minor} */\n#include <sys/sysmacros.h>\n#endif\n\n#ifdef __APPLE__\n#include <sys/uio.h>\n#include <sys/syslimits.h>\n#include <mach/mach.h>\n#include <mach-o/dyld.h>\n#include <sys/param.h>\n#include <sys/mount.h>\n#include <sys/sysctl.h>\n#include <netinet/in.h>\n#include <net/if.h>\n#include <net/if_dl.h>\n#include <net/route.h>\n\n#include <CoreFoundation/CoreFoundation.h>\n#include <IOKit/IOKitLib.h>\n#include <IOKit/storage/IOBlockStorageDriver.h>\n#include <IOKit/storage/IOMedia.h>\n#include <IOKit/IOBSD.h>\n#endif\n\n#endif\n\nstd::string removeWhitespace(const std::string &t)\n{\n\tstatic const std::string ws(\" \\t\\r\");\n\tstd::string str = t;\n\tsize_t found = str.find_last_not_of(ws);\n\tif (found != std::string::npos)\n\t\tstr.erase(found + 1);\n\telse\n\t\tstr.clear(); // str is all whitespace\n\tfound = str.find_first_not_of(ws);\n\tif (found != std::string::npos)\n\t\tstr.erase(0, found);\n\telse\n\t\tstr.clear(); // str is all whitespace\n\n\treturn str;\n}\n\n#ifdef _WIN32\n#define ALLOC_FAIL NULL\n#elif defined(__unixish__)\n#define ALLOC_FAIL MAP_FAILED\n#else\n#error What platform is this?\n#endif\n\nusing std::cout;\nusing std::endl;\n\n#if defined(_WIN32)\n__int64 FiletimeAsInt64 (FILETIME &t){\n\treturn *(__int64*)&t;\n}\n#endif\n\n#ifdef _WIN32\nbool handlePdhStatus(const PDH_STATUS& status, std::string message) {\n\tif (status != ERROR_SUCCESS) {\n\t\tTraceEvent(SevWarnAlways, message.c_str()).GetLastError().detail(\"Status\", status);\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nbool setPdhString(int id, std::string &out) {\n\tchar buf[512];\n\tDWORD sz = 512;\n\tif (!handlePdhStatus(PdhLookupPerfNameByIndex(NULL, id, buf, &sz), \"PdhLookupPerfByNameIndex\"))\n\t\treturn false;\n\tout = buf;\n\treturn true;\n}\n#endif\n\n#ifdef __unixish__\nstatic double getProcessorTimeGeneric(int who) {\n\tstruct rusage r_usage;\n\n\tif (getrusage(who, &r_usage)) {\n\t\tTraceEvent(SevError, \"GetCPUTime\").detail(\"Who\", who).GetLastError();\n\t\tthrow platform_error();\n\t}\n\n\treturn (r_usage.ru_utime.tv_sec + (r_usage.ru_utime.tv_usec / double(1e6)) +\n\t\t\tr_usage.ru_stime.tv_sec + (r_usage.ru_stime.tv_usec / double(1e6)));\n}\n#endif\n\ndouble getProcessorTimeThread() {\n\tINJECT_FAULT( platform_error, \"getProcessorTimeThread\" );\n#if defined(_WIN32)\n\tFILETIME ftCreate, ftExit, ftKernel, ftUser;\n\tif (!GetThreadTimes(GetCurrentThread(), &ftCreate, &ftExit, &ftKernel, &ftUser)) {\n\t\tTraceEvent(SevError, \"GetThreadCPUTime\").GetLastError();\n\t\tthrow platform_error();\n\t}\n\treturn FiletimeAsInt64(ftKernel) / double(1e7) + FiletimeAsInt64(ftUser) / double(1e7);\n#elif defined(__linux__)\n\treturn getProcessorTimeGeneric(RUSAGE_THREAD);\n#elif defined(__APPLE__)\n\t/* No RUSAGE_THREAD so we use the lower level interface */\n\tstruct thread_basic_info info;\n\tmach_msg_type_number_t info_count = THREAD_BASIC_INFO_COUNT;\n\tif (KERN_SUCCESS != thread_info(mach_thread_self(), THREAD_BASIC_INFO, (thread_info_t)&info, &info_count)) {\n\t\tTraceEvent(SevError, \"GetThreadCPUTime\").GetLastError();\n\t\tthrow platform_error();\n\t}\n\treturn (info.user_time.seconds + (info.user_time.microseconds / double(1e6)) +\n\t\t\tinfo.system_time.seconds + (info.system_time.microseconds / double(1e6)));\n#else\n\t#warning getProcessorTimeThread unimplemented on this platform\n\treturn 0.0;\n#endif\n}\n\ndouble getProcessorTimeProcess() {\n\tINJECT_FAULT( platform_error, \"getProcessorTimeProcess\" );\n#if defined(_WIN32)\n\tFILETIME ftCreate, ftExit, ftKernel, ftUser;\n\tif (!GetProcessTimes(GetCurrentProcess(), &ftCreate, &ftExit, &ftKernel, &ftUser)) {\n\t\tTraceEvent(SevError, \"GetProcessCPUTime\").GetLastError();\n\t\tthrow platform_error();\n\t}\n\treturn FiletimeAsInt64(ftKernel) / double(1e7) + FiletimeAsInt64(ftUser) / double(1e7);\n#elif defined(__unixish__)\n\treturn getProcessorTimeGeneric(RUSAGE_SELF);\n#else\n\t#warning getProcessorTimeProcess unimplemented on this platform\n\treturn 0.0;\n#endif\n}\n\nuint64_t getResidentMemoryUsage() {\n#if defined(__linux__)\n\tuint64_t rssize = 0;\n\n\tstd::ifstream stat_stream(\"/proc/self/statm\", std::ifstream::in);\n\tstd::string ignore;\n\n\tif(!stat_stream.good()) {\n\t\tTraceEvent(SevError, \"GetResidentMemoryUsage\").GetLastError();\n\t\tthrow platform_error();\n\t}\n\n\tstat_stream >> ignore;\n\tstat_stream >> rssize;\n\n\trssize *= sysconf(_SC_PAGESIZE);\n\n\treturn rssize;\n#elif defined(_WIN32)\n\tPROCESS_MEMORY_COUNTERS_EX pmc;\n\tif(!GetProcessMemoryInfo(GetCurrentProcess(), (PPROCESS_MEMORY_COUNTERS)&pmc, sizeof(pmc))) {\n\t\tTraceEvent(SevError, \"GetResidentMemoryUsage\").GetLastError();\n\t\tthrow platform_error();\n\t}\n\treturn pmc.WorkingSetSize;\n#elif defined(__APPLE__)\n\tstruct task_basic_info info;\n\tmach_msg_type_number_t info_count = TASK_BASIC_INFO_COUNT;\n\tif (KERN_SUCCESS != task_info(mach_task_self(), TASK_BASIC_INFO, (task_info_t)&info, &info_count)) {\n\t\tTraceEvent(SevError, \"GetResidentMemoryUsage\").GetLastError();\n\t\tthrow platform_error();\n\t}\n\treturn info.resident_size;\n#else\n\t#warning getMemoryUsage unimplemented on this platform\n\treturn 0;\n#endif\n}\n\nuint64_t getMemoryUsage() {\n#if defined(__linux__)\n\tuint64_t vmsize = 0;\n\n\tstd::ifstream stat_stream(\"/proc/self/statm\", std::ifstream::in);\n\n\tif(!stat_stream.good()) {\n\t\tTraceEvent(SevError, \"GetMemoryUsage\").GetLastError();\n\t\tthrow platform_error();\n\t}\n\n\tstat_stream >> vmsize;\n\n\tvmsize *= sysconf(_SC_PAGESIZE);\n\n\treturn vmsize;\n#elif defined(_WIN32)\n\tPROCESS_MEMORY_COUNTERS_EX pmc;\n\tif(!GetProcessMemoryInfo(GetCurrentProcess(), (PPROCESS_MEMORY_COUNTERS)&pmc, sizeof(pmc))) {\n\t\tTraceEvent(SevError, \"GetMemoryUsage\").GetLastError();\n\t\tthrow platform_error();\n\t}\n\treturn pmc.PagefileUsage;\n#elif defined(__APPLE__)\n\tstruct task_basic_info info;\n\tmach_msg_type_number_t info_count = TASK_BASIC_INFO_COUNT;\n\tif (KERN_SUCCESS != task_info(mach_task_self(), TASK_BASIC_INFO, (task_info_t)&info, &info_count)) {\n\t\tTraceEvent(SevError, \"GetMemoryUsage\").GetLastError();\n\t\tthrow platform_error();\n\t}\n\treturn info.virtual_size;\n#else\n\t#warning getMemoryUsage unimplemented on this platform\n\treturn 0;\n#endif\n}\n\n#if defined(__linux__)\nvoid getMemoryInfo(std::map<StringRef, int64_t>& request, std::stringstream& memInfoStream) {\n\tsize_t count = request.size();\n\tif (count == 0)\n\t\treturn;\n\n\twhile (count > 0 && !memInfoStream.eof()) {\n\t\tstd::string key;\n\n\t\tmemInfoStream >> key;\n\t\tauto item = request.find(StringRef(key));\n\t\tif (item != request.end()){\n\t\t\tint64_t value;\n\t\t\tmemInfoStream >> value;\n\t\t\titem->second = value;\n\t\t\tcount--;\n\t\t}\n\t\tmemInfoStream.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n\t}\n}\n\nint64_t getLowWatermark(std::stringstream& zoneInfoStream) {\n\tint64_t lowWatermark = 0;\n\twhile(!zoneInfoStream.eof()) {\n\t\tstd::string key;\n\t\tzoneInfoStream >> key;\n\n\t\tif(key == \"low\") {\n\t\t\tint64_t value;\n\t\t\tzoneInfoStream >> value;\n\t\t\tlowWatermark += value;\n\t\t}\n\n\t\tzoneInfoStream.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n\t}\n\n\treturn lowWatermark;\n}\n#endif\n\nvoid getMachineRAMInfo(MachineRAMInfo& memInfo) {\n#if defined(__linux__)\n\tstd::ifstream zoneInfoFileStream(\"/proc/zoneinfo\", std::ifstream::in);\n\tint64_t lowWatermark = 0;\n\tif(!zoneInfoFileStream.good()) {\n\t\tTraceEvent(SevWarnAlways, \"GetMachineZoneInfo\").GetLastError();\n\t}\n\telse {\n\t\tstd::stringstream zoneInfoStream;\n\t\tzoneInfoStream << zoneInfoFileStream.rdbuf();\n\t\tlowWatermark = getLowWatermark(zoneInfoStream) * 4; // Convert from 4K pages to KB\n\t}\n\n\tstd::ifstream fileStream(\"/proc/meminfo\", std::ifstream::in);\n\tif (!fileStream.good()) {\n\t\tTraceEvent(SevError, \"GetMachineMemInfo\").GetLastError();\n\t\tthrow platform_error();\n\t}\n\n\tstd::map<StringRef, int64_t> request = {\n\t\t{ LiteralStringRef(\"MemTotal:\"), 0 },\n\t\t{ LiteralStringRef(\"MemFree:\"), 0 },\n\t\t{ LiteralStringRef(\"MemAvailable:\"), -1 },\n\t\t{ LiteralStringRef(\"Active(file):\"), 0 },\n\t\t{ LiteralStringRef(\"Inactive(file):\"), 0 },\n\t\t{ LiteralStringRef(\"SwapTotal:\"), 0 },\n\t\t{ LiteralStringRef(\"SwapFree:\"), 0 },\n\t\t{ LiteralStringRef(\"SReclaimable:\"), 0 },\n\t};\n\n\tstd::stringstream memInfoStream;\n\tmemInfoStream << fileStream.rdbuf();\n\tgetMemoryInfo( request, memInfoStream );\n\n\tint64_t memFree = request[LiteralStringRef(\"MemFree:\")];\n\tint64_t pageCache = request[LiteralStringRef(\"Active(file):\")] + request[LiteralStringRef(\"Inactive(file):\")];\n\tint64_t slabReclaimable = request[LiteralStringRef(\"SReclaimable:\")];\n\tint64_t usedSwap = request[LiteralStringRef(\"SwapTotal:\")] - request[LiteralStringRef(\"SwapFree:\")];\n\n\tmemInfo.total = 1024 * request[LiteralStringRef(\"MemTotal:\")];\n\tif(request[LiteralStringRef(\"MemAvailable:\")] != -1) {\n\t\tmemInfo.available = 1024 * (request[LiteralStringRef(\"MemAvailable:\")] - usedSwap);\n\t}\n\telse {\n\t\tmemInfo.available = 1024 * (std::max<int64_t>(0, (memFree-lowWatermark) + std::max(pageCache-lowWatermark, pageCache/2) + std::max(slabReclaimable-lowWatermark, slabReclaimable/2)) - usedSwap);\n\t}\n\n\tmemInfo.committed = memInfo.total - memInfo.available;\n#elif defined(_WIN32)\n\tMEMORYSTATUSEX mem_status;\n\tmem_status.dwLength = sizeof(mem_status);\n\tif (!GlobalMemoryStatusEx(&mem_status)) {\n\t\tTraceEvent(SevError, \"WindowsGetMemStatus\").GetLastError();\n\t\tthrow platform_error();\n\t}\n\n\tPERFORMACE_INFORMATION perf;\n\tif (!GetPerformanceInfo(&perf, sizeof(perf))) {\n\t\tTraceEvent(SevError, \"WindowsGetMemPerformanceInfo\").GetLastError();\n\t\tthrow platform_error();\n\t}\n\n\tmemInfo.total = mem_status.ullTotalPhys;\n\tmemInfo.committed = perf.PageSize*perf.CommitTotal;\n\tmemInfo.available = memInfo.total - memInfo.committed;\n#elif defined(__APPLE__)\n\tvm_statistics_data_t vm_stat;\n\tvm_size_t pagesize;\n\tmach_msg_type_number_t host_size = sizeof(vm_statistics_data_t) / sizeof(integer_t);\n\tif (KERN_SUCCESS != host_statistics(mach_host_self(), HOST_VM_INFO, (host_info_t)&vm_stat, &host_size)) {\n\t\tTraceEvent(SevError, \"GetMachineMemInfo\").GetLastError();\n\t\tthrow platform_error();\n\t}\n\thost_page_size(mach_host_self(), &pagesize);\n\n\tmemInfo.total = pagesize * (vm_stat.free_count + vm_stat.active_count + vm_stat.inactive_count + vm_stat.wire_count);\n\tmemInfo.available = pagesize * vm_stat.free_count;\n\tmemInfo.committed = memInfo.total - memInfo.available;\n#else\n\t#warning getMachineRAMInfo unimplemented on this platform\n#endif\n}\n\nError systemErrorCodeToError() {\n#if defined(_WIN32)\n\tif(GetLastError() == ERROR_IO_DEVICE) {\n\t\treturn io_error();\n\t}\n#elif defined(__unixish__)\n\tif(errno == EIO || errno == EROFS) {\n\t\treturn io_error();\n\t}\n#else\n\t#error Port me!\n#endif\n\n\treturn platform_error();\n}\n\nvoid getDiskBytes(std::string const& directory, int64_t& free, int64_t& total) {\n\tINJECT_FAULT( platform_error, \"getDiskBytes\" );\n#if defined(__unixish__)\n#ifdef __linux__\n\tstruct statvfs buf;\n\tif (statvfs(directory.c_str(), &buf)) {\n\t\tError e = systemErrorCodeToError();\n\t\tTraceEvent(SevError, \"GetDiskBytesStatvfsError\").detail(\"Directory\", directory).GetLastError().error(e);\n\t\tthrow e;\n\t}\n\n\tuint64_t blockSize = buf.f_frsize;\n#elif defined(__APPLE__)\n\tstruct statfs buf;\n\tif (statfs(directory.c_str(), &buf)) {\n\t\tError e = systemErrorCodeToError();\n\t\tTraceEvent(SevError, \"GetDiskBytesStatfsError\").detail(\"Directory\", directory).GetLastError().error(e);\n\t\tthrow e;\n\t}\n\n\tuint64_t blockSize = buf.f_bsize;\n#else\n#error Unknown unix\n#endif\n\n\tfree = std::min( (uint64_t) std::numeric_limits<int64_t>::max(), buf.f_bavail * blockSize );\n\ttotal = std::min( (uint64_t) std::numeric_limits<int64_t>::max(), buf.f_blocks * blockSize );\n\n#elif defined(_WIN32)\n\tstd::string fullPath = abspath(directory);\n\t//TraceEvent(\"FullDiskPath\").detail(\"Path\", fullPath).detail(\"Disk\", (char)toupper(fullPath[0]));\n\n\tULARGE_INTEGER freeSpace;\n\tULARGE_INTEGER totalSpace;\n\tULARGE_INTEGER totalFreeSpace;\n\tif( !GetDiskFreeSpaceEx( fullPath.c_str(), &freeSpace, &totalSpace, &totalFreeSpace ) ) {\n\t\tError e = systemErrorCodeToError();\n\t\tTraceEvent(SevError, \"DiskFreeError\").detail(\"Path\", fullPath).GetLastError().error(e);\n\t\tthrow e;\n\t}\n\ttotal = std::min( (uint64_t) std::numeric_limits<int64_t>::max(), totalSpace.QuadPart );\n\tfree = std::min( (uint64_t) std::numeric_limits<int64_t>::max(), freeSpace.QuadPart );\n#else\n\t#warning getDiskBytes unimplemented on this platform\n\tfree = 1LL<<50;\n\ttotal = 1LL<<50;\n#endif\n}\n\n#ifdef __unixish__\nconst char* getInterfaceName(const IPAddress& _ip) {\n\tINJECT_FAULT( platform_error, \"getInterfaceName\" );\n\tstatic char iname[20];\n\n\tstruct ifaddrs* interfaces = NULL;\n\tconst char* ifa_name = NULL;\n\n\tif (getifaddrs(&interfaces)) {\n\t\tTraceEvent(SevWarnAlways, \"GetInterfaceAddrs\").GetLastError();\n\t\tthrow platform_error();\n\t}\n\n\tfor (struct ifaddrs* iter = interfaces; iter; iter = iter->ifa_next) {\n\t\tif(!iter->ifa_addr)\n\t\t\tcontinue;\n\t\tif (iter->ifa_addr->sa_family == AF_INET && _ip.isV4()) {\n\t\t\tuint32_t ip = ntohl((reinterpret_cast<struct sockaddr_in*>(iter->ifa_addr))->sin_addr.s_addr);\n\t\t\tif (ip == _ip.toV4()) {\n\t\t\t\tifa_name = iter->ifa_name;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else if (iter->ifa_addr->sa_family == AF_INET6 && _ip.isV6()) {\n\t\t\tstruct sockaddr_in6* ifa_addr = reinterpret_cast<struct sockaddr_in6*>(iter->ifa_addr);\n\t\t\tif (memcmp(_ip.toV6().data(), &ifa_addr->sin6_addr, 16) == 0) {\n\t\t\t\tifa_name = iter->ifa_name;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tif (ifa_name) {\n\t\tstrncpy(iname, ifa_name, 19);\n\t\tiname[19] = 0;\n\t}\n\n\tfreeifaddrs(interfaces);\n\n\tif (ifa_name)\n\t\treturn iname;\n\telse\n\t\treturn NULL;\n}\n#endif\n\n#if defined(__linux__)\nvoid getNetworkTraffic(const IPAddress& ip, uint64_t& bytesSent, uint64_t& bytesReceived, uint64_t& outSegs,\n                       uint64_t& retransSegs) {\n\tINJECT_FAULT( platform_error, \"getNetworkTraffic\" ); // Even though this function doesn't throw errors, the equivalents for other platforms do, and since all of our simulation testing is on Linux...\n\tconst char* ifa_name = nullptr;\n\ttry {\n\t\tifa_name = getInterfaceName(ip);\n\t}\n\tcatch(Error &e) {\n\t\tif(e.code() != error_code_platform_error) {\n\t\t\tthrow;\n\t\t}\n\t}\n\n\tif (!ifa_name)\n\t\treturn;\n\n\tstd::ifstream dev_stream(\"/proc/net/dev\", std::ifstream::in);\n\tdev_stream.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n\tdev_stream.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n\n\tstd::string iface;\n\tstd::string ignore;\n\n\tuint64_t bytesSentSum = 0;\n\tuint64_t bytesReceivedSum = 0;\n\n\twhile (dev_stream.good()) {\n\t\tdev_stream >> iface;\n\t\tif (dev_stream.eof()) break;\n\t\tif (!strncmp(iface.c_str(), ifa_name, strlen(ifa_name))) {\n\t\t\tuint64_t sent = 0, received = 0;\n\n\t\t\tdev_stream >> received;\n\t\t\tfor (int i = 0; i < 7; i++) dev_stream >> ignore;\n\t\t\tdev_stream >> sent;\n\n\t\t\tbytesSentSum += sent;\n\t\t\tbytesReceivedSum += received;\n\n\t\t\tdev_stream.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n\t\t}\n\t}\n\n\tif(bytesSentSum > 0) {\n\t\tbytesSent = bytesSentSum;\n\t}\n\tif(bytesReceivedSum > 0) {\n\t\tbytesReceived = bytesReceivedSum;\n\t}\n\n\tstd::ifstream snmp_stream(\"/proc/net/snmp\", std::ifstream::in);\n\n\tstd::string label;\n\n\twhile (snmp_stream.good()) {\n\t\tsnmp_stream >> label;\n\t\tsnmp_stream.ignore(std::numeric_limits<std::streamsize>::max(), '\\n');\n\t\tif (label == \"Tcp:\")\n\t\t\tbreak;\n\t}\n\n\t/* Ignore the first 11 columns of the Tcp line */\n\tfor (int i = 0; i < 11; i++)\n\t\tsnmp_stream >> ignore;\n\n\tsnmp_stream >> outSegs;\n\tsnmp_stream >> retransSegs;\n}\n\nvoid getMachineLoad(uint64_t& idleTime, uint64_t& totalTime, bool logDetails) {\n\tINJECT_FAULT( platform_error, \"getMachineLoad\" ); // Even though this function doesn't throw errors, the equivalents for other platforms do, and since all of our simulation testing is on Linux...\n\tstd::ifstream stat_stream(\"/proc/stat\", std::ifstream::in);\n\n\tstd::string ignore;\n\tstat_stream >> ignore;\n\n\tuint64_t t_user, t_nice, t_system, t_idle, t_iowait, t_irq, t_softirq, t_steal, t_guest;\n\tstat_stream >> t_user >> t_nice >> t_system >> t_idle >> t_iowait >> t_irq >> t_softirq >> t_steal >> t_guest;\n\n\ttotalTime = t_user+t_nice+t_system+t_idle+t_iowait+t_irq+t_softirq+t_steal+t_guest;\n\tidleTime = t_idle+t_iowait;\n\n\tif( !DEBUG_DETERMINISM && logDetails )\n\t\tTraceEvent(\"MachineLoadDetail\").detail(\"User\", t_user).detail(\"Nice\", t_nice).detail(\"System\", t_system).detail(\"Idle\", t_idle).detail(\"IOWait\", t_iowait).detail(\"IRQ\", t_irq).detail(\"SoftIRQ\", t_softirq).detail(\"Steal\", t_steal).detail(\"Guest\", t_guest);\n}\n\nvoid getDiskStatistics(std::string const& directory, uint64_t& currentIOs, uint64_t& busyTicks, uint64_t& reads, uint64_t& writes, uint64_t& writeSectors, uint64_t& readSectors) {\n\tINJECT_FAULT( platform_error, \"getDiskStatistics\" );\n\tcurrentIOs = 0;\n\n\tstruct stat buf;\n\tif (stat(directory.c_str(), &buf)) {\n\t\tTraceEvent(SevError, \"GetDiskStatisticsStatError\").detail(\"Directory\", directory).GetLastError();\n\t\tthrow platform_error();\n\t}\n\n\tstd::ifstream proc_stream(\"/proc/diskstats\", std::ifstream::in);\n\twhile (proc_stream.good()) {\n\t\tstd::string line;\n\t\tgetline(proc_stream, line);\n\t\tstd::istringstream disk_stream(line, std::istringstream::in);\n\n\t\tunsigned int majorId;\n\t\tunsigned int minorId;\n\t\tdisk_stream >> majorId;\n\t\tdisk_stream >> minorId;\n\t\tif(majorId == (unsigned int) gnu_dev_major(buf.st_dev) && minorId == (unsigned int) gnu_dev_minor(buf.st_dev)) {\n\t\t\tstd::string ignore;\n\t\t\tuint64_t rd_ios;\t/* # of reads completed */\n\t\t\t//\t    This is the total number of reads completed successfully.\n\n\t\t\tuint64_t rd_merges;\t/* # of reads merged */\n\t\t\t//\t    Reads and writes which are adjacent to each other may be merged for\n\t\t\t//\t    efficiency.  Thus two 4K reads may become one 8K read before it is\n\t\t\t//\t    ultimately handed to the disk, and so it will be counted (and queued)\n\t\t\t//\t    as only one I/O.  This field lets you know how often this was done.\n\n\t\t\tuint64_t rd_sectors; /*# of sectors read */\n\t\t\t//\t    This is the total number of sectors read successfully.\n\n\t\t\tuint64_t rd_ticks;\t/* # of milliseconds spent reading */\n\t\t\t//\t    This is the total number of milliseconds spent by all reads (as\n\t\t\t//\t    measured from __make_request() to end_that_request_last()).\n\n\t\t\tuint64_t wr_ios;\t/* # of writes completed */\n\t\t\t//\t    This is the total number of writes completed successfully.\n\n\t\t\tuint64_t wr_merges;\t/* # of writes merged */\n\t\t\t//\t    Reads and writes which are adjacent to each other may be merged for\n\t\t\t//\t    efficiency.  Thus two 4K reads may become one 8K read before it is\n\t\t\t//\t    ultimately handed to the disk, and so it will be counted (and queued)\n\t\t\t//\t    as only one I/O.  This field lets you know how often this was done.\n\n\t\t\tuint64_t wr_sectors; /* # of sectors written */\n\t\t\t//\t    This is the total number of sectors written successfully.\n\n\t\t\tuint64_t wr_ticks;\t/* # of milliseconds spent writing */\n\t\t\t//\t    This is the total number of milliseconds spent by all writes (as\n\t\t\t//\t    measured from __make_request() to end_that_request_last()).\n\n\t\t\tuint64_t cur_ios;\t/* # of I/Os currently in progress */\n\t\t\t//\t    The only field that should go to zero. Incremented as requests are\n\t\t\t//\t    given to appropriate struct request_queue and decremented as they finish.\n\n\t\t\tuint64_t ticks;\t/* # of milliseconds spent doing I/Os */\n\t\t\t//\t    This field increases so long as field 9 is nonzero.\n\n\t\t\tuint64_t aveq;\t/* weighted # of milliseconds spent doing I/Os */\n\t\t\t//\t    This field is incremented at each I/O start, I/O completion, I/O\n\t\t\t//\t    merge, or read of these stats by the number of I/Os in progress\n\t\t\t//\t    (field 9) times the number of milliseconds spent doing I/O since the\n\t\t\t//\t    last update of this field.  This can provide an easy measure of both\n\t\t\t//\t    I/O completion time and the backlog that may be accumulating.\n\n\t\t\tdisk_stream >> ignore;\n\t\t\tdisk_stream >> rd_ios;\n\t\t\tdisk_stream >> rd_merges;\n\t\t\tdisk_stream >> rd_sectors;\n\t\t\tdisk_stream >> rd_ticks;\n\t\t\tdisk_stream >> wr_ios;\n\t\t\tdisk_stream >> wr_merges;\n\t\t\tdisk_stream >> wr_sectors;\n\t\t\tdisk_stream >> wr_ticks;\n\t\t\tdisk_stream >> cur_ios;\n\t\t\tdisk_stream >> ticks;\n\t\t\tdisk_stream >> aveq;\n\n\t\t\tcurrentIOs = cur_ios;\n\t\t\tbusyTicks = ticks;\n\t\t\treads = rd_ios;\n\t\t\twrites = wr_ios;\n\t\t\twriteSectors = wr_sectors;\n\t\t\treadSectors = rd_sectors;\n\n\t\t\t//TraceEvent(\"DiskMetricsRaw\").detail(\"Input\", line).detail(\"Ignore\", ignore).detail(\"RdIos\", rd_ios)\n\t\t\t//\t.detail(\"RdMerges\", rd_merges).detail(\"RdSectors\", rd_sectors).detail(\"RdTicks\", rd_ticks).detail(\"WrIos\", wr_ios).detail(\"WrMerges\", wr_merges)\n\t\t\t//\t.detail(\"WrSectors\", wr_sectors).detail(\"WrTicks\", wr_ticks).detail(\"CurIos\", cur_ios).detail(\"Ticks\", ticks).detail(\"Aveq\", aveq)\n\t\t\t//\t.detail(\"CurrentIOs\", currentIOs).detail(\"BusyTicks\", busyTicks).detail(\"Reads\", reads).detail(\"Writes\", writes).detail(\"WriteSectors\", writeSectors)\n\t\t\t//  .detail(\"ReadSectors\", readSectors);\n\t\t\treturn;\n\t\t} else\n\t\t\tdisk_stream.ignore( std::numeric_limits<std::streamsize>::max(), '\\n');\n\t}\n\n\tif(!g_network->isSimulated()) TraceEvent(SevWarn, \"GetDiskStatisticsDeviceNotFound\").detail(\"Directory\", directory);\n}\n\ndev_t getDeviceId(std::string path) {\n\tstruct stat statInfo;\n\n\twhile (true) {\n\t\tint returnValue = stat(path.c_str(), &statInfo);\n\t\tif (!returnValue) break;\n\n\t\tif (errno == ENOENT) {\n\t\t\tpath = parentDirectory(path);\n\t\t} else {\n\t\t\tTraceEvent(SevError, \"GetDeviceIdError\").detail(\"Path\", path).GetLastError();\n\t\t\tthrow platform_error();\n\t\t}\n\t}\n\n\treturn statInfo.st_dev;\n}\n\n#endif\n\n#ifdef __APPLE__\nvoid getNetworkTraffic(const IPAddress& ip, uint64_t& bytesSent, uint64_t& bytesReceived, uint64_t& outSegs,\n                       uint64_t& retransSegs) {\n\tINJECT_FAULT( platform_error, \"getNetworkTraffic\" );\n\n\tconst char* ifa_name = nullptr;\n\ttry {\n\t\tifa_name = getInterfaceName(ip);\n\t}\n\tcatch(Error &e) {\n\t\tif(e.code() != error_code_platform_error) {\n\t\t\tthrow;\n\t\t}\n\t}\n\n\tif (!ifa_name)\n\t\treturn;\n\n\tint mib[] = {\n\t\tCTL_NET,\n\t\tPF_ROUTE,\n\t\t0,\n\t\tAF_INET,\n\t\tNET_RT_IFLIST2,\n\t\t0 /* If we could get an interface index instead of name, we would pass it here */\n\t};\n\n\tsize_t len;\n\n\tif (sysctl(mib, 6, NULL, &len, NULL, 0) < 0) {\n\t\tTraceEvent(SevError, \"GetNetworkTrafficError\").GetLastError();\n\t\tthrow platform_error();\n\t}\n\n\tchar *buf = (char*)malloc(len);\n\n\tif (sysctl(mib, 6, buf, &len, NULL, 0) < 0) {\n\t\tfree(buf);\n\t\tTraceEvent(SevError, \"GetNetworkTrafficReadInterfacesError\").GetLastError();\n\t\tthrow platform_error();\n\t}\n\n\tchar *lim = buf + len;\n\n\tfor (char *next = buf; next < lim; ) {\n\t\tstruct if_msghdr* ifm = (struct if_msghdr*)next;\n\t\tnext += ifm->ifm_msglen;\n\n\t\tif ((ifm->ifm_type = RTM_IFINFO2)) {\n\t\t\tstruct if_msghdr2* if2m = (struct if_msghdr2*)ifm;\n\t\t\tstruct sockaddr_dl *sdl = (struct sockaddr_dl*)(if2m + 1);\n\n\t\t\tif (sdl->sdl_nlen == strlen(ifa_name) && !strncmp(ifa_name, sdl->sdl_data, sdl->sdl_nlen)) {\n\t\t\t\tbytesSent = if2m->ifm_data.ifi_obytes;\n\t\t\t\tbytesReceived = if2m->ifm_data.ifi_ibytes;\n\t\t\t\toutSegs = if2m->ifm_data.ifi_opackets;\n\t\t\t\tretransSegs = 0;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\tfree(buf);\n}\n\nvoid getMachineLoad(uint64_t& idleTime, uint64_t& totalTime, bool logDetails) {\n\tINJECT_FAULT( platform_error, \"getMachineLoad\" );\n\tmach_msg_type_number_t count = HOST_CPU_LOAD_INFO_COUNT;\n\thost_cpu_load_info_data_t r_load;\n\n\tif (host_statistics(mach_host_self(), HOST_CPU_LOAD_INFO, (host_info_t)&r_load, &count) != KERN_SUCCESS) {\n\t\tTraceEvent(SevError, \"GetMachineLoad\").GetLastError();\n\t\tthrow platform_error();\n\t}\n\n\tidleTime = r_load.cpu_ticks[CPU_STATE_IDLE];\n\ttotalTime = r_load.cpu_ticks[CPU_STATE_IDLE] + r_load.cpu_ticks[CPU_STATE_USER] + r_load.cpu_ticks[CPU_STATE_NICE] + r_load.cpu_ticks[CPU_STATE_SYSTEM];\n}\n\nvoid getDiskStatistics(std::string const& directory, uint64_t& currentIOs, uint64_t& busyTicks, uint64_t& reads, uint64_t& writes, uint64_t& writeSectors, uint64_t& readSectors) {\n\tINJECT_FAULT( platform_error, \"getDiskStatistics\" );\n\tcurrentIOs = 0;\n\tbusyTicks = 0;\n\twriteSectors = 0;\n\treadSectors = 0;\n\n\tstruct statfs buf;\n\tif (statfs(directory.c_str(), &buf)) {\n\t\tError e = systemErrorCodeToError();\n\t\tTraceEvent(SevError, \"GetDiskStatisticsStatfsError\").detail(\"Directory\", directory).GetLastError().error(e);\n\t\tthrow e;\n\t}\n\n\tconst char* dev = strrchr(buf.f_mntfromname, '/');\n\tif (!dev) {\n\t\tTraceEvent(SevError, \"GetDiskStatisticsStrrchrError\").detail(\"Directory\", directory).GetLastError();\n\t\tthrow platform_error();\n\t}\n\tdev++;\n\n\tio_iterator_t disk_list;\n\n\t// According to Apple docs, if this gets passed to IOServiceGetMatchingServices, we aren't responsible for the memory anymore,\n\t// the only case where it isn't passed is if it's null, in which case we also aren't responsible. So no need to call CFRelease\n\t// on this variable.\n\tCFMutableDictionaryRef match = IOBSDNameMatching(kIOMasterPortDefault, kNilOptions, dev);\n\n\tif(!match) {\n\t\tTraceEvent(SevError, \"IOBSDNameMatching\");\n\t\tthrow platform_error();\n\t}\n\n\tif (IOServiceGetMatchingServices(kIOMasterPortDefault, match, &disk_list) != kIOReturnSuccess) {\n\t\tTraceEvent(SevError, \"IOServiceGetMatchingServices\");\n\t\tthrow platform_error();\n\t}\n\n\tio_registry_entry_t disk = IOIteratorNext(disk_list);\n\tif (!disk) {\n\t\tIOObjectRelease(disk_list);\n\t\tTraceEvent(SevError, \"IOIteratorNext\");\n\t\tthrow platform_error();\n\t}\n\n\tio_registry_entry_t tdisk = disk;\n\twhile (!IOObjectConformsTo(disk, \"IOBlockStorageDriver\")) {\n\t\tIORegistryEntryGetParentEntry(disk, kIOServicePlane, &tdisk);\n\t\tIOObjectRelease(disk);\n\t\tdisk = tdisk;\n\t}\n\n\tCFDictionaryRef disk_dict = NULL;\n\tif (IORegistryEntryCreateCFProperties(disk, (CFMutableDictionaryRef*)&disk_dict, kCFAllocatorDefault, kNilOptions) != kIOReturnSuccess) {\n\t\tIOObjectRelease(disk);\n\t\tIOObjectRelease(disk_list);\n\t\tTraceEvent(SevError, \"IORegistryEntryCreateCFProperties\");\n\t\tthrow platform_error();\n\t}\n\n\t// Here and below, note that memory returned by CFDictionaryGetValue() is not owned by us, and should not be CFRelease()'d by us.\n\tCFDictionaryRef stats_dict = (CFDictionaryRef)CFDictionaryGetValue(disk_dict, CFSTR(kIOBlockStorageDriverStatisticsKey));\n\n\tif (stats_dict == NULL) {\n\t\tCFRelease(disk_dict);\n\t\tIOObjectRelease(disk);\n\t\tIOObjectRelease(disk_list);\n\t\tTraceEvent(SevError, \"CFDictionaryGetValue\");\n\t\tthrow platform_error();\n\t}\n\n\tCFNumberRef number;\n\n\tif ((number = (CFNumberRef)CFDictionaryGetValue(stats_dict, CFSTR(kIOBlockStorageDriverStatisticsReadsKey)))) {\n\t\tCFNumberGetValue(number, kCFNumberSInt64Type, &reads);\n\t}\n\n\tif ((number = (CFNumberRef)CFDictionaryGetValue(stats_dict, CFSTR(kIOBlockStorageDriverStatisticsWritesKey)))) {\n\t\tCFNumberGetValue(number, kCFNumberSInt64Type, &writes);\n\t}\n\n\tCFRelease(disk_dict);\n\tIOObjectRelease(disk);\n\tIOObjectRelease(disk_list);\n}\n#endif\n\n#if defined(_WIN32)\nstd::vector<std::string> expandWildcardPath(const char *wildcardPath)\n{\n\tPDH_STATUS Status;\n\tchar *EndOfPaths;\n\tchar *Paths = NULL;\n\tDWORD BufferSize = 0;\n\tstd::vector<std::string> results;\n\n\tStatus = PdhExpandCounterPath(wildcardPath, Paths, &BufferSize);\n\tif (Status != PDH_MORE_DATA) {\n\t\tTraceEvent(SevWarn, \"PdhExpandCounterPathError\").detail(\"Reason\", \"Expand Path call made no sense\").detail(\"Status\", Status);\n\t\tgoto Cleanup;\n\t}\n\n\tPaths = (char *)malloc(BufferSize);\n\tStatus = PdhExpandCounterPath(wildcardPath, Paths, &BufferSize);\n\n\tif (Status != ERROR_SUCCESS) {\n\t\tTraceEvent(SevWarn, \"PdhExpandCounterPathError\").detail(\"Reason\", \"Expand Path call failed\").detail(\"Status\", Status);\n\t\tgoto Cleanup;\n\t}\n\n\tif (Paths == NULL) {\n\t\tTraceEvent(\"WindowsPdhExpandCounterPathError\").detail(\"Reason\", \"Path could not be expanded\");\n\t\tgoto Cleanup;\n\t}\n\n\tEndOfPaths = Paths + BufferSize;\n\n\tfor (char *p = Paths; ((p != EndOfPaths) && (*p != '\\0')); p += strlen(p) + 1) {\n\t\tresults.push_back( p );\n\t\t//printf(\"Counter: %s\\n\", p);\n\t}\n\nCleanup:\n\tif (Paths)\n\t{\n\t\tfree(Paths);\n\t}\n\treturn results;\n}\n\nstd::vector<HCOUNTER> addCounters( HQUERY Query, const char *path ) {\n\tstd::vector<HCOUNTER> counters;\n\n\tstd::vector<std::string> paths = expandWildcardPath( path );\n\n\tfor(int i = 0; i < paths.size(); i++) {\n\t\tHCOUNTER counter;\n\t\thandlePdhStatus( PdhAddCounter(Query, paths[i].c_str(), 0, &counter), \"PdhAddCounter\" );\n\t\tcounters.push_back( counter );\n\t}\n\treturn counters;\n}\n#endif\n\nstruct SystemStatisticsState {\n\tdouble lastTime;\n\tdouble lastClockThread;\n\tdouble lastClockProcess;\n\tuint64_t processLastSent;\n\tuint64_t processLastReceived;\n#if defined(_WIN32)\n\tstruct {\n\t\tstd::string diskDevice;\n\t\tstd::string physicalDisk;\n\t\tstd::string processor;\n\t\tstd::string networkDevice;\n\t\tstd::string tcpv4;\n\t\tstd::string pctIdle;\n\t\tstd::string diskQueueLength;\n\t\tstd::string diskReadsPerSec;\n\t\tstd::string diskWritesPerSec;\n\t\tstd::string diskWriteBytesPerSec;\n\t\tstd::string bytesSentPerSec;\n\t\tstd::string bytesRecvPerSec;\n\t\tstd::string segmentsOutPerSec;\n\t\tstd::string segmentsRetransPerSec;\n\t} pdhStrings;\n\tPDH_STATUS Status;\n\tHQUERY Query;\n\tHCOUNTER QueueLengthCounter;\n\tHCOUNTER DiskTimeCounter;\n\tHCOUNTER ReadsCounter;\n\tHCOUNTER WritesCounter;\n\tHCOUNTER WriteBytesCounter;\n\tstd::vector<HCOUNTER> SendCounters;\n\tstd::vector<HCOUNTER> ReceiveCounters;\n\tHCOUNTER SegmentsOutCounter;\n\tHCOUNTER SegmentsRetransCounter;\n\tHCOUNTER ProcessorIdleCounter;\n\tSystemStatisticsState() : Query(NULL), QueueLengthCounter(NULL), DiskTimeCounter(NULL),\n\t\tReadsCounter(NULL), WritesCounter(NULL), WriteBytesCounter(NULL), ProcessorIdleCounter(NULL),\n#elif defined(__unixish__)\n\tuint64_t machineLastSent, machineLastReceived;\n\tuint64_t machineLastOutSegs, machineLastRetransSegs;\n\tuint64_t lastBusyTicks, lastReads, lastWrites, lastWriteSectors, lastReadSectors;\n\tuint64_t lastClockIdleTime, lastClockTotalTime;\n\tSystemStatisticsState() : machineLastSent(0), machineLastReceived(0), machineLastOutSegs(0), machineLastRetransSegs(0),\n\t\tlastBusyTicks(0), lastReads(0), lastWrites(0), lastWriteSectors(0), lastReadSectors(0), lastClockIdleTime(0), lastClockTotalTime(0),\n#else\n\t#error Port me!\n#endif\n\t\tlastTime(0), lastClockThread(0), lastClockProcess(0), processLastSent(0), processLastReceived(0) {}\n};\n\n#if defined(_WIN32)\nvoid initPdhStrings(SystemStatisticsState *state, std::string dataFolder) {\n\tif (setPdhString(234, state->pdhStrings.physicalDisk) &&\n\t\tsetPdhString(238, state->pdhStrings.processor) &&\n\t\tsetPdhString(510, state->pdhStrings.networkDevice) &&\n\t\tsetPdhString(638, state->pdhStrings.tcpv4) &&\n\t\tsetPdhString(1482, state->pdhStrings.pctIdle) &&\n\t\tsetPdhString(198, state->pdhStrings.diskQueueLength) &&\n\t\tsetPdhString(214, state->pdhStrings.diskReadsPerSec) &&\n\t\tsetPdhString(216, state->pdhStrings.diskWritesPerSec) &&\n\t\tsetPdhString(222, state->pdhStrings.diskWriteBytesPerSec) &&\n\t\tsetPdhString(506, state->pdhStrings.bytesSentPerSec) &&\n\t\tsetPdhString(264, state->pdhStrings.bytesRecvPerSec) &&\n\t\tsetPdhString(654, state->pdhStrings.segmentsOutPerSec) &&\n\t\tsetPdhString(656, state->pdhStrings.segmentsRetransPerSec)) {\n\n\t\tif (!dataFolder.empty()) {\n\t\t\tdataFolder = abspath(dataFolder);\n\t\t\tchar buf[512], buf2[512];\n\t\t\tDWORD sz = 512, sz2 = 512;\n\n\t\t\tif (!GetVolumePathName(dataFolder.c_str(), buf, 512)) {\n\t\t\t\tTraceEvent(SevWarn, \"GetVolumePathName\").GetLastError().detail(\"Path\", dataFolder);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!GetVolumeNameForVolumeMountPoint(buf, buf2, 512)) {\n\t\t\t\tTraceEvent(SevWarn, \"GetVolumeNameForVolumeMountPoint\").GetLastError().detail(\"Path\", dataFolder);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (!strlen(buf2)) {\n\t\t\t\tTraceEvent(SevWarn, \"WinDiskStatsGetPathError\").detail(\"Path\", dataFolder);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (buf2[strlen(buf2) - 1] == '\\\\')\n\t\t\t\tbuf2[strlen(buf2) - 1] = 0;\n\n\t\t\tHANDLE hDevice = CreateFile(buf2, 0, 0, NULL, OPEN_EXISTING, 0, NULL);\n\t\t\tif (hDevice == INVALID_HANDLE_VALUE) {\n\t\t\t\tTraceEvent(SevWarn, \"CreateFile\").GetLastError().detail(\"Path\", dataFolder);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tSTORAGE_DEVICE_NUMBER storage_device;\n\t\t\tif (!DeviceIoControl(hDevice, IOCTL_STORAGE_GET_DEVICE_NUMBER, NULL, 0,\n\t\t\t\t\t\t\t\t &storage_device, sizeof(storage_device), &sz, NULL)) {\n\t\t\t\tTraceEvent(SevWarn, \"DeviceIoControl\").GetLastError().detail(\"Path\", dataFolder);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Find the drive letter involved!\n\t\t\tsz = 512;\n\t\t\tif (handlePdhStatus(PdhEnumObjectItems(NULL, NULL, state->pdhStrings.physicalDisk.c_str(),\n\t\t\t\t\t\t\t\tbuf2, &sz2, buf, &sz, PERF_DETAIL_NOVICE, 0), \"PdhEnumObjectItems\")) {\n\t\t\t\tchar *ptr = buf;\n\t\t\t\twhile (*ptr) {\n\t\t\t\t\tif (isdigit(*ptr) && atoi(ptr) == storage_device.DeviceNumber) {\n\t\t\t\t\t\tstate->pdhStrings.diskDevice = ptr;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tptr += strlen(ptr) + 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (state->pdhStrings.diskDevice.empty()) {\n\t\t\t\tTraceEvent(SevWarn, \"WinDiskStatsGetPathError\").detail(\"Path\", dataFolder);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t}\n}\n#endif\n\nSystemStatistics getSystemStatistics(std::string dataFolder, const IPAddress* ip, SystemStatisticsState** statState, bool logDetails) {\n\tif( (*statState) == NULL )\n\t\t(*statState) = new SystemStatisticsState();\n\tSystemStatistics returnStats;\n\n\tdouble nowTime = timer();\n\tdouble nowClockProcess = getProcessorTimeProcess();\n\tdouble nowClockThread = getProcessorTimeThread();\n\treturnStats.elapsed = nowTime - (*statState)->lastTime;\n\n\treturnStats.initialized = (*statState)->lastTime != 0;\n\tif( returnStats.initialized ) {\n\t\treturnStats.processCPUSeconds = (nowClockProcess - (*statState)->lastClockProcess);\n\t\treturnStats.mainThreadCPUSeconds = (nowClockThread - (*statState)->lastClockThread);\n\t}\n\n\treturnStats.processMemory = getMemoryUsage();\n\treturnStats.processResidentMemory = getResidentMemoryUsage();\n\n\tMachineRAMInfo memInfo;\n\tgetMachineRAMInfo(memInfo);\n\treturnStats.machineTotalRAM = memInfo.total;\n\treturnStats.machineCommittedRAM = memInfo.committed;\n\treturnStats.machineAvailableRAM = memInfo.available;\n\n\tif(dataFolder != \"\") {\n\t\tint64_t diskTotal, diskFree;\n\t\tgetDiskBytes(dataFolder, diskFree, diskTotal);\n\t\treturnStats.processDiskTotalBytes = diskTotal;\n\t\treturnStats.processDiskFreeBytes = diskFree;\n\t}\n\n#if defined(_WIN32)\n\tif((*statState)->Query == NULL) {\n\t\tinitPdhStrings(*statState, dataFolder);\n\n\t\tTraceEvent(\"SetupQuery\");\n\t\thandlePdhStatus( PdhOpenQuery(NULL, NULL, &(*statState)->Query), \"PdhOpenQuery\" );\n\n\t\tif( !(*statState)->pdhStrings.diskDevice.empty() ) {\n\t\t\thandlePdhStatus(PdhAddCounter((*statState)->Query, (\"\\\\\" + (*statState)->pdhStrings.physicalDisk + \"(\" + (*statState)->pdhStrings.diskDevice + \")\\\\\" + (*statState)->pdhStrings.pctIdle).c_str(), 0, &(*statState)->DiskTimeCounter), \"PdhAddCounter\");\n\t\t\thandlePdhStatus(PdhAddCounter((*statState)->Query, (\"\\\\\" + (*statState)->pdhStrings.physicalDisk + \"(\" + (*statState)->pdhStrings.diskDevice + \")\\\\\" + (*statState)->pdhStrings.diskQueueLength).c_str(), 0, &(*statState)->QueueLengthCounter), \"PdhAddCounter\");\n\t\t\thandlePdhStatus(PdhAddCounter((*statState)->Query, (\"\\\\\" + (*statState)->pdhStrings.physicalDisk + \"(\" + (*statState)->pdhStrings.diskDevice + \")\\\\\" + (*statState)->pdhStrings.diskReadsPerSec).c_str(), 0, &(*statState)->ReadsCounter), \"PdhAddCounter\");\n\t\t\thandlePdhStatus(PdhAddCounter((*statState)->Query, (\"\\\\\" + (*statState)->pdhStrings.physicalDisk + \"(\" + (*statState)->pdhStrings.diskDevice + \")\\\\\" + (*statState)->pdhStrings.diskWritesPerSec).c_str(), 0, &(*statState)->WritesCounter), \"PdhAddCounter\");\n\t\t\thandlePdhStatus(PdhAddCounter((*statState)->Query, (\"\\\\\" + (*statState)->pdhStrings.physicalDisk + \"(\" + (*statState)->pdhStrings.diskDevice + \")\\\\\" + (*statState)->pdhStrings.diskWriteBytesPerSec).c_str(), 0, &(*statState)->WriteBytesCounter), \"PdhAddCounter\");\n\t\t}\n\t\t(*statState)->SendCounters = addCounters((*statState)->Query, (\"\\\\\" + (*statState)->pdhStrings.networkDevice + \"(*)\\\\\" + (*statState)->pdhStrings.bytesSentPerSec).c_str());\n\t\t(*statState)->ReceiveCounters = addCounters((*statState)->Query, (\"\\\\\" + (*statState)->pdhStrings.networkDevice + \"(*)\\\\\" + (*statState)->pdhStrings.bytesRecvPerSec).c_str());\n\t\thandlePdhStatus(PdhAddCounter((*statState)->Query, (\"\\\\\" + (*statState)->pdhStrings.tcpv4 + \"\\\\\" + (*statState)->pdhStrings.segmentsOutPerSec).c_str(), 0, &(*statState)->SegmentsOutCounter), \"PdhAddCounter\");\n\t\thandlePdhStatus(PdhAddCounter((*statState)->Query, (\"\\\\\" + (*statState)->pdhStrings.tcpv4 + \"\\\\\" + (*statState)->pdhStrings.segmentsRetransPerSec).c_str(), 0, &(*statState)->SegmentsRetransCounter), \"PdhAddCounter\");\n\t\thandlePdhStatus(PdhAddCounter((*statState)->Query, (\"\\\\\" + (*statState)->pdhStrings.processor + \"(*)\\\\\" + (*statState)->pdhStrings.pctIdle).c_str(), 0, &(*statState)->ProcessorIdleCounter), \"PdhAddCounter\");\n\t}\n\thandlePdhStatus( PdhCollectQueryData((*statState)->Query), \"PdhCollectQueryData\" );\n\n\tPDH_FMT_COUNTERVALUE DisplayValue;\n\tif (returnStats.initialized) {\n\t\tif (!(*statState)->pdhStrings.diskDevice.empty()) {\n\t\t\tif( handlePdhStatus( PdhGetFormattedCounterValue((*statState)->DiskTimeCounter, PDH_FMT_DOUBLE, 0, &DisplayValue), \"DiskTimeCounter\" ) )\n\t\t\t\treturnStats.processDiskIdleSeconds = DisplayValue.doubleValue * returnStats.elapsed / 100.0;\n\t\t\tif( handlePdhStatus( PdhGetFormattedCounterValue((*statState)->QueueLengthCounter, PDH_FMT_DOUBLE, 0, &DisplayValue), \"QueueLengthCounter\" ) )\n\t\t\t\treturnStats.processDiskQueueDepth = DisplayValue.doubleValue;\n\t\t\tif( handlePdhStatus( PdhGetFormattedCounterValue((*statState)->ReadsCounter, PDH_FMT_DOUBLE, 0, &DisplayValue), \"ReadsCounter\" ) )\n\t\t\t\treturnStats.processDiskRead = DisplayValue.doubleValue * returnStats.elapsed;\n\t\t\tif( handlePdhStatus( PdhGetFormattedCounterValue((*statState)->WritesCounter, PDH_FMT_DOUBLE, 0, &DisplayValue), \"WritesCounter\" ) )\n\t\t\t\treturnStats.processDiskWrite = DisplayValue.doubleValue * returnStats.elapsed;\n\t\t\tif (handlePdhStatus(PdhGetFormattedCounterValue((*statState)->WriteBytesCounter, PDH_FMT_DOUBLE, 0, &DisplayValue), \"WriteBytesCounter\"))\n\t\t\t\treturnStats.processDiskWriteSectors = DisplayValue.doubleValue * returnStats.elapsed / 512.0;\n\t\t}\n\t\treturnStats.machineMegabitsSent = 0.0;\n\t\tfor( int i = 0; i < (*statState)->SendCounters.size(); i++ )\n\t\t\tif( handlePdhStatus( PdhGetFormattedCounterValue((*statState)->SendCounters[i], PDH_FMT_DOUBLE, 0, &DisplayValue), \"SendCounter\" ) )\n\t\t\t\treturnStats.machineMegabitsSent += DisplayValue.doubleValue * 7.62939453e-6;\n\t\treturnStats.machineMegabitsSent *= returnStats.elapsed;\n\n\t\treturnStats.machineMegabitsReceived = 0.0;\n\t\tfor( int i = 0; i < (*statState)->ReceiveCounters.size(); i++ )\n\t\t\tif( handlePdhStatus( PdhGetFormattedCounterValue((*statState)->ReceiveCounters[i], PDH_FMT_DOUBLE, 0, &DisplayValue), \"ReceiveCounter\" ) )\n\t\t\t\treturnStats.machineMegabitsReceived += DisplayValue.doubleValue * 7.62939453e-6;\n\t\treturnStats.machineMegabitsReceived *= returnStats.elapsed;\n\n\t\tif (handlePdhStatus(PdhGetFormattedCounterValue((*statState)->SegmentsOutCounter, PDH_FMT_DOUBLE, 0, &DisplayValue), \"SegmentsOutCounter\"))\n\t\t\treturnStats.machineOutSegs = DisplayValue.doubleValue * returnStats.elapsed;\n\t\tif (handlePdhStatus(PdhGetFormattedCounterValue((*statState)->SegmentsRetransCounter, PDH_FMT_DOUBLE, 0, &DisplayValue), \"SegmentsRetransCounter\"))\n\t\t\treturnStats.machineRetransSegs = DisplayValue.doubleValue * returnStats.elapsed;\n\n\t\tif( handlePdhStatus( PdhGetFormattedCounterValue((*statState)->ProcessorIdleCounter, PDH_FMT_DOUBLE, 0, &DisplayValue), \"ProcessorIdleCounter\" ) )\n\t\t\treturnStats.machineCPUSeconds = (100 - DisplayValue.doubleValue) * returnStats.elapsed / 100.0;\n\t}\n#elif defined(__unixish__)\n\tuint64_t machineNowSent = (*statState)->machineLastSent;\n\tuint64_t machineNowReceived = (*statState)->machineLastReceived;\n\tuint64_t machineOutSegs = (*statState)->machineLastOutSegs;\n\tuint64_t machineRetransSegs = (*statState)->machineLastRetransSegs;\n\n\tgetNetworkTraffic(*ip, machineNowSent, machineNowReceived, machineOutSegs, machineRetransSegs);\n\tif( returnStats.initialized ) {\n\t\treturnStats.machineMegabitsSent = ((machineNowSent - (*statState)->machineLastSent) * 8e-6);\n\t\treturnStats.machineMegabitsReceived = ((machineNowReceived - (*statState)->machineLastReceived) * 8e-6);\n\t\treturnStats.machineOutSegs = machineOutSegs - (*statState)->machineLastOutSegs;\n\t\treturnStats.machineRetransSegs = machineRetransSegs - (*statState)->machineLastRetransSegs;\n\t}\n\t(*statState)->machineLastSent = machineNowSent;\n\t(*statState)->machineLastReceived = machineNowReceived;\n\t(*statState)->machineLastOutSegs = machineOutSegs;\n\t(*statState)->machineLastRetransSegs = machineRetransSegs;\n\n\tuint64_t currentIOs;\n\tuint64_t nowBusyTicks = (*statState)->lastBusyTicks;\n\tuint64_t nowReads = (*statState)->lastReads;\n\tuint64_t nowWrites = (*statState)->lastWrites;\n\tuint64_t nowWriteSectors = (*statState)->lastWriteSectors;\n\tuint64_t nowReadSectors = (*statState)->lastReadSectors;\n\n\tif(dataFolder != \"\") {\n\t\tgetDiskStatistics(dataFolder, currentIOs, nowBusyTicks, nowReads, nowWrites, nowWriteSectors, nowReadSectors);\n\t\treturnStats.processDiskQueueDepth = currentIOs;\n\t\treturnStats.processDiskReadCount = nowReads;\n\t\treturnStats.processDiskWriteCount = nowWrites;\n\t\tif( returnStats.initialized ) {\n\t\t\treturnStats.processDiskIdleSeconds = std::max<double>(0, returnStats.elapsed - std::min<double>(returnStats.elapsed, (nowBusyTicks - (*statState)->lastBusyTicks) / 1000.0));\n\t\t\treturnStats.processDiskRead = (nowReads - (*statState)->lastReads);\n\t\t\treturnStats.processDiskWrite = (nowWrites - (*statState)->lastWrites);\n\t\t\treturnStats.processDiskWriteSectors = (nowWriteSectors - (*statState)->lastWriteSectors);\n\t\t\treturnStats.processDiskReadSectors = (nowReadSectors - (*statState)->lastReadSectors);\n\t\t}\n\t\t(*statState)->lastBusyTicks = nowBusyTicks;\n\t\t(*statState)->lastReads = nowReads;\n\t\t(*statState)->lastWrites = nowWrites;\n\t\t(*statState)->lastWriteSectors = nowWriteSectors;\n\t\t(*statState)->lastReadSectors = nowReadSectors;\n\t}\n\n\tuint64_t clockIdleTime = (*statState)->lastClockIdleTime;\n\tuint64_t clockTotalTime = (*statState)->lastClockTotalTime;\n\n\tgetMachineLoad(clockIdleTime, clockTotalTime, logDetails);\n\treturnStats.machineCPUSeconds = clockTotalTime - (*statState)->lastClockTotalTime != 0 ? ( 1 - ((clockIdleTime - (*statState)->lastClockIdleTime) / ((double)(clockTotalTime - (*statState)->lastClockTotalTime)))) * returnStats.elapsed : 0;\n\t(*statState)->lastClockIdleTime = clockIdleTime;\n\t(*statState)->lastClockTotalTime = clockTotalTime;\n#endif\n\t(*statState)->lastTime = nowTime;\n\t(*statState)->lastClockProcess = nowClockProcess;\n\t(*statState)->lastClockThread = nowClockThread;\n\treturn returnStats;\n}\n\n#ifdef _WIN32\nstruct OffsetTimer {\n\tdouble secondsPerCount, offset;\n\n\tstatic const int64_t FILETIME_C_EPOCH = 11644473600LL * 10000000LL;\t// Difference between FILETIME epoch (1601) and Unix epoch (1970) in 100ns FILETIME ticks\n\n\tOffsetTimer() {\n\t\tlong long countsPerSecond;\n\t\tif (!QueryPerformanceFrequency( (LARGE_INTEGER*)&countsPerSecond))\n\t\t\tthrow performance_counter_error();\n\t\tsecondsPerCount = 1.0 / countsPerSecond;\n\n\t\tFILETIME fileTime;\n\n\t\toffset = 0;\n\t\tdouble timer = now();\n\t\tGetSystemTimeAsFileTime(&fileTime);\n\t\tstatic_assert( sizeof(fileTime) == sizeof(uint64_t), \"FILETIME size wrong\" );\n\t\toffset = (*(uint64_t*)&fileTime - FILETIME_C_EPOCH) * 100e-9 - timer;\n\t}\n\n\tdouble now() {\n\t\tlong long count;\n\t\tif (!QueryPerformanceCounter( (LARGE_INTEGER*)&count ))\n\t\t\tthrow performance_counter_error();\n\t\treturn offset + count * secondsPerCount;\n\t}\n};\n#elif defined(__linux__)\n#define DOUBLETIME(ts) (double(ts.tv_sec) + (ts.tv_nsec * 1e-9))\n#ifndef CLOCK_MONOTONIC_RAW\n#define CLOCK_MONOTONIC_RAW 4 // Confirmed safe to do with glibc >= 2.11 and kernel >= 2.6.28. No promises with older glibc. Older kernel definitely breaks it.\n#endif\nstruct OffsetTimer {\n\tdouble offset;\n\n\tOffsetTimer() {\n\t\tstruct timespec ts;\n\t\tclock_gettime(CLOCK_REALTIME, &ts);\n\t\toffset = DOUBLETIME(ts);\n\t\tclock_gettime(CLOCK_MONOTONIC, &ts);\n\t\toffset -= DOUBLETIME(ts);\n\t}\n\n\tdouble now() {\n\t\tstruct timespec ts;\n\t\tclock_gettime(CLOCK_MONOTONIC, &ts);\n\t\treturn (offset + DOUBLETIME(ts));\n\t}\n};\n\n#elif defined(__APPLE__)\n\n#include <mach/mach.h>\n#include <mach/mach_time.h>\n\nstruct OffsetTimer {\n\tmach_timebase_info_data_t timebase_info;\n\tuint64_t offset;\n\tdouble offset_seconds;\n\n\tOffsetTimer() {\n\t\tmach_timebase_info(&timebase_info);\n\t\toffset = mach_absolute_time();\n\n\t\tstruct timeval tv;\n\t\tgettimeofday(&tv, NULL);\n\n\t\toffset_seconds = tv.tv_sec + 1e-6 * tv.tv_usec;\n\t}\n\n\tdouble now() {\n\t\tuint64_t elapsed = mach_absolute_time() - offset;\n\t\treturn offset_seconds + double((elapsed * timebase_info.numer) / timebase_info.denom) * 1e-9;\n\t}\n};\n\n#else\n#error Port me!\n#endif\n\ndouble timer_monotonic() {\n\tstatic OffsetTimer theTimer;\n\treturn theTimer.now();\n}\n\ndouble timer() {\n#ifdef _WIN32\n\tstatic const int64_t FILETIME_C_EPOCH = 11644473600LL * 10000000LL;\t// Difference between FILETIME epoch (1601) and Unix epoch (1970) in 100ns FILETIME ticks\n\tFILETIME fileTime;\n\tGetSystemTimeAsFileTime(&fileTime);\n\tstatic_assert( sizeof(fileTime) == sizeof(uint64_t), \"FILETIME size wrong\" );\n\treturn (*(uint64_t*)&fileTime - FILETIME_C_EPOCH) * 100e-9;\n#elif defined(__linux__)\n\tstruct timespec ts;\n\tclock_gettime(CLOCK_REALTIME, &ts);\n\treturn double(ts.tv_sec) + (ts.tv_nsec * 1e-9);\n#elif defined(__APPLE__)\n\tstruct timeval tv;\n\tgettimeofday(&tv, NULL);\n\treturn double(tv.tv_sec) + (tv.tv_usec * 1e-6);\n#else\n#error Port me!\n#endif\n};\n\nuint64_t timer_int() {\n#ifdef _WIN32\n\tstatic const int64_t FILETIME_C_EPOCH = 11644473600LL * 10000000LL;\t// Difference between FILETIME epoch (1601) and Unix epoch (1970) in 100ns FILETIME ticks\n\tFILETIME fileTime;\n\tGetSystemTimeAsFileTime(&fileTime);\n\tstatic_assert( sizeof(fileTime) == sizeof(uint64_t), \"FILETIME size wrong\" );\n\treturn (*(uint64_t*)&fileTime - FILETIME_C_EPOCH);\n#elif defined(__linux__)\n\tstruct timespec ts;\n\tclock_gettime(CLOCK_REALTIME, &ts);\n\treturn uint64_t(ts.tv_sec) * 1e9 + ts.tv_nsec;\n#elif defined(__APPLE__)\n\tstruct timeval tv;\n\tgettimeofday(&tv, NULL);\n\treturn uint64_t(tv.tv_sec) * 1e9 + (tv.tv_usec * 1e3);\n#else\n#error Port me!\n#endif\n};\n\nvoid getLocalTime(const time_t *timep, struct tm *result) {\n#ifdef _WIN32\n\tif(localtime_s(result, timep) != 0) {\n\t\tTraceEvent(SevError, \"GetLocalTimeError\").GetLastError();\n\t\tthrow platform_error();\n\t}\n#elif defined(__unixish__)\n\tif(localtime_r(timep, result) == NULL) {\n\t\tTraceEvent(SevError, \"GetLocalTimeError\").GetLastError();\n\t\tthrow platform_error();\n\t}\n#else\n#error Port me!\n#endif\n}\n\nvoid setMemoryQuota( size_t limit ) {\n#if defined(USE_SANITIZER)\n\t// ASAN doesn't work with memory quotas: https://github.com/google/sanitizers/wiki/AddressSanitizer#ulimit--v\n\treturn;\n#endif\n\tINJECT_FAULT( platform_error, \"setMemoryQuota\" );\n#if defined(_WIN32)\n\tHANDLE job = CreateJobObject( NULL, NULL );\n\tif (!job) {\n\t\tTraceEvent(SevError, \"WinCreateJobError\").GetLastError();\n\t\tthrow platform_error();\n\t}\n\tJOBOBJECT_EXTENDED_LIMIT_INFORMATION limits;\n\tlimits.BasicLimitInformation.LimitFlags = JOB_OBJECT_LIMIT_JOB_MEMORY;\n\tlimits.JobMemoryLimit = limit;\n\tif (!SetInformationJobObject( job, JobObjectExtendedLimitInformation, &limits, sizeof(limits) )) {\n\t\tTraceEvent(SevError, \"FailedToSetInfoOnJobObject\").detail(\"Limit\", limit).GetLastError();\n\t\tthrow platform_error();\n\t}\n\tif (!AssignProcessToJobObject( job, GetCurrentProcess() ))\n\t\tTraceEvent(SevWarn, \"FailedToSetMemoryLimit\").GetLastError();\n#elif defined(__linux__)\n\tstruct rlimit rlim;\n\tif (getrlimit(RLIMIT_AS, &rlim)) {\n\t\tTraceEvent(SevError, \"GetMemoryLimit\").GetLastError();\n\t\tthrow platform_error();\n\t} else if (limit > rlim.rlim_max) {\n\t\tTraceEvent(SevError, \"MemoryLimitTooHigh\").detail(\"Limit\", limit).detail(\"ResidentMaxLimit\", rlim.rlim_max);\n\t\tthrow platform_error();\n\t}\n\trlim.rlim_cur = limit;\n\tif (setrlimit(RLIMIT_AS, &rlim)) {\n\t\tTraceEvent(SevError, \"SetMemoryLimit\").detail(\"Limit\", limit).GetLastError();\n\t\tthrow platform_error();\n\t}\n#endif\n}\n\n#ifdef _WIN32\nstatic int ModifyPrivilege( const char* szPrivilege, bool fEnable )\n{\n\tHRESULT hr = S_OK;\n\tTOKEN_PRIVILEGES NewState;\n\tLUID luid;\n\tHANDLE hToken = NULL;\n\n\t// Open the process token for this process.\n\tif (!OpenProcessToken( GetCurrentProcess(),\n\t\t\t\t\t\t   TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY,\n\t\t\t\t\t\t   &hToken ))\n\t{\n\t\tTraceEvent( SevWarn, \"OpenProcessTokenError\" ).error(large_alloc_failed()).GetLastError();\n\t\treturn ERROR_FUNCTION_FAILED;\n\t}\n\n\t// Get the local unique ID for the privilege.\n\tif ( !LookupPrivilegeValue( NULL,\n\t\t\t\t\t\t\t\tszPrivilege,\n\t\t\t\t\t\t\t\t&luid ))\n\t{\n\t\tCloseHandle( hToken );\n\t\tTraceEvent( SevWarn, \"LookupPrivilegeValue\" ).error(large_alloc_failed()).GetLastError();\n\t\treturn ERROR_FUNCTION_FAILED;\n\t}\n\n\t//cout << luid.HighPart << \" \" << luid.LowPart << endl;\n\n\t// Assign values to the TOKEN_PRIVILEGE structure.\n\tNewState.PrivilegeCount = 1;\n\tNewState.Privileges[0].Luid = luid;\n\tNewState.Privileges[0].Attributes =\n\t\t(fEnable ? SE_PRIVILEGE_ENABLED : 0);\n\n\t// Adjust the token privilege.\n\tif (!AdjustTokenPrivileges(hToken,\n\t\t\t\t\t\t\t   FALSE,\n\t\t\t\t\t\t\t   &NewState,\n\t\t\t\t\t\t\t   0,\n\t\t\t\t\t\t\t   NULL,\n\t\t\t\t\t\t\t   NULL))\n\t{\n\t\tTraceEvent( SevWarn, \"AdjustTokenPrivileges\" ).error(large_alloc_failed()).GetLastError();\n\t\thr = ERROR_FUNCTION_FAILED;\n\t}\n\n\t// Close the handle.\n\tCloseHandle(hToken);\n\n\treturn hr;\n}\n#endif\n\nstatic bool largePagesPrivilegeEnabled = false;\n\nstatic void enableLargePages() {\n\tif (largePagesPrivilegeEnabled)\n\t\treturn;\n#ifdef _WIN32\n\tModifyPrivilege(SE_LOCK_MEMORY_NAME, true);\n\tlargePagesPrivilegeEnabled = true;\n#else\n\t// SOMEDAY: can/should we teach the client how to enable large pages\n\t// on Linux? Or just rely on the system to have been configured as\n\t// desired?\n#endif\n}\n\nstatic void *allocateInternal(size_t length, bool largePages) {\n\n#ifdef _WIN32\n\tDWORD allocType = MEM_COMMIT|MEM_RESERVE;\n\n\tif (largePages)\n\t\tallocType |= MEM_LARGE_PAGES;\n\n\treturn VirtualAlloc(NULL, length, allocType, PAGE_READWRITE);\n#elif defined(__linux__)\n\tint flags = MAP_PRIVATE|MAP_ANONYMOUS;\n\n\tif (largePages)\n\t\tflags |= MAP_HUGETLB;\n\n\treturn mmap(NULL, length, PROT_READ|PROT_WRITE, flags, -1, 0);\n#elif defined(__APPLE__)\n\tint flags = MAP_PRIVATE|MAP_ANON;\n\n\treturn mmap(NULL, length, PROT_READ|PROT_WRITE, flags, -1, 0);\n#else\n#error Port me!\n#endif\n}\n\nstatic bool largeBlockFail = false;\nvoid *allocate(size_t length, bool allowLargePages) {\n\tif (allowLargePages)\n\t\tenableLargePages();\n\n\tvoid *block = ALLOC_FAIL;\n\n\tif (allowLargePages && !largeBlockFail) {\n\t\tblock = allocateInternal(length, true);\n\t\tif (block == ALLOC_FAIL) largeBlockFail = true;\n\t}\n\n\tif (block == ALLOC_FAIL)\n\t\tblock = allocateInternal(length, false);\n\n\t// FIXME: SevWarnAlways trace if \"close\" to out of memory\n\n\tif (block == ALLOC_FAIL)\n\t\tplatform::outOfMemory();\n\n\treturn block;\n}\n\n#if 0\nvoid* numaAllocate(size_t size) {\n\tvoid* thePtr = (void*)0xA00000000LL;\n\tenableLargePages();\n\n\tsize_t vaPageSize = 2<<20;//64<<10;\n\tint nVAPages = size / vaPageSize;\n\n\tint nodes;\n\tif (!GetNumaHighestNodeNumber((PULONG)&nodes)) {\n\t\tTraceEvent(SevError, \"GetNumaHighestNodeNumber\").getLastError();\n\t\tthrow platform_error();\n\t}\n\t++nodes;\n\n\tfor(int i=0; i<nodes; i++) {\n\t\tchar* p = (char*)thePtr + i*nVAPages/nodes*vaPageSize;\n\t\tchar* e = (char*)thePtr + (i+1)*nVAPages/nodes*vaPageSize;\n\t\t//printf(\"  %p + %lld\\n\", p, e-p);\n\t\t// SOMEDAY: removed NUMA extensions for compatibity with Windows Server 2003 -- make execution dynamic\n\t\tif (!VirtualAlloc/*ExNuma*/(/*GetCurrentProcess(),*/ p, e-p, MEM_COMMIT|MEM_RESERVE|MEM_LARGE_PAGES, PAGE_READWRITE/*, i*/)) {\n\t\t\tError e = platform_error();\n\t\t\tTraceEvent(e, \"VirtualAlloc\").GetLastError();\n\t\t\tthrow e;\n\t\t}\n\t}\n\treturn thePtr;\n}\n#endif\n\nvoid setAffinity(int proc) {\n#if defined(_WIN32)\n\t/*if (SetProcessAffinityMask(GetCurrentProcess(), 0x5555))//0x5555555555555555UL))\n\t\tprintf(\"Set affinity mask\\n\");\n\telse\n\t\tprintf(\"Failed to set affinity mask: error %d\\n\", GetLastError());*/\n\tSetThreadAffinityMask( GetCurrentThread(), 1ULL<<proc );\n#elif defined(__linux__)\n\tcpu_set_t set;\n\tCPU_ZERO(&set);\n\tCPU_SET(proc, &set);\n\tsched_setaffinity(0, sizeof(cpu_set_t), &set);\n#endif\n}\n\n\nnamespace platform {\n\nint getRandomSeed() {\n\tINJECT_FAULT( platform_error, \"getRandomSeed\" );\n\tint randomSeed;\n\tint retryCount = 0;\n\n#ifdef _WIN32\n\tdo {\n\t\tretryCount++;\n\t\tif( rand_s( (unsigned int *)&randomSeed ) != 0 ) {\n\t\t\tTraceEvent(SevError, \"WindowsRandomSeedError\");\n\t\t\tthrow platform_error();\n\t\t}\n\t} while (randomSeed == 0 && retryCount < FLOW_KNOBS->RANDOMSEED_RETRY_LIMIT);\t// randomSeed cannot be 0 since we use mersenne twister in DeterministicRandom. Get a new one if randomSeed is 0.\n#else\n\tint devRandom = open(\"/dev/urandom\", O_RDONLY | O_CLOEXEC);\n\tdo {\n\t\tretryCount++;\n\t\tif (read(devRandom, &randomSeed, sizeof(randomSeed)) != sizeof(randomSeed) ) {\n\t\t\tTraceEvent(SevError, \"OpenURandom\").GetLastError();\n\t\t\tthrow platform_error();\n\t\t}\n\t} while (randomSeed == 0 && retryCount < FLOW_KNOBS->RANDOMSEED_RETRY_LIMIT);\n\tclose(devRandom);\n#endif\n\n\tif (randomSeed == 0) {\n\t\tTraceEvent(SevError, \"RandomSeedZeroError\");\n\t\tthrow platform_error();\n\t}\n\treturn randomSeed;\n}\n} // namespace platform\n\nstd::string joinPath( std::string const& directory, std::string const& filename ) {\n\tauto d = directory;\n\tauto f = filename;\n\twhile (f.size() && (f[0] == '/' || f[0] == CANONICAL_PATH_SEPARATOR))\n\t\tf = f.substr(1);\n\twhile (d.size() && (d.back() == '/' || d.back() == CANONICAL_PATH_SEPARATOR))\n\t\td.resize(d.size() - 1);\n\treturn d + CANONICAL_PATH_SEPARATOR + f;\n}\n\nvoid renamedFile() {\n\tINJECT_FAULT( io_error, \"renameFile\" );\n}\n\nvoid renameFile( std::string const& fromPath, std::string const& toPath ) {\n\tINJECT_FAULT( io_error, \"renameFile\" );\n#ifdef _WIN32\n\tif (MoveFile( fromPath.c_str(), toPath.c_str() )) {\n\t\t//renamedFile();\n\t\treturn;\n\t}\n#elif (defined(__linux__) || defined(__APPLE__))\n\tif (!rename( fromPath.c_str(), toPath.c_str() )) {\n\t\t//FIXME: We cannot inject faults after renaming the file, because we could end up with two asyncFileNonDurable open for the same file\n\t\t//renamedFile();\n\t\treturn;\n\t}\n#else\n\t#error Port me!\n#endif\n\tTraceEvent(SevError, \"RenameFile\").detail(\"FromPath\", fromPath).detail(\"ToPath\", toPath).GetLastError();\n\tthrow io_error();\n}\n\n#if defined(__linux__)\n#define FOPEN_CLOEXEC_MODE \"e\"\n#elif defined(_WIN32)\n#define FOPEN_CLOEXEC_MODE \"N\"\n#else\n#define FOPEN_CLOEXEC_MODE \"\"\n#endif\n\nvoid atomicReplace( std::string const& path, std::string const& content, bool textmode ) {\n\tFILE* f = 0;\n\ttry {\n\t\tINJECT_FAULT( io_error, \"atomicReplace\" );\n\n\t\tstd::string tempfilename = joinPath(parentDirectory(path), deterministicRandom()->randomUniqueID().toString() + \".tmp\");\n\t\tf = textmode ? fopen( tempfilename.c_str(), \"wt\" FOPEN_CLOEXEC_MODE ) : fopen(tempfilename.c_str(), \"wb\");\n\t\tif(!f)\n\t\t\tthrow io_error();\n\t#ifdef _WIN32\n\t\t// In Windows case, ReplaceFile API is used which preserves the ownership,\n\t\t// ACLs and other attributes of the original file\n\t#elif defined(__unixish__)\n\t\t// get the uid/gid/mode bits of old file and set it on new file, else fail\n\t\tstruct stat info;\n\t\tbool exists = true;\n\t\tif (stat(path.c_str(), &info) < 0) {\n\t\t\tif (errno == ENOENT) {\n\t\t\t\texists = false;\n\t\t\t} else {\n\t\t\t\tTraceEvent(\"StatFailed\").detail(\"Path\", path);\n\t\t\t\tthrow io_error();\n\t\t\t}\n\t\t}\n\t\tif (exists && chown(tempfilename.c_str(), info.st_uid, info.st_gid) < 0) {\n\t\t\tTraceEvent(\"ChownFailed\")\n\t\t\t\t.detail(\"TempFilename\", tempfilename)\n\t\t\t\t.detail(\"OriginalFile\", path)\n\t\t\t\t.detail(\"Uid\", info.st_uid)\n\t\t\t\t.detail(\"Gid\", info.st_gid);\n\t\t\tdeleteFile(tempfilename);\n\t\t\tthrow io_error();\n\t\t}\n\t\tif (exists && chmod(tempfilename.c_str(), info.st_mode) < 0) {\n\t\t\tTraceEvent(\"ChmodFailed\")\n\t\t\t\t.detail(\"TempFilename\", tempfilename)\n\t\t\t\t.detail(\"OriginalFile\", path)\n\t\t\t\t.detail(\"Mode\", info.st_mode);\n\t\t\tdeleteFile(tempfilename);\n\t\t\tthrow io_error();\n\t\t}\n\t#else\n\t#error Port me!\n\t#endif\n\n\t\tif( textmode && fprintf( f, \"%s\", content.c_str() ) < 0)\n\t\t\tthrow io_error();\n\n\t\tif (!textmode && fwrite(content.c_str(), sizeof(uint8_t), content.size(), f) != content.size())\n\t\t\tthrow io_error();\n\n\t\tif(fflush(f) != 0)\n\t\t\tthrow io_error();\n\n\t#ifdef _WIN32\n\t\tHANDLE h = (HANDLE)_get_osfhandle(_fileno(f));\n\t\tif(!g_network->isSimulated()) {\n\t\t\tif(!FlushFileBuffers(h))\n\t\t\t\tthrow io_error();\n\t\t}\n\n\t\tif(fclose(f) != 0) {\n\t\t\tf = 0;\n\t\t\tthrow io_error();\n\t\t}\n\t\tf = 0;\n\n\t\tif(!ReplaceFile( path.c_str(), tempfilename.c_str(), NULL, NULL, NULL, NULL ))\n\t\t\tthrow io_error();\n\t#elif defined(__unixish__)\n\t\tif(!g_network->isSimulated()) {\n\t\t\tif(fsync( fileno(f) ) != 0)\n\t\t\t\tthrow io_error();\n\t\t}\n\n\t\tif(fclose(f) != 0) {\n\t\t\tf = 0;\n\t\t\tthrow io_error();\n\t\t}\n\t\tf = 0;\n\n\t\tif(rename( tempfilename.c_str(), path.c_str() ) != 0)\n\t\t\tthrow io_error();\n\t#else\n\t#error Port me!\n\t#endif\n\n\t\tINJECT_FAULT( io_error, \"atomicReplace\" );\n\t}\n\tcatch(Error &e) {\n\t\tTraceEvent(SevWarn, \"AtomicReplace\").error(e).detail(\"Path\", path).GetLastError();\n\t\tif (f) fclose(f);\n\t\tthrow;\n\t}\n}\n\nstatic bool deletedFile() {\n\tINJECT_FAULT( platform_error, \"deleteFile\" );\n\treturn true;\n}\n\nbool deleteFile( std::string const& filename ) {\n\tINJECT_FAULT( platform_error, \"deleteFile\" );\n#ifdef _WIN32\n\tif (DeleteFile(filename.c_str()))\n\t\treturn deletedFile();\n\tif (GetLastError() == ERROR_FILE_NOT_FOUND)\n\t\treturn false;\n#elif defined(__unixish__)\n\tif (!unlink( filename.c_str() ))\n\t\treturn deletedFile();\n\tif (errno == ENOENT)\n\t\treturn false;\n#else\n\t#error Port me!\n#endif\n\tError e = systemErrorCodeToError();\n\tTraceEvent(SevError, \"DeleteFile\").detail(\"Filename\", filename).GetLastError().error(e);\n\tthrow e;\n}\n\nstatic void createdDirectory() { INJECT_FAULT( platform_error, \"createDirectory\" ); }\n\nnamespace platform {\n\nbool createDirectory( std::string const& directory ) {\n\tINJECT_FAULT( platform_error, \"createDirectory\" );\n\n#ifdef _WIN32\n\tif (CreateDirectory( directory.c_str(), NULL )) {\n\t\tcreatedDirectory();\n\t\treturn true;\n\t}\n\tif (GetLastError() == ERROR_ALREADY_EXISTS)\n\t\treturn false;\n\tif (GetLastError() == ERROR_PATH_NOT_FOUND) {\n\t\tsize_t delim = directory.find_last_of(\"/\\\\\");\n\t\tif (delim != std::string::npos) {\n\t\t\tcreateDirectory( directory.substr(0, delim) );\n\t\t\treturn createDirectory( directory );\n\t\t}\n\t}\n\tError e = systemErrorCodeToError();\n\tTraceEvent(SevError, \"CreateDirectory\").detail(\"Directory\", directory).GetLastError().error(e);\n\tthrow e;\n#elif (defined(__linux__) || defined(__APPLE__))\n\tsize_t sep = 0;\n\tdo {\n\t\tsep = directory.find_first_of('/', sep + 1);\n\t\tif ( mkdir( directory.substr(0, sep).c_str(), 0755 ) != 0 ) {\n\t\t\tif (errno == EEXIST)\n\t\t\t\tcontinue;\n\t\t\tauto mkdirErrno = errno;\n\n\t\t\t// check if directory already exists\n\t\t\t// necessary due to old kernel bugs\n\t\t\tstruct stat s;\n\t\t\tconst char* dirname = directory.c_str();\n\t\t\tif (stat(dirname, &s) != -1 && S_ISDIR(s.st_mode)) {\n\t\t\t\tTraceEvent(\"DirectoryAlreadyExists\").detail(\"Directory\", dirname).detail(\"IgnoredError\", mkdirErrno);\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tError e;\n\t\t\tif (mkdirErrno == EACCES) {\n\t\t\t\te = file_not_writable();\n\t\t\t} else {\n\t\t\t\te = systemErrorCodeToError();\n\t\t\t}\n\n\t\t\tTraceEvent(SevError, \"CreateDirectory\")\n\t\t\t    .detail(\"Directory\", directory)\n\t\t\t    .detailf(\"UnixErrorCode\", \"%x\", errno)\n\t\t\t    .detail(\"UnixError\", strerror(mkdirErrno))\n\t\t\t    .error(e);\n\t\t\tthrow e;\n\t\t}\n\t\tcreatedDirectory();\n\t} while (sep != std::string::npos && sep != directory.length() - 1);\n\treturn true;\n#else\n\t#error Port me!\n#endif\n}\n\n} // namespace platform\n\nconst uint8_t separatorChar = CANONICAL_PATH_SEPARATOR;\nStringRef separator(&separatorChar, 1);\nStringRef dotdot = LiteralStringRef(\"..\");\n\nstd::string cleanPath(std::string const &path) {\n\tstd::vector<StringRef> finalParts;\n\tbool absolute = !path.empty() && path[0] == CANONICAL_PATH_SEPARATOR;\n\n\tStringRef p(path);\n\n\twhile(p.size() != 0) {\n\t\tStringRef part = p.eat(separator);\n\t\tif(part.size() == 0 || (part.size() == 1 && part[0] == '.'))\n\t\t\tcontinue;\n\t\tif(part == dotdot) {\n\t\t\tif(!finalParts.empty() && finalParts.back() != dotdot) {\n\t\t\t\tfinalParts.pop_back();\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif(absolute) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t}\n\t\tfinalParts.push_back(part);\n\t}\n\n\tstd::string result;\n\tresult.reserve(PATH_MAX);\n\tif(absolute) {\n\t\tresult.append(1, CANONICAL_PATH_SEPARATOR);\n\t}\n\n\tfor(int i = 0; i < finalParts.size(); ++i) {\n\t\tif(i != 0) {\n\t\t\tresult.append(1, CANONICAL_PATH_SEPARATOR);\n\t\t}\n\t\tresult.append((const char *)finalParts[i].begin(), finalParts[i].size());\n\t}\n\n\treturn result.empty() ? \".\" : result;\n}\n\nstd::string popPath(const std::string &path) {\n\tint i = path.size() - 1;\n\t// Skip over any trailing separators\n\twhile(i >= 0 && path[i] == CANONICAL_PATH_SEPARATOR) {\n\t\t--i;\n\t}\n\t// Skip over non separators\n\twhile(i >= 0 && path[i] != CANONICAL_PATH_SEPARATOR) {\n\t\t--i;\n\t}\n\t// Skip over trailing separators again\n\tbool foundSeparator = false;\n\twhile(i >= 0 && path[i] == CANONICAL_PATH_SEPARATOR) {\n\t\t--i;\n\t\tfoundSeparator = true;\n\t}\n\n\tif(foundSeparator) {\n\t\t++i;\n\t}\n\telse {\n\t\t// If absolute then we popped off the only path component so return \"/\"\n\t\tif(!path.empty() && path.front() == CANONICAL_PATH_SEPARATOR) {\n\t\t\treturn \"/\";\n\t\t}\n\t}\n\treturn path.substr(0, i + 1);\n}\n\nstd::string abspath( std::string const& path, bool resolveLinks, bool mustExist ) {\n\tif(path.empty()) {\n\t\tError e = platform_error();\n\t\tSeverity sev = e.code() == error_code_io_error ? SevError : SevWarnAlways;\n\t\tTraceEvent(sev, \"AbsolutePathError\").detail(\"Path\", path).error(e);\n\t\tthrow e;\n\t}\n\n\t// Returns an absolute path canonicalized to use only CANONICAL_PATH_SEPARATOR\n\tINJECT_FAULT( platform_error, \"abspath\" );\n\n\tif(!resolveLinks) {\n\t\t// TODO:  Not resolving symbolic links does not yet behave well on Windows because of drive letters\n\t\t// and network names, so it's not currently allowed here (but it is allowed in fdbmonitor which is unix-only)\n\t\tASSERT(false);\n\t\t// Treat paths starting with ~ or separator as absolute, meaning they shouldn't be appended to the current working dir\n\t\tbool absolute = !path.empty() && (path[0] == CANONICAL_PATH_SEPARATOR || path[0] == '~');\n\t\tstd::string clean = cleanPath(absolute ? path : joinPath(platform::getWorkingDirectory(), path));\n\t\tif(mustExist && !fileExists(clean)) {\n\t\t\tError e = systemErrorCodeToError();\n\t\t\tSeverity sev = e.code() == error_code_io_error ? SevError : SevWarnAlways;\n\t\t\tTraceEvent(sev, \"AbsolutePathError\").detail(\"Path\", path).GetLastError().error(e);\n\t\t\tthrow e;\n\t\t}\n\t\treturn clean;\n\t}\n\n#ifdef _WIN32\n\tchar nameBuffer[MAX_PATH];\n\tif(!GetFullPathName(path.c_str(), MAX_PATH, nameBuffer, NULL) || (mustExist && !fileExists(nameBuffer))) {\n\t\tError e = systemErrorCodeToError();\n\t\tSeverity sev = e.code() == error_code_io_error ? SevError : SevWarnAlways;\n\t\tTraceEvent(sev, \"AbsolutePathError\").detail(\"Path\", path).GetLastError().error(e);\n\t\tthrow e;\n\t}\n\t// Not totally obvious from the help whether GetFullPathName canonicalizes slashes, so let's do it...\n\tfor(char*x = nameBuffer; *x; x++)\n\t\tif (*x == '/')\n\t\t\t*x = CANONICAL_PATH_SEPARATOR;\n\treturn nameBuffer;\n#elif (defined(__linux__) || defined(__APPLE__))\n\n\tchar result[PATH_MAX];\n\t// Must resolve links, so first try realpath on the whole thing\n\tconst char *r = realpath( path.c_str(), result );\n\tif(r == nullptr) {\n\t\t// If the error was ENOENT and the path doesn't have to exist,\n\t\t// try to resolve symlinks in progressively shorter prefixes of the path\n\t\tif(errno == ENOENT && !mustExist) {\n\t\t\tstd::string prefix = popPath(path);\n\t\t\tstd::string suffix = path.substr(prefix.size());\n\t\t\tif(prefix.empty() && (suffix.empty() || suffix[0] != '~')) {\n\t\t\t\tprefix = \".\";\n\t\t\t}\n\t\t\tif(!prefix.empty()) {\n\t\t\t\treturn cleanPath(joinPath(abspath(prefix, true, false), suffix));\n\t\t\t}\n\t\t}\n\t\tError e = systemErrorCodeToError();\n\t\tSeverity sev = e.code() == error_code_io_error ? SevError : SevWarnAlways;\n\t\tTraceEvent(sev, \"AbsolutePathError\").detail(\"Path\", path).GetLastError().error(e);\n\t\tthrow e;\n\t}\n\treturn std::string(r);\n#else\n\t#error Port me!\n#endif\n}\n\nstd::string parentDirectory( std::string const& path, bool resolveLinks, bool mustExist ) {\n\treturn popPath(abspath(path, resolveLinks, mustExist));\n}\n\nstd::string basename( std::string const& filename ) {\n\tauto abs = abspath(filename);\n\tsize_t sep = abs.find_last_of( CANONICAL_PATH_SEPARATOR );\n\tif (sep == std::string::npos) return filename;\n\treturn abs.substr(sep+1);\n}\n\nstd::string getUserHomeDirectory() {\n#if defined(__unixish__)\n\tconst char* ret = getenv( \"HOME\" );\n\tif ( !ret ) {\n\t\tif ( struct passwd *pw = getpwuid( getuid() ) ) {\n\t\t\tret = pw->pw_dir;\n\t\t}\n\t}\n\treturn ret;\n#elif defined(_WIN32)\n\tTCHAR szPath[MAX_PATH];\n\tif( SHGetFolderPath(NULL, CSIDL_PROFILE, NULL, 0, szPath)  != S_OK ) {\n\t\tTraceEvent(SevError, \"GetUserHomeDirectory\").GetLastError();\n\t\tthrow platform_error();\n\t}\n\tstd::string path(szPath);\n\treturn path;\n#else\n#error Port me!\n#endif\n}\n\n#ifdef _WIN32\n#define FILE_ATTRIBUTE_DATA DWORD\n#elif (defined(__linux__) || defined(__APPLE__))\n#define FILE_ATTRIBUTE_DATA mode_t\n#else\n#error Port me!\n#endif\n\nbool acceptFile( FILE_ATTRIBUTE_DATA fileAttributes, std::string name, std::string extension ) {\n#ifdef _WIN32\n\treturn !(fileAttributes & FILE_ATTRIBUTE_DIRECTORY) && StringRef(name).endsWith(extension);\n#elif (defined(__linux__) || defined(__APPLE__))\n\treturn S_ISREG(fileAttributes) && StringRef(name).endsWith(extension);\n#else\n\t#error Port me!\n#endif\n}\n\nbool acceptDirectory( FILE_ATTRIBUTE_DATA fileAttributes, std::string name, std::string extension ) {\n#ifdef _WIN32\n\treturn (fileAttributes & FILE_ATTRIBUTE_DIRECTORY) != 0;\n#elif (defined(__linux__) || defined(__APPLE__))\n\treturn S_ISDIR(fileAttributes);\n#else\n\t#error Port me!\n#endif\n}\n\nstd::vector<std::string> findFiles( std::string const& directory, std::string const& extension,\n\t\tbool (*accept_file)(FILE_ATTRIBUTE_DATA, std::string, std::string)) {\n\tINJECT_FAULT( platform_error, \"findFiles\" );\n\tstd::vector<std::string> result;\n\n#ifdef _WIN32\n\tWIN32_FIND_DATA fd;\n\tHANDLE h = FindFirstFile( (directory + \"/*\" + extension).c_str(), &fd );\n\tif (h == INVALID_HANDLE_VALUE) {\n\t\tif (GetLastError() != ERROR_FILE_NOT_FOUND && GetLastError() != ERROR_PATH_NOT_FOUND) {\n\t\t\tTraceEvent(SevError, \"FindFirstFile\").detail(\"Directory\", directory).detail(\"Extension\", extension).GetLastError();\n\t\t\tthrow platform_error();\n\t\t}\n\t} else {\n\t\twhile (true) {\n\t\t\tstd::string name = fd.cFileName;\n\t\t\tif ((*accept_file)(fd.dwFileAttributes, name, extension)) {\n\t\t\t\tresult.push_back( name );\n\t\t\t}\n\t\t\tif (!FindNextFile( h, &fd ))\n\t\t\t\tbreak;\n\t\t}\n\t\tif (GetLastError() != ERROR_NO_MORE_FILES) {\n\t\t\tTraceEvent(SevError, \"FindNextFile\").detail(\"Directory\", directory).detail(\"Extension\", extension).GetLastError();\n\t\t\tFindClose(h);\n\t\t\tthrow platform_error();\n\t\t}\n\t\tFindClose(h);\n\t}\n#elif (defined(__linux__) || defined(__APPLE__))\n\tDIR *dip;\n\n\tif ((dip = opendir(directory.c_str())) != NULL) {\n\t\tstruct dirent *dit;\n\t\twhile ((dit = readdir(dip)) != NULL) {\n\t\t\tstd::string name(dit->d_name);\n\t\t\tstruct stat buf;\n\t\t\tif (stat(joinPath(directory, name).c_str(), &buf)) {\n\t\t\t\tbool isError = errno != ENOENT;\n\t\t\t\tTraceEvent(isError ? SevError : SevWarn, \"StatFailed\")\n\t\t\t\t\t.detail(\"Directory\", directory)\n\t\t\t\t\t.detail(\"Extension\", extension)\n\t\t\t\t\t.detail(\"Name\", name)\n\t\t\t\t\t.GetLastError();\n\t\t\t\tif( isError )\n\t\t\t\t\tthrow platform_error();\n\t\t\t\telse\n\t\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif ((*accept_file)(buf.st_mode, name, extension))\n\t\t\t\tresult.push_back( name );\n\t\t}\n\n\t\tclosedir(dip);\n\t}\n#else\n\t#error Port me!\n#endif\n\tstd::sort(result.begin(), result.end());\n\treturn result;\n}\n\n\nnamespace platform {\n\nstd::vector<std::string> listFiles( std::string const& directory, std::string const& extension ) {\n\treturn findFiles( directory, extension, &acceptFile );\n}\n\nstd::vector<std::string> listDirectories( std::string const& directory ) {\n\treturn findFiles( directory, \"\", &acceptDirectory );\n}\n\nvoid findFilesRecursively(std::string path, std::vector<std::string> &out) {\n\t// Add files to output, prefixing path\n\tstd::vector<std::string> files = platform::listFiles(path);\n\tfor(auto const &f : files)\n\t\tout.push_back(joinPath(path, f));\n\n\t// Recurse for directories\n\tstd::vector<std::string> directories = platform::listDirectories(path);\n\tfor(auto const &dir : directories) {\n\t\tif(dir != \".\" && dir != \"..\")\n\t\t\tfindFilesRecursively(joinPath(path, dir), out);\n\t}\n}\n\n} // namespace platform\n\n\nvoid threadSleep( double seconds ) {\n#ifdef _WIN32\n\tSleep( (DWORD)(seconds * 1e3) );\n#elif (defined(__linux__) || defined(__APPLE__))\n\tstruct timespec req, rem;\n\n\treq.tv_sec = seconds;\n\treq.tv_nsec = (seconds - req.tv_sec) * 1e9L;\n\n\twhile (nanosleep(&req, &rem) == -1 && errno == EINTR) {\n\t\treq.tv_sec = rem.tv_sec;\n\t\treq.tv_nsec = rem.tv_nsec;\n\t}\n#else\n\t#error Port me!\n#endif\n}\n\nvoid threadYield() {\n#ifdef _WIN32\n\tSleep(0);\n#elif defined( __unixish__ )\n\tsched_yield();\n#else\n#error Port me!\n#endif\n}\n\nnamespace platform {\n\nvoid makeTemporary( const char* filename ) {\n#ifdef _WIN32\n\tSetFileAttributes(filename, FILE_ATTRIBUTE_TEMPORARY);\n#endif\n}\n\nvoid setCloseOnExec( int fd ) {\n#if defined(__unixish__)\n\tint options = fcntl(fd, F_GETFD);\n\tif (options != -1) {\n\t\toptions = fcntl(fd, F_SETFD, options | FD_CLOEXEC);\n\t}\n\tif (options == -1) {\n\t\tTraceEvent(SevWarnAlways, \"PlatformSetCloseOnExecError\").suppressFor(60).GetLastError();\n\t}\n#endif\n}\n\n} // namespace platform\n\n#ifdef _WIN32\nTHREAD_HANDLE startThread(void (*func) (void *), void *arg) {\n\treturn (void *)_beginthread(func, 0, arg);\n}\n#elif (defined(__linux__) || defined(__APPLE__))\nTHREAD_HANDLE startThread(void *(*func) (void *), void *arg) {\n\tpthread_t t;\n\tpthread_create(&t, NULL, func, arg);\n\treturn t;\n}\n#else\n\t#error Port me!\n#endif\n\nvoid waitThread(THREAD_HANDLE thread) {\n#ifdef _WIN32\n\tWaitForSingleObject(thread, INFINITE);\n#elif (defined(__linux__) || defined(__APPLE__))\n\tpthread_join(thread, NULL);\n#else\n\t#error Port me!\n#endif\n}\n\nvoid deprioritizeThread() {\n#ifdef __linux__\n\tint tid = syscall(SYS_gettid);\n\tsetpriority( PRIO_PROCESS, tid, 10 );\n#elif defined(_WIN32)\n#endif\n}\n\nbool fileExists(std::string const& filename) {\n\tFILE* f = fopen(filename.c_str(), \"rb\" FOPEN_CLOEXEC_MODE );\n\tif (!f) return false;\n\tfclose(f);\n\treturn true;\n}\n\nbool directoryExists(std::string const& path) {\n#ifdef _WIN32\n\tDWORD bits = ::GetFileAttributes(path.c_str());\n\treturn bits != INVALID_FILE_ATTRIBUTES && (bits & FILE_ATTRIBUTE_DIRECTORY);\n#else\n\tDIR *d = opendir(path.c_str());\n\tif(d == nullptr)\n\t\treturn false;\n\tclosedir(d);\n\treturn true;\n#endif\n}\n\nint64_t fileSize(std::string const& filename) {\n#ifdef _WIN32\n\tstruct _stati64 file_status;\n\tif(_stati64(filename.c_str(), &file_status) != 0)\n\t\treturn 0;\n\telse\n\t\treturn file_status.st_size;\n#elif (defined(__linux__) || defined(__APPLE__))\n\tstruct stat file_status;\n\tif(stat(filename.c_str(), &file_status) != 0)\n\t\treturn 0;\n\telse\n\t\treturn file_status.st_size;\n#else\n\t#error Port me!\n#endif\n}\n\nstd::string readFileBytes( std::string const& filename, int maxSize ) {\n\tstd::string s;\n\tFILE* f = fopen(filename.c_str(), \"rb\" FOPEN_CLOEXEC_MODE);\n\tif (!f) throw file_not_readable();\n\ttry {\n\t\tfseek(f, 0, SEEK_END);\n\t\tsize_t size = ftell(f);\n\t\tif (size > maxSize)\n\t\t\tthrow file_too_large();\n\t\ts.resize( size );\n\t\tfseek(f, 0, SEEK_SET);\n\t\tif (!fread( &s[0], size, 1, f ))\n\t\t\tthrow file_not_readable();\n\t} catch (...) {\n\t\tfclose(f);\n\t\tthrow;\n\t}\n\tfclose(f);\n\treturn s;\n}\n\nvoid writeFileBytes(std::string const& filename, const uint8_t* data, size_t count) {\n\tFILE* f = fopen(filename.c_str(), \"wb\" FOPEN_CLOEXEC_MODE);\n\tif (!f)\n\t{\n\t\tTraceEvent(SevError, \"WriteFileBytes\").detail(\"Filename\", filename).GetLastError();\n\t\tthrow file_not_writable();\n\t}\n\n\ttry {\n\t\tsize_t length = fwrite(data, sizeof(uint8_t), count, f);\n\t\tif (length != count)\n\t\t{\n\t\t\tTraceEvent(SevError, \"WriteFileBytes\").detail(\"Filename\", filename).detail(\"WrittenLength\", length).GetLastError();\n\t\t\tthrow file_not_writable();\n\t\t}\n\t}\n\tcatch (...) {\n\t\tfclose(f);\n\t\tthrow;\n\t}\n\tfclose(f);\n}\n\nvoid writeFile(std::string const& filename, std::string const& content) {\n\twriteFileBytes(filename, (const uint8_t*)(content.c_str()), content.size());\n}\n\n\nnamespace platform {\n\nbool getEnvironmentVar(const char* name, std::string& value) {\n#if defined(__unixish__)\n\tchar* val = getenv(name);\n\tif (val) {\n\t\tvalue = std::string(val);\n\t\treturn true;\n\t}\n\treturn false;\n#elif defined(_WIN32)\n\tint len = GetEnvironmentVariable(name, NULL, 0);\n\tif (len == 0) {\n\t\tif (GetLastError() == ERROR_ENVVAR_NOT_FOUND) {\n\t\t\treturn false;\n\t\t}\n\t\tTraceEvent(SevError, \"GetEnvironmentVariable\").detail(\"Name\", name).GetLastError();\n\t\tthrow platform_error();\n\t}\n\tvalue.resize(len);\n\tint rc = GetEnvironmentVariable(name, &value[0], len);\n\tif (rc + 1 != len) {\n\t\tTraceEvent(SevError, \"WrongEnvVarLength\")\n\t\t\t.detail(\"ExpectedLength\", len)\n\t\t\t.detail(\"ReceivedLength\", rc + 1);\n\t\tthrow platform_error();\n\t}\n\tvalue.resize(len-1);\n\treturn true;\n#else\n#error Port me!\n#endif\n}\n\nint setEnvironmentVar(const char *name, const char *value, int overwrite)\n{\n#if defined(_WIN32)\n\tint errcode = 0;\n\tif(!overwrite) {\n\t\tsize_t envsize = 0;\n\t\terrcode = getenv_s(&envsize, NULL, 0, name);\n\t\tif(errcode || envsize) return errcode;\n\t}\n\treturn _putenv_s(name, value);\n#else\n\treturn setenv(name, value, overwrite);\n#endif\n}\n\n#if defined(_WIN32)\n#define getcwd(buf, maxlen) _getcwd(buf, maxlen)\n#endif\nstd::string getWorkingDirectory() {\n\tchar *buf;\n\tif( (buf = getcwd(NULL, 0)) == NULL ) {\n\t\tTraceEvent(SevWarnAlways, \"GetWorkingDirectoryError\").GetLastError();\n\t\tthrow platform_error();\n\t}\n\tstd::string result(buf);\n\tfree(buf);\n\treturn result;\n}\n\n} // namespace platform\n\nextern std::string format( const char *form, ... );\n\nnamespace platform {\nstd::string getDefaultConfigPath() {\n#ifdef _WIN32\n\tTCHAR szPath[MAX_PATH];\n\tif( SHGetFolderPath(NULL, CSIDL_COMMON_APPDATA, NULL, 0, szPath)  != S_OK ) {\n\t\tTraceEvent(SevError, \"WindowsAppDataError\").GetLastError();\n\t\tthrow platform_error();\n\t}\n\tstd::string _filepath(szPath);\n\treturn _filepath + \"\\\\foundationdb\";\n#elif defined(__linux__)\n\treturn \"/etc/foundationdb\";\n#elif defined(__APPLE__)\n\treturn \"/usr/local/etc/foundationdb\";\n#else\n\t#error Port me!\n#endif\n}\n\nstd::string getDefaultClusterFilePath() {\n\treturn joinPath(getDefaultConfigPath(), \"fdb.cluster\");\n}\n} // namespace platform\n\n#ifdef ALLOC_INSTRUMENTATION\n#define TRACEALLOCATOR( size ) TraceEvent(\"MemSample\").detail(\"Count\", FastAllocator<size>::getApproximateMemoryUnused()/size).detail(\"TotalSize\", FastAllocator<size>::getApproximateMemoryUnused()).detail(\"SampleCount\", 1).detail(\"Hash\", \"FastAllocatedUnused\" #size ).detail(\"Bt\", \"na\")\n#ifdef __linux__\n#include <cxxabi.h>\n#endif\nuint8_t *g_extra_memory;\n#endif\n\nnamespace platform {\n\nvoid outOfMemory() {\n#ifdef ALLOC_INSTRUMENTATION\n\tdelete [] g_extra_memory;\n\tstd::vector< std::pair<std::string, const char*> > typeNames;\n\tfor( auto i = allocInstr.begin(); i != allocInstr.end(); ++i ) {\n\t\tstd::string s;\n#ifdef __linux__\n\t\tchar *demangled = abi::__cxa_demangle(i->first, NULL, NULL, NULL);\n\t\tif (demangled) {\n\t\t\ts = demangled;\n\t\t\tif (StringRef(s).startsWith(LiteralStringRef(\"(anonymous namespace)::\")))\n\t\t\t\ts = s.substr(LiteralStringRef(\"(anonymous namespace)::\").size());\n\t\t\tfree(demangled);\n\t\t} else\n\t\t\ts = i->first;\n#else\n\t\ts = i->first;\n\t\tif (StringRef(s).startsWith(LiteralStringRef(\"class `anonymous namespace'::\")))\n\t\t\ts = s.substr(LiteralStringRef(\"class `anonymous namespace'::\").size());\n\t\telse if (StringRef(s).startsWith(LiteralStringRef(\"class \")))\n\t\t\ts = s.substr(LiteralStringRef(\"class \").size());\n\t\telse if (StringRef(s).startsWith(LiteralStringRef(\"struct \")))\n\t\t\ts = s.substr(LiteralStringRef(\"struct \").size());\n#endif\n\t\ttypeNames.push_back( std::make_pair(s, i->first) );\n\t}\n\tstd::sort(typeNames.begin(), typeNames.end());\n\tfor(int i=0; i<typeNames.size(); i++) {\n\t\tconst char* n = typeNames[i].second;\n\t\tauto& f = allocInstr[n];\n\t\tif(f.maxAllocated > 10000)\n\t\t\tTraceEvent(\"AllocInstrument\").detail(\"CurrentAlloc\", f.allocCount-f.deallocCount)\n\t\t\t\t.detail(\"Name\", typeNames[i].first.c_str());\n\t}\n\n\tstd::unordered_map<uint32_t, BackTraceAccount> traceCounts;\n\tsize_t memSampleSize;\n\tmemSample_entered = true;\n\t{\n\t\tThreadSpinLockHolder holder( memLock );\n\t\ttraceCounts = backTraceLookup;\n\t\tmemSampleSize = memSample.size();\n\t}\n\tmemSample_entered = false;\n\n\tTraceEvent(\"MemSampleSummary\")\n\t\t.detail(\"InverseByteSampleRatio\", SAMPLE_BYTES)\n\t\t.detail(\"MemorySamples\", memSampleSize)\n\t\t.detail(\"BackTraces\", traceCounts.size());\n\n\tfor( auto i = traceCounts.begin(); i != traceCounts.end(); ++i ) {\n\t\tchar buf[1024];\n\t\tstd::vector<void *> *frames = i->second.backTrace;\n\t\tstd::string backTraceStr;\n#if defined(_WIN32)\n\t\tfor (int j = 1; j < frames->size(); j++) {\n\t\t\t_snprintf(buf, 1024, \"%p \", frames->at(j));\n\t\t\tbackTraceStr += buf;\n\t\t}\n#else\n\t\tbackTraceStr = format_backtrace(&(*frames)[0], frames->size());\n#endif\n\t\tTraceEvent(\"MemSample\")\n\t\t\t.detail(\"Count\", (int64_t)i->second.count)\n\t\t\t.detail(\"TotalSize\", i->second.totalSize)\n\t\t\t.detail(\"SampleCount\", i->second.sampleCount)\n\t\t\t.detail(\"Hash\", format(\"%lld\", i->first))\n\t\t\t.detail(\"Bt\", backTraceStr);\n\t}\n\n\tTraceEvent(\"MemSample\")\n\t\t.detail(\"Count\", traceCounts.size())\n\t\t.detail(\"TotalSize\", traceCounts.size() * ((int)(sizeof(uint32_t) + sizeof(size_t) + sizeof(size_t))))\n\t\t.detail(\"SampleCount\", traceCounts.size())\n\t\t.detail(\"Hash\", \"backTraces\")\n\t\t.detail(\"Bt\", \"na\");\n\n\tTraceEvent(\"MemSample\")\n\t\t.detail(\"Count\", memSampleSize)\n\t\t.detail(\"TotalSize\", memSampleSize * ((int)(sizeof(void*) + sizeof(uint32_t) + sizeof(size_t))))\n\t\t.detail(\"SapmleCount\", memSampleSize)\n\t\t.detail(\"Hash\", \"memSamples\")\n\t\t.detail(\"Bt\", \"na\");\n\tTRACEALLOCATOR(16);\n\tTRACEALLOCATOR(32);\n\tTRACEALLOCATOR(64);\n\tTRACEALLOCATOR(96);\n\tTRACEALLOCATOR(128);\n\tTRACEALLOCATOR(256);\n\tTRACEALLOCATOR(512);\n\tTRACEALLOCATOR(1024);\n\tTRACEALLOCATOR(2048);\n\tTRACEALLOCATOR(4096);\n\tTRACEALLOCATOR(8192);\n\tg_traceBatch.dump();\n#endif\n\n\tcriticalError(FDB_EXIT_NO_MEM, \"OutOfMemory\", \"Out of memory\");\n}\n} // namespace platform\n\nextern \"C\" void criticalError(int exitCode, const char *type, const char *message) {\n\t// Be careful!  This function may be called asynchronously from a thread or in other weird conditions\n\n\tfprintf(stderr, \"ERROR: %s\\n\", message);\n\n\tif (g_network && !g_network->isSimulated())\n\t{\n\t\tTraceEvent ev(SevError, type);\n\t\tev.detail(\"Message\", message);\n\t}\n\n\tflushAndExit(exitCode);\n}\n\nextern void flushTraceFileVoid();\n\nextern \"C\" void flushAndExit(int exitCode) {\n\tflushTraceFileVoid();\n\tfflush(stdout);\n\tcloseTraceFile();\n#ifdef _WIN32\n\t// This function is documented as being asynchronous, but we suspect it might actually be synchronous in the\n\t// case that it is passed a handle to the current process. If not, then there may be cases where we escalate\n\t// to the crashAndDie call below.\n\tTerminateProcess(GetCurrentProcess(), exitCode);\n#else\n\t_exit(exitCode);\n#endif\n\t// should never reach here, but you never know\n\tcrashAndDie();\n}\n\n#ifdef __unixish__\n#include <dlfcn.h>\n\n#ifdef __linux__\n#include <link.h>\n#endif\n\nstruct ImageInfo {\n\tvoid *offset;\n\tstd::string symbolFileName;\n\n\tImageInfo() : offset(NULL), symbolFileName(\"\") {}\n};\n\nImageInfo getImageInfo(const void *symbol) {\n\tDl_info info;\n\tImageInfo imageInfo;\n\n#ifdef __linux__\n\tlink_map *linkMap;\n\tint res = dladdr1(symbol, &info, (void**)&linkMap, RTLD_DL_LINKMAP);\n#else\n\tint res = dladdr(symbol, &info);\n#endif\n\n\tif(res != 0) {\n\t\tstd::string imageFile = basename(info.dli_fname);\n\t\t// If we have a client library that doesn't end in the appropriate extension, we will get the wrong debug suffix. This should only be a cosmetic problem, though.\n#ifdef __linux__\n\t\timageInfo.offset = (void*)linkMap->l_addr;\n\t\tif(imageFile.length() >= 3 && imageFile.rfind(\".so\") == imageFile.length()-3) {\n#else\n\t\timageInfo.offset = info.dli_fbase;\n\t\tif(imageFile.length() >= 6 && imageFile.rfind(\".dylib\") == imageFile.length()-6) {\n#endif\n\t\t\timageInfo.symbolFileName = imageFile + \"-debug\";\n\t\t}\n\t\telse {\n\t\t\timageInfo.symbolFileName = imageFile + \".debug\";\n\t\t}\n\t}\n\telse {\n\t\timageInfo.symbolFileName = \"unknown\";\n\t}\n\n\treturn imageInfo;\n}\n\nImageInfo getCachedImageInfo() {\n\t// The use of \"getCachedImageInfo\" is arbitrary and was a best guess at a good way to get the image of the\n\t//  most likely candidate for the \"real\" flow library or binary\n\tstatic ImageInfo info = getImageInfo((const void *)&getCachedImageInfo);\n\treturn info;\n}\n\n#include <execinfo.h>\n\nnamespace platform {\nvoid* getImageOffset() {\n\treturn getCachedImageInfo().offset;\n}\n\nsize_t raw_backtrace(void** addresses, int maxStackDepth) {\n#if !defined(__APPLE__)\n\t// absl::GetStackTrace doesn't have an implementation for MacOS.\n\treturn absl::GetStackTrace(addresses, maxStackDepth, 0);\n#else\n\treturn backtrace(addresses, maxStackDepth);\n#endif\n}\n\nstd::string format_backtrace(void **addresses, int numAddresses) {\n\tImageInfo const& imageInfo = getCachedImageInfo();\n#ifdef __APPLE__\n\tstd::string s = format(\"atos -o %s -arch x86_64 -l %p\", imageInfo.symbolFileName.c_str(), imageInfo.offset);\n\tfor(int i = 1; i < numAddresses; i++) {\n\t\ts += format(\" %p\", addresses[i]);\n\t}\n#else\n\tstd::string s = format(\"addr2line -e %s -p -C -f -i\", imageInfo.symbolFileName.c_str());\n\tfor(int i = 1; i < numAddresses; i++) {\n\t\ts += format(\" %p\", (char*)addresses[i]-(char*)imageInfo.offset);\n\t}\n#endif\n\treturn s;\n}\n\nstd::string get_backtrace() {\n\tvoid *addresses[50];\n\tsize_t size = raw_backtrace(addresses, 50);\n\treturn format_backtrace(addresses, size);\n}\n} // namespace platform\n#else\n\nnamespace platform {\nstd::string get_backtrace() { return std::string(); }\nstd::string format_backtrace(void **addresses, int numAddresses) { return std::string(); }\nvoid* getImageOffset() { return NULL; }\n} // namespace platform\n#endif\n\nbool isLibraryLoaded(const char* lib_path) {\n#if !defined(__linux__) && !defined(__APPLE__) && !defined(_WIN32)\n#error Port me!\n#endif\n\n\tvoid* dlobj = NULL;\n\n#if defined(__unixish__)\n\tdlobj = dlopen( lib_path, RTLD_NOLOAD | RTLD_LAZY );\n#else\n\tdlobj = GetModuleHandle( lib_path );\n#endif\n\n\treturn dlobj != NULL;\n}\n\nvoid* loadLibrary(const char* lib_path) {\n#if !defined(__linux__) && !defined(__APPLE__) && !defined(_WIN32)\n#error Port me!\n#endif\n\n\tvoid* dlobj = NULL;\n\n#if defined(__unixish__)\n\tdlobj = dlopen( lib_path, RTLD_LAZY | RTLD_LOCAL );\n\tif(dlobj == NULL) {\n\t\tTraceEvent(SevWarn, \"LoadLibraryFailed\").detail(\"Library\", lib_path).detail(\"Error\", dlerror());\n\t}\n#else\n\tdlobj = LoadLibrary( lib_path );\n\tif(dlobj == NULL) {\n\t\tTraceEvent(SevWarn, \"LoadLibraryFailed\").detail(\"Library\", lib_path).GetLastError();\n\t}\n#endif\n\n\treturn dlobj;\n}\n\nvoid* loadFunction(void* lib, const char* func_name) {\n\tvoid* dlfcn = NULL;\n\n#if defined(__unixish__)\n\tdlfcn = dlsym( lib, func_name );\n\tif(dlfcn == NULL) {\n\t\tTraceEvent(SevWarn, \"LoadFunctionFailed\").detail(\"Function\", func_name).detail(\"Error\", dlerror());\n\t}\n#else\n\tdlfcn = GetProcAddress( (HINSTANCE)lib, func_name );\n\tif(dlfcn == NULL) {\n\t\tTraceEvent(SevWarn, \"LoadFunctionFailed\").detail(\"Function\", func_name).GetLastError();\n\t}\n#endif\n\n\treturn dlfcn;\n}\n\nvoid closeLibrary(void* handle) {\n#ifdef __unixish__\n\tdlclose(handle);\n#else\n\tFreeLibrary(reinterpret_cast<HMODULE>(handle));\n#endif\n}\n\nstd::string exePath() {\n#if defined(__linux__)\n\tstd::unique_ptr<char[]> buf(new char[PATH_MAX]);\n\tauto len = readlink(\"/proc/self/exe\", buf.get(), PATH_MAX);\n\tif (len > 0 && len < PATH_MAX) {\n\t\tbuf[len] = '\\0';\n\t\treturn std::string(buf.get());\n\t} else {\n\t\tthrow platform_error();\n\t}\n#elif defined(__APPLE__)\n\tuint32_t bufSize = 1024;\n\tstd::unique_ptr<char[]> buf(new char[bufSize]);\n\twhile (true) {\n\t\tauto res = _NSGetExecutablePath(buf.get(), &bufSize);\n\t\tif (res == -1) {\n\t\t\tbuf.reset(new char[bufSize]);\n\t\t} else {\n\t\t\treturn std::string(buf.get());\n\t\t}\n\t}\n#elif defined(_WIN32)\n\tDWORD bufSize = 1024;\n\tstd::unique_ptr<char[]> buf(new char[bufSize]);\n\twhile (true) {\n\t\tauto s = GetModuleFileName(nullptr, buf.get(), bufSize);\n\t\tif (s >= 0) {\n\t\t\tif (GetLastError() == ERROR_INSUFFICIENT_BUFFER) {\n\t\t\t\tbufSize *= 2;\n\t\t\t\tbuf.reset(new char[bufSize]);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\treturn std::string(buf.get());\n\t\t} else {\n\t\t\tthrow platform_error();\n\t\t}\n\t}\n#else\n#  error Port me!\n#endif\n}\n\nvoid platformInit() {\n#ifdef WIN32\n\t_set_FMA3_enable(0); // Workaround for VS 2013 code generation bug. See https://connect.microsoft.com/VisualStudio/feedback/details/811093/visual-studio-2013-rtm-c-x64-code-generation-bug-for-avx2-instructions\n#endif\n#ifdef __linux__\n\tstruct timespec ts;\n\tif (clock_gettime(CLOCK_MONOTONIC, &ts) != 0) {\n\t\tcriticalError(FDB_EXIT_ERROR, \"MonotonicTimeUnavailable\", \"clock_gettime(CLOCK_MONOTONIC, ...) returned an error. Check your kernel and glibc versions.\");\n\t}\n#endif\n}\n\nvoid crashHandler(int sig) {\n#ifdef __linux__\n\t// Pretty much all of this handler is risking undefined behavior and hangs,\n\t//  but the idea is that we're about to crash anyway...\n\tstd::string backtrace = platform::get_backtrace();\n\n\tbool error = (sig != SIGUSR2);\n\n\tfflush(stdout);\n\tTraceEvent(error ? SevError : SevInfo, error ? \"Crash\" : \"ProcessTerminated\")\n\t\t.detail(\"Signal\", sig)\n\t\t.detail(\"Name\", strsignal(sig))\n\t\t.detail(\"Trace\", backtrace);\n\tflushTraceFileVoid();\n\n\tfprintf(stderr, \"SIGNAL: %s (%d)\\n\", strsignal(sig), sig);\n\tfprintf(stderr, \"Trace: %s\\n\", backtrace.c_str());\n\n\tstruct sigaction sa;\n\tsa.sa_handler = SIG_DFL;\n\tif (sigemptyset(&sa.sa_mask)) {\n\t\tint err = errno;\n\t\tfprintf(stderr, \"sigemptyset failed: %s\\n\", strerror(err));\n\t\t_exit(sig + 128);\n\t}\n\tsa.sa_flags = 0;\n\tif (sigaction(sig, &sa, NULL)) {\n\t\tint err = errno;\n\t\tfprintf(stderr, \"sigaction failed: %s\\n\", strerror(err));\n\t\t_exit(sig + 128);\n\t}\n\tif (kill(getpid(), sig)) {\n\t\tint err = errno;\n\t\tfprintf(stderr, \"kill failed: %s\\n\", strerror(err));\n\t\t_exit(sig + 128);\n\t}\n\t// Rely on kill to end the process\n#else\n\t// No crash handler for other platforms!\n#endif\n}\n\nvoid registerCrashHandler() {\n#ifdef __linux__\n\t// For these otherwise fatal errors, attempt to log a trace of\n\t// what was happening and then exit\n\tstruct sigaction action;\n\taction.sa_handler = crashHandler;\n\tsigfillset( &action.sa_mask );\n\taction.sa_flags = 0;\n\n\tsigaction(SIGILL, &action, NULL);\n\tsigaction(SIGFPE, &action, NULL);\n\tsigaction(SIGSEGV, &action, NULL);\n\tsigaction(SIGBUS, &action, NULL);\n\tsigaction(SIGUSR2, &action, NULL);\n#else\n\t// No crash handler for other platforms!\n#endif\n}\n\n#ifdef __linux__\nextern volatile void** net2backtraces;\nextern volatile size_t net2backtraces_offset;\nextern volatile size_t net2backtraces_max;\nextern volatile bool net2backtraces_overflow;\nextern volatile int net2backtraces_count;\nextern std::atomic<int64_t> net2liveness;\nextern volatile thread_local int profilingEnabled;\nextern void initProfiling();\n\nstd::atomic<double> checkThreadTime;\nvolatile thread_local bool profileThread = false;\n#endif\n\nvolatile thread_local int profilingEnabled = 1;\n\nvoid setProfilingEnabled(int enabled) {\n\tprofilingEnabled = enabled;\n}\n\nvoid profileHandler(int sig) {\n#ifdef __linux__\n\tif (!profileThread || !profilingEnabled) {\n\t\treturn;\n\t}\n\n\tnet2backtraces_count++;\n\tif (!net2backtraces || net2backtraces_max - net2backtraces_offset < 50) {\n\t\tnet2backtraces_overflow = true;\n\t\treturn;\n\t}\n\n\t// We are casting away the volatile-ness of the backtrace array, but we believe that should be reasonably safe in the signal handler\n\tProfilingSample* ps = const_cast<ProfilingSample*>((volatile ProfilingSample*)(net2backtraces + net2backtraces_offset));\n\n\t// We can only read the check thread time in a signal handler if the atomic is lock free.\n\t// We can't get the time from a timer() call because it's not signal safe.\n\tps->timestamp = checkThreadTime.is_lock_free() ? checkThreadTime.load() : 0;\n\n\t// SOMEDAY: should we limit the maximum number of frames from\n\t// backtrace beyond just available space?\n\tsize_t size = backtrace(ps->frames, net2backtraces_max - net2backtraces_offset - 2);\n\n\tps->length = size;\n\n\tnet2backtraces_offset += size + 2;\n#else\n\t// No slow task profiling for other platforms!\n#endif\n}\n\nvoid* checkThread(void *arg) {\n#ifdef __linux__\n\tpthread_t mainThread = *(pthread_t*)arg;\n\tfree(arg);\n\n\tint64_t lastValue = net2liveness.load();\n\tdouble lastSignal = 0;\n\tdouble logInterval = FLOW_KNOBS->SLOWTASK_PROFILING_INTERVAL;\n\twhile(true) {\n\t\tthreadSleep(FLOW_KNOBS->SLOWTASK_PROFILING_INTERVAL);\n\t\tint64_t currentLiveness = net2liveness.load();\n\t\tif(lastValue == currentLiveness) {\n\t\t\tdouble t = timer();\n\t\t\tif(lastSignal == 0 || t - lastSignal >= logInterval) {\n\t\t\t\tif(lastSignal > 0) {\n\t\t\t\t\tlogInterval = std::min(FLOW_KNOBS->SLOWTASK_PROFILING_MAX_LOG_INTERVAL, FLOW_KNOBS->SLOWTASK_PROFILING_LOG_BACKOFF * logInterval);\n\t\t\t\t}\n\n\t\t\t\tlastSignal = t;\n\t\t\t\tcheckThreadTime.store(lastSignal);\n\t\t\t\tpthread_kill(mainThread, SIGPROF);\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\tlastValue = currentLiveness;\n\t\t\tlastSignal = 0;\n\t\t\tlogInterval = FLOW_KNOBS->SLOWTASK_PROFILING_INTERVAL;\n\t\t}\n\t}\n\treturn NULL;\n#else\n\t// No slow task profiling for other platforms!\n\treturn NULL;\n#endif\n}\n\n#if defined(DTRACE_PROBES)\nvoid fdb_probe_actor_create(const char* name, unsigned long id) {\n\tFDB_TRACE_PROBE(actor_create, name, id);\n}\nvoid fdb_probe_actor_destroy(const char* name, unsigned long id) {\n\tFDB_TRACE_PROBE(actor_destroy, name, id);\n}\nvoid fdb_probe_actor_enter(const char* name, unsigned long id, int index) {\n\tFDB_TRACE_PROBE(actor_enter, name, id, index);\n}\nvoid fdb_probe_actor_exit(const char* name, unsigned long id, int index) {\n\tFDB_TRACE_PROBE(actor_exit, name, id, index);\n}\n#endif\n\n\nvoid setupSlowTaskProfiler() {\n#ifdef __linux__\n\tif(FLOW_KNOBS->SLOWTASK_PROFILING_INTERVAL > 0) {\n\t\tTraceEvent(\"StartingSlowTaskProfilingThread\").detail(\"Interval\", FLOW_KNOBS->SLOWTASK_PROFILING_INTERVAL);\n\t\tinitProfiling();\n\t\tprofileThread = true;\n\n\t\tstruct sigaction action;\n\t\taction.sa_handler = profileHandler;\n\t\tsigfillset(&action.sa_mask);\n\t\taction.sa_flags = 0;\n\t\tsigaction(SIGPROF, &action, NULL);\n\n\t\t// Start a thread which will use signals to log stacks on long events\n\t\tpthread_t *mainThread = (pthread_t*)malloc(sizeof(pthread_t));\n\t\t*mainThread = pthread_self();\n\t\tstartThread(&checkThread, (void*)mainThread);\n\t}\n#else\n\t// No slow task profiling for other platforms!\n#endif\n}\n\n// UnitTest for getMemoryInfo\n#ifdef __linux__\nTEST_CASE(\"/flow/Platform/getMemoryInfo\") {\n\n\tprintf(\"UnitTest flow/Platform/getMemoryInfo 1\\n\");\n\tstd::string memString =\n\t\t\"MemTotal:       24733228 kB\\n\"\n\t\t\"MemFree:         2077580 kB\\n\"\n\t\t\"Buffers:          266940 kB\\n\"\n\t\t\"Cached:         16798292 kB\\n\"\n\t\t\"SwapCached:       210240 kB\\n\"\n\t\t\"Active:         12447724 kB\\n\"\n\t\t\"Inactive:        9175508 kB\\n\"\n\t\t\"Active(anon):    3458596 kB\\n\"\n\t\t\"Inactive(anon):  1102948 kB\\n\"\n\t\t\"Active(file):    8989128 kB\\n\"\n\t\t\"Inactive(file):  8072560 kB\\n\"\n\t\t\"Unevictable:           0 kB\\n\"\n\t\t\"Mlocked:               0 kB\\n\"\n\t\t\"SwapTotal:      25165820 kB\\n\"\n\t\t\"SwapFree:       23680228 kB\\n\"\n\t\t\"Dirty:               200 kB\\n\"\n\t\t\"Writeback:             0 kB\\n\"\n\t\t\"AnonPages:       4415148 kB\\n\"\n\t\t\"Mapped:            62804 kB\\n\"\n\t\t\"Shmem:              3544 kB\\n\"\n\t\t\"Slab:             620144 kB\\n\"\n\t\t\"SReclaimable:     556640 kB\\n\"\n\t\t\"SUnreclaim:        63504 kB\\n\"\n\t\t\"KernelStack:        5240 kB\\n\"\n\t\t\"PageTables:        47292 kB\\n\"\n\t\t\"NFS_Unstable:          0 kB\\n\"\n\t\t\"Bounce:                0 kB\\n\"\n\t\t\"WritebackTmp:          0 kB\\n\"\n\t\t\"CommitLimit:    37532432 kB\\n\"\n\t\t\"Committed_AS:    8603484 kB\\n\"\n\t\t\"VmallocTotal:   34359738367 kB\\n\"\n\t\t\"VmallocUsed:      410576 kB\\n\";\n\n\tstd::map<StringRef, int64_t> request = {\n\t\t{ LiteralStringRef(\"MemTotal:\"), 0 },\n\t\t{ LiteralStringRef(\"MemFree:\"), 0 },\n\t\t{ LiteralStringRef(\"MemAvailable:\"), 0 },\n\t\t{ LiteralStringRef(\"Buffers:\"), 0 },\n\t\t{ LiteralStringRef(\"Cached:\"), 0 },\n\t\t{ LiteralStringRef(\"SwapTotal:\"), 0 },\n\t\t{ LiteralStringRef(\"SwapFree:\"), 0 },\n\t};\n\n\tstd::stringstream memInfoStream(memString);\n\tgetMemoryInfo(request, memInfoStream);\n\tASSERT(request[LiteralStringRef(\"MemTotal:\")] == 24733228);\n\tASSERT(request[LiteralStringRef(\"MemFree:\")] == 2077580);\n\tASSERT(request[LiteralStringRef(\"MemAvailable:\")] == 0);\n\tASSERT(request[LiteralStringRef(\"Buffers:\")] == 266940);\n\tASSERT(request[LiteralStringRef(\"Cached:\")] == 16798292);\n\tASSERT(request[LiteralStringRef(\"SwapTotal:\")] == 25165820);\n\tASSERT(request[LiteralStringRef(\"SwapFree:\")] == 23680228);\n\tfor (auto & item : request) {\n\t\tprintf(\"%s:%ld\\n\", item.first.toString().c_str(), item.second );\n\t}\n\n\tprintf(\"UnitTest flow/Platform/getMemoryInfo 2\\n\");\n\tstd::string memString1 =\n\t\t\"Slab:             192816 kB\\n\"\n\t\t\"SReclaimable:     158404 kB\\n\"\n\t\t\"SUnreclaim:        34412 kB\\n\"\n\t\t\"KernelStack:        7152 kB\\n\"\n\t\t\"PageTables:        45284 kB\\n\"\n\t\t\"NFS_Unstable:          0 kB\\n\"\n\t\t\"Bounce:                0 kB\\n\"\n\t\t\"WritebackTmp:          0 kB\\n\"\n\t\t\"MemTotal:       31856496 kB\\n\"\n\t\t\"MemFree:        25492716 kB\\n\"\n\t\t\"MemAvailable:   28470756 kB\\n\"\n\t\t\"Buffers:          313644 kB\\n\"\n\t\t\"Cached:          2956444 kB\\n\"\n\t\t\"SwapCached:            0 kB\\n\"\n\t\t\"Active:          3708432 kB\\n\"\n\t\t\"Inactive:        2163752 kB\\n\"\n\t\t\"Active(anon):    2604524 kB\\n\"\n\t\t\"Inactive(anon):   199896 kB\\n\"\n\t\t\"Active(file):    1103908 kB\\n\"\n\t\t\"Inactive(file):  1963856 kB\\n\"\n\t\t\"Unevictable:           0 kB\\n\"\n\t\t\"Mlocked:               0 kB\\n\"\n\t\t\"SwapTotal:             0 kB\\n\"\n\t\t\"SwapFree:              0 kB\\n\"\n\t\t\"Dirty:                 0 kB\\n\"\n\t\t\"Writeback:             0 kB\\n\"\n\t\t\"AnonPages:       2602108 kB\\n\"\n\t\t\"Mapped:           361088 kB\\n\"\n\t\t\"Shmem:            202332 kB\\n\"\n\t\t\"CommitLimit:    15928248 kB\\n\"\n\t\t\"Committed_AS:    5556756 kB\\n\"\n\t\t\"VmallocTotal:   34359738367 kB\\n\"\n\t\t\"VmallocUsed:      427528 kB\\n\"\n\t\t\"VmallocChunk:   34359283752 kB\\n\"\n\t\t\"HardwareCorrupted:     0 kB\\n\"\n\t\t\"AnonHugePages:   1275904 kB\\n\";\n\n\tstd::stringstream memInfoStream1(memString1);\n\tgetMemoryInfo(request, memInfoStream1);\n\tASSERT(request[LiteralStringRef(\"MemTotal:\")] == 31856496);\n\tASSERT(request[LiteralStringRef(\"MemFree:\")] == 25492716);\n\tASSERT(request[LiteralStringRef(\"MemAvailable:\")] == 28470756);\n\tASSERT(request[LiteralStringRef(\"Buffers:\")] == 313644);\n\tASSERT(request[LiteralStringRef(\"Cached:\")] == 2956444);\n\tASSERT(request[LiteralStringRef(\"SwapTotal:\")] == 0);\n\tASSERT(request[LiteralStringRef(\"SwapFree:\")] == 0);\n\tfor (auto & item : request) {\n\t\tprintf(\"%s:%ld\\n\", item.first.toString().c_str(), item.second);\n\t}\n\n\treturn Void();\n}\n#endif\n\nint testPathFunction(const char *name, std::function<std::string(std::string)> fun, std::string a, ErrorOr<std::string> b) {\n\tErrorOr<std::string> result;\n\ttry { result  = fun(a); } catch(Error &e) { result = e; }\n\tbool r = result.isError() == b.isError() && (b.isError() || b.get() == result.get()) && (!b.isError() || b.getError().code() == result.getError().code());\n\n\tprintf(\"%s: %s('%s') -> %s\", r ? \"PASS\" : \"FAIL\", name, a.c_str(), result.isError() ? result.getError().what() : format(\"'%s'\", result.get().c_str()).c_str());\n\tif(!r) {\n\t\tprintf(\"  *ERROR* expected %s\", b.isError() ? b.getError().what() : format(\"'%s'\", b.get().c_str()).c_str());\n\t}\n\tprintf(\"\\n\");\n\treturn r ? 0 : 1;\n}\n\nint testPathFunction2(const char *name, std::function<std::string(std::string, bool, bool)> fun, std::string a, bool resolveLinks, bool mustExist, ErrorOr<std::string> b) {\n\t// Skip tests with resolveLinks set to false as the implementation is not complete\n\tif(resolveLinks == false) {\n\t\tprintf(\"SKIPPED: %s('%s', %d, %d)\\n\", name, a.c_str(), resolveLinks, mustExist);\n\t\treturn 0;\n\t}\n\n\tErrorOr<std::string> result;\n\ttry { result  = fun(a, resolveLinks, mustExist); } catch(Error &e) { result = e; }\n\tbool r = result.isError() == b.isError() && (b.isError() || b.get() == result.get()) && (!b.isError() || b.getError().code() == result.getError().code());\n\n\tprintf(\"%s: %s('%s', %d, %d) -> %s\", r ? \"PASS\" : \"FAIL\", name, a.c_str(), resolveLinks, mustExist, result.isError() ? result.getError().what() : format(\"'%s'\", result.get().c_str()).c_str());\n\tif(!r) {\n\t\tprintf(\"  *ERROR* expected %s\", b.isError() ? b.getError().what() : format(\"'%s'\", b.get().c_str()).c_str());\n\t}\n\tprintf(\"\\n\");\n\treturn r ? 0 : 1;\n}\n\nTEST_CASE(\"/flow/Platform/directoryOps\") {\n\tint errors = 0;\n\n\terrors += testPathFunction(\"popPath\", popPath, \"a\", \"\");\n\terrors += testPathFunction(\"popPath\", popPath, \"a/\", \"\");\n\terrors += testPathFunction(\"popPath\", popPath, \"a///\", \"\");\n\terrors += testPathFunction(\"popPath\", popPath, \"a///..\", \"a/\");\n\terrors += testPathFunction(\"popPath\", popPath, \"a///../\", \"a/\");\n\terrors += testPathFunction(\"popPath\", popPath, \"a///..//\", \"a/\");\n\terrors += testPathFunction(\"popPath\", popPath, \"/\", \"/\");\n\terrors += testPathFunction(\"popPath\", popPath, \"/a\", \"/\");\n\terrors += testPathFunction(\"popPath\", popPath, \"/a/b\", \"/a/\");\n\terrors += testPathFunction(\"popPath\", popPath, \"/a/b/\", \"/a/\");\n\terrors += testPathFunction(\"popPath\", popPath, \"/a/b/..\", \"/a/b/\");\n\terrors += testPathFunction(\"popPath\", popPath, \"/a/b///..//\", \"/a/b/\");\n\n\terrors += testPathFunction(\"cleanPath\", cleanPath, \"/\", \"/\");\n\terrors += testPathFunction(\"cleanPath\", cleanPath, \"///.///\", \"/\");\n\terrors += testPathFunction(\"cleanPath\", cleanPath, \"/a/b/.././../c/./././////./d/..//\", \"/c\");\n\terrors += testPathFunction(\"cleanPath\", cleanPath, \"a/b/.././../c/./././////./d/..//\", \"c\");\n\terrors += testPathFunction(\"cleanPath\", cleanPath, \"..\", \"..\");\n\terrors += testPathFunction(\"cleanPath\", cleanPath, \"../.././\", \"../..\");\n\terrors += testPathFunction(\"cleanPath\", cleanPath, \"../a/b/..//\", \"../a\");\n\terrors += testPathFunction(\"cleanPath\", cleanPath, \"a/b/.././../c/./././////./d/..//..\", \".\");\n\terrors += testPathFunction(\"cleanPath\", cleanPath, \"/..\", \"/\");\n\terrors += testPathFunction(\"cleanPath\", cleanPath, \"/../foo/bar///\", \"/foo/bar\");\n\terrors += testPathFunction(\"cleanPath\", cleanPath, \"/a/b/../.././../\", \"/\");\n\terrors += testPathFunction(\"cleanPath\", cleanPath, \".\", \".\");\n\n\t// Creating this directory in backups avoids some sanity checks\n\tplatform::createDirectory(\"simfdb/backups/one/two/three\");\n\tstd::string cwd = platform::getWorkingDirectory();\n\n#ifndef _WIN32\n\t// Create some symlinks and test resolution (or non-resolution) of them\n\tASSERT(symlink(\"one/two\", \"simfdb/backups/four\") == 0);\n\tASSERT(symlink(\"../backups/four\", \"simfdb/backups/five\") == 0);\n\n\terrors += testPathFunction2(\"abspath\", abspath, \"simfdb/backups/four/../two\", true, true, joinPath(cwd, \"simfdb/backups/one/two\"));\n\terrors += testPathFunction2(\"abspath\", abspath, \"simfdb/backups/five/../two\", true, true, joinPath(cwd, \"simfdb/backups/one/two\"));\n\terrors += testPathFunction2(\"abspath\", abspath, \"simfdb/backups/five/../two\", true, false, joinPath(cwd, \"simfdb/backups/one/two\"));\n\terrors += testPathFunction2(\"abspath\", abspath, \"simfdb/backups/five/../three\", true, true, platform_error());\n\terrors += testPathFunction2(\"abspath\", abspath, \"simfdb/backups/five/../three\", true, false, joinPath(cwd, \"simfdb/backups/one/three\"));\n\terrors += testPathFunction2(\"abspath\", abspath, \"simfdb/backups/five/../three/../four\", true, false, joinPath(cwd, \"simfdb/backups/one/four\"));\n\n\terrors += testPathFunction2(\"parentDirectory\", parentDirectory, \"simfdb/backups/four/../two\", true, true, joinPath(cwd, \"simfdb/backups/one/\"));\n\terrors += testPathFunction2(\"parentDirectory\", parentDirectory, \"simfdb/backups/five/../two\", true, true, joinPath(cwd, \"simfdb/backups/one/\"));\n\terrors += testPathFunction2(\"parentDirectory\", parentDirectory, \"simfdb/backups/five/../two\", true, false, joinPath(cwd, \"simfdb/backups/one/\"));\n\terrors += testPathFunction2(\"parentDirectory\", parentDirectory, \"simfdb/backups/five/../three\", true, true, platform_error());\n\terrors += testPathFunction2(\"parentDirectory\", parentDirectory, \"simfdb/backups/five/../three\", true, false, joinPath(cwd, \"simfdb/backups/one/\"));\n\terrors += testPathFunction2(\"parentDirectory\", parentDirectory, \"simfdb/backups/five/../three/../four\", true, false, joinPath(cwd, \"simfdb/backups/one/\"));\n#endif\n\n\terrors += testPathFunction2(\"abspath\", abspath, \"/\", false, false, \"/\");\n\terrors += testPathFunction2(\"abspath\", abspath, \"/foo//bar//baz/.././\", false, false, \"/foo/bar\");\n\terrors += testPathFunction2(\"abspath\", abspath, \"/\", true, false, \"/\");\n\terrors += testPathFunction2(\"abspath\", abspath, \"\", true, false, platform_error());\n\terrors += testPathFunction2(\"abspath\", abspath, \".\", true, false, cwd);\n\terrors += testPathFunction2(\"abspath\", abspath, \"/a\", true, false, \"/a\");\n\terrors += testPathFunction2(\"abspath\", abspath, \"one/two/three/four\", false, true, platform_error());\n\terrors += testPathFunction2(\"abspath\", abspath, \"one/two/three/four\", false, false, joinPath(cwd, \"one/two/three/four\"));\n\terrors += testPathFunction2(\"abspath\", abspath, \"one/two/three/./four\", false, false, joinPath(cwd, \"one/two/three/four\"));\n\terrors += testPathFunction2(\"abspath\", abspath, \"one/two/three/./four\", false, false, joinPath(cwd, \"one/two/three/four\"));\n\terrors += testPathFunction2(\"abspath\", abspath, \"one/two/three/./four/..\", false, false, joinPath(cwd, \"one/two/three\"));\n\terrors += testPathFunction2(\"abspath\", abspath, \"one/./two/../three/./four\", false, false, joinPath(cwd, \"one/three/four\"));\n\terrors += testPathFunction2(\"abspath\", abspath, \"one/./two/../three/./four\", false, true, platform_error());\n\terrors += testPathFunction2(\"abspath\", abspath, \"one/two/three/./four\", false, true, platform_error());\n\terrors += testPathFunction2(\"abspath\", abspath, \"simfdb/backups/one/two/three\", false, true, joinPath(cwd, \"simfdb/backups/one/two/three\"));\n\terrors += testPathFunction2(\"abspath\", abspath, \"simfdb/backups/one/two/threefoo\", false, true, platform_error());\n\terrors += testPathFunction2(\"abspath\", abspath, \"simfdb/backups/four/../two\", false, false, joinPath(cwd, \"simfdb/backups/two\"));\n\terrors += testPathFunction2(\"abspath\", abspath, \"simfdb/backups/four/../two\", false, true, platform_error());\n\terrors += testPathFunction2(\"abspath\", abspath, \"simfdb/backups/five/../two\", false, true, platform_error());\n\terrors += testPathFunction2(\"abspath\", abspath, \"simfdb/backups/five/../two\", false, false, joinPath(cwd, \"simfdb/backups/two\"));\n\terrors += testPathFunction2(\"abspath\", abspath, \"foo/./../foo2/./bar//\", false, false, joinPath(cwd, \"foo2/bar\"));\n\terrors += testPathFunction2(\"abspath\", abspath, \"foo/./../foo2/./bar//\", false, true, platform_error());\n\terrors += testPathFunction2(\"abspath\", abspath, \"foo/./../foo2/./bar//\", true, false, joinPath(cwd, \"foo2/bar\"));\n\terrors += testPathFunction2(\"abspath\", abspath, \"foo/./../foo2/./bar//\", true, true, platform_error());\n\n\terrors += testPathFunction2(\"parentDirectory\", parentDirectory, \"\", true, false, platform_error());\n\terrors += testPathFunction2(\"parentDirectory\", parentDirectory, \"/\", true, false, \"/\");\n\terrors += testPathFunction2(\"parentDirectory\", parentDirectory, \"/a\", true, false, \"/\");\n\terrors += testPathFunction2(\"parentDirectory\", parentDirectory, \".\", false, false, cleanPath(joinPath(cwd, \"..\")) + \"/\");\n\terrors += testPathFunction2(\"parentDirectory\", parentDirectory, \"./foo\", false, false, cleanPath(cwd) + \"/\");\n\terrors += testPathFunction2(\"parentDirectory\", parentDirectory, \"one/two/three/four\", false, true, platform_error());\n\terrors += testPathFunction2(\"parentDirectory\", parentDirectory, \"one/two/three/four\", false, false, joinPath(cwd, \"one/two/three/\"));\n\terrors += testPathFunction2(\"parentDirectory\", parentDirectory, \"one/two/three/./four\", false, false, joinPath(cwd, \"one/two/three/\"));\n\terrors += testPathFunction2(\"parentDirectory\", parentDirectory, \"one/two/three/./four/..\", false, false, joinPath(cwd, \"one/two/\"));\n\terrors += testPathFunction2(\"parentDirectory\", parentDirectory, \"one/./two/../three/./four\", false, false, joinPath(cwd, \"one/three/\"));\n\terrors += testPathFunction2(\"parentDirectory\", parentDirectory, \"one/./two/../three/./four\", false, true, platform_error());\n\terrors += testPathFunction2(\"parentDirectory\", parentDirectory, \"one/two/three/./four\", false, true, platform_error());\n\terrors += testPathFunction2(\"parentDirectory\", parentDirectory, \"simfdb/backups/one/two/three\", false, true, joinPath(cwd, \"simfdb/backups/one/two/\"));\n\terrors += testPathFunction2(\"parentDirectory\", parentDirectory, \"simfdb/backups/one/two/threefoo\", false, true, platform_error());\n\terrors += testPathFunction2(\"parentDirectory\", parentDirectory, \"simfdb/backups/four/../two\", false, false, joinPath(cwd, \"simfdb/backups/\"));\n\terrors += testPathFunction2(\"parentDirectory\", parentDirectory, \"simfdb/backups/four/../two\", false, true, platform_error());\n\terrors += testPathFunction2(\"parentDirectory\", parentDirectory, \"simfdb/backups/five/../two\", false, true, platform_error());\n\terrors += testPathFunction2(\"parentDirectory\", parentDirectory, \"simfdb/backups/five/../two\", false, false, joinPath(cwd, \"simfdb/backups/\"));\n\terrors += testPathFunction2(\"parentDirectory\", parentDirectory, \"foo/./../foo2/./bar//\", false, false, joinPath(cwd, \"foo2/\"));\n\terrors += testPathFunction2(\"parentDirectory\", parentDirectory, \"foo/./../foo2/./bar//\", false, true, platform_error());\n\terrors += testPathFunction2(\"parentDirectory\", parentDirectory, \"foo/./../foo2/./bar//\", true, false, joinPath(cwd, \"foo2/\"));\n\terrors += testPathFunction2(\"parentDirectory\", parentDirectory, \"foo/./../foo2/./bar//\", true, true, platform_error());\n\n\tprintf(\"%d errors.\\n\", errors);\n\n\tASSERT(errors == 0);\n\treturn Void();\n}\n",
        "/tmp/vanessa/spack-stage/spack-stage-foundationdb-6.2.24-ivypaqw232so4ki6gkkpzsm3swadt3su/spack-src/flow/SignalSafeUnwind.cpp": "/*\n * SignalSafeUnwind.cpp\n *\n * This source file is part of the FoundationDB open source project\n *\n * Copyright 2013-2018 Apple Inc. and the FoundationDB project authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n#include \"flow/SignalSafeUnwind.h\"\n\nint64_t dl_iterate_phdr_calls = 0;\n\n#ifdef __linux__\n\n#include <link.h>\n#include <mutex>\n\nstatic bool phdr_cache_initialized = false;\nstatic std::vector< std::vector<uint8_t> > phdr_cache;\n\nstatic int (*chain_dl_iterate_phdr)(\n          int (*callback) (struct dl_phdr_info *info, size_t size, void *data),\n          void *data) = nullptr;\n\nstatic int phdr_cache_add( struct dl_phdr_info *info, size_t size, void *data ) {\n\tphdr_cache.push_back( std::vector<uint8_t>((uint8_t*)info, (uint8_t*)info + size) );\n\treturn 0;\n}\n\nstatic void initChain() {\n\tstatic std::once_flag flag;\n\n\t// Ensure that chain_dl_iterate_phdr points to the \"real\" function that we are overriding\n\tstd::call_once(flag, [](){ *(void**)&chain_dl_iterate_phdr = dlsym(RTLD_NEXT, \"dl_iterate_phdr\"); });\n\n\tif (!chain_dl_iterate_phdr) {\n\t\tcriticalError(FDB_EXIT_ERROR, \"SignalSafeUnwindError\", \"Unable to find dl_iterate_phdr symbol\");\n\t}\n}\n\nvoid initSignalSafeUnwind() {\n\tinitChain();\n\n\tphdr_cache.clear();\n\tif (chain_dl_iterate_phdr(&phdr_cache_add, 0))\n\t\tcriticalError(FDB_EXIT_ERROR, \"DLIterateError\", \"dl_iterate_phdr error\");\n\tphdr_cache_initialized = true;\n}\n\n// This overrides the function in libc!\nextern \"C\" int dl_iterate_phdr(\n          int (*callback) (struct dl_phdr_info *info, size_t size, void *data),\n          void *data)\n{\n\tinterlockedIncrement64(&dl_iterate_phdr_calls);\n\n\tif (phdr_cache_initialized)\n\t{\n\t\t// This path should be async signal safe\n\t\tfor(int i=0; i<phdr_cache.size(); i++)\n\t\t{\n\t\t\tint r = callback( (struct dl_phdr_info*)&phdr_cache[i][0], phdr_cache[i].size(), data );\n\t\t\tif (r!=0)\n\t\t\t\treturn r;\n\t\t}\n\t\treturn 0;\n\t} else {\n\t\t// This path is NOT async signal safe, and serves until and unless initSignalSafeUnwind() is called\n\t\tinitChain();\n\n\t\tsetProfilingEnabled(0);\n\t\tint result = chain_dl_iterate_phdr(callback, data);\n\t\tsetProfilingEnabled(1);\n\t\treturn result;\n\t}\n}\n\n#else  // __linux__\n\nvoid initSignalSafeUnwind() {}\n\n#endif",
        "/tmp/vanessa/spack-stage/spack-stage-foundationdb-6.2.24-ivypaqw232so4ki6gkkpzsm3swadt3su/spack-src/fdbserver/sqlite/sqlite3.amalgamation.c": "#ifndef NDEBUG\n#define NDEBUG\n#endif\n#ifndef NDEBUG\n    #define SQLITE_DEBUG 1\n#endif\n#define SQLITE_THREADSAFE 0\n#define ENABLE_SCRATCHALLOC_CHECK 0\n#define SQLITE_OMIT_SHARED_CACHE 1\n#define SQLITE_FILE_HEADER \"FoundationDB100\"\n#define HAVE_USLEEP 1\n\n/******************************************************************************\n** This file is an amalgamation of many separate C source files from SQLite\n** version 3.7.6.  By combining all the individual C code files into this \n** single large file, the entire code can be compiled as a one translation\n** unit.  This allows many compilers to do optimizations that would not be\n** possible if the files were compiled separately.  Performance improvements\n** of 5% or more are commonly seen when SQLite is compiled as a single\n** translation unit.\n**\n** This file is all you need to compile SQLite.  To use SQLite in other\n** programs, you need this file and the \"sqlite3.h\" header file that defines\n** the programming interface to the SQLite library.  (If you do not have \n** the \"sqlite3.h\" header file at hand, you will find a copy embedded within\n** the text of this file.  Search for \"Begin file sqlite3.h\" to find the start\n** of the embedded sqlite3.h header file.) Additional code files may be needed\n** if you want a wrapper to interface SQLite with your choice of programming\n** language. The code for the \"sqlite3\" command-line shell is also in a\n** separate file. This file contains only code for the core SQLite library.\n*/\n#define SQLITE_CORE 1\n#define SQLITE_AMALGAMATION 1\n#ifndef SQLITE_PRIVATE\n# define SQLITE_PRIVATE //static\n#endif\n#ifndef SQLITE_API\n# define SQLITE_API\n#endif\n/************** Begin file sqliteInt.h ***************************************/\n/*\n** 2001 September 15\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** Internal interface definitions for SQLite.\n**\n*/\n#ifndef _SQLITEINT_H_\n#define _SQLITEINT_H_\n\n/*\n** These #defines should enable >2GB file support on POSIX if the\n** underlying operating system supports it.  If the OS lacks\n** large file support, or if the OS is windows, these should be no-ops.\n**\n** Ticket #2739:  The _LARGEFILE_SOURCE macro must appear before any\n** system #includes.  Hence, this block of code must be the very first\n** code in all source files.\n**\n** Large file support can be disabled using the -DSQLITE_DISABLE_LFS switch\n** on the compiler command line.  This is necessary if you are compiling\n** on a recent machine (ex: Red Hat 7.2) but you want your code to work\n** on an older machine (ex: Red Hat 6.0).  If you compile on Red Hat 7.2\n** without this option, LFS is enable.  But LFS does not exist in the kernel\n** in Red Hat 6.0, so the code won't work.  Hence, for maximum binary\n** portability you should omit LFS.\n**\n** Similar is true for Mac OS X.  LFS is only supported on Mac OS X 9 and later.\n*/\n#ifndef SQLITE_DISABLE_LFS\n# define _LARGE_FILE       1\n# ifndef _FILE_OFFSET_BITS\n#   define _FILE_OFFSET_BITS 64\n# endif\n# define _LARGEFILE_SOURCE 1\n#endif\n\n/*\n** Include the configuration header output by 'configure' if we're using the\n** autoconf-based build\n*/\n#ifdef _HAVE_SQLITE_CONFIG_H\n#include \"config.h\"\n#endif\n\n/************** Include sqliteLimit.h in the middle of sqliteInt.h ***********/\n/************** Begin file sqliteLimit.h *************************************/\n/*\n** 2007 May 7\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** \n** This file defines various limits of what SQLite can process.\n*/\n\n/*\n** The maximum length of a TEXT or BLOB in bytes.   This also\n** limits the size of a row in a table or index.\n**\n** The hard limit is the ability of a 32-bit signed integer\n** to count the size: 2^31-1 or 2147483647.\n*/\n#ifndef SQLITE_MAX_LENGTH\n# define SQLITE_MAX_LENGTH 1000000000\n#endif\n\n/*\n** This is the maximum number of\n**\n**    * Columns in a table\n**    * Columns in an index\n**    * Columns in a view\n**    * Terms in the SET clause of an UPDATE statement\n**    * Terms in the result set of a SELECT statement\n**    * Terms in the GROUP BY or ORDER BY clauses of a SELECT statement.\n**    * Terms in the VALUES clause of an INSERT statement\n**\n** The hard upper limit here is 32676.  Most database people will\n** tell you that in a well-normalized database, you usually should\n** not have more than a dozen or so columns in any table.  And if\n** that is the case, there is no point in having more than a few\n** dozen values in any of the other situations described above.\n*/\n#ifndef SQLITE_MAX_COLUMN\n# define SQLITE_MAX_COLUMN 2000\n#endif\n\n/*\n** The maximum length of a single SQL statement in bytes.\n**\n** It used to be the case that setting this value to zero would\n** turn the limit off.  That is no longer true.  It is not possible\n** to turn this limit off.\n*/\n#ifndef SQLITE_MAX_SQL_LENGTH\n# define SQLITE_MAX_SQL_LENGTH 1000000000\n#endif\n\n/*\n** The maximum depth of an expression tree. This is limited to \n** some extent by SQLITE_MAX_SQL_LENGTH. But sometime you might \n** want to place more severe limits on the complexity of an \n** expression.\n**\n** A value of 0 used to mean that the limit was not enforced.\n** But that is no longer true.  The limit is now strictly enforced\n** at all times.\n*/\n#ifndef SQLITE_MAX_EXPR_DEPTH\n# define SQLITE_MAX_EXPR_DEPTH 1000\n#endif\n\n/*\n** The maximum number of terms in a compound SELECT statement.\n** The code generator for compound SELECT statements does one\n** level of recursion for each term.  A stack overflow can result\n** if the number of terms is too large.  In practice, most SQL\n** never has more than 3 or 4 terms.  Use a value of 0 to disable\n** any limit on the number of terms in a compound SELECT.\n*/\n#ifndef SQLITE_MAX_COMPOUND_SELECT\n# define SQLITE_MAX_COMPOUND_SELECT 500\n#endif\n\n/*\n** The maximum number of opcodes in a VDBE program.\n** Not currently enforced.\n*/\n#ifndef SQLITE_MAX_VDBE_OP\n# define SQLITE_MAX_VDBE_OP 25000\n#endif\n\n/*\n** The maximum number of arguments to an SQL function.\n*/\n#ifndef SQLITE_MAX_FUNCTION_ARG\n# define SQLITE_MAX_FUNCTION_ARG 127\n#endif\n\n/*\n** The maximum number of in-memory pages to use for the main database\n** table and for temporary tables.  The SQLITE_DEFAULT_CACHE_SIZE\n*/\n#ifndef SQLITE_DEFAULT_CACHE_SIZE\n# define SQLITE_DEFAULT_CACHE_SIZE  2000\n#endif\n#ifndef SQLITE_DEFAULT_TEMP_CACHE_SIZE\n# define SQLITE_DEFAULT_TEMP_CACHE_SIZE  500\n#endif\n\n/*\n** The default number of frames to accumulate in the log file before\n** checkpointing the database in WAL mode.\n*/\n#ifndef SQLITE_DEFAULT_WAL_AUTOCHECKPOINT\n# define SQLITE_DEFAULT_WAL_AUTOCHECKPOINT  1000\n#endif\n\n/*\n** The maximum number of attached databases.  This must be between 0\n** and 30.  The upper bound on 30 is because a 32-bit integer bitmap\n** is used internally to track attached databases.\n*/\n#ifndef SQLITE_MAX_ATTACHED\n# define SQLITE_MAX_ATTACHED 10\n#endif\n\n\n/*\n** The maximum value of a ?nnn wildcard that the parser will accept.\n*/\n#ifndef SQLITE_MAX_VARIABLE_NUMBER\n# define SQLITE_MAX_VARIABLE_NUMBER 999\n#endif\n\n/* Maximum page size.  The upper bound on this value is 65536.  This a limit\n** imposed by the use of 16-bit offsets within each page.\n**\n** Earlier versions of SQLite allowed the user to change this value at\n** compile time. This is no longer permitted, on the grounds that it creates\n** a library that is technically incompatible with an SQLite library \n** compiled with a different limit. If a process operating on a database \n** with a page-size of 65536 bytes crashes, then an instance of SQLite \n** compiled with the default page-size limit will not be able to rollback \n** the aborted transaction. This could lead to database corruption.\n*/\n#ifdef SQLITE_MAX_PAGE_SIZE\n# undef SQLITE_MAX_PAGE_SIZE\n#endif\n#define SQLITE_MAX_PAGE_SIZE 65536\n\n\n/*\n** The default size of a database page.\n*/\n#ifndef SQLITE_DEFAULT_PAGE_SIZE\n# define SQLITE_DEFAULT_PAGE_SIZE 1024\n#endif\n#if SQLITE_DEFAULT_PAGE_SIZE>SQLITE_MAX_PAGE_SIZE\n# undef SQLITE_DEFAULT_PAGE_SIZE\n# define SQLITE_DEFAULT_PAGE_SIZE SQLITE_MAX_PAGE_SIZE\n#endif\n\n/*\n** Ordinarily, if no value is explicitly provided, SQLite creates databases\n** with page size SQLITE_DEFAULT_PAGE_SIZE. However, based on certain\n** device characteristics (sector-size and atomic write() support),\n** SQLite may choose a larger value. This constant is the maximum value\n** SQLite will choose on its own.\n*/\n#ifndef SQLITE_MAX_DEFAULT_PAGE_SIZE\n# define SQLITE_MAX_DEFAULT_PAGE_SIZE 8192\n#endif\n#if SQLITE_MAX_DEFAULT_PAGE_SIZE>SQLITE_MAX_PAGE_SIZE\n# undef SQLITE_MAX_DEFAULT_PAGE_SIZE\n# define SQLITE_MAX_DEFAULT_PAGE_SIZE SQLITE_MAX_PAGE_SIZE\n#endif\n\n\n/*\n** Maximum number of pages in one database file.\n**\n** This is really just the default value for the max_page_count pragma.\n** This value can be lowered (or raised) at run-time using that the\n** max_page_count macro.\n*/\n#ifndef SQLITE_MAX_PAGE_COUNT\n# define SQLITE_MAX_PAGE_COUNT 1073741823\n#endif\n\n/*\n** Maximum length (in bytes) of the pattern in a LIKE or GLOB\n** operator.\n*/\n#ifndef SQLITE_MAX_LIKE_PATTERN_LENGTH\n# define SQLITE_MAX_LIKE_PATTERN_LENGTH 50000\n#endif\n\n/*\n** Maximum depth of recursion for triggers.\n**\n** A value of 1 means that a trigger program will not be able to itself\n** fire any triggers. A value of 0 means that no trigger programs at all \n** may be executed.\n*/\n#ifndef SQLITE_MAX_TRIGGER_DEPTH\n# define SQLITE_MAX_TRIGGER_DEPTH 1000\n#endif\n\n/************** End of sqliteLimit.h *****************************************/\n/************** Continuing where we left off in sqliteInt.h ******************/\n\n/* Disable nuisance warnings on Borland compilers */\n#if defined(__BORLANDC__)\n#pragma warn -rch /* unreachable code */\n#pragma warn -ccc /* Condition is always true or false */\n#pragma warn -aus /* Assigned value is never used */\n#pragma warn -csu /* Comparing signed and unsigned */\n#pragma warn -spa /* Suspicious pointer arithmetic */\n#endif\n\n/* Needed for various definitions... */\n#ifndef _GNU_SOURCE\n# define _GNU_SOURCE\n#endif\n\n/*\n** Include standard header files as necessary\n*/\n#ifdef HAVE_STDINT_H\n#include <stdint.h>\n#endif\n#ifdef HAVE_INTTYPES_H\n#include <inttypes.h>\n#endif\n\n/*\n** The number of samples of an index that SQLite takes in order to \n** construct a histogram of the table content when running ANALYZE\n** and with SQLITE_ENABLE_STAT2\n*/\n#define SQLITE_INDEX_SAMPLES 10\n\n/*\n** The following macros are used to cast pointers to integers and\n** integers to pointers.  The way you do this varies from one compiler\n** to the next, so we have developed the following set of #if statements\n** to generate appropriate macros for a wide range of compilers.\n**\n** The correct \"ANSI\" way to do this is to use the intptr_t type. \n** Unfortunately, that typedef is not available on all compilers, or\n** if it is available, it requires an #include of specific headers\n** that vary from one machine to the next.\n**\n** Ticket #3860:  The llvm-gcc-4.2 compiler from Apple chokes on\n** the ((void*)&((char*)0)[X]) construct.  But MSVC chokes on ((void*)(X)).\n** So we have to define the macros in different ways depending on the\n** compiler.\n*/\n#if defined(__PTRDIFF_TYPE__)  /* This case should work for GCC */\n# define SQLITE_INT_TO_PTR(X)  ((void*)(__PTRDIFF_TYPE__)(X))\n# define SQLITE_PTR_TO_INT(X)  ((int)(__PTRDIFF_TYPE__)(X))\n#elif !defined(__GNUC__)       /* Works for compilers other than LLVM */\n# define SQLITE_INT_TO_PTR(X)  ((void*)&((char*)0)[X])\n# define SQLITE_PTR_TO_INT(X)  ((int)(((char*)X)-(char*)0))\n#elif defined(HAVE_STDINT_H)   /* Use this case if we have ANSI headers */\n# define SQLITE_INT_TO_PTR(X)  ((void*)(intptr_t)(X))\n# define SQLITE_PTR_TO_INT(X)  ((int)(intptr_t)(X))\n#else                          /* Generates a warning - but it always works */\n# define SQLITE_INT_TO_PTR(X)  ((void*)(X))\n# define SQLITE_PTR_TO_INT(X)  ((int)(X))\n#endif\n\n/*\n** The SQLITE_THREADSAFE macro must be defined as 0, 1, or 2.\n** 0 means mutexes are permanently disable and the library is never\n** threadsafe.  1 means the library is serialized which is the highest\n** level of threadsafety.  2 means the libary is multithreaded - multiple\n** threads can use SQLite as long as no two threads try to use the same\n** database connection at the same time.\n**\n** Older versions of SQLite used an optional THREADSAFE macro.\n** We support that for legacy.\n*/\n#if !defined(SQLITE_THREADSAFE)\n#if defined(THREADSAFE)\n# define SQLITE_THREADSAFE THREADSAFE\n#else\n# define SQLITE_THREADSAFE 1 /* IMP: R-07272-22309 */\n#endif\n#endif\n\n/*\n** The SQLITE_DEFAULT_MEMSTATUS macro must be defined as either 0 or 1.\n** It determines whether or not the features related to \n** SQLITE_CONFIG_MEMSTATUS are available by default or not. This value can\n** be overridden at runtime using the sqlite3_config() API.\n*/\n/* FIXME: this needs to be true for better tracking memory use in our\n   sqlite threads, but causes large slowdowns due to mutex\n   contention. Disabled for now, but a better long term solution is\n   required. */\n#if !defined(SQLITE_DEFAULT_MEMSTATUS)\n# define SQLITE_DEFAULT_MEMSTATUS 0\n#endif\n\n/*\n** Exactly one of the following macros must be defined in order to\n** specify which memory allocation subsystem to use.\n**\n**     SQLITE_SYSTEM_MALLOC          // Use normal system malloc()\n**     SQLITE_MEMDEBUG               // Debugging version of system malloc()\n**\n** (Historical note:  There used to be several other options, but we've\n** pared it down to just these two.)\n**\n** If none of the above are defined, then set SQLITE_SYSTEM_MALLOC as\n** the default.\n*/\n#if defined(SQLITE_SYSTEM_MALLOC)+defined(SQLITE_MEMDEBUG)>1\n# error \"At most one of the following compile-time configuration options\\\n is allows: SQLITE_SYSTEM_MALLOC, SQLITE_MEMDEBUG\"\n#endif\n#if defined(SQLITE_SYSTEM_MALLOC)+defined(SQLITE_MEMDEBUG)==0\n# define SQLITE_SYSTEM_MALLOC 1\n#endif\n\n/*\n** If SQLITE_MALLOC_SOFT_LIMIT is not zero, then try to keep the\n** sizes of memory allocations below this value where possible.\n*/\n#if !defined(SQLITE_MALLOC_SOFT_LIMIT)\n# define SQLITE_MALLOC_SOFT_LIMIT 1024\n#endif\n\n/*\n** We need to define _XOPEN_SOURCE as follows in order to enable\n** recursive mutexes on most Unix systems.  But Mac OS X is different.\n** The _XOPEN_SOURCE define causes problems for Mac OS X we are told,\n** so it is omitted there.  See ticket #2673.\n**\n** Later we learn that _XOPEN_SOURCE is poorly or incorrectly\n** implemented on some systems.  So we avoid defining it at all\n** if it is already defined or if it is unneeded because we are\n** not doing a threadsafe build.  Ticket #2681.\n**\n** See also ticket #2741.\n*/\n#if !defined(_XOPEN_SOURCE) && !defined(__DARWIN__) && !defined(__APPLE__) && SQLITE_THREADSAFE\n#  define _XOPEN_SOURCE 500  /* Needed to enable pthread recursive mutexes */\n#endif\n\n/*\n** The TCL headers are only needed when compiling the TCL bindings.\n*/\n#if defined(SQLITE_TCL) || defined(TCLSH)\n# include <tcl.h>\n#endif\n\n/*\n** Many people are failing to set -DNDEBUG=1 when compiling SQLite.\n** Setting NDEBUG makes the code smaller and run faster.  So the following\n** lines are added to automatically set NDEBUG unless the -DSQLITE_DEBUG=1\n** option is set.  Thus NDEBUG becomes an opt-in rather than an opt-out\n** feature.\n*/\n#if !defined(NDEBUG) && !defined(SQLITE_DEBUG) \n# define NDEBUG 1\n#endif\n#if defined(NDEBUG) && defined(SQLITE_DEBUG)\n# undef NDEBUG\n#endif\n\n/*\n** The testcase() macro is used to aid in coverage testing.  When \n** doing coverage testing, the condition inside the argument to\n** testcase() must be evaluated both true and false in order to\n** get full branch coverage.  The testcase() macro is inserted\n** to help ensure adequate test coverage in places where simple\n** condition/decision coverage is inadequate.  For example, testcase()\n** can be used to make sure boundary values are tested.  For\n** bitmask tests, testcase() can be used to make sure each bit\n** is significant and used at least once.  On switch statements\n** where multiple cases go to the same block of code, testcase()\n** can insure that all cases are evaluated.\n**\n*/\n#ifdef SQLITE_COVERAGE_TEST\nSQLITE_PRIVATE   void sqlite3Coverage(int);\n# define testcase(X)  if( X ){ sqlite3Coverage(__LINE__); }\n#else\n# define testcase(X)\n#endif\n\n/*\n** The TESTONLY macro is used to enclose variable declarations or\n** other bits of code that are needed to support the arguments\n** within testcase() and assert() macros.\n*/\n#if !defined(NDEBUG) || defined(SQLITE_COVERAGE_TEST)\n# define TESTONLY(X)  X\n#else\n# define TESTONLY(X)\n#endif\n\n/*\n** Sometimes we need a small amount of code such as a variable initialization\n** to setup for a later assert() statement.  We do not want this code to\n** appear when assert() is disabled.  The following macro is therefore\n** used to contain that setup code.  The \"VVA\" acronym stands for\n** \"Verification, Validation, and Accreditation\".  In other words, the\n** code within VVA_ONLY() will only run during verification processes.\n*/\n#ifndef NDEBUG\n# define VVA_ONLY(X)  X\n#else\n# define VVA_ONLY(X)\n#endif\n\n/*\n** The ALWAYS and NEVER macros surround boolean expressions which \n** are intended to always be true or false, respectively.  Such\n** expressions could be omitted from the code completely.  But they\n** are included in a few cases in order to enhance the resilience\n** of SQLite to unexpected behavior - to make the code \"self-healing\"\n** or \"ductile\" rather than being \"brittle\" and crashing at the first\n** hint of unplanned behavior.\n**\n** In other words, ALWAYS and NEVER are added for defensive code.\n**\n** When doing coverage testing ALWAYS and NEVER are hard-coded to\n** be true and false so that the unreachable code then specify will\n** not be counted as untested code.\n*/\n#if defined(SQLITE_COVERAGE_TEST)\n# define ALWAYS(X)      (1)\n# define NEVER(X)       (0)\n#elif !defined(NDEBUG)\n# define ALWAYS(X)      ((X)?1:(assert(0),0))\n# define NEVER(X)       ((X)?(assert(0),1):0)\n#else\n# define ALWAYS(X)      ((X) != 0)\n# define NEVER(X)       ((X) != 0)\n#endif\n\n/*\n** Return true (non-zero) if the input is a integer that is too large\n** to fit in 32-bits.  This macro is used inside of various testcase()\n** macros to verify that we have tested SQLite for large-file support.\n*/\n#define IS_BIG_INT(X)  (((X)&~(i64)0xffffffff)!=0)\n\n/*\n** The macro unlikely() is a hint that surrounds a boolean\n** expression that is usually false.  Macro likely() surrounds\n** a boolean expression that is usually true.  GCC is able to\n** use these hints to generate better code, sometimes.\n*/\n#if defined(__GNUC__) && 0\n# define likely(X)    __builtin_expect((X),1)\n# define unlikely(X)  __builtin_expect((X),0)\n#else\n# define likely(X)    !!(X)\n# define unlikely(X)  !!(X)\n#endif\n\n/************** Include sqlite3.h in the middle of sqliteInt.h ***************/\n#include \"sqlite3.h\"\n\n/************** Continuing where we left off in sqliteInt.h ******************/\n/************** Include hash.h in the middle of sqliteInt.h ******************/\n/************** Begin file hash.h ********************************************/\n/*\n** 2001 September 22\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This is the header file for the generic hash-table implemenation\n** used in SQLite.\n*/\n#ifndef _SQLITE_HASH_H_\n#define _SQLITE_HASH_H_\n\n/* Forward declarations of structures. */\ntypedef struct Hash Hash;\ntypedef struct HashElem HashElem;\n\n/* A complete hash table is an instance of the following structure.\n** The internals of this structure are intended to be opaque -- client\n** code should not attempt to access or modify the fields of this structure\n** directly.  Change this structure only by using the routines below.\n** However, some of the \"procedures\" and \"functions\" for modifying and\n** accessing this structure are really macros, so we can't really make\n** this structure opaque.\n**\n** All elements of the hash table are on a single doubly-linked list.\n** Hash.first points to the head of this list.\n**\n** There are Hash.htsize buckets.  Each bucket points to a spot in\n** the global doubly-linked list.  The contents of the bucket are the\n** element pointed to plus the next _ht.count-1 elements in the list.\n**\n** Hash.htsize and Hash.ht may be zero.  In that case lookup is done\n** by a linear search of the global list.  For small tables, the \n** Hash.ht table is never allocated because if there are few elements\n** in the table, it is faster to do a linear search than to manage\n** the hash table.\n*/\nstruct Hash {\n  unsigned int htsize;      /* Number of buckets in the hash table */\n  unsigned int count;       /* Number of entries in this table */\n  HashElem *first;          /* The first element of the array */\n  struct _ht {              /* the hash table */\n    int count;                 /* Number of entries with this hash */\n    HashElem *chain;           /* Pointer to first entry with this hash */\n  } *ht;\n};\n\n/* Each element in the hash table is an instance of the following \n** structure.  All elements are stored on a single doubly-linked list.\n**\n** Again, this structure is intended to be opaque, but it can't really\n** be opaque because it is used by macros.\n*/\nstruct HashElem {\n  HashElem *next, *prev;       /* Next and previous elements in the table */\n  void *data;                  /* Data associated with this element */\n  const char *pKey; int nKey;  /* Key associated with this element */\n};\n\n/*\n** Access routines.  To delete, insert a NULL pointer.\n*/\nSQLITE_PRIVATE void sqlite3HashInit(Hash*);\nSQLITE_PRIVATE void *sqlite3HashInsert(Hash*, const char *pKey, int nKey, void *pData);\nSQLITE_PRIVATE void *sqlite3HashFind(const Hash*, const char *pKey, int nKey);\nSQLITE_PRIVATE void sqlite3HashClear(Hash*);\n\n/*\n** Macros for looping over all elements of a hash table.  The idiom is\n** like this:\n**\n**   Hash h;\n**   HashElem *p;\n**   ...\n**   for(p=sqliteHashFirst(&h); p; p=sqliteHashNext(p)){\n**     SomeStructure *pData = sqliteHashData(p);\n**     // do something with pData\n**   }\n*/\n#define sqliteHashFirst(H)  ((H)->first)\n#define sqliteHashNext(E)   ((E)->next)\n#define sqliteHashData(E)   ((E)->data)\n/* #define sqliteHashKey(E)    ((E)->pKey) // NOT USED */\n/* #define sqliteHashKeysize(E) ((E)->nKey)  // NOT USED */\n\n/*\n** Number of entries in a hash table\n*/\n/* #define sqliteHashCount(H)  ((H)->count) // NOT USED */\n\n#endif /* _SQLITE_HASH_H_ */\n\n/************** End of hash.h ************************************************/\n/************** Continuing where we left off in sqliteInt.h ******************/\n/************** Include parse.h in the middle of sqliteInt.h *****************/\n/************** Begin file parse.h *******************************************/\n#define TK_SEMI                            1\n#define TK_EXPLAIN                         2\n#define TK_QUERY                           3\n#define TK_PLAN                            4\n#define TK_BEGIN                           5\n#define TK_TRANSACTION                     6\n#define TK_DEFERRED                        7\n#define TK_IMMEDIATE                       8\n#define TK_EXCLUSIVE                       9\n#define TK_COMMIT                         10\n#define TK_END                            11\n#define TK_ROLLBACK                       12\n#define TK_SAVEPOINT                      13\n#define TK_RELEASE                        14\n#define TK_TO                             15\n#define TK_TABLE                          16\n#define TK_CREATE                         17\n#define TK_IF                             18\n#define TK_NOT                            19\n#define TK_EXISTS                         20\n#define TK_TEMP                           21\n#define TK_LP                             22\n#define TK_RP                             23\n#define TK_AS                             24\n#define TK_COMMA                          25\n#define TK_ID                             26\n#define TK_INDEXED                        27\n#define TK_ABORT                          28\n#define TK_ACTION                         29\n#define TK_AFTER                          30\n#define TK_ANALYZE                        31\n#define TK_ASC                            32\n#define TK_ATTACH                         33\n#define TK_BEFORE                         34\n#define TK_BY                             35\n#define TK_CASCADE                        36\n#define TK_CAST                           37\n#define TK_COLUMNKW                       38\n#define TK_CONFLICT                       39\n#define TK_DATABASE                       40\n#define TK_DESC                           41\n#define TK_DETACH                         42\n#define TK_EACH                           43\n#define TK_FAIL                           44\n#define TK_FOR                            45\n#define TK_IGNORE                         46\n#define TK_INITIALLY                      47\n#define TK_INSTEAD                        48\n#define TK_LIKE_KW                        49\n#define TK_MATCH                          50\n#define TK_NO                             51\n#define TK_KEY                            52\n#define TK_OF                             53\n#define TK_OFFSET                         54\n#define TK_PRAGMA                         55\n#define TK_RAISE                          56\n#define TK_REPLACE                        57\n#define TK_RESTRICT                       58\n#define TK_ROW                            59\n#define TK_TRIGGER                        60\n#define TK_VACUUM                         61\n#define TK_VIEW                           62\n#define TK_VIRTUAL                        63\n#define TK_REINDEX                        64\n#define TK_RENAME                         65\n#define TK_CTIME_KW                       66\n#define TK_ANY                            67\n#define TK_OR                             68\n#define TK_AND                            69\n#define TK_IS                             70\n#define TK_BETWEEN                        71\n#define TK_IN                             72\n#define TK_ISNULL                         73\n#define TK_NOTNULL                        74\n#define TK_NE                             75\n#define TK_EQ                             76\n#define TK_GT                             77\n#define TK_LE                             78\n#define TK_LT                             79\n#define TK_GE                             80\n#define TK_ESCAPE                         81\n#define TK_BITAND                         82\n#define TK_BITOR                          83\n#define TK_LSHIFT                         84\n#define TK_RSHIFT                         85\n#define TK_PLUS                           86\n#define TK_MINUS                          87\n#define TK_STAR                           88\n#define TK_SLASH                          89\n#define TK_REM                            90\n#define TK_CONCAT                         91\n#define TK_COLLATE                        92\n#define TK_BITNOT                         93\n#define TK_STRING                         94\n#define TK_JOIN_KW                        95\n#define TK_CONSTRAINT                     96\n#define TK_DEFAULT                        97\n#define TK_NULL                           98\n#define TK_PRIMARY                        99\n#define TK_UNIQUE                         100\n#define TK_CHECK                          101\n#define TK_REFERENCES                     102\n#define TK_AUTOINCR                       103\n#define TK_ON                             104\n#define TK_INSERT                         105\n#define TK_DELETE                         106\n#define TK_UPDATE                         107\n#define TK_SET                            108\n#define TK_DEFERRABLE                     109\n#define TK_FOREIGN                        110\n#define TK_DROP                           111\n#define TK_UNION                          112\n#define TK_ALL                            113\n#define TK_EXCEPT                         114\n#define TK_INTERSECT                      115\n#define TK_SELECT                         116\n#define TK_DISTINCT                       117\n#define TK_DOT                            118\n#define TK_FROM                           119\n#define TK_JOIN                           120\n#define TK_USING                          121\n#define TK_ORDER                          122\n#define TK_GROUP                          123\n#define TK_HAVING                         124\n#define TK_LIMIT                          125\n#define TK_WHERE                          126\n#define TK_INTO                           127\n#define TK_VALUES                         128\n#define TK_INTEGER                        129\n#define TK_FLOAT                          130\n#define TK_BLOB                           131\n#define TK_REGISTER                       132\n#define TK_VARIABLE                       133\n#define TK_CASE                           134\n#define TK_WHEN                           135\n#define TK_THEN                           136\n#define TK_ELSE                           137\n#define TK_INDEX                          138\n#define TK_ALTER                          139\n#define TK_ADD                            140\n#define TK_TO_TEXT                        141\n#define TK_TO_BLOB                        142\n#define TK_TO_NUMERIC                     143\n#define TK_TO_INT                         144\n#define TK_TO_REAL                        145\n#define TK_ISNOT                          146\n#define TK_END_OF_FILE                    147\n#define TK_ILLEGAL                        148\n#define TK_SPACE                          149\n#define TK_UNCLOSED_STRING                150\n#define TK_FUNCTION                       151\n#define TK_COLUMN                         152\n#define TK_AGG_FUNCTION                   153\n#define TK_AGG_COLUMN                     154\n#define TK_CONST_FUNC                     155\n#define TK_UMINUS                         156\n#define TK_UPLUS                          157\n\n/************** End of parse.h ***********************************************/\n/************** Continuing where we left off in sqliteInt.h ******************/\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <assert.h>\n#include <stddef.h>\n\n/*\n** If compiling for a processor that lacks floating point support,\n** substitute integer for floating-point\n*/\n#ifdef SQLITE_OMIT_FLOATING_POINT\n# define double sqlite_int64\n# define float sqlite_int64\n# define LONGDOUBLE_TYPE sqlite_int64\n# ifndef SQLITE_BIG_DBL\n#   define SQLITE_BIG_DBL (((sqlite3_int64)1)<<50)\n# endif\n# define SQLITE_OMIT_DATETIME_FUNCS 1\n# define SQLITE_OMIT_TRACE 1\n# undef SQLITE_MIXED_ENDIAN_64BIT_FLOAT\n# undef SQLITE_HAVE_ISNAN\n#endif\n#ifndef SQLITE_BIG_DBL\n# define SQLITE_BIG_DBL (1e99)\n#endif\n\n/*\n** OMIT_TEMPDB is set to 1 if SQLITE_OMIT_TEMPDB is defined, or 0\n** afterward. Having this macro allows us to cause the C compiler \n** to omit code used by TEMP tables without messy #ifndef statements.\n*/\n#ifdef SQLITE_OMIT_TEMPDB\n#define OMIT_TEMPDB 1\n#else\n#define OMIT_TEMPDB 0\n#endif\n\n/*\n** The \"file format\" number is an integer that is incremented whenever\n** the VDBE-level file format changes.  The following macros define the\n** the default file format for new databases and the maximum file format\n** that the library can read.\n*/\n#define SQLITE_MAX_FILE_FORMAT 4\n#ifndef SQLITE_DEFAULT_FILE_FORMAT\n# define SQLITE_DEFAULT_FILE_FORMAT 1\n#endif\n\n/*\n** Determine whether triggers are recursive by default.  This can be\n** changed at run-time using a pragma.\n*/\n#ifndef SQLITE_DEFAULT_RECURSIVE_TRIGGERS\n# define SQLITE_DEFAULT_RECURSIVE_TRIGGERS 0\n#endif\n\n/*\n** Provide a default value for SQLITE_TEMP_STORE in case it is not specified\n** on the command-line\n*/\n#ifndef SQLITE_TEMP_STORE\n# define SQLITE_TEMP_STORE 1\n#endif\n\n/*\n** GCC does not define the offsetof() macro so we'll have to do it\n** ourselves.\n*/\n#ifndef offsetof\n#define offsetof(STRUCTURE,FIELD) ((int)((char*)&((STRUCTURE*)0)->FIELD))\n#endif\n\n/*\n** Check to see if this machine uses EBCDIC.  (Yes, believe it or\n** not, there are still machines out there that use EBCDIC.)\n*/\n#if 'A' == '\\301'\n# define SQLITE_EBCDIC 1\n#else\n# define SQLITE_ASCII 1\n#endif\n\n/*\n** Integers of known sizes.  These typedefs might change for architectures\n** where the sizes very.  Preprocessor macros are available so that the\n** types can be conveniently redefined at compile-type.  Like this:\n**\n**         cc '-DUINTPTR_TYPE=long long int' ...\n*/\n#ifndef UINT32_TYPE\n# ifdef HAVE_UINT32_T\n#  define UINT32_TYPE uint32_t\n# else\n#  define UINT32_TYPE unsigned int\n# endif\n#endif\n#ifndef UINT16_TYPE\n# ifdef HAVE_UINT16_T\n#  define UINT16_TYPE uint16_t\n# else\n#  define UINT16_TYPE unsigned short int\n# endif\n#endif\n#ifndef INT16_TYPE\n# ifdef HAVE_INT16_T\n#  define INT16_TYPE int16_t\n# else\n#  define INT16_TYPE short int\n# endif\n#endif\n#ifndef UINT8_TYPE\n# ifdef HAVE_UINT8_T\n#  define UINT8_TYPE uint8_t\n# else\n#  define UINT8_TYPE unsigned char\n# endif\n#endif\n#ifndef INT8_TYPE\n# ifdef HAVE_INT8_T\n#  define INT8_TYPE int8_t\n# else\n#  define INT8_TYPE signed char\n# endif\n#endif\n#ifndef LONGDOUBLE_TYPE\n# define LONGDOUBLE_TYPE long double\n#endif\ntypedef sqlite_int64 i64;          /* 8-byte signed integer */\ntypedef sqlite_uint64 u64;         /* 8-byte unsigned integer */\ntypedef UINT32_TYPE u32;           /* 4-byte unsigned integer */\ntypedef UINT16_TYPE u16;           /* 2-byte unsigned integer */\ntypedef INT16_TYPE i16;            /* 2-byte signed integer */\ntypedef UINT8_TYPE u8;             /* 1-byte unsigned integer */\ntypedef INT8_TYPE i8;              /* 1-byte signed integer */\n\n/*\n** SQLITE_MAX_U32 is a u64 constant that is the maximum u64 value\n** that can be stored in a u32 without loss of data.  The value\n** is 0x00000000ffffffff.  But because of quirks of some compilers, we\n** have to specify the value in the less intuitive manner shown:\n*/\n#define SQLITE_MAX_U32  ((((u64)1)<<32)-1)\n\n/*\n** Macros to determine whether the machine is big or little endian,\n** evaluated at runtime.\n*/\n#ifdef SQLITE_AMALGAMATION\nSQLITE_PRIVATE const int sqlite3one = 1;\n#else\nSQLITE_PRIVATE const int sqlite3one;\n#endif\n#if defined(i386) || defined(__i386__) || defined(_M_IX86)\\\n                             || defined(__x86_64) || defined(__x86_64__)\n# define SQLITE_BIGENDIAN    0\n# define SQLITE_LITTLEENDIAN 1\n# define SQLITE_UTF16NATIVE  SQLITE_UTF16LE\n#else\n# define SQLITE_BIGENDIAN    (*(char *)(&sqlite3one)==0)\n# define SQLITE_LITTLEENDIAN (*(char *)(&sqlite3one)==1)\n# define SQLITE_UTF16NATIVE (SQLITE_BIGENDIAN?SQLITE_UTF16BE:SQLITE_UTF16LE)\n#endif\n\n/*\n** Constants for the largest and smallest possible 64-bit signed integers.\n** These macros are designed to work correctly on both 32-bit and 64-bit\n** compilers.\n*/\n#define LARGEST_INT64  (0xffffffff|(((i64)0x7fffffff)<<32))\n#define SMALLEST_INT64 (((i64)-1) - LARGEST_INT64)\n\n/* \n** Round up a number to the next larger multiple of 8.  This is used\n** to force 8-byte alignment on 64-bit architectures.\n*/\n#define ROUND8(x)     (((x)+7)&~7)\n\n/*\n** Round down to the nearest multiple of 8\n*/\n#define ROUNDDOWN8(x) ((x)&~7)\n\n/*\n** Assert that the pointer X is aligned to an 8-byte boundary.  This\n** macro is used only within assert() to verify that the code gets\n** all alignment restrictions correct.\n**\n** Except, if SQLITE_4_BYTE_ALIGNED_MALLOC is defined, then the\n** underlying malloc() implemention might return us 4-byte aligned\n** pointers.  In that case, only verify 4-byte alignment.\n*/\n#ifdef SQLITE_4_BYTE_ALIGNED_MALLOC\n# define EIGHT_BYTE_ALIGNMENT(X)   ((((char*)(X) - (char*)0)&3)==0)\n#else\n# define EIGHT_BYTE_ALIGNMENT(X)   ((((char*)(X) - (char*)0)&7)==0)\n#endif\n\n\n/*\n** An instance of the following structure is used to store the busy-handler\n** callback for a given sqlite handle. \n**\n** The sqlite.busyHandler member of the sqlite struct contains the busy\n** callback for the database handle. Each pager opened via the sqlite\n** handle is passed a pointer to sqlite.busyHandler. The busy-handler\n** callback is currently invoked only from within pager.c.\n*/\ntypedef struct BusyHandler BusyHandler;\nstruct BusyHandler {\n  int (*xFunc)(void *,int);  /* The busy callback */\n  void *pArg;                /* First arg to busy callback */\n  int nBusy;                 /* Incremented with each busy call */\n};\n\n/*\n** Name of the master database table.  The master database table\n** is a special table that holds the names and attributes of all\n** user tables and indices.\n*/\n#define MASTER_NAME       \"sqlite_master\"\n#define TEMP_MASTER_NAME  \"sqlite_temp_master\"\n\n/*\n** The root-page of the master database table.\n*/\n#define MASTER_ROOT       1\n\n/*\n** The name of the schema table.\n*/\n#define SCHEMA_TABLE(x)  ((!OMIT_TEMPDB)&&(x==1)?TEMP_MASTER_NAME:MASTER_NAME)\n\n/*\n** A convenience macro that returns the number of elements in\n** an array.\n*/\n#define ArraySize(X)    ((int)(sizeof(X)/sizeof(X[0])))\n\n/*\n** The following value as a destructor means to use sqlite3DbFree().\n** This is an internal extension to SQLITE_STATIC and SQLITE_TRANSIENT.\n*/\n#define SQLITE_DYNAMIC   ((sqlite3_destructor_type)sqlite3DbFree)\n\n/*\n** When SQLITE_OMIT_WSD is defined, it means that the target platform does\n** not support Writable Static Data (WSD) such as global and static variables.\n** All variables must either be on the stack or dynamically allocated from\n** the heap.  When WSD is unsupported, the variable declarations scattered\n** throughout the SQLite code must become constants instead.  The SQLITE_WSD\n** macro is used for this purpose.  And instead of referencing the variable\n** directly, we use its constant as a key to lookup the run-time allocated\n** buffer that holds real variable.  The constant is also the initializer\n** for the run-time allocated buffer.\n**\n** In the usual case where WSD is supported, the SQLITE_WSD and GLOBAL\n** macros become no-ops and have zero performance impact.\n*/\n#ifdef SQLITE_OMIT_WSD\n  #define SQLITE_WSD const\n  #define GLOBAL(t,v) (*(t*)sqlite3_wsd_find((void*)&(v), sizeof(v)))\n  #define sqlite3GlobalConfig GLOBAL(struct Sqlite3Config, sqlite3Config)\nSQLITE_API   int sqlite3_wsd_init(int N, int J);\nSQLITE_API   void *sqlite3_wsd_find(void *K, int L);\n#else\n  #define SQLITE_WSD \n  #define GLOBAL(t,v) v\n  #define sqlite3GlobalConfig sqlite3Config\n#endif\n\n/*\n** The following macros are used to suppress compiler warnings and to\n** make it clear to human readers when a function parameter is deliberately \n** left unused within the body of a function. This usually happens when\n** a function is called via a function pointer. For example the \n** implementation of an SQL aggregate step callback may not use the\n** parameter indicating the number of arguments passed to the aggregate,\n** if it knows that this is enforced elsewhere.\n**\n** When a function parameter is not used at all within the body of a function,\n** it is generally named \"NotUsed\" or \"NotUsed2\" to make things even clearer.\n** However, these macros may also be used to suppress warnings related to\n** parameters that may or may not be used depending on compilation options.\n** For example those parameters only used in assert() statements. In these\n** cases the parameters are named as per the usual conventions.\n*/\n#define UNUSED_PARAMETER(x) (void)(x)\n#define UNUSED_PARAMETER2(x,y) UNUSED_PARAMETER(x),UNUSED_PARAMETER(y)\n\n/*\n** Forward references to structures\n*/\ntypedef struct AggInfo AggInfo;\ntypedef struct AuthContext AuthContext;\ntypedef struct AutoincInfo AutoincInfo;\ntypedef struct Bitvec Bitvec;\ntypedef struct CollSeq CollSeq;\ntypedef struct Column Column;\ntypedef struct Db Db;\ntypedef struct Schema Schema;\ntypedef struct Expr Expr;\ntypedef struct ExprList ExprList;\ntypedef struct ExprSpan ExprSpan;\ntypedef struct FKey FKey;\ntypedef struct FuncDestructor FuncDestructor;\ntypedef struct FuncDef FuncDef;\ntypedef struct FuncDefHash FuncDefHash;\ntypedef struct IdList IdList;\ntypedef struct Index Index;\ntypedef struct IndexSample IndexSample;\ntypedef struct KeyClass KeyClass;\ntypedef struct KeyInfo KeyInfo;\ntypedef struct Lookaside Lookaside;\ntypedef struct LookasideSlot LookasideSlot;\ntypedef struct Module Module;\ntypedef struct NameContext NameContext;\ntypedef struct Parse Parse;\ntypedef struct RowSet RowSet;\ntypedef struct Savepoint Savepoint;\ntypedef struct Select Select;\ntypedef struct SrcList SrcList;\ntypedef struct StrAccum StrAccum;\ntypedef struct Table Table;\ntypedef struct TableLock TableLock;\ntypedef struct Token Token;\ntypedef struct Trigger Trigger;\ntypedef struct TriggerPrg TriggerPrg;\ntypedef struct TriggerStep TriggerStep;\ntypedef struct UnpackedRecord UnpackedRecord;\ntypedef struct VTable VTable;\ntypedef struct Walker Walker;\ntypedef struct WherePlan WherePlan;\ntypedef struct WhereInfo WhereInfo;\ntypedef struct WhereLevel WhereLevel;\n\n/*\n** Defer sourcing vdbe.h and btree.h until after the \"u8\" and \n** \"BusyHandler\" typedefs. vdbe.h also requires a few of the opaque\n** pointer types (i.e. FuncDef) defined above.\n*/\n/************** Include btree.h in the middle of sqliteInt.h *****************/\n/************** Begin file btree.h *******************************************/\n/*\n** 2001 September 15\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This header file defines the interface that the sqlite B-Tree file\n** subsystem.  See comments in the source code for a detailed description\n** of what each interface routine does.\n*/\n#ifndef _BTREE_H_\n#define _BTREE_H_\n\n/* TODO: This definition is just included so other modules compile. It\n** needs to be revisited.\n*/\n#define SQLITE_N_BTREE_META 10\n\n/*\n** If defined as non-zero, auto-vacuum is enabled by default. Otherwise\n** it must be turned on for each database using \"PRAGMA auto_vacuum = 1\".\n*/\n#ifndef SQLITE_DEFAULT_AUTOVACUUM\n  #define SQLITE_DEFAULT_AUTOVACUUM 0\n#endif\n\n#define BTREE_AUTOVACUUM_NONE 0        /* Do not do auto-vacuum */\n#define BTREE_AUTOVACUUM_FULL 1        /* Do full auto-vacuum */\n#define BTREE_AUTOVACUUM_INCR 2        /* Incremental vacuum */\n\n/*\n** Forward declarations of structure\n*/\ntypedef struct BtCursor BtCursor;\ntypedef struct BtShared BtShared;\ntypedef struct BtreeMutexArray BtreeMutexArray;\n\n/*\n** This structure records all of the Btrees that need to hold\n** a mutex before we enter sqlite3VdbeExec().  The Btrees are\n** are placed in aBtree[] in order of aBtree[]->pBt.  That way,\n** we can always lock and unlock them all quickly.\n*/\nstruct BtreeMutexArray {\n  int nMutex;\n  Btree *aBtree[SQLITE_MAX_ATTACHED+1];\n};\n\n\nSQLITE_PRIVATE int sqlite3BtreeOpen(\n  const char *zFilename,   /* Name of database file to open */\n  sqlite3 *db,             /* Associated database connection */\n  Btree **ppBtree,         /* Return open Btree* here */\n  int flags,               /* Flags */\n  int vfsFlags             /* Flags passed through to VFS open */\n);\n\n/* The flags parameter to sqlite3BtreeOpen can be the bitwise or of the\n** following values.\n**\n** NOTE:  These values must match the corresponding PAGER_ values in\n** pager.h.\n*/\n#define BTREE_OMIT_JOURNAL  1  /* Do not create or use a rollback journal */\n#define BTREE_NO_READLOCK   2  /* Omit readlocks on readonly files */\n#define BTREE_MEMORY        4  /* This is an in-memory DB */\n#define BTREE_SINGLE        8  /* The file contains at most 1 b-tree */\n#define BTREE_UNORDERED    16  /* Use of a hash implementation is OK */\n\nSQLITE_PRIVATE int sqlite3BtreeClose(Btree*);\nSQLITE_PRIVATE int sqlite3BtreeSetCacheSize(Btree*,int);\nSQLITE_PRIVATE int sqlite3BtreeSetSafetyLevel(Btree*,int,int,int);\nSQLITE_PRIVATE int sqlite3BtreeSyncDisabled(Btree*);\nSQLITE_PRIVATE int sqlite3BtreeSetPageSize(Btree *p, int nPagesize, int nReserve, int eFix);\nSQLITE_PRIVATE int sqlite3BtreeGetPageSize(Btree*);\nSQLITE_PRIVATE int sqlite3BtreeMaxPageCount(Btree*,int);\nSQLITE_PRIVATE u32 sqlite3BtreeLastPage(Btree*);\nSQLITE_PRIVATE int sqlite3BtreeSecureDelete(Btree*,int);\nSQLITE_PRIVATE int sqlite3BtreeGetReserve(Btree*);\nSQLITE_PRIVATE int sqlite3BtreeSetAutoVacuum(Btree *, int);\nSQLITE_PRIVATE int sqlite3BtreeGetAutoVacuum(Btree *);\nSQLITE_PRIVATE int sqlite3BtreeBeginTrans(Btree*,int);\nSQLITE_PRIVATE int sqlite3BtreeCommitPhaseOne(Btree*, const char *zMaster);\nSQLITE_PRIVATE int sqlite3BtreeCommitPhaseTwo(Btree*);\nSQLITE_PRIVATE int sqlite3BtreeCommit(Btree*);\nSQLITE_PRIVATE int sqlite3BtreeRollback(Btree*);\nSQLITE_PRIVATE int sqlite3BtreeBeginStmt(Btree*,int);\nSQLITE_PRIVATE int sqlite3BtreeCreateTable(Btree*, int*, int flags);\nSQLITE_PRIVATE int sqlite3BtreeIsInTrans(Btree*);\nSQLITE_PRIVATE int sqlite3BtreeIsInReadTrans(Btree*);\nSQLITE_PRIVATE int sqlite3BtreeIsInBackup(Btree*);\nSQLITE_PRIVATE void *sqlite3BtreeSchema(Btree *, int, void(*)(void *));\nSQLITE_PRIVATE int sqlite3BtreeSchemaLocked(Btree *pBtree);\nSQLITE_PRIVATE int sqlite3BtreeLockTable(Btree *pBtree, int iTab, u8 isWriteLock);\nSQLITE_PRIVATE int sqlite3BtreeSavepoint(Btree *, int, int);\n\nSQLITE_PRIVATE const char *sqlite3BtreeGetFilename(Btree *);\nSQLITE_PRIVATE const char *sqlite3BtreeGetJournalname(Btree *);\nSQLITE_PRIVATE int sqlite3BtreeCopyFile(Btree *, Btree *);\n\nSQLITE_PRIVATE int sqlite3BtreeIncrVacuum(Btree *);\n\n/* The flags parameter to sqlite3BtreeCreateTable can be the bitwise OR\n** of the flags shown below.\n**\n** Every SQLite table must have either BTREE_INTKEY or BTREE_BLOBKEY set.\n** With BTREE_INTKEY, the table key is a 64-bit integer and arbitrary data\n** is stored in the leaves.  (BTREE_INTKEY is used for SQL tables.)  With\n** BTREE_BLOBKEY, the key is an arbitrary BLOB and no content is stored\n** anywhere - the key is the content.  (BTREE_BLOBKEY is used for SQL\n** indices.)\n*/\n#define BTREE_INTKEY     1    /* Table has only 64-bit signed integer keys */\n#define BTREE_BLOBKEY    2    /* Table has keys only - no data */\n\nSQLITE_PRIVATE int sqlite3BtreeDropTable(Btree*, int, int*);\nSQLITE_PRIVATE int sqlite3BtreeClearTable(Btree*, int, int*);\nSQLITE_PRIVATE void sqlite3BtreeTripAllCursors(Btree*, int);\n\nSQLITE_PRIVATE void sqlite3BtreeGetMeta(Btree *pBtree, int idx, u32 *pValue);\nSQLITE_PRIVATE int sqlite3BtreeUpdateMeta(Btree*, int idx, u32 value);\n\n/*\n** The second parameter to sqlite3BtreeGetMeta or sqlite3BtreeUpdateMeta\n** should be one of the following values. The integer values are assigned \n** to constants so that the offset of the corresponding field in an\n** SQLite database header may be found using the following formula:\n**\n**   offset = 36 + (idx * 4)\n**\n** For example, the free-page-count field is located at byte offset 36 of\n** the database file header. The incr-vacuum-flag field is located at\n** byte offset 64 (== 36+4*7).\n*/\n#define BTREE_FREE_PAGE_COUNT     0\n#define BTREE_SCHEMA_VERSION      1\n#define BTREE_FILE_FORMAT         2\n#define BTREE_DEFAULT_CACHE_SIZE  3\n#define BTREE_LARGEST_ROOT_PAGE   4\n#define BTREE_TEXT_ENCODING       5\n#define BTREE_USER_VERSION        6\n#define BTREE_INCR_VACUUM         7\n\nSQLITE_PRIVATE int sqlite3BtreeCursor(\n  Btree*,                              /* BTree containing table to open */\n  int iTable,                          /* Index of root page */\n  int wrFlag,                          /* 1 for writing.  0 for read-only */\n  struct KeyInfo*,                     /* First argument to compare function */\n  BtCursor *pCursor                    /* Space to write cursor structure */\n);\nSQLITE_PRIVATE int sqlite3BtreeCursorSize(void);\nSQLITE_PRIVATE void sqlite3BtreeCursorZero(BtCursor*);\n\nSQLITE_PRIVATE int sqlite3BtreeCloseCursor(BtCursor*);\nSQLITE_PRIVATE int sqlite3BtreeMovetoUnpacked(\n  BtCursor*,\n  UnpackedRecord *pUnKey,\n  i64 intKey,\n  int bias,\n  int *pRes\n);\nSQLITE_PRIVATE int sqlite3BtreeCursorHasMoved(BtCursor*, int*);\nSQLITE_PRIVATE int sqlite3BtreeDelete(BtCursor*);\nSQLITE_PRIVATE int sqlite3BtreeInsert(BtCursor*, const void *pKey, i64 nKey,\n                                  const void *pData, int nData,\n                                  int nZero, int bias, int seekResult);\nSQLITE_PRIVATE int sqlite3BtreeFirst(BtCursor*, int *pRes);\nSQLITE_PRIVATE int sqlite3BtreeLast(BtCursor*, int *pRes);\nSQLITE_PRIVATE int sqlite3BtreeNext(BtCursor*, int *pRes);\nSQLITE_PRIVATE int sqlite3BtreeEof(BtCursor*);\nSQLITE_PRIVATE int sqlite3BtreePrevious(BtCursor*, int *pRes);\nSQLITE_PRIVATE int sqlite3BtreeKeySize(BtCursor*, i64 *pSize);\nSQLITE_PRIVATE int sqlite3BtreeKey(BtCursor*, u32 offset, u32 amt, void*);\nSQLITE_PRIVATE const void *sqlite3BtreeKeyFetch(BtCursor*, int *pAmt);\nSQLITE_PRIVATE const void *sqlite3BtreeDataFetch(BtCursor*, int *pAmt);\nSQLITE_PRIVATE int sqlite3BtreeDataSize(BtCursor*, u32 *pSize);\nSQLITE_PRIVATE int sqlite3BtreeData(BtCursor*, u32 offset, u32 amt, void*);\nSQLITE_PRIVATE void sqlite3BtreeSetCachedRowid(BtCursor*, sqlite3_int64);\nSQLITE_PRIVATE sqlite3_int64 sqlite3BtreeGetCachedRowid(BtCursor*);\n\nSQLITE_PRIVATE char *sqlite3BtreeIntegrityCheck(Btree*, int *aRoot, int nRoot, int, int*, int);\nSQLITE_PRIVATE struct Pager *sqlite3BtreePager(Btree*);\n\nSQLITE_PRIVATE int sqlite3BtreePutData(BtCursor*, u32 offset, u32 amt, void*);\nSQLITE_PRIVATE void sqlite3BtreeCacheOverflow(BtCursor *);\nSQLITE_PRIVATE void sqlite3BtreeClearCursor(BtCursor *);\n\nSQLITE_PRIVATE int sqlite3BtreeSetVersion(Btree *pBt, int iVersion);\n\n#ifndef NDEBUG\nSQLITE_PRIVATE int sqlite3BtreeCursorIsValid(BtCursor*);\n#endif\n\n#ifndef SQLITE_OMIT_BTREECOUNT\nSQLITE_PRIVATE int sqlite3BtreeCount(BtCursor *, i64 *);\n#endif\n\n#ifdef SQLITE_TEST\nSQLITE_PRIVATE int sqlite3BtreeCursorInfo(BtCursor*, int*, int);\nSQLITE_PRIVATE void sqlite3BtreeCursorList(Btree*);\n#endif\n\n#ifndef SQLITE_OMIT_WAL\nSQLITE_PRIVATE   int sqlite3BtreeCheckpoint(Btree*, int, int *, int *);\n#endif\n\n/*\n** If we are not using shared cache, then there is no need to\n** use mutexes to access the BtShared structures.  So make the\n** Enter and Leave procedures no-ops.\n*/\n#ifndef SQLITE_OMIT_SHARED_CACHE\nSQLITE_PRIVATE   void sqlite3BtreeEnter(Btree*);\nSQLITE_PRIVATE   void sqlite3BtreeEnterAll(sqlite3*);\n#else\n# define sqlite3BtreeEnter(X) \n# define sqlite3BtreeEnterAll(X)\n#endif\n\n#if !defined(SQLITE_OMIT_SHARED_CACHE) && SQLITE_THREADSAFE\nSQLITE_PRIVATE   void sqlite3BtreeLeave(Btree*);\nSQLITE_PRIVATE   void sqlite3BtreeEnterCursor(BtCursor*);\nSQLITE_PRIVATE   void sqlite3BtreeLeaveCursor(BtCursor*);\nSQLITE_PRIVATE   void sqlite3BtreeLeaveAll(sqlite3*);\nSQLITE_PRIVATE   void sqlite3BtreeMutexArrayEnter(BtreeMutexArray*);\nSQLITE_PRIVATE   void sqlite3BtreeMutexArrayLeave(BtreeMutexArray*);\nSQLITE_PRIVATE   void sqlite3BtreeMutexArrayInsert(BtreeMutexArray*, Btree*);\n#ifndef NDEBUG\n  /* These routines are used inside assert() statements only. */\nSQLITE_PRIVATE   int sqlite3BtreeHoldsMutex(Btree*);\nSQLITE_PRIVATE   int sqlite3BtreeHoldsAllMutexes(sqlite3*);\n#endif\n#else\n\n# define sqlite3BtreeLeave(X)\n# define sqlite3BtreeEnterCursor(X)\n# define sqlite3BtreeLeaveCursor(X)\n# define sqlite3BtreeLeaveAll(X)\n# define sqlite3BtreeMutexArrayEnter(X)\n# define sqlite3BtreeMutexArrayLeave(X)\n# define sqlite3BtreeMutexArrayInsert(X,Y)\n\n# define sqlite3BtreeHoldsMutex(X) 1\n# define sqlite3BtreeHoldsAllMutexes(X) 1\n#endif\n\n\n#endif /* _BTREE_H_ */\n\n/************** End of btree.h ***********************************************/\n/************** Continuing where we left off in sqliteInt.h ******************/\n/************** Include vdbe.h in the middle of sqliteInt.h ******************/\n/************** Begin file vdbe.h ********************************************/\n/*\n** 2001 September 15\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** Header file for the Virtual DataBase Engine (VDBE)\n**\n** This header defines the interface to the virtual database engine\n** or VDBE.  The VDBE implements an abstract machine that runs a\n** simple program to access and modify the underlying database.\n*/\n#ifndef _SQLITE_VDBE_H_\n#define _SQLITE_VDBE_H_\n\n/*\n** A single VDBE is an opaque structure named \"Vdbe\".  Only routines\n** in the source file sqliteVdbe.c are allowed to see the insides\n** of this structure.\n*/\ntypedef struct Vdbe Vdbe;\n\n/*\n** The names of the following types declared in vdbeInt.h are required\n** for the VdbeOp definition.\n*/\ntypedef struct VdbeFunc VdbeFunc;\ntypedef struct Mem Mem;\ntypedef struct SubProgram SubProgram;\n\n/*\n** A single instruction of the virtual machine has an opcode\n** and as many as three operands.  The instruction is recorded\n** as an instance of the following structure:\n*/\nstruct VdbeOp {\n  u8 opcode;          /* What operation to perform */\n  signed char p4type; /* One of the P4_xxx constants for p4 */\n  u8 opflags;         /* Mask of the OPFLG_* flags in opcodes.h */\n  u8 p5;              /* Fifth parameter is an unsigned character */\n  int p1;             /* First operand */\n  int p2;             /* Second parameter (often the jump destination) */\n  int p3;             /* The third parameter */\n  union {             /* fourth parameter */\n    int i;                 /* Integer value if p4type==P4_INT32 */\n    void *p;               /* Generic pointer */\n    char *z;               /* Pointer to data for string (char array) types */\n    i64 *pI64;             /* Used when p4type is P4_INT64 */\n    double *pReal;         /* Used when p4type is P4_REAL */\n    FuncDef *pFunc;        /* Used when p4type is P4_FUNCDEF */\n    VdbeFunc *pVdbeFunc;   /* Used when p4type is P4_VDBEFUNC */\n    CollSeq *pColl;        /* Used when p4type is P4_COLLSEQ */\n    Mem *pMem;             /* Used when p4type is P4_MEM */\n    VTable *pVtab;         /* Used when p4type is P4_VTAB */\n    KeyInfo *pKeyInfo;     /* Used when p4type is P4_KEYINFO */\n    int *ai;               /* Used when p4type is P4_INTARRAY */\n    SubProgram *pProgram;  /* Used when p4type is P4_SUBPROGRAM */\n  } p4;\n#ifdef SQLITE_DEBUG\n  char *zComment;          /* Comment to improve readability */\n#endif\n#ifdef VDBE_PROFILE\n  int cnt;                 /* Number of times this instruction was executed */\n  u64 cycles;              /* Total time spent executing this instruction */\n#endif\n};\ntypedef struct VdbeOp VdbeOp;\n\n\n/*\n** A sub-routine used to implement a trigger program.\n*/\nstruct SubProgram {\n  VdbeOp *aOp;                  /* Array of opcodes for sub-program */\n  int nOp;                      /* Elements in aOp[] */\n  int nMem;                     /* Number of memory cells required */\n  int nCsr;                     /* Number of cursors required */\n  void *token;                  /* id that may be used to recursive triggers */\n  SubProgram *pNext;            /* Next sub-program already visited */\n};\n\n/*\n** A smaller version of VdbeOp used for the VdbeAddOpList() function because\n** it takes up less space.\n*/\nstruct VdbeOpList {\n  u8 opcode;          /* What operation to perform */\n  signed char p1;     /* First operand */\n  signed char p2;     /* Second parameter (often the jump destination) */\n  signed char p3;     /* Third parameter */\n};\ntypedef struct VdbeOpList VdbeOpList;\n\n/*\n** Allowed values of VdbeOp.p4type\n*/\n#define P4_NOTUSED    0   /* The P4 parameter is not used */\n#define P4_DYNAMIC  (-1)  /* Pointer to a string obtained from sqliteMalloc() */\n#define P4_STATIC   (-2)  /* Pointer to a static string */\n#define P4_COLLSEQ  (-4)  /* P4 is a pointer to a CollSeq structure */\n#define P4_FUNCDEF  (-5)  /* P4 is a pointer to a FuncDef structure */\n#define P4_KEYINFO  (-6)  /* P4 is a pointer to a KeyInfo structure */\n#define P4_VDBEFUNC (-7)  /* P4 is a pointer to a VdbeFunc structure */\n#define P4_MEM      (-8)  /* P4 is a pointer to a Mem*    structure */\n#define P4_TRANSIENT (-9) /* P4 is a pointer to a transient string */\n#define P4_VTAB     (-10) /* P4 is a pointer to an sqlite3_vtab structure */\n#define P4_MPRINTF  (-11) /* P4 is a string obtained from sqlite3_mprintf() */\n#define P4_REAL     (-12) /* P4 is a 64-bit floating point value */\n#define P4_INT64    (-13) /* P4 is a 64-bit signed integer */\n#define P4_INT32    (-14) /* P4 is a 32-bit signed integer */\n#define P4_INTARRAY (-15) /* P4 is a vector of 32-bit integers */\n#define P4_SUBPROGRAM  (-18) /* P4 is a pointer to a SubProgram structure */\n\n/* When adding a P4 argument using P4_KEYINFO, a copy of the KeyInfo structure\n** is made.  That copy is freed when the Vdbe is finalized.  But if the\n** argument is P4_KEYINFO_HANDOFF, the passed in pointer is used.  It still\n** gets freed when the Vdbe is finalized so it still should be obtained\n** from a single sqliteMalloc().  But no copy is made and the calling\n** function should *not* try to free the KeyInfo.\n*/\n#define P4_KEYINFO_HANDOFF (-16)\n#define P4_KEYINFO_STATIC  (-17)\n\n/*\n** The Vdbe.aColName array contains 5n Mem structures, where n is the \n** number of columns of data returned by the statement.\n*/\n#define COLNAME_NAME     0\n#define COLNAME_DECLTYPE 1\n#define COLNAME_DATABASE 2\n#define COLNAME_TABLE    3\n#define COLNAME_COLUMN   4\n#ifdef SQLITE_ENABLE_COLUMN_METADATA\n# define COLNAME_N        5      /* Number of COLNAME_xxx symbols */\n#else\n# ifdef SQLITE_OMIT_DECLTYPE\n#   define COLNAME_N      1      /* Store only the name */\n# else\n#   define COLNAME_N      2      /* Store the name and decltype */\n# endif\n#endif\n\n/*\n** The following macro converts a relative address in the p2 field\n** of a VdbeOp structure into a negative number so that \n** sqlite3VdbeAddOpList() knows that the address is relative.  Calling\n** the macro again restores the address.\n*/\n#define ADDR(X)  (-1-(X))\n\n/*\n** The makefile scans the vdbe.c source file and creates the \"opcodes.h\"\n** header file that defines a number for each opcode used by the VDBE.\n*/\n/************** Include opcodes.h in the middle of vdbe.h ********************/\n/************** Begin file opcodes.h *****************************************/\n/* Automatically generated.  Do not edit */\n/* See the mkopcodeh.awk script for details */\n#define OP_Goto                                 1\n#define OP_Gosub                                2\n#define OP_Return                               3\n#define OP_Yield                                4\n#define OP_HaltIfNull                           5\n#define OP_Halt                                 6\n#define OP_Integer                              7\n#define OP_Int64                                8\n#define OP_Real                               130   /* same as TK_FLOAT    */\n#define OP_String8                             94   /* same as TK_STRING   */\n#define OP_String                               9\n#define OP_Null                                10\n#define OP_Blob                                11\n#define OP_Variable                            12\n#define OP_Move                                13\n#define OP_Copy                                14\n#define OP_SCopy                               15\n#define OP_ResultRow                           16\n#define OP_Concat                              91   /* same as TK_CONCAT   */\n#define OP_Add                                 86   /* same as TK_PLUS     */\n#define OP_Subtract                            87   /* same as TK_MINUS    */\n#define OP_Multiply                            88   /* same as TK_STAR     */\n#define OP_Divide                              89   /* same as TK_SLASH    */\n#define OP_Remainder                           90   /* same as TK_REM      */\n#define OP_CollSeq                             17\n#define OP_Function                            18\n#define OP_BitAnd                              82   /* same as TK_BITAND   */\n#define OP_BitOr                               83   /* same as TK_BITOR    */\n#define OP_ShiftLeft                           84   /* same as TK_LSHIFT   */\n#define OP_ShiftRight                          85   /* same as TK_RSHIFT   */\n#define OP_AddImm                              20\n#define OP_MustBeInt                           21\n#define OP_RealAffinity                        22\n#define OP_ToText                             141   /* same as TK_TO_TEXT  */\n#define OP_ToBlob                             142   /* same as TK_TO_BLOB  */\n#define OP_ToNumeric                          143   /* same as TK_TO_NUMERIC*/\n#define OP_ToInt                              144   /* same as TK_TO_INT   */\n#define OP_ToReal                             145   /* same as TK_TO_REAL  */\n#define OP_Eq                                  76   /* same as TK_EQ       */\n#define OP_Ne                                  75   /* same as TK_NE       */\n#define OP_Lt                                  79   /* same as TK_LT       */\n#define OP_Le                                  78   /* same as TK_LE       */\n#define OP_Gt                                  77   /* same as TK_GT       */\n#define OP_Ge                                  80   /* same as TK_GE       */\n#define OP_Permutation                         23\n#define OP_Compare                             24\n#define OP_Jump                                25\n#define OP_And                                 69   /* same as TK_AND      */\n#define OP_Or                                  68   /* same as TK_OR       */\n#define OP_Not                                 19   /* same as TK_NOT      */\n#define OP_BitNot                              93   /* same as TK_BITNOT   */\n#define OP_If                                  26\n#define OP_IfNot                               27\n#define OP_IsNull                              73   /* same as TK_ISNULL   */\n#define OP_NotNull                             74   /* same as TK_NOTNULL  */\n#define OP_Column                              28\n#define OP_Affinity                            29\n#define OP_MakeRecord                          30\n#define OP_Count                               31\n#define OP_Savepoint                           32\n#define OP_AutoCommit                          33\n#define OP_Transaction                         34\n#define OP_ReadCookie                          35\n#define OP_SetCookie                           36\n#define OP_VerifyCookie                        37\n#define OP_OpenRead                            38\n#define OP_OpenWrite                           39\n#define OP_OpenAutoindex                       40\n#define OP_OpenEphemeral                       41\n#define OP_OpenPseudo                          42\n#define OP_Close                               43\n#define OP_SeekLt                              44\n#define OP_SeekLe                              45\n#define OP_SeekGe                              46\n#define OP_SeekGt                              47\n#define OP_Seek                                48\n#define OP_NotFound                            49\n#define OP_Found                               50\n#define OP_IsUnique                            51\n#define OP_NotExists                           52\n#define OP_Sequence                            53\n#define OP_NewRowid                            54\n#define OP_Insert                              55\n#define OP_InsertInt                           56\n#define OP_Delete                              57\n#define OP_ResetCount                          58\n#define OP_RowKey                              59\n#define OP_RowData                             60\n#define OP_Rowid                               61\n#define OP_NullRow                             62\n#define OP_Last                                63\n#define OP_Sort                                64\n#define OP_Rewind                              65\n#define OP_Prev                                66\n#define OP_Next                                67\n#define OP_IdxInsert                           70\n#define OP_IdxDelete                           71\n#define OP_IdxRowid                            72\n#define OP_IdxLT                               81\n#define OP_IdxGE                               92\n#define OP_Destroy                             95\n#define OP_Clear                               96\n#define OP_CreateIndex                         97\n#define OP_CreateTable                         98\n#define OP_ParseSchema                         99\n#define OP_LoadAnalysis                       100\n#define OP_DropTable                          101\n#define OP_DropIndex                          102\n#define OP_DropTrigger                        103\n#define OP_IntegrityCk                        104\n#define OP_RowSetAdd                          105\n#define OP_RowSetRead                         106\n#define OP_RowSetTest                         107\n#define OP_Program                            108\n#define OP_Param                              109\n#define OP_FkCounter                          110\n#define OP_FkIfZero                           111\n#define OP_MemMax                             112\n#define OP_IfPos                              113\n#define OP_IfNeg                              114\n#define OP_IfZero                             115\n#define OP_AggStep                            116\n#define OP_AggFinal                           117\n#define OP_Checkpoint                         118\n#define OP_JournalMode                        119\n#define OP_Vacuum                             120\n#define OP_IncrVacuum                         121\n#define OP_Expire                             122\n#define OP_TableLock                          123\n#define OP_VBegin                             124\n#define OP_VCreate                            125\n#define OP_VDestroy                           126\n#define OP_VOpen                              127\n#define OP_VFilter                            128\n#define OP_VColumn                            129\n#define OP_VNext                              131\n#define OP_VRename                            132\n#define OP_VUpdate                            133\n#define OP_Pagecount                          134\n#define OP_MaxPgcnt                           135\n#define OP_Trace                              136\n#define OP_Noop                               137\n#define OP_Explain                            138\n\n/* The following opcode values are never used */\n#define OP_NotUsed_139                        139\n#define OP_NotUsed_140                        140\n\n\n/* Properties such as \"out2\" or \"jump\" that are specified in\n** comments following the \"case\" for each opcode in the vdbe.c\n** are encoded into bitvectors as follows:\n*/\n#define OPFLG_JUMP            0x0001  /* jump:  P2 holds jmp target */\n#define OPFLG_OUT2_PRERELEASE 0x0002  /* out2-prerelease: */\n#define OPFLG_IN1             0x0004  /* in1:   P1 is an input */\n#define OPFLG_IN2             0x0008  /* in2:   P2 is an input */\n#define OPFLG_IN3             0x0010  /* in3:   P3 is an input */\n#define OPFLG_OUT2            0x0020  /* out2:  P2 is an output */\n#define OPFLG_OUT3            0x0040  /* out3:  P3 is an output */\n#define OPFLG_INITIALIZER {\\\n/*   0 */ 0x00, 0x01, 0x05, 0x04, 0x04, 0x10, 0x00, 0x02,\\\n/*   8 */ 0x02, 0x02, 0x02, 0x02, 0x02, 0x00, 0x24, 0x24,\\\n/*  16 */ 0x00, 0x00, 0x00, 0x24, 0x04, 0x05, 0x04, 0x00,\\\n/*  24 */ 0x00, 0x01, 0x05, 0x05, 0x00, 0x00, 0x00, 0x02,\\\n/*  32 */ 0x00, 0x00, 0x00, 0x02, 0x10, 0x00, 0x00, 0x00,\\\n/*  40 */ 0x00, 0x00, 0x00, 0x00, 0x11, 0x11, 0x11, 0x11,\\\n/*  48 */ 0x08, 0x11, 0x11, 0x11, 0x11, 0x02, 0x02, 0x00,\\\n/*  56 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00, 0x01,\\\n/*  64 */ 0x01, 0x01, 0x01, 0x01, 0x4c, 0x4c, 0x08, 0x00,\\\n/*  72 */ 0x02, 0x05, 0x05, 0x15, 0x15, 0x15, 0x15, 0x15,\\\n/*  80 */ 0x15, 0x01, 0x4c, 0x4c, 0x4c, 0x4c, 0x4c, 0x4c,\\\n/*  88 */ 0x4c, 0x4c, 0x4c, 0x4c, 0x01, 0x24, 0x02, 0x02,\\\n/*  96 */ 0x00, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,\\\n/* 104 */ 0x00, 0x0c, 0x45, 0x15, 0x01, 0x02, 0x00, 0x01,\\\n/* 112 */ 0x08, 0x05, 0x05, 0x05, 0x00, 0x00, 0x00, 0x02,\\\n/* 120 */ 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\\\n/* 128 */ 0x01, 0x00, 0x02, 0x01, 0x00, 0x00, 0x02, 0x02,\\\n/* 136 */ 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x04, 0x04,\\\n/* 144 */ 0x04, 0x04,}\n\n/************** End of opcodes.h *********************************************/\n/************** Continuing where we left off in vdbe.h ***********************/\n\n/*\n** Prototypes for the VDBE interface.  See comments on the implementation\n** for a description of what each of these routines does.\n*/\nSQLITE_PRIVATE Vdbe *sqlite3VdbeCreate(sqlite3*);\nSQLITE_PRIVATE int sqlite3VdbeAddOp0(Vdbe*,int);\nSQLITE_PRIVATE int sqlite3VdbeAddOp1(Vdbe*,int,int);\nSQLITE_PRIVATE int sqlite3VdbeAddOp2(Vdbe*,int,int,int);\nSQLITE_PRIVATE int sqlite3VdbeAddOp3(Vdbe*,int,int,int,int);\nSQLITE_PRIVATE int sqlite3VdbeAddOp4(Vdbe*,int,int,int,int,const char *zP4,int);\nSQLITE_PRIVATE int sqlite3VdbeAddOp4Int(Vdbe*,int,int,int,int,int);\nSQLITE_PRIVATE int sqlite3VdbeAddOpList(Vdbe*, int nOp, VdbeOpList const *aOp);\nSQLITE_PRIVATE void sqlite3VdbeChangeP1(Vdbe*, int addr, int P1);\nSQLITE_PRIVATE void sqlite3VdbeChangeP2(Vdbe*, int addr, int P2);\nSQLITE_PRIVATE void sqlite3VdbeChangeP3(Vdbe*, int addr, int P3);\nSQLITE_PRIVATE void sqlite3VdbeChangeP5(Vdbe*, u8 P5);\nSQLITE_PRIVATE void sqlite3VdbeJumpHere(Vdbe*, int addr);\nSQLITE_PRIVATE void sqlite3VdbeChangeToNoop(Vdbe*, int addr, int N);\nSQLITE_PRIVATE void sqlite3VdbeChangeP4(Vdbe*, int addr, const char *zP4, int N);\nSQLITE_PRIVATE void sqlite3VdbeUsesBtree(Vdbe*, int);\nSQLITE_PRIVATE VdbeOp *sqlite3VdbeGetOp(Vdbe*, int);\nSQLITE_PRIVATE int sqlite3VdbeMakeLabel(Vdbe*);\nSQLITE_PRIVATE void sqlite3VdbeRunOnlyOnce(Vdbe*);\nSQLITE_PRIVATE void sqlite3VdbeDelete(Vdbe*);\nSQLITE_PRIVATE void sqlite3VdbeDeleteObject(sqlite3*,Vdbe*);\nSQLITE_PRIVATE void sqlite3VdbeMakeReady(Vdbe*,int,int,int,int,int,int);\nSQLITE_PRIVATE int sqlite3VdbeFinalize(Vdbe*);\nSQLITE_PRIVATE void sqlite3VdbeResolveLabel(Vdbe*, int);\nSQLITE_PRIVATE int sqlite3VdbeCurrentAddr(Vdbe*);\n#ifdef SQLITE_DEBUG\nSQLITE_PRIVATE   int sqlite3VdbeAssertMayAbort(Vdbe *, int);\nSQLITE_PRIVATE   void sqlite3VdbeTrace(Vdbe*,FILE*);\n#endif\nSQLITE_PRIVATE void sqlite3VdbeResetStepResult(Vdbe*);\nSQLITE_PRIVATE int sqlite3VdbeReset(Vdbe*);\nSQLITE_PRIVATE void sqlite3VdbeSetNumCols(Vdbe*,int);\nSQLITE_PRIVATE int sqlite3VdbeSetColName(Vdbe*, int, int, const char *, void(*)(void*));\nSQLITE_PRIVATE void sqlite3VdbeCountChanges(Vdbe*);\nSQLITE_PRIVATE sqlite3 *sqlite3VdbeDb(Vdbe*);\nSQLITE_PRIVATE void sqlite3VdbeSetSql(Vdbe*, const char *z, int n, int);\nSQLITE_PRIVATE void sqlite3VdbeSwap(Vdbe*,Vdbe*);\nSQLITE_PRIVATE VdbeOp *sqlite3VdbeTakeOpArray(Vdbe*, int*, int*);\nSQLITE_PRIVATE sqlite3_value *sqlite3VdbeGetValue(Vdbe*, int, u8);\nSQLITE_PRIVATE void sqlite3VdbeSetVarmask(Vdbe*, int);\n#ifndef SQLITE_OMIT_TRACE\nSQLITE_PRIVATE   char *sqlite3VdbeExpandSql(Vdbe*, const char*);\n#endif\n\nSQLITE_PRIVATE UnpackedRecord *sqlite3VdbeRecordUnpack(KeyInfo*,int,const void*,char*,int);\nSQLITE_PRIVATE void sqlite3VdbeDeleteUnpackedRecord(UnpackedRecord*);\nSQLITE_PRIVATE int sqlite3VdbeRecordCompare(int,const void*,UnpackedRecord*,int,int*);\n\n#ifndef SQLITE_OMIT_TRIGGER\nSQLITE_PRIVATE void sqlite3VdbeLinkSubProgram(Vdbe *, SubProgram *);\n#endif\n\n\n#ifndef NDEBUG\nSQLITE_PRIVATE   void sqlite3VdbeComment(Vdbe*, const char*, ...);\n# define VdbeComment(X)  sqlite3VdbeComment X\nSQLITE_PRIVATE   void sqlite3VdbeNoopComment(Vdbe*, const char*, ...);\n# define VdbeNoopComment(X)  sqlite3VdbeNoopComment X\n#else\n# define VdbeComment(X)\n# define VdbeNoopComment(X)\n#endif\n\n#endif\n\n/************** End of vdbe.h ************************************************/\n/************** Continuing where we left off in sqliteInt.h ******************/\n/************** Include pager.h in the middle of sqliteInt.h *****************/\n/************** Begin file pager.h *******************************************/\n/*\n** 2001 September 15\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This header file defines the interface that the sqlite page cache\n** subsystem.  The page cache subsystem reads and writes a file a page\n** at a time and provides a journal for rollback.\n*/\n\n#ifndef _PAGER_H_\n#define _PAGER_H_\n\n/*\n** Default maximum size for persistent journal files. A negative \n** value means no limit. This value may be overridden using the \n** sqlite3PagerJournalSizeLimit() API. See also \"PRAGMA journal_size_limit\".\n*/\n#ifndef SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT\n  #define SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT -1\n#endif\n\n/*\n** Each open file is managed by a separate instance of the \"Pager\" structure.\n*/\ntypedef struct Pager Pager;\n\n/*\n** Handle type for pages.\n*/\ntypedef struct PgHdr DbPage;\n\n/*\n** Page number PAGER_MJ_PGNO is never used in an SQLite database (it is\n** reserved for working around a windows/posix incompatibility). It is\n** used in the journal to signify that the remainder of the journal file \n** is devoted to storing a master journal name - there are no more pages to\n** roll back. See comments for function writeMasterJournal() in pager.c \n** for details.\n*/\n#define PAGER_MJ_PGNO(x) ((Pgno)((PENDING_BYTE/((x)->pageSize))+1))\n\n/*\n** Allowed values for the flags parameter to sqlite3PagerOpen().\n**\n** NOTE: These values must match the corresponding BTREE_ values in btree.h.\n*/\n#define PAGER_OMIT_JOURNAL  0x0001    /* Do not use a rollback journal */\n#define PAGER_NO_READLOCK   0x0002    /* Omit readlocks on readonly files */\n#define PAGER_MEMORY        0x0004    /* In-memory database */\n\n/*\n** Valid values for the second argument to sqlite3PagerLockingMode().\n*/\n#define PAGER_LOCKINGMODE_QUERY      -1\n#define PAGER_LOCKINGMODE_NORMAL      0\n#define PAGER_LOCKINGMODE_EXCLUSIVE   1\n\n/*\n** Numeric constants that encode the journalmode.  \n*/\n#define PAGER_JOURNALMODE_QUERY     (-1)  /* Query the value of journalmode */\n#define PAGER_JOURNALMODE_DELETE      0   /* Commit by deleting journal file */\n#define PAGER_JOURNALMODE_PERSIST     1   /* Commit by zeroing journal header */\n#define PAGER_JOURNALMODE_OFF         2   /* Journal omitted.  */\n#define PAGER_JOURNALMODE_TRUNCATE    3   /* Commit by truncating journal */\n#define PAGER_JOURNALMODE_MEMORY      4   /* In-memory journal file */\n#define PAGER_JOURNALMODE_WAL         5   /* Use write-ahead logging */\n\n/*\n** The remainder of this file contains the declarations of the functions\n** that make up the Pager sub-system API. See source code comments for \n** a detailed description of each routine.\n*/\n\n/* Open and close a Pager connection. */ \nSQLITE_PRIVATE int sqlite3PagerOpen(\n  sqlite3_vfs*,\n  Pager **ppPager,\n  const char*,\n  int,\n  int,\n  int,\n  void(*)(DbPage*)\n);\nSQLITE_PRIVATE int sqlite3PagerClose(Pager *pPager);\nSQLITE_PRIVATE int sqlite3PagerReadFileheader(Pager*, int, unsigned char*);\n\n/* Functions used to configure a Pager object. */\nSQLITE_PRIVATE void sqlite3PagerSetBusyhandler(Pager*, int(*)(void *), void *);\nSQLITE_PRIVATE int sqlite3PagerSetPagesize(Pager*, u32*, int);\nSQLITE_PRIVATE int sqlite3PagerMaxPageCount(Pager*, int);\nSQLITE_PRIVATE void sqlite3PagerSetCachesize(Pager*, int);\nSQLITE_PRIVATE void sqlite3PagerSetSafetyLevel(Pager*,int,int,int);\nSQLITE_PRIVATE int sqlite3PagerLockingMode(Pager *, int);\nSQLITE_PRIVATE int sqlite3PagerSetJournalMode(Pager *, int);\nSQLITE_PRIVATE int sqlite3PagerGetJournalMode(Pager*);\nSQLITE_PRIVATE int sqlite3PagerOkToChangeJournalMode(Pager*);\nSQLITE_PRIVATE i64 sqlite3PagerJournalSizeLimit(Pager *, i64);\nSQLITE_PRIVATE sqlite3_backup **sqlite3PagerBackupPtr(Pager*);\n\n/* Functions used to obtain and release page references. */ \nSQLITE_PRIVATE int sqlite3PagerAcquire(Pager *pPager, Pgno pgno, DbPage **ppPage, int clrFlag);\n#define sqlite3PagerGet(A,B,C) sqlite3PagerAcquire(A,B,C,0)\nSQLITE_PRIVATE DbPage *sqlite3PagerLookup(Pager *pPager, Pgno pgno);\nSQLITE_PRIVATE void sqlite3PagerRef(DbPage*);\nSQLITE_PRIVATE void sqlite3PagerUnref(DbPage*);\n\n/* Operations on page references. */\nSQLITE_PRIVATE int sqlite3PagerWrite(DbPage*);\nSQLITE_PRIVATE void sqlite3PagerDontWrite(DbPage*);\nSQLITE_PRIVATE int sqlite3PagerMovepage(Pager*,DbPage*,Pgno,int);\nSQLITE_PRIVATE int sqlite3PagerPageRefcount(DbPage*);\nSQLITE_PRIVATE void *sqlite3PagerGetData(DbPage *); \nSQLITE_PRIVATE void *sqlite3PagerGetExtra(DbPage *); \n\n/* Functions used to manage pager transactions and savepoints. */\nSQLITE_PRIVATE void sqlite3PagerPagecount(Pager*, int*);\nSQLITE_PRIVATE int sqlite3PagerBegin(Pager*, int exFlag, int);\nSQLITE_PRIVATE int sqlite3PagerCommitPhaseOne(Pager*,const char *zMaster, int);\nSQLITE_PRIVATE int sqlite3PagerExclusiveLock(Pager*);\nSQLITE_PRIVATE int sqlite3PagerSync(Pager *pPager);\nSQLITE_PRIVATE int sqlite3PagerCommitPhaseTwo(Pager*);\nSQLITE_PRIVATE int sqlite3PagerRollback(Pager*);\nSQLITE_PRIVATE int sqlite3PagerOpenSavepoint(Pager *pPager, int n);\nSQLITE_PRIVATE int sqlite3PagerSavepoint(Pager *pPager, int op, int iSavepoint);\nSQLITE_PRIVATE int sqlite3PagerSharedLock(Pager *pPager);\n\nSQLITE_PRIVATE int sqlite3PagerCheckpoint(Pager *pPager, int, int*, int*);\nSQLITE_PRIVATE int sqlite3PagerWalSupported(Pager *pPager);\nSQLITE_PRIVATE int sqlite3PagerWalCallback(Pager *pPager);\nSQLITE_PRIVATE int sqlite3PagerOpenWal(Pager *pPager, int *pisOpen);\nSQLITE_PRIVATE int sqlite3PagerCloseWal(Pager *pPager);\n\n/* Functions used to query pager state and configuration. */\nSQLITE_PRIVATE u8 sqlite3PagerIsreadonly(Pager*);\nSQLITE_PRIVATE int sqlite3PagerRefcount(Pager*);\nSQLITE_PRIVATE int sqlite3PagerMemUsed(Pager*);\nSQLITE_PRIVATE const char *sqlite3PagerFilename(Pager*);\nSQLITE_PRIVATE const sqlite3_vfs *sqlite3PagerVfs(Pager*);\nSQLITE_PRIVATE sqlite3_file *sqlite3PagerFile(Pager*);\nSQLITE_PRIVATE const char *sqlite3PagerJournalname(Pager*);\nSQLITE_PRIVATE int sqlite3PagerNosync(Pager*);\nSQLITE_PRIVATE void *sqlite3PagerTempSpace(Pager*);\nSQLITE_PRIVATE int sqlite3PagerIsMemdb(Pager*);\n\n/* Functions used to truncate the database file. */\nSQLITE_PRIVATE void sqlite3PagerTruncateImage(Pager*,Pgno);\n\n#if defined(SQLITE_HAS_CODEC) && !defined(SQLITE_OMIT_WAL)\nSQLITE_PRIVATE void *sqlite3PagerCodec(DbPage *);\n#endif\n\n/* Functions to support testing and debugging. */\n#if !defined(NDEBUG) || defined(SQLITE_TEST)\nSQLITE_PRIVATE   Pgno sqlite3PagerPagenumber(DbPage*);\nSQLITE_PRIVATE   int sqlite3PagerIswriteable(DbPage*);\n#endif\n#ifdef SQLITE_TEST\nSQLITE_PRIVATE   int *sqlite3PagerStats(Pager*);\nSQLITE_PRIVATE   void sqlite3PagerRefdump(Pager*);\n  void disable_simulated_io_errors(void);\n  void enable_simulated_io_errors(void);\n#else\n# define disable_simulated_io_errors()\n# define enable_simulated_io_errors()\n#endif\n\n#endif /* _PAGER_H_ */\n\n/************** End of pager.h ***********************************************/\n/************** Continuing where we left off in sqliteInt.h ******************/\n/************** Include pcache.h in the middle of sqliteInt.h ****************/\n/************** Begin file pcache.h ******************************************/\n/*\n** 2008 August 05\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This header file defines the interface that the sqlite page cache\n** subsystem. \n*/\n\n#ifndef _PCACHE_H_\n\ntypedef struct PgHdr PgHdr;\ntypedef struct PCache PCache;\n\n/*\n** Every page in the cache is controlled by an instance of the following\n** structure.\n*/\nstruct PgHdr {\n  void *pData;                   /* Content of this page */\n  void *pExtra;                  /* Extra content */\n  PgHdr *pDirty;                 /* Transient list of dirty pages */\n  Pgno pgno;                     /* Page number for this page */\n  Pager *pPager;                 /* The pager this page is part of */\n#ifdef SQLITE_CHECK_PAGES\n  u32 pageHash;                  /* Hash of page content */\n#endif\n  u16 flags;                     /* PGHDR flags defined below */\n\n  /**********************************************************************\n  ** Elements above are public.  All that follows is private to pcache.c\n  ** and should not be accessed by other modules.\n  */\n  i16 nRef;                      /* Number of users of this page */\n  PCache *pCache;                /* Cache that owns this page */\n\n  PgHdr *pDirtyNext;             /* Next element in list of dirty pages */\n  PgHdr *pDirtyPrev;             /* Previous element in list of dirty pages */\n};\n\n/* Bit values for PgHdr.flags */\n#define PGHDR_DIRTY             0x002  /* Page has changed */\n#define PGHDR_NEED_SYNC         0x004  /* Fsync the rollback journal before\n                                       ** writing this page to the database */\n#define PGHDR_NEED_READ         0x008  /* Content is unread */\n#define PGHDR_REUSE_UNLIKELY    0x010  /* A hint that reuse is unlikely */\n#define PGHDR_DONT_WRITE        0x020  /* Do not write content to disk */\n\n#define PGHDR_ZERO_COPY         0x040  /* Content was read via xReadZeroCopy and must be released with xReleaseZeroCopy */\n\n/* Initialize and shutdown the page cache subsystem */\nSQLITE_PRIVATE int sqlite3PcacheInitialize(void);\nSQLITE_PRIVATE void sqlite3PcacheShutdown(void);\n\n/* Page cache buffer management:\n** These routines implement SQLITE_CONFIG_PAGECACHE.\n*/\nSQLITE_PRIVATE void sqlite3PCacheBufferSetup(void *, int sz, int n);\n\n/* Create a new pager cache.\n** Under memory stress, invoke xStress to try to make pages clean.\n** Only clean and unpinned pages can be reclaimed.\n*/\nSQLITE_PRIVATE void sqlite3PcacheOpen(\n  int szPage,                    /* Size of every page */\n  int szExtra,                   /* Extra space associated with each page */\n  int bPurgeable,                /* True if pages are on backing store */\n  int (*xStress)(void*, PgHdr*), /* Call to try to make pages clean */\n  void *pStress,                 /* Argument to xStress */\n  PCache *pToInit                /* Preallocated space for the PCache */\n);\n\n/* Modify the page-size after the cache has been created. */\nSQLITE_PRIVATE void sqlite3PcacheSetPageSize(PCache *, int);\n\n/* Return the size in bytes of a PCache object.  Used to preallocate\n** storage space.\n*/\nSQLITE_PRIVATE int sqlite3PcacheSize(void);\n\n/* One release per successful fetch.  Page is pinned until released.\n** Reference counted. \n*/\nSQLITE_PRIVATE int sqlite3PcacheFetch(PCache*, Pgno, int createFlag, PgHdr**);\nSQLITE_PRIVATE void sqlite3PcacheRelease(PgHdr*);\n\nSQLITE_PRIVATE void sqlite3PcacheDrop(PgHdr*);         /* Remove page from cache */\nSQLITE_PRIVATE void sqlite3PcacheMakeDirty(PgHdr*);    /* Make sure page is marked dirty */\nSQLITE_PRIVATE void sqlite3PcacheMakeClean(PgHdr*);    /* Mark a single page as clean */\nSQLITE_PRIVATE void sqlite3PcacheCleanAll(PCache*);    /* Mark all dirty list pages as clean */\n\n/* Change a page number.  Used by incr-vacuum. */\nSQLITE_PRIVATE void sqlite3PcacheMove(PgHdr*, Pgno);\n\n/* Remove all pages with pgno>x.  Reset the cache if x==0 */\nSQLITE_PRIVATE void sqlite3PcacheTruncate(PCache*, Pgno x);\n\n/* Get a list of all dirty pages in the cache, sorted by page number */\nSQLITE_PRIVATE PgHdr *sqlite3PcacheDirtyList(PCache*);\n\n/* Reset and close the cache object */\nSQLITE_PRIVATE void sqlite3PcacheClose(PCache*);\n\n/* Clear flags from pages of the page cache */\nSQLITE_PRIVATE void sqlite3PcacheClearSyncFlags(PCache *);\n\n/* Discard the contents of the cache */\nSQLITE_PRIVATE void sqlite3PcacheClear(PCache*);\n\n/* Return the total number of outstanding page references */\nSQLITE_PRIVATE int sqlite3PcacheRefCount(PCache*);\n\n/* Increment the reference count of an existing page */\nSQLITE_PRIVATE void sqlite3PcacheRef(PgHdr*);\n\nSQLITE_PRIVATE int sqlite3PcachePageRefcount(PgHdr*);\n\n/* Return the total number of pages stored in the cache */\nSQLITE_PRIVATE int sqlite3PcachePagecount(PCache*);\n\n#if defined(SQLITE_CHECK_PAGES) || defined(SQLITE_DEBUG)\n/* Iterate through all dirty pages currently stored in the cache. This\n** interface is only available if SQLITE_CHECK_PAGES is defined when the \n** library is built.\n*/\nSQLITE_PRIVATE void sqlite3PcacheIterateDirty(PCache *pCache, void (*xIter)(PgHdr *));\n#endif\n\n/* Set and get the suggested cache-size for the specified pager-cache.\n**\n** If no global maximum is configured, then the system attempts to limit\n** the total number of pages cached by purgeable pager-caches to the sum\n** of the suggested cache-sizes.\n*/\nSQLITE_PRIVATE void sqlite3PcacheSetCachesize(PCache *, int);\n#ifdef SQLITE_TEST\nSQLITE_PRIVATE int sqlite3PcacheGetCachesize(PCache *);\n#endif\n\n#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT\n/* Try to return memory used by the pcache module to the main memory heap */\nSQLITE_PRIVATE int sqlite3PcacheReleaseMemory(int);\n#endif\n\n#ifdef SQLITE_TEST\nSQLITE_PRIVATE void sqlite3PcacheStats(int*,int*,int*,int*);\n#endif\n\nSQLITE_PRIVATE void sqlite3PCacheSetDefault(void);\n\n#endif /* _PCACHE_H_ */\n\n/************** End of pcache.h **********************************************/\n/************** Continuing where we left off in sqliteInt.h ******************/\n\n/************** Include os.h in the middle of sqliteInt.h ********************/\n/************** Begin file os.h **********************************************/\n/*\n** 2001 September 16\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n******************************************************************************\n**\n** This header file (together with is companion C source-code file\n** \"os.c\") attempt to abstract the underlying operating system so that\n** the SQLite library will work on both POSIX and windows systems.\n**\n** This header file is #include-ed by sqliteInt.h and thus ends up\n** being included by every source file.\n*/\n#ifndef _SQLITE_OS_H_\n#define _SQLITE_OS_H_\n\n/*\n** Figure out if we are dealing with Unix, Windows, or some other\n** operating system.  After the following block of preprocess macros,\n** all of SQLITE_OS_UNIX, SQLITE_OS_WIN, SQLITE_OS_OS2, and SQLITE_OS_OTHER \n** will defined to either 1 or 0.  One of the four will be 1.  The other \n** three will be 0.\n*/\n#if defined(SQLITE_OS_OTHER)\n# if SQLITE_OS_OTHER==1\n#   undef SQLITE_OS_UNIX\n#   define SQLITE_OS_UNIX 0\n#   undef SQLITE_OS_WIN\n#   define SQLITE_OS_WIN 0\n#   undef SQLITE_OS_OS2\n#   define SQLITE_OS_OS2 0\n# else\n#   undef SQLITE_OS_OTHER\n# endif\n#endif\n#if !defined(SQLITE_OS_UNIX) && !defined(SQLITE_OS_OTHER)\n# define SQLITE_OS_OTHER 0\n# ifndef SQLITE_OS_WIN\n#   if defined(_WIN32) || defined(WIN32) || defined(__CYGWIN__) || defined(__MINGW32__) || defined(__BORLANDC__)\n#     define SQLITE_OS_WIN 1\n#     define SQLITE_OS_UNIX 0\n#     define SQLITE_OS_OS2 0\n#   elif defined(__EMX__) || defined(_OS2) || defined(OS2) || defined(_OS2_) || defined(__OS2__)\n#     define SQLITE_OS_WIN 0\n#     define SQLITE_OS_UNIX 0\n#     define SQLITE_OS_OS2 1\n#   else\n#     define SQLITE_OS_WIN 0\n#     define SQLITE_OS_UNIX 1\n#     define SQLITE_OS_OS2 0\n#  endif\n# else\n#  define SQLITE_OS_UNIX 0\n#  define SQLITE_OS_OS2 0\n# endif\n#else\n# ifndef SQLITE_OS_WIN\n#  define SQLITE_OS_WIN 0\n# endif\n#endif\n\n/*\n** Determine if we are dealing with WindowsCE - which has a much\n** reduced API.\n*/\n#if defined(_WIN32_WCE)\n# define SQLITE_OS_WINCE 1\n#else\n# define SQLITE_OS_WINCE 0\n#endif\n\n\n/*\n** Define the maximum size of a temporary filename\n*/\n#if SQLITE_OS_WIN\n# include <windows.h>\n# define SQLITE_TEMPNAME_SIZE (MAX_PATH+50)\n#elif SQLITE_OS_OS2\n# if (__GNUC__ > 3 || __GNUC__ == 3 && __GNUC_MINOR__ >= 3) && defined(OS2_HIGH_MEMORY)\n#  include <os2safe.h> /* has to be included before os2.h for linking to work */\n# endif\n# define INCL_DOSDATETIME\n# define INCL_DOSFILEMGR\n# define INCL_DOSERRORS\n# define INCL_DOSMISC\n# define INCL_DOSPROCESS\n# define INCL_DOSMODULEMGR\n# define INCL_DOSSEMAPHORES\n# include <os2.h>\n# include <uconv.h>\n# define SQLITE_TEMPNAME_SIZE (CCHMAXPATHCOMP)\n#else\n# define SQLITE_TEMPNAME_SIZE 200\n#endif\n\n/* If the SET_FULLSYNC macro is not defined above, then make it\n** a no-op\n*/\n#ifndef SET_FULLSYNC\n# define SET_FULLSYNC(x,y)\n#endif\n\n/*\n** The default size of a disk sector\n*/\n#ifndef SQLITE_DEFAULT_SECTOR_SIZE\n# define SQLITE_DEFAULT_SECTOR_SIZE 512\n#endif\n\n/*\n** Temporary files are named starting with this prefix followed by 16 random\n** alphanumeric characters, and no file extension. They are stored in the\n** OS's standard temporary file directory, and are deleted prior to exit.\n** If sqlite is being embedded in another program, you may wish to change the\n** prefix to reflect your program's name, so that if your program exits\n** prematurely, old temporary files can be easily identified. This can be done\n** using -DSQLITE_TEMP_FILE_PREFIX=myprefix_ on the compiler command line.\n**\n** 2006-10-31:  The default prefix used to be \"sqlite_\".  But then\n** Mcafee started using SQLite in their anti-virus product and it\n** started putting files with the \"sqlite\" name in the c:/temp folder.\n** This annoyed many windows users.  Those users would then do a \n** Google search for \"sqlite\", find the telephone numbers of the\n** developers and call to wake them up at night and complain.\n** For this reason, the default name prefix is changed to be \"sqlite\" \n** spelled backwards.  So the temp files are still identified, but\n** anybody smart enough to figure out the code is also likely smart\n** enough to know that calling the developer will not help get rid\n** of the file.\n*/\n#ifndef SQLITE_TEMP_FILE_PREFIX\n# define SQLITE_TEMP_FILE_PREFIX \"etilqs_\"\n#endif\n\n/*\n** The following values may be passed as the second argument to\n** sqlite3OsLock(). The various locks exhibit the following semantics:\n**\n** SHARED:    Any number of processes may hold a SHARED lock simultaneously.\n** RESERVED:  A single process may hold a RESERVED lock on a file at\n**            any time. Other processes may hold and obtain new SHARED locks.\n** PENDING:   A single process may hold a PENDING lock on a file at\n**            any one time. Existing SHARED locks may persist, but no new\n**            SHARED locks may be obtained by other processes.\n** EXCLUSIVE: An EXCLUSIVE lock precludes all other locks.\n**\n** PENDING_LOCK may not be passed directly to sqlite3OsLock(). Instead, a\n** process that requests an EXCLUSIVE lock may actually obtain a PENDING\n** lock. This can be upgraded to an EXCLUSIVE lock by a subsequent call to\n** sqlite3OsLock().\n*/\n#define NO_LOCK         0\n#define SHARED_LOCK     1\n#define RESERVED_LOCK   2\n#define PENDING_LOCK    3\n#define EXCLUSIVE_LOCK  4\n\n/*\n** File Locking Notes:  (Mostly about windows but also some info for Unix)\n**\n** We cannot use LockFileEx() or UnlockFileEx() on Win95/98/ME because\n** those functions are not available.  So we use only LockFile() and\n** UnlockFile().\n**\n** LockFile() prevents not just writing but also reading by other processes.\n** A SHARED_LOCK is obtained by locking a single randomly-chosen \n** byte out of a specific range of bytes. The lock byte is obtained at \n** random so two separate readers can probably access the file at the \n** same time, unless they are unlucky and choose the same lock byte.\n** An EXCLUSIVE_LOCK is obtained by locking all bytes in the range.\n** There can only be one writer.  A RESERVED_LOCK is obtained by locking\n** a single byte of the file that is designated as the reserved lock byte.\n** A PENDING_LOCK is obtained by locking a designated byte different from\n** the RESERVED_LOCK byte.\n**\n** On WinNT/2K/XP systems, LockFileEx() and UnlockFileEx() are available,\n** which means we can use reader/writer locks.  When reader/writer locks\n** are used, the lock is placed on the same range of bytes that is used\n** for probabilistic locking in Win95/98/ME.  Hence, the locking scheme\n** will support two or more Win95 readers or two or more WinNT readers.\n** But a single Win95 reader will lock out all WinNT readers and a single\n** WinNT reader will lock out all other Win95 readers.\n**\n** The following #defines specify the range of bytes used for locking.\n** SHARED_SIZE is the number of bytes available in the pool from which\n** a random byte is selected for a shared lock.  The pool of bytes for\n** shared locks begins at SHARED_FIRST. \n**\n** The same locking strategy and\n** byte ranges are used for Unix.  This leaves open the possiblity of having\n** clients on win95, winNT, and unix all talking to the same shared file\n** and all locking correctly.  To do so would require that samba (or whatever\n** tool is being used for file sharing) implements locks correctly between\n** windows and unix.  I'm guessing that isn't likely to happen, but by\n** using the same locking range we are at least open to the possibility.\n**\n** Locking in windows is manditory.  For this reason, we cannot store\n** actual data in the bytes used for locking.  The pager never allocates\n** the pages involved in locking therefore.  SHARED_SIZE is selected so\n** that all locks will fit on a single page even at the minimum page size.\n** PENDING_BYTE defines the beginning of the locks.  By default PENDING_BYTE\n** is set high so that we don't have to allocate an unused page except\n** for very large databases.  But one should test the page skipping logic \n** by setting PENDING_BYTE low and running the entire regression suite.\n**\n** Changing the value of PENDING_BYTE results in a subtly incompatible\n** file format.  Depending on how it is changed, you might not notice\n** the incompatibility right away, even running a full regression test.\n** The default location of PENDING_BYTE is the first byte past the\n** 1GB boundary.\n**\n*/\n#ifdef SQLITE_OMIT_WSD\n# define PENDING_BYTE     (0x40000000)\n#else\n# define PENDING_BYTE      sqlite3PendingByte\n#endif\n#define RESERVED_BYTE     (PENDING_BYTE+1)\n#define SHARED_FIRST      (PENDING_BYTE+2)\n#define SHARED_SIZE       510\n\n/*\n** Wrapper around OS specific sqlite3_os_init() function.\n*/\nSQLITE_PRIVATE int sqlite3OsInit(void);\n\n/* \n** Functions for accessing sqlite3_file methods \n*/\nSQLITE_PRIVATE int sqlite3OsClose(sqlite3_file*);\nSQLITE_PRIVATE int sqlite3OsRead(sqlite3_file*, void*, int amt, i64 offset);\nSQLITE_PRIVATE int sqlite3OsWrite(sqlite3_file*, const void*, int amt, i64 offset);\nSQLITE_PRIVATE int sqlite3OsTruncate(sqlite3_file*, i64 size);\nSQLITE_PRIVATE int sqlite3OsSync(sqlite3_file*, int);\nSQLITE_PRIVATE int sqlite3OsFileSize(sqlite3_file*, i64 *pSize);\nSQLITE_PRIVATE int sqlite3OsLock(sqlite3_file*, int);\nSQLITE_PRIVATE int sqlite3OsUnlock(sqlite3_file*, int);\nSQLITE_PRIVATE int sqlite3OsCheckReservedLock(sqlite3_file *id, int *pResOut);\nSQLITE_PRIVATE int sqlite3OsFileControl(sqlite3_file*,int,void*);\n#define SQLITE_FCNTL_DB_UNCHANGED 0xca093fa0\nSQLITE_PRIVATE int sqlite3OsSectorSize(sqlite3_file *id);\nSQLITE_PRIVATE int sqlite3OsDeviceCharacteristics(sqlite3_file *id);\nSQLITE_PRIVATE int sqlite3OsShmMap(sqlite3_file *,int,int,int,void volatile **);\nSQLITE_PRIVATE int sqlite3OsShmLock(sqlite3_file *id, int, int, int);\nSQLITE_PRIVATE void sqlite3OsShmBarrier(sqlite3_file *id);\nSQLITE_PRIVATE int sqlite3OsShmUnmap(sqlite3_file *id, int);\n\n/* \n** Functions for accessing sqlite3_vfs methods \n*/\nSQLITE_PRIVATE int sqlite3OsOpen(sqlite3_vfs *, const char *, sqlite3_file*, int, int *);\nSQLITE_PRIVATE int sqlite3OsDelete(sqlite3_vfs *, const char *, int);\nSQLITE_PRIVATE int sqlite3OsAccess(sqlite3_vfs *, const char *, int, int *pResOut);\nSQLITE_PRIVATE int sqlite3OsFullPathname(sqlite3_vfs *, const char *, int, char *);\n#ifndef SQLITE_OMIT_LOAD_EXTENSION\nSQLITE_PRIVATE void *sqlite3OsDlOpen(sqlite3_vfs *, const char *);\nSQLITE_PRIVATE void sqlite3OsDlError(sqlite3_vfs *, int, char *);\nSQLITE_PRIVATE void (*sqlite3OsDlSym(sqlite3_vfs *, void *, const char *))(void);\nSQLITE_PRIVATE void sqlite3OsDlClose(sqlite3_vfs *, void *);\n#endif /* SQLITE_OMIT_LOAD_EXTENSION */\nSQLITE_PRIVATE int sqlite3OsRandomness(sqlite3_vfs *, int, char *);\nSQLITE_PRIVATE int sqlite3OsSleep(sqlite3_vfs *, int);\nSQLITE_PRIVATE int sqlite3OsCurrentTimeInt64(sqlite3_vfs *, sqlite3_int64*);\n\n/*\n** Convenience functions for opening and closing files using \n** sqlite3_malloc() to obtain space for the file-handle structure.\n*/\nSQLITE_PRIVATE int sqlite3OsOpenMalloc(sqlite3_vfs *, const char *, sqlite3_file **, int,int*);\nSQLITE_PRIVATE int sqlite3OsCloseFree(sqlite3_file *);\n\n#endif /* _SQLITE_OS_H_ */\n\n/************** End of os.h **************************************************/\n/************** Continuing where we left off in sqliteInt.h ******************/\n/************** Include mutex.h in the middle of sqliteInt.h *****************/\n/************** Begin file mutex.h *******************************************/\n/*\n** 2007 August 28\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n**\n** This file contains the common header for all mutex implementations.\n** The sqliteInt.h header #includes this file so that it is available\n** to all source files.  We break it out in an effort to keep the code\n** better organized.\n**\n** NOTE:  source files should *not* #include this header file directly.\n** Source files should #include the sqliteInt.h file and let that file\n** include this one indirectly.\n*/\n\n\n/*\n** Figure out what version of the code to use.  The choices are\n**\n**   SQLITE_MUTEX_OMIT         No mutex logic.  Not even stubs.  The\n**                             mutexes implemention cannot be overridden\n**                             at start-time.\n**\n**   SQLITE_MUTEX_NOOP         For single-threaded applications.  No\n**                             mutual exclusion is provided.  But this\n**                             implementation can be overridden at\n**                             start-time.\n**\n**   SQLITE_MUTEX_PTHREADS     For multi-threaded applications on Unix.\n**\n**   SQLITE_MUTEX_W32          For multi-threaded applications on Win32.\n**\n**   SQLITE_MUTEX_OS2          For multi-threaded applications on OS/2.\n*/\n#if !SQLITE_THREADSAFE\n# define SQLITE_MUTEX_OMIT\n#endif\n#if SQLITE_THREADSAFE && !defined(SQLITE_MUTEX_NOOP)\n#  if SQLITE_OS_UNIX\n#    define SQLITE_MUTEX_PTHREADS\n#  elif SQLITE_OS_WIN\n#    define SQLITE_MUTEX_W32\n#  elif SQLITE_OS_OS2\n#    define SQLITE_MUTEX_OS2\n#  else\n#    define SQLITE_MUTEX_NOOP\n#  endif\n#endif\n\n#ifdef SQLITE_MUTEX_OMIT\n/*\n** If this is a no-op implementation, implement everything as macros.\n*/\n#define sqlite3_mutex_alloc(X)    ((sqlite3_mutex*)8)\n#define sqlite3_mutex_free(X)\n#define sqlite3_mutex_enter(X)\n#define sqlite3_mutex_try(X)      SQLITE_OK\n#define sqlite3_mutex_leave(X)\n#define sqlite3_mutex_held(X)     ((void)(X),1)\n#define sqlite3_mutex_notheld(X)  ((void)(X),1)\n#define sqlite3MutexAlloc(X)      ((sqlite3_mutex*)8)\n#define sqlite3MutexInit()        SQLITE_OK\n#define sqlite3MutexEnd()\n#endif /* defined(SQLITE_MUTEX_OMIT) */\n\n/************** End of mutex.h ***********************************************/\n/************** Continuing where we left off in sqliteInt.h ******************/\n\n\n/*\n** Each database file to be accessed by the system is an instance\n** of the following structure.  There are normally two of these structures\n** in the sqlite.aDb[] array.  aDb[0] is the main database file and\n** aDb[1] is the database file used to hold temporary tables.  Additional\n** databases may be attached.\n*/\nstruct Db {\n  char *zName;         /* Name of this database */\n  Btree *pBt;          /* The B*Tree structure for this database file */\n  u8 inTrans;          /* 0: not writable.  1: Transaction.  2: Checkpoint */\n  u8 safety_level;     /* How aggressive at syncing data to disk */\n  Schema *pSchema;     /* Pointer to database schema (possibly shared) */\n};\n\n/*\n** An instance of the following structure stores a database schema.\n*/\nstruct Schema {\n  int schema_cookie;   /* Database schema version number for this file */\n  Hash tblHash;        /* All tables indexed by name */\n  Hash idxHash;        /* All (named) indices indexed by name */\n  Hash trigHash;       /* All triggers indexed by name */\n  Hash fkeyHash;       /* All foreign keys by referenced table name */\n  Table *pSeqTab;      /* The sqlite_sequence table used by AUTOINCREMENT */\n  u8 file_format;      /* Schema format version for this file */\n  u8 enc;              /* Text encoding used by this database */\n  u16 flags;           /* Flags associated with this schema */\n  int cache_size;      /* Number of pages to use in the cache */\n};\n\n/*\n** These macros can be used to test, set, or clear bits in the \n** Db.pSchema->flags field.\n*/\n#define DbHasProperty(D,I,P)     (((D)->aDb[I].pSchema->flags&(P))==(P))\n#define DbHasAnyProperty(D,I,P)  (((D)->aDb[I].pSchema->flags&(P))!=0)\n#define DbSetProperty(D,I,P)     (D)->aDb[I].pSchema->flags|=(P)\n#define DbClearProperty(D,I,P)   (D)->aDb[I].pSchema->flags&=~(P)\n\n/*\n** Allowed values for the DB.pSchema->flags field.\n**\n** The DB_SchemaLoaded flag is set after the database schema has been\n** read into internal hash tables.\n**\n** DB_UnresetViews means that one or more views have column names that\n** have been filled out.  If the schema changes, these column names might\n** changes and so the view will need to be reset.\n*/\n#define DB_SchemaLoaded    0x0001  /* The schema has been loaded */\n#define DB_UnresetViews    0x0002  /* Some views have defined column names */\n#define DB_Empty           0x0004  /* The file is empty (length 0 bytes) */\n\n/*\n** The number of different kinds of things that can be limited\n** using the sqlite3_limit() interface.\n*/\n#define SQLITE_N_LIMIT (SQLITE_LIMIT_TRIGGER_DEPTH+1)\n\n/*\n** Lookaside malloc is a set of fixed-size buffers that can be used\n** to satisfy small transient memory allocation requests for objects\n** associated with a particular database connection.  The use of\n** lookaside malloc provides a significant performance enhancement\n** (approx 10%) by avoiding numerous malloc/free requests while parsing\n** SQL statements.\n**\n** The Lookaside structure holds configuration information about the\n** lookaside malloc subsystem.  Each available memory allocation in\n** the lookaside subsystem is stored on a linked list of LookasideSlot\n** objects.\n**\n** Lookaside allocations are only allowed for objects that are associated\n** with a particular database connection.  Hence, schema information cannot\n** be stored in lookaside because in shared cache mode the schema information\n** is shared by multiple database connections.  Therefore, while parsing\n** schema information, the Lookaside.bEnabled flag is cleared so that\n** lookaside allocations are not used to construct the schema objects.\n*/\nstruct Lookaside {\n  u16 sz;                 /* Size of each buffer in bytes */\n  u8 bEnabled;            /* False to disable new lookaside allocations */\n  u8 bMalloced;           /* True if pStart obtained from sqlite3_malloc() */\n  int nOut;               /* Number of buffers currently checked out */\n  int mxOut;              /* Highwater mark for nOut */\n  int anStat[3];          /* 0: hits.  1: size misses.  2: full misses */\n  LookasideSlot *pFree;   /* List of available buffers */\n  void *pStart;           /* First byte of available memory space */\n  void *pEnd;             /* First byte past end of available space */\n};\nstruct LookasideSlot {\n  LookasideSlot *pNext;    /* Next buffer in the list of free buffers */\n};\n\n/*\n** A hash table for function definitions.\n**\n** Hash each FuncDef structure into one of the FuncDefHash.a[] slots.\n** Collisions are on the FuncDef.pHash chain.\n*/\nstruct FuncDefHash {\n  FuncDef *a[23];       /* Hash table for functions */\n};\n\n/*\n** Each database connection is an instance of the following structure.\n**\n** The sqlite.lastRowid records the last insert rowid generated by an\n** insert statement.  Inserts on views do not affect its value.  Each\n** trigger has its own context, so that lastRowid can be updated inside\n** triggers as usual.  The previous value will be restored once the trigger\n** exits.  Upon entering a before or instead of trigger, lastRowid is no\n** longer (since after version 2.8.12) reset to -1.\n**\n** The sqlite.nChange does not count changes within triggers and keeps no\n** context.  It is reset at start of sqlite3_exec.\n** The sqlite.lsChange represents the number of changes made by the last\n** insert, update, or delete statement.  It remains constant throughout the\n** length of a statement and is then updated by OP_SetCounts.  It keeps a\n** context stack just like lastRowid so that the count of changes\n** within a trigger is not seen outside the trigger.  Changes to views do not\n** affect the value of lsChange.\n** The sqlite.csChange keeps track of the number of current changes (since\n** the last statement) and is used to update sqlite_lsChange.\n**\n** The member variables sqlite.errCode, sqlite.zErrMsg and sqlite.zErrMsg16\n** store the most recent error code and, if applicable, string. The\n** internal function sqlite3Error() is used to set these variables\n** consistently.\n*/\nstruct sqlite3 {\n  sqlite3_vfs *pVfs;            /* OS Interface */\n  int nDb;                      /* Number of backends currently in use */\n  Db *aDb;                      /* All backends */\n  int flags;                    /* Miscellaneous flags. See below */\n  int openFlags;                /* Flags passed to sqlite3_vfs.xOpen() */\n  int errCode;                  /* Most recent error code (SQLITE_*) */\n  int errMask;                  /* & result codes with this before returning */\n  u8 autoCommit;                /* The auto-commit flag. */\n  u8 temp_store;                /* 1: file 2: memory 0: default */\n  u8 mallocFailed;              /* True if we have seen a malloc failure */\n  u8 dfltLockMode;              /* Default locking-mode for attached dbs */\n  signed char nextAutovac;      /* Autovac setting after VACUUM if >=0 */\n  u8 suppressErr;               /* Do not issue error messages if true */\n  int nextPagesize;             /* Pagesize after VACUUM if >0 */\n  int nTable;                   /* Number of tables in the database */\n  CollSeq *pDfltColl;           /* The default collating sequence (BINARY) */\n  i64 lastRowid;                /* ROWID of most recent insert (see above) */\n  u32 magic;                    /* Magic number for detect library misuse */\n  int nChange;                  /* Value returned by sqlite3_changes() */\n  int nTotalChange;             /* Value returned by sqlite3_total_changes() */\n  sqlite3_mutex *mutex;         /* Connection mutex */\n  int aLimit[SQLITE_N_LIMIT];   /* Limits */\n  struct sqlite3InitInfo {      /* Information used during initialization */\n    int iDb;                    /* When back is being initialized */\n    int newTnum;                /* Rootpage of table being initialized */\n    u8 busy;                    /* TRUE if currently initializing */\n    u8 orphanTrigger;           /* Last statement is orphaned TEMP trigger */\n  } init;\n  int nExtension;               /* Number of loaded extensions */\n  void **aExtension;            /* Array of shared library handles */\n  struct Vdbe *pVdbe;           /* List of active virtual machines */\n  int activeVdbeCnt;            /* Number of VDBEs currently executing */\n  int writeVdbeCnt;             /* Number of active VDBEs that are writing */\n  int vdbeExecCnt;              /* Number of nested calls to VdbeExec() */\n  void (*xTrace)(void*,const char*);        /* Trace function */\n  void *pTraceArg;                          /* Argument to the trace function */\n  void (*xProfile)(void*,const char*,u64);  /* Profiling function */\n  void *pProfileArg;                        /* Argument to profile function */\n  void *pCommitArg;                 /* Argument to xCommitCallback() */   \n  int (*xCommitCallback)(void*);    /* Invoked at every commit. */\n  void *pRollbackArg;               /* Argument to xRollbackCallback() */   \n  void (*xRollbackCallback)(void*); /* Invoked at every commit. */\n  void *pUpdateArg;\n  void (*xUpdateCallback)(void*,int, const char*,const char*,sqlite_int64);\n#ifndef SQLITE_OMIT_WAL\n  int (*xWalCallback)(void *, sqlite3 *, const char *, int);\n  void *pWalArg;\n#endif\n  void(*xCollNeeded)(void*,sqlite3*,int eTextRep,const char*);\n  void(*xCollNeeded16)(void*,sqlite3*,int eTextRep,const void*);\n  void *pCollNeededArg;\n  sqlite3_value *pErr;          /* Most recent error message */\n  char *zErrMsg;                /* Most recent error message (UTF-8 encoded) */\n  char *zErrMsg16;              /* Most recent error message (UTF-16 encoded) */\n  union {\n    volatile int isInterrupted; /* True if sqlite3_interrupt has been called */\n    double notUsed1;            /* Spacer */\n  } u1;\n  Lookaside lookaside;          /* Lookaside malloc configuration */\n#ifndef SQLITE_OMIT_AUTHORIZATION\n  int (*xAuth)(void*,int,const char*,const char*,const char*,const char*);\n                                /* Access authorization function */\n  void *pAuthArg;               /* 1st argument to the access auth function */\n#endif\n#ifndef SQLITE_OMIT_PROGRESS_CALLBACK\n  int (*xProgress)(void *);     /* The progress callback */\n  void *pProgressArg;           /* Argument to the progress callback */\n  int nProgressOps;             /* Number of opcodes for progress callback */\n#endif\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  Hash aModule;                 /* populated by sqlite3_create_module() */\n  Table *pVTab;                 /* vtab with active Connect/Create method */\n  VTable **aVTrans;             /* Virtual tables with open transactions */\n  int nVTrans;                  /* Allocated size of aVTrans */\n  VTable *pDisconnect;    /* Disconnect these in next sqlite3_prepare() */\n#endif\n  FuncDefHash aFunc;            /* Hash table of connection functions */\n  Hash aCollSeq;                /* All collating sequences */\n  BusyHandler busyHandler;      /* Busy callback */\n  int busyTimeout;              /* Busy handler timeout, in msec */\n  Db aDbStatic[2];              /* Static space for the 2 default backends */\n  Savepoint *pSavepoint;        /* List of active savepoints */\n  int nSavepoint;               /* Number of non-transaction savepoints */\n  int nStatement;               /* Number of nested statement-transactions  */\n  u8 isTransactionSavepoint;    /* True if the outermost savepoint is a TS */\n  i64 nDeferredCons;            /* Net deferred constraints this transaction. */\n  int *pnBytesFreed;            /* If not NULL, increment this in DbFree() */\n\n#ifdef SQLITE_ENABLE_UNLOCK_NOTIFY\n  /* The following variables are all protected by the STATIC_MASTER \n  ** mutex, not by sqlite3.mutex. They are used by code in notify.c. \n  **\n  ** When X.pUnlockConnection==Y, that means that X is waiting for Y to\n  ** unlock so that it can proceed.\n  **\n  ** When X.pBlockingConnection==Y, that means that something that X tried\n  ** tried to do recently failed with an SQLITE_LOCKED error due to locks\n  ** held by Y.\n  */\n  sqlite3 *pBlockingConnection; /* Connection that caused SQLITE_LOCKED */\n  sqlite3 *pUnlockConnection;           /* Connection to watch for unlock */\n  void *pUnlockArg;                     /* Argument to xUnlockNotify */\n  void (*xUnlockNotify)(void **, int);  /* Unlock notify callback */\n  sqlite3 *pNextBlocked;        /* Next in list of all blocked connections */\n#endif\n};\n\n/*\n** A macro to discover the encoding of a database.\n*/\n#define ENC(db) ((db)->aDb[0].pSchema->enc)\n\n/*\n** Possible values for the sqlite3.flags.\n*/\n#define SQLITE_VdbeTrace      0x00000100  /* True to trace VDBE execution */\n#define SQLITE_InternChanges  0x00000200  /* Uncommitted Hash table changes */\n#define SQLITE_FullColNames   0x00000400  /* Show full column names on SELECT */\n#define SQLITE_ShortColNames  0x00000800  /* Show short columns names */\n#define SQLITE_CountRows      0x00001000  /* Count rows changed by INSERT, */\n                                          /*   DELETE, or UPDATE and return */\n                                          /*   the count using a callback. */\n#define SQLITE_NullCallback   0x00002000  /* Invoke the callback once if the */\n                                          /*   result set is empty */\n#define SQLITE_SqlTrace       0x00004000  /* Debug print SQL as it executes */\n#define SQLITE_VdbeListing    0x00008000  /* Debug listings of VDBE programs */\n#define SQLITE_WriteSchema    0x00010000  /* OK to update SQLITE_MASTER */\n#define SQLITE_NoReadlock     0x00020000  /* Readlocks are omitted when \n                                          ** accessing read-only databases */\n#define SQLITE_IgnoreChecks   0x00040000  /* Do not enforce check constraints */\n#define SQLITE_ReadUncommitted 0x0080000  /* For shared-cache mode */\n#define SQLITE_LegacyFileFmt  0x00100000  /* Create new databases in format 1 */\n#define SQLITE_FullFSync      0x00200000  /* Use full fsync on the backend */\n#define SQLITE_CkptFullFSync  0x00400000  /* Use full fsync for checkpoint */\n#define SQLITE_RecoveryMode   0x00800000  /* Ignore schema errors */\n#define SQLITE_ReverseOrder   0x01000000  /* Reverse unordered SELECTs */\n#define SQLITE_RecTriggers    0x02000000  /* Enable recursive triggers */\n#define SQLITE_ForeignKeys    0x04000000  /* Enforce foreign key constraints  */\n#define SQLITE_AutoIndex      0x08000000  /* Enable automatic indexes */\n#define SQLITE_PreferBuiltin  0x10000000  /* Preference to built-in funcs */\n#define SQLITE_LoadExtension  0x20000000  /* Enable load_extension */\n\n/*\n** Bits of the sqlite3.flags field that are used by the\n** sqlite3_test_control(SQLITE_TESTCTRL_OPTIMIZATIONS,...) interface.\n** These must be the low-order bits of the flags field.\n*/\n#define SQLITE_QueryFlattener 0x01        /* Disable query flattening */\n#define SQLITE_ColumnCache    0x02        /* Disable the column cache */\n#define SQLITE_IndexSort      0x04        /* Disable indexes for sorting */\n#define SQLITE_IndexSearch    0x08        /* Disable indexes for searching */\n#define SQLITE_IndexCover     0x10        /* Disable index covering table */\n#define SQLITE_GroupByOrder   0x20        /* Disable GROUPBY cover of ORDERBY */\n#define SQLITE_FactorOutConst 0x40        /* Disable factoring out constants */\n#define SQLITE_OptMask        0xff        /* Mask of all disablable opts */\n\n/*\n** Possible values for the sqlite.magic field.\n** The numbers are obtained at random and have no special meaning, other\n** than being distinct from one another.\n*/\n#define SQLITE_MAGIC_OPEN     0xa029a697  /* Database is open */\n#define SQLITE_MAGIC_CLOSED   0x9f3c2d33  /* Database is closed */\n#define SQLITE_MAGIC_SICK     0x4b771290  /* Error and awaiting close */\n#define SQLITE_MAGIC_BUSY     0xf03b7906  /* Database currently in use */\n#define SQLITE_MAGIC_ERROR    0xb5357930  /* An SQLITE_MISUSE error occurred */\n\n/*\n** Each SQL function is defined by an instance of the following\n** structure.  A pointer to this structure is stored in the sqlite.aFunc\n** hash table.  When multiple functions have the same name, the hash table\n** points to a linked list of these structures.\n*/\nstruct FuncDef {\n  i16 nArg;            /* Number of arguments.  -1 means unlimited */\n  u8 iPrefEnc;         /* Preferred text encoding (SQLITE_UTF8, 16LE, 16BE) */\n  u8 flags;            /* Some combination of SQLITE_FUNC_* */\n  void *pUserData;     /* User data parameter */\n  FuncDef *pNext;      /* Next function with same name */\n  void (*xFunc)(sqlite3_context*,int,sqlite3_value**); /* Regular function */\n  void (*xStep)(sqlite3_context*,int,sqlite3_value**); /* Aggregate step */\n  void (*xFinalize)(sqlite3_context*);                /* Aggregate finalizer */\n  char *zName;         /* SQL name of the function. */\n  FuncDef *pHash;      /* Next with a different name but the same hash */\n  FuncDestructor *pDestructor;   /* Reference counted destructor function */\n};\n\n/*\n** This structure encapsulates a user-function destructor callback (as\n** configured using create_function_v2()) and a reference counter. When\n** create_function_v2() is called to create a function with a destructor,\n** a single object of this type is allocated. FuncDestructor.nRef is set to \n** the number of FuncDef objects created (either 1 or 3, depending on whether\n** or not the specified encoding is SQLITE_ANY). The FuncDef.pDestructor\n** member of each of the new FuncDef objects is set to point to the allocated\n** FuncDestructor.\n**\n** Thereafter, when one of the FuncDef objects is deleted, the reference\n** count on this object is decremented. When it reaches 0, the destructor\n** is invoked and the FuncDestructor structure freed.\n*/\nstruct FuncDestructor {\n  int nRef;\n  void (*xDestroy)(void *);\n  void *pUserData;\n};\n\n/*\n** Possible values for FuncDef.flags\n*/\n#define SQLITE_FUNC_LIKE     0x01 /* Candidate for the LIKE optimization */\n#define SQLITE_FUNC_CASE     0x02 /* Case-sensitive LIKE-type function */\n#define SQLITE_FUNC_EPHEM    0x04 /* Ephemeral.  Delete with VDBE */\n#define SQLITE_FUNC_NEEDCOLL 0x08 /* sqlite3GetFuncCollSeq() might be called */\n#define SQLITE_FUNC_PRIVATE  0x10 /* Allowed for internal use only */\n#define SQLITE_FUNC_COUNT    0x20 /* Built-in count(*) aggregate */\n#define SQLITE_FUNC_COALESCE 0x40 /* Built-in coalesce() or ifnull() function */\n\n/*\n** The following three macros, FUNCTION(), LIKEFUNC() and AGGREGATE() are\n** used to create the initializers for the FuncDef structures.\n**\n**   FUNCTION(zName, nArg, iArg, bNC, xFunc)\n**     Used to create a scalar function definition of a function zName \n**     implemented by C function xFunc that accepts nArg arguments. The\n**     value passed as iArg is cast to a (void*) and made available\n**     as the user-data (sqlite3_user_data()) for the function. If \n**     argument bNC is true, then the SQLITE_FUNC_NEEDCOLL flag is set.\n**\n**   AGGREGATE(zName, nArg, iArg, bNC, xStep, xFinal)\n**     Used to create an aggregate function definition implemented by\n**     the C functions xStep and xFinal. The first four parameters\n**     are interpreted in the same way as the first 4 parameters to\n**     FUNCTION().\n**\n**   LIKEFUNC(zName, nArg, pArg, flags)\n**     Used to create a scalar function definition of a function zName \n**     that accepts nArg arguments and is implemented by a call to C \n**     function likeFunc. Argument pArg is cast to a (void *) and made\n**     available as the function user-data (sqlite3_user_data()). The\n**     FuncDef.flags variable is set to the value passed as the flags\n**     parameter.\n*/\n#define FUNCTION(zName, nArg, iArg, bNC, xFunc) \\\n  {nArg, SQLITE_UTF8, bNC*SQLITE_FUNC_NEEDCOLL, \\\n   SQLITE_INT_TO_PTR(iArg), 0, xFunc, 0, 0, #zName, 0, 0}\n#define STR_FUNCTION(zName, nArg, pArg, bNC, xFunc) \\\n  {nArg, SQLITE_UTF8, bNC*SQLITE_FUNC_NEEDCOLL, \\\n   pArg, 0, xFunc, 0, 0, #zName, 0, 0}\n#define LIKEFUNC(zName, nArg, arg, flags) \\\n  {nArg, SQLITE_UTF8, flags, (void *)arg, 0, likeFunc, 0, 0, #zName, 0, 0}\n#define AGGREGATE(zName, nArg, arg, nc, xStep, xFinal) \\\n  {nArg, SQLITE_UTF8, nc*SQLITE_FUNC_NEEDCOLL, \\\n   SQLITE_INT_TO_PTR(arg), 0, 0, xStep,xFinal,#zName,0,0}\n\n/*\n** All current savepoints are stored in a linked list starting at\n** sqlite3.pSavepoint. The first element in the list is the most recently\n** opened savepoint. Savepoints are added to the list by the vdbe\n** OP_Savepoint instruction.\n*/\nstruct Savepoint {\n  char *zName;                        /* Savepoint name (nul-terminated) */\n  i64 nDeferredCons;                  /* Number of deferred fk violations */\n  Savepoint *pNext;                   /* Parent savepoint (if any) */\n};\n\n/*\n** The following are used as the second parameter to sqlite3Savepoint(),\n** and as the P1 argument to the OP_Savepoint instruction.\n*/\n#define SAVEPOINT_BEGIN      0\n#define SAVEPOINT_RELEASE    1\n#define SAVEPOINT_ROLLBACK   2\n\n\n/*\n** Each SQLite module (virtual table definition) is defined by an\n** instance of the following structure, stored in the sqlite3.aModule\n** hash table.\n*/\nstruct Module {\n  const sqlite3_module *pModule;       /* Callback pointers */\n  const char *zName;                   /* Name passed to create_module() */\n  void *pAux;                          /* pAux passed to create_module() */\n  void (*xDestroy)(void *);            /* Module destructor function */\n};\n\n/*\n** information about each column of an SQL table is held in an instance\n** of this structure.\n*/\nstruct Column {\n  char *zName;     /* Name of this column */\n  Expr *pDflt;     /* Default value of this column */\n  char *zDflt;     /* Original text of the default value */\n  char *zType;     /* Data type for this column */\n  char *zColl;     /* Collating sequence.  If NULL, use the default */\n  u8 notNull;      /* True if there is a NOT NULL constraint */\n  u8 isPrimKey;    /* True if this column is part of the PRIMARY KEY */\n  char affinity;   /* One of the SQLITE_AFF_... values */\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  u8 isHidden;     /* True if this column is 'hidden' */\n#endif\n};\n\n/*\n** A \"Collating Sequence\" is defined by an instance of the following\n** structure. Conceptually, a collating sequence consists of a name and\n** a comparison routine that defines the order of that sequence.\n**\n** There may two separate implementations of the collation function, one\n** that processes text in UTF-8 encoding (CollSeq.xCmp) and another that\n** processes text encoded in UTF-16 (CollSeq.xCmp16), using the machine\n** native byte order. When a collation sequence is invoked, SQLite selects\n** the version that will require the least expensive encoding\n** translations, if any.\n**\n** The CollSeq.pUser member variable is an extra parameter that passed in\n** as the first argument to the UTF-8 comparison function, xCmp.\n** CollSeq.pUser16 is the equivalent for the UTF-16 comparison function,\n** xCmp16.\n**\n** If both CollSeq.xCmp and CollSeq.xCmp16 are NULL, it means that the\n** collating sequence is undefined.  Indices built on an undefined\n** collating sequence may not be read or written.\n*/\nstruct CollSeq {\n  char *zName;          /* Name of the collating sequence, UTF-8 encoded */\n  u8 enc;               /* Text encoding handled by xCmp() */\n  u8 type;              /* One of the SQLITE_COLL_... values below */\n  void *pUser;          /* First argument to xCmp() */\n  int (*xCmp)(void*,int, const void*, int, const void*);\n  void (*xDel)(void*);  /* Destructor for pUser */\n};\n\n/*\n** Allowed values of CollSeq.type:\n*/\n#define SQLITE_COLL_BINARY  1  /* The default memcmp() collating sequence */\n#define SQLITE_COLL_NOCASE  2  /* The built-in NOCASE collating sequence */\n#define SQLITE_COLL_REVERSE 3  /* The built-in REVERSE collating sequence */\n#define SQLITE_COLL_USER    0  /* Any other user-defined collating sequence */\n\n/*\n** A sort order can be either ASC or DESC.\n*/\n#define SQLITE_SO_ASC       0  /* Sort in ascending order */\n#define SQLITE_SO_DESC      1  /* Sort in ascending order */\n\n/*\n** Column affinity types.\n**\n** These used to have mnemonic name like 'i' for SQLITE_AFF_INTEGER and\n** 't' for SQLITE_AFF_TEXT.  But we can save a little space and improve\n** the speed a little by numbering the values consecutively.  \n**\n** But rather than start with 0 or 1, we begin with 'a'.  That way,\n** when multiple affinity types are concatenated into a string and\n** used as the P4 operand, they will be more readable.\n**\n** Note also that the numeric types are grouped together so that testing\n** for a numeric type is a single comparison.\n*/\n#define SQLITE_AFF_TEXT     'a'\n#define SQLITE_AFF_NONE     'b'\n#define SQLITE_AFF_NUMERIC  'c'\n#define SQLITE_AFF_INTEGER  'd'\n#define SQLITE_AFF_REAL     'e'\n\n#define sqlite3IsNumericAffinity(X)  ((X)>=SQLITE_AFF_NUMERIC)\n\n/*\n** The SQLITE_AFF_MASK values masks off the significant bits of an\n** affinity value. \n*/\n#define SQLITE_AFF_MASK     0x67\n\n/*\n** Additional bit values that can be ORed with an affinity without\n** changing the affinity.\n*/\n#define SQLITE_JUMPIFNULL   0x08  /* jumps if either operand is NULL */\n#define SQLITE_STOREP2      0x10  /* Store result in reg[P2] rather than jump */\n#define SQLITE_NULLEQ       0x80  /* NULL=NULL */\n\n/*\n** An object of this type is created for each virtual table present in\n** the database schema. \n**\n** If the database schema is shared, then there is one instance of this\n** structure for each database connection (sqlite3*) that uses the shared\n** schema. This is because each database connection requires its own unique\n** instance of the sqlite3_vtab* handle used to access the virtual table \n** implementation. sqlite3_vtab* handles can not be shared between \n** database connections, even when the rest of the in-memory database \n** schema is shared, as the implementation often stores the database\n** connection handle passed to it via the xConnect() or xCreate() method\n** during initialization internally. This database connection handle may\n** then used by the virtual table implementation to access real tables \n** within the database. So that they appear as part of the callers \n** transaction, these accesses need to be made via the same database \n** connection as that used to execute SQL operations on the virtual table.\n**\n** All VTable objects that correspond to a single table in a shared\n** database schema are initially stored in a linked-list pointed to by\n** the Table.pVTable member variable of the corresponding Table object.\n** When an sqlite3_prepare() operation is required to access the virtual\n** table, it searches the list for the VTable that corresponds to the\n** database connection doing the preparing so as to use the correct\n** sqlite3_vtab* handle in the compiled query.\n**\n** When an in-memory Table object is deleted (for example when the\n** schema is being reloaded for some reason), the VTable objects are not \n** deleted and the sqlite3_vtab* handles are not xDisconnect()ed \n** immediately. Instead, they are moved from the Table.pVTable list to\n** another linked list headed by the sqlite3.pDisconnect member of the\n** corresponding sqlite3 structure. They are then deleted/xDisconnected \n** next time a statement is prepared using said sqlite3*. This is done\n** to avoid deadlock issues involving multiple sqlite3.mutex mutexes.\n** Refer to comments above function sqlite3VtabUnlockList() for an\n** explanation as to why it is safe to add an entry to an sqlite3.pDisconnect\n** list without holding the corresponding sqlite3.mutex mutex.\n**\n** The memory for objects of this type is always allocated by \n** sqlite3DbMalloc(), using the connection handle stored in VTable.db as \n** the first argument.\n*/\nstruct VTable {\n  sqlite3 *db;              /* Database connection associated with this table */\n  Module *pMod;             /* Pointer to module implementation */\n  sqlite3_vtab *pVtab;      /* Pointer to vtab instance */\n  int nRef;                 /* Number of pointers to this structure */\n  VTable *pNext;            /* Next in linked list (see above) */\n};\n\n/*\n** Each SQL table is represented in memory by an instance of the\n** following structure.\n**\n** Table.zName is the name of the table.  The case of the original\n** CREATE TABLE statement is stored, but case is not significant for\n** comparisons.\n**\n** Table.nCol is the number of columns in this table.  Table.aCol is a\n** pointer to an array of Column structures, one for each column.\n**\n** If the table has an INTEGER PRIMARY KEY, then Table.iPKey is the index of\n** the column that is that key.   Otherwise Table.iPKey is negative.  Note\n** that the datatype of the PRIMARY KEY must be INTEGER for this field to\n** be set.  An INTEGER PRIMARY KEY is used as the rowid for each row of\n** the table.  If a table has no INTEGER PRIMARY KEY, then a random rowid\n** is generated for each row of the table.  TF_HasPrimaryKey is set if\n** the table has any PRIMARY KEY, INTEGER or otherwise.\n**\n** Table.tnum is the page number for the root BTree page of the table in the\n** database file.  If Table.iDb is the index of the database table backend\n** in sqlite.aDb[].  0 is for the main database and 1 is for the file that\n** holds temporary tables and indices.  If TF_Ephemeral is set\n** then the table is stored in a file that is automatically deleted\n** when the VDBE cursor to the table is closed.  In this case Table.tnum \n** refers VDBE cursor number that holds the table open, not to the root\n** page number.  Transient tables are used to hold the results of a\n** sub-query that appears instead of a real table name in the FROM clause \n** of a SELECT statement.\n*/\nstruct Table {\n  char *zName;         /* Name of the table or view */\n  int iPKey;           /* If not negative, use aCol[iPKey] as the primary key */\n  int nCol;            /* Number of columns in this table */\n  Column *aCol;        /* Information about each column */\n  Index *pIndex;       /* List of SQL indexes on this table. */\n  int tnum;            /* Root BTree node for this table (see note above) */\n  unsigned nRowEst;    /* Estimated rows in table - from sqlite_stat1 table */\n  Select *pSelect;     /* NULL for tables.  Points to definition if a view. */\n  u16 nRef;            /* Number of pointers to this Table */\n  u8 tabFlags;         /* Mask of TF_* values */\n  u8 keyConf;          /* What to do in case of uniqueness conflict on iPKey */\n  FKey *pFKey;         /* Linked list of all foreign keys in this table */\n  char *zColAff;       /* String defining the affinity of each column */\n#ifndef SQLITE_OMIT_CHECK\n  Expr *pCheck;        /* The AND of all CHECK constraints */\n#endif\n#ifndef SQLITE_OMIT_ALTERTABLE\n  int addColOffset;    /* Offset in CREATE TABLE stmt to add a new column */\n#endif\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  VTable *pVTable;     /* List of VTable objects. */\n  int nModuleArg;      /* Number of arguments to the module */\n  char **azModuleArg;  /* Text of all module args. [0] is module name */\n#endif\n  Trigger *pTrigger;   /* List of triggers stored in pSchema */\n  Schema *pSchema;     /* Schema that contains this table */\n  Table *pNextZombie;  /* Next on the Parse.pZombieTab list */\n};\n\n/*\n** Allowed values for Tabe.tabFlags.\n*/\n#define TF_Readonly        0x01    /* Read-only system table */\n#define TF_Ephemeral       0x02    /* An ephemeral table */\n#define TF_HasPrimaryKey   0x04    /* Table has a primary key */\n#define TF_Autoincrement   0x08    /* Integer primary key is autoincrement */\n#define TF_Virtual         0x10    /* Is a virtual table */\n#define TF_NeedMetadata    0x20    /* aCol[].zType and aCol[].pColl missing */\n\n\n\n/*\n** Test to see whether or not a table is a virtual table.  This is\n** done as a macro so that it will be optimized out when virtual\n** table support is omitted from the build.\n*/\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n#  define IsVirtual(X)      (((X)->tabFlags & TF_Virtual)!=0)\n#  define IsHiddenColumn(X) ((X)->isHidden)\n#else\n#  define IsVirtual(X)      0\n#  define IsHiddenColumn(X) 0\n#endif\n\n/*\n** Each foreign key constraint is an instance of the following structure.\n**\n** A foreign key is associated with two tables.  The \"from\" table is\n** the table that contains the REFERENCES clause that creates the foreign\n** key.  The \"to\" table is the table that is named in the REFERENCES clause.\n** Consider this example:\n**\n**     CREATE TABLE ex1(\n**       a INTEGER PRIMARY KEY,\n**       b INTEGER CONSTRAINT fk1 REFERENCES ex2(x)\n**     );\n**\n** For foreign key \"fk1\", the from-table is \"ex1\" and the to-table is \"ex2\".\n**\n** Each REFERENCES clause generates an instance of the following structure\n** which is attached to the from-table.  The to-table need not exist when\n** the from-table is created.  The existence of the to-table is not checked.\n*/\nstruct FKey {\n  Table *pFrom;     /* Table containing the REFERENCES clause (aka: Child) */\n  FKey *pNextFrom;  /* Next foreign key in pFrom */\n  char *zTo;        /* Name of table that the key points to (aka: Parent) */\n  FKey *pNextTo;    /* Next foreign key on table named zTo */\n  FKey *pPrevTo;    /* Previous foreign key on table named zTo */\n  int nCol;         /* Number of columns in this key */\n  /* EV: R-30323-21917 */\n  u8 isDeferred;    /* True if constraint checking is deferred till COMMIT */\n  u8 aAction[2];          /* ON DELETE and ON UPDATE actions, respectively */\n  Trigger *apTrigger[2];  /* Triggers for aAction[] actions */\n  struct sColMap {  /* Mapping of columns in pFrom to columns in zTo */\n    int iFrom;         /* Index of column in pFrom */\n    char *zCol;        /* Name of column in zTo.  If 0 use PRIMARY KEY */\n  } aCol[1];        /* One entry for each of nCol column s */\n};\n\n/*\n** SQLite supports many different ways to resolve a constraint\n** error.  ROLLBACK processing means that a constraint violation\n** causes the operation in process to fail and for the current transaction\n** to be rolled back.  ABORT processing means the operation in process\n** fails and any prior changes from that one operation are backed out,\n** but the transaction is not rolled back.  FAIL processing means that\n** the operation in progress stops and returns an error code.  But prior\n** changes due to the same operation are not backed out and no rollback\n** occurs.  IGNORE means that the particular row that caused the constraint\n** error is not inserted or updated.  Processing continues and no error\n** is returned.  REPLACE means that preexisting database rows that caused\n** a UNIQUE constraint violation are removed so that the new insert or\n** update can proceed.  Processing continues and no error is reported.\n**\n** RESTRICT, SETNULL, and CASCADE actions apply only to foreign keys.\n** RESTRICT is the same as ABORT for IMMEDIATE foreign keys and the\n** same as ROLLBACK for DEFERRED keys.  SETNULL means that the foreign\n** key is set to NULL.  CASCADE means that a DELETE or UPDATE of the\n** referenced table row is propagated into the row that holds the\n** foreign key.\n** \n** The following symbolic values are used to record which type\n** of action to take.\n*/\n#define OE_None     0   /* There is no constraint to check */\n#define OE_Rollback 1   /* Fail the operation and rollback the transaction */\n#define OE_Abort    2   /* Back out changes but do no rollback transaction */\n#define OE_Fail     3   /* Stop the operation but leave all prior changes */\n#define OE_Ignore   4   /* Ignore the error. Do not do the INSERT or UPDATE */\n#define OE_Replace  5   /* Delete existing record, then do INSERT or UPDATE */\n\n#define OE_Restrict 6   /* OE_Abort for IMMEDIATE, OE_Rollback for DEFERRED */\n#define OE_SetNull  7   /* Set the foreign key value to NULL */\n#define OE_SetDflt  8   /* Set the foreign key value to its default */\n#define OE_Cascade  9   /* Cascade the changes */\n\n#define OE_Default  99  /* Do whatever the default action is */\n\n\n/*\n** An instance of the following structure is passed as the first\n** argument to sqlite3VdbeKeyCompare and is used to control the \n** comparison of the two index keys.\n*/\nstruct KeyInfo {\n  sqlite3 *db;        /* The database connection */\n  u8 enc;             /* Text encoding - one of the SQLITE_UTF* values */\n  u16 nField;         /* Number of entries in aColl[] */\n  u8 *aSortOrder;     /* Sort order for each column.  May be NULL */\n  CollSeq *aColl[1];  /* Collating sequence for each term of the key */\n};\n\n/*\n** An instance of the following structure holds information about a\n** single index record that has already been parsed out into individual\n** values.\n**\n** A record is an object that contains one or more fields of data.\n** Records are used to store the content of a table row and to store\n** the key of an index.  A blob encoding of a record is created by\n** the OP_MakeRecord opcode of the VDBE and is disassembled by the\n** OP_Column opcode.\n**\n** This structure holds a record that has already been disassembled\n** into its constituent fields.\n*/\nstruct UnpackedRecord {\n  KeyInfo *pKeyInfo;  /* Collation and sort-order information */\n  u16 nField;         /* Number of entries in apMem[] */\n  u16 flags;          /* Boolean settings.  UNPACKED_... below */\n  i64 rowid;          /* Used by UNPACKED_PREFIX_SEARCH */\n  Mem *aMem;          /* Values */\n};\n\n/*\n** Allowed values of UnpackedRecord.flags\n*/\n#define UNPACKED_NEED_FREE     0x0001  /* Memory is from sqlite3Malloc() */\n#define UNPACKED_NEED_DESTROY  0x0002  /* apMem[]s should all be destroyed */\n#define UNPACKED_IGNORE_ROWID  0x0004  /* Ignore trailing rowid on key1 */\n#define UNPACKED_INCRKEY       0x0008  /* Make this key an epsilon larger */\n#define UNPACKED_PREFIX_MATCH  0x0010  /* A prefix match is considered OK */\n#define UNPACKED_PREFIX_SEARCH 0x0020  /* A prefix match is considered OK */\n\n/*\n** Each SQL index is represented in memory by an\n** instance of the following structure.\n**\n** The columns of the table that are to be indexed are described\n** by the aiColumn[] field of this structure.  For example, suppose\n** we have the following table and index:\n**\n**     CREATE TABLE Ex1(c1 int, c2 int, c3 text);\n**     CREATE INDEX Ex2 ON Ex1(c3,c1);\n**\n** In the Table structure describing Ex1, nCol==3 because there are\n** three columns in the table.  In the Index structure describing\n** Ex2, nColumn==2 since 2 of the 3 columns of Ex1 are indexed.\n** The value of aiColumn is {2, 0}.  aiColumn[0]==2 because the \n** first column to be indexed (c3) has an index of 2 in Ex1.aCol[].\n** The second column to be indexed (c1) has an index of 0 in\n** Ex1.aCol[], hence Ex2.aiColumn[1]==0.\n**\n** The Index.onError field determines whether or not the indexed columns\n** must be unique and what to do if they are not.  When Index.onError=OE_None,\n** it means this is not a unique index.  Otherwise it is a unique index\n** and the value of Index.onError indicate the which conflict resolution \n** algorithm to employ whenever an attempt is made to insert a non-unique\n** element.\n*/\nstruct Index {\n  char *zName;     /* Name of this index */\n  int nColumn;     /* Number of columns in the table used by this index */\n  int *aiColumn;   /* Which columns are used by this index.  1st is 0 */\n  unsigned *aiRowEst; /* Result of ANALYZE: Est. rows selected by each column */\n  Table *pTable;   /* The SQL table being indexed */\n  int tnum;        /* Page containing root of this index in database file */\n  u8 onError;      /* OE_Abort, OE_Ignore, OE_Replace, or OE_None */\n  u8 autoIndex;    /* True if is automatically created (ex: by UNIQUE) */\n  char *zColAff;   /* String defining the affinity of each column */\n  Index *pNext;    /* The next index associated with the same table */\n  Schema *pSchema; /* Schema containing this index */\n  u8 *aSortOrder;  /* Array of size Index.nColumn. True==DESC, False==ASC */\n  char **azColl;   /* Array of collation sequence names for index */\n  IndexSample *aSample;    /* Array of SQLITE_INDEX_SAMPLES samples */\n};\n\n/*\n** Each sample stored in the sqlite_stat2 table is represented in memory \n** using a structure of this type.\n*/\nstruct IndexSample {\n  union {\n    char *z;        /* Value if eType is SQLITE_TEXT or SQLITE_BLOB */\n    double r;       /* Value if eType is SQLITE_FLOAT or SQLITE_INTEGER */\n  } u;\n  u8 eType;         /* SQLITE_NULL, SQLITE_INTEGER ... etc. */\n  u8 nByte;         /* Size in byte of text or blob. */\n};\n\n/*\n** Each token coming out of the lexer is an instance of\n** this structure.  Tokens are also used as part of an expression.\n**\n** Note if Token.z==0 then Token.dyn and Token.n are undefined and\n** may contain random values.  Do not make any assumptions about Token.dyn\n** and Token.n when Token.z==0.\n*/\nstruct Token {\n  const char *z;     /* Text of the token.  Not NULL-terminated! */\n  unsigned int n;    /* Number of characters in this token */\n};\n\n/*\n** An instance of this structure contains information needed to generate\n** code for a SELECT that contains aggregate functions.\n**\n** If Expr.op==TK_AGG_COLUMN or TK_AGG_FUNCTION then Expr.pAggInfo is a\n** pointer to this structure.  The Expr.iColumn field is the index in\n** AggInfo.aCol[] or AggInfo.aFunc[] of information needed to generate\n** code for that node.\n**\n** AggInfo.pGroupBy and AggInfo.aFunc.pExpr point to fields within the\n** original Select structure that describes the SELECT statement.  These\n** fields do not need to be freed when deallocating the AggInfo structure.\n*/\nstruct AggInfo {\n  u8 directMode;          /* Direct rendering mode means take data directly\n                          ** from source tables rather than from accumulators */\n  u8 useSortingIdx;       /* In direct mode, reference the sorting index rather\n                          ** than the source table */\n  int sortingIdx;         /* Cursor number of the sorting index */\n  ExprList *pGroupBy;     /* The group by clause */\n  int nSortingColumn;     /* Number of columns in the sorting index */\n  struct AggInfo_col {    /* For each column used in source tables */\n    Table *pTab;             /* Source table */\n    int iTable;              /* Cursor number of the source table */\n    int iColumn;             /* Column number within the source table */\n    int iSorterColumn;       /* Column number in the sorting index */\n    int iMem;                /* Memory location that acts as accumulator */\n    Expr *pExpr;             /* The original expression */\n  } *aCol;\n  int nColumn;            /* Number of used entries in aCol[] */\n  int nColumnAlloc;       /* Number of slots allocated for aCol[] */\n  int nAccumulator;       /* Number of columns that show through to the output.\n                          ** Additional columns are used only as parameters to\n                          ** aggregate functions */\n  struct AggInfo_func {   /* For each aggregate function */\n    Expr *pExpr;             /* Expression encoding the function */\n    FuncDef *pFunc;          /* The aggregate function implementation */\n    int iMem;                /* Memory location that acts as accumulator */\n    int iDistinct;           /* Ephemeral table used to enforce DISTINCT */\n  } *aFunc;\n  int nFunc;              /* Number of entries in aFunc[] */\n  int nFuncAlloc;         /* Number of slots allocated for aFunc[] */\n};\n\n/*\n** The datatype ynVar is a signed integer, either 16-bit or 32-bit.\n** Usually it is 16-bits.  But if SQLITE_MAX_VARIABLE_NUMBER is greater\n** than 32767 we have to make it 32-bit.  16-bit is preferred because\n** it uses less memory in the Expr object, which is a big memory user\n** in systems with lots of prepared statements.  And few applications\n** need more than about 10 or 20 variables.  But some extreme users want\n** to have prepared statements with over 32767 variables, and for them\n** the option is available (at compile-time).\n*/\n#if SQLITE_MAX_VARIABLE_NUMBER<=32767\ntypedef i16 ynVar;\n#else\ntypedef int ynVar;\n#endif\n\n/*\n** Each node of an expression in the parse tree is an instance\n** of this structure.\n**\n** Expr.op is the opcode. The integer parser token codes are reused\n** as opcodes here. For example, the parser defines TK_GE to be an integer\n** code representing the \">=\" operator. This same integer code is reused\n** to represent the greater-than-or-equal-to operator in the expression\n** tree.\n**\n** If the expression is an SQL literal (TK_INTEGER, TK_FLOAT, TK_BLOB, \n** or TK_STRING), then Expr.token contains the text of the SQL literal. If\n** the expression is a variable (TK_VARIABLE), then Expr.token contains the \n** variable name. Finally, if the expression is an SQL function (TK_FUNCTION),\n** then Expr.token contains the name of the function.\n**\n** Expr.pRight and Expr.pLeft are the left and right subexpressions of a\n** binary operator. Either or both may be NULL.\n**\n** Expr.x.pList is a list of arguments if the expression is an SQL function,\n** a CASE expression or an IN expression of the form \"<lhs> IN (<y>, <z>...)\".\n** Expr.x.pSelect is used if the expression is a sub-select or an expression of\n** the form \"<lhs> IN (SELECT ...)\". If the EP_xIsSelect bit is set in the\n** Expr.flags mask, then Expr.x.pSelect is valid. Otherwise, Expr.x.pList is \n** valid.\n**\n** An expression of the form ID or ID.ID refers to a column in a table.\n** For such expressions, Expr.op is set to TK_COLUMN and Expr.iTable is\n** the integer cursor number of a VDBE cursor pointing to that table and\n** Expr.iColumn is the column number for the specific column.  If the\n** expression is used as a result in an aggregate SELECT, then the\n** value is also stored in the Expr.iAgg column in the aggregate so that\n** it can be accessed after all aggregates are computed.\n**\n** If the expression is an unbound variable marker (a question mark \n** character '?' in the original SQL) then the Expr.iTable holds the index \n** number for that variable.\n**\n** If the expression is a subquery then Expr.iColumn holds an integer\n** register number containing the result of the subquery.  If the\n** subquery gives a constant result, then iTable is -1.  If the subquery\n** gives a different answer at different times during statement processing\n** then iTable is the address of a subroutine that computes the subquery.\n**\n** If the Expr is of type OP_Column, and the table it is selecting from\n** is a disk table or the \"old.*\" pseudo-table, then pTab points to the\n** corresponding table definition.\n**\n** ALLOCATION NOTES:\n**\n** Expr objects can use a lot of memory space in database schema.  To\n** help reduce memory requirements, sometimes an Expr object will be\n** truncated.  And to reduce the number of memory allocations, sometimes\n** two or more Expr objects will be stored in a single memory allocation,\n** together with Expr.zToken strings.\n**\n** If the EP_Reduced and EP_TokenOnly flags are set when\n** an Expr object is truncated.  When EP_Reduced is set, then all\n** the child Expr objects in the Expr.pLeft and Expr.pRight subtrees\n** are contained within the same memory allocation.  Note, however, that\n** the subtrees in Expr.x.pList or Expr.x.pSelect are always separately\n** allocated, regardless of whether or not EP_Reduced is set.\n*/\nstruct Expr {\n  u8 op;                 /* Operation performed by this node */\n  char affinity;         /* The affinity of the column or 0 if not a column */\n  u16 flags;             /* Various flags.  EP_* See below */\n  union {\n    char *zToken;          /* Token value. Zero terminated and dequoted */\n    int iValue;            /* Non-negative integer value if EP_IntValue */\n  } u;\n\n  /* If the EP_TokenOnly flag is set in the Expr.flags mask, then no\n  ** space is allocated for the fields below this point. An attempt to\n  ** access them will result in a segfault or malfunction. \n  *********************************************************************/\n\n  Expr *pLeft;           /* Left subnode */\n  Expr *pRight;          /* Right subnode */\n  union {\n    ExprList *pList;     /* Function arguments or in \"<expr> IN (<expr-list)\" */\n    Select *pSelect;     /* Used for sub-selects and \"<expr> IN (<select>)\" */\n  } x;\n  CollSeq *pColl;        /* The collation type of the column or 0 */\n\n  /* If the EP_Reduced flag is set in the Expr.flags mask, then no\n  ** space is allocated for the fields below this point. An attempt to\n  ** access them will result in a segfault or malfunction.\n  *********************************************************************/\n\n  int iTable;            /* TK_COLUMN: cursor number of table holding column\n                         ** TK_REGISTER: register number\n                         ** TK_TRIGGER: 1 -> new, 0 -> old */\n  ynVar iColumn;         /* TK_COLUMN: column index.  -1 for rowid.\n                         ** TK_VARIABLE: variable number (always >= 1). */\n  i16 iAgg;              /* Which entry in pAggInfo->aCol[] or ->aFunc[] */\n  i16 iRightJoinTable;   /* If EP_FromJoin, the right table of the join */\n  u8 flags2;             /* Second set of flags.  EP2_... */\n  u8 op2;                /* If a TK_REGISTER, the original value of Expr.op */\n  AggInfo *pAggInfo;     /* Used by TK_AGG_COLUMN and TK_AGG_FUNCTION */\n  Table *pTab;           /* Table for TK_COLUMN expressions. */\n#if SQLITE_MAX_EXPR_DEPTH>0\n  int nHeight;           /* Height of the tree headed by this node */\n#endif\n};\n\n/*\n** The following are the meanings of bits in the Expr.flags field.\n*/\n#define EP_FromJoin   0x0001  /* Originated in ON or USING clause of a join */\n#define EP_Agg        0x0002  /* Contains one or more aggregate functions */\n#define EP_Resolved   0x0004  /* IDs have been resolved to COLUMNs */\n#define EP_Error      0x0008  /* Expression contains one or more errors */\n#define EP_Distinct   0x0010  /* Aggregate function with DISTINCT keyword */\n#define EP_VarSelect  0x0020  /* pSelect is correlated, not constant */\n#define EP_DblQuoted  0x0040  /* token.z was originally in \"...\" */\n#define EP_InfixFunc  0x0080  /* True for an infix function: LIKE, GLOB, etc */\n#define EP_ExpCollate 0x0100  /* Collating sequence specified explicitly */\n#define EP_FixedDest  0x0200  /* Result needed in a specific register */\n#define EP_IntValue   0x0400  /* Integer value contained in u.iValue */\n#define EP_xIsSelect  0x0800  /* x.pSelect is valid (otherwise x.pList is) */\n\n#define EP_Reduced    0x1000  /* Expr struct is EXPR_REDUCEDSIZE bytes only */\n#define EP_TokenOnly  0x2000  /* Expr struct is EXPR_TOKENONLYSIZE bytes only */\n#define EP_Static     0x4000  /* Held in memory not obtained from malloc() */\n\n/*\n** The following are the meanings of bits in the Expr.flags2 field.\n*/\n#define EP2_MallocedToken  0x0001  /* Need to sqlite3DbFree() Expr.zToken */\n#define EP2_Irreducible    0x0002  /* Cannot EXPRDUP_REDUCE this Expr */\n\n/*\n** The pseudo-routine sqlite3ExprSetIrreducible sets the EP2_Irreducible\n** flag on an expression structure.  This flag is used for VV&A only.  The\n** routine is implemented as a macro that only works when in debugging mode,\n** so as not to burden production code.\n*/\n#ifdef SQLITE_DEBUG\n# define ExprSetIrreducible(X)  (X)->flags2 |= EP2_Irreducible\n#else\n# define ExprSetIrreducible(X)\n#endif\n\n/*\n** These macros can be used to test, set, or clear bits in the \n** Expr.flags field.\n*/\n#define ExprHasProperty(E,P)     (((E)->flags&(P))==(P))\n#define ExprHasAnyProperty(E,P)  (((E)->flags&(P))!=0)\n#define ExprSetProperty(E,P)     (E)->flags|=(P)\n#define ExprClearProperty(E,P)   (E)->flags&=~(P)\n\n/*\n** Macros to determine the number of bytes required by a normal Expr \n** struct, an Expr struct with the EP_Reduced flag set in Expr.flags \n** and an Expr struct with the EP_TokenOnly flag set.\n*/\n#define EXPR_FULLSIZE           sizeof(Expr)           /* Full size */\n#define EXPR_REDUCEDSIZE        offsetof(Expr,iTable)  /* Common features */\n#define EXPR_TOKENONLYSIZE      offsetof(Expr,pLeft)   /* Fewer features */\n\n/*\n** Flags passed to the sqlite3ExprDup() function. See the header comment \n** above sqlite3ExprDup() for details.\n*/\n#define EXPRDUP_REDUCE         0x0001  /* Used reduced-size Expr nodes */\n\n/*\n** A list of expressions.  Each expression may optionally have a\n** name.  An expr/name combination can be used in several ways, such\n** as the list of \"expr AS ID\" fields following a \"SELECT\" or in the\n** list of \"ID = expr\" items in an UPDATE.  A list of expressions can\n** also be used as the argument to a function, in which case the a.zName\n** field is not used.\n*/\nstruct ExprList {\n  int nExpr;             /* Number of expressions on the list */\n  int nAlloc;            /* Number of entries allocated below */\n  int iECursor;          /* VDBE Cursor associated with this ExprList */\n  struct ExprList_item {\n    Expr *pExpr;           /* The list of expressions */\n    char *zName;           /* Token associated with this expression */\n    char *zSpan;           /* Original text of the expression */\n    u8 sortOrder;          /* 1 for DESC or 0 for ASC */\n    u8 done;               /* A flag to indicate when processing is finished */\n    u16 iCol;              /* For ORDER BY, column number in result set */\n    u16 iAlias;            /* Index into Parse.aAlias[] for zName */\n  } *a;                  /* One entry for each expression */\n};\n\n/*\n** An instance of this structure is used by the parser to record both\n** the parse tree for an expression and the span of input text for an\n** expression.\n*/\nstruct ExprSpan {\n  Expr *pExpr;          /* The expression parse tree */\n  const char *zStart;   /* First character of input text */\n  const char *zEnd;     /* One character past the end of input text */\n};\n\n/*\n** An instance of this structure can hold a simple list of identifiers,\n** such as the list \"a,b,c\" in the following statements:\n**\n**      INSERT INTO t(a,b,c) VALUES ...;\n**      CREATE INDEX idx ON t(a,b,c);\n**      CREATE TRIGGER trig BEFORE UPDATE ON t(a,b,c) ...;\n**\n** The IdList.a.idx field is used when the IdList represents the list of\n** column names after a table name in an INSERT statement.  In the statement\n**\n**     INSERT INTO t(a,b,c) ...\n**\n** If \"a\" is the k-th column of table \"t\", then IdList.a[0].idx==k.\n*/\nstruct IdList {\n  struct IdList_item {\n    char *zName;      /* Name of the identifier */\n    int idx;          /* Index in some Table.aCol[] of a column named zName */\n  } *a;\n  int nId;         /* Number of identifiers on the list */\n  int nAlloc;      /* Number of entries allocated for a[] below */\n};\n\n/*\n** The bitmask datatype defined below is used for various optimizations.\n**\n** Changing this from a 64-bit to a 32-bit type limits the number of\n** tables in a join to 32 instead of 64.  But it also reduces the size\n** of the library by 738 bytes on ix86.\n*/\ntypedef u64 Bitmask;\n\n/*\n** The number of bits in a Bitmask.  \"BMS\" means \"BitMask Size\".\n*/\n#define BMS  ((int)(sizeof(Bitmask)*8))\n\n/*\n** The following structure describes the FROM clause of a SELECT statement.\n** Each table or subquery in the FROM clause is a separate element of\n** the SrcList.a[] array.\n**\n** With the addition of multiple database support, the following structure\n** can also be used to describe a particular table such as the table that\n** is modified by an INSERT, DELETE, or UPDATE statement.  In standard SQL,\n** such a table must be a simple name: ID.  But in SQLite, the table can\n** now be identified by a database name, a dot, then the table name: ID.ID.\n**\n** The jointype starts out showing the join type between the current table\n** and the next table on the list.  The parser builds the list this way.\n** But sqlite3SrcListShiftJoinType() later shifts the jointypes so that each\n** jointype expresses the join between the table and the previous table.\n**\n** In the colUsed field, the high-order bit (bit 63) is set if the table\n** contains more than 63 columns and the 64-th or later column is used.\n*/\nstruct SrcList {\n  i16 nSrc;        /* Number of tables or subqueries in the FROM clause */\n  i16 nAlloc;      /* Number of entries allocated in a[] below */\n  struct SrcList_item {\n    char *zDatabase;  /* Name of database holding this table */\n    char *zName;      /* Name of the table */\n    char *zAlias;     /* The \"B\" part of a \"A AS B\" phrase.  zName is the \"A\" */\n    Table *pTab;      /* An SQL table corresponding to zName */\n    Select *pSelect;  /* A SELECT statement used in place of a table name */\n    u8 isPopulated;   /* Temporary table associated with SELECT is populated */\n    u8 jointype;      /* Type of join between this able and the previous */\n    u8 notIndexed;    /* True if there is a NOT INDEXED clause */\n#ifndef SQLITE_OMIT_EXPLAIN\n    u8 iSelectId;     /* If pSelect!=0, the id of the sub-select in EQP */\n#endif\n    int iCursor;      /* The VDBE cursor number used to access this table */\n    Expr *pOn;        /* The ON clause of a join */\n    IdList *pUsing;   /* The USING clause of a join */\n    Bitmask colUsed;  /* Bit N (1<<N) set if column N of pTab is used */\n    char *zIndex;     /* Identifier from \"INDEXED BY <zIndex>\" clause */\n    Index *pIndex;    /* Index structure corresponding to zIndex, if any */\n  } a[1];             /* One entry for each identifier on the list */\n};\n\n/*\n** Permitted values of the SrcList.a.jointype field\n*/\n#define JT_INNER     0x0001    /* Any kind of inner or cross join */\n#define JT_CROSS     0x0002    /* Explicit use of the CROSS keyword */\n#define JT_NATURAL   0x0004    /* True for a \"natural\" join */\n#define JT_LEFT      0x0008    /* Left outer join */\n#define JT_RIGHT     0x0010    /* Right outer join */\n#define JT_OUTER     0x0020    /* The \"OUTER\" keyword is present */\n#define JT_ERROR     0x0040    /* unknown or unsupported join type */\n\n\n/*\n** A WherePlan object holds information that describes a lookup\n** strategy.\n**\n** This object is intended to be opaque outside of the where.c module.\n** It is included here only so that that compiler will know how big it\n** is.  None of the fields in this object should be used outside of\n** the where.c module.\n**\n** Within the union, pIdx is only used when wsFlags&WHERE_INDEXED is true.\n** pTerm is only used when wsFlags&WHERE_MULTI_OR is true.  And pVtabIdx\n** is only used when wsFlags&WHERE_VIRTUALTABLE is true.  It is never the\n** case that more than one of these conditions is true.\n*/\nstruct WherePlan {\n  u32 wsFlags;                   /* WHERE_* flags that describe the strategy */\n  u32 nEq;                       /* Number of == constraints */\n  double nRow;                   /* Estimated number of rows (for EQP) */\n  union {\n    Index *pIdx;                   /* Index when WHERE_INDEXED is true */\n    struct WhereTerm *pTerm;       /* WHERE clause term for OR-search */\n    sqlite3_index_info *pVtabIdx;  /* Virtual table index to use */\n  } u;\n};\n\n/*\n** For each nested loop in a WHERE clause implementation, the WhereInfo\n** structure contains a single instance of this structure.  This structure\n** is intended to be private the the where.c module and should not be\n** access or modified by other modules.\n**\n** The pIdxInfo field is used to help pick the best index on a\n** virtual table.  The pIdxInfo pointer contains indexing\n** information for the i-th table in the FROM clause before reordering.\n** All the pIdxInfo pointers are freed by whereInfoFree() in where.c.\n** All other information in the i-th WhereLevel object for the i-th table\n** after FROM clause ordering.\n*/\nstruct WhereLevel {\n  WherePlan plan;       /* query plan for this element of the FROM clause */\n  int iLeftJoin;        /* Memory cell used to implement LEFT OUTER JOIN */\n  int iTabCur;          /* The VDBE cursor used to access the table */\n  int iIdxCur;          /* The VDBE cursor used to access pIdx */\n  int addrBrk;          /* Jump here to break out of the loop */\n  int addrNxt;          /* Jump here to start the next IN combination */\n  int addrCont;         /* Jump here to continue with the next loop cycle */\n  int addrFirst;        /* First instruction of interior of the loop */\n  u8 iFrom;             /* Which entry in the FROM clause */\n  u8 op, p5;            /* Opcode and P5 of the opcode that ends the loop */\n  int p1, p2;           /* Operands of the opcode used to ends the loop */\n  union {               /* Information that depends on plan.wsFlags */\n    struct {\n      int nIn;              /* Number of entries in aInLoop[] */\n      struct InLoop {\n        int iCur;              /* The VDBE cursor used by this IN operator */\n        int addrInTop;         /* Top of the IN loop */\n      } *aInLoop;           /* Information about each nested IN operator */\n    } in;                 /* Used when plan.wsFlags&WHERE_IN_ABLE */\n  } u;\n\n  /* The following field is really not part of the current level.  But\n  ** we need a place to cache virtual table index information for each\n  ** virtual table in the FROM clause and the WhereLevel structure is\n  ** a convenient place since there is one WhereLevel for each FROM clause\n  ** element.\n  */\n  sqlite3_index_info *pIdxInfo;  /* Index info for n-th source table */\n};\n\n/*\n** Flags appropriate for the wctrlFlags parameter of sqlite3WhereBegin()\n** and the WhereInfo.wctrlFlags member.\n*/\n#define WHERE_ORDERBY_NORMAL   0x0000 /* No-op */\n#define WHERE_ORDERBY_MIN      0x0001 /* ORDER BY processing for min() func */\n#define WHERE_ORDERBY_MAX      0x0002 /* ORDER BY processing for max() func */\n#define WHERE_ONEPASS_DESIRED  0x0004 /* Want to do one-pass UPDATE/DELETE */\n#define WHERE_DUPLICATES_OK    0x0008 /* Ok to return a row more than once */\n#define WHERE_OMIT_OPEN        0x0010 /* Table cursors are already open */\n#define WHERE_OMIT_CLOSE       0x0020 /* Omit close of table & index cursors */\n#define WHERE_FORCE_TABLE      0x0040 /* Do not use an index-only search */\n#define WHERE_ONETABLE_ONLY    0x0080 /* Only code the 1st table in pTabList */\n\n/*\n** The WHERE clause processing routine has two halves.  The\n** first part does the start of the WHERE loop and the second\n** half does the tail of the WHERE loop.  An instance of\n** this structure is returned by the first half and passed\n** into the second half to give some continuity.\n*/\nstruct WhereInfo {\n  Parse *pParse;       /* Parsing and code generating context */\n  u16 wctrlFlags;      /* Flags originally passed to sqlite3WhereBegin() */\n  u8 okOnePass;        /* Ok to use one-pass algorithm for UPDATE or DELETE */\n  u8 untestedTerms;    /* Not all WHERE terms resolved by outer loop */\n  SrcList *pTabList;             /* List of tables in the join */\n  int iTop;                      /* The very beginning of the WHERE loop */\n  int iContinue;                 /* Jump here to continue with next record */\n  int iBreak;                    /* Jump here to break out of the loop */\n  int nLevel;                    /* Number of nested loop */\n  struct WhereClause *pWC;       /* Decomposition of the WHERE clause */\n  double savedNQueryLoop;        /* pParse->nQueryLoop outside the WHERE loop */\n  double nRowOut;                /* Estimated number of output rows */\n  WhereLevel a[1];               /* Information about each nest loop in WHERE */\n};\n\n/*\n** A NameContext defines a context in which to resolve table and column\n** names.  The context consists of a list of tables (the pSrcList) field and\n** a list of named expression (pEList).  The named expression list may\n** be NULL.  The pSrc corresponds to the FROM clause of a SELECT or\n** to the table being operated on by INSERT, UPDATE, or DELETE.  The\n** pEList corresponds to the result set of a SELECT and is NULL for\n** other statements.\n**\n** NameContexts can be nested.  When resolving names, the inner-most \n** context is searched first.  If no match is found, the next outer\n** context is checked.  If there is still no match, the next context\n** is checked.  This process continues until either a match is found\n** or all contexts are check.  When a match is found, the nRef member of\n** the context containing the match is incremented. \n**\n** Each subquery gets a new NameContext.  The pNext field points to the\n** NameContext in the parent query.  Thus the process of scanning the\n** NameContext list corresponds to searching through successively outer\n** subqueries looking for a match.\n*/\nstruct NameContext {\n  Parse *pParse;       /* The parser */\n  SrcList *pSrcList;   /* One or more tables used to resolve names */\n  ExprList *pEList;    /* Optional list of named expressions */\n  int nRef;            /* Number of names resolved by this context */\n  int nErr;            /* Number of errors encountered while resolving names */\n  u8 allowAgg;         /* Aggregate functions allowed here */\n  u8 hasAgg;           /* True if aggregates are seen */\n  u8 isCheck;          /* True if resolving names in a CHECK constraint */\n  int nDepth;          /* Depth of subquery recursion. 1 for no recursion */\n  AggInfo *pAggInfo;   /* Information about aggregates at this level */\n  NameContext *pNext;  /* Next outer name context.  NULL for outermost */\n};\n\n/*\n** An instance of the following structure contains all information\n** needed to generate code for a single SELECT statement.\n**\n** nLimit is set to -1 if there is no LIMIT clause.  nOffset is set to 0.\n** If there is a LIMIT clause, the parser sets nLimit to the value of the\n** limit and nOffset to the value of the offset (or 0 if there is not\n** offset).  But later on, nLimit and nOffset become the memory locations\n** in the VDBE that record the limit and offset counters.\n**\n** addrOpenEphm[] entries contain the address of OP_OpenEphemeral opcodes.\n** These addresses must be stored so that we can go back and fill in\n** the P4_KEYINFO and P2 parameters later.  Neither the KeyInfo nor\n** the number of columns in P2 can be computed at the same time\n** as the OP_OpenEphm instruction is coded because not\n** enough information about the compound query is known at that point.\n** The KeyInfo for addrOpenTran[0] and [1] contains collating sequences\n** for the result set.  The KeyInfo for addrOpenTran[2] contains collating\n** sequences for the ORDER BY clause.\n*/\nstruct Select {\n  ExprList *pEList;      /* The fields of the result */\n  u8 op;                 /* One of: TK_UNION TK_ALL TK_INTERSECT TK_EXCEPT */\n  char affinity;         /* MakeRecord with this affinity for SRT_Set */\n  u16 selFlags;          /* Various SF_* values */\n  SrcList *pSrc;         /* The FROM clause */\n  Expr *pWhere;          /* The WHERE clause */\n  ExprList *pGroupBy;    /* The GROUP BY clause */\n  Expr *pHaving;         /* The HAVING clause */\n  ExprList *pOrderBy;    /* The ORDER BY clause */\n  Select *pPrior;        /* Prior select in a compound select statement */\n  Select *pNext;         /* Next select to the left in a compound */\n  Select *pRightmost;    /* Right-most select in a compound select statement */\n  Expr *pLimit;          /* LIMIT expression. NULL means not used. */\n  Expr *pOffset;         /* OFFSET expression. NULL means not used. */\n  int iLimit, iOffset;   /* Memory registers holding LIMIT & OFFSET counters */\n  int addrOpenEphm[3];   /* OP_OpenEphem opcodes related to this select */\n  double nSelectRow;     /* Estimated number of result rows */\n};\n\n/*\n** Allowed values for Select.selFlags.  The \"SF\" prefix stands for\n** \"Select Flag\".\n*/\n#define SF_Distinct        0x0001  /* Output should be DISTINCT */\n#define SF_Resolved        0x0002  /* Identifiers have been resolved */\n#define SF_Aggregate       0x0004  /* Contains aggregate functions */\n#define SF_UsesEphemeral   0x0008  /* Uses the OpenEphemeral opcode */\n#define SF_Expanded        0x0010  /* sqlite3SelectExpand() called on this */\n#define SF_HasTypeInfo     0x0020  /* FROM subqueries have Table metadata */\n\n\n/*\n** The results of a select can be distributed in several ways.  The\n** \"SRT\" prefix means \"SELECT Result Type\".\n*/\n#define SRT_Union        1  /* Store result as keys in an index */\n#define SRT_Except       2  /* Remove result from a UNION index */\n#define SRT_Exists       3  /* Store 1 if the result is not empty */\n#define SRT_Discard      4  /* Do not save the results anywhere */\n\n/* The ORDER BY clause is ignored for all of the above */\n#define IgnorableOrderby(X) ((X->eDest)<=SRT_Discard)\n\n#define SRT_Output       5  /* Output each row of result */\n#define SRT_Mem          6  /* Store result in a memory cell */\n#define SRT_Set          7  /* Store results as keys in an index */\n#define SRT_Table        8  /* Store result as data with an automatic rowid */\n#define SRT_EphemTab     9  /* Create transient tab and store like SRT_Table */\n#define SRT_Coroutine   10  /* Generate a single row of result */\n\n/*\n** A structure used to customize the behavior of sqlite3Select(). See\n** comments above sqlite3Select() for details.\n*/\ntypedef struct SelectDest SelectDest;\nstruct SelectDest {\n  u8 eDest;         /* How to dispose of the results */\n  u8 affinity;      /* Affinity used when eDest==SRT_Set */\n  int iParm;        /* A parameter used by the eDest disposal method */\n  int iMem;         /* Base register where results are written */\n  int nMem;         /* Number of registers allocated */\n};\n\n/*\n** During code generation of statements that do inserts into AUTOINCREMENT \n** tables, the following information is attached to the Table.u.autoInc.p\n** pointer of each autoincrement table to record some side information that\n** the code generator needs.  We have to keep per-table autoincrement\n** information in case inserts are down within triggers.  Triggers do not\n** normally coordinate their activities, but we do need to coordinate the\n** loading and saving of autoincrement information.\n*/\nstruct AutoincInfo {\n  AutoincInfo *pNext;   /* Next info block in a list of them all */\n  Table *pTab;          /* Table this info block refers to */\n  int iDb;              /* Index in sqlite3.aDb[] of database holding pTab */\n  int regCtr;           /* Memory register holding the rowid counter */\n};\n\n/*\n** Size of the column cache\n*/\n#ifndef SQLITE_N_COLCACHE\n# define SQLITE_N_COLCACHE 10\n#endif\n\n/*\n** At least one instance of the following structure is created for each \n** trigger that may be fired while parsing an INSERT, UPDATE or DELETE\n** statement. All such objects are stored in the linked list headed at\n** Parse.pTriggerPrg and deleted once statement compilation has been\n** completed.\n**\n** A Vdbe sub-program that implements the body and WHEN clause of trigger\n** TriggerPrg.pTrigger, assuming a default ON CONFLICT clause of\n** TriggerPrg.orconf, is stored in the TriggerPrg.pProgram variable.\n** The Parse.pTriggerPrg list never contains two entries with the same\n** values for both pTrigger and orconf.\n**\n** The TriggerPrg.aColmask[0] variable is set to a mask of old.* columns\n** accessed (or set to 0 for triggers fired as a result of INSERT \n** statements). Similarly, the TriggerPrg.aColmask[1] variable is set to\n** a mask of new.* columns used by the program.\n*/\nstruct TriggerPrg {\n  Trigger *pTrigger;      /* Trigger this program was coded from */\n  int orconf;             /* Default ON CONFLICT policy */\n  SubProgram *pProgram;   /* Program implementing pTrigger/orconf */\n  u32 aColmask[2];        /* Masks of old.*, new.* columns accessed */\n  TriggerPrg *pNext;      /* Next entry in Parse.pTriggerPrg list */\n};\n\n/*\n** An SQL parser context.  A copy of this structure is passed through\n** the parser and down into all the parser action routine in order to\n** carry around information that is global to the entire parse.\n**\n** The structure is divided into two parts.  When the parser and code\n** generate call themselves recursively, the first part of the structure\n** is constant but the second part is reset at the beginning and end of\n** each recursion.\n**\n** The nTableLock and aTableLock variables are only used if the shared-cache \n** feature is enabled (if sqlite3Tsd()->useSharedData is true). They are\n** used to store the set of table-locks required by the statement being\n** compiled. Function sqlite3TableLock() is used to add entries to the\n** list.\n*/\nstruct Parse {\n  sqlite3 *db;         /* The main database structure */\n  int rc;              /* Return code from execution */\n  char *zErrMsg;       /* An error message */\n  Vdbe *pVdbe;         /* An engine for executing database bytecode */\n  u8 colNamesSet;      /* TRUE after OP_ColumnName has been issued to pVdbe */\n  u8 nameClash;        /* A permanent table name clashes with temp table name */\n  u8 checkSchema;      /* Causes schema cookie check after an error */\n  u8 nested;           /* Number of nested calls to the parser/code generator */\n  u8 parseError;       /* True after a parsing error.  Ticket #1794 */\n  u8 nTempReg;         /* Number of temporary registers in aTempReg[] */\n  u8 nTempInUse;       /* Number of aTempReg[] currently checked out */\n  int aTempReg[8];     /* Holding area for temporary registers */\n  int nRangeReg;       /* Size of the temporary register block */\n  int iRangeReg;       /* First register in temporary register block */\n  int nErr;            /* Number of errors seen */\n  int nTab;            /* Number of previously allocated VDBE cursors */\n  int nMem;            /* Number of memory cells used so far */\n  int nSet;            /* Number of sets used so far */\n  int ckBase;          /* Base register of data during check constraints */\n  int iCacheLevel;     /* ColCache valid when aColCache[].iLevel<=iCacheLevel */\n  int iCacheCnt;       /* Counter used to generate aColCache[].lru values */\n  u8 nColCache;        /* Number of entries in the column cache */\n  u8 iColCache;        /* Next entry of the cache to replace */\n  struct yColCache {\n    int iTable;           /* Table cursor number */\n    int iColumn;          /* Table column number */\n    u8 tempReg;           /* iReg is a temp register that needs to be freed */\n    int iLevel;           /* Nesting level */\n    int iReg;             /* Reg with value of this column. 0 means none. */\n    int lru;              /* Least recently used entry has the smallest value */\n  } aColCache[SQLITE_N_COLCACHE];  /* One for each column cache entry */\n  u32 writeMask;       /* Start a write transaction on these databases */\n  u32 cookieMask;      /* Bitmask of schema verified databases */\n  u8 isMultiWrite;     /* True if statement may affect/insert multiple rows */\n  u8 mayAbort;         /* True if statement may throw an ABORT exception */\n  int cookieGoto;      /* Address of OP_Goto to cookie verifier subroutine */\n  int cookieValue[SQLITE_MAX_ATTACHED+2];  /* Values of cookies to verify */\n#ifndef SQLITE_OMIT_SHARED_CACHE\n  int nTableLock;        /* Number of locks in aTableLock */\n  TableLock *aTableLock; /* Required table locks for shared-cache mode */\n#endif\n  int regRowid;        /* Register holding rowid of CREATE TABLE entry */\n  int regRoot;         /* Register holding root page number for new objects */\n  AutoincInfo *pAinc;  /* Information about AUTOINCREMENT counters */\n  int nMaxArg;         /* Max args passed to user function by sub-program */\n\n  /* Information used while coding trigger programs. */\n  Parse *pToplevel;    /* Parse structure for main program (or NULL) */\n  Table *pTriggerTab;  /* Table triggers are being coded for */\n  u32 oldmask;         /* Mask of old.* columns referenced */\n  u32 newmask;         /* Mask of new.* columns referenced */\n  u8 eTriggerOp;       /* TK_UPDATE, TK_INSERT or TK_DELETE */\n  u8 eOrconf;          /* Default ON CONFLICT policy for trigger steps */\n  u8 disableTriggers;  /* True to disable triggers */\n  double nQueryLoop;   /* Estimated number of iterations of a query */\n\n  /* Above is constant between recursions.  Below is reset before and after\n  ** each recursion */\n\n  int nVar;            /* Number of '?' variables seen in the SQL so far */\n  int nVarExpr;        /* Number of used slots in apVarExpr[] */\n  int nVarExprAlloc;   /* Number of allocated slots in apVarExpr[] */\n  Expr **apVarExpr;    /* Pointers to :aaa and $aaaa wildcard expressions */\n  Vdbe *pReprepare;    /* VM being reprepared (sqlite3Reprepare()) */\n  int nAlias;          /* Number of aliased result set columns */\n  int nAliasAlloc;     /* Number of allocated slots for aAlias[] */\n  int *aAlias;         /* Register used to hold aliased result */\n  u8 explain;          /* True if the EXPLAIN flag is found on the query */\n  Token sNameToken;    /* Token with unqualified schema object name */\n  Token sLastToken;    /* The last token parsed */\n  const char *zTail;   /* All SQL text past the last semicolon parsed */\n  Table *pNewTable;    /* A table being constructed by CREATE TABLE */\n  Trigger *pNewTrigger;     /* Trigger under construct by a CREATE TRIGGER */\n  const char *zAuthContext; /* The 6th parameter to db->xAuth callbacks */\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  Token sArg;                /* Complete text of a module argument */\n  u8 declareVtab;            /* True if inside sqlite3_declare_vtab() */\n  int nVtabLock;             /* Number of virtual tables to lock */\n  Table **apVtabLock;        /* Pointer to virtual tables needing locking */\n#endif\n  int nHeight;            /* Expression tree height of current sub-select */\n  Table *pZombieTab;      /* List of Table objects to delete after code gen */\n  TriggerPrg *pTriggerPrg;    /* Linked list of coded triggers */\n\n#ifndef SQLITE_OMIT_EXPLAIN\n  int iSelectId;\n  int iNextSelectId;\n#endif\n};\n\n#ifdef SQLITE_OMIT_VIRTUALTABLE\n  #define IN_DECLARE_VTAB 0\n#else\n  #define IN_DECLARE_VTAB (pParse->declareVtab)\n#endif\n\n/*\n** An instance of the following structure can be declared on a stack and used\n** to save the Parse.zAuthContext value so that it can be restored later.\n*/\nstruct AuthContext {\n  const char *zAuthContext;   /* Put saved Parse.zAuthContext here */\n  Parse *pParse;              /* The Parse structure */\n};\n\n/*\n** Bitfield flags for P5 value in OP_Insert and OP_Delete\n*/\n#define OPFLAG_NCHANGE       0x01    /* Set to update db->nChange */\n#define OPFLAG_LASTROWID     0x02    /* Set to update db->lastRowid */\n#define OPFLAG_ISUPDATE      0x04    /* This OP_Insert is an sql UPDATE */\n#define OPFLAG_APPEND        0x08    /* This is likely to be an append */\n#define OPFLAG_USESEEKRESULT 0x10    /* Try to avoid a seek in BtreeInsert() */\n#define OPFLAG_CLEARCACHE    0x20    /* Clear pseudo-table cache in OP_Column */\n\n/*\n * Each trigger present in the database schema is stored as an instance of\n * struct Trigger. \n *\n * Pointers to instances of struct Trigger are stored in two ways.\n * 1. In the \"trigHash\" hash table (part of the sqlite3* that represents the \n *    database). This allows Trigger structures to be retrieved by name.\n * 2. All triggers associated with a single table form a linked list, using the\n *    pNext member of struct Trigger. A pointer to the first element of the\n *    linked list is stored as the \"pTrigger\" member of the associated\n *    struct Table.\n *\n * The \"step_list\" member points to the first element of a linked list\n * containing the SQL statements specified as the trigger program.\n */\nstruct Trigger {\n  char *zName;            /* The name of the trigger                        */\n  char *table;            /* The table or view to which the trigger applies */\n  u8 op;                  /* One of TK_DELETE, TK_UPDATE, TK_INSERT         */\n  u8 tr_tm;               /* One of TRIGGER_BEFORE, TRIGGER_AFTER */\n  Expr *pWhen;            /* The WHEN clause of the expression (may be NULL) */\n  IdList *pColumns;       /* If this is an UPDATE OF <column-list> trigger,\n                             the <column-list> is stored here */\n  Schema *pSchema;        /* Schema containing the trigger */\n  Schema *pTabSchema;     /* Schema containing the table */\n  TriggerStep *step_list; /* Link list of trigger program steps             */\n  Trigger *pNext;         /* Next trigger associated with the table */\n};\n\n/*\n** A trigger is either a BEFORE or an AFTER trigger.  The following constants\n** determine which. \n**\n** If there are multiple triggers, you might of some BEFORE and some AFTER.\n** In that cases, the constants below can be ORed together.\n*/\n#define TRIGGER_BEFORE  1\n#define TRIGGER_AFTER   2\n\n/*\n * An instance of struct TriggerStep is used to store a single SQL statement\n * that is a part of a trigger-program. \n *\n * Instances of struct TriggerStep are stored in a singly linked list (linked\n * using the \"pNext\" member) referenced by the \"step_list\" member of the \n * associated struct Trigger instance. The first element of the linked list is\n * the first step of the trigger-program.\n * \n * The \"op\" member indicates whether this is a \"DELETE\", \"INSERT\", \"UPDATE\" or\n * \"SELECT\" statement. The meanings of the other members is determined by the \n * value of \"op\" as follows:\n *\n * (op == TK_INSERT)\n * orconf    -> stores the ON CONFLICT algorithm\n * pSelect   -> If this is an INSERT INTO ... SELECT ... statement, then\n *              this stores a pointer to the SELECT statement. Otherwise NULL.\n * target    -> A token holding the quoted name of the table to insert into.\n * pExprList -> If this is an INSERT INTO ... VALUES ... statement, then\n *              this stores values to be inserted. Otherwise NULL.\n * pIdList   -> If this is an INSERT INTO ... (<column-names>) VALUES ... \n *              statement, then this stores the column-names to be\n *              inserted into.\n *\n * (op == TK_DELETE)\n * target    -> A token holding the quoted name of the table to delete from.\n * pWhere    -> The WHERE clause of the DELETE statement if one is specified.\n *              Otherwise NULL.\n * \n * (op == TK_UPDATE)\n * target    -> A token holding the quoted name of the table to update rows of.\n * pWhere    -> The WHERE clause of the UPDATE statement if one is specified.\n *              Otherwise NULL.\n * pExprList -> A list of the columns to update and the expressions to update\n *              them to. See sqlite3Update() documentation of \"pChanges\"\n *              argument.\n * \n */\nstruct TriggerStep {\n  u8 op;               /* One of TK_DELETE, TK_UPDATE, TK_INSERT, TK_SELECT */\n  u8 orconf;           /* OE_Rollback etc. */\n  Trigger *pTrig;      /* The trigger that this step is a part of */\n  Select *pSelect;     /* SELECT statment or RHS of INSERT INTO .. SELECT ... */\n  Token target;        /* Target table for DELETE, UPDATE, INSERT */\n  Expr *pWhere;        /* The WHERE clause for DELETE or UPDATE steps */\n  ExprList *pExprList; /* SET clause for UPDATE.  VALUES clause for INSERT */\n  IdList *pIdList;     /* Column names for INSERT */\n  TriggerStep *pNext;  /* Next in the link-list */\n  TriggerStep *pLast;  /* Last element in link-list. Valid for 1st elem only */\n};\n\n/*\n** The following structure contains information used by the sqliteFix...\n** routines as they walk the parse tree to make database references\n** explicit.  \n*/\ntypedef struct DbFixer DbFixer;\nstruct DbFixer {\n  Parse *pParse;      /* The parsing context.  Error messages written here */\n  const char *zDb;    /* Make sure all objects are contained in this database */\n  const char *zType;  /* Type of the container - used for error messages */\n  const Token *pName; /* Name of the container - used for error messages */\n};\n\n/*\n** An objected used to accumulate the text of a string where we\n** do not necessarily know how big the string will be in the end.\n*/\nstruct StrAccum {\n  sqlite3 *db;         /* Optional database for lookaside.  Can be NULL */\n  char *zBase;         /* A base allocation.  Not from malloc. */\n  char *zText;         /* The string collected so far */\n  int  nChar;          /* Length of the string so far */\n  int  nAlloc;         /* Amount of space allocated in zText */\n  int  mxAlloc;        /* Maximum allowed string length */\n  u8   mallocFailed;   /* Becomes true if any memory allocation fails */\n  u8   useMalloc;      /* 0: none,  1: sqlite3DbMalloc,  2: sqlite3_malloc */\n  u8   tooBig;         /* Becomes true if string size exceeds limits */\n};\n\n/*\n** A pointer to this structure is used to communicate information\n** from sqlite3Init and OP_ParseSchema into the sqlite3InitCallback.\n*/\ntypedef struct {\n  sqlite3 *db;        /* The database being initialized */\n  int iDb;            /* 0 for main database.  1 for TEMP, 2.. for ATTACHed */\n  char **pzErrMsg;    /* Error message stored here */\n  int rc;             /* Result code stored here */\n} InitData;\n\n/*\n** Structure containing global configuration data for the SQLite library.\n**\n** This structure also contains some state information.\n*/\nstruct Sqlite3Config {\n  int bMemstat;                     /* True to enable memory status */\n  int bCoreMutex;                   /* True to enable core mutexing */\n  int bFullMutex;                   /* True to enable full mutexing */\n  int mxStrlen;                     /* Maximum string length */\n  int szLookaside;                  /* Default lookaside buffer size */\n  int nLookaside;                   /* Default lookaside buffer count */\n  sqlite3_mem_methods m;            /* Low-level memory allocation interface */\n  sqlite3_mutex_methods mutex;      /* Low-level mutex interface */\n  sqlite3_pcache_methods pcache;    /* Low-level page-cache interface */\n  void *pHeap;                      /* Heap storage space */\n  int nHeap;                        /* Size of pHeap[] */\n  int mnReq, mxReq;                 /* Min and max heap requests sizes */\n  void *pScratch;                   /* Scratch memory */\n  int szScratch;                    /* Size of each scratch buffer */\n  int nScratch;                     /* Number of scratch buffers */\n  void *pPage;                      /* Page cache memory */\n  int szPage;                       /* Size of each page in pPage[] */\n  int nPage;                        /* Number of pages in pPage[] */\n  int mxParserStack;                /* maximum depth of the parser stack */\n  int sharedCacheEnabled;           /* true if shared-cache mode enabled */\n  /* The above might be initialized to non-zero.  The following need to always\n  ** initially be zero, however. */\n  int isInit;                       /* True after initialization has finished */\n  int inProgress;                   /* True while initialization in progress */\n  int isMutexInit;                  /* True after mutexes are initialized */\n  int isMallocInit;                 /* True after malloc is initialized */\n  int isPCacheInit;                 /* True after malloc is initialized */\n  sqlite3_mutex *pInitMutex;        /* Mutex used by sqlite3_initialize() */\n  int nRefInitMutex;                /* Number of users of pInitMutex */\n  void (*xLog)(void*,int,const char*); /* Function for logging */\n  void *pLogArg;                       /* First argument to xLog() */\n};\n\n/*\n** Context pointer passed down through the tree-walk.\n*/\nstruct Walker {\n  int (*xExprCallback)(Walker*, Expr*);     /* Callback for expressions */\n  int (*xSelectCallback)(Walker*,Select*);  /* Callback for SELECTs */\n  Parse *pParse;                            /* Parser context.  */\n  union {                                   /* Extra data for callback */\n    NameContext *pNC;                          /* Naming context */\n    int i;                                     /* Integer value */\n  } u;\n};\n\n/* Forward declarations */\nSQLITE_PRIVATE int sqlite3WalkExpr(Walker*, Expr*);\nSQLITE_PRIVATE int sqlite3WalkExprList(Walker*, ExprList*);\nSQLITE_PRIVATE int sqlite3WalkSelect(Walker*, Select*);\nSQLITE_PRIVATE int sqlite3WalkSelectExpr(Walker*, Select*);\nSQLITE_PRIVATE int sqlite3WalkSelectFrom(Walker*, Select*);\n\n/*\n** Return code from the parse-tree walking primitives and their\n** callbacks.\n*/\n#define WRC_Continue    0   /* Continue down into children */\n#define WRC_Prune       1   /* Omit children but continue walking siblings */\n#define WRC_Abort       2   /* Abandon the tree walk */\n\n/*\n** Assuming zIn points to the first byte of a UTF-8 character,\n** advance zIn to point to the first byte of the next UTF-8 character.\n*/\n#define SQLITE_SKIP_UTF8(zIn) {                        \\\n  if( (*(zIn++))>=0xc0 ){                              \\\n    while( (*zIn & 0xc0)==0x80 ){ zIn++; }             \\\n  }                                                    \\\n}\n\n/*\n** The SQLITE_*_BKPT macros are substitutes for the error codes with\n** the same name but without the _BKPT suffix.  These macros invoke\n** routines that report the line-number on which the error originated\n** using sqlite3_log().  The routines also provide a convenient place\n** to set a debugger breakpoint.\n*/\nSQLITE_PRIVATE int sqlite3CorruptError(int);\nSQLITE_PRIVATE int sqlite3MisuseError(int);\nSQLITE_PRIVATE int sqlite3CantopenError(int);\n#define SQLITE_CORRUPT_BKPT sqlite3CorruptError(__LINE__)\n#define SQLITE_MISUSE_BKPT sqlite3MisuseError(__LINE__)\n#define SQLITE_CANTOPEN_BKPT sqlite3CantopenError(__LINE__)\n\n\n/*\n** FTS4 is really an extension for FTS3.  It is enabled using the\n** SQLITE_ENABLE_FTS3 macro.  But to avoid confusion we also all\n** the SQLITE_ENABLE_FTS4 macro to serve as an alisse for SQLITE_ENABLE_FTS3.\n*/\n#if defined(SQLITE_ENABLE_FTS4) && !defined(SQLITE_ENABLE_FTS3)\n# define SQLITE_ENABLE_FTS3\n#endif\n\n/*\n** The ctype.h header is needed for non-ASCII systems.  It is also\n** needed by FTS3 when FTS3 is included in the amalgamation.\n*/\n#if !defined(SQLITE_ASCII) || \\\n    (defined(SQLITE_ENABLE_FTS3) && defined(SQLITE_AMALGAMATION))\n# include <ctype.h>\n#endif\n\n/*\n** The following macros mimic the standard library functions toupper(),\n** isspace(), isalnum(), isdigit() and isxdigit(), respectively. The\n** sqlite versions only work for ASCII characters, regardless of locale.\n*/\n#ifdef SQLITE_ASCII\n# define sqlite3Toupper(x)  ((x)&~(sqlite3CtypeMap[(unsigned char)(x)]&0x20))\n# define sqlite3Isspace(x)   (sqlite3CtypeMap[(unsigned char)(x)]&0x01)\n# define sqlite3Isalnum(x)   (sqlite3CtypeMap[(unsigned char)(x)]&0x06)\n# define sqlite3Isalpha(x)   (sqlite3CtypeMap[(unsigned char)(x)]&0x02)\n# define sqlite3Isdigit(x)   (sqlite3CtypeMap[(unsigned char)(x)]&0x04)\n# define sqlite3Isxdigit(x)  (sqlite3CtypeMap[(unsigned char)(x)]&0x08)\n# define sqlite3Tolower(x)   (sqlite3UpperToLower[(unsigned char)(x)])\n#else\n# define sqlite3Toupper(x)   toupper((unsigned char)(x))\n# define sqlite3Isspace(x)   isspace((unsigned char)(x))\n# define sqlite3Isalnum(x)   isalnum((unsigned char)(x))\n# define sqlite3Isalpha(x)   isalpha((unsigned char)(x))\n# define sqlite3Isdigit(x)   isdigit((unsigned char)(x))\n# define sqlite3Isxdigit(x)  isxdigit((unsigned char)(x))\n# define sqlite3Tolower(x)   tolower((unsigned char)(x))\n#endif\n\n/*\n** Internal function prototypes\n*/\nSQLITE_PRIVATE int sqlite3StrICmp(const char *, const char *);\nSQLITE_PRIVATE int sqlite3Strlen30(const char*);\n#define sqlite3StrNICmp sqlite3_strnicmp\n\nSQLITE_PRIVATE int sqlite3MallocInit(void);\nSQLITE_PRIVATE void sqlite3MallocEnd(void);\nSQLITE_PRIVATE void *sqlite3Malloc(int);\nSQLITE_PRIVATE void *sqlite3MallocZero(int);\nSQLITE_PRIVATE void *sqlite3DbMallocZero(sqlite3*, int);\nSQLITE_PRIVATE void *sqlite3DbMallocRaw(sqlite3*, int);\nSQLITE_PRIVATE char *sqlite3DbStrDup(sqlite3*,const char*);\nSQLITE_PRIVATE char *sqlite3DbStrNDup(sqlite3*,const char*, int);\nSQLITE_PRIVATE void *sqlite3Realloc(void*, int);\nSQLITE_PRIVATE void *sqlite3DbReallocOrFree(sqlite3 *, void *, int);\nSQLITE_PRIVATE void *sqlite3DbRealloc(sqlite3 *, void *, int);\nSQLITE_PRIVATE void sqlite3DbFree(sqlite3*, void*);\nSQLITE_PRIVATE int sqlite3MallocSize(void*);\nSQLITE_PRIVATE int sqlite3DbMallocSize(sqlite3*, void*);\nSQLITE_PRIVATE void *sqlite3ScratchMalloc(int);\nSQLITE_PRIVATE void sqlite3ScratchFree(void*);\nSQLITE_PRIVATE void *sqlite3PageMalloc(int);\nSQLITE_PRIVATE void sqlite3PageFree(void*);\nSQLITE_PRIVATE void sqlite3MemSetDefault(void);\nSQLITE_PRIVATE void sqlite3BenignMallocHooks(void (*)(void), void (*)(void));\nSQLITE_PRIVATE int sqlite3HeapNearlyFull(void);\n\n/*\n** On systems with ample stack space and that support alloca(), make\n** use of alloca() to obtain space for large automatic objects.  By default,\n** obtain space from malloc().\n**\n** The alloca() routine never returns NULL.  This will cause code paths\n** that deal with sqlite3StackAlloc() failures to be unreachable.\n*/\n#ifdef SQLITE_USE_ALLOCA\n# define sqlite3StackAllocRaw(D,N)   alloca(N)\n# define sqlite3StackAllocZero(D,N)  memset(alloca(N), 0, N)\n# define sqlite3StackFree(D,P)       \n#else\n# define sqlite3StackAllocRaw(D,N)   sqlite3DbMallocRaw(D,N)\n# define sqlite3StackAllocZero(D,N)  sqlite3DbMallocZero(D,N)\n# define sqlite3StackFree(D,P)       sqlite3DbFree(D,P)\n#endif\n\n#ifdef SQLITE_ENABLE_MEMSYS3\nSQLITE_PRIVATE const sqlite3_mem_methods *sqlite3MemGetMemsys3(void);\n#endif\n#ifdef SQLITE_ENABLE_MEMSYS5\nSQLITE_PRIVATE const sqlite3_mem_methods *sqlite3MemGetMemsys5(void);\n#endif\n\n\n#ifndef SQLITE_MUTEX_OMIT\nSQLITE_PRIVATE   sqlite3_mutex_methods const *sqlite3DefaultMutex(void);\nSQLITE_PRIVATE   sqlite3_mutex_methods const *sqlite3NoopMutex(void);\nSQLITE_PRIVATE   sqlite3_mutex *sqlite3MutexAlloc(int);\nSQLITE_PRIVATE   int sqlite3MutexInit(void);\nSQLITE_PRIVATE   int sqlite3MutexEnd(void);\n#endif\n\nSQLITE_PRIVATE int sqlite3StatusValue(int);\nSQLITE_PRIVATE void sqlite3StatusAdd(int, int);\nSQLITE_PRIVATE void sqlite3StatusSet(int, int);\n\n#ifndef SQLITE_OMIT_FLOATING_POINT\nSQLITE_PRIVATE   int sqlite3IsNaN(double);\n#else\n# define sqlite3IsNaN(X)  0\n#endif\n\nSQLITE_PRIVATE void sqlite3VXPrintf(StrAccum*, int, const char*, va_list);\n#ifndef SQLITE_OMIT_TRACE\nSQLITE_PRIVATE void sqlite3XPrintf(StrAccum*, const char*, ...);\n#endif\nSQLITE_PRIVATE char *sqlite3MPrintf(sqlite3*,const char*, ...);\nSQLITE_PRIVATE char *sqlite3VMPrintf(sqlite3*,const char*, va_list);\nSQLITE_PRIVATE char *sqlite3MAppendf(sqlite3*,char*,const char*,...);\n#if defined(SQLITE_TEST) || defined(SQLITE_DEBUG)\nSQLITE_PRIVATE   void sqlite3DebugPrintf(const char*, ...);\n#endif\n#if defined(SQLITE_TEST)\nSQLITE_PRIVATE   void *sqlite3TestTextToPtr(const char*);\n#endif\nSQLITE_PRIVATE void sqlite3SetString(char **, sqlite3*, const char*, ...);\nSQLITE_PRIVATE void sqlite3ErrorMsg(Parse*, const char*, ...);\nSQLITE_PRIVATE int sqlite3Dequote(char*);\nSQLITE_PRIVATE int sqlite3KeywordCode(const unsigned char*, int);\nSQLITE_PRIVATE int sqlite3RunParser(Parse*, const char*, char **);\nSQLITE_PRIVATE void sqlite3FinishCoding(Parse*);\nSQLITE_PRIVATE int sqlite3GetTempReg(Parse*);\nSQLITE_PRIVATE void sqlite3ReleaseTempReg(Parse*,int);\nSQLITE_PRIVATE int sqlite3GetTempRange(Parse*,int);\nSQLITE_PRIVATE void sqlite3ReleaseTempRange(Parse*,int,int);\nSQLITE_PRIVATE Expr *sqlite3ExprAlloc(sqlite3*,int,const Token*,int);\nSQLITE_PRIVATE Expr *sqlite3Expr(sqlite3*,int,const char*);\nSQLITE_PRIVATE void sqlite3ExprAttachSubtrees(sqlite3*,Expr*,Expr*,Expr*);\nSQLITE_PRIVATE Expr *sqlite3PExpr(Parse*, int, Expr*, Expr*, const Token*);\nSQLITE_PRIVATE Expr *sqlite3ExprAnd(sqlite3*,Expr*, Expr*);\nSQLITE_PRIVATE Expr *sqlite3ExprFunction(Parse*,ExprList*, Token*);\nSQLITE_PRIVATE void sqlite3ExprAssignVarNumber(Parse*, Expr*);\nSQLITE_PRIVATE void sqlite3ExprDelete(sqlite3*, Expr*);\nSQLITE_PRIVATE ExprList *sqlite3ExprListAppend(Parse*,ExprList*,Expr*);\nSQLITE_PRIVATE void sqlite3ExprListSetName(Parse*,ExprList*,Token*,int);\nSQLITE_PRIVATE void sqlite3ExprListSetSpan(Parse*,ExprList*,ExprSpan*);\nSQLITE_PRIVATE void sqlite3ExprListDelete(sqlite3*, ExprList*);\nSQLITE_PRIVATE int sqlite3Init(sqlite3*, char**);\nSQLITE_PRIVATE int sqlite3InitCallback(void*, int, char**, char**);\nSQLITE_PRIVATE void sqlite3Pragma(Parse*,Token*,Token*,Token*,int);\nSQLITE_PRIVATE void sqlite3ResetInternalSchema(sqlite3*, int);\nSQLITE_PRIVATE void sqlite3BeginParse(Parse*,int);\nSQLITE_PRIVATE void sqlite3CommitInternalChanges(sqlite3*);\nSQLITE_PRIVATE Table *sqlite3ResultSetOfSelect(Parse*,Select*);\nSQLITE_PRIVATE void sqlite3OpenMasterTable(Parse *, int);\nSQLITE_PRIVATE void sqlite3StartTable(Parse*,Token*,Token*,int,int,int,int);\nSQLITE_PRIVATE void sqlite3AddColumn(Parse*,Token*);\nSQLITE_PRIVATE void sqlite3AddNotNull(Parse*, int);\nSQLITE_PRIVATE void sqlite3AddPrimaryKey(Parse*, ExprList*, int, int, int);\nSQLITE_PRIVATE void sqlite3AddCheckConstraint(Parse*, Expr*);\nSQLITE_PRIVATE void sqlite3AddColumnType(Parse*,Token*);\nSQLITE_PRIVATE void sqlite3AddDefaultValue(Parse*,ExprSpan*);\nSQLITE_PRIVATE void sqlite3AddCollateType(Parse*, Token*);\nSQLITE_PRIVATE void sqlite3EndTable(Parse*,Token*,Token*,Select*);\n\nSQLITE_PRIVATE Bitvec *sqlite3BitvecCreate(u32);\nSQLITE_PRIVATE int sqlite3BitvecTest(Bitvec*, u32);\nSQLITE_PRIVATE int sqlite3BitvecSet(Bitvec*, u32);\nSQLITE_PRIVATE void sqlite3BitvecClear(Bitvec*, u32, void*);\nSQLITE_PRIVATE void sqlite3BitvecDestroy(Bitvec*);\nSQLITE_PRIVATE u32 sqlite3BitvecSize(Bitvec*);\nSQLITE_PRIVATE int sqlite3BitvecBuiltinTest(int,int*);\n\nSQLITE_PRIVATE RowSet *sqlite3RowSetInit(sqlite3*, void*, unsigned int);\nSQLITE_PRIVATE void sqlite3RowSetClear(RowSet*);\nSQLITE_PRIVATE void sqlite3RowSetInsert(RowSet*, i64);\nSQLITE_PRIVATE int sqlite3RowSetTest(RowSet*, u8 iBatch, i64);\nSQLITE_PRIVATE int sqlite3RowSetNext(RowSet*, i64*);\n\nSQLITE_PRIVATE void sqlite3CreateView(Parse*,Token*,Token*,Token*,Select*,int,int);\n\n#if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_VIRTUALTABLE)\nSQLITE_PRIVATE   int sqlite3ViewGetColumnNames(Parse*,Table*);\n#else\n# define sqlite3ViewGetColumnNames(A,B) 0\n#endif\n\nSQLITE_PRIVATE void sqlite3DropTable(Parse*, SrcList*, int, int);\nSQLITE_PRIVATE void sqlite3DeleteTable(sqlite3*, Table*);\n#ifndef SQLITE_OMIT_AUTOINCREMENT\nSQLITE_PRIVATE   void sqlite3AutoincrementBegin(Parse *pParse);\nSQLITE_PRIVATE   void sqlite3AutoincrementEnd(Parse *pParse);\n#else\n# define sqlite3AutoincrementBegin(X)\n# define sqlite3AutoincrementEnd(X)\n#endif\nSQLITE_PRIVATE void sqlite3Insert(Parse*, SrcList*, ExprList*, Select*, IdList*, int);\nSQLITE_PRIVATE void *sqlite3ArrayAllocate(sqlite3*,void*,int,int,int*,int*,int*);\nSQLITE_PRIVATE IdList *sqlite3IdListAppend(sqlite3*, IdList*, Token*);\nSQLITE_PRIVATE int sqlite3IdListIndex(IdList*,const char*);\nSQLITE_PRIVATE SrcList *sqlite3SrcListEnlarge(sqlite3*, SrcList*, int, int);\nSQLITE_PRIVATE SrcList *sqlite3SrcListAppend(sqlite3*, SrcList*, Token*, Token*);\nSQLITE_PRIVATE SrcList *sqlite3SrcListAppendFromTerm(Parse*, SrcList*, Token*, Token*,\n                                      Token*, Select*, Expr*, IdList*);\nSQLITE_PRIVATE void sqlite3SrcListIndexedBy(Parse *, SrcList *, Token *);\nSQLITE_PRIVATE int sqlite3IndexedByLookup(Parse *, struct SrcList_item *);\nSQLITE_PRIVATE void sqlite3SrcListShiftJoinType(SrcList*);\nSQLITE_PRIVATE void sqlite3SrcListAssignCursors(Parse*, SrcList*);\nSQLITE_PRIVATE void sqlite3IdListDelete(sqlite3*, IdList*);\nSQLITE_PRIVATE void sqlite3SrcListDelete(sqlite3*, SrcList*);\nSQLITE_PRIVATE Index *sqlite3CreateIndex(Parse*,Token*,Token*,SrcList*,ExprList*,int,Token*,\n                        Token*, int, int);\nSQLITE_PRIVATE void sqlite3DropIndex(Parse*, SrcList*, int);\nSQLITE_PRIVATE int sqlite3Select(Parse*, Select*, SelectDest*);\nSQLITE_PRIVATE Select *sqlite3SelectNew(Parse*,ExprList*,SrcList*,Expr*,ExprList*,\n                         Expr*,ExprList*,int,Expr*,Expr*);\nSQLITE_PRIVATE void sqlite3SelectDelete(sqlite3*, Select*);\nSQLITE_PRIVATE Table *sqlite3SrcListLookup(Parse*, SrcList*);\nSQLITE_PRIVATE int sqlite3IsReadOnly(Parse*, Table*, int);\nSQLITE_PRIVATE void sqlite3OpenTable(Parse*, int iCur, int iDb, Table*, int);\n#if defined(SQLITE_ENABLE_UPDATE_DELETE_LIMIT) && !defined(SQLITE_OMIT_SUBQUERY)\nSQLITE_PRIVATE Expr *sqlite3LimitWhere(Parse *, SrcList *, Expr *, ExprList *, Expr *, Expr *, char *);\n#endif\nSQLITE_PRIVATE void sqlite3DeleteFrom(Parse*, SrcList*, Expr*);\nSQLITE_PRIVATE void sqlite3Update(Parse*, SrcList*, ExprList*, Expr*, int);\nSQLITE_PRIVATE WhereInfo *sqlite3WhereBegin(Parse*, SrcList*, Expr*, ExprList**, u16);\nSQLITE_PRIVATE void sqlite3WhereEnd(WhereInfo*);\nSQLITE_PRIVATE int sqlite3ExprCodeGetColumn(Parse*, Table*, int, int, int);\nSQLITE_PRIVATE void sqlite3ExprCodeGetColumnOfTable(Vdbe*, Table*, int, int, int);\nSQLITE_PRIVATE void sqlite3ExprCodeMove(Parse*, int, int, int);\nSQLITE_PRIVATE void sqlite3ExprCodeCopy(Parse*, int, int, int);\nSQLITE_PRIVATE void sqlite3ExprCacheStore(Parse*, int, int, int);\nSQLITE_PRIVATE void sqlite3ExprCachePush(Parse*);\nSQLITE_PRIVATE void sqlite3ExprCachePop(Parse*, int);\nSQLITE_PRIVATE void sqlite3ExprCacheRemove(Parse*, int, int);\nSQLITE_PRIVATE void sqlite3ExprCacheClear(Parse*);\nSQLITE_PRIVATE void sqlite3ExprCacheAffinityChange(Parse*, int, int);\nSQLITE_PRIVATE int sqlite3ExprCode(Parse*, Expr*, int);\nSQLITE_PRIVATE int sqlite3ExprCodeTemp(Parse*, Expr*, int*);\nSQLITE_PRIVATE int sqlite3ExprCodeTarget(Parse*, Expr*, int);\nSQLITE_PRIVATE int sqlite3ExprCodeAndCache(Parse*, Expr*, int);\nSQLITE_PRIVATE void sqlite3ExprCodeConstants(Parse*, Expr*);\nSQLITE_PRIVATE int sqlite3ExprCodeExprList(Parse*, ExprList*, int, int);\nSQLITE_PRIVATE void sqlite3ExprIfTrue(Parse*, Expr*, int, int);\nSQLITE_PRIVATE void sqlite3ExprIfFalse(Parse*, Expr*, int, int);\nSQLITE_PRIVATE Table *sqlite3FindTable(sqlite3*,const char*, const char*);\nSQLITE_PRIVATE Table *sqlite3LocateTable(Parse*,int isView,const char*, const char*);\nSQLITE_PRIVATE Index *sqlite3FindIndex(sqlite3*,const char*, const char*);\nSQLITE_PRIVATE void sqlite3UnlinkAndDeleteTable(sqlite3*,int,const char*);\nSQLITE_PRIVATE void sqlite3UnlinkAndDeleteIndex(sqlite3*,int,const char*);\nSQLITE_PRIVATE void sqlite3Vacuum(Parse*);\nSQLITE_PRIVATE int sqlite3RunVacuum(char**, sqlite3*);\nSQLITE_PRIVATE char *sqlite3NameFromToken(sqlite3*, Token*);\nSQLITE_PRIVATE int sqlite3ExprCompare(Expr*, Expr*);\nSQLITE_PRIVATE int sqlite3ExprListCompare(ExprList*, ExprList*);\nSQLITE_PRIVATE void sqlite3ExprAnalyzeAggregates(NameContext*, Expr*);\nSQLITE_PRIVATE void sqlite3ExprAnalyzeAggList(NameContext*,ExprList*);\nSQLITE_PRIVATE Vdbe *sqlite3GetVdbe(Parse*);\nSQLITE_PRIVATE void sqlite3PrngSaveState(void);\nSQLITE_PRIVATE void sqlite3PrngRestoreState(void);\nSQLITE_PRIVATE void sqlite3PrngResetState(void);\nSQLITE_PRIVATE void sqlite3RollbackAll(sqlite3*);\nSQLITE_PRIVATE void sqlite3CodeVerifySchema(Parse*, int);\nSQLITE_PRIVATE void sqlite3BeginTransaction(Parse*, int);\nSQLITE_PRIVATE void sqlite3CommitTransaction(Parse*);\nSQLITE_PRIVATE void sqlite3RollbackTransaction(Parse*);\nSQLITE_PRIVATE void sqlite3Savepoint(Parse*, int, Token*);\nSQLITE_PRIVATE void sqlite3CloseSavepoints(sqlite3 *);\nSQLITE_PRIVATE int sqlite3ExprIsConstant(Expr*);\nSQLITE_PRIVATE int sqlite3ExprIsConstantNotJoin(Expr*);\nSQLITE_PRIVATE int sqlite3ExprIsConstantOrFunction(Expr*);\nSQLITE_PRIVATE int sqlite3ExprIsInteger(Expr*, int*);\nSQLITE_PRIVATE int sqlite3ExprCanBeNull(const Expr*);\nSQLITE_PRIVATE void sqlite3ExprCodeIsNullJump(Vdbe*, const Expr*, int, int);\nSQLITE_PRIVATE int sqlite3ExprNeedsNoAffinityChange(const Expr*, char);\nSQLITE_PRIVATE int sqlite3IsRowid(const char*);\nSQLITE_PRIVATE void sqlite3GenerateRowDelete(Parse*, Table*, int, int, int, Trigger *, int);\nSQLITE_PRIVATE void sqlite3GenerateRowIndexDelete(Parse*, Table*, int, int*);\nSQLITE_PRIVATE int sqlite3GenerateIndexKey(Parse*, Index*, int, int, int);\nSQLITE_PRIVATE void sqlite3GenerateConstraintChecks(Parse*,Table*,int,int,\n                                     int*,int,int,int,int,int*);\nSQLITE_PRIVATE void sqlite3CompleteInsertion(Parse*, Table*, int, int, int*, int, int, int);\nSQLITE_PRIVATE int sqlite3OpenTableAndIndices(Parse*, Table*, int, int);\nSQLITE_PRIVATE void sqlite3BeginWriteOperation(Parse*, int, int);\nSQLITE_PRIVATE void sqlite3MultiWrite(Parse*);\nSQLITE_PRIVATE void sqlite3MayAbort(Parse*);\nSQLITE_PRIVATE void sqlite3HaltConstraint(Parse*, int, char*, int);\nSQLITE_PRIVATE Expr *sqlite3ExprDup(sqlite3*,Expr*,int);\nSQLITE_PRIVATE ExprList *sqlite3ExprListDup(sqlite3*,ExprList*,int);\nSQLITE_PRIVATE SrcList *sqlite3SrcListDup(sqlite3*,SrcList*,int);\nSQLITE_PRIVATE IdList *sqlite3IdListDup(sqlite3*,IdList*);\nSQLITE_PRIVATE Select *sqlite3SelectDup(sqlite3*,Select*,int);\nSQLITE_PRIVATE void sqlite3FuncDefInsert(FuncDefHash*, FuncDef*);\nSQLITE_PRIVATE FuncDef *sqlite3FindFunction(sqlite3*,const char*,int,int,u8,int);\nSQLITE_PRIVATE void sqlite3RegisterBuiltinFunctions(sqlite3*);\nSQLITE_PRIVATE void sqlite3RegisterDateTimeFunctions(void);\nSQLITE_PRIVATE void sqlite3RegisterGlobalFunctions(void);\nSQLITE_PRIVATE int sqlite3SafetyCheckOk(sqlite3*);\nSQLITE_PRIVATE int sqlite3SafetyCheckSickOrOk(sqlite3*);\nSQLITE_PRIVATE void sqlite3ChangeCookie(Parse*, int);\n\n#if !defined(SQLITE_OMIT_VIEW) && !defined(SQLITE_OMIT_TRIGGER)\nSQLITE_PRIVATE void sqlite3MaterializeView(Parse*, Table*, Expr*, int);\n#endif\n\n#ifndef SQLITE_OMIT_TRIGGER\nSQLITE_PRIVATE   void sqlite3BeginTrigger(Parse*, Token*,Token*,int,int,IdList*,SrcList*,\n                           Expr*,int, int);\nSQLITE_PRIVATE   void sqlite3FinishTrigger(Parse*, TriggerStep*, Token*);\nSQLITE_PRIVATE   void sqlite3DropTrigger(Parse*, SrcList*, int);\nSQLITE_PRIVATE   void sqlite3DropTriggerPtr(Parse*, Trigger*);\nSQLITE_PRIVATE   Trigger *sqlite3TriggersExist(Parse *, Table*, int, ExprList*, int *pMask);\nSQLITE_PRIVATE   Trigger *sqlite3TriggerList(Parse *, Table *);\nSQLITE_PRIVATE   void sqlite3CodeRowTrigger(Parse*, Trigger *, int, ExprList*, int, Table *,\n                            int, int, int);\nSQLITE_PRIVATE   void sqlite3CodeRowTriggerDirect(Parse *, Trigger *, Table *, int, int, int);\n  void sqliteViewTriggers(Parse*, Table*, Expr*, int, ExprList*);\nSQLITE_PRIVATE   void sqlite3DeleteTriggerStep(sqlite3*, TriggerStep*);\nSQLITE_PRIVATE   TriggerStep *sqlite3TriggerSelectStep(sqlite3*,Select*);\nSQLITE_PRIVATE   TriggerStep *sqlite3TriggerInsertStep(sqlite3*,Token*, IdList*,\n                                        ExprList*,Select*,u8);\nSQLITE_PRIVATE   TriggerStep *sqlite3TriggerUpdateStep(sqlite3*,Token*,ExprList*, Expr*, u8);\nSQLITE_PRIVATE   TriggerStep *sqlite3TriggerDeleteStep(sqlite3*,Token*, Expr*);\nSQLITE_PRIVATE   void sqlite3DeleteTrigger(sqlite3*, Trigger*);\nSQLITE_PRIVATE   void sqlite3UnlinkAndDeleteTrigger(sqlite3*,int,const char*);\nSQLITE_PRIVATE   u32 sqlite3TriggerColmask(Parse*,Trigger*,ExprList*,int,int,Table*,int);\n# define sqlite3ParseToplevel(p) ((p)->pToplevel ? (p)->pToplevel : (p))\n#else\n# define sqlite3TriggersExist(B,C,D,E,F) 0\n# define sqlite3DeleteTrigger(A,B)\n# define sqlite3DropTriggerPtr(A,B)\n# define sqlite3UnlinkAndDeleteTrigger(A,B,C)\n# define sqlite3CodeRowTrigger(A,B,C,D,E,F,G,H,I)\n# define sqlite3CodeRowTriggerDirect(A,B,C,D,E,F)\n# define sqlite3TriggerList(X, Y) 0\n# define sqlite3ParseToplevel(p) p\n# define sqlite3TriggerColmask(A,B,C,D,E,F,G) 0\n#endif\n\nSQLITE_PRIVATE int sqlite3JoinType(Parse*, Token*, Token*, Token*);\nSQLITE_PRIVATE void sqlite3CreateForeignKey(Parse*, ExprList*, Token*, ExprList*, int);\nSQLITE_PRIVATE void sqlite3DeferForeignKey(Parse*, int);\n#ifndef SQLITE_OMIT_AUTHORIZATION\nSQLITE_PRIVATE   void sqlite3AuthRead(Parse*,Expr*,Schema*,SrcList*);\nSQLITE_PRIVATE   int sqlite3AuthCheck(Parse*,int, const char*, const char*, const char*);\nSQLITE_PRIVATE   void sqlite3AuthContextPush(Parse*, AuthContext*, const char*);\nSQLITE_PRIVATE   void sqlite3AuthContextPop(AuthContext*);\nSQLITE_PRIVATE   int sqlite3AuthReadCol(Parse*, const char *, const char *, int);\n#else\n# define sqlite3AuthRead(a,b,c,d)\n# define sqlite3AuthCheck(a,b,c,d,e)    SQLITE_OK\n# define sqlite3AuthContextPush(a,b,c)\n# define sqlite3AuthContextPop(a)  ((void)(a))\n#endif\nSQLITE_PRIVATE void sqlite3Attach(Parse*, Expr*, Expr*, Expr*);\nSQLITE_PRIVATE void sqlite3Detach(Parse*, Expr*);\nSQLITE_PRIVATE int sqlite3FixInit(DbFixer*, Parse*, int, const char*, const Token*);\nSQLITE_PRIVATE int sqlite3FixSrcList(DbFixer*, SrcList*);\nSQLITE_PRIVATE int sqlite3FixSelect(DbFixer*, Select*);\nSQLITE_PRIVATE int sqlite3FixExpr(DbFixer*, Expr*);\nSQLITE_PRIVATE int sqlite3FixExprList(DbFixer*, ExprList*);\nSQLITE_PRIVATE int sqlite3FixTriggerStep(DbFixer*, TriggerStep*);\nSQLITE_PRIVATE int sqlite3AtoF(const char *z, double*, int, u8);\nSQLITE_PRIVATE int sqlite3GetInt32(const char *, int*);\nSQLITE_PRIVATE int sqlite3Atoi(const char*);\nSQLITE_PRIVATE int sqlite3Utf16ByteLen(const void *pData, int nChar);\nSQLITE_PRIVATE int sqlite3Utf8CharLen(const char *pData, int nByte);\nSQLITE_PRIVATE int sqlite3Utf8Read(const u8*, const u8**);\n\n/*\n** Routines to read and write variable-length integers.  These used to\n** be defined locally, but now we use the varint routines in the util.c\n** file.  Code should use the MACRO forms below, as the Varint32 versions\n** are coded to assume the single byte case is already handled (which \n** the MACRO form does).\n*/\nSQLITE_PRIVATE int sqlite3PutVarint(unsigned char*, u64);\nSQLITE_PRIVATE int sqlite3PutVarint32(unsigned char*, u32);\nSQLITE_PRIVATE u8 sqlite3GetVarint(const unsigned char *, u64 *);\nSQLITE_PRIVATE u8 sqlite3GetVarint32(const unsigned char *, u32 *);\nSQLITE_PRIVATE int sqlite3VarintLen(u64 v);\n\n/*\n** The header of a record consists of a sequence variable-length integers.\n** These integers are almost always small and are encoded as a single byte.\n** The following macros take advantage this fact to provide a fast encode\n** and decode of the integers in a record header.  It is faster for the common\n** case where the integer is a single byte.  It is a little slower when the\n** integer is two or more bytes.  But overall it is faster.\n**\n** The following expressions are equivalent:\n**\n**     x = sqlite3GetVarint32( A, &B );\n**     x = sqlite3PutVarint32( A, B );\n**\n**     x = getVarint32( A, B );\n**     x = putVarint32( A, B );\n**\n*/\n#define getVarint32(A,B)  (u8)((*(A)<(u8)0x80) ? ((B) = (u32)*(A)),1 : sqlite3GetVarint32((A), (u32 *)&(B)))\n#define putVarint32(A,B)  (u8)(((u32)(B)<(u32)0x80) ? (*(A) = (unsigned char)(B)),1 : sqlite3PutVarint32((A), (B)))\n#define getVarint    sqlite3GetVarint\n#define putVarint    sqlite3PutVarint\n\n\nSQLITE_PRIVATE const char *sqlite3IndexAffinityStr(Vdbe *, Index *);\nSQLITE_PRIVATE void sqlite3TableAffinityStr(Vdbe *, Table *);\nSQLITE_PRIVATE char sqlite3CompareAffinity(Expr *pExpr, char aff2);\nSQLITE_PRIVATE int sqlite3IndexAffinityOk(Expr *pExpr, char idx_affinity);\nSQLITE_PRIVATE char sqlite3ExprAffinity(Expr *pExpr);\nSQLITE_PRIVATE int sqlite3Atoi64(const char*, i64*, int, u8);\nSQLITE_PRIVATE void sqlite3Error(sqlite3*, int, const char*,...);\nSQLITE_PRIVATE void *sqlite3HexToBlob(sqlite3*, const char *z, int n);\nSQLITE_PRIVATE int sqlite3TwoPartName(Parse *, Token *, Token *, Token **);\nSQLITE_PRIVATE const char *sqlite3ErrStr(int);\nSQLITE_PRIVATE int sqlite3ReadSchema(Parse *pParse);\nSQLITE_PRIVATE CollSeq *sqlite3FindCollSeq(sqlite3*,u8 enc, const char*,int);\nSQLITE_PRIVATE CollSeq *sqlite3LocateCollSeq(Parse *pParse, const char*zName);\nSQLITE_PRIVATE CollSeq *sqlite3ExprCollSeq(Parse *pParse, Expr *pExpr);\nSQLITE_PRIVATE Expr *sqlite3ExprSetColl(Expr*, CollSeq*);\nSQLITE_PRIVATE Expr *sqlite3ExprSetCollByToken(Parse *pParse, Expr*, Token*);\nSQLITE_PRIVATE int sqlite3CheckCollSeq(Parse *, CollSeq *);\nSQLITE_PRIVATE int sqlite3CheckObjectName(Parse *, const char *);\nSQLITE_PRIVATE void sqlite3VdbeSetChanges(sqlite3 *, int);\nSQLITE_PRIVATE int sqlite3AddInt64(i64*,i64);\nSQLITE_PRIVATE int sqlite3SubInt64(i64*,i64);\nSQLITE_PRIVATE int sqlite3MulInt64(i64*,i64);\nSQLITE_PRIVATE int sqlite3AbsInt32(int);\n\nSQLITE_PRIVATE const void *sqlite3ValueText(sqlite3_value*, u8);\nSQLITE_PRIVATE int sqlite3ValueBytes(sqlite3_value*, u8);\nSQLITE_PRIVATE void sqlite3ValueSetStr(sqlite3_value*, int, const void *,u8, \n                        void(*)(void*));\nSQLITE_PRIVATE void sqlite3ValueFree(sqlite3_value*);\nSQLITE_PRIVATE sqlite3_value *sqlite3ValueNew(sqlite3 *);\nSQLITE_PRIVATE char *sqlite3Utf16to8(sqlite3 *, const void*, int, u8);\n#ifdef SQLITE_ENABLE_STAT2\nSQLITE_PRIVATE char *sqlite3Utf8to16(sqlite3 *, u8, char *, int, int *);\n#endif\nSQLITE_PRIVATE int sqlite3ValueFromExpr(sqlite3 *, Expr *, u8, u8, sqlite3_value **);\nSQLITE_PRIVATE void sqlite3ValueApplyAffinity(sqlite3_value *, u8, u8);\n#ifndef SQLITE_AMALGAMATION\nSQLITE_PRIVATE const unsigned char sqlite3OpcodeProperty[];\nSQLITE_PRIVATE const unsigned char sqlite3UpperToLower[];\nSQLITE_PRIVATE const unsigned char sqlite3CtypeMap[];\nSQLITE_PRIVATE const Token sqlite3IntTokens[];\nSQLITE_PRIVATE SQLITE_WSD struct Sqlite3Config sqlite3Config;\nSQLITE_PRIVATE SQLITE_WSD FuncDefHash sqlite3GlobalFunctions;\n#ifndef SQLITE_OMIT_WSD\nSQLITE_PRIVATE int sqlite3PendingByte;\n#endif\n#endif\nSQLITE_PRIVATE void sqlite3RootPageMoved(Db*, int, int);\nSQLITE_PRIVATE void sqlite3Reindex(Parse*, Token*, Token*);\nSQLITE_PRIVATE void sqlite3AlterFunctions(void);\nSQLITE_PRIVATE void sqlite3AlterRenameTable(Parse*, SrcList*, Token*);\nSQLITE_PRIVATE int sqlite3GetToken(const unsigned char *, int *);\nSQLITE_PRIVATE void sqlite3NestedParse(Parse*, const char*, ...);\nSQLITE_PRIVATE void sqlite3ExpirePreparedStatements(sqlite3*);\nSQLITE_PRIVATE int sqlite3CodeSubselect(Parse *, Expr *, int, int);\nSQLITE_PRIVATE void sqlite3SelectPrep(Parse*, Select*, NameContext*);\nSQLITE_PRIVATE int sqlite3ResolveExprNames(NameContext*, Expr*);\nSQLITE_PRIVATE void sqlite3ResolveSelectNames(Parse*, Select*, NameContext*);\nSQLITE_PRIVATE int sqlite3ResolveOrderGroupBy(Parse*, Select*, ExprList*, const char*);\nSQLITE_PRIVATE void sqlite3ColumnDefault(Vdbe *, Table *, int, int);\nSQLITE_PRIVATE void sqlite3AlterFinishAddColumn(Parse *, Token *);\nSQLITE_PRIVATE void sqlite3AlterBeginAddColumn(Parse *, SrcList *);\nSQLITE_PRIVATE CollSeq *sqlite3GetCollSeq(sqlite3*, u8, CollSeq *, const char*);\nSQLITE_PRIVATE char sqlite3AffinityType(const char*);\nSQLITE_PRIVATE void sqlite3Analyze(Parse*, Token*, Token*);\nSQLITE_PRIVATE int sqlite3InvokeBusyHandler(BusyHandler*);\nSQLITE_PRIVATE int sqlite3FindDb(sqlite3*, Token*);\nSQLITE_PRIVATE int sqlite3FindDbName(sqlite3 *, const char *);\nSQLITE_PRIVATE int sqlite3AnalysisLoad(sqlite3*,int iDB);\nSQLITE_PRIVATE void sqlite3DeleteIndexSamples(sqlite3*,Index*);\nSQLITE_PRIVATE void sqlite3DefaultRowEst(Index*);\nSQLITE_PRIVATE void sqlite3RegisterLikeFunctions(sqlite3*, int);\nSQLITE_PRIVATE int sqlite3IsLikeFunction(sqlite3*,Expr*,int*,char*);\nSQLITE_PRIVATE void sqlite3MinimumFileFormat(Parse*, int, int);\nSQLITE_PRIVATE void sqlite3SchemaFree(void *);\nSQLITE_PRIVATE Schema *sqlite3SchemaGet(sqlite3 *, Btree *);\nSQLITE_PRIVATE int sqlite3SchemaToIndex(sqlite3 *db, Schema *);\nSQLITE_PRIVATE KeyInfo *sqlite3IndexKeyinfo(Parse *, Index *);\nSQLITE_PRIVATE int sqlite3CreateFunc(sqlite3 *, const char *, int, int, void *, \n  void (*)(sqlite3_context*,int,sqlite3_value **),\n  void (*)(sqlite3_context*,int,sqlite3_value **), void (*)(sqlite3_context*),\n  FuncDestructor *pDestructor\n);\nSQLITE_PRIVATE int sqlite3ApiExit(sqlite3 *db, int);\nSQLITE_PRIVATE int sqlite3OpenTempDatabase(Parse *);\n\nSQLITE_PRIVATE void sqlite3StrAccumInit(StrAccum*, char*, int, int);\nSQLITE_PRIVATE void sqlite3StrAccumAppend(StrAccum*,const char*,int);\nSQLITE_PRIVATE char *sqlite3StrAccumFinish(StrAccum*);\nSQLITE_PRIVATE void sqlite3StrAccumReset(StrAccum*);\nSQLITE_PRIVATE void sqlite3SelectDestInit(SelectDest*,int,int);\nSQLITE_PRIVATE Expr *sqlite3CreateColumnExpr(sqlite3 *, SrcList *, int, int);\n\nSQLITE_PRIVATE void sqlite3BackupRestart(sqlite3_backup *);\nSQLITE_PRIVATE void sqlite3BackupUpdate(sqlite3_backup *, Pgno, const u8 *);\n\n/*\n** The interface to the LEMON-generated parser\n*/\nSQLITE_PRIVATE void *sqlite3ParserAlloc(void*(*)(size_t));\nSQLITE_PRIVATE void sqlite3ParserFree(void*, void(*)(void*));\nSQLITE_PRIVATE void sqlite3Parser(void*, int, Token, Parse*);\n#ifdef YYTRACKMAXSTACKDEPTH\nSQLITE_PRIVATE   int sqlite3ParserStackPeak(void*);\n#endif\n\nSQLITE_PRIVATE void sqlite3AutoLoadExtensions(sqlite3*);\n#ifndef SQLITE_OMIT_LOAD_EXTENSION\nSQLITE_PRIVATE   void sqlite3CloseExtensions(sqlite3*);\n#else\n# define sqlite3CloseExtensions(X)\n#endif\n\n#ifndef SQLITE_OMIT_SHARED_CACHE\nSQLITE_PRIVATE   void sqlite3TableLock(Parse *, int, int, u8, const char *);\n#else\n  #define sqlite3TableLock(v,w,x,y,z)\n#endif\n\n#ifdef SQLITE_TEST\nSQLITE_PRIVATE   int sqlite3Utf8To8(unsigned char*);\n#endif\n\n#ifdef SQLITE_OMIT_VIRTUALTABLE\n#  define sqlite3VtabClear(Y)\n#  define sqlite3VtabSync(X,Y) SQLITE_OK\n#  define sqlite3VtabRollback(X)\n#  define sqlite3VtabCommit(X)\n#  define sqlite3VtabInSync(db) 0\n#  define sqlite3VtabLock(X) \n#  define sqlite3VtabUnlock(X)\n#  define sqlite3VtabUnlockList(X)\n#else\nSQLITE_PRIVATE    void sqlite3VtabClear(sqlite3 *db, Table*);\nSQLITE_PRIVATE    int sqlite3VtabSync(sqlite3 *db, char **);\nSQLITE_PRIVATE    int sqlite3VtabRollback(sqlite3 *db);\nSQLITE_PRIVATE    int sqlite3VtabCommit(sqlite3 *db);\nSQLITE_PRIVATE    void sqlite3VtabLock(VTable *);\nSQLITE_PRIVATE    void sqlite3VtabUnlock(VTable *);\nSQLITE_PRIVATE    void sqlite3VtabUnlockList(sqlite3*);\n#  define sqlite3VtabInSync(db) ((db)->nVTrans>0 && (db)->aVTrans==0)\n#endif\nSQLITE_PRIVATE void sqlite3VtabMakeWritable(Parse*,Table*);\nSQLITE_PRIVATE void sqlite3VtabBeginParse(Parse*, Token*, Token*, Token*);\nSQLITE_PRIVATE void sqlite3VtabFinishParse(Parse*, Token*);\nSQLITE_PRIVATE void sqlite3VtabArgInit(Parse*);\nSQLITE_PRIVATE void sqlite3VtabArgExtend(Parse*, Token*);\nSQLITE_PRIVATE int sqlite3VtabCallCreate(sqlite3*, int, const char *, char **);\nSQLITE_PRIVATE int sqlite3VtabCallConnect(Parse*, Table*);\nSQLITE_PRIVATE int sqlite3VtabCallDestroy(sqlite3*, int, const char *);\nSQLITE_PRIVATE int sqlite3VtabBegin(sqlite3 *, VTable *);\nSQLITE_PRIVATE FuncDef *sqlite3VtabOverloadFunction(sqlite3 *,FuncDef*, int nArg, Expr*);\nSQLITE_PRIVATE void sqlite3InvalidFunction(sqlite3_context*,int,sqlite3_value**);\nSQLITE_PRIVATE int sqlite3VdbeParameterIndex(Vdbe*, const char*, int);\nSQLITE_PRIVATE int sqlite3TransferBindings(sqlite3_stmt *, sqlite3_stmt *);\nSQLITE_PRIVATE int sqlite3Reprepare(Vdbe*);\nSQLITE_PRIVATE void sqlite3ExprListCheckLength(Parse*, ExprList*, const char*);\nSQLITE_PRIVATE CollSeq *sqlite3BinaryCompareCollSeq(Parse *, Expr *, Expr *);\nSQLITE_PRIVATE int sqlite3TempInMemory(const sqlite3*);\nSQLITE_PRIVATE VTable *sqlite3GetVTable(sqlite3*, Table*);\nSQLITE_PRIVATE const char *sqlite3JournalModename(int);\nSQLITE_PRIVATE int sqlite3Checkpoint(sqlite3*, int, int, int*, int*);\nSQLITE_PRIVATE int sqlite3WalDefaultHook(void*,sqlite3*,const char*,int);\n\n/* Declarations for functions in fkey.c. All of these are replaced by\n** no-op macros if OMIT_FOREIGN_KEY is defined. In this case no foreign\n** key functionality is available. If OMIT_TRIGGER is defined but\n** OMIT_FOREIGN_KEY is not, only some of the functions are no-oped. In\n** this case foreign keys are parsed, but no other functionality is \n** provided (enforcement of FK constraints requires the triggers sub-system).\n*/\n#if !defined(SQLITE_OMIT_FOREIGN_KEY) && !defined(SQLITE_OMIT_TRIGGER)\nSQLITE_PRIVATE   void sqlite3FkCheck(Parse*, Table*, int, int);\nSQLITE_PRIVATE   void sqlite3FkDropTable(Parse*, SrcList *, Table*);\nSQLITE_PRIVATE   void sqlite3FkActions(Parse*, Table*, ExprList*, int);\nSQLITE_PRIVATE   int sqlite3FkRequired(Parse*, Table*, int*, int);\nSQLITE_PRIVATE   u32 sqlite3FkOldmask(Parse*, Table*);\nSQLITE_PRIVATE   FKey *sqlite3FkReferences(Table *);\n#else\n  #define sqlite3FkActions(a,b,c,d)\n  #define sqlite3FkCheck(a,b,c,d)\n  #define sqlite3FkDropTable(a,b,c)\n  #define sqlite3FkOldmask(a,b)      0\n  #define sqlite3FkRequired(a,b,c,d) 0\n#endif\n#ifndef SQLITE_OMIT_FOREIGN_KEY\nSQLITE_PRIVATE   void sqlite3FkDelete(sqlite3 *, Table*);\n#else\n  #define sqlite3FkDelete(a,b)\n#endif\n\n\n/*\n** Available fault injectors.  Should be numbered beginning with 0.\n*/\n#define SQLITE_FAULTINJECTOR_MALLOC     0\n#define SQLITE_FAULTINJECTOR_COUNT      1\n\n/*\n** The interface to the code in fault.c used for identifying \"benign\"\n** malloc failures. This is only present if SQLITE_OMIT_BUILTIN_TEST\n** is not defined.\n*/\n#ifndef SQLITE_OMIT_BUILTIN_TEST\nSQLITE_PRIVATE   void sqlite3BeginBenignMalloc(void);\nSQLITE_PRIVATE   void sqlite3EndBenignMalloc(void);\n#else\n  #define sqlite3BeginBenignMalloc()\n  #define sqlite3EndBenignMalloc()\n#endif\n\n#define IN_INDEX_ROWID           1\n#define IN_INDEX_EPH             2\n#define IN_INDEX_INDEX           3\nSQLITE_PRIVATE int sqlite3FindInIndex(Parse *, Expr *, int*);\n\n#ifdef SQLITE_ENABLE_ATOMIC_WRITE\nSQLITE_PRIVATE   int sqlite3JournalOpen(sqlite3_vfs *, const char *, sqlite3_file *, int, int);\nSQLITE_PRIVATE   int sqlite3JournalSize(sqlite3_vfs *);\nSQLITE_PRIVATE   int sqlite3JournalCreate(sqlite3_file *);\n#else\n  #define sqlite3JournalSize(pVfs) ((pVfs)->szOsFile)\n#endif\n\nSQLITE_PRIVATE void sqlite3MemJournalOpen(sqlite3_file *);\nSQLITE_PRIVATE int sqlite3MemJournalSize(void);\nSQLITE_PRIVATE int sqlite3IsMemJournal(sqlite3_file *);\n\n#if SQLITE_MAX_EXPR_DEPTH>0\nSQLITE_PRIVATE   void sqlite3ExprSetHeight(Parse *pParse, Expr *p);\nSQLITE_PRIVATE   int sqlite3SelectExprHeight(Select *);\nSQLITE_PRIVATE   int sqlite3ExprCheckHeight(Parse*, int);\n#else\n  #define sqlite3ExprSetHeight(x,y)\n  #define sqlite3SelectExprHeight(x) 0\n  #define sqlite3ExprCheckHeight(x,y)\n#endif\n\nSQLITE_PRIVATE u32 sqlite3Get4byte(const u8*);\nSQLITE_PRIVATE void sqlite3Put4byte(u8*, u32);\n\n#ifdef SQLITE_ENABLE_UNLOCK_NOTIFY\nSQLITE_PRIVATE   void sqlite3ConnectionBlocked(sqlite3 *, sqlite3 *);\nSQLITE_PRIVATE   void sqlite3ConnectionUnlocked(sqlite3 *db);\nSQLITE_PRIVATE   void sqlite3ConnectionClosed(sqlite3 *db);\n#else\n  #define sqlite3ConnectionBlocked(x,y)\n  #define sqlite3ConnectionUnlocked(x)\n  #define sqlite3ConnectionClosed(x)\n#endif\n\n#ifdef SQLITE_DEBUG\nSQLITE_PRIVATE   void sqlite3ParserTrace(FILE*, char *);\n#endif\n\n/*\n** If the SQLITE_ENABLE IOTRACE exists then the global variable\n** sqlite3IoTrace is a pointer to a printf-like routine used to\n** print I/O tracing messages. \n*/\n#ifdef SQLITE_ENABLE_IOTRACE\n# define IOTRACE(A)  if( sqlite3IoTrace ){ sqlite3IoTrace A; }\nSQLITE_PRIVATE   void sqlite3VdbeIOTraceSql(Vdbe*);\nSQLITE_PRIVATE void (*sqlite3IoTrace)(const char*,...);\n#else\n# define IOTRACE(A)\n# define sqlite3VdbeIOTraceSql(X)\n#endif\n\n/*\n** These routines are available for the mem2.c debugging memory allocator\n** only.  They are used to verify that different \"types\" of memory\n** allocations are properly tracked by the system.\n**\n** sqlite3MemdebugSetType() sets the \"type\" of an allocation to one of\n** the MEMTYPE_* macros defined below.  The type must be a bitmask with\n** a single bit set.\n**\n** sqlite3MemdebugHasType() returns true if any of the bits in its second\n** argument match the type set by the previous sqlite3MemdebugSetType().\n** sqlite3MemdebugHasType() is intended for use inside assert() statements.\n**\n** sqlite3MemdebugNoType() returns true if none of the bits in its second\n** argument match the type set by the previous sqlite3MemdebugSetType().\n**\n** Perhaps the most important point is the difference between MEMTYPE_HEAP\n** and MEMTYPE_LOOKASIDE.  If an allocation is MEMTYPE_LOOKASIDE, that means\n** it might have been allocated by lookaside, except the allocation was\n** too large or lookaside was already full.  It is important to verify\n** that allocations that might have been satisfied by lookaside are not\n** passed back to non-lookaside free() routines.  Asserts such as the\n** example above are placed on the non-lookaside free() routines to verify\n** this constraint. \n**\n** All of this is no-op for a production build.  It only comes into\n** play when the SQLITE_MEMDEBUG compile-time option is used.\n*/\n#ifdef SQLITE_MEMDEBUG\nSQLITE_PRIVATE   void sqlite3MemdebugSetType(void*,u8);\nSQLITE_PRIVATE   int sqlite3MemdebugHasType(void*,u8);\nSQLITE_PRIVATE   int sqlite3MemdebugNoType(void*,u8);\n#else\n# define sqlite3MemdebugSetType(X,Y)  /* no-op */\n# define sqlite3MemdebugHasType(X,Y)  1\n# define sqlite3MemdebugNoType(X,Y)   1\n#endif\n#define MEMTYPE_HEAP       0x01  /* General heap allocations */\n#define MEMTYPE_LOOKASIDE  0x02  /* Might have been lookaside memory */\n#define MEMTYPE_SCRATCH    0x04  /* Scratch allocations */\n#define MEMTYPE_PCACHE     0x08  /* Page cache allocations */\n#define MEMTYPE_DB         0x10  /* Uses sqlite3DbMalloc, not sqlite_malloc */\n\n#endif /* _SQLITEINT_H_ */\n\n/************** End of sqliteInt.h *******************************************/\n/************** Begin file global.c ******************************************/\n/*\n** 2008 June 13\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n**\n** This file contains definitions of global variables and contants.\n*/\n\n/* An array to map all upper-case characters into their corresponding\n** lower-case character. \n**\n** SQLite only considers US-ASCII (or EBCDIC) characters.  We do not\n** handle case conversions for the UTF character set since the tables\n** involved are nearly as big or bigger than SQLite itself.\n*/\nSQLITE_PRIVATE const unsigned char sqlite3UpperToLower[] = {\n#ifdef SQLITE_ASCII\n      0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,\n     18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35,\n     36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53,\n     54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 97, 98, 99,100,101,102,103,\n    104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,119,120,121,\n    122, 91, 92, 93, 94, 95, 96, 97, 98, 99,100,101,102,103,104,105,106,107,\n    108,109,110,111,112,113,114,115,116,117,118,119,120,121,122,123,124,125,\n    126,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,\n    144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,160,161,\n    162,163,164,165,166,167,168,169,170,171,172,173,174,175,176,177,178,179,\n    180,181,182,183,184,185,186,187,188,189,190,191,192,193,194,195,196,197,\n    198,199,200,201,202,203,204,205,206,207,208,209,210,211,212,213,214,215,\n    216,217,218,219,220,221,222,223,224,225,226,227,228,229,230,231,232,233,\n    234,235,236,237,238,239,240,241,242,243,244,245,246,247,248,249,250,251,\n    252,253,254,255\n#endif\n#ifdef SQLITE_EBCDIC\n      0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, /* 0x */\n     16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, /* 1x */\n     32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, /* 2x */\n     48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, /* 3x */\n     64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, /* 4x */\n     80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, /* 5x */\n     96, 97, 66, 67, 68, 69, 70, 71, 72, 73,106,107,108,109,110,111, /* 6x */\n    112, 81, 82, 83, 84, 85, 86, 87, 88, 89,122,123,124,125,126,127, /* 7x */\n    128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143, /* 8x */\n    144,145,146,147,148,149,150,151,152,153,154,155,156,157,156,159, /* 9x */\n    160,161,162,163,164,165,166,167,168,169,170,171,140,141,142,175, /* Ax */\n    176,177,178,179,180,181,182,183,184,185,186,187,188,189,190,191, /* Bx */\n    192,129,130,131,132,133,134,135,136,137,202,203,204,205,206,207, /* Cx */\n    208,145,146,147,148,149,150,151,152,153,218,219,220,221,222,223, /* Dx */\n    224,225,162,163,164,165,166,167,168,169,232,203,204,205,206,207, /* Ex */\n    239,240,241,242,243,244,245,246,247,248,249,219,220,221,222,255, /* Fx */\n#endif\n};\n\n/*\n** The following 256 byte lookup table is used to support SQLites built-in\n** equivalents to the following standard library functions:\n**\n**   isspace()                        0x01\n**   isalpha()                        0x02\n**   isdigit()                        0x04\n**   isalnum()                        0x06\n**   isxdigit()                       0x08\n**   toupper()                        0x20\n**   SQLite identifier character      0x40\n**\n** Bit 0x20 is set if the mapped character requires translation to upper\n** case. i.e. if the character is a lower-case ASCII character.\n** If x is a lower-case ASCII character, then its upper-case equivalent\n** is (x - 0x20). Therefore toupper() can be implemented as:\n**\n**   (x & ~(map[x]&0x20))\n**\n** Standard function tolower() is implemented using the sqlite3UpperToLower[]\n** array. tolower() is used more often than toupper() by SQLite.\n**\n** Bit 0x40 is set if the character non-alphanumeric and can be used in an \n** SQLite identifier.  Identifiers are alphanumerics, \"_\", \"$\", and any\n** non-ASCII UTF character. Hence the test for whether or not a character is\n** part of an identifier is 0x46.\n**\n** SQLite's versions are identical to the standard versions assuming a\n** locale of \"C\". They are implemented as macros in sqliteInt.h.\n*/\n#ifdef SQLITE_ASCII\nSQLITE_PRIVATE const unsigned char sqlite3CtypeMap[256] = {\n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /* 00..07    ........ */\n  0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00,  /* 08..0f    ........ */\n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /* 10..17    ........ */\n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /* 18..1f    ........ */\n  0x01, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,  /* 20..27     !\"#$%&' */\n  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /* 28..2f    ()*+,-./ */\n  0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c, 0x0c,  /* 30..37    01234567 */\n  0x0c, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  /* 38..3f    89:;<=>? */\n\n  0x00, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x02,  /* 40..47    @ABCDEFG */\n  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  /* 48..4f    HIJKLMNO */\n  0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,  /* 50..57    PQRSTUVW */\n  0x02, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x40,  /* 58..5f    XYZ[\\]^_ */\n  0x00, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x2a, 0x22,  /* 60..67    `abcdefg */\n  0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,  /* 68..6f    hijklmno */\n  0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22, 0x22,  /* 70..77    pqrstuvw */\n  0x22, 0x22, 0x22, 0x00, 0x00, 0x00, 0x00, 0x00,  /* 78..7f    xyz{|}~. */\n\n  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* 80..87    ........ */\n  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* 88..8f    ........ */\n  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* 90..97    ........ */\n  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* 98..9f    ........ */\n  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* a0..a7    ........ */\n  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* a8..af    ........ */\n  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* b0..b7    ........ */\n  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* b8..bf    ........ */\n\n  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* c0..c7    ........ */\n  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* c8..cf    ........ */\n  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* d0..d7    ........ */\n  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* d8..df    ........ */\n  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* e0..e7    ........ */\n  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* e8..ef    ........ */\n  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40,  /* f0..f7    ........ */\n  0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40   /* f8..ff    ........ */\n};\n#endif\n\n\n\n/*\n** The following singleton contains the global configuration for\n** the SQLite library.\n*/\nSQLITE_PRIVATE SQLITE_WSD struct Sqlite3Config sqlite3Config = {\n   SQLITE_DEFAULT_MEMSTATUS,  /* bMemstat */\n   1,                         /* bCoreMutex */\n   SQLITE_THREADSAFE==1,      /* bFullMutex */\n   0x7ffffffe,                /* mxStrlen */\n   100,                       /* szLookaside */\n   500,                       /* nLookaside */\n   {0,0,0,0,0,0,0,0},         /* m */\n   {0,0,0,0,0,0,0,0,0},       /* mutex */\n   {0,0,0,0,0,0,0,0,0,0,0},   /* pcache */\n   (void*)0,                  /* pHeap */\n   0,                         /* nHeap */\n   0, 0,                      /* mnHeap, mxHeap */\n   (void*)0,                  /* pScratch */\n   0,                         /* szScratch */\n   0,                         /* nScratch */\n   (void*)0,                  /* pPage */\n   0,                         /* szPage */\n   0,                         /* nPage */\n   0,                         /* mxParserStack */\n   0,                         /* sharedCacheEnabled */\n   /* All the rest should always be initialized to zero */\n   0,                         /* isInit */\n   0,                         /* inProgress */\n   0,                         /* isMutexInit */\n   0,                         /* isMallocInit */\n   0,                         /* isPCacheInit */\n   0,                         /* pInitMutex */\n   0,                         /* nRefInitMutex */\n   0,                         /* xLog */\n   0,                         /* pLogArg */\n};\n\n\n/*\n** Hash table for global functions - functions common to all\n** database connections.  After initialization, this table is\n** read-only.\n*/\nSQLITE_PRIVATE SQLITE_WSD FuncDefHash sqlite3GlobalFunctions;\n\n/*\n** Constant tokens for values 0 and 1.\n*/\nSQLITE_PRIVATE const Token sqlite3IntTokens[] = {\n   { \"0\", 1 },\n   { \"1\", 1 }\n};\n\n\n/*\n** The value of the \"pending\" byte must be 0x40000000 (1 byte past the\n** 1-gibabyte boundary) in a compatible database.  SQLite never uses\n** the database page that contains the pending byte.  It never attempts\n** to read or write that page.  The pending byte page is set assign\n** for use by the VFS layers as space for managing file locks.\n**\n** During testing, it is often desirable to move the pending byte to\n** a different position in the file.  This allows code that has to\n** deal with the pending byte to run on files that are much smaller\n** than 1 GiB.  The sqlite3_test_control() interface can be used to\n** move the pending byte.\n**\n** IMPORTANT:  Changing the pending byte to any value other than\n** 0x40000000 results in an incompatible database file format!\n** Changing the pending byte during operating results in undefined\n** and dileterious behavior.\n*/\n#ifndef SQLITE_OMIT_WSD\nSQLITE_PRIVATE int sqlite3PendingByte = 0x40000000;\n#endif\n\n/*\n** Properties of opcodes.  The OPFLG_INITIALIZER macro is\n** created by mkopcodeh.awk during compilation.  Data is obtained\n** from the comments following the \"case OP_xxxx:\" statements in\n** the vdbe.c file.  \n*/\nSQLITE_PRIVATE const unsigned char sqlite3OpcodeProperty[] = OPFLG_INITIALIZER;\n\n/************** End of global.c **********************************************/\n/************** Begin file ctime.c *******************************************/\n/*\n** 2010 February 23\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n**\n** This file implements routines used to report what compile-time options\n** SQLite was built with.\n*/\n\n#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS\n\n\n/*\n** An array of names of all compile-time options.  This array should \n** be sorted A-Z.\n**\n** This array looks large, but in a typical installation actually uses\n** only a handful of compile-time options, so most times this array is usually\n** rather short and uses little memory space.\n*/\nstatic const char * const azCompileOpt[] = {\n\n/* These macros are provided to \"stringify\" the value of the define\n** for those options in which the value is meaningful. */\n#define CTIMEOPT_VAL_(opt) #opt\n#define CTIMEOPT_VAL(opt) CTIMEOPT_VAL_(opt)\n\n#ifdef SQLITE_32BIT_ROWID\n  \"32BIT_ROWID\",\n#endif\n#ifdef SQLITE_4_BYTE_ALIGNED_MALLOC\n  \"4_BYTE_ALIGNED_MALLOC\",\n#endif\n#ifdef SQLITE_CASE_SENSITIVE_LIKE\n  \"CASE_SENSITIVE_LIKE\",\n#endif\n#ifdef SQLITE_CHECK_PAGES\n  \"CHECK_PAGES\",\n#endif\n#ifdef SQLITE_COVERAGE_TEST\n  \"COVERAGE_TEST\",\n#endif\n#ifdef SQLITE_DEBUG\n  \"DEBUG\",\n#endif\n#ifdef SQLITE_DEFAULT_LOCKING_MODE\n  \"DEFAULT_LOCKING_MODE=\" CTIMEOPT_VAL(SQLITE_DEFAULT_LOCKING_MODE),\n#endif\n#ifdef SQLITE_DISABLE_DIRSYNC\n  \"DISABLE_DIRSYNC\",\n#endif\n#ifdef SQLITE_DISABLE_LFS\n  \"DISABLE_LFS\",\n#endif\n#ifdef SQLITE_ENABLE_ATOMIC_WRITE\n  \"ENABLE_ATOMIC_WRITE\",\n#endif\n#ifdef SQLITE_ENABLE_CEROD\n  \"ENABLE_CEROD\",\n#endif\n#ifdef SQLITE_ENABLE_COLUMN_METADATA\n  \"ENABLE_COLUMN_METADATA\",\n#endif\n#ifdef SQLITE_ENABLE_EXPENSIVE_ASSERT\n  \"ENABLE_EXPENSIVE_ASSERT\",\n#endif\n#ifdef SQLITE_ENABLE_FTS1\n  \"ENABLE_FTS1\",\n#endif\n#ifdef SQLITE_ENABLE_FTS2\n  \"ENABLE_FTS2\",\n#endif\n#ifdef SQLITE_ENABLE_FTS3\n  \"ENABLE_FTS3\",\n#endif\n#ifdef SQLITE_ENABLE_FTS3_PARENTHESIS\n  \"ENABLE_FTS3_PARENTHESIS\",\n#endif\n#ifdef SQLITE_ENABLE_FTS4\n  \"ENABLE_FTS4\",\n#endif\n#ifdef SQLITE_ENABLE_ICU\n  \"ENABLE_ICU\",\n#endif\n#ifdef SQLITE_ENABLE_IOTRACE\n  \"ENABLE_IOTRACE\",\n#endif\n#ifdef SQLITE_ENABLE_LOAD_EXTENSION\n  \"ENABLE_LOAD_EXTENSION\",\n#endif\n#ifdef SQLITE_ENABLE_LOCKING_STYLE\n  \"ENABLE_LOCKING_STYLE=\" CTIMEOPT_VAL(SQLITE_ENABLE_LOCKING_STYLE),\n#endif\n#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT\n  \"ENABLE_MEMORY_MANAGEMENT\",\n#endif\n#ifdef SQLITE_ENABLE_MEMSYS3\n  \"ENABLE_MEMSYS3\",\n#endif\n#ifdef SQLITE_ENABLE_MEMSYS5\n  \"ENABLE_MEMSYS5\",\n#endif\n#ifdef SQLITE_ENABLE_OVERSIZE_CELL_CHECK\n  \"ENABLE_OVERSIZE_CELL_CHECK\",\n#endif\n#ifdef SQLITE_ENABLE_RTREE\n  \"ENABLE_RTREE\",\n#endif\n#ifdef SQLITE_ENABLE_STAT2\n  \"ENABLE_STAT2\",\n#endif\n#ifdef SQLITE_ENABLE_UNLOCK_NOTIFY\n  \"ENABLE_UNLOCK_NOTIFY\",\n#endif\n#ifdef SQLITE_ENABLE_UPDATE_DELETE_LIMIT\n  \"ENABLE_UPDATE_DELETE_LIMIT\",\n#endif\n#ifdef SQLITE_HAS_CODEC\n  \"HAS_CODEC\",\n#endif\n#ifdef SQLITE_HAVE_ISNAN\n  \"HAVE_ISNAN\",\n#endif\n#ifdef SQLITE_HOMEGROWN_RECURSIVE_MUTEX\n  \"HOMEGROWN_RECURSIVE_MUTEX\",\n#endif\n#ifdef SQLITE_IGNORE_AFP_LOCK_ERRORS\n  \"IGNORE_AFP_LOCK_ERRORS\",\n#endif\n#ifdef SQLITE_IGNORE_FLOCK_LOCK_ERRORS\n  \"IGNORE_FLOCK_LOCK_ERRORS\",\n#endif\n#ifdef SQLITE_INT64_TYPE\n  \"INT64_TYPE\",\n#endif\n#ifdef SQLITE_LOCK_TRACE\n  \"LOCK_TRACE\",\n#endif\n#ifdef SQLITE_MEMDEBUG\n  \"MEMDEBUG\",\n#endif\n#ifdef SQLITE_MIXED_ENDIAN_64BIT_FLOAT\n  \"MIXED_ENDIAN_64BIT_FLOAT\",\n#endif\n#ifdef SQLITE_NO_SYNC\n  \"NO_SYNC\",\n#endif\n#ifdef SQLITE_OMIT_ALTERTABLE\n  \"OMIT_ALTERTABLE\",\n#endif\n#ifdef SQLITE_OMIT_ANALYZE\n  \"OMIT_ANALYZE\",\n#endif\n#ifdef SQLITE_OMIT_ATTACH\n  \"OMIT_ATTACH\",\n#endif\n#ifdef SQLITE_OMIT_AUTHORIZATION\n  \"OMIT_AUTHORIZATION\",\n#endif\n#ifdef SQLITE_OMIT_AUTOINCREMENT\n  \"OMIT_AUTOINCREMENT\",\n#endif\n#ifdef SQLITE_OMIT_AUTOINIT\n  \"OMIT_AUTOINIT\",\n#endif\n#ifdef SQLITE_OMIT_AUTOMATIC_INDEX\n  \"OMIT_AUTOMATIC_INDEX\",\n#endif\n#ifdef SQLITE_OMIT_AUTORESET\n  \"OMIT_AUTORESET\",\n#endif\n#ifdef SQLITE_OMIT_AUTOVACUUM\n  \"OMIT_AUTOVACUUM\",\n#endif\n#ifdef SQLITE_OMIT_BETWEEN_OPTIMIZATION\n  \"OMIT_BETWEEN_OPTIMIZATION\",\n#endif\n#ifdef SQLITE_OMIT_BLOB_LITERAL\n  \"OMIT_BLOB_LITERAL\",\n#endif\n#ifdef SQLITE_OMIT_BTREECOUNT\n  \"OMIT_BTREECOUNT\",\n#endif\n#ifdef SQLITE_OMIT_BUILTIN_TEST\n  \"OMIT_BUILTIN_TEST\",\n#endif\n#ifdef SQLITE_OMIT_CAST\n  \"OMIT_CAST\",\n#endif\n#ifdef SQLITE_OMIT_CHECK\n  \"OMIT_CHECK\",\n#endif\n/* // redundant\n** #ifdef SQLITE_OMIT_COMPILEOPTION_DIAGS\n**   \"OMIT_COMPILEOPTION_DIAGS\",\n** #endif\n*/\n#ifdef SQLITE_OMIT_COMPLETE\n  \"OMIT_COMPLETE\",\n#endif\n#ifdef SQLITE_OMIT_COMPOUND_SELECT\n  \"OMIT_COMPOUND_SELECT\",\n#endif\n#ifdef SQLITE_OMIT_DATETIME_FUNCS\n  \"OMIT_DATETIME_FUNCS\",\n#endif\n#ifdef SQLITE_OMIT_DECLTYPE\n  \"OMIT_DECLTYPE\",\n#endif\n#ifdef SQLITE_OMIT_DEPRECATED\n  \"OMIT_DEPRECATED\",\n#endif\n#ifdef SQLITE_OMIT_DISKIO\n  \"OMIT_DISKIO\",\n#endif\n#ifdef SQLITE_OMIT_EXPLAIN\n  \"OMIT_EXPLAIN\",\n#endif\n#ifdef SQLITE_OMIT_FLAG_PRAGMAS\n  \"OMIT_FLAG_PRAGMAS\",\n#endif\n#ifdef SQLITE_OMIT_FLOATING_POINT\n  \"OMIT_FLOATING_POINT\",\n#endif\n#ifdef SQLITE_OMIT_FOREIGN_KEY\n  \"OMIT_FOREIGN_KEY\",\n#endif\n#ifdef SQLITE_OMIT_GET_TABLE\n  \"OMIT_GET_TABLE\",\n#endif\n#ifdef SQLITE_OMIT_INCRBLOB\n  \"OMIT_INCRBLOB\",\n#endif\n#ifdef SQLITE_OMIT_INTEGRITY_CHECK\n  \"OMIT_INTEGRITY_CHECK\",\n#endif\n#ifdef SQLITE_OMIT_LIKE_OPTIMIZATION\n  \"OMIT_LIKE_OPTIMIZATION\",\n#endif\n#ifdef SQLITE_OMIT_LOAD_EXTENSION\n  \"OMIT_LOAD_EXTENSION\",\n#endif\n#ifdef SQLITE_OMIT_LOCALTIME\n  \"OMIT_LOCALTIME\",\n#endif\n#ifdef SQLITE_OMIT_LOOKASIDE\n  \"OMIT_LOOKASIDE\",\n#endif\n#ifdef SQLITE_OMIT_MEMORYDB\n  \"OMIT_MEMORYDB\",\n#endif\n#ifdef SQLITE_OMIT_OR_OPTIMIZATION\n  \"OMIT_OR_OPTIMIZATION\",\n#endif\n#ifdef SQLITE_OMIT_PAGER_PRAGMAS\n  \"OMIT_PAGER_PRAGMAS\",\n#endif\n#ifdef SQLITE_OMIT_PRAGMA\n  \"OMIT_PRAGMA\",\n#endif\n#ifdef SQLITE_OMIT_PROGRESS_CALLBACK\n  \"OMIT_PROGRESS_CALLBACK\",\n#endif\n#ifdef SQLITE_OMIT_QUICKBALANCE\n  \"OMIT_QUICKBALANCE\",\n#endif\n#ifdef SQLITE_OMIT_REINDEX\n  \"OMIT_REINDEX\",\n#endif\n#ifdef SQLITE_OMIT_SCHEMA_PRAGMAS\n  \"OMIT_SCHEMA_PRAGMAS\",\n#endif\n#ifdef SQLITE_OMIT_SCHEMA_VERSION_PRAGMAS\n  \"OMIT_SCHEMA_VERSION_PRAGMAS\",\n#endif\n#ifdef SQLITE_OMIT_SHARED_CACHE\n  \"OMIT_SHARED_CACHE\",\n#endif\n#ifdef SQLITE_OMIT_SUBQUERY\n  \"OMIT_SUBQUERY\",\n#endif\n#ifdef SQLITE_OMIT_TCL_VARIABLE\n  \"OMIT_TCL_VARIABLE\",\n#endif\n#ifdef SQLITE_OMIT_TEMPDB\n  \"OMIT_TEMPDB\",\n#endif\n#ifdef SQLITE_OMIT_TRACE\n  \"OMIT_TRACE\",\n#endif\n#ifdef SQLITE_OMIT_TRIGGER\n  \"OMIT_TRIGGER\",\n#endif\n#ifdef SQLITE_OMIT_TRUNCATE_OPTIMIZATION\n  \"OMIT_TRUNCATE_OPTIMIZATION\",\n#endif\n#ifdef SQLITE_OMIT_UNIQUE_ENFORCEMENT\n  \"OMIT_UNIQUE_ENFORCEMENT\",\n#endif\n#ifdef SQLITE_OMIT_UTF16\n  \"OMIT_UTF16\",\n#endif\n#ifdef SQLITE_OMIT_VACUUM\n  \"OMIT_VACUUM\",\n#endif\n#ifdef SQLITE_OMIT_VIEW\n  \"OMIT_VIEW\",\n#endif\n#ifdef SQLITE_OMIT_VIRTUALTABLE\n  \"OMIT_VIRTUALTABLE\",\n#endif\n#ifdef SQLITE_OMIT_WAL\n  \"OMIT_WAL\",\n#endif\n#ifdef SQLITE_OMIT_WSD\n  \"OMIT_WSD\",\n#endif\n#ifdef SQLITE_OMIT_XFER_OPT\n  \"OMIT_XFER_OPT\",\n#endif\n#ifdef SQLITE_PERFORMANCE_TRACE\n  \"PERFORMANCE_TRACE\",\n#endif\n#ifdef SQLITE_PROXY_DEBUG\n  \"PROXY_DEBUG\",\n#endif\n#ifdef SQLITE_SECURE_DELETE\n  \"SECURE_DELETE\",\n#endif\n#ifdef SQLITE_SMALL_STACK\n  \"SMALL_STACK\",\n#endif\n#ifdef SQLITE_SOUNDEX\n  \"SOUNDEX\",\n#endif\n#ifdef SQLITE_TCL\n  \"TCL\",\n#endif\n#ifdef SQLITE_TEMP_STORE\n  \"TEMP_STORE=\" CTIMEOPT_VAL(SQLITE_TEMP_STORE),\n#endif\n#ifdef SQLITE_TEST\n  \"TEST\",\n#endif\n#ifdef SQLITE_THREADSAFE\n  \"THREADSAFE=\" CTIMEOPT_VAL(SQLITE_THREADSAFE),\n#endif\n#ifdef SQLITE_USE_ALLOCA\n  \"USE_ALLOCA\",\n#endif\n#ifdef SQLITE_ZERO_MALLOC\n  \"ZERO_MALLOC\"\n#endif\n};\n\n/*\n** Given the name of a compile-time option, return true if that option\n** was used and false if not.\n**\n** The name can optionally begin with \"SQLITE_\" but the \"SQLITE_\" prefix\n** is not required for a match.\n*/\nSQLITE_API int sqlite3_compileoption_used(const char *zOptName){\n  int i, n;\n  if( sqlite3StrNICmp(zOptName, \"SQLITE_\", 7)==0 ) zOptName += 7;\n  n = sqlite3Strlen30(zOptName);\n\n  /* Since ArraySize(azCompileOpt) is normally in single digits, a\n  ** linear search is adequate.  No need for a binary search. */\n  for(i=0; i<ArraySize(azCompileOpt); i++){\n    if(   (sqlite3StrNICmp(zOptName, azCompileOpt[i], n)==0)\n       && ( (azCompileOpt[i][n]==0) || (azCompileOpt[i][n]=='=') ) ) return 1;\n  }\n  return 0;\n}\n\n/*\n** Return the N-th compile-time option string.  If N is out of range,\n** return a NULL pointer.\n*/\nSQLITE_API const char *sqlite3_compileoption_get(int N){\n  if( N>=0 && N<ArraySize(azCompileOpt) ){\n    return azCompileOpt[N];\n  }\n  return 0;\n}\n\n#endif /* SQLITE_OMIT_COMPILEOPTION_DIAGS */\n\n/************** End of ctime.c ***********************************************/\n/************** Begin file status.c ******************************************/\n/*\n** 2008 June 18\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n**\n** This module implements the sqlite3_status() interface and related\n** functionality.\n*/\n/************** Include vdbeInt.h in the middle of status.c ******************/\n/************** Begin file vdbeInt.h *****************************************/\n/*\n** 2003 September 6\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This is the header file for information that is private to the\n** VDBE.  This information used to all be at the top of the single\n** source code file \"vdbe.c\".  When that file became too big (over\n** 6000 lines long) it was split up into several smaller files and\n** this header information was factored out.\n*/\n#ifndef _VDBEINT_H_\n#define _VDBEINT_H_\n\n/*\n** SQL is translated into a sequence of instructions to be\n** executed by a virtual machine.  Each instruction is an instance\n** of the following structure.\n*/\ntypedef struct VdbeOp Op;\n\n/*\n** Boolean values\n*/\ntypedef unsigned char Bool;\n\n/*\n** A cursor is a pointer into a single BTree within a database file.\n** The cursor can seek to a BTree entry with a particular key, or\n** loop over all entries of the Btree.  You can also insert new BTree\n** entries or retrieve the key or data from the entry that the cursor\n** is currently pointing to.\n** \n** Every cursor that the virtual machine has open is represented by an\n** instance of the following structure.\n*/\nstruct VdbeCursor {\n  BtCursor *pCursor;    /* The cursor structure of the backend */\n  Btree *pBt;           /* Separate file holding temporary table */\n  KeyInfo *pKeyInfo;    /* Info about index keys needed by index cursors */\n  int iDb;              /* Index of cursor database in db->aDb[] (or -1) */\n  int pseudoTableReg;   /* Register holding pseudotable content. */\n  int nField;           /* Number of fields in the header */\n  Bool zeroed;          /* True if zeroed out and ready for reuse */\n  Bool rowidIsValid;    /* True if lastRowid is valid */\n  Bool atFirst;         /* True if pointing to first entry */\n  Bool useRandomRowid;  /* Generate new record numbers semi-randomly */\n  Bool nullRow;         /* True if pointing to a row with no data */\n  Bool deferredMoveto;  /* A call to sqlite3BtreeMoveto() is needed */\n  Bool isTable;         /* True if a table requiring integer keys */\n  Bool isIndex;         /* True if an index containing keys only - no data */\n  Bool isOrdered;       /* True if the underlying table is BTREE_UNORDERED */\n  sqlite3_vtab_cursor *pVtabCursor;  /* The cursor for a virtual table */\n  const sqlite3_module *pModule;     /* Module for cursor pVtabCursor */\n  i64 seqCount;         /* Sequence counter */\n  i64 movetoTarget;     /* Argument to the deferred sqlite3BtreeMoveto() */\n  i64 lastRowid;        /* Last rowid from a Next or NextIdx operation */\n\n  /* Result of last sqlite3BtreeMoveto() done by an OP_NotExists or \n  ** OP_IsUnique opcode on this cursor. */\n  int seekResult;\n\n  /* Cached information about the header for the data record that the\n  ** cursor is currently pointing to.  Only valid if cacheStatus matches\n  ** Vdbe.cacheCtr.  Vdbe.cacheCtr will never take on the value of\n  ** CACHE_STALE and so setting cacheStatus=CACHE_STALE guarantees that\n  ** the cache is out of date.\n  **\n  ** aRow might point to (ephemeral) data for the current row, or it might\n  ** be NULL.\n  */\n  u32 cacheStatus;      /* Cache is valid if this matches Vdbe.cacheCtr */\n  int payloadSize;      /* Total number of bytes in the record */\n  u32 *aType;           /* Type values for all entries in the record */\n  u32 *aOffset;         /* Cached offsets to the start of each columns data */\n  u8 *aRow;             /* Data for the current row, if all on one page */\n};\ntypedef struct VdbeCursor VdbeCursor;\n\n/*\n** When a sub-program is executed (OP_Program), a structure of this type\n** is allocated to store the current value of the program counter, as\n** well as the current memory cell array and various other frame specific\n** values stored in the Vdbe struct. When the sub-program is finished, \n** these values are copied back to the Vdbe from the VdbeFrame structure,\n** restoring the state of the VM to as it was before the sub-program\n** began executing.\n**\n** The memory for a VdbeFrame object is allocated and managed by a memory\n** cell in the parent (calling) frame. When the memory cell is deleted or\n** overwritten, the VdbeFrame object is not freed immediately. Instead, it\n** is linked into the Vdbe.pDelFrame list. The contents of the Vdbe.pDelFrame\n** list is deleted when the VM is reset in VdbeHalt(). The reason for doing\n** this instead of deleting the VdbeFrame immediately is to avoid recursive\n** calls to sqlite3VdbeMemRelease() when the memory cells belonging to the\n** child frame are released.\n**\n** The currently executing frame is stored in Vdbe.pFrame. Vdbe.pFrame is\n** set to NULL if the currently executing frame is the main program.\n*/\ntypedef struct VdbeFrame VdbeFrame;\nstruct VdbeFrame {\n  Vdbe *v;                /* VM this frame belongs to */\n  int pc;                 /* Program Counter in parent (calling) frame */\n  Op *aOp;                /* Program instructions for parent frame */\n  int nOp;                /* Size of aOp array */\n  Mem *aMem;              /* Array of memory cells for parent frame */\n  int nMem;               /* Number of entries in aMem */\n  VdbeCursor **apCsr;     /* Array of Vdbe cursors for parent frame */\n  u16 nCursor;            /* Number of entries in apCsr */\n  void *token;            /* Copy of SubProgram.token */\n  int nChildMem;          /* Number of memory cells for child frame */\n  int nChildCsr;          /* Number of cursors for child frame */\n  i64 lastRowid;          /* Last insert rowid (sqlite3.lastRowid) */\n  int nChange;            /* Statement changes (Vdbe.nChanges)     */\n  VdbeFrame *pParent;     /* Parent of this frame, or NULL if parent is main */\n};\n\n#define VdbeFrameMem(p) ((Mem *)&((u8 *)p)[ROUND8(sizeof(VdbeFrame))])\n\n/*\n** A value for VdbeCursor.cacheValid that means the cache is always invalid.\n*/\n#define CACHE_STALE 0\n\n/*\n** Internally, the vdbe manipulates nearly all SQL values as Mem\n** structures. Each Mem struct may cache multiple representations (string,\n** integer etc.) of the same value.\n*/\nstruct Mem {\n  sqlite3 *db;        /* The associated database connection */\n  char *z;            /* String or BLOB value */\n  double r;           /* Real value */\n  union {\n    i64 i;              /* Integer value used when MEM_Int is set in flags */\n    int nZero;          /* Used when bit MEM_Zero is set in flags */\n    FuncDef *pDef;      /* Used only when flags==MEM_Agg */\n    RowSet *pRowSet;    /* Used only when flags==MEM_RowSet */\n    VdbeFrame *pFrame;  /* Used when flags==MEM_Frame */\n  } u;\n  int n;              /* Number of characters in string value, excluding '\\0' */\n  u16 flags;          /* Some combination of MEM_Null, MEM_Str, MEM_Dyn, etc. */\n  u8  type;           /* One of SQLITE_NULL, SQLITE_TEXT, SQLITE_INTEGER, etc */\n  u8  enc;            /* SQLITE_UTF8, SQLITE_UTF16BE, SQLITE_UTF16LE */\n#ifdef SQLITE_DEBUG\n  Mem *pScopyFrom;    /* This Mem is a shallow copy of pScopyFrom */\n  void *pFiller;      /* So that sizeof(Mem) is a multiple of 8 */\n#endif\n  void (*xDel)(void *);  /* If not null, call this function to delete Mem.z */\n  char *zMalloc;      /* Dynamic buffer allocated by sqlite3_malloc() */\n};\n\n/* One or more of the following flags are set to indicate the validOK\n** representations of the value stored in the Mem struct.\n**\n** If the MEM_Null flag is set, then the value is an SQL NULL value.\n** No other flags may be set in this case.\n**\n** If the MEM_Str flag is set then Mem.z points at a string representation.\n** Usually this is encoded in the same unicode encoding as the main\n** database (see below for exceptions). If the MEM_Term flag is also\n** set, then the string is nul terminated. The MEM_Int and MEM_Real \n** flags may coexist with the MEM_Str flag.\n*/\n#define MEM_Null      0x0001   /* Value is NULL */\n#define MEM_Str       0x0002   /* Value is a string */\n#define MEM_Int       0x0004   /* Value is an integer */\n#define MEM_Real      0x0008   /* Value is a real number */\n#define MEM_Blob      0x0010   /* Value is a BLOB */\n#define MEM_RowSet    0x0020   /* Value is a RowSet object */\n#define MEM_Frame     0x0040   /* Value is a VdbeFrame object */\n#define MEM_Invalid   0x0080   /* Value is undefined */\n#define MEM_TypeMask  0x00ff   /* Mask of type bits */\n\n/* Whenever Mem contains a valid string or blob representation, one of\n** the following flags must be set to determine the memory management\n** policy for Mem.z.  The MEM_Term flag tells us whether or not the\n** string is \\000 or \\u0000 terminated\n*/\n#define MEM_Term      0x0200   /* String rep is nul terminated */\n#define MEM_Dyn       0x0400   /* Need to call sqliteFree() on Mem.z */\n#define MEM_Static    0x0800   /* Mem.z points to a static string */\n#define MEM_Ephem     0x1000   /* Mem.z points to an ephemeral string */\n#define MEM_Agg       0x2000   /* Mem.z points to an agg function context */\n#define MEM_Zero      0x4000   /* Mem.i contains count of 0s appended to blob */\n#ifdef SQLITE_OMIT_INCRBLOB\n  #undef MEM_Zero\n  #define MEM_Zero 0x0000\n#endif\n\n/*\n** Clear any existing type flags from a Mem and replace them with f\n*/\n#define MemSetTypeFlag(p, f) \\\n   ((p)->flags = ((p)->flags&~(MEM_TypeMask|MEM_Zero))|f)\n\n/*\n** Return true if a memory cell is not marked as invalid.  This macro\n** is for use inside assert() statements only.\n*/\n#ifdef SQLITE_DEBUG\n#define memIsValid(M)  ((M)->flags & MEM_Invalid)==0\n#endif\n\n\n/* A VdbeFunc is just a FuncDef (defined in sqliteInt.h) that contains\n** additional information about auxiliary information bound to arguments\n** of the function.  This is used to implement the sqlite3_get_auxdata()\n** and sqlite3_set_auxdata() APIs.  The \"auxdata\" is some auxiliary data\n** that can be associated with a constant argument to a function.  This\n** allows functions such as \"regexp\" to compile their constant regular\n** expression argument once and reused the compiled code for multiple\n** invocations.\n*/\nstruct VdbeFunc {\n  FuncDef *pFunc;               /* The definition of the function */\n  int nAux;                     /* Number of entries allocated for apAux[] */\n  struct AuxData {\n    void *pAux;                   /* Aux data for the i-th argument */\n    void (*xDelete)(void *);      /* Destructor for the aux data */\n  } apAux[1];                   /* One slot for each function argument */\n};\n\n/*\n** The \"context\" argument for a installable function.  A pointer to an\n** instance of this structure is the first argument to the routines used\n** implement the SQL functions.\n**\n** There is a typedef for this structure in sqlite.h.  So all routines,\n** even the public interface to SQLite, can use a pointer to this structure.\n** But this file is the only place where the internal details of this\n** structure are known.\n**\n** This structure is defined inside of vdbeInt.h because it uses substructures\n** (Mem) which are only defined there.\n*/\nstruct sqlite3_context {\n  FuncDef *pFunc;       /* Pointer to function information.  MUST BE FIRST */\n  VdbeFunc *pVdbeFunc;  /* Auxilary data, if created. */\n  Mem s;                /* The return value is stored here */\n  Mem *pMem;            /* Memory cell used to store aggregate context */\n  int isError;          /* Error code returned by the function. */\n  CollSeq *pColl;       /* Collating sequence */\n};\n\n/*\n** An instance of the virtual machine.  This structure contains the complete\n** state of the virtual machine.\n**\n** The \"sqlite3_stmt\" structure pointer that is returned by sqlite3_prepare()\n** is really a pointer to an instance of this structure.\n**\n** The Vdbe.inVtabMethod variable is set to non-zero for the duration of\n** any virtual table method invocations made by the vdbe program. It is\n** set to 2 for xDestroy method calls and 1 for all other methods. This\n** variable is used for two purposes: to allow xDestroy methods to execute\n** \"DROP TABLE\" statements and to prevent some nasty side effects of\n** malloc failure when SQLite is invoked recursively by a virtual table \n** method function.\n*/\nstruct Vdbe {\n  sqlite3 *db;            /* The database connection that owns this statement */\n  Op *aOp;                /* Space to hold the virtual machine's program */\n  Mem *aMem;              /* The memory locations */\n  Mem **apArg;            /* Arguments to currently executing user function */\n  Mem *aColName;          /* Column names to return */\n  Mem *pResultSet;        /* Pointer to an array of results */\n  int nMem;               /* Number of memory locations currently allocated */\n  int nOp;                /* Number of instructions in the program */\n  int nOpAlloc;           /* Number of slots allocated for aOp[] */\n  int nLabel;             /* Number of labels used */\n  int nLabelAlloc;        /* Number of slots allocated in aLabel[] */\n  int *aLabel;            /* Space to hold the labels */\n  u16 nResColumn;         /* Number of columns in one row of the result set */\n  u16 nCursor;            /* Number of slots in apCsr[] */\n  u32 magic;              /* Magic number for sanity checking */\n  char *zErrMsg;          /* Error message written here */\n  Vdbe *pPrev,*pNext;     /* Linked list of VDBEs with the same Vdbe.db */\n  VdbeCursor **apCsr;     /* One element of this array for each open cursor */\n  Mem *aVar;              /* Values for the OP_Variable opcode. */\n  char **azVar;           /* Name of variables */\n  ynVar nVar;             /* Number of entries in aVar[] */\n  u32 cacheCtr;           /* VdbeCursor row cache generation counter */\n  int pc;                 /* The program counter */\n  int rc;                 /* Value to return */\n  u8 errorAction;         /* Recovery action to do in case of an error */\n  u8 okVar;               /* True if azVar[] has been initialized */\n  u8 explain;             /* True if EXPLAIN present on SQL command */\n  u8 changeCntOn;         /* True to update the change-counter */\n  u8 expired;             /* True if the VM needs to be recompiled */\n  u8 runOnlyOnce;         /* Automatically expire on reset */\n  u8 minWriteFileFormat;  /* Minimum file format for writable database files */\n  u8 inVtabMethod;        /* See comments above */\n  u8 usesStmtJournal;     /* True if uses a statement journal */\n  u8 readOnly;            /* True for read-only statements */\n  u8 isPrepareV2;         /* True if prepared with prepare_v2() */\n  int nChange;            /* Number of db changes made since last reset */\n  int btreeMask;          /* Bitmask of db->aDb[] entries referenced */\n  int iStatement;         /* Statement number (or 0 if has not opened stmt) */\n  int aCounter[3];        /* Counters used by sqlite3_stmt_status() */\n  BtreeMutexArray aMutex; /* An array of Btree used here and needing locks */\n#ifndef SQLITE_OMIT_TRACE\n  i64 startTime;          /* Time when query started - used for profiling */\n#endif\n  i64 nFkConstraint;      /* Number of imm. FK constraints this VM */\n  i64 nStmtDefCons;       /* Number of def. constraints when stmt started */\n  char *zSql;             /* Text of the SQL statement that generated this */\n  void *pFree;            /* Free this when deleting the vdbe */\n#ifdef SQLITE_DEBUG\n  FILE *trace;            /* Write an execution trace here, if not NULL */\n#endif\n  VdbeFrame *pFrame;      /* Parent frame */\n  VdbeFrame *pDelFrame;   /* List of frame objects to free on VM reset */\n  int nFrame;             /* Number of frames in pFrame list */\n  u32 expmask;            /* Binding to these vars invalidates VM */\n  SubProgram *pProgram;   /* Linked list of all sub-programs used by VM */\n};\n\n/*\n** The following are allowed values for Vdbe.magic\n*/\n#define VDBE_MAGIC_INIT     0x26bceaa5    /* Building a VDBE program */\n#define VDBE_MAGIC_RUN      0xbdf20da3    /* VDBE is ready to execute */\n#define VDBE_MAGIC_HALT     0x519c2973    /* VDBE has completed execution */\n#define VDBE_MAGIC_DEAD     0xb606c3c8    /* The VDBE has been deallocated */\n\n/*\n** Function prototypes\n*/\nSQLITE_PRIVATE void sqlite3VdbeFreeCursor(Vdbe *, VdbeCursor*);\nvoid sqliteVdbePopStack(Vdbe*,int);\nSQLITE_PRIVATE int sqlite3VdbeCursorMoveto(VdbeCursor*);\n#if defined(SQLITE_DEBUG) || defined(VDBE_PROFILE)\nSQLITE_PRIVATE void sqlite3VdbePrintOp(FILE*, int, Op*);\n#endif\nSQLITE_PRIVATE u32 sqlite3VdbeSerialTypeLen(u32);\nSQLITE_PRIVATE u32 sqlite3VdbeSerialType(Mem*, int);\nSQLITE_PRIVATE u32 sqlite3VdbeSerialPut(unsigned char*, int, Mem*, int);\nSQLITE_PRIVATE u32 sqlite3VdbeSerialGet(const unsigned char*, u32, Mem*);\nSQLITE_PRIVATE void sqlite3VdbeDeleteAuxData(VdbeFunc*, int);\n\nint sqlite2BtreeKeyCompare(BtCursor *, const void *, int, int, int *);\nSQLITE_PRIVATE int sqlite3VdbeIdxKeyCompare(VdbeCursor*,UnpackedRecord*,int*);\nSQLITE_PRIVATE int sqlite3VdbeIdxRowid(sqlite3*, BtCursor *, i64 *);\nSQLITE_PRIVATE int sqlite3MemCompare(const Mem*, const Mem*, const CollSeq*);\nSQLITE_PRIVATE int sqlite3VdbeExec(Vdbe*);\nSQLITE_PRIVATE int sqlite3VdbeList(Vdbe*);\nSQLITE_PRIVATE int sqlite3VdbeHalt(Vdbe*);\nSQLITE_PRIVATE int sqlite3VdbeChangeEncoding(Mem *, int);\nSQLITE_PRIVATE int sqlite3VdbeMemTooBig(Mem*);\nSQLITE_PRIVATE int sqlite3VdbeMemCopy(Mem*, const Mem*);\nSQLITE_PRIVATE void sqlite3VdbeMemShallowCopy(Mem*, const Mem*, int);\nSQLITE_PRIVATE void sqlite3VdbeMemMove(Mem*, Mem*);\nSQLITE_PRIVATE int sqlite3VdbeMemNulTerminate(Mem*);\nSQLITE_PRIVATE int sqlite3VdbeMemSetStr(Mem*, const char*, int, u8, void(*)(void*));\nSQLITE_PRIVATE void sqlite3VdbeMemSetInt64(Mem*, i64);\n#ifdef SQLITE_OMIT_FLOATING_POINT\n# define sqlite3VdbeMemSetDouble sqlite3VdbeMemSetInt64\n#else\nSQLITE_PRIVATE   void sqlite3VdbeMemSetDouble(Mem*, double);\n#endif\nSQLITE_PRIVATE void sqlite3VdbeMemSetNull(Mem*);\nSQLITE_PRIVATE void sqlite3VdbeMemSetZeroBlob(Mem*,int);\nSQLITE_PRIVATE void sqlite3VdbeMemSetRowSet(Mem*);\nSQLITE_PRIVATE int sqlite3VdbeMemMakeWriteable(Mem*);\nSQLITE_PRIVATE int sqlite3VdbeMemStringify(Mem*, int);\nSQLITE_PRIVATE i64 sqlite3VdbeIntValue(Mem*);\nSQLITE_PRIVATE int sqlite3VdbeMemIntegerify(Mem*);\nSQLITE_PRIVATE double sqlite3VdbeRealValue(Mem*);\nSQLITE_PRIVATE void sqlite3VdbeIntegerAffinity(Mem*);\nSQLITE_PRIVATE int sqlite3VdbeMemRealify(Mem*);\nSQLITE_PRIVATE int sqlite3VdbeMemNumerify(Mem*);\nSQLITE_PRIVATE int sqlite3VdbeMemFromBtree(BtCursor*,int,int,int,Mem*);\nSQLITE_PRIVATE void sqlite3VdbeMemRelease(Mem *p);\nSQLITE_PRIVATE void sqlite3VdbeMemReleaseExternal(Mem *p);\nSQLITE_PRIVATE int sqlite3VdbeMemFinalize(Mem*, FuncDef*);\nSQLITE_PRIVATE const char *sqlite3OpcodeName(int);\nSQLITE_PRIVATE int sqlite3VdbeMemGrow(Mem *pMem, int n, int preserve);\nSQLITE_PRIVATE int sqlite3VdbeCloseStatement(Vdbe *, int);\nSQLITE_PRIVATE void sqlite3VdbeFrameDelete(VdbeFrame*);\nSQLITE_PRIVATE int sqlite3VdbeFrameRestore(VdbeFrame *);\nSQLITE_PRIVATE void sqlite3VdbeMemStoreType(Mem *pMem);\n\n#ifdef SQLITE_DEBUG\nSQLITE_PRIVATE void sqlite3VdbeMemPrepareToChange(Vdbe*,Mem*);\n#endif\n\n#ifndef SQLITE_OMIT_FOREIGN_KEY\nSQLITE_PRIVATE int sqlite3VdbeCheckFk(Vdbe *, int);\n#else\n# define sqlite3VdbeCheckFk(p,i) 0\n#endif\n\n#ifndef SQLITE_OMIT_SHARED_CACHE\nSQLITE_PRIVATE void sqlite3VdbeMutexArrayEnter(Vdbe *p);\n#else\n# define sqlite3VdbeMutexArrayEnter(p)\n#endif\n\nSQLITE_PRIVATE int sqlite3VdbeMemTranslate(Mem*, u8);\n#ifdef SQLITE_DEBUG\nSQLITE_PRIVATE   void sqlite3VdbePrintSql(Vdbe*);\nSQLITE_PRIVATE   void sqlite3VdbeMemPrettyPrint(Mem *pMem, char *zBuf);\n#endif\nSQLITE_PRIVATE int sqlite3VdbeMemHandleBom(Mem *pMem);\n\n#ifndef SQLITE_OMIT_INCRBLOB\nSQLITE_PRIVATE   int sqlite3VdbeMemExpandBlob(Mem *);\n#else\n  #define sqlite3VdbeMemExpandBlob(x) SQLITE_OK\n#endif\n\n#endif /* !defined(_VDBEINT_H_) */\n\n/************** End of vdbeInt.h *********************************************/\n/************** Continuing where we left off in status.c *********************/\n\n/*\n** Variables in which to record status information.\n*/\ntypedef struct sqlite3StatType sqlite3StatType;\nstatic SQLITE_WSD struct sqlite3StatType {\n  int nowValue[10];         /* Current value */\n  int mxValue[10];          /* Maximum value */\n} sqlite3Stat = { {0,}, {0,} };\n\n\n/* The \"wsdStat\" macro will resolve to the status information\n** state vector.  If writable static data is unsupported on the target,\n** we have to locate the state vector at run-time.  In the more common\n** case where writable static data is supported, wsdStat can refer directly\n** to the \"sqlite3Stat\" state vector declared above.\n*/\n#ifdef SQLITE_OMIT_WSD\n# define wsdStatInit  sqlite3StatType *x = &GLOBAL(sqlite3StatType,sqlite3Stat)\n# define wsdStat x[0]\n#else\n# define wsdStatInit\n# define wsdStat sqlite3Stat\n#endif\n\n/*\n** Return the current value of a status parameter.\n*/\nSQLITE_PRIVATE int sqlite3StatusValue(int op){\n  wsdStatInit;\n  assert( op>=0 && op<ArraySize(wsdStat.nowValue) );\n  return wsdStat.nowValue[op];\n}\n\n/*\n** Add N to the value of a status record.  It is assumed that the\n** caller holds appropriate locks.\n*/\nSQLITE_PRIVATE void sqlite3StatusAdd(int op, int N){\n  wsdStatInit;\n  assert( op>=0 && op<ArraySize(wsdStat.nowValue) );\n  wsdStat.nowValue[op] += N;\n  if( wsdStat.nowValue[op]>wsdStat.mxValue[op] ){\n    wsdStat.mxValue[op] = wsdStat.nowValue[op];\n  }\n}\n\n/*\n** Set the value of a status to X.\n*/\nSQLITE_PRIVATE void sqlite3StatusSet(int op, int X){\n  wsdStatInit;\n  assert( op>=0 && op<ArraySize(wsdStat.nowValue) );\n  wsdStat.nowValue[op] = X;\n  if( wsdStat.nowValue[op]>wsdStat.mxValue[op] ){\n    wsdStat.mxValue[op] = wsdStat.nowValue[op];\n  }\n}\n\n/*\n** Query status information.\n**\n** This implementation assumes that reading or writing an aligned\n** 32-bit integer is an atomic operation.  If that assumption is not true,\n** then this routine is not threadsafe.\n*/\nSQLITE_API int sqlite3_status(int op, int *pCurrent, int *pHighwater, int resetFlag){\n  wsdStatInit;\n  if( op<0 || op>=ArraySize(wsdStat.nowValue) ){\n    return SQLITE_MISUSE_BKPT;\n  }\n  *pCurrent = wsdStat.nowValue[op];\n  *pHighwater = wsdStat.mxValue[op];\n  if( resetFlag ){\n    wsdStat.mxValue[op] = wsdStat.nowValue[op];\n  }\n  return SQLITE_OK;\n}\n\n/*\n** Query status information for a single database connection\n*/\nSQLITE_API int sqlite3_db_status(\n  sqlite3 *db,          /* The database connection whose status is desired */\n  int op,               /* Status verb */\n  int *pCurrent,        /* Write current value here */\n  int *pHighwater,      /* Write high-water mark here */\n  int resetFlag         /* Reset high-water mark if true */\n){\n  int rc = SQLITE_OK;   /* Return code */\n  sqlite3_mutex_enter(db->mutex);\n  switch( op ){\n    case SQLITE_DBSTATUS_LOOKASIDE_USED: {\n      *pCurrent = db->lookaside.nOut;\n      *pHighwater = db->lookaside.mxOut;\n      if( resetFlag ){\n        db->lookaside.mxOut = db->lookaside.nOut;\n      }\n      break;\n    }\n\n    case SQLITE_DBSTATUS_LOOKASIDE_HIT:\n    case SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE:\n    case SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL: {\n      testcase( op==SQLITE_DBSTATUS_LOOKASIDE_HIT );\n      testcase( op==SQLITE_DBSTATUS_LOOKASIDE_MISS_SIZE );\n      testcase( op==SQLITE_DBSTATUS_LOOKASIDE_MISS_FULL );\n      assert( (op-SQLITE_DBSTATUS_LOOKASIDE_HIT)>=0 );\n      assert( (op-SQLITE_DBSTATUS_LOOKASIDE_HIT)<3 );\n      *pCurrent = 0;\n      *pHighwater = db->lookaside.anStat[op - SQLITE_DBSTATUS_LOOKASIDE_HIT];\n      if( resetFlag ){\n        db->lookaside.anStat[op - SQLITE_DBSTATUS_LOOKASIDE_HIT] = 0;\n      }\n      break;\n    }\n\n    /* \n    ** Return an approximation for the amount of memory currently used\n    ** by all pagers associated with the given database connection.  The\n    ** highwater mark is meaningless and is returned as zero.\n    */\n    case SQLITE_DBSTATUS_CACHE_USED: {\n      int totalUsed = 0;\n      int i;\n      sqlite3BtreeEnterAll(db);\n      for(i=0; i<db->nDb; i++){\n        Btree *pBt = db->aDb[i].pBt;\n        if( pBt ){\n          Pager *pPager = sqlite3BtreePager(pBt);\n          totalUsed += sqlite3PagerMemUsed(pPager);\n        }\n      }\n      sqlite3BtreeLeaveAll(db);\n      *pCurrent = totalUsed;\n      *pHighwater = 0;\n      break;\n    }\n\n    /*\n    ** *pCurrent gets an accurate estimate of the amount of memory used\n    ** to store the schema for all databases (main, temp, and any ATTACHed\n    ** databases.  *pHighwater is set to zero.\n    */\n    case SQLITE_DBSTATUS_SCHEMA_USED: {\n      int i;                      /* Used to iterate through schemas */\n      int nByte = 0;              /* Used to accumulate return value */\n\n      db->pnBytesFreed = &nByte;\n      for(i=0; i<db->nDb; i++){\n        Schema *pSchema = db->aDb[i].pSchema;\n        if( ALWAYS(pSchema!=0) ){\n          HashElem *p;\n\n          nByte += sqlite3GlobalConfig.m.xRoundup(sizeof(HashElem)) * (\n              pSchema->tblHash.count \n            + pSchema->trigHash.count\n            + pSchema->idxHash.count\n            + pSchema->fkeyHash.count\n          );\n          nByte += sqlite3MallocSize(pSchema->tblHash.ht);\n          nByte += sqlite3MallocSize(pSchema->trigHash.ht);\n          nByte += sqlite3MallocSize(pSchema->idxHash.ht);\n          nByte += sqlite3MallocSize(pSchema->fkeyHash.ht);\n\n          for(p=sqliteHashFirst(&pSchema->trigHash); p; p=sqliteHashNext(p)){\n            sqlite3DeleteTrigger(db, (Trigger*)sqliteHashData(p));\n          }\n          for(p=sqliteHashFirst(&pSchema->tblHash); p; p=sqliteHashNext(p)){\n            sqlite3DeleteTable(db, (Table *)sqliteHashData(p));\n          }\n        }\n      }\n      db->pnBytesFreed = 0;\n\n      *pHighwater = 0;\n      *pCurrent = nByte;\n      break;\n    }\n\n    /*\n    ** *pCurrent gets an accurate estimate of the amount of memory used\n    ** to store all prepared statements.\n    ** *pHighwater is set to zero.\n    */\n    case SQLITE_DBSTATUS_STMT_USED: {\n      struct Vdbe *pVdbe;         /* Used to iterate through VMs */\n      int nByte = 0;              /* Used to accumulate return value */\n\n      db->pnBytesFreed = &nByte;\n      for(pVdbe=db->pVdbe; pVdbe; pVdbe=pVdbe->pNext){\n        sqlite3VdbeDeleteObject(db, pVdbe);\n      }\n      db->pnBytesFreed = 0;\n\n      *pHighwater = 0;\n      *pCurrent = nByte;\n\n      break;\n    }\n\n    default: {\n      rc = SQLITE_ERROR;\n    }\n  }\n  sqlite3_mutex_leave(db->mutex);\n  return rc;\n}\n\n/************** End of status.c **********************************************/\n/************** Begin file date.c ********************************************/\n/*\n** 2003 October 31\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains the C functions that implement date and time\n** functions for SQLite.  \n**\n** There is only one exported symbol in this file - the function\n** sqlite3RegisterDateTimeFunctions() found at the bottom of the file.\n** All other code has file scope.\n**\n** SQLite processes all times and dates as Julian Day numbers.  The\n** dates and times are stored as the number of days since noon\n** in Greenwich on November 24, 4714 B.C. according to the Gregorian\n** calendar system. \n**\n** 1970-01-01 00:00:00 is JD 2440587.5\n** 2000-01-01 00:00:00 is JD 2451544.5\n**\n** This implemention requires years to be expressed as a 4-digit number\n** which means that only dates between 0000-01-01 and 9999-12-31 can\n** be represented, even though julian day numbers allow a much wider\n** range of dates.\n**\n** The Gregorian calendar system is used for all dates and times,\n** even those that predate the Gregorian calendar.  Historians usually\n** use the Julian calendar for dates prior to 1582-10-15 and for some\n** dates afterwards, depending on locale.  Beware of this difference.\n**\n** The conversion algorithms are implemented based on descriptions\n** in the following text:\n**\n**      Jean Meeus\n**      Astronomical Algorithms, 2nd Edition, 1998\n**      ISBM 0-943396-61-1\n**      Willmann-Bell, Inc\n**      Richmond, Virginia (USA)\n*/\n#include <time.h>\n\n#ifndef SQLITE_OMIT_DATETIME_FUNCS\n\n/*\n** On recent Windows platforms, the localtime_s() function is available\n** as part of the \"Secure CRT\". It is essentially equivalent to \n** localtime_r() available under most POSIX platforms, except that the \n** order of the parameters is reversed.\n**\n** See http://msdn.microsoft.com/en-us/library/a442x3ye(VS.80).aspx.\n**\n** If the user has not indicated to use localtime_r() or localtime_s()\n** already, check for an MSVC build environment that provides \n** localtime_s().\n*/\n#if !defined(HAVE_LOCALTIME_R) && !defined(HAVE_LOCALTIME_S) && \\\n     defined(_MSC_VER) && defined(_CRT_INSECURE_DEPRECATE)\n#define HAVE_LOCALTIME_S 1\n#endif\n\n/*\n** A structure for holding a single date and time.\n*/\ntypedef struct DateTime DateTime;\nstruct DateTime {\n  sqlite3_int64 iJD; /* The julian day number times 86400000 */\n  int Y, M, D;       /* Year, month, and day */\n  int h, m;          /* Hour and minutes */\n  int tz;            /* Timezone offset in minutes */\n  double s;          /* Seconds */\n  char validYMD;     /* True (1) if Y,M,D are valid */\n  char validHMS;     /* True (1) if h,m,s are valid */\n  char validJD;      /* True (1) if iJD is valid */\n  char validTZ;      /* True (1) if tz is valid */\n};\n\n\n/*\n** Convert zDate into one or more integers.  Additional arguments\n** come in groups of 5 as follows:\n**\n**       N       number of digits in the integer\n**       min     minimum allowed value of the integer\n**       max     maximum allowed value of the integer\n**       nextC   first character after the integer\n**       pVal    where to write the integers value.\n**\n** Conversions continue until one with nextC==0 is encountered.\n** The function returns the number of successful conversions.\n*/\nstatic int getDigits(const char *zDate, ...){\n  va_list ap;\n  int val;\n  int N;\n  int min;\n  int max;\n  int nextC;\n  int *pVal;\n  int cnt = 0;\n  va_start(ap, zDate);\n  do{\n    N = va_arg(ap, int);\n    min = va_arg(ap, int);\n    max = va_arg(ap, int);\n    nextC = va_arg(ap, int);\n    pVal = va_arg(ap, int*);\n    val = 0;\n    while( N-- ){\n      if( !sqlite3Isdigit(*zDate) ){\n        goto end_getDigits;\n      }\n      val = val*10 + *zDate - '0';\n      zDate++;\n    }\n    if( val<min || val>max || (nextC!=0 && nextC!=*zDate) ){\n      goto end_getDigits;\n    }\n    *pVal = val;\n    zDate++;\n    cnt++;\n  }while( nextC );\nend_getDigits:\n  va_end(ap);\n  return cnt;\n}\n\n/*\n** Parse a timezone extension on the end of a date-time.\n** The extension is of the form:\n**\n**        (+/-)HH:MM\n**\n** Or the \"zulu\" notation:\n**\n**        Z\n**\n** If the parse is successful, write the number of minutes\n** of change in p->tz and return 0.  If a parser error occurs,\n** return non-zero.\n**\n** A missing specifier is not considered an error.\n*/\nstatic int parseTimezone(const char *zDate, DateTime *p){\n  int sgn = 0;\n  int nHr, nMn;\n  int c;\n  while( sqlite3Isspace(*zDate) ){ zDate++; }\n  p->tz = 0;\n  c = *zDate;\n  if( c=='-' ){\n    sgn = -1;\n  }else if( c=='+' ){\n    sgn = +1;\n  }else if( c=='Z' || c=='z' ){\n    zDate++;\n    goto zulu_time;\n  }else{\n    return c!=0;\n  }\n  zDate++;\n  if( getDigits(zDate, 2, 0, 14, ':', &nHr, 2, 0, 59, 0, &nMn)!=2 ){\n    return 1;\n  }\n  zDate += 5;\n  p->tz = sgn*(nMn + nHr*60);\nzulu_time:\n  while( sqlite3Isspace(*zDate) ){ zDate++; }\n  return *zDate!=0;\n}\n\n/*\n** Parse times of the form HH:MM or HH:MM:SS or HH:MM:SS.FFFF.\n** The HH, MM, and SS must each be exactly 2 digits.  The\n** fractional seconds FFFF can be one or more digits.\n**\n** Return 1 if there is a parsing error and 0 on success.\n*/\nstatic int parseHhMmSs(const char *zDate, DateTime *p){\n  int h, m, s;\n  double ms = 0.0;\n  if( getDigits(zDate, 2, 0, 24, ':', &h, 2, 0, 59, 0, &m)!=2 ){\n    return 1;\n  }\n  zDate += 5;\n  if( *zDate==':' ){\n    zDate++;\n    if( getDigits(zDate, 2, 0, 59, 0, &s)!=1 ){\n      return 1;\n    }\n    zDate += 2;\n    if( *zDate=='.' && sqlite3Isdigit(zDate[1]) ){\n      double rScale = 1.0;\n      zDate++;\n      while( sqlite3Isdigit(*zDate) ){\n        ms = ms*10.0 + *zDate - '0';\n        rScale *= 10.0;\n        zDate++;\n      }\n      ms /= rScale;\n    }\n  }else{\n    s = 0;\n  }\n  p->validJD = 0;\n  p->validHMS = 1;\n  p->h = h;\n  p->m = m;\n  p->s = s + ms;\n  if( parseTimezone(zDate, p) ) return 1;\n  p->validTZ = (p->tz!=0)?1:0;\n  return 0;\n}\n\n/*\n** Convert from YYYY-MM-DD HH:MM:SS to julian day.  We always assume\n** that the YYYY-MM-DD is according to the Gregorian calendar.\n**\n** Reference:  Meeus page 61\n*/\nstatic void computeJD(DateTime *p){\n  int Y, M, D, A, B, X1, X2;\n\n  if( p->validJD ) return;\n  if( p->validYMD ){\n    Y = p->Y;\n    M = p->M;\n    D = p->D;\n  }else{\n    Y = 2000;  /* If no YMD specified, assume 2000-Jan-01 */\n    M = 1;\n    D = 1;\n  }\n  if( M<=2 ){\n    Y--;\n    M += 12;\n  }\n  A = Y/100;\n  B = 2 - A + (A/4);\n  X1 = 36525*(Y+4716)/100;\n  X2 = 306001*(M+1)/10000;\n  p->iJD = (sqlite3_int64)((X1 + X2 + D + B - 1524.5 ) * 86400000);\n  p->validJD = 1;\n  if( p->validHMS ){\n    p->iJD += p->h*3600000 + p->m*60000 + (sqlite3_int64)(p->s*1000);\n    if( p->validTZ ){\n      p->iJD -= p->tz*60000;\n      p->validYMD = 0;\n      p->validHMS = 0;\n      p->validTZ = 0;\n    }\n  }\n}\n\n/*\n** Parse dates of the form\n**\n**     YYYY-MM-DD HH:MM:SS.FFF\n**     YYYY-MM-DD HH:MM:SS\n**     YYYY-MM-DD HH:MM\n**     YYYY-MM-DD\n**\n** Write the result into the DateTime structure and return 0\n** on success and 1 if the input string is not a well-formed\n** date.\n*/\nstatic int parseYyyyMmDd(const char *zDate, DateTime *p){\n  int Y, M, D, neg;\n\n  if( zDate[0]=='-' ){\n    zDate++;\n    neg = 1;\n  }else{\n    neg = 0;\n  }\n  if( getDigits(zDate,4,0,9999,'-',&Y,2,1,12,'-',&M,2,1,31,0,&D)!=3 ){\n    return 1;\n  }\n  zDate += 10;\n  while( sqlite3Isspace(*zDate) || 'T'==*(u8*)zDate ){ zDate++; }\n  if( parseHhMmSs(zDate, p)==0 ){\n    /* We got the time */\n  }else if( *zDate==0 ){\n    p->validHMS = 0;\n  }else{\n    return 1;\n  }\n  p->validJD = 0;\n  p->validYMD = 1;\n  p->Y = neg ? -Y : Y;\n  p->M = M;\n  p->D = D;\n  if( p->validTZ ){\n    computeJD(p);\n  }\n  return 0;\n}\n\n/*\n** Set the time to the current time reported by the VFS\n*/\nstatic void setDateTimeToCurrent(sqlite3_context *context, DateTime *p){\n  sqlite3 *db = sqlite3_context_db_handle(context);\n  sqlite3OsCurrentTimeInt64(db->pVfs, &p->iJD);\n  p->validJD = 1;\n}\n\n/*\n** Attempt to parse the given string into a Julian Day Number.  Return\n** the number of errors.\n**\n** The following are acceptable forms for the input string:\n**\n**      YYYY-MM-DD HH:MM:SS.FFF  +/-HH:MM\n**      DDDD.DD \n**      now\n**\n** In the first form, the +/-HH:MM is always optional.  The fractional\n** seconds extension (the \".FFF\") is optional.  The seconds portion\n** (\":SS.FFF\") is option.  The year and date can be omitted as long\n** as there is a time string.  The time string can be omitted as long\n** as there is a year and date.\n*/\nstatic int parseDateOrTime(\n  sqlite3_context *context, \n  const char *zDate, \n  DateTime *p\n){\n  double r;\n  if( parseYyyyMmDd(zDate,p)==0 ){\n    return 0;\n  }else if( parseHhMmSs(zDate, p)==0 ){\n    return 0;\n  }else if( sqlite3StrICmp(zDate,\"now\")==0){\n    setDateTimeToCurrent(context, p);\n    return 0;\n  }else if( sqlite3AtoF(zDate, &r, sqlite3Strlen30(zDate), SQLITE_UTF8) ){\n    p->iJD = (sqlite3_int64)(r*86400000.0 + 0.5);\n    p->validJD = 1;\n    return 0;\n  }\n  return 1;\n}\n\n/*\n** Compute the Year, Month, and Day from the julian day number.\n*/\nstatic void computeYMD(DateTime *p){\n  int Z, A, B, C, D, E, X1;\n  if( p->validYMD ) return;\n  if( !p->validJD ){\n    p->Y = 2000;\n    p->M = 1;\n    p->D = 1;\n  }else{\n    Z = (int)((p->iJD + 43200000)/86400000);\n    A = (int)((Z - 1867216.25)/36524.25);\n    A = Z + 1 + A - (A/4);\n    B = A + 1524;\n    C = (int)((B - 122.1)/365.25);\n    D = (36525*C)/100;\n    E = (int)((B-D)/30.6001);\n    X1 = (int)(30.6001*E);\n    p->D = B - D - X1;\n    p->M = E<14 ? E-1 : E-13;\n    p->Y = p->M>2 ? C - 4716 : C - 4715;\n  }\n  p->validYMD = 1;\n}\n\n/*\n** Compute the Hour, Minute, and Seconds from the julian day number.\n*/\nstatic void computeHMS(DateTime *p){\n  int s;\n  if( p->validHMS ) return;\n  computeJD(p);\n  s = (int)((p->iJD + 43200000) % 86400000);\n  p->s = s/1000.0;\n  s = (int)p->s;\n  p->s -= s;\n  p->h = s/3600;\n  s -= p->h*3600;\n  p->m = s/60;\n  p->s += s - p->m*60;\n  p->validHMS = 1;\n}\n\n/*\n** Compute both YMD and HMS\n*/\nstatic void computeYMD_HMS(DateTime *p){\n  computeYMD(p);\n  computeHMS(p);\n}\n\n/*\n** Clear the YMD and HMS and the TZ\n*/\nstatic void clearYMD_HMS_TZ(DateTime *p){\n  p->validYMD = 0;\n  p->validHMS = 0;\n  p->validTZ = 0;\n}\n\n#ifndef SQLITE_OMIT_LOCALTIME\n/*\n** Compute the difference (in milliseconds)\n** between localtime and UTC (a.k.a. GMT)\n** for the time value p where p is in UTC.\n*/\nstatic sqlite3_int64 localtimeOffset(DateTime *p){\n  DateTime x, y;\n  time_t t;\n  x = *p;\n  computeYMD_HMS(&x);\n  if( x.Y<1971 || x.Y>=2038 ){\n    x.Y = 2000;\n    x.M = 1;\n    x.D = 1;\n    x.h = 0;\n    x.m = 0;\n    x.s = 0.0;\n  } else {\n    int s = (int)(x.s + 0.5);\n    x.s = s;\n  }\n  x.tz = 0;\n  x.validJD = 0;\n  computeJD(&x);\n  t = (time_t)(x.iJD/1000 - 21086676*(i64)10000);\n#ifdef HAVE_LOCALTIME_R\n  {\n    struct tm sLocal;\n    localtime_r(&t, &sLocal);\n    y.Y = sLocal.tm_year + 1900;\n    y.M = sLocal.tm_mon + 1;\n    y.D = sLocal.tm_mday;\n    y.h = sLocal.tm_hour;\n    y.m = sLocal.tm_min;\n    y.s = sLocal.tm_sec;\n  }\n#elif defined(HAVE_LOCALTIME_S) && HAVE_LOCALTIME_S\n  {\n    struct tm sLocal;\n    localtime_s(&sLocal, &t);\n    y.Y = sLocal.tm_year + 1900;\n    y.M = sLocal.tm_mon + 1;\n    y.D = sLocal.tm_mday;\n    y.h = sLocal.tm_hour;\n    y.m = sLocal.tm_min;\n    y.s = sLocal.tm_sec;\n  }\n#else\n  {\n    struct tm *pTm;\n    sqlite3_mutex_enter(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER));\n    pTm = localtime(&t);\n    y.Y = pTm->tm_year + 1900;\n    y.M = pTm->tm_mon + 1;\n    y.D = pTm->tm_mday;\n    y.h = pTm->tm_hour;\n    y.m = pTm->tm_min;\n    y.s = pTm->tm_sec;\n    sqlite3_mutex_leave(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER));\n  }\n#endif\n  y.validYMD = 1;\n  y.validHMS = 1;\n  y.validJD = 0;\n  y.validTZ = 0;\n  computeJD(&y);\n  return y.iJD - x.iJD;\n}\n#endif /* SQLITE_OMIT_LOCALTIME */\n\n/*\n** Process a modifier to a date-time stamp.  The modifiers are\n** as follows:\n**\n**     NNN days\n**     NNN hours\n**     NNN minutes\n**     NNN.NNNN seconds\n**     NNN months\n**     NNN years\n**     start of month\n**     start of year\n**     start of week\n**     start of day\n**     weekday N\n**     unixepoch\n**     localtime\n**     utc\n**\n** Return 0 on success and 1 if there is any kind of error.\n*/\nstatic int parseModifier(const char *zMod, DateTime *p){\n  int rc = 1;\n  int n;\n  double r;\n  char *z, zBuf[30];\n  z = zBuf;\n  for(n=0; n<ArraySize(zBuf)-1 && zMod[n]; n++){\n    z[n] = (char)sqlite3UpperToLower[(u8)zMod[n]];\n  }\n  z[n] = 0;\n  switch( z[0] ){\n#ifndef SQLITE_OMIT_LOCALTIME\n    case 'l': {\n      /*    localtime\n      **\n      ** Assuming the current time value is UTC (a.k.a. GMT), shift it to\n      ** show local time.\n      */\n      if( strcmp(z, \"localtime\")==0 ){\n        computeJD(p);\n        p->iJD += localtimeOffset(p);\n        clearYMD_HMS_TZ(p);\n        rc = 0;\n      }\n      break;\n    }\n#endif\n    case 'u': {\n      /*\n      **    unixepoch\n      **\n      ** Treat the current value of p->iJD as the number of\n      ** seconds since 1970.  Convert to a real julian day number.\n      */\n      if( strcmp(z, \"unixepoch\")==0 && p->validJD ){\n        p->iJD = (p->iJD + 43200)/86400 + 21086676*(i64)10000000;\n        clearYMD_HMS_TZ(p);\n        rc = 0;\n      }\n#ifndef SQLITE_OMIT_LOCALTIME\n      else if( strcmp(z, \"utc\")==0 ){\n        sqlite3_int64 c1;\n        computeJD(p);\n        c1 = localtimeOffset(p);\n        p->iJD -= c1;\n        clearYMD_HMS_TZ(p);\n        p->iJD += c1 - localtimeOffset(p);\n        rc = 0;\n      }\n#endif\n      break;\n    }\n    case 'w': {\n      /*\n      **    weekday N\n      **\n      ** Move the date to the same time on the next occurrence of\n      ** weekday N where 0==Sunday, 1==Monday, and so forth.  If the\n      ** date is already on the appropriate weekday, this is a no-op.\n      */\n      if( strncmp(z, \"weekday \", 8)==0\n               && sqlite3AtoF(&z[8], &r, sqlite3Strlen30(&z[8]), SQLITE_UTF8)\n               && (n=(int)r)==r && n>=0 && r<7 ){\n        sqlite3_int64 Z;\n        computeYMD_HMS(p);\n        p->validTZ = 0;\n        p->validJD = 0;\n        computeJD(p);\n        Z = ((p->iJD + 129600000)/86400000) % 7;\n        if( Z>n ) Z -= 7;\n        p->iJD += (n - Z)*86400000;\n        clearYMD_HMS_TZ(p);\n        rc = 0;\n      }\n      break;\n    }\n    case 's': {\n      /*\n      **    start of TTTTT\n      **\n      ** Move the date backwards to the beginning of the current day,\n      ** or month or year.\n      */\n      if( strncmp(z, \"start of \", 9)!=0 ) break;\n      z += 9;\n      computeYMD(p);\n      p->validHMS = 1;\n      p->h = p->m = 0;\n      p->s = 0.0;\n      p->validTZ = 0;\n      p->validJD = 0;\n      if( strcmp(z,\"month\")==0 ){\n        p->D = 1;\n        rc = 0;\n      }else if( strcmp(z,\"year\")==0 ){\n        computeYMD(p);\n        p->M = 1;\n        p->D = 1;\n        rc = 0;\n      }else if( strcmp(z,\"day\")==0 ){\n        rc = 0;\n      }\n      break;\n    }\n    case '+':\n    case '-':\n    case '0':\n    case '1':\n    case '2':\n    case '3':\n    case '4':\n    case '5':\n    case '6':\n    case '7':\n    case '8':\n    case '9': {\n      double rRounder;\n      for(n=1; z[n] && z[n]!=':' && !sqlite3Isspace(z[n]); n++){}\n      if( !sqlite3AtoF(z, &r, n, SQLITE_UTF8) ){\n        rc = 1;\n        break;\n      }\n      if( z[n]==':' ){\n        /* A modifier of the form (+|-)HH:MM:SS.FFF adds (or subtracts) the\n        ** specified number of hours, minutes, seconds, and fractional seconds\n        ** to the time.  The \".FFF\" may be omitted.  The \":SS.FFF\" may be\n        ** omitted.\n        */\n        const char *z2 = z;\n        DateTime tx;\n        sqlite3_int64 day;\n        if( !sqlite3Isdigit(*z2) ) z2++;\n        memset(&tx, 0, sizeof(tx));\n        if( parseHhMmSs(z2, &tx) ) break;\n        computeJD(&tx);\n        tx.iJD -= 43200000;\n        day = tx.iJD/86400000;\n        tx.iJD -= day*86400000;\n        if( z[0]=='-' ) tx.iJD = -tx.iJD;\n        computeJD(p);\n        clearYMD_HMS_TZ(p);\n        p->iJD += tx.iJD;\n        rc = 0;\n        break;\n      }\n      z += n;\n      while( sqlite3Isspace(*z) ) z++;\n      n = sqlite3Strlen30(z);\n      if( n>10 || n<3 ) break;\n      if( z[n-1]=='s' ){ z[n-1] = 0; n--; }\n      computeJD(p);\n      rc = 0;\n      rRounder = r<0 ? -0.5 : +0.5;\n      if( n==3 && strcmp(z,\"day\")==0 ){\n        p->iJD += (sqlite3_int64)(r*86400000.0 + rRounder);\n      }else if( n==4 && strcmp(z,\"hour\")==0 ){\n        p->iJD += (sqlite3_int64)(r*(86400000.0/24.0) + rRounder);\n      }else if( n==6 && strcmp(z,\"minute\")==0 ){\n        p->iJD += (sqlite3_int64)(r*(86400000.0/(24.0*60.0)) + rRounder);\n      }else if( n==6 && strcmp(z,\"second\")==0 ){\n        p->iJD += (sqlite3_int64)(r*(86400000.0/(24.0*60.0*60.0)) + rRounder);\n      }else if( n==5 && strcmp(z,\"month\")==0 ){\n        int x, y;\n        computeYMD_HMS(p);\n        p->M += (int)r;\n        x = p->M>0 ? (p->M-1)/12 : (p->M-12)/12;\n        p->Y += x;\n        p->M -= x*12;\n        p->validJD = 0;\n        computeJD(p);\n        y = (int)r;\n        if( y!=r ){\n          p->iJD += (sqlite3_int64)((r - y)*30.0*86400000.0 + rRounder);\n        }\n      }else if( n==4 && strcmp(z,\"year\")==0 ){\n        int y = (int)r;\n        computeYMD_HMS(p);\n        p->Y += y;\n        p->validJD = 0;\n        computeJD(p);\n        if( y!=r ){\n          p->iJD += (sqlite3_int64)((r - y)*365.0*86400000.0 + rRounder);\n        }\n      }else{\n        rc = 1;\n      }\n      clearYMD_HMS_TZ(p);\n      break;\n    }\n    default: {\n      break;\n    }\n  }\n  return rc;\n}\n\n/*\n** Process time function arguments.  argv[0] is a date-time stamp.\n** argv[1] and following are modifiers.  Parse them all and write\n** the resulting time into the DateTime structure p.  Return 0\n** on success and 1 if there are any errors.\n**\n** If there are zero parameters (if even argv[0] is undefined)\n** then assume a default value of \"now\" for argv[0].\n*/\nstatic int isDate(\n  sqlite3_context *context, \n  int argc, \n  sqlite3_value **argv, \n  DateTime *p\n){\n  int i;\n  const unsigned char *z;\n  int eType;\n  memset(p, 0, sizeof(*p));\n  if( argc==0 ){\n    setDateTimeToCurrent(context, p);\n  }else if( (eType = sqlite3_value_type(argv[0]))==SQLITE_FLOAT\n                   || eType==SQLITE_INTEGER ){\n    p->iJD = (sqlite3_int64)(sqlite3_value_double(argv[0])*86400000.0 + 0.5);\n    p->validJD = 1;\n  }else{\n    z = sqlite3_value_text(argv[0]);\n    if( !z || parseDateOrTime(context, (char*)z, p) ){\n      return 1;\n    }\n  }\n  for(i=1; i<argc; i++){\n    if( (z = sqlite3_value_text(argv[i]))==0 || parseModifier((char*)z, p) ){\n      return 1;\n    }\n  }\n  return 0;\n}\n\n\n/*\n** The following routines implement the various date and time functions\n** of SQLite.\n*/\n\n/*\n**    julianday( TIMESTRING, MOD, MOD, ...)\n**\n** Return the julian day number of the date specified in the arguments\n*/\nstatic void juliandayFunc(\n  sqlite3_context *context,\n  int argc,\n  sqlite3_value **argv\n){\n  DateTime x;\n  if( isDate(context, argc, argv, &x)==0 ){\n    computeJD(&x);\n    sqlite3_result_double(context, x.iJD/86400000.0);\n  }\n}\n\n/*\n**    datetime( TIMESTRING, MOD, MOD, ...)\n**\n** Return YYYY-MM-DD HH:MM:SS\n*/\nstatic void datetimeFunc(\n  sqlite3_context *context,\n  int argc,\n  sqlite3_value **argv\n){\n  DateTime x;\n  if( isDate(context, argc, argv, &x)==0 ){\n    char zBuf[100];\n    computeYMD_HMS(&x);\n    sqlite3_snprintf(sizeof(zBuf), zBuf, \"%04d-%02d-%02d %02d:%02d:%02d\",\n                     x.Y, x.M, x.D, x.h, x.m, (int)(x.s));\n    sqlite3_result_text(context, zBuf, -1, SQLITE_TRANSIENT);\n  }\n}\n\n/*\n**    time( TIMESTRING, MOD, MOD, ...)\n**\n** Return HH:MM:SS\n*/\nstatic void timeFunc(\n  sqlite3_context *context,\n  int argc,\n  sqlite3_value **argv\n){\n  DateTime x;\n  if( isDate(context, argc, argv, &x)==0 ){\n    char zBuf[100];\n    computeHMS(&x);\n    sqlite3_snprintf(sizeof(zBuf), zBuf, \"%02d:%02d:%02d\", x.h, x.m, (int)x.s);\n    sqlite3_result_text(context, zBuf, -1, SQLITE_TRANSIENT);\n  }\n}\n\n/*\n**    date( TIMESTRING, MOD, MOD, ...)\n**\n** Return YYYY-MM-DD\n*/\nstatic void dateFunc(\n  sqlite3_context *context,\n  int argc,\n  sqlite3_value **argv\n){\n  DateTime x;\n  if( isDate(context, argc, argv, &x)==0 ){\n    char zBuf[100];\n    computeYMD(&x);\n    sqlite3_snprintf(sizeof(zBuf), zBuf, \"%04d-%02d-%02d\", x.Y, x.M, x.D);\n    sqlite3_result_text(context, zBuf, -1, SQLITE_TRANSIENT);\n  }\n}\n\n/*\n**    strftime( FORMAT, TIMESTRING, MOD, MOD, ...)\n**\n** Return a string described by FORMAT.  Conversions as follows:\n**\n**   %d  day of month\n**   %f  ** fractional seconds  SS.SSS\n**   %H  hour 00-24\n**   %j  day of year 000-366\n**   %J  ** Julian day number\n**   %m  month 01-12\n**   %M  minute 00-59\n**   %s  seconds since 1970-01-01\n**   %S  seconds 00-59\n**   %w  day of week 0-6  sunday==0\n**   %W  week of year 00-53\n**   %Y  year 0000-9999\n**   %%  %\n*/\nstatic void strftimeFunc(\n  sqlite3_context *context,\n  int argc,\n  sqlite3_value **argv\n){\n  DateTime x;\n  u64 n;\n  size_t i,j;\n  char *z;\n  sqlite3 *db;\n  const char *zFmt = (const char*)sqlite3_value_text(argv[0]);\n  char zBuf[100];\n  if( zFmt==0 || isDate(context, argc-1, argv+1, &x) ) return;\n  db = sqlite3_context_db_handle(context);\n  for(i=0, n=1; zFmt[i]; i++, n++){\n    if( zFmt[i]=='%' ){\n      switch( zFmt[i+1] ){\n        case 'd':\n        case 'H':\n        case 'm':\n        case 'M':\n        case 'S':\n        case 'W':\n          n++;\n          /* fall thru */\n        case 'w':\n        case '%':\n          break;\n        case 'f':\n          n += 8;\n          break;\n        case 'j':\n          n += 3;\n          break;\n        case 'Y':\n          n += 8;\n          break;\n        case 's':\n        case 'J':\n          n += 50;\n          break;\n        default:\n          return;  /* ERROR.  return a NULL */\n      }\n      i++;\n    }\n  }\n  testcase( n==sizeof(zBuf)-1 );\n  testcase( n==sizeof(zBuf) );\n  testcase( n==(u64)db->aLimit[SQLITE_LIMIT_LENGTH]+1 );\n  testcase( n==(u64)db->aLimit[SQLITE_LIMIT_LENGTH] );\n  if( n<sizeof(zBuf) ){\n    z = zBuf;\n  }else if( n>(u64)db->aLimit[SQLITE_LIMIT_LENGTH] ){\n    sqlite3_result_error_toobig(context);\n    return;\n  }else{\n    z = sqlite3DbMallocRaw(db, (int)n);\n    if( z==0 ){\n      sqlite3_result_error_nomem(context);\n      return;\n    }\n  }\n  computeJD(&x);\n  computeYMD_HMS(&x);\n  for(i=j=0; zFmt[i]; i++){\n    if( zFmt[i]!='%' ){\n      z[j++] = zFmt[i];\n    }else{\n      i++;\n      switch( zFmt[i] ){\n        case 'd':  sqlite3_snprintf(3, &z[j],\"%02d\",x.D); j+=2; break;\n        case 'f': {\n          double s = x.s;\n          if( s>59.999 ) s = 59.999;\n          sqlite3_snprintf(7, &z[j],\"%06.3f\", s);\n          j += sqlite3Strlen30(&z[j]);\n          break;\n        }\n        case 'H':  sqlite3_snprintf(3, &z[j],\"%02d\",x.h); j+=2; break;\n        case 'W': /* Fall thru */\n        case 'j': {\n          int nDay;             /* Number of days since 1st day of year */\n          DateTime y = x;\n          y.validJD = 0;\n          y.M = 1;\n          y.D = 1;\n          computeJD(&y);\n          nDay = (int)((x.iJD-y.iJD+43200000)/86400000);\n          if( zFmt[i]=='W' ){\n            int wd;   /* 0=Monday, 1=Tuesday, ... 6=Sunday */\n            wd = (int)(((x.iJD+43200000)/86400000)%7);\n            sqlite3_snprintf(3, &z[j],\"%02d\",(nDay+7-wd)/7);\n            j += 2;\n          }else{\n            sqlite3_snprintf(4, &z[j],\"%03d\",nDay+1);\n            j += 3;\n          }\n          break;\n        }\n        case 'J': {\n          sqlite3_snprintf(20, &z[j],\"%.16g\",x.iJD/86400000.0);\n          j+=sqlite3Strlen30(&z[j]);\n          break;\n        }\n        case 'm':  sqlite3_snprintf(3, &z[j],\"%02d\",x.M); j+=2; break;\n        case 'M':  sqlite3_snprintf(3, &z[j],\"%02d\",x.m); j+=2; break;\n        case 's': {\n          sqlite3_snprintf(30,&z[j],\"%lld\",\n                           (i64)(x.iJD/1000 - 21086676*(i64)10000));\n          j += sqlite3Strlen30(&z[j]);\n          break;\n        }\n        case 'S':  sqlite3_snprintf(3,&z[j],\"%02d\",(int)x.s); j+=2; break;\n        case 'w': {\n          z[j++] = (char)(((x.iJD+129600000)/86400000) % 7) + '0';\n          break;\n        }\n        case 'Y': {\n          sqlite3_snprintf(5,&z[j],\"%04d\",x.Y); j+=sqlite3Strlen30(&z[j]);\n          break;\n        }\n        default:   z[j++] = '%'; break;\n      }\n    }\n  }\n  z[j] = 0;\n  sqlite3_result_text(context, z, -1,\n                      z==zBuf ? SQLITE_TRANSIENT : SQLITE_DYNAMIC);\n}\n\n/*\n** current_time()\n**\n** This function returns the same value as time('now').\n*/\nstatic void ctimeFunc(\n  sqlite3_context *context,\n  int NotUsed,\n  sqlite3_value **NotUsed2\n){\n  UNUSED_PARAMETER2(NotUsed, NotUsed2);\n  timeFunc(context, 0, 0);\n}\n\n/*\n** current_date()\n**\n** This function returns the same value as date('now').\n*/\nstatic void cdateFunc(\n  sqlite3_context *context,\n  int NotUsed,\n  sqlite3_value **NotUsed2\n){\n  UNUSED_PARAMETER2(NotUsed, NotUsed2);\n  dateFunc(context, 0, 0);\n}\n\n/*\n** current_timestamp()\n**\n** This function returns the same value as datetime('now').\n*/\nstatic void ctimestampFunc(\n  sqlite3_context *context,\n  int NotUsed,\n  sqlite3_value **NotUsed2\n){\n  UNUSED_PARAMETER2(NotUsed, NotUsed2);\n  datetimeFunc(context, 0, 0);\n}\n#endif /* !defined(SQLITE_OMIT_DATETIME_FUNCS) */\n\n#ifdef SQLITE_OMIT_DATETIME_FUNCS\n/*\n** If the library is compiled to omit the full-scale date and time\n** handling (to get a smaller binary), the following minimal version\n** of the functions current_time(), current_date() and current_timestamp()\n** are included instead. This is to support column declarations that\n** include \"DEFAULT CURRENT_TIME\" etc.\n**\n** This function uses the C-library functions time(), gmtime()\n** and strftime(). The format string to pass to strftime() is supplied\n** as the user-data for the function.\n*/\nstatic void currentTimeFunc(\n  sqlite3_context *context,\n  int argc,\n  sqlite3_value **argv\n){\n  time_t t;\n  char *zFormat = (char *)sqlite3_user_data(context);\n  sqlite3 *db;\n  sqlite3_int64 iT;\n  char zBuf[20];\n\n  UNUSED_PARAMETER(argc);\n  UNUSED_PARAMETER(argv);\n\n  db = sqlite3_context_db_handle(context);\n  sqlite3OsCurrentTimeInt64(db->pVfs, &iT);\n  t = iT/1000 - 10000*(sqlite3_int64)21086676;\n#ifdef HAVE_GMTIME_R\n  {\n    struct tm sNow;\n    gmtime_r(&t, &sNow);\n    strftime(zBuf, 20, zFormat, &sNow);\n  }\n#else\n  {\n    struct tm *pTm;\n    sqlite3_mutex_enter(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER));\n    pTm = gmtime(&t);\n    strftime(zBuf, 20, zFormat, pTm);\n    sqlite3_mutex_leave(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER));\n  }\n#endif\n\n  sqlite3_result_text(context, zBuf, -1, SQLITE_TRANSIENT);\n}\n#endif\n\n/*\n** This function registered all of the above C functions as SQL\n** functions.  This should be the only routine in this file with\n** external linkage.\n*/\nSQLITE_PRIVATE void sqlite3RegisterDateTimeFunctions(void){\n  static SQLITE_WSD FuncDef aDateTimeFuncs[] = {\n#ifndef SQLITE_OMIT_DATETIME_FUNCS\n    FUNCTION(julianday,        -1, 0, 0, juliandayFunc ),\n    FUNCTION(date,             -1, 0, 0, dateFunc      ),\n    FUNCTION(time,             -1, 0, 0, timeFunc      ),\n    FUNCTION(datetime,         -1, 0, 0, datetimeFunc  ),\n    FUNCTION(strftime,         -1, 0, 0, strftimeFunc  ),\n    FUNCTION(current_time,      0, 0, 0, ctimeFunc     ),\n    FUNCTION(current_timestamp, 0, 0, 0, ctimestampFunc),\n    FUNCTION(current_date,      0, 0, 0, cdateFunc     ),\n#else\n    STR_FUNCTION(current_time,      0, \"%H:%M:%S\",          0, currentTimeFunc),\n    STR_FUNCTION(current_date,      0, \"%Y-%m-%d\",          0, currentTimeFunc),\n    STR_FUNCTION(current_timestamp, 0, \"%Y-%m-%d %H:%M:%S\", 0, currentTimeFunc),\n#endif\n  };\n  int i;\n  FuncDefHash *pHash = &GLOBAL(FuncDefHash, sqlite3GlobalFunctions);\n  FuncDef *aFunc = (FuncDef*)&GLOBAL(FuncDef, aDateTimeFuncs);\n\n  for(i=0; i<ArraySize(aDateTimeFuncs); i++){\n    sqlite3FuncDefInsert(pHash, &aFunc[i]);\n  }\n}\n\n/************** End of date.c ************************************************/\n/************** Begin file os.c **********************************************/\n/*\n** 2005 November 29\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n******************************************************************************\n**\n** This file contains OS interface code that is common to all\n** architectures.\n*/\n#define _SQLITE_OS_C_ 1\n#undef _SQLITE_OS_C_\n\n/*\n** The default SQLite sqlite3_vfs implementations do not allocate\n** memory (actually, os_unix.c allocates a small amount of memory\n** from within OsOpen()), but some third-party implementations may.\n** So we test the effects of a malloc() failing and the sqlite3OsXXX()\n** function returning SQLITE_IOERR_NOMEM using the DO_OS_MALLOC_TEST macro.\n**\n** The following functions are instrumented for malloc() failure \n** testing:\n**\n**     sqlite3OsOpen()\n**     sqlite3OsRead()\n**     sqlite3OsWrite()\n**     sqlite3OsSync()\n**     sqlite3OsLock()\n**\n*/\n#if defined(SQLITE_TEST)\nSQLITE_API int sqlite3_memdebug_vfs_oom_test = 1;\n  #define DO_OS_MALLOC_TEST(x)                                       \\\n  if (sqlite3_memdebug_vfs_oom_test && (!x || !sqlite3IsMemJournal(x))) {  \\\n    void *pTstAlloc = sqlite3Malloc(10);                             \\\n    if (!pTstAlloc) return SQLITE_IOERR_NOMEM;                       \\\n    sqlite3_free(pTstAlloc);                                         \\\n  }\n#else\n  #define DO_OS_MALLOC_TEST(x)\n#endif\n\n/*\n** The following routines are convenience wrappers around methods\n** of the sqlite3_file object.  This is mostly just syntactic sugar. All\n** of this would be completely automatic if SQLite were coded using\n** C++ instead of plain old C.\n*/\nSQLITE_PRIVATE int sqlite3OsClose(sqlite3_file *pId){\n  int rc = SQLITE_OK;\n  if( pId->pMethods ){\n    rc = pId->pMethods->xClose(pId);\n    pId->pMethods = 0;\n  }\n  return rc;\n}\nSQLITE_PRIVATE int sqlite3OsRead(sqlite3_file *id, void *pBuf, int amt, i64 offset){\n  DO_OS_MALLOC_TEST(id);\n  return id->pMethods->xRead(id, pBuf, amt, offset);\n}\nSQLITE_PRIVATE int sqlite3OsWrite(sqlite3_file *id, const void *pBuf, int amt, i64 offset){\n  DO_OS_MALLOC_TEST(id);\n  return id->pMethods->xWrite(id, pBuf, amt, offset);\n}\nSQLITE_PRIVATE int sqlite3OsTruncate(sqlite3_file *id, i64 size){\n  return id->pMethods->xTruncate(id, size);\n}\nSQLITE_PRIVATE int sqlite3OsSync(sqlite3_file *id, int flags){\n  DO_OS_MALLOC_TEST(id);\n  return id->pMethods->xSync(id, flags);\n}\nSQLITE_PRIVATE int sqlite3OsFileSize(sqlite3_file *id, i64 *pSize){\n  DO_OS_MALLOC_TEST(id);\n  return id->pMethods->xFileSize(id, pSize);\n}\nSQLITE_PRIVATE int sqlite3OsLock(sqlite3_file *id, int lockType){\n  DO_OS_MALLOC_TEST(id);\n  return id->pMethods->xLock(id, lockType);\n}\nSQLITE_PRIVATE int sqlite3OsUnlock(sqlite3_file *id, int lockType){\n  return id->pMethods->xUnlock(id, lockType);\n}\nSQLITE_PRIVATE int sqlite3OsCheckReservedLock(sqlite3_file *id, int *pResOut){\n  DO_OS_MALLOC_TEST(id);\n  return id->pMethods->xCheckReservedLock(id, pResOut);\n}\nSQLITE_PRIVATE int sqlite3OsFileControl(sqlite3_file *id, int op, void *pArg){\n  return id->pMethods->xFileControl(id, op, pArg);\n}\nSQLITE_PRIVATE int sqlite3OsSectorSize(sqlite3_file *id){\n  int (*xSectorSize)(sqlite3_file*) = id->pMethods->xSectorSize;\n  return (xSectorSize ? xSectorSize(id) : SQLITE_DEFAULT_SECTOR_SIZE);\n}\nSQLITE_PRIVATE int sqlite3OsDeviceCharacteristics(sqlite3_file *id){\n  return id->pMethods->xDeviceCharacteristics(id);\n}\nSQLITE_PRIVATE int sqlite3OsShmLock(sqlite3_file *id, int offset, int n, int flags){\n  return id->pMethods->xShmLock(id, offset, n, flags);\n}\nSQLITE_PRIVATE void sqlite3OsShmBarrier(sqlite3_file *id){\n  id->pMethods->xShmBarrier(id);\n}\nSQLITE_PRIVATE int sqlite3OsShmUnmap(sqlite3_file *id, int deleteFlag){\n  return id->pMethods->xShmUnmap(id, deleteFlag);\n}\nSQLITE_PRIVATE int sqlite3OsShmMap(\n  sqlite3_file *id,               /* Database file handle */\n  int iPage,\n  int pgsz,\n  int bExtend,                    /* True to extend file if necessary */\n  void volatile **pp              /* OUT: Pointer to mapping */\n){\n  return id->pMethods->xShmMap(id, iPage, pgsz, bExtend, pp);\n}\n\n/*\n** The next group of routines are convenience wrappers around the\n** VFS methods.\n*/\nSQLITE_PRIVATE int sqlite3OsOpen(\n  sqlite3_vfs *pVfs, \n  const char *zPath, \n  sqlite3_file *pFile, \n  int flags, \n  int *pFlagsOut\n){\n  int rc;\n  DO_OS_MALLOC_TEST(0);\n  /* 0x87f3f is a mask of SQLITE_OPEN_ flags that are valid to be passed\n  ** down into the VFS layer.  Some SQLITE_OPEN_ flags (for example,\n  ** SQLITE_OPEN_FULLMUTEX or SQLITE_OPEN_SHAREDCACHE) are blocked before\n  ** reaching the VFS. */\n  rc = pVfs->xOpen(pVfs, zPath, pFile, flags & 0x87f3f, pFlagsOut);\n  assert( rc==SQLITE_OK || pFile->pMethods==0 );\n  return rc;\n}\nSQLITE_PRIVATE int sqlite3OsDelete(sqlite3_vfs *pVfs, const char *zPath, int dirSync){\n  return pVfs->xDelete(pVfs, zPath, dirSync);\n}\nSQLITE_PRIVATE int sqlite3OsAccess(\n  sqlite3_vfs *pVfs, \n  const char *zPath, \n  int flags, \n  int *pResOut\n){\n  DO_OS_MALLOC_TEST(0);\n  return pVfs->xAccess(pVfs, zPath, flags, pResOut);\n}\nSQLITE_PRIVATE int sqlite3OsFullPathname(\n  sqlite3_vfs *pVfs, \n  const char *zPath, \n  int nPathOut, \n  char *zPathOut\n){\n  zPathOut[0] = 0;\n  return pVfs->xFullPathname(pVfs, zPath, nPathOut, zPathOut);\n}\n#ifndef SQLITE_OMIT_LOAD_EXTENSION\nSQLITE_PRIVATE void *sqlite3OsDlOpen(sqlite3_vfs *pVfs, const char *zPath){\n  return pVfs->xDlOpen(pVfs, zPath);\n}\nSQLITE_PRIVATE void sqlite3OsDlError(sqlite3_vfs *pVfs, int nByte, char *zBufOut){\n  pVfs->xDlError(pVfs, nByte, zBufOut);\n}\nSQLITE_PRIVATE void (*sqlite3OsDlSym(sqlite3_vfs *pVfs, void *pHdle, const char *zSym))(void){\n  return pVfs->xDlSym(pVfs, pHdle, zSym);\n}\nSQLITE_PRIVATE void sqlite3OsDlClose(sqlite3_vfs *pVfs, void *pHandle){\n  pVfs->xDlClose(pVfs, pHandle);\n}\n#endif /* SQLITE_OMIT_LOAD_EXTENSION */\nSQLITE_PRIVATE int sqlite3OsRandomness(sqlite3_vfs *pVfs, int nByte, char *zBufOut){\n  return pVfs->xRandomness(pVfs, nByte, zBufOut);\n}\nSQLITE_PRIVATE int sqlite3OsSleep(sqlite3_vfs *pVfs, int nMicro){\n  return pVfs->xSleep(pVfs, nMicro);\n}\nSQLITE_PRIVATE int sqlite3OsCurrentTimeInt64(sqlite3_vfs *pVfs, sqlite3_int64 *pTimeOut){\n  int rc;\n  /* IMPLEMENTATION-OF: R-49045-42493 SQLite will use the xCurrentTimeInt64()\n  ** method to get the current date and time if that method is available\n  ** (if iVersion is 2 or greater and the function pointer is not NULL) and\n  ** will fall back to xCurrentTime() if xCurrentTimeInt64() is\n  ** unavailable.\n  */\n  if( pVfs->iVersion>=2 && pVfs->xCurrentTimeInt64 ){\n    rc = pVfs->xCurrentTimeInt64(pVfs, pTimeOut);\n  }else{\n    double r;\n    rc = pVfs->xCurrentTime(pVfs, &r);\n    *pTimeOut = (sqlite3_int64)(r*86400000.0);\n  }\n  return rc;\n}\n\nSQLITE_PRIVATE int sqlite3OsOpenMalloc(\n  sqlite3_vfs *pVfs, \n  const char *zFile, \n  sqlite3_file **ppFile, \n  int flags,\n  int *pOutFlags\n){\n  int rc = SQLITE_NOMEM;\n  sqlite3_file *pFile;\n  pFile = (sqlite3_file *)sqlite3Malloc(pVfs->szOsFile);\n  if( pFile ){\n    rc = sqlite3OsOpen(pVfs, zFile, pFile, flags, pOutFlags);\n    if( rc!=SQLITE_OK ){\n      sqlite3_free(pFile);\n    }else{\n      *ppFile = pFile;\n    }\n  }\n  return rc;\n}\nSQLITE_PRIVATE int sqlite3OsCloseFree(sqlite3_file *pFile){\n  int rc = SQLITE_OK;\n  assert( pFile );\n  rc = sqlite3OsClose(pFile);\n  sqlite3_free(pFile);\n  return rc;\n}\n\n/*\n** This function is a wrapper around the OS specific implementation of\n** sqlite3_os_init(). The purpose of the wrapper is to provide the\n** ability to simulate a malloc failure, so that the handling of an\n** error in sqlite3_os_init() by the upper layers can be tested.\n*/\nSQLITE_PRIVATE int sqlite3OsInit(void){\n  void *p = sqlite3_malloc(10);\n  if( p==0 ) return SQLITE_NOMEM;\n  sqlite3_free(p);\n  return sqlite3_os_init();\n}\n\n/*\n** The list of all registered VFS implementations.\n*/\nstatic sqlite3_vfs * SQLITE_WSD vfsList = 0;\n#define vfsList GLOBAL(sqlite3_vfs *, vfsList)\n\n/*\n** Locate a VFS by name.  If no name is given, simply return the\n** first VFS on the list.\n*/\nSQLITE_API sqlite3_vfs *sqlite3_vfs_find(const char *zVfs){\n  sqlite3_vfs *pVfs = 0;\n#if SQLITE_THREADSAFE\n  sqlite3_mutex *mutex;\n#endif\n#ifndef SQLITE_OMIT_AUTOINIT\n  int rc = sqlite3_initialize();\n  if( rc ) return 0;\n#endif\n#if SQLITE_THREADSAFE\n  mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER);\n#endif\n  sqlite3_mutex_enter(mutex);\n  for(pVfs = vfsList; pVfs; pVfs=pVfs->pNext){\n    if( zVfs==0 ) break;\n    if( strcmp(zVfs, pVfs->zName)==0 ) break;\n  }\n  sqlite3_mutex_leave(mutex);\n  return pVfs;\n}\n\n/*\n** Unlink a VFS from the linked list\n*/\nstatic void vfsUnlink(sqlite3_vfs *pVfs){\n  assert( sqlite3_mutex_held(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER)) );\n  if( pVfs==0 ){\n    /* No-op */\n  }else if( vfsList==pVfs ){\n    vfsList = pVfs->pNext;\n  }else if( vfsList ){\n    sqlite3_vfs *p = vfsList;\n    while( p->pNext && p->pNext!=pVfs ){\n      p = p->pNext;\n    }\n    if( p->pNext==pVfs ){\n      p->pNext = pVfs->pNext;\n    }\n  }\n}\n\n/*\n** Register a VFS with the system.  It is harmless to register the same\n** VFS multiple times.  The new VFS becomes the default if makeDflt is\n** true.\n*/\nSQLITE_API int sqlite3_vfs_register(sqlite3_vfs *pVfs, int makeDflt){\n  sqlite3_mutex *mutex = 0;\n#ifndef SQLITE_OMIT_AUTOINIT\n  int rc = sqlite3_initialize();\n  if( rc ) return rc;\n#endif\n  mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER);\n  sqlite3_mutex_enter(mutex);\n  vfsUnlink(pVfs);\n  if( makeDflt || vfsList==0 ){\n    pVfs->pNext = vfsList;\n    vfsList = pVfs;\n  }else{\n    pVfs->pNext = vfsList->pNext;\n    vfsList->pNext = pVfs;\n  }\n  assert(vfsList);\n  sqlite3_mutex_leave(mutex);\n  return SQLITE_OK;\n}\n\n/*\n** Unregister a VFS so that it is no longer accessible.\n*/\nSQLITE_API int sqlite3_vfs_unregister(sqlite3_vfs *pVfs){\n#if SQLITE_THREADSAFE\n  sqlite3_mutex *mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER);\n#endif\n  sqlite3_mutex_enter(mutex);\n  vfsUnlink(pVfs);\n  sqlite3_mutex_leave(mutex);\n  return SQLITE_OK;\n}\n\n/************** End of os.c **************************************************/\n/************** Begin file fault.c *******************************************/\n/*\n** 2008 Jan 22\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n**\n** This file contains code to support the concept of \"benign\" \n** malloc failures (when the xMalloc() or xRealloc() method of the\n** sqlite3_mem_methods structure fails to allocate a block of memory\n** and returns 0). \n**\n** Most malloc failures are non-benign. After they occur, SQLite\n** abandons the current operation and returns an error code (usually\n** SQLITE_NOMEM) to the user. However, sometimes a fault is not necessarily\n** fatal. For example, if a malloc fails while resizing a hash table, this \n** is completely recoverable simply by not carrying out the resize. The \n** hash table will continue to function normally.  So a malloc failure \n** during a hash table resize is a benign fault.\n*/\n\n\n#ifndef SQLITE_OMIT_BUILTIN_TEST\n\n/*\n** Global variables.\n*/\ntypedef struct BenignMallocHooks BenignMallocHooks;\nstatic SQLITE_WSD struct BenignMallocHooks {\n  void (*xBenignBegin)(void);\n  void (*xBenignEnd)(void);\n} sqlite3Hooks = { 0, 0 };\n\n/* The \"wsdHooks\" macro will resolve to the appropriate BenignMallocHooks\n** structure.  If writable static data is unsupported on the target,\n** we have to locate the state vector at run-time.  In the more common\n** case where writable static data is supported, wsdHooks can refer directly\n** to the \"sqlite3Hooks\" state vector declared above.\n*/\n#ifdef SQLITE_OMIT_WSD\n# define wsdHooksInit \\\n  BenignMallocHooks *x = &GLOBAL(BenignMallocHooks,sqlite3Hooks)\n# define wsdHooks x[0]\n#else\n# define wsdHooksInit\n# define wsdHooks sqlite3Hooks\n#endif\n\n\n/*\n** Register hooks to call when sqlite3BeginBenignMalloc() and\n** sqlite3EndBenignMalloc() are called, respectively.\n*/\nSQLITE_PRIVATE void sqlite3BenignMallocHooks(\n  void (*xBenignBegin)(void),\n  void (*xBenignEnd)(void)\n){\n  wsdHooksInit;\n  wsdHooks.xBenignBegin = xBenignBegin;\n  wsdHooks.xBenignEnd = xBenignEnd;\n}\n\n/*\n** This (sqlite3EndBenignMalloc()) is called by SQLite code to indicate that\n** subsequent malloc failures are benign. A call to sqlite3EndBenignMalloc()\n** indicates that subsequent malloc failures are non-benign.\n*/\nSQLITE_PRIVATE void sqlite3BeginBenignMalloc(void){\n  wsdHooksInit;\n  if( wsdHooks.xBenignBegin ){\n    wsdHooks.xBenignBegin();\n  }\n}\nSQLITE_PRIVATE void sqlite3EndBenignMalloc(void){\n  wsdHooksInit;\n  if( wsdHooks.xBenignEnd ){\n    wsdHooks.xBenignEnd();\n  }\n}\n\n#endif   /* #ifndef SQLITE_OMIT_BUILTIN_TEST */\n\n/************** End of fault.c ***********************************************/\n/************** Begin file mem0.c ********************************************/\n/*\n** 2008 October 28\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n**\n** This file contains a no-op memory allocation drivers for use when\n** SQLITE_ZERO_MALLOC is defined.  The allocation drivers implemented\n** here always fail.  SQLite will not operate with these drivers.  These\n** are merely placeholders.  Real drivers must be substituted using\n** sqlite3_config() before SQLite will operate.\n*/\n\n/*\n** This version of the memory allocator is the default.  It is\n** used when no other memory allocator is specified using compile-time\n** macros.\n*/\n#ifdef SQLITE_ZERO_MALLOC\n\n/*\n** No-op versions of all memory allocation routines\n*/\nstatic void *sqlite3MemMalloc(int nByte){ return 0; }\nstatic void sqlite3MemFree(void *pPrior){ return; }\nstatic void *sqlite3MemRealloc(void *pPrior, int nByte){ return 0; }\nstatic int sqlite3MemSize(void *pPrior){ return 0; }\nstatic int sqlite3MemRoundup(int n){ return n; }\nstatic int sqlite3MemInit(void *NotUsed){ return SQLITE_OK; }\nstatic void sqlite3MemShutdown(void *NotUsed){ return; }\n\n/*\n** This routine is the only routine in this file with external linkage.\n**\n** Populate the low-level memory allocation function pointers in\n** sqlite3GlobalConfig.m with pointers to the routines in this file.\n*/\nSQLITE_PRIVATE void sqlite3MemSetDefault(void){\n  static const sqlite3_mem_methods defaultMethods = {\n     sqlite3MemMalloc,\n     sqlite3MemFree,\n     sqlite3MemRealloc,\n     sqlite3MemSize,\n     sqlite3MemRoundup,\n     sqlite3MemInit,\n     sqlite3MemShutdown,\n     0\n  };\n  sqlite3_config(SQLITE_CONFIG_MALLOC, &defaultMethods);\n}\n\n#endif /* SQLITE_ZERO_MALLOC */\n\n/************** End of mem0.c ************************************************/\n/************** Begin file mem1.c ********************************************/\n/*\n** 2007 August 14\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n**\n** This file contains low-level memory allocation drivers for when\n** SQLite will use the standard C-library malloc/realloc/free interface\n** to obtain the memory it needs.\n**\n** This file contains implementations of the low-level memory allocation\n** routines specified in the sqlite3_mem_methods object.\n*/\n\n/*\n** This version of the memory allocator is the default.  It is\n** used when no other memory allocator is specified using compile-time\n** macros.\n*/\n#ifdef SQLITE_SYSTEM_MALLOC\n\n/*\n** Like malloc(), but remember the size of the allocation\n** so that we can find it later using sqlite3MemSize().\n**\n** For this low-level routine, we are guaranteed that nByte>0 because\n** cases of nByte<=0 will be intercepted and dealt with by higher level\n** routines.\n*/\nstatic void *sqlite3MemMalloc(int nByte){\n  sqlite3_int64 *p;\n  assert( nByte>0 );\n  nByte = ROUND8(nByte);\n  p = malloc( nByte+8 );\n  if( p ){\n    p[0] = nByte;\n    p++;\n  }else{\n    testcase( sqlite3GlobalConfig.xLog!=0 );\n    sqlite3_log(SQLITE_NOMEM, \"failed to allocate %u bytes of memory\", nByte);\n  }\n  return (void *)p;\n}\n\n/*\n** Like free() but works for allocations obtained from sqlite3MemMalloc()\n** or sqlite3MemRealloc().\n**\n** For this low-level routine, we already know that pPrior!=0 since\n** cases where pPrior==0 will have been intecepted and dealt with\n** by higher-level routines.\n*/\nstatic void sqlite3MemFree(void *pPrior){\n  sqlite3_int64 *p = (sqlite3_int64*)pPrior;\n  assert( pPrior!=0 );\n  p--;\n  free(p);\n}\n\n/*\n** Report the allocated size of a prior return from xMalloc()\n** or xRealloc().\n*/\nstatic int sqlite3MemSize(void *pPrior){\n  sqlite3_int64 *p;\n  if( pPrior==0 ) return 0;\n  p = (sqlite3_int64*)pPrior;\n  p--;\n  return (int)p[0];\n}\n\n/*\n** Like realloc().  Resize an allocation previously obtained from\n** sqlite3MemMalloc().\n**\n** For this low-level interface, we know that pPrior!=0.  Cases where\n** pPrior==0 while have been intercepted by higher-level routine and\n** redirected to xMalloc.  Similarly, we know that nByte>0 becauses\n** cases where nByte<=0 will have been intercepted by higher-level\n** routines and redirected to xFree.\n*/\nstatic void *sqlite3MemRealloc(void *pPrior, int nByte){\n  sqlite3_int64 *p = (sqlite3_int64*)pPrior;\n  assert( pPrior!=0 && nByte>0 );\n  assert( nByte==ROUND8(nByte) ); /* EV: R-46199-30249 */\n  p--;\n  p = realloc(p, nByte+8 );\n  if( p ){\n    p[0] = nByte;\n    p++;\n  }else{\n    testcase( sqlite3GlobalConfig.xLog!=0 );\n    sqlite3_log(SQLITE_NOMEM,\n      \"failed memory resize %u to %u bytes\",\n      sqlite3MemSize(pPrior), nByte);\n  }\n  return (void*)p;\n}\n\n/*\n** Round up a request size to the next valid allocation size.\n*/\nstatic int sqlite3MemRoundup(int n){\n  return ROUND8(n);\n}\n\n/*\n** Initialize this module.\n*/\nstatic int sqlite3MemInit(void *NotUsed){\n  UNUSED_PARAMETER(NotUsed);\n  return SQLITE_OK;\n}\n\n/*\n** Deinitialize this module.\n*/\nstatic void sqlite3MemShutdown(void *NotUsed){\n  UNUSED_PARAMETER(NotUsed);\n  return;\n}\n\n/*\n** This routine is the only routine in this file with external linkage.\n**\n** Populate the low-level memory allocation function pointers in\n** sqlite3GlobalConfig.m with pointers to the routines in this file.\n*/\nSQLITE_PRIVATE void sqlite3MemSetDefault(void){\n  static const sqlite3_mem_methods defaultMethods = {\n     sqlite3MemMalloc,\n     sqlite3MemFree,\n     sqlite3MemRealloc,\n     sqlite3MemSize,\n     sqlite3MemRoundup,\n     sqlite3MemInit,\n     sqlite3MemShutdown,\n     0\n  };\n  sqlite3_config(SQLITE_CONFIG_MALLOC, &defaultMethods);\n}\n\n#endif /* SQLITE_SYSTEM_MALLOC */\n\n/************** End of mem1.c ************************************************/\n/************** Begin file mem2.c ********************************************/\n/*\n** 2007 August 15\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n**\n** This file contains low-level memory allocation drivers for when\n** SQLite will use the standard C-library malloc/realloc/free interface\n** to obtain the memory it needs while adding lots of additional debugging\n** information to each allocation in order to help detect and fix memory\n** leaks and memory usage errors.\n**\n** This file contains implementations of the low-level memory allocation\n** routines specified in the sqlite3_mem_methods object.\n*/\n\n/*\n** This version of the memory allocator is used only if the\n** SQLITE_MEMDEBUG macro is defined\n*/\n#ifdef SQLITE_MEMDEBUG\n\n/*\n** The backtrace functionality is only available with GLIBC\n*/\n#ifdef __GLIBC__\n  extern int backtrace(void**,int);\n  extern void backtrace_symbols_fd(void*const*,int,int);\n#else\n# define backtrace(A,B) 1\n# define backtrace_symbols_fd(A,B,C)\n#endif\n\n/*\n** Each memory allocation looks like this:\n**\n**  ------------------------------------------------------------------------\n**  | Title |  backtrace pointers |  MemBlockHdr |  allocation |  EndGuard |\n**  ------------------------------------------------------------------------\n**\n** The application code sees only a pointer to the allocation.  We have\n** to back up from the allocation pointer to find the MemBlockHdr.  The\n** MemBlockHdr tells us the size of the allocation and the number of\n** backtrace pointers.  There is also a guard word at the end of the\n** MemBlockHdr.\n*/\nstruct MemBlockHdr {\n  i64 iSize;                          /* Size of this allocation */\n  struct MemBlockHdr *pNext, *pPrev;  /* Linked list of all unfreed memory */\n  char nBacktrace;                    /* Number of backtraces on this alloc */\n  char nBacktraceSlots;               /* Available backtrace slots */\n  u8 nTitle;                          /* Bytes of title; includes '\\0' */\n  u8 eType;                           /* Allocation type code */\n  int iForeGuard;                     /* Guard word for sanity */\n};\n\n/*\n** Guard words\n*/\n#define FOREGUARD 0x80F5E153\n#define REARGUARD 0xE4676B53\n\n/*\n** Number of malloc size increments to track.\n*/\n#define NCSIZE  1000\n\n/*\n** All of the static variables used by this module are collected\n** into a single structure named \"mem\".  This is to keep the\n** static variables organized and to reduce namespace pollution\n** when this module is combined with other in the amalgamation.\n*/\nstatic struct {\n  \n  /*\n  ** Mutex to control access to the memory allocation subsystem.\n  */\n  sqlite3_mutex *mutex;\n\n  /*\n  ** Head and tail of a linked list of all outstanding allocations\n  */\n  struct MemBlockHdr *pFirst;\n  struct MemBlockHdr *pLast;\n  \n  /*\n  ** The number of levels of backtrace to save in new allocations.\n  */\n  int nBacktrace;\n  void (*xBacktrace)(int, int, void **);\n\n  /*\n  ** Title text to insert in front of each block\n  */\n  int nTitle;        /* Bytes of zTitle to save.  Includes '\\0' and padding */\n  char zTitle[100];  /* The title text */\n\n  /* \n  ** sqlite3MallocDisallow() increments the following counter.\n  ** sqlite3MallocAllow() decrements it.\n  */\n  int disallow; /* Do not allow memory allocation */\n\n  /*\n  ** Gather statistics on the sizes of memory allocations.\n  ** nAlloc[i] is the number of allocation attempts of i*8\n  ** bytes.  i==NCSIZE is the number of allocation attempts for\n  ** sizes more than NCSIZE*8 bytes.\n  */\n  int nAlloc[NCSIZE];      /* Total number of allocations */\n  int nCurrent[NCSIZE];    /* Current number of allocations */\n  int mxCurrent[NCSIZE];   /* Highwater mark for nCurrent */\n\n} mem;\n\n\n/*\n** Adjust memory usage statistics\n*/\nstatic void adjustStats(int iSize, int increment){\n  int i = ROUND8(iSize)/8;\n  if( i>NCSIZE-1 ){\n    i = NCSIZE - 1;\n  }\n  if( increment>0 ){\n    mem.nAlloc[i]++;\n    mem.nCurrent[i]++;\n    if( mem.nCurrent[i]>mem.mxCurrent[i] ){\n      mem.mxCurrent[i] = mem.nCurrent[i];\n    }\n  }else{\n    mem.nCurrent[i]--;\n    assert( mem.nCurrent[i]>=0 );\n  }\n}\n\n/*\n** Given an allocation, find the MemBlockHdr for that allocation.\n**\n** This routine checks the guards at either end of the allocation and\n** if they are incorrect it asserts.\n*/\nstatic struct MemBlockHdr *sqlite3MemsysGetHeader(void *pAllocation){\n  struct MemBlockHdr *p;\n  int *pInt;\n  u8 *pU8;\n  int nReserve;\n\n  p = (struct MemBlockHdr*)pAllocation;\n  p--;\n  assert( p->iForeGuard==(int)FOREGUARD );\n  nReserve = ROUND8(p->iSize);\n  pInt = (int*)pAllocation;\n  pU8 = (u8*)pAllocation;\n  assert( pInt[nReserve/sizeof(int)]==(int)REARGUARD );\n  /* This checks any of the \"extra\" bytes allocated due\n  ** to rounding up to an 8 byte boundary to ensure \n  ** they haven't been overwritten.\n  */\n  while( nReserve-- > p->iSize ) assert( pU8[nReserve]==0x65 );\n  return p;\n}\n\n/*\n** Return the number of bytes currently allocated at address p.\n*/\nstatic int sqlite3MemSize(void *p){\n  struct MemBlockHdr *pHdr;\n  if( !p ){\n    return 0;\n  }\n  pHdr = sqlite3MemsysGetHeader(p);\n  return pHdr->iSize;\n}\n\n/*\n** Initialize the memory allocation subsystem.\n*/\nstatic int sqlite3MemInit(void *NotUsed){\n  UNUSED_PARAMETER(NotUsed);\n  assert( (sizeof(struct MemBlockHdr)&7) == 0 );\n  if( !sqlite3GlobalConfig.bMemstat ){\n    /* If memory status is enabled, then the malloc.c wrapper will already\n    ** hold the STATIC_MEM mutex when the routines here are invoked. */\n    mem.mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MEM);\n  }\n  return SQLITE_OK;\n}\n\n/*\n** Deinitialize the memory allocation subsystem.\n*/\nstatic void sqlite3MemShutdown(void *NotUsed){\n  UNUSED_PARAMETER(NotUsed);\n  mem.mutex = 0;\n}\n\n/*\n** Round up a request size to the next valid allocation size.\n*/\nstatic int sqlite3MemRoundup(int n){\n  return ROUND8(n);\n}\n\n/*\n** Fill a buffer with pseudo-random bytes.  This is used to preset\n** the content of a new memory allocation to unpredictable values and\n** to clear the content of a freed allocation to unpredictable values.\n*/\nstatic void randomFill(char *pBuf, int nByte){\n  unsigned int x, y, r;\n  x = SQLITE_PTR_TO_INT(pBuf);\n  y = nByte | 1;\n  while( nByte >= 4 ){\n    x = (x>>1) ^ (-(x&1) & 0xd0000001);\n    y = y*1103515245 + 12345;\n    r = x ^ y;\n    *(int*)pBuf = r;\n    pBuf += 4;\n    nByte -= 4;\n  }\n  while( nByte-- > 0 ){\n    x = (x>>1) ^ (-(x&1) & 0xd0000001);\n    y = y*1103515245 + 12345;\n    r = x ^ y;\n    *(pBuf++) = r & 0xff;\n  }\n}\n\n/*\n** Allocate nByte bytes of memory.\n*/\nstatic void *sqlite3MemMalloc(int nByte){\n  struct MemBlockHdr *pHdr;\n  void **pBt;\n  char *z;\n  int *pInt;\n  void *p = 0;\n  int totalSize;\n  int nReserve;\n  sqlite3_mutex_enter(mem.mutex);\n  assert( mem.disallow==0 );\n  nReserve = ROUND8(nByte);\n  totalSize = nReserve + sizeof(*pHdr) + sizeof(int) +\n               mem.nBacktrace*sizeof(void*) + mem.nTitle;\n  p = malloc(totalSize);\n  if( p ){\n    z = p;\n    pBt = (void**)&z[mem.nTitle];\n    pHdr = (struct MemBlockHdr*)&pBt[mem.nBacktrace];\n    pHdr->pNext = 0;\n    pHdr->pPrev = mem.pLast;\n    if( mem.pLast ){\n      mem.pLast->pNext = pHdr;\n    }else{\n      mem.pFirst = pHdr;\n    }\n    mem.pLast = pHdr;\n    pHdr->iForeGuard = FOREGUARD;\n    pHdr->eType = MEMTYPE_HEAP;\n    pHdr->nBacktraceSlots = mem.nBacktrace;\n    pHdr->nTitle = mem.nTitle;\n    if( mem.nBacktrace ){\n      void *aAddr[40];\n      pHdr->nBacktrace = backtrace(aAddr, mem.nBacktrace+1)-1;\n      memcpy(pBt, &aAddr[1], pHdr->nBacktrace*sizeof(void*));\n      assert(pBt[0]);\n      if( mem.xBacktrace ){\n        mem.xBacktrace(nByte, pHdr->nBacktrace-1, &aAddr[1]);\n      }\n    }else{\n      pHdr->nBacktrace = 0;\n    }\n    if( mem.nTitle ){\n      memcpy(z, mem.zTitle, mem.nTitle);\n    }\n    pHdr->iSize = nByte;\n    adjustStats(nByte, +1);\n    pInt = (int*)&pHdr[1];\n    pInt[nReserve/sizeof(int)] = REARGUARD;\n    randomFill((char*)pInt, nByte);\n    memset(((char*)pInt)+nByte, 0x65, nReserve-nByte);\n    p = (void*)pInt;\n  }\n  sqlite3_mutex_leave(mem.mutex);\n  return p; \n}\n\n/*\n** Free memory.\n*/\nstatic void sqlite3MemFree(void *pPrior){\n  struct MemBlockHdr *pHdr;\n  void **pBt;\n  char *z;\n  assert( sqlite3GlobalConfig.bMemstat || sqlite3GlobalConfig.bCoreMutex==0 \n       || mem.mutex!=0 );\n  pHdr = sqlite3MemsysGetHeader(pPrior);\n  pBt = (void**)pHdr;\n  pBt -= pHdr->nBacktraceSlots;\n  sqlite3_mutex_enter(mem.mutex);\n  if( pHdr->pPrev ){\n    assert( pHdr->pPrev->pNext==pHdr );\n    pHdr->pPrev->pNext = pHdr->pNext;\n  }else{\n    assert( mem.pFirst==pHdr );\n    mem.pFirst = pHdr->pNext;\n  }\n  if( pHdr->pNext ){\n    assert( pHdr->pNext->pPrev==pHdr );\n    pHdr->pNext->pPrev = pHdr->pPrev;\n  }else{\n    assert( mem.pLast==pHdr );\n    mem.pLast = pHdr->pPrev;\n  }\n  z = (char*)pBt;\n  z -= pHdr->nTitle;\n  adjustStats(pHdr->iSize, -1);\n  randomFill(z, sizeof(void*)*pHdr->nBacktraceSlots + sizeof(*pHdr) +\n                pHdr->iSize + sizeof(int) + pHdr->nTitle);\n  free(z);\n  sqlite3_mutex_leave(mem.mutex);  \n}\n\n/*\n** Change the size of an existing memory allocation.\n**\n** For this debugging implementation, we *always* make a copy of the\n** allocation into a new place in memory.  In this way, if the \n** higher level code is using pointer to the old allocation, it is \n** much more likely to break and we are much more liking to find\n** the error.\n*/\nstatic void *sqlite3MemRealloc(void *pPrior, int nByte){\n  struct MemBlockHdr *pOldHdr;\n  void *pNew;\n  assert( mem.disallow==0 );\n  assert( (nByte & 7)==0 );     /* EV: R-46199-30249 */\n  pOldHdr = sqlite3MemsysGetHeader(pPrior);\n  pNew = sqlite3MemMalloc(nByte);\n  if( pNew ){\n    memcpy(pNew, pPrior, nByte<pOldHdr->iSize ? nByte : pOldHdr->iSize);\n    if( nByte>pOldHdr->iSize ){\n      randomFill(&((char*)pNew)[pOldHdr->iSize], nByte - pOldHdr->iSize);\n    }\n    sqlite3MemFree(pPrior);\n  }\n  return pNew;\n}\n\n/*\n** Populate the low-level memory allocation function pointers in\n** sqlite3GlobalConfig.m with pointers to the routines in this file.\n*/\nSQLITE_PRIVATE void sqlite3MemSetDefault(void){\n  static const sqlite3_mem_methods defaultMethods = {\n     sqlite3MemMalloc,\n     sqlite3MemFree,\n     sqlite3MemRealloc,\n     sqlite3MemSize,\n     sqlite3MemRoundup,\n     sqlite3MemInit,\n     sqlite3MemShutdown,\n     0\n  };\n  sqlite3_config(SQLITE_CONFIG_MALLOC, &defaultMethods);\n}\n\n/*\n** Set the \"type\" of an allocation.\n*/\nSQLITE_PRIVATE void sqlite3MemdebugSetType(void *p, u8 eType){\n  if( p && sqlite3GlobalConfig.m.xMalloc==sqlite3MemMalloc ){\n    struct MemBlockHdr *pHdr;\n    pHdr = sqlite3MemsysGetHeader(p);\n    assert( pHdr->iForeGuard==FOREGUARD );\n    pHdr->eType = eType;\n  }\n}\n\n/*\n** Return TRUE if the mask of type in eType matches the type of the\n** allocation p.  Also return true if p==NULL.\n**\n** This routine is designed for use within an assert() statement, to\n** verify the type of an allocation.  For example:\n**\n**     assert( sqlite3MemdebugHasType(p, MEMTYPE_DB) );\n*/\nSQLITE_PRIVATE int sqlite3MemdebugHasType(void *p, u8 eType){\n  int rc = 1;\n  if( p && sqlite3GlobalConfig.m.xMalloc==sqlite3MemMalloc ){\n    struct MemBlockHdr *pHdr;\n    pHdr = sqlite3MemsysGetHeader(p);\n    assert( pHdr->iForeGuard==FOREGUARD );         /* Allocation is valid */\n    if( (pHdr->eType&eType)==0 ){\n      rc = 0;\n    }\n  }\n  return rc;\n}\n\n/*\n** Return TRUE if the mask of type in eType matches no bits of the type of the\n** allocation p.  Also return true if p==NULL.\n**\n** This routine is designed for use within an assert() statement, to\n** verify the type of an allocation.  For example:\n**\n**     assert( sqlite3MemdebugNoType(p, MEMTYPE_DB) );\n*/\nSQLITE_PRIVATE int sqlite3MemdebugNoType(void *p, u8 eType){\n  int rc = 1;\n  if( p && sqlite3GlobalConfig.m.xMalloc==sqlite3MemMalloc ){\n    struct MemBlockHdr *pHdr;\n    pHdr = sqlite3MemsysGetHeader(p);\n    assert( pHdr->iForeGuard==FOREGUARD );         /* Allocation is valid */\n    if( (pHdr->eType&eType)!=0 ){\n      rc = 0;\n    }\n  }\n  return rc;\n}\n\n/*\n** Set the number of backtrace levels kept for each allocation.\n** A value of zero turns off backtracing.  The number is always rounded\n** up to a multiple of 2.\n*/\nSQLITE_PRIVATE void sqlite3MemdebugBacktrace(int depth){\n  if( depth<0 ){ depth = 0; }\n  if( depth>20 ){ depth = 20; }\n  depth = (depth+1)&0xfe;\n  mem.nBacktrace = depth;\n}\n\nSQLITE_PRIVATE void sqlite3MemdebugBacktraceCallback(void (*xBacktrace)(int, int, void **)){\n  mem.xBacktrace = xBacktrace;\n}\n\n/*\n** Set the title string for subsequent allocations.\n*/\nSQLITE_PRIVATE void sqlite3MemdebugSettitle(const char *zTitle){\n  unsigned int n = sqlite3Strlen30(zTitle) + 1;\n  sqlite3_mutex_enter(mem.mutex);\n  if( n>=sizeof(mem.zTitle) ) n = sizeof(mem.zTitle)-1;\n  memcpy(mem.zTitle, zTitle, n);\n  mem.zTitle[n] = 0;\n  mem.nTitle = ROUND8(n);\n  sqlite3_mutex_leave(mem.mutex);\n}\n\nSQLITE_PRIVATE void sqlite3MemdebugSync(){\n  struct MemBlockHdr *pHdr;\n  for(pHdr=mem.pFirst; pHdr; pHdr=pHdr->pNext){\n    void **pBt = (void**)pHdr;\n    pBt -= pHdr->nBacktraceSlots;\n    mem.xBacktrace(pHdr->iSize, pHdr->nBacktrace-1, &pBt[1]);\n  }\n}\n\n/*\n** Open the file indicated and write a log of all unfreed memory \n** allocations into that log.\n*/\nSQLITE_PRIVATE void sqlite3MemdebugDump(const char *zFilename){\n  FILE *out;\n  struct MemBlockHdr *pHdr;\n  void **pBt;\n  int i;\n  out = fopen(zFilename, \"w\");\n  if( out==0 ){\n    fprintf(stderr, \"** Unable to output memory debug output log: %s **\\n\",\n                    zFilename);\n    return;\n  }\n  for(pHdr=mem.pFirst; pHdr; pHdr=pHdr->pNext){\n    char *z = (char*)pHdr;\n    z -= pHdr->nBacktraceSlots*sizeof(void*) + pHdr->nTitle;\n    fprintf(out, \"**** %lld bytes at %p from %s ****\\n\", \n            pHdr->iSize, &pHdr[1], pHdr->nTitle ? z : \"???\");\n    if( pHdr->nBacktrace ){\n      fflush(out);\n      pBt = (void**)pHdr;\n      pBt -= pHdr->nBacktraceSlots;\n      backtrace_symbols_fd(pBt, pHdr->nBacktrace, fileno(out));\n      fprintf(out, \"\\n\");\n    }\n  }\n  fprintf(out, \"COUNTS:\\n\");\n  for(i=0; i<NCSIZE-1; i++){\n    if( mem.nAlloc[i] ){\n      fprintf(out, \"   %5d: %10d %10d %10d\\n\", \n            i*8, mem.nAlloc[i], mem.nCurrent[i], mem.mxCurrent[i]);\n    }\n  }\n  if( mem.nAlloc[NCSIZE-1] ){\n    fprintf(out, \"   %5d: %10d %10d %10d\\n\",\n             NCSIZE*8-8, mem.nAlloc[NCSIZE-1],\n             mem.nCurrent[NCSIZE-1], mem.mxCurrent[NCSIZE-1]);\n  }\n  fclose(out);\n}\n\n/*\n** Return the number of times sqlite3MemMalloc() has been called.\n*/\nSQLITE_PRIVATE int sqlite3MemdebugMallocCount(){\n  int i;\n  int nTotal = 0;\n  for(i=0; i<NCSIZE; i++){\n    nTotal += mem.nAlloc[i];\n  }\n  return nTotal;\n}\n\n\n#endif /* SQLITE_MEMDEBUG */\n\n/************** End of mem2.c ************************************************/\n/************** Begin file mem3.c ********************************************/\n/*\n** 2007 October 14\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains the C functions that implement a memory\n** allocation subsystem for use by SQLite. \n**\n** This version of the memory allocation subsystem omits all\n** use of malloc(). The SQLite user supplies a block of memory\n** before calling sqlite3_initialize() from which allocations\n** are made and returned by the xMalloc() and xRealloc() \n** implementations. Once sqlite3_initialize() has been called,\n** the amount of memory available to SQLite is fixed and cannot\n** be changed.\n**\n** This version of the memory allocation subsystem is included\n** in the build only if SQLITE_ENABLE_MEMSYS3 is defined.\n*/\n\n/*\n** This version of the memory allocator is only built into the library\n** SQLITE_ENABLE_MEMSYS3 is defined. Defining this symbol does not\n** mean that the library will use a memory-pool by default, just that\n** it is available. The mempool allocator is activated by calling\n** sqlite3_config().\n*/\n#ifdef SQLITE_ENABLE_MEMSYS3\n\n/*\n** Maximum size (in Mem3Blocks) of a \"small\" chunk.\n*/\n#define MX_SMALL 10\n\n\n/*\n** Number of freelist hash slots\n*/\n#define N_HASH  61\n\n/*\n** A memory allocation (also called a \"chunk\") consists of two or \n** more blocks where each block is 8 bytes.  The first 8 bytes are \n** a header that is not returned to the user.\n**\n** A chunk is two or more blocks that is either checked out or\n** free.  The first block has format u.hdr.  u.hdr.size4x is 4 times the\n** size of the allocation in blocks if the allocation is free.\n** The u.hdr.size4x&1 bit is true if the chunk is checked out and\n** false if the chunk is on the freelist.  The u.hdr.size4x&2 bit\n** is true if the previous chunk is checked out and false if the\n** previous chunk is free.  The u.hdr.prevSize field is the size of\n** the previous chunk in blocks if the previous chunk is on the\n** freelist. If the previous chunk is checked out, then\n** u.hdr.prevSize can be part of the data for that chunk and should\n** not be read or written.\n**\n** We often identify a chunk by its index in mem3.aPool[].  When\n** this is done, the chunk index refers to the second block of\n** the chunk.  In this way, the first chunk has an index of 1.\n** A chunk index of 0 means \"no such chunk\" and is the equivalent\n** of a NULL pointer.\n**\n** The second block of free chunks is of the form u.list.  The\n** two fields form a double-linked list of chunks of related sizes.\n** Pointers to the head of the list are stored in mem3.aiSmall[] \n** for smaller chunks and mem3.aiHash[] for larger chunks.\n**\n** The second block of a chunk is user data if the chunk is checked \n** out.  If a chunk is checked out, the user data may extend into\n** the u.hdr.prevSize value of the following chunk.\n*/\ntypedef struct Mem3Block Mem3Block;\nstruct Mem3Block {\n  union {\n    struct {\n      u32 prevSize;   /* Size of previous chunk in Mem3Block elements */\n      u32 size4x;     /* 4x the size of current chunk in Mem3Block elements */\n    } hdr;\n    struct {\n      u32 next;       /* Index in mem3.aPool[] of next free chunk */\n      u32 prev;       /* Index in mem3.aPool[] of previous free chunk */\n    } list;\n  } u;\n};\n\n/*\n** All of the static variables used by this module are collected\n** into a single structure named \"mem3\".  This is to keep the\n** static variables organized and to reduce namespace pollution\n** when this module is combined with other in the amalgamation.\n*/\nstatic SQLITE_WSD struct Mem3Global {\n  /*\n  ** Memory available for allocation. nPool is the size of the array\n  ** (in Mem3Blocks) pointed to by aPool less 2.\n  */\n  u32 nPool;\n  Mem3Block *aPool;\n\n  /*\n  ** True if we are evaluating an out-of-memory callback.\n  */\n  int alarmBusy;\n  \n  /*\n  ** Mutex to control access to the memory allocation subsystem.\n  */\n  sqlite3_mutex *mutex;\n  \n  /*\n  ** The minimum amount of free space that we have seen.\n  */\n  u32 mnMaster;\n\n  /*\n  ** iMaster is the index of the master chunk.  Most new allocations\n  ** occur off of this chunk.  szMaster is the size (in Mem3Blocks)\n  ** of the current master.  iMaster is 0 if there is not master chunk.\n  ** The master chunk is not in either the aiHash[] or aiSmall[].\n  */\n  u32 iMaster;\n  u32 szMaster;\n\n  /*\n  ** Array of lists of free blocks according to the block size \n  ** for smaller chunks, or a hash on the block size for larger\n  ** chunks.\n  */\n  u32 aiSmall[MX_SMALL-1];   /* For sizes 2 through MX_SMALL, inclusive */\n  u32 aiHash[N_HASH];        /* For sizes MX_SMALL+1 and larger */\n} mem3 = { 97535575 };\n\n#define mem3 GLOBAL(struct Mem3Global, mem3)\n\n/*\n** Unlink the chunk at mem3.aPool[i] from list it is currently\n** on.  *pRoot is the list that i is a member of.\n*/\nstatic void memsys3UnlinkFromList(u32 i, u32 *pRoot){\n  u32 next = mem3.aPool[i].u.list.next;\n  u32 prev = mem3.aPool[i].u.list.prev;\n  assert( sqlite3_mutex_held(mem3.mutex) );\n  if( prev==0 ){\n    *pRoot = next;\n  }else{\n    mem3.aPool[prev].u.list.next = next;\n  }\n  if( next ){\n    mem3.aPool[next].u.list.prev = prev;\n  }\n  mem3.aPool[i].u.list.next = 0;\n  mem3.aPool[i].u.list.prev = 0;\n}\n\n/*\n** Unlink the chunk at index i from \n** whatever list is currently a member of.\n*/\nstatic void memsys3Unlink(u32 i){\n  u32 size, hash;\n  assert( sqlite3_mutex_held(mem3.mutex) );\n  assert( (mem3.aPool[i-1].u.hdr.size4x & 1)==0 );\n  assert( i>=1 );\n  size = mem3.aPool[i-1].u.hdr.size4x/4;\n  assert( size==mem3.aPool[i+size-1].u.hdr.prevSize );\n  assert( size>=2 );\n  if( size <= MX_SMALL ){\n    memsys3UnlinkFromList(i, &mem3.aiSmall[size-2]);\n  }else{\n    hash = size % N_HASH;\n    memsys3UnlinkFromList(i, &mem3.aiHash[hash]);\n  }\n}\n\n/*\n** Link the chunk at mem3.aPool[i] so that is on the list rooted\n** at *pRoot.\n*/\nstatic void memsys3LinkIntoList(u32 i, u32 *pRoot){\n  assert( sqlite3_mutex_held(mem3.mutex) );\n  mem3.aPool[i].u.list.next = *pRoot;\n  mem3.aPool[i].u.list.prev = 0;\n  if( *pRoot ){\n    mem3.aPool[*pRoot].u.list.prev = i;\n  }\n  *pRoot = i;\n}\n\n/*\n** Link the chunk at index i into either the appropriate\n** small chunk list, or into the large chunk hash table.\n*/\nstatic void memsys3Link(u32 i){\n  u32 size, hash;\n  assert( sqlite3_mutex_held(mem3.mutex) );\n  assert( i>=1 );\n  assert( (mem3.aPool[i-1].u.hdr.size4x & 1)==0 );\n  size = mem3.aPool[i-1].u.hdr.size4x/4;\n  assert( size==mem3.aPool[i+size-1].u.hdr.prevSize );\n  assert( size>=2 );\n  if( size <= MX_SMALL ){\n    memsys3LinkIntoList(i, &mem3.aiSmall[size-2]);\n  }else{\n    hash = size % N_HASH;\n    memsys3LinkIntoList(i, &mem3.aiHash[hash]);\n  }\n}\n\n/*\n** If the STATIC_MEM mutex is not already held, obtain it now. The mutex\n** will already be held (obtained by code in malloc.c) if\n** sqlite3GlobalConfig.bMemStat is true.\n*/\nstatic void memsys3Enter(void){\n  if( sqlite3GlobalConfig.bMemstat==0 && mem3.mutex==0 ){\n    mem3.mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MEM);\n  }\n  sqlite3_mutex_enter(mem3.mutex);\n}\nstatic void memsys3Leave(void){\n  sqlite3_mutex_leave(mem3.mutex);\n}\n\n/*\n** Called when we are unable to satisfy an allocation of nBytes.\n*/\nstatic void memsys3OutOfMemory(int nByte){\n  if( !mem3.alarmBusy ){\n    mem3.alarmBusy = 1;\n    assert( sqlite3_mutex_held(mem3.mutex) );\n    sqlite3_mutex_leave(mem3.mutex);\n    sqlite3_release_memory(nByte);\n    sqlite3_mutex_enter(mem3.mutex);\n    mem3.alarmBusy = 0;\n  }\n}\n\n\n/*\n** Chunk i is a free chunk that has been unlinked.  Adjust its \n** size parameters for check-out and return a pointer to the \n** user portion of the chunk.\n*/\nstatic void *memsys3Checkout(u32 i, u32 nBlock){\n  u32 x;\n  assert( sqlite3_mutex_held(mem3.mutex) );\n  assert( i>=1 );\n  assert( mem3.aPool[i-1].u.hdr.size4x/4==nBlock );\n  assert( mem3.aPool[i+nBlock-1].u.hdr.prevSize==nBlock );\n  x = mem3.aPool[i-1].u.hdr.size4x;\n  mem3.aPool[i-1].u.hdr.size4x = nBlock*4 | 1 | (x&2);\n  mem3.aPool[i+nBlock-1].u.hdr.prevSize = nBlock;\n  mem3.aPool[i+nBlock-1].u.hdr.size4x |= 2;\n  return &mem3.aPool[i];\n}\n\n/*\n** Carve a piece off of the end of the mem3.iMaster free chunk.\n** Return a pointer to the new allocation.  Or, if the master chunk\n** is not large enough, return 0.\n*/\nstatic void *memsys3FromMaster(u32 nBlock){\n  assert( sqlite3_mutex_held(mem3.mutex) );\n  assert( mem3.szMaster>=nBlock );\n  if( nBlock>=mem3.szMaster-1 ){\n    /* Use the entire master */\n    void *p = memsys3Checkout(mem3.iMaster, mem3.szMaster);\n    mem3.iMaster = 0;\n    mem3.szMaster = 0;\n    mem3.mnMaster = 0;\n    return p;\n  }else{\n    /* Split the master block.  Return the tail. */\n    u32 newi, x;\n    newi = mem3.iMaster + mem3.szMaster - nBlock;\n    assert( newi > mem3.iMaster+1 );\n    mem3.aPool[mem3.iMaster+mem3.szMaster-1].u.hdr.prevSize = nBlock;\n    mem3.aPool[mem3.iMaster+mem3.szMaster-1].u.hdr.size4x |= 2;\n    mem3.aPool[newi-1].u.hdr.size4x = nBlock*4 + 1;\n    mem3.szMaster -= nBlock;\n    mem3.aPool[newi-1].u.hdr.prevSize = mem3.szMaster;\n    x = mem3.aPool[mem3.iMaster-1].u.hdr.size4x & 2;\n    mem3.aPool[mem3.iMaster-1].u.hdr.size4x = mem3.szMaster*4 | x;\n    if( mem3.szMaster < mem3.mnMaster ){\n      mem3.mnMaster = mem3.szMaster;\n    }\n    return (void*)&mem3.aPool[newi];\n  }\n}\n\n/*\n** *pRoot is the head of a list of free chunks of the same size\n** or same size hash.  In other words, *pRoot is an entry in either\n** mem3.aiSmall[] or mem3.aiHash[].  \n**\n** This routine examines all entries on the given list and tries\n** to coalesce each entries with adjacent free chunks.  \n**\n** If it sees a chunk that is larger than mem3.iMaster, it replaces \n** the current mem3.iMaster with the new larger chunk.  In order for\n** this mem3.iMaster replacement to work, the master chunk must be\n** linked into the hash tables.  That is not the normal state of\n** affairs, of course.  The calling routine must link the master\n** chunk before invoking this routine, then must unlink the (possibly\n** changed) master chunk once this routine has finished.\n*/\nstatic void memsys3Merge(u32 *pRoot){\n  u32 iNext, prev, size, i, x;\n\n  assert( sqlite3_mutex_held(mem3.mutex) );\n  for(i=*pRoot; i>0; i=iNext){\n    iNext = mem3.aPool[i].u.list.next;\n    size = mem3.aPool[i-1].u.hdr.size4x;\n    assert( (size&1)==0 );\n    if( (size&2)==0 ){\n      memsys3UnlinkFromList(i, pRoot);\n      assert( i > mem3.aPool[i-1].u.hdr.prevSize );\n      prev = i - mem3.aPool[i-1].u.hdr.prevSize;\n      if( prev==iNext ){\n        iNext = mem3.aPool[prev].u.list.next;\n      }\n      memsys3Unlink(prev);\n      size = i + size/4 - prev;\n      x = mem3.aPool[prev-1].u.hdr.size4x & 2;\n      mem3.aPool[prev-1].u.hdr.size4x = size*4 | x;\n      mem3.aPool[prev+size-1].u.hdr.prevSize = size;\n      memsys3Link(prev);\n      i = prev;\n    }else{\n      size /= 4;\n    }\n    if( size>mem3.szMaster ){\n      mem3.iMaster = i;\n      mem3.szMaster = size;\n    }\n  }\n}\n\n/*\n** Return a block of memory of at least nBytes in size.\n** Return NULL if unable.\n**\n** This function assumes that the necessary mutexes, if any, are\n** already held by the caller. Hence \"Unsafe\".\n*/\nstatic void *memsys3MallocUnsafe(int nByte){\n  u32 i;\n  u32 nBlock;\n  u32 toFree;\n\n  assert( sqlite3_mutex_held(mem3.mutex) );\n  assert( sizeof(Mem3Block)==8 );\n  if( nByte<=12 ){\n    nBlock = 2;\n  }else{\n    nBlock = (nByte + 11)/8;\n  }\n  assert( nBlock>=2 );\n\n  /* STEP 1:\n  ** Look for an entry of the correct size in either the small\n  ** chunk table or in the large chunk hash table.  This is\n  ** successful most of the time (about 9 times out of 10).\n  */\n  if( nBlock <= MX_SMALL ){\n    i = mem3.aiSmall[nBlock-2];\n    if( i>0 ){\n      memsys3UnlinkFromList(i, &mem3.aiSmall[nBlock-2]);\n      return memsys3Checkout(i, nBlock);\n    }\n  }else{\n    int hash = nBlock % N_HASH;\n    for(i=mem3.aiHash[hash]; i>0; i=mem3.aPool[i].u.list.next){\n      if( mem3.aPool[i-1].u.hdr.size4x/4==nBlock ){\n        memsys3UnlinkFromList(i, &mem3.aiHash[hash]);\n        return memsys3Checkout(i, nBlock);\n      }\n    }\n  }\n\n  /* STEP 2:\n  ** Try to satisfy the allocation by carving a piece off of the end\n  ** of the master chunk.  This step usually works if step 1 fails.\n  */\n  if( mem3.szMaster>=nBlock ){\n    return memsys3FromMaster(nBlock);\n  }\n\n\n  /* STEP 3:  \n  ** Loop through the entire memory pool.  Coalesce adjacent free\n  ** chunks.  Recompute the master chunk as the largest free chunk.\n  ** Then try again to satisfy the allocation by carving a piece off\n  ** of the end of the master chunk.  This step happens very\n  ** rarely (we hope!)\n  */\n  for(toFree=nBlock*16; toFree<(mem3.nPool*16); toFree *= 2){\n    memsys3OutOfMemory(toFree);\n    if( mem3.iMaster ){\n      memsys3Link(mem3.iMaster);\n      mem3.iMaster = 0;\n      mem3.szMaster = 0;\n    }\n    for(i=0; i<N_HASH; i++){\n      memsys3Merge(&mem3.aiHash[i]);\n    }\n    for(i=0; i<MX_SMALL-1; i++){\n      memsys3Merge(&mem3.aiSmall[i]);\n    }\n    if( mem3.szMaster ){\n      memsys3Unlink(mem3.iMaster);\n      if( mem3.szMaster>=nBlock ){\n        return memsys3FromMaster(nBlock);\n      }\n    }\n  }\n\n  /* If none of the above worked, then we fail. */\n  return 0;\n}\n\n/*\n** Free an outstanding memory allocation.\n**\n** This function assumes that the necessary mutexes, if any, are\n** already held by the caller. Hence \"Unsafe\".\n*/\nvoid memsys3FreeUnsafe(void *pOld){\n  Mem3Block *p = (Mem3Block*)pOld;\n  int i;\n  u32 size, x;\n  assert( sqlite3_mutex_held(mem3.mutex) );\n  assert( p>mem3.aPool && p<&mem3.aPool[mem3.nPool] );\n  i = p - mem3.aPool;\n  assert( (mem3.aPool[i-1].u.hdr.size4x&1)==1 );\n  size = mem3.aPool[i-1].u.hdr.size4x/4;\n  assert( i+size<=mem3.nPool+1 );\n  mem3.aPool[i-1].u.hdr.size4x &= ~1;\n  mem3.aPool[i+size-1].u.hdr.prevSize = size;\n  mem3.aPool[i+size-1].u.hdr.size4x &= ~2;\n  memsys3Link(i);\n\n  /* Try to expand the master using the newly freed chunk */\n  if( mem3.iMaster ){\n    while( (mem3.aPool[mem3.iMaster-1].u.hdr.size4x&2)==0 ){\n      size = mem3.aPool[mem3.iMaster-1].u.hdr.prevSize;\n      mem3.iMaster -= size;\n      mem3.szMaster += size;\n      memsys3Unlink(mem3.iMaster);\n      x = mem3.aPool[mem3.iMaster-1].u.hdr.size4x & 2;\n      mem3.aPool[mem3.iMaster-1].u.hdr.size4x = mem3.szMaster*4 | x;\n      mem3.aPool[mem3.iMaster+mem3.szMaster-1].u.hdr.prevSize = mem3.szMaster;\n    }\n    x = mem3.aPool[mem3.iMaster-1].u.hdr.size4x & 2;\n    while( (mem3.aPool[mem3.iMaster+mem3.szMaster-1].u.hdr.size4x&1)==0 ){\n      memsys3Unlink(mem3.iMaster+mem3.szMaster);\n      mem3.szMaster += mem3.aPool[mem3.iMaster+mem3.szMaster-1].u.hdr.size4x/4;\n      mem3.aPool[mem3.iMaster-1].u.hdr.size4x = mem3.szMaster*4 | x;\n      mem3.aPool[mem3.iMaster+mem3.szMaster-1].u.hdr.prevSize = mem3.szMaster;\n    }\n  }\n}\n\n/*\n** Return the size of an outstanding allocation, in bytes.  The\n** size returned omits the 8-byte header overhead.  This only\n** works for chunks that are currently checked out.\n*/\nstatic int memsys3Size(void *p){\n  Mem3Block *pBlock;\n  if( p==0 ) return 0;\n  pBlock = (Mem3Block*)p;\n  assert( (pBlock[-1].u.hdr.size4x&1)!=0 );\n  return (pBlock[-1].u.hdr.size4x&~3)*2 - 4;\n}\n\n/*\n** Round up a request size to the next valid allocation size.\n*/\nstatic int memsys3Roundup(int n){\n  if( n<=12 ){\n    return 12;\n  }else{\n    return ((n+11)&~7) - 4;\n  }\n}\n\n/*\n** Allocate nBytes of memory.\n*/\nstatic void *memsys3Malloc(int nBytes){\n  sqlite3_int64 *p;\n  assert( nBytes>0 );          /* malloc.c filters out 0 byte requests */\n  memsys3Enter();\n  p = memsys3MallocUnsafe(nBytes);\n  memsys3Leave();\n  return (void*)p; \n}\n\n/*\n** Free memory.\n*/\nvoid memsys3Free(void *pPrior){\n  assert( pPrior );\n  memsys3Enter();\n  memsys3FreeUnsafe(pPrior);\n  memsys3Leave();\n}\n\n/*\n** Change the size of an existing memory allocation\n*/\nvoid *memsys3Realloc(void *pPrior, int nBytes){\n  int nOld;\n  void *p;\n  if( pPrior==0 ){\n    return sqlite3_malloc(nBytes);\n  }\n  if( nBytes<=0 ){\n    sqlite3_free(pPrior);\n    return 0;\n  }\n  nOld = memsys3Size(pPrior);\n  if( nBytes<=nOld && nBytes>=nOld-128 ){\n    return pPrior;\n  }\n  memsys3Enter();\n  p = memsys3MallocUnsafe(nBytes);\n  if( p ){\n    if( nOld<nBytes ){\n      memcpy(p, pPrior, nOld);\n    }else{\n      memcpy(p, pPrior, nBytes);\n    }\n    memsys3FreeUnsafe(pPrior);\n  }\n  memsys3Leave();\n  return p;\n}\n\n/*\n** Initialize this module.\n*/\nstatic int memsys3Init(void *NotUsed){\n  UNUSED_PARAMETER(NotUsed);\n  if( !sqlite3GlobalConfig.pHeap ){\n    return SQLITE_ERROR;\n  }\n\n  /* Store a pointer to the memory block in global structure mem3. */\n  assert( sizeof(Mem3Block)==8 );\n  mem3.aPool = (Mem3Block *)sqlite3GlobalConfig.pHeap;\n  mem3.nPool = (sqlite3GlobalConfig.nHeap / sizeof(Mem3Block)) - 2;\n\n  /* Initialize the master block. */\n  mem3.szMaster = mem3.nPool;\n  mem3.mnMaster = mem3.szMaster;\n  mem3.iMaster = 1;\n  mem3.aPool[0].u.hdr.size4x = (mem3.szMaster<<2) + 2;\n  mem3.aPool[mem3.nPool].u.hdr.prevSize = mem3.nPool;\n  mem3.aPool[mem3.nPool].u.hdr.size4x = 1;\n\n  return SQLITE_OK;\n}\n\n/*\n** Deinitialize this module.\n*/\nstatic void memsys3Shutdown(void *NotUsed){\n  UNUSED_PARAMETER(NotUsed);\n  mem3.mutex = 0;\n  return;\n}\n\n\n\n/*\n** Open the file indicated and write a log of all unfreed memory \n** allocations into that log.\n*/\nSQLITE_PRIVATE void sqlite3Memsys3Dump(const char *zFilename){\n#ifdef SQLITE_DEBUG\n  FILE *out;\n  u32 i, j;\n  u32 size;\n  if( zFilename==0 || zFilename[0]==0 ){\n    out = stdout;\n  }else{\n    out = fopen(zFilename, \"w\");\n    if( out==0 ){\n      fprintf(stderr, \"** Unable to output memory debug output log: %s **\\n\",\n                      zFilename);\n      return;\n    }\n  }\n  memsys3Enter();\n  fprintf(out, \"CHUNKS:\\n\");\n  for(i=1; i<=mem3.nPool; i+=size/4){\n    size = mem3.aPool[i-1].u.hdr.size4x;\n    if( size/4<=1 ){\n      fprintf(out, \"%p size error\\n\", &mem3.aPool[i]);\n      assert( 0 );\n      break;\n    }\n    if( (size&1)==0 && mem3.aPool[i+size/4-1].u.hdr.prevSize!=size/4 ){\n      fprintf(out, \"%p tail size does not match\\n\", &mem3.aPool[i]);\n      assert( 0 );\n      break;\n    }\n    if( ((mem3.aPool[i+size/4-1].u.hdr.size4x&2)>>1)!=(size&1) ){\n      fprintf(out, \"%p tail checkout bit is incorrect\\n\", &mem3.aPool[i]);\n      assert( 0 );\n      break;\n    }\n    if( size&1 ){\n      fprintf(out, \"%p %6d bytes checked out\\n\", &mem3.aPool[i], (size/4)*8-8);\n    }else{\n      fprintf(out, \"%p %6d bytes free%s\\n\", &mem3.aPool[i], (size/4)*8-8,\n                  i==mem3.iMaster ? \" **master**\" : \"\");\n    }\n  }\n  for(i=0; i<MX_SMALL-1; i++){\n    if( mem3.aiSmall[i]==0 ) continue;\n    fprintf(out, \"small(%2d):\", i);\n    for(j = mem3.aiSmall[i]; j>0; j=mem3.aPool[j].u.list.next){\n      fprintf(out, \" %p(%d)\", &mem3.aPool[j],\n              (mem3.aPool[j-1].u.hdr.size4x/4)*8-8);\n    }\n    fprintf(out, \"\\n\"); \n  }\n  for(i=0; i<N_HASH; i++){\n    if( mem3.aiHash[i]==0 ) continue;\n    fprintf(out, \"hash(%2d):\", i);\n    for(j = mem3.aiHash[i]; j>0; j=mem3.aPool[j].u.list.next){\n      fprintf(out, \" %p(%d)\", &mem3.aPool[j],\n              (mem3.aPool[j-1].u.hdr.size4x/4)*8-8);\n    }\n    fprintf(out, \"\\n\"); \n  }\n  fprintf(out, \"master=%d\\n\", mem3.iMaster);\n  fprintf(out, \"nowUsed=%d\\n\", mem3.nPool*8 - mem3.szMaster*8);\n  fprintf(out, \"mxUsed=%d\\n\", mem3.nPool*8 - mem3.mnMaster*8);\n  sqlite3_mutex_leave(mem3.mutex);\n  if( out==stdout ){\n    fflush(stdout);\n  }else{\n    fclose(out);\n  }\n#else\n  UNUSED_PARAMETER(zFilename);\n#endif\n}\n\n/*\n** This routine is the only routine in this file with external \n** linkage.\n**\n** Populate the low-level memory allocation function pointers in\n** sqlite3GlobalConfig.m with pointers to the routines in this file. The\n** arguments specify the block of memory to manage.\n**\n** This routine is only called by sqlite3_config(), and therefore\n** is not required to be threadsafe (it is not).\n*/\nSQLITE_PRIVATE const sqlite3_mem_methods *sqlite3MemGetMemsys3(void){\n  static const sqlite3_mem_methods mempoolMethods = {\n     memsys3Malloc,\n     memsys3Free,\n     memsys3Realloc,\n     memsys3Size,\n     memsys3Roundup,\n     memsys3Init,\n     memsys3Shutdown,\n     0\n  };\n  return &mempoolMethods;\n}\n\n#endif /* SQLITE_ENABLE_MEMSYS3 */\n\n/************** End of mem3.c ************************************************/\n/************** Begin file mem5.c ********************************************/\n/*\n** 2007 October 14\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains the C functions that implement a memory\n** allocation subsystem for use by SQLite. \n**\n** This version of the memory allocation subsystem omits all\n** use of malloc(). The application gives SQLite a block of memory\n** before calling sqlite3_initialize() from which allocations\n** are made and returned by the xMalloc() and xRealloc() \n** implementations. Once sqlite3_initialize() has been called,\n** the amount of memory available to SQLite is fixed and cannot\n** be changed.\n**\n** This version of the memory allocation subsystem is included\n** in the build only if SQLITE_ENABLE_MEMSYS5 is defined.\n**\n** This memory allocator uses the following algorithm:\n**\n**   1.  All memory allocations sizes are rounded up to a power of 2.\n**\n**   2.  If two adjacent free blocks are the halves of a larger block,\n**       then the two blocks are coalesed into the single larger block.\n**\n**   3.  New memory is allocated from the first available free block.\n**\n** This algorithm is described in: J. M. Robson. \"Bounds for Some Functions\n** Concerning Dynamic Storage Allocation\". Journal of the Association for\n** Computing Machinery, Volume 21, Number 8, July 1974, pages 491-499.\n** \n** Let n be the size of the largest allocation divided by the minimum\n** allocation size (after rounding all sizes up to a power of 2.)  Let M\n** be the maximum amount of memory ever outstanding at one time.  Let\n** N be the total amount of memory available for allocation.  Robson\n** proved that this memory allocator will never breakdown due to \n** fragmentation as long as the following constraint holds:\n**\n**      N >=  M*(1 + log2(n)/2) - n + 1\n**\n** The sqlite3_status() logic tracks the maximum values of n and M so\n** that an application can, at any time, verify this constraint.\n*/\n\n/*\n** This version of the memory allocator is used only when \n** SQLITE_ENABLE_MEMSYS5 is defined.\n*/\n#ifdef SQLITE_ENABLE_MEMSYS5\n\n/*\n** A minimum allocation is an instance of the following structure.\n** Larger allocations are an array of these structures where the\n** size of the array is a power of 2.\n**\n** The size of this object must be a power of two.  That fact is\n** verified in memsys5Init().\n*/\ntypedef struct Mem5Link Mem5Link;\nstruct Mem5Link {\n  int next;       /* Index of next free chunk */\n  int prev;       /* Index of previous free chunk */\n};\n\n/*\n** Maximum size of any allocation is ((1<<LOGMAX)*mem5.szAtom). Since\n** mem5.szAtom is always at least 8 and 32-bit integers are used,\n** it is not actually possible to reach this limit.\n*/\n#define LOGMAX 30\n\n/*\n** Masks used for mem5.aCtrl[] elements.\n*/\n#define CTRL_LOGSIZE  0x1f    /* Log2 Size of this block */\n#define CTRL_FREE     0x20    /* True if not checked out */\n\n/*\n** All of the static variables used by this module are collected\n** into a single structure named \"mem5\".  This is to keep the\n** static variables organized and to reduce namespace pollution\n** when this module is combined with other in the amalgamation.\n*/\nstatic SQLITE_WSD struct Mem5Global {\n  /*\n  ** Memory available for allocation\n  */\n  int szAtom;      /* Smallest possible allocation in bytes */\n  int nBlock;      /* Number of szAtom sized blocks in zPool */\n  u8 *zPool;       /* Memory available to be allocated */\n  \n  /*\n  ** Mutex to control access to the memory allocation subsystem.\n  */\n  sqlite3_mutex *mutex;\n\n  /*\n  ** Performance statistics\n  */\n  u64 nAlloc;         /* Total number of calls to malloc */\n  u64 totalAlloc;     /* Total of all malloc calls - includes internal frag */\n  u64 totalExcess;    /* Total internal fragmentation */\n  u32 currentOut;     /* Current checkout, including internal fragmentation */\n  u32 currentCount;   /* Current number of distinct checkouts */\n  u32 maxOut;         /* Maximum instantaneous currentOut */\n  u32 maxCount;       /* Maximum instantaneous currentCount */\n  u32 maxRequest;     /* Largest allocation (exclusive of internal frag) */\n  \n  /*\n  ** Lists of free blocks.  aiFreelist[0] is a list of free blocks of\n  ** size mem5.szAtom.  aiFreelist[1] holds blocks of size szAtom*2.\n  ** and so forth.\n  */\n  int aiFreelist[LOGMAX+1];\n\n  /*\n  ** Space for tracking which blocks are checked out and the size\n  ** of each block.  One byte per block.\n  */\n  u8 *aCtrl;\n\n} mem5 = { 0 };\n\n/*\n** Access the static variable through a macro for SQLITE_OMIT_WSD\n*/\n#define mem5 GLOBAL(struct Mem5Global, mem5)\n\n/*\n** Assuming mem5.zPool is divided up into an array of Mem5Link\n** structures, return a pointer to the idx-th such lik.\n*/\n#define MEM5LINK(idx) ((Mem5Link *)(&mem5.zPool[(idx)*mem5.szAtom]))\n\n/*\n** Unlink the chunk at mem5.aPool[i] from list it is currently\n** on.  It should be found on mem5.aiFreelist[iLogsize].\n*/\nstatic void memsys5Unlink(int i, int iLogsize){\n  int next, prev;\n  assert( i>=0 && i<mem5.nBlock );\n  assert( iLogsize>=0 && iLogsize<=LOGMAX );\n  assert( (mem5.aCtrl[i] & CTRL_LOGSIZE)==iLogsize );\n\n  next = MEM5LINK(i)->next;\n  prev = MEM5LINK(i)->prev;\n  if( prev<0 ){\n    mem5.aiFreelist[iLogsize] = next;\n  }else{\n    MEM5LINK(prev)->next = next;\n  }\n  if( next>=0 ){\n    MEM5LINK(next)->prev = prev;\n  }\n}\n\n/*\n** Link the chunk at mem5.aPool[i] so that is on the iLogsize\n** free list.\n*/\nstatic void memsys5Link(int i, int iLogsize){\n  int x;\n  assert( sqlite3_mutex_held(mem5.mutex) );\n  assert( i>=0 && i<mem5.nBlock );\n  assert( iLogsize>=0 && iLogsize<=LOGMAX );\n  assert( (mem5.aCtrl[i] & CTRL_LOGSIZE)==iLogsize );\n\n  x = MEM5LINK(i)->next = mem5.aiFreelist[iLogsize];\n  MEM5LINK(i)->prev = -1;\n  if( x>=0 ){\n    assert( x<mem5.nBlock );\n    MEM5LINK(x)->prev = i;\n  }\n  mem5.aiFreelist[iLogsize] = i;\n}\n\n/*\n** If the STATIC_MEM mutex is not already held, obtain it now. The mutex\n** will already be held (obtained by code in malloc.c) if\n** sqlite3GlobalConfig.bMemStat is true.\n*/\nstatic void memsys5Enter(void){\n  sqlite3_mutex_enter(mem5.mutex);\n}\nstatic void memsys5Leave(void){\n  sqlite3_mutex_leave(mem5.mutex);\n}\n\n/*\n** Return the size of an outstanding allocation, in bytes.  The\n** size returned omits the 8-byte header overhead.  This only\n** works for chunks that are currently checked out.\n*/\nstatic int memsys5Size(void *p){\n  int iSize = 0;\n  if( p ){\n    int i = ((u8 *)p-mem5.zPool)/mem5.szAtom;\n    assert( i>=0 && i<mem5.nBlock );\n    iSize = mem5.szAtom * (1 << (mem5.aCtrl[i]&CTRL_LOGSIZE));\n  }\n  return iSize;\n}\n\n/*\n** Find the first entry on the freelist iLogsize.  Unlink that\n** entry and return its index. \n*/\nstatic int memsys5UnlinkFirst(int iLogsize){\n  int i;\n  int iFirst;\n\n  assert( iLogsize>=0 && iLogsize<=LOGMAX );\n  i = iFirst = mem5.aiFreelist[iLogsize];\n  assert( iFirst>=0 );\n  while( i>0 ){\n    if( i<iFirst ) iFirst = i;\n    i = MEM5LINK(i)->next;\n  }\n  memsys5Unlink(iFirst, iLogsize);\n  return iFirst;\n}\n\n/*\n** Return a block of memory of at least nBytes in size.\n** Return NULL if unable.  Return NULL if nBytes==0.\n**\n** The caller guarantees that nByte positive.\n**\n** The caller has obtained a mutex prior to invoking this\n** routine so there is never any chance that two or more\n** threads can be in this routine at the same time.\n*/\nstatic void *memsys5MallocUnsafe(int nByte){\n  int i;           /* Index of a mem5.aPool[] slot */\n  int iBin;        /* Index into mem5.aiFreelist[] */\n  int iFullSz;     /* Size of allocation rounded up to power of 2 */\n  int iLogsize;    /* Log2 of iFullSz/POW2_MIN */\n\n  /* nByte must be a positive */\n  assert( nByte>0 );\n\n  /* Keep track of the maximum allocation request.  Even unfulfilled\n  ** requests are counted */\n  if( (u32)nByte>mem5.maxRequest ){\n    mem5.maxRequest = nByte;\n  }\n\n  /* Abort if the requested allocation size is larger than the largest\n  ** power of two that we can represent using 32-bit signed integers.\n  */\n  if( nByte > 0x40000000 ){\n    return 0;\n  }\n\n  /* Round nByte up to the next valid power of two */\n  for(iFullSz=mem5.szAtom, iLogsize=0; iFullSz<nByte; iFullSz *= 2, iLogsize++){}\n\n  /* Make sure mem5.aiFreelist[iLogsize] contains at least one free\n  ** block.  If not, then split a block of the next larger power of\n  ** two in order to create a new free block of size iLogsize.\n  */\n  for(iBin=iLogsize; mem5.aiFreelist[iBin]<0 && iBin<=LOGMAX; iBin++){}\n  if( iBin>LOGMAX ){\n    testcase( sqlite3GlobalConfig.xLog!=0 );\n    sqlite3_log(SQLITE_NOMEM, \"failed to allocate %u bytes\", nByte);\n    return 0;\n  }\n  i = memsys5UnlinkFirst(iBin);\n  while( iBin>iLogsize ){\n    int newSize;\n\n    iBin--;\n    newSize = 1 << iBin;\n    mem5.aCtrl[i+newSize] = CTRL_FREE | iBin;\n    memsys5Link(i+newSize, iBin);\n  }\n  mem5.aCtrl[i] = iLogsize;\n\n  /* Update allocator performance statistics. */\n  mem5.nAlloc++;\n  mem5.totalAlloc += iFullSz;\n  mem5.totalExcess += iFullSz - nByte;\n  mem5.currentCount++;\n  mem5.currentOut += iFullSz;\n  if( mem5.maxCount<mem5.currentCount ) mem5.maxCount = mem5.currentCount;\n  if( mem5.maxOut<mem5.currentOut ) mem5.maxOut = mem5.currentOut;\n\n  /* Return a pointer to the allocated memory. */\n  return (void*)&mem5.zPool[i*mem5.szAtom];\n}\n\n/*\n** Free an outstanding memory allocation.\n*/\nstatic void memsys5FreeUnsafe(void *pOld){\n  u32 size, iLogsize;\n  int iBlock;\n\n  /* Set iBlock to the index of the block pointed to by pOld in \n  ** the array of mem5.szAtom byte blocks pointed to by mem5.zPool.\n  */\n  iBlock = ((u8 *)pOld-mem5.zPool)/mem5.szAtom;\n\n  /* Check that the pointer pOld points to a valid, non-free block. */\n  assert( iBlock>=0 && iBlock<mem5.nBlock );\n  assert( ((u8 *)pOld-mem5.zPool)%mem5.szAtom==0 );\n  assert( (mem5.aCtrl[iBlock] & CTRL_FREE)==0 );\n\n  iLogsize = mem5.aCtrl[iBlock] & CTRL_LOGSIZE;\n  size = 1<<iLogsize;\n  assert( iBlock+size-1<(u32)mem5.nBlock );\n\n  mem5.aCtrl[iBlock] |= CTRL_FREE;\n  mem5.aCtrl[iBlock+size-1] |= CTRL_FREE;\n  assert( mem5.currentCount>0 );\n  assert( mem5.currentOut>=(size*mem5.szAtom) );\n  mem5.currentCount--;\n  mem5.currentOut -= size*mem5.szAtom;\n  assert( mem5.currentOut>0 || mem5.currentCount==0 );\n  assert( mem5.currentCount>0 || mem5.currentOut==0 );\n\n  mem5.aCtrl[iBlock] = CTRL_FREE | iLogsize;\n  while( ALWAYS(iLogsize<LOGMAX) ){\n    int iBuddy;\n    if( (iBlock>>iLogsize) & 1 ){\n      iBuddy = iBlock - size;\n    }else{\n      iBuddy = iBlock + size;\n    }\n    assert( iBuddy>=0 );\n    if( (iBuddy+(1<<iLogsize))>mem5.nBlock ) break;\n    if( mem5.aCtrl[iBuddy]!=(CTRL_FREE | iLogsize) ) break;\n    memsys5Unlink(iBuddy, iLogsize);\n    iLogsize++;\n    if( iBuddy<iBlock ){\n      mem5.aCtrl[iBuddy] = CTRL_FREE | iLogsize;\n      mem5.aCtrl[iBlock] = 0;\n      iBlock = iBuddy;\n    }else{\n      mem5.aCtrl[iBlock] = CTRL_FREE | iLogsize;\n      mem5.aCtrl[iBuddy] = 0;\n    }\n    size *= 2;\n  }\n  memsys5Link(iBlock, iLogsize);\n}\n\n/*\n** Allocate nBytes of memory\n*/\nstatic void *memsys5Malloc(int nBytes){\n  sqlite3_int64 *p = 0;\n  if( nBytes>0 ){\n    memsys5Enter();\n    p = memsys5MallocUnsafe(nBytes);\n    memsys5Leave();\n  }\n  return (void*)p; \n}\n\n/*\n** Free memory.\n**\n** The outer layer memory allocator prevents this routine from\n** being called with pPrior==0.\n*/\nstatic void memsys5Free(void *pPrior){\n  assert( pPrior!=0 );\n  memsys5Enter();\n  memsys5FreeUnsafe(pPrior);\n  memsys5Leave();  \n}\n\n/*\n** Change the size of an existing memory allocation.\n**\n** The outer layer memory allocator prevents this routine from\n** being called with pPrior==0.  \n**\n** nBytes is always a value obtained from a prior call to\n** memsys5Round().  Hence nBytes is always a non-negative power\n** of two.  If nBytes==0 that means that an oversize allocation\n** (an allocation larger than 0x40000000) was requested and this\n** routine should return 0 without freeing pPrior.\n*/\nstatic void *memsys5Realloc(void *pPrior, int nBytes){\n  int nOld;\n  void *p;\n  assert( pPrior!=0 );\n  assert( (nBytes&(nBytes-1))==0 );  /* EV: R-46199-30249 */\n  assert( nBytes>=0 );\n  if( nBytes==0 ){\n    return 0;\n  }\n  nOld = memsys5Size(pPrior);\n  if( nBytes<=nOld ){\n    return pPrior;\n  }\n  memsys5Enter();\n  p = memsys5MallocUnsafe(nBytes);\n  if( p ){\n    memcpy(p, pPrior, nOld);\n    memsys5FreeUnsafe(pPrior);\n  }\n  memsys5Leave();\n  return p;\n}\n\n/*\n** Round up a request size to the next valid allocation size.  If\n** the allocation is too large to be handled by this allocation system,\n** return 0.\n**\n** All allocations must be a power of two and must be expressed by a\n** 32-bit signed integer.  Hence the largest allocation is 0x40000000\n** or 1073741824 bytes.\n*/\nstatic int memsys5Roundup(int n){\n  int iFullSz;\n  if( n > 0x40000000 ) return 0;\n  for(iFullSz=mem5.szAtom; iFullSz<n; iFullSz *= 2);\n  return iFullSz;\n}\n\n/*\n** Return the ceiling of the logarithm base 2 of iValue.\n**\n** Examples:   memsys5Log(1) -> 0\n**             memsys5Log(2) -> 1\n**             memsys5Log(4) -> 2\n**             memsys5Log(5) -> 3\n**             memsys5Log(8) -> 3\n**             memsys5Log(9) -> 4\n*/\nstatic int memsys5Log(int iValue){\n  int iLog;\n  for(iLog=0; (iLog<((sizeof(int)*8)-1)) && (1<<iLog)<iValue; iLog++);\n  return iLog;\n}\n\n/*\n** Initialize the memory allocator.\n**\n** This routine is not threadsafe.  The caller must be holding a mutex\n** to prevent multiple threads from entering at the same time.\n*/\nstatic int memsys5Init(void *NotUsed){\n  int ii;            /* Loop counter */\n  int nByte;         /* Number of bytes of memory available to this allocator */\n  u8 *zByte;         /* Memory usable by this allocator */\n  int nMinLog;       /* Log base 2 of minimum allocation size in bytes */\n  int iOffset;       /* An offset into mem5.aCtrl[] */\n\n  UNUSED_PARAMETER(NotUsed);\n\n  /* For the purposes of this routine, disable the mutex */\n  mem5.mutex = 0;\n\n  /* The size of a Mem5Link object must be a power of two.  Verify that\n  ** this is case.\n  */\n  assert( (sizeof(Mem5Link)&(sizeof(Mem5Link)-1))==0 );\n\n  nByte = sqlite3GlobalConfig.nHeap;\n  zByte = (u8*)sqlite3GlobalConfig.pHeap;\n  assert( zByte!=0 );  /* sqlite3_config() does not allow otherwise */\n\n  /* boundaries on sqlite3GlobalConfig.mnReq are enforced in sqlite3_config() */\n  nMinLog = memsys5Log(sqlite3GlobalConfig.mnReq);\n  mem5.szAtom = (1<<nMinLog);\n  while( (int)sizeof(Mem5Link)>mem5.szAtom ){\n    mem5.szAtom = mem5.szAtom << 1;\n  }\n\n  mem5.nBlock = (nByte / (mem5.szAtom+sizeof(u8)));\n  mem5.zPool = zByte;\n  mem5.aCtrl = (u8 *)&mem5.zPool[mem5.nBlock*mem5.szAtom];\n\n  for(ii=0; ii<=LOGMAX; ii++){\n    mem5.aiFreelist[ii] = -1;\n  }\n\n  iOffset = 0;\n  for(ii=LOGMAX; ii>=0; ii--){\n    int nAlloc = (1<<ii);\n    if( (iOffset+nAlloc)<=mem5.nBlock ){\n      mem5.aCtrl[iOffset] = ii | CTRL_FREE;\n      memsys5Link(iOffset, ii);\n      iOffset += nAlloc;\n    }\n    assert((iOffset+nAlloc)>mem5.nBlock);\n  }\n\n  /* If a mutex is required for normal operation, allocate one */\n  if( sqlite3GlobalConfig.bMemstat==0 ){\n    mem5.mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MEM);\n  }\n\n  return SQLITE_OK;\n}\n\n/*\n** Deinitialize this module.\n*/\nstatic void memsys5Shutdown(void *NotUsed){\n  UNUSED_PARAMETER(NotUsed);\n  mem5.mutex = 0;\n  return;\n}\n\n#ifdef SQLITE_TEST\n/*\n** Open the file indicated and write a log of all unfreed memory \n** allocations into that log.\n*/\nSQLITE_PRIVATE void sqlite3Memsys5Dump(const char *zFilename){\n  FILE *out;\n  int i, j, n;\n  int nMinLog;\n\n  if( zFilename==0 || zFilename[0]==0 ){\n    out = stdout;\n  }else{\n    out = fopen(zFilename, \"w\");\n    if( out==0 ){\n      fprintf(stderr, \"** Unable to output memory debug output log: %s **\\n\",\n                      zFilename);\n      return;\n    }\n  }\n  memsys5Enter();\n  nMinLog = memsys5Log(mem5.szAtom);\n  for(i=0; i<=LOGMAX && i+nMinLog<32; i++){\n    for(n=0, j=mem5.aiFreelist[i]; j>=0; j = MEM5LINK(j)->next, n++){}\n    fprintf(out, \"freelist items of size %d: %d\\n\", mem5.szAtom << i, n);\n  }\n  fprintf(out, \"mem5.nAlloc       = %llu\\n\", mem5.nAlloc);\n  fprintf(out, \"mem5.totalAlloc   = %llu\\n\", mem5.totalAlloc);\n  fprintf(out, \"mem5.totalExcess  = %llu\\n\", mem5.totalExcess);\n  fprintf(out, \"mem5.currentOut   = %u\\n\", mem5.currentOut);\n  fprintf(out, \"mem5.currentCount = %u\\n\", mem5.currentCount);\n  fprintf(out, \"mem5.maxOut       = %u\\n\", mem5.maxOut);\n  fprintf(out, \"mem5.maxCount     = %u\\n\", mem5.maxCount);\n  fprintf(out, \"mem5.maxRequest   = %u\\n\", mem5.maxRequest);\n  memsys5Leave();\n  if( out==stdout ){\n    fflush(stdout);\n  }else{\n    fclose(out);\n  }\n}\n#endif\n\n/*\n** This routine is the only routine in this file with external \n** linkage. It returns a pointer to a static sqlite3_mem_methods\n** struct populated with the memsys5 methods.\n*/\nSQLITE_PRIVATE const sqlite3_mem_methods *sqlite3MemGetMemsys5(void){\n  static const sqlite3_mem_methods memsys5Methods = {\n     memsys5Malloc,\n     memsys5Free,\n     memsys5Realloc,\n     memsys5Size,\n     memsys5Roundup,\n     memsys5Init,\n     memsys5Shutdown,\n     0\n  };\n  return &memsys5Methods;\n}\n\n#endif /* SQLITE_ENABLE_MEMSYS5 */\n\n/************** End of mem5.c ************************************************/\n/************** Begin file mutex.c *******************************************/\n/*\n** 2007 August 14\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains the C functions that implement mutexes.\n**\n** This file contains code that is common across all mutex implementations.\n*/\n\n#if defined(SQLITE_DEBUG) && !defined(SQLITE_MUTEX_OMIT)\n/*\n** For debugging purposes, record when the mutex subsystem is initialized\n** and uninitialized so that we can assert() if there is an attempt to\n** allocate a mutex while the system is uninitialized.\n*/\nstatic SQLITE_WSD int mutexIsInit = 0;\n#endif /* SQLITE_DEBUG */\n\n\n#ifndef SQLITE_MUTEX_OMIT\n/*\n** Initialize the mutex system.\n*/\nSQLITE_PRIVATE int sqlite3MutexInit(void){ \n  int rc = SQLITE_OK;\n  if( !sqlite3GlobalConfig.mutex.xMutexAlloc ){\n    /* If the xMutexAlloc method has not been set, then the user did not\n    ** install a mutex implementation via sqlite3_config() prior to \n    ** sqlite3_initialize() being called. This block copies pointers to\n    ** the default implementation into the sqlite3GlobalConfig structure.\n    */\n    sqlite3_mutex_methods const *pFrom;\n    sqlite3_mutex_methods *pTo = &sqlite3GlobalConfig.mutex;\n\n    if( sqlite3GlobalConfig.bCoreMutex ){\n      pFrom = sqlite3DefaultMutex();\n    }else{\n      pFrom = sqlite3NoopMutex();\n    }\n    memcpy(pTo, pFrom, offsetof(sqlite3_mutex_methods, xMutexAlloc));\n    memcpy(&pTo->xMutexFree, &pFrom->xMutexFree,\n           sizeof(*pTo) - offsetof(sqlite3_mutex_methods, xMutexFree));\n    pTo->xMutexAlloc = pFrom->xMutexAlloc;\n  }\n  rc = sqlite3GlobalConfig.mutex.xMutexInit();\n\n#ifdef SQLITE_DEBUG\n  GLOBAL(int, mutexIsInit) = 1;\n#endif\n\n  return rc;\n}\n\n/*\n** Shutdown the mutex system. This call frees resources allocated by\n** sqlite3MutexInit().\n*/\nSQLITE_PRIVATE int sqlite3MutexEnd(void){\n  int rc = SQLITE_OK;\n  if( sqlite3GlobalConfig.mutex.xMutexEnd ){\n    rc = sqlite3GlobalConfig.mutex.xMutexEnd();\n  }\n\n#ifdef SQLITE_DEBUG\n  GLOBAL(int, mutexIsInit) = 0;\n#endif\n\n  return rc;\n}\n\n/*\n** Retrieve a pointer to a static mutex or allocate a new dynamic one.\n*/\nSQLITE_API sqlite3_mutex *sqlite3_mutex_alloc(int id){\n#ifndef SQLITE_OMIT_AUTOINIT\n  if( sqlite3_initialize() ) return 0;\n#endif\n  return sqlite3GlobalConfig.mutex.xMutexAlloc(id);\n}\n\nSQLITE_PRIVATE sqlite3_mutex *sqlite3MutexAlloc(int id){\n  if( !sqlite3GlobalConfig.bCoreMutex ){\n    return 0;\n  }\n  assert( GLOBAL(int, mutexIsInit) );\n  return sqlite3GlobalConfig.mutex.xMutexAlloc(id);\n}\n\n/*\n** Free a dynamic mutex.\n*/\nSQLITE_API void sqlite3_mutex_free(sqlite3_mutex *p){\n  if( p ){\n    sqlite3GlobalConfig.mutex.xMutexFree(p);\n  }\n}\n\n/*\n** Obtain the mutex p. If some other thread already has the mutex, block\n** until it can be obtained.\n*/\nSQLITE_API void sqlite3_mutex_enter(sqlite3_mutex *p){\n  if( p ){\n    sqlite3GlobalConfig.mutex.xMutexEnter(p);\n  }\n}\n\n/*\n** Obtain the mutex p. If successful, return SQLITE_OK. Otherwise, if another\n** thread holds the mutex and it cannot be obtained, return SQLITE_BUSY.\n*/\nSQLITE_API int sqlite3_mutex_try(sqlite3_mutex *p){\n  int rc = SQLITE_OK;\n  if( p ){\n    return sqlite3GlobalConfig.mutex.xMutexTry(p);\n  }\n  return rc;\n}\n\n/*\n** The sqlite3_mutex_leave() routine exits a mutex that was previously\n** entered by the same thread.  The behavior is undefined if the mutex \n** is not currently entered. If a NULL pointer is passed as an argument\n** this function is a no-op.\n*/\nSQLITE_API void sqlite3_mutex_leave(sqlite3_mutex *p){\n  if( p ){\n    sqlite3GlobalConfig.mutex.xMutexLeave(p);\n  }\n}\n\n#ifndef NDEBUG\n/*\n** The sqlite3_mutex_held() and sqlite3_mutex_notheld() routine are\n** intended for use inside assert() statements.\n*/\nSQLITE_API int sqlite3_mutex_held(sqlite3_mutex *p){\n  return p==0 || sqlite3GlobalConfig.mutex.xMutexHeld(p);\n}\nSQLITE_API int sqlite3_mutex_notheld(sqlite3_mutex *p){\n  return p==0 || sqlite3GlobalConfig.mutex.xMutexNotheld(p);\n}\n#endif\n\n#endif /* SQLITE_MUTEX_OMIT */\n\n/************** End of mutex.c ***********************************************/\n/************** Begin file mutex_noop.c **************************************/\n/*\n** 2008 October 07\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains the C functions that implement mutexes.\n**\n** This implementation in this file does not provide any mutual\n** exclusion and is thus suitable for use only in applications\n** that use SQLite in a single thread.  The routines defined\n** here are place-holders.  Applications can substitute working\n** mutex routines at start-time using the\n**\n**     sqlite3_config(SQLITE_CONFIG_MUTEX,...)\n**\n** interface.\n**\n** If compiled with SQLITE_DEBUG, then additional logic is inserted\n** that does error checking on mutexes to make sure they are being\n** called correctly.\n*/\n\n#ifndef SQLITE_MUTEX_OMIT\n\n#ifndef SQLITE_DEBUG\n/*\n** Stub routines for all mutex methods.\n**\n** This routines provide no mutual exclusion or error checking.\n*/\nstatic int noopMutexInit(void){ return SQLITE_OK; }\nstatic int noopMutexEnd(void){ return SQLITE_OK; }\nstatic sqlite3_mutex *noopMutexAlloc(int id){ \n  UNUSED_PARAMETER(id);\n  return (sqlite3_mutex*)8; \n}\nstatic void noopMutexFree(sqlite3_mutex *p){ UNUSED_PARAMETER(p); return; }\nstatic void noopMutexEnter(sqlite3_mutex *p){ UNUSED_PARAMETER(p); return; }\nstatic int noopMutexTry(sqlite3_mutex *p){\n  UNUSED_PARAMETER(p);\n  return SQLITE_OK;\n}\nstatic void noopMutexLeave(sqlite3_mutex *p){ UNUSED_PARAMETER(p); return; }\n\nSQLITE_PRIVATE sqlite3_mutex_methods const *sqlite3NoopMutex(void){\n  static const sqlite3_mutex_methods sMutex = {\n    noopMutexInit,\n    noopMutexEnd,\n    noopMutexAlloc,\n    noopMutexFree,\n    noopMutexEnter,\n    noopMutexTry,\n    noopMutexLeave,\n\n    0,\n    0,\n  };\n\n  return &sMutex;\n}\n#endif /* !SQLITE_DEBUG */\n\n#ifdef SQLITE_DEBUG\n/*\n** In this implementation, error checking is provided for testing\n** and debugging purposes.  The mutexes still do not provide any\n** mutual exclusion.\n*/\n\n/*\n** The mutex object\n*/\ntypedef struct sqlite3_debug_mutex {\n  int id;     /* The mutex type */\n  int cnt;    /* Number of entries without a matching leave */\n} sqlite3_debug_mutex;\n\n/*\n** The sqlite3_mutex_held() and sqlite3_mutex_notheld() routine are\n** intended for use inside assert() statements.\n*/\nstatic int debugMutexHeld(sqlite3_mutex *pX){\n  sqlite3_debug_mutex *p = (sqlite3_debug_mutex*)pX;\n  return p==0 || p->cnt>0;\n}\nstatic int debugMutexNotheld(sqlite3_mutex *pX){\n  sqlite3_debug_mutex *p = (sqlite3_debug_mutex*)pX;\n  return p==0 || p->cnt==0;\n}\n\n/*\n** Initialize and deinitialize the mutex subsystem.\n*/\nstatic int debugMutexInit(void){ return SQLITE_OK; }\nstatic int debugMutexEnd(void){ return SQLITE_OK; }\n\n/*\n** The sqlite3_mutex_alloc() routine allocates a new\n** mutex and returns a pointer to it.  If it returns NULL\n** that means that a mutex could not be allocated. \n*/\nstatic sqlite3_mutex *debugMutexAlloc(int id){\n  static sqlite3_debug_mutex aStatic[6];\n  sqlite3_debug_mutex *pNew = 0;\n  switch( id ){\n    case SQLITE_MUTEX_FAST:\n    case SQLITE_MUTEX_RECURSIVE: {\n      pNew = sqlite3Malloc(sizeof(*pNew));\n      if( pNew ){\n        pNew->id = id;\n        pNew->cnt = 0;\n      }\n      break;\n    }\n    default: {\n      assert( id-2 >= 0 );\n      assert( id-2 < (int)(sizeof(aStatic)/sizeof(aStatic[0])) );\n      pNew = &aStatic[id-2];\n      pNew->id = id;\n      break;\n    }\n  }\n  return (sqlite3_mutex*)pNew;\n}\n\n/*\n** This routine deallocates a previously allocated mutex.\n*/\nstatic void debugMutexFree(sqlite3_mutex *pX){\n  sqlite3_debug_mutex *p = (sqlite3_debug_mutex*)pX;\n  assert( p->cnt==0 );\n  assert( p->id==SQLITE_MUTEX_FAST || p->id==SQLITE_MUTEX_RECURSIVE );\n  sqlite3_free(p);\n}\n\n/*\n** The sqlite3_mutex_enter() and sqlite3_mutex_try() routines attempt\n** to enter a mutex.  If another thread is already within the mutex,\n** sqlite3_mutex_enter() will block and sqlite3_mutex_try() will return\n** SQLITE_BUSY.  The sqlite3_mutex_try() interface returns SQLITE_OK\n** upon successful entry.  Mutexes created using SQLITE_MUTEX_RECURSIVE can\n** be entered multiple times by the same thread.  In such cases the,\n** mutex must be exited an equal number of times before another thread\n** can enter.  If the same thread tries to enter any other kind of mutex\n** more than once, the behavior is undefined.\n*/\nstatic void debugMutexEnter(sqlite3_mutex *pX){\n  sqlite3_debug_mutex *p = (sqlite3_debug_mutex*)pX;\n  assert( p->id==SQLITE_MUTEX_RECURSIVE || debugMutexNotheld(pX) );\n  p->cnt++;\n}\nstatic int debugMutexTry(sqlite3_mutex *pX){\n  sqlite3_debug_mutex *p = (sqlite3_debug_mutex*)pX;\n  assert( p->id==SQLITE_MUTEX_RECURSIVE || debugMutexNotheld(pX) );\n  p->cnt++;\n  return SQLITE_OK;\n}\n\n/*\n** The sqlite3_mutex_leave() routine exits a mutex that was\n** previously entered by the same thread.  The behavior\n** is undefined if the mutex is not currently entered or\n** is not currently allocated.  SQLite will never do either.\n*/\nstatic void debugMutexLeave(sqlite3_mutex *pX){\n  sqlite3_debug_mutex *p = (sqlite3_debug_mutex*)pX;\n  assert( debugMutexHeld(pX) );\n  p->cnt--;\n  assert( p->id==SQLITE_MUTEX_RECURSIVE || debugMutexNotheld(pX) );\n}\n\nSQLITE_PRIVATE sqlite3_mutex_methods const *sqlite3NoopMutex(void){\n  static const sqlite3_mutex_methods sMutex = {\n    debugMutexInit,\n    debugMutexEnd,\n    debugMutexAlloc,\n    debugMutexFree,\n    debugMutexEnter,\n    debugMutexTry,\n    debugMutexLeave,\n\n    debugMutexHeld,\n    debugMutexNotheld\n  };\n\n  return &sMutex;\n}\n#endif /* SQLITE_DEBUG */\n\n/*\n** If compiled with SQLITE_MUTEX_NOOP, then the no-op mutex implementation\n** is used regardless of the run-time threadsafety setting.\n*/\n#ifdef SQLITE_MUTEX_NOOP\nSQLITE_PRIVATE sqlite3_mutex_methods const *sqlite3DefaultMutex(void){\n  return sqlite3NoopMutex();\n}\n#endif /* SQLITE_MUTEX_NOOP */\n#endif /* SQLITE_MUTEX_OMIT */\n\n/************** End of mutex_noop.c ******************************************/\n/************** Begin file mutex_os2.c ***************************************/\n/*\n** 2007 August 28\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains the C functions that implement mutexes for OS/2\n*/\n\n/*\n** The code in this file is only used if SQLITE_MUTEX_OS2 is defined.\n** See the mutex.h file for details.\n*/\n#ifdef SQLITE_MUTEX_OS2\n\n/********************** OS/2 Mutex Implementation **********************\n**\n** This implementation of mutexes is built using the OS/2 API.\n*/\n\n/*\n** The mutex object\n** Each recursive mutex is an instance of the following structure.\n*/\nstruct sqlite3_mutex {\n  HMTX mutex;       /* Mutex controlling the lock */\n  int  id;          /* Mutex type */\n#ifdef SQLITE_DEBUG\n int   trace;       /* True to trace changes */\n#endif\n};\n\n#ifdef SQLITE_DEBUG\n#define SQLITE3_MUTEX_INITIALIZER { 0, 0, 0 }\n#else\n#define SQLITE3_MUTEX_INITIALIZER { 0, 0 }\n#endif\n\n/*\n** Initialize and deinitialize the mutex subsystem.\n*/\nstatic int os2MutexInit(void){ return SQLITE_OK; }\nstatic int os2MutexEnd(void){ return SQLITE_OK; }\n\n/*\n** The sqlite3_mutex_alloc() routine allocates a new\n** mutex and returns a pointer to it.  If it returns NULL\n** that means that a mutex could not be allocated. \n** SQLite will unwind its stack and return an error.  The argument\n** to sqlite3_mutex_alloc() is one of these integer constants:\n**\n** <ul>\n** <li>  SQLITE_MUTEX_FAST\n** <li>  SQLITE_MUTEX_RECURSIVE\n** <li>  SQLITE_MUTEX_STATIC_MASTER\n** <li>  SQLITE_MUTEX_STATIC_MEM\n** <li>  SQLITE_MUTEX_STATIC_MEM2\n** <li>  SQLITE_MUTEX_STATIC_PRNG\n** <li>  SQLITE_MUTEX_STATIC_LRU\n** <li>  SQLITE_MUTEX_STATIC_LRU2\n** </ul>\n**\n** The first two constants cause sqlite3_mutex_alloc() to create\n** a new mutex.  The new mutex is recursive when SQLITE_MUTEX_RECURSIVE\n** is used but not necessarily so when SQLITE_MUTEX_FAST is used.\n** The mutex implementation does not need to make a distinction\n** between SQLITE_MUTEX_RECURSIVE and SQLITE_MUTEX_FAST if it does\n** not want to.  But SQLite will only request a recursive mutex in\n** cases where it really needs one.  If a faster non-recursive mutex\n** implementation is available on the host platform, the mutex subsystem\n** might return such a mutex in response to SQLITE_MUTEX_FAST.\n**\n** The other allowed parameters to sqlite3_mutex_alloc() each return\n** a pointer to a static preexisting mutex.  Six static mutexes are\n** used by the current version of SQLite.  Future versions of SQLite\n** may add additional static mutexes.  Static mutexes are for internal\n** use by SQLite only.  Applications that use SQLite mutexes should\n** use only the dynamic mutexes returned by SQLITE_MUTEX_FAST or\n** SQLITE_MUTEX_RECURSIVE.\n**\n** Note that if one of the dynamic mutex parameters (SQLITE_MUTEX_FAST\n** or SQLITE_MUTEX_RECURSIVE) is used then sqlite3_mutex_alloc()\n** returns a different mutex on every call.  But for the static\n** mutex types, the same mutex is returned on every call that has\n** the same type number.\n*/\nstatic sqlite3_mutex *os2MutexAlloc(int iType){\n  sqlite3_mutex *p = NULL;\n  switch( iType ){\n    case SQLITE_MUTEX_FAST:\n    case SQLITE_MUTEX_RECURSIVE: {\n      p = sqlite3MallocZero( sizeof(*p) );\n      if( p ){\n        p->id = iType;\n        if( DosCreateMutexSem( 0, &p->mutex, 0, FALSE ) != NO_ERROR ){\n          sqlite3_free( p );\n          p = NULL;\n        }\n      }\n      break;\n    }\n    default: {\n      static volatile int isInit = 0;\n      static sqlite3_mutex staticMutexes[6] = {\n        SQLITE3_MUTEX_INITIALIZER,\n        SQLITE3_MUTEX_INITIALIZER,\n        SQLITE3_MUTEX_INITIALIZER,\n        SQLITE3_MUTEX_INITIALIZER,\n        SQLITE3_MUTEX_INITIALIZER,\n        SQLITE3_MUTEX_INITIALIZER,\n      };\n      if ( !isInit ){\n        APIRET rc;\n        PTIB ptib;\n        PPIB ppib;\n        HMTX mutex;\n        char name[32];\n        DosGetInfoBlocks( &ptib, &ppib );\n        sqlite3_snprintf( sizeof(name), name, \"\\\\SEM32\\\\SQLITE%04x\",\n                          ppib->pib_ulpid );\n        while( !isInit ){\n          mutex = 0;\n          rc = DosCreateMutexSem( name, &mutex, 0, FALSE);\n          if( rc == NO_ERROR ){\n            unsigned int i;\n            if( !isInit ){\n              for( i = 0; i < sizeof(staticMutexes)/sizeof(staticMutexes[0]); i++ ){\n                DosCreateMutexSem( 0, &staticMutexes[i].mutex, 0, FALSE );\n              }\n              isInit = 1;\n            }\n            DosCloseMutexSem( mutex );\n          }else if( rc == ERROR_DUPLICATE_NAME ){\n            DosSleep( 1 );\n          }else{\n            return p;\n          }\n        }\n      }\n      assert( iType-2 >= 0 );\n      assert( iType-2 < sizeof(staticMutexes)/sizeof(staticMutexes[0]) );\n      p = &staticMutexes[iType-2];\n      p->id = iType;\n      break;\n    }\n  }\n  return p;\n}\n\n\n/*\n** This routine deallocates a previously allocated mutex.\n** SQLite is careful to deallocate every mutex that it allocates.\n*/\nstatic void os2MutexFree(sqlite3_mutex *p){\n#ifdef SQLITE_DEBUG\n  TID tid;\n  PID pid;\n  ULONG ulCount;\n  DosQueryMutexSem(p->mutex, &pid, &tid, &ulCount);\n  assert( ulCount==0 );\n  assert( p->id==SQLITE_MUTEX_FAST || p->id==SQLITE_MUTEX_RECURSIVE );\n#endif\n  DosCloseMutexSem( p->mutex );\n  sqlite3_free( p );\n}\n\n#ifdef SQLITE_DEBUG\n/*\n** The sqlite3_mutex_held() and sqlite3_mutex_notheld() routine are\n** intended for use inside assert() statements.\n*/\nstatic int os2MutexHeld(sqlite3_mutex *p){\n  TID tid;\n  PID pid;\n  ULONG ulCount;\n  PTIB ptib;\n  DosQueryMutexSem(p->mutex, &pid, &tid, &ulCount);\n  if( ulCount==0 || ( ulCount>1 && p->id!=SQLITE_MUTEX_RECURSIVE ) )\n    return 0;\n  DosGetInfoBlocks(&ptib, NULL);\n  return tid==ptib->tib_ptib2->tib2_ultid;\n}\nstatic int os2MutexNotheld(sqlite3_mutex *p){\n  TID tid;\n  PID pid;\n  ULONG ulCount;\n  PTIB ptib;\n  DosQueryMutexSem(p->mutex, &pid, &tid, &ulCount);\n  if( ulCount==0 )\n    return 1;\n  DosGetInfoBlocks(&ptib, NULL);\n  return tid!=ptib->tib_ptib2->tib2_ultid;\n}\nstatic void os2MutexTrace(sqlite3_mutex *p, char *pAction){\n  TID   tid;\n  PID   pid;\n  ULONG ulCount;\n  DosQueryMutexSem(p->mutex, &pid, &tid, &ulCount);\n  printf(\"%s mutex %p (%d) with nRef=%ld\\n\", pAction, (void*)p, p->trace, ulCount);\n}\n#endif\n\n/*\n** The sqlite3_mutex_enter() and sqlite3_mutex_try() routines attempt\n** to enter a mutex.  If another thread is already within the mutex,\n** sqlite3_mutex_enter() will block and sqlite3_mutex_try() will return\n** SQLITE_BUSY.  The sqlite3_mutex_try() interface returns SQLITE_OK\n** upon successful entry.  Mutexes created using SQLITE_MUTEX_RECURSIVE can\n** be entered multiple times by the same thread.  In such cases the,\n** mutex must be exited an equal number of times before another thread\n** can enter.  If the same thread tries to enter any other kind of mutex\n** more than once, the behavior is undefined.\n*/\nstatic void os2MutexEnter(sqlite3_mutex *p){\n  assert( p->id==SQLITE_MUTEX_RECURSIVE || os2MutexNotheld(p) );\n  DosRequestMutexSem(p->mutex, SEM_INDEFINITE_WAIT);\n#ifdef SQLITE_DEBUG\n  if( p->trace ) os2MutexTrace(p, \"enter\");\n#endif\n}\nstatic int os2MutexTry(sqlite3_mutex *p){\n  int rc = SQLITE_BUSY;\n  assert( p->id==SQLITE_MUTEX_RECURSIVE || os2MutexNotheld(p) );\n  if( DosRequestMutexSem(p->mutex, SEM_IMMEDIATE_RETURN) == NO_ERROR ) {\n    rc = SQLITE_OK;\n#ifdef SQLITE_DEBUG\n    if( p->trace ) os2MutexTrace(p, \"try\");\n#endif\n  }\n  return rc;\n}\n\n/*\n** The sqlite3_mutex_leave() routine exits a mutex that was\n** previously entered by the same thread.  The behavior\n** is undefined if the mutex is not currently entered or\n** is not currently allocated.  SQLite will never do either.\n*/\nstatic void os2MutexLeave(sqlite3_mutex *p){\n  assert( os2MutexHeld(p) );\n  DosReleaseMutexSem(p->mutex);\n#ifdef SQLITE_DEBUG\n  if( p->trace ) os2MutexTrace(p, \"leave\");\n#endif\n}\n\nSQLITE_PRIVATE SQLITE_PRIVATE sqlite3_mutex_methods const *sqlite3DefaultMutex(void){\n  static const sqlite3_mutex_methods sMutex = {\n    os2MutexInit,\n    os2MutexEnd,\n    os2MutexAlloc,\n    os2MutexFree,\n    os2MutexEnter,\n    os2MutexTry,\n    os2MutexLeave,\n#ifdef SQLITE_DEBUG\n    os2MutexHeld,\n    os2MutexNotheld\n#else\n    0,\n    0\n#endif\n  };\n\n  return &sMutex;\n}\n#endif /* SQLITE_MUTEX_OS2 */\n\n/************** End of mutex_os2.c *******************************************/\n/************** Begin file mutex_unix.c **************************************/\n/*\n** 2007 August 28\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains the C functions that implement mutexes for pthreads\n*/\n\n/*\n** The code in this file is only used if we are compiling threadsafe\n** under unix with pthreads.\n**\n** Note that this implementation requires a version of pthreads that\n** supports recursive mutexes.\n*/\n#ifdef SQLITE_MUTEX_PTHREADS\n\n#include <pthread.h>\n\n/*\n** The sqlite3_mutex.id, sqlite3_mutex.nRef, and sqlite3_mutex.owner fields\n** are necessary under two condidtions:  (1) Debug builds and (2) using\n** home-grown mutexes.  Encapsulate these conditions into a single #define.\n*/\n#if defined(SQLITE_DEBUG) || defined(SQLITE_HOMEGROWN_RECURSIVE_MUTEX)\n# define SQLITE_MUTEX_NREF 1\n#else\n# define SQLITE_MUTEX_NREF 0\n#endif\n\n/*\n** Each recursive mutex is an instance of the following structure.\n*/\nstruct sqlite3_mutex {\n  pthread_mutex_t mutex;     /* Mutex controlling the lock */\n#if SQLITE_MUTEX_NREF\n  int id;                    /* Mutex type */\n  volatile int nRef;         /* Number of entrances */\n  volatile pthread_t owner;  /* Thread that is within this mutex */\n  int trace;                 /* True to trace changes */\n#endif\n};\n#if SQLITE_MUTEX_NREF\n#define SQLITE3_MUTEX_INITIALIZER { PTHREAD_MUTEX_INITIALIZER, 0, 0, (pthread_t)0, 0 }\n#else\n#define SQLITE3_MUTEX_INITIALIZER { PTHREAD_MUTEX_INITIALIZER }\n#endif\n\n/*\n** The sqlite3_mutex_held() and sqlite3_mutex_notheld() routine are\n** intended for use only inside assert() statements.  On some platforms,\n** there might be race conditions that can cause these routines to\n** deliver incorrect results.  In particular, if pthread_equal() is\n** not an atomic operation, then these routines might delivery\n** incorrect results.  On most platforms, pthread_equal() is a \n** comparison of two integers and is therefore atomic.  But we are\n** told that HPUX is not such a platform.  If so, then these routines\n** will not always work correctly on HPUX.\n**\n** On those platforms where pthread_equal() is not atomic, SQLite\n** should be compiled without -DSQLITE_DEBUG and with -DNDEBUG to\n** make sure no assert() statements are evaluated and hence these\n** routines are never called.\n*/\n#if !defined(NDEBUG) || defined(SQLITE_DEBUG)\nstatic int pthreadMutexHeld(sqlite3_mutex *p){\n  return (p->nRef!=0 && pthread_equal(p->owner, pthread_self()));\n}\nstatic int pthreadMutexNotheld(sqlite3_mutex *p){\n  return p->nRef==0 || pthread_equal(p->owner, pthread_self())==0;\n}\n#endif\n\n/*\n** Initialize and deinitialize the mutex subsystem.\n*/\nstatic int pthreadMutexInit(void){ return SQLITE_OK; }\nstatic int pthreadMutexEnd(void){ return SQLITE_OK; }\n\n/*\n** The sqlite3_mutex_alloc() routine allocates a new\n** mutex and returns a pointer to it.  If it returns NULL\n** that means that a mutex could not be allocated.  SQLite\n** will unwind its stack and return an error.  The argument\n** to sqlite3_mutex_alloc() is one of these integer constants:\n**\n** <ul>\n** <li>  SQLITE_MUTEX_FAST\n** <li>  SQLITE_MUTEX_RECURSIVE\n** <li>  SQLITE_MUTEX_STATIC_MASTER\n** <li>  SQLITE_MUTEX_STATIC_MEM\n** <li>  SQLITE_MUTEX_STATIC_MEM2\n** <li>  SQLITE_MUTEX_STATIC_PRNG\n** <li>  SQLITE_MUTEX_STATIC_LRU\n** <li>  SQLITE_MUTEX_STATIC_PMEM\n** </ul>\n**\n** The first two constants cause sqlite3_mutex_alloc() to create\n** a new mutex.  The new mutex is recursive when SQLITE_MUTEX_RECURSIVE\n** is used but not necessarily so when SQLITE_MUTEX_FAST is used.\n** The mutex implementation does not need to make a distinction\n** between SQLITE_MUTEX_RECURSIVE and SQLITE_MUTEX_FAST if it does\n** not want to.  But SQLite will only request a recursive mutex in\n** cases where it really needs one.  If a faster non-recursive mutex\n** implementation is available on the host platform, the mutex subsystem\n** might return such a mutex in response to SQLITE_MUTEX_FAST.\n**\n** The other allowed parameters to sqlite3_mutex_alloc() each return\n** a pointer to a static preexisting mutex.  Six static mutexes are\n** used by the current version of SQLite.  Future versions of SQLite\n** may add additional static mutexes.  Static mutexes are for internal\n** use by SQLite only.  Applications that use SQLite mutexes should\n** use only the dynamic mutexes returned by SQLITE_MUTEX_FAST or\n** SQLITE_MUTEX_RECURSIVE.\n**\n** Note that if one of the dynamic mutex parameters (SQLITE_MUTEX_FAST\n** or SQLITE_MUTEX_RECURSIVE) is used then sqlite3_mutex_alloc()\n** returns a different mutex on every call.  But for the static \n** mutex types, the same mutex is returned on every call that has\n** the same type number.\n*/\nstatic sqlite3_mutex *pthreadMutexAlloc(int iType){\n  static sqlite3_mutex staticMutexes[] = {\n    SQLITE3_MUTEX_INITIALIZER,\n    SQLITE3_MUTEX_INITIALIZER,\n    SQLITE3_MUTEX_INITIALIZER,\n    SQLITE3_MUTEX_INITIALIZER,\n    SQLITE3_MUTEX_INITIALIZER,\n    SQLITE3_MUTEX_INITIALIZER\n  };\n  sqlite3_mutex *p;\n  switch( iType ){\n    case SQLITE_MUTEX_RECURSIVE: {\n      p = sqlite3MallocZero( sizeof(*p) );\n      if( p ){\n#ifdef SQLITE_HOMEGROWN_RECURSIVE_MUTEX\n        /* If recursive mutexes are not available, we will have to\n        ** build our own.  See below. */\n        pthread_mutex_init(&p->mutex, 0);\n#else\n        /* Use a recursive mutex if it is available */\n        pthread_mutexattr_t recursiveAttr;\n        pthread_mutexattr_init(&recursiveAttr);\n        pthread_mutexattr_settype(&recursiveAttr, PTHREAD_MUTEX_RECURSIVE);\n        pthread_mutex_init(&p->mutex, &recursiveAttr);\n        pthread_mutexattr_destroy(&recursiveAttr);\n#endif\n#if SQLITE_MUTEX_NREF\n        p->id = iType;\n#endif\n      }\n      break;\n    }\n    case SQLITE_MUTEX_FAST: {\n      p = sqlite3MallocZero( sizeof(*p) );\n      if( p ){\n#if SQLITE_MUTEX_NREF\n        p->id = iType;\n#endif\n        pthread_mutex_init(&p->mutex, 0);\n      }\n      break;\n    }\n    default: {\n      assert( iType-2 >= 0 );\n      assert( iType-2 < ArraySize(staticMutexes) );\n      p = &staticMutexes[iType-2];\n#if SQLITE_MUTEX_NREF\n      p->id = iType;\n#endif\n      break;\n    }\n  }\n  return p;\n}\n\n\n/*\n** This routine deallocates a previously\n** allocated mutex.  SQLite is careful to deallocate every\n** mutex that it allocates.\n*/\nstatic void pthreadMutexFree(sqlite3_mutex *p){\n  assert( p->nRef==0 );\n  assert( p->id==SQLITE_MUTEX_FAST || p->id==SQLITE_MUTEX_RECURSIVE );\n  pthread_mutex_destroy(&p->mutex);\n  sqlite3_free(p);\n}\n\n/*\n** The sqlite3_mutex_enter() and sqlite3_mutex_try() routines attempt\n** to enter a mutex.  If another thread is already within the mutex,\n** sqlite3_mutex_enter() will block and sqlite3_mutex_try() will return\n** SQLITE_BUSY.  The sqlite3_mutex_try() interface returns SQLITE_OK\n** upon successful entry.  Mutexes created using SQLITE_MUTEX_RECURSIVE can\n** be entered multiple times by the same thread.  In such cases the,\n** mutex must be exited an equal number of times before another thread\n** can enter.  If the same thread tries to enter any other kind of mutex\n** more than once, the behavior is undefined.\n*/\nstatic void pthreadMutexEnter(sqlite3_mutex *p){\n  assert( p->id==SQLITE_MUTEX_RECURSIVE || pthreadMutexNotheld(p) );\n\n#ifdef SQLITE_HOMEGROWN_RECURSIVE_MUTEX\n  /* If recursive mutexes are not available, then we have to grow\n  ** our own.  This implementation assumes that pthread_equal()\n  ** is atomic - that it cannot be deceived into thinking self\n  ** and p->owner are equal if p->owner changes between two values\n  ** that are not equal to self while the comparison is taking place.\n  ** This implementation also assumes a coherent cache - that \n  ** separate processes cannot read different values from the same\n  ** address at the same time.  If either of these two conditions\n  ** are not met, then the mutexes will fail and problems will result.\n  */\n  {\n    pthread_t self = pthread_self();\n    if( p->nRef>0 && pthread_equal(p->owner, self) ){\n      p->nRef++;\n    }else{\n      pthread_mutex_lock(&p->mutex);\n      assert( p->nRef==0 );\n      p->owner = self;\n      p->nRef = 1;\n    }\n  }\n#else\n  /* Use the built-in recursive mutexes if they are available.\n  */\n  pthread_mutex_lock(&p->mutex);\n#if SQLITE_MUTEX_NREF\n  assert( p->nRef>0 || p->owner==0 );\n  p->owner = pthread_self();\n  p->nRef++;\n#endif\n#endif\n\n#ifdef SQLITE_DEBUG\n  if( p->trace ){\n    printf(\"enter mutex %p (%d) with nRef=%d\\n\", p, p->trace, p->nRef);\n  }\n#endif\n}\nstatic int pthreadMutexTry(sqlite3_mutex *p){\n  int rc;\n  assert( p->id==SQLITE_MUTEX_RECURSIVE || pthreadMutexNotheld(p) );\n\n#ifdef SQLITE_HOMEGROWN_RECURSIVE_MUTEX\n  /* If recursive mutexes are not available, then we have to grow\n  ** our own.  This implementation assumes that pthread_equal()\n  ** is atomic - that it cannot be deceived into thinking self\n  ** and p->owner are equal if p->owner changes between two values\n  ** that are not equal to self while the comparison is taking place.\n  ** This implementation also assumes a coherent cache - that \n  ** separate processes cannot read different values from the same\n  ** address at the same time.  If either of these two conditions\n  ** are not met, then the mutexes will fail and problems will result.\n  */\n  {\n    pthread_t self = pthread_self();\n    if( p->nRef>0 && pthread_equal(p->owner, self) ){\n      p->nRef++;\n      rc = SQLITE_OK;\n    }else if( pthread_mutex_trylock(&p->mutex)==0 ){\n      assert( p->nRef==0 );\n      p->owner = self;\n      p->nRef = 1;\n      rc = SQLITE_OK;\n    }else{\n      rc = SQLITE_BUSY;\n    }\n  }\n#else\n  /* Use the built-in recursive mutexes if they are available.\n  */\n  if( pthread_mutex_trylock(&p->mutex)==0 ){\n#if SQLITE_MUTEX_NREF\n    p->owner = pthread_self();\n    p->nRef++;\n#endif\n    rc = SQLITE_OK;\n  }else{\n    rc = SQLITE_BUSY;\n  }\n#endif\n\n#ifdef SQLITE_DEBUG\n  if( rc==SQLITE_OK && p->trace ){\n    printf(\"enter mutex %p (%d) with nRef=%d\\n\", p, p->trace, p->nRef);\n  }\n#endif\n  return rc;\n}\n\n/*\n** The sqlite3_mutex_leave() routine exits a mutex that was\n** previously entered by the same thread.  The behavior\n** is undefined if the mutex is not currently entered or\n** is not currently allocated.  SQLite will never do either.\n*/\nstatic void pthreadMutexLeave(sqlite3_mutex *p){\n  assert( pthreadMutexHeld(p) );\n#if SQLITE_MUTEX_NREF\n  p->nRef--;\n  if( p->nRef==0 ) p->owner = 0;\n#endif\n  assert( p->nRef==0 || p->id==SQLITE_MUTEX_RECURSIVE );\n\n#ifdef SQLITE_HOMEGROWN_RECURSIVE_MUTEX\n  if( p->nRef==0 ){\n    pthread_mutex_unlock(&p->mutex);\n  }\n#else\n  pthread_mutex_unlock(&p->mutex);\n#endif\n\n#ifdef SQLITE_DEBUG\n  if( p->trace ){\n    printf(\"leave mutex %p (%d) with nRef=%d\\n\", p, p->trace, p->nRef);\n  }\n#endif\n}\n\nSQLITE_PRIVATE sqlite3_mutex_methods const *sqlite3DefaultMutex(void){\n  static const sqlite3_mutex_methods sMutex = {\n    pthreadMutexInit,\n    pthreadMutexEnd,\n    pthreadMutexAlloc,\n    pthreadMutexFree,\n    pthreadMutexEnter,\n    pthreadMutexTry,\n    pthreadMutexLeave,\n#ifdef SQLITE_DEBUG\n    pthreadMutexHeld,\n    pthreadMutexNotheld\n#else\n    0,\n    0\n#endif\n  };\n\n  return &sMutex;\n}\n\n#endif /* SQLITE_MUTEX_PTHREAD */\n\n/************** End of mutex_unix.c ******************************************/\n/************** Begin file mutex_w32.c ***************************************/\n/*\n** 2007 August 14\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains the C functions that implement mutexes for win32\n*/\n\n/*\n** The code in this file is only used if we are compiling multithreaded\n** on a win32 system.\n*/\n#ifdef SQLITE_MUTEX_W32\n\n/*\n** Each recursive mutex is an instance of the following structure.\n*/\nstruct sqlite3_mutex {\n  CRITICAL_SECTION mutex;    /* Mutex controlling the lock */\n  int id;                    /* Mutex type */\n#ifdef SQLITE_DEBUG\n  volatile int nRef;         /* Number of enterances */\n  volatile DWORD owner;      /* Thread holding this mutex */\n  int trace;                 /* True to trace changes */\n#endif\n};\n#define SQLITE_W32_MUTEX_INITIALIZER { 0 }\n#ifdef SQLITE_DEBUG\n#define SQLITE3_MUTEX_INITIALIZER { SQLITE_W32_MUTEX_INITIALIZER, 0, 0L, (DWORD)0, 0 }\n#else\n#define SQLITE3_MUTEX_INITIALIZER { SQLITE_W32_MUTEX_INITIALIZER, 0 }\n#endif\n\n/*\n** Return true (non-zero) if we are running under WinNT, Win2K, WinXP,\n** or WinCE.  Return false (zero) for Win95, Win98, or WinME.\n**\n** Here is an interesting observation:  Win95, Win98, and WinME lack\n** the LockFileEx() API.  But we can still statically link against that\n** API as long as we don't call it win running Win95/98/ME.  A call to\n** this routine is used to determine if the host is Win95/98/ME or\n** WinNT/2K/XP so that we will know whether or not we can safely call\n** the LockFileEx() API.\n**\n** mutexIsNT() is only used for the TryEnterCriticalSection() API call,\n** which is only available if your application was compiled with \n** _WIN32_WINNT defined to a value >= 0x0400.  Currently, the only\n** call to TryEnterCriticalSection() is #ifdef'ed out, so #ifdef \n** this out as well.\n*/\n#if 0\n#if SQLITE_OS_WINCE\n# define mutexIsNT()  (1)\n#else\n  static int mutexIsNT(void){\n    static int osType = 0;\n    if( osType==0 ){\n      OSVERSIONINFO sInfo;\n      sInfo.dwOSVersionInfoSize = sizeof(sInfo);\n      GetVersionEx(&sInfo);\n      osType = sInfo.dwPlatformId==VER_PLATFORM_WIN32_NT ? 2 : 1;\n    }\n    return osType==2;\n  }\n#endif /* SQLITE_OS_WINCE */\n#endif\n\n#ifdef SQLITE_DEBUG\n/*\n** The sqlite3_mutex_held() and sqlite3_mutex_notheld() routine are\n** intended for use only inside assert() statements.\n*/\nstatic int winMutexHeld(sqlite3_mutex *p){\n  return p->nRef!=0 && p->owner==GetCurrentThreadId();\n}\nstatic int winMutexNotheld2(sqlite3_mutex *p, DWORD tid){\n  return p->nRef==0 || p->owner!=tid;\n}\nstatic int winMutexNotheld(sqlite3_mutex *p){\n  DWORD tid = GetCurrentThreadId(); \n  return winMutexNotheld2(p, tid);\n}\n#endif\n\n\n/*\n** Initialize and deinitialize the mutex subsystem.\n*/\nstatic sqlite3_mutex winMutex_staticMutexes[6] = {\n  SQLITE3_MUTEX_INITIALIZER,\n  SQLITE3_MUTEX_INITIALIZER,\n  SQLITE3_MUTEX_INITIALIZER,\n  SQLITE3_MUTEX_INITIALIZER,\n  SQLITE3_MUTEX_INITIALIZER,\n  SQLITE3_MUTEX_INITIALIZER\n};\nstatic int winMutex_isInit = 0;\n/* As winMutexInit() and winMutexEnd() are called as part\n** of the sqlite3_initialize and sqlite3_shutdown()\n** processing, the \"interlocked\" magic is probably not\n** strictly necessary.\n*/\nstatic long winMutex_lock = 0;\n\nstatic int winMutexInit(void){ \n  /* The first to increment to 1 does actual initialization */\n  if( InterlockedCompareExchange(&winMutex_lock, 1, 0)==0 ){\n    int i;\n    for(i=0; i<ArraySize(winMutex_staticMutexes); i++){\n      InitializeCriticalSection(&winMutex_staticMutexes[i].mutex);\n    }\n    winMutex_isInit = 1;\n  }else{\n    /* Someone else is in the process of initing the static mutexes */\n    while( !winMutex_isInit ){\n      Sleep(1);\n    }\n  }\n  return SQLITE_OK; \n}\n\nstatic int winMutexEnd(void){ \n  /* The first to decrement to 0 does actual shutdown \n  ** (which should be the last to shutdown.) */\n  if( InterlockedCompareExchange(&winMutex_lock, 0, 1)==1 ){\n    if( winMutex_isInit==1 ){\n      int i;\n      for(i=0; i<ArraySize(winMutex_staticMutexes); i++){\n        DeleteCriticalSection(&winMutex_staticMutexes[i].mutex);\n      }\n      winMutex_isInit = 0;\n    }\n  }\n  return SQLITE_OK; \n}\n\n/*\n** The sqlite3_mutex_alloc() routine allocates a new\n** mutex and returns a pointer to it.  If it returns NULL\n** that means that a mutex could not be allocated.  SQLite\n** will unwind its stack and return an error.  The argument\n** to sqlite3_mutex_alloc() is one of these integer constants:\n**\n** <ul>\n** <li>  SQLITE_MUTEX_FAST\n** <li>  SQLITE_MUTEX_RECURSIVE\n** <li>  SQLITE_MUTEX_STATIC_MASTER\n** <li>  SQLITE_MUTEX_STATIC_MEM\n** <li>  SQLITE_MUTEX_STATIC_MEM2\n** <li>  SQLITE_MUTEX_STATIC_PRNG\n** <li>  SQLITE_MUTEX_STATIC_LRU\n** <li>  SQLITE_MUTEX_STATIC_PMEM\n** </ul>\n**\n** The first two constants cause sqlite3_mutex_alloc() to create\n** a new mutex.  The new mutex is recursive when SQLITE_MUTEX_RECURSIVE\n** is used but not necessarily so when SQLITE_MUTEX_FAST is used.\n** The mutex implementation does not need to make a distinction\n** between SQLITE_MUTEX_RECURSIVE and SQLITE_MUTEX_FAST if it does\n** not want to.  But SQLite will only request a recursive mutex in\n** cases where it really needs one.  If a faster non-recursive mutex\n** implementation is available on the host platform, the mutex subsystem\n** might return such a mutex in response to SQLITE_MUTEX_FAST.\n**\n** The other allowed parameters to sqlite3_mutex_alloc() each return\n** a pointer to a static preexisting mutex.  Six static mutexes are\n** used by the current version of SQLite.  Future versions of SQLite\n** may add additional static mutexes.  Static mutexes are for internal\n** use by SQLite only.  Applications that use SQLite mutexes should\n** use only the dynamic mutexes returned by SQLITE_MUTEX_FAST or\n** SQLITE_MUTEX_RECURSIVE.\n**\n** Note that if one of the dynamic mutex parameters (SQLITE_MUTEX_FAST\n** or SQLITE_MUTEX_RECURSIVE) is used then sqlite3_mutex_alloc()\n** returns a different mutex on every call.  But for the static \n** mutex types, the same mutex is returned on every call that has\n** the same type number.\n*/\nstatic sqlite3_mutex *winMutexAlloc(int iType){\n  sqlite3_mutex *p;\n\n  switch( iType ){\n    case SQLITE_MUTEX_FAST:\n    case SQLITE_MUTEX_RECURSIVE: {\n      p = sqlite3MallocZero( sizeof(*p) );\n      if( p ){  \n#ifdef SQLITE_DEBUG\n        p->id = iType;\n#endif\n        InitializeCriticalSection(&p->mutex);\n      }\n      break;\n    }\n    default: {\n      assert( winMutex_isInit==1 );\n      assert( iType-2 >= 0 );\n      assert( iType-2 < ArraySize(winMutex_staticMutexes) );\n      p = &winMutex_staticMutexes[iType-2];\n#ifdef SQLITE_DEBUG\n      p->id = iType;\n#endif\n      break;\n    }\n  }\n  return p;\n}\n\n\n/*\n** This routine deallocates a previously\n** allocated mutex.  SQLite is careful to deallocate every\n** mutex that it allocates.\n*/\nstatic void winMutexFree(sqlite3_mutex *p){\n  assert( p );\n  assert( p->nRef==0 && p->owner==0 );\n  assert( p->id==SQLITE_MUTEX_FAST || p->id==SQLITE_MUTEX_RECURSIVE );\n  DeleteCriticalSection(&p->mutex);\n  sqlite3_free(p);\n}\n\n/*\n** The sqlite3_mutex_enter() and sqlite3_mutex_try() routines attempt\n** to enter a mutex.  If another thread is already within the mutex,\n** sqlite3_mutex_enter() will block and sqlite3_mutex_try() will return\n** SQLITE_BUSY.  The sqlite3_mutex_try() interface returns SQLITE_OK\n** upon successful entry.  Mutexes created using SQLITE_MUTEX_RECURSIVE can\n** be entered multiple times by the same thread.  In such cases the,\n** mutex must be exited an equal number of times before another thread\n** can enter.  If the same thread tries to enter any other kind of mutex\n** more than once, the behavior is undefined.\n*/\nstatic void winMutexEnter(sqlite3_mutex *p){\n#ifdef SQLITE_DEBUG\n  DWORD tid = GetCurrentThreadId(); \n  assert( p->id==SQLITE_MUTEX_RECURSIVE || winMutexNotheld2(p, tid) );\n#endif\n  EnterCriticalSection(&p->mutex);\n#ifdef SQLITE_DEBUG\n  assert( p->nRef>0 || p->owner==0 );\n  p->owner = tid; \n  p->nRef++;\n  if( p->trace ){\n    printf(\"enter mutex %p (%d) with nRef=%d\\n\", p, p->trace, p->nRef);\n  }\n#endif\n}\nstatic int winMutexTry(sqlite3_mutex *p){\n#ifndef NDEBUG\n  DWORD tid = GetCurrentThreadId(); \n#endif\n  int rc = SQLITE_BUSY;\n  assert( p->id==SQLITE_MUTEX_RECURSIVE || winMutexNotheld2(p, tid) );\n  /*\n  ** The sqlite3_mutex_try() routine is very rarely used, and when it\n  ** is used it is merely an optimization.  So it is OK for it to always\n  ** fail.  \n  **\n  ** The TryEnterCriticalSection() interface is only available on WinNT.\n  ** And some windows compilers complain if you try to use it without\n  ** first doing some #defines that prevent SQLite from building on Win98.\n  ** For that reason, we will omit this optimization for now.  See\n  ** ticket #2685.\n  */\n#if 0\n  if( mutexIsNT() && TryEnterCriticalSection(&p->mutex) ){\n    p->owner = tid;\n    p->nRef++;\n    rc = SQLITE_OK;\n  }\n#else\n  UNUSED_PARAMETER(p);\n#endif\n#ifdef SQLITE_DEBUG\n  if( rc==SQLITE_OK && p->trace ){\n    printf(\"try mutex %p (%d) with nRef=%d\\n\", p, p->trace, p->nRef);\n  }\n#endif\n  return rc;\n}\n\n/*\n** The sqlite3_mutex_leave() routine exits a mutex that was\n** previously entered by the same thread.  The behavior\n** is undefined if the mutex is not currently entered or\n** is not currently allocated.  SQLite will never do either.\n*/\nstatic void winMutexLeave(sqlite3_mutex *p){\n#ifndef NDEBUG\n  DWORD tid = GetCurrentThreadId();\n  assert( p->nRef>0 );\n  assert( p->owner==tid );\n  p->nRef--;\n  if( p->nRef==0 ) p->owner = 0;\n  assert( p->nRef==0 || p->id==SQLITE_MUTEX_RECURSIVE );\n#endif\n  LeaveCriticalSection(&p->mutex);\n#ifdef SQLITE_DEBUG\n  if( p->trace ){\n    printf(\"leave mutex %p (%d) with nRef=%d\\n\", p, p->trace, p->nRef);\n  }\n#endif\n}\n\nSQLITE_PRIVATE sqlite3_mutex_methods const *sqlite3DefaultMutex(void){\n  static const sqlite3_mutex_methods sMutex = {\n    winMutexInit,\n    winMutexEnd,\n    winMutexAlloc,\n    winMutexFree,\n    winMutexEnter,\n    winMutexTry,\n    winMutexLeave,\n#ifdef SQLITE_DEBUG\n    winMutexHeld,\n    winMutexNotheld\n#else\n    0,\n    0\n#endif\n  };\n\n  return &sMutex;\n}\n#endif /* SQLITE_MUTEX_W32 */\n\n/************** End of mutex_w32.c *******************************************/\n/************** Begin file malloc.c ******************************************/\n/*\n** 2001 September 15\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n**\n** Memory allocation functions used throughout sqlite.\n*/\n\n/*\n** Attempt to release up to n bytes of non-essential memory currently\n** held by SQLite. An example of non-essential memory is memory used to\n** cache database pages that are not currently in use.\n*/\nSQLITE_API int sqlite3_release_memory(int n){\n#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT\n  return sqlite3PcacheReleaseMemory(n);\n#else\n  /* IMPLEMENTATION-OF: R-34391-24921 The sqlite3_release_memory() routine\n  ** is a no-op returning zero if SQLite is not compiled with\n  ** SQLITE_ENABLE_MEMORY_MANAGEMENT. */\n  UNUSED_PARAMETER(n);\n  return 0;\n#endif\n}\n\n/*\n** An instance of the following object records the location of\n** each unused scratch buffer.\n*/\ntypedef struct ScratchFreeslot {\n  struct ScratchFreeslot *pNext;   /* Next unused scratch buffer */\n} ScratchFreeslot;\n\n/*\n** State information local to the memory allocation subsystem.\n*/\nstatic SQLITE_WSD struct Mem0Global {\n  sqlite3_mutex *mutex;         /* Mutex to serialize access */\n\n  /*\n  ** The alarm callback and its arguments.  The mem0.mutex lock will\n  ** be held while the callback is running.  Recursive calls into\n  ** the memory subsystem are allowed, but no new callbacks will be\n  ** issued.\n  */\n  sqlite3_int64 alarmThreshold;\n  void (*alarmCallback)(void*, sqlite3_int64,int);\n  void *alarmArg;\n\n  /*\n  ** Pointers to the end of sqlite3GlobalConfig.pScratch memory\n  ** (so that a range test can be used to determine if an allocation\n  ** being freed came from pScratch) and a pointer to the list of\n  ** unused scratch allocations.\n  */\n  void *pScratchEnd;\n  ScratchFreeslot *pScratchFree;\n  u32 nScratchFree;\n\n  /*\n  ** True if heap is nearly \"full\" where \"full\" is defined by the\n  ** sqlite3_soft_heap_limit() setting.\n  */\n  int nearlyFull;\n} mem0 = { 0, 0, 0, 0, 0, 0, 0, 0 };\n\n#define mem0 GLOBAL(struct Mem0Global, mem0)\n\n/*\n** This routine runs when the memory allocator sees that the\n** total memory allocation is about to exceed the soft heap\n** limit.\n*/\nstatic void softHeapLimitEnforcer(\n  void *NotUsed, \n  sqlite3_int64 NotUsed2,\n  int allocSize\n){\n  UNUSED_PARAMETER2(NotUsed, NotUsed2);\n  sqlite3_release_memory(allocSize);\n}\n\n/*\n** Change the alarm callback\n*/\nstatic int sqlite3MemoryAlarm(\n  void(*xCallback)(void *pArg, sqlite3_int64 used,int N),\n  void *pArg,\n  sqlite3_int64 iThreshold\n){\n  int nUsed;\n  sqlite3_mutex_enter(mem0.mutex);\n  mem0.alarmCallback = xCallback;\n  mem0.alarmArg = pArg;\n  mem0.alarmThreshold = iThreshold;\n  nUsed = sqlite3StatusValue(SQLITE_STATUS_MEMORY_USED);\n  mem0.nearlyFull = (iThreshold>0 && iThreshold<=nUsed);\n  sqlite3_mutex_leave(mem0.mutex);\n  return SQLITE_OK;\n}\n\n#ifndef SQLITE_OMIT_DEPRECATED\n/*\n** Deprecated external interface.  Internal/core SQLite code\n** should call sqlite3MemoryAlarm.\n*/\nSQLITE_API int sqlite3_memory_alarm(\n  void(*xCallback)(void *pArg, sqlite3_int64 used,int N),\n  void *pArg,\n  sqlite3_int64 iThreshold\n){\n  return sqlite3MemoryAlarm(xCallback, pArg, iThreshold);\n}\n#endif\n\n/*\n** Set the soft heap-size limit for the library. Passing a zero or \n** negative value indicates no limit.\n*/\nSQLITE_API sqlite3_int64 sqlite3_soft_heap_limit64(sqlite3_int64 n){\n  sqlite3_int64 priorLimit;\n  sqlite3_int64 excess;\n#ifndef SQLITE_OMIT_AUTOINIT\n  sqlite3_initialize();\n#endif\n  sqlite3_mutex_enter(mem0.mutex);\n  priorLimit = mem0.alarmThreshold;\n  sqlite3_mutex_leave(mem0.mutex);\n  if( n<0 ) return priorLimit;\n  if( n>0 ){\n    sqlite3MemoryAlarm(softHeapLimitEnforcer, 0, n);\n  }else{\n    sqlite3MemoryAlarm(0, 0, 0);\n  }\n  excess = sqlite3_memory_used() - n;\n  if( excess>0 ) sqlite3_release_memory((int)(excess & 0x7fffffff));\n  return priorLimit;\n}\nSQLITE_API void sqlite3_soft_heap_limit(int n){\n  if( n<0 ) n = 0;\n  sqlite3_soft_heap_limit64(n);\n}\n\n/*\n** Initialize the memory allocation subsystem.\n*/\nSQLITE_PRIVATE int sqlite3MallocInit(void){\n  if( sqlite3GlobalConfig.m.xMalloc==0 ){\n    sqlite3MemSetDefault();\n  }\n  memset(&mem0, 0, sizeof(mem0));\n  if( sqlite3GlobalConfig.bCoreMutex ){\n    mem0.mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MEM);\n  }\n  if( sqlite3GlobalConfig.pScratch && sqlite3GlobalConfig.szScratch>=100\n      && sqlite3GlobalConfig.nScratch>0 ){\n    int i, n, sz;\n    ScratchFreeslot *pSlot;\n    sz = ROUNDDOWN8(sqlite3GlobalConfig.szScratch);\n    sqlite3GlobalConfig.szScratch = sz;\n    pSlot = (ScratchFreeslot*)sqlite3GlobalConfig.pScratch;\n    n = sqlite3GlobalConfig.nScratch;\n    mem0.pScratchFree = pSlot;\n    mem0.nScratchFree = n;\n    for(i=0; i<n-1; i++){\n      pSlot->pNext = (ScratchFreeslot*)(sz+(char*)pSlot);\n      pSlot = pSlot->pNext;\n    }\n    pSlot->pNext = 0;\n    mem0.pScratchEnd = (void*)&pSlot[1];\n  }else{\n    mem0.pScratchEnd = 0;\n    sqlite3GlobalConfig.pScratch = 0;\n    sqlite3GlobalConfig.szScratch = 0;\n    sqlite3GlobalConfig.nScratch = 0;\n  }\n  if( sqlite3GlobalConfig.pPage==0 || sqlite3GlobalConfig.szPage<512\n      || sqlite3GlobalConfig.nPage<1 ){\n    sqlite3GlobalConfig.pPage = 0;\n    sqlite3GlobalConfig.szPage = 0;\n    sqlite3GlobalConfig.nPage = 0;\n  }\n  return sqlite3GlobalConfig.m.xInit(sqlite3GlobalConfig.m.pAppData);\n}\n\n/*\n** Return true if the heap is currently under memory pressure - in other\n** words if the amount of heap used is close to the limit set by\n** sqlite3_soft_heap_limit().\n*/\nSQLITE_PRIVATE int sqlite3HeapNearlyFull(void){\n  return mem0.nearlyFull;\n}\n\n/*\n** Deinitialize the memory allocation subsystem.\n*/\nSQLITE_PRIVATE void sqlite3MallocEnd(void){\n  if( sqlite3GlobalConfig.m.xShutdown ){\n    sqlite3GlobalConfig.m.xShutdown(sqlite3GlobalConfig.m.pAppData);\n  }\n  memset(&mem0, 0, sizeof(mem0));\n}\n\n/*\n** Return the amount of memory currently checked out.\n*/\nSQLITE_API sqlite3_int64 sqlite3_memory_used(void){\n  int n, mx;\n  sqlite3_int64 res;\n  sqlite3_status(SQLITE_STATUS_MEMORY_USED, &n, &mx, 0);\n  res = (sqlite3_int64)n;  /* Work around bug in Borland C. Ticket #3216 */\n  return res;\n}\n\n/*\n** Return the maximum amount of memory that has ever been\n** checked out since either the beginning of this process\n** or since the most recent reset.\n*/\nSQLITE_API sqlite3_int64 sqlite3_memory_highwater(int resetFlag){\n  int n, mx;\n  sqlite3_int64 res;\n  sqlite3_status(SQLITE_STATUS_MEMORY_USED, &n, &mx, resetFlag);\n  res = (sqlite3_int64)mx;  /* Work around bug in Borland C. Ticket #3216 */\n  return res;\n}\n\n/*\n** Trigger the alarm \n*/\nstatic void sqlite3MallocAlarm(int nByte){\n  void (*xCallback)(void*,sqlite3_int64,int);\n  sqlite3_int64 nowUsed;\n  void *pArg;\n  if( mem0.alarmCallback==0 ) return;\n  xCallback = mem0.alarmCallback;\n  nowUsed = sqlite3StatusValue(SQLITE_STATUS_MEMORY_USED);\n  pArg = mem0.alarmArg;\n  mem0.alarmCallback = 0;\n  sqlite3_mutex_leave(mem0.mutex);\n  xCallback(pArg, nowUsed, nByte);\n  sqlite3_mutex_enter(mem0.mutex);\n  mem0.alarmCallback = xCallback;\n  mem0.alarmArg = pArg;\n}\n\n/*\n** Do a memory allocation with statistics and alarms.  Assume the\n** lock is already held.\n*/\nstatic int mallocWithAlarm(int n, void **pp){\n  int nFull;\n  void *p;\n  assert( sqlite3_mutex_held(mem0.mutex) );\n  nFull = sqlite3GlobalConfig.m.xRoundup(n);\n  sqlite3StatusSet(SQLITE_STATUS_MALLOC_SIZE, n);\n  if( mem0.alarmCallback!=0 ){\n    int nUsed = sqlite3StatusValue(SQLITE_STATUS_MEMORY_USED);\n    if( nUsed+nFull >= mem0.alarmThreshold ){\n      mem0.nearlyFull = 1;\n      sqlite3MallocAlarm(nFull);\n    }else{\n      mem0.nearlyFull = 0;\n    }\n  }\n  p = sqlite3GlobalConfig.m.xMalloc(nFull);\n#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT\n  if( p==0 && mem0.alarmCallback ){\n    sqlite3MallocAlarm(nFull);\n    p = sqlite3GlobalConfig.m.xMalloc(nFull);\n  }\n#endif\n  if( p ){\n    nFull = sqlite3MallocSize(p);\n    sqlite3StatusAdd(SQLITE_STATUS_MEMORY_USED, nFull);\n    sqlite3StatusAdd(SQLITE_STATUS_MALLOC_COUNT, 1);\n  }\n  *pp = p;\n  return nFull;\n}\n\n/*\n** Allocate memory.  This routine is like sqlite3_malloc() except that it\n** assumes the memory subsystem has already been initialized.\n*/\nSQLITE_PRIVATE void *sqlite3Malloc(int n){\n  void *p;\n  if( n<=0               /* IMP: R-65312-04917 */ \n   || n>=0x7fffff00\n  ){\n    /* A memory allocation of a number of bytes which is near the maximum\n    ** signed integer value might cause an integer overflow inside of the\n    ** xMalloc().  Hence we limit the maximum size to 0x7fffff00, giving\n    ** 255 bytes of overhead.  SQLite itself will never use anything near\n    ** this amount.  The only way to reach the limit is with sqlite3_malloc() */\n    p = 0;\n  }else if( sqlite3GlobalConfig.bMemstat ){\n    sqlite3_mutex_enter(mem0.mutex);\n    mallocWithAlarm(n, &p);\n    sqlite3_mutex_leave(mem0.mutex);\n  }else{\n    p = sqlite3GlobalConfig.m.xMalloc(n);\n  }\n  assert( EIGHT_BYTE_ALIGNMENT(p) );  /* IMP: R-04675-44850 */\n  return p;\n}\n\n/*\n** This version of the memory allocation is for use by the application.\n** First make sure the memory subsystem is initialized, then do the\n** allocation.\n*/\nSQLITE_API void *sqlite3_malloc(int n){\n#ifndef SQLITE_OMIT_AUTOINIT\n  if( sqlite3_initialize() ) return 0;\n#endif\n  return sqlite3Malloc(n);\n}\n\n/*\n** Each thread may only have a single outstanding allocation from\n** xScratchMalloc().  We verify this constraint in the single-threaded\n** case by setting scratchAllocOut to 1 when an allocation\n** is outstanding clearing it when the allocation is freed.\n*/\n#if SQLITE_THREADSAFE==0 && !defined(NDEBUG) && ENABLE_SCRATCHALLOC_CHECK\nstatic int scratchAllocOut = 0;\n#endif\n\n\n/*\n** Allocate memory that is to be used and released right away.\n** This routine is similar to alloca() in that it is not intended\n** for situations where the memory might be held long-term.  This\n** routine is intended to get memory to old large transient data\n** structures that would not normally fit on the stack of an\n** embedded processor.\n*/\nSQLITE_PRIVATE void *sqlite3ScratchMalloc(int n){\n  void *p;\n  assert( n>0 );\n\n  sqlite3_mutex_enter(mem0.mutex);\n  if( mem0.nScratchFree && sqlite3GlobalConfig.szScratch>=n ){\n    p = mem0.pScratchFree;\n    mem0.pScratchFree = mem0.pScratchFree->pNext;\n    mem0.nScratchFree--;\n    sqlite3StatusAdd(SQLITE_STATUS_SCRATCH_USED, 1);\n    sqlite3StatusSet(SQLITE_STATUS_SCRATCH_SIZE, n);\n    sqlite3_mutex_leave(mem0.mutex);\n  }else{\n    if( sqlite3GlobalConfig.bMemstat ){\n      sqlite3StatusSet(SQLITE_STATUS_SCRATCH_SIZE, n);\n      n = mallocWithAlarm(n, &p);\n      if( p ) sqlite3StatusAdd(SQLITE_STATUS_SCRATCH_OVERFLOW, n);\n      sqlite3_mutex_leave(mem0.mutex);\n    }else{\n      sqlite3_mutex_leave(mem0.mutex);\n      p = sqlite3GlobalConfig.m.xMalloc(n);\n    }\n    sqlite3MemdebugSetType(p, MEMTYPE_SCRATCH);\n  }\n  assert( sqlite3_mutex_notheld(mem0.mutex) );\n\n\n#if SQLITE_THREADSAFE==0 && !defined(NDEBUG) && ENABLE_SCRATCHALLOC_CHECK\n  /* Verify that no more than two scratch allocations per thread\n  ** are outstanding at one time.  (This is only checked in the\n  ** single-threaded case since checking in the multi-threaded case\n  ** would be much more complicated.) */\n  assert( scratchAllocOut<=1 );\n  if( p ) scratchAllocOut++;\n#endif\n\n  return p;\n}\nSQLITE_PRIVATE void sqlite3ScratchFree(void *p){\n  if( p ){\n\n#if SQLITE_THREADSAFE==0 && !defined(NDEBUG) && ENABLE_SCRATCHALLOC_CHECK\n    /* Verify that no more than two scratch allocation per thread\n    ** is outstanding at one time.  (This is only checked in the\n    ** single-threaded case since checking in the multi-threaded case\n    ** would be much more complicated.) */\n    assert( scratchAllocOut>=1 && scratchAllocOut<=2 );\n    scratchAllocOut--;\n#endif\n\n    if( p>=sqlite3GlobalConfig.pScratch && p<mem0.pScratchEnd ){\n      /* Release memory from the SQLITE_CONFIG_SCRATCH allocation */\n      ScratchFreeslot *pSlot;\n      pSlot = (ScratchFreeslot*)p;\n      sqlite3_mutex_enter(mem0.mutex);\n      pSlot->pNext = mem0.pScratchFree;\n      mem0.pScratchFree = pSlot;\n      mem0.nScratchFree++;\n      assert( mem0.nScratchFree<=sqlite3GlobalConfig.nScratch );\n      sqlite3StatusAdd(SQLITE_STATUS_SCRATCH_USED, -1);\n      sqlite3_mutex_leave(mem0.mutex);\n    }else{\n      /* Release memory back to the heap */\n      assert( sqlite3MemdebugHasType(p, MEMTYPE_SCRATCH) );\n      assert( sqlite3MemdebugNoType(p, ~MEMTYPE_SCRATCH) );\n      sqlite3MemdebugSetType(p, MEMTYPE_HEAP);\n      if( sqlite3GlobalConfig.bMemstat ){\n        int iSize = sqlite3MallocSize(p);\n        sqlite3_mutex_enter(mem0.mutex);\n        sqlite3StatusAdd(SQLITE_STATUS_SCRATCH_OVERFLOW, -iSize);\n        sqlite3StatusAdd(SQLITE_STATUS_MEMORY_USED, -iSize);\n        sqlite3StatusAdd(SQLITE_STATUS_MALLOC_COUNT, -1);\n        sqlite3GlobalConfig.m.xFree(p);\n        sqlite3_mutex_leave(mem0.mutex);\n      }else{\n        sqlite3GlobalConfig.m.xFree(p);\n      }\n    }\n  }\n}\n\n/*\n** TRUE if p is a lookaside memory allocation from db\n*/\n#ifndef SQLITE_OMIT_LOOKASIDE\nstatic int isLookaside(sqlite3 *db, void *p){\n  return p && p>=db->lookaside.pStart && p<db->lookaside.pEnd;\n}\n#else\n#define isLookaside(A,B) 0\n#endif\n\n/*\n** Return the size of a memory allocation previously obtained from\n** sqlite3Malloc() or sqlite3_malloc().\n*/\nSQLITE_PRIVATE int sqlite3MallocSize(void *p){\n  assert( sqlite3MemdebugHasType(p, MEMTYPE_HEAP) );\n  assert( sqlite3MemdebugNoType(p, MEMTYPE_DB) );\n  return sqlite3GlobalConfig.m.xSize(p);\n}\nSQLITE_PRIVATE int sqlite3DbMallocSize(sqlite3 *db, void *p){\n  assert( db==0 || sqlite3_mutex_held(db->mutex) );\n  if( db && isLookaside(db, p) ){\n    return db->lookaside.sz;\n  }else{\n    assert( sqlite3MemdebugHasType(p, MEMTYPE_DB) );\n    assert( sqlite3MemdebugHasType(p, MEMTYPE_LOOKASIDE|MEMTYPE_HEAP) );\n    assert( db!=0 || sqlite3MemdebugNoType(p, MEMTYPE_LOOKASIDE) );\n    return sqlite3GlobalConfig.m.xSize(p);\n  }\n}\n\n/*\n** Free memory previously obtained from sqlite3Malloc().\n*/\nSQLITE_API void sqlite3_free(void *p){\n  if( p==0 ) return;  /* IMP: R-49053-54554 */\n  assert( sqlite3MemdebugNoType(p, MEMTYPE_DB) );\n  assert( sqlite3MemdebugHasType(p, MEMTYPE_HEAP) );\n  if( sqlite3GlobalConfig.bMemstat ){\n    sqlite3_mutex_enter(mem0.mutex);\n    sqlite3StatusAdd(SQLITE_STATUS_MEMORY_USED, -sqlite3MallocSize(p));\n    sqlite3StatusAdd(SQLITE_STATUS_MALLOC_COUNT, -1);\n    sqlite3GlobalConfig.m.xFree(p);\n    sqlite3_mutex_leave(mem0.mutex);\n  }else{\n    sqlite3GlobalConfig.m.xFree(p);\n  }\n}\n\n/*\n** Free memory that might be associated with a particular database\n** connection.\n*/\nSQLITE_PRIVATE void sqlite3DbFree(sqlite3 *db, void *p){\n  assert( db==0 || sqlite3_mutex_held(db->mutex) );\n  if( db ){\n    if( db->pnBytesFreed ){\n      *db->pnBytesFreed += sqlite3DbMallocSize(db, p);\n      return;\n    }\n    if( isLookaside(db, p) ){\n      LookasideSlot *pBuf = (LookasideSlot*)p;\n      pBuf->pNext = db->lookaside.pFree;\n      db->lookaside.pFree = pBuf;\n      db->lookaside.nOut--;\n      return;\n    }\n  }\n  assert( sqlite3MemdebugHasType(p, MEMTYPE_DB) );\n  assert( sqlite3MemdebugHasType(p, MEMTYPE_LOOKASIDE|MEMTYPE_HEAP) );\n  assert( db!=0 || sqlite3MemdebugNoType(p, MEMTYPE_LOOKASIDE) );\n  sqlite3MemdebugSetType(p, MEMTYPE_HEAP);\n  sqlite3_free(p);\n}\n\n/*\n** Change the size of an existing memory allocation\n*/\nSQLITE_PRIVATE void *sqlite3Realloc(void *pOld, int nBytes){\n  int nOld, nNew;\n  void *pNew;\n  if( pOld==0 ){\n    return sqlite3Malloc(nBytes); /* IMP: R-28354-25769 */\n  }\n  if( nBytes<=0 ){\n    sqlite3_free(pOld); /* IMP: R-31593-10574 */\n    return 0;\n  }\n  if( nBytes>=0x7fffff00 ){\n    /* The 0x7ffff00 limit term is explained in comments on sqlite3Malloc() */\n    return 0;\n  }\n  nOld = sqlite3MallocSize(pOld);\n  /* IMPLEMENTATION-OF: R-46199-30249 SQLite guarantees that the second\n  ** argument to xRealloc is always a value returned by a prior call to\n  ** xRoundup. */\n  nNew = sqlite3GlobalConfig.m.xRoundup(nBytes);\n  if( nOld==nNew ){\n    pNew = pOld;\n  }else if( sqlite3GlobalConfig.bMemstat ){\n    sqlite3_mutex_enter(mem0.mutex);\n    sqlite3StatusSet(SQLITE_STATUS_MALLOC_SIZE, nBytes);\n    if( sqlite3StatusValue(SQLITE_STATUS_MEMORY_USED)+nNew-nOld >= \n          mem0.alarmThreshold ){\n      sqlite3MallocAlarm(nNew-nOld);\n    }\n    assert( sqlite3MemdebugHasType(pOld, MEMTYPE_HEAP) );\n    assert( sqlite3MemdebugNoType(pOld, ~MEMTYPE_HEAP) );\n    pNew = sqlite3GlobalConfig.m.xRealloc(pOld, nNew);\n    if( pNew==0 && mem0.alarmCallback ){\n      sqlite3MallocAlarm(nBytes);\n      pNew = sqlite3GlobalConfig.m.xRealloc(pOld, nNew);\n    }\n    if( pNew ){\n      nNew = sqlite3MallocSize(pNew);\n      sqlite3StatusAdd(SQLITE_STATUS_MEMORY_USED, nNew-nOld);\n    }\n    sqlite3_mutex_leave(mem0.mutex);\n  }else{\n    pNew = sqlite3GlobalConfig.m.xRealloc(pOld, nNew);\n  }\n  assert( EIGHT_BYTE_ALIGNMENT(pNew) ); /* IMP: R-04675-44850 */\n  return pNew;\n}\n\n/*\n** The public interface to sqlite3Realloc.  Make sure that the memory\n** subsystem is initialized prior to invoking sqliteRealloc.\n*/\nSQLITE_API void *sqlite3_realloc(void *pOld, int n){\n#ifndef SQLITE_OMIT_AUTOINIT\n  if( sqlite3_initialize() ) return 0;\n#endif\n  return sqlite3Realloc(pOld, n);\n}\n\n\n/*\n** Allocate and zero memory.\n*/ \nSQLITE_PRIVATE void *sqlite3MallocZero(int n){\n  void *p = sqlite3Malloc(n);\n  if( p ){\n    memset(p, 0, n);\n  }\n  return p;\n}\n\n/*\n** Allocate and zero memory.  If the allocation fails, make\n** the mallocFailed flag in the connection pointer.\n*/\nSQLITE_PRIVATE void *sqlite3DbMallocZero(sqlite3 *db, int n){\n  void *p = sqlite3DbMallocRaw(db, n);\n  if( p ){\n    memset(p, 0, n);\n  }\n  return p;\n}\n\n/*\n** Allocate and zero memory.  If the allocation fails, make\n** the mallocFailed flag in the connection pointer.\n**\n** If db!=0 and db->mallocFailed is true (indicating a prior malloc\n** failure on the same database connection) then always return 0.\n** Hence for a particular database connection, once malloc starts\n** failing, it fails consistently until mallocFailed is reset.\n** This is an important assumption.  There are many places in the\n** code that do things like this:\n**\n**         int *a = (int*)sqlite3DbMallocRaw(db, 100);\n**         int *b = (int*)sqlite3DbMallocRaw(db, 200);\n**         if( b ) a[10] = 9;\n**\n** In other words, if a subsequent malloc (ex: \"b\") worked, it is assumed\n** that all prior mallocs (ex: \"a\") worked too.\n*/\nSQLITE_PRIVATE void *sqlite3DbMallocRaw(sqlite3 *db, int n){\n  void *p;\n  assert( db==0 || sqlite3_mutex_held(db->mutex) );\n  assert( db==0 || db->pnBytesFreed==0 );\n#ifndef SQLITE_OMIT_LOOKASIDE\n  if( db ){\n    LookasideSlot *pBuf;\n    if( db->mallocFailed ){\n      return 0;\n    }\n    if( db->lookaside.bEnabled ){\n      if( n>db->lookaside.sz ){\n        db->lookaside.anStat[1]++;\n      }else if( (pBuf = db->lookaside.pFree)==0 ){\n        db->lookaside.anStat[2]++;\n      }else{\n        db->lookaside.pFree = pBuf->pNext;\n        db->lookaside.nOut++;\n        db->lookaside.anStat[0]++;\n        if( db->lookaside.nOut>db->lookaside.mxOut ){\n          db->lookaside.mxOut = db->lookaside.nOut;\n        }\n        return (void*)pBuf;\n      }\n    }\n  }\n#else\n  if( db && db->mallocFailed ){\n    return 0;\n  }\n#endif\n  p = sqlite3Malloc(n);\n  if( !p && db ){\n    db->mallocFailed = 1;\n  }\n  sqlite3MemdebugSetType(p, MEMTYPE_DB |\n         ((db && db->lookaside.bEnabled) ? MEMTYPE_LOOKASIDE : MEMTYPE_HEAP));\n  return p;\n}\n\n/*\n** Resize the block of memory pointed to by p to n bytes. If the\n** resize fails, set the mallocFailed flag in the connection object.\n*/\nSQLITE_PRIVATE void *sqlite3DbRealloc(sqlite3 *db, void *p, int n){\n  void *pNew = 0;\n  assert( db!=0 );\n  assert( sqlite3_mutex_held(db->mutex) );\n  if( db->mallocFailed==0 ){\n    if( p==0 ){\n      return sqlite3DbMallocRaw(db, n);\n    }\n    if( isLookaside(db, p) ){\n      if( n<=db->lookaside.sz ){\n        return p;\n      }\n      pNew = sqlite3DbMallocRaw(db, n);\n      if( pNew ){\n        memcpy(pNew, p, db->lookaside.sz);\n        sqlite3DbFree(db, p);\n      }\n    }else{\n      assert( sqlite3MemdebugHasType(p, MEMTYPE_DB) );\n      assert( sqlite3MemdebugHasType(p, MEMTYPE_LOOKASIDE|MEMTYPE_HEAP) );\n      sqlite3MemdebugSetType(p, MEMTYPE_HEAP);\n      pNew = sqlite3_realloc(p, n);\n      if( !pNew ){\n        sqlite3MemdebugSetType(p, MEMTYPE_DB|MEMTYPE_HEAP);\n        db->mallocFailed = 1;\n      }\n      sqlite3MemdebugSetType(pNew, MEMTYPE_DB | \n            (db->lookaside.bEnabled ? MEMTYPE_LOOKASIDE : MEMTYPE_HEAP));\n    }\n  }\n  return pNew;\n}\n\n/*\n** Attempt to reallocate p.  If the reallocation fails, then free p\n** and set the mallocFailed flag in the database connection.\n*/\nSQLITE_PRIVATE void *sqlite3DbReallocOrFree(sqlite3 *db, void *p, int n){\n  void *pNew;\n  pNew = sqlite3DbRealloc(db, p, n);\n  if( !pNew ){\n    sqlite3DbFree(db, p);\n  }\n  return pNew;\n}\n\n/*\n** Make a copy of a string in memory obtained from sqliteMalloc(). These \n** functions call sqlite3MallocRaw() directly instead of sqliteMalloc(). This\n** is because when memory debugging is turned on, these two functions are \n** called via macros that record the current file and line number in the\n** ThreadData structure.\n*/\nSQLITE_PRIVATE char *sqlite3DbStrDup(sqlite3 *db, const char *z){\n  char *zNew;\n  size_t n;\n  if( z==0 ){\n    return 0;\n  }\n  n = sqlite3Strlen30(z) + 1;\n  assert( (n&0x7fffffff)==n );\n  zNew = sqlite3DbMallocRaw(db, (int)n);\n  if( zNew ){\n    memcpy(zNew, z, n);\n  }\n  return zNew;\n}\nSQLITE_PRIVATE char *sqlite3DbStrNDup(sqlite3 *db, const char *z, int n){\n  char *zNew;\n  if( z==0 ){\n    return 0;\n  }\n  assert( (n&0x7fffffff)==n );\n  zNew = sqlite3DbMallocRaw(db, n+1);\n  if( zNew ){\n    memcpy(zNew, z, n);\n    zNew[n] = 0;\n  }\n  return zNew;\n}\n\n/*\n** Create a string from the zFromat argument and the va_list that follows.\n** Store the string in memory obtained from sqliteMalloc() and make *pz\n** point to that string.\n*/\nSQLITE_PRIVATE void sqlite3SetString(char **pz, sqlite3 *db, const char *zFormat, ...){\n  va_list ap;\n  char *z;\n\n  va_start(ap, zFormat);\n  z = sqlite3VMPrintf(db, zFormat, ap);\n  va_end(ap);\n  sqlite3DbFree(db, *pz);\n  *pz = z;\n}\n\n\n/*\n** This function must be called before exiting any API function (i.e. \n** returning control to the user) that has called sqlite3_malloc or\n** sqlite3_realloc.\n**\n** The returned value is normally a copy of the second argument to this\n** function. However, if a malloc() failure has occurred since the previous\n** invocation SQLITE_NOMEM is returned instead. \n**\n** If the first argument, db, is not NULL and a malloc() error has occurred,\n** then the connection error-code (the value returned by sqlite3_errcode())\n** is set to SQLITE_NOMEM.\n*/\nSQLITE_PRIVATE int sqlite3ApiExit(sqlite3* db, int rc){\n  /* If the db handle is not NULL, then we must hold the connection handle\n  ** mutex here. Otherwise the read (and possible write) of db->mallocFailed \n  ** is unsafe, as is the call to sqlite3Error().\n  */\n  assert( !db || sqlite3_mutex_held(db->mutex) );\n  if( db && (db->mallocFailed || rc==SQLITE_IOERR_NOMEM) ){\n    sqlite3Error(db, SQLITE_NOMEM, 0);\n    db->mallocFailed = 0;\n    rc = SQLITE_NOMEM;\n  }\n  return rc & (db ? db->errMask : 0xff);\n}\n\n/************** End of malloc.c **********************************************/\n/************** Begin file printf.c ******************************************/\n/*\n** The \"printf\" code that follows dates from the 1980's.  It is in\n** the public domain.  The original comments are included here for\n** completeness.  They are very out-of-date but might be useful as\n** an historical reference.  Most of the \"enhancements\" have been backed\n** out so that the functionality is now the same as standard printf().\n**\n**************************************************************************\n**\n** The following modules is an enhanced replacement for the \"printf\" subroutines\n** found in the standard C library.  The following enhancements are\n** supported:\n**\n**      +  Additional functions.  The standard set of \"printf\" functions\n**         includes printf, fprintf, sprintf, vprintf, vfprintf, and\n**         vsprintf.  This module adds the following:\n**\n**           *  snprintf -- Works like sprintf, but has an extra argument\n**                          which is the size of the buffer written to.\n**\n**           *  mprintf --  Similar to sprintf.  Writes output to memory\n**                          obtained from malloc.\n**\n**           *  xprintf --  Calls a function to dispose of output.\n**\n**           *  nprintf --  No output, but returns the number of characters\n**                          that would have been output by printf.\n**\n**           *  A v- version (ex: vsnprintf) of every function is also\n**              supplied.\n**\n**      +  A few extensions to the formatting notation are supported:\n**\n**           *  The \"=\" flag (similar to \"-\") causes the output to be\n**              be centered in the appropriately sized field.\n**\n**           *  The %b field outputs an integer in binary notation.\n**\n**           *  The %c field now accepts a precision.  The character output\n**              is repeated by the number of times the precision specifies.\n**\n**           *  The %' field works like %c, but takes as its character the\n**              next character of the format string, instead of the next\n**              argument.  For example,  printf(\"%.78'-\")  prints 78 minus\n**              signs, the same as  printf(\"%.78c\",'-').\n**\n**      +  When compiled using GCC on a SPARC, this version of printf is\n**         faster than the library printf for SUN OS 4.1.\n**\n**      +  All functions are fully reentrant.\n**\n*/\n\n/*\n** Conversion types fall into various categories as defined by the\n** following enumeration.\n*/\n#define etRADIX       1 /* Integer types.  %d, %x, %o, and so forth */\n#define etFLOAT       2 /* Floating point.  %f */\n#define etEXP         3 /* Exponentional notation. %e and %E */\n#define etGENERIC     4 /* Floating or exponential, depending on exponent. %g */\n#define etSIZE        5 /* Return number of characters processed so far. %n */\n#define etSTRING      6 /* Strings. %s */\n#define etDYNSTRING   7 /* Dynamically allocated strings. %z */\n#define etPERCENT     8 /* Percent symbol. %% */\n#define etCHARX       9 /* Characters. %c */\n/* The rest are extensions, not normally found in printf() */\n#define etSQLESCAPE  10 /* Strings with '\\'' doubled.  %q */\n#define etSQLESCAPE2 11 /* Strings with '\\'' doubled and enclosed in '',\n                          NULL pointers replaced by SQL NULL.  %Q */\n#define etTOKEN      12 /* a pointer to a Token structure */\n#define etSRCLIST    13 /* a pointer to a SrcList */\n#define etPOINTER    14 /* The %p conversion */\n#define etSQLESCAPE3 15 /* %w -> Strings with '\\\"' doubled */\n#define etORDINAL    16 /* %r -> 1st, 2nd, 3rd, 4th, etc.  English only */\n\n#define etINVALID     0 /* Any unrecognized conversion type */\n\n\n/*\n** An \"etByte\" is an 8-bit unsigned value.\n*/\ntypedef unsigned char etByte;\n\n/*\n** Each builtin conversion character (ex: the 'd' in \"%d\") is described\n** by an instance of the following structure\n*/\ntypedef struct et_info {   /* Information about each format field */\n  char fmttype;            /* The format field code letter */\n  etByte base;             /* The base for radix conversion */\n  etByte flags;            /* One or more of FLAG_ constants below */\n  etByte type;             /* Conversion paradigm */\n  etByte charset;          /* Offset into aDigits[] of the digits string */\n  etByte prefix;           /* Offset into aPrefix[] of the prefix string */\n} et_info;\n\n/*\n** Allowed values for et_info.flags\n*/\n#define FLAG_SIGNED  1     /* True if the value to convert is signed */\n#define FLAG_INTERN  2     /* True if for internal use only */\n#define FLAG_STRING  4     /* Allow infinity precision */\n\n\n/*\n** The following table is searched linearly, so it is good to put the\n** most frequently used conversion types first.\n*/\nstatic const char aDigits[] = \"0123456789ABCDEF0123456789abcdef\";\nstatic const char aPrefix[] = \"-x0\\000X0\";\nstatic const et_info fmtinfo[] = {\n  {  'd', 10, 1, etRADIX,      0,  0 },\n  {  's',  0, 4, etSTRING,     0,  0 },\n  {  'g',  0, 1, etGENERIC,    30, 0 },\n  {  'z',  0, 4, etDYNSTRING,  0,  0 },\n  {  'q',  0, 4, etSQLESCAPE,  0,  0 },\n  {  'Q',  0, 4, etSQLESCAPE2, 0,  0 },\n  {  'w',  0, 4, etSQLESCAPE3, 0,  0 },\n  {  'c',  0, 0, etCHARX,      0,  0 },\n  {  'o',  8, 0, etRADIX,      0,  2 },\n  {  'u', 10, 0, etRADIX,      0,  0 },\n  {  'x', 16, 0, etRADIX,      16, 1 },\n  {  'X', 16, 0, etRADIX,      0,  4 },\n#ifndef SQLITE_OMIT_FLOATING_POINT\n  {  'f',  0, 1, etFLOAT,      0,  0 },\n  {  'e',  0, 1, etEXP,        30, 0 },\n  {  'E',  0, 1, etEXP,        14, 0 },\n  {  'G',  0, 1, etGENERIC,    14, 0 },\n#endif\n  {  'i', 10, 1, etRADIX,      0,  0 },\n  {  'n',  0, 0, etSIZE,       0,  0 },\n  {  '%',  0, 0, etPERCENT,    0,  0 },\n  {  'p', 16, 0, etPOINTER,    0,  1 },\n\n/* All the rest have the FLAG_INTERN bit set and are thus for internal\n** use only */\n  {  'T',  0, 2, etTOKEN,      0,  0 },\n  {  'S',  0, 2, etSRCLIST,    0,  0 },\n  {  'r', 10, 3, etORDINAL,    0,  0 },\n};\n\n/*\n** If SQLITE_OMIT_FLOATING_POINT is defined, then none of the floating point\n** conversions will work.\n*/\n#ifndef SQLITE_OMIT_FLOATING_POINT\n/*\n** \"*val\" is a double such that 0.1 <= *val < 10.0\n** Return the ascii code for the leading digit of *val, then\n** multiply \"*val\" by 10.0 to renormalize.\n**\n** Example:\n**     input:     *val = 3.14159\n**     output:    *val = 1.4159    function return = '3'\n**\n** The counter *cnt is incremented each time.  After counter exceeds\n** 16 (the number of significant digits in a 64-bit float) '0' is\n** always returned.\n*/\nstatic char et_getdigit(LONGDOUBLE_TYPE *val, int *cnt){\n  int digit;\n  LONGDOUBLE_TYPE d;\n  if( (*cnt)++ >= 16 ) return '0';\n  digit = (int)*val;\n  d = digit;\n  digit += '0';\n  *val = (*val - d)*10.0;\n  return (char)digit;\n}\n#endif /* SQLITE_OMIT_FLOATING_POINT */\n\n/*\n** Append N space characters to the given string buffer.\n*/\nstatic void appendSpace(StrAccum *pAccum, int N){\n  static const char zSpaces[] = \"                             \";\n  while( N>=(int)sizeof(zSpaces)-1 ){\n    sqlite3StrAccumAppend(pAccum, zSpaces, sizeof(zSpaces)-1);\n    N -= sizeof(zSpaces)-1;\n  }\n  if( N>0 ){\n    sqlite3StrAccumAppend(pAccum, zSpaces, N);\n  }\n}\n\n/*\n** On machines with a small stack size, you can redefine the\n** SQLITE_PRINT_BUF_SIZE to be less than 350.\n*/\n#ifndef SQLITE_PRINT_BUF_SIZE\n# if defined(SQLITE_SMALL_STACK)\n#   define SQLITE_PRINT_BUF_SIZE 50\n# else\n#   define SQLITE_PRINT_BUF_SIZE 350\n# endif\n#endif\n#define etBUFSIZE SQLITE_PRINT_BUF_SIZE  /* Size of the output buffer */\n\n/*\n** The root program.  All variations call this core.\n**\n** INPUTS:\n**   func   This is a pointer to a function taking three arguments\n**            1. A pointer to anything.  Same as the \"arg\" parameter.\n**            2. A pointer to the list of characters to be output\n**               (Note, this list is NOT null terminated.)\n**            3. An integer number of characters to be output.\n**               (Note: This number might be zero.)\n**\n**   arg    This is the pointer to anything which will be passed as the\n**          first argument to \"func\".  Use it for whatever you like.\n**\n**   fmt    This is the format string, as in the usual print.\n**\n**   ap     This is a pointer to a list of arguments.  Same as in\n**          vfprint.\n**\n** OUTPUTS:\n**          The return value is the total number of characters sent to\n**          the function \"func\".  Returns -1 on a error.\n**\n** Note that the order in which automatic variables are declared below\n** seems to make a big difference in determining how fast this beast\n** will run.\n*/\nSQLITE_PRIVATE void sqlite3VXPrintf(\n  StrAccum *pAccum,                  /* Accumulate results here */\n  int useExtended,                   /* Allow extended %-conversions */\n  const char *fmt,                   /* Format string */\n  va_list ap                         /* arguments */\n){\n  int c;                     /* Next character in the format string */\n  char *bufpt;               /* Pointer to the conversion buffer */\n  int precision;             /* Precision of the current field */\n  int length;                /* Length of the field */\n  int idx;                   /* A general purpose loop counter */\n  int width;                 /* Width of the current field */\n  etByte flag_leftjustify;   /* True if \"-\" flag is present */\n  etByte flag_plussign;      /* True if \"+\" flag is present */\n  etByte flag_blanksign;     /* True if \" \" flag is present */\n  etByte flag_alternateform; /* True if \"#\" flag is present */\n  etByte flag_altform2;      /* True if \"!\" flag is present */\n  etByte flag_zeropad;       /* True if field width constant starts with zero */\n  etByte flag_long;          /* True if \"l\" flag is present */\n  etByte flag_longlong;      /* True if the \"ll\" flag is present */\n  etByte done;               /* Loop termination flag */\n  sqlite_uint64 longvalue;   /* Value for integer types */\n  LONGDOUBLE_TYPE realvalue; /* Value for real types */\n  const et_info *infop;      /* Pointer to the appropriate info structure */\n  char buf[etBUFSIZE];       /* Conversion buffer */\n  char prefix;               /* Prefix character.  \"+\" or \"-\" or \" \" or '\\0'. */\n  etByte xtype = 0;          /* Conversion paradigm */\n  char *zExtra;              /* Extra memory used for etTCLESCAPE conversions */\n#ifndef SQLITE_OMIT_FLOATING_POINT\n  int  exp, e2;              /* exponent of real numbers */\n  double rounder;            /* Used for rounding floating point values */\n  etByte flag_dp;            /* True if decimal point should be shown */\n  etByte flag_rtz;           /* True if trailing zeros should be removed */\n  etByte flag_exp;           /* True to force display of the exponent */\n  int nsd;                   /* Number of significant digits returned */\n#endif\n\n  length = 0;\n  bufpt = 0;\n  for(; (c=(*fmt))!=0; ++fmt){\n    if( c!='%' ){\n      int amt;\n      bufpt = (char *)fmt;\n      amt = 1;\n      while( (c=(*++fmt))!='%' && c!=0 ) amt++;\n      sqlite3StrAccumAppend(pAccum, bufpt, amt);\n      if( c==0 ) break;\n    }\n    if( (c=(*++fmt))==0 ){\n      sqlite3StrAccumAppend(pAccum, \"%\", 1);\n      break;\n    }\n    /* Find out what flags are present */\n    flag_leftjustify = flag_plussign = flag_blanksign = \n     flag_alternateform = flag_altform2 = flag_zeropad = 0;\n    done = 0;\n    do{\n      switch( c ){\n        case '-':   flag_leftjustify = 1;     break;\n        case '+':   flag_plussign = 1;        break;\n        case ' ':   flag_blanksign = 1;       break;\n        case '#':   flag_alternateform = 1;   break;\n        case '!':   flag_altform2 = 1;        break;\n        case '0':   flag_zeropad = 1;         break;\n        default:    done = 1;                 break;\n      }\n    }while( !done && (c=(*++fmt))!=0 );\n    /* Get the field width */\n    width = 0;\n    if( c=='*' ){\n      width = va_arg(ap,int);\n      if( width<0 ){\n        flag_leftjustify = 1;\n        width = -width;\n      }\n      c = *++fmt;\n    }else{\n      while( c>='0' && c<='9' ){\n        width = width*10 + c - '0';\n        c = *++fmt;\n      }\n    }\n    if( width > etBUFSIZE-10 ){\n      width = etBUFSIZE-10;\n    }\n    /* Get the precision */\n    if( c=='.' ){\n      precision = 0;\n      c = *++fmt;\n      if( c=='*' ){\n        precision = va_arg(ap,int);\n        if( precision<0 ) precision = -precision;\n        c = *++fmt;\n      }else{\n        while( c>='0' && c<='9' ){\n          precision = precision*10 + c - '0';\n          c = *++fmt;\n        }\n      }\n    }else{\n      precision = -1;\n    }\n    /* Get the conversion type modifier */\n    if( c=='l' ){\n      flag_long = 1;\n      c = *++fmt;\n      if( c=='l' ){\n        flag_longlong = 1;\n        c = *++fmt;\n      }else{\n        flag_longlong = 0;\n      }\n    }else{\n      flag_long = flag_longlong = 0;\n    }\n    /* Fetch the info entry for the field */\n    infop = &fmtinfo[0];\n    xtype = etINVALID;\n    for(idx=0; idx<ArraySize(fmtinfo); idx++){\n      if( c==fmtinfo[idx].fmttype ){\n        infop = &fmtinfo[idx];\n        if( useExtended || (infop->flags & FLAG_INTERN)==0 ){\n          xtype = infop->type;\n        }else{\n          return;\n        }\n        break;\n      }\n    }\n    zExtra = 0;\n\n\n    /* Limit the precision to prevent overflowing buf[] during conversion */\n    if( precision>etBUFSIZE-40 && (infop->flags & FLAG_STRING)==0 ){\n      precision = etBUFSIZE-40;\n    }\n\n    /*\n    ** At this point, variables are initialized as follows:\n    **\n    **   flag_alternateform          TRUE if a '#' is present.\n    **   flag_altform2               TRUE if a '!' is present.\n    **   flag_plussign               TRUE if a '+' is present.\n    **   flag_leftjustify            TRUE if a '-' is present or if the\n    **                               field width was negative.\n    **   flag_zeropad                TRUE if the width began with 0.\n    **   flag_long                   TRUE if the letter 'l' (ell) prefixed\n    **                               the conversion character.\n    **   flag_longlong               TRUE if the letter 'll' (ell ell) prefixed\n    **                               the conversion character.\n    **   flag_blanksign              TRUE if a ' ' is present.\n    **   width                       The specified field width.  This is\n    **                               always non-negative.  Zero is the default.\n    **   precision                   The specified precision.  The default\n    **                               is -1.\n    **   xtype                       The class of the conversion.\n    **   infop                       Pointer to the appropriate info struct.\n    */\n    switch( xtype ){\n      case etPOINTER:\n        flag_longlong = sizeof(char*)==sizeof(i64);\n        flag_long = sizeof(char*)==sizeof(long int);\n        /* Fall through into the next case */\n      case etORDINAL:\n      case etRADIX:\n        if( infop->flags & FLAG_SIGNED ){\n          i64 v;\n          if( flag_longlong ){\n            v = va_arg(ap,i64);\n          }else if( flag_long ){\n            v = va_arg(ap,long int);\n          }else{\n            v = va_arg(ap,int);\n          }\n          if( v<0 ){\n            if( v==SMALLEST_INT64 ){\n              longvalue = ((u64)1)<<63;\n            }else{\n              longvalue = -v;\n            }\n            prefix = '-';\n          }else{\n            longvalue = v;\n            if( flag_plussign )        prefix = '+';\n            else if( flag_blanksign )  prefix = ' ';\n            else                       prefix = 0;\n          }\n        }else{\n          if( flag_longlong ){\n            longvalue = va_arg(ap,u64);\n          }else if( flag_long ){\n            longvalue = va_arg(ap,unsigned long int);\n          }else{\n            longvalue = va_arg(ap,unsigned int);\n          }\n          prefix = 0;\n        }\n        if( longvalue==0 ) flag_alternateform = 0;\n        if( flag_zeropad && precision<width-(prefix!=0) ){\n          precision = width-(prefix!=0);\n        }\n        bufpt = &buf[etBUFSIZE-1];\n        if( xtype==etORDINAL ){\n          static const char zOrd[] = \"thstndrd\";\n          int x = (int)(longvalue % 10);\n          if( x>=4 || (longvalue/10)%10==1 ){\n            x = 0;\n          }\n          buf[etBUFSIZE-3] = zOrd[x*2];\n          buf[etBUFSIZE-2] = zOrd[x*2+1];\n          bufpt -= 2;\n        }\n        {\n          register const char *cset;      /* Use registers for speed */\n          register int base;\n          cset = &aDigits[infop->charset];\n          base = infop->base;\n          do{                                           /* Convert to ascii */\n            *(--bufpt) = cset[longvalue%base];\n            longvalue = longvalue/base;\n          }while( longvalue>0 );\n        }\n        length = (int)(&buf[etBUFSIZE-1]-bufpt);\n        for(idx=precision-length; idx>0; idx--){\n          *(--bufpt) = '0';                             /* Zero pad */\n        }\n        if( prefix ) *(--bufpt) = prefix;               /* Add sign */\n        if( flag_alternateform && infop->prefix ){      /* Add \"0\" or \"0x\" */\n          const char *pre;\n          char x;\n          pre = &aPrefix[infop->prefix];\n          for(; (x=(*pre))!=0; pre++) *(--bufpt) = x;\n        }\n        length = (int)(&buf[etBUFSIZE-1]-bufpt);\n        break;\n      case etFLOAT:\n      case etEXP:\n      case etGENERIC:\n        realvalue = va_arg(ap,double);\n#ifdef SQLITE_OMIT_FLOATING_POINT\n        length = 0;\n#else\n        if( precision<0 ) precision = 6;         /* Set default precision */\n        if( precision>etBUFSIZE/2-10 ) precision = etBUFSIZE/2-10;\n        if( realvalue<0.0 ){\n          realvalue = -realvalue;\n          prefix = '-';\n        }else{\n          if( flag_plussign )          prefix = '+';\n          else if( flag_blanksign )    prefix = ' ';\n          else                         prefix = 0;\n        }\n        if( xtype==etGENERIC && precision>0 ) precision--;\n#if 0\n        /* Rounding works like BSD when the constant 0.4999 is used.  Wierd! */\n        for(idx=precision, rounder=0.4999; idx>0; idx--, rounder*=0.1);\n#else\n        /* It makes more sense to use 0.5 */\n        for(idx=precision, rounder=0.5; idx>0; idx--, rounder*=0.1){}\n#endif\n        if( xtype==etFLOAT ) realvalue += rounder;\n        /* Normalize realvalue to within 10.0 > realvalue >= 1.0 */\n        exp = 0;\n        if( sqlite3IsNaN((double)realvalue) ){\n          bufpt = \"NaN\";\n          length = 3;\n          break;\n        }\n        if( realvalue>0.0 ){\n          while( realvalue>=1e32 && exp<=350 ){ realvalue *= 1e-32; exp+=32; }\n          while( realvalue>=1e8 && exp<=350 ){ realvalue *= 1e-8; exp+=8; }\n          while( realvalue>=10.0 && exp<=350 ){ realvalue *= 0.1; exp++; }\n          while( realvalue<1e-8 ){ realvalue *= 1e8; exp-=8; }\n          while( realvalue<1.0 ){ realvalue *= 10.0; exp--; }\n          if( exp>350 ){\n            if( prefix=='-' ){\n              bufpt = \"-Inf\";\n            }else if( prefix=='+' ){\n              bufpt = \"+Inf\";\n            }else{\n              bufpt = \"Inf\";\n            }\n            length = sqlite3Strlen30(bufpt);\n            break;\n          }\n        }\n        bufpt = buf;\n        /*\n        ** If the field type is etGENERIC, then convert to either etEXP\n        ** or etFLOAT, as appropriate.\n        */\n        flag_exp = xtype==etEXP;\n        if( xtype!=etFLOAT ){\n          realvalue += rounder;\n          if( realvalue>=10.0 ){ realvalue *= 0.1; exp++; }\n        }\n        if( xtype==etGENERIC ){\n          flag_rtz = !flag_alternateform;\n          if( exp<-4 || exp>precision ){\n            xtype = etEXP;\n          }else{\n            precision = precision - exp;\n            xtype = etFLOAT;\n          }\n        }else{\n          flag_rtz = 0;\n        }\n        if( xtype==etEXP ){\n          e2 = 0;\n        }else{\n          e2 = exp;\n        }\n        nsd = 0;\n        flag_dp = (precision>0 ?1:0) | flag_alternateform | flag_altform2;\n        /* The sign in front of the number */\n        if( prefix ){\n          *(bufpt++) = prefix;\n        }\n        /* Digits prior to the decimal point */\n        if( e2<0 ){\n          *(bufpt++) = '0';\n        }else{\n          for(; e2>=0; e2--){\n            *(bufpt++) = et_getdigit(&realvalue,&nsd);\n          }\n        }\n        /* The decimal point */\n        if( flag_dp ){\n          *(bufpt++) = '.';\n        }\n        /* \"0\" digits after the decimal point but before the first\n        ** significant digit of the number */\n        for(e2++; e2<0; precision--, e2++){\n          assert( precision>0 );\n          *(bufpt++) = '0';\n        }\n        /* Significant digits after the decimal point */\n        while( (precision--)>0 ){\n          *(bufpt++) = et_getdigit(&realvalue,&nsd);\n        }\n        /* Remove trailing zeros and the \".\" if no digits follow the \".\" */\n        if( flag_rtz && flag_dp ){\n          while( bufpt[-1]=='0' ) *(--bufpt) = 0;\n          assert( bufpt>buf );\n          if( bufpt[-1]=='.' ){\n            if( flag_altform2 ){\n              *(bufpt++) = '0';\n            }else{\n              *(--bufpt) = 0;\n            }\n          }\n        }\n        /* Add the \"eNNN\" suffix */\n        if( flag_exp || xtype==etEXP ){\n          *(bufpt++) = aDigits[infop->charset];\n          if( exp<0 ){\n            *(bufpt++) = '-'; exp = -exp;\n          }else{\n            *(bufpt++) = '+';\n          }\n          if( exp>=100 ){\n            *(bufpt++) = (char)((exp/100)+'0');        /* 100's digit */\n            exp %= 100;\n          }\n          *(bufpt++) = (char)(exp/10+'0');             /* 10's digit */\n          *(bufpt++) = (char)(exp%10+'0');             /* 1's digit */\n        }\n        *bufpt = 0;\n\n        /* The converted number is in buf[] and zero terminated. Output it.\n        ** Note that the number is in the usual order, not reversed as with\n        ** integer conversions. */\n        length = (int)(bufpt-buf);\n        bufpt = buf;\n\n        /* Special case:  Add leading zeros if the flag_zeropad flag is\n        ** set and we are not left justified */\n        if( flag_zeropad && !flag_leftjustify && length < width){\n          int i;\n          int nPad = width - length;\n          for(i=width; i>=nPad; i--){\n            bufpt[i] = bufpt[i-nPad];\n          }\n          i = prefix!=0;\n          while( nPad-- ) bufpt[i++] = '0';\n          length = width;\n        }\n#endif /* !defined(SQLITE_OMIT_FLOATING_POINT) */\n        break;\n      case etSIZE:\n        *(va_arg(ap,int*)) = pAccum->nChar;\n        length = width = 0;\n        break;\n      case etPERCENT:\n        buf[0] = '%';\n        bufpt = buf;\n        length = 1;\n        break;\n      case etCHARX:\n        c = va_arg(ap,int);\n        buf[0] = (char)c;\n        if( precision>=0 ){\n          for(idx=1; idx<precision; idx++) buf[idx] = (char)c;\n          length = precision;\n        }else{\n          length =1;\n        }\n        bufpt = buf;\n        break;\n      case etSTRING:\n      case etDYNSTRING:\n        bufpt = va_arg(ap,char*);\n        if( bufpt==0 ){\n          bufpt = \"\";\n        }else if( xtype==etDYNSTRING ){\n          zExtra = bufpt;\n        }\n        if( precision>=0 ){\n          for(length=0; length<precision && bufpt[length]; length++){}\n        }else{\n          length = sqlite3Strlen30(bufpt);\n        }\n        break;\n      case etSQLESCAPE:\n      case etSQLESCAPE2:\n      case etSQLESCAPE3: {\n        int i, j, k, n, isnull;\n        int needQuote;\n        char ch;\n        char q = ((xtype==etSQLESCAPE3)?'\"':'\\'');   /* Quote character */\n        char *escarg = va_arg(ap,char*);\n        isnull = escarg==0;\n        if( isnull ) escarg = (xtype==etSQLESCAPE2 ? \"NULL\" : \"(NULL)\");\n        k = precision;\n        for(i=n=0; k!=0 && (ch=escarg[i])!=0; i++, k--){\n          if( ch==q )  n++;\n        }\n        needQuote = !isnull && xtype==etSQLESCAPE2;\n        n += i + 1 + needQuote*2;\n        if( n>etBUFSIZE ){\n          bufpt = zExtra = sqlite3Malloc( n );\n          if( bufpt==0 ){\n            pAccum->mallocFailed = 1;\n            return;\n          }\n        }else{\n          bufpt = buf;\n        }\n        j = 0;\n        if( needQuote ) bufpt[j++] = q;\n        k = i;\n        for(i=0; i<k; i++){\n          bufpt[j++] = ch = escarg[i];\n          if( ch==q ) bufpt[j++] = ch;\n        }\n        if( needQuote ) bufpt[j++] = q;\n        bufpt[j] = 0;\n        length = j;\n        /* The precision in %q and %Q means how many input characters to\n        ** consume, not the length of the output...\n        ** if( precision>=0 && precision<length ) length = precision; */\n        break;\n      }\n      case etTOKEN: {\n        Token *pToken = va_arg(ap, Token*);\n        if( pToken ){\n          sqlite3StrAccumAppend(pAccum, (const char*)pToken->z, pToken->n);\n        }\n        length = width = 0;\n        break;\n      }\n      case etSRCLIST: {\n        SrcList *pSrc = va_arg(ap, SrcList*);\n        int k = va_arg(ap, int);\n        struct SrcList_item *pItem = &pSrc->a[k];\n        assert( k>=0 && k<pSrc->nSrc );\n        if( pItem->zDatabase ){\n          sqlite3StrAccumAppend(pAccum, pItem->zDatabase, -1);\n          sqlite3StrAccumAppend(pAccum, \".\", 1);\n        }\n        sqlite3StrAccumAppend(pAccum, pItem->zName, -1);\n        length = width = 0;\n        break;\n      }\n      default: {\n        assert( xtype==etINVALID );\n        return;\n      }\n    }/* End switch over the format type */\n    /*\n    ** The text of the conversion is pointed to by \"bufpt\" and is\n    ** \"length\" characters long.  The field width is \"width\".  Do\n    ** the output.\n    */\n    if( !flag_leftjustify ){\n      register int nspace;\n      nspace = width-length;\n      if( nspace>0 ){\n        appendSpace(pAccum, nspace);\n      }\n    }\n    if( length>0 ){\n      sqlite3StrAccumAppend(pAccum, bufpt, length);\n    }\n    if( flag_leftjustify ){\n      register int nspace;\n      nspace = width-length;\n      if( nspace>0 ){\n        appendSpace(pAccum, nspace);\n      }\n    }\n    if( zExtra ){\n      sqlite3_free(zExtra);\n    }\n  }/* End for loop over the format string */\n} /* End of function */\n\n/*\n** Append N bytes of text from z to the StrAccum object.\n*/\nSQLITE_PRIVATE void sqlite3StrAccumAppend(StrAccum *p, const char *z, int N){\n  assert( z!=0 || N==0 );\n  if( p->tooBig | p->mallocFailed ){\n    testcase(p->tooBig);\n    testcase(p->mallocFailed);\n    return;\n  }\n  if( N<0 ){\n    N = sqlite3Strlen30(z);\n  }\n  if( N==0 || NEVER(z==0) ){\n    return;\n  }\n  if( p->nChar+N >= p->nAlloc ){\n    char *zNew;\n    if( !p->useMalloc ){\n      p->tooBig = 1;\n      N = p->nAlloc - p->nChar - 1;\n      if( N<=0 ){\n        return;\n      }\n    }else{\n      char *zOld = (p->zText==p->zBase ? 0 : p->zText);\n      i64 szNew = p->nChar;\n      szNew += N + 1;\n      if( szNew > p->mxAlloc ){\n        sqlite3StrAccumReset(p);\n        p->tooBig = 1;\n        return;\n      }else{\n        p->nAlloc = (int)szNew;\n      }\n      if( p->useMalloc==1 ){\n        zNew = sqlite3DbRealloc(p->db, zOld, p->nAlloc);\n      }else{\n        zNew = sqlite3_realloc(zOld, p->nAlloc);\n      }\n      if( zNew ){\n        if( zOld==0 ) memcpy(zNew, p->zText, p->nChar);\n        p->zText = zNew;\n      }else{\n        p->mallocFailed = 1;\n        sqlite3StrAccumReset(p);\n        return;\n      }\n    }\n  }\n  memcpy(&p->zText[p->nChar], z, N);\n  p->nChar += N;\n}\n\n/*\n** Finish off a string by making sure it is zero-terminated.\n** Return a pointer to the resulting string.  Return a NULL\n** pointer if any kind of error was encountered.\n*/\nSQLITE_PRIVATE char *sqlite3StrAccumFinish(StrAccum *p){\n  if( p->zText ){\n    p->zText[p->nChar] = 0;\n    if( p->useMalloc && p->zText==p->zBase ){\n      if( p->useMalloc==1 ){\n        p->zText = sqlite3DbMallocRaw(p->db, p->nChar+1 );\n      }else{\n        p->zText = sqlite3_malloc(p->nChar+1);\n      }\n      if( p->zText ){\n        memcpy(p->zText, p->zBase, p->nChar+1);\n      }else{\n        p->mallocFailed = 1;\n      }\n    }\n  }\n  return p->zText;\n}\n\n/*\n** Reset an StrAccum string.  Reclaim all malloced memory.\n*/\nSQLITE_PRIVATE void sqlite3StrAccumReset(StrAccum *p){\n  if( p->zText!=p->zBase ){\n    if( p->useMalloc==1 ){\n      sqlite3DbFree(p->db, p->zText);\n    }else{\n      sqlite3_free(p->zText);\n    }\n  }\n  p->zText = 0;\n}\n\n/*\n** Initialize a string accumulator\n*/\nSQLITE_PRIVATE void sqlite3StrAccumInit(StrAccum *p, char *zBase, int n, int mx){\n  p->zText = p->zBase = zBase;\n  p->db = 0;\n  p->nChar = 0;\n  p->nAlloc = n;\n  p->mxAlloc = mx;\n  p->useMalloc = 1;\n  p->tooBig = 0;\n  p->mallocFailed = 0;\n}\n\n/*\n** Print into memory obtained from sqliteMalloc().  Use the internal\n** %-conversion extensions.\n*/\nSQLITE_PRIVATE char *sqlite3VMPrintf(sqlite3 *db, const char *zFormat, va_list ap){\n  char *z;\n  char zBase[SQLITE_PRINT_BUF_SIZE];\n  StrAccum acc;\n  assert( db!=0 );\n  sqlite3StrAccumInit(&acc, zBase, sizeof(zBase),\n                      db->aLimit[SQLITE_LIMIT_LENGTH]);\n  acc.db = db;\n  sqlite3VXPrintf(&acc, 1, zFormat, ap);\n  z = sqlite3StrAccumFinish(&acc);\n  if( acc.mallocFailed ){\n    db->mallocFailed = 1;\n  }\n  return z;\n}\n\n/*\n** Print into memory obtained from sqliteMalloc().  Use the internal\n** %-conversion extensions.\n*/\nSQLITE_PRIVATE char *sqlite3MPrintf(sqlite3 *db, const char *zFormat, ...){\n  va_list ap;\n  char *z;\n  va_start(ap, zFormat);\n  z = sqlite3VMPrintf(db, zFormat, ap);\n  va_end(ap);\n  return z;\n}\n\n/*\n** Like sqlite3MPrintf(), but call sqlite3DbFree() on zStr after formatting\n** the string and before returnning.  This routine is intended to be used\n** to modify an existing string.  For example:\n**\n**       x = sqlite3MPrintf(db, x, \"prefix %s suffix\", x);\n**\n*/\nSQLITE_PRIVATE char *sqlite3MAppendf(sqlite3 *db, char *zStr, const char *zFormat, ...){\n  va_list ap;\n  char *z;\n  va_start(ap, zFormat);\n  z = sqlite3VMPrintf(db, zFormat, ap);\n  va_end(ap);\n  sqlite3DbFree(db, zStr);\n  return z;\n}\n\n/*\n** Print into memory obtained from sqlite3_malloc().  Omit the internal\n** %-conversion extensions.\n*/\nSQLITE_API char *sqlite3_vmprintf(const char *zFormat, va_list ap){\n  char *z;\n  char zBase[SQLITE_PRINT_BUF_SIZE];\n  StrAccum acc;\n#ifndef SQLITE_OMIT_AUTOINIT\n  if( sqlite3_initialize() ) return 0;\n#endif\n  sqlite3StrAccumInit(&acc, zBase, sizeof(zBase), SQLITE_MAX_LENGTH);\n  acc.useMalloc = 2;\n  sqlite3VXPrintf(&acc, 0, zFormat, ap);\n  z = sqlite3StrAccumFinish(&acc);\n  return z;\n}\n\n/*\n** Print into memory obtained from sqlite3_malloc()().  Omit the internal\n** %-conversion extensions.\n*/\nSQLITE_API char *sqlite3_mprintf(const char *zFormat, ...){\n  va_list ap;\n  char *z;\n#ifndef SQLITE_OMIT_AUTOINIT\n  if( sqlite3_initialize() ) return 0;\n#endif\n  va_start(ap, zFormat);\n  z = sqlite3_vmprintf(zFormat, ap);\n  va_end(ap);\n  return z;\n}\n\n/*\n** sqlite3_snprintf() works like snprintf() except that it ignores the\n** current locale settings.  This is important for SQLite because we\n** are not able to use a \",\" as the decimal point in place of \".\" as\n** specified by some locales.\n**\n** Oops:  The first two arguments of sqlite3_snprintf() are backwards\n** from the snprintf() standard.  Unfortunately, it is too late to change\n** this without breaking compatibility, so we just have to live with the\n** mistake.\n**\n** sqlite3_vsnprintf() is the varargs version.\n*/\nSQLITE_API char *sqlite3_vsnprintf(int n, char *zBuf, const char *zFormat, va_list ap){\n  StrAccum acc;\n  if( n<=0 ) return zBuf;\n  sqlite3StrAccumInit(&acc, zBuf, n, 0);\n  acc.useMalloc = 0;\n  sqlite3VXPrintf(&acc, 0, zFormat, ap);\n  return sqlite3StrAccumFinish(&acc);\n}\nSQLITE_API char *sqlite3_snprintf(int n, char *zBuf, const char *zFormat, ...){\n  char *z;\n  va_list ap;\n  va_start(ap,zFormat);\n  z = sqlite3_vsnprintf(n, zBuf, zFormat, ap);\n  va_end(ap);\n  return z;\n}\n\n/*\n** This is the routine that actually formats the sqlite3_log() message.\n** We house it in a separate routine from sqlite3_log() to avoid using\n** stack space on small-stack systems when logging is disabled.\n**\n** sqlite3_log() must render into a static buffer.  It cannot dynamically\n** allocate memory because it might be called while the memory allocator\n** mutex is held.\n*/\nstatic void renderLogMsg(int iErrCode, const char *zFormat, va_list ap){\n  StrAccum acc;                          /* String accumulator */\n  char zMsg[SQLITE_PRINT_BUF_SIZE*3];    /* Complete log message */\n\n  sqlite3StrAccumInit(&acc, zMsg, sizeof(zMsg), 0);\n  acc.useMalloc = 0;\n  sqlite3VXPrintf(&acc, 0, zFormat, ap);\n  sqlite3GlobalConfig.xLog(sqlite3GlobalConfig.pLogArg, iErrCode,\n                           sqlite3StrAccumFinish(&acc));\n}\n\n/*\n** Format and write a message to the log if logging is enabled.\n*/\nSQLITE_API void sqlite3_log(int iErrCode, const char *zFormat, ...){\n  va_list ap;                             /* Vararg list */\n  if( sqlite3GlobalConfig.xLog ){\n    va_start(ap, zFormat);\n    renderLogMsg(iErrCode, zFormat, ap);\n    va_end(ap);\n  }\n}\n\n#if defined(SQLITE_DEBUG)\n/*\n** A version of printf() that understands %lld.  Used for debugging.\n** The printf() built into some versions of windows does not understand %lld\n** and segfaults if you give it a long long int.\n*/\nSQLITE_PRIVATE void sqlite3DebugPrintf(const char *zFormat, ...){\n  va_list ap;\n  StrAccum acc;\n  char zBuf[500];\n  sqlite3StrAccumInit(&acc, zBuf, sizeof(zBuf), 0);\n  acc.useMalloc = 0;\n  va_start(ap,zFormat);\n  sqlite3VXPrintf(&acc, 0, zFormat, ap);\n  va_end(ap);\n  sqlite3StrAccumFinish(&acc);\n  fprintf(stdout,\"%s\", zBuf);\n  fflush(stdout);\n}\n#endif\n\n#ifndef SQLITE_OMIT_TRACE\n/*\n** variable-argument wrapper around sqlite3VXPrintf().\n*/\nSQLITE_PRIVATE void sqlite3XPrintf(StrAccum *p, const char *zFormat, ...){\n  va_list ap;\n  va_start(ap,zFormat);\n  sqlite3VXPrintf(p, 1, zFormat, ap);\n  va_end(ap);\n}\n#endif\n\n/************** End of printf.c **********************************************/\n/************** Begin file random.c ******************************************/\n/*\n** 2001 September 15\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains code to implement a pseudo-random number\n** generator (PRNG) for SQLite.\n**\n** Random numbers are used by some of the database backends in order\n** to generate random integer keys for tables or random filenames.\n*/\n\n\n/* All threads share a single random number generator.\n** This structure is the current state of the generator.\n*/\nstatic SQLITE_WSD struct sqlite3PrngType {\n  unsigned char isInit;          /* True if initialized */\n  unsigned char i, j;            /* State variables */\n  unsigned char s[256];          /* State variables */\n} sqlite3Prng;\n\n/*\n** Get a single 8-bit random value from the RC4 PRNG.  The Mutex\n** must be held while executing this routine.\n**\n** Why not just use a library random generator like lrand48() for this?\n** Because the OP_NewRowid opcode in the VDBE depends on having a very\n** good source of random numbers.  The lrand48() library function may\n** well be good enough.  But maybe not.  Or maybe lrand48() has some\n** subtle problems on some systems that could cause problems.  It is hard\n** to know.  To minimize the risk of problems due to bad lrand48()\n** implementations, SQLite uses this random number generator based\n** on RC4, which we know works very well.\n**\n** (Later):  Actually, OP_NewRowid does not depend on a good source of\n** randomness any more.  But we will leave this code in all the same.\n*/\nstatic u8 randomByte(void){\n  unsigned char t;\n\n\n  /* The \"wsdPrng\" macro will resolve to the pseudo-random number generator\n  ** state vector.  If writable static data is unsupported on the target,\n  ** we have to locate the state vector at run-time.  In the more common\n  ** case where writable static data is supported, wsdPrng can refer directly\n  ** to the \"sqlite3Prng\" state vector declared above.\n  */\n#ifdef SQLITE_OMIT_WSD\n  struct sqlite3PrngType *p = &GLOBAL(struct sqlite3PrngType, sqlite3Prng);\n# define wsdPrng p[0]\n#else\n# define wsdPrng sqlite3Prng\n#endif\n\n\n  /* Initialize the state of the random number generator once,\n  ** the first time this routine is called.  The seed value does\n  ** not need to contain a lot of randomness since we are not\n  ** trying to do secure encryption or anything like that...\n  **\n  ** Nothing in this file or anywhere else in SQLite does any kind of\n  ** encryption.  The RC4 algorithm is being used as a PRNG (pseudo-random\n  ** number generator) not as an encryption device.\n  */\n  if( !wsdPrng.isInit ){\n    int i;\n    char k[256];\n    wsdPrng.j = 0;\n    wsdPrng.i = 0;\n    sqlite3OsRandomness(sqlite3_vfs_find(0), 256, k);\n    for(i=0; i<256; i++){\n      wsdPrng.s[i] = (u8)i;\n    }\n    for(i=0; i<256; i++){\n      wsdPrng.j += wsdPrng.s[i] + k[i];\n      t = wsdPrng.s[wsdPrng.j];\n      wsdPrng.s[wsdPrng.j] = wsdPrng.s[i];\n      wsdPrng.s[i] = t;\n    }\n    wsdPrng.isInit = 1;\n  }\n\n  /* Generate and return single random byte\n  */\n  wsdPrng.i++;\n  t = wsdPrng.s[wsdPrng.i];\n  wsdPrng.j += t;\n  wsdPrng.s[wsdPrng.i] = wsdPrng.s[wsdPrng.j];\n  wsdPrng.s[wsdPrng.j] = t;\n  t += wsdPrng.s[wsdPrng.i];\n  return wsdPrng.s[t];\n}\n\n/*\n** Return N random bytes.\n*/\nSQLITE_API void sqlite3_randomness(int N, void *pBuf){\n  unsigned char *zBuf = pBuf;\n#if SQLITE_THREADSAFE\n  sqlite3_mutex *mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_PRNG);\n#endif\n  sqlite3_mutex_enter(mutex);\n  while( N-- ){\n    *(zBuf++) = randomByte();\n  }\n  sqlite3_mutex_leave(mutex);\n}\n\n#ifndef SQLITE_OMIT_BUILTIN_TEST\n/*\n** For testing purposes, we sometimes want to preserve the state of\n** PRNG and restore the PRNG to its saved state at a later time, or\n** to reset the PRNG to its initial state.  These routines accomplish\n** those tasks.\n**\n** The sqlite3_test_control() interface calls these routines to\n** control the PRNG.\n*/\nstatic SQLITE_WSD struct sqlite3PrngType sqlite3SavedPrng;\nSQLITE_PRIVATE void sqlite3PrngSaveState(void){\n  memcpy(\n    &GLOBAL(struct sqlite3PrngType, sqlite3SavedPrng),\n    &GLOBAL(struct sqlite3PrngType, sqlite3Prng),\n    sizeof(sqlite3Prng)\n  );\n}\nSQLITE_PRIVATE void sqlite3PrngRestoreState(void){\n  memcpy(\n    &GLOBAL(struct sqlite3PrngType, sqlite3Prng),\n    &GLOBAL(struct sqlite3PrngType, sqlite3SavedPrng),\n    sizeof(sqlite3Prng)\n  );\n}\nSQLITE_PRIVATE void sqlite3PrngResetState(void){\n  GLOBAL(struct sqlite3PrngType, sqlite3Prng).isInit = 0;\n}\n#endif /* SQLITE_OMIT_BUILTIN_TEST */\n\n/************** End of random.c **********************************************/\n/************** Begin file utf.c *********************************************/\n/*\n** 2004 April 13\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains routines used to translate between UTF-8, \n** UTF-16, UTF-16BE, and UTF-16LE.\n**\n** Notes on UTF-8:\n**\n**   Byte-0    Byte-1    Byte-2    Byte-3    Value\n**  0xxxxxxx                                 00000000 00000000 0xxxxxxx\n**  110yyyyy  10xxxxxx                       00000000 00000yyy yyxxxxxx\n**  1110zzzz  10yyyyyy  10xxxxxx             00000000 zzzzyyyy yyxxxxxx\n**  11110uuu  10uuzzzz  10yyyyyy  10xxxxxx   000uuuuu zzzzyyyy yyxxxxxx\n**\n**\n** Notes on UTF-16:  (with wwww+1==uuuuu)\n**\n**      Word-0               Word-1          Value\n**  110110ww wwzzzzyy   110111yy yyxxxxxx    000uuuuu zzzzyyyy yyxxxxxx\n**  zzzzyyyy yyxxxxxx                        00000000 zzzzyyyy yyxxxxxx\n**\n**\n** BOM or Byte Order Mark:\n**     0xff 0xfe   little-endian utf-16 follows\n**     0xfe 0xff   big-endian utf-16 follows\n**\n*/\n\n#ifndef SQLITE_AMALGAMATION\n/*\n** The following constant value is used by the SQLITE_BIGENDIAN and\n** SQLITE_LITTLEENDIAN macros.\n*/\nSQLITE_PRIVATE const int sqlite3one = 1;\n#endif /* SQLITE_AMALGAMATION */\n\n/*\n** This lookup table is used to help decode the first byte of\n** a multi-byte UTF8 character.\n*/\nstatic const unsigned char sqlite3Utf8Trans1[] = {\n  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n  0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n  0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f,\n  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n  0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n  0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n  0x00, 0x01, 0x02, 0x03, 0x00, 0x01, 0x00, 0x00,\n};\n\n\n#define WRITE_UTF8(zOut, c) {                          \\\n  if( c<0x00080 ){                                     \\\n    *zOut++ = (u8)(c&0xFF);                            \\\n  }                                                    \\\n  else if( c<0x00800 ){                                \\\n    *zOut++ = 0xC0 + (u8)((c>>6)&0x1F);                \\\n    *zOut++ = 0x80 + (u8)(c & 0x3F);                   \\\n  }                                                    \\\n  else if( c<0x10000 ){                                \\\n    *zOut++ = 0xE0 + (u8)((c>>12)&0x0F);               \\\n    *zOut++ = 0x80 + (u8)((c>>6) & 0x3F);              \\\n    *zOut++ = 0x80 + (u8)(c & 0x3F);                   \\\n  }else{                                               \\\n    *zOut++ = 0xF0 + (u8)((c>>18) & 0x07);             \\\n    *zOut++ = 0x80 + (u8)((c>>12) & 0x3F);             \\\n    *zOut++ = 0x80 + (u8)((c>>6) & 0x3F);              \\\n    *zOut++ = 0x80 + (u8)(c & 0x3F);                   \\\n  }                                                    \\\n}\n\n#define WRITE_UTF16LE(zOut, c) {                                    \\\n  if( c<=0xFFFF ){                                                  \\\n    *zOut++ = (u8)(c&0x00FF);                                       \\\n    *zOut++ = (u8)((c>>8)&0x00FF);                                  \\\n  }else{                                                            \\\n    *zOut++ = (u8)(((c>>10)&0x003F) + (((c-0x10000)>>10)&0x00C0));  \\\n    *zOut++ = (u8)(0x00D8 + (((c-0x10000)>>18)&0x03));              \\\n    *zOut++ = (u8)(c&0x00FF);                                       \\\n    *zOut++ = (u8)(0x00DC + ((c>>8)&0x03));                         \\\n  }                                                                 \\\n}\n\n#define WRITE_UTF16BE(zOut, c) {                                    \\\n  if( c<=0xFFFF ){                                                  \\\n    *zOut++ = (u8)((c>>8)&0x00FF);                                  \\\n    *zOut++ = (u8)(c&0x00FF);                                       \\\n  }else{                                                            \\\n    *zOut++ = (u8)(0x00D8 + (((c-0x10000)>>18)&0x03));              \\\n    *zOut++ = (u8)(((c>>10)&0x003F) + (((c-0x10000)>>10)&0x00C0));  \\\n    *zOut++ = (u8)(0x00DC + ((c>>8)&0x03));                         \\\n    *zOut++ = (u8)(c&0x00FF);                                       \\\n  }                                                                 \\\n}\n\n#define READ_UTF16LE(zIn, TERM, c){                                   \\\n  c = (*zIn++);                                                       \\\n  c += ((*zIn++)<<8);                                                 \\\n  if( c>=0xD800 && c<0xE000 && TERM ){                                \\\n    int c2 = (*zIn++);                                                \\\n    c2 += ((*zIn++)<<8);                                              \\\n    c = (c2&0x03FF) + ((c&0x003F)<<10) + (((c&0x03C0)+0x0040)<<10);   \\\n  }                                                                   \\\n}\n\n#define READ_UTF16BE(zIn, TERM, c){                                   \\\n  c = ((*zIn++)<<8);                                                  \\\n  c += (*zIn++);                                                      \\\n  if( c>=0xD800 && c<0xE000 && TERM ){                                \\\n    int c2 = ((*zIn++)<<8);                                           \\\n    c2 += (*zIn++);                                                   \\\n    c = (c2&0x03FF) + ((c&0x003F)<<10) + (((c&0x03C0)+0x0040)<<10);   \\\n  }                                                                   \\\n}\n\n/*\n** Translate a single UTF-8 character.  Return the unicode value.\n**\n** During translation, assume that the byte that zTerm points\n** is a 0x00.\n**\n** Write a pointer to the next unread byte back into *pzNext.\n**\n** Notes On Invalid UTF-8:\n**\n**  *  This routine never allows a 7-bit character (0x00 through 0x7f) to\n**     be encoded as a multi-byte character.  Any multi-byte character that\n**     attempts to encode a value between 0x00 and 0x7f is rendered as 0xfffd.\n**\n**  *  This routine never allows a UTF16 surrogate value to be encoded.\n**     If a multi-byte character attempts to encode a value between\n**     0xd800 and 0xe000 then it is rendered as 0xfffd.\n**\n**  *  Bytes in the range of 0x80 through 0xbf which occur as the first\n**     byte of a character are interpreted as single-byte characters\n**     and rendered as themselves even though they are technically\n**     invalid characters.\n**\n**  *  This routine accepts an infinite number of different UTF8 encodings\n**     for unicode values 0x80 and greater.  It do not change over-length\n**     encodings to 0xfffd as some systems recommend.\n*/\n#define READ_UTF8(zIn, zTerm, c)                           \\\n  c = *(zIn++);                                            \\\n  if( c>=0xc0 ){                                           \\\n    c = sqlite3Utf8Trans1[c-0xc0];                         \\\n    while( zIn!=zTerm && (*zIn & 0xc0)==0x80 ){            \\\n      c = (c<<6) + (0x3f & *(zIn++));                      \\\n    }                                                      \\\n    if( c<0x80                                             \\\n        || (c&0xFFFFF800)==0xD800                          \\\n        || (c&0xFFFFFFFE)==0xFFFE ){  c = 0xFFFD; }        \\\n  }\nSQLITE_PRIVATE int sqlite3Utf8Read(\n  const unsigned char *zIn,       /* First byte of UTF-8 character */\n  const unsigned char **pzNext    /* Write first byte past UTF-8 char here */\n){\n  int c;\n\n  /* Same as READ_UTF8() above but without the zTerm parameter.\n  ** For this routine, we assume the UTF8 string is always zero-terminated.\n  */\n  c = *(zIn++);\n  if( c>=0xc0 ){\n    c = sqlite3Utf8Trans1[c-0xc0];\n    while( (*zIn & 0xc0)==0x80 ){\n      c = (c<<6) + (0x3f & *(zIn++));\n    }\n    if( c<0x80\n        || (c&0xFFFFF800)==0xD800\n        || (c&0xFFFFFFFE)==0xFFFE ){  c = 0xFFFD; }\n  }\n  *pzNext = zIn;\n  return c;\n}\n\n\n\n\n/*\n** If the TRANSLATE_TRACE macro is defined, the value of each Mem is\n** printed on stderr on the way into and out of sqlite3VdbeMemTranslate().\n*/ \n/* #define TRANSLATE_TRACE 1 */\n\n#ifndef SQLITE_OMIT_UTF16\n/*\n** This routine transforms the internal text encoding used by pMem to\n** desiredEnc. It is an error if the string is already of the desired\n** encoding, or if *pMem does not contain a string value.\n*/\nSQLITE_PRIVATE int sqlite3VdbeMemTranslate(Mem *pMem, u8 desiredEnc){\n  int len;                    /* Maximum length of output string in bytes */\n  unsigned char *zOut;                  /* Output buffer */\n  unsigned char *zIn;                   /* Input iterator */\n  unsigned char *zTerm;                 /* End of input */\n  unsigned char *z;                     /* Output iterator */\n  unsigned int c;\n\n  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );\n  assert( pMem->flags&MEM_Str );\n  assert( pMem->enc!=desiredEnc );\n  assert( pMem->enc!=0 );\n  assert( pMem->n>=0 );\n\n#if defined(TRANSLATE_TRACE) && defined(SQLITE_DEBUG)\n  {\n    char zBuf[100];\n    sqlite3VdbeMemPrettyPrint(pMem, zBuf);\n    fprintf(stderr, \"INPUT:  %s\\n\", zBuf);\n  }\n#endif\n\n  /* If the translation is between UTF-16 little and big endian, then \n  ** all that is required is to swap the byte order. This case is handled\n  ** differently from the others.\n  */\n  if( pMem->enc!=SQLITE_UTF8 && desiredEnc!=SQLITE_UTF8 ){\n    u8 temp;\n    int rc;\n    rc = sqlite3VdbeMemMakeWriteable(pMem);\n    if( rc!=SQLITE_OK ){\n      assert( rc==SQLITE_NOMEM );\n      return SQLITE_NOMEM;\n    }\n    zIn = (u8*)pMem->z;\n    zTerm = &zIn[pMem->n&~1];\n    while( zIn<zTerm ){\n      temp = *zIn;\n      *zIn = *(zIn+1);\n      zIn++;\n      *zIn++ = temp;\n    }\n    pMem->enc = desiredEnc;\n    goto translate_out;\n  }\n\n  /* Set len to the maximum number of bytes required in the output buffer. */\n  if( desiredEnc==SQLITE_UTF8 ){\n    /* When converting from UTF-16, the maximum growth results from\n    ** translating a 2-byte character to a 4-byte UTF-8 character.\n    ** A single byte is required for the output string\n    ** nul-terminator.\n    */\n    pMem->n &= ~1;\n    len = pMem->n * 2 + 1;\n  }else{\n    /* When converting from UTF-8 to UTF-16 the maximum growth is caused\n    ** when a 1-byte UTF-8 character is translated into a 2-byte UTF-16\n    ** character. Two bytes are required in the output buffer for the\n    ** nul-terminator.\n    */\n    len = pMem->n * 2 + 2;\n  }\n\n  /* Set zIn to point at the start of the input buffer and zTerm to point 1\n  ** byte past the end.\n  **\n  ** Variable zOut is set to point at the output buffer, space obtained\n  ** from sqlite3_malloc().\n  */\n  zIn = (u8*)pMem->z;\n  zTerm = &zIn[pMem->n];\n  zOut = sqlite3DbMallocRaw(pMem->db, len);\n  if( !zOut ){\n    return SQLITE_NOMEM;\n  }\n  z = zOut;\n\n  if( pMem->enc==SQLITE_UTF8 ){\n    if( desiredEnc==SQLITE_UTF16LE ){\n      /* UTF-8 -> UTF-16 Little-endian */\n      while( zIn<zTerm ){\n        /* c = sqlite3Utf8Read(zIn, zTerm, (const u8**)&zIn); */\n        READ_UTF8(zIn, zTerm, c);\n        WRITE_UTF16LE(z, c);\n      }\n    }else{\n      assert( desiredEnc==SQLITE_UTF16BE );\n      /* UTF-8 -> UTF-16 Big-endian */\n      while( zIn<zTerm ){\n        /* c = sqlite3Utf8Read(zIn, zTerm, (const u8**)&zIn); */\n        READ_UTF8(zIn, zTerm, c);\n        WRITE_UTF16BE(z, c);\n      }\n    }\n    pMem->n = (int)(z - zOut);\n    *z++ = 0;\n  }else{\n    assert( desiredEnc==SQLITE_UTF8 );\n    if( pMem->enc==SQLITE_UTF16LE ){\n      /* UTF-16 Little-endian -> UTF-8 */\n      while( zIn<zTerm ){\n        READ_UTF16LE(zIn, zIn<zTerm, c); \n        WRITE_UTF8(z, c);\n      }\n    }else{\n      /* UTF-16 Big-endian -> UTF-8 */\n      while( zIn<zTerm ){\n        READ_UTF16BE(zIn, zIn<zTerm, c); \n        WRITE_UTF8(z, c);\n      }\n    }\n    pMem->n = (int)(z - zOut);\n  }\n  *z = 0;\n  assert( (pMem->n+(desiredEnc==SQLITE_UTF8?1:2))<=len );\n\n  sqlite3VdbeMemRelease(pMem);\n  pMem->flags &= ~(MEM_Static|MEM_Dyn|MEM_Ephem);\n  pMem->enc = desiredEnc;\n  pMem->flags |= (MEM_Term|MEM_Dyn);\n  pMem->z = (char*)zOut;\n  pMem->zMalloc = pMem->z;\n\ntranslate_out:\n#if defined(TRANSLATE_TRACE) && defined(SQLITE_DEBUG)\n  {\n    char zBuf[100];\n    sqlite3VdbeMemPrettyPrint(pMem, zBuf);\n    fprintf(stderr, \"OUTPUT: %s\\n\", zBuf);\n  }\n#endif\n  return SQLITE_OK;\n}\n\n/*\n** This routine checks for a byte-order mark at the beginning of the \n** UTF-16 string stored in *pMem. If one is present, it is removed and\n** the encoding of the Mem adjusted. This routine does not do any\n** byte-swapping, it just sets Mem.enc appropriately.\n**\n** The allocation (static, dynamic etc.) and encoding of the Mem may be\n** changed by this function.\n*/\nSQLITE_PRIVATE int sqlite3VdbeMemHandleBom(Mem *pMem){\n  int rc = SQLITE_OK;\n  u8 bom = 0;\n\n  assert( pMem->n>=0 );\n  if( pMem->n>1 ){\n    u8 b1 = *(u8 *)pMem->z;\n    u8 b2 = *(((u8 *)pMem->z) + 1);\n    if( b1==0xFE && b2==0xFF ){\n      bom = SQLITE_UTF16BE;\n    }\n    if( b1==0xFF && b2==0xFE ){\n      bom = SQLITE_UTF16LE;\n    }\n  }\n  \n  if( bom ){\n    rc = sqlite3VdbeMemMakeWriteable(pMem);\n    if( rc==SQLITE_OK ){\n      pMem->n -= 2;\n      memmove(pMem->z, &pMem->z[2], pMem->n);\n      pMem->z[pMem->n] = '\\0';\n      pMem->z[pMem->n+1] = '\\0';\n      pMem->flags |= MEM_Term;\n      pMem->enc = bom;\n    }\n  }\n  return rc;\n}\n#endif /* SQLITE_OMIT_UTF16 */\n\n/*\n** pZ is a UTF-8 encoded unicode string. If nByte is less than zero,\n** return the number of unicode characters in pZ up to (but not including)\n** the first 0x00 byte. If nByte is not less than zero, return the\n** number of unicode characters in the first nByte of pZ (or up to \n** the first 0x00, whichever comes first).\n*/\nSQLITE_PRIVATE int sqlite3Utf8CharLen(const char *zIn, int nByte){\n  int r = 0;\n  const u8 *z = (const u8*)zIn;\n  const u8 *zTerm;\n  if( nByte>=0 ){\n    zTerm = &z[nByte];\n  }else{\n    zTerm = (const u8*)(-1);\n  }\n  assert( z<=zTerm );\n  while( *z!=0 && z<zTerm ){\n    SQLITE_SKIP_UTF8(z);\n    r++;\n  }\n  return r;\n}\n\n/* This test function is not currently used by the automated test-suite. \n** Hence it is only available in debug builds.\n*/\n#if defined(SQLITE_TEST) && defined(SQLITE_DEBUG)\n/*\n** Translate UTF-8 to UTF-8.\n**\n** This has the effect of making sure that the string is well-formed\n** UTF-8.  Miscoded characters are removed.\n**\n** The translation is done in-place (since it is impossible for the\n** correct UTF-8 encoding to be longer than a malformed encoding).\n*/\nSQLITE_PRIVATE int sqlite3Utf8To8(unsigned char *zIn){\n  unsigned char *zOut = zIn;\n  unsigned char *zStart = zIn;\n  u32 c;\n\n  while( zIn[0] ){\n    c = sqlite3Utf8Read(zIn, (const u8**)&zIn);\n    if( c!=0xfffd ){\n      WRITE_UTF8(zOut, c);\n    }\n  }\n  *zOut = 0;\n  return (int)(zOut - zStart);\n}\n#endif\n\n#ifndef SQLITE_OMIT_UTF16\n/*\n** Convert a UTF-16 string in the native encoding into a UTF-8 string.\n** Memory to hold the UTF-8 string is obtained from sqlite3_malloc and must\n** be freed by the calling function.\n**\n** NULL is returned if there is an allocation error.\n*/\nSQLITE_PRIVATE char *sqlite3Utf16to8(sqlite3 *db, const void *z, int nByte, u8 enc){\n  Mem m;\n  memset(&m, 0, sizeof(m));\n  m.db = db;\n  sqlite3VdbeMemSetStr(&m, z, nByte, enc, SQLITE_STATIC);\n  sqlite3VdbeChangeEncoding(&m, SQLITE_UTF8);\n  if( db->mallocFailed ){\n    sqlite3VdbeMemRelease(&m);\n    m.z = 0;\n  }\n  assert( (m.flags & MEM_Term)!=0 || db->mallocFailed );\n  assert( (m.flags & MEM_Str)!=0 || db->mallocFailed );\n  assert( (m.flags & MEM_Dyn)!=0 || db->mallocFailed );\n  assert( m.z || db->mallocFailed );\n  return m.z;\n}\n\n/*\n** Convert a UTF-8 string to the UTF-16 encoding specified by parameter\n** enc. A pointer to the new string is returned, and the value of *pnOut\n** is set to the length of the returned string in bytes. The call should\n** arrange to call sqlite3DbFree() on the returned pointer when it is\n** no longer required.\n** \n** If a malloc failure occurs, NULL is returned and the db.mallocFailed\n** flag set.\n*/\n#ifdef SQLITE_ENABLE_STAT2\nSQLITE_PRIVATE char *sqlite3Utf8to16(sqlite3 *db, u8 enc, char *z, int n, int *pnOut){\n  Mem m;\n  memset(&m, 0, sizeof(m));\n  m.db = db;\n  sqlite3VdbeMemSetStr(&m, z, n, SQLITE_UTF8, SQLITE_STATIC);\n  if( sqlite3VdbeMemTranslate(&m, enc) ){\n    assert( db->mallocFailed );\n    return 0;\n  }\n  assert( m.z==m.zMalloc );\n  *pnOut = m.n;\n  return m.z;\n}\n#endif\n\n/*\n** zIn is a UTF-16 encoded unicode string at least nChar characters long.\n** Return the number of bytes in the first nChar unicode characters\n** in pZ.  nChar must be non-negative.\n*/\nSQLITE_PRIVATE int sqlite3Utf16ByteLen(const void *zIn, int nChar){\n  int c;\n  unsigned char const *z = zIn;\n  int n = 0;\n  \n  if( SQLITE_UTF16NATIVE==SQLITE_UTF16BE ){\n    while( n<nChar ){\n      READ_UTF16BE(z, 1, c);\n      n++;\n    }\n  }else{\n    while( n<nChar ){\n      READ_UTF16LE(z, 1, c);\n      n++;\n    }\n  }\n  return (int)(z-(unsigned char const *)zIn);\n}\n\n#if defined(SQLITE_TEST)\n/*\n** This routine is called from the TCL test function \"translate_selftest\".\n** It checks that the primitives for serializing and deserializing\n** characters in each encoding are inverses of each other.\n*/\nSQLITE_PRIVATE void sqlite3UtfSelfTest(void){\n  unsigned int i, t;\n  unsigned char zBuf[20];\n  unsigned char *z;\n  int n;\n  unsigned int c;\n\n  for(i=0; i<0x00110000; i++){\n    z = zBuf;\n    WRITE_UTF8(z, i);\n    n = (int)(z-zBuf);\n    assert( n>0 && n<=4 );\n    z[0] = 0;\n    z = zBuf;\n    c = sqlite3Utf8Read(z, (const u8**)&z);\n    t = i;\n    if( i>=0xD800 && i<=0xDFFF ) t = 0xFFFD;\n    if( (i&0xFFFFFFFE)==0xFFFE ) t = 0xFFFD;\n    assert( c==t );\n    assert( (z-zBuf)==n );\n  }\n  for(i=0; i<0x00110000; i++){\n    if( i>=0xD800 && i<0xE000 ) continue;\n    z = zBuf;\n    WRITE_UTF16LE(z, i);\n    n = (int)(z-zBuf);\n    assert( n>0 && n<=4 );\n    z[0] = 0;\n    z = zBuf;\n    READ_UTF16LE(z, 1, c);\n    assert( c==i );\n    assert( (z-zBuf)==n );\n  }\n  for(i=0; i<0x00110000; i++){\n    if( i>=0xD800 && i<0xE000 ) continue;\n    z = zBuf;\n    WRITE_UTF16BE(z, i);\n    n = (int)(z-zBuf);\n    assert( n>0 && n<=4 );\n    z[0] = 0;\n    z = zBuf;\n    READ_UTF16BE(z, 1, c);\n    assert( c==i );\n    assert( (z-zBuf)==n );\n  }\n}\n#endif /* SQLITE_TEST */\n#endif /* SQLITE_OMIT_UTF16 */\n\n/************** End of utf.c *************************************************/\n/************** Begin file util.c ********************************************/\n/*\n** 2001 September 15\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** Utility functions used throughout sqlite.\n**\n** This file contains functions for allocating memory, comparing\n** strings, and stuff like that.\n**\n*/\n#ifdef SQLITE_HAVE_ISNAN\n# include <math.h>\n#endif\n\n/*\n** Routine needed to support the testcase() macro.\n*/\n#ifdef SQLITE_COVERAGE_TEST\nSQLITE_PRIVATE void sqlite3Coverage(int x){\n  static int dummy = 0;\n  dummy += x;\n}\n#endif\n\n#ifndef SQLITE_OMIT_FLOATING_POINT\n/*\n** Return true if the floating point value is Not a Number (NaN).\n**\n** Use the math library isnan() function if compiled with SQLITE_HAVE_ISNAN.\n** Otherwise, we have our own implementation that works on most systems.\n*/\nSQLITE_PRIVATE int sqlite3IsNaN(double x){\n  int rc;   /* The value return */\n#if !defined(SQLITE_HAVE_ISNAN)\n  /*\n  ** Systems that support the isnan() library function should probably\n  ** make use of it by compiling with -DSQLITE_HAVE_ISNAN.  But we have\n  ** found that many systems do not have a working isnan() function so\n  ** this implementation is provided as an alternative.\n  **\n  ** This NaN test sometimes fails if compiled on GCC with -ffast-math.\n  ** On the other hand, the use of -ffast-math comes with the following\n  ** warning:\n  **\n  **      This option [-ffast-math] should never be turned on by any\n  **      -O option since it can result in incorrect output for programs\n  **      which depend on an exact implementation of IEEE or ISO \n  **      rules/specifications for math functions.\n  **\n  ** Under MSVC, this NaN test may fail if compiled with a floating-\n  ** point precision mode other than /fp:precise.  From the MSDN \n  ** documentation:\n  **\n  **      The compiler [with /fp:precise] will properly handle comparisons \n  **      involving NaN. For example, x != x evaluates to true if x is NaN \n  **      ...\n  */\n#ifdef __FAST_MATH__\n# error SQLite will not work correctly with the -ffast-math option of GCC.\n#endif\n  volatile double y = x;\n  volatile double z = y;\n  rc = (y!=z);\n#else  /* if defined(SQLITE_HAVE_ISNAN) */\n  rc = isnan(x);\n#endif /* SQLITE_HAVE_ISNAN */\n  testcase( rc );\n  return rc;\n}\n#endif /* SQLITE_OMIT_FLOATING_POINT */\n\n/*\n** Compute a string length that is limited to what can be stored in\n** lower 30 bits of a 32-bit signed integer.\n**\n** The value returned will never be negative.  Nor will it ever be greater\n** than the actual length of the string.  For very long strings (greater\n** than 1GiB) the value returned might be less than the true string length.\n*/\nSQLITE_PRIVATE int sqlite3Strlen30(const char *z){\n  const char *z2 = z;\n  if( z==0 ) return 0;\n  while( *z2 ){ z2++; }\n  return 0x3fffffff & (int)(z2 - z);\n}\n\n/*\n** Set the most recent error code and error string for the sqlite\n** handle \"db\". The error code is set to \"err_code\".\n**\n** If it is not NULL, string zFormat specifies the format of the\n** error string in the style of the printf functions: The following\n** format characters are allowed:\n**\n**      %s      Insert a string\n**      %z      A string that should be freed after use\n**      %d      Insert an integer\n**      %T      Insert a token\n**      %S      Insert the first element of a SrcList\n**\n** zFormat and any string tokens that follow it are assumed to be\n** encoded in UTF-8.\n**\n** To clear the most recent error for sqlite handle \"db\", sqlite3Error\n** should be called with err_code set to SQLITE_OK and zFormat set\n** to NULL.\n*/\nSQLITE_PRIVATE void sqlite3Error(sqlite3 *db, int err_code, const char *zFormat, ...){\n  if( db && (db->pErr || (db->pErr = sqlite3ValueNew(db))!=0) ){\n    db->errCode = err_code;\n    if( zFormat ){\n      char *z;\n      va_list ap;\n      va_start(ap, zFormat);\n      z = sqlite3VMPrintf(db, zFormat, ap);\n      va_end(ap);\n      sqlite3ValueSetStr(db->pErr, -1, z, SQLITE_UTF8, SQLITE_DYNAMIC);\n    }else{\n      sqlite3ValueSetStr(db->pErr, 0, 0, SQLITE_UTF8, SQLITE_STATIC);\n    }\n  }\n}\n\n/*\n** Add an error message to pParse->zErrMsg and increment pParse->nErr.\n** The following formatting characters are allowed:\n**\n**      %s      Insert a string\n**      %z      A string that should be freed after use\n**      %d      Insert an integer\n**      %T      Insert a token\n**      %S      Insert the first element of a SrcList\n**\n** This function should be used to report any error that occurs whilst\n** compiling an SQL statement (i.e. within sqlite3_prepare()). The\n** last thing the sqlite3_prepare() function does is copy the error\n** stored by this function into the database handle using sqlite3Error().\n** Function sqlite3Error() should be used during statement execution\n** (sqlite3_step() etc.).\n*/\nSQLITE_PRIVATE void sqlite3ErrorMsg(Parse *pParse, const char *zFormat, ...){\n  char *zMsg;\n  va_list ap;\n  sqlite3 *db = pParse->db;\n  va_start(ap, zFormat);\n  zMsg = sqlite3VMPrintf(db, zFormat, ap);\n  va_end(ap);\n  if( db->suppressErr ){\n    sqlite3DbFree(db, zMsg);\n  }else{\n    pParse->nErr++;\n    sqlite3DbFree(db, pParse->zErrMsg);\n    pParse->zErrMsg = zMsg;\n    pParse->rc = SQLITE_ERROR;\n  }\n}\n\n/*\n** Convert an SQL-style quoted string into a normal string by removing\n** the quote characters.  The conversion is done in-place.  If the\n** input does not begin with a quote character, then this routine\n** is a no-op.\n**\n** The input string must be zero-terminated.  A new zero-terminator\n** is added to the dequoted string.\n**\n** The return value is -1 if no dequoting occurs or the length of the\n** dequoted string, exclusive of the zero terminator, if dequoting does\n** occur.\n**\n** 2002-Feb-14: This routine is extended to remove MS-Access style\n** brackets from around identifers.  For example:  \"[a-b-c]\" becomes\n** \"a-b-c\".\n*/\nSQLITE_PRIVATE int sqlite3Dequote(char *z){\n  char quote;\n  int i, j;\n  if( z==0 ) return -1;\n  quote = z[0];\n  switch( quote ){\n    case '\\'':  break;\n    case '\"':   break;\n    case '`':   break;                /* For MySQL compatibility */\n    case '[':   quote = ']';  break;  /* For MS SqlServer compatibility */\n    default:    return -1;\n  }\n  for(i=1, j=0; ALWAYS(z[i]); i++){\n    if( z[i]==quote ){\n      if( z[i+1]==quote ){\n        z[j++] = quote;\n        i++;\n      }else{\n        break;\n      }\n    }else{\n      z[j++] = z[i];\n    }\n  }\n  z[j] = 0;\n  return j;\n}\n\n/* Convenient short-hand */\n#define UpperToLower sqlite3UpperToLower\n\n/*\n** Some systems have stricmp().  Others have strcasecmp().  Because\n** there is no consistency, we will define our own.\n**\n** IMPLEMENTATION-OF: R-20522-24639 The sqlite3_strnicmp() API allows\n** applications and extensions to compare the contents of two buffers\n** containing UTF-8 strings in a case-independent fashion, using the same\n** definition of case independence that SQLite uses internally when\n** comparing identifiers.\n*/\nSQLITE_PRIVATE int sqlite3StrICmp(const char *zLeft, const char *zRight){\n  register unsigned char *a, *b;\n  a = (unsigned char *)zLeft;\n  b = (unsigned char *)zRight;\n  while( *a!=0 && UpperToLower[*a]==UpperToLower[*b]){ a++; b++; }\n  return UpperToLower[*a] - UpperToLower[*b];\n}\nSQLITE_API int sqlite3_strnicmp(const char *zLeft, const char *zRight, int N){\n  register unsigned char *a, *b;\n  a = (unsigned char *)zLeft;\n  b = (unsigned char *)zRight;\n  while( N-- > 0 && *a!=0 && UpperToLower[*a]==UpperToLower[*b]){ a++; b++; }\n  return N<0 ? 0 : UpperToLower[*a] - UpperToLower[*b];\n}\n\n/*\n** The string z[] is an text representation of a real number.\n** Convert this string to a double and write it into *pResult.\n**\n** The string z[] is length bytes in length (bytes, not characters) and\n** uses the encoding enc.  The string is not necessarily zero-terminated.\n**\n** Return TRUE if the result is a valid real number (or integer) and FALSE\n** if the string is empty or contains extraneous text.  Valid numbers\n** are in one of these formats:\n**\n**    [+-]digits[E[+-]digits]\n**    [+-]digits.[digits][E[+-]digits]\n**    [+-].digits[E[+-]digits]\n**\n** Leading and trailing whitespace is ignored for the purpose of determining\n** validity.\n**\n** If some prefix of the input string is a valid number, this routine\n** returns FALSE but it still converts the prefix and writes the result\n** into *pResult.\n*/\nSQLITE_PRIVATE int sqlite3AtoF(const char *z, double *pResult, int length, u8 enc){\n#ifndef SQLITE_OMIT_FLOATING_POINT\n  int incr = (enc==SQLITE_UTF8?1:2);\n  const char *zEnd = z + length;\n  /* sign * significand * (10 ^ (esign * exponent)) */\n  int sign = 1;    /* sign of significand */\n  i64 s = 0;       /* significand */\n  int d = 0;       /* adjust exponent for shifting decimal point */\n  int esign = 1;   /* sign of exponent */\n  int e = 0;       /* exponent */\n  int eValid = 1;  /* True exponent is either not used or is well-formed */\n  double result;\n  int nDigits = 0;\n\n  *pResult = 0.0;   /* Default return value, in case of an error */\n\n  if( enc==SQLITE_UTF16BE ) z++;\n\n  /* skip leading spaces */\n  while( z<zEnd && sqlite3Isspace(*z) ) z+=incr;\n  if( z>=zEnd ) return 0;\n\n  /* get sign of significand */\n  if( *z=='-' ){\n    sign = -1;\n    z+=incr;\n  }else if( *z=='+' ){\n    z+=incr;\n  }\n\n  /* skip leading zeroes */\n  while( z<zEnd && z[0]=='0' ) z+=incr, nDigits++;\n\n  /* copy max significant digits to significand */\n  while( z<zEnd && sqlite3Isdigit(*z) && s<((LARGEST_INT64-9)/10) ){\n    s = s*10 + (*z - '0');\n    z+=incr, nDigits++;\n  }\n\n  /* skip non-significant significand digits\n  ** (increase exponent by d to shift decimal left) */\n  while( z<zEnd && sqlite3Isdigit(*z) ) z+=incr, nDigits++, d++;\n  if( z>=zEnd ) goto do_atof_calc;\n\n  /* if decimal point is present */\n  if( *z=='.' ){\n    z+=incr;\n    /* copy digits from after decimal to significand\n    ** (decrease exponent by d to shift decimal right) */\n    while( z<zEnd && sqlite3Isdigit(*z) && s<((LARGEST_INT64-9)/10) ){\n      s = s*10 + (*z - '0');\n      z+=incr, nDigits++, d--;\n    }\n    /* skip non-significant digits */\n    while( z<zEnd && sqlite3Isdigit(*z) ) z+=incr, nDigits++;\n  }\n  if( z>=zEnd ) goto do_atof_calc;\n\n  /* if exponent is present */\n  if( *z=='e' || *z=='E' ){\n    z+=incr;\n    eValid = 0;\n    if( z>=zEnd ) goto do_atof_calc;\n    /* get sign of exponent */\n    if( *z=='-' ){\n      esign = -1;\n      z+=incr;\n    }else if( *z=='+' ){\n      z+=incr;\n    }\n    /* copy digits to exponent */\n    while( z<zEnd && sqlite3Isdigit(*z) ){\n      e = e*10 + (*z - '0');\n      z+=incr;\n      eValid = 1;\n    }\n  }\n\n  /* skip trailing spaces */\n  if( nDigits && eValid ){\n    while( z<zEnd && sqlite3Isspace(*z) ) z+=incr;\n  }\n\ndo_atof_calc:\n  /* adjust exponent by d, and update sign */\n  e = (e*esign) + d;\n  if( e<0 ) {\n    esign = -1;\n    e *= -1;\n  } else {\n    esign = 1;\n  }\n\n  /* if 0 significand */\n  if( !s ) {\n    /* In the IEEE 754 standard, zero is signed.\n    ** Add the sign if we've seen at least one digit */\n    result = (sign<0 && nDigits) ? -(double)0 : (double)0;\n  } else {\n    /* attempt to reduce exponent */\n    if( esign>0 ){\n      while( s<(LARGEST_INT64/10) && e>0 ) e--,s*=10;\n    }else{\n      while( !(s%10) && e>0 ) e--,s/=10;\n    }\n\n    /* adjust the sign of significand */\n    s = sign<0 ? -s : s;\n\n    /* if exponent, scale significand as appropriate\n    ** and store in result. */\n    if( e ){\n      double scale = 1.0;\n      /* attempt to handle extremely small/large numbers better */\n      if( e>307 && e<342 ){\n        while( e%308 ) { scale *= 1.0e+1; e -= 1; }\n        if( esign<0 ){\n          result = s / scale;\n          result /= 1.0e+308;\n        }else{\n          result = s * scale;\n          result *= 1.0e+308;\n        }\n      }else{\n        /* 1.0e+22 is the largest power of 10 than can be \n        ** represented exactly. */\n        while( e%22 ) { scale *= 1.0e+1; e -= 1; }\n        while( e>0 ) { scale *= 1.0e+22; e -= 22; }\n        if( esign<0 ){\n          result = s / scale;\n        }else{\n          result = s * scale;\n        }\n      }\n    } else {\n      result = (double)s;\n    }\n  }\n\n  /* store the result */\n  *pResult = result;\n\n  /* return true if number and no extra non-whitespace chracters after */\n  return z>=zEnd && nDigits>0 && eValid;\n#else\n  return !sqlite3Atoi64(z, pResult, length, enc);\n#endif /* SQLITE_OMIT_FLOATING_POINT */\n}\n\n/*\n** Compare the 19-character string zNum against the text representation\n** value 2^63:  9223372036854775808.  Return negative, zero, or positive\n** if zNum is less than, equal to, or greater than the string.\n** Note that zNum must contain exactly 19 characters.\n**\n** Unlike memcmp() this routine is guaranteed to return the difference\n** in the values of the last digit if the only difference is in the\n** last digit.  So, for example,\n**\n**      compare2pow63(\"9223372036854775800\", 1)\n**\n** will return -8.\n*/\nstatic int compare2pow63(const char *zNum, int incr){\n  int c = 0;\n  int i;\n                    /* 012345678901234567 */\n  const char *pow63 = \"922337203685477580\";\n  for(i=0; c==0 && i<18; i++){\n    c = (zNum[i*incr]-pow63[i])*10;\n  }\n  if( c==0 ){\n    c = zNum[18*incr] - '8';\n    testcase( c==(-1) );\n    testcase( c==0 );\n    testcase( c==(+1) );\n  }\n  return c;\n}\n\n\n/*\n** Convert zNum to a 64-bit signed integer.\n**\n** If the zNum value is representable as a 64-bit twos-complement \n** integer, then write that value into *pNum and return 0.\n**\n** If zNum is exactly 9223372036854665808, return 2.  This special\n** case is broken out because while 9223372036854665808 cannot be a \n** signed 64-bit integer, its negative -9223372036854665808 can be.\n**\n** If zNum is too big for a 64-bit integer and is not\n** 9223372036854665808 then return 1.\n**\n** length is the number of bytes in the string (bytes, not characters).\n** The string is not necessarily zero-terminated.  The encoding is\n** given by enc.\n*/\nSQLITE_PRIVATE int sqlite3Atoi64(const char *zNum, i64 *pNum, int length, u8 enc){\n  int incr = (enc==SQLITE_UTF8?1:2);\n  u64 u = 0;\n  int neg = 0; /* assume positive */\n  int i;\n  int c = 0;\n  const char *zStart;\n  const char *zEnd = zNum + length;\n  if( enc==SQLITE_UTF16BE ) zNum++;\n  while( zNum<zEnd && sqlite3Isspace(*zNum) ) zNum+=incr;\n  if( zNum<zEnd ){\n    if( *zNum=='-' ){\n      neg = 1;\n      zNum+=incr;\n    }else if( *zNum=='+' ){\n      zNum+=incr;\n    }\n  }\n  zStart = zNum;\n  while( zNum<zEnd && zNum[0]=='0' ){ zNum+=incr; } /* Skip leading zeros. */\n  for(i=0; &zNum[i]<zEnd && (c=zNum[i])>='0' && c<='9'; i+=incr){\n    u = u*10 + c - '0';\n  }\n  if( u>LARGEST_INT64 ){\n    *pNum = SMALLEST_INT64;\n  }else if( neg ){\n    *pNum = -(i64)u;\n  }else{\n    *pNum = (i64)u;\n  }\n  testcase( i==18 );\n  testcase( i==19 );\n  testcase( i==20 );\n  if( (c!=0 && &zNum[i]<zEnd) || (i==0 && zStart==zNum) || i>19*incr ){\n    /* zNum is empty or contains non-numeric text or is longer\n    ** than 19 digits (thus guaranteeing that it is too large) */\n    return 1;\n  }else if( i<19*incr ){\n    /* Less than 19 digits, so we know that it fits in 64 bits */\n    assert( u<=LARGEST_INT64 );\n    return 0;\n  }else{\n    /* zNum is a 19-digit numbers.  Compare it against 9223372036854775808. */\n    c = compare2pow63(zNum, incr);\n    if( c<0 ){\n      /* zNum is less than 9223372036854775808 so it fits */\n      assert( u<=LARGEST_INT64 );\n      return 0;\n    }else if( c>0 ){\n      /* zNum is greater than 9223372036854775808 so it overflows */\n      return 1;\n    }else{\n      /* zNum is exactly 9223372036854775808.  Fits if negative.  The\n      ** special case 2 overflow if positive */\n      assert( u-1==LARGEST_INT64 );\n      assert( (*pNum)==SMALLEST_INT64 );\n      return neg ? 0 : 2;\n    }\n  }\n}\n\n/*\n** If zNum represents an integer that will fit in 32-bits, then set\n** *pValue to that integer and return true.  Otherwise return false.\n**\n** Any non-numeric characters that following zNum are ignored.\n** This is different from sqlite3Atoi64() which requires the\n** input number to be zero-terminated.\n*/\nSQLITE_PRIVATE int sqlite3GetInt32(const char *zNum, int *pValue){\n  sqlite_int64 v = 0;\n  int i, c;\n  int neg = 0;\n  if( zNum[0]=='-' ){\n    neg = 1;\n    zNum++;\n  }else if( zNum[0]=='+' ){\n    zNum++;\n  }\n  while( zNum[0]=='0' ) zNum++;\n  for(i=0; i<11 && (c = zNum[i] - '0')>=0 && c<=9; i++){\n    v = v*10 + c;\n  }\n\n  /* The longest decimal representation of a 32 bit integer is 10 digits:\n  **\n  **             1234567890\n  **     2^31 -> 2147483648\n  */\n  testcase( i==10 );\n  if( i>10 ){\n    return 0;\n  }\n  testcase( v-neg==2147483647 );\n  if( v-neg>2147483647 ){\n    return 0;\n  }\n  if( neg ){\n    v = -v;\n  }\n  *pValue = (int)v;\n  return 1;\n}\n\n/*\n** Return a 32-bit integer value extracted from a string.  If the\n** string is not an integer, just return 0.\n*/\nSQLITE_PRIVATE int sqlite3Atoi(const char *z){\n  int x = 0;\n  if( z ) sqlite3GetInt32(z, &x);\n  return x;\n}\n\n/*\n** The variable-length integer encoding is as follows:\n**\n** KEY:\n**         A = 0xxxxxxx    7 bits of data and one flag bit\n**         B = 1xxxxxxx    7 bits of data and one flag bit\n**         C = xxxxxxxx    8 bits of data\n**\n**  7 bits - A\n** 14 bits - BA\n** 21 bits - BBA\n** 28 bits - BBBA\n** 35 bits - BBBBA\n** 42 bits - BBBBBA\n** 49 bits - BBBBBBA\n** 56 bits - BBBBBBBA\n** 64 bits - BBBBBBBBC\n*/\n\n/*\n** Write a 64-bit variable-length integer to memory starting at p[0].\n** The length of data write will be between 1 and 9 bytes.  The number\n** of bytes written is returned.\n**\n** A variable-length integer consists of the lower 7 bits of each byte\n** for all bytes that have the 8th bit set and one byte with the 8th\n** bit clear.  Except, if we get to the 9th byte, it stores the full\n** 8 bits and is the last byte.\n*/\nSQLITE_PRIVATE int sqlite3PutVarint(unsigned char *p, u64 v){\n  int i, j, n;\n  u8 buf[10];\n  if( v & (((u64)0xff000000)<<32) ){\n    p[8] = (u8)v;\n    v >>= 8;\n    for(i=7; i>=0; i--){\n      p[i] = (u8)((v & 0x7f) | 0x80);\n      v >>= 7;\n    }\n    return 9;\n  }    \n  n = 0;\n  do{\n    buf[n++] = (u8)((v & 0x7f) | 0x80);\n    v >>= 7;\n  }while( v!=0 );\n  buf[0] &= 0x7f;\n  assert( n<=9 );\n  for(i=0, j=n-1; j>=0; j--, i++){\n    p[i] = buf[j];\n  }\n  return n;\n}\n\n/*\n** This routine is a faster version of sqlite3PutVarint() that only\n** works for 32-bit positive integers and which is optimized for\n** the common case of small integers.  A MACRO version, putVarint32,\n** is provided which inlines the single-byte case.  All code should use\n** the MACRO version as this function assumes the single-byte case has\n** already been handled.\n*/\nSQLITE_PRIVATE int sqlite3PutVarint32(unsigned char *p, u32 v){\n#ifndef putVarint32\n  if( (v & ~0x7f)==0 ){\n    p[0] = v;\n    return 1;\n  }\n#endif\n  if( (v & ~0x3fff)==0 ){\n    p[0] = (u8)((v>>7) | 0x80);\n    p[1] = (u8)(v & 0x7f);\n    return 2;\n  }\n  return sqlite3PutVarint(p, v);\n}\n\n/*\n** Bitmasks used by sqlite3GetVarint().  These precomputed constants\n** are defined here rather than simply putting the constant expressions\n** inline in order to work around bugs in the RVT compiler.\n**\n** SLOT_2_0     A mask for  (0x7f<<14) | 0x7f\n**\n** SLOT_4_2_0   A mask for  (0x7f<<28) | SLOT_2_0\n*/\n#define SLOT_2_0     0x001fc07f\n#define SLOT_4_2_0   0xf01fc07f\n\n\n/*\n** Read a 64-bit variable-length integer from memory starting at p[0].\n** Return the number of bytes read.  The value is stored in *v.\n*/\nSQLITE_PRIVATE u8 sqlite3GetVarint(const unsigned char *p, u64 *v){\n  u32 a,b,s;\n\n  a = *p;\n  /* a: p0 (unmasked) */\n  if (!(a&0x80))\n  {\n    *v = a;\n    return 1;\n  }\n\n  p++;\n  b = *p;\n  /* b: p1 (unmasked) */\n  if (!(b&0x80))\n  {\n    a &= 0x7f;\n    a = a<<7;\n    a |= b;\n    *v = a;\n    return 2;\n  }\n\n  /* Verify that constants are precomputed correctly */\n  assert( SLOT_2_0 == ((0x7f<<14) | (0x7f)) );\n  assert( SLOT_4_2_0 == ((0xfU<<28) | (0x7f<<14) | (0x7f)) );\n\n  p++;\n  a = a<<14;\n  a |= *p;\n  /* a: p0<<14 | p2 (unmasked) */\n  if (!(a&0x80))\n  {\n    a &= SLOT_2_0;\n    b &= 0x7f;\n    b = b<<7;\n    a |= b;\n    *v = a;\n    return 3;\n  }\n\n  /* CSE1 from below */\n  a &= SLOT_2_0;\n  p++;\n  b = b<<14;\n  b |= *p;\n  /* b: p1<<14 | p3 (unmasked) */\n  if (!(b&0x80))\n  {\n    b &= SLOT_2_0;\n    /* moved CSE1 up */\n    /* a &= (0x7f<<14)|(0x7f); */\n    a = a<<7;\n    a |= b;\n    *v = a;\n    return 4;\n  }\n\n  /* a: p0<<14 | p2 (masked) */\n  /* b: p1<<14 | p3 (unmasked) */\n  /* 1:save off p0<<21 | p1<<14 | p2<<7 | p3 (masked) */\n  /* moved CSE1 up */\n  /* a &= (0x7f<<14)|(0x7f); */\n  b &= SLOT_2_0;\n  s = a;\n  /* s: p0<<14 | p2 (masked) */\n\n  p++;\n  a = a<<14;\n  a |= *p;\n  /* a: p0<<28 | p2<<14 | p4 (unmasked) */\n  if (!(a&0x80))\n  {\n    /* we can skip these cause they were (effectively) done above in calc'ing s */\n    /* a &= (0x7f<<28)|(0x7f<<14)|(0x7f); */\n    /* b &= (0x7f<<14)|(0x7f); */\n    b = b<<7;\n    a |= b;\n    s = s>>18;\n    *v = ((u64)s)<<32 | a;\n    return 5;\n  }\n\n  /* 2:save off p0<<21 | p1<<14 | p2<<7 | p3 (masked) */\n  s = s<<7;\n  s |= b;\n  /* s: p0<<21 | p1<<14 | p2<<7 | p3 (masked) */\n\n  p++;\n  b = b<<14;\n  b |= *p;\n  /* b: p1<<28 | p3<<14 | p5 (unmasked) */\n  if (!(b&0x80))\n  {\n    /* we can skip this cause it was (effectively) done above in calc'ing s */\n    /* b &= (0x7f<<28)|(0x7f<<14)|(0x7f); */\n    a &= SLOT_2_0;\n    a = a<<7;\n    a |= b;\n    s = s>>18;\n    *v = ((u64)s)<<32 | a;\n    return 6;\n  }\n\n  p++;\n  a = a<<14;\n  a |= *p;\n  /* a: p2<<28 | p4<<14 | p6 (unmasked) */\n  if (!(a&0x80))\n  {\n    a &= SLOT_4_2_0;\n    b &= SLOT_2_0;\n    b = b<<7;\n    a |= b;\n    s = s>>11;\n    *v = ((u64)s)<<32 | a;\n    return 7;\n  }\n\n  /* CSE2 from below */\n  a &= SLOT_2_0;\n  p++;\n  b = b<<14;\n  b |= *p;\n  /* b: p3<<28 | p5<<14 | p7 (unmasked) */\n  if (!(b&0x80))\n  {\n    b &= SLOT_4_2_0;\n    /* moved CSE2 up */\n    /* a &= (0x7f<<14)|(0x7f); */\n    a = a<<7;\n    a |= b;\n    s = s>>4;\n    *v = ((u64)s)<<32 | a;\n    return 8;\n  }\n\n  p++;\n  a = a<<15;\n  a |= *p;\n  /* a: p4<<29 | p6<<15 | p8 (unmasked) */\n\n  /* moved CSE2 up */\n  /* a &= (0x7f<<29)|(0x7f<<15)|(0xff); */\n  b &= SLOT_2_0;\n  b = b<<8;\n  a |= b;\n\n  s = s<<4;\n  b = p[-4];\n  b &= 0x7f;\n  b = b>>3;\n  s |= b;\n\n  *v = ((u64)s)<<32 | a;\n\n  return 9;\n}\n\n/*\n** Read a 32-bit variable-length integer from memory starting at p[0].\n** Return the number of bytes read.  The value is stored in *v.\n**\n** If the varint stored in p[0] is larger than can fit in a 32-bit unsigned\n** integer, then set *v to 0xffffffff.\n**\n** A MACRO version, getVarint32, is provided which inlines the \n** single-byte case.  All code should use the MACRO version as \n** this function assumes the single-byte case has already been handled.\n*/\nSQLITE_PRIVATE u8 sqlite3GetVarint32(const unsigned char *p, u32 *v){\n  u32 a,b;\n\n  /* The 1-byte case.  Overwhelmingly the most common.  Handled inline\n  ** by the getVarin32() macro */\n  a = *p;\n  /* a: p0 (unmasked) */\n#ifndef getVarint32\n  if (!(a&0x80))\n  {\n    /* Values between 0 and 127 */\n    *v = a;\n    return 1;\n  }\n#endif\n\n  /* The 2-byte case */\n  p++;\n  b = *p;\n  /* b: p1 (unmasked) */\n  if (!(b&0x80))\n  {\n    /* Values between 128 and 16383 */\n    a &= 0x7f;\n    a = a<<7;\n    *v = a | b;\n    return 2;\n  }\n\n  /* The 3-byte case */\n  p++;\n  a = a<<14;\n  a |= *p;\n  /* a: p0<<14 | p2 (unmasked) */\n  if (!(a&0x80))\n  {\n    /* Values between 16384 and 2097151 */\n    a &= (0x7f<<14)|(0x7f);\n    b &= 0x7f;\n    b = b<<7;\n    *v = a | b;\n    return 3;\n  }\n\n  /* A 32-bit varint is used to store size information in btrees.\n  ** Objects are rarely larger than 2MiB limit of a 3-byte varint.\n  ** A 3-byte varint is sufficient, for example, to record the size\n  ** of a 1048569-byte BLOB or string.\n  **\n  ** We only unroll the first 1-, 2-, and 3- byte cases.  The very\n  ** rare larger cases can be handled by the slower 64-bit varint\n  ** routine.\n  */\n#if 1\n  {\n    u64 v64;\n    u8 n;\n\n    p -= 2;\n    n = sqlite3GetVarint(p, &v64);\n    assert( n>3 && n<=9 );\n    if( (v64 & SQLITE_MAX_U32)!=v64 ){\n      *v = 0xffffffff;\n    }else{\n      *v = (u32)v64;\n    }\n    return n;\n  }\n\n#else\n  /* For following code (kept for historical record only) shows an\n  ** unrolling for the 3- and 4-byte varint cases.  This code is\n  ** slightly faster, but it is also larger and much harder to test.\n  */\n  p++;\n  b = b<<14;\n  b |= *p;\n  /* b: p1<<14 | p3 (unmasked) */\n  if (!(b&0x80))\n  {\n    /* Values between 2097152 and 268435455 */\n    b &= (0x7f<<14)|(0x7f);\n    a &= (0x7f<<14)|(0x7f);\n    a = a<<7;\n    *v = a | b;\n    return 4;\n  }\n\n  p++;\n  a = a<<14;\n  a |= *p;\n  /* a: p0<<28 | p2<<14 | p4 (unmasked) */\n  if (!(a&0x80))\n  {\n    /* Values  between 268435456 and 34359738367 */\n    a &= SLOT_4_2_0;\n    b &= SLOT_4_2_0;\n    b = b<<7;\n    *v = a | b;\n    return 5;\n  }\n\n  /* We can only reach this point when reading a corrupt database\n  ** file.  In that case we are not in any hurry.  Use the (relatively\n  ** slow) general-purpose sqlite3GetVarint() routine to extract the\n  ** value. */\n  {\n    u64 v64;\n    u8 n;\n\n    p -= 4;\n    n = sqlite3GetVarint(p, &v64);\n    assert( n>5 && n<=9 );\n    *v = (u32)v64;\n    return n;\n  }\n#endif\n}\n\n/*\n** Return the number of bytes that will be needed to store the given\n** 64-bit integer.\n*/\nSQLITE_PRIVATE int sqlite3VarintLen(u64 v){\n  int i = 0;\n  do{\n    i++;\n    v >>= 7;\n  }while( v!=0 && ALWAYS(i<9) );\n  return i;\n}\n\n\n/*\n** Read or write a four-byte big-endian integer value.\n*/\nSQLITE_PRIVATE u32 sqlite3Get4byte(const u8 *p){\n  return ((u32)p[0]<<24) | ((u32)p[1]<<16) | ((u32)p[2]<<8) | (u32)p[3];\n}\nSQLITE_PRIVATE void sqlite3Put4byte(unsigned char *p, u32 v){\n  p[0] = (u8)(v>>24);\n  p[1] = (u8)(v>>16);\n  p[2] = (u8)(v>>8);\n  p[3] = (u8)v;\n}\n\n\n\n#if !defined(SQLITE_OMIT_BLOB_LITERAL) || defined(SQLITE_HAS_CODEC)\n/*\n** Translate a single byte of Hex into an integer.\n** This routine only works if h really is a valid hexadecimal\n** character:  0..9a..fA..F\n*/\nstatic u8 hexToInt(int h){\n  assert( (h>='0' && h<='9') ||  (h>='a' && h<='f') ||  (h>='A' && h<='F') );\n#ifdef SQLITE_ASCII\n  h += 9*(1&(h>>6));\n#endif\n#ifdef SQLITE_EBCDIC\n  h += 9*(1&~(h>>4));\n#endif\n  return (u8)(h & 0xf);\n}\n#endif /* !SQLITE_OMIT_BLOB_LITERAL || SQLITE_HAS_CODEC */\n\n#if !defined(SQLITE_OMIT_BLOB_LITERAL) || defined(SQLITE_HAS_CODEC)\n/*\n** Convert a BLOB literal of the form \"x'hhhhhh'\" into its binary\n** value.  Return a pointer to its binary value.  Space to hold the\n** binary value has been obtained from malloc and must be freed by\n** the calling routine.\n*/\nSQLITE_PRIVATE void *sqlite3HexToBlob(sqlite3 *db, const char *z, int n){\n  char *zBlob;\n  int i;\n\n  zBlob = (char *)sqlite3DbMallocRaw(db, n/2 + 1);\n  n--;\n  if( zBlob ){\n    for(i=0; i<n; i+=2){\n      zBlob[i/2] = (hexToInt(z[i])<<4) | hexToInt(z[i+1]);\n    }\n    zBlob[i/2] = 0;\n  }\n  return zBlob;\n}\n#endif /* !SQLITE_OMIT_BLOB_LITERAL || SQLITE_HAS_CODEC */\n\n/*\n** Log an error that is an API call on a connection pointer that should\n** not have been used.  The \"type\" of connection pointer is given as the\n** argument.  The zType is a word like \"NULL\" or \"closed\" or \"invalid\".\n*/\nstatic void logBadConnection(const char *zType){\n  sqlite3_log(SQLITE_MISUSE, \n     \"API call with %s database connection pointer\",\n     zType\n  );\n}\n\n/*\n** Check to make sure we have a valid db pointer.  This test is not\n** foolproof but it does provide some measure of protection against\n** misuse of the interface such as passing in db pointers that are\n** NULL or which have been previously closed.  If this routine returns\n** 1 it means that the db pointer is valid and 0 if it should not be\n** dereferenced for any reason.  The calling function should invoke\n** SQLITE_MISUSE immediately.\n**\n** sqlite3SafetyCheckOk() requires that the db pointer be valid for\n** use.  sqlite3SafetyCheckSickOrOk() allows a db pointer that failed to\n** open properly and is not fit for general use but which can be\n** used as an argument to sqlite3_errmsg() or sqlite3_close().\n*/\nSQLITE_PRIVATE int sqlite3SafetyCheckOk(sqlite3 *db){\n  u32 magic;\n  if( db==0 ){\n    logBadConnection(\"NULL\");\n    return 0;\n  }\n  magic = db->magic;\n  if( magic!=SQLITE_MAGIC_OPEN ){\n    if( sqlite3SafetyCheckSickOrOk(db) ){\n      testcase( sqlite3GlobalConfig.xLog!=0 );\n      logBadConnection(\"unopened\");\n    }\n    return 0;\n  }else{\n    return 1;\n  }\n}\nSQLITE_PRIVATE int sqlite3SafetyCheckSickOrOk(sqlite3 *db){\n  u32 magic;\n  magic = db->magic;\n  if( magic!=SQLITE_MAGIC_SICK &&\n      magic!=SQLITE_MAGIC_OPEN &&\n      magic!=SQLITE_MAGIC_BUSY ){\n    testcase( sqlite3GlobalConfig.xLog!=0 );\n    logBadConnection(\"invalid\");\n    return 0;\n  }else{\n    return 1;\n  }\n}\n\n/*\n** Attempt to add, substract, or multiply the 64-bit signed value iB against\n** the other 64-bit signed integer at *pA and store the result in *pA.\n** Return 0 on success.  Or if the operation would have resulted in an\n** overflow, leave *pA unchanged and return 1.\n*/\nSQLITE_PRIVATE int sqlite3AddInt64(i64 *pA, i64 iB){\n  i64 iA = *pA;\n  testcase( iA==0 ); testcase( iA==1 );\n  testcase( iB==-1 ); testcase( iB==0 );\n  if( iB>=0 ){\n    testcase( iA>0 && LARGEST_INT64 - iA == iB );\n    testcase( iA>0 && LARGEST_INT64 - iA == iB - 1 );\n    if( iA>0 && LARGEST_INT64 - iA < iB ) return 1;\n    *pA += iB;\n  }else{\n    testcase( iA<0 && -(iA + LARGEST_INT64) == iB + 1 );\n    testcase( iA<0 && -(iA + LARGEST_INT64) == iB + 2 );\n    if( iA<0 && -(iA + LARGEST_INT64) > iB + 1 ) return 1;\n    *pA += iB;\n  }\n  return 0; \n}\nSQLITE_PRIVATE int sqlite3SubInt64(i64 *pA, i64 iB){\n  testcase( iB==SMALLEST_INT64+1 );\n  if( iB==SMALLEST_INT64 ){\n    testcase( (*pA)==(-1) ); testcase( (*pA)==0 );\n    if( (*pA)>=0 ) return 1;\n    *pA -= iB;\n    return 0;\n  }else{\n    return sqlite3AddInt64(pA, -iB);\n  }\n}\n#define TWOPOWER32 (((i64)1)<<32)\n#define TWOPOWER31 (((i64)1)<<31)\nSQLITE_PRIVATE int sqlite3MulInt64(i64 *pA, i64 iB){\n  i64 iA = *pA;\n  i64 iA1, iA0, iB1, iB0, r;\n\n  iA1 = iA/TWOPOWER32;\n  iA0 = iA % TWOPOWER32;\n  iB1 = iB/TWOPOWER32;\n  iB0 = iB % TWOPOWER32;\n  if( iA1*iB1 != 0 ) return 1;\n  assert( iA1*iB0==0 || iA0*iB1==0 );\n  r = iA1*iB0 + iA0*iB1;\n  testcase( r==(-TWOPOWER31)-1 );\n  testcase( r==(-TWOPOWER31) );\n  testcase( r==TWOPOWER31 );\n  testcase( r==TWOPOWER31-1 );\n  if( r<(-TWOPOWER31) || r>=TWOPOWER31 ) return 1;\n  r *= TWOPOWER32;\n  if( sqlite3AddInt64(&r, iA0*iB0) ) return 1;\n  *pA = r;\n  return 0;\n}\n\n/*\n** Compute the absolute value of a 32-bit signed integer, of possible.  Or \n** if the integer has a value of -2147483648, return +2147483647\n*/\nSQLITE_PRIVATE int sqlite3AbsInt32(int x){\n  if( x>=0 ) return x;\n  if( x==(int)0x80000000 ) return 0x7fffffff;\n  return -x;\n}\n\n/************** End of util.c ************************************************/\n/************** Begin file hash.c ********************************************/\n/*\n** 2001 September 22\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This is the implementation of generic hash-tables\n** used in SQLite.\n*/\n\n/* Turn bulk memory into a hash table object by initializing the\n** fields of the Hash structure.\n**\n** \"pNew\" is a pointer to the hash table that is to be initialized.\n*/\nSQLITE_PRIVATE void sqlite3HashInit(Hash *pNew){\n  assert( pNew!=0 );\n  pNew->first = 0;\n  pNew->count = 0;\n  pNew->htsize = 0;\n  pNew->ht = 0;\n}\n\n/* Remove all entries from a hash table.  Reclaim all memory.\n** Call this routine to delete a hash table or to reset a hash table\n** to the empty state.\n*/\nSQLITE_PRIVATE void sqlite3HashClear(Hash *pH){\n  HashElem *elem;         /* For looping over all elements of the table */\n\n  assert( pH!=0 );\n  elem = pH->first;\n  pH->first = 0;\n  sqlite3_free(pH->ht);\n  pH->ht = 0;\n  pH->htsize = 0;\n  while( elem ){\n    HashElem *next_elem = elem->next;\n    sqlite3_free(elem);\n    elem = next_elem;\n  }\n  pH->count = 0;\n}\n\n/*\n** The hashing function.\n*/\nstatic unsigned int strHash(const char *z, int nKey){\n  int h = 0;\n  assert( nKey>=0 );\n  while( nKey > 0  ){\n    h = (h<<3) ^ h ^ sqlite3UpperToLower[(unsigned char)*z++];\n    nKey--;\n  }\n  return h;\n}\n\n\n/* Link pNew element into the hash table pH.  If pEntry!=0 then also\n** insert pNew into the pEntry hash bucket.\n*/\nstatic void insertElement(\n  Hash *pH,              /* The complete hash table */\n  struct _ht *pEntry,    /* The entry into which pNew is inserted */\n  HashElem *pNew         /* The element to be inserted */\n){\n  HashElem *pHead;       /* First element already in pEntry */\n  if( pEntry ){\n    pHead = pEntry->count ? pEntry->chain : 0;\n    pEntry->count++;\n    pEntry->chain = pNew;\n  }else{\n    pHead = 0;\n  }\n  if( pHead ){\n    pNew->next = pHead;\n    pNew->prev = pHead->prev;\n    if( pHead->prev ){ pHead->prev->next = pNew; }\n    else             { pH->first = pNew; }\n    pHead->prev = pNew;\n  }else{\n    pNew->next = pH->first;\n    if( pH->first ){ pH->first->prev = pNew; }\n    pNew->prev = 0;\n    pH->first = pNew;\n  }\n}\n\n\n/* Resize the hash table so that it cantains \"new_size\" buckets.\n**\n** The hash table might fail to resize if sqlite3_malloc() fails or\n** if the new size is the same as the prior size.\n** Return TRUE if the resize occurs and false if not.\n*/\nstatic int rehash(Hash *pH, unsigned int new_size){\n  struct _ht *new_ht;            /* The new hash table */\n  HashElem *elem, *next_elem;    /* For looping over existing elements */\n\n#if SQLITE_MALLOC_SOFT_LIMIT>0\n  if( new_size*sizeof(struct _ht)>SQLITE_MALLOC_SOFT_LIMIT ){\n    new_size = SQLITE_MALLOC_SOFT_LIMIT/sizeof(struct _ht);\n  }\n  if( new_size==pH->htsize ) return 0;\n#endif\n\n  /* The inability to allocates space for a larger hash table is\n  ** a performance hit but it is not a fatal error.  So mark the\n  ** allocation as a benign.\n  */\n  sqlite3BeginBenignMalloc();\n  new_ht = (struct _ht *)sqlite3Malloc( new_size*sizeof(struct _ht) );\n  sqlite3EndBenignMalloc();\n\n  if( new_ht==0 ) return 0;\n  sqlite3_free(pH->ht);\n  pH->ht = new_ht;\n  pH->htsize = new_size = sqlite3MallocSize(new_ht)/sizeof(struct _ht);\n  memset(new_ht, 0, new_size*sizeof(struct _ht));\n  for(elem=pH->first, pH->first=0; elem; elem = next_elem){\n    unsigned int h = strHash(elem->pKey, elem->nKey) % new_size;\n    next_elem = elem->next;\n    insertElement(pH, &new_ht[h], elem);\n  }\n  return 1;\n}\n\n/* This function (for internal use only) locates an element in an\n** hash table that matches the given key.  The hash for this key has\n** already been computed and is passed as the 4th parameter.\n*/\nstatic HashElem *findElementGivenHash(\n  const Hash *pH,     /* The pH to be searched */\n  const char *pKey,   /* The key we are searching for */\n  int nKey,           /* Bytes in key (not counting zero terminator) */\n  unsigned int h      /* The hash for this key. */\n){\n  HashElem *elem;                /* Used to loop thru the element list */\n  int count;                     /* Number of elements left to test */\n\n  if( pH->ht ){\n    struct _ht *pEntry = &pH->ht[h];\n    elem = pEntry->chain;\n    count = pEntry->count;\n  }else{\n    elem = pH->first;\n    count = pH->count;\n  }\n  while( count-- && ALWAYS(elem) ){\n    if( elem->nKey==nKey && sqlite3StrNICmp(elem->pKey,pKey,nKey)==0 ){ \n      return elem;\n    }\n    elem = elem->next;\n  }\n  return 0;\n}\n\n/* Remove a single entry from the hash table given a pointer to that\n** element and a hash on the element's key.\n*/\nstatic void removeElementGivenHash(\n  Hash *pH,         /* The pH containing \"elem\" */\n  HashElem* elem,   /* The element to be removed from the pH */\n  unsigned int h    /* Hash value for the element */\n){\n  struct _ht *pEntry;\n  if( elem->prev ){\n    elem->prev->next = elem->next; \n  }else{\n    pH->first = elem->next;\n  }\n  if( elem->next ){\n    elem->next->prev = elem->prev;\n  }\n  if( pH->ht ){\n    pEntry = &pH->ht[h];\n    if( pEntry->chain==elem ){\n      pEntry->chain = elem->next;\n    }\n    pEntry->count--;\n    assert( pEntry->count>=0 );\n  }\n  sqlite3_free( elem );\n  pH->count--;\n  if( pH->count<=0 ){\n    assert( pH->first==0 );\n    assert( pH->count==0 );\n    sqlite3HashClear(pH);\n  }\n}\n\n/* Attempt to locate an element of the hash table pH with a key\n** that matches pKey,nKey.  Return the data for this element if it is\n** found, or NULL if there is no match.\n*/\nSQLITE_PRIVATE void *sqlite3HashFind(const Hash *pH, const char *pKey, int nKey){\n  HashElem *elem;    /* The element that matches key */\n  unsigned int h;    /* A hash on key */\n\n  assert( pH!=0 );\n  assert( pKey!=0 );\n  assert( nKey>=0 );\n  if( pH->ht ){\n    h = strHash(pKey, nKey) % pH->htsize;\n  }else{\n    h = 0;\n  }\n  elem = findElementGivenHash(pH, pKey, nKey, h);\n  return elem ? elem->data : 0;\n}\n\n/* Insert an element into the hash table pH.  The key is pKey,nKey\n** and the data is \"data\".\n**\n** If no element exists with a matching key, then a new\n** element is created and NULL is returned.\n**\n** If another element already exists with the same key, then the\n** new data replaces the old data and the old data is returned.\n** The key is not copied in this instance.  If a malloc fails, then\n** the new data is returned and the hash table is unchanged.\n**\n** If the \"data\" parameter to this function is NULL, then the\n** element corresponding to \"key\" is removed from the hash table.\n*/\nSQLITE_PRIVATE void *sqlite3HashInsert(Hash *pH, const char *pKey, int nKey, void *data){\n  unsigned int h;       /* the hash of the key modulo hash table size */\n  HashElem *elem;       /* Used to loop thru the element list */\n  HashElem *new_elem;   /* New element added to the pH */\n\n  assert( pH!=0 );\n  assert( pKey!=0 );\n  assert( nKey>=0 );\n  if( pH->htsize ){\n    h = strHash(pKey, nKey) % pH->htsize;\n  }else{\n    h = 0;\n  }\n  elem = findElementGivenHash(pH,pKey,nKey,h);\n  if( elem ){\n    void *old_data = elem->data;\n    if( data==0 ){\n      removeElementGivenHash(pH,elem,h);\n    }else{\n      elem->data = data;\n      elem->pKey = pKey;\n      assert(nKey==elem->nKey);\n    }\n    return old_data;\n  }\n  if( data==0 ) return 0;\n  new_elem = (HashElem*)sqlite3Malloc( sizeof(HashElem) );\n  if( new_elem==0 ) return data;\n  new_elem->pKey = pKey;\n  new_elem->nKey = nKey;\n  new_elem->data = data;\n  pH->count++;\n  if( pH->count>=10 && pH->count > 2*pH->htsize ){\n    if( rehash(pH, pH->count*2) ){\n      assert( pH->htsize>0 );\n      h = strHash(pKey, nKey) % pH->htsize;\n    }\n  }\n  if( pH->ht ){\n    insertElement(pH, &pH->ht[h], new_elem);\n  }else{\n    insertElement(pH, 0, new_elem);\n  }\n  return 0;\n}\n\n/************** End of hash.c ************************************************/\n/************** Begin file opcodes.c *****************************************/\n/* Automatically generated.  Do not edit */\n/* See the mkopcodec.awk script for details. */\n#if !defined(SQLITE_OMIT_EXPLAIN) || !defined(NDEBUG) || defined(VDBE_PROFILE) || defined(SQLITE_DEBUG)\nSQLITE_PRIVATE const char *sqlite3OpcodeName(int i){\n static const char *const azName[] = { \"?\",\n     /*   1 */ \"Goto\",\n     /*   2 */ \"Gosub\",\n     /*   3 */ \"Return\",\n     /*   4 */ \"Yield\",\n     /*   5 */ \"HaltIfNull\",\n     /*   6 */ \"Halt\",\n     /*   7 */ \"Integer\",\n     /*   8 */ \"Int64\",\n     /*   9 */ \"String\",\n     /*  10 */ \"Null\",\n     /*  11 */ \"Blob\",\n     /*  12 */ \"Variable\",\n     /*  13 */ \"Move\",\n     /*  14 */ \"Copy\",\n     /*  15 */ \"SCopy\",\n     /*  16 */ \"ResultRow\",\n     /*  17 */ \"CollSeq\",\n     /*  18 */ \"Function\",\n     /*  19 */ \"Not\",\n     /*  20 */ \"AddImm\",\n     /*  21 */ \"MustBeInt\",\n     /*  22 */ \"RealAffinity\",\n     /*  23 */ \"Permutation\",\n     /*  24 */ \"Compare\",\n     /*  25 */ \"Jump\",\n     /*  26 */ \"If\",\n     /*  27 */ \"IfNot\",\n     /*  28 */ \"Column\",\n     /*  29 */ \"Affinity\",\n     /*  30 */ \"MakeRecord\",\n     /*  31 */ \"Count\",\n     /*  32 */ \"Savepoint\",\n     /*  33 */ \"AutoCommit\",\n     /*  34 */ \"Transaction\",\n     /*  35 */ \"ReadCookie\",\n     /*  36 */ \"SetCookie\",\n     /*  37 */ \"VerifyCookie\",\n     /*  38 */ \"OpenRead\",\n     /*  39 */ \"OpenWrite\",\n     /*  40 */ \"OpenAutoindex\",\n     /*  41 */ \"OpenEphemeral\",\n     /*  42 */ \"OpenPseudo\",\n     /*  43 */ \"Close\",\n     /*  44 */ \"SeekLt\",\n     /*  45 */ \"SeekLe\",\n     /*  46 */ \"SeekGe\",\n     /*  47 */ \"SeekGt\",\n     /*  48 */ \"Seek\",\n     /*  49 */ \"NotFound\",\n     /*  50 */ \"Found\",\n     /*  51 */ \"IsUnique\",\n     /*  52 */ \"NotExists\",\n     /*  53 */ \"Sequence\",\n     /*  54 */ \"NewRowid\",\n     /*  55 */ \"Insert\",\n     /*  56 */ \"InsertInt\",\n     /*  57 */ \"Delete\",\n     /*  58 */ \"ResetCount\",\n     /*  59 */ \"RowKey\",\n     /*  60 */ \"RowData\",\n     /*  61 */ \"Rowid\",\n     /*  62 */ \"NullRow\",\n     /*  63 */ \"Last\",\n     /*  64 */ \"Sort\",\n     /*  65 */ \"Rewind\",\n     /*  66 */ \"Prev\",\n     /*  67 */ \"Next\",\n     /*  68 */ \"Or\",\n     /*  69 */ \"And\",\n     /*  70 */ \"IdxInsert\",\n     /*  71 */ \"IdxDelete\",\n     /*  72 */ \"IdxRowid\",\n     /*  73 */ \"IsNull\",\n     /*  74 */ \"NotNull\",\n     /*  75 */ \"Ne\",\n     /*  76 */ \"Eq\",\n     /*  77 */ \"Gt\",\n     /*  78 */ \"Le\",\n     /*  79 */ \"Lt\",\n     /*  80 */ \"Ge\",\n     /*  81 */ \"IdxLT\",\n     /*  82 */ \"BitAnd\",\n     /*  83 */ \"BitOr\",\n     /*  84 */ \"ShiftLeft\",\n     /*  85 */ \"ShiftRight\",\n     /*  86 */ \"Add\",\n     /*  87 */ \"Subtract\",\n     /*  88 */ \"Multiply\",\n     /*  89 */ \"Divide\",\n     /*  90 */ \"Remainder\",\n     /*  91 */ \"Concat\",\n     /*  92 */ \"IdxGE\",\n     /*  93 */ \"BitNot\",\n     /*  94 */ \"String8\",\n     /*  95 */ \"Destroy\",\n     /*  96 */ \"Clear\",\n     /*  97 */ \"CreateIndex\",\n     /*  98 */ \"CreateTable\",\n     /*  99 */ \"ParseSchema\",\n     /* 100 */ \"LoadAnalysis\",\n     /* 101 */ \"DropTable\",\n     /* 102 */ \"DropIndex\",\n     /* 103 */ \"DropTrigger\",\n     /* 104 */ \"IntegrityCk\",\n     /* 105 */ \"RowSetAdd\",\n     /* 106 */ \"RowSetRead\",\n     /* 107 */ \"RowSetTest\",\n     /* 108 */ \"Program\",\n     /* 109 */ \"Param\",\n     /* 110 */ \"FkCounter\",\n     /* 111 */ \"FkIfZero\",\n     /* 112 */ \"MemMax\",\n     /* 113 */ \"IfPos\",\n     /* 114 */ \"IfNeg\",\n     /* 115 */ \"IfZero\",\n     /* 116 */ \"AggStep\",\n     /* 117 */ \"AggFinal\",\n     /* 118 */ \"Checkpoint\",\n     /* 119 */ \"JournalMode\",\n     /* 120 */ \"Vacuum\",\n     /* 121 */ \"IncrVacuum\",\n     /* 122 */ \"Expire\",\n     /* 123 */ \"TableLock\",\n     /* 124 */ \"VBegin\",\n     /* 125 */ \"VCreate\",\n     /* 126 */ \"VDestroy\",\n     /* 127 */ \"VOpen\",\n     /* 128 */ \"VFilter\",\n     /* 129 */ \"VColumn\",\n     /* 130 */ \"Real\",\n     /* 131 */ \"VNext\",\n     /* 132 */ \"VRename\",\n     /* 133 */ \"VUpdate\",\n     /* 134 */ \"Pagecount\",\n     /* 135 */ \"MaxPgcnt\",\n     /* 136 */ \"Trace\",\n     /* 137 */ \"Noop\",\n     /* 138 */ \"Explain\",\n     /* 139 */ \"NotUsed_139\",\n     /* 140 */ \"NotUsed_140\",\n     /* 141 */ \"ToText\",\n     /* 142 */ \"ToBlob\",\n     /* 143 */ \"ToNumeric\",\n     /* 144 */ \"ToInt\",\n     /* 145 */ \"ToReal\",\n  };\n  return azName[i];\n}\n#endif\n\n/************** End of opcodes.c *********************************************/\n/************** Begin file os_os2.c ******************************************/\n/*\n** 2006 Feb 14\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n******************************************************************************\n**\n** This file contains code that is specific to OS/2.\n*/\n\n\n#if SQLITE_OS_OS2\n\n/*\n** A Note About Memory Allocation:\n**\n** This driver uses malloc()/free() directly rather than going through\n** the SQLite-wrappers sqlite3_malloc()/sqlite3_free().  Those wrappers\n** are designed for use on embedded systems where memory is scarce and\n** malloc failures happen frequently.  OS/2 does not typically run on\n** embedded systems, and when it does the developers normally have bigger\n** problems to worry about than running out of memory.  So there is not\n** a compelling need to use the wrappers.\n**\n** But there is a good reason to not use the wrappers.  If we use the\n** wrappers then we will get simulated malloc() failures within this\n** driver.  And that causes all kinds of problems for our tests.  We\n** could enhance SQLite to deal with simulated malloc failures within\n** the OS driver, but the code to deal with those failure would not\n** be exercised on Linux (which does not need to malloc() in the driver)\n** and so we would have difficulty writing coverage tests for that\n** code.  Better to leave the code out, we think.\n**\n** The point of this discussion is as follows:  When creating a new\n** OS layer for an embedded system, if you use this file as an example,\n** avoid the use of malloc()/free().  Those routines work ok on OS/2\n** desktops but not so well in embedded systems.\n*/\n\n/*\n** Macros used to determine whether or not to use threads.\n*/\n#if defined(SQLITE_THREADSAFE) && SQLITE_THREADSAFE\n# define SQLITE_OS2_THREADS 1\n#endif\n\n/*\n** Include code that is common to all os_*.c files\n*/\n/************** Include os_common.h in the middle of os_os2.c ****************/\n/************** Begin file os_common.h ***************************************/\n/*\n** 2004 May 22\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n******************************************************************************\n**\n** This file contains macros and a little bit of code that is common to\n** all of the platform-specific files (os_*.c) and is #included into those\n** files.\n**\n** This file should be #included by the os_*.c files only.  It is not a\n** general purpose header file.\n*/\n#ifndef _OS_COMMON_H_\n#define _OS_COMMON_H_\n\n/*\n** At least two bugs have slipped in because we changed the MEMORY_DEBUG\n** macro to SQLITE_DEBUG and some older makefiles have not yet made the\n** switch.  The following code should catch this problem at compile-time.\n*/\n#ifdef MEMORY_DEBUG\n# error \"The MEMORY_DEBUG macro is obsolete.  Use SQLITE_DEBUG instead.\"\n#endif\n\n#ifdef SQLITE_DEBUG\nSQLITE_PRIVATE int sqlite3OSTrace = 0;\n#define OSTRACE(X)          if( sqlite3OSTrace ) sqlite3DebugPrintf X\n#else\n#define OSTRACE(X)\n#endif\n\n/*\n** Macros for performance tracing.  Normally turned off.  Only works\n** on i486 hardware.\n*/\n#ifdef SQLITE_PERFORMANCE_TRACE\n\n/* \n** hwtime.h contains inline assembler code for implementing \n** high-performance timing routines.\n*/\n/************** Include hwtime.h in the middle of os_common.h ****************/\n/************** Begin file hwtime.h ******************************************/\n/*\n** 2008 May 27\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n******************************************************************************\n**\n** This file contains inline asm code for retrieving \"high-performance\"\n** counters for x86 class CPUs.\n*/\n#ifndef _HWTIME_H_\n#define _HWTIME_H_\n\n/*\n** The following routine only works on pentium-class (or newer) processors.\n** It uses the RDTSC opcode to read the cycle count value out of the\n** processor and returns that value.  This can be used for high-res\n** profiling.\n*/\n#if (defined(__GNUC__) || defined(_MSC_VER)) && \\\n      (defined(i386) || defined(__i386__) || defined(_M_IX86))\n\n  #if defined(__GNUC__)\n\n  __inline__ sqlite_uint64 sqlite3Hwtime(void){\n     unsigned int lo, hi;\n     __asm__ __volatile__ (\"rdtsc\" : \"=a\" (lo), \"=d\" (hi));\n     return (sqlite_uint64)hi << 32 | lo;\n  }\n\n  #elif defined(_MSC_VER)\n\n  __declspec(naked) __inline sqlite_uint64 __cdecl sqlite3Hwtime(void){\n     __asm {\n        rdtsc\n        ret       ; return value at EDX:EAX\n     }\n  }\n\n  #endif\n\n#elif (defined(__GNUC__) && defined(__x86_64__))\n\n  __inline__ sqlite_uint64 sqlite3Hwtime(void){\n      unsigned long val;\n      __asm__ __volatile__ (\"rdtsc\" : \"=A\" (val));\n      return val;\n  }\n \n#elif (defined(__GNUC__) && defined(__ppc__))\n\n  __inline__ sqlite_uint64 sqlite3Hwtime(void){\n      unsigned long long retval;\n      unsigned long junk;\n      __asm__ __volatile__ (\"\\n\\\n          1:      mftbu   %1\\n\\\n                  mftb    %L0\\n\\\n                  mftbu   %0\\n\\\n                  cmpw    %0,%1\\n\\\n                  bne     1b\"\n                  : \"=r\" (retval), \"=r\" (junk));\n      return retval;\n  }\n\n#else\n\n  #error Need implementation of sqlite3Hwtime() for your platform.\n\n  /*\n  ** To compile without implementing sqlite3Hwtime() for your platform,\n  ** you can remove the above #error and use the following\n  ** stub function.  You will lose timing support for many\n  ** of the debugging and testing utilities, but it should at\n  ** least compile and run.\n  */\nSQLITE_PRIVATE   sqlite_uint64 sqlite3Hwtime(void){ return ((sqlite_uint64)0); }\n\n#endif\n\n#endif /* !defined(_HWTIME_H_) */\n\n/************** End of hwtime.h **********************************************/\n/************** Continuing where we left off in os_common.h ******************/\n\nstatic sqlite_uint64 g_start;\nstatic sqlite_uint64 g_elapsed;\n#define TIMER_START       g_start=sqlite3Hwtime()\n#define TIMER_END         g_elapsed=sqlite3Hwtime()-g_start\n#define TIMER_ELAPSED     g_elapsed\n#else\n#define TIMER_START\n#define TIMER_END\n#define TIMER_ELAPSED     ((sqlite_uint64)0)\n#endif\n\n/*\n** If we compile with the SQLITE_TEST macro set, then the following block\n** of code will give us the ability to simulate a disk I/O error.  This\n** is used for testing the I/O recovery logic.\n*/\n#ifdef SQLITE_TEST\nSQLITE_API int sqlite3_io_error_hit = 0;            /* Total number of I/O Errors */\nSQLITE_API int sqlite3_io_error_hardhit = 0;        /* Number of non-benign errors */\nSQLITE_API int sqlite3_io_error_pending = 0;        /* Count down to first I/O error */\nSQLITE_API int sqlite3_io_error_persist = 0;        /* True if I/O errors persist */\nSQLITE_API int sqlite3_io_error_benign = 0;         /* True if errors are benign */\nSQLITE_API int sqlite3_diskfull_pending = 0;\nSQLITE_API int sqlite3_diskfull = 0;\n#define SimulateIOErrorBenign(X) sqlite3_io_error_benign=(X)\n#define SimulateIOError(CODE)  \\\n  if( (sqlite3_io_error_persist && sqlite3_io_error_hit) \\\n       || sqlite3_io_error_pending-- == 1 )  \\\n              { local_ioerr(); CODE; }\nstatic void local_ioerr(){\n  IOTRACE((\"IOERR\\n\"));\n  sqlite3_io_error_hit++;\n  if( !sqlite3_io_error_benign ) sqlite3_io_error_hardhit++;\n}\n#define SimulateDiskfullError(CODE) \\\n   if( sqlite3_diskfull_pending ){ \\\n     if( sqlite3_diskfull_pending == 1 ){ \\\n       local_ioerr(); \\\n       sqlite3_diskfull = 1; \\\n       sqlite3_io_error_hit = 1; \\\n       CODE; \\\n     }else{ \\\n       sqlite3_diskfull_pending--; \\\n     } \\\n   }\n#else\n#define SimulateIOErrorBenign(X)\n#define SimulateIOError(A)\n#define SimulateDiskfullError(A)\n#endif\n\n/*\n** When testing, keep a count of the number of open files.\n*/\n#ifdef SQLITE_TEST\nSQLITE_API int sqlite3_open_file_count = 0;\n#define OpenCounter(X)  sqlite3_open_file_count+=(X)\n#else\n#define OpenCounter(X)\n#endif\n\n#endif /* !defined(_OS_COMMON_H_) */\n\n/************** End of os_common.h *******************************************/\n/************** Continuing where we left off in os_os2.c *********************/\n\n/*\n** The os2File structure is subclass of sqlite3_file specific for the OS/2\n** protability layer.\n*/\ntypedef struct os2File os2File;\nstruct os2File {\n  const sqlite3_io_methods *pMethod;  /* Always the first entry */\n  HFILE h;                  /* Handle for accessing the file */\n  char* pathToDel;          /* Name of file to delete on close, NULL if not */\n  unsigned char locktype;   /* Type of lock currently held on this file */\n};\n\n#define LOCK_TIMEOUT 10L /* the default locking timeout */\n\n/*****************************************************************************\n** The next group of routines implement the I/O methods specified\n** by the sqlite3_io_methods object.\n******************************************************************************/\n\n/*\n** Close a file.\n*/\nstatic int os2Close( sqlite3_file *id ){\n  APIRET rc = NO_ERROR;\n  os2File *pFile;\n  if( id && (pFile = (os2File*)id) != 0 ){\n    OSTRACE(( \"CLOSE %d\\n\", pFile->h ));\n    rc = DosClose( pFile->h );\n    pFile->locktype = NO_LOCK;\n    if( pFile->pathToDel != NULL ){\n      rc = DosForceDelete( (PSZ)pFile->pathToDel );\n      free( pFile->pathToDel );\n      pFile->pathToDel = NULL;\n    }\n    id = 0;\n    OpenCounter( -1 );\n  }\n\n  return rc == NO_ERROR ? SQLITE_OK : SQLITE_IOERR;\n}\n\n/*\n** Read data from a file into a buffer.  Return SQLITE_OK if all\n** bytes were read successfully and SQLITE_IOERR if anything goes\n** wrong.\n*/\nstatic int os2Read(\n  sqlite3_file *id,               /* File to read from */\n  void *pBuf,                     /* Write content into this buffer */\n  int amt,                        /* Number of bytes to read */\n  sqlite3_int64 offset            /* Begin reading at this offset */\n){\n  ULONG fileLocation = 0L;\n  ULONG got;\n  os2File *pFile = (os2File*)id;\n  assert( id!=0 );\n  SimulateIOError( return SQLITE_IOERR_READ );\n  OSTRACE(( \"READ %d lock=%d\\n\", pFile->h, pFile->locktype ));\n  if( DosSetFilePtr(pFile->h, offset, FILE_BEGIN, &fileLocation) != NO_ERROR ){\n    return SQLITE_IOERR;\n  }\n  if( DosRead( pFile->h, pBuf, amt, &got ) != NO_ERROR ){\n    return SQLITE_IOERR_READ;\n  }\n  if( got == (ULONG)amt )\n    return SQLITE_OK;\n  else {\n    /* Unread portions of the input buffer must be zero-filled */\n    memset(&((char*)pBuf)[got], 0, amt-got);\n    return SQLITE_IOERR_SHORT_READ;\n  }\n}\n\n/*\n** Write data from a buffer into a file.  Return SQLITE_OK on success\n** or some other error code on failure.\n*/\nstatic int os2Write(\n  sqlite3_file *id,               /* File to write into */\n  const void *pBuf,               /* The bytes to be written */\n  int amt,                        /* Number of bytes to write */\n  sqlite3_int64 offset            /* Offset into the file to begin writing at */\n){\n  ULONG fileLocation = 0L;\n  APIRET rc = NO_ERROR;\n  ULONG wrote;\n  os2File *pFile = (os2File*)id;\n  assert( id!=0 );\n  SimulateIOError( return SQLITE_IOERR_WRITE );\n  SimulateDiskfullError( return SQLITE_FULL );\n  OSTRACE(( \"WRITE %d lock=%d\\n\", pFile->h, pFile->locktype ));\n  if( DosSetFilePtr(pFile->h, offset, FILE_BEGIN, &fileLocation) != NO_ERROR ){\n    return SQLITE_IOERR;\n  }\n  assert( amt>0 );\n  while( amt > 0 &&\n         ( rc = DosWrite( pFile->h, (PVOID)pBuf, amt, &wrote ) ) == NO_ERROR &&\n         wrote > 0\n  ){\n    amt -= wrote;\n    pBuf = &((char*)pBuf)[wrote];\n  }\n\n  return ( rc != NO_ERROR || amt > (int)wrote ) ? SQLITE_FULL : SQLITE_OK;\n}\n\n/*\n** Truncate an open file to a specified size\n*/\nstatic int os2Truncate( sqlite3_file *id, i64 nByte ){\n  APIRET rc = NO_ERROR;\n  os2File *pFile = (os2File*)id;\n  OSTRACE(( \"TRUNCATE %d %lld\\n\", pFile->h, nByte ));\n  SimulateIOError( return SQLITE_IOERR_TRUNCATE );\n  rc = DosSetFileSize( pFile->h, nByte );\n  return rc == NO_ERROR ? SQLITE_OK : SQLITE_IOERR_TRUNCATE;\n}\n\n#ifdef SQLITE_TEST\n/*\n** Count the number of fullsyncs and normal syncs.  This is used to test\n** that syncs and fullsyncs are occuring at the right times.\n*/\nSQLITE_API int sqlite3_sync_count = 0;\nSQLITE_API int sqlite3_fullsync_count = 0;\n#endif\n\n/*\n** Make sure all writes to a particular file are committed to disk.\n*/\nstatic int os2Sync( sqlite3_file *id, int flags ){\n  os2File *pFile = (os2File*)id;\n  OSTRACE(( \"SYNC %d lock=%d\\n\", pFile->h, pFile->locktype ));\n#ifdef SQLITE_TEST\n  if( flags & SQLITE_SYNC_FULL){\n    sqlite3_fullsync_count++;\n  }\n  sqlite3_sync_count++;\n#endif\n  /* If we compiled with the SQLITE_NO_SYNC flag, then syncing is a\n  ** no-op\n  */\n#ifdef SQLITE_NO_SYNC\n  UNUSED_PARAMETER(pFile);\n  return SQLITE_OK;\n#else\n  return DosResetBuffer( pFile->h ) == NO_ERROR ? SQLITE_OK : SQLITE_IOERR;\n#endif\n}\n\n/*\n** Determine the current size of a file in bytes\n*/\nstatic int os2FileSize( sqlite3_file *id, sqlite3_int64 *pSize ){\n  APIRET rc = NO_ERROR;\n  FILESTATUS3 fsts3FileInfo;\n  memset(&fsts3FileInfo, 0, sizeof(fsts3FileInfo));\n  assert( id!=0 );\n  SimulateIOError( return SQLITE_IOERR_FSTAT );\n  rc = DosQueryFileInfo( ((os2File*)id)->h, FIL_STANDARD, &fsts3FileInfo, sizeof(FILESTATUS3) );\n  if( rc == NO_ERROR ){\n    *pSize = fsts3FileInfo.cbFile;\n    return SQLITE_OK;\n  }else{\n    return SQLITE_IOERR_FSTAT;\n  }\n}\n\n/*\n** Acquire a reader lock.\n*/\nstatic int getReadLock( os2File *pFile ){\n  FILELOCK  LockArea,\n            UnlockArea;\n  APIRET res;\n  memset(&LockArea, 0, sizeof(LockArea));\n  memset(&UnlockArea, 0, sizeof(UnlockArea));\n  LockArea.lOffset = SHARED_FIRST;\n  LockArea.lRange = SHARED_SIZE;\n  UnlockArea.lOffset = 0L;\n  UnlockArea.lRange = 0L;\n  res = DosSetFileLocks( pFile->h, &UnlockArea, &LockArea, LOCK_TIMEOUT, 1L );\n  OSTRACE(( \"GETREADLOCK %d res=%d\\n\", pFile->h, res ));\n  return res;\n}\n\n/*\n** Undo a readlock\n*/\nstatic int unlockReadLock( os2File *id ){\n  FILELOCK  LockArea,\n            UnlockArea;\n  APIRET res;\n  memset(&LockArea, 0, sizeof(LockArea));\n  memset(&UnlockArea, 0, sizeof(UnlockArea));\n  LockArea.lOffset = 0L;\n  LockArea.lRange = 0L;\n  UnlockArea.lOffset = SHARED_FIRST;\n  UnlockArea.lRange = SHARED_SIZE;\n  res = DosSetFileLocks( id->h, &UnlockArea, &LockArea, LOCK_TIMEOUT, 1L );\n  OSTRACE(( \"UNLOCK-READLOCK file handle=%d res=%d?\\n\", id->h, res ));\n  return res;\n}\n\n/*\n** Lock the file with the lock specified by parameter locktype - one\n** of the following:\n**\n**     (1) SHARED_LOCK\n**     (2) RESERVED_LOCK\n**     (3) PENDING_LOCK\n**     (4) EXCLUSIVE_LOCK\n**\n** Sometimes when requesting one lock state, additional lock states\n** are inserted in between.  The locking might fail on one of the later\n** transitions leaving the lock state different from what it started but\n** still short of its goal.  The following chart shows the allowed\n** transitions and the inserted intermediate states:\n**\n**    UNLOCKED -> SHARED\n**    SHARED -> RESERVED\n**    SHARED -> (PENDING) -> EXCLUSIVE\n**    RESERVED -> (PENDING) -> EXCLUSIVE\n**    PENDING -> EXCLUSIVE\n**\n** This routine will only increase a lock.  The os2Unlock() routine\n** erases all locks at once and returns us immediately to locking level 0.\n** It is not possible to lower the locking level one step at a time.  You\n** must go straight to locking level 0.\n*/\nstatic int os2Lock( sqlite3_file *id, int locktype ){\n  int rc = SQLITE_OK;       /* Return code from subroutines */\n  APIRET res = NO_ERROR;    /* Result of an OS/2 lock call */\n  int newLocktype;       /* Set pFile->locktype to this value before exiting */\n  int gotPendingLock = 0;/* True if we acquired a PENDING lock this time */\n  FILELOCK  LockArea,\n            UnlockArea;\n  os2File *pFile = (os2File*)id;\n  memset(&LockArea, 0, sizeof(LockArea));\n  memset(&UnlockArea, 0, sizeof(UnlockArea));\n  assert( pFile!=0 );\n  OSTRACE(( \"LOCK %d %d was %d\\n\", pFile->h, locktype, pFile->locktype ));\n\n  /* If there is already a lock of this type or more restrictive on the\n  ** os2File, do nothing. Don't use the end_lock: exit path, as\n  ** sqlite3_mutex_enter() hasn't been called yet.\n  */\n  if( pFile->locktype>=locktype ){\n    OSTRACE(( \"LOCK %d %d ok (already held)\\n\", pFile->h, locktype ));\n    return SQLITE_OK;\n  }\n\n  /* Make sure the locking sequence is correct\n  */\n  assert( pFile->locktype!=NO_LOCK || locktype==SHARED_LOCK );\n  assert( locktype!=PENDING_LOCK );\n  assert( locktype!=RESERVED_LOCK || pFile->locktype==SHARED_LOCK );\n\n  /* Lock the PENDING_LOCK byte if we need to acquire a PENDING lock or\n  ** a SHARED lock.  If we are acquiring a SHARED lock, the acquisition of\n  ** the PENDING_LOCK byte is temporary.\n  */\n  newLocktype = pFile->locktype;\n  if( pFile->locktype==NO_LOCK\n      || (locktype==EXCLUSIVE_LOCK && pFile->locktype==RESERVED_LOCK)\n  ){\n    LockArea.lOffset = PENDING_BYTE;\n    LockArea.lRange = 1L;\n    UnlockArea.lOffset = 0L;\n    UnlockArea.lRange = 0L;\n\n    /* wait longer than LOCK_TIMEOUT here not to have to try multiple times */\n    res = DosSetFileLocks( pFile->h, &UnlockArea, &LockArea, 100L, 0L );\n    if( res == NO_ERROR ){\n      gotPendingLock = 1;\n      OSTRACE(( \"LOCK %d pending lock boolean set.  res=%d\\n\", pFile->h, res ));\n    }\n  }\n\n  /* Acquire a shared lock\n  */\n  if( locktype==SHARED_LOCK && res == NO_ERROR ){\n    assert( pFile->locktype==NO_LOCK );\n    res = getReadLock(pFile);\n    if( res == NO_ERROR ){\n      newLocktype = SHARED_LOCK;\n    }\n    OSTRACE(( \"LOCK %d acquire shared lock. res=%d\\n\", pFile->h, res ));\n  }\n\n  /* Acquire a RESERVED lock\n  */\n  if( locktype==RESERVED_LOCK && res == NO_ERROR ){\n    assert( pFile->locktype==SHARED_LOCK );\n    LockArea.lOffset = RESERVED_BYTE;\n    LockArea.lRange = 1L;\n    UnlockArea.lOffset = 0L;\n    UnlockArea.lRange = 0L;\n    res = DosSetFileLocks( pFile->h, &UnlockArea, &LockArea, LOCK_TIMEOUT, 0L );\n    if( res == NO_ERROR ){\n      newLocktype = RESERVED_LOCK;\n    }\n    OSTRACE(( \"LOCK %d acquire reserved lock. res=%d\\n\", pFile->h, res ));\n  }\n\n  /* Acquire a PENDING lock\n  */\n  if( locktype==EXCLUSIVE_LOCK && res == NO_ERROR ){\n    newLocktype = PENDING_LOCK;\n    gotPendingLock = 0;\n    OSTRACE(( \"LOCK %d acquire pending lock. pending lock boolean unset.\\n\",\n               pFile->h ));\n  }\n\n  /* Acquire an EXCLUSIVE lock\n  */\n  if( locktype==EXCLUSIVE_LOCK && res == NO_ERROR ){\n    assert( pFile->locktype>=SHARED_LOCK );\n    res = unlockReadLock(pFile);\n    OSTRACE(( \"unreadlock = %d\\n\", res ));\n    LockArea.lOffset = SHARED_FIRST;\n    LockArea.lRange = SHARED_SIZE;\n    UnlockArea.lOffset = 0L;\n    UnlockArea.lRange = 0L;\n    res = DosSetFileLocks( pFile->h, &UnlockArea, &LockArea, LOCK_TIMEOUT, 0L );\n    if( res == NO_ERROR ){\n      newLocktype = EXCLUSIVE_LOCK;\n    }else{\n      OSTRACE(( \"OS/2 error-code = %d\\n\", res ));\n      getReadLock(pFile);\n    }\n    OSTRACE(( \"LOCK %d acquire exclusive lock.  res=%d\\n\", pFile->h, res ));\n  }\n\n  /* If we are holding a PENDING lock that ought to be released, then\n  ** release it now.\n  */\n  if( gotPendingLock && locktype==SHARED_LOCK ){\n    int r;\n    LockArea.lOffset = 0L;\n    LockArea.lRange = 0L;\n    UnlockArea.lOffset = PENDING_BYTE;\n    UnlockArea.lRange = 1L;\n    r = DosSetFileLocks( pFile->h, &UnlockArea, &LockArea, LOCK_TIMEOUT, 0L );\n    OSTRACE(( \"LOCK %d unlocking pending/is shared. r=%d\\n\", pFile->h, r ));\n  }\n\n  /* Update the state of the lock has held in the file descriptor then\n  ** return the appropriate result code.\n  */\n  if( res == NO_ERROR ){\n    rc = SQLITE_OK;\n  }else{\n    OSTRACE(( \"LOCK FAILED %d trying for %d but got %d\\n\", pFile->h,\n              locktype, newLocktype ));\n    rc = SQLITE_BUSY;\n  }\n  pFile->locktype = newLocktype;\n  OSTRACE(( \"LOCK %d now %d\\n\", pFile->h, pFile->locktype ));\n  return rc;\n}\n\n/*\n** This routine checks if there is a RESERVED lock held on the specified\n** file by this or any other process. If such a lock is held, return\n** non-zero, otherwise zero.\n*/\nstatic int os2CheckReservedLock( sqlite3_file *id, int *pOut ){\n  int r = 0;\n  os2File *pFile = (os2File*)id;\n  assert( pFile!=0 );\n  if( pFile->locktype>=RESERVED_LOCK ){\n    r = 1;\n    OSTRACE(( \"TEST WR-LOCK %d %d (local)\\n\", pFile->h, r ));\n  }else{\n    FILELOCK  LockArea,\n              UnlockArea;\n    APIRET rc = NO_ERROR;\n    memset(&LockArea, 0, sizeof(LockArea));\n    memset(&UnlockArea, 0, sizeof(UnlockArea));\n    LockArea.lOffset = RESERVED_BYTE;\n    LockArea.lRange = 1L;\n    UnlockArea.lOffset = 0L;\n    UnlockArea.lRange = 0L;\n    rc = DosSetFileLocks( pFile->h, &UnlockArea, &LockArea, LOCK_TIMEOUT, 0L );\n    OSTRACE(( \"TEST WR-LOCK %d lock reserved byte rc=%d\\n\", pFile->h, rc ));\n    if( rc == NO_ERROR ){\n      APIRET rcu = NO_ERROR; /* return code for unlocking */\n      LockArea.lOffset = 0L;\n      LockArea.lRange = 0L;\n      UnlockArea.lOffset = RESERVED_BYTE;\n      UnlockArea.lRange = 1L;\n      rcu = DosSetFileLocks( pFile->h, &UnlockArea, &LockArea, LOCK_TIMEOUT, 0L );\n      OSTRACE(( \"TEST WR-LOCK %d unlock reserved byte r=%d\\n\", pFile->h, rcu ));\n    }\n    r = !(rc == NO_ERROR);\n    OSTRACE(( \"TEST WR-LOCK %d %d (remote)\\n\", pFile->h, r ));\n  }\n  *pOut = r;\n  return SQLITE_OK;\n}\n\n/*\n** Lower the locking level on file descriptor id to locktype.  locktype\n** must be either NO_LOCK or SHARED_LOCK.\n**\n** If the locking level of the file descriptor is already at or below\n** the requested locking level, this routine is a no-op.\n**\n** It is not possible for this routine to fail if the second argument\n** is NO_LOCK.  If the second argument is SHARED_LOCK then this routine\n** might return SQLITE_IOERR;\n*/\nstatic int os2Unlock( sqlite3_file *id, int locktype ){\n  int type;\n  os2File *pFile = (os2File*)id;\n  APIRET rc = SQLITE_OK;\n  APIRET res = NO_ERROR;\n  FILELOCK  LockArea,\n            UnlockArea;\n  memset(&LockArea, 0, sizeof(LockArea));\n  memset(&UnlockArea, 0, sizeof(UnlockArea));\n  assert( pFile!=0 );\n  assert( locktype<=SHARED_LOCK );\n  OSTRACE(( \"UNLOCK %d to %d was %d\\n\", pFile->h, locktype, pFile->locktype ));\n  type = pFile->locktype;\n  if( type>=EXCLUSIVE_LOCK ){\n    LockArea.lOffset = 0L;\n    LockArea.lRange = 0L;\n    UnlockArea.lOffset = SHARED_FIRST;\n    UnlockArea.lRange = SHARED_SIZE;\n    res = DosSetFileLocks( pFile->h, &UnlockArea, &LockArea, LOCK_TIMEOUT, 0L );\n    OSTRACE(( \"UNLOCK %d exclusive lock res=%d\\n\", pFile->h, res ));\n    if( locktype==SHARED_LOCK && getReadLock(pFile) != NO_ERROR ){\n      /* This should never happen.  We should always be able to\n      ** reacquire the read lock */\n      OSTRACE(( \"UNLOCK %d to %d getReadLock() failed\\n\", pFile->h, locktype ));\n      rc = SQLITE_IOERR_UNLOCK;\n    }\n  }\n  if( type>=RESERVED_LOCK ){\n    LockArea.lOffset = 0L;\n    LockArea.lRange = 0L;\n    UnlockArea.lOffset = RESERVED_BYTE;\n    UnlockArea.lRange = 1L;\n    res = DosSetFileLocks( pFile->h, &UnlockArea, &LockArea, LOCK_TIMEOUT, 0L );\n    OSTRACE(( \"UNLOCK %d reserved res=%d\\n\", pFile->h, res ));\n  }\n  if( locktype==NO_LOCK && type>=SHARED_LOCK ){\n    res = unlockReadLock(pFile);\n    OSTRACE(( \"UNLOCK %d is %d want %d res=%d\\n\",\n              pFile->h, type, locktype, res ));\n  }\n  if( type>=PENDING_LOCK ){\n    LockArea.lOffset = 0L;\n    LockArea.lRange = 0L;\n    UnlockArea.lOffset = PENDING_BYTE;\n    UnlockArea.lRange = 1L;\n    res = DosSetFileLocks( pFile->h, &UnlockArea, &LockArea, LOCK_TIMEOUT, 0L );\n    OSTRACE(( \"UNLOCK %d pending res=%d\\n\", pFile->h, res ));\n  }\n  pFile->locktype = locktype;\n  OSTRACE(( \"UNLOCK %d now %d\\n\", pFile->h, pFile->locktype ));\n  return rc;\n}\n\n/*\n** Control and query of the open file handle.\n*/\nstatic int os2FileControl(sqlite3_file *id, int op, void *pArg){\n  switch( op ){\n    case SQLITE_FCNTL_LOCKSTATE: {\n      *(int*)pArg = ((os2File*)id)->locktype;\n      OSTRACE(( \"FCNTL_LOCKSTATE %d lock=%d\\n\",\n                ((os2File*)id)->h, ((os2File*)id)->locktype ));\n      return SQLITE_OK;\n    }\n  }\n  return SQLITE_NOTFOUND;\n}\n\n/*\n** Return the sector size in bytes of the underlying block device for\n** the specified file. This is almost always 512 bytes, but may be\n** larger for some devices.\n**\n** SQLite code assumes this function cannot fail. It also assumes that\n** if two files are created in the same file-system directory (i.e.\n** a database and its journal file) that the sector size will be the\n** same for both.\n*/\nstatic int os2SectorSize(sqlite3_file *id){\n  return SQLITE_DEFAULT_SECTOR_SIZE;\n}\n\n/*\n** Return a vector of device characteristics.\n*/\nstatic int os2DeviceCharacteristics(sqlite3_file *id){\n  return 0;\n}\n\n\n/*\n** Character set conversion objects used by conversion routines.\n*/\nstatic UconvObject ucUtf8 = NULL; /* convert between UTF-8 and UCS-2 */\nstatic UconvObject uclCp = NULL;  /* convert between local codepage and UCS-2 */\n\n/*\n** Helper function to initialize the conversion objects from and to UTF-8.\n*/\nstatic void initUconvObjects( void ){\n  if( UniCreateUconvObject( UTF_8, &ucUtf8 ) != ULS_SUCCESS )\n    ucUtf8 = NULL;\n  if ( UniCreateUconvObject( (UniChar *)L\"@path=yes\", &uclCp ) != ULS_SUCCESS )\n    uclCp = NULL;\n}\n\n/*\n** Helper function to free the conversion objects from and to UTF-8.\n*/\nstatic void freeUconvObjects( void ){\n  if ( ucUtf8 )\n    UniFreeUconvObject( ucUtf8 );\n  if ( uclCp )\n    UniFreeUconvObject( uclCp );\n  ucUtf8 = NULL;\n  uclCp = NULL;\n}\n\n/*\n** Helper function to convert UTF-8 filenames to local OS/2 codepage.\n** The two-step process: first convert the incoming UTF-8 string\n** into UCS-2 and then from UCS-2 to the current codepage.\n** The returned char pointer has to be freed.\n*/\nstatic char *convertUtf8PathToCp( const char *in ){\n  UniChar tempPath[CCHMAXPATH];\n  char *out = (char *)calloc( CCHMAXPATH, 1 );\n\n  if( !out )\n    return NULL;\n\n  if( !ucUtf8 || !uclCp )\n    initUconvObjects();\n\n  /* determine string for the conversion of UTF-8 which is CP1208 */\n  if( UniStrToUcs( ucUtf8, tempPath, (char *)in, CCHMAXPATH ) != ULS_SUCCESS )\n    return out; /* if conversion fails, return the empty string */\n\n  /* conversion for current codepage which can be used for paths */\n  UniStrFromUcs( uclCp, out, tempPath, CCHMAXPATH );\n\n  return out;\n}\n\n/*\n** Helper function to convert filenames from local codepage to UTF-8.\n** The two-step process: first convert the incoming codepage-specific\n** string into UCS-2 and then from UCS-2 to the codepage of UTF-8.\n** The returned char pointer has to be freed.\n**\n** This function is non-static to be able to use this in shell.c and\n** similar applications that take command line arguments.\n*/\nchar *convertCpPathToUtf8( const char *in ){\n  UniChar tempPath[CCHMAXPATH];\n  char *out = (char *)calloc( CCHMAXPATH, 1 );\n\n  if( !out )\n    return NULL;\n\n  if( !ucUtf8 || !uclCp )\n    initUconvObjects();\n\n  /* conversion for current codepage which can be used for paths */\n  if( UniStrToUcs( uclCp, tempPath, (char *)in, CCHMAXPATH ) != ULS_SUCCESS )\n    return out; /* if conversion fails, return the empty string */\n\n  /* determine string for the conversion of UTF-8 which is CP1208 */\n  UniStrFromUcs( ucUtf8, out, tempPath, CCHMAXPATH );\n\n  return out;\n}\n\n/*\n** This vector defines all the methods that can operate on an\n** sqlite3_file for os2.\n*/\nstatic const sqlite3_io_methods os2IoMethod = {\n  1,                              /* iVersion */\n  os2Close,                       /* xClose */\n  os2Read,                        /* xRead */\n  os2Write,                       /* xWrite */\n  os2Truncate,                    /* xTruncate */\n  os2Sync,                        /* xSync */\n  os2FileSize,                    /* xFileSize */\n  os2Lock,                        /* xLock */\n  os2Unlock,                      /* xUnlock */\n  os2CheckReservedLock,           /* xCheckReservedLock */\n  os2FileControl,                 /* xFileControl */\n  os2SectorSize,                  /* xSectorSize */\n  os2DeviceCharacteristics,       /* xDeviceCharacteristics */\n  0,                              /* xShmMap */\n  0,                              /* xShmLock */\n  0,                              /* xShmBarrier */\n  0                               /* xShmUnmap */\n};\n\n/***************************************************************************\n** Here ends the I/O methods that form the sqlite3_io_methods object.\n**\n** The next block of code implements the VFS methods.\n****************************************************************************/\n\n/*\n** Create a temporary file name in zBuf.  zBuf must be big enough to\n** hold at pVfs->mxPathname characters.\n*/\nstatic int getTempname(int nBuf, char *zBuf ){\n  static const unsigned char zChars[] =\n    \"abcdefghijklmnopqrstuvwxyz\"\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    \"0123456789\";\n  int i, j;\n  char zTempPathBuf[3];\n  PSZ zTempPath = (PSZ)&zTempPathBuf;\n  if( sqlite3_temp_directory ){\n    zTempPath = sqlite3_temp_directory;\n  }else{\n    if( DosScanEnv( (PSZ)\"TEMP\", &zTempPath ) ){\n      if( DosScanEnv( (PSZ)\"TMP\", &zTempPath ) ){\n        if( DosScanEnv( (PSZ)\"TMPDIR\", &zTempPath ) ){\n           ULONG ulDriveNum = 0, ulDriveMap = 0;\n           DosQueryCurrentDisk( &ulDriveNum, &ulDriveMap );\n           sprintf( (char*)zTempPath, \"%c:\", (char)( 'A' + ulDriveNum - 1 ) );\n        }\n      }\n    }\n  }\n  /* Strip off a trailing slashes or backslashes, otherwise we would get *\n   * multiple (back)slashes which causes DosOpen() to fail.              *\n   * Trailing spaces are not allowed, either.                            */\n  j = sqlite3Strlen30(zTempPath);\n  while( j > 0 && ( zTempPath[j-1] == '\\\\' || zTempPath[j-1] == '/'\n                    || zTempPath[j-1] == ' ' ) ){\n    j--;\n  }\n  zTempPath[j] = '\\0';\n  if( !sqlite3_temp_directory ){\n    char *zTempPathUTF = convertCpPathToUtf8( zTempPath );\n    sqlite3_snprintf( nBuf-30, zBuf,\n                      \"%s\\\\\"SQLITE_TEMP_FILE_PREFIX, zTempPathUTF );\n    free( zTempPathUTF );\n  }else{\n    sqlite3_snprintf( nBuf-30, zBuf,\n                      \"%s\\\\\"SQLITE_TEMP_FILE_PREFIX, zTempPath );\n  }\n  j = sqlite3Strlen30( zBuf );\n  sqlite3_randomness( 20, &zBuf[j] );\n  for( i = 0; i < 20; i++, j++ ){\n    zBuf[j] = (char)zChars[ ((unsigned char)zBuf[j])%(sizeof(zChars)-1) ];\n  }\n  zBuf[j] = 0;\n  OSTRACE(( \"TEMP FILENAME: %s\\n\", zBuf ));\n  return SQLITE_OK;\n}\n\n\n/*\n** Turn a relative pathname into a full pathname.  Write the full\n** pathname into zFull[].  zFull[] will be at least pVfs->mxPathname\n** bytes in size.\n*/\nstatic int os2FullPathname(\n  sqlite3_vfs *pVfs,          /* Pointer to vfs object */\n  const char *zRelative,      /* Possibly relative input path */\n  int nFull,                  /* Size of output buffer in bytes */\n  char *zFull                 /* Output buffer */\n){\n  char *zRelativeCp = convertUtf8PathToCp( zRelative );\n  char zFullCp[CCHMAXPATH] = \"\\0\";\n  char *zFullUTF;\n  APIRET rc = DosQueryPathInfo( zRelativeCp, FIL_QUERYFULLNAME, zFullCp,\n                                CCHMAXPATH );\n  free( zRelativeCp );\n  zFullUTF = convertCpPathToUtf8( zFullCp );\n  sqlite3_snprintf( nFull, zFull, zFullUTF );\n  free( zFullUTF );\n  return rc == NO_ERROR ? SQLITE_OK : SQLITE_IOERR;\n}\n\n\n/*\n** Open a file.\n*/\nstatic int os2Open(\n  sqlite3_vfs *pVfs,            /* Not used */\n  const char *zName,            /* Name of the file (UTF-8) */\n  sqlite3_file *id,             /* Write the SQLite file handle here */\n  int flags,                    /* Open mode flags */\n  int *pOutFlags                /* Status return flags */\n){\n  HFILE h;\n  ULONG ulOpenFlags = 0;\n  ULONG ulOpenMode = 0;\n  ULONG ulAction = 0;\n  ULONG rc;\n  os2File *pFile = (os2File*)id;\n  const char *zUtf8Name = zName;\n  char *zNameCp;\n  char  zTmpname[CCHMAXPATH];\n\n  int isExclusive  = (flags & SQLITE_OPEN_EXCLUSIVE);\n  int isDelete     = (flags & SQLITE_OPEN_DELETEONCLOSE);\n  int isCreate     = (flags & SQLITE_OPEN_CREATE);\n  int isReadWrite  = (flags & SQLITE_OPEN_READWRITE);\n#ifndef NDEBUG\n  int isReadonly   = (flags & SQLITE_OPEN_READONLY);\n  int eType        = (flags & 0xFFFFFF00);\n  int isOpenJournal = (isCreate && (\n        eType==SQLITE_OPEN_MASTER_JOURNAL \n     || eType==SQLITE_OPEN_MAIN_JOURNAL \n     || eType==SQLITE_OPEN_WAL\n  ));\n#endif\n\n  UNUSED_PARAMETER(pVfs);\n  assert( id!=0 );\n\n  /* Check the following statements are true: \n  **\n  **   (a) Exactly one of the READWRITE and READONLY flags must be set, and \n  **   (b) if CREATE is set, then READWRITE must also be set, and\n  **   (c) if EXCLUSIVE is set, then CREATE must also be set.\n  **   (d) if DELETEONCLOSE is set, then CREATE must also be set.\n  */\n  assert((isReadonly==0 || isReadWrite==0) && (isReadWrite || isReadonly));\n  assert(isCreate==0 || isReadWrite);\n  assert(isExclusive==0 || isCreate);\n  assert(isDelete==0 || isCreate);\n\n  /* The main DB, main journal, WAL file and master journal are never \n  ** automatically deleted. Nor are they ever temporary files.  */\n  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_MAIN_DB );\n  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_MAIN_JOURNAL );\n  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_MASTER_JOURNAL );\n  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_WAL );\n\n  /* Assert that the upper layer has set one of the \"file-type\" flags. */\n  assert( eType==SQLITE_OPEN_MAIN_DB      || eType==SQLITE_OPEN_TEMP_DB \n       || eType==SQLITE_OPEN_MAIN_JOURNAL || eType==SQLITE_OPEN_TEMP_JOURNAL \n       || eType==SQLITE_OPEN_SUBJOURNAL   || eType==SQLITE_OPEN_MASTER_JOURNAL \n       || eType==SQLITE_OPEN_TRANSIENT_DB || eType==SQLITE_OPEN_WAL\n  );\n\n  memset( pFile, 0, sizeof(*pFile) );\n  pFile->pMethod = &os2IoMethod;\n\n  /* If the second argument to this function is NULL, generate a \n  ** temporary file name to use \n  */\n  if( !zUtf8Name ){\n    assert(isDelete && !isOpenJournal);\n    rc = getTempname(CCHMAXPATH, zTmpname);\n    if( rc!=SQLITE_OK ){\n      return rc;\n    }\n    zUtf8Name = zTmpname;\n  }\n\n  if( isReadWrite ){\n    ulOpenMode |= OPEN_ACCESS_READWRITE;\n  }else{\n    ulOpenMode |= OPEN_ACCESS_READONLY;\n  }\n\n  /* Open in random access mode for possibly better speed.  Allow full\n  ** sharing because file locks will provide exclusive access when needed.\n  */\n  ulOpenMode |= OPEN_FLAGS_RANDOM;\n  ulOpenMode |= OPEN_FLAGS_FAIL_ON_ERROR;\n  ulOpenMode |= OPEN_FLAGS_NOINHERIT;\n  ulOpenMode |= OPEN_SHARE_DENYNONE;\n\n  /* SQLITE_OPEN_EXCLUSIVE is used to make sure that a new file is \n  ** created. SQLite doesn't use it to indicate \"exclusive access\" \n  ** as it is usually understood.\n  */\n  if( isExclusive ){\n    /* Creates a new file, only if it does not already exist. */\n    /* If the file exists, it fails. */\n    ulOpenFlags |= OPEN_ACTION_CREATE_IF_NEW | OPEN_ACTION_FAIL_IF_EXISTS;\n  }else if( isCreate ){\n    /* Open existing file, or create if it doesn't exist */\n    ulOpenFlags |= OPEN_ACTION_CREATE_IF_NEW | OPEN_ACTION_OPEN_IF_EXISTS;\n  }else{\n    /* Opens a file, only if it exists. */\n    ulOpenFlags |= OPEN_ACTION_FAIL_IF_NEW | OPEN_ACTION_OPEN_IF_EXISTS;\n  }\n\n  /* For DELETEONCLOSE, save a pointer to the converted filename */\n  if( isDelete ){\n    char pathUtf8[CCHMAXPATH];\n    os2FullPathname( pVfs, zUtf8Name, CCHMAXPATH, pathUtf8 );\n    pFile->pathToDel = convertUtf8PathToCp( pathUtf8 );\n  }\n\n  zNameCp = convertUtf8PathToCp( zUtf8Name );\n  rc = DosOpen( (PSZ)zNameCp,\n                &h,\n                &ulAction,\n                0L,\n                FILE_NORMAL,\n                ulOpenFlags,\n                ulOpenMode,\n                (PEAOP2)NULL );\n  free( zNameCp );\n\n  if( rc != NO_ERROR ){\n    OSTRACE(( \"OPEN Invalid handle rc=%d: zName=%s, ulAction=%#lx, ulFlags=%#lx, ulMode=%#lx\\n\",\n              rc, zUtf8Name, ulAction, ulOpenFlags, ulOpenMode ));\n    if( pFile->pathToDel )\n      free( pFile->pathToDel );\n    pFile->pathToDel = NULL;\n\n    if( isReadWrite ){\n      return os2Open( pVfs, zName, id,\n                      ((flags|SQLITE_OPEN_READONLY)&~(SQLITE_OPEN_CREATE|SQLITE_OPEN_READWRITE)),\n                      pOutFlags );\n    }else{\n      return SQLITE_CANTOPEN;\n    }\n  }\n\n  if( pOutFlags ){\n    *pOutFlags = isReadWrite ? SQLITE_OPEN_READWRITE : SQLITE_OPEN_READONLY;\n  }\n\n  pFile->h = h;\n  OpenCounter(+1);\n  OSTRACE(( \"OPEN %d pOutFlags=%d\\n\", pFile->h, pOutFlags ));\n  return SQLITE_OK;\n}\n\n/*\n** Delete the named file.\n*/\nstatic int os2Delete(\n  sqlite3_vfs *pVfs,                     /* Not used on os2 */\n  const char *zFilename,                 /* Name of file to delete */\n  int syncDir                            /* Not used on os2 */\n){\n  APIRET rc;\n  char *zFilenameCp;\n  SimulateIOError( return SQLITE_IOERR_DELETE );\n  zFilenameCp = convertUtf8PathToCp( zFilename );\n  rc = DosDelete( (PSZ)zFilenameCp );\n  free( zFilenameCp );\n  OSTRACE(( \"DELETE \\\"%s\\\"\\n\", zFilename ));\n  return (rc == NO_ERROR ||\n          rc == ERROR_FILE_NOT_FOUND ||\n          rc == ERROR_PATH_NOT_FOUND ) ? SQLITE_OK : SQLITE_IOERR_DELETE;\n}\n\n/*\n** Check the existance and status of a file.\n*/\nstatic int os2Access(\n  sqlite3_vfs *pVfs,        /* Not used on os2 */\n  const char *zFilename,    /* Name of file to check */\n  int flags,                /* Type of test to make on this file */\n  int *pOut                 /* Write results here */\n){\n  FILESTATUS3 fsts3ConfigInfo;\n  APIRET rc = NO_ERROR;\n  char *zFilenameCp = convertUtf8PathToCp( zFilename );\n\n  memset( &fsts3ConfigInfo, 0, sizeof(fsts3ConfigInfo) );\n  rc = DosQueryPathInfo( (PSZ)zFilenameCp, FIL_STANDARD,\n                         &fsts3ConfigInfo, sizeof(FILESTATUS3) );\n  free( zFilenameCp );\n  OSTRACE(( \"ACCESS fsts3ConfigInfo.attrFile=%d flags=%d rc=%d\\n\",\n            fsts3ConfigInfo.attrFile, flags, rc ));\n  switch( flags ){\n    case SQLITE_ACCESS_READ:\n    case SQLITE_ACCESS_EXISTS:\n      rc = (rc == NO_ERROR);\n      OSTRACE(( \"ACCESS %s access of read and exists  rc=%d\\n\", zFilename, rc));\n      break;\n    case SQLITE_ACCESS_READWRITE:\n      rc = (rc == NO_ERROR) && ( (fsts3ConfigInfo.attrFile & FILE_READONLY) == 0 );\n      OSTRACE(( \"ACCESS %s access of read/write  rc=%d\\n\", zFilename, rc ));\n      break;\n    default:\n      assert( !\"Invalid flags argument\" );\n  }\n  *pOut = rc;\n  return SQLITE_OK;\n}\n\n\n#ifndef SQLITE_OMIT_LOAD_EXTENSION\n/*\n** Interfaces for opening a shared library, finding entry points\n** within the shared library, and closing the shared library.\n*/\n/*\n** Interfaces for opening a shared library, finding entry points\n** within the shared library, and closing the shared library.\n*/\nstatic void *os2DlOpen(sqlite3_vfs *pVfs, const char *zFilename){\n  UCHAR loadErr[256];\n  HMODULE hmod;\n  APIRET rc;\n  char *zFilenameCp = convertUtf8PathToCp(zFilename);\n  rc = DosLoadModule((PSZ)loadErr, sizeof(loadErr), zFilenameCp, &hmod);\n  free(zFilenameCp);\n  return rc != NO_ERROR ? 0 : (void*)hmod;\n}\n/*\n** A no-op since the error code is returned on the DosLoadModule call.\n** os2Dlopen returns zero if DosLoadModule is not successful.\n*/\nstatic void os2DlError(sqlite3_vfs *pVfs, int nBuf, char *zBufOut){\n/* no-op */\n}\nstatic void (*os2DlSym(sqlite3_vfs *pVfs, void *pHandle, const char *zSymbol))(void){\n  PFN pfn;\n  APIRET rc;\n  rc = DosQueryProcAddr((HMODULE)pHandle, 0L, zSymbol, &pfn);\n  if( rc != NO_ERROR ){\n    /* if the symbol itself was not found, search again for the same\n     * symbol with an extra underscore, that might be needed depending\n     * on the calling convention */\n    char _zSymbol[256] = \"_\";\n    strncat(_zSymbol, zSymbol, 255);\n    rc = DosQueryProcAddr((HMODULE)pHandle, 0L, _zSymbol, &pfn);\n  }\n  return rc != NO_ERROR ? 0 : (void(*)(void))pfn;\n}\nstatic void os2DlClose(sqlite3_vfs *pVfs, void *pHandle){\n  DosFreeModule((HMODULE)pHandle);\n}\n#else /* if SQLITE_OMIT_LOAD_EXTENSION is defined: */\n  #define os2DlOpen 0\n  #define os2DlError 0\n  #define os2DlSym 0\n  #define os2DlClose 0\n#endif\n\n\n/*\n** Write up to nBuf bytes of randomness into zBuf.\n*/\nstatic int os2Randomness(sqlite3_vfs *pVfs, int nBuf, char *zBuf ){\n  int n = 0;\n#if defined(SQLITE_TEST)\n  n = nBuf;\n  memset(zBuf, 0, nBuf);\n#else\n  int sizeofULong = sizeof(ULONG);\n  if( (int)sizeof(DATETIME) <= nBuf - n ){\n    DATETIME x;\n    DosGetDateTime(&x);\n    memcpy(&zBuf[n], &x, sizeof(x));\n    n += sizeof(x);\n  }\n\n  if( sizeofULong <= nBuf - n ){\n    PPIB ppib;\n    DosGetInfoBlocks(NULL, &ppib);\n    memcpy(&zBuf[n], &ppib->pib_ulpid, sizeofULong);\n    n += sizeofULong;\n  }\n\n  if( sizeofULong <= nBuf - n ){\n    PTIB ptib;\n    DosGetInfoBlocks(&ptib, NULL);\n    memcpy(&zBuf[n], &ptib->tib_ptib2->tib2_ultid, sizeofULong);\n    n += sizeofULong;\n  }\n\n  /* if we still haven't filled the buffer yet the following will */\n  /* grab everything once instead of making several calls for a single item */\n  if( sizeofULong <= nBuf - n ){\n    ULONG ulSysInfo[QSV_MAX];\n    DosQuerySysInfo(1L, QSV_MAX, ulSysInfo, sizeofULong * QSV_MAX);\n\n    memcpy(&zBuf[n], &ulSysInfo[QSV_MS_COUNT - 1], sizeofULong);\n    n += sizeofULong;\n\n    if( sizeofULong <= nBuf - n ){\n      memcpy(&zBuf[n], &ulSysInfo[QSV_TIMER_INTERVAL - 1], sizeofULong);\n      n += sizeofULong;\n    }\n    if( sizeofULong <= nBuf - n ){\n      memcpy(&zBuf[n], &ulSysInfo[QSV_TIME_LOW - 1], sizeofULong);\n      n += sizeofULong;\n    }\n    if( sizeofULong <= nBuf - n ){\n      memcpy(&zBuf[n], &ulSysInfo[QSV_TIME_HIGH - 1], sizeofULong);\n      n += sizeofULong;\n    }\n    if( sizeofULong <= nBuf - n ){\n      memcpy(&zBuf[n], &ulSysInfo[QSV_TOTAVAILMEM - 1], sizeofULong);\n      n += sizeofULong;\n    }\n  }\n#endif\n\n  return n;\n}\n\n/*\n** Sleep for a little while.  Return the amount of time slept.\n** The argument is the number of microseconds we want to sleep.\n** The return value is the number of microseconds of sleep actually\n** requested from the underlying operating system, a number which\n** might be greater than or equal to the argument, but not less\n** than the argument.\n*/\nstatic int os2Sleep( sqlite3_vfs *pVfs, int microsec ){\n  DosSleep( (microsec/1000) );\n  return microsec;\n}\n\n/*\n** The following variable, if set to a non-zero value, becomes the result\n** returned from sqlite3OsCurrentTime().  This is used for testing.\n*/\n#ifdef SQLITE_TEST\nSQLITE_API int sqlite3_current_time = 0;\n#endif\n\n/*\n** Find the current time (in Universal Coordinated Time).  Write the\n** current time and date as a Julian Day number into *prNow and\n** return 0.  Return 1 if the time and date cannot be found.\n*/\nint os2CurrentTime( sqlite3_vfs *pVfs, double *prNow ){\n  double now;\n  SHORT minute; /* needs to be able to cope with negative timezone offset */\n  USHORT hundredths, second, hour,\n         day, month, year;\n  DATETIME dt;\n  DosGetDateTime( &dt );\n  hundredths = (USHORT)dt.hundredths;\n  second = (USHORT)dt.seconds;\n  minute = (SHORT)dt.minutes + dt.timezone;\n  hour = (USHORT)dt.hours;\n  day = (USHORT)dt.day;\n  month = (USHORT)dt.month;\n  year = (USHORT)dt.year;\n\n  /* Calculations from http://www.astro.keele.ac.uk/~rno/Astronomy/hjd.html\n     http://www.astro.keele.ac.uk/~rno/Astronomy/hjd-0.1.c */\n  /* Calculate the Julian days */\n  now = day - 32076 +\n    1461*(year + 4800 + (month - 14)/12)/4 +\n    367*(month - 2 - (month - 14)/12*12)/12 -\n    3*((year + 4900 + (month - 14)/12)/100)/4;\n\n  /* Add the fractional hours, mins and seconds */\n  now += (hour + 12.0)/24.0;\n  now += minute/1440.0;\n  now += second/86400.0;\n  now += hundredths/8640000.0;\n  *prNow = now;\n#ifdef SQLITE_TEST\n  if( sqlite3_current_time ){\n    *prNow = sqlite3_current_time/86400.0 + 2440587.5;\n  }\n#endif\n  return 0;\n}\n\n/*\n** Find the current time (in Universal Coordinated Time).  Write into *piNow\n** the current time and date as a Julian Day number times 86_400_000.  In\n** other words, write into *piNow the number of milliseconds since the Julian\n** epoch of noon in Greenwich on November 24, 4714 B.C according to the\n** proleptic Gregorian calendar.\n**\n** On success, return 0.  Return 1 if the time and date cannot be found.\n*/\nstatic int os2CurrentTimeInt64(sqlite3_vfs *pVfs, sqlite3_int64 *piNow){\n  double now;\n  os2CurrentTime(pVfs, &now);\n  *piNow = now * 86400000;\n  return 0;\n}\n\nstatic int os2GetLastError(sqlite3_vfs *pVfs, int nBuf, char *zBuf){\n  return 0;\n}\n\n/*\n** Initialize and deinitialize the operating system interface.\n*/\nSQLITE_API int sqlite3_os_init(void){\n  static sqlite3_vfs os2Vfs = {\n    3,                 /* iVersion */\n    sizeof(os2File),   /* szOsFile */\n    CCHMAXPATH,        /* mxPathname */\n    0,                 /* pNext */\n    \"os2\",             /* zName */\n    0,                 /* pAppData */\n\n    os2Open,           /* xOpen */\n    os2Delete,         /* xDelete */\n    os2Access,         /* xAccess */\n    os2FullPathname,   /* xFullPathname */\n    os2DlOpen,         /* xDlOpen */\n    os2DlError,        /* xDlError */\n    os2DlSym,          /* xDlSym */\n    os2DlClose,        /* xDlClose */\n    os2Randomness,     /* xRandomness */\n    os2Sleep,          /* xSleep */\n    os2CurrentTime,    /* xCurrentTime */\n    os2GetLastError,   /* xGetLastError */\n    os2CurrentTimeInt64 /* xCurrentTimeInt64 */\n    0,                 /* xSetSystemCall */\n    0,                 /* xGetSystemCall */\n    0,                 /* xNextSystemCall */\n  };\n  sqlite3_vfs_register(&os2Vfs, 1);\n  initUconvObjects();\n  return SQLITE_OK;\n}\nSQLITE_API int sqlite3_os_end(void){\n  freeUconvObjects();\n  return SQLITE_OK;\n}\n\n#endif /* SQLITE_OS_OS2 */\n\n/************** End of os_os2.c **********************************************/\n/************** Begin file os_unix.c *****************************************/\n/*\n** 2004 May 22\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n******************************************************************************\n**\n** This file contains the VFS implementation for unix-like operating systems\n** include Linux, MacOSX, *BSD, QNX, VxWorks, AIX, HPUX, and others.\n**\n** There are actually several different VFS implementations in this file.\n** The differences are in the way that file locking is done.  The default\n** implementation uses Posix Advisory Locks.  Alternative implementations\n** use flock(), dot-files, various proprietary locking schemas, or simply\n** skip locking all together.\n**\n** This source file is organized into divisions where the logic for various\n** subfunctions is contained within the appropriate division.  PLEASE\n** KEEP THE STRUCTURE OF THIS FILE INTACT.  New code should be placed\n** in the correct division and should be clearly labeled.\n**\n** The layout of divisions is as follows:\n**\n**   *  General-purpose declarations and utility functions.\n**   *  Unique file ID logic used by VxWorks.\n**   *  Various locking primitive implementations (all except proxy locking):\n**      + for Posix Advisory Locks\n**      + for no-op locks\n**      + for dot-file locks\n**      + for flock() locking\n**      + for named semaphore locks (VxWorks only)\n**      + for AFP filesystem locks (MacOSX only)\n**   *  sqlite3_file methods not associated with locking.\n**   *  Definitions of sqlite3_io_methods objects for all locking\n**      methods plus \"finder\" functions for each locking method.\n**   *  sqlite3_vfs method implementations.\n**   *  Locking primitives for the proxy uber-locking-method. (MacOSX only)\n**   *  Definitions of sqlite3_vfs objects for all locking methods\n**      plus implementations of sqlite3_os_init() and sqlite3_os_end().\n*/\n#if SQLITE_OS_UNIX              /* This file is used on unix only */\n\n/*\n** There are various methods for file locking used for concurrency\n** control:\n**\n**   1. POSIX locking (the default),\n**   2. No locking,\n**   3. Dot-file locking,\n**   4. flock() locking,\n**   5. AFP locking (OSX only),\n**   6. Named POSIX semaphores (VXWorks only),\n**   7. proxy locking. (OSX only)\n**\n** Styles 4, 5, and 7 are only available of SQLITE_ENABLE_LOCKING_STYLE\n** is defined to 1.  The SQLITE_ENABLE_LOCKING_STYLE also enables automatic\n** selection of the appropriate locking style based on the filesystem\n** where the database is located.  \n*/\n#if !defined(SQLITE_ENABLE_LOCKING_STYLE)\n#  if defined(__APPLE__)\n#    define SQLITE_ENABLE_LOCKING_STYLE 1\n#  else\n#    define SQLITE_ENABLE_LOCKING_STYLE 0\n#  endif\n#endif\n\n/*\n** Define the OS_VXWORKS pre-processor macro to 1 if building on \n** vxworks, or 0 otherwise.\n*/\n#ifndef OS_VXWORKS\n#  if defined(__RTP__) || defined(_WRS_KERNEL)\n#    define OS_VXWORKS 1\n#  else\n#    define OS_VXWORKS 0\n#  endif\n#endif\n\n/*\n** These #defines should enable >2GB file support on Posix if the\n** underlying operating system supports it.  If the OS lacks\n** large file support, these should be no-ops.\n**\n** Large file support can be disabled using the -DSQLITE_DISABLE_LFS switch\n** on the compiler command line.  This is necessary if you are compiling\n** on a recent machine (ex: RedHat 7.2) but you want your code to work\n** on an older machine (ex: RedHat 6.0).  If you compile on RedHat 7.2\n** without this option, LFS is enable.  But LFS does not exist in the kernel\n** in RedHat 6.0, so the code won't work.  Hence, for maximum binary\n** portability you should omit LFS.\n**\n** The previous paragraph was written in 2005.  (This paragraph is written\n** on 2008-11-28.) These days, all Linux kernels support large files, so\n** you should probably leave LFS enabled.  But some embedded platforms might\n** lack LFS in which case the SQLITE_DISABLE_LFS macro might still be useful.\n*/\n#ifndef SQLITE_DISABLE_LFS\n# define _LARGE_FILE       1\n# ifndef _FILE_OFFSET_BITS\n#   define _FILE_OFFSET_BITS 64\n# endif\n# define _LARGEFILE_SOURCE 1\n#endif\n\n/*\n** standard include files.\n*/\n#include <sys/types.h>\n#include <sys/stat.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/time.h>\n#include <errno.h>\n#ifndef SQLITE_OMIT_WAL\n#include <sys/mman.h>\n#endif\n\n#if SQLITE_ENABLE_LOCKING_STYLE\n# include <sys/ioctl.h>\n# if OS_VXWORKS\n#  include <semaphore.h>\n#  include <limits.h>\n# else\n#  include <sys/file.h>\n#  include <sys/param.h>\n# endif\n#endif /* SQLITE_ENABLE_LOCKING_STYLE */\n\n#if defined(__APPLE__) || (SQLITE_ENABLE_LOCKING_STYLE && !OS_VXWORKS)\n# include <sys/mount.h>\n#endif\n\n/*\n** Allowed values of unixFile.fsFlags\n*/\n#define SQLITE_FSFLAGS_IS_MSDOS     0x1\n\n/*\n** If we are to be thread-safe, include the pthreads header and define\n** the SQLITE_UNIX_THREADS macro.\n*/\n#if SQLITE_THREADSAFE\n# define SQLITE_UNIX_THREADS 1\n#endif\n\n/*\n** Default permissions when creating a new file\n*/\n#ifndef SQLITE_DEFAULT_FILE_PERMISSIONS\n# define SQLITE_DEFAULT_FILE_PERMISSIONS 0644\n#endif\n\n/*\n ** Default permissions when creating auto proxy dir\n */\n#ifndef SQLITE_DEFAULT_PROXYDIR_PERMISSIONS\n# define SQLITE_DEFAULT_PROXYDIR_PERMISSIONS 0755\n#endif\n\n/*\n** Maximum supported path-length.\n*/\n#define MAX_PATHNAME 512\n\n/*\n** Only set the lastErrno if the error code is a real error and not \n** a normal expected return code of SQLITE_BUSY or SQLITE_OK\n*/\n#define IS_LOCK_ERROR(x)  ((x != SQLITE_OK) && (x != SQLITE_BUSY))\n\n/* Forward references */\ntypedef struct unixShm unixShm;               /* Connection shared memory */\ntypedef struct unixShmNode unixShmNode;       /* Shared memory instance */\ntypedef struct unixInodeInfo unixInodeInfo;   /* An i-node */\ntypedef struct UnixUnusedFd UnixUnusedFd;     /* An unused file descriptor */\n\n/*\n** Sometimes, after a file handle is closed by SQLite, the file descriptor\n** cannot be closed immediately. In these cases, instances of the following\n** structure are used to store the file descriptor while waiting for an\n** opportunity to either close or reuse it.\n*/\nstruct UnixUnusedFd {\n  int fd;                   /* File descriptor to close */\n  int flags;                /* Flags this file descriptor was opened with */\n  UnixUnusedFd *pNext;      /* Next unused file descriptor on same file */\n};\n\n/*\n** The unixFile structure is subclass of sqlite3_file specific to the unix\n** VFS implementations.\n*/\ntypedef struct unixFile unixFile;\nstruct unixFile {\n  sqlite3_io_methods const *pMethod;  /* Always the first entry */\n  unixInodeInfo *pInode;              /* Info about locks on this inode */\n  int h;                              /* The file descriptor */\n  int dirfd;                          /* File descriptor for the directory */\n  unsigned char eFileLock;            /* The type of lock held on this fd */\n  unsigned char ctrlFlags;            /* Behavioral bits.  UNIXFILE_* flags */\n  int lastErrno;                      /* The unix errno from last I/O error */\n  void *lockingContext;               /* Locking style specific state */\n  UnixUnusedFd *pUnused;              /* Pre-allocated UnixUnusedFd */\n  const char *zPath;                  /* Name of the file */\n  unixShm *pShm;                      /* Shared memory segment information */\n  int szChunk;                        /* Configured by FCNTL_CHUNK_SIZE */\n#if SQLITE_ENABLE_LOCKING_STYLE\n  int openFlags;                      /* The flags specified at open() */\n#endif\n#if SQLITE_ENABLE_LOCKING_STYLE || defined(__APPLE__)\n  unsigned fsFlags;                   /* cached details from statfs() */\n#endif\n#if OS_VXWORKS\n  int isDelete;                       /* Delete on close if true */\n  struct vxworksFileId *pId;          /* Unique file ID */\n#endif\n#ifndef NDEBUG\n  /* The next group of variables are used to track whether or not the\n  ** transaction counter in bytes 24-27 of database files are updated\n  ** whenever any part of the database changes.  An assertion fault will\n  ** occur if a file is updated without also updating the transaction\n  ** counter.  This test is made to avoid new problems similar to the\n  ** one described by ticket #3584. \n  */\n  unsigned char transCntrChng;   /* True if the transaction counter changed */\n  unsigned char dbUpdate;        /* True if any part of database file changed */\n  unsigned char inNormalWrite;   /* True if in a normal write operation */\n#endif\n#ifdef SQLITE_TEST\n  /* In test mode, increase the size of this structure a bit so that \n  ** it is larger than the struct CrashFile defined in test6.c.\n  */\n  char aPadding[32];\n#endif\n};\n\n/*\n** Allowed values for the unixFile.ctrlFlags bitmask:\n*/\n#define UNIXFILE_EXCL   0x01     /* Connections from one process only */\n#define UNIXFILE_RDONLY 0x02     /* Connection is read only */\n\n/*\n** Include code that is common to all os_*.c files\n*/\n/************** Include os_common.h in the middle of os_unix.c ***************/\n/************** Begin file os_common.h ***************************************/\n/*\n** 2004 May 22\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n******************************************************************************\n**\n** This file contains macros and a little bit of code that is common to\n** all of the platform-specific files (os_*.c) and is #included into those\n** files.\n**\n** This file should be #included by the os_*.c files only.  It is not a\n** general purpose header file.\n*/\n#ifndef _OS_COMMON_H_\n#define _OS_COMMON_H_\n\n/*\n** At least two bugs have slipped in because we changed the MEMORY_DEBUG\n** macro to SQLITE_DEBUG and some older makefiles have not yet made the\n** switch.  The following code should catch this problem at compile-time.\n*/\n#ifdef MEMORY_DEBUG\n# error \"The MEMORY_DEBUG macro is obsolete.  Use SQLITE_DEBUG instead.\"\n#endif\n\n#ifdef SQLITE_DEBUG\nSQLITE_PRIVATE int sqlite3OSTrace = 0;\n#define OSTRACE(X)          if( sqlite3OSTrace ) sqlite3DebugPrintf X\n#else\n#define OSTRACE(X)\n#endif\n\n/*\n** Macros for performance tracing.  Normally turned off.  Only works\n** on i486 hardware.\n*/\n#ifdef SQLITE_PERFORMANCE_TRACE\n\n/* \n** hwtime.h contains inline assembler code for implementing \n** high-performance timing routines.\n*/\n/************** Include hwtime.h in the middle of os_common.h ****************/\n/************** Begin file hwtime.h ******************************************/\n/*\n** 2008 May 27\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n******************************************************************************\n**\n** This file contains inline asm code for retrieving \"high-performance\"\n** counters for x86 class CPUs.\n*/\n#ifndef _HWTIME_H_\n#define _HWTIME_H_\n\n/*\n** The following routine only works on pentium-class (or newer) processors.\n** It uses the RDTSC opcode to read the cycle count value out of the\n** processor and returns that value.  This can be used for high-res\n** profiling.\n*/\n#if (defined(__GNUC__) || defined(_MSC_VER)) && \\\n      (defined(i386) || defined(__i386__) || defined(_M_IX86))\n\n  #if defined(__GNUC__)\n\n  __inline__ sqlite_uint64 sqlite3Hwtime(void){\n     unsigned int lo, hi;\n     __asm__ __volatile__ (\"rdtsc\" : \"=a\" (lo), \"=d\" (hi));\n     return (sqlite_uint64)hi << 32 | lo;\n  }\n\n  #elif defined(_MSC_VER)\n\n  __declspec(naked) __inline sqlite_uint64 __cdecl sqlite3Hwtime(void){\n     __asm {\n        rdtsc\n        ret       ; return value at EDX:EAX\n     }\n  }\n\n  #endif\n\n#elif (defined(__GNUC__) && defined(__x86_64__))\n\n  __inline__ sqlite_uint64 sqlite3Hwtime(void){\n      unsigned long val;\n      __asm__ __volatile__ (\"rdtsc\" : \"=A\" (val));\n      return val;\n  }\n \n#elif (defined(__GNUC__) && defined(__ppc__))\n\n  __inline__ sqlite_uint64 sqlite3Hwtime(void){\n      unsigned long long retval;\n      unsigned long junk;\n      __asm__ __volatile__ (\"\\n\\\n          1:      mftbu   %1\\n\\\n                  mftb    %L0\\n\\\n                  mftbu   %0\\n\\\n                  cmpw    %0,%1\\n\\\n                  bne     1b\"\n                  : \"=r\" (retval), \"=r\" (junk));\n      return retval;\n  }\n\n#else\n\n  #error Need implementation of sqlite3Hwtime() for your platform.\n\n  /*\n  ** To compile without implementing sqlite3Hwtime() for your platform,\n  ** you can remove the above #error and use the following\n  ** stub function.  You will lose timing support for many\n  ** of the debugging and testing utilities, but it should at\n  ** least compile and run.\n  */\nSQLITE_PRIVATE   sqlite_uint64 sqlite3Hwtime(void){ return ((sqlite_uint64)0); }\n\n#endif\n\n#endif /* !defined(_HWTIME_H_) */\n\n/************** End of hwtime.h **********************************************/\n/************** Continuing where we left off in os_common.h ******************/\n\nstatic sqlite_uint64 g_start;\nstatic sqlite_uint64 g_elapsed;\n#define TIMER_START       g_start=sqlite3Hwtime()\n#define TIMER_END         g_elapsed=sqlite3Hwtime()-g_start\n#define TIMER_ELAPSED     g_elapsed\n#else\n#define TIMER_START\n#define TIMER_END\n#define TIMER_ELAPSED     ((sqlite_uint64)0)\n#endif\n\n/*\n** If we compile with the SQLITE_TEST macro set, then the following block\n** of code will give us the ability to simulate a disk I/O error.  This\n** is used for testing the I/O recovery logic.\n*/\n#ifdef SQLITE_TEST\nSQLITE_API int sqlite3_io_error_hit = 0;            /* Total number of I/O Errors */\nSQLITE_API int sqlite3_io_error_hardhit = 0;        /* Number of non-benign errors */\nSQLITE_API int sqlite3_io_error_pending = 0;        /* Count down to first I/O error */\nSQLITE_API int sqlite3_io_error_persist = 0;        /* True if I/O errors persist */\nSQLITE_API int sqlite3_io_error_benign = 0;         /* True if errors are benign */\nSQLITE_API int sqlite3_diskfull_pending = 0;\nSQLITE_API int sqlite3_diskfull = 0;\n#define SimulateIOErrorBenign(X) sqlite3_io_error_benign=(X)\n#define SimulateIOError(CODE)  \\\n  if( (sqlite3_io_error_persist && sqlite3_io_error_hit) \\\n       || sqlite3_io_error_pending-- == 1 )  \\\n              { local_ioerr(); CODE; }\nstatic void local_ioerr(){\n  IOTRACE((\"IOERR\\n\"));\n  sqlite3_io_error_hit++;\n  if( !sqlite3_io_error_benign ) sqlite3_io_error_hardhit++;\n}\n#define SimulateDiskfullError(CODE) \\\n   if( sqlite3_diskfull_pending ){ \\\n     if( sqlite3_diskfull_pending == 1 ){ \\\n       local_ioerr(); \\\n       sqlite3_diskfull = 1; \\\n       sqlite3_io_error_hit = 1; \\\n       CODE; \\\n     }else{ \\\n       sqlite3_diskfull_pending--; \\\n     } \\\n   }\n#else\n#define SimulateIOErrorBenign(X)\n#define SimulateIOError(A)\n#define SimulateDiskfullError(A)\n#endif\n\n/*\n** When testing, keep a count of the number of open files.\n*/\n#ifdef SQLITE_TEST\nSQLITE_API int sqlite3_open_file_count = 0;\n#define OpenCounter(X)  sqlite3_open_file_count+=(X)\n#else\n#define OpenCounter(X)\n#endif\n\n#endif /* !defined(_OS_COMMON_H_) */\n\n/************** End of os_common.h *******************************************/\n/************** Continuing where we left off in os_unix.c ********************/\n\n/*\n** Define various macros that are missing from some systems.\n*/\n#ifndef O_LARGEFILE\n# define O_LARGEFILE 0\n#endif\n#ifdef SQLITE_DISABLE_LFS\n# undef O_LARGEFILE\n# define O_LARGEFILE 0\n#endif\n#ifndef O_NOFOLLOW\n# define O_NOFOLLOW 0\n#endif\n#ifndef O_BINARY\n# define O_BINARY 0\n#endif\n\n/*\n** The threadid macro resolves to the thread-id or to 0.  Used for\n** testing and debugging only.\n*/\n#if SQLITE_THREADSAFE\n#define threadid pthread_self()\n#else\n#define threadid 0\n#endif\n\n/*\n** Many system calls are accessed through pointer-to-functions so that\n** they may be overridden at runtime to facilitate fault injection during\n** testing and sandboxing.  The following array holds the names and pointers\n** to all overrideable system calls.\n*/\nstatic struct unix_syscall {\n  const char *zName;      /* Name of the sytem call */\n  void *pCurrent;         /* Current value of the system call */\n  void *pDefault;         /* Default value */\n} aSyscall[] = {\n  { \"open\",         (void*)open,       0  },\n#define osOpen      ((int(*)(const char*,int,int))aSyscall[0].pCurrent)\n\n  { \"close\",        (void*)close,      0  },\n#define osClose     ((int(*)(int))aSyscall[1].pCurrent)\n\n  { \"access\",       (void*)access,     0  },\n#define osAccess    ((int(*)(const char*,int))aSyscall[2].pCurrent)\n\n  { \"getcwd\",       (void*)getcwd,     0  },\n#define osGetcwd    ((char*(*)(char*,size_t))aSyscall[3].pCurrent)\n\n  { \"stat\",         (void*)stat,       0  },\n#define osStat      ((int(*)(const char*,struct stat*))aSyscall[4].pCurrent)\n\n/*\n** The DJGPP compiler environment looks mostly like Unix, but it\n** lacks the fcntl() system call.  So redefine fcntl() to be something\n** that always succeeds.  This means that locking does not occur under\n** DJGPP.  But it is DOS - what did you expect?\n*/\n#ifdef __DJGPP__\n  { \"fstat\",        0,                 0  },\n#define osFstat(a,b,c)    0\n#else     \n  { \"fstat\",        (void*)fstat,      0  },\n#define osFstat     ((int(*)(int,struct stat*))aSyscall[5].pCurrent)\n#endif\n\n  { \"ftruncate\",    (void*)ftruncate,  0  },\n#define osFtruncate ((int(*)(int,off_t))aSyscall[6].pCurrent)\n\n  { \"fcntl\",        (void*)fcntl,      0  },\n#define osFcntl     ((int(*)(int,int,...))aSyscall[7].pCurrent)\n\n  { \"read\",         (void*)read,       0  },\n#define osRead      ((ssize_t(*)(int,void*,size_t))aSyscall[8].pCurrent)\n\n#if defined(USE_PREAD) || defined(SQLITE_ENABLE_LOCKING_STYLE)\n  { \"pread\",        (void*)pread,      0  },\n#else\n  { \"pread\",        (void*)0,          0  },\n#endif\n#define osPread     ((ssize_t(*)(int,void*,size_t,off_t))aSyscall[9].pCurrent)\n\n#if defined(USE_PREAD64)\n  { \"pread64\",      (void*)pread64,    0  },\n#else\n  { \"pread64\",      (void*)0,          0  },\n#endif\n#define osPread64   ((ssize_t(*)(int,void*,size_t,off_t))aSyscall[10].pCurrent)\n\n  { \"write\",        (void*)write,      0  },\n#define osWrite     ((ssize_t(*)(int,const void*,size_t))aSyscall[11].pCurrent)\n\n#if defined(USE_PREAD) || defined(SQLITE_ENABLE_LOCKING_STYLE)\n  { \"pwrite\",       (void*)pwrite,     0  },\n#else\n  { \"pwrite\",       (void*)0,          0  },\n#endif\n#define osPwrite    ((ssize_t(*)(int,const void*,size_t,off_t))\\\n                    aSyscall[12].pCurrent)\n\n#if defined(USE_PREAD64)\n  { \"pwrite64\",     (void*)pwrite64,   0  },\n#else\n  { \"pwrite64\",     (void*)0,          0  },\n#endif\n#define osPwrite64  ((ssize_t(*)(int,const void*,size_t,off_t))\\\n                    aSyscall[13].pCurrent)\n\n  { \"fchmod\",       (void*)fchmod,     0  },\n#define osFchmod    ((int(*)(int,mode_t))aSyscall[14].pCurrent)\n\n#if defined(HAVE_POSIX_FALLOCATE) && HAVE_POSIX_FALLOCATE\n  { \"fallocate\",    (void*)posix_fallocate,  0 },\n#else\n  { \"fallocate\",    (void*)0,                0 },\n#endif\n#define osFallocate ((int(*)(int,off_t,off_t)aSyscall[15].pCurrent)\n\n}; /* End of the overrideable system calls */\n\n/*\n** This is the xSetSystemCall() method of sqlite3_vfs for all of the\n** \"unix\" VFSes.  Return SQLITE_OK opon successfully updating the\n** system call pointer, or SQLITE_NOTFOUND if there is no configurable\n** system call named zName.\n*/\nstatic int unixSetSystemCall(\n  sqlite3_vfs *pNotUsed,     /* The VFS pointer.  Not used */\n  const char *zName,         /* Name of system call to override */\n  void *pNewFunc             /* Pointer to new system call value */\n){\n  int i;\n  int rc = SQLITE_NOTFOUND;\n  if( zName==0 ){\n    /* If no zName is given, restore all system calls to their default\n    ** settings and return NULL\n    */\n    for(i=0; i<sizeof(aSyscall)/sizeof(aSyscall[0]); i++){\n      if( aSyscall[i].pDefault ){\n        aSyscall[i].pCurrent = aSyscall[i].pDefault;\n        rc = SQLITE_OK;\n      }\n    }\n  }else{\n    /* If zName is specified, operate on only the one system call\n    ** specified.\n    */\n    for(i=0; i<sizeof(aSyscall)/sizeof(aSyscall[0]); i++){\n      if( strcmp(zName, aSyscall[i].zName)==0 ){\n        if( aSyscall[i].pDefault==0 ){\n          aSyscall[i].pDefault = aSyscall[i].pCurrent;\n        }\n        rc = SQLITE_OK;\n        if( pNewFunc==0 ) pNewFunc = aSyscall[i].pDefault;\n        aSyscall[i].pCurrent = pNewFunc;\n        break;\n      }\n    }\n  }\n  return rc;\n}\n\n/*\n** Return the value of a system call.  Return NULL if zName is not a\n** recognized system call name.  NULL is also returned if the system call\n** is currently undefined.\n*/\nstatic void *unixGetSystemCall(sqlite3_vfs *pNotUsed, const char *zName){\n  int i;\n  for(i=0; i<sizeof(aSyscall)/sizeof(aSyscall[0]); i++){\n    if( strcmp(zName, aSyscall[i].zName)==0 ) return aSyscall[i].pCurrent;\n  }\n  return 0;\n}\n\n/*\n** Return the name of the first system call after zName.  If zName==NULL\n** then return the name of the first system call.  Return NULL if zName\n** is the last system call or if zName is not the name of a valid\n** system call.\n*/\nstatic const char *unixNextSystemCall(sqlite3_vfs *p, const char *zName){\n  int i;\n  if( zName==0 ){\n    i = -1;\n  }else{\n    for(i=0; i<sizeof(aSyscall)/sizeof(aSyscall[0])-1; i++){\n      if( strcmp(zName, aSyscall[0].zName)==0 ) break;\n    }\n  }\n  for(i++; i<sizeof(aSyscall)/sizeof(aSyscall[0]); i++){\n    if( aSyscall[0].pCurrent!=0 ) return aSyscall[0].zName;\n  }\n  return 0;\n}\n\n/*\n** Retry open() calls that fail due to EINTR\n*/\nstatic int robust_open(const char *z, int f, int m){\n  int rc;\n  do{ rc = osOpen(z,f,m); }while( rc<0 && errno==EINTR );\n  return rc;\n}\n\n/*\n** Helper functions to obtain and relinquish the global mutex. The\n** global mutex is used to protect the unixInodeInfo and\n** vxworksFileId objects used by this file, all of which may be \n** shared by multiple threads.\n**\n** Function unixMutexHeld() is used to assert() that the global mutex \n** is held when required. This function is only used as part of assert() \n** statements. e.g.\n**\n**   unixEnterMutex()\n**     assert( unixMutexHeld() );\n**   unixEnterLeave()\n*/\nstatic void unixEnterMutex(void){\n  sqlite3_mutex_enter(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER));\n}\nstatic void unixLeaveMutex(void){\n  sqlite3_mutex_leave(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER));\n}\n#ifdef SQLITE_DEBUG\nstatic int unixMutexHeld(void) {\n  return sqlite3_mutex_held(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER));\n}\n#endif\n\n\n#ifdef SQLITE_DEBUG\n/*\n** Helper function for printing out trace information from debugging\n** binaries. This returns the string represetation of the supplied\n** integer lock-type.\n*/\nstatic const char *azFileLock(int eFileLock){\n  switch( eFileLock ){\n    case NO_LOCK: return \"NONE\";\n    case SHARED_LOCK: return \"SHARED\";\n    case RESERVED_LOCK: return \"RESERVED\";\n    case PENDING_LOCK: return \"PENDING\";\n    case EXCLUSIVE_LOCK: return \"EXCLUSIVE\";\n  }\n  return \"ERROR\";\n}\n#endif\n\n#ifdef SQLITE_LOCK_TRACE\n/*\n** Print out information about all locking operations.\n**\n** This routine is used for troubleshooting locks on multithreaded\n** platforms.  Enable by compiling with the -DSQLITE_LOCK_TRACE\n** command-line option on the compiler.  This code is normally\n** turned off.\n*/\nstatic int lockTrace(int fd, int op, struct flock *p){\n  char *zOpName, *zType;\n  int s;\n  int savedErrno;\n  if( op==F_GETLK ){\n    zOpName = \"GETLK\";\n  }else if( op==F_SETLK ){\n    zOpName = \"SETLK\";\n  }else{\n    s = osFcntl(fd, op, p);\n    sqlite3DebugPrintf(\"fcntl unknown %d %d %d\\n\", fd, op, s);\n    return s;\n  }\n  if( p->l_type==F_RDLCK ){\n    zType = \"RDLCK\";\n  }else if( p->l_type==F_WRLCK ){\n    zType = \"WRLCK\";\n  }else if( p->l_type==F_UNLCK ){\n    zType = \"UNLCK\";\n  }else{\n    assert( 0 );\n  }\n  assert( p->l_whence==SEEK_SET );\n  s = osFcntl(fd, op, p);\n  savedErrno = errno;\n  sqlite3DebugPrintf(\"fcntl %d %d %s %s %d %d %d %d\\n\",\n     threadid, fd, zOpName, zType, (int)p->l_start, (int)p->l_len,\n     (int)p->l_pid, s);\n  if( s==(-1) && op==F_SETLK && (p->l_type==F_RDLCK || p->l_type==F_WRLCK) ){\n    struct flock l2;\n    l2 = *p;\n    osFcntl(fd, F_GETLK, &l2);\n    if( l2.l_type==F_RDLCK ){\n      zType = \"RDLCK\";\n    }else if( l2.l_type==F_WRLCK ){\n      zType = \"WRLCK\";\n    }else if( l2.l_type==F_UNLCK ){\n      zType = \"UNLCK\";\n    }else{\n      assert( 0 );\n    }\n    sqlite3DebugPrintf(\"fcntl-failure-reason: %s %d %d %d\\n\",\n       zType, (int)l2.l_start, (int)l2.l_len, (int)l2.l_pid);\n  }\n  errno = savedErrno;\n  return s;\n}\n#undef osFcntl\n#define osFcntl lockTrace\n#endif /* SQLITE_LOCK_TRACE */\n\n/*\n** Retry ftruncate() calls that fail due to EINTR\n*/\nstatic int robust_ftruncate(int h, sqlite3_int64 sz){\n  int rc;\n  do{ rc = osFtruncate(h,sz); }while( rc<0 && errno==EINTR );\n  return rc;\n}\n\n/*\n** This routine translates a standard POSIX errno code into something\n** useful to the clients of the sqlite3 functions.  Specifically, it is\n** intended to translate a variety of \"try again\" errors into SQLITE_BUSY\n** and a variety of \"please close the file descriptor NOW\" errors into \n** SQLITE_IOERR\n** \n** Errors during initialization of locks, or file system support for locks,\n** should handle ENOLCK, ENOTSUP, EOPNOTSUPP separately.\n*/\nstatic int sqliteErrorFromPosixError(int posixError, int sqliteIOErr) {\n  switch (posixError) {\n  case 0: \n    return SQLITE_OK;\n    \n  case EAGAIN:\n  case ETIMEDOUT:\n  case EBUSY:\n  case EINTR:\n  case ENOLCK:  \n    /* random NFS retry error, unless during file system support \n     * introspection, in which it actually means what it says */\n    return SQLITE_BUSY;\n    \n  case EACCES: \n    /* EACCES is like EAGAIN during locking operations, but not any other time*/\n    if( (sqliteIOErr == SQLITE_IOERR_LOCK) || \n    (sqliteIOErr == SQLITE_IOERR_UNLOCK) || \n    (sqliteIOErr == SQLITE_IOERR_RDLOCK) ||\n    (sqliteIOErr == SQLITE_IOERR_CHECKRESERVEDLOCK) ){\n      return SQLITE_BUSY;\n    }\n    /* else fall through */\n  case EPERM: \n    return SQLITE_PERM;\n    \n  case EDEADLK:\n    return SQLITE_IOERR_BLOCKED;\n    \n#if EOPNOTSUPP!=ENOTSUP\n  case EOPNOTSUPP: \n    /* something went terribly awry, unless during file system support \n     * introspection, in which it actually means what it says */\n#endif\n#ifdef ENOTSUP\n  case ENOTSUP: \n    /* invalid fd, unless during file system support introspection, in which \n     * it actually means what it says */\n#endif\n  case EIO:\n  case EBADF:\n  case EINVAL:\n  case ENOTCONN:\n  case ENODEV:\n  case ENXIO:\n  case ENOENT:\n  case ESTALE:\n  case ENOSYS:\n    /* these should force the client to close the file and reconnect */\n    \n  default: \n    return sqliteIOErr;\n  }\n}\n\n\n\n/******************************************************************************\n****************** Begin Unique File ID Utility Used By VxWorks ***************\n**\n** On most versions of unix, we can get a unique ID for a file by concatenating\n** the device number and the inode number.  But this does not work on VxWorks.\n** On VxWorks, a unique file id must be based on the canonical filename.\n**\n** A pointer to an instance of the following structure can be used as a\n** unique file ID in VxWorks.  Each instance of this structure contains\n** a copy of the canonical filename.  There is also a reference count.  \n** The structure is reclaimed when the number of pointers to it drops to\n** zero.\n**\n** There are never very many files open at one time and lookups are not\n** a performance-critical path, so it is sufficient to put these\n** structures on a linked list.\n*/\nstruct vxworksFileId {\n  struct vxworksFileId *pNext;  /* Next in a list of them all */\n  int nRef;                     /* Number of references to this one */\n  int nName;                    /* Length of the zCanonicalName[] string */\n  char *zCanonicalName;         /* Canonical filename */\n};\n\n#if OS_VXWORKS\n/* \n** All unique filenames are held on a linked list headed by this\n** variable:\n*/\nstatic struct vxworksFileId *vxworksFileList = 0;\n\n/*\n** Simplify a filename into its canonical form\n** by making the following changes:\n**\n**  * removing any trailing and duplicate /\n**  * convert /./ into just /\n**  * convert /A/../ where A is any simple name into just /\n**\n** Changes are made in-place.  Return the new name length.\n**\n** The original filename is in z[0..n-1].  Return the number of\n** characters in the simplified name.\n*/\nstatic int vxworksSimplifyName(char *z, int n){\n  int i, j;\n  while( n>1 && z[n-1]=='/' ){ n--; }\n  for(i=j=0; i<n; i++){\n    if( z[i]=='/' ){\n      if( z[i+1]=='/' ) continue;\n      if( z[i+1]=='.' && i+2<n && z[i+2]=='/' ){\n        i += 1;\n        continue;\n      }\n      if( z[i+1]=='.' && i+3<n && z[i+2]=='.' && z[i+3]=='/' ){\n        while( j>0 && z[j-1]!='/' ){ j--; }\n        if( j>0 ){ j--; }\n        i += 2;\n        continue;\n      }\n    }\n    z[j++] = z[i];\n  }\n  z[j] = 0;\n  return j;\n}\n\n/*\n** Find a unique file ID for the given absolute pathname.  Return\n** a pointer to the vxworksFileId object.  This pointer is the unique\n** file ID.\n**\n** The nRef field of the vxworksFileId object is incremented before\n** the object is returned.  A new vxworksFileId object is created\n** and added to the global list if necessary.\n**\n** If a memory allocation error occurs, return NULL.\n*/\nstatic struct vxworksFileId *vxworksFindFileId(const char *zAbsoluteName){\n  struct vxworksFileId *pNew;         /* search key and new file ID */\n  struct vxworksFileId *pCandidate;   /* For looping over existing file IDs */\n  int n;                              /* Length of zAbsoluteName string */\n\n  assert( zAbsoluteName[0]=='/' );\n  n = (int)strlen(zAbsoluteName);\n  pNew = sqlite3_malloc( sizeof(*pNew) + (n+1) );\n  if( pNew==0 ) return 0;\n  pNew->zCanonicalName = (char*)&pNew[1];\n  memcpy(pNew->zCanonicalName, zAbsoluteName, n+1);\n  n = vxworksSimplifyName(pNew->zCanonicalName, n);\n\n  /* Search for an existing entry that matching the canonical name.\n  ** If found, increment the reference count and return a pointer to\n  ** the existing file ID.\n  */\n  unixEnterMutex();\n  for(pCandidate=vxworksFileList; pCandidate; pCandidate=pCandidate->pNext){\n    if( pCandidate->nName==n \n     && memcmp(pCandidate->zCanonicalName, pNew->zCanonicalName, n)==0\n    ){\n       sqlite3_free(pNew);\n       pCandidate->nRef++;\n       unixLeaveMutex();\n       return pCandidate;\n    }\n  }\n\n  /* No match was found.  We will make a new file ID */\n  pNew->nRef = 1;\n  pNew->nName = n;\n  pNew->pNext = vxworksFileList;\n  vxworksFileList = pNew;\n  unixLeaveMutex();\n  return pNew;\n}\n\n/*\n** Decrement the reference count on a vxworksFileId object.  Free\n** the object when the reference count reaches zero.\n*/\nstatic void vxworksReleaseFileId(struct vxworksFileId *pId){\n  unixEnterMutex();\n  assert( pId->nRef>0 );\n  pId->nRef--;\n  if( pId->nRef==0 ){\n    struct vxworksFileId **pp;\n    for(pp=&vxworksFileList; *pp && *pp!=pId; pp = &((*pp)->pNext)){}\n    assert( *pp==pId );\n    *pp = pId->pNext;\n    sqlite3_free(pId);\n  }\n  unixLeaveMutex();\n}\n#endif /* OS_VXWORKS */\n/*************** End of Unique File ID Utility Used By VxWorks ****************\n******************************************************************************/\n\n\n/******************************************************************************\n*************************** Posix Advisory Locking ****************************\n**\n** POSIX advisory locks are broken by design.  ANSI STD 1003.1 (1996)\n** section 6.5.2.2 lines 483 through 490 specify that when a process\n** sets or clears a lock, that operation overrides any prior locks set\n** by the same process.  It does not explicitly say so, but this implies\n** that it overrides locks set by the same process using a different\n** file descriptor.  Consider this test case:\n**\n**       int fd1 = open(\"./file1\", O_RDWR|O_CREAT, 0644);\n**       int fd2 = open(\"./file2\", O_RDWR|O_CREAT, 0644);\n**\n** Suppose ./file1 and ./file2 are really the same file (because\n** one is a hard or symbolic link to the other) then if you set\n** an exclusive lock on fd1, then try to get an exclusive lock\n** on fd2, it works.  I would have expected the second lock to\n** fail since there was already a lock on the file due to fd1.\n** But not so.  Since both locks came from the same process, the\n** second overrides the first, even though they were on different\n** file descriptors opened on different file names.\n**\n** This means that we cannot use POSIX locks to synchronize file access\n** among competing threads of the same process.  POSIX locks will work fine\n** to synchronize access for threads in separate processes, but not\n** threads within the same process.\n**\n** To work around the problem, SQLite has to manage file locks internally\n** on its own.  Whenever a new database is opened, we have to find the\n** specific inode of the database file (the inode is determined by the\n** st_dev and st_ino fields of the stat structure that fstat() fills in)\n** and check for locks already existing on that inode.  When locks are\n** created or removed, we have to look at our own internal record of the\n** locks to see if another thread has previously set a lock on that same\n** inode.\n**\n** (Aside: The use of inode numbers as unique IDs does not work on VxWorks.\n** For VxWorks, we have to use the alternative unique ID system based on\n** canonical filename and implemented in the previous division.)\n**\n** The sqlite3_file structure for POSIX is no longer just an integer file\n** descriptor.  It is now a structure that holds the integer file\n** descriptor and a pointer to a structure that describes the internal\n** locks on the corresponding inode.  There is one locking structure\n** per inode, so if the same inode is opened twice, both unixFile structures\n** point to the same locking structure.  The locking structure keeps\n** a reference count (so we will know when to delete it) and a \"cnt\"\n** field that tells us its internal lock status.  cnt==0 means the\n** file is unlocked.  cnt==-1 means the file has an exclusive lock.\n** cnt>0 means there are cnt shared locks on the file.\n**\n** Any attempt to lock or unlock a file first checks the locking\n** structure.  The fcntl() system call is only invoked to set a \n** POSIX lock if the internal lock structure transitions between\n** a locked and an unlocked state.\n**\n** But wait:  there are yet more problems with POSIX advisory locks.\n**\n** If you close a file descriptor that points to a file that has locks,\n** all locks on that file that are owned by the current process are\n** released.  To work around this problem, each unixInodeInfo object\n** maintains a count of the number of pending locks on tha inode.\n** When an attempt is made to close an unixFile, if there are\n** other unixFile open on the same inode that are holding locks, the call\n** to close() the file descriptor is deferred until all of the locks clear.\n** The unixInodeInfo structure keeps a list of file descriptors that need to\n** be closed and that list is walked (and cleared) when the last lock\n** clears.\n**\n** Yet another problem:  LinuxThreads do not play well with posix locks.\n**\n** Many older versions of linux use the LinuxThreads library which is\n** not posix compliant.  Under LinuxThreads, a lock created by thread\n** A cannot be modified or overridden by a different thread B.\n** Only thread A can modify the lock.  Locking behavior is correct\n** if the appliation uses the newer Native Posix Thread Library (NPTL)\n** on linux - with NPTL a lock created by thread A can override locks\n** in thread B.  But there is no way to know at compile-time which\n** threading library is being used.  So there is no way to know at\n** compile-time whether or not thread A can override locks on thread B.\n** One has to do a run-time check to discover the behavior of the\n** current process.\n**\n** SQLite used to support LinuxThreads.  But support for LinuxThreads\n** was dropped beginning with version 3.7.0.  SQLite will still work with\n** LinuxThreads provided that (1) there is no more than one connection \n** per database file in the same process and (2) database connections\n** do not move across threads.\n*/\n\n/*\n** An instance of the following structure serves as the key used\n** to locate a particular unixInodeInfo object.\n*/\nstruct unixFileId {\n  dev_t dev;                  /* Device number */\n#if OS_VXWORKS\n  struct vxworksFileId *pId;  /* Unique file ID for vxworks. */\n#else\n  ino_t ino;                  /* Inode number */\n#endif\n};\n\n/*\n** An instance of the following structure is allocated for each open\n** inode.  Or, on LinuxThreads, there is one of these structures for\n** each inode opened by each thread.\n**\n** A single inode can have multiple file descriptors, so each unixFile\n** structure contains a pointer to an instance of this object and this\n** object keeps a count of the number of unixFile pointing to it.\n*/\nstruct unixInodeInfo {\n  struct unixFileId fileId;       /* The lookup key */\n  int nShared;                    /* Number of SHARED locks held */\n  unsigned char eFileLock;        /* One of SHARED_LOCK, RESERVED_LOCK etc. */\n  unsigned char bProcessLock;     /* An exclusive process lock is held */\n  int nRef;                       /* Number of pointers to this structure */\n  unixShmNode *pShmNode;          /* Shared memory associated with this inode */\n  int nLock;                      /* Number of outstanding file locks */\n  UnixUnusedFd *pUnused;          /* Unused file descriptors to close */\n  unixInodeInfo *pNext;           /* List of all unixInodeInfo objects */\n  unixInodeInfo *pPrev;           /*    .... doubly linked */\n#if defined(SQLITE_ENABLE_LOCKING_STYLE)\n  unsigned long long sharedByte;  /* for AFP simulated shared lock */\n#endif\n#if OS_VXWORKS\n  sem_t *pSem;                    /* Named POSIX semaphore */\n  char aSemName[MAX_PATHNAME+2];  /* Name of that semaphore */\n#endif\n};\n\n/*\n** A lists of all unixInodeInfo objects.\n*/\nstatic unixInodeInfo *inodeList = 0;\n\n/*\n**\n** This function - unixLogError_x(), is only ever called via the macro\n** unixLogError().\n**\n** It is invoked after an error occurs in an OS function and errno has been\n** set. It logs a message using sqlite3_log() containing the current value of\n** errno and, if possible, the human-readable equivalent from strerror() or\n** strerror_r().\n**\n** The first argument passed to the macro should be the error code that\n** will be returned to SQLite (e.g. SQLITE_IOERR_DELETE, SQLITE_CANTOPEN). \n** The two subsequent arguments should be the name of the OS function that\n** failed (e.g. \"unlink\", \"open\") and the the associated file-system path,\n** if any.\n*/\n#define unixLogError(a,b,c)     unixLogErrorAtLine(a,b,c,__LINE__)\nstatic int unixLogErrorAtLine(\n  int errcode,                    /* SQLite error code */\n  const char *zFunc,              /* Name of OS function that failed */\n  const char *zPath,              /* File path associated with error */\n  int iLine                       /* Source line number where error occurred */\n){\n  char *zErr;                     /* Message from strerror() or equivalent */\n  int iErrno = errno;             /* Saved syscall error number */\n\n  /* If this is not a threadsafe build (SQLITE_THREADSAFE==0), then use\n  ** the strerror() function to obtain the human-readable error message\n  ** equivalent to errno. Otherwise, use strerror_r().\n  */ \n#if SQLITE_THREADSAFE && defined(HAVE_STRERROR_R)\n  char aErr[80];\n  memset(aErr, 0, sizeof(aErr));\n  zErr = aErr;\n\n  /* If STRERROR_R_CHAR_P (set by autoconf scripts) or __USE_GNU is defined,\n  ** assume that the system provides the the GNU version of strerror_r() that \n  ** returns a pointer to a buffer containing the error message. That pointer \n  ** may point to aErr[], or it may point to some static storage somewhere. \n  ** Otherwise, assume that the system provides the POSIX version of \n  ** strerror_r(), which always writes an error message into aErr[].\n  **\n  ** If the code incorrectly assumes that it is the POSIX version that is\n  ** available, the error message will often be an empty string. Not a\n  ** huge problem. Incorrectly concluding that the GNU version is available \n  ** could lead to a segfault though.\n  */\n#if defined(STRERROR_R_CHAR_P) || defined(__USE_GNU)\n  zErr = \n# endif\n  strerror_r(iErrno, aErr, sizeof(aErr)-1);\n\n#elif SQLITE_THREADSAFE\n  /* This is a threadsafe build, but strerror_r() is not available. */\n  zErr = \"\";\n#else\n  /* Non-threadsafe build, use strerror(). */\n  zErr = strerror(iErrno);\n#endif\n\n  assert( errcode!=SQLITE_OK );\n  if( zPath==0 ) zPath = \"\";\n  sqlite3_log(errcode,\n      \"os_unix.c:%d: (%d) %s(%s) - %s\",\n      iLine, iErrno, zFunc, zPath, zErr\n  );\n\n  return errcode;\n}\n\n/*\n** Close a file descriptor.\n**\n** We assume that close() almost always works, since it is only in a\n** very sick application or on a very sick platform that it might fail.\n** If it does fail, simply leak the file descriptor, but do log the\n** error.\n**\n** Note that it is not safe to retry close() after EINTR since the\n** file descriptor might have already been reused by another thread.\n** So we don't even try to recover from an EINTR.  Just log the error\n** and move on.\n*/\nstatic void robust_close(unixFile *pFile, int h, int lineno){\n  if( osClose(h) ){\n    unixLogErrorAtLine(SQLITE_IOERR_CLOSE, \"close\",\n                       pFile ? pFile->zPath : 0, lineno);\n  }\n}\n\n/*\n** Close all file descriptors accumuated in the unixInodeInfo->pUnused list.\n*/ \nstatic void closePendingFds(unixFile *pFile){\n  unixInodeInfo *pInode = pFile->pInode;\n  UnixUnusedFd *p;\n  UnixUnusedFd *pNext;\n  for(p=pInode->pUnused; p; p=pNext){\n    pNext = p->pNext;\n    robust_close(pFile, p->fd, __LINE__);\n    sqlite3_free(p);\n  }\n  pInode->pUnused = 0;\n}\n\n/*\n** Release a unixInodeInfo structure previously allocated by findInodeInfo().\n**\n** The mutex entered using the unixEnterMutex() function must be held\n** when this function is called.\n*/\nstatic void releaseInodeInfo(unixFile *pFile){\n  unixInodeInfo *pInode = pFile->pInode;\n  assert( unixMutexHeld() );\n  if( pInode ){\n    pInode->nRef--;\n    if( pInode->nRef==0 ){\n      assert( pInode->pShmNode==0 );\n      closePendingFds(pFile);\n      if( pInode->pPrev ){\n        assert( pInode->pPrev->pNext==pInode );\n        pInode->pPrev->pNext = pInode->pNext;\n      }else{\n        assert( inodeList==pInode );\n        inodeList = pInode->pNext;\n      }\n      if( pInode->pNext ){\n        assert( pInode->pNext->pPrev==pInode );\n        pInode->pNext->pPrev = pInode->pPrev;\n      }\n      sqlite3_free(pInode);\n    }\n  }\n}\n\n/*\n** Given a file descriptor, locate the unixInodeInfo object that\n** describes that file descriptor.  Create a new one if necessary.  The\n** return value might be uninitialized if an error occurs.\n**\n** The mutex entered using the unixEnterMutex() function must be held\n** when this function is called.\n**\n** Return an appropriate error code.\n*/\nstatic int findInodeInfo(\n  unixFile *pFile,               /* Unix file with file desc used in the key */\n  unixInodeInfo **ppInode        /* Return the unixInodeInfo object here */\n){\n  int rc;                        /* System call return code */\n  int fd;                        /* The file descriptor for pFile */\n  struct unixFileId fileId;      /* Lookup key for the unixInodeInfo */\n  struct stat statbuf;           /* Low-level file information */\n  unixInodeInfo *pInode = 0;     /* Candidate unixInodeInfo object */\n\n  assert( unixMutexHeld() );\n\n  /* Get low-level information about the file that we can used to\n  ** create a unique name for the file.\n  */\n  fd = pFile->h;\n  rc = osFstat(fd, &statbuf);\n  if( rc!=0 ){\n    pFile->lastErrno = errno;\n#ifdef EOVERFLOW\n    if( pFile->lastErrno==EOVERFLOW ) return SQLITE_NOLFS;\n#endif\n    return SQLITE_IOERR;\n  }\n\n#ifdef __APPLE__\n  /* On OS X on an msdos filesystem, the inode number is reported\n  ** incorrectly for zero-size files.  See ticket #3260.  To work\n  ** around this problem (we consider it a bug in OS X, not SQLite)\n  ** we always increase the file size to 1 by writing a single byte\n  ** prior to accessing the inode number.  The one byte written is\n  ** an ASCII 'S' character which also happens to be the first byte\n  ** in the header of every SQLite database.  In this way, if there\n  ** is a race condition such that another thread has already populated\n  ** the first page of the database, no damage is done.\n  */\n  if( statbuf.st_size==0 && (pFile->fsFlags & SQLITE_FSFLAGS_IS_MSDOS)!=0 ){\n    do{ rc = osWrite(fd, \"S\", 1); }while( rc<0 && errno==EINTR );\n    if( rc!=1 ){\n      pFile->lastErrno = errno;\n      return SQLITE_IOERR;\n    }\n    rc = osFstat(fd, &statbuf);\n    if( rc!=0 ){\n      pFile->lastErrno = errno;\n      return SQLITE_IOERR;\n    }\n  }\n#endif\n\n  memset(&fileId, 0, sizeof(fileId));\n  fileId.dev = statbuf.st_dev;\n#if OS_VXWORKS\n  fileId.pId = pFile->pId;\n#else\n  fileId.ino = statbuf.st_ino;\n#endif\n  pInode = inodeList;\n  while( pInode && memcmp(&fileId, &pInode->fileId, sizeof(fileId)) ){\n    pInode = pInode->pNext;\n  }\n  if( pInode==0 ){\n    pInode = sqlite3_malloc( sizeof(*pInode) );\n    if( pInode==0 ){\n      return SQLITE_NOMEM;\n    }\n    memset(pInode, 0, sizeof(*pInode));\n    memcpy(&pInode->fileId, &fileId, sizeof(fileId));\n    pInode->nRef = 1;\n    pInode->pNext = inodeList;\n    pInode->pPrev = 0;\n    if( inodeList ) inodeList->pPrev = pInode;\n    inodeList = pInode;\n  }else{\n    pInode->nRef++;\n  }\n  *ppInode = pInode;\n  return SQLITE_OK;\n}\n\n\n/*\n** This routine checks if there is a RESERVED lock held on the specified\n** file by this or any other process. If such a lock is held, set *pResOut\n** to a non-zero value otherwise *pResOut is set to zero.  The return value\n** is set to SQLITE_OK unless an I/O error occurs during lock checking.\n*/\nstatic int unixCheckReservedLock(sqlite3_file *id, int *pResOut){\n  int rc = SQLITE_OK;\n  int reserved = 0;\n  unixFile *pFile = (unixFile*)id;\n\n  SimulateIOError( return SQLITE_IOERR_CHECKRESERVEDLOCK; );\n\n  assert( pFile );\n  unixEnterMutex(); /* Because pFile->pInode is shared across threads */\n\n  /* Check if a thread in this process holds such a lock */\n  if( pFile->pInode->eFileLock>SHARED_LOCK ){\n    reserved = 1;\n  }\n\n  /* Otherwise see if some other process holds it.\n  */\n#ifndef __DJGPP__\n  if( !reserved && !pFile->pInode->bProcessLock ){\n    struct flock lock;\n    lock.l_whence = SEEK_SET;\n    lock.l_start = RESERVED_BYTE;\n    lock.l_len = 1;\n    lock.l_type = F_WRLCK;\n    if (-1 == osFcntl(pFile->h, F_GETLK, &lock)) {\n      int tErrno = errno;\n      rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_CHECKRESERVEDLOCK);\n      pFile->lastErrno = tErrno;\n    } else if( lock.l_type!=F_UNLCK ){\n      reserved = 1;\n    }\n  }\n#endif\n  \n  unixLeaveMutex();\n  OSTRACE((\"TEST WR-LOCK %d %d %d (unix)\\n\", pFile->h, rc, reserved));\n\n  *pResOut = reserved;\n  return rc;\n}\n\n/*\n** Attempt to set a system-lock on the file pFile.  The lock is \n** described by pLock.\n**\n** If the pFile was opened read/write from unix-excl, then the only lock\n** ever obtained is an exclusive lock, and it is obtained exactly once\n** the first time any lock is attempted.  All subsequent system locking\n** operations become no-ops.  Locking operations still happen internally,\n** in order to coordinate access between separate database connections\n** within this process, but all of that is handled in memory and the\n** operating system does not participate.\n**\n** This function is a pass-through to fcntl(F_SETLK) if pFile is using\n** any VFS other than \"unix-excl\" or if pFile is opened on \"unix-excl\"\n** and is read-only.\n*/\nstatic int unixFileLock(unixFile *pFile, struct flock *pLock){\n  int rc;\n  unixInodeInfo *pInode = pFile->pInode;\n  assert( unixMutexHeld() );\n  assert( pInode!=0 );\n  if( ((pFile->ctrlFlags & UNIXFILE_EXCL)!=0 || pInode->bProcessLock)\n   && ((pFile->ctrlFlags & UNIXFILE_RDONLY)==0)\n  ){\n    if( pInode->bProcessLock==0 ){\n      struct flock lock;\n      assert( pInode->nLock==0 );\n      lock.l_whence = SEEK_SET;\n      lock.l_start = SHARED_FIRST;\n      lock.l_len = SHARED_SIZE;\n      lock.l_type = F_WRLCK;\n      rc = osFcntl(pFile->h, F_SETLK, &lock);\n      if( rc<0 ) return rc;\n      pInode->bProcessLock = 1;\n      pInode->nLock++;\n    }else{\n      rc = 0;\n    }\n  }else{\n    rc = osFcntl(pFile->h, F_SETLK, pLock);\n  }\n  return rc;\n}\n\n/*\n** Lock the file with the lock specified by parameter eFileLock - one\n** of the following:\n**\n**     (1) SHARED_LOCK\n**     (2) RESERVED_LOCK\n**     (3) PENDING_LOCK\n**     (4) EXCLUSIVE_LOCK\n**\n** Sometimes when requesting one lock state, additional lock states\n** are inserted in between.  The locking might fail on one of the later\n** transitions leaving the lock state different from what it started but\n** still short of its goal.  The following chart shows the allowed\n** transitions and the inserted intermediate states:\n**\n**    UNLOCKED -> SHARED\n**    SHARED -> RESERVED\n**    SHARED -> (PENDING) -> EXCLUSIVE\n**    RESERVED -> (PENDING) -> EXCLUSIVE\n**    PENDING -> EXCLUSIVE\n**\n** This routine will only increase a lock.  Use the sqlite3OsUnlock()\n** routine to lower a locking level.\n*/\nstatic int unixLock(sqlite3_file *id, int eFileLock){\n  /* The following describes the implementation of the various locks and\n  ** lock transitions in terms of the POSIX advisory shared and exclusive\n  ** lock primitives (called read-locks and write-locks below, to avoid\n  ** confusion with SQLite lock names). The algorithms are complicated\n  ** slightly in order to be compatible with windows systems simultaneously\n  ** accessing the same database file, in case that is ever required.\n  **\n  ** Symbols defined in os.h indentify the 'pending byte' and the 'reserved\n  ** byte', each single bytes at well known offsets, and the 'shared byte\n  ** range', a range of 510 bytes at a well known offset.\n  **\n  ** To obtain a SHARED lock, a read-lock is obtained on the 'pending\n  ** byte'.  If this is successful, a random byte from the 'shared byte\n  ** range' is read-locked and the lock on the 'pending byte' released.\n  **\n  ** A process may only obtain a RESERVED lock after it has a SHARED lock.\n  ** A RESERVED lock is implemented by grabbing a write-lock on the\n  ** 'reserved byte'. \n  **\n  ** A process may only obtain a PENDING lock after it has obtained a\n  ** SHARED lock. A PENDING lock is implemented by obtaining a write-lock\n  ** on the 'pending byte'. This ensures that no new SHARED locks can be\n  ** obtained, but existing SHARED locks are allowed to persist. A process\n  ** does not have to obtain a RESERVED lock on the way to a PENDING lock.\n  ** This property is used by the algorithm for rolling back a journal file\n  ** after a crash.\n  **\n  ** An EXCLUSIVE lock, obtained after a PENDING lock is held, is\n  ** implemented by obtaining a write-lock on the entire 'shared byte\n  ** range'. Since all other locks require a read-lock on one of the bytes\n  ** within this range, this ensures that no other locks are held on the\n  ** database. \n  **\n  ** The reason a single byte cannot be used instead of the 'shared byte\n  ** range' is that some versions of windows do not support read-locks. By\n  ** locking a random byte from a range, concurrent SHARED locks may exist\n  ** even if the locking primitive used is always a write-lock.\n  */\n  int rc = SQLITE_OK;\n  unixFile *pFile = (unixFile*)id;\n  unixInodeInfo *pInode = pFile->pInode;\n  struct flock lock;\n  int s = 0;\n  int tErrno = 0;\n\n  assert( pFile );\n  OSTRACE((\"LOCK    %d %s was %s(%s,%d) pid=%d (unix)\\n\", pFile->h,\n      azFileLock(eFileLock), azFileLock(pFile->eFileLock),\n      azFileLock(pInode->eFileLock), pInode->nShared , getpid()));\n\n  /* If there is already a lock of this type or more restrictive on the\n  ** unixFile, do nothing. Don't use the end_lock: exit path, as\n  ** unixEnterMutex() hasn't been called yet.\n  */\n  if( pFile->eFileLock>=eFileLock ){\n    OSTRACE((\"LOCK    %d %s ok (already held) (unix)\\n\", pFile->h,\n            azFileLock(eFileLock)));\n    return SQLITE_OK;\n  }\n\n  /* Make sure the locking sequence is correct.\n  **  (1) We never move from unlocked to anything higher than shared lock.\n  **  (2) SQLite never explicitly requests a pending lock.\n  **  (3) A shared lock is always held when a reserve lock is requested.\n  */\n  assert( pFile->eFileLock!=NO_LOCK || eFileLock==SHARED_LOCK );\n  assert( eFileLock!=PENDING_LOCK );\n  assert( eFileLock!=RESERVED_LOCK || pFile->eFileLock==SHARED_LOCK );\n\n  /* This mutex is needed because pFile->pInode is shared across threads\n  */\n  unixEnterMutex();\n  pInode = pFile->pInode;\n\n  /* If some thread using this PID has a lock via a different unixFile*\n  ** handle that precludes the requested lock, return BUSY.\n  */\n  if( (pFile->eFileLock!=pInode->eFileLock && \n          (pInode->eFileLock>=PENDING_LOCK || eFileLock>SHARED_LOCK))\n  ){\n    rc = SQLITE_BUSY;\n    goto end_lock;\n  }\n\n  /* If a SHARED lock is requested, and some thread using this PID already\n  ** has a SHARED or RESERVED lock, then increment reference counts and\n  ** return SQLITE_OK.\n  */\n  if( eFileLock==SHARED_LOCK && \n      (pInode->eFileLock==SHARED_LOCK || pInode->eFileLock==RESERVED_LOCK) ){\n    assert( eFileLock==SHARED_LOCK );\n    assert( pFile->eFileLock==0 );\n    assert( pInode->nShared>0 );\n    pFile->eFileLock = SHARED_LOCK;\n    pInode->nShared++;\n    pInode->nLock++;\n    goto end_lock;\n  }\n\n\n  /* A PENDING lock is needed before acquiring a SHARED lock and before\n  ** acquiring an EXCLUSIVE lock.  For the SHARED lock, the PENDING will\n  ** be released.\n  */\n  lock.l_len = 1L;\n  lock.l_whence = SEEK_SET;\n  if( eFileLock==SHARED_LOCK \n      || (eFileLock==EXCLUSIVE_LOCK && pFile->eFileLock<PENDING_LOCK)\n  ){\n    lock.l_type = (eFileLock==SHARED_LOCK?F_RDLCK:F_WRLCK);\n    lock.l_start = PENDING_BYTE;\n    s = unixFileLock(pFile, &lock);\n    if( s==(-1) ){\n      tErrno = errno;\n      rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK);\n      if( IS_LOCK_ERROR(rc) ){\n        pFile->lastErrno = tErrno;\n      }\n      goto end_lock;\n    }\n  }\n\n\n  /* If control gets to this point, then actually go ahead and make\n  ** operating system calls for the specified lock.\n  */\n  if( eFileLock==SHARED_LOCK ){\n    assert( pInode->nShared==0 );\n    assert( pInode->eFileLock==0 );\n\n    /* Now get the read-lock */\n    lock.l_start = SHARED_FIRST;\n    lock.l_len = SHARED_SIZE;\n    if( (s = unixFileLock(pFile, &lock))==(-1) ){\n      tErrno = errno;\n    }\n    /* Drop the temporary PENDING lock */\n    lock.l_start = PENDING_BYTE;\n    lock.l_len = 1L;\n    lock.l_type = F_UNLCK;\n    if( unixFileLock(pFile, &lock)!=0 ){\n      if( s != -1 ){\n        /* This could happen with a network mount */\n        tErrno = errno; \n        rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_UNLOCK); \n        if( IS_LOCK_ERROR(rc) ){\n          pFile->lastErrno = tErrno;\n        }\n        goto end_lock;\n      }\n    }\n    if( s==(-1) ){\n      rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK);\n      if( IS_LOCK_ERROR(rc) ){\n        pFile->lastErrno = tErrno;\n      }\n    }else{\n      pFile->eFileLock = SHARED_LOCK;\n      pInode->nLock++;\n      pInode->nShared = 1;\n    }\n  }else if( eFileLock==EXCLUSIVE_LOCK && pInode->nShared>1 ){\n    /* We are trying for an exclusive lock but another thread in this\n    ** same process is still holding a shared lock. */\n    rc = SQLITE_BUSY;\n  }else{\n    /* The request was for a RESERVED or EXCLUSIVE lock.  It is\n    ** assumed that there is a SHARED or greater lock on the file\n    ** already.\n    */\n    assert( 0!=pFile->eFileLock );\n    lock.l_type = F_WRLCK;\n    switch( eFileLock ){\n      case RESERVED_LOCK:\n        lock.l_start = RESERVED_BYTE;\n        break;\n      case EXCLUSIVE_LOCK:\n        lock.l_start = SHARED_FIRST;\n        lock.l_len = SHARED_SIZE;\n        break;\n      default:\n        assert(0);\n    }\n    s = unixFileLock(pFile, &lock);\n    if( s==(-1) ){\n      tErrno = errno;\n      rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK);\n      if( IS_LOCK_ERROR(rc) ){\n        pFile->lastErrno = tErrno;\n      }\n    }\n  }\n  \n\n#ifndef NDEBUG\n  /* Set up the transaction-counter change checking flags when\n  ** transitioning from a SHARED to a RESERVED lock.  The change\n  ** from SHARED to RESERVED marks the beginning of a normal\n  ** write operation (not a hot journal rollback).\n  */\n  if( rc==SQLITE_OK\n   && pFile->eFileLock<=SHARED_LOCK\n   && eFileLock==RESERVED_LOCK\n  ){\n    pFile->transCntrChng = 0;\n    pFile->dbUpdate = 0;\n    pFile->inNormalWrite = 1;\n  }\n#endif\n\n\n  if( rc==SQLITE_OK ){\n    pFile->eFileLock = eFileLock;\n    pInode->eFileLock = eFileLock;\n  }else if( eFileLock==EXCLUSIVE_LOCK ){\n    pFile->eFileLock = PENDING_LOCK;\n    pInode->eFileLock = PENDING_LOCK;\n  }\n\nend_lock:\n  unixLeaveMutex();\n  OSTRACE((\"LOCK    %d %s %s (unix)\\n\", pFile->h, azFileLock(eFileLock), \n      rc==SQLITE_OK ? \"ok\" : \"failed\"));\n  return rc;\n}\n\n/*\n** Add the file descriptor used by file handle pFile to the corresponding\n** pUnused list.\n*/\nstatic void setPendingFd(unixFile *pFile){\n  unixInodeInfo *pInode = pFile->pInode;\n  UnixUnusedFd *p = pFile->pUnused;\n  p->pNext = pInode->pUnused;\n  pInode->pUnused = p;\n  pFile->h = -1;\n  pFile->pUnused = 0;\n}\n\n/*\n** Lower the locking level on file descriptor pFile to eFileLock.  eFileLock\n** must be either NO_LOCK or SHARED_LOCK.\n**\n** If the locking level of the file descriptor is already at or below\n** the requested locking level, this routine is a no-op.\n** \n** If handleNFSUnlock is true, then on downgrading an EXCLUSIVE_LOCK to SHARED\n** the byte range is divided into 2 parts and the first part is unlocked then\n** set to a read lock, then the other part is simply unlocked.  This works \n** around a bug in BSD NFS lockd (also seen on MacOSX 10.3+) that fails to \n** remove the write lock on a region when a read lock is set.\n*/\nstatic int posixUnlock(sqlite3_file *id, int eFileLock, int handleNFSUnlock){\n  unixFile *pFile = (unixFile*)id;\n  unixInodeInfo *pInode;\n  struct flock lock;\n  int rc = SQLITE_OK;\n  int h;\n  int tErrno;                      /* Error code from system call errors */\n\n  assert( pFile );\n  OSTRACE((\"UNLOCK  %d %d was %d(%d,%d) pid=%d (unix)\\n\", pFile->h, eFileLock,\n      pFile->eFileLock, pFile->pInode->eFileLock, pFile->pInode->nShared,\n      getpid()));\n\n  assert( eFileLock<=SHARED_LOCK );\n  if( pFile->eFileLock<=eFileLock ){\n    return SQLITE_OK;\n  }\n  unixEnterMutex();\n  h = pFile->h;\n  pInode = pFile->pInode;\n  assert( pInode->nShared!=0 );\n  if( pFile->eFileLock>SHARED_LOCK ){\n    assert( pInode->eFileLock==pFile->eFileLock );\n    SimulateIOErrorBenign(1);\n    SimulateIOError( h=(-1) )\n    SimulateIOErrorBenign(0);\n\n#ifndef NDEBUG\n    /* When reducing a lock such that other processes can start\n    ** reading the database file again, make sure that the\n    ** transaction counter was updated if any part of the database\n    ** file changed.  If the transaction counter is not updated,\n    ** other connections to the same file might not realize that\n    ** the file has changed and hence might not know to flush their\n    ** cache.  The use of a stale cache can lead to database corruption.\n    */\n#if 0\n    assert( pFile->inNormalWrite==0\n         || pFile->dbUpdate==0\n         || pFile->transCntrChng==1 );\n#endif\n    pFile->inNormalWrite = 0;\n#endif\n\n    /* downgrading to a shared lock on NFS involves clearing the write lock\n    ** before establishing the readlock - to avoid a race condition we downgrade\n    ** the lock in 2 blocks, so that part of the range will be covered by a \n    ** write lock until the rest is covered by a read lock:\n    **  1:   [WWWWW]\n    **  2:   [....W]\n    **  3:   [RRRRW]\n    **  4:   [RRRR.]\n    */\n    if( eFileLock==SHARED_LOCK ){\n\n#if !defined(__APPLE__) || !SQLITE_ENABLE_LOCKING_STYLE\n      (void)handleNFSUnlock;\n      assert( handleNFSUnlock==0 );\n#endif\n#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE\n      if( handleNFSUnlock ){\n        off_t divSize = SHARED_SIZE - 1;\n        \n        lock.l_type = F_UNLCK;\n        lock.l_whence = SEEK_SET;\n        lock.l_start = SHARED_FIRST;\n        lock.l_len = divSize;\n        if( unixFileLock(pFile, &lock)==(-1) ){\n          tErrno = errno;\n          rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_UNLOCK);\n          if( IS_LOCK_ERROR(rc) ){\n            pFile->lastErrno = tErrno;\n          }\n          goto end_unlock;\n        }\n        lock.l_type = F_RDLCK;\n        lock.l_whence = SEEK_SET;\n        lock.l_start = SHARED_FIRST;\n        lock.l_len = divSize;\n        if( unixFileLock(pFile, &lock)==(-1) ){\n          tErrno = errno;\n          rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_RDLOCK);\n          if( IS_LOCK_ERROR(rc) ){\n            pFile->lastErrno = tErrno;\n          }\n          goto end_unlock;\n        }\n        lock.l_type = F_UNLCK;\n        lock.l_whence = SEEK_SET;\n        lock.l_start = SHARED_FIRST+divSize;\n        lock.l_len = SHARED_SIZE-divSize;\n        if( unixFileLock(pFile, &lock)==(-1) ){\n          tErrno = errno;\n          rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_UNLOCK);\n          if( IS_LOCK_ERROR(rc) ){\n            pFile->lastErrno = tErrno;\n          }\n          goto end_unlock;\n        }\n      }else\n#endif /* defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE */\n      {\n        lock.l_type = F_RDLCK;\n        lock.l_whence = SEEK_SET;\n        lock.l_start = SHARED_FIRST;\n        lock.l_len = SHARED_SIZE;\n        if( unixFileLock(pFile, &lock)==(-1) ){\n          tErrno = errno;\n          rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_RDLOCK);\n          if( IS_LOCK_ERROR(rc) ){\n            pFile->lastErrno = tErrno;\n          }\n          goto end_unlock;\n        }\n      }\n    }\n    lock.l_type = F_UNLCK;\n    lock.l_whence = SEEK_SET;\n    lock.l_start = PENDING_BYTE;\n    lock.l_len = 2L;  assert( PENDING_BYTE+1==RESERVED_BYTE );\n    if( unixFileLock(pFile, &lock)!=(-1) ){\n      pInode->eFileLock = SHARED_LOCK;\n    }else{\n      tErrno = errno;\n      rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_UNLOCK);\n      if( IS_LOCK_ERROR(rc) ){\n        pFile->lastErrno = tErrno;\n      }\n      goto end_unlock;\n    }\n  }\n  if( eFileLock==NO_LOCK ){\n    /* Decrement the shared lock counter.  Release the lock using an\n    ** OS call only when all threads in this same process have released\n    ** the lock.\n    */\n    pInode->nShared--;\n    if( pInode->nShared==0 ){\n      lock.l_type = F_UNLCK;\n      lock.l_whence = SEEK_SET;\n      lock.l_start = lock.l_len = 0L;\n      SimulateIOErrorBenign(1);\n      SimulateIOError( h=(-1) )\n      SimulateIOErrorBenign(0);\n      if( unixFileLock(pFile, &lock)!=(-1) ){\n        pInode->eFileLock = NO_LOCK;\n      }else{\n        tErrno = errno;\n        rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_UNLOCK);\n        if( IS_LOCK_ERROR(rc) ){\n          pFile->lastErrno = tErrno;\n        }\n        pInode->eFileLock = NO_LOCK;\n        pFile->eFileLock = NO_LOCK;\n      }\n    }\n\n    /* Decrement the count of locks against this same file.  When the\n    ** count reaches zero, close any other file descriptors whose close\n    ** was deferred because of outstanding locks.\n    */\n    pInode->nLock--;\n    assert( pInode->nLock>=0 );\n    if( pInode->nLock==0 ){\n      closePendingFds(pFile);\n    }\n  }\n\nend_unlock:\n  unixLeaveMutex();\n  if( rc==SQLITE_OK ) pFile->eFileLock = eFileLock;\n  return rc;\n}\n\n/*\n** Lower the locking level on file descriptor pFile to eFileLock.  eFileLock\n** must be either NO_LOCK or SHARED_LOCK.\n**\n** If the locking level of the file descriptor is already at or below\n** the requested locking level, this routine is a no-op.\n*/\nstatic int unixUnlock(sqlite3_file *id, int eFileLock){\n  return posixUnlock(id, eFileLock, 0);\n}\n\n/*\n** This function performs the parts of the \"close file\" operation \n** common to all locking schemes. It closes the directory and file\n** handles, if they are valid, and sets all fields of the unixFile\n** structure to 0.\n**\n** It is *not* necessary to hold the mutex when this routine is called,\n** even on VxWorks.  A mutex will be acquired on VxWorks by the\n** vxworksReleaseFileId() routine.\n*/\nstatic int closeUnixFile(sqlite3_file *id){\n  unixFile *pFile = (unixFile*)id;\n  if( pFile ){\n    if( pFile->dirfd>=0 ){\n      robust_close(pFile, pFile->dirfd, __LINE__);\n      pFile->dirfd=-1;\n    }\n    if( pFile->h>=0 ){\n      robust_close(pFile, pFile->h, __LINE__);\n      pFile->h = -1;\n    }\n#if OS_VXWORKS\n    if( pFile->pId ){\n      if( pFile->isDelete ){\n        unlink(pFile->pId->zCanonicalName);\n      }\n      vxworksReleaseFileId(pFile->pId);\n      pFile->pId = 0;\n    }\n#endif\n    OSTRACE((\"CLOSE   %-3d\\n\", pFile->h));\n    OpenCounter(-1);\n    sqlite3_free(pFile->pUnused);\n    memset(pFile, 0, sizeof(unixFile));\n  }\n  return SQLITE_OK;\n}\n\n/*\n** Close a file.\n*/\nstatic int unixClose(sqlite3_file *id){\n  int rc = SQLITE_OK;\n  if( id ){\n    unixFile *pFile = (unixFile *)id;\n    unixUnlock(id, NO_LOCK);\n    unixEnterMutex();\n    assert( pFile->pInode==0 || pFile->pInode->nLock>0\n            || pFile->pInode->bProcessLock==0 );\n    if( pFile->pInode && pFile->pInode->nLock ){\n      /* If there are outstanding locks, do not actually close the file just\n      ** yet because that would clear those locks.  Instead, add the file\n      ** descriptor to pInode->pUnused list.  It will be automatically closed \n      ** when the last lock is cleared.\n      */\n      setPendingFd(pFile);\n    }\n    releaseInodeInfo(pFile);\n    rc = closeUnixFile(id);\n    unixLeaveMutex();\n  }\n  return rc;\n}\n\n/************** End of the posix advisory lock implementation *****************\n******************************************************************************/\n\n/******************************************************************************\n****************************** No-op Locking **********************************\n**\n** Of the various locking implementations available, this is by far the\n** simplest:  locking is ignored.  No attempt is made to lock the database\n** file for reading or writing.\n**\n** This locking mode is appropriate for use on read-only databases\n** (ex: databases that are burned into CD-ROM, for example.)  It can\n** also be used if the application employs some external mechanism to\n** prevent simultaneous access of the same database by two or more\n** database connections.  But there is a serious risk of database\n** corruption if this locking mode is used in situations where multiple\n** database connections are accessing the same database file at the same\n** time and one or more of those connections are writing.\n*/\n\nstatic int nolockCheckReservedLock(sqlite3_file *NotUsed, int *pResOut){\n  UNUSED_PARAMETER(NotUsed);\n  *pResOut = 0;\n  return SQLITE_OK;\n}\nstatic int nolockLock(sqlite3_file *NotUsed, int NotUsed2){\n  UNUSED_PARAMETER2(NotUsed, NotUsed2);\n  return SQLITE_OK;\n}\nstatic int nolockUnlock(sqlite3_file *NotUsed, int NotUsed2){\n  UNUSED_PARAMETER2(NotUsed, NotUsed2);\n  return SQLITE_OK;\n}\n\n/*\n** Close the file.\n*/\nstatic int nolockClose(sqlite3_file *id) {\n  return closeUnixFile(id);\n}\n\n/******************* End of the no-op lock implementation *********************\n******************************************************************************/\n\n/******************************************************************************\n************************* Begin dot-file Locking ******************************\n**\n** The dotfile locking implementation uses the existance of separate lock\n** files in order to control access to the database.  This works on just\n** about every filesystem imaginable.  But there are serious downsides:\n**\n**    (1)  There is zero concurrency.  A single reader blocks all other\n**         connections from reading or writing the database.\n**\n**    (2)  An application crash or power loss can leave stale lock files\n**         sitting around that need to be cleared manually.\n**\n** Nevertheless, a dotlock is an appropriate locking mode for use if no\n** other locking strategy is available.\n**\n** Dotfile locking works by creating a file in the same directory as the\n** database and with the same name but with a \".lock\" extension added.\n** The existance of a lock file implies an EXCLUSIVE lock.  All other lock\n** types (SHARED, RESERVED, PENDING) are mapped into EXCLUSIVE.\n*/\n\n/*\n** The file suffix added to the data base filename in order to create the\n** lock file.\n*/\n#define DOTLOCK_SUFFIX \".lock\"\n\n/*\n** This routine checks if there is a RESERVED lock held on the specified\n** file by this or any other process. If such a lock is held, set *pResOut\n** to a non-zero value otherwise *pResOut is set to zero.  The return value\n** is set to SQLITE_OK unless an I/O error occurs during lock checking.\n**\n** In dotfile locking, either a lock exists or it does not.  So in this\n** variation of CheckReservedLock(), *pResOut is set to true if any lock\n** is held on the file and false if the file is unlocked.\n*/\nstatic int dotlockCheckReservedLock(sqlite3_file *id, int *pResOut) {\n  int rc = SQLITE_OK;\n  int reserved = 0;\n  unixFile *pFile = (unixFile*)id;\n\n  SimulateIOError( return SQLITE_IOERR_CHECKRESERVEDLOCK; );\n  \n  assert( pFile );\n\n  /* Check if a thread in this process holds such a lock */\n  if( pFile->eFileLock>SHARED_LOCK ){\n    /* Either this connection or some other connection in the same process\n    ** holds a lock on the file.  No need to check further. */\n    reserved = 1;\n  }else{\n    /* The lock is held if and only if the lockfile exists */\n    const char *zLockFile = (const char*)pFile->lockingContext;\n    reserved = osAccess(zLockFile, 0)==0;\n  }\n  OSTRACE((\"TEST WR-LOCK %d %d %d (dotlock)\\n\", pFile->h, rc, reserved));\n  *pResOut = reserved;\n  return rc;\n}\n\n/*\n** Lock the file with the lock specified by parameter eFileLock - one\n** of the following:\n**\n**     (1) SHARED_LOCK\n**     (2) RESERVED_LOCK\n**     (3) PENDING_LOCK\n**     (4) EXCLUSIVE_LOCK\n**\n** Sometimes when requesting one lock state, additional lock states\n** are inserted in between.  The locking might fail on one of the later\n** transitions leaving the lock state different from what it started but\n** still short of its goal.  The following chart shows the allowed\n** transitions and the inserted intermediate states:\n**\n**    UNLOCKED -> SHARED\n**    SHARED -> RESERVED\n**    SHARED -> (PENDING) -> EXCLUSIVE\n**    RESERVED -> (PENDING) -> EXCLUSIVE\n**    PENDING -> EXCLUSIVE\n**\n** This routine will only increase a lock.  Use the sqlite3OsUnlock()\n** routine to lower a locking level.\n**\n** With dotfile locking, we really only support state (4): EXCLUSIVE.\n** But we track the other locking levels internally.\n*/\nstatic int dotlockLock(sqlite3_file *id, int eFileLock) {\n  unixFile *pFile = (unixFile*)id;\n  int fd;\n  char *zLockFile = (char *)pFile->lockingContext;\n  int rc = SQLITE_OK;\n\n\n  /* If we have any lock, then the lock file already exists.  All we have\n  ** to do is adjust our internal record of the lock level.\n  */\n  if( pFile->eFileLock > NO_LOCK ){\n    pFile->eFileLock = eFileLock;\n#if !OS_VXWORKS\n    /* Always update the timestamp on the old file */\n    utimes(zLockFile, NULL);\n#endif\n    return SQLITE_OK;\n  }\n  \n  /* grab an exclusive lock */\n  fd = robust_open(zLockFile,O_RDONLY|O_CREAT|O_EXCL,0600);\n  if( fd<0 ){\n    /* failed to open/create the file, someone else may have stolen the lock */\n    int tErrno = errno;\n    if( EEXIST == tErrno ){\n      rc = SQLITE_BUSY;\n    } else {\n      rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK);\n      if( IS_LOCK_ERROR(rc) ){\n        pFile->lastErrno = tErrno;\n      }\n    }\n    return rc;\n  } \n  robust_close(pFile, fd, __LINE__);\n  \n  /* got it, set the type and return ok */\n  pFile->eFileLock = eFileLock;\n  return rc;\n}\n\n/*\n** Lower the locking level on file descriptor pFile to eFileLock.  eFileLock\n** must be either NO_LOCK or SHARED_LOCK.\n**\n** If the locking level of the file descriptor is already at or below\n** the requested locking level, this routine is a no-op.\n**\n** When the locking level reaches NO_LOCK, delete the lock file.\n*/\nstatic int dotlockUnlock(sqlite3_file *id, int eFileLock) {\n  unixFile *pFile = (unixFile*)id;\n  char *zLockFile = (char *)pFile->lockingContext;\n\n  assert( pFile );\n  OSTRACE((\"UNLOCK  %d %d was %d pid=%d (dotlock)\\n\", pFile->h, eFileLock,\n       pFile->eFileLock, getpid()));\n  assert( eFileLock<=SHARED_LOCK );\n  \n  /* no-op if possible */\n  if( pFile->eFileLock==eFileLock ){\n    return SQLITE_OK;\n  }\n\n  /* To downgrade to shared, simply update our internal notion of the\n  ** lock state.  No need to mess with the file on disk.\n  */\n  if( eFileLock==SHARED_LOCK ){\n    pFile->eFileLock = SHARED_LOCK;\n    return SQLITE_OK;\n  }\n  \n  /* To fully unlock the database, delete the lock file */\n  assert( eFileLock==NO_LOCK );\n  if( unlink(zLockFile) ){\n    int rc = 0;\n    int tErrno = errno;\n    if( ENOENT != tErrno ){\n      rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_UNLOCK);\n    }\n    if( IS_LOCK_ERROR(rc) ){\n      pFile->lastErrno = tErrno;\n    }\n    return rc; \n  }\n  pFile->eFileLock = NO_LOCK;\n  return SQLITE_OK;\n}\n\n/*\n** Close a file.  Make sure the lock has been released before closing.\n*/\nstatic int dotlockClose(sqlite3_file *id) {\n  int rc;\n  if( id ){\n    unixFile *pFile = (unixFile*)id;\n    dotlockUnlock(id, NO_LOCK);\n    sqlite3_free(pFile->lockingContext);\n  }\n  rc = closeUnixFile(id);\n  return rc;\n}\n/****************** End of the dot-file lock implementation *******************\n******************************************************************************/\n\n/******************************************************************************\n************************** Begin flock Locking ********************************\n**\n** Use the flock() system call to do file locking.\n**\n** flock() locking is like dot-file locking in that the various\n** fine-grain locking levels supported by SQLite are collapsed into\n** a single exclusive lock.  In other words, SHARED, RESERVED, and\n** PENDING locks are the same thing as an EXCLUSIVE lock.  SQLite\n** still works when you do this, but concurrency is reduced since\n** only a single process can be reading the database at a time.\n**\n** Omit this section if SQLITE_ENABLE_LOCKING_STYLE is turned off or if\n** compiling for VXWORKS.\n*/\n#if SQLITE_ENABLE_LOCKING_STYLE && !OS_VXWORKS\n\n/*\n** Retry flock() calls that fail with EINTR\n*/\n#ifdef EINTR\nstatic int robust_flock(int fd, int op){\n  int rc;\n  do{ rc = flock(fd,op); }while( rc<0 && errno==EINTR );\n  return rc;\n}\n#else\n# define robust_flock(a,b) flock(a,b)\n#endif\n     \n\n/*\n** This routine checks if there is a RESERVED lock held on the specified\n** file by this or any other process. If such a lock is held, set *pResOut\n** to a non-zero value otherwise *pResOut is set to zero.  The return value\n** is set to SQLITE_OK unless an I/O error occurs during lock checking.\n*/\nstatic int flockCheckReservedLock(sqlite3_file *id, int *pResOut){\n  int rc = SQLITE_OK;\n  int reserved = 0;\n  unixFile *pFile = (unixFile*)id;\n  \n  SimulateIOError( return SQLITE_IOERR_CHECKRESERVEDLOCK; );\n  \n  assert( pFile );\n  \n  /* Check if a thread in this process holds such a lock */\n  if( pFile->eFileLock>SHARED_LOCK ){\n    reserved = 1;\n  }\n  \n  /* Otherwise see if some other process holds it. */\n  if( !reserved ){\n    /* attempt to get the lock */\n    int lrc = robust_flock(pFile->h, LOCK_EX | LOCK_NB);\n    if( !lrc ){\n      /* got the lock, unlock it */\n      lrc = robust_flock(pFile->h, LOCK_UN);\n      if ( lrc ) {\n        int tErrno = errno;\n        /* unlock failed with an error */\n        lrc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_UNLOCK); \n        if( IS_LOCK_ERROR(lrc) ){\n          pFile->lastErrno = tErrno;\n          rc = lrc;\n        }\n      }\n    } else {\n      int tErrno = errno;\n      reserved = 1;\n      /* someone else might have it reserved */\n      lrc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK); \n      if( IS_LOCK_ERROR(lrc) ){\n        pFile->lastErrno = tErrno;\n        rc = lrc;\n      }\n    }\n  }\n  OSTRACE((\"TEST WR-LOCK %d %d %d (flock)\\n\", pFile->h, rc, reserved));\n\n#ifdef SQLITE_IGNORE_FLOCK_LOCK_ERRORS\n  if( (rc & SQLITE_IOERR) == SQLITE_IOERR ){\n    rc = SQLITE_OK;\n    reserved=1;\n  }\n#endif /* SQLITE_IGNORE_FLOCK_LOCK_ERRORS */\n  *pResOut = reserved;\n  return rc;\n}\n\n/*\n** Lock the file with the lock specified by parameter eFileLock - one\n** of the following:\n**\n**     (1) SHARED_LOCK\n**     (2) RESERVED_LOCK\n**     (3) PENDING_LOCK\n**     (4) EXCLUSIVE_LOCK\n**\n** Sometimes when requesting one lock state, additional lock states\n** are inserted in between.  The locking might fail on one of the later\n** transitions leaving the lock state different from what it started but\n** still short of its goal.  The following chart shows the allowed\n** transitions and the inserted intermediate states:\n**\n**    UNLOCKED -> SHARED\n**    SHARED -> RESERVED\n**    SHARED -> (PENDING) -> EXCLUSIVE\n**    RESERVED -> (PENDING) -> EXCLUSIVE\n**    PENDING -> EXCLUSIVE\n**\n** flock() only really support EXCLUSIVE locks.  We track intermediate\n** lock states in the sqlite3_file structure, but all locks SHARED or\n** above are really EXCLUSIVE locks and exclude all other processes from\n** access the file.\n**\n** This routine will only increase a lock.  Use the sqlite3OsUnlock()\n** routine to lower a locking level.\n*/\nstatic int flockLock(sqlite3_file *id, int eFileLock) {\n  int rc = SQLITE_OK;\n  unixFile *pFile = (unixFile*)id;\n\n  assert( pFile );\n\n  /* if we already have a lock, it is exclusive.  \n  ** Just adjust level and punt on outta here. */\n  if (pFile->eFileLock > NO_LOCK) {\n    pFile->eFileLock = eFileLock;\n    return SQLITE_OK;\n  }\n  \n  /* grab an exclusive lock */\n  \n  if (robust_flock(pFile->h, LOCK_EX | LOCK_NB)) {\n    int tErrno = errno;\n    /* didn't get, must be busy */\n    rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_LOCK);\n    if( IS_LOCK_ERROR(rc) ){\n      pFile->lastErrno = tErrno;\n    }\n  } else {\n    /* got it, set the type and return ok */\n    pFile->eFileLock = eFileLock;\n  }\n  OSTRACE((\"LOCK    %d %s %s (flock)\\n\", pFile->h, azFileLock(eFileLock), \n           rc==SQLITE_OK ? \"ok\" : \"failed\"));\n#ifdef SQLITE_IGNORE_FLOCK_LOCK_ERRORS\n  if( (rc & SQLITE_IOERR) == SQLITE_IOERR ){\n    rc = SQLITE_BUSY;\n  }\n#endif /* SQLITE_IGNORE_FLOCK_LOCK_ERRORS */\n  return rc;\n}\n\n\n/*\n** Lower the locking level on file descriptor pFile to eFileLock.  eFileLock\n** must be either NO_LOCK or SHARED_LOCK.\n**\n** If the locking level of the file descriptor is already at or below\n** the requested locking level, this routine is a no-op.\n*/\nstatic int flockUnlock(sqlite3_file *id, int eFileLock) {\n  unixFile *pFile = (unixFile*)id;\n  \n  assert( pFile );\n  OSTRACE((\"UNLOCK  %d %d was %d pid=%d (flock)\\n\", pFile->h, eFileLock,\n           pFile->eFileLock, getpid()));\n  assert( eFileLock<=SHARED_LOCK );\n  \n  /* no-op if possible */\n  if( pFile->eFileLock==eFileLock ){\n    return SQLITE_OK;\n  }\n  \n  /* shared can just be set because we always have an exclusive */\n  if (eFileLock==SHARED_LOCK) {\n    pFile->eFileLock = eFileLock;\n    return SQLITE_OK;\n  }\n  \n  /* no, really, unlock. */\n  int rc = robust_flock(pFile->h, LOCK_UN);\n  if (rc) {\n    int r, tErrno = errno;\n    r = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_UNLOCK);\n    if( IS_LOCK_ERROR(r) ){\n      pFile->lastErrno = tErrno;\n    }\n#ifdef SQLITE_IGNORE_FLOCK_LOCK_ERRORS\n    if( (r & SQLITE_IOERR) == SQLITE_IOERR ){\n      r = SQLITE_BUSY;\n    }\n#endif /* SQLITE_IGNORE_FLOCK_LOCK_ERRORS */\n    \n    return r;\n  } else {\n    pFile->eFileLock = NO_LOCK;\n    return SQLITE_OK;\n  }\n}\n\n/*\n** Close a file.\n*/\nstatic int flockClose(sqlite3_file *id) {\n  if( id ){\n    flockUnlock(id, NO_LOCK);\n  }\n  return closeUnixFile(id);\n}\n\n#endif /* SQLITE_ENABLE_LOCKING_STYLE && !OS_VXWORK */\n\n/******************* End of the flock lock implementation *********************\n******************************************************************************/\n\n/******************************************************************************\n************************ Begin Named Semaphore Locking ************************\n**\n** Named semaphore locking is only supported on VxWorks.\n**\n** Semaphore locking is like dot-lock and flock in that it really only\n** supports EXCLUSIVE locking.  Only a single process can read or write\n** the database file at a time.  This reduces potential concurrency, but\n** makes the lock implementation much easier.\n*/\n#if OS_VXWORKS\n\n/*\n** This routine checks if there is a RESERVED lock held on the specified\n** file by this or any other process. If such a lock is held, set *pResOut\n** to a non-zero value otherwise *pResOut is set to zero.  The return value\n** is set to SQLITE_OK unless an I/O error occurs during lock checking.\n*/\nstatic int semCheckReservedLock(sqlite3_file *id, int *pResOut) {\n  int rc = SQLITE_OK;\n  int reserved = 0;\n  unixFile *pFile = (unixFile*)id;\n\n  SimulateIOError( return SQLITE_IOERR_CHECKRESERVEDLOCK; );\n  \n  assert( pFile );\n\n  /* Check if a thread in this process holds such a lock */\n  if( pFile->eFileLock>SHARED_LOCK ){\n    reserved = 1;\n  }\n  \n  /* Otherwise see if some other process holds it. */\n  if( !reserved ){\n    sem_t *pSem = pFile->pInode->pSem;\n    struct stat statBuf;\n\n    if( sem_trywait(pSem)==-1 ){\n      int tErrno = errno;\n      if( EAGAIN != tErrno ){\n        rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_CHECKRESERVEDLOCK);\n        pFile->lastErrno = tErrno;\n      } else {\n        /* someone else has the lock when we are in NO_LOCK */\n        reserved = (pFile->eFileLock < SHARED_LOCK);\n      }\n    }else{\n      /* we could have it if we want it */\n      sem_post(pSem);\n    }\n  }\n  OSTRACE((\"TEST WR-LOCK %d %d %d (sem)\\n\", pFile->h, rc, reserved));\n\n  *pResOut = reserved;\n  return rc;\n}\n\n/*\n** Lock the file with the lock specified by parameter eFileLock - one\n** of the following:\n**\n**     (1) SHARED_LOCK\n**     (2) RESERVED_LOCK\n**     (3) PENDING_LOCK\n**     (4) EXCLUSIVE_LOCK\n**\n** Sometimes when requesting one lock state, additional lock states\n** are inserted in between.  The locking might fail on one of the later\n** transitions leaving the lock state different from what it started but\n** still short of its goal.  The following chart shows the allowed\n** transitions and the inserted intermediate states:\n**\n**    UNLOCKED -> SHARED\n**    SHARED -> RESERVED\n**    SHARED -> (PENDING) -> EXCLUSIVE\n**    RESERVED -> (PENDING) -> EXCLUSIVE\n**    PENDING -> EXCLUSIVE\n**\n** Semaphore locks only really support EXCLUSIVE locks.  We track intermediate\n** lock states in the sqlite3_file structure, but all locks SHARED or\n** above are really EXCLUSIVE locks and exclude all other processes from\n** access the file.\n**\n** This routine will only increase a lock.  Use the sqlite3OsUnlock()\n** routine to lower a locking level.\n*/\nstatic int semLock(sqlite3_file *id, int eFileLock) {\n  unixFile *pFile = (unixFile*)id;\n  int fd;\n  sem_t *pSem = pFile->pInode->pSem;\n  int rc = SQLITE_OK;\n\n  /* if we already have a lock, it is exclusive.  \n  ** Just adjust level and punt on outta here. */\n  if (pFile->eFileLock > NO_LOCK) {\n    pFile->eFileLock = eFileLock;\n    rc = SQLITE_OK;\n    goto sem_end_lock;\n  }\n  \n  /* lock semaphore now but bail out when already locked. */\n  if( sem_trywait(pSem)==-1 ){\n    rc = SQLITE_BUSY;\n    goto sem_end_lock;\n  }\n\n  /* got it, set the type and return ok */\n  pFile->eFileLock = eFileLock;\n\n sem_end_lock:\n  return rc;\n}\n\n/*\n** Lower the locking level on file descriptor pFile to eFileLock.  eFileLock\n** must be either NO_LOCK or SHARED_LOCK.\n**\n** If the locking level of the file descriptor is already at or below\n** the requested locking level, this routine is a no-op.\n*/\nstatic int semUnlock(sqlite3_file *id, int eFileLock) {\n  unixFile *pFile = (unixFile*)id;\n  sem_t *pSem = pFile->pInode->pSem;\n\n  assert( pFile );\n  assert( pSem );\n  OSTRACE((\"UNLOCK  %d %d was %d pid=%d (sem)\\n\", pFile->h, eFileLock,\n       pFile->eFileLock, getpid()));\n  assert( eFileLock<=SHARED_LOCK );\n  \n  /* no-op if possible */\n  if( pFile->eFileLock==eFileLock ){\n    return SQLITE_OK;\n  }\n  \n  /* shared can just be set because we always have an exclusive */\n  if (eFileLock==SHARED_LOCK) {\n    pFile->eFileLock = eFileLock;\n    return SQLITE_OK;\n  }\n  \n  /* no, really unlock. */\n  if ( sem_post(pSem)==-1 ) {\n    int rc, tErrno = errno;\n    rc = sqliteErrorFromPosixError(tErrno, SQLITE_IOERR_UNLOCK);\n    if( IS_LOCK_ERROR(rc) ){\n      pFile->lastErrno = tErrno;\n    }\n    return rc; \n  }\n  pFile->eFileLock = NO_LOCK;\n  return SQLITE_OK;\n}\n\n/*\n ** Close a file.\n */\nstatic int semClose(sqlite3_file *id) {\n  if( id ){\n    unixFile *pFile = (unixFile*)id;\n    semUnlock(id, NO_LOCK);\n    assert( pFile );\n    unixEnterMutex();\n    releaseInodeInfo(pFile);\n    unixLeaveMutex();\n    closeUnixFile(id);\n  }\n  return SQLITE_OK;\n}\n\n#endif /* OS_VXWORKS */\n/*\n** Named semaphore locking is only available on VxWorks.\n**\n*************** End of the named semaphore lock implementation ****************\n******************************************************************************/\n\n\n/******************************************************************************\n*************************** Begin AFP Locking *********************************\n**\n** AFP is the Apple Filing Protocol.  AFP is a network filesystem found\n** on Apple Macintosh computers - both OS9 and OSX.\n**\n** Third-party implementations of AFP are available.  But this code here\n** only works on OSX.\n*/\n\n#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE\n/*\n** The afpLockingContext structure contains all afp lock specific state\n*/\ntypedef struct afpLockingContext afpLockingContext;\nstruct afpLockingContext {\n  int reserved;\n  const char *dbPath;             /* Name of the open file */\n};\n\nstruct ByteRangeLockPB2\n{\n  unsigned long long offset;        /* offset to first byte to lock */\n  unsigned long long length;        /* nbr of bytes to lock */\n  unsigned long long retRangeStart; /* nbr of 1st byte locked if successful */\n  unsigned char unLockFlag;         /* 1 = unlock, 0 = lock */\n  unsigned char startEndFlag;       /* 1=rel to end of fork, 0=rel to start */\n  int fd;                           /* file desc to assoc this lock with */\n};\n\n#define afpfsByteRangeLock2FSCTL        _IOWR('z', 23, struct ByteRangeLockPB2)\n\n/*\n** This is a utility for setting or clearing a bit-range lock on an\n** AFP filesystem.\n** \n** Return SQLITE_OK on success, SQLITE_BUSY on failure.\n*/\nstatic int afpSetLock(\n  const char *path,              /* Name of the file to be locked or unlocked */\n  unixFile *pFile,               /* Open file descriptor on path */\n  unsigned long long offset,     /* First byte to be locked */\n  unsigned long long length,     /* Number of bytes to lock */\n  int setLockFlag                /* True to set lock.  False to clear lock */\n){\n  struct ByteRangeLockPB2 pb;\n  int err;\n  \n  pb.unLockFlag = setLockFlag ? 0 : 1;\n  pb.startEndFlag = 0;\n  pb.offset = offset;\n  pb.length = length; \n  pb.fd = pFile->h;\n  \n  OSTRACE((\"AFPSETLOCK [%s] for %d%s in range %llx:%llx\\n\", \n    (setLockFlag?\"ON\":\"OFF\"), pFile->h, (pb.fd==-1?\"[testval-1]\":\"\"),\n    offset, length));\n  err = fsctl(path, afpfsByteRangeLock2FSCTL, &pb, 0);\n  if ( err==-1 ) {\n    int rc;\n    int tErrno = errno;\n    OSTRACE((\"AFPSETLOCK failed to fsctl() '%s' %d %s\\n\",\n             path, tErrno, strerror(tErrno)));\n#ifdef SQLITE_IGNORE_AFP_LOCK_ERRORS\n    rc = SQLITE_BUSY;\n#else\n    rc = sqliteErrorFromPosixError(tErrno,\n                    setLockFlag ? SQLITE_IOERR_LOCK : SQLITE_IOERR_UNLOCK);\n#endif /* SQLITE_IGNORE_AFP_LOCK_ERRORS */\n    if( IS_LOCK_ERROR(rc) ){\n      pFile->lastErrno = tErrno;\n    }\n    return rc;\n  } else {\n    return SQLITE_OK;\n  }\n}\n\n/*\n** This routine checks if there is a RESERVED lock held on the specified\n** file by this or any other process. If such a lock is held, set *pResOut\n** to a non-zero value otherwise *pResOut is set to zero.  The return value\n** is set to SQLITE_OK unless an I/O error occurs during lock checking.\n*/\nstatic int afpCheckReservedLock(sqlite3_file *id, int *pResOut){\n  int rc = SQLITE_OK;\n  int reserved = 0;\n  unixFile *pFile = (unixFile*)id;\n  \n  SimulateIOError( return SQLITE_IOERR_CHECKRESERVEDLOCK; );\n  \n  assert( pFile );\n  afpLockingContext *context = (afpLockingContext *) pFile->lockingContext;\n  if( context->reserved ){\n    *pResOut = 1;\n    return SQLITE_OK;\n  }\n  unixEnterMutex(); /* Because pFile->pInode is shared across threads */\n  \n  /* Check if a thread in this process holds such a lock */\n  if( pFile->pInode->eFileLock>SHARED_LOCK ){\n    reserved = 1;\n  }\n  \n  /* Otherwise see if some other process holds it.\n   */\n  if( !reserved ){\n    /* lock the RESERVED byte */\n    int lrc = afpSetLock(context->dbPath, pFile, RESERVED_BYTE, 1,1);  \n    if( SQLITE_OK==lrc ){\n      /* if we succeeded in taking the reserved lock, unlock it to restore\n      ** the original state */\n      lrc = afpSetLock(context->dbPath, pFile, RESERVED_BYTE, 1, 0);\n    } else {\n      /* if we failed to get the lock then someone else must have it */\n      reserved = 1;\n    }\n    if( IS_LOCK_ERROR(lrc) ){\n      rc=lrc;\n    }\n  }\n  \n  unixLeaveMutex();\n  OSTRACE((\"TEST WR-LOCK %d %d %d (afp)\\n\", pFile->h, rc, reserved));\n  \n  *pResOut = reserved;\n  return rc;\n}\n\n/*\n** Lock the file with the lock specified by parameter eFileLock - one\n** of the following:\n**\n**     (1) SHARED_LOCK\n**     (2) RESERVED_LOCK\n**     (3) PENDING_LOCK\n**     (4) EXCLUSIVE_LOCK\n**\n** Sometimes when requesting one lock state, additional lock states\n** are inserted in between.  The locking might fail on one of the later\n** transitions leaving the lock state different from what it started but\n** still short of its goal.  The following chart shows the allowed\n** transitions and the inserted intermediate states:\n**\n**    UNLOCKED -> SHARED\n**    SHARED -> RESERVED\n**    SHARED -> (PENDING) -> EXCLUSIVE\n**    RESERVED -> (PENDING) -> EXCLUSIVE\n**    PENDING -> EXCLUSIVE\n**\n** This routine will only increase a lock.  Use the sqlite3OsUnlock()\n** routine to lower a locking level.\n*/\nstatic int afpLock(sqlite3_file *id, int eFileLock){\n  int rc = SQLITE_OK;\n  unixFile *pFile = (unixFile*)id;\n  unixInodeInfo *pInode = pFile->pInode;\n  afpLockingContext *context = (afpLockingContext *) pFile->lockingContext;\n  \n  assert( pFile );\n  OSTRACE((\"LOCK    %d %s was %s(%s,%d) pid=%d (afp)\\n\", pFile->h,\n           azFileLock(eFileLock), azFileLock(pFile->eFileLock),\n           azFileLock(pInode->eFileLock), pInode->nShared , getpid()));\n\n  /* If there is already a lock of this type or more restrictive on the\n  ** unixFile, do nothing. Don't use the afp_end_lock: exit path, as\n  ** unixEnterMutex() hasn't been called yet.\n  */\n  if( pFile->eFileLock>=eFileLock ){\n    OSTRACE((\"LOCK    %d %s ok (already held) (afp)\\n\", pFile->h,\n           azFileLock(eFileLock)));\n    return SQLITE_OK;\n  }\n\n  /* Make sure the locking sequence is correct\n  **  (1) We never move from unlocked to anything higher than shared lock.\n  **  (2) SQLite never explicitly requests a pending lock.\n  **  (3) A shared lock is always held when a reserve lock is requested.\n  */\n  assert( pFile->eFileLock!=NO_LOCK || eFileLock==SHARED_LOCK );\n  assert( eFileLock!=PENDING_LOCK );\n  assert( eFileLock!=RESERVED_LOCK || pFile->eFileLock==SHARED_LOCK );\n  \n  /* This mutex is needed because pFile->pInode is shared across threads\n  */\n  unixEnterMutex();\n  pInode = pFile->pInode;\n\n  /* If some thread using this PID has a lock via a different unixFile*\n  ** handle that precludes the requested lock, return BUSY.\n  */\n  if( (pFile->eFileLock!=pInode->eFileLock && \n       (pInode->eFileLock>=PENDING_LOCK || eFileLock>SHARED_LOCK))\n     ){\n    rc = SQLITE_BUSY;\n    goto afp_end_lock;\n  }\n  \n  /* If a SHARED lock is requested, and some thread using this PID already\n  ** has a SHARED or RESERVED lock, then increment reference counts and\n  ** return SQLITE_OK.\n  */\n  if( eFileLock==SHARED_LOCK && \n     (pInode->eFileLock==SHARED_LOCK || pInode->eFileLock==RESERVED_LOCK) ){\n    assert( eFileLock==SHARED_LOCK );\n    assert( pFile->eFileLock==0 );\n    assert( pInode->nShared>0 );\n    pFile->eFileLock = SHARED_LOCK;\n    pInode->nShared++;\n    pInode->nLock++;\n    goto afp_end_lock;\n  }\n    \n  /* A PENDING lock is needed before acquiring a SHARED lock and before\n  ** acquiring an EXCLUSIVE lock.  For the SHARED lock, the PENDING will\n  ** be released.\n  */\n  if( eFileLock==SHARED_LOCK \n      || (eFileLock==EXCLUSIVE_LOCK && pFile->eFileLock<PENDING_LOCK)\n  ){\n    int failed;\n    failed = afpSetLock(context->dbPath, pFile, PENDING_BYTE, 1, 1);\n    if (failed) {\n      rc = failed;\n      goto afp_end_lock;\n    }\n  }\n  \n  /* If control gets to this point, then actually go ahead and make\n  ** operating system calls for the specified lock.\n  */\n  if( eFileLock==SHARED_LOCK ){\n    int lrc1, lrc2, lrc1Errno;\n    long lk, mask;\n    \n    assert( pInode->nShared==0 );\n    assert( pInode->eFileLock==0 );\n        \n    mask = (sizeof(long)==8) ? LARGEST_INT64 : 0x7fffffff;\n    /* Now get the read-lock SHARED_LOCK */\n    /* note that the quality of the randomness doesn't matter that much */\n    lk = random(); \n    pInode->sharedByte = (lk & mask)%(SHARED_SIZE - 1);\n    lrc1 = afpSetLock(context->dbPath, pFile, \n          SHARED_FIRST+pInode->sharedByte, 1, 1);\n    if( IS_LOCK_ERROR(lrc1) ){\n      lrc1Errno = pFile->lastErrno;\n    }\n    /* Drop the temporary PENDING lock */\n    lrc2 = afpSetLock(context->dbPath, pFile, PENDING_BYTE, 1, 0);\n    \n    if( IS_LOCK_ERROR(lrc1) ) {\n      pFile->lastErrno = lrc1Errno;\n      rc = lrc1;\n      goto afp_end_lock;\n    } else if( IS_LOCK_ERROR(lrc2) ){\n      rc = lrc2;\n      goto afp_end_lock;\n    } else if( lrc1 != SQLITE_OK ) {\n      rc = lrc1;\n    } else {\n      pFile->eFileLock = SHARED_LOCK;\n      pInode->nLock++;\n      pInode->nShared = 1;\n    }\n  }else if( eFileLock==EXCLUSIVE_LOCK && pInode->nShared>1 ){\n    /* We are trying for an exclusive lock but another thread in this\n     ** same process is still holding a shared lock. */\n    rc = SQLITE_BUSY;\n  }else{\n    /* The request was for a RESERVED or EXCLUSIVE lock.  It is\n    ** assumed that there is a SHARED or greater lock on the file\n    ** already.\n    */\n    int failed = 0;\n    assert( 0!=pFile->eFileLock );\n    if (eFileLock >= RESERVED_LOCK && pFile->eFileLock < RESERVED_LOCK) {\n        /* Acquire a RESERVED lock */\n        failed = afpSetLock(context->dbPath, pFile, RESERVED_BYTE, 1,1);\n      if( !failed ){\n        context->reserved = 1;\n      }\n    }\n    if (!failed && eFileLock == EXCLUSIVE_LOCK) {\n      /* Acquire an EXCLUSIVE lock */\n        \n      /* Remove the shared lock before trying the range.  we'll need to \n      ** reestablish the shared lock if we can't get the  afpUnlock\n      */\n      if( !(failed = afpSetLock(context->dbPath, pFile, SHARED_FIRST +\n                         pInode->sharedByte, 1, 0)) ){\n        int failed2 = SQLITE_OK;\n        /* now attemmpt to get the exclusive lock range */\n        failed = afpSetLock(context->dbPath, pFile, SHARED_FIRST, \n                               SHARED_SIZE, 1);\n        if( failed && (failed2 = afpSetLock(context->dbPath, pFile, \n                       SHARED_FIRST + pInode->sharedByte, 1, 1)) ){\n          /* Can't reestablish the shared lock.  Sqlite can't deal, this is\n          ** a critical I/O error\n          */\n          rc = ((failed & SQLITE_IOERR) == SQLITE_IOERR) ? failed2 : \n               SQLITE_IOERR_LOCK;\n          goto afp_end_lock;\n        } \n      }else{\n        rc = failed; \n      }\n    }\n    if( failed ){\n      rc = failed;\n    }\n  }\n  \n  if( rc==SQLITE_OK ){\n    pFile->eFileLock = eFileLock;\n    pInode->eFileLock = eFileLock;\n  }else if( eFileLock==EXCLUSIVE_LOCK ){\n    pFile->eFileLock = PENDING_LOCK;\n    pInode->eFileLock = PENDING_LOCK;\n  }\n  \nafp_end_lock:\n  unixLeaveMutex();\n  OSTRACE((\"LOCK    %d %s %s (afp)\\n\", pFile->h, azFileLock(eFileLock), \n         rc==SQLITE_OK ? \"ok\" : \"failed\"));\n  return rc;\n}\n\n/*\n** Lower the locking level on file descriptor pFile to eFileLock.  eFileLock\n** must be either NO_LOCK or SHARED_LOCK.\n**\n** If the locking level of the file descriptor is already at or below\n** the requested locking level, this routine is a no-op.\n*/\nstatic int afpUnlock(sqlite3_file *id, int eFileLock) {\n  int rc = SQLITE_OK;\n  unixFile *pFile = (unixFile*)id;\n  unixInodeInfo *pInode;\n  afpLockingContext *context = (afpLockingContext *) pFile->lockingContext;\n  int skipShared = 0;\n#ifdef SQLITE_TEST\n  int h = pFile->h;\n#endif\n\n  assert( pFile );\n  OSTRACE((\"UNLOCK  %d %d was %d(%d,%d) pid=%d (afp)\\n\", pFile->h, eFileLock,\n           pFile->eFileLock, pFile->pInode->eFileLock, pFile->pInode->nShared,\n           getpid()));\n\n  assert( eFileLock<=SHARED_LOCK );\n  if( pFile->eFileLock<=eFileLock ){\n    return SQLITE_OK;\n  }\n  unixEnterMutex();\n  pInode = pFile->pInode;\n  assert( pInode->nShared!=0 );\n  if( pFile->eFileLock>SHARED_LOCK ){\n    assert( pInode->eFileLock==pFile->eFileLock );\n    SimulateIOErrorBenign(1);\n    SimulateIOError( h=(-1) )\n    SimulateIOErrorBenign(0);\n    \n#ifndef NDEBUG\n    /* When reducing a lock such that other processes can start\n    ** reading the database file again, make sure that the\n    ** transaction counter was updated if any part of the database\n    ** file changed.  If the transaction counter is not updated,\n    ** other connections to the same file might not realize that\n    ** the file has changed and hence might not know to flush their\n    ** cache.  The use of a stale cache can lead to database corruption.\n    */\n    assert( pFile->inNormalWrite==0\n           || pFile->dbUpdate==0\n           || pFile->transCntrChng==1 );\n    pFile->inNormalWrite = 0;\n#endif\n    \n    if( pFile->eFileLock==EXCLUSIVE_LOCK ){\n      rc = afpSetLock(context->dbPath, pFile, SHARED_FIRST, SHARED_SIZE, 0);\n      if( rc==SQLITE_OK && (eFileLock==SHARED_LOCK || pInode->nShared>1) ){\n        /* only re-establish the shared lock if necessary */\n        int sharedLockByte = SHARED_FIRST+pInode->sharedByte;\n        rc = afpSetLock(context->dbPath, pFile, sharedLockByte, 1, 1);\n      } else {\n        skipShared = 1;\n      }\n    }\n    if( rc==SQLITE_OK && pFile->eFileLock>=PENDING_LOCK ){\n      rc = afpSetLock(context->dbPath, pFile, PENDING_BYTE, 1, 0);\n    } \n    if( rc==SQLITE_OK && pFile->eFileLock>=RESERVED_LOCK && context->reserved ){\n      rc = afpSetLock(context->dbPath, pFile, RESERVED_BYTE, 1, 0);\n      if( !rc ){ \n        context->reserved = 0; \n      }\n    }\n    if( rc==SQLITE_OK && (eFileLock==SHARED_LOCK || pInode->nShared>1)){\n      pInode->eFileLock = SHARED_LOCK;\n    }\n  }\n  if( rc==SQLITE_OK && eFileLock==NO_LOCK ){\n\n    /* Decrement the shared lock counter.  Release the lock using an\n    ** OS call only when all threads in this same process have released\n    ** the lock.\n    */\n    unsigned long long sharedLockByte = SHARED_FIRST+pInode->sharedByte;\n    pInode->nShared--;\n    if( pInode->nShared==0 ){\n      SimulateIOErrorBenign(1);\n      SimulateIOError( h=(-1) )\n      SimulateIOErrorBenign(0);\n      if( !skipShared ){\n        rc = afpSetLock(context->dbPath, pFile, sharedLockByte, 1, 0);\n      }\n      if( !rc ){\n        pInode->eFileLock = NO_LOCK;\n        pFile->eFileLock = NO_LOCK;\n      }\n    }\n    if( rc==SQLITE_OK ){\n      pInode->nLock--;\n      assert( pInode->nLock>=0 );\n      if( pInode->nLock==0 ){\n        closePendingFds(pFile);\n      }\n    }\n  }\n  \n  unixLeaveMutex();\n  if( rc==SQLITE_OK ) pFile->eFileLock = eFileLock;\n  return rc;\n}\n\n/*\n** Close a file & cleanup AFP specific locking context \n*/\nstatic int afpClose(sqlite3_file *id) {\n  int rc = SQLITE_OK;\n  if( id ){\n    unixFile *pFile = (unixFile*)id;\n    afpUnlock(id, NO_LOCK);\n    unixEnterMutex();\n    if( pFile->pInode && pFile->pInode->nLock ){\n      /* If there are outstanding locks, do not actually close the file just\n      ** yet because that would clear those locks.  Instead, add the file\n      ** descriptor to pInode->aPending.  It will be automatically closed when\n      ** the last lock is cleared.\n      */\n      setPendingFd(pFile);\n    }\n    releaseInodeInfo(pFile);\n    sqlite3_free(pFile->lockingContext);\n    rc = closeUnixFile(id);\n    unixLeaveMutex();\n  }\n  return rc;\n}\n\n#endif /* defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE */\n/*\n** The code above is the AFP lock implementation.  The code is specific\n** to MacOSX and does not work on other unix platforms.  No alternative\n** is available.  If you don't compile for a mac, then the \"unix-afp\"\n** VFS is not available.\n**\n********************* End of the AFP lock implementation **********************\n******************************************************************************/\n\n/******************************************************************************\n*************************** Begin NFS Locking ********************************/\n\n#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE\n/*\n ** Lower the locking level on file descriptor pFile to eFileLock.  eFileLock\n ** must be either NO_LOCK or SHARED_LOCK.\n **\n ** If the locking level of the file descriptor is already at or below\n ** the requested locking level, this routine is a no-op.\n */\nstatic int nfsUnlock(sqlite3_file *id, int eFileLock){\n  return posixUnlock(id, eFileLock, 1);\n}\n\n#endif /* defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE */\n/*\n** The code above is the NFS lock implementation.  The code is specific\n** to MacOSX and does not work on other unix platforms.  No alternative\n** is available.  \n**\n********************* End of the NFS lock implementation **********************\n******************************************************************************/\n\n/******************************************************************************\n**************** Non-locking sqlite3_file methods *****************************\n**\n** The next division contains implementations for all methods of the \n** sqlite3_file object other than the locking methods.  The locking\n** methods were defined in divisions above (one locking method per\n** division).  Those methods that are common to all locking modes\n** are gather together into this division.\n*/\n\n/*\n** Seek to the offset passed as the second argument, then read cnt \n** bytes into pBuf. Return the number of bytes actually read.\n**\n** NB:  If you define USE_PREAD or USE_PREAD64, then it might also\n** be necessary to define _XOPEN_SOURCE to be 500.  This varies from\n** one system to another.  Since SQLite does not define USE_PREAD\n** any any form by default, we will not attempt to define _XOPEN_SOURCE.\n** See tickets #2741 and #2681.\n**\n** To avoid stomping the errno value on a failed read the lastErrno value\n** is set before returning.\n*/\nstatic int seekAndRead(unixFile *id, sqlite3_int64 offset, void *pBuf, int cnt){\n  int got;\n#if (!defined(USE_PREAD) && !defined(USE_PREAD64))\n  i64 newOffset;\n#endif\n  TIMER_START;\n#if defined(USE_PREAD)\n  do{ got = osPread(id->h, pBuf, cnt, offset); }while( got<0 && errno==EINTR );\n  SimulateIOError( got = -1 );\n#elif defined(USE_PREAD64)\n  do{ got = osPread64(id->h, pBuf, cnt, offset); }while( got<0 && errno==EINTR);\n  SimulateIOError( got = -1 );\n#else\n  newOffset = lseek(id->h, offset, SEEK_SET);\n  SimulateIOError( newOffset-- );\n  if( newOffset!=offset ){\n    if( newOffset == -1 ){\n      ((unixFile*)id)->lastErrno = errno;\n    }else{\n      ((unixFile*)id)->lastErrno = 0;\n    }\n    return -1;\n  }\n  do{ got = osRead(id->h, pBuf, cnt); }while( got<0 && errno==EINTR );\n#endif\n  TIMER_END;\n  if( got<0 ){\n    ((unixFile*)id)->lastErrno = errno;\n  }\n  OSTRACE((\"READ    %-3d %5d %7lld %llu\\n\", id->h, got, offset, TIMER_ELAPSED));\n  return got;\n}\n\n/*\n** Read data from a file into a buffer.  Return SQLITE_OK if all\n** bytes were read successfully and SQLITE_IOERR if anything goes\n** wrong.\n*/\nstatic int unixRead(\n  sqlite3_file *id, \n  void *pBuf, \n  int amt,\n  sqlite3_int64 offset\n){\n  unixFile *pFile = (unixFile *)id;\n  int got;\n  assert( id );\n\n  /* If this is a database file (not a journal, master-journal or temp\n  ** file), the bytes in the locking range should never be read or written. */\n#if 0\n  assert( pFile->pUnused==0\n       || offset>=PENDING_BYTE+512\n       || offset+amt<=PENDING_BYTE \n  );\n#endif\n\n  got = seekAndRead(pFile, offset, pBuf, amt);\n  if( got==amt ){\n    return SQLITE_OK;\n  }else if( got<0 ){\n    /* lastErrno set by seekAndRead */\n    return SQLITE_IOERR_READ;\n  }else{\n    pFile->lastErrno = 0; /* not a system error */\n    /* Unread parts of the buffer must be zero-filled */\n    memset(&((char*)pBuf)[got], 0, amt-got);\n    return SQLITE_IOERR_SHORT_READ;\n  }\n}\n\n/*\n** Seek to the offset in id->offset then read cnt bytes into pBuf.\n** Return the number of bytes actually read.  Update the offset.\n**\n** To avoid stomping the errno value on a failed write the lastErrno value\n** is set before returning.\n*/\nstatic int seekAndWrite(unixFile *id, i64 offset, const void *pBuf, int cnt){\n  int got;\n#if (!defined(USE_PREAD) && !defined(USE_PREAD64))\n  i64 newOffset;\n#endif\n  TIMER_START;\n#if defined(USE_PREAD)\n  do{ got = osPwrite(id->h, pBuf, cnt, offset); }while( got<0 && errno==EINTR );\n#elif defined(USE_PREAD64)\n  do{ got = osPwrite64(id->h, pBuf, cnt, offset);}while( got<0 && errno==EINTR);\n#else\n  newOffset = lseek(id->h, offset, SEEK_SET);\n  if( newOffset!=offset ){\n    if( newOffset == -1 ){\n      ((unixFile*)id)->lastErrno = errno;\n    }else{\n      ((unixFile*)id)->lastErrno = 0;\n    }\n    return -1;\n  }\n  do{ got = osWrite(id->h, pBuf, cnt); }while( got<0 && errno==EINTR );\n#endif\n  TIMER_END;\n  if( got<0 ){\n    ((unixFile*)id)->lastErrno = errno;\n  }\n\n  OSTRACE((\"WRITE   %-3d %5d %7lld %llu\\n\", id->h, got, offset, TIMER_ELAPSED));\n  return got;\n}\n\n\n/*\n** Write data from a buffer into a file.  Return SQLITE_OK on success\n** or some other error code on failure.\n*/\nstatic int unixWrite(\n  sqlite3_file *id, \n  const void *pBuf, \n  int amt,\n  sqlite3_int64 offset \n){\n  unixFile *pFile = (unixFile*)id;\n  int wrote = 0;\n  assert( id );\n  assert( amt>0 );\n\n  /* If this is a database file (not a journal, master-journal or temp\n  ** file), the bytes in the locking range should never be read or written. */\n#if 0\n  assert( pFile->pUnused==0\n       || offset>=PENDING_BYTE+512\n       || offset+amt<=PENDING_BYTE \n  );\n#endif\n\n#ifndef NDEBUG\n  /* If we are doing a normal write to a database file (as opposed to\n  ** doing a hot-journal rollback or a write to some file other than a\n  ** normal database file) then record the fact that the database\n  ** has changed.  If the transaction counter is modified, record that\n  ** fact too.\n  */\n  if( pFile->inNormalWrite ){\n    pFile->dbUpdate = 1;  /* The database has been modified */\n    if( offset<=24 && offset+amt>=27 ){\n      int rc;\n      char oldCntr[4];\n      SimulateIOErrorBenign(1);\n      rc = seekAndRead(pFile, 24, oldCntr, 4);\n      SimulateIOErrorBenign(0);\n      if( rc!=4 || memcmp(oldCntr, &((char*)pBuf)[24-offset], 4)!=0 ){\n        pFile->transCntrChng = 1;  /* The transaction counter has changed */\n      }\n    }\n  }\n#endif\n\n  while( amt>0 && (wrote = seekAndWrite(pFile, offset, pBuf, amt))>0 ){\n    amt -= wrote;\n    offset += wrote;\n    pBuf = &((char*)pBuf)[wrote];\n  }\n  SimulateIOError(( wrote=(-1), amt=1 ));\n  SimulateDiskfullError(( wrote=0, amt=1 ));\n\n  if( amt>0 ){\n    if( wrote<0 ){\n      /* lastErrno set by seekAndWrite */\n      return SQLITE_IOERR_WRITE;\n    }else{\n      pFile->lastErrno = 0; /* not a system error */\n      return SQLITE_FULL;\n    }\n  }\n\n  return SQLITE_OK;\n}\n\n#ifdef SQLITE_TEST\n/*\n** Count the number of fullsyncs and normal syncs.  This is used to test\n** that syncs and fullsyncs are occurring at the right times.\n*/\nSQLITE_API int sqlite3_sync_count = 0;\nSQLITE_API int sqlite3_fullsync_count = 0;\n#endif\n\n/*\n** We do not trust systems to provide a working fdatasync().  Some do.\n** Others do no.  To be safe, we will stick with the (slower) fsync().\n** If you know that your system does support fdatasync() correctly,\n** then simply compile with -Dfdatasync=fdatasync\n*/\n#if !defined(fdatasync) && !defined(__linux__)\n# define fdatasync fsync\n#endif\n\n/*\n** Define HAVE_FULLFSYNC to 0 or 1 depending on whether or not\n** the F_FULLFSYNC macro is defined.  F_FULLFSYNC is currently\n** only available on Mac OS X.  But that could change.\n*/\n#ifdef F_FULLFSYNC\n# define HAVE_FULLFSYNC 1\n#else\n# define HAVE_FULLFSYNC 0\n#endif\n\n\n/*\n** The fsync() system call does not work as advertised on many\n** unix systems.  The following procedure is an attempt to make\n** it work better.\n**\n** The SQLITE_NO_SYNC macro disables all fsync()s.  This is useful\n** for testing when we want to run through the test suite quickly.\n** You are strongly advised *not* to deploy with SQLITE_NO_SYNC\n** enabled, however, since with SQLITE_NO_SYNC enabled, an OS crash\n** or power failure will likely corrupt the database file.\n**\n** SQLite sets the dataOnly flag if the size of the file is unchanged.\n** The idea behind dataOnly is that it should only write the file content\n** to disk, not the inode.  We only set dataOnly if the file size is \n** unchanged since the file size is part of the inode.  However, \n** Ted Ts'o tells us that fdatasync() will also write the inode if the\n** file size has changed.  The only real difference between fdatasync()\n** and fsync(), Ted tells us, is that fdatasync() will not flush the\n** inode if the mtime or owner or other inode attributes have changed.\n** We only care about the file size, not the other file attributes, so\n** as far as SQLite is concerned, an fdatasync() is always adequate.\n** So, we always use fdatasync() if it is available, regardless of\n** the value of the dataOnly flag.\n*/\nstatic int full_fsync(int fd, int fullSync, int dataOnly){\n  int rc;\n\n  /* The following \"ifdef/elif/else/\" block has the same structure as\n  ** the one below. It is replicated here solely to avoid cluttering \n  ** up the real code with the UNUSED_PARAMETER() macros.\n  */\n#ifdef SQLITE_NO_SYNC\n  UNUSED_PARAMETER(fd);\n  UNUSED_PARAMETER(fullSync);\n  UNUSED_PARAMETER(dataOnly);\n#elif HAVE_FULLFSYNC\n  UNUSED_PARAMETER(dataOnly);\n#else\n  UNUSED_PARAMETER(fullSync);\n  UNUSED_PARAMETER(dataOnly);\n#endif\n\n  /* Record the number of times that we do a normal fsync() and \n  ** FULLSYNC.  This is used during testing to verify that this procedure\n  ** gets called with the correct arguments.\n  */\n#ifdef SQLITE_TEST\n  if( fullSync ) sqlite3_fullsync_count++;\n  sqlite3_sync_count++;\n#endif\n\n  /* If we compiled with the SQLITE_NO_SYNC flag, then syncing is a\n  ** no-op\n  */\n#ifdef SQLITE_NO_SYNC\n  rc = SQLITE_OK;\n#elif HAVE_FULLFSYNC\n  if( fullSync ){\n    rc = osFcntl(fd, F_FULLFSYNC, 0);\n  }else{\n    rc = 1;\n  }\n  /* If the FULLFSYNC failed, fall back to attempting an fsync().\n  ** It shouldn't be possible for fullfsync to fail on the local \n  ** file system (on OSX), so failure indicates that FULLFSYNC\n  ** isn't supported for this file system. So, attempt an fsync \n  ** and (for now) ignore the overhead of a superfluous fcntl call.  \n  ** It'd be better to detect fullfsync support once and avoid \n  ** the fcntl call every time sync is called.\n  */\n  if( rc ) rc = fsync(fd);\n\n#elif defined(__APPLE__)\n  /* fdatasync() on HFS+ doesn't yet flush the file size if it changed correctly\n  ** so currently we default to the macro that redefines fdatasync to fsync\n  */\n  rc = fsync(fd);\n#else \n  rc = fdatasync(fd);\n#if OS_VXWORKS\n  if( rc==-1 && errno==ENOTSUP ){\n    rc = fsync(fd);\n  }\n#endif /* OS_VXWORKS */\n#endif /* ifdef SQLITE_NO_SYNC elif HAVE_FULLFSYNC */\n\n  if( OS_VXWORKS && rc!= -1 ){\n    rc = 0;\n  }\n  return rc;\n}\n\n/*\n** Make sure all writes to a particular file are committed to disk.\n**\n** If dataOnly==0 then both the file itself and its metadata (file\n** size, access time, etc) are synced.  If dataOnly!=0 then only the\n** file data is synced.\n**\n** Under Unix, also make sure that the directory entry for the file\n** has been created by fsync-ing the directory that contains the file.\n** If we do not do this and we encounter a power failure, the directory\n** entry for the journal might not exist after we reboot.  The next\n** SQLite to access the file will not know that the journal exists (because\n** the directory entry for the journal was never created) and the transaction\n** will not roll back - possibly leading to database corruption.\n*/\nstatic int unixSync(sqlite3_file *id, int flags){\n  int rc;\n  unixFile *pFile = (unixFile*)id;\n\n  int isDataOnly = (flags&SQLITE_SYNC_DATAONLY);\n  int isFullsync = (flags&0x0F)==SQLITE_SYNC_FULL;\n\n  /* Check that one of SQLITE_SYNC_NORMAL or FULL was passed */\n  assert((flags&0x0F)==SQLITE_SYNC_NORMAL\n      || (flags&0x0F)==SQLITE_SYNC_FULL\n  );\n\n  /* Unix cannot, but some systems may return SQLITE_FULL from here. This\n  ** line is to test that doing so does not cause any problems.\n  */\n  SimulateDiskfullError( return SQLITE_FULL );\n\n  assert( pFile );\n  OSTRACE((\"SYNC    %-3d\\n\", pFile->h));\n  rc = full_fsync(pFile->h, isFullsync, isDataOnly);\n  SimulateIOError( rc=1 );\n  if( rc ){\n    pFile->lastErrno = errno;\n    return unixLogError(SQLITE_IOERR_FSYNC, \"full_fsync\", pFile->zPath);\n  }\n  if( pFile->dirfd>=0 ){\n    OSTRACE((\"DIRSYNC %-3d (have_fullfsync=%d fullsync=%d)\\n\", pFile->dirfd,\n            HAVE_FULLFSYNC, isFullsync));\n#ifndef SQLITE_DISABLE_DIRSYNC\n    /* The directory sync is only attempted if full_fsync is\n    ** turned off or unavailable.  If a full_fsync occurred above,\n    ** then the directory sync is superfluous.\n    */\n    if( (!HAVE_FULLFSYNC || !isFullsync) && full_fsync(pFile->dirfd,0,0) ){\n       /*\n       ** We have received multiple reports of fsync() returning\n       ** errors when applied to directories on certain file systems.\n       ** A failed directory sync is not a big deal.  So it seems\n       ** better to ignore the error.  Ticket #1657\n       */\n       /* pFile->lastErrno = errno; */\n       /* return SQLITE_IOERR; */\n    }\n#endif\n    /* Only need to sync once, so close the  directory when we are done */\n    robust_close(pFile, pFile->dirfd, __LINE__);\n    pFile->dirfd = -1;\n  }\n  return rc;\n}\n\n/*\n** Truncate an open file to a specified size\n*/\nstatic int unixTruncate(sqlite3_file *id, i64 nByte){\n  unixFile *pFile = (unixFile *)id;\n  int rc;\n  assert( pFile );\n  SimulateIOError( return SQLITE_IOERR_TRUNCATE );\n\n  /* If the user has configured a chunk-size for this file, truncate the\n  ** file so that it consists of an integer number of chunks (i.e. the\n  ** actual file size after the operation may be larger than the requested\n  ** size).\n  */\n  if( pFile->szChunk ){\n    nByte = ((nByte + pFile->szChunk - 1)/pFile->szChunk) * pFile->szChunk;\n  }\n\n  rc = robust_ftruncate(pFile->h, (off_t)nByte);\n  if( rc ){\n    pFile->lastErrno = errno;\n    return unixLogError(SQLITE_IOERR_TRUNCATE, \"ftruncate\", pFile->zPath);\n  }else{\n#ifndef NDEBUG\n    /* If we are doing a normal write to a database file (as opposed to\n    ** doing a hot-journal rollback or a write to some file other than a\n    ** normal database file) and we truncate the file to zero length,\n    ** that effectively updates the change counter.  This might happen\n    ** when restoring a database using the backup API from a zero-length\n    ** source.\n    */\n    if( pFile->inNormalWrite && nByte==0 ){\n      pFile->transCntrChng = 1;\n    }\n#endif\n\n    return SQLITE_OK;\n  }\n}\n\n/*\n** Determine the current size of a file in bytes\n*/\nstatic int unixFileSize(sqlite3_file *id, i64 *pSize){\n  int rc;\n  struct stat buf;\n  assert( id );\n  rc = osFstat(((unixFile*)id)->h, &buf);\n  SimulateIOError( rc=1 );\n  if( rc!=0 ){\n    ((unixFile*)id)->lastErrno = errno;\n    return SQLITE_IOERR_FSTAT;\n  }\n  *pSize = buf.st_size;\n\n  /* When opening a zero-size database, the findInodeInfo() procedure\n  ** writes a single byte into that file in order to work around a bug\n  ** in the OS-X msdos filesystem.  In order to avoid problems with upper\n  ** layers, we need to report this file size as zero even though it is\n  ** really 1.   Ticket #3260.\n  */\n  if( *pSize==1 ) *pSize = 0;\n\n\n  return SQLITE_OK;\n}\n\n#if SQLITE_ENABLE_LOCKING_STYLE && defined(__APPLE__)\n/*\n** Handler for proxy-locking file-control verbs.  Defined below in the\n** proxying locking division.\n*/\nstatic int proxyFileControl(sqlite3_file*,int,void*);\n#endif\n\n/* \n** This function is called to handle the SQLITE_FCNTL_SIZE_HINT \n** file-control operation.\n**\n** If the user has configured a chunk-size for this file, it could be\n** that the file needs to be extended at this point. Otherwise, the\n** SQLITE_FCNTL_SIZE_HINT operation is a no-op for Unix.\n*/\nstatic int fcntlSizeHint(unixFile *pFile, i64 nByte){\n  if( pFile->szChunk ){\n    i64 nSize;                    /* Required file size */\n    struct stat buf;              /* Used to hold return values of fstat() */\n   \n    if( osFstat(pFile->h, &buf) ) return SQLITE_IOERR_FSTAT;\n\n    nSize = ((nByte+pFile->szChunk-1) / pFile->szChunk) * pFile->szChunk;\n    if( nSize>(i64)buf.st_size ){\n#if defined(HAVE_POSIX_FALLOCATE) && HAVE_POSIX_FALLOCATE\n      int rc;\n      do{\n        rc = osFallocate(pFile->.h, buf.st_size, nSize-buf.st_size;\n      }while( rc<0 && errno=EINTR );\n      if( rc ) return SQLITE_IOERR_WRITE;\n#else\n      /* If the OS does not have posix_fallocate(), fake it. First use\n      ** ftruncate() to set the file size, then write a single byte to\n      ** the last byte in each block within the extended region. This\n      ** is the same technique used by glibc to implement posix_fallocate()\n      ** on systems that do not have a real fallocate() system call.\n      */\n      int nBlk = buf.st_blksize;  /* File-system block size */\n      i64 iWrite;                 /* Next offset to write to */\n      int nWrite;                 /* Return value from seekAndWrite() */\n\n      if( robust_ftruncate(pFile->h, nSize) ){\n        pFile->lastErrno = errno;\n        return unixLogError(SQLITE_IOERR_TRUNCATE, \"ftruncate\", pFile->zPath);\n      }\n      iWrite = ((buf.st_size + 2*nBlk - 1)/nBlk)*nBlk-1;\n      do {\n        nWrite = seekAndWrite(pFile, iWrite, \"\", 1);\n        iWrite += nBlk;\n      } while( nWrite==1 && iWrite<nSize );\n      if( nWrite!=1 ) return SQLITE_IOERR_WRITE;\n#endif\n    }\n  }\n\n  return SQLITE_OK;\n}\n\n/*\n** Information and control of an open file handle.\n*/\nstatic int unixFileControl(sqlite3_file *id, int op, void *pArg){\n  switch( op ){\n    case SQLITE_FCNTL_LOCKSTATE: {\n      *(int*)pArg = ((unixFile*)id)->eFileLock;\n      return SQLITE_OK;\n    }\n    case SQLITE_LAST_ERRNO: {\n      *(int*)pArg = ((unixFile*)id)->lastErrno;\n      return SQLITE_OK;\n    }\n    case SQLITE_FCNTL_CHUNK_SIZE: {\n      ((unixFile*)id)->szChunk = *(int *)pArg;\n      return SQLITE_OK;\n    }\n    case SQLITE_FCNTL_SIZE_HINT: {\n      return fcntlSizeHint((unixFile *)id, *(i64 *)pArg);\n    }\n#ifndef NDEBUG\n    /* The pager calls this method to signal that it has done\n    ** a rollback and that the database is therefore unchanged and\n    ** it hence it is OK for the transaction change counter to be\n    ** unchanged.\n    */\n    case SQLITE_FCNTL_DB_UNCHANGED: {\n      ((unixFile*)id)->dbUpdate = 0;\n      return SQLITE_OK;\n    }\n#endif\n#if SQLITE_ENABLE_LOCKING_STYLE && defined(__APPLE__)\n    case SQLITE_SET_LOCKPROXYFILE:\n    case SQLITE_GET_LOCKPROXYFILE: {\n      return proxyFileControl(id,op,pArg);\n    }\n#endif /* SQLITE_ENABLE_LOCKING_STYLE && defined(__APPLE__) */\n    case SQLITE_FCNTL_SYNC_OMITTED: {\n      return SQLITE_OK;  /* A no-op */\n    }\n  }\n  return SQLITE_NOTFOUND;\n}\n\n/*\n** Return the sector size in bytes of the underlying block device for\n** the specified file. This is almost always 512 bytes, but may be\n** larger for some devices.\n**\n** SQLite code assumes this function cannot fail. It also assumes that\n** if two files are created in the same file-system directory (i.e.\n** a database and its journal file) that the sector size will be the\n** same for both.\n*/\nstatic int unixSectorSize(sqlite3_file *NotUsed){\n  UNUSED_PARAMETER(NotUsed);\n  return SQLITE_DEFAULT_SECTOR_SIZE;\n}\n\n/*\n** Return the device characteristics for the file. This is always 0 for unix.\n*/\nstatic int unixDeviceCharacteristics(sqlite3_file *NotUsed){\n  UNUSED_PARAMETER(NotUsed);\n  return 0;\n}\n\n#ifndef SQLITE_OMIT_WAL\n\n\n/*\n** Object used to represent an shared memory buffer.  \n**\n** When multiple threads all reference the same wal-index, each thread\n** has its own unixShm object, but they all point to a single instance\n** of this unixShmNode object.  In other words, each wal-index is opened\n** only once per process.\n**\n** Each unixShmNode object is connected to a single unixInodeInfo object.\n** We could coalesce this object into unixInodeInfo, but that would mean\n** every open file that does not use shared memory (in other words, most\n** open files) would have to carry around this extra information.  So\n** the unixInodeInfo object contains a pointer to this unixShmNode object\n** and the unixShmNode object is created only when needed.\n**\n** unixMutexHeld() must be true when creating or destroying\n** this object or while reading or writing the following fields:\n**\n**      nRef\n**\n** The following fields are read-only after the object is created:\n** \n**      fid\n**      zFilename\n**\n** Either unixShmNode.mutex must be held or unixShmNode.nRef==0 and\n** unixMutexHeld() is true when reading or writing any other field\n** in this structure.\n*/\nstruct unixShmNode {\n  unixInodeInfo *pInode;     /* unixInodeInfo that owns this SHM node */\n  sqlite3_mutex *mutex;      /* Mutex to access this object */\n  char *zFilename;           /* Name of the mmapped file */\n  int h;                     /* Open file descriptor */\n  int szRegion;              /* Size of shared-memory regions */\n  int nRegion;               /* Size of array apRegion */\n  char **apRegion;           /* Array of mapped shared-memory regions */\n  int nRef;                  /* Number of unixShm objects pointing to this */\n  unixShm *pFirst;           /* All unixShm objects pointing to this */\n#ifdef SQLITE_DEBUG\n  u8 exclMask;               /* Mask of exclusive locks held */\n  u8 sharedMask;             /* Mask of shared locks held */\n  u8 nextShmId;              /* Next available unixShm.id value */\n#endif\n};\n\n/*\n** Structure used internally by this VFS to record the state of an\n** open shared memory connection.\n**\n** The following fields are initialized when this object is created and\n** are read-only thereafter:\n**\n**    unixShm.pFile\n**    unixShm.id\n**\n** All other fields are read/write.  The unixShm.pFile->mutex must be held\n** while accessing any read/write fields.\n*/\nstruct unixShm {\n  unixShmNode *pShmNode;     /* The underlying unixShmNode object */\n  unixShm *pNext;            /* Next unixShm with the same unixShmNode */\n  u8 hasMutex;               /* True if holding the unixShmNode mutex */\n  u16 sharedMask;            /* Mask of shared locks held */\n  u16 exclMask;              /* Mask of exclusive locks held */\n#ifdef SQLITE_DEBUG\n  u8 id;                     /* Id of this connection within its unixShmNode */\n#endif\n};\n\n/*\n** Constants used for locking\n*/\n#define UNIX_SHM_BASE   ((22+SQLITE_SHM_NLOCK)*4)         /* first lock byte */\n#define UNIX_SHM_DMS    (UNIX_SHM_BASE+SQLITE_SHM_NLOCK)  /* deadman switch */\n\n/*\n** Apply posix advisory locks for all bytes from ofst through ofst+n-1.\n**\n** Locks block if the mask is exactly UNIX_SHM_C and are non-blocking\n** otherwise.\n*/\nstatic int unixShmSystemLock(\n  unixShmNode *pShmNode, /* Apply locks to this open shared-memory segment */\n  int lockType,          /* F_UNLCK, F_RDLCK, or F_WRLCK */\n  int ofst,              /* First byte of the locking range */\n  int n                  /* Number of bytes to lock */\n){\n  struct flock f;       /* The posix advisory locking structure */\n  int rc = SQLITE_OK;   /* Result code form fcntl() */\n\n  /* Access to the unixShmNode object is serialized by the caller */\n  assert( sqlite3_mutex_held(pShmNode->mutex) || pShmNode->nRef==0 );\n\n  /* Shared locks never span more than one byte */\n  assert( n==1 || lockType!=F_RDLCK );\n\n  /* Locks are within range */\n  assert( n>=1 && n<SQLITE_SHM_NLOCK );\n\n  if( pShmNode->h>=0 ){\n    /* Initialize the locking parameters */\n    memset(&f, 0, sizeof(f));\n    f.l_type = lockType;\n    f.l_whence = SEEK_SET;\n    f.l_start = ofst;\n    f.l_len = n;\n\n    rc = osFcntl(pShmNode->h, F_SETLK, &f);\n    rc = (rc!=(-1)) ? SQLITE_OK : SQLITE_BUSY;\n  }\n\n  /* Update the global lock state and do debug tracing */\n#ifdef SQLITE_DEBUG\n  { u16 mask;\n  OSTRACE((\"SHM-LOCK \"));\n  mask = (1<<(ofst+n)) - (1<<ofst);\n  if( rc==SQLITE_OK ){\n    if( lockType==F_UNLCK ){\n      OSTRACE((\"unlock %d ok\", ofst));\n      pShmNode->exclMask &= ~mask;\n      pShmNode->sharedMask &= ~mask;\n    }else if( lockType==F_RDLCK ){\n      OSTRACE((\"read-lock %d ok\", ofst));\n      pShmNode->exclMask &= ~mask;\n      pShmNode->sharedMask |= mask;\n    }else{\n      assert( lockType==F_WRLCK );\n      OSTRACE((\"write-lock %d ok\", ofst));\n      pShmNode->exclMask |= mask;\n      pShmNode->sharedMask &= ~mask;\n    }\n  }else{\n    if( lockType==F_UNLCK ){\n      OSTRACE((\"unlock %d failed\", ofst));\n    }else if( lockType==F_RDLCK ){\n      OSTRACE((\"read-lock failed\"));\n    }else{\n      assert( lockType==F_WRLCK );\n      OSTRACE((\"write-lock %d failed\", ofst));\n    }\n  }\n  OSTRACE((\" - afterwards %03x,%03x\\n\",\n           pShmNode->sharedMask, pShmNode->exclMask));\n  }\n#endif\n\n  return rc;        \n}\n\n\n/*\n** Purge the unixShmNodeList list of all entries with unixShmNode.nRef==0.\n**\n** This is not a VFS shared-memory method; it is a utility function called\n** by VFS shared-memory methods.\n*/\nstatic void unixShmPurge(unixFile *pFd){\n  unixShmNode *p = pFd->pInode->pShmNode;\n  assert( unixMutexHeld() );\n  if( p && p->nRef==0 ){\n    int i;\n    assert( p->pInode==pFd->pInode );\n    if( p->mutex )\n      sqlite3_mutex_free(p->mutex);\n    for(i=0; i<p->nRegion; i++){\n      if( p->h>=0 ){\n        munmap(p->apRegion[i], p->szRegion);\n      }else{\n        sqlite3_free(p->apRegion[i]);\n      }\n    }\n    sqlite3_free(p->apRegion);\n    if( p->h>=0 ){\n      robust_close(pFd, p->h, __LINE__);\n      p->h = -1;\n    }\n    p->pInode->pShmNode = 0;\n    sqlite3_free(p);\n  }\n}\n\n/*\n** Open a shared-memory area associated with open database file pDbFd.  \n** This particular implementation uses mmapped files.\n**\n** The file used to implement shared-memory is in the same directory\n** as the open database file and has the same name as the open database\n** file with the \"-shm\" suffix added.  For example, if the database file\n** is \"/home/user1/config.db\" then the file that is created and mmapped\n** for shared memory will be called \"/home/user1/config.db-shm\".  \n**\n** Another approach to is to use files in /dev/shm or /dev/tmp or an\n** some other tmpfs mount. But if a file in a different directory\n** from the database file is used, then differing access permissions\n** or a chroot() might cause two different processes on the same\n** database to end up using different files for shared memory - \n** meaning that their memory would not really be shared - resulting\n** in database corruption.  Nevertheless, this tmpfs file usage\n** can be enabled at compile-time using -DSQLITE_SHM_DIRECTORY=\"/dev/shm\"\n** or the equivalent.  The use of the SQLITE_SHM_DIRECTORY compile-time\n** option results in an incompatible build of SQLite;  builds of SQLite\n** that with differing SQLITE_SHM_DIRECTORY settings attempt to use the\n** same database file at the same time, database corruption will likely\n** result. The SQLITE_SHM_DIRECTORY compile-time option is considered\n** \"unsupported\" and may go away in a future SQLite release.\n**\n** When opening a new shared-memory file, if no other instances of that\n** file are currently open, in this process or in other processes, then\n** the file must be truncated to zero length or have its header cleared.\n**\n** If the original database file (pDbFd) is using the \"unix-excl\" VFS\n** that means that an exclusive lock is held on the database file and\n** that no other processes are able to read or write the database.  In\n** that case, we do not really need shared memory.  No shared memory\n** file is created.  The shared memory will be simulated with heap memory.\n*/\nstatic int unixOpenSharedMemory(unixFile *pDbFd){\n  struct unixShm *p = 0;          /* The connection to be opened */\n  struct unixShmNode *pShmNode;   /* The underlying mmapped file */\n  int rc;                         /* Result code */\n  unixInodeInfo *pInode;          /* The inode of fd */\n  char *zShmFilename;             /* Name of the file used for SHM */\n  int nShmFilename;               /* Size of the SHM filename in bytes */\n\n  /* Allocate space for the new unixShm object. */\n  p = sqlite3_malloc( sizeof(*p) );\n  if( p==0 ) return SQLITE_NOMEM;\n  memset(p, 0, sizeof(*p));\n  assert( pDbFd->pShm==0 );\n\n  /* Check to see if a unixShmNode object already exists. Reuse an existing\n  ** one if present. Create a new one if necessary.\n  */\n  unixEnterMutex();\n  pInode = pDbFd->pInode;\n  pShmNode = pInode->pShmNode;\n  if( pShmNode==0 ){\n    struct stat sStat;                 /* fstat() info for database file */\n\n    /* Call fstat() to figure out the permissions on the database file. If\n    ** a new *-shm file is created, an attempt will be made to create it\n    ** with the same permissions. The actual permissions the file is created\n    ** with are subject to the current umask setting.\n    */\n    if( osFstat(pDbFd->h, &sStat) && pInode->bProcessLock==0 ){\n      rc = SQLITE_IOERR_FSTAT;\n      goto shm_open_err;\n    }\n\n#ifdef SQLITE_SHM_DIRECTORY\n    nShmFilename = sizeof(SQLITE_SHM_DIRECTORY) + 30;\n#else\n    nShmFilename = 5 + (int)strlen(pDbFd->zPath);\n#endif\n    pShmNode = sqlite3_malloc( sizeof(*pShmNode) + nShmFilename );\n    if( pShmNode==0 ){\n      rc = SQLITE_NOMEM;\n      goto shm_open_err;\n    }\n    memset(pShmNode, 0, sizeof(*pShmNode));\n    zShmFilename = pShmNode->zFilename = (char*)&pShmNode[1];\n#ifdef SQLITE_SHM_DIRECTORY\n    sqlite3_snprintf(nShmFilename, zShmFilename, \n                     SQLITE_SHM_DIRECTORY \"/sqlite-shm-%x-%x\",\n                     (u32)sStat.st_ino, (u32)sStat.st_dev);\n#else\n    sqlite3_snprintf(nShmFilename, zShmFilename, \"%s-shm\", pDbFd->zPath);\n#endif\n    pShmNode->h = -1;\n    pDbFd->pInode->pShmNode = pShmNode;\n    pShmNode->pInode = pDbFd->pInode;\n    pShmNode->mutex = sqlite3_mutex_alloc(SQLITE_MUTEX_FAST);\n    if( pShmNode->mutex==0 ){\n      rc = SQLITE_NOMEM;\n      goto shm_open_err;\n    }\n\n    if( pInode->bProcessLock==0 ){\n      pShmNode->h = robust_open(zShmFilename, O_RDWR|O_CREAT,\n                               (sStat.st_mode & 0777));\n      if( pShmNode->h<0 ){\n        rc = unixLogError(SQLITE_CANTOPEN_BKPT, \"open\", zShmFilename);\n        goto shm_open_err;\n      }\n  \n      /* Check to see if another process is holding the dead-man switch.\n      ** If not, truncate the file to zero length. \n      */\n      rc = SQLITE_OK;\n      if( unixShmSystemLock(pShmNode, F_WRLCK, UNIX_SHM_DMS, 1)==SQLITE_OK ){\n        if( robust_ftruncate(pShmNode->h, 0) ){\n          rc = unixLogError(SQLITE_IOERR_SHMOPEN, \"ftruncate\", zShmFilename);\n        }\n      }\n      if( rc==SQLITE_OK ){\n        rc = unixShmSystemLock(pShmNode, F_RDLCK, UNIX_SHM_DMS, 1);\n      }\n      if( rc ) goto shm_open_err;\n    }\n  }\n\n  /* Make the new connection a child of the unixShmNode */\n  p->pShmNode = pShmNode;\n#ifdef SQLITE_DEBUG\n  p->id = pShmNode->nextShmId++;\n#endif\n  pShmNode->nRef++;\n  pDbFd->pShm = p;\n  unixLeaveMutex();\n\n  /* The reference count on pShmNode has already been incremented under\n  ** the cover of the unixEnterMutex() mutex and the pointer from the\n  ** new (struct unixShm) object to the pShmNode has been set. All that is\n  ** left to do is to link the new object into the linked list starting\n  ** at pShmNode->pFirst. This must be done while holding the pShmNode->mutex \n  ** mutex.\n  */\n  sqlite3_mutex_enter(pShmNode->mutex);\n  p->pNext = pShmNode->pFirst;\n  pShmNode->pFirst = p;\n  sqlite3_mutex_leave(pShmNode->mutex);\n  return SQLITE_OK;\n\n  /* Jump here on any error */\nshm_open_err:\n  unixShmPurge(pDbFd);       /* This call frees pShmNode if required */\n  sqlite3_free(p);\n  unixLeaveMutex();\n  return rc;\n}\n\n/*\n** This function is called to obtain a pointer to region iRegion of the \n** shared-memory associated with the database file fd. Shared-memory regions \n** are numbered starting from zero. Each shared-memory region is szRegion \n** bytes in size.\n**\n** If an error occurs, an error code is returned and *pp is set to NULL.\n**\n** Otherwise, if the bExtend parameter is 0 and the requested shared-memory\n** region has not been allocated (by any client, including one running in a\n** separate process), then *pp is set to NULL and SQLITE_OK returned. If \n** bExtend is non-zero and the requested shared-memory region has not yet \n** been allocated, it is allocated by this function.\n**\n** If the shared-memory region has already been allocated or is allocated by\n** this call as described above, then it is mapped into this processes \n** address space (if it is not already), *pp is set to point to the mapped \n** memory and SQLITE_OK returned.\n*/\nstatic int unixShmMap(\n  sqlite3_file *fd,               /* Handle open on database file */\n  int iRegion,                    /* Region to retrieve */\n  int szRegion,                   /* Size of regions */\n  int bExtend,                    /* True to extend file if necessary */\n  void volatile **pp              /* OUT: Mapped memory */\n){\n  unixFile *pDbFd = (unixFile*)fd;\n  unixShm *p;\n  unixShmNode *pShmNode;\n  int rc = SQLITE_OK;\n\n  /* If the shared-memory file has not yet been opened, open it now. */\n  if( pDbFd->pShm==0 ){\n    rc = unixOpenSharedMemory(pDbFd);\n    if( rc!=SQLITE_OK ) return rc;\n  }\n\n  p = pDbFd->pShm;\n  pShmNode = p->pShmNode;\n  sqlite3_mutex_enter(pShmNode->mutex);\n  assert( szRegion==pShmNode->szRegion || pShmNode->nRegion==0 );\n  assert( pShmNode->pInode==pDbFd->pInode );\n  assert( pShmNode->h>=0 || pDbFd->pInode->bProcessLock==1 );\n  assert( pShmNode->h<0 || pDbFd->pInode->bProcessLock==0 );\n\n  if( pShmNode->nRegion<=iRegion ){\n    char **apNew;                      /* New apRegion[] array */\n    int nByte = (iRegion+1)*szRegion;  /* Minimum required file size */\n    struct stat sStat;                 /* Used by fstat() */\n\n    pShmNode->szRegion = szRegion;\n\n    if( pShmNode->h>=0 ){\n      /* The requested region is not mapped into this processes address space.\n      ** Check to see if it has been allocated (i.e. if the wal-index file is\n      ** large enough to contain the requested region).\n      */\n      if( osFstat(pShmNode->h, &sStat) ){\n        rc = SQLITE_IOERR_SHMSIZE;\n        goto shmpage_out;\n      }\n  \n      if( sStat.st_size<nByte ){\n        /* The requested memory region does not exist. If bExtend is set to\n        ** false, exit early. *pp will be set to NULL and SQLITE_OK returned.\n        **\n        ** Alternatively, if bExtend is true, use ftruncate() to allocate\n        ** the requested memory region.\n        */\n        if( !bExtend ) goto shmpage_out;\n        if( robust_ftruncate(pShmNode->h, nByte) ){\n          rc = unixLogError(SQLITE_IOERR_SHMSIZE, \"ftruncate\",\n                            pShmNode->zFilename);\n          goto shmpage_out;\n        }\n      }\n    }\n\n    /* Map the requested memory region into this processes address space. */\n    apNew = (char **)sqlite3_realloc(\n        pShmNode->apRegion, (iRegion+1)*sizeof(char *)\n    );\n    if( !apNew ){\n      rc = SQLITE_IOERR_NOMEM;\n      goto shmpage_out;\n    }\n    pShmNode->apRegion = apNew;\n    while(pShmNode->nRegion<=iRegion){\n      void *pMem;\n      if( pShmNode->h>=0 ){\n        pMem = mmap(0, szRegion, PROT_READ|PROT_WRITE, \n            MAP_SHARED, pShmNode->h, pShmNode->nRegion*szRegion\n        );\n        if( pMem==MAP_FAILED ){\n          rc = SQLITE_IOERR;\n          goto shmpage_out;\n        }\n      }else{\n        pMem = sqlite3_malloc(szRegion);\n        if( pMem==0 ){\n          rc = SQLITE_NOMEM;\n          goto shmpage_out;\n        }\n        memset(pMem, 0, szRegion);\n      }\n      pShmNode->apRegion[pShmNode->nRegion] = pMem;\n      pShmNode->nRegion++;\n    }\n  }\n\nshmpage_out:\n  if( pShmNode->nRegion>iRegion ){\n    *pp = pShmNode->apRegion[iRegion];\n  }else{\n    *pp = 0;\n  }\n  sqlite3_mutex_leave(pShmNode->mutex);\n  return rc;\n}\n\n/*\n** Change the lock state for a shared-memory segment.\n**\n** Note that the relationship between SHAREd and EXCLUSIVE locks is a little\n** different here than in posix.  In xShmLock(), one can go from unlocked\n** to shared and back or from unlocked to exclusive and back.  But one may\n** not go from shared to exclusive or from exclusive to shared.\n*/\nstatic int unixShmLock(\n  sqlite3_file *fd,          /* Database file holding the shared memory */\n  int ofst,                  /* First lock to acquire or release */\n  int n,                     /* Number of locks to acquire or release */\n  int flags                  /* What to do with the lock */\n){\n  unixFile *pDbFd = (unixFile*)fd;      /* Connection holding shared memory */\n  unixShm *p = pDbFd->pShm;             /* The shared memory being locked */\n  unixShm *pX;                          /* For looping over all siblings */\n  unixShmNode *pShmNode = p->pShmNode;  /* The underlying file iNode */\n  int rc = SQLITE_OK;                   /* Result code */\n  u16 mask;                             /* Mask of locks to take or release */\n\n  assert( pShmNode==pDbFd->pInode->pShmNode );\n  assert( pShmNode->pInode==pDbFd->pInode );\n  assert( ofst>=0 && ofst+n<=SQLITE_SHM_NLOCK );\n  assert( n>=1 );\n  assert( flags==(SQLITE_SHM_LOCK | SQLITE_SHM_SHARED)\n       || flags==(SQLITE_SHM_LOCK | SQLITE_SHM_EXCLUSIVE)\n       || flags==(SQLITE_SHM_UNLOCK | SQLITE_SHM_SHARED)\n       || flags==(SQLITE_SHM_UNLOCK | SQLITE_SHM_EXCLUSIVE) );\n  assert( n==1 || (flags & SQLITE_SHM_EXCLUSIVE)!=0 );\n  assert( pShmNode->h>=0 || pDbFd->pInode->bProcessLock==1 );\n  assert( pShmNode->h<0 || pDbFd->pInode->bProcessLock==0 );\n\n  mask = (1<<(ofst+n)) - (1<<ofst);\n  assert( n>1 || mask==(1<<ofst) );\n  sqlite3_mutex_enter(pShmNode->mutex);\n  if( flags & SQLITE_SHM_UNLOCK ){\n    u16 allMask = 0; /* Mask of locks held by siblings */\n\n    /* See if any siblings hold this same lock */\n    for(pX=pShmNode->pFirst; pX; pX=pX->pNext){\n      if( pX==p ) continue;\n      assert( (pX->exclMask & (p->exclMask|p->sharedMask))==0 );\n      allMask |= pX->sharedMask;\n    }\n\n    /* Unlock the system-level locks */\n    if( (mask & allMask)==0 ){\n      rc = unixShmSystemLock(pShmNode, F_UNLCK, ofst+UNIX_SHM_BASE, n);\n    }else{\n      rc = SQLITE_OK;\n    }\n\n    /* Undo the local locks */\n    if( rc==SQLITE_OK ){\n      p->exclMask &= ~mask;\n      p->sharedMask &= ~mask;\n    } \n  }else if( flags & SQLITE_SHM_SHARED ){\n    u16 allShared = 0;  /* Union of locks held by connections other than \"p\" */\n\n    /* Find out which shared locks are already held by sibling connections.\n    ** If any sibling already holds an exclusive lock, go ahead and return\n    ** SQLITE_BUSY.\n    */\n    for(pX=pShmNode->pFirst; pX; pX=pX->pNext){\n      if( (pX->exclMask & mask)!=0 ){\n        rc = SQLITE_BUSY;\n        break;\n      }\n      allShared |= pX->sharedMask;\n    }\n\n    /* Get shared locks at the system level, if necessary */\n    if( rc==SQLITE_OK ){\n      if( (allShared & mask)==0 ){\n        rc = unixShmSystemLock(pShmNode, F_RDLCK, ofst+UNIX_SHM_BASE, n);\n      }else{\n        rc = SQLITE_OK;\n      }\n    }\n\n    /* Get the local shared locks */\n    if( rc==SQLITE_OK ){\n      p->sharedMask |= mask;\n    }\n  }else{\n    /* Make sure no sibling connections hold locks that will block this\n    ** lock.  If any do, return SQLITE_BUSY right away.\n    */\n    for(pX=pShmNode->pFirst; pX; pX=pX->pNext){\n      if( (pX->exclMask & mask)!=0 || (pX->sharedMask & mask)!=0 ){\n        rc = SQLITE_BUSY;\n        break;\n      }\n    }\n  \n    /* Get the exclusive locks at the system level.  Then if successful\n    ** also mark the local connection as being locked.\n    */\n    if( rc==SQLITE_OK ){\n      rc = unixShmSystemLock(pShmNode, F_WRLCK, ofst+UNIX_SHM_BASE, n);\n      if( rc==SQLITE_OK ){\n        assert( (p->sharedMask & mask)==0 );\n        p->exclMask |= mask;\n      }\n    }\n  }\n  sqlite3_mutex_leave(pShmNode->mutex);\n  OSTRACE((\"SHM-LOCK shmid-%d, pid-%d got %03x,%03x\\n\",\n           p->id, getpid(), p->sharedMask, p->exclMask));\n  return rc;\n}\n\n/*\n** Implement a memory barrier or memory fence on shared memory.  \n**\n** All loads and stores begun before the barrier must complete before\n** any load or store begun after the barrier.\n*/\nstatic void unixShmBarrier(\n  sqlite3_file *fd                /* Database file holding the shared memory */\n){\n  UNUSED_PARAMETER(fd);\n  unixEnterMutex();\n  unixLeaveMutex();\n}\n\n/*\n** Close a connection to shared-memory.  Delete the underlying \n** storage if deleteFlag is true.\n**\n** If there is no shared memory associated with the connection then this\n** routine is a harmless no-op.\n*/\nstatic int unixShmUnmap(\n  sqlite3_file *fd,               /* The underlying database file */\n  int deleteFlag                  /* Delete shared-memory if true */\n){\n  unixShm *p;                     /* The connection to be closed */\n  unixShmNode *pShmNode;          /* The underlying shared-memory file */\n  unixShm **pp;                   /* For looping over sibling connections */\n  unixFile *pDbFd;                /* The underlying database file */\n\n  pDbFd = (unixFile*)fd;\n  p = pDbFd->pShm;\n  if( p==0 ) return SQLITE_OK;\n  pShmNode = p->pShmNode;\n\n  assert( pShmNode==pDbFd->pInode->pShmNode );\n  assert( pShmNode->pInode==pDbFd->pInode );\n\n  /* Remove connection p from the set of connections associated\n  ** with pShmNode */\n  sqlite3_mutex_enter(pShmNode->mutex);\n  for(pp=&pShmNode->pFirst; (*pp)!=p; pp = &(*pp)->pNext){}\n  *pp = p->pNext;\n\n  /* Free the connection p */\n  sqlite3_free(p);\n  pDbFd->pShm = 0;\n  sqlite3_mutex_leave(pShmNode->mutex);\n\n  /* If pShmNode->nRef has reached 0, then close the underlying\n  ** shared-memory file, too */\n  unixEnterMutex();\n  assert( pShmNode->nRef>0 );\n  pShmNode->nRef--;\n  if( pShmNode->nRef==0 ){\n    if( deleteFlag && pShmNode->h>=0 ) unlink(pShmNode->zFilename);\n    unixShmPurge(pDbFd);\n  }\n  unixLeaveMutex();\n\n  return SQLITE_OK;\n}\n\n\n#else\n# define unixShmMap     0\n# define unixShmLock    0\n# define unixShmBarrier 0\n# define unixShmUnmap   0\n#endif /* #ifndef SQLITE_OMIT_WAL */\n\n/*\n** Here ends the implementation of all sqlite3_file methods.\n**\n********************** End sqlite3_file Methods *******************************\n******************************************************************************/\n\n/*\n** This division contains definitions of sqlite3_io_methods objects that\n** implement various file locking strategies.  It also contains definitions\n** of \"finder\" functions.  A finder-function is used to locate the appropriate\n** sqlite3_io_methods object for a particular database file.  The pAppData\n** field of the sqlite3_vfs VFS objects are initialized to be pointers to\n** the correct finder-function for that VFS.\n**\n** Most finder functions return a pointer to a fixed sqlite3_io_methods\n** object.  The only interesting finder-function is autolockIoFinder, which\n** looks at the filesystem type and tries to guess the best locking\n** strategy from that.\n**\n** For finder-funtion F, two objects are created:\n**\n**    (1) The real finder-function named \"FImpt()\".\n**\n**    (2) A constant pointer to this function named just \"F\".\n**\n**\n** A pointer to the F pointer is used as the pAppData value for VFS\n** objects.  We have to do this instead of letting pAppData point\n** directly at the finder-function since C90 rules prevent a void*\n** from be cast into a function pointer.\n**\n**\n** Each instance of this macro generates two objects:\n**\n**   *  A constant sqlite3_io_methods object call METHOD that has locking\n**      methods CLOSE, LOCK, UNLOCK, CKRESLOCK.\n**\n**   *  An I/O method finder function called FINDER that returns a pointer\n**      to the METHOD object in the previous bullet.\n*/\n#define IOMETHODS(FINDER, METHOD, VERSION, CLOSE, LOCK, UNLOCK, CKLOCK)      \\\nstatic const sqlite3_io_methods METHOD = {                                   \\\n   VERSION,                    /* iVersion */                                \\\n   CLOSE,                      /* xClose */                                  \\\n   unixRead,                   /* xRead */                                   \\\n   unixWrite,                  /* xWrite */                                  \\\n   unixTruncate,               /* xTruncate */                               \\\n   unixSync,                   /* xSync */                                   \\\n   unixFileSize,               /* xFileSize */                               \\\n   LOCK,                       /* xLock */                                   \\\n   UNLOCK,                     /* xUnlock */                                 \\\n   CKLOCK,                     /* xCheckReservedLock */                      \\\n   unixFileControl,            /* xFileControl */                            \\\n   unixSectorSize,             /* xSectorSize */                             \\\n   unixDeviceCharacteristics,  /* xDeviceCapabilities */                     \\\n   unixShmMap,                 /* xShmMap */                                 \\\n   unixShmLock,                /* xShmLock */                                \\\n   unixShmBarrier,             /* xShmBarrier */                             \\\n   unixShmUnmap                /* xShmUnmap */                               \\\n};                                                                           \\\nstatic const sqlite3_io_methods *FINDER##Impl(const char *z, unixFile *p){   \\\n  UNUSED_PARAMETER(z); UNUSED_PARAMETER(p);                                  \\\n  return &METHOD;                                                            \\\n}                                                                            \\\nstatic const sqlite3_io_methods *(*const FINDER)(const char*,unixFile *p)    \\\n    = FINDER##Impl;\n\n/*\n** Here are all of the sqlite3_io_methods objects for each of the\n** locking strategies.  Functions that return pointers to these methods\n** are also created.\n*/\nIOMETHODS(\n  posixIoFinder,            /* Finder function name */\n  posixIoMethods,           /* sqlite3_io_methods object name */\n  2,                        /* shared memory is enabled */\n  unixClose,                /* xClose method */\n  unixLock,                 /* xLock method */\n  unixUnlock,               /* xUnlock method */\n  unixCheckReservedLock     /* xCheckReservedLock method */\n)\nIOMETHODS(\n  nolockIoFinder,           /* Finder function name */\n  nolockIoMethods,          /* sqlite3_io_methods object name */\n  1,                        /* shared memory is disabled */\n  nolockClose,              /* xClose method */\n  nolockLock,               /* xLock method */\n  nolockUnlock,             /* xUnlock method */\n  nolockCheckReservedLock   /* xCheckReservedLock method */\n)\nIOMETHODS(\n  dotlockIoFinder,          /* Finder function name */\n  dotlockIoMethods,         /* sqlite3_io_methods object name */\n  1,                        /* shared memory is disabled */\n  dotlockClose,             /* xClose method */\n  dotlockLock,              /* xLock method */\n  dotlockUnlock,            /* xUnlock method */\n  dotlockCheckReservedLock  /* xCheckReservedLock method */\n)\n\n#if SQLITE_ENABLE_LOCKING_STYLE && !OS_VXWORKS\nIOMETHODS(\n  flockIoFinder,            /* Finder function name */\n  flockIoMethods,           /* sqlite3_io_methods object name */\n  1,                        /* shared memory is disabled */\n  flockClose,               /* xClose method */\n  flockLock,                /* xLock method */\n  flockUnlock,              /* xUnlock method */\n  flockCheckReservedLock    /* xCheckReservedLock method */\n)\n#endif\n\n#if OS_VXWORKS\nIOMETHODS(\n  semIoFinder,              /* Finder function name */\n  semIoMethods,             /* sqlite3_io_methods object name */\n  1,                        /* shared memory is disabled */\n  semClose,                 /* xClose method */\n  semLock,                  /* xLock method */\n  semUnlock,                /* xUnlock method */\n  semCheckReservedLock      /* xCheckReservedLock method */\n)\n#endif\n\n#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE\nIOMETHODS(\n  afpIoFinder,              /* Finder function name */\n  afpIoMethods,             /* sqlite3_io_methods object name */\n  1,                        /* shared memory is disabled */\n  afpClose,                 /* xClose method */\n  afpLock,                  /* xLock method */\n  afpUnlock,                /* xUnlock method */\n  afpCheckReservedLock      /* xCheckReservedLock method */\n)\n#endif\n\n/*\n** The proxy locking method is a \"super-method\" in the sense that it\n** opens secondary file descriptors for the conch and lock files and\n** it uses proxy, dot-file, AFP, and flock() locking methods on those\n** secondary files.  For this reason, the division that implements\n** proxy locking is located much further down in the file.  But we need\n** to go ahead and define the sqlite3_io_methods and finder function\n** for proxy locking here.  So we forward declare the I/O methods.\n*/\n#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE\nstatic int proxyClose(sqlite3_file*);\nstatic int proxyLock(sqlite3_file*, int);\nstatic int proxyUnlock(sqlite3_file*, int);\nstatic int proxyCheckReservedLock(sqlite3_file*, int*);\nIOMETHODS(\n  proxyIoFinder,            /* Finder function name */\n  proxyIoMethods,           /* sqlite3_io_methods object name */\n  1,                        /* shared memory is disabled */\n  proxyClose,               /* xClose method */\n  proxyLock,                /* xLock method */\n  proxyUnlock,              /* xUnlock method */\n  proxyCheckReservedLock    /* xCheckReservedLock method */\n)\n#endif\n\n/* nfs lockd on OSX 10.3+ doesn't clear write locks when a read lock is set */\n#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE\nIOMETHODS(\n  nfsIoFinder,               /* Finder function name */\n  nfsIoMethods,              /* sqlite3_io_methods object name */\n  1,                         /* shared memory is disabled */\n  unixClose,                 /* xClose method */\n  unixLock,                  /* xLock method */\n  nfsUnlock,                 /* xUnlock method */\n  unixCheckReservedLock      /* xCheckReservedLock method */\n)\n#endif\n\n#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE\n/* \n** This \"finder\" function attempts to determine the best locking strategy \n** for the database file \"filePath\".  It then returns the sqlite3_io_methods\n** object that implements that strategy.\n**\n** This is for MacOSX only.\n*/\nstatic const sqlite3_io_methods *autolockIoFinderImpl(\n  const char *filePath,    /* name of the database file */\n  unixFile *pNew           /* open file object for the database file */\n){\n  static const struct Mapping {\n    const char *zFilesystem;              /* Filesystem type name */\n    const sqlite3_io_methods *pMethods;   /* Appropriate locking method */\n  } aMap[] = {\n    { \"hfs\",    &posixIoMethods },\n    { \"ufs\",    &posixIoMethods },\n    { \"afpfs\",  &afpIoMethods },\n    { \"smbfs\",  &afpIoMethods },\n    { \"webdav\", &nolockIoMethods },\n    { 0, 0 }\n  };\n  int i;\n  struct statfs fsInfo;\n  struct flock lockInfo;\n\n  if( !filePath ){\n    /* If filePath==NULL that means we are dealing with a transient file\n    ** that does not need to be locked. */\n    return &nolockIoMethods;\n  }\n  if( statfs(filePath, &fsInfo) != -1 ){\n    if( fsInfo.f_flags & MNT_RDONLY ){\n      return &nolockIoMethods;\n    }\n    for(i=0; aMap[i].zFilesystem; i++){\n      if( strcmp(fsInfo.f_fstypename, aMap[i].zFilesystem)==0 ){\n        return aMap[i].pMethods;\n      }\n    }\n  }\n\n  /* Default case. Handles, amongst others, \"nfs\".\n  ** Test byte-range lock using fcntl(). If the call succeeds, \n  ** assume that the file-system supports POSIX style locks. \n  */\n  lockInfo.l_len = 1;\n  lockInfo.l_start = 0;\n  lockInfo.l_whence = SEEK_SET;\n  lockInfo.l_type = F_RDLCK;\n  if( osFcntl(pNew->h, F_GETLK, &lockInfo)!=-1 ) {\n    if( strcmp(fsInfo.f_fstypename, \"nfs\")==0 ){\n      return &nfsIoMethods;\n    } else {\n      return &posixIoMethods;\n    }\n  }else{\n    return &dotlockIoMethods;\n  }\n}\nstatic const sqlite3_io_methods \n  *(*const autolockIoFinder)(const char*,unixFile*) = autolockIoFinderImpl;\n\n#endif /* defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE */\n\n#if OS_VXWORKS && SQLITE_ENABLE_LOCKING_STYLE\n/* \n** This \"finder\" function attempts to determine the best locking strategy \n** for the database file \"filePath\".  It then returns the sqlite3_io_methods\n** object that implements that strategy.\n**\n** This is for VXWorks only.\n*/\nstatic const sqlite3_io_methods *autolockIoFinderImpl(\n  const char *filePath,    /* name of the database file */\n  unixFile *pNew           /* the open file object */\n){\n  struct flock lockInfo;\n\n  if( !filePath ){\n    /* If filePath==NULL that means we are dealing with a transient file\n    ** that does not need to be locked. */\n    return &nolockIoMethods;\n  }\n\n  /* Test if fcntl() is supported and use POSIX style locks.\n  ** Otherwise fall back to the named semaphore method.\n  */\n  lockInfo.l_len = 1;\n  lockInfo.l_start = 0;\n  lockInfo.l_whence = SEEK_SET;\n  lockInfo.l_type = F_RDLCK;\n  if( osFcntl(pNew->h, F_GETLK, &lockInfo)!=-1 ) {\n    return &posixIoMethods;\n  }else{\n    return &semIoMethods;\n  }\n}\nstatic const sqlite3_io_methods \n  *(*const autolockIoFinder)(const char*,unixFile*) = autolockIoFinderImpl;\n\n#endif /* OS_VXWORKS && SQLITE_ENABLE_LOCKING_STYLE */\n\n/*\n** An abstract type for a pointer to a IO method finder function:\n*/\ntypedef const sqlite3_io_methods *(*finder_type)(const char*,unixFile*);\n\n\n/****************************************************************************\n**************************** sqlite3_vfs methods ****************************\n**\n** This division contains the implementation of methods on the\n** sqlite3_vfs object.\n*/\n\n/*\n** Initialize the contents of the unixFile structure pointed to by pId.\n*/\nstatic int fillInUnixFile(\n  sqlite3_vfs *pVfs,      /* Pointer to vfs object */\n  int h,                  /* Open file descriptor of file being opened */\n  int dirfd,              /* Directory file descriptor */\n  sqlite3_file *pId,      /* Write to the unixFile structure here */\n  const char *zFilename,  /* Name of the file being opened */\n  int noLock,             /* Omit locking if true */\n  int isDelete,           /* Delete on close if true */\n  int isReadOnly          /* True if the file is opened read-only */\n){\n  const sqlite3_io_methods *pLockingStyle;\n  unixFile *pNew = (unixFile *)pId;\n  int rc = SQLITE_OK;\n\n  assert( pNew->pInode==NULL );\n\n  /* Parameter isDelete is only used on vxworks. Express this explicitly \n  ** here to prevent compiler warnings about unused parameters.\n  */\n  UNUSED_PARAMETER(isDelete);\n\n  /* Usually the path zFilename should not be a relative pathname. The\n  ** exception is when opening the proxy \"conch\" file in builds that\n  ** include the special Apple locking styles.\n  */\n#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE\n  assert( zFilename==0 || zFilename[0]=='/' \n    || pVfs->pAppData==(void*)&autolockIoFinder );\n#else\n  assert( zFilename==0 || zFilename[0]=='/' );\n#endif\n\n  OSTRACE((\"OPEN    %-3d %s\\n\", h, zFilename));\n  pNew->h = h;\n  pNew->dirfd = dirfd;\n  pNew->zPath = zFilename;\n  if( memcmp(pVfs->zName,\"unix-excl\",10)==0 ){\n    pNew->ctrlFlags = UNIXFILE_EXCL;\n  }else{\n    pNew->ctrlFlags = 0;\n  }\n  if( isReadOnly ){\n    pNew->ctrlFlags |= UNIXFILE_RDONLY;\n  }\n\n#if OS_VXWORKS\n  pNew->pId = vxworksFindFileId(zFilename);\n  if( pNew->pId==0 ){\n    noLock = 1;\n    rc = SQLITE_NOMEM;\n  }\n#endif\n\n  if( noLock ){\n    pLockingStyle = &nolockIoMethods;\n  }else{\n    pLockingStyle = (**(finder_type*)pVfs->pAppData)(zFilename, pNew);\n#if SQLITE_ENABLE_LOCKING_STYLE\n    /* Cache zFilename in the locking context (AFP and dotlock override) for\n    ** proxyLock activation is possible (remote proxy is based on db name)\n    ** zFilename remains valid until file is closed, to support */\n    pNew->lockingContext = (void*)zFilename;\n#endif\n  }\n\n  if( pLockingStyle == &posixIoMethods\n#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE\n    || pLockingStyle == &nfsIoMethods\n#endif\n  ){\n    unixEnterMutex();\n    rc = findInodeInfo(pNew, &pNew->pInode);\n    if( rc!=SQLITE_OK ){\n      /* If an error occured in findInodeInfo(), close the file descriptor\n      ** immediately, before releasing the mutex. findInodeInfo() may fail\n      ** in two scenarios:\n      **\n      **   (a) A call to fstat() failed.\n      **   (b) A malloc failed.\n      **\n      ** Scenario (b) may only occur if the process is holding no other\n      ** file descriptors open on the same file. If there were other file\n      ** descriptors on this file, then no malloc would be required by\n      ** findInodeInfo(). If this is the case, it is quite safe to close\n      ** handle h - as it is guaranteed that no posix locks will be released\n      ** by doing so.\n      **\n      ** If scenario (a) caused the error then things are not so safe. The\n      ** implicit assumption here is that if fstat() fails, things are in\n      ** such bad shape that dropping a lock or two doesn't matter much.\n      */\n      robust_close(pNew, h, __LINE__);\n      h = -1;\n    }\n    unixLeaveMutex();\n  }\n\n#if SQLITE_ENABLE_LOCKING_STYLE && defined(__APPLE__)\n  else if( pLockingStyle == &afpIoMethods ){\n    /* AFP locking uses the file path so it needs to be included in\n    ** the afpLockingContext.\n    */\n    afpLockingContext *pCtx;\n    pNew->lockingContext = pCtx = sqlite3_malloc( sizeof(*pCtx) );\n    if( pCtx==0 ){\n      rc = SQLITE_NOMEM;\n    }else{\n      /* NB: zFilename exists and remains valid until the file is closed\n      ** according to requirement F11141.  So we do not need to make a\n      ** copy of the filename. */\n      pCtx->dbPath = zFilename;\n      pCtx->reserved = 0;\n      srandomdev();\n      unixEnterMutex();\n      rc = findInodeInfo(pNew, &pNew->pInode);\n      if( rc!=SQLITE_OK ){\n        sqlite3_free(pNew->lockingContext);\n        robust_close(pNew, h, __LINE__);\n        h = -1;\n      }\n      unixLeaveMutex();        \n    }\n  }\n#endif\n\n  else if( pLockingStyle == &dotlockIoMethods ){\n    /* Dotfile locking uses the file path so it needs to be included in\n    ** the dotlockLockingContext \n    */\n    char *zLockFile;\n    int nFilename;\n    nFilename = (int)strlen(zFilename) + 6;\n    zLockFile = (char *)sqlite3_malloc(nFilename);\n    if( zLockFile==0 ){\n      rc = SQLITE_NOMEM;\n    }else{\n      sqlite3_snprintf(nFilename, zLockFile, \"%s\" DOTLOCK_SUFFIX, zFilename);\n    }\n    pNew->lockingContext = zLockFile;\n  }\n\n#if OS_VXWORKS\n  else if( pLockingStyle == &semIoMethods ){\n    /* Named semaphore locking uses the file path so it needs to be\n    ** included in the semLockingContext\n    */\n    unixEnterMutex();\n    rc = findInodeInfo(pNew, &pNew->pInode);\n    if( (rc==SQLITE_OK) && (pNew->pInode->pSem==NULL) ){\n      char *zSemName = pNew->pInode->aSemName;\n      int n;\n      sqlite3_snprintf(MAX_PATHNAME, zSemName, \"/%s.sem\",\n                       pNew->pId->zCanonicalName);\n      for( n=1; zSemName[n]; n++ )\n        if( zSemName[n]=='/' ) zSemName[n] = '_';\n      pNew->pInode->pSem = sem_open(zSemName, O_CREAT, 0666, 1);\n      if( pNew->pInode->pSem == SEM_FAILED ){\n        rc = SQLITE_NOMEM;\n        pNew->pInode->aSemName[0] = '\\0';\n      }\n    }\n    unixLeaveMutex();\n  }\n#endif\n  \n  pNew->lastErrno = 0;\n#if OS_VXWORKS\n  if( rc!=SQLITE_OK ){\n    if( h>=0 ) robust_close(pNew, h, __LINE__);\n    h = -1;\n    unlink(zFilename);\n    isDelete = 0;\n  }\n  pNew->isDelete = isDelete;\n#endif\n  if( rc!=SQLITE_OK ){\n    if( dirfd>=0 ) robust_close(pNew, dirfd, __LINE__);\n    if( h>=0 ) robust_close(pNew, h, __LINE__);\n  }else{\n    pNew->pMethod = pLockingStyle;\n    OpenCounter(+1);\n  }\n  return rc;\n}\n\n/*\n** Open a file descriptor to the directory containing file zFilename.\n** If successful, *pFd is set to the opened file descriptor and\n** SQLITE_OK is returned. If an error occurs, either SQLITE_NOMEM\n** or SQLITE_CANTOPEN is returned and *pFd is set to an undefined\n** value.\n**\n** If SQLITE_OK is returned, the caller is responsible for closing\n** the file descriptor *pFd using close().\n*/\nstatic int openDirectory(const char *zFilename, int *pFd){\n  int ii;\n  int fd = -1;\n  char zDirname[MAX_PATHNAME+1];\n\n  sqlite3_snprintf(MAX_PATHNAME, zDirname, \"%s\", zFilename);\n  for(ii=(int)strlen(zDirname); ii>1 && zDirname[ii]!='/'; ii--);\n  if( ii>0 ){\n    zDirname[ii] = '\\0';\n    fd = robust_open(zDirname, O_RDONLY|O_BINARY, 0);\n    if( fd>=0 ){\n#ifdef FD_CLOEXEC\n      osFcntl(fd, F_SETFD, osFcntl(fd, F_GETFD, 0) | FD_CLOEXEC);\n#endif\n      OSTRACE((\"OPENDIR %-3d %s\\n\", fd, zDirname));\n    }\n  }\n  *pFd = fd;\n  return (fd>=0?SQLITE_OK:unixLogError(SQLITE_CANTOPEN_BKPT, \"open\", zDirname));\n}\n\n/*\n** Return the name of a directory in which to put temporary files.\n** If no suitable temporary file directory can be found, return NULL.\n*/\nstatic const char *unixTempFileDir(void){\n  static const char *azDirs[] = {\n     0,\n     0,\n     \"/var/tmp\",\n     \"/usr/tmp\",\n     \"/tmp\",\n     0        /* List terminator */\n  };\n  unsigned int i;\n  struct stat buf;\n  const char *zDir = 0;\n\n  azDirs[0] = sqlite3_temp_directory;\n  if( !azDirs[1] ) azDirs[1] = getenv(\"TMPDIR\");\n  for(i=0; i<sizeof(azDirs)/sizeof(azDirs[0]); zDir=azDirs[i++]){\n    if( zDir==0 ) continue;\n    if( osStat(zDir, &buf) ) continue;\n    if( !S_ISDIR(buf.st_mode) ) continue;\n    if( osAccess(zDir, 07) ) continue;\n    break;\n  }\n  return zDir;\n}\n\n/*\n** Create a temporary file name in zBuf.  zBuf must be allocated\n** by the calling process and must be big enough to hold at least\n** pVfs->mxPathname bytes.\n*/\nstatic int unixGetTempname(int nBuf, char *zBuf){\n  static const unsigned char zChars[] =\n    \"abcdefghijklmnopqrstuvwxyz\"\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    \"0123456789\";\n  unsigned int i, j;\n  const char *zDir;\n\n  /* It's odd to simulate an io-error here, but really this is just\n  ** using the io-error infrastructure to test that SQLite handles this\n  ** function failing. \n  */\n  SimulateIOError( return SQLITE_IOERR );\n\n  zDir = unixTempFileDir();\n  if( zDir==0 ) zDir = \".\";\n\n  /* Check that the output buffer is large enough for the temporary file \n  ** name. If it is not, return SQLITE_ERROR.\n  */\n  if( (strlen(zDir) + strlen(SQLITE_TEMP_FILE_PREFIX) + 17) >= (size_t)nBuf ){\n    return SQLITE_ERROR;\n  }\n\n  do{\n    sqlite3_snprintf(nBuf-17, zBuf, \"%s/\"SQLITE_TEMP_FILE_PREFIX, zDir);\n    j = (int)strlen(zBuf);\n    sqlite3_randomness(15, &zBuf[j]);\n    for(i=0; i<15; i++, j++){\n      zBuf[j] = (char)zChars[ ((unsigned char)zBuf[j])%(sizeof(zChars)-1) ];\n    }\n    zBuf[j] = 0;\n  }while( osAccess(zBuf,0)==0 );\n  return SQLITE_OK;\n}\n\n#if SQLITE_ENABLE_LOCKING_STYLE && defined(__APPLE__)\n/*\n** Routine to transform a unixFile into a proxy-locking unixFile.\n** Implementation in the proxy-lock division, but used by unixOpen()\n** if SQLITE_PREFER_PROXY_LOCKING is defined.\n*/\nstatic int proxyTransformUnixFile(unixFile*, const char*);\n#endif\n\n/*\n** Search for an unused file descriptor that was opened on the database \n** file (not a journal or master-journal file) identified by pathname\n** zPath with SQLITE_OPEN_XXX flags matching those passed as the second\n** argument to this function.\n**\n** Such a file descriptor may exist if a database connection was closed\n** but the associated file descriptor could not be closed because some\n** other file descriptor open on the same file is holding a file-lock.\n** Refer to comments in the unixClose() function and the lengthy comment\n** describing \"Posix Advisory Locking\" at the start of this file for \n** further details. Also, ticket #4018.\n**\n** If a suitable file descriptor is found, then it is returned. If no\n** such file descriptor is located, -1 is returned.\n*/\nstatic UnixUnusedFd *findReusableFd(const char *zPath, int flags){\n  UnixUnusedFd *pUnused = 0;\n\n  /* Do not search for an unused file descriptor on vxworks. Not because\n  ** vxworks would not benefit from the change (it might, we're not sure),\n  ** but because no way to test it is currently available. It is better \n  ** not to risk breaking vxworks support for the sake of such an obscure \n  ** feature.  */\n#if !OS_VXWORKS\n  struct stat sStat;                   /* Results of stat() call */\n\n  /* A stat() call may fail for various reasons. If this happens, it is\n  ** almost certain that an open() call on the same path will also fail.\n  ** For this reason, if an error occurs in the stat() call here, it is\n  ** ignored and -1 is returned. The caller will try to open a new file\n  ** descriptor on the same path, fail, and return an error to SQLite.\n  **\n  ** Even if a subsequent open() call does succeed, the consequences of\n  ** not searching for a resusable file descriptor are not dire.  */\n  if( 0==stat(zPath, &sStat) ){\n    unixInodeInfo *pInode;\n\n    unixEnterMutex();\n    pInode = inodeList;\n    while( pInode && (pInode->fileId.dev!=sStat.st_dev\n                     || pInode->fileId.ino!=sStat.st_ino) ){\n       pInode = pInode->pNext;\n    }\n    if( pInode ){\n      UnixUnusedFd **pp;\n      for(pp=&pInode->pUnused; *pp && (*pp)->flags!=flags; pp=&((*pp)->pNext));\n      pUnused = *pp;\n      if( pUnused ){\n        *pp = pUnused->pNext;\n      }\n    }\n    unixLeaveMutex();\n  }\n#endif    /* if !OS_VXWORKS */\n  return pUnused;\n}\n\n/*\n** This function is called by unixOpen() to determine the unix permissions\n** to create new files with. If no error occurs, then SQLITE_OK is returned\n** and a value suitable for passing as the third argument to open(2) is\n** written to *pMode. If an IO error occurs, an SQLite error code is \n** returned and the value of *pMode is not modified.\n**\n** If the file being opened is a temporary file, it is always created with\n** the octal permissions 0600 (read/writable by owner only). If the file\n** is a database or master journal file, it is created with the permissions \n** mask SQLITE_DEFAULT_FILE_PERMISSIONS.\n**\n** Finally, if the file being opened is a WAL or regular journal file, then \n** this function queries the file-system for the permissions on the \n** corresponding database file and sets *pMode to this value. Whenever \n** possible, WAL and journal files are created using the same permissions \n** as the associated database file.\n*/\nstatic int findCreateFileMode(\n  const char *zPath,              /* Path of file (possibly) being created */\n  int flags,                      /* Flags passed as 4th argument to xOpen() */\n  mode_t *pMode                   /* OUT: Permissions to open file with */\n){\n  int rc = SQLITE_OK;             /* Return Code */\n  if( flags & (SQLITE_OPEN_WAL|SQLITE_OPEN_MAIN_JOURNAL) ){\n    char zDb[MAX_PATHNAME+1];     /* Database file path */\n    int nDb;                      /* Number of valid bytes in zDb */\n    struct stat sStat;            /* Output of stat() on database file */\n\n    /* zPath is a path to a WAL or journal file. The following block derives\n    ** the path to the associated database file from zPath. This block handles\n    ** the following naming conventions:\n    **\n    **   \"<path to db>-journal\"\n    **   \"<path to db>-wal\"\n    **   \"<path to db>-journal-NNNN\"\n    **   \"<path to db>-wal-NNNN\"\n    **\n    ** where NNNN is a 4 digit decimal number. The NNNN naming schemes are \n    ** used by the test_multiplex.c module.\n    */\n    nDb = sqlite3Strlen30(zPath) - 1; \n    while( nDb>0 && zPath[nDb]!='l' ) nDb--;\n    nDb -= ((flags & SQLITE_OPEN_WAL) ? 3 : 7);\n    memcpy(zDb, zPath, nDb);\n    zDb[nDb] = '\\0';\n\n    if( 0==stat(zDb, &sStat) ){\n      *pMode = sStat.st_mode & 0777;\n    }else{\n      rc = SQLITE_IOERR_FSTAT;\n    }\n  }else if( flags & SQLITE_OPEN_DELETEONCLOSE ){\n    *pMode = 0600;\n  }else{\n    *pMode = SQLITE_DEFAULT_FILE_PERMISSIONS;\n  }\n  return rc;\n}\n\n/*\n** Open the file zPath.\n** \n** Previously, the SQLite OS layer used three functions in place of this\n** one:\n**\n**     sqlite3OsOpenReadWrite();\n**     sqlite3OsOpenReadOnly();\n**     sqlite3OsOpenExclusive();\n**\n** These calls correspond to the following combinations of flags:\n**\n**     ReadWrite() ->     (READWRITE | CREATE)\n**     ReadOnly()  ->     (READONLY) \n**     OpenExclusive() -> (READWRITE | CREATE | EXCLUSIVE)\n**\n** The old OpenExclusive() accepted a boolean argument - \"delFlag\". If\n** true, the file was configured to be automatically deleted when the\n** file handle closed. To achieve the same effect using this new \n** interface, add the DELETEONCLOSE flag to those specified above for \n** OpenExclusive().\n*/\nstatic int unixOpen(\n  sqlite3_vfs *pVfs,           /* The VFS for which this is the xOpen method */\n  const char *zPath,           /* Pathname of file to be opened */\n  sqlite3_file *pFile,         /* The file descriptor to be filled in */\n  int flags,                   /* Input flags to control the opening */\n  int *pOutFlags               /* Output flags returned to SQLite core */\n){\n  unixFile *p = (unixFile *)pFile;\n  int fd = -1;                   /* File descriptor returned by open() */\n  int dirfd = -1;                /* Directory file descriptor */\n  int openFlags = 0;             /* Flags to pass to open() */\n  int eType = flags&0xFFFFFF00;  /* Type of file to open */\n  int noLock;                    /* True to omit locking primitives */\n  int rc = SQLITE_OK;            /* Function Return Code */\n\n  int isExclusive  = (flags & SQLITE_OPEN_EXCLUSIVE);\n  int isDelete     = (flags & SQLITE_OPEN_DELETEONCLOSE);\n  int isCreate     = (flags & SQLITE_OPEN_CREATE);\n  int isReadonly   = (flags & SQLITE_OPEN_READONLY);\n  int isReadWrite  = (flags & SQLITE_OPEN_READWRITE);\n#if SQLITE_ENABLE_LOCKING_STYLE\n  int isAutoProxy  = (flags & SQLITE_OPEN_AUTOPROXY);\n#endif\n\n  /* If creating a master or main-file journal, this function will open\n  ** a file-descriptor on the directory too. The first time unixSync()\n  ** is called the directory file descriptor will be fsync()ed and close()d.\n  */\n  int isOpenDirectory = (isCreate && (\n        eType==SQLITE_OPEN_MASTER_JOURNAL \n     || eType==SQLITE_OPEN_MAIN_JOURNAL \n     || eType==SQLITE_OPEN_WAL\n  ));\n\n  /* If argument zPath is a NULL pointer, this function is required to open\n  ** a temporary file. Use this buffer to store the file name in.\n  */\n  char zTmpname[MAX_PATHNAME+1];\n  const char *zName = zPath;\n\n  /* Check the following statements are true: \n  **\n  **   (a) Exactly one of the READWRITE and READONLY flags must be set, and \n  **   (b) if CREATE is set, then READWRITE must also be set, and\n  **   (c) if EXCLUSIVE is set, then CREATE must also be set.\n  **   (d) if DELETEONCLOSE is set, then CREATE must also be set.\n  */\n  assert((isReadonly==0 || isReadWrite==0) && (isReadWrite || isReadonly));\n  assert(isCreate==0 || isReadWrite);\n  assert(isExclusive==0 || isCreate);\n  assert(isDelete==0 || isCreate);\n\n  /* The main DB, main journal, WAL file and master journal are never \n  ** automatically deleted. Nor are they ever temporary files.  */\n  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_MAIN_DB );\n  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_MAIN_JOURNAL );\n  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_MASTER_JOURNAL );\n  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_WAL );\n\n  /* Assert that the upper layer has set one of the \"file-type\" flags. */\n  assert( eType==SQLITE_OPEN_MAIN_DB      || eType==SQLITE_OPEN_TEMP_DB \n       || eType==SQLITE_OPEN_MAIN_JOURNAL || eType==SQLITE_OPEN_TEMP_JOURNAL \n       || eType==SQLITE_OPEN_SUBJOURNAL   || eType==SQLITE_OPEN_MASTER_JOURNAL \n       || eType==SQLITE_OPEN_TRANSIENT_DB || eType==SQLITE_OPEN_WAL\n  );\n\n  memset(p, 0, sizeof(unixFile));\n\n  if( eType==SQLITE_OPEN_MAIN_DB ){\n    UnixUnusedFd *pUnused;\n    pUnused = findReusableFd(zName, flags);\n    if( pUnused ){\n      fd = pUnused->fd;\n    }else{\n      pUnused = sqlite3_malloc(sizeof(*pUnused));\n      if( !pUnused ){\n        return SQLITE_NOMEM;\n      }\n    }\n    p->pUnused = pUnused;\n  }else if( !zName ){\n    /* If zName is NULL, the upper layer is requesting a temp file. */\n    assert(isDelete && !isOpenDirectory);\n    rc = unixGetTempname(MAX_PATHNAME+1, zTmpname);\n    if( rc!=SQLITE_OK ){\n      return rc;\n    }\n    zName = zTmpname;\n  }\n\n  /* Determine the value of the flags parameter passed to POSIX function\n  ** open(). These must be calculated even if open() is not called, as\n  ** they may be stored as part of the file handle and used by the \n  ** 'conch file' locking functions later on.  */\n  if( isReadonly )  openFlags |= O_RDONLY;\n  if( isReadWrite ) openFlags |= O_RDWR;\n  if( isCreate )    openFlags |= O_CREAT;\n  if( isExclusive ) openFlags |= (O_EXCL|O_NOFOLLOW);\n  openFlags |= (O_LARGEFILE|O_BINARY);\n\n  if( fd<0 ){\n    mode_t openMode;              /* Permissions to create file with */\n    rc = findCreateFileMode(zName, flags, &openMode);\n    if( rc!=SQLITE_OK ){\n      assert( !p->pUnused );\n      assert( eType==SQLITE_OPEN_WAL || eType==SQLITE_OPEN_MAIN_JOURNAL );\n      return rc;\n    }\n    fd = robust_open(zName, openFlags, openMode);\n    OSTRACE((\"OPENX   %-3d %s 0%o\\n\", fd, zName, openFlags));\n    if( fd<0 && errno!=EISDIR && isReadWrite && !isExclusive ){\n      /* Failed to open the file for read/write access. Try read-only. */\n      flags &= ~(SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE);\n      openFlags &= ~(O_RDWR|O_CREAT);\n      flags |= SQLITE_OPEN_READONLY;\n      openFlags |= O_RDONLY;\n      isReadonly = 1;\n      fd = robust_open(zName, openFlags, openMode);\n    }\n    if( fd<0 ){\n      rc = unixLogError(SQLITE_CANTOPEN_BKPT, \"open\", zName);\n      goto open_finished;\n    }\n  }\n  assert( fd>=0 );\n  if( pOutFlags ){\n    *pOutFlags = flags;\n  }\n\n  if( p->pUnused ){\n    p->pUnused->fd = fd;\n    p->pUnused->flags = flags;\n  }\n\n  if( isDelete ){\n#if OS_VXWORKS\n    zPath = zName;\n#else\n    unlink(zName);\n#endif\n  }\n#if SQLITE_ENABLE_LOCKING_STYLE\n  else{\n    p->openFlags = openFlags;\n  }\n#endif\n\n  if( isOpenDirectory ){\n    rc = openDirectory(zPath, &dirfd);\n    if( rc!=SQLITE_OK ){\n      /* It is safe to close fd at this point, because it is guaranteed not\n      ** to be open on a database file. If it were open on a database file,\n      ** it would not be safe to close as this would release any locks held\n      ** on the file by this process.  */\n      assert( eType!=SQLITE_OPEN_MAIN_DB );\n      robust_close(p, fd, __LINE__);\n      goto open_finished;\n    }\n  }\n\n#ifdef FD_CLOEXEC\n  osFcntl(fd, F_SETFD, osFcntl(fd, F_GETFD, 0) | FD_CLOEXEC);\n#endif\n\n  noLock = eType!=SQLITE_OPEN_MAIN_DB;\n\n  \n#if defined(__APPLE__) || SQLITE_ENABLE_LOCKING_STYLE\n  struct statfs fsInfo;\n  if( fstatfs(fd, &fsInfo) == -1 ){\n    ((unixFile*)pFile)->lastErrno = errno;\n    if( dirfd>=0 ) robust_close(p, dirfd, __LINE__);\n    robust_close(p, fd, __LINE__);\n    return SQLITE_IOERR_ACCESS;\n  }\n  if (0 == strncmp(\"msdos\", fsInfo.f_fstypename, 5)) {\n    ((unixFile*)pFile)->fsFlags |= SQLITE_FSFLAGS_IS_MSDOS;\n  }\n#endif\n  \n#if SQLITE_ENABLE_LOCKING_STYLE\n#if SQLITE_PREFER_PROXY_LOCKING\n  isAutoProxy = 1;\n#endif\n  if( isAutoProxy && (zPath!=NULL) && (!noLock) && pVfs->xOpen ){\n    char *envforce = getenv(\"SQLITE_FORCE_PROXY_LOCKING\");\n    int useProxy = 0;\n\n    /* SQLITE_FORCE_PROXY_LOCKING==1 means force always use proxy, 0 means \n    ** never use proxy, NULL means use proxy for non-local files only.  */\n    if( envforce!=NULL ){\n      useProxy = atoi(envforce)>0;\n    }else{\n      struct statfs fsInfo;\n      if( statfs(zPath, &fsInfo) == -1 ){\n        /* In theory, the close(fd) call is sub-optimal. If the file opened\n        ** with fd is a database file, and there are other connections open\n        ** on that file that are currently holding advisory locks on it,\n        ** then the call to close() will cancel those locks. In practice,\n        ** we're assuming that statfs() doesn't fail very often. At least\n        ** not while other file descriptors opened by the same process on\n        ** the same file are working.  */\n        p->lastErrno = errno;\n        if( dirfd>=0 ){\n          robust_close(p, dirfd, __LINE__);\n        }\n        robust_close(p, fd, __LINE__);\n        rc = SQLITE_IOERR_ACCESS;\n        goto open_finished;\n      }\n      useProxy = !(fsInfo.f_flags&MNT_LOCAL);\n    }\n    if( useProxy ){\n      rc = fillInUnixFile(pVfs, fd, dirfd, pFile, zPath, noLock,\n                          isDelete, isReadonly);\n      if( rc==SQLITE_OK ){\n        rc = proxyTransformUnixFile((unixFile*)pFile, \":auto:\");\n        if( rc!=SQLITE_OK ){\n          /* Use unixClose to clean up the resources added in fillInUnixFile \n          ** and clear all the structure's references.  Specifically, \n          ** pFile->pMethods will be NULL so sqlite3OsClose will be a no-op \n          */\n          unixClose(pFile);\n          return rc;\n        }\n      }\n      goto open_finished;\n    }\n  }\n#endif\n  \n  rc = fillInUnixFile(pVfs, fd, dirfd, pFile, zPath, noLock,\n                      isDelete, isReadonly);\nopen_finished:\n  if( rc!=SQLITE_OK ){\n    sqlite3_free(p->pUnused);\n  }\n  return rc;\n}\n\n\n/*\n** Delete the file at zPath. If the dirSync argument is true, fsync()\n** the directory after deleting the file.\n*/\nstatic int unixDelete(\n  sqlite3_vfs *NotUsed,     /* VFS containing this as the xDelete method */\n  const char *zPath,        /* Name of file to be deleted */\n  int dirSync               /* If true, fsync() directory after deleting file */\n){\n  int rc = SQLITE_OK;\n  UNUSED_PARAMETER(NotUsed);\n  SimulateIOError(return SQLITE_IOERR_DELETE);\n  if( unlink(zPath)==(-1) && errno!=ENOENT ){\n    return unixLogError(SQLITE_IOERR_DELETE, \"unlink\", zPath);\n  }\n#ifndef SQLITE_DISABLE_DIRSYNC\n  if( dirSync ){\n    int fd;\n    rc = openDirectory(zPath, &fd);\n    if( rc==SQLITE_OK ){\n#if OS_VXWORKS\n      if( fsync(fd)==-1 )\n#else\n      if( fsync(fd) )\n#endif\n      {\n        rc = unixLogError(SQLITE_IOERR_DIR_FSYNC, \"fsync\", zPath);\n      }\n      robust_close(0, fd, __LINE__);\n    }\n  }\n#endif\n  return rc;\n}\n\n/*\n** Test the existance of or access permissions of file zPath. The\n** test performed depends on the value of flags:\n**\n**     SQLITE_ACCESS_EXISTS: Return 1 if the file exists\n**     SQLITE_ACCESS_READWRITE: Return 1 if the file is read and writable.\n**     SQLITE_ACCESS_READONLY: Return 1 if the file is readable.\n**\n** Otherwise return 0.\n*/\nstatic int unixAccess(\n  sqlite3_vfs *NotUsed,   /* The VFS containing this xAccess method */\n  const char *zPath,      /* Path of the file to examine */\n  int flags,              /* What do we want to learn about the zPath file? */\n  int *pResOut            /* Write result boolean here */\n){\n  int amode = 0;\n  UNUSED_PARAMETER(NotUsed);\n  SimulateIOError( return SQLITE_IOERR_ACCESS; );\n  switch( flags ){\n    case SQLITE_ACCESS_EXISTS:\n      amode = F_OK;\n      break;\n    case SQLITE_ACCESS_READWRITE:\n      amode = W_OK|R_OK;\n      break;\n    case SQLITE_ACCESS_READ:\n      amode = R_OK;\n      break;\n\n    default:\n      assert(!\"Invalid flags argument\");\n  }\n  *pResOut = (osAccess(zPath, amode)==0);\n  if( flags==SQLITE_ACCESS_EXISTS && *pResOut ){\n    struct stat buf;\n    if( 0==stat(zPath, &buf) && buf.st_size==0 ){\n      *pResOut = 0;\n    }\n  }\n  return SQLITE_OK;\n}\n\n\n/*\n** Turn a relative pathname into a full pathname. The relative path\n** is stored as a nul-terminated string in the buffer pointed to by\n** zPath. \n**\n** zOut points to a buffer of at least sqlite3_vfs.mxPathname bytes \n** (in this case, MAX_PATHNAME bytes). The full-path is written to\n** this buffer before returning.\n*/\nstatic int unixFullPathname(\n  sqlite3_vfs *pVfs,            /* Pointer to vfs object */\n  const char *zPath,            /* Possibly relative input path */\n  int nOut,                     /* Size of output buffer in bytes */\n  char *zOut                    /* Output buffer */\n){\n\n  /* It's odd to simulate an io-error here, but really this is just\n  ** using the io-error infrastructure to test that SQLite handles this\n  ** function failing. This function could fail if, for example, the\n  ** current working directory has been unlinked.\n  */\n  SimulateIOError( return SQLITE_ERROR );\n\n  assert( pVfs->mxPathname==MAX_PATHNAME );\n  UNUSED_PARAMETER(pVfs);\n\n  zOut[nOut-1] = '\\0';\n  if( zPath[0]=='/' ){\n    sqlite3_snprintf(nOut, zOut, \"%s\", zPath);\n  }else{\n    int nCwd;\n    if( osGetcwd(zOut, nOut-1)==0 ){\n      return unixLogError(SQLITE_CANTOPEN_BKPT, \"getcwd\", zPath);\n    }\n    nCwd = (int)strlen(zOut);\n    sqlite3_snprintf(nOut-nCwd, &zOut[nCwd], \"/%s\", zPath);\n  }\n  return SQLITE_OK;\n}\n\n\n#ifndef SQLITE_OMIT_LOAD_EXTENSION\n/*\n** Interfaces for opening a shared library, finding entry points\n** within the shared library, and closing the shared library.\n*/\n#include <dlfcn.h>\nstatic void *unixDlOpen(sqlite3_vfs *NotUsed, const char *zFilename){\n  UNUSED_PARAMETER(NotUsed);\n  return dlopen(zFilename, RTLD_NOW | RTLD_GLOBAL);\n}\n\n/*\n** SQLite calls this function immediately after a call to unixDlSym() or\n** unixDlOpen() fails (returns a null pointer). If a more detailed error\n** message is available, it is written to zBufOut. If no error message\n** is available, zBufOut is left unmodified and SQLite uses a default\n** error message.\n*/\nstatic void unixDlError(sqlite3_vfs *NotUsed, int nBuf, char *zBufOut){\n  const char *zErr;\n  UNUSED_PARAMETER(NotUsed);\n  unixEnterMutex();\n  zErr = dlerror();\n  if( zErr ){\n    sqlite3_snprintf(nBuf, zBufOut, \"%s\", zErr);\n  }\n  unixLeaveMutex();\n}\nstatic void (*unixDlSym(sqlite3_vfs *NotUsed, void *p, const char*zSym))(void){\n  /* \n  ** GCC with -pedantic-errors says that C90 does not allow a void* to be\n  ** cast into a pointer to a function.  And yet the library dlsym() routine\n  ** returns a void* which is really a pointer to a function.  So how do we\n  ** use dlsym() with -pedantic-errors?\n  **\n  ** Variable x below is defined to be a pointer to a function taking\n  ** parameters void* and const char* and returning a pointer to a function.\n  ** We initialize x by assigning it a pointer to the dlsym() function.\n  ** (That assignment requires a cast.)  Then we call the function that\n  ** x points to.  \n  **\n  ** This work-around is unlikely to work correctly on any system where\n  ** you really cannot cast a function pointer into void*.  But then, on the\n  ** other hand, dlsym() will not work on such a system either, so we have\n  ** not really lost anything.\n  */\n  void (*(*x)(void*,const char*))(void);\n  UNUSED_PARAMETER(NotUsed);\n  x = (void(*(*)(void*,const char*))(void))dlsym;\n  return (*x)(p, zSym);\n}\nstatic void unixDlClose(sqlite3_vfs *NotUsed, void *pHandle){\n  UNUSED_PARAMETER(NotUsed);\n  dlclose(pHandle);\n}\n#else /* if SQLITE_OMIT_LOAD_EXTENSION is defined: */\n  #define unixDlOpen  0\n  #define unixDlError 0\n  #define unixDlSym   0\n  #define unixDlClose 0\n#endif\n\n/*\n** Write nBuf bytes of random data to the supplied buffer zBuf.\n*/\nstatic int unixRandomness(sqlite3_vfs *NotUsed, int nBuf, char *zBuf){\n  UNUSED_PARAMETER(NotUsed);\n  assert((size_t)nBuf>=(sizeof(time_t)+sizeof(int)));\n\n  /* We have to initialize zBuf to prevent valgrind from reporting\n  ** errors.  The reports issued by valgrind are incorrect - we would\n  ** prefer that the randomness be increased by making use of the\n  ** uninitialized space in zBuf - but valgrind errors tend to worry\n  ** some users.  Rather than argue, it seems easier just to initialize\n  ** the whole array and silence valgrind, even if that means less randomness\n  ** in the random seed.\n  **\n  ** When testing, initializing zBuf[] to zero is all we do.  That means\n  ** that we always use the same random number sequence.  This makes the\n  ** tests repeatable.\n  */\n  memset(zBuf, 0, nBuf);\n#if !defined(SQLITE_TEST)\n  {\n    int pid, fd;\n    fd = robust_open(\"/dev/urandom\", O_RDONLY, 0);\n    if( fd<0 ){\n      time_t t;\n      time(&t);\n      memcpy(zBuf, &t, sizeof(t));\n      pid = getpid();\n      memcpy(&zBuf[sizeof(t)], &pid, sizeof(pid));\n      assert( sizeof(t)+sizeof(pid)<=(size_t)nBuf );\n      nBuf = sizeof(t) + sizeof(pid);\n    }else{\n      do{ nBuf = osRead(fd, zBuf, nBuf); }while( nBuf<0 && errno==EINTR );\n      robust_close(0, fd, __LINE__);\n    }\n  }\n#endif\n  return nBuf;\n}\n\n\n/*\n** Sleep for a little while.  Return the amount of time slept.\n** The argument is the number of microseconds we want to sleep.\n** The return value is the number of microseconds of sleep actually\n** requested from the underlying operating system, a number which\n** might be greater than or equal to the argument, but not less\n** than the argument.\n*/\nstatic int unixSleep(sqlite3_vfs *NotUsed, int microseconds){\n#if OS_VXWORKS\n  struct timespec sp;\n\n  sp.tv_sec = microseconds / 1000000;\n  sp.tv_nsec = (microseconds % 1000000) * 1000;\n  nanosleep(&sp, NULL);\n  UNUSED_PARAMETER(NotUsed);\n  return microseconds;\n#elif defined(HAVE_USLEEP) && HAVE_USLEEP\n  usleep(microseconds);\n  UNUSED_PARAMETER(NotUsed);\n  return microseconds;\n#else\n  #error Slow unix sleep!\n  int seconds = (microseconds+999999)/1000000;\n  sleep(seconds);\n  UNUSED_PARAMETER(NotUsed);\n  return seconds*1000000;\n#endif\n}\n\n/*\n** The following variable, if set to a non-zero value, is interpreted as\n** the number of seconds since 1970 and is used to set the result of\n** sqlite3OsCurrentTime() during testing.\n*/\n#ifdef SQLITE_TEST\nSQLITE_API int sqlite3_current_time = 0;  /* Fake system time in seconds since 1970. */\n#endif\n\n/*\n** Find the current time (in Universal Coordinated Time).  Write into *piNow\n** the current time and date as a Julian Day number times 86_400_000.  In\n** other words, write into *piNow the number of milliseconds since the Julian\n** epoch of noon in Greenwich on November 24, 4714 B.C according to the\n** proleptic Gregorian calendar.\n**\n** On success, return 0.  Return 1 if the time and date cannot be found.\n*/\nstatic int unixCurrentTimeInt64(sqlite3_vfs *NotUsed, sqlite3_int64 *piNow){\n  static const sqlite3_int64 unixEpoch = 24405875*(sqlite3_int64)8640000;\n#if defined(NO_GETTOD)\n  time_t t;\n  time(&t);\n  *piNow = ((sqlite3_int64)t)*1000 + unixEpoch;\n#elif OS_VXWORKS\n  struct timespec sNow;\n  clock_gettime(CLOCK_REALTIME, &sNow);\n  *piNow = unixEpoch + 1000*(sqlite3_int64)sNow.tv_sec + sNow.tv_nsec/1000000;\n#else\n  struct timeval sNow;\n  gettimeofday(&sNow, 0);\n  *piNow = unixEpoch + 1000*(sqlite3_int64)sNow.tv_sec + sNow.tv_usec/1000;\n#endif\n\n#ifdef SQLITE_TEST\n  if( sqlite3_current_time ){\n    *piNow = 1000*(sqlite3_int64)sqlite3_current_time + unixEpoch;\n  }\n#endif\n  UNUSED_PARAMETER(NotUsed);\n  return 0;\n}\n\n/*\n** Find the current time (in Universal Coordinated Time).  Write the\n** current time and date as a Julian Day number into *prNow and\n** return 0.  Return 1 if the time and date cannot be found.\n*/\nstatic int unixCurrentTime(sqlite3_vfs *NotUsed, double *prNow){\n  sqlite3_int64 i;\n  UNUSED_PARAMETER(NotUsed);\n  unixCurrentTimeInt64(0, &i);\n  *prNow = i/86400000.0;\n  return 0;\n}\n\n/*\n** We added the xGetLastError() method with the intention of providing\n** better low-level error messages when operating-system problems come up\n** during SQLite operation.  But so far, none of that has been implemented\n** in the core.  So this routine is never called.  For now, it is merely\n** a place-holder.\n*/\nstatic int unixGetLastError(sqlite3_vfs *NotUsed, int NotUsed2, char *NotUsed3){\n  UNUSED_PARAMETER(NotUsed);\n  UNUSED_PARAMETER(NotUsed2);\n  UNUSED_PARAMETER(NotUsed3);\n  return 0;\n}\n\n\n/*\n************************ End of sqlite3_vfs methods ***************************\n******************************************************************************/\n\n/******************************************************************************\n************************** Begin Proxy Locking ********************************\n**\n** Proxy locking is a \"uber-locking-method\" in this sense:  It uses the\n** other locking methods on secondary lock files.  Proxy locking is a\n** meta-layer over top of the primitive locking implemented above.  For\n** this reason, the division that implements of proxy locking is deferred\n** until late in the file (here) after all of the other I/O methods have\n** been defined - so that the primitive locking methods are available\n** as services to help with the implementation of proxy locking.\n**\n****\n**\n** The default locking schemes in SQLite use byte-range locks on the\n** database file to coordinate safe, concurrent access by multiple readers\n** and writers [http://sqlite.org/lockingv3.html].  The five file locking\n** states (UNLOCKED, PENDING, SHARED, RESERVED, EXCLUSIVE) are implemented\n** as POSIX read & write locks over fixed set of locations (via fsctl),\n** on AFP and SMB only exclusive byte-range locks are available via fsctl\n** with _IOWR('z', 23, struct ByteRangeLockPB2) to track the same 5 states.\n** To simulate a F_RDLCK on the shared range, on AFP a randomly selected\n** address in the shared range is taken for a SHARED lock, the entire\n** shared range is taken for an EXCLUSIVE lock):\n**\n**      PENDING_BYTE        0x40000000\n**      RESERVED_BYTE       0x40000001\n**      SHARED_RANGE        0x40000002 -> 0x40000200\n**\n** This works well on the local file system, but shows a nearly 100x\n** slowdown in read performance on AFP because the AFP client disables\n** the read cache when byte-range locks are present.  Enabling the read\n** cache exposes a cache coherency problem that is present on all OS X\n** supported network file systems.  NFS and AFP both observe the\n** close-to-open semantics for ensuring cache coherency\n** [http://nfs.sourceforge.net/#faq_a8], which does not effectively\n** address the requirements for concurrent database access by multiple\n** readers and writers\n** [http://www.nabble.com/SQLite-on-NFS-cache-coherency-td15655701.html].\n**\n** To address the performance and cache coherency issues, proxy file locking\n** changes the way database access is controlled by limiting access to a\n** single host at a time and moving file locks off of the database file\n** and onto a proxy file on the local file system.  \n**\n**\n** Using proxy locks\n** -----------------\n**\n** C APIs\n**\n**  sqlite3_file_control(db, dbname, SQLITE_SET_LOCKPROXYFILE,\n**                       <proxy_path> | \":auto:\");\n**  sqlite3_file_control(db, dbname, SQLITE_GET_LOCKPROXYFILE, &<proxy_path>);\n**\n**\n** SQL pragmas\n**\n**  PRAGMA [database.]lock_proxy_file=<proxy_path> | :auto:\n**  PRAGMA [database.]lock_proxy_file\n**\n** Specifying \":auto:\" means that if there is a conch file with a matching\n** host ID in it, the proxy path in the conch file will be used, otherwise\n** a proxy path based on the user's temp dir\n** (via confstr(_CS_DARWIN_USER_TEMP_DIR,...)) will be used and the\n** actual proxy file name is generated from the name and path of the\n** database file.  For example:\n**\n**       For database path \"/Users/me/foo.db\" \n**       The lock path will be \"<tmpdir>/sqliteplocks/_Users_me_foo.db:auto:\")\n**\n** Once a lock proxy is configured for a database connection, it can not\n** be removed, however it may be switched to a different proxy path via\n** the above APIs (assuming the conch file is not being held by another\n** connection or process). \n**\n**\n** How proxy locking works\n** -----------------------\n**\n** Proxy file locking relies primarily on two new supporting files: \n**\n**   *  conch file to limit access to the database file to a single host\n**      at a time\n**\n**   *  proxy file to act as a proxy for the advisory locks normally\n**      taken on the database\n**\n** The conch file - to use a proxy file, sqlite must first \"hold the conch\"\n** by taking an sqlite-style shared lock on the conch file, reading the\n** contents and comparing the host's unique host ID (see below) and lock\n** proxy path against the values stored in the conch.  The conch file is\n** stored in the same directory as the database file and the file name\n** is patterned after the database file name as \".<databasename>-conch\".\n** If the conch file does not exist, or it's contents do not match the\n** host ID and/or proxy path, then the lock is escalated to an exclusive\n** lock and the conch file contents is updated with the host ID and proxy\n** path and the lock is downgraded to a shared lock again.  If the conch\n** is held by another process (with a shared lock), the exclusive lock\n** will fail and SQLITE_BUSY is returned.\n**\n** The proxy file - a single-byte file used for all advisory file locks\n** normally taken on the database file.   This allows for safe sharing\n** of the database file for multiple readers and writers on the same\n** host (the conch ensures that they all use the same local lock file).\n**\n** Requesting the lock proxy does not immediately take the conch, it is\n** only taken when the first request to lock database file is made.  \n** This matches the semantics of the traditional locking behavior, where\n** opening a connection to a database file does not take a lock on it.\n** The shared lock and an open file descriptor are maintained until \n** the connection to the database is closed. \n**\n** The proxy file and the lock file are never deleted so they only need\n** to be created the first time they are used.\n**\n** Configuration options\n** ---------------------\n**\n**  SQLITE_PREFER_PROXY_LOCKING\n**\n**       Database files accessed on non-local file systems are\n**       automatically configured for proxy locking, lock files are\n**       named automatically using the same logic as\n**       PRAGMA lock_proxy_file=\":auto:\"\n**    \n**  SQLITE_PROXY_DEBUG\n**\n**       Enables the logging of error messages during host id file\n**       retrieval and creation\n**\n**  LOCKPROXYDIR\n**\n**       Overrides the default directory used for lock proxy files that\n**       are named automatically via the \":auto:\" setting\n**\n**  SQLITE_DEFAULT_PROXYDIR_PERMISSIONS\n**\n**       Permissions to use when creating a directory for storing the\n**       lock proxy files, only used when LOCKPROXYDIR is not set.\n**    \n**    \n** As mentioned above, when compiled with SQLITE_PREFER_PROXY_LOCKING,\n** setting the environment variable SQLITE_FORCE_PROXY_LOCKING to 1 will\n** force proxy locking to be used for every database file opened, and 0\n** will force automatic proxy locking to be disabled for all database\n** files (explicitly calling the SQLITE_SET_LOCKPROXYFILE pragma or\n** sqlite_file_control API is not affected by SQLITE_FORCE_PROXY_LOCKING).\n*/\n\n/*\n** Proxy locking is only available on MacOSX \n*/\n#if defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE\n\n/*\n** The proxyLockingContext has the path and file structures for the remote \n** and local proxy files in it\n*/\ntypedef struct proxyLockingContext proxyLockingContext;\nstruct proxyLockingContext {\n  unixFile *conchFile;         /* Open conch file */\n  char *conchFilePath;         /* Name of the conch file */\n  unixFile *lockProxy;         /* Open proxy lock file */\n  char *lockProxyPath;         /* Name of the proxy lock file */\n  char *dbPath;                /* Name of the open file */\n  int conchHeld;               /* 1 if the conch is held, -1 if lockless */\n  void *oldLockingContext;     /* Original lockingcontext to restore on close */\n  sqlite3_io_methods const *pOldMethod;     /* Original I/O methods for close */\n};\n\n/* \n** The proxy lock file path for the database at dbPath is written into lPath, \n** which must point to valid, writable memory large enough for a maxLen length\n** file path. \n*/\nstatic int proxyGetLockPath(const char *dbPath, char *lPath, size_t maxLen){\n  int len;\n  int dbLen;\n  int i;\n\n#ifdef LOCKPROXYDIR\n  len = strlcpy(lPath, LOCKPROXYDIR, maxLen);\n#else\n# ifdef _CS_DARWIN_USER_TEMP_DIR\n  {\n    if( !confstr(_CS_DARWIN_USER_TEMP_DIR, lPath, maxLen) ){\n      OSTRACE((\"GETLOCKPATH  failed %s errno=%d pid=%d\\n\",\n               lPath, errno, getpid()));\n      return SQLITE_IOERR_LOCK;\n    }\n    len = strlcat(lPath, \"sqliteplocks\", maxLen);    \n  }\n# else\n  len = strlcpy(lPath, \"/tmp/\", maxLen);\n# endif\n#endif\n\n  if( lPath[len-1]!='/' ){\n    len = strlcat(lPath, \"/\", maxLen);\n  }\n  \n  /* transform the db path to a unique cache name */\n  dbLen = (int)strlen(dbPath);\n  for( i=0; i<dbLen && (i+len+7)<(int)maxLen; i++){\n    char c = dbPath[i];\n    lPath[i+len] = (c=='/')?'_':c;\n  }\n  lPath[i+len]='\\0';\n  strlcat(lPath, \":auto:\", maxLen);\n  OSTRACE((\"GETLOCKPATH  proxy lock path=%s pid=%d\\n\", lPath, getpid()));\n  return SQLITE_OK;\n}\n\n/* \n ** Creates the lock file and any missing directories in lockPath\n */\nstatic int proxyCreateLockPath(const char *lockPath){\n  int i, len;\n  char buf[MAXPATHLEN];\n  int start = 0;\n  \n  assert(lockPath!=NULL);\n  /* try to create all the intermediate directories */\n  len = (int)strlen(lockPath);\n  buf[0] = lockPath[0];\n  for( i=1; i<len; i++ ){\n    if( lockPath[i] == '/' && (i - start > 0) ){\n      /* only mkdir if leaf dir != \".\" or \"/\" or \"..\" */\n      if( i-start>2 || (i-start==1 && buf[start] != '.' && buf[start] != '/') \n         || (i-start==2 && buf[start] != '.' && buf[start+1] != '.') ){\n        buf[i]='\\0';\n        if( mkdir(buf, SQLITE_DEFAULT_PROXYDIR_PERMISSIONS) ){\n          int err=errno;\n          if( err!=EEXIST ) {\n            OSTRACE((\"CREATELOCKPATH  FAILED creating %s, \"\n                     \"'%s' proxy lock path=%s pid=%d\\n\",\n                     buf, strerror(err), lockPath, getpid()));\n            return err;\n          }\n        }\n      }\n      start=i+1;\n    }\n    buf[i] = lockPath[i];\n  }\n  OSTRACE((\"CREATELOCKPATH  proxy lock path=%s pid=%d\\n\", lockPath, getpid()));\n  return 0;\n}\n\n/*\n** Create a new VFS file descriptor (stored in memory obtained from\n** sqlite3_malloc) and open the file named \"path\" in the file descriptor.\n**\n** The caller is responsible not only for closing the file descriptor\n** but also for freeing the memory associated with the file descriptor.\n*/\nstatic int proxyCreateUnixFile(\n    const char *path,        /* path for the new unixFile */\n    unixFile **ppFile,       /* unixFile created and returned by ref */\n    int islockfile           /* if non zero missing dirs will be created */\n) {\n  int fd = -1;\n  int dirfd = -1;\n  unixFile *pNew;\n  int rc = SQLITE_OK;\n  int openFlags = O_RDWR | O_CREAT;\n  sqlite3_vfs dummyVfs;\n  int terrno = 0;\n  UnixUnusedFd *pUnused = NULL;\n\n  /* 1. first try to open/create the file\n  ** 2. if that fails, and this is a lock file (not-conch), try creating\n  ** the parent directories and then try again.\n  ** 3. if that fails, try to open the file read-only\n  ** otherwise return BUSY (if lock file) or CANTOPEN for the conch file\n  */\n  pUnused = findReusableFd(path, openFlags);\n  if( pUnused ){\n    fd = pUnused->fd;\n  }else{\n    pUnused = sqlite3_malloc(sizeof(*pUnused));\n    if( !pUnused ){\n      return SQLITE_NOMEM;\n    }\n  }\n  if( fd<0 ){\n    fd = robust_open(path, openFlags, SQLITE_DEFAULT_FILE_PERMISSIONS);\n    terrno = errno;\n    if( fd<0 && errno==ENOENT && islockfile ){\n      if( proxyCreateLockPath(path) == SQLITE_OK ){\n        fd = robust_open(path, openFlags, SQLITE_DEFAULT_FILE_PERMISSIONS);\n      }\n    }\n  }\n  if( fd<0 ){\n    openFlags = O_RDONLY;\n    fd = robust_open(path, openFlags, SQLITE_DEFAULT_FILE_PERMISSIONS);\n    terrno = errno;\n  }\n  if( fd<0 ){\n    if( islockfile ){\n      return SQLITE_BUSY;\n    }\n    switch (terrno) {\n      case EACCES:\n        return SQLITE_PERM;\n      case EIO: \n        return SQLITE_IOERR_LOCK; /* even though it is the conch */\n      default:\n        return SQLITE_CANTOPEN_BKPT;\n    }\n  }\n  \n  pNew = (unixFile *)sqlite3_malloc(sizeof(*pNew));\n  if( pNew==NULL ){\n    rc = SQLITE_NOMEM;\n    goto end_create_proxy;\n  }\n  memset(pNew, 0, sizeof(unixFile));\n  pNew->openFlags = openFlags;\n  dummyVfs.pAppData = (void*)&autolockIoFinder;\n  pUnused->fd = fd;\n  pUnused->flags = openFlags;\n  pNew->pUnused = pUnused;\n  \n  rc = fillInUnixFile(&dummyVfs, fd, dirfd, (sqlite3_file*)pNew, path, 0, 0, 0);\n  if( rc==SQLITE_OK ){\n    *ppFile = pNew;\n    return SQLITE_OK;\n  }\nend_create_proxy:    \n  robust_close(pNew, fd, __LINE__);\n  sqlite3_free(pNew);\n  sqlite3_free(pUnused);\n  return rc;\n}\n\n#ifdef SQLITE_TEST\n/* simulate multiple hosts by creating unique hostid file paths */\nSQLITE_API int sqlite3_hostid_num = 0;\n#endif\n\n#define PROXY_HOSTIDLEN    16  /* conch file host id length */\n\n/* Not always defined in the headers as it ought to be */\nextern int gethostuuid(uuid_t id, const struct timespec *wait);\n\n/* get the host ID via gethostuuid(), pHostID must point to PROXY_HOSTIDLEN \n** bytes of writable memory.\n*/\nstatic int proxyGetHostID(unsigned char *pHostID, int *pError){\n  assert(PROXY_HOSTIDLEN == sizeof(uuid_t));\n  memset(pHostID, 0, PROXY_HOSTIDLEN);\n#if defined(__MAX_OS_X_VERSION_MIN_REQUIRED)\\\n               && __MAC_OS_X_VERSION_MIN_REQUIRED<1050\n  {\n    static const struct timespec timeout = {1, 0}; /* 1 sec timeout */\n    if( gethostuuid(pHostID, &timeout) ){\n      int err = errno;\n      if( pError ){\n        *pError = err;\n      }\n      return SQLITE_IOERR;\n    }\n  }\n#endif\n#ifdef SQLITE_TEST\n  /* simulate multiple hosts by creating unique hostid file paths */\n  if( sqlite3_hostid_num != 0){\n    pHostID[0] = (char)(pHostID[0] + (char)(sqlite3_hostid_num & 0xFF));\n  }\n#endif\n  \n  return SQLITE_OK;\n}\n\n/* The conch file contains the header, host id and lock file path\n */\n#define PROXY_CONCHVERSION 2   /* 1-byte header, 16-byte host id, path */\n#define PROXY_HEADERLEN    1   /* conch file header length */\n#define PROXY_PATHINDEX    (PROXY_HEADERLEN+PROXY_HOSTIDLEN)\n#define PROXY_MAXCONCHLEN  (PROXY_HEADERLEN+PROXY_HOSTIDLEN+MAXPATHLEN)\n\n/* \n** Takes an open conch file, copies the contents to a new path and then moves \n** it back.  The newly created file's file descriptor is assigned to the\n** conch file structure and finally the original conch file descriptor is \n** closed.  Returns zero if successful.\n*/\nstatic int proxyBreakConchLock(unixFile *pFile, uuid_t myHostID){\n  proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext; \n  unixFile *conchFile = pCtx->conchFile;\n  char tPath[MAXPATHLEN];\n  char buf[PROXY_MAXCONCHLEN];\n  char *cPath = pCtx->conchFilePath;\n  size_t readLen = 0;\n  size_t pathLen = 0;\n  char errmsg[64] = \"\";\n  int fd = -1;\n  int rc = -1;\n  UNUSED_PARAMETER(myHostID);\n\n  /* create a new path by replace the trailing '-conch' with '-break' */\n  pathLen = strlcpy(tPath, cPath, MAXPATHLEN);\n  if( pathLen>MAXPATHLEN || pathLen<6 || \n     (strlcpy(&tPath[pathLen-5], \"break\", 6) != 5) ){\n    sqlite3_snprintf(sizeof(errmsg),errmsg,\"path error (len %d)\",(int)pathLen);\n    goto end_breaklock;\n  }\n  /* read the conch content */\n  readLen = osPread(conchFile->h, buf, PROXY_MAXCONCHLEN, 0);\n  if( readLen<PROXY_PATHINDEX ){\n    sqlite3_snprintf(sizeof(errmsg),errmsg,\"read error (len %d)\",(int)readLen);\n    goto end_breaklock;\n  }\n  /* write it out to the temporary break file */\n  fd = robust_open(tPath, (O_RDWR|O_CREAT|O_EXCL),\n                   SQLITE_DEFAULT_FILE_PERMISSIONS);\n  if( fd<0 ){\n    sqlite3_snprintf(sizeof(errmsg), errmsg, \"create failed (%d)\", errno);\n    goto end_breaklock;\n  }\n  if( osPwrite(fd, buf, readLen, 0) != (ssize_t)readLen ){\n    sqlite3_snprintf(sizeof(errmsg), errmsg, \"write failed (%d)\", errno);\n    goto end_breaklock;\n  }\n  if( rename(tPath, cPath) ){\n    sqlite3_snprintf(sizeof(errmsg), errmsg, \"rename failed (%d)\", errno);\n    goto end_breaklock;\n  }\n  rc = 0;\n  fprintf(stderr, \"broke stale lock on %s\\n\", cPath);\n  robust_close(pFile, conchFile->h, __LINE__);\n  conchFile->h = fd;\n  conchFile->openFlags = O_RDWR | O_CREAT;\n\nend_breaklock:\n  if( rc ){\n    if( fd>=0 ){\n      unlink(tPath);\n      robust_close(pFile, fd, __LINE__);\n    }\n    fprintf(stderr, \"failed to break stale lock on %s, %s\\n\", cPath, errmsg);\n  }\n  return rc;\n}\n\n/* Take the requested lock on the conch file and break a stale lock if the \n** host id matches.\n*/\nstatic int proxyConchLock(unixFile *pFile, uuid_t myHostID, int lockType){\n  proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext; \n  unixFile *conchFile = pCtx->conchFile;\n  int rc = SQLITE_OK;\n  int nTries = 0;\n  struct timespec conchModTime;\n  \n  do {\n    rc = conchFile->pMethod->xLock((sqlite3_file*)conchFile, lockType);\n    nTries ++;\n    if( rc==SQLITE_BUSY ){\n      /* If the lock failed (busy):\n       * 1st try: get the mod time of the conch, wait 0.5s and try again. \n       * 2nd try: fail if the mod time changed or host id is different, wait \n       *           10 sec and try again\n       * 3rd try: break the lock unless the mod time has changed.\n       */\n      struct stat buf;\n      if( osFstat(conchFile->h, &buf) ){\n        pFile->lastErrno = errno;\n        return SQLITE_IOERR_LOCK;\n      }\n      \n      if( nTries==1 ){\n        conchModTime = buf.st_mtimespec;\n        usleep(500000); /* wait 0.5 sec and try the lock again*/\n        continue;  \n      }\n\n      assert( nTries>1 );\n      if( conchModTime.tv_sec != buf.st_mtimespec.tv_sec || \n         conchModTime.tv_nsec != buf.st_mtimespec.tv_nsec ){\n        return SQLITE_BUSY;\n      }\n      \n      if( nTries==2 ){  \n        char tBuf[PROXY_MAXCONCHLEN];\n        int len = osPread(conchFile->h, tBuf, PROXY_MAXCONCHLEN, 0);\n        if( len<0 ){\n          pFile->lastErrno = errno;\n          return SQLITE_IOERR_LOCK;\n        }\n        if( len>PROXY_PATHINDEX && tBuf[0]==(char)PROXY_CONCHVERSION){\n          /* don't break the lock if the host id doesn't match */\n          if( 0!=memcmp(&tBuf[PROXY_HEADERLEN], myHostID, PROXY_HOSTIDLEN) ){\n            return SQLITE_BUSY;\n          }\n        }else{\n          /* don't break the lock on short read or a version mismatch */\n          return SQLITE_BUSY;\n        }\n        usleep(10000000); /* wait 10 sec and try the lock again */\n        continue; \n      }\n      \n      assert( nTries==3 );\n      if( 0==proxyBreakConchLock(pFile, myHostID) ){\n        rc = SQLITE_OK;\n        if( lockType==EXCLUSIVE_LOCK ){\n          rc = conchFile->pMethod->xLock((sqlite3_file*)conchFile, SHARED_LOCK);          \n        }\n        if( !rc ){\n          rc = conchFile->pMethod->xLock((sqlite3_file*)conchFile, lockType);\n        }\n      }\n    }\n  } while( rc==SQLITE_BUSY && nTries<3 );\n  \n  return rc;\n}\n\n/* Takes the conch by taking a shared lock and read the contents conch, if \n** lockPath is non-NULL, the host ID and lock file path must match.  A NULL \n** lockPath means that the lockPath in the conch file will be used if the \n** host IDs match, or a new lock path will be generated automatically \n** and written to the conch file.\n*/\nstatic int proxyTakeConch(unixFile *pFile){\n  proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext; \n  \n  if( pCtx->conchHeld!=0 ){\n    return SQLITE_OK;\n  }else{\n    unixFile *conchFile = pCtx->conchFile;\n    uuid_t myHostID;\n    int pError = 0;\n    char readBuf[PROXY_MAXCONCHLEN];\n    char lockPath[MAXPATHLEN];\n    char *tempLockPath = NULL;\n    int rc = SQLITE_OK;\n    int createConch = 0;\n    int hostIdMatch = 0;\n    int readLen = 0;\n    int tryOldLockPath = 0;\n    int forceNewLockPath = 0;\n    \n    OSTRACE((\"TAKECONCH  %d for %s pid=%d\\n\", conchFile->h,\n             (pCtx->lockProxyPath ? pCtx->lockProxyPath : \":auto:\"), getpid()));\n\n    rc = proxyGetHostID(myHostID, &pError);\n    if( (rc&0xff)==SQLITE_IOERR ){\n      pFile->lastErrno = pError;\n      goto end_takeconch;\n    }\n    rc = proxyConchLock(pFile, myHostID, SHARED_LOCK);\n    if( rc!=SQLITE_OK ){\n      goto end_takeconch;\n    }\n    /* read the existing conch file */\n    readLen = seekAndRead((unixFile*)conchFile, 0, readBuf, PROXY_MAXCONCHLEN);\n    if( readLen<0 ){\n      /* I/O error: lastErrno set by seekAndRead */\n      pFile->lastErrno = conchFile->lastErrno;\n      rc = SQLITE_IOERR_READ;\n      goto end_takeconch;\n    }else if( readLen<=(PROXY_HEADERLEN+PROXY_HOSTIDLEN) || \n             readBuf[0]!=(char)PROXY_CONCHVERSION ){\n      /* a short read or version format mismatch means we need to create a new \n      ** conch file. \n      */\n      createConch = 1;\n    }\n    /* if the host id matches and the lock path already exists in the conch\n    ** we'll try to use the path there, if we can't open that path, we'll \n    ** retry with a new auto-generated path \n    */\n    do { /* in case we need to try again for an :auto: named lock file */\n\n      if( !createConch && !forceNewLockPath ){\n        hostIdMatch = !memcmp(&readBuf[PROXY_HEADERLEN], myHostID, \n                                  PROXY_HOSTIDLEN);\n        /* if the conch has data compare the contents */\n        if( !pCtx->lockProxyPath ){\n          /* for auto-named local lock file, just check the host ID and we'll\n           ** use the local lock file path that's already in there\n           */\n          if( hostIdMatch ){\n            size_t pathLen = (readLen - PROXY_PATHINDEX);\n            \n            if( pathLen>=MAXPATHLEN ){\n              pathLen=MAXPATHLEN-1;\n            }\n            memcpy(lockPath, &readBuf[PROXY_PATHINDEX], pathLen);\n            lockPath[pathLen] = 0;\n            tempLockPath = lockPath;\n            tryOldLockPath = 1;\n            /* create a copy of the lock path if the conch is taken */\n            goto end_takeconch;\n          }\n        }else if( hostIdMatch\n               && !strncmp(pCtx->lockProxyPath, &readBuf[PROXY_PATHINDEX],\n                           readLen-PROXY_PATHINDEX)\n        ){\n          /* conch host and lock path match */\n          goto end_takeconch; \n        }\n      }\n      \n      /* if the conch isn't writable and doesn't match, we can't take it */\n      if( (conchFile->openFlags&O_RDWR) == 0 ){\n        rc = SQLITE_BUSY;\n        goto end_takeconch;\n      }\n      \n      /* either the conch didn't match or we need to create a new one */\n      if( !pCtx->lockProxyPath ){\n        proxyGetLockPath(pCtx->dbPath, lockPath, MAXPATHLEN);\n        tempLockPath = lockPath;\n        /* create a copy of the lock path _only_ if the conch is taken */\n      }\n      \n      /* update conch with host and path (this will fail if other process\n      ** has a shared lock already), if the host id matches, use the big\n      ** stick.\n      */\n      futimes(conchFile->h, NULL);\n      if( hostIdMatch && !createConch ){\n        if( conchFile->pInode && conchFile->pInode->nShared>1 ){\n          /* We are trying for an exclusive lock but another thread in this\n           ** same process is still holding a shared lock. */\n          rc = SQLITE_BUSY;\n        } else {          \n          rc = proxyConchLock(pFile, myHostID, EXCLUSIVE_LOCK);\n        }\n      }else{\n        rc = conchFile->pMethod->xLock((sqlite3_file*)conchFile, EXCLUSIVE_LOCK);\n      }\n      if( rc==SQLITE_OK ){\n        char writeBuffer[PROXY_MAXCONCHLEN];\n        int writeSize = 0;\n        \n        writeBuffer[0] = (char)PROXY_CONCHVERSION;\n        memcpy(&writeBuffer[PROXY_HEADERLEN], myHostID, PROXY_HOSTIDLEN);\n        if( pCtx->lockProxyPath!=NULL ){\n          strlcpy(&writeBuffer[PROXY_PATHINDEX], pCtx->lockProxyPath, MAXPATHLEN);\n        }else{\n          strlcpy(&writeBuffer[PROXY_PATHINDEX], tempLockPath, MAXPATHLEN);\n        }\n        writeSize = PROXY_PATHINDEX + strlen(&writeBuffer[PROXY_PATHINDEX]);\n        robust_ftruncate(conchFile->h, writeSize);\n        rc = unixWrite((sqlite3_file *)conchFile, writeBuffer, writeSize, 0);\n        fsync(conchFile->h);\n        /* If we created a new conch file (not just updated the contents of a \n         ** valid conch file), try to match the permissions of the database \n         */\n        if( rc==SQLITE_OK && createConch ){\n          struct stat buf;\n          int err = osFstat(pFile->h, &buf);\n          if( err==0 ){\n            mode_t cmode = buf.st_mode&(S_IRUSR|S_IWUSR | S_IRGRP|S_IWGRP |\n                                        S_IROTH|S_IWOTH);\n            /* try to match the database file R/W permissions, ignore failure */\n#ifndef SQLITE_PROXY_DEBUG\n            osFchmod(conchFile->h, cmode);\n#else\n            do{\n              rc = osFchmod(conchFile->h, cmode);\n            }while( rc==(-1) && errno==EINTR );\n            if( rc!=0 ){\n              int code = errno;\n              fprintf(stderr, \"fchmod %o FAILED with %d %s\\n\",\n                      cmode, code, strerror(code));\n            } else {\n              fprintf(stderr, \"fchmod %o SUCCEDED\\n\",cmode);\n            }\n          }else{\n            int code = errno;\n            fprintf(stderr, \"STAT FAILED[%d] with %d %s\\n\", \n                    err, code, strerror(code));\n#endif\n          }\n        }\n      }\n      conchFile->pMethod->xUnlock((sqlite3_file*)conchFile, SHARED_LOCK);\n      \n    end_takeconch:\n      OSTRACE((\"TRANSPROXY: CLOSE  %d\\n\", pFile->h));\n      if( rc==SQLITE_OK && pFile->openFlags ){\n        if( pFile->h>=0 ){\n          robust_close(pFile, pFile->h, __LINE__);\n        }\n        pFile->h = -1;\n        int fd = robust_open(pCtx->dbPath, pFile->openFlags,\n                      SQLITE_DEFAULT_FILE_PERMISSIONS);\n        OSTRACE((\"TRANSPROXY: OPEN  %d\\n\", fd));\n        if( fd>=0 ){\n          pFile->h = fd;\n        }else{\n          rc=SQLITE_CANTOPEN_BKPT; /* SQLITE_BUSY? proxyTakeConch called\n           during locking */\n        }\n      }\n      if( rc==SQLITE_OK && !pCtx->lockProxy ){\n        char *path = tempLockPath ? tempLockPath : pCtx->lockProxyPath;\n        rc = proxyCreateUnixFile(path, &pCtx->lockProxy, 1);\n        if( rc!=SQLITE_OK && rc!=SQLITE_NOMEM && tryOldLockPath ){\n          /* we couldn't create the proxy lock file with the old lock file path\n           ** so try again via auto-naming \n           */\n          forceNewLockPath = 1;\n          tryOldLockPath = 0;\n          continue; /* go back to the do {} while start point, try again */\n        }\n      }\n      if( rc==SQLITE_OK ){\n        /* Need to make a copy of path if we extracted the value\n         ** from the conch file or the path was allocated on the stack\n         */\n        if( tempLockPath ){\n          pCtx->lockProxyPath = sqlite3DbStrDup(0, tempLockPath);\n          if( !pCtx->lockProxyPath ){\n            rc = SQLITE_NOMEM;\n          }\n        }\n      }\n      if( rc==SQLITE_OK ){\n        pCtx->conchHeld = 1;\n        \n        if( pCtx->lockProxy->pMethod == &afpIoMethods ){\n          afpLockingContext *afpCtx;\n          afpCtx = (afpLockingContext *)pCtx->lockProxy->lockingContext;\n          afpCtx->dbPath = pCtx->lockProxyPath;\n        }\n      } else {\n        conchFile->pMethod->xUnlock((sqlite3_file*)conchFile, NO_LOCK);\n      }\n      OSTRACE((\"TAKECONCH  %d %s\\n\", conchFile->h,\n               rc==SQLITE_OK?\"ok\":\"failed\"));\n      return rc;\n    } while (1); /* in case we need to retry the :auto: lock file - \n                 ** we should never get here except via the 'continue' call. */\n  }\n}\n\n/*\n** If pFile holds a lock on a conch file, then release that lock.\n*/\nstatic int proxyReleaseConch(unixFile *pFile){\n  int rc = SQLITE_OK;         /* Subroutine return code */\n  proxyLockingContext *pCtx;  /* The locking context for the proxy lock */\n  unixFile *conchFile;        /* Name of the conch file */\n\n  pCtx = (proxyLockingContext *)pFile->lockingContext;\n  conchFile = pCtx->conchFile;\n  OSTRACE((\"RELEASECONCH  %d for %s pid=%d\\n\", conchFile->h,\n           (pCtx->lockProxyPath ? pCtx->lockProxyPath : \":auto:\"), \n           getpid()));\n  if( pCtx->conchHeld>0 ){\n    rc = conchFile->pMethod->xUnlock((sqlite3_file*)conchFile, NO_LOCK);\n  }\n  pCtx->conchHeld = 0;\n  OSTRACE((\"RELEASECONCH  %d %s\\n\", conchFile->h,\n           (rc==SQLITE_OK ? \"ok\" : \"failed\")));\n  return rc;\n}\n\n/*\n** Given the name of a database file, compute the name of its conch file.\n** Store the conch filename in memory obtained from sqlite3_malloc().\n** Make *pConchPath point to the new name.  Return SQLITE_OK on success\n** or SQLITE_NOMEM if unable to obtain memory.\n**\n** The caller is responsible for ensuring that the allocated memory\n** space is eventually freed.\n**\n** *pConchPath is set to NULL if a memory allocation error occurs.\n*/\nstatic int proxyCreateConchPathname(char *dbPath, char **pConchPath){\n  int i;                        /* Loop counter */\n  int len = (int)strlen(dbPath); /* Length of database filename - dbPath */\n  char *conchPath;              /* buffer in which to construct conch name */\n\n  /* Allocate space for the conch filename and initialize the name to\n  ** the name of the original database file. */  \n  *pConchPath = conchPath = (char *)sqlite3_malloc(len + 8);\n  if( conchPath==0 ){\n    return SQLITE_NOMEM;\n  }\n  memcpy(conchPath, dbPath, len+1);\n  \n  /* now insert a \".\" before the last / character */\n  for( i=(len-1); i>=0; i-- ){\n    if( conchPath[i]=='/' ){\n      i++;\n      break;\n    }\n  }\n  conchPath[i]='.';\n  while ( i<len ){\n    conchPath[i+1]=dbPath[i];\n    i++;\n  }\n\n  /* append the \"-conch\" suffix to the file */\n  memcpy(&conchPath[i+1], \"-conch\", 7);\n  assert( (int)strlen(conchPath) == len+7 );\n\n  return SQLITE_OK;\n}\n\n\n/* Takes a fully configured proxy locking-style unix file and switches\n** the local lock file path \n*/\nstatic int switchLockProxyPath(unixFile *pFile, const char *path) {\n  proxyLockingContext *pCtx = (proxyLockingContext*)pFile->lockingContext;\n  char *oldPath = pCtx->lockProxyPath;\n  int rc = SQLITE_OK;\n\n  if( pFile->eFileLock!=NO_LOCK ){\n    return SQLITE_BUSY;\n  }  \n\n  /* nothing to do if the path is NULL, :auto: or matches the existing path */\n  if( !path || path[0]=='\\0' || !strcmp(path, \":auto:\") ||\n    (oldPath && !strncmp(oldPath, path, MAXPATHLEN)) ){\n    return SQLITE_OK;\n  }else{\n    unixFile *lockProxy = pCtx->lockProxy;\n    pCtx->lockProxy=NULL;\n    pCtx->conchHeld = 0;\n    if( lockProxy!=NULL ){\n      rc=lockProxy->pMethod->xClose((sqlite3_file *)lockProxy);\n      if( rc ) return rc;\n      sqlite3_free(lockProxy);\n    }\n    sqlite3_free(oldPath);\n    pCtx->lockProxyPath = sqlite3DbStrDup(0, path);\n  }\n  \n  return rc;\n}\n\n/*\n** pFile is a file that has been opened by a prior xOpen call.  dbPath\n** is a string buffer at least MAXPATHLEN+1 characters in size.\n**\n** This routine find the filename associated with pFile and writes it\n** int dbPath.\n*/\nstatic int proxyGetDbPathForUnixFile(unixFile *pFile, char *dbPath){\n#if defined(__APPLE__)\n  if( pFile->pMethod == &afpIoMethods ){\n    /* afp style keeps a reference to the db path in the filePath field \n    ** of the struct */\n    assert( (int)strlen((char*)pFile->lockingContext)<=MAXPATHLEN );\n    strlcpy(dbPath, ((afpLockingContext *)pFile->lockingContext)->dbPath, MAXPATHLEN);\n  } else\n#endif\n  if( pFile->pMethod == &dotlockIoMethods ){\n    /* dot lock style uses the locking context to store the dot lock\n    ** file path */\n    int len = strlen((char *)pFile->lockingContext) - strlen(DOTLOCK_SUFFIX);\n    memcpy(dbPath, (char *)pFile->lockingContext, len + 1);\n  }else{\n    /* all other styles use the locking context to store the db file path */\n    assert( strlen((char*)pFile->lockingContext)<=MAXPATHLEN );\n    strlcpy(dbPath, (char *)pFile->lockingContext, MAXPATHLEN);\n  }\n  return SQLITE_OK;\n}\n\n/*\n** Takes an already filled in unix file and alters it so all file locking \n** will be performed on the local proxy lock file.  The following fields\n** are preserved in the locking context so that they can be restored and \n** the unix structure properly cleaned up at close time:\n**  ->lockingContext\n**  ->pMethod\n*/\nstatic int proxyTransformUnixFile(unixFile *pFile, const char *path) {\n  proxyLockingContext *pCtx;\n  char dbPath[MAXPATHLEN+1];       /* Name of the database file */\n  char *lockPath=NULL;\n  int rc = SQLITE_OK;\n  \n  if( pFile->eFileLock!=NO_LOCK ){\n    return SQLITE_BUSY;\n  }\n  proxyGetDbPathForUnixFile(pFile, dbPath);\n  if( !path || path[0]=='\\0' || !strcmp(path, \":auto:\") ){\n    lockPath=NULL;\n  }else{\n    lockPath=(char *)path;\n  }\n  \n  OSTRACE((\"TRANSPROXY  %d for %s pid=%d\\n\", pFile->h,\n           (lockPath ? lockPath : \":auto:\"), getpid()));\n\n  pCtx = sqlite3_malloc( sizeof(*pCtx) );\n  if( pCtx==0 ){\n    return SQLITE_NOMEM;\n  }\n  memset(pCtx, 0, sizeof(*pCtx));\n\n  rc = proxyCreateConchPathname(dbPath, &pCtx->conchFilePath);\n  if( rc==SQLITE_OK ){\n    rc = proxyCreateUnixFile(pCtx->conchFilePath, &pCtx->conchFile, 0);\n    if( rc==SQLITE_CANTOPEN && ((pFile->openFlags&O_RDWR) == 0) ){\n      /* if (a) the open flags are not O_RDWR, (b) the conch isn't there, and\n      ** (c) the file system is read-only, then enable no-locking access.\n      ** Ugh, since O_RDONLY==0x0000 we test for !O_RDWR since unixOpen asserts\n      ** that openFlags will have only one of O_RDONLY or O_RDWR.\n      */\n      struct statfs fsInfo;\n      struct stat conchInfo;\n      int goLockless = 0;\n\n      if( osStat(pCtx->conchFilePath, &conchInfo) == -1 ) {\n        int err = errno;\n        if( (err==ENOENT) && (statfs(dbPath, &fsInfo) != -1) ){\n          goLockless = (fsInfo.f_flags&MNT_RDONLY) == MNT_RDONLY;\n        }\n      }\n      if( goLockless ){\n        pCtx->conchHeld = -1; /* read only FS/ lockless */\n        rc = SQLITE_OK;\n      }\n    }\n  }  \n  if( rc==SQLITE_OK && lockPath ){\n    pCtx->lockProxyPath = sqlite3DbStrDup(0, lockPath);\n  }\n\n  if( rc==SQLITE_OK ){\n    pCtx->dbPath = sqlite3DbStrDup(0, dbPath);\n    if( pCtx->dbPath==NULL ){\n      rc = SQLITE_NOMEM;\n    }\n  }\n  if( rc==SQLITE_OK ){\n    /* all memory is allocated, proxys are created and assigned, \n    ** switch the locking context and pMethod then return.\n    */\n    pCtx->oldLockingContext = pFile->lockingContext;\n    pFile->lockingContext = pCtx;\n    pCtx->pOldMethod = pFile->pMethod;\n    pFile->pMethod = &proxyIoMethods;\n  }else{\n    if( pCtx->conchFile ){ \n      pCtx->conchFile->pMethod->xClose((sqlite3_file *)pCtx->conchFile);\n      sqlite3_free(pCtx->conchFile);\n    }\n    sqlite3DbFree(0, pCtx->lockProxyPath);\n    sqlite3_free(pCtx->conchFilePath); \n    sqlite3_free(pCtx);\n  }\n  OSTRACE((\"TRANSPROXY  %d %s\\n\", pFile->h,\n           (rc==SQLITE_OK ? \"ok\" : \"failed\")));\n  return rc;\n}\n\n\n/*\n** This routine handles sqlite3_file_control() calls that are specific\n** to proxy locking.\n*/\nstatic int proxyFileControl(sqlite3_file *id, int op, void *pArg){\n  switch( op ){\n    case SQLITE_GET_LOCKPROXYFILE: {\n      unixFile *pFile = (unixFile*)id;\n      if( pFile->pMethod == &proxyIoMethods ){\n        proxyLockingContext *pCtx = (proxyLockingContext*)pFile->lockingContext;\n        proxyTakeConch(pFile);\n        if( pCtx->lockProxyPath ){\n          *(const char **)pArg = pCtx->lockProxyPath;\n        }else{\n          *(const char **)pArg = \":auto: (not held)\";\n        }\n      } else {\n        *(const char **)pArg = NULL;\n      }\n      return SQLITE_OK;\n    }\n    case SQLITE_SET_LOCKPROXYFILE: {\n      unixFile *pFile = (unixFile*)id;\n      int rc = SQLITE_OK;\n      int isProxyStyle = (pFile->pMethod == &proxyIoMethods);\n      if( pArg==NULL || (const char *)pArg==0 ){\n        if( isProxyStyle ){\n          /* turn off proxy locking - not supported */\n          rc = SQLITE_ERROR /*SQLITE_PROTOCOL? SQLITE_MISUSE?*/;\n        }else{\n          /* turn off proxy locking - already off - NOOP */\n          rc = SQLITE_OK;\n        }\n      }else{\n        const char *proxyPath = (const char *)pArg;\n        if( isProxyStyle ){\n          proxyLockingContext *pCtx = \n            (proxyLockingContext*)pFile->lockingContext;\n          if( !strcmp(pArg, \":auto:\") \n           || (pCtx->lockProxyPath &&\n               !strncmp(pCtx->lockProxyPath, proxyPath, MAXPATHLEN))\n          ){\n            rc = SQLITE_OK;\n          }else{\n            rc = switchLockProxyPath(pFile, proxyPath);\n          }\n        }else{\n          /* turn on proxy file locking */\n          rc = proxyTransformUnixFile(pFile, proxyPath);\n        }\n      }\n      return rc;\n    }\n    default: {\n      assert( 0 );  /* The call assures that only valid opcodes are sent */\n    }\n  }\n  /*NOTREACHED*/\n  return SQLITE_ERROR;\n}\n\n/*\n** Within this division (the proxying locking implementation) the procedures\n** above this point are all utilities.  The lock-related methods of the\n** proxy-locking sqlite3_io_method object follow.\n*/\n\n\n/*\n** This routine checks if there is a RESERVED lock held on the specified\n** file by this or any other process. If such a lock is held, set *pResOut\n** to a non-zero value otherwise *pResOut is set to zero.  The return value\n** is set to SQLITE_OK unless an I/O error occurs during lock checking.\n*/\nstatic int proxyCheckReservedLock(sqlite3_file *id, int *pResOut) {\n  unixFile *pFile = (unixFile*)id;\n  int rc = proxyTakeConch(pFile);\n  if( rc==SQLITE_OK ){\n    proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext;\n    if( pCtx->conchHeld>0 ){\n      unixFile *proxy = pCtx->lockProxy;\n      return proxy->pMethod->xCheckReservedLock((sqlite3_file*)proxy, pResOut);\n    }else{ /* conchHeld < 0 is lockless */\n      pResOut=0;\n    }\n  }\n  return rc;\n}\n\n/*\n** Lock the file with the lock specified by parameter eFileLock - one\n** of the following:\n**\n**     (1) SHARED_LOCK\n**     (2) RESERVED_LOCK\n**     (3) PENDING_LOCK\n**     (4) EXCLUSIVE_LOCK\n**\n** Sometimes when requesting one lock state, additional lock states\n** are inserted in between.  The locking might fail on one of the later\n** transitions leaving the lock state different from what it started but\n** still short of its goal.  The following chart shows the allowed\n** transitions and the inserted intermediate states:\n**\n**    UNLOCKED -> SHARED\n**    SHARED -> RESERVED\n**    SHARED -> (PENDING) -> EXCLUSIVE\n**    RESERVED -> (PENDING) -> EXCLUSIVE\n**    PENDING -> EXCLUSIVE\n**\n** This routine will only increase a lock.  Use the sqlite3OsUnlock()\n** routine to lower a locking level.\n*/\nstatic int proxyLock(sqlite3_file *id, int eFileLock) {\n  unixFile *pFile = (unixFile*)id;\n  int rc = proxyTakeConch(pFile);\n  if( rc==SQLITE_OK ){\n    proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext;\n    if( pCtx->conchHeld>0 ){\n      unixFile *proxy = pCtx->lockProxy;\n      rc = proxy->pMethod->xLock((sqlite3_file*)proxy, eFileLock);\n      pFile->eFileLock = proxy->eFileLock;\n    }else{\n      /* conchHeld < 0 is lockless */\n    }\n  }\n  return rc;\n}\n\n\n/*\n** Lower the locking level on file descriptor pFile to eFileLock.  eFileLock\n** must be either NO_LOCK or SHARED_LOCK.\n**\n** If the locking level of the file descriptor is already at or below\n** the requested locking level, this routine is a no-op.\n*/\nstatic int proxyUnlock(sqlite3_file *id, int eFileLock) {\n  unixFile *pFile = (unixFile*)id;\n  int rc = proxyTakeConch(pFile);\n  if( rc==SQLITE_OK ){\n    proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext;\n    if( pCtx->conchHeld>0 ){\n      unixFile *proxy = pCtx->lockProxy;\n      rc = proxy->pMethod->xUnlock((sqlite3_file*)proxy, eFileLock);\n      pFile->eFileLock = proxy->eFileLock;\n    }else{\n      /* conchHeld < 0 is lockless */\n    }\n  }\n  return rc;\n}\n\n/*\n** Close a file that uses proxy locks.\n*/\nstatic int proxyClose(sqlite3_file *id) {\n  if( id ){\n    unixFile *pFile = (unixFile*)id;\n    proxyLockingContext *pCtx = (proxyLockingContext *)pFile->lockingContext;\n    unixFile *lockProxy = pCtx->lockProxy;\n    unixFile *conchFile = pCtx->conchFile;\n    int rc = SQLITE_OK;\n    \n    if( lockProxy ){\n      rc = lockProxy->pMethod->xUnlock((sqlite3_file*)lockProxy, NO_LOCK);\n      if( rc ) return rc;\n      rc = lockProxy->pMethod->xClose((sqlite3_file*)lockProxy);\n      if( rc ) return rc;\n      sqlite3_free(lockProxy);\n      pCtx->lockProxy = 0;\n    }\n    if( conchFile ){\n      if( pCtx->conchHeld ){\n        rc = proxyReleaseConch(pFile);\n        if( rc ) return rc;\n      }\n      rc = conchFile->pMethod->xClose((sqlite3_file*)conchFile);\n      if( rc ) return rc;\n      sqlite3_free(conchFile);\n    }\n    sqlite3DbFree(0, pCtx->lockProxyPath);\n    sqlite3_free(pCtx->conchFilePath);\n    sqlite3DbFree(0, pCtx->dbPath);\n    /* restore the original locking context and pMethod then close it */\n    pFile->lockingContext = pCtx->oldLockingContext;\n    pFile->pMethod = pCtx->pOldMethod;\n    sqlite3_free(pCtx);\n    return pFile->pMethod->xClose(id);\n  }\n  return SQLITE_OK;\n}\n\n\n\n#endif /* defined(__APPLE__) && SQLITE_ENABLE_LOCKING_STYLE */\n/*\n** The proxy locking style is intended for use with AFP filesystems.\n** And since AFP is only supported on MacOSX, the proxy locking is also\n** restricted to MacOSX.\n** \n**\n******************* End of the proxy lock implementation **********************\n******************************************************************************/\n\n/*\n** Initialize the operating system interface.\n**\n** This routine registers all VFS implementations for unix-like operating\n** systems.  This routine, and the sqlite3_os_end() routine that follows,\n** should be the only routines in this file that are visible from other\n** files.\n**\n** This routine is called once during SQLite initialization and by a\n** single thread.  The memory allocation and mutex subsystems have not\n** necessarily been initialized when this routine is called, and so they\n** should not be used.\n*/\nSQLITE_API int sqlite3_os_init(void){ \n  /* \n  ** The following macro defines an initializer for an sqlite3_vfs object.\n  ** The name of the VFS is NAME.  The pAppData is a pointer to a pointer\n  ** to the \"finder\" function.  (pAppData is a pointer to a pointer because\n  ** silly C90 rules prohibit a void* from being cast to a function pointer\n  ** and so we have to go through the intermediate pointer to avoid problems\n  ** when compiling with -pedantic-errors on GCC.)\n  **\n  ** The FINDER parameter to this macro is the name of the pointer to the\n  ** finder-function.  The finder-function returns a pointer to the\n  ** sqlite_io_methods object that implements the desired locking\n  ** behaviors.  See the division above that contains the IOMETHODS\n  ** macro for addition information on finder-functions.\n  **\n  ** Most finders simply return a pointer to a fixed sqlite3_io_methods\n  ** object.  But the \"autolockIoFinder\" available on MacOSX does a little\n  ** more than that; it looks at the filesystem type that hosts the \n  ** database file and tries to choose an locking method appropriate for\n  ** that filesystem time.\n  */\n  #define UNIXVFS(VFSNAME, FINDER) {                        \\\n    3,                    /* iVersion */                    \\\n    sizeof(unixFile),     /* szOsFile */                    \\\n    MAX_PATHNAME,         /* mxPathname */                  \\\n    0,                    /* pNext */                       \\\n    VFSNAME,              /* zName */                       \\\n    (void*)&FINDER,       /* pAppData */                    \\\n    unixOpen,             /* xOpen */                       \\\n    unixDelete,           /* xDelete */                     \\\n    unixAccess,           /* xAccess */                     \\\n    unixFullPathname,     /* xFullPathname */               \\\n    unixDlOpen,           /* xDlOpen */                     \\\n    unixDlError,          /* xDlError */                    \\\n    unixDlSym,            /* xDlSym */                      \\\n    unixDlClose,          /* xDlClose */                    \\\n    unixRandomness,       /* xRandomness */                 \\\n    unixSleep,            /* xSleep */                      \\\n    unixCurrentTime,      /* xCurrentTime */                \\\n    unixGetLastError,     /* xGetLastError */               \\\n    unixCurrentTimeInt64, /* xCurrentTimeInt64 */           \\\n    unixSetSystemCall,    /* xSetSystemCall */              \\\n    unixGetSystemCall,    /* xGetSystemCall */              \\\n    unixNextSystemCall,   /* xNextSystemCall */             \\\n  }\n\n  /*\n  ** All default VFSes for unix are contained in the following array.\n  **\n  ** Note that the sqlite3_vfs.pNext field of the VFS object is modified\n  ** by the SQLite core when the VFS is registered.  So the following\n  ** array cannot be const.\n  */\n  static sqlite3_vfs aVfs[] = {\n#if SQLITE_ENABLE_LOCKING_STYLE && (OS_VXWORKS || defined(__APPLE__))\n    UNIXVFS(\"unix\",          autolockIoFinder ),\n#else\n    UNIXVFS(\"unix\",          posixIoFinder ),\n#endif\n    UNIXVFS(\"unix-none\",     nolockIoFinder ),\n    UNIXVFS(\"unix-dotfile\",  dotlockIoFinder ),\n    UNIXVFS(\"unix-excl\",     posixIoFinder ),\n#if OS_VXWORKS\n    UNIXVFS(\"unix-namedsem\", semIoFinder ),\n#endif\n#if SQLITE_ENABLE_LOCKING_STYLE\n    UNIXVFS(\"unix-posix\",    posixIoFinder ),\n#if !OS_VXWORKS\n    UNIXVFS(\"unix-flock\",    flockIoFinder ),\n#endif\n#endif\n#if SQLITE_ENABLE_LOCKING_STYLE && defined(__APPLE__)\n    UNIXVFS(\"unix-afp\",      afpIoFinder ),\n    UNIXVFS(\"unix-nfs\",      nfsIoFinder ),\n    UNIXVFS(\"unix-proxy\",    proxyIoFinder ),\n#endif\n  };\n  unsigned int i;          /* Loop counter */\n\n  /* Register all VFSes defined in the aVfs[] array */\n  for(i=0; i<(sizeof(aVfs)/sizeof(sqlite3_vfs)); i++){\n    sqlite3_vfs_register(&aVfs[i], i==0);\n  }\n  return SQLITE_OK; \n}\n\n/*\n** Shutdown the operating system interface.\n**\n** Some operating systems might need to do some cleanup in this routine,\n** to release dynamically allocated objects.  But not on unix.\n** This routine is a no-op for unix.\n*/\nSQLITE_API int sqlite3_os_end(void){ \n  return SQLITE_OK; \n}\n \n#endif /* SQLITE_OS_UNIX */\n\n/************** End of os_unix.c *********************************************/\n/************** Begin file os_win.c ******************************************/\n/*\n** 2004 May 22\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n******************************************************************************\n**\n** This file contains code that is specific to windows.\n*/\n#if SQLITE_OS_WIN               /* This file is used for windows only */\n\n\n/*\n** A Note About Memory Allocation:\n**\n** This driver uses malloc()/free() directly rather than going through\n** the SQLite-wrappers sqlite3_malloc()/sqlite3_free().  Those wrappers\n** are designed for use on embedded systems where memory is scarce and\n** malloc failures happen frequently.  Win32 does not typically run on\n** embedded systems, and when it does the developers normally have bigger\n** problems to worry about than running out of memory.  So there is not\n** a compelling need to use the wrappers.\n**\n** But there is a good reason to not use the wrappers.  If we use the\n** wrappers then we will get simulated malloc() failures within this\n** driver.  And that causes all kinds of problems for our tests.  We\n** could enhance SQLite to deal with simulated malloc failures within\n** the OS driver, but the code to deal with those failure would not\n** be exercised on Linux (which does not need to malloc() in the driver)\n** and so we would have difficulty writing coverage tests for that\n** code.  Better to leave the code out, we think.\n**\n** The point of this discussion is as follows:  When creating a new\n** OS layer for an embedded system, if you use this file as an example,\n** avoid the use of malloc()/free().  Those routines work ok on windows\n** desktops but not so well in embedded systems.\n*/\n\n#include <winbase.h>\n\n#ifdef __CYGWIN__\n# include <sys/cygwin.h>\n#endif\n\n/*\n** Macros used to determine whether or not to use threads.\n*/\n#if defined(THREADSAFE) && THREADSAFE\n# define SQLITE_W32_THREADS 1\n#endif\n\n/*\n** Include code that is common to all os_*.c files\n*/\n/************** Include os_common.h in the middle of os_win.c ****************/\n/************** Begin file os_common.h ***************************************/\n/*\n** 2004 May 22\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n******************************************************************************\n**\n** This file contains macros and a little bit of code that is common to\n** all of the platform-specific files (os_*.c) and is #included into those\n** files.\n**\n** This file should be #included by the os_*.c files only.  It is not a\n** general purpose header file.\n*/\n#ifndef _OS_COMMON_H_\n#define _OS_COMMON_H_\n\n/*\n** At least two bugs have slipped in because we changed the MEMORY_DEBUG\n** macro to SQLITE_DEBUG and some older makefiles have not yet made the\n** switch.  The following code should catch this problem at compile-time.\n*/\n#ifdef MEMORY_DEBUG\n# error \"The MEMORY_DEBUG macro is obsolete.  Use SQLITE_DEBUG instead.\"\n#endif\n\n#ifdef SQLITE_DEBUG\nSQLITE_PRIVATE int sqlite3OSTrace = 0;\n#define OSTRACE(X)          if( sqlite3OSTrace ) sqlite3DebugPrintf X\n#else\n#define OSTRACE(X)\n#endif\n\n/*\n** Macros for performance tracing.  Normally turned off.  Only works\n** on i486 hardware.\n*/\n#ifdef SQLITE_PERFORMANCE_TRACE\n\n/* \n** hwtime.h contains inline assembler code for implementing \n** high-performance timing routines.\n*/\n/************** Include hwtime.h in the middle of os_common.h ****************/\n/************** Begin file hwtime.h ******************************************/\n/*\n** 2008 May 27\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n******************************************************************************\n**\n** This file contains inline asm code for retrieving \"high-performance\"\n** counters for x86 class CPUs.\n*/\n#ifndef _HWTIME_H_\n#define _HWTIME_H_\n\n/*\n** The following routine only works on pentium-class (or newer) processors.\n** It uses the RDTSC opcode to read the cycle count value out of the\n** processor and returns that value.  This can be used for high-res\n** profiling.\n*/\n#if (defined(__GNUC__) || defined(_MSC_VER)) && \\\n      (defined(i386) || defined(__i386__) || defined(_M_IX86))\n\n  #if defined(__GNUC__)\n\n  __inline__ sqlite_uint64 sqlite3Hwtime(void){\n     unsigned int lo, hi;\n     __asm__ __volatile__ (\"rdtsc\" : \"=a\" (lo), \"=d\" (hi));\n     return (sqlite_uint64)hi << 32 | lo;\n  }\n\n  #elif defined(_MSC_VER)\n\n  __declspec(naked) __inline sqlite_uint64 __cdecl sqlite3Hwtime(void){\n     __asm {\n        rdtsc\n        ret       ; return value at EDX:EAX\n     }\n  }\n\n  #endif\n\n#elif (defined(__GNUC__) && defined(__x86_64__))\n\n  __inline__ sqlite_uint64 sqlite3Hwtime(void){\n      unsigned long val;\n      __asm__ __volatile__ (\"rdtsc\" : \"=A\" (val));\n      return val;\n  }\n \n#elif (defined(__GNUC__) && defined(__ppc__))\n\n  __inline__ sqlite_uint64 sqlite3Hwtime(void){\n      unsigned long long retval;\n      unsigned long junk;\n      __asm__ __volatile__ (\"\\n\\\n          1:      mftbu   %1\\n\\\n                  mftb    %L0\\n\\\n                  mftbu   %0\\n\\\n                  cmpw    %0,%1\\n\\\n                  bne     1b\"\n                  : \"=r\" (retval), \"=r\" (junk));\n      return retval;\n  }\n\n#else\n\n  #error Need implementation of sqlite3Hwtime() for your platform.\n\n  /*\n  ** To compile without implementing sqlite3Hwtime() for your platform,\n  ** you can remove the above #error and use the following\n  ** stub function.  You will lose timing support for many\n  ** of the debugging and testing utilities, but it should at\n  ** least compile and run.\n  */\nSQLITE_PRIVATE   sqlite_uint64 sqlite3Hwtime(void){ return ((sqlite_uint64)0); }\n\n#endif\n\n#endif /* !defined(_HWTIME_H_) */\n\n/************** End of hwtime.h **********************************************/\n/************** Continuing where we left off in os_common.h ******************/\n\nstatic sqlite_uint64 g_start;\nstatic sqlite_uint64 g_elapsed;\n#define TIMER_START       g_start=sqlite3Hwtime()\n#define TIMER_END         g_elapsed=sqlite3Hwtime()-g_start\n#define TIMER_ELAPSED     g_elapsed\n#else\n#define TIMER_START\n#define TIMER_END\n#define TIMER_ELAPSED     ((sqlite_uint64)0)\n#endif\n\n/*\n** If we compile with the SQLITE_TEST macro set, then the following block\n** of code will give us the ability to simulate a disk I/O error.  This\n** is used for testing the I/O recovery logic.\n*/\n#ifdef SQLITE_TEST\nSQLITE_API int sqlite3_io_error_hit = 0;            /* Total number of I/O Errors */\nSQLITE_API int sqlite3_io_error_hardhit = 0;        /* Number of non-benign errors */\nSQLITE_API int sqlite3_io_error_pending = 0;        /* Count down to first I/O error */\nSQLITE_API int sqlite3_io_error_persist = 0;        /* True if I/O errors persist */\nSQLITE_API int sqlite3_io_error_benign = 0;         /* True if errors are benign */\nSQLITE_API int sqlite3_diskfull_pending = 0;\nSQLITE_API int sqlite3_diskfull = 0;\n#define SimulateIOErrorBenign(X) sqlite3_io_error_benign=(X)\n#define SimulateIOError(CODE)  \\\n  if( (sqlite3_io_error_persist && sqlite3_io_error_hit) \\\n       || sqlite3_io_error_pending-- == 1 )  \\\n              { local_ioerr(); CODE; }\nstatic void local_ioerr(){\n  IOTRACE((\"IOERR\\n\"));\n  sqlite3_io_error_hit++;\n  if( !sqlite3_io_error_benign ) sqlite3_io_error_hardhit++;\n}\n#define SimulateDiskfullError(CODE) \\\n   if( sqlite3_diskfull_pending ){ \\\n     if( sqlite3_diskfull_pending == 1 ){ \\\n       local_ioerr(); \\\n       sqlite3_diskfull = 1; \\\n       sqlite3_io_error_hit = 1; \\\n       CODE; \\\n     }else{ \\\n       sqlite3_diskfull_pending--; \\\n     } \\\n   }\n#else\n#define SimulateIOErrorBenign(X)\n#define SimulateIOError(A)\n#define SimulateDiskfullError(A)\n#endif\n\n/*\n** When testing, keep a count of the number of open files.\n*/\n#ifdef SQLITE_TEST\nSQLITE_API int sqlite3_open_file_count = 0;\n#define OpenCounter(X)  sqlite3_open_file_count+=(X)\n#else\n#define OpenCounter(X)\n#endif\n\n#endif /* !defined(_OS_COMMON_H_) */\n\n/************** End of os_common.h *******************************************/\n/************** Continuing where we left off in os_win.c *********************/\n\n/*\n** Some microsoft compilers lack this definition.\n*/\n#ifndef INVALID_FILE_ATTRIBUTES\n# define INVALID_FILE_ATTRIBUTES ((DWORD)-1) \n#endif\n\n/*\n** Determine if we are dealing with WindowsCE - which has a much\n** reduced API.\n*/\n#if SQLITE_OS_WINCE\n# define AreFileApisANSI() 1\n# define FormatMessageW(a,b,c,d,e,f,g) 0\n#endif\n\n/* Forward references */\ntypedef struct winShm winShm;           /* A connection to shared-memory */\ntypedef struct winShmNode winShmNode;   /* A region of shared-memory */\n\n/*\n** WinCE lacks native support for file locking so we have to fake it\n** with some code of our own.\n*/\n#if SQLITE_OS_WINCE\ntypedef struct winceLock {\n  int nReaders;       /* Number of reader locks obtained */\n  BOOL bPending;      /* Indicates a pending lock has been obtained */\n  BOOL bReserved;     /* Indicates a reserved lock has been obtained */\n  BOOL bExclusive;    /* Indicates an exclusive lock has been obtained */\n} winceLock;\n#endif\n\n/*\n** The winFile structure is a subclass of sqlite3_file* specific to the win32\n** portability layer.\n*/\ntypedef struct winFile winFile;\nstruct winFile {\n  const sqlite3_io_methods *pMethod; /*** Must be first ***/\n  sqlite3_vfs *pVfs;      /* The VFS used to open this file */\n  HANDLE h;               /* Handle for accessing the file */\n  unsigned char locktype; /* Type of lock currently held on this file */\n  short sharedLockByte;   /* Randomly chosen byte used as a shared lock */\n  DWORD lastErrno;        /* The Windows errno from the last I/O error */\n  DWORD sectorSize;       /* Sector size of the device file is on */\n  winShm *pShm;           /* Instance of shared memory on this file */\n  const char *zPath;      /* Full pathname of this file */\n  int szChunk;            /* Chunk size configured by FCNTL_CHUNK_SIZE */\n#if SQLITE_OS_WINCE\n  WCHAR *zDeleteOnClose;  /* Name of file to delete when closing */\n  HANDLE hMutex;          /* Mutex used to control access to shared lock */  \n  HANDLE hShared;         /* Shared memory segment used for locking */\n  winceLock local;        /* Locks obtained by this instance of winFile */\n  winceLock *shared;      /* Global shared lock memory for the file  */\n#endif\n};\n\n/*\n** Forward prototypes.\n*/\nstatic int getSectorSize(\n    sqlite3_vfs *pVfs,\n    const char *zRelative     /* UTF-8 file name */\n);\n\n/*\n** The following variable is (normally) set once and never changes\n** thereafter.  It records whether the operating system is Win95\n** or WinNT.\n**\n** 0:   Operating system unknown.\n** 1:   Operating system is Win95.\n** 2:   Operating system is WinNT.\n**\n** In order to facilitate testing on a WinNT system, the test fixture\n** can manually set this value to 1 to emulate Win98 behavior.\n*/\n#ifdef SQLITE_TEST\nSQLITE_API int sqlite3_os_type = 0;\n#else\nstatic int sqlite3_os_type = 0;\n#endif\n\n/*\n** Return true (non-zero) if we are running under WinNT, Win2K, WinXP,\n** or WinCE.  Return false (zero) for Win95, Win98, or WinME.\n**\n** Here is an interesting observation:  Win95, Win98, and WinME lack\n** the LockFileEx() API.  But we can still statically link against that\n** API as long as we don't call it when running Win95/98/ME.  A call to\n** this routine is used to determine if the host is Win95/98/ME or\n** WinNT/2K/XP so that we will know whether or not we can safely call\n** the LockFileEx() API.\n*/\n#if SQLITE_OS_WINCE\n# define isNT()  (1)\n#else\n  static int isNT(void){\n    if( sqlite3_os_type==0 ){\n      OSVERSIONINFO sInfo;\n      sInfo.dwOSVersionInfoSize = sizeof(sInfo);\n      GetVersionEx(&sInfo);\n      sqlite3_os_type = sInfo.dwPlatformId==VER_PLATFORM_WIN32_NT ? 2 : 1;\n    }\n    return sqlite3_os_type==2;\n  }\n#endif /* SQLITE_OS_WINCE */\n\n/*\n** Convert a UTF-8 string to microsoft unicode (UTF-16?). \n**\n** Space to hold the returned string is obtained from malloc.\n*/\nstatic WCHAR *utf8ToUnicode(const char *zFilename){\n  int nChar;\n  WCHAR *zWideFilename;\n\n  nChar = MultiByteToWideChar(CP_UTF8, 0, zFilename, -1, NULL, 0);\n  zWideFilename = malloc( nChar*sizeof(zWideFilename[0]) );\n  if( zWideFilename==0 ){\n    return 0;\n  }\n  nChar = MultiByteToWideChar(CP_UTF8, 0, zFilename, -1, zWideFilename, nChar);\n  if( nChar==0 ){\n    free(zWideFilename);\n    zWideFilename = 0;\n  }\n  return zWideFilename;\n}\n\n/*\n** Convert microsoft unicode to UTF-8.  Space to hold the returned string is\n** obtained from malloc().\n*/\nstatic char *unicodeToUtf8(const WCHAR *zWideFilename){\n  int nByte;\n  char *zFilename;\n\n  nByte = WideCharToMultiByte(CP_UTF8, 0, zWideFilename, -1, 0, 0, 0, 0);\n  zFilename = malloc( nByte );\n  if( zFilename==0 ){\n    return 0;\n  }\n  nByte = WideCharToMultiByte(CP_UTF8, 0, zWideFilename, -1, zFilename, nByte,\n                              0, 0);\n  if( nByte == 0 ){\n    free(zFilename);\n    zFilename = 0;\n  }\n  return zFilename;\n}\n\n/*\n** Convert an ansi string to microsoft unicode, based on the\n** current codepage settings for file apis.\n** \n** Space to hold the returned string is obtained\n** from malloc.\n*/\nstatic WCHAR *mbcsToUnicode(const char *zFilename){\n  int nByte;\n  WCHAR *zMbcsFilename;\n  int codepage = AreFileApisANSI() ? CP_ACP : CP_OEMCP;\n\n  nByte = MultiByteToWideChar(codepage, 0, zFilename, -1, NULL,0)*sizeof(WCHAR);\n  zMbcsFilename = malloc( nByte*sizeof(zMbcsFilename[0]) );\n  if( zMbcsFilename==0 ){\n    return 0;\n  }\n  nByte = MultiByteToWideChar(codepage, 0, zFilename, -1, zMbcsFilename, nByte);\n  if( nByte==0 ){\n    free(zMbcsFilename);\n    zMbcsFilename = 0;\n  }\n  return zMbcsFilename;\n}\n\n/*\n** Convert microsoft unicode to multibyte character string, based on the\n** user's Ansi codepage.\n**\n** Space to hold the returned string is obtained from\n** malloc().\n*/\nstatic char *unicodeToMbcs(const WCHAR *zWideFilename){\n  int nByte;\n  char *zFilename;\n  int codepage = AreFileApisANSI() ? CP_ACP : CP_OEMCP;\n\n  nByte = WideCharToMultiByte(codepage, 0, zWideFilename, -1, 0, 0, 0, 0);\n  zFilename = malloc( nByte );\n  if( zFilename==0 ){\n    return 0;\n  }\n  nByte = WideCharToMultiByte(codepage, 0, zWideFilename, -1, zFilename, nByte,\n                              0, 0);\n  if( nByte == 0 ){\n    free(zFilename);\n    zFilename = 0;\n  }\n  return zFilename;\n}\n\n/*\n** Convert multibyte character string to UTF-8.  Space to hold the\n** returned string is obtained from malloc().\n*/\nSQLITE_API char *sqlite3_win32_mbcs_to_utf8(const char *zFilename){\n  char *zFilenameUtf8;\n  WCHAR *zTmpWide;\n\n  zTmpWide = mbcsToUnicode(zFilename);\n  if( zTmpWide==0 ){\n    return 0;\n  }\n  zFilenameUtf8 = unicodeToUtf8(zTmpWide);\n  free(zTmpWide);\n  return zFilenameUtf8;\n}\n\n/*\n** Convert UTF-8 to multibyte character string.  Space to hold the \n** returned string is obtained from malloc().\n*/\nstatic char *utf8ToMbcs(const char *zFilename){\n  char *zFilenameMbcs;\n  WCHAR *zTmpWide;\n\n  zTmpWide = utf8ToUnicode(zFilename);\n  if( zTmpWide==0 ){\n    return 0;\n  }\n  zFilenameMbcs = unicodeToMbcs(zTmpWide);\n  free(zTmpWide);\n  return zFilenameMbcs;\n}\n\n#if SQLITE_OS_WINCE\n/*************************************************************************\n** This section contains code for WinCE only.\n*/\n/*\n** WindowsCE does not have a localtime() function.  So create a\n** substitute.\n*/\nstruct tm *__cdecl localtime(const time_t *t)\n{\n  static struct tm y;\n  FILETIME uTm, lTm;\n  SYSTEMTIME pTm;\n  sqlite3_int64 t64;\n  t64 = *t;\n  t64 = (t64 + 11644473600)*10000000;\n  uTm.dwLowDateTime = (DWORD)(t64 & 0xFFFFFFFF);\n  uTm.dwHighDateTime= (DWORD)(t64 >> 32);\n  FileTimeToLocalFileTime(&uTm,&lTm);\n  FileTimeToSystemTime(&lTm,&pTm);\n  y.tm_year = pTm.wYear - 1900;\n  y.tm_mon = pTm.wMonth - 1;\n  y.tm_wday = pTm.wDayOfWeek;\n  y.tm_mday = pTm.wDay;\n  y.tm_hour = pTm.wHour;\n  y.tm_min = pTm.wMinute;\n  y.tm_sec = pTm.wSecond;\n  return &y;\n}\n\n/* This will never be called, but defined to make the code compile */\n#define GetTempPathA(a,b)\n\n#define LockFile(a,b,c,d,e)       winceLockFile(&a, b, c, d, e)\n#define UnlockFile(a,b,c,d,e)     winceUnlockFile(&a, b, c, d, e)\n#define LockFileEx(a,b,c,d,e,f)   winceLockFileEx(&a, b, c, d, e, f)\n\n#define HANDLE_TO_WINFILE(a) (winFile*)&((char*)a)[-(int)offsetof(winFile,h)]\n\n/*\n** Acquire a lock on the handle h\n*/\nstatic void winceMutexAcquire(HANDLE h){\n   DWORD dwErr;\n   do {\n     dwErr = WaitForSingleObject(h, INFINITE);\n   } while (dwErr != WAIT_OBJECT_0 && dwErr != WAIT_ABANDONED);\n}\n/*\n** Release a lock acquired by winceMutexAcquire()\n*/\n#define winceMutexRelease(h) ReleaseMutex(h)\n\n/*\n** Create the mutex and shared memory used for locking in the file\n** descriptor pFile\n*/\nstatic BOOL winceCreateLock(const char *zFilename, winFile *pFile){\n  WCHAR *zTok;\n  WCHAR *zName = utf8ToUnicode(zFilename);\n  BOOL bInit = TRUE;\n\n  /* Initialize the local lockdata */\n  ZeroMemory(&pFile->local, sizeof(pFile->local));\n\n  /* Replace the backslashes from the filename and lowercase it\n  ** to derive a mutex name. */\n  zTok = CharLowerW(zName);\n  for (;*zTok;zTok++){\n    if (*zTok == '\\\\') *zTok = '_';\n  }\n\n  /* Create/open the named mutex */\n  pFile->hMutex = CreateMutexW(NULL, FALSE, zName);\n  if (!pFile->hMutex){\n    pFile->lastErrno = GetLastError();\n    free(zName);\n    return FALSE;\n  }\n\n  /* Acquire the mutex before continuing */\n  winceMutexAcquire(pFile->hMutex);\n  \n  /* Since the names of named mutexes, semaphores, file mappings etc are \n  ** case-sensitive, take advantage of that by uppercasing the mutex name\n  ** and using that as the shared filemapping name.\n  */\n  CharUpperW(zName);\n  pFile->hShared = CreateFileMappingW(INVALID_HANDLE_VALUE, NULL,\n                                       PAGE_READWRITE, 0, sizeof(winceLock),\n                                       zName);  \n\n  /* Set a flag that indicates we're the first to create the memory so it \n  ** must be zero-initialized */\n  if (GetLastError() == ERROR_ALREADY_EXISTS){\n    bInit = FALSE;\n  }\n\n  free(zName);\n\n  /* If we succeeded in making the shared memory handle, map it. */\n  if (pFile->hShared){\n    pFile->shared = (winceLock*)MapViewOfFile(pFile->hShared, \n             FILE_MAP_READ|FILE_MAP_WRITE, 0, 0, sizeof(winceLock));\n    /* If mapping failed, close the shared memory handle and erase it */\n    if (!pFile->shared){\n      pFile->lastErrno = GetLastError();\n      CloseHandle(pFile->hShared);\n      pFile->hShared = NULL;\n    }\n  }\n\n  /* If shared memory could not be created, then close the mutex and fail */\n  if (pFile->hShared == NULL){\n    winceMutexRelease(pFile->hMutex);\n    CloseHandle(pFile->hMutex);\n    pFile->hMutex = NULL;\n    return FALSE;\n  }\n  \n  /* Initialize the shared memory if we're supposed to */\n  if (bInit) {\n    ZeroMemory(pFile->shared, sizeof(winceLock));\n  }\n\n  winceMutexRelease(pFile->hMutex);\n  return TRUE;\n}\n\n/*\n** Destroy the part of winFile that deals with wince locks\n*/\nstatic void winceDestroyLock(winFile *pFile){\n  if (pFile->hMutex){\n    /* Acquire the mutex */\n    winceMutexAcquire(pFile->hMutex);\n\n    /* The following blocks should probably assert in debug mode, but they\n       are to cleanup in case any locks remained open */\n    if (pFile->local.nReaders){\n      pFile->shared->nReaders --;\n    }\n    if (pFile->local.bReserved){\n      pFile->shared->bReserved = FALSE;\n    }\n    if (pFile->local.bPending){\n      pFile->shared->bPending = FALSE;\n    }\n    if (pFile->local.bExclusive){\n      pFile->shared->bExclusive = FALSE;\n    }\n\n    /* De-reference and close our copy of the shared memory handle */\n    UnmapViewOfFile(pFile->shared);\n    CloseHandle(pFile->hShared);\n\n    /* Done with the mutex */\n    winceMutexRelease(pFile->hMutex);    \n    CloseHandle(pFile->hMutex);\n    pFile->hMutex = NULL;\n  }\n}\n\n/* \n** An implementation of the LockFile() API of windows for wince\n*/\nstatic BOOL winceLockFile(\n  HANDLE *phFile,\n  DWORD dwFileOffsetLow,\n  DWORD dwFileOffsetHigh,\n  DWORD nNumberOfBytesToLockLow,\n  DWORD nNumberOfBytesToLockHigh\n){\n  winFile *pFile = HANDLE_TO_WINFILE(phFile);\n  BOOL bReturn = FALSE;\n\n  UNUSED_PARAMETER(dwFileOffsetHigh);\n  UNUSED_PARAMETER(nNumberOfBytesToLockHigh);\n\n  if (!pFile->hMutex) return TRUE;\n  winceMutexAcquire(pFile->hMutex);\n\n  /* Wanting an exclusive lock? */\n  if (dwFileOffsetLow == (DWORD)SHARED_FIRST\n       && nNumberOfBytesToLockLow == (DWORD)SHARED_SIZE){\n    if (pFile->shared->nReaders == 0 && pFile->shared->bExclusive == 0){\n       pFile->shared->bExclusive = TRUE;\n       pFile->local.bExclusive = TRUE;\n       bReturn = TRUE;\n    }\n  }\n\n  /* Want a read-only lock? */\n  else if (dwFileOffsetLow == (DWORD)SHARED_FIRST &&\n           nNumberOfBytesToLockLow == 1){\n    if (pFile->shared->bExclusive == 0){\n      pFile->local.nReaders ++;\n      if (pFile->local.nReaders == 1){\n        pFile->shared->nReaders ++;\n      }\n      bReturn = TRUE;\n    }\n  }\n\n  /* Want a pending lock? */\n  else if (dwFileOffsetLow == (DWORD)PENDING_BYTE && nNumberOfBytesToLockLow == 1){\n    /* If no pending lock has been acquired, then acquire it */\n    if (pFile->shared->bPending == 0) {\n      pFile->shared->bPending = TRUE;\n      pFile->local.bPending = TRUE;\n      bReturn = TRUE;\n    }\n  }\n\n  /* Want a reserved lock? */\n  else if (dwFileOffsetLow == (DWORD)RESERVED_BYTE && nNumberOfBytesToLockLow == 1){\n    if (pFile->shared->bReserved == 0) {\n      pFile->shared->bReserved = TRUE;\n      pFile->local.bReserved = TRUE;\n      bReturn = TRUE;\n    }\n  }\n\n  winceMutexRelease(pFile->hMutex);\n  return bReturn;\n}\n\n/*\n** An implementation of the UnlockFile API of windows for wince\n*/\nstatic BOOL winceUnlockFile(\n  HANDLE *phFile,\n  DWORD dwFileOffsetLow,\n  DWORD dwFileOffsetHigh,\n  DWORD nNumberOfBytesToUnlockLow,\n  DWORD nNumberOfBytesToUnlockHigh\n){\n  winFile *pFile = HANDLE_TO_WINFILE(phFile);\n  BOOL bReturn = FALSE;\n\n  UNUSED_PARAMETER(dwFileOffsetHigh);\n  UNUSED_PARAMETER(nNumberOfBytesToUnlockHigh);\n\n  if (!pFile->hMutex) return TRUE;\n  winceMutexAcquire(pFile->hMutex);\n\n  /* Releasing a reader lock or an exclusive lock */\n  if (dwFileOffsetLow == (DWORD)SHARED_FIRST){\n    /* Did we have an exclusive lock? */\n    if (pFile->local.bExclusive){\n      assert(nNumberOfBytesToUnlockLow == (DWORD)SHARED_SIZE);\n      pFile->local.bExclusive = FALSE;\n      pFile->shared->bExclusive = FALSE;\n      bReturn = TRUE;\n    }\n\n    /* Did we just have a reader lock? */\n    else if (pFile->local.nReaders){\n      assert(nNumberOfBytesToUnlockLow == (DWORD)SHARED_SIZE || nNumberOfBytesToUnlockLow == 1);\n      pFile->local.nReaders --;\n      if (pFile->local.nReaders == 0)\n      {\n        pFile->shared->nReaders --;\n      }\n      bReturn = TRUE;\n    }\n  }\n\n  /* Releasing a pending lock */\n  else if (dwFileOffsetLow == (DWORD)PENDING_BYTE && nNumberOfBytesToUnlockLow == 1){\n    if (pFile->local.bPending){\n      pFile->local.bPending = FALSE;\n      pFile->shared->bPending = FALSE;\n      bReturn = TRUE;\n    }\n  }\n  /* Releasing a reserved lock */\n  else if (dwFileOffsetLow == (DWORD)RESERVED_BYTE && nNumberOfBytesToUnlockLow == 1){\n    if (pFile->local.bReserved) {\n      pFile->local.bReserved = FALSE;\n      pFile->shared->bReserved = FALSE;\n      bReturn = TRUE;\n    }\n  }\n\n  winceMutexRelease(pFile->hMutex);\n  return bReturn;\n}\n\n/*\n** An implementation of the LockFileEx() API of windows for wince\n*/\nstatic BOOL winceLockFileEx(\n  HANDLE *phFile,\n  DWORD dwFlags,\n  DWORD dwReserved,\n  DWORD nNumberOfBytesToLockLow,\n  DWORD nNumberOfBytesToLockHigh,\n  LPOVERLAPPED lpOverlapped\n){\n  UNUSED_PARAMETER(dwReserved);\n  UNUSED_PARAMETER(nNumberOfBytesToLockHigh);\n\n  /* If the caller wants a shared read lock, forward this call\n  ** to winceLockFile */\n  if (lpOverlapped->Offset == (DWORD)SHARED_FIRST &&\n      dwFlags == 1 &&\n      nNumberOfBytesToLockLow == (DWORD)SHARED_SIZE){\n    return winceLockFile(phFile, SHARED_FIRST, 0, 1, 0);\n  }\n  return FALSE;\n}\n/*\n** End of the special code for wince\n*****************************************************************************/\n#endif /* SQLITE_OS_WINCE */\n\n/*****************************************************************************\n** The next group of routines implement the I/O methods specified\n** by the sqlite3_io_methods object.\n******************************************************************************/\n\n/*\n** Some microsoft compilers lack this definition.\n*/\n#ifndef INVALID_SET_FILE_POINTER\n# define INVALID_SET_FILE_POINTER ((DWORD)-1)\n#endif\n\n/*\n** Move the current position of the file handle passed as the first \n** argument to offset iOffset within the file. If successful, return 0. \n** Otherwise, set pFile->lastErrno and return non-zero.\n*/\nstatic int seekWinFile(winFile *pFile, sqlite3_int64 iOffset){\n  LONG upperBits;                 /* Most sig. 32 bits of new offset */\n  LONG lowerBits;                 /* Least sig. 32 bits of new offset */\n  DWORD dwRet;                    /* Value returned by SetFilePointer() */\n\n  upperBits = (LONG)((iOffset>>32) & 0x7fffffff);\n  lowerBits = (LONG)(iOffset & 0xffffffff);\n\n  /* API oddity: If successful, SetFilePointer() returns a dword \n  ** containing the lower 32-bits of the new file-offset. Or, if it fails,\n  ** it returns INVALID_SET_FILE_POINTER. However according to MSDN, \n  ** INVALID_SET_FILE_POINTER may also be a valid new offset. So to determine \n  ** whether an error has actually occured, it is also necessary to call \n  ** GetLastError().\n  */\n  dwRet = SetFilePointer(pFile->h, lowerBits, &upperBits, FILE_BEGIN);\n  if( (dwRet==INVALID_SET_FILE_POINTER && GetLastError()!=NO_ERROR) ){\n    pFile->lastErrno = GetLastError();\n    return 1;\n  }\n\n  return 0;\n}\n\n/*\n** Close a file.\n**\n** It is reported that an attempt to close a handle might sometimes\n** fail.  This is a very unreasonable result, but windows is notorious\n** for being unreasonable so I do not doubt that it might happen.  If\n** the close fails, we pause for 100 milliseconds and try again.  As\n** many as MX_CLOSE_ATTEMPT attempts to close the handle are made before\n** giving up and returning an error.\n*/\n#define MX_CLOSE_ATTEMPT 3\nstatic int winClose(sqlite3_file *id){\n  int rc, cnt = 0;\n  winFile *pFile = (winFile*)id;\n\n  assert( id!=0 );\n  assert( pFile->pShm==0 );\n  OSTRACE((\"CLOSE %d\\n\", pFile->h));\n  do{\n    rc = CloseHandle(pFile->h);\n    /* SimulateIOError( rc=0; cnt=MX_CLOSE_ATTEMPT; ); */\n  }while( rc==0 && ++cnt < MX_CLOSE_ATTEMPT && (Sleep(100), 1) );\n#if SQLITE_OS_WINCE\n#define WINCE_DELETION_ATTEMPTS 3\n  winceDestroyLock(pFile);\n  if( pFile->zDeleteOnClose ){\n    int cnt = 0;\n    while(\n           DeleteFileW(pFile->zDeleteOnClose)==0\n        && GetFileAttributesW(pFile->zDeleteOnClose)!=0xffffffff \n        && cnt++ < WINCE_DELETION_ATTEMPTS\n    ){\n       Sleep(100);  /* Wait a little before trying again */\n    }\n    free(pFile->zDeleteOnClose);\n  }\n#endif\n  OSTRACE((\"CLOSE %d %s\\n\", pFile->h, rc ? \"ok\" : \"failed\"));\n  OpenCounter(-1);\n  return rc ? SQLITE_OK : SQLITE_IOERR;\n}\n\n/*\n** Read data from a file into a buffer.  Return SQLITE_OK if all\n** bytes were read successfully and SQLITE_IOERR if anything goes\n** wrong.\n*/\nstatic int winRead(\n  sqlite3_file *id,          /* File to read from */\n  void *pBuf,                /* Write content into this buffer */\n  int amt,                   /* Number of bytes to read */\n  sqlite3_int64 offset       /* Begin reading at this offset */\n){\n  winFile *pFile = (winFile*)id;  /* file handle */\n  DWORD nRead;                    /* Number of bytes actually read from file */\n\n  assert( id!=0 );\n  SimulateIOError(return SQLITE_IOERR_READ);\n  OSTRACE((\"READ %d lock=%d\\n\", pFile->h, pFile->locktype));\n\n  if( seekWinFile(pFile, offset) ){\n    return SQLITE_FULL;\n  }\n  if( !ReadFile(pFile->h, pBuf, amt, &nRead, 0) ){\n    pFile->lastErrno = GetLastError();\n    return SQLITE_IOERR_READ;\n  }\n  if( nRead<(DWORD)amt ){\n    /* Unread parts of the buffer must be zero-filled */\n    memset(&((char*)pBuf)[nRead], 0, amt-nRead);\n    return SQLITE_IOERR_SHORT_READ;\n  }\n\n  return SQLITE_OK;\n}\n\n/*\n** Write data from a buffer into a file.  Return SQLITE_OK on success\n** or some other error code on failure.\n*/\nstatic int winWrite(\n  sqlite3_file *id,               /* File to write into */\n  const void *pBuf,               /* The bytes to be written */\n  int amt,                        /* Number of bytes to write */\n  sqlite3_int64 offset            /* Offset into the file to begin writing at */\n){\n  int rc;                         /* True if error has occured, else false */\n  winFile *pFile = (winFile*)id;  /* File handle */\n\n  assert( amt>0 );\n  assert( pFile );\n  SimulateIOError(return SQLITE_IOERR_WRITE);\n  SimulateDiskfullError(return SQLITE_FULL);\n\n  OSTRACE((\"WRITE %d lock=%d\\n\", pFile->h, pFile->locktype));\n\n  rc = seekWinFile(pFile, offset);\n  if( rc==0 ){\n    u8 *aRem = (u8 *)pBuf;        /* Data yet to be written */\n    int nRem = amt;               /* Number of bytes yet to be written */\n    DWORD nWrite;                 /* Bytes written by each WriteFile() call */\n\n    while( nRem>0 && WriteFile(pFile->h, aRem, nRem, &nWrite, 0) && nWrite>0 ){\n      aRem += nWrite;\n      nRem -= nWrite;\n    }\n    if( nRem>0 ){\n      pFile->lastErrno = GetLastError();\n      rc = 1;\n    }\n  }\n\n  if( rc ){\n    if( pFile->lastErrno==ERROR_HANDLE_DISK_FULL ){\n      return SQLITE_FULL;\n    }\n    return SQLITE_IOERR_WRITE;\n  }\n  return SQLITE_OK;\n}\n\n/*\n** Truncate an open file to a specified size\n*/\nstatic int winTruncate(sqlite3_file *id, sqlite3_int64 nByte){\n  winFile *pFile = (winFile*)id;  /* File handle object */\n  int rc = SQLITE_OK;             /* Return code for this function */\n\n  assert( pFile );\n\n  OSTRACE((\"TRUNCATE %d %lld\\n\", pFile->h, nByte));\n  SimulateIOError(return SQLITE_IOERR_TRUNCATE);\n\n  /* If the user has configured a chunk-size for this file, truncate the\n  ** file so that it consists of an integer number of chunks (i.e. the\n  ** actual file size after the operation may be larger than the requested\n  ** size).\n  */\n  if( pFile->szChunk ){\n    nByte = ((nByte + pFile->szChunk - 1)/pFile->szChunk) * pFile->szChunk;\n  }\n\n  /* SetEndOfFile() returns non-zero when successful, or zero when it fails. */\n  if( seekWinFile(pFile, nByte) ){\n    rc = SQLITE_IOERR_TRUNCATE;\n  }else if( 0==SetEndOfFile(pFile->h) ){\n    pFile->lastErrno = GetLastError();\n    rc = SQLITE_IOERR_TRUNCATE;\n  }\n\n  OSTRACE((\"TRUNCATE %d %lld %s\\n\", pFile->h, nByte, rc ? \"failed\" : \"ok\"));\n  return rc;\n}\n\n#ifdef SQLITE_TEST\n/*\n** Count the number of fullsyncs and normal syncs.  This is used to test\n** that syncs and fullsyncs are occuring at the right times.\n*/\nSQLITE_API int sqlite3_sync_count = 0;\nSQLITE_API int sqlite3_fullsync_count = 0;\n#endif\n\n/*\n** Make sure all writes to a particular file are committed to disk.\n*/\nstatic int winSync(sqlite3_file *id, int flags){\n#if !defined(NDEBUG) || !defined(SQLITE_NO_SYNC) || defined(SQLITE_DEBUG)\n  winFile *pFile = (winFile*)id;\n#else\n  UNUSED_PARAMETER(id);\n#endif\n\n  assert( pFile );\n  /* Check that one of SQLITE_SYNC_NORMAL or FULL was passed */\n  assert((flags&0x0F)==SQLITE_SYNC_NORMAL\n      || (flags&0x0F)==SQLITE_SYNC_FULL\n  );\n\n  OSTRACE((\"SYNC %d lock=%d\\n\", pFile->h, pFile->locktype));\n\n#ifndef SQLITE_TEST\n  UNUSED_PARAMETER(flags);\n#else\n  if( flags & SQLITE_SYNC_FULL ){\n    sqlite3_fullsync_count++;\n  }\n  sqlite3_sync_count++;\n#endif\n\n  /* Unix cannot, but some systems may return SQLITE_FULL from here. This\n  ** line is to test that doing so does not cause any problems.\n  */\n  SimulateDiskfullError( return SQLITE_FULL );\n  SimulateIOError( return SQLITE_IOERR; );\n\n  /* If we compiled with the SQLITE_NO_SYNC flag, then syncing is a\n  ** no-op\n  */\n#ifdef SQLITE_NO_SYNC\n  return SQLITE_OK;\n#else\n  if( FlushFileBuffers(pFile->h) ){\n    return SQLITE_OK;\n  }else{\n    pFile->lastErrno = GetLastError();\n    return SQLITE_IOERR;\n  }\n#endif\n}\n\n/*\n** Determine the current size of a file in bytes\n*/\nstatic int winFileSize(sqlite3_file *id, sqlite3_int64 *pSize){\n  DWORD upperBits;\n  DWORD lowerBits;\n  winFile *pFile = (winFile*)id;\n  DWORD error;\n\n  assert( id!=0 );\n  SimulateIOError(return SQLITE_IOERR_FSTAT);\n  lowerBits = GetFileSize(pFile->h, &upperBits);\n  if(   (lowerBits == INVALID_FILE_SIZE)\n     && ((error = GetLastError()) != NO_ERROR) )\n  {\n    pFile->lastErrno = error;\n    return SQLITE_IOERR_FSTAT;\n  }\n  *pSize = (((sqlite3_int64)upperBits)<<32) + lowerBits;\n  return SQLITE_OK;\n}\n\n/*\n** LOCKFILE_FAIL_IMMEDIATELY is undefined on some Windows systems.\n*/\n#ifndef LOCKFILE_FAIL_IMMEDIATELY\n# define LOCKFILE_FAIL_IMMEDIATELY 1\n#endif\n\n/*\n** Acquire a reader lock.\n** Different API routines are called depending on whether or not this\n** is Win95 or WinNT.\n*/\nstatic int getReadLock(winFile *pFile){\n  int res;\n  if( isNT() ){\n    OVERLAPPED ovlp;\n    ovlp.Offset = SHARED_FIRST;\n    ovlp.OffsetHigh = 0;\n    ovlp.hEvent = 0;\n    res = LockFileEx(pFile->h, LOCKFILE_FAIL_IMMEDIATELY,\n                     0, SHARED_SIZE, 0, &ovlp);\n/* isNT() is 1 if SQLITE_OS_WINCE==1, so this else is never executed. \n*/\n#if SQLITE_OS_WINCE==0\n  }else{\n    int lk;\n    sqlite3_randomness(sizeof(lk), &lk);\n    pFile->sharedLockByte = (short)((lk & 0x7fffffff)%(SHARED_SIZE - 1));\n    res = LockFile(pFile->h, SHARED_FIRST+pFile->sharedLockByte, 0, 1, 0);\n#endif\n  }\n  if( res == 0 ){\n    pFile->lastErrno = GetLastError();\n  }\n  return res;\n}\n\n/*\n** Undo a readlock\n*/\nstatic int unlockReadLock(winFile *pFile){\n  int res;\n  if( isNT() ){\n    res = UnlockFile(pFile->h, SHARED_FIRST, 0, SHARED_SIZE, 0);\n/* isNT() is 1 if SQLITE_OS_WINCE==1, so this else is never executed. \n*/\n#if SQLITE_OS_WINCE==0\n  }else{\n    res = UnlockFile(pFile->h, SHARED_FIRST + pFile->sharedLockByte, 0, 1, 0);\n#endif\n  }\n  if( res == 0 ){\n    pFile->lastErrno = GetLastError();\n  }\n  return res;\n}\n\n/*\n** Lock the file with the lock specified by parameter locktype - one\n** of the following:\n**\n**     (1) SHARED_LOCK\n**     (2) RESERVED_LOCK\n**     (3) PENDING_LOCK\n**     (4) EXCLUSIVE_LOCK\n**\n** Sometimes when requesting one lock state, additional lock states\n** are inserted in between.  The locking might fail on one of the later\n** transitions leaving the lock state different from what it started but\n** still short of its goal.  The following chart shows the allowed\n** transitions and the inserted intermediate states:\n**\n**    UNLOCKED -> SHARED\n**    SHARED -> RESERVED\n**    SHARED -> (PENDING) -> EXCLUSIVE\n**    RESERVED -> (PENDING) -> EXCLUSIVE\n**    PENDING -> EXCLUSIVE\n**\n** This routine will only increase a lock.  The winUnlock() routine\n** erases all locks at once and returns us immediately to locking level 0.\n** It is not possible to lower the locking level one step at a time.  You\n** must go straight to locking level 0.\n*/\nstatic int winLock(sqlite3_file *id, int locktype){\n  int rc = SQLITE_OK;    /* Return code from subroutines */\n  int res = 1;           /* Result of a windows lock call */\n  int newLocktype;       /* Set pFile->locktype to this value before exiting */\n  int gotPendingLock = 0;/* True if we acquired a PENDING lock this time */\n  winFile *pFile = (winFile*)id;\n  DWORD error = NO_ERROR;\n\n  assert( id!=0 );\n  OSTRACE((\"LOCK %d %d was %d(%d)\\n\",\n           pFile->h, locktype, pFile->locktype, pFile->sharedLockByte));\n\n  /* If there is already a lock of this type or more restrictive on the\n  ** OsFile, do nothing. Don't use the end_lock: exit path, as\n  ** sqlite3OsEnterMutex() hasn't been called yet.\n  */\n  if( pFile->locktype>=locktype ){\n    return SQLITE_OK;\n  }\n\n  /* Make sure the locking sequence is correct\n  */\n  assert( pFile->locktype!=NO_LOCK || locktype==SHARED_LOCK );\n  assert( locktype!=PENDING_LOCK );\n  assert( locktype!=RESERVED_LOCK || pFile->locktype==SHARED_LOCK );\n\n  /* Lock the PENDING_LOCK byte if we need to acquire a PENDING lock or\n  ** a SHARED lock.  If we are acquiring a SHARED lock, the acquisition of\n  ** the PENDING_LOCK byte is temporary.\n  */\n  newLocktype = pFile->locktype;\n  if(   (pFile->locktype==NO_LOCK)\n     || (   (locktype==EXCLUSIVE_LOCK)\n         && (pFile->locktype==RESERVED_LOCK))\n  ){\n    int cnt = 3;\n    while( cnt-->0 && (res = LockFile(pFile->h, PENDING_BYTE, 0, 1, 0))==0 ){\n      /* Try 3 times to get the pending lock.  The pending lock might be\n      ** held by another reader process who will release it momentarily.\n      */\n      OSTRACE((\"could not get a PENDING lock. cnt=%d\\n\", cnt));\n      Sleep(1);\n    }\n    gotPendingLock = res;\n    if( !res ){\n      error = GetLastError();\n    }\n  }\n\n  /* Acquire a shared lock\n  */\n  if( locktype==SHARED_LOCK && res ){\n    assert( pFile->locktype==NO_LOCK );\n    res = getReadLock(pFile);\n    if( res ){\n      newLocktype = SHARED_LOCK;\n    }else{\n      error = GetLastError();\n    }\n  }\n\n  /* Acquire a RESERVED lock\n  */\n  if( locktype==RESERVED_LOCK && res ){\n    assert( pFile->locktype==SHARED_LOCK );\n    res = LockFile(pFile->h, RESERVED_BYTE, 0, 1, 0);\n    if( res ){\n      newLocktype = RESERVED_LOCK;\n    }else{\n      error = GetLastError();\n    }\n  }\n\n  /* Acquire a PENDING lock\n  */\n  if( locktype==EXCLUSIVE_LOCK && res ){\n    newLocktype = PENDING_LOCK;\n    gotPendingLock = 0;\n  }\n\n  /* Acquire an EXCLUSIVE lock\n  */\n  if( locktype==EXCLUSIVE_LOCK && res ){\n    assert( pFile->locktype>=SHARED_LOCK );\n    res = unlockReadLock(pFile);\n    OSTRACE((\"unreadlock = %d\\n\", res));\n    res = LockFile(pFile->h, SHARED_FIRST, 0, SHARED_SIZE, 0);\n    if( res ){\n      newLocktype = EXCLUSIVE_LOCK;\n    }else{\n      error = GetLastError();\n      OSTRACE((\"error-code = %d\\n\", error));\n      getReadLock(pFile);\n    }\n  }\n\n  /* If we are holding a PENDING lock that ought to be released, then\n  ** release it now.\n  */\n  if( gotPendingLock && locktype==SHARED_LOCK ){\n    UnlockFile(pFile->h, PENDING_BYTE, 0, 1, 0);\n  }\n\n  /* Update the state of the lock has held in the file descriptor then\n  ** return the appropriate result code.\n  */\n  if( res ){\n    rc = SQLITE_OK;\n  }else{\n    OSTRACE((\"LOCK FAILED %d trying for %d but got %d\\n\", pFile->h,\n           locktype, newLocktype));\n    pFile->lastErrno = error;\n    rc = SQLITE_BUSY;\n  }\n  pFile->locktype = (u8)newLocktype;\n  return rc;\n}\n\n/*\n** This routine checks if there is a RESERVED lock held on the specified\n** file by this or any other process. If such a lock is held, return\n** non-zero, otherwise zero.\n*/\nstatic int winCheckReservedLock(sqlite3_file *id, int *pResOut){\n  int rc;\n  winFile *pFile = (winFile*)id;\n\n  SimulateIOError( return SQLITE_IOERR_CHECKRESERVEDLOCK; );\n\n  assert( id!=0 );\n  if( pFile->locktype>=RESERVED_LOCK ){\n    rc = 1;\n    OSTRACE((\"TEST WR-LOCK %d %d (local)\\n\", pFile->h, rc));\n  }else{\n    rc = LockFile(pFile->h, RESERVED_BYTE, 0, 1, 0);\n    if( rc ){\n      UnlockFile(pFile->h, RESERVED_BYTE, 0, 1, 0);\n    }\n    rc = !rc;\n    OSTRACE((\"TEST WR-LOCK %d %d (remote)\\n\", pFile->h, rc));\n  }\n  *pResOut = rc;\n  return SQLITE_OK;\n}\n\n/*\n** Lower the locking level on file descriptor id to locktype.  locktype\n** must be either NO_LOCK or SHARED_LOCK.\n**\n** If the locking level of the file descriptor is already at or below\n** the requested locking level, this routine is a no-op.\n**\n** It is not possible for this routine to fail if the second argument\n** is NO_LOCK.  If the second argument is SHARED_LOCK then this routine\n** might return SQLITE_IOERR;\n*/\nstatic int winUnlock(sqlite3_file *id, int locktype){\n  int type;\n  winFile *pFile = (winFile*)id;\n  int rc = SQLITE_OK;\n  assert( pFile!=0 );\n  assert( locktype<=SHARED_LOCK );\n  OSTRACE((\"UNLOCK %d to %d was %d(%d)\\n\", pFile->h, locktype,\n          pFile->locktype, pFile->sharedLockByte));\n  type = pFile->locktype;\n  if( type>=EXCLUSIVE_LOCK ){\n    UnlockFile(pFile->h, SHARED_FIRST, 0, SHARED_SIZE, 0);\n    if( locktype==SHARED_LOCK && !getReadLock(pFile) ){\n      /* This should never happen.  We should always be able to\n      ** reacquire the read lock */\n      rc = SQLITE_IOERR_UNLOCK;\n    }\n  }\n  if( type>=RESERVED_LOCK ){\n    UnlockFile(pFile->h, RESERVED_BYTE, 0, 1, 0);\n  }\n  if( locktype==NO_LOCK && type>=SHARED_LOCK ){\n    unlockReadLock(pFile);\n  }\n  if( type>=PENDING_LOCK ){\n    UnlockFile(pFile->h, PENDING_BYTE, 0, 1, 0);\n  }\n  pFile->locktype = (u8)locktype;\n  return rc;\n}\n\n/*\n** Control and query of the open file handle.\n*/\nstatic int winFileControl(sqlite3_file *id, int op, void *pArg){\n  switch( op ){\n    case SQLITE_FCNTL_LOCKSTATE: {\n      *(int*)pArg = ((winFile*)id)->locktype;\n      return SQLITE_OK;\n    }\n    case SQLITE_LAST_ERRNO: {\n      *(int*)pArg = (int)((winFile*)id)->lastErrno;\n      return SQLITE_OK;\n    }\n    case SQLITE_FCNTL_CHUNK_SIZE: {\n      ((winFile*)id)->szChunk = *(int *)pArg;\n      return SQLITE_OK;\n    }\n    case SQLITE_FCNTL_SIZE_HINT: {\n      sqlite3_int64 sz = *(sqlite3_int64*)pArg;\n      SimulateIOErrorBenign(1);\n      winTruncate(id, sz);\n      SimulateIOErrorBenign(0);\n      return SQLITE_OK;\n    }\n    case SQLITE_FCNTL_SYNC_OMITTED: {\n      return SQLITE_OK;\n    }\n  }\n  return SQLITE_NOTFOUND;\n}\n\n/*\n** Return the sector size in bytes of the underlying block device for\n** the specified file. This is almost always 512 bytes, but may be\n** larger for some devices.\n**\n** SQLite code assumes this function cannot fail. It also assumes that\n** if two files are created in the same file-system directory (i.e.\n** a database and its journal file) that the sector size will be the\n** same for both.\n*/\nstatic int winSectorSize(sqlite3_file *id){\n  assert( id!=0 );\n  return (int)(((winFile*)id)->sectorSize);\n}\n\n/*\n** Return a vector of device characteristics.\n*/\nstatic int winDeviceCharacteristics(sqlite3_file *id){\n  UNUSED_PARAMETER(id);\n  return SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN;\n}\n\n#ifndef SQLITE_OMIT_WAL\n\n/* \n** Windows will only let you create file view mappings\n** on allocation size granularity boundaries.\n** During sqlite3_os_init() we do a GetSystemInfo()\n** to get the granularity size.\n*/\nSYSTEM_INFO winSysInfo;\n\n/*\n** Helper functions to obtain and relinquish the global mutex. The\n** global mutex is used to protect the winLockInfo objects used by \n** this file, all of which may be shared by multiple threads.\n**\n** Function winShmMutexHeld() is used to assert() that the global mutex \n** is held when required. This function is only used as part of assert() \n** statements. e.g.\n**\n**   winShmEnterMutex()\n**     assert( winShmMutexHeld() );\n**   winShmLeaveMutex()\n*/\nstatic void winShmEnterMutex(void){\n  sqlite3_mutex_enter(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER));\n}\nstatic void winShmLeaveMutex(void){\n  sqlite3_mutex_leave(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER));\n}\n#ifdef SQLITE_DEBUG\nstatic int winShmMutexHeld(void) {\n  return sqlite3_mutex_held(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER));\n}\n#endif\n\n/*\n** Object used to represent a single file opened and mmapped to provide\n** shared memory.  When multiple threads all reference the same\n** log-summary, each thread has its own winFile object, but they all\n** point to a single instance of this object.  In other words, each\n** log-summary is opened only once per process.\n**\n** winShmMutexHeld() must be true when creating or destroying\n** this object or while reading or writing the following fields:\n**\n**      nRef\n**      pNext \n**\n** The following fields are read-only after the object is created:\n** \n**      fid\n**      zFilename\n**\n** Either winShmNode.mutex must be held or winShmNode.nRef==0 and\n** winShmMutexHeld() is true when reading or writing any other field\n** in this structure.\n**\n*/\nstruct winShmNode {\n  sqlite3_mutex *mutex;      /* Mutex to access this object */\n  char *zFilename;           /* Name of the file */\n  winFile hFile;             /* File handle from winOpen */\n\n  int szRegion;              /* Size of shared-memory regions */\n  int nRegion;               /* Size of array apRegion */\n  struct ShmRegion {\n    HANDLE hMap;             /* File handle from CreateFileMapping */\n    void *pMap;\n  } *aRegion;\n  DWORD lastErrno;           /* The Windows errno from the last I/O error */\n\n  int nRef;                  /* Number of winShm objects pointing to this */\n  winShm *pFirst;            /* All winShm objects pointing to this */\n  winShmNode *pNext;         /* Next in list of all winShmNode objects */\n#ifdef SQLITE_DEBUG\n  u8 nextShmId;              /* Next available winShm.id value */\n#endif\n};\n\n/*\n** A global array of all winShmNode objects.\n**\n** The winShmMutexHeld() must be true while reading or writing this list.\n*/\nstatic winShmNode *winShmNodeList = 0;\n\n/*\n** Structure used internally by this VFS to record the state of an\n** open shared memory connection.\n**\n** The following fields are initialized when this object is created and\n** are read-only thereafter:\n**\n**    winShm.pShmNode\n**    winShm.id\n**\n** All other fields are read/write.  The winShm.pShmNode->mutex must be held\n** while accessing any read/write fields.\n*/\nstruct winShm {\n  winShmNode *pShmNode;      /* The underlying winShmNode object */\n  winShm *pNext;             /* Next winShm with the same winShmNode */\n  u8 hasMutex;               /* True if holding the winShmNode mutex */\n  u16 sharedMask;            /* Mask of shared locks held */\n  u16 exclMask;              /* Mask of exclusive locks held */\n#ifdef SQLITE_DEBUG\n  u8 id;                     /* Id of this connection with its winShmNode */\n#endif\n};\n\n/*\n** Constants used for locking\n*/\n#define WIN_SHM_BASE   ((22+SQLITE_SHM_NLOCK)*4)        /* first lock byte */\n#define WIN_SHM_DMS    (WIN_SHM_BASE+SQLITE_SHM_NLOCK)  /* deadman switch */\n\n/*\n** Apply advisory locks for all n bytes beginning at ofst.\n*/\n#define _SHM_UNLCK  1\n#define _SHM_RDLCK  2\n#define _SHM_WRLCK  3\nstatic int winShmSystemLock(\n  winShmNode *pFile,    /* Apply locks to this open shared-memory segment */\n  int lockType,         /* _SHM_UNLCK, _SHM_RDLCK, or _SHM_WRLCK */\n  int ofst,             /* Offset to first byte to be locked/unlocked */\n  int nByte             /* Number of bytes to lock or unlock */\n){\n  OVERLAPPED ovlp;\n  DWORD dwFlags;\n  int rc = 0;           /* Result code form Lock/UnlockFileEx() */\n\n  /* Access to the winShmNode object is serialized by the caller */\n  assert( sqlite3_mutex_held(pFile->mutex) || pFile->nRef==0 );\n\n  /* Initialize the locking parameters */\n  dwFlags = LOCKFILE_FAIL_IMMEDIATELY;\n  if( lockType == _SHM_WRLCK ) dwFlags |= LOCKFILE_EXCLUSIVE_LOCK;\n\n  memset(&ovlp, 0, sizeof(OVERLAPPED));\n  ovlp.Offset = ofst;\n\n  /* Release/Acquire the system-level lock */\n  if( lockType==_SHM_UNLCK ){\n    rc = UnlockFileEx(pFile->hFile.h, 0, nByte, 0, &ovlp);\n  }else{\n    rc = LockFileEx(pFile->hFile.h, dwFlags, 0, nByte, 0, &ovlp);\n  }\n  \n  if( rc!= 0 ){\n    rc = SQLITE_OK;\n  }else{\n    pFile->lastErrno =  GetLastError();\n    rc = SQLITE_BUSY;\n  }\n\n  OSTRACE((\"SHM-LOCK %d %s %s 0x%08lx\\n\", \n           pFile->hFile.h,\n           rc==SQLITE_OK ? \"ok\" : \"failed\",\n           lockType==_SHM_UNLCK ? \"UnlockFileEx\" : \"LockFileEx\",\n           pFile->lastErrno));\n\n  return rc;\n}\n\n/* Forward references to VFS methods */\nstatic int winOpen(sqlite3_vfs*,const char*,sqlite3_file*,int,int*);\nstatic int winDelete(sqlite3_vfs *,const char*,int);\n\n/*\n** Purge the winShmNodeList list of all entries with winShmNode.nRef==0.\n**\n** This is not a VFS shared-memory method; it is a utility function called\n** by VFS shared-memory methods.\n*/\nstatic void winShmPurge(sqlite3_vfs *pVfs, int deleteFlag){\n  winShmNode **pp;\n  winShmNode *p;\n  BOOL bRc;\n  assert( winShmMutexHeld() );\n  pp = &winShmNodeList;\n  while( (p = *pp)!=0 ){\n    if( p->nRef==0 ){\n      int i;\n      if( p->mutex ) sqlite3_mutex_free(p->mutex);\n      for(i=0; i<p->nRegion; i++){\n        bRc = UnmapViewOfFile(p->aRegion[i].pMap);\n        OSTRACE((\"SHM-PURGE pid-%d unmap region=%d %s\\n\",\n                 (int)GetCurrentProcessId(), i,\n                 bRc ? \"ok\" : \"failed\"));\n        bRc = CloseHandle(p->aRegion[i].hMap);\n        OSTRACE((\"SHM-PURGE pid-%d close region=%d %s\\n\",\n                 (int)GetCurrentProcessId(), i,\n                 bRc ? \"ok\" : \"failed\"));\n      }\n      if( p->hFile.h != INVALID_HANDLE_VALUE ){\n        SimulateIOErrorBenign(1);\n        winClose((sqlite3_file *)&p->hFile);\n        SimulateIOErrorBenign(0);\n      }\n      if( deleteFlag ){\n        SimulateIOErrorBenign(1);\n        winDelete(pVfs, p->zFilename, 0);\n        SimulateIOErrorBenign(0);\n      }\n      *pp = p->pNext;\n      sqlite3_free(p->aRegion);\n      sqlite3_free(p);\n    }else{\n      pp = &p->pNext;\n    }\n  }\n}\n\n/*\n** Open the shared-memory area associated with database file pDbFd.\n**\n** When opening a new shared-memory file, if no other instances of that\n** file are currently open, in this process or in other processes, then\n** the file must be truncated to zero length or have its header cleared.\n*/\nstatic int winOpenSharedMemory(winFile *pDbFd){\n  struct winShm *p;                  /* The connection to be opened */\n  struct winShmNode *pShmNode = 0;   /* The underlying mmapped file */\n  int rc;                            /* Result code */\n  struct winShmNode *pNew;           /* Newly allocated winShmNode */\n  int nName;                         /* Size of zName in bytes */\n\n  assert( pDbFd->pShm==0 );    /* Not previously opened */\n\n  /* Allocate space for the new sqlite3_shm object.  Also speculatively\n  ** allocate space for a new winShmNode and filename.\n  */\n  p = sqlite3_malloc( sizeof(*p) );\n  if( p==0 ) return SQLITE_NOMEM;\n  memset(p, 0, sizeof(*p));\n  nName = sqlite3Strlen30(pDbFd->zPath);\n  pNew = sqlite3_malloc( sizeof(*pShmNode) + nName + 15 );\n  if( pNew==0 ){\n    sqlite3_free(p);\n    return SQLITE_NOMEM;\n  }\n  memset(pNew, 0, sizeof(*pNew));\n  pNew->zFilename = (char*)&pNew[1];\n  sqlite3_snprintf(nName+15, pNew->zFilename, \"%s-shm\", pDbFd->zPath);\n\n  /* Look to see if there is an existing winShmNode that can be used.\n  ** If no matching winShmNode currently exists, create a new one.\n  */\n  winShmEnterMutex();\n  for(pShmNode = winShmNodeList; pShmNode; pShmNode=pShmNode->pNext){\n    /* TBD need to come up with better match here.  Perhaps\n    ** use FILE_ID_BOTH_DIR_INFO Structure.\n    */\n    if( sqlite3StrICmp(pShmNode->zFilename, pNew->zFilename)==0 ) break;\n  }\n  if( pShmNode ){\n    sqlite3_free(pNew);\n  }else{\n    pShmNode = pNew;\n    pNew = 0;\n    ((winFile*)(&pShmNode->hFile))->h = INVALID_HANDLE_VALUE;\n    pShmNode->pNext = winShmNodeList;\n    winShmNodeList = pShmNode;\n\n    pShmNode->mutex = sqlite3_mutex_alloc(SQLITE_MUTEX_FAST);\n    if( pShmNode->mutex==0 ){\n      rc = SQLITE_NOMEM;\n      goto shm_open_err;\n    }\n\n    rc = winOpen(pDbFd->pVfs,\n                 pShmNode->zFilename,             /* Name of the file (UTF-8) */\n                 (sqlite3_file*)&pShmNode->hFile,  /* File handle here */\n                 SQLITE_OPEN_WAL | SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE, /* Mode flags */\n                 0);\n    if( SQLITE_OK!=rc ){\n      rc = SQLITE_CANTOPEN_BKPT;\n      goto shm_open_err;\n    }\n\n    /* Check to see if another process is holding the dead-man switch.\n    ** If not, truncate the file to zero length. \n    */\n    if( winShmSystemLock(pShmNode, _SHM_WRLCK, WIN_SHM_DMS, 1)==SQLITE_OK ){\n      rc = winTruncate((sqlite3_file *)&pShmNode->hFile, 0);\n      if( rc!=SQLITE_OK ){\n        rc = SQLITE_IOERR_SHMOPEN;\n      }\n    }\n    if( rc==SQLITE_OK ){\n      winShmSystemLock(pShmNode, _SHM_UNLCK, WIN_SHM_DMS, 1);\n      rc = winShmSystemLock(pShmNode, _SHM_RDLCK, WIN_SHM_DMS, 1);\n    }\n    if( rc ) goto shm_open_err;\n  }\n\n  /* Make the new connection a child of the winShmNode */\n  p->pShmNode = pShmNode;\n#ifdef SQLITE_DEBUG\n  p->id = pShmNode->nextShmId++;\n#endif\n  pShmNode->nRef++;\n  pDbFd->pShm = p;\n  winShmLeaveMutex();\n\n  /* The reference count on pShmNode has already been incremented under\n  ** the cover of the winShmEnterMutex() mutex and the pointer from the\n  ** new (struct winShm) object to the pShmNode has been set. All that is\n  ** left to do is to link the new object into the linked list starting\n  ** at pShmNode->pFirst. This must be done while holding the pShmNode->mutex \n  ** mutex.\n  */\n  sqlite3_mutex_enter(pShmNode->mutex);\n  p->pNext = pShmNode->pFirst;\n  pShmNode->pFirst = p;\n  sqlite3_mutex_leave(pShmNode->mutex);\n  return SQLITE_OK;\n\n  /* Jump here on any error */\nshm_open_err:\n  winShmSystemLock(pShmNode, _SHM_UNLCK, WIN_SHM_DMS, 1);\n  winShmPurge(pDbFd->pVfs, 0);      /* This call frees pShmNode if required */\n  sqlite3_free(p);\n  sqlite3_free(pNew);\n  winShmLeaveMutex();\n  return rc;\n}\n\n/*\n** Close a connection to shared-memory.  Delete the underlying \n** storage if deleteFlag is true.\n*/\nstatic int winShmUnmap(\n  sqlite3_file *fd,          /* Database holding shared memory */\n  int deleteFlag             /* Delete after closing if true */\n){\n  winFile *pDbFd;       /* Database holding shared-memory */\n  winShm *p;            /* The connection to be closed */\n  winShmNode *pShmNode; /* The underlying shared-memory file */\n  winShm **pp;          /* For looping over sibling connections */\n\n  pDbFd = (winFile*)fd;\n  p = pDbFd->pShm;\n  if( p==0 ) return SQLITE_OK;\n  pShmNode = p->pShmNode;\n\n  /* Remove connection p from the set of connections associated\n  ** with pShmNode */\n  sqlite3_mutex_enter(pShmNode->mutex);\n  for(pp=&pShmNode->pFirst; (*pp)!=p; pp = &(*pp)->pNext){}\n  *pp = p->pNext;\n\n  /* Free the connection p */\n  sqlite3_free(p);\n  pDbFd->pShm = 0;\n  sqlite3_mutex_leave(pShmNode->mutex);\n\n  /* If pShmNode->nRef has reached 0, then close the underlying\n  ** shared-memory file, too */\n  winShmEnterMutex();\n  assert( pShmNode->nRef>0 );\n  pShmNode->nRef--;\n  if( pShmNode->nRef==0 ){\n    winShmPurge(pDbFd->pVfs, deleteFlag);\n  }\n  winShmLeaveMutex();\n\n  return SQLITE_OK;\n}\n\n/*\n** Change the lock state for a shared-memory segment.\n*/\nstatic int winShmLock(\n  sqlite3_file *fd,          /* Database file holding the shared memory */\n  int ofst,                  /* First lock to acquire or release */\n  int n,                     /* Number of locks to acquire or release */\n  int flags                  /* What to do with the lock */\n){\n  winFile *pDbFd = (winFile*)fd;        /* Connection holding shared memory */\n  winShm *p = pDbFd->pShm;              /* The shared memory being locked */\n  winShm *pX;                           /* For looping over all siblings */\n  winShmNode *pShmNode = p->pShmNode;\n  int rc = SQLITE_OK;                   /* Result code */\n  u16 mask;                             /* Mask of locks to take or release */\n\n  assert( ofst>=0 && ofst+n<=SQLITE_SHM_NLOCK );\n  assert( n>=1 );\n  assert( flags==(SQLITE_SHM_LOCK | SQLITE_SHM_SHARED)\n       || flags==(SQLITE_SHM_LOCK | SQLITE_SHM_EXCLUSIVE)\n       || flags==(SQLITE_SHM_UNLOCK | SQLITE_SHM_SHARED)\n       || flags==(SQLITE_SHM_UNLOCK | SQLITE_SHM_EXCLUSIVE) );\n  assert( n==1 || (flags & SQLITE_SHM_EXCLUSIVE)!=0 );\n\n  mask = (u16)((1U<<(ofst+n)) - (1U<<ofst));\n  assert( n>1 || mask==(1<<ofst) );\n  sqlite3_mutex_enter(pShmNode->mutex);\n  if( flags & SQLITE_SHM_UNLOCK ){\n    u16 allMask = 0; /* Mask of locks held by siblings */\n\n    /* See if any siblings hold this same lock */\n    for(pX=pShmNode->pFirst; pX; pX=pX->pNext){\n      if( pX==p ) continue;\n      assert( (pX->exclMask & (p->exclMask|p->sharedMask))==0 );\n      allMask |= pX->sharedMask;\n    }\n\n    /* Unlock the system-level locks */\n    if( (mask & allMask)==0 ){\n      rc = winShmSystemLock(pShmNode, _SHM_UNLCK, ofst+WIN_SHM_BASE, n);\n    }else{\n      rc = SQLITE_OK;\n    }\n\n    /* Undo the local locks */\n    if( rc==SQLITE_OK ){\n      p->exclMask &= ~mask;\n      p->sharedMask &= ~mask;\n    } \n  }else if( flags & SQLITE_SHM_SHARED ){\n    u16 allShared = 0;  /* Union of locks held by connections other than \"p\" */\n\n    /* Find out which shared locks are already held by sibling connections.\n    ** If any sibling already holds an exclusive lock, go ahead and return\n    ** SQLITE_BUSY.\n    */\n    for(pX=pShmNode->pFirst; pX; pX=pX->pNext){\n      if( (pX->exclMask & mask)!=0 ){\n        rc = SQLITE_BUSY;\n        break;\n      }\n      allShared |= pX->sharedMask;\n    }\n\n    /* Get shared locks at the system level, if necessary */\n    if( rc==SQLITE_OK ){\n      if( (allShared & mask)==0 ){\n        rc = winShmSystemLock(pShmNode, _SHM_RDLCK, ofst+WIN_SHM_BASE, n);\n      }else{\n        rc = SQLITE_OK;\n      }\n    }\n\n    /* Get the local shared locks */\n    if( rc==SQLITE_OK ){\n      p->sharedMask |= mask;\n    }\n  }else{\n    /* Make sure no sibling connections hold locks that will block this\n    ** lock.  If any do, return SQLITE_BUSY right away.\n    */\n    for(pX=pShmNode->pFirst; pX; pX=pX->pNext){\n      if( (pX->exclMask & mask)!=0 || (pX->sharedMask & mask)!=0 ){\n        rc = SQLITE_BUSY;\n        break;\n      }\n    }\n  \n    /* Get the exclusive locks at the system level.  Then if successful\n    ** also mark the local connection as being locked.\n    */\n    if( rc==SQLITE_OK ){\n      rc = winShmSystemLock(pShmNode, _SHM_WRLCK, ofst+WIN_SHM_BASE, n);\n      if( rc==SQLITE_OK ){\n        assert( (p->sharedMask & mask)==0 );\n        p->exclMask |= mask;\n      }\n    }\n  }\n  sqlite3_mutex_leave(pShmNode->mutex);\n  OSTRACE((\"SHM-LOCK shmid-%d, pid-%d got %03x,%03x %s\\n\",\n           p->id, (int)GetCurrentProcessId(), p->sharedMask, p->exclMask,\n           rc ? \"failed\" : \"ok\"));\n  return rc;\n}\n\n/*\n** Implement a memory barrier or memory fence on shared memory.  \n**\n** All loads and stores begun before the barrier must complete before\n** any load or store begun after the barrier.\n*/\nstatic void winShmBarrier(\n  sqlite3_file *fd          /* Database holding the shared memory */\n){\n  UNUSED_PARAMETER(fd);\n  /* MemoryBarrier(); // does not work -- do not know why not */\n  winShmEnterMutex();\n  winShmLeaveMutex();\n}\n\n/*\n** This function is called to obtain a pointer to region iRegion of the \n** shared-memory associated with the database file fd. Shared-memory regions \n** are numbered starting from zero. Each shared-memory region is szRegion \n** bytes in size.\n**\n** If an error occurs, an error code is returned and *pp is set to NULL.\n**\n** Otherwise, if the isWrite parameter is 0 and the requested shared-memory\n** region has not been allocated (by any client, including one running in a\n** separate process), then *pp is set to NULL and SQLITE_OK returned. If \n** isWrite is non-zero and the requested shared-memory region has not yet \n** been allocated, it is allocated by this function.\n**\n** If the shared-memory region has already been allocated or is allocated by\n** this call as described above, then it is mapped into this processes \n** address space (if it is not already), *pp is set to point to the mapped \n** memory and SQLITE_OK returned.\n*/\nstatic int winShmMap(\n  sqlite3_file *fd,               /* Handle open on database file */\n  int iRegion,                    /* Region to retrieve */\n  int szRegion,                   /* Size of regions */\n  int isWrite,                    /* True to extend file if necessary */\n  void volatile **pp              /* OUT: Mapped memory */\n){\n  winFile *pDbFd = (winFile*)fd;\n  winShm *p = pDbFd->pShm;\n  winShmNode *pShmNode;\n  int rc = SQLITE_OK;\n\n  if( !p ){\n    rc = winOpenSharedMemory(pDbFd);\n    if( rc!=SQLITE_OK ) return rc;\n    p = pDbFd->pShm;\n  }\n  pShmNode = p->pShmNode;\n\n  sqlite3_mutex_enter(pShmNode->mutex);\n  assert( szRegion==pShmNode->szRegion || pShmNode->nRegion==0 );\n\n  if( pShmNode->nRegion<=iRegion ){\n    struct ShmRegion *apNew;           /* New aRegion[] array */\n    int nByte = (iRegion+1)*szRegion;  /* Minimum required file size */\n    sqlite3_int64 sz;                  /* Current size of wal-index file */\n\n    pShmNode->szRegion = szRegion;\n\n    /* The requested region is not mapped into this processes address space.\n    ** Check to see if it has been allocated (i.e. if the wal-index file is\n    ** large enough to contain the requested region).\n    */\n    rc = winFileSize((sqlite3_file *)&pShmNode->hFile, &sz);\n    if( rc!=SQLITE_OK ){\n      rc = SQLITE_IOERR_SHMSIZE;\n      goto shmpage_out;\n    }\n\n    if( sz<nByte ){\n      /* The requested memory region does not exist. If isWrite is set to\n      ** zero, exit early. *pp will be set to NULL and SQLITE_OK returned.\n      **\n      ** Alternatively, if isWrite is non-zero, use ftruncate() to allocate\n      ** the requested memory region.\n      */\n      if( !isWrite ) goto shmpage_out;\n      rc = winTruncate((sqlite3_file *)&pShmNode->hFile, nByte);\n      if( rc!=SQLITE_OK ){\n        rc = SQLITE_IOERR_SHMSIZE;\n        goto shmpage_out;\n      }\n    }\n\n    /* Map the requested memory region into this processes address space. */\n    apNew = (struct ShmRegion *)sqlite3_realloc(\n        pShmNode->aRegion, (iRegion+1)*sizeof(apNew[0])\n    );\n    if( !apNew ){\n      rc = SQLITE_IOERR_NOMEM;\n      goto shmpage_out;\n    }\n    pShmNode->aRegion = apNew;\n\n    while( pShmNode->nRegion<=iRegion ){\n      HANDLE hMap;                /* file-mapping handle */\n      void *pMap = 0;             /* Mapped memory region */\n     \n      hMap = CreateFileMapping(pShmNode->hFile.h, \n          NULL, PAGE_READWRITE, 0, nByte, NULL\n      );\n      OSTRACE((\"SHM-MAP pid-%d create region=%d nbyte=%d %s\\n\",\n               (int)GetCurrentProcessId(), pShmNode->nRegion, nByte,\n               hMap ? \"ok\" : \"failed\"));\n      if( hMap ){\n        int iOffset = pShmNode->nRegion*szRegion;\n        int iOffsetShift = iOffset % winSysInfo.dwAllocationGranularity;\n        pMap = MapViewOfFile(hMap, FILE_MAP_WRITE | FILE_MAP_READ,\n            0, iOffset - iOffsetShift, szRegion + iOffsetShift\n        );\n        OSTRACE((\"SHM-MAP pid-%d map region=%d offset=%d size=%d %s\\n\",\n                 (int)GetCurrentProcessId(), pShmNode->nRegion, iOffset, szRegion,\n                 pMap ? \"ok\" : \"failed\"));\n      }\n      if( !pMap ){\n        pShmNode->lastErrno = GetLastError();\n        rc = SQLITE_IOERR;\n        if( hMap ) CloseHandle(hMap);\n        goto shmpage_out;\n      }\n\n      pShmNode->aRegion[pShmNode->nRegion].pMap = pMap;\n      pShmNode->aRegion[pShmNode->nRegion].hMap = hMap;\n      pShmNode->nRegion++;\n    }\n  }\n\nshmpage_out:\n  if( pShmNode->nRegion>iRegion ){\n    int iOffset = iRegion*szRegion;\n    int iOffsetShift = iOffset % winSysInfo.dwAllocationGranularity;\n    char *p = (char *)pShmNode->aRegion[iRegion].pMap;\n    *pp = (void *)&p[iOffsetShift];\n  }else{\n    *pp = 0;\n  }\n  sqlite3_mutex_leave(pShmNode->mutex);\n  return rc;\n}\n\n#else\n# define winShmMap     0\n# define winShmLock    0\n# define winShmBarrier 0\n# define winShmUnmap   0\n#endif /* #ifndef SQLITE_OMIT_WAL */\n\n/*\n** Here ends the implementation of all sqlite3_file methods.\n**\n********************** End sqlite3_file Methods *******************************\n******************************************************************************/\n\n/*\n** This vector defines all the methods that can operate on an\n** sqlite3_file for win32.\n*/\nstatic const sqlite3_io_methods winIoMethod = {\n  2,                              /* iVersion */\n  winClose,                       /* xClose */\n  winRead,                        /* xRead */\n  winWrite,                       /* xWrite */\n  winTruncate,                    /* xTruncate */\n  winSync,                        /* xSync */\n  winFileSize,                    /* xFileSize */\n  winLock,                        /* xLock */\n  winUnlock,                      /* xUnlock */\n  winCheckReservedLock,           /* xCheckReservedLock */\n  winFileControl,                 /* xFileControl */\n  winSectorSize,                  /* xSectorSize */\n  winDeviceCharacteristics,       /* xDeviceCharacteristics */\n  winShmMap,                      /* xShmMap */\n  winShmLock,                     /* xShmLock */\n  winShmBarrier,                  /* xShmBarrier */\n  winShmUnmap                     /* xShmUnmap */\n};\n\n/****************************************************************************\n**************************** sqlite3_vfs methods ****************************\n**\n** This division contains the implementation of methods on the\n** sqlite3_vfs object.\n*/\n\n/*\n** Convert a UTF-8 filename into whatever form the underlying\n** operating system wants filenames in.  Space to hold the result\n** is obtained from malloc and must be freed by the calling\n** function.\n*/\nstatic void *convertUtf8Filename(const char *zFilename){\n  void *zConverted = 0;\n  if( isNT() ){\n    zConverted = utf8ToUnicode(zFilename);\n/* isNT() is 1 if SQLITE_OS_WINCE==1, so this else is never executed. \n*/\n#if SQLITE_OS_WINCE==0\n  }else{\n    zConverted = utf8ToMbcs(zFilename);\n#endif\n  }\n  /* caller will handle out of memory */\n  return zConverted;\n}\n\n/*\n** Create a temporary file name in zBuf.  zBuf must be big enough to\n** hold at pVfs->mxPathname characters.\n*/\nstatic int getTempname(int nBuf, char *zBuf){\n  static char zChars[] =\n    \"abcdefghijklmnopqrstuvwxyz\"\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    \"0123456789\";\n  size_t i, j;\n  char zTempPath[MAX_PATH+1];\n\n  /* It's odd to simulate an io-error here, but really this is just\n  ** using the io-error infrastructure to test that SQLite handles this\n  ** function failing. \n  */\n  SimulateIOError( return SQLITE_IOERR );\n\n  if( sqlite3_temp_directory ){\n    sqlite3_snprintf(MAX_PATH-30, zTempPath, \"%s\", sqlite3_temp_directory);\n  }else if( isNT() ){\n    char *zMulti;\n    WCHAR zWidePath[MAX_PATH];\n    GetTempPathW(MAX_PATH-30, zWidePath);\n    zMulti = unicodeToUtf8(zWidePath);\n    if( zMulti ){\n      sqlite3_snprintf(MAX_PATH-30, zTempPath, \"%s\", zMulti);\n      free(zMulti);\n    }else{\n      return SQLITE_NOMEM;\n    }\n/* isNT() is 1 if SQLITE_OS_WINCE==1, so this else is never executed. \n** Since the ASCII version of these Windows API do not exist for WINCE,\n** it's important to not reference them for WINCE builds.\n*/\n#if SQLITE_OS_WINCE==0\n  }else{\n    char *zUtf8;\n    char zMbcsPath[MAX_PATH];\n    GetTempPathA(MAX_PATH-30, zMbcsPath);\n    zUtf8 = sqlite3_win32_mbcs_to_utf8(zMbcsPath);\n    if( zUtf8 ){\n      sqlite3_snprintf(MAX_PATH-30, zTempPath, \"%s\", zUtf8);\n      free(zUtf8);\n    }else{\n      return SQLITE_NOMEM;\n    }\n#endif\n  }\n\n  /* Check that the output buffer is large enough for the temporary file \n  ** name. If it is not, return SQLITE_ERROR.\n  */\n  if( (sqlite3Strlen30(zTempPath) + sqlite3Strlen30(SQLITE_TEMP_FILE_PREFIX) + 17) >= nBuf ){\n    return SQLITE_ERROR;\n  }\n\n  for(i=sqlite3Strlen30(zTempPath); i>0 && zTempPath[i-1]=='\\\\'; i--){}\n  zTempPath[i] = 0;\n\n  sqlite3_snprintf(nBuf-17, zBuf,\n                   \"%s\\\\\"SQLITE_TEMP_FILE_PREFIX, zTempPath);\n  j = sqlite3Strlen30(zBuf);\n  sqlite3_randomness(15, &zBuf[j]);\n  for(i=0; i<15; i++, j++){\n    zBuf[j] = (char)zChars[ ((unsigned char)zBuf[j])%(sizeof(zChars)-1) ];\n  }\n  zBuf[j] = 0;\n\n  OSTRACE((\"TEMP FILENAME: %s\\n\", zBuf));\n  return SQLITE_OK; \n}\n\n/*\n** The return value of getLastErrorMsg\n** is zero if the error message fits in the buffer, or non-zero\n** otherwise (if the message was truncated).\n*/\nstatic int getLastErrorMsg(int nBuf, char *zBuf){\n  /* FormatMessage returns 0 on failure.  Otherwise it\n  ** returns the number of TCHARs written to the output\n  ** buffer, excluding the terminating null char.\n  */\n  DWORD error = GetLastError();\n  DWORD dwLen = 0;\n  char *zOut = 0;\n\n  if( isNT() ){\n    WCHAR *zTempWide = NULL;\n    dwLen = FormatMessageW(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,\n                           NULL,\n                           error,\n                           0,\n                           (LPWSTR) &zTempWide,\n                           0,\n                           0);\n    if( dwLen > 0 ){\n      /* allocate a buffer and convert to UTF8 */\n      zOut = unicodeToUtf8(zTempWide);\n      /* free the system buffer allocated by FormatMessage */\n      LocalFree(zTempWide);\n    }\n/* isNT() is 1 if SQLITE_OS_WINCE==1, so this else is never executed. \n** Since the ASCII version of these Windows API do not exist for WINCE,\n** it's important to not reference them for WINCE builds.\n*/\n#if SQLITE_OS_WINCE==0\n  }else{\n    char *zTemp = NULL;\n    dwLen = FormatMessageA(FORMAT_MESSAGE_ALLOCATE_BUFFER | FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_IGNORE_INSERTS,\n                           NULL,\n                           error,\n                           0,\n                           (LPSTR) &zTemp,\n                           0,\n                           0);\n    if( dwLen > 0 ){\n      /* allocate a buffer and convert to UTF8 */\n      zOut = sqlite3_win32_mbcs_to_utf8(zTemp);\n      /* free the system buffer allocated by FormatMessage */\n      LocalFree(zTemp);\n    }\n#endif\n  }\n  if( 0 == dwLen ){\n    sqlite3_snprintf(nBuf, zBuf, \"OsError 0x%x (%u)\", error, error);\n  }else{\n    /* copy a maximum of nBuf chars to output buffer */\n    sqlite3_snprintf(nBuf, zBuf, \"%s\", zOut);\n    /* free the UTF8 buffer */\n    free(zOut);\n  }\n  return 0;\n}\n\n/*\n** Open a file.\n*/\nstatic int winOpen(\n  sqlite3_vfs *pVfs,        /* Not used */\n  const char *zName,        /* Name of the file (UTF-8) */\n  sqlite3_file *id,         /* Write the SQLite file handle here */\n  int flags,                /* Open mode flags */\n  int *pOutFlags            /* Status return flags */\n){\n  HANDLE h;\n  DWORD dwDesiredAccess;\n  DWORD dwShareMode;\n  DWORD dwCreationDisposition;\n  DWORD dwFlagsAndAttributes = 0;\n#if SQLITE_OS_WINCE\n  int isTemp = 0;\n#endif\n  winFile *pFile = (winFile*)id;\n  void *zConverted;              /* Filename in OS encoding */\n  const char *zUtf8Name = zName; /* Filename in UTF-8 encoding */\n\n  /* If argument zPath is a NULL pointer, this function is required to open\n  ** a temporary file. Use this buffer to store the file name in.\n  */\n  char zTmpname[MAX_PATH+1];     /* Buffer used to create temp filename */\n\n  int rc = SQLITE_OK;            /* Function Return Code */\n#if !defined(NDEBUG) || SQLITE_OS_WINCE\n  int eType = flags&0xFFFFFF00;  /* Type of file to open */\n#endif\n\n  int isExclusive  = (flags & SQLITE_OPEN_EXCLUSIVE);\n  int isDelete     = (flags & SQLITE_OPEN_DELETEONCLOSE);\n  int isCreate     = (flags & SQLITE_OPEN_CREATE);\n#ifndef NDEBUG\n  int isReadonly   = (flags & SQLITE_OPEN_READONLY);\n#endif\n  int isReadWrite  = (flags & SQLITE_OPEN_READWRITE);\n\n#ifndef NDEBUG\n  int isOpenJournal = (isCreate && (\n        eType==SQLITE_OPEN_MASTER_JOURNAL \n     || eType==SQLITE_OPEN_MAIN_JOURNAL \n     || eType==SQLITE_OPEN_WAL\n  ));\n#endif\n\n  /* Check the following statements are true: \n  **\n  **   (a) Exactly one of the READWRITE and READONLY flags must be set, and \n  **   (b) if CREATE is set, then READWRITE must also be set, and\n  **   (c) if EXCLUSIVE is set, then CREATE must also be set.\n  **   (d) if DELETEONCLOSE is set, then CREATE must also be set.\n  */\n  assert((isReadonly==0 || isReadWrite==0) && (isReadWrite || isReadonly));\n  assert(isCreate==0 || isReadWrite);\n  assert(isExclusive==0 || isCreate);\n  assert(isDelete==0 || isCreate);\n\n  /* The main DB, main journal, WAL file and master journal are never \n  ** automatically deleted. Nor are they ever temporary files.  */\n  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_MAIN_DB );\n  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_MAIN_JOURNAL );\n  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_MASTER_JOURNAL );\n  assert( (!isDelete && zName) || eType!=SQLITE_OPEN_WAL );\n\n  /* Assert that the upper layer has set one of the \"file-type\" flags. */\n  assert( eType==SQLITE_OPEN_MAIN_DB      || eType==SQLITE_OPEN_TEMP_DB \n       || eType==SQLITE_OPEN_MAIN_JOURNAL || eType==SQLITE_OPEN_TEMP_JOURNAL \n       || eType==SQLITE_OPEN_SUBJOURNAL   || eType==SQLITE_OPEN_MASTER_JOURNAL \n       || eType==SQLITE_OPEN_TRANSIENT_DB || eType==SQLITE_OPEN_WAL\n  );\n\n  assert( id!=0 );\n  UNUSED_PARAMETER(pVfs);\n\n  pFile->h = INVALID_HANDLE_VALUE;\n\n  /* If the second argument to this function is NULL, generate a \n  ** temporary file name to use \n  */\n  if( !zUtf8Name ){\n    assert(isDelete && !isOpenJournal);\n    rc = getTempname(MAX_PATH+1, zTmpname);\n    if( rc!=SQLITE_OK ){\n      return rc;\n    }\n    zUtf8Name = zTmpname;\n  }\n\n  /* Convert the filename to the system encoding. */\n  zConverted = convertUtf8Filename(zUtf8Name);\n  if( zConverted==0 ){\n    return SQLITE_NOMEM;\n  }\n\n  if( isReadWrite ){\n    dwDesiredAccess = GENERIC_READ | GENERIC_WRITE;\n  }else{\n    dwDesiredAccess = GENERIC_READ;\n  }\n\n  /* SQLITE_OPEN_EXCLUSIVE is used to make sure that a new file is \n  ** created. SQLite doesn't use it to indicate \"exclusive access\" \n  ** as it is usually understood.\n  */\n  if( isExclusive ){\n    /* Creates a new file, only if it does not already exist. */\n    /* If the file exists, it fails. */\n    dwCreationDisposition = CREATE_NEW;\n  }else if( isCreate ){\n    /* Open existing file, or create if it doesn't exist */\n    dwCreationDisposition = OPEN_ALWAYS;\n  }else{\n    /* Opens a file, only if it exists. */\n    dwCreationDisposition = OPEN_EXISTING;\n  }\n\n  dwShareMode = FILE_SHARE_READ | FILE_SHARE_WRITE;\n\n  if( isDelete ){\n#if SQLITE_OS_WINCE\n    dwFlagsAndAttributes = FILE_ATTRIBUTE_HIDDEN;\n    isTemp = 1;\n#else\n    dwFlagsAndAttributes = FILE_ATTRIBUTE_TEMPORARY\n                               | FILE_ATTRIBUTE_HIDDEN\n                               | FILE_FLAG_DELETE_ON_CLOSE;\n#endif\n  }else{\n    dwFlagsAndAttributes = FILE_ATTRIBUTE_NORMAL;\n  }\n  /* Reports from the internet are that performance is always\n  ** better if FILE_FLAG_RANDOM_ACCESS is used.  Ticket #2699. */\n#if SQLITE_OS_WINCE\n  dwFlagsAndAttributes |= FILE_FLAG_RANDOM_ACCESS;\n#endif\n\n  if( isNT() ){\n    h = CreateFileW((WCHAR*)zConverted,\n       dwDesiredAccess,\n       dwShareMode,\n       NULL,\n       dwCreationDisposition,\n       dwFlagsAndAttributes,\n       NULL\n    );\n/* isNT() is 1 if SQLITE_OS_WINCE==1, so this else is never executed. \n** Since the ASCII version of these Windows API do not exist for WINCE,\n** it's important to not reference them for WINCE builds.\n*/\n#if SQLITE_OS_WINCE==0\n  }else{\n    h = CreateFileA((char*)zConverted,\n       dwDesiredAccess,\n       dwShareMode,\n       NULL,\n       dwCreationDisposition,\n       dwFlagsAndAttributes,\n       NULL\n    );\n#endif\n  }\n\n  OSTRACE((\"OPEN %d %s 0x%lx %s\\n\", \n           h, zName, dwDesiredAccess, \n           h==INVALID_HANDLE_VALUE ? \"failed\" : \"ok\"));\n\n  if( h==INVALID_HANDLE_VALUE ){\n    pFile->lastErrno = GetLastError();\n    free(zConverted);\n    if( isReadWrite ){\n      return winOpen(pVfs, zName, id, \n             ((flags|SQLITE_OPEN_READONLY)&~(SQLITE_OPEN_CREATE|SQLITE_OPEN_READWRITE)), pOutFlags);\n    }else{\n      return SQLITE_CANTOPEN_BKPT;\n    }\n  }\n\n  if( pOutFlags ){\n    if( isReadWrite ){\n      *pOutFlags = SQLITE_OPEN_READWRITE;\n    }else{\n      *pOutFlags = SQLITE_OPEN_READONLY;\n    }\n  }\n\n  memset(pFile, 0, sizeof(*pFile));\n  pFile->pMethod = &winIoMethod;\n  pFile->h = h;\n  pFile->lastErrno = NO_ERROR;\n  pFile->pVfs = pVfs;\n  pFile->pShm = 0;\n  pFile->zPath = zName;\n  pFile->sectorSize = getSectorSize(pVfs, zUtf8Name);\n\n#if SQLITE_OS_WINCE\n  if( isReadWrite && eType==SQLITE_OPEN_MAIN_DB\n       && !winceCreateLock(zName, pFile)\n  ){\n    CloseHandle(h);\n    free(zConverted);\n    return SQLITE_CANTOPEN_BKPT;\n  }\n  if( isTemp ){\n    pFile->zDeleteOnClose = zConverted;\n  }else\n#endif\n  {\n    free(zConverted);\n  }\n\n  OpenCounter(+1);\n  return rc;\n}\n\n/*\n** Delete the named file.\n**\n** Note that windows does not allow a file to be deleted if some other\n** process has it open.  Sometimes a virus scanner or indexing program\n** will open a journal file shortly after it is created in order to do\n** whatever it does.  While this other process is holding the\n** file open, we will be unable to delete it.  To work around this\n** problem, we delay 100 milliseconds and try to delete again.  Up\n** to MX_DELETION_ATTEMPTs deletion attempts are run before giving\n** up and returning an error.\n*/\n#define MX_DELETION_ATTEMPTS 5\nstatic int winDelete(\n  sqlite3_vfs *pVfs,          /* Not used on win32 */\n  const char *zFilename,      /* Name of file to delete */\n  int syncDir                 /* Not used on win32 */\n){\n  int cnt = 0;\n  DWORD rc;\n  DWORD error = 0;\n  void *zConverted;\n  UNUSED_PARAMETER(pVfs);\n  UNUSED_PARAMETER(syncDir);\n\n  SimulateIOError(return SQLITE_IOERR_DELETE);\n  zConverted = convertUtf8Filename(zFilename);\n  if( zConverted==0 ){\n    return SQLITE_NOMEM;\n  }\n  if( isNT() ){\n    do{\n      DeleteFileW(zConverted);\n    }while(   (   ((rc = GetFileAttributesW(zConverted)) != INVALID_FILE_ATTRIBUTES)\n               || ((error = GetLastError()) == ERROR_ACCESS_DENIED))\n           && (++cnt < MX_DELETION_ATTEMPTS)\n           && (Sleep(100), 1) );\n/* isNT() is 1 if SQLITE_OS_WINCE==1, so this else is never executed. \n** Since the ASCII version of these Windows API do not exist for WINCE,\n** it's important to not reference them for WINCE builds.\n*/\n#if SQLITE_OS_WINCE==0\n  }else{\n    do{\n      DeleteFileA(zConverted);\n    }while(   (   ((rc = GetFileAttributesA(zConverted)) != INVALID_FILE_ATTRIBUTES)\n               || ((error = GetLastError()) == ERROR_ACCESS_DENIED))\n           && (++cnt < MX_DELETION_ATTEMPTS)\n           && (Sleep(100), 1) );\n#endif\n  }\n  free(zConverted);\n  OSTRACE((\"DELETE \\\"%s\\\" %s\\n\", zFilename,\n       ( (rc==INVALID_FILE_ATTRIBUTES) && (error==ERROR_FILE_NOT_FOUND)) ?\n         \"ok\" : \"failed\" ));\n \n  return (   (rc == INVALID_FILE_ATTRIBUTES) \n          && (error == ERROR_FILE_NOT_FOUND)) ? SQLITE_OK : SQLITE_IOERR_DELETE;\n}\n\n/*\n** Check the existance and status of a file.\n*/\nstatic int winAccess(\n  sqlite3_vfs *pVfs,         /* Not used on win32 */\n  const char *zFilename,     /* Name of file to check */\n  int flags,                 /* Type of test to make on this file */\n  int *pResOut               /* OUT: Result */\n){\n  DWORD attr;\n  int rc = 0;\n  void *zConverted;\n  UNUSED_PARAMETER(pVfs);\n\n  SimulateIOError( return SQLITE_IOERR_ACCESS; );\n  zConverted = convertUtf8Filename(zFilename);\n  if( zConverted==0 ){\n    return SQLITE_NOMEM;\n  }\n  if( isNT() ){\n    WIN32_FILE_ATTRIBUTE_DATA sAttrData;\n    memset(&sAttrData, 0, sizeof(sAttrData));\n    if( GetFileAttributesExW((WCHAR*)zConverted,\n                             GetFileExInfoStandard, \n                             &sAttrData) ){\n      /* For an SQLITE_ACCESS_EXISTS query, treat a zero-length file\n      ** as if it does not exist.\n      */\n      if(    flags==SQLITE_ACCESS_EXISTS\n          && sAttrData.nFileSizeHigh==0 \n          && sAttrData.nFileSizeLow==0 ){\n        attr = INVALID_FILE_ATTRIBUTES;\n      }else{\n        attr = sAttrData.dwFileAttributes;\n      }\n    }else{\n      if( GetLastError()!=ERROR_FILE_NOT_FOUND ){\n        free(zConverted);\n        return SQLITE_IOERR_ACCESS;\n      }else{\n        attr = INVALID_FILE_ATTRIBUTES;\n      }\n    }\n/* isNT() is 1 if SQLITE_OS_WINCE==1, so this else is never executed. \n** Since the ASCII version of these Windows API do not exist for WINCE,\n** it's important to not reference them for WINCE builds.\n*/\n#if SQLITE_OS_WINCE==0\n  }else{\n    attr = GetFileAttributesA((char*)zConverted);\n#endif\n  }\n  free(zConverted);\n  switch( flags ){\n    case SQLITE_ACCESS_READ:\n    case SQLITE_ACCESS_EXISTS:\n      rc = attr!=INVALID_FILE_ATTRIBUTES;\n      break;\n    case SQLITE_ACCESS_READWRITE:\n      rc = (attr & FILE_ATTRIBUTE_READONLY)==0;\n      break;\n    default:\n      assert(!\"Invalid flags argument\");\n  }\n  *pResOut = rc;\n  return SQLITE_OK;\n}\n\n\n/*\n** Turn a relative pathname into a full pathname.  Write the full\n** pathname into zOut[].  zOut[] will be at least pVfs->mxPathname\n** bytes in size.\n*/\nstatic int winFullPathname(\n  sqlite3_vfs *pVfs,            /* Pointer to vfs object */\n  const char *zRelative,        /* Possibly relative input path */\n  int nFull,                    /* Size of output buffer in bytes */\n  char *zFull                   /* Output buffer */\n){\n  \n#if defined(__CYGWIN__)\n  SimulateIOError( return SQLITE_ERROR );\n  UNUSED_PARAMETER(nFull);\n  cygwin_conv_to_full_win32_path(zRelative, zFull);\n  return SQLITE_OK;\n#endif\n\n#if SQLITE_OS_WINCE\n  SimulateIOError( return SQLITE_ERROR );\n  UNUSED_PARAMETER(nFull);\n  /* WinCE has no concept of a relative pathname, or so I am told. */\n  sqlite3_snprintf(pVfs->mxPathname, zFull, \"%s\", zRelative);\n  return SQLITE_OK;\n#endif\n\n#if !SQLITE_OS_WINCE && !defined(__CYGWIN__)\n  int nByte;\n  void *zConverted;\n  char *zOut;\n\n  /* It's odd to simulate an io-error here, but really this is just\n  ** using the io-error infrastructure to test that SQLite handles this\n  ** function failing. This function could fail if, for example, the\n  ** current working directory has been unlinked.\n  */\n  SimulateIOError( return SQLITE_ERROR );\n  UNUSED_PARAMETER(nFull);\n  zConverted = convertUtf8Filename(zRelative);\n  if( isNT() ){\n    WCHAR *zTemp;\n    nByte = GetFullPathNameW((WCHAR*)zConverted, 0, 0, 0) + 3;\n    zTemp = malloc( nByte*sizeof(zTemp[0]) );\n    if( zTemp==0 ){\n      free(zConverted);\n      return SQLITE_NOMEM;\n    }\n    GetFullPathNameW((WCHAR*)zConverted, nByte, zTemp, 0);\n    free(zConverted);\n    zOut = unicodeToUtf8(zTemp);\n    free(zTemp);\n/* isNT() is 1 if SQLITE_OS_WINCE==1, so this else is never executed. \n** Since the ASCII version of these Windows API do not exist for WINCE,\n** it's important to not reference them for WINCE builds.\n*/\n#if SQLITE_OS_WINCE==0\n  }else{\n    char *zTemp;\n    nByte = GetFullPathNameA((char*)zConverted, 0, 0, 0) + 3;\n    zTemp = malloc( nByte*sizeof(zTemp[0]) );\n    if( zTemp==0 ){\n      free(zConverted);\n      return SQLITE_NOMEM;\n    }\n    GetFullPathNameA((char*)zConverted, nByte, zTemp, 0);\n    free(zConverted);\n    zOut = sqlite3_win32_mbcs_to_utf8(zTemp);\n    free(zTemp);\n#endif\n  }\n  if( zOut ){\n    sqlite3_snprintf(pVfs->mxPathname, zFull, \"%s\", zOut);\n    free(zOut);\n    return SQLITE_OK;\n  }else{\n    return SQLITE_NOMEM;\n  }\n#endif\n}\n\n/*\n** Get the sector size of the device used to store\n** file.\n*/\nstatic int getSectorSize(\n    sqlite3_vfs *pVfs,\n    const char *zRelative     /* UTF-8 file name */\n){\n  DWORD bytesPerSector = SQLITE_DEFAULT_SECTOR_SIZE;\n  /* GetDiskFreeSpace is not supported under WINCE */\n#if SQLITE_OS_WINCE\n  UNUSED_PARAMETER(pVfs);\n  UNUSED_PARAMETER(zRelative);\n#else\n  char zFullpath[MAX_PATH+1];\n  int rc;\n  DWORD dwRet = 0;\n  DWORD dwDummy;\n\n  /*\n  ** We need to get the full path name of the file\n  ** to get the drive letter to look up the sector\n  ** size.\n  */\n  SimulateIOErrorBenign(1);\n  rc = winFullPathname(pVfs, zRelative, MAX_PATH, zFullpath);\n  SimulateIOErrorBenign(0);\n  if( rc == SQLITE_OK )\n  {\n    void *zConverted = convertUtf8Filename(zFullpath);\n    if( zConverted ){\n      if( isNT() ){\n        /* trim path to just drive reference */\n        WCHAR *p = zConverted;\n        for(;*p;p++){\n          if( *p == '\\\\' ){\n            *p = '\\0';\n            break;\n          }\n        }\n        dwRet = GetDiskFreeSpaceW((WCHAR*)zConverted,\n                                  &dwDummy,\n                                  &bytesPerSector,\n                                  &dwDummy,\n                                  &dwDummy);\n      }else{\n        /* trim path to just drive reference */\n        char *p = (char *)zConverted;\n        for(;*p;p++){\n          if( *p == '\\\\' ){\n            *p = '\\0';\n            break;\n          }\n        }\n        dwRet = GetDiskFreeSpaceA((char*)zConverted,\n                                  &dwDummy,\n                                  &bytesPerSector,\n                                  &dwDummy,\n                                  &dwDummy);\n      }\n      free(zConverted);\n    }\n    if( !dwRet ){\n      bytesPerSector = SQLITE_DEFAULT_SECTOR_SIZE;\n    }\n  }\n#endif\n  return (int) bytesPerSector; \n}\n\n#ifndef SQLITE_OMIT_LOAD_EXTENSION\n/*\n** Interfaces for opening a shared library, finding entry points\n** within the shared library, and closing the shared library.\n*/\n/*\n** Interfaces for opening a shared library, finding entry points\n** within the shared library, and closing the shared library.\n*/\nstatic void *winDlOpen(sqlite3_vfs *pVfs, const char *zFilename){\n  HANDLE h;\n  void *zConverted = convertUtf8Filename(zFilename);\n  UNUSED_PARAMETER(pVfs);\n  if( zConverted==0 ){\n    return 0;\n  }\n  if( isNT() ){\n    h = LoadLibraryW((WCHAR*)zConverted);\n/* isNT() is 1 if SQLITE_OS_WINCE==1, so this else is never executed. \n** Since the ASCII version of these Windows API do not exist for WINCE,\n** it's important to not reference them for WINCE builds.\n*/\n#if SQLITE_OS_WINCE==0\n  }else{\n    h = LoadLibraryA((char*)zConverted);\n#endif\n  }\n  free(zConverted);\n  return (void*)h;\n}\nstatic void winDlError(sqlite3_vfs *pVfs, int nBuf, char *zBufOut){\n  UNUSED_PARAMETER(pVfs);\n  getLastErrorMsg(nBuf, zBufOut);\n}\nvoid (*winDlSym(sqlite3_vfs *pVfs, void *pHandle, const char *zSymbol))(void){\n  UNUSED_PARAMETER(pVfs);\n#if SQLITE_OS_WINCE\n  /* The GetProcAddressA() routine is only available on wince. */\n  return (void(*)(void))GetProcAddressA((HANDLE)pHandle, zSymbol);\n#else\n  /* All other windows platforms expect GetProcAddress() to take\n  ** an Ansi string regardless of the _UNICODE setting */\n  return (void(*)(void))GetProcAddress((HANDLE)pHandle, zSymbol);\n#endif\n}\nvoid winDlClose(sqlite3_vfs *pVfs, void *pHandle){\n  UNUSED_PARAMETER(pVfs);\n  FreeLibrary((HANDLE)pHandle);\n}\n#else /* if SQLITE_OMIT_LOAD_EXTENSION is defined: */\n  #define winDlOpen  0\n  #define winDlError 0\n  #define winDlSym   0\n  #define winDlClose 0\n#endif\n\n\n/*\n** Write up to nBuf bytes of randomness into zBuf.\n*/\nstatic int winRandomness(sqlite3_vfs *pVfs, int nBuf, char *zBuf){\n  int n = 0;\n  UNUSED_PARAMETER(pVfs);\n#if defined(SQLITE_TEST)\n  n = nBuf;\n  memset(zBuf, 0, nBuf);\n#else\n  if( sizeof(SYSTEMTIME)<=nBuf-n ){\n    SYSTEMTIME x;\n    GetSystemTime(&x);\n    memcpy(&zBuf[n], &x, sizeof(x));\n    n += sizeof(x);\n  }\n  if( sizeof(DWORD)<=nBuf-n ){\n    DWORD pid = GetCurrentProcessId();\n    memcpy(&zBuf[n], &pid, sizeof(pid));\n    n += sizeof(pid);\n  }\n  if( sizeof(DWORD)<=nBuf-n ){\n    DWORD cnt = GetTickCount();\n    memcpy(&zBuf[n], &cnt, sizeof(cnt));\n    n += sizeof(cnt);\n  }\n  if( sizeof(LARGE_INTEGER)<=nBuf-n ){\n    LARGE_INTEGER i;\n    QueryPerformanceCounter(&i);\n    memcpy(&zBuf[n], &i, sizeof(i));\n    n += sizeof(i);\n  }\n#endif\n  return n;\n}\n\n\n/*\n** Sleep for a little while.  Return the amount of time slept.\n*/\nstatic int winSleep(sqlite3_vfs *pVfs, int microsec){\n  Sleep((microsec+999)/1000);\n  UNUSED_PARAMETER(pVfs);\n  return ((microsec+999)/1000)*1000;\n}\n\n/*\n** The following variable, if set to a non-zero value, is interpreted as\n** the number of seconds since 1970 and is used to set the result of\n** sqlite3OsCurrentTime() during testing.\n*/\n#ifdef SQLITE_TEST\nSQLITE_API int sqlite3_current_time = 0;  /* Fake system time in seconds since 1970. */\n#endif\n\n/*\n** Find the current time (in Universal Coordinated Time).  Write into *piNow\n** the current time and date as a Julian Day number times 86_400_000.  In\n** other words, write into *piNow the number of milliseconds since the Julian\n** epoch of noon in Greenwich on November 24, 4714 B.C according to the\n** proleptic Gregorian calendar.\n**\n** On success, return 0.  Return 1 if the time and date cannot be found.\n*/\nstatic int winCurrentTimeInt64(sqlite3_vfs *pVfs, sqlite3_int64 *piNow){\n  /* FILETIME structure is a 64-bit value representing the number of \n     100-nanosecond intervals since January 1, 1601 (= JD 2305813.5). \n  */\n  FILETIME ft;\n  static const sqlite3_int64 winFiletimeEpoch = 23058135*(sqlite3_int64)8640000;\n#ifdef SQLITE_TEST\n  static const sqlite3_int64 unixEpoch = 24405875*(sqlite3_int64)8640000;\n#endif\n  /* 2^32 - to avoid use of LL and warnings in gcc */\n  static const sqlite3_int64 max32BitValue = \n      (sqlite3_int64)2000000000 + (sqlite3_int64)2000000000 + (sqlite3_int64)294967296;\n\n#if SQLITE_OS_WINCE\n  SYSTEMTIME time;\n  GetSystemTime(&time);\n  /* if SystemTimeToFileTime() fails, it returns zero. */\n  if (!SystemTimeToFileTime(&time,&ft)){\n    return 1;\n  }\n#else\n  GetSystemTimeAsFileTime( &ft );\n#endif\n\n  *piNow = winFiletimeEpoch +\n            ((((sqlite3_int64)ft.dwHighDateTime)*max32BitValue) + \n               (sqlite3_int64)ft.dwLowDateTime)/(sqlite3_int64)10000;\n\n#ifdef SQLITE_TEST\n  if( sqlite3_current_time ){\n    *piNow = 1000*(sqlite3_int64)sqlite3_current_time + unixEpoch;\n  }\n#endif\n  UNUSED_PARAMETER(pVfs);\n  return 0;\n}\n\n/*\n** Find the current time (in Universal Coordinated Time).  Write the\n** current time and date as a Julian Day number into *prNow and\n** return 0.  Return 1 if the time and date cannot be found.\n*/\nint winCurrentTime(sqlite3_vfs *pVfs, double *prNow){\n  int rc;\n  sqlite3_int64 i;\n  rc = winCurrentTimeInt64(pVfs, &i);\n  if( !rc ){\n    *prNow = i/86400000.0;\n  }\n  return rc;\n}\n\n/*\n** The idea is that this function works like a combination of\n** GetLastError() and FormatMessage() on windows (or errno and\n** strerror_r() on unix). After an error is returned by an OS\n** function, SQLite calls this function with zBuf pointing to\n** a buffer of nBuf bytes. The OS layer should populate the\n** buffer with a nul-terminated UTF-8 encoded error message\n** describing the last IO error to have occurred within the calling\n** thread.\n**\n** If the error message is too large for the supplied buffer,\n** it should be truncated. The return value of xGetLastError\n** is zero if the error message fits in the buffer, or non-zero\n** otherwise (if the message was truncated). If non-zero is returned,\n** then it is not necessary to include the nul-terminator character\n** in the output buffer.\n**\n** Not supplying an error message will have no adverse effect\n** on SQLite. It is fine to have an implementation that never\n** returns an error message:\n**\n**   int xGetLastError(sqlite3_vfs *pVfs, int nBuf, char *zBuf){\n**     assert(zBuf[0]=='\\0');\n**     return 0;\n**   }\n**\n** However if an error message is supplied, it will be incorporated\n** by sqlite into the error message available to the user using\n** sqlite3_errmsg(), possibly making IO errors easier to debug.\n*/\nstatic int winGetLastError(sqlite3_vfs *pVfs, int nBuf, char *zBuf){\n  UNUSED_PARAMETER(pVfs);\n  return getLastErrorMsg(nBuf, zBuf);\n}\n\n\n\n/*\n** Initialize and deinitialize the operating system interface.\n*/\nSQLITE_API int sqlite3_os_init(void){\n  static sqlite3_vfs winVfs = {\n    3,                   /* iVersion */\n    sizeof(winFile),     /* szOsFile */\n    MAX_PATH,            /* mxPathname */\n    0,                   /* pNext */\n    \"win32\",             /* zName */\n    0,                   /* pAppData */\n    winOpen,             /* xOpen */\n    winDelete,           /* xDelete */\n    winAccess,           /* xAccess */\n    winFullPathname,     /* xFullPathname */\n    winDlOpen,           /* xDlOpen */\n    winDlError,          /* xDlError */\n    winDlSym,            /* xDlSym */\n    winDlClose,          /* xDlClose */\n    winRandomness,       /* xRandomness */\n    winSleep,            /* xSleep */\n    winCurrentTime,      /* xCurrentTime */\n    winGetLastError,     /* xGetLastError */\n    winCurrentTimeInt64, /* xCurrentTimeInt64 */\n    0,                   /* xSetSystemCall */\n    0,                   /* xGetSystemCall */\n    0,                   /* xNextSystemCall */\n  };\n\n#ifndef SQLITE_OMIT_WAL\n  /* get memory map allocation granularity */\n  memset(&winSysInfo, 0, sizeof(SYSTEM_INFO));\n  GetSystemInfo(&winSysInfo);\n  assert(winSysInfo.dwAllocationGranularity > 0);\n#endif\n\n  sqlite3_vfs_register(&winVfs, 1);\n  return SQLITE_OK; \n}\nSQLITE_API int sqlite3_os_end(void){ \n  return SQLITE_OK;\n}\n\n#endif /* SQLITE_OS_WIN */\n\n/************** End of os_win.c **********************************************/\n/************** Begin file bitvec.c ******************************************/\n/*\n** 2008 February 16\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file implements an object that represents a fixed-length\n** bitmap.  Bits are numbered starting with 1.\n**\n** A bitmap is used to record which pages of a database file have been\n** journalled during a transaction, or which pages have the \"dont-write\"\n** property.  Usually only a few pages are meet either condition.\n** So the bitmap is usually sparse and has low cardinality.\n** But sometimes (for example when during a DROP of a large table) most\n** or all of the pages in a database can get journalled.  In those cases, \n** the bitmap becomes dense with high cardinality.  The algorithm needs \n** to handle both cases well.\n**\n** The size of the bitmap is fixed when the object is created.\n**\n** All bits are clear when the bitmap is created.  Individual bits\n** may be set or cleared one at a time.\n**\n** Test operations are about 100 times more common that set operations.\n** Clear operations are exceedingly rare.  There are usually between\n** 5 and 500 set operations per Bitvec object, though the number of sets can\n** sometimes grow into tens of thousands or larger.  The size of the\n** Bitvec object is the number of pages in the database file at the\n** start of a transaction, and is thus usually less than a few thousand,\n** but can be as large as 2 billion for a really big database.\n*/\n\n/* Size of the Bitvec structure in bytes. */\n#define BITVEC_SZ        512\n\n/* Round the union size down to the nearest pointer boundary, since that's how \n** it will be aligned within the Bitvec struct. */\n#define BITVEC_USIZE     (((BITVEC_SZ-(3*sizeof(u32)))/sizeof(Bitvec*))*sizeof(Bitvec*))\n\n/* Type of the array \"element\" for the bitmap representation. \n** Should be a power of 2, and ideally, evenly divide into BITVEC_USIZE. \n** Setting this to the \"natural word\" size of your CPU may improve\n** performance. */\n#define BITVEC_TELEM     u8\n/* Size, in bits, of the bitmap element. */\n#define BITVEC_SZELEM    8\n/* Number of elements in a bitmap array. */\n#define BITVEC_NELEM     (BITVEC_USIZE/sizeof(BITVEC_TELEM))\n/* Number of bits in the bitmap array. */\n#define BITVEC_NBIT      (BITVEC_NELEM*BITVEC_SZELEM)\n\n/* Number of u32 values in hash table. */\n#define BITVEC_NINT      (BITVEC_USIZE/sizeof(u32))\n/* Maximum number of entries in hash table before \n** sub-dividing and re-hashing. */\n#define BITVEC_MXHASH    (BITVEC_NINT/2)\n/* Hashing function for the aHash representation.\n** Empirical testing showed that the *37 multiplier \n** (an arbitrary prime)in the hash function provided \n** no fewer collisions than the no-op *1. */\n#define BITVEC_HASH(X)   (((X)*1)%BITVEC_NINT)\n\n#define BITVEC_NPTR      (BITVEC_USIZE/sizeof(Bitvec *))\n\n\n/*\n** A bitmap is an instance of the following structure.\n**\n** This bitmap records the existance of zero or more bits\n** with values between 1 and iSize, inclusive.\n**\n** There are three possible representations of the bitmap.\n** If iSize<=BITVEC_NBIT, then Bitvec.u.aBitmap[] is a straight\n** bitmap.  The least significant bit is bit 1.\n**\n** If iSize>BITVEC_NBIT and iDivisor==0 then Bitvec.u.aHash[] is\n** a hash table that will hold up to BITVEC_MXHASH distinct values.\n**\n** Otherwise, the value i is redirected into one of BITVEC_NPTR\n** sub-bitmaps pointed to by Bitvec.u.apSub[].  Each subbitmap\n** handles up to iDivisor separate values of i.  apSub[0] holds\n** values between 1 and iDivisor.  apSub[1] holds values between\n** iDivisor+1 and 2*iDivisor.  apSub[N] holds values between\n** N*iDivisor+1 and (N+1)*iDivisor.  Each subbitmap is normalized\n** to hold deal with values between 1 and iDivisor.\n*/\nstruct Bitvec {\n  u32 iSize;      /* Maximum bit index.  Max iSize is 4,294,967,296. */\n  u32 nSet;       /* Number of bits that are set - only valid for aHash\n                  ** element.  Max is BITVEC_NINT.  For BITVEC_SZ of 512,\n                  ** this would be 125. */\n  u32 iDivisor;   /* Number of bits handled by each apSub[] entry. */\n                  /* Should >=0 for apSub element. */\n                  /* Max iDivisor is max(u32) / BITVEC_NPTR + 1.  */\n                  /* For a BITVEC_SZ of 512, this would be 34,359,739. */\n  union {\n    BITVEC_TELEM aBitmap[BITVEC_NELEM];    /* Bitmap representation */\n    u32 aHash[BITVEC_NINT];      /* Hash table representation */\n    Bitvec *apSub[BITVEC_NPTR];  /* Recursive representation */\n  } u;\n};\n\n/*\n** Create a new bitmap object able to handle bits between 0 and iSize,\n** inclusive.  Return a pointer to the new object.  Return NULL if \n** malloc fails.\n*/\nSQLITE_PRIVATE Bitvec *sqlite3BitvecCreate(u32 iSize){\n  Bitvec *p;\n  assert( sizeof(*p)==BITVEC_SZ );\n  p = sqlite3MallocZero( sizeof(*p) );\n  if( p ){\n    p->iSize = iSize;\n  }\n  return p;\n}\n\n/*\n** Check to see if the i-th bit is set.  Return true or false.\n** If p is NULL (if the bitmap has not been created) or if\n** i is out of range, then return false.\n*/\nSQLITE_PRIVATE int sqlite3BitvecTest(Bitvec *p, u32 i){\n  if( p==0 ) return 0;\n  if( i>p->iSize || i==0 ) return 0;\n  i--;\n  while( p->iDivisor ){\n    u32 bin = i/p->iDivisor;\n    i = i%p->iDivisor;\n    p = p->u.apSub[bin];\n    if (!p) {\n      return 0;\n    }\n  }\n  if( p->iSize<=BITVEC_NBIT ){\n    return (p->u.aBitmap[i/BITVEC_SZELEM] & (1<<(i&(BITVEC_SZELEM-1))))!=0;\n  } else{\n    u32 h = BITVEC_HASH(i++);\n    while( p->u.aHash[h] ){\n      if( p->u.aHash[h]==i ) return 1;\n      h = (h+1) % BITVEC_NINT;\n    }\n    return 0;\n  }\n}\n\n/*\n** Set the i-th bit.  Return 0 on success and an error code if\n** anything goes wrong.\n**\n** This routine might cause sub-bitmaps to be allocated.  Failing\n** to get the memory needed to hold the sub-bitmap is the only\n** that can go wrong with an insert, assuming p and i are valid.\n**\n** The calling function must ensure that p is a valid Bitvec object\n** and that the value for \"i\" is within range of the Bitvec object.\n** Otherwise the behavior is undefined.\n*/\nSQLITE_PRIVATE int sqlite3BitvecSet(Bitvec *p, u32 i){\n  u32 h;\n  if( p==0 ) return SQLITE_OK;\n  assert( i>0 );\n  assert( i<=p->iSize );\n  i--;\n  while((p->iSize > BITVEC_NBIT) && p->iDivisor) {\n    u32 bin = i/p->iDivisor;\n    i = i%p->iDivisor;\n    if( p->u.apSub[bin]==0 ){\n      p->u.apSub[bin] = sqlite3BitvecCreate( p->iDivisor );\n      if( p->u.apSub[bin]==0 ) return SQLITE_NOMEM;\n    }\n    p = p->u.apSub[bin];\n  }\n  if( p->iSize<=BITVEC_NBIT ){\n    p->u.aBitmap[i/BITVEC_SZELEM] |= 1 << (i&(BITVEC_SZELEM-1));\n    return SQLITE_OK;\n  }\n  h = BITVEC_HASH(i++);\n  /* if there wasn't a hash collision, and this doesn't */\n  /* completely fill the hash, then just add it without */\n  /* worring about sub-dividing and re-hashing. */\n  if( !p->u.aHash[h] ){\n    if (p->nSet<(BITVEC_NINT-1)) {\n      goto bitvec_set_end;\n    } else {\n      goto bitvec_set_rehash;\n    }\n  }\n  /* there was a collision, check to see if it's already */\n  /* in hash, if not, try to find a spot for it */\n  do {\n    if( p->u.aHash[h]==i ) return SQLITE_OK;\n    h++;\n    if( h>=BITVEC_NINT ) h = 0;\n  } while( p->u.aHash[h] );\n  /* we didn't find it in the hash.  h points to the first */\n  /* available free spot. check to see if this is going to */\n  /* make our hash too \"full\".  */\nbitvec_set_rehash:\n  if( p->nSet>=BITVEC_MXHASH ){\n    unsigned int j;\n    int rc;\n    u32 *aiValues = sqlite3StackAllocRaw(0, sizeof(p->u.aHash));\n    if( aiValues==0 ){\n      return SQLITE_NOMEM;\n    }else{\n      memcpy(aiValues, p->u.aHash, sizeof(p->u.aHash));\n      memset(p->u.apSub, 0, sizeof(p->u.apSub));\n      p->iDivisor = (p->iSize + BITVEC_NPTR - 1)/BITVEC_NPTR;\n      rc = sqlite3BitvecSet(p, i);\n      for(j=0; j<BITVEC_NINT; j++){\n        if( aiValues[j] ) rc |= sqlite3BitvecSet(p, aiValues[j]);\n      }\n      sqlite3StackFree(0, aiValues);\n      return rc;\n    }\n  }\nbitvec_set_end:\n  p->nSet++;\n  p->u.aHash[h] = i;\n  return SQLITE_OK;\n}\n\n/*\n** Clear the i-th bit.\n**\n** pBuf must be a pointer to at least BITVEC_SZ bytes of temporary storage\n** that BitvecClear can use to rebuilt its hash table.\n*/\nSQLITE_PRIVATE void sqlite3BitvecClear(Bitvec *p, u32 i, void *pBuf){\n  if( p==0 ) return;\n  assert( i>0 );\n  i--;\n  while( p->iDivisor ){\n    u32 bin = i/p->iDivisor;\n    i = i%p->iDivisor;\n    p = p->u.apSub[bin];\n    if (!p) {\n      return;\n    }\n  }\n  if( p->iSize<=BITVEC_NBIT ){\n    p->u.aBitmap[i/BITVEC_SZELEM] &= ~(1 << (i&(BITVEC_SZELEM-1)));\n  }else{\n    unsigned int j;\n    u32 *aiValues = pBuf;\n    memcpy(aiValues, p->u.aHash, sizeof(p->u.aHash));\n    memset(p->u.aHash, 0, sizeof(p->u.aHash));\n    p->nSet = 0;\n    for(j=0; j<BITVEC_NINT; j++){\n      if( aiValues[j] && aiValues[j]!=(i+1) ){\n        u32 h = BITVEC_HASH(aiValues[j]-1);\n        p->nSet++;\n        while( p->u.aHash[h] ){\n          h++;\n          if( h>=BITVEC_NINT ) h = 0;\n        }\n        p->u.aHash[h] = aiValues[j];\n      }\n    }\n  }\n}\n\n/*\n** Destroy a bitmap object.  Reclaim all memory used.\n*/\nSQLITE_PRIVATE void sqlite3BitvecDestroy(Bitvec *p){\n  if( p==0 ) return;\n  if( p->iDivisor ){\n    unsigned int i;\n    for(i=0; i<BITVEC_NPTR; i++){\n      sqlite3BitvecDestroy(p->u.apSub[i]);\n    }\n  }\n  sqlite3_free(p);\n}\n\n/*\n** Return the value of the iSize parameter specified when Bitvec *p\n** was created.\n*/\nSQLITE_PRIVATE u32 sqlite3BitvecSize(Bitvec *p){\n  return p->iSize;\n}\n\n#ifndef SQLITE_OMIT_BUILTIN_TEST\n/*\n** Let V[] be an array of unsigned characters sufficient to hold\n** up to N bits.  Let I be an integer between 0 and N.  0<=I<N.\n** Then the following macros can be used to set, clear, or test\n** individual bits within V.\n*/\n#define SETBIT(V,I)      V[I>>3] |= (1<<(I&7))\n#define CLEARBIT(V,I)    V[I>>3] &= ~(1<<(I&7))\n#define TESTBIT(V,I)     (V[I>>3]&(1<<(I&7)))!=0\n\n/*\n** This routine runs an extensive test of the Bitvec code.\n**\n** The input is an array of integers that acts as a program\n** to test the Bitvec.  The integers are opcodes followed\n** by 0, 1, or 3 operands, depending on the opcode.  Another\n** opcode follows immediately after the last operand.\n**\n** There are 6 opcodes numbered from 0 through 5.  0 is the\n** \"halt\" opcode and causes the test to end.\n**\n**    0          Halt and return the number of errors\n**    1 N S X    Set N bits beginning with S and incrementing by X\n**    2 N S X    Clear N bits beginning with S and incrementing by X\n**    3 N        Set N randomly chosen bits\n**    4 N        Clear N randomly chosen bits\n**    5 N S X    Set N bits from S increment X in array only, not in bitvec\n**\n** The opcodes 1 through 4 perform set and clear operations are performed\n** on both a Bitvec object and on a linear array of bits obtained from malloc.\n** Opcode 5 works on the linear array only, not on the Bitvec.\n** Opcode 5 is used to deliberately induce a fault in order to\n** confirm that error detection works.\n**\n** At the conclusion of the test the linear array is compared\n** against the Bitvec object.  If there are any differences,\n** an error is returned.  If they are the same, zero is returned.\n**\n** If a memory allocation error occurs, return -1.\n*/\nSQLITE_PRIVATE int sqlite3BitvecBuiltinTest(int sz, int *aOp){\n  Bitvec *pBitvec = 0;\n  unsigned char *pV = 0;\n  int rc = -1;\n  int i, nx, pc, op;\n  void *pTmpSpace;\n\n  /* Allocate the Bitvec to be tested and a linear array of\n  ** bits to act as the reference */\n  pBitvec = sqlite3BitvecCreate( sz );\n  pV = sqlite3_malloc( (sz+7)/8 + 1 );\n  pTmpSpace = sqlite3_malloc(BITVEC_SZ);\n  if( pBitvec==0 || pV==0 || pTmpSpace==0  ) goto bitvec_end;\n  memset(pV, 0, (sz+7)/8 + 1);\n\n  /* NULL pBitvec tests */\n  sqlite3BitvecSet(0, 1);\n  sqlite3BitvecClear(0, 1, pTmpSpace);\n\n  /* Run the program */\n  pc = 0;\n  while( (op = aOp[pc])!=0 ){\n    switch( op ){\n      case 1:\n      case 2:\n      case 5: {\n        nx = 4;\n        i = aOp[pc+2] - 1;\n        aOp[pc+2] += aOp[pc+3];\n        break;\n      }\n      case 3:\n      case 4: \n      default: {\n        nx = 2;\n        sqlite3_randomness(sizeof(i), &i);\n        break;\n      }\n    }\n    if( (--aOp[pc+1]) > 0 ) nx = 0;\n    pc += nx;\n    i = (i & 0x7fffffff)%sz;\n    if( (op & 1)!=0 ){\n      SETBIT(pV, (i+1));\n      if( op!=5 ){\n        if( sqlite3BitvecSet(pBitvec, i+1) ) goto bitvec_end;\n      }\n    }else{\n      CLEARBIT(pV, (i+1));\n      sqlite3BitvecClear(pBitvec, i+1, pTmpSpace);\n    }\n  }\n\n  /* Test to make sure the linear array exactly matches the\n  ** Bitvec object.  Start with the assumption that they do\n  ** match (rc==0).  Change rc to non-zero if a discrepancy\n  ** is found.\n  */\n  rc = sqlite3BitvecTest(0,0) + sqlite3BitvecTest(pBitvec, sz+1)\n          + sqlite3BitvecTest(pBitvec, 0)\n          + (sqlite3BitvecSize(pBitvec) - sz);\n  for(i=1; i<=sz; i++){\n    if(  (TESTBIT(pV,i))!=sqlite3BitvecTest(pBitvec,i) ){\n      rc = i;\n      break;\n    }\n  }\n\n  /* Free allocated structure */\nbitvec_end:\n  sqlite3_free(pTmpSpace);\n  sqlite3_free(pV);\n  sqlite3BitvecDestroy(pBitvec);\n  return rc;\n}\n#endif /* SQLITE_OMIT_BUILTIN_TEST */\n\n/************** End of bitvec.c **********************************************/\n/************** Begin file pcache.c ******************************************/\n/*\n** 2008 August 05\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file implements that page cache.\n*/\n\n/*\n** A complete page cache is an instance of this structure.\n*/\nstruct PCache {\n  PgHdr *pDirty, *pDirtyTail;         /* List of dirty pages in LRU order */\n  PgHdr *pSynced;                     /* Last synced page in dirty page list */\n  int nRef;                           /* Number of referenced pages */\n  int nMax;                           /* Configured cache size */\n  int szPage;                         /* Size of every page in this cache */\n  int szExtra;                        /* Size of extra space for each page */\n  int bPurgeable;                     /* True if pages are on backing store */\n  int (*xStress)(void*,PgHdr*);       /* Call to try make a page clean */\n  void *pStress;                      /* Argument to xStress */\n  sqlite3_pcache *pCache;             /* Pluggable cache module */\n  PgHdr *pPage1;                      /* Reference to page 1 */\n};\n\n/*\n** Some of the assert() macros in this code are too expensive to run\n** even during normal debugging.  Use them only rarely on long-running\n** tests.  Enable the expensive asserts using the\n** -DSQLITE_ENABLE_EXPENSIVE_ASSERT=1 compile-time option.\n*/\n#ifdef SQLITE_ENABLE_EXPENSIVE_ASSERT\n# define expensive_assert(X)  assert(X)\n#else\n# define expensive_assert(X)\n#endif\n\n/********************************** Linked List Management ********************/\n\n#if !defined(NDEBUG) && defined(SQLITE_ENABLE_EXPENSIVE_ASSERT)\n/*\n** Check that the pCache->pSynced variable is set correctly. If it\n** is not, either fail an assert or return zero. Otherwise, return\n** non-zero. This is only used in debugging builds, as follows:\n**\n**   expensive_assert( pcacheCheckSynced(pCache) );\n*/\nstatic int pcacheCheckSynced(PCache *pCache){\n  PgHdr *p;\n  for(p=pCache->pDirtyTail; p!=pCache->pSynced; p=p->pDirtyPrev){\n    assert( p->nRef || (p->flags&PGHDR_NEED_SYNC) );\n  }\n  return (p==0 || p->nRef || (p->flags&PGHDR_NEED_SYNC)==0);\n}\n#endif /* !NDEBUG && SQLITE_ENABLE_EXPENSIVE_ASSERT */\n\n/*\n** Remove page pPage from the list of dirty pages.\n*/\nstatic void pcacheRemoveFromDirtyList(PgHdr *pPage){\n  PCache *p = pPage->pCache;\n\n  assert( pPage->pDirtyNext || pPage==p->pDirtyTail );\n  assert( pPage->pDirtyPrev || pPage==p->pDirty );\n\n  /* Update the PCache1.pSynced variable if necessary. */\n  if( p->pSynced==pPage ){\n    PgHdr *pSynced = pPage->pDirtyPrev;\n    while( pSynced && (pSynced->flags&PGHDR_NEED_SYNC) ){\n      pSynced = pSynced->pDirtyPrev;\n    }\n    p->pSynced = pSynced;\n  }\n\n  if( pPage->pDirtyNext ){\n    pPage->pDirtyNext->pDirtyPrev = pPage->pDirtyPrev;\n  }else{\n    assert( pPage==p->pDirtyTail );\n    p->pDirtyTail = pPage->pDirtyPrev;\n  }\n  if( pPage->pDirtyPrev ){\n    pPage->pDirtyPrev->pDirtyNext = pPage->pDirtyNext;\n  }else{\n    assert( pPage==p->pDirty );\n    p->pDirty = pPage->pDirtyNext;\n  }\n  pPage->pDirtyNext = 0;\n  pPage->pDirtyPrev = 0;\n\n  expensive_assert( pcacheCheckSynced(p) );\n}\n\n/*\n** Add page pPage to the head of the dirty list (PCache1.pDirty is set to\n** pPage).\n*/\nstatic void pcacheAddToDirtyList(PgHdr *pPage){\n  PCache *p = pPage->pCache;\n\n  assert( pPage->pDirtyNext==0 && pPage->pDirtyPrev==0 && p->pDirty!=pPage );\n\n  pPage->pDirtyNext = p->pDirty;\n  if( pPage->pDirtyNext ){\n    assert( pPage->pDirtyNext->pDirtyPrev==0 );\n    pPage->pDirtyNext->pDirtyPrev = pPage;\n  }\n  p->pDirty = pPage;\n  if( !p->pDirtyTail ){\n    p->pDirtyTail = pPage;\n  }\n  if( !p->pSynced && 0==(pPage->flags&PGHDR_NEED_SYNC) ){\n    p->pSynced = pPage;\n  }\n  expensive_assert( pcacheCheckSynced(p) );\n}\n\nstatic void unpinZeroCopy(PgHdr* p);\n\n/*\n** Wrapper around the pluggable caches xUnpin method. If the cache is\n** being used for an in-memory database, this function is a no-op.\n*/\nstatic void pcacheUnpin(PgHdr *p){\n  PCache *pCache = p->pCache;\n  if( pCache->bPurgeable ){\n    if( p->pgno==1 ){\n      pCache->pPage1 = 0;\n    }\n    if( p->flags & PGHDR_ZERO_COPY )\n      unpinZeroCopy(p);\n    sqlite3GlobalConfig.pcache.xUnpin(pCache->pCache, p, 0);\n  }\n}\n\n/*************************************************** General Interfaces ******\n**\n** Initialize and shutdown the page cache subsystem. Neither of these \n** functions are threadsafe.\n*/\nSQLITE_PRIVATE int sqlite3PcacheInitialize(void){\n  if( sqlite3GlobalConfig.pcache.xInit==0 ){\n    /* IMPLEMENTATION-OF: R-26801-64137 If the xInit() method is NULL, then the\n    ** built-in default page cache is used instead of the application defined\n    ** page cache. */\n    sqlite3PCacheSetDefault();\n  }\n  return sqlite3GlobalConfig.pcache.xInit(sqlite3GlobalConfig.pcache.pArg);\n}\nSQLITE_PRIVATE void sqlite3PcacheShutdown(void){\n  if( sqlite3GlobalConfig.pcache.xShutdown ){\n    /* IMPLEMENTATION-OF: R-26000-56589 The xShutdown() method may be NULL. */\n    sqlite3GlobalConfig.pcache.xShutdown(sqlite3GlobalConfig.pcache.pArg);\n  }\n}\n\n/*\n** Return the size in bytes of a PCache object.\n*/\nSQLITE_PRIVATE int sqlite3PcacheSize(void){ return sizeof(PCache); }\n\n/*\n** Create a new PCache object. Storage space to hold the object\n** has already been allocated and is passed in as the p pointer. \n** The caller discovers how much space needs to be allocated by \n** calling sqlite3PcacheSize().\n*/\nSQLITE_PRIVATE void sqlite3PcacheOpen(\n  int szPage,                  /* Size of every page */\n  int szExtra,                 /* Extra space associated with each page */\n  int bPurgeable,              /* True if pages are on backing store */\n  int (*xStress)(void*,PgHdr*),/* Call to try to make pages clean */\n  void *pStress,               /* Argument to xStress */\n  PCache *p                    /* Preallocated space for the PCache */\n){\n  memset(p, 0, sizeof(PCache));\n  p->szPage = szPage;\n  p->szExtra = szExtra;\n  p->bPurgeable = bPurgeable;\n  p->xStress = xStress;\n  p->pStress = pStress;\n  p->nMax = 100;\n}\n\n/*\n** Change the page size for PCache object. The caller must ensure that there\n** are no outstanding page references when this function is called.\n*/\nSQLITE_PRIVATE void sqlite3PcacheSetPageSize(PCache *pCache, int szPage){\n  assert( pCache->nRef==0 && pCache->pDirty==0 );\n  if( pCache->pCache ){\n    sqlite3GlobalConfig.pcache.xDestroy(pCache->pCache);\n    pCache->pCache = 0;\n    pCache->pPage1 = 0;\n  }\n  pCache->szPage = szPage;\n}\n\n/*\n** Try to obtain a page from the cache.\n*/\nSQLITE_PRIVATE int sqlite3PcacheFetch(\n  PCache *pCache,       /* Obtain the page from this cache */\n  Pgno pgno,            /* Page number to obtain */\n  int createFlag,       /* If true, create page if it does not exist already */\n  PgHdr **ppPage        /* Write the page here */\n){\n  PgHdr *pPage = 0;\n  int eCreate;\n\n  assert( pCache!=0 );\n  assert( createFlag==1 || createFlag==0 );\n  assert( pgno>0 );\n\n  /* If the pluggable cache (sqlite3_pcache*) has not been allocated,\n  ** allocate it now.\n  */\n  if( !pCache->pCache && createFlag ){\n    sqlite3_pcache *p;\n    int nByte;\n    nByte = pCache->szPage + pCache->szExtra + sizeof(PgHdr);\n    p = sqlite3GlobalConfig.pcache.xCreate(nByte, pCache->bPurgeable);\n    if( !p ){\n      return SQLITE_NOMEM;\n    }\n    sqlite3GlobalConfig.pcache.xCachesize(p, pCache->nMax);\n    pCache->pCache = p;\n  }\n\n  eCreate = createFlag * (1 + (!pCache->bPurgeable || !pCache->pDirty));\n  if( pCache->pCache ){\n    pPage = sqlite3GlobalConfig.pcache.xFetch(pCache->pCache, pgno, eCreate);\n  }\n\n  if( !pPage && eCreate==1 ){\n    PgHdr *pPg;\n\n    /* Find a dirty page to write-out and recycle. First try to find a \n    ** page that does not require a journal-sync (one with PGHDR_NEED_SYNC\n    ** cleared), but if that is not possible settle for any other \n    ** unreferenced dirty page.\n    */\n    expensive_assert( pcacheCheckSynced(pCache) );\n    for(pPg=pCache->pSynced; \n        pPg && (pPg->nRef || (pPg->flags&PGHDR_NEED_SYNC)); \n        pPg=pPg->pDirtyPrev\n    );\n    pCache->pSynced = pPg;\n    if( !pPg ){\n      for(pPg=pCache->pDirtyTail; pPg && pPg->nRef; pPg=pPg->pDirtyPrev);\n    }\n    if( pPg ){\n      int rc;\n      rc = pCache->xStress(pCache->pStress, pPg);\n      if( rc!=SQLITE_OK && rc!=SQLITE_BUSY ){\n        return rc;\n      }\n    }\n\n    pPage = sqlite3GlobalConfig.pcache.xFetch(pCache->pCache, pgno, 2);\n  }\n\n  if( pPage ){\n    if( !pPage->pData ){\n      memset(pPage, 0, sizeof(PgHdr));\n      pPage->pData = (void *)&pPage[1];\n      pPage->pExtra = (void*)&((char *)pPage->pData)[pCache->szPage];\n      memset(pPage->pExtra, 0, pCache->szExtra);\n      pPage->pCache = pCache;\n      pPage->pgno = pgno;\n    }\n    assert( pPage->pCache==pCache );\n    assert( pPage->pgno==pgno );\n    assert( pPage->pData==(void *)&pPage[1] || pPage->flags & PGHDR_ZERO_COPY );\n    assert( pPage->pExtra==(void *)&((char *)&pPage[1])[pCache->szPage] );\n\n    if( 0==pPage->nRef ){\n      pCache->nRef++;\n    }\n    pPage->nRef++;\n    if( pgno==1 ){\n      pCache->pPage1 = pPage;\n    }\n  }\n  *ppPage = pPage;\n  return (pPage==0 && eCreate) ? SQLITE_NOMEM : SQLITE_OK;\n}\n\n/*\n** Decrement the reference count on a page. If the page is clean and the\n** reference count drops to 0, then it is made elible for recycling.\n*/\nSQLITE_PRIVATE void sqlite3PcacheRelease(PgHdr *p){\n  assert( p->nRef>0 );\n  p->nRef--;\n  if( p->nRef==0 ){\n    PCache *pCache = p->pCache;\n    pCache->nRef--;\n    if( (p->flags&PGHDR_DIRTY)==0 ){\n      pcacheUnpin(p);\n    }else{\n      /* Move the page to the head of the dirty list. */\n      pcacheRemoveFromDirtyList(p);\n      pcacheAddToDirtyList(p);\n    }\n  }\n}\n\n/*\n** Increase the reference count of a supplied page by 1.\n*/\nSQLITE_PRIVATE void sqlite3PcacheRef(PgHdr *p){\n  assert(p->nRef>0);\n  p->nRef++;\n}\n\n/*\n** Drop a page from the cache. There must be exactly one reference to the\n** page. This function deletes that reference, so after it returns the\n** page pointed to by p is invalid.\n*/\nSQLITE_PRIVATE void sqlite3PcacheDrop(PgHdr *p){\n  PCache *pCache;\n  assert( p->nRef==1 );\n  if( p->flags&PGHDR_DIRTY ){\n    pcacheRemoveFromDirtyList(p);\n  }\n  pCache = p->pCache;\n  pCache->nRef--;\n  if( p->pgno==1 ){\n    pCache->pPage1 = 0;\n  }\n  if( p->flags & PGHDR_ZERO_COPY )\n    unpinZeroCopy(p);\n  sqlite3GlobalConfig.pcache.xUnpin(pCache->pCache, p, 1);\n}\n\n/*\n** Make sure the page is marked as dirty. If it isn't dirty already,\n** make it so.\n*/\nSQLITE_PRIVATE void sqlite3PcacheMakeDirty(PgHdr *p){\n  p->flags &= ~PGHDR_DONT_WRITE;\n  assert( p->nRef>0 );\n  if( 0==(p->flags & PGHDR_DIRTY) ){\n    p->flags |= PGHDR_DIRTY;\n    pcacheAddToDirtyList( p);\n  }\n}\n\n/*\n** Make sure the page is marked as clean. If it isn't clean already,\n** make it so.\n*/\nSQLITE_PRIVATE void sqlite3PcacheMakeClean(PgHdr *p){\n  if( (p->flags & PGHDR_DIRTY) ){\n    pcacheRemoveFromDirtyList(p);\n    p->flags &= ~(PGHDR_DIRTY|PGHDR_NEED_SYNC);\n    if( p->nRef==0 ){\n      pcacheUnpin(p);\n    }\n  }\n}\n\n/*\n** Make every page in the cache clean.\n*/\nSQLITE_PRIVATE void sqlite3PcacheCleanAll(PCache *pCache){\n  PgHdr *p;\n  while( (p = pCache->pDirty)!=0 ){\n    sqlite3PcacheMakeClean(p);\n  }\n}\n\n/*\n** Clear the PGHDR_NEED_SYNC flag from all dirty pages.\n*/\nSQLITE_PRIVATE void sqlite3PcacheClearSyncFlags(PCache *pCache){\n  PgHdr *p;\n  for(p=pCache->pDirty; p; p=p->pDirtyNext){\n    p->flags &= ~PGHDR_NEED_SYNC;\n  }\n  pCache->pSynced = pCache->pDirtyTail;\n}\n\n/*\n** Change the page number of page p to newPgno. \n*/\nSQLITE_PRIVATE void sqlite3PcacheMove(PgHdr *p, Pgno newPgno){\n  PCache *pCache = p->pCache;\n  assert( p->nRef>0 );\n  assert( newPgno>0 );\n  sqlite3GlobalConfig.pcache.xRekey(pCache->pCache, p, p->pgno, newPgno);\n  p->pgno = newPgno;\n  if( (p->flags&PGHDR_DIRTY) && (p->flags&PGHDR_NEED_SYNC) ){\n    pcacheRemoveFromDirtyList(p);\n    pcacheAddToDirtyList(p);\n  }\n}\n\n/*\n** Drop every cache entry whose page number is greater than \"pgno\". The\n** caller must ensure that there are no outstanding references to any pages\n** other than page 1 with a page number greater than pgno.\n**\n** If there is a reference to page 1 and the pgno parameter passed to this\n** function is 0, then the data area associated with page 1 is zeroed, but\n** the page object is not dropped.\n*/\nSQLITE_PRIVATE void sqlite3PcacheTruncate(PCache *pCache, Pgno pgno){\n  if( pCache->pCache ){\n    PgHdr *p;\n    PgHdr *pNext;\n    for(p=pCache->pDirty; p; p=pNext){\n      pNext = p->pDirtyNext;\n      /* This routine never gets call with a positive pgno except right\n      ** after sqlite3PcacheCleanAll().  So if there are dirty pages,\n      ** it must be that pgno==0.\n      */\n      assert( p->pgno>0 );\n      if( ALWAYS(p->pgno>pgno) ){\n        assert( p->flags&PGHDR_DIRTY );\n        sqlite3PcacheMakeClean(p);\n      }\n    }\n    if( pgno==0 && pCache->pPage1 ){\n      memset(pCache->pPage1->pData, 0, pCache->szPage);\n      pgno = 1;\n    }\n    sqlite3GlobalConfig.pcache.xTruncate(pCache->pCache, pgno+1);\n  }\n}\n\n/*\n** Close a cache.\n*/\nSQLITE_PRIVATE void sqlite3PcacheClose(PCache *pCache){\n  if( pCache->pCache ){\n    sqlite3GlobalConfig.pcache.xDestroy(pCache->pCache);\n  }\n}\n\n/* \n** Discard the contents of the cache.\n*/\nSQLITE_PRIVATE void sqlite3PcacheClear(PCache *pCache){\n  sqlite3PcacheTruncate(pCache, 0);\n}\n\n/*\n** Merge two lists of pages connected by pDirty and in pgno order.\n** Do not both fixing the pDirtyPrev pointers.\n*/\nstatic PgHdr *pcacheMergeDirtyList(PgHdr *pA, PgHdr *pB){\n  PgHdr result, *pTail;\n  pTail = &result;\n  while( pA && pB ){\n    if( pA->pgno<pB->pgno ){\n      pTail->pDirty = pA;\n      pTail = pA;\n      pA = pA->pDirty;\n    }else{\n      pTail->pDirty = pB;\n      pTail = pB;\n      pB = pB->pDirty;\n    }\n  }\n  if( pA ){\n    pTail->pDirty = pA;\n  }else if( pB ){\n    pTail->pDirty = pB;\n  }else{\n    pTail->pDirty = 0;\n  }\n  return result.pDirty;\n}\n\n/*\n** Sort the list of pages in accending order by pgno.  Pages are\n** connected by pDirty pointers.  The pDirtyPrev pointers are\n** corrupted by this sort.\n**\n** Since there cannot be more than 2^31 distinct pages in a database,\n** there cannot be more than 31 buckets required by the merge sorter.\n** One extra bucket is added to catch overflow in case something\n** ever changes to make the previous sentence incorrect.\n*/\n#define N_SORT_BUCKET  32\nstatic PgHdr *pcacheSortDirtyList(PgHdr *pIn){\n  PgHdr *a[N_SORT_BUCKET], *p;\n  int i;\n  memset(a, 0, sizeof(a));\n  while( pIn ){\n    p = pIn;\n    pIn = p->pDirty;\n    p->pDirty = 0;\n    for(i=0; ALWAYS(i<N_SORT_BUCKET-1); i++){\n      if( a[i]==0 ){\n        a[i] = p;\n        break;\n      }else{\n        p = pcacheMergeDirtyList(a[i], p);\n        a[i] = 0;\n      }\n    }\n    if( NEVER(i==N_SORT_BUCKET-1) ){\n      /* To get here, there need to be 2^(N_SORT_BUCKET) elements in\n      ** the input list.  But that is impossible.\n      */\n      a[i] = pcacheMergeDirtyList(a[i], p);\n    }\n  }\n  p = a[0];\n  for(i=1; i<N_SORT_BUCKET; i++){\n    p = pcacheMergeDirtyList(p, a[i]);\n  }\n  return p;\n}\n\n/*\n** Return a list of all dirty pages in the cache, sorted by page number.\n*/\nSQLITE_PRIVATE PgHdr *sqlite3PcacheDirtyList(PCache *pCache){\n  PgHdr *p;\n  for(p=pCache->pDirty; p; p=p->pDirtyNext){\n    p->pDirty = p->pDirtyNext;\n  }\n  return pcacheSortDirtyList(pCache->pDirty);\n}\n\n/* \n** Return the total number of referenced pages held by the cache.\n*/\nSQLITE_PRIVATE int sqlite3PcacheRefCount(PCache *pCache){\n  return pCache->nRef;\n}\n\n/*\n** Return the number of references to the page supplied as an argument.\n*/\nSQLITE_PRIVATE int sqlite3PcachePageRefcount(PgHdr *p){\n  return p->nRef;\n}\n\n/* \n** Return the total number of pages in the cache.\n*/\nSQLITE_PRIVATE int sqlite3PcachePagecount(PCache *pCache){\n  int nPage = 0;\n  if( pCache->pCache ){\n    nPage = sqlite3GlobalConfig.pcache.xPagecount(pCache->pCache);\n  }\n  return nPage;\n}\n\n#ifdef SQLITE_TEST\n/*\n** Get the suggested cache-size value.\n*/\nSQLITE_PRIVATE int sqlite3PcacheGetCachesize(PCache *pCache){\n  return pCache->nMax;\n}\n#endif\n\n/*\n** Set the suggested cache-size value.\n*/\nSQLITE_PRIVATE void sqlite3PcacheSetCachesize(PCache *pCache, int mxPage){\n  pCache->nMax = mxPage;\n  if( pCache->pCache ){\n    sqlite3GlobalConfig.pcache.xCachesize(pCache->pCache, mxPage);\n  }\n}\n\n#if defined(SQLITE_CHECK_PAGES) || defined(SQLITE_DEBUG)\n/*\n** For all dirty pages currently in the cache, invoke the specified\n** callback. This is only used if the SQLITE_CHECK_PAGES macro is\n** defined.\n*/\nSQLITE_PRIVATE void sqlite3PcacheIterateDirty(PCache *pCache, void (*xIter)(PgHdr *)){\n  PgHdr *pDirty;\n  for(pDirty=pCache->pDirty; pDirty; pDirty=pDirty->pDirtyNext){\n    xIter(pDirty);\n  }\n}\n#endif\n\n/************** End of pcache.c **********************************************/\n/************** Begin file pcache1.c *****************************************/\n/*\n** 2008 November 05\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n**\n** This file implements the default page cache implementation (the\n** sqlite3_pcache interface). It also contains part of the implementation\n** of the SQLITE_CONFIG_PAGECACHE and sqlite3_release_memory() features.\n** If the default page cache implementation is overriden, then neither of\n** these two features are available.\n*/\n\n\ntypedef struct PCache1 PCache1;\ntypedef struct PgHdr1 PgHdr1;\ntypedef struct PgFreeslot PgFreeslot;\ntypedef struct PGroup PGroup;\n\n/* Each page cache (or PCache) belongs to a PGroup.  A PGroup is a set \n** of one or more PCaches that are able to recycle each others unpinned\n** pages when they are under memory pressure.  A PGroup is an instance of\n** the following object.\n**\n** This page cache implementation works in one of two modes:\n**\n**   (1)  Every PCache is the sole member of its own PGroup.  There is\n**        one PGroup per PCache.\n**\n**   (2)  There is a single global PGroup that all PCaches are a member\n**        of.\n**\n** Mode 1 uses more memory (since PCache instances are not able to rob\n** unused pages from other PCaches) but it also operates without a mutex,\n** and is therefore often faster.  Mode 2 requires a mutex in order to be\n** threadsafe, but is able recycle pages more efficient.\n**\n** For mode (1), PGroup.mutex is NULL.  For mode (2) there is only a single\n** PGroup which is the pcache1.grp global variable and its mutex is\n** SQLITE_MUTEX_STATIC_LRU.\n*/\nstruct PGroup {\n  sqlite3_mutex *mutex;          /* MUTEX_STATIC_LRU or NULL */\n  int nMaxPage;                  /* Sum of nMax for purgeable caches */\n  int nMinPage;                  /* Sum of nMin for purgeable caches */\n  int mxPinned;                  /* nMaxpage + 10 - nMinPage */\n  int nCurrentPage;              /* Number of purgeable pages allocated */\n  PgHdr1 *pLruHead, *pLruTail;   /* LRU list of unpinned pages */\n};\n\n/* Each page cache is an instance of the following object.  Every\n** open database file (including each in-memory database and each\n** temporary or transient database) has a single page cache which\n** is an instance of this object.\n**\n** Pointers to structures of this type are cast and returned as \n** opaque sqlite3_pcache* handles.\n*/\nstruct PCache1 {\n  /* Cache configuration parameters. Page size (szPage) and the purgeable\n  ** flag (bPurgeable) are set when the cache is created. nMax may be \n  ** modified at any time by a call to the pcache1CacheSize() method.\n  ** The PGroup mutex must be held when accessing nMax.\n  */\n  PGroup *pGroup;                     /* PGroup this cache belongs to */\n  int szPage;                         /* Size of allocated pages in bytes */\n  int bPurgeable;                     /* True if cache is purgeable */\n  unsigned int nMin;                  /* Minimum number of pages reserved */\n  unsigned int nMax;                  /* Configured \"cache_size\" value */\n  unsigned int n90pct;                /* nMax*9/10 */\n\n  /* Hash table of all pages. The following variables may only be accessed\n  ** when the accessor is holding the PGroup mutex.\n  */\n  unsigned int nRecyclable;           /* Number of pages in the LRU list */\n  unsigned int nPage;                 /* Total number of pages in apHash */\n  unsigned int nHash;                 /* Number of slots in apHash[] */\n  PgHdr1 **apHash;                    /* Hash table for fast lookup by key */\n\n  unsigned int iMaxKey;               /* Largest key seen since xTruncate() */\n};\n\n/*\n** Each cache entry is represented by an instance of the following \n** structure. A buffer of PgHdr1.pCache->szPage bytes is allocated \n** directly before this structure in memory (see the PGHDR1_TO_PAGE() \n** macro below).\n*/\nstruct PgHdr1 {\n  unsigned int iKey;             /* Key value (page number) */\n  PgHdr1 *pNext;                 /* Next in hash table chain */\n  PCache1 *pCache;               /* Cache that currently owns this page */\n  PgHdr1 *pLruNext;              /* Next in LRU list of unpinned pages */\n  PgHdr1 *pLruPrev;              /* Previous in LRU list of unpinned pages */\n};\n\n/*\n** Free slots in the allocator used to divide up the buffer provided using\n** the SQLITE_CONFIG_PAGECACHE mechanism.\n*/\nstruct PgFreeslot {\n  PgFreeslot *pNext;  /* Next free slot */\n};\n\n/*\n** Global data used by this cache.\n*/\nstatic SQLITE_WSD struct PCacheGlobal {\n  PGroup grp;                    /* The global PGroup for mode (2) */\n\n  /* Variables related to SQLITE_CONFIG_PAGECACHE settings.  The\n  ** szSlot, nSlot, pStart, pEnd, nReserve, and isInit values are all\n  ** fixed at sqlite3_initialize() time and do not require mutex protection.\n  ** The nFreeSlot and pFree values do require mutex protection.\n  */\n  int isInit;                    /* True if initialized */\n  int szSlot;                    /* Size of each free slot */\n  int nSlot;                     /* The number of pcache slots */\n  int nReserve;                  /* Try to keep nFreeSlot above this */\n  void *pStart, *pEnd;           /* Bounds of pagecache malloc range */\n  /* Above requires no mutex.  Use mutex below for variable that follow. */\n  sqlite3_mutex *mutex;          /* Mutex for accessing the following: */\n  int nFreeSlot;                 /* Number of unused pcache slots */\n  PgFreeslot *pFree;             /* Free page blocks */\n  /* The following value requires a mutex to change.  We skip the mutex on\n  ** reading because (1) most platforms read a 32-bit integer atomically and\n  ** (2) even if an incorrect value is read, no great harm is done since this\n  ** is really just an optimization. */\n  int bUnderPressure;            /* True if low on PAGECACHE memory */\n} pcache1_g;\n\n/*\n** All code in this file should access the global structure above via the\n** alias \"pcache1\". This ensures that the WSD emulation is used when\n** compiling for systems that do not support real WSD.\n*/\n#define pcache1 (GLOBAL(struct PCacheGlobal, pcache1_g))\n\n/*\n** When a PgHdr1 structure is allocated, the associated PCache1.szPage\n** bytes of data are located directly before it in memory (i.e. the total\n** size of the allocation is sizeof(PgHdr1)+PCache1.szPage byte). The\n** PGHDR1_TO_PAGE() macro takes a pointer to a PgHdr1 structure as\n** an argument and returns a pointer to the associated block of szPage\n** bytes. The PAGE_TO_PGHDR1() macro does the opposite: its argument is\n** a pointer to a block of szPage bytes of data and the return value is\n** a pointer to the associated PgHdr1 structure.\n**\n**   assert( PGHDR1_TO_PAGE(PAGE_TO_PGHDR1(pCache, X))==X );\n*/\n#define PGHDR1_TO_PAGE(p)    (void*)(((char*)p) - p->pCache->szPage)\n#define PAGE_TO_PGHDR1(c, p) (PgHdr1*)(((char*)p) + c->szPage)\n\n/*\n** Macros to enter and leave the PCache LRU mutex.\n*/\n#define pcache1EnterMutex(X) sqlite3_mutex_enter((X)->mutex)\n#define pcache1LeaveMutex(X) sqlite3_mutex_leave((X)->mutex)\n\n/******************************************************************************/\n/******** Page Allocation/SQLITE_CONFIG_PCACHE Related Functions **************/\n\n/*\n** This function is called during initialization if a static buffer is \n** supplied to use for the page-cache by passing the SQLITE_CONFIG_PAGECACHE\n** verb to sqlite3_config(). Parameter pBuf points to an allocation large\n** enough to contain 'n' buffers of 'sz' bytes each.\n**\n** This routine is called from sqlite3_initialize() and so it is guaranteed\n** to be serialized already.  There is no need for further mutexing.\n*/\nSQLITE_PRIVATE void sqlite3PCacheBufferSetup(void *pBuf, int sz, int n){\n  if( pcache1.isInit ){\n    PgFreeslot *p;\n    sz = ROUNDDOWN8(sz);\n    pcache1.szSlot = sz;\n    pcache1.nSlot = pcache1.nFreeSlot = n;\n    pcache1.nReserve = n>90 ? 10 : (n/10 + 1);\n    pcache1.pStart = pBuf;\n    pcache1.pFree = 0;\n    pcache1.bUnderPressure = 0;\n    while( n-- ){\n      p = (PgFreeslot*)pBuf;\n      p->pNext = pcache1.pFree;\n      pcache1.pFree = p;\n      pBuf = (void*)&((char*)pBuf)[sz];\n    }\n    pcache1.pEnd = pBuf;\n  }\n}\n\n/*\n** Malloc function used within this file to allocate space from the buffer\n** configured using sqlite3_config(SQLITE_CONFIG_PAGECACHE) option. If no \n** such buffer exists or there is no space left in it, this function falls \n** back to sqlite3Malloc().\n**\n** Multiple threads can run this routine at the same time.  Global variables\n** in pcache1 need to be protected via mutex.\n*/\nstatic void *pcache1Alloc(int nByte){\n  void *p = 0;\n  assert( sqlite3_mutex_notheld(pcache1.grp.mutex) );\n  sqlite3StatusSet(SQLITE_STATUS_PAGECACHE_SIZE, nByte);\n  if( nByte<=pcache1.szSlot ){\n    sqlite3_mutex_enter(pcache1.mutex);\n    p = (PgHdr1 *)pcache1.pFree;\n    if( p ){\n      pcache1.pFree = pcache1.pFree->pNext;\n      pcache1.nFreeSlot--;\n      pcache1.bUnderPressure = pcache1.nFreeSlot<pcache1.nReserve;\n      assert( pcache1.nFreeSlot>=0 );\n      sqlite3StatusAdd(SQLITE_STATUS_PAGECACHE_USED, 1);\n    }\n    sqlite3_mutex_leave(pcache1.mutex);\n  }\n  if( p==0 ){\n    /* Memory is not available in the SQLITE_CONFIG_PAGECACHE pool.  Get\n    ** it from sqlite3Malloc instead.\n    */\n    p = sqlite3Malloc(nByte);\n    if( p ){\n      int sz = sqlite3MallocSize(p);\n      sqlite3_mutex_enter(pcache1.mutex);\n      sqlite3StatusAdd(SQLITE_STATUS_PAGECACHE_OVERFLOW, sz);\n      sqlite3_mutex_leave(pcache1.mutex);\n    }\n    sqlite3MemdebugSetType(p, MEMTYPE_PCACHE);\n  }\n  return p;\n}\n\n/*\n** Free an allocated buffer obtained from pcache1Alloc().\n*/\nstatic void pcache1Free(void *p){\n  if( p==0 ) return;\n  if( p>=pcache1.pStart && p<pcache1.pEnd ){\n    PgFreeslot *pSlot;\n    sqlite3_mutex_enter(pcache1.mutex);\n    sqlite3StatusAdd(SQLITE_STATUS_PAGECACHE_USED, -1);\n    pSlot = (PgFreeslot*)p;\n    pSlot->pNext = pcache1.pFree;\n    pcache1.pFree = pSlot;\n    pcache1.nFreeSlot++;\n    pcache1.bUnderPressure = pcache1.nFreeSlot<pcache1.nReserve;\n    assert( pcache1.nFreeSlot<=pcache1.nSlot );\n    sqlite3_mutex_leave(pcache1.mutex);\n  }else{\n    int iSize;\n    assert( sqlite3MemdebugHasType(p, MEMTYPE_PCACHE) );\n    sqlite3MemdebugSetType(p, MEMTYPE_HEAP);\n    iSize = sqlite3MallocSize(p);\n    sqlite3_mutex_enter(pcache1.mutex);\n    sqlite3StatusAdd(SQLITE_STATUS_PAGECACHE_OVERFLOW, -iSize);\n    sqlite3_mutex_leave(pcache1.mutex);\n    sqlite3_free(p);\n  }\n}\n\n#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT\n/*\n** Return the size of a pcache allocation\n*/\nstatic int pcache1MemSize(void *p){\n  if( p>=pcache1.pStart && p<pcache1.pEnd ){\n    return pcache1.szSlot;\n  }else{\n    int iSize;\n    assert( sqlite3MemdebugHasType(p, MEMTYPE_PCACHE) );\n    sqlite3MemdebugSetType(p, MEMTYPE_HEAP);\n    iSize = sqlite3MallocSize(p);\n    sqlite3MemdebugSetType(p, MEMTYPE_PCACHE);\n    return iSize;\n  }\n}\n#endif /* SQLITE_ENABLE_MEMORY_MANAGEMENT */\n\n/*\n** Allocate a new page object initially associated with cache pCache.\n*/\nstatic PgHdr1 *pcache1AllocPage(PCache1 *pCache){\n  int nByte = sizeof(PgHdr1) + pCache->szPage;\n  void *pPg = pcache1Alloc(nByte);\n  PgHdr1 *p;\n  if( pPg ){\n    p = PAGE_TO_PGHDR1(pCache, pPg);\n    if( pCache->bPurgeable ){\n      pCache->pGroup->nCurrentPage++;\n    }\n  }else{\n    p = 0;\n  }\n  return p;\n}\n\n/*\n** Free a page object allocated by pcache1AllocPage().\n**\n** The pointer is allowed to be NULL, which is prudent.  But it turns out\n** that the current implementation happens to never call this routine\n** with a NULL pointer, so we mark the NULL test with ALWAYS().\n*/\nstatic void pcache1FreePage(PgHdr1 *p){\n  if( ALWAYS(p) ){\n    PCache1 *pCache = p->pCache;\n    if( pCache->bPurgeable ){\n      pCache->pGroup->nCurrentPage--;\n    }\n    pcache1Free(PGHDR1_TO_PAGE(p));\n  }\n}\n\n/*\n** Malloc function used by SQLite to obtain space from the buffer configured\n** using sqlite3_config(SQLITE_CONFIG_PAGECACHE) option. If no such buffer\n** exists, this function falls back to sqlite3Malloc().\n*/\nSQLITE_PRIVATE void *sqlite3PageMalloc(int sz){\n  return pcache1Alloc(sz);\n}\n\n/*\n** Free an allocated buffer obtained from sqlite3PageMalloc().\n*/\nSQLITE_PRIVATE void sqlite3PageFree(void *p){\n  pcache1Free(p);\n}\n\n\n/*\n** Return true if it desirable to avoid allocating a new page cache\n** entry.\n**\n** If memory was allocated specifically to the page cache using\n** SQLITE_CONFIG_PAGECACHE but that memory has all been used, then\n** it is desirable to avoid allocating a new page cache entry because\n** presumably SQLITE_CONFIG_PAGECACHE was suppose to be sufficient\n** for all page cache needs and we should not need to spill the\n** allocation onto the heap.\n**\n** Or, the heap is used for all page cache memory put the heap is\n** under memory pressure, then again it is desirable to avoid\n** allocating a new page cache entry in order to avoid stressing\n** the heap even further.\n*/\nstatic int pcache1UnderMemoryPressure(PCache1 *pCache){\n  if( pcache1.nSlot && pCache->szPage<=pcache1.szSlot ){\n    return pcache1.bUnderPressure;\n  }else{\n    return sqlite3HeapNearlyFull();\n  }\n}\n\n/******************************************************************************/\n/******** General Implementation Functions ************************************/\n\n/*\n** This function is used to resize the hash table used by the cache passed\n** as the first argument.\n**\n** The PCache mutex must be held when this function is called.\n*/\nstatic int pcache1ResizeHash(PCache1 *p){\n  PgHdr1 **apNew;\n  unsigned int nNew;\n  unsigned int i;\n\n  assert( sqlite3_mutex_held(p->pGroup->mutex) );\n\n  nNew = p->nHash*2;\n  if( nNew<256 ){\n    nNew = 256;\n  }\n\n  pcache1LeaveMutex(p->pGroup);\n  if( p->nHash ){ sqlite3BeginBenignMalloc(); }\n  apNew = (PgHdr1 **)sqlite3_malloc(sizeof(PgHdr1 *)*nNew);\n  if( p->nHash ){ sqlite3EndBenignMalloc(); }\n  pcache1EnterMutex(p->pGroup);\n  if( apNew ){\n    memset(apNew, 0, sizeof(PgHdr1 *)*nNew);\n    for(i=0; i<p->nHash; i++){\n      PgHdr1 *pPage;\n      PgHdr1 *pNext = p->apHash[i];\n      while( (pPage = pNext)!=0 ){\n        unsigned int h = pPage->iKey % nNew;\n        pNext = pPage->pNext;\n        pPage->pNext = apNew[h];\n        apNew[h] = pPage;\n      }\n    }\n    sqlite3_free(p->apHash);\n    p->apHash = apNew;\n    p->nHash = nNew;\n  }\n\n  return (p->apHash ? SQLITE_OK : SQLITE_NOMEM);\n}\n\n/*\n** This function is used internally to remove the page pPage from the \n** PGroup LRU list, if is part of it. If pPage is not part of the PGroup\n** LRU list, then this function is a no-op.\n**\n** The PGroup mutex must be held when this function is called.\n**\n** If pPage is NULL then this routine is a no-op.\n*/\nstatic void pcache1PinPage(PgHdr1 *pPage){\n  PCache1 *pCache;\n  PGroup *pGroup;\n\n  if( pPage==0 ) return;\n  pCache = pPage->pCache;\n  pGroup = pCache->pGroup;\n  assert( sqlite3_mutex_held(pGroup->mutex) );\n  if( pPage->pLruNext || pPage==pGroup->pLruTail ){\n    if( pPage->pLruPrev ){\n      pPage->pLruPrev->pLruNext = pPage->pLruNext;\n    }\n    if( pPage->pLruNext ){\n      pPage->pLruNext->pLruPrev = pPage->pLruPrev;\n    }\n    if( pGroup->pLruHead==pPage ){\n      pGroup->pLruHead = pPage->pLruNext;\n    }\n    if( pGroup->pLruTail==pPage ){\n      pGroup->pLruTail = pPage->pLruPrev;\n    }\n    pPage->pLruNext = 0;\n    pPage->pLruPrev = 0;\n    pPage->pCache->nRecyclable--;\n  }\n}\n\n\n/*\n** Remove the page supplied as an argument from the hash table \n** (PCache1.apHash structure) that it is currently stored in.\n**\n** The PGroup mutex must be held when this function is called.\n*/\nstatic void pcache1RemoveFromHash(PgHdr1 *pPage){\n  unsigned int h;\n  PCache1 *pCache = pPage->pCache;\n  PgHdr1 **pp;\n\n  assert( sqlite3_mutex_held(pCache->pGroup->mutex) );\n  h = pPage->iKey % pCache->nHash;\n  for(pp=&pCache->apHash[h]; (*pp)!=pPage; pp=&(*pp)->pNext);\n  *pp = (*pp)->pNext;\n\n  pCache->nPage--;\n}\n\n/*\n** If there are currently more than nMaxPage pages allocated, try\n** to recycle pages to reduce the number allocated to nMaxPage.\n*/\nstatic void pcache1EnforceMaxPage(PGroup *pGroup){\n  assert( sqlite3_mutex_held(pGroup->mutex) );\n  while( pGroup->nCurrentPage>pGroup->nMaxPage && pGroup->pLruTail ){\n    PgHdr1 *p = pGroup->pLruTail;\n    assert( p->pCache->pGroup==pGroup );\n    pcache1PinPage(p);\n    pcache1RemoveFromHash(p);\n    pcache1FreePage(p);\n  }\n}\n\n/*\n** Discard all pages from cache pCache with a page number (key value) \n** greater than or equal to iLimit. Any pinned pages that meet this \n** criteria are unpinned before they are discarded.\n**\n** The PCache mutex must be held when this function is called.\n*/\nstatic void pcache1TruncateUnsafe(\n  PCache1 *pCache,             /* The cache to truncate */\n  unsigned int iLimit          /* Drop pages with this pgno or larger */\n){\n  TESTONLY( unsigned int nPage = 0; )  /* To assert pCache->nPage is correct */\n  unsigned int h;\n  assert( sqlite3_mutex_held(pCache->pGroup->mutex) );\n  for(h=0; h<pCache->nHash; h++){\n    PgHdr1 **pp = &pCache->apHash[h]; \n    PgHdr1 *pPage;\n    while( (pPage = *pp)!=0 ){\n      if( pPage->iKey>=iLimit ){\n        pCache->nPage--;\n        *pp = pPage->pNext;\n        pcache1PinPage(pPage);\n        pcache1FreePage(pPage);\n      }else{\n        pp = &pPage->pNext;\n        TESTONLY( nPage++; )\n      }\n    }\n  }\n  assert( pCache->nPage==nPage );\n}\n\n/******************************************************************************/\n/******** sqlite3_pcache Methods **********************************************/\n\n/*\n** Implementation of the sqlite3_pcache.xInit method.\n*/\nstatic int pcache1Init(void *NotUsed){\n  UNUSED_PARAMETER(NotUsed);\n  assert( pcache1.isInit==0 );\n  memset(&pcache1, 0, sizeof(pcache1));\n  if( sqlite3GlobalConfig.bCoreMutex ){\n    pcache1.grp.mutex = sqlite3_mutex_alloc(SQLITE_MUTEX_STATIC_LRU);\n    pcache1.mutex = sqlite3_mutex_alloc(SQLITE_MUTEX_STATIC_PMEM);\n  }\n  pcache1.grp.mxPinned = 10;\n  pcache1.isInit = 1;\n  return SQLITE_OK;\n}\n\n/*\n** Implementation of the sqlite3_pcache.xShutdown method.\n** Note that the static mutex allocated in xInit does \n** not need to be freed.\n*/\nstatic void pcache1Shutdown(void *NotUsed){\n  UNUSED_PARAMETER(NotUsed);\n  assert( pcache1.isInit!=0 );\n  memset(&pcache1, 0, sizeof(pcache1));\n}\n\n/*\n** Implementation of the sqlite3_pcache.xCreate method.\n**\n** Allocate a new cache.\n*/\nstatic sqlite3_pcache *pcache1Create(int szPage, int bPurgeable){\n  PCache1 *pCache;      /* The newly created page cache */\n  PGroup *pGroup;       /* The group the new page cache will belong to */\n  int sz;               /* Bytes of memory required to allocate the new cache */\n\n  /*\n  ** The seperateCache variable is true if each PCache has its own private\n  ** PGroup.  In other words, separateCache is true for mode (1) where no\n  ** mutexing is required.\n  **\n  **   *  Always use a unified cache (mode-2) if ENABLE_MEMORY_MANAGEMENT\n  **\n  **   *  Always use a unified cache in single-threaded applications\n  **\n  **   *  Otherwise (if multi-threaded and ENABLE_MEMORY_MANAGEMENT is off)\n  **      use separate caches (mode-1)\n  */\n#if defined(SQLITE_ENABLE_MEMORY_MANAGEMENT) || SQLITE_THREADSAFE==0\n  const int separateCache = 0;\n#else\n  int separateCache = sqlite3GlobalConfig.bCoreMutex>0;\n#endif\n\n  sz = sizeof(PCache1) + sizeof(PGroup)*separateCache;\n  pCache = (PCache1 *)sqlite3_malloc(sz);\n  if( pCache ){\n    memset(pCache, 0, sz);\n    if( separateCache ){\n      pGroup = (PGroup*)&pCache[1];\n      pGroup->mxPinned = 10;\n    }else{\n      pGroup = &pcache1_g.grp;\n    }\n    pCache->pGroup = pGroup;\n    pCache->szPage = szPage;\n    pCache->bPurgeable = (bPurgeable ? 1 : 0);\n    if( bPurgeable ){\n      pCache->nMin = 10;\n      pcache1EnterMutex(pGroup);\n      pGroup->nMinPage += pCache->nMin;\n      pGroup->mxPinned = pGroup->nMaxPage + 10 - pGroup->nMinPage;\n      pcache1LeaveMutex(pGroup);\n    }\n  }\n  return (sqlite3_pcache *)pCache;\n}\n\n/*\n** Implementation of the sqlite3_pcache.xCachesize method. \n**\n** Configure the cache_size limit for a cache.\n*/\nstatic void pcache1Cachesize(sqlite3_pcache *p, int nMax){\n  PCache1 *pCache = (PCache1 *)p;\n  if( pCache->bPurgeable ){\n    PGroup *pGroup = pCache->pGroup;\n    pcache1EnterMutex(pGroup);\n    pGroup->nMaxPage += (nMax - pCache->nMax);\n    pGroup->mxPinned = pGroup->nMaxPage + 10 - pGroup->nMinPage;\n    pCache->nMax = nMax;\n    pCache->n90pct = pCache->nMax*9/10;\n    pcache1EnforceMaxPage(pGroup);\n    pcache1LeaveMutex(pGroup);\n  }\n}\n\n/*\n** Implementation of the sqlite3_pcache.xPagecount method. \n*/\nstatic int pcache1Pagecount(sqlite3_pcache *p){\n  int n;\n  PCache1 *pCache = (PCache1*)p;\n  pcache1EnterMutex(pCache->pGroup);\n  n = pCache->nPage;\n  pcache1LeaveMutex(pCache->pGroup);\n  return n;\n}\n\n/*\n** Implementation of the sqlite3_pcache.xFetch method. \n**\n** Fetch a page by key value.\n**\n** Whether or not a new page may be allocated by this function depends on\n** the value of the createFlag argument.  0 means do not allocate a new\n** page.  1 means allocate a new page if space is easily available.  2 \n** means to try really hard to allocate a new page.\n**\n** For a non-purgeable cache (a cache used as the storage for an in-memory\n** database) there is really no difference between createFlag 1 and 2.  So\n** the calling function (pcache.c) will never have a createFlag of 1 on\n** a non-purgable cache.\n**\n** There are three different approaches to obtaining space for a page,\n** depending on the value of parameter createFlag (which may be 0, 1 or 2).\n**\n**   1. Regardless of the value of createFlag, the cache is searched for a \n**      copy of the requested page. If one is found, it is returned.\n**\n**   2. If createFlag==0 and the page is not already in the cache, NULL is\n**      returned.\n**\n**   3. If createFlag is 1, and the page is not already in the cache, then\n**      return NULL (do not allocate a new page) if any of the following\n**      conditions are true:\n**\n**       (a) the number of pages pinned by the cache is greater than\n**           PCache1.nMax, or\n**\n**       (b) the number of pages pinned by the cache is greater than\n**           the sum of nMax for all purgeable caches, less the sum of \n**           nMin for all other purgeable caches, or\n**\n**   4. If none of the first three conditions apply and the cache is marked\n**      as purgeable, and if one of the following is true:\n**\n**       (a) The number of pages allocated for the cache is already \n**           PCache1.nMax, or\n**\n**       (b) The number of pages allocated for all purgeable caches is\n**           already equal to or greater than the sum of nMax for all\n**           purgeable caches,\n**\n**       (c) The system is under memory pressure and wants to avoid\n**           unnecessary pages cache entry allocations\n**\n**      then attempt to recycle a page from the LRU list. If it is the right\n**      size, return the recycled buffer. Otherwise, free the buffer and\n**      proceed to step 5. \n**\n**   5. Otherwise, allocate and return a new page buffer.\n*/\nstatic void *pcache1Fetch(sqlite3_pcache *p, unsigned int iKey, int createFlag){\n  int nPinned;\n  PCache1 *pCache = (PCache1 *)p;\n  PGroup *pGroup;\n  PgHdr1 *pPage = 0;\n\n  assert( pCache->bPurgeable || createFlag!=1 );\n  assert( pCache->bPurgeable || pCache->nMin==0 );\n  assert( pCache->bPurgeable==0 || pCache->nMin==10 );\n  assert( pCache->nMin==0 || pCache->bPurgeable );\n  pcache1EnterMutex(pGroup = pCache->pGroup);\n\n  /* Step 1: Search the hash table for an existing entry. */\n  if( pCache->nHash>0 ){\n    unsigned int h = iKey % pCache->nHash;\n    for(pPage=pCache->apHash[h]; pPage&&pPage->iKey!=iKey; pPage=pPage->pNext);\n  }\n\n  /* Step 2: Abort if no existing page is found and createFlag is 0 */\n  if( pPage || createFlag==0 ){\n    pcache1PinPage(pPage);\n    goto fetch_out;\n  }\n\n  /* The pGroup local variable will normally be initialized by the\n  ** pcache1EnterMutex() macro above.  But if SQLITE_MUTEX_OMIT is defined,\n  ** then pcache1EnterMutex() is a no-op, so we have to initialize the\n  ** local variable here.  Delaying the initialization of pGroup is an\n  ** optimization:  The common case is to exit the module before reaching\n  ** this point.\n  */\n#ifdef SQLITE_MUTEX_OMIT\n  pGroup = pCache->pGroup;\n#endif\n\n\n  /* Step 3: Abort if createFlag is 1 but the cache is nearly full */\n  nPinned = pCache->nPage - pCache->nRecyclable;\n  assert( nPinned>=0 );\n  assert( pGroup->mxPinned == pGroup->nMaxPage + 10 - pGroup->nMinPage );\n  assert( pCache->n90pct == pCache->nMax*9/10 );\n  if( createFlag==1 && (\n        nPinned>=pGroup->mxPinned\n     || nPinned>=(int)pCache->n90pct\n     || pcache1UnderMemoryPressure(pCache)\n  )){\n    goto fetch_out;\n  }\n\n  if( pCache->nPage>=pCache->nHash && pcache1ResizeHash(pCache) ){\n    goto fetch_out;\n  }\n\n  /* Step 4. Try to recycle a page. */\n  if( pCache->bPurgeable && pGroup->pLruTail && (\n         (pCache->nPage+1>=pCache->nMax)\n      || pGroup->nCurrentPage>=pGroup->nMaxPage\n      || pcache1UnderMemoryPressure(pCache)\n  )){\n    PCache1 *pOtherCache;\n    pPage = pGroup->pLruTail;\n    pcache1RemoveFromHash(pPage);\n    pcache1PinPage(pPage);\n    if( (pOtherCache = pPage->pCache)->szPage!=pCache->szPage ){\n      pcache1FreePage(pPage);\n      pPage = 0;\n    }else{\n      pGroup->nCurrentPage -= \n               (pOtherCache->bPurgeable - pCache->bPurgeable);\n    }\n  }\n\n  /* Step 5. If a usable page buffer has still not been found, \n  ** attempt to allocate a new one. \n  */\n  if( !pPage ){\n    if( createFlag==1 ) sqlite3BeginBenignMalloc();\n    pcache1LeaveMutex(pGroup);\n    pPage = pcache1AllocPage(pCache);\n    pcache1EnterMutex(pGroup);\n    if( createFlag==1 ) sqlite3EndBenignMalloc();\n  }\n\n  if( pPage ){\n    unsigned int h = iKey % pCache->nHash;\n    pCache->nPage++;\n    pPage->iKey = iKey;\n    pPage->pNext = pCache->apHash[h];\n    pPage->pCache = pCache;\n    pPage->pLruPrev = 0;\n    pPage->pLruNext = 0;\n    *(void **)(PGHDR1_TO_PAGE(pPage)) = 0;\n    pCache->apHash[h] = pPage;\n  }\n\nfetch_out:\n  if( pPage && iKey>pCache->iMaxKey ){\n    pCache->iMaxKey = iKey;\n  }\n  pcache1LeaveMutex(pGroup);\n  return (pPage ? PGHDR1_TO_PAGE(pPage) : 0);\n}\n\n\n/*\n** Implementation of the sqlite3_pcache.xUnpin method.\n**\n** Mark a page as unpinned (eligible for asynchronous recycling).\n*/\nstatic void pcache1Unpin(sqlite3_pcache *p, void *pPg, int reuseUnlikely){\n  PCache1 *pCache = (PCache1 *)p;\n  PgHdr1 *pPage = PAGE_TO_PGHDR1(pCache, pPg);\n  PGroup *pGroup = pCache->pGroup;\n \n  assert( pPage->pCache==pCache );\n  pcache1EnterMutex(pGroup);\n\n  /* It is an error to call this function if the page is already \n  ** part of the PGroup LRU list.\n  */\n  assert( pPage->pLruPrev==0 && pPage->pLruNext==0 );\n  assert( pGroup->pLruHead!=pPage && pGroup->pLruTail!=pPage );\n\n  if( reuseUnlikely || pGroup->nCurrentPage>pGroup->nMaxPage ){\n    pcache1RemoveFromHash(pPage);\n    pcache1FreePage(pPage);\n  }else{\n    /* Add the page to the PGroup LRU list. */\n    if( pGroup->pLruHead ){\n      pGroup->pLruHead->pLruPrev = pPage;\n      pPage->pLruNext = pGroup->pLruHead;\n      pGroup->pLruHead = pPage;\n    }else{\n      pGroup->pLruTail = pPage;\n      pGroup->pLruHead = pPage;\n    }\n    pCache->nRecyclable++;\n  }\n\n  pcache1LeaveMutex(pCache->pGroup);\n}\n\n/*\n** Implementation of the sqlite3_pcache.xRekey method. \n*/\nstatic void pcache1Rekey(\n  sqlite3_pcache *p,\n  void *pPg,\n  unsigned int iOld,\n  unsigned int iNew\n){\n  PCache1 *pCache = (PCache1 *)p;\n  PgHdr1 *pPage = PAGE_TO_PGHDR1(pCache, pPg);\n  PgHdr1 **pp;\n  unsigned int h; \n  assert( pPage->iKey==iOld );\n  assert( pPage->pCache==pCache );\n\n  pcache1EnterMutex(pCache->pGroup);\n\n  h = iOld%pCache->nHash;\n  pp = &pCache->apHash[h];\n  while( (*pp)!=pPage ){\n    pp = &(*pp)->pNext;\n  }\n  *pp = pPage->pNext;\n\n  h = iNew%pCache->nHash;\n  pPage->iKey = iNew;\n  pPage->pNext = pCache->apHash[h];\n  pCache->apHash[h] = pPage;\n  if( iNew>pCache->iMaxKey ){\n    pCache->iMaxKey = iNew;\n  }\n\n  pcache1LeaveMutex(pCache->pGroup);\n}\n\n/*\n** Implementation of the sqlite3_pcache.xTruncate method. \n**\n** Discard all unpinned pages in the cache with a page number equal to\n** or greater than parameter iLimit. Any pinned pages with a page number\n** equal to or greater than iLimit are implicitly unpinned.\n*/\nstatic void pcache1Truncate(sqlite3_pcache *p, unsigned int iLimit){\n  PCache1 *pCache = (PCache1 *)p;\n  pcache1EnterMutex(pCache->pGroup);\n  if( iLimit<=pCache->iMaxKey ){\n    pcache1TruncateUnsafe(pCache, iLimit);\n    pCache->iMaxKey = iLimit-1;\n  }\n  pcache1LeaveMutex(pCache->pGroup);\n}\n\n/*\n** Implementation of the sqlite3_pcache.xDestroy method. \n**\n** Destroy a cache allocated using pcache1Create().\n*/\nstatic void pcache1Destroy(sqlite3_pcache *p){\n  PCache1 *pCache = (PCache1 *)p;\n  PGroup *pGroup = pCache->pGroup;\n  assert( pCache->bPurgeable || (pCache->nMax==0 && pCache->nMin==0) );\n  pcache1EnterMutex(pGroup);\n  pcache1TruncateUnsafe(pCache, 0);\n  pGroup->nMaxPage -= pCache->nMax;\n  pGroup->nMinPage -= pCache->nMin;\n  pGroup->mxPinned = pGroup->nMaxPage + 10 - pGroup->nMinPage;\n  pcache1EnforceMaxPage(pGroup);\n  pcache1LeaveMutex(pGroup);\n  sqlite3_free(pCache->apHash);\n  sqlite3_free(pCache);\n}\n\n/*\n** This function is called during initialization (sqlite3_initialize()) to\n** install the default pluggable cache module, assuming the user has not\n** already provided an alternative.\n*/\nSQLITE_PRIVATE void sqlite3PCacheSetDefault(void){\n  static const sqlite3_pcache_methods defaultMethods = {\n    0,                       /* pArg */\n    pcache1Init,             /* xInit */\n    pcache1Shutdown,         /* xShutdown */\n    pcache1Create,           /* xCreate */\n    pcache1Cachesize,        /* xCachesize */\n    pcache1Pagecount,        /* xPagecount */\n    pcache1Fetch,            /* xFetch */\n    pcache1Unpin,            /* xUnpin */\n    pcache1Rekey,            /* xRekey */\n    pcache1Truncate,         /* xTruncate */\n    pcache1Destroy           /* xDestroy */\n  };\n  sqlite3_config(SQLITE_CONFIG_PCACHE, &defaultMethods);\n}\n\n#ifdef SQLITE_ENABLE_MEMORY_MANAGEMENT\n/*\n** This function is called to free superfluous dynamically allocated memory\n** held by the pager system. Memory in use by any SQLite pager allocated\n** by the current thread may be sqlite3_free()ed.\n**\n** nReq is the number of bytes of memory required. Once this much has\n** been released, the function returns. The return value is the total number \n** of bytes of memory released.\n*/\nSQLITE_PRIVATE int sqlite3PcacheReleaseMemory(int nReq){\n  int nFree = 0;\n  assert( sqlite3_mutex_notheld(pcache1.grp.mutex) );\n  assert( sqlite3_mutex_notheld(pcache1.mutex) );\n  if( pcache1.pStart==0 ){\n    PgHdr1 *p;\n    pcache1EnterMutex(&pcache1.grp);\n    while( (nReq<0 || nFree<nReq) && ((p=pcache1.grp.pLruTail)!=0) ){\n      nFree += pcache1MemSize(PGHDR1_TO_PAGE(p));\n      pcache1PinPage(p);\n      pcache1RemoveFromHash(p);\n      pcache1FreePage(p);\n    }\n    pcache1LeaveMutex(&pcache1.grp);\n  }\n  return nFree;\n}\n#endif /* SQLITE_ENABLE_MEMORY_MANAGEMENT */\n\n#ifdef SQLITE_TEST\n/*\n** This function is used by test procedures to inspect the internal state\n** of the global cache.\n*/\nSQLITE_PRIVATE void sqlite3PcacheStats(\n  int *pnCurrent,      /* OUT: Total number of pages cached */\n  int *pnMax,          /* OUT: Global maximum cache size */\n  int *pnMin,          /* OUT: Sum of PCache1.nMin for purgeable caches */\n  int *pnRecyclable    /* OUT: Total number of pages available for recycling */\n){\n  PgHdr1 *p;\n  int nRecyclable = 0;\n  for(p=pcache1.grp.pLruHead; p; p=p->pLruNext){\n    nRecyclable++;\n  }\n  *pnCurrent = pcache1.grp.nCurrentPage;\n  *pnMax = pcache1.grp.nMaxPage;\n  *pnMin = pcache1.grp.nMinPage;\n  *pnRecyclable = nRecyclable;\n}\n#endif\n\n/************** End of pcache1.c *********************************************/\n/************** Begin file rowset.c ******************************************/\n/*\n** 2008 December 3\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n**\n** This module implements an object we call a \"RowSet\".\n**\n** The RowSet object is a collection of rowids.  Rowids\n** are inserted into the RowSet in an arbitrary order.  Inserts\n** can be intermixed with tests to see if a given rowid has been\n** previously inserted into the RowSet.\n**\n** After all inserts are finished, it is possible to extract the\n** elements of the RowSet in sorted order.  Once this extraction\n** process has started, no new elements may be inserted.\n**\n** Hence, the primitive operations for a RowSet are:\n**\n**    CREATE\n**    INSERT\n**    TEST\n**    SMALLEST\n**    DESTROY\n**\n** The CREATE and DESTROY primitives are the constructor and destructor,\n** obviously.  The INSERT primitive adds a new element to the RowSet.\n** TEST checks to see if an element is already in the RowSet.  SMALLEST\n** extracts the least value from the RowSet.\n**\n** The INSERT primitive might allocate additional memory.  Memory is\n** allocated in chunks so most INSERTs do no allocation.  There is an \n** upper bound on the size of allocated memory.  No memory is freed\n** until DESTROY.\n**\n** The TEST primitive includes a \"batch\" number.  The TEST primitive\n** will only see elements that were inserted before the last change\n** in the batch number.  In other words, if an INSERT occurs between\n** two TESTs where the TESTs have the same batch nubmer, then the\n** value added by the INSERT will not be visible to the second TEST.\n** The initial batch number is zero, so if the very first TEST contains\n** a non-zero batch number, it will see all prior INSERTs.\n**\n** No INSERTs may occurs after a SMALLEST.  An assertion will fail if\n** that is attempted.\n**\n** The cost of an INSERT is roughly constant.  (Sometime new memory\n** has to be allocated on an INSERT.)  The cost of a TEST with a new\n** batch number is O(NlogN) where N is the number of elements in the RowSet.\n** The cost of a TEST using the same batch number is O(logN).  The cost\n** of the first SMALLEST is O(NlogN).  Second and subsequent SMALLEST\n** primitives are constant time.  The cost of DESTROY is O(N).\n**\n** There is an added cost of O(N) when switching between TEST and\n** SMALLEST primitives.\n*/\n\n\n/*\n** Target size for allocation chunks.\n*/\n#define ROWSET_ALLOCATION_SIZE 1024\n\n/*\n** The number of rowset entries per allocation chunk.\n*/\n#define ROWSET_ENTRY_PER_CHUNK  \\\n                       ((ROWSET_ALLOCATION_SIZE-8)/sizeof(struct RowSetEntry))\n\n/*\n** Each entry in a RowSet is an instance of the following object.\n*/\nstruct RowSetEntry {            \n  i64 v;                        /* ROWID value for this entry */\n  struct RowSetEntry *pRight;   /* Right subtree (larger entries) or list */\n  struct RowSetEntry *pLeft;    /* Left subtree (smaller entries) */\n};\n\n/*\n** RowSetEntry objects are allocated in large chunks (instances of the\n** following structure) to reduce memory allocation overhead.  The\n** chunks are kept on a linked list so that they can be deallocated\n** when the RowSet is destroyed.\n*/\nstruct RowSetChunk {\n  struct RowSetChunk *pNextChunk;        /* Next chunk on list of them all */\n  struct RowSetEntry aEntry[ROWSET_ENTRY_PER_CHUNK]; /* Allocated entries */\n};\n\n/*\n** A RowSet in an instance of the following structure.\n**\n** A typedef of this structure if found in sqliteInt.h.\n*/\nstruct RowSet {\n  struct RowSetChunk *pChunk;    /* List of all chunk allocations */\n  sqlite3 *db;                   /* The database connection */\n  struct RowSetEntry *pEntry;    /* List of entries using pRight */\n  struct RowSetEntry *pLast;     /* Last entry on the pEntry list */\n  struct RowSetEntry *pFresh;    /* Source of new entry objects */\n  struct RowSetEntry *pTree;     /* Binary tree of entries */\n  u16 nFresh;                    /* Number of objects on pFresh */\n  u8 isSorted;                   /* True if pEntry is sorted */\n  u8 iBatch;                     /* Current insert batch */\n};\n\n/*\n** Turn bulk memory into a RowSet object.  N bytes of memory\n** are available at pSpace.  The db pointer is used as a memory context\n** for any subsequent allocations that need to occur.\n** Return a pointer to the new RowSet object.\n**\n** It must be the case that N is sufficient to make a Rowset.  If not\n** an assertion fault occurs.\n** \n** If N is larger than the minimum, use the surplus as an initial\n** allocation of entries available to be filled.\n*/\nSQLITE_PRIVATE RowSet *sqlite3RowSetInit(sqlite3 *db, void *pSpace, unsigned int N){\n  RowSet *p;\n  assert( N >= ROUND8(sizeof(*p)) );\n  p = pSpace;\n  p->pChunk = 0;\n  p->db = db;\n  p->pEntry = 0;\n  p->pLast = 0;\n  p->pTree = 0;\n  p->pFresh = (struct RowSetEntry*)(ROUND8(sizeof(*p)) + (char*)p);\n  p->nFresh = (u16)((N - ROUND8(sizeof(*p)))/sizeof(struct RowSetEntry));\n  p->isSorted = 1;\n  p->iBatch = 0;\n  return p;\n}\n\n/*\n** Deallocate all chunks from a RowSet.  This frees all memory that\n** the RowSet has allocated over its lifetime.  This routine is\n** the destructor for the RowSet.\n*/\nSQLITE_PRIVATE void sqlite3RowSetClear(RowSet *p){\n  struct RowSetChunk *pChunk, *pNextChunk;\n  for(pChunk=p->pChunk; pChunk; pChunk = pNextChunk){\n    pNextChunk = pChunk->pNextChunk;\n    sqlite3DbFree(p->db, pChunk);\n  }\n  p->pChunk = 0;\n  p->nFresh = 0;\n  p->pEntry = 0;\n  p->pLast = 0;\n  p->pTree = 0;\n  p->isSorted = 1;\n}\n\n/*\n** Insert a new value into a RowSet.\n**\n** The mallocFailed flag of the database connection is set if a\n** memory allocation fails.\n*/\nSQLITE_PRIVATE void sqlite3RowSetInsert(RowSet *p, i64 rowid){\n  struct RowSetEntry *pEntry;  /* The new entry */\n  struct RowSetEntry *pLast;   /* The last prior entry */\n  assert( p!=0 );\n  if( p->nFresh==0 ){\n    struct RowSetChunk *pNew;\n    pNew = sqlite3DbMallocRaw(p->db, sizeof(*pNew));\n    if( pNew==0 ){\n      return;\n    }\n    pNew->pNextChunk = p->pChunk;\n    p->pChunk = pNew;\n    p->pFresh = pNew->aEntry;\n    p->nFresh = ROWSET_ENTRY_PER_CHUNK;\n  }\n  pEntry = p->pFresh++;\n  p->nFresh--;\n  pEntry->v = rowid;\n  pEntry->pRight = 0;\n  pLast = p->pLast;\n  if( pLast ){\n    if( p->isSorted && rowid<=pLast->v ){\n      p->isSorted = 0;\n    }\n    pLast->pRight = pEntry;\n  }else{\n    assert( p->pEntry==0 ); /* Fires if INSERT after SMALLEST */\n    p->pEntry = pEntry;\n  }\n  p->pLast = pEntry;\n}\n\n/*\n** Merge two lists of RowSetEntry objects.  Remove duplicates.\n**\n** The input lists are connected via pRight pointers and are \n** assumed to each already be in sorted order.\n*/\nstatic struct RowSetEntry *rowSetMerge(\n  struct RowSetEntry *pA,    /* First sorted list to be merged */\n  struct RowSetEntry *pB     /* Second sorted list to be merged */\n){\n  struct RowSetEntry head;\n  struct RowSetEntry *pTail;\n\n  pTail = &head;\n  while( pA && pB ){\n    assert( pA->pRight==0 || pA->v<=pA->pRight->v );\n    assert( pB->pRight==0 || pB->v<=pB->pRight->v );\n    if( pA->v<pB->v ){\n      pTail->pRight = pA;\n      pA = pA->pRight;\n      pTail = pTail->pRight;\n    }else if( pB->v<pA->v ){\n      pTail->pRight = pB;\n      pB = pB->pRight;\n      pTail = pTail->pRight;\n    }else{\n      pA = pA->pRight;\n    }\n  }\n  if( pA ){\n    assert( pA->pRight==0 || pA->v<=pA->pRight->v );\n    pTail->pRight = pA;\n  }else{\n    assert( pB==0 || pB->pRight==0 || pB->v<=pB->pRight->v );\n    pTail->pRight = pB;\n  }\n  return head.pRight;\n}\n\n/*\n** Sort all elements on the pEntry list of the RowSet into ascending order.\n*/ \nstatic void rowSetSort(RowSet *p){\n  unsigned int i;\n  struct RowSetEntry *pEntry;\n  struct RowSetEntry *aBucket[40];\n\n  assert( p->isSorted==0 );\n  memset(aBucket, 0, sizeof(aBucket));\n  while( p->pEntry ){\n    pEntry = p->pEntry;\n    p->pEntry = pEntry->pRight;\n    pEntry->pRight = 0;\n    for(i=0; aBucket[i]; i++){\n      pEntry = rowSetMerge(aBucket[i], pEntry);\n      aBucket[i] = 0;\n    }\n    aBucket[i] = pEntry;\n  }\n  pEntry = 0;\n  for(i=0; i<sizeof(aBucket)/sizeof(aBucket[0]); i++){\n    pEntry = rowSetMerge(pEntry, aBucket[i]);\n  }\n  p->pEntry = pEntry;\n  p->pLast = 0;\n  p->isSorted = 1;\n}\n\n\n/*\n** The input, pIn, is a binary tree (or subtree) of RowSetEntry objects.\n** Convert this tree into a linked list connected by the pRight pointers\n** and return pointers to the first and last elements of the new list.\n*/\nstatic void rowSetTreeToList(\n  struct RowSetEntry *pIn,         /* Root of the input tree */\n  struct RowSetEntry **ppFirst,    /* Write head of the output list here */\n  struct RowSetEntry **ppLast      /* Write tail of the output list here */\n){\n  assert( pIn!=0 );\n  if( pIn->pLeft ){\n    struct RowSetEntry *p;\n    rowSetTreeToList(pIn->pLeft, ppFirst, &p);\n    p->pRight = pIn;\n  }else{\n    *ppFirst = pIn;\n  }\n  if( pIn->pRight ){\n    rowSetTreeToList(pIn->pRight, &pIn->pRight, ppLast);\n  }else{\n    *ppLast = pIn;\n  }\n  assert( (*ppLast)->pRight==0 );\n}\n\n\n/*\n** Convert a sorted list of elements (connected by pRight) into a binary\n** tree with depth of iDepth.  A depth of 1 means the tree contains a single\n** node taken from the head of *ppList.  A depth of 2 means a tree with\n** three nodes.  And so forth.\n**\n** Use as many entries from the input list as required and update the\n** *ppList to point to the unused elements of the list.  If the input\n** list contains too few elements, then construct an incomplete tree\n** and leave *ppList set to NULL.\n**\n** Return a pointer to the root of the constructed binary tree.\n*/\nstatic struct RowSetEntry *rowSetNDeepTree(\n  struct RowSetEntry **ppList,\n  int iDepth\n){\n  struct RowSetEntry *p;         /* Root of the new tree */\n  struct RowSetEntry *pLeft;     /* Left subtree */\n  if( *ppList==0 ){\n    return 0;\n  }\n  if( iDepth==1 ){\n    p = *ppList;\n    *ppList = p->pRight;\n    p->pLeft = p->pRight = 0;\n    return p;\n  }\n  pLeft = rowSetNDeepTree(ppList, iDepth-1);\n  p = *ppList;\n  if( p==0 ){\n    return pLeft;\n  }\n  p->pLeft = pLeft;\n  *ppList = p->pRight;\n  p->pRight = rowSetNDeepTree(ppList, iDepth-1);\n  return p;\n}\n\n/*\n** Convert a sorted list of elements into a binary tree. Make the tree\n** as deep as it needs to be in order to contain the entire list.\n*/\nstatic struct RowSetEntry *rowSetListToTree(struct RowSetEntry *pList){\n  int iDepth;           /* Depth of the tree so far */\n  struct RowSetEntry *p;       /* Current tree root */\n  struct RowSetEntry *pLeft;   /* Left subtree */\n\n  assert( pList!=0 );\n  p = pList;\n  pList = p->pRight;\n  p->pLeft = p->pRight = 0;\n  for(iDepth=1; pList; iDepth++){\n    pLeft = p;\n    p = pList;\n    pList = p->pRight;\n    p->pLeft = pLeft;\n    p->pRight = rowSetNDeepTree(&pList, iDepth);\n  }\n  return p;\n}\n\n/*\n** Convert the list in p->pEntry into a sorted list if it is not\n** sorted already.  If there is a binary tree on p->pTree, then\n** convert it into a list too and merge it into the p->pEntry list.\n*/\nstatic void rowSetToList(RowSet *p){\n  if( !p->isSorted ){\n    rowSetSort(p);\n  }\n  if( p->pTree ){\n    struct RowSetEntry *pHead, *pTail;\n    rowSetTreeToList(p->pTree, &pHead, &pTail);\n    p->pTree = 0;\n    p->pEntry = rowSetMerge(p->pEntry, pHead);\n  }\n}\n\n/*\n** Extract the smallest element from the RowSet.\n** Write the element into *pRowid.  Return 1 on success.  Return\n** 0 if the RowSet is already empty.\n**\n** After this routine has been called, the sqlite3RowSetInsert()\n** routine may not be called again.  \n*/\nSQLITE_PRIVATE int sqlite3RowSetNext(RowSet *p, i64 *pRowid){\n  rowSetToList(p);\n  if( p->pEntry ){\n    *pRowid = p->pEntry->v;\n    p->pEntry = p->pEntry->pRight;\n    if( p->pEntry==0 ){\n      sqlite3RowSetClear(p);\n    }\n    return 1;\n  }else{\n    return 0;\n  }\n}\n\n/*\n** Check to see if element iRowid was inserted into the the rowset as\n** part of any insert batch prior to iBatch.  Return 1 or 0.\n*/\nSQLITE_PRIVATE int sqlite3RowSetTest(RowSet *pRowSet, u8 iBatch, sqlite3_int64 iRowid){\n  struct RowSetEntry *p;\n  if( iBatch!=pRowSet->iBatch ){\n    if( pRowSet->pEntry ){\n      rowSetToList(pRowSet);\n      pRowSet->pTree = rowSetListToTree(pRowSet->pEntry);\n      pRowSet->pEntry = 0;\n      pRowSet->pLast = 0;\n    }\n    pRowSet->iBatch = iBatch;\n  }\n  p = pRowSet->pTree;\n  while( p ){\n    if( p->v<iRowid ){\n      p = p->pRight;\n    }else if( p->v>iRowid ){\n      p = p->pLeft;\n    }else{\n      return 1;\n    }\n  }\n  return 0;\n}\n\n/************** End of rowset.c **********************************************/\n/************** Begin file pager.c *******************************************/\n/*\n** 2001 September 15\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This is the implementation of the page cache subsystem or \"pager\".\n** \n** The pager is used to access a database disk file.  It implements\n** atomic commit and rollback through the use of a journal file that\n** is separate from the database file.  The pager also implements file\n** locking to prevent two processes from writing the same database\n** file simultaneously, or one process from reading the database while\n** another is writing.\n*/\n#ifndef SQLITE_OMIT_DISKIO\n/************** Include wal.h in the middle of pager.c ***********************/\n/************** Begin file wal.h *********************************************/\n/*\n** 2010 February 1\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This header file defines the interface to the write-ahead logging \n** system. Refer to the comments below and the header comment attached to \n** the implementation of each function in log.c for further details.\n*/\n\n#ifndef _WAL_H_\n#define _WAL_H_\n\n\n#ifdef SQLITE_OMIT_WAL\n# define sqlite3WalOpen(x,y,z)                   0\n# define sqlite3WalClose(w,x,y,z)                0\n# define sqlite3WalBeginReadTransaction(y,z)     0\n# define sqlite3WalEndReadTransaction(z)\n# define sqlite3WalRead(v,w,x,y,z)               0\n# define sqlite3WalDbsize(y)                     0\n# define sqlite3WalBeginWriteTransaction(y)      0\n# define sqlite3WalEndWriteTransaction(x)        0\n# define sqlite3WalUndo(x,y,z)                   0\n# define sqlite3WalSavepoint(y,z)\n# define sqlite3WalSavepointUndo(y,z)            0\n# define sqlite3WalFrames(u,v,w,x,y,z)           0\n# define sqlite3WalCheckpoint(r,s,t,u,v,w,x,y,z) 0\n# define sqlite3WalCallback(z)                   0\n# define sqlite3WalExclusiveMode(y,z)            0\n# define sqlite3WalHeapMemory(z)                 0\n#else\n\n#define WAL_SAVEPOINT_NDATA 4\n\n/* Connection to a write-ahead log (WAL) file. \n** There is one object of this type for each pager. \n*/\ntypedef struct Wal Wal;\n\n/* Open and close a connection to a write-ahead log. */\nSQLITE_PRIVATE int sqlite3WalOpen(sqlite3_vfs*, sqlite3_file*, const char *zName, int, Wal**);\nSQLITE_PRIVATE int sqlite3WalClose(Wal *pWal, int sync_flags, int, u8 *);\n\n/* Used by readers to open (lock) and close (unlock) a snapshot.  A \n** snapshot is like a read-transaction.  It is the state of the database\n** at an instant in time.  sqlite3WalOpenSnapshot gets a read lock and\n** preserves the current state even if the other threads or processes\n** write to or checkpoint the WAL.  sqlite3WalCloseSnapshot() closes the\n** transaction and releases the lock.\n*/\nSQLITE_PRIVATE int sqlite3WalBeginReadTransaction(Wal *pWal, int *);\nSQLITE_PRIVATE void sqlite3WalEndReadTransaction(Wal *pWal);\n\n/* Read a page from the write-ahead log, if it is present. */\nSQLITE_PRIVATE int sqlite3WalRead(Wal *pWal, Pgno pgno, int *pInWal, int nOut, u8 *pOut);\n\n/* If the WAL is not empty, return the size of the database. */\nSQLITE_PRIVATE Pgno sqlite3WalDbsize(Wal *pWal);\n\n/* Obtain or release the WRITER lock. */\nSQLITE_PRIVATE int sqlite3WalBeginWriteTransaction(Wal *pWal);\nSQLITE_PRIVATE int sqlite3WalEndWriteTransaction(Wal *pWal);\n\n/* Undo any frames written (but not committed) to the log */\nSQLITE_PRIVATE int sqlite3WalUndo(Wal *pWal, int (*xUndo)(void *, Pgno), void *pUndoCtx);\n\n/* Return an integer that records the current (uncommitted) write\n** position in the WAL */\nSQLITE_PRIVATE void sqlite3WalSavepoint(Wal *pWal, u32 *aWalData);\n\n/* Move the write position of the WAL back to iFrame.  Called in\n** response to a ROLLBACK TO command. */\nSQLITE_PRIVATE int sqlite3WalSavepointUndo(Wal *pWal, u32 *aWalData);\n\n/* Write a frame or frames to the log. */\nSQLITE_PRIVATE int sqlite3WalFrames(Wal *pWal, int, PgHdr *, Pgno, int, int);\n\n/* Copy pages from the log to the database file */ \nSQLITE_PRIVATE int sqlite3WalCheckpoint(\n  Wal *pWal,                      /* Write-ahead log connection */\n  int eMode,                      /* One of PASSIVE, FULL and RESTART */\n  int (*xBusy)(void*),            /* Function to call when busy */\n  void *pBusyArg,                 /* Context argument for xBusyHandler */\n  int sync_flags,                 /* Flags to sync db file with (or 0) */\n  int nBuf,                       /* Size of buffer nBuf */\n  u8 *zBuf,                       /* Temporary buffer to use */\n  int *pnLog,                     /* OUT: Number of frames in WAL */\n  int *pnCkpt                     /* OUT: Number of backfilled frames in WAL */\n);\n\n/* Return the value to pass to a sqlite3_wal_hook callback, the\n** number of frames in the WAL at the point of the last commit since\n** sqlite3WalCallback() was called.  If no commits have occurred since\n** the last call, then return 0.\n*/\nSQLITE_PRIVATE int sqlite3WalCallback(Wal *pWal);\n\n/* Tell the wal layer that an EXCLUSIVE lock has been obtained (or released)\n** by the pager layer on the database file.\n*/\nSQLITE_PRIVATE int sqlite3WalExclusiveMode(Wal *pWal, int op);\n\n/* Return true if the argument is non-NULL and the WAL module is using\n** heap-memory for the wal-index. Otherwise, if the argument is NULL or the\n** WAL module is using shared-memory, return false. \n*/\nSQLITE_PRIVATE int sqlite3WalHeapMemory(Wal *pWal);\n\n#endif /* ifndef SQLITE_OMIT_WAL */\n#endif /* _WAL_H_ */\n\n/************** End of wal.h *************************************************/\n/************** Continuing where we left off in pager.c **********************/\n\n\n/******************* NOTES ON THE DESIGN OF THE PAGER ************************\n**\n** This comment block describes invariants that hold when using a rollback\n** journal.  These invariants do not apply for journal_mode=WAL,\n** journal_mode=MEMORY, or journal_mode=OFF.\n**\n** Within this comment block, a page is deemed to have been synced\n** automatically as soon as it is written when PRAGMA synchronous=OFF.\n** Otherwise, the page is not synced until the xSync method of the VFS\n** is called successfully on the file containing the page.\n**\n** Definition:  A page of the database file is said to be \"overwriteable\" if\n** one or more of the following are true about the page:\n** \n**     (a)  The original content of the page as it was at the beginning of\n**          the transaction has been written into the rollback journal and\n**          synced.\n** \n**     (b)  The page was a freelist leaf page at the start of the transaction.\n** \n**     (c)  The page number is greater than the largest page that existed in\n**          the database file at the start of the transaction.\n** \n** (1) A page of the database file is never overwritten unless one of the\n**     following are true:\n** \n**     (a) The page and all other pages on the same sector are overwriteable.\n** \n**     (b) The atomic page write optimization is enabled, and the entire\n**         transaction other than the update of the transaction sequence\n**         number consists of a single page change.\n** \n** (2) The content of a page written into the rollback journal exactly matches\n**     both the content in the database when the rollback journal was written\n**     and the content in the database at the beginning of the current\n**     transaction.\n** \n** (3) Writes to the database file are an integer multiple of the page size\n**     in length and are aligned on a page boundary.\n** \n** (4) Reads from the database file are either aligned on a page boundary and\n**     an integer multiple of the page size in length or are taken from the\n**     first 100 bytes of the database file.\n** \n** (5) All writes to the database file are synced prior to the rollback journal\n**     being deleted, truncated, or zeroed.\n** \n** (6) If a master journal file is used, then all writes to the database file\n**     are synced prior to the master journal being deleted.\n** \n** Definition: Two databases (or the same database at two points it time)\n** are said to be \"logically equivalent\" if they give the same answer to\n** all queries.  Note in particular the the content of freelist leaf\n** pages can be changed arbitarily without effecting the logical equivalence\n** of the database.\n** \n** (7) At any time, if any subset, including the empty set and the total set,\n**     of the unsynced changes to a rollback journal are removed and the \n**     journal is rolled back, the resulting database file will be logical\n**     equivalent to the database file at the beginning of the transaction.\n** \n** (8) When a transaction is rolled back, the xTruncate method of the VFS\n**     is called to restore the database file to the same size it was at\n**     the beginning of the transaction.  (In some VFSes, the xTruncate\n**     method is a no-op, but that does not change the fact the SQLite will\n**     invoke it.)\n** \n** (9) Whenever the database file is modified, at least one bit in the range\n**     of bytes from 24 through 39 inclusive will be changed prior to releasing\n**     the EXCLUSIVE lock, thus signaling other connections on the same\n**     database to flush their caches.\n**\n** (10) The pattern of bits in bytes 24 through 39 shall not repeat in less\n**      than one billion transactions.\n**\n** (11) A database file is well-formed at the beginning and at the conclusion\n**      of every transaction.\n**\n** (12) An EXCLUSIVE lock is held on the database file when writing to\n**      the database file.\n**\n** (13) A SHARED lock is held on the database file while reading any\n**      content out of the database file.\n**\n******************************************************************************/\n\n/*\n** Macros for troubleshooting.  Normally turned off\n*/\n#if 0\nint sqlite3PagerTrace=1;  /* True to enable tracing */\n#define sqlite3DebugPrintf printf\n#define PAGERTRACE(X)     if( sqlite3PagerTrace ){ sqlite3DebugPrintf X; }\n#else\n#define PAGERTRACE(X)\n#endif\n\n/*\n** The following two macros are used within the PAGERTRACE() macros above\n** to print out file-descriptors. \n**\n** PAGERID() takes a pointer to a Pager struct as its argument. The\n** associated file-descriptor is returned. FILEHANDLEID() takes an sqlite3_file\n** struct as its argument.\n*/\n#define PAGERID(p) ((int)(p->fd))\n#define FILEHANDLEID(fd) ((int)fd)\n\n/*\n** The Pager.eState variable stores the current 'state' of a pager. A\n** pager may be in any one of the seven states shown in the following\n** state diagram.\n**\n**                            OPEN <------+------+\n**                              |         |      |\n**                              V         |      |\n**               +---------> READER-------+      |\n**               |              |                |\n**               |              V                |\n**               |<-------WRITER_LOCKED------> ERROR\n**               |              |                ^  \n**               |              V                |\n**               |<------WRITER_CACHEMOD-------->|\n**               |              |                |\n**               |              V                |\n**               |<-------WRITER_DBMOD---------->|\n**               |              |                |\n**               |              V                |\n**               +<------WRITER_FINISHED-------->+\n**\n**\n** List of state transitions and the C [function] that performs each:\n** \n**   OPEN              -> READER              [sqlite3PagerSharedLock]\n**   READER            -> OPEN                [pager_unlock]\n**\n**   READER            -> WRITER_LOCKED       [sqlite3PagerBegin]\n**   WRITER_LOCKED     -> WRITER_CACHEMOD     [pager_open_journal]\n**   WRITER_CACHEMOD   -> WRITER_DBMOD        [syncJournal]\n**   WRITER_DBMOD      -> WRITER_FINISHED     [sqlite3PagerCommitPhaseOne]\n**   WRITER_***        -> READER              [pager_end_transaction]\n**\n**   WRITER_***        -> ERROR               [pager_error]\n**   ERROR             -> OPEN                [pager_unlock]\n** \n**\n**  OPEN:\n**\n**    The pager starts up in this state. Nothing is guaranteed in this\n**    state - the file may or may not be locked and the database size is\n**    unknown. The database may not be read or written.\n**\n**    * No read or write transaction is active.\n**    * Any lock, or no lock at all, may be held on the database file.\n**    * The dbSize, dbOrigSize and dbFileSize variables may not be trusted.\n**\n**  READER:\n**\n**    In this state all the requirements for reading the database in \n**    rollback (non-WAL) mode are met. Unless the pager is (or recently\n**    was) in exclusive-locking mode, a user-level read transaction is \n**    open. The database size is known in this state.\n**\n**    A connection running with locking_mode=normal enters this state when\n**    it opens a read-transaction on the database and returns to state\n**    OPEN after the read-transaction is completed. However a connection\n**    running in locking_mode=exclusive (including temp databases) remains in\n**    this state even after the read-transaction is closed. The only way\n**    a locking_mode=exclusive connection can transition from READER to OPEN\n**    is via the ERROR state (see below).\n** \n**    * A read transaction may be active (but a write-transaction cannot).\n**    * A SHARED or greater lock is held on the database file.\n**    * The dbSize variable may be trusted (even if a user-level read \n**      transaction is not active). The dbOrigSize and dbFileSize variables\n**      may not be trusted at this point.\n**    * If the database is a WAL database, then the WAL connection is open.\n**    * Even if a read-transaction is not open, it is guaranteed that \n**      there is no hot-journal in the file-system.\n**\n**  WRITER_LOCKED:\n**\n**    The pager moves to this state from READER when a write-transaction\n**    is first opened on the database. In WRITER_LOCKED state, all locks \n**    required to start a write-transaction are held, but no actual \n**    modifications to the cache or database have taken place.\n**\n**    In rollback mode, a RESERVED or (if the transaction was opened with \n**    BEGIN EXCLUSIVE) EXCLUSIVE lock is obtained on the database file when\n**    moving to this state, but the journal file is not written to or opened \n**    to in this state. If the transaction is committed or rolled back while \n**    in WRITER_LOCKED state, all that is required is to unlock the database \n**    file.\n**\n**    IN WAL mode, WalBeginWriteTransaction() is called to lock the log file.\n**    If the connection is running with locking_mode=exclusive, an attempt\n**    is made to obtain an EXCLUSIVE lock on the database file.\n**\n**    * A write transaction is active.\n**    * If the connection is open in rollback-mode, a RESERVED or greater \n**      lock is held on the database file.\n**    * If the connection is open in WAL-mode, a WAL write transaction\n**      is open (i.e. sqlite3WalBeginWriteTransaction() has been successfully\n**      called).\n**    * The dbSize, dbOrigSize and dbFileSize variables are all valid.\n**    * The contents of the pager cache have not been modified.\n**    * The journal file may or may not be open.\n**    * Nothing (not even the first header) has been written to the journal.\n**\n**  WRITER_CACHEMOD:\n**\n**    A pager moves from WRITER_LOCKED state to this state when a page is\n**    first modified by the upper layer. In rollback mode the journal file\n**    is opened (if it is not already open) and a header written to the\n**    start of it. The database file on disk has not been modified.\n**\n**    * A write transaction is active.\n**    * A RESERVED or greater lock is held on the database file.\n**    * The journal file is open and the first header has been written \n**      to it, but the header has not been synced to disk.\n**    * The contents of the page cache have been modified.\n**\n**  WRITER_DBMOD:\n**\n**    The pager transitions from WRITER_CACHEMOD into WRITER_DBMOD state\n**    when it modifies the contents of the database file. WAL connections\n**    never enter this state (since they do not modify the database file,\n**    just the log file).\n**\n**    * A write transaction is active.\n**    * An EXCLUSIVE or greater lock is held on the database file.\n**    * The journal file is open and the first header has been written \n**      and synced to disk.\n**    * The contents of the page cache have been modified (and possibly\n**      written to disk).\n**\n**  WRITER_FINISHED:\n**\n**    It is not possible for a WAL connection to enter this state.\n**\n**    A rollback-mode pager changes to WRITER_FINISHED state from WRITER_DBMOD\n**    state after the entire transaction has been successfully written into the\n**    database file. In this state the transaction may be committed simply\n**    by finalizing the journal file. Once in WRITER_FINISHED state, it is \n**    not possible to modify the database further. At this point, the upper \n**    layer must either commit or rollback the transaction.\n**\n**    * A write transaction is active.\n**    * An EXCLUSIVE or greater lock is held on the database file.\n**    * All writing and syncing of journal and database data has finished.\n**      If no error occured, all that remains is to finalize the journal to\n**      commit the transaction. If an error did occur, the caller will need\n**      to rollback the transaction. \n**\n**  ERROR:\n**\n**    The ERROR state is entered when an IO or disk-full error (including\n**    SQLITE_IOERR_NOMEM) occurs at a point in the code that makes it \n**    difficult to be sure that the in-memory pager state (cache contents, \n**    db size etc.) are consistent with the contents of the file-system.\n**\n**    Temporary pager files may enter the ERROR state, but in-memory pagers\n**    cannot.\n**\n**    For example, if an IO error occurs while performing a rollback, \n**    the contents of the page-cache may be left in an inconsistent state.\n**    At this point it would be dangerous to change back to READER state\n**    (as usually happens after a rollback). Any subsequent readers might\n**    report database corruption (due to the inconsistent cache), and if\n**    they upgrade to writers, they may inadvertently corrupt the database\n**    file. To avoid this hazard, the pager switches into the ERROR state\n**    instead of READER following such an error.\n**\n**    Once it has entered the ERROR state, any attempt to use the pager\n**    to read or write data returns an error. Eventually, once all \n**    outstanding transactions have been abandoned, the pager is able to\n**    transition back to OPEN state, discarding the contents of the \n**    page-cache and any other in-memory state at the same time. Everything\n**    is reloaded from disk (and, if necessary, hot-journal rollback peformed)\n**    when a read-transaction is next opened on the pager (transitioning\n**    the pager into READER state). At that point the system has recovered \n**    from the error.\n**\n**    Specifically, the pager jumps into the ERROR state if:\n**\n**      1. An error occurs while attempting a rollback. This happens in\n**         function sqlite3PagerRollback().\n**\n**      2. An error occurs while attempting to finalize a journal file\n**         following a commit in function sqlite3PagerCommitPhaseTwo().\n**\n**      3. An error occurs while attempting to write to the journal or\n**         database file in function pagerStress() in order to free up\n**         memory.\n**\n**    In other cases, the error is returned to the b-tree layer. The b-tree\n**    layer then attempts a rollback operation. If the error condition \n**    persists, the pager enters the ERROR state via condition (1) above.\n**\n**    Condition (3) is necessary because it can be triggered by a read-only\n**    statement executed within a transaction. In this case, if the error\n**    code were simply returned to the user, the b-tree layer would not\n**    automatically attempt a rollback, as it assumes that an error in a\n**    read-only statement cannot leave the pager in an internally inconsistent \n**    state.\n**\n**    * The Pager.errCode variable is set to something other than SQLITE_OK.\n**    * There are one or more outstanding references to pages (after the\n**      last reference is dropped the pager should move back to OPEN state).\n**    * The pager is not an in-memory pager.\n**    \n**\n** Notes:\n**\n**   * A pager is never in WRITER_DBMOD or WRITER_FINISHED state if the\n**     connection is open in WAL mode. A WAL connection is always in one\n**     of the first four states.\n**\n**   * Normally, a connection open in exclusive mode is never in PAGER_OPEN\n**     state. There are two exceptions: immediately after exclusive-mode has\n**     been turned on (and before any read or write transactions are \n**     executed), and when the pager is leaving the \"error state\".\n**\n**   * See also: assert_pager_state().\n*/\n#define PAGER_OPEN                  0\n#define PAGER_READER                1\n#define PAGER_WRITER_LOCKED         2\n#define PAGER_WRITER_CACHEMOD       3\n#define PAGER_WRITER_DBMOD          4\n#define PAGER_WRITER_FINISHED       5\n#define PAGER_ERROR                 6\n\n/*\n** The Pager.eLock variable is almost always set to one of the \n** following locking-states, according to the lock currently held on\n** the database file: NO_LOCK, SHARED_LOCK, RESERVED_LOCK or EXCLUSIVE_LOCK.\n** This variable is kept up to date as locks are taken and released by\n** the pagerLockDb() and pagerUnlockDb() wrappers.\n**\n** If the VFS xLock() or xUnlock() returns an error other than SQLITE_BUSY\n** (i.e. one of the SQLITE_IOERR subtypes), it is not clear whether or not\n** the operation was successful. In these circumstances pagerLockDb() and\n** pagerUnlockDb() take a conservative approach - eLock is always updated\n** when unlocking the file, and only updated when locking the file if the\n** VFS call is successful. This way, the Pager.eLock variable may be set\n** to a less exclusive (lower) value than the lock that is actually held\n** at the system level, but it is never set to a more exclusive value.\n**\n** This is usually safe. If an xUnlock fails or appears to fail, there may \n** be a few redundant xLock() calls or a lock may be held for longer than\n** required, but nothing really goes wrong.\n**\n** The exception is when the database file is unlocked as the pager moves\n** from ERROR to OPEN state. At this point there may be a hot-journal file \n** in the file-system that needs to be rolled back (as part of a OPEN->SHARED\n** transition, by the same pager or any other). If the call to xUnlock()\n** fails at this point and the pager is left holding an EXCLUSIVE lock, this\n** can confuse the call to xCheckReservedLock() call made later as part\n** of hot-journal detection.\n**\n** xCheckReservedLock() is defined as returning true \"if there is a RESERVED \n** lock held by this process or any others\". So xCheckReservedLock may \n** return true because the caller itself is holding an EXCLUSIVE lock (but\n** doesn't know it because of a previous error in xUnlock). If this happens\n** a hot-journal may be mistaken for a journal being created by an active\n** transaction in another process, causing SQLite to read from the database\n** without rolling it back.\n**\n** To work around this, if a call to xUnlock() fails when unlocking the\n** database in the ERROR state, Pager.eLock is set to UNKNOWN_LOCK. It\n** is only changed back to a real locking state after a successful call\n** to xLock(EXCLUSIVE). Also, the code to do the OPEN->SHARED state transition\n** omits the check for a hot-journal if Pager.eLock is set to UNKNOWN_LOCK \n** lock. Instead, it assumes a hot-journal exists and obtains an EXCLUSIVE\n** lock on the database file before attempting to roll it back. See function\n** PagerSharedLock() for more detail.\n**\n** Pager.eLock may only be set to UNKNOWN_LOCK when the pager is in \n** PAGER_OPEN state.\n*/\n#define UNKNOWN_LOCK                (EXCLUSIVE_LOCK+1)\n\n/*\n** A macro used for invoking the codec if there is one\n*/\n#ifdef SQLITE_HAS_CODEC\n# define CODEC1(P,D,N,X,E) \\\n    if( P->xCodec && P->xCodec(P->pCodec,D,N,X)==0 ){ E; }\n# define CODEC2(P,D,N,X,E,O) \\\n    if( P->xCodec==0 ){ O=(char*)D; }else \\\n    if( (O=(char*)(P->xCodec(P->pCodec,D,N,X)))==0 ){ E; }\n#else\n# define CODEC1(P,D,N,X,E)   /* NO-OP */\n# define CODEC2(P,D,N,X,E,O) O=(char*)D\n#endif\n\n/*\n** The maximum allowed sector size. 64KiB. If the xSectorsize() method \n** returns a value larger than this, then MAX_SECTOR_SIZE is used instead.\n** This could conceivably cause corruption following a power failure on\n** such a system. This is currently an undocumented limit.\n*/\n#define MAX_SECTOR_SIZE 0x10000\n\n/*\n** An instance of the following structure is allocated for each active\n** savepoint and statement transaction in the system. All such structures\n** are stored in the Pager.aSavepoint[] array, which is allocated and\n** resized using sqlite3Realloc().\n**\n** When a savepoint is created, the PagerSavepoint.iHdrOffset field is\n** set to 0. If a journal-header is written into the main journal while\n** the savepoint is active, then iHdrOffset is set to the byte offset \n** immediately following the last journal record written into the main\n** journal before the journal-header. This is required during savepoint\n** rollback (see pagerPlaybackSavepoint()).\n*/\ntypedef struct PagerSavepoint PagerSavepoint;\nstruct PagerSavepoint {\n  i64 iOffset;                 /* Starting offset in main journal */\n  i64 iHdrOffset;              /* See above */\n  Bitvec *pInSavepoint;        /* Set of pages in this savepoint */\n  Pgno nOrig;                  /* Original number of pages in file */\n  Pgno iSubRec;                /* Index of first record in sub-journal */\n#ifndef SQLITE_OMIT_WAL\n  u32 aWalData[WAL_SAVEPOINT_NDATA];        /* WAL savepoint context */\n#endif\n};\n\n/*\n** A open page cache is an instance of struct Pager. A description of\n** some of the more important member variables follows:\n**\n** eState\n**\n**   The current 'state' of the pager object. See the comment and state\n**   diagram above for a description of the pager state.\n**\n** eLock\n**\n**   For a real on-disk database, the current lock held on the database file -\n**   NO_LOCK, SHARED_LOCK, RESERVED_LOCK or EXCLUSIVE_LOCK.\n**\n**   For a temporary or in-memory database (neither of which require any\n**   locks), this variable is always set to EXCLUSIVE_LOCK. Since such\n**   databases always have Pager.exclusiveMode==1, this tricks the pager\n**   logic into thinking that it already has all the locks it will ever\n**   need (and no reason to release them).\n**\n**   In some (obscure) circumstances, this variable may also be set to\n**   UNKNOWN_LOCK. See the comment above the #define of UNKNOWN_LOCK for\n**   details.\n**\n** changeCountDone\n**\n**   This boolean variable is used to make sure that the change-counter \n**   (the 4-byte header field at byte offset 24 of the database file) is \n**   not updated more often than necessary. \n**\n**   It is set to true when the change-counter field is updated, which \n**   can only happen if an exclusive lock is held on the database file.\n**   It is cleared (set to false) whenever an exclusive lock is \n**   relinquished on the database file. Each time a transaction is committed,\n**   The changeCountDone flag is inspected. If it is true, the work of\n**   updating the change-counter is omitted for the current transaction.\n**\n**   This mechanism means that when running in exclusive mode, a connection \n**   need only update the change-counter once, for the first transaction\n**   committed.\n**\n** setMaster\n**\n**   When PagerCommitPhaseOne() is called to commit a transaction, it may\n**   (or may not) specify a master-journal name to be written into the \n**   journal file before it is synced to disk.\n**\n**   Whether or not a journal file contains a master-journal pointer affects \n**   the way in which the journal file is finalized after the transaction is \n**   committed or rolled back when running in \"journal_mode=PERSIST\" mode.\n**   If a journal file does not contain a master-journal pointer, it is\n**   finalized by overwriting the first journal header with zeroes. If\n**   it does contain a master-journal pointer the journal file is finalized \n**   by truncating it to zero bytes, just as if the connection were \n**   running in \"journal_mode=truncate\" mode.\n**\n**   Journal files that contain master journal pointers cannot be finalized\n**   simply by overwriting the first journal-header with zeroes, as the\n**   master journal pointer could interfere with hot-journal rollback of any\n**   subsequently interrupted transaction that reuses the journal file.\n**\n**   The flag is cleared as soon as the journal file is finalized (either\n**   by PagerCommitPhaseTwo or PagerRollback). If an IO error prevents the\n**   journal file from being successfully finalized, the setMaster flag\n**   is cleared anyway (and the pager will move to ERROR state).\n**\n** doNotSpill, doNotSyncSpill\n**\n**   These two boolean variables control the behaviour of cache-spills\n**   (calls made by the pcache module to the pagerStress() routine to\n**   write cached data to the file-system in order to free up memory).\n**\n**   When doNotSpill is non-zero, writing to the database from pagerStress()\n**   is disabled altogether. This is done in a very obscure case that\n**   comes up during savepoint rollback that requires the pcache module\n**   to allocate a new page to prevent the journal file from being written\n**   while it is being traversed by code in pager_playback().\n** \n**   If doNotSyncSpill is non-zero, writing to the database from pagerStress()\n**   is permitted, but syncing the journal file is not. This flag is set\n**   by sqlite3PagerWrite() when the file-system sector-size is larger than\n**   the database page-size in order to prevent a journal sync from happening \n**   in between the journalling of two pages on the same sector. \n**\n** subjInMemory\n**\n**   This is a boolean variable. If true, then any required sub-journal\n**   is opened as an in-memory journal file. If false, then in-memory\n**   sub-journals are only used for in-memory pager files.\n**\n**   This variable is updated by the upper layer each time a new \n**   write-transaction is opened.\n**\n** dbSize, dbOrigSize, dbFileSize\n**\n**   Variable dbSize is set to the number of pages in the database file.\n**   It is valid in PAGER_READER and higher states (all states except for\n**   OPEN and ERROR). \n**\n**   dbSize is set based on the size of the database file, which may be \n**   larger than the size of the database (the value stored at offset\n**   28 of the database header by the btree). If the size of the file\n**   is not an integer multiple of the page-size, the value stored in\n**   dbSize is rounded down (i.e. a 5KB file with 2K page-size has dbSize==2).\n**   Except, any file that is greater than 0 bytes in size is considered\n**   to have at least one page. (i.e. a 1KB file with 2K page-size leads\n**   to dbSize==1).\n**\n**   During a write-transaction, if pages with page-numbers greater than\n**   dbSize are modified in the cache, dbSize is updated accordingly.\n**   Similarly, if the database is truncated using PagerTruncateImage(), \n**   dbSize is updated.\n**\n**   Variables dbOrigSize and dbFileSize are valid in states \n**   PAGER_WRITER_LOCKED and higher. dbOrigSize is a copy of the dbSize\n**   variable at the start of the transaction. It is used during rollback,\n**   and to determine whether or not pages need to be journalled before\n**   being modified.\n**\n**   Throughout a write-transaction, dbFileSize contains the size of\n**   the file on disk in pages. It is set to a copy of dbSize when the\n**   write-transaction is first opened, and updated when VFS calls are made\n**   to write or truncate the database file on disk. \n**\n**   The only reason the dbFileSize variable is required is to suppress \n**   unnecessary calls to xTruncate() after committing a transaction. If, \n**   when a transaction is committed, the dbFileSize variable indicates \n**   that the database file is larger than the database image (Pager.dbSize), \n**   pager_truncate() is called. The pager_truncate() call uses xFilesize()\n**   to measure the database file on disk, and then truncates it if required.\n**   dbFileSize is not used when rolling back a transaction. In this case\n**   pager_truncate() is called unconditionally (which means there may be\n**   a call to xFilesize() that is not strictly required). In either case,\n**   pager_truncate() may cause the file to become smaller or larger.\n**\n** dbHintSize\n**\n**   The dbHintSize variable is used to limit the number of calls made to\n**   the VFS xFileControl(FCNTL_SIZE_HINT) method. \n**\n**   dbHintSize is set to a copy of the dbSize variable when a\n**   write-transaction is opened (at the same time as dbFileSize and\n**   dbOrigSize). If the xFileControl(FCNTL_SIZE_HINT) method is called,\n**   dbHintSize is increased to the number of pages that correspond to the\n**   size-hint passed to the method call. See pager_write_pagelist() for \n**   details.\n**\n** errCode\n**\n**   The Pager.errCode variable is only ever used in PAGER_ERROR state. It\n**   is set to zero in all other states. In PAGER_ERROR state, Pager.errCode \n**   is always set to SQLITE_FULL, SQLITE_IOERR or one of the SQLITE_IOERR_XXX \n**   sub-codes.\n*/\nstruct Pager {\n  sqlite3_vfs *pVfs;          /* OS functions to use for IO */\n  u8 exclusiveMode;           /* Boolean. True if locking_mode==EXCLUSIVE */\n  u8 journalMode;             /* One of the PAGER_JOURNALMODE_* values */\n  u8 useJournal;              /* Use a rollback journal on this file */\n  u8 noReadlock;              /* Do not bother to obtain readlocks */\n  u8 noSync;                  /* Do not sync the journal if true */\n  u8 fullSync;                /* Do extra syncs of the journal for robustness */\n  u8 ckptSyncFlags;           /* SYNC_NORMAL or SYNC_FULL for checkpoint */\n  u8 syncFlags;               /* SYNC_NORMAL or SYNC_FULL otherwise */\n  u8 tempFile;                /* zFilename is a temporary file */\n  u8 readOnly;                /* True for a read-only database */\n  u8 memDb;                   /* True to inhibit all file I/O */\n\n  /**************************************************************************\n  ** The following block contains those class members that change during\n  ** routine opertion.  Class members not in this block are either fixed\n  ** when the pager is first created or else only change when there is a\n  ** significant mode change (such as changing the page_size, locking_mode,\n  ** or the journal_mode).  From another view, these class members describe\n  ** the \"state\" of the pager, while other class members describe the\n  ** \"configuration\" of the pager.\n  */\n  u8 eState;                  /* Pager state (OPEN, READER, WRITER_LOCKED..) */\n  u8 eLock;                   /* Current lock held on database file */\n  u8 changeCountDone;         /* Set after incrementing the change-counter */\n  u8 setMaster;               /* True if a m-j name has been written to jrnl */\n  u8 doNotSpill;              /* Do not spill the cache when non-zero */\n  u8 doNotSyncSpill;          /* Do not do a spill that requires jrnl sync */\n  u8 subjInMemory;            /* True to use in-memory sub-journals */\n  Pgno dbSize;                /* Number of pages in the database */\n  Pgno dbOrigSize;            /* dbSize before the current transaction */\n  Pgno dbFileSize;            /* Number of pages in the database file */\n  Pgno dbHintSize;            /* Value passed to FCNTL_SIZE_HINT call */\n  int errCode;                /* One of several kinds of errors */\n  int nRec;                   /* Pages journalled since last j-header written */\n  u32 cksumInit;              /* Quasi-random value added to every checksum */\n  u32 nSubRec;                /* Number of records written to sub-journal */\n  Bitvec *pInJournal;         /* One bit for each page in the database file */\n  sqlite3_file *fd;           /* File descriptor for database */\n  sqlite3_file *jfd;          /* File descriptor for main journal */\n  sqlite3_file *sjfd;         /* File descriptor for sub-journal */\n  i64 journalOff;             /* Current write offset in the journal file */\n  i64 journalHdr;             /* Byte offset to previous journal header */\n  sqlite3_backup *pBackup;    /* Pointer to list of ongoing backup processes */\n  PagerSavepoint *aSavepoint; /* Array of active savepoints */\n  int nSavepoint;             /* Number of elements in aSavepoint[] */\n  char dbFileVers[16];        /* Changes whenever database file changes */\n  /*\n  ** End of the routinely-changing class members\n  ***************************************************************************/\n\n  u16 nExtra;                 /* Add this many bytes to each in-memory page */\n  i16 nReserve;               /* Number of unused bytes at end of each page */\n  u32 vfsFlags;               /* Flags for sqlite3_vfs.xOpen() */\n  u32 sectorSize;             /* Assumed sector size during rollback */\n  int pageSize;               /* Number of bytes in a page */\n  Pgno mxPgno;                /* Maximum allowed size of the database */\n  i64 journalSizeLimit;       /* Size limit for persistent journal files */\n  char *zFilename;            /* Name of the database file */\n  char *zJournal;             /* Name of the journal file */\n  int (*xBusyHandler)(void*); /* Function to call when busy */\n  void *pBusyHandlerArg;      /* Context argument for xBusyHandler */\n#ifdef SQLITE_TEST\n  int nHit, nMiss;            /* Cache hits and missing */\n  int nRead, nWrite;          /* Database pages read/written */\n#endif\n  void (*xReiniter)(DbPage*); /* Call this routine when reloading pages */\n#ifdef SQLITE_HAS_CODEC\n  void *(*xCodec)(void*,void*,Pgno,int); /* Routine for en/decoding data */\n  void (*xCodecSizeChng)(void*,int,int); /* Notify of page size changes */\n  void (*xCodecFree)(void*);             /* Destructor for the codec */\n  void *pCodec;               /* First argument to xCodec... methods */\n#endif\n  char *pTmpSpace;            /* Pager.pageSize bytes of space for tmp use */\n  PCache *pPCache;            /* Pointer to page cache object */\n#ifndef SQLITE_OMIT_WAL\n  Wal *pWal;                  /* Write-ahead log used by \"journal_mode=wal\" */\n  char *zWal;                 /* File name for write-ahead log */\n#endif\n};\n\n/*\n** The following global variables hold counters used for\n** testing purposes only.  These variables do not exist in\n** a non-testing build.  These variables are not thread-safe.\n*/\n#ifdef SQLITE_TEST\nSQLITE_API int sqlite3_pager_readdb_count = 0;    /* Number of full pages read from DB */\nSQLITE_API int sqlite3_pager_writedb_count = 0;   /* Number of full pages written to DB */\nSQLITE_API int sqlite3_pager_writej_count = 0;    /* Number of pages written to journal */\n# define PAGER_INCR(v)  v++\n#else\n# define PAGER_INCR(v)\n#endif\n\n\n\n/*\n** Journal files begin with the following magic string.  The data\n** was obtained from /dev/random.  It is used only as a sanity check.\n**\n** Since version 2.8.0, the journal format contains additional sanity\n** checking information.  If the power fails while the journal is being\n** written, semi-random garbage data might appear in the journal\n** file after power is restored.  If an attempt is then made\n** to roll the journal back, the database could be corrupted.  The additional\n** sanity checking data is an attempt to discover the garbage in the\n** journal and ignore it.\n**\n** The sanity checking information for the new journal format consists\n** of a 32-bit checksum on each page of data.  The checksum covers both\n** the page number and the pPager->pageSize bytes of data for the page.\n** This cksum is initialized to a 32-bit random value that appears in the\n** journal file right after the header.  The random initializer is important,\n** because garbage data that appears at the end of a journal is likely\n** data that was once in other files that have now been deleted.  If the\n** garbage data came from an obsolete journal file, the checksums might\n** be correct.  But by initializing the checksum to random value which\n** is different for every journal, we minimize that risk.\n*/\nstatic const unsigned char aJournalMagic[] = {\n  0xd9, 0xd5, 0x05, 0xf9, 0x20, 0xa1, 0x63, 0xd7,\n};\n\n/*\n** The size of the of each page record in the journal is given by\n** the following macro.\n*/\n#define JOURNAL_PG_SZ(pPager)  ((pPager->pageSize) + 8)\n\n/*\n** The journal header size for this pager. This is usually the same \n** size as a single disk sector. See also setSectorSize().\n*/\n#define JOURNAL_HDR_SZ(pPager) (pPager->sectorSize)\n\n/*\n** The macro MEMDB is true if we are dealing with an in-memory database.\n** We do this as a macro so that if the SQLITE_OMIT_MEMORYDB macro is set,\n** the value of MEMDB will be a constant and the compiler will optimize\n** out code that would never execute.\n*/\n#ifdef SQLITE_OMIT_MEMORYDB\n# define MEMDB 0\n#else\n# define MEMDB pPager->memDb\n#endif\n\n/*\n** The maximum legal page number is (2^31 - 1).\n*/\n#define PAGER_MAX_PGNO 2147483647\n\n/*\n** The argument to this macro is a file descriptor (type sqlite3_file*).\n** Return 0 if it is not open, or non-zero (but not 1) if it is.\n**\n** This is so that expressions can be written as:\n**\n**   if( isOpen(pPager->jfd) ){ ...\n**\n** instead of\n**\n**   if( pPager->jfd->pMethods ){ ...\n*/\n#define isOpen(pFd) ((pFd)->pMethods)\n\n/*\n** Return true if this pager uses a write-ahead log instead of the usual\n** rollback journal. Otherwise false.\n*/\n#ifndef SQLITE_OMIT_WAL\nstatic int pagerUseWal(Pager *pPager){\n  return (pPager->pWal!=0);\n}\n#else\n# define pagerUseWal(x) 0\n# define pagerRollbackWal(x) 0\n# define pagerWalFrames(v,w,x,y,z) 0\n# define pagerOpenWalIfPresent(z) SQLITE_OK\n# define pagerBeginReadTransaction(z) SQLITE_OK\n#endif\n\n#ifndef NDEBUG \n/*\n** Usage:\n**\n**   assert( assert_pager_state(pPager) );\n**\n** This function runs many asserts to try to find inconsistencies in\n** the internal state of the Pager object.\n*/\nstatic int assert_pager_state(Pager *p){\n  Pager *pPager = p;\n\n  /* State must be valid. */\n  assert( p->eState==PAGER_OPEN\n       || p->eState==PAGER_READER\n       || p->eState==PAGER_WRITER_LOCKED\n       || p->eState==PAGER_WRITER_CACHEMOD\n       || p->eState==PAGER_WRITER_DBMOD\n       || p->eState==PAGER_WRITER_FINISHED\n       || p->eState==PAGER_ERROR\n  );\n\n  /* Regardless of the current state, a temp-file connection always behaves\n  ** as if it has an exclusive lock on the database file. It never updates\n  ** the change-counter field, so the changeCountDone flag is always set.\n  */\n  assert( p->tempFile==0 || p->eLock==EXCLUSIVE_LOCK );\n  assert( p->tempFile==0 || pPager->changeCountDone );\n\n  /* If the useJournal flag is clear, the journal-mode must be \"OFF\". \n  ** And if the journal-mode is \"OFF\", the journal file must not be open.\n  */\n  assert( p->journalMode==PAGER_JOURNALMODE_OFF || p->useJournal );\n  assert( p->journalMode!=PAGER_JOURNALMODE_OFF || !isOpen(p->jfd) );\n\n  /* Check that MEMDB implies noSync. And an in-memory journal. Since \n  ** this means an in-memory pager performs no IO at all, it cannot encounter \n  ** either SQLITE_IOERR or SQLITE_FULL during rollback or while finalizing \n  ** a journal file. (although the in-memory journal implementation may \n  ** return SQLITE_IOERR_NOMEM while the journal file is being written). It \n  ** is therefore not possible for an in-memory pager to enter the ERROR \n  ** state.\n  */\n  if( MEMDB ){\n    assert( p->noSync );\n    assert( p->journalMode==PAGER_JOURNALMODE_OFF \n         || p->journalMode==PAGER_JOURNALMODE_MEMORY \n    );\n    assert( p->eState!=PAGER_ERROR && p->eState!=PAGER_OPEN );\n    assert( pagerUseWal(p)==0 );\n  }\n\n  /* If changeCountDone is set, a RESERVED lock or greater must be held\n  ** on the file.\n  */\n  assert( pPager->changeCountDone==0 || pPager->eLock>=RESERVED_LOCK );\n  assert( p->eLock!=PENDING_LOCK );\n\n  switch( p->eState ){\n    case PAGER_OPEN:\n      assert( !MEMDB );\n      assert( pPager->errCode==SQLITE_OK );\n      assert( sqlite3PcacheRefCount(pPager->pPCache)==0 || pPager->tempFile );\n      break;\n\n    case PAGER_READER:\n      assert( pPager->errCode==SQLITE_OK );\n      assert( p->eLock!=UNKNOWN_LOCK );\n      assert( p->eLock>=SHARED_LOCK || p->noReadlock );\n      break;\n\n    case PAGER_WRITER_LOCKED:\n      assert( p->eLock!=UNKNOWN_LOCK );\n      assert( pPager->errCode==SQLITE_OK );\n      if( !pagerUseWal(pPager) ){\n        assert( p->eLock>=RESERVED_LOCK );\n      }\n      assert( pPager->dbSize==pPager->dbOrigSize );\n      assert( pPager->dbOrigSize==pPager->dbFileSize );\n      assert( pPager->dbOrigSize==pPager->dbHintSize );\n      assert( pPager->setMaster==0 );\n      break;\n\n    case PAGER_WRITER_CACHEMOD:\n      assert( p->eLock!=UNKNOWN_LOCK );\n      assert( pPager->errCode==SQLITE_OK );\n      if( !pagerUseWal(pPager) ){\n        /* It is possible that if journal_mode=wal here that neither the\n        ** journal file nor the WAL file are open. This happens during\n        ** a rollback transaction that switches from journal_mode=off\n        ** to journal_mode=wal.\n        */\n        assert( p->eLock>=RESERVED_LOCK );\n        assert( isOpen(p->jfd) \n             || p->journalMode==PAGER_JOURNALMODE_OFF \n             || p->journalMode==PAGER_JOURNALMODE_WAL \n        );\n      }\n      assert( pPager->dbOrigSize==pPager->dbFileSize );\n      assert( pPager->dbOrigSize==pPager->dbHintSize );\n      break;\n\n    case PAGER_WRITER_DBMOD:\n      assert( p->eLock==EXCLUSIVE_LOCK );\n      assert( pPager->errCode==SQLITE_OK );\n      assert( !pagerUseWal(pPager) );\n      assert( p->eLock>=EXCLUSIVE_LOCK );\n      assert( isOpen(p->jfd) \n           || p->journalMode==PAGER_JOURNALMODE_OFF \n           || p->journalMode==PAGER_JOURNALMODE_WAL \n      );\n      assert( pPager->dbOrigSize<=pPager->dbHintSize );\n      break;\n\n    case PAGER_WRITER_FINISHED:\n      assert( p->eLock==EXCLUSIVE_LOCK );\n      assert( pPager->errCode==SQLITE_OK );\n      assert( !pagerUseWal(pPager) );\n      assert( isOpen(p->jfd) \n           || p->journalMode==PAGER_JOURNALMODE_OFF \n           || p->journalMode==PAGER_JOURNALMODE_WAL \n      );\n      break;\n\n    case PAGER_ERROR:\n      /* There must be at least one outstanding reference to the pager if\n      ** in ERROR state. Otherwise the pager should have already dropped\n      ** back to OPEN state.\n      */\n      assert( pPager->errCode!=SQLITE_OK );\n      assert( sqlite3PcacheRefCount(pPager->pPCache)>0 );\n      break;\n  }\n\n  return 1;\n}\n#endif /* ifndef NDEBUG */\n\n#ifdef SQLITE_DEBUG \n/*\n** Return a pointer to a human readable string in a static buffer\n** containing the state of the Pager object passed as an argument. This\n** is intended to be used within debuggers. For example, as an alternative\n** to \"print *pPager\" in gdb:\n**\n** (gdb) printf \"%s\", print_pager_state(pPager)\n*/\nstatic char *print_pager_state(Pager *p){\n  static char zRet[1024];\n\n  sqlite3_snprintf(1024, zRet,\n      \"Filename:      %s\\n\"\n      \"State:         %s errCode=%d\\n\"\n      \"Lock:          %s\\n\"\n      \"Locking mode:  locking_mode=%s\\n\"\n      \"Journal mode:  journal_mode=%s\\n\"\n      \"Backing store: tempFile=%d memDb=%d useJournal=%d\\n\"\n      \"Journal:       journalOff=%lld journalHdr=%lld\\n\"\n      \"Size:          dbsize=%d dbOrigSize=%d dbFileSize=%d\\n\"\n      , p->zFilename\n      , p->eState==PAGER_OPEN            ? \"OPEN\" :\n        p->eState==PAGER_READER          ? \"READER\" :\n        p->eState==PAGER_WRITER_LOCKED   ? \"WRITER_LOCKED\" :\n        p->eState==PAGER_WRITER_CACHEMOD ? \"WRITER_CACHEMOD\" :\n        p->eState==PAGER_WRITER_DBMOD    ? \"WRITER_DBMOD\" :\n        p->eState==PAGER_WRITER_FINISHED ? \"WRITER_FINISHED\" :\n        p->eState==PAGER_ERROR           ? \"ERROR\" : \"?error?\"\n      , (int)p->errCode\n      , p->eLock==NO_LOCK         ? \"NO_LOCK\" :\n        p->eLock==RESERVED_LOCK   ? \"RESERVED\" :\n        p->eLock==EXCLUSIVE_LOCK  ? \"EXCLUSIVE\" :\n        p->eLock==SHARED_LOCK     ? \"SHARED\" :\n        p->eLock==UNKNOWN_LOCK    ? \"UNKNOWN\" : \"?error?\"\n      , p->exclusiveMode ? \"exclusive\" : \"normal\"\n      , p->journalMode==PAGER_JOURNALMODE_MEMORY   ? \"memory\" :\n        p->journalMode==PAGER_JOURNALMODE_OFF      ? \"off\" :\n        p->journalMode==PAGER_JOURNALMODE_DELETE   ? \"delete\" :\n        p->journalMode==PAGER_JOURNALMODE_PERSIST  ? \"persist\" :\n        p->journalMode==PAGER_JOURNALMODE_TRUNCATE ? \"truncate\" :\n        p->journalMode==PAGER_JOURNALMODE_WAL      ? \"wal\" : \"?error?\"\n      , (int)p->tempFile, (int)p->memDb, (int)p->useJournal\n      , p->journalOff, p->journalHdr\n      , (int)p->dbSize, (int)p->dbOrigSize, (int)p->dbFileSize\n  );\n\n  return zRet;\n}\n#endif\n\n/*\n** Return true if it is necessary to write page *pPg into the sub-journal.\n** A page needs to be written into the sub-journal if there exists one\n** or more open savepoints for which:\n**\n**   * The page-number is less than or equal to PagerSavepoint.nOrig, and\n**   * The bit corresponding to the page-number is not set in\n**     PagerSavepoint.pInSavepoint.\n*/\nstatic int subjRequiresPage(PgHdr *pPg){\n  Pgno pgno = pPg->pgno;\n  Pager *pPager = pPg->pPager;\n  int i;\n  for(i=0; i<pPager->nSavepoint; i++){\n    PagerSavepoint *p = &pPager->aSavepoint[i];\n    if( p->nOrig>=pgno && 0==sqlite3BitvecTest(p->pInSavepoint, pgno) ){\n      return 1;\n    }\n  }\n  return 0;\n}\n\n/*\n** Return true if the page is already in the journal file.\n*/\nstatic int pageInJournal(PgHdr *pPg){\n  return sqlite3BitvecTest(pPg->pPager->pInJournal, pPg->pgno);\n}\n\n/*\n** Read a 32-bit integer from the given file descriptor.  Store the integer\n** that is read in *pRes.  Return SQLITE_OK if everything worked, or an\n** error code is something goes wrong.\n**\n** All values are stored on disk as big-endian.\n*/\nstatic int read32bits(sqlite3_file *fd, i64 offset, u32 *pRes){\n  unsigned char ac[4];\n  int rc = sqlite3OsRead(fd, ac, sizeof(ac), offset);\n  if( rc==SQLITE_OK ){\n    *pRes = sqlite3Get4byte(ac);\n  }\n  return rc;\n}\n\n/*\n** Write a 32-bit integer into a string buffer in big-endian byte order.\n*/\n#define put32bits(A,B)  sqlite3Put4byte((u8*)A,B)\n\n\n/*\n** Write a 32-bit integer into the given file descriptor.  Return SQLITE_OK\n** on success or an error code is something goes wrong.\n*/\nstatic int write32bits(sqlite3_file *fd, i64 offset, u32 val){\n  char ac[4];\n  put32bits(ac, val);\n  return sqlite3OsWrite(fd, ac, 4, offset);\n}\n\n/*\n** Unlock the database file to level eLock, which must be either NO_LOCK\n** or SHARED_LOCK. Regardless of whether or not the call to xUnlock()\n** succeeds, set the Pager.eLock variable to match the (attempted) new lock.\n**\n** Except, if Pager.eLock is set to UNKNOWN_LOCK when this function is\n** called, do not modify it. See the comment above the #define of \n** UNKNOWN_LOCK for an explanation of this.\n*/\nstatic int pagerUnlockDb(Pager *pPager, int eLock){\n  int rc = SQLITE_OK;\n\n  assert( !pPager->exclusiveMode || pPager->eLock==eLock );\n  assert( eLock==NO_LOCK || eLock==SHARED_LOCK );\n  assert( eLock!=NO_LOCK || pagerUseWal(pPager)==0 );\n  if( isOpen(pPager->fd) ){\n    assert( pPager->eLock>=eLock );\n    rc = sqlite3OsUnlock(pPager->fd, eLock);\n    if( pPager->eLock!=UNKNOWN_LOCK ){\n      pPager->eLock = (u8)eLock;\n    }\n    IOTRACE((\"UNLOCK %p %d\\n\", pPager, eLock))\n  }\n  return rc;\n}\n\n/*\n** Lock the database file to level eLock, which must be either SHARED_LOCK,\n** RESERVED_LOCK or EXCLUSIVE_LOCK. If the caller is successful, set the\n** Pager.eLock variable to the new locking state. \n**\n** Except, if Pager.eLock is set to UNKNOWN_LOCK when this function is \n** called, do not modify it unless the new locking state is EXCLUSIVE_LOCK. \n** See the comment above the #define of UNKNOWN_LOCK for an explanation \n** of this.\n*/\nstatic int pagerLockDb(Pager *pPager, int eLock){\n  int rc = SQLITE_OK;\n\n  assert( eLock==SHARED_LOCK || eLock==RESERVED_LOCK || eLock==EXCLUSIVE_LOCK );\n  if( pPager->eLock<eLock || pPager->eLock==UNKNOWN_LOCK ){\n    rc = sqlite3OsLock(pPager->fd, eLock);\n    if( rc==SQLITE_OK && (pPager->eLock!=UNKNOWN_LOCK||eLock==EXCLUSIVE_LOCK) ){\n      pPager->eLock = (u8)eLock;\n      IOTRACE((\"LOCK %p %d\\n\", pPager, eLock))\n    }\n  }\n  return rc;\n}\n\n/*\n** This function determines whether or not the atomic-write optimization\n** can be used with this pager. The optimization can be used if:\n**\n**  (a) the value returned by OsDeviceCharacteristics() indicates that\n**      a database page may be written atomically, and\n**  (b) the value returned by OsSectorSize() is less than or equal\n**      to the page size.\n**\n** The optimization is also always enabled for temporary files. It is\n** an error to call this function if pPager is opened on an in-memory\n** database.\n**\n** If the optimization cannot be used, 0 is returned. If it can be used,\n** then the value returned is the size of the journal file when it\n** contains rollback data for exactly one page.\n*/\n#ifdef SQLITE_ENABLE_ATOMIC_WRITE\nstatic int jrnlBufferSize(Pager *pPager){\n  assert( !MEMDB );\n  if( !pPager->tempFile ){\n    int dc;                           /* Device characteristics */\n    int nSector;                      /* Sector size */\n    int szPage;                       /* Page size */\n\n    assert( isOpen(pPager->fd) );\n    dc = sqlite3OsDeviceCharacteristics(pPager->fd);\n    nSector = pPager->sectorSize;\n    szPage = pPager->pageSize;\n\n    assert(SQLITE_IOCAP_ATOMIC512==(512>>8));\n    assert(SQLITE_IOCAP_ATOMIC64K==(65536>>8));\n    if( 0==(dc&(SQLITE_IOCAP_ATOMIC|(szPage>>8)) || nSector>szPage) ){\n      return 0;\n    }\n  }\n\n  return JOURNAL_HDR_SZ(pPager) + JOURNAL_PG_SZ(pPager);\n}\n#endif\n\n/*\n** If SQLITE_CHECK_PAGES is defined then we do some sanity checking\n** on the cache using a hash function.  This is used for testing\n** and debugging only.\n*/\n#ifdef SQLITE_CHECK_PAGES\n/*\n** Return a 32-bit hash of the page data for pPage.\n*/\nstatic u32 pager_datahash(int nByte, unsigned char *pData){\n  u32 hash = 0;\n  int i;\n  for(i=0; i<nByte; i++){\n    hash = (hash*1039) + pData[i];\n  }\n  return hash;\n}\nstatic u32 pager_pagehash(PgHdr *pPage){\n  return pager_datahash(pPage->pPager->pageSize, (unsigned char *)pPage->pData);\n}\nstatic void pager_set_pagehash(PgHdr *pPage){\n  pPage->pageHash = pager_pagehash(pPage);\n}\n\n/*\n** The CHECK_PAGE macro takes a PgHdr* as an argument. If SQLITE_CHECK_PAGES\n** is defined, and NDEBUG is not defined, an assert() statement checks\n** that the page is either dirty or still matches the calculated page-hash.\n*/\n#define CHECK_PAGE(x) checkPage(x)\nstatic void checkPage(PgHdr *pPg){\n  Pager *pPager = pPg->pPager;\n  assert( pPager->eState!=PAGER_ERROR );\n  assert( (pPg->flags&PGHDR_DIRTY) || pPg->pageHash==pager_pagehash(pPg) );\n}\n\n#else\n#define pager_datahash(X,Y)  0\n#define pager_pagehash(X)  0\n#define pager_set_pagehash(X)\n#define CHECK_PAGE(x)\n#endif  /* SQLITE_CHECK_PAGES */\n\n/*\n** When this is called the journal file for pager pPager must be open.\n** This function attempts to read a master journal file name from the \n** end of the file and, if successful, copies it into memory supplied \n** by the caller. See comments above writeMasterJournal() for the format\n** used to store a master journal file name at the end of a journal file.\n**\n** zMaster must point to a buffer of at least nMaster bytes allocated by\n** the caller. This should be sqlite3_vfs.mxPathname+1 (to ensure there is\n** enough space to write the master journal name). If the master journal\n** name in the journal is longer than nMaster bytes (including a\n** nul-terminator), then this is handled as if no master journal name\n** were present in the journal.\n**\n** If a master journal file name is present at the end of the journal\n** file, then it is copied into the buffer pointed to by zMaster. A\n** nul-terminator byte is appended to the buffer following the master\n** journal file name.\n**\n** If it is determined that no master journal file name is present \n** zMaster[0] is set to 0 and SQLITE_OK returned.\n**\n** If an error occurs while reading from the journal file, an SQLite\n** error code is returned.\n*/\nstatic int readMasterJournal(sqlite3_file *pJrnl, char *zMaster, u32 nMaster){\n  int rc;                    /* Return code */\n  u32 len;                   /* Length in bytes of master journal name */\n  i64 szJ;                   /* Total size in bytes of journal file pJrnl */\n  u32 cksum;                 /* MJ checksum value read from journal */\n  u32 u;                     /* Unsigned loop counter */\n  unsigned char aMagic[8];   /* A buffer to hold the magic header */\n  zMaster[0] = '\\0';\n\n  if( SQLITE_OK!=(rc = sqlite3OsFileSize(pJrnl, &szJ))\n   || szJ<16\n   || SQLITE_OK!=(rc = read32bits(pJrnl, szJ-16, &len))\n   || len>=nMaster \n   || SQLITE_OK!=(rc = read32bits(pJrnl, szJ-12, &cksum))\n   || SQLITE_OK!=(rc = sqlite3OsRead(pJrnl, aMagic, 8, szJ-8))\n   || memcmp(aMagic, aJournalMagic, 8)\n   || SQLITE_OK!=(rc = sqlite3OsRead(pJrnl, zMaster, len, szJ-16-len))\n  ){\n    return rc;\n  }\n\n  /* See if the checksum matches the master journal name */\n  for(u=0; u<len; u++){\n    cksum -= zMaster[u];\n  }\n  if( cksum ){\n    /* If the checksum doesn't add up, then one or more of the disk sectors\n    ** containing the master journal filename is corrupted. This means\n    ** definitely roll back, so just return SQLITE_OK and report a (nul)\n    ** master-journal filename.\n    */\n    len = 0;\n  }\n  zMaster[len] = '\\0';\n   \n  return SQLITE_OK;\n}\n\n/*\n** Return the offset of the sector boundary at or immediately \n** following the value in pPager->journalOff, assuming a sector \n** size of pPager->sectorSize bytes.\n**\n** i.e for a sector size of 512:\n**\n**   Pager.journalOff          Return value\n**   ---------------------------------------\n**   0                         0\n**   512                       512\n**   100                       512\n**   2000                      2048\n** \n*/\nstatic i64 journalHdrOffset(Pager *pPager){\n  i64 offset = 0;\n  i64 c = pPager->journalOff;\n  if( c ){\n    offset = ((c-1)/JOURNAL_HDR_SZ(pPager) + 1) * JOURNAL_HDR_SZ(pPager);\n  }\n  assert( offset%JOURNAL_HDR_SZ(pPager)==0 );\n  assert( offset>=c );\n  assert( (offset-c)<JOURNAL_HDR_SZ(pPager) );\n  return offset;\n}\n\n/*\n** The journal file must be open when this function is called.\n**\n** This function is a no-op if the journal file has not been written to\n** within the current transaction (i.e. if Pager.journalOff==0).\n**\n** If doTruncate is non-zero or the Pager.journalSizeLimit variable is\n** set to 0, then truncate the journal file to zero bytes in size. Otherwise,\n** zero the 28-byte header at the start of the journal file. In either case, \n** if the pager is not in no-sync mode, sync the journal file immediately \n** after writing or truncating it.\n**\n** If Pager.journalSizeLimit is set to a positive, non-zero value, and\n** following the truncation or zeroing described above the size of the \n** journal file in bytes is larger than this value, then truncate the\n** journal file to Pager.journalSizeLimit bytes. The journal file does\n** not need to be synced following this operation.\n**\n** If an IO error occurs, abandon processing and return the IO error code.\n** Otherwise, return SQLITE_OK.\n*/\nstatic int zeroJournalHdr(Pager *pPager, int doTruncate){\n  int rc = SQLITE_OK;                               /* Return code */\n  assert( isOpen(pPager->jfd) );\n  if( pPager->journalOff ){\n    const i64 iLimit = pPager->journalSizeLimit;    /* Local cache of jsl */\n\n    IOTRACE((\"JZEROHDR %p\\n\", pPager))\n    if( doTruncate || iLimit==0 ){\n      rc = sqlite3OsTruncate(pPager->jfd, 0);\n    }else{\n      static const char zeroHdr[28] = {0};\n      rc = sqlite3OsWrite(pPager->jfd, zeroHdr, sizeof(zeroHdr), 0);\n    }\n    if( rc==SQLITE_OK && !pPager->noSync ){\n      rc = sqlite3OsSync(pPager->jfd, SQLITE_SYNC_DATAONLY|pPager->syncFlags);\n    }\n\n    /* At this point the transaction is committed but the write lock \n    ** is still held on the file. If there is a size limit configured for \n    ** the persistent journal and the journal file currently consumes more\n    ** space than that limit allows for, truncate it now. There is no need\n    ** to sync the file following this operation.\n    */\n    if( rc==SQLITE_OK && iLimit>0 ){\n      i64 sz;\n      rc = sqlite3OsFileSize(pPager->jfd, &sz);\n      if( rc==SQLITE_OK && sz>iLimit ){\n        rc = sqlite3OsTruncate(pPager->jfd, iLimit);\n      }\n    }\n  }\n  return rc;\n}\n\n/*\n** The journal file must be open when this routine is called. A journal\n** header (JOURNAL_HDR_SZ bytes) is written into the journal file at the\n** current location.\n**\n** The format for the journal header is as follows:\n** - 8 bytes: Magic identifying journal format.\n** - 4 bytes: Number of records in journal, or -1 no-sync mode is on.\n** - 4 bytes: Random number used for page hash.\n** - 4 bytes: Initial database page count.\n** - 4 bytes: Sector size used by the process that wrote this journal.\n** - 4 bytes: Database page size.\n** \n** Followed by (JOURNAL_HDR_SZ - 28) bytes of unused space.\n*/\nstatic int writeJournalHdr(Pager *pPager){\n  int rc = SQLITE_OK;                 /* Return code */\n  char *zHeader = pPager->pTmpSpace;  /* Temporary space used to build header */\n  u32 nHeader = (u32)pPager->pageSize;/* Size of buffer pointed to by zHeader */\n  u32 nWrite;                         /* Bytes of header sector written */\n  int ii;                             /* Loop counter */\n\n  assert( isOpen(pPager->jfd) );      /* Journal file must be open. */\n\n  if( nHeader>JOURNAL_HDR_SZ(pPager) ){\n    nHeader = JOURNAL_HDR_SZ(pPager);\n  }\n\n  /* If there are active savepoints and any of them were created \n  ** since the most recent journal header was written, update the \n  ** PagerSavepoint.iHdrOffset fields now.\n  */\n  for(ii=0; ii<pPager->nSavepoint; ii++){\n    if( pPager->aSavepoint[ii].iHdrOffset==0 ){\n      pPager->aSavepoint[ii].iHdrOffset = pPager->journalOff;\n    }\n  }\n\n  pPager->journalHdr = pPager->journalOff = journalHdrOffset(pPager);\n\n  /* \n  ** Write the nRec Field - the number of page records that follow this\n  ** journal header. Normally, zero is written to this value at this time.\n  ** After the records are added to the journal (and the journal synced, \n  ** if in full-sync mode), the zero is overwritten with the true number\n  ** of records (see syncJournal()).\n  **\n  ** A faster alternative is to write 0xFFFFFFFF to the nRec field. When\n  ** reading the journal this value tells SQLite to assume that the\n  ** rest of the journal file contains valid page records. This assumption\n  ** is dangerous, as if a failure occurred whilst writing to the journal\n  ** file it may contain some garbage data. There are two scenarios\n  ** where this risk can be ignored:\n  **\n  **   * When the pager is in no-sync mode. Corruption can follow a\n  **     power failure in this case anyway.\n  **\n  **   * When the SQLITE_IOCAP_SAFE_APPEND flag is set. This guarantees\n  **     that garbage data is never appended to the journal file.\n  */\n  assert( isOpen(pPager->fd) || pPager->noSync );\n  if( pPager->noSync || (pPager->journalMode==PAGER_JOURNALMODE_MEMORY)\n   || (sqlite3OsDeviceCharacteristics(pPager->fd)&SQLITE_IOCAP_SAFE_APPEND) \n  ){\n    memcpy(zHeader, aJournalMagic, sizeof(aJournalMagic));\n    put32bits(&zHeader[sizeof(aJournalMagic)], 0xffffffff);\n  }else{\n    memset(zHeader, 0, sizeof(aJournalMagic)+4);\n  }\n\n  /* The random check-hash initialiser */ \n  sqlite3_randomness(sizeof(pPager->cksumInit), &pPager->cksumInit);\n  put32bits(&zHeader[sizeof(aJournalMagic)+4], pPager->cksumInit);\n  /* The initial database size */\n  put32bits(&zHeader[sizeof(aJournalMagic)+8], pPager->dbOrigSize);\n  /* The assumed sector size for this process */\n  put32bits(&zHeader[sizeof(aJournalMagic)+12], pPager->sectorSize);\n\n  /* The page size */\n  put32bits(&zHeader[sizeof(aJournalMagic)+16], pPager->pageSize);\n\n  /* Initializing the tail of the buffer is not necessary.  Everything\n  ** works find if the following memset() is omitted.  But initializing\n  ** the memory prevents valgrind from complaining, so we are willing to\n  ** take the performance hit.\n  */\n  memset(&zHeader[sizeof(aJournalMagic)+20], 0,\n         nHeader-(sizeof(aJournalMagic)+20));\n\n  /* In theory, it is only necessary to write the 28 bytes that the \n  ** journal header consumes to the journal file here. Then increment the \n  ** Pager.journalOff variable by JOURNAL_HDR_SZ so that the next \n  ** record is written to the following sector (leaving a gap in the file\n  ** that will be implicitly filled in by the OS).\n  **\n  ** However it has been discovered that on some systems this pattern can \n  ** be significantly slower than contiguously writing data to the file,\n  ** even if that means explicitly writing data to the block of \n  ** (JOURNAL_HDR_SZ - 28) bytes that will not be used. So that is what\n  ** is done. \n  **\n  ** The loop is required here in case the sector-size is larger than the \n  ** database page size. Since the zHeader buffer is only Pager.pageSize\n  ** bytes in size, more than one call to sqlite3OsWrite() may be required\n  ** to populate the entire journal header sector.\n  */ \n  for(nWrite=0; rc==SQLITE_OK&&nWrite<JOURNAL_HDR_SZ(pPager); nWrite+=nHeader){\n    IOTRACE((\"JHDR %p %lld %d\\n\", pPager, pPager->journalHdr, nHeader))\n    rc = sqlite3OsWrite(pPager->jfd, zHeader, nHeader, pPager->journalOff);\n    assert( pPager->journalHdr <= pPager->journalOff );\n    pPager->journalOff += nHeader;\n  }\n\n  return rc;\n}\n\n/*\n** The journal file must be open when this is called. A journal header file\n** (JOURNAL_HDR_SZ bytes) is read from the current location in the journal\n** file. The current location in the journal file is given by\n** pPager->journalOff. See comments above function writeJournalHdr() for\n** a description of the journal header format.\n**\n** If the header is read successfully, *pNRec is set to the number of\n** page records following this header and *pDbSize is set to the size of the\n** database before the transaction began, in pages. Also, pPager->cksumInit\n** is set to the value read from the journal header. SQLITE_OK is returned\n** in this case.\n**\n** If the journal header file appears to be corrupted, SQLITE_DONE is\n** returned and *pNRec and *PDbSize are undefined.  If JOURNAL_HDR_SZ bytes\n** cannot be read from the journal file an error code is returned.\n*/\nstatic int readJournalHdr(\n  Pager *pPager,               /* Pager object */\n  int isHot,\n  i64 journalSize,             /* Size of the open journal file in bytes */\n  u32 *pNRec,                  /* OUT: Value read from the nRec field */\n  u32 *pDbSize                 /* OUT: Value of original database size field */\n){\n  int rc;                      /* Return code */\n  unsigned char aMagic[8];     /* A buffer to hold the magic header */\n  i64 iHdrOff;                 /* Offset of journal header being read */\n\n  assert( isOpen(pPager->jfd) );      /* Journal file must be open. */\n\n  /* Advance Pager.journalOff to the start of the next sector. If the\n  ** journal file is too small for there to be a header stored at this\n  ** point, return SQLITE_DONE.\n  */\n  pPager->journalOff = journalHdrOffset(pPager);\n  if( pPager->journalOff+JOURNAL_HDR_SZ(pPager) > journalSize ){\n    return SQLITE_DONE;\n  }\n  iHdrOff = pPager->journalOff;\n\n  /* Read in the first 8 bytes of the journal header. If they do not match\n  ** the  magic string found at the start of each journal header, return\n  ** SQLITE_DONE. If an IO error occurs, return an error code. Otherwise,\n  ** proceed.\n  */\n  if( isHot || iHdrOff!=pPager->journalHdr ){\n    rc = sqlite3OsRead(pPager->jfd, aMagic, sizeof(aMagic), iHdrOff);\n    if( rc ){\n      return rc;\n    }\n    if( memcmp(aMagic, aJournalMagic, sizeof(aMagic))!=0 ){\n      return SQLITE_DONE;\n    }\n  }\n\n  /* Read the first three 32-bit fields of the journal header: The nRec\n  ** field, the checksum-initializer and the database size at the start\n  ** of the transaction. Return an error code if anything goes wrong.\n  */\n  if( SQLITE_OK!=(rc = read32bits(pPager->jfd, iHdrOff+8, pNRec))\n   || SQLITE_OK!=(rc = read32bits(pPager->jfd, iHdrOff+12, &pPager->cksumInit))\n   || SQLITE_OK!=(rc = read32bits(pPager->jfd, iHdrOff+16, pDbSize))\n  ){\n    return rc;\n  }\n\n  if( pPager->journalOff==0 ){\n    u32 iPageSize;               /* Page-size field of journal header */\n    u32 iSectorSize;             /* Sector-size field of journal header */\n\n    /* Read the page-size and sector-size journal header fields. */\n    if( SQLITE_OK!=(rc = read32bits(pPager->jfd, iHdrOff+20, &iSectorSize))\n     || SQLITE_OK!=(rc = read32bits(pPager->jfd, iHdrOff+24, &iPageSize))\n    ){\n      return rc;\n    }\n\n    /* Versions of SQLite prior to 3.5.8 set the page-size field of the\n    ** journal header to zero. In this case, assume that the Pager.pageSize\n    ** variable is already set to the correct page size.\n    */\n    if( iPageSize==0 ){\n      iPageSize = pPager->pageSize;\n    }\n\n    /* Check that the values read from the page-size and sector-size fields\n    ** are within range. To be 'in range', both values need to be a power\n    ** of two greater than or equal to 512 or 32, and not greater than their \n    ** respective compile time maximum limits.\n    */\n    if( iPageSize<512                  || iSectorSize<32\n     || iPageSize>SQLITE_MAX_PAGE_SIZE || iSectorSize>MAX_SECTOR_SIZE\n     || ((iPageSize-1)&iPageSize)!=0   || ((iSectorSize-1)&iSectorSize)!=0 \n    ){\n      /* If the either the page-size or sector-size in the journal-header is \n      ** invalid, then the process that wrote the journal-header must have \n      ** crashed before the header was synced. In this case stop reading \n      ** the journal file here.\n      */\n      return SQLITE_DONE;\n    }\n\n    /* Update the page-size to match the value read from the journal. \n    ** Use a testcase() macro to make sure that malloc failure within \n    ** PagerSetPagesize() is tested.\n    */\n    rc = sqlite3PagerSetPagesize(pPager, &iPageSize, -1);\n    testcase( rc!=SQLITE_OK );\n\n    /* Update the assumed sector-size to match the value used by \n    ** the process that created this journal. If this journal was\n    ** created by a process other than this one, then this routine\n    ** is being called from within pager_playback(). The local value\n    ** of Pager.sectorSize is restored at the end of that routine.\n    */\n    pPager->sectorSize = iSectorSize;\n  }\n\n  pPager->journalOff += JOURNAL_HDR_SZ(pPager);\n  return rc;\n}\n\n\n/*\n** Write the supplied master journal name into the journal file for pager\n** pPager at the current location. The master journal name must be the last\n** thing written to a journal file. If the pager is in full-sync mode, the\n** journal file descriptor is advanced to the next sector boundary before\n** anything is written. The format is:\n**\n**   + 4 bytes: PAGER_MJ_PGNO.\n**   + N bytes: Master journal filename in utf-8.\n**   + 4 bytes: N (length of master journal name in bytes, no nul-terminator).\n**   + 4 bytes: Master journal name checksum.\n**   + 8 bytes: aJournalMagic[].\n**\n** The master journal page checksum is the sum of the bytes in the master\n** journal name, where each byte is interpreted as a signed 8-bit integer.\n**\n** If zMaster is a NULL pointer (occurs for a single database transaction), \n** this call is a no-op.\n*/\nstatic int writeMasterJournal(Pager *pPager, const char *zMaster){\n  int rc;                          /* Return code */\n  int nMaster;                     /* Length of string zMaster */\n  i64 iHdrOff;                     /* Offset of header in journal file */\n  i64 jrnlSize;                    /* Size of journal file on disk */\n  u32 cksum = 0;                   /* Checksum of string zMaster */\n\n  assert( pPager->setMaster==0 );\n  assert( !pagerUseWal(pPager) );\n\n  if( !zMaster \n   || pPager->journalMode==PAGER_JOURNALMODE_MEMORY \n   || pPager->journalMode==PAGER_JOURNALMODE_OFF \n  ){\n    return SQLITE_OK;\n  }\n  pPager->setMaster = 1;\n  assert( isOpen(pPager->jfd) );\n  assert( pPager->journalHdr <= pPager->journalOff );\n\n  /* Calculate the length in bytes and the checksum of zMaster */\n  for(nMaster=0; zMaster[nMaster]; nMaster++){\n    cksum += zMaster[nMaster];\n  }\n\n  /* If in full-sync mode, advance to the next disk sector before writing\n  ** the master journal name. This is in case the previous page written to\n  ** the journal has already been synced.\n  */\n  if( pPager->fullSync ){\n    pPager->journalOff = journalHdrOffset(pPager);\n  }\n  iHdrOff = pPager->journalOff;\n\n  /* Write the master journal data to the end of the journal file. If\n  ** an error occurs, return the error code to the caller.\n  */\n  if( (0 != (rc = write32bits(pPager->jfd, iHdrOff, PAGER_MJ_PGNO(pPager))))\n   || (0 != (rc = sqlite3OsWrite(pPager->jfd, zMaster, nMaster, iHdrOff+4)))\n   || (0 != (rc = write32bits(pPager->jfd, iHdrOff+4+nMaster, nMaster)))\n   || (0 != (rc = write32bits(pPager->jfd, iHdrOff+4+nMaster+4, cksum)))\n   || (0 != (rc = sqlite3OsWrite(pPager->jfd, aJournalMagic, 8, iHdrOff+4+nMaster+8)))\n  ){\n    return rc;\n  }\n  pPager->journalOff += (nMaster+20);\n\n  /* If the pager is in peristent-journal mode, then the physical \n  ** journal-file may extend past the end of the master-journal name\n  ** and 8 bytes of magic data just written to the file. This is \n  ** dangerous because the code to rollback a hot-journal file\n  ** will not be able to find the master-journal name to determine \n  ** whether or not the journal is hot. \n  **\n  ** Easiest thing to do in this scenario is to truncate the journal \n  ** file to the required size.\n  */ \n  if( SQLITE_OK==(rc = sqlite3OsFileSize(pPager->jfd, &jrnlSize))\n   && jrnlSize>pPager->journalOff\n  ){\n    rc = sqlite3OsTruncate(pPager->jfd, pPager->journalOff);\n  }\n  return rc;\n}\n\n/*\n** Find a page in the hash table given its page number. Return\n** a pointer to the page or NULL if the requested page is not \n** already in memory.\n*/\nstatic PgHdr *pager_lookup(Pager *pPager, Pgno pgno){\n  PgHdr *p;                         /* Return value */\n\n  /* It is not possible for a call to PcacheFetch() with createFlag==0 to\n  ** fail, since no attempt to allocate dynamic memory will be made.\n  */\n  (void)sqlite3PcacheFetch(pPager->pPCache, pgno, 0, &p);\n  return p;\n}\n\n/*\n** Discard the entire contents of the in-memory page-cache.\n*/\nstatic void pager_reset(Pager *pPager){\n  sqlite3BackupRestart(pPager->pBackup);\n  sqlite3PcacheClear(pPager->pPCache);\n}\n\n/*\n** Free all structures in the Pager.aSavepoint[] array and set both\n** Pager.aSavepoint and Pager.nSavepoint to zero. Close the sub-journal\n** if it is open and the pager is not in exclusive mode.\n*/\nstatic void releaseAllSavepoints(Pager *pPager){\n  int ii;               /* Iterator for looping through Pager.aSavepoint */\n  for(ii=0; ii<pPager->nSavepoint; ii++){\n    sqlite3BitvecDestroy(pPager->aSavepoint[ii].pInSavepoint);\n  }\n  if( !pPager->exclusiveMode || sqlite3IsMemJournal(pPager->sjfd) ){\n    sqlite3OsClose(pPager->sjfd);\n  }\n  sqlite3_free(pPager->aSavepoint);\n  pPager->aSavepoint = 0;\n  pPager->nSavepoint = 0;\n  pPager->nSubRec = 0;\n}\n\n/*\n** Set the bit number pgno in the PagerSavepoint.pInSavepoint \n** bitvecs of all open savepoints. Return SQLITE_OK if successful\n** or SQLITE_NOMEM if a malloc failure occurs.\n*/\nstatic int addToSavepointBitvecs(Pager *pPager, Pgno pgno){\n  int ii;                   /* Loop counter */\n  int rc = SQLITE_OK;       /* Result code */\n\n  for(ii=0; ii<pPager->nSavepoint; ii++){\n    PagerSavepoint *p = &pPager->aSavepoint[ii];\n    if( pgno<=p->nOrig ){\n      rc |= sqlite3BitvecSet(p->pInSavepoint, pgno);\n      testcase( rc==SQLITE_NOMEM );\n      assert( rc==SQLITE_OK || rc==SQLITE_NOMEM );\n    }\n  }\n  return rc;\n}\n\n/*\n** This function is a no-op if the pager is in exclusive mode and not\n** in the ERROR state. Otherwise, it switches the pager to PAGER_OPEN\n** state.\n**\n** If the pager is not in exclusive-access mode, the database file is\n** completely unlocked. If the file is unlocked and the file-system does\n** not exhibit the UNDELETABLE_WHEN_OPEN property, the journal file is\n** closed (if it is open).\n**\n** If the pager is in ERROR state when this function is called, the \n** contents of the pager cache are discarded before switching back to \n** the OPEN state. Regardless of whether the pager is in exclusive-mode\n** or not, any journal file left in the file-system will be treated\n** as a hot-journal and rolled back the next time a read-transaction\n** is opened (by this or by any other connection).\n*/\nstatic void pager_unlock(Pager *pPager){\n\n  assert( pPager->eState==PAGER_READER \n       || pPager->eState==PAGER_OPEN \n       || pPager->eState==PAGER_ERROR \n  );\n\n  sqlite3BitvecDestroy(pPager->pInJournal);\n  pPager->pInJournal = 0;\n  releaseAllSavepoints(pPager);\n\n  if( pagerUseWal(pPager) ){\n    assert( !isOpen(pPager->jfd) );\n    sqlite3WalEndReadTransaction(pPager->pWal);\n    pPager->eState = PAGER_OPEN;\n  }else if( !pPager->exclusiveMode ){\n    int rc;                       /* Error code returned by pagerUnlockDb() */\n    int iDc = isOpen(pPager->fd)?sqlite3OsDeviceCharacteristics(pPager->fd):0;\n\n    /* If the operating system support deletion of open files, then\n    ** close the journal file when dropping the database lock.  Otherwise\n    ** another connection with journal_mode=delete might delete the file\n    ** out from under us.\n    */\n    assert( (PAGER_JOURNALMODE_MEMORY   & 5)!=1 );\n    assert( (PAGER_JOURNALMODE_OFF      & 5)!=1 );\n    assert( (PAGER_JOURNALMODE_WAL      & 5)!=1 );\n    assert( (PAGER_JOURNALMODE_DELETE   & 5)!=1 );\n    assert( (PAGER_JOURNALMODE_TRUNCATE & 5)==1 );\n    assert( (PAGER_JOURNALMODE_PERSIST  & 5)==1 );\n    if( 0==(iDc & SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN)\n     || 1!=(pPager->journalMode & 5)\n    ){\n      sqlite3OsClose(pPager->jfd);\n    }\n\n    /* If the pager is in the ERROR state and the call to unlock the database\n    ** file fails, set the current lock to UNKNOWN_LOCK. See the comment\n    ** above the #define for UNKNOWN_LOCK for an explanation of why this\n    ** is necessary.\n    */\n    rc = pagerUnlockDb(pPager, NO_LOCK);\n    if( rc!=SQLITE_OK && pPager->eState==PAGER_ERROR ){\n      pPager->eLock = UNKNOWN_LOCK;\n    }\n\n    /* The pager state may be changed from PAGER_ERROR to PAGER_OPEN here\n    ** without clearing the error code. This is intentional - the error\n    ** code is cleared and the cache reset in the block below.\n    */\n    assert( pPager->errCode || pPager->eState!=PAGER_ERROR );\n    pPager->changeCountDone = 0;\n    pPager->eState = PAGER_OPEN;\n  }\n\n  /* If Pager.errCode is set, the contents of the pager cache cannot be\n  ** trusted. Now that there are no outstanding references to the pager,\n  ** it can safely move back to PAGER_OPEN state. This happens in both\n  ** normal and exclusive-locking mode.\n  */\n  if( pPager->errCode ){\n    assert( !MEMDB );\n    pager_reset(pPager);\n    pPager->changeCountDone = pPager->tempFile;\n    pPager->eState = PAGER_OPEN;\n    pPager->errCode = SQLITE_OK;\n  }\n\n  pPager->journalOff = 0;\n  pPager->journalHdr = 0;\n  pPager->setMaster = 0;\n}\n\n/*\n** This function is called whenever an IOERR or FULL error that requires\n** the pager to transition into the ERROR state may ahve occurred.\n** The first argument is a pointer to the pager structure, the second \n** the error-code about to be returned by a pager API function. The \n** value returned is a copy of the second argument to this function. \n**\n** If the second argument is SQLITE_FULL, SQLITE_IOERR or one of the\n** IOERR sub-codes, the pager enters the ERROR state and the error code\n** is stored in Pager.errCode. While the pager remains in the ERROR state,\n** all major API calls on the Pager will immediately return Pager.errCode.\n**\n** The ERROR state indicates that the contents of the pager-cache \n** cannot be trusted. This state can be cleared by completely discarding \n** the contents of the pager-cache. If a transaction was active when\n** the persistent error occurred, then the rollback journal may need\n** to be replayed to restore the contents of the database file (as if\n** it were a hot-journal).\n*/\nstatic int pager_error(Pager *pPager, int rc){\n  int rc2 = rc & 0xff;\n  assert( rc==SQLITE_OK || !MEMDB );\n  assert(\n       pPager->errCode==SQLITE_FULL ||\n       pPager->errCode==SQLITE_OK ||\n       (pPager->errCode & 0xff)==SQLITE_IOERR\n  );\n  if( rc2==SQLITE_FULL || rc2==SQLITE_IOERR ){\n    pPager->errCode = rc;\n    pPager->eState = PAGER_ERROR;\n  }\n  return rc;\n}\n\n/*\n** This routine ends a transaction. A transaction is usually ended by \n** either a COMMIT or a ROLLBACK operation. This routine may be called \n** after rollback of a hot-journal, or if an error occurs while opening\n** the journal file or writing the very first journal-header of a\n** database transaction.\n** \n** This routine is never called in PAGER_ERROR state. If it is called\n** in PAGER_NONE or PAGER_SHARED state and the lock held is less\n** exclusive than a RESERVED lock, it is a no-op.\n**\n** Otherwise, any active savepoints are released.\n**\n** If the journal file is open, then it is \"finalized\". Once a journal \n** file has been finalized it is not possible to use it to roll back a \n** transaction. Nor will it be considered to be a hot-journal by this\n** or any other database connection. Exactly how a journal is finalized\n** depends on whether or not the pager is running in exclusive mode and\n** the current journal-mode (Pager.journalMode value), as follows:\n**\n**   journalMode==MEMORY\n**     Journal file descriptor is simply closed. This destroys an \n**     in-memory journal.\n**\n**   journalMode==TRUNCATE\n**     Journal file is truncated to zero bytes in size.\n**\n**   journalMode==PERSIST\n**     The first 28 bytes of the journal file are zeroed. This invalidates\n**     the first journal header in the file, and hence the entire journal\n**     file. An invalid journal file cannot be rolled back.\n**\n**   journalMode==DELETE\n**     The journal file is closed and deleted using sqlite3OsDelete().\n**\n**     If the pager is running in exclusive mode, this method of finalizing\n**     the journal file is never used. Instead, if the journalMode is\n**     DELETE and the pager is in exclusive mode, the method described under\n**     journalMode==PERSIST is used instead.\n**\n** After the journal is finalized, the pager moves to PAGER_READER state.\n** If running in non-exclusive rollback mode, the lock on the file is \n** downgraded to a SHARED_LOCK.\n**\n** SQLITE_OK is returned if no error occurs. If an error occurs during\n** any of the IO operations to finalize the journal file or unlock the\n** database then the IO error code is returned to the user. If the \n** operation to finalize the journal file fails, then the code still\n** tries to unlock the database file if not in exclusive mode. If the\n** unlock operation fails as well, then the first error code related\n** to the first error encountered (the journal finalization one) is\n** returned.\n*/\nstatic int pager_end_transaction(Pager *pPager, int hasMaster){\n  int rc = SQLITE_OK;      /* Error code from journal finalization operation */\n  int rc2 = SQLITE_OK;     /* Error code from db file unlock operation */\n\n  /* Do nothing if the pager does not have an open write transaction\n  ** or at least a RESERVED lock. This function may be called when there\n  ** is no write-transaction active but a RESERVED or greater lock is\n  ** held under two circumstances:\n  **\n  **   1. After a successful hot-journal rollback, it is called with\n  **      eState==PAGER_NONE and eLock==EXCLUSIVE_LOCK.\n  **\n  **   2. If a connection with locking_mode=exclusive holding an EXCLUSIVE \n  **      lock switches back to locking_mode=normal and then executes a\n  **      read-transaction, this function is called with eState==PAGER_READER \n  **      and eLock==EXCLUSIVE_LOCK when the read-transaction is closed.\n  */\n  assert( assert_pager_state(pPager) );\n  assert( pPager->eState!=PAGER_ERROR );\n  if( pPager->eState<PAGER_WRITER_LOCKED && pPager->eLock<RESERVED_LOCK ){\n    return SQLITE_OK;\n  }\n\n  releaseAllSavepoints(pPager);\n  assert( isOpen(pPager->jfd) || pPager->pInJournal==0 );\n  if( isOpen(pPager->jfd) ){\n    assert( !pagerUseWal(pPager) );\n\n    /* Finalize the journal file. */\n    if( sqlite3IsMemJournal(pPager->jfd) ){\n      assert( pPager->journalMode==PAGER_JOURNALMODE_MEMORY );\n      sqlite3OsClose(pPager->jfd);\n    }else if( pPager->journalMode==PAGER_JOURNALMODE_TRUNCATE ){\n      if( pPager->journalOff==0 ){\n        rc = SQLITE_OK;\n      }else{\n        rc = sqlite3OsTruncate(pPager->jfd, 0);\n      }\n      pPager->journalOff = 0;\n    }else if( pPager->journalMode==PAGER_JOURNALMODE_PERSIST\n      || (pPager->exclusiveMode && pPager->journalMode!=PAGER_JOURNALMODE_WAL)\n    ){\n      rc = zeroJournalHdr(pPager, hasMaster);\n      pPager->journalOff = 0;\n    }else{\n      /* This branch may be executed with Pager.journalMode==MEMORY if\n      ** a hot-journal was just rolled back. In this case the journal\n      ** file should be closed and deleted. If this connection writes to\n      ** the database file, it will do so using an in-memory journal. \n      */\n      assert( pPager->journalMode==PAGER_JOURNALMODE_DELETE \n           || pPager->journalMode==PAGER_JOURNALMODE_MEMORY \n           || pPager->journalMode==PAGER_JOURNALMODE_WAL \n      );\n      sqlite3OsClose(pPager->jfd);\n      if( !pPager->tempFile ){\n        rc = sqlite3OsDelete(pPager->pVfs, pPager->zJournal, 0);\n      }\n    }\n  }\n\n#ifdef SQLITE_CHECK_PAGES\n  sqlite3PcacheIterateDirty(pPager->pPCache, pager_set_pagehash);\n  if( pPager->dbSize==0 && sqlite3PcacheRefCount(pPager->pPCache)>0 ){\n    PgHdr *p = pager_lookup(pPager, 1);\n    if( p ){\n      p->pageHash = 0;\n      sqlite3PagerUnref(p);\n    }\n  }\n#endif\n\n  sqlite3BitvecDestroy(pPager->pInJournal);\n  pPager->pInJournal = 0;\n  pPager->nRec = 0;\n  sqlite3PcacheCleanAll(pPager->pPCache);\n  sqlite3PcacheTruncate(pPager->pPCache, pPager->dbSize);\n\n  if( pagerUseWal(pPager) ){\n    /* Drop the WAL write-lock, if any. Also, if the connection was in \n    ** locking_mode=exclusive mode but is no longer, drop the EXCLUSIVE \n    ** lock held on the database file.\n    */\n    rc2 = sqlite3WalEndWriteTransaction(pPager->pWal);\n    assert( rc2==SQLITE_OK );\n  }\n  if( !pPager->exclusiveMode \n   && (!pagerUseWal(pPager) || sqlite3WalExclusiveMode(pPager->pWal, 0))\n  ){\n    rc2 = pagerUnlockDb(pPager, SHARED_LOCK);\n    pPager->changeCountDone = 0;\n  }\n  pPager->eState = PAGER_READER;\n  pPager->setMaster = 0;\n\n  return (rc==SQLITE_OK?rc2:rc);\n}\n\n/*\n** Execute a rollback if a transaction is active and unlock the \n** database file. \n**\n** If the pager has already entered the ERROR state, do not attempt \n** the rollback at this time. Instead, pager_unlock() is called. The\n** call to pager_unlock() will discard all in-memory pages, unlock\n** the database file and move the pager back to OPEN state. If this \n** means that there is a hot-journal left in the file-system, the next \n** connection to obtain a shared lock on the pager (which may be this one) \n** will roll it back.\n**\n** If the pager has not already entered the ERROR state, but an IO or\n** malloc error occurs during a rollback, then this will itself cause \n** the pager to enter the ERROR state. Which will be cleared by the\n** call to pager_unlock(), as described above.\n*/\nstatic void pagerUnlockAndRollback(Pager *pPager){\n  if( pPager->eState!=PAGER_ERROR && pPager->eState!=PAGER_OPEN ){\n    assert( assert_pager_state(pPager) );\n    if( pPager->eState>=PAGER_WRITER_LOCKED ){\n      sqlite3BeginBenignMalloc();\n      sqlite3PagerRollback(pPager);\n      sqlite3EndBenignMalloc();\n    }else if( !pPager->exclusiveMode ){\n      assert( pPager->eState==PAGER_READER );\n      pager_end_transaction(pPager, 0);\n    }\n  }\n  pager_unlock(pPager);\n}\n\n/*\n** Parameter aData must point to a buffer of pPager->pageSize bytes\n** of data. Compute and return a checksum based ont the contents of the \n** page of data and the current value of pPager->cksumInit.\n**\n** This is not a real checksum. It is really just the sum of the \n** random initial value (pPager->cksumInit) and every 200th byte\n** of the page data, starting with byte offset (pPager->pageSize%200).\n** Each byte is interpreted as an 8-bit unsigned integer.\n**\n** Changing the formula used to compute this checksum results in an\n** incompatible journal file format.\n**\n** If journal corruption occurs due to a power failure, the most likely \n** scenario is that one end or the other of the record will be changed. \n** It is much less likely that the two ends of the journal record will be\n** correct and the middle be corrupt.  Thus, this \"checksum\" scheme,\n** though fast and simple, catches the mostly likely kind of corruption.\n*/\nstatic u32 pager_cksum(Pager *pPager, const u8 *aData){\n  u32 cksum = pPager->cksumInit;         /* Checksum value to return */\n  int i = pPager->pageSize-200;          /* Loop counter */\n  while( i>0 ){\n    cksum += aData[i];\n    i -= 200;\n  }\n  return cksum;\n}\n\n/*\n** Report the current page size and number of reserved bytes back\n** to the codec.\n*/\n#ifdef SQLITE_HAS_CODEC\nstatic void pagerReportSize(Pager *pPager){\n  if( pPager->xCodecSizeChng ){\n    pPager->xCodecSizeChng(pPager->pCodec, pPager->pageSize,\n                           (int)pPager->nReserve);\n  }\n}\n#else\n# define pagerReportSize(X)     /* No-op if we do not support a codec */\n#endif\n\n/*\n** Read a single page from either the journal file (if isMainJrnl==1) or\n** from the sub-journal (if isMainJrnl==0) and playback that page.\n** The page begins at offset *pOffset into the file. The *pOffset\n** value is increased to the start of the next page in the journal.\n**\n** The main rollback journal uses checksums - the statement journal does \n** not.\n**\n** If the page number of the page record read from the (sub-)journal file\n** is greater than the current value of Pager.dbSize, then playback is\n** skipped and SQLITE_OK is returned.\n**\n** If pDone is not NULL, then it is a record of pages that have already\n** been played back.  If the page at *pOffset has already been played back\n** (if the corresponding pDone bit is set) then skip the playback.\n** Make sure the pDone bit corresponding to the *pOffset page is set\n** prior to returning.\n**\n** If the page record is successfully read from the (sub-)journal file\n** and played back, then SQLITE_OK is returned. If an IO error occurs\n** while reading the record from the (sub-)journal file or while writing\n** to the database file, then the IO error code is returned. If data\n** is successfully read from the (sub-)journal file but appears to be\n** corrupted, SQLITE_DONE is returned. Data is considered corrupted in\n** two circumstances:\n** \n**   * If the record page-number is illegal (0 or PAGER_MJ_PGNO), or\n**   * If the record is being rolled back from the main journal file\n**     and the checksum field does not match the record content.\n**\n** Neither of these two scenarios are possible during a savepoint rollback.\n**\n** If this is a savepoint rollback, then memory may have to be dynamically\n** allocated by this function. If this is the case and an allocation fails,\n** SQLITE_NOMEM is returned.\n*/\nstatic int pager_playback_one_page(\n  Pager *pPager,                /* The pager being played back */\n  i64 *pOffset,                 /* Offset of record to playback */\n  Bitvec *pDone,                /* Bitvec of pages already played back */\n  int isMainJrnl,               /* 1 -> main journal. 0 -> sub-journal. */\n  int isSavepnt                 /* True for a savepoint rollback */\n){\n  int rc;\n  PgHdr *pPg;                   /* An existing page in the cache */\n  Pgno pgno;                    /* The page number of a page in journal */\n  u32 cksum;                    /* Checksum used for sanity checking */\n  char *aData;                  /* Temporary storage for the page */\n  sqlite3_file *jfd;            /* The file descriptor for the journal file */\n  int isSynced;                 /* True if journal page is synced */\n\n  assert( (isMainJrnl&~1)==0 );      /* isMainJrnl is 0 or 1 */\n  assert( (isSavepnt&~1)==0 );       /* isSavepnt is 0 or 1 */\n  assert( isMainJrnl || pDone );     /* pDone always used on sub-journals */\n  assert( isSavepnt || pDone==0 );   /* pDone never used on non-savepoint */\n\n  aData = pPager->pTmpSpace;\n  assert( aData );         /* Temp storage must have already been allocated */\n  assert( pagerUseWal(pPager)==0 || (!isMainJrnl && isSavepnt) );\n\n  /* Either the state is greater than PAGER_WRITER_CACHEMOD (a transaction \n  ** or savepoint rollback done at the request of the caller) or this is\n  ** a hot-journal rollback. If it is a hot-journal rollback, the pager\n  ** is in state OPEN and holds an EXCLUSIVE lock. Hot-journal rollback\n  ** only reads from the main journal, not the sub-journal.\n  */\n  assert( pPager->eState>=PAGER_WRITER_CACHEMOD\n       || (pPager->eState==PAGER_OPEN && pPager->eLock==EXCLUSIVE_LOCK)\n  );\n  assert( pPager->eState>=PAGER_WRITER_CACHEMOD || isMainJrnl );\n\n  /* Read the page number and page data from the journal or sub-journal\n  ** file. Return an error code to the caller if an IO error occurs.\n  */\n  jfd = isMainJrnl ? pPager->jfd : pPager->sjfd;\n  rc = read32bits(jfd, *pOffset, &pgno);\n  if( rc!=SQLITE_OK ) return rc;\n  rc = sqlite3OsRead(jfd, (u8*)aData, pPager->pageSize, (*pOffset)+4);\n  if( rc!=SQLITE_OK ) return rc;\n  *pOffset += pPager->pageSize + 4 + isMainJrnl*4;\n\n  /* Sanity checking on the page.  This is more important that I originally\n  ** thought.  If a power failure occurs while the journal is being written,\n  ** it could cause invalid data to be written into the journal.  We need to\n  ** detect this invalid data (with high probability) and ignore it.\n  */\n  if( pgno==0 || pgno==PAGER_MJ_PGNO(pPager) ){\n    assert( !isSavepnt );\n    return SQLITE_DONE;\n  }\n  if( pgno>(Pgno)pPager->dbSize || sqlite3BitvecTest(pDone, pgno) ){\n    return SQLITE_OK;\n  }\n  if( isMainJrnl ){\n    rc = read32bits(jfd, (*pOffset)-4, &cksum);\n    if( rc ) return rc;\n    if( !isSavepnt && pager_cksum(pPager, (u8*)aData)!=cksum ){\n      return SQLITE_DONE;\n    }\n  }\n\n  /* If this page has already been played by before during the current\n  ** rollback, then don't bother to play it back again.\n  */\n  if( pDone && (rc = sqlite3BitvecSet(pDone, pgno))!=SQLITE_OK ){\n    return rc;\n  }\n\n  /* When playing back page 1, restore the nReserve setting\n  */\n  if( pgno==1 && pPager->nReserve!=((u8*)aData)[20] ){\n    pPager->nReserve = ((u8*)aData)[20];\n    pagerReportSize(pPager);\n  }\n\n  /* If the pager is in CACHEMOD state, then there must be a copy of this\n  ** page in the pager cache. In this case just update the pager cache,\n  ** not the database file. The page is left marked dirty in this case.\n  **\n  ** An exception to the above rule: If the database is in no-sync mode\n  ** and a page is moved during an incremental vacuum then the page may\n  ** not be in the pager cache. Later: if a malloc() or IO error occurs\n  ** during a Movepage() call, then the page may not be in the cache\n  ** either. So the condition described in the above paragraph is not\n  ** assert()able.\n  **\n  ** If in WRITER_DBMOD, WRITER_FINISHED or OPEN state, then we update the\n  ** pager cache if it exists and the main file. The page is then marked \n  ** not dirty. Since this code is only executed in PAGER_OPEN state for\n  ** a hot-journal rollback, it is guaranteed that the page-cache is empty\n  ** if the pager is in OPEN state.\n  **\n  ** Ticket #1171:  The statement journal might contain page content that is\n  ** different from the page content at the start of the transaction.\n  ** This occurs when a page is changed prior to the start of a statement\n  ** then changed again within the statement.  When rolling back such a\n  ** statement we must not write to the original database unless we know\n  ** for certain that original page contents are synced into the main rollback\n  ** journal.  Otherwise, a power loss might leave modified data in the\n  ** database file without an entry in the rollback journal that can\n  ** restore the database to its original form.  Two conditions must be\n  ** met before writing to the database files. (1) the database must be\n  ** locked.  (2) we know that the original page content is fully synced\n  ** in the main journal either because the page is not in cache or else\n  ** the page is marked as needSync==0.\n  **\n  ** 2008-04-14:  When attempting to vacuum a corrupt database file, it\n  ** is possible to fail a statement on a database that does not yet exist.\n  ** Do not attempt to write if database file has never been opened.\n  */\n  if( pagerUseWal(pPager) ){\n    pPg = 0;\n  }else{\n    pPg = pager_lookup(pPager, pgno);\n  }\n  assert( pPg || !MEMDB );\n  assert( pPager->eState!=PAGER_OPEN || pPg==0 );\n  PAGERTRACE((\"PLAYBACK %d page %d hash(%08x) %s\\n\",\n           PAGERID(pPager), pgno, pager_datahash(pPager->pageSize, (u8*)aData),\n           (isMainJrnl?\"main-journal\":\"sub-journal\")\n  ));\n  if( isMainJrnl ){\n    isSynced = pPager->noSync || (*pOffset <= pPager->journalHdr);\n  }else{\n    isSynced = (pPg==0 || 0==(pPg->flags & PGHDR_NEED_SYNC));\n  }\n  if( isOpen(pPager->fd)\n   && (pPager->eState>=PAGER_WRITER_DBMOD || pPager->eState==PAGER_OPEN)\n   && isSynced\n  ){\n    i64 ofst = (pgno-1)*(i64)pPager->pageSize;\n    testcase( !isSavepnt && pPg!=0 && (pPg->flags&PGHDR_NEED_SYNC)!=0 );\n    assert( !pagerUseWal(pPager) );\n    rc = sqlite3OsWrite(pPager->fd, (u8*)aData, pPager->pageSize, ofst);\n    if( pgno>pPager->dbFileSize ){\n      pPager->dbFileSize = pgno;\n    }\n    if( pPager->pBackup ){\n      CODEC1(pPager, aData, pgno, 3, rc=SQLITE_CORRUPT);  /* This was originally rc=SQLITE_NOMEM for some reason */\n      sqlite3BackupUpdate(pPager->pBackup, pgno, (u8*)aData);\n      CODEC2(pPager, aData, pgno, 7, rc=SQLITE_NOMEM, aData);\n    }\n  }else if( !isMainJrnl && pPg==0 ){\n    /* If this is a rollback of a savepoint and data was not written to\n    ** the database and the page is not in-memory, there is a potential\n    ** problem. When the page is next fetched by the b-tree layer, it \n    ** will be read from the database file, which may or may not be \n    ** current. \n    **\n    ** There are a couple of different ways this can happen. All are quite\n    ** obscure. When running in synchronous mode, this can only happen \n    ** if the page is on the free-list at the start of the transaction, then\n    ** populated, then moved using sqlite3PagerMovepage().\n    **\n    ** The solution is to add an in-memory page to the cache containing\n    ** the data just read from the sub-journal. Mark the page as dirty \n    ** and if the pager requires a journal-sync, then mark the page as \n    ** requiring a journal-sync before it is written.\n    */\n    assert( isSavepnt );\n    assert( pPager->doNotSpill==0 );\n    pPager->doNotSpill++;\n    rc = sqlite3PagerAcquire(pPager, pgno, &pPg, 1);\n    assert( pPager->doNotSpill==1 );\n    pPager->doNotSpill--;\n    if( rc!=SQLITE_OK ) return rc;\n    pPg->flags &= ~PGHDR_NEED_READ;\n    sqlite3PcacheMakeDirty(pPg);\n  }\n  if( pPg ){\n    /* No page should ever be explicitly rolled back that is in use, except\n    ** for page 1 which is held in use in order to keep the lock on the\n    ** database active. However such a page may be rolled back as a result\n    ** of an internal error resulting in an automatic call to\n    ** sqlite3PagerRollback().\n    */\n    void *pData;\n    pData = pPg->pData;\n    memcpy(pData, (u8*)aData, pPager->pageSize);\n    pPager->xReiniter(pPg);\n    if( isMainJrnl && (!isSavepnt || *pOffset<=pPager->journalHdr) ){\n      /* If the contents of this page were just restored from the main \n      ** journal file, then its content must be as they were when the \n      ** transaction was first opened. In this case we can mark the page\n      ** as clean, since there will be no need to write it out to the\n      ** database.\n      **\n      ** There is one exception to this rule. If the page is being rolled\n      ** back as part of a savepoint (or statement) rollback from an \n      ** unsynced portion of the main journal file, then it is not safe\n      ** to mark the page as clean. This is because marking the page as\n      ** clean will clear the PGHDR_NEED_SYNC flag. Since the page is\n      ** already in the journal file (recorded in Pager.pInJournal) and\n      ** the PGHDR_NEED_SYNC flag is cleared, if the page is written to\n      ** again within this transaction, it will be marked as dirty but\n      ** the PGHDR_NEED_SYNC flag will not be set. It could then potentially\n      ** be written out into the database file before its journal file\n      ** segment is synced. If a crash occurs during or following this,\n      ** database corruption may ensue.\n      */\n      assert( !pagerUseWal(pPager) );\n      sqlite3PcacheMakeClean(pPg);\n    }\n    pager_set_pagehash(pPg);\n\n    /* If this was page 1, then restore the value of Pager.dbFileVers.\n    ** Do this before any decoding. */\n    if( pgno==1 ){\n      memcpy(&pPager->dbFileVers, &((u8*)pData)[24],sizeof(pPager->dbFileVers));\n    }\n\n    /* Decode the page just read from disk */\n    CODEC1(pPager, pData, pPg->pgno, 3, rc=SQLITE_CORRUPT);   /* This was originally rc=SQLITE_NOMEM for some reason */\n    sqlite3PcacheRelease(pPg);\n  }\n  return rc;\n}\n\n/*\n** Parameter zMaster is the name of a master journal file. A single journal\n** file that referred to the master journal file has just been rolled back.\n** This routine checks if it is possible to delete the master journal file,\n** and does so if it is.\n**\n** Argument zMaster may point to Pager.pTmpSpace. So that buffer is not \n** available for use within this function.\n**\n** When a master journal file is created, it is populated with the names \n** of all of its child journals, one after another, formatted as utf-8 \n** encoded text. The end of each child journal file is marked with a \n** nul-terminator byte (0x00). i.e. the entire contents of a master journal\n** file for a transaction involving two databases might be:\n**\n**   \"/home/bill/a.db-journal\\x00/home/bill/b.db-journal\\x00\"\n**\n** A master journal file may only be deleted once all of its child \n** journals have been rolled back.\n**\n** This function reads the contents of the master-journal file into \n** memory and loops through each of the child journal names. For\n** each child journal, it checks if:\n**\n**   * if the child journal exists, and if so\n**   * if the child journal contains a reference to master journal \n**     file zMaster\n**\n** If a child journal can be found that matches both of the criteria\n** above, this function returns without doing anything. Otherwise, if\n** no such child journal can be found, file zMaster is deleted from\n** the file-system using sqlite3OsDelete().\n**\n** If an IO error within this function, an error code is returned. This\n** function allocates memory by calling sqlite3Malloc(). If an allocation\n** fails, SQLITE_NOMEM is returned. Otherwise, if no IO or malloc errors \n** occur, SQLITE_OK is returned.\n**\n** TODO: This function allocates a single block of memory to load\n** the entire contents of the master journal file. This could be\n** a couple of kilobytes or so - potentially larger than the page \n** size.\n*/\nstatic int pager_delmaster(Pager *pPager, const char *zMaster){\n  sqlite3_vfs *pVfs = pPager->pVfs;\n  int rc;                   /* Return code */\n  sqlite3_file *pMaster;    /* Malloc'd master-journal file descriptor */\n  sqlite3_file *pJournal;   /* Malloc'd child-journal file descriptor */\n  char *zMasterJournal = 0; /* Contents of master journal file */\n  i64 nMasterJournal;       /* Size of master journal file */\n  char *zJournal;           /* Pointer to one journal within MJ file */\n  char *zMasterPtr;         /* Space to hold MJ filename from a journal file */\n  int nMasterPtr;           /* Amount of space allocated to zMasterPtr[] */\n\n  /* Allocate space for both the pJournal and pMaster file descriptors.\n  ** If successful, open the master journal file for reading.\n  */\n  pMaster = (sqlite3_file *)sqlite3MallocZero(pVfs->szOsFile * 2);\n  pJournal = (sqlite3_file *)(((u8 *)pMaster) + pVfs->szOsFile);\n  if( !pMaster ){\n    rc = SQLITE_NOMEM;\n  }else{\n    const int flags = (SQLITE_OPEN_READONLY|SQLITE_OPEN_MASTER_JOURNAL);\n    rc = sqlite3OsOpen(pVfs, zMaster, pMaster, flags, 0);\n  }\n  if( rc!=SQLITE_OK ) goto delmaster_out;\n\n  /* Load the entire master journal file into space obtained from\n  ** sqlite3_malloc() and pointed to by zMasterJournal.   Also obtain\n  ** sufficient space (in zMasterPtr) to hold the names of master\n  ** journal files extracted from regular rollback-journals.\n  */\n  rc = sqlite3OsFileSize(pMaster, &nMasterJournal);\n  if( rc!=SQLITE_OK ) goto delmaster_out;\n  nMasterPtr = pVfs->mxPathname+1;\n  zMasterJournal = sqlite3Malloc((int)nMasterJournal + nMasterPtr + 1);\n  if( !zMasterJournal ){\n    rc = SQLITE_NOMEM;\n    goto delmaster_out;\n  }\n  zMasterPtr = &zMasterJournal[nMasterJournal+1];\n  rc = sqlite3OsRead(pMaster, zMasterJournal, (int)nMasterJournal, 0);\n  if( rc!=SQLITE_OK ) goto delmaster_out;\n  zMasterJournal[nMasterJournal] = 0;\n\n  zJournal = zMasterJournal;\n  while( (zJournal-zMasterJournal)<nMasterJournal ){\n    int exists;\n    rc = sqlite3OsAccess(pVfs, zJournal, SQLITE_ACCESS_EXISTS, &exists);\n    if( rc!=SQLITE_OK ){\n      goto delmaster_out;\n    }\n    if( exists ){\n      /* One of the journals pointed to by the master journal exists.\n      ** Open it and check if it points at the master journal. If\n      ** so, return without deleting the master journal file.\n      */\n      int c;\n      int flags = (SQLITE_OPEN_READONLY|SQLITE_OPEN_MAIN_JOURNAL);\n      rc = sqlite3OsOpen(pVfs, zJournal, pJournal, flags, 0);\n      if( rc!=SQLITE_OK ){\n        goto delmaster_out;\n      }\n\n      rc = readMasterJournal(pJournal, zMasterPtr, nMasterPtr);\n      sqlite3OsClose(pJournal);\n      if( rc!=SQLITE_OK ){\n        goto delmaster_out;\n      }\n\n      c = zMasterPtr[0]!=0 && strcmp(zMasterPtr, zMaster)==0;\n      if( c ){\n        /* We have a match. Do not delete the master journal file. */\n        goto delmaster_out;\n      }\n    }\n    zJournal += (sqlite3Strlen30(zJournal)+1);\n  }\n \n  sqlite3OsClose(pMaster);\n  rc = sqlite3OsDelete(pVfs, zMaster, 0);\n\ndelmaster_out:\n  sqlite3_free(zMasterJournal);\n  if( pMaster ){\n    sqlite3OsClose(pMaster);\n    assert( !isOpen(pJournal) );\n    sqlite3_free(pMaster);\n  }\n  return rc;\n}\n\n\n/*\n** This function is used to change the actual size of the database \n** file in the file-system. This only happens when committing a transaction,\n** or rolling back a transaction (including rolling back a hot-journal).\n**\n** If the main database file is not open, or the pager is not in either\n** DBMOD or OPEN state, this function is a no-op. Otherwise, the size \n** of the file is changed to nPage pages (nPage*pPager->pageSize bytes). \n** If the file on disk is currently larger than nPage pages, then use the VFS\n** xTruncate() method to truncate it.\n**\n** Or, it might might be the case that the file on disk is smaller than \n** nPage pages. Some operating system implementations can get confused if \n** you try to truncate a file to some size that is larger than it \n** currently is, so detect this case and write a single zero byte to \n** the end of the new file instead.\n**\n** If successful, return SQLITE_OK. If an IO error occurs while modifying\n** the database file, return the error code to the caller.\n*/\nstatic int pager_truncate(Pager *pPager, Pgno nPage){\n  int rc = SQLITE_OK;\n  assert( pPager->eState!=PAGER_ERROR );\n  assert( pPager->eState!=PAGER_READER );\n  \n  if( isOpen(pPager->fd) \n   && (pPager->eState>=PAGER_WRITER_DBMOD || pPager->eState==PAGER_OPEN) \n  ){\n    i64 currentSize, newSize;\n    int szPage = pPager->pageSize;\n    assert( pPager->eLock==EXCLUSIVE_LOCK );\n    /* TODO: Is it safe to use Pager.dbFileSize here? */\n    rc = sqlite3OsFileSize(pPager->fd, &currentSize);\n    newSize = szPage*(i64)nPage;\n    if( rc==SQLITE_OK && currentSize!=newSize ){\n      if( currentSize>newSize ){\n        rc = sqlite3OsTruncate(pPager->fd, newSize);\n      }else{\n        char *pTmp = pPager->pTmpSpace;\n        memset(pTmp, 0, szPage);\n        testcase( (newSize-szPage) <  currentSize );\n        testcase( (newSize-szPage) == currentSize );\n        testcase( (newSize-szPage) >  currentSize );\n        rc = sqlite3OsWrite(pPager->fd, pTmp, szPage, newSize-szPage);\n      }\n      if( rc==SQLITE_OK ){\n        pPager->dbFileSize = nPage;\n      }\n    }\n  }\n  return rc;\n}\n\n/*\n** Set the value of the Pager.sectorSize variable for the given\n** pager based on the value returned by the xSectorSize method\n** of the open database file. The sector size will be used used \n** to determine the size and alignment of journal header and \n** master journal pointers within created journal files.\n**\n** For temporary files the effective sector size is always 512 bytes.\n**\n** Otherwise, for non-temporary files, the effective sector size is\n** the value returned by the xSectorSize() method rounded up to 32 if\n** it is less than 32, or rounded down to MAX_SECTOR_SIZE if it\n** is greater than MAX_SECTOR_SIZE.\n*/\nstatic void setSectorSize(Pager *pPager){\n  assert( isOpen(pPager->fd) || pPager->tempFile );\n\n  if( !pPager->tempFile ){\n    /* Sector size doesn't matter for temporary files. Also, the file\n    ** may not have been opened yet, in which case the OsSectorSize()\n    ** call will segfault.\n    */\n    pPager->sectorSize = sqlite3OsSectorSize(pPager->fd);\n  }\n  if( pPager->sectorSize<32 ){\n    pPager->sectorSize = 512;\n  }\n  if( pPager->sectorSize>MAX_SECTOR_SIZE ){\n    assert( MAX_SECTOR_SIZE>=512 );\n    pPager->sectorSize = MAX_SECTOR_SIZE;\n  }\n}\n\n/*\n** Playback the journal and thus restore the database file to\n** the state it was in before we started making changes.  \n**\n** The journal file format is as follows: \n**\n**  (1)  8 byte prefix.  A copy of aJournalMagic[].\n**  (2)  4 byte big-endian integer which is the number of valid page records\n**       in the journal.  If this value is 0xffffffff, then compute the\n**       number of page records from the journal size.\n**  (3)  4 byte big-endian integer which is the initial value for the \n**       sanity checksum.\n**  (4)  4 byte integer which is the number of pages to truncate the\n**       database to during a rollback.\n**  (5)  4 byte big-endian integer which is the sector size.  The header\n**       is this many bytes in size.\n**  (6)  4 byte big-endian integer which is the page size.\n**  (7)  zero padding out to the next sector size.\n**  (8)  Zero or more pages instances, each as follows:\n**        +  4 byte page number.\n**        +  pPager->pageSize bytes of data.\n**        +  4 byte checksum\n**\n** When we speak of the journal header, we mean the first 7 items above.\n** Each entry in the journal is an instance of the 8th item.\n**\n** Call the value from the second bullet \"nRec\".  nRec is the number of\n** valid page entries in the journal.  In most cases, you can compute the\n** value of nRec from the size of the journal file.  But if a power\n** failure occurred while the journal was being written, it could be the\n** case that the size of the journal file had already been increased but\n** the extra entries had not yet made it safely to disk.  In such a case,\n** the value of nRec computed from the file size would be too large.  For\n** that reason, we always use the nRec value in the header.\n**\n** If the nRec value is 0xffffffff it means that nRec should be computed\n** from the file size.  This value is used when the user selects the\n** no-sync option for the journal.  A power failure could lead to corruption\n** in this case.  But for things like temporary table (which will be\n** deleted when the power is restored) we don't care.  \n**\n** If the file opened as the journal file is not a well-formed\n** journal file then all pages up to the first corrupted page are rolled\n** back (or no pages if the journal header is corrupted). The journal file\n** is then deleted and SQLITE_OK returned, just as if no corruption had\n** been encountered.\n**\n** If an I/O or malloc() error occurs, the journal-file is not deleted\n** and an error code is returned.\n**\n** The isHot parameter indicates that we are trying to rollback a journal\n** that might be a hot journal.  Or, it could be that the journal is \n** preserved because of JOURNALMODE_PERSIST or JOURNALMODE_TRUNCATE.\n** If the journal really is hot, reset the pager cache prior rolling\n** back any content.  If the journal is merely persistent, no reset is\n** needed.\n*/\nstatic int pager_playback(Pager *pPager, int isHot){\n  sqlite3_vfs *pVfs = pPager->pVfs;\n  i64 szJ;                 /* Size of the journal file in bytes */\n  u32 nRec;                /* Number of Records in the journal */\n  u32 u;                   /* Unsigned loop counter */\n  Pgno mxPg = 0;           /* Size of the original file in pages */\n  int rc;                  /* Result code of a subroutine */\n  int res = 1;             /* Value returned by sqlite3OsAccess() */\n  char *zMaster = 0;       /* Name of master journal file if any */\n  int needPagerReset;      /* True to reset page prior to first page rollback */\n\n  /* Figure out how many records are in the journal.  Abort early if\n  ** the journal is empty.\n  */\n  assert( isOpen(pPager->jfd) );\n  rc = sqlite3OsFileSize(pPager->jfd, &szJ);\n  if( rc!=SQLITE_OK ){\n    goto end_playback;\n  }\n\n  /* Read the master journal name from the journal, if it is present.\n  ** If a master journal file name is specified, but the file is not\n  ** present on disk, then the journal is not hot and does not need to be\n  ** played back.\n  **\n  ** TODO: Technically the following is an error because it assumes that\n  ** buffer Pager.pTmpSpace is (mxPathname+1) bytes or larger. i.e. that\n  ** (pPager->pageSize >= pPager->pVfs->mxPathname+1). Using os_unix.c,\n  **  mxPathname is 512, which is the same as the minimum allowable value\n  ** for pageSize.\n  */\n  zMaster = pPager->pTmpSpace;\n  rc = readMasterJournal(pPager->jfd, zMaster, pPager->pVfs->mxPathname+1);\n  if( rc==SQLITE_OK && zMaster[0] ){\n    rc = sqlite3OsAccess(pVfs, zMaster, SQLITE_ACCESS_EXISTS, &res);\n  }\n  zMaster = 0;\n  if( rc!=SQLITE_OK || !res ){\n    goto end_playback;\n  }\n  pPager->journalOff = 0;\n  needPagerReset = isHot;\n\n  /* This loop terminates either when a readJournalHdr() or \n  ** pager_playback_one_page() call returns SQLITE_DONE or an IO error \n  ** occurs. \n  */\n  while( 1 ){\n    /* Read the next journal header from the journal file.  If there are\n    ** not enough bytes left in the journal file for a complete header, or\n    ** it is corrupted, then a process must have failed while writing it.\n    ** This indicates nothing more needs to be rolled back.\n    */\n    rc = readJournalHdr(pPager, isHot, szJ, &nRec, &mxPg);\n    if( rc!=SQLITE_OK ){ \n      if( rc==SQLITE_DONE ){\n        rc = SQLITE_OK;\n      }\n      goto end_playback;\n    }\n\n    /* If nRec is 0xffffffff, then this journal was created by a process\n    ** working in no-sync mode. This means that the rest of the journal\n    ** file consists of pages, there are no more journal headers. Compute\n    ** the value of nRec based on this assumption.\n    */\n    if( nRec==0xffffffff ){\n      assert( pPager->journalOff==JOURNAL_HDR_SZ(pPager) );\n      nRec = (int)((szJ - JOURNAL_HDR_SZ(pPager))/JOURNAL_PG_SZ(pPager));\n    }\n\n    /* If nRec is 0 and this rollback is of a transaction created by this\n    ** process and if this is the final header in the journal, then it means\n    ** that this part of the journal was being filled but has not yet been\n    ** synced to disk.  Compute the number of pages based on the remaining\n    ** size of the file.\n    **\n    ** The third term of the test was added to fix ticket #2565.\n    ** When rolling back a hot journal, nRec==0 always means that the next\n    ** chunk of the journal contains zero pages to be rolled back.  But\n    ** when doing a ROLLBACK and the nRec==0 chunk is the last chunk in\n    ** the journal, it means that the journal might contain additional\n    ** pages that need to be rolled back and that the number of pages \n    ** should be computed based on the journal file size.\n    */\n    if( nRec==0 && !isHot &&\n        pPager->journalHdr+JOURNAL_HDR_SZ(pPager)==pPager->journalOff ){\n      nRec = (int)((szJ - pPager->journalOff) / JOURNAL_PG_SZ(pPager));\n    }\n\n    /* If this is the first header read from the journal, truncate the\n    ** database file back to its original size.\n    */\n    if( pPager->journalOff==JOURNAL_HDR_SZ(pPager) ){\n      rc = pager_truncate(pPager, mxPg);\n      if( rc!=SQLITE_OK ){\n        goto end_playback;\n      }\n      pPager->dbSize = mxPg;\n    }\n\n    /* Copy original pages out of the journal and back into the \n    ** database file and/or page cache.\n    */\n    for(u=0; u<nRec; u++){\n      if( needPagerReset ){\n        pager_reset(pPager);\n        needPagerReset = 0;\n      }\n      rc = pager_playback_one_page(pPager,&pPager->journalOff,0,1,0);\n      if( rc!=SQLITE_OK ){\n        if( rc==SQLITE_DONE ){\n          rc = SQLITE_OK;\n          pPager->journalOff = szJ;\n          break;\n        }else if( rc==SQLITE_IOERR_SHORT_READ ){\n          /* If the journal has been truncated, simply stop reading and\n          ** processing the journal. This might happen if the journal was\n          ** not completely written and synced prior to a crash.  In that\n          ** case, the database should have never been written in the\n          ** first place so it is OK to simply abandon the rollback. */\n          rc = SQLITE_OK;\n          goto end_playback;\n        }else{\n          /* If we are unable to rollback, quit and return the error\n          ** code.  This will cause the pager to enter the error state\n          ** so that no further harm will be done.  Perhaps the next\n          ** process to come along will be able to rollback the database.\n          */\n          goto end_playback;\n        }\n      }\n    }\n  }\n  /*NOTREACHED*/\n  assert( 0 );\n\nend_playback:\n  /* Following a rollback, the database file should be back in its original\n  ** state prior to the start of the transaction, so invoke the\n  ** SQLITE_FCNTL_DB_UNCHANGED file-control method to disable the\n  ** assertion that the transaction counter was modified.\n  */\n  assert(\n    pPager->fd->pMethods==0 ||\n    sqlite3OsFileControl(pPager->fd,SQLITE_FCNTL_DB_UNCHANGED,0)>=SQLITE_OK\n  );\n\n  /* If this playback is happening automatically as a result of an IO or \n  ** malloc error that occurred after the change-counter was updated but \n  ** before the transaction was committed, then the change-counter \n  ** modification may just have been reverted. If this happens in exclusive \n  ** mode, then subsequent transactions performed by the connection will not\n  ** update the change-counter at all. This may lead to cache inconsistency\n  ** problems for other processes at some point in the future. So, just\n  ** in case this has happened, clear the changeCountDone flag now.\n  */\n  pPager->changeCountDone = pPager->tempFile;\n\n  if( rc==SQLITE_OK ){\n    zMaster = pPager->pTmpSpace;\n    rc = readMasterJournal(pPager->jfd, zMaster, pPager->pVfs->mxPathname+1);\n    testcase( rc!=SQLITE_OK );\n  }\n  if( rc==SQLITE_OK\n   && (pPager->eState>=PAGER_WRITER_DBMOD || pPager->eState==PAGER_OPEN)\n  ){\n    rc = sqlite3PagerSync(pPager);\n  }\n  if( rc==SQLITE_OK ){\n    rc = pager_end_transaction(pPager, zMaster[0]!='\\0');\n    testcase( rc!=SQLITE_OK );\n  }\n  if( rc==SQLITE_OK && zMaster[0] && res ){\n    /* If there was a master journal and this routine will return success,\n    ** see if it is possible to delete the master journal.\n    */\n    rc = pager_delmaster(pPager, zMaster);\n    testcase( rc!=SQLITE_OK );\n  }\n\n  /* The Pager.sectorSize variable may have been updated while rolling\n  ** back a journal created by a process with a different sector size\n  ** value. Reset it to the correct value for this process.\n  */\n  setSectorSize(pPager);\n  return rc;\n}\n\n/* Release the memory for a page which was read using xReadZeroCopy */\nstatic void unpinZeroCopy(PgHdr* p) {\n  assert (p->flags & PGHDR_ZERO_COPY);\n  assert (p->pPager->readOnly);\n  p->pPager->fd->pMethods->xReleaseZeroCopy(p->pPager->fd, p->pData, p->pPager->pageSize, (p->pgno-1)*(i64)p->pPager->pageSize);\n  p->pData = 0;\n  p->flags &= ~PGHDR_ZERO_COPY;\n}\n\n/*\n** Read the content for page pPg out of the database file and into \n** pPg->pData. A shared lock or greater must be held on the database\n** file before this function is called.\n**\n** If page 1 is read, then the value of Pager.dbFileVers[] is set to\n** the value read from the database file.\n**\n** If an IO error occurs, then the IO error is returned to the caller.\n** Otherwise, SQLITE_OK is returned.\n*/\nstatic int readDbPage(PgHdr *pPg){\n  Pager *pPager = pPg->pPager; /* Pager object associated with page pPg */\n  Pgno pgno = pPg->pgno;       /* Page number to read */\n  int rc = SQLITE_OK;          /* Return code */\n  int isInWal = 0;             /* True if page is in log file */\n  int pgsz = pPager->pageSize; /* Number of bytes to read */\n\n  assert( pPager->eState>=PAGER_READER && !MEMDB );\n  assert( isOpen(pPager->fd) );\n\n  if( NEVER(!isOpen(pPager->fd)) ){\n    assert( pPager->tempFile );\n    memset(pPg->pData, 0, pPager->pageSize);\n    return SQLITE_OK;\n  }\n\n  int wasCached = 0;\n  if (pPager->readOnly && pagerUseWal(pPager)) {\n    rc = sqlite3WalRead(pPager->pWal, pgno, &isInWal, pgsz, pPg->pData);\n    if( rc==SQLITE_OK && !isInWal ){\n      void *pData;\n      i64 iOffset = (pgno-1)*(i64)pPager->pageSize;\n      // Try to do the read zero-copy\n      rc = pPager->fd->pMethods->xReadZeroCopy(pPager->fd, &pData, pgsz, iOffset, &wasCached);\n      if (rc == SQLITE_OK) {\n        pPg->flags |= PGHDR_ZERO_COPY;\n        pPg->pData = pData;\n      } else {\n        // Fall back to the normal read path (e.g. might be required at the end of the file if it is a funny length)\n        i64 iOffset = (pgno-1)*(i64)pPager->pageSize;\n        rc = sqlite3OsRead(pPager->fd, pPg->pData, pgsz, iOffset);\n        if( rc==SQLITE_IOERR_SHORT_READ ){\n          rc = SQLITE_OK;\n        }\n      }\n    }\n  } else {\n    if( pagerUseWal(pPager) ){\n      /* Try to pull the page from the write-ahead log. */\n      rc = sqlite3WalRead(pPager->pWal, pgno, &isInWal, pgsz, pPg->pData);\n    }\n    if( rc==SQLITE_OK && !isInWal ){\n      i64 iOffset = (pgno-1)*(i64)pPager->pageSize;\n      rc = sqlite3OsRead(pPager->fd, pPg->pData, pgsz, iOffset);\n      if( rc==SQLITE_IOERR_SHORT_READ ){\n        rc = SQLITE_OK;\n      }\n    }\n  }\n\n  if( pgno==1 ){\n    if( rc ){\n      /* If the read is unsuccessful, set the dbFileVers[] to something\n      ** that will never be a valid file version.  dbFileVers[] is a copy\n      ** of bytes 24..39 of the database.  Bytes 28..31 should always be\n      ** zero or the size of the database in page. Bytes 32..35 and 35..39\n      ** should be page numbers which are never 0xffffffff.  So filling\n      ** pPager->dbFileVers[] with all 0xff bytes should suffice.\n      **\n      ** For an encrypted database, the situation is more complex:  bytes\n      ** 24..39 of the database are white noise.  But the probability of\n      ** white noising equaling 16 bytes of 0xff is vanishingly small so\n      ** we should still be ok.\n      */\n      memset(pPager->dbFileVers, 0xff, sizeof(pPager->dbFileVers));\n    }else{\n      u8 *dbFileVers = &((u8*)pPg->pData)[24];\n      memcpy(&pPager->dbFileVers, dbFileVers, sizeof(pPager->dbFileVers));\n    }\n  }\n  if(rc == SQLITE_OK && wasCached == 0)\n    CODEC1(pPager, pPg->pData, pgno, 3, rc = SQLITE_CORRUPT);   /* This was originally rc=SQLITE_NOMEM for some reason */\n\n  PAGER_INCR(sqlite3_pager_readdb_count);\n  PAGER_INCR(pPager->nRead);\n  IOTRACE((\"PGIN %p %d\\n\", pPager, pgno));\n  PAGERTRACE((\"FETCH %d page %d hash(%08x)\\n\",\n               PAGERID(pPager), pgno, pager_pagehash(pPg)));\n\n  return rc;\n}\n\n/*\n** Update the value of the change-counter at offsets 24 and 92 in\n** the header and the sqlite version number at offset 96.\n**\n** This is an unconditional update.  See also the pager_incr_changecounter()\n** routine which only updates the change-counter if the update is actually\n** needed, as determined by the pPager->changeCountDone state variable.\n*/\nstatic void pager_write_changecounter(PgHdr *pPg){\n  u32 change_counter;\n\n  /* Increment the value just read and write it back to byte 24. */\n  change_counter = sqlite3Get4byte((u8*)pPg->pPager->dbFileVers)+1;\n  put32bits(((char*)pPg->pData)+24, change_counter);\n\n  /* Also store the SQLite version number in bytes 96..99 and in\n  ** bytes 92..95 store the change counter for which the version number\n  ** is valid. */\n  put32bits(((char*)pPg->pData)+92, change_counter);\n  put32bits(((char*)pPg->pData)+96, SQLITE_VERSION_NUMBER);\n}\n\n#ifndef SQLITE_OMIT_WAL\n/*\n** This function is invoked once for each page that has already been \n** written into the log file when a WAL transaction is rolled back.\n** Parameter iPg is the page number of said page. The pCtx argument \n** is actually a pointer to the Pager structure.\n**\n** If page iPg is present in the cache, and has no outstanding references,\n** it is discarded. Otherwise, if there are one or more outstanding\n** references, the page content is reloaded from the database. If the\n** attempt to reload content from the database is required and fails, \n** return an SQLite error code. Otherwise, SQLITE_OK.\n*/\nstatic int pagerUndoCallback(void *pCtx, Pgno iPg){\n  int rc = SQLITE_OK;\n  Pager *pPager = (Pager *)pCtx;\n  PgHdr *pPg;\n\n  pPg = sqlite3PagerLookup(pPager, iPg);\n  if( pPg ){\n    if( sqlite3PcachePageRefcount(pPg)==1 ){\n      sqlite3PcacheDrop(pPg);\n    }else{\n      rc = readDbPage(pPg);\n      if( rc==SQLITE_OK ){\n        pPager->xReiniter(pPg);\n      }\n      sqlite3PagerUnref(pPg);\n    }\n  }\n\n  /* Normally, if a transaction is rolled back, any backup processes are\n  ** updated as data is copied out of the rollback journal and into the\n  ** database. This is not generally possible with a WAL database, as\n  ** rollback involves simply truncating the log file. Therefore, if one\n  ** or more frames have already been written to the log (and therefore \n  ** also copied into the backup databases) as part of this transaction,\n  ** the backups must be restarted.\n  */\n  sqlite3BackupRestart(pPager->pBackup);\n\n  return rc;\n}\n\n/*\n** This function is called to rollback a transaction on a WAL database.\n*/\nstatic int pagerRollbackWal(Pager *pPager){\n  int rc;                         /* Return Code */\n  PgHdr *pList;                   /* List of dirty pages to revert */\n\n  /* For all pages in the cache that are currently dirty or have already\n  ** been written (but not committed) to the log file, do one of the \n  ** following:\n  **\n  **   + Discard the cached page (if refcount==0), or\n  **   + Reload page content from the database (if refcount>0).\n  */\n  pPager->dbSize = pPager->dbOrigSize;\n  rc = sqlite3WalUndo(pPager->pWal, pagerUndoCallback, (void *)pPager);\n  pList = sqlite3PcacheDirtyList(pPager->pPCache);\n  while( pList && rc==SQLITE_OK ){\n    PgHdr *pNext = pList->pDirty;\n    rc = pagerUndoCallback((void *)pPager, pList->pgno);\n    pList = pNext;\n  }\n\n  return rc;\n}\n\n/*\n** This function is a wrapper around sqlite3WalFrames(). As well as logging\n** the contents of the list of pages headed by pList (connected by pDirty),\n** this function notifies any active backup processes that the pages have\n** changed. \n**\n** The list of pages passed into this routine is always sorted by page number.\n** Hence, if page 1 appears anywhere on the list, it will be the first page.\n*/ \nstatic int pagerWalFrames(\n  Pager *pPager,                  /* Pager object */\n  PgHdr *pList,                   /* List of frames to log */\n  Pgno nTruncate,                 /* Database size after this commit */\n  int isCommit,                   /* True if this is a commit */\n  int syncFlags                   /* Flags to pass to OsSync() (or 0) */\n){\n  int rc;                         /* Return code */\n#if defined(SQLITE_DEBUG) || defined(SQLITE_CHECK_PAGES)\n  PgHdr *p;                       /* For looping over pages */\n#endif\n\n  assert( pPager->pWal );\n#ifdef SQLITE_DEBUG\n  /* Verify that the page list is in accending order */\n  for(p=pList; p && p->pDirty; p=p->pDirty){\n    assert( p->pgno < p->pDirty->pgno );\n  }\n#endif\n\n  if( pList->pgno==1 ) pager_write_changecounter(pList);\n  rc = sqlite3WalFrames(pPager->pWal, \n      pPager->pageSize, pList, nTruncate, isCommit, syncFlags\n  );\n  if( rc==SQLITE_OK && pPager->pBackup ){\n    PgHdr *p;\n    for(p=pList; p; p=p->pDirty){\n      sqlite3BackupUpdate(pPager->pBackup, p->pgno, (u8 *)p->pData);\n    }\n  }\n\n#ifdef SQLITE_CHECK_PAGES\n  for(p=pList; p; p=p->pDirty){\n    pager_set_pagehash(p);\n  }\n#endif\n\n  return rc;\n}\n\n/*\n** Begin a read transaction on the WAL.\n**\n** This routine used to be called \"pagerOpenSnapshot()\" because it essentially\n** makes a snapshot of the database at the current point in time and preserves\n** that snapshot for use by the reader in spite of concurrently changes by\n** other writers or checkpointers.\n*/\nstatic int pagerBeginReadTransaction(Pager *pPager){\n  int rc;                         /* Return code */\n  int changed = 0;                /* True if cache must be reset */\n\n  assert( pagerUseWal(pPager) );\n  assert( pPager->eState==PAGER_OPEN || pPager->eState==PAGER_READER );\n\n  /* sqlite3WalEndReadTransaction() was not called for the previous\n  ** transaction in locking_mode=EXCLUSIVE.  So call it now.  If we\n  ** are in locking_mode=NORMAL and EndRead() was previously called,\n  ** the duplicate call is harmless.\n  */\n  sqlite3WalEndReadTransaction(pPager->pWal);\n\n  rc = sqlite3WalBeginReadTransaction(pPager->pWal, &changed);\n  if( rc!=SQLITE_OK || changed ){\n    pager_reset(pPager);\n  }\n\n  return rc;\n}\n#endif\n\n/*\n** This function is called as part of the transition from PAGER_OPEN\n** to PAGER_READER state to determine the size of the database file\n** in pages (assuming the page size currently stored in Pager.pageSize).\n**\n** If no error occurs, SQLITE_OK is returned and the size of the database\n** in pages is stored in *pnPage. Otherwise, an error code (perhaps\n** SQLITE_IOERR_FSTAT) is returned and *pnPage is left unmodified.\n*/\nstatic int pagerPagecount(Pager *pPager, Pgno *pnPage){\n  Pgno nPage;                     /* Value to return via *pnPage */\n\n  /* Query the WAL sub-system for the database size. The WalDbsize()\n  ** function returns zero if the WAL is not open (i.e. Pager.pWal==0), or\n  ** if the database size is not available. The database size is not\n  ** available from the WAL sub-system if the log file is empty or\n  ** contains no valid committed transactions.\n  */\n  assert( pPager->eState==PAGER_OPEN );\n  assert( pPager->eLock>=SHARED_LOCK || pPager->noReadlock );\n  nPage = sqlite3WalDbsize(pPager->pWal);\n\n  /* If the database size was not available from the WAL sub-system,\n  ** determine it based on the size of the database file. If the size\n  ** of the database file is not an integer multiple of the page-size,\n  ** round down to the nearest page. Except, any file larger than 0\n  ** bytes in size is considered to contain at least one page.\n  */\n  if( nPage==0 ){\n    i64 n = 0;                    /* Size of db file in bytes */\n    assert( isOpen(pPager->fd) || pPager->tempFile );\n    if( isOpen(pPager->fd) ){\n      int rc = sqlite3OsFileSize(pPager->fd, &n);\n      if( rc!=SQLITE_OK ){\n        return rc;\n      }\n    }\n    nPage = (Pgno)(n / pPager->pageSize);\n    if( nPage==0 && n>0 ){\n      nPage = 1;\n    }\n  }\n\n  /* If the current number of pages in the file is greater than the\n  ** configured maximum pager number, increase the allowed limit so\n  ** that the file can be read.\n  */\n  if( nPage>pPager->mxPgno ){\n    pPager->mxPgno = (Pgno)nPage;\n  }\n\n  *pnPage = nPage;\n  return SQLITE_OK;\n}\n\n#ifndef SQLITE_OMIT_WAL\n/*\n** Check if the *-wal file that corresponds to the database opened by pPager\n** exists if the database is not empy, or verify that the *-wal file does\n** not exist (by deleting it) if the database file is empty.\n**\n** If the database is not empty and the *-wal file exists, open the pager\n** in WAL mode.  If the database is empty or if no *-wal file exists and\n** if no error occurs, make sure Pager.journalMode is not set to\n** PAGER_JOURNALMODE_WAL.\n**\n** Return SQLITE_OK or an error code.\n**\n** The caller must hold a SHARED lock on the database file to call this\n** function. Because an EXCLUSIVE lock on the db file is required to delete \n** a WAL on a none-empty database, this ensures there is no race condition \n** between the xAccess() below and an xDelete() being executed by some \n** other connection.\n*/\nstatic int pagerOpenWalIfPresent(Pager *pPager){\n  int rc = SQLITE_OK;\n  assert( pPager->eState==PAGER_OPEN );\n  assert( pPager->eLock>=SHARED_LOCK || pPager->noReadlock );\n\n  if( !pPager->tempFile ){\n    int isWal;                    /* True if WAL file exists */\n    Pgno nPage;                   /* Size of the database file */\n\n    rc = pagerPagecount(pPager, &nPage);\n    if( rc ) return rc;\n    if( nPage==0 ){\n      rc = sqlite3OsDelete(pPager->pVfs, pPager->zWal, 0);\n      isWal = 0;\n    }else{\n      rc = sqlite3OsAccess(\n          pPager->pVfs, pPager->zWal, SQLITE_ACCESS_EXISTS, &isWal\n      );\n    }\n    if( rc==SQLITE_OK ){\n      if( isWal ){\n        testcase( sqlite3PcachePagecount(pPager->pPCache)==0 );\n        rc = sqlite3PagerOpenWal(pPager, 0);\n      }else if( pPager->journalMode==PAGER_JOURNALMODE_WAL ){\n        pPager->journalMode = PAGER_JOURNALMODE_DELETE;\n      }\n    }\n  }\n  return rc;\n}\n#endif\n\n/*\n** Playback savepoint pSavepoint. Or, if pSavepoint==NULL, then playback\n** the entire master journal file. The case pSavepoint==NULL occurs when \n** a ROLLBACK TO command is invoked on a SAVEPOINT that is a transaction \n** savepoint.\n**\n** When pSavepoint is not NULL (meaning a non-transaction savepoint is \n** being rolled back), then the rollback consists of up to three stages,\n** performed in the order specified:\n**\n**   * Pages are played back from the main journal starting at byte\n**     offset PagerSavepoint.iOffset and continuing to \n**     PagerSavepoint.iHdrOffset, or to the end of the main journal\n**     file if PagerSavepoint.iHdrOffset is zero.\n**\n**   * If PagerSavepoint.iHdrOffset is not zero, then pages are played\n**     back starting from the journal header immediately following \n**     PagerSavepoint.iHdrOffset to the end of the main journal file.\n**\n**   * Pages are then played back from the sub-journal file, starting\n**     with the PagerSavepoint.iSubRec and continuing to the end of\n**     the journal file.\n**\n** Throughout the rollback process, each time a page is rolled back, the\n** corresponding bit is set in a bitvec structure (variable pDone in the\n** implementation below). This is used to ensure that a page is only\n** rolled back the first time it is encountered in either journal.\n**\n** If pSavepoint is NULL, then pages are only played back from the main\n** journal file. There is no need for a bitvec in this case.\n**\n** In either case, before playback commences the Pager.dbSize variable\n** is reset to the value that it held at the start of the savepoint \n** (or transaction). No page with a page-number greater than this value\n** is played back. If one is encountered it is simply skipped.\n*/\nstatic int pagerPlaybackSavepoint(Pager *pPager, PagerSavepoint *pSavepoint){\n  i64 szJ;                 /* Effective size of the main journal */\n  i64 iHdrOff;             /* End of first segment of main-journal records */\n  int rc = SQLITE_OK;      /* Return code */\n  Bitvec *pDone = 0;       /* Bitvec to ensure pages played back only once */\n\n  assert( pPager->eState!=PAGER_ERROR );\n  assert( pPager->eState>=PAGER_WRITER_LOCKED );\n\n  /* Allocate a bitvec to use to store the set of pages rolled back */\n  if( pSavepoint ){\n    pDone = sqlite3BitvecCreate(pSavepoint->nOrig);\n    if( !pDone ){\n      return SQLITE_NOMEM;\n    }\n  }\n\n  /* Set the database size back to the value it was before the savepoint \n  ** being reverted was opened.\n  */\n  pPager->dbSize = pSavepoint ? pSavepoint->nOrig : pPager->dbOrigSize;\n  pPager->changeCountDone = pPager->tempFile;\n\n  if( !pSavepoint && pagerUseWal(pPager) ){\n    return pagerRollbackWal(pPager);\n  }\n\n  /* Use pPager->journalOff as the effective size of the main rollback\n  ** journal.  The actual file might be larger than this in\n  ** PAGER_JOURNALMODE_TRUNCATE or PAGER_JOURNALMODE_PERSIST.  But anything\n  ** past pPager->journalOff is off-limits to us.\n  */\n  szJ = pPager->journalOff;\n  assert( pagerUseWal(pPager)==0 || szJ==0 );\n\n  /* Begin by rolling back records from the main journal starting at\n  ** PagerSavepoint.iOffset and continuing to the next journal header.\n  ** There might be records in the main journal that have a page number\n  ** greater than the current database size (pPager->dbSize) but those\n  ** will be skipped automatically.  Pages are added to pDone as they\n  ** are played back.\n  */\n  if( pSavepoint && !pagerUseWal(pPager) ){\n    iHdrOff = pSavepoint->iHdrOffset ? pSavepoint->iHdrOffset : szJ;\n    pPager->journalOff = pSavepoint->iOffset;\n    while( rc==SQLITE_OK && pPager->journalOff<iHdrOff ){\n      rc = pager_playback_one_page(pPager, &pPager->journalOff, pDone, 1, 1);\n    }\n    assert( rc!=SQLITE_DONE );\n  }else{\n    pPager->journalOff = 0;\n  }\n\n  /* Continue rolling back records out of the main journal starting at\n  ** the first journal header seen and continuing until the effective end\n  ** of the main journal file.  Continue to skip out-of-range pages and\n  ** continue adding pages rolled back to pDone.\n  */\n  while( rc==SQLITE_OK && pPager->journalOff<szJ ){\n    u32 ii;            /* Loop counter */\n    u32 nJRec = 0;     /* Number of Journal Records */\n    u32 dummy;\n    rc = readJournalHdr(pPager, 0, szJ, &nJRec, &dummy);\n    assert( rc!=SQLITE_DONE );\n\n    /*\n    ** The \"pPager->journalHdr+JOURNAL_HDR_SZ(pPager)==pPager->journalOff\"\n    ** test is related to ticket #2565.  See the discussion in the\n    ** pager_playback() function for additional information.\n    */\n    if( nJRec==0 \n     && pPager->journalHdr+JOURNAL_HDR_SZ(pPager)==pPager->journalOff\n    ){\n      nJRec = (u32)((szJ - pPager->journalOff)/JOURNAL_PG_SZ(pPager));\n    }\n    for(ii=0; rc==SQLITE_OK && ii<nJRec && pPager->journalOff<szJ; ii++){\n      rc = pager_playback_one_page(pPager, &pPager->journalOff, pDone, 1, 1);\n    }\n    assert( rc!=SQLITE_DONE );\n  }\n  assert( rc!=SQLITE_OK || pPager->journalOff>=szJ );\n\n  /* Finally,  rollback pages from the sub-journal.  Page that were\n  ** previously rolled back out of the main journal (and are hence in pDone)\n  ** will be skipped.  Out-of-range pages are also skipped.\n  */\n  if( pSavepoint ){\n    u32 ii;            /* Loop counter */\n    i64 offset = pSavepoint->iSubRec*(4+pPager->pageSize);\n\n    if( pagerUseWal(pPager) ){\n      rc = sqlite3WalSavepointUndo(pPager->pWal, pSavepoint->aWalData);\n    }\n    for(ii=pSavepoint->iSubRec; rc==SQLITE_OK && ii<pPager->nSubRec; ii++){\n      assert( offset==ii*(4+pPager->pageSize) );\n      rc = pager_playback_one_page(pPager, &offset, pDone, 0, 1);\n    }\n    assert( rc!=SQLITE_DONE );\n  }\n\n  sqlite3BitvecDestroy(pDone);\n  if( rc==SQLITE_OK ){\n    pPager->journalOff = szJ;\n  }\n\n  return rc;\n}\n\n/*\n** Change the maximum number of in-memory pages that are allowed.\n*/\nSQLITE_PRIVATE void sqlite3PagerSetCachesize(Pager *pPager, int mxPage){\n  sqlite3PcacheSetCachesize(pPager->pPCache, mxPage);\n}\n\n/*\n** Adjust the robustness of the database to damage due to OS crashes\n** or power failures by changing the number of syncs()s when writing\n** the rollback journal.  There are three levels:\n**\n**    OFF       sqlite3OsSync() is never called.  This is the default\n**              for temporary and transient files.\n**\n**    NORMAL    The journal is synced once before writes begin on the\n**              database.  This is normally adequate protection, but\n**              it is theoretically possible, though very unlikely,\n**              that an inopertune power failure could leave the journal\n**              in a state which would cause damage to the database\n**              when it is rolled back.\n**\n**    FULL      The journal is synced twice before writes begin on the\n**              database (with some additional information - the nRec field\n**              of the journal header - being written in between the two\n**              syncs).  If we assume that writing a\n**              single disk sector is atomic, then this mode provides\n**              assurance that the journal will not be corrupted to the\n**              point of causing damage to the database during rollback.\n**\n** The above is for a rollback-journal mode.  For WAL mode, OFF continues\n** to mean that no syncs ever occur.  NORMAL means that the WAL is synced\n** prior to the start of checkpoint and that the database file is synced\n** at the conclusion of the checkpoint if the entire content of the WAL\n** was written back into the database.  But no sync operations occur for\n** an ordinary commit in NORMAL mode with WAL.  FULL means that the WAL\n** file is synced following each commit operation, in addition to the\n** syncs associated with NORMAL.\n**\n** Do not confuse synchronous=FULL with SQLITE_SYNC_FULL.  The\n** SQLITE_SYNC_FULL macro means to use the MacOSX-style full-fsync\n** using fcntl(F_FULLFSYNC).  SQLITE_SYNC_NORMAL means to do an\n** ordinary fsync() call.  There is no difference between SQLITE_SYNC_FULL\n** and SQLITE_SYNC_NORMAL on platforms other than MacOSX.  But the\n** synchronous=FULL versus synchronous=NORMAL setting determines when\n** the xSync primitive is called and is relevant to all platforms.\n**\n** Numeric values associated with these states are OFF==1, NORMAL=2,\n** and FULL=3.\n*/\n#ifndef SQLITE_OMIT_PAGER_PRAGMAS\nSQLITE_PRIVATE void sqlite3PagerSetSafetyLevel(\n  Pager *pPager,        /* The pager to set safety level for */\n  int level,            /* PRAGMA synchronous.  1=OFF, 2=NORMAL, 3=FULL */  \n  int bFullFsync,       /* PRAGMA fullfsync */\n  int bCkptFullFsync    /* PRAGMA checkpoint_fullfsync */\n){\n  assert( level>=1 && level<=3 );\n  pPager->noSync =  (level==1 || pPager->tempFile) ?1:0;\n  pPager->fullSync = (level==3 && !pPager->tempFile) ?1:0;\n  if( pPager->noSync ){\n    pPager->syncFlags = 0;\n    pPager->ckptSyncFlags = 0;\n  }else if( bFullFsync ){\n    pPager->syncFlags = SQLITE_SYNC_FULL;\n    pPager->ckptSyncFlags = SQLITE_SYNC_FULL;\n  }else if( bCkptFullFsync ){\n    pPager->syncFlags = SQLITE_SYNC_NORMAL;\n    pPager->ckptSyncFlags = SQLITE_SYNC_FULL;\n  }else{\n    pPager->syncFlags = SQLITE_SYNC_NORMAL;\n    pPager->ckptSyncFlags = SQLITE_SYNC_NORMAL;\n  }\n}\n#endif\n\n/*\n** The following global variable is incremented whenever the library\n** attempts to open a temporary file.  This information is used for\n** testing and analysis only.  \n*/\n#ifdef SQLITE_TEST\nSQLITE_API int sqlite3_opentemp_count = 0;\n#endif\n\n/*\n** Open a temporary file.\n**\n** Write the file descriptor into *pFile. Return SQLITE_OK on success \n** or some other error code if we fail. The OS will automatically \n** delete the temporary file when it is closed.\n**\n** The flags passed to the VFS layer xOpen() call are those specified\n** by parameter vfsFlags ORed with the following:\n**\n**     SQLITE_OPEN_READWRITE\n**     SQLITE_OPEN_CREATE\n**     SQLITE_OPEN_EXCLUSIVE\n**     SQLITE_OPEN_DELETEONCLOSE\n*/\nstatic int pagerOpentemp(\n  Pager *pPager,        /* The pager object */\n  sqlite3_file *pFile,  /* Write the file descriptor here */\n  int vfsFlags          /* Flags passed through to the VFS */\n){\n  int rc;               /* Return code */\n\n#ifdef SQLITE_TEST\n  sqlite3_opentemp_count++;  /* Used for testing and analysis only */\n#endif\n\n  vfsFlags |=  SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE |\n            SQLITE_OPEN_EXCLUSIVE | SQLITE_OPEN_DELETEONCLOSE;\n  rc = sqlite3OsOpen(pPager->pVfs, 0, pFile, vfsFlags, 0);\n  assert( rc!=SQLITE_OK || isOpen(pFile) );\n  return rc;\n}\n\n/*\n** Set the busy handler function.\n**\n** The pager invokes the busy-handler if sqlite3OsLock() returns \n** SQLITE_BUSY when trying to upgrade from no-lock to a SHARED lock,\n** or when trying to upgrade from a RESERVED lock to an EXCLUSIVE \n** lock. It does *not* invoke the busy handler when upgrading from\n** SHARED to RESERVED, or when upgrading from SHARED to EXCLUSIVE\n** (which occurs during hot-journal rollback). Summary:\n**\n**   Transition                        | Invokes xBusyHandler\n**   --------------------------------------------------------\n**   NO_LOCK       -> SHARED_LOCK      | Yes\n**   SHARED_LOCK   -> RESERVED_LOCK    | No\n**   SHARED_LOCK   -> EXCLUSIVE_LOCK   | No\n**   RESERVED_LOCK -> EXCLUSIVE_LOCK   | Yes\n**\n** If the busy-handler callback returns non-zero, the lock is \n** retried. If it returns zero, then the SQLITE_BUSY error is\n** returned to the caller of the pager API function.\n*/\nSQLITE_PRIVATE void sqlite3PagerSetBusyhandler(\n  Pager *pPager,                       /* Pager object */\n  int (*xBusyHandler)(void *),         /* Pointer to busy-handler function */\n  void *pBusyHandlerArg                /* Argument to pass to xBusyHandler */\n){  \n  pPager->xBusyHandler = xBusyHandler;\n  pPager->pBusyHandlerArg = pBusyHandlerArg;\n}\n\n/*\n** Change the page size used by the Pager object. The new page size \n** is passed in *pPageSize.\n**\n** If the pager is in the error state when this function is called, it\n** is a no-op. The value returned is the error state error code (i.e. \n** one of SQLITE_IOERR, an SQLITE_IOERR_xxx sub-code or SQLITE_FULL).\n**\n** Otherwise, if all of the following are true:\n**\n**   * the new page size (value of *pPageSize) is valid (a power \n**     of two between 512 and SQLITE_MAX_PAGE_SIZE, inclusive), and\n**\n**   * there are no outstanding page references, and\n**\n**   * the database is either not an in-memory database or it is\n**     an in-memory database that currently consists of zero pages.\n**\n** then the pager object page size is set to *pPageSize.\n**\n** If the page size is changed, then this function uses sqlite3PagerMalloc() \n** to obtain a new Pager.pTmpSpace buffer. If this allocation attempt \n** fails, SQLITE_NOMEM is returned and the page size remains unchanged. \n** In all other cases, SQLITE_OK is returned.\n**\n** If the page size is not changed, either because one of the enumerated\n** conditions above is not true, the pager was in error state when this\n** function was called, or because the memory allocation attempt failed, \n** then *pPageSize is set to the old, retained page size before returning.\n*/\nSQLITE_PRIVATE int sqlite3PagerSetPagesize(Pager *pPager, u32 *pPageSize, int nReserve){\n  int rc = SQLITE_OK;\n\n  /* It is not possible to do a full assert_pager_state() here, as this\n  ** function may be called from within PagerOpen(), before the state\n  ** of the Pager object is internally consistent.\n  **\n  ** At one point this function returned an error if the pager was in \n  ** PAGER_ERROR state. But since PAGER_ERROR state guarantees that\n  ** there is at least one outstanding page reference, this function\n  ** is a no-op for that case anyhow.\n  */\n\n  u32 pageSize = *pPageSize;\n  assert( pageSize==0 || (pageSize>=512 && pageSize<=SQLITE_MAX_PAGE_SIZE) );\n  if( (pPager->memDb==0 || pPager->dbSize==0)\n   && sqlite3PcacheRefCount(pPager->pPCache)==0 \n   && pageSize && pageSize!=(u32)pPager->pageSize \n  ){\n    char *pNew = NULL;             /* New temp space */\n    i64 nByte = 0;\n\n    if( pPager->eState>PAGER_OPEN && isOpen(pPager->fd) ){\n      rc = sqlite3OsFileSize(pPager->fd, &nByte);\n    }\n    if( rc==SQLITE_OK ){\n      pNew = (char *)sqlite3PageMalloc(pageSize);\n      if( !pNew ) rc = SQLITE_NOMEM;\n    }\n\n    if( rc==SQLITE_OK ){\n      pager_reset(pPager);\n      pPager->dbSize = (Pgno)(nByte/pageSize);\n      pPager->pageSize = pageSize;\n      sqlite3PageFree(pPager->pTmpSpace);\n      pPager->pTmpSpace = pNew;\n      sqlite3PcacheSetPageSize(pPager->pPCache, pageSize);\n    }\n  }\n\n  *pPageSize = pPager->pageSize;\n  if( rc==SQLITE_OK ){\n    if( nReserve<0 ) nReserve = pPager->nReserve;\n    assert( nReserve>=0 && nReserve<1000 );\n    pPager->nReserve = (i16)nReserve;\n    pagerReportSize(pPager);\n  }\n  return rc;\n}\n\n/*\n** Return a pointer to the \"temporary page\" buffer held internally\n** by the pager.  This is a buffer that is big enough to hold the\n** entire content of a database page.  This buffer is used internally\n** during rollback and will be overwritten whenever a rollback\n** occurs.  But other modules are free to use it too, as long as\n** no rollbacks are happening.\n*/\nSQLITE_PRIVATE void *sqlite3PagerTempSpace(Pager *pPager){\n  return pPager->pTmpSpace;\n}\n\n/*\n** Attempt to set the maximum database page count if mxPage is positive. \n** Make no changes if mxPage is zero or negative.  And never reduce the\n** maximum page count below the current size of the database.\n**\n** Regardless of mxPage, return the current maximum page count.\n*/\nSQLITE_PRIVATE int sqlite3PagerMaxPageCount(Pager *pPager, int mxPage){\n  if( mxPage>0 ){\n    pPager->mxPgno = mxPage;\n  }\n  assert( pPager->eState!=PAGER_OPEN );      /* Called only by OP_MaxPgcnt */\n  assert( pPager->mxPgno>=pPager->dbSize );  /* OP_MaxPgcnt enforces this */\n  return pPager->mxPgno;\n}\n\n/*\n** The following set of routines are used to disable the simulated\n** I/O error mechanism.  These routines are used to avoid simulated\n** errors in places where we do not care about errors.\n**\n** Unless -DSQLITE_TEST=1 is used, these routines are all no-ops\n** and generate no code.\n*/\n#ifdef SQLITE_TEST\nSQLITE_API extern int sqlite3_io_error_pending;\nSQLITE_API extern int sqlite3_io_error_hit;\nstatic int saved_cnt;\nvoid disable_simulated_io_errors(void){\n  saved_cnt = sqlite3_io_error_pending;\n  sqlite3_io_error_pending = -1;\n}\nvoid enable_simulated_io_errors(void){\n  sqlite3_io_error_pending = saved_cnt;\n}\n#else\n# define disable_simulated_io_errors()\n# define enable_simulated_io_errors()\n#endif\n\n/*\n** Read the first N bytes from the beginning of the file into memory\n** that pDest points to. \n**\n** If the pager was opened on a transient file (zFilename==\"\"), or\n** opened on a file less than N bytes in size, the output buffer is\n** zeroed and SQLITE_OK returned. The rationale for this is that this \n** function is used to read database headers, and a new transient or\n** zero sized database has a header than consists entirely of zeroes.\n**\n** If any IO error apart from SQLITE_IOERR_SHORT_READ is encountered,\n** the error code is returned to the caller and the contents of the\n** output buffer undefined.\n*/\nSQLITE_PRIVATE int sqlite3PagerReadFileheader(Pager *pPager, int N, unsigned char *pDest){\n  int rc = SQLITE_OK;\n  memset(pDest, 0, N);\n  assert( isOpen(pPager->fd) || pPager->tempFile );\n\n  /* This routine is only called by btree immediately after creating\n  ** the Pager object.  There has not been an opportunity to transition\n  ** to WAL mode yet.\n  */\n  assert( !pagerUseWal(pPager) );\n\n  if( isOpen(pPager->fd) ){\n    IOTRACE((\"DBHDR %p 0 %d\\n\", pPager, N))\n    rc = sqlite3OsRead(pPager->fd, pDest, N, 0);\n    if( rc==SQLITE_IOERR_SHORT_READ ){\n      rc = SQLITE_OK;\n    }\n  }\n  return rc;\n}\n\n/*\n** This function may only be called when a read-transaction is open on\n** the pager. It returns the total number of pages in the database.\n**\n** However, if the file is between 1 and <page-size> bytes in size, then \n** this is considered a 1 page file.\n*/\nSQLITE_PRIVATE void sqlite3PagerPagecount(Pager *pPager, int *pnPage){\n  assert( pPager->eState>=PAGER_READER );\n  assert( pPager->eState!=PAGER_WRITER_FINISHED );\n  *pnPage = (int)pPager->dbSize;\n}\n\n\n/*\n** Try to obtain a lock of type locktype on the database file. If\n** a similar or greater lock is already held, this function is a no-op\n** (returning SQLITE_OK immediately).\n**\n** Otherwise, attempt to obtain the lock using sqlite3OsLock(). Invoke \n** the busy callback if the lock is currently not available. Repeat \n** until the busy callback returns false or until the attempt to \n** obtain the lock succeeds.\n**\n** Return SQLITE_OK on success and an error code if we cannot obtain\n** the lock. If the lock is obtained successfully, set the Pager.state \n** variable to locktype before returning.\n*/\nstatic int pager_wait_on_lock(Pager *pPager, int locktype){\n  int rc;                              /* Return code */\n\n  /* Check that this is either a no-op (because the requested lock is \n  ** already held, or one of the transistions that the busy-handler\n  ** may be invoked during, according to the comment above\n  ** sqlite3PagerSetBusyhandler().\n  */\n  assert( (pPager->eLock>=locktype)\n       || (pPager->eLock==NO_LOCK && locktype==SHARED_LOCK)\n       || (pPager->eLock==RESERVED_LOCK && locktype==EXCLUSIVE_LOCK)\n  );\n\n  do {\n    rc = pagerLockDb(pPager, locktype);\n  }while( rc==SQLITE_BUSY && pPager->xBusyHandler(pPager->pBusyHandlerArg) );\n  return rc;\n}\n\n/*\n** Function assertTruncateConstraint(pPager) checks that one of the \n** following is true for all dirty pages currently in the page-cache:\n**\n**   a) The page number is less than or equal to the size of the \n**      current database image, in pages, OR\n**\n**   b) if the page content were written at this time, it would not\n**      be necessary to write the current content out to the sub-journal\n**      (as determined by function subjRequiresPage()).\n**\n** If the condition asserted by this function were not true, and the\n** dirty page were to be discarded from the cache via the pagerStress()\n** routine, pagerStress() would not write the current page content to\n** the database file. If a savepoint transaction were rolled back after\n** this happened, the correct behaviour would be to restore the current\n** content of the page. However, since this content is not present in either\n** the database file or the portion of the rollback journal and \n** sub-journal rolled back the content could not be restored and the\n** database image would become corrupt. It is therefore fortunate that \n** this circumstance cannot arise.\n*/\n#if defined(SQLITE_DEBUG)\nstatic void assertTruncateConstraintCb(PgHdr *pPg){\n  assert( pPg->flags&PGHDR_DIRTY );\n  assert( !subjRequiresPage(pPg) || pPg->pgno<=pPg->pPager->dbSize );\n}\nstatic void assertTruncateConstraint(Pager *pPager){\n  sqlite3PcacheIterateDirty(pPager->pPCache, assertTruncateConstraintCb);\n}\n#else\n# define assertTruncateConstraint(pPager)\n#endif\n\n/*\n** Truncate the in-memory database file image to nPage pages. This \n** function does not actually modify the database file on disk. It \n** just sets the internal state of the pager object so that the \n** truncation will be done when the current transaction is committed.\n*/\nSQLITE_PRIVATE void sqlite3PagerTruncateImage(Pager *pPager, Pgno nPage){\n  assert( pPager->dbSize>=nPage );\n  assert( pPager->eState>=PAGER_WRITER_CACHEMOD );\n  pPager->dbSize = nPage;\n  assertTruncateConstraint(pPager);\n}\n\n\n/*\n** This function is called before attempting a hot-journal rollback. It\n** syncs the journal file to disk, then sets pPager->journalHdr to the\n** size of the journal file so that the pager_playback() routine knows\n** that the entire journal file has been synced.\n**\n** Syncing a hot-journal to disk before attempting to roll it back ensures \n** that if a power-failure occurs during the rollback, the process that\n** attempts rollback following system recovery sees the same journal\n** content as this process.\n**\n** If everything goes as planned, SQLITE_OK is returned. Otherwise, \n** an SQLite error code.\n*/\nstatic int pagerSyncHotJournal(Pager *pPager){\n  int rc = SQLITE_OK;\n  if( !pPager->noSync ){\n    rc = sqlite3OsSync(pPager->jfd, SQLITE_SYNC_NORMAL);\n  }\n  if( rc==SQLITE_OK ){\n    rc = sqlite3OsFileSize(pPager->jfd, &pPager->journalHdr);\n  }\n  return rc;\n}\n\n/*\n** Shutdown the page cache.  Free all memory and close all files.\n**\n** If a transaction was in progress when this routine is called, that\n** transaction is rolled back.  All outstanding pages are invalidated\n** and their memory is freed.  Any attempt to use a page associated\n** with this page cache after this function returns will likely\n** result in a coredump.\n**\n** This function always succeeds. If a transaction is active an attempt\n** is made to roll it back. If an error occurs during the rollback \n** a hot journal may be left in the filesystem but no error is returned\n** to the caller.\n*/\nSQLITE_PRIVATE int sqlite3PagerClose(Pager *pPager){\n  u8 *pTmp = (u8 *)pPager->pTmpSpace;\n\n  disable_simulated_io_errors();\n  sqlite3BeginBenignMalloc();\n  /* pPager->errCode = 0; */\n  pPager->exclusiveMode = 0;\n#ifndef SQLITE_OMIT_WAL\n  sqlite3WalClose(pPager->pWal, pPager->ckptSyncFlags, pPager->pageSize, pTmp);\n  pPager->pWal = 0;\n#endif\n  pager_reset(pPager);\n  if( MEMDB ){\n    pager_unlock(pPager);\n  }else{\n    /* If it is open, sync the journal file before calling UnlockAndRollback.\n    ** If this is not done, then an unsynced portion of the open journal \n    ** file may be played back into the database. If a power failure occurs \n    ** while this is happening, the database could become corrupt.\n    **\n    ** If an error occurs while trying to sync the journal, shift the pager\n    ** into the ERROR state. This causes UnlockAndRollback to unlock the\n    ** database and close the journal file without attempting to roll it\n    ** back or finalize it. The next database user will have to do hot-journal\n    ** rollback before accessing the database file.\n    */\n    if( isOpen(pPager->jfd) ){\n      pager_error(pPager, pagerSyncHotJournal(pPager));\n    }\n    pagerUnlockAndRollback(pPager);\n  }\n  sqlite3EndBenignMalloc();\n  enable_simulated_io_errors();\n  PAGERTRACE((\"CLOSE %d\\n\", PAGERID(pPager)));\n  IOTRACE((\"CLOSE %p\\n\", pPager))\n  sqlite3OsClose(pPager->jfd);\n  sqlite3OsClose(pPager->fd);\n  sqlite3PageFree(pTmp);\n  sqlite3PcacheClose(pPager->pPCache);\n\n#ifdef SQLITE_HAS_CODEC\n  if( pPager->xCodecFree ) pPager->xCodecFree(pPager->pCodec);\n#endif\n\n  assert( !pPager->aSavepoint && !pPager->pInJournal );\n  assert( !isOpen(pPager->jfd) && !isOpen(pPager->sjfd) );\n\n  sqlite3_free(pPager);\n  return SQLITE_OK;\n}\n\n#if !defined(NDEBUG) || defined(SQLITE_TEST)\n/*\n** Return the page number for page pPg.\n*/\nSQLITE_PRIVATE Pgno sqlite3PagerPagenumber(DbPage *pPg){\n  return pPg->pgno;\n}\n#endif\n\n/*\n** Increment the reference count for page pPg.\n*/\nSQLITE_PRIVATE void sqlite3PagerRef(DbPage *pPg){\n  sqlite3PcacheRef(pPg);\n}\n\n/*\n** Sync the journal. In other words, make sure all the pages that have\n** been written to the journal have actually reached the surface of the\n** disk and can be restored in the event of a hot-journal rollback.\n**\n** If the Pager.noSync flag is set, then this function is a no-op.\n** Otherwise, the actions required depend on the journal-mode and the \n** device characteristics of the the file-system, as follows:\n**\n**   * If the journal file is an in-memory journal file, no action need\n**     be taken.\n**\n**   * Otherwise, if the device does not support the SAFE_APPEND property,\n**     then the nRec field of the most recently written journal header\n**     is updated to contain the number of journal records that have\n**     been written following it. If the pager is operating in full-sync\n**     mode, then the journal file is synced before this field is updated.\n**\n**   * If the device does not support the SEQUENTIAL property, then \n**     journal file is synced.\n**\n** Or, in pseudo-code:\n**\n**   if( NOT <in-memory journal> ){\n**     if( NOT SAFE_APPEND ){\n**       if( <full-sync mode> ) xSync(<journal file>);\n**       <update nRec field>\n**     } \n**     if( NOT SEQUENTIAL ) xSync(<journal file>);\n**   }\n**\n** If successful, this routine clears the PGHDR_NEED_SYNC flag of every \n** page currently held in memory before returning SQLITE_OK. If an IO\n** error is encountered, then the IO error code is returned to the caller.\n*/\nstatic int syncJournal(Pager *pPager, int newHdr){\n  int rc;                         /* Return code */\n\n  assert( pPager->eState==PAGER_WRITER_CACHEMOD\n       || pPager->eState==PAGER_WRITER_DBMOD\n  );\n  assert( assert_pager_state(pPager) );\n  assert( !pagerUseWal(pPager) );\n\n  rc = sqlite3PagerExclusiveLock(pPager);\n  if( rc!=SQLITE_OK ) return rc;\n\n  if( !pPager->noSync ){\n    assert( !pPager->tempFile );\n    if( isOpen(pPager->jfd) && pPager->journalMode!=PAGER_JOURNALMODE_MEMORY ){\n      const int iDc = sqlite3OsDeviceCharacteristics(pPager->fd);\n      assert( isOpen(pPager->jfd) );\n\n      if( 0==(iDc&SQLITE_IOCAP_SAFE_APPEND) ){\n        /* This block deals with an obscure problem. If the last connection\n        ** that wrote to this database was operating in persistent-journal\n        ** mode, then the journal file may at this point actually be larger\n        ** than Pager.journalOff bytes. If the next thing in the journal\n        ** file happens to be a journal-header (written as part of the\n        ** previous connection's transaction), and a crash or power-failure \n        ** occurs after nRec is updated but before this connection writes \n        ** anything else to the journal file (or commits/rolls back its \n        ** transaction), then SQLite may become confused when doing the \n        ** hot-journal rollback following recovery. It may roll back all\n        ** of this connections data, then proceed to rolling back the old,\n        ** out-of-date data that follows it. Database corruption.\n        **\n        ** To work around this, if the journal file does appear to contain\n        ** a valid header following Pager.journalOff, then write a 0x00\n        ** byte to the start of it to prevent it from being recognized.\n        **\n        ** Variable iNextHdrOffset is set to the offset at which this\n        ** problematic header will occur, if it exists. aMagic is used \n        ** as a temporary buffer to inspect the first couple of bytes of\n        ** the potential journal header.\n        */\n        i64 iNextHdrOffset;\n        u8 aMagic[8];\n        u8 zHeader[sizeof(aJournalMagic)+4];\n\n        memcpy(zHeader, aJournalMagic, sizeof(aJournalMagic));\n        put32bits(&zHeader[sizeof(aJournalMagic)], pPager->nRec);\n\n        iNextHdrOffset = journalHdrOffset(pPager);\n        rc = sqlite3OsRead(pPager->jfd, aMagic, 8, iNextHdrOffset);\n        if( rc==SQLITE_OK && 0==memcmp(aMagic, aJournalMagic, 8) ){\n          static const u8 zerobyte = 0;\n          rc = sqlite3OsWrite(pPager->jfd, &zerobyte, 1, iNextHdrOffset);\n        }\n        if( rc!=SQLITE_OK && rc!=SQLITE_IOERR_SHORT_READ ){\n          return rc;\n        }\n\n        /* Write the nRec value into the journal file header. If in\n        ** full-synchronous mode, sync the journal first. This ensures that\n        ** all data has really hit the disk before nRec is updated to mark\n        ** it as a candidate for rollback.\n        **\n        ** This is not required if the persistent media supports the\n        ** SAFE_APPEND property. Because in this case it is not possible \n        ** for garbage data to be appended to the file, the nRec field\n        ** is populated with 0xFFFFFFFF when the journal header is written\n        ** and never needs to be updated.\n        */\n        if( pPager->fullSync && 0==(iDc&SQLITE_IOCAP_SEQUENTIAL) ){\n          PAGERTRACE((\"SYNC journal of %d\\n\", PAGERID(pPager)));\n          IOTRACE((\"JSYNC %p\\n\", pPager))\n          rc = sqlite3OsSync(pPager->jfd, pPager->syncFlags);\n          if( rc!=SQLITE_OK ) return rc;\n        }\n        IOTRACE((\"JHDR %p %lld\\n\", pPager, pPager->journalHdr));\n        rc = sqlite3OsWrite(\n            pPager->jfd, zHeader, sizeof(zHeader), pPager->journalHdr\n        );\n        if( rc!=SQLITE_OK ) return rc;\n      }\n      if( 0==(iDc&SQLITE_IOCAP_SEQUENTIAL) ){\n        PAGERTRACE((\"SYNC journal of %d\\n\", PAGERID(pPager)));\n        IOTRACE((\"JSYNC %p\\n\", pPager))\n        rc = sqlite3OsSync(pPager->jfd, pPager->syncFlags| \n          (pPager->syncFlags==SQLITE_SYNC_FULL?SQLITE_SYNC_DATAONLY:0)\n        );\n        if( rc!=SQLITE_OK ) return rc;\n      }\n\n      pPager->journalHdr = pPager->journalOff;\n      if( newHdr && 0==(iDc&SQLITE_IOCAP_SAFE_APPEND) ){\n        pPager->nRec = 0;\n        rc = writeJournalHdr(pPager);\n        if( rc!=SQLITE_OK ) return rc;\n      }\n    }else{\n      pPager->journalHdr = pPager->journalOff;\n    }\n  }\n\n  /* Unless the pager is in noSync mode, the journal file was just \n  ** successfully synced. Either way, clear the PGHDR_NEED_SYNC flag on \n  ** all pages.\n  */\n  sqlite3PcacheClearSyncFlags(pPager->pPCache);\n  pPager->eState = PAGER_WRITER_DBMOD;\n  assert( assert_pager_state(pPager) );\n  return SQLITE_OK;\n}\n\n/*\n** The argument is the first in a linked list of dirty pages connected\n** by the PgHdr.pDirty pointer. This function writes each one of the\n** in-memory pages in the list to the database file. The argument may\n** be NULL, representing an empty list. In this case this function is\n** a no-op.\n**\n** The pager must hold at least a RESERVED lock when this function\n** is called. Before writing anything to the database file, this lock\n** is upgraded to an EXCLUSIVE lock. If the lock cannot be obtained,\n** SQLITE_BUSY is returned and no data is written to the database file.\n** \n** If the pager is a temp-file pager and the actual file-system file\n** is not yet open, it is created and opened before any data is \n** written out.\n**\n** Once the lock has been upgraded and, if necessary, the file opened,\n** the pages are written out to the database file in list order. Writing\n** a page is skipped if it meets either of the following criteria:\n**\n**   * The page number is greater than Pager.dbSize, or\n**   * The PGHDR_DONT_WRITE flag is set on the page.\n**\n** If writing out a page causes the database file to grow, Pager.dbFileSize\n** is updated accordingly. If page 1 is written out, then the value cached\n** in Pager.dbFileVers[] is updated to match the new value stored in\n** the database file.\n**\n** If everything is successful, SQLITE_OK is returned. If an IO error \n** occurs, an IO error code is returned. Or, if the EXCLUSIVE lock cannot\n** be obtained, SQLITE_BUSY is returned.\n*/\nstatic int pager_write_pagelist(Pager *pPager, PgHdr *pList){\n  int rc = SQLITE_OK;                  /* Return code */\n\n  /* This function is only called for rollback pagers in WRITER_DBMOD state. */\n  assert( !pagerUseWal(pPager) );\n  assert( pPager->eState==PAGER_WRITER_DBMOD );\n  assert( pPager->eLock==EXCLUSIVE_LOCK );\n\n  /* If the file is a temp-file has not yet been opened, open it now. It\n  ** is not possible for rc to be other than SQLITE_OK if this branch\n  ** is taken, as pager_wait_on_lock() is a no-op for temp-files.\n  */\n  if( !isOpen(pPager->fd) ){\n    assert( pPager->tempFile && rc==SQLITE_OK );\n    rc = pagerOpentemp(pPager, pPager->fd, pPager->vfsFlags);\n  }\n\n  /* Before the first write, give the VFS a hint of what the final\n  ** file size will be.\n  */\n  assert( rc!=SQLITE_OK || isOpen(pPager->fd) );\n  if( rc==SQLITE_OK && pPager->dbSize>pPager->dbHintSize ){\n    sqlite3_int64 szFile = pPager->pageSize * (sqlite3_int64)pPager->dbSize;\n    sqlite3OsFileControl(pPager->fd, SQLITE_FCNTL_SIZE_HINT, &szFile);\n    pPager->dbHintSize = pPager->dbSize;\n  }\n\n  while( rc==SQLITE_OK && pList ){\n    Pgno pgno = pList->pgno;\n\n    /* If there are dirty pages in the page cache with page numbers greater\n    ** than Pager.dbSize, this means sqlite3PagerTruncateImage() was called to\n    ** make the file smaller (presumably by auto-vacuum code). Do not write\n    ** any such pages to the file.\n    **\n    ** Also, do not write out any page that has the PGHDR_DONT_WRITE flag\n    ** set (set by sqlite3PagerDontWrite()).\n    */\n    if( pgno<=pPager->dbSize && 0==(pList->flags&PGHDR_DONT_WRITE) ){\n      i64 offset = (pgno-1)*(i64)pPager->pageSize;   /* Offset to write */\n      char *pData;                                   /* Data to write */    \n\n      assert( (pList->flags&PGHDR_NEED_SYNC)==0 );\n      if( pList->pgno==1 ) pager_write_changecounter(pList);\n\n      /* Encode the database */\n      CODEC2(pPager, pList->pData, pgno, 6, return SQLITE_NOMEM, pData);\n\n      /* Write out the page data. */\n      rc = sqlite3OsWrite(pPager->fd, pData, pPager->pageSize, offset);\n\n      /* If page 1 was just written, update Pager.dbFileVers to match\n      ** the value now stored in the database file. If writing this \n      ** page caused the database file to grow, update dbFileSize. \n      */\n      if( pgno==1 ){\n        memcpy(&pPager->dbFileVers, &pData[24], sizeof(pPager->dbFileVers));\n      }\n      if( pgno>pPager->dbFileSize ){\n        pPager->dbFileSize = pgno;\n      }\n\n      /* Update any backup objects copying the contents of this pager. */\n      sqlite3BackupUpdate(pPager->pBackup, pgno, (u8*)pList->pData);\n\n      PAGERTRACE((\"STORE %d page %d hash(%08x)\\n\",\n                   PAGERID(pPager), pgno, pager_pagehash(pList)));\n      IOTRACE((\"PGOUT %p %d\\n\", pPager, pgno));\n      PAGER_INCR(sqlite3_pager_writedb_count);\n      PAGER_INCR(pPager->nWrite);\n    }else{\n      PAGERTRACE((\"NOSTORE %d page %d\\n\", PAGERID(pPager), pgno));\n    }\n    pager_set_pagehash(pList);\n    pList = pList->pDirty;\n  }\n\n  return rc;\n}\n\n/*\n** Ensure that the sub-journal file is open. If it is already open, this \n** function is a no-op.\n**\n** SQLITE_OK is returned if everything goes according to plan. An \n** SQLITE_IOERR_XXX error code is returned if a call to sqlite3OsOpen() \n** fails.\n*/\nstatic int openSubJournal(Pager *pPager){\n  int rc = SQLITE_OK;\n  if( !isOpen(pPager->sjfd) ){\n    if( pPager->journalMode==PAGER_JOURNALMODE_MEMORY || pPager->subjInMemory ){\n      sqlite3MemJournalOpen(pPager->sjfd);\n    }else{\n      rc = pagerOpentemp(pPager, pPager->sjfd, SQLITE_OPEN_SUBJOURNAL);\n    }\n  }\n  return rc;\n}\n\n/*\n** Append a record of the current state of page pPg to the sub-journal. \n** It is the callers responsibility to use subjRequiresPage() to check \n** that it is really required before calling this function.\n**\n** If successful, set the bit corresponding to pPg->pgno in the bitvecs\n** for all open savepoints before returning.\n**\n** This function returns SQLITE_OK if everything is successful, an IO\n** error code if the attempt to write to the sub-journal fails, or \n** SQLITE_NOMEM if a malloc fails while setting a bit in a savepoint\n** bitvec.\n*/\nstatic int subjournalPage(PgHdr *pPg){\n  int rc = SQLITE_OK;\n  Pager *pPager = pPg->pPager;\n  if( pPager->journalMode!=PAGER_JOURNALMODE_OFF ){\n\n    /* Open the sub-journal, if it has not already been opened */\n    assert( pPager->useJournal );\n    assert( isOpen(pPager->jfd) || pagerUseWal(pPager) );\n    assert( isOpen(pPager->sjfd) || pPager->nSubRec==0 );\n    assert( pagerUseWal(pPager) \n         || pageInJournal(pPg) \n         || pPg->pgno>pPager->dbOrigSize \n    );\n    rc = openSubJournal(pPager);\n\n    /* If the sub-journal was opened successfully (or was already open),\n    ** write the journal record into the file.  */\n    if( rc==SQLITE_OK ){\n      void *pData = pPg->pData;\n      i64 offset = pPager->nSubRec*(4+pPager->pageSize);\n      char *pData2;\n  \n      CODEC2(pPager, pData, pPg->pgno, 7, return SQLITE_NOMEM, pData2);\n      PAGERTRACE((\"STMT-JOURNAL %d page %d\\n\", PAGERID(pPager), pPg->pgno));\n      rc = write32bits(pPager->sjfd, offset, pPg->pgno);\n      if( rc==SQLITE_OK ){\n        rc = sqlite3OsWrite(pPager->sjfd, pData2, pPager->pageSize, offset+4);\n      }\n    }\n  }\n  if( rc==SQLITE_OK ){\n    pPager->nSubRec++;\n    assert( pPager->nSavepoint>0 );\n    rc = addToSavepointBitvecs(pPager, pPg->pgno);\n  }\n  return rc;\n}\n\n/*\n** This function is called by the pcache layer when it has reached some\n** soft memory limit. The first argument is a pointer to a Pager object\n** (cast as a void*). The pager is always 'purgeable' (not an in-memory\n** database). The second argument is a reference to a page that is \n** currently dirty but has no outstanding references. The page\n** is always associated with the Pager object passed as the first \n** argument.\n**\n** The job of this function is to make pPg clean by writing its contents\n** out to the database file, if possible. This may involve syncing the\n** journal file. \n**\n** If successful, sqlite3PcacheMakeClean() is called on the page and\n** SQLITE_OK returned. If an IO error occurs while trying to make the\n** page clean, the IO error code is returned. If the page cannot be\n** made clean for some other reason, but no error occurs, then SQLITE_OK\n** is returned by sqlite3PcacheMakeClean() is not called.\n*/\nstatic int pagerStress(void *p, PgHdr *pPg){\n  Pager *pPager = (Pager *)p;\n  int rc = SQLITE_OK;\n\n  assert( pPg->pPager==pPager );\n  assert( pPg->flags&PGHDR_DIRTY );\n\n  /* The doNotSyncSpill flag is set during times when doing a sync of\n  ** journal (and adding a new header) is not allowed.  This occurs\n  ** during calls to sqlite3PagerWrite() while trying to journal multiple\n  ** pages belonging to the same sector.\n  **\n  ** The doNotSpill flag inhibits all cache spilling regardless of whether\n  ** or not a sync is required.  This is set during a rollback.\n  **\n  ** Spilling is also prohibited when in an error state since that could\n  ** lead to database corruption.   In the current implementaton it \n  ** is impossible for sqlite3PCacheFetch() to be called with createFlag==1\n  ** while in the error state, hence it is impossible for this routine to\n  ** be called in the error state.  Nevertheless, we include a NEVER()\n  ** test for the error state as a safeguard against future changes.\n  */\n  if( NEVER(pPager->errCode) ) return SQLITE_OK;\n  if( pPager->doNotSpill ) return SQLITE_OK;\n  if( pPager->doNotSyncSpill && (pPg->flags & PGHDR_NEED_SYNC)!=0 ){\n    return SQLITE_OK;\n  }\n\n  pPg->pDirty = 0;\n  if( pagerUseWal(pPager) ){\n    /* Write a single frame for this page to the log. */\n    if( subjRequiresPage(pPg) ){ \n      rc = subjournalPage(pPg); \n    }\n    if( rc==SQLITE_OK ){\n      rc = pagerWalFrames(pPager, pPg, 0, 0, 0);\n    }\n  }else{\n  \n    /* Sync the journal file if required. */\n    if( pPg->flags&PGHDR_NEED_SYNC \n     || pPager->eState==PAGER_WRITER_CACHEMOD\n    ){\n      rc = syncJournal(pPager, 1);\n    }\n  \n    /* If the page number of this page is larger than the current size of\n    ** the database image, it may need to be written to the sub-journal.\n    ** This is because the call to pager_write_pagelist() below will not\n    ** actually write data to the file in this case.\n    **\n    ** Consider the following sequence of events:\n    **\n    **   BEGIN;\n    **     <journal page X>\n    **     <modify page X>\n    **     SAVEPOINT sp;\n    **       <shrink database file to Y pages>\n    **       pagerStress(page X)\n    **     ROLLBACK TO sp;\n    **\n    ** If (X>Y), then when pagerStress is called page X will not be written\n    ** out to the database file, but will be dropped from the cache. Then,\n    ** following the \"ROLLBACK TO sp\" statement, reading page X will read\n    ** data from the database file. This will be the copy of page X as it\n    ** was when the transaction started, not as it was when \"SAVEPOINT sp\"\n    ** was executed.\n    **\n    ** The solution is to write the current data for page X into the \n    ** sub-journal file now (if it is not already there), so that it will\n    ** be restored to its current value when the \"ROLLBACK TO sp\" is \n    ** executed.\n    */\n    if( NEVER(\n        rc==SQLITE_OK && pPg->pgno>pPager->dbSize && subjRequiresPage(pPg)\n    ) ){\n      rc = subjournalPage(pPg);\n    }\n  \n    /* Write the contents of the page out to the database file. */\n    if( rc==SQLITE_OK ){\n      assert( (pPg->flags&PGHDR_NEED_SYNC)==0 );\n      rc = pager_write_pagelist(pPager, pPg);\n    }\n  }\n\n  /* Mark the page as clean. */\n  if( rc==SQLITE_OK ){\n    PAGERTRACE((\"STRESS %d page %d\\n\", PAGERID(pPager), pPg->pgno));\n    sqlite3PcacheMakeClean(pPg);\n  }\n\n  return pager_error(pPager, rc); \n}\n\n\n/*\n** Allocate and initialize a new Pager object and put a pointer to it\n** in *ppPager. The pager should eventually be freed by passing it\n** to sqlite3PagerClose().\n**\n** The zFilename argument is the path to the database file to open.\n** If zFilename is NULL then a randomly-named temporary file is created\n** and used as the file to be cached. Temporary files are be deleted\n** automatically when they are closed. If zFilename is \":memory:\" then \n** all information is held in cache. It is never written to disk. \n** This can be used to implement an in-memory database.\n**\n** The nExtra parameter specifies the number of bytes of space allocated\n** along with each page reference. This space is available to the user\n** via the sqlite3PagerGetExtra() API.\n**\n** The flags argument is used to specify properties that affect the\n** operation of the pager. It should be passed some bitwise combination\n** of the PAGER_OMIT_JOURNAL and PAGER_NO_READLOCK flags.\n**\n** The vfsFlags parameter is a bitmask to pass to the flags parameter\n** of the xOpen() method of the supplied VFS when opening files. \n**\n** If the pager object is allocated and the specified file opened \n** successfully, SQLITE_OK is returned and *ppPager set to point to\n** the new pager object. If an error occurs, *ppPager is set to NULL\n** and error code returned. This function may return SQLITE_NOMEM\n** (sqlite3Malloc() is used to allocate memory), SQLITE_CANTOPEN or \n** various SQLITE_IO_XXX errors.\n*/\nSQLITE_PRIVATE int sqlite3PagerOpen(\n  sqlite3_vfs *pVfs,       /* The virtual file system to use */\n  Pager **ppPager,         /* OUT: Return the Pager structure here */\n  const char *zFilename,   /* Name of the database file to open */\n  int nExtra,              /* Extra bytes append to each in-memory page */\n  int flags,               /* flags controlling this file */\n  int vfsFlags,            /* flags passed through to sqlite3_vfs.xOpen() */\n  void (*xReinit)(DbPage*) /* Function to reinitialize pages */\n){\n  u8 *pPtr;\n  Pager *pPager = 0;       /* Pager object to allocate and return */\n  int rc = SQLITE_OK;      /* Return code */\n  int tempFile = 0;        /* True for temp files (incl. in-memory files) */\n  int memDb = 0;           /* True if this is an in-memory file */\n  int readOnly = 0;        /* True if this is a read-only file */\n  int journalFileSize;     /* Bytes to allocate for each journal fd */\n  char *zPathname = 0;     /* Full path to database file */\n  int nPathname = 0;       /* Number of bytes in zPathname */\n  int useJournal = (flags & PAGER_OMIT_JOURNAL)==0; /* False to omit journal */\n  int noReadlock = (flags & PAGER_NO_READLOCK)!=0;  /* True to omit read-lock */\n  int pcacheSize = sqlite3PcacheSize();       /* Bytes to allocate for PCache */\n  u32 szPageDflt = SQLITE_DEFAULT_PAGE_SIZE;  /* Default page size */\n\n  /* Figure out how much space is required for each journal file-handle\n  ** (there are two of them, the main journal and the sub-journal). This\n  ** is the maximum space required for an in-memory journal file handle \n  ** and a regular journal file-handle. Note that a \"regular journal-handle\"\n  ** may be a wrapper capable of caching the first portion of the journal\n  ** file in memory to implement the atomic-write optimization (see \n  ** source file journal.c).\n  */\n  if( sqlite3JournalSize(pVfs)>sqlite3MemJournalSize() ){\n    journalFileSize = ROUND8(sqlite3JournalSize(pVfs));\n  }else{\n    journalFileSize = ROUND8(sqlite3MemJournalSize());\n  }\n\n  /* Set the output variable to NULL in case an error occurs. */\n  *ppPager = 0;\n\n#ifndef SQLITE_OMIT_MEMORYDB\n  if( flags & PAGER_MEMORY ){\n    memDb = 1;\n    zFilename = 0;\n  }\n#endif\n\n  /* Compute and store the full pathname in an allocated buffer pointed\n  ** to by zPathname, length nPathname. Or, if this is a temporary file,\n  ** leave both nPathname and zPathname set to 0.\n  */\n  if( zFilename && zFilename[0] ){\n    nPathname = pVfs->mxPathname+1;\n    zPathname = sqlite3Malloc(nPathname*2);\n    if( zPathname==0 ){\n      return SQLITE_NOMEM;\n    }\n    zPathname[0] = 0; /* Make sure initialized even if FullPathname() fails */\n    rc = sqlite3OsFullPathname(pVfs, zFilename, nPathname, zPathname);\n    nPathname = sqlite3Strlen30(zPathname);\n    if( rc==SQLITE_OK && nPathname+8>pVfs->mxPathname ){\n      /* This branch is taken when the journal path required by\n      ** the database being opened will be more than pVfs->mxPathname\n      ** bytes in length. This means the database cannot be opened,\n      ** as it will not be possible to open the journal file or even\n      ** check for a hot-journal before reading.\n      */\n      rc = SQLITE_CANTOPEN_BKPT;\n    }\n    if( rc!=SQLITE_OK ){\n      sqlite3_free(zPathname);\n      return rc;\n    }\n  }\n\n  /* Allocate memory for the Pager structure, PCache object, the\n  ** three file descriptors, the database file name and the journal \n  ** file name. The layout in memory is as follows:\n  **\n  **     Pager object                    (sizeof(Pager) bytes)\n  **     PCache object                   (sqlite3PcacheSize() bytes)\n  **     Database file handle            (pVfs->szOsFile bytes)\n  **     Sub-journal file handle         (journalFileSize bytes)\n  **     Main journal file handle        (journalFileSize bytes)\n  **     Database file name              (nPathname+1 bytes)\n  **     Journal file name               (nPathname+8+1 bytes)\n  */\n  pPtr = (u8 *)sqlite3MallocZero(\n    ROUND8(sizeof(*pPager)) +      /* Pager structure */\n    ROUND8(pcacheSize) +           /* PCache object */\n    ROUND8(pVfs->szOsFile) +       /* The main db file */\n    journalFileSize * 2 +          /* The two journal files */ \n    nPathname + 1 +                /* zFilename */\n    nPathname + 8 + 1              /* zJournal */\n#ifndef SQLITE_OMIT_WAL\n    + nPathname + 4 + 1              /* zWal */\n#endif\n  );\n  assert( EIGHT_BYTE_ALIGNMENT(SQLITE_INT_TO_PTR(journalFileSize)) );\n  if( !pPtr ){\n    sqlite3_free(zPathname);\n    return SQLITE_NOMEM;\n  }\n  pPager =              (Pager*)(pPtr);\n  pPager->pPCache =    (PCache*)(pPtr += ROUND8(sizeof(*pPager)));\n  pPager->fd =   (sqlite3_file*)(pPtr += ROUND8(pcacheSize));\n  pPager->sjfd = (sqlite3_file*)(pPtr += ROUND8(pVfs->szOsFile));\n  pPager->jfd =  (sqlite3_file*)(pPtr += journalFileSize);\n  pPager->zFilename =    (char*)(pPtr += journalFileSize);\n  assert( EIGHT_BYTE_ALIGNMENT(pPager->jfd) );\n\n  /* Fill in the Pager.zFilename and Pager.zJournal buffers, if required. */\n  if( zPathname ){\n    assert( nPathname>0 );\n    pPager->zJournal =   (char*)(pPtr += nPathname + 1);\n    memcpy(pPager->zFilename, zPathname, nPathname);\n    memcpy(pPager->zJournal, zPathname, nPathname);\n    memcpy(&pPager->zJournal[nPathname], \"-journal\", 8);\n#ifndef SQLITE_OMIT_WAL\n    pPager->zWal = &pPager->zJournal[nPathname+8+1];\n    memcpy(pPager->zWal, zPathname, nPathname);\n    memcpy(&pPager->zWal[nPathname], \"-wal\", 4);\n#endif\n    sqlite3_free(zPathname);\n  }\n  pPager->pVfs = pVfs;\n  pPager->vfsFlags = vfsFlags;\n\n  /* Open the pager file.\n  */\n  if( zFilename && zFilename[0] ){\n    int fout = 0;                    /* VFS flags returned by xOpen() */\n    rc = sqlite3OsOpen(pVfs, pPager->zFilename, pPager->fd, vfsFlags, &fout);\n    assert( !memDb );\n    readOnly = (fout&SQLITE_OPEN_READONLY);\n\n    /* If the file was successfully opened for read/write access,\n    ** choose a default page size in case we have to create the\n    ** database file. The default page size is the maximum of:\n    **\n    **    + SQLITE_DEFAULT_PAGE_SIZE,\n    **    + The value returned by sqlite3OsSectorSize()\n    **    + The largest page size that can be written atomically.\n    */\n    if( rc==SQLITE_OK && !readOnly ){\n      setSectorSize(pPager);\n      assert(SQLITE_DEFAULT_PAGE_SIZE<=SQLITE_MAX_DEFAULT_PAGE_SIZE);\n      if( szPageDflt<pPager->sectorSize ){\n        if( pPager->sectorSize>SQLITE_MAX_DEFAULT_PAGE_SIZE ){\n          szPageDflt = SQLITE_MAX_DEFAULT_PAGE_SIZE;\n        }else{\n          szPageDflt = (u32)pPager->sectorSize;\n        }\n      }\n#ifdef SQLITE_ENABLE_ATOMIC_WRITE\n      {\n        int iDc = sqlite3OsDeviceCharacteristics(pPager->fd);\n        int ii;\n        assert(SQLITE_IOCAP_ATOMIC512==(512>>8));\n        assert(SQLITE_IOCAP_ATOMIC64K==(65536>>8));\n        assert(SQLITE_MAX_DEFAULT_PAGE_SIZE<=65536);\n        for(ii=szPageDflt; ii<=SQLITE_MAX_DEFAULT_PAGE_SIZE; ii=ii*2){\n          if( iDc&(SQLITE_IOCAP_ATOMIC|(ii>>8)) ){\n            szPageDflt = ii;\n          }\n        }\n      }\n#endif\n    }\n  }else{\n    /* If a temporary file is requested, it is not opened immediately.\n    ** In this case we accept the default page size and delay actually\n    ** opening the file until the first call to OsWrite().\n    **\n    ** This branch is also run for an in-memory database. An in-memory\n    ** database is the same as a temp-file that is never written out to\n    ** disk and uses an in-memory rollback journal.\n    */ \n    tempFile = 1;\n    pPager->eState = PAGER_READER;\n    pPager->eLock = EXCLUSIVE_LOCK;\n    readOnly = (vfsFlags&SQLITE_OPEN_READONLY);\n  }\n\n  /* The following call to PagerSetPagesize() serves to set the value of \n  ** Pager.pageSize and to allocate the Pager.pTmpSpace buffer.\n  */\n  if( rc==SQLITE_OK ){\n    assert( pPager->memDb==0 );\n    rc = sqlite3PagerSetPagesize(pPager, &szPageDflt, -1);\n    testcase( rc!=SQLITE_OK );\n  }\n\n  /* If an error occurred in either of the blocks above, free the \n  ** Pager structure and close the file.\n  */\n  if( rc!=SQLITE_OK ){\n    assert( !pPager->pTmpSpace );\n    sqlite3OsClose(pPager->fd);\n    sqlite3_free(pPager);\n    return rc;\n  }\n\n  /* Initialize the PCache object. */\n  assert( nExtra<1000 );\n  nExtra = ROUND8(nExtra);\n  sqlite3PcacheOpen(szPageDflt, nExtra, !memDb,\n                    !memDb?pagerStress:0, (void *)pPager, pPager->pPCache);\n\n  PAGERTRACE((\"OPEN %d %s\\n\", FILEHANDLEID(pPager->fd), pPager->zFilename));\n  IOTRACE((\"OPEN %p %s\\n\", pPager, pPager->zFilename))\n\n  pPager->useJournal = (u8)useJournal;\n  pPager->noReadlock = (noReadlock && readOnly) ?1:0;\n  /* pPager->stmtOpen = 0; */\n  /* pPager->stmtInUse = 0; */\n  /* pPager->nRef = 0; */\n  /* pPager->stmtSize = 0; */\n  /* pPager->stmtJSize = 0; */\n  /* pPager->nPage = 0; */\n  pPager->mxPgno = SQLITE_MAX_PAGE_COUNT;\n  /* pPager->state = PAGER_UNLOCK; */\n#if 0\n  assert( pPager->state == (tempFile ? PAGER_EXCLUSIVE : PAGER_UNLOCK) );\n#endif\n  /* pPager->errMask = 0; */\n  pPager->tempFile = (u8)tempFile;\n  assert( tempFile==PAGER_LOCKINGMODE_NORMAL \n          || tempFile==PAGER_LOCKINGMODE_EXCLUSIVE );\n  assert( PAGER_LOCKINGMODE_EXCLUSIVE==1 );\n  pPager->exclusiveMode = (u8)tempFile; \n  pPager->changeCountDone = pPager->tempFile;\n  pPager->memDb = (u8)memDb;\n  pPager->readOnly = (u8)readOnly;\n  assert( useJournal || pPager->tempFile );\n  pPager->noSync = pPager->tempFile;\n  pPager->fullSync = pPager->noSync ?0:1;\n  pPager->syncFlags = pPager->noSync ? 0 : SQLITE_SYNC_NORMAL;\n  pPager->ckptSyncFlags = pPager->syncFlags;\n  /* pPager->pFirst = 0; */\n  /* pPager->pFirstSynced = 0; */\n  /* pPager->pLast = 0; */\n  pPager->nExtra = (u16)nExtra;\n  pPager->journalSizeLimit = SQLITE_DEFAULT_JOURNAL_SIZE_LIMIT;\n  assert( isOpen(pPager->fd) || tempFile );\n  setSectorSize(pPager);\n  if( !useJournal ){\n    pPager->journalMode = PAGER_JOURNALMODE_OFF;\n  }else if( memDb ){\n    pPager->journalMode = PAGER_JOURNALMODE_MEMORY;\n  }\n  /* pPager->xBusyHandler = 0; */\n  /* pPager->pBusyHandlerArg = 0; */\n  pPager->xReiniter = xReinit;\n  /* memset(pPager->aHash, 0, sizeof(pPager->aHash)); */\n\n  *ppPager = pPager;\n  return SQLITE_OK;\n}\n\n\n\n/*\n** This function is called after transitioning from PAGER_UNLOCK to\n** PAGER_SHARED state. It tests if there is a hot journal present in\n** the file-system for the given pager. A hot journal is one that \n** needs to be played back. According to this function, a hot-journal\n** file exists if the following criteria are met:\n**\n**   * The journal file exists in the file system, and\n**   * No process holds a RESERVED or greater lock on the database file, and\n**   * The database file itself is greater than 0 bytes in size, and\n**   * The first byte of the journal file exists and is not 0x00.\n**\n** If the current size of the database file is 0 but a journal file\n** exists, that is probably an old journal left over from a prior\n** database with the same name. In this case the journal file is\n** just deleted using OsDelete, *pExists is set to 0 and SQLITE_OK\n** is returned.\n**\n** This routine does not check if there is a master journal filename\n** at the end of the file. If there is, and that master journal file\n** does not exist, then the journal file is not really hot. In this\n** case this routine will return a false-positive. The pager_playback()\n** routine will discover that the journal file is not really hot and \n** will not roll it back. \n**\n** If a hot-journal file is found to exist, *pExists is set to 1 and \n** SQLITE_OK returned. If no hot-journal file is present, *pExists is\n** set to 0 and SQLITE_OK returned. If an IO error occurs while trying\n** to determine whether or not a hot-journal file exists, the IO error\n** code is returned and the value of *pExists is undefined.\n*/\nstatic int hasHotJournal(Pager *pPager, int *pExists){\n  sqlite3_vfs * const pVfs = pPager->pVfs;\n  int rc = SQLITE_OK;           /* Return code */\n  int exists = 1;               /* True if a journal file is present */\n  int jrnlOpen = !!isOpen(pPager->jfd);\n\n  assert( pPager->useJournal );\n  assert( isOpen(pPager->fd) );\n  assert( pPager->eState==PAGER_OPEN );\n\n  assert( jrnlOpen==0 || ( sqlite3OsDeviceCharacteristics(pPager->jfd) &\n    SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN\n  ));\n\n  *pExists = 0;\n  if( !jrnlOpen ){\n    rc = sqlite3OsAccess(pVfs, pPager->zJournal, SQLITE_ACCESS_EXISTS, &exists);\n  }\n  if( rc==SQLITE_OK && exists ){\n    int locked = 0;             /* True if some process holds a RESERVED lock */\n\n    /* Race condition here:  Another process might have been holding the\n    ** the RESERVED lock and have a journal open at the sqlite3OsAccess() \n    ** call above, but then delete the journal and drop the lock before\n    ** we get to the following sqlite3OsCheckReservedLock() call.  If that\n    ** is the case, this routine might think there is a hot journal when\n    ** in fact there is none.  This results in a false-positive which will\n    ** be dealt with by the playback routine.  Ticket #3883.\n    */\n    rc = sqlite3OsCheckReservedLock(pPager->fd, &locked);\n    if( rc==SQLITE_OK && !locked ){\n      Pgno nPage;                 /* Number of pages in database file */\n\n      /* Check the size of the database file. If it consists of 0 pages,\n      ** then delete the journal file. See the header comment above for \n      ** the reasoning here.  Delete the obsolete journal file under\n      ** a RESERVED lock to avoid race conditions and to avoid violating\n      ** [H33020].\n      */\n      rc = pagerPagecount(pPager, &nPage);\n      if( rc==SQLITE_OK ){\n        if( nPage==0 ){\n          sqlite3BeginBenignMalloc();\n          if( pagerLockDb(pPager, RESERVED_LOCK)==SQLITE_OK ){\n            sqlite3OsDelete(pVfs, pPager->zJournal, 0);\n            if( !pPager->exclusiveMode ) pagerUnlockDb(pPager, SHARED_LOCK);\n          }\n          sqlite3EndBenignMalloc();\n        }else{\n          /* The journal file exists and no other connection has a reserved\n          ** or greater lock on the database file. Now check that there is\n          ** at least one non-zero bytes at the start of the journal file.\n          ** If there is, then we consider this journal to be hot. If not, \n          ** it can be ignored.\n          */\n          if( !jrnlOpen ){\n            int f = SQLITE_OPEN_READONLY|SQLITE_OPEN_MAIN_JOURNAL;\n            rc = sqlite3OsOpen(pVfs, pPager->zJournal, pPager->jfd, f, &f);\n          }\n          if( rc==SQLITE_OK ){\n            u8 first = 0;\n            rc = sqlite3OsRead(pPager->jfd, (void *)&first, 1, 0);\n            if( rc==SQLITE_IOERR_SHORT_READ ){\n              rc = SQLITE_OK;\n            }\n            if( !jrnlOpen ){\n              sqlite3OsClose(pPager->jfd);\n            }\n            *pExists = (first!=0);\n          }else if( rc==SQLITE_CANTOPEN ){\n            /* If we cannot open the rollback journal file in order to see if\n            ** its has a zero header, that might be due to an I/O error, or\n            ** it might be due to the race condition described above and in\n            ** ticket #3883.  Either way, assume that the journal is hot.\n            ** This might be a false positive.  But if it is, then the\n            ** automatic journal playback and recovery mechanism will deal\n            ** with it under an EXCLUSIVE lock where we do not need to\n            ** worry so much with race conditions.\n            */\n            *pExists = 1;\n            rc = SQLITE_OK;\n          }\n        }\n      }\n    }\n  }\n\n  return rc;\n}\n\n/*\n** This function is called to obtain a shared lock on the database file.\n** It is illegal to call sqlite3PagerAcquire() until after this function\n** has been successfully called. If a shared-lock is already held when\n** this function is called, it is a no-op.\n**\n** The following operations are also performed by this function.\n**\n**   1) If the pager is currently in PAGER_OPEN state (no lock held\n**      on the database file), then an attempt is made to obtain a\n**      SHARED lock on the database file. Immediately after obtaining\n**      the SHARED lock, the file-system is checked for a hot-journal,\n**      which is played back if present. Following any hot-journal \n**      rollback, the contents of the cache are validated by checking\n**      the 'change-counter' field of the database file header and\n**      discarded if they are found to be invalid.\n**\n**   2) If the pager is running in exclusive-mode, and there are currently\n**      no outstanding references to any pages, and is in the error state,\n**      then an attempt is made to clear the error state by discarding\n**      the contents of the page cache and rolling back any open journal\n**      file.\n**\n** If everything is successful, SQLITE_OK is returned. If an IO error \n** occurs while locking the database, checking for a hot-journal file or \n** rolling back a journal file, the IO error code is returned.\n*/\nSQLITE_PRIVATE int sqlite3PagerSharedLock(Pager *pPager){\n  int rc = SQLITE_OK;                /* Return code */\n\n  /* This routine is only called from b-tree and only when there are no\n  ** outstanding pages. This implies that the pager state should either\n  ** be OPEN or READER. READER is only possible if the pager is or was in \n  ** exclusive access mode.\n  */\n  assert( sqlite3PcacheRefCount(pPager->pPCache)==0 );\n  assert( assert_pager_state(pPager) );\n  assert( pPager->eState==PAGER_OPEN || pPager->eState==PAGER_READER );\n  if( NEVER(MEMDB && pPager->errCode) ){ return pPager->errCode; }\n\n  if( !pagerUseWal(pPager) && pPager->eState==PAGER_OPEN ){\n    int bHotJournal = 1;          /* True if there exists a hot journal-file */\n\n    assert( !MEMDB );\n    assert( pPager->noReadlock==0 || pPager->readOnly );\n\n    if( pPager->noReadlock==0 ){\n      rc = pager_wait_on_lock(pPager, SHARED_LOCK);\n      if( rc!=SQLITE_OK ){\n        assert( pPager->eLock==NO_LOCK || pPager->eLock==UNKNOWN_LOCK );\n        goto failed;\n      }\n    }\n\n    /* If a journal file exists, and there is no RESERVED lock on the\n    ** database file, then it either needs to be played back or deleted.\n    */\n    if( pPager->eLock<=SHARED_LOCK ){\n      rc = hasHotJournal(pPager, &bHotJournal);\n    }\n    if( rc!=SQLITE_OK ){\n      goto failed;\n    }\n    if( bHotJournal ){\n      /* Get an EXCLUSIVE lock on the database file. At this point it is\n      ** important that a RESERVED lock is not obtained on the way to the\n      ** EXCLUSIVE lock. If it were, another process might open the\n      ** database file, detect the RESERVED lock, and conclude that the\n      ** database is safe to read while this process is still rolling the \n      ** hot-journal back.\n      ** \n      ** Because the intermediate RESERVED lock is not requested, any\n      ** other process attempting to access the database file will get to \n      ** this point in the code and fail to obtain its own EXCLUSIVE lock \n      ** on the database file.\n      **\n      ** Unless the pager is in locking_mode=exclusive mode, the lock is\n      ** downgraded to SHARED_LOCK before this function returns.\n      */\n      rc = pagerLockDb(pPager, EXCLUSIVE_LOCK);\n      if( rc!=SQLITE_OK ){\n        goto failed;\n      }\n \n      /* If it is not already open and the file exists on disk, open the \n      ** journal for read/write access. Write access is required because \n      ** in exclusive-access mode the file descriptor will be kept open \n      ** and possibly used for a transaction later on. Also, write-access \n      ** is usually required to finalize the journal in journal_mode=persist \n      ** mode (and also for journal_mode=truncate on some systems).\n      **\n      ** If the journal does not exist, it usually means that some \n      ** other connection managed to get in and roll it back before \n      ** this connection obtained the exclusive lock above. Or, it \n      ** may mean that the pager was in the error-state when this\n      ** function was called and the journal file does not exist.\n      */\n      if( !isOpen(pPager->jfd) ){\n        sqlite3_vfs * const pVfs = pPager->pVfs;\n        int bExists;              /* True if journal file exists */\n        rc = sqlite3OsAccess(\n            pVfs, pPager->zJournal, SQLITE_ACCESS_EXISTS, &bExists);\n        if( rc==SQLITE_OK && bExists ){\n          int fout = 0;\n          int f = SQLITE_OPEN_READWRITE|SQLITE_OPEN_MAIN_JOURNAL;\n          assert( !pPager->tempFile );\n          rc = sqlite3OsOpen(pVfs, pPager->zJournal, pPager->jfd, f, &fout);\n          assert( rc!=SQLITE_OK || isOpen(pPager->jfd) );\n          if( rc==SQLITE_OK && fout&SQLITE_OPEN_READONLY ){\n            rc = SQLITE_CANTOPEN_BKPT;\n            sqlite3OsClose(pPager->jfd);\n          }\n        }\n      }\n \n      /* Playback and delete the journal.  Drop the database write\n      ** lock and reacquire the read lock. Purge the cache before\n      ** playing back the hot-journal so that we don't end up with\n      ** an inconsistent cache.  Sync the hot journal before playing\n      ** it back since the process that crashed and left the hot journal\n      ** probably did not sync it and we are required to always sync\n      ** the journal before playing it back.\n      */\n      if( isOpen(pPager->jfd) ){\n        assert( rc==SQLITE_OK );\n        rc = pagerSyncHotJournal(pPager);\n        if( rc==SQLITE_OK ){\n          rc = pager_playback(pPager, 1);\n          pPager->eState = PAGER_OPEN;\n        }\n      }else if( !pPager->exclusiveMode ){\n        pagerUnlockDb(pPager, SHARED_LOCK);\n      }\n\n      if( rc!=SQLITE_OK ){\n        /* This branch is taken if an error occurs while trying to open\n        ** or roll back a hot-journal while holding an EXCLUSIVE lock. The\n        ** pager_unlock() routine will be called before returning to unlock\n        ** the file. If the unlock attempt fails, then Pager.eLock must be\n        ** set to UNKNOWN_LOCK (see the comment above the #define for \n        ** UNKNOWN_LOCK above for an explanation). \n        **\n        ** In order to get pager_unlock() to do this, set Pager.eState to\n        ** PAGER_ERROR now. This is not actually counted as a transition\n        ** to ERROR state in the state diagram at the top of this file,\n        ** since we know that the same call to pager_unlock() will very\n        ** shortly transition the pager object to the OPEN state. Calling\n        ** assert_pager_state() would fail now, as it should not be possible\n        ** to be in ERROR state when there are zero outstanding page \n        ** references.\n        */\n        pager_error(pPager, rc);\n        goto failed;\n      }\n\n      assert( pPager->eState==PAGER_OPEN );\n      assert( (pPager->eLock==SHARED_LOCK)\n           || (pPager->exclusiveMode && pPager->eLock>SHARED_LOCK)\n      );\n    }\n\n    if( !pPager->tempFile \n     && (pPager->pBackup || sqlite3PcachePagecount(pPager->pPCache)>0) \n    ){\n      /* The shared-lock has just been acquired on the database file\n      ** and there are already pages in the cache (from a previous\n      ** read or write transaction).  Check to see if the database\n      ** has been modified.  If the database has changed, flush the\n      ** cache.\n      **\n      ** Database changes is detected by looking at 15 bytes beginning\n      ** at offset 24 into the file.  The first 4 of these 16 bytes are\n      ** a 32-bit counter that is incremented with each change.  The\n      ** other bytes change randomly with each file change when\n      ** a codec is in use.\n      ** \n      ** There is a vanishingly small chance that a change will not be \n      ** detected.  The chance of an undetected change is so small that\n      ** it can be neglected.\n      */\n      Pgno nPage = 0;\n      char dbFileVers[sizeof(pPager->dbFileVers)];\n\n      rc = pagerPagecount(pPager, &nPage);\n      if( rc ) goto failed;\n\n      if( nPage>0 ){\n        IOTRACE((\"CKVERS %p %d\\n\", pPager, sizeof(dbFileVers)));\n        rc = sqlite3OsRead(pPager->fd, &dbFileVers, sizeof(dbFileVers), 24);\n        if( rc!=SQLITE_OK ){\n          goto failed;\n        }\n      }else{\n        memset(dbFileVers, 0, sizeof(dbFileVers));\n      }\n\n      if( memcmp(pPager->dbFileVers, dbFileVers, sizeof(dbFileVers))!=0 ){\n        pager_reset(pPager);\n      }\n    }\n\n    /* If there is a WAL file in the file-system, open this database in WAL\n    ** mode. Otherwise, the following function call is a no-op.\n    */\n    rc = pagerOpenWalIfPresent(pPager);\n#ifndef SQLITE_OMIT_WAL\n    assert( pPager->pWal==0 || rc==SQLITE_OK );\n#endif\n  }\n\n  if( pagerUseWal(pPager) ){\n    assert( rc==SQLITE_OK );\n    rc = pagerBeginReadTransaction(pPager);\n  }\n\n  if( pPager->eState==PAGER_OPEN && rc==SQLITE_OK ){\n    rc = pagerPagecount(pPager, &pPager->dbSize);\n  }\n\n failed:\n  if( rc!=SQLITE_OK ){\n    assert( !MEMDB );\n    pager_unlock(pPager);\n    assert( pPager->eState==PAGER_OPEN );\n  }else{\n    pPager->eState = PAGER_READER;\n  }\n  return rc;\n}\n\n/*\n** If the reference count has reached zero, rollback any active\n** transaction and unlock the pager.\n**\n** Except, in locking_mode=EXCLUSIVE when there is nothing to in\n** the rollback journal, the unlock is not performed and there is\n** nothing to rollback, so this routine is a no-op.\n*/ \nstatic void pagerUnlockIfUnused(Pager *pPager){\n  if( (sqlite3PcacheRefCount(pPager->pPCache)==0) ){\n    pagerUnlockAndRollback(pPager);\n  }\n}\n\n/*\n** Acquire a reference to page number pgno in pager pPager (a page\n** reference has type DbPage*). If the requested reference is \n** successfully obtained, it is copied to *ppPage and SQLITE_OK returned.\n**\n** If the requested page is already in the cache, it is returned. \n** Otherwise, a new page object is allocated and populated with data\n** read from the database file. In some cases, the pcache module may\n** choose not to allocate a new page object and may reuse an existing\n** object with no outstanding references.\n**\n** The extra data appended to a page is always initialized to zeros the \n** first time a page is loaded into memory. If the page requested is \n** already in the cache when this function is called, then the extra\n** data is left as it was when the page object was last used.\n**\n** If the database image is smaller than the requested page or if a \n** non-zero value is passed as the noContent parameter and the \n** requested page is not already stored in the cache, then no \n** actual disk read occurs. In this case the memory image of the \n** page is initialized to all zeros. \n**\n** If noContent is true, it means that we do not care about the contents\n** of the page. This occurs in two seperate scenarios:\n**\n**   a) When reading a free-list leaf page from the database, and\n**\n**   b) When a savepoint is being rolled back and we need to load\n**      a new page into the cache to be filled with the data read\n**      from the savepoint journal.\n**\n** If noContent is true, then the data returned is zeroed instead of\n** being read from the database. Additionally, the bits corresponding\n** to pgno in Pager.pInJournal (bitvec of pages already written to the\n** journal file) and the PagerSavepoint.pInSavepoint bitvecs of any open\n** savepoints are set. This means if the page is made writable at any\n** point in the future, using a call to sqlite3PagerWrite(), its contents\n** will not be journaled. This saves IO.\n**\n** The acquisition might fail for several reasons.  In all cases,\n** an appropriate error code is returned and *ppPage is set to NULL.\n**\n** See also sqlite3PagerLookup().  Both this routine and Lookup() attempt\n** to find a page in the in-memory cache first.  If the page is not already\n** in memory, this routine goes to disk to read it in whereas Lookup()\n** just returns 0.  This routine acquires a read-lock the first time it\n** has to go to disk, and could also playback an old journal if necessary.\n** Since Lookup() never goes to disk, it never has to deal with locks\n** or journal files.\n*/\nSQLITE_PRIVATE int sqlite3PagerAcquire(\n  Pager *pPager,      /* The pager open on the database file */\n  Pgno pgno,          /* Page number to fetch */\n  DbPage **ppPage,    /* Write a pointer to the page here */\n  int noContent       /* Do not bother reading content from disk if true */\n){\n  int rc;\n  PgHdr *pPg;\n\n  assert( pPager->eState>=PAGER_READER );\n  assert( assert_pager_state(pPager) );\n\n  if( pgno==0 ){\n    return SQLITE_CORRUPT_BKPT;\n  }\n\n  /* If the pager is in the error state, return an error immediately. \n  ** Otherwise, request the page from the PCache layer. */\n  if( pPager->errCode!=SQLITE_OK ){\n    rc = pPager->errCode;\n  }else{\n    rc = sqlite3PcacheFetch(pPager->pPCache, pgno, 1, ppPage);\n  }\n\n  if( rc!=SQLITE_OK ){\n    /* Either the call to sqlite3PcacheFetch() returned an error or the\n    ** pager was already in the error-state when this function was called.\n    ** Set pPg to 0 and jump to the exception handler.  */\n    pPg = 0;\n    goto pager_acquire_err;\n  }\n  assert( (*ppPage)->pgno==pgno );\n  assert( (*ppPage)->pPager==pPager || (*ppPage)->pPager==0 );\n\n  if( (*ppPage)->pPager && !noContent ){\n    /* In this case the pcache already contains an initialized copy of\n    ** the page. Return without further ado.  */\n    assert( pgno<=PAGER_MAX_PGNO && pgno!=PAGER_MJ_PGNO(pPager) );\n    PAGER_INCR(pPager->nHit);\n    return SQLITE_OK;\n\n  }else{\n    /* The pager cache has created a new page. Its content needs to \n    ** be initialized.  */\n\n    PAGER_INCR(pPager->nMiss);\n    pPg = *ppPage;\n    pPg->pPager = pPager;\n\n    /* The maximum page number is 2^31. Return SQLITE_CORRUPT if a page\n    ** number greater than this, or the unused locking-page, is requested. */\n    if( pgno>PAGER_MAX_PGNO || pgno==PAGER_MJ_PGNO(pPager) ){\n      rc = SQLITE_CORRUPT_BKPT;\n      goto pager_acquire_err;\n    }\n\n    if( MEMDB || pPager->dbSize<pgno || noContent || !isOpen(pPager->fd) ){\n      if( pgno>pPager->mxPgno ){\n        rc = SQLITE_FULL;\n        goto pager_acquire_err;\n      }\n      if( noContent ){\n        /* Failure to set the bits in the InJournal bit-vectors is benign.\n        ** It merely means that we might do some extra work to journal a \n        ** page that does not need to be journaled.  Nevertheless, be sure \n        ** to test the case where a malloc error occurs while trying to set \n        ** a bit in a bit vector.\n        */\n        sqlite3BeginBenignMalloc();\n        if( pgno<=pPager->dbOrigSize ){\n          TESTONLY( rc = ) sqlite3BitvecSet(pPager->pInJournal, pgno);\n          testcase( rc==SQLITE_NOMEM );\n        }\n        TESTONLY( rc = ) addToSavepointBitvecs(pPager, pgno);\n        testcase( rc==SQLITE_NOMEM );\n        sqlite3EndBenignMalloc();\n      }\n      memset(pPg->pData, 0, pPager->pageSize);\n      IOTRACE((\"ZERO %p %d\\n\", pPager, pgno));\n    }else{\n      assert( pPg->pPager==pPager );\n      rc = readDbPage(pPg);\n      if( rc!=SQLITE_OK ){\n        goto pager_acquire_err;\n      }\n    }\n    pager_set_pagehash(pPg);\n  }\n\n  return SQLITE_OK;\n\npager_acquire_err:\n  assert( rc!=SQLITE_OK );\n  if( pPg ){\n    sqlite3PcacheDrop(pPg);\n  }\n  pagerUnlockIfUnused(pPager);\n\n  *ppPage = 0;\n  return rc;\n}\n\n/*\n** Acquire a page if it is already in the in-memory cache.  Do\n** not read the page from disk.  Return a pointer to the page,\n** or 0 if the page is not in cache. \n**\n** See also sqlite3PagerGet().  The difference between this routine\n** and sqlite3PagerGet() is that _get() will go to the disk and read\n** in the page if the page is not already in cache.  This routine\n** returns NULL if the page is not in cache or if a disk I/O error \n** has ever happened.\n*/\nSQLITE_PRIVATE DbPage *sqlite3PagerLookup(Pager *pPager, Pgno pgno){\n  PgHdr *pPg = 0;\n  assert( pPager!=0 );\n  assert( pgno!=0 );\n  assert( pPager->pPCache!=0 );\n  assert( pPager->eState>=PAGER_READER && pPager->eState!=PAGER_ERROR );\n  sqlite3PcacheFetch(pPager->pPCache, pgno, 0, &pPg);\n  return pPg;\n}\n\n/*\n** Release a page reference.\n**\n** If the number of references to the page drop to zero, then the\n** page is added to the LRU list.  When all references to all pages\n** are released, a rollback occurs and the lock on the database is\n** removed.\n*/\nSQLITE_PRIVATE void sqlite3PagerUnref(DbPage *pPg){\n  if( pPg ){\n    Pager *pPager = pPg->pPager;\n    sqlite3PcacheRelease(pPg);\n    pagerUnlockIfUnused(pPager);\n  }\n}\n\n/*\n** This function is called at the start of every write transaction.\n** There must already be a RESERVED or EXCLUSIVE lock on the database \n** file when this routine is called.\n**\n** Open the journal file for pager pPager and write a journal header\n** to the start of it. If there are active savepoints, open the sub-journal\n** as well. This function is only used when the journal file is being \n** opened to write a rollback log for a transaction. It is not used \n** when opening a hot journal file to roll it back.\n**\n** If the journal file is already open (as it may be in exclusive mode),\n** then this function just writes a journal header to the start of the\n** already open file. \n**\n** Whether or not the journal file is opened by this function, the\n** Pager.pInJournal bitvec structure is allocated.\n**\n** Return SQLITE_OK if everything is successful. Otherwise, return \n** SQLITE_NOMEM if the attempt to allocate Pager.pInJournal fails, or \n** an IO error code if opening or writing the journal file fails.\n*/\nstatic int pager_open_journal(Pager *pPager){\n  int rc = SQLITE_OK;                        /* Return code */\n  sqlite3_vfs * const pVfs = pPager->pVfs;   /* Local cache of vfs pointer */\n\n  assert( pPager->eState==PAGER_WRITER_LOCKED );\n  assert( assert_pager_state(pPager) );\n  assert( pPager->pInJournal==0 );\n  \n  /* If already in the error state, this function is a no-op.  But on\n  ** the other hand, this routine is never called if we are already in\n  ** an error state. */\n  if( NEVER(pPager->errCode) ) return pPager->errCode;\n\n  if( !pagerUseWal(pPager) && pPager->journalMode!=PAGER_JOURNALMODE_OFF ){\n    pPager->pInJournal = sqlite3BitvecCreate(pPager->dbSize);\n    if( pPager->pInJournal==0 ){\n      return SQLITE_NOMEM;\n    }\n  \n    /* Open the journal file if it is not already open. */\n    if( !isOpen(pPager->jfd) ){\n      if( pPager->journalMode==PAGER_JOURNALMODE_MEMORY ){\n        sqlite3MemJournalOpen(pPager->jfd);\n      }else{\n        const int flags =                   /* VFS flags to open journal file */\n          SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE|\n          (pPager->tempFile ? \n            (SQLITE_OPEN_DELETEONCLOSE|SQLITE_OPEN_TEMP_JOURNAL):\n            (SQLITE_OPEN_MAIN_JOURNAL)\n          );\n  #ifdef SQLITE_ENABLE_ATOMIC_WRITE\n        rc = sqlite3JournalOpen(\n            pVfs, pPager->zJournal, pPager->jfd, flags, jrnlBufferSize(pPager)\n        );\n  #else\n        rc = sqlite3OsOpen(pVfs, pPager->zJournal, pPager->jfd, flags, 0);\n  #endif\n      }\n      assert( rc!=SQLITE_OK || isOpen(pPager->jfd) );\n    }\n  \n  \n    /* Write the first journal header to the journal file and open \n    ** the sub-journal if necessary.\n    */\n    if( rc==SQLITE_OK ){\n      /* TODO: Check if all of these are really required. */\n      pPager->nRec = 0;\n      pPager->journalOff = 0;\n      pPager->setMaster = 0;\n      pPager->journalHdr = 0;\n      rc = writeJournalHdr(pPager);\n    }\n  }\n\n  if( rc!=SQLITE_OK ){\n    sqlite3BitvecDestroy(pPager->pInJournal);\n    pPager->pInJournal = 0;\n  }else{\n    assert( pPager->eState==PAGER_WRITER_LOCKED );\n    pPager->eState = PAGER_WRITER_CACHEMOD;\n  }\n\n  return rc;\n}\n\n/*\n** Begin a write-transaction on the specified pager object. If a \n** write-transaction has already been opened, this function is a no-op.\n**\n** If the exFlag argument is false, then acquire at least a RESERVED\n** lock on the database file. If exFlag is true, then acquire at least\n** an EXCLUSIVE lock. If such a lock is already held, no locking \n** functions need be called.\n**\n** If the subjInMemory argument is non-zero, then any sub-journal opened\n** within this transaction will be opened as an in-memory file. This\n** has no effect if the sub-journal is already opened (as it may be when\n** running in exclusive mode) or if the transaction does not require a\n** sub-journal. If the subjInMemory argument is zero, then any required\n** sub-journal is implemented in-memory if pPager is an in-memory database, \n** or using a temporary file otherwise.\n*/\nSQLITE_PRIVATE int sqlite3PagerBegin(Pager *pPager, int exFlag, int subjInMemory){\n  int rc = SQLITE_OK;\n\n  if( pPager->errCode ) return pPager->errCode;\n  assert( pPager->eState>=PAGER_READER && pPager->eState<PAGER_ERROR );\n  pPager->subjInMemory = (u8)subjInMemory;\n\n  if( ALWAYS(pPager->eState==PAGER_READER) ){\n    assert( pPager->pInJournal==0 );\n\n    if( pagerUseWal(pPager) ){\n      /* If the pager is configured to use locking_mode=exclusive, and an\n      ** exclusive lock on the database is not already held, obtain it now.\n      */\n      if( pPager->exclusiveMode && sqlite3WalExclusiveMode(pPager->pWal, -1) ){\n        rc = pagerLockDb(pPager, EXCLUSIVE_LOCK);\n        if( rc!=SQLITE_OK ){\n          return rc;\n        }\n        sqlite3WalExclusiveMode(pPager->pWal, 1);\n      }\n\n      /* Grab the write lock on the log file. If successful, upgrade to\n      ** PAGER_RESERVED state. Otherwise, return an error code to the caller.\n      ** The busy-handler is not invoked if another connection already\n      ** holds the write-lock. If possible, the upper layer will call it.\n      */\n      rc = sqlite3WalBeginWriteTransaction(pPager->pWal);\n    }else{\n      /* Obtain a RESERVED lock on the database file. If the exFlag parameter\n      ** is true, then immediately upgrade this to an EXCLUSIVE lock. The\n      ** busy-handler callback can be used when upgrading to the EXCLUSIVE\n      ** lock, but not when obtaining the RESERVED lock.\n      */\n      rc = pagerLockDb(pPager, RESERVED_LOCK);\n      if( rc==SQLITE_OK && exFlag ){\n        rc = pager_wait_on_lock(pPager, EXCLUSIVE_LOCK);\n      }\n    }\n\n    if( rc==SQLITE_OK ){\n      /* Change to WRITER_LOCKED state.\n      **\n      ** WAL mode sets Pager.eState to PAGER_WRITER_LOCKED or CACHEMOD\n      ** when it has an open transaction, but never to DBMOD or FINISHED.\n      ** This is because in those states the code to roll back savepoint \n      ** transactions may copy data from the sub-journal into the database \n      ** file as well as into the page cache. Which would be incorrect in \n      ** WAL mode.\n      */\n      pPager->eState = PAGER_WRITER_LOCKED;\n      pPager->dbHintSize = pPager->dbSize;\n      pPager->dbFileSize = pPager->dbSize;\n      pPager->dbOrigSize = pPager->dbSize;\n      pPager->journalOff = 0;\n    }\n\n    assert( rc==SQLITE_OK || pPager->eState==PAGER_READER );\n    assert( rc!=SQLITE_OK || pPager->eState==PAGER_WRITER_LOCKED );\n    assert( assert_pager_state(pPager) );\n  }\n\n  PAGERTRACE((\"TRANSACTION %d\\n\", PAGERID(pPager)));\n  return rc;\n}\n\n/*\n** Mark a single data page as writeable. The page is written into the \n** main journal or sub-journal as required. If the page is written into\n** one of the journals, the corresponding bit is set in the \n** Pager.pInJournal bitvec and the PagerSavepoint.pInSavepoint bitvecs\n** of any open savepoints as appropriate.\n*/\nstatic int pager_write(PgHdr *pPg){\n  void *pData = pPg->pData;\n  Pager *pPager = pPg->pPager;\n  int rc = SQLITE_OK;\n\n  /* This routine is not called unless a write-transaction has already \n  ** been started. The journal file may or may not be open at this point.\n  ** It is never called in the ERROR state.\n  */\n  assert( pPager->eState==PAGER_WRITER_LOCKED\n       || pPager->eState==PAGER_WRITER_CACHEMOD\n       || pPager->eState==PAGER_WRITER_DBMOD\n  );\n  assert( assert_pager_state(pPager) );\n\n  /* If an error has been previously detected, report the same error\n  ** again. This should not happen, but the check provides robustness. */\n  if( NEVER(pPager->errCode) )  return pPager->errCode;\n\n  /* Higher-level routines never call this function if database is not\n  ** writable.  But check anyway, just for robustness. */\n  if( NEVER(pPager->readOnly) ) return SQLITE_PERM;\n\n  CHECK_PAGE(pPg);\n\n  /* The journal file needs to be opened. Higher level routines have already\n  ** obtained the necessary locks to begin the write-transaction, but the\n  ** rollback journal might not yet be open. Open it now if this is the case.\n  **\n  ** This is done before calling sqlite3PcacheMakeDirty() on the page. \n  ** Otherwise, if it were done after calling sqlite3PcacheMakeDirty(), then\n  ** an error might occur and the pager would end up in WRITER_LOCKED state\n  ** with pages marked as dirty in the cache.\n  */\n  if( pPager->eState==PAGER_WRITER_LOCKED ){\n    rc = pager_open_journal(pPager);\n    if( rc!=SQLITE_OK ) return rc;\n  }\n  assert( pPager->eState>=PAGER_WRITER_CACHEMOD );\n  assert( assert_pager_state(pPager) );\n\n  /* Mark the page as dirty.  If the page has already been written\n  ** to the journal then we can return right away.\n  */\n  sqlite3PcacheMakeDirty(pPg);\n  if( pageInJournal(pPg) && !subjRequiresPage(pPg) ){\n    assert( !pagerUseWal(pPager) );\n  }else{\n  \n    /* The transaction journal now exists and we have a RESERVED or an\n    ** EXCLUSIVE lock on the main database file.  Write the current page to\n    ** the transaction journal if it is not there already.\n    */\n    if( !pageInJournal(pPg) && !pagerUseWal(pPager) ){\n      assert( pagerUseWal(pPager)==0 );\n      if( pPg->pgno<=pPager->dbOrigSize && isOpen(pPager->jfd) ){\n        u32 cksum;\n        char *pData2;\n        i64 iOff = pPager->journalOff;\n\n        /* We should never write to the journal file the page that\n        ** contains the database locks.  The following assert verifies\n        ** that we do not. */\n        assert( pPg->pgno!=PAGER_MJ_PGNO(pPager) );\n\n        assert( pPager->journalHdr<=pPager->journalOff );\n        CODEC2(pPager, pData, pPg->pgno, 7, return SQLITE_NOMEM, pData2);\n        cksum = pager_cksum(pPager, (u8*)pData2);\n\n        /* Even if an IO or diskfull error occurs while journalling the\n        ** page in the block above, set the need-sync flag for the page.\n        ** Otherwise, when the transaction is rolled back, the logic in\n        ** playback_one_page() will think that the page needs to be restored\n        ** in the database file. And if an IO error occurs while doing so,\n        ** then corruption may follow.\n        */\n        pPg->flags |= PGHDR_NEED_SYNC;\n\n        rc = write32bits(pPager->jfd, iOff, pPg->pgno);\n        if( rc!=SQLITE_OK ) return rc;\n        rc = sqlite3OsWrite(pPager->jfd, pData2, pPager->pageSize, iOff+4);\n        if( rc!=SQLITE_OK ) return rc;\n        rc = write32bits(pPager->jfd, iOff+pPager->pageSize+4, cksum);\n        if( rc!=SQLITE_OK ) return rc;\n\n        IOTRACE((\"JOUT %p %d %lld %d\\n\", pPager, pPg->pgno, \n                 pPager->journalOff, pPager->pageSize));\n        PAGER_INCR(sqlite3_pager_writej_count);\n        PAGERTRACE((\"JOURNAL %d page %d needSync=%d hash(%08x)\\n\",\n             PAGERID(pPager), pPg->pgno, \n             ((pPg->flags&PGHDR_NEED_SYNC)?1:0), pager_pagehash(pPg)));\n\n        pPager->journalOff += 8 + pPager->pageSize;\n        pPager->nRec++;\n        assert( pPager->pInJournal!=0 );\n        rc = sqlite3BitvecSet(pPager->pInJournal, pPg->pgno);\n        testcase( rc==SQLITE_NOMEM );\n        assert( rc==SQLITE_OK || rc==SQLITE_NOMEM );\n        rc |= addToSavepointBitvecs(pPager, pPg->pgno);\n        if( rc!=SQLITE_OK ){\n          assert( rc==SQLITE_NOMEM );\n          return rc;\n        }\n      }else{\n        if( pPager->eState!=PAGER_WRITER_DBMOD ){\n          pPg->flags |= PGHDR_NEED_SYNC;\n        }\n        PAGERTRACE((\"APPEND %d page %d needSync=%d\\n\",\n                PAGERID(pPager), pPg->pgno,\n               ((pPg->flags&PGHDR_NEED_SYNC)?1:0)));\n      }\n    }\n  \n    /* If the statement journal is open and the page is not in it,\n    ** then write the current page to the statement journal.  Note that\n    ** the statement journal format differs from the standard journal format\n    ** in that it omits the checksums and the header.\n    */\n    if( subjRequiresPage(pPg) ){\n      rc = subjournalPage(pPg);\n    }\n  }\n\n  /* Update the database size and return.\n  */\n  if( pPager->dbSize<pPg->pgno ){\n    pPager->dbSize = pPg->pgno;\n  }\n  return rc;\n}\n\n/*\n** Mark a data page as writeable. This routine must be called before \n** making changes to a page. The caller must check the return value \n** of this function and be careful not to change any page data unless \n** this routine returns SQLITE_OK.\n**\n** The difference between this function and pager_write() is that this\n** function also deals with the special case where 2 or more pages\n** fit on a single disk sector. In this case all co-resident pages\n** must have been written to the journal file before returning.\n**\n** If an error occurs, SQLITE_NOMEM or an IO error code is returned\n** as appropriate. Otherwise, SQLITE_OK.\n*/\nSQLITE_PRIVATE int sqlite3PagerWrite(DbPage *pDbPage){\n  int rc = SQLITE_OK;\n\n  PgHdr *pPg = pDbPage;\n  Pager *pPager = pPg->pPager;\n  Pgno nPagePerSector = (pPager->sectorSize/pPager->pageSize);\n\n  assert( pPager->eState>=PAGER_WRITER_LOCKED );\n  assert( pPager->eState!=PAGER_ERROR );\n  assert( assert_pager_state(pPager) );\n\n  if( nPagePerSector>1 ){\n    Pgno nPageCount;          /* Total number of pages in database file */\n    Pgno pg1;                 /* First page of the sector pPg is located on. */\n    int nPage = 0;            /* Number of pages starting at pg1 to journal */\n    int ii;                   /* Loop counter */\n    int needSync = 0;         /* True if any page has PGHDR_NEED_SYNC */\n\n    /* Set the doNotSyncSpill flag to 1. This is because we cannot allow\n    ** a journal header to be written between the pages journaled by\n    ** this function.\n    */\n    assert( !MEMDB );\n    assert( pPager->doNotSyncSpill==0 );\n    pPager->doNotSyncSpill++;\n\n    /* This trick assumes that both the page-size and sector-size are\n    ** an integer power of 2. It sets variable pg1 to the identifier\n    ** of the first page of the sector pPg is located on.\n    */\n    pg1 = ((pPg->pgno-1) & ~(nPagePerSector-1)) + 1;\n\n    nPageCount = pPager->dbSize;\n    if( pPg->pgno>nPageCount ){\n      nPage = (pPg->pgno - pg1)+1;\n    }else if( (pg1+nPagePerSector-1)>nPageCount ){\n      nPage = nPageCount+1-pg1;\n    }else{\n      nPage = nPagePerSector;\n    }\n    assert(nPage>0);\n    assert(pg1<=pPg->pgno);\n    assert((pg1+nPage)>pPg->pgno);\n\n    for(ii=0; ii<nPage && rc==SQLITE_OK; ii++){\n      Pgno pg = pg1+ii;\n      PgHdr *pPage;\n      if( pg==pPg->pgno || !sqlite3BitvecTest(pPager->pInJournal, pg) ){\n        if( pg!=PAGER_MJ_PGNO(pPager) ){\n          rc = sqlite3PagerGet(pPager, pg, &pPage);\n          if( rc==SQLITE_OK ){\n            rc = pager_write(pPage);\n            if( pPage->flags&PGHDR_NEED_SYNC ){\n              needSync = 1;\n            }\n            sqlite3PagerUnref(pPage);\n          }\n        }\n      }else if( (pPage = pager_lookup(pPager, pg))!=0 ){\n        if( pPage->flags&PGHDR_NEED_SYNC ){\n          needSync = 1;\n        }\n        sqlite3PagerUnref(pPage);\n      }\n    }\n\n    /* If the PGHDR_NEED_SYNC flag is set for any of the nPage pages \n    ** starting at pg1, then it needs to be set for all of them. Because\n    ** writing to any of these nPage pages may damage the others, the\n    ** journal file must contain sync()ed copies of all of them\n    ** before any of them can be written out to the database file.\n    */\n    if( rc==SQLITE_OK && needSync ){\n      assert( !MEMDB );\n      for(ii=0; ii<nPage; ii++){\n        PgHdr *pPage = pager_lookup(pPager, pg1+ii);\n        if( pPage ){\n          pPage->flags |= PGHDR_NEED_SYNC;\n          sqlite3PagerUnref(pPage);\n        }\n      }\n    }\n\n    assert( pPager->doNotSyncSpill==1 );\n    pPager->doNotSyncSpill--;\n  }else{\n    rc = pager_write(pDbPage);\n  }\n  return rc;\n}\n\n/*\n** Return TRUE if the page given in the argument was previously passed\n** to sqlite3PagerWrite().  In other words, return TRUE if it is ok\n** to change the content of the page.\n*/\n#ifndef NDEBUG\nSQLITE_PRIVATE int sqlite3PagerIswriteable(DbPage *pPg){\n  return pPg->flags&PGHDR_DIRTY;\n}\n#endif\n\n/*\n** A call to this routine tells the pager that it is not necessary to\n** write the information on page pPg back to the disk, even though\n** that page might be marked as dirty.  This happens, for example, when\n** the page has been added as a leaf of the freelist and so its\n** content no longer matters.\n**\n** The overlying software layer calls this routine when all of the data\n** on the given page is unused. The pager marks the page as clean so\n** that it does not get written to disk.\n**\n** Tests show that this optimization can quadruple the speed of large \n** DELETE operations.\n*/\nSQLITE_PRIVATE void sqlite3PagerDontWrite(PgHdr *pPg){\n  Pager *pPager = pPg->pPager;\n  if( (pPg->flags&PGHDR_DIRTY) && pPager->nSavepoint==0 ){\n    PAGERTRACE((\"DONT_WRITE page %d of %d\\n\", pPg->pgno, PAGERID(pPager)));\n    IOTRACE((\"CLEAN %p %d\\n\", pPager, pPg->pgno))\n    pPg->flags |= PGHDR_DONT_WRITE;\n    pager_set_pagehash(pPg);\n  }\n}\n\n/*\n** This routine is called to increment the value of the database file \n** change-counter, stored as a 4-byte big-endian integer starting at \n** byte offset 24 of the pager file.  The secondary change counter at\n** 92 is also updated, as is the SQLite version number at offset 96.\n**\n** But this only happens if the pPager->changeCountDone flag is false.\n** To avoid excess churning of page 1, the update only happens once.\n** See also the pager_write_changecounter() routine that does an \n** unconditional update of the change counters.\n**\n** If the isDirectMode flag is zero, then this is done by calling \n** sqlite3PagerWrite() on page 1, then modifying the contents of the\n** page data. In this case the file will be updated when the current\n** transaction is committed.\n**\n** The isDirectMode flag may only be non-zero if the library was compiled\n** with the SQLITE_ENABLE_ATOMIC_WRITE macro defined. In this case,\n** if isDirect is non-zero, then the database file is updated directly\n** by writing an updated version of page 1 using a call to the \n** sqlite3OsWrite() function.\n*/\nstatic int pager_incr_changecounter(Pager *pPager, int isDirectMode){\n  int rc = SQLITE_OK;\n\n  assert( pPager->eState==PAGER_WRITER_CACHEMOD\n       || pPager->eState==PAGER_WRITER_DBMOD\n  );\n  assert( assert_pager_state(pPager) );\n\n  /* Declare and initialize constant integer 'isDirect'. If the\n  ** atomic-write optimization is enabled in this build, then isDirect\n  ** is initialized to the value passed as the isDirectMode parameter\n  ** to this function. Otherwise, it is always set to zero.\n  **\n  ** The idea is that if the atomic-write optimization is not\n  ** enabled at compile time, the compiler can omit the tests of\n  ** 'isDirect' below, as well as the block enclosed in the\n  ** \"if( isDirect )\" condition.\n  */\n#ifndef SQLITE_ENABLE_ATOMIC_WRITE\n# define DIRECT_MODE 0\n  assert( isDirectMode==0 );\n  UNUSED_PARAMETER(isDirectMode);\n#else\n# define DIRECT_MODE isDirectMode\n#endif\n\n  if( !pPager->changeCountDone && pPager->dbSize>0 ){\n    PgHdr *pPgHdr;                /* Reference to page 1 */\n\n    assert( !pPager->tempFile && isOpen(pPager->fd) );\n\n    /* Open page 1 of the file for writing. */\n    rc = sqlite3PagerGet(pPager, 1, &pPgHdr);\n    assert( pPgHdr==0 || rc==SQLITE_OK );\n\n    /* If page one was fetched successfully, and this function is not\n    ** operating in direct-mode, make page 1 writable.  When not in \n    ** direct mode, page 1 is always held in cache and hence the PagerGet()\n    ** above is always successful - hence the ALWAYS on rc==SQLITE_OK.\n    */\n    if( !DIRECT_MODE && ALWAYS(rc==SQLITE_OK) ){\n      rc = sqlite3PagerWrite(pPgHdr);\n    }\n\n    if( rc==SQLITE_OK ){\n      /* Actually do the update of the change counter */\n      pager_write_changecounter(pPgHdr);\n\n      /* If running in direct mode, write the contents of page 1 to the file. */\n      if( DIRECT_MODE ){\n        const void *zBuf;\n        assert( pPager->dbFileSize>0 );\n        CODEC2(pPager, pPgHdr->pData, 1, 6, rc=SQLITE_NOMEM, zBuf);\n        if( rc==SQLITE_OK ){\n          rc = sqlite3OsWrite(pPager->fd, zBuf, pPager->pageSize, 0);\n        }\n        if( rc==SQLITE_OK ){\n          pPager->changeCountDone = 1;\n        }\n      }else{\n        pPager->changeCountDone = 1;\n      }\n    }\n\n    /* Release the page reference. */\n    sqlite3PagerUnref(pPgHdr);\n  }\n  return rc;\n}\n\n/*\n** Sync the database file to disk. This is a no-op for in-memory databases\n** or pages with the Pager.noSync flag set.\n**\n** If successful, or if called on a pager for which it is a no-op, this\n** function returns SQLITE_OK. Otherwise, an IO error code is returned.\n*/\nSQLITE_PRIVATE int sqlite3PagerSync(Pager *pPager){\n  int rc = SQLITE_OK;\n  if( !pPager->noSync ){\n    assert( !MEMDB );\n    rc = sqlite3OsSync(pPager->fd, pPager->syncFlags);\n  }else if( isOpen(pPager->fd) ){\n    assert( !MEMDB );\n    sqlite3OsFileControl(pPager->fd, SQLITE_FCNTL_SYNC_OMITTED, (void *)&rc);\n  }\n  return rc;\n}\n\n/*\n** This function may only be called while a write-transaction is active in\n** rollback. If the connection is in WAL mode, this call is a no-op. \n** Otherwise, if the connection does not already have an EXCLUSIVE lock on \n** the database file, an attempt is made to obtain one.\n**\n** If the EXCLUSIVE lock is already held or the attempt to obtain it is\n** successful, or the connection is in WAL mode, SQLITE_OK is returned.\n** Otherwise, either SQLITE_BUSY or an SQLITE_IOERR_XXX error code is \n** returned.\n*/\nSQLITE_PRIVATE int sqlite3PagerExclusiveLock(Pager *pPager){\n  int rc = SQLITE_OK;\n  assert( pPager->eState==PAGER_WRITER_CACHEMOD \n       || pPager->eState==PAGER_WRITER_DBMOD \n       || pPager->eState==PAGER_WRITER_LOCKED \n  );\n  assert( assert_pager_state(pPager) );\n  if( 0==pagerUseWal(pPager) ){\n    rc = pager_wait_on_lock(pPager, EXCLUSIVE_LOCK);\n  }\n  return rc;\n}\n\n/*\n** Sync the database file for the pager pPager. zMaster points to the name\n** of a master journal file that should be written into the individual\n** journal file. zMaster may be NULL, which is interpreted as no master\n** journal (a single database transaction).\n**\n** This routine ensures that:\n**\n**   * The database file change-counter is updated,\n**   * the journal is synced (unless the atomic-write optimization is used),\n**   * all dirty pages are written to the database file, \n**   * the database file is truncated (if required), and\n**   * the database file synced. \n**\n** The only thing that remains to commit the transaction is to finalize \n** (delete, truncate or zero the first part of) the journal file (or \n** delete the master journal file if specified).\n**\n** Note that if zMaster==NULL, this does not overwrite a previous value\n** passed to an sqlite3PagerCommitPhaseOne() call.\n**\n** If the final parameter - noSync - is true, then the database file itself\n** is not synced. The caller must call sqlite3PagerSync() directly to\n** sync the database file before calling CommitPhaseTwo() to delete the\n** journal file in this case.\n*/\nSQLITE_PRIVATE int sqlite3PagerCommitPhaseOne(\n  Pager *pPager,                  /* Pager object */\n  const char *zMaster,            /* If not NULL, the master journal name */\n  int noSync                      /* True to omit the xSync on the db file */\n){\n  int rc = SQLITE_OK;             /* Return code */\n\n  assert( pPager->eState==PAGER_WRITER_LOCKED\n       || pPager->eState==PAGER_WRITER_CACHEMOD\n       || pPager->eState==PAGER_WRITER_DBMOD\n       || pPager->eState==PAGER_ERROR\n  );\n  assert( assert_pager_state(pPager) );\n\n  /* If a prior error occurred, report that error again. */\n  if( NEVER(pPager->errCode) ) return pPager->errCode;\n\n  PAGERTRACE((\"DATABASE SYNC: File=%s zMaster=%s nSize=%d\\n\", \n      pPager->zFilename, zMaster, pPager->dbSize));\n\n  /* If no database changes have been made, return early. */\n  if( pPager->eState<PAGER_WRITER_CACHEMOD ) return SQLITE_OK;\n\n  if( MEMDB ){\n    /* If this is an in-memory db, or no pages have been written to, or this\n    ** function has already been called, it is mostly a no-op.  However, any\n    ** backup in progress needs to be restarted.\n    */\n    sqlite3BackupRestart(pPager->pBackup);\n  }else{\n    if( pagerUseWal(pPager) ){\n      PgHdr *pList = sqlite3PcacheDirtyList(pPager->pPCache);\n      if( pList ){\n        rc = pagerWalFrames(pPager, pList, pPager->dbSize, 1, \n            (pPager->fullSync ? pPager->syncFlags : 0)\n        );\n      }\n      if( rc==SQLITE_OK ){\n        sqlite3PcacheCleanAll(pPager->pPCache);\n      }\n    }else{\n      /* The following block updates the change-counter. Exactly how it\n      ** does this depends on whether or not the atomic-update optimization\n      ** was enabled at compile time, and if this transaction meets the \n      ** runtime criteria to use the operation: \n      **\n      **    * The file-system supports the atomic-write property for\n      **      blocks of size page-size, and \n      **    * This commit is not part of a multi-file transaction, and\n      **    * Exactly one page has been modified and store in the journal file.\n      **\n      ** If the optimization was not enabled at compile time, then the\n      ** pager_incr_changecounter() function is called to update the change\n      ** counter in 'indirect-mode'. If the optimization is compiled in but\n      ** is not applicable to this transaction, call sqlite3JournalCreate()\n      ** to make sure the journal file has actually been created, then call\n      ** pager_incr_changecounter() to update the change-counter in indirect\n      ** mode. \n      **\n      ** Otherwise, if the optimization is both enabled and applicable,\n      ** then call pager_incr_changecounter() to update the change-counter\n      ** in 'direct' mode. In this case the journal file will never be\n      ** created for this transaction.\n      */\n  #ifdef SQLITE_ENABLE_ATOMIC_WRITE\n      PgHdr *pPg;\n      assert( isOpen(pPager->jfd) \n           || pPager->journalMode==PAGER_JOURNALMODE_OFF \n           || pPager->journalMode==PAGER_JOURNALMODE_WAL \n      );\n      if( !zMaster && isOpen(pPager->jfd) \n       && pPager->journalOff==jrnlBufferSize(pPager) \n       && pPager->dbSize>=pPager->dbOrigSize\n       && (0==(pPg = sqlite3PcacheDirtyList(pPager->pPCache)) || 0==pPg->pDirty)\n      ){\n        /* Update the db file change counter via the direct-write method. The \n        ** following call will modify the in-memory representation of page 1 \n        ** to include the updated change counter and then write page 1 \n        ** directly to the database file. Because of the atomic-write \n        ** property of the host file-system, this is safe.\n        */\n        rc = pager_incr_changecounter(pPager, 1);\n      }else{\n        rc = sqlite3JournalCreate(pPager->jfd);\n        if( rc==SQLITE_OK ){\n          rc = pager_incr_changecounter(pPager, 0);\n        }\n      }\n  #else\n      rc = pager_incr_changecounter(pPager, 0);\n  #endif\n      if( rc!=SQLITE_OK ) goto commit_phase_one_exit;\n  \n      /* If this transaction has made the database smaller, then all pages\n      ** being discarded by the truncation must be written to the journal\n      ** file. This can only happen in auto-vacuum mode.\n      **\n      ** Before reading the pages with page numbers larger than the \n      ** current value of Pager.dbSize, set dbSize back to the value\n      ** that it took at the start of the transaction. Otherwise, the\n      ** calls to sqlite3PagerGet() return zeroed pages instead of \n      ** reading data from the database file.\n      */\n  #ifndef SQLITE_OMIT_AUTOVACUUM\n      if( pPager->dbSize<pPager->dbOrigSize \n       && pPager->journalMode!=PAGER_JOURNALMODE_OFF\n      ){\n        Pgno i;                                   /* Iterator variable */\n        const Pgno iSkip = PAGER_MJ_PGNO(pPager); /* Pending lock page */\n        const Pgno dbSize = pPager->dbSize;       /* Database image size */ \n        pPager->dbSize = pPager->dbOrigSize;\n        for( i=dbSize+1; i<=pPager->dbOrigSize; i++ ){\n          if( !sqlite3BitvecTest(pPager->pInJournal, i) && i!=iSkip ){\n            PgHdr *pPage;             /* Page to journal */\n            rc = sqlite3PagerGet(pPager, i, &pPage);\n            if( rc!=SQLITE_OK ) goto commit_phase_one_exit;\n            rc = sqlite3PagerWrite(pPage);\n            sqlite3PagerUnref(pPage);\n            if( rc!=SQLITE_OK ) goto commit_phase_one_exit;\n          }\n        }\n        pPager->dbSize = dbSize;\n      } \n  #endif\n  \n      /* Write the master journal name into the journal file. If a master \n      ** journal file name has already been written to the journal file, \n      ** or if zMaster is NULL (no master journal), then this call is a no-op.\n      */\n      rc = writeMasterJournal(pPager, zMaster);\n      if( rc!=SQLITE_OK ) goto commit_phase_one_exit;\n  \n      /* Sync the journal file and write all dirty pages to the database.\n      ** If the atomic-update optimization is being used, this sync will not \n      ** create the journal file or perform any real IO.\n      **\n      ** Because the change-counter page was just modified, unless the\n      ** atomic-update optimization is used it is almost certain that the\n      ** journal requires a sync here. However, in locking_mode=exclusive\n      ** on a system under memory pressure it is just possible that this is \n      ** not the case. In this case it is likely enough that the redundant\n      ** xSync() call will be changed to a no-op by the OS anyhow. \n      */\n      rc = syncJournal(pPager, 0);\n      if( rc!=SQLITE_OK ) goto commit_phase_one_exit;\n  \n      rc = pager_write_pagelist(pPager,sqlite3PcacheDirtyList(pPager->pPCache));\n      if( rc!=SQLITE_OK ){\n        assert( rc!=SQLITE_IOERR_BLOCKED );\n        goto commit_phase_one_exit;\n      }\n      sqlite3PcacheCleanAll(pPager->pPCache);\n  \n      /* If the file on disk is not the same size as the database image,\n      ** then use pager_truncate to grow or shrink the file here.\n      */\n      if( pPager->dbSize!=pPager->dbFileSize ){\n        Pgno nNew = pPager->dbSize - (pPager->dbSize==PAGER_MJ_PGNO(pPager));\n        assert( pPager->eState==PAGER_WRITER_DBMOD );\n        rc = pager_truncate(pPager, nNew);\n        if( rc!=SQLITE_OK ) goto commit_phase_one_exit;\n      }\n  \n      /* Finally, sync the database file. */\n      if( !noSync ){\n        rc = sqlite3PagerSync(pPager);\n      }\n      IOTRACE((\"DBSYNC %p\\n\", pPager))\n    }\n  }\n\ncommit_phase_one_exit:\n  if( rc==SQLITE_OK && !pagerUseWal(pPager) ){\n    pPager->eState = PAGER_WRITER_FINISHED;\n  }\n  return rc;\n}\n\n\n/*\n** When this function is called, the database file has been completely\n** updated to reflect the changes made by the current transaction and\n** synced to disk. The journal file still exists in the file-system \n** though, and if a failure occurs at this point it will eventually\n** be used as a hot-journal and the current transaction rolled back.\n**\n** This function finalizes the journal file, either by deleting, \n** truncating or partially zeroing it, so that it cannot be used \n** for hot-journal rollback. Once this is done the transaction is\n** irrevocably committed.\n**\n** If an error occurs, an IO error code is returned and the pager\n** moves into the error state. Otherwise, SQLITE_OK is returned.\n*/\nSQLITE_PRIVATE int sqlite3PagerCommitPhaseTwo(Pager *pPager){\n  int rc = SQLITE_OK;                  /* Return code */\n\n  /* This routine should not be called if a prior error has occurred.\n  ** But if (due to a coding error elsewhere in the system) it does get\n  ** called, just return the same error code without doing anything. */\n  if( NEVER(pPager->errCode) ) return pPager->errCode;\n\n  assert( pPager->eState==PAGER_WRITER_LOCKED\n       || pPager->eState==PAGER_WRITER_FINISHED\n       || (pagerUseWal(pPager) && pPager->eState==PAGER_WRITER_CACHEMOD)\n  );\n  assert( assert_pager_state(pPager) );\n\n  /* An optimization. If the database was not actually modified during\n  ** this transaction, the pager is running in exclusive-mode and is\n  ** using persistent journals, then this function is a no-op.\n  **\n  ** The start of the journal file currently contains a single journal \n  ** header with the nRec field set to 0. If such a journal is used as\n  ** a hot-journal during hot-journal rollback, 0 changes will be made\n  ** to the database file. So there is no need to zero the journal \n  ** header. Since the pager is in exclusive mode, there is no need\n  ** to drop any locks either.\n  */\n  if( pPager->eState==PAGER_WRITER_LOCKED \n   && pPager->exclusiveMode \n   && pPager->journalMode==PAGER_JOURNALMODE_PERSIST\n  ){\n    assert( pPager->journalOff==JOURNAL_HDR_SZ(pPager) || !pPager->journalOff );\n    pPager->eState = PAGER_READER;\n    return SQLITE_OK;\n  }\n\n  PAGERTRACE((\"COMMIT %d\\n\", PAGERID(pPager)));\n  rc = pager_end_transaction(pPager, pPager->setMaster);\n  return pager_error(pPager, rc);\n}\n\n/*\n** If a write transaction is open, then all changes made within the \n** transaction are reverted and the current write-transaction is closed.\n** The pager falls back to PAGER_READER state if successful, or PAGER_ERROR\n** state if an error occurs.\n**\n** If the pager is already in PAGER_ERROR state when this function is called,\n** it returns Pager.errCode immediately. No work is performed in this case.\n**\n** Otherwise, in rollback mode, this function performs two functions:\n**\n**   1) It rolls back the journal file, restoring all database file and \n**      in-memory cache pages to the state they were in when the transaction\n**      was opened, and\n**\n**   2) It finalizes the journal file, so that it is not used for hot\n**      rollback at any point in the future.\n**\n** Finalization of the journal file (task 2) is only performed if the \n** rollback is successful.\n**\n** In WAL mode, all cache-entries containing data modified within the\n** current transaction are either expelled from the cache or reverted to\n** their pre-transaction state by re-reading data from the database or\n** WAL files. The WAL transaction is then closed.\n*/\nSQLITE_PRIVATE int sqlite3PagerRollback(Pager *pPager){\n  int rc = SQLITE_OK;                  /* Return code */\n  PAGERTRACE((\"ROLLBACK %d\\n\", PAGERID(pPager)));\n\n  /* PagerRollback() is a no-op if called in READER or OPEN state. If\n  ** the pager is already in the ERROR state, the rollback is not \n  ** attempted here. Instead, the error code is returned to the caller.\n  */\n  assert( assert_pager_state(pPager) );\n  if( pPager->eState==PAGER_ERROR ) return pPager->errCode;\n  if( pPager->eState<=PAGER_READER ) return SQLITE_OK;\n\n  if( pagerUseWal(pPager) ){\n    int rc2;\n    rc = sqlite3PagerSavepoint(pPager, SAVEPOINT_ROLLBACK, -1);\n    rc2 = pager_end_transaction(pPager, pPager->setMaster);\n    if( rc==SQLITE_OK ) rc = rc2;\n  }else if( !isOpen(pPager->jfd) || pPager->eState==PAGER_WRITER_LOCKED ){\n    int eState = pPager->eState;\n    rc = pager_end_transaction(pPager, 0);\n    if( !MEMDB && eState>PAGER_WRITER_LOCKED ){\n      /* This can happen using journal_mode=off. Move the pager to the error \n      ** state to indicate that the contents of the cache may not be trusted.\n      ** Any active readers will get SQLITE_ABORT.\n      */\n      pPager->errCode = SQLITE_ABORT;\n      pPager->eState = PAGER_ERROR;\n      return rc;\n    }\n  }else{\n    rc = pager_playback(pPager, 0);\n  }\n\n  assert( pPager->eState==PAGER_READER || rc!=SQLITE_OK );\n  assert( rc==SQLITE_OK || rc==SQLITE_FULL || (rc&0xFF)==SQLITE_IOERR );\n\n  /* If an error occurs during a ROLLBACK, we can no longer trust the pager\n  ** cache. So call pager_error() on the way out to make any error persistent.\n  */\n  return pager_error(pPager, rc);\n}\n\n/*\n** Return TRUE if the database file is opened read-only.  Return FALSE\n** if the database is (in theory) writable.\n*/\nSQLITE_PRIVATE u8 sqlite3PagerIsreadonly(Pager *pPager){\n  return pPager->readOnly;\n}\n\n/*\n** Return the number of references to the pager.\n*/\nSQLITE_PRIVATE int sqlite3PagerRefcount(Pager *pPager){\n  return sqlite3PcacheRefCount(pPager->pPCache);\n}\n\n/*\n** Return the approximate number of bytes of memory currently\n** used by the pager and its associated cache.\n*/\nSQLITE_PRIVATE int sqlite3PagerMemUsed(Pager *pPager){\n  int perPageSize = pPager->pageSize + pPager->nExtra + sizeof(PgHdr)\n                                     + 5*sizeof(void*);\n  return perPageSize*sqlite3PcachePagecount(pPager->pPCache)\n           + sqlite3MallocSize(pPager)\n           + pPager->pageSize;\n}\n\n/*\n** Return the number of references to the specified page.\n*/\nSQLITE_PRIVATE int sqlite3PagerPageRefcount(DbPage *pPage){\n  return sqlite3PcachePageRefcount(pPage);\n}\n\n#ifdef SQLITE_TEST\n/*\n** This routine is used for testing and analysis only.\n*/\nSQLITE_PRIVATE int *sqlite3PagerStats(Pager *pPager){\n  static int a[11];\n  a[0] = sqlite3PcacheRefCount(pPager->pPCache);\n  a[1] = sqlite3PcachePagecount(pPager->pPCache);\n  a[2] = sqlite3PcacheGetCachesize(pPager->pPCache);\n  a[3] = pPager->eState==PAGER_OPEN ? -1 : (int) pPager->dbSize;\n  a[4] = pPager->eState;\n  a[5] = pPager->errCode;\n  a[6] = pPager->nHit;\n  a[7] = pPager->nMiss;\n  a[8] = 0;  /* Used to be pPager->nOvfl */\n  a[9] = pPager->nRead;\n  a[10] = pPager->nWrite;\n  return a;\n}\n#endif\n\n/*\n** Return true if this is an in-memory pager.\n*/\nSQLITE_PRIVATE int sqlite3PagerIsMemdb(Pager *pPager){\n  return MEMDB;\n}\n\n/*\n** Check that there are at least nSavepoint savepoints open. If there are\n** currently less than nSavepoints open, then open one or more savepoints\n** to make up the difference. If the number of savepoints is already\n** equal to nSavepoint, then this function is a no-op.\n**\n** If a memory allocation fails, SQLITE_NOMEM is returned. If an error \n** occurs while opening the sub-journal file, then an IO error code is\n** returned. Otherwise, SQLITE_OK.\n*/\nSQLITE_PRIVATE int sqlite3PagerOpenSavepoint(Pager *pPager, int nSavepoint){\n  int rc = SQLITE_OK;                       /* Return code */\n  int nCurrent = pPager->nSavepoint;        /* Current number of savepoints */\n\n  assert( pPager->eState>=PAGER_WRITER_LOCKED );\n  assert( assert_pager_state(pPager) );\n\n  if( nSavepoint>nCurrent && pPager->useJournal ){\n    int ii;                                 /* Iterator variable */\n    PagerSavepoint *aNew;                   /* New Pager.aSavepoint array */\n\n    /* Grow the Pager.aSavepoint array using realloc(). Return SQLITE_NOMEM\n    ** if the allocation fails. Otherwise, zero the new portion in case a \n    ** malloc failure occurs while populating it in the for(...) loop below.\n    */\n    aNew = (PagerSavepoint *)sqlite3Realloc(\n        pPager->aSavepoint, sizeof(PagerSavepoint)*nSavepoint\n    );\n    if( !aNew ){\n      return SQLITE_NOMEM;\n    }\n    memset(&aNew[nCurrent], 0, (nSavepoint-nCurrent) * sizeof(PagerSavepoint));\n    pPager->aSavepoint = aNew;\n\n    /* Populate the PagerSavepoint structures just allocated. */\n    for(ii=nCurrent; ii<nSavepoint; ii++){\n      aNew[ii].nOrig = pPager->dbSize;\n      if( isOpen(pPager->jfd) && pPager->journalOff>0 ){\n        aNew[ii].iOffset = pPager->journalOff;\n      }else{\n        aNew[ii].iOffset = JOURNAL_HDR_SZ(pPager);\n      }\n      aNew[ii].iSubRec = pPager->nSubRec;\n      aNew[ii].pInSavepoint = sqlite3BitvecCreate(pPager->dbSize);\n      if( !aNew[ii].pInSavepoint ){\n        return SQLITE_NOMEM;\n      }\n      if( pagerUseWal(pPager) ){\n        sqlite3WalSavepoint(pPager->pWal, aNew[ii].aWalData);\n      }\n      pPager->nSavepoint = ii+1;\n    }\n    assert( pPager->nSavepoint==nSavepoint );\n    assertTruncateConstraint(pPager);\n  }\n\n  return rc;\n}\n\n/*\n** This function is called to rollback or release (commit) a savepoint.\n** The savepoint to release or rollback need not be the most recently \n** created savepoint.\n**\n** Parameter op is always either SAVEPOINT_ROLLBACK or SAVEPOINT_RELEASE.\n** If it is SAVEPOINT_RELEASE, then release and destroy the savepoint with\n** index iSavepoint. If it is SAVEPOINT_ROLLBACK, then rollback all changes\n** that have occurred since the specified savepoint was created.\n**\n** The savepoint to rollback or release is identified by parameter \n** iSavepoint. A value of 0 means to operate on the outermost savepoint\n** (the first created). A value of (Pager.nSavepoint-1) means operate\n** on the most recently created savepoint. If iSavepoint is greater than\n** (Pager.nSavepoint-1), then this function is a no-op.\n**\n** If a negative value is passed to this function, then the current\n** transaction is rolled back. This is different to calling \n** sqlite3PagerRollback() because this function does not terminate\n** the transaction or unlock the database, it just restores the \n** contents of the database to its original state. \n**\n** In any case, all savepoints with an index greater than iSavepoint \n** are destroyed. If this is a release operation (op==SAVEPOINT_RELEASE),\n** then savepoint iSavepoint is also destroyed.\n**\n** This function may return SQLITE_NOMEM if a memory allocation fails,\n** or an IO error code if an IO error occurs while rolling back a \n** savepoint. If no errors occur, SQLITE_OK is returned.\n*/ \nSQLITE_PRIVATE int sqlite3PagerSavepoint(Pager *pPager, int op, int iSavepoint){\n  int rc = pPager->errCode;       /* Return code */\n\n  assert( op==SAVEPOINT_RELEASE || op==SAVEPOINT_ROLLBACK );\n  assert( iSavepoint>=0 || op==SAVEPOINT_ROLLBACK );\n\n  if( rc==SQLITE_OK && iSavepoint<pPager->nSavepoint ){\n    int ii;            /* Iterator variable */\n    int nNew;          /* Number of remaining savepoints after this op. */\n\n    /* Figure out how many savepoints will still be active after this\n    ** operation. Store this value in nNew. Then free resources associated \n    ** with any savepoints that are destroyed by this operation.\n    */\n    nNew = iSavepoint + (( op==SAVEPOINT_RELEASE ) ? 0 : 1);\n    for(ii=nNew; ii<pPager->nSavepoint; ii++){\n      sqlite3BitvecDestroy(pPager->aSavepoint[ii].pInSavepoint);\n    }\n    pPager->nSavepoint = nNew;\n\n    /* If this is a release of the outermost savepoint, truncate \n    ** the sub-journal to zero bytes in size. */\n    if( op==SAVEPOINT_RELEASE ){\n      if( nNew==0 && isOpen(pPager->sjfd) ){\n        /* Only truncate if it is an in-memory sub-journal. */\n        if( sqlite3IsMemJournal(pPager->sjfd) ){\n          rc = sqlite3OsTruncate(pPager->sjfd, 0);\n          assert( rc==SQLITE_OK );\n        }\n        pPager->nSubRec = 0;\n      }\n    }\n    /* Else this is a rollback operation, playback the specified savepoint.\n    ** If this is a temp-file, it is possible that the journal file has\n    ** not yet been opened. In this case there have been no changes to\n    ** the database file, so the playback operation can be skipped.\n    */\n    else if( pagerUseWal(pPager) || isOpen(pPager->jfd) ){\n      PagerSavepoint *pSavepoint = (nNew==0)?0:&pPager->aSavepoint[nNew-1];\n      rc = pagerPlaybackSavepoint(pPager, pSavepoint);\n      assert(rc!=SQLITE_DONE);\n    }\n  }\n\n  return rc;\n}\n\n/*\n** Return the full pathname of the database file.\n*/\nSQLITE_PRIVATE const char *sqlite3PagerFilename(Pager *pPager){\n  return pPager->zFilename;\n}\n\n/*\n** Return the VFS structure for the pager.\n*/\nSQLITE_PRIVATE const sqlite3_vfs *sqlite3PagerVfs(Pager *pPager){\n  return pPager->pVfs;\n}\n\n/*\n** Return the file handle for the database file associated\n** with the pager.  This might return NULL if the file has\n** not yet been opened.\n*/\nSQLITE_PRIVATE sqlite3_file *sqlite3PagerFile(Pager *pPager){\n  return pPager->fd;\n}\n\n/*\n** Return the full pathname of the journal file.\n*/\nSQLITE_PRIVATE const char *sqlite3PagerJournalname(Pager *pPager){\n  return pPager->zJournal;\n}\n\n/*\n** Return true if fsync() calls are disabled for this pager.  Return FALSE\n** if fsync()s are executed normally.\n*/\nSQLITE_PRIVATE int sqlite3PagerNosync(Pager *pPager){\n  return pPager->noSync;\n}\n\n#ifdef SQLITE_HAS_CODEC\n/*\n** Set or retrieve the codec for this pager\n*/\nSQLITE_PRIVATE void sqlite3PagerSetCodec(\n  Pager *pPager,\n  void *(*xCodec)(void*,void*,Pgno,int),\n  void (*xCodecSizeChng)(void*,int,int),\n  void (*xCodecFree)(void*),\n  void *pCodec\n){\n  if( pPager->xCodecFree ) pPager->xCodecFree(pPager->pCodec);\n  pPager->xCodec = pPager->memDb ? 0 : xCodec;\n  pPager->xCodecSizeChng = xCodecSizeChng;\n  pPager->xCodecFree = xCodecFree;\n  pPager->pCodec = pCodec;\n  pagerReportSize(pPager);\n}\n/* Set pager codec for a BTree's pager */\nSQLITE_PRIVATE void sqlite3BtreePagerSetCodec(\n  Btree *bt,\n  void *(*xCodec)(void*,void*,Pgno,int),\n  void (*xCodecSizeChng)(void*,int,int),\n  void (*xCodecFree)(void*),\n  void *pCodec\n){\n  return sqlite3PagerSetCodec(sqlite3BtreePager(bt), xCodec, xCodecSizeChng, xCodecFree, pCodec);\n}\n\nSQLITE_PRIVATE void *sqlite3PagerGetCodec(Pager *pPager){\n  return pPager->pCodec;\n}\n#endif\n\n#ifndef SQLITE_OMIT_AUTOVACUUM\n/*\n** Move the page pPg to location pgno in the file.\n**\n** There must be no references to the page previously located at\n** pgno (which we call pPgOld) though that page is allowed to be\n** in cache.  If the page previously located at pgno is not already\n** in the rollback journal, it is not put there by by this routine.\n**\n** References to the page pPg remain valid. Updating any\n** meta-data associated with pPg (i.e. data stored in the nExtra bytes\n** allocated along with the page) is the responsibility of the caller.\n**\n** A transaction must be active when this routine is called. It used to be\n** required that a statement transaction was not active, but this restriction\n** has been removed (CREATE INDEX needs to move a page when a statement\n** transaction is active).\n**\n** If the fourth argument, isCommit, is non-zero, then this page is being\n** moved as part of a database reorganization just before the transaction \n** is being committed. In this case, it is guaranteed that the database page \n** pPg refers to will not be written to again within this transaction.\n**\n** This function may return SQLITE_NOMEM or an IO error code if an error\n** occurs. Otherwise, it returns SQLITE_OK.\n*/\nSQLITE_PRIVATE int sqlite3PagerMovepage(Pager *pPager, DbPage *pPg, Pgno pgno, int isCommit){\n  PgHdr *pPgOld;               /* The page being overwritten. */\n  Pgno needSyncPgno = 0;       /* Old value of pPg->pgno, if sync is required */\n  int rc;                      /* Return code */\n  Pgno origPgno;               /* The original page number */\n\n  assert( pPg->nRef>0 );\n  assert( pPager->eState==PAGER_WRITER_CACHEMOD\n       || pPager->eState==PAGER_WRITER_DBMOD\n  );\n  assert( assert_pager_state(pPager) );\n\n  /* In order to be able to rollback, an in-memory database must journal\n  ** the page we are moving from.\n  */\n  if( MEMDB ){\n    rc = sqlite3PagerWrite(pPg);\n    if( rc ) return rc;\n  }\n\n  /* If the page being moved is dirty and has not been saved by the latest\n  ** savepoint, then save the current contents of the page into the \n  ** sub-journal now. This is required to handle the following scenario:\n  **\n  **   BEGIN;\n  **     <journal page X, then modify it in memory>\n  **     SAVEPOINT one;\n  **       <Move page X to location Y>\n  **     ROLLBACK TO one;\n  **\n  ** If page X were not written to the sub-journal here, it would not\n  ** be possible to restore its contents when the \"ROLLBACK TO one\"\n  ** statement were is processed.\n  **\n  ** subjournalPage() may need to allocate space to store pPg->pgno into\n  ** one or more savepoint bitvecs. This is the reason this function\n  ** may return SQLITE_NOMEM.\n  */\n  if( pPg->flags&PGHDR_DIRTY\n   && subjRequiresPage(pPg)\n   && SQLITE_OK!=(rc = subjournalPage(pPg))\n  ){\n    return rc;\n  }\n\n  PAGERTRACE((\"MOVE %d page %d (needSync=%d) moves to %d\\n\", \n      PAGERID(pPager), pPg->pgno, (pPg->flags&PGHDR_NEED_SYNC)?1:0, pgno));\n  IOTRACE((\"MOVE %p %d %d\\n\", pPager, pPg->pgno, pgno))\n\n  /* If the journal needs to be sync()ed before page pPg->pgno can\n  ** be written to, store pPg->pgno in local variable needSyncPgno.\n  **\n  ** If the isCommit flag is set, there is no need to remember that\n  ** the journal needs to be sync()ed before database page pPg->pgno \n  ** can be written to. The caller has already promised not to write to it.\n  */\n  if( (pPg->flags&PGHDR_NEED_SYNC) && !isCommit ){\n    needSyncPgno = pPg->pgno;\n    assert( pageInJournal(pPg) || pPg->pgno>pPager->dbOrigSize );\n    assert( pPg->flags&PGHDR_DIRTY );\n  }\n\n  /* If the cache contains a page with page-number pgno, remove it\n  ** from its hash chain. Also, if the PGHDR_NEED_SYNC flag was set for \n  ** page pgno before the 'move' operation, it needs to be retained \n  ** for the page moved there.\n  */\n  pPg->flags &= ~PGHDR_NEED_SYNC;\n  pPgOld = pager_lookup(pPager, pgno);\n  assert( !pPgOld || pPgOld->nRef==1 );\n  if( pPgOld ){\n    pPg->flags |= (pPgOld->flags&PGHDR_NEED_SYNC);\n    if( MEMDB ){\n      /* Do not discard pages from an in-memory database since we might\n      ** need to rollback later.  Just move the page out of the way. */\n      sqlite3PcacheMove(pPgOld, pPager->dbSize+1);\n    }else{\n      sqlite3PcacheDrop(pPgOld);\n    }\n  }\n\n  origPgno = pPg->pgno;\n  sqlite3PcacheMove(pPg, pgno);\n  sqlite3PcacheMakeDirty(pPg);\n\n  /* For an in-memory database, make sure the original page continues\n  ** to exist, in case the transaction needs to roll back.  Use pPgOld\n  ** as the original page since it has already been allocated.\n  */\n  if( MEMDB ){\n    assert( pPgOld );\n    sqlite3PcacheMove(pPgOld, origPgno);\n    sqlite3PagerUnref(pPgOld);\n  }\n\n  if( needSyncPgno ){\n    /* If needSyncPgno is non-zero, then the journal file needs to be \n    ** sync()ed before any data is written to database file page needSyncPgno.\n    ** Currently, no such page exists in the page-cache and the \n    ** \"is journaled\" bitvec flag has been set. This needs to be remedied by\n    ** loading the page into the pager-cache and setting the PGHDR_NEED_SYNC\n    ** flag.\n    **\n    ** If the attempt to load the page into the page-cache fails, (due\n    ** to a malloc() or IO failure), clear the bit in the pInJournal[]\n    ** array. Otherwise, if the page is loaded and written again in\n    ** this transaction, it may be written to the database file before\n    ** it is synced into the journal file. This way, it may end up in\n    ** the journal file twice, but that is not a problem.\n    */\n    PgHdr *pPgHdr;\n    rc = sqlite3PagerGet(pPager, needSyncPgno, &pPgHdr);\n    if( rc!=SQLITE_OK ){\n      if( needSyncPgno<=pPager->dbOrigSize ){\n        assert( pPager->pTmpSpace!=0 );\n        sqlite3BitvecClear(pPager->pInJournal, needSyncPgno, pPager->pTmpSpace);\n      }\n      return rc;\n    }\n    pPgHdr->flags |= PGHDR_NEED_SYNC;\n    sqlite3PcacheMakeDirty(pPgHdr);\n    sqlite3PagerUnref(pPgHdr);\n  }\n\n  return SQLITE_OK;\n}\n#endif\n\n/*\n** Return a pointer to the data for the specified page.\n*/\nSQLITE_PRIVATE void *sqlite3PagerGetData(DbPage *pPg){\n  assert( pPg->nRef>0 || pPg->pPager->memDb );\n  return pPg->pData;\n}\n\n/*\n** Return a pointer to the Pager.nExtra bytes of \"extra\" space \n** allocated along with the specified page.\n*/\nSQLITE_PRIVATE void *sqlite3PagerGetExtra(DbPage *pPg){\n  return pPg->pExtra;\n}\n\n/*\n** Get/set the locking-mode for this pager. Parameter eMode must be one\n** of PAGER_LOCKINGMODE_QUERY, PAGER_LOCKINGMODE_NORMAL or \n** PAGER_LOCKINGMODE_EXCLUSIVE. If the parameter is not _QUERY, then\n** the locking-mode is set to the value specified.\n**\n** The returned value is either PAGER_LOCKINGMODE_NORMAL or\n** PAGER_LOCKINGMODE_EXCLUSIVE, indicating the current (possibly updated)\n** locking-mode.\n*/\nSQLITE_PRIVATE int sqlite3PagerLockingMode(Pager *pPager, int eMode){\n  assert( eMode==PAGER_LOCKINGMODE_QUERY\n            || eMode==PAGER_LOCKINGMODE_NORMAL\n            || eMode==PAGER_LOCKINGMODE_EXCLUSIVE );\n  assert( PAGER_LOCKINGMODE_QUERY<0 );\n  assert( PAGER_LOCKINGMODE_NORMAL>=0 && PAGER_LOCKINGMODE_EXCLUSIVE>=0 );\n  assert( pPager->exclusiveMode || 0==sqlite3WalHeapMemory(pPager->pWal) );\n  if( eMode>=0 && !pPager->tempFile && !sqlite3WalHeapMemory(pPager->pWal) ){\n    pPager->exclusiveMode = (u8)eMode;\n  }\n  return (int)pPager->exclusiveMode;\n}\n\n/*\n** Set the journal-mode for this pager. Parameter eMode must be one of:\n**\n**    PAGER_JOURNALMODE_DELETE\n**    PAGER_JOURNALMODE_TRUNCATE\n**    PAGER_JOURNALMODE_PERSIST\n**    PAGER_JOURNALMODE_OFF\n**    PAGER_JOURNALMODE_MEMORY\n**    PAGER_JOURNALMODE_WAL\n**\n** The journalmode is set to the value specified if the change is allowed.\n** The change may be disallowed for the following reasons:\n**\n**   *  An in-memory database can only have its journal_mode set to _OFF\n**      or _MEMORY.\n**\n**   *  Temporary databases cannot have _WAL journalmode.\n**\n** The returned indicate the current (possibly updated) journal-mode.\n*/\nSQLITE_PRIVATE int sqlite3PagerSetJournalMode(Pager *pPager, int eMode){\n  u8 eOld = pPager->journalMode;    /* Prior journalmode */\n\n#ifdef SQLITE_DEBUG\n  /* The print_pager_state() routine is intended to be used by the debugger\n  ** only.  We invoke it once here to suppress a compiler warning. */\n  print_pager_state(pPager);\n#endif\n\n\n  /* The eMode parameter is always valid */\n  assert(      eMode==PAGER_JOURNALMODE_DELETE\n            || eMode==PAGER_JOURNALMODE_TRUNCATE\n            || eMode==PAGER_JOURNALMODE_PERSIST\n            || eMode==PAGER_JOURNALMODE_OFF \n            || eMode==PAGER_JOURNALMODE_WAL \n            || eMode==PAGER_JOURNALMODE_MEMORY );\n\n  /* This routine is only called from the OP_JournalMode opcode, and\n  ** the logic there will never allow a temporary file to be changed\n  ** to WAL mode.\n  */\n  assert( pPager->tempFile==0 || eMode!=PAGER_JOURNALMODE_WAL );\n\n  /* Do allow the journalmode of an in-memory database to be set to\n  ** anything other than MEMORY or OFF\n  */\n  if( MEMDB ){\n    assert( eOld==PAGER_JOURNALMODE_MEMORY || eOld==PAGER_JOURNALMODE_OFF );\n    if( eMode!=PAGER_JOURNALMODE_MEMORY && eMode!=PAGER_JOURNALMODE_OFF ){\n      eMode = eOld;\n    }\n  }\n\n  if( eMode!=eOld ){\n\n    /* Change the journal mode. */\n    assert( pPager->eState!=PAGER_ERROR );\n    pPager->journalMode = (u8)eMode;\n\n    /* When transistioning from TRUNCATE or PERSIST to any other journal\n    ** mode except WAL, unless the pager is in locking_mode=exclusive mode,\n    ** delete the journal file.\n    */\n    assert( (PAGER_JOURNALMODE_TRUNCATE & 5)==1 );\n    assert( (PAGER_JOURNALMODE_PERSIST & 5)==1 );\n    assert( (PAGER_JOURNALMODE_DELETE & 5)==0 );\n    assert( (PAGER_JOURNALMODE_MEMORY & 5)==4 );\n    assert( (PAGER_JOURNALMODE_OFF & 5)==0 );\n    assert( (PAGER_JOURNALMODE_WAL & 5)==5 );\n\n    assert( isOpen(pPager->fd) || pPager->exclusiveMode );\n    if( !pPager->exclusiveMode && (eOld & 5)==1 && (eMode & 1)==0 ){\n\n      /* In this case we would like to delete the journal file. If it is\n      ** not possible, then that is not a problem. Deleting the journal file\n      ** here is an optimization only.\n      **\n      ** Before deleting the journal file, obtain a RESERVED lock on the\n      ** database file. This ensures that the journal file is not deleted\n      ** while it is in use by some other client.\n      */\n      sqlite3OsClose(pPager->jfd);\n      if( pPager->eLock>=RESERVED_LOCK ){\n        sqlite3OsDelete(pPager->pVfs, pPager->zJournal, 0);\n      }else{\n        int rc = SQLITE_OK;\n        int state = pPager->eState;\n        assert( state==PAGER_OPEN || state==PAGER_READER );\n        if( state==PAGER_OPEN ){\n          rc = sqlite3PagerSharedLock(pPager);\n        }\n        if( pPager->eState==PAGER_READER ){\n          assert( rc==SQLITE_OK );\n          rc = pagerLockDb(pPager, RESERVED_LOCK);\n        }\n        if( rc==SQLITE_OK ){\n          sqlite3OsDelete(pPager->pVfs, pPager->zJournal, 0);\n        }\n        if( rc==SQLITE_OK && state==PAGER_READER ){\n          pagerUnlockDb(pPager, SHARED_LOCK);\n        }else if( state==PAGER_OPEN ){\n          pager_unlock(pPager);\n        }\n        assert( state==pPager->eState );\n      }\n    }\n  }\n\n  /* Return the new journal mode */\n  return (int)pPager->journalMode;\n}\n\n/*\n** Return the current journal mode.\n*/\nSQLITE_PRIVATE int sqlite3PagerGetJournalMode(Pager *pPager){\n  return (int)pPager->journalMode;\n}\n\n/*\n** Return TRUE if the pager is in a state where it is OK to change the\n** journalmode.  Journalmode changes can only happen when the database\n** is unmodified.\n*/\nSQLITE_PRIVATE int sqlite3PagerOkToChangeJournalMode(Pager *pPager){\n  assert( assert_pager_state(pPager) );\n  if( pPager->eState>=PAGER_WRITER_CACHEMOD ) return 0;\n  if( NEVER(isOpen(pPager->jfd) && pPager->journalOff>0) ) return 0;\n  return 1;\n}\n\n/*\n** Get/set the size-limit used for persistent journal files.\n**\n** Setting the size limit to -1 means no limit is enforced.\n** An attempt to set a limit smaller than -1 is a no-op.\n*/\nSQLITE_PRIVATE i64 sqlite3PagerJournalSizeLimit(Pager *pPager, i64 iLimit){\n  if( iLimit>=-1 ){\n    pPager->journalSizeLimit = iLimit;\n  }\n  return pPager->journalSizeLimit;\n}\n\n/*\n** Return a pointer to the pPager->pBackup variable. The backup module\n** in backup.c maintains the content of this variable. This module\n** uses it opaquely as an argument to sqlite3BackupRestart() and\n** sqlite3BackupUpdate() only.\n*/\nSQLITE_PRIVATE sqlite3_backup **sqlite3PagerBackupPtr(Pager *pPager){\n  return &pPager->pBackup;\n}\n\n#ifndef SQLITE_OMIT_WAL\n/*\n** This function is called when the user invokes \"PRAGMA wal_checkpoint\",\n** \"PRAGMA wal_blocking_checkpoint\" or calls the sqlite3_wal_checkpoint()\n** or wal_blocking_checkpoint() API functions.\n**\n** Parameter eMode is one of SQLITE_CHECKPOINT_PASSIVE, FULL or RESTART.\n*/\nSQLITE_PRIVATE int sqlite3PagerCheckpoint(Pager *pPager, int eMode, int *pnLog, int *pnCkpt){\n  int rc = SQLITE_OK;\n  if( pPager->pWal ){\n    rc = sqlite3WalCheckpoint(pPager->pWal, eMode,\n        pPager->xBusyHandler, pPager->pBusyHandlerArg,\n        pPager->ckptSyncFlags, pPager->pageSize, (u8 *)pPager->pTmpSpace,\n        pnLog, pnCkpt\n    );\n  }\n  return rc;\n}\n\nSQLITE_PRIVATE int sqlite3PagerWalCallback(Pager *pPager){\n  return sqlite3WalCallback(pPager->pWal);\n}\n\n/*\n** Return true if the underlying VFS for the given pager supports the\n** primitives necessary for write-ahead logging.\n*/\nSQLITE_PRIVATE int sqlite3PagerWalSupported(Pager *pPager){\n  const sqlite3_io_methods *pMethods = pPager->fd->pMethods;\n  return pPager->exclusiveMode || (pMethods->iVersion>=2 && pMethods->xShmMap);\n}\n\n/*\n** Attempt to take an exclusive lock on the database file. If a PENDING lock\n** is obtained instead, immediately release it.\n*/\nstatic int pagerExclusiveLock(Pager *pPager){\n  int rc;                         /* Return code */\n\n  assert( pPager->eLock==SHARED_LOCK || pPager->eLock==EXCLUSIVE_LOCK );\n  rc = pagerLockDb(pPager, EXCLUSIVE_LOCK);\n  if( rc!=SQLITE_OK ){\n    /* If the attempt to grab the exclusive lock failed, release the \n    ** pending lock that may have been obtained instead.  */\n    pagerUnlockDb(pPager, SHARED_LOCK);\n  }\n\n  return rc;\n}\n\n/*\n** Call sqlite3WalOpen() to open the WAL handle. If the pager is in \n** exclusive-locking mode when this function is called, take an EXCLUSIVE\n** lock on the database file and use heap-memory to store the wal-index\n** in. Otherwise, use the normal shared-memory.\n*/\nstatic int pagerOpenWal(Pager *pPager){\n  int rc = SQLITE_OK;\n\n  assert( pPager->pWal==0 && pPager->tempFile==0 );\n  assert( pPager->eLock==SHARED_LOCK || pPager->eLock==EXCLUSIVE_LOCK || pPager->noReadlock);\n\n  /* If the pager is already in exclusive-mode, the WAL module will use \n  ** heap-memory for the wal-index instead of the VFS shared-memory \n  ** implementation. Take the exclusive lock now, before opening the WAL\n  ** file, to make sure this is safe.\n  */\n  if( pPager->exclusiveMode ){\n    rc = pagerExclusiveLock(pPager);\n  }\n\n  /* Open the connection to the log file. If this operation fails, \n  ** (e.g. due to malloc() failure), return an error code.\n  */\n  if( rc==SQLITE_OK ){\n    rc = sqlite3WalOpen(pPager->pVfs, \n        pPager->fd, pPager->zWal, pPager->exclusiveMode, &pPager->pWal\n    );\n  }\n\n  return rc;\n}\n\n\n/*\n** The caller must be holding a SHARED lock on the database file to call\n** this function.\n**\n** If the pager passed as the first argument is open on a real database\n** file (not a temp file or an in-memory database), and the WAL file\n** is not already open, make an attempt to open it now. If successful,\n** return SQLITE_OK. If an error occurs or the VFS used by the pager does \n** not support the xShmXXX() methods, return an error code. *pbOpen is\n** not modified in either case.\n**\n** If the pager is open on a temp-file (or in-memory database), or if\n** the WAL file is already open, set *pbOpen to 1 and return SQLITE_OK\n** without doing anything.\n*/\nSQLITE_PRIVATE int sqlite3PagerOpenWal(\n  Pager *pPager,                  /* Pager object */\n  int *pbOpen                     /* OUT: Set to true if call is a no-op */\n){\n  int rc = SQLITE_OK;             /* Return code */\n\n  assert( assert_pager_state(pPager) );\n  assert( pPager->eState==PAGER_OPEN   || pbOpen );\n  assert( pPager->eState==PAGER_READER || !pbOpen );\n  assert( pbOpen==0 || *pbOpen==0 );\n  assert( pbOpen!=0 || (!pPager->tempFile && !pPager->pWal) );\n\n  if( !pPager->tempFile && !pPager->pWal ){\n    if( !sqlite3PagerWalSupported(pPager) ) return SQLITE_CANTOPEN;\n\n    /* Close any rollback journal previously open */\n    sqlite3OsClose(pPager->jfd);\n\n    rc = pagerOpenWal(pPager);\n    if( rc==SQLITE_OK ){\n      pPager->journalMode = PAGER_JOURNALMODE_WAL;\n      pPager->eState = PAGER_OPEN;\n    }\n  }else{\n    *pbOpen = 1;\n  }\n\n  return rc;\n}\n\n/*\n** This function is called to close the connection to the log file prior\n** to switching from WAL to rollback mode.\n**\n** Before closing the log file, this function attempts to take an \n** EXCLUSIVE lock on the database file. If this cannot be obtained, an\n** error (SQLITE_BUSY) is returned and the log connection is not closed.\n** If successful, the EXCLUSIVE lock is not released before returning.\n*/\nSQLITE_PRIVATE int sqlite3PagerCloseWal(Pager *pPager){\n  int rc = SQLITE_OK;\n\n  assert( pPager->journalMode==PAGER_JOURNALMODE_WAL );\n\n  /* If the log file is not already open, but does exist in the file-system,\n  ** it may need to be checkpointed before the connection can switch to\n  ** rollback mode. Open it now so this can happen.\n  */\n  if( !pPager->pWal ){\n    int logexists = 0;\n    rc = pagerLockDb(pPager, SHARED_LOCK);\n    if( rc==SQLITE_OK ){\n      rc = sqlite3OsAccess(\n          pPager->pVfs, pPager->zWal, SQLITE_ACCESS_EXISTS, &logexists\n      );\n    }\n    if( rc==SQLITE_OK && logexists ){\n      rc = pagerOpenWal(pPager);\n    }\n  }\n    \n  /* Checkpoint and close the log. Because an EXCLUSIVE lock is held on\n  ** the database file, the log and log-summary files will be deleted.\n  */\n  if( rc==SQLITE_OK && pPager->pWal ){\n    rc = pagerExclusiveLock(pPager);\n    if( rc==SQLITE_OK ){\n      rc = sqlite3WalClose(pPager->pWal, pPager->ckptSyncFlags,\n                           pPager->pageSize, (u8*)pPager->pTmpSpace);\n      pPager->pWal = 0;\n    }\n  }\n  return rc;\n}\n\n#ifdef SQLITE_HAS_CODEC\n/*\n** This function is called by the wal module when writing page content\n** into the log file.\n**\n** This function returns a pointer to a buffer containing the encrypted\n** page content. If a malloc fails, this function may return NULL.\n*/\nSQLITE_PRIVATE void *sqlite3PagerCodec(PgHdr *pPg){\n  void *aData = 0;\n  CODEC2(pPg->pPager, pPg->pData, pPg->pgno, 6, return 0, aData);\n  return aData;\n}\n#endif /* SQLITE_HAS_CODEC */\n\n#endif /* !SQLITE_OMIT_WAL */\n\n#endif /* SQLITE_OMIT_DISKIO */\n\n/************** End of pager.c ***********************************************/\n/************** Begin file wal.c *********************************************/\n/*\n** 2010 February 1\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n**\n** This file contains the implementation of a write-ahead log (WAL) used in \n** \"journal_mode=WAL\" mode.\n**\n** WRITE-AHEAD LOG (WAL) FILE FORMAT\n**\n** A WAL file consists of a header followed by zero or more \"frames\".\n** Each frame records the revised content of a single page from the\n** database file.  All changes to the database are recorded by writing\n** frames into the WAL.  Transactions commit when a frame is written that\n** contains a commit marker.  A single WAL can and usually does record \n** multiple transactions.  Periodically, the content of the WAL is\n** transferred back into the database file in an operation called a\n** \"checkpoint\".\n**\n** A single WAL file can be used multiple times.  In other words, the\n** WAL can fill up with frames and then be checkpointed and then new\n** frames can overwrite the old ones.  A WAL always grows from beginning\n** toward the end.  Checksums and counters attached to each frame are\n** used to determine which frames within the WAL are valid and which\n** are leftovers from prior checkpoints.\n**\n** The WAL header is 32 bytes in size and consists of the following eight\n** big-endian 32-bit unsigned integer values:\n**\n**     0: Magic number.  0x377f0682 or 0x377f0683\n**     4: File format version.  Currently 3007000\n**     8: Database page size.  Example: 1024\n**    12: Checkpoint sequence number\n**    16: Salt-1, random integer incremented with each checkpoint\n**    20: Salt-2, a different random integer changing with each ckpt\n**    24: Checksum-1 (first part of checksum for first 24 bytes of header).\n**    28: Checksum-2 (second part of checksum for first 24 bytes of header).\n**\n** Immediately following the wal-header are zero or more frames. Each\n** frame consists of a 24-byte frame-header followed by a <page-size> bytes\n** of page data. The frame-header is six big-endian 32-bit unsigned \n** integer values, as follows:\n**\n**     0: Page number.\n**     4: For commit records, the size of the database image in pages \n**        after the commit. For all other records, zero.\n**     8: Salt-1 (copied from the header)\n**    12: Salt-2 (copied from the header)\n**    16: Checksum-1.\n**    20: Checksum-2.\n**\n** A frame is considered valid if and only if the following conditions are\n** true:\n**\n**    (1) The salt-1 and salt-2 values in the frame-header match\n**        salt values in the wal-header\n**\n**    (2) The checksum values in the final 8 bytes of the frame-header\n**        exactly match the checksum computed consecutively on the\n**        WAL header and the first 8 bytes and the content of all frames\n**        up to and including the current frame.\n**\n** The checksum is computed using 32-bit big-endian integers if the\n** magic number in the first 4 bytes of the WAL is 0x377f0683 and it\n** is computed using little-endian if the magic number is 0x377f0682.\n** The checksum values are always stored in the frame header in a\n** big-endian format regardless of which byte order is used to compute\n** the checksum.  The checksum is computed by interpreting the input as\n** an even number of unsigned 32-bit integers: x[0] through x[N].  The\n** algorithm used for the checksum is as follows:\n** \n**   for i from 0 to n-1 step 2:\n**     s0 += x[i] + s1;\n**     s1 += x[i+1] + s0;\n**   endfor\n**\n** Note that s0 and s1 are both weighted checksums using fibonacci weights\n** in reverse order (the largest fibonacci weight occurs on the first element\n** of the sequence being summed.)  The s1 value spans all 32-bit \n** terms of the sequence whereas s0 omits the final term.\n**\n** On a checkpoint, the WAL is first VFS.xSync-ed, then valid content of the\n** WAL is transferred into the database, then the database is VFS.xSync-ed.\n** The VFS.xSync operations serve as write barriers - all writes launched\n** before the xSync must complete before any write that launches after the\n** xSync begins.\n**\n** After each checkpoint, the salt-1 value is incremented and the salt-2\n** value is randomized.  This prevents old and new frames in the WAL from\n** being considered valid at the same time and being checkpointing together\n** following a crash.\n**\n** READER ALGORITHM\n**\n** To read a page from the database (call it page number P), a reader\n** first checks the WAL to see if it contains page P.  If so, then the\n** last valid instance of page P that is a followed by a commit frame\n** or is a commit frame itself becomes the value read.  If the WAL\n** contains no copies of page P that are valid and which are a commit\n** frame or are followed by a commit frame, then page P is read from\n** the database file.\n**\n** To start a read transaction, the reader records the index of the last\n** valid frame in the WAL.  The reader uses this recorded \"mxFrame\" value\n** for all subsequent read operations.  New transactions can be appended\n** to the WAL, but as long as the reader uses its original mxFrame value\n** and ignores the newly appended content, it will see a consistent snapshot\n** of the database from a single point in time.  This technique allows\n** multiple concurrent readers to view different versions of the database\n** content simultaneously.\n**\n** The reader algorithm in the previous paragraphs works correctly, but \n** because frames for page P can appear anywhere within the WAL, the\n** reader has to scan the entire WAL looking for page P frames.  If the\n** WAL is large (multiple megabytes is typical) that scan can be slow,\n** and read performance suffers.  To overcome this problem, a separate\n** data structure called the wal-index is maintained to expedite the\n** search for frames of a particular page.\n** \n** WAL-INDEX FORMAT\n**\n** Conceptually, the wal-index is shared memory, though VFS implementations\n** might choose to implement the wal-index using a mmapped file.  Because\n** the wal-index is shared memory, SQLite does not support journal_mode=WAL \n** on a network filesystem.  All users of the database must be able to\n** share memory.\n**\n** The wal-index is transient.  After a crash, the wal-index can (and should\n** be) reconstructed from the original WAL file.  In fact, the VFS is required\n** to either truncate or zero the header of the wal-index when the last\n** connection to it closes.  Because the wal-index is transient, it can\n** use an architecture-specific format; it does not have to be cross-platform.\n** Hence, unlike the database and WAL file formats which store all values\n** as big endian, the wal-index can store multi-byte values in the native\n** byte order of the host computer.\n**\n** The purpose of the wal-index is to answer this question quickly:  Given\n** a page number P, return the index of the last frame for page P in the WAL,\n** or return NULL if there are no frames for page P in the WAL.\n**\n** The wal-index consists of a header region, followed by an one or\n** more index blocks.  \n**\n** The wal-index header contains the total number of frames within the WAL\n** in the the mxFrame field.  \n**\n** Each index block except for the first contains information on \n** HASHTABLE_NPAGE frames. The first index block contains information on\n** HASHTABLE_NPAGE_ONE frames. The values of HASHTABLE_NPAGE_ONE and \n** HASHTABLE_NPAGE are selected so that together the wal-index header and\n** first index block are the same size as all other index blocks in the\n** wal-index.\n**\n** Each index block contains two sections, a page-mapping that contains the\n** database page number associated with each wal frame, and a hash-table \n** that allows readers to query an index block for a specific page number.\n** The page-mapping is an array of HASHTABLE_NPAGE (or HASHTABLE_NPAGE_ONE\n** for the first index block) 32-bit page numbers. The first entry in the \n** first index-block contains the database page number corresponding to the\n** first frame in the WAL file. The first entry in the second index block\n** in the WAL file corresponds to the (HASHTABLE_NPAGE_ONE+1)th frame in\n** the log, and so on.\n**\n** The last index block in a wal-index usually contains less than the full\n** complement of HASHTABLE_NPAGE (or HASHTABLE_NPAGE_ONE) page-numbers,\n** depending on the contents of the WAL file. This does not change the\n** allocated size of the page-mapping array - the page-mapping array merely\n** contains unused entries.\n**\n** Even without using the hash table, the last frame for page P\n** can be found by scanning the page-mapping sections of each index block\n** starting with the last index block and moving toward the first, and\n** within each index block, starting at the end and moving toward the\n** beginning.  The first entry that equals P corresponds to the frame\n** holding the content for that page.\n**\n** The hash table consists of HASHTABLE_NSLOT 16-bit unsigned integers.\n** HASHTABLE_NSLOT = 2*HASHTABLE_NPAGE, and there is one entry in the\n** hash table for each page number in the mapping section, so the hash \n** table is never more than half full.  The expected number of collisions \n** prior to finding a match is 1.  Each entry of the hash table is an\n** 1-based index of an entry in the mapping section of the same\n** index block.   Let K be the 1-based index of the largest entry in\n** the mapping section.  (For index blocks other than the last, K will\n** always be exactly HASHTABLE_NPAGE (4096) and for the last index block\n** K will be (mxFrame%HASHTABLE_NPAGE).)  Unused slots of the hash table\n** contain a value of 0.\n**\n** To look for page P in the hash table, first compute a hash iKey on\n** P as follows:\n**\n**      iKey = (P * 383) % HASHTABLE_NSLOT\n**\n** Then start scanning entries of the hash table, starting with iKey\n** (wrapping around to the beginning when the end of the hash table is\n** reached) until an unused hash slot is found. Let the first unused slot\n** be at index iUnused.  (iUnused might be less than iKey if there was\n** wrap-around.) Because the hash table is never more than half full,\n** the search is guaranteed to eventually hit an unused entry.  Let \n** iMax be the value between iKey and iUnused, closest to iUnused,\n** where aHash[iMax]==P.  If there is no iMax entry (if there exists\n** no hash slot such that aHash[i]==p) then page P is not in the\n** current index block.  Otherwise the iMax-th mapping entry of the\n** current index block corresponds to the last entry that references \n** page P.\n**\n** A hash search begins with the last index block and moves toward the\n** first index block, looking for entries corresponding to page P.  On\n** average, only two or three slots in each index block need to be\n** examined in order to either find the last entry for page P, or to\n** establish that no such entry exists in the block.  Each index block\n** holds over 4000 entries.  So two or three index blocks are sufficient\n** to cover a typical 10 megabyte WAL file, assuming 1K pages.  8 or 10\n** comparisons (on average) suffice to either locate a frame in the\n** WAL or to establish that the frame does not exist in the WAL.  This\n** is much faster than scanning the entire 10MB WAL.\n**\n** Note that entries are added in order of increasing K.  Hence, one\n** reader might be using some value K0 and a second reader that started\n** at a later time (after additional transactions were added to the WAL\n** and to the wal-index) might be using a different value K1, where K1>K0.\n** Both readers can use the same hash table and mapping section to get\n** the correct result.  There may be entries in the hash table with\n** K>K0 but to the first reader, those entries will appear to be unused\n** slots in the hash table and so the first reader will get an answer as\n** if no values greater than K0 had ever been inserted into the hash table\n** in the first place - which is what reader one wants.  Meanwhile, the\n** second reader using K1 will see additional values that were inserted\n** later, which is exactly what reader two wants.  \n**\n** When a rollback occurs, the value of K is decreased. Hash table entries\n** that correspond to frames greater than the new K value are removed\n** from the hash table at this point.\n*/\n#ifndef SQLITE_OMIT_WAL\n\n\n/*\n** Trace output macros\n*/\n#if defined(SQLITE_TEST) && defined(SQLITE_DEBUG)\nSQLITE_PRIVATE int sqlite3WalTrace = 0;\n# define WALTRACE(X)  if(sqlite3WalTrace) sqlite3DebugPrintf X\n#else\n# define WALTRACE(X)\n#endif\n\n/*\n** The maximum (and only) versions of the wal and wal-index formats\n** that may be interpreted by this version of SQLite.\n**\n** If a client begins recovering a WAL file and finds that (a) the checksum\n** values in the wal-header are correct and (b) the version field is not\n** WAL_MAX_VERSION, recovery fails and SQLite returns SQLITE_CANTOPEN.\n**\n** Similarly, if a client successfully reads a wal-index header (i.e. the \n** checksum test is successful) and finds that the version field is not\n** WALINDEX_MAX_VERSION, then no read-transaction is opened and SQLite\n** returns SQLITE_CANTOPEN.\n*/\n#define WAL_MAX_VERSION      3007000\n#define WALINDEX_MAX_VERSION 3007000\n\n/*\n** Indices of various locking bytes.   WAL_NREADER is the number\n** of available reader locks and should be at least 3.\n*/\n#define WAL_WRITE_LOCK         0\n#define WAL_ALL_BUT_WRITE      1\n#define WAL_CKPT_LOCK          1\n#define WAL_RECOVER_LOCK       2\n#define WAL_READ_LOCK(I)       (3+(I))\n#define WAL_NREADER            (SQLITE_SHM_NLOCK-3)\n\n\n/* Object declarations */\ntypedef struct WalIndexHdr WalIndexHdr;\ntypedef struct WalIterator WalIterator;\ntypedef struct WalCkptInfo WalCkptInfo;\n\n\n/*\n** The following object holds a copy of the wal-index header content.\n**\n** The actual header in the wal-index consists of two copies of this\n** object.\n**\n** The szPage value can be any power of 2 between 512 and 32768, inclusive.\n** Or it can be 1 to represent a 65536-byte page.  The latter case was\n** added in 3.7.1 when support for 64K pages was added.  \n*/\nstruct WalIndexHdr {\n  u32 iVersion;                   /* Wal-index version */\n  u32 unused;                     /* Unused (padding) field */\n  u32 iChange;                    /* Counter incremented each transaction */\n  u8 isInit;                      /* 1 when initialized */\n  u8 bigEndCksum;                 /* True if checksums in WAL are big-endian */\n  u16 szPage;                     /* Database page size in bytes. 1==64K */\n  u32 mxFrame;                    /* Index of last valid frame in the WAL */\n  u32 nPage;                      /* Size of database in pages */\n  u32 aFrameCksum[2];             /* Checksum of last frame in log */\n  u32 aSalt[2];                   /* Two salt values copied from WAL header */\n  u32 aCksum[2];                  /* Checksum over all prior fields */\n};\n\n/*\n** A copy of the following object occurs in the wal-index immediately\n** following the second copy of the WalIndexHdr.  This object stores\n** information used by checkpoint.\n**\n** nBackfill is the number of frames in the WAL that have been written\n** back into the database. (We call the act of moving content from WAL to\n** database \"backfilling\".)  The nBackfill number is never greater than\n** WalIndexHdr.mxFrame.  nBackfill can only be increased by threads\n** holding the WAL_CKPT_LOCK lock (which includes a recovery thread).\n** However, a WAL_WRITE_LOCK thread can move the value of nBackfill from\n** mxFrame back to zero when the WAL is reset.\n**\n** There is one entry in aReadMark[] for each reader lock.  If a reader\n** holds read-lock K, then the value in aReadMark[K] is no greater than\n** the mxFrame for that reader.  The value READMARK_NOT_USED (0xffffffff)\n** for any aReadMark[] means that entry is unused.  aReadMark[0] is \n** a special case; its value is never used and it exists as a place-holder\n** to avoid having to offset aReadMark[] indexs by one.  Readers holding\n** WAL_READ_LOCK(0) always ignore the entire WAL and read all content\n** directly from the database.\n**\n** The value of aReadMark[K] may only be changed by a thread that\n** is holding an exclusive lock on WAL_READ_LOCK(K).  Thus, the value of\n** aReadMark[K] cannot changed while there is a reader is using that mark\n** since the reader will be holding a shared lock on WAL_READ_LOCK(K).\n**\n** The checkpointer may only transfer frames from WAL to database where\n** the frame numbers are less than or equal to every aReadMark[] that is\n** in use (that is, every aReadMark[j] for which there is a corresponding\n** WAL_READ_LOCK(j)).  New readers (usually) pick the aReadMark[] with the\n** largest value and will increase an unused aReadMark[] to mxFrame if there\n** is not already an aReadMark[] equal to mxFrame.  The exception to the\n** previous sentence is when nBackfill equals mxFrame (meaning that everything\n** in the WAL has been backfilled into the database) then new readers\n** will choose aReadMark[0] which has value 0 and hence such reader will\n** get all their all content directly from the database file and ignore \n** the WAL.\n**\n** Writers normally append new frames to the end of the WAL.  However,\n** if nBackfill equals mxFrame (meaning that all WAL content has been\n** written back into the database) and if no readers are using the WAL\n** (in other words, if there are no WAL_READ_LOCK(i) where i>0) then\n** the writer will first \"reset\" the WAL back to the beginning and start\n** writing new content beginning at frame 1.\n**\n** We assume that 32-bit loads are atomic and so no locks are needed in\n** order to read from any aReadMark[] entries.\n*/\nstruct WalCkptInfo {\n  u32 nBackfill;                  /* Number of WAL frames backfilled into DB */\n  u32 aReadMark[WAL_NREADER];     /* Reader marks */\n};\n#define READMARK_NOT_USED  0xffffffff\n\n\n/* A block of WALINDEX_LOCK_RESERVED bytes beginning at\n** WALINDEX_LOCK_OFFSET is reserved for locks. Since some systems\n** only support mandatory file-locks, we do not read or write data\n** from the region of the file on which locks are applied.\n*/\n#define WALINDEX_LOCK_OFFSET   (sizeof(WalIndexHdr)*2 + sizeof(WalCkptInfo))\n#define WALINDEX_LOCK_RESERVED 16\n#define WALINDEX_HDR_SIZE      (WALINDEX_LOCK_OFFSET+WALINDEX_LOCK_RESERVED)\n\n/* Size of header before each frame in wal */\n#define WAL_FRAME_HDRSIZE 24\n\n/* Size of write ahead log header, including checksum. */\n/* #define WAL_HDRSIZE 24 */\n#define WAL_HDRSIZE 32\n\n/* WAL magic value. Either this value, or the same value with the least\n** significant bit also set (WAL_MAGIC | 0x00000001) is stored in 32-bit\n** big-endian format in the first 4 bytes of a WAL file.\n**\n** If the LSB is set, then the checksums for each frame within the WAL\n** file are calculated by treating all data as an array of 32-bit \n** big-endian words. Otherwise, they are calculated by interpreting \n** all data as 32-bit little-endian words.\n*/\n#define WAL_MAGIC 0x377f0682\n\n/*\n** Return the offset of frame iFrame in the write-ahead log file, \n** assuming a database page size of szPage bytes. The offset returned\n** is to the start of the write-ahead log frame-header.\n*/\n#define walFrameOffset(iFrame, szPage) (                               \\\n  WAL_HDRSIZE + ((iFrame)-1)*(i64)((szPage)+WAL_FRAME_HDRSIZE)         \\\n)\n\n/*\n** An open write-ahead log file is represented by an instance of the\n** following object.\n*/\nstruct Wal {\n  sqlite3_vfs *pVfs;         /* The VFS used to create pDbFd */\n  sqlite3_file *pDbFd;       /* File handle for the database file */\n  sqlite3_file *pWalFd;      /* File handle for WAL file */\n  u32 iCallback;             /* Value to pass to log callback (or 0) */\n  int nWiData;               /* Size of array apWiData */\n  volatile u32 **apWiData;   /* Pointer to wal-index content in memory */\n  u32 szPage;                /* Database page size */\n  i16 readLock;              /* Which read lock is being held.  -1 for none */\n  u8 exclusiveMode;          /* Non-zero if connection is in exclusive mode */\n  u8 writeLock;              /* True if in a write transaction */\n  u8 ckptLock;               /* True if holding a checkpoint lock */\n  u8 readOnly;               /* True if the WAL file is open read-only */\n  WalIndexHdr hdr;           /* Wal-index header for current transaction */\n  const char *zWalName;      /* Name of WAL file */\n  u32 nCkpt;                 /* Checkpoint sequence counter in the wal-header */\n#ifdef SQLITE_DEBUG\n  u8 lockError;              /* True if a locking error has occurred */\n#endif\n};\n\n/*\n** Candidate values for Wal.exclusiveMode.\n*/\n#define WAL_NORMAL_MODE     0\n#define WAL_EXCLUSIVE_MODE  1     \n#define WAL_HEAPMEMORY_MODE 2\n\n/*\n** Each page of the wal-index mapping contains a hash-table made up of\n** an array of HASHTABLE_NSLOT elements of the following type.\n*/\ntypedef u16 ht_slot;\n\n/*\n** This structure is used to implement an iterator that loops through\n** all frames in the WAL in database page order. Where two or more frames\n** correspond to the same database page, the iterator visits only the \n** frame most recently written to the WAL (in other words, the frame with\n** the largest index).\n**\n** The internals of this structure are only accessed by:\n**\n**   walIteratorInit() - Create a new iterator,\n**   walIteratorNext() - Step an iterator,\n**   walIteratorFree() - Free an iterator.\n**\n** This functionality is used by the checkpoint code (see walCheckpoint()).\n*/\nstruct WalIterator {\n  int iPrior;                     /* Last result returned from the iterator */\n  int nSegment;                   /* Number of entries in aSegment[] */\n  struct WalSegment {\n    int iNext;                    /* Next slot in aIndex[] not yet returned */\n    ht_slot *aIndex;              /* i0, i1, i2... such that aPgno[iN] ascend */\n    u32 *aPgno;                   /* Array of page numbers. */\n    int nEntry;                   /* Nr. of entries in aPgno[] and aIndex[] */\n    int iZero;                    /* Frame number associated with aPgno[0] */\n  } aSegment[1];                  /* One for every 32KB page in the wal-index */\n};\n\n/*\n** Define the parameters of the hash tables in the wal-index file. There\n** is a hash-table following every HASHTABLE_NPAGE page numbers in the\n** wal-index.\n**\n** Changing any of these constants will alter the wal-index format and\n** create incompatibilities.\n*/\n#define HASHTABLE_NPAGE      4096                 /* Must be power of 2 */\n#define HASHTABLE_HASH_1     383                  /* Should be prime */\n#define HASHTABLE_NSLOT      (HASHTABLE_NPAGE*2)  /* Must be a power of 2 */\n\n/* \n** The block of page numbers associated with the first hash-table in a\n** wal-index is smaller than usual. This is so that there is a complete\n** hash-table on each aligned 32KB page of the wal-index.\n*/\n#define HASHTABLE_NPAGE_ONE  (HASHTABLE_NPAGE - (WALINDEX_HDR_SIZE/sizeof(u32)))\n\n/* The wal-index is divided into pages of WALINDEX_PGSZ bytes each. */\n#define WALINDEX_PGSZ   (                                         \\\n    sizeof(ht_slot)*HASHTABLE_NSLOT + HASHTABLE_NPAGE*sizeof(u32) \\\n)\n\n/*\n** Obtain a pointer to the iPage'th page of the wal-index. The wal-index\n** is broken into pages of WALINDEX_PGSZ bytes. Wal-index pages are\n** numbered from zero.\n**\n** If this call is successful, *ppPage is set to point to the wal-index\n** page and SQLITE_OK is returned. If an error (an OOM or VFS error) occurs,\n** then an SQLite error code is returned and *ppPage is set to 0.\n*/\nstatic int walIndexPage(Wal *pWal, int iPage, volatile u32 **ppPage){\n  int rc = SQLITE_OK;\n\n  /* Enlarge the pWal->apWiData[] array if required */\n  if( pWal->nWiData<=iPage ){\n    int nByte = sizeof(u32*)*(iPage+1);\n    volatile u32 **apNew;\n    apNew = (volatile u32 **)sqlite3_realloc((void *)pWal->apWiData, nByte);\n    if( !apNew ){\n      *ppPage = 0;\n      return SQLITE_NOMEM;\n    }\n    memset((void*)&apNew[pWal->nWiData], 0,\n           sizeof(u32*)*(iPage+1-pWal->nWiData));\n    pWal->apWiData = apNew;\n    pWal->nWiData = iPage+1;\n  }\n\n  /* Request a pointer to the required page from the VFS */\n  if( pWal->apWiData[iPage]==0 ){\n    if( pWal->exclusiveMode==WAL_HEAPMEMORY_MODE ){\n      pWal->apWiData[iPage] = (u32 volatile *)sqlite3MallocZero(WALINDEX_PGSZ);\n      if( !pWal->apWiData[iPage] ) rc = SQLITE_NOMEM;\n    }else{\n      rc = sqlite3OsShmMap(pWal->pDbFd, iPage, WALINDEX_PGSZ, \n          pWal->writeLock, (void volatile **)&pWal->apWiData[iPage]\n      );\n    }\n  }\n\n  *ppPage = pWal->apWiData[iPage];\n  assert( iPage==0 || *ppPage || rc!=SQLITE_OK );\n  return rc;\n}\n\n/*\n** Return a pointer to the WalCkptInfo structure in the wal-index.\n*/\nstatic volatile WalCkptInfo *walCkptInfo(Wal *pWal){\n  assert( pWal->nWiData>0 && pWal->apWiData[0] );\n  return (volatile WalCkptInfo*)&(pWal->apWiData[0][sizeof(WalIndexHdr)/2]);\n}\n\n/*\n** Return a pointer to the WalIndexHdr structure in the wal-index.\n*/\nstatic volatile WalIndexHdr *walIndexHdr(Wal *pWal){\n  assert( pWal->nWiData>0 && pWal->apWiData[0] );\n  return (volatile WalIndexHdr*)pWal->apWiData[0];\n}\n\n/*\n** The argument to this macro must be of type u32. On a little-endian\n** architecture, it returns the u32 value that results from interpreting\n** the 4 bytes as a big-endian value. On a big-endian architecture, it\n** returns the value that would be produced by intepreting the 4 bytes\n** of the input value as a little-endian integer.\n*/\n#define BYTESWAP32(x) ( \\\n    (((x)&0x000000FF)<<24) + (((x)&0x0000FF00)<<8)  \\\n  + (((x)&0x00FF0000)>>8)  + (((x)&0xFF000000)>>24) \\\n)\n\n/*\n** Generate or extend an 8 byte checksum based on the data in \n** array aByte[] and the initial values of aIn[0] and aIn[1] (or\n** initial values of 0 and 0 if aIn==NULL).\n**\n** The checksum is written back into aOut[] before returning.\n**\n** nByte must be a positive multiple of 8.\n*/\nstatic void walChecksumBytes(\n  int nativeCksum, /* True for native byte-order, false for non-native */\n  u8 *a,           /* Content to be checksummed */\n  int nByte,       /* Bytes of content in a[].  Must be a multiple of 8. */\n  const u32 *aIn,  /* Initial checksum value input */\n  u32 *aOut        /* OUT: Final checksum value output */\n){\n  u32 s1, s2;\n  u32 *aData = (u32 *)a;\n  u32 *aEnd = (u32 *)&a[nByte];\n\n  if( aIn ){\n    s1 = aIn[0];\n    s2 = aIn[1];\n  }else{\n    s1 = s2 = 0;\n  }\n\n  assert( nByte>=8 );\n  assert( (nByte&0x00000007)==0 );\n\n  if( nativeCksum ){\n    do {\n      s1 += *aData++ + s2;\n      s2 += *aData++ + s1;\n    }while( aData<aEnd );\n  }else{\n    do {\n      s1 += BYTESWAP32(aData[0]) + s2;\n      s2 += BYTESWAP32(aData[1]) + s1;\n      aData += 2;\n    }while( aData<aEnd );\n  }\n\n  aOut[0] = s1;\n  aOut[1] = s2;\n}\n\nstatic void walShmBarrier(Wal *pWal){\n  if( pWal->exclusiveMode!=WAL_HEAPMEMORY_MODE ){\n    sqlite3OsShmBarrier(pWal->pDbFd);\n  }\n}\n\n/*\n** Write the header information in pWal->hdr into the wal-index.\n**\n** The checksum on pWal->hdr is updated before it is written.\n*/\nstatic void walIndexWriteHdr(Wal *pWal){\n  volatile WalIndexHdr *aHdr = walIndexHdr(pWal);\n  const int nCksum = offsetof(WalIndexHdr, aCksum);\n\n  assert( pWal->writeLock );\n  pWal->hdr.isInit = 1;\n  pWal->hdr.iVersion = WALINDEX_MAX_VERSION;\n  walChecksumBytes(1, (u8*)&pWal->hdr, nCksum, 0, pWal->hdr.aCksum);\n  memcpy((void *)&aHdr[1], (void *)&pWal->hdr, sizeof(WalIndexHdr));\n  walShmBarrier(pWal);\n  memcpy((void *)&aHdr[0], (void *)&pWal->hdr, sizeof(WalIndexHdr));\n}\n\n/*\n** This function encodes a single frame header and writes it to a buffer\n** supplied by the caller. A frame-header is made up of a series of \n** 4-byte big-endian integers, as follows:\n**\n**     0: Page number.\n**     4: For commit records, the size of the database image in pages \n**        after the commit. For all other records, zero.\n**     8: Salt-1 (copied from the wal-header)\n**    12: Salt-2 (copied from the wal-header)\n**    16: Checksum-1.\n**    20: Checksum-2.\n*/\nstatic void walEncodeFrame(\n  Wal *pWal,                      /* The write-ahead log */\n  u32 iPage,                      /* Database page number for frame */\n  u32 nTruncate,                  /* New db size (or 0 for non-commit frames) */\n  u8 *aData,                      /* Pointer to page data */\n  u8 *aFrame                      /* OUT: Write encoded frame here */\n){\n  int nativeCksum;                /* True for native byte-order checksums */\n  u32 *aCksum = pWal->hdr.aFrameCksum;\n  assert( WAL_FRAME_HDRSIZE==24 );\n  sqlite3Put4byte(&aFrame[0], iPage);\n  sqlite3Put4byte(&aFrame[4], nTruncate);\n  memcpy(&aFrame[8], pWal->hdr.aSalt, 8);\n\n  nativeCksum = (pWal->hdr.bigEndCksum==SQLITE_BIGENDIAN);\n  walChecksumBytes(nativeCksum, aFrame, 8, aCksum, aCksum);\n  walChecksumBytes(nativeCksum, aData, pWal->szPage, aCksum, aCksum);\n\n  sqlite3Put4byte(&aFrame[16], aCksum[0]);\n  sqlite3Put4byte(&aFrame[20], aCksum[1]);\n}\n\n/*\n** Check to see if the frame with header in aFrame[] and content\n** in aData[] is valid.  If it is a valid frame, fill *piPage and\n** *pnTruncate and return true.  Return if the frame is not valid.\n*/\nstatic int walDecodeFrame(\n  Wal *pWal,                      /* The write-ahead log */\n  u32 *piPage,                    /* OUT: Database page number for frame */\n  u32 *pnTruncate,                /* OUT: New db size (or 0 if not commit) */\n  u8 *aData,                      /* Pointer to page data (for checksum) */\n  u8 *aFrame                      /* Frame data */\n){\n  int nativeCksum;                /* True for native byte-order checksums */\n  u32 *aCksum = pWal->hdr.aFrameCksum;\n  u32 pgno;                       /* Page number of the frame */\n  assert( WAL_FRAME_HDRSIZE==24 );\n\n  /* A frame is only valid if the salt values in the frame-header\n  ** match the salt values in the wal-header. \n  */\n  if( memcmp(&pWal->hdr.aSalt, &aFrame[8], 8)!=0 ){\n    return 0;\n  }\n\n  /* A frame is only valid if the page number is creater than zero.\n  */\n  pgno = sqlite3Get4byte(&aFrame[0]);\n  if( pgno==0 ){\n    return 0;\n  }\n\n  /* A frame is only valid if a checksum of the WAL header,\n  ** all prior frams, the first 16 bytes of this frame-header, \n  ** and the frame-data matches the checksum in the last 8 \n  ** bytes of this frame-header.\n  */\n  nativeCksum = (pWal->hdr.bigEndCksum==SQLITE_BIGENDIAN);\n  walChecksumBytes(nativeCksum, aFrame, 8, aCksum, aCksum);\n  walChecksumBytes(nativeCksum, aData, pWal->szPage, aCksum, aCksum);\n  if( aCksum[0]!=sqlite3Get4byte(&aFrame[16]) \n   || aCksum[1]!=sqlite3Get4byte(&aFrame[20]) \n  ){\n    /* Checksum failed. */\n    return 0;\n  }\n\n  /* If we reach this point, the frame is valid.  Return the page number\n  ** and the new database size.\n  */\n  *piPage = pgno;\n  *pnTruncate = sqlite3Get4byte(&aFrame[4]);\n  return 1;\n}\n\n\n#if defined(SQLITE_TEST) && defined(SQLITE_DEBUG)\n/*\n** Names of locks.  This routine is used to provide debugging output and is not\n** a part of an ordinary build.\n*/\nstatic const char *walLockName(int lockIdx){\n  if( lockIdx==WAL_WRITE_LOCK ){\n    return \"WRITE-LOCK\";\n  }else if( lockIdx==WAL_CKPT_LOCK ){\n    return \"CKPT-LOCK\";\n  }else if( lockIdx==WAL_RECOVER_LOCK ){\n    return \"RECOVER-LOCK\";\n  }else{\n    static char zName[15];\n    sqlite3_snprintf(sizeof(zName), zName, \"READ-LOCK[%d]\",\n                     lockIdx-WAL_READ_LOCK(0));\n    return zName;\n  }\n}\n#endif /*defined(SQLITE_TEST) || defined(SQLITE_DEBUG) */\n    \n\n/*\n** Set or release locks on the WAL.  Locks are either shared or exclusive.\n** A lock cannot be moved directly between shared and exclusive - it must go\n** through the unlocked state first.\n**\n** In locking_mode=EXCLUSIVE, all of these routines become no-ops.\n*/\nstatic int walLockShared(Wal *pWal, int lockIdx){\n  int rc;\n  if( pWal->exclusiveMode ) return SQLITE_OK;\n  rc = sqlite3OsShmLock(pWal->pDbFd, lockIdx, 1,\n                        SQLITE_SHM_LOCK | SQLITE_SHM_SHARED);\n  WALTRACE((\"WAL%p: acquire SHARED-%s %s\\n\", pWal,\n            walLockName(lockIdx), rc ? \"failed\" : \"ok\"));\n  VVA_ONLY( pWal->lockError = (u8)(rc!=SQLITE_OK && rc!=SQLITE_BUSY); )\n  return rc;\n}\nstatic void walUnlockShared(Wal *pWal, int lockIdx){\n  if( pWal->exclusiveMode ) return;\n  (void)sqlite3OsShmLock(pWal->pDbFd, lockIdx, 1,\n                         SQLITE_SHM_UNLOCK | SQLITE_SHM_SHARED);\n  WALTRACE((\"WAL%p: release SHARED-%s\\n\", pWal, walLockName(lockIdx)));\n}\nstatic int walLockExclusive(Wal *pWal, int lockIdx, int n){\n  int rc;\n  if( pWal->exclusiveMode ) return SQLITE_OK;\n  rc = sqlite3OsShmLock(pWal->pDbFd, lockIdx, n,\n                        SQLITE_SHM_LOCK | SQLITE_SHM_EXCLUSIVE);\n  WALTRACE((\"WAL%p: acquire EXCLUSIVE-%s cnt=%d %s\\n\", pWal,\n            walLockName(lockIdx), n, rc ? \"failed\" : \"ok\"));\n  VVA_ONLY( pWal->lockError = (u8)(rc!=SQLITE_OK && rc!=SQLITE_BUSY); )\n  return rc;\n}\nstatic void walUnlockExclusive(Wal *pWal, int lockIdx, int n){\n  if( pWal->exclusiveMode ) return;\n  (void)sqlite3OsShmLock(pWal->pDbFd, lockIdx, n,\n                         SQLITE_SHM_UNLOCK | SQLITE_SHM_EXCLUSIVE);\n  WALTRACE((\"WAL%p: release EXCLUSIVE-%s cnt=%d\\n\", pWal,\n             walLockName(lockIdx), n));\n}\n\n/*\n** Compute a hash on a page number.  The resulting hash value must land\n** between 0 and (HASHTABLE_NSLOT-1).  The walHashNext() function advances\n** the hash to the next value in the event of a collision.\n*/\nstatic int walHash(u32 iPage){\n  assert( iPage>0 );\n  assert( (HASHTABLE_NSLOT & (HASHTABLE_NSLOT-1))==0 );\n  return (iPage*HASHTABLE_HASH_1) & (HASHTABLE_NSLOT-1);\n}\nstatic int walNextHash(int iPriorHash){\n  return (iPriorHash+1)&(HASHTABLE_NSLOT-1);\n}\n\n/* \n** Return pointers to the hash table and page number array stored on\n** page iHash of the wal-index. The wal-index is broken into 32KB pages\n** numbered starting from 0.\n**\n** Set output variable *paHash to point to the start of the hash table\n** in the wal-index file. Set *piZero to one less than the frame \n** number of the first frame indexed by this hash table. If a\n** slot in the hash table is set to N, it refers to frame number \n** (*piZero+N) in the log.\n**\n** Finally, set *paPgno so that *paPgno[1] is the page number of the\n** first frame indexed by the hash table, frame (*piZero+1).\n*/\nstatic int walHashGet(\n  Wal *pWal,                      /* WAL handle */\n  int iHash,                      /* Find the iHash'th table */\n  volatile ht_slot **paHash,      /* OUT: Pointer to hash index */\n  volatile u32 **paPgno,          /* OUT: Pointer to page number array */\n  u32 *piZero                     /* OUT: Frame associated with *paPgno[0] */\n){\n  int rc;                         /* Return code */\n  volatile u32 *aPgno;\n\n  rc = walIndexPage(pWal, iHash, &aPgno);\n  assert( rc==SQLITE_OK || iHash>0 );\n\n  if( rc==SQLITE_OK ){\n    u32 iZero;\n    volatile ht_slot *aHash;\n\n    aHash = (volatile ht_slot *)&aPgno[HASHTABLE_NPAGE];\n    if( iHash==0 ){\n      aPgno = &aPgno[WALINDEX_HDR_SIZE/sizeof(u32)];\n      iZero = 0;\n    }else{\n      iZero = HASHTABLE_NPAGE_ONE + (iHash-1)*HASHTABLE_NPAGE;\n    }\n  \n    *paPgno = &aPgno[-1];\n    *paHash = aHash;\n    *piZero = iZero;\n  }\n  return rc;\n}\n\n/*\n** Return the number of the wal-index page that contains the hash-table\n** and page-number array that contain entries corresponding to WAL frame\n** iFrame. The wal-index is broken up into 32KB pages. Wal-index pages \n** are numbered starting from 0.\n*/\nstatic int walFramePage(u32 iFrame){\n  int iHash = (iFrame+HASHTABLE_NPAGE-HASHTABLE_NPAGE_ONE-1) / HASHTABLE_NPAGE;\n  assert( (iHash==0 || iFrame>HASHTABLE_NPAGE_ONE)\n       && (iHash>=1 || iFrame<=HASHTABLE_NPAGE_ONE)\n       && (iHash<=1 || iFrame>(HASHTABLE_NPAGE_ONE+HASHTABLE_NPAGE))\n       && (iHash>=2 || iFrame<=HASHTABLE_NPAGE_ONE+HASHTABLE_NPAGE)\n       && (iHash<=2 || iFrame>(HASHTABLE_NPAGE_ONE+2*HASHTABLE_NPAGE))\n  );\n  return iHash;\n}\n\n/*\n** Return the page number associated with frame iFrame in this WAL.\n*/\nstatic u32 walFramePgno(Wal *pWal, u32 iFrame){\n  int iHash = walFramePage(iFrame);\n  if( iHash==0 ){\n    return pWal->apWiData[0][WALINDEX_HDR_SIZE/sizeof(u32) + iFrame - 1];\n  }\n  return pWal->apWiData[iHash][(iFrame-1-HASHTABLE_NPAGE_ONE)%HASHTABLE_NPAGE];\n}\n\n/*\n** Remove entries from the hash table that point to WAL slots greater\n** than pWal->hdr.mxFrame.\n**\n** This function is called whenever pWal->hdr.mxFrame is decreased due\n** to a rollback or savepoint.\n**\n** At most only the hash table containing pWal->hdr.mxFrame needs to be\n** updated.  Any later hash tables will be automatically cleared when\n** pWal->hdr.mxFrame advances to the point where those hash tables are\n** actually needed.\n*/\nstatic void walCleanupHash(Wal *pWal){\n  volatile ht_slot *aHash = 0;    /* Pointer to hash table to clear */\n  volatile u32 *aPgno = 0;        /* Page number array for hash table */\n  u32 iZero = 0;                  /* frame == (aHash[x]+iZero) */\n  int iLimit = 0;                 /* Zero values greater than this */\n  int nByte;                      /* Number of bytes to zero in aPgno[] */\n  int i;                          /* Used to iterate through aHash[] */\n\n  assert( pWal->writeLock );\n  testcase( pWal->hdr.mxFrame==HASHTABLE_NPAGE_ONE-1 );\n  testcase( pWal->hdr.mxFrame==HASHTABLE_NPAGE_ONE );\n  testcase( pWal->hdr.mxFrame==HASHTABLE_NPAGE_ONE+1 );\n\n  if( pWal->hdr.mxFrame==0 ) return;\n\n  /* Obtain pointers to the hash-table and page-number array containing \n  ** the entry that corresponds to frame pWal->hdr.mxFrame. It is guaranteed\n  ** that the page said hash-table and array reside on is already mapped.\n  */\n  assert( pWal->nWiData>walFramePage(pWal->hdr.mxFrame) );\n  assert( pWal->apWiData[walFramePage(pWal->hdr.mxFrame)] );\n  walHashGet(pWal, walFramePage(pWal->hdr.mxFrame), &aHash, &aPgno, &iZero);\n\n  /* Zero all hash-table entries that correspond to frame numbers greater\n  ** than pWal->hdr.mxFrame.\n  */\n  iLimit = pWal->hdr.mxFrame - iZero;\n  assert( iLimit>0 );\n  for(i=0; i<HASHTABLE_NSLOT; i++){\n    if( aHash[i]>iLimit ){\n      aHash[i] = 0;\n    }\n  }\n  \n  /* Zero the entries in the aPgno array that correspond to frames with\n  ** frame numbers greater than pWal->hdr.mxFrame. \n  */\n  nByte = (int)((char *)aHash - (char *)&aPgno[iLimit+1]);\n  memset((void *)&aPgno[iLimit+1], 0, nByte);\n\n#ifdef SQLITE_ENABLE_EXPENSIVE_ASSERT\n  /* Verify that the every entry in the mapping region is still reachable\n  ** via the hash table even after the cleanup.\n  */\n  if( iLimit ){\n    int i;           /* Loop counter */\n    int iKey;        /* Hash key */\n    for(i=1; i<=iLimit; i++){\n      for(iKey=walHash(aPgno[i]); aHash[iKey]; iKey=walNextHash(iKey)){\n        if( aHash[iKey]==i ) break;\n      }\n      assert( aHash[iKey]==i );\n    }\n  }\n#endif /* SQLITE_ENABLE_EXPENSIVE_ASSERT */\n}\n\n\n/*\n** Set an entry in the wal-index that will map database page number\n** pPage into WAL frame iFrame.\n*/\nstatic int walIndexAppend(Wal *pWal, u32 iFrame, u32 iPage){\n  int rc;                         /* Return code */\n  u32 iZero = 0;                  /* One less than frame number of aPgno[1] */\n  volatile u32 *aPgno = 0;        /* Page number array */\n  volatile ht_slot *aHash = 0;    /* Hash table */\n\n  rc = walHashGet(pWal, walFramePage(iFrame), &aHash, &aPgno, &iZero);\n\n  /* Assuming the wal-index file was successfully mapped, populate the\n  ** page number array and hash table entry.\n  */\n  if( rc==SQLITE_OK ){\n    int iKey;                     /* Hash table key */\n    int idx;                      /* Value to write to hash-table slot */\n    int nCollide;                 /* Number of hash collisions */\n\n    idx = iFrame - iZero;\n    assert( idx <= HASHTABLE_NSLOT/2 + 1 );\n    \n    /* If this is the first entry to be added to this hash-table, zero the\n    ** entire hash table and aPgno[] array before proceding. \n    */\n    if( idx==1 ){\n      int nByte = (int)((u8 *)&aHash[HASHTABLE_NSLOT] - (u8 *)&aPgno[1]);\n      memset((void*)&aPgno[1], 0, nByte);\n    }\n\n    /* If the entry in aPgno[] is already set, then the previous writer\n    ** must have exited unexpectedly in the middle of a transaction (after\n    ** writing one or more dirty pages to the WAL to free up memory). \n    ** Remove the remnants of that writers uncommitted transaction from \n    ** the hash-table before writing any new entries.\n    */\n    if( aPgno[idx] ){\n      walCleanupHash(pWal);\n      assert( !aPgno[idx] );\n    }\n\n    /* Write the aPgno[] array entry and the hash-table slot. */\n    nCollide = idx;\n    for(iKey=walHash(iPage); aHash[iKey]; iKey=walNextHash(iKey)){\n      if( (nCollide--)==0 ) return SQLITE_CORRUPT_BKPT;\n    }\n    aPgno[idx] = iPage;\n    aHash[iKey] = (ht_slot)idx;\n\n#ifdef SQLITE_ENABLE_EXPENSIVE_ASSERT\n    /* Verify that the number of entries in the hash table exactly equals\n    ** the number of entries in the mapping region.\n    */\n    {\n      int i;           /* Loop counter */\n      int nEntry = 0;  /* Number of entries in the hash table */\n      for(i=0; i<HASHTABLE_NSLOT; i++){ if( aHash[i] ) nEntry++; }\n      assert( nEntry==idx );\n    }\n\n    /* Verify that the every entry in the mapping region is reachable\n    ** via the hash table.  This turns out to be a really, really expensive\n    ** thing to check, so only do this occasionally - not on every\n    ** iteration.\n    */\n    if( (idx&0x3ff)==0 ){\n      int i;           /* Loop counter */\n      for(i=1; i<=idx; i++){\n        for(iKey=walHash(aPgno[i]); aHash[iKey]; iKey=walNextHash(iKey)){\n          if( aHash[iKey]==i ) break;\n        }\n        assert( aHash[iKey]==i );\n      }\n    }\n#endif /* SQLITE_ENABLE_EXPENSIVE_ASSERT */\n  }\n\n\n  return rc;\n}\n\n\n/*\n** Recover the wal-index by reading the write-ahead log file. \n**\n** This routine first tries to establish an exclusive lock on the\n** wal-index to prevent other threads/processes from doing anything\n** with the WAL or wal-index while recovery is running.  The\n** WAL_RECOVER_LOCK is also held so that other threads will know\n** that this thread is running recovery.  If unable to establish\n** the necessary locks, this routine returns SQLITE_BUSY.\n*/\nstatic int walIndexRecover(Wal *pWal){\n  int rc;                         /* Return Code */\n  i64 nSize;                      /* Size of log file */\n  u32 aFrameCksum[2] = {0, 0};\n  int iLock;                      /* Lock offset to lock for checkpoint */\n  int nLock;                      /* Number of locks to hold */\n\n  /* Obtain an exclusive lock on all byte in the locking range not already\n  ** locked by the caller. The caller is guaranteed to have locked the\n  ** WAL_WRITE_LOCK byte, and may have also locked the WAL_CKPT_LOCK byte.\n  ** If successful, the same bytes that are locked here are unlocked before\n  ** this function returns.\n  */\n  assert( pWal->ckptLock==1 || pWal->ckptLock==0 );\n  assert( WAL_ALL_BUT_WRITE==WAL_WRITE_LOCK+1 );\n  assert( WAL_CKPT_LOCK==WAL_ALL_BUT_WRITE );\n  assert( pWal->writeLock );\n  iLock = WAL_ALL_BUT_WRITE + pWal->ckptLock;\n  nLock = SQLITE_SHM_NLOCK - iLock;\n  rc = walLockExclusive(pWal, iLock, nLock);\n  if( rc ){\n    return rc;\n  }\n  WALTRACE((\"WAL%p: recovery begin...\\n\", pWal));\n\n  memset(&pWal->hdr, 0, sizeof(WalIndexHdr));\n\n  rc = sqlite3OsFileSize(pWal->pWalFd, &nSize);\n  if( rc!=SQLITE_OK ){\n    goto recovery_error;\n  }\n\n  if( nSize>WAL_HDRSIZE ){\n    u8 aBuf[WAL_HDRSIZE];         /* Buffer to load WAL header into */\n    u8 *aFrame = 0;               /* Malloc'd buffer to load entire frame */\n    int szFrame;                  /* Number of bytes in buffer aFrame[] */\n    u8 *aData;                    /* Pointer to data part of aFrame buffer */\n    int iFrame;                   /* Index of last frame read */\n    i64 iOffset;                  /* Next offset to read from log file */\n    int szPage;                   /* Page size according to the log */\n    u32 magic;                    /* Magic value read from WAL header */\n    u32 version;                  /* Magic value read from WAL header */\n\n    /* Read in the WAL header. */\n    rc = sqlite3OsRead(pWal->pWalFd, aBuf, WAL_HDRSIZE, 0);\n    if( rc!=SQLITE_OK ){\n      goto recovery_error;\n    }\n\n    /* If the database page size is not a power of two, or is greater than\n    ** SQLITE_MAX_PAGE_SIZE, conclude that the WAL file contains no valid \n    ** data. Similarly, if the 'magic' value is invalid, ignore the whole\n    ** WAL file.\n    */\n    magic = sqlite3Get4byte(&aBuf[0]);\n    szPage = sqlite3Get4byte(&aBuf[8]);\n    if( (magic&0xFFFFFFFE)!=WAL_MAGIC \n     || szPage&(szPage-1) \n     || szPage>SQLITE_MAX_PAGE_SIZE \n     || szPage<512 \n    ){\n      goto finished;\n    }\n    pWal->hdr.bigEndCksum = (u8)(magic&0x00000001);\n    pWal->szPage = szPage;\n    pWal->nCkpt = sqlite3Get4byte(&aBuf[12]);\n    memcpy(&pWal->hdr.aSalt, &aBuf[16], 8);\n\n    /* Verify that the WAL header checksum is correct */\n    walChecksumBytes(pWal->hdr.bigEndCksum==SQLITE_BIGENDIAN, \n        aBuf, WAL_HDRSIZE-2*4, 0, pWal->hdr.aFrameCksum\n    );\n    if( pWal->hdr.aFrameCksum[0]!=sqlite3Get4byte(&aBuf[24])\n     || pWal->hdr.aFrameCksum[1]!=sqlite3Get4byte(&aBuf[28])\n    ){\n      goto finished;\n    }\n\n    /* Verify that the version number on the WAL format is one that\n    ** are able to understand */\n    version = sqlite3Get4byte(&aBuf[4]);\n    if( version!=WAL_MAX_VERSION ){\n      rc = SQLITE_CANTOPEN_BKPT;\n      goto finished;\n    }\n\n    /* Malloc a buffer to read frames into. */\n    szFrame = szPage + WAL_FRAME_HDRSIZE;\n    aFrame = (u8 *)sqlite3_malloc(szFrame);\n    if( !aFrame ){\n      rc = SQLITE_NOMEM;\n      goto recovery_error;\n    }\n    aData = &aFrame[WAL_FRAME_HDRSIZE];\n\n    /* Read all frames from the log file. */\n    iFrame = 0;\n    for(iOffset=WAL_HDRSIZE; (iOffset+szFrame)<=nSize; iOffset+=szFrame){\n      u32 pgno;                   /* Database page number for frame */\n      u32 nTruncate;              /* dbsize field from frame header */\n      int isValid;                /* True if this frame is valid */\n\n      /* Read and decode the next log frame. */\n      rc = sqlite3OsRead(pWal->pWalFd, aFrame, szFrame, iOffset);\n      if( rc!=SQLITE_OK ) break;\n      isValid = walDecodeFrame(pWal, &pgno, &nTruncate, aData, aFrame);\n      if( !isValid ) break;\n      rc = walIndexAppend(pWal, ++iFrame, pgno);\n      if( rc!=SQLITE_OK ) break;\n\n      /* If nTruncate is non-zero, this is a commit record. */\n      if( nTruncate ){\n        pWal->hdr.mxFrame = iFrame;\n        pWal->hdr.nPage = nTruncate;\n        pWal->hdr.szPage = (u16)((szPage&0xff00) | (szPage>>16));\n        testcase( szPage<=32768 );\n        testcase( szPage>=65536 );\n        aFrameCksum[0] = pWal->hdr.aFrameCksum[0];\n        aFrameCksum[1] = pWal->hdr.aFrameCksum[1];\n      }\n    }\n\n    sqlite3_free(aFrame);\n  }\n\nfinished:\n  if( rc==SQLITE_OK ){\n    volatile WalCkptInfo *pInfo;\n    int i;\n    pWal->hdr.aFrameCksum[0] = aFrameCksum[0];\n    pWal->hdr.aFrameCksum[1] = aFrameCksum[1];\n    walIndexWriteHdr(pWal);\n\n    /* Reset the checkpoint-header. This is safe because this thread is \n    ** currently holding locks that exclude all other readers, writers and\n    ** checkpointers.\n    */\n    pInfo = walCkptInfo(pWal);\n    pInfo->nBackfill = 0;\n    pInfo->aReadMark[0] = 0;\n    for(i=1; i<WAL_NREADER; i++) pInfo->aReadMark[i] = READMARK_NOT_USED;\n\n    /* If more than one frame was recovered from the log file, report an\n    ** event via sqlite3_log(). This is to help with identifying performance\n    ** problems caused by applications routinely shutting down without\n    ** checkpointing the log file.\n    */\n    if( pWal->hdr.nPage ){\n      sqlite3_log(SQLITE_OK, \"Recovered %d frames from WAL file %s\",\n          pWal->hdr.nPage, pWal->zWalName\n      );\n    }\n  }\n\nrecovery_error:\n  WALTRACE((\"WAL%p: recovery %s\\n\", pWal, rc ? \"failed\" : \"ok\"));\n  walUnlockExclusive(pWal, iLock, nLock);\n  return rc;\n}\n\n/*\n** Close an open wal-index.\n*/\nstatic void walIndexClose(Wal *pWal, int isDelete){\n  if( pWal->exclusiveMode==WAL_HEAPMEMORY_MODE ){\n    int i;\n    for(i=0; i<pWal->nWiData; i++){\n      sqlite3_free((void *)pWal->apWiData[i]);\n      pWal->apWiData[i] = 0;\n    }\n  }else{\n    sqlite3OsShmUnmap(pWal->pDbFd, isDelete);\n  }\n}\n\n/* \n** Open a connection to the WAL file zWalName. The database file must \n** already be opened on connection pDbFd. The buffer that zWalName points\n** to must remain valid for the lifetime of the returned Wal* handle.\n**\n** A SHARED lock should be held on the database file when this function\n** is called. The purpose of this SHARED lock is to prevent any other\n** client from unlinking the WAL or wal-index file. If another process\n** were to do this just after this client opened one of these files, the\n** system would be badly broken.\n**\n** If the log file is successfully opened, SQLITE_OK is returned and \n** *ppWal is set to point to a new WAL handle. If an error occurs,\n** an SQLite error code is returned and *ppWal is left unmodified.\n*/\nSQLITE_PRIVATE int sqlite3WalOpen(\n  sqlite3_vfs *pVfs,              /* vfs module to open wal and wal-index */\n  sqlite3_file *pDbFd,            /* The open database file */\n  const char *zWalName,           /* Name of the WAL file */\n  int bNoShm,                     /* True to run in heap-memory mode */\n  Wal **ppWal                     /* OUT: Allocated Wal handle */\n){\n  int rc;                         /* Return Code */\n  Wal *pRet;                      /* Object to allocate and return */\n  int flags;                      /* Flags passed to OsOpen() */\n\n  assert( zWalName && zWalName[0] );\n  assert( pDbFd );\n\n  /* In the amalgamation, the os_unix.c and os_win.c source files come before\n  ** this source file.  Verify that the #defines of the locking byte offsets\n  ** in os_unix.c and os_win.c agree with the WALINDEX_LOCK_OFFSET value.\n  */\n#ifdef WIN_SHM_BASE\n  assert( WIN_SHM_BASE==WALINDEX_LOCK_OFFSET );\n#endif\n#ifdef UNIX_SHM_BASE\n  assert( UNIX_SHM_BASE==WALINDEX_LOCK_OFFSET );\n#endif\n\n\n  /* Allocate an instance of struct Wal to return. */\n  *ppWal = 0;\n  pRet = (Wal*)sqlite3MallocZero(sizeof(Wal) + pVfs->szOsFile);\n  if( !pRet ){\n    return SQLITE_NOMEM;\n  }\n\n  pRet->pVfs = pVfs;\n  pRet->pWalFd = (sqlite3_file *)&pRet[1];\n  pRet->pDbFd = pDbFd;\n  pRet->readLock = -1;\n  pRet->zWalName = zWalName;\n  pRet->exclusiveMode = (bNoShm ? WAL_HEAPMEMORY_MODE: WAL_NORMAL_MODE);\n\n  /* Open file handle on the write-ahead log file. */\n  flags = (SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE|SQLITE_OPEN_WAL);\n  rc = sqlite3OsOpen(pVfs, zWalName, pRet->pWalFd, flags, &flags);\n  if( rc==SQLITE_OK && flags&SQLITE_OPEN_READONLY ){\n    pRet->readOnly = 1;\n  }\n\n  if( rc!=SQLITE_OK ){\n    walIndexClose(pRet, 0);\n    sqlite3OsClose(pRet->pWalFd);\n    sqlite3_free(pRet);\n  }else{\n    *ppWal = pRet;\n    WALTRACE((\"WAL%d: opened\\n\", pRet));\n  }\n  return rc;\n}\n\n/*\n** Find the smallest page number out of all pages held in the WAL that\n** has not been returned by any prior invocation of this method on the\n** same WalIterator object.   Write into *piFrame the frame index where\n** that page was last written into the WAL.  Write into *piPage the page\n** number.\n**\n** Return 0 on success.  If there are no pages in the WAL with a page\n** number larger than *piPage, then return 1.\n*/\nstatic int walIteratorNext(\n  WalIterator *p,               /* Iterator */\n  u32 *piPage,                  /* OUT: The page number of the next page */\n  u32 *piFrame                  /* OUT: Wal frame index of next page */\n){\n  u32 iMin;                     /* Result pgno must be greater than iMin */\n  u32 iRet = 0xFFFFFFFF;        /* 0xffffffff is never a valid page number */\n  int i;                        /* For looping through segments */\n\n  iMin = p->iPrior;\n  assert( iMin<0xffffffff );\n  for(i=p->nSegment-1; i>=0; i--){\n    struct WalSegment *pSegment = &p->aSegment[i];\n    while( pSegment->iNext<pSegment->nEntry ){\n      u32 iPg = pSegment->aPgno[pSegment->aIndex[pSegment->iNext]];\n      if( iPg>iMin ){\n        if( iPg<iRet ){\n          iRet = iPg;\n          *piFrame = pSegment->iZero + pSegment->aIndex[pSegment->iNext];\n        }\n        break;\n      }\n      pSegment->iNext++;\n    }\n  }\n\n  *piPage = p->iPrior = iRet;\n  return (iRet==0xFFFFFFFF);\n}\n\n/*\n** This function merges two sorted lists into a single sorted list.\n**\n** aLeft[] and aRight[] are arrays of indices.  The sort key is\n** aContent[aLeft[]] and aContent[aRight[]].  Upon entry, the following\n** is guaranteed for all J<K:\n**\n**        aContent[aLeft[J]] < aContent[aLeft[K]]\n**        aContent[aRight[J]] < aContent[aRight[K]]\n**\n** This routine overwrites aRight[] with a new (probably longer) sequence\n** of indices such that the aRight[] contains every index that appears in\n** either aLeft[] or the old aRight[] and such that the second condition\n** above is still met.\n**\n** The aContent[aLeft[X]] values will be unique for all X.  And the\n** aContent[aRight[X]] values will be unique too.  But there might be\n** one or more combinations of X and Y such that\n**\n**      aLeft[X]!=aRight[Y]  &&  aContent[aLeft[X]] == aContent[aRight[Y]]\n**\n** When that happens, omit the aLeft[X] and use the aRight[Y] index.\n*/\nstatic void walMerge(\n  const u32 *aContent,            /* Pages in wal - keys for the sort */\n  ht_slot *aLeft,                 /* IN: Left hand input list */\n  int nLeft,                      /* IN: Elements in array *paLeft */\n  ht_slot **paRight,              /* IN/OUT: Right hand input list */\n  int *pnRight,                   /* IN/OUT: Elements in *paRight */\n  ht_slot *aTmp                   /* Temporary buffer */\n){\n  int iLeft = 0;                  /* Current index in aLeft */\n  int iRight = 0;                 /* Current index in aRight */\n  int iOut = 0;                   /* Current index in output buffer */\n  int nRight = *pnRight;\n  ht_slot *aRight = *paRight;\n\n  assert( nLeft>0 && nRight>0 );\n  while( iRight<nRight || iLeft<nLeft ){\n    ht_slot logpage;\n    Pgno dbpage;\n\n    if( (iLeft<nLeft) \n     && (iRight>=nRight || aContent[aLeft[iLeft]]<aContent[aRight[iRight]])\n    ){\n      logpage = aLeft[iLeft++];\n    }else{\n      logpage = aRight[iRight++];\n    }\n    dbpage = aContent[logpage];\n\n    aTmp[iOut++] = logpage;\n    if( iLeft<nLeft && aContent[aLeft[iLeft]]==dbpage ) iLeft++;\n\n    assert( iLeft>=nLeft || aContent[aLeft[iLeft]]>dbpage );\n    assert( iRight>=nRight || aContent[aRight[iRight]]>dbpage );\n  }\n\n  *paRight = aLeft;\n  *pnRight = iOut;\n  memcpy(aLeft, aTmp, sizeof(aTmp[0])*iOut);\n}\n\n/*\n** Sort the elements in list aList using aContent[] as the sort key.\n** Remove elements with duplicate keys, preferring to keep the\n** larger aList[] values.\n**\n** The aList[] entries are indices into aContent[].  The values in\n** aList[] are to be sorted so that for all J<K:\n**\n**      aContent[aList[J]] < aContent[aList[K]]\n**\n** For any X and Y such that\n**\n**      aContent[aList[X]] == aContent[aList[Y]]\n**\n** Keep the larger of the two values aList[X] and aList[Y] and discard\n** the smaller.\n*/\nstatic void walMergesort(\n  const u32 *aContent,            /* Pages in wal */\n  ht_slot *aBuffer,               /* Buffer of at least *pnList items to use */\n  ht_slot *aList,                 /* IN/OUT: List to sort */\n  int *pnList                     /* IN/OUT: Number of elements in aList[] */\n){\n  struct Sublist {\n    int nList;                    /* Number of elements in aList */\n    ht_slot *aList;               /* Pointer to sub-list content */\n  };\n\n  const int nList = *pnList;      /* Size of input list */\n  int nMerge = 0;                 /* Number of elements in list aMerge */\n  ht_slot *aMerge = 0;            /* List to be merged */\n  int iList;                      /* Index into input list */\n  int iSub = 0;                   /* Index into aSub array */\n  struct Sublist aSub[13];        /* Array of sub-lists */\n\n  memset(aSub, 0, sizeof(aSub));\n  assert( nList<=HASHTABLE_NPAGE && nList>0 );\n  assert( HASHTABLE_NPAGE==(1<<(ArraySize(aSub)-1)) );\n\n  for(iList=0; iList<nList; iList++){\n    nMerge = 1;\n    aMerge = &aList[iList];\n    for(iSub=0; iList & (1<<iSub); iSub++){\n      struct Sublist *p = &aSub[iSub];\n      assert( p->aList && p->nList<=(1<<iSub) );\n      assert( p->aList==&aList[iList&~((2<<iSub)-1)] );\n      walMerge(aContent, p->aList, p->nList, &aMerge, &nMerge, aBuffer);\n    }\n    aSub[iSub].aList = aMerge;\n    aSub[iSub].nList = nMerge;\n  }\n\n  for(iSub++; iSub<ArraySize(aSub); iSub++){\n    if( nList & (1<<iSub) ){\n      struct Sublist *p = &aSub[iSub];\n      assert( p->nList<=(1<<iSub) );\n      assert( p->aList==&aList[nList&~((2<<iSub)-1)] );\n      walMerge(aContent, p->aList, p->nList, &aMerge, &nMerge, aBuffer);\n    }\n  }\n  assert( aMerge==aList );\n  *pnList = nMerge;\n\n#ifdef SQLITE_DEBUG\n  {\n    int i;\n    for(i=1; i<*pnList; i++){\n      assert( aContent[aList[i]] > aContent[aList[i-1]] );\n    }\n  }\n#endif\n}\n\n/* \n** Free an iterator allocated by walIteratorInit().\n*/\nstatic void walIteratorFree(WalIterator *p){\n  sqlite3ScratchFree(p);\n}\n\n/*\n** Construct a WalInterator object that can be used to loop over all \n** pages in the WAL in ascending order. The caller must hold the checkpoint\n** lock.\n**\n** On success, make *pp point to the newly allocated WalInterator object\n** return SQLITE_OK. Otherwise, return an error code. If this routine\n** returns an error, the value of *pp is undefined.\n**\n** The calling routine should invoke walIteratorFree() to destroy the\n** WalIterator object when it has finished with it.\n*/\nstatic int walIteratorInit(Wal *pWal, WalIterator **pp){\n  WalIterator *p;                 /* Return value */\n  int nSegment;                   /* Number of segments to merge */\n  u32 iLast;                      /* Last frame in log */\n  int nByte;                      /* Number of bytes to allocate */\n  int i;                          /* Iterator variable */\n  ht_slot *aTmp;                  /* Temp space used by merge-sort */\n  int rc = SQLITE_OK;             /* Return Code */\n\n  /* This routine only runs while holding the checkpoint lock. And\n  ** it only runs if there is actually content in the log (mxFrame>0).\n  */\n  assert( pWal->ckptLock && pWal->hdr.mxFrame>0 );\n  iLast = pWal->hdr.mxFrame;\n\n  /* Allocate space for the WalIterator object. */\n  nSegment = walFramePage(iLast) + 1;\n  nByte = sizeof(WalIterator) \n        + (nSegment-1)*sizeof(struct WalSegment)\n        + iLast*sizeof(ht_slot);\n  p = (WalIterator *)sqlite3ScratchMalloc(nByte);\n  if( !p ){\n    return SQLITE_NOMEM;\n  }\n  memset(p, 0, nByte);\n  p->nSegment = nSegment;\n\n  /* Allocate temporary space used by the merge-sort routine. This block\n  ** of memory will be freed before this function returns.\n  */\n  aTmp = (ht_slot *)sqlite3ScratchMalloc(\n      sizeof(ht_slot) * (iLast>HASHTABLE_NPAGE?HASHTABLE_NPAGE:iLast)\n  );\n  if( !aTmp ){\n    rc = SQLITE_NOMEM;\n  }\n\n  for(i=0; rc==SQLITE_OK && i<nSegment; i++){\n    volatile ht_slot *aHash;\n    u32 iZero;\n    volatile u32 *aPgno;\n\n    rc = walHashGet(pWal, i, &aHash, &aPgno, &iZero);\n    if( rc==SQLITE_OK ){\n      int j;                      /* Counter variable */\n      int nEntry;                 /* Number of entries in this segment */\n      ht_slot *aIndex;            /* Sorted index for this segment */\n\n      aPgno++;\n      if( (i+1)==nSegment ){\n        nEntry = (int)(iLast - iZero);\n      }else{\n        nEntry = (int)((u32*)aHash - (u32*)aPgno);\n      }\n      aIndex = &((ht_slot *)&p->aSegment[p->nSegment])[iZero];\n      iZero++;\n  \n      for(j=0; j<nEntry; j++){\n        aIndex[j] = (ht_slot)j;\n      }\n      walMergesort((u32 *)aPgno, aTmp, aIndex, &nEntry);\n      p->aSegment[i].iZero = iZero;\n      p->aSegment[i].nEntry = nEntry;\n      p->aSegment[i].aIndex = aIndex;\n      p->aSegment[i].aPgno = (u32 *)aPgno;\n    }\n  }\n  sqlite3ScratchFree(aTmp);\n\n  if( rc!=SQLITE_OK ){\n    walIteratorFree(p);\n  }\n  *pp = p;\n  return rc;\n}\n\n/*\n** Attempt to obtain the exclusive WAL lock defined by parameters lockIdx and\n** n. If the attempt fails and parameter xBusy is not NULL, then it is a\n** busy-handler function. Invoke it and retry the lock until either the\n** lock is successfully obtained or the busy-handler returns 0.\n*/\nstatic int walBusyLock(\n  Wal *pWal,                      /* WAL connection */\n  int (*xBusy)(void*),            /* Function to call when busy */\n  void *pBusyArg,                 /* Context argument for xBusyHandler */\n  int lockIdx,                    /* Offset of first byte to lock */\n  int n                           /* Number of bytes to lock */\n){\n  int rc;\n  do {\n    rc = walLockExclusive(pWal, lockIdx, n);\n  }while( xBusy && rc==SQLITE_BUSY && xBusy(pBusyArg) );\n  return rc;\n}\n\n/*\n** The cache of the wal-index header must be valid to call this function.\n** Return the page-size in bytes used by the database.\n*/\nstatic int walPagesize(Wal *pWal){\n  return (pWal->hdr.szPage&0xfe00) + ((pWal->hdr.szPage&0x0001)<<16);\n}\n\n/*\n** Copy as much content as we can from the WAL back into the database file\n** in response to an sqlite3_wal_checkpoint() request or the equivalent.\n**\n** The amount of information copies from WAL to database might be limited\n** by active readers.  This routine will never overwrite a database page\n** that a concurrent reader might be using.\n**\n** All I/O barrier operations (a.k.a fsyncs) occur in this routine when\n** SQLite is in WAL-mode in synchronous=NORMAL.  That means that if \n** checkpoints are always run by a background thread or background \n** process, foreground threads will never block on a lengthy fsync call.\n**\n** Fsync is called on the WAL before writing content out of the WAL and\n** into the database.  This ensures that if the new content is persistent\n** in the WAL and can be recovered following a power-loss or hard reset.\n**\n** Fsync is also called on the database file if (and only if) the entire\n** WAL content is copied into the database file.  This second fsync makes\n** it safe to delete the WAL since the new content will persist in the\n** database file.\n**\n** This routine uses and updates the nBackfill field of the wal-index header.\n** This is the only routine tha will increase the value of nBackfill.  \n** (A WAL reset or recovery will revert nBackfill to zero, but not increase\n** its value.)\n**\n** The caller must be holding sufficient locks to ensure that no other\n** checkpoint is running (in any other thread or process) at the same\n** time.\n*/\nstatic int walCheckpoint(\n  Wal *pWal,                      /* Wal connection */\n  int eMode,                      /* One of PASSIVE, FULL or RESTART */\n  int (*xBusyCall)(void*),        /* Function to call when busy */\n  void *pBusyArg,                 /* Context argument for xBusyHandler */\n  int sync_flags,                 /* Flags for OsSync() (or 0) */\n  u8 *zBuf                        /* Temporary buffer to use */\n){\n  int rc;                         /* Return code */\n  int szPage;                     /* Database page-size */\n  WalIterator *pIter = 0;         /* Wal iterator context */\n  u32 iDbpage = 0;                /* Next database page to write */\n  u32 iFrame = 0;                 /* Wal frame containing data for iDbpage */\n  u32 mxSafeFrame;                /* Max frame that can be backfilled */\n  u32 mxPage;                     /* Max database page to write */\n  int i;                          /* Loop counter */\n  volatile WalCkptInfo *pInfo;    /* The checkpoint status information */\n  int (*xBusy)(void*) = 0;        /* Function to call when waiting for locks */\n\n  szPage = walPagesize(pWal);\n  testcase( szPage<=32768 );\n  testcase( szPage>=65536 );\n  pInfo = walCkptInfo(pWal);\n\n\n  if( pWal->hdr.mxFrame == 0 || (pInfo->nBackfill>=pWal->hdr.mxFrame && eMode != SQLITE_CHECKPOINT_RESTART) ) {\n      return SQLITE_OK;\n  }\n\n  /* Allocate the iterator */\n  rc = walIteratorInit(pWal, &pIter);\n  if( rc!=SQLITE_OK ){\n    return rc;\n  }\n  assert( pIter );\n\n  if( eMode!=SQLITE_CHECKPOINT_PASSIVE ) xBusy = xBusyCall;\n\n  /* Compute in mxSafeFrame the index of the last frame of the WAL that is\n  ** safe to write into the database.  Frames beyond mxSafeFrame might\n  ** overwrite database pages that are in use by active readers and thus\n  ** cannot be backfilled from the WAL.\n  */\n  mxSafeFrame = pWal->hdr.mxFrame;\n  mxPage = pWal->hdr.nPage;\n  for(i=1; i<WAL_NREADER; i++){\n    u32 y = pInfo->aReadMark[i];\n    if( mxSafeFrame>y ){\n      assert( y<=pWal->hdr.mxFrame );\n      rc = walBusyLock(pWal, xBusy, pBusyArg, WAL_READ_LOCK(i), 1);\n      if( rc==SQLITE_OK ){\n        pInfo->aReadMark[i] = READMARK_NOT_USED;\n        walUnlockExclusive(pWal, WAL_READ_LOCK(i), 1);\n      }else if( rc==SQLITE_BUSY ){\n        mxSafeFrame = y;\n        xBusy = 0;\n      }else{\n        goto walcheckpoint_out;\n      }\n    }\n  }\n\n  if( pInfo->nBackfill<mxSafeFrame\n   && (rc = walBusyLock(pWal, xBusy, pBusyArg, WAL_READ_LOCK(0), 1))==SQLITE_OK\n  ){\n    i64 nSize;                    /* Current size of database file */\n    u32 nBackfill = pInfo->nBackfill;\n\n    /* Sync the WAL to disk */\n    if( sync_flags ){\n      rc = sqlite3OsSync(pWal->pWalFd, sync_flags);\n    }\n\n    /* If the database file may grow as a result of this checkpoint, hint\n    ** about the eventual size of the db file to the VFS layer. \n    */\n    if( rc==SQLITE_OK ){\n      i64 nReq = ((i64)mxPage * szPage);\n      rc = sqlite3OsFileSize(pWal->pDbFd, &nSize);\n      if( rc==SQLITE_OK && nSize<nReq ){\n        sqlite3OsFileControl(pWal->pDbFd, SQLITE_FCNTL_SIZE_HINT, &nReq);\n      }\n    }\n\n    /* Iterate through the contents of the WAL, copying data to the db file. */\n    while( rc==SQLITE_OK && 0==walIteratorNext(pIter, &iDbpage, &iFrame) ){\n      i64 iOffset;\n      assert( walFramePgno(pWal, iFrame)==iDbpage );\n      if( iFrame<=nBackfill || iFrame>mxSafeFrame || iDbpage>mxPage ) continue;\n      iOffset = walFrameOffset(iFrame, szPage) + WAL_FRAME_HDRSIZE;\n      /* testcase( IS_BIG_INT(iOffset) ); // requires a 4GiB WAL file */\n      rc = sqlite3OsRead(pWal->pWalFd, zBuf, szPage, iOffset);\n      if( rc!=SQLITE_OK ) break;\n      iOffset = (iDbpage-1)*(i64)szPage;\n      testcase( IS_BIG_INT(iOffset) );\n      rc = sqlite3OsWrite(pWal->pDbFd, zBuf, szPage, iOffset);\n      if( rc!=SQLITE_OK ) break;\n    }\n\n    /* If work was actually accomplished... */\n    if( rc==SQLITE_OK ){\n      if( mxSafeFrame==walIndexHdr(pWal)->mxFrame ){\n        i64 szDb = pWal->hdr.nPage*(i64)szPage;\n        testcase( IS_BIG_INT(szDb) );\n        rc = sqlite3OsTruncate(pWal->pDbFd, szDb);\n        if( rc==SQLITE_OK && sync_flags ){\n          rc = sqlite3OsSync(pWal->pDbFd, sync_flags);\n        }\n      }\n      if( rc==SQLITE_OK ){\n        pInfo->nBackfill = mxSafeFrame;\n      }\n    }\n\n    /* Release the reader lock held while backfilling */\n    walUnlockExclusive(pWal, WAL_READ_LOCK(0), 1);\n  }\n\n  if( rc==SQLITE_BUSY ){\n    /* Reset the return code so as not to report a checkpoint failure\n    ** just because there are active readers.  */\n    rc = SQLITE_OK;\n  }\n\n  /* If this is an SQLITE_CHECKPOINT_RESTART operation, and the entire wal\n  ** file has been copied into the database file, then block until all\n  ** readers have finished using the wal file. This ensures that the next\n  ** process to write to the database restarts the wal file.\n  */\n  if( rc==SQLITE_OK && eMode!=SQLITE_CHECKPOINT_PASSIVE ){\n    assert( pWal->writeLock );\n    if( pInfo->nBackfill<pWal->hdr.mxFrame ){\n      rc = SQLITE_BUSY;\n    }else if( eMode==SQLITE_CHECKPOINT_RESTART ){\n      assert( mxSafeFrame==pWal->hdr.mxFrame );\n      rc = walBusyLock(pWal, xBusy, pBusyArg, WAL_READ_LOCK(1), WAL_NREADER-1);\n      if( rc==SQLITE_OK ){\n        walUnlockExclusive(pWal, WAL_READ_LOCK(1), WAL_NREADER-1);\n      }\n    }\n  }\n\n walcheckpoint_out:\n  walIteratorFree(pIter);\n  return rc;\n}\n\n/*\n** Close a connection to a log file.\n*/\nSQLITE_PRIVATE int sqlite3WalClose(\n  Wal *pWal,                      /* Wal to close */\n  int sync_flags,                 /* Flags to pass to OsSync() (or 0) */\n  int nBuf,\n  u8 *zBuf                        /* Buffer of at least nBuf bytes */\n){\n  int rc = SQLITE_OK;\n  if( pWal ){\n    int isDelete = 0;             /* True to unlink wal and wal-index files */\n\n    /* If an EXCLUSIVE lock can be obtained on the database file (using the\n    ** ordinary, rollback-mode locking methods, this guarantees that the\n    ** connection associated with this log file is the only connection to\n    ** the database. In this case checkpoint the database and unlink both\n    ** the wal and wal-index files.\n    **\n    ** The EXCLUSIVE lock is not released before returning.\n    */\n    rc = sqlite3OsLock(pWal->pDbFd, SQLITE_LOCK_EXCLUSIVE);\n    if( rc==SQLITE_OK ){\n      if( pWal->exclusiveMode==WAL_NORMAL_MODE ){\n        pWal->exclusiveMode = WAL_EXCLUSIVE_MODE;\n      }\n      rc = sqlite3WalCheckpoint(\n          pWal, SQLITE_CHECKPOINT_PASSIVE, 0, 0, sync_flags, nBuf, zBuf, 0, 0\n      );\n      if( rc==SQLITE_OK ){\n        isDelete = 1;\n      }\n    }\n\n    walIndexClose(pWal, isDelete);\n    sqlite3OsClose(pWal->pWalFd);\n    if( isDelete ){\n      sqlite3OsDelete(pWal->pVfs, pWal->zWalName, 0);\n    }\n    WALTRACE((\"WAL%p: closed\\n\", pWal));\n    sqlite3_free((void *)pWal->apWiData);\n    sqlite3_free(pWal);\n  }\n  return rc;\n}\n\n/*\n** Try to read the wal-index header.  Return 0 on success and 1 if\n** there is a problem.\n**\n** The wal-index is in shared memory.  Another thread or process might\n** be writing the header at the same time this procedure is trying to\n** read it, which might result in inconsistency.  A dirty read is detected\n** by verifying that both copies of the header are the same and also by\n** a checksum on the header.\n**\n** If and only if the read is consistent and the header is different from\n** pWal->hdr, then pWal->hdr is updated to the content of the new header\n** and *pChanged is set to 1.\n**\n** If the checksum cannot be verified return non-zero. If the header\n** is read successfully and the checksum verified, return zero.\n*/\nstatic int walIndexTryHdr(Wal *pWal, int *pChanged){\n  u32 aCksum[2];                  /* Checksum on the header content */\n  WalIndexHdr h1, h2;             /* Two copies of the header content */\n  WalIndexHdr volatile *aHdr;     /* Header in shared memory */\n\n  /* The first page of the wal-index must be mapped at this point. */\n  assert( pWal->nWiData>0 && pWal->apWiData[0] );\n\n  /* Read the header. This might happen concurrently with a write to the\n  ** same area of shared memory on a different CPU in a SMP,\n  ** meaning it is possible that an inconsistent snapshot is read\n  ** from the file. If this happens, return non-zero.\n  **\n  ** There are two copies of the header at the beginning of the wal-index.\n  ** When reading, read [0] first then [1].  Writes are in the reverse order.\n  ** Memory barriers are used to prevent the compiler or the hardware from\n  ** reordering the reads and writes.\n  */\n  aHdr = walIndexHdr(pWal);\n  memcpy(&h1, (void *)&aHdr[0], sizeof(h1));\n  walShmBarrier(pWal);\n  memcpy(&h2, (void *)&aHdr[1], sizeof(h2));\n\n  if( memcmp(&h1, &h2, sizeof(h1))!=0 ){\n    return 1;   /* Dirty read */\n  }  \n  if( h1.isInit==0 ){\n    return 1;   /* Malformed header - probably all zeros */\n  }\n  walChecksumBytes(1, (u8*)&h1, sizeof(h1)-sizeof(h1.aCksum), 0, aCksum);\n  if( aCksum[0]!=h1.aCksum[0] || aCksum[1]!=h1.aCksum[1] ){\n    return 1;   /* Checksum does not match */\n  }\n\n  if( memcmp(&pWal->hdr, &h1, sizeof(WalIndexHdr)) ){\n    *pChanged = 1;\n    memcpy(&pWal->hdr, &h1, sizeof(WalIndexHdr));\n    pWal->szPage = (pWal->hdr.szPage&0xfe00) + ((pWal->hdr.szPage&0x0001)<<16);\n    testcase( pWal->szPage<=32768 );\n    testcase( pWal->szPage>=65536 );\n  }\n\n  /* The header was successfully read. Return zero. */\n  return 0;\n}\n\n/*\n** Read the wal-index header from the wal-index and into pWal->hdr.\n** If the wal-header appears to be corrupt, try to reconstruct the\n** wal-index from the WAL before returning.\n**\n** Set *pChanged to 1 if the wal-index header value in pWal->hdr is\n** changed by this opertion.  If pWal->hdr is unchanged, set *pChanged\n** to 0.\n**\n** If the wal-index header is successfully read, return SQLITE_OK. \n** Otherwise an SQLite error code.\n*/\nstatic int walIndexReadHdr(Wal *pWal, int *pChanged){\n  int rc;                         /* Return code */\n  int badHdr;                     /* True if a header read failed */\n  volatile u32 *page0;            /* Chunk of wal-index containing header */\n\n  /* Ensure that page 0 of the wal-index (the page that contains the \n  ** wal-index header) is mapped. Return early if an error occurs here.\n  */\n  assert( pChanged );\n  rc = walIndexPage(pWal, 0, &page0);\n  if( rc!=SQLITE_OK ){\n    return rc;\n  };\n  assert( page0 || pWal->writeLock==0 );\n\n  /* If the first page of the wal-index has been mapped, try to read the\n  ** wal-index header immediately, without holding any lock. This usually\n  ** works, but may fail if the wal-index header is corrupt or currently \n  ** being modified by another thread or process.\n  */\n  badHdr = (page0 ? walIndexTryHdr(pWal, pChanged) : 1);\n\n  /* If the first attempt failed, it might have been due to a race\n  ** with a writer.  So get a WRITE lock and try again.\n  */\n  assert( badHdr==0 || pWal->writeLock==0 );\n  if( badHdr && SQLITE_OK==(rc = walLockExclusive(pWal, WAL_WRITE_LOCK, 1)) ){\n    pWal->writeLock = 1;\n    if( SQLITE_OK==(rc = walIndexPage(pWal, 0, &page0)) ){\n      badHdr = walIndexTryHdr(pWal, pChanged);\n      if( badHdr ){\n        /* If the wal-index header is still malformed even while holding\n        ** a WRITE lock, it can only mean that the header is corrupted and\n        ** needs to be reconstructed.  So run recovery to do exactly that.\n        */\n        rc = walIndexRecover(pWal);\n        *pChanged = 1;\n      }\n    }\n    pWal->writeLock = 0;\n    walUnlockExclusive(pWal, WAL_WRITE_LOCK, 1);\n  }\n\n  /* If the header is read successfully, check the version number to make\n  ** sure the wal-index was not constructed with some future format that\n  ** this version of SQLite cannot understand.\n  */\n  if( badHdr==0 && pWal->hdr.iVersion!=WALINDEX_MAX_VERSION ){\n    rc = SQLITE_CANTOPEN_BKPT;\n  }\n\n  return rc;\n}\n\n/*\n** This is the value that walTryBeginRead returns when it needs to\n** be retried.\n*/\n#define WAL_RETRY  (-1)\n\n/*\n** Attempt to start a read transaction.  This might fail due to a race or\n** other transient condition.  When that happens, it returns WAL_RETRY to\n** indicate to the caller that it is safe to retry immediately.\n**\n** On success return SQLITE_OK.  On a permanent failure (such an\n** I/O error or an SQLITE_BUSY because another process is running\n** recovery) return a positive error code.\n**\n** The useWal parameter is true to force the use of the WAL and disable\n** the case where the WAL is bypassed because it has been completely\n** checkpointed.  If useWal==0 then this routine calls walIndexReadHdr() \n** to make a copy of the wal-index header into pWal->hdr.  If the \n** wal-index header has changed, *pChanged is set to 1 (as an indication \n** to the caller that the local paget cache is obsolete and needs to be \n** flushed.)  When useWal==1, the wal-index header is assumed to already\n** be loaded and the pChanged parameter is unused.\n**\n** The caller must set the cnt parameter to the number of prior calls to\n** this routine during the current read attempt that returned WAL_RETRY.\n** This routine will start taking more aggressive measures to clear the\n** race conditions after multiple WAL_RETRY returns, and after an excessive\n** number of errors will ultimately return SQLITE_PROTOCOL.  The\n** SQLITE_PROTOCOL return indicates that some other process has gone rogue\n** and is not honoring the locking protocol.  There is a vanishingly small\n** chance that SQLITE_PROTOCOL could be returned because of a run of really\n** bad luck when there is lots of contention for the wal-index, but that\n** possibility is so small that it can be safely neglected, we believe.\n**\n** On success, this routine obtains a read lock on \n** WAL_READ_LOCK(pWal->readLock).  The pWal->readLock integer is\n** in the range 0 <= pWal->readLock < WAL_NREADER.  If pWal->readLock==(-1)\n** that means the Wal does not hold any read lock.  The reader must not\n** access any database page that is modified by a WAL frame up to and\n** including frame number aReadMark[pWal->readLock].  The reader will\n** use WAL frames up to and including pWal->hdr.mxFrame if pWal->readLock>0\n** Or if pWal->readLock==0, then the reader will ignore the WAL\n** completely and get all content directly from the database file.\n** If the useWal parameter is 1 then the WAL will never be ignored and\n** this routine will always set pWal->readLock>0 on success.\n** When the read transaction is completed, the caller must release the\n** lock on WAL_READ_LOCK(pWal->readLock) and set pWal->readLock to -1.\n**\n** This routine uses the nBackfill and aReadMark[] fields of the header\n** to select a particular WAL_READ_LOCK() that strives to let the\n** checkpoint process do as much work as possible.  This routine might\n** update values of the aReadMark[] array in the header, but if it does\n** so it takes care to hold an exclusive lock on the corresponding\n** WAL_READ_LOCK() while changing values.\n*/\nstatic int walTryBeginRead(Wal *pWal, int *pChanged, int useWal, int cnt){\n  volatile WalCkptInfo *pInfo;    /* Checkpoint information in wal-index */\n  u32 mxReadMark;                 /* Largest aReadMark[] value */\n  int mxI;                        /* Index of largest aReadMark[] value */\n  int i;                          /* Loop counter */\n  int rc = SQLITE_OK;             /* Return code  */\n\n  assert( pWal->readLock<0 );     /* Not currently locked */\n\n  /* Take steps to avoid spinning forever if there is a protocol error.\n  **\n  ** Circumstances that cause a RETRY should only last for the briefest\n  ** instances of time.  No I/O or other system calls are done while the\n  ** locks are held, so the locks should not be held for very long. But \n  ** if we are unlucky, another process that is holding a lock might get\n  ** paged out or take a page-fault that is time-consuming to resolve, \n  ** during the few nanoseconds that it is holding the lock.  In that case,\n  ** it might take longer than normal for the lock to free.\n  **\n  ** After 5 RETRYs, we begin calling sqlite3OsSleep().  The first few\n  ** calls to sqlite3OsSleep() have a delay of 1 microsecond.  Really this\n  ** is more of a scheduler yield than an actual delay.  But on the 10th\n  ** an subsequent retries, the delays start becoming longer and longer, \n  ** so that on the 100th (and last) RETRY we delay for 21 milliseconds.\n  ** The total delay time before giving up is less than 1 second.\n  */\n  if( cnt>5 ){\n    int nDelay = 1;                      /* Pause time in microseconds */\n    if( cnt>100 ){\n      VVA_ONLY( pWal->lockError = 1; )\n      return SQLITE_PROTOCOL;\n    }\n    if( cnt>=10 ) nDelay = (cnt-9)*238;  /* Max delay 21ms. Total delay 996ms */\n    sqlite3OsSleep(pWal->pVfs, nDelay);\n  }\n\n  if( !useWal ){\n    rc = walIndexReadHdr(pWal, pChanged);\n    if( rc==SQLITE_BUSY ){\n      /* If there is not a recovery running in another thread or process\n      ** then convert BUSY errors to WAL_RETRY.  If recovery is known to\n      ** be running, convert BUSY to BUSY_RECOVERY.  There is a race here\n      ** which might cause WAL_RETRY to be returned even if BUSY_RECOVERY\n      ** would be technically correct.  But the race is benign since with\n      ** WAL_RETRY this routine will be called again and will probably be\n      ** right on the second iteration.\n      */\n      if( pWal->apWiData[0]==0 ){\n        /* This branch is taken when the xShmMap() method returns SQLITE_BUSY.\n        ** We assume this is a transient condition, so return WAL_RETRY. The\n        ** xShmMap() implementation used by the default unix and win32 VFS \n        ** modules may return SQLITE_BUSY due to a race condition in the \n        ** code that determines whether or not the shared-memory region \n        ** must be zeroed before the requested page is returned.\n        */\n        rc = WAL_RETRY;\n      }else if( SQLITE_OK==(rc = walLockShared(pWal, WAL_RECOVER_LOCK)) ){\n        walUnlockShared(pWal, WAL_RECOVER_LOCK);\n        rc = WAL_RETRY;\n      }else if( rc==SQLITE_BUSY ){\n        rc = SQLITE_BUSY_RECOVERY;\n      }\n    }\n    if( rc!=SQLITE_OK ){\n      return rc;\n    }\n  }\n\n  pInfo = walCkptInfo(pWal);\n  if( !useWal && pInfo->nBackfill==pWal->hdr.mxFrame ){\n    /* The WAL has been completely backfilled (or it is empty).\n    ** and can be safely ignored.\n    */\n    rc = walLockShared(pWal, WAL_READ_LOCK(0));\n    walShmBarrier(pWal);\n    if( rc==SQLITE_OK ){\n      if( memcmp((void *)walIndexHdr(pWal), &pWal->hdr, sizeof(WalIndexHdr)) ){\n        /* It is not safe to allow the reader to continue here if frames\n        ** may have been appended to the log before READ_LOCK(0) was obtained.\n        ** When holding READ_LOCK(0), the reader ignores the entire log file,\n        ** which implies that the database file contains a trustworthy\n        ** snapshoT. Since holding READ_LOCK(0) prevents a checkpoint from\n        ** happening, this is usually correct.\n        **\n        ** However, if frames have been appended to the log (or if the log \n        ** is wrapped and written for that matter) before the READ_LOCK(0)\n        ** is obtained, that is not necessarily true. A checkpointer may\n        ** have started to backfill the appended frames but crashed before\n        ** it finished. Leaving a corrupt image in the database file.\n        */\n        walUnlockShared(pWal, WAL_READ_LOCK(0));\n        return WAL_RETRY;\n      }\n      pWal->readLock = 0;\n      return SQLITE_OK;\n    }else if( rc!=SQLITE_BUSY ){\n      return rc;\n    }\n  }\n\n  /* If we get this far, it means that the reader will want to use\n  ** the WAL to get at content from recent commits.  The job now is\n  ** to select one of the aReadMark[] entries that is closest to\n  ** but not exceeding pWal->hdr.mxFrame and lock that entry.\n  */\n  mxReadMark = 0;\n  mxI = 0;\n  for(i=1; i<WAL_NREADER; i++){\n    u32 thisMark = pInfo->aReadMark[i];\n    if( mxReadMark<=thisMark && thisMark<=pWal->hdr.mxFrame ){\n      assert( thisMark!=READMARK_NOT_USED );\n      mxReadMark = thisMark;\n      mxI = i;\n    }\n  }\n  /* There was once an \"if\" here. The extra \"{\" is to preserve indentation. */\n  {\n    if( mxReadMark < pWal->hdr.mxFrame || mxI==0 ){\n      for(i=1; i<WAL_NREADER; i++){\n        rc = walLockExclusive(pWal, WAL_READ_LOCK(i), 1);\n        if( rc==SQLITE_OK ){\n          mxReadMark = pInfo->aReadMark[i] = pWal->hdr.mxFrame;\n          mxI = i;\n          walUnlockExclusive(pWal, WAL_READ_LOCK(i), 1);\n          break;\n        }else if( rc!=SQLITE_BUSY ){\n          return rc;\n        }\n      }\n    }\n    if( mxI==0 ){\n      assert( rc==SQLITE_BUSY );\n      return WAL_RETRY;\n    }\n\n    rc = walLockShared(pWal, WAL_READ_LOCK(mxI));\n    if( rc ){\n      return rc==SQLITE_BUSY ? WAL_RETRY : rc;\n    }\n    /* Now that the read-lock has been obtained, check that neither the\n    ** value in the aReadMark[] array or the contents of the wal-index\n    ** header have changed.\n    **\n    ** It is necessary to check that the wal-index header did not change\n    ** between the time it was read and when the shared-lock was obtained\n    ** on WAL_READ_LOCK(mxI) was obtained to account for the possibility\n    ** that the log file may have been wrapped by a writer, or that frames\n    ** that occur later in the log than pWal->hdr.mxFrame may have been\n    ** copied into the database by a checkpointer. If either of these things\n    ** happened, then reading the database with the current value of\n    ** pWal->hdr.mxFrame risks reading a corrupted snapshot. So, retry\n    ** instead.\n    **\n    ** This does not guarantee that the copy of the wal-index header is up to\n    ** date before proceeding. That would not be possible without somehow\n    ** blocking writers. It only guarantees that a dangerous checkpoint or \n    ** log-wrap (either of which would require an exclusive lock on\n    ** WAL_READ_LOCK(mxI)) has not occurred since the snapshot was valid.\n    */\n    walShmBarrier(pWal);\n    if( pInfo->aReadMark[mxI]!=mxReadMark\n     || memcmp((void *)walIndexHdr(pWal), &pWal->hdr, sizeof(WalIndexHdr))\n    ){\n      walUnlockShared(pWal, WAL_READ_LOCK(mxI));\n      return WAL_RETRY;\n    }else{\n      assert( mxReadMark<=pWal->hdr.mxFrame );\n      pWal->readLock = (i16)mxI;\n    }\n  }\n  return rc;\n}\n\n/*\n** Begin a read transaction on the database.\n**\n** This routine used to be called sqlite3OpenSnapshot() and with good reason:\n** it takes a snapshot of the state of the WAL and wal-index for the current\n** instant in time.  The current thread will continue to use this snapshot.\n** Other threads might append new content to the WAL and wal-index but\n** that extra content is ignored by the current thread.\n**\n** If the database contents have changes since the previous read\n** transaction, then *pChanged is set to 1 before returning.  The\n** Pager layer will use this to know that is cache is stale and\n** needs to be flushed.\n*/\nSQLITE_PRIVATE int sqlite3WalBeginReadTransaction(Wal *pWal, int *pChanged){\n  int rc;                         /* Return code */\n  int cnt = 0;                    /* Number of TryBeginRead attempts */\n\n  do{\n    rc = walTryBeginRead(pWal, pChanged, 0, ++cnt);\n  }while( rc==WAL_RETRY );\n  testcase( (rc&0xff)==SQLITE_BUSY );\n  testcase( (rc&0xff)==SQLITE_IOERR );\n  testcase( rc==SQLITE_PROTOCOL );\n  testcase( rc==SQLITE_OK );\n  return rc;\n}\n\n/*\n** Finish with a read transaction.  All this does is release the\n** read-lock.\n*/\nSQLITE_PRIVATE void sqlite3WalEndReadTransaction(Wal *pWal){\n  sqlite3WalEndWriteTransaction(pWal);\n  if( pWal->readLock>=0 ){\n    walUnlockShared(pWal, WAL_READ_LOCK(pWal->readLock));\n    pWal->readLock = -1;\n  }\n}\n\n/*\n** Read a page from the WAL, if it is present in the WAL and if the \n** current read transaction is configured to use the WAL.  \n**\n** The *pInWal is set to 1 if the requested page is in the WAL and\n** has been loaded.  Or *pInWal is set to 0 if the page was not in \n** the WAL and needs to be read out of the database.\n*/\nSQLITE_PRIVATE int sqlite3WalRead(\n  Wal *pWal,                      /* WAL handle */\n  Pgno pgno,                      /* Database page number to read data for */\n  int *pInWal,                    /* OUT: True if data is read from WAL */\n  int nOut,                       /* Size of buffer pOut in bytes */\n  u8 *pOut                        /* Buffer to write page data to */\n){\n  u32 iRead = 0;                  /* If !=0, WAL frame to return data from */\n  u32 iLast = pWal->hdr.mxFrame;  /* Last page in WAL for this reader */\n  int iHash;                      /* Used to loop through N hash tables */\n\n  /* This routine is only be called from within a read transaction. */\n  assert( pWal->readLock>=0 || pWal->lockError );\n\n  /* If the \"last page\" field of the wal-index header snapshot is 0, then\n  ** no data will be read from the wal under any circumstances. Return early\n  ** in this case as an optimization.  Likewise, if pWal->readLock==0, \n  ** then the WAL is ignored by the reader so return early, as if the \n  ** WAL were empty.\n  */\n  if( iLast==0 || pWal->readLock==0 ){\n    *pInWal = 0;\n    return SQLITE_OK;\n  }\n\n  /* Search the hash table or tables for an entry matching page number\n  ** pgno. Each iteration of the following for() loop searches one\n  ** hash table (each hash table indexes up to HASHTABLE_NPAGE frames).\n  **\n  ** This code might run concurrently to the code in walIndexAppend()\n  ** that adds entries to the wal-index (and possibly to this hash \n  ** table). This means the value just read from the hash \n  ** slot (aHash[iKey]) may have been added before or after the \n  ** current read transaction was opened. Values added after the\n  ** read transaction was opened may have been written incorrectly -\n  ** i.e. these slots may contain garbage data. However, we assume\n  ** that any slots written before the current read transaction was\n  ** opened remain unmodified.\n  **\n  ** For the reasons above, the if(...) condition featured in the inner\n  ** loop of the following block is more stringent that would be required \n  ** if we had exclusive access to the hash-table:\n  **\n  **   (aPgno[iFrame]==pgno): \n  **     This condition filters out normal hash-table collisions.\n  **\n  **   (iFrame<=iLast): \n  **     This condition filters out entries that were added to the hash\n  **     table after the current read-transaction had started.\n  */\n  for(iHash=walFramePage(iLast); iHash>=0 && iRead==0; iHash--){\n    volatile ht_slot *aHash;      /* Pointer to hash table */\n    volatile u32 *aPgno;          /* Pointer to array of page numbers */\n    u32 iZero;                    /* Frame number corresponding to aPgno[0] */\n    int iKey;                     /* Hash slot index */\n    int nCollide;                 /* Number of hash collisions remaining */\n    int rc;                       /* Error code */\n\n    rc = walHashGet(pWal, iHash, &aHash, &aPgno, &iZero);\n    if( rc!=SQLITE_OK ){\n      return rc;\n    }\n    nCollide = HASHTABLE_NSLOT;\n    for(iKey=walHash(pgno); aHash[iKey]; iKey=walNextHash(iKey)){\n      u32 iFrame = aHash[iKey] + iZero;\n      if( iFrame<=iLast && aPgno[aHash[iKey]]==pgno ){\n        assert( iFrame>iRead );\n        iRead = iFrame;\n      }\n      if( (nCollide--)==0 ){\n        return SQLITE_CORRUPT_BKPT;\n      }\n    }\n  }\n\n#ifdef SQLITE_ENABLE_EXPENSIVE_ASSERT\n  /* If expensive assert() statements are available, do a linear search\n  ** of the wal-index file content. Make sure the results agree with the\n  ** result obtained using the hash indexes above.  */\n  {\n    u32 iRead2 = 0;\n    u32 iTest;\n    for(iTest=iLast; iTest>0; iTest--){\n      if( walFramePgno(pWal, iTest)==pgno ){\n        iRead2 = iTest;\n        break;\n      }\n    }\n    assert( iRead==iRead2 );\n  }\n#endif\n\n  /* If iRead is non-zero, then it is the log frame number that contains the\n  ** required page. Read and return data from the log file.\n  */\n  if( iRead ){\n    int sz;\n    i64 iOffset;\n    sz = pWal->hdr.szPage;\n    sz = (pWal->hdr.szPage&0xfe00) + ((pWal->hdr.szPage&0x0001)<<16);\n    testcase( sz<=32768 );\n    testcase( sz>=65536 );\n    iOffset = walFrameOffset(iRead, sz) + WAL_FRAME_HDRSIZE;\n    *pInWal = 1;\n    /* testcase( IS_BIG_INT(iOffset) ); // requires a 4GiB WAL */\n    return sqlite3OsRead(pWal->pWalFd, pOut, nOut, iOffset);\n  }\n\n  *pInWal = 0;\n  return SQLITE_OK;\n}\n\n\n/* \n** Return the size of the database in pages (or zero, if unknown).\n*/\nSQLITE_PRIVATE Pgno sqlite3WalDbsize(Wal *pWal){\n  if( pWal && ALWAYS(pWal->readLock>=0) ){\n    return pWal->hdr.nPage;\n  }\n  return 0;\n}\n\n\n/* \n** This function starts a write transaction on the WAL.\n**\n** A read transaction must have already been started by a prior call\n** to sqlite3WalBeginReadTransaction().\n**\n** If another thread or process has written into the database since\n** the read transaction was started, then it is not possible for this\n** thread to write as doing so would cause a fork.  So this routine\n** returns SQLITE_BUSY in that case and no write transaction is started.\n**\n** There can only be a single writer active at a time.\n*/\nSQLITE_PRIVATE int sqlite3WalBeginWriteTransaction(Wal *pWal){\n  int rc;\n\n  /* Cannot start a write transaction without first holding a read\n  ** transaction. */\n  assert( pWal->readLock>=0 );\n\n  if( pWal->readOnly ){\n    return SQLITE_READONLY;\n  }\n\n  /* Only one writer allowed at a time.  Get the write lock.  Return\n  ** SQLITE_BUSY if unable.\n  */\n  rc = walLockExclusive(pWal, WAL_WRITE_LOCK, 1);\n  if( rc ){\n    return rc;\n  }\n  pWal->writeLock = 1;\n\n  /* If another connection has written to the database file since the\n  ** time the read transaction on this connection was started, then\n  ** the write is disallowed.\n  */\n  if( memcmp(&pWal->hdr, (void *)walIndexHdr(pWal), sizeof(WalIndexHdr))!=0 ){\n    walUnlockExclusive(pWal, WAL_WRITE_LOCK, 1);\n    pWal->writeLock = 0;\n    rc = SQLITE_BUSY;\n  }\n\n  return rc;\n}\n\n/*\n** End a write transaction.  The commit has already been done.  This\n** routine merely releases the lock.\n*/\nSQLITE_PRIVATE int sqlite3WalEndWriteTransaction(Wal *pWal){\n  if( pWal->writeLock ){\n    walUnlockExclusive(pWal, WAL_WRITE_LOCK, 1);\n    pWal->writeLock = 0;\n  }\n  return SQLITE_OK;\n}\n\n/*\n** If any data has been written (but not committed) to the log file, this\n** function moves the write-pointer back to the start of the transaction.\n**\n** Additionally, the callback function is invoked for each frame written\n** to the WAL since the start of the transaction. If the callback returns\n** other than SQLITE_OK, it is not invoked again and the error code is\n** returned to the caller.\n**\n** Otherwise, if the callback function does not return an error, this\n** function returns SQLITE_OK.\n*/\nSQLITE_PRIVATE int sqlite3WalUndo(Wal *pWal, int (*xUndo)(void *, Pgno), void *pUndoCtx){\n  int rc = SQLITE_OK;\n  if( ALWAYS(pWal->writeLock) ){\n    Pgno iMax = pWal->hdr.mxFrame;\n    Pgno iFrame;\n  \n    /* Restore the clients cache of the wal-index header to the state it\n    ** was in before the client began writing to the database. \n    */\n    memcpy(&pWal->hdr, (void *)walIndexHdr(pWal), sizeof(WalIndexHdr));\n\n    for(iFrame=pWal->hdr.mxFrame+1; \n        ALWAYS(rc==SQLITE_OK) && iFrame<=iMax; \n        iFrame++\n    ){\n      /* This call cannot fail. Unless the page for which the page number\n      ** is passed as the second argument is (a) in the cache and \n      ** (b) has an outstanding reference, then xUndo is either a no-op\n      ** (if (a) is false) or simply expels the page from the cache (if (b)\n      ** is false).\n      **\n      ** If the upper layer is doing a rollback, it is guaranteed that there\n      ** are no outstanding references to any page other than page 1. And\n      ** page 1 is never written to the log until the transaction is\n      ** committed. As a result, the call to xUndo may not fail.\n      */\n      assert( walFramePgno(pWal, iFrame)!=1 );\n      rc = xUndo(pUndoCtx, walFramePgno(pWal, iFrame));\n    }\n    walCleanupHash(pWal);\n  }\n  assert( rc==SQLITE_OK );\n  return rc;\n}\n\n/* \n** Argument aWalData must point to an array of WAL_SAVEPOINT_NDATA u32 \n** values. This function populates the array with values required to \n** \"rollback\" the write position of the WAL handle back to the current \n** point in the event of a savepoint rollback (via WalSavepointUndo()).\n*/\nSQLITE_PRIVATE void sqlite3WalSavepoint(Wal *pWal, u32 *aWalData){\n  assert( pWal->writeLock );\n  aWalData[0] = pWal->hdr.mxFrame;\n  aWalData[1] = pWal->hdr.aFrameCksum[0];\n  aWalData[2] = pWal->hdr.aFrameCksum[1];\n  aWalData[3] = pWal->nCkpt;\n}\n\n/* \n** Move the write position of the WAL back to the point identified by\n** the values in the aWalData[] array. aWalData must point to an array\n** of WAL_SAVEPOINT_NDATA u32 values that has been previously populated\n** by a call to WalSavepoint().\n*/\nSQLITE_PRIVATE int sqlite3WalSavepointUndo(Wal *pWal, u32 *aWalData){\n  int rc = SQLITE_OK;\n\n  assert( pWal->writeLock );\n  assert( aWalData[3]!=pWal->nCkpt || aWalData[0]<=pWal->hdr.mxFrame );\n\n  if( aWalData[3]!=pWal->nCkpt ){\n    /* This savepoint was opened immediately after the write-transaction\n    ** was started. Right after that, the writer decided to wrap around\n    ** to the start of the log. Update the savepoint values to match.\n    */\n    aWalData[0] = 0;\n    aWalData[3] = pWal->nCkpt;\n  }\n\n  if( aWalData[0]<pWal->hdr.mxFrame ){\n    pWal->hdr.mxFrame = aWalData[0];\n    pWal->hdr.aFrameCksum[0] = aWalData[1];\n    pWal->hdr.aFrameCksum[1] = aWalData[2];\n    walCleanupHash(pWal);\n  }\n\n  return rc;\n}\n\n/*\n** This function is called just before writing a set of frames to the log\n** file (see sqlite3WalFrames()). It checks to see if, instead of appending\n** to the current log file, it is possible to overwrite the start of the\n** existing log file with the new frames (i.e. \"reset\" the log). If so,\n** it sets pWal->hdr.mxFrame to 0. Otherwise, pWal->hdr.mxFrame is left\n** unchanged.\n**\n** SQLITE_OK is returned if no error is encountered (regardless of whether\n** or not pWal->hdr.mxFrame is modified). An SQLite error code is returned\n** if an error occurs.\n*/\nstatic int walRestartLog(Wal *pWal){\n  int rc = SQLITE_OK;\n  int cnt;\n\n  if( pWal->readLock==0 ){\n    volatile WalCkptInfo *pInfo = walCkptInfo(pWal);\n    assert( pInfo->nBackfill==pWal->hdr.mxFrame );\n    if( pInfo->nBackfill>0 ){\n      u32 salt1;\n      sqlite3_randomness(4, &salt1);\n      rc = walLockExclusive(pWal, WAL_READ_LOCK(1), WAL_NREADER-1);\n      if( rc==SQLITE_OK ){\n        /* If all readers are using WAL_READ_LOCK(0) (in other words if no\n        ** readers are currently using the WAL), then the transactions\n        ** frames will overwrite the start of the existing log. Update the\n        ** wal-index header to reflect this.\n        **\n        ** In theory it would be Ok to update the cache of the header only\n        ** at this point. But updating the actual wal-index header is also\n        ** safe and means there is no special case for sqlite3WalUndo()\n        ** to handle if this transaction is rolled back.\n        */\n        int i;                    /* Loop counter */\n        u32 *aSalt = pWal->hdr.aSalt;       /* Big-endian salt values */\n        pWal->nCkpt++;\n        pWal->hdr.mxFrame = 0;\n        sqlite3Put4byte((u8*)&aSalt[0], 1 + sqlite3Get4byte((u8*)&aSalt[0]));\n        aSalt[1] = salt1;\n        walIndexWriteHdr(pWal);\n        pInfo->nBackfill = 0;\n        for(i=1; i<WAL_NREADER; i++) pInfo->aReadMark[i] = READMARK_NOT_USED;\n        assert( pInfo->aReadMark[0]==0 );\n        walUnlockExclusive(pWal, WAL_READ_LOCK(1), WAL_NREADER-1);\n      }else if( rc!=SQLITE_BUSY ){\n        return rc;\n      }\n    }\n    walUnlockShared(pWal, WAL_READ_LOCK(0));\n    pWal->readLock = -1;\n    cnt = 0;\n    do{\n      int notUsed;\n      rc = walTryBeginRead(pWal, &notUsed, 1, ++cnt);\n    }while( rc==WAL_RETRY );\n    assert( (rc&0xff)!=SQLITE_BUSY ); /* BUSY not possible when useWal==1 */\n    testcase( (rc&0xff)==SQLITE_IOERR );\n    testcase( rc==SQLITE_PROTOCOL );\n    testcase( rc==SQLITE_OK );\n  }\n  return rc;\n}\n\n/* \n** Write a set of frames to the log. The caller must hold the write-lock\n** on the log file (obtained using sqlite3WalBeginWriteTransaction()).\n*/\nSQLITE_PRIVATE int sqlite3WalFrames(\n  Wal *pWal,                      /* Wal handle to write to */\n  int szPage,                     /* Database page-size in bytes */\n  PgHdr *pList,                   /* List of dirty pages to write */\n  Pgno nTruncate,                 /* Database size after this commit */\n  int isCommit,                   /* True if this is a commit */\n  int sync_flags                  /* Flags to pass to OsSync() (or 0) */\n){\n  int rc;                         /* Used to catch return codes */\n  u32 iFrame;                     /* Next frame address */\n  u8 aFrame[WAL_FRAME_HDRSIZE];   /* Buffer to assemble frame-header in */\n  PgHdr *p;                       /* Iterator to run through pList with. */\n  PgHdr *pLast = 0;               /* Last frame in list */\n  int nLast = 0;                  /* Number of extra copies of last page */\n\n  assert( pList );\n  assert( pWal->writeLock );\n\n#if defined(SQLITE_TEST) && defined(SQLITE_DEBUG)\n  { int cnt; for(cnt=0, p=pList; p; p=p->pDirty, cnt++){}\n    WALTRACE((\"WAL%p: frame write begin. %d frames. mxFrame=%d. %s\\n\",\n              pWal, cnt, pWal->hdr.mxFrame, isCommit ? \"Commit\" : \"Spill\"));\n  }\n#endif\n\n  /* See if it is possible to write these frames into the start of the\n  ** log file, instead of appending to it at pWal->hdr.mxFrame.\n  */\n  if( SQLITE_OK!=(rc = walRestartLog(pWal)) ){\n    return rc;\n  }\n\n  /* If this is the first frame written into the log, write the WAL\n  ** header to the start of the WAL file. See comments at the top of\n  ** this source file for a description of the WAL header format.\n  */\n  iFrame = pWal->hdr.mxFrame;\n  if( iFrame==0 ){\n    u8 aWalHdr[WAL_HDRSIZE];      /* Buffer to assemble wal-header in */\n    u32 aCksum[2];                /* Checksum for wal-header */\n\n    sqlite3Put4byte(&aWalHdr[0], (WAL_MAGIC | SQLITE_BIGENDIAN));\n    sqlite3Put4byte(&aWalHdr[4], WAL_MAX_VERSION);\n    sqlite3Put4byte(&aWalHdr[8], szPage);\n    sqlite3Put4byte(&aWalHdr[12], pWal->nCkpt);\n    sqlite3_randomness(8, pWal->hdr.aSalt);\n    memcpy(&aWalHdr[16], pWal->hdr.aSalt, 8);\n    walChecksumBytes(1, aWalHdr, WAL_HDRSIZE-2*4, 0, aCksum);\n    sqlite3Put4byte(&aWalHdr[24], aCksum[0]);\n    sqlite3Put4byte(&aWalHdr[28], aCksum[1]);\n    \n    pWal->szPage = szPage;\n    pWal->hdr.bigEndCksum = SQLITE_BIGENDIAN;\n    pWal->hdr.aFrameCksum[0] = aCksum[0];\n    pWal->hdr.aFrameCksum[1] = aCksum[1];\n\n    rc = sqlite3OsWrite(pWal->pWalFd, aWalHdr, sizeof(aWalHdr), 0);\n    WALTRACE((\"WAL%p: wal-header write %s\\n\", pWal, rc ? \"failed\" : \"ok\"));\n    if( rc!=SQLITE_OK ){\n      return rc;\n    }\n  }\n  assert( (int)pWal->szPage==szPage );\n\n  /* Write the log file. */\n  for(p=pList; p; p=p->pDirty){\n    u32 nDbsize;                  /* Db-size field for frame header */\n    i64 iOffset;                  /* Write offset in log file */\n    void *pData;\n   \n    iOffset = walFrameOffset(++iFrame, szPage);\n    /* testcase( IS_BIG_INT(iOffset) ); // requires a 4GiB WAL */\n    \n    /* Populate and write the frame header */\n    nDbsize = (isCommit && p->pDirty==0) ? nTruncate : 0;\n#if defined(SQLITE_HAS_CODEC)\n    if( (pData = sqlite3PagerCodec(p))==0 ) return SQLITE_NOMEM;\n#else\n    pData = p->pData;\n#endif\n    walEncodeFrame(pWal, p->pgno, nDbsize, pData, aFrame);\n    rc = sqlite3OsWrite(pWal->pWalFd, aFrame, sizeof(aFrame), iOffset);\n    if( rc!=SQLITE_OK ){\n      return rc;\n    }\n\n    /* Write the page data */\n    rc = sqlite3OsWrite(pWal->pWalFd, pData, szPage, iOffset+sizeof(aFrame));\n    if( rc!=SQLITE_OK ){\n      return rc;\n    }\n    pLast = p;\n  }\n\n  /* Sync the log file if the 'isSync' flag was specified. */\n  if( sync_flags ){\n    i64 iSegment = sqlite3OsSectorSize(pWal->pWalFd);\n    i64 iOffset = walFrameOffset(iFrame+1, szPage);\n\n    assert( isCommit );\n    assert( iSegment>0 );\n\n    iSegment = (((iOffset+iSegment-1)/iSegment) * iSegment);\n    while( iOffset<iSegment ){\n      void *pData;\n#if defined(SQLITE_HAS_CODEC)\n      if( (pData = sqlite3PagerCodec(pLast))==0 ) return SQLITE_NOMEM;\n#else\n      pData = pLast->pData;\n#endif\n      walEncodeFrame(pWal, pLast->pgno, nTruncate, pData, aFrame);\n      /* testcase( IS_BIG_INT(iOffset) ); // requires a 4GiB WAL */\n      rc = sqlite3OsWrite(pWal->pWalFd, aFrame, sizeof(aFrame), iOffset);\n      if( rc!=SQLITE_OK ){\n        return rc;\n      }\n      iOffset += WAL_FRAME_HDRSIZE;\n      rc = sqlite3OsWrite(pWal->pWalFd, pData, szPage, iOffset); \n      if( rc!=SQLITE_OK ){\n        return rc;\n      }\n      nLast++;\n      iOffset += szPage;\n    }\n\n    rc = sqlite3OsSync(pWal->pWalFd, sync_flags);\n  }\n\n  /* Append data to the wal-index. It is not necessary to lock the \n  ** wal-index to do this as the SQLITE_SHM_WRITE lock held on the wal-index\n  ** guarantees that there are no other writers, and no data that may\n  ** be in use by existing readers is being overwritten.\n  */\n  iFrame = pWal->hdr.mxFrame;\n  for(p=pList; p && rc==SQLITE_OK; p=p->pDirty){\n    iFrame++;\n    rc = walIndexAppend(pWal, iFrame, p->pgno);\n  }\n  while( nLast>0 && rc==SQLITE_OK ){\n    iFrame++;\n    nLast--;\n    rc = walIndexAppend(pWal, iFrame, pLast->pgno);\n  }\n\n  if( rc==SQLITE_OK ){\n    /* Update the private copy of the header. */\n    pWal->hdr.szPage = (u16)((szPage&0xff00) | (szPage>>16));\n    testcase( szPage<=32768 );\n    testcase( szPage>=65536 );\n    pWal->hdr.mxFrame = iFrame;\n    if( isCommit ){\n      pWal->hdr.iChange++;\n      pWal->hdr.nPage = nTruncate;\n    }\n    /* If this is a commit, update the wal-index header too. */\n    if( isCommit ){\n      walIndexWriteHdr(pWal);\n      pWal->iCallback = iFrame;\n    }\n  }\n\n  WALTRACE((\"WAL%p: frame write %s\\n\", pWal, rc ? \"failed\" : \"ok\"));\n  return rc;\n}\n\n/* \n** This routine is called to implement sqlite3_wal_checkpoint() and\n** related interfaces.\n**\n** Obtain a CHECKPOINT lock and then backfill as much information as\n** we can from WAL into the database.\n**\n** If parameter xBusy is not NULL, it is a pointer to a busy-handler\n** callback. In this case this function runs a blocking checkpoint.\n*/\nSQLITE_PRIVATE int sqlite3WalCheckpoint(\n  Wal *pWal,                      /* Wal connection */\n  int eMode,                      /* PASSIVE, FULL or RESTART */\n  int (*xBusy)(void*),            /* Function to call when busy */\n  void *pBusyArg,                 /* Context argument for xBusyHandler */\n  int sync_flags,                 /* Flags to sync db file with (or 0) */\n  int nBuf,                       /* Size of temporary buffer */\n  u8 *zBuf,                       /* Temporary buffer to use */\n  int *pnLog,                     /* OUT: Number of frames in WAL */\n  int *pnCkpt                     /* OUT: Number of backfilled frames in WAL */\n){\n  int rc;                         /* Return code */\n  int isChanged = 0;              /* True if a new wal-index header is loaded */\n  int eMode2 = eMode;             /* Mode to pass to walCheckpoint() */\n\n  assert( pWal->ckptLock==0 );\n  assert( pWal->writeLock==0 );\n\n  WALTRACE((\"WAL%p: checkpoint begins\\n\", pWal));\n  rc = walLockExclusive(pWal, WAL_CKPT_LOCK, 1);\n  if( rc ){\n    /* Usually this is SQLITE_BUSY meaning that another thread or process\n    ** is already running a checkpoint, or maybe a recovery.  But it might\n    ** also be SQLITE_IOERR. */\n    return rc;\n  }\n  pWal->ckptLock = 1;\n\n  /* If this is a blocking-checkpoint, then obtain the write-lock as well\n  ** to prevent any writers from running while the checkpoint is underway.\n  ** This has to be done before the call to walIndexReadHdr() below.\n  **\n  ** If the writer lock cannot be obtained, then a passive checkpoint is\n  ** run instead. Since the checkpointer is not holding the writer lock,\n  ** there is no point in blocking waiting for any readers. Assuming no \n  ** other error occurs, this function will return SQLITE_BUSY to the caller.\n  */\n  if( eMode!=SQLITE_CHECKPOINT_PASSIVE ){\n    rc = walBusyLock(pWal, xBusy, pBusyArg, WAL_WRITE_LOCK, 1);\n    if( rc==SQLITE_OK ){\n      pWal->writeLock = 1;\n    }else if( rc==SQLITE_BUSY ){\n      eMode2 = SQLITE_CHECKPOINT_PASSIVE;\n      rc = SQLITE_OK;\n    }\n  }\n\n  /* Read the wal-index header. */\n  if( rc==SQLITE_OK ){\n    rc = walIndexReadHdr(pWal, &isChanged);\n  }\n\n  /* Copy data from the log to the database file. */\n  if( rc==SQLITE_OK ){\n    if( pWal->hdr.mxFrame && walPagesize(pWal)!=nBuf ){\n      rc = SQLITE_CORRUPT_BKPT;\n    }else{\n      rc = walCheckpoint(pWal, eMode2, xBusy, pBusyArg, sync_flags, zBuf);\n    }\n\n    /* If no error occurred, set the output variables. */\n    if( rc==SQLITE_OK || rc==SQLITE_BUSY ){\n      if( pnLog ) *pnLog = (int)pWal->hdr.mxFrame;\n      if( pnCkpt ) *pnCkpt = (int)(walCkptInfo(pWal)->nBackfill);\n    }\n  }\n\n  if( isChanged ){\n    /* If a new wal-index header was loaded before the checkpoint was \n    ** performed, then the pager-cache associated with pWal is now\n    ** out of date. So zero the cached wal-index header to ensure that\n    ** next time the pager opens a snapshot on this database it knows that\n    ** the cache needs to be reset.\n    */\n    memset(&pWal->hdr, 0, sizeof(WalIndexHdr));\n  }\n\n  /* Release the locks. */\n  sqlite3WalEndWriteTransaction(pWal);\n  walUnlockExclusive(pWal, WAL_CKPT_LOCK, 1);\n  pWal->ckptLock = 0;\n  WALTRACE((\"WAL%p: checkpoint %s\\n\", pWal, rc ? \"failed\" : \"ok\"));\n  return (rc==SQLITE_OK && eMode!=eMode2 ? SQLITE_BUSY : rc);\n}\n\n/* Return the value to pass to a sqlite3_wal_hook callback, the\n** number of frames in the WAL at the point of the last commit since\n** sqlite3WalCallback() was called.  If no commits have occurred since\n** the last call, then return 0.\n*/\nSQLITE_PRIVATE int sqlite3WalCallback(Wal *pWal){\n  u32 ret = 0;\n  if( pWal ){\n    ret = pWal->iCallback;\n    pWal->iCallback = 0;\n  }\n  return (int)ret;\n}\n\n/*\n** This function is called to change the WAL subsystem into or out\n** of locking_mode=EXCLUSIVE.\n**\n** If op is zero, then attempt to change from locking_mode=EXCLUSIVE\n** into locking_mode=NORMAL.  This means that we must acquire a lock\n** on the pWal->readLock byte.  If the WAL is already in locking_mode=NORMAL\n** or if the acquisition of the lock fails, then return 0.  If the\n** transition out of exclusive-mode is successful, return 1.  This\n** operation must occur while the pager is still holding the exclusive\n** lock on the main database file.\n**\n** If op is one, then change from locking_mode=NORMAL into \n** locking_mode=EXCLUSIVE.  This means that the pWal->readLock must\n** be released.  Return 1 if the transition is made and 0 if the\n** WAL is already in exclusive-locking mode - meaning that this\n** routine is a no-op.  The pager must already hold the exclusive lock\n** on the main database file before invoking this operation.\n**\n** If op is negative, then do a dry-run of the op==1 case but do\n** not actually change anything. The pager uses this to see if it\n** should acquire the database exclusive lock prior to invoking\n** the op==1 case.\n*/\nSQLITE_PRIVATE int sqlite3WalExclusiveMode(Wal *pWal, int op){\n  int rc;\n  assert( pWal->writeLock==0 );\n  assert( pWal->exclusiveMode!=WAL_HEAPMEMORY_MODE || op==-1 );\n\n  /* pWal->readLock is usually set, but might be -1 if there was a \n  ** prior error while attempting to acquire are read-lock. This cannot \n  ** happen if the connection is actually in exclusive mode (as no xShmLock\n  ** locks are taken in this case). Nor should the pager attempt to\n  ** upgrade to exclusive-mode following such an error.\n  */\n  assert( pWal->readLock>=0 || pWal->lockError );\n  assert( pWal->readLock>=0 || (op<=0 && pWal->exclusiveMode==0) );\n\n  if( op==0 ){\n    if( pWal->exclusiveMode ){\n      pWal->exclusiveMode = 0;\n      if( walLockShared(pWal, WAL_READ_LOCK(pWal->readLock))!=SQLITE_OK ){\n        pWal->exclusiveMode = 1;\n      }\n      rc = pWal->exclusiveMode==0;\n    }else{\n      /* Already in locking_mode=NORMAL */\n      rc = 0;\n    }\n  }else if( op>0 ){\n    assert( pWal->exclusiveMode==0 );\n    assert( pWal->readLock>=0 );\n    walUnlockShared(pWal, WAL_READ_LOCK(pWal->readLock));\n    pWal->exclusiveMode = 1;\n    rc = 1;\n  }else{\n    rc = pWal->exclusiveMode==0;\n  }\n  return rc;\n}\n\n/* \n** Return true if the argument is non-NULL and the WAL module is using\n** heap-memory for the wal-index. Otherwise, if the argument is NULL or the\n** WAL module is using shared-memory, return false. \n*/\nSQLITE_PRIVATE int sqlite3WalHeapMemory(Wal *pWal){\n  return (pWal && pWal->exclusiveMode==WAL_HEAPMEMORY_MODE );\n}\n\n#endif /* #ifndef SQLITE_OMIT_WAL */\n\n/************** End of wal.c *************************************************/\n/************** Begin file btmutex.c *****************************************/\n/*\n** 2007 August 27\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n**\n** This file contains code used to implement mutexes on Btree objects.\n** This code really belongs in btree.c.  But btree.c is getting too\n** big and we want to break it down some.  This packaged seemed like\n** a good breakout.\n*/\n/************** Include btreeInt.h in the middle of btmutex.c ****************/\n/************** Begin file btreeInt.h ****************************************/\n/*\n** 2004 April 6\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file implements a external (disk-based) database using BTrees.\n** For a detailed discussion of BTrees, refer to\n**\n**     Donald E. Knuth, THE ART OF COMPUTER PROGRAMMING, Volume 3:\n**     \"Sorting And Searching\", pages 473-480. Addison-Wesley\n**     Publishing Company, Reading, Massachusetts.\n**\n** The basic idea is that each page of the file contains N database\n** entries and N+1 pointers to subpages.\n**\n**   ----------------------------------------------------------------\n**   |  Ptr(0) | Key(0) | Ptr(1) | Key(1) | ... | Key(N-1) | Ptr(N) |\n**   ----------------------------------------------------------------\n**\n** All of the keys on the page that Ptr(0) points to have values less\n** than Key(0).  All of the keys on page Ptr(1) and its subpages have\n** values greater than Key(0) and less than Key(1).  All of the keys\n** on Ptr(N) and its subpages have values greater than Key(N-1).  And\n** so forth.\n**\n** Finding a particular key requires reading O(log(M)) pages from the \n** disk where M is the number of entries in the tree.\n**\n** In this implementation, a single file can hold one or more separate \n** BTrees.  Each BTree is identified by the index of its root page.  The\n** key and data for any entry are combined to form the \"payload\".  A\n** fixed amount of payload can be carried directly on the database\n** page.  If the payload is larger than the preset amount then surplus\n** bytes are stored on overflow pages.  The payload for an entry\n** and the preceding pointer are combined to form a \"Cell\".  Each \n** page has a small header which contains the Ptr(N) pointer and other\n** information such as the size of key and data.\n**\n** FORMAT DETAILS\n**\n** The file is divided into pages.  The first page is called page 1,\n** the second is page 2, and so forth.  A page number of zero indicates\n** \"no such page\".  The page size can be any power of 2 between 512 and 65536.\n** Each page can be either a btree page, a freelist page, an overflow\n** page, or a pointer-map page.\n**\n** The first page is always a btree page.  The first 100 bytes of the first\n** page contain a special header (the \"file header\") that describes the file.\n** The format of the file header is as follows:\n**\n**   OFFSET   SIZE    DESCRIPTION\n**      0      16     Header string: \"SQLite format 3\\000\"\n**     16       2     Page size in bytes.  \n**     18       1     File format write version\n**     19       1     File format read version\n**     20       1     Bytes of unused space at the end of each page\n**     21       1     Max embedded payload fraction\n**     22       1     Min embedded payload fraction\n**     23       1     Min leaf payload fraction\n**     24       4     File change counter\n**     28       4     Reserved for future use\n**     32       4     First freelist page\n**     36       4     Number of freelist pages in the file\n**     40      60     15 4-byte meta values passed to higher layers\n**\n**     40       4     Schema cookie\n**     44       4     File format of schema layer\n**     48       4     Size of page cache\n**     52       4     Largest root-page (auto/incr_vacuum)\n**     56       4     1=UTF-8 2=UTF16le 3=UTF16be\n**     60       4     User version\n**     64       4     Incremental vacuum mode\n**     68       4     unused\n**     72       4     unused\n**     76       4     unused\n**\n** All of the integer values are big-endian (most significant byte first).\n**\n** The file change counter is incremented when the database is changed\n** This counter allows other processes to know when the file has changed\n** and thus when they need to flush their cache.\n**\n** The max embedded payload fraction is the amount of the total usable\n** space in a page that can be consumed by a single cell for standard\n** B-tree (non-LEAFDATA) tables.  A value of 255 means 100%.  The default\n** is to limit the maximum cell size so that at least 4 cells will fit\n** on one page.  Thus the default max embedded payload fraction is 64.\n**\n** If the payload for a cell is larger than the max payload, then extra\n** payload is spilled to overflow pages.  Once an overflow page is allocated,\n** as many bytes as possible are moved into the overflow pages without letting\n** the cell size drop below the min embedded payload fraction.\n**\n** The min leaf payload fraction is like the min embedded payload fraction\n** except that it applies to leaf nodes in a LEAFDATA tree.  The maximum\n** payload fraction for a LEAFDATA tree is always 100% (or 255) and it\n** not specified in the header.\n**\n** Each btree pages is divided into three sections:  The header, the\n** cell pointer array, and the cell content area.  Page 1 also has a 100-byte\n** file header that occurs before the page header.\n**\n**      |----------------|\n**      | file header    |   100 bytes.  Page 1 only.\n**      |----------------|\n**      | page header    |   8 bytes for leaves.  12 bytes for interior nodes\n**      |----------------|\n**      | cell pointer   |   |  2 bytes per cell.  Sorted order.\n**      | array          |   |  Grows downward\n**      |                |   v\n**      |----------------|\n**      | unallocated    |\n**      | space          |\n**      |----------------|   ^  Grows upwards\n**      | cell content   |   |  Arbitrary order interspersed with freeblocks.\n**      | area           |   |  and free space fragments.\n**      |----------------|\n**\n** The page headers looks like this:\n**\n**   OFFSET   SIZE     DESCRIPTION\n**      0       1      Flags. 1: intkey, 2: zerodata, 4: leafdata, 8: leaf\n**      1       2      byte offset to the first freeblock\n**      3       2      number of cells on this page\n**      5       2      first byte of the cell content area\n**      7       1      number of fragmented free bytes\n**      8       4      Right child (the Ptr(N) value).  Omitted on leaves.\n**\n** The flags define the format of this btree page.  The leaf flag means that\n** this page has no children.  The zerodata flag means that this page carries\n** only keys and no data.  The intkey flag means that the key is a integer\n** which is stored in the key size entry of the cell header rather than in\n** the payload area.\n**\n** The cell pointer array begins on the first byte after the page header.\n** The cell pointer array contains zero or more 2-byte numbers which are\n** offsets from the beginning of the page to the cell content in the cell\n** content area.  The cell pointers occur in sorted order.  The system strives\n** to keep free space after the last cell pointer so that new cells can\n** be easily added without having to defragment the page.\n**\n** Cell content is stored at the very end of the page and grows toward the\n** beginning of the page.\n**\n** Unused space within the cell content area is collected into a linked list of\n** freeblocks.  Each freeblock is at least 4 bytes in size.  The byte offset\n** to the first freeblock is given in the header.  Freeblocks occur in\n** increasing order.  Because a freeblock must be at least 4 bytes in size,\n** any group of 3 or fewer unused bytes in the cell content area cannot\n** exist on the freeblock chain.  A group of 3 or fewer free bytes is called\n** a fragment.  The total number of bytes in all fragments is recorded.\n** in the page header at offset 7.\n**\n**    SIZE    DESCRIPTION\n**      2     Byte offset of the next freeblock\n**      2     Bytes in this freeblock\n**\n** Cells are of variable length.  Cells are stored in the cell content area at\n** the end of the page.  Pointers to the cells are in the cell pointer array\n** that immediately follows the page header.  Cells is not necessarily\n** contiguous or in order, but cell pointers are contiguous and in order.\n**\n** Cell content makes use of variable length integers.  A variable\n** length integer is 1 to 9 bytes where the lower 7 bits of each \n** byte are used.  The integer consists of all bytes that have bit 8 set and\n** the first byte with bit 8 clear.  The most significant byte of the integer\n** appears first.  A variable-length integer may not be more than 9 bytes long.\n** As a special case, all 8 bytes of the 9th byte are used as data.  This\n** allows a 64-bit integer to be encoded in 9 bytes.\n**\n**    0x00                      becomes  0x00000000\n**    0x7f                      becomes  0x0000007f\n**    0x81 0x00                 becomes  0x00000080\n**    0x82 0x00                 becomes  0x00000100\n**    0x80 0x7f                 becomes  0x0000007f\n**    0x8a 0x91 0xd1 0xac 0x78  becomes  0x12345678\n**    0x81 0x81 0x81 0x81 0x01  becomes  0x10204081\n**\n** Variable length integers are used for rowids and to hold the number of\n** bytes of key and data in a btree cell.\n**\n** The content of a cell looks like this:\n**\n**    SIZE    DESCRIPTION\n**      4     Page number of the left child. Omitted if leaf flag is set.\n**     var    Number of bytes of data. Omitted if the zerodata flag is set.\n**     var    Number of bytes of key. Or the key itself if intkey flag is set.\n**      *     Payload\n**      4     First page of the overflow chain.  Omitted if no overflow\n**\n** Overflow pages form a linked list.  Each page except the last is completely\n** filled with data (pagesize - 4 bytes).  The last page can have as little\n** as 1 byte of data.\n**\n**    SIZE    DESCRIPTION\n**      4     Page number of next overflow page\n**      *     Data\n**\n** Freelist pages come in two subtypes: trunk pages and leaf pages.  The\n** file header points to the first in a linked list of trunk page.  Each trunk\n** page points to multiple leaf pages.  The content of a leaf page is\n** unspecified.  A trunk page looks like this:\n**\n**    SIZE    DESCRIPTION\n**      4     Page number of next trunk page\n**      4     Number of leaf pointers on this page\n**      *     zero or more pages numbers of leaves\n*/\n\n\n/* The following value is the maximum cell size assuming a maximum page\n** size give above.\n*/\n#define MX_CELL_SIZE(pBt)  (pBt->pageSize-8)\n\n/* The maximum number of cells on a single page of the database.  This\n** assumes a minimum cell size of 6 bytes  (4 bytes for the cell itself\n** plus 2 bytes for the index to the cell in the page header).  Such\n** small cells will be rare, but they are possible.\n*/\n#define MX_CELL(pBt) ((pBt->pageSize-8)/6)\n\n/* Forward declarations */\ntypedef struct MemPage MemPage;\ntypedef struct BtLock BtLock;\n\n/*\n** This is a magic string that appears at the beginning of every\n** SQLite database in order to identify the file as a real database.\n**\n** You can change this value at compile-time by specifying a\n** -DSQLITE_FILE_HEADER=\"...\" on the compiler command-line.  The\n** header must be exactly 16 bytes including the zero-terminator so\n** the string itself should be 15 characters long.  If you change\n** the header, then your custom library will not be able to read \n** databases generated by the standard tools and the standard tools\n** will not be able to read databases created by your custom library.\n*/\n#ifndef SQLITE_FILE_HEADER /* 123456789 123456 */\n#  define SQLITE_FILE_HEADER \"SQLite format 3\"\n#endif\n\n/*\n** Page type flags.  An ORed combination of these flags appear as the\n** first byte of on-disk image of every BTree page.\n*/\n#define PTF_INTKEY    0x01\n#define PTF_ZERODATA  0x02\n#define PTF_LEAFDATA  0x04\n#define PTF_LEAF      0x08\n\n/*\n** As each page of the file is loaded into memory, an instance of the following\n** structure is appended and initialized to zero.  This structure stores\n** information about the page that is decoded from the raw file page.\n**\n** The pParent field points back to the parent page.  This allows us to\n** walk up the BTree from any leaf to the root.  Care must be taken to\n** unref() the parent page pointer when this page is no longer referenced.\n** The pageDestructor() routine handles that chore.\n**\n** Access to all fields of this structure is controlled by the mutex\n** stored in MemPage.pBt->mutex.\n*/\nstruct MemPage {\n  u8 isInit;           /* True if previously initialized. MUST BE FIRST! */\n  u8 nOverflow;        /* Number of overflow cell bodies in aCell[] */\n  u8 intKey;           /* True if intkey flag is set */\n  u8 leaf;             /* True if leaf flag is set */\n  u8 hasData;          /* True if this page stores data */\n  u8 hdrOffset;        /* 100 for page 1.  0 otherwise */\n  u8 childPtrSize;     /* 0 if leaf==1.  4 if leaf==0 */\n  u16 maxLocal;        /* Copy of BtShared.maxLocal or BtShared.maxLeaf */\n  u16 minLocal;        /* Copy of BtShared.minLocal or BtShared.minLeaf */\n  u16 cellOffset;      /* Index in aData of first cell pointer */\n  u16 nFree;           /* Number of free bytes on the page */\n  u16 nCell;           /* Number of cells on this page, local and ovfl */\n  u16 maskPage;        /* Mask for page offset */\n  struct _OvflCell {   /* Cells that will not fit on aData[] */\n    u8 *pCell;          /* Pointers to the body of the overflow cell */\n    u16 idx;            /* Insert this cell before idx-th non-overflow cell */\n  } aOvfl[5];\n  BtShared *pBt;       /* Pointer to BtShared that this page is part of */\n  u8 *aData;           /* Pointer to disk image of the page data */\n  DbPage *pDbPage;     /* Pager page handle */\n  Pgno pgno;           /* Page number for this page */\n};\n\n/*\n** The in-memory image of a disk page has the auxiliary information appended\n** to the end.  EXTRA_SIZE is the number of bytes of space needed to hold\n** that extra information.\n*/\n#define EXTRA_SIZE sizeof(MemPage)\n\n/*\n** A linked list of the following structures is stored at BtShared.pLock.\n** Locks are added (or upgraded from READ_LOCK to WRITE_LOCK) when a cursor \n** is opened on the table with root page BtShared.iTable. Locks are removed\n** from this list when a transaction is committed or rolled back, or when\n** a btree handle is closed.\n*/\nstruct BtLock {\n  Btree *pBtree;        /* Btree handle holding this lock */\n  Pgno iTable;          /* Root page of table */\n  u8 eLock;             /* READ_LOCK or WRITE_LOCK */\n  BtLock *pNext;        /* Next in BtShared.pLock list */\n};\n\n/* Candidate values for BtLock.eLock */\n#define READ_LOCK     1\n#define WRITE_LOCK    2\n\n/* A Btree handle\n**\n** A database connection contains a pointer to an instance of\n** this object for every database file that it has open.  This structure\n** is opaque to the database connection.  The database connection cannot\n** see the internals of this structure and only deals with pointers to\n** this structure.\n**\n** For some database files, the same underlying database cache might be \n** shared between multiple connections.  In that case, each connection\n** has it own instance of this object.  But each instance of this object\n** points to the same BtShared object.  The database cache and the\n** schema associated with the database file are all contained within\n** the BtShared object.\n**\n** All fields in this structure are accessed under sqlite3.mutex.\n** The pBt pointer itself may not be changed while there exists cursors \n** in the referenced BtShared that point back to this Btree since those\n** cursors have to do go through this Btree to find their BtShared and\n** they often do so without holding sqlite3.mutex.\n*/\nstruct Btree {\n  sqlite3 *db;       /* The database connection holding this btree */\n  BtShared *pBt;     /* Sharable content of this btree */\n  u8 inTrans;        /* TRANS_NONE, TRANS_READ or TRANS_WRITE */\n  u8 sharable;       /* True if we can share pBt with another db */\n  u8 locked;         /* True if db currently has pBt locked */\n  int wantToLock;    /* Number of nested calls to sqlite3BtreeEnter() */\n  int nBackup;       /* Number of backup operations reading this btree */\n  Btree *pNext;      /* List of other sharable Btrees from the same db */\n  Btree *pPrev;      /* Back pointer of the same list */\n#ifndef SQLITE_OMIT_SHARED_CACHE\n  BtLock lock;       /* Object used to lock page 1 */\n#endif\n};\n\n/*\n** Btree.inTrans may take one of the following values.\n**\n** If the shared-data extension is enabled, there may be multiple users\n** of the Btree structure. At most one of these may open a write transaction,\n** but any number may have active read transactions.\n*/\n#define TRANS_NONE  0\n#define TRANS_READ  1\n#define TRANS_WRITE 2\n\n/*\n** An instance of this object represents a single database file.\n** \n** A single database file can be in use as the same time by two\n** or more database connections.  When two or more connections are\n** sharing the same database file, each connection has it own\n** private Btree object for the file and each of those Btrees points\n** to this one BtShared object.  BtShared.nRef is the number of\n** connections currently sharing this database file.\n**\n** Fields in this structure are accessed under the BtShared.mutex\n** mutex, except for nRef and pNext which are accessed under the\n** global SQLITE_MUTEX_STATIC_MASTER mutex.  The pPager field\n** may not be modified once it is initially set as long as nRef>0.\n** The pSchema field may be set once under BtShared.mutex and\n** thereafter is unchanged as long as nRef>0.\n**\n** isPending:\n**\n**   If a BtShared client fails to obtain a write-lock on a database\n**   table (because there exists one or more read-locks on the table),\n**   the shared-cache enters 'pending-lock' state and isPending is\n**   set to true.\n**\n**   The shared-cache leaves the 'pending lock' state when either of\n**   the following occur:\n**\n**     1) The current writer (BtShared.pWriter) concludes its transaction, OR\n**     2) The number of locks held by other connections drops to zero.\n**\n**   while in the 'pending-lock' state, no connection may start a new\n**   transaction.\n**\n**   This feature is included to help prevent writer-starvation.\n*/\nstruct BtShared {\n  Pager *pPager;        /* The page cache */\n  sqlite3 *db;          /* Database connection currently using this Btree */\n  BtCursor *pCursor;    /* A list of all open cursors */\n  MemPage *pPage1;      /* First page of the database */\n  u8 readOnly;          /* True if the underlying file is readonly */\n  u8 pageSizeFixed;     /* True if the page size can no longer be changed */\n  u8 secureDelete;      /* True if secure_delete is enabled */\n  u8 initiallyEmpty;    /* Database is empty at start of transaction */\n  u8 openFlags;         /* Flags to sqlite3BtreeOpen() */\n#ifndef SQLITE_OMIT_AUTOVACUUM\n  u8 autoVacuum;        /* True if auto-vacuum is enabled */\n  u8 incrVacuum;        /* True if incr-vacuum is enabled */\n#endif\n  u8 inTransaction;     /* Transaction state */\n  u8 doNotUseWAL;       /* If true, do not open write-ahead-log file */\n  u16 maxLocal;         /* Maximum local payload in non-LEAFDATA tables */\n  u16 minLocal;         /* Minimum local payload in non-LEAFDATA tables */\n  u16 maxLeaf;          /* Maximum local payload in a LEAFDATA table */\n  u16 minLeaf;          /* Minimum local payload in a LEAFDATA table */\n  u32 pageSize;         /* Total number of bytes on a page */\n  u32 usableSize;       /* Number of usable bytes on each page */\n  int nTransaction;     /* Number of open transactions (read + write) */\n  u32 nPage;            /* Number of pages in the database */\n  void *pSchema;        /* Pointer to space allocated by sqlite3BtreeSchema() */\n  void (*xFreeSchema)(void*);  /* Destructor for BtShared.pSchema */\n  sqlite3_mutex *mutex; /* Non-recursive mutex required to access this struct */\n  Bitvec *pHasContent;  /* Set of pages moved to free-list this transaction */\n#ifndef SQLITE_OMIT_SHARED_CACHE\n  int nRef;             /* Number of references to this structure */\n  BtShared *pNext;      /* Next on a list of sharable BtShared structs */\n  BtLock *pLock;        /* List of locks held on this shared-btree struct */\n  Btree *pWriter;       /* Btree with currently open write transaction */\n  u8 isExclusive;       /* True if pWriter has an EXCLUSIVE lock on the db */\n  u8 isPending;         /* If waiting for read-locks to clear */\n#endif\n  u8 *pTmpSpace;        /* BtShared.pageSize bytes of space for tmp use */\n};\n\n/*\n** An instance of the following structure is used to hold information\n** about a cell.  The parseCellPtr() function fills in this structure\n** based on information extract from the raw disk page.\n*/\ntypedef struct CellInfo CellInfo;\nstruct CellInfo {\n  i64 nKey;      /* The key for INTKEY tables, or number of bytes in key */\n  u8 *pCell;     /* Pointer to the start of cell content */\n  u32 nData;     /* Number of bytes of data */\n  u32 nPayload;  /* Total amount of payload */\n  u16 nHeader;   /* Size of the cell content header in bytes */\n  u16 nLocal;    /* Amount of payload held locally */\n  u16 iOverflow; /* Offset to overflow page number.  Zero if no overflow */\n  u16 nSize;     /* Size of the cell content on the main b-tree page */\n};\n\n/*\n** Maximum depth of an SQLite B-Tree structure. Any B-Tree deeper than\n** this will be declared corrupt. This value is calculated based on a\n** maximum database size of 2^31 pages a minimum fanout of 2 for a\n** root-node and 3 for all other internal nodes.\n**\n** If a tree that appears to be taller than this is encountered, it is\n** assumed that the database is corrupt.\n*/\n#define BTCURSOR_MAX_DEPTH 20\n\n/*\n** A cursor is a pointer to a particular entry within a particular\n** b-tree within a database file.\n**\n** The entry is identified by its MemPage and the index in\n** MemPage.aCell[] of the entry.\n**\n** A single database file can shared by two more database connections,\n** but cursors cannot be shared.  Each cursor is associated with a\n** particular database connection identified BtCursor.pBtree.db.\n**\n** Fields in this structure are accessed under the BtShared.mutex\n** found at self->pBt->mutex. \n*/\nstruct BtCursor {\n  Btree *pBtree;            /* The Btree to which this cursor belongs */\n  BtShared *pBt;            /* The BtShared this cursor points to */\n  BtCursor *pNext, *pPrev;  /* Forms a linked list of all cursors */\n  struct KeyInfo *pKeyInfo; /* Argument passed to comparison function */\n  Pgno pgnoRoot;            /* The root page of this tree */\n  sqlite3_int64 cachedRowid; /* Next rowid cache.  0 means not valid */\n  CellInfo info;            /* A parse of the cell we are pointing at */\n  i64 nKey;        /* Size of pKey, or last integer key */\n  void *pKey;      /* Saved key that was cursor's last known position */\n  int skipNext;    /* Prev() is noop if negative. Next() is noop if positive */\n  u8 wrFlag;                /* True if writable */\n  u8 atLast;                /* Cursor pointing to the last entry */\n  u8 validNKey;             /* True if info.nKey is valid */\n  u8 eState;                /* One of the CURSOR_XXX constants (see below) */\n#ifndef SQLITE_OMIT_INCRBLOB\n  Pgno *aOverflow;          /* Cache of overflow page locations */\n  u8 isIncrblobHandle;      /* True if this cursor is an incr. io handle */\n#endif\n  i16 iPage;                            /* Index of current page in apPage */\n  u16 aiIdx[BTCURSOR_MAX_DEPTH];        /* Current index in apPage[i] */\n  MemPage *apPage[BTCURSOR_MAX_DEPTH];  /* Pages from root to current page */\n};\n\n/*\n** Potential values for BtCursor.eState.\n**\n** CURSOR_VALID:\n**   Cursor points to a valid entry. getPayload() etc. may be called.\n**\n** CURSOR_INVALID:\n**   Cursor does not point to a valid entry. This can happen (for example) \n**   because the table is empty or because BtreeCursorFirst() has not been\n**   called.\n**\n** CURSOR_REQUIRESEEK:\n**   The table that this cursor was opened on still exists, but has been \n**   modified since the cursor was last used. The cursor position is saved\n**   in variables BtCursor.pKey and BtCursor.nKey. When a cursor is in \n**   this state, restoreCursorPosition() can be called to attempt to\n**   seek the cursor to the saved position.\n**\n** CURSOR_FAULT:\n**   A unrecoverable error (an I/O error or a malloc failure) has occurred\n**   on a different connection that shares the BtShared cache with this\n**   cursor.  The error has left the cache in an inconsistent state.\n**   Do nothing else with this cursor.  Any attempt to use the cursor\n**   should return the error code stored in BtCursor.skip\n*/\n#define CURSOR_INVALID           0\n#define CURSOR_VALID             1\n#define CURSOR_REQUIRESEEK       2\n#define CURSOR_FAULT             3\n\n/* \n** The database page the PENDING_BYTE occupies. This page is never used.\n*/\n# define PENDING_BYTE_PAGE(pBt) PAGER_MJ_PGNO(pBt)\n\n/*\n** These macros define the location of the pointer-map entry for a \n** database page. The first argument to each is the number of usable\n** bytes on each page of the database (often 1024). The second is the\n** page number to look up in the pointer map.\n**\n** PTRMAP_PAGENO returns the database page number of the pointer-map\n** page that stores the required pointer. PTRMAP_PTROFFSET returns\n** the offset of the requested map entry.\n**\n** If the pgno argument passed to PTRMAP_PAGENO is a pointer-map page,\n** then pgno is returned. So (pgno==PTRMAP_PAGENO(pgsz, pgno)) can be\n** used to test if pgno is a pointer-map page. PTRMAP_ISPAGE implements\n** this test.\n*/\n#define PTRMAP_PAGENO(pBt, pgno) ptrmapPageno(pBt, pgno)\n#define PTRMAP_PTROFFSET(pgptrmap, pgno) (5*(pgno-pgptrmap-1))\n#define PTRMAP_ISPAGE(pBt, pgno) (PTRMAP_PAGENO((pBt),(pgno))==(pgno))\n\n/*\n** The pointer map is a lookup table that identifies the parent page for\n** each child page in the database file.  The parent page is the page that\n** contains a pointer to the child.  Every page in the database contains\n** 0 or 1 parent pages.  (In this context 'database page' refers\n** to any page that is not part of the pointer map itself.)  Each pointer map\n** entry consists of a single byte 'type' and a 4 byte parent page number.\n** The PTRMAP_XXX identifiers below are the valid types.\n**\n** The purpose of the pointer map is to facility moving pages from one\n** position in the file to another as part of autovacuum.  When a page\n** is moved, the pointer in its parent must be updated to point to the\n** new location.  The pointer map is used to locate the parent page quickly.\n**\n** PTRMAP_ROOTPAGE: The database page is a root-page. The page-number is not\n**                  used in this case.\n**\n** PTRMAP_FREEPAGE: The database page is an unused (free) page. The page-number \n**                  is a reference to the previous trunk page if this page\n**                  is a trunk, or zero if the page is the first trunk, \n**                  EXCEPT that in legacy databases it may be zero instead.\n**\n** PTRMAP_OVERFLOW1: The database page is the first page in a list of \n**                   overflow pages. The page number identifies the page that\n**                   contains the cell with a pointer to this overflow page.\n**\n** PTRMAP_OVERFLOW2: The database page is the second or later page in a list of\n**                   overflow pages. The page-number identifies the previous\n**                   page in the overflow page list.\n**\n** PTRMAP_BTREE: The database page is a non-root btree page. The page number\n**               identifies the parent page in the btree.\n**\n** PTRMAP_FREELEAF: A database page that is completely unused. The page number\n**                  is unused.\n*/\n#define PTRMAP_ROOTPAGE 1\n#define PTRMAP_FREEPAGE 2\n#define PTRMAP_OVERFLOW1 3\n#define PTRMAP_OVERFLOW2 4\n#define PTRMAP_BTREE 5\n#define PTRMAP_FREELEAF 6\n\n/* A bunch of assert() statements to check the transaction state variables\n** of handle p (type Btree*) are internally consistent.\n*/\n#define btreeIntegrity(p) \\\n  assert( p->pBt->inTransaction!=TRANS_NONE || p->pBt->nTransaction==0 ); \\\n  assert( p->pBt->inTransaction>=p->inTrans ); \n\n\n/*\n** The ISAUTOVACUUM macro is used within balance_nonroot() to determine\n** if the database supports auto-vacuum or not. Because it is used\n** within an expression that is an argument to another macro \n** (sqliteMallocRaw), it is not possible to use conditional compilation.\n** So, this macro is defined instead.\n*/\n#ifndef SQLITE_OMIT_AUTOVACUUM\n#define ISAUTOVACUUM (pBt->autoVacuum)\n#else\n#define ISAUTOVACUUM 0\n#endif\n\n\n/*\n** This structure is passed around through all the sanity checking routines\n** in order to keep track of some global state information.\n*/\ntypedef struct IntegrityCk IntegrityCk;\nstruct IntegrityCk {\n  BtShared *pBt;    /* The tree being checked out */\n  Pager *pPager;    /* The associated pager.  Also accessible by pBt->pPager */\n  Pgno nPage;       /* Number of pages in the database */\n  int *anRef;       /* Number of times each page is referenced */\n  int mxErr;        /* Stop accumulating errors when this reaches zero */\n  int nErr;         /* Number of messages written to zErrMsg so far */\n  int mallocFailed; /* A memory allocation error has occurred */\n  StrAccum errMsg;  /* Accumulate the error message text here */\n};\n\n/*\n** Read or write a two- and four-byte big-endian integer values.\n*/\n#define get2byte(x)   ((x)[0]<<8 | (x)[1])\n#define put2byte(p,v) ((p)[0] = (u8)((v)>>8), (p)[1] = (u8)(v))\n#define get4byte sqlite3Get4byte\n#define put4byte sqlite3Put4byte\n\n/************** End of btreeInt.h ********************************************/\n/************** Continuing where we left off in btmutex.c ********************/\n#ifndef SQLITE_OMIT_SHARED_CACHE\n#if SQLITE_THREADSAFE\n\n/*\n** Obtain the BtShared mutex associated with B-Tree handle p. Also,\n** set BtShared.db to the database handle associated with p and the\n** p->locked boolean to true.\n*/\nstatic void lockBtreeMutex(Btree *p){\n  assert( p->locked==0 );\n  assert( sqlite3_mutex_notheld(p->pBt->mutex) );\n  assert( sqlite3_mutex_held(p->db->mutex) );\n\n  sqlite3_mutex_enter(p->pBt->mutex);\n  p->pBt->db = p->db;\n  p->locked = 1;\n}\n\n/*\n** Release the BtShared mutex associated with B-Tree handle p and\n** clear the p->locked boolean.\n*/\nstatic void unlockBtreeMutex(Btree *p){\n  assert( p->locked==1 );\n  assert( sqlite3_mutex_held(p->pBt->mutex) );\n  assert( sqlite3_mutex_held(p->db->mutex) );\n  assert( p->db==p->pBt->db );\n\n  sqlite3_mutex_leave(p->pBt->mutex);\n  p->locked = 0;\n}\n\n/*\n** Enter a mutex on the given BTree object.\n**\n** If the object is not sharable, then no mutex is ever required\n** and this routine is a no-op.  The underlying mutex is non-recursive.\n** But we keep a reference count in Btree.wantToLock so the behavior\n** of this interface is recursive.\n**\n** To avoid deadlocks, multiple Btrees are locked in the same order\n** by all database connections.  The p->pNext is a list of other\n** Btrees belonging to the same database connection as the p Btree\n** which need to be locked after p.  If we cannot get a lock on\n** p, then first unlock all of the others on p->pNext, then wait\n** for the lock to become available on p, then relock all of the\n** subsequent Btrees that desire a lock.\n*/\nSQLITE_PRIVATE void sqlite3BtreeEnter(Btree *p){\n  Btree *pLater;\n\n  /* Some basic sanity checking on the Btree.  The list of Btrees\n  ** connected by pNext and pPrev should be in sorted order by\n  ** Btree.pBt value. All elements of the list should belong to\n  ** the same connection. Only shared Btrees are on the list. */\n  assert( p->pNext==0 || p->pNext->pBt>p->pBt );\n  assert( p->pPrev==0 || p->pPrev->pBt<p->pBt );\n  assert( p->pNext==0 || p->pNext->db==p->db );\n  assert( p->pPrev==0 || p->pPrev->db==p->db );\n  assert( p->sharable || (p->pNext==0 && p->pPrev==0) );\n\n  /* Check for locking consistency */\n  assert( !p->locked || p->wantToLock>0 );\n  assert( p->sharable || p->wantToLock==0 );\n\n  /* We should already hold a lock on the database connection */\n  assert( sqlite3_mutex_held(p->db->mutex) );\n\n  /* Unless the database is sharable and unlocked, then BtShared.db\n  ** should already be set correctly. */\n  assert( (p->locked==0 && p->sharable) || p->pBt->db==p->db );\n\n  if( !p->sharable ) return;\n  p->wantToLock++;\n  if( p->locked ) return;\n\n  /* In most cases, we should be able to acquire the lock we\n  ** want without having to go throught the ascending lock\n  ** procedure that follows.  Just be sure not to block.\n  */\n  if( sqlite3_mutex_try(p->pBt->mutex)==SQLITE_OK ){\n    p->pBt->db = p->db;\n    p->locked = 1;\n    return;\n  }\n\n  /* To avoid deadlock, first release all locks with a larger\n  ** BtShared address.  Then acquire our lock.  Then reacquire\n  ** the other BtShared locks that we used to hold in ascending\n  ** order.\n  */\n  for(pLater=p->pNext; pLater; pLater=pLater->pNext){\n    assert( pLater->sharable );\n    assert( pLater->pNext==0 || pLater->pNext->pBt>pLater->pBt );\n    assert( !pLater->locked || pLater->wantToLock>0 );\n    if( pLater->locked ){\n      unlockBtreeMutex(pLater);\n    }\n  }\n  lockBtreeMutex(p);\n  for(pLater=p->pNext; pLater; pLater=pLater->pNext){\n    if( pLater->wantToLock ){\n      lockBtreeMutex(pLater);\n    }\n  }\n}\n\n/*\n** Exit the recursive mutex on a Btree.\n*/\nSQLITE_PRIVATE void sqlite3BtreeLeave(Btree *p){\n  if( p->sharable ){\n    assert( p->wantToLock>0 );\n    p->wantToLock--;\n    if( p->wantToLock==0 ){\n      unlockBtreeMutex(p);\n    }\n  }\n}\n\n#ifndef NDEBUG\n/*\n** Return true if the BtShared mutex is held on the btree, or if the\n** B-Tree is not marked as sharable.\n**\n** This routine is used only from within assert() statements.\n*/\nSQLITE_PRIVATE int sqlite3BtreeHoldsMutex(Btree *p){\n  assert( p->sharable==0 || p->locked==0 || p->wantToLock>0 );\n  assert( p->sharable==0 || p->locked==0 || p->db==p->pBt->db );\n  assert( p->sharable==0 || p->locked==0 || sqlite3_mutex_held(p->pBt->mutex) );\n  assert( p->sharable==0 || p->locked==0 || sqlite3_mutex_held(p->db->mutex) );\n\n  return (p->sharable==0 || p->locked);\n}\n#endif\n\n\n#ifndef SQLITE_OMIT_INCRBLOB\n/*\n** Enter and leave a mutex on a Btree given a cursor owned by that\n** Btree.  These entry points are used by incremental I/O and can be\n** omitted if that module is not used.\n*/\nSQLITE_PRIVATE void sqlite3BtreeEnterCursor(BtCursor *pCur){\n  sqlite3BtreeEnter(pCur->pBtree);\n}\nSQLITE_PRIVATE void sqlite3BtreeLeaveCursor(BtCursor *pCur){\n  sqlite3BtreeLeave(pCur->pBtree);\n}\n#endif /* SQLITE_OMIT_INCRBLOB */\n\n\n/*\n** Enter the mutex on every Btree associated with a database\n** connection.  This is needed (for example) prior to parsing\n** a statement since we will be comparing table and column names\n** against all schemas and we do not want those schemas being\n** reset out from under us.\n**\n** There is a corresponding leave-all procedures.\n**\n** Enter the mutexes in accending order by BtShared pointer address\n** to avoid the possibility of deadlock when two threads with\n** two or more btrees in common both try to lock all their btrees\n** at the same instant.\n*/\nSQLITE_PRIVATE void sqlite3BtreeEnterAll(sqlite3 *db){\n  int i;\n  Btree *p, *pLater;\n  assert( sqlite3_mutex_held(db->mutex) );\n  for(i=0; i<db->nDb; i++){\n    p = db->aDb[i].pBt;\n    assert( !p || (p->locked==0 && p->sharable) || p->pBt->db==p->db );\n    if( p && p->sharable ){\n      p->wantToLock++;\n      if( !p->locked ){\n        assert( p->wantToLock==1 );\n        while( p->pPrev ) p = p->pPrev;\n        /* Reason for ALWAYS:  There must be at least on unlocked Btree in\n        ** the chain.  Otherwise the !p->locked test above would have failed */\n        while( p->locked && ALWAYS(p->pNext) ) p = p->pNext;\n        for(pLater = p->pNext; pLater; pLater=pLater->pNext){\n          if( pLater->locked ){\n            unlockBtreeMutex(pLater);\n          }\n        }\n        while( p ){\n          lockBtreeMutex(p);\n          p = p->pNext;\n        }\n      }\n    }\n  }\n}\nSQLITE_PRIVATE void sqlite3BtreeLeaveAll(sqlite3 *db){\n  int i;\n  Btree *p;\n  assert( sqlite3_mutex_held(db->mutex) );\n  for(i=0; i<db->nDb; i++){\n    p = db->aDb[i].pBt;\n    if( p && p->sharable ){\n      assert( p->wantToLock>0 );\n      p->wantToLock--;\n      if( p->wantToLock==0 ){\n        unlockBtreeMutex(p);\n      }\n    }\n  }\n}\n\n#ifndef NDEBUG\n/*\n** Return true if the current thread holds the database connection\n** mutex and all required BtShared mutexes.\n**\n** This routine is used inside assert() statements only.\n*/\nSQLITE_PRIVATE int sqlite3BtreeHoldsAllMutexes(sqlite3 *db){\n  int i;\n  if( !sqlite3_mutex_held(db->mutex) ){\n    return 0;\n  }\n  for(i=0; i<db->nDb; i++){\n    Btree *p;\n    p = db->aDb[i].pBt;\n    if( p && p->sharable &&\n         (p->wantToLock==0 || !sqlite3_mutex_held(p->pBt->mutex)) ){\n      return 0;\n    }\n  }\n  return 1;\n}\n#endif /* NDEBUG */\n\n/*\n** Add a new Btree pointer to a BtreeMutexArray. \n** if the pointer can possibly be shared with\n** another database connection.\n**\n** The pointers are kept in sorted order by pBtree->pBt.  That\n** way when we go to enter all the mutexes, we can enter them\n** in order without every having to backup and retry and without\n** worrying about deadlock.\n**\n** The number of shared btrees will always be small (usually 0 or 1)\n** so an insertion sort is an adequate algorithm here.\n*/\nSQLITE_PRIVATE void sqlite3BtreeMutexArrayInsert(BtreeMutexArray *pArray, Btree *pBtree){\n  int i, j;\n  BtShared *pBt;\n  if( pBtree==0 || pBtree->sharable==0 ) return;\n#ifndef NDEBUG\n  {\n    for(i=0; i<pArray->nMutex; i++){\n      assert( pArray->aBtree[i]!=pBtree );\n    }\n  }\n#endif\n  assert( pArray->nMutex>=0 );\n  assert( pArray->nMutex<ArraySize(pArray->aBtree)-1 );\n  pBt = pBtree->pBt;\n  for(i=0; i<pArray->nMutex; i++){\n    assert( pArray->aBtree[i]!=pBtree );\n    if( pArray->aBtree[i]->pBt>pBt ){\n      for(j=pArray->nMutex; j>i; j--){\n        pArray->aBtree[j] = pArray->aBtree[j-1];\n      }\n      pArray->aBtree[i] = pBtree;\n      pArray->nMutex++;\n      return;\n    }\n  }\n  pArray->aBtree[pArray->nMutex++] = pBtree;\n}\n\n/*\n** Enter the mutex of every btree in the array.  This routine is\n** called at the beginning of sqlite3VdbeExec().  The mutexes are\n** exited at the end of the same function.\n*/\nSQLITE_PRIVATE void sqlite3BtreeMutexArrayEnter(BtreeMutexArray *pArray){\n  int i;\n  for(i=0; i<pArray->nMutex; i++){\n    Btree *p = pArray->aBtree[i];\n    /* Some basic sanity checking */\n    assert( i==0 || pArray->aBtree[i-1]->pBt<p->pBt );\n    assert( !p->locked || p->wantToLock>0 );\n\n    /* We should already hold a lock on the database connection */\n    assert( sqlite3_mutex_held(p->db->mutex) );\n\n    /* The Btree is sharable because only sharable Btrees are entered\n    ** into the array in the first place. */\n    assert( p->sharable );\n\n    p->wantToLock++;\n    if( !p->locked ){\n      lockBtreeMutex(p);\n    }\n  }\n}\n\n/*\n** Leave the mutex of every btree in the group.\n*/\nSQLITE_PRIVATE void sqlite3BtreeMutexArrayLeave(BtreeMutexArray *pArray){\n  int i;\n  for(i=0; i<pArray->nMutex; i++){\n    Btree *p = pArray->aBtree[i];\n    /* Some basic sanity checking */\n    assert( i==0 || pArray->aBtree[i-1]->pBt<p->pBt );\n    assert( p->locked );\n    assert( p->wantToLock>0 );\n\n    /* We should already hold a lock on the database connection */\n    assert( sqlite3_mutex_held(p->db->mutex) );\n\n    p->wantToLock--;\n    if( p->wantToLock==0 ){\n      unlockBtreeMutex(p);\n    }\n  }\n}\n\n#else\nSQLITE_PRIVATE void sqlite3BtreeEnter(Btree *p){\n  p->pBt->db = p->db;\n}\nSQLITE_PRIVATE void sqlite3BtreeEnterAll(sqlite3 *db){\n  int i;\n  for(i=0; i<db->nDb; i++){\n    Btree *p = db->aDb[i].pBt;\n    if( p ){\n      p->pBt->db = p->db;\n    }\n  }\n}\n#endif /* if SQLITE_THREADSAFE */\n#endif /* ifndef SQLITE_OMIT_SHARED_CACHE */\n\n/************** End of btmutex.c *********************************************/\n\n#include \"btree.c\"\n\n/************** Begin file backup.c ******************************************/\n/*\n** 2009 January 28\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains the implementation of the sqlite3_backup_XXX() \n** API functions and the related features.\n*/\n\n/* Macro to find the minimum of two numeric values.\n*/\n#ifndef MIN\n# define MIN(x,y) ((x)<(y)?(x):(y))\n#endif\n\n/*\n** Structure allocated for each backup operation.\n*/\nstruct sqlite3_backup {\n  sqlite3* pDestDb;        /* Destination database handle */\n  Btree *pDest;            /* Destination b-tree file */\n  u32 iDestSchema;         /* Original schema cookie in destination */\n  int bDestLocked;         /* True once a write-transaction is open on pDest */\n\n  Pgno iNext;              /* Page number of the next source page to copy */\n  sqlite3* pSrcDb;         /* Source database handle */\n  Btree *pSrc;             /* Source b-tree file */\n\n  int rc;                  /* Backup process error code */\n\n  /* These two variables are set by every call to backup_step(). They are\n  ** read by calls to backup_remaining() and backup_pagecount().\n  */\n  Pgno nRemaining;         /* Number of pages left to copy */\n  Pgno nPagecount;         /* Total number of pages to copy */\n\n  int isAttached;          /* True once backup has been registered with pager */\n  sqlite3_backup *pNext;   /* Next backup associated with source pager */\n};\n\n/*\n** THREAD SAFETY NOTES:\n**\n**   Once it has been created using backup_init(), a single sqlite3_backup\n**   structure may be accessed via two groups of thread-safe entry points:\n**\n**     * Via the sqlite3_backup_XXX() API function backup_step() and \n**       backup_finish(). Both these functions obtain the source database\n**       handle mutex and the mutex associated with the source BtShared \n**       structure, in that order.\n**\n**     * Via the BackupUpdate() and BackupRestart() functions, which are\n**       invoked by the pager layer to report various state changes in\n**       the page cache associated with the source database. The mutex\n**       associated with the source database BtShared structure will always \n**       be held when either of these functions are invoked.\n**\n**   The other sqlite3_backup_XXX() API functions, backup_remaining() and\n**   backup_pagecount() are not thread-safe functions. If they are called\n**   while some other thread is calling backup_step() or backup_finish(),\n**   the values returned may be invalid. There is no way for a call to\n**   BackupUpdate() or BackupRestart() to interfere with backup_remaining()\n**   or backup_pagecount().\n**\n**   Depending on the SQLite configuration, the database handles and/or\n**   the Btree objects may have their own mutexes that require locking.\n**   Non-sharable Btrees (in-memory databases for example), do not have\n**   associated mutexes.\n*/\n\n/*\n** Return a pointer corresponding to database zDb (i.e. \"main\", \"temp\")\n** in connection handle pDb. If such a database cannot be found, return\n** a NULL pointer and write an error message to pErrorDb.\n**\n** If the \"temp\" database is requested, it may need to be opened by this \n** function. If an error occurs while doing so, return 0 and write an \n** error message to pErrorDb.\n*/\nstatic Btree *findBtree(sqlite3 *pErrorDb, sqlite3 *pDb, const char *zDb){\n  int i = sqlite3FindDbName(pDb, zDb);\n\n  if( i==1 ){\n    Parse *pParse;\n    int rc = 0;\n    pParse = sqlite3StackAllocZero(pErrorDb, sizeof(*pParse));\n    if( pParse==0 ){\n      sqlite3Error(pErrorDb, SQLITE_NOMEM, \"out of memory\");\n      rc = SQLITE_NOMEM;\n    }else{\n      pParse->db = pDb;\n      if( sqlite3OpenTempDatabase(pParse) ){\n        sqlite3Error(pErrorDb, pParse->rc, \"%s\", pParse->zErrMsg);\n        rc = SQLITE_ERROR;\n      }\n      sqlite3DbFree(pErrorDb, pParse->zErrMsg);\n      sqlite3StackFree(pErrorDb, pParse);\n    }\n    if( rc ){\n      return 0;\n    }\n  }\n\n  if( i<0 ){\n    sqlite3Error(pErrorDb, SQLITE_ERROR, \"unknown database %s\", zDb);\n    return 0;\n  }\n\n  return pDb->aDb[i].pBt;\n}\n\n/*\n** Attempt to set the page size of the destination to match the page size\n** of the source.\n*/\nstatic int setDestPgsz(sqlite3_backup *p){\n  int rc;\n  rc = sqlite3BtreeSetPageSize(p->pDest,sqlite3BtreeGetPageSize(p->pSrc),-1,0);\n  return rc;\n}\n\n/*\n** Create an sqlite3_backup process to copy the contents of zSrcDb from\n** connection handle pSrcDb to zDestDb in pDestDb. If successful, return\n** a pointer to the new sqlite3_backup object.\n**\n** If an error occurs, NULL is returned and an error code and error message\n** stored in database handle pDestDb.\n*/\nSQLITE_API sqlite3_backup *sqlite3_backup_init(\n  sqlite3* pDestDb,                     /* Database to write to */\n  const char *zDestDb,                  /* Name of database within pDestDb */\n  sqlite3* pSrcDb,                      /* Database connection to read from */\n  const char *zSrcDb                    /* Name of database within pSrcDb */\n){\n  sqlite3_backup *p;                    /* Value to return */\n\n  /* Lock the source database handle. The destination database\n  ** handle is not locked in this routine, but it is locked in\n  ** sqlite3_backup_step(). The user is required to ensure that no\n  ** other thread accesses the destination handle for the duration\n  ** of the backup operation.  Any attempt to use the destination\n  ** database connection while a backup is in progress may cause\n  ** a malfunction or a deadlock.\n  */\n  sqlite3_mutex_enter(pSrcDb->mutex);\n  sqlite3_mutex_enter(pDestDb->mutex);\n\n  if( pSrcDb==pDestDb ){\n    sqlite3Error(\n        pDestDb, SQLITE_ERROR, \"source and destination must be distinct\"\n    );\n    p = 0;\n  }else {\n    /* Allocate space for a new sqlite3_backup object...\n    ** EVIDENCE-OF: R-64852-21591 The sqlite3_backup object is created by a\n    ** call to sqlite3_backup_init() and is destroyed by a call to\n    ** sqlite3_backup_finish(). */\n    p = (sqlite3_backup *)sqlite3_malloc(sizeof(sqlite3_backup));\n    if( !p ){\n      sqlite3Error(pDestDb, SQLITE_NOMEM, 0);\n    }\n  }\n\n  /* If the allocation succeeded, populate the new object. */\n  if( p ){\n    memset(p, 0, sizeof(sqlite3_backup));\n    p->pSrc = findBtree(pDestDb, pSrcDb, zSrcDb);\n    p->pDest = findBtree(pDestDb, pDestDb, zDestDb);\n    p->pDestDb = pDestDb;\n    p->pSrcDb = pSrcDb;\n    p->iNext = 1;\n    p->isAttached = 0;\n\n    if( 0==p->pSrc || 0==p->pDest || setDestPgsz(p)==SQLITE_NOMEM ){\n      /* One (or both) of the named databases did not exist or an OOM\n      ** error was hit.  The error has already been written into the\n      ** pDestDb handle.  All that is left to do here is free the\n      ** sqlite3_backup structure.\n      */\n      sqlite3_free(p);\n      p = 0;\n    }\n  }\n  if( p ){\n    p->pSrc->nBackup++;\n  }\n\n  sqlite3_mutex_leave(pDestDb->mutex);\n  sqlite3_mutex_leave(pSrcDb->mutex);\n  return p;\n}\n\n/*\n** Argument rc is an SQLite error code. Return true if this error is \n** considered fatal if encountered during a backup operation. All errors\n** are considered fatal except for SQLITE_BUSY and SQLITE_LOCKED.\n*/\nstatic int isFatalError(int rc){\n  return (rc!=SQLITE_OK && rc!=SQLITE_BUSY && ALWAYS(rc!=SQLITE_LOCKED));\n}\n\n/*\n** Parameter zSrcData points to a buffer containing the data for \n** page iSrcPg from the source database. Copy this data into the \n** destination database.\n*/\nstatic int backupOnePage(sqlite3_backup *p, Pgno iSrcPg, const u8 *zSrcData){\n  Pager * const pDestPager = sqlite3BtreePager(p->pDest);\n  const int nSrcPgsz = sqlite3BtreeGetPageSize(p->pSrc);\n  int nDestPgsz = sqlite3BtreeGetPageSize(p->pDest);\n  const int nCopy = MIN(nSrcPgsz, nDestPgsz);\n  const i64 iEnd = (i64)iSrcPg*(i64)nSrcPgsz;\n\n  int rc = SQLITE_OK;\n  i64 iOff;\n\n  assert( p->bDestLocked );\n  assert( !isFatalError(p->rc) );\n  assert( iSrcPg!=PENDING_BYTE_PAGE(p->pSrc->pBt) );\n  assert( zSrcData );\n\n  /* Catch the case where the destination is an in-memory database and the\n  ** page sizes of the source and destination differ. \n  */\n  if( nSrcPgsz!=nDestPgsz && sqlite3PagerIsMemdb(pDestPager) ){\n    rc = SQLITE_READONLY;\n  }\n\n#ifdef SQLITE_HAS_CODEC\n  /* Backup is not possible if the page size of the destination is changing\n  ** a a codec is in use.\n  */\n  if( nSrcPgsz!=nDestPgsz && sqlite3PagerGetCodec(pDestPager)!=0 ){\n    rc = SQLITE_READONLY;\n  }\n#endif\n\n  /* This loop runs once for each destination page spanned by the source \n  ** page. For each iteration, variable iOff is set to the byte offset\n  ** of the destination page.\n  */\n  for(iOff=iEnd-(i64)nSrcPgsz; rc==SQLITE_OK && iOff<iEnd; iOff+=nDestPgsz){\n    DbPage *pDestPg = 0;\n    Pgno iDest = (Pgno)(iOff/nDestPgsz)+1;\n    if( iDest==PENDING_BYTE_PAGE(p->pDest->pBt) ) continue;\n    if( SQLITE_OK==(rc = sqlite3PagerGet(pDestPager, iDest, &pDestPg))\n     && SQLITE_OK==(rc = sqlite3PagerWrite(pDestPg))\n    ){\n      const u8 *zIn = &zSrcData[iOff%nSrcPgsz];\n      u8 *zDestData = sqlite3PagerGetData(pDestPg);\n      u8 *zOut = &zDestData[iOff%nDestPgsz];\n\n      /* Copy the data from the source page into the destination page.\n      ** Then clear the Btree layer MemPage.isInit flag. Both this module\n      ** and the pager code use this trick (clearing the first byte\n      ** of the page 'extra' space to invalidate the Btree layers\n      ** cached parse of the page). MemPage.isInit is marked \n      ** \"MUST BE FIRST\" for this purpose.\n      */\n      memcpy(zOut, zIn, nCopy);\n      ((u8 *)sqlite3PagerGetExtra(pDestPg))[0] = 0;\n    }\n    sqlite3PagerUnref(pDestPg);\n  }\n\n  return rc;\n}\n\n/*\n** If pFile is currently larger than iSize bytes, then truncate it to\n** exactly iSize bytes. If pFile is not larger than iSize bytes, then\n** this function is a no-op.\n**\n** Return SQLITE_OK if everything is successful, or an SQLite error \n** code if an error occurs.\n*/\nstatic int backupTruncateFile(sqlite3_file *pFile, i64 iSize){\n  i64 iCurrent;\n  int rc = sqlite3OsFileSize(pFile, &iCurrent);\n  if( rc==SQLITE_OK && iCurrent>iSize ){\n    rc = sqlite3OsTruncate(pFile, iSize);\n  }\n  return rc;\n}\n\n/*\n** Register this backup object with the associated source pager for\n** callbacks when pages are changed or the cache invalidated.\n*/\nstatic void attachBackupObject(sqlite3_backup *p){\n  sqlite3_backup **pp;\n  assert( sqlite3BtreeHoldsMutex(p->pSrc) );\n  pp = sqlite3PagerBackupPtr(sqlite3BtreePager(p->pSrc));\n  p->pNext = *pp;\n  *pp = p;\n  p->isAttached = 1;\n}\n\n/*\n** Copy nPage pages from the source b-tree to the destination.\n*/\nSQLITE_API int sqlite3_backup_step(sqlite3_backup *p, int nPage){\n  int rc;\n  int destMode;       /* Destination journal mode */\n  int pgszSrc = 0;    /* Source page size */\n  int pgszDest = 0;   /* Destination page size */\n\n  sqlite3_mutex_enter(p->pSrcDb->mutex);\n  sqlite3BtreeEnter(p->pSrc);\n  if( p->pDestDb ){\n    sqlite3_mutex_enter(p->pDestDb->mutex);\n  }\n\n  rc = p->rc;\n  if( !isFatalError(rc) ){\n    Pager * const pSrcPager = sqlite3BtreePager(p->pSrc);     /* Source pager */\n    Pager * const pDestPager = sqlite3BtreePager(p->pDest);   /* Dest pager */\n    int ii;                            /* Iterator variable */\n    int nSrcPage = -1;                 /* Size of source db in pages */\n    int bCloseTrans = 0;               /* True if src db requires unlocking */\n\n    /* If the source pager is currently in a write-transaction, return\n    ** SQLITE_BUSY immediately.\n    */\n    if( p->pDestDb && p->pSrc->pBt->inTransaction==TRANS_WRITE ){\n      rc = SQLITE_BUSY;\n    }else{\n      rc = SQLITE_OK;\n    }\n\n    /* Lock the destination database, if it is not locked already. */\n    if( SQLITE_OK==rc && p->bDestLocked==0\n     && SQLITE_OK==(rc = sqlite3BtreeBeginTrans(p->pDest, 2)) \n    ){\n      p->bDestLocked = 1;\n      sqlite3BtreeGetMeta(p->pDest, BTREE_SCHEMA_VERSION, &p->iDestSchema);\n    }\n\n    /* If there is no open read-transaction on the source database, open\n    ** one now. If a transaction is opened here, then it will be closed\n    ** before this function exits.\n    */\n    if( rc==SQLITE_OK && 0==sqlite3BtreeIsInReadTrans(p->pSrc) ){\n      rc = sqlite3BtreeBeginTrans(p->pSrc, 0);\n      bCloseTrans = 1;\n    }\n\n    /* Do not allow backup if the destination database is in WAL mode\n    ** and the page sizes are different between source and destination */\n    pgszSrc = sqlite3BtreeGetPageSize(p->pSrc);\n    pgszDest = sqlite3BtreeGetPageSize(p->pDest);\n    destMode = sqlite3PagerGetJournalMode(sqlite3BtreePager(p->pDest));\n    if( SQLITE_OK==rc && destMode==PAGER_JOURNALMODE_WAL && pgszSrc!=pgszDest ){\n      rc = SQLITE_READONLY;\n    }\n  \n    /* Now that there is a read-lock on the source database, query the\n    ** source pager for the number of pages in the database.\n    */\n    nSrcPage = (int)sqlite3BtreeLastPage(p->pSrc);\n    assert( nSrcPage>=0 );\n    for(ii=0; (nPage<0 || ii<nPage) && p->iNext<=(Pgno)nSrcPage && !rc; ii++){\n      const Pgno iSrcPg = p->iNext;                 /* Source page number */\n      if( iSrcPg!=PENDING_BYTE_PAGE(p->pSrc->pBt) ){\n        DbPage *pSrcPg;                             /* Source page object */\n        rc = sqlite3PagerGet(pSrcPager, iSrcPg, &pSrcPg);\n        if( rc==SQLITE_OK ){\n          rc = backupOnePage(p, iSrcPg, sqlite3PagerGetData(pSrcPg));\n          sqlite3PagerUnref(pSrcPg);\n        }\n      }\n      p->iNext++;\n    }\n    if( rc==SQLITE_OK ){\n      p->nPagecount = nSrcPage;\n      p->nRemaining = nSrcPage+1-p->iNext;\n      if( p->iNext>(Pgno)nSrcPage ){\n        rc = SQLITE_DONE;\n      }else if( !p->isAttached ){\n        attachBackupObject(p);\n      }\n    }\n  \n    /* Update the schema version field in the destination database. This\n    ** is to make sure that the schema-version really does change in\n    ** the case where the source and destination databases have the\n    ** same schema version.\n    */\n    if( rc==SQLITE_DONE \n     && (rc = sqlite3BtreeUpdateMeta(p->pDest,1,p->iDestSchema+1))==SQLITE_OK\n    ){\n      int nDestTruncate;\n  \n      if( p->pDestDb ){\n        sqlite3ResetInternalSchema(p->pDestDb, 0);\n      }\n\n      /* Set nDestTruncate to the final number of pages in the destination\n      ** database. The complication here is that the destination page\n      ** size may be different to the source page size. \n      **\n      ** If the source page size is smaller than the destination page size, \n      ** round up. In this case the call to sqlite3OsTruncate() below will\n      ** fix the size of the file. However it is important to call\n      ** sqlite3PagerTruncateImage() here so that any pages in the \n      ** destination file that lie beyond the nDestTruncate page mark are\n      ** journalled by PagerCommitPhaseOne() before they are destroyed\n      ** by the file truncation.\n      */\n      assert( pgszSrc==sqlite3BtreeGetPageSize(p->pSrc) );\n      assert( pgszDest==sqlite3BtreeGetPageSize(p->pDest) );\n      if( pgszSrc<pgszDest ){\n        int ratio = pgszDest/pgszSrc;\n        nDestTruncate = (nSrcPage+ratio-1)/ratio;\n        if( nDestTruncate==(int)PENDING_BYTE_PAGE(p->pDest->pBt) ){\n          nDestTruncate--;\n        }\n      }else{\n        nDestTruncate = nSrcPage * (pgszSrc/pgszDest);\n      }\n      sqlite3PagerTruncateImage(pDestPager, nDestTruncate);\n\n      if( pgszSrc<pgszDest ){\n        /* If the source page-size is smaller than the destination page-size,\n        ** two extra things may need to happen:\n        **\n        **   * The destination may need to be truncated, and\n        **\n        **   * Data stored on the pages immediately following the \n        **     pending-byte page in the source database may need to be\n        **     copied into the destination database.\n        */\n        const i64 iSize = (i64)pgszSrc * (i64)nSrcPage;\n        sqlite3_file * const pFile = sqlite3PagerFile(pDestPager);\n        i64 iOff;\n        i64 iEnd;\n\n        assert( pFile );\n        assert( (i64)nDestTruncate*(i64)pgszDest >= iSize || (\n              nDestTruncate==(int)(PENDING_BYTE_PAGE(p->pDest->pBt)-1)\n           && iSize>=PENDING_BYTE && iSize<=PENDING_BYTE+pgszDest\n        ));\n\n        /* This call ensures that all data required to recreate the original\n        ** database has been stored in the journal for pDestPager and the\n        ** journal synced to disk. So at this point we may safely modify\n        ** the database file in any way, knowing that if a power failure\n        ** occurs, the original database will be reconstructed from the \n        ** journal file.  */\n        rc = sqlite3PagerCommitPhaseOne(pDestPager, 0, 1);\n\n        /* Write the extra pages and truncate the database file as required. */\n        iEnd = MIN(PENDING_BYTE + pgszDest, iSize);\n        for(\n          iOff=PENDING_BYTE+pgszSrc; \n          rc==SQLITE_OK && iOff<iEnd; \n          iOff+=pgszSrc\n        ){\n          PgHdr *pSrcPg = 0;\n          const Pgno iSrcPg = (Pgno)((iOff/pgszSrc)+1);\n          rc = sqlite3PagerGet(pSrcPager, iSrcPg, &pSrcPg);\n          if( rc==SQLITE_OK ){\n            u8 *zData = sqlite3PagerGetData(pSrcPg);\n            rc = sqlite3OsWrite(pFile, zData, pgszSrc, iOff);\n          }\n          sqlite3PagerUnref(pSrcPg);\n        }\n        if( rc==SQLITE_OK ){\n          rc = backupTruncateFile(pFile, iSize);\n        }\n\n        /* Sync the database file to disk. */\n        if( rc==SQLITE_OK ){\n          rc = sqlite3PagerSync(pDestPager);\n        }\n      }else{\n        rc = sqlite3PagerCommitPhaseOne(pDestPager, 0, 0);\n      }\n  \n      /* Finish committing the transaction to the destination database. */\n      if( SQLITE_OK==rc\n       && SQLITE_OK==(rc = sqlite3BtreeCommitPhaseTwo(p->pDest))\n      ){\n        rc = SQLITE_DONE;\n      }\n    }\n  \n    /* If bCloseTrans is true, then this function opened a read transaction\n    ** on the source database. Close the read transaction here. There is\n    ** no need to check the return values of the btree methods here, as\n    ** \"committing\" a read-only transaction cannot fail.\n    */\n    if( bCloseTrans ){\n      TESTONLY( int rc2 );\n      TESTONLY( rc2  = ) sqlite3BtreeCommitPhaseOne(p->pSrc, 0);\n      TESTONLY( rc2 |= ) sqlite3BtreeCommitPhaseTwo(p->pSrc);\n      assert( rc2==SQLITE_OK );\n    }\n  \n    if( rc==SQLITE_IOERR_NOMEM ){\n      rc = SQLITE_NOMEM;\n    }\n    p->rc = rc;\n  }\n  if( p->pDestDb ){\n    sqlite3_mutex_leave(p->pDestDb->mutex);\n  }\n  sqlite3BtreeLeave(p->pSrc);\n  sqlite3_mutex_leave(p->pSrcDb->mutex);\n  return rc;\n}\n\n/*\n** Release all resources associated with an sqlite3_backup* handle.\n*/\nSQLITE_API int sqlite3_backup_finish(sqlite3_backup *p){\n  sqlite3_backup **pp;                 /* Ptr to head of pagers backup list */\n  sqlite3_mutex *mutex;                /* Mutex to protect source database */\n  int rc;                              /* Value to return */\n\n  /* Enter the mutexes */\n  if( p==0 ) return SQLITE_OK;\n  sqlite3_mutex_enter(p->pSrcDb->mutex);\n  sqlite3BtreeEnter(p->pSrc);\n  mutex = p->pSrcDb->mutex;\n  if( p->pDestDb ){\n    sqlite3_mutex_enter(p->pDestDb->mutex);\n  }\n\n  /* Detach this backup from the source pager. */\n  if( p->pDestDb ){\n    p->pSrc->nBackup--;\n  }\n  if( p->isAttached ){\n    pp = sqlite3PagerBackupPtr(sqlite3BtreePager(p->pSrc));\n    while( *pp!=p ){\n      pp = &(*pp)->pNext;\n    }\n    *pp = p->pNext;\n  }\n\n  /* If a transaction is still open on the Btree, roll it back. */\n  sqlite3BtreeRollback(p->pDest);\n\n  /* Set the error code of the destination database handle. */\n  rc = (p->rc==SQLITE_DONE) ? SQLITE_OK : p->rc;\n  sqlite3Error(p->pDestDb, rc, 0);\n\n  /* Exit the mutexes and free the backup context structure. */\n  if( p->pDestDb ){\n    sqlite3_mutex_leave(p->pDestDb->mutex);\n  }\n  sqlite3BtreeLeave(p->pSrc);\n  if( p->pDestDb ){\n    /* EVIDENCE-OF: R-64852-21591 The sqlite3_backup object is created by a\n    ** call to sqlite3_backup_init() and is destroyed by a call to\n    ** sqlite3_backup_finish(). */\n    sqlite3_free(p);\n  }\n  sqlite3_mutex_leave(mutex);\n  return rc;\n}\n\n/*\n** Return the number of pages still to be backed up as of the most recent\n** call to sqlite3_backup_step().\n*/\nSQLITE_API int sqlite3_backup_remaining(sqlite3_backup *p){\n  return p->nRemaining;\n}\n\n/*\n** Return the total number of pages in the source database as of the most \n** recent call to sqlite3_backup_step().\n*/\nSQLITE_API int sqlite3_backup_pagecount(sqlite3_backup *p){\n  return p->nPagecount;\n}\n\n/*\n** This function is called after the contents of page iPage of the\n** source database have been modified. If page iPage has already been \n** copied into the destination database, then the data written to the\n** destination is now invalidated. The destination copy of iPage needs\n** to be updated with the new data before the backup operation is\n** complete.\n**\n** It is assumed that the mutex associated with the BtShared object\n** corresponding to the source database is held when this function is\n** called.\n*/\nSQLITE_PRIVATE void sqlite3BackupUpdate(sqlite3_backup *pBackup, Pgno iPage, const u8 *aData){\n  sqlite3_backup *p;                   /* Iterator variable */\n  for(p=pBackup; p; p=p->pNext){\n    assert( sqlite3_mutex_held(p->pSrc->pBt->mutex) );\n    if( !isFatalError(p->rc) && iPage<p->iNext ){\n      /* The backup process p has already copied page iPage. But now it\n      ** has been modified by a transaction on the source pager. Copy\n      ** the new data into the backup.\n      */\n      int rc = backupOnePage(p, iPage, aData);\n      assert( rc!=SQLITE_BUSY && rc!=SQLITE_LOCKED );\n      if( rc!=SQLITE_OK ){\n        p->rc = rc;\n      }\n    }\n  }\n}\n\n/*\n** Restart the backup process. This is called when the pager layer\n** detects that the database has been modified by an external database\n** connection. In this case there is no way of knowing which of the\n** pages that have been copied into the destination database are still \n** valid and which are not, so the entire process needs to be restarted.\n**\n** It is assumed that the mutex associated with the BtShared object\n** corresponding to the source database is held when this function is\n** called.\n*/\nSQLITE_PRIVATE void sqlite3BackupRestart(sqlite3_backup *pBackup){\n  sqlite3_backup *p;                   /* Iterator variable */\n  for(p=pBackup; p; p=p->pNext){\n    assert( sqlite3_mutex_held(p->pSrc->pBt->mutex) );\n    p->iNext = 1;\n  }\n}\n\n#ifndef SQLITE_OMIT_VACUUM\n/*\n** Copy the complete content of pBtFrom into pBtTo.  A transaction\n** must be active for both files.\n**\n** The size of file pTo may be reduced by this operation. If anything \n** goes wrong, the transaction on pTo is rolled back. If successful, the \n** transaction is committed before returning.\n*/\nSQLITE_PRIVATE int sqlite3BtreeCopyFile(Btree *pTo, Btree *pFrom){\n  int rc;\n  sqlite3_backup b;\n  sqlite3BtreeEnter(pTo);\n  sqlite3BtreeEnter(pFrom);\n\n  /* Set up an sqlite3_backup object. sqlite3_backup.pDestDb must be set\n  ** to 0. This is used by the implementations of sqlite3_backup_step()\n  ** and sqlite3_backup_finish() to detect that they are being called\n  ** from this function, not directly by the user.\n  */\n  memset(&b, 0, sizeof(b));\n  b.pSrcDb = pFrom->db;\n  b.pSrc = pFrom;\n  b.pDest = pTo;\n  b.iNext = 1;\n\n  /* 0x7FFFFFFF is the hard limit for the number of pages in a database\n  ** file. By passing this as the number of pages to copy to\n  ** sqlite3_backup_step(), we can guarantee that the copy finishes \n  ** within a single call (unless an error occurs). The assert() statement\n  ** checks this assumption - (p->rc) should be set to either SQLITE_DONE \n  ** or an error code.\n  */\n  sqlite3_backup_step(&b, 0x7FFFFFFF);\n  assert( b.rc!=SQLITE_OK );\n  rc = sqlite3_backup_finish(&b);\n  if( rc==SQLITE_OK ){\n    pTo->pBt->pageSizeFixed = 0;\n  }\n\n  sqlite3BtreeLeave(pFrom);\n  sqlite3BtreeLeave(pTo);\n  return rc;\n}\n#endif /* SQLITE_OMIT_VACUUM */\n\n/************** End of backup.c **********************************************/\n/************** Begin file vdbemem.c *****************************************/\n/*\n** 2004 May 26\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n**\n** This file contains code use to manipulate \"Mem\" structure.  A \"Mem\"\n** stores a single value in the VDBE.  Mem is an opaque structure visible\n** only within the VDBE.  Interface routines refer to a Mem using the\n** name sqlite_value\n*/\n\n/*\n** Call sqlite3VdbeMemExpandBlob() on the supplied value (type Mem*)\n** P if required.\n*/\n#define expandBlob(P) (((P)->flags&MEM_Zero)?sqlite3VdbeMemExpandBlob(P):0)\n\n/*\n** If pMem is an object with a valid string representation, this routine\n** ensures the internal encoding for the string representation is\n** 'desiredEnc', one of SQLITE_UTF8, SQLITE_UTF16LE or SQLITE_UTF16BE.\n**\n** If pMem is not a string object, or the encoding of the string\n** representation is already stored using the requested encoding, then this\n** routine is a no-op.\n**\n** SQLITE_OK is returned if the conversion is successful (or not required).\n** SQLITE_NOMEM may be returned if a malloc() fails during conversion\n** between formats.\n*/\nSQLITE_PRIVATE int sqlite3VdbeChangeEncoding(Mem *pMem, int desiredEnc){\n  int rc;\n  assert( (pMem->flags&MEM_RowSet)==0 );\n  assert( desiredEnc==SQLITE_UTF8 || desiredEnc==SQLITE_UTF16LE\n           || desiredEnc==SQLITE_UTF16BE );\n  if( !(pMem->flags&MEM_Str) || pMem->enc==desiredEnc ){\n    return SQLITE_OK;\n  }\n  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );\n#ifdef SQLITE_OMIT_UTF16\n  return SQLITE_ERROR;\n#else\n\n  /* MemTranslate() may return SQLITE_OK or SQLITE_NOMEM. If NOMEM is returned,\n  ** then the encoding of the value may not have changed.\n  */\n  rc = sqlite3VdbeMemTranslate(pMem, (u8)desiredEnc);\n  assert(rc==SQLITE_OK    || rc==SQLITE_NOMEM);\n  assert(rc==SQLITE_OK    || pMem->enc!=desiredEnc);\n  assert(rc==SQLITE_NOMEM || pMem->enc==desiredEnc);\n  return rc;\n#endif\n}\n\n/*\n** Make sure pMem->z points to a writable allocation of at least \n** n bytes.\n**\n** If the memory cell currently contains string or blob data\n** and the third argument passed to this function is true, the \n** current content of the cell is preserved. Otherwise, it may\n** be discarded.  \n**\n** This function sets the MEM_Dyn flag and clears any xDel callback.\n** It also clears MEM_Ephem and MEM_Static. If the preserve flag is \n** not set, Mem.n is zeroed.\n*/\nSQLITE_PRIVATE int sqlite3VdbeMemGrow(Mem *pMem, int n, int preserve){\n  assert( 1 >=\n    ((pMem->zMalloc && pMem->zMalloc==pMem->z) ? 1 : 0) +\n    (((pMem->flags&MEM_Dyn)&&pMem->xDel) ? 1 : 0) + \n    ((pMem->flags&MEM_Ephem) ? 1 : 0) + \n    ((pMem->flags&MEM_Static) ? 1 : 0)\n  );\n  assert( (pMem->flags&MEM_RowSet)==0 );\n\n  if( n<32 ) n = 32;\n  if( sqlite3DbMallocSize(pMem->db, pMem->zMalloc)<n ){\n    if( preserve && pMem->z==pMem->zMalloc ){\n      pMem->z = pMem->zMalloc = sqlite3DbReallocOrFree(pMem->db, pMem->z, n);\n      preserve = 0;\n    }else{\n      sqlite3DbFree(pMem->db, pMem->zMalloc);\n      pMem->zMalloc = sqlite3DbMallocRaw(pMem->db, n);\n    }\n  }\n\n  if( pMem->z && preserve && pMem->zMalloc && pMem->z!=pMem->zMalloc ){\n    memcpy(pMem->zMalloc, pMem->z, pMem->n);\n  }\n  if( pMem->flags&MEM_Dyn && pMem->xDel ){\n    pMem->xDel((void *)(pMem->z));\n  }\n\n  pMem->z = pMem->zMalloc;\n  if( pMem->z==0 ){\n    pMem->flags = MEM_Null;\n  }else{\n    pMem->flags &= ~(MEM_Ephem|MEM_Static);\n  }\n  pMem->xDel = 0;\n  return (pMem->z ? SQLITE_OK : SQLITE_NOMEM);\n}\n\n/*\n** Make the given Mem object MEM_Dyn.  In other words, make it so\n** that any TEXT or BLOB content is stored in memory obtained from\n** malloc().  In this way, we know that the memory is safe to be\n** overwritten or altered.\n**\n** Return SQLITE_OK on success or SQLITE_NOMEM if malloc fails.\n*/\nSQLITE_PRIVATE int sqlite3VdbeMemMakeWriteable(Mem *pMem){\n  int f;\n  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );\n  assert( (pMem->flags&MEM_RowSet)==0 );\n  expandBlob(pMem);\n  f = pMem->flags;\n  if( (f&(MEM_Str|MEM_Blob)) && pMem->z!=pMem->zMalloc ){\n    if( sqlite3VdbeMemGrow(pMem, pMem->n + 2, 1) ){\n      return SQLITE_NOMEM;\n    }\n    pMem->z[pMem->n] = 0;\n    pMem->z[pMem->n+1] = 0;\n    pMem->flags |= MEM_Term;\n#ifdef SQLITE_DEBUG\n    pMem->pScopyFrom = 0;\n#endif\n  }\n\n  return SQLITE_OK;\n}\n\n/*\n** If the given Mem* has a zero-filled tail, turn it into an ordinary\n** blob stored in dynamically allocated space.\n*/\n#ifndef SQLITE_OMIT_INCRBLOB\nSQLITE_PRIVATE int sqlite3VdbeMemExpandBlob(Mem *pMem){\n  if( pMem->flags & MEM_Zero ){\n    int nByte;\n    assert( pMem->flags&MEM_Blob );\n    assert( (pMem->flags&MEM_RowSet)==0 );\n    assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );\n\n    /* Set nByte to the number of bytes required to store the expanded blob. */\n    nByte = pMem->n + pMem->u.nZero;\n    if( nByte<=0 ){\n      nByte = 1;\n    }\n    if( sqlite3VdbeMemGrow(pMem, nByte, 1) ){\n      return SQLITE_NOMEM;\n    }\n\n    memset(&pMem->z[pMem->n], 0, pMem->u.nZero);\n    pMem->n += pMem->u.nZero;\n    pMem->flags &= ~(MEM_Zero|MEM_Term);\n  }\n  return SQLITE_OK;\n}\n#endif\n\n\n/*\n** Make sure the given Mem is \\u0000 terminated.\n*/\nSQLITE_PRIVATE int sqlite3VdbeMemNulTerminate(Mem *pMem){\n  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );\n  if( (pMem->flags & MEM_Term)!=0 || (pMem->flags & MEM_Str)==0 ){\n    return SQLITE_OK;   /* Nothing to do */\n  }\n  if( sqlite3VdbeMemGrow(pMem, pMem->n+2, 1) ){\n    return SQLITE_NOMEM;\n  }\n  pMem->z[pMem->n] = 0;\n  pMem->z[pMem->n+1] = 0;\n  pMem->flags |= MEM_Term;\n  return SQLITE_OK;\n}\n\n/*\n** Add MEM_Str to the set of representations for the given Mem.  Numbers\n** are converted using sqlite3_snprintf().  Converting a BLOB to a string\n** is a no-op.\n**\n** Existing representations MEM_Int and MEM_Real are *not* invalidated.\n**\n** A MEM_Null value will never be passed to this function. This function is\n** used for converting values to text for returning to the user (i.e. via\n** sqlite3_value_text()), or for ensuring that values to be used as btree\n** keys are strings. In the former case a NULL pointer is returned the\n** user and the later is an internal programming error.\n*/\nSQLITE_PRIVATE int sqlite3VdbeMemStringify(Mem *pMem, int enc){\n  int rc = SQLITE_OK;\n  int fg = pMem->flags;\n  const int nByte = 32;\n\n  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );\n  assert( !(fg&MEM_Zero) );\n  assert( !(fg&(MEM_Str|MEM_Blob)) );\n  assert( fg&(MEM_Int|MEM_Real) );\n  assert( (pMem->flags&MEM_RowSet)==0 );\n  assert( EIGHT_BYTE_ALIGNMENT(pMem) );\n\n\n  if( sqlite3VdbeMemGrow(pMem, nByte, 0) ){\n    return SQLITE_NOMEM;\n  }\n\n  /* For a Real or Integer, use sqlite3_mprintf() to produce the UTF-8\n  ** string representation of the value. Then, if the required encoding\n  ** is UTF-16le or UTF-16be do a translation.\n  ** \n  ** FIX ME: It would be better if sqlite3_snprintf() could do UTF-16.\n  */\n  if( fg & MEM_Int ){\n    sqlite3_snprintf(nByte, pMem->z, \"%lld\", pMem->u.i);\n  }else{\n    assert( fg & MEM_Real );\n    sqlite3_snprintf(nByte, pMem->z, \"%!.15g\", pMem->r);\n  }\n  pMem->n = sqlite3Strlen30(pMem->z);\n  pMem->enc = SQLITE_UTF8;\n  pMem->flags |= MEM_Str|MEM_Term;\n  sqlite3VdbeChangeEncoding(pMem, enc);\n  return rc;\n}\n\n/*\n** Memory cell pMem contains the context of an aggregate function.\n** This routine calls the finalize method for that function.  The\n** result of the aggregate is stored back into pMem.\n**\n** Return SQLITE_ERROR if the finalizer reports an error.  SQLITE_OK\n** otherwise.\n*/\nSQLITE_PRIVATE int sqlite3VdbeMemFinalize(Mem *pMem, FuncDef *pFunc){\n  int rc = SQLITE_OK;\n  if( ALWAYS(pFunc && pFunc->xFinalize) ){\n    sqlite3_context ctx;\n    assert( (pMem->flags & MEM_Null)!=0 || pFunc==pMem->u.pDef );\n    assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );\n    memset(&ctx, 0, sizeof(ctx));\n    ctx.s.flags = MEM_Null;\n    ctx.s.db = pMem->db;\n    ctx.pMem = pMem;\n    ctx.pFunc = pFunc;\n    pFunc->xFinalize(&ctx); /* IMP: R-24505-23230 */\n    assert( 0==(pMem->flags&MEM_Dyn) && !pMem->xDel );\n    sqlite3DbFree(pMem->db, pMem->zMalloc);\n    memcpy(pMem, &ctx.s, sizeof(ctx.s));\n    rc = ctx.isError;\n  }\n  return rc;\n}\n\n/*\n** If the memory cell contains a string value that must be freed by\n** invoking an external callback, free it now. Calling this function\n** does not free any Mem.zMalloc buffer.\n*/\nSQLITE_PRIVATE void sqlite3VdbeMemReleaseExternal(Mem *p){\n  assert( p->db==0 || sqlite3_mutex_held(p->db->mutex) );\n  testcase( p->flags & MEM_Agg );\n  testcase( p->flags & MEM_Dyn );\n  testcase( p->flags & MEM_RowSet );\n  testcase( p->flags & MEM_Frame );\n  if( p->flags&(MEM_Agg|MEM_Dyn|MEM_RowSet|MEM_Frame) ){\n    if( p->flags&MEM_Agg ){\n      sqlite3VdbeMemFinalize(p, p->u.pDef);\n      assert( (p->flags & MEM_Agg)==0 );\n      sqlite3VdbeMemRelease(p);\n    }else if( p->flags&MEM_Dyn && p->xDel ){\n      assert( (p->flags&MEM_RowSet)==0 );\n      p->xDel((void *)p->z);\n      p->xDel = 0;\n    }else if( p->flags&MEM_RowSet ){\n      sqlite3RowSetClear(p->u.pRowSet);\n    }else if( p->flags&MEM_Frame ){\n      sqlite3VdbeMemSetNull(p);\n    }\n  }\n}\n\n/*\n** Release any memory held by the Mem. This may leave the Mem in an\n** inconsistent state, for example with (Mem.z==0) and\n** (Mem.type==SQLITE_TEXT).\n*/\nSQLITE_PRIVATE void sqlite3VdbeMemRelease(Mem *p){\n  sqlite3VdbeMemReleaseExternal(p);\n  sqlite3DbFree(p->db, p->zMalloc);\n  p->z = 0;\n  p->zMalloc = 0;\n  p->xDel = 0;\n}\n\n/*\n** Convert a 64-bit IEEE double into a 64-bit signed integer.\n** If the double is too large, return 0x8000000000000000.\n**\n** Most systems appear to do this simply by assigning\n** variables and without the extra range tests.  But\n** there are reports that windows throws an expection\n** if the floating point value is out of range. (See ticket #2880.)\n** Because we do not completely understand the problem, we will\n** take the conservative approach and always do range tests\n** before attempting the conversion.\n*/\nstatic i64 doubleToInt64(double r){\n#ifdef SQLITE_OMIT_FLOATING_POINT\n  /* When floating-point is omitted, double and int64 are the same thing */\n  return r;\n#else\n  /*\n  ** Many compilers we encounter do not define constants for the\n  ** minimum and maximum 64-bit integers, or they define them\n  ** inconsistently.  And many do not understand the \"LL\" notation.\n  ** So we define our own static constants here using nothing\n  ** larger than a 32-bit integer constant.\n  */\n  static const i64 maxInt = LARGEST_INT64;\n  static const i64 minInt = SMALLEST_INT64;\n\n  if( r<(double)minInt ){\n    return minInt;\n  }else if( r>(double)maxInt ){\n    /* minInt is correct here - not maxInt.  It turns out that assigning\n    ** a very large positive number to an integer results in a very large\n    ** negative integer.  This makes no sense, but it is what x86 hardware\n    ** does so for compatibility we will do the same in software. */\n    return minInt;\n  }else{\n    return (i64)r;\n  }\n#endif\n}\n\n/*\n** Return some kind of integer value which is the best we can do\n** at representing the value that *pMem describes as an integer.\n** If pMem is an integer, then the value is exact.  If pMem is\n** a floating-point then the value returned is the integer part.\n** If pMem is a string or blob, then we make an attempt to convert\n** it into a integer and return that.  If pMem represents an\n** an SQL-NULL value, return 0.\n**\n** If pMem represents a string value, its encoding might be changed.\n*/\nSQLITE_PRIVATE i64 sqlite3VdbeIntValue(Mem *pMem){\n  int flags;\n  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );\n  assert( EIGHT_BYTE_ALIGNMENT(pMem) );\n  flags = pMem->flags;\n  if( flags & MEM_Int ){\n    return pMem->u.i;\n  }else if( flags & MEM_Real ){\n    return doubleToInt64(pMem->r);\n  }else if( flags & (MEM_Str|MEM_Blob) ){\n    i64 value = 0;\n    assert( pMem->z || pMem->n==0 );\n    testcase( pMem->z==0 );\n    sqlite3Atoi64(pMem->z, &value, pMem->n, pMem->enc);\n    return value;\n  }else{\n    return 0;\n  }\n}\n\n/*\n** Return the best representation of pMem that we can get into a\n** double.  If pMem is already a double or an integer, return its\n** value.  If it is a string or blob, try to convert it to a double.\n** If it is a NULL, return 0.0.\n*/\nSQLITE_PRIVATE double sqlite3VdbeRealValue(Mem *pMem){\n  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );\n  assert( EIGHT_BYTE_ALIGNMENT(pMem) );\n  if( pMem->flags & MEM_Real ){\n    return pMem->r;\n  }else if( pMem->flags & MEM_Int ){\n    return (double)pMem->u.i;\n  }else if( pMem->flags & (MEM_Str|MEM_Blob) ){\n    /* (double)0 In case of SQLITE_OMIT_FLOATING_POINT... */\n    double val = (double)0;\n    sqlite3AtoF(pMem->z, &val, pMem->n, pMem->enc);\n    return val;\n  }else{\n    /* (double)0 In case of SQLITE_OMIT_FLOATING_POINT... */\n    return (double)0;\n  }\n}\n\n/*\n** The MEM structure is already a MEM_Real.  Try to also make it a\n** MEM_Int if we can.\n*/\nSQLITE_PRIVATE void sqlite3VdbeIntegerAffinity(Mem *pMem){\n  assert( pMem->flags & MEM_Real );\n  assert( (pMem->flags & MEM_RowSet)==0 );\n  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );\n  assert( EIGHT_BYTE_ALIGNMENT(pMem) );\n\n  pMem->u.i = doubleToInt64(pMem->r);\n\n  /* Only mark the value as an integer if\n  **\n  **    (1) the round-trip conversion real->int->real is a no-op, and\n  **    (2) The integer is neither the largest nor the smallest\n  **        possible integer (ticket #3922)\n  **\n  ** The second and third terms in the following conditional enforces\n  ** the second condition under the assumption that addition overflow causes\n  ** values to wrap around.  On x86 hardware, the third term is always\n  ** true and could be omitted.  But we leave it in because other\n  ** architectures might behave differently.\n  */\n  if( pMem->r==(double)pMem->u.i && pMem->u.i>SMALLEST_INT64\n      && ALWAYS(pMem->u.i<LARGEST_INT64) ){\n    pMem->flags |= MEM_Int;\n  }\n}\n\n/*\n** Convert pMem to type integer.  Invalidate any prior representations.\n*/\nSQLITE_PRIVATE int sqlite3VdbeMemIntegerify(Mem *pMem){\n  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );\n  assert( (pMem->flags & MEM_RowSet)==0 );\n  assert( EIGHT_BYTE_ALIGNMENT(pMem) );\n\n  pMem->u.i = sqlite3VdbeIntValue(pMem);\n  MemSetTypeFlag(pMem, MEM_Int);\n  return SQLITE_OK;\n}\n\n/*\n** Convert pMem so that it is of type MEM_Real.\n** Invalidate any prior representations.\n*/\nSQLITE_PRIVATE int sqlite3VdbeMemRealify(Mem *pMem){\n  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );\n  assert( EIGHT_BYTE_ALIGNMENT(pMem) );\n\n  pMem->r = sqlite3VdbeRealValue(pMem);\n  MemSetTypeFlag(pMem, MEM_Real);\n  return SQLITE_OK;\n}\n\n/*\n** Convert pMem so that it has types MEM_Real or MEM_Int or both.\n** Invalidate any prior representations.\n**\n** Every effort is made to force the conversion, even if the input\n** is a string that does not look completely like a number.  Convert\n** as much of the string as we can and ignore the rest.\n*/\nSQLITE_PRIVATE int sqlite3VdbeMemNumerify(Mem *pMem){\n  if( (pMem->flags & (MEM_Int|MEM_Real|MEM_Null))==0 ){\n    assert( (pMem->flags & (MEM_Blob|MEM_Str))!=0 );\n    assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );\n    if( 0==sqlite3Atoi64(pMem->z, &pMem->u.i, pMem->n, pMem->enc) ){\n      MemSetTypeFlag(pMem, MEM_Int);\n    }else{\n      pMem->r = sqlite3VdbeRealValue(pMem);\n      MemSetTypeFlag(pMem, MEM_Real);\n      sqlite3VdbeIntegerAffinity(pMem);\n    }\n  }\n  assert( (pMem->flags & (MEM_Int|MEM_Real|MEM_Null))!=0 );\n  pMem->flags &= ~(MEM_Str|MEM_Blob);\n  return SQLITE_OK;\n}\n\n/*\n** Delete any previous value and set the value stored in *pMem to NULL.\n*/\nSQLITE_PRIVATE void sqlite3VdbeMemSetNull(Mem *pMem){\n  if( pMem->flags & MEM_Frame ){\n    VdbeFrame *pFrame = pMem->u.pFrame;\n    pFrame->pParent = pFrame->v->pDelFrame;\n    pFrame->v->pDelFrame = pFrame;\n  }\n  if( pMem->flags & MEM_RowSet ){\n    sqlite3RowSetClear(pMem->u.pRowSet);\n  }\n  MemSetTypeFlag(pMem, MEM_Null);\n  pMem->type = SQLITE_NULL;\n}\n\n/*\n** Delete any previous value and set the value to be a BLOB of length\n** n containing all zeros.\n*/\nSQLITE_PRIVATE void sqlite3VdbeMemSetZeroBlob(Mem *pMem, int n){\n  sqlite3VdbeMemRelease(pMem);\n  pMem->flags = MEM_Blob|MEM_Zero;\n  pMem->type = SQLITE_BLOB;\n  pMem->n = 0;\n  if( n<0 ) n = 0;\n  pMem->u.nZero = n;\n  pMem->enc = SQLITE_UTF8;\n\n#ifdef SQLITE_OMIT_INCRBLOB\n  sqlite3VdbeMemGrow(pMem, n, 0);\n  if( pMem->z ){\n    pMem->n = n;\n    memset(pMem->z, 0, n);\n  }\n#endif\n}\n\n/*\n** Delete any previous value and set the value stored in *pMem to val,\n** manifest type INTEGER.\n*/\nSQLITE_PRIVATE void sqlite3VdbeMemSetInt64(Mem *pMem, i64 val){\n  sqlite3VdbeMemRelease(pMem);\n  pMem->u.i = val;\n  pMem->flags = MEM_Int;\n  pMem->type = SQLITE_INTEGER;\n}\n\n#ifndef SQLITE_OMIT_FLOATING_POINT\n/*\n** Delete any previous value and set the value stored in *pMem to val,\n** manifest type REAL.\n*/\nSQLITE_PRIVATE void sqlite3VdbeMemSetDouble(Mem *pMem, double val){\n  if( sqlite3IsNaN(val) ){\n    sqlite3VdbeMemSetNull(pMem);\n  }else{\n    sqlite3VdbeMemRelease(pMem);\n    pMem->r = val;\n    pMem->flags = MEM_Real;\n    pMem->type = SQLITE_FLOAT;\n  }\n}\n#endif\n\n/*\n** Delete any previous value and set the value of pMem to be an\n** empty boolean index.\n*/\nSQLITE_PRIVATE void sqlite3VdbeMemSetRowSet(Mem *pMem){\n  sqlite3 *db = pMem->db;\n  assert( db!=0 );\n  assert( (pMem->flags & MEM_RowSet)==0 );\n  sqlite3VdbeMemRelease(pMem);\n  pMem->zMalloc = sqlite3DbMallocRaw(db, 64);\n  if( db->mallocFailed ){\n    pMem->flags = MEM_Null;\n  }else{\n    assert( pMem->zMalloc );\n    pMem->u.pRowSet = sqlite3RowSetInit(db, pMem->zMalloc, \n                                       sqlite3DbMallocSize(db, pMem->zMalloc));\n    assert( pMem->u.pRowSet!=0 );\n    pMem->flags = MEM_RowSet;\n  }\n}\n\n/*\n** Return true if the Mem object contains a TEXT or BLOB that is\n** too large - whose size exceeds SQLITE_MAX_LENGTH.\n*/\nSQLITE_PRIVATE int sqlite3VdbeMemTooBig(Mem *p){\n  assert( p->db!=0 );\n  if( p->flags & (MEM_Str|MEM_Blob) ){\n    int n = p->n;\n    if( p->flags & MEM_Zero ){\n      n += p->u.nZero;\n    }\n    return n>p->db->aLimit[SQLITE_LIMIT_LENGTH];\n  }\n  return 0; \n}\n\n#ifdef SQLITE_DEBUG\n/*\n** This routine prepares a memory cell for modication by breaking\n** its link to a shallow copy and by marking any current shallow\n** copies of this cell as invalid.\n**\n** This is used for testing and debugging only - to make sure shallow\n** copies are not misused.\n*/\nSQLITE_PRIVATE void sqlite3VdbeMemPrepareToChange(Vdbe *pVdbe, Mem *pMem){\n  int i;\n  Mem *pX;\n  for(i=1, pX=&pVdbe->aMem[1]; i<=pVdbe->nMem; i++, pX++){\n    if( pX->pScopyFrom==pMem ){\n      pX->flags |= MEM_Invalid;\n      pX->pScopyFrom = 0;\n    }\n  }\n  pMem->pScopyFrom = 0;\n}\n#endif /* SQLITE_DEBUG */\n\n/*\n** Size of struct Mem not including the Mem.zMalloc member.\n*/\n#define MEMCELLSIZE (size_t)(&(((Mem *)0)->zMalloc))\n\n/*\n** Make an shallow copy of pFrom into pTo.  Prior contents of\n** pTo are freed.  The pFrom->z field is not duplicated.  If\n** pFrom->z is used, then pTo->z points to the same thing as pFrom->z\n** and flags gets srcType (either MEM_Ephem or MEM_Static).\n*/\nSQLITE_PRIVATE void sqlite3VdbeMemShallowCopy(Mem *pTo, const Mem *pFrom, int srcType){\n  assert( (pFrom->flags & MEM_RowSet)==0 );\n  sqlite3VdbeMemReleaseExternal(pTo);\n  memcpy(pTo, pFrom, MEMCELLSIZE);\n  pTo->xDel = 0;\n  if( (pFrom->flags&MEM_Static)==0 ){\n    pTo->flags &= ~(MEM_Dyn|MEM_Static|MEM_Ephem);\n    assert( srcType==MEM_Ephem || srcType==MEM_Static );\n    pTo->flags |= srcType;\n  }\n}\n\n/*\n** Make a full copy of pFrom into pTo.  Prior contents of pTo are\n** freed before the copy is made.\n*/\nSQLITE_PRIVATE int sqlite3VdbeMemCopy(Mem *pTo, const Mem *pFrom){\n  int rc = SQLITE_OK;\n\n  assert( (pFrom->flags & MEM_RowSet)==0 );\n  sqlite3VdbeMemReleaseExternal(pTo);\n  memcpy(pTo, pFrom, MEMCELLSIZE);\n  pTo->flags &= ~MEM_Dyn;\n\n  if( pTo->flags&(MEM_Str|MEM_Blob) ){\n    if( 0==(pFrom->flags&MEM_Static) ){\n      pTo->flags |= MEM_Ephem;\n      rc = sqlite3VdbeMemMakeWriteable(pTo);\n    }\n  }\n\n  return rc;\n}\n\n/*\n** Transfer the contents of pFrom to pTo. Any existing value in pTo is\n** freed. If pFrom contains ephemeral data, a copy is made.\n**\n** pFrom contains an SQL NULL when this routine returns.\n*/\nSQLITE_PRIVATE void sqlite3VdbeMemMove(Mem *pTo, Mem *pFrom){\n  assert( pFrom->db==0 || sqlite3_mutex_held(pFrom->db->mutex) );\n  assert( pTo->db==0 || sqlite3_mutex_held(pTo->db->mutex) );\n  assert( pFrom->db==0 || pTo->db==0 || pFrom->db==pTo->db );\n\n  sqlite3VdbeMemRelease(pTo);\n  memcpy(pTo, pFrom, sizeof(Mem));\n  pFrom->flags = MEM_Null;\n  pFrom->xDel = 0;\n  pFrom->zMalloc = 0;\n}\n\n/*\n** Change the value of a Mem to be a string or a BLOB.\n**\n** The memory management strategy depends on the value of the xDel\n** parameter. If the value passed is SQLITE_TRANSIENT, then the \n** string is copied into a (possibly existing) buffer managed by the \n** Mem structure. Otherwise, any existing buffer is freed and the\n** pointer copied.\n**\n** If the string is too large (if it exceeds the SQLITE_LIMIT_LENGTH\n** size limit) then no memory allocation occurs.  If the string can be\n** stored without allocating memory, then it is.  If a memory allocation\n** is required to store the string, then value of pMem is unchanged.  In\n** either case, SQLITE_TOOBIG is returned.\n*/\nSQLITE_PRIVATE int sqlite3VdbeMemSetStr(\n  Mem *pMem,          /* Memory cell to set to string value */\n  const char *z,      /* String pointer */\n  int n,              /* Bytes in string, or negative */\n  u8 enc,             /* Encoding of z.  0 for BLOBs */\n  void (*xDel)(void*) /* Destructor function */\n){\n  int nByte = n;      /* New value for pMem->n */\n  int iLimit;         /* Maximum allowed string or blob size */\n  u16 flags = 0;      /* New value for pMem->flags */\n\n  assert( pMem->db==0 || sqlite3_mutex_held(pMem->db->mutex) );\n  assert( (pMem->flags & MEM_RowSet)==0 );\n\n  /* If z is a NULL pointer, set pMem to contain an SQL NULL. */\n  if( !z ){\n    sqlite3VdbeMemSetNull(pMem);\n    return SQLITE_OK;\n  }\n\n  if( pMem->db ){\n    iLimit = pMem->db->aLimit[SQLITE_LIMIT_LENGTH];\n  }else{\n    iLimit = SQLITE_MAX_LENGTH;\n  }\n  flags = (enc==0?MEM_Blob:MEM_Str);\n  if( nByte<0 ){\n    assert( enc!=0 );\n    if( enc==SQLITE_UTF8 ){\n      for(nByte=0; nByte<=iLimit && z[nByte]; nByte++){}\n    }else{\n      for(nByte=0; nByte<=iLimit && (z[nByte] | z[nByte+1]); nByte+=2){}\n    }\n    flags |= MEM_Term;\n  }\n\n  /* The following block sets the new values of Mem.z and Mem.xDel. It\n  ** also sets a flag in local variable \"flags\" to indicate the memory\n  ** management (one of MEM_Dyn or MEM_Static).\n  */\n  if( xDel==SQLITE_TRANSIENT ){\n    int nAlloc = nByte;\n    if( flags&MEM_Term ){\n      nAlloc += (enc==SQLITE_UTF8?1:2);\n    }\n    if( nByte>iLimit ){\n      return SQLITE_TOOBIG;\n    }\n    if( sqlite3VdbeMemGrow(pMem, nAlloc, 0) ){\n      return SQLITE_NOMEM;\n    }\n    memcpy(pMem->z, z, nAlloc);\n  }else if( xDel==SQLITE_DYNAMIC ){\n    sqlite3VdbeMemRelease(pMem);\n    pMem->zMalloc = pMem->z = (char *)z;\n    pMem->xDel = 0;\n  }else{\n    sqlite3VdbeMemRelease(pMem);\n    pMem->z = (char *)z;\n    pMem->xDel = xDel;\n    flags |= ((xDel==SQLITE_STATIC)?MEM_Static:MEM_Dyn);\n  }\n\n  pMem->n = nByte;\n  pMem->flags = flags;\n  pMem->enc = (enc==0 ? SQLITE_UTF8 : enc);\n  pMem->type = (enc==0 ? SQLITE_BLOB : SQLITE_TEXT);\n\n#ifndef SQLITE_OMIT_UTF16\n  if( pMem->enc!=SQLITE_UTF8 && sqlite3VdbeMemHandleBom(pMem) ){\n    return SQLITE_NOMEM;\n  }\n#endif\n\n  if( nByte>iLimit ){\n    return SQLITE_TOOBIG;\n  }\n\n  return SQLITE_OK;\n}\n\n/*\n** Compare the values contained by the two memory cells, returning\n** negative, zero or positive if pMem1 is less than, equal to, or greater\n** than pMem2. Sorting order is NULL's first, followed by numbers (integers\n** and reals) sorted numerically, followed by text ordered by the collating\n** sequence pColl and finally blob's ordered by memcmp().\n**\n** Two NULL values are considered equal by this function.\n*/\nSQLITE_PRIVATE int sqlite3MemCompare(const Mem *pMem1, const Mem *pMem2, const CollSeq *pColl){\n  int rc;\n  int f1, f2;\n  int combined_flags;\n\n  f1 = pMem1->flags;\n  f2 = pMem2->flags;\n  combined_flags = f1|f2;\n  assert( (combined_flags & MEM_RowSet)==0 );\n \n  /* If one value is NULL, it is less than the other. If both values\n  ** are NULL, return 0.\n  */\n  if( combined_flags&MEM_Null ){\n    return (f2&MEM_Null) - (f1&MEM_Null);\n  }\n\n  /* If one value is a number and the other is not, the number is less.\n  ** If both are numbers, compare as reals if one is a real, or as integers\n  ** if both values are integers.\n  */\n  if( combined_flags&(MEM_Int|MEM_Real) ){\n    if( !(f1&(MEM_Int|MEM_Real)) ){\n      return 1;\n    }\n    if( !(f2&(MEM_Int|MEM_Real)) ){\n      return -1;\n    }\n    if( (f1 & f2 & MEM_Int)==0 ){\n      double r1, r2;\n      if( (f1&MEM_Real)==0 ){\n        r1 = (double)pMem1->u.i;\n      }else{\n        r1 = pMem1->r;\n      }\n      if( (f2&MEM_Real)==0 ){\n        r2 = (double)pMem2->u.i;\n      }else{\n        r2 = pMem2->r;\n      }\n      if( r1<r2 ) return -1;\n      if( r1>r2 ) return 1;\n      return 0;\n    }else{\n      assert( f1&MEM_Int );\n      assert( f2&MEM_Int );\n      if( pMem1->u.i < pMem2->u.i ) return -1;\n      if( pMem1->u.i > pMem2->u.i ) return 1;\n      return 0;\n    }\n  }\n\n  /* If one value is a string and the other is a blob, the string is less.\n  ** If both are strings, compare using the collating functions.\n  */\n  if( combined_flags&MEM_Str ){\n    if( (f1 & MEM_Str)==0 ){\n      return 1;\n    }\n    if( (f2 & MEM_Str)==0 ){\n      return -1;\n    }\n\n    assert( pMem1->enc==pMem2->enc );\n    assert( pMem1->enc==SQLITE_UTF8 || \n            pMem1->enc==SQLITE_UTF16LE || pMem1->enc==SQLITE_UTF16BE );\n\n    /* The collation sequence must be defined at this point, even if\n    ** the user deletes the collation sequence after the vdbe program is\n    ** compiled (this was not always the case).\n    */\n    assert( !pColl || pColl->xCmp );\n\n    if( pColl ){\n      if( pMem1->enc==pColl->enc ){\n        /* The strings are already in the correct encoding.  Call the\n        ** comparison function directly */\n        return pColl->xCmp(pColl->pUser,pMem1->n,pMem1->z,pMem2->n,pMem2->z);\n      }else{\n        const void *v1, *v2;\n        int n1, n2;\n        Mem c1;\n        Mem c2;\n        memset(&c1, 0, sizeof(c1));\n        memset(&c2, 0, sizeof(c2));\n        sqlite3VdbeMemShallowCopy(&c1, pMem1, MEM_Ephem);\n        sqlite3VdbeMemShallowCopy(&c2, pMem2, MEM_Ephem);\n        v1 = sqlite3ValueText((sqlite3_value*)&c1, pColl->enc);\n        n1 = v1==0 ? 0 : c1.n;\n        v2 = sqlite3ValueText((sqlite3_value*)&c2, pColl->enc);\n        n2 = v2==0 ? 0 : c2.n;\n        rc = pColl->xCmp(pColl->pUser, n1, v1, n2, v2);\n        sqlite3VdbeMemRelease(&c1);\n        sqlite3VdbeMemRelease(&c2);\n        return rc;\n      }\n    }\n    /* If a NULL pointer was passed as the collate function, fall through\n    ** to the blob case and use memcmp().  */\n  }\n \n  /* Both values must be blobs.  Compare using memcmp().  */\n  rc = memcmp(pMem1->z, pMem2->z, (pMem1->n>pMem2->n)?pMem2->n:pMem1->n);\n  if( rc==0 ){\n    rc = pMem1->n - pMem2->n;\n  }\n  return rc;\n}\n\n/*\n** Move data out of a btree key or data field and into a Mem structure.\n** The data or key is taken from the entry that pCur is currently pointing\n** to.  offset and amt determine what portion of the data or key to retrieve.\n** key is true to get the key or false to get data.  The result is written\n** into the pMem element.\n**\n** The pMem structure is assumed to be uninitialized.  Any prior content\n** is overwritten without being freed.\n**\n** If this routine fails for any reason (malloc returns NULL or unable\n** to read from the disk) then the pMem is left in an inconsistent state.\n*/\nSQLITE_PRIVATE int sqlite3VdbeMemFromBtree(\n  BtCursor *pCur,   /* Cursor pointing at record to retrieve. */\n  int offset,       /* Offset from the start of data to return bytes from. */\n  int amt,          /* Number of bytes to return. */\n  int key,          /* If true, retrieve from the btree key, not data. */\n  Mem *pMem         /* OUT: Return data in this Mem structure. */\n){\n  char *zData;        /* Data from the btree layer */\n  int available = 0;  /* Number of bytes available on the local btree page */\n  int rc = SQLITE_OK; /* Return code */\n\n  assert( sqlite3BtreeCursorIsValid(pCur) );\n\n  /* Note: the calls to BtreeKeyFetch() and DataFetch() below assert() \n  ** that both the BtShared and database handle mutexes are held. */\n  assert( (pMem->flags & MEM_RowSet)==0 );\n  if( key ){\n    zData = (char *)sqlite3BtreeKeyFetch(pCur, &available);\n  }else{\n    zData = (char *)sqlite3BtreeDataFetch(pCur, &available);\n  }\n  assert( zData!=0 );\n\n  if( offset+amt<=available && (pMem->flags&MEM_Dyn)==0 ){\n    sqlite3VdbeMemRelease(pMem);\n    pMem->z = &zData[offset];\n    pMem->flags = MEM_Blob|MEM_Ephem;\n  }else if( SQLITE_OK==(rc = sqlite3VdbeMemGrow(pMem, amt+2, 0)) ){\n    pMem->flags = MEM_Blob|MEM_Dyn|MEM_Term;\n    pMem->enc = 0;\n    pMem->type = SQLITE_BLOB;\n    if( key ){\n      rc = sqlite3BtreeKey(pCur, offset, amt, pMem->z);\n    }else{\n      rc = sqlite3BtreeData(pCur, offset, amt, pMem->z);\n    }\n    pMem->z[amt] = 0;\n    pMem->z[amt+1] = 0;\n    if( rc!=SQLITE_OK ){\n      sqlite3VdbeMemRelease(pMem);\n    }\n  }\n  pMem->n = amt;\n\n  return rc;\n}\n\n/* This function is only available internally, it is not part of the\n** external API. It works in a similar way to sqlite3_value_text(),\n** except the data returned is in the encoding specified by the second\n** parameter, which must be one of SQLITE_UTF16BE, SQLITE_UTF16LE or\n** SQLITE_UTF8.\n**\n** (2006-02-16:)  The enc value can be or-ed with SQLITE_UTF16_ALIGNED.\n** If that is the case, then the result must be aligned on an even byte\n** boundary.\n*/\nSQLITE_PRIVATE const void *sqlite3ValueText(sqlite3_value* pVal, u8 enc){\n  if( !pVal ) return 0;\n\n  assert( pVal->db==0 || sqlite3_mutex_held(pVal->db->mutex) );\n  assert( (enc&3)==(enc&~SQLITE_UTF16_ALIGNED) );\n  assert( (pVal->flags & MEM_RowSet)==0 );\n\n  if( pVal->flags&MEM_Null ){\n    return 0;\n  }\n  assert( (MEM_Blob>>3) == MEM_Str );\n  pVal->flags |= (pVal->flags & MEM_Blob)>>3;\n  expandBlob(pVal);\n  if( pVal->flags&MEM_Str ){\n    sqlite3VdbeChangeEncoding(pVal, enc & ~SQLITE_UTF16_ALIGNED);\n    if( (enc & SQLITE_UTF16_ALIGNED)!=0 && 1==(1&SQLITE_PTR_TO_INT(pVal->z)) ){\n      assert( (pVal->flags & (MEM_Ephem|MEM_Static))!=0 );\n      if( sqlite3VdbeMemMakeWriteable(pVal)!=SQLITE_OK ){\n        return 0;\n      }\n    }\n    sqlite3VdbeMemNulTerminate(pVal); /* IMP: R-59893-45467 */\n  }else{\n    assert( (pVal->flags&MEM_Blob)==0 );\n    sqlite3VdbeMemStringify(pVal, enc);\n    assert( 0==(1&SQLITE_PTR_TO_INT(pVal->z)) );\n  }\n  assert(pVal->enc==(enc & ~SQLITE_UTF16_ALIGNED) || pVal->db==0\n              || pVal->db->mallocFailed );\n  if( pVal->enc==(enc & ~SQLITE_UTF16_ALIGNED) ){\n    return pVal->z;\n  }else{\n    return 0;\n  }\n}\n\n/*\n** Create a new sqlite3_value object.\n*/\nSQLITE_PRIVATE sqlite3_value *sqlite3ValueNew(sqlite3 *db){\n  Mem *p = sqlite3DbMallocZero(db, sizeof(*p));\n  if( p ){\n    p->flags = MEM_Null;\n    p->type = SQLITE_NULL;\n    p->db = db;\n  }\n  return p;\n}\n\n/*\n** Create a new sqlite3_value object, containing the value of pExpr.\n**\n** This only works for very simple expressions that consist of one constant\n** token (i.e. \"5\", \"5.1\", \"'a string'\"). If the expression can\n** be converted directly into a value, then the value is allocated and\n** a pointer written to *ppVal. The caller is responsible for deallocating\n** the value by passing it to sqlite3ValueFree() later on. If the expression\n** cannot be converted to a value, then *ppVal is set to NULL.\n*/\nSQLITE_PRIVATE int sqlite3ValueFromExpr(\n  sqlite3 *db,              /* The database connection */\n  Expr *pExpr,              /* The expression to evaluate */\n  u8 enc,                   /* Encoding to use */\n  u8 affinity,              /* Affinity to use */\n  sqlite3_value **ppVal     /* Write the new value here */\n){\n  int op;\n  char *zVal = 0;\n  sqlite3_value *pVal = 0;\n  int negInt = 1;\n  const char *zNeg = \"\";\n\n  if( !pExpr ){\n    *ppVal = 0;\n    return SQLITE_OK;\n  }\n  op = pExpr->op;\n\n  /* op can only be TK_REGISTER if we have compiled with SQLITE_ENABLE_STAT2.\n  ** The ifdef here is to enable us to achieve 100% branch test coverage even\n  ** when SQLITE_ENABLE_STAT2 is omitted.\n  */\n#ifdef SQLITE_ENABLE_STAT2\n  if( op==TK_REGISTER ) op = pExpr->op2;\n#else\n  if( NEVER(op==TK_REGISTER) ) op = pExpr->op2;\n#endif\n\n  /* Handle negative integers in a single step.  This is needed in the\n  ** case when the value is -9223372036854775808.\n  */\n  if( op==TK_UMINUS\n   && (pExpr->pLeft->op==TK_INTEGER || pExpr->pLeft->op==TK_FLOAT) ){\n    pExpr = pExpr->pLeft;\n    op = pExpr->op;\n    negInt = -1;\n    zNeg = \"-\";\n  }\n\n  if( op==TK_STRING || op==TK_FLOAT || op==TK_INTEGER ){\n    pVal = sqlite3ValueNew(db);\n    if( pVal==0 ) goto no_mem;\n    if( ExprHasProperty(pExpr, EP_IntValue) ){\n      sqlite3VdbeMemSetInt64(pVal, (i64)pExpr->u.iValue*negInt);\n    }else{\n      zVal = sqlite3MPrintf(db, \"%s%s\", zNeg, pExpr->u.zToken);\n      if( zVal==0 ) goto no_mem;\n      sqlite3ValueSetStr(pVal, -1, zVal, SQLITE_UTF8, SQLITE_DYNAMIC);\n      if( op==TK_FLOAT ) pVal->type = SQLITE_FLOAT;\n    }\n    if( (op==TK_INTEGER || op==TK_FLOAT ) && affinity==SQLITE_AFF_NONE ){\n      sqlite3ValueApplyAffinity(pVal, SQLITE_AFF_NUMERIC, SQLITE_UTF8);\n    }else{\n      sqlite3ValueApplyAffinity(pVal, affinity, SQLITE_UTF8);\n    }\n    if( pVal->flags & (MEM_Int|MEM_Real) ) pVal->flags &= ~MEM_Str;\n    if( enc!=SQLITE_UTF8 ){\n      sqlite3VdbeChangeEncoding(pVal, enc);\n    }\n  }else if( op==TK_UMINUS ) {\n    /* This branch happens for multiple negative signs.  Ex: -(-5) */\n    if( SQLITE_OK==sqlite3ValueFromExpr(db,pExpr->pLeft,enc,affinity,&pVal) ){\n      sqlite3VdbeMemNumerify(pVal);\n      if( pVal->u.i==SMALLEST_INT64 ){\n        pVal->flags &= MEM_Int;\n        pVal->flags |= MEM_Real;\n        pVal->r = (double)LARGEST_INT64;\n      }else{\n        pVal->u.i = -pVal->u.i;\n      }\n      pVal->r = -pVal->r;\n      sqlite3ValueApplyAffinity(pVal, affinity, enc);\n    }\n  }else if( op==TK_NULL ){\n    pVal = sqlite3ValueNew(db);\n    if( pVal==0 ) goto no_mem;\n  }\n#ifndef SQLITE_OMIT_BLOB_LITERAL\n  else if( op==TK_BLOB ){\n    int nVal;\n    assert( pExpr->u.zToken[0]=='x' || pExpr->u.zToken[0]=='X' );\n    assert( pExpr->u.zToken[1]=='\\'' );\n    pVal = sqlite3ValueNew(db);\n    if( !pVal ) goto no_mem;\n    zVal = &pExpr->u.zToken[2];\n    nVal = sqlite3Strlen30(zVal)-1;\n    assert( zVal[nVal]=='\\'' );\n    sqlite3VdbeMemSetStr(pVal, sqlite3HexToBlob(db, zVal, nVal), nVal/2,\n                         0, SQLITE_DYNAMIC);\n  }\n#endif\n\n  if( pVal ){\n    sqlite3VdbeMemStoreType(pVal);\n  }\n  *ppVal = pVal;\n  return SQLITE_OK;\n\nno_mem:\n  db->mallocFailed = 1;\n  sqlite3DbFree(db, zVal);\n  sqlite3ValueFree(pVal);\n  *ppVal = 0;\n  return SQLITE_NOMEM;\n}\n\n/*\n** Change the string value of an sqlite3_value object\n*/\nSQLITE_PRIVATE void sqlite3ValueSetStr(\n  sqlite3_value *v,     /* Value to be set */\n  int n,                /* Length of string z */\n  const void *z,        /* Text of the new string */\n  u8 enc,               /* Encoding to use */\n  void (*xDel)(void*)   /* Destructor for the string */\n){\n  if( v ) sqlite3VdbeMemSetStr((Mem *)v, z, n, enc, xDel);\n}\n\n/*\n** Free an sqlite3_value object\n*/\nSQLITE_PRIVATE void sqlite3ValueFree(sqlite3_value *v){\n  if( !v ) return;\n  sqlite3VdbeMemRelease((Mem *)v);\n  sqlite3DbFree(((Mem*)v)->db, v);\n}\n\n/*\n** Return the number of bytes in the sqlite3_value object assuming\n** that it uses the encoding \"enc\"\n*/\nSQLITE_PRIVATE int sqlite3ValueBytes(sqlite3_value *pVal, u8 enc){\n  Mem *p = (Mem*)pVal;\n  if( (p->flags & MEM_Blob)!=0 || sqlite3ValueText(pVal, enc) ){\n    if( p->flags & MEM_Zero ){\n      return p->n + p->u.nZero;\n    }else{\n      return p->n;\n    }\n  }\n  return 0;\n}\n\n/************** End of vdbemem.c *********************************************/\n/************** Begin file vdbeaux.c *****************************************/\n/*\n** 2003 September 6\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains code used for creating, destroying, and populating\n** a VDBE (or an \"sqlite3_stmt\" as it is known to the outside world.)  Prior\n** to version 2.8.7, all this code was combined into the vdbe.c source file.\n** But that file was getting too big so this subroutines were split out.\n*/\n\n\n\n/*\n** When debugging the code generator in a symbolic debugger, one can\n** set the sqlite3VdbeAddopTrace to 1 and all opcodes will be printed\n** as they are added to the instruction stream.\n*/\n#ifdef SQLITE_DEBUG\nSQLITE_PRIVATE int sqlite3VdbeAddopTrace = 0;\n#endif\n\n\n/*\n** Create a new virtual database engine.\n*/\nSQLITE_PRIVATE Vdbe *sqlite3VdbeCreate(sqlite3 *db){\n  Vdbe *p;\n  p = sqlite3DbMallocZero(db, sizeof(Vdbe) );\n  if( p==0 ) return 0;\n  p->db = db;\n  if( db->pVdbe ){\n    db->pVdbe->pPrev = p;\n  }\n  p->pNext = db->pVdbe;\n  p->pPrev = 0;\n  db->pVdbe = p;\n  p->magic = VDBE_MAGIC_INIT;\n  return p;\n}\n\n/*\n** Remember the SQL string for a prepared statement.\n*/\nSQLITE_PRIVATE void sqlite3VdbeSetSql(Vdbe *p, const char *z, int n, int isPrepareV2){\n  assert( isPrepareV2==1 || isPrepareV2==0 );\n  if( p==0 ) return;\n#ifdef SQLITE_OMIT_TRACE\n  if( !isPrepareV2 ) return;\n#endif\n  assert( p->zSql==0 );\n  p->zSql = sqlite3DbStrNDup(p->db, z, n);\n  p->isPrepareV2 = (u8)isPrepareV2;\n}\n\n/*\n** Return the SQL associated with a prepared statement\n*/\nSQLITE_API const char *sqlite3_sql(sqlite3_stmt *pStmt){\n  Vdbe *p = (Vdbe *)pStmt;\n  return (p && p->isPrepareV2) ? p->zSql : 0;\n}\n\n/*\n** Swap all content between two VDBE structures.\n*/\nSQLITE_PRIVATE void sqlite3VdbeSwap(Vdbe *pA, Vdbe *pB){\n  Vdbe tmp, *pTmp;\n  char *zTmp;\n  tmp = *pA;\n  *pA = *pB;\n  *pB = tmp;\n  pTmp = pA->pNext;\n  pA->pNext = pB->pNext;\n  pB->pNext = pTmp;\n  pTmp = pA->pPrev;\n  pA->pPrev = pB->pPrev;\n  pB->pPrev = pTmp;\n  zTmp = pA->zSql;\n  pA->zSql = pB->zSql;\n  pB->zSql = zTmp;\n  pB->isPrepareV2 = pA->isPrepareV2;\n}\n\n#ifdef SQLITE_DEBUG\n/*\n** Turn tracing on or off\n*/\nSQLITE_PRIVATE void sqlite3VdbeTrace(Vdbe *p, FILE *trace){\n  p->trace = trace;\n}\n#endif\n\n/*\n** Resize the Vdbe.aOp array so that it is at least one op larger than \n** it was.\n**\n** If an out-of-memory error occurs while resizing the array, return\n** SQLITE_NOMEM. In this case Vdbe.aOp and Vdbe.nOpAlloc remain \n** unchanged (this is so that any opcodes already allocated can be \n** correctly deallocated along with the rest of the Vdbe).\n*/\nstatic int growOpArray(Vdbe *p){\n  VdbeOp *pNew;\n  int nNew = (p->nOpAlloc ? p->nOpAlloc*2 : (int)(1024/sizeof(Op)));\n  pNew = sqlite3DbRealloc(p->db, p->aOp, nNew*sizeof(Op));\n  if( pNew ){\n    p->nOpAlloc = sqlite3DbMallocSize(p->db, pNew)/sizeof(Op);\n    p->aOp = pNew;\n  }\n  return (pNew ? SQLITE_OK : SQLITE_NOMEM);\n}\n\n/*\n** Add a new instruction to the list of instructions current in the\n** VDBE.  Return the address of the new instruction.\n**\n** Parameters:\n**\n**    p               Pointer to the VDBE\n**\n**    op              The opcode for this instruction\n**\n**    p1, p2, p3      Operands\n**\n** Use the sqlite3VdbeResolveLabel() function to fix an address and\n** the sqlite3VdbeChangeP4() function to change the value of the P4\n** operand.\n*/\nSQLITE_PRIVATE int sqlite3VdbeAddOp3(Vdbe *p, int op, int p1, int p2, int p3){\n  int i;\n  VdbeOp *pOp;\n\n  i = p->nOp;\n  assert( p->magic==VDBE_MAGIC_INIT );\n  assert( op>0 && op<0xff );\n  if( p->nOpAlloc<=i ){\n    if( growOpArray(p) ){\n      return 1;\n    }\n  }\n  p->nOp++;\n  pOp = &p->aOp[i];\n  pOp->opcode = (u8)op;\n  pOp->p5 = 0;\n  pOp->p1 = p1;\n  pOp->p2 = p2;\n  pOp->p3 = p3;\n  pOp->p4.p = 0;\n  pOp->p4type = P4_NOTUSED;\n  p->expired = 0;\n#ifdef SQLITE_DEBUG\n  pOp->zComment = 0;\n  if( sqlite3VdbeAddopTrace ) sqlite3VdbePrintOp(0, i, &p->aOp[i]);\n#endif\n#ifdef VDBE_PROFILE\n  pOp->cycles = 0;\n  pOp->cnt = 0;\n#endif\n  return i;\n}\nSQLITE_PRIVATE int sqlite3VdbeAddOp0(Vdbe *p, int op){\n  return sqlite3VdbeAddOp3(p, op, 0, 0, 0);\n}\nSQLITE_PRIVATE int sqlite3VdbeAddOp1(Vdbe *p, int op, int p1){\n  return sqlite3VdbeAddOp3(p, op, p1, 0, 0);\n}\nSQLITE_PRIVATE int sqlite3VdbeAddOp2(Vdbe *p, int op, int p1, int p2){\n  return sqlite3VdbeAddOp3(p, op, p1, p2, 0);\n}\n\n\n/*\n** Add an opcode that includes the p4 value as a pointer.\n*/\nSQLITE_PRIVATE int sqlite3VdbeAddOp4(\n  Vdbe *p,            /* Add the opcode to this VM */\n  int op,             /* The new opcode */\n  int p1,             /* The P1 operand */\n  int p2,             /* The P2 operand */\n  int p3,             /* The P3 operand */\n  const char *zP4,    /* The P4 operand */\n  int p4type          /* P4 operand type */\n){\n  int addr = sqlite3VdbeAddOp3(p, op, p1, p2, p3);\n  sqlite3VdbeChangeP4(p, addr, zP4, p4type);\n  return addr;\n}\n\n/*\n** Add an opcode that includes the p4 value as an integer.\n*/\nSQLITE_PRIVATE int sqlite3VdbeAddOp4Int(\n  Vdbe *p,            /* Add the opcode to this VM */\n  int op,             /* The new opcode */\n  int p1,             /* The P1 operand */\n  int p2,             /* The P2 operand */\n  int p3,             /* The P3 operand */\n  int p4              /* The P4 operand as an integer */\n){\n  int addr = sqlite3VdbeAddOp3(p, op, p1, p2, p3);\n  sqlite3VdbeChangeP4(p, addr, SQLITE_INT_TO_PTR(p4), P4_INT32);\n  return addr;\n}\n\n/*\n** Create a new symbolic label for an instruction that has yet to be\n** coded.  The symbolic label is really just a negative number.  The\n** label can be used as the P2 value of an operation.  Later, when\n** the label is resolved to a specific address, the VDBE will scan\n** through its operation list and change all values of P2 which match\n** the label into the resolved address.\n**\n** The VDBE knows that a P2 value is a label because labels are\n** always negative and P2 values are suppose to be non-negative.\n** Hence, a negative P2 value is a label that has yet to be resolved.\n**\n** Zero is returned if a malloc() fails.\n*/\nSQLITE_PRIVATE int sqlite3VdbeMakeLabel(Vdbe *p){\n  int i;\n  i = p->nLabel++;\n  assert( p->magic==VDBE_MAGIC_INIT );\n  if( i>=p->nLabelAlloc ){\n    int n = p->nLabelAlloc*2 + 5;\n    p->aLabel = sqlite3DbReallocOrFree(p->db, p->aLabel,\n                                       n*sizeof(p->aLabel[0]));\n    p->nLabelAlloc = sqlite3DbMallocSize(p->db, p->aLabel)/sizeof(p->aLabel[0]);\n  }\n  if( p->aLabel ){\n    p->aLabel[i] = -1;\n  }\n  return -1-i;\n}\n\n/*\n** Resolve label \"x\" to be the address of the next instruction to\n** be inserted.  The parameter \"x\" must have been obtained from\n** a prior call to sqlite3VdbeMakeLabel().\n*/\nSQLITE_PRIVATE void sqlite3VdbeResolveLabel(Vdbe *p, int x){\n  int j = -1-x;\n  assert( p->magic==VDBE_MAGIC_INIT );\n  assert( j>=0 && j<p->nLabel );\n  if( p->aLabel ){\n    p->aLabel[j] = p->nOp;\n  }\n}\n\n/*\n** Mark the VDBE as one that can only be run one time.\n*/\nSQLITE_PRIVATE void sqlite3VdbeRunOnlyOnce(Vdbe *p){\n  p->runOnlyOnce = 1;\n}\n\n#ifdef SQLITE_DEBUG /* sqlite3AssertMayAbort() logic */\n\n/*\n** The following type and function are used to iterate through all opcodes\n** in a Vdbe main program and each of the sub-programs (triggers) it may \n** invoke directly or indirectly. It should be used as follows:\n**\n**   Op *pOp;\n**   VdbeOpIter sIter;\n**\n**   memset(&sIter, 0, sizeof(sIter));\n**   sIter.v = v;                            // v is of type Vdbe* \n**   while( (pOp = opIterNext(&sIter)) ){\n**     // Do something with pOp\n**   }\n**   sqlite3DbFree(v->db, sIter.apSub);\n** \n*/\ntypedef struct VdbeOpIter VdbeOpIter;\nstruct VdbeOpIter {\n  Vdbe *v;                   /* Vdbe to iterate through the opcodes of */\n  SubProgram **apSub;        /* Array of subprograms */\n  int nSub;                  /* Number of entries in apSub */\n  int iAddr;                 /* Address of next instruction to return */\n  int iSub;                  /* 0 = main program, 1 = first sub-program etc. */\n};\nstatic Op *opIterNext(VdbeOpIter *p){\n  Vdbe *v = p->v;\n  Op *pRet = 0;\n  Op *aOp;\n  int nOp;\n\n  if( p->iSub<=p->nSub ){\n\n    if( p->iSub==0 ){\n      aOp = v->aOp;\n      nOp = v->nOp;\n    }else{\n      aOp = p->apSub[p->iSub-1]->aOp;\n      nOp = p->apSub[p->iSub-1]->nOp;\n    }\n    assert( p->iAddr<nOp );\n\n    pRet = &aOp[p->iAddr];\n    p->iAddr++;\n    if( p->iAddr==nOp ){\n      p->iSub++;\n      p->iAddr = 0;\n    }\n  \n    if( pRet->p4type==P4_SUBPROGRAM ){\n      int nByte = (p->nSub+1)*sizeof(SubProgram*);\n      int j;\n      for(j=0; j<p->nSub; j++){\n        if( p->apSub[j]==pRet->p4.pProgram ) break;\n      }\n      if( j==p->nSub ){\n        p->apSub = sqlite3DbReallocOrFree(v->db, p->apSub, nByte);\n        if( !p->apSub ){\n          pRet = 0;\n        }else{\n          p->apSub[p->nSub++] = pRet->p4.pProgram;\n        }\n      }\n    }\n  }\n\n  return pRet;\n}\n\n/*\n** Check if the program stored in the VM associated with pParse may\n** throw an ABORT exception (causing the statement, but not entire transaction\n** to be rolled back). This condition is true if the main program or any\n** sub-programs contains any of the following:\n**\n**   *  OP_Halt with P1=SQLITE_CONSTRAINT and P2=OE_Abort.\n**   *  OP_HaltIfNull with P1=SQLITE_CONSTRAINT and P2=OE_Abort.\n**   *  OP_Destroy\n**   *  OP_VUpdate\n**   *  OP_VRename\n**   *  OP_FkCounter with P2==0 (immediate foreign key constraint)\n**\n** Then check that the value of Parse.mayAbort is true if an\n** ABORT may be thrown, or false otherwise. Return true if it does\n** match, or false otherwise. This function is intended to be used as\n** part of an assert statement in the compiler. Similar to:\n**\n**   assert( sqlite3VdbeAssertMayAbort(pParse->pVdbe, pParse->mayAbort) );\n*/\nSQLITE_PRIVATE int sqlite3VdbeAssertMayAbort(Vdbe *v, int mayAbort){\n  int hasAbort = 0;\n  Op *pOp;\n  VdbeOpIter sIter;\n  memset(&sIter, 0, sizeof(sIter));\n  sIter.v = v;\n\n  while( (pOp = opIterNext(&sIter))!=0 ){\n    int opcode = pOp->opcode;\n    if( opcode==OP_Destroy || opcode==OP_VUpdate || opcode==OP_VRename \n#ifndef SQLITE_OMIT_FOREIGN_KEY\n     || (opcode==OP_FkCounter && pOp->p1==0 && pOp->p2==1) \n#endif\n     || ((opcode==OP_Halt || opcode==OP_HaltIfNull) \n      && (pOp->p1==SQLITE_CONSTRAINT && pOp->p2==OE_Abort))\n    ){\n      hasAbort = 1;\n      break;\n    }\n  }\n  sqlite3DbFree(v->db, sIter.apSub);\n\n  /* Return true if hasAbort==mayAbort. Or if a malloc failure occured.\n  ** If malloc failed, then the while() loop above may not have iterated\n  ** through all opcodes and hasAbort may be set incorrectly. Return\n  ** true for this case to prevent the assert() in the callers frame\n  ** from failing.  */\n  return ( v->db->mallocFailed || hasAbort==mayAbort );\n}\n#endif /* SQLITE_DEBUG - the sqlite3AssertMayAbort() function */\n\n/*\n** Loop through the program looking for P2 values that are negative\n** on jump instructions.  Each such value is a label.  Resolve the\n** label by setting the P2 value to its correct non-zero value.\n**\n** This routine is called once after all opcodes have been inserted.\n**\n** Variable *pMaxFuncArgs is set to the maximum value of any P2 argument \n** to an OP_Function, OP_AggStep or OP_VFilter opcode. This is used by \n** sqlite3VdbeMakeReady() to size the Vdbe.apArg[] array.\n**\n** The Op.opflags field is set on all opcodes.\n*/\nstatic void resolveP2Values(Vdbe *p, int *pMaxFuncArgs){\n  int i;\n  int nMaxArgs = *pMaxFuncArgs;\n  Op *pOp;\n  int *aLabel = p->aLabel;\n  p->readOnly = 1;\n  for(pOp=p->aOp, i=p->nOp-1; i>=0; i--, pOp++){\n    u8 opcode = pOp->opcode;\n\n    pOp->opflags = sqlite3OpcodeProperty[opcode];\n    if( opcode==OP_Function || opcode==OP_AggStep ){\n      if( pOp->p5>nMaxArgs ) nMaxArgs = pOp->p5;\n    }else if( (opcode==OP_Transaction && pOp->p2!=0) || opcode==OP_Vacuum ){\n      p->readOnly = 0;\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n    }else if( opcode==OP_VUpdate ){\n      if( pOp->p2>nMaxArgs ) nMaxArgs = pOp->p2;\n    }else if( opcode==OP_VFilter ){\n      int n;\n      assert( p->nOp - i >= 3 );\n      assert( pOp[-1].opcode==OP_Integer );\n      n = pOp[-1].p1;\n      if( n>nMaxArgs ) nMaxArgs = n;\n#endif\n    }\n\n    if( (pOp->opflags & OPFLG_JUMP)!=0 && pOp->p2<0 ){\n      assert( -1-pOp->p2<p->nLabel );\n      pOp->p2 = aLabel[-1-pOp->p2];\n    }\n  }\n  sqlite3DbFree(p->db, p->aLabel);\n  p->aLabel = 0;\n\n  *pMaxFuncArgs = nMaxArgs;\n}\n\n/*\n** Return the address of the next instruction to be inserted.\n*/\nSQLITE_PRIVATE int sqlite3VdbeCurrentAddr(Vdbe *p){\n  assert( p->magic==VDBE_MAGIC_INIT );\n  return p->nOp;\n}\n\n/*\n** This function returns a pointer to the array of opcodes associated with\n** the Vdbe passed as the first argument. It is the callers responsibility\n** to arrange for the returned array to be eventually freed using the \n** vdbeFreeOpArray() function.\n**\n** Before returning, *pnOp is set to the number of entries in the returned\n** array. Also, *pnMaxArg is set to the larger of its current value and \n** the number of entries in the Vdbe.apArg[] array required to execute the \n** returned program.\n*/\nSQLITE_PRIVATE VdbeOp *sqlite3VdbeTakeOpArray(Vdbe *p, int *pnOp, int *pnMaxArg){\n  VdbeOp *aOp = p->aOp;\n  assert( aOp && !p->db->mallocFailed );\n\n  /* Check that sqlite3VdbeUsesBtree() was not called on this VM */\n  assert( p->aMutex.nMutex==0 );\n\n  resolveP2Values(p, pnMaxArg);\n  *pnOp = p->nOp;\n  p->aOp = 0;\n  return aOp;\n}\n\n/*\n** Add a whole list of operations to the operation stack.  Return the\n** address of the first operation added.\n*/\nSQLITE_PRIVATE int sqlite3VdbeAddOpList(Vdbe *p, int nOp, VdbeOpList const *aOp){\n  int addr;\n  assert( p->magic==VDBE_MAGIC_INIT );\n  if( p->nOp + nOp > p->nOpAlloc && growOpArray(p) ){\n    return 0;\n  }\n  addr = p->nOp;\n  if( ALWAYS(nOp>0) ){\n    int i;\n    VdbeOpList const *pIn = aOp;\n    for(i=0; i<nOp; i++, pIn++){\n      int p2 = pIn->p2;\n      VdbeOp *pOut = &p->aOp[i+addr];\n      pOut->opcode = pIn->opcode;\n      pOut->p1 = pIn->p1;\n      if( p2<0 && (sqlite3OpcodeProperty[pOut->opcode] & OPFLG_JUMP)!=0 ){\n        pOut->p2 = addr + ADDR(p2);\n      }else{\n        pOut->p2 = p2;\n      }\n      pOut->p3 = pIn->p3;\n      pOut->p4type = P4_NOTUSED;\n      pOut->p4.p = 0;\n      pOut->p5 = 0;\n#ifdef SQLITE_DEBUG\n      pOut->zComment = 0;\n      if( sqlite3VdbeAddopTrace ){\n        sqlite3VdbePrintOp(0, i+addr, &p->aOp[i+addr]);\n      }\n#endif\n    }\n    p->nOp += nOp;\n  }\n  return addr;\n}\n\n/*\n** Change the value of the P1 operand for a specific instruction.\n** This routine is useful when a large program is loaded from a\n** static array using sqlite3VdbeAddOpList but we want to make a\n** few minor changes to the program.\n*/\nSQLITE_PRIVATE void sqlite3VdbeChangeP1(Vdbe *p, int addr, int val){\n  assert( p!=0 );\n  assert( addr>=0 );\n  if( p->nOp>addr ){\n    p->aOp[addr].p1 = val;\n  }\n}\n\n/*\n** Change the value of the P2 operand for a specific instruction.\n** This routine is useful for setting a jump destination.\n*/\nSQLITE_PRIVATE void sqlite3VdbeChangeP2(Vdbe *p, int addr, int val){\n  assert( p!=0 );\n  assert( addr>=0 );\n  if( p->nOp>addr ){\n    p->aOp[addr].p2 = val;\n  }\n}\n\n/*\n** Change the value of the P3 operand for a specific instruction.\n*/\nSQLITE_PRIVATE void sqlite3VdbeChangeP3(Vdbe *p, int addr, int val){\n  assert( p!=0 );\n  assert( addr>=0 );\n  if( p->nOp>addr ){\n    p->aOp[addr].p3 = val;\n  }\n}\n\n/*\n** Change the value of the P5 operand for the most recently\n** added operation.\n*/\nSQLITE_PRIVATE void sqlite3VdbeChangeP5(Vdbe *p, u8 val){\n  assert( p!=0 );\n  if( p->aOp ){\n    assert( p->nOp>0 );\n    p->aOp[p->nOp-1].p5 = val;\n  }\n}\n\n/*\n** Change the P2 operand of instruction addr so that it points to\n** the address of the next instruction to be coded.\n*/\nSQLITE_PRIVATE void sqlite3VdbeJumpHere(Vdbe *p, int addr){\n  sqlite3VdbeChangeP2(p, addr, p->nOp);\n}\n\n\n/*\n** If the input FuncDef structure is ephemeral, then free it.  If\n** the FuncDef is not ephermal, then do nothing.\n*/\nstatic void freeEphemeralFunction(sqlite3 *db, FuncDef *pDef){\n  if( ALWAYS(pDef) && (pDef->flags & SQLITE_FUNC_EPHEM)!=0 ){\n    sqlite3DbFree(db, pDef);\n  }\n}\n\nstatic void vdbeFreeOpArray(sqlite3 *, Op *, int);\n\n/*\n** Delete a P4 value if necessary.\n*/\nstatic void freeP4(sqlite3 *db, int p4type, void *p4){\n  if( p4 ){\n    assert( db );\n    switch( p4type ){\n      case P4_REAL:\n      case P4_INT64:\n      case P4_DYNAMIC:\n      case P4_KEYINFO:\n      case P4_INTARRAY:\n      case P4_KEYINFO_HANDOFF: {\n        sqlite3DbFree(db, p4);\n        break;\n      }\n      case P4_MPRINTF: {\n        if( db->pnBytesFreed==0 ) sqlite3_free(p4);\n        break;\n      }\n      case P4_VDBEFUNC: {\n        VdbeFunc *pVdbeFunc = (VdbeFunc *)p4;\n        freeEphemeralFunction(db, pVdbeFunc->pFunc);\n        if( db->pnBytesFreed==0 ) sqlite3VdbeDeleteAuxData(pVdbeFunc, 0);\n        sqlite3DbFree(db, pVdbeFunc);\n        break;\n      }\n      case P4_FUNCDEF: {\n        freeEphemeralFunction(db, (FuncDef*)p4);\n        break;\n      }\n      case P4_MEM: {\n        if( db->pnBytesFreed==0 ){\n          sqlite3ValueFree((sqlite3_value*)p4);\n        }else{\n          Mem *p = (Mem*)p4;\n          sqlite3DbFree(db, p->zMalloc);\n          sqlite3DbFree(db, p);\n        }\n        break;\n      }\n      case P4_VTAB : {\n        if( db->pnBytesFreed==0 ) sqlite3VtabUnlock((VTable *)p4);\n        break;\n      }\n    }\n  }\n}\n\n/*\n** Free the space allocated for aOp and any p4 values allocated for the\n** opcodes contained within. If aOp is not NULL it is assumed to contain \n** nOp entries. \n*/\nstatic void vdbeFreeOpArray(sqlite3 *db, Op *aOp, int nOp){\n  if( aOp ){\n    Op *pOp;\n    for(pOp=aOp; pOp<&aOp[nOp]; pOp++){\n      freeP4(db, pOp->p4type, pOp->p4.p);\n#ifdef SQLITE_DEBUG\n      sqlite3DbFree(db, pOp->zComment);\n#endif     \n    }\n  }\n  sqlite3DbFree(db, aOp);\n}\n\n/*\n** Link the SubProgram object passed as the second argument into the linked\n** list at Vdbe.pSubProgram. This list is used to delete all sub-program\n** objects when the VM is no longer required.\n*/\nSQLITE_PRIVATE void sqlite3VdbeLinkSubProgram(Vdbe *pVdbe, SubProgram *p){\n  p->pNext = pVdbe->pProgram;\n  pVdbe->pProgram = p;\n}\n\n/*\n** Change N opcodes starting at addr to No-ops.\n*/\nSQLITE_PRIVATE void sqlite3VdbeChangeToNoop(Vdbe *p, int addr, int N){\n  if( p->aOp ){\n    VdbeOp *pOp = &p->aOp[addr];\n    sqlite3 *db = p->db;\n    while( N-- ){\n      freeP4(db, pOp->p4type, pOp->p4.p);\n      memset(pOp, 0, sizeof(pOp[0]));\n      pOp->opcode = OP_Noop;\n      pOp++;\n    }\n  }\n}\n\n/*\n** Change the value of the P4 operand for a specific instruction.\n** This routine is useful when a large program is loaded from a\n** static array using sqlite3VdbeAddOpList but we want to make a\n** few minor changes to the program.\n**\n** If n>=0 then the P4 operand is dynamic, meaning that a copy of\n** the string is made into memory obtained from sqlite3_malloc().\n** A value of n==0 means copy bytes of zP4 up to and including the\n** first null byte.  If n>0 then copy n+1 bytes of zP4.\n**\n** If n==P4_KEYINFO it means that zP4 is a pointer to a KeyInfo structure.\n** A copy is made of the KeyInfo structure into memory obtained from\n** sqlite3_malloc, to be freed when the Vdbe is finalized.\n** n==P4_KEYINFO_HANDOFF indicates that zP4 points to a KeyInfo structure\n** stored in memory that the caller has obtained from sqlite3_malloc. The \n** caller should not free the allocation, it will be freed when the Vdbe is\n** finalized.\n** \n** Other values of n (P4_STATIC, P4_COLLSEQ etc.) indicate that zP4 points\n** to a string or structure that is guaranteed to exist for the lifetime of\n** the Vdbe. In these cases we can just copy the pointer.\n**\n** If addr<0 then change P4 on the most recently inserted instruction.\n*/\nSQLITE_PRIVATE void sqlite3VdbeChangeP4(Vdbe *p, int addr, const char *zP4, int n){\n  Op *pOp;\n  sqlite3 *db;\n  assert( p!=0 );\n  db = p->db;\n  assert( p->magic==VDBE_MAGIC_INIT );\n  if( p->aOp==0 || db->mallocFailed ){\n    if ( n!=P4_KEYINFO && n!=P4_VTAB ) {\n      freeP4(db, n, (void*)*(char**)&zP4);\n    }\n    return;\n  }\n  assert( p->nOp>0 );\n  assert( addr<p->nOp );\n  if( addr<0 ){\n    addr = p->nOp - 1;\n  }\n  pOp = &p->aOp[addr];\n  freeP4(db, pOp->p4type, pOp->p4.p);\n  pOp->p4.p = 0;\n  if( n==P4_INT32 ){\n    /* Note: this cast is safe, because the origin data point was an int\n    ** that was cast to a (const char *). */\n    pOp->p4.i = SQLITE_PTR_TO_INT(zP4);\n    pOp->p4type = P4_INT32;\n  }else if( zP4==0 ){\n    pOp->p4.p = 0;\n    pOp->p4type = P4_NOTUSED;\n  }else if( n==P4_KEYINFO ){\n    KeyInfo *pKeyInfo;\n    int nField, nByte;\n\n    nField = ((KeyInfo*)zP4)->nField;\n    nByte = sizeof(*pKeyInfo) + (nField-1)*sizeof(pKeyInfo->aColl[0]) + nField;\n    pKeyInfo = sqlite3DbMallocRaw(0, nByte);\n    pOp->p4.pKeyInfo = pKeyInfo;\n    if( pKeyInfo ){\n      u8 *aSortOrder;\n      memcpy((char*)pKeyInfo, zP4, nByte - nField);\n      aSortOrder = pKeyInfo->aSortOrder;\n      if( aSortOrder ){\n        pKeyInfo->aSortOrder = (unsigned char*)&pKeyInfo->aColl[nField];\n        memcpy(pKeyInfo->aSortOrder, aSortOrder, nField);\n      }\n      pOp->p4type = P4_KEYINFO;\n    }else{\n      p->db->mallocFailed = 1;\n      pOp->p4type = P4_NOTUSED;\n    }\n  }else if( n==P4_KEYINFO_HANDOFF ){\n    pOp->p4.p = (void*)zP4;\n    pOp->p4type = P4_KEYINFO;\n  }else if( n==P4_VTAB ){\n    pOp->p4.p = (void*)zP4;\n    pOp->p4type = P4_VTAB;\n    sqlite3VtabLock((VTable *)zP4);\n    assert( ((VTable *)zP4)->db==p->db );\n  }else if( n<0 ){\n    pOp->p4.p = (void*)zP4;\n    pOp->p4type = (signed char)n;\n  }else{\n    if( n==0 ) n = sqlite3Strlen30(zP4);\n    pOp->p4.z = sqlite3DbStrNDup(p->db, zP4, n);\n    pOp->p4type = P4_DYNAMIC;\n  }\n}\n\n#ifndef NDEBUG\n/*\n** Change the comment on the the most recently coded instruction.  Or\n** insert a No-op and add the comment to that new instruction.  This\n** makes the code easier to read during debugging.  None of this happens\n** in a production build.\n*/\nSQLITE_PRIVATE void sqlite3VdbeComment(Vdbe *p, const char *zFormat, ...){\n  va_list ap;\n  if( !p ) return;\n  assert( p->nOp>0 || p->aOp==0 );\n  assert( p->aOp==0 || p->aOp[p->nOp-1].zComment==0 || p->db->mallocFailed );\n  if( p->nOp ){\n    char **pz = &p->aOp[p->nOp-1].zComment;\n    va_start(ap, zFormat);\n    sqlite3DbFree(p->db, *pz);\n    *pz = sqlite3VMPrintf(p->db, zFormat, ap);\n    va_end(ap);\n  }\n}\nSQLITE_PRIVATE void sqlite3VdbeNoopComment(Vdbe *p, const char *zFormat, ...){\n  va_list ap;\n  if( !p ) return;\n  sqlite3VdbeAddOp0(p, OP_Noop);\n  assert( p->nOp>0 || p->aOp==0 );\n  assert( p->aOp==0 || p->aOp[p->nOp-1].zComment==0 || p->db->mallocFailed );\n  if( p->nOp ){\n    char **pz = &p->aOp[p->nOp-1].zComment;\n    va_start(ap, zFormat);\n    sqlite3DbFree(p->db, *pz);\n    *pz = sqlite3VMPrintf(p->db, zFormat, ap);\n    va_end(ap);\n  }\n}\n#endif  /* NDEBUG */\n\n/*\n** Return the opcode for a given address.  If the address is -1, then\n** return the most recently inserted opcode.\n**\n** If a memory allocation error has occurred prior to the calling of this\n** routine, then a pointer to a dummy VdbeOp will be returned.  That opcode\n** is readable but not writable, though it is cast to a writable value.\n** The return of a dummy opcode allows the call to continue functioning\n** after a OOM fault without having to check to see if the return from \n** this routine is a valid pointer.  But because the dummy.opcode is 0,\n** dummy will never be written to.  This is verified by code inspection and\n** by running with Valgrind.\n**\n** About the #ifdef SQLITE_OMIT_TRACE:  Normally, this routine is never called\n** unless p->nOp>0.  This is because in the absense of SQLITE_OMIT_TRACE,\n** an OP_Trace instruction is always inserted by sqlite3VdbeGet() as soon as\n** a new VDBE is created.  So we are free to set addr to p->nOp-1 without\n** having to double-check to make sure that the result is non-negative. But\n** if SQLITE_OMIT_TRACE is defined, the OP_Trace is omitted and we do need to\n** check the value of p->nOp-1 before continuing.\n*/\nSQLITE_PRIVATE VdbeOp *sqlite3VdbeGetOp(Vdbe *p, int addr){\n  /* C89 specifies that the constant \"dummy\" will be initialized to all\n  ** zeros, which is correct.  MSVC generates a warning, nevertheless. */\n  static const VdbeOp dummy;  /* Ignore the MSVC warning about no initializer */\n  assert( p->magic==VDBE_MAGIC_INIT );\n  if( addr<0 ){\n#ifdef SQLITE_OMIT_TRACE\n    if( p->nOp==0 ) return (VdbeOp*)&dummy;\n#endif\n    addr = p->nOp - 1;\n  }\n  assert( (addr>=0 && addr<p->nOp) || p->db->mallocFailed );\n  if( p->db->mallocFailed ){\n    return (VdbeOp*)&dummy;\n  }else{\n    return &p->aOp[addr];\n  }\n}\n\n#if !defined(SQLITE_OMIT_EXPLAIN) || !defined(NDEBUG) \\\n     || defined(VDBE_PROFILE) || defined(SQLITE_DEBUG)\n/*\n** Compute a string that describes the P4 parameter for an opcode.\n** Use zTemp for any required temporary buffer space.\n*/\nstatic char *displayP4(Op *pOp, char *zTemp, int nTemp){\n  char *zP4 = zTemp;\n  assert( nTemp>=20 );\n  switch( pOp->p4type ){\n    case P4_KEYINFO_STATIC:\n    case P4_KEYINFO: {\n      int i, j;\n      KeyInfo *pKeyInfo = pOp->p4.pKeyInfo;\n      sqlite3_snprintf(nTemp, zTemp, \"keyinfo(%d\", pKeyInfo->nField);\n      i = sqlite3Strlen30(zTemp);\n      for(j=0; j<pKeyInfo->nField; j++){\n        CollSeq *pColl = pKeyInfo->aColl[j];\n        if( pColl ){\n          int n = sqlite3Strlen30(pColl->zName);\n          if( i+n>nTemp-6 ){\n            memcpy(&zTemp[i],\",...\",4);\n            break;\n          }\n          zTemp[i++] = ',';\n          if( pKeyInfo->aSortOrder && pKeyInfo->aSortOrder[j] ){\n            zTemp[i++] = '-';\n          }\n          memcpy(&zTemp[i], pColl->zName,n+1);\n          i += n;\n        }else if( i+4<nTemp-6 ){\n          memcpy(&zTemp[i],\",nil\",4);\n          i += 4;\n        }\n      }\n      zTemp[i++] = ')';\n      zTemp[i] = 0;\n      assert( i<nTemp );\n      break;\n    }\n    case P4_COLLSEQ: {\n      CollSeq *pColl = pOp->p4.pColl;\n      sqlite3_snprintf(nTemp, zTemp, \"collseq(%.20s)\", pColl->zName);\n      break;\n    }\n    case P4_FUNCDEF: {\n      FuncDef *pDef = pOp->p4.pFunc;\n      sqlite3_snprintf(nTemp, zTemp, \"%s(%d)\", pDef->zName, pDef->nArg);\n      break;\n    }\n    case P4_INT64: {\n      sqlite3_snprintf(nTemp, zTemp, \"%lld\", *pOp->p4.pI64);\n      break;\n    }\n    case P4_INT32: {\n      sqlite3_snprintf(nTemp, zTemp, \"%d\", pOp->p4.i);\n      break;\n    }\n    case P4_REAL: {\n      sqlite3_snprintf(nTemp, zTemp, \"%.16g\", *pOp->p4.pReal);\n      break;\n    }\n    case P4_MEM: {\n      Mem *pMem = pOp->p4.pMem;\n      assert( (pMem->flags & MEM_Null)==0 );\n      if( pMem->flags & MEM_Str ){\n        zP4 = pMem->z;\n      }else if( pMem->flags & MEM_Int ){\n        sqlite3_snprintf(nTemp, zTemp, \"%lld\", pMem->u.i);\n      }else if( pMem->flags & MEM_Real ){\n        sqlite3_snprintf(nTemp, zTemp, \"%.16g\", pMem->r);\n      }else{\n        assert( pMem->flags & MEM_Blob );\n        zP4 = \"(blob)\";\n      }\n      break;\n    }\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n    case P4_VTAB: {\n      sqlite3_vtab *pVtab = pOp->p4.pVtab->pVtab;\n      sqlite3_snprintf(nTemp, zTemp, \"vtab:%p:%p\", pVtab, pVtab->pModule);\n      break;\n    }\n#endif\n    case P4_INTARRAY: {\n      sqlite3_snprintf(nTemp, zTemp, \"intarray\");\n      break;\n    }\n    case P4_SUBPROGRAM: {\n      sqlite3_snprintf(nTemp, zTemp, \"program\");\n      break;\n    }\n    default: {\n      zP4 = pOp->p4.z;\n      if( zP4==0 ){\n        zP4 = zTemp;\n        zTemp[0] = 0;\n      }\n    }\n  }\n  assert( zP4!=0 );\n  return zP4;\n}\n#endif\n\n/*\n** Declare to the Vdbe that the BTree object at db->aDb[i] is used.\n**\n** The prepared statement has to know in advance which Btree objects\n** will be used so that it can acquire mutexes on them all in sorted\n** order (via sqlite3VdbeMutexArrayEnter().  Mutexes are acquired\n** in order (and released in reverse order) to avoid deadlocks.\n*/\nSQLITE_PRIVATE void sqlite3VdbeUsesBtree(Vdbe *p, int i){\n  int mask;\n  assert( i>=0 && i<p->db->nDb && i<sizeof(u32)*8 );\n  assert( i<(int)sizeof(p->btreeMask)*8 );\n  mask = ((u32)1)<<i;\n  if( (p->btreeMask & mask)==0 ){\n    p->btreeMask |= mask;\n    sqlite3BtreeMutexArrayInsert(&p->aMutex, p->db->aDb[i].pBt);\n  }\n}\n\n\n#if defined(VDBE_PROFILE) || defined(SQLITE_DEBUG)\n/*\n** Print a single opcode.  This routine is used for debugging only.\n*/\nSQLITE_PRIVATE void sqlite3VdbePrintOp(FILE *pOut, int pc, Op *pOp){\n  char *zP4;\n  char zPtr[50];\n  static const char *zFormat1 = \"%4d %-13s %4d %4d %4d %-4s %.2X %s\\n\";\n  if( pOut==0 ) pOut = stdout;\n  zP4 = displayP4(pOp, zPtr, sizeof(zPtr));\n  fprintf(pOut, zFormat1, pc, \n      sqlite3OpcodeName(pOp->opcode), pOp->p1, pOp->p2, pOp->p3, zP4, pOp->p5,\n#ifdef SQLITE_DEBUG\n      pOp->zComment ? pOp->zComment : \"\"\n#else\n      \"\"\n#endif\n  );\n  fflush(pOut);\n}\n#endif\n\n/*\n** Release an array of N Mem elements\n*/\nstatic void releaseMemArray(Mem *p, int N){\n  if( p && N ){\n    Mem *pEnd;\n    sqlite3 *db = p->db;\n    u8 malloc_failed = db->mallocFailed;\n    if( db->pnBytesFreed ){\n      for(pEnd=&p[N]; p<pEnd; p++){\n        sqlite3DbFree(db, p->zMalloc);\n      }\n      return;\n    }\n    for(pEnd=&p[N]; p<pEnd; p++){\n      assert( (&p[1])==pEnd || p[0].db==p[1].db );\n\n      /* This block is really an inlined version of sqlite3VdbeMemRelease()\n      ** that takes advantage of the fact that the memory cell value is \n      ** being set to NULL after releasing any dynamic resources.\n      **\n      ** The justification for duplicating code is that according to \n      ** callgrind, this causes a certain test case to hit the CPU 4.7 \n      ** percent less (x86 linux, gcc version 4.1.2, -O6) than if \n      ** sqlite3MemRelease() were called from here. With -O2, this jumps\n      ** to 6.6 percent. The test case is inserting 1000 rows into a table \n      ** with no indexes using a single prepared INSERT statement, bind() \n      ** and reset(). Inserts are grouped into a transaction.\n      */\n      if( p->flags&(MEM_Agg|MEM_Dyn|MEM_Frame|MEM_RowSet) ){\n        sqlite3VdbeMemRelease(p);\n      }else if( p->zMalloc ){\n        sqlite3DbFree(db, p->zMalloc);\n        p->zMalloc = 0;\n      }\n\n      p->flags = MEM_Null;\n    }\n    db->mallocFailed = malloc_failed;\n  }\n}\n\n/*\n** Delete a VdbeFrame object and its contents. VdbeFrame objects are\n** allocated by the OP_Program opcode in sqlite3VdbeExec().\n*/\nSQLITE_PRIVATE void sqlite3VdbeFrameDelete(VdbeFrame *p){\n  int i;\n  Mem *aMem = VdbeFrameMem(p);\n  VdbeCursor **apCsr = (VdbeCursor **)&aMem[p->nChildMem];\n  for(i=0; i<p->nChildCsr; i++){\n    sqlite3VdbeFreeCursor(p->v, apCsr[i]);\n  }\n  releaseMemArray(aMem, p->nChildMem);\n  sqlite3DbFree(p->v->db, p);\n}\n\n#ifndef SQLITE_OMIT_EXPLAIN\n/*\n** Give a listing of the program in the virtual machine.\n**\n** The interface is the same as sqlite3VdbeExec().  But instead of\n** running the code, it invokes the callback once for each instruction.\n** This feature is used to implement \"EXPLAIN\".\n**\n** When p->explain==1, each instruction is listed.  When\n** p->explain==2, only OP_Explain instructions are listed and these\n** are shown in a different format.  p->explain==2 is used to implement\n** EXPLAIN QUERY PLAN.\n**\n** When p->explain==1, first the main program is listed, then each of\n** the trigger subprograms are listed one by one.\n*/\nSQLITE_PRIVATE int sqlite3VdbeList(\n  Vdbe *p                   /* The VDBE */\n){\n  int nRow;                            /* Stop when row count reaches this */\n  int nSub = 0;                        /* Number of sub-vdbes seen so far */\n  SubProgram **apSub = 0;              /* Array of sub-vdbes */\n  Mem *pSub = 0;                       /* Memory cell hold array of subprogs */\n  sqlite3 *db = p->db;                 /* The database connection */\n  int i;                               /* Loop counter */\n  int rc = SQLITE_OK;                  /* Return code */\n  Mem *pMem = p->pResultSet = &p->aMem[1];  /* First Mem of result set */\n\n  assert( p->explain );\n  assert( p->magic==VDBE_MAGIC_RUN );\n  assert( p->rc==SQLITE_OK || p->rc==SQLITE_BUSY || p->rc==SQLITE_NOMEM );\n\n  /* Even though this opcode does not use dynamic strings for\n  ** the result, result columns may become dynamic if the user calls\n  ** sqlite3_column_text16(), causing a translation to UTF-16 encoding.\n  */\n  releaseMemArray(pMem, 8);\n\n  if( p->rc==SQLITE_NOMEM ){\n    /* This happens if a malloc() inside a call to sqlite3_column_text() or\n    ** sqlite3_column_text16() failed.  */\n    db->mallocFailed = 1;\n    return SQLITE_ERROR;\n  }\n\n  /* When the number of output rows reaches nRow, that means the\n  ** listing has finished and sqlite3_step() should return SQLITE_DONE.\n  ** nRow is the sum of the number of rows in the main program, plus\n  ** the sum of the number of rows in all trigger subprograms encountered\n  ** so far.  The nRow value will increase as new trigger subprograms are\n  ** encountered, but p->pc will eventually catch up to nRow.\n  */\n  nRow = p->nOp;\n  if( p->explain==1 ){\n    /* The first 8 memory cells are used for the result set.  So we will\n    ** commandeer the 9th cell to use as storage for an array of pointers\n    ** to trigger subprograms.  The VDBE is guaranteed to have at least 9\n    ** cells.  */\n    assert( p->nMem>9 );\n    pSub = &p->aMem[9];\n    if( pSub->flags&MEM_Blob ){\n      /* On the first call to sqlite3_step(), pSub will hold a NULL.  It is\n      ** initialized to a BLOB by the P4_SUBPROGRAM processing logic below */\n      nSub = pSub->n/sizeof(Vdbe*);\n      apSub = (SubProgram **)pSub->z;\n    }\n    for(i=0; i<nSub; i++){\n      nRow += apSub[i]->nOp;\n    }\n  }\n\n  do{\n    i = p->pc++;\n  }while( i<nRow && p->explain==2 && p->aOp[i].opcode!=OP_Explain );\n  if( i>=nRow ){\n    p->rc = SQLITE_OK;\n    rc = SQLITE_DONE;\n  }else if( db->u1.isInterrupted ){\n    p->rc = SQLITE_INTERRUPT;\n    rc = SQLITE_ERROR;\n    sqlite3SetString(&p->zErrMsg, db, \"%s\", sqlite3ErrStr(p->rc));\n  }else{\n    char *z;\n    Op *pOp;\n    if( i<p->nOp ){\n      /* The output line number is small enough that we are still in the\n      ** main program. */\n      pOp = &p->aOp[i];\n    }else{\n      /* We are currently listing subprograms.  Figure out which one and\n      ** pick up the appropriate opcode. */\n      int j;\n      i -= p->nOp;\n      for(j=0; i>=apSub[j]->nOp; j++){\n        i -= apSub[j]->nOp;\n      }\n      pOp = &apSub[j]->aOp[i];\n    }\n    if( p->explain==1 ){\n      pMem->flags = MEM_Int;\n      pMem->type = SQLITE_INTEGER;\n      pMem->u.i = i;                                /* Program counter */\n      pMem++;\n  \n      pMem->flags = MEM_Static|MEM_Str|MEM_Term;\n      pMem->z = (char*)sqlite3OpcodeName(pOp->opcode);  /* Opcode */\n      assert( pMem->z!=0 );\n      pMem->n = sqlite3Strlen30(pMem->z);\n      pMem->type = SQLITE_TEXT;\n      pMem->enc = SQLITE_UTF8;\n      pMem++;\n\n      /* When an OP_Program opcode is encounter (the only opcode that has\n      ** a P4_SUBPROGRAM argument), expand the size of the array of subprograms\n      ** kept in p->aMem[9].z to hold the new program - assuming this subprogram\n      ** has not already been seen.\n      */\n      if( pOp->p4type==P4_SUBPROGRAM ){\n        int nByte = (nSub+1)*sizeof(SubProgram*);\n        int j;\n        for(j=0; j<nSub; j++){\n          if( apSub[j]==pOp->p4.pProgram ) break;\n        }\n        if( j==nSub && SQLITE_OK==sqlite3VdbeMemGrow(pSub, nByte, 1) ){\n          apSub = (SubProgram **)pSub->z;\n          apSub[nSub++] = pOp->p4.pProgram;\n          pSub->flags |= MEM_Blob;\n          pSub->n = nSub*sizeof(SubProgram*);\n        }\n      }\n    }\n\n    pMem->flags = MEM_Int;\n    pMem->u.i = pOp->p1;                          /* P1 */\n    pMem->type = SQLITE_INTEGER;\n    pMem++;\n\n    pMem->flags = MEM_Int;\n    pMem->u.i = pOp->p2;                          /* P2 */\n    pMem->type = SQLITE_INTEGER;\n    pMem++;\n\n    pMem->flags = MEM_Int;\n    pMem->u.i = pOp->p3;                          /* P3 */\n    pMem->type = SQLITE_INTEGER;\n    pMem++;\n\n    if( sqlite3VdbeMemGrow(pMem, 32, 0) ){            /* P4 */\n      assert( p->db->mallocFailed );\n      return SQLITE_ERROR;\n    }\n    pMem->flags = MEM_Dyn|MEM_Str|MEM_Term;\n    z = displayP4(pOp, pMem->z, 32);\n    if( z!=pMem->z ){\n      sqlite3VdbeMemSetStr(pMem, z, -1, SQLITE_UTF8, 0);\n    }else{\n      assert( pMem->z!=0 );\n      pMem->n = sqlite3Strlen30(pMem->z);\n      pMem->enc = SQLITE_UTF8;\n    }\n    pMem->type = SQLITE_TEXT;\n    pMem++;\n\n    if( p->explain==1 ){\n      if( sqlite3VdbeMemGrow(pMem, 4, 0) ){\n        assert( p->db->mallocFailed );\n        return SQLITE_ERROR;\n      }\n      pMem->flags = MEM_Dyn|MEM_Str|MEM_Term;\n      pMem->n = 2;\n      sqlite3_snprintf(3, pMem->z, \"%.2x\", pOp->p5);   /* P5 */\n      pMem->type = SQLITE_TEXT;\n      pMem->enc = SQLITE_UTF8;\n      pMem++;\n  \n#ifdef SQLITE_DEBUG\n      if( pOp->zComment ){\n        pMem->flags = MEM_Str|MEM_Term;\n        pMem->z = pOp->zComment;\n        pMem->n = sqlite3Strlen30(pMem->z);\n        pMem->enc = SQLITE_UTF8;\n        pMem->type = SQLITE_TEXT;\n      }else\n#endif\n      {\n        pMem->flags = MEM_Null;                       /* Comment */\n        pMem->type = SQLITE_NULL;\n      }\n    }\n\n    p->nResColumn = 8 - 4*(p->explain-1);\n    p->rc = SQLITE_OK;\n    rc = SQLITE_ROW;\n  }\n  return rc;\n}\n#endif /* SQLITE_OMIT_EXPLAIN */\n\n#ifdef SQLITE_DEBUG\n/*\n** Print the SQL that was used to generate a VDBE program.\n*/\nSQLITE_PRIVATE void sqlite3VdbePrintSql(Vdbe *p){\n  int nOp = p->nOp;\n  VdbeOp *pOp;\n  if( nOp<1 ) return;\n  pOp = &p->aOp[0];\n  if( pOp->opcode==OP_Trace && pOp->p4.z!=0 ){\n    const char *z = pOp->p4.z;\n    while( sqlite3Isspace(*z) ) z++;\n    printf(\"SQL: [%s]\\n\", z);\n  }\n}\n#endif\n\n#if !defined(SQLITE_OMIT_TRACE) && defined(SQLITE_ENABLE_IOTRACE)\n/*\n** Print an IOTRACE message showing SQL content.\n*/\nSQLITE_PRIVATE void sqlite3VdbeIOTraceSql(Vdbe *p){\n  int nOp = p->nOp;\n  VdbeOp *pOp;\n  if( sqlite3IoTrace==0 ) return;\n  if( nOp<1 ) return;\n  pOp = &p->aOp[0];\n  if( pOp->opcode==OP_Trace && pOp->p4.z!=0 ){\n    int i, j;\n    char z[1000];\n    sqlite3_snprintf(sizeof(z), z, \"%s\", pOp->p4.z);\n    for(i=0; sqlite3Isspace(z[i]); i++){}\n    for(j=0; z[i]; i++){\n      if( sqlite3Isspace(z[i]) ){\n        if( z[i-1]!=' ' ){\n          z[j++] = ' ';\n        }\n      }else{\n        z[j++] = z[i];\n      }\n    }\n    z[j] = 0;\n    sqlite3IoTrace(\"SQL %s\\n\", z);\n  }\n}\n#endif /* !SQLITE_OMIT_TRACE && SQLITE_ENABLE_IOTRACE */\n\n/*\n** Allocate space from a fixed size buffer and return a pointer to\n** that space.  If insufficient space is available, return NULL.\n**\n** The pBuf parameter is the initial value of a pointer which will\n** receive the new memory.  pBuf is normally NULL.  If pBuf is not\n** NULL, it means that memory space has already been allocated and that\n** this routine should not allocate any new memory.  When pBuf is not\n** NULL simply return pBuf.  Only allocate new memory space when pBuf\n** is NULL.\n**\n** nByte is the number of bytes of space needed.\n**\n** *ppFrom points to available space and pEnd points to the end of the\n** available space.  When space is allocated, *ppFrom is advanced past\n** the end of the allocated space.\n**\n** *pnByte is a counter of the number of bytes of space that have failed\n** to allocate.  If there is insufficient space in *ppFrom to satisfy the\n** request, then increment *pnByte by the amount of the request.\n*/\nstatic void *allocSpace(\n  void *pBuf,          /* Where return pointer will be stored */\n  int nByte,           /* Number of bytes to allocate */\n  u8 **ppFrom,         /* IN/OUT: Allocate from *ppFrom */\n  u8 *pEnd,            /* Pointer to 1 byte past the end of *ppFrom buffer */\n  int *pnByte          /* If allocation cannot be made, increment *pnByte */\n){\n  assert( EIGHT_BYTE_ALIGNMENT(*ppFrom) );\n  if( pBuf ) return pBuf;\n  nByte = ROUND8(nByte);\n  if( &(*ppFrom)[nByte] <= pEnd ){\n    pBuf = (void*)*ppFrom;\n    *ppFrom += nByte;\n  }else{\n    *pnByte += nByte;\n  }\n  return pBuf;\n}\n\n/*\n** Prepare a virtual machine for execution.  This involves things such\n** as allocating stack space and initializing the program counter.\n** After the VDBE has be prepped, it can be executed by one or more\n** calls to sqlite3VdbeExec().  \n**\n** This is the only way to move a VDBE from VDBE_MAGIC_INIT to\n** VDBE_MAGIC_RUN.\n**\n** This function may be called more than once on a single virtual machine.\n** The first call is made while compiling the SQL statement. Subsequent\n** calls are made as part of the process of resetting a statement to be\n** re-executed (from a call to sqlite3_reset()). The nVar, nMem, nCursor \n** and isExplain parameters are only passed correct values the first time\n** the function is called. On subsequent calls, from sqlite3_reset(), nVar\n** is passed -1 and nMem, nCursor and isExplain are all passed zero.\n*/\nSQLITE_PRIVATE void sqlite3VdbeMakeReady(\n  Vdbe *p,                       /* The VDBE */\n  int nVar,                      /* Number of '?' see in the SQL statement */\n  int nMem,                      /* Number of memory cells to allocate */\n  int nCursor,                   /* Number of cursors to allocate */\n  int nArg,                      /* Maximum number of args in SubPrograms */\n  int isExplain,                 /* True if the EXPLAIN keywords is present */\n  int usesStmtJournal            /* True to set Vdbe.usesStmtJournal */\n){\n  int n;\n  sqlite3 *db = p->db;\n\n  assert( p!=0 );\n  assert( p->magic==VDBE_MAGIC_INIT );\n\n  /* There should be at least one opcode.\n  */\n  assert( p->nOp>0 );\n\n  /* Set the magic to VDBE_MAGIC_RUN sooner rather than later. */\n  p->magic = VDBE_MAGIC_RUN;\n\n  /* For each cursor required, also allocate a memory cell. Memory\n  ** cells (nMem+1-nCursor)..nMem, inclusive, will never be used by\n  ** the vdbe program. Instead they are used to allocate space for\n  ** VdbeCursor/BtCursor structures. The blob of memory associated with \n  ** cursor 0 is stored in memory cell nMem. Memory cell (nMem-1)\n  ** stores the blob of memory associated with cursor 1, etc.\n  **\n  ** See also: allocateCursor().\n  */\n  nMem += nCursor;\n\n  /* Allocate space for memory registers, SQL variables, VDBE cursors and \n  ** an array to marshal SQL function arguments in. This is only done the\n  ** first time this function is called for a given VDBE, not when it is\n  ** being called from sqlite3_reset() to reset the virtual machine.\n  */\n  if( nVar>=0 && ALWAYS(db->mallocFailed==0) ){\n    u8 *zCsr = (u8 *)&p->aOp[p->nOp];       /* Memory avaliable for alloation */\n    u8 *zEnd = (u8 *)&p->aOp[p->nOpAlloc];  /* First byte past available mem */\n    int nByte;                              /* How much extra memory needed */\n\n    resolveP2Values(p, &nArg);\n    p->usesStmtJournal = (u8)usesStmtJournal;\n    if( isExplain && nMem<10 ){\n      nMem = 10;\n    }\n    memset(zCsr, 0, zEnd-zCsr);\n    zCsr += (zCsr - (u8*)0)&7;\n    assert( EIGHT_BYTE_ALIGNMENT(zCsr) );\n\n    /* Memory for registers, parameters, cursor, etc, is allocated in two\n    ** passes.  On the first pass, we try to reuse unused space at the \n    ** end of the opcode array.  If we are unable to satisfy all memory\n    ** requirements by reusing the opcode array tail, then the second\n    ** pass will fill in the rest using a fresh allocation.  \n    **\n    ** This two-pass approach that reuses as much memory as possible from\n    ** the leftover space at the end of the opcode array can significantly\n    ** reduce the amount of memory held by a prepared statement.\n    */\n    do {\n      nByte = 0;\n      p->aMem = allocSpace(p->aMem, nMem*sizeof(Mem), &zCsr, zEnd, &nByte);\n      p->aVar = allocSpace(p->aVar, nVar*sizeof(Mem), &zCsr, zEnd, &nByte);\n      p->apArg = allocSpace(p->apArg, nArg*sizeof(Mem*), &zCsr, zEnd, &nByte);\n      p->azVar = allocSpace(p->azVar, nVar*sizeof(char*), &zCsr, zEnd, &nByte);\n      p->apCsr = allocSpace(p->apCsr, nCursor*sizeof(VdbeCursor*),\n                            &zCsr, zEnd, &nByte);\n      if( nByte ){\n        p->pFree = sqlite3DbMallocZero(db, nByte);\n      }\n      zCsr = p->pFree;\n      zEnd = &zCsr[nByte];\n    }while( nByte && !db->mallocFailed );\n\n    p->nCursor = (u16)nCursor;\n    if( p->aVar ){\n      p->nVar = (ynVar)nVar;\n      for(n=0; n<nVar; n++){\n        p->aVar[n].flags = MEM_Null;\n        p->aVar[n].db = db;\n      }\n    }\n    if( p->aMem ){\n      p->aMem--;                      /* aMem[] goes from 1..nMem */\n      p->nMem = nMem;                 /*       not from 0..nMem-1 */\n      for(n=1; n<=nMem; n++){\n        p->aMem[n].flags = MEM_Null;\n        p->aMem[n].db = db;\n      }\n    }\n  }\n#ifdef SQLITE_DEBUG\n  for(n=1; n<p->nMem; n++){\n    assert( p->aMem[n].db==db );\n  }\n#endif\n\n  p->pc = -1;\n  p->rc = SQLITE_OK;\n  p->errorAction = OE_Abort;\n  p->explain |= isExplain;\n  p->magic = VDBE_MAGIC_RUN;\n  p->nChange = 0;\n  p->cacheCtr = 1;\n  p->minWriteFileFormat = 255;\n  p->iStatement = 0;\n  p->nFkConstraint = 0;\n#ifdef VDBE_PROFILE\n  {\n    int i;\n    for(i=0; i<p->nOp; i++){\n      p->aOp[i].cnt = 0;\n      p->aOp[i].cycles = 0;\n    }\n  }\n#endif\n}\n\n/*\n** Close a VDBE cursor and release all the resources that cursor \n** happens to hold.\n*/\nSQLITE_PRIVATE void sqlite3VdbeFreeCursor(Vdbe *p, VdbeCursor *pCx){\n  if( pCx==0 ){\n    return;\n  }\n  if( pCx->pBt ){\n    sqlite3BtreeClose(pCx->pBt);\n    /* The pCx->pCursor will be close automatically, if it exists, by\n    ** the call above. */\n  }else if( pCx->pCursor ){\n    sqlite3BtreeCloseCursor(pCx->pCursor);\n  }\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  if( pCx->pVtabCursor ){\n    sqlite3_vtab_cursor *pVtabCursor = pCx->pVtabCursor;\n    const sqlite3_module *pModule = pCx->pModule;\n    p->inVtabMethod = 1;\n    pModule->xClose(pVtabCursor);\n    p->inVtabMethod = 0;\n  }\n#endif\n}\n\n/*\n** Copy the values stored in the VdbeFrame structure to its Vdbe. This\n** is used, for example, when a trigger sub-program is halted to restore\n** control to the main program.\n*/\nSQLITE_PRIVATE int sqlite3VdbeFrameRestore(VdbeFrame *pFrame){\n  Vdbe *v = pFrame->v;\n  v->aOp = pFrame->aOp;\n  v->nOp = pFrame->nOp;\n  v->aMem = pFrame->aMem;\n  v->nMem = pFrame->nMem;\n  v->apCsr = pFrame->apCsr;\n  v->nCursor = pFrame->nCursor;\n  v->db->lastRowid = pFrame->lastRowid;\n  v->nChange = pFrame->nChange;\n  return pFrame->pc;\n}\n\n/*\n** Close all cursors.\n**\n** Also release any dynamic memory held by the VM in the Vdbe.aMem memory \n** cell array. This is necessary as the memory cell array may contain\n** pointers to VdbeFrame objects, which may in turn contain pointers to\n** open cursors.\n*/\nstatic void closeAllCursors(Vdbe *p){\n  if( p->pFrame ){\n    VdbeFrame *pFrame;\n    for(pFrame=p->pFrame; pFrame->pParent; pFrame=pFrame->pParent);\n    sqlite3VdbeFrameRestore(pFrame);\n  }\n  p->pFrame = 0;\n  p->nFrame = 0;\n\n  if( p->apCsr ){\n    int i;\n    for(i=0; i<p->nCursor; i++){\n      VdbeCursor *pC = p->apCsr[i];\n      if( pC ){\n        sqlite3VdbeFreeCursor(p, pC);\n        p->apCsr[i] = 0;\n      }\n    }\n  }\n  if( p->aMem ){\n    releaseMemArray(&p->aMem[1], p->nMem);\n  }\n  while( p->pDelFrame ){\n    VdbeFrame *pDel = p->pDelFrame;\n    p->pDelFrame = pDel->pParent;\n    sqlite3VdbeFrameDelete(pDel);\n  }\n}\n\n/*\n** Clean up the VM after execution.\n**\n** This routine will automatically close any cursors, lists, and/or\n** sorters that were left open.  It also deletes the values of\n** variables in the aVar[] array.\n*/\nstatic void Cleanup(Vdbe *p){\n  sqlite3 *db = p->db;\n\n#ifdef SQLITE_DEBUG\n  /* Execute assert() statements to ensure that the Vdbe.apCsr[] and \n  ** Vdbe.aMem[] arrays have already been cleaned up.  */\n  int i;\n  for(i=0; i<p->nCursor; i++) assert( p->apCsr==0 || p->apCsr[i]==0 );\n  for(i=1; i<=p->nMem; i++) assert( p->aMem==0 || p->aMem[i].flags==MEM_Null );\n#endif\n\n  sqlite3DbFree(db, p->zErrMsg);\n  p->zErrMsg = 0;\n  p->pResultSet = 0;\n}\n\n/*\n** Set the number of result columns that will be returned by this SQL\n** statement. This is now set at compile time, rather than during\n** execution of the vdbe program so that sqlite3_column_count() can\n** be called on an SQL statement before sqlite3_step().\n*/\nSQLITE_PRIVATE void sqlite3VdbeSetNumCols(Vdbe *p, int nResColumn){\n  Mem *pColName;\n  int n;\n  sqlite3 *db = p->db;\n\n  releaseMemArray(p->aColName, p->nResColumn*COLNAME_N);\n  sqlite3DbFree(db, p->aColName);\n  n = nResColumn*COLNAME_N;\n  p->nResColumn = (u16)nResColumn;\n  p->aColName = pColName = (Mem*)sqlite3DbMallocZero(db, sizeof(Mem)*n );\n  if( p->aColName==0 ) return;\n  while( n-- > 0 ){\n    pColName->flags = MEM_Null;\n    pColName->db = p->db;\n    pColName++;\n  }\n}\n\n/*\n** Set the name of the idx'th column to be returned by the SQL statement.\n** zName must be a pointer to a nul terminated string.\n**\n** This call must be made after a call to sqlite3VdbeSetNumCols().\n**\n** The final parameter, xDel, must be one of SQLITE_DYNAMIC, SQLITE_STATIC\n** or SQLITE_TRANSIENT. If it is SQLITE_DYNAMIC, then the buffer pointed\n** to by zName will be freed by sqlite3DbFree() when the vdbe is destroyed.\n*/\nSQLITE_PRIVATE int sqlite3VdbeSetColName(\n  Vdbe *p,                         /* Vdbe being configured */\n  int idx,                         /* Index of column zName applies to */\n  int var,                         /* One of the COLNAME_* constants */\n  const char *zName,               /* Pointer to buffer containing name */\n  void (*xDel)(void*)              /* Memory management strategy for zName */\n){\n  int rc;\n  Mem *pColName;\n  assert( idx<p->nResColumn );\n  assert( var<COLNAME_N );\n  if( p->db->mallocFailed ){\n    assert( !zName || xDel!=SQLITE_DYNAMIC );\n    return SQLITE_NOMEM;\n  }\n  assert( p->aColName!=0 );\n  pColName = &(p->aColName[idx+var*p->nResColumn]);\n  rc = sqlite3VdbeMemSetStr(pColName, zName, -1, SQLITE_UTF8, xDel);\n  assert( rc!=0 || !zName || (pColName->flags&MEM_Term)!=0 );\n  return rc;\n}\n\n/*\n** A read or write transaction may or may not be active on database handle\n** db. If a transaction is active, commit it. If there is a\n** write-transaction spanning more than one database file, this routine\n** takes care of the master journal trickery.\n*/\nstatic int vdbeCommit(sqlite3 *db, Vdbe *p){\n  int i;\n  int nTrans = 0;  /* Number of databases with an active write-transaction */\n  int rc = SQLITE_OK;\n  int needXcommit = 0;\n\n#ifdef SQLITE_OMIT_VIRTUALTABLE\n  /* With this option, sqlite3VtabSync() is defined to be simply \n  ** SQLITE_OK so p is not used. \n  */\n  UNUSED_PARAMETER(p);\n#endif\n\n  /* Before doing anything else, call the xSync() callback for any\n  ** virtual module tables written in this transaction. This has to\n  ** be done before determining whether a master journal file is \n  ** required, as an xSync() callback may add an attached database\n  ** to the transaction.\n  */\n  rc = sqlite3VtabSync(db, &p->zErrMsg);\n\n  /* This loop determines (a) if the commit hook should be invoked and\n  ** (b) how many database files have open write transactions, not \n  ** including the temp database. (b) is important because if more than \n  ** one database file has an open write transaction, a master journal\n  ** file is required for an atomic commit.\n  */ \n  for(i=0; rc==SQLITE_OK && i<db->nDb; i++){ \n    Btree *pBt = db->aDb[i].pBt;\n    if( sqlite3BtreeIsInTrans(pBt) ){\n      needXcommit = 1;\n      if( i!=1 ) nTrans++;\n      rc = sqlite3PagerExclusiveLock(sqlite3BtreePager(pBt));\n    }\n  }\n  if( rc!=SQLITE_OK ){\n    return rc;\n  }\n\n  /* If there are any write-transactions at all, invoke the commit hook */\n  if( needXcommit && db->xCommitCallback ){\n    rc = db->xCommitCallback(db->pCommitArg);\n    if( rc ){\n      return SQLITE_CONSTRAINT;\n    }\n  }\n\n  /* The simple case - no more than one database file (not counting the\n  ** TEMP database) has a transaction active.   There is no need for the\n  ** master-journal.\n  **\n  ** If the return value of sqlite3BtreeGetFilename() is a zero length\n  ** string, it means the main database is :memory: or a temp file.  In \n  ** that case we do not support atomic multi-file commits, so use the \n  ** simple case then too.\n  */\n  if( 0==sqlite3Strlen30(sqlite3BtreeGetFilename(db->aDb[0].pBt))\n   || nTrans<=1\n  ){\n    for(i=0; rc==SQLITE_OK && i<db->nDb; i++){\n      Btree *pBt = db->aDb[i].pBt;\n      if( pBt ){\n        rc = sqlite3BtreeCommitPhaseOne(pBt, 0);\n      }\n    }\n\n    /* Do the commit only if all databases successfully complete phase 1. \n    ** If one of the BtreeCommitPhaseOne() calls fails, this indicates an\n    ** IO error while deleting or truncating a journal file. It is unlikely,\n    ** but could happen. In this case abandon processing and return the error.\n    */\n    for(i=0; rc==SQLITE_OK && i<db->nDb; i++){\n      Btree *pBt = db->aDb[i].pBt;\n      if( pBt ){\n        rc = sqlite3BtreeCommitPhaseTwo(pBt);\n      }\n    }\n    if( rc==SQLITE_OK ){\n      sqlite3VtabCommit(db);\n    }\n  }\n\n  /* The complex case - There is a multi-file write-transaction active.\n  ** This requires a master journal file to ensure the transaction is\n  ** committed atomicly.\n  */\n#ifndef SQLITE_OMIT_DISKIO\n  else{\n    sqlite3_vfs *pVfs = db->pVfs;\n    int needSync = 0;\n    char *zMaster = 0;   /* File-name for the master journal */\n    char const *zMainFile = sqlite3BtreeGetFilename(db->aDb[0].pBt);\n    sqlite3_file *pMaster = 0;\n    i64 offset = 0;\n    int res;\n\n    /* Select a master journal file name */\n    do {\n      u32 iRandom;\n      sqlite3DbFree(db, zMaster);\n      sqlite3_randomness(sizeof(iRandom), &iRandom);\n      zMaster = sqlite3MPrintf(db, \"%s-mj%08X\", zMainFile, iRandom&0x7fffffff);\n      if( !zMaster ){\n        return SQLITE_NOMEM;\n      }\n      rc = sqlite3OsAccess(pVfs, zMaster, SQLITE_ACCESS_EXISTS, &res);\n    }while( rc==SQLITE_OK && res );\n    if( rc==SQLITE_OK ){\n      /* Open the master journal. */\n      rc = sqlite3OsOpenMalloc(pVfs, zMaster, &pMaster, \n          SQLITE_OPEN_READWRITE|SQLITE_OPEN_CREATE|\n          SQLITE_OPEN_EXCLUSIVE|SQLITE_OPEN_MASTER_JOURNAL, 0\n      );\n    }\n    if( rc!=SQLITE_OK ){\n      sqlite3DbFree(db, zMaster);\n      return rc;\n    }\n \n    /* Write the name of each database file in the transaction into the new\n    ** master journal file. If an error occurs at this point close\n    ** and delete the master journal file. All the individual journal files\n    ** still have 'null' as the master journal pointer, so they will roll\n    ** back independently if a failure occurs.\n    */\n    for(i=0; i<db->nDb; i++){\n      Btree *pBt = db->aDb[i].pBt;\n      if( sqlite3BtreeIsInTrans(pBt) ){\n        char const *zFile = sqlite3BtreeGetJournalname(pBt);\n        if( zFile==0 ){\n          continue;  /* Ignore TEMP and :memory: databases */\n        }\n        assert( zFile[0]!=0 );\n        if( !needSync && !sqlite3BtreeSyncDisabled(pBt) ){\n          needSync = 1;\n        }\n        rc = sqlite3OsWrite(pMaster, zFile, sqlite3Strlen30(zFile)+1, offset);\n        offset += sqlite3Strlen30(zFile)+1;\n        if( rc!=SQLITE_OK ){\n          sqlite3OsCloseFree(pMaster);\n          sqlite3OsDelete(pVfs, zMaster, 0);\n          sqlite3DbFree(db, zMaster);\n          return rc;\n        }\n      }\n    }\n\n    /* Sync the master journal file. If the IOCAP_SEQUENTIAL device\n    ** flag is set this is not required.\n    */\n    if( needSync \n     && 0==(sqlite3OsDeviceCharacteristics(pMaster)&SQLITE_IOCAP_SEQUENTIAL)\n     && SQLITE_OK!=(rc = sqlite3OsSync(pMaster, SQLITE_SYNC_NORMAL))\n    ){\n      sqlite3OsCloseFree(pMaster);\n      sqlite3OsDelete(pVfs, zMaster, 0);\n      sqlite3DbFree(db, zMaster);\n      return rc;\n    }\n\n    /* Sync all the db files involved in the transaction. The same call\n    ** sets the master journal pointer in each individual journal. If\n    ** an error occurs here, do not delete the master journal file.\n    **\n    ** If the error occurs during the first call to\n    ** sqlite3BtreeCommitPhaseOne(), then there is a chance that the\n    ** master journal file will be orphaned. But we cannot delete it,\n    ** in case the master journal file name was written into the journal\n    ** file before the failure occurred.\n    */\n    for(i=0; rc==SQLITE_OK && i<db->nDb; i++){ \n      Btree *pBt = db->aDb[i].pBt;\n      if( pBt ){\n        rc = sqlite3BtreeCommitPhaseOne(pBt, zMaster);\n      }\n    }\n    sqlite3OsCloseFree(pMaster);\n    assert( rc!=SQLITE_BUSY );\n    if( rc!=SQLITE_OK ){\n      sqlite3DbFree(db, zMaster);\n      return rc;\n    }\n\n    /* Delete the master journal file. This commits the transaction. After\n    ** doing this the directory is synced again before any individual\n    ** transaction files are deleted.\n    */\n    rc = sqlite3OsDelete(pVfs, zMaster, 1);\n    sqlite3DbFree(db, zMaster);\n    zMaster = 0;\n    if( rc ){\n      return rc;\n    }\n\n    /* All files and directories have already been synced, so the following\n    ** calls to sqlite3BtreeCommitPhaseTwo() are only closing files and\n    ** deleting or truncating journals. If something goes wrong while\n    ** this is happening we don't really care. The integrity of the\n    ** transaction is already guaranteed, but some stray 'cold' journals\n    ** may be lying around. Returning an error code won't help matters.\n    */\n    disable_simulated_io_errors();\n    sqlite3BeginBenignMalloc();\n    for(i=0; i<db->nDb; i++){ \n      Btree *pBt = db->aDb[i].pBt;\n      if( pBt ){\n        sqlite3BtreeCommitPhaseTwo(pBt);\n      }\n    }\n    sqlite3EndBenignMalloc();\n    enable_simulated_io_errors();\n\n    sqlite3VtabCommit(db);\n  }\n#endif\n\n  return rc;\n}\n\n/* \n** This routine checks that the sqlite3.activeVdbeCnt count variable\n** matches the number of vdbe's in the list sqlite3.pVdbe that are\n** currently active. An assertion fails if the two counts do not match.\n** This is an internal self-check only - it is not an essential processing\n** step.\n**\n** This is a no-op if NDEBUG is defined.\n*/\n#ifndef NDEBUG\nstatic void checkActiveVdbeCnt(sqlite3 *db){\n  Vdbe *p;\n  int cnt = 0;\n  int nWrite = 0;\n  p = db->pVdbe;\n  while( p ){\n    if( p->magic==VDBE_MAGIC_RUN && p->pc>=0 ){\n      cnt++;\n      if( p->readOnly==0 ) nWrite++;\n    }\n    p = p->pNext;\n  }\n  assert( cnt==db->activeVdbeCnt );\n  assert( nWrite==db->writeVdbeCnt );\n}\n#else\n#define checkActiveVdbeCnt(x)\n#endif\n\n/*\n** For every Btree that in database connection db which \n** has been modified, \"trip\" or invalidate each cursor in\n** that Btree might have been modified so that the cursor\n** can never be used again.  This happens when a rollback\n*** occurs.  We have to trip all the other cursors, even\n** cursor from other VMs in different database connections,\n** so that none of them try to use the data at which they\n** were pointing and which now may have been changed due\n** to the rollback.\n**\n** Remember that a rollback can delete tables complete and\n** reorder rootpages.  So it is not sufficient just to save\n** the state of the cursor.  We have to invalidate the cursor\n** so that it is never used again.\n*/\nstatic void invalidateCursorsOnModifiedBtrees(sqlite3 *db){\n  int i;\n  for(i=0; i<db->nDb; i++){\n    Btree *p = db->aDb[i].pBt;\n    if( p && sqlite3BtreeIsInTrans(p) ){\n      sqlite3BtreeTripAllCursors(p, SQLITE_ABORT);\n    }\n  }\n}\n\n/*\n** If the Vdbe passed as the first argument opened a statement-transaction,\n** close it now. Argument eOp must be either SAVEPOINT_ROLLBACK or\n** SAVEPOINT_RELEASE. If it is SAVEPOINT_ROLLBACK, then the statement\n** transaction is rolled back. If eOp is SAVEPOINT_RELEASE, then the \n** statement transaction is commtted.\n**\n** If an IO error occurs, an SQLITE_IOERR_XXX error code is returned. \n** Otherwise SQLITE_OK.\n*/\nSQLITE_PRIVATE int sqlite3VdbeCloseStatement(Vdbe *p, int eOp){\n  sqlite3 *const db = p->db;\n  int rc = SQLITE_OK;\n\n  /* If p->iStatement is greater than zero, then this Vdbe opened a \n  ** statement transaction that should be closed here. The only exception\n  ** is that an IO error may have occured, causing an emergency rollback.\n  ** In this case (db->nStatement==0), and there is nothing to do.\n  */\n  if( db->nStatement && p->iStatement ){\n    int i;\n    const int iSavepoint = p->iStatement-1;\n\n    assert( eOp==SAVEPOINT_ROLLBACK || eOp==SAVEPOINT_RELEASE);\n    assert( db->nStatement>0 );\n    assert( p->iStatement==(db->nStatement+db->nSavepoint) );\n\n    for(i=0; i<db->nDb; i++){ \n      int rc2 = SQLITE_OK;\n      Btree *pBt = db->aDb[i].pBt;\n      if( pBt ){\n        if( eOp==SAVEPOINT_ROLLBACK ){\n          rc2 = sqlite3BtreeSavepoint(pBt, SAVEPOINT_ROLLBACK, iSavepoint);\n        }\n        if( rc2==SQLITE_OK ){\n          rc2 = sqlite3BtreeSavepoint(pBt, SAVEPOINT_RELEASE, iSavepoint);\n        }\n        if( rc==SQLITE_OK ){\n          rc = rc2;\n        }\n      }\n    }\n    db->nStatement--;\n    p->iStatement = 0;\n\n    /* If the statement transaction is being rolled back, also restore the \n    ** database handles deferred constraint counter to the value it had when \n    ** the statement transaction was opened.  */\n    if( eOp==SAVEPOINT_ROLLBACK ){\n      db->nDeferredCons = p->nStmtDefCons;\n    }\n  }\n  return rc;\n}\n\n/*\n** If SQLite is compiled to support shared-cache mode and to be threadsafe,\n** this routine obtains the mutex associated with each BtShared structure\n** that may be accessed by the VM passed as an argument. In doing so it\n** sets the BtShared.db member of each of the BtShared structures, ensuring\n** that the correct busy-handler callback is invoked if required.\n**\n** If SQLite is not threadsafe but does support shared-cache mode, then\n** sqlite3BtreeEnterAll() is invoked to set the BtShared.db variables\n** of all of BtShared structures accessible via the database handle \n** associated with the VM. Of course only a subset of these structures\n** will be accessed by the VM, and we could use Vdbe.btreeMask to figure\n** that subset out, but there is no advantage to doing so.\n**\n** If SQLite is not threadsafe and does not support shared-cache mode, this\n** function is a no-op.\n*/\n#ifndef SQLITE_OMIT_SHARED_CACHE\nSQLITE_PRIVATE void sqlite3VdbeMutexArrayEnter(Vdbe *p){\n#if SQLITE_THREADSAFE\n  sqlite3BtreeMutexArrayEnter(&p->aMutex);\n#else\n  sqlite3BtreeEnterAll(p->db);\n#endif\n}\n#endif\n\n/*\n** This function is called when a transaction opened by the database \n** handle associated with the VM passed as an argument is about to be \n** committed. If there are outstanding deferred foreign key constraint\n** violations, return SQLITE_ERROR. Otherwise, SQLITE_OK.\n**\n** If there are outstanding FK violations and this function returns \n** SQLITE_ERROR, set the result of the VM to SQLITE_CONSTRAINT and write\n** an error message to it. Then return SQLITE_ERROR.\n*/\n#ifndef SQLITE_OMIT_FOREIGN_KEY\nSQLITE_PRIVATE int sqlite3VdbeCheckFk(Vdbe *p, int deferred){\n  sqlite3 *db = p->db;\n  if( (deferred && db->nDeferredCons>0) || (!deferred && p->nFkConstraint>0) ){\n    p->rc = SQLITE_CONSTRAINT;\n    p->errorAction = OE_Abort;\n    sqlite3SetString(&p->zErrMsg, db, \"foreign key constraint failed\");\n    return SQLITE_ERROR;\n  }\n  return SQLITE_OK;\n}\n#endif\n\n/*\n** This routine is called the when a VDBE tries to halt.  If the VDBE\n** has made changes and is in autocommit mode, then commit those\n** changes.  If a rollback is needed, then do the rollback.\n**\n** This routine is the only way to move the state of a VM from\n** SQLITE_MAGIC_RUN to SQLITE_MAGIC_HALT.  It is harmless to\n** call this on a VM that is in the SQLITE_MAGIC_HALT state.\n**\n** Return an error code.  If the commit could not complete because of\n** lock contention, return SQLITE_BUSY.  If SQLITE_BUSY is returned, it\n** means the close did not happen and needs to be repeated.\n*/\nSQLITE_PRIVATE int sqlite3VdbeHalt(Vdbe *p){\n  int rc;                         /* Used to store transient return codes */\n  sqlite3 *db = p->db;\n\n  /* This function contains the logic that determines if a statement or\n  ** transaction will be committed or rolled back as a result of the\n  ** execution of this virtual machine. \n  **\n  ** If any of the following errors occur:\n  **\n  **     SQLITE_NOMEM\n  **     SQLITE_IOERR\n  **     SQLITE_FULL\n  **     SQLITE_INTERRUPT\n  **\n  ** Then the internal cache might have been left in an inconsistent\n  ** state.  We need to rollback the statement transaction, if there is\n  ** one, or the complete transaction if there is no statement transaction.\n  */\n\n  if( p->db->mallocFailed ){\n    p->rc = SQLITE_NOMEM;\n  }\n  closeAllCursors(p);\n  if( p->magic!=VDBE_MAGIC_RUN ){\n    return SQLITE_OK;\n  }\n  checkActiveVdbeCnt(db);\n\n  /* No commit or rollback needed if the program never started */\n  if( p->pc>=0 ){\n    int mrc;   /* Primary error code from p->rc */\n    int eStatementOp = 0;\n    int isSpecialError;            /* Set to true if a 'special' error */\n\n    /* Lock all btrees used by the statement */\n    sqlite3VdbeMutexArrayEnter(p);\n\n    /* Check for one of the special errors */\n    mrc = p->rc & 0xff;\n    assert( p->rc!=SQLITE_IOERR_BLOCKED );  /* This error no longer exists */\n    isSpecialError = mrc==SQLITE_NOMEM || mrc==SQLITE_IOERR\n                     || mrc==SQLITE_INTERRUPT || mrc==SQLITE_FULL;\n    if( isSpecialError ){\n      /* If the query was read-only and the error code is SQLITE_INTERRUPT, \n      ** no rollback is necessary. Otherwise, at least a savepoint \n      ** transaction must be rolled back to restore the database to a \n      ** consistent state.\n      **\n      ** Even if the statement is read-only, it is important to perform\n      ** a statement or transaction rollback operation. If the error \n      ** occured while writing to the journal, sub-journal or database\n      ** file as part of an effort to free up cache space (see function\n      ** pagerStress() in pager.c), the rollback is required to restore \n      ** the pager to a consistent state.\n      */\n      if( !p->readOnly || mrc!=SQLITE_INTERRUPT ){\n        if( (mrc==SQLITE_NOMEM || mrc==SQLITE_FULL) && p->usesStmtJournal ){\n          eStatementOp = SAVEPOINT_ROLLBACK;\n        }else{\n          /* We are forced to roll back the active transaction. Before doing\n          ** so, abort any other statements this handle currently has active.\n          */\n          invalidateCursorsOnModifiedBtrees(db);\n          sqlite3RollbackAll(db);\n          sqlite3CloseSavepoints(db);\n          db->autoCommit = 1;\n        }\n      }\n    }\n\n    /* Check for immediate foreign key violations. */\n    if( p->rc==SQLITE_OK ){\n      sqlite3VdbeCheckFk(p, 0);\n    }\n  \n    /* If the auto-commit flag is set and this is the only active writer \n    ** VM, then we do either a commit or rollback of the current transaction. \n    **\n    ** Note: This block also runs if one of the special errors handled \n    ** above has occurred. \n    */\n    if( !sqlite3VtabInSync(db) \n     && db->autoCommit \n     && db->writeVdbeCnt==(p->readOnly==0) \n    ){\n      if( p->rc==SQLITE_OK || (p->errorAction==OE_Fail && !isSpecialError) ){\n        rc = sqlite3VdbeCheckFk(p, 1);\n        if( rc!=SQLITE_OK ){\n          if( NEVER(p->readOnly) ){\n            sqlite3BtreeMutexArrayLeave(&p->aMutex);\n            return SQLITE_ERROR;\n          }\n          rc = SQLITE_CONSTRAINT;\n        }else{ \n          /* The auto-commit flag is true, the vdbe program was successful \n          ** or hit an 'OR FAIL' constraint and there are no deferred foreign\n          ** key constraints to hold up the transaction. This means a commit \n          ** is required. */\n          rc = vdbeCommit(db, p);\n        }\n        if( rc==SQLITE_BUSY && p->readOnly ){\n          sqlite3BtreeMutexArrayLeave(&p->aMutex);\n          return SQLITE_BUSY;\n        }else if( rc!=SQLITE_OK ){\n          p->rc = rc;\n          sqlite3RollbackAll(db);\n        }else{\n          db->nDeferredCons = 0;\n          sqlite3CommitInternalChanges(db);\n        }\n      }else{\n        sqlite3RollbackAll(db);\n      }\n      db->nStatement = 0;\n    }else if( eStatementOp==0 ){\n      if( p->rc==SQLITE_OK || p->errorAction==OE_Fail ){\n        eStatementOp = SAVEPOINT_RELEASE;\n      }else if( p->errorAction==OE_Abort ){\n        eStatementOp = SAVEPOINT_ROLLBACK;\n      }else{\n        invalidateCursorsOnModifiedBtrees(db);\n        sqlite3RollbackAll(db);\n        sqlite3CloseSavepoints(db);\n        db->autoCommit = 1;\n      }\n    }\n  \n    /* If eStatementOp is non-zero, then a statement transaction needs to\n    ** be committed or rolled back. Call sqlite3VdbeCloseStatement() to\n    ** do so. If this operation returns an error, and the current statement\n    ** error code is SQLITE_OK or SQLITE_CONSTRAINT, then promote the\n    ** current statement error code.\n    **\n    ** Note that sqlite3VdbeCloseStatement() can only fail if eStatementOp\n    ** is SAVEPOINT_ROLLBACK.  But if p->rc==SQLITE_OK then eStatementOp\n    ** must be SAVEPOINT_RELEASE.  Hence the NEVER(p->rc==SQLITE_OK) in \n    ** the following code.\n    */\n    if( eStatementOp ){\n      rc = sqlite3VdbeCloseStatement(p, eStatementOp);\n      if( rc ){\n        assert( eStatementOp==SAVEPOINT_ROLLBACK );\n        if( NEVER(p->rc==SQLITE_OK) || p->rc==SQLITE_CONSTRAINT ){\n          p->rc = rc;\n          sqlite3DbFree(db, p->zErrMsg);\n          p->zErrMsg = 0;\n        }\n        invalidateCursorsOnModifiedBtrees(db);\n        sqlite3RollbackAll(db);\n        sqlite3CloseSavepoints(db);\n        db->autoCommit = 1;\n      }\n    }\n  \n    /* If this was an INSERT, UPDATE or DELETE and no statement transaction\n    ** has been rolled back, update the database connection change-counter. \n    */\n    if( p->changeCntOn ){\n      if( eStatementOp!=SAVEPOINT_ROLLBACK ){\n        sqlite3VdbeSetChanges(db, p->nChange);\n      }else{\n        sqlite3VdbeSetChanges(db, 0);\n      }\n      p->nChange = 0;\n    }\n  \n    /* Rollback or commit any schema changes that occurred. */\n    if( p->rc!=SQLITE_OK && db->flags&SQLITE_InternChanges ){\n      sqlite3ResetInternalSchema(db, 0);\n      db->flags = (db->flags | SQLITE_InternChanges);\n    }\n\n    /* Release the locks */\n    sqlite3BtreeMutexArrayLeave(&p->aMutex);\n  }\n\n  /* We have successfully halted and closed the VM.  Record this fact. */\n  if( p->pc>=0 ){\n    db->activeVdbeCnt--;\n    if( !p->readOnly ){\n      db->writeVdbeCnt--;\n    }\n    assert( db->activeVdbeCnt>=db->writeVdbeCnt );\n  }\n  p->magic = VDBE_MAGIC_HALT;\n  checkActiveVdbeCnt(db);\n  if( p->db->mallocFailed ){\n    p->rc = SQLITE_NOMEM;\n  }\n\n  /* If the auto-commit flag is set to true, then any locks that were held\n  ** by connection db have now been released. Call sqlite3ConnectionUnlocked() \n  ** to invoke any required unlock-notify callbacks.\n  */\n  if( db->autoCommit ){\n    sqlite3ConnectionUnlocked(db);\n  }\n\n  assert( db->activeVdbeCnt>0 || db->autoCommit==0 || db->nStatement==0 );\n  return (p->rc==SQLITE_BUSY ? SQLITE_BUSY : SQLITE_OK);\n}\n\n\n/*\n** Each VDBE holds the result of the most recent sqlite3_step() call\n** in p->rc.  This routine sets that result back to SQLITE_OK.\n*/\nSQLITE_PRIVATE void sqlite3VdbeResetStepResult(Vdbe *p){\n  p->rc = SQLITE_OK;\n}\n\n/*\n** Clean up a VDBE after execution but do not delete the VDBE just yet.\n** Write any error messages into *pzErrMsg.  Return the result code.\n**\n** After this routine is run, the VDBE should be ready to be executed\n** again.\n**\n** To look at it another way, this routine resets the state of the\n** virtual machine from VDBE_MAGIC_RUN or VDBE_MAGIC_HALT back to\n** VDBE_MAGIC_INIT.\n*/\nSQLITE_PRIVATE int sqlite3VdbeReset(Vdbe *p){\n  sqlite3 *db;\n  db = p->db;\n\n  /* If the VM did not run to completion or if it encountered an\n  ** error, then it might not have been halted properly.  So halt\n  ** it now.\n  */\n  sqlite3VdbeHalt(p);\n\n  /* If the VDBE has be run even partially, then transfer the error code\n  ** and error message from the VDBE into the main database structure.  But\n  ** if the VDBE has just been set to run but has not actually executed any\n  ** instructions yet, leave the main database error information unchanged.\n  */\n  if( p->pc>=0 ){\n    if( p->zErrMsg ){\n      sqlite3BeginBenignMalloc();\n      sqlite3ValueSetStr(db->pErr,-1,p->zErrMsg,SQLITE_UTF8,SQLITE_TRANSIENT);\n      sqlite3EndBenignMalloc();\n      db->errCode = p->rc;\n      sqlite3DbFree(db, p->zErrMsg);\n      p->zErrMsg = 0;\n    }else if( p->rc ){\n      sqlite3Error(db, p->rc, 0);\n    }else{\n      sqlite3Error(db, SQLITE_OK, 0);\n    }\n    if( p->runOnlyOnce ) p->expired = 1;\n  }else if( p->rc && p->expired ){\n    /* The expired flag was set on the VDBE before the first call\n    ** to sqlite3_step(). For consistency (since sqlite3_step() was\n    ** called), set the database error in this case as well.\n    */\n    sqlite3Error(db, p->rc, 0);\n    sqlite3ValueSetStr(db->pErr, -1, p->zErrMsg, SQLITE_UTF8, SQLITE_TRANSIENT);\n    sqlite3DbFree(db, p->zErrMsg);\n    p->zErrMsg = 0;\n  }\n\n  /* Reclaim all memory used by the VDBE\n  */\n  Cleanup(p);\n\n  /* Save profiling information from this VDBE run.\n  */\n#ifdef VDBE_PROFILE\n  {\n    FILE *out = fopen(\"vdbe_profile.out\", \"a\");\n    if( out ){\n      int i;\n      fprintf(out, \"---- \");\n      for(i=0; i<p->nOp; i++){\n        fprintf(out, \"%02x\", p->aOp[i].opcode);\n      }\n      fprintf(out, \"\\n\");\n      for(i=0; i<p->nOp; i++){\n        fprintf(out, \"%6d %10lld %8lld \",\n           p->aOp[i].cnt,\n           p->aOp[i].cycles,\n           p->aOp[i].cnt>0 ? p->aOp[i].cycles/p->aOp[i].cnt : 0\n        );\n        sqlite3VdbePrintOp(out, i, &p->aOp[i]);\n      }\n      fclose(out);\n    }\n  }\n#endif\n  p->magic = VDBE_MAGIC_INIT;\n  return p->rc & db->errMask;\n}\n \n/*\n** Clean up and delete a VDBE after execution.  Return an integer which is\n** the result code.  Write any error message text into *pzErrMsg.\n*/\nSQLITE_PRIVATE int sqlite3VdbeFinalize(Vdbe *p){\n  int rc = SQLITE_OK;\n  if( p->magic==VDBE_MAGIC_RUN || p->magic==VDBE_MAGIC_HALT ){\n    rc = sqlite3VdbeReset(p);\n    assert( (rc & p->db->errMask)==rc );\n  }\n  sqlite3VdbeDelete(p);\n  return rc;\n}\n\n/*\n** Call the destructor for each auxdata entry in pVdbeFunc for which\n** the corresponding bit in mask is clear.  Auxdata entries beyond 31\n** are always destroyed.  To destroy all auxdata entries, call this\n** routine with mask==0.\n*/\nSQLITE_PRIVATE void sqlite3VdbeDeleteAuxData(VdbeFunc *pVdbeFunc, int mask){\n  int i;\n  for(i=0; i<pVdbeFunc->nAux; i++){\n    struct AuxData *pAux = &pVdbeFunc->apAux[i];\n    if( (i>31 || !(mask&(((u32)1)<<i))) && pAux->pAux ){\n      if( pAux->xDelete ){\n        pAux->xDelete(pAux->pAux);\n      }\n      pAux->pAux = 0;\n    }\n  }\n}\n\n/*\n** Free all memory associated with the Vdbe passed as the second argument.\n** The difference between this function and sqlite3VdbeDelete() is that\n** VdbeDelete() also unlinks the Vdbe from the list of VMs associated with\n** the database connection.\n*/\nSQLITE_PRIVATE void sqlite3VdbeDeleteObject(sqlite3 *db, Vdbe *p){\n  SubProgram *pSub, *pNext;\n  assert( p->db==0 || p->db==db );\n  releaseMemArray(p->aVar, p->nVar);\n  releaseMemArray(p->aColName, p->nResColumn*COLNAME_N);\n  for(pSub=p->pProgram; pSub; pSub=pNext){\n    pNext = pSub->pNext;\n    vdbeFreeOpArray(db, pSub->aOp, pSub->nOp);\n    sqlite3DbFree(db, pSub);\n  }\n  vdbeFreeOpArray(db, p->aOp, p->nOp);\n  sqlite3DbFree(db, p->aLabel);\n  sqlite3DbFree(db, p->aColName);\n  sqlite3DbFree(db, p->zSql);\n  sqlite3DbFree(db, p->pFree);\n  sqlite3DbFree(db, p);\n}\n\n/*\n** Delete an entire VDBE.\n*/\nSQLITE_PRIVATE void sqlite3VdbeDelete(Vdbe *p){\n  sqlite3 *db;\n\n  if( NEVER(p==0) ) return;\n  db = p->db;\n  if( p->pPrev ){\n    p->pPrev->pNext = p->pNext;\n  }else{\n    assert( db->pVdbe==p );\n    db->pVdbe = p->pNext;\n  }\n  if( p->pNext ){\n    p->pNext->pPrev = p->pPrev;\n  }\n  p->magic = VDBE_MAGIC_DEAD;\n  p->db = 0;\n  sqlite3VdbeDeleteObject(db, p);\n}\n\n/*\n** Make sure the cursor p is ready to read or write the row to which it\n** was last positioned.  Return an error code if an OOM fault or I/O error\n** prevents us from positioning the cursor to its correct position.\n**\n** If a MoveTo operation is pending on the given cursor, then do that\n** MoveTo now.  If no move is pending, check to see if the row has been\n** deleted out from under the cursor and if it has, mark the row as\n** a NULL row.\n**\n** If the cursor is already pointing to the correct row and that row has\n** not been deleted out from under the cursor, then this routine is a no-op.\n*/\nSQLITE_PRIVATE int sqlite3VdbeCursorMoveto(VdbeCursor *p){\n  if( p->deferredMoveto ){\n    int res, rc;\n#ifdef SQLITE_TEST\n    extern int sqlite3_search_count;\n#endif\n    assert( p->isTable );\n    rc = sqlite3BtreeMovetoUnpacked(p->pCursor, 0, p->movetoTarget, 0, &res);\n    if( rc ) return rc;\n    p->lastRowid = p->movetoTarget;\n    if( res!=0 ) return SQLITE_CORRUPT_BKPT;\n    p->rowidIsValid = 1;\n#ifdef SQLITE_TEST\n    sqlite3_search_count++;\n#endif\n    p->deferredMoveto = 0;\n    p->cacheStatus = CACHE_STALE;\n  }else if( ALWAYS(p->pCursor) ){\n    int hasMoved;\n    int rc = sqlite3BtreeCursorHasMoved(p->pCursor, &hasMoved);\n    if( rc ) return rc;\n    if( hasMoved ){\n      p->cacheStatus = CACHE_STALE;\n      p->nullRow = 1;\n    }\n  }\n  return SQLITE_OK;\n}\n\n/*\n** The following functions:\n**\n** sqlite3VdbeSerialType()\n** sqlite3VdbeSerialTypeLen()\n** sqlite3VdbeSerialLen()\n** sqlite3VdbeSerialPut()\n** sqlite3VdbeSerialGet()\n**\n** encapsulate the code that serializes values for storage in SQLite\n** data and index records. Each serialized value consists of a\n** 'serial-type' and a blob of data. The serial type is an 8-byte unsigned\n** integer, stored as a varint.\n**\n** In an SQLite index record, the serial type is stored directly before\n** the blob of data that it corresponds to. In a table record, all serial\n** types are stored at the start of the record, and the blobs of data at\n** the end. Hence these functions allow the caller to handle the\n** serial-type and data blob seperately.\n**\n** The following table describes the various storage classes for data:\n**\n**   serial type        bytes of data      type\n**   --------------     ---------------    ---------------\n**      0                     0            NULL\n**      1                     1            signed integer\n**      2                     2            signed integer\n**      3                     3            signed integer\n**      4                     4            signed integer\n**      5                     6            signed integer\n**      6                     8            signed integer\n**      7                     8            IEEE float\n**      8                     0            Integer constant 0\n**      9                     0            Integer constant 1\n**     10,11                               reserved for expansion\n**    N>=12 and even       (N-12)/2        BLOB\n**    N>=13 and odd        (N-13)/2        text\n**\n** The 8 and 9 types were added in 3.3.0, file format 4.  Prior versions\n** of SQLite will not understand those serial types.\n*/\n\n/*\n** Return the serial-type for the value stored in pMem.\n*/\nSQLITE_PRIVATE u32 sqlite3VdbeSerialType(Mem *pMem, int file_format){\n  int flags = pMem->flags;\n  int n;\n\n  if( flags&MEM_Null ){\n    return 0;\n  }\n  if( flags&MEM_Int ){\n    /* Figure out whether to use 1, 2, 4, 6 or 8 bytes. */\n#   define MAX_6BYTE ((((i64)0x00008000)<<32)-1)\n    i64 i = pMem->u.i;\n    u64 u;\n    if( file_format>=4 && (i&1)==i ){\n      return 8+(u32)i;\n    }\n    if( i<0 ){\n      if( i<(-MAX_6BYTE) ) return 6;\n      /* Previous test prevents:  u = -(-9223372036854775808) */\n      u = -i;\n    }else{\n      u = i;\n    }\n    if( u<=127 ) return 1;\n    if( u<=32767 ) return 2;\n    if( u<=8388607 ) return 3;\n    if( u<=2147483647 ) return 4;\n    if( u<=MAX_6BYTE ) return 5;\n    return 6;\n  }\n  if( flags&MEM_Real ){\n    return 7;\n  }\n  assert( pMem->db->mallocFailed || flags&(MEM_Str|MEM_Blob) );\n  n = pMem->n;\n  if( flags & MEM_Zero ){\n    n += pMem->u.nZero;\n  }\n  assert( n>=0 );\n  return ((n*2) + 12 + ((flags&MEM_Str)!=0));\n}\n\n/*\n** Return the length of the data corresponding to the supplied serial-type.\n*/\nSQLITE_PRIVATE u32 sqlite3VdbeSerialTypeLen(u32 serial_type){\n  if( serial_type>=12 ){\n    return (serial_type-12)/2;\n  }else{\n    static const u8 aSize[] = { 0, 1, 2, 3, 4, 6, 8, 8, 0, 0, 0, 0 };\n    return aSize[serial_type];\n  }\n}\n\n/*\n** If we are on an architecture with mixed-endian floating \n** points (ex: ARM7) then swap the lower 4 bytes with the \n** upper 4 bytes.  Return the result.\n**\n** For most architectures, this is a no-op.\n**\n** (later):  It is reported to me that the mixed-endian problem\n** on ARM7 is an issue with GCC, not with the ARM7 chip.  It seems\n** that early versions of GCC stored the two words of a 64-bit\n** float in the wrong order.  And that error has been propagated\n** ever since.  The blame is not necessarily with GCC, though.\n** GCC might have just copying the problem from a prior compiler.\n** I am also told that newer versions of GCC that follow a different\n** ABI get the byte order right.\n**\n** Developers using SQLite on an ARM7 should compile and run their\n** application using -DSQLITE_DEBUG=1 at least once.  With DEBUG\n** enabled, some asserts below will ensure that the byte order of\n** floating point values is correct.\n**\n** (2007-08-30)  Frank van Vugt has studied this problem closely\n** and has send his findings to the SQLite developers.  Frank\n** writes that some Linux kernels offer floating point hardware\n** emulation that uses only 32-bit mantissas instead of a full \n** 48-bits as required by the IEEE standard.  (This is the\n** CONFIG_FPE_FASTFPE option.)  On such systems, floating point\n** byte swapping becomes very complicated.  To avoid problems,\n** the necessary byte swapping is carried out using a 64-bit integer\n** rather than a 64-bit float.  Frank assures us that the code here\n** works for him.  We, the developers, have no way to independently\n** verify this, but Frank seems to know what he is talking about\n** so we trust him.\n*/\n#ifdef SQLITE_MIXED_ENDIAN_64BIT_FLOAT\nstatic u64 floatSwap(u64 in){\n  union {\n    u64 r;\n    u32 i[2];\n  } u;\n  u32 t;\n\n  u.r = in;\n  t = u.i[0];\n  u.i[0] = u.i[1];\n  u.i[1] = t;\n  return u.r;\n}\n# define swapMixedEndianFloat(X)  X = floatSwap(X)\n#else\n# define swapMixedEndianFloat(X)\n#endif\n\n/*\n** Write the serialized data blob for the value stored in pMem into \n** buf. It is assumed that the caller has allocated sufficient space.\n** Return the number of bytes written.\n**\n** nBuf is the amount of space left in buf[].  nBuf must always be\n** large enough to hold the entire field.  Except, if the field is\n** a blob with a zero-filled tail, then buf[] might be just the right\n** size to hold everything except for the zero-filled tail.  If buf[]\n** is only big enough to hold the non-zero prefix, then only write that\n** prefix into buf[].  But if buf[] is large enough to hold both the\n** prefix and the tail then write the prefix and set the tail to all\n** zeros.\n**\n** Return the number of bytes actually written into buf[].  The number\n** of bytes in the zero-filled tail is included in the return value only\n** if those bytes were zeroed in buf[].\n*/ \nSQLITE_PRIVATE u32 sqlite3VdbeSerialPut(u8 *buf, int nBuf, Mem *pMem, int file_format){\n  u32 serial_type = sqlite3VdbeSerialType(pMem, file_format);\n  u32 len;\n\n  /* Integer and Real */\n  if( serial_type<=7 && serial_type>0 ){\n    u64 v;\n    u32 i;\n    if( serial_type==7 ){\n      assert( sizeof(v)==sizeof(pMem->r) );\n      memcpy(&v, &pMem->r, sizeof(v));\n      swapMixedEndianFloat(v);\n    }else{\n      v = pMem->u.i;\n    }\n    len = i = sqlite3VdbeSerialTypeLen(serial_type);\n    assert( len<=(u32)nBuf );\n    while( i-- ){\n      buf[i] = (u8)(v&0xFF);\n      v >>= 8;\n    }\n    return len;\n  }\n\n  /* String or blob */\n  if( serial_type>=12 ){\n    assert( pMem->n + ((pMem->flags & MEM_Zero)?pMem->u.nZero:0)\n             == (int)sqlite3VdbeSerialTypeLen(serial_type) );\n    assert( pMem->n<=nBuf );\n    len = pMem->n;\n    memcpy(buf, pMem->z, len);\n    if( pMem->flags & MEM_Zero ){\n      len += pMem->u.nZero;\n      assert( nBuf>=0 );\n      if( len > (u32)nBuf ){\n        len = (u32)nBuf;\n      }\n      memset(&buf[pMem->n], 0, len-pMem->n);\n    }\n    return len;\n  }\n\n  /* NULL or constants 0 or 1 */\n  return 0;\n}\n\n/*\n** Deserialize the data blob pointed to by buf as serial type serial_type\n** and store the result in pMem.  Return the number of bytes read.\n*/ \nSQLITE_PRIVATE u32 sqlite3VdbeSerialGet(\n  const unsigned char *buf,     /* Buffer to deserialize from */\n  u32 serial_type,              /* Serial type to deserialize */\n  Mem *pMem                     /* Memory cell to write value into */\n){\n  switch( serial_type ){\n    case 10:   /* Reserved for future use */\n    case 11:   /* Reserved for future use */\n    case 0: {  /* NULL */\n      pMem->flags = MEM_Null;\n      break;\n    }\n    case 1: { /* 1-byte signed integer */\n      pMem->u.i = (signed char)buf[0];\n      pMem->flags = MEM_Int;\n      return 1;\n    }\n    case 2: { /* 2-byte signed integer */\n      pMem->u.i = (((signed char)buf[0])<<8) | buf[1];\n      pMem->flags = MEM_Int;\n      return 2;\n    }\n    case 3: { /* 3-byte signed integer */\n      pMem->u.i = (((signed char)buf[0])<<16) | (buf[1]<<8) | buf[2];\n      pMem->flags = MEM_Int;\n      return 3;\n    }\n    case 4: { /* 4-byte signed integer */\n      pMem->u.i = (buf[0]<<24) | (buf[1]<<16) | (buf[2]<<8) | buf[3];\n      pMem->flags = MEM_Int;\n      return 4;\n    }\n    case 5: { /* 6-byte signed integer */\n      u64 x = (((signed char)buf[0])<<8) | buf[1];\n      u32 y = (buf[2]<<24) | (buf[3]<<16) | (buf[4]<<8) | buf[5];\n      x = (x<<32) | y;\n      pMem->u.i = *(i64*)&x;\n      pMem->flags = MEM_Int;\n      return 6;\n    }\n    case 6:   /* 8-byte signed integer */\n    case 7: { /* IEEE floating point */\n      u64 x;\n      u32 y;\n#if !defined(NDEBUG) && !defined(SQLITE_OMIT_FLOATING_POINT)\n      /* Verify that integers and floating point values use the same\n      ** byte order.  Or, that if SQLITE_MIXED_ENDIAN_64BIT_FLOAT is\n      ** defined that 64-bit floating point values really are mixed\n      ** endian.\n      */\n      static const u64 t1 = ((u64)0x3ff00000)<<32;\n      static const double r1 = 1.0;\n      u64 t2 = t1;\n      swapMixedEndianFloat(t2);\n      assert( sizeof(r1)==sizeof(t2) && memcmp(&r1, &t2, sizeof(r1))==0 );\n#endif\n\n      x = (buf[0]<<24) | (buf[1]<<16) | (buf[2]<<8) | buf[3];\n      y = (buf[4]<<24) | (buf[5]<<16) | (buf[6]<<8) | buf[7];\n      x = (x<<32) | y;\n      if( serial_type==6 ){\n        pMem->u.i = *(i64*)&x;\n        pMem->flags = MEM_Int;\n      }else{\n        assert( sizeof(x)==8 && sizeof(pMem->r)==8 );\n        swapMixedEndianFloat(x);\n        memcpy(&pMem->r, &x, sizeof(x));\n        pMem->flags = sqlite3IsNaN(pMem->r) ? MEM_Null : MEM_Real;\n      }\n      return 8;\n    }\n    case 8:    /* Integer 0 */\n    case 9: {  /* Integer 1 */\n      pMem->u.i = serial_type-8;\n      pMem->flags = MEM_Int;\n      return 0;\n    }\n    default: {\n      u32 len = (serial_type-12)/2;\n      pMem->z = (char *)buf;\n      pMem->n = len;\n      pMem->xDel = 0;\n      if( serial_type&0x01 ){\n        pMem->flags = MEM_Str | MEM_Ephem;\n      }else{\n        pMem->flags = MEM_Blob | MEM_Ephem;\n      }\n      return len;\n    }\n  }\n  return 0;\n}\n\n\n/*\n** Given the nKey-byte encoding of a record in pKey[], parse the\n** record into a UnpackedRecord structure.  Return a pointer to\n** that structure.\n**\n** The calling function might provide szSpace bytes of memory\n** space at pSpace.  This space can be used to hold the returned\n** VDbeParsedRecord structure if it is large enough.  If it is\n** not big enough, space is obtained from sqlite3_malloc().\n**\n** The returned structure should be closed by a call to\n** sqlite3VdbeDeleteUnpackedRecord().\n*/ \nSQLITE_PRIVATE UnpackedRecord *sqlite3VdbeRecordUnpack(\n  KeyInfo *pKeyInfo,     /* Information about the record format */\n  int nKey,              /* Size of the binary record */\n  const void *pKey,      /* The binary record */\n  char *pSpace,          /* Unaligned space available to hold the object */\n  int szSpace            /* Size of pSpace[] in bytes */\n){\n  const unsigned char *aKey = (const unsigned char *)pKey;\n  UnpackedRecord *p;  /* The unpacked record that we will return */\n  int nByte;          /* Memory space needed to hold p, in bytes */\n  int d;\n  u32 idx;\n  u16 u;              /* Unsigned loop counter */\n  u32 szHdr;\n  Mem *pMem;\n  int nOff;           /* Increase pSpace by this much to 8-byte align it */\n  \n  /*\n  ** We want to shift the pointer pSpace up such that it is 8-byte aligned.\n  ** Thus, we need to calculate a value, nOff, between 0 and 7, to shift \n  ** it by.  If pSpace is already 8-byte aligned, nOff should be zero.\n  */\n  nOff = (8 - (SQLITE_PTR_TO_INT(pSpace) & 7)) & 7;\n  pSpace += nOff;\n  szSpace -= nOff;\n  nByte = ROUND8(sizeof(UnpackedRecord)) + sizeof(Mem)*(pKeyInfo->nField+1);\n  if( nByte>szSpace ){\n    p = sqlite3DbMallocRaw(pKeyInfo->db, nByte);\n    if( p==0 ) return 0;\n    p->flags = UNPACKED_NEED_FREE | UNPACKED_NEED_DESTROY;\n  }else{\n    p = (UnpackedRecord*)pSpace;\n    p->flags = UNPACKED_NEED_DESTROY;\n  }\n  p->pKeyInfo = pKeyInfo;\n  p->nField = pKeyInfo->nField + 1;\n  p->aMem = pMem = (Mem*)&((char*)p)[ROUND8(sizeof(UnpackedRecord))];\n  assert( EIGHT_BYTE_ALIGNMENT(pMem) );\n  idx = getVarint32(aKey, szHdr);\n  d = szHdr;\n  u = 0;\n  while( idx<szHdr && u<p->nField && d<=nKey ){\n    u32 serial_type;\n\n    idx += getVarint32(&aKey[idx], serial_type);\n    pMem->enc = pKeyInfo->enc;\n    pMem->db = pKeyInfo->db;\n    pMem->flags = 0;\n    pMem->zMalloc = 0;\n    d += sqlite3VdbeSerialGet(&aKey[d], serial_type, pMem);\n    pMem++;\n    u++;\n  }\n  assert( u<=pKeyInfo->nField + 1 );\n  p->nField = u;\n  return (void*)p;\n}\n\n/*\n** This routine destroys a UnpackedRecord object.\n*/\nSQLITE_PRIVATE void sqlite3VdbeDeleteUnpackedRecord(UnpackedRecord *p){\n  int i;\n  Mem *pMem;\n\n  assert( p!=0 );\n  assert( p->flags & UNPACKED_NEED_DESTROY );\n  for(i=0, pMem=p->aMem; i<p->nField; i++, pMem++){\n    /* The unpacked record is always constructed by the\n    ** sqlite3VdbeUnpackRecord() function above, which makes all\n    ** strings and blobs static.  And none of the elements are\n    ** ever transformed, so there is never anything to delete.\n    */\n    if( NEVER(pMem->zMalloc) ) sqlite3VdbeMemRelease(pMem);\n  }\n  if( p->flags & UNPACKED_NEED_FREE ){\n    sqlite3DbFree(p->pKeyInfo->db, p);\n  }\n}\n\n/*\n** This function compares the two table rows or index records\n** specified by {nKey1, pKey1} and pPKey2.  It returns a negative, zero\n** or positive integer if key1 is less than, equal to or \n** greater than key2.  The {nKey1, pKey1} key must be a blob\n** created by th OP_MakeRecord opcode of the VDBE.  The pPKey2\n** key must be a parsed key such as obtained from\n** sqlite3VdbeParseRecord.\n**\n** Key1 and Key2 do not have to contain the same number of fields.\n** The key with fewer fields is usually compares less than the \n** longer key.  However if the UNPACKED_INCRKEY flags in pPKey2 is set\n** and the common prefixes are equal, then key1 is less than key2.\n** Or if the UNPACKED_MATCH_PREFIX flag is set and the prefixes are\n** equal, then the keys are considered to be equal and\n** the parts beyond the common prefix are ignored.\n**\n** If the UNPACKED_IGNORE_ROWID flag is set, then the last byte of\n** the header of pKey1 is ignored.  It is assumed that pKey1 is\n** an index key, and thus ends with a rowid value.  The last byte\n** of the header will therefore be the serial type of the rowid:\n** one of 1, 2, 3, 4, 5, 6, 8, or 9 - the integer serial types.\n** The serial type of the final rowid will always be a single byte.\n** By ignoring this last byte of the header, we force the comparison\n** to ignore the rowid at the end of key1.\n*/\nSQLITE_PRIVATE int sqlite3VdbeRecordCompare(\n  int nKey1, const void *pKey1, /* Left key */\n  UnpackedRecord *pPKey2,       /* Right key */\n  int startField,               /* first field index to start comparison from */\n  int *pRestartField            /* Can be null.  If not null, *pRestartField will ONLY be set if this\n                                   function is returning exactly 0.  In that case, it will be set as follows:\n                                   If both\n                                     a) key1 is a partial record\n                                     b) the comparison result could not be determined from the partial record\n                                   then it will be set to the field index to start comparison from after loading more data.\n                                   Otherwise, it will be set to -1. */\n){\n  int d1;            /* Offset into aKey[] of next data element */\n  u32 idx1;          /* Offset into aKey[] of next header element */\n  u32 szHdr1;        /* Number of bytes in header */\n  int i = 0;\n  int nField;\n  int rc = 0;\n  const unsigned char *aKey1 = (const unsigned char *)pKey1;\n  KeyInfo *pKeyInfo;\n  Mem mem1;\n\n  pKeyInfo = pPKey2->pKeyInfo;\n  mem1.enc = pKeyInfo->enc;\n  mem1.db = pKeyInfo->db;\n  /* mem1.flags = 0;  // Will be initialized by sqlite3VdbeSerialGet() */\n  VVA_ONLY( mem1.zMalloc = 0; ) /* Only needed by assert() statements */\n\n  /* Compilers may complain that mem1.u.i is potentially uninitialized.\n  ** We could initialize it, as shown here, to silence those complaints.\n  ** But in fact, mem1.u.i will never actually be used initialized, and doing \n  ** the unnecessary initialization has a measurable negative performance\n  ** impact, since this routine is a very high runner.  And so, we choose\n  ** to ignore the compiler warnings and leave this variable uninitialized.\n  */\n  /*  mem1.u.i = 0;  // not needed, here to silence compiler warning */\n  \n  /* idx1 is the position of the type/length of the next record field */\n  idx1 = getVarint32(aKey1, szHdr1);\n\n  /* d1 is the offset of the content of the next record field */\n  d1 = szHdr1;\n  if( pPKey2->flags & UNPACKED_IGNORE_ROWID ){\n    szHdr1--;\n  }\n\n  /* If key1 buffer isn't even long enough to hold the entire header\n   * then return 0 with nextField set to 0 */\n  if(d1 > nKey1) {\n    if(pRestartField)\n      *pRestartField = 0;\n    return 0;\n  }\n  \n  nField = pKeyInfo->nField;\n  /* While the next key1 type/len position is still within the header\n   * and the next key2 field i is less than key2 field count */\n  while( idx1<szHdr1 && i<pPKey2->nField ){\n    u32 serial_type1;\n\n    /* Get the type/len of the next key1 field and advance idx1 */\n    idx1 += getVarint32( aKey1+idx1, serial_type1 );\n    /* Get the len of the next key1 field based on its type/len composite */\n    u32 len1 = sqlite3VdbeSerialTypeLen(serial_type1);\n\n    /* If key1 buffer is not big enough to contain entire field */\n    if(d1 + len1 > nKey1) {\n      /* If start field is ahead of this partial field then the comparison was supposed to skip this field.\n       * We can't 'skip' it because there are no more fields after this partial field, but the continuation\n       * call should not start before startField after more data is loaded so just set pRestartField to \n       * startField and return 0. */\n      if(startField > i) {\n        if(pRestartField)\n          *pRestartField = startField;\n        return 0;\n      }\n\n      /* Reduce len1 to the amount of bytes we actually have available */\n      len1 = nKey1 - d1;\n\n      /* If both key1 and key2 fields are of the same type and the type\n       * is BLOB or STRING then truncate key2 field to be no longer then\n       * the available length of key1 field and compare. */\n      u32 serial_type2 = sqlite3VdbeSerialType(&pPKey2->aMem[i], pKeyInfo->db->aDb->pSchema->file_format);\n      \n      if(    serial_type1 >= 12 && serial_type2 >= 12\n         && (serial_type1 & 0x01) == (serial_type2 & 0x01))\n      {\n        /* Decode key1 field, then patch its length to be only the available bytes */\n        d1 += sqlite3VdbeSerialGet(&aKey1[d1], serial_type1, &mem1);\n        mem1.n = len1;\n\n        /* Temporarily truncate key2 field to length of key1 field */\n        int orig_len2 = pPKey2->aMem[i].n;\n        if(pPKey2->aMem[i].n > len1)\n          pPKey2->aMem[i].n = len1;\n\n        /* Do comparison of partial key1 and potentially truncated key2 */\n        rc = sqlite3MemCompare(&mem1, &pPKey2->aMem[i],\n                           i<nField ? pKeyInfo->aColl[i] : 0);\n        \n        /* Restore key2 field len */\n        pPKey2->aMem[i].n = orig_len2;\n        \n      } else {\n        /* Types do not match so no partial comparison could be done.  The result of this is\n         * the same as the partial fields being equal as in both cases we cannot determine the \n         * comparison result with the data available. */\n        rc = 0;\n      }\n      \n      /* If a definitive result was not found then set *pNextField and return */\n      if(rc == 0) {\n        if(pRestartField)\n          *pRestartField = i;\n        return rc;\n      }\n\n    } else {\n      /* key1 value is complete.  If start field is ahead of i then just advance d1 to the next\n       * value within key1 and set rc to 0 so the record comparison will advance to the next field.\n       * Otherwise extract the key1 value and compare. */\n      if(startField > i) {\n        d1 += len1;\n        rc = 0;\n      }\n      else {\n        d1 += sqlite3VdbeSerialGet(&aKey1[d1], serial_type1, &mem1);\n        rc = sqlite3MemCompare(&mem1, &pPKey2->aMem[i], i<nField ? pKeyInfo->aColl[i] : 0);\n      }\n    }\n\n    if( rc!=0 ){\n      assert( mem1.zMalloc==0 );  /* See comment below */\n\n      /* Invert the result if we are using DESC sort order. */\n      if( pKeyInfo->aSortOrder && i<nField && pKeyInfo->aSortOrder[i] ){\n        rc = -rc;\n      }\n    \n      /* If the PREFIX_SEARCH flag is set and all fields except the final\n      ** rowid field were equal, then clear the PREFIX_SEARCH flag and set \n      ** pPKey2->rowid to the value of the rowid field in (pKey1, nKey1).\n      ** This is used by the OP_IsUnique opcode.\n      */\n      if( (pPKey2->flags & UNPACKED_PREFIX_SEARCH) && i==(pPKey2->nField-1) ){\n        assert( idx1==szHdr1 && rc );\n        assert( mem1.flags & MEM_Int );\n        pPKey2->flags &= ~UNPACKED_PREFIX_SEARCH;\n        pPKey2->rowid = mem1.u.i;\n      }\n\n      return rc;\n    }\n    i++;\n  }\n\n  /* An incomplete field was not encountered so comparison is complete. */\n  if(pRestartField)\n    *pRestartField = -1;\n  \n  /* No memory allocation is ever used on mem1.  Prove this using\n  ** the following assert().  If the assert() fails, it indicates a\n  ** memory leak and a need to call sqlite3VdbeMemRelease(&mem1).\n  */\n  assert( mem1.zMalloc==0 );\n\n  /* rc==0 here means that one of the keys ran out of fields and\n  ** all the fields up to that point were equal. If the UNPACKED_INCRKEY\n  ** flag is set, then break the tie by treating key2 as larger.\n  ** If the UPACKED_PREFIX_MATCH flag is set, then keys with common prefixes\n  ** are considered to be equal.  Otherwise, the longer key is the \n  ** larger.  As it happens, the pPKey2 will always be the longer\n  ** if there is a difference.\n  */\n  assert( rc==0 );\n  if( pPKey2->flags & UNPACKED_INCRKEY ){\n    rc = -1;\n  }else if( pPKey2->flags & UNPACKED_PREFIX_MATCH ){\n    /* Leave rc==0 */\n  }else if( idx1<szHdr1 ){\n    rc = 1;\n  }\n\n  return rc;\n}\n \n\n/*\n** pCur points at an index entry created using the OP_MakeRecord opcode.\n** Read the rowid (the last field in the record) and store it in *rowid.\n** Return SQLITE_OK if everything works, or an error code otherwise.\n**\n** pCur might be pointing to text obtained from a corrupt database file.\n** So the content cannot be trusted.  Do appropriate checks on the content.\n*/\nSQLITE_PRIVATE int sqlite3VdbeIdxRowid(sqlite3 *db, BtCursor *pCur, i64 *rowid){\n  i64 nCellKey = 0;\n  int rc;\n  u32 szHdr;        /* Size of the header */\n  u32 typeRowid;    /* Serial type of the rowid */\n  u32 lenRowid;     /* Size of the rowid */\n  Mem m, v;\n\n  UNUSED_PARAMETER(db);\n\n  /* Get the size of the index entry.  Only indices entries of less\n  ** than 2GiB are support - anything large must be database corruption.\n  ** Any corruption is detected in sqlite3BtreeParseCellPtr(), though, so\n  ** this code can safely assume that nCellKey is 32-bits  \n  */\n  assert( sqlite3BtreeCursorIsValid(pCur) );\n  rc = sqlite3BtreeKeySize(pCur, &nCellKey);\n  assert( rc==SQLITE_OK );     /* pCur is always valid so KeySize cannot fail */\n  assert( (nCellKey & SQLITE_MAX_U32)==(u64)nCellKey );\n\n  /* Read in the complete content of the index entry */\n  memset(&m, 0, sizeof(m));\n  rc = sqlite3VdbeMemFromBtree(pCur, 0, (int)nCellKey, 1, &m);\n  if( rc ){\n    return rc;\n  }\n\n  /* The index entry must begin with a header size */\n  (void)getVarint32((u8*)m.z, szHdr);\n  testcase( szHdr==3 );\n  testcase( szHdr==m.n );\n  if( unlikely(szHdr<3 || (int)szHdr>m.n) ){\n    goto idx_rowid_corruption;\n  }\n\n  /* The last field of the index should be an integer - the ROWID.\n  ** Verify that the last entry really is an integer. */\n  (void)getVarint32((u8*)&m.z[szHdr-1], typeRowid);\n  testcase( typeRowid==1 );\n  testcase( typeRowid==2 );\n  testcase( typeRowid==3 );\n  testcase( typeRowid==4 );\n  testcase( typeRowid==5 );\n  testcase( typeRowid==6 );\n  testcase( typeRowid==8 );\n  testcase( typeRowid==9 );\n  if( unlikely(typeRowid<1 || typeRowid>9 || typeRowid==7) ){\n    goto idx_rowid_corruption;\n  }\n  lenRowid = sqlite3VdbeSerialTypeLen(typeRowid);\n  testcase( (u32)m.n==szHdr+lenRowid );\n  if( unlikely((u32)m.n<szHdr+lenRowid) ){\n    goto idx_rowid_corruption;\n  }\n\n  /* Fetch the integer off the end of the index record */\n  sqlite3VdbeSerialGet((u8*)&m.z[m.n-lenRowid], typeRowid, &v);\n  *rowid = v.u.i;\n  sqlite3VdbeMemRelease(&m);\n  return SQLITE_OK;\n\n  /* Jump here if database corruption is detected after m has been\n  ** allocated.  Free the m object and return SQLITE_CORRUPT. */\nidx_rowid_corruption:\n  testcase( m.zMalloc!=0 );\n  sqlite3VdbeMemRelease(&m);\n  return SQLITE_CORRUPT_BKPT;\n}\n\n/*\n** Compare the key of the index entry that cursor pC is pointing to against\n** the key string in pUnpacked.  Write into *pRes a number\n** that is negative, zero, or positive if pC is less than, equal to,\n** or greater than pUnpacked.  Return SQLITE_OK on success.\n**\n** pUnpacked is either created without a rowid or is truncated so that it\n** omits the rowid at the end.  The rowid at the end of the index entry\n** is ignored as well.  Hence, this routine only compares the prefixes \n** of the keys prior to the final rowid, not the entire key.\n*/\nSQLITE_PRIVATE int sqlite3VdbeIdxKeyCompare(\n  VdbeCursor *pC,             /* The cursor to compare against */\n  UnpackedRecord *pUnpacked,  /* Unpacked version of key to compare against */\n  int *res                    /* Write the comparison result here */\n){\n  i64 nCellKey = 0;\n  int rc;\n  BtCursor *pCur = pC->pCursor;\n  Mem m;\n\n  assert( sqlite3BtreeCursorIsValid(pCur) );\n  rc = sqlite3BtreeKeySize(pCur, &nCellKey);\n  assert( rc==SQLITE_OK );    /* pCur is always valid so KeySize cannot fail */\n  /* nCellKey will always be between 0 and 0xffffffff because of the say\n  ** that btreeParseCellPtr() and sqlite3GetVarint32() are implemented */\n  if( nCellKey<=0 || nCellKey>0x7fffffff ){\n    *res = 0;\n    return SQLITE_CORRUPT_BKPT;\n  }\n  memset(&m, 0, sizeof(m));\n  rc = sqlite3VdbeMemFromBtree(pC->pCursor, 0, (int)nCellKey, 1, &m);\n  if( rc ){\n    return rc;\n  }\n  assert( pUnpacked->flags & UNPACKED_IGNORE_ROWID );\n  *res = sqlite3VdbeRecordCompare(m.n, m.z, pUnpacked, 0, NULL);\n  sqlite3VdbeMemRelease(&m);\n  return SQLITE_OK;\n}\n\n/*\n** This routine sets the value to be returned by subsequent calls to\n** sqlite3_changes() on the database handle 'db'. \n*/\nSQLITE_PRIVATE void sqlite3VdbeSetChanges(sqlite3 *db, int nChange){\n  assert( sqlite3_mutex_held(db->mutex) );\n  db->nChange = nChange;\n  db->nTotalChange += nChange;\n}\n\n/*\n** Set a flag in the vdbe to update the change counter when it is finalised\n** or reset.\n*/\nSQLITE_PRIVATE void sqlite3VdbeCountChanges(Vdbe *v){\n  v->changeCntOn = 1;\n}\n\n/*\n** Mark every prepared statement associated with a database connection\n** as expired.\n**\n** An expired statement means that recompilation of the statement is\n** recommend.  Statements expire when things happen that make their\n** programs obsolete.  Removing user-defined functions or collating\n** sequences, or changing an authorization function are the types of\n** things that make prepared statements obsolete.\n*/\nSQLITE_PRIVATE void sqlite3ExpirePreparedStatements(sqlite3 *db){\n  Vdbe *p;\n  for(p = db->pVdbe; p; p=p->pNext){\n    p->expired = 1;\n  }\n}\n\n/*\n** Return the database associated with the Vdbe.\n*/\nSQLITE_PRIVATE sqlite3 *sqlite3VdbeDb(Vdbe *v){\n  return v->db;\n}\n\n/*\n** Return a pointer to an sqlite3_value structure containing the value bound\n** parameter iVar of VM v. Except, if the value is an SQL NULL, return \n** 0 instead. Unless it is NULL, apply affinity aff (one of the SQLITE_AFF_*\n** constants) to the value before returning it.\n**\n** The returned value must be freed by the caller using sqlite3ValueFree().\n*/\nSQLITE_PRIVATE sqlite3_value *sqlite3VdbeGetValue(Vdbe *v, int iVar, u8 aff){\n  assert( iVar>0 );\n  if( v ){\n    Mem *pMem = &v->aVar[iVar-1];\n    if( 0==(pMem->flags & MEM_Null) ){\n      sqlite3_value *pRet = sqlite3ValueNew(v->db);\n      if( pRet ){\n        sqlite3VdbeMemCopy((Mem *)pRet, pMem);\n        sqlite3ValueApplyAffinity(pRet, aff, SQLITE_UTF8);\n        sqlite3VdbeMemStoreType((Mem *)pRet);\n      }\n      return pRet;\n    }\n  }\n  return 0;\n}\n\n/*\n** Configure SQL variable iVar so that binding a new value to it signals\n** to sqlite3_reoptimize() that re-preparing the statement may result\n** in a better query plan.\n*/\nSQLITE_PRIVATE void sqlite3VdbeSetVarmask(Vdbe *v, int iVar){\n  assert( iVar>0 );\n  if( iVar>32 ){\n    v->expmask = 0xffffffff;\n  }else{\n    v->expmask |= ((u32)1 << (iVar-1));\n  }\n}\n\n/************** End of vdbeaux.c *********************************************/\n/************** Begin file vdbeapi.c *****************************************/\n/*\n** 2004 May 26\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n**\n** This file contains code use to implement APIs that are part of the\n** VDBE.\n*/\n\n#ifndef SQLITE_OMIT_DEPRECATED\n/*\n** Return TRUE (non-zero) of the statement supplied as an argument needs\n** to be recompiled.  A statement needs to be recompiled whenever the\n** execution environment changes in a way that would alter the program\n** that sqlite3_prepare() generates.  For example, if new functions or\n** collating sequences are registered or if an authorizer function is\n** added or changed.\n*/\nSQLITE_API int sqlite3_expired(sqlite3_stmt *pStmt){\n  Vdbe *p = (Vdbe*)pStmt;\n  return p==0 || p->expired;\n}\n#endif\n\n/*\n** Check on a Vdbe to make sure it has not been finalized.  Log\n** an error and return true if it has been finalized (or is otherwise\n** invalid).  Return false if it is ok.\n*/\nstatic int vdbeSafety(Vdbe *p){\n  if( p->db==0 ){\n    sqlite3_log(SQLITE_MISUSE, \"API called with finalized prepared statement\");\n    return 1;\n  }else{\n    return 0;\n  }\n}\nstatic int vdbeSafetyNotNull(Vdbe *p){\n  if( p==0 ){\n    sqlite3_log(SQLITE_MISUSE, \"API called with NULL prepared statement\");\n    return 1;\n  }else{\n    return vdbeSafety(p);\n  }\n}\n\n/*\n** The following routine destroys a virtual machine that is created by\n** the sqlite3_compile() routine. The integer returned is an SQLITE_\n** success/failure code that describes the result of executing the virtual\n** machine.\n**\n** This routine sets the error code and string returned by\n** sqlite3_errcode(), sqlite3_errmsg() and sqlite3_errmsg16().\n*/\nSQLITE_API int sqlite3_finalize(sqlite3_stmt *pStmt){\n  int rc;\n  if( pStmt==0 ){\n    /* IMPLEMENTATION-OF: R-57228-12904 Invoking sqlite3_finalize() on a NULL\n    ** pointer is a harmless no-op. */\n    rc = SQLITE_OK;\n  }else{\n    Vdbe *v = (Vdbe*)pStmt;\n    sqlite3 *db = v->db;\n#if SQLITE_THREADSAFE\n    sqlite3_mutex *mutex;\n#endif\n    if( vdbeSafety(v) ) return SQLITE_MISUSE_BKPT;\n#if SQLITE_THREADSAFE\n    mutex = v->db->mutex;\n#endif\n    sqlite3_mutex_enter(mutex);\n    rc = sqlite3VdbeFinalize(v);\n    rc = sqlite3ApiExit(db, rc);\n    sqlite3_mutex_leave(mutex);\n  }\n  return rc;\n}\n\n/*\n** Terminate the current execution of an SQL statement and reset it\n** back to its starting state so that it can be reused. A success code from\n** the prior execution is returned.\n**\n** This routine sets the error code and string returned by\n** sqlite3_errcode(), sqlite3_errmsg() and sqlite3_errmsg16().\n*/\nSQLITE_API int sqlite3_reset(sqlite3_stmt *pStmt){\n  int rc;\n  if( pStmt==0 ){\n    rc = SQLITE_OK;\n  }else{\n    Vdbe *v = (Vdbe*)pStmt;\n    sqlite3_mutex_enter(v->db->mutex);\n    rc = sqlite3VdbeReset(v);\n    sqlite3VdbeMakeReady(v, -1, 0, 0, 0, 0, 0);\n    assert( (rc & (v->db->errMask))==rc );\n    rc = sqlite3ApiExit(v->db, rc);\n    sqlite3_mutex_leave(v->db->mutex);\n  }\n  return rc;\n}\n\n/*\n** Set all the parameters in the compiled SQL statement to NULL.\n*/\nSQLITE_API int sqlite3_clear_bindings(sqlite3_stmt *pStmt){\n  int i;\n  int rc = SQLITE_OK;\n  Vdbe *p = (Vdbe*)pStmt;\n#if SQLITE_THREADSAFE\n  sqlite3_mutex *mutex = ((Vdbe*)pStmt)->db->mutex;\n#endif\n  sqlite3_mutex_enter(mutex);\n  for(i=0; i<p->nVar; i++){\n    sqlite3VdbeMemRelease(&p->aVar[i]);\n    p->aVar[i].flags = MEM_Null;\n  }\n  if( p->isPrepareV2 && p->expmask ){\n    p->expired = 1;\n  }\n  sqlite3_mutex_leave(mutex);\n  return rc;\n}\n\n\n/**************************** sqlite3_value_  *******************************\n** The following routines extract information from a Mem or sqlite3_value\n** structure.\n*/\nSQLITE_API const void *sqlite3_value_blob(sqlite3_value *pVal){\n  Mem *p = (Mem*)pVal;\n  if( p->flags & (MEM_Blob|MEM_Str) ){\n    sqlite3VdbeMemExpandBlob(p);\n    p->flags &= ~MEM_Str;\n    p->flags |= MEM_Blob;\n    return p->n ? p->z : 0;\n  }else{\n    return sqlite3_value_text(pVal);\n  }\n}\nSQLITE_API int sqlite3_value_bytes(sqlite3_value *pVal){\n  return sqlite3ValueBytes(pVal, SQLITE_UTF8);\n}\nSQLITE_API int sqlite3_value_bytes16(sqlite3_value *pVal){\n  return sqlite3ValueBytes(pVal, SQLITE_UTF16NATIVE);\n}\nSQLITE_API double sqlite3_value_double(sqlite3_value *pVal){\n  return sqlite3VdbeRealValue((Mem*)pVal);\n}\nSQLITE_API int sqlite3_value_int(sqlite3_value *pVal){\n  return (int)sqlite3VdbeIntValue((Mem*)pVal);\n}\nSQLITE_API sqlite_int64 sqlite3_value_int64(sqlite3_value *pVal){\n  return sqlite3VdbeIntValue((Mem*)pVal);\n}\nSQLITE_API const unsigned char *sqlite3_value_text(sqlite3_value *pVal){\n  return (const unsigned char *)sqlite3ValueText(pVal, SQLITE_UTF8);\n}\n#ifndef SQLITE_OMIT_UTF16\nSQLITE_API const void *sqlite3_value_text16(sqlite3_value* pVal){\n  return sqlite3ValueText(pVal, SQLITE_UTF16NATIVE);\n}\nSQLITE_API const void *sqlite3_value_text16be(sqlite3_value *pVal){\n  return sqlite3ValueText(pVal, SQLITE_UTF16BE);\n}\nSQLITE_API const void *sqlite3_value_text16le(sqlite3_value *pVal){\n  return sqlite3ValueText(pVal, SQLITE_UTF16LE);\n}\n#endif /* SQLITE_OMIT_UTF16 */\nSQLITE_API int sqlite3_value_type(sqlite3_value* pVal){\n  return pVal->type;\n}\n\n/**************************** sqlite3_result_  *******************************\n** The following routines are used by user-defined functions to specify\n** the function result.\n**\n** The setStrOrError() funtion calls sqlite3VdbeMemSetStr() to store the\n** result as a string or blob but if the string or blob is too large, it\n** then sets the error code to SQLITE_TOOBIG\n*/\nstatic void setResultStrOrError(\n  sqlite3_context *pCtx,  /* Function context */\n  const char *z,          /* String pointer */\n  int n,                  /* Bytes in string, or negative */\n  u8 enc,                 /* Encoding of z.  0 for BLOBs */\n  void (*xDel)(void*)     /* Destructor function */\n){\n  if( sqlite3VdbeMemSetStr(&pCtx->s, z, n, enc, xDel)==SQLITE_TOOBIG ){\n    sqlite3_result_error_toobig(pCtx);\n  }\n}\nSQLITE_API void sqlite3_result_blob(\n  sqlite3_context *pCtx, \n  const void *z, \n  int n, \n  void (*xDel)(void *)\n){\n  assert( n>=0 );\n  assert( sqlite3_mutex_held(pCtx->s.db->mutex) );\n  setResultStrOrError(pCtx, z, n, 0, xDel);\n}\nSQLITE_API void sqlite3_result_double(sqlite3_context *pCtx, double rVal){\n  assert( sqlite3_mutex_held(pCtx->s.db->mutex) );\n  sqlite3VdbeMemSetDouble(&pCtx->s, rVal);\n}\nSQLITE_API void sqlite3_result_error(sqlite3_context *pCtx, const char *z, int n){\n  assert( sqlite3_mutex_held(pCtx->s.db->mutex) );\n  pCtx->isError = SQLITE_ERROR;\n  sqlite3VdbeMemSetStr(&pCtx->s, z, n, SQLITE_UTF8, SQLITE_TRANSIENT);\n}\n#ifndef SQLITE_OMIT_UTF16\nSQLITE_API void sqlite3_result_error16(sqlite3_context *pCtx, const void *z, int n){\n  assert( sqlite3_mutex_held(pCtx->s.db->mutex) );\n  pCtx->isError = SQLITE_ERROR;\n  sqlite3VdbeMemSetStr(&pCtx->s, z, n, SQLITE_UTF16NATIVE, SQLITE_TRANSIENT);\n}\n#endif\nSQLITE_API void sqlite3_result_int(sqlite3_context *pCtx, int iVal){\n  assert( sqlite3_mutex_held(pCtx->s.db->mutex) );\n  sqlite3VdbeMemSetInt64(&pCtx->s, (i64)iVal);\n}\nSQLITE_API void sqlite3_result_int64(sqlite3_context *pCtx, i64 iVal){\n  assert( sqlite3_mutex_held(pCtx->s.db->mutex) );\n  sqlite3VdbeMemSetInt64(&pCtx->s, iVal);\n}\nSQLITE_API void sqlite3_result_null(sqlite3_context *pCtx){\n  assert( sqlite3_mutex_held(pCtx->s.db->mutex) );\n  sqlite3VdbeMemSetNull(&pCtx->s);\n}\nSQLITE_API void sqlite3_result_text(\n  sqlite3_context *pCtx, \n  const char *z, \n  int n,\n  void (*xDel)(void *)\n){\n  assert( sqlite3_mutex_held(pCtx->s.db->mutex) );\n  setResultStrOrError(pCtx, z, n, SQLITE_UTF8, xDel);\n}\n#ifndef SQLITE_OMIT_UTF16\nSQLITE_API void sqlite3_result_text16(\n  sqlite3_context *pCtx, \n  const void *z, \n  int n, \n  void (*xDel)(void *)\n){\n  assert( sqlite3_mutex_held(pCtx->s.db->mutex) );\n  setResultStrOrError(pCtx, z, n, SQLITE_UTF16NATIVE, xDel);\n}\nSQLITE_API void sqlite3_result_text16be(\n  sqlite3_context *pCtx, \n  const void *z, \n  int n, \n  void (*xDel)(void *)\n){\n  assert( sqlite3_mutex_held(pCtx->s.db->mutex) );\n  setResultStrOrError(pCtx, z, n, SQLITE_UTF16BE, xDel);\n}\nSQLITE_API void sqlite3_result_text16le(\n  sqlite3_context *pCtx, \n  const void *z, \n  int n, \n  void (*xDel)(void *)\n){\n  assert( sqlite3_mutex_held(pCtx->s.db->mutex) );\n  setResultStrOrError(pCtx, z, n, SQLITE_UTF16LE, xDel);\n}\n#endif /* SQLITE_OMIT_UTF16 */\nSQLITE_API void sqlite3_result_value(sqlite3_context *pCtx, sqlite3_value *pValue){\n  assert( sqlite3_mutex_held(pCtx->s.db->mutex) );\n  sqlite3VdbeMemCopy(&pCtx->s, pValue);\n}\nSQLITE_API void sqlite3_result_zeroblob(sqlite3_context *pCtx, int n){\n  assert( sqlite3_mutex_held(pCtx->s.db->mutex) );\n  sqlite3VdbeMemSetZeroBlob(&pCtx->s, n);\n}\nSQLITE_API void sqlite3_result_error_code(sqlite3_context *pCtx, int errCode){\n  pCtx->isError = errCode;\n  if( pCtx->s.flags & MEM_Null ){\n    sqlite3VdbeMemSetStr(&pCtx->s, sqlite3ErrStr(errCode), -1, \n                         SQLITE_UTF8, SQLITE_STATIC);\n  }\n}\n\n/* Force an SQLITE_TOOBIG error. */\nSQLITE_API void sqlite3_result_error_toobig(sqlite3_context *pCtx){\n  assert( sqlite3_mutex_held(pCtx->s.db->mutex) );\n  pCtx->isError = SQLITE_TOOBIG;\n  sqlite3VdbeMemSetStr(&pCtx->s, \"string or blob too big\", -1, \n                       SQLITE_UTF8, SQLITE_STATIC);\n}\n\n/* An SQLITE_NOMEM error. */\nSQLITE_API void sqlite3_result_error_nomem(sqlite3_context *pCtx){\n  assert( sqlite3_mutex_held(pCtx->s.db->mutex) );\n  sqlite3VdbeMemSetNull(&pCtx->s);\n  pCtx->isError = SQLITE_NOMEM;\n  pCtx->s.db->mallocFailed = 1;\n}\n\n/*\n** This function is called after a transaction has been committed. It \n** invokes callbacks registered with sqlite3_wal_hook() as required.\n*/\nstatic int doWalCallbacks(sqlite3 *db){\n  int rc = SQLITE_OK;\n#ifndef SQLITE_OMIT_WAL\n  int i;\n  for(i=0; i<db->nDb; i++){\n    Btree *pBt = db->aDb[i].pBt;\n    if( pBt ){\n      int nEntry = sqlite3PagerWalCallback(sqlite3BtreePager(pBt));\n      if( db->xWalCallback && nEntry>0 && rc==SQLITE_OK ){\n        rc = db->xWalCallback(db->pWalArg, db, db->aDb[i].zName, nEntry);\n      }\n    }\n  }\n#endif\n  return rc;\n}\n\n/*\n** Execute the statement pStmt, either until a row of data is ready, the\n** statement is completely executed or an error occurs.\n**\n** This routine implements the bulk of the logic behind the sqlite_step()\n** API.  The only thing omitted is the automatic recompile if a \n** schema change has occurred.  That detail is handled by the\n** outer sqlite3_step() wrapper procedure.\n*/\nstatic int sqlite3Step(Vdbe *p){\n  sqlite3 *db;\n  int rc;\n\n  assert(p);\n  if( p->magic!=VDBE_MAGIC_RUN ){\n    /* We used to require that sqlite3_reset() be called before retrying\n    ** sqlite3_step() after any error or after SQLITE_DONE.  But beginning\n    ** with version 3.7.0, we changed this so that sqlite3_reset() would\n    ** be called automatically instead of throwing the SQLITE_MISUSE error.\n    ** This \"automatic-reset\" change is not technically an incompatibility, \n    ** since any application that receives an SQLITE_MISUSE is broken by\n    ** definition.\n    **\n    ** Nevertheless, some published applications that were originally written\n    ** for version 3.6.23 or earlier do in fact depend on SQLITE_MISUSE \n    ** returns, and the so were broken by the automatic-reset change.  As a\n    ** a work-around, the SQLITE_OMIT_AUTORESET compile-time restores the\n    ** legacy behavior of returning SQLITE_MISUSE for cases where the \n    ** previous sqlite3_step() returned something other than a SQLITE_LOCKED\n    ** or SQLITE_BUSY error.\n    */\n#ifdef SQLITE_OMIT_AUTORESET\n    if( p->rc==SQLITE_BUSY || p->rc==SQLITE_LOCKED ){\n      sqlite3_reset((sqlite3_stmt*)p);\n    }else{\n      return SQLITE_MISUSE_BKPT;\n    }\n#else\n    sqlite3_reset((sqlite3_stmt*)p);\n#endif\n  }\n\n  /* Check that malloc() has not failed. If it has, return early. */\n  db = p->db;\n  if( db->mallocFailed ){\n    p->rc = SQLITE_NOMEM;\n    return SQLITE_NOMEM;\n  }\n\n  if( p->pc<=0 && p->expired ){\n    p->rc = SQLITE_SCHEMA;\n    rc = SQLITE_ERROR;\n    goto end_of_step;\n  }\n  if( p->pc<0 ){\n    /* If there are no other statements currently running, then\n    ** reset the interrupt flag.  This prevents a call to sqlite3_interrupt\n    ** from interrupting a statement that has not yet started.\n    */\n    if( db->activeVdbeCnt==0 ){\n      db->u1.isInterrupted = 0;\n    }\n\n    assert( db->writeVdbeCnt>0 || db->autoCommit==0 || db->nDeferredCons==0 );\n\n#ifndef SQLITE_OMIT_TRACE\n    if( db->xProfile && !db->init.busy ){\n      sqlite3OsCurrentTimeInt64(db->pVfs, &p->startTime);\n    }\n#endif\n\n    db->activeVdbeCnt++;\n    if( p->readOnly==0 ) db->writeVdbeCnt++;\n    p->pc = 0;\n  }\n#ifndef SQLITE_OMIT_EXPLAIN\n  if( p->explain ){\n    rc = sqlite3VdbeList(p);\n  }else\n#endif /* SQLITE_OMIT_EXPLAIN */\n  {\n    db->vdbeExecCnt++;\n    rc = sqlite3VdbeExec(p);\n    db->vdbeExecCnt--;\n  }\n\n#ifndef SQLITE_OMIT_TRACE\n  /* Invoke the profile callback if there is one\n  */\n  if( rc!=SQLITE_ROW && db->xProfile && !db->init.busy && p->zSql ){\n    sqlite3_int64 iNow;\n    sqlite3OsCurrentTimeInt64(db->pVfs, &iNow);\n    db->xProfile(db->pProfileArg, p->zSql, (iNow - p->startTime)*1000000);\n  }\n#endif\n\n  if( rc==SQLITE_DONE ){\n    assert( p->rc==SQLITE_OK );\n    p->rc = doWalCallbacks(db);\n    if( p->rc!=SQLITE_OK ){\n      rc = SQLITE_ERROR;\n    }\n  }\n\n  db->errCode = rc;\n  if( SQLITE_NOMEM==sqlite3ApiExit(p->db, p->rc) ){\n    p->rc = SQLITE_NOMEM;\n  }\nend_of_step:\n  /* At this point local variable rc holds the value that should be \n  ** returned if this statement was compiled using the legacy \n  ** sqlite3_prepare() interface. According to the docs, this can only\n  ** be one of the values in the first assert() below. Variable p->rc \n  ** contains the value that would be returned if sqlite3_finalize() \n  ** were called on statement p.\n  */\n  assert( rc==SQLITE_ROW  || rc==SQLITE_DONE   || rc==SQLITE_ERROR \n       || rc==SQLITE_BUSY || rc==SQLITE_MISUSE\n  );\n  assert( p->rc!=SQLITE_ROW && p->rc!=SQLITE_DONE );\n  if( p->isPrepareV2 && rc!=SQLITE_ROW && rc!=SQLITE_DONE ){\n    /* If this statement was prepared using sqlite3_prepare_v2(), and an\n    ** error has occured, then return the error code in p->rc to the\n    ** caller. Set the error code in the database handle to the same value.\n    */ \n    rc = db->errCode = p->rc;\n  }\n  return (rc&db->errMask);\n}\n\n/*\n** This is the top-level implementation of sqlite3_step().  Call\n** sqlite3Step() to do most of the work.  If a schema error occurs,\n** call sqlite3Reprepare() and try again.\n*/\nSQLITE_API int sqlite3_step(sqlite3_stmt *pStmt){\n  int rc = SQLITE_OK;      /* Result from sqlite3Step() */\n  int rc2 = SQLITE_OK;     /* Result from sqlite3Reprepare() */\n  Vdbe *v = (Vdbe*)pStmt;  /* the prepared statement */\n  int cnt = 0;             /* Counter to prevent infinite loop of reprepares */\n  sqlite3 *db;             /* The database connection */\n\n  if( vdbeSafetyNotNull(v) ){\n    return SQLITE_MISUSE_BKPT;\n  }\n  db = v->db;\n  sqlite3_mutex_enter(db->mutex);\n  while( (rc = sqlite3Step(v))==SQLITE_SCHEMA\n         && cnt++ < 5\n         && (rc2 = rc = sqlite3Reprepare(v))==SQLITE_OK ){\n    sqlite3_reset(pStmt);\n    v->expired = 0;\n  }\n  if( rc2!=SQLITE_OK && ALWAYS(v->isPrepareV2) && ALWAYS(db->pErr) ){\n    /* This case occurs after failing to recompile an sql statement. \n    ** The error message from the SQL compiler has already been loaded \n    ** into the database handle. This block copies the error message \n    ** from the database handle into the statement and sets the statement\n    ** program counter to 0 to ensure that when the statement is \n    ** finalized or reset the parser error message is available via\n    ** sqlite3_errmsg() and sqlite3_errcode().\n    */\n    const char *zErr = (const char *)sqlite3_value_text(db->pErr); \n    sqlite3DbFree(db, v->zErrMsg);\n    if( !db->mallocFailed ){\n      v->zErrMsg = sqlite3DbStrDup(db, zErr);\n      v->rc = rc2;\n    } else {\n      v->zErrMsg = 0;\n      v->rc = rc = SQLITE_NOMEM;\n    }\n  }\n  rc = sqlite3ApiExit(db, rc);\n  sqlite3_mutex_leave(db->mutex);\n  return rc;\n}\n\n/*\n** Extract the user data from a sqlite3_context structure and return a\n** pointer to it.\n*/\nSQLITE_API void *sqlite3_user_data(sqlite3_context *p){\n  assert( p && p->pFunc );\n  return p->pFunc->pUserData;\n}\n\n/*\n** Extract the user data from a sqlite3_context structure and return a\n** pointer to it.\n**\n** IMPLEMENTATION-OF: R-46798-50301 The sqlite3_context_db_handle() interface\n** returns a copy of the pointer to the database connection (the 1st\n** parameter) of the sqlite3_create_function() and\n** sqlite3_create_function16() routines that originally registered the\n** application defined function.\n*/\nSQLITE_API sqlite3 *sqlite3_context_db_handle(sqlite3_context *p){\n  assert( p && p->pFunc );\n  return p->s.db;\n}\n\n/*\n** The following is the implementation of an SQL function that always\n** fails with an error message stating that the function is used in the\n** wrong context.  The sqlite3_overload_function() API might construct\n** SQL function that use this routine so that the functions will exist\n** for name resolution but are actually overloaded by the xFindFunction\n** method of virtual tables.\n*/\nSQLITE_PRIVATE void sqlite3InvalidFunction(\n  sqlite3_context *context,  /* The function calling context */\n  int NotUsed,               /* Number of arguments to the function */\n  sqlite3_value **NotUsed2   /* Value of each argument */\n){\n  const char *zName = context->pFunc->zName;\n  char *zErr;\n  UNUSED_PARAMETER2(NotUsed, NotUsed2);\n  zErr = sqlite3_mprintf(\n      \"unable to use function %s in the requested context\", zName);\n  sqlite3_result_error(context, zErr, -1);\n  sqlite3_free(zErr);\n}\n\n/*\n** Allocate or return the aggregate context for a user function.  A new\n** context is allocated on the first call.  Subsequent calls return the\n** same context that was returned on prior calls.\n*/\nSQLITE_API void *sqlite3_aggregate_context(sqlite3_context *p, int nByte){\n  Mem *pMem;\n  assert( p && p->pFunc && p->pFunc->xStep );\n  assert( sqlite3_mutex_held(p->s.db->mutex) );\n  pMem = p->pMem;\n  testcase( nByte<0 );\n  if( (pMem->flags & MEM_Agg)==0 ){\n    if( nByte<=0 ){\n      sqlite3VdbeMemReleaseExternal(pMem);\n      pMem->flags = MEM_Null;\n      pMem->z = 0;\n    }else{\n      sqlite3VdbeMemGrow(pMem, nByte, 0);\n      pMem->flags = MEM_Agg;\n      pMem->u.pDef = p->pFunc;\n      if( pMem->z ){\n        memset(pMem->z, 0, nByte);\n      }\n    }\n  }\n  return (void*)pMem->z;\n}\n\n/*\n** Return the auxilary data pointer, if any, for the iArg'th argument to\n** the user-function defined by pCtx.\n*/\nSQLITE_API void *sqlite3_get_auxdata(sqlite3_context *pCtx, int iArg){\n  VdbeFunc *pVdbeFunc;\n\n  assert( sqlite3_mutex_held(pCtx->s.db->mutex) );\n  pVdbeFunc = pCtx->pVdbeFunc;\n  if( !pVdbeFunc || iArg>=pVdbeFunc->nAux || iArg<0 ){\n    return 0;\n  }\n  return pVdbeFunc->apAux[iArg].pAux;\n}\n\n/*\n** Set the auxilary data pointer and delete function, for the iArg'th\n** argument to the user-function defined by pCtx. Any previous value is\n** deleted by calling the delete function specified when it was set.\n*/\nSQLITE_API void sqlite3_set_auxdata(\n  sqlite3_context *pCtx, \n  int iArg, \n  void *pAux, \n  void (*xDelete)(void*)\n){\n  struct AuxData *pAuxData;\n  VdbeFunc *pVdbeFunc;\n  if( iArg<0 ) goto failed;\n\n  assert( sqlite3_mutex_held(pCtx->s.db->mutex) );\n  pVdbeFunc = pCtx->pVdbeFunc;\n  if( !pVdbeFunc || pVdbeFunc->nAux<=iArg ){\n    int nAux = (pVdbeFunc ? pVdbeFunc->nAux : 0);\n    int nMalloc = sizeof(VdbeFunc) + sizeof(struct AuxData)*iArg;\n    pVdbeFunc = sqlite3DbRealloc(pCtx->s.db, pVdbeFunc, nMalloc);\n    if( !pVdbeFunc ){\n      goto failed;\n    }\n    pCtx->pVdbeFunc = pVdbeFunc;\n    memset(&pVdbeFunc->apAux[nAux], 0, sizeof(struct AuxData)*(iArg+1-nAux));\n    pVdbeFunc->nAux = iArg+1;\n    pVdbeFunc->pFunc = pCtx->pFunc;\n  }\n\n  pAuxData = &pVdbeFunc->apAux[iArg];\n  if( pAuxData->pAux && pAuxData->xDelete ){\n    pAuxData->xDelete(pAuxData->pAux);\n  }\n  pAuxData->pAux = pAux;\n  pAuxData->xDelete = xDelete;\n  return;\n\nfailed:\n  if( xDelete ){\n    xDelete(pAux);\n  }\n}\n\n#ifndef SQLITE_OMIT_DEPRECATED\n/*\n** Return the number of times the Step function of a aggregate has been \n** called.\n**\n** This function is deprecated.  Do not use it for new code.  It is\n** provide only to avoid breaking legacy code.  New aggregate function\n** implementations should keep their own counts within their aggregate\n** context.\n*/\nSQLITE_API int sqlite3_aggregate_count(sqlite3_context *p){\n  assert( p && p->pMem && p->pFunc && p->pFunc->xStep );\n  return p->pMem->n;\n}\n#endif\n\n/*\n** Return the number of columns in the result set for the statement pStmt.\n*/\nSQLITE_API int sqlite3_column_count(sqlite3_stmt *pStmt){\n  Vdbe *pVm = (Vdbe *)pStmt;\n  return pVm ? pVm->nResColumn : 0;\n}\n\n/*\n** Return the number of values available from the current row of the\n** currently executing statement pStmt.\n*/\nSQLITE_API int sqlite3_data_count(sqlite3_stmt *pStmt){\n  Vdbe *pVm = (Vdbe *)pStmt;\n  if( pVm==0 || pVm->pResultSet==0 ) return 0;\n  return pVm->nResColumn;\n}\n\n\n/*\n** Check to see if column iCol of the given statement is valid.  If\n** it is, return a pointer to the Mem for the value of that column.\n** If iCol is not valid, return a pointer to a Mem which has a value\n** of NULL.\n*/\nstatic Mem *columnMem(sqlite3_stmt *pStmt, int i){\n  Vdbe *pVm;\n  Mem *pOut;\n\n  pVm = (Vdbe *)pStmt;\n  if( pVm && pVm->pResultSet!=0 && i<pVm->nResColumn && i>=0 ){\n    sqlite3_mutex_enter(pVm->db->mutex);\n    pOut = &pVm->pResultSet[i];\n  }else{\n    /* If the value passed as the second argument is out of range, return\n    ** a pointer to the following static Mem object which contains the\n    ** value SQL NULL. Even though the Mem structure contains an element\n    ** of type i64, on certain architecture (x86) with certain compiler\n    ** switches (-Os), gcc may align this Mem object on a 4-byte boundary\n    ** instead of an 8-byte one. This all works fine, except that when\n    ** running with SQLITE_DEBUG defined the SQLite code sometimes assert()s\n    ** that a Mem structure is located on an 8-byte boundary. To prevent\n    ** this assert() from failing, when building with SQLITE_DEBUG defined\n    ** using gcc, force nullMem to be 8-byte aligned using the magical\n    ** __attribute__((aligned(8))) macro.  */\n    static const Mem nullMem \n#if defined(SQLITE_DEBUG) && defined(__GNUC__)\n      __attribute__((aligned(8))) \n#endif\n      = {0, \"\", (double)0, {0}, 0, MEM_Null, SQLITE_NULL, 0, 0, 0 };\n\n    if( pVm && ALWAYS(pVm->db) ){\n      sqlite3_mutex_enter(pVm->db->mutex);\n      sqlite3Error(pVm->db, SQLITE_RANGE, 0);\n    }\n    pOut = (Mem*)&nullMem;\n  }\n  return pOut;\n}\n\n/*\n** This function is called after invoking an sqlite3_value_XXX function on a \n** column value (i.e. a value returned by evaluating an SQL expression in the\n** select list of a SELECT statement) that may cause a malloc() failure. If \n** malloc() has failed, the threads mallocFailed flag is cleared and the result\n** code of statement pStmt set to SQLITE_NOMEM.\n**\n** Specifically, this is called from within:\n**\n**     sqlite3_column_int()\n**     sqlite3_column_int64()\n**     sqlite3_column_text()\n**     sqlite3_column_text16()\n**     sqlite3_column_real()\n**     sqlite3_column_bytes()\n**     sqlite3_column_bytes16()\n**     sqiite3_column_blob()\n*/\nstatic void columnMallocFailure(sqlite3_stmt *pStmt)\n{\n  /* If malloc() failed during an encoding conversion within an\n  ** sqlite3_column_XXX API, then set the return code of the statement to\n  ** SQLITE_NOMEM. The next call to _step() (if any) will return SQLITE_ERROR\n  ** and _finalize() will return NOMEM.\n  */\n  Vdbe *p = (Vdbe *)pStmt;\n  if( p ){\n    p->rc = sqlite3ApiExit(p->db, p->rc);\n    sqlite3_mutex_leave(p->db->mutex);\n  }\n}\n\n/**************************** sqlite3_column_  *******************************\n** The following routines are used to access elements of the current row\n** in the result set.\n*/\nSQLITE_API const void *sqlite3_column_blob(sqlite3_stmt *pStmt, int i){\n  const void *val;\n  val = sqlite3_value_blob( columnMem(pStmt,i) );\n  /* Even though there is no encoding conversion, value_blob() might\n  ** need to call malloc() to expand the result of a zeroblob() \n  ** expression. \n  */\n  columnMallocFailure(pStmt);\n  return val;\n}\nSQLITE_API int sqlite3_column_bytes(sqlite3_stmt *pStmt, int i){\n  int val = sqlite3_value_bytes( columnMem(pStmt,i) );\n  columnMallocFailure(pStmt);\n  return val;\n}\nSQLITE_API int sqlite3_column_bytes16(sqlite3_stmt *pStmt, int i){\n  int val = sqlite3_value_bytes16( columnMem(pStmt,i) );\n  columnMallocFailure(pStmt);\n  return val;\n}\nSQLITE_API double sqlite3_column_double(sqlite3_stmt *pStmt, int i){\n  double val = sqlite3_value_double( columnMem(pStmt,i) );\n  columnMallocFailure(pStmt);\n  return val;\n}\nSQLITE_API int sqlite3_column_int(sqlite3_stmt *pStmt, int i){\n  int val = sqlite3_value_int( columnMem(pStmt,i) );\n  columnMallocFailure(pStmt);\n  return val;\n}\nSQLITE_API sqlite_int64 sqlite3_column_int64(sqlite3_stmt *pStmt, int i){\n  sqlite_int64 val = sqlite3_value_int64( columnMem(pStmt,i) );\n  columnMallocFailure(pStmt);\n  return val;\n}\nSQLITE_API const unsigned char *sqlite3_column_text(sqlite3_stmt *pStmt, int i){\n  const unsigned char *val = sqlite3_value_text( columnMem(pStmt,i) );\n  columnMallocFailure(pStmt);\n  return val;\n}\nSQLITE_API sqlite3_value *sqlite3_column_value(sqlite3_stmt *pStmt, int i){\n  Mem *pOut = columnMem(pStmt, i);\n  if( pOut->flags&MEM_Static ){\n    pOut->flags &= ~MEM_Static;\n    pOut->flags |= MEM_Ephem;\n  }\n  columnMallocFailure(pStmt);\n  return (sqlite3_value *)pOut;\n}\n#ifndef SQLITE_OMIT_UTF16\nSQLITE_API const void *sqlite3_column_text16(sqlite3_stmt *pStmt, int i){\n  const void *val = sqlite3_value_text16( columnMem(pStmt,i) );\n  columnMallocFailure(pStmt);\n  return val;\n}\n#endif /* SQLITE_OMIT_UTF16 */\nSQLITE_API int sqlite3_column_type(sqlite3_stmt *pStmt, int i){\n  int iType = sqlite3_value_type( columnMem(pStmt,i) );\n  columnMallocFailure(pStmt);\n  return iType;\n}\n\n/* The following function is experimental and subject to change or\n** removal */\n/*int sqlite3_column_numeric_type(sqlite3_stmt *pStmt, int i){\n**  return sqlite3_value_numeric_type( columnMem(pStmt,i) );\n**}\n*/\n\n/*\n** Convert the N-th element of pStmt->pColName[] into a string using\n** xFunc() then return that string.  If N is out of range, return 0.\n**\n** There are up to 5 names for each column.  useType determines which\n** name is returned.  Here are the names:\n**\n**    0      The column name as it should be displayed for output\n**    1      The datatype name for the column\n**    2      The name of the database that the column derives from\n**    3      The name of the table that the column derives from\n**    4      The name of the table column that the result column derives from\n**\n** If the result is not a simple column reference (if it is an expression\n** or a constant) then useTypes 2, 3, and 4 return NULL.\n*/\nstatic const void *columnName(\n  sqlite3_stmt *pStmt,\n  int N,\n  const void *(*xFunc)(Mem*),\n  int useType\n){\n  const void *ret = 0;\n  Vdbe *p = (Vdbe *)pStmt;\n  int n;\n  sqlite3 *db = p->db;\n  \n  assert( db!=0 );\n  n = sqlite3_column_count(pStmt);\n  if( N<n && N>=0 ){\n    N += useType*n;\n    sqlite3_mutex_enter(db->mutex);\n    assert( db->mallocFailed==0 );\n    ret = xFunc(&p->aColName[N]);\n     /* A malloc may have failed inside of the xFunc() call. If this\n    ** is the case, clear the mallocFailed flag and return NULL.\n    */\n    if( db->mallocFailed ){\n      db->mallocFailed = 0;\n      ret = 0;\n    }\n    sqlite3_mutex_leave(db->mutex);\n  }\n  return ret;\n}\n\n/*\n** Return the name of the Nth column of the result set returned by SQL\n** statement pStmt.\n*/\nSQLITE_API const char *sqlite3_column_name(sqlite3_stmt *pStmt, int N){\n  return columnName(\n      pStmt, N, (const void*(*)(Mem*))sqlite3_value_text, COLNAME_NAME);\n}\n#ifndef SQLITE_OMIT_UTF16\nSQLITE_API const void *sqlite3_column_name16(sqlite3_stmt *pStmt, int N){\n  return columnName(\n      pStmt, N, (const void*(*)(Mem*))sqlite3_value_text16, COLNAME_NAME);\n}\n#endif\n\n/*\n** Constraint:  If you have ENABLE_COLUMN_METADATA then you must\n** not define OMIT_DECLTYPE.\n*/\n#if defined(SQLITE_OMIT_DECLTYPE) && defined(SQLITE_ENABLE_COLUMN_METADATA)\n# error \"Must not define both SQLITE_OMIT_DECLTYPE \\\n         and SQLITE_ENABLE_COLUMN_METADATA\"\n#endif\n\n#ifndef SQLITE_OMIT_DECLTYPE\n/*\n** Return the column declaration type (if applicable) of the 'i'th column\n** of the result set of SQL statement pStmt.\n*/\nSQLITE_API const char *sqlite3_column_decltype(sqlite3_stmt *pStmt, int N){\n  return columnName(\n      pStmt, N, (const void*(*)(Mem*))sqlite3_value_text, COLNAME_DECLTYPE);\n}\n#ifndef SQLITE_OMIT_UTF16\nSQLITE_API const void *sqlite3_column_decltype16(sqlite3_stmt *pStmt, int N){\n  return columnName(\n      pStmt, N, (const void*(*)(Mem*))sqlite3_value_text16, COLNAME_DECLTYPE);\n}\n#endif /* SQLITE_OMIT_UTF16 */\n#endif /* SQLITE_OMIT_DECLTYPE */\n\n#ifdef SQLITE_ENABLE_COLUMN_METADATA\n/*\n** Return the name of the database from which a result column derives.\n** NULL is returned if the result column is an expression or constant or\n** anything else which is not an unabiguous reference to a database column.\n*/\nSQLITE_API const char *sqlite3_column_database_name(sqlite3_stmt *pStmt, int N){\n  return columnName(\n      pStmt, N, (const void*(*)(Mem*))sqlite3_value_text, COLNAME_DATABASE);\n}\n#ifndef SQLITE_OMIT_UTF16\nSQLITE_API const void *sqlite3_column_database_name16(sqlite3_stmt *pStmt, int N){\n  return columnName(\n      pStmt, N, (const void*(*)(Mem*))sqlite3_value_text16, COLNAME_DATABASE);\n}\n#endif /* SQLITE_OMIT_UTF16 */\n\n/*\n** Return the name of the table from which a result column derives.\n** NULL is returned if the result column is an expression or constant or\n** anything else which is not an unabiguous reference to a database column.\n*/\nSQLITE_API const char *sqlite3_column_table_name(sqlite3_stmt *pStmt, int N){\n  return columnName(\n      pStmt, N, (const void*(*)(Mem*))sqlite3_value_text, COLNAME_TABLE);\n}\n#ifndef SQLITE_OMIT_UTF16\nSQLITE_API const void *sqlite3_column_table_name16(sqlite3_stmt *pStmt, int N){\n  return columnName(\n      pStmt, N, (const void*(*)(Mem*))sqlite3_value_text16, COLNAME_TABLE);\n}\n#endif /* SQLITE_OMIT_UTF16 */\n\n/*\n** Return the name of the table column from which a result column derives.\n** NULL is returned if the result column is an expression or constant or\n** anything else which is not an unabiguous reference to a database column.\n*/\nSQLITE_API const char *sqlite3_column_origin_name(sqlite3_stmt *pStmt, int N){\n  return columnName(\n      pStmt, N, (const void*(*)(Mem*))sqlite3_value_text, COLNAME_COLUMN);\n}\n#ifndef SQLITE_OMIT_UTF16\nSQLITE_API const void *sqlite3_column_origin_name16(sqlite3_stmt *pStmt, int N){\n  return columnName(\n      pStmt, N, (const void*(*)(Mem*))sqlite3_value_text16, COLNAME_COLUMN);\n}\n#endif /* SQLITE_OMIT_UTF16 */\n#endif /* SQLITE_ENABLE_COLUMN_METADATA */\n\n\n/******************************* sqlite3_bind_  ***************************\n** \n** Routines used to attach values to wildcards in a compiled SQL statement.\n*/\n/*\n** Unbind the value bound to variable i in virtual machine p. This is the \n** the same as binding a NULL value to the column. If the \"i\" parameter is\n** out of range, then SQLITE_RANGE is returned. Othewise SQLITE_OK.\n**\n** A successful evaluation of this routine acquires the mutex on p.\n** the mutex is released if any kind of error occurs.\n**\n** The error code stored in database p->db is overwritten with the return\n** value in any case.\n*/\nstatic int vdbeUnbind(Vdbe *p, int i){\n  Mem *pVar;\n  if( vdbeSafetyNotNull(p) ){\n    return SQLITE_MISUSE_BKPT;\n  }\n  sqlite3_mutex_enter(p->db->mutex);\n  if( p->magic!=VDBE_MAGIC_RUN || p->pc>=0 ){\n    sqlite3Error(p->db, SQLITE_MISUSE, 0);\n    sqlite3_mutex_leave(p->db->mutex);\n    sqlite3_log(SQLITE_MISUSE, \n        \"bind on a busy prepared statement: [%s]\", p->zSql);\n    return SQLITE_MISUSE_BKPT;\n  }\n  if( i<1 || i>p->nVar ){\n    sqlite3Error(p->db, SQLITE_RANGE, 0);\n    sqlite3_mutex_leave(p->db->mutex);\n    return SQLITE_RANGE;\n  }\n  i--;\n  pVar = &p->aVar[i];\n  sqlite3VdbeMemRelease(pVar);\n  pVar->flags = MEM_Null;\n  sqlite3Error(p->db, SQLITE_OK, 0);\n\n  /* If the bit corresponding to this variable in Vdbe.expmask is set, then \n  ** binding a new value to this variable invalidates the current query plan.\n  **\n  ** IMPLEMENTATION-OF: R-48440-37595 If the specific value bound to host\n  ** parameter in the WHERE clause might influence the choice of query plan\n  ** for a statement, then the statement will be automatically recompiled,\n  ** as if there had been a schema change, on the first sqlite3_step() call\n  ** following any change to the bindings of that parameter.\n  */\n  if( p->isPrepareV2 &&\n     ((i<32 && p->expmask & ((u32)1 << i)) || p->expmask==0xffffffff)\n  ){\n    p->expired = 1;\n  }\n  return SQLITE_OK;\n}\n\n/*\n** Bind a text or BLOB value.\n*/\nstatic int bindText(\n  sqlite3_stmt *pStmt,   /* The statement to bind against */\n  int i,                 /* Index of the parameter to bind */\n  const void *zData,     /* Pointer to the data to be bound */\n  int nData,             /* Number of bytes of data to be bound */\n  void (*xDel)(void*),   /* Destructor for the data */\n  u8 encoding            /* Encoding for the data */\n){\n  Vdbe *p = (Vdbe *)pStmt;\n  Mem *pVar;\n  int rc;\n\n  rc = vdbeUnbind(p, i);\n  if( rc==SQLITE_OK ){\n    if( zData!=0 ){\n      pVar = &p->aVar[i-1];\n      rc = sqlite3VdbeMemSetStr(pVar, zData, nData, encoding, xDel);\n      if( rc==SQLITE_OK && encoding!=0 ){\n        rc = sqlite3VdbeChangeEncoding(pVar, ENC(p->db));\n      }\n      sqlite3Error(p->db, rc, 0);\n      rc = sqlite3ApiExit(p->db, rc);\n    }\n    sqlite3_mutex_leave(p->db->mutex);\n  }else if( xDel!=SQLITE_STATIC && xDel!=SQLITE_TRANSIENT ){\n    xDel((void*)zData);\n  }\n  return rc;\n}\n\n\n/*\n** Bind a blob value to an SQL statement variable.\n*/\nSQLITE_API int sqlite3_bind_blob(\n  sqlite3_stmt *pStmt, \n  int i, \n  const void *zData, \n  int nData, \n  void (*xDel)(void*)\n){\n  return bindText(pStmt, i, zData, nData, xDel, 0);\n}\nSQLITE_API int sqlite3_bind_double(sqlite3_stmt *pStmt, int i, double rValue){\n  int rc;\n  Vdbe *p = (Vdbe *)pStmt;\n  rc = vdbeUnbind(p, i);\n  if( rc==SQLITE_OK ){\n    sqlite3VdbeMemSetDouble(&p->aVar[i-1], rValue);\n    sqlite3_mutex_leave(p->db->mutex);\n  }\n  return rc;\n}\nSQLITE_API int sqlite3_bind_int(sqlite3_stmt *p, int i, int iValue){\n  return sqlite3_bind_int64(p, i, (i64)iValue);\n}\nSQLITE_API int sqlite3_bind_int64(sqlite3_stmt *pStmt, int i, sqlite_int64 iValue){\n  int rc;\n  Vdbe *p = (Vdbe *)pStmt;\n  rc = vdbeUnbind(p, i);\n  if( rc==SQLITE_OK ){\n    sqlite3VdbeMemSetInt64(&p->aVar[i-1], iValue);\n    sqlite3_mutex_leave(p->db->mutex);\n  }\n  return rc;\n}\nSQLITE_API int sqlite3_bind_null(sqlite3_stmt *pStmt, int i){\n  int rc;\n  Vdbe *p = (Vdbe*)pStmt;\n  rc = vdbeUnbind(p, i);\n  if( rc==SQLITE_OK ){\n    sqlite3_mutex_leave(p->db->mutex);\n  }\n  return rc;\n}\nSQLITE_API int sqlite3_bind_text( \n  sqlite3_stmt *pStmt, \n  int i, \n  const char *zData, \n  int nData, \n  void (*xDel)(void*)\n){\n  return bindText(pStmt, i, zData, nData, xDel, SQLITE_UTF8);\n}\n#ifndef SQLITE_OMIT_UTF16\nSQLITE_API int sqlite3_bind_text16(\n  sqlite3_stmt *pStmt, \n  int i, \n  const void *zData, \n  int nData, \n  void (*xDel)(void*)\n){\n  return bindText(pStmt, i, zData, nData, xDel, SQLITE_UTF16NATIVE);\n}\n#endif /* SQLITE_OMIT_UTF16 */\nSQLITE_API int sqlite3_bind_value(sqlite3_stmt *pStmt, int i, const sqlite3_value *pValue){\n  int rc;\n  switch( pValue->type ){\n    case SQLITE_INTEGER: {\n      rc = sqlite3_bind_int64(pStmt, i, pValue->u.i);\n      break;\n    }\n    case SQLITE_FLOAT: {\n      rc = sqlite3_bind_double(pStmt, i, pValue->r);\n      break;\n    }\n    case SQLITE_BLOB: {\n      if( pValue->flags & MEM_Zero ){\n        rc = sqlite3_bind_zeroblob(pStmt, i, pValue->u.nZero);\n      }else{\n        rc = sqlite3_bind_blob(pStmt, i, pValue->z, pValue->n,SQLITE_TRANSIENT);\n      }\n      break;\n    }\n    case SQLITE_TEXT: {\n      rc = bindText(pStmt,i,  pValue->z, pValue->n, SQLITE_TRANSIENT,\n                              pValue->enc);\n      break;\n    }\n    default: {\n      rc = sqlite3_bind_null(pStmt, i);\n      break;\n    }\n  }\n  return rc;\n}\nSQLITE_API int sqlite3_bind_zeroblob(sqlite3_stmt *pStmt, int i, int n){\n  int rc;\n  Vdbe *p = (Vdbe *)pStmt;\n  rc = vdbeUnbind(p, i);\n  if( rc==SQLITE_OK ){\n    sqlite3VdbeMemSetZeroBlob(&p->aVar[i-1], n);\n    sqlite3_mutex_leave(p->db->mutex);\n  }\n  return rc;\n}\n\n/*\n** Return the number of wildcards that can be potentially bound to.\n** This routine is added to support DBD::SQLite.  \n*/\nSQLITE_API int sqlite3_bind_parameter_count(sqlite3_stmt *pStmt){\n  Vdbe *p = (Vdbe*)pStmt;\n  return p ? p->nVar : 0;\n}\n\n/*\n** Create a mapping from variable numbers to variable names\n** in the Vdbe.azVar[] array, if such a mapping does not already\n** exist.\n*/\nstatic void createVarMap(Vdbe *p){\n  if( !p->okVar ){\n    int j;\n    Op *pOp;\n    sqlite3_mutex_enter(p->db->mutex);\n    /* The race condition here is harmless.  If two threads call this\n    ** routine on the same Vdbe at the same time, they both might end\n    ** up initializing the Vdbe.azVar[] array.  That is a little extra\n    ** work but it results in the same answer.\n    */\n    for(j=0, pOp=p->aOp; j<p->nOp; j++, pOp++){\n      if( pOp->opcode==OP_Variable ){\n        assert( pOp->p1>0 && pOp->p1<=p->nVar );\n        p->azVar[pOp->p1-1] = pOp->p4.z;\n      }\n    }\n    p->okVar = 1;\n    sqlite3_mutex_leave(p->db->mutex);\n  }\n}\n\n/*\n** Return the name of a wildcard parameter.  Return NULL if the index\n** is out of range or if the wildcard is unnamed.\n**\n** The result is always UTF-8.\n*/\nSQLITE_API const char *sqlite3_bind_parameter_name(sqlite3_stmt *pStmt, int i){\n  Vdbe *p = (Vdbe*)pStmt;\n  if( p==0 || i<1 || i>p->nVar ){\n    return 0;\n  }\n  createVarMap(p);\n  return p->azVar[i-1];\n}\n\n/*\n** Given a wildcard parameter name, return the index of the variable\n** with that name.  If there is no variable with the given name,\n** return 0.\n*/\nSQLITE_PRIVATE int sqlite3VdbeParameterIndex(Vdbe *p, const char *zName, int nName){\n  int i;\n  if( p==0 ){\n    return 0;\n  }\n  createVarMap(p); \n  if( zName ){\n    for(i=0; i<p->nVar; i++){\n      const char *z = p->azVar[i];\n      if( z && memcmp(z,zName,nName)==0 && z[nName]==0 ){\n        return i+1;\n      }\n    }\n  }\n  return 0;\n}\nSQLITE_API int sqlite3_bind_parameter_index(sqlite3_stmt *pStmt, const char *zName){\n  return sqlite3VdbeParameterIndex((Vdbe*)pStmt, zName, sqlite3Strlen30(zName));\n}\n\n/*\n** Transfer all bindings from the first statement over to the second.\n*/\nSQLITE_PRIVATE int sqlite3TransferBindings(sqlite3_stmt *pFromStmt, sqlite3_stmt *pToStmt){\n  Vdbe *pFrom = (Vdbe*)pFromStmt;\n  Vdbe *pTo = (Vdbe*)pToStmt;\n  int i;\n  assert( pTo->db==pFrom->db );\n  assert( pTo->nVar==pFrom->nVar );\n  sqlite3_mutex_enter(pTo->db->mutex);\n  for(i=0; i<pFrom->nVar; i++){\n    sqlite3VdbeMemMove(&pTo->aVar[i], &pFrom->aVar[i]);\n  }\n  sqlite3_mutex_leave(pTo->db->mutex);\n  return SQLITE_OK;\n}\n\n#ifndef SQLITE_OMIT_DEPRECATED\n/*\n** Deprecated external interface.  Internal/core SQLite code\n** should call sqlite3TransferBindings.\n**\n** Is is misuse to call this routine with statements from different\n** database connections.  But as this is a deprecated interface, we\n** will not bother to check for that condition.\n**\n** If the two statements contain a different number of bindings, then\n** an SQLITE_ERROR is returned.  Nothing else can go wrong, so otherwise\n** SQLITE_OK is returned.\n*/\nSQLITE_API int sqlite3_transfer_bindings(sqlite3_stmt *pFromStmt, sqlite3_stmt *pToStmt){\n  Vdbe *pFrom = (Vdbe*)pFromStmt;\n  Vdbe *pTo = (Vdbe*)pToStmt;\n  if( pFrom->nVar!=pTo->nVar ){\n    return SQLITE_ERROR;\n  }\n  if( pTo->isPrepareV2 && pTo->expmask ){\n    pTo->expired = 1;\n  }\n  if( pFrom->isPrepareV2 && pFrom->expmask ){\n    pFrom->expired = 1;\n  }\n  return sqlite3TransferBindings(pFromStmt, pToStmt);\n}\n#endif\n\n/*\n** Return the sqlite3* database handle to which the prepared statement given\n** in the argument belongs.  This is the same database handle that was\n** the first argument to the sqlite3_prepare() that was used to create\n** the statement in the first place.\n*/\nSQLITE_API sqlite3 *sqlite3_db_handle(sqlite3_stmt *pStmt){\n  return pStmt ? ((Vdbe*)pStmt)->db : 0;\n}\n\n/*\n** Return true if the prepared statement is guaranteed to not modify the\n** database.\n*/\nSQLITE_API int sqlite3_stmt_readonly(sqlite3_stmt *pStmt){\n  return pStmt ? ((Vdbe*)pStmt)->readOnly : 1;\n}\n\n/*\n** Return a pointer to the next prepared statement after pStmt associated\n** with database connection pDb.  If pStmt is NULL, return the first\n** prepared statement for the database connection.  Return NULL if there\n** are no more.\n*/\nSQLITE_API sqlite3_stmt *sqlite3_next_stmt(sqlite3 *pDb, sqlite3_stmt *pStmt){\n  sqlite3_stmt *pNext;\n  sqlite3_mutex_enter(pDb->mutex);\n  if( pStmt==0 ){\n    pNext = (sqlite3_stmt*)pDb->pVdbe;\n  }else{\n    pNext = (sqlite3_stmt*)((Vdbe*)pStmt)->pNext;\n  }\n  sqlite3_mutex_leave(pDb->mutex);\n  return pNext;\n}\n\n/*\n** Return the value of a status counter for a prepared statement\n*/\nSQLITE_API int sqlite3_stmt_status(sqlite3_stmt *pStmt, int op, int resetFlag){\n  Vdbe *pVdbe = (Vdbe*)pStmt;\n  int v = pVdbe->aCounter[op-1];\n  if( resetFlag ) pVdbe->aCounter[op-1] = 0;\n  return v;\n}\n\n/************** End of vdbeapi.c *********************************************/\n/************** Begin file vdbetrace.c ***************************************/\n/*\n** 2009 November 25\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n**\n** This file contains code used to insert the values of host parameters\n** (aka \"wildcards\") into the SQL text output by sqlite3_trace().\n*/\n\n#ifndef SQLITE_OMIT_TRACE\n\n/*\n** zSql is a zero-terminated string of UTF-8 SQL text.  Return the number of\n** bytes in this text up to but excluding the first character in\n** a host parameter.  If the text contains no host parameters, return\n** the total number of bytes in the text.\n*/\nstatic int findNextHostParameter(const char *zSql, int *pnToken){\n  int tokenType;\n  int nTotal = 0;\n  int n;\n\n  *pnToken = 0;\n  while( zSql[0] ){\n    n = sqlite3GetToken((u8*)zSql, &tokenType);\n    assert( n>0 && tokenType!=TK_ILLEGAL );\n    if( tokenType==TK_VARIABLE ){\n      *pnToken = n;\n      break;\n    }\n    nTotal += n;\n    zSql += n;\n  }\n  return nTotal;\n}\n\n/*\n** This function returns a pointer to a nul-terminated string in memory\n** obtained from sqlite3DbMalloc(). If sqlite3.vdbeExecCnt is 1, then the\n** string contains a copy of zRawSql but with host parameters expanded to \n** their current bindings. Or, if sqlite3.vdbeExecCnt is greater than 1, \n** then the returned string holds a copy of zRawSql with \"-- \" prepended\n** to each line of text.\n**\n** The calling function is responsible for making sure the memory returned\n** is eventually freed.\n**\n** ALGORITHM:  Scan the input string looking for host parameters in any of\n** these forms:  ?, ?N, $A, @A, :A.  Take care to avoid text within\n** string literals, quoted identifier names, and comments.  For text forms,\n** the host parameter index is found by scanning the perpared\n** statement for the corresponding OP_Variable opcode.  Once the host\n** parameter index is known, locate the value in p->aVar[].  Then render\n** the value as a literal in place of the host parameter name.\n*/\nSQLITE_PRIVATE char *sqlite3VdbeExpandSql(\n  Vdbe *p,                 /* The prepared statement being evaluated */\n  const char *zRawSql      /* Raw text of the SQL statement */\n){\n  sqlite3 *db;             /* The database connection */\n  int idx = 0;             /* Index of a host parameter */\n  int nextIndex = 1;       /* Index of next ? host parameter */\n  int n;                   /* Length of a token prefix */\n  int nToken;              /* Length of the parameter token */\n  int i;                   /* Loop counter */\n  Mem *pVar;               /* Value of a host parameter */\n  StrAccum out;            /* Accumulate the output here */\n  char zBase[100];         /* Initial working space */\n\n  db = p->db;\n  sqlite3StrAccumInit(&out, zBase, sizeof(zBase), \n                      db->aLimit[SQLITE_LIMIT_LENGTH]);\n  out.db = db;\n  if( db->vdbeExecCnt>1 ){\n    while( *zRawSql ){\n      const char *zStart = zRawSql;\n      while( *(zRawSql++)!='\\n' && *zRawSql );\n      sqlite3StrAccumAppend(&out, \"-- \", 3);\n      sqlite3StrAccumAppend(&out, zStart, zRawSql-zStart);\n    }\n  }else{\n    while( zRawSql[0] ){\n      n = findNextHostParameter(zRawSql, &nToken);\n      assert( n>0 );\n      sqlite3StrAccumAppend(&out, zRawSql, n);\n      zRawSql += n;\n      assert( zRawSql[0] || nToken==0 );\n      if( nToken==0 ) break;\n      if( zRawSql[0]=='?' ){\n        if( nToken>1 ){\n          assert( sqlite3Isdigit(zRawSql[1]) );\n          sqlite3GetInt32(&zRawSql[1], &idx);\n        }else{\n          idx = nextIndex;\n        }\n      }else{\n        assert( zRawSql[0]==':' || zRawSql[0]=='$' || zRawSql[0]=='@' );\n        testcase( zRawSql[0]==':' );\n        testcase( zRawSql[0]=='$' );\n        testcase( zRawSql[0]=='@' );\n        idx = sqlite3VdbeParameterIndex(p, zRawSql, nToken);\n        assert( idx>0 );\n      }\n      zRawSql += nToken;\n      nextIndex = idx + 1;\n      assert( idx>0 && idx<=p->nVar );\n      pVar = &p->aVar[idx-1];\n      if( pVar->flags & MEM_Null ){\n        sqlite3StrAccumAppend(&out, \"NULL\", 4);\n      }else if( pVar->flags & MEM_Int ){\n        sqlite3XPrintf(&out, \"%lld\", pVar->u.i);\n      }else if( pVar->flags & MEM_Real ){\n        sqlite3XPrintf(&out, \"%!.15g\", pVar->r);\n      }else if( pVar->flags & MEM_Str ){\n#ifndef SQLITE_OMIT_UTF16\n        u8 enc = ENC(db);\n        if( enc!=SQLITE_UTF8 ){\n          Mem utf8;\n          memset(&utf8, 0, sizeof(utf8));\n          utf8.db = db;\n          sqlite3VdbeMemSetStr(&utf8, pVar->z, pVar->n, enc, SQLITE_STATIC);\n          sqlite3VdbeChangeEncoding(&utf8, SQLITE_UTF8);\n          sqlite3XPrintf(&out, \"'%.*q'\", utf8.n, utf8.z);\n          sqlite3VdbeMemRelease(&utf8);\n        }else\n#endif\n        {\n          sqlite3XPrintf(&out, \"'%.*q'\", pVar->n, pVar->z);\n        }\n      }else if( pVar->flags & MEM_Zero ){\n        sqlite3XPrintf(&out, \"zeroblob(%d)\", pVar->u.nZero);\n      }else{\n        assert( pVar->flags & MEM_Blob );\n        sqlite3StrAccumAppend(&out, \"x'\", 2);\n        for(i=0; i<pVar->n; i++){\n          sqlite3XPrintf(&out, \"%02x\", pVar->z[i]&0xff);\n        }\n        sqlite3StrAccumAppend(&out, \"'\", 1);\n      }\n    }\n  }\n  return sqlite3StrAccumFinish(&out);\n}\n\n#endif /* #ifndef SQLITE_OMIT_TRACE */\n\n/************** End of vdbetrace.c *******************************************/\n/************** Begin file vdbe.c ********************************************/\n/*\n** 2001 September 15\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** The code in this file implements execution method of the \n** Virtual Database Engine (VDBE).  A separate file (\"vdbeaux.c\")\n** handles housekeeping details such as creating and deleting\n** VDBE instances.  This file is solely interested in executing\n** the VDBE program.\n**\n** In the external interface, an \"sqlite3_stmt*\" is an opaque pointer\n** to a VDBE.\n**\n** The SQL parser generates a program which is then executed by\n** the VDBE to do the work of the SQL statement.  VDBE programs are \n** similar in form to assembly language.  The program consists of\n** a linear sequence of operations.  Each operation has an opcode \n** and 5 operands.  Operands P1, P2, and P3 are integers.  Operand P4 \n** is a null-terminated string.  Operand P5 is an unsigned character.\n** Few opcodes use all 5 operands.\n**\n** Computation results are stored on a set of registers numbered beginning\n** with 1 and going up to Vdbe.nMem.  Each register can store\n** either an integer, a null-terminated string, a floating point\n** number, or the SQL \"NULL\" value.  An implicit conversion from one\n** type to the other occurs as necessary.\n** \n** Most of the code in this file is taken up by the sqlite3VdbeExec()\n** function which does the work of interpreting a VDBE program.\n** But other routines are also provided to help in building up\n** a program instruction by instruction.\n**\n** Various scripts scan this source file in order to generate HTML\n** documentation, headers files, or other derived files.  The formatting\n** of the code in this file is, therefore, important.  See other comments\n** in this file for details.  If in doubt, do not deviate from existing\n** commenting and indentation practices when changing or adding code.\n*/\n\n/*\n** Invoke this macro on memory cells just prior to changing the\n** value of the cell.  This macro verifies that shallow copies are\n** not misused.\n*/\n#ifdef SQLITE_DEBUG\n# define memAboutToChange(P,M) sqlite3VdbeMemPrepareToChange(P,M)\n#else\n# define memAboutToChange(P,M)\n#endif\n\n/*\n** The following global variable is incremented every time a cursor\n** moves, either by the OP_SeekXX, OP_Next, or OP_Prev opcodes.  The test\n** procedures use this information to make sure that indices are\n** working correctly.  This variable has no function other than to\n** help verify the correct operation of the library.\n*/\n#ifdef SQLITE_TEST\nSQLITE_API int sqlite3_search_count = 0;\n#endif\n\n/*\n** When this global variable is positive, it gets decremented once before\n** each instruction in the VDBE.  When reaches zero, the u1.isInterrupted\n** field of the sqlite3 structure is set in order to simulate and interrupt.\n**\n** This facility is used for testing purposes only.  It does not function\n** in an ordinary build.\n*/\n#ifdef SQLITE_TEST\nSQLITE_API int sqlite3_interrupt_count = 0;\n#endif\n\n/*\n** The next global variable is incremented each type the OP_Sort opcode\n** is executed.  The test procedures use this information to make sure that\n** sorting is occurring or not occurring at appropriate times.   This variable\n** has no function other than to help verify the correct operation of the\n** library.\n*/\n#ifdef SQLITE_TEST\nSQLITE_API int sqlite3_sort_count = 0;\n#endif\n\n/*\n** The next global variable records the size of the largest MEM_Blob\n** or MEM_Str that has been used by a VDBE opcode.  The test procedures\n** use this information to make sure that the zero-blob functionality\n** is working correctly.   This variable has no function other than to\n** help verify the correct operation of the library.\n*/\n#ifdef SQLITE_TEST\nSQLITE_API int sqlite3_max_blobsize = 0;\nstatic void updateMaxBlobsize(Mem *p){\n  if( (p->flags & (MEM_Str|MEM_Blob))!=0 && p->n>sqlite3_max_blobsize ){\n    sqlite3_max_blobsize = p->n;\n  }\n}\n#endif\n\n/*\n** The next global variable is incremented each type the OP_Found opcode\n** is executed. This is used to test whether or not the foreign key\n** operation implemented using OP_FkIsZero is working. This variable\n** has no function other than to help verify the correct operation of the\n** library.\n*/\n#ifdef SQLITE_TEST\nSQLITE_API int sqlite3_found_count = 0;\n#endif\n\n/*\n** Test a register to see if it exceeds the current maximum blob size.\n** If it does, record the new maximum blob size.\n*/\n#if defined(SQLITE_TEST) && !defined(SQLITE_OMIT_BUILTIN_TEST)\n# define UPDATE_MAX_BLOBSIZE(P)  updateMaxBlobsize(P)\n#else\n# define UPDATE_MAX_BLOBSIZE(P)\n#endif\n\n/*\n** Convert the given register into a string if it isn't one\n** already. Return non-zero if a malloc() fails.\n*/\n#define Stringify(P, enc) \\\n   if(((P)->flags&(MEM_Str|MEM_Blob))==0 && sqlite3VdbeMemStringify(P,enc)) \\\n     { goto no_mem; }\n\n/*\n** An ephemeral string value (signified by the MEM_Ephem flag) contains\n** a pointer to a dynamically allocated string where some other entity\n** is responsible for deallocating that string.  Because the register\n** does not control the string, it might be deleted without the register\n** knowing it.\n**\n** This routine converts an ephemeral string into a dynamically allocated\n** string that the register itself controls.  In other words, it\n** converts an MEM_Ephem string into an MEM_Dyn string.\n*/\n#define Deephemeralize(P) \\\n   if( ((P)->flags&MEM_Ephem)!=0 \\\n       && sqlite3VdbeMemMakeWriteable(P) ){ goto no_mem;}\n\n/*\n** Call sqlite3VdbeMemExpandBlob() on the supplied value (type Mem*)\n** P if required.\n*/\n#define ExpandBlob(P) (((P)->flags&MEM_Zero)?sqlite3VdbeMemExpandBlob(P):0)\n\n/*\n** Argument pMem points at a register that will be passed to a\n** user-defined function or returned to the user as the result of a query.\n** This routine sets the pMem->type variable used by the sqlite3_value_*() \n** routines.\n*/\nSQLITE_PRIVATE void sqlite3VdbeMemStoreType(Mem *pMem){\n  int flags = pMem->flags;\n  if( flags & MEM_Null ){\n    pMem->type = SQLITE_NULL;\n  }\n  else if( flags & MEM_Int ){\n    pMem->type = SQLITE_INTEGER;\n  }\n  else if( flags & MEM_Real ){\n    pMem->type = SQLITE_FLOAT;\n  }\n  else if( flags & MEM_Str ){\n    pMem->type = SQLITE_TEXT;\n  }else{\n    pMem->type = SQLITE_BLOB;\n  }\n}\n\n/*\n** Allocate VdbeCursor number iCur.  Return a pointer to it.  Return NULL\n** if we run out of memory.\n*/\nstatic VdbeCursor *allocateCursor(\n  Vdbe *p,              /* The virtual machine */\n  int iCur,             /* Index of the new VdbeCursor */\n  int nField,           /* Number of fields in the table or index */\n  int iDb,              /* When database the cursor belongs to, or -1 */\n  int isBtreeCursor     /* True for B-Tree.  False for pseudo-table or vtab */\n){\n  /* Find the memory cell that will be used to store the blob of memory\n  ** required for this VdbeCursor structure. It is convenient to use a \n  ** vdbe memory cell to manage the memory allocation required for a\n  ** VdbeCursor structure for the following reasons:\n  **\n  **   * Sometimes cursor numbers are used for a couple of different\n  **     purposes in a vdbe program. The different uses might require\n  **     different sized allocations. Memory cells provide growable\n  **     allocations.\n  **\n  **   * When using ENABLE_MEMORY_MANAGEMENT, memory cell buffers can\n  **     be freed lazily via the sqlite3_release_memory() API. This\n  **     minimizes the number of malloc calls made by the system.\n  **\n  ** Memory cells for cursors are allocated at the top of the address\n  ** space. Memory cell (p->nMem) corresponds to cursor 0. Space for\n  ** cursor 1 is managed by memory cell (p->nMem-1), etc.\n  */\n  Mem *pMem = &p->aMem[p->nMem-iCur];\n\n  int nByte;\n  VdbeCursor *pCx = 0;\n  nByte = \n      ROUND8(sizeof(VdbeCursor)) + \n      (isBtreeCursor?sqlite3BtreeCursorSize():0) + \n      2*nField*sizeof(u32);\n\n  assert( iCur<p->nCursor );\n  if( p->apCsr[iCur] ){\n    sqlite3VdbeFreeCursor(p, p->apCsr[iCur]);\n    p->apCsr[iCur] = 0;\n  }\n  if( SQLITE_OK==sqlite3VdbeMemGrow(pMem, nByte, 0) ){\n    p->apCsr[iCur] = pCx = (VdbeCursor*)pMem->z;\n    memset(pCx, 0, sizeof(VdbeCursor));\n    pCx->iDb = iDb;\n    pCx->nField = nField;\n    if( nField ){\n      pCx->aType = (u32 *)&pMem->z[ROUND8(sizeof(VdbeCursor))];\n    }\n    if( isBtreeCursor ){\n      pCx->pCursor = (BtCursor*)\n          &pMem->z[ROUND8(sizeof(VdbeCursor))+2*nField*sizeof(u32)];\n      sqlite3BtreeCursorZero(pCx->pCursor);\n    }\n  }\n  return pCx;\n}\n\n/*\n** Try to convert a value into a numeric representation if we can\n** do so without loss of information.  In other words, if the string\n** looks like a number, convert it into a number.  If it does not\n** look like a number, leave it alone.\n*/\nstatic void applyNumericAffinity(Mem *pRec){\n  if( (pRec->flags & (MEM_Real|MEM_Int))==0 ){\n    double rValue;\n    i64 iValue;\n    u8 enc = pRec->enc;\n    if( (pRec->flags&MEM_Str)==0 ) return;\n    if( sqlite3AtoF(pRec->z, &rValue, pRec->n, enc)==0 ) return;\n    if( 0==sqlite3Atoi64(pRec->z, &iValue, pRec->n, enc) ){\n      pRec->u.i = iValue;\n      pRec->flags |= MEM_Int;\n    }else{\n      pRec->r = rValue;\n      pRec->flags |= MEM_Real;\n    }\n  }\n}\n\n/*\n** Processing is determine by the affinity parameter:\n**\n** SQLITE_AFF_INTEGER:\n** SQLITE_AFF_REAL:\n** SQLITE_AFF_NUMERIC:\n**    Try to convert pRec to an integer representation or a \n**    floating-point representation if an integer representation\n**    is not possible.  Note that the integer representation is\n**    always preferred, even if the affinity is REAL, because\n**    an integer representation is more space efficient on disk.\n**\n** SQLITE_AFF_TEXT:\n**    Convert pRec to a text representation.\n**\n** SQLITE_AFF_NONE:\n**    No-op.  pRec is unchanged.\n*/\nstatic void applyAffinity(\n  Mem *pRec,          /* The value to apply affinity to */\n  char affinity,      /* The affinity to be applied */\n  u8 enc              /* Use this text encoding */\n){\n  if( affinity==SQLITE_AFF_TEXT ){\n    /* Only attempt the conversion to TEXT if there is an integer or real\n    ** representation (blob and NULL do not get converted) but no string\n    ** representation.\n    */\n    if( 0==(pRec->flags&MEM_Str) && (pRec->flags&(MEM_Real|MEM_Int)) ){\n      sqlite3VdbeMemStringify(pRec, enc);\n    }\n    pRec->flags &= ~(MEM_Real|MEM_Int);\n  }else if( affinity!=SQLITE_AFF_NONE ){\n    assert( affinity==SQLITE_AFF_INTEGER || affinity==SQLITE_AFF_REAL\n             || affinity==SQLITE_AFF_NUMERIC );\n    applyNumericAffinity(pRec);\n    if( pRec->flags & MEM_Real ){\n      sqlite3VdbeIntegerAffinity(pRec);\n    }\n  }\n}\n\n/*\n** Try to convert the type of a function argument or a result column\n** into a numeric representation.  Use either INTEGER or REAL whichever\n** is appropriate.  But only do the conversion if it is possible without\n** loss of information and return the revised type of the argument.\n*/\nSQLITE_API int sqlite3_value_numeric_type(sqlite3_value *pVal){\n  Mem *pMem = (Mem*)pVal;\n  if( pMem->type==SQLITE_TEXT ){\n    applyNumericAffinity(pMem);\n    sqlite3VdbeMemStoreType(pMem);\n  }\n  return pMem->type;\n}\n\n/*\n** Exported version of applyAffinity(). This one works on sqlite3_value*, \n** not the internal Mem* type.\n*/\nSQLITE_PRIVATE void sqlite3ValueApplyAffinity(\n  sqlite3_value *pVal, \n  u8 affinity, \n  u8 enc\n){\n  applyAffinity((Mem *)pVal, affinity, enc);\n}\n\n#ifdef SQLITE_DEBUG\n/*\n** Write a nice string representation of the contents of cell pMem\n** into buffer zBuf, length nBuf.\n*/\nSQLITE_PRIVATE void sqlite3VdbeMemPrettyPrint(Mem *pMem, char *zBuf){\n  char *zCsr = zBuf;\n  int f = pMem->flags;\n\n  static const char *const encnames[] = {\"(X)\", \"(8)\", \"(16LE)\", \"(16BE)\"};\n\n  if( f&MEM_Blob ){\n    int i;\n    char c;\n    if( f & MEM_Dyn ){\n      c = 'z';\n      assert( (f & (MEM_Static|MEM_Ephem))==0 );\n    }else if( f & MEM_Static ){\n      c = 't';\n      assert( (f & (MEM_Dyn|MEM_Ephem))==0 );\n    }else if( f & MEM_Ephem ){\n      c = 'e';\n      assert( (f & (MEM_Static|MEM_Dyn))==0 );\n    }else{\n      c = 's';\n    }\n\n    sqlite3_snprintf(100, zCsr, \"%c\", c);\n    zCsr += sqlite3Strlen30(zCsr);\n    sqlite3_snprintf(100, zCsr, \"%d[\", pMem->n);\n    zCsr += sqlite3Strlen30(zCsr);\n    for(i=0; i<16 && i<pMem->n; i++){\n      sqlite3_snprintf(100, zCsr, \"%02X\", ((int)pMem->z[i] & 0xFF));\n      zCsr += sqlite3Strlen30(zCsr);\n    }\n    for(i=0; i<16 && i<pMem->n; i++){\n      char z = pMem->z[i];\n      if( z<32 || z>126 ) *zCsr++ = '.';\n      else *zCsr++ = z;\n    }\n\n    sqlite3_snprintf(100, zCsr, \"]%s\", encnames[pMem->enc]);\n    zCsr += sqlite3Strlen30(zCsr);\n    if( f & MEM_Zero ){\n      sqlite3_snprintf(100, zCsr,\"+%dz\",pMem->u.nZero);\n      zCsr += sqlite3Strlen30(zCsr);\n    }\n    *zCsr = '\\0';\n  }else if( f & MEM_Str ){\n    int j, k;\n    zBuf[0] = ' ';\n    if( f & MEM_Dyn ){\n      zBuf[1] = 'z';\n      assert( (f & (MEM_Static|MEM_Ephem))==0 );\n    }else if( f & MEM_Static ){\n      zBuf[1] = 't';\n      assert( (f & (MEM_Dyn|MEM_Ephem))==0 );\n    }else if( f & MEM_Ephem ){\n      zBuf[1] = 'e';\n      assert( (f & (MEM_Static|MEM_Dyn))==0 );\n    }else{\n      zBuf[1] = 's';\n    }\n    k = 2;\n    sqlite3_snprintf(100, &zBuf[k], \"%d\", pMem->n);\n    k += sqlite3Strlen30(&zBuf[k]);\n    zBuf[k++] = '[';\n    for(j=0; j<15 && j<pMem->n; j++){\n      u8 c = pMem->z[j];\n      if( c>=0x20 && c<0x7f ){\n        zBuf[k++] = c;\n      }else{\n        zBuf[k++] = '.';\n      }\n    }\n    zBuf[k++] = ']';\n    sqlite3_snprintf(100,&zBuf[k], encnames[pMem->enc]);\n    k += sqlite3Strlen30(&zBuf[k]);\n    zBuf[k++] = 0;\n  }\n}\n#endif\n\n#ifdef SQLITE_DEBUG\n/*\n** Print the value of a register for tracing purposes:\n*/\nstatic void memTracePrint(FILE *out, Mem *p){\n  if( p->flags & MEM_Null ){\n    fprintf(out, \" NULL\");\n  }else if( (p->flags & (MEM_Int|MEM_Str))==(MEM_Int|MEM_Str) ){\n    fprintf(out, \" si:%lld\", p->u.i);\n  }else if( p->flags & MEM_Int ){\n    fprintf(out, \" i:%lld\", p->u.i);\n#ifndef SQLITE_OMIT_FLOATING_POINT\n  }else if( p->flags & MEM_Real ){\n    fprintf(out, \" r:%g\", p->r);\n#endif\n  }else if( p->flags & MEM_RowSet ){\n    fprintf(out, \" (rowset)\");\n  }else{\n    char zBuf[200];\n    sqlite3VdbeMemPrettyPrint(p, zBuf);\n    fprintf(out, \" \");\n    fprintf(out, \"%s\", zBuf);\n  }\n}\nstatic void registerTrace(FILE *out, int iReg, Mem *p){\n  fprintf(out, \"REG[%d] = \", iReg);\n  memTracePrint(out, p);\n  fprintf(out, \"\\n\");\n}\n#endif\n\n#ifdef SQLITE_DEBUG\n#  define REGISTER_TRACE(R,M) if(p->trace)registerTrace(p->trace,R,M)\n#else\n#  define REGISTER_TRACE(R,M)\n#endif\n\n\n#ifdef VDBE_PROFILE\n\n/* \n** hwtime.h contains inline assembler code for implementing \n** high-performance timing routines.\n*/\n/************** Include hwtime.h in the middle of vdbe.c *********************/\n/************** Begin file hwtime.h ******************************************/\n/*\n** 2008 May 27\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n******************************************************************************\n**\n** This file contains inline asm code for retrieving \"high-performance\"\n** counters for x86 class CPUs.\n*/\n#ifndef _HWTIME_H_\n#define _HWTIME_H_\n\n/*\n** The following routine only works on pentium-class (or newer) processors.\n** It uses the RDTSC opcode to read the cycle count value out of the\n** processor and returns that value.  This can be used for high-res\n** profiling.\n*/\n#if (defined(__GNUC__) || defined(_MSC_VER)) && \\\n      (defined(i386) || defined(__i386__) || defined(_M_IX86))\n\n  #if defined(__GNUC__)\n\n  __inline__ sqlite_uint64 sqlite3Hwtime(void){\n     unsigned int lo, hi;\n     __asm__ __volatile__ (\"rdtsc\" : \"=a\" (lo), \"=d\" (hi));\n     return (sqlite_uint64)hi << 32 | lo;\n  }\n\n  #elif defined(_MSC_VER)\n\n  __declspec(naked) __inline sqlite_uint64 __cdecl sqlite3Hwtime(void){\n     __asm {\n        rdtsc\n        ret       ; return value at EDX:EAX\n     }\n  }\n\n  #endif\n\n#elif (defined(__GNUC__) && defined(__x86_64__))\n\n  __inline__ sqlite_uint64 sqlite3Hwtime(void){\n      unsigned long val;\n      __asm__ __volatile__ (\"rdtsc\" : \"=A\" (val));\n      return val;\n  }\n \n#elif (defined(__GNUC__) && defined(__ppc__))\n\n  __inline__ sqlite_uint64 sqlite3Hwtime(void){\n      unsigned long long retval;\n      unsigned long junk;\n      __asm__ __volatile__ (\"\\n\\\n          1:      mftbu   %1\\n\\\n                  mftb    %L0\\n\\\n                  mftbu   %0\\n\\\n                  cmpw    %0,%1\\n\\\n                  bne     1b\"\n                  : \"=r\" (retval), \"=r\" (junk));\n      return retval;\n  }\n\n#else\n\n  #error Need implementation of sqlite3Hwtime() for your platform.\n\n  /*\n  ** To compile without implementing sqlite3Hwtime() for your platform,\n  ** you can remove the above #error and use the following\n  ** stub function.  You will lose timing support for many\n  ** of the debugging and testing utilities, but it should at\n  ** least compile and run.\n  */\nSQLITE_PRIVATE   sqlite_uint64 sqlite3Hwtime(void){ return ((sqlite_uint64)0); }\n\n#endif\n\n#endif /* !defined(_HWTIME_H_) */\n\n/************** End of hwtime.h **********************************************/\n/************** Continuing where we left off in vdbe.c ***********************/\n\n#endif\n\n/*\n** The CHECK_FOR_INTERRUPT macro defined here looks to see if the\n** sqlite3_interrupt() routine has been called.  If it has been, then\n** processing of the VDBE program is interrupted.\n**\n** This macro added to every instruction that does a jump in order to\n** implement a loop.  This test used to be on every single instruction,\n** but that meant we more testing that we needed.  By only testing the\n** flag on jump instructions, we get a (small) speed improvement.\n*/\n#define CHECK_FOR_INTERRUPT \\\n   if( db->u1.isInterrupted ) goto abort_due_to_interrupt;\n\n\n#ifndef NDEBUG\n/*\n** This function is only called from within an assert() expression. It\n** checks that the sqlite3.nTransaction variable is correctly set to\n** the number of non-transaction savepoints currently in the \n** linked list starting at sqlite3.pSavepoint.\n** \n** Usage:\n**\n**     assert( checkSavepointCount(db) );\n*/\nstatic int checkSavepointCount(sqlite3 *db){\n  int n = 0;\n  Savepoint *p;\n  for(p=db->pSavepoint; p; p=p->pNext) n++;\n  assert( n==(db->nSavepoint + db->isTransactionSavepoint) );\n  return 1;\n}\n#endif\n\n/*\n** Transfer error message text from an sqlite3_vtab.zErrMsg (text stored\n** in memory obtained from sqlite3_malloc) into a Vdbe.zErrMsg (text stored\n** in memory obtained from sqlite3DbMalloc).\n*/\nstatic void importVtabErrMsg(Vdbe *p, sqlite3_vtab *pVtab){\n  sqlite3 *db = p->db;\n  sqlite3DbFree(db, p->zErrMsg);\n  p->zErrMsg = sqlite3DbStrDup(db, pVtab->zErrMsg);\n  sqlite3_free(pVtab->zErrMsg);\n  pVtab->zErrMsg = 0;\n}\n\n\n/*\n** Execute as much of a VDBE program as we can then return.\n**\n** sqlite3VdbeMakeReady() must be called before this routine in order to\n** close the program with a final OP_Halt and to set up the callbacks\n** and the error message pointer.\n**\n** Whenever a row or result data is available, this routine will either\n** invoke the result callback (if there is one) or return with\n** SQLITE_ROW.\n**\n** If an attempt is made to open a locked database, then this routine\n** will either invoke the busy callback (if there is one) or it will\n** return SQLITE_BUSY.\n**\n** If an error occurs, an error message is written to memory obtained\n** from sqlite3_malloc() and p->zErrMsg is made to point to that memory.\n** The error code is stored in p->rc and this routine returns SQLITE_ERROR.\n**\n** If the callback ever returns non-zero, then the program exits\n** immediately.  There will be no error message but the p->rc field is\n** set to SQLITE_ABORT and this routine will return SQLITE_ERROR.\n**\n** A memory allocation error causes p->rc to be set to SQLITE_NOMEM and this\n** routine to return SQLITE_ERROR.\n**\n** Other fatal errors return SQLITE_ERROR.\n**\n** After this routine has finished, sqlite3VdbeFinalize() should be\n** used to clean up the mess that was left behind.\n*/\nSQLITE_PRIVATE int sqlite3VdbeExec(\n  Vdbe *p                    /* The VDBE */\n){\n  int pc=0;                  /* The program counter */\n  Op *aOp = p->aOp;          /* Copy of p->aOp */\n  Op *pOp;                   /* Current operation */\n  int rc = SQLITE_OK;        /* Value to return */\n  sqlite3 *db = p->db;       /* The database */\n  u8 resetSchemaOnFault = 0; /* Reset schema after an error if true */\n  u8 encoding = ENC(db);     /* The database encoding */\n#ifndef SQLITE_OMIT_PROGRESS_CALLBACK\n  int checkProgress;         /* True if progress callbacks are enabled */\n  int nProgressOps = 0;      /* Opcodes executed since progress callback. */\n#endif\n  Mem *aMem = p->aMem;       /* Copy of p->aMem */\n  Mem *pIn1 = 0;             /* 1st input operand */\n  Mem *pIn2 = 0;             /* 2nd input operand */\n  Mem *pIn3 = 0;             /* 3rd input operand */\n  Mem *pOut = 0;             /* Output operand */\n  int iCompare = 0;          /* Result of last OP_Compare operation */\n  int *aPermute = 0;         /* Permutation of columns for OP_Compare */\n#ifdef VDBE_PROFILE\n  u64 start;                 /* CPU clock count at start of opcode */\n  int origPc;                /* Program counter at start of opcode */\n#endif\n  /********************************************************************\n  ** Automatically generated code\n  **\n  ** The following union is automatically generated by the\n  ** vdbe-compress.tcl script.  The purpose of this union is to\n  ** reduce the amount of stack space required by this function.\n  ** See comments in the vdbe-compress.tcl script for details.\n  */\n  union vdbeExecUnion {\n    struct OP_Yield_stack_vars {\n      int pcDest;\n    } aa;\n    struct OP_Variable_stack_vars {\n      Mem *pVar;       /* Value being transferred */\n    } ab;\n    struct OP_Move_stack_vars {\n      char *zMalloc;   /* Holding variable for allocated memory */\n      int n;           /* Number of registers left to copy */\n      int p1;          /* Register to copy from */\n      int p2;          /* Register to copy to */\n    } ac;\n    struct OP_ResultRow_stack_vars {\n      Mem *pMem;\n      int i;\n    } ad;\n    struct OP_Concat_stack_vars {\n      i64 nByte;\n    } ae;\n    struct OP_Remainder_stack_vars {\n      int flags;      /* Combined MEM_* flags from both inputs */\n      i64 iA;         /* Integer value of left operand */\n      i64 iB;         /* Integer value of right operand */\n      double rA;      /* Real value of left operand */\n      double rB;      /* Real value of right operand */\n    } af;\n    struct OP_Function_stack_vars {\n      int i;\n      Mem *pArg;\n      sqlite3_context ctx;\n      sqlite3_value **apVal;\n      int n;\n    } ag;\n    struct OP_ShiftRight_stack_vars {\n      i64 iA;\n      u64 uA;\n      i64 iB;\n      u8 op;\n    } ah;\n    struct OP_Ge_stack_vars {\n      int res;            /* Result of the comparison of pIn1 against pIn3 */\n      char affinity;      /* Affinity to use for comparison */\n      u16 flags1;         /* Copy of initial value of pIn1->flags */\n      u16 flags3;         /* Copy of initial value of pIn3->flags */\n    } ai;\n    struct OP_Compare_stack_vars {\n      int n;\n      int i;\n      int p1;\n      int p2;\n      const KeyInfo *pKeyInfo;\n      int idx;\n      CollSeq *pColl;    /* Collating sequence to use on this term */\n      int bRev;          /* True for DESCENDING sort order */\n    } aj;\n    struct OP_Or_stack_vars {\n      int v1;    /* Left operand:  0==FALSE, 1==TRUE, 2==UNKNOWN or NULL */\n      int v2;    /* Right operand: 0==FALSE, 1==TRUE, 2==UNKNOWN or NULL */\n    } ak;\n    struct OP_IfNot_stack_vars {\n      int c;\n    } al;\n    struct OP_Column_stack_vars {\n      u32 payloadSize;   /* Number of bytes in the record */\n      i64 payloadSize64; /* Number of bytes in the record */\n      int p1;            /* P1 value of the opcode */\n      int p2;            /* column number to retrieve */\n      VdbeCursor *pC;    /* The VDBE cursor */\n      char *zRec;        /* Pointer to complete record-data */\n      BtCursor *pCrsr;   /* The BTree cursor */\n      u32 *aType;        /* aType[i] holds the numeric type of the i-th column */\n      u32 *aOffset;      /* aOffset[i] is offset to start of data for i-th column */\n      int nField;        /* number of fields in the record */\n      int len;           /* The length of the serialized data for the column */\n      int i;             /* Loop counter */\n      char *zData;       /* Part of the record being decoded */\n      Mem *pDest;        /* Where to write the extracted value */\n      Mem sMem;          /* For storing the record being decoded */\n      u8 *zIdx;          /* Index into header */\n      u8 *zEndHdr;       /* Pointer to first byte after the header */\n      u32 offset;        /* Offset into the data */\n      u32 szField;       /* Number of bytes in the content of a field */\n      int szHdr;         /* Size of the header size field at start of record */\n      int avail;         /* Number of bytes of available data */\n      Mem *pReg;         /* PseudoTable input register */\n    } am;\n    struct OP_Affinity_stack_vars {\n      const char *zAffinity;   /* The affinity to be applied */\n      char cAff;               /* A single character of affinity */\n    } an;\n    struct OP_MakeRecord_stack_vars {\n      u8 *zNewRecord;        /* A buffer to hold the data for the new record */\n      Mem *pRec;             /* The new record */\n      u64 nData;             /* Number of bytes of data space */\n      int nHdr;              /* Number of bytes of header space */\n      i64 nByte;             /* Data space required for this record */\n      int nZero;             /* Number of zero bytes at the end of the record */\n      int nVarint;           /* Number of bytes in a varint */\n      u32 serial_type;       /* Type field */\n      Mem *pData0;           /* First field to be combined into the record */\n      Mem *pLast;            /* Last field of the record */\n      int nField;            /* Number of fields in the record */\n      char *zAffinity;       /* The affinity string for the record */\n      int file_format;       /* File format to use for encoding */\n      int i;                 /* Space used in zNewRecord[] */\n      int len;               /* Length of a field */\n    } ao;\n    struct OP_Count_stack_vars {\n      i64 nEntry;\n      BtCursor *pCrsr;\n    } ap;\n    struct OP_Savepoint_stack_vars {\n      int p1;                         /* Value of P1 operand */\n      char *zName;                    /* Name of savepoint */\n      int nName;\n      Savepoint *pNew;\n      Savepoint *pSavepoint;\n      Savepoint *pTmp;\n      int iSavepoint;\n      int ii;\n    } aq;\n    struct OP_AutoCommit_stack_vars {\n      int desiredAutoCommit;\n      int iRollback;\n      int turnOnAC;\n    } ar;\n    struct OP_Transaction_stack_vars {\n      Btree *pBt;\n    } as;\n    struct OP_ReadCookie_stack_vars {\n      int iMeta;\n      int iDb;\n      int iCookie;\n    } at;\n    struct OP_SetCookie_stack_vars {\n      Db *pDb;\n    } au;\n    struct OP_VerifyCookie_stack_vars {\n      int iMeta;\n      Btree *pBt;\n    } av;\n    struct OP_OpenWrite_stack_vars {\n      int nField;\n      KeyInfo *pKeyInfo;\n      int p2;\n      int iDb;\n      int wrFlag;\n      Btree *pX;\n      VdbeCursor *pCur;\n      Db *pDb;\n    } aw;\n    struct OP_OpenEphemeral_stack_vars {\n      VdbeCursor *pCx;\n    } ax;\n    struct OP_OpenPseudo_stack_vars {\n      VdbeCursor *pCx;\n    } ay;\n    struct OP_SeekGt_stack_vars {\n      int res;\n      int oc;\n      VdbeCursor *pC;\n      UnpackedRecord r;\n      int nField;\n      i64 iKey;      /* The rowid we are to seek to */\n    } az;\n    struct OP_Seek_stack_vars {\n      VdbeCursor *pC;\n    } ba;\n    struct OP_Found_stack_vars {\n      int alreadyExists;\n      VdbeCursor *pC;\n      int res;\n      UnpackedRecord *pIdxKey;\n      UnpackedRecord r;\n      char aTempRec[ROUND8(sizeof(UnpackedRecord)) + sizeof(Mem)*3 + 7];\n    } bb;\n    struct OP_IsUnique_stack_vars {\n      u16 ii;\n      VdbeCursor *pCx;\n      BtCursor *pCrsr;\n      u16 nField;\n      Mem *aMx;\n      UnpackedRecord r;                  /* B-Tree index search key */\n      i64 R;                             /* Rowid stored in register P3 */\n    } bc;\n    struct OP_NotExists_stack_vars {\n      VdbeCursor *pC;\n      BtCursor *pCrsr;\n      int res;\n      u64 iKey;\n    } bd;\n    struct OP_NewRowid_stack_vars {\n      i64 v;                 /* The new rowid */\n      VdbeCursor *pC;        /* Cursor of table to get the new rowid */\n      int res;               /* Result of an sqlite3BtreeLast() */\n      int cnt;               /* Counter to limit the number of searches */\n      Mem *pMem;             /* Register holding largest rowid for AUTOINCREMENT */\n      VdbeFrame *pFrame;     /* Root frame of VDBE */\n    } be;\n    struct OP_InsertInt_stack_vars {\n      Mem *pData;       /* MEM cell holding data for the record to be inserted */\n      Mem *pKey;        /* MEM cell holding key  for the record */\n      i64 iKey;         /* The integer ROWID or key for the record to be inserted */\n      VdbeCursor *pC;   /* Cursor to table into which insert is written */\n      int nZero;        /* Number of zero-bytes to append */\n      int seekResult;   /* Result of prior seek or 0 if no USESEEKRESULT flag */\n      const char *zDb;  /* database name - used by the update hook */\n      const char *zTbl; /* Table name - used by the opdate hook */\n      int op;           /* Opcode for update hook: SQLITE_UPDATE or SQLITE_INSERT */\n    } bf;\n    struct OP_Delete_stack_vars {\n      i64 iKey;\n      VdbeCursor *pC;\n    } bg;\n    struct OP_RowData_stack_vars {\n      VdbeCursor *pC;\n      BtCursor *pCrsr;\n      u32 n;\n      i64 n64;\n    } bh;\n    struct OP_Rowid_stack_vars {\n      VdbeCursor *pC;\n      i64 v;\n      sqlite3_vtab *pVtab;\n      const sqlite3_module *pModule;\n    } bi;\n    struct OP_NullRow_stack_vars {\n      VdbeCursor *pC;\n    } bj;\n    struct OP_Last_stack_vars {\n      VdbeCursor *pC;\n      BtCursor *pCrsr;\n      int res;\n    } bk;\n    struct OP_Rewind_stack_vars {\n      VdbeCursor *pC;\n      BtCursor *pCrsr;\n      int res;\n    } bl;\n    struct OP_Next_stack_vars {\n      VdbeCursor *pC;\n      BtCursor *pCrsr;\n      int res;\n    } bm;\n    struct OP_IdxInsert_stack_vars {\n      VdbeCursor *pC;\n      BtCursor *pCrsr;\n      int nKey;\n      const char *zKey;\n    } bn;\n    struct OP_IdxDelete_stack_vars {\n      VdbeCursor *pC;\n      BtCursor *pCrsr;\n      int res;\n      UnpackedRecord r;\n    } bo;\n    struct OP_IdxRowid_stack_vars {\n      BtCursor *pCrsr;\n      VdbeCursor *pC;\n      i64 rowid;\n    } bp;\n    struct OP_IdxGE_stack_vars {\n      VdbeCursor *pC;\n      int res;\n      UnpackedRecord r;\n    } bq;\n    struct OP_Destroy_stack_vars {\n      int iMoved;\n      int iCnt;\n      Vdbe *pVdbe;\n      int iDb;\n    } br;\n    struct OP_Clear_stack_vars {\n      int nChange;\n    } bs;\n    struct OP_CreateTable_stack_vars {\n      int pgno;\n      int flags;\n      Db *pDb;\n    } bt;\n    struct OP_ParseSchema_stack_vars {\n      int iDb;\n      const char *zMaster;\n      char *zSql;\n      InitData initData;\n    } bu;\n    struct OP_IntegrityCk_stack_vars {\n      int nRoot;      /* Number of tables to check.  (Number of root pages.) */\n      int *aRoot;     /* Array of rootpage numbers for tables to be checked */\n      int j;          /* Loop counter */\n      int nErr;       /* Number of errors reported */\n      char *z;        /* Text of the error report */\n      Mem *pnErr;     /* Register keeping track of errors remaining */\n    } bv;\n    struct OP_RowSetRead_stack_vars {\n      i64 val;\n    } bw;\n    struct OP_RowSetTest_stack_vars {\n      int iSet;\n      int exists;\n    } bx;\n    struct OP_Program_stack_vars {\n      int nMem;               /* Number of memory registers for sub-program */\n      int nByte;              /* Bytes of runtime space required for sub-program */\n      Mem *pRt;               /* Register to allocate runtime space */\n      Mem *pMem;              /* Used to iterate through memory cells */\n      Mem *pEnd;              /* Last memory cell in new array */\n      VdbeFrame *pFrame;      /* New vdbe frame to execute in */\n      SubProgram *pProgram;   /* Sub-program to execute */\n      void *t;                /* Token identifying trigger */\n    } by;\n    struct OP_Param_stack_vars {\n      VdbeFrame *pFrame;\n      Mem *pIn;\n    } bz;\n    struct OP_MemMax_stack_vars {\n      Mem *pIn1;\n      VdbeFrame *pFrame;\n    } ca;\n    struct OP_AggStep_stack_vars {\n      int n;\n      int i;\n      Mem *pMem;\n      Mem *pRec;\n      sqlite3_context ctx;\n      sqlite3_value **apVal;\n    } cb;\n    struct OP_AggFinal_stack_vars {\n      Mem *pMem;\n    } cc;\n    struct OP_Checkpoint_stack_vars {\n      int i;                          /* Loop counter */\n      int aRes[3];                    /* Results */\n      Mem *pMem;                      /* Write results here */\n    } cd;\n    struct OP_JournalMode_stack_vars {\n      Btree *pBt;                     /* Btree to change journal mode of */\n      Pager *pPager;                  /* Pager associated with pBt */\n      int eNew;                       /* New journal mode */\n      int eOld;                       /* The old journal mode */\n      const char *zFilename;          /* Name of database file for pPager */\n    } ce;\n    struct OP_IncrVacuum_stack_vars {\n      Btree *pBt;\n    } cf;\n    struct OP_VBegin_stack_vars {\n      VTable *pVTab;\n    } cg;\n    struct OP_VOpen_stack_vars {\n      VdbeCursor *pCur;\n      sqlite3_vtab_cursor *pVtabCursor;\n      sqlite3_vtab *pVtab;\n      sqlite3_module *pModule;\n    } ch;\n    struct OP_VFilter_stack_vars {\n      int nArg;\n      int iQuery;\n      const sqlite3_module *pModule;\n      Mem *pQuery;\n      Mem *pArgc;\n      sqlite3_vtab_cursor *pVtabCursor;\n      sqlite3_vtab *pVtab;\n      VdbeCursor *pCur;\n      int res;\n      int i;\n      Mem **apArg;\n    } ci;\n    struct OP_VColumn_stack_vars {\n      sqlite3_vtab *pVtab;\n      const sqlite3_module *pModule;\n      Mem *pDest;\n      sqlite3_context sContext;\n    } cj;\n    struct OP_VNext_stack_vars {\n      sqlite3_vtab *pVtab;\n      const sqlite3_module *pModule;\n      int res;\n      VdbeCursor *pCur;\n    } ck;\n    struct OP_VRename_stack_vars {\n      sqlite3_vtab *pVtab;\n      Mem *pName;\n    } cl;\n    struct OP_VUpdate_stack_vars {\n      sqlite3_vtab *pVtab;\n      sqlite3_module *pModule;\n      int nArg;\n      int i;\n      sqlite_int64 rowid;\n      Mem **apArg;\n      Mem *pX;\n    } cm;\n    struct OP_Trace_stack_vars {\n      char *zTrace;\n    } cn;\n  } u;\n  /* End automatically generated code\n  ********************************************************************/\n\n  assert( p->magic==VDBE_MAGIC_RUN );  /* sqlite3_step() verifies this */\n  sqlite3VdbeMutexArrayEnter(p);\n  if( p->rc==SQLITE_NOMEM ){\n    /* This happens if a malloc() inside a call to sqlite3_column_text() or\n    ** sqlite3_column_text16() failed.  */\n    goto no_mem;\n  }\n  assert( p->rc==SQLITE_OK || p->rc==SQLITE_BUSY );\n  p->rc = SQLITE_OK;\n  assert( p->explain==0 );\n  p->pResultSet = 0;\n  db->busyHandler.nBusy = 0;\n  CHECK_FOR_INTERRUPT;\n  sqlite3VdbeIOTraceSql(p);\n#ifndef SQLITE_OMIT_PROGRESS_CALLBACK\n  checkProgress = db->xProgress!=0;\n#endif\n#ifdef SQLITE_DEBUG\n  sqlite3BeginBenignMalloc();\n  if( p->pc==0  && (p->db->flags & SQLITE_VdbeListing)!=0 ){\n    int i;\n    printf(\"VDBE Program Listing:\\n\");\n    sqlite3VdbePrintSql(p);\n    for(i=0; i<p->nOp; i++){\n      sqlite3VdbePrintOp(stdout, i, &aOp[i]);\n    }\n  }\n  sqlite3EndBenignMalloc();\n#endif\n  for(pc=p->pc; rc==SQLITE_OK; pc++){\n    assert( pc>=0 && pc<p->nOp );\n    if( db->mallocFailed ) goto no_mem;\n#ifdef VDBE_PROFILE\n    origPc = pc;\n    start = sqlite3Hwtime();\n#endif\n    pOp = &aOp[pc];\n\n    /* Only allow tracing if SQLITE_DEBUG is defined.\n    */\n#ifdef SQLITE_DEBUG\n    if( p->trace ){\n      if( pc==0 ){\n        printf(\"VDBE Execution Trace:\\n\");\n        sqlite3VdbePrintSql(p);\n      }\n      sqlite3VdbePrintOp(p->trace, pc, pOp);\n    }\n#endif\n      \n\n    /* Check to see if we need to simulate an interrupt.  This only happens\n    ** if we have a special test build.\n    */\n#ifdef SQLITE_TEST\n    if( sqlite3_interrupt_count>0 ){\n      sqlite3_interrupt_count--;\n      if( sqlite3_interrupt_count==0 ){\n        sqlite3_interrupt(db);\n      }\n    }\n#endif\n\n#ifndef SQLITE_OMIT_PROGRESS_CALLBACK\n    /* Call the progress callback if it is configured and the required number\n    ** of VDBE ops have been executed (either since this invocation of\n    ** sqlite3VdbeExec() or since last time the progress callback was called).\n    ** If the progress callback returns non-zero, exit the virtual machine with\n    ** a return code SQLITE_ABORT.\n    */\n    if( checkProgress ){\n      if( db->nProgressOps==nProgressOps ){\n        int prc;\n        prc = db->xProgress(db->pProgressArg);\n        if( prc!=0 ){\n          rc = SQLITE_INTERRUPT;\n          goto vdbe_error_halt;\n        }\n        nProgressOps = 0;\n      }\n      nProgressOps++;\n    }\n#endif\n\n    /* On any opcode with the \"out2-prerelase\" tag, free any\n    ** external allocations out of mem[p2] and set mem[p2] to be\n    ** an undefined integer.  Opcodes will either fill in the integer\n    ** value or convert mem[p2] to a different type.\n    */\n    assert( pOp->opflags==sqlite3OpcodeProperty[pOp->opcode] );\n    if( pOp->opflags & OPFLG_OUT2_PRERELEASE ){\n      assert( pOp->p2>0 );\n      assert( pOp->p2<=p->nMem );\n      pOut = &aMem[pOp->p2];\n      memAboutToChange(p, pOut);\n      sqlite3VdbeMemReleaseExternal(pOut);\n      pOut->flags = MEM_Int;\n    }\n\n    /* Sanity checking on other operands */\n#ifdef SQLITE_DEBUG\n    if( (pOp->opflags & OPFLG_IN1)!=0 ){\n      assert( pOp->p1>0 );\n      assert( pOp->p1<=p->nMem );\n      assert( memIsValid(&aMem[pOp->p1]) );\n      REGISTER_TRACE(pOp->p1, &aMem[pOp->p1]);\n    }\n    if( (pOp->opflags & OPFLG_IN2)!=0 ){\n      assert( pOp->p2>0 );\n      assert( pOp->p2<=p->nMem );\n      assert( memIsValid(&aMem[pOp->p2]) );\n      REGISTER_TRACE(pOp->p2, &aMem[pOp->p2]);\n    }\n    if( (pOp->opflags & OPFLG_IN3)!=0 ){\n      assert( pOp->p3>0 );\n      assert( pOp->p3<=p->nMem );\n      assert( memIsValid(&aMem[pOp->p3]) );\n      REGISTER_TRACE(pOp->p3, &aMem[pOp->p3]);\n    }\n    if( (pOp->opflags & OPFLG_OUT2)!=0 ){\n      assert( pOp->p2>0 );\n      assert( pOp->p2<=p->nMem );\n      memAboutToChange(p, &aMem[pOp->p2]);\n    }\n    if( (pOp->opflags & OPFLG_OUT3)!=0 ){\n      assert( pOp->p3>0 );\n      assert( pOp->p3<=p->nMem );\n      memAboutToChange(p, &aMem[pOp->p3]);\n    }\n#endif\n  \n    switch( pOp->opcode ){\n\n/*****************************************************************************\n** What follows is a massive switch statement where each case implements a\n** separate instruction in the virtual machine.  If we follow the usual\n** indentation conventions, each case should be indented by 6 spaces.  But\n** that is a lot of wasted space on the left margin.  So the code within\n** the switch statement will break with convention and be flush-left. Another\n** big comment (similar to this one) will mark the point in the code where\n** we transition back to normal indentation.\n**\n** The formatting of each case is important.  The makefile for SQLite\n** generates two C files \"opcodes.h\" and \"opcodes.c\" by scanning this\n** file looking for lines that begin with \"case OP_\".  The opcodes.h files\n** will be filled with #defines that give unique integer values to each\n** opcode and the opcodes.c file is filled with an array of strings where\n** each string is the symbolic name for the corresponding opcode.  If the\n** case statement is followed by a comment of the form \"/# same as ... #/\"\n** that comment is used to determine the particular value of the opcode.\n**\n** Other keywords in the comment that follows each case are used to\n** construct the OPFLG_INITIALIZER value that initializes opcodeProperty[].\n** Keywords include: in1, in2, in3, out2_prerelease, out2, out3.  See\n** the mkopcodeh.awk script for additional information.\n**\n** Documentation about VDBE opcodes is generated by scanning this file\n** for lines of that contain \"Opcode:\".  That line and all subsequent\n** comment lines are used in the generation of the opcode.html documentation\n** file.\n**\n** SUMMARY:\n**\n**     Formatting is important to scripts that scan this file.\n**     Do not deviate from the formatting style currently in use.\n**\n*****************************************************************************/\n\n/* Opcode:  Goto * P2 * * *\n**\n** An unconditional jump to address P2.\n** The next instruction executed will be \n** the one at index P2 from the beginning of\n** the program.\n*/\ncase OP_Goto: {             /* jump */\n  CHECK_FOR_INTERRUPT;\n  pc = pOp->p2 - 1;\n  break;\n}\n\n/* Opcode:  Gosub P1 P2 * * *\n**\n** Write the current address onto register P1\n** and then jump to address P2.\n*/\ncase OP_Gosub: {            /* jump, in1 */\n  pIn1 = &aMem[pOp->p1];\n  assert( (pIn1->flags & MEM_Dyn)==0 );\n  memAboutToChange(p, pIn1);\n  pIn1->flags = MEM_Int;\n  pIn1->u.i = pc;\n  REGISTER_TRACE(pOp->p1, pIn1);\n  pc = pOp->p2 - 1;\n  break;\n}\n\n/* Opcode:  Return P1 * * * *\n**\n** Jump to the next instruction after the address in register P1.\n*/\ncase OP_Return: {           /* in1 */\n  pIn1 = &aMem[pOp->p1];\n  assert( pIn1->flags & MEM_Int );\n  pc = (int)pIn1->u.i;\n  break;\n}\n\n/* Opcode:  Yield P1 * * * *\n**\n** Swap the program counter with the value in register P1.\n*/\ncase OP_Yield: {            /* in1 */\n#if 0  /* local variables moved into u.aa */\n  int pcDest;\n#endif /* local variables moved into u.aa */\n  pIn1 = &aMem[pOp->p1];\n  assert( (pIn1->flags & MEM_Dyn)==0 );\n  pIn1->flags = MEM_Int;\n  u.aa.pcDest = (int)pIn1->u.i;\n  pIn1->u.i = pc;\n  REGISTER_TRACE(pOp->p1, pIn1);\n  pc = u.aa.pcDest;\n  break;\n}\n\n/* Opcode:  HaltIfNull  P1 P2 P3 P4 *\n**\n** Check the value in register P3.  If is is NULL then Halt using\n** parameter P1, P2, and P4 as if this were a Halt instruction.  If the\n** value in register P3 is not NULL, then this routine is a no-op.\n*/\ncase OP_HaltIfNull: {      /* in3 */\n  pIn3 = &aMem[pOp->p3];\n  if( (pIn3->flags & MEM_Null)==0 ) break;\n  /* Fall through into OP_Halt */\n}\n\n/* Opcode:  Halt P1 P2 * P4 *\n**\n** Exit immediately.  All open cursors, etc are closed\n** automatically.\n**\n** P1 is the result code returned by sqlite3_exec(), sqlite3_reset(),\n** or sqlite3_finalize().  For a normal halt, this should be SQLITE_OK (0).\n** For errors, it can be some other value.  If P1!=0 then P2 will determine\n** whether or not to rollback the current transaction.  Do not rollback\n** if P2==OE_Fail. Do the rollback if P2==OE_Rollback.  If P2==OE_Abort,\n** then back out all changes that have occurred during this execution of the\n** VDBE, but do not rollback the transaction. \n**\n** If P4 is not null then it is an error message string.\n**\n** There is an implied \"Halt 0 0 0\" instruction inserted at the very end of\n** every program.  So a jump past the last instruction of the program\n** is the same as executing Halt.\n*/\ncase OP_Halt: {\n  if( pOp->p1==SQLITE_OK && p->pFrame ){\n    /* Halt the sub-program. Return control to the parent frame. */\n    VdbeFrame *pFrame = p->pFrame;\n    p->pFrame = pFrame->pParent;\n    p->nFrame--;\n    sqlite3VdbeSetChanges(db, p->nChange);\n    pc = sqlite3VdbeFrameRestore(pFrame);\n    if( pOp->p2==OE_Ignore ){\n      /* Instruction pc is the OP_Program that invoked the sub-program \n      ** currently being halted. If the p2 instruction of this OP_Halt\n      ** instruction is set to OE_Ignore, then the sub-program is throwing\n      ** an IGNORE exception. In this case jump to the address specified\n      ** as the p2 of the calling OP_Program.  */\n      pc = p->aOp[pc].p2-1;\n    }\n    aOp = p->aOp;\n    aMem = p->aMem;\n    break;\n  }\n\n  p->rc = pOp->p1;\n  p->errorAction = (u8)pOp->p2;\n  p->pc = pc;\n  if( pOp->p4.z ){\n    assert( p->rc!=SQLITE_OK );\n    sqlite3SetString(&p->zErrMsg, db, \"%s\", pOp->p4.z);\n    testcase( sqlite3GlobalConfig.xLog!=0 );\n    sqlite3_log(pOp->p1, \"abort at %d in [%s]: %s\", pc, p->zSql, pOp->p4.z);\n  }else if( p->rc ){\n    testcase( sqlite3GlobalConfig.xLog!=0 );\n    sqlite3_log(pOp->p1, \"constraint failed at %d in [%s]\", pc, p->zSql);\n  }\n  rc = sqlite3VdbeHalt(p);\n  assert( rc==SQLITE_BUSY || rc==SQLITE_OK || rc==SQLITE_ERROR );\n  if( rc==SQLITE_BUSY ){\n    p->rc = rc = SQLITE_BUSY;\n  }else{\n    assert( rc==SQLITE_OK || p->rc==SQLITE_CONSTRAINT );\n    assert( rc==SQLITE_OK || db->nDeferredCons>0 );\n    rc = p->rc ? SQLITE_ERROR : SQLITE_DONE;\n  }\n  goto vdbe_return;\n}\n\n/* Opcode: Integer P1 P2 * * *\n**\n** The 32-bit integer value P1 is written into register P2.\n*/\ncase OP_Integer: {         /* out2-prerelease */\n  pOut->u.i = pOp->p1;\n  break;\n}\n\n/* Opcode: Int64 * P2 * P4 *\n**\n** P4 is a pointer to a 64-bit integer value.\n** Write that value into register P2.\n*/\ncase OP_Int64: {           /* out2-prerelease */\n  assert( pOp->p4.pI64!=0 );\n  pOut->u.i = *pOp->p4.pI64;\n  break;\n}\n\n#ifndef SQLITE_OMIT_FLOATING_POINT\n/* Opcode: Real * P2 * P4 *\n**\n** P4 is a pointer to a 64-bit floating point value.\n** Write that value into register P2.\n*/\ncase OP_Real: {            /* same as TK_FLOAT, out2-prerelease */\n  pOut->flags = MEM_Real;\n  assert( !sqlite3IsNaN(*pOp->p4.pReal) );\n  pOut->r = *pOp->p4.pReal;\n  break;\n}\n#endif\n\n/* Opcode: String8 * P2 * P4 *\n**\n** P4 points to a nul terminated UTF-8 string. This opcode is transformed \n** into an OP_String before it is executed for the first time.\n*/\ncase OP_String8: {         /* same as TK_STRING, out2-prerelease */\n  assert( pOp->p4.z!=0 );\n  pOp->opcode = OP_String;\n  pOp->p1 = sqlite3Strlen30(pOp->p4.z);\n\n#ifndef SQLITE_OMIT_UTF16\n  if( encoding!=SQLITE_UTF8 ){\n    rc = sqlite3VdbeMemSetStr(pOut, pOp->p4.z, -1, SQLITE_UTF8, SQLITE_STATIC);\n    if( rc==SQLITE_TOOBIG ) goto too_big;\n    if( SQLITE_OK!=sqlite3VdbeChangeEncoding(pOut, encoding) ) goto no_mem;\n    assert( pOut->zMalloc==pOut->z );\n    assert( pOut->flags & MEM_Dyn );\n    pOut->zMalloc = 0;\n    pOut->flags |= MEM_Static;\n    pOut->flags &= ~MEM_Dyn;\n    if( pOp->p4type==P4_DYNAMIC ){\n      sqlite3DbFree(db, pOp->p4.z);\n    }\n    pOp->p4type = P4_DYNAMIC;\n    pOp->p4.z = pOut->z;\n    pOp->p1 = pOut->n;\n  }\n#endif\n  if( pOp->p1>db->aLimit[SQLITE_LIMIT_LENGTH] ){\n    goto too_big;\n  }\n  /* Fall through to the next case, OP_String */\n}\n  \n/* Opcode: String P1 P2 * P4 *\n**\n** The string value P4 of length P1 (bytes) is stored in register P2.\n*/\ncase OP_String: {          /* out2-prerelease */\n  assert( pOp->p4.z!=0 );\n  pOut->flags = MEM_Str|MEM_Static|MEM_Term;\n  pOut->z = pOp->p4.z;\n  pOut->n = pOp->p1;\n  pOut->enc = encoding;\n  UPDATE_MAX_BLOBSIZE(pOut);\n  break;\n}\n\n/* Opcode: Null * P2 * * *\n**\n** Write a NULL into register P2.\n*/\ncase OP_Null: {           /* out2-prerelease */\n  pOut->flags = MEM_Null;\n  break;\n}\n\n\n/* Opcode: Blob P1 P2 * P4\n**\n** P4 points to a blob of data P1 bytes long.  Store this\n** blob in register P2.\n*/\ncase OP_Blob: {                /* out2-prerelease */\n  assert( pOp->p1 <= SQLITE_MAX_LENGTH );\n  sqlite3VdbeMemSetStr(pOut, pOp->p4.z, pOp->p1, 0, 0);\n  pOut->enc = encoding;\n  UPDATE_MAX_BLOBSIZE(pOut);\n  break;\n}\n\n/* Opcode: Variable P1 P2 * P4 *\n**\n** Transfer the values of bound parameter P1 into register P2\n**\n** If the parameter is named, then its name appears in P4 and P3==1.\n** The P4 value is used by sqlite3_bind_parameter_name().\n*/\ncase OP_Variable: {            /* out2-prerelease */\n#if 0  /* local variables moved into u.ab */\n  Mem *pVar;       /* Value being transferred */\n#endif /* local variables moved into u.ab */\n\n  assert( pOp->p1>0 && pOp->p1<=p->nVar );\n  u.ab.pVar = &p->aVar[pOp->p1 - 1];\n  if( sqlite3VdbeMemTooBig(u.ab.pVar) ){\n    goto too_big;\n  }\n  sqlite3VdbeMemShallowCopy(pOut, u.ab.pVar, MEM_Static);\n  UPDATE_MAX_BLOBSIZE(pOut);\n  break;\n}\n\n/* Opcode: Move P1 P2 P3 * *\n**\n** Move the values in register P1..P1+P3-1 over into\n** registers P2..P2+P3-1.  Registers P1..P1+P1-1 are\n** left holding a NULL.  It is an error for register ranges\n** P1..P1+P3-1 and P2..P2+P3-1 to overlap.\n*/\ncase OP_Move: {\n#if 0  /* local variables moved into u.ac */\n  char *zMalloc;   /* Holding variable for allocated memory */\n  int n;           /* Number of registers left to copy */\n  int p1;          /* Register to copy from */\n  int p2;          /* Register to copy to */\n#endif /* local variables moved into u.ac */\n\n  u.ac.n = pOp->p3;\n  u.ac.p1 = pOp->p1;\n  u.ac.p2 = pOp->p2;\n  assert( u.ac.n>0 && u.ac.p1>0 && u.ac.p2>0 );\n  assert( u.ac.p1+u.ac.n<=u.ac.p2 || u.ac.p2+u.ac.n<=u.ac.p1 );\n\n  pIn1 = &aMem[u.ac.p1];\n  pOut = &aMem[u.ac.p2];\n  while( u.ac.n-- ){\n    assert( pOut<=&aMem[p->nMem] );\n    assert( pIn1<=&aMem[p->nMem] );\n    assert( memIsValid(pIn1) );\n    memAboutToChange(p, pOut);\n    u.ac.zMalloc = pOut->zMalloc;\n    pOut->zMalloc = 0;\n    sqlite3VdbeMemMove(pOut, pIn1);\n    pIn1->zMalloc = u.ac.zMalloc;\n    REGISTER_TRACE(u.ac.p2++, pOut);\n    pIn1++;\n    pOut++;\n  }\n  break;\n}\n\n/* Opcode: Copy P1 P2 * * *\n**\n** Make a copy of register P1 into register P2.\n**\n** This instruction makes a deep copy of the value.  A duplicate\n** is made of any string or blob constant.  See also OP_SCopy.\n*/\ncase OP_Copy: {             /* in1, out2 */\n  pIn1 = &aMem[pOp->p1];\n  pOut = &aMem[pOp->p2];\n  assert( pOut!=pIn1 );\n  sqlite3VdbeMemShallowCopy(pOut, pIn1, MEM_Ephem);\n  Deephemeralize(pOut);\n  REGISTER_TRACE(pOp->p2, pOut);\n  break;\n}\n\n/* Opcode: SCopy P1 P2 * * *\n**\n** Make a shallow copy of register P1 into register P2.\n**\n** This instruction makes a shallow copy of the value.  If the value\n** is a string or blob, then the copy is only a pointer to the\n** original and hence if the original changes so will the copy.\n** Worse, if the original is deallocated, the copy becomes invalid.\n** Thus the program must guarantee that the original will not change\n** during the lifetime of the copy.  Use OP_Copy to make a complete\n** copy.\n*/\ncase OP_SCopy: {            /* in1, out2 */\n  pIn1 = &aMem[pOp->p1];\n  pOut = &aMem[pOp->p2];\n  assert( pOut!=pIn1 );\n  sqlite3VdbeMemShallowCopy(pOut, pIn1, MEM_Ephem);\n#ifdef SQLITE_DEBUG\n  if( pOut->pScopyFrom==0 ) pOut->pScopyFrom = pIn1;\n#endif\n  REGISTER_TRACE(pOp->p2, pOut);\n  break;\n}\n\n/* Opcode: ResultRow P1 P2 * * *\n**\n** The registers P1 through P1+P2-1 contain a single row of\n** results. This opcode causes the sqlite3_step() call to terminate\n** with an SQLITE_ROW return code and it sets up the sqlite3_stmt\n** structure to provide access to the top P1 values as the result\n** row.\n*/\ncase OP_ResultRow: {\n#if 0  /* local variables moved into u.ad */\n  Mem *pMem;\n  int i;\n#endif /* local variables moved into u.ad */\n  assert( p->nResColumn==pOp->p2 );\n  assert( pOp->p1>0 );\n  assert( pOp->p1+pOp->p2<=p->nMem+1 );\n\n  /* If this statement has violated immediate foreign key constraints, do\n  ** not return the number of rows modified. And do not RELEASE the statement\n  ** transaction. It needs to be rolled back.  */\n  if( SQLITE_OK!=(rc = sqlite3VdbeCheckFk(p, 0)) ){\n    assert( db->flags&SQLITE_CountRows );\n    assert( p->usesStmtJournal );\n    break;\n  }\n\n  /* If the SQLITE_CountRows flag is set in sqlite3.flags mask, then\n  ** DML statements invoke this opcode to return the number of rows\n  ** modified to the user. This is the only way that a VM that\n  ** opens a statement transaction may invoke this opcode.\n  **\n  ** In case this is such a statement, close any statement transaction\n  ** opened by this VM before returning control to the user. This is to\n  ** ensure that statement-transactions are always nested, not overlapping.\n  ** If the open statement-transaction is not closed here, then the user\n  ** may step another VM that opens its own statement transaction. This\n  ** may lead to overlapping statement transactions.\n  **\n  ** The statement transaction is never a top-level transaction.  Hence\n  ** the RELEASE call below can never fail.\n  */\n  assert( p->iStatement==0 || db->flags&SQLITE_CountRows );\n  rc = sqlite3VdbeCloseStatement(p, SAVEPOINT_RELEASE);\n  if( NEVER(rc!=SQLITE_OK) ){\n    break;\n  }\n\n  /* Invalidate all ephemeral cursor row caches */\n  p->cacheCtr = (p->cacheCtr + 2)|1;\n\n  /* Make sure the results of the current row are \\000 terminated\n  ** and have an assigned type.  The results are de-ephemeralized as\n  ** as side effect.\n  */\n  u.ad.pMem = p->pResultSet = &aMem[pOp->p1];\n  for(u.ad.i=0; u.ad.i<pOp->p2; u.ad.i++){\n    assert( memIsValid(&u.ad.pMem[u.ad.i]) );\n    Deephemeralize(&u.ad.pMem[u.ad.i]);\n    assert( (u.ad.pMem[u.ad.i].flags & MEM_Ephem)==0\n            || (u.ad.pMem[u.ad.i].flags & (MEM_Str|MEM_Blob))==0 );\n    sqlite3VdbeMemNulTerminate(&u.ad.pMem[u.ad.i]);\n    sqlite3VdbeMemStoreType(&u.ad.pMem[u.ad.i]);\n    REGISTER_TRACE(pOp->p1+u.ad.i, &u.ad.pMem[u.ad.i]);\n  }\n  if( db->mallocFailed ) goto no_mem;\n\n  /* Return SQLITE_ROW\n  */\n  p->pc = pc + 1;\n  rc = SQLITE_ROW;\n  goto vdbe_return;\n}\n\n/* Opcode: Concat P1 P2 P3 * *\n**\n** Add the text in register P1 onto the end of the text in\n** register P2 and store the result in register P3.\n** If either the P1 or P2 text are NULL then store NULL in P3.\n**\n**   P3 = P2 || P1\n**\n** It is illegal for P1 and P3 to be the same register. Sometimes,\n** if P3 is the same register as P2, the implementation is able\n** to avoid a memcpy().\n*/\ncase OP_Concat: {           /* same as TK_CONCAT, in1, in2, out3 */\n#if 0  /* local variables moved into u.ae */\n  i64 nByte;\n#endif /* local variables moved into u.ae */\n\n  pIn1 = &aMem[pOp->p1];\n  pIn2 = &aMem[pOp->p2];\n  pOut = &aMem[pOp->p3];\n  assert( pIn1!=pOut );\n  if( (pIn1->flags | pIn2->flags) & MEM_Null ){\n    sqlite3VdbeMemSetNull(pOut);\n    break;\n  }\n  if( ExpandBlob(pIn1) || ExpandBlob(pIn2) ) goto no_mem;\n  Stringify(pIn1, encoding);\n  Stringify(pIn2, encoding);\n  u.ae.nByte = pIn1->n + pIn2->n;\n  if( u.ae.nByte>db->aLimit[SQLITE_LIMIT_LENGTH] ){\n    goto too_big;\n  }\n  MemSetTypeFlag(pOut, MEM_Str);\n  if( sqlite3VdbeMemGrow(pOut, (int)u.ae.nByte+2, pOut==pIn2) ){\n    goto no_mem;\n  }\n  if( pOut!=pIn2 ){\n    memcpy(pOut->z, pIn2->z, pIn2->n);\n  }\n  memcpy(&pOut->z[pIn2->n], pIn1->z, pIn1->n);\n  pOut->z[u.ae.nByte] = 0;\n  pOut->z[u.ae.nByte+1] = 0;\n  pOut->flags |= MEM_Term;\n  pOut->n = (int)u.ae.nByte;\n  pOut->enc = encoding;\n  UPDATE_MAX_BLOBSIZE(pOut);\n  break;\n}\n\n/* Opcode: Add P1 P2 P3 * *\n**\n** Add the value in register P1 to the value in register P2\n** and store the result in register P3.\n** If either input is NULL, the result is NULL.\n*/\n/* Opcode: Multiply P1 P2 P3 * *\n**\n**\n** Multiply the value in register P1 by the value in register P2\n** and store the result in register P3.\n** If either input is NULL, the result is NULL.\n*/\n/* Opcode: Subtract P1 P2 P3 * *\n**\n** Subtract the value in register P1 from the value in register P2\n** and store the result in register P3.\n** If either input is NULL, the result is NULL.\n*/\n/* Opcode: Divide P1 P2 P3 * *\n**\n** Divide the value in register P1 by the value in register P2\n** and store the result in register P3 (P3=P2/P1). If the value in \n** register P1 is zero, then the result is NULL. If either input is \n** NULL, the result is NULL.\n*/\n/* Opcode: Remainder P1 P2 P3 * *\n**\n** Compute the remainder after integer division of the value in\n** register P1 by the value in register P2 and store the result in P3. \n** If the value in register P2 is zero the result is NULL.\n** If either operand is NULL, the result is NULL.\n*/\ncase OP_Add:                   /* same as TK_PLUS, in1, in2, out3 */\ncase OP_Subtract:              /* same as TK_MINUS, in1, in2, out3 */\ncase OP_Multiply:              /* same as TK_STAR, in1, in2, out3 */\ncase OP_Divide:                /* same as TK_SLASH, in1, in2, out3 */\ncase OP_Remainder: {           /* same as TK_REM, in1, in2, out3 */\n#if 0  /* local variables moved into u.af */\n  int flags;      /* Combined MEM_* flags from both inputs */\n  i64 iA;         /* Integer value of left operand */\n  i64 iB;         /* Integer value of right operand */\n  double rA;      /* Real value of left operand */\n  double rB;      /* Real value of right operand */\n#endif /* local variables moved into u.af */\n\n  pIn1 = &aMem[pOp->p1];\n  applyNumericAffinity(pIn1);\n  pIn2 = &aMem[pOp->p2];\n  applyNumericAffinity(pIn2);\n  pOut = &aMem[pOp->p3];\n  u.af.flags = pIn1->flags | pIn2->flags;\n  if( (u.af.flags & MEM_Null)!=0 ) goto arithmetic_result_is_null;\n  if( (pIn1->flags & pIn2->flags & MEM_Int)==MEM_Int ){\n    u.af.iA = pIn1->u.i;\n    u.af.iB = pIn2->u.i;\n    switch( pOp->opcode ){\n      case OP_Add:       if( sqlite3AddInt64(&u.af.iB,u.af.iA) ) goto fp_math;  break;\n      case OP_Subtract:  if( sqlite3SubInt64(&u.af.iB,u.af.iA) ) goto fp_math;  break;\n      case OP_Multiply:  if( sqlite3MulInt64(&u.af.iB,u.af.iA) ) goto fp_math;  break;\n      case OP_Divide: {\n        if( u.af.iA==0 ) goto arithmetic_result_is_null;\n        if( u.af.iA==-1 && u.af.iB==SMALLEST_INT64 ) goto fp_math;\n        u.af.iB /= u.af.iA;\n        break;\n      }\n      default: {\n        if( u.af.iA==0 ) goto arithmetic_result_is_null;\n        if( u.af.iA==-1 ) u.af.iA = 1;\n        u.af.iB %= u.af.iA;\n        break;\n      }\n    }\n    pOut->u.i = u.af.iB;\n    MemSetTypeFlag(pOut, MEM_Int);\n  }else{\nfp_math:\n    u.af.rA = sqlite3VdbeRealValue(pIn1);\n    u.af.rB = sqlite3VdbeRealValue(pIn2);\n    switch( pOp->opcode ){\n      case OP_Add:         u.af.rB += u.af.rA;       break;\n      case OP_Subtract:    u.af.rB -= u.af.rA;       break;\n      case OP_Multiply:    u.af.rB *= u.af.rA;       break;\n      case OP_Divide: {\n        /* (double)0 In case of SQLITE_OMIT_FLOATING_POINT... */\n        if( u.af.rA==(double)0 ) goto arithmetic_result_is_null;\n        u.af.rB /= u.af.rA;\n        break;\n      }\n      default: {\n        u.af.iA = (i64)u.af.rA;\n        u.af.iB = (i64)u.af.rB;\n        if( u.af.iA==0 ) goto arithmetic_result_is_null;\n        if( u.af.iA==-1 ) u.af.iA = 1;\n        u.af.rB = (double)(u.af.iB % u.af.iA);\n        break;\n      }\n    }\n#ifdef SQLITE_OMIT_FLOATING_POINT\n    pOut->u.i = u.af.rB;\n    MemSetTypeFlag(pOut, MEM_Int);\n#else\n    if( sqlite3IsNaN(u.af.rB) ){\n      goto arithmetic_result_is_null;\n    }\n    pOut->r = u.af.rB;\n    MemSetTypeFlag(pOut, MEM_Real);\n    if( (u.af.flags & MEM_Real)==0 ){\n      sqlite3VdbeIntegerAffinity(pOut);\n    }\n#endif\n  }\n  break;\n\narithmetic_result_is_null:\n  sqlite3VdbeMemSetNull(pOut);\n  break;\n}\n\n/* Opcode: CollSeq * * P4\n**\n** P4 is a pointer to a CollSeq struct. If the next call to a user function\n** or aggregate calls sqlite3GetFuncCollSeq(), this collation sequence will\n** be returned. This is used by the built-in min(), max() and nullif()\n** functions.\n**\n** The interface used by the implementation of the aforementioned functions\n** to retrieve the collation sequence set by this opcode is not available\n** publicly, only to user functions defined in func.c.\n*/\ncase OP_CollSeq: {\n  assert( pOp->p4type==P4_COLLSEQ );\n  break;\n}\n\n/* Opcode: Function P1 P2 P3 P4 P5\n**\n** Invoke a user function (P4 is a pointer to a Function structure that\n** defines the function) with P5 arguments taken from register P2 and\n** successors.  The result of the function is stored in register P3.\n** Register P3 must not be one of the function inputs.\n**\n** P1 is a 32-bit bitmask indicating whether or not each argument to the \n** function was determined to be constant at compile time. If the first\n** argument was constant then bit 0 of P1 is set. This is used to determine\n** whether meta data associated with a user function argument using the\n** sqlite3_set_auxdata() API may be safely retained until the next\n** invocation of this opcode.\n**\n** See also: AggStep and AggFinal\n*/\ncase OP_Function: {\n#if 0  /* local variables moved into u.ag */\n  int i;\n  Mem *pArg;\n  sqlite3_context ctx;\n  sqlite3_value **apVal;\n  int n;\n#endif /* local variables moved into u.ag */\n\n  u.ag.n = pOp->p5;\n  u.ag.apVal = p->apArg;\n  assert( u.ag.apVal || u.ag.n==0 );\n  assert( pOp->p3>0 && pOp->p3<=p->nMem );\n  pOut = &aMem[pOp->p3];\n  memAboutToChange(p, pOut);\n\n  assert( u.ag.n==0 || (pOp->p2>0 && pOp->p2+u.ag.n<=p->nMem+1) );\n  assert( pOp->p3<pOp->p2 || pOp->p3>=pOp->p2+u.ag.n );\n  u.ag.pArg = &aMem[pOp->p2];\n  for(u.ag.i=0; u.ag.i<u.ag.n; u.ag.i++, u.ag.pArg++){\n    assert( memIsValid(u.ag.pArg) );\n    u.ag.apVal[u.ag.i] = u.ag.pArg;\n    Deephemeralize(u.ag.pArg);\n    sqlite3VdbeMemStoreType(u.ag.pArg);\n    REGISTER_TRACE(pOp->p2+u.ag.i, u.ag.pArg);\n  }\n\n  assert( pOp->p4type==P4_FUNCDEF || pOp->p4type==P4_VDBEFUNC );\n  if( pOp->p4type==P4_FUNCDEF ){\n    u.ag.ctx.pFunc = pOp->p4.pFunc;\n    u.ag.ctx.pVdbeFunc = 0;\n  }else{\n    u.ag.ctx.pVdbeFunc = (VdbeFunc*)pOp->p4.pVdbeFunc;\n    u.ag.ctx.pFunc = u.ag.ctx.pVdbeFunc->pFunc;\n  }\n\n  u.ag.ctx.s.flags = MEM_Null;\n  u.ag.ctx.s.db = db;\n  u.ag.ctx.s.xDel = 0;\n  u.ag.ctx.s.zMalloc = 0;\n\n  /* The output cell may already have a buffer allocated. Move\n  ** the pointer to u.ag.ctx.s so in case the user-function can use\n  ** the already allocated buffer instead of allocating a new one.\n  */\n  sqlite3VdbeMemMove(&u.ag.ctx.s, pOut);\n  MemSetTypeFlag(&u.ag.ctx.s, MEM_Null);\n\n  u.ag.ctx.isError = 0;\n  if( u.ag.ctx.pFunc->flags & SQLITE_FUNC_NEEDCOLL ){\n    assert( pOp>aOp );\n    assert( pOp[-1].p4type==P4_COLLSEQ );\n    assert( pOp[-1].opcode==OP_CollSeq );\n    u.ag.ctx.pColl = pOp[-1].p4.pColl;\n  }\n  (*u.ag.ctx.pFunc->xFunc)(&u.ag.ctx, u.ag.n, u.ag.apVal); /* IMP: R-24505-23230 */\n  if( db->mallocFailed ){\n    /* Even though a malloc() has failed, the implementation of the\n    ** user function may have called an sqlite3_result_XXX() function\n    ** to return a value. The following call releases any resources\n    ** associated with such a value.\n    */\n    sqlite3VdbeMemRelease(&u.ag.ctx.s);\n    goto no_mem;\n  }\n\n  /* If any auxiliary data functions have been called by this user function,\n  ** immediately call the destructor for any non-static values.\n  */\n  if( u.ag.ctx.pVdbeFunc ){\n    sqlite3VdbeDeleteAuxData(u.ag.ctx.pVdbeFunc, pOp->p1);\n    pOp->p4.pVdbeFunc = u.ag.ctx.pVdbeFunc;\n    pOp->p4type = P4_VDBEFUNC;\n  }\n\n  /* If the function returned an error, throw an exception */\n  if( u.ag.ctx.isError ){\n    sqlite3SetString(&p->zErrMsg, db, \"%s\", sqlite3_value_text(&u.ag.ctx.s));\n    rc = u.ag.ctx.isError;\n  }\n\n  /* Copy the result of the function into register P3 */\n  sqlite3VdbeChangeEncoding(&u.ag.ctx.s, encoding);\n  sqlite3VdbeMemMove(pOut, &u.ag.ctx.s);\n  if( sqlite3VdbeMemTooBig(pOut) ){\n    goto too_big;\n  }\n  REGISTER_TRACE(pOp->p3, pOut);\n  UPDATE_MAX_BLOBSIZE(pOut);\n  break;\n}\n\n/* Opcode: BitAnd P1 P2 P3 * *\n**\n** Take the bit-wise AND of the values in register P1 and P2 and\n** store the result in register P3.\n** If either input is NULL, the result is NULL.\n*/\n/* Opcode: BitOr P1 P2 P3 * *\n**\n** Take the bit-wise OR of the values in register P1 and P2 and\n** store the result in register P3.\n** If either input is NULL, the result is NULL.\n*/\n/* Opcode: ShiftLeft P1 P2 P3 * *\n**\n** Shift the integer value in register P2 to the left by the\n** number of bits specified by the integer in register P1.\n** Store the result in register P3.\n** If either input is NULL, the result is NULL.\n*/\n/* Opcode: ShiftRight P1 P2 P3 * *\n**\n** Shift the integer value in register P2 to the right by the\n** number of bits specified by the integer in register P1.\n** Store the result in register P3.\n** If either input is NULL, the result is NULL.\n*/\ncase OP_BitAnd:                 /* same as TK_BITAND, in1, in2, out3 */\ncase OP_BitOr:                  /* same as TK_BITOR, in1, in2, out3 */\ncase OP_ShiftLeft:              /* same as TK_LSHIFT, in1, in2, out3 */\ncase OP_ShiftRight: {           /* same as TK_RSHIFT, in1, in2, out3 */\n#if 0  /* local variables moved into u.ah */\n  i64 iA;\n  u64 uA;\n  i64 iB;\n  u8 op;\n#endif /* local variables moved into u.ah */\n\n  pIn1 = &aMem[pOp->p1];\n  pIn2 = &aMem[pOp->p2];\n  pOut = &aMem[pOp->p3];\n  if( (pIn1->flags | pIn2->flags) & MEM_Null ){\n    sqlite3VdbeMemSetNull(pOut);\n    break;\n  }\n  u.ah.iA = sqlite3VdbeIntValue(pIn2);\n  u.ah.iB = sqlite3VdbeIntValue(pIn1);\n  u.ah.op = pOp->opcode;\n  if( u.ah.op==OP_BitAnd ){\n    u.ah.iA &= u.ah.iB;\n  }else if( u.ah.op==OP_BitOr ){\n    u.ah.iA |= u.ah.iB;\n  }else if( u.ah.iB!=0 ){\n    assert( u.ah.op==OP_ShiftRight || u.ah.op==OP_ShiftLeft );\n\n    /* If shifting by a negative amount, shift in the other direction */\n    if( u.ah.iB<0 ){\n      assert( OP_ShiftRight==OP_ShiftLeft+1 );\n      u.ah.op = 2*OP_ShiftLeft + 1 - u.ah.op;\n      u.ah.iB = u.ah.iB>(-64) ? -u.ah.iB : 64;\n    }\n\n    if( u.ah.iB>=64 ){\n      u.ah.iA = (u.ah.iA>=0 || u.ah.op==OP_ShiftLeft) ? 0 : -1;\n    }else{\n      memcpy(&u.ah.uA, &u.ah.iA, sizeof(u.ah.uA));\n      if( u.ah.op==OP_ShiftLeft ){\n        u.ah.uA <<= u.ah.iB;\n      }else{\n        u.ah.uA >>= u.ah.iB;\n        /* Sign-extend on a right shift of a negative number */\n        if( u.ah.iA<0 ) u.ah.uA |= ((((u64)0xffffffff)<<32)|0xffffffff) << (64-u.ah.iB);\n      }\n      memcpy(&u.ah.iA, &u.ah.uA, sizeof(u.ah.iA));\n    }\n  }\n  pOut->u.i = u.ah.iA;\n  MemSetTypeFlag(pOut, MEM_Int);\n  break;\n}\n\n/* Opcode: AddImm  P1 P2 * * *\n** \n** Add the constant P2 to the value in register P1.\n** The result is always an integer.\n**\n** To force any register to be an integer, just add 0.\n*/\ncase OP_AddImm: {            /* in1 */\n  pIn1 = &aMem[pOp->p1];\n  memAboutToChange(p, pIn1);\n  sqlite3VdbeMemIntegerify(pIn1);\n  pIn1->u.i += pOp->p2;\n  break;\n}\n\n/* Opcode: MustBeInt P1 P2 * * *\n** \n** Force the value in register P1 to be an integer.  If the value\n** in P1 is not an integer and cannot be converted into an integer\n** without data loss, then jump immediately to P2, or if P2==0\n** raise an SQLITE_MISMATCH exception.\n*/\ncase OP_MustBeInt: {            /* jump, in1 */\n  pIn1 = &aMem[pOp->p1];\n  applyAffinity(pIn1, SQLITE_AFF_NUMERIC, encoding);\n  if( (pIn1->flags & MEM_Int)==0 ){\n    if( pOp->p2==0 ){\n      rc = SQLITE_MISMATCH;\n      goto abort_due_to_error;\n    }else{\n      pc = pOp->p2 - 1;\n    }\n  }else{\n    MemSetTypeFlag(pIn1, MEM_Int);\n  }\n  break;\n}\n\n#ifndef SQLITE_OMIT_FLOATING_POINT\n/* Opcode: RealAffinity P1 * * * *\n**\n** If register P1 holds an integer convert it to a real value.\n**\n** This opcode is used when extracting information from a column that\n** has REAL affinity.  Such column values may still be stored as\n** integers, for space efficiency, but after extraction we want them\n** to have only a real value.\n*/\ncase OP_RealAffinity: {                  /* in1 */\n  pIn1 = &aMem[pOp->p1];\n  if( pIn1->flags & MEM_Int ){\n    sqlite3VdbeMemRealify(pIn1);\n  }\n  break;\n}\n#endif\n\n#ifndef SQLITE_OMIT_CAST\n/* Opcode: ToText P1 * * * *\n**\n** Force the value in register P1 to be text.\n** If the value is numeric, convert it to a string using the\n** equivalent of printf().  Blob values are unchanged and\n** are afterwards simply interpreted as text.\n**\n** A NULL value is not changed by this routine.  It remains NULL.\n*/\ncase OP_ToText: {                  /* same as TK_TO_TEXT, in1 */\n  pIn1 = &aMem[pOp->p1];\n  memAboutToChange(p, pIn1);\n  if( pIn1->flags & MEM_Null ) break;\n  assert( MEM_Str==(MEM_Blob>>3) );\n  pIn1->flags |= (pIn1->flags&MEM_Blob)>>3;\n  applyAffinity(pIn1, SQLITE_AFF_TEXT, encoding);\n  rc = ExpandBlob(pIn1);\n  assert( pIn1->flags & MEM_Str || db->mallocFailed );\n  pIn1->flags &= ~(MEM_Int|MEM_Real|MEM_Blob|MEM_Zero);\n  UPDATE_MAX_BLOBSIZE(pIn1);\n  break;\n}\n\n/* Opcode: ToBlob P1 * * * *\n**\n** Force the value in register P1 to be a BLOB.\n** If the value is numeric, convert it to a string first.\n** Strings are simply reinterpreted as blobs with no change\n** to the underlying data.\n**\n** A NULL value is not changed by this routine.  It remains NULL.\n*/\ncase OP_ToBlob: {                  /* same as TK_TO_BLOB, in1 */\n  pIn1 = &aMem[pOp->p1];\n  if( pIn1->flags & MEM_Null ) break;\n  if( (pIn1->flags & MEM_Blob)==0 ){\n    applyAffinity(pIn1, SQLITE_AFF_TEXT, encoding);\n    assert( pIn1->flags & MEM_Str || db->mallocFailed );\n    MemSetTypeFlag(pIn1, MEM_Blob);\n  }else{\n    pIn1->flags &= ~(MEM_TypeMask&~MEM_Blob);\n  }\n  UPDATE_MAX_BLOBSIZE(pIn1);\n  break;\n}\n\n/* Opcode: ToNumeric P1 * * * *\n**\n** Force the value in register P1 to be numeric (either an\n** integer or a floating-point number.)\n** If the value is text or blob, try to convert it to an using the\n** equivalent of atoi() or atof() and store 0 if no such conversion \n** is possible.\n**\n** A NULL value is not changed by this routine.  It remains NULL.\n*/\ncase OP_ToNumeric: {                  /* same as TK_TO_NUMERIC, in1 */\n  pIn1 = &aMem[pOp->p1];\n  sqlite3VdbeMemNumerify(pIn1);\n  break;\n}\n#endif /* SQLITE_OMIT_CAST */\n\n/* Opcode: ToInt P1 * * * *\n**\n** Force the value in register P1 to be an integer.  If\n** The value is currently a real number, drop its fractional part.\n** If the value is text or blob, try to convert it to an integer using the\n** equivalent of atoi() and store 0 if no such conversion is possible.\n**\n** A NULL value is not changed by this routine.  It remains NULL.\n*/\ncase OP_ToInt: {                  /* same as TK_TO_INT, in1 */\n  pIn1 = &aMem[pOp->p1];\n  if( (pIn1->flags & MEM_Null)==0 ){\n    sqlite3VdbeMemIntegerify(pIn1);\n  }\n  break;\n}\n\n#if !defined(SQLITE_OMIT_CAST) && !defined(SQLITE_OMIT_FLOATING_POINT)\n/* Opcode: ToReal P1 * * * *\n**\n** Force the value in register P1 to be a floating point number.\n** If The value is currently an integer, convert it.\n** If the value is text or blob, try to convert it to an integer using the\n** equivalent of atoi() and store 0.0 if no such conversion is possible.\n**\n** A NULL value is not changed by this routine.  It remains NULL.\n*/\ncase OP_ToReal: {                  /* same as TK_TO_REAL, in1 */\n  pIn1 = &aMem[pOp->p1];\n  memAboutToChange(p, pIn1);\n  if( (pIn1->flags & MEM_Null)==0 ){\n    sqlite3VdbeMemRealify(pIn1);\n  }\n  break;\n}\n#endif /* !defined(SQLITE_OMIT_CAST) && !defined(SQLITE_OMIT_FLOATING_POINT) */\n\n/* Opcode: Lt P1 P2 P3 P4 P5\n**\n** Compare the values in register P1 and P3.  If reg(P3)<reg(P1) then\n** jump to address P2.  \n**\n** If the SQLITE_JUMPIFNULL bit of P5 is set and either reg(P1) or\n** reg(P3) is NULL then take the jump.  If the SQLITE_JUMPIFNULL \n** bit is clear then fall through if either operand is NULL.\n**\n** The SQLITE_AFF_MASK portion of P5 must be an affinity character -\n** SQLITE_AFF_TEXT, SQLITE_AFF_INTEGER, and so forth. An attempt is made \n** to coerce both inputs according to this affinity before the\n** comparison is made. If the SQLITE_AFF_MASK is 0x00, then numeric\n** affinity is used. Note that the affinity conversions are stored\n** back into the input registers P1 and P3.  So this opcode can cause\n** persistent changes to registers P1 and P3.\n**\n** Once any conversions have taken place, and neither value is NULL, \n** the values are compared. If both values are blobs then memcmp() is\n** used to determine the results of the comparison.  If both values\n** are text, then the appropriate collating function specified in\n** P4 is  used to do the comparison.  If P4 is not specified then\n** memcmp() is used to compare text string.  If both values are\n** numeric, then a numeric comparison is used. If the two values\n** are of different types, then numbers are considered less than\n** strings and strings are considered less than blobs.\n**\n** If the SQLITE_STOREP2 bit of P5 is set, then do not jump.  Instead,\n** store a boolean result (either 0, or 1, or NULL) in register P2.\n*/\n/* Opcode: Ne P1 P2 P3 P4 P5\n**\n** This works just like the Lt opcode except that the jump is taken if\n** the operands in registers P1 and P3 are not equal.  See the Lt opcode for\n** additional information.\n**\n** If SQLITE_NULLEQ is set in P5 then the result of comparison is always either\n** true or false and is never NULL.  If both operands are NULL then the result\n** of comparison is false.  If either operand is NULL then the result is true.\n** If neither operand is NULL the the result is the same as it would be if\n** the SQLITE_NULLEQ flag were omitted from P5.\n*/\n/* Opcode: Eq P1 P2 P3 P4 P5\n**\n** This works just like the Lt opcode except that the jump is taken if\n** the operands in registers P1 and P3 are equal.\n** See the Lt opcode for additional information.\n**\n** If SQLITE_NULLEQ is set in P5 then the result of comparison is always either\n** true or false and is never NULL.  If both operands are NULL then the result\n** of comparison is true.  If either operand is NULL then the result is false.\n** If neither operand is NULL the the result is the same as it would be if\n** the SQLITE_NULLEQ flag were omitted from P5.\n*/\n/* Opcode: Le P1 P2 P3 P4 P5\n**\n** This works just like the Lt opcode except that the jump is taken if\n** the content of register P3 is less than or equal to the content of\n** register P1.  See the Lt opcode for additional information.\n*/\n/* Opcode: Gt P1 P2 P3 P4 P5\n**\n** This works just like the Lt opcode except that the jump is taken if\n** the content of register P3 is greater than the content of\n** register P1.  See the Lt opcode for additional information.\n*/\n/* Opcode: Ge P1 P2 P3 P4 P5\n**\n** This works just like the Lt opcode except that the jump is taken if\n** the content of register P3 is greater than or equal to the content of\n** register P1.  See the Lt opcode for additional information.\n*/\ncase OP_Eq:               /* same as TK_EQ, jump, in1, in3 */\ncase OP_Ne:               /* same as TK_NE, jump, in1, in3 */\ncase OP_Lt:               /* same as TK_LT, jump, in1, in3 */\ncase OP_Le:               /* same as TK_LE, jump, in1, in3 */\ncase OP_Gt:               /* same as TK_GT, jump, in1, in3 */\ncase OP_Ge: {             /* same as TK_GE, jump, in1, in3 */\n#if 0  /* local variables moved into u.ai */\n  int res;            /* Result of the comparison of pIn1 against pIn3 */\n  char affinity;      /* Affinity to use for comparison */\n  u16 flags1;         /* Copy of initial value of pIn1->flags */\n  u16 flags3;         /* Copy of initial value of pIn3->flags */\n#endif /* local variables moved into u.ai */\n\n  pIn1 = &aMem[pOp->p1];\n  pIn3 = &aMem[pOp->p3];\n  u.ai.flags1 = pIn1->flags;\n  u.ai.flags3 = pIn3->flags;\n  if( (pIn1->flags | pIn3->flags)&MEM_Null ){\n    /* One or both operands are NULL */\n    if( pOp->p5 & SQLITE_NULLEQ ){\n      /* If SQLITE_NULLEQ is set (which will only happen if the operator is\n      ** OP_Eq or OP_Ne) then take the jump or not depending on whether\n      ** or not both operands are null.\n      */\n      assert( pOp->opcode==OP_Eq || pOp->opcode==OP_Ne );\n      u.ai.res = (pIn1->flags & pIn3->flags & MEM_Null)==0;\n    }else{\n      /* SQLITE_NULLEQ is clear and at least one operand is NULL,\n      ** then the result is always NULL.\n      ** The jump is taken if the SQLITE_JUMPIFNULL bit is set.\n      */\n      if( pOp->p5 & SQLITE_STOREP2 ){\n        pOut = &aMem[pOp->p2];\n        MemSetTypeFlag(pOut, MEM_Null);\n        REGISTER_TRACE(pOp->p2, pOut);\n      }else if( pOp->p5 & SQLITE_JUMPIFNULL ){\n        pc = pOp->p2-1;\n      }\n      break;\n    }\n  }else{\n    /* Neither operand is NULL.  Do a comparison. */\n    u.ai.affinity = pOp->p5 & SQLITE_AFF_MASK;\n    if( u.ai.affinity ){\n      applyAffinity(pIn1, u.ai.affinity, encoding);\n      applyAffinity(pIn3, u.ai.affinity, encoding);\n      if( db->mallocFailed ) goto no_mem;\n    }\n\n    assert( pOp->p4type==P4_COLLSEQ || pOp->p4.pColl==0 );\n    ExpandBlob(pIn1);\n    ExpandBlob(pIn3);\n    u.ai.res = sqlite3MemCompare(pIn3, pIn1, pOp->p4.pColl);\n  }\n  switch( pOp->opcode ){\n    case OP_Eq:    u.ai.res = u.ai.res==0;     break;\n    case OP_Ne:    u.ai.res = u.ai.res!=0;     break;\n    case OP_Lt:    u.ai.res = u.ai.res<0;      break;\n    case OP_Le:    u.ai.res = u.ai.res<=0;     break;\n    case OP_Gt:    u.ai.res = u.ai.res>0;      break;\n    default:       u.ai.res = u.ai.res>=0;     break;\n  }\n\n  if( pOp->p5 & SQLITE_STOREP2 ){\n    pOut = &aMem[pOp->p2];\n    memAboutToChange(p, pOut);\n    MemSetTypeFlag(pOut, MEM_Int);\n    pOut->u.i = u.ai.res;\n    REGISTER_TRACE(pOp->p2, pOut);\n  }else if( u.ai.res ){\n    pc = pOp->p2-1;\n  }\n\n  /* Undo any changes made by applyAffinity() to the input registers. */\n  pIn1->flags = (pIn1->flags&~MEM_TypeMask) | (u.ai.flags1&MEM_TypeMask);\n  pIn3->flags = (pIn3->flags&~MEM_TypeMask) | (u.ai.flags3&MEM_TypeMask);\n  break;\n}\n\n/* Opcode: Permutation * * * P4 *\n**\n** Set the permutation used by the OP_Compare operator to be the array\n** of integers in P4.\n**\n** The permutation is only valid until the next OP_Permutation, OP_Compare,\n** OP_Halt, or OP_ResultRow.  Typically the OP_Permutation should occur\n** immediately prior to the OP_Compare.\n*/\ncase OP_Permutation: {\n  assert( pOp->p4type==P4_INTARRAY );\n  assert( pOp->p4.ai );\n  aPermute = pOp->p4.ai;\n  break;\n}\n\n/* Opcode: Compare P1 P2 P3 P4 *\n**\n** Compare two vectors of registers in reg(P1)..reg(P1+P3-1) (call this\n** vector \"A\") and in reg(P2)..reg(P2+P3-1) (\"B\").  Save the result of\n** the comparison for use by the next OP_Jump instruct.\n**\n** P4 is a KeyInfo structure that defines collating sequences and sort\n** orders for the comparison.  The permutation applies to registers\n** only.  The KeyInfo elements are used sequentially.\n**\n** The comparison is a sort comparison, so NULLs compare equal,\n** NULLs are less than numbers, numbers are less than strings,\n** and strings are less than blobs.\n*/\ncase OP_Compare: {\n#if 0  /* local variables moved into u.aj */\n  int n;\n  int i;\n  int p1;\n  int p2;\n  const KeyInfo *pKeyInfo;\n  int idx;\n  CollSeq *pColl;    /* Collating sequence to use on this term */\n  int bRev;          /* True for DESCENDING sort order */\n#endif /* local variables moved into u.aj */\n\n  u.aj.n = pOp->p3;\n  u.aj.pKeyInfo = pOp->p4.pKeyInfo;\n  assert( u.aj.n>0 );\n  assert( u.aj.pKeyInfo!=0 );\n  u.aj.p1 = pOp->p1;\n  u.aj.p2 = pOp->p2;\n#if SQLITE_DEBUG\n  if( aPermute ){\n    int k, mx = 0;\n    for(k=0; k<u.aj.n; k++) if( aPermute[k]>mx ) mx = aPermute[k];\n    assert( u.aj.p1>0 && u.aj.p1+mx<=p->nMem+1 );\n    assert( u.aj.p2>0 && u.aj.p2+mx<=p->nMem+1 );\n  }else{\n    assert( u.aj.p1>0 && u.aj.p1+u.aj.n<=p->nMem+1 );\n    assert( u.aj.p2>0 && u.aj.p2+u.aj.n<=p->nMem+1 );\n  }\n#endif /* SQLITE_DEBUG */\n  for(u.aj.i=0; u.aj.i<u.aj.n; u.aj.i++){\n    u.aj.idx = aPermute ? aPermute[u.aj.i] : u.aj.i;\n    assert( memIsValid(&aMem[u.aj.p1+u.aj.idx]) );\n    assert( memIsValid(&aMem[u.aj.p2+u.aj.idx]) );\n    REGISTER_TRACE(u.aj.p1+u.aj.idx, &aMem[u.aj.p1+u.aj.idx]);\n    REGISTER_TRACE(u.aj.p2+u.aj.idx, &aMem[u.aj.p2+u.aj.idx]);\n    assert( u.aj.i<u.aj.pKeyInfo->nField );\n    u.aj.pColl = u.aj.pKeyInfo->aColl[u.aj.i];\n    u.aj.bRev = u.aj.pKeyInfo->aSortOrder[u.aj.i];\n    iCompare = sqlite3MemCompare(&aMem[u.aj.p1+u.aj.idx], &aMem[u.aj.p2+u.aj.idx], u.aj.pColl);\n    if( iCompare ){\n      if( u.aj.bRev ) iCompare = -iCompare;\n      break;\n    }\n  }\n  aPermute = 0;\n  break;\n}\n\n/* Opcode: Jump P1 P2 P3 * *\n**\n** Jump to the instruction at address P1, P2, or P3 depending on whether\n** in the most recent OP_Compare instruction the P1 vector was less than\n** equal to, or greater than the P2 vector, respectively.\n*/\ncase OP_Jump: {             /* jump */\n  if( iCompare<0 ){\n    pc = pOp->p1 - 1;\n  }else if( iCompare==0 ){\n    pc = pOp->p2 - 1;\n  }else{\n    pc = pOp->p3 - 1;\n  }\n  break;\n}\n\n/* Opcode: And P1 P2 P3 * *\n**\n** Take the logical AND of the values in registers P1 and P2 and\n** write the result into register P3.\n**\n** If either P1 or P2 is 0 (false) then the result is 0 even if\n** the other input is NULL.  A NULL and true or two NULLs give\n** a NULL output.\n*/\n/* Opcode: Or P1 P2 P3 * *\n**\n** Take the logical OR of the values in register P1 and P2 and\n** store the answer in register P3.\n**\n** If either P1 or P2 is nonzero (true) then the result is 1 (true)\n** even if the other input is NULL.  A NULL and false or two NULLs\n** give a NULL output.\n*/\ncase OP_And:              /* same as TK_AND, in1, in2, out3 */\ncase OP_Or: {             /* same as TK_OR, in1, in2, out3 */\n#if 0  /* local variables moved into u.ak */\n  int v1;    /* Left operand:  0==FALSE, 1==TRUE, 2==UNKNOWN or NULL */\n  int v2;    /* Right operand: 0==FALSE, 1==TRUE, 2==UNKNOWN or NULL */\n#endif /* local variables moved into u.ak */\n\n  pIn1 = &aMem[pOp->p1];\n  if( pIn1->flags & MEM_Null ){\n    u.ak.v1 = 2;\n  }else{\n    u.ak.v1 = sqlite3VdbeIntValue(pIn1)!=0;\n  }\n  pIn2 = &aMem[pOp->p2];\n  if( pIn2->flags & MEM_Null ){\n    u.ak.v2 = 2;\n  }else{\n    u.ak.v2 = sqlite3VdbeIntValue(pIn2)!=0;\n  }\n  if( pOp->opcode==OP_And ){\n    static const unsigned char and_logic[] = { 0, 0, 0, 0, 1, 2, 0, 2, 2 };\n    u.ak.v1 = and_logic[u.ak.v1*3+u.ak.v2];\n  }else{\n    static const unsigned char or_logic[] = { 0, 1, 2, 1, 1, 1, 2, 1, 2 };\n    u.ak.v1 = or_logic[u.ak.v1*3+u.ak.v2];\n  }\n  pOut = &aMem[pOp->p3];\n  if( u.ak.v1==2 ){\n    MemSetTypeFlag(pOut, MEM_Null);\n  }else{\n    pOut->u.i = u.ak.v1;\n    MemSetTypeFlag(pOut, MEM_Int);\n  }\n  break;\n}\n\n/* Opcode: Not P1 P2 * * *\n**\n** Interpret the value in register P1 as a boolean value.  Store the\n** boolean complement in register P2.  If the value in register P1 is \n** NULL, then a NULL is stored in P2.\n*/\ncase OP_Not: {                /* same as TK_NOT, in1, out2 */\n  pIn1 = &aMem[pOp->p1];\n  pOut = &aMem[pOp->p2];\n  if( pIn1->flags & MEM_Null ){\n    sqlite3VdbeMemSetNull(pOut);\n  }else{\n    sqlite3VdbeMemSetInt64(pOut, !sqlite3VdbeIntValue(pIn1));\n  }\n  break;\n}\n\n/* Opcode: BitNot P1 P2 * * *\n**\n** Interpret the content of register P1 as an integer.  Store the\n** ones-complement of the P1 value into register P2.  If P1 holds\n** a NULL then store a NULL in P2.\n*/\ncase OP_BitNot: {             /* same as TK_BITNOT, in1, out2 */\n  pIn1 = &aMem[pOp->p1];\n  pOut = &aMem[pOp->p2];\n  if( pIn1->flags & MEM_Null ){\n    sqlite3VdbeMemSetNull(pOut);\n  }else{\n    sqlite3VdbeMemSetInt64(pOut, ~sqlite3VdbeIntValue(pIn1));\n  }\n  break;\n}\n\n/* Opcode: If P1 P2 P3 * *\n**\n** Jump to P2 if the value in register P1 is true.  The value is\n** is considered true if it is numeric and non-zero.  If the value\n** in P1 is NULL then take the jump if P3 is true.\n*/\n/* Opcode: IfNot P1 P2 P3 * *\n**\n** Jump to P2 if the value in register P1 is False.  The value is\n** is considered true if it has a numeric value of zero.  If the value\n** in P1 is NULL then take the jump if P3 is true.\n*/\ncase OP_If:                 /* jump, in1 */\ncase OP_IfNot: {            /* jump, in1 */\n#if 0  /* local variables moved into u.al */\n  int c;\n#endif /* local variables moved into u.al */\n  pIn1 = &aMem[pOp->p1];\n  if( pIn1->flags & MEM_Null ){\n    u.al.c = pOp->p3;\n  }else{\n#ifdef SQLITE_OMIT_FLOATING_POINT\n    u.al.c = sqlite3VdbeIntValue(pIn1)!=0;\n#else\n    u.al.c = sqlite3VdbeRealValue(pIn1)!=0.0;\n#endif\n    if( pOp->opcode==OP_IfNot ) u.al.c = !u.al.c;\n  }\n  if( u.al.c ){\n    pc = pOp->p2-1;\n  }\n  break;\n}\n\n/* Opcode: IsNull P1 P2 * * *\n**\n** Jump to P2 if the value in register P1 is NULL.\n*/\ncase OP_IsNull: {            /* same as TK_ISNULL, jump, in1 */\n  pIn1 = &aMem[pOp->p1];\n  if( (pIn1->flags & MEM_Null)!=0 ){\n    pc = pOp->p2 - 1;\n  }\n  break;\n}\n\n/* Opcode: NotNull P1 P2 * * *\n**\n** Jump to P2 if the value in register P1 is not NULL.  \n*/\ncase OP_NotNull: {            /* same as TK_NOTNULL, jump, in1 */\n  pIn1 = &aMem[pOp->p1];\n  if( (pIn1->flags & MEM_Null)==0 ){\n    pc = pOp->p2 - 1;\n  }\n  break;\n}\n\n/* Opcode: Column P1 P2 P3 P4 P5\n**\n** Interpret the data that cursor P1 points to as a structure built using\n** the MakeRecord instruction.  (See the MakeRecord opcode for additional\n** information about the format of the data.)  Extract the P2-th column\n** from this record.  If there are less that (P2+1) \n** values in the record, extract a NULL.\n**\n** The value extracted is stored in register P3.\n**\n** If the column contains fewer than P2 fields, then extract a NULL.  Or,\n** if the P4 argument is a P4_MEM use the value of the P4 argument as\n** the result.\n**\n** If the OPFLAG_CLEARCACHE bit is set on P5 and P1 is a pseudo-table cursor,\n** then the cache of the cursor is reset prior to extracting the column.\n** The first OP_Column against a pseudo-table after the value of the content\n** register has changed should have this bit set.\n*/\ncase OP_Column: {\n#if 0  /* local variables moved into u.am */\n  u32 payloadSize;   /* Number of bytes in the record */\n  i64 payloadSize64; /* Number of bytes in the record */\n  int p1;            /* P1 value of the opcode */\n  int p2;            /* column number to retrieve */\n  VdbeCursor *pC;    /* The VDBE cursor */\n  char *zRec;        /* Pointer to complete record-data */\n  BtCursor *pCrsr;   /* The BTree cursor */\n  u32 *aType;        /* aType[i] holds the numeric type of the i-th column */\n  u32 *aOffset;      /* aOffset[i] is offset to start of data for i-th column */\n  int nField;        /* number of fields in the record */\n  int len;           /* The length of the serialized data for the column */\n  int i;             /* Loop counter */\n  char *zData;       /* Part of the record being decoded */\n  Mem *pDest;        /* Where to write the extracted value */\n  Mem sMem;          /* For storing the record being decoded */\n  u8 *zIdx;          /* Index into header */\n  u8 *zEndHdr;       /* Pointer to first byte after the header */\n  u32 offset;        /* Offset into the data */\n  u32 szField;       /* Number of bytes in the content of a field */\n  int szHdr;         /* Size of the header size field at start of record */\n  int avail;         /* Number of bytes of available data */\n  Mem *pReg;         /* PseudoTable input register */\n#endif /* local variables moved into u.am */\n\n\n  u.am.p1 = pOp->p1;\n  u.am.p2 = pOp->p2;\n  u.am.pC = 0;\n  memset(&u.am.sMem, 0, sizeof(u.am.sMem));\n  assert( u.am.p1<p->nCursor );\n  assert( pOp->p3>0 && pOp->p3<=p->nMem );\n  u.am.pDest = &aMem[pOp->p3];\n  memAboutToChange(p, u.am.pDest);\n  MemSetTypeFlag(u.am.pDest, MEM_Null);\n  u.am.zRec = 0;\n\n  /* This block sets the variable u.am.payloadSize to be the total number of\n  ** bytes in the record.\n  **\n  ** u.am.zRec is set to be the complete text of the record if it is available.\n  ** The complete record text is always available for pseudo-tables\n  ** If the record is stored in a cursor, the complete record text\n  ** might be available in the  u.am.pC->aRow cache.  Or it might not be.\n  ** If the data is unavailable,  u.am.zRec is set to NULL.\n  **\n  ** We also compute the number of columns in the record.  For cursors,\n  ** the number of columns is stored in the VdbeCursor.nField element.\n  */\n  u.am.pC = p->apCsr[u.am.p1];\n  assert( u.am.pC!=0 );\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  assert( u.am.pC->pVtabCursor==0 );\n#endif\n  u.am.pCrsr = u.am.pC->pCursor;\n  if( u.am.pCrsr!=0 ){\n    /* The record is stored in a B-Tree */\n    rc = sqlite3VdbeCursorMoveto(u.am.pC);\n    if( rc ) goto abort_due_to_error;\n    if( u.am.pC->nullRow ){\n      u.am.payloadSize = 0;\n    }else if( u.am.pC->cacheStatus==p->cacheCtr ){\n      u.am.payloadSize = u.am.pC->payloadSize;\n      u.am.zRec = (char*)u.am.pC->aRow;\n    }else if( u.am.pC->isIndex ){\n      assert( sqlite3BtreeCursorIsValid(u.am.pCrsr) );\n      rc = sqlite3BtreeKeySize(u.am.pCrsr, &u.am.payloadSize64);\n      assert( rc==SQLITE_OK );   /* True because of CursorMoveto() call above */\n      /* sqlite3BtreeParseCellPtr() uses getVarint32() to extract the\n      ** payload size, so it is impossible for u.am.payloadSize64 to be\n      ** larger than 32 bits. */\n      assert( (u.am.payloadSize64 & SQLITE_MAX_U32)==(u64)u.am.payloadSize64 );\n      u.am.payloadSize = (u32)u.am.payloadSize64;\n    }else{\n      assert( sqlite3BtreeCursorIsValid(u.am.pCrsr) );\n      rc = sqlite3BtreeDataSize(u.am.pCrsr, &u.am.payloadSize);\n      assert( rc==SQLITE_OK );   /* DataSize() cannot fail */\n    }\n  }else if( u.am.pC->pseudoTableReg>0 ){\n    u.am.pReg = &aMem[u.am.pC->pseudoTableReg];\n    assert( u.am.pReg->flags & MEM_Blob );\n    assert( memIsValid(u.am.pReg) );\n    u.am.payloadSize = u.am.pReg->n;\n    u.am.zRec = u.am.pReg->z;\n    u.am.pC->cacheStatus = (pOp->p5&OPFLAG_CLEARCACHE) ? CACHE_STALE : p->cacheCtr;\n    assert( u.am.payloadSize==0 || u.am.zRec!=0 );\n  }else{\n    /* Consider the row to be NULL */\n    u.am.payloadSize = 0;\n  }\n\n  /* If u.am.payloadSize is 0, then just store a NULL */\n  if( u.am.payloadSize==0 ){\n    assert( u.am.pDest->flags&MEM_Null );\n    goto op_column_out;\n  }\n  assert( db->aLimit[SQLITE_LIMIT_LENGTH]>=0 );\n  if( u.am.payloadSize > (u32)db->aLimit[SQLITE_LIMIT_LENGTH] ){\n    goto too_big;\n  }\n\n  u.am.nField = u.am.pC->nField;\n  assert( u.am.p2<u.am.nField );\n\n  /* Read and parse the table header.  Store the results of the parse\n  ** into the record header cache fields of the cursor.\n  */\n  u.am.aType = u.am.pC->aType;\n  if( u.am.pC->cacheStatus==p->cacheCtr ){\n    u.am.aOffset = u.am.pC->aOffset;\n  }else{\n    assert(u.am.aType);\n    u.am.avail = 0;\n    u.am.pC->aOffset = u.am.aOffset = &u.am.aType[u.am.nField];\n    u.am.pC->payloadSize = u.am.payloadSize;\n    u.am.pC->cacheStatus = p->cacheCtr;\n\n    /* Figure out how many bytes are in the header */\n    if( u.am.zRec ){\n      u.am.zData = u.am.zRec;\n    }else{\n      if( u.am.pC->isIndex ){\n        u.am.zData = (char*)sqlite3BtreeKeyFetch(u.am.pCrsr, &u.am.avail);\n      }else{\n        u.am.zData = (char*)sqlite3BtreeDataFetch(u.am.pCrsr, &u.am.avail);\n      }\n      /* If KeyFetch()/DataFetch() managed to get the entire payload,\n      ** save the payload in the u.am.pC->aRow cache.  That will save us from\n      ** having to make additional calls to fetch the content portion of\n      ** the record.\n      */\n      assert( u.am.avail>=0 );\n      if( u.am.payloadSize <= (u32)u.am.avail ){\n        u.am.zRec = u.am.zData;\n        u.am.pC->aRow = (u8*)u.am.zData;\n      }else{\n        u.am.pC->aRow = 0;\n      }\n    }\n    /* The following assert is true in all cases accept when\n    ** the database file has been corrupted externally.\n    **    assert( u.am.zRec!=0 || u.am.avail>=u.am.payloadSize || u.am.avail>=9 ); */\n    u.am.szHdr = getVarint32((u8*)u.am.zData, u.am.offset);\n\n    /* Make sure a corrupt database has not given us an oversize header.\n    ** Do this now to avoid an oversize memory allocation.\n    **\n    ** Type entries can be between 1 and 5 bytes each.  But 4 and 5 byte\n    ** types use so much data space that there can only be 4096 and 32 of\n    ** them, respectively.  So the maximum header length results from a\n    ** 3-byte type for each of the maximum of 32768 columns plus three\n    ** extra bytes for the header length itself.  32768*3 + 3 = 98307.\n    */\n    if( u.am.offset > 98307 ){\n      rc = SQLITE_CORRUPT_BKPT;\n      goto op_column_out;\n    }\n\n    /* Compute in u.am.len the number of bytes of data we need to read in order\n    ** to get u.am.nField type values.  u.am.offset is an upper bound on this.  But\n    ** u.am.nField might be significantly less than the true number of columns\n    ** in the table, and in that case, 5*u.am.nField+3 might be smaller than u.am.offset.\n    ** We want to minimize u.am.len in order to limit the size of the memory\n    ** allocation, especially if a corrupt database file has caused u.am.offset\n    ** to be oversized. Offset is limited to 98307 above.  But 98307 might\n    ** still exceed Robson memory allocation limits on some configurations.\n    ** On systems that cannot tolerate large memory allocations, u.am.nField*5+3\n    ** will likely be much smaller since u.am.nField will likely be less than\n    ** 20 or so.  This insures that Robson memory allocation limits are\n    ** not exceeded even for corrupt database files.\n    */\n    u.am.len = u.am.nField*5 + 3;\n    if( u.am.len > (int)u.am.offset ) u.am.len = (int)u.am.offset;\n\n    /* The KeyFetch() or DataFetch() above are fast and will get the entire\n    ** record header in most cases.  But they will fail to get the complete\n    ** record header if the record header does not fit on a single page\n    ** in the B-Tree.  When that happens, use sqlite3VdbeMemFromBtree() to\n    ** acquire the complete header text.\n    */\n    if( !u.am.zRec && u.am.avail<u.am.len ){\n      u.am.sMem.flags = 0;\n      u.am.sMem.db = 0;\n      rc = sqlite3VdbeMemFromBtree(u.am.pCrsr, 0, u.am.len, u.am.pC->isIndex, &u.am.sMem);\n      if( rc!=SQLITE_OK ){\n        goto op_column_out;\n      }\n      u.am.zData = u.am.sMem.z;\n    }\n    u.am.zEndHdr = (u8 *)&u.am.zData[u.am.len];\n    u.am.zIdx = (u8 *)&u.am.zData[u.am.szHdr];\n\n    /* Scan the header and use it to fill in the u.am.aType[] and u.am.aOffset[]\n    ** arrays.  u.am.aType[u.am.i] will contain the type integer for the u.am.i-th\n    ** column and u.am.aOffset[u.am.i] will contain the u.am.offset from the beginning\n    ** of the record to the start of the data for the u.am.i-th column\n    */\n    for(u.am.i=0; u.am.i<u.am.nField; u.am.i++){\n      if( u.am.zIdx<u.am.zEndHdr ){\n        u.am.aOffset[u.am.i] = u.am.offset;\n        u.am.zIdx += getVarint32(u.am.zIdx, u.am.aType[u.am.i]);\n        u.am.szField = sqlite3VdbeSerialTypeLen(u.am.aType[u.am.i]);\n        u.am.offset += u.am.szField;\n        if( u.am.offset<u.am.szField ){  /* True if u.am.offset overflows */\n          u.am.zIdx = &u.am.zEndHdr[1];  /* Forces SQLITE_CORRUPT return below */\n          break;\n        }\n      }else{\n        /* If u.am.i is less that u.am.nField, then there are less fields in this\n        ** record than SetNumColumns indicated there are columns in the\n        ** table. Set the u.am.offset for any extra columns not present in\n        ** the record to 0. This tells code below to store a NULL\n        ** instead of deserializing a value from the record.\n        */\n        u.am.aOffset[u.am.i] = 0;\n      }\n    }\n    sqlite3VdbeMemRelease(&u.am.sMem);\n    u.am.sMem.flags = MEM_Null;\n\n    /* If we have read more header data than was contained in the header,\n    ** or if the end of the last field appears to be past the end of the\n    ** record, or if the end of the last field appears to be before the end\n    ** of the record (when all fields present), then we must be dealing\n    ** with a corrupt database.\n    */\n    if( (u.am.zIdx > u.am.zEndHdr) || (u.am.offset > u.am.payloadSize)\n         || (u.am.zIdx==u.am.zEndHdr && u.am.offset!=u.am.payloadSize) ){\n      rc = SQLITE_CORRUPT_BKPT;\n      goto op_column_out;\n    }\n  }\n\n  /* Get the column information. If u.am.aOffset[u.am.p2] is non-zero, then\n  ** deserialize the value from the record. If u.am.aOffset[u.am.p2] is zero,\n  ** then there are not enough fields in the record to satisfy the\n  ** request.  In this case, set the value NULL or to P4 if P4 is\n  ** a pointer to a Mem object.\n  */\n  if( u.am.aOffset[u.am.p2] ){\n    assert( rc==SQLITE_OK );\n    if( u.am.zRec ){\n      sqlite3VdbeMemReleaseExternal(u.am.pDest);\n      sqlite3VdbeSerialGet((u8 *)&u.am.zRec[u.am.aOffset[u.am.p2]], u.am.aType[u.am.p2], u.am.pDest);\n    }else{\n      u.am.len = sqlite3VdbeSerialTypeLen(u.am.aType[u.am.p2]);\n      sqlite3VdbeMemMove(&u.am.sMem, u.am.pDest);\n      rc = sqlite3VdbeMemFromBtree(u.am.pCrsr, u.am.aOffset[u.am.p2], u.am.len, u.am.pC->isIndex, &u.am.sMem);\n      if( rc!=SQLITE_OK ){\n        goto op_column_out;\n      }\n      u.am.zData = u.am.sMem.z;\n      sqlite3VdbeSerialGet((u8*)u.am.zData, u.am.aType[u.am.p2], u.am.pDest);\n    }\n    u.am.pDest->enc = encoding;\n  }else{\n    if( pOp->p4type==P4_MEM ){\n      sqlite3VdbeMemShallowCopy(u.am.pDest, pOp->p4.pMem, MEM_Static);\n    }else{\n      assert( u.am.pDest->flags&MEM_Null );\n    }\n  }\n\n  /* If we dynamically allocated space to hold the data (in the\n  ** sqlite3VdbeMemFromBtree() call above) then transfer control of that\n  ** dynamically allocated space over to the u.am.pDest structure.\n  ** This prevents a memory copy.\n  */\n  if( u.am.sMem.zMalloc ){\n    assert( u.am.sMem.z==u.am.sMem.zMalloc );\n    assert( !(u.am.pDest->flags & MEM_Dyn) );\n    assert( !(u.am.pDest->flags & (MEM_Blob|MEM_Str)) || u.am.pDest->z==u.am.sMem.z );\n    u.am.pDest->flags &= ~(MEM_Ephem|MEM_Static);\n    u.am.pDest->flags |= MEM_Term;\n    u.am.pDest->z = u.am.sMem.z;\n    u.am.pDest->zMalloc = u.am.sMem.zMalloc;\n  }\n\n  rc = sqlite3VdbeMemMakeWriteable(u.am.pDest);\n\nop_column_out:\n  UPDATE_MAX_BLOBSIZE(u.am.pDest);\n  REGISTER_TRACE(pOp->p3, u.am.pDest);\n  break;\n}\n\n/* Opcode: Affinity P1 P2 * P4 *\n**\n** Apply affinities to a range of P2 registers starting with P1.\n**\n** P4 is a string that is P2 characters long. The nth character of the\n** string indicates the column affinity that should be used for the nth\n** memory cell in the range.\n*/\ncase OP_Affinity: {\n#if 0  /* local variables moved into u.an */\n  const char *zAffinity;   /* The affinity to be applied */\n  char cAff;               /* A single character of affinity */\n#endif /* local variables moved into u.an */\n\n  u.an.zAffinity = pOp->p4.z;\n  assert( u.an.zAffinity!=0 );\n  assert( u.an.zAffinity[pOp->p2]==0 );\n  pIn1 = &aMem[pOp->p1];\n  while( (u.an.cAff = *(u.an.zAffinity++))!=0 ){\n    assert( pIn1 <= &p->aMem[p->nMem] );\n    assert( memIsValid(pIn1) );\n    ExpandBlob(pIn1);\n    applyAffinity(pIn1, u.an.cAff, encoding);\n    pIn1++;\n  }\n  break;\n}\n\n/* Opcode: MakeRecord P1 P2 P3 P4 *\n**\n** Convert P2 registers beginning with P1 into the [record format]\n** use as a data record in a database table or as a key\n** in an index.  The OP_Column opcode can decode the record later.\n**\n** P4 may be a string that is P2 characters long.  The nth character of the\n** string indicates the column affinity that should be used for the nth\n** field of the index key.\n**\n** The mapping from character to affinity is given by the SQLITE_AFF_\n** macros defined in sqliteInt.h.\n**\n** If P4 is NULL then all index fields have the affinity NONE.\n*/\ncase OP_MakeRecord: {\n#if 0  /* local variables moved into u.ao */\n  u8 *zNewRecord;        /* A buffer to hold the data for the new record */\n  Mem *pRec;             /* The new record */\n  u64 nData;             /* Number of bytes of data space */\n  int nHdr;              /* Number of bytes of header space */\n  i64 nByte;             /* Data space required for this record */\n  int nZero;             /* Number of zero bytes at the end of the record */\n  int nVarint;           /* Number of bytes in a varint */\n  u32 serial_type;       /* Type field */\n  Mem *pData0;           /* First field to be combined into the record */\n  Mem *pLast;            /* Last field of the record */\n  int nField;            /* Number of fields in the record */\n  char *zAffinity;       /* The affinity string for the record */\n  int file_format;       /* File format to use for encoding */\n  int i;                 /* Space used in zNewRecord[] */\n  int len;               /* Length of a field */\n#endif /* local variables moved into u.ao */\n\n  /* Assuming the record contains N fields, the record format looks\n  ** like this:\n  **\n  ** ------------------------------------------------------------------------\n  ** | hdr-size | type 0 | type 1 | ... | type N-1 | data0 | ... | data N-1 |\n  ** ------------------------------------------------------------------------\n  **\n  ** Data(0) is taken from register P1.  Data(1) comes from register P1+1\n  ** and so froth.\n  **\n  ** Each type field is a varint representing the serial type of the\n  ** corresponding data element (see sqlite3VdbeSerialType()). The\n  ** hdr-size field is also a varint which is the offset from the beginning\n  ** of the record to data0.\n  */\n  u.ao.nData = 0;         /* Number of bytes of data space */\n  u.ao.nHdr = 0;          /* Number of bytes of header space */\n  u.ao.nZero = 0;         /* Number of zero bytes at the end of the record */\n  u.ao.nField = pOp->p1;\n  u.ao.zAffinity = pOp->p4.z;\n  assert( u.ao.nField>0 && pOp->p2>0 && pOp->p2+u.ao.nField<=p->nMem+1 );\n  u.ao.pData0 = &aMem[u.ao.nField];\n  u.ao.nField = pOp->p2;\n  u.ao.pLast = &u.ao.pData0[u.ao.nField-1];\n  u.ao.file_format = p->minWriteFileFormat;\n\n  /* Identify the output register */\n  assert( pOp->p3<pOp->p1 || pOp->p3>=pOp->p1+pOp->p2 );\n  pOut = &aMem[pOp->p3];\n  memAboutToChange(p, pOut);\n\n  /* Loop through the elements that will make up the record to figure\n  ** out how much space is required for the new record.\n  */\n  for(u.ao.pRec=u.ao.pData0; u.ao.pRec<=u.ao.pLast; u.ao.pRec++){\n    assert( memIsValid(u.ao.pRec) );\n    if( u.ao.zAffinity ){\n      applyAffinity(u.ao.pRec, u.ao.zAffinity[u.ao.pRec-u.ao.pData0], encoding);\n    }\n    if( u.ao.pRec->flags&MEM_Zero && u.ao.pRec->n>0 ){\n      sqlite3VdbeMemExpandBlob(u.ao.pRec);\n    }\n    u.ao.serial_type = sqlite3VdbeSerialType(u.ao.pRec, u.ao.file_format);\n    u.ao.len = sqlite3VdbeSerialTypeLen(u.ao.serial_type);\n    u.ao.nData += u.ao.len;\n    u.ao.nHdr += sqlite3VarintLen(u.ao.serial_type);\n    if( u.ao.pRec->flags & MEM_Zero ){\n      /* Only pure zero-filled BLOBs can be input to this Opcode.\n      ** We do not allow blobs with a prefix and a zero-filled tail. */\n      u.ao.nZero += u.ao.pRec->u.nZero;\n    }else if( u.ao.len ){\n      u.ao.nZero = 0;\n    }\n  }\n\n  /* Add the initial header varint and total the size */\n  u.ao.nHdr += u.ao.nVarint = sqlite3VarintLen(u.ao.nHdr);\n  if( u.ao.nVarint<sqlite3VarintLen(u.ao.nHdr) ){\n    u.ao.nHdr++;\n  }\n  u.ao.nByte = u.ao.nHdr+u.ao.nData-u.ao.nZero;\n  if( u.ao.nByte>db->aLimit[SQLITE_LIMIT_LENGTH] ){\n    goto too_big;\n  }\n\n  /* Make sure the output register has a buffer large enough to store\n  ** the new record. The output register (pOp->p3) is not allowed to\n  ** be one of the input registers (because the following call to\n  ** sqlite3VdbeMemGrow() could clobber the value before it is used).\n  */\n  if( sqlite3VdbeMemGrow(pOut, (int)u.ao.nByte, 0) ){\n    goto no_mem;\n  }\n  u.ao.zNewRecord = (u8 *)pOut->z;\n\n  /* Write the record */\n  u.ao.i = putVarint32(u.ao.zNewRecord, u.ao.nHdr);\n  for(u.ao.pRec=u.ao.pData0; u.ao.pRec<=u.ao.pLast; u.ao.pRec++){\n    u.ao.serial_type = sqlite3VdbeSerialType(u.ao.pRec, u.ao.file_format);\n    u.ao.i += putVarint32(&u.ao.zNewRecord[u.ao.i], u.ao.serial_type);      /* serial type */\n  }\n  for(u.ao.pRec=u.ao.pData0; u.ao.pRec<=u.ao.pLast; u.ao.pRec++){  /* serial data */\n    u.ao.i += sqlite3VdbeSerialPut(&u.ao.zNewRecord[u.ao.i], (int)(u.ao.nByte-u.ao.i), u.ao.pRec,u.ao.file_format);\n  }\n  assert( u.ao.i==u.ao.nByte );\n\n  assert( pOp->p3>0 && pOp->p3<=p->nMem );\n  pOut->n = (int)u.ao.nByte;\n  pOut->flags = MEM_Blob | MEM_Dyn;\n  pOut->xDel = 0;\n  if( u.ao.nZero ){\n    pOut->u.nZero = u.ao.nZero;\n    pOut->flags |= MEM_Zero;\n  }\n  pOut->enc = SQLITE_UTF8;  /* In case the blob is ever converted to text */\n  REGISTER_TRACE(pOp->p3, pOut);\n  UPDATE_MAX_BLOBSIZE(pOut);\n  break;\n}\n\n/* Opcode: Count P1 P2 * * *\n**\n** Store the number of entries (an integer value) in the table or index \n** opened by cursor P1 in register P2\n*/\n#ifndef SQLITE_OMIT_BTREECOUNT\ncase OP_Count: {         /* out2-prerelease */\n#if 0  /* local variables moved into u.ap */\n  i64 nEntry;\n  BtCursor *pCrsr;\n#endif /* local variables moved into u.ap */\n\n  u.ap.pCrsr = p->apCsr[pOp->p1]->pCursor;\n  if( u.ap.pCrsr ){\n    rc = sqlite3BtreeCount(u.ap.pCrsr, &u.ap.nEntry);\n  }else{\n    u.ap.nEntry = 0;\n  }\n  pOut->u.i = u.ap.nEntry;\n  break;\n}\n#endif\n\n/* Opcode: Savepoint P1 * * P4 *\n**\n** Open, release or rollback the savepoint named by parameter P4, depending\n** on the value of P1. To open a new savepoint, P1==0. To release (commit) an\n** existing savepoint, P1==1, or to rollback an existing savepoint P1==2.\n*/\ncase OP_Savepoint: {\n#if 0  /* local variables moved into u.aq */\n  int p1;                         /* Value of P1 operand */\n  char *zName;                    /* Name of savepoint */\n  int nName;\n  Savepoint *pNew;\n  Savepoint *pSavepoint;\n  Savepoint *pTmp;\n  int iSavepoint;\n  int ii;\n#endif /* local variables moved into u.aq */\n\n  u.aq.p1 = pOp->p1;\n  u.aq.zName = pOp->p4.z;\n\n  /* Assert that the u.aq.p1 parameter is valid. Also that if there is no open\n  ** transaction, then there cannot be any savepoints.\n  */\n  assert( db->pSavepoint==0 || db->autoCommit==0 );\n  assert( u.aq.p1==SAVEPOINT_BEGIN||u.aq.p1==SAVEPOINT_RELEASE||u.aq.p1==SAVEPOINT_ROLLBACK );\n  assert( db->pSavepoint || db->isTransactionSavepoint==0 );\n  assert( checkSavepointCount(db) );\n\n  if( u.aq.p1==SAVEPOINT_BEGIN ){\n    if( db->writeVdbeCnt>0 ){\n      /* A new savepoint cannot be created if there are active write\n      ** statements (i.e. open read/write incremental blob handles).\n      */\n      sqlite3SetString(&p->zErrMsg, db, \"cannot open savepoint - \"\n        \"SQL statements in progress\");\n      rc = SQLITE_BUSY;\n    }else{\n      u.aq.nName = sqlite3Strlen30(u.aq.zName);\n\n      /* Create a new savepoint structure. */\n      u.aq.pNew = sqlite3DbMallocRaw(db, sizeof(Savepoint)+u.aq.nName+1);\n      if( u.aq.pNew ){\n        u.aq.pNew->zName = (char *)&u.aq.pNew[1];\n        memcpy(u.aq.pNew->zName, u.aq.zName, u.aq.nName+1);\n\n        /* If there is no open transaction, then mark this as a special\n        ** \"transaction savepoint\". */\n        if( db->autoCommit ){\n          db->autoCommit = 0;\n          db->isTransactionSavepoint = 1;\n        }else{\n          db->nSavepoint++;\n        }\n\n        /* Link the new savepoint into the database handle's list. */\n        u.aq.pNew->pNext = db->pSavepoint;\n        db->pSavepoint = u.aq.pNew;\n        u.aq.pNew->nDeferredCons = db->nDeferredCons;\n      }\n    }\n  }else{\n    u.aq.iSavepoint = 0;\n\n    /* Find the named savepoint. If there is no such savepoint, then an\n    ** an error is returned to the user.  */\n    for(\n      u.aq.pSavepoint = db->pSavepoint;\n      u.aq.pSavepoint && sqlite3StrICmp(u.aq.pSavepoint->zName, u.aq.zName);\n      u.aq.pSavepoint = u.aq.pSavepoint->pNext\n    ){\n      u.aq.iSavepoint++;\n    }\n    if( !u.aq.pSavepoint ){\n      sqlite3SetString(&p->zErrMsg, db, \"no such savepoint: %s\", u.aq.zName);\n      rc = SQLITE_ERROR;\n    }else if(\n        db->writeVdbeCnt>0 || (u.aq.p1==SAVEPOINT_ROLLBACK && db->activeVdbeCnt>1)\n    ){\n      /* It is not possible to release (commit) a savepoint if there are\n      ** active write statements. It is not possible to rollback a savepoint\n      ** if there are any active statements at all.\n      */\n      sqlite3SetString(&p->zErrMsg, db,\n        \"cannot %s savepoint - SQL statements in progress\",\n        (u.aq.p1==SAVEPOINT_ROLLBACK ? \"rollback\": \"release\")\n      );\n      rc = SQLITE_BUSY;\n    }else{\n\n      /* Determine whether or not this is a transaction savepoint. If so,\n      ** and this is a RELEASE command, then the current transaction\n      ** is committed.\n      */\n      int isTransaction = u.aq.pSavepoint->pNext==0 && db->isTransactionSavepoint;\n      if( isTransaction && u.aq.p1==SAVEPOINT_RELEASE ){\n        if( (rc = sqlite3VdbeCheckFk(p, 1))!=SQLITE_OK ){\n          goto vdbe_return;\n        }\n        db->autoCommit = 1;\n        if( sqlite3VdbeHalt(p)==SQLITE_BUSY ){\n          p->pc = pc;\n          db->autoCommit = 0;\n          p->rc = rc = SQLITE_BUSY;\n          goto vdbe_return;\n        }\n        db->isTransactionSavepoint = 0;\n        rc = p->rc;\n      }else{\n        u.aq.iSavepoint = db->nSavepoint - u.aq.iSavepoint - 1;\n        for(u.aq.ii=0; u.aq.ii<db->nDb; u.aq.ii++){\n          rc = sqlite3BtreeSavepoint(db->aDb[u.aq.ii].pBt, u.aq.p1, u.aq.iSavepoint);\n          if( rc!=SQLITE_OK ){\n            goto abort_due_to_error;\n          }\n        }\n        if( u.aq.p1==SAVEPOINT_ROLLBACK && (db->flags&SQLITE_InternChanges)!=0 ){\n          sqlite3ExpirePreparedStatements(db);\n          sqlite3ResetInternalSchema(db, 0);\n          db->flags = (db->flags | SQLITE_InternChanges);\n        }\n      }\n\n      /* Regardless of whether this is a RELEASE or ROLLBACK, destroy all\n      ** savepoints nested inside of the savepoint being operated on. */\n      while( db->pSavepoint!=u.aq.pSavepoint ){\n        u.aq.pTmp = db->pSavepoint;\n        db->pSavepoint = u.aq.pTmp->pNext;\n        sqlite3DbFree(db, u.aq.pTmp);\n        db->nSavepoint--;\n      }\n\n      /* If it is a RELEASE, then destroy the savepoint being operated on\n      ** too. If it is a ROLLBACK TO, then set the number of deferred\n      ** constraint violations present in the database to the value stored\n      ** when the savepoint was created.  */\n      if( u.aq.p1==SAVEPOINT_RELEASE ){\n        assert( u.aq.pSavepoint==db->pSavepoint );\n        db->pSavepoint = u.aq.pSavepoint->pNext;\n        sqlite3DbFree(db, u.aq.pSavepoint);\n        if( !isTransaction ){\n          db->nSavepoint--;\n        }\n      }else{\n        db->nDeferredCons = u.aq.pSavepoint->nDeferredCons;\n      }\n    }\n  }\n\n  break;\n}\n\n/* Opcode: AutoCommit P1 P2 * * *\n**\n** Set the database auto-commit flag to P1 (1 or 0). If P2 is true, roll\n** back any currently active btree transactions. If there are any active\n** VMs (apart from this one), then a ROLLBACK fails.  A COMMIT fails if\n** there are active writing VMs or active VMs that use shared cache.\n**\n** This instruction causes the VM to halt.\n*/\ncase OP_AutoCommit: {\n#if 0  /* local variables moved into u.ar */\n  int desiredAutoCommit;\n  int iRollback;\n  int turnOnAC;\n#endif /* local variables moved into u.ar */\n\n  u.ar.desiredAutoCommit = pOp->p1;\n  u.ar.iRollback = pOp->p2;\n  u.ar.turnOnAC = u.ar.desiredAutoCommit && !db->autoCommit;\n  assert( u.ar.desiredAutoCommit==1 || u.ar.desiredAutoCommit==0 );\n  assert( u.ar.desiredAutoCommit==1 || u.ar.iRollback==0 );\n  assert( db->activeVdbeCnt>0 );  /* At least this one VM is active */\n\n  if( u.ar.turnOnAC && u.ar.iRollback && db->activeVdbeCnt>1 ){\n    /* If this instruction implements a ROLLBACK and other VMs are\n    ** still running, and a transaction is active, return an error indicating\n    ** that the other VMs must complete first.\n    */\n    sqlite3SetString(&p->zErrMsg, db, \"cannot rollback transaction - \"\n        \"SQL statements in progress\");\n    rc = SQLITE_BUSY;\n  }else if( u.ar.turnOnAC && !u.ar.iRollback && db->writeVdbeCnt>0 ){\n    /* If this instruction implements a COMMIT and other VMs are writing\n    ** return an error indicating that the other VMs must complete first.\n    */\n    sqlite3SetString(&p->zErrMsg, db, \"cannot commit transaction - \"\n        \"SQL statements in progress\");\n    rc = SQLITE_BUSY;\n  }else if( u.ar.desiredAutoCommit!=db->autoCommit ){\n    if( u.ar.iRollback ){\n      assert( u.ar.desiredAutoCommit==1 );\n      sqlite3RollbackAll(db);\n      db->autoCommit = 1;\n    }else if( (rc = sqlite3VdbeCheckFk(p, 1))!=SQLITE_OK ){\n      goto vdbe_return;\n    }else{\n      db->autoCommit = (u8)u.ar.desiredAutoCommit;\n      if( sqlite3VdbeHalt(p)==SQLITE_BUSY ){\n        p->pc = pc;\n        db->autoCommit = (u8)(1-u.ar.desiredAutoCommit);\n        p->rc = rc = SQLITE_BUSY;\n        goto vdbe_return;\n      }\n    }\n    assert( db->nStatement==0 );\n    sqlite3CloseSavepoints(db);\n    if( p->rc==SQLITE_OK ){\n      rc = SQLITE_DONE;\n    }else{\n      rc = SQLITE_ERROR;\n    }\n    goto vdbe_return;\n  }else{\n    sqlite3SetString(&p->zErrMsg, db,\n        (!u.ar.desiredAutoCommit)?\"cannot start a transaction within a transaction\":(\n        (u.ar.iRollback)?\"cannot rollback - no transaction is active\":\n                   \"cannot commit - no transaction is active\"));\n\n    rc = SQLITE_ERROR;\n  }\n  break;\n}\n\n/* Opcode: Transaction P1 P2 * * *\n**\n** Begin a transaction.  The transaction ends when a Commit or Rollback\n** opcode is encountered.  Depending on the ON CONFLICT setting, the\n** transaction might also be rolled back if an error is encountered.\n**\n** P1 is the index of the database file on which the transaction is\n** started.  Index 0 is the main database file and index 1 is the\n** file used for temporary tables.  Indices of 2 or more are used for\n** attached databases.\n**\n** If P2 is non-zero, then a write-transaction is started.  A RESERVED lock is\n** obtained on the database file when a write-transaction is started.  No\n** other process can start another write transaction while this transaction is\n** underway.  Starting a write transaction also creates a rollback journal. A\n** write transaction must be started before any changes can be made to the\n** database.  If P2 is 2 or greater then an EXCLUSIVE lock is also obtained\n** on the file.\n**\n** If a write-transaction is started and the Vdbe.usesStmtJournal flag is\n** true (this flag is set if the Vdbe may modify more than one row and may\n** throw an ABORT exception), a statement transaction may also be opened.\n** More specifically, a statement transaction is opened iff the database\n** connection is currently not in autocommit mode, or if there are other\n** active statements. A statement transaction allows the affects of this\n** VDBE to be rolled back after an error without having to roll back the\n** entire transaction. If no error is encountered, the statement transaction\n** will automatically commit when the VDBE halts.\n**\n** If P2 is zero, then a read-lock is obtained on the database file.\n*/\ncase OP_Transaction: {\n#if 0  /* local variables moved into u.as */\n  Btree *pBt;\n#endif /* local variables moved into u.as */\n\n  assert( pOp->p1>=0 && pOp->p1<db->nDb );\n  assert( (p->btreeMask & (1<<pOp->p1))!=0 );\n  u.as.pBt = db->aDb[pOp->p1].pBt;\n\n  if( u.as.pBt ){\n    rc = sqlite3BtreeBeginTrans(u.as.pBt, pOp->p2);\n    if( rc==SQLITE_BUSY ){\n      p->pc = pc;\n      p->rc = rc = SQLITE_BUSY;\n      goto vdbe_return;\n    }\n    if( rc!=SQLITE_OK ){\n      goto abort_due_to_error;\n    }\n\n    if( pOp->p2 && p->usesStmtJournal\n     && (db->autoCommit==0 || db->activeVdbeCnt>1)\n    ){\n      assert( sqlite3BtreeIsInTrans(u.as.pBt) );\n      if( p->iStatement==0 ){\n        assert( db->nStatement>=0 && db->nSavepoint>=0 );\n        db->nStatement++;\n        p->iStatement = db->nSavepoint + db->nStatement;\n      }\n      rc = sqlite3BtreeBeginStmt(u.as.pBt, p->iStatement);\n\n      /* Store the current value of the database handles deferred constraint\n      ** counter. If the statement transaction needs to be rolled back,\n      ** the value of this counter needs to be restored too.  */\n      p->nStmtDefCons = db->nDeferredCons;\n    }\n  }\n  break;\n}\n\n/* Opcode: ReadCookie P1 P2 P3 * *\n**\n** Read cookie number P3 from database P1 and write it into register P2.\n** P3==1 is the schema version.  P3==2 is the database format.\n** P3==3 is the recommended pager cache size, and so forth.  P1==0 is\n** the main database file and P1==1 is the database file used to store\n** temporary tables.\n**\n** There must be a read-lock on the database (either a transaction\n** must be started or there must be an open cursor) before\n** executing this instruction.\n*/\ncase OP_ReadCookie: {               /* out2-prerelease */\n#if 0  /* local variables moved into u.at */\n  int iMeta;\n  int iDb;\n  int iCookie;\n#endif /* local variables moved into u.at */\n\n  u.at.iDb = pOp->p1;\n  u.at.iCookie = pOp->p3;\n  assert( pOp->p3<SQLITE_N_BTREE_META );\n  assert( u.at.iDb>=0 && u.at.iDb<db->nDb );\n  assert( db->aDb[u.at.iDb].pBt!=0 );\n  assert( (p->btreeMask & (1<<u.at.iDb))!=0 );\n\n  sqlite3BtreeGetMeta(db->aDb[u.at.iDb].pBt, u.at.iCookie, (u32 *)&u.at.iMeta);\n  pOut->u.i = u.at.iMeta;\n  break;\n}\n\n/* Opcode: SetCookie P1 P2 P3 * *\n**\n** Write the content of register P3 (interpreted as an integer)\n** into cookie number P2 of database P1.  P2==1 is the schema version.  \n** P2==2 is the database format. P2==3 is the recommended pager cache \n** size, and so forth.  P1==0 is the main database file and P1==1 is the \n** database file used to store temporary tables.\n**\n** A transaction must be started before executing this opcode.\n*/\ncase OP_SetCookie: {       /* in3 */\n#if 0  /* local variables moved into u.au */\n  Db *pDb;\n#endif /* local variables moved into u.au */\n  assert( pOp->p2<SQLITE_N_BTREE_META );\n  assert( pOp->p1>=0 && pOp->p1<db->nDb );\n  assert( (p->btreeMask & (1<<pOp->p1))!=0 );\n  u.au.pDb = &db->aDb[pOp->p1];\n  assert( u.au.pDb->pBt!=0 );\n  pIn3 = &aMem[pOp->p3];\n  sqlite3VdbeMemIntegerify(pIn3);\n  /* See note about index shifting on OP_ReadCookie */\n  rc = sqlite3BtreeUpdateMeta(u.au.pDb->pBt, pOp->p2, (int)pIn3->u.i);\n  if( pOp->p2==BTREE_SCHEMA_VERSION ){\n    /* When the schema cookie changes, record the new cookie internally */\n    u.au.pDb->pSchema->schema_cookie = (int)pIn3->u.i;\n    db->flags |= SQLITE_InternChanges;\n  }else if( pOp->p2==BTREE_FILE_FORMAT ){\n    /* Record changes in the file format */\n    u.au.pDb->pSchema->file_format = (u8)pIn3->u.i;\n  }\n  if( pOp->p1==1 ){\n    /* Invalidate all prepared statements whenever the TEMP database\n    ** schema is changed.  Ticket #1644 */\n    sqlite3ExpirePreparedStatements(db);\n    p->expired = 0;\n  }\n  break;\n}\n\n/* Opcode: VerifyCookie P1 P2 *\n**\n** Check the value of global database parameter number 0 (the\n** schema version) and make sure it is equal to P2.  \n** P1 is the database number which is 0 for the main database file\n** and 1 for the file holding temporary tables and some higher number\n** for auxiliary databases.\n**\n** The cookie changes its value whenever the database schema changes.\n** This operation is used to detect when that the cookie has changed\n** and that the current process needs to reread the schema.\n**\n** Either a transaction needs to have been started or an OP_Open needs\n** to be executed (to establish a read lock) before this opcode is\n** invoked.\n*/\ncase OP_VerifyCookie: {\n#if 0  /* local variables moved into u.av */\n  int iMeta;\n  Btree *pBt;\n#endif /* local variables moved into u.av */\n  assert( pOp->p1>=0 && pOp->p1<db->nDb );\n  assert( (p->btreeMask & (1<<pOp->p1))!=0 );\n  u.av.pBt = db->aDb[pOp->p1].pBt;\n  if( u.av.pBt ){\n    sqlite3BtreeGetMeta(u.av.pBt, BTREE_SCHEMA_VERSION, (u32 *)&u.av.iMeta);\n  }else{\n    u.av.iMeta = 0;\n  }\n  if( u.av.iMeta!=pOp->p2 ){\n    sqlite3DbFree(db, p->zErrMsg);\n    p->zErrMsg = sqlite3DbStrDup(db, \"database schema has changed\");\n    /* If the schema-cookie from the database file matches the cookie\n    ** stored with the in-memory representation of the schema, do\n    ** not reload the schema from the database file.\n    **\n    ** If virtual-tables are in use, this is not just an optimization.\n    ** Often, v-tables store their data in other SQLite tables, which\n    ** are queried from within xNext() and other v-table methods using\n    ** prepared queries. If such a query is out-of-date, we do not want to\n    ** discard the database schema, as the user code implementing the\n    ** v-table would have to be ready for the sqlite3_vtab structure itself\n    ** to be invalidated whenever sqlite3_step() is called from within\n    ** a v-table method.\n    */\n    if( db->aDb[pOp->p1].pSchema->schema_cookie!=u.av.iMeta ){\n      sqlite3ResetInternalSchema(db, pOp->p1);\n    }\n\n    p->expired = 1;\n    rc = SQLITE_SCHEMA;\n  }\n  break;\n}\n\n/* Opcode: OpenRead P1 P2 P3 P4 P5\n**\n** Open a read-only cursor for the database table whose root page is\n** P2 in a database file.  The database file is determined by P3. \n** P3==0 means the main database, P3==1 means the database used for \n** temporary tables, and P3>1 means used the corresponding attached\n** database.  Give the new cursor an identifier of P1.  The P1\n** values need not be contiguous but all P1 values should be small integers.\n** It is an error for P1 to be negative.\n**\n** If P5!=0 then use the content of register P2 as the root page, not\n** the value of P2 itself.\n**\n** There will be a read lock on the database whenever there is an\n** open cursor.  If the database was unlocked prior to this instruction\n** then a read lock is acquired as part of this instruction.  A read\n** lock allows other processes to read the database but prohibits\n** any other process from modifying the database.  The read lock is\n** released when all cursors are closed.  If this instruction attempts\n** to get a read lock but fails, the script terminates with an\n** SQLITE_BUSY error code.\n**\n** The P4 value may be either an integer (P4_INT32) or a pointer to\n** a KeyInfo structure (P4_KEYINFO). If it is a pointer to a KeyInfo \n** structure, then said structure defines the content and collating \n** sequence of the index being opened. Otherwise, if P4 is an integer \n** value, it is set to the number of columns in the table.\n**\n** See also OpenWrite.\n*/\n/* Opcode: OpenWrite P1 P2 P3 P4 P5\n**\n** Open a read/write cursor named P1 on the table or index whose root\n** page is P2.  Or if P5!=0 use the content of register P2 to find the\n** root page.\n**\n** The P4 value may be either an integer (P4_INT32) or a pointer to\n** a KeyInfo structure (P4_KEYINFO). If it is a pointer to a KeyInfo \n** structure, then said structure defines the content and collating \n** sequence of the index being opened. Otherwise, if P4 is an integer \n** value, it is set to the number of columns in the table, or to the\n** largest index of any column of the table that is actually used.\n**\n** This instruction works just like OpenRead except that it opens the cursor\n** in read/write mode.  For a given table, there can be one or more read-only\n** cursors or a single read/write cursor but not both.\n**\n** See also OpenRead.\n*/\ncase OP_OpenRead:\ncase OP_OpenWrite: {\n#if 0  /* local variables moved into u.aw */\n  int nField;\n  KeyInfo *pKeyInfo;\n  int p2;\n  int iDb;\n  int wrFlag;\n  Btree *pX;\n  VdbeCursor *pCur;\n  Db *pDb;\n#endif /* local variables moved into u.aw */\n\n  if( p->expired ){\n    rc = SQLITE_ABORT;\n    break;\n  }\n\n  u.aw.nField = 0;\n  u.aw.pKeyInfo = 0;\n  u.aw.p2 = pOp->p2;\n  u.aw.iDb = pOp->p3;\n  assert( u.aw.iDb>=0 && u.aw.iDb<db->nDb );\n  assert( (p->btreeMask & (1<<u.aw.iDb))!=0 );\n  u.aw.pDb = &db->aDb[u.aw.iDb];\n  u.aw.pX = u.aw.pDb->pBt;\n  assert( u.aw.pX!=0 );\n  if( pOp->opcode==OP_OpenWrite ){\n    u.aw.wrFlag = 1;\n    if( u.aw.pDb->pSchema->file_format < p->minWriteFileFormat ){\n      p->minWriteFileFormat = u.aw.pDb->pSchema->file_format;\n    }\n  }else{\n    u.aw.wrFlag = 0;\n  }\n  if( pOp->p5 ){\n    assert( u.aw.p2>0 );\n    assert( u.aw.p2<=p->nMem );\n    pIn2 = &aMem[u.aw.p2];\n    assert( memIsValid(pIn2) );\n    assert( (pIn2->flags & MEM_Int)!=0 );\n    sqlite3VdbeMemIntegerify(pIn2);\n    u.aw.p2 = (int)pIn2->u.i;\n    /* The u.aw.p2 value always comes from a prior OP_CreateTable opcode and\n    ** that opcode will always set the u.aw.p2 value to 2 or more or else fail.\n    ** If there were a failure, the prepared statement would have halted\n    ** before reaching this instruction. */\n    if( NEVER(u.aw.p2<2) ) {\n      rc = SQLITE_CORRUPT_BKPT;\n      goto abort_due_to_error;\n    }\n  }\n  if( pOp->p4type==P4_KEYINFO ){\n    u.aw.pKeyInfo = pOp->p4.pKeyInfo;\n    u.aw.pKeyInfo->enc = ENC(p->db);\n    u.aw.nField = u.aw.pKeyInfo->nField+1;\n  }else if( pOp->p4type==P4_INT32 ){\n    u.aw.nField = pOp->p4.i;\n  }\n  assert( pOp->p1>=0 );\n  u.aw.pCur = allocateCursor(p, pOp->p1, u.aw.nField, u.aw.iDb, 1);\n  if( u.aw.pCur==0 ) goto no_mem;\n  u.aw.pCur->nullRow = 1;\n  u.aw.pCur->isOrdered = 1;\n  rc = sqlite3BtreeCursor(u.aw.pX, u.aw.p2, u.aw.wrFlag, u.aw.pKeyInfo, u.aw.pCur->pCursor);\n  u.aw.pCur->pKeyInfo = u.aw.pKeyInfo;\n\n  /* Since it performs no memory allocation or IO, the only values that\n  ** sqlite3BtreeCursor() may return are SQLITE_EMPTY and SQLITE_OK.\n  ** SQLITE_EMPTY is only returned when attempting to open the table\n  ** rooted at page 1 of a zero-byte database.  */\n  assert( rc==SQLITE_EMPTY || rc==SQLITE_OK );\n  if( rc==SQLITE_EMPTY ){\n    u.aw.pCur->pCursor = 0;\n    rc = SQLITE_OK;\n  }\n\n  /* Set the VdbeCursor.isTable and isIndex variables. Previous versions of\n  ** SQLite used to check if the root-page flags were sane at this point\n  ** and report database corruption if they were not, but this check has\n  ** since moved into the btree layer.  */\n  u.aw.pCur->isTable = pOp->p4type!=P4_KEYINFO;\n  u.aw.pCur->isIndex = !u.aw.pCur->isTable;\n  break;\n}\n\n/* Opcode: OpenEphemeral P1 P2 * P4 *\n**\n** Open a new cursor P1 to a transient table.\n** The cursor is always opened read/write even if \n** the main database is read-only.  The ephemeral\n** table is deleted automatically when the cursor is closed.\n**\n** P2 is the number of columns in the ephemeral table.\n** The cursor points to a BTree table if P4==0 and to a BTree index\n** if P4 is not 0.  If P4 is not NULL, it points to a KeyInfo structure\n** that defines the format of keys in the index.\n**\n** This opcode was once called OpenTemp.  But that created\n** confusion because the term \"temp table\", might refer either\n** to a TEMP table at the SQL level, or to a table opened by\n** this opcode.  Then this opcode was call OpenVirtual.  But\n** that created confusion with the whole virtual-table idea.\n*/\n/* Opcode: OpenAutoindex P1 P2 * P4 *\n**\n** This opcode works the same as OP_OpenEphemeral.  It has a\n** different name to distinguish its use.  Tables created using\n** by this opcode will be used for automatically created transient\n** indices in joins.\n*/\ncase OP_OpenAutoindex: \ncase OP_OpenEphemeral: {\n#if 0  /* local variables moved into u.ax */\n  VdbeCursor *pCx;\n#endif /* local variables moved into u.ax */\n  static const int vfsFlags =\n      SQLITE_OPEN_READWRITE |\n      SQLITE_OPEN_CREATE |\n      SQLITE_OPEN_EXCLUSIVE |\n      SQLITE_OPEN_DELETEONCLOSE |\n      SQLITE_OPEN_TRANSIENT_DB;\n\n  assert( pOp->p1>=0 );\n  u.ax.pCx = allocateCursor(p, pOp->p1, pOp->p2, -1, 1);\n  if( u.ax.pCx==0 ) goto no_mem;\n  u.ax.pCx->nullRow = 1;\n  rc = sqlite3BtreeOpen(0, db, &u.ax.pCx->pBt,\n                        BTREE_OMIT_JOURNAL | BTREE_SINGLE | pOp->p5, vfsFlags);\n  if( rc==SQLITE_OK ){\n    rc = sqlite3BtreeBeginTrans(u.ax.pCx->pBt, 1);\n  }\n  if( rc==SQLITE_OK ){\n    /* If a transient index is required, create it by calling\n    ** sqlite3BtreeCreateTable() with the BTREE_BLOBKEY flag before\n    ** opening it. If a transient table is required, just use the\n    ** automatically created table with root-page 1 (an BLOB_INTKEY table).\n    */\n    if( pOp->p4.pKeyInfo ){\n      int pgno;\n      assert( pOp->p4type==P4_KEYINFO );\n      rc = sqlite3BtreeCreateTable(u.ax.pCx->pBt, &pgno, BTREE_BLOBKEY);\n      if( rc==SQLITE_OK ){\n        assert( pgno==MASTER_ROOT+1 );\n        rc = sqlite3BtreeCursor(u.ax.pCx->pBt, pgno, 1,\n                                (KeyInfo*)pOp->p4.z, u.ax.pCx->pCursor);\n        u.ax.pCx->pKeyInfo = pOp->p4.pKeyInfo;\n        u.ax.pCx->pKeyInfo->enc = ENC(p->db);\n      }\n      u.ax.pCx->isTable = 0;\n    }else{\n      rc = sqlite3BtreeCursor(u.ax.pCx->pBt, MASTER_ROOT, 1, 0, u.ax.pCx->pCursor);\n      u.ax.pCx->isTable = 1;\n    }\n  }\n  u.ax.pCx->isOrdered = (pOp->p5!=BTREE_UNORDERED);\n  u.ax.pCx->isIndex = !u.ax.pCx->isTable;\n  break;\n}\n\n/* Opcode: OpenPseudo P1 P2 P3 * *\n**\n** Open a new cursor that points to a fake table that contains a single\n** row of data.  The content of that one row in the content of memory\n** register P2.  In other words, cursor P1 becomes an alias for the \n** MEM_Blob content contained in register P2.\n**\n** A pseudo-table created by this opcode is used to hold a single\n** row output from the sorter so that the row can be decomposed into\n** individual columns using the OP_Column opcode.  The OP_Column opcode\n** is the only cursor opcode that works with a pseudo-table.\n**\n** P3 is the number of fields in the records that will be stored by\n** the pseudo-table.\n*/\ncase OP_OpenPseudo: {\n#if 0  /* local variables moved into u.ay */\n  VdbeCursor *pCx;\n#endif /* local variables moved into u.ay */\n\n  assert( pOp->p1>=0 );\n  u.ay.pCx = allocateCursor(p, pOp->p1, pOp->p3, -1, 0);\n  if( u.ay.pCx==0 ) goto no_mem;\n  u.ay.pCx->nullRow = 1;\n  u.ay.pCx->pseudoTableReg = pOp->p2;\n  u.ay.pCx->isTable = 1;\n  u.ay.pCx->isIndex = 0;\n  break;\n}\n\n/* Opcode: Close P1 * * * *\n**\n** Close a cursor previously opened as P1.  If P1 is not\n** currently open, this instruction is a no-op.\n*/\ncase OP_Close: {\n  assert( pOp->p1>=0 && pOp->p1<p->nCursor );\n  sqlite3VdbeFreeCursor(p, p->apCsr[pOp->p1]);\n  p->apCsr[pOp->p1] = 0;\n  break;\n}\n\n/* Opcode: SeekGe P1 P2 P3 P4 *\n**\n** If cursor P1 refers to an SQL table (B-Tree that uses integer keys), \n** use the value in register P3 as the key.  If cursor P1 refers \n** to an SQL index, then P3 is the first in an array of P4 registers \n** that are used as an unpacked index key. \n**\n** Reposition cursor P1 so that  it points to the smallest entry that \n** is greater than or equal to the key value. If there are no records \n** greater than or equal to the key and P2 is not zero, then jump to P2.\n**\n** See also: Found, NotFound, Distinct, SeekLt, SeekGt, SeekLe\n*/\n/* Opcode: SeekGt P1 P2 P3 P4 *\n**\n** If cursor P1 refers to an SQL table (B-Tree that uses integer keys), \n** use the value in register P3 as a key. If cursor P1 refers \n** to an SQL index, then P3 is the first in an array of P4 registers \n** that are used as an unpacked index key. \n**\n** Reposition cursor P1 so that  it points to the smallest entry that \n** is greater than the key value. If there are no records greater than \n** the key and P2 is not zero, then jump to P2.\n**\n** See also: Found, NotFound, Distinct, SeekLt, SeekGe, SeekLe\n*/\n/* Opcode: SeekLt P1 P2 P3 P4 * \n**\n** If cursor P1 refers to an SQL table (B-Tree that uses integer keys), \n** use the value in register P3 as a key. If cursor P1 refers \n** to an SQL index, then P3 is the first in an array of P4 registers \n** that are used as an unpacked index key. \n**\n** Reposition cursor P1 so that  it points to the largest entry that \n** is less than the key value. If there are no records less than \n** the key and P2 is not zero, then jump to P2.\n**\n** See also: Found, NotFound, Distinct, SeekGt, SeekGe, SeekLe\n*/\n/* Opcode: SeekLe P1 P2 P3 P4 *\n**\n** If cursor P1 refers to an SQL table (B-Tree that uses integer keys), \n** use the value in register P3 as a key. If cursor P1 refers \n** to an SQL index, then P3 is the first in an array of P4 registers \n** that are used as an unpacked index key. \n**\n** Reposition cursor P1 so that it points to the largest entry that \n** is less than or equal to the key value. If there are no records \n** less than or equal to the key and P2 is not zero, then jump to P2.\n**\n** See also: Found, NotFound, Distinct, SeekGt, SeekGe, SeekLt\n*/\ncase OP_SeekLt:         /* jump, in3 */\ncase OP_SeekLe:         /* jump, in3 */\ncase OP_SeekGe:         /* jump, in3 */\ncase OP_SeekGt: {       /* jump, in3 */\n#if 0  /* local variables moved into u.az */\n  int res;\n  int oc;\n  VdbeCursor *pC;\n  UnpackedRecord r;\n  int nField;\n  i64 iKey;      /* The rowid we are to seek to */\n#endif /* local variables moved into u.az */\n\n  assert( pOp->p1>=0 && pOp->p1<p->nCursor );\n  assert( pOp->p2!=0 );\n  u.az.pC = p->apCsr[pOp->p1];\n  assert( u.az.pC!=0 );\n  assert( u.az.pC->pseudoTableReg==0 );\n  assert( OP_SeekLe == OP_SeekLt+1 );\n  assert( OP_SeekGe == OP_SeekLt+2 );\n  assert( OP_SeekGt == OP_SeekLt+3 );\n  assert( u.az.pC->isOrdered );\n  if( u.az.pC->pCursor!=0 ){\n    u.az.oc = pOp->opcode;\n    u.az.pC->nullRow = 0;\n    if( u.az.pC->isTable ){\n      /* The input value in P3 might be of any type: integer, real, string,\n      ** blob, or NULL.  But it needs to be an integer before we can do\n      ** the seek, so covert it. */\n      pIn3 = &aMem[pOp->p3];\n      applyNumericAffinity(pIn3);\n      u.az.iKey = sqlite3VdbeIntValue(pIn3);\n      u.az.pC->rowidIsValid = 0;\n\n      /* If the P3 value could not be converted into an integer without\n      ** loss of information, then special processing is required... */\n      if( (pIn3->flags & MEM_Int)==0 ){\n        if( (pIn3->flags & MEM_Real)==0 ){\n          /* If the P3 value cannot be converted into any kind of a number,\n          ** then the seek is not possible, so jump to P2 */\n          pc = pOp->p2 - 1;\n          break;\n        }\n        /* If we reach this point, then the P3 value must be a floating\n        ** point number. */\n        assert( (pIn3->flags & MEM_Real)!=0 );\n\n        if( u.az.iKey==SMALLEST_INT64 && (pIn3->r<(double)u.az.iKey || pIn3->r>0) ){\n          /* The P3 value is too large in magnitude to be expressed as an\n          ** integer. */\n          u.az.res = 1;\n          if( pIn3->r<0 ){\n            if( u.az.oc>=OP_SeekGe ){  assert( u.az.oc==OP_SeekGe || u.az.oc==OP_SeekGt );\n              rc = sqlite3BtreeFirst(u.az.pC->pCursor, &u.az.res);\n              if( rc!=SQLITE_OK ) goto abort_due_to_error;\n            }\n          }else{\n            if( u.az.oc<=OP_SeekLe ){  assert( u.az.oc==OP_SeekLt || u.az.oc==OP_SeekLe );\n              rc = sqlite3BtreeLast(u.az.pC->pCursor, &u.az.res);\n              if( rc!=SQLITE_OK ) goto abort_due_to_error;\n            }\n          }\n          if( u.az.res ){\n            pc = pOp->p2 - 1;\n          }\n          break;\n        }else if( u.az.oc==OP_SeekLt || u.az.oc==OP_SeekGe ){\n          /* Use the ceiling() function to convert real->int */\n          if( pIn3->r > (double)u.az.iKey ) u.az.iKey++;\n        }else{\n          /* Use the floor() function to convert real->int */\n          assert( u.az.oc==OP_SeekLe || u.az.oc==OP_SeekGt );\n          if( pIn3->r < (double)u.az.iKey ) u.az.iKey--;\n        }\n      }\n      rc = sqlite3BtreeMovetoUnpacked(u.az.pC->pCursor, 0, (u64)u.az.iKey, 0, &u.az.res);\n      if( rc!=SQLITE_OK ){\n        goto abort_due_to_error;\n      }\n      if( u.az.res==0 ){\n        u.az.pC->rowidIsValid = 1;\n        u.az.pC->lastRowid = u.az.iKey;\n      }\n    }else{\n      u.az.nField = pOp->p4.i;\n      assert( pOp->p4type==P4_INT32 );\n      assert( u.az.nField>0 );\n      u.az.r.pKeyInfo = u.az.pC->pKeyInfo;\n      u.az.r.nField = (u16)u.az.nField;\n\n      /* The next line of code computes as follows, only faster:\n      **   if( u.az.oc==OP_SeekGt || u.az.oc==OP_SeekLe ){\n      **     u.az.r.flags = UNPACKED_INCRKEY;\n      **   }else{\n      **     u.az.r.flags = 0;\n      **   }\n      */\n      u.az.r.flags = (u16)(UNPACKED_INCRKEY * (1 & (u.az.oc - OP_SeekLt)));\n      assert( u.az.oc!=OP_SeekGt || u.az.r.flags==UNPACKED_INCRKEY );\n      assert( u.az.oc!=OP_SeekLe || u.az.r.flags==UNPACKED_INCRKEY );\n      assert( u.az.oc!=OP_SeekGe || u.az.r.flags==0 );\n      assert( u.az.oc!=OP_SeekLt || u.az.r.flags==0 );\n\n      u.az.r.aMem = &aMem[pOp->p3];\n#ifdef SQLITE_DEBUG\n      { int i; for(i=0; i<u.az.r.nField; i++) assert( memIsValid(&u.az.r.aMem[i]) ); }\n#endif\n      ExpandBlob(u.az.r.aMem);\n      rc = sqlite3BtreeMovetoUnpacked(u.az.pC->pCursor, &u.az.r, 0, 0, &u.az.res);\n      if( rc!=SQLITE_OK ){\n        goto abort_due_to_error;\n      }\n      u.az.pC->rowidIsValid = 0;\n    }\n    u.az.pC->deferredMoveto = 0;\n    u.az.pC->cacheStatus = CACHE_STALE;\n#ifdef SQLITE_TEST\n    sqlite3_search_count++;\n#endif\n    if( u.az.oc>=OP_SeekGe ){  assert( u.az.oc==OP_SeekGe || u.az.oc==OP_SeekGt );\n      if( u.az.res<0 || (u.az.res==0 && u.az.oc==OP_SeekGt) ){\n        rc = sqlite3BtreeNext(u.az.pC->pCursor, &u.az.res);\n        if( rc!=SQLITE_OK ) goto abort_due_to_error;\n        u.az.pC->rowidIsValid = 0;\n      }else{\n        u.az.res = 0;\n      }\n    }else{\n      assert( u.az.oc==OP_SeekLt || u.az.oc==OP_SeekLe );\n      if( u.az.res>0 || (u.az.res==0 && u.az.oc==OP_SeekLt) ){\n        rc = sqlite3BtreePrevious(u.az.pC->pCursor, &u.az.res);\n        if( rc!=SQLITE_OK ) goto abort_due_to_error;\n        u.az.pC->rowidIsValid = 0;\n      }else{\n        /* u.az.res might be negative because the table is empty.  Check to\n        ** see if this is the case.\n        */\n        u.az.res = sqlite3BtreeEof(u.az.pC->pCursor);\n      }\n    }\n    assert( pOp->p2>0 );\n    if( u.az.res ){\n      pc = pOp->p2 - 1;\n    }\n  }else{\n    /* This happens when attempting to open the sqlite3_master table\n    ** for read access returns SQLITE_EMPTY. In this case always\n    ** take the jump (since there are no records in the table).\n    */\n    pc = pOp->p2 - 1;\n  }\n  break;\n}\n\n/* Opcode: Seek P1 P2 * * *\n**\n** P1 is an open table cursor and P2 is a rowid integer.  Arrange\n** for P1 to move so that it points to the rowid given by P2.\n**\n** This is actually a deferred seek.  Nothing actually happens until\n** the cursor is used to read a record.  That way, if no reads\n** occur, no unnecessary I/O happens.\n*/\ncase OP_Seek: {    /* in2 */\n#if 0  /* local variables moved into u.ba */\n  VdbeCursor *pC;\n#endif /* local variables moved into u.ba */\n\n  assert( pOp->p1>=0 && pOp->p1<p->nCursor );\n  u.ba.pC = p->apCsr[pOp->p1];\n  assert( u.ba.pC!=0 );\n  if( ALWAYS(u.ba.pC->pCursor!=0) ){\n    assert( u.ba.pC->isTable );\n    u.ba.pC->nullRow = 0;\n    pIn2 = &aMem[pOp->p2];\n    u.ba.pC->movetoTarget = sqlite3VdbeIntValue(pIn2);\n    u.ba.pC->rowidIsValid = 0;\n    u.ba.pC->deferredMoveto = 1;\n  }\n  break;\n}\n  \n\n/* Opcode: Found P1 P2 P3 P4 *\n**\n** If P4==0 then register P3 holds a blob constructed by MakeRecord.  If\n** P4>0 then register P3 is the first of P4 registers that form an unpacked\n** record.\n**\n** Cursor P1 is on an index btree.  If the record identified by P3 and P4\n** is a prefix of any entry in P1 then a jump is made to P2 and\n** P1 is left pointing at the matching entry.\n*/\n/* Opcode: NotFound P1 P2 P3 P4 *\n**\n** If P4==0 then register P3 holds a blob constructed by MakeRecord.  If\n** P4>0 then register P3 is the first of P4 registers that form an unpacked\n** record.\n** \n** Cursor P1 is on an index btree.  If the record identified by P3 and P4\n** is not the prefix of any entry in P1 then a jump is made to P2.  If P1 \n** does contain an entry whose prefix matches the P3/P4 record then control\n** falls through to the next instruction and P1 is left pointing at the\n** matching entry.\n**\n** See also: Found, NotExists, IsUnique\n*/\ncase OP_NotFound:       /* jump, in3 */\ncase OP_Found: {        /* jump, in3 */\n#if 0  /* local variables moved into u.bb */\n  int alreadyExists;\n  VdbeCursor *pC;\n  int res;\n  UnpackedRecord *pIdxKey;\n  UnpackedRecord r;\n  char aTempRec[ROUND8(sizeof(UnpackedRecord)) + sizeof(Mem)*3 + 7];\n#endif /* local variables moved into u.bb */\n\n#ifdef SQLITE_TEST\n  sqlite3_found_count++;\n#endif\n\n  u.bb.alreadyExists = 0;\n  assert( pOp->p1>=0 && pOp->p1<p->nCursor );\n  assert( pOp->p4type==P4_INT32 );\n  u.bb.pC = p->apCsr[pOp->p1];\n  assert( u.bb.pC!=0 );\n  pIn3 = &aMem[pOp->p3];\n  if( ALWAYS(u.bb.pC->pCursor!=0) ){\n\n    assert( u.bb.pC->isTable==0 );\n    if( pOp->p4.i>0 ){\n      u.bb.r.pKeyInfo = u.bb.pC->pKeyInfo;\n      u.bb.r.nField = (u16)pOp->p4.i;\n      u.bb.r.aMem = pIn3;\n#ifdef SQLITE_DEBUG\n      { int i; for(i=0; i<u.bb.r.nField; i++) assert( memIsValid(&u.bb.r.aMem[i]) ); }\n#endif\n      u.bb.r.flags = UNPACKED_PREFIX_MATCH;\n      u.bb.pIdxKey = &u.bb.r;\n    }else{\n      assert( pIn3->flags & MEM_Blob );\n      assert( (pIn3->flags & MEM_Zero)==0 );  /* zeroblobs already expanded */\n      u.bb.pIdxKey = sqlite3VdbeRecordUnpack(u.bb.pC->pKeyInfo, pIn3->n, pIn3->z,\n                                        u.bb.aTempRec, sizeof(u.bb.aTempRec));\n      if( u.bb.pIdxKey==0 ){\n        goto no_mem;\n      }\n      u.bb.pIdxKey->flags |= UNPACKED_PREFIX_MATCH;\n    }\n    rc = sqlite3BtreeMovetoUnpacked(u.bb.pC->pCursor, u.bb.pIdxKey, 0, 0, &u.bb.res);\n    if( pOp->p4.i==0 ){\n      sqlite3VdbeDeleteUnpackedRecord(u.bb.pIdxKey);\n    }\n    if( rc!=SQLITE_OK ){\n      break;\n    }\n    u.bb.alreadyExists = (u.bb.res==0);\n    u.bb.pC->deferredMoveto = 0;\n    u.bb.pC->cacheStatus = CACHE_STALE;\n  }\n  if( pOp->opcode==OP_Found ){\n    if( u.bb.alreadyExists ) pc = pOp->p2 - 1;\n  }else{\n    if( !u.bb.alreadyExists ) pc = pOp->p2 - 1;\n  }\n  break;\n}\n\n/* Opcode: IsUnique P1 P2 P3 P4 *\n**\n** Cursor P1 is open on an index b-tree - that is to say, a btree which\n** no data and where the key are records generated by OP_MakeRecord with\n** the list field being the integer ROWID of the entry that the index\n** entry refers to.\n**\n** The P3 register contains an integer record number. Call this record \n** number R. Register P4 is the first in a set of N contiguous registers\n** that make up an unpacked index key that can be used with cursor P1.\n** The value of N can be inferred from the cursor. N includes the rowid\n** value appended to the end of the index record. This rowid value may\n** or may not be the same as R.\n**\n** If any of the N registers beginning with register P4 contains a NULL\n** value, jump immediately to P2.\n**\n** Otherwise, this instruction checks if cursor P1 contains an entry\n** where the first (N-1) fields match but the rowid value at the end\n** of the index entry is not R. If there is no such entry, control jumps\n** to instruction P2. Otherwise, the rowid of the conflicting index\n** entry is copied to register P3 and control falls through to the next\n** instruction.\n**\n** See also: NotFound, NotExists, Found\n*/\ncase OP_IsUnique: {        /* jump, in3 */\n#if 0  /* local variables moved into u.bc */\n  u16 ii;\n  VdbeCursor *pCx;\n  BtCursor *pCrsr;\n  u16 nField;\n  Mem *aMx;\n  UnpackedRecord r;                  /* B-Tree index search key */\n  i64 R;                             /* Rowid stored in register P3 */\n#endif /* local variables moved into u.bc */\n\n  pIn3 = &aMem[pOp->p3];\n  u.bc.aMx = &aMem[pOp->p4.i];\n  /* Assert that the values of parameters P1 and P4 are in range. */\n  assert( pOp->p4type==P4_INT32 );\n  assert( pOp->p4.i>0 && pOp->p4.i<=p->nMem );\n  assert( pOp->p1>=0 && pOp->p1<p->nCursor );\n\n  /* Find the index cursor. */\n  u.bc.pCx = p->apCsr[pOp->p1];\n  assert( u.bc.pCx->deferredMoveto==0 );\n  u.bc.pCx->seekResult = 0;\n  u.bc.pCx->cacheStatus = CACHE_STALE;\n  u.bc.pCrsr = u.bc.pCx->pCursor;\n\n  /* If any of the values are NULL, take the jump. */\n  u.bc.nField = u.bc.pCx->pKeyInfo->nField;\n  for(u.bc.ii=0; u.bc.ii<u.bc.nField; u.bc.ii++){\n    if( u.bc.aMx[u.bc.ii].flags & MEM_Null ){\n      pc = pOp->p2 - 1;\n      u.bc.pCrsr = 0;\n      break;\n    }\n  }\n  assert( (u.bc.aMx[u.bc.nField].flags & MEM_Null)==0 );\n\n  if( u.bc.pCrsr!=0 ){\n    /* Populate the index search key. */\n    u.bc.r.pKeyInfo = u.bc.pCx->pKeyInfo;\n    u.bc.r.nField = u.bc.nField + 1;\n    u.bc.r.flags = UNPACKED_PREFIX_SEARCH;\n    u.bc.r.aMem = u.bc.aMx;\n#ifdef SQLITE_DEBUG\n    { int i; for(i=0; i<u.bc.r.nField; i++) assert( memIsValid(&u.bc.r.aMem[i]) ); }\n#endif\n\n    /* Extract the value of u.bc.R from register P3. */\n    sqlite3VdbeMemIntegerify(pIn3);\n    u.bc.R = pIn3->u.i;\n\n    /* Search the B-Tree index. If no conflicting record is found, jump\n    ** to P2. Otherwise, copy the rowid of the conflicting record to\n    ** register P3 and fall through to the next instruction.  */\n    rc = sqlite3BtreeMovetoUnpacked(u.bc.pCrsr, &u.bc.r, 0, 0, &u.bc.pCx->seekResult);\n    if( (u.bc.r.flags & UNPACKED_PREFIX_SEARCH) || u.bc.r.rowid==u.bc.R ){\n      pc = pOp->p2 - 1;\n    }else{\n      pIn3->u.i = u.bc.r.rowid;\n    }\n  }\n  break;\n}\n\n/* Opcode: NotExists P1 P2 P3 * *\n**\n** Use the content of register P3 as a integer key.  If a record \n** with that key does not exist in table of P1, then jump to P2. \n** If the record does exist, then fall through.  The cursor is left \n** pointing to the record if it exists.\n**\n** The difference between this operation and NotFound is that this\n** operation assumes the key is an integer and that P1 is a table whereas\n** NotFound assumes key is a blob constructed from MakeRecord and\n** P1 is an index.\n**\n** See also: Found, NotFound, IsUnique\n*/\ncase OP_NotExists: {        /* jump, in3 */\n#if 0  /* local variables moved into u.bd */\n  VdbeCursor *pC;\n  BtCursor *pCrsr;\n  int res;\n  u64 iKey;\n#endif /* local variables moved into u.bd */\n\n  pIn3 = &aMem[pOp->p3];\n  assert( pIn3->flags & MEM_Int );\n  assert( pOp->p1>=0 && pOp->p1<p->nCursor );\n  u.bd.pC = p->apCsr[pOp->p1];\n  assert( u.bd.pC!=0 );\n  assert( u.bd.pC->isTable );\n  assert( u.bd.pC->pseudoTableReg==0 );\n  u.bd.pCrsr = u.bd.pC->pCursor;\n  if( u.bd.pCrsr!=0 ){\n    u.bd.res = 0;\n    u.bd.iKey = pIn3->u.i;\n    rc = sqlite3BtreeMovetoUnpacked(u.bd.pCrsr, 0, u.bd.iKey, 0, &u.bd.res);\n    u.bd.pC->lastRowid = pIn3->u.i;\n    u.bd.pC->rowidIsValid = u.bd.res==0 ?1:0;\n    u.bd.pC->nullRow = 0;\n    u.bd.pC->cacheStatus = CACHE_STALE;\n    u.bd.pC->deferredMoveto = 0;\n    if( u.bd.res!=0 ){\n      pc = pOp->p2 - 1;\n      assert( u.bd.pC->rowidIsValid==0 );\n    }\n    u.bd.pC->seekResult = u.bd.res;\n  }else{\n    /* This happens when an attempt to open a read cursor on the\n    ** sqlite_master table returns SQLITE_EMPTY.\n    */\n    pc = pOp->p2 - 1;\n    assert( u.bd.pC->rowidIsValid==0 );\n    u.bd.pC->seekResult = 0;\n  }\n  break;\n}\n\n/* Opcode: Sequence P1 P2 * * *\n**\n** Find the next available sequence number for cursor P1.\n** Write the sequence number into register P2.\n** The sequence number on the cursor is incremented after this\n** instruction.  \n*/\ncase OP_Sequence: {           /* out2-prerelease */\n  assert( pOp->p1>=0 && pOp->p1<p->nCursor );\n  assert( p->apCsr[pOp->p1]!=0 );\n  pOut->u.i = p->apCsr[pOp->p1]->seqCount++;\n  break;\n}\n\n\n/* Opcode: NewRowid P1 P2 P3 * *\n**\n** Get a new integer record number (a.k.a \"rowid\") used as the key to a table.\n** The record number is not previously used as a key in the database\n** table that cursor P1 points to.  The new record number is written\n** written to register P2.\n**\n** If P3>0 then P3 is a register in the root frame of this VDBE that holds \n** the largest previously generated record number. No new record numbers are\n** allowed to be less than this value. When this value reaches its maximum, \n** a SQLITE_FULL error is generated. The P3 register is updated with the '\n** generated record number. This P3 mechanism is used to help implement the\n** AUTOINCREMENT feature.\n*/\ncase OP_NewRowid: {           /* out2-prerelease */\n#if 0  /* local variables moved into u.be */\n  i64 v;                 /* The new rowid */\n  VdbeCursor *pC;        /* Cursor of table to get the new rowid */\n  int res;               /* Result of an sqlite3BtreeLast() */\n  int cnt;               /* Counter to limit the number of searches */\n  Mem *pMem;             /* Register holding largest rowid for AUTOINCREMENT */\n  VdbeFrame *pFrame;     /* Root frame of VDBE */\n#endif /* local variables moved into u.be */\n\n  u.be.v = 0;\n  u.be.res = 0;\n  assert( pOp->p1>=0 && pOp->p1<p->nCursor );\n  u.be.pC = p->apCsr[pOp->p1];\n  assert( u.be.pC!=0 );\n  if( NEVER(u.be.pC->pCursor==0) ){\n    /* The zero initialization above is all that is needed */\n  }else{\n    /* The next rowid or record number (different terms for the same\n    ** thing) is obtained in a two-step algorithm.\n    **\n    ** First we attempt to find the largest existing rowid and add one\n    ** to that.  But if the largest existing rowid is already the maximum\n    ** positive integer, we have to fall through to the second\n    ** probabilistic algorithm\n    **\n    ** The second algorithm is to select a rowid at random and see if\n    ** it already exists in the table.  If it does not exist, we have\n    ** succeeded.  If the random rowid does exist, we select a new one\n    ** and try again, up to 100 times.\n    */\n    assert( u.be.pC->isTable );\n\n#ifdef SQLITE_32BIT_ROWID\n#   define MAX_ROWID 0x7fffffff\n#else\n    /* Some compilers complain about constants of the form 0x7fffffffffffffff.\n    ** Others complain about 0x7ffffffffffffffffLL.  The following macro seems\n    ** to provide the constant while making all compilers happy.\n    */\n#   define MAX_ROWID  (i64)( (((u64)0x7fffffff)<<32) | (u64)0xffffffff )\n#endif\n\n    if( !u.be.pC->useRandomRowid ){\n      u.be.v = sqlite3BtreeGetCachedRowid(u.be.pC->pCursor);\n      if( u.be.v==0 ){\n        rc = sqlite3BtreeLast(u.be.pC->pCursor, &u.be.res);\n        if( rc!=SQLITE_OK ){\n          goto abort_due_to_error;\n        }\n        if( u.be.res ){\n          u.be.v = 1;   /* IMP: R-61914-48074 */\n        }else{\n          assert( sqlite3BtreeCursorIsValid(u.be.pC->pCursor) );\n          rc = sqlite3BtreeKeySize(u.be.pC->pCursor, &u.be.v);\n          assert( rc==SQLITE_OK );   /* Cannot fail following BtreeLast() */\n          if( u.be.v==MAX_ROWID ){\n            u.be.pC->useRandomRowid = 1;\n          }else{\n            u.be.v++;   /* IMP: R-29538-34987 */\n          }\n        }\n      }\n\n#ifndef SQLITE_OMIT_AUTOINCREMENT\n      if( pOp->p3 ){\n        /* Assert that P3 is a valid memory cell. */\n        assert( pOp->p3>0 );\n        if( p->pFrame ){\n          for(u.be.pFrame=p->pFrame; u.be.pFrame->pParent; u.be.pFrame=u.be.pFrame->pParent);\n          /* Assert that P3 is a valid memory cell. */\n          assert( pOp->p3<=u.be.pFrame->nMem );\n          u.be.pMem = &u.be.pFrame->aMem[pOp->p3];\n        }else{\n          /* Assert that P3 is a valid memory cell. */\n          assert( pOp->p3<=p->nMem );\n          u.be.pMem = &aMem[pOp->p3];\n          memAboutToChange(p, u.be.pMem);\n        }\n        assert( memIsValid(u.be.pMem) );\n\n        REGISTER_TRACE(pOp->p3, u.be.pMem);\n        sqlite3VdbeMemIntegerify(u.be.pMem);\n        assert( (u.be.pMem->flags & MEM_Int)!=0 );  /* mem(P3) holds an integer */\n        if( u.be.pMem->u.i==MAX_ROWID || u.be.pC->useRandomRowid ){\n          rc = SQLITE_FULL;   /* IMP: R-12275-61338 */\n          goto abort_due_to_error;\n        }\n        if( u.be.v<u.be.pMem->u.i+1 ){\n          u.be.v = u.be.pMem->u.i + 1;\n        }\n        u.be.pMem->u.i = u.be.v;\n      }\n#endif\n\n      sqlite3BtreeSetCachedRowid(u.be.pC->pCursor, u.be.v<MAX_ROWID ? u.be.v+1 : 0);\n    }\n    if( u.be.pC->useRandomRowid ){\n      /* IMPLEMENTATION-OF: R-07677-41881 If the largest ROWID is equal to the\n      ** largest possible integer (9223372036854775807) then the database\n      ** engine starts picking positive candidate ROWIDs at random until\n      ** it finds one that is not previously used. */\n      assert( pOp->p3==0 );  /* We cannot be in random rowid mode if this is\n                             ** an AUTOINCREMENT table. */\n      /* on the first attempt, simply do one more than previous */\n      u.be.v = db->lastRowid;\n      u.be.v &= (MAX_ROWID>>1); /* ensure doesn't go negative */\n      u.be.v++; /* ensure non-zero */\n      u.be.cnt = 0;\n      while(   ((rc = sqlite3BtreeMovetoUnpacked(u.be.pC->pCursor, 0, (u64)u.be.v,\n                                                 0, &u.be.res))==SQLITE_OK)\n            && (u.be.res==0)\n            && (++u.be.cnt<100)){\n        /* collision - try another random rowid */\n        sqlite3_randomness(sizeof(u.be.v), &u.be.v);\n        if( u.be.cnt<5 ){\n          /* try \"small\" random rowids for the initial attempts */\n          u.be.v &= 0xffffff;\n        }else{\n          u.be.v &= (MAX_ROWID>>1); /* ensure doesn't go negative */\n        }\n        u.be.v++; /* ensure non-zero */\n      }\n      if( rc==SQLITE_OK && u.be.res==0 ){\n        rc = SQLITE_FULL;   /* IMP: R-38219-53002 */\n        goto abort_due_to_error;\n      }\n      assert( u.be.v>0 );  /* EV: R-40812-03570 */\n    }\n    u.be.pC->rowidIsValid = 0;\n    u.be.pC->deferredMoveto = 0;\n    u.be.pC->cacheStatus = CACHE_STALE;\n  }\n  pOut->u.i = u.be.v;\n  break;\n}\n\n/* Opcode: Insert P1 P2 P3 P4 P5\n**\n** Write an entry into the table of cursor P1.  A new entry is\n** created if it doesn't already exist or the data for an existing\n** entry is overwritten.  The data is the value MEM_Blob stored in register\n** number P2. The key is stored in register P3. The key must\n** be a MEM_Int.\n**\n** If the OPFLAG_NCHANGE flag of P5 is set, then the row change count is\n** incremented (otherwise not).  If the OPFLAG_LASTROWID flag of P5 is set,\n** then rowid is stored for subsequent return by the\n** sqlite3_last_insert_rowid() function (otherwise it is unmodified).\n**\n** If the OPFLAG_USESEEKRESULT flag of P5 is set and if the result of\n** the last seek operation (OP_NotExists) was a success, then this\n** operation will not attempt to find the appropriate row before doing\n** the insert but will instead overwrite the row that the cursor is\n** currently pointing to.  Presumably, the prior OP_NotExists opcode\n** has already positioned the cursor correctly.  This is an optimization\n** that boosts performance by avoiding redundant seeks.\n**\n** If the OPFLAG_ISUPDATE flag is set, then this opcode is part of an\n** UPDATE operation.  Otherwise (if the flag is clear) then this opcode\n** is part of an INSERT operation.  The difference is only important to\n** the update hook.\n**\n** Parameter P4 may point to a string containing the table-name, or\n** may be NULL. If it is not NULL, then the update-hook \n** (sqlite3.xUpdateCallback) is invoked following a successful insert.\n**\n** (WARNING/TODO: If P1 is a pseudo-cursor and P2 is dynamically\n** allocated, then ownership of P2 is transferred to the pseudo-cursor\n** and register P2 becomes ephemeral.  If the cursor is changed, the\n** value of register P2 will then change.  Make sure this does not\n** cause any problems.)\n**\n** This instruction only works on tables.  The equivalent instruction\n** for indices is OP_IdxInsert.\n*/\n/* Opcode: InsertInt P1 P2 P3 P4 P5\n**\n** This works exactly like OP_Insert except that the key is the\n** integer value P3, not the value of the integer stored in register P3.\n*/\ncase OP_Insert: \ncase OP_InsertInt: {\n#if 0  /* local variables moved into u.bf */\n  Mem *pData;       /* MEM cell holding data for the record to be inserted */\n  Mem *pKey;        /* MEM cell holding key  for the record */\n  i64 iKey;         /* The integer ROWID or key for the record to be inserted */\n  VdbeCursor *pC;   /* Cursor to table into which insert is written */\n  int nZero;        /* Number of zero-bytes to append */\n  int seekResult;   /* Result of prior seek or 0 if no USESEEKRESULT flag */\n  const char *zDb;  /* database name - used by the update hook */\n  const char *zTbl; /* Table name - used by the opdate hook */\n  int op;           /* Opcode for update hook: SQLITE_UPDATE or SQLITE_INSERT */\n#endif /* local variables moved into u.bf */\n\n  u.bf.pData = &aMem[pOp->p2];\n  assert( pOp->p1>=0 && pOp->p1<p->nCursor );\n  assert( memIsValid(u.bf.pData) );\n  u.bf.pC = p->apCsr[pOp->p1];\n  assert( u.bf.pC!=0 );\n  assert( u.bf.pC->pCursor!=0 );\n  assert( u.bf.pC->pseudoTableReg==0 );\n  assert( u.bf.pC->isTable );\n  REGISTER_TRACE(pOp->p2, u.bf.pData);\n\n  if( pOp->opcode==OP_Insert ){\n    u.bf.pKey = &aMem[pOp->p3];\n    assert( u.bf.pKey->flags & MEM_Int );\n    assert( memIsValid(u.bf.pKey) );\n    REGISTER_TRACE(pOp->p3, u.bf.pKey);\n    u.bf.iKey = u.bf.pKey->u.i;\n  }else{\n    assert( pOp->opcode==OP_InsertInt );\n    u.bf.iKey = pOp->p3;\n  }\n\n  if( pOp->p5 & OPFLAG_NCHANGE ) p->nChange++;\n  if( pOp->p5 & OPFLAG_LASTROWID ) db->lastRowid = u.bf.iKey;\n  if( u.bf.pData->flags & MEM_Null ){\n    u.bf.pData->z = 0;\n    u.bf.pData->n = 0;\n  }else{\n    assert( u.bf.pData->flags & (MEM_Blob|MEM_Str) );\n  }\n  u.bf.seekResult = ((pOp->p5 & OPFLAG_USESEEKRESULT) ? u.bf.pC->seekResult : 0);\n  if( u.bf.pData->flags & MEM_Zero ){\n    u.bf.nZero = u.bf.pData->u.nZero;\n  }else{\n    u.bf.nZero = 0;\n  }\n  sqlite3BtreeSetCachedRowid(u.bf.pC->pCursor, 0);\n  rc = sqlite3BtreeInsert(u.bf.pC->pCursor, 0, u.bf.iKey,\n                          u.bf.pData->z, u.bf.pData->n, u.bf.nZero,\n                          pOp->p5 & OPFLAG_APPEND, u.bf.seekResult\n  );\n  u.bf.pC->rowidIsValid = 0;\n  u.bf.pC->deferredMoveto = 0;\n  u.bf.pC->cacheStatus = CACHE_STALE;\n\n  /* Invoke the update-hook if required. */\n  if( rc==SQLITE_OK && db->xUpdateCallback && pOp->p4.z ){\n    u.bf.zDb = db->aDb[u.bf.pC->iDb].zName;\n    u.bf.zTbl = pOp->p4.z;\n    u.bf.op = ((pOp->p5 & OPFLAG_ISUPDATE) ? SQLITE_UPDATE : SQLITE_INSERT);\n    assert( u.bf.pC->isTable );\n    db->xUpdateCallback(db->pUpdateArg, u.bf.op, u.bf.zDb, u.bf.zTbl, u.bf.iKey);\n    assert( u.bf.pC->iDb>=0 );\n  }\n  break;\n}\n\n/* Opcode: Delete P1 P2 * P4 *\n**\n** Delete the record at which the P1 cursor is currently pointing.\n**\n** The cursor will be left pointing at either the next or the previous\n** record in the table. If it is left pointing at the next record, then\n** the next Next instruction will be a no-op.  Hence it is OK to delete\n** a record from within an Next loop.\n**\n** If the OPFLAG_NCHANGE flag of P2 is set, then the row change count is\n** incremented (otherwise not).\n**\n** P1 must not be pseudo-table.  It has to be a real table with\n** multiple rows.\n**\n** If P4 is not NULL, then it is the name of the table that P1 is\n** pointing to.  The update hook will be invoked, if it exists.\n** If P4 is not NULL then the P1 cursor must have been positioned\n** using OP_NotFound prior to invoking this opcode.\n*/\ncase OP_Delete: {\n#if 0  /* local variables moved into u.bg */\n  i64 iKey;\n  VdbeCursor *pC;\n#endif /* local variables moved into u.bg */\n\n  u.bg.iKey = 0;\n  assert( pOp->p1>=0 && pOp->p1<p->nCursor );\n  u.bg.pC = p->apCsr[pOp->p1];\n  assert( u.bg.pC!=0 );\n  assert( u.bg.pC->pCursor!=0 );  /* Only valid for real tables, no pseudotables */\n\n  /* If the update-hook will be invoked, set u.bg.iKey to the rowid of the\n  ** row being deleted.\n  */\n  if( db->xUpdateCallback && pOp->p4.z ){\n    assert( u.bg.pC->isTable );\n    assert( u.bg.pC->rowidIsValid );  /* lastRowid set by previous OP_NotFound */\n    u.bg.iKey = u.bg.pC->lastRowid;\n  }\n\n  /* The OP_Delete opcode always follows an OP_NotExists or OP_Last or\n  ** OP_Column on the same table without any intervening operations that\n  ** might move or invalidate the cursor.  Hence cursor u.bg.pC is always pointing\n  ** to the row to be deleted and the sqlite3VdbeCursorMoveto() operation\n  ** below is always a no-op and cannot fail.  We will run it anyhow, though,\n  ** to guard against future changes to the code generator.\n  **/\n  assert( u.bg.pC->deferredMoveto==0 );\n  rc = sqlite3VdbeCursorMoveto(u.bg.pC);\n  if( NEVER(rc!=SQLITE_OK) ) goto abort_due_to_error;\n\n  sqlite3BtreeSetCachedRowid(u.bg.pC->pCursor, 0);\n  rc = sqlite3BtreeDelete(u.bg.pC->pCursor);\n  u.bg.pC->cacheStatus = CACHE_STALE;\n\n  /* Invoke the update-hook if required. */\n  if( rc==SQLITE_OK && db->xUpdateCallback && pOp->p4.z ){\n    const char *zDb = db->aDb[u.bg.pC->iDb].zName;\n    const char *zTbl = pOp->p4.z;\n    db->xUpdateCallback(db->pUpdateArg, SQLITE_DELETE, zDb, zTbl, u.bg.iKey);\n    assert( u.bg.pC->iDb>=0 );\n  }\n  if( pOp->p2 & OPFLAG_NCHANGE ) p->nChange++;\n  break;\n}\n/* Opcode: ResetCount * * * * *\n**\n** The value of the change counter is copied to the database handle\n** change counter (returned by subsequent calls to sqlite3_changes()).\n** Then the VMs internal change counter resets to 0.\n** This is used by trigger programs.\n*/\ncase OP_ResetCount: {\n  sqlite3VdbeSetChanges(db, p->nChange);\n  p->nChange = 0;\n  break;\n}\n\n/* Opcode: RowData P1 P2 * * *\n**\n** Write into register P2 the complete row data for cursor P1.\n** There is no interpretation of the data.  \n** It is just copied onto the P2 register exactly as \n** it is found in the database file.\n**\n** If the P1 cursor must be pointing to a valid row (not a NULL row)\n** of a real table, not a pseudo-table.\n*/\n/* Opcode: RowKey P1 P2 * * *\n**\n** Write into register P2 the complete row key for cursor P1.\n** There is no interpretation of the data.  \n** The key is copied onto the P3 register exactly as \n** it is found in the database file.\n**\n** If the P1 cursor must be pointing to a valid row (not a NULL row)\n** of a real table, not a pseudo-table.\n*/\ncase OP_RowKey:\ncase OP_RowData: {\n#if 0  /* local variables moved into u.bh */\n  VdbeCursor *pC;\n  BtCursor *pCrsr;\n  u32 n;\n  i64 n64;\n#endif /* local variables moved into u.bh */\n\n  pOut = &aMem[pOp->p2];\n  memAboutToChange(p, pOut);\n\n  /* Note that RowKey and RowData are really exactly the same instruction */\n  assert( pOp->p1>=0 && pOp->p1<p->nCursor );\n  u.bh.pC = p->apCsr[pOp->p1];\n  assert( u.bh.pC->isTable || pOp->opcode==OP_RowKey );\n  assert( u.bh.pC->isIndex || pOp->opcode==OP_RowData );\n  assert( u.bh.pC!=0 );\n  assert( u.bh.pC->nullRow==0 );\n  assert( u.bh.pC->pseudoTableReg==0 );\n  assert( u.bh.pC->pCursor!=0 );\n  u.bh.pCrsr = u.bh.pC->pCursor;\n  assert( sqlite3BtreeCursorIsValid(u.bh.pCrsr) );\n\n  /* The OP_RowKey and OP_RowData opcodes always follow OP_NotExists or\n  ** OP_Rewind/Op_Next with no intervening instructions that might invalidate\n  ** the cursor.  Hence the following sqlite3VdbeCursorMoveto() call is always\n  ** a no-op and can never fail.  But we leave it in place as a safety.\n  */\n  assert( u.bh.pC->deferredMoveto==0 );\n  rc = sqlite3VdbeCursorMoveto(u.bh.pC);\n  if( NEVER(rc!=SQLITE_OK) ) goto abort_due_to_error;\n\n  if( u.bh.pC->isIndex ){\n    assert( !u.bh.pC->isTable );\n    rc = sqlite3BtreeKeySize(u.bh.pCrsr, &u.bh.n64);\n    assert( rc==SQLITE_OK );    /* True because of CursorMoveto() call above */\n    if( u.bh.n64>db->aLimit[SQLITE_LIMIT_LENGTH] ){\n      goto too_big;\n    }\n    u.bh.n = (u32)u.bh.n64;\n  }else{\n    rc = sqlite3BtreeDataSize(u.bh.pCrsr, &u.bh.n);\n    assert( rc==SQLITE_OK );    /* DataSize() cannot fail */\n    if( u.bh.n>(u32)db->aLimit[SQLITE_LIMIT_LENGTH] ){\n      goto too_big;\n    }\n  }\n  if( sqlite3VdbeMemGrow(pOut, u.bh.n, 0) ){\n    goto no_mem;\n  }\n  pOut->n = u.bh.n;\n  MemSetTypeFlag(pOut, MEM_Blob);\n  if( u.bh.pC->isIndex ){\n    rc = sqlite3BtreeKey(u.bh.pCrsr, 0, u.bh.n, pOut->z);\n  }else{\n    rc = sqlite3BtreeData(u.bh.pCrsr, 0, u.bh.n, pOut->z);\n  }\n  pOut->enc = SQLITE_UTF8;  /* In case the blob is ever cast to text */\n  UPDATE_MAX_BLOBSIZE(pOut);\n  break;\n}\n\n/* Opcode: Rowid P1 P2 * * *\n**\n** Store in register P2 an integer which is the key of the table entry that\n** P1 is currently point to.\n**\n** P1 can be either an ordinary table or a virtual table.  There used to\n** be a separate OP_VRowid opcode for use with virtual tables, but this\n** one opcode now works for both table types.\n*/\ncase OP_Rowid: {                 /* out2-prerelease */\n#if 0  /* local variables moved into u.bi */\n  VdbeCursor *pC;\n  i64 v;\n  sqlite3_vtab *pVtab;\n  const sqlite3_module *pModule;\n#endif /* local variables moved into u.bi */\n\n  assert( pOp->p1>=0 && pOp->p1<p->nCursor );\n  u.bi.pC = p->apCsr[pOp->p1];\n  assert( u.bi.pC!=0 );\n  assert( u.bi.pC->pseudoTableReg==0 );\n  if( u.bi.pC->nullRow ){\n    pOut->flags = MEM_Null;\n    break;\n  }else if( u.bi.pC->deferredMoveto ){\n    u.bi.v = u.bi.pC->movetoTarget;\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  }else if( u.bi.pC->pVtabCursor ){\n    u.bi.pVtab = u.bi.pC->pVtabCursor->pVtab;\n    u.bi.pModule = u.bi.pVtab->pModule;\n    assert( u.bi.pModule->xRowid );\n    rc = u.bi.pModule->xRowid(u.bi.pC->pVtabCursor, &u.bi.v);\n    importVtabErrMsg(p, u.bi.pVtab);\n#endif /* SQLITE_OMIT_VIRTUALTABLE */\n  }else{\n    assert( u.bi.pC->pCursor!=0 );\n    rc = sqlite3VdbeCursorMoveto(u.bi.pC);\n    if( rc ) goto abort_due_to_error;\n    if( u.bi.pC->rowidIsValid ){\n      u.bi.v = u.bi.pC->lastRowid;\n    }else{\n      rc = sqlite3BtreeKeySize(u.bi.pC->pCursor, &u.bi.v);\n      assert( rc==SQLITE_OK );  /* Always so because of CursorMoveto() above */\n    }\n  }\n  pOut->u.i = u.bi.v;\n  break;\n}\n\n/* Opcode: NullRow P1 * * * *\n**\n** Move the cursor P1 to a null row.  Any OP_Column operations\n** that occur while the cursor is on the null row will always\n** write a NULL.\n*/\ncase OP_NullRow: {\n#if 0  /* local variables moved into u.bj */\n  VdbeCursor *pC;\n#endif /* local variables moved into u.bj */\n\n  assert( pOp->p1>=0 && pOp->p1<p->nCursor );\n  u.bj.pC = p->apCsr[pOp->p1];\n  assert( u.bj.pC!=0 );\n  u.bj.pC->nullRow = 1;\n  u.bj.pC->rowidIsValid = 0;\n  if( u.bj.pC->pCursor ){\n    sqlite3BtreeClearCursor(u.bj.pC->pCursor);\n  }\n  break;\n}\n\n/* Opcode: Last P1 P2 * * *\n**\n** The next use of the Rowid or Column or Next instruction for P1 \n** will refer to the last entry in the database table or index.\n** If the table or index is empty and P2>0, then jump immediately to P2.\n** If P2 is 0 or if the table or index is not empty, fall through\n** to the following instruction.\n*/\ncase OP_Last: {        /* jump */\n#if 0  /* local variables moved into u.bk */\n  VdbeCursor *pC;\n  BtCursor *pCrsr;\n  int res;\n#endif /* local variables moved into u.bk */\n\n  assert( pOp->p1>=0 && pOp->p1<p->nCursor );\n  u.bk.pC = p->apCsr[pOp->p1];\n  assert( u.bk.pC!=0 );\n  u.bk.pCrsr = u.bk.pC->pCursor;\n  if( u.bk.pCrsr==0 ){\n    u.bk.res = 1;\n  }else{\n    rc = sqlite3BtreeLast(u.bk.pCrsr, &u.bk.res);\n  }\n  u.bk.pC->nullRow = (u8)u.bk.res;\n  u.bk.pC->deferredMoveto = 0;\n  u.bk.pC->rowidIsValid = 0;\n  u.bk.pC->cacheStatus = CACHE_STALE;\n  if( pOp->p2>0 && u.bk.res ){\n    pc = pOp->p2 - 1;\n  }\n  break;\n}\n\n\n/* Opcode: Sort P1 P2 * * *\n**\n** This opcode does exactly the same thing as OP_Rewind except that\n** it increments an undocumented global variable used for testing.\n**\n** Sorting is accomplished by writing records into a sorting index,\n** then rewinding that index and playing it back from beginning to\n** end.  We use the OP_Sort opcode instead of OP_Rewind to do the\n** rewinding so that the global variable will be incremented and\n** regression tests can determine whether or not the optimizer is\n** correctly optimizing out sorts.\n*/\ncase OP_Sort: {        /* jump */\n#ifdef SQLITE_TEST\n  sqlite3_sort_count++;\n  sqlite3_search_count--;\n#endif\n  p->aCounter[SQLITE_STMTSTATUS_SORT-1]++;\n  /* Fall through into OP_Rewind */\n}\n/* Opcode: Rewind P1 P2 * * *\n**\n** The next use of the Rowid or Column or Next instruction for P1 \n** will refer to the first entry in the database table or index.\n** If the table or index is empty and P2>0, then jump immediately to P2.\n** If P2 is 0 or if the table or index is not empty, fall through\n** to the following instruction.\n*/\ncase OP_Rewind: {        /* jump */\n#if 0  /* local variables moved into u.bl */\n  VdbeCursor *pC;\n  BtCursor *pCrsr;\n  int res;\n#endif /* local variables moved into u.bl */\n\n  assert( pOp->p1>=0 && pOp->p1<p->nCursor );\n  u.bl.pC = p->apCsr[pOp->p1];\n  assert( u.bl.pC!=0 );\n  u.bl.res = 1;\n  if( (u.bl.pCrsr = u.bl.pC->pCursor)!=0 ){\n    rc = sqlite3BtreeFirst(u.bl.pCrsr, &u.bl.res);\n    u.bl.pC->atFirst = u.bl.res==0 ?1:0;\n    u.bl.pC->deferredMoveto = 0;\n    u.bl.pC->cacheStatus = CACHE_STALE;\n    u.bl.pC->rowidIsValid = 0;\n  }\n  u.bl.pC->nullRow = (u8)u.bl.res;\n  assert( pOp->p2>0 && pOp->p2<p->nOp );\n  if( u.bl.res ){\n    pc = pOp->p2 - 1;\n  }\n  break;\n}\n\n/* Opcode: Next P1 P2 * * P5\n**\n** Advance cursor P1 so that it points to the next key/data pair in its\n** table or index.  If there are no more key/value pairs then fall through\n** to the following instruction.  But if the cursor advance was successful,\n** jump immediately to P2.\n**\n** The P1 cursor must be for a real table, not a pseudo-table.\n**\n** If P5 is positive and the jump is taken, then event counter\n** number P5-1 in the prepared statement is incremented.\n**\n** See also: Prev\n*/\n/* Opcode: Prev P1 P2 * * P5\n**\n** Back up cursor P1 so that it points to the previous key/data pair in its\n** table or index.  If there is no previous key/value pairs then fall through\n** to the following instruction.  But if the cursor backup was successful,\n** jump immediately to P2.\n**\n** The P1 cursor must be for a real table, not a pseudo-table.\n**\n** If P5 is positive and the jump is taken, then event counter\n** number P5-1 in the prepared statement is incremented.\n*/\ncase OP_Prev:          /* jump */\ncase OP_Next: {        /* jump */\n#if 0  /* local variables moved into u.bm */\n  VdbeCursor *pC;\n  BtCursor *pCrsr;\n  int res;\n#endif /* local variables moved into u.bm */\n\n  CHECK_FOR_INTERRUPT;\n  assert( pOp->p1>=0 && pOp->p1<p->nCursor );\n  assert( pOp->p5<=ArraySize(p->aCounter) );\n  u.bm.pC = p->apCsr[pOp->p1];\n  if( u.bm.pC==0 ){\n    break;  /* See ticket #2273 */\n  }\n  u.bm.pCrsr = u.bm.pC->pCursor;\n  if( u.bm.pCrsr==0 ){\n    u.bm.pC->nullRow = 1;\n    break;\n  }\n  u.bm.res = 1;\n  assert( u.bm.pC->deferredMoveto==0 );\n  rc = pOp->opcode==OP_Next ? sqlite3BtreeNext(u.bm.pCrsr, &u.bm.res) :\n                              sqlite3BtreePrevious(u.bm.pCrsr, &u.bm.res);\n  u.bm.pC->nullRow = (u8)u.bm.res;\n  u.bm.pC->cacheStatus = CACHE_STALE;\n  if( u.bm.res==0 ){\n    pc = pOp->p2 - 1;\n    if( pOp->p5 ) p->aCounter[pOp->p5-1]++;\n#ifdef SQLITE_TEST\n    sqlite3_search_count++;\n#endif\n  }\n  u.bm.pC->rowidIsValid = 0;\n  break;\n}\n\n/* Opcode: IdxInsert P1 P2 P3 * P5\n**\n** Register P2 holds a SQL index key made using the\n** MakeRecord instructions.  This opcode writes that key\n** into the index P1.  Data for the entry is nil.\n**\n** P3 is a flag that provides a hint to the b-tree layer that this\n** insert is likely to be an append.\n**\n** This instruction only works for indices.  The equivalent instruction\n** for tables is OP_Insert.\n*/\ncase OP_IdxInsert: {        /* in2 */\n#if 0  /* local variables moved into u.bn */\n  VdbeCursor *pC;\n  BtCursor *pCrsr;\n  int nKey;\n  const char *zKey;\n#endif /* local variables moved into u.bn */\n\n  assert( pOp->p1>=0 && pOp->p1<p->nCursor );\n  u.bn.pC = p->apCsr[pOp->p1];\n  assert( u.bn.pC!=0 );\n  pIn2 = &aMem[pOp->p2];\n  assert( pIn2->flags & MEM_Blob );\n  u.bn.pCrsr = u.bn.pC->pCursor;\n  if( ALWAYS(u.bn.pCrsr!=0) ){\n    assert( u.bn.pC->isTable==0 );\n    rc = ExpandBlob(pIn2);\n    if( rc==SQLITE_OK ){\n      u.bn.nKey = pIn2->n;\n      u.bn.zKey = pIn2->z;\n      rc = sqlite3BtreeInsert(u.bn.pCrsr, u.bn.zKey, u.bn.nKey, \"\", 0, 0, pOp->p3,\n          ((pOp->p5 & OPFLAG_USESEEKRESULT) ? u.bn.pC->seekResult : 0)\n      );\n      assert( u.bn.pC->deferredMoveto==0 );\n      u.bn.pC->cacheStatus = CACHE_STALE;\n    }\n  }\n  break;\n}\n\n/* Opcode: IdxDelete P1 P2 P3 * *\n**\n** The content of P3 registers starting at register P2 form\n** an unpacked index key. This opcode removes that entry from the \n** index opened by cursor P1.\n*/\ncase OP_IdxDelete: {\n#if 0  /* local variables moved into u.bo */\n  VdbeCursor *pC;\n  BtCursor *pCrsr;\n  int res;\n  UnpackedRecord r;\n#endif /* local variables moved into u.bo */\n\n  assert( pOp->p3>0 );\n  assert( pOp->p2>0 && pOp->p2+pOp->p3<=p->nMem+1 );\n  assert( pOp->p1>=0 && pOp->p1<p->nCursor );\n  u.bo.pC = p->apCsr[pOp->p1];\n  assert( u.bo.pC!=0 );\n  u.bo.pCrsr = u.bo.pC->pCursor;\n  if( ALWAYS(u.bo.pCrsr!=0) ){\n    u.bo.r.pKeyInfo = u.bo.pC->pKeyInfo;\n    u.bo.r.nField = (u16)pOp->p3;\n    u.bo.r.flags = 0;\n    u.bo.r.aMem = &aMem[pOp->p2];\n#ifdef SQLITE_DEBUG\n    { int i; for(i=0; i<u.bo.r.nField; i++) assert( memIsValid(&u.bo.r.aMem[i]) ); }\n#endif\n    rc = sqlite3BtreeMovetoUnpacked(u.bo.pCrsr, &u.bo.r, 0, 0, &u.bo.res);\n    if( rc==SQLITE_OK && u.bo.res==0 ){\n      rc = sqlite3BtreeDelete(u.bo.pCrsr);\n    }\n    assert( u.bo.pC->deferredMoveto==0 );\n    u.bo.pC->cacheStatus = CACHE_STALE;\n  }\n  break;\n}\n\n/* Opcode: IdxRowid P1 P2 * * *\n**\n** Write into register P2 an integer which is the last entry in the record at\n** the end of the index key pointed to by cursor P1.  This integer should be\n** the rowid of the table entry to which this index entry points.\n**\n** See also: Rowid, MakeRecord.\n*/\ncase OP_IdxRowid: {              /* out2-prerelease */\n#if 0  /* local variables moved into u.bp */\n  BtCursor *pCrsr;\n  VdbeCursor *pC;\n  i64 rowid;\n#endif /* local variables moved into u.bp */\n\n  assert( pOp->p1>=0 && pOp->p1<p->nCursor );\n  u.bp.pC = p->apCsr[pOp->p1];\n  assert( u.bp.pC!=0 );\n  u.bp.pCrsr = u.bp.pC->pCursor;\n  pOut->flags = MEM_Null;\n  if( ALWAYS(u.bp.pCrsr!=0) ){\n    rc = sqlite3VdbeCursorMoveto(u.bp.pC);\n    if( NEVER(rc) ) goto abort_due_to_error;\n    assert( u.bp.pC->deferredMoveto==0 );\n    assert( u.bp.pC->isTable==0 );\n    if( !u.bp.pC->nullRow ){\n      rc = sqlite3VdbeIdxRowid(db, u.bp.pCrsr, &u.bp.rowid);\n      if( rc!=SQLITE_OK ){\n        goto abort_due_to_error;\n      }\n      pOut->u.i = u.bp.rowid;\n      pOut->flags = MEM_Int;\n    }\n  }\n  break;\n}\n\n/* Opcode: IdxGE P1 P2 P3 P4 P5\n**\n** The P4 register values beginning with P3 form an unpacked index \n** key that omits the ROWID.  Compare this key value against the index \n** that P1 is currently pointing to, ignoring the ROWID on the P1 index.\n**\n** If the P1 index entry is greater than or equal to the key value\n** then jump to P2.  Otherwise fall through to the next instruction.\n**\n** If P5 is non-zero then the key value is increased by an epsilon \n** prior to the comparison.  This make the opcode work like IdxGT except\n** that if the key from register P3 is a prefix of the key in the cursor,\n** the result is false whereas it would be true with IdxGT.\n*/\n/* Opcode: IdxLT P1 P2 P3 P4 P5\n**\n** The P4 register values beginning with P3 form an unpacked index \n** key that omits the ROWID.  Compare this key value against the index \n** that P1 is currently pointing to, ignoring the ROWID on the P1 index.\n**\n** If the P1 index entry is less than the key value then jump to P2.\n** Otherwise fall through to the next instruction.\n**\n** If P5 is non-zero then the key value is increased by an epsilon prior \n** to the comparison.  This makes the opcode work like IdxLE.\n*/\ncase OP_IdxLT:          /* jump */\ncase OP_IdxGE: {        /* jump */\n#if 0  /* local variables moved into u.bq */\n  VdbeCursor *pC;\n  int res;\n  UnpackedRecord r;\n#endif /* local variables moved into u.bq */\n\n  assert( pOp->p1>=0 && pOp->p1<p->nCursor );\n  u.bq.pC = p->apCsr[pOp->p1];\n  assert( u.bq.pC!=0 );\n  assert( u.bq.pC->isOrdered );\n  if( ALWAYS(u.bq.pC->pCursor!=0) ){\n    assert( u.bq.pC->deferredMoveto==0 );\n    assert( pOp->p5==0 || pOp->p5==1 );\n    assert( pOp->p4type==P4_INT32 );\n    u.bq.r.pKeyInfo = u.bq.pC->pKeyInfo;\n    u.bq.r.nField = (u16)pOp->p4.i;\n    if( pOp->p5 ){\n      u.bq.r.flags = UNPACKED_INCRKEY | UNPACKED_IGNORE_ROWID;\n    }else{\n      u.bq.r.flags = UNPACKED_IGNORE_ROWID;\n    }\n    u.bq.r.aMem = &aMem[pOp->p3];\n#ifdef SQLITE_DEBUG\n    { int i; for(i=0; i<u.bq.r.nField; i++) assert( memIsValid(&u.bq.r.aMem[i]) ); }\n#endif\n    rc = sqlite3VdbeIdxKeyCompare(u.bq.pC, &u.bq.r, &u.bq.res);\n    if( pOp->opcode==OP_IdxLT ){\n      u.bq.res = -u.bq.res;\n    }else{\n      assert( pOp->opcode==OP_IdxGE );\n      u.bq.res++;\n    }\n    if( u.bq.res>0 ){\n      pc = pOp->p2 - 1 ;\n    }\n  }\n  break;\n}\n\n/* Opcode: Destroy P1 P2 P3 * *\n**\n** Delete an entire database table or index whose root page in the database\n** file is given by P1.\n**\n** The table being destroyed is in the main database file if P3==0.  If\n** P3==1 then the table to be clear is in the auxiliary database file\n** that is used to store tables create using CREATE TEMPORARY TABLE.\n**\n** If AUTOVACUUM is enabled then it is possible that another root page\n** might be moved into the newly deleted root page in order to keep all\n** root pages contiguous at the beginning of the database.  The former\n** value of the root page that moved - its value before the move occurred -\n** is stored in register P2.  If no page \n** movement was required (because the table being dropped was already \n** the last one in the database) then a zero is stored in register P2.\n** If AUTOVACUUM is disabled then a zero is stored in register P2.\n**\n** See also: Clear\n*/\ncase OP_Destroy: {     /* out2-prerelease */\n#if 0  /* local variables moved into u.br */\n  int iMoved;\n  int iCnt;\n  Vdbe *pVdbe;\n  int iDb;\n#endif /* local variables moved into u.br */\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  u.br.iCnt = 0;\n  for(u.br.pVdbe=db->pVdbe; u.br.pVdbe; u.br.pVdbe = u.br.pVdbe->pNext){\n    if( u.br.pVdbe->magic==VDBE_MAGIC_RUN && u.br.pVdbe->inVtabMethod<2 && u.br.pVdbe->pc>=0 ){\n      u.br.iCnt++;\n    }\n  }\n#else\n  u.br.iCnt = db->activeVdbeCnt;\n#endif\n  pOut->flags = MEM_Null;\n  if( u.br.iCnt>1 ){\n    rc = SQLITE_LOCKED;\n    p->errorAction = OE_Abort;\n  }else{\n    u.br.iDb = pOp->p3;\n    assert( u.br.iCnt==1 );\n    assert( (p->btreeMask & (1<<u.br.iDb))!=0 );\n    rc = sqlite3BtreeDropTable(db->aDb[u.br.iDb].pBt, pOp->p1, &u.br.iMoved);\n    pOut->flags = MEM_Int;\n    pOut->u.i = u.br.iMoved;\n#ifndef SQLITE_OMIT_AUTOVACUUM\n    if( rc==SQLITE_OK && u.br.iMoved!=0 ){\n      sqlite3RootPageMoved(&db->aDb[u.br.iDb], u.br.iMoved, pOp->p1);\n      resetSchemaOnFault = 1;\n    }\n#endif\n  }\n  break;\n}\n\n/* Opcode: Clear P1 P2 P3\n**\n** Delete all contents of the database table or index whose root page\n** in the database file is given by P1.  But, unlike Destroy, do not\n** remove the table or index from the database file.\n**\n** The table being clear is in the main database file if P2==0.  If\n** P2==1 then the table to be clear is in the auxiliary database file\n** that is used to store tables create using CREATE TEMPORARY TABLE.\n**\n** If the P3 value is non-zero, then the table referred to must be an\n** intkey table (an SQL table, not an index). In this case the row change \n** count is incremented by the number of rows in the table being cleared. \n** If P3 is greater than zero, then the value stored in register P3 is\n** also incremented by the number of rows in the table being cleared.\n**\n** See also: Destroy\n*/\ncase OP_Clear: {\n#if 0  /* local variables moved into u.bs */\n  int nChange;\n#endif /* local variables moved into u.bs */\n\n  u.bs.nChange = 0;\n  assert( (p->btreeMask & (1<<pOp->p2))!=0 );\n  rc = sqlite3BtreeClearTable(\n      db->aDb[pOp->p2].pBt, pOp->p1, (pOp->p3 ? &u.bs.nChange : 0)\n  );\n  if( pOp->p3 ){\n    p->nChange += u.bs.nChange;\n    if( pOp->p3>0 ){\n      assert( memIsValid(&aMem[pOp->p3]) );\n      memAboutToChange(p, &aMem[pOp->p3]);\n      aMem[pOp->p3].u.i += u.bs.nChange;\n    }\n  }\n  break;\n}\n\n/* Opcode: CreateTable P1 P2 * * *\n**\n** Allocate a new table in the main database file if P1==0 or in the\n** auxiliary database file if P1==1 or in an attached database if\n** P1>1.  Write the root page number of the new table into\n** register P2\n**\n** The difference between a table and an index is this:  A table must\n** have a 4-byte integer key and can have arbitrary data.  An index\n** has an arbitrary key but no data.\n**\n** See also: CreateIndex\n*/\n/* Opcode: CreateIndex P1 P2 * * *\n**\n** Allocate a new index in the main database file if P1==0 or in the\n** auxiliary database file if P1==1 or in an attached database if\n** P1>1.  Write the root page number of the new table into\n** register P2.\n**\n** See documentation on OP_CreateTable for additional information.\n*/\ncase OP_CreateIndex:            /* out2-prerelease */\ncase OP_CreateTable: {          /* out2-prerelease */\n#if 0  /* local variables moved into u.bt */\n  int pgno;\n  int flags;\n  Db *pDb;\n#endif /* local variables moved into u.bt */\n\n  u.bt.pgno = 0;\n  assert( pOp->p1>=0 && pOp->p1<db->nDb );\n  assert( (p->btreeMask & (1<<pOp->p1))!=0 );\n  u.bt.pDb = &db->aDb[pOp->p1];\n  assert( u.bt.pDb->pBt!=0 );\n  if( pOp->opcode==OP_CreateTable ){\n    /* u.bt.flags = BTREE_INTKEY; */\n    u.bt.flags = BTREE_INTKEY;\n  }else{\n    u.bt.flags = BTREE_BLOBKEY;\n  }\n  rc = sqlite3BtreeCreateTable(u.bt.pDb->pBt, &u.bt.pgno, u.bt.flags);\n  pOut->u.i = u.bt.pgno;\n  break;\n}\n\n/* Opcode: ParseSchema P1 P2 * P4 *\n**\n** Read and parse all entries from the SQLITE_MASTER table of database P1\n** that match the WHERE clause P4.  P2 is the \"force\" flag.   Always do\n** the parsing if P2 is true.  If P2 is false, then this routine is a\n** no-op if the schema is not currently loaded.  In other words, if P2\n** is false, the SQLITE_MASTER table is only parsed if the rest of the\n** schema is already loaded into the symbol table.\n**\n** This opcode invokes the parser to create a new virtual machine,\n** then runs the new virtual machine.  It is thus a re-entrant opcode.\n*/\ncase OP_ParseSchema: {\n#if 0  /* local variables moved into u.bu */\n  int iDb;\n  const char *zMaster;\n  char *zSql;\n  InitData initData;\n#endif /* local variables moved into u.bu */\n\n  u.bu.iDb = pOp->p1;\n  assert( u.bu.iDb>=0 && u.bu.iDb<db->nDb );\n\n  /* If pOp->p2 is 0, then this opcode is being executed to read a\n  ** single row, for example the row corresponding to a new index\n  ** created by this VDBE, from the sqlite_master table. It only\n  ** does this if the corresponding in-memory schema is currently\n  ** loaded. Otherwise, the new index definition can be loaded along\n  ** with the rest of the schema when it is required.\n  **\n  ** Although the mutex on the BtShared object that corresponds to\n  ** database u.bu.iDb (the database containing the sqlite_master table\n  ** read by this instruction) is currently held, it is necessary to\n  ** obtain the mutexes on all attached databases before checking if\n  ** the schema of u.bu.iDb is loaded. This is because, at the start of\n  ** the sqlite3_exec() call below, SQLite will invoke\n  ** sqlite3BtreeEnterAll(). If all mutexes are not already held, the\n  ** u.bu.iDb mutex may be temporarily released to avoid deadlock. If\n  ** this happens, then some other thread may delete the in-memory\n  ** schema of database u.bu.iDb before the SQL statement runs. The schema\n  ** will not be reloaded becuase the db->init.busy flag is set. This\n  ** can result in a \"no such table: sqlite_master\" or \"malformed\n  ** database schema\" error being returned to the user.\n  */\n  assert( sqlite3BtreeHoldsMutex(db->aDb[u.bu.iDb].pBt) );\n  sqlite3BtreeEnterAll(db);\n  if( pOp->p2 || DbHasProperty(db, u.bu.iDb, DB_SchemaLoaded) ){\n    u.bu.zMaster = SCHEMA_TABLE(u.bu.iDb);\n    u.bu.initData.db = db;\n    u.bu.initData.iDb = pOp->p1;\n    u.bu.initData.pzErrMsg = &p->zErrMsg;\n    u.bu.zSql = sqlite3MPrintf(db,\n       \"SELECT name, rootpage, sql FROM '%q'.%s WHERE %s ORDER BY rowid\",\n       db->aDb[u.bu.iDb].zName, u.bu.zMaster, pOp->p4.z);\n    if( u.bu.zSql==0 ){\n      rc = SQLITE_NOMEM;\n    }else{\n      assert( db->init.busy==0 );\n      db->init.busy = 1;\n      u.bu.initData.rc = SQLITE_OK;\n      assert( !db->mallocFailed );\n      rc = sqlite3_exec(db, u.bu.zSql, sqlite3InitCallback, &u.bu.initData, 0);\n      if( rc==SQLITE_OK ) rc = u.bu.initData.rc;\n      sqlite3DbFree(db, u.bu.zSql);\n      db->init.busy = 0;\n    }\n  }\n  sqlite3BtreeLeaveAll(db);\n  if( rc==SQLITE_NOMEM ){\n    goto no_mem;\n  }\n  break;\n}\n\n#if !defined(SQLITE_OMIT_ANALYZE)\n/* Opcode: LoadAnalysis P1 * * * *\n**\n** Read the sqlite_stat1 table for database P1 and load the content\n** of that table into the internal index hash table.  This will cause\n** the analysis to be used when preparing all subsequent queries.\n*/\ncase OP_LoadAnalysis: {\n  assert( pOp->p1>=0 && pOp->p1<db->nDb );\n  rc = sqlite3AnalysisLoad(db, pOp->p1);\n  break;  \n}\n#endif /* !defined(SQLITE_OMIT_ANALYZE) */\n\n/* Opcode: DropTable P1 * * P4 *\n**\n** Remove the internal (in-memory) data structures that describe\n** the table named P4 in database P1.  This is called after a table\n** is dropped in order to keep the internal representation of the\n** schema consistent with what is on disk.\n*/\ncase OP_DropTable: {\n  sqlite3UnlinkAndDeleteTable(db, pOp->p1, pOp->p4.z);\n  break;\n}\n\n/* Opcode: DropIndex P1 * * P4 *\n**\n** Remove the internal (in-memory) data structures that describe\n** the index named P4 in database P1.  This is called after an index\n** is dropped in order to keep the internal representation of the\n** schema consistent with what is on disk.\n*/\ncase OP_DropIndex: {\n  sqlite3UnlinkAndDeleteIndex(db, pOp->p1, pOp->p4.z);\n  break;\n}\n\n/* Opcode: DropTrigger P1 * * P4 *\n**\n** Remove the internal (in-memory) data structures that describe\n** the trigger named P4 in database P1.  This is called after a trigger\n** is dropped in order to keep the internal representation of the\n** schema consistent with what is on disk.\n*/\ncase OP_DropTrigger: {\n  sqlite3UnlinkAndDeleteTrigger(db, pOp->p1, pOp->p4.z);\n  break;\n}\n\n\n#ifndef SQLITE_OMIT_INTEGRITY_CHECK\n/* Opcode: IntegrityCk P1 P2 P3 * P5\n**\n** Do an analysis of the currently open database.  Store in\n** register P1 the text of an error message describing any problems.\n** If no problems are found, store a NULL in register P1.\n**\n** The register P3 contains the maximum number of allowed errors.\n** At most reg(P3) errors will be reported.\n** In other words, the analysis stops as soon as reg(P1) errors are \n** seen.  Reg(P1) is updated with the number of errors remaining.\n**\n** The root page numbers of all tables in the database are integer\n** stored in reg(P1), reg(P1+1), reg(P1+2), ....  There are P2 tables\n** total.\n**\n** If P5 is not zero, the check is done on the auxiliary database\n** file, not the main database file.\n**\n** This opcode is used to implement the integrity_check pragma.\n*/\ncase OP_IntegrityCk: {\n#if 0  /* local variables moved into u.bv */\n  int nRoot;      /* Number of tables to check.  (Number of root pages.) */\n  int *aRoot;     /* Array of rootpage numbers for tables to be checked */\n  int j;          /* Loop counter */\n  int nErr;       /* Number of errors reported */\n  char *z;        /* Text of the error report */\n  Mem *pnErr;     /* Register keeping track of errors remaining */\n#endif /* local variables moved into u.bv */\n\n  u.bv.nRoot = pOp->p2;\n  assert( u.bv.nRoot>0 );\n  u.bv.aRoot = sqlite3DbMallocRaw(db, sizeof(int)*(u.bv.nRoot+1) );\n  if( u.bv.aRoot==0 ) goto no_mem;\n  assert( pOp->p3>0 && pOp->p3<=p->nMem );\n  u.bv.pnErr = &aMem[pOp->p3];\n  assert( (u.bv.pnErr->flags & MEM_Int)!=0 );\n  assert( (u.bv.pnErr->flags & (MEM_Str|MEM_Blob))==0 );\n  pIn1 = &aMem[pOp->p1];\n  for(u.bv.j=0; u.bv.j<u.bv.nRoot; u.bv.j++){\n    u.bv.aRoot[u.bv.j] = (int)sqlite3VdbeIntValue(&pIn1[u.bv.j]);\n  }\n  u.bv.aRoot[u.bv.j] = 0;\n  assert( pOp->p5<db->nDb );\n  assert( (p->btreeMask & (1<<pOp->p5))!=0 );\n  u.bv.z = sqlite3BtreeIntegrityCheck(db->aDb[pOp->p5].pBt, u.bv.aRoot, u.bv.nRoot,\n                                 (int)u.bv.pnErr->u.i, &u.bv.nErr, 0);\n  sqlite3DbFree(db, u.bv.aRoot);\n  u.bv.pnErr->u.i -= u.bv.nErr;\n  sqlite3VdbeMemSetNull(pIn1);\n  if( u.bv.nErr==0 ){\n    assert( u.bv.z==0 );\n  }else if( u.bv.z==0 ){\n    goto no_mem;\n  }else{\n    sqlite3VdbeMemSetStr(pIn1, u.bv.z, -1, SQLITE_UTF8, sqlite3_free);\n  }\n  UPDATE_MAX_BLOBSIZE(pIn1);\n  sqlite3VdbeChangeEncoding(pIn1, encoding);\n  break;\n}\n#endif /* SQLITE_OMIT_INTEGRITY_CHECK */\n\n/* Opcode: RowSetAdd P1 P2 * * *\n**\n** Insert the integer value held by register P2 into a boolean index\n** held in register P1.\n**\n** An assertion fails if P2 is not an integer.\n*/\ncase OP_RowSetAdd: {       /* in1, in2 */\n  pIn1 = &aMem[pOp->p1];\n  pIn2 = &aMem[pOp->p2];\n  assert( (pIn2->flags & MEM_Int)!=0 );\n  if( (pIn1->flags & MEM_RowSet)==0 ){\n    sqlite3VdbeMemSetRowSet(pIn1);\n    if( (pIn1->flags & MEM_RowSet)==0 ) goto no_mem;\n  }\n  sqlite3RowSetInsert(pIn1->u.pRowSet, pIn2->u.i);\n  break;\n}\n\n/* Opcode: RowSetRead P1 P2 P3 * *\n**\n** Extract the smallest value from boolean index P1 and put that value into\n** register P3.  Or, if boolean index P1 is initially empty, leave P3\n** unchanged and jump to instruction P2.\n*/\ncase OP_RowSetRead: {       /* jump, in1, out3 */\n#if 0  /* local variables moved into u.bw */\n  i64 val;\n#endif /* local variables moved into u.bw */\n  CHECK_FOR_INTERRUPT;\n  pIn1 = &aMem[pOp->p1];\n  if( (pIn1->flags & MEM_RowSet)==0\n   || sqlite3RowSetNext(pIn1->u.pRowSet, &u.bw.val)==0\n  ){\n    /* The boolean index is empty */\n    sqlite3VdbeMemSetNull(pIn1);\n    pc = pOp->p2 - 1;\n  }else{\n    /* A value was pulled from the index */\n    sqlite3VdbeMemSetInt64(&aMem[pOp->p3], u.bw.val);\n  }\n  break;\n}\n\n/* Opcode: RowSetTest P1 P2 P3 P4\n**\n** Register P3 is assumed to hold a 64-bit integer value. If register P1\n** contains a RowSet object and that RowSet object contains\n** the value held in P3, jump to register P2. Otherwise, insert the\n** integer in P3 into the RowSet and continue on to the\n** next opcode.\n**\n** The RowSet object is optimized for the case where successive sets\n** of integers, where each set contains no duplicates. Each set\n** of values is identified by a unique P4 value. The first set\n** must have P4==0, the final set P4=-1.  P4 must be either -1 or\n** non-negative.  For non-negative values of P4 only the lower 4\n** bits are significant.\n**\n** This allows optimizations: (a) when P4==0 there is no need to test\n** the rowset object for P3, as it is guaranteed not to contain it,\n** (b) when P4==-1 there is no need to insert the value, as it will\n** never be tested for, and (c) when a value that is part of set X is\n** inserted, there is no need to search to see if the same value was\n** previously inserted as part of set X (only if it was previously\n** inserted as part of some other set).\n*/\ncase OP_RowSetTest: {                     /* jump, in1, in3 */\n#if 0  /* local variables moved into u.bx */\n  int iSet;\n  int exists;\n#endif /* local variables moved into u.bx */\n\n  pIn1 = &aMem[pOp->p1];\n  pIn3 = &aMem[pOp->p3];\n  u.bx.iSet = pOp->p4.i;\n  assert( pIn3->flags&MEM_Int );\n\n  /* If there is anything other than a rowset object in memory cell P1,\n  ** delete it now and initialize P1 with an empty rowset\n  */\n  if( (pIn1->flags & MEM_RowSet)==0 ){\n    sqlite3VdbeMemSetRowSet(pIn1);\n    if( (pIn1->flags & MEM_RowSet)==0 ) goto no_mem;\n  }\n\n  assert( pOp->p4type==P4_INT32 );\n  assert( u.bx.iSet==-1 || u.bx.iSet>=0 );\n  if( u.bx.iSet ){\n    u.bx.exists = sqlite3RowSetTest(pIn1->u.pRowSet,\n                               (u8)(u.bx.iSet>=0 ? u.bx.iSet & 0xf : 0xff),\n                               pIn3->u.i);\n    if( u.bx.exists ){\n      pc = pOp->p2 - 1;\n      break;\n    }\n  }\n  if( u.bx.iSet>=0 ){\n    sqlite3RowSetInsert(pIn1->u.pRowSet, pIn3->u.i);\n  }\n  break;\n}\n\n\n#ifndef SQLITE_OMIT_TRIGGER\n\n/* Opcode: Program P1 P2 P3 P4 *\n**\n** Execute the trigger program passed as P4 (type P4_SUBPROGRAM). \n**\n** P1 contains the address of the memory cell that contains the first memory \n** cell in an array of values used as arguments to the sub-program. P2 \n** contains the address to jump to if the sub-program throws an IGNORE \n** exception using the RAISE() function. Register P3 contains the address \n** of a memory cell in this (the parent) VM that is used to allocate the \n** memory required by the sub-vdbe at runtime.\n**\n** P4 is a pointer to the VM containing the trigger program.\n*/\ncase OP_Program: {        /* jump */\n#if 0  /* local variables moved into u.by */\n  int nMem;               /* Number of memory registers for sub-program */\n  int nByte;              /* Bytes of runtime space required for sub-program */\n  Mem *pRt;               /* Register to allocate runtime space */\n  Mem *pMem;              /* Used to iterate through memory cells */\n  Mem *pEnd;              /* Last memory cell in new array */\n  VdbeFrame *pFrame;      /* New vdbe frame to execute in */\n  SubProgram *pProgram;   /* Sub-program to execute */\n  void *t;                /* Token identifying trigger */\n#endif /* local variables moved into u.by */\n\n  u.by.pProgram = pOp->p4.pProgram;\n  u.by.pRt = &aMem[pOp->p3];\n  assert( memIsValid(u.by.pRt) );\n  assert( u.by.pProgram->nOp>0 );\n\n  /* If the p5 flag is clear, then recursive invocation of triggers is\n  ** disabled for backwards compatibility (p5 is set if this sub-program\n  ** is really a trigger, not a foreign key action, and the flag set\n  ** and cleared by the \"PRAGMA recursive_triggers\" command is clear).\n  **\n  ** It is recursive invocation of triggers, at the SQL level, that is\n  ** disabled. In some cases a single trigger may generate more than one\n  ** SubProgram (if the trigger may be executed with more than one different\n  ** ON CONFLICT algorithm). SubProgram structures associated with a\n  ** single trigger all have the same value for the SubProgram.token\n  ** variable.  */\n  if( pOp->p5 ){\n    u.by.t = u.by.pProgram->token;\n    for(u.by.pFrame=p->pFrame; u.by.pFrame && u.by.pFrame->token!=u.by.t; u.by.pFrame=u.by.pFrame->pParent);\n    if( u.by.pFrame ) break;\n  }\n\n  if( p->nFrame>=db->aLimit[SQLITE_LIMIT_TRIGGER_DEPTH] ){\n    rc = SQLITE_ERROR;\n    sqlite3SetString(&p->zErrMsg, db, \"too many levels of trigger recursion\");\n    break;\n  }\n\n  /* Register u.by.pRt is used to store the memory required to save the state\n  ** of the current program, and the memory required at runtime to execute\n  ** the trigger program. If this trigger has been fired before, then u.by.pRt\n  ** is already allocated. Otherwise, it must be initialized.  */\n  if( (u.by.pRt->flags&MEM_Frame)==0 ){\n    /* SubProgram.nMem is set to the number of memory cells used by the\n    ** program stored in SubProgram.aOp. As well as these, one memory\n    ** cell is required for each cursor used by the program. Set local\n    ** variable u.by.nMem (and later, VdbeFrame.nChildMem) to this value.\n    */\n    u.by.nMem = u.by.pProgram->nMem + u.by.pProgram->nCsr;\n    u.by.nByte = ROUND8(sizeof(VdbeFrame))\n              + u.by.nMem * sizeof(Mem)\n              + u.by.pProgram->nCsr * sizeof(VdbeCursor *);\n    u.by.pFrame = sqlite3DbMallocZero(db, u.by.nByte);\n    if( !u.by.pFrame ){\n      goto no_mem;\n    }\n    sqlite3VdbeMemRelease(u.by.pRt);\n    u.by.pRt->flags = MEM_Frame;\n    u.by.pRt->u.pFrame = u.by.pFrame;\n\n    u.by.pFrame->v = p;\n    u.by.pFrame->nChildMem = u.by.nMem;\n    u.by.pFrame->nChildCsr = u.by.pProgram->nCsr;\n    u.by.pFrame->pc = pc;\n    u.by.pFrame->aMem = p->aMem;\n    u.by.pFrame->nMem = p->nMem;\n    u.by.pFrame->apCsr = p->apCsr;\n    u.by.pFrame->nCursor = p->nCursor;\n    u.by.pFrame->aOp = p->aOp;\n    u.by.pFrame->nOp = p->nOp;\n    u.by.pFrame->token = u.by.pProgram->token;\n\n    u.by.pEnd = &VdbeFrameMem(u.by.pFrame)[u.by.pFrame->nChildMem];\n    for(u.by.pMem=VdbeFrameMem(u.by.pFrame); u.by.pMem!=u.by.pEnd; u.by.pMem++){\n      u.by.pMem->flags = MEM_Null;\n      u.by.pMem->db = db;\n    }\n  }else{\n    u.by.pFrame = u.by.pRt->u.pFrame;\n    assert( u.by.pProgram->nMem+u.by.pProgram->nCsr==u.by.pFrame->nChildMem );\n    assert( u.by.pProgram->nCsr==u.by.pFrame->nChildCsr );\n    assert( pc==u.by.pFrame->pc );\n  }\n\n  p->nFrame++;\n  u.by.pFrame->pParent = p->pFrame;\n  u.by.pFrame->lastRowid = db->lastRowid;\n  u.by.pFrame->nChange = p->nChange;\n  p->nChange = 0;\n  p->pFrame = u.by.pFrame;\n  p->aMem = aMem = &VdbeFrameMem(u.by.pFrame)[-1];\n  p->nMem = u.by.pFrame->nChildMem;\n  p->nCursor = (u16)u.by.pFrame->nChildCsr;\n  p->apCsr = (VdbeCursor **)&aMem[p->nMem+1];\n  p->aOp = aOp = u.by.pProgram->aOp;\n  p->nOp = u.by.pProgram->nOp;\n  pc = -1;\n\n  break;\n}\n\n/* Opcode: Param P1 P2 * * *\n**\n** This opcode is only ever present in sub-programs called via the \n** OP_Program instruction. Copy a value currently stored in a memory \n** cell of the calling (parent) frame to cell P2 in the current frames \n** address space. This is used by trigger programs to access the new.* \n** and old.* values.\n**\n** The address of the cell in the parent frame is determined by adding\n** the value of the P1 argument to the value of the P1 argument to the\n** calling OP_Program instruction.\n*/\ncase OP_Param: {           /* out2-prerelease */\n#if 0  /* local variables moved into u.bz */\n  VdbeFrame *pFrame;\n  Mem *pIn;\n#endif /* local variables moved into u.bz */\n  u.bz.pFrame = p->pFrame;\n  u.bz.pIn = &u.bz.pFrame->aMem[pOp->p1 + u.bz.pFrame->aOp[u.bz.pFrame->pc].p1];\n  sqlite3VdbeMemShallowCopy(pOut, u.bz.pIn, MEM_Ephem);\n  break;\n}\n\n#endif /* #ifndef SQLITE_OMIT_TRIGGER */\n\n#ifndef SQLITE_OMIT_FOREIGN_KEY\n/* Opcode: FkCounter P1 P2 * * *\n**\n** Increment a \"constraint counter\" by P2 (P2 may be negative or positive).\n** If P1 is non-zero, the database constraint counter is incremented \n** (deferred foreign key constraints). Otherwise, if P1 is zero, the \n** statement counter is incremented (immediate foreign key constraints).\n*/\ncase OP_FkCounter: {\n  if( pOp->p1 ){\n    db->nDeferredCons += pOp->p2;\n  }else{\n    p->nFkConstraint += pOp->p2;\n  }\n  break;\n}\n\n/* Opcode: FkIfZero P1 P2 * * *\n**\n** This opcode tests if a foreign key constraint-counter is currently zero.\n** If so, jump to instruction P2. Otherwise, fall through to the next \n** instruction.\n**\n** If P1 is non-zero, then the jump is taken if the database constraint-counter\n** is zero (the one that counts deferred constraint violations). If P1 is\n** zero, the jump is taken if the statement constraint-counter is zero\n** (immediate foreign key constraint violations).\n*/\ncase OP_FkIfZero: {         /* jump */\n  if( pOp->p1 ){\n    if( db->nDeferredCons==0 ) pc = pOp->p2-1;\n  }else{\n    if( p->nFkConstraint==0 ) pc = pOp->p2-1;\n  }\n  break;\n}\n#endif /* #ifndef SQLITE_OMIT_FOREIGN_KEY */\n\n#ifndef SQLITE_OMIT_AUTOINCREMENT\n/* Opcode: MemMax P1 P2 * * *\n**\n** P1 is a register in the root frame of this VM (the root frame is\n** different from the current frame if this instruction is being executed\n** within a sub-program). Set the value of register P1 to the maximum of \n** its current value and the value in register P2.\n**\n** This instruction throws an error if the memory cell is not initially\n** an integer.\n*/\ncase OP_MemMax: {        /* in2 */\n#if 0  /* local variables moved into u.ca */\n  Mem *pIn1;\n  VdbeFrame *pFrame;\n#endif /* local variables moved into u.ca */\n  if( p->pFrame ){\n    for(u.ca.pFrame=p->pFrame; u.ca.pFrame->pParent; u.ca.pFrame=u.ca.pFrame->pParent);\n    u.ca.pIn1 = &u.ca.pFrame->aMem[pOp->p1];\n  }else{\n    u.ca.pIn1 = &aMem[pOp->p1];\n  }\n  assert( memIsValid(u.ca.pIn1) );\n  sqlite3VdbeMemIntegerify(u.ca.pIn1);\n  pIn2 = &aMem[pOp->p2];\n  sqlite3VdbeMemIntegerify(pIn2);\n  if( u.ca.pIn1->u.i<pIn2->u.i){\n    u.ca.pIn1->u.i = pIn2->u.i;\n  }\n  break;\n}\n#endif /* SQLITE_OMIT_AUTOINCREMENT */\n\n/* Opcode: IfPos P1 P2 * * *\n**\n** If the value of register P1 is 1 or greater, jump to P2.\n**\n** It is illegal to use this instruction on a register that does\n** not contain an integer.  An assertion fault will result if you try.\n*/\ncase OP_IfPos: {        /* jump, in1 */\n  pIn1 = &aMem[pOp->p1];\n  assert( pIn1->flags&MEM_Int );\n  if( pIn1->u.i>0 ){\n     pc = pOp->p2 - 1;\n  }\n  break;\n}\n\n/* Opcode: IfNeg P1 P2 * * *\n**\n** If the value of register P1 is less than zero, jump to P2. \n**\n** It is illegal to use this instruction on a register that does\n** not contain an integer.  An assertion fault will result if you try.\n*/\ncase OP_IfNeg: {        /* jump, in1 */\n  pIn1 = &aMem[pOp->p1];\n  assert( pIn1->flags&MEM_Int );\n  if( pIn1->u.i<0 ){\n     pc = pOp->p2 - 1;\n  }\n  break;\n}\n\n/* Opcode: IfZero P1 P2 P3 * *\n**\n** The register P1 must contain an integer.  Add literal P3 to the\n** value in register P1.  If the result is exactly 0, jump to P2. \n**\n** It is illegal to use this instruction on a register that does\n** not contain an integer.  An assertion fault will result if you try.\n*/\ncase OP_IfZero: {        /* jump, in1 */\n  pIn1 = &aMem[pOp->p1];\n  assert( pIn1->flags&MEM_Int );\n  pIn1->u.i += pOp->p3;\n  if( pIn1->u.i==0 ){\n     pc = pOp->p2 - 1;\n  }\n  break;\n}\n\n/* Opcode: AggStep * P2 P3 P4 P5\n**\n** Execute the step function for an aggregate.  The\n** function has P5 arguments.   P4 is a pointer to the FuncDef\n** structure that specifies the function.  Use register\n** P3 as the accumulator.\n**\n** The P5 arguments are taken from register P2 and its\n** successors.\n*/\ncase OP_AggStep: {\n#if 0  /* local variables moved into u.cb */\n  int n;\n  int i;\n  Mem *pMem;\n  Mem *pRec;\n  sqlite3_context ctx;\n  sqlite3_value **apVal;\n#endif /* local variables moved into u.cb */\n\n  u.cb.n = pOp->p5;\n  assert( u.cb.n>=0 );\n  u.cb.pRec = &aMem[pOp->p2];\n  u.cb.apVal = p->apArg;\n  assert( u.cb.apVal || u.cb.n==0 );\n  for(u.cb.i=0; u.cb.i<u.cb.n; u.cb.i++, u.cb.pRec++){\n    assert( memIsValid(u.cb.pRec) );\n    u.cb.apVal[u.cb.i] = u.cb.pRec;\n    memAboutToChange(p, u.cb.pRec);\n    sqlite3VdbeMemStoreType(u.cb.pRec);\n  }\n  u.cb.ctx.pFunc = pOp->p4.pFunc;\n  assert( pOp->p3>0 && pOp->p3<=p->nMem );\n  u.cb.ctx.pMem = u.cb.pMem = &aMem[pOp->p3];\n  u.cb.pMem->n++;\n  u.cb.ctx.s.flags = MEM_Null;\n  u.cb.ctx.s.z = 0;\n  u.cb.ctx.s.zMalloc = 0;\n  u.cb.ctx.s.xDel = 0;\n  u.cb.ctx.s.db = db;\n  u.cb.ctx.isError = 0;\n  u.cb.ctx.pColl = 0;\n  if( u.cb.ctx.pFunc->flags & SQLITE_FUNC_NEEDCOLL ){\n    assert( pOp>p->aOp );\n    assert( pOp[-1].p4type==P4_COLLSEQ );\n    assert( pOp[-1].opcode==OP_CollSeq );\n    u.cb.ctx.pColl = pOp[-1].p4.pColl;\n  }\n  (u.cb.ctx.pFunc->xStep)(&u.cb.ctx, u.cb.n, u.cb.apVal); /* IMP: R-24505-23230 */\n  if( u.cb.ctx.isError ){\n    sqlite3SetString(&p->zErrMsg, db, \"%s\", sqlite3_value_text(&u.cb.ctx.s));\n    rc = u.cb.ctx.isError;\n  }\n  sqlite3VdbeMemRelease(&u.cb.ctx.s);\n  break;\n}\n\n/* Opcode: AggFinal P1 P2 * P4 *\n**\n** Execute the finalizer function for an aggregate.  P1 is\n** the memory location that is the accumulator for the aggregate.\n**\n** P2 is the number of arguments that the step function takes and\n** P4 is a pointer to the FuncDef for this function.  The P2\n** argument is not used by this opcode.  It is only there to disambiguate\n** functions that can take varying numbers of arguments.  The\n** P4 argument is only needed for the degenerate case where\n** the step function was not previously called.\n*/\ncase OP_AggFinal: {\n#if 0  /* local variables moved into u.cc */\n  Mem *pMem;\n#endif /* local variables moved into u.cc */\n  assert( pOp->p1>0 && pOp->p1<=p->nMem );\n  u.cc.pMem = &aMem[pOp->p1];\n  assert( (u.cc.pMem->flags & ~(MEM_Null|MEM_Agg))==0 );\n  rc = sqlite3VdbeMemFinalize(u.cc.pMem, pOp->p4.pFunc);\n  if( rc ){\n    sqlite3SetString(&p->zErrMsg, db, \"%s\", sqlite3_value_text(u.cc.pMem));\n  }\n  sqlite3VdbeChangeEncoding(u.cc.pMem, encoding);\n  UPDATE_MAX_BLOBSIZE(u.cc.pMem);\n  if( sqlite3VdbeMemTooBig(u.cc.pMem) ){\n    goto too_big;\n  }\n  break;\n}\n\n#ifndef SQLITE_OMIT_WAL\n/* Opcode: Checkpoint P1 P2 P3 * *\n**\n** Checkpoint database P1. This is a no-op if P1 is not currently in\n** WAL mode. Parameter P2 is one of SQLITE_CHECKPOINT_PASSIVE, FULL\n** or RESTART.  Write 1 or 0 into mem[P3] if the checkpoint returns\n** SQLITE_BUSY or not, respectively.  Write the number of pages in the\n** WAL after the checkpoint into mem[P3+1] and the number of pages\n** in the WAL that have been checkpointed after the checkpoint\n** completes into mem[P3+2].  However on an error, mem[P3+1] and\n** mem[P3+2] are initialized to -1.\n*/\ncase OP_Checkpoint: {\n#if 0  /* local variables moved into u.cd */\n  int i;                          /* Loop counter */\n  int aRes[3];                    /* Results */\n  Mem *pMem;                      /* Write results here */\n#endif /* local variables moved into u.cd */\n\n  u.cd.aRes[0] = 0;\n  u.cd.aRes[1] = u.cd.aRes[2] = -1;\n  assert( pOp->p2==SQLITE_CHECKPOINT_PASSIVE\n       || pOp->p2==SQLITE_CHECKPOINT_FULL\n       || pOp->p2==SQLITE_CHECKPOINT_RESTART\n  );\n  rc = sqlite3Checkpoint(db, pOp->p1, pOp->p2, &u.cd.aRes[1], &u.cd.aRes[2]);\n  if( rc==SQLITE_BUSY ){\n    rc = SQLITE_OK;\n    u.cd.aRes[0] = 1;\n  }\n  for(u.cd.i=0, u.cd.pMem = &aMem[pOp->p3]; u.cd.i<3; u.cd.i++, u.cd.pMem++){\n    sqlite3VdbeMemSetInt64(u.cd.pMem, (i64)u.cd.aRes[u.cd.i]);\n  }\n  break;\n};  \n#endif\n\n#ifndef SQLITE_OMIT_PRAGMA\n/* Opcode: JournalMode P1 P2 P3 * P5\n**\n** Change the journal mode of database P1 to P3. P3 must be one of the\n** PAGER_JOURNALMODE_XXX values. If changing between the various rollback\n** modes (delete, truncate, persist, off and memory), this is a simple\n** operation. No IO is required.\n**\n** If changing into or out of WAL mode the procedure is more complicated.\n**\n** Write a string containing the final journal-mode to register P2.\n*/\ncase OP_JournalMode: {    /* out2-prerelease */\n#if 0  /* local variables moved into u.ce */\n  Btree *pBt;                     /* Btree to change journal mode of */\n  Pager *pPager;                  /* Pager associated with pBt */\n  int eNew;                       /* New journal mode */\n  int eOld;                       /* The old journal mode */\n  const char *zFilename;          /* Name of database file for pPager */\n#endif /* local variables moved into u.ce */\n\n  u.ce.eNew = pOp->p3;\n  assert( u.ce.eNew==PAGER_JOURNALMODE_DELETE\n       || u.ce.eNew==PAGER_JOURNALMODE_TRUNCATE\n       || u.ce.eNew==PAGER_JOURNALMODE_PERSIST\n       || u.ce.eNew==PAGER_JOURNALMODE_OFF\n       || u.ce.eNew==PAGER_JOURNALMODE_MEMORY\n       || u.ce.eNew==PAGER_JOURNALMODE_WAL\n       || u.ce.eNew==PAGER_JOURNALMODE_QUERY\n  );\n  assert( pOp->p1>=0 && pOp->p1<db->nDb );\n\n  /* This opcode is used in two places: PRAGMA journal_mode and ATTACH.\n  ** In PRAGMA journal_mode, the sqlite3VdbeUsesBtree() routine is called\n  ** when the statment is prepared and so p->aMutex.nMutex>0.  All mutexes\n  ** are already acquired.  But when used in ATTACH, sqlite3VdbeUsesBtree()\n  ** is not called when the statement is prepared because it requires the\n  ** iDb index of the database as a parameter, and the database has not\n  ** yet been attached so that index is unavailable.  We have to wait\n  ** until runtime (now) to get the mutex on the newly attached database.\n  ** No other mutexes are required by the ATTACH command so this is safe\n  ** to do.\n  */\n  assert( (p->btreeMask & (1<<pOp->p1))!=0 || p->aMutex.nMutex==0 );\n  if( p->aMutex.nMutex==0 ){\n    /* This occurs right after ATTACH.  Get a mutex on the newly ATTACHed\n    ** database. */\n    sqlite3VdbeUsesBtree(p, pOp->p1);\n    sqlite3VdbeMutexArrayEnter(p);\n  }\n\n  u.ce.pBt = db->aDb[pOp->p1].pBt;\n  u.ce.pPager = sqlite3BtreePager(u.ce.pBt);\n  u.ce.eOld = sqlite3PagerGetJournalMode(u.ce.pPager);\n  if( u.ce.eNew==PAGER_JOURNALMODE_QUERY ) u.ce.eNew = u.ce.eOld;\n  if( !sqlite3PagerOkToChangeJournalMode(u.ce.pPager) ) u.ce.eNew = u.ce.eOld;\n\n#ifndef SQLITE_OMIT_WAL\n  u.ce.zFilename = sqlite3PagerFilename(u.ce.pPager);\n\n  /* Do not allow a transition to journal_mode=WAL for a database\n  ** in temporary storage or if the VFS does not support shared memory\n  */\n  if( u.ce.eNew==PAGER_JOURNALMODE_WAL\n   && (u.ce.zFilename[0]==0                         /* Temp file */\n       || !sqlite3PagerWalSupported(u.ce.pPager))   /* No shared-memory support */\n  ){\n    u.ce.eNew = u.ce.eOld;\n  }\n\n  if( (u.ce.eNew!=u.ce.eOld)\n   && (u.ce.eOld==PAGER_JOURNALMODE_WAL || u.ce.eNew==PAGER_JOURNALMODE_WAL)\n  ){\n    if( !db->autoCommit || db->activeVdbeCnt>1 ){\n      rc = SQLITE_ERROR;\n      sqlite3SetString(&p->zErrMsg, db,\n          \"cannot change %s wal mode from within a transaction\",\n          (u.ce.eNew==PAGER_JOURNALMODE_WAL ? \"into\" : \"out of\")\n      );\n      break;\n    }else{\n\n      if( u.ce.eOld==PAGER_JOURNALMODE_WAL ){\n        /* If leaving WAL mode, close the log file. If successful, the call\n        ** to PagerCloseWal() checkpoints and deletes the write-ahead-log\n        ** file. An EXCLUSIVE lock may still be held on the database file\n        ** after a successful return.\n        */\n        rc = sqlite3PagerCloseWal(u.ce.pPager);\n        if( rc==SQLITE_OK ){\n          sqlite3PagerSetJournalMode(u.ce.pPager, u.ce.eNew);\n        }\n      }else if( u.ce.eOld==PAGER_JOURNALMODE_MEMORY ){\n        /* Cannot transition directly from MEMORY to WAL.  Use mode OFF\n        ** as an intermediate */\n        sqlite3PagerSetJournalMode(u.ce.pPager, PAGER_JOURNALMODE_OFF);\n      }\n\n      /* Open a transaction on the database file. Regardless of the journal\n      ** mode, this transaction always uses a rollback journal.\n      */\n      assert( sqlite3BtreeIsInTrans(u.ce.pBt)==0 );\n      if( rc==SQLITE_OK ){\n        rc = sqlite3BtreeSetVersion(u.ce.pBt, (u.ce.eNew==PAGER_JOURNALMODE_WAL ? 2 : 1));\n      }\n    }\n  }\n#endif /* ifndef SQLITE_OMIT_WAL */\n\n  if( rc ){\n    u.ce.eNew = u.ce.eOld;\n  }\n  u.ce.eNew = sqlite3PagerSetJournalMode(u.ce.pPager, u.ce.eNew);\n\n  pOut = &aMem[pOp->p2];\n  pOut->flags = MEM_Str|MEM_Static|MEM_Term;\n  pOut->z = (char *)sqlite3JournalModename(u.ce.eNew);\n  pOut->n = sqlite3Strlen30(pOut->z);\n  pOut->enc = SQLITE_UTF8;\n  sqlite3VdbeChangeEncoding(pOut, encoding);\n  break;\n};\n#endif /* SQLITE_OMIT_PRAGMA */\n\n#if !defined(SQLITE_OMIT_VACUUM) && !defined(SQLITE_OMIT_ATTACH)\n/* Opcode: Vacuum * * * * *\n**\n** Vacuum the entire database.  This opcode will cause other virtual\n** machines to be created and run.  It may not be called from within\n** a transaction.\n*/\ncase OP_Vacuum: {\n  rc = sqlite3RunVacuum(&p->zErrMsg, db);\n  break;\n}\n#endif\n\n#if !defined(SQLITE_OMIT_AUTOVACUUM)\n/* Opcode: IncrVacuum P1 P2 * * *\n**\n** Perform a single step of the incremental vacuum procedure on\n** the P1 database. If the vacuum has finished, jump to instruction\n** P2. Otherwise, fall through to the next instruction.\n*/\ncase OP_IncrVacuum: {        /* jump */\n#if 0  /* local variables moved into u.cf */\n  Btree *pBt;\n#endif /* local variables moved into u.cf */\n\n  assert( pOp->p1>=0 && pOp->p1<db->nDb );\n  assert( (p->btreeMask & (1<<pOp->p1))!=0 );\n  u.cf.pBt = db->aDb[pOp->p1].pBt;\n  rc = sqlite3BtreeIncrVacuum(u.cf.pBt);\n  if( rc==SQLITE_DONE ){\n    pc = pOp->p2 - 1;\n    rc = SQLITE_OK;\n  }\n  break;\n}\n#endif\n\n/* Opcode: Expire P1 * * * *\n**\n** Cause precompiled statements to become expired. An expired statement\n** fails with an error code of SQLITE_SCHEMA if it is ever executed \n** (via sqlite3_step()).\n** \n** If P1 is 0, then all SQL statements become expired. If P1 is non-zero,\n** then only the currently executing statement is affected. \n*/\ncase OP_Expire: {\n  if( !pOp->p1 ){\n    sqlite3ExpirePreparedStatements(db);\n  }else{\n    p->expired = 1;\n  }\n  break;\n}\n\n#ifndef SQLITE_OMIT_SHARED_CACHE\n/* Opcode: TableLock P1 P2 P3 P4 *\n**\n** Obtain a lock on a particular table. This instruction is only used when\n** the shared-cache feature is enabled. \n**\n** P1 is the index of the database in sqlite3.aDb[] of the database\n** on which the lock is acquired.  A readlock is obtained if P3==0 or\n** a write lock if P3==1.\n**\n** P2 contains the root-page of the table to lock.\n**\n** P4 contains a pointer to the name of the table being locked. This is only\n** used to generate an error message if the lock cannot be obtained.\n*/\ncase OP_TableLock: {\n  u8 isWriteLock = (u8)pOp->p3;\n  if( isWriteLock || 0==(db->flags&SQLITE_ReadUncommitted) ){\n    int p1 = pOp->p1; \n    assert( p1>=0 && p1<db->nDb );\n    assert( (p->btreeMask & (1<<p1))!=0 );\n    assert( isWriteLock==0 || isWriteLock==1 );\n    rc = sqlite3BtreeLockTable(db->aDb[p1].pBt, pOp->p2, isWriteLock);\n    if( (rc&0xFF)==SQLITE_LOCKED ){\n      const char *z = pOp->p4.z;\n      sqlite3SetString(&p->zErrMsg, db, \"database table is locked: %s\", z);\n    }\n  }\n  break;\n}\n#endif /* SQLITE_OMIT_SHARED_CACHE */\n\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n/* Opcode: VBegin * * * P4 *\n**\n** P4 may be a pointer to an sqlite3_vtab structure. If so, call the \n** xBegin method for that table.\n**\n** Also, whether or not P4 is set, check that this is not being called from\n** within a callback to a virtual table xSync() method. If it is, the error\n** code will be set to SQLITE_LOCKED.\n*/\ncase OP_VBegin: {\n#if 0  /* local variables moved into u.cg */\n  VTable *pVTab;\n#endif /* local variables moved into u.cg */\n  u.cg.pVTab = pOp->p4.pVtab;\n  rc = sqlite3VtabBegin(db, u.cg.pVTab);\n  if( u.cg.pVTab ) importVtabErrMsg(p, u.cg.pVTab->pVtab);\n  break;\n}\n#endif /* SQLITE_OMIT_VIRTUALTABLE */\n\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n/* Opcode: VCreate P1 * * P4 *\n**\n** P4 is the name of a virtual table in database P1. Call the xCreate method\n** for that table.\n*/\ncase OP_VCreate: {\n  rc = sqlite3VtabCallCreate(db, pOp->p1, pOp->p4.z, &p->zErrMsg);\n  break;\n}\n#endif /* SQLITE_OMIT_VIRTUALTABLE */\n\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n/* Opcode: VDestroy P1 * * P4 *\n**\n** P4 is the name of a virtual table in database P1.  Call the xDestroy method\n** of that table.\n*/\ncase OP_VDestroy: {\n  p->inVtabMethod = 2;\n  rc = sqlite3VtabCallDestroy(db, pOp->p1, pOp->p4.z);\n  p->inVtabMethod = 0;\n  break;\n}\n#endif /* SQLITE_OMIT_VIRTUALTABLE */\n\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n/* Opcode: VOpen P1 * * P4 *\n**\n** P4 is a pointer to a virtual table object, an sqlite3_vtab structure.\n** P1 is a cursor number.  This opcode opens a cursor to the virtual\n** table and stores that cursor in P1.\n*/\ncase OP_VOpen: {\n#if 0  /* local variables moved into u.ch */\n  VdbeCursor *pCur;\n  sqlite3_vtab_cursor *pVtabCursor;\n  sqlite3_vtab *pVtab;\n  sqlite3_module *pModule;\n#endif /* local variables moved into u.ch */\n\n  u.ch.pCur = 0;\n  u.ch.pVtabCursor = 0;\n  u.ch.pVtab = pOp->p4.pVtab->pVtab;\n  u.ch.pModule = (sqlite3_module *)u.ch.pVtab->pModule;\n  assert(u.ch.pVtab && u.ch.pModule);\n  rc = u.ch.pModule->xOpen(u.ch.pVtab, &u.ch.pVtabCursor);\n  importVtabErrMsg(p, u.ch.pVtab);\n  if( SQLITE_OK==rc ){\n    /* Initialize sqlite3_vtab_cursor base class */\n    u.ch.pVtabCursor->pVtab = u.ch.pVtab;\n\n    /* Initialise vdbe cursor object */\n    u.ch.pCur = allocateCursor(p, pOp->p1, 0, -1, 0);\n    if( u.ch.pCur ){\n      u.ch.pCur->pVtabCursor = u.ch.pVtabCursor;\n      u.ch.pCur->pModule = u.ch.pVtabCursor->pVtab->pModule;\n    }else{\n      db->mallocFailed = 1;\n      u.ch.pModule->xClose(u.ch.pVtabCursor);\n    }\n  }\n  break;\n}\n#endif /* SQLITE_OMIT_VIRTUALTABLE */\n\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n/* Opcode: VFilter P1 P2 P3 P4 *\n**\n** P1 is a cursor opened using VOpen.  P2 is an address to jump to if\n** the filtered result set is empty.\n**\n** P4 is either NULL or a string that was generated by the xBestIndex\n** method of the module.  The interpretation of the P4 string is left\n** to the module implementation.\n**\n** This opcode invokes the xFilter method on the virtual table specified\n** by P1.  The integer query plan parameter to xFilter is stored in register\n** P3. Register P3+1 stores the argc parameter to be passed to the\n** xFilter method. Registers P3+2..P3+1+argc are the argc\n** additional parameters which are passed to\n** xFilter as argv. Register P3+2 becomes argv[0] when passed to xFilter.\n**\n** A jump is made to P2 if the result set after filtering would be empty.\n*/\ncase OP_VFilter: {   /* jump */\n#if 0  /* local variables moved into u.ci */\n  int nArg;\n  int iQuery;\n  const sqlite3_module *pModule;\n  Mem *pQuery;\n  Mem *pArgc;\n  sqlite3_vtab_cursor *pVtabCursor;\n  sqlite3_vtab *pVtab;\n  VdbeCursor *pCur;\n  int res;\n  int i;\n  Mem **apArg;\n#endif /* local variables moved into u.ci */\n\n  u.ci.pQuery = &aMem[pOp->p3];\n  u.ci.pArgc = &u.ci.pQuery[1];\n  u.ci.pCur = p->apCsr[pOp->p1];\n  assert( memIsValid(u.ci.pQuery) );\n  REGISTER_TRACE(pOp->p3, u.ci.pQuery);\n  assert( u.ci.pCur->pVtabCursor );\n  u.ci.pVtabCursor = u.ci.pCur->pVtabCursor;\n  u.ci.pVtab = u.ci.pVtabCursor->pVtab;\n  u.ci.pModule = u.ci.pVtab->pModule;\n\n  /* Grab the index number and argc parameters */\n  assert( (u.ci.pQuery->flags&MEM_Int)!=0 && u.ci.pArgc->flags==MEM_Int );\n  u.ci.nArg = (int)u.ci.pArgc->u.i;\n  u.ci.iQuery = (int)u.ci.pQuery->u.i;\n\n  /* Invoke the xFilter method */\n  {\n    u.ci.res = 0;\n    u.ci.apArg = p->apArg;\n    for(u.ci.i = 0; u.ci.i<u.ci.nArg; u.ci.i++){\n      u.ci.apArg[u.ci.i] = &u.ci.pArgc[u.ci.i+1];\n      sqlite3VdbeMemStoreType(u.ci.apArg[u.ci.i]);\n    }\n\n    p->inVtabMethod = 1;\n    rc = u.ci.pModule->xFilter(u.ci.pVtabCursor, u.ci.iQuery, pOp->p4.z, u.ci.nArg, u.ci.apArg);\n    p->inVtabMethod = 0;\n    importVtabErrMsg(p, u.ci.pVtab);\n    if( rc==SQLITE_OK ){\n      u.ci.res = u.ci.pModule->xEof(u.ci.pVtabCursor);\n    }\n\n    if( u.ci.res ){\n      pc = pOp->p2 - 1;\n    }\n  }\n  u.ci.pCur->nullRow = 0;\n\n  break;\n}\n#endif /* SQLITE_OMIT_VIRTUALTABLE */\n\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n/* Opcode: VColumn P1 P2 P3 * *\n**\n** Store the value of the P2-th column of\n** the row of the virtual-table that the \n** P1 cursor is pointing to into register P3.\n*/\ncase OP_VColumn: {\n#if 0  /* local variables moved into u.cj */\n  sqlite3_vtab *pVtab;\n  const sqlite3_module *pModule;\n  Mem *pDest;\n  sqlite3_context sContext;\n#endif /* local variables moved into u.cj */\n\n  VdbeCursor *pCur = p->apCsr[pOp->p1];\n  assert( pCur->pVtabCursor );\n  assert( pOp->p3>0 && pOp->p3<=p->nMem );\n  u.cj.pDest = &aMem[pOp->p3];\n  memAboutToChange(p, u.cj.pDest);\n  if( pCur->nullRow ){\n    sqlite3VdbeMemSetNull(u.cj.pDest);\n    break;\n  }\n  u.cj.pVtab = pCur->pVtabCursor->pVtab;\n  u.cj.pModule = u.cj.pVtab->pModule;\n  assert( u.cj.pModule->xColumn );\n  memset(&u.cj.sContext, 0, sizeof(u.cj.sContext));\n\n  /* The output cell may already have a buffer allocated. Move\n  ** the current contents to u.cj.sContext.s so in case the user-function\n  ** can use the already allocated buffer instead of allocating a\n  ** new one.\n  */\n  sqlite3VdbeMemMove(&u.cj.sContext.s, u.cj.pDest);\n  MemSetTypeFlag(&u.cj.sContext.s, MEM_Null);\n\n  rc = u.cj.pModule->xColumn(pCur->pVtabCursor, &u.cj.sContext, pOp->p2);\n  importVtabErrMsg(p, u.cj.pVtab);\n  if( u.cj.sContext.isError ){\n    rc = u.cj.sContext.isError;\n  }\n\n  /* Copy the result of the function to the P3 register. We\n  ** do this regardless of whether or not an error occurred to ensure any\n  ** dynamic allocation in u.cj.sContext.s (a Mem struct) is  released.\n  */\n  sqlite3VdbeChangeEncoding(&u.cj.sContext.s, encoding);\n  sqlite3VdbeMemMove(u.cj.pDest, &u.cj.sContext.s);\n  REGISTER_TRACE(pOp->p3, u.cj.pDest);\n  UPDATE_MAX_BLOBSIZE(u.cj.pDest);\n\n  if( sqlite3VdbeMemTooBig(u.cj.pDest) ){\n    goto too_big;\n  }\n  break;\n}\n#endif /* SQLITE_OMIT_VIRTUALTABLE */\n\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n/* Opcode: VNext P1 P2 * * *\n**\n** Advance virtual table P1 to the next row in its result set and\n** jump to instruction P2.  Or, if the virtual table has reached\n** the end of its result set, then fall through to the next instruction.\n*/\ncase OP_VNext: {   /* jump */\n#if 0  /* local variables moved into u.ck */\n  sqlite3_vtab *pVtab;\n  const sqlite3_module *pModule;\n  int res;\n  VdbeCursor *pCur;\n#endif /* local variables moved into u.ck */\n\n  u.ck.res = 0;\n  u.ck.pCur = p->apCsr[pOp->p1];\n  assert( u.ck.pCur->pVtabCursor );\n  if( u.ck.pCur->nullRow ){\n    break;\n  }\n  u.ck.pVtab = u.ck.pCur->pVtabCursor->pVtab;\n  u.ck.pModule = u.ck.pVtab->pModule;\n  assert( u.ck.pModule->xNext );\n\n  /* Invoke the xNext() method of the module. There is no way for the\n  ** underlying implementation to return an error if one occurs during\n  ** xNext(). Instead, if an error occurs, true is returned (indicating that\n  ** data is available) and the error code returned when xColumn or\n  ** some other method is next invoked on the save virtual table cursor.\n  */\n  p->inVtabMethod = 1;\n  rc = u.ck.pModule->xNext(u.ck.pCur->pVtabCursor);\n  p->inVtabMethod = 0;\n  importVtabErrMsg(p, u.ck.pVtab);\n  if( rc==SQLITE_OK ){\n    u.ck.res = u.ck.pModule->xEof(u.ck.pCur->pVtabCursor);\n  }\n\n  if( !u.ck.res ){\n    /* If there is data, jump to P2 */\n    pc = pOp->p2 - 1;\n  }\n  break;\n}\n#endif /* SQLITE_OMIT_VIRTUALTABLE */\n\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n/* Opcode: VRename P1 * * P4 *\n**\n** P4 is a pointer to a virtual table object, an sqlite3_vtab structure.\n** This opcode invokes the corresponding xRename method. The value\n** in register P1 is passed as the zName argument to the xRename method.\n*/\ncase OP_VRename: {\n#if 0  /* local variables moved into u.cl */\n  sqlite3_vtab *pVtab;\n  Mem *pName;\n#endif /* local variables moved into u.cl */\n\n  u.cl.pVtab = pOp->p4.pVtab->pVtab;\n  u.cl.pName = &aMem[pOp->p1];\n  assert( u.cl.pVtab->pModule->xRename );\n  assert( memIsValid(u.cl.pName) );\n  REGISTER_TRACE(pOp->p1, u.cl.pName);\n  assert( u.cl.pName->flags & MEM_Str );\n  rc = u.cl.pVtab->pModule->xRename(u.cl.pVtab, u.cl.pName->z);\n  importVtabErrMsg(p, u.cl.pVtab);\n  p->expired = 0;\n\n  break;\n}\n#endif\n\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n/* Opcode: VUpdate P1 P2 P3 P4 *\n**\n** P4 is a pointer to a virtual table object, an sqlite3_vtab structure.\n** This opcode invokes the corresponding xUpdate method. P2 values\n** are contiguous memory cells starting at P3 to pass to the xUpdate \n** invocation. The value in register (P3+P2-1) corresponds to the \n** p2th element of the argv array passed to xUpdate.\n**\n** The xUpdate method will do a DELETE or an INSERT or both.\n** The argv[0] element (which corresponds to memory cell P3)\n** is the rowid of a row to delete.  If argv[0] is NULL then no \n** deletion occurs.  The argv[1] element is the rowid of the new \n** row.  This can be NULL to have the virtual table select the new \n** rowid for itself.  The subsequent elements in the array are \n** the values of columns in the new row.\n**\n** If P2==1 then no insert is performed.  argv[0] is the rowid of\n** a row to delete.\n**\n** P1 is a boolean flag. If it is set to true and the xUpdate call\n** is successful, then the value returned by sqlite3_last_insert_rowid() \n** is set to the value of the rowid for the row just inserted.\n*/\ncase OP_VUpdate: {\n#if 0  /* local variables moved into u.cm */\n  sqlite3_vtab *pVtab;\n  sqlite3_module *pModule;\n  int nArg;\n  int i;\n  sqlite_int64 rowid;\n  Mem **apArg;\n  Mem *pX;\n#endif /* local variables moved into u.cm */\n\n  u.cm.pVtab = pOp->p4.pVtab->pVtab;\n  u.cm.pModule = (sqlite3_module *)u.cm.pVtab->pModule;\n  u.cm.nArg = pOp->p2;\n  assert( pOp->p4type==P4_VTAB );\n  if( ALWAYS(u.cm.pModule->xUpdate) ){\n    u.cm.apArg = p->apArg;\n    u.cm.pX = &aMem[pOp->p3];\n    for(u.cm.i=0; u.cm.i<u.cm.nArg; u.cm.i++){\n      assert( memIsValid(u.cm.pX) );\n      memAboutToChange(p, u.cm.pX);\n      sqlite3VdbeMemStoreType(u.cm.pX);\n      u.cm.apArg[u.cm.i] = u.cm.pX;\n      u.cm.pX++;\n    }\n    rc = u.cm.pModule->xUpdate(u.cm.pVtab, u.cm.nArg, u.cm.apArg, &u.cm.rowid);\n    importVtabErrMsg(p, u.cm.pVtab);\n    if( rc==SQLITE_OK && pOp->p1 ){\n      assert( u.cm.nArg>1 && u.cm.apArg[0] && (u.cm.apArg[0]->flags&MEM_Null) );\n      db->lastRowid = u.cm.rowid;\n    }\n    p->nChange++;\n  }\n  break;\n}\n#endif /* SQLITE_OMIT_VIRTUALTABLE */\n\n#ifndef  SQLITE_OMIT_PAGER_PRAGMAS\n/* Opcode: Pagecount P1 P2 * * *\n**\n** Write the current number of pages in database P1 to memory cell P2.\n*/\ncase OP_Pagecount: {            /* out2-prerelease */\n  pOut->u.i = sqlite3BtreeLastPage(db->aDb[pOp->p1].pBt);\n  break;\n}\n#endif\n\n\n#ifndef  SQLITE_OMIT_PAGER_PRAGMAS\n/* Opcode: MaxPgcnt P1 P2 P3 * *\n**\n** Try to set the maximum page count for database P1 to the value in P3.\n** Do not let the maximum page count fall below the current page count and\n** do not change the maximum page count value if P3==0.\n**\n** Store the maximum page count after the change in register P2.\n*/\ncase OP_MaxPgcnt: {            /* out2-prerelease */\n  unsigned int newMax;\n  Btree *pBt;\n\n  pBt = db->aDb[pOp->p1].pBt;\n  newMax = 0;\n  if( pOp->p3 ){\n    newMax = sqlite3BtreeLastPage(pBt);\n    if( newMax < (unsigned)pOp->p3 ) newMax = (unsigned)pOp->p3;\n  }\n  pOut->u.i = sqlite3BtreeMaxPageCount(pBt, newMax);\n  break;\n}\n#endif\n\n\n#ifndef SQLITE_OMIT_TRACE\n/* Opcode: Trace * * * P4 *\n**\n** If tracing is enabled (by the sqlite3_trace()) interface, then\n** the UTF-8 string contained in P4 is emitted on the trace callback.\n*/\ncase OP_Trace: {\n#if 0  /* local variables moved into u.cn */\n  char *zTrace;\n#endif /* local variables moved into u.cn */\n\n  u.cn.zTrace = (pOp->p4.z ? pOp->p4.z : p->zSql);\n  if( u.cn.zTrace ){\n    if( db->xTrace ){\n      char *z = sqlite3VdbeExpandSql(p, u.cn.zTrace);\n      db->xTrace(db->pTraceArg, z);\n      sqlite3DbFree(db, z);\n    }\n#ifdef SQLITE_DEBUG\n    if( (db->flags & SQLITE_SqlTrace)!=0 ){\n      sqlite3DebugPrintf(\"SQL-trace: %s\\n\", u.cn.zTrace);\n    }\n#endif /* SQLITE_DEBUG */\n  }\n  break;\n}\n#endif\n\n\n/* Opcode: Noop * * * * *\n**\n** Do nothing.  This instruction is often useful as a jump\n** destination.\n*/\n/*\n** The magic Explain opcode are only inserted when explain==2 (which\n** is to say when the EXPLAIN QUERY PLAN syntax is used.)\n** This opcode records information from the optimizer.  It is the\n** the same as a no-op.  This opcodesnever appears in a real VM program.\n*/\ndefault: {          /* This is really OP_Noop and OP_Explain */\n  assert( pOp->opcode==OP_Noop || pOp->opcode==OP_Explain );\n  break;\n}\n\n/*****************************************************************************\n** The cases of the switch statement above this line should all be indented\n** by 6 spaces.  But the left-most 6 spaces have been removed to improve the\n** readability.  From this point on down, the normal indentation rules are\n** restored.\n*****************************************************************************/\n    }\n\n#ifdef VDBE_PROFILE\n    {\n      u64 elapsed = sqlite3Hwtime() - start;\n      pOp->cycles += elapsed;\n      pOp->cnt++;\n#if 0\n        fprintf(stdout, \"%10llu \", elapsed);\n        sqlite3VdbePrintOp(stdout, origPc, &aOp[origPc]);\n#endif\n    }\n#endif\n\n    /* The following code adds nothing to the actual functionality\n    ** of the program.  It is only here for testing and debugging.\n    ** On the other hand, it does burn CPU cycles every time through\n    ** the evaluator loop.  So we can leave it out when NDEBUG is defined.\n    */\n#ifndef NDEBUG\n    assert( pc>=-1 && pc<p->nOp );\n\n#ifdef SQLITE_DEBUG\n    if( p->trace ){\n      if( rc!=0 ) fprintf(p->trace,\"rc=%d\\n\",rc);\n      if( pOp->opflags & (OPFLG_OUT2_PRERELEASE|OPFLG_OUT2) ){\n        registerTrace(p->trace, pOp->p2, &aMem[pOp->p2]);\n      }\n      if( pOp->opflags & OPFLG_OUT3 ){\n        registerTrace(p->trace, pOp->p3, &aMem[pOp->p3]);\n      }\n    }\n#endif  /* SQLITE_DEBUG */\n#endif  /* NDEBUG */\n  }  /* The end of the for(;;) loop the loops through opcodes */\n\n  /* If we reach this point, it means that execution is finished with\n  ** an error of some kind.\n  */\nvdbe_error_halt:\n  assert( rc );\n  p->rc = rc;\n  testcase( sqlite3GlobalConfig.xLog!=0 );\n  sqlite3_log(rc, \"statement aborts at %d: [%s] %s\", \n                   pc, p->zSql, p->zErrMsg);\n  sqlite3VdbeHalt(p);\n  if( rc==SQLITE_IOERR_NOMEM ) db->mallocFailed = 1;\n  rc = SQLITE_ERROR;\n  if( resetSchemaOnFault ) sqlite3ResetInternalSchema(db, 0);\n\n  /* This is the only way out of this procedure.  We have to\n  ** release the mutexes on btrees that were acquired at the\n  ** top. */\nvdbe_return:\n  sqlite3BtreeMutexArrayLeave(&p->aMutex);\n  return rc;\n\n  /* Jump to here if a string or blob larger than SQLITE_MAX_LENGTH\n  ** is encountered.\n  */\ntoo_big:\n  sqlite3SetString(&p->zErrMsg, db, \"string or blob too big\");\n  rc = SQLITE_TOOBIG;\n  goto vdbe_error_halt;\n\n  /* Jump to here if a malloc() fails.\n  */\nno_mem:\n  db->mallocFailed = 1;\n  sqlite3SetString(&p->zErrMsg, db, \"out of memory\");\n  rc = SQLITE_NOMEM;\n  goto vdbe_error_halt;\n\n  /* Jump to here for any other kind of fatal error.  The \"rc\" variable\n  ** should hold the error number.\n  */\nabort_due_to_error:\n  assert( p->zErrMsg==0 );\n  if( db->mallocFailed ) rc = SQLITE_NOMEM;\n  if( rc!=SQLITE_IOERR_NOMEM ){\n    sqlite3SetString(&p->zErrMsg, db, \"%s\", sqlite3ErrStr(rc));\n  }\n  goto vdbe_error_halt;\n\n  /* Jump to here if the sqlite3_interrupt() API sets the interrupt\n  ** flag.\n  */\nabort_due_to_interrupt:\n  assert( db->u1.isInterrupted );\n  rc = SQLITE_INTERRUPT;\n  p->rc = rc;\n  sqlite3SetString(&p->zErrMsg, db, \"%s\", sqlite3ErrStr(rc));\n  goto vdbe_error_halt;\n}\n\n/************** End of vdbe.c ************************************************/\n/************** Begin file vdbeblob.c ****************************************/\n/*\n** 2007 May 1\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n**\n** This file contains code used to implement incremental BLOB I/O.\n*/\n\n\n#ifndef SQLITE_OMIT_INCRBLOB\n\n/*\n** Valid sqlite3_blob* handles point to Incrblob structures.\n*/\ntypedef struct Incrblob Incrblob;\nstruct Incrblob {\n  int flags;              /* Copy of \"flags\" passed to sqlite3_blob_open() */\n  int nByte;              /* Size of open blob, in bytes */\n  int iOffset;            /* Byte offset of blob in cursor data */\n  int iCol;               /* Table column this handle is open on */\n  BtCursor *pCsr;         /* Cursor pointing at blob row */\n  sqlite3_stmt *pStmt;    /* Statement holding cursor open */\n  sqlite3 *db;            /* The associated database */\n};\n\n\n/*\n** This function is used by both blob_open() and blob_reopen(). It seeks\n** the b-tree cursor associated with blob handle p to point to row iRow.\n** If successful, SQLITE_OK is returned and subsequent calls to\n** sqlite3_blob_read() or sqlite3_blob_write() access the specified row.\n**\n** If an error occurs, or if the specified row does not exist or does not\n** contain a value of type TEXT or BLOB in the column nominated when the\n** blob handle was opened, then an error code is returned and *pzErr may\n** be set to point to a buffer containing an error message. It is the\n** responsibility of the caller to free the error message buffer using\n** sqlite3DbFree().\n**\n** If an error does occur, then the b-tree cursor is closed. All subsequent\n** calls to sqlite3_blob_read(), blob_write() or blob_reopen() will \n** immediately return SQLITE_ABORT.\n*/\nstatic int blobSeekToRow(Incrblob *p, sqlite3_int64 iRow, char **pzErr){\n  int rc;                         /* Error code */\n  char *zErr = 0;                 /* Error message */\n  Vdbe *v = (Vdbe *)p->pStmt;\n\n  /* Set the value of the SQL statements only variable to integer iRow. \n  ** This is done directly instead of using sqlite3_bind_int64() to avoid \n  ** triggering asserts related to mutexes.\n  */\n  assert( v->aVar[0].flags&MEM_Int );\n  v->aVar[0].u.i = iRow;\n\n  rc = sqlite3_step(p->pStmt);\n  if( rc==SQLITE_ROW ){\n    u32 type = v->apCsr[0]->aType[p->iCol];\n    if( type<12 ){\n      zErr = sqlite3MPrintf(p->db, \"cannot open value of type %s\",\n          type==0?\"null\": type==7?\"real\": \"integer\"\n      );\n      rc = SQLITE_ERROR;\n      sqlite3_finalize(p->pStmt);\n      p->pStmt = 0;\n    }else{\n      p->iOffset = v->apCsr[0]->aOffset[p->iCol];\n      p->nByte = sqlite3VdbeSerialTypeLen(type);\n      p->pCsr =  v->apCsr[0]->pCursor;\n      sqlite3BtreeEnterCursor(p->pCsr);\n      sqlite3BtreeCacheOverflow(p->pCsr);\n      sqlite3BtreeLeaveCursor(p->pCsr);\n    }\n  }\n\n  if( rc==SQLITE_ROW ){\n    rc = SQLITE_OK;\n  }else if( p->pStmt ){\n    rc = sqlite3_finalize(p->pStmt);\n    p->pStmt = 0;\n    if( rc==SQLITE_OK ){\n      zErr = sqlite3MPrintf(p->db, \"no such rowid: %lld\", iRow);\n      rc = SQLITE_ERROR;\n    }else{\n      zErr = sqlite3MPrintf(p->db, \"%s\", sqlite3_errmsg(p->db));\n    }\n  }\n\n  assert( rc!=SQLITE_OK || zErr==0 );\n  assert( rc!=SQLITE_ROW && rc!=SQLITE_DONE );\n\n  *pzErr = zErr;\n  return rc;\n}\n\n/*\n** Open a blob handle.\n*/\nSQLITE_API int sqlite3_blob_open(\n  sqlite3* db,            /* The database connection */\n  const char *zDb,        /* The attached database containing the blob */\n  const char *zTable,     /* The table containing the blob */\n  const char *zColumn,    /* The column containing the blob */\n  sqlite_int64 iRow,      /* The row containing the glob */\n  int flags,              /* True -> read/write access, false -> read-only */\n  sqlite3_blob **ppBlob   /* Handle for accessing the blob returned here */\n){\n  int nAttempt = 0;\n  int iCol;               /* Index of zColumn in row-record */\n\n  /* This VDBE program seeks a btree cursor to the identified \n  ** db/table/row entry. The reason for using a vdbe program instead\n  ** of writing code to use the b-tree layer directly is that the\n  ** vdbe program will take advantage of the various transaction,\n  ** locking and error handling infrastructure built into the vdbe.\n  **\n  ** After seeking the cursor, the vdbe executes an OP_ResultRow.\n  ** Code external to the Vdbe then \"borrows\" the b-tree cursor and\n  ** uses it to implement the blob_read(), blob_write() and \n  ** blob_bytes() functions.\n  **\n  ** The sqlite3_blob_close() function finalizes the vdbe program,\n  ** which closes the b-tree cursor and (possibly) commits the \n  ** transaction.\n  */\n  static const VdbeOpList openBlob[] = {\n    {OP_Transaction, 0, 0, 0},     /* 0: Start a transaction */\n    {OP_VerifyCookie, 0, 0, 0},    /* 1: Check the schema cookie */\n    {OP_TableLock, 0, 0, 0},       /* 2: Acquire a read or write lock */\n\n    /* One of the following two instructions is replaced by an OP_Noop. */\n    {OP_OpenRead, 0, 0, 0},        /* 3: Open cursor 0 for reading */\n    {OP_OpenWrite, 0, 0, 0},       /* 4: Open cursor 0 for read/write */\n\n    {OP_Variable, 1, 1, 1},        /* 5: Push the rowid to the stack */\n    {OP_NotExists, 0, 10, 1},      /* 6: Seek the cursor */\n    {OP_Column, 0, 0, 1},          /* 7  */\n    {OP_ResultRow, 1, 0, 0},       /* 8  */\n    {OP_Goto, 0, 5, 0},            /* 9  */\n    {OP_Close, 0, 0, 0},           /* 10 */\n    {OP_Halt, 0, 0, 0},            /* 11 */\n  };\n\n  int rc = SQLITE_OK;\n  char *zErr = 0;\n  Table *pTab;\n  Parse *pParse = 0;\n  Incrblob *pBlob = 0;\n\n  flags = !!flags;                /* flags = (flags ? 1 : 0); */\n  *ppBlob = 0;\n\n  sqlite3_mutex_enter(db->mutex);\n\n  pBlob = (Incrblob *)sqlite3DbMallocZero(db, sizeof(Incrblob));\n  if( !pBlob ) goto blob_open_out;\n  pParse = sqlite3StackAllocRaw(db, sizeof(*pParse));\n  if( !pParse ) goto blob_open_out;\n\n  do {\n    memset(pParse, 0, sizeof(Parse));\n    pParse->db = db;\n    sqlite3DbFree(db, zErr);\n    zErr = 0;\n\n    sqlite3BtreeEnterAll(db);\n    pTab = sqlite3LocateTable(pParse, 0, zTable, zDb);\n    if( pTab && IsVirtual(pTab) ){\n      pTab = 0;\n      sqlite3ErrorMsg(pParse, \"cannot open virtual table: %s\", zTable);\n    }\n#ifndef SQLITE_OMIT_VIEW\n    if( pTab && pTab->pSelect ){\n      pTab = 0;\n      sqlite3ErrorMsg(pParse, \"cannot open view: %s\", zTable);\n    }\n#endif\n    if( !pTab ){\n      if( pParse->zErrMsg ){\n        sqlite3DbFree(db, zErr);\n        zErr = pParse->zErrMsg;\n        pParse->zErrMsg = 0;\n      }\n      rc = SQLITE_ERROR;\n      sqlite3BtreeLeaveAll(db);\n      goto blob_open_out;\n    }\n\n    /* Now search pTab for the exact column. */\n    for(iCol=0; iCol<pTab->nCol; iCol++) {\n      if( sqlite3StrICmp(pTab->aCol[iCol].zName, zColumn)==0 ){\n        break;\n      }\n    }\n    if( iCol==pTab->nCol ){\n      sqlite3DbFree(db, zErr);\n      zErr = sqlite3MPrintf(db, \"no such column: \\\"%s\\\"\", zColumn);\n      rc = SQLITE_ERROR;\n      sqlite3BtreeLeaveAll(db);\n      goto blob_open_out;\n    }\n\n    /* If the value is being opened for writing, check that the\n    ** column is not indexed, and that it is not part of a foreign key. \n    ** It is against the rules to open a column to which either of these\n    ** descriptions applies for writing.  */\n    if( flags ){\n      const char *zFault = 0;\n      Index *pIdx;\n#ifndef SQLITE_OMIT_FOREIGN_KEY\n      if( db->flags&SQLITE_ForeignKeys ){\n        /* Check that the column is not part of an FK child key definition. It\n        ** is not necessary to check if it is part of a parent key, as parent\n        ** key columns must be indexed. The check below will pick up this \n        ** case.  */\n        FKey *pFKey;\n        for(pFKey=pTab->pFKey; pFKey; pFKey=pFKey->pNextFrom){\n          int j;\n          for(j=0; j<pFKey->nCol; j++){\n            if( pFKey->aCol[j].iFrom==iCol ){\n              zFault = \"foreign key\";\n            }\n          }\n        }\n      }\n#endif\n      for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){\n        int j;\n        for(j=0; j<pIdx->nColumn; j++){\n          if( pIdx->aiColumn[j]==iCol ){\n            zFault = \"indexed\";\n          }\n        }\n      }\n      if( zFault ){\n        sqlite3DbFree(db, zErr);\n        zErr = sqlite3MPrintf(db, \"cannot open %s column for writing\", zFault);\n        rc = SQLITE_ERROR;\n        sqlite3BtreeLeaveAll(db);\n        goto blob_open_out;\n      }\n    }\n\n    pBlob->pStmt = (sqlite3_stmt *)sqlite3VdbeCreate(db);\n    assert( pBlob->pStmt || db->mallocFailed );\n    if( pBlob->pStmt ){\n      Vdbe *v = (Vdbe *)pBlob->pStmt;\n      int iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n\n      sqlite3VdbeAddOpList(v, sizeof(openBlob)/sizeof(VdbeOpList), openBlob);\n\n\n      /* Configure the OP_Transaction */\n      sqlite3VdbeChangeP1(v, 0, iDb);\n      sqlite3VdbeChangeP2(v, 0, flags);\n\n      /* Configure the OP_VerifyCookie */\n      sqlite3VdbeChangeP1(v, 1, iDb);\n      sqlite3VdbeChangeP2(v, 1, pTab->pSchema->schema_cookie);\n\n      /* Make sure a mutex is held on the table to be accessed */\n      sqlite3VdbeUsesBtree(v, iDb); \n\n      /* Configure the OP_TableLock instruction */\n#ifdef SQLITE_OMIT_SHARED_CACHE\n      sqlite3VdbeChangeToNoop(v, 2, 1);\n#else\n      sqlite3VdbeChangeP1(v, 2, iDb);\n      sqlite3VdbeChangeP2(v, 2, pTab->tnum);\n      sqlite3VdbeChangeP3(v, 2, flags);\n      sqlite3VdbeChangeP4(v, 2, pTab->zName, P4_TRANSIENT);\n#endif\n\n      /* Remove either the OP_OpenWrite or OpenRead. Set the P2 \n      ** parameter of the other to pTab->tnum.  */\n      sqlite3VdbeChangeToNoop(v, 4 - flags, 1);\n      sqlite3VdbeChangeP2(v, 3 + flags, pTab->tnum);\n      sqlite3VdbeChangeP3(v, 3 + flags, iDb);\n\n      /* Configure the number of columns. Configure the cursor to\n      ** think that the table has one more column than it really\n      ** does. An OP_Column to retrieve this imaginary column will\n      ** always return an SQL NULL. This is useful because it means\n      ** we can invoke OP_Column to fill in the vdbe cursors type \n      ** and offset cache without causing any IO.\n      */\n      sqlite3VdbeChangeP4(v, 3+flags, SQLITE_INT_TO_PTR(pTab->nCol+1),P4_INT32);\n      sqlite3VdbeChangeP2(v, 7, pTab->nCol);\n      if( !db->mallocFailed ){\n        sqlite3VdbeMakeReady(v, 1, 1, 1, 0, 0, 0);\n      }\n    }\n   \n    pBlob->flags = flags;\n    pBlob->iCol = iCol;\n    pBlob->db = db;\n    sqlite3BtreeLeaveAll(db);\n    if( db->mallocFailed ){\n      goto blob_open_out;\n    }\n    sqlite3_bind_int64(pBlob->pStmt, 1, iRow);\n    rc = blobSeekToRow(pBlob, iRow, &zErr);\n  } while( (++nAttempt)<5 && rc==SQLITE_SCHEMA );\n\nblob_open_out:\n  if( rc==SQLITE_OK && db->mallocFailed==0 ){\n    *ppBlob = (sqlite3_blob *)pBlob;\n  }else{\n    if( pBlob && pBlob->pStmt ) sqlite3VdbeFinalize((Vdbe *)pBlob->pStmt);\n    sqlite3DbFree(db, pBlob);\n  }\n  sqlite3Error(db, rc, (zErr ? \"%s\" : 0), zErr);\n  sqlite3DbFree(db, zErr);\n  sqlite3StackFree(db, pParse);\n  rc = sqlite3ApiExit(db, rc);\n  sqlite3_mutex_leave(db->mutex);\n  return rc;\n}\n\n/*\n** Close a blob handle that was previously created using\n** sqlite3_blob_open().\n*/\nSQLITE_API int sqlite3_blob_close(sqlite3_blob *pBlob){\n  Incrblob *p = (Incrblob *)pBlob;\n  int rc;\n  sqlite3 *db;\n\n  if( p ){\n    db = p->db;\n    sqlite3_mutex_enter(db->mutex);\n    rc = sqlite3_finalize(p->pStmt);\n    sqlite3DbFree(db, p);\n    sqlite3_mutex_leave(db->mutex);\n  }else{\n    rc = SQLITE_OK;\n  }\n  return rc;\n}\n\n/*\n** Perform a read or write operation on a blob\n*/\nstatic int blobReadWrite(\n  sqlite3_blob *pBlob, \n  void *z, \n  int n, \n  int iOffset, \n  int (*xCall)(BtCursor*, u32, u32, void*)\n){\n  int rc;\n  Incrblob *p = (Incrblob *)pBlob;\n  Vdbe *v;\n  sqlite3 *db;\n\n  if( p==0 ) return SQLITE_MISUSE_BKPT;\n  db = p->db;\n  sqlite3_mutex_enter(db->mutex);\n  v = (Vdbe*)p->pStmt;\n\n  if( n<0 || iOffset<0 || (iOffset+n)>p->nByte ){\n    /* Request is out of range. Return a transient error. */\n    rc = SQLITE_ERROR;\n    sqlite3Error(db, SQLITE_ERROR, 0);\n  }else if( v==0 ){\n    /* If there is no statement handle, then the blob-handle has\n    ** already been invalidated. Return SQLITE_ABORT in this case.\n    */\n    rc = SQLITE_ABORT;\n  }else{\n    /* Call either BtreeData() or BtreePutData(). If SQLITE_ABORT is\n    ** returned, clean-up the statement handle.\n    */\n    assert( db == v->db );\n    sqlite3BtreeEnterCursor(p->pCsr);\n    rc = xCall(p->pCsr, iOffset+p->iOffset, n, z);\n    sqlite3BtreeLeaveCursor(p->pCsr);\n    if( rc==SQLITE_ABORT ){\n      sqlite3VdbeFinalize(v);\n      p->pStmt = 0;\n    }else{\n      db->errCode = rc;\n      v->rc = rc;\n    }\n  }\n  rc = sqlite3ApiExit(db, rc);\n  sqlite3_mutex_leave(db->mutex);\n  return rc;\n}\n\n/*\n** Read data from a blob handle.\n*/\nSQLITE_API int sqlite3_blob_read(sqlite3_blob *pBlob, void *z, int n, int iOffset){\n  return blobReadWrite(pBlob, z, n, iOffset, sqlite3BtreeData);\n}\n\n/*\n** Write data to a blob handle.\n*/\nSQLITE_API int sqlite3_blob_write(sqlite3_blob *pBlob, const void *z, int n, int iOffset){\n  return blobReadWrite(pBlob, (void *)z, n, iOffset, sqlite3BtreePutData);\n}\n\n/*\n** Query a blob handle for the size of the data.\n**\n** The Incrblob.nByte field is fixed for the lifetime of the Incrblob\n** so no mutex is required for access.\n*/\nSQLITE_API int sqlite3_blob_bytes(sqlite3_blob *pBlob){\n  Incrblob *p = (Incrblob *)pBlob;\n  return (p && p->pStmt) ? p->nByte : 0;\n}\n\n/*\n** Move an existing blob handle to point to a different row of the same\n** database table.\n**\n** If an error occurs, or if the specified row does not exist or does not\n** contain a blob or text value, then an error code is returned and the\n** database handle error code and message set. If this happens, then all \n** subsequent calls to sqlite3_blob_xxx() functions (except blob_close()) \n** immediately return SQLITE_ABORT.\n*/\nSQLITE_API int sqlite3_blob_reopen(sqlite3_blob *pBlob, sqlite3_int64 iRow){\n  int rc;\n  Incrblob *p = (Incrblob *)pBlob;\n  sqlite3 *db;\n\n  if( p==0 ) return SQLITE_MISUSE_BKPT;\n  db = p->db;\n  sqlite3_mutex_enter(db->mutex);\n\n  if( p->pStmt==0 ){\n    /* If there is no statement handle, then the blob-handle has\n    ** already been invalidated. Return SQLITE_ABORT in this case.\n    */\n    rc = SQLITE_ABORT;\n  }else{\n    char *zErr;\n    rc = blobSeekToRow(p, iRow, &zErr);\n    if( rc!=SQLITE_OK ){\n      sqlite3Error(db, rc, (zErr ? \"%s\" : 0), zErr);\n      sqlite3DbFree(db, zErr);\n    }\n    assert( rc!=SQLITE_SCHEMA );\n  }\n\n  rc = sqlite3ApiExit(db, rc);\n  assert( rc==SQLITE_OK || p->pStmt==0 );\n  sqlite3_mutex_leave(db->mutex);\n  return rc;\n}\n\n#endif /* #ifndef SQLITE_OMIT_INCRBLOB */\n\n/************** End of vdbeblob.c ********************************************/\n/************** Begin file journal.c *****************************************/\n/*\n** 2007 August 22\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n**\n** This file implements a special kind of sqlite3_file object used\n** by SQLite to create journal files if the atomic-write optimization\n** is enabled.\n**\n** The distinctive characteristic of this sqlite3_file is that the\n** actual on disk file is created lazily. When the file is created,\n** the caller specifies a buffer size for an in-memory buffer to\n** be used to service read() and write() requests. The actual file\n** on disk is not created or populated until either:\n**\n**   1) The in-memory representation grows too large for the allocated \n**      buffer, or\n**   2) The sqlite3JournalCreate() function is called.\n*/\n#ifdef SQLITE_ENABLE_ATOMIC_WRITE\n\n\n/*\n** A JournalFile object is a subclass of sqlite3_file used by\n** as an open file handle for journal files.\n*/\nstruct JournalFile {\n  sqlite3_io_methods *pMethod;    /* I/O methods on journal files */\n  int nBuf;                       /* Size of zBuf[] in bytes */\n  char *zBuf;                     /* Space to buffer journal writes */\n  int iSize;                      /* Amount of zBuf[] currently used */\n  int flags;                      /* xOpen flags */\n  sqlite3_vfs *pVfs;              /* The \"real\" underlying VFS */\n  sqlite3_file *pReal;            /* The \"real\" underlying file descriptor */\n  const char *zJournal;           /* Name of the journal file */\n};\ntypedef struct JournalFile JournalFile;\n\n/*\n** If it does not already exists, create and populate the on-disk file \n** for JournalFile p.\n*/\nstatic int createFile(JournalFile *p){\n  int rc = SQLITE_OK;\n  if( !p->pReal ){\n    sqlite3_file *pReal = (sqlite3_file *)&p[1];\n    rc = sqlite3OsOpen(p->pVfs, p->zJournal, pReal, p->flags, 0);\n    if( rc==SQLITE_OK ){\n      p->pReal = pReal;\n      if( p->iSize>0 ){\n        assert(p->iSize<=p->nBuf);\n        rc = sqlite3OsWrite(p->pReal, p->zBuf, p->iSize, 0);\n      }\n    }\n  }\n  return rc;\n}\n\n/*\n** Close the file.\n*/\nstatic int jrnlClose(sqlite3_file *pJfd){\n  JournalFile *p = (JournalFile *)pJfd;\n  if( p->pReal ){\n    sqlite3OsClose(p->pReal);\n  }\n  sqlite3_free(p->zBuf);\n  return SQLITE_OK;\n}\n\n/*\n** Read data from the file.\n*/\nstatic int jrnlRead(\n  sqlite3_file *pJfd,    /* The journal file from which to read */\n  void *zBuf,            /* Put the results here */\n  int iAmt,              /* Number of bytes to read */\n  sqlite_int64 iOfst     /* Begin reading at this offset */\n){\n  int rc = SQLITE_OK;\n  JournalFile *p = (JournalFile *)pJfd;\n  if( p->pReal ){\n    rc = sqlite3OsRead(p->pReal, zBuf, iAmt, iOfst);\n  }else if( (iAmt+iOfst)>p->iSize ){\n    rc = SQLITE_IOERR_SHORT_READ;\n  }else{\n    memcpy(zBuf, &p->zBuf[iOfst], iAmt);\n  }\n  return rc;\n}\n\n/*\n** Write data to the file.\n*/\nstatic int jrnlWrite(\n  sqlite3_file *pJfd,    /* The journal file into which to write */\n  const void *zBuf,      /* Take data to be written from here */\n  int iAmt,              /* Number of bytes to write */\n  sqlite_int64 iOfst     /* Begin writing at this offset into the file */\n){\n  int rc = SQLITE_OK;\n  JournalFile *p = (JournalFile *)pJfd;\n  if( !p->pReal && (iOfst+iAmt)>p->nBuf ){\n    rc = createFile(p);\n  }\n  if( rc==SQLITE_OK ){\n    if( p->pReal ){\n      rc = sqlite3OsWrite(p->pReal, zBuf, iAmt, iOfst);\n    }else{\n      memcpy(&p->zBuf[iOfst], zBuf, iAmt);\n      if( p->iSize<(iOfst+iAmt) ){\n        p->iSize = (iOfst+iAmt);\n      }\n    }\n  }\n  return rc;\n}\n\n/*\n** Truncate the file.\n*/\nstatic int jrnlTruncate(sqlite3_file *pJfd, sqlite_int64 size){\n  int rc = SQLITE_OK;\n  JournalFile *p = (JournalFile *)pJfd;\n  if( p->pReal ){\n    rc = sqlite3OsTruncate(p->pReal, size);\n  }else if( size<p->iSize ){\n    p->iSize = size;\n  }\n  return rc;\n}\n\n/*\n** Sync the file.\n*/\nstatic int jrnlSync(sqlite3_file *pJfd, int flags){\n  int rc;\n  JournalFile *p = (JournalFile *)pJfd;\n  if( p->pReal ){\n    rc = sqlite3OsSync(p->pReal, flags);\n  }else{\n    rc = SQLITE_OK;\n  }\n  return rc;\n}\n\n/*\n** Query the size of the file in bytes.\n*/\nstatic int jrnlFileSize(sqlite3_file *pJfd, sqlite_int64 *pSize){\n  int rc = SQLITE_OK;\n  JournalFile *p = (JournalFile *)pJfd;\n  if( p->pReal ){\n    rc = sqlite3OsFileSize(p->pReal, pSize);\n  }else{\n    *pSize = (sqlite_int64) p->iSize;\n  }\n  return rc;\n}\n\n/*\n** Table of methods for JournalFile sqlite3_file object.\n*/\nstatic struct sqlite3_io_methods JournalFileMethods = {\n  1,             /* iVersion */\n  jrnlClose,     /* xClose */\n  jrnlRead,      /* xRead */\n  jrnlWrite,     /* xWrite */\n  jrnlTruncate,  /* xTruncate */\n  jrnlSync,      /* xSync */\n  jrnlFileSize,  /* xFileSize */\n  0,             /* xLock */\n  0,             /* xUnlock */\n  0,             /* xCheckReservedLock */\n  0,             /* xFileControl */\n  0,             /* xSectorSize */\n  0,             /* xDeviceCharacteristics */\n  0,             /* xShmMap */\n  0,             /* xShmLock */\n  0,             /* xShmBarrier */\n  0              /* xShmUnmap */\n};\n\n/* \n** Open a journal file.\n*/\nSQLITE_PRIVATE int sqlite3JournalOpen(\n  sqlite3_vfs *pVfs,         /* The VFS to use for actual file I/O */\n  const char *zName,         /* Name of the journal file */\n  sqlite3_file *pJfd,        /* Preallocated, blank file handle */\n  int flags,                 /* Opening flags */\n  int nBuf                   /* Bytes buffered before opening the file */\n){\n  JournalFile *p = (JournalFile *)pJfd;\n  memset(p, 0, sqlite3JournalSize(pVfs));\n  if( nBuf>0 ){\n    p->zBuf = sqlite3MallocZero(nBuf);\n    if( !p->zBuf ){\n      return SQLITE_NOMEM;\n    }\n  }else{\n    return sqlite3OsOpen(pVfs, zName, pJfd, flags, 0);\n  }\n  p->pMethod = &JournalFileMethods;\n  p->nBuf = nBuf;\n  p->flags = flags;\n  p->zJournal = zName;\n  p->pVfs = pVfs;\n  return SQLITE_OK;\n}\n\n/*\n** If the argument p points to a JournalFile structure, and the underlying\n** file has not yet been created, create it now.\n*/\nSQLITE_PRIVATE int sqlite3JournalCreate(sqlite3_file *p){\n  if( p->pMethods!=&JournalFileMethods ){\n    return SQLITE_OK;\n  }\n  return createFile((JournalFile *)p);\n}\n\n/* \n** Return the number of bytes required to store a JournalFile that uses vfs\n** pVfs to create the underlying on-disk files.\n*/\nSQLITE_PRIVATE int sqlite3JournalSize(sqlite3_vfs *pVfs){\n  return (pVfs->szOsFile+sizeof(JournalFile));\n}\n#endif\n\n/************** End of journal.c *********************************************/\n/************** Begin file memjournal.c **************************************/\n/*\n** 2008 October 7\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n**\n** This file contains code use to implement an in-memory rollback journal.\n** The in-memory rollback journal is used to journal transactions for\n** \":memory:\" databases and when the journal_mode=MEMORY pragma is used.\n*/\n\n/* Forward references to internal structures */\ntypedef struct MemJournal MemJournal;\ntypedef struct FilePoint FilePoint;\ntypedef struct FileChunk FileChunk;\n\n/* Space to hold the rollback journal is allocated in increments of\n** this many bytes.\n**\n** The size chosen is a little less than a power of two.  That way,\n** the FileChunk object will have a size that almost exactly fills\n** a power-of-two allocation.  This mimimizes wasted space in power-of-two\n** memory allocators.\n*/\n#define JOURNAL_CHUNKSIZE ((int)(1024-sizeof(FileChunk*)))\n\n/* Macro to find the minimum of two numeric values.\n*/\n#ifndef MIN\n# define MIN(x,y) ((x)<(y)?(x):(y))\n#endif\n\n/*\n** The rollback journal is composed of a linked list of these structures.\n*/\nstruct FileChunk {\n  FileChunk *pNext;               /* Next chunk in the journal */\n  u8 zChunk[JOURNAL_CHUNKSIZE];   /* Content of this chunk */\n};\n\n/*\n** An instance of this object serves as a cursor into the rollback journal.\n** The cursor can be either for reading or writing.\n*/\nstruct FilePoint {\n  sqlite3_int64 iOffset;          /* Offset from the beginning of the file */\n  FileChunk *pChunk;              /* Specific chunk into which cursor points */\n};\n\n/*\n** This subclass is a subclass of sqlite3_file.  Each open memory-journal\n** is an instance of this class.\n*/\nstruct MemJournal {\n  sqlite3_io_methods *pMethod;    /* Parent class. MUST BE FIRST */\n  FileChunk *pFirst;              /* Head of in-memory chunk-list */\n  FilePoint endpoint;             /* Pointer to the end of the file */\n  FilePoint readpoint;            /* Pointer to the end of the last xRead() */\n};\n\n/*\n** Read data from the in-memory journal file.  This is the implementation\n** of the sqlite3_vfs.xRead method.\n*/\nstatic int memjrnlRead(\n  sqlite3_file *pJfd,    /* The journal file from which to read */\n  void *zBuf,            /* Put the results here */\n  int iAmt,              /* Number of bytes to read */\n  sqlite_int64 iOfst     /* Begin reading at this offset */\n){\n  MemJournal *p = (MemJournal *)pJfd;\n  u8 *zOut = zBuf;\n  int nRead = iAmt;\n  int iChunkOffset;\n  FileChunk *pChunk;\n\n  /* SQLite never tries to read past the end of a rollback journal file */\n  assert( iOfst+iAmt<=p->endpoint.iOffset );\n\n  if( p->readpoint.iOffset!=iOfst || iOfst==0 ){\n    sqlite3_int64 iOff = 0;\n    for(pChunk=p->pFirst; \n        ALWAYS(pChunk) && (iOff+JOURNAL_CHUNKSIZE)<=iOfst;\n        pChunk=pChunk->pNext\n    ){\n      iOff += JOURNAL_CHUNKSIZE;\n    }\n  }else{\n    pChunk = p->readpoint.pChunk;\n  }\n\n  iChunkOffset = (int)(iOfst%JOURNAL_CHUNKSIZE);\n  do {\n    int iSpace = JOURNAL_CHUNKSIZE - iChunkOffset;\n    int nCopy = MIN(nRead, (JOURNAL_CHUNKSIZE - iChunkOffset));\n    memcpy(zOut, &pChunk->zChunk[iChunkOffset], nCopy);\n    zOut += nCopy;\n    nRead -= iSpace;\n    iChunkOffset = 0;\n  } while( nRead>=0 && (pChunk=pChunk->pNext)!=0 && nRead>0 );\n  p->readpoint.iOffset = iOfst+iAmt;\n  p->readpoint.pChunk = pChunk;\n\n  return SQLITE_OK;\n}\n\n/*\n** Write data to the file.\n*/\nstatic int memjrnlWrite(\n  sqlite3_file *pJfd,    /* The journal file into which to write */\n  const void *zBuf,      /* Take data to be written from here */\n  int iAmt,              /* Number of bytes to write */\n  sqlite_int64 iOfst     /* Begin writing at this offset into the file */\n){\n  MemJournal *p = (MemJournal *)pJfd;\n  int nWrite = iAmt;\n  u8 *zWrite = (u8 *)zBuf;\n\n  /* An in-memory journal file should only ever be appended to. Random\n  ** access writes are not required by sqlite.\n  */\n  assert( iOfst==p->endpoint.iOffset );\n  UNUSED_PARAMETER(iOfst);\n\n  while( nWrite>0 ){\n    FileChunk *pChunk = p->endpoint.pChunk;\n    int iChunkOffset = (int)(p->endpoint.iOffset%JOURNAL_CHUNKSIZE);\n    int iSpace = MIN(nWrite, JOURNAL_CHUNKSIZE - iChunkOffset);\n\n    if( iChunkOffset==0 ){\n      /* New chunk is required to extend the file. */\n      FileChunk *pNew = sqlite3_malloc(sizeof(FileChunk));\n      if( !pNew ){\n        return SQLITE_IOERR_NOMEM;\n      }\n      pNew->pNext = 0;\n      if( pChunk ){\n        assert( p->pFirst );\n        pChunk->pNext = pNew;\n      }else{\n        assert( !p->pFirst );\n        p->pFirst = pNew;\n      }\n      p->endpoint.pChunk = pNew;\n    }\n\n    memcpy(&p->endpoint.pChunk->zChunk[iChunkOffset], zWrite, iSpace);\n    zWrite += iSpace;\n    nWrite -= iSpace;\n    p->endpoint.iOffset += iSpace;\n  }\n\n  return SQLITE_OK;\n}\n\n/*\n** Truncate the file.\n*/\nstatic int memjrnlTruncate(sqlite3_file *pJfd, sqlite_int64 size){\n  MemJournal *p = (MemJournal *)pJfd;\n  FileChunk *pChunk;\n  assert(size==0);\n  UNUSED_PARAMETER(size);\n  pChunk = p->pFirst;\n  while( pChunk ){\n    FileChunk *pTmp = pChunk;\n    pChunk = pChunk->pNext;\n    sqlite3_free(pTmp);\n  }\n  sqlite3MemJournalOpen(pJfd);\n  return SQLITE_OK;\n}\n\n/*\n** Close the file.\n*/\nstatic int memjrnlClose(sqlite3_file *pJfd){\n  memjrnlTruncate(pJfd, 0);\n  return SQLITE_OK;\n}\n\n\n/*\n** Sync the file.\n**\n** Syncing an in-memory journal is a no-op.  And, in fact, this routine\n** is never called in a working implementation.  This implementation\n** exists purely as a contingency, in case some malfunction in some other\n** part of SQLite causes Sync to be called by mistake.\n*/\nstatic int memjrnlSync(sqlite3_file *NotUsed, int NotUsed2){\n  UNUSED_PARAMETER2(NotUsed, NotUsed2);\n  return SQLITE_OK;\n}\n\n/*\n** Query the size of the file in bytes.\n*/\nstatic int memjrnlFileSize(sqlite3_file *pJfd, sqlite_int64 *pSize){\n  MemJournal *p = (MemJournal *)pJfd;\n  *pSize = (sqlite_int64) p->endpoint.iOffset;\n  return SQLITE_OK;\n}\n\n/*\n** Table of methods for MemJournal sqlite3_file object.\n*/\nstatic const struct sqlite3_io_methods MemJournalMethods = {\n  1,                /* iVersion */\n  memjrnlClose,     /* xClose */\n  memjrnlRead,      /* xRead */\n  memjrnlWrite,     /* xWrite */\n  memjrnlTruncate,  /* xTruncate */\n  memjrnlSync,      /* xSync */\n  memjrnlFileSize,  /* xFileSize */\n  0,                /* xLock */\n  0,                /* xUnlock */\n  0,                /* xCheckReservedLock */\n  0,                /* xFileControl */\n  0,                /* xSectorSize */\n  0,                /* xDeviceCharacteristics */\n  0,                /* xShmMap */\n  0,                /* xShmLock */\n  0,                /* xShmBarrier */\n  0                 /* xShmUnlock */\n};\n\n/* \n** Open a journal file.\n*/\nSQLITE_PRIVATE void sqlite3MemJournalOpen(sqlite3_file *pJfd){\n  MemJournal *p = (MemJournal *)pJfd;\n  assert( EIGHT_BYTE_ALIGNMENT(p) );\n  memset(p, 0, sqlite3MemJournalSize());\n  p->pMethod = (sqlite3_io_methods*)&MemJournalMethods;\n}\n\n/*\n** Return true if the file-handle passed as an argument is \n** an in-memory journal \n*/\nSQLITE_PRIVATE int sqlite3IsMemJournal(sqlite3_file *pJfd){\n  return pJfd->pMethods==&MemJournalMethods;\n}\n\n/* \n** Return the number of bytes required to store a MemJournal file descriptor.\n*/\nSQLITE_PRIVATE int sqlite3MemJournalSize(void){\n  return sizeof(MemJournal);\n}\n\n/************** End of memjournal.c ******************************************/\n/************** Begin file walker.c ******************************************/\n/*\n** 2008 August 16\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains routines used for walking the parser tree for\n** an SQL statement.\n*/\n\n\n/*\n** Walk an expression tree.  Invoke the callback once for each node\n** of the expression, while decending.  (In other words, the callback\n** is invoked before visiting children.)\n**\n** The return value from the callback should be one of the WRC_*\n** constants to specify how to proceed with the walk.\n**\n**    WRC_Continue      Continue descending down the tree.\n**\n**    WRC_Prune         Do not descend into child nodes.  But allow\n**                      the walk to continue with sibling nodes.\n**\n**    WRC_Abort         Do no more callbacks.  Unwind the stack and\n**                      return the top-level walk call.\n**\n** The return value from this routine is WRC_Abort to abandon the tree walk\n** and WRC_Continue to continue.\n*/\nSQLITE_PRIVATE int sqlite3WalkExpr(Walker *pWalker, Expr *pExpr){\n  int rc;\n  if( pExpr==0 ) return WRC_Continue;\n  testcase( ExprHasProperty(pExpr, EP_TokenOnly) );\n  testcase( ExprHasProperty(pExpr, EP_Reduced) );\n  rc = pWalker->xExprCallback(pWalker, pExpr);\n  if( rc==WRC_Continue\n              && !ExprHasAnyProperty(pExpr,EP_TokenOnly) ){\n    if( sqlite3WalkExpr(pWalker, pExpr->pLeft) ) return WRC_Abort;\n    if( sqlite3WalkExpr(pWalker, pExpr->pRight) ) return WRC_Abort;\n    if( ExprHasProperty(pExpr, EP_xIsSelect) ){\n      if( sqlite3WalkSelect(pWalker, pExpr->x.pSelect) ) return WRC_Abort;\n    }else{\n      if( sqlite3WalkExprList(pWalker, pExpr->x.pList) ) return WRC_Abort;\n    }\n  }\n  return rc & WRC_Abort;\n}\n\n/*\n** Call sqlite3WalkExpr() for every expression in list p or until\n** an abort request is seen.\n*/\nSQLITE_PRIVATE int sqlite3WalkExprList(Walker *pWalker, ExprList *p){\n  int i;\n  struct ExprList_item *pItem;\n  if( p ){\n    for(i=p->nExpr, pItem=p->a; i>0; i--, pItem++){\n      if( sqlite3WalkExpr(pWalker, pItem->pExpr) ) return WRC_Abort;\n    }\n  }\n  return WRC_Continue;\n}\n\n/*\n** Walk all expressions associated with SELECT statement p.  Do\n** not invoke the SELECT callback on p, but do (of course) invoke\n** any expr callbacks and SELECT callbacks that come from subqueries.\n** Return WRC_Abort or WRC_Continue.\n*/\nSQLITE_PRIVATE int sqlite3WalkSelectExpr(Walker *pWalker, Select *p){\n  if( sqlite3WalkExprList(pWalker, p->pEList) ) return WRC_Abort;\n  if( sqlite3WalkExpr(pWalker, p->pWhere) ) return WRC_Abort;\n  if( sqlite3WalkExprList(pWalker, p->pGroupBy) ) return WRC_Abort;\n  if( sqlite3WalkExpr(pWalker, p->pHaving) ) return WRC_Abort;\n  if( sqlite3WalkExprList(pWalker, p->pOrderBy) ) return WRC_Abort;\n  if( sqlite3WalkExpr(pWalker, p->pLimit) ) return WRC_Abort;\n  if( sqlite3WalkExpr(pWalker, p->pOffset) ) return WRC_Abort;\n  return WRC_Continue;\n}\n\n/*\n** Walk the parse trees associated with all subqueries in the\n** FROM clause of SELECT statement p.  Do not invoke the select\n** callback on p, but do invoke it on each FROM clause subquery\n** and on any subqueries further down in the tree.  Return \n** WRC_Abort or WRC_Continue;\n*/\nSQLITE_PRIVATE int sqlite3WalkSelectFrom(Walker *pWalker, Select *p){\n  SrcList *pSrc;\n  int i;\n  struct SrcList_item *pItem;\n\n  pSrc = p->pSrc;\n  if( ALWAYS(pSrc) ){\n    for(i=pSrc->nSrc, pItem=pSrc->a; i>0; i--, pItem++){\n      if( sqlite3WalkSelect(pWalker, pItem->pSelect) ){\n        return WRC_Abort;\n      }\n    }\n  }\n  return WRC_Continue;\n} \n\n/*\n** Call sqlite3WalkExpr() for every expression in Select statement p.\n** Invoke sqlite3WalkSelect() for subqueries in the FROM clause and\n** on the compound select chain, p->pPrior.\n**\n** Return WRC_Continue under normal conditions.  Return WRC_Abort if\n** there is an abort request.\n**\n** If the Walker does not have an xSelectCallback() then this routine\n** is a no-op returning WRC_Continue.\n*/\nSQLITE_PRIVATE int sqlite3WalkSelect(Walker *pWalker, Select *p){\n  int rc;\n  if( p==0 || pWalker->xSelectCallback==0 ) return WRC_Continue;\n  rc = WRC_Continue;\n  while( p  ){\n    rc = pWalker->xSelectCallback(pWalker, p);\n    if( rc ) break;\n    if( sqlite3WalkSelectExpr(pWalker, p) ) return WRC_Abort;\n    if( sqlite3WalkSelectFrom(pWalker, p) ) return WRC_Abort;\n    p = p->pPrior;\n  }\n  return rc & WRC_Abort;\n}\n\n/************** End of walker.c **********************************************/\n/************** Begin file resolve.c *****************************************/\n/*\n** 2008 August 18\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n**\n** This file contains routines used for walking the parser tree and\n** resolve all identifiers by associating them with a particular\n** table and column.\n*/\n\n/*\n** Turn the pExpr expression into an alias for the iCol-th column of the\n** result set in pEList.\n**\n** If the result set column is a simple column reference, then this routine\n** makes an exact copy.  But for any other kind of expression, this\n** routine make a copy of the result set column as the argument to the\n** TK_AS operator.  The TK_AS operator causes the expression to be\n** evaluated just once and then reused for each alias.\n**\n** The reason for suppressing the TK_AS term when the expression is a simple\n** column reference is so that the column reference will be recognized as\n** usable by indices within the WHERE clause processing logic. \n**\n** Hack:  The TK_AS operator is inhibited if zType[0]=='G'.  This means\n** that in a GROUP BY clause, the expression is evaluated twice.  Hence:\n**\n**     SELECT random()%5 AS x, count(*) FROM tab GROUP BY x\n**\n** Is equivalent to:\n**\n**     SELECT random()%5 AS x, count(*) FROM tab GROUP BY random()%5\n**\n** The result of random()%5 in the GROUP BY clause is probably different\n** from the result in the result-set.  We might fix this someday.  Or\n** then again, we might not...\n*/\nstatic void resolveAlias(\n  Parse *pParse,         /* Parsing context */\n  ExprList *pEList,      /* A result set */\n  int iCol,              /* A column in the result set.  0..pEList->nExpr-1 */\n  Expr *pExpr,           /* Transform this into an alias to the result set */\n  const char *zType      /* \"GROUP\" or \"ORDER\" or \"\" */\n){\n  Expr *pOrig;           /* The iCol-th column of the result set */\n  Expr *pDup;            /* Copy of pOrig */\n  sqlite3 *db;           /* The database connection */\n\n  assert( iCol>=0 && iCol<pEList->nExpr );\n  pOrig = pEList->a[iCol].pExpr;\n  assert( pOrig!=0 );\n  assert( pOrig->flags & EP_Resolved );\n  db = pParse->db;\n  if( pOrig->op!=TK_COLUMN && zType[0]!='G' ){\n    pDup = sqlite3ExprDup(db, pOrig, 0);\n    pDup = sqlite3PExpr(pParse, TK_AS, pDup, 0, 0);\n    if( pDup==0 ) return;\n    if( pEList->a[iCol].iAlias==0 ){\n      pEList->a[iCol].iAlias = (u16)(++pParse->nAlias);\n    }\n    pDup->iTable = pEList->a[iCol].iAlias;\n  }else if( ExprHasProperty(pOrig, EP_IntValue) || pOrig->u.zToken==0 ){\n    pDup = sqlite3ExprDup(db, pOrig, 0);\n    if( pDup==0 ) return;\n  }else{\n    char *zToken = pOrig->u.zToken;\n    assert( zToken!=0 );\n    pOrig->u.zToken = 0;\n    pDup = sqlite3ExprDup(db, pOrig, 0);\n    pOrig->u.zToken = zToken;\n    if( pDup==0 ) return;\n    assert( (pDup->flags & (EP_Reduced|EP_TokenOnly))==0 );\n    pDup->flags2 |= EP2_MallocedToken;\n    pDup->u.zToken = sqlite3DbStrDup(db, zToken);\n  }\n  if( pExpr->flags & EP_ExpCollate ){\n    pDup->pColl = pExpr->pColl;\n    pDup->flags |= EP_ExpCollate;\n  }\n\n  /* Before calling sqlite3ExprDelete(), set the EP_Static flag. This \n  ** prevents ExprDelete() from deleting the Expr structure itself,\n  ** allowing it to be repopulated by the memcpy() on the following line.\n  */\n  ExprSetProperty(pExpr, EP_Static);\n  sqlite3ExprDelete(db, pExpr);\n  memcpy(pExpr, pDup, sizeof(*pExpr));\n  sqlite3DbFree(db, pDup);\n}\n\n/*\n** Given the name of a column of the form X.Y.Z or Y.Z or just Z, look up\n** that name in the set of source tables in pSrcList and make the pExpr \n** expression node refer back to that source column.  The following changes\n** are made to pExpr:\n**\n**    pExpr->iDb           Set the index in db->aDb[] of the database X\n**                         (even if X is implied).\n**    pExpr->iTable        Set to the cursor number for the table obtained\n**                         from pSrcList.\n**    pExpr->pTab          Points to the Table structure of X.Y (even if\n**                         X and/or Y are implied.)\n**    pExpr->iColumn       Set to the column number within the table.\n**    pExpr->op            Set to TK_COLUMN.\n**    pExpr->pLeft         Any expression this points to is deleted\n**    pExpr->pRight        Any expression this points to is deleted.\n**\n** The zDb variable is the name of the database (the \"X\").  This value may be\n** NULL meaning that name is of the form Y.Z or Z.  Any available database\n** can be used.  The zTable variable is the name of the table (the \"Y\").  This\n** value can be NULL if zDb is also NULL.  If zTable is NULL it\n** means that the form of the name is Z and that columns from any table\n** can be used.\n**\n** If the name cannot be resolved unambiguously, leave an error message\n** in pParse and return WRC_Abort.  Return WRC_Prune on success.\n*/\nstatic int lookupName(\n  Parse *pParse,       /* The parsing context */\n  const char *zDb,     /* Name of the database containing table, or NULL */\n  const char *zTab,    /* Name of table containing column, or NULL */\n  const char *zCol,    /* Name of the column. */\n  NameContext *pNC,    /* The name context used to resolve the name */\n  Expr *pExpr          /* Make this EXPR node point to the selected column */\n){\n  int i, j;            /* Loop counters */\n  int cnt = 0;                      /* Number of matching column names */\n  int cntTab = 0;                   /* Number of matching table names */\n  sqlite3 *db = pParse->db;         /* The database connection */\n  struct SrcList_item *pItem;       /* Use for looping over pSrcList items */\n  struct SrcList_item *pMatch = 0;  /* The matching pSrcList item */\n  NameContext *pTopNC = pNC;        /* First namecontext in the list */\n  Schema *pSchema = 0;              /* Schema of the expression */\n  int isTrigger = 0;\n\n  assert( pNC );     /* the name context cannot be NULL. */\n  assert( zCol );    /* The Z in X.Y.Z cannot be NULL */\n  assert( ~ExprHasAnyProperty(pExpr, EP_TokenOnly|EP_Reduced) );\n\n  /* Initialize the node to no-match */\n  pExpr->iTable = -1;\n  pExpr->pTab = 0;\n  ExprSetIrreducible(pExpr);\n\n  /* Start at the inner-most context and move outward until a match is found */\n  while( pNC && cnt==0 ){\n    ExprList *pEList;\n    SrcList *pSrcList = pNC->pSrcList;\n\n    if( pSrcList ){\n      for(i=0, pItem=pSrcList->a; i<pSrcList->nSrc; i++, pItem++){\n        Table *pTab;\n        int iDb;\n        Column *pCol;\n  \n        pTab = pItem->pTab;\n        assert( pTab!=0 && pTab->zName!=0 );\n        iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n        assert( pTab->nCol>0 );\n        if( zTab ){\n          if( pItem->zAlias ){\n            char *zTabName = pItem->zAlias;\n            if( sqlite3StrICmp(zTabName, zTab)!=0 ) continue;\n          }else{\n            char *zTabName = pTab->zName;\n            if( NEVER(zTabName==0) || sqlite3StrICmp(zTabName, zTab)!=0 ){\n              continue;\n            }\n            if( zDb!=0 && sqlite3StrICmp(db->aDb[iDb].zName, zDb)!=0 ){\n              continue;\n            }\n          }\n        }\n        if( 0==(cntTab++) ){\n          pExpr->iTable = pItem->iCursor;\n          pExpr->pTab = pTab;\n          pSchema = pTab->pSchema;\n          pMatch = pItem;\n        }\n        for(j=0, pCol=pTab->aCol; j<pTab->nCol; j++, pCol++){\n          if( sqlite3StrICmp(pCol->zName, zCol)==0 ){\n            IdList *pUsing;\n            cnt++;\n            pExpr->iTable = pItem->iCursor;\n            pExpr->pTab = pTab;\n            pMatch = pItem;\n            pSchema = pTab->pSchema;\n            /* Substitute the rowid (column -1) for the INTEGER PRIMARY KEY */\n            pExpr->iColumn = j==pTab->iPKey ? -1 : (i16)j;\n            if( i<pSrcList->nSrc-1 ){\n              if( pItem[1].jointype & JT_NATURAL ){\n                /* If this match occurred in the left table of a natural join,\n                ** then skip the right table to avoid a duplicate match */\n                pItem++;\n                i++;\n              }else if( (pUsing = pItem[1].pUsing)!=0 ){\n                /* If this match occurs on a column that is in the USING clause\n                ** of a join, skip the search of the right table of the join\n                ** to avoid a duplicate match there. */\n                int k;\n                for(k=0; k<pUsing->nId; k++){\n                  if( sqlite3StrICmp(pUsing->a[k].zName, zCol)==0 ){\n                    pItem++;\n                    i++;\n                    break;\n                  }\n                }\n              }\n            }\n            break;\n          }\n        }\n      }\n    }\n\n#ifndef SQLITE_OMIT_TRIGGER\n    /* If we have not already resolved the name, then maybe \n    ** it is a new.* or old.* trigger argument reference\n    */\n    if( zDb==0 && zTab!=0 && cnt==0 && pParse->pTriggerTab!=0 ){\n      int op = pParse->eTriggerOp;\n      Table *pTab = 0;\n      assert( op==TK_DELETE || op==TK_UPDATE || op==TK_INSERT );\n      if( op!=TK_DELETE && sqlite3StrICmp(\"new\",zTab) == 0 ){\n        pExpr->iTable = 1;\n        pTab = pParse->pTriggerTab;\n      }else if( op!=TK_INSERT && sqlite3StrICmp(\"old\",zTab)==0 ){\n        pExpr->iTable = 0;\n        pTab = pParse->pTriggerTab;\n      }\n\n      if( pTab ){ \n        int iCol;\n        pSchema = pTab->pSchema;\n        cntTab++;\n        for(iCol=0; iCol<pTab->nCol; iCol++){\n          Column *pCol = &pTab->aCol[iCol];\n          if( sqlite3StrICmp(pCol->zName, zCol)==0 ){\n            if( iCol==pTab->iPKey ){\n              iCol = -1;\n            }\n            break;\n          }\n        }\n        if( iCol>=pTab->nCol && sqlite3IsRowid(zCol) ){\n          iCol = -1;        /* IMP: R-44911-55124 */\n        }\n        if( iCol<pTab->nCol ){\n          cnt++;\n          if( iCol<0 ){\n            pExpr->affinity = SQLITE_AFF_INTEGER;\n          }else if( pExpr->iTable==0 ){\n            testcase( iCol==31 );\n            testcase( iCol==32 );\n            pParse->oldmask |= (iCol>=32 ? 0xffffffff : (((u32)1)<<iCol));\n          }else{\n            testcase( iCol==31 );\n            testcase( iCol==32 );\n            pParse->newmask |= (iCol>=32 ? 0xffffffff : (((u32)1)<<iCol));\n          }\n          pExpr->iColumn = (i16)iCol;\n          pExpr->pTab = pTab;\n          isTrigger = 1;\n        }\n      }\n    }\n#endif /* !defined(SQLITE_OMIT_TRIGGER) */\n\n    /*\n    ** Perhaps the name is a reference to the ROWID\n    */\n    if( cnt==0 && cntTab==1 && sqlite3IsRowid(zCol) ){\n      cnt = 1;\n      pExpr->iColumn = -1;     /* IMP: R-44911-55124 */\n      pExpr->affinity = SQLITE_AFF_INTEGER;\n    }\n\n    /*\n    ** If the input is of the form Z (not Y.Z or X.Y.Z) then the name Z\n    ** might refer to an result-set alias.  This happens, for example, when\n    ** we are resolving names in the WHERE clause of the following command:\n    **\n    **     SELECT a+b AS x FROM table WHERE x<10;\n    **\n    ** In cases like this, replace pExpr with a copy of the expression that\n    ** forms the result set entry (\"a+b\" in the example) and return immediately.\n    ** Note that the expression in the result set should have already been\n    ** resolved by the time the WHERE clause is resolved.\n    */\n    if( cnt==0 && (pEList = pNC->pEList)!=0 && zTab==0 ){\n      for(j=0; j<pEList->nExpr; j++){\n        char *zAs = pEList->a[j].zName;\n        if( zAs!=0 && sqlite3StrICmp(zAs, zCol)==0 ){\n          Expr *pOrig;\n          assert( pExpr->pLeft==0 && pExpr->pRight==0 );\n          assert( pExpr->x.pList==0 );\n          assert( pExpr->x.pSelect==0 );\n          pOrig = pEList->a[j].pExpr;\n          if( !pNC->allowAgg && ExprHasProperty(pOrig, EP_Agg) ){\n            sqlite3ErrorMsg(pParse, \"misuse of aliased aggregate %s\", zAs);\n            return WRC_Abort;\n          }\n          resolveAlias(pParse, pEList, j, pExpr, \"\");\n          cnt = 1;\n          pMatch = 0;\n          assert( zTab==0 && zDb==0 );\n          goto lookupname_end;\n        }\n      } \n    }\n\n    /* Advance to the next name context.  The loop will exit when either\n    ** we have a match (cnt>0) or when we run out of name contexts.\n    */\n    if( cnt==0 ){\n      pNC = pNC->pNext;\n    }\n  }\n\n  /*\n  ** If X and Y are NULL (in other words if only the column name Z is\n  ** supplied) and the value of Z is enclosed in double-quotes, then\n  ** Z is a string literal if it doesn't match any column names.  In that\n  ** case, we need to return right away and not make any changes to\n  ** pExpr.\n  **\n  ** Because no reference was made to outer contexts, the pNC->nRef\n  ** fields are not changed in any context.\n  */\n  if( cnt==0 && zTab==0 && ExprHasProperty(pExpr,EP_DblQuoted) ){\n    pExpr->op = TK_STRING;\n    pExpr->pTab = 0;\n    return WRC_Prune;\n  }\n\n  /*\n  ** cnt==0 means there was not match.  cnt>1 means there were two or\n  ** more matches.  Either way, we have an error.\n  */\n  if( cnt!=1 ){\n    const char *zErr;\n    zErr = cnt==0 ? \"no such column\" : \"ambiguous column name\";\n    if( zDb ){\n      sqlite3ErrorMsg(pParse, \"%s: %s.%s.%s\", zErr, zDb, zTab, zCol);\n    }else if( zTab ){\n      sqlite3ErrorMsg(pParse, \"%s: %s.%s\", zErr, zTab, zCol);\n    }else{\n      sqlite3ErrorMsg(pParse, \"%s: %s\", zErr, zCol);\n    }\n    pParse->checkSchema = 1;\n    pTopNC->nErr++;\n  }\n\n  /* If a column from a table in pSrcList is referenced, then record\n  ** this fact in the pSrcList.a[].colUsed bitmask.  Column 0 causes\n  ** bit 0 to be set.  Column 1 sets bit 1.  And so forth.  If the\n  ** column number is greater than the number of bits in the bitmask\n  ** then set the high-order bit of the bitmask.\n  */\n  if( pExpr->iColumn>=0 && pMatch!=0 ){\n    int n = pExpr->iColumn;\n    testcase( n==BMS-1 );\n    if( n>=BMS ){\n      n = BMS-1;\n    }\n    assert( pMatch->iCursor==pExpr->iTable );\n    pMatch->colUsed |= ((Bitmask)1)<<n;\n  }\n\n  /* Clean up and return\n  */\n  sqlite3ExprDelete(db, pExpr->pLeft);\n  pExpr->pLeft = 0;\n  sqlite3ExprDelete(db, pExpr->pRight);\n  pExpr->pRight = 0;\n  pExpr->op = (isTrigger ? TK_TRIGGER : TK_COLUMN);\nlookupname_end:\n  if( cnt==1 ){\n    assert( pNC!=0 );\n    sqlite3AuthRead(pParse, pExpr, pSchema, pNC->pSrcList);\n    /* Increment the nRef value on all name contexts from TopNC up to\n    ** the point where the name matched. */\n    for(;;){\n      assert( pTopNC!=0 );\n      pTopNC->nRef++;\n      if( pTopNC==pNC ) break;\n      pTopNC = pTopNC->pNext;\n    }\n    return WRC_Prune;\n  } else {\n    return WRC_Abort;\n  }\n}\n\n/*\n** Allocate and return a pointer to an expression to load the column iCol\n** from datasource iSrc in SrcList pSrc.\n*/\nSQLITE_PRIVATE Expr *sqlite3CreateColumnExpr(sqlite3 *db, SrcList *pSrc, int iSrc, int iCol){\n  Expr *p = sqlite3ExprAlloc(db, TK_COLUMN, 0, 0);\n  if( p ){\n    struct SrcList_item *pItem = &pSrc->a[iSrc];\n    p->pTab = pItem->pTab;\n    p->iTable = pItem->iCursor;\n    if( p->pTab->iPKey==iCol ){\n      p->iColumn = -1;\n    }else{\n      p->iColumn = (ynVar)iCol;\n      testcase( iCol==BMS );\n      testcase( iCol==BMS-1 );\n      pItem->colUsed |= ((Bitmask)1)<<(iCol>=BMS ? BMS-1 : iCol);\n    }\n    ExprSetProperty(p, EP_Resolved);\n  }\n  return p;\n}\n\n/*\n** This routine is callback for sqlite3WalkExpr().\n**\n** Resolve symbolic names into TK_COLUMN operators for the current\n** node in the expression tree.  Return 0 to continue the search down\n** the tree or 2 to abort the tree walk.\n**\n** This routine also does error checking and name resolution for\n** function names.  The operator for aggregate functions is changed\n** to TK_AGG_FUNCTION.\n*/\nstatic int resolveExprStep(Walker *pWalker, Expr *pExpr){\n  NameContext *pNC;\n  Parse *pParse;\n\n  pNC = pWalker->u.pNC;\n  assert( pNC!=0 );\n  pParse = pNC->pParse;\n  assert( pParse==pWalker->pParse );\n\n  if( ExprHasAnyProperty(pExpr, EP_Resolved) ) return WRC_Prune;\n  ExprSetProperty(pExpr, EP_Resolved);\n#ifndef NDEBUG\n  if( pNC->pSrcList && pNC->pSrcList->nAlloc>0 ){\n    SrcList *pSrcList = pNC->pSrcList;\n    int i;\n    for(i=0; i<pNC->pSrcList->nSrc; i++){\n      assert( pSrcList->a[i].iCursor>=0 && pSrcList->a[i].iCursor<pParse->nTab);\n    }\n  }\n#endif\n  switch( pExpr->op ){\n\n#if defined(SQLITE_ENABLE_UPDATE_DELETE_LIMIT) && !defined(SQLITE_OMIT_SUBQUERY)\n    /* The special operator TK_ROW means use the rowid for the first\n    ** column in the FROM clause.  This is used by the LIMIT and ORDER BY\n    ** clause processing on UPDATE and DELETE statements.\n    */\n    case TK_ROW: {\n      SrcList *pSrcList = pNC->pSrcList;\n      struct SrcList_item *pItem;\n      assert( pSrcList && pSrcList->nSrc==1 );\n      pItem = pSrcList->a; \n      pExpr->op = TK_COLUMN;\n      pExpr->pTab = pItem->pTab;\n      pExpr->iTable = pItem->iCursor;\n      pExpr->iColumn = -1;\n      pExpr->affinity = SQLITE_AFF_INTEGER;\n      break;\n    }\n#endif /* defined(SQLITE_ENABLE_UPDATE_DELETE_LIMIT) && !defined(SQLITE_OMIT_SUBQUERY) */\n\n    /* A lone identifier is the name of a column.\n    */\n    case TK_ID: {\n      return lookupName(pParse, 0, 0, pExpr->u.zToken, pNC, pExpr);\n    }\n  \n    /* A table name and column name:     ID.ID\n    ** Or a database, table and column:  ID.ID.ID\n    */\n    case TK_DOT: {\n      const char *zColumn;\n      const char *zTable;\n      const char *zDb;\n      Expr *pRight;\n\n      /* if( pSrcList==0 ) break; */\n      pRight = pExpr->pRight;\n      if( pRight->op==TK_ID ){\n        zDb = 0;\n        zTable = pExpr->pLeft->u.zToken;\n        zColumn = pRight->u.zToken;\n      }else{\n        assert( pRight->op==TK_DOT );\n        zDb = pExpr->pLeft->u.zToken;\n        zTable = pRight->pLeft->u.zToken;\n        zColumn = pRight->pRight->u.zToken;\n      }\n      return lookupName(pParse, zDb, zTable, zColumn, pNC, pExpr);\n    }\n\n    /* Resolve function names\n    */\n    case TK_CONST_FUNC:\n    case TK_FUNCTION: {\n      ExprList *pList = pExpr->x.pList;    /* The argument list */\n      int n = pList ? pList->nExpr : 0;    /* Number of arguments */\n      int no_such_func = 0;       /* True if no such function exists */\n      int wrong_num_args = 0;     /* True if wrong number of arguments */\n      int is_agg = 0;             /* True if is an aggregate function */\n      int auth;                   /* Authorization to use the function */\n      int nId;                    /* Number of characters in function name */\n      const char *zId;            /* The function name. */\n      FuncDef *pDef;              /* Information about the function */\n      u8 enc = ENC(pParse->db);   /* The database encoding */\n\n      testcase( pExpr->op==TK_CONST_FUNC );\n      assert( !ExprHasProperty(pExpr, EP_xIsSelect) );\n      zId = pExpr->u.zToken;\n      nId = sqlite3Strlen30(zId);\n      pDef = sqlite3FindFunction(pParse->db, zId, nId, n, enc, 0);\n      if( pDef==0 ){\n        pDef = sqlite3FindFunction(pParse->db, zId, nId, -1, enc, 0);\n        if( pDef==0 ){\n          no_such_func = 1;\n        }else{\n          wrong_num_args = 1;\n        }\n      }else{\n        is_agg = pDef->xFunc==0;\n      }\n#ifndef SQLITE_OMIT_AUTHORIZATION\n      if( pDef ){\n        auth = sqlite3AuthCheck(pParse, SQLITE_FUNCTION, 0, pDef->zName, 0);\n        if( auth!=SQLITE_OK ){\n          if( auth==SQLITE_DENY ){\n            sqlite3ErrorMsg(pParse, \"not authorized to use function: %s\",\n                                    pDef->zName);\n            pNC->nErr++;\n          }\n          pExpr->op = TK_NULL;\n          return WRC_Prune;\n        }\n      }\n#endif\n      if( is_agg && !pNC->allowAgg ){\n        sqlite3ErrorMsg(pParse, \"misuse of aggregate function %.*s()\", nId,zId);\n        pNC->nErr++;\n        is_agg = 0;\n      }else if( no_such_func ){\n        sqlite3ErrorMsg(pParse, \"no such function: %.*s\", nId, zId);\n        pNC->nErr++;\n      }else if( wrong_num_args ){\n        sqlite3ErrorMsg(pParse,\"wrong number of arguments to function %.*s()\",\n             nId, zId);\n        pNC->nErr++;\n      }\n      if( is_agg ){\n        pExpr->op = TK_AGG_FUNCTION;\n        pNC->hasAgg = 1;\n      }\n      if( is_agg ) pNC->allowAgg = 0;\n      sqlite3WalkExprList(pWalker, pList);\n      if( is_agg ) pNC->allowAgg = 1;\n      /* FIX ME:  Compute pExpr->affinity based on the expected return\n      ** type of the function \n      */\n      return WRC_Prune;\n    }\n#ifndef SQLITE_OMIT_SUBQUERY\n    case TK_SELECT:\n    case TK_EXISTS:  testcase( pExpr->op==TK_EXISTS );\n#endif\n    case TK_IN: {\n      testcase( pExpr->op==TK_IN );\n      if( ExprHasProperty(pExpr, EP_xIsSelect) ){\n        int nRef = pNC->nRef;\n#ifndef SQLITE_OMIT_CHECK\n        if( pNC->isCheck ){\n          sqlite3ErrorMsg(pParse,\"subqueries prohibited in CHECK constraints\");\n        }\n#endif\n        sqlite3WalkSelect(pWalker, pExpr->x.pSelect);\n        assert( pNC->nRef>=nRef );\n        if( nRef!=pNC->nRef ){\n          ExprSetProperty(pExpr, EP_VarSelect);\n        }\n      }\n      break;\n    }\n#ifndef SQLITE_OMIT_CHECK\n    case TK_VARIABLE: {\n      if( pNC->isCheck ){\n        sqlite3ErrorMsg(pParse,\"parameters prohibited in CHECK constraints\");\n      }\n      break;\n    }\n#endif\n  }\n  return (pParse->nErr || pParse->db->mallocFailed) ? WRC_Abort : WRC_Continue;\n}\n\n/*\n** pEList is a list of expressions which are really the result set of the\n** a SELECT statement.  pE is a term in an ORDER BY or GROUP BY clause.\n** This routine checks to see if pE is a simple identifier which corresponds\n** to the AS-name of one of the terms of the expression list.  If it is,\n** this routine return an integer between 1 and N where N is the number of\n** elements in pEList, corresponding to the matching entry.  If there is\n** no match, or if pE is not a simple identifier, then this routine\n** return 0.\n**\n** pEList has been resolved.  pE has not.\n*/\nstatic int resolveAsName(\n  Parse *pParse,     /* Parsing context for error messages */\n  ExprList *pEList,  /* List of expressions to scan */\n  Expr *pE           /* Expression we are trying to match */\n){\n  int i;             /* Loop counter */\n\n  UNUSED_PARAMETER(pParse);\n\n  if( pE->op==TK_ID ){\n    char *zCol = pE->u.zToken;\n    for(i=0; i<pEList->nExpr; i++){\n      char *zAs = pEList->a[i].zName;\n      if( zAs!=0 && sqlite3StrICmp(zAs, zCol)==0 ){\n        return i+1;\n      }\n    }\n  }\n  return 0;\n}\n\n/*\n** pE is a pointer to an expression which is a single term in the\n** ORDER BY of a compound SELECT.  The expression has not been\n** name resolved.\n**\n** At the point this routine is called, we already know that the\n** ORDER BY term is not an integer index into the result set.  That\n** case is handled by the calling routine.\n**\n** Attempt to match pE against result set columns in the left-most\n** SELECT statement.  Return the index i of the matching column,\n** as an indication to the caller that it should sort by the i-th column.\n** The left-most column is 1.  In other words, the value returned is the\n** same integer value that would be used in the SQL statement to indicate\n** the column.\n**\n** If there is no match, return 0.  Return -1 if an error occurs.\n*/\nstatic int resolveOrderByTermToExprList(\n  Parse *pParse,     /* Parsing context for error messages */\n  Select *pSelect,   /* The SELECT statement with the ORDER BY clause */\n  Expr *pE           /* The specific ORDER BY term */\n){\n  int i;             /* Loop counter */\n  ExprList *pEList;  /* The columns of the result set */\n  NameContext nc;    /* Name context for resolving pE */\n  sqlite3 *db;       /* Database connection */\n  int rc;            /* Return code from subprocedures */\n  u8 savedSuppErr;   /* Saved value of db->suppressErr */\n\n  assert( sqlite3ExprIsInteger(pE, &i)==0 );\n  pEList = pSelect->pEList;\n\n  /* Resolve all names in the ORDER BY term expression\n  */\n  memset(&nc, 0, sizeof(nc));\n  nc.pParse = pParse;\n  nc.pSrcList = pSelect->pSrc;\n  nc.pEList = pEList;\n  nc.allowAgg = 1;\n  nc.nErr = 0;\n  db = pParse->db;\n  savedSuppErr = db->suppressErr;\n  db->suppressErr = 1;\n  rc = sqlite3ResolveExprNames(&nc, pE);\n  db->suppressErr = savedSuppErr;\n  if( rc ) return 0;\n\n  /* Try to match the ORDER BY expression against an expression\n  ** in the result set.  Return an 1-based index of the matching\n  ** result-set entry.\n  */\n  for(i=0; i<pEList->nExpr; i++){\n    if( sqlite3ExprCompare(pEList->a[i].pExpr, pE)<2 ){\n      return i+1;\n    }\n  }\n\n  /* If no match, return 0. */\n  return 0;\n}\n\n/*\n** Generate an ORDER BY or GROUP BY term out-of-range error.\n*/\nstatic void resolveOutOfRangeError(\n  Parse *pParse,         /* The error context into which to write the error */\n  const char *zType,     /* \"ORDER\" or \"GROUP\" */\n  int i,                 /* The index (1-based) of the term out of range */\n  int mx                 /* Largest permissible value of i */\n){\n  sqlite3ErrorMsg(pParse, \n    \"%r %s BY term out of range - should be \"\n    \"between 1 and %d\", i, zType, mx);\n}\n\n/*\n** Analyze the ORDER BY clause in a compound SELECT statement.   Modify\n** each term of the ORDER BY clause is a constant integer between 1\n** and N where N is the number of columns in the compound SELECT.\n**\n** ORDER BY terms that are already an integer between 1 and N are\n** unmodified.  ORDER BY terms that are integers outside the range of\n** 1 through N generate an error.  ORDER BY terms that are expressions\n** are matched against result set expressions of compound SELECT\n** beginning with the left-most SELECT and working toward the right.\n** At the first match, the ORDER BY expression is transformed into\n** the integer column number.\n**\n** Return the number of errors seen.\n*/\nstatic int resolveCompoundOrderBy(\n  Parse *pParse,        /* Parsing context.  Leave error messages here */\n  Select *pSelect       /* The SELECT statement containing the ORDER BY */\n){\n  int i;\n  ExprList *pOrderBy;\n  ExprList *pEList;\n  sqlite3 *db;\n  int moreToDo = 1;\n\n  pOrderBy = pSelect->pOrderBy;\n  if( pOrderBy==0 ) return 0;\n  db = pParse->db;\n#if SQLITE_MAX_COLUMN\n  if( pOrderBy->nExpr>db->aLimit[SQLITE_LIMIT_COLUMN] ){\n    sqlite3ErrorMsg(pParse, \"too many terms in ORDER BY clause\");\n    return 1;\n  }\n#endif\n  for(i=0; i<pOrderBy->nExpr; i++){\n    pOrderBy->a[i].done = 0;\n  }\n  pSelect->pNext = 0;\n  while( pSelect->pPrior ){\n    pSelect->pPrior->pNext = pSelect;\n    pSelect = pSelect->pPrior;\n  }\n  while( pSelect && moreToDo ){\n    struct ExprList_item *pItem;\n    moreToDo = 0;\n    pEList = pSelect->pEList;\n    assert( pEList!=0 );\n    for(i=0, pItem=pOrderBy->a; i<pOrderBy->nExpr; i++, pItem++){\n      int iCol = -1;\n      Expr *pE, *pDup;\n      if( pItem->done ) continue;\n      pE = pItem->pExpr;\n      if( sqlite3ExprIsInteger(pE, &iCol) ){\n        if( iCol<=0 || iCol>pEList->nExpr ){\n          resolveOutOfRangeError(pParse, \"ORDER\", i+1, pEList->nExpr);\n          return 1;\n        }\n      }else{\n        iCol = resolveAsName(pParse, pEList, pE);\n        if( iCol==0 ){\n          pDup = sqlite3ExprDup(db, pE, 0);\n          if( !db->mallocFailed ){\n            assert(pDup);\n            iCol = resolveOrderByTermToExprList(pParse, pSelect, pDup);\n          }\n          sqlite3ExprDelete(db, pDup);\n        }\n      }\n      if( iCol>0 ){\n        CollSeq *pColl = pE->pColl;\n        int flags = pE->flags & EP_ExpCollate;\n        sqlite3ExprDelete(db, pE);\n        pItem->pExpr = pE = sqlite3Expr(db, TK_INTEGER, 0);\n        if( pE==0 ) return 1;\n        pE->pColl = pColl;\n        pE->flags |= EP_IntValue | flags;\n        pE->u.iValue = iCol;\n        pItem->iCol = (u16)iCol;\n        pItem->done = 1;\n      }else{\n        moreToDo = 1;\n      }\n    }\n    pSelect = pSelect->pNext;\n  }\n  for(i=0; i<pOrderBy->nExpr; i++){\n    if( pOrderBy->a[i].done==0 ){\n      sqlite3ErrorMsg(pParse, \"%r ORDER BY term does not match any \"\n            \"column in the result set\", i+1);\n      return 1;\n    }\n  }\n  return 0;\n}\n\n/*\n** Check every term in the ORDER BY or GROUP BY clause pOrderBy of\n** the SELECT statement pSelect.  If any term is reference to a\n** result set expression (as determined by the ExprList.a.iCol field)\n** then convert that term into a copy of the corresponding result set\n** column.\n**\n** If any errors are detected, add an error message to pParse and\n** return non-zero.  Return zero if no errors are seen.\n*/\nSQLITE_PRIVATE int sqlite3ResolveOrderGroupBy(\n  Parse *pParse,        /* Parsing context.  Leave error messages here */\n  Select *pSelect,      /* The SELECT statement containing the clause */\n  ExprList *pOrderBy,   /* The ORDER BY or GROUP BY clause to be processed */\n  const char *zType     /* \"ORDER\" or \"GROUP\" */\n){\n  int i;\n  sqlite3 *db = pParse->db;\n  ExprList *pEList;\n  struct ExprList_item *pItem;\n\n  if( pOrderBy==0 || pParse->db->mallocFailed ) return 0;\n#if SQLITE_MAX_COLUMN\n  if( pOrderBy->nExpr>db->aLimit[SQLITE_LIMIT_COLUMN] ){\n    sqlite3ErrorMsg(pParse, \"too many terms in %s BY clause\", zType);\n    return 1;\n  }\n#endif\n  pEList = pSelect->pEList;\n  assert( pEList!=0 );  /* sqlite3SelectNew() guarantees this */\n  for(i=0, pItem=pOrderBy->a; i<pOrderBy->nExpr; i++, pItem++){\n    if( pItem->iCol ){\n      if( pItem->iCol>pEList->nExpr ){\n        resolveOutOfRangeError(pParse, zType, i+1, pEList->nExpr);\n        return 1;\n      }\n      resolveAlias(pParse, pEList, pItem->iCol-1, pItem->pExpr, zType);\n    }\n  }\n  return 0;\n}\n\n/*\n** pOrderBy is an ORDER BY or GROUP BY clause in SELECT statement pSelect.\n** The Name context of the SELECT statement is pNC.  zType is either\n** \"ORDER\" or \"GROUP\" depending on which type of clause pOrderBy is.\n**\n** This routine resolves each term of the clause into an expression.\n** If the order-by term is an integer I between 1 and N (where N is the\n** number of columns in the result set of the SELECT) then the expression\n** in the resolution is a copy of the I-th result-set expression.  If\n** the order-by term is an identify that corresponds to the AS-name of\n** a result-set expression, then the term resolves to a copy of the\n** result-set expression.  Otherwise, the expression is resolved in\n** the usual way - using sqlite3ResolveExprNames().\n**\n** This routine returns the number of errors.  If errors occur, then\n** an appropriate error message might be left in pParse.  (OOM errors\n** excepted.)\n*/\nstatic int resolveOrderGroupBy(\n  NameContext *pNC,     /* The name context of the SELECT statement */\n  Select *pSelect,      /* The SELECT statement holding pOrderBy */\n  ExprList *pOrderBy,   /* An ORDER BY or GROUP BY clause to resolve */\n  const char *zType     /* Either \"ORDER\" or \"GROUP\", as appropriate */\n){\n  int i;                         /* Loop counter */\n  int iCol;                      /* Column number */\n  struct ExprList_item *pItem;   /* A term of the ORDER BY clause */\n  Parse *pParse;                 /* Parsing context */\n  int nResult;                   /* Number of terms in the result set */\n\n  if( pOrderBy==0 ) return 0;\n  nResult = pSelect->pEList->nExpr;\n  pParse = pNC->pParse;\n  for(i=0, pItem=pOrderBy->a; i<pOrderBy->nExpr; i++, pItem++){\n    Expr *pE = pItem->pExpr;\n    iCol = resolveAsName(pParse, pSelect->pEList, pE);\n    if( iCol>0 ){\n      /* If an AS-name match is found, mark this ORDER BY column as being\n      ** a copy of the iCol-th result-set column.  The subsequent call to\n      ** sqlite3ResolveOrderGroupBy() will convert the expression to a\n      ** copy of the iCol-th result-set expression. */\n      pItem->iCol = (u16)iCol;\n      continue;\n    }\n    if( sqlite3ExprIsInteger(pE, &iCol) ){\n      /* The ORDER BY term is an integer constant.  Again, set the column\n      ** number so that sqlite3ResolveOrderGroupBy() will convert the\n      ** order-by term to a copy of the result-set expression */\n      if( iCol<1 ){\n        resolveOutOfRangeError(pParse, zType, i+1, nResult);\n        return 1;\n      }\n      pItem->iCol = (u16)iCol;\n      continue;\n    }\n\n    /* Otherwise, treat the ORDER BY term as an ordinary expression */\n    pItem->iCol = 0;\n    if( sqlite3ResolveExprNames(pNC, pE) ){\n      return 1;\n    }\n  }\n  return sqlite3ResolveOrderGroupBy(pParse, pSelect, pOrderBy, zType);\n}\n\n/*\n** Resolve names in the SELECT statement p and all of its descendents.\n*/\nstatic int resolveSelectStep(Walker *pWalker, Select *p){\n  NameContext *pOuterNC;  /* Context that contains this SELECT */\n  NameContext sNC;        /* Name context of this SELECT */\n  int isCompound;         /* True if p is a compound select */\n  int nCompound;          /* Number of compound terms processed so far */\n  Parse *pParse;          /* Parsing context */\n  ExprList *pEList;       /* Result set expression list */\n  int i;                  /* Loop counter */\n  ExprList *pGroupBy;     /* The GROUP BY clause */\n  Select *pLeftmost;      /* Left-most of SELECT of a compound */\n  sqlite3 *db;            /* Database connection */\n  \n\n  assert( p!=0 );\n  if( p->selFlags & SF_Resolved ){\n    return WRC_Prune;\n  }\n  pOuterNC = pWalker->u.pNC;\n  pParse = pWalker->pParse;\n  db = pParse->db;\n\n  /* Normally sqlite3SelectExpand() will be called first and will have\n  ** already expanded this SELECT.  However, if this is a subquery within\n  ** an expression, sqlite3ResolveExprNames() will be called without a\n  ** prior call to sqlite3SelectExpand().  When that happens, let\n  ** sqlite3SelectPrep() do all of the processing for this SELECT.\n  ** sqlite3SelectPrep() will invoke both sqlite3SelectExpand() and\n  ** this routine in the correct order.\n  */\n  if( (p->selFlags & SF_Expanded)==0 ){\n    sqlite3SelectPrep(pParse, p, pOuterNC);\n    return (pParse->nErr || db->mallocFailed) ? WRC_Abort : WRC_Prune;\n  }\n\n  isCompound = p->pPrior!=0;\n  nCompound = 0;\n  pLeftmost = p;\n  while( p ){\n    assert( (p->selFlags & SF_Expanded)!=0 );\n    assert( (p->selFlags & SF_Resolved)==0 );\n    p->selFlags |= SF_Resolved;\n\n    /* Resolve the expressions in the LIMIT and OFFSET clauses. These\n    ** are not allowed to refer to any names, so pass an empty NameContext.\n    */\n    memset(&sNC, 0, sizeof(sNC));\n    sNC.pParse = pParse;\n    if( sqlite3ResolveExprNames(&sNC, p->pLimit) ||\n        sqlite3ResolveExprNames(&sNC, p->pOffset) ){\n      return WRC_Abort;\n    }\n  \n    /* Set up the local name-context to pass to sqlite3ResolveExprNames() to\n    ** resolve the result-set expression list.\n    */\n    sNC.allowAgg = 1;\n    sNC.pSrcList = p->pSrc;\n    sNC.pNext = pOuterNC;\n  \n    /* Resolve names in the result set. */\n    pEList = p->pEList;\n    assert( pEList!=0 );\n    for(i=0; i<pEList->nExpr; i++){\n      Expr *pX = pEList->a[i].pExpr;\n      if( sqlite3ResolveExprNames(&sNC, pX) ){\n        return WRC_Abort;\n      }\n    }\n  \n    /* Recursively resolve names in all subqueries\n    */\n    for(i=0; i<p->pSrc->nSrc; i++){\n      struct SrcList_item *pItem = &p->pSrc->a[i];\n      if( pItem->pSelect ){\n        const char *zSavedContext = pParse->zAuthContext;\n        if( pItem->zName ) pParse->zAuthContext = pItem->zName;\n        sqlite3ResolveSelectNames(pParse, pItem->pSelect, pOuterNC);\n        pParse->zAuthContext = zSavedContext;\n        if( pParse->nErr || db->mallocFailed ) return WRC_Abort;\n      }\n    }\n  \n    /* If there are no aggregate functions in the result-set, and no GROUP BY \n    ** expression, do not allow aggregates in any of the other expressions.\n    */\n    assert( (p->selFlags & SF_Aggregate)==0 );\n    pGroupBy = p->pGroupBy;\n    if( pGroupBy || sNC.hasAgg ){\n      p->selFlags |= SF_Aggregate;\n    }else{\n      sNC.allowAgg = 0;\n    }\n  \n    /* If a HAVING clause is present, then there must be a GROUP BY clause.\n    */\n    if( p->pHaving && !pGroupBy ){\n      sqlite3ErrorMsg(pParse, \"a GROUP BY clause is required before HAVING\");\n      return WRC_Abort;\n    }\n  \n    /* Add the expression list to the name-context before parsing the\n    ** other expressions in the SELECT statement. This is so that\n    ** expressions in the WHERE clause (etc.) can refer to expressions by\n    ** aliases in the result set.\n    **\n    ** Minor point: If this is the case, then the expression will be\n    ** re-evaluated for each reference to it.\n    */\n    sNC.pEList = p->pEList;\n    if( sqlite3ResolveExprNames(&sNC, p->pWhere) ||\n       sqlite3ResolveExprNames(&sNC, p->pHaving)\n    ){\n      return WRC_Abort;\n    }\n\n    /* The ORDER BY and GROUP BY clauses may not refer to terms in\n    ** outer queries \n    */\n    sNC.pNext = 0;\n    sNC.allowAgg = 1;\n\n    /* Process the ORDER BY clause for singleton SELECT statements.\n    ** The ORDER BY clause for compounds SELECT statements is handled\n    ** below, after all of the result-sets for all of the elements of\n    ** the compound have been resolved.\n    */\n    if( !isCompound && resolveOrderGroupBy(&sNC, p, p->pOrderBy, \"ORDER\") ){\n      return WRC_Abort;\n    }\n    if( db->mallocFailed ){\n      return WRC_Abort;\n    }\n  \n    /* Resolve the GROUP BY clause.  At the same time, make sure \n    ** the GROUP BY clause does not contain aggregate functions.\n    */\n    if( pGroupBy ){\n      struct ExprList_item *pItem;\n    \n      if( resolveOrderGroupBy(&sNC, p, pGroupBy, \"GROUP\") || db->mallocFailed ){\n        return WRC_Abort;\n      }\n      for(i=0, pItem=pGroupBy->a; i<pGroupBy->nExpr; i++, pItem++){\n        if( ExprHasProperty(pItem->pExpr, EP_Agg) ){\n          sqlite3ErrorMsg(pParse, \"aggregate functions are not allowed in \"\n              \"the GROUP BY clause\");\n          return WRC_Abort;\n        }\n      }\n    }\n\n    /* Advance to the next term of the compound\n    */\n    p = p->pPrior;\n    nCompound++;\n  }\n\n  /* Resolve the ORDER BY on a compound SELECT after all terms of\n  ** the compound have been resolved.\n  */\n  if( isCompound && resolveCompoundOrderBy(pParse, pLeftmost) ){\n    return WRC_Abort;\n  }\n\n  return WRC_Prune;\n}\n\n/*\n** This routine walks an expression tree and resolves references to\n** table columns and result-set columns.  At the same time, do error\n** checking on function usage and set a flag if any aggregate functions\n** are seen.\n**\n** To resolve table columns references we look for nodes (or subtrees) of the \n** form X.Y.Z or Y.Z or just Z where\n**\n**      X:   The name of a database.  Ex:  \"main\" or \"temp\" or\n**           the symbolic name assigned to an ATTACH-ed database.\n**\n**      Y:   The name of a table in a FROM clause.  Or in a trigger\n**           one of the special names \"old\" or \"new\".\n**\n**      Z:   The name of a column in table Y.\n**\n** The node at the root of the subtree is modified as follows:\n**\n**    Expr.op        Changed to TK_COLUMN\n**    Expr.pTab      Points to the Table object for X.Y\n**    Expr.iColumn   The column index in X.Y.  -1 for the rowid.\n**    Expr.iTable    The VDBE cursor number for X.Y\n**\n**\n** To resolve result-set references, look for expression nodes of the\n** form Z (with no X and Y prefix) where the Z matches the right-hand\n** size of an AS clause in the result-set of a SELECT.  The Z expression\n** is replaced by a copy of the left-hand side of the result-set expression.\n** Table-name and function resolution occurs on the substituted expression\n** tree.  For example, in:\n**\n**      SELECT a+b AS x, c+d AS y FROM t1 ORDER BY x;\n**\n** The \"x\" term of the order by is replaced by \"a+b\" to render:\n**\n**      SELECT a+b AS x, c+d AS y FROM t1 ORDER BY a+b;\n**\n** Function calls are checked to make sure that the function is \n** defined and that the correct number of arguments are specified.\n** If the function is an aggregate function, then the pNC->hasAgg is\n** set and the opcode is changed from TK_FUNCTION to TK_AGG_FUNCTION.\n** If an expression contains aggregate functions then the EP_Agg\n** property on the expression is set.\n**\n** An error message is left in pParse if anything is amiss.  The number\n** if errors is returned.\n*/\nSQLITE_PRIVATE int sqlite3ResolveExprNames( \n  NameContext *pNC,       /* Namespace to resolve expressions in. */\n  Expr *pExpr             /* The expression to be analyzed. */\n){\n  int savedHasAgg;\n  Walker w;\n\n  if( pExpr==0 ) return 0;\n#if SQLITE_MAX_EXPR_DEPTH>0\n  {\n    Parse *pParse = pNC->pParse;\n    if( sqlite3ExprCheckHeight(pParse, pExpr->nHeight+pNC->pParse->nHeight) ){\n      return 1;\n    }\n    pParse->nHeight += pExpr->nHeight;\n  }\n#endif\n  savedHasAgg = pNC->hasAgg;\n  pNC->hasAgg = 0;\n  w.xExprCallback = resolveExprStep;\n  w.xSelectCallback = resolveSelectStep;\n  w.pParse = pNC->pParse;\n  w.u.pNC = pNC;\n  sqlite3WalkExpr(&w, pExpr);\n#if SQLITE_MAX_EXPR_DEPTH>0\n  pNC->pParse->nHeight -= pExpr->nHeight;\n#endif\n  if( pNC->nErr>0 || w.pParse->nErr>0 ){\n    ExprSetProperty(pExpr, EP_Error);\n  }\n  if( pNC->hasAgg ){\n    ExprSetProperty(pExpr, EP_Agg);\n  }else if( savedHasAgg ){\n    pNC->hasAgg = 1;\n  }\n  return ExprHasProperty(pExpr, EP_Error);\n}\n\n\n/*\n** Resolve all names in all expressions of a SELECT and in all\n** decendents of the SELECT, including compounds off of p->pPrior,\n** subqueries in expressions, and subqueries used as FROM clause\n** terms.\n**\n** See sqlite3ResolveExprNames() for a description of the kinds of\n** transformations that occur.\n**\n** All SELECT statements should have been expanded using\n** sqlite3SelectExpand() prior to invoking this routine.\n*/\nSQLITE_PRIVATE void sqlite3ResolveSelectNames(\n  Parse *pParse,         /* The parser context */\n  Select *p,             /* The SELECT statement being coded. */\n  NameContext *pOuterNC  /* Name context for parent SELECT statement */\n){\n  Walker w;\n\n  assert( p!=0 );\n  w.xExprCallback = resolveExprStep;\n  w.xSelectCallback = resolveSelectStep;\n  w.pParse = pParse;\n  w.u.pNC = pOuterNC;\n  sqlite3WalkSelect(&w, p);\n}\n\n/************** End of resolve.c *********************************************/\n/************** Begin file expr.c ********************************************/\n/*\n** 2001 September 15\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains routines used for analyzing expressions and\n** for generating VDBE code that evaluates expressions in SQLite.\n*/\n\n/*\n** Return the 'affinity' of the expression pExpr if any.\n**\n** If pExpr is a column, a reference to a column via an 'AS' alias,\n** or a sub-select with a column as the return value, then the \n** affinity of that column is returned. Otherwise, 0x00 is returned,\n** indicating no affinity for the expression.\n**\n** i.e. the WHERE clause expresssions in the following statements all\n** have an affinity:\n**\n** CREATE TABLE t1(a);\n** SELECT * FROM t1 WHERE a;\n** SELECT a AS b FROM t1 WHERE b;\n** SELECT * FROM t1 WHERE (select a from t1);\n*/\nSQLITE_PRIVATE char sqlite3ExprAffinity(Expr *pExpr){\n  int op = pExpr->op;\n  if( op==TK_SELECT ){\n    assert( pExpr->flags&EP_xIsSelect );\n    return sqlite3ExprAffinity(pExpr->x.pSelect->pEList->a[0].pExpr);\n  }\n#ifndef SQLITE_OMIT_CAST\n  if( op==TK_CAST ){\n    assert( !ExprHasProperty(pExpr, EP_IntValue) );\n    return sqlite3AffinityType(pExpr->u.zToken);\n  }\n#endif\n  if( (op==TK_AGG_COLUMN || op==TK_COLUMN || op==TK_REGISTER) \n   && pExpr->pTab!=0\n  ){\n    /* op==TK_REGISTER && pExpr->pTab!=0 happens when pExpr was originally\n    ** a TK_COLUMN but was previously evaluated and cached in a register */\n    int j = pExpr->iColumn;\n    if( j<0 ) return SQLITE_AFF_INTEGER;\n    assert( pExpr->pTab && j<pExpr->pTab->nCol );\n    return pExpr->pTab->aCol[j].affinity;\n  }\n  return pExpr->affinity;\n}\n\n/*\n** Set the explicit collating sequence for an expression to the\n** collating sequence supplied in the second argument.\n*/\nSQLITE_PRIVATE Expr *sqlite3ExprSetColl(Expr *pExpr, CollSeq *pColl){\n  if( pExpr && pColl ){\n    pExpr->pColl = pColl;\n    pExpr->flags |= EP_ExpCollate;\n  }\n  return pExpr;\n}\n\n/*\n** Set the collating sequence for expression pExpr to be the collating\n** sequence named by pToken.   Return a pointer to the revised expression.\n** The collating sequence is marked as \"explicit\" using the EP_ExpCollate\n** flag.  An explicit collating sequence will override implicit\n** collating sequences.\n*/\nSQLITE_PRIVATE Expr *sqlite3ExprSetCollByToken(Parse *pParse, Expr *pExpr, Token *pCollName){\n  char *zColl = 0;            /* Dequoted name of collation sequence */\n  CollSeq *pColl;\n  sqlite3 *db = pParse->db;\n  zColl = sqlite3NameFromToken(db, pCollName);\n  pColl = sqlite3LocateCollSeq(pParse, zColl);\n  sqlite3ExprSetColl(pExpr, pColl);\n  sqlite3DbFree(db, zColl);\n  return pExpr;\n}\n\n/*\n** Return the default collation sequence for the expression pExpr. If\n** there is no default collation type, return 0.\n*/\nSQLITE_PRIVATE CollSeq *sqlite3ExprCollSeq(Parse *pParse, Expr *pExpr){\n  CollSeq *pColl = 0;\n  Expr *p = pExpr;\n  while( p ){\n    int op;\n    pColl = p->pColl;\n    if( pColl ) break;\n    op = p->op;\n    if( p->pTab!=0 && (\n        op==TK_AGG_COLUMN || op==TK_COLUMN || op==TK_REGISTER || op==TK_TRIGGER\n    )){\n      /* op==TK_REGISTER && p->pTab!=0 happens when pExpr was originally\n      ** a TK_COLUMN but was previously evaluated and cached in a register */\n      const char *zColl;\n      int j = p->iColumn;\n      if( j>=0 ){\n        sqlite3 *db = pParse->db;\n        zColl = p->pTab->aCol[j].zColl;\n        pColl = sqlite3FindCollSeq(db, ENC(db), zColl, 0);\n        pExpr->pColl = pColl;\n      }\n      break;\n    }\n    if( op!=TK_CAST && op!=TK_UPLUS ){\n      break;\n    }\n    p = p->pLeft;\n  }\n  if( sqlite3CheckCollSeq(pParse, pColl) ){ \n    pColl = 0;\n  }\n  return pColl;\n}\n\n/*\n** pExpr is an operand of a comparison operator.  aff2 is the\n** type affinity of the other operand.  This routine returns the\n** type affinity that should be used for the comparison operator.\n*/\nSQLITE_PRIVATE char sqlite3CompareAffinity(Expr *pExpr, char aff2){\n  char aff1 = sqlite3ExprAffinity(pExpr);\n  if( aff1 && aff2 ){\n    /* Both sides of the comparison are columns. If one has numeric\n    ** affinity, use that. Otherwise use no affinity.\n    */\n    if( sqlite3IsNumericAffinity(aff1) || sqlite3IsNumericAffinity(aff2) ){\n      return SQLITE_AFF_NUMERIC;\n    }else{\n      return SQLITE_AFF_NONE;\n    }\n  }else if( !aff1 && !aff2 ){\n    /* Neither side of the comparison is a column.  Compare the\n    ** results directly.\n    */\n    return SQLITE_AFF_NONE;\n  }else{\n    /* One side is a column, the other is not. Use the columns affinity. */\n    assert( aff1==0 || aff2==0 );\n    return (aff1 + aff2);\n  }\n}\n\n/*\n** pExpr is a comparison operator.  Return the type affinity that should\n** be applied to both operands prior to doing the comparison.\n*/\nstatic char comparisonAffinity(Expr *pExpr){\n  char aff;\n  assert( pExpr->op==TK_EQ || pExpr->op==TK_IN || pExpr->op==TK_LT ||\n          pExpr->op==TK_GT || pExpr->op==TK_GE || pExpr->op==TK_LE ||\n          pExpr->op==TK_NE || pExpr->op==TK_IS || pExpr->op==TK_ISNOT );\n  assert( pExpr->pLeft );\n  aff = sqlite3ExprAffinity(pExpr->pLeft);\n  if( pExpr->pRight ){\n    aff = sqlite3CompareAffinity(pExpr->pRight, aff);\n  }else if( ExprHasProperty(pExpr, EP_xIsSelect) ){\n    aff = sqlite3CompareAffinity(pExpr->x.pSelect->pEList->a[0].pExpr, aff);\n  }else if( !aff ){\n    aff = SQLITE_AFF_NONE;\n  }\n  return aff;\n}\n\n/*\n** pExpr is a comparison expression, eg. '=', '<', IN(...) etc.\n** idx_affinity is the affinity of an indexed column. Return true\n** if the index with affinity idx_affinity may be used to implement\n** the comparison in pExpr.\n*/\nSQLITE_PRIVATE int sqlite3IndexAffinityOk(Expr *pExpr, char idx_affinity){\n  char aff = comparisonAffinity(pExpr);\n  switch( aff ){\n    case SQLITE_AFF_NONE:\n      return 1;\n    case SQLITE_AFF_TEXT:\n      return idx_affinity==SQLITE_AFF_TEXT;\n    default:\n      return sqlite3IsNumericAffinity(idx_affinity);\n  }\n}\n\n/*\n** Return the P5 value that should be used for a binary comparison\n** opcode (OP_Eq, OP_Ge etc.) used to compare pExpr1 and pExpr2.\n*/\nstatic u8 binaryCompareP5(Expr *pExpr1, Expr *pExpr2, int jumpIfNull){\n  u8 aff = (char)sqlite3ExprAffinity(pExpr2);\n  aff = (u8)sqlite3CompareAffinity(pExpr1, aff) | (u8)jumpIfNull;\n  return aff;\n}\n\n/*\n** Return a pointer to the collation sequence that should be used by\n** a binary comparison operator comparing pLeft and pRight.\n**\n** If the left hand expression has a collating sequence type, then it is\n** used. Otherwise the collation sequence for the right hand expression\n** is used, or the default (BINARY) if neither expression has a collating\n** type.\n**\n** Argument pRight (but not pLeft) may be a null pointer. In this case,\n** it is not considered.\n*/\nSQLITE_PRIVATE CollSeq *sqlite3BinaryCompareCollSeq(\n  Parse *pParse, \n  Expr *pLeft, \n  Expr *pRight\n){\n  CollSeq *pColl;\n  assert( pLeft );\n  if( pLeft->flags & EP_ExpCollate ){\n    assert( pLeft->pColl );\n    pColl = pLeft->pColl;\n  }else if( pRight && pRight->flags & EP_ExpCollate ){\n    assert( pRight->pColl );\n    pColl = pRight->pColl;\n  }else{\n    pColl = sqlite3ExprCollSeq(pParse, pLeft);\n    if( !pColl ){\n      pColl = sqlite3ExprCollSeq(pParse, pRight);\n    }\n  }\n  return pColl;\n}\n\n/*\n** Generate code for a comparison operator.\n*/\nstatic int codeCompare(\n  Parse *pParse,    /* The parsing (and code generating) context */\n  Expr *pLeft,      /* The left operand */\n  Expr *pRight,     /* The right operand */\n  int opcode,       /* The comparison opcode */\n  int in1, int in2, /* Register holding operands */\n  int dest,         /* Jump here if true.  */\n  int jumpIfNull    /* If true, jump if either operand is NULL */\n){\n  int p5;\n  int addr;\n  CollSeq *p4;\n\n  p4 = sqlite3BinaryCompareCollSeq(pParse, pLeft, pRight);\n  p5 = binaryCompareP5(pLeft, pRight, jumpIfNull);\n  addr = sqlite3VdbeAddOp4(pParse->pVdbe, opcode, in2, dest, in1,\n                           (void*)p4, P4_COLLSEQ);\n  sqlite3VdbeChangeP5(pParse->pVdbe, (u8)p5);\n  return addr;\n}\n\n#if SQLITE_MAX_EXPR_DEPTH>0\n/*\n** Check that argument nHeight is less than or equal to the maximum\n** expression depth allowed. If it is not, leave an error message in\n** pParse.\n*/\nSQLITE_PRIVATE int sqlite3ExprCheckHeight(Parse *pParse, int nHeight){\n  int rc = SQLITE_OK;\n  int mxHeight = pParse->db->aLimit[SQLITE_LIMIT_EXPR_DEPTH];\n  if( nHeight>mxHeight ){\n    sqlite3ErrorMsg(pParse, \n       \"Expression tree is too large (maximum depth %d)\", mxHeight\n    );\n    rc = SQLITE_ERROR;\n  }\n  return rc;\n}\n\n/* The following three functions, heightOfExpr(), heightOfExprList()\n** and heightOfSelect(), are used to determine the maximum height\n** of any expression tree referenced by the structure passed as the\n** first argument.\n**\n** If this maximum height is greater than the current value pointed\n** to by pnHeight, the second parameter, then set *pnHeight to that\n** value.\n*/\nstatic void heightOfExpr(Expr *p, int *pnHeight){\n  if( p ){\n    if( p->nHeight>*pnHeight ){\n      *pnHeight = p->nHeight;\n    }\n  }\n}\nstatic void heightOfExprList(ExprList *p, int *pnHeight){\n  if( p ){\n    int i;\n    for(i=0; i<p->nExpr; i++){\n      heightOfExpr(p->a[i].pExpr, pnHeight);\n    }\n  }\n}\nstatic void heightOfSelect(Select *p, int *pnHeight){\n  if( p ){\n    heightOfExpr(p->pWhere, pnHeight);\n    heightOfExpr(p->pHaving, pnHeight);\n    heightOfExpr(p->pLimit, pnHeight);\n    heightOfExpr(p->pOffset, pnHeight);\n    heightOfExprList(p->pEList, pnHeight);\n    heightOfExprList(p->pGroupBy, pnHeight);\n    heightOfExprList(p->pOrderBy, pnHeight);\n    heightOfSelect(p->pPrior, pnHeight);\n  }\n}\n\n/*\n** Set the Expr.nHeight variable in the structure passed as an \n** argument. An expression with no children, Expr.pList or \n** Expr.pSelect member has a height of 1. Any other expression\n** has a height equal to the maximum height of any other \n** referenced Expr plus one.\n*/\nstatic void exprSetHeight(Expr *p){\n  int nHeight = 0;\n  heightOfExpr(p->pLeft, &nHeight);\n  heightOfExpr(p->pRight, &nHeight);\n  if( ExprHasProperty(p, EP_xIsSelect) ){\n    heightOfSelect(p->x.pSelect, &nHeight);\n  }else{\n    heightOfExprList(p->x.pList, &nHeight);\n  }\n  p->nHeight = nHeight + 1;\n}\n\n/*\n** Set the Expr.nHeight variable using the exprSetHeight() function. If\n** the height is greater than the maximum allowed expression depth,\n** leave an error in pParse.\n*/\nSQLITE_PRIVATE void sqlite3ExprSetHeight(Parse *pParse, Expr *p){\n  exprSetHeight(p);\n  sqlite3ExprCheckHeight(pParse, p->nHeight);\n}\n\n/*\n** Return the maximum height of any expression tree referenced\n** by the select statement passed as an argument.\n*/\nSQLITE_PRIVATE int sqlite3SelectExprHeight(Select *p){\n  int nHeight = 0;\n  heightOfSelect(p, &nHeight);\n  return nHeight;\n}\n#else\n  #define exprSetHeight(y)\n#endif /* SQLITE_MAX_EXPR_DEPTH>0 */\n\n/*\n** This routine is the core allocator for Expr nodes.\n**\n** Construct a new expression node and return a pointer to it.  Memory\n** for this node and for the pToken argument is a single allocation\n** obtained from sqlite3DbMalloc().  The calling function\n** is responsible for making sure the node eventually gets freed.\n**\n** If dequote is true, then the token (if it exists) is dequoted.\n** If dequote is false, no dequoting is performance.  The deQuote\n** parameter is ignored if pToken is NULL or if the token does not\n** appear to be quoted.  If the quotes were of the form \"...\" (double-quotes)\n** then the EP_DblQuoted flag is set on the expression node.\n**\n** Special case:  If op==TK_INTEGER and pToken points to a string that\n** can be translated into a 32-bit integer, then the token is not\n** stored in u.zToken.  Instead, the integer values is written\n** into u.iValue and the EP_IntValue flag is set.  No extra storage\n** is allocated to hold the integer text and the dequote flag is ignored.\n*/\nSQLITE_PRIVATE Expr *sqlite3ExprAlloc(\n  sqlite3 *db,            /* Handle for sqlite3DbMallocZero() (may be null) */\n  int op,                 /* Expression opcode */\n  const Token *pToken,    /* Token argument.  Might be NULL */\n  int dequote             /* True to dequote */\n){\n  Expr *pNew;\n  int nExtra = 0;\n  int iValue = 0;\n\n  if( pToken ){\n    if( op!=TK_INTEGER || pToken->z==0\n          || sqlite3GetInt32(pToken->z, &iValue)==0 ){\n      nExtra = pToken->n+1;\n      assert( iValue>=0 );\n    }\n  }\n  pNew = sqlite3DbMallocZero(db, sizeof(Expr)+nExtra);\n  if( pNew ){\n    pNew->op = (u8)op;\n    pNew->iAgg = -1;\n    if( pToken ){\n      if( nExtra==0 ){\n        pNew->flags |= EP_IntValue;\n        pNew->u.iValue = iValue;\n      }else{\n        int c;\n        pNew->u.zToken = (char*)&pNew[1];\n        memcpy(pNew->u.zToken, pToken->z, pToken->n);\n        pNew->u.zToken[pToken->n] = 0;\n        if( dequote && nExtra>=3 \n             && ((c = pToken->z[0])=='\\'' || c=='\"' || c=='[' || c=='`') ){\n          sqlite3Dequote(pNew->u.zToken);\n          if( c=='\"' ) pNew->flags |= EP_DblQuoted;\n        }\n      }\n    }\n#if SQLITE_MAX_EXPR_DEPTH>0\n    pNew->nHeight = 1;\n#endif  \n  }\n  return pNew;\n}\n\n/*\n** Allocate a new expression node from a zero-terminated token that has\n** already been dequoted.\n*/\nSQLITE_PRIVATE Expr *sqlite3Expr(\n  sqlite3 *db,            /* Handle for sqlite3DbMallocZero() (may be null) */\n  int op,                 /* Expression opcode */\n  const char *zToken      /* Token argument.  Might be NULL */\n){\n  Token x;\n  x.z = zToken;\n  x.n = zToken ? sqlite3Strlen30(zToken) : 0;\n  return sqlite3ExprAlloc(db, op, &x, 0);\n}\n\n/*\n** Attach subtrees pLeft and pRight to the Expr node pRoot.\n**\n** If pRoot==NULL that means that a memory allocation error has occurred.\n** In that case, delete the subtrees pLeft and pRight.\n*/\nSQLITE_PRIVATE void sqlite3ExprAttachSubtrees(\n  sqlite3 *db,\n  Expr *pRoot,\n  Expr *pLeft,\n  Expr *pRight\n){\n  if( pRoot==0 ){\n    assert( db->mallocFailed );\n    sqlite3ExprDelete(db, pLeft);\n    sqlite3ExprDelete(db, pRight);\n  }else{\n    if( pRight ){\n      pRoot->pRight = pRight;\n      if( pRight->flags & EP_ExpCollate ){\n        pRoot->flags |= EP_ExpCollate;\n        pRoot->pColl = pRight->pColl;\n      }\n    }\n    if( pLeft ){\n      pRoot->pLeft = pLeft;\n      if( pLeft->flags & EP_ExpCollate ){\n        pRoot->flags |= EP_ExpCollate;\n        pRoot->pColl = pLeft->pColl;\n      }\n    }\n    exprSetHeight(pRoot);\n  }\n}\n\n/*\n** Allocate a Expr node which joins as many as two subtrees.\n**\n** One or both of the subtrees can be NULL.  Return a pointer to the new\n** Expr node.  Or, if an OOM error occurs, set pParse->db->mallocFailed,\n** free the subtrees and return NULL.\n*/\nSQLITE_PRIVATE Expr *sqlite3PExpr(\n  Parse *pParse,          /* Parsing context */\n  int op,                 /* Expression opcode */\n  Expr *pLeft,            /* Left operand */\n  Expr *pRight,           /* Right operand */\n  const Token *pToken     /* Argument token */\n){\n  Expr *p = sqlite3ExprAlloc(pParse->db, op, pToken, 1);\n  sqlite3ExprAttachSubtrees(pParse->db, p, pLeft, pRight);\n  if( p ) {\n    sqlite3ExprCheckHeight(pParse, p->nHeight);\n  }\n  return p;\n}\n\n/*\n** Join two expressions using an AND operator.  If either expression is\n** NULL, then just return the other expression.\n*/\nSQLITE_PRIVATE Expr *sqlite3ExprAnd(sqlite3 *db, Expr *pLeft, Expr *pRight){\n  if( pLeft==0 ){\n    return pRight;\n  }else if( pRight==0 ){\n    return pLeft;\n  }else{\n    Expr *pNew = sqlite3ExprAlloc(db, TK_AND, 0, 0);\n    sqlite3ExprAttachSubtrees(db, pNew, pLeft, pRight);\n    return pNew;\n  }\n}\n\n/*\n** Construct a new expression node for a function with multiple\n** arguments.\n*/\nSQLITE_PRIVATE Expr *sqlite3ExprFunction(Parse *pParse, ExprList *pList, Token *pToken){\n  Expr *pNew;\n  sqlite3 *db = pParse->db;\n  assert( pToken );\n  pNew = sqlite3ExprAlloc(db, TK_FUNCTION, pToken, 1);\n  if( pNew==0 ){\n    sqlite3ExprListDelete(db, pList); /* Avoid memory leak when malloc fails */\n    return 0;\n  }\n  pNew->x.pList = pList;\n  assert( !ExprHasProperty(pNew, EP_xIsSelect) );\n  sqlite3ExprSetHeight(pParse, pNew);\n  return pNew;\n}\n\n/*\n** Assign a variable number to an expression that encodes a wildcard\n** in the original SQL statement.  \n**\n** Wildcards consisting of a single \"?\" are assigned the next sequential\n** variable number.\n**\n** Wildcards of the form \"?nnn\" are assigned the number \"nnn\".  We make\n** sure \"nnn\" is not too be to avoid a denial of service attack when\n** the SQL statement comes from an external source.\n**\n** Wildcards of the form \":aaa\", \"@aaa\", or \"$aaa\" are assigned the same number\n** as the previous instance of the same wildcard.  Or if this is the first\n** instance of the wildcard, the next sequenial variable number is\n** assigned.\n*/\nSQLITE_PRIVATE void sqlite3ExprAssignVarNumber(Parse *pParse, Expr *pExpr){\n  sqlite3 *db = pParse->db;\n  const char *z;\n\n  if( pExpr==0 ) return;\n  assert( !ExprHasAnyProperty(pExpr, EP_IntValue|EP_Reduced|EP_TokenOnly) );\n  z = pExpr->u.zToken;\n  assert( z!=0 );\n  assert( z[0]!=0 );\n  if( z[1]==0 ){\n    /* Wildcard of the form \"?\".  Assign the next variable number */\n    assert( z[0]=='?' );\n    pExpr->iColumn = (ynVar)(++pParse->nVar);\n  }else if( z[0]=='?' ){\n    /* Wildcard of the form \"?nnn\".  Convert \"nnn\" to an integer and\n    ** use it as the variable number */\n    i64 i;\n    int bOk = 0==sqlite3Atoi64(&z[1], &i, sqlite3Strlen30(&z[1]), SQLITE_UTF8);\n    pExpr->iColumn = (ynVar)i;\n    testcase( i==0 );\n    testcase( i==1 );\n    testcase( i==db->aLimit[SQLITE_LIMIT_VARIABLE_NUMBER]-1 );\n    testcase( i==db->aLimit[SQLITE_LIMIT_VARIABLE_NUMBER] );\n    if( bOk==0 || i<1 || i>db->aLimit[SQLITE_LIMIT_VARIABLE_NUMBER] ){\n      sqlite3ErrorMsg(pParse, \"variable number must be between ?1 and ?%d\",\n          db->aLimit[SQLITE_LIMIT_VARIABLE_NUMBER]);\n    }\n    if( i>pParse->nVar ){\n      pParse->nVar = (int)i;\n    }\n  }else{\n    /* Wildcards like \":aaa\", \"$aaa\" or \"@aaa\".  Reuse the same variable\n    ** number as the prior appearance of the same name, or if the name\n    ** has never appeared before, reuse the same variable number\n    */\n    int i;\n    u32 n;\n    n = sqlite3Strlen30(z);\n    for(i=0; i<pParse->nVarExpr; i++){\n      Expr *pE = pParse->apVarExpr[i];\n      assert( pE!=0 );\n      if( memcmp(pE->u.zToken, z, n)==0 && pE->u.zToken[n]==0 ){\n        pExpr->iColumn = pE->iColumn;\n        break;\n      }\n    }\n    if( i>=pParse->nVarExpr ){\n      pExpr->iColumn = (ynVar)(++pParse->nVar);\n      if( pParse->nVarExpr>=pParse->nVarExprAlloc-1 ){\n        pParse->nVarExprAlloc += pParse->nVarExprAlloc + 10;\n        pParse->apVarExpr =\n            sqlite3DbReallocOrFree(\n              db,\n              pParse->apVarExpr,\n              pParse->nVarExprAlloc*sizeof(pParse->apVarExpr[0])\n            );\n      }\n      if( !db->mallocFailed ){\n        assert( pParse->apVarExpr!=0 );\n        pParse->apVarExpr[pParse->nVarExpr++] = pExpr;\n      }\n    }\n  } \n  if( !pParse->nErr && pParse->nVar>db->aLimit[SQLITE_LIMIT_VARIABLE_NUMBER] ){\n    sqlite3ErrorMsg(pParse, \"too many SQL variables\");\n  }\n}\n\n/*\n** Recursively delete an expression tree.\n*/\nSQLITE_PRIVATE void sqlite3ExprDelete(sqlite3 *db, Expr *p){\n  if( p==0 ) return;\n  /* Sanity check: Assert that the IntValue is non-negative if it exists */\n  assert( !ExprHasProperty(p, EP_IntValue) || p->u.iValue>=0 );\n  if( !ExprHasAnyProperty(p, EP_TokenOnly) ){\n    sqlite3ExprDelete(db, p->pLeft);\n    sqlite3ExprDelete(db, p->pRight);\n    if( !ExprHasProperty(p, EP_Reduced) && (p->flags2 & EP2_MallocedToken)!=0 ){\n      sqlite3DbFree(db, p->u.zToken);\n    }\n    if( ExprHasProperty(p, EP_xIsSelect) ){\n      sqlite3SelectDelete(db, p->x.pSelect);\n    }else{\n      sqlite3ExprListDelete(db, p->x.pList);\n    }\n  }\n  if( !ExprHasProperty(p, EP_Static) ){\n    sqlite3DbFree(db, p);\n  }\n}\n\n/*\n** Return the number of bytes allocated for the expression structure \n** passed as the first argument. This is always one of EXPR_FULLSIZE,\n** EXPR_REDUCEDSIZE or EXPR_TOKENONLYSIZE.\n*/\nstatic int exprStructSize(Expr *p){\n  if( ExprHasProperty(p, EP_TokenOnly) ) return EXPR_TOKENONLYSIZE;\n  if( ExprHasProperty(p, EP_Reduced) ) return EXPR_REDUCEDSIZE;\n  return EXPR_FULLSIZE;\n}\n\n/*\n** The dupedExpr*Size() routines each return the number of bytes required\n** to store a copy of an expression or expression tree.  They differ in\n** how much of the tree is measured.\n**\n**     dupedExprStructSize()     Size of only the Expr structure \n**     dupedExprNodeSize()       Size of Expr + space for token\n**     dupedExprSize()           Expr + token + subtree components\n**\n***************************************************************************\n**\n** The dupedExprStructSize() function returns two values OR-ed together:  \n** (1) the space required for a copy of the Expr structure only and \n** (2) the EP_xxx flags that indicate what the structure size should be.\n** The return values is always one of:\n**\n**      EXPR_FULLSIZE\n**      EXPR_REDUCEDSIZE   | EP_Reduced\n**      EXPR_TOKENONLYSIZE | EP_TokenOnly\n**\n** The size of the structure can be found by masking the return value\n** of this routine with 0xfff.  The flags can be found by masking the\n** return value with EP_Reduced|EP_TokenOnly.\n**\n** Note that with flags==EXPRDUP_REDUCE, this routines works on full-size\n** (unreduced) Expr objects as they or originally constructed by the parser.\n** During expression analysis, extra information is computed and moved into\n** later parts of teh Expr object and that extra information might get chopped\n** off if the expression is reduced.  Note also that it does not work to\n** make a EXPRDUP_REDUCE copy of a reduced expression.  It is only legal\n** to reduce a pristine expression tree from the parser.  The implementation\n** of dupedExprStructSize() contain multiple assert() statements that attempt\n** to enforce this constraint.\n*/\nstatic int dupedExprStructSize(Expr *p, int flags){\n  int nSize;\n  assert( flags==EXPRDUP_REDUCE || flags==0 ); /* Only one flag value allowed */\n  if( 0==(flags&EXPRDUP_REDUCE) ){\n    nSize = EXPR_FULLSIZE;\n  }else{\n    assert( !ExprHasAnyProperty(p, EP_TokenOnly|EP_Reduced) );\n    assert( !ExprHasProperty(p, EP_FromJoin) ); \n    assert( (p->flags2 & EP2_MallocedToken)==0 );\n    assert( (p->flags2 & EP2_Irreducible)==0 );\n    if( p->pLeft || p->pRight || p->pColl || p->x.pList ){\n      nSize = EXPR_REDUCEDSIZE | EP_Reduced;\n    }else{\n      nSize = EXPR_TOKENONLYSIZE | EP_TokenOnly;\n    }\n  }\n  return nSize;\n}\n\n/*\n** This function returns the space in bytes required to store the copy \n** of the Expr structure and a copy of the Expr.u.zToken string (if that\n** string is defined.)\n*/\nstatic int dupedExprNodeSize(Expr *p, int flags){\n  int nByte = dupedExprStructSize(p, flags) & 0xfff;\n  if( !ExprHasProperty(p, EP_IntValue) && p->u.zToken ){\n    nByte += sqlite3Strlen30(p->u.zToken)+1;\n  }\n  return ROUND8(nByte);\n}\n\n/*\n** Return the number of bytes required to create a duplicate of the \n** expression passed as the first argument. The second argument is a\n** mask containing EXPRDUP_XXX flags.\n**\n** The value returned includes space to create a copy of the Expr struct\n** itself and the buffer referred to by Expr.u.zToken, if any.\n**\n** If the EXPRDUP_REDUCE flag is set, then the return value includes \n** space to duplicate all Expr nodes in the tree formed by Expr.pLeft \n** and Expr.pRight variables (but not for any structures pointed to or \n** descended from the Expr.x.pList or Expr.x.pSelect variables).\n*/\nstatic int dupedExprSize(Expr *p, int flags){\n  int nByte = 0;\n  if( p ){\n    nByte = dupedExprNodeSize(p, flags);\n    if( flags&EXPRDUP_REDUCE ){\n      nByte += dupedExprSize(p->pLeft, flags) + dupedExprSize(p->pRight, flags);\n    }\n  }\n  return nByte;\n}\n\n/*\n** This function is similar to sqlite3ExprDup(), except that if pzBuffer \n** is not NULL then *pzBuffer is assumed to point to a buffer large enough \n** to store the copy of expression p, the copies of p->u.zToken\n** (if applicable), and the copies of the p->pLeft and p->pRight expressions,\n** if any. Before returning, *pzBuffer is set to the first byte passed the\n** portion of the buffer copied into by this function.\n*/\nstatic Expr *exprDup(sqlite3 *db, Expr *p, int flags, u8 **pzBuffer){\n  Expr *pNew = 0;                      /* Value to return */\n  if( p ){\n    const int isReduced = (flags&EXPRDUP_REDUCE);\n    u8 *zAlloc;\n    u32 staticFlag = 0;\n\n    assert( pzBuffer==0 || isReduced );\n\n    /* Figure out where to write the new Expr structure. */\n    if( pzBuffer ){\n      zAlloc = *pzBuffer;\n      staticFlag = EP_Static;\n    }else{\n      zAlloc = sqlite3DbMallocRaw(db, dupedExprSize(p, flags));\n    }\n    pNew = (Expr *)zAlloc;\n\n    if( pNew ){\n      /* Set nNewSize to the size allocated for the structure pointed to\n      ** by pNew. This is either EXPR_FULLSIZE, EXPR_REDUCEDSIZE or\n      ** EXPR_TOKENONLYSIZE. nToken is set to the number of bytes consumed\n      ** by the copy of the p->u.zToken string (if any).\n      */\n      const unsigned nStructSize = dupedExprStructSize(p, flags);\n      const int nNewSize = nStructSize & 0xfff;\n      int nToken;\n      if( !ExprHasProperty(p, EP_IntValue) && p->u.zToken ){\n        nToken = sqlite3Strlen30(p->u.zToken) + 1;\n      }else{\n        nToken = 0;\n      }\n      if( isReduced ){\n        assert( ExprHasProperty(p, EP_Reduced)==0 );\n        memcpy(zAlloc, p, nNewSize);\n      }else{\n        int nSize = exprStructSize(p);\n        memcpy(zAlloc, p, nSize);\n        memset(&zAlloc[nSize], 0, EXPR_FULLSIZE-nSize);\n      }\n\n      /* Set the EP_Reduced, EP_TokenOnly, and EP_Static flags appropriately. */\n      pNew->flags &= ~(EP_Reduced|EP_TokenOnly|EP_Static);\n      pNew->flags |= nStructSize & (EP_Reduced|EP_TokenOnly);\n      pNew->flags |= staticFlag;\n\n      /* Copy the p->u.zToken string, if any. */\n      if( nToken ){\n        char *zToken = pNew->u.zToken = (char*)&zAlloc[nNewSize];\n        memcpy(zToken, p->u.zToken, nToken);\n      }\n\n      if( 0==((p->flags|pNew->flags) & EP_TokenOnly) ){\n        /* Fill in the pNew->x.pSelect or pNew->x.pList member. */\n        if( ExprHasProperty(p, EP_xIsSelect) ){\n          pNew->x.pSelect = sqlite3SelectDup(db, p->x.pSelect, isReduced);\n        }else{\n          pNew->x.pList = sqlite3ExprListDup(db, p->x.pList, isReduced);\n        }\n      }\n\n      /* Fill in pNew->pLeft and pNew->pRight. */\n      if( ExprHasAnyProperty(pNew, EP_Reduced|EP_TokenOnly) ){\n        zAlloc += dupedExprNodeSize(p, flags);\n        if( ExprHasProperty(pNew, EP_Reduced) ){\n          pNew->pLeft = exprDup(db, p->pLeft, EXPRDUP_REDUCE, &zAlloc);\n          pNew->pRight = exprDup(db, p->pRight, EXPRDUP_REDUCE, &zAlloc);\n        }\n        if( pzBuffer ){\n          *pzBuffer = zAlloc;\n        }\n      }else{\n        pNew->flags2 = 0;\n        if( !ExprHasAnyProperty(p, EP_TokenOnly) ){\n          pNew->pLeft = sqlite3ExprDup(db, p->pLeft, 0);\n          pNew->pRight = sqlite3ExprDup(db, p->pRight, 0);\n        }\n      }\n\n    }\n  }\n  return pNew;\n}\n\n/*\n** The following group of routines make deep copies of expressions,\n** expression lists, ID lists, and select statements.  The copies can\n** be deleted (by being passed to their respective ...Delete() routines)\n** without effecting the originals.\n**\n** The expression list, ID, and source lists return by sqlite3ExprListDup(),\n** sqlite3IdListDup(), and sqlite3SrcListDup() can not be further expanded \n** by subsequent calls to sqlite*ListAppend() routines.\n**\n** Any tables that the SrcList might point to are not duplicated.\n**\n** The flags parameter contains a combination of the EXPRDUP_XXX flags.\n** If the EXPRDUP_REDUCE flag is set, then the structure returned is a\n** truncated version of the usual Expr structure that will be stored as\n** part of the in-memory representation of the database schema.\n*/\nSQLITE_PRIVATE Expr *sqlite3ExprDup(sqlite3 *db, Expr *p, int flags){\n  return exprDup(db, p, flags, 0);\n}\nSQLITE_PRIVATE ExprList *sqlite3ExprListDup(sqlite3 *db, ExprList *p, int flags){\n  ExprList *pNew;\n  struct ExprList_item *pItem, *pOldItem;\n  int i;\n  if( p==0 ) return 0;\n  pNew = sqlite3DbMallocRaw(db, sizeof(*pNew) );\n  if( pNew==0 ) return 0;\n  pNew->iECursor = 0;\n  pNew->nExpr = pNew->nAlloc = p->nExpr;\n  pNew->a = pItem = sqlite3DbMallocRaw(db,  p->nExpr*sizeof(p->a[0]) );\n  if( pItem==0 ){\n    sqlite3DbFree(db, pNew);\n    return 0;\n  } \n  pOldItem = p->a;\n  for(i=0; i<p->nExpr; i++, pItem++, pOldItem++){\n    Expr *pOldExpr = pOldItem->pExpr;\n    pItem->pExpr = sqlite3ExprDup(db, pOldExpr, flags);\n    pItem->zName = sqlite3DbStrDup(db, pOldItem->zName);\n    pItem->zSpan = sqlite3DbStrDup(db, pOldItem->zSpan);\n    pItem->sortOrder = pOldItem->sortOrder;\n    pItem->done = 0;\n    pItem->iCol = pOldItem->iCol;\n    pItem->iAlias = pOldItem->iAlias;\n  }\n  return pNew;\n}\n\n/*\n** If cursors, triggers, views and subqueries are all omitted from\n** the build, then none of the following routines, except for \n** sqlite3SelectDup(), can be called. sqlite3SelectDup() is sometimes\n** called with a NULL argument.\n*/\n#if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_TRIGGER) \\\n || !defined(SQLITE_OMIT_SUBQUERY)\nSQLITE_PRIVATE SrcList *sqlite3SrcListDup(sqlite3 *db, SrcList *p, int flags){\n  SrcList *pNew;\n  int i;\n  int nByte;\n  if( p==0 ) return 0;\n  nByte = sizeof(*p) + (p->nSrc>0 ? sizeof(p->a[0]) * (p->nSrc-1) : 0);\n  pNew = sqlite3DbMallocRaw(db, nByte );\n  if( pNew==0 ) return 0;\n  pNew->nSrc = pNew->nAlloc = p->nSrc;\n  for(i=0; i<p->nSrc; i++){\n    struct SrcList_item *pNewItem = &pNew->a[i];\n    struct SrcList_item *pOldItem = &p->a[i];\n    Table *pTab;\n    pNewItem->zDatabase = sqlite3DbStrDup(db, pOldItem->zDatabase);\n    pNewItem->zName = sqlite3DbStrDup(db, pOldItem->zName);\n    pNewItem->zAlias = sqlite3DbStrDup(db, pOldItem->zAlias);\n    pNewItem->jointype = pOldItem->jointype;\n    pNewItem->iCursor = pOldItem->iCursor;\n    pNewItem->isPopulated = pOldItem->isPopulated;\n    pNewItem->zIndex = sqlite3DbStrDup(db, pOldItem->zIndex);\n    pNewItem->notIndexed = pOldItem->notIndexed;\n    pNewItem->pIndex = pOldItem->pIndex;\n    pTab = pNewItem->pTab = pOldItem->pTab;\n    if( pTab ){\n      pTab->nRef++;\n    }\n    pNewItem->pSelect = sqlite3SelectDup(db, pOldItem->pSelect, flags);\n    pNewItem->pOn = sqlite3ExprDup(db, pOldItem->pOn, flags);\n    pNewItem->pUsing = sqlite3IdListDup(db, pOldItem->pUsing);\n    pNewItem->colUsed = pOldItem->colUsed;\n  }\n  return pNew;\n}\nSQLITE_PRIVATE IdList *sqlite3IdListDup(sqlite3 *db, IdList *p){\n  IdList *pNew;\n  int i;\n  if( p==0 ) return 0;\n  pNew = sqlite3DbMallocRaw(db, sizeof(*pNew) );\n  if( pNew==0 ) return 0;\n  pNew->nId = pNew->nAlloc = p->nId;\n  pNew->a = sqlite3DbMallocRaw(db, p->nId*sizeof(p->a[0]) );\n  if( pNew->a==0 ){\n    sqlite3DbFree(db, pNew);\n    return 0;\n  }\n  for(i=0; i<p->nId; i++){\n    struct IdList_item *pNewItem = &pNew->a[i];\n    struct IdList_item *pOldItem = &p->a[i];\n    pNewItem->zName = sqlite3DbStrDup(db, pOldItem->zName);\n    pNewItem->idx = pOldItem->idx;\n  }\n  return pNew;\n}\nSQLITE_PRIVATE Select *sqlite3SelectDup(sqlite3 *db, Select *p, int flags){\n  Select *pNew;\n  if( p==0 ) return 0;\n  pNew = sqlite3DbMallocRaw(db, sizeof(*p) );\n  if( pNew==0 ) return 0;\n  pNew->pEList = sqlite3ExprListDup(db, p->pEList, flags);\n  pNew->pSrc = sqlite3SrcListDup(db, p->pSrc, flags);\n  pNew->pWhere = sqlite3ExprDup(db, p->pWhere, flags);\n  pNew->pGroupBy = sqlite3ExprListDup(db, p->pGroupBy, flags);\n  pNew->pHaving = sqlite3ExprDup(db, p->pHaving, flags);\n  pNew->pOrderBy = sqlite3ExprListDup(db, p->pOrderBy, flags);\n  pNew->op = p->op;\n  pNew->pPrior = sqlite3SelectDup(db, p->pPrior, flags);\n  pNew->pLimit = sqlite3ExprDup(db, p->pLimit, flags);\n  pNew->pOffset = sqlite3ExprDup(db, p->pOffset, flags);\n  pNew->iLimit = 0;\n  pNew->iOffset = 0;\n  pNew->selFlags = p->selFlags & ~SF_UsesEphemeral;\n  pNew->pRightmost = 0;\n  pNew->addrOpenEphm[0] = -1;\n  pNew->addrOpenEphm[1] = -1;\n  pNew->addrOpenEphm[2] = -1;\n  return pNew;\n}\n#else\nSQLITE_PRIVATE Select *sqlite3SelectDup(sqlite3 *db, Select *p, int flags){\n  assert( p==0 );\n  return 0;\n}\n#endif\n\n\n/*\n** Add a new element to the end of an expression list.  If pList is\n** initially NULL, then create a new expression list.\n**\n** If a memory allocation error occurs, the entire list is freed and\n** NULL is returned.  If non-NULL is returned, then it is guaranteed\n** that the new entry was successfully appended.\n*/\nSQLITE_PRIVATE ExprList *sqlite3ExprListAppend(\n  Parse *pParse,          /* Parsing context */\n  ExprList *pList,        /* List to which to append. Might be NULL */\n  Expr *pExpr             /* Expression to be appended. Might be NULL */\n){\n  sqlite3 *db = pParse->db;\n  if( pList==0 ){\n    pList = sqlite3DbMallocZero(db, sizeof(ExprList) );\n    if( pList==0 ){\n      goto no_mem;\n    }\n    assert( pList->nAlloc==0 );\n  }\n  if( pList->nAlloc<=pList->nExpr ){\n    struct ExprList_item *a;\n    int n = pList->nAlloc*2 + 4;\n    a = sqlite3DbRealloc(db, pList->a, n*sizeof(pList->a[0]));\n    if( a==0 ){\n      goto no_mem;\n    }\n    pList->a = a;\n    pList->nAlloc = sqlite3DbMallocSize(db, a)/sizeof(a[0]);\n  }\n  assert( pList->a!=0 );\n  if( 1 ){\n    struct ExprList_item *pItem = &pList->a[pList->nExpr++];\n    memset(pItem, 0, sizeof(*pItem));\n    pItem->pExpr = pExpr;\n  }\n  return pList;\n\nno_mem:     \n  /* Avoid leaking memory if malloc has failed. */\n  sqlite3ExprDelete(db, pExpr);\n  sqlite3ExprListDelete(db, pList);\n  return 0;\n}\n\n/*\n** Set the ExprList.a[].zName element of the most recently added item\n** on the expression list.\n**\n** pList might be NULL following an OOM error.  But pName should never be\n** NULL.  If a memory allocation fails, the pParse->db->mallocFailed flag\n** is set.\n*/\nSQLITE_PRIVATE void sqlite3ExprListSetName(\n  Parse *pParse,          /* Parsing context */\n  ExprList *pList,        /* List to which to add the span. */\n  Token *pName,           /* Name to be added */\n  int dequote             /* True to cause the name to be dequoted */\n){\n  assert( pList!=0 || pParse->db->mallocFailed!=0 );\n  if( pList ){\n    struct ExprList_item *pItem;\n    assert( pList->nExpr>0 );\n    pItem = &pList->a[pList->nExpr-1];\n    assert( pItem->zName==0 );\n    pItem->zName = sqlite3DbStrNDup(pParse->db, pName->z, pName->n);\n    if( dequote && pItem->zName ) sqlite3Dequote(pItem->zName);\n  }\n}\n\n/*\n** Set the ExprList.a[].zSpan element of the most recently added item\n** on the expression list.\n**\n** pList might be NULL following an OOM error.  But pSpan should never be\n** NULL.  If a memory allocation fails, the pParse->db->mallocFailed flag\n** is set.\n*/\nSQLITE_PRIVATE void sqlite3ExprListSetSpan(\n  Parse *pParse,          /* Parsing context */\n  ExprList *pList,        /* List to which to add the span. */\n  ExprSpan *pSpan         /* The span to be added */\n){\n  sqlite3 *db = pParse->db;\n  assert( pList!=0 || db->mallocFailed!=0 );\n  if( pList ){\n    struct ExprList_item *pItem = &pList->a[pList->nExpr-1];\n    assert( pList->nExpr>0 );\n    assert( db->mallocFailed || pItem->pExpr==pSpan->pExpr );\n    sqlite3DbFree(db, pItem->zSpan);\n    pItem->zSpan = sqlite3DbStrNDup(db, (char*)pSpan->zStart,\n                                    (int)(pSpan->zEnd - pSpan->zStart));\n  }\n}\n\n/*\n** If the expression list pEList contains more than iLimit elements,\n** leave an error message in pParse.\n*/\nSQLITE_PRIVATE void sqlite3ExprListCheckLength(\n  Parse *pParse,\n  ExprList *pEList,\n  const char *zObject\n){\n  int mx = pParse->db->aLimit[SQLITE_LIMIT_COLUMN];\n  testcase( pEList && pEList->nExpr==mx );\n  testcase( pEList && pEList->nExpr==mx+1 );\n  if( pEList && pEList->nExpr>mx ){\n    sqlite3ErrorMsg(pParse, \"too many columns in %s\", zObject);\n  }\n}\n\n/*\n** Delete an entire expression list.\n*/\nSQLITE_PRIVATE void sqlite3ExprListDelete(sqlite3 *db, ExprList *pList){\n  int i;\n  struct ExprList_item *pItem;\n  if( pList==0 ) return;\n  assert( pList->a!=0 || (pList->nExpr==0 && pList->nAlloc==0) );\n  assert( pList->nExpr<=pList->nAlloc );\n  for(pItem=pList->a, i=0; i<pList->nExpr; i++, pItem++){\n    sqlite3ExprDelete(db, pItem->pExpr);\n    sqlite3DbFree(db, pItem->zName);\n    sqlite3DbFree(db, pItem->zSpan);\n  }\n  sqlite3DbFree(db, pList->a);\n  sqlite3DbFree(db, pList);\n}\n\n/*\n** These routines are Walker callbacks.  Walker.u.pi is a pointer\n** to an integer.  These routines are checking an expression to see\n** if it is a constant.  Set *Walker.u.pi to 0 if the expression is\n** not constant.\n**\n** These callback routines are used to implement the following:\n**\n**     sqlite3ExprIsConstant()\n**     sqlite3ExprIsConstantNotJoin()\n**     sqlite3ExprIsConstantOrFunction()\n**\n*/\nstatic int exprNodeIsConstant(Walker *pWalker, Expr *pExpr){\n\n  /* If pWalker->u.i is 3 then any term of the expression that comes from\n  ** the ON or USING clauses of a join disqualifies the expression\n  ** from being considered constant. */\n  if( pWalker->u.i==3 && ExprHasAnyProperty(pExpr, EP_FromJoin) ){\n    pWalker->u.i = 0;\n    return WRC_Abort;\n  }\n\n  switch( pExpr->op ){\n    /* Consider functions to be constant if all their arguments are constant\n    ** and pWalker->u.i==2 */\n    case TK_FUNCTION:\n      if( pWalker->u.i==2 ) return 0;\n      /* Fall through */\n    case TK_ID:\n    case TK_COLUMN:\n    case TK_AGG_FUNCTION:\n    case TK_AGG_COLUMN:\n      testcase( pExpr->op==TK_ID );\n      testcase( pExpr->op==TK_COLUMN );\n      testcase( pExpr->op==TK_AGG_FUNCTION );\n      testcase( pExpr->op==TK_AGG_COLUMN );\n      pWalker->u.i = 0;\n      return WRC_Abort;\n    default:\n      testcase( pExpr->op==TK_SELECT ); /* selectNodeIsConstant will disallow */\n      testcase( pExpr->op==TK_EXISTS ); /* selectNodeIsConstant will disallow */\n      return WRC_Continue;\n  }\n}\nstatic int selectNodeIsConstant(Walker *pWalker, Select *NotUsed){\n  UNUSED_PARAMETER(NotUsed);\n  pWalker->u.i = 0;\n  return WRC_Abort;\n}\nstatic int exprIsConst(Expr *p, int initFlag){\n  Walker w;\n  w.u.i = initFlag;\n  w.xExprCallback = exprNodeIsConstant;\n  w.xSelectCallback = selectNodeIsConstant;\n  sqlite3WalkExpr(&w, p);\n  return w.u.i;\n}\n\n/*\n** Walk an expression tree.  Return 1 if the expression is constant\n** and 0 if it involves variables or function calls.\n**\n** For the purposes of this function, a double-quoted string (ex: \"abc\")\n** is considered a variable but a single-quoted string (ex: 'abc') is\n** a constant.\n*/\nSQLITE_PRIVATE int sqlite3ExprIsConstant(Expr *p){\n  return exprIsConst(p, 1);\n}\n\n/*\n** Walk an expression tree.  Return 1 if the expression is constant\n** that does no originate from the ON or USING clauses of a join.\n** Return 0 if it involves variables or function calls or terms from\n** an ON or USING clause.\n*/\nSQLITE_PRIVATE int sqlite3ExprIsConstantNotJoin(Expr *p){\n  return exprIsConst(p, 3);\n}\n\n/*\n** Walk an expression tree.  Return 1 if the expression is constant\n** or a function call with constant arguments.  Return and 0 if there\n** are any variables.\n**\n** For the purposes of this function, a double-quoted string (ex: \"abc\")\n** is considered a variable but a single-quoted string (ex: 'abc') is\n** a constant.\n*/\nSQLITE_PRIVATE int sqlite3ExprIsConstantOrFunction(Expr *p){\n  return exprIsConst(p, 2);\n}\n\n/*\n** If the expression p codes a constant integer that is small enough\n** to fit in a 32-bit integer, return 1 and put the value of the integer\n** in *pValue.  If the expression is not an integer or if it is too big\n** to fit in a signed 32-bit integer, return 0 and leave *pValue unchanged.\n*/\nSQLITE_PRIVATE int sqlite3ExprIsInteger(Expr *p, int *pValue){\n  int rc = 0;\n\n  /* If an expression is an integer literal that fits in a signed 32-bit\n  ** integer, then the EP_IntValue flag will have already been set */\n  assert( p->op!=TK_INTEGER || (p->flags & EP_IntValue)!=0\n           || sqlite3GetInt32(p->u.zToken, &rc)==0 );\n\n  if( p->flags & EP_IntValue ){\n    *pValue = p->u.iValue;\n    return 1;\n  }\n  switch( p->op ){\n    case TK_UPLUS: {\n      rc = sqlite3ExprIsInteger(p->pLeft, pValue);\n      break;\n    }\n    case TK_UMINUS: {\n      int v;\n      if( sqlite3ExprIsInteger(p->pLeft, &v) ){\n        *pValue = -v;\n        rc = 1;\n      }\n      break;\n    }\n    default: break;\n  }\n  return rc;\n}\n\n/*\n** Return FALSE if there is no chance that the expression can be NULL.\n**\n** If the expression might be NULL or if the expression is too complex\n** to tell return TRUE.  \n**\n** This routine is used as an optimization, to skip OP_IsNull opcodes\n** when we know that a value cannot be NULL.  Hence, a false positive\n** (returning TRUE when in fact the expression can never be NULL) might\n** be a small performance hit but is otherwise harmless.  On the other\n** hand, a false negative (returning FALSE when the result could be NULL)\n** will likely result in an incorrect answer.  So when in doubt, return\n** TRUE.\n*/\nSQLITE_PRIVATE int sqlite3ExprCanBeNull(const Expr *p){\n  u8 op;\n  while( p->op==TK_UPLUS || p->op==TK_UMINUS ){ p = p->pLeft; }\n  op = p->op;\n  if( op==TK_REGISTER ) op = p->op2;\n  switch( op ){\n    case TK_INTEGER:\n    case TK_STRING:\n    case TK_FLOAT:\n    case TK_BLOB:\n      return 0;\n    default:\n      return 1;\n  }\n}\n\n/*\n** Generate an OP_IsNull instruction that tests register iReg and jumps\n** to location iDest if the value in iReg is NULL.  The value in iReg \n** was computed by pExpr.  If we can look at pExpr at compile-time and\n** determine that it can never generate a NULL, then the OP_IsNull operation\n** can be omitted.\n*/\nSQLITE_PRIVATE void sqlite3ExprCodeIsNullJump(\n  Vdbe *v,            /* The VDBE under construction */\n  const Expr *pExpr,  /* Only generate OP_IsNull if this expr can be NULL */\n  int iReg,           /* Test the value in this register for NULL */\n  int iDest           /* Jump here if the value is null */\n){\n  if( sqlite3ExprCanBeNull(pExpr) ){\n    sqlite3VdbeAddOp2(v, OP_IsNull, iReg, iDest);\n  }\n}\n\n/*\n** Return TRUE if the given expression is a constant which would be\n** unchanged by OP_Affinity with the affinity given in the second\n** argument.\n**\n** This routine is used to determine if the OP_Affinity operation\n** can be omitted.  When in doubt return FALSE.  A false negative\n** is harmless.  A false positive, however, can result in the wrong\n** answer.\n*/\nSQLITE_PRIVATE int sqlite3ExprNeedsNoAffinityChange(const Expr *p, char aff){\n  u8 op;\n  if( aff==SQLITE_AFF_NONE ) return 1;\n  while( p->op==TK_UPLUS || p->op==TK_UMINUS ){ p = p->pLeft; }\n  op = p->op;\n  if( op==TK_REGISTER ) op = p->op2;\n  switch( op ){\n    case TK_INTEGER: {\n      return aff==SQLITE_AFF_INTEGER || aff==SQLITE_AFF_NUMERIC;\n    }\n    case TK_FLOAT: {\n      return aff==SQLITE_AFF_REAL || aff==SQLITE_AFF_NUMERIC;\n    }\n    case TK_STRING: {\n      return aff==SQLITE_AFF_TEXT;\n    }\n    case TK_BLOB: {\n      return 1;\n    }\n    case TK_COLUMN: {\n      assert( p->iTable>=0 );  /* p cannot be part of a CHECK constraint */\n      return p->iColumn<0\n          && (aff==SQLITE_AFF_INTEGER || aff==SQLITE_AFF_NUMERIC);\n    }\n    default: {\n      return 0;\n    }\n  }\n}\n\n/*\n** Return TRUE if the given string is a row-id column name.\n*/\nSQLITE_PRIVATE int sqlite3IsRowid(const char *z){\n  if( sqlite3StrICmp(z, \"_ROWID_\")==0 ) return 1;\n  if( sqlite3StrICmp(z, \"ROWID\")==0 ) return 1;\n  if( sqlite3StrICmp(z, \"OID\")==0 ) return 1;\n  return 0;\n}\n\n/*\n** Return true if we are able to the IN operator optimization on a\n** query of the form\n**\n**       x IN (SELECT ...)\n**\n** Where the SELECT... clause is as specified by the parameter to this\n** routine.\n**\n** The Select object passed in has already been preprocessed and no\n** errors have been found.\n*/\n#ifndef SQLITE_OMIT_SUBQUERY\nstatic int isCandidateForInOpt(Select *p){\n  SrcList *pSrc;\n  ExprList *pEList;\n  Table *pTab;\n  if( p==0 ) return 0;                   /* right-hand side of IN is SELECT */\n  if( p->pPrior ) return 0;              /* Not a compound SELECT */\n  if( p->selFlags & (SF_Distinct|SF_Aggregate) ){\n    testcase( (p->selFlags & (SF_Distinct|SF_Aggregate))==SF_Distinct );\n    testcase( (p->selFlags & (SF_Distinct|SF_Aggregate))==SF_Aggregate );\n    return 0; /* No DISTINCT keyword and no aggregate functions */\n  }\n  assert( p->pGroupBy==0 );              /* Has no GROUP BY clause */\n  if( p->pLimit ) return 0;              /* Has no LIMIT clause */\n  assert( p->pOffset==0 );               /* No LIMIT means no OFFSET */\n  if( p->pWhere ) return 0;              /* Has no WHERE clause */\n  pSrc = p->pSrc;\n  assert( pSrc!=0 );\n  if( pSrc->nSrc!=1 ) return 0;          /* Single term in FROM clause */\n  if( pSrc->a[0].pSelect ) return 0;     /* FROM is not a subquery or view */\n  pTab = pSrc->a[0].pTab;\n  if( NEVER(pTab==0) ) return 0;\n  assert( pTab->pSelect==0 );            /* FROM clause is not a view */\n  if( IsVirtual(pTab) ) return 0;        /* FROM clause not a virtual table */\n  pEList = p->pEList;\n  if( pEList->nExpr!=1 ) return 0;       /* One column in the result set */\n  if( pEList->a[0].pExpr->op!=TK_COLUMN ) return 0; /* Result is a column */\n  return 1;\n}\n#endif /* SQLITE_OMIT_SUBQUERY */\n\n/*\n** This function is used by the implementation of the IN (...) operator.\n** It's job is to find or create a b-tree structure that may be used\n** either to test for membership of the (...) set or to iterate through\n** its members, skipping duplicates.\n**\n** The index of the cursor opened on the b-tree (database table, database index \n** or ephermal table) is stored in pX->iTable before this function returns.\n** The returned value of this function indicates the b-tree type, as follows:\n**\n**   IN_INDEX_ROWID - The cursor was opened on a database table.\n**   IN_INDEX_INDEX - The cursor was opened on a database index.\n**   IN_INDEX_EPH -   The cursor was opened on a specially created and\n**                    populated epheremal table.\n**\n** An existing b-tree may only be used if the SELECT is of the simple\n** form:\n**\n**     SELECT <column> FROM <table>\n**\n** If the prNotFound parameter is 0, then the b-tree will be used to iterate\n** through the set members, skipping any duplicates. In this case an\n** epheremal table must be used unless the selected <column> is guaranteed\n** to be unique - either because it is an INTEGER PRIMARY KEY or it\n** has a UNIQUE constraint or UNIQUE index.\n**\n** If the prNotFound parameter is not 0, then the b-tree will be used \n** for fast set membership tests. In this case an epheremal table must \n** be used unless <column> is an INTEGER PRIMARY KEY or an index can \n** be found with <column> as its left-most column.\n**\n** When the b-tree is being used for membership tests, the calling function\n** needs to know whether or not the structure contains an SQL NULL \n** value in order to correctly evaluate expressions like \"X IN (Y, Z)\".\n** If there is any chance that the (...) might contain a NULL value at\n** runtime, then a register is allocated and the register number written\n** to *prNotFound. If there is no chance that the (...) contains a\n** NULL value, then *prNotFound is left unchanged.\n**\n** If a register is allocated and its location stored in *prNotFound, then\n** its initial value is NULL.  If the (...) does not remain constant\n** for the duration of the query (i.e. the SELECT within the (...)\n** is a correlated subquery) then the value of the allocated register is\n** reset to NULL each time the subquery is rerun. This allows the\n** caller to use vdbe code equivalent to the following:\n**\n**   if( register==NULL ){\n**     has_null = <test if data structure contains null>\n**     register = 1\n**   }\n**\n** in order to avoid running the <test if data structure contains null>\n** test more often than is necessary.\n*/\n#ifndef SQLITE_OMIT_SUBQUERY\nSQLITE_PRIVATE int sqlite3FindInIndex(Parse *pParse, Expr *pX, int *prNotFound){\n  Select *p;                            /* SELECT to the right of IN operator */\n  int eType = 0;                        /* Type of RHS table. IN_INDEX_* */\n  int iTab = pParse->nTab++;            /* Cursor of the RHS table */\n  int mustBeUnique = (prNotFound==0);   /* True if RHS must be unique */\n\n  assert( pX->op==TK_IN );\n\n  /* Check to see if an existing table or index can be used to\n  ** satisfy the query.  This is preferable to generating a new \n  ** ephemeral table.\n  */\n  p = (ExprHasProperty(pX, EP_xIsSelect) ? pX->x.pSelect : 0);\n  if( ALWAYS(pParse->nErr==0) && isCandidateForInOpt(p) ){\n    sqlite3 *db = pParse->db;              /* Database connection */\n    Expr *pExpr = p->pEList->a[0].pExpr;   /* Expression <column> */\n    int iCol = pExpr->iColumn;             /* Index of column <column> */\n    Vdbe *v = sqlite3GetVdbe(pParse);      /* Virtual machine being coded */\n    Table *pTab = p->pSrc->a[0].pTab;      /* Table <table>. */\n    int iDb;                               /* Database idx for pTab */\n   \n    /* Code an OP_VerifyCookie and OP_TableLock for <table>. */\n    iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n    sqlite3CodeVerifySchema(pParse, iDb);\n    sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);\n\n    /* This function is only called from two places. In both cases the vdbe\n    ** has already been allocated. So assume sqlite3GetVdbe() is always\n    ** successful here.\n    */\n    assert(v);\n    if( iCol<0 ){\n      int iMem = ++pParse->nMem;\n      int iAddr;\n\n      iAddr = sqlite3VdbeAddOp1(v, OP_If, iMem);\n      sqlite3VdbeAddOp2(v, OP_Integer, 1, iMem);\n\n      sqlite3OpenTable(pParse, iTab, iDb, pTab, OP_OpenRead);\n      eType = IN_INDEX_ROWID;\n\n      sqlite3VdbeJumpHere(v, iAddr);\n    }else{\n      Index *pIdx;                         /* Iterator variable */\n\n      /* The collation sequence used by the comparison. If an index is to\n      ** be used in place of a temp-table, it must be ordered according\n      ** to this collation sequence.  */\n      CollSeq *pReq = sqlite3BinaryCompareCollSeq(pParse, pX->pLeft, pExpr);\n\n      /* Check that the affinity that will be used to perform the \n      ** comparison is the same as the affinity of the column. If\n      ** it is not, it is not possible to use any index.\n      */\n      char aff = comparisonAffinity(pX);\n      int affinity_ok = (pTab->aCol[iCol].affinity==aff||aff==SQLITE_AFF_NONE);\n\n      for(pIdx=pTab->pIndex; pIdx && eType==0 && affinity_ok; pIdx=pIdx->pNext){\n        if( (pIdx->aiColumn[0]==iCol)\n         && sqlite3FindCollSeq(db, ENC(db), pIdx->azColl[0], 0)==pReq\n         && (!mustBeUnique || (pIdx->nColumn==1 && pIdx->onError!=OE_None))\n        ){\n          int iMem = ++pParse->nMem;\n          int iAddr;\n          char *pKey;\n  \n          pKey = (char *)sqlite3IndexKeyinfo(pParse, pIdx);\n          iAddr = sqlite3VdbeAddOp1(v, OP_If, iMem);\n          sqlite3VdbeAddOp2(v, OP_Integer, 1, iMem);\n  \n          sqlite3VdbeAddOp4(v, OP_OpenRead, iTab, pIdx->tnum, iDb,\n                               pKey,P4_KEYINFO_HANDOFF);\n          VdbeComment((v, \"%s\", pIdx->zName));\n          eType = IN_INDEX_INDEX;\n\n          sqlite3VdbeJumpHere(v, iAddr);\n          if( prNotFound && !pTab->aCol[iCol].notNull ){\n            *prNotFound = ++pParse->nMem;\n          }\n        }\n      }\n    }\n  }\n\n  if( eType==0 ){\n    /* Could not found an existing table or index to use as the RHS b-tree.\n    ** We will have to generate an ephemeral table to do the job.\n    */\n    double savedNQueryLoop = pParse->nQueryLoop;\n    int rMayHaveNull = 0;\n    eType = IN_INDEX_EPH;\n    if( prNotFound ){\n      *prNotFound = rMayHaveNull = ++pParse->nMem;\n    }else{\n      testcase( pParse->nQueryLoop>(double)1 );\n      pParse->nQueryLoop = (double)1;\n      if( pX->pLeft->iColumn<0 && !ExprHasAnyProperty(pX, EP_xIsSelect) ){\n        eType = IN_INDEX_ROWID;\n      }\n    }\n    sqlite3CodeSubselect(pParse, pX, rMayHaveNull, eType==IN_INDEX_ROWID);\n    pParse->nQueryLoop = savedNQueryLoop;\n  }else{\n    pX->iTable = iTab;\n  }\n  return eType;\n}\n#endif\n\n/*\n** Generate code for scalar subqueries used as a subquery expression, EXISTS,\n** or IN operators.  Examples:\n**\n**     (SELECT a FROM b)          -- subquery\n**     EXISTS (SELECT a FROM b)   -- EXISTS subquery\n**     x IN (4,5,11)              -- IN operator with list on right-hand side\n**     x IN (SELECT a FROM b)     -- IN operator with subquery on the right\n**\n** The pExpr parameter describes the expression that contains the IN\n** operator or subquery.\n**\n** If parameter isRowid is non-zero, then expression pExpr is guaranteed\n** to be of the form \"<rowid> IN (?, ?, ?)\", where <rowid> is a reference\n** to some integer key column of a table B-Tree. In this case, use an\n** intkey B-Tree to store the set of IN(...) values instead of the usual\n** (slower) variable length keys B-Tree.\n**\n** If rMayHaveNull is non-zero, that means that the operation is an IN\n** (not a SELECT or EXISTS) and that the RHS might contains NULLs.\n** Furthermore, the IN is in a WHERE clause and that we really want\n** to iterate over the RHS of the IN operator in order to quickly locate\n** all corresponding LHS elements.  All this routine does is initialize\n** the register given by rMayHaveNull to NULL.  Calling routines will take\n** care of changing this register value to non-NULL if the RHS is NULL-free.\n**\n** If rMayHaveNull is zero, that means that the subquery is being used\n** for membership testing only.  There is no need to initialize any\n** registers to indicate the presense or absence of NULLs on the RHS.\n**\n** For a SELECT or EXISTS operator, return the register that holds the\n** result.  For IN operators or if an error occurs, the return value is 0.\n*/\n#ifndef SQLITE_OMIT_SUBQUERY\nSQLITE_PRIVATE int sqlite3CodeSubselect(\n  Parse *pParse,          /* Parsing context */\n  Expr *pExpr,            /* The IN, SELECT, or EXISTS operator */\n  int rMayHaveNull,       /* Register that records whether NULLs exist in RHS */\n  int isRowid             /* If true, LHS of IN operator is a rowid */\n){\n  int testAddr = 0;                       /* One-time test address */\n  int rReg = 0;                           /* Register storing resulting */\n  Vdbe *v = sqlite3GetVdbe(pParse);\n  if( NEVER(v==0) ) return 0;\n  sqlite3ExprCachePush(pParse);\n\n  /* This code must be run in its entirety every time it is encountered\n  ** if any of the following is true:\n  **\n  **    *  The right-hand side is a correlated subquery\n  **    *  The right-hand side is an expression list containing variables\n  **    *  We are inside a trigger\n  **\n  ** If all of the above are false, then we can run this code just once\n  ** save the results, and reuse the same result on subsequent invocations.\n  */\n  if( !ExprHasAnyProperty(pExpr, EP_VarSelect) && !pParse->pTriggerTab ){\n    int mem = ++pParse->nMem;\n    sqlite3VdbeAddOp1(v, OP_If, mem);\n    testAddr = sqlite3VdbeAddOp2(v, OP_Integer, 1, mem);\n    assert( testAddr>0 || pParse->db->mallocFailed );\n  }\n\n#ifndef SQLITE_OMIT_EXPLAIN\n  if( pParse->explain==2 ){\n    char *zMsg = sqlite3MPrintf(\n        pParse->db, \"EXECUTE %s%s SUBQUERY %d\", testAddr?\"\":\"CORRELATED \",\n        pExpr->op==TK_IN?\"LIST\":\"SCALAR\", pParse->iNextSelectId\n    );\n    sqlite3VdbeAddOp4(v, OP_Explain, pParse->iSelectId, 0, 0, zMsg, P4_DYNAMIC);\n  }\n#endif\n\n  switch( pExpr->op ){\n    case TK_IN: {\n      char affinity;              /* Affinity of the LHS of the IN */\n      KeyInfo keyInfo;            /* Keyinfo for the generated table */\n      int addr;                   /* Address of OP_OpenEphemeral instruction */\n      Expr *pLeft = pExpr->pLeft; /* the LHS of the IN operator */\n\n      if( rMayHaveNull ){\n        sqlite3VdbeAddOp2(v, OP_Null, 0, rMayHaveNull);\n      }\n\n      affinity = sqlite3ExprAffinity(pLeft);\n\n      /* Whether this is an 'x IN(SELECT...)' or an 'x IN(<exprlist>)'\n      ** expression it is handled the same way.  An ephemeral table is \n      ** filled with single-field index keys representing the results\n      ** from the SELECT or the <exprlist>.\n      **\n      ** If the 'x' expression is a column value, or the SELECT...\n      ** statement returns a column value, then the affinity of that\n      ** column is used to build the index keys. If both 'x' and the\n      ** SELECT... statement are columns, then numeric affinity is used\n      ** if either column has NUMERIC or INTEGER affinity. If neither\n      ** 'x' nor the SELECT... statement are columns, then numeric affinity\n      ** is used.\n      */\n      pExpr->iTable = pParse->nTab++;\n      addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, pExpr->iTable, !isRowid);\n      if( rMayHaveNull==0 ) sqlite3VdbeChangeP5(v, BTREE_UNORDERED);\n      memset(&keyInfo, 0, sizeof(keyInfo));\n      keyInfo.nField = 1;\n\n      if( ExprHasProperty(pExpr, EP_xIsSelect) ){\n        /* Case 1:     expr IN (SELECT ...)\n        **\n        ** Generate code to write the results of the select into the temporary\n        ** table allocated and opened above.\n        */\n        SelectDest dest;\n        ExprList *pEList;\n\n        assert( !isRowid );\n        sqlite3SelectDestInit(&dest, SRT_Set, pExpr->iTable);\n        dest.affinity = (u8)affinity;\n        assert( (pExpr->iTable&0x0000FFFF)==pExpr->iTable );\n        pExpr->x.pSelect->iLimit = 0;\n        if( sqlite3Select(pParse, pExpr->x.pSelect, &dest) ){\n          return 0;\n        }\n        pEList = pExpr->x.pSelect->pEList;\n        if( ALWAYS(pEList!=0 && pEList->nExpr>0) ){ \n          keyInfo.aColl[0] = sqlite3BinaryCompareCollSeq(pParse, pExpr->pLeft,\n              pEList->a[0].pExpr);\n        }\n      }else if( ALWAYS(pExpr->x.pList!=0) ){\n        /* Case 2:     expr IN (exprlist)\n        **\n        ** For each expression, build an index key from the evaluation and\n        ** store it in the temporary table. If <expr> is a column, then use\n        ** that columns affinity when building index keys. If <expr> is not\n        ** a column, use numeric affinity.\n        */\n        int i;\n        ExprList *pList = pExpr->x.pList;\n        struct ExprList_item *pItem;\n        int r1, r2, r3;\n\n        if( !affinity ){\n          affinity = SQLITE_AFF_NONE;\n        }\n        keyInfo.aColl[0] = sqlite3ExprCollSeq(pParse, pExpr->pLeft);\n\n        /* Loop through each expression in <exprlist>. */\n        r1 = sqlite3GetTempReg(pParse);\n        r2 = sqlite3GetTempReg(pParse);\n        sqlite3VdbeAddOp2(v, OP_Null, 0, r2);\n        for(i=pList->nExpr, pItem=pList->a; i>0; i--, pItem++){\n          Expr *pE2 = pItem->pExpr;\n          int iValToIns;\n\n          /* If the expression is not constant then we will need to\n          ** disable the test that was generated above that makes sure\n          ** this code only executes once.  Because for a non-constant\n          ** expression we need to rerun this code each time.\n          */\n          if( testAddr && !sqlite3ExprIsConstant(pE2) ){\n            sqlite3VdbeChangeToNoop(v, testAddr-1, 2);\n            testAddr = 0;\n          }\n\n          /* Evaluate the expression and insert it into the temp table */\n          if( isRowid && sqlite3ExprIsInteger(pE2, &iValToIns) ){\n            sqlite3VdbeAddOp3(v, OP_InsertInt, pExpr->iTable, r2, iValToIns);\n          }else{\n            r3 = sqlite3ExprCodeTarget(pParse, pE2, r1);\n            if( isRowid ){\n              sqlite3VdbeAddOp2(v, OP_MustBeInt, r3,\n                                sqlite3VdbeCurrentAddr(v)+2);\n              sqlite3VdbeAddOp3(v, OP_Insert, pExpr->iTable, r2, r3);\n            }else{\n              sqlite3VdbeAddOp4(v, OP_MakeRecord, r3, 1, r2, &affinity, 1);\n              sqlite3ExprCacheAffinityChange(pParse, r3, 1);\n              sqlite3VdbeAddOp2(v, OP_IdxInsert, pExpr->iTable, r2);\n            }\n          }\n        }\n        sqlite3ReleaseTempReg(pParse, r1);\n        sqlite3ReleaseTempReg(pParse, r2);\n      }\n      if( !isRowid ){\n        sqlite3VdbeChangeP4(v, addr, (void *)&keyInfo, P4_KEYINFO);\n      }\n      break;\n    }\n\n    case TK_EXISTS:\n    case TK_SELECT:\n    default: {\n      /* If this has to be a scalar SELECT.  Generate code to put the\n      ** value of this select in a memory cell and record the number\n      ** of the memory cell in iColumn.  If this is an EXISTS, write\n      ** an integer 0 (not exists) or 1 (exists) into a memory cell\n      ** and record that memory cell in iColumn.\n      */\n      Select *pSel;                         /* SELECT statement to encode */\n      SelectDest dest;                      /* How to deal with SELECt result */\n\n      testcase( pExpr->op==TK_EXISTS );\n      testcase( pExpr->op==TK_SELECT );\n      assert( pExpr->op==TK_EXISTS || pExpr->op==TK_SELECT );\n\n      assert( ExprHasProperty(pExpr, EP_xIsSelect) );\n      pSel = pExpr->x.pSelect;\n      sqlite3SelectDestInit(&dest, 0, ++pParse->nMem);\n      if( pExpr->op==TK_SELECT ){\n        dest.eDest = SRT_Mem;\n        sqlite3VdbeAddOp2(v, OP_Null, 0, dest.iParm);\n        VdbeComment((v, \"Init subquery result\"));\n      }else{\n        dest.eDest = SRT_Exists;\n        sqlite3VdbeAddOp2(v, OP_Integer, 0, dest.iParm);\n        VdbeComment((v, \"Init EXISTS result\"));\n      }\n      sqlite3ExprDelete(pParse->db, pSel->pLimit);\n      pSel->pLimit = sqlite3PExpr(pParse, TK_INTEGER, 0, 0,\n                                  &sqlite3IntTokens[1]);\n      pSel->iLimit = 0;\n      if( sqlite3Select(pParse, pSel, &dest) ){\n        return 0;\n      }\n      rReg = dest.iParm;\n      ExprSetIrreducible(pExpr);\n      break;\n    }\n  }\n\n  if( testAddr ){\n    sqlite3VdbeJumpHere(v, testAddr-1);\n  }\n  sqlite3ExprCachePop(pParse, 1);\n\n  return rReg;\n}\n#endif /* SQLITE_OMIT_SUBQUERY */\n\n#ifndef SQLITE_OMIT_SUBQUERY\n/*\n** Generate code for an IN expression.\n**\n**      x IN (SELECT ...)\n**      x IN (value, value, ...)\n**\n** The left-hand side (LHS) is a scalar expression.  The right-hand side (RHS)\n** is an array of zero or more values.  The expression is true if the LHS is\n** contained within the RHS.  The value of the expression is unknown (NULL)\n** if the LHS is NULL or if the LHS is not contained within the RHS and the\n** RHS contains one or more NULL values.\n**\n** This routine generates code will jump to destIfFalse if the LHS is not \n** contained within the RHS.  If due to NULLs we cannot determine if the LHS\n** is contained in the RHS then jump to destIfNull.  If the LHS is contained\n** within the RHS then fall through.\n*/\nstatic void sqlite3ExprCodeIN(\n  Parse *pParse,        /* Parsing and code generating context */\n  Expr *pExpr,          /* The IN expression */\n  int destIfFalse,      /* Jump here if LHS is not contained in the RHS */\n  int destIfNull        /* Jump here if the results are unknown due to NULLs */\n){\n  int rRhsHasNull = 0;  /* Register that is true if RHS contains NULL values */\n  char affinity;        /* Comparison affinity to use */\n  int eType;            /* Type of the RHS */\n  int r1;               /* Temporary use register */\n  Vdbe *v;              /* Statement under construction */\n\n  /* Compute the RHS.   After this step, the table with cursor\n  ** pExpr->iTable will contains the values that make up the RHS.\n  */\n  v = pParse->pVdbe;\n  assert( v!=0 );       /* OOM detected prior to this routine */\n  VdbeNoopComment((v, \"begin IN expr\"));\n  eType = sqlite3FindInIndex(pParse, pExpr, &rRhsHasNull);\n\n  /* Figure out the affinity to use to create a key from the results\n  ** of the expression. affinityStr stores a static string suitable for\n  ** P4 of OP_MakeRecord.\n  */\n  affinity = comparisonAffinity(pExpr);\n\n  /* Code the LHS, the <expr> from \"<expr> IN (...)\".\n  */\n  sqlite3ExprCachePush(pParse);\n  r1 = sqlite3GetTempReg(pParse);\n  sqlite3ExprCode(pParse, pExpr->pLeft, r1);\n\n  /* If the LHS is NULL, then the result is either false or NULL depending\n  ** on whether the RHS is empty or not, respectively.\n  */\n  if( destIfNull==destIfFalse ){\n    /* Shortcut for the common case where the false and NULL outcomes are\n    ** the same. */\n    sqlite3VdbeAddOp2(v, OP_IsNull, r1, destIfNull);\n  }else{\n    int addr1 = sqlite3VdbeAddOp1(v, OP_NotNull, r1);\n    sqlite3VdbeAddOp2(v, OP_Rewind, pExpr->iTable, destIfFalse);\n    sqlite3VdbeAddOp2(v, OP_Goto, 0, destIfNull);\n    sqlite3VdbeJumpHere(v, addr1);\n  }\n\n  if( eType==IN_INDEX_ROWID ){\n    /* In this case, the RHS is the ROWID of table b-tree\n    */\n    sqlite3VdbeAddOp2(v, OP_MustBeInt, r1, destIfFalse);\n    sqlite3VdbeAddOp3(v, OP_NotExists, pExpr->iTable, destIfFalse, r1);\n  }else{\n    /* In this case, the RHS is an index b-tree.\n    */\n    sqlite3VdbeAddOp4(v, OP_Affinity, r1, 1, 0, &affinity, 1);\n\n    /* If the set membership test fails, then the result of the \n    ** \"x IN (...)\" expression must be either 0 or NULL. If the set\n    ** contains no NULL values, then the result is 0. If the set \n    ** contains one or more NULL values, then the result of the\n    ** expression is also NULL.\n    */\n    if( rRhsHasNull==0 || destIfFalse==destIfNull ){\n      /* This branch runs if it is known at compile time that the RHS\n      ** cannot contain NULL values. This happens as the result\n      ** of a \"NOT NULL\" constraint in the database schema.\n      **\n      ** Also run this branch if NULL is equivalent to FALSE\n      ** for this particular IN operator.\n      */\n      sqlite3VdbeAddOp4Int(v, OP_NotFound, pExpr->iTable, destIfFalse, r1, 1);\n\n    }else{\n      /* In this branch, the RHS of the IN might contain a NULL and\n      ** the presence of a NULL on the RHS makes a difference in the\n      ** outcome.\n      */\n      int j1, j2, j3;\n\n      /* First check to see if the LHS is contained in the RHS.  If so,\n      ** then the presence of NULLs in the RHS does not matter, so jump\n      ** over all of the code that follows.\n      */\n      j1 = sqlite3VdbeAddOp4Int(v, OP_Found, pExpr->iTable, 0, r1, 1);\n\n      /* Here we begin generating code that runs if the LHS is not\n      ** contained within the RHS.  Generate additional code that\n      ** tests the RHS for NULLs.  If the RHS contains a NULL then\n      ** jump to destIfNull.  If there are no NULLs in the RHS then\n      ** jump to destIfFalse.\n      */\n      j2 = sqlite3VdbeAddOp1(v, OP_NotNull, rRhsHasNull);\n      j3 = sqlite3VdbeAddOp4Int(v, OP_Found, pExpr->iTable, 0, rRhsHasNull, 1);\n      sqlite3VdbeAddOp2(v, OP_Integer, -1, rRhsHasNull);\n      sqlite3VdbeJumpHere(v, j3);\n      sqlite3VdbeAddOp2(v, OP_AddImm, rRhsHasNull, 1);\n      sqlite3VdbeJumpHere(v, j2);\n\n      /* Jump to the appropriate target depending on whether or not\n      ** the RHS contains a NULL\n      */\n      sqlite3VdbeAddOp2(v, OP_If, rRhsHasNull, destIfNull);\n      sqlite3VdbeAddOp2(v, OP_Goto, 0, destIfFalse);\n\n      /* The OP_Found at the top of this branch jumps here when true, \n      ** causing the overall IN expression evaluation to fall through.\n      */\n      sqlite3VdbeJumpHere(v, j1);\n    }\n  }\n  sqlite3ReleaseTempReg(pParse, r1);\n  sqlite3ExprCachePop(pParse, 1);\n  VdbeComment((v, \"end IN expr\"));\n}\n#endif /* SQLITE_OMIT_SUBQUERY */\n\n/*\n** Duplicate an 8-byte value\n*/\nstatic char *dup8bytes(Vdbe *v, const char *in){\n  char *out = sqlite3DbMallocRaw(sqlite3VdbeDb(v), 8);\n  if( out ){\n    memcpy(out, in, 8);\n  }\n  return out;\n}\n\n#ifndef SQLITE_OMIT_FLOATING_POINT\n/*\n** Generate an instruction that will put the floating point\n** value described by z[0..n-1] into register iMem.\n**\n** The z[] string will probably not be zero-terminated.  But the \n** z[n] character is guaranteed to be something that does not look\n** like the continuation of the number.\n*/\nstatic void codeReal(Vdbe *v, const char *z, int negateFlag, int iMem){\n  if( ALWAYS(z!=0) ){\n    double value;\n    char *zV;\n    sqlite3AtoF(z, &value, sqlite3Strlen30(z), SQLITE_UTF8);\n    assert( !sqlite3IsNaN(value) ); /* The new AtoF never returns NaN */\n    if( negateFlag ) value = -value;\n    zV = dup8bytes(v, (char*)&value);\n    sqlite3VdbeAddOp4(v, OP_Real, 0, iMem, 0, zV, P4_REAL);\n  }\n}\n#endif\n\n\n/*\n** Generate an instruction that will put the integer describe by\n** text z[0..n-1] into register iMem.\n**\n** Expr.u.zToken is always UTF8 and zero-terminated.\n*/\nstatic void codeInteger(Parse *pParse, Expr *pExpr, int negFlag, int iMem){\n  Vdbe *v = pParse->pVdbe;\n  if( pExpr->flags & EP_IntValue ){\n    int i = pExpr->u.iValue;\n    assert( i>=0 );\n    if( negFlag ) i = -i;\n    sqlite3VdbeAddOp2(v, OP_Integer, i, iMem);\n  }else{\n    int c;\n    i64 value;\n    const char *z = pExpr->u.zToken;\n    assert( z!=0 );\n    c = sqlite3Atoi64(z, &value, sqlite3Strlen30(z), SQLITE_UTF8);\n    if( c==0 || (c==2 && negFlag) ){\n      char *zV;\n      if( negFlag ){ value = c==2 ? SMALLEST_INT64 : -value; }\n      zV = dup8bytes(v, (char*)&value);\n      sqlite3VdbeAddOp4(v, OP_Int64, 0, iMem, 0, zV, P4_INT64);\n    }else{\n#ifdef SQLITE_OMIT_FLOATING_POINT\n      sqlite3ErrorMsg(pParse, \"oversized integer: %s%s\", negFlag ? \"-\" : \"\", z);\n#else\n      codeReal(v, z, negFlag, iMem);\n#endif\n    }\n  }\n}\n\n/*\n** Clear a cache entry.\n*/\nstatic void cacheEntryClear(Parse *pParse, struct yColCache *p){\n  if( p->tempReg ){\n    if( pParse->nTempReg<ArraySize(pParse->aTempReg) ){\n      pParse->aTempReg[pParse->nTempReg++] = p->iReg;\n    }\n    p->tempReg = 0;\n  }\n}\n\n\n/*\n** Record in the column cache that a particular column from a\n** particular table is stored in a particular register.\n*/\nSQLITE_PRIVATE void sqlite3ExprCacheStore(Parse *pParse, int iTab, int iCol, int iReg){\n  int i;\n  int minLru;\n  int idxLru;\n  struct yColCache *p;\n\n  assert( iReg>0 );  /* Register numbers are always positive */\n  assert( iCol>=-1 && iCol<32768 );  /* Finite column numbers */\n\n  /* The SQLITE_ColumnCache flag disables the column cache.  This is used\n  ** for testing only - to verify that SQLite always gets the same answer\n  ** with and without the column cache.\n  */\n  if( pParse->db->flags & SQLITE_ColumnCache ) return;\n\n  /* First replace any existing entry.\n  **\n  ** Actually, the way the column cache is currently used, we are guaranteed\n  ** that the object will never already be in cache.  Verify this guarantee.\n  */\n#ifndef NDEBUG\n  for(i=0, p=pParse->aColCache; i<SQLITE_N_COLCACHE; i++, p++){\n#if 0 /* This code wold remove the entry from the cache if it existed */\n    if( p->iReg && p->iTable==iTab && p->iColumn==iCol ){\n      cacheEntryClear(pParse, p);\n      p->iLevel = pParse->iCacheLevel;\n      p->iReg = iReg;\n      p->lru = pParse->iCacheCnt++;\n      return;\n    }\n#endif\n    assert( p->iReg==0 || p->iTable!=iTab || p->iColumn!=iCol );\n  }\n#endif\n\n  /* Find an empty slot and replace it */\n  for(i=0, p=pParse->aColCache; i<SQLITE_N_COLCACHE; i++, p++){\n    if( p->iReg==0 ){\n      p->iLevel = pParse->iCacheLevel;\n      p->iTable = iTab;\n      p->iColumn = iCol;\n      p->iReg = iReg;\n      p->tempReg = 0;\n      p->lru = pParse->iCacheCnt++;\n      return;\n    }\n  }\n\n  /* Replace the last recently used */\n  minLru = 0x7fffffff;\n  idxLru = -1;\n  for(i=0, p=pParse->aColCache; i<SQLITE_N_COLCACHE; i++, p++){\n    if( p->lru<minLru ){\n      idxLru = i;\n      minLru = p->lru;\n    }\n  }\n  if( ALWAYS(idxLru>=0) ){\n    p = &pParse->aColCache[idxLru];\n    p->iLevel = pParse->iCacheLevel;\n    p->iTable = iTab;\n    p->iColumn = iCol;\n    p->iReg = iReg;\n    p->tempReg = 0;\n    p->lru = pParse->iCacheCnt++;\n    return;\n  }\n}\n\n/*\n** Indicate that registers between iReg..iReg+nReg-1 are being overwritten.\n** Purge the range of registers from the column cache.\n*/\nSQLITE_PRIVATE void sqlite3ExprCacheRemove(Parse *pParse, int iReg, int nReg){\n  int i;\n  int iLast = iReg + nReg - 1;\n  struct yColCache *p;\n  for(i=0, p=pParse->aColCache; i<SQLITE_N_COLCACHE; i++, p++){\n    int r = p->iReg;\n    if( r>=iReg && r<=iLast ){\n      cacheEntryClear(pParse, p);\n      p->iReg = 0;\n    }\n  }\n}\n\n/*\n** Remember the current column cache context.  Any new entries added\n** added to the column cache after this call are removed when the\n** corresponding pop occurs.\n*/\nSQLITE_PRIVATE void sqlite3ExprCachePush(Parse *pParse){\n  pParse->iCacheLevel++;\n}\n\n/*\n** Remove from the column cache any entries that were added since the\n** the previous N Push operations.  In other words, restore the cache\n** to the state it was in N Pushes ago.\n*/\nSQLITE_PRIVATE void sqlite3ExprCachePop(Parse *pParse, int N){\n  int i;\n  struct yColCache *p;\n  assert( N>0 );\n  assert( pParse->iCacheLevel>=N );\n  pParse->iCacheLevel -= N;\n  for(i=0, p=pParse->aColCache; i<SQLITE_N_COLCACHE; i++, p++){\n    if( p->iReg && p->iLevel>pParse->iCacheLevel ){\n      cacheEntryClear(pParse, p);\n      p->iReg = 0;\n    }\n  }\n}\n\n/*\n** When a cached column is reused, make sure that its register is\n** no longer available as a temp register.  ticket #3879:  that same\n** register might be in the cache in multiple places, so be sure to\n** get them all.\n*/\nstatic void sqlite3ExprCachePinRegister(Parse *pParse, int iReg){\n  int i;\n  struct yColCache *p;\n  for(i=0, p=pParse->aColCache; i<SQLITE_N_COLCACHE; i++, p++){\n    if( p->iReg==iReg ){\n      p->tempReg = 0;\n    }\n  }\n}\n\n/*\n** Generate code to extract the value of the iCol-th column of a table.\n*/\nSQLITE_PRIVATE void sqlite3ExprCodeGetColumnOfTable(\n  Vdbe *v,        /* The VDBE under construction */\n  Table *pTab,    /* The table containing the value */\n  int iTabCur,    /* The cursor for this table */\n  int iCol,       /* Index of the column to extract */\n  int regOut      /* Extract the valud into this register */\n){\n  if( iCol<0 || iCol==pTab->iPKey ){\n    sqlite3VdbeAddOp2(v, OP_Rowid, iTabCur, regOut);\n  }else{\n    int op = IsVirtual(pTab) ? OP_VColumn : OP_Column;\n    sqlite3VdbeAddOp3(v, op, iTabCur, iCol, regOut);\n  }\n  if( iCol>=0 ){\n    sqlite3ColumnDefault(v, pTab, iCol, regOut);\n  }\n}\n\n/*\n** Generate code that will extract the iColumn-th column from\n** table pTab and store the column value in a register.  An effort\n** is made to store the column value in register iReg, but this is\n** not guaranteed.  The location of the column value is returned.\n**\n** There must be an open cursor to pTab in iTable when this routine\n** is called.  If iColumn<0 then code is generated that extracts the rowid.\n*/\nSQLITE_PRIVATE int sqlite3ExprCodeGetColumn(\n  Parse *pParse,   /* Parsing and code generating context */\n  Table *pTab,     /* Description of the table we are reading from */\n  int iColumn,     /* Index of the table column */\n  int iTable,      /* The cursor pointing to the table */\n  int iReg         /* Store results here */\n){\n  Vdbe *v = pParse->pVdbe;\n  int i;\n  struct yColCache *p;\n\n  for(i=0, p=pParse->aColCache; i<SQLITE_N_COLCACHE; i++, p++){\n    if( p->iReg>0 && p->iTable==iTable && p->iColumn==iColumn ){\n      p->lru = pParse->iCacheCnt++;\n      sqlite3ExprCachePinRegister(pParse, p->iReg);\n      return p->iReg;\n    }\n  }  \n  assert( v!=0 );\n  sqlite3ExprCodeGetColumnOfTable(v, pTab, iTable, iColumn, iReg);\n  sqlite3ExprCacheStore(pParse, iTable, iColumn, iReg);\n  return iReg;\n}\n\n/*\n** Clear all column cache entries.\n*/\nSQLITE_PRIVATE void sqlite3ExprCacheClear(Parse *pParse){\n  int i;\n  struct yColCache *p;\n\n  for(i=0, p=pParse->aColCache; i<SQLITE_N_COLCACHE; i++, p++){\n    if( p->iReg ){\n      cacheEntryClear(pParse, p);\n      p->iReg = 0;\n    }\n  }\n}\n\n/*\n** Record the fact that an affinity change has occurred on iCount\n** registers starting with iStart.\n*/\nSQLITE_PRIVATE void sqlite3ExprCacheAffinityChange(Parse *pParse, int iStart, int iCount){\n  sqlite3ExprCacheRemove(pParse, iStart, iCount);\n}\n\n/*\n** Generate code to move content from registers iFrom...iFrom+nReg-1\n** over to iTo..iTo+nReg-1. Keep the column cache up-to-date.\n*/\nSQLITE_PRIVATE void sqlite3ExprCodeMove(Parse *pParse, int iFrom, int iTo, int nReg){\n  int i;\n  struct yColCache *p;\n  if( NEVER(iFrom==iTo) ) return;\n  sqlite3VdbeAddOp3(pParse->pVdbe, OP_Move, iFrom, iTo, nReg);\n  for(i=0, p=pParse->aColCache; i<SQLITE_N_COLCACHE; i++, p++){\n    int x = p->iReg;\n    if( x>=iFrom && x<iFrom+nReg ){\n      p->iReg += iTo-iFrom;\n    }\n  }\n}\n\n/*\n** Generate code to copy content from registers iFrom...iFrom+nReg-1\n** over to iTo..iTo+nReg-1.\n*/\nSQLITE_PRIVATE void sqlite3ExprCodeCopy(Parse *pParse, int iFrom, int iTo, int nReg){\n  int i;\n  if( NEVER(iFrom==iTo) ) return;\n  for(i=0; i<nReg; i++){\n    sqlite3VdbeAddOp2(pParse->pVdbe, OP_Copy, iFrom+i, iTo+i);\n  }\n}\n\n#if defined(SQLITE_DEBUG) || defined(SQLITE_COVERAGE_TEST)\n/*\n** Return true if any register in the range iFrom..iTo (inclusive)\n** is used as part of the column cache.\n**\n** This routine is used within assert() and testcase() macros only\n** and does not appear in a normal build.\n*/\nstatic int usedAsColumnCache(Parse *pParse, int iFrom, int iTo){\n  int i;\n  struct yColCache *p;\n  for(i=0, p=pParse->aColCache; i<SQLITE_N_COLCACHE; i++, p++){\n    int r = p->iReg;\n    if( r>=iFrom && r<=iTo ) return 1;    /*NO_TEST*/\n  }\n  return 0;\n}\n#endif /* SQLITE_DEBUG || SQLITE_COVERAGE_TEST */\n\n/*\n** Generate code into the current Vdbe to evaluate the given\n** expression.  Attempt to store the results in register \"target\".\n** Return the register where results are stored.\n**\n** With this routine, there is no guarantee that results will\n** be stored in target.  The result might be stored in some other\n** register if it is convenient to do so.  The calling function\n** must check the return code and move the results to the desired\n** register.\n*/\nSQLITE_PRIVATE int sqlite3ExprCodeTarget(Parse *pParse, Expr *pExpr, int target){\n  Vdbe *v = pParse->pVdbe;  /* The VM under construction */\n  int op;                   /* The opcode being coded */\n  int inReg = target;       /* Results stored in register inReg */\n  int regFree1 = 0;         /* If non-zero free this temporary register */\n  int regFree2 = 0;         /* If non-zero free this temporary register */\n  int r1, r2, r3, r4;       /* Various register numbers */\n  sqlite3 *db = pParse->db; /* The database connection */\n\n  assert( target>0 && target<=pParse->nMem );\n  if( v==0 ){\n    assert( pParse->db->mallocFailed );\n    return 0;\n  }\n\n  if( pExpr==0 ){\n    op = TK_NULL;\n  }else{\n    op = pExpr->op;\n  }\n  switch( op ){\n    case TK_AGG_COLUMN: {\n      AggInfo *pAggInfo = pExpr->pAggInfo;\n      struct AggInfo_col *pCol = &pAggInfo->aCol[pExpr->iAgg];\n      if( !pAggInfo->directMode ){\n        assert( pCol->iMem>0 );\n        inReg = pCol->iMem;\n        break;\n      }else if( pAggInfo->useSortingIdx ){\n        sqlite3VdbeAddOp3(v, OP_Column, pAggInfo->sortingIdx,\n                              pCol->iSorterColumn, target);\n        break;\n      }\n      /* Otherwise, fall thru into the TK_COLUMN case */\n    }\n    case TK_COLUMN: {\n      if( pExpr->iTable<0 ){\n        /* This only happens when coding check constraints */\n        assert( pParse->ckBase>0 );\n        inReg = pExpr->iColumn + pParse->ckBase;\n      }else{\n        inReg = sqlite3ExprCodeGetColumn(pParse, pExpr->pTab,\n                                 pExpr->iColumn, pExpr->iTable, target);\n      }\n      break;\n    }\n    case TK_INTEGER: {\n      codeInteger(pParse, pExpr, 0, target);\n      break;\n    }\n#ifndef SQLITE_OMIT_FLOATING_POINT\n    case TK_FLOAT: {\n      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n      codeReal(v, pExpr->u.zToken, 0, target);\n      break;\n    }\n#endif\n    case TK_STRING: {\n      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n      sqlite3VdbeAddOp4(v, OP_String8, 0, target, 0, pExpr->u.zToken, 0);\n      break;\n    }\n    case TK_NULL: {\n      sqlite3VdbeAddOp2(v, OP_Null, 0, target);\n      break;\n    }\n#ifndef SQLITE_OMIT_BLOB_LITERAL\n    case TK_BLOB: {\n      int n;\n      const char *z;\n      char *zBlob;\n      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n      assert( pExpr->u.zToken[0]=='x' || pExpr->u.zToken[0]=='X' );\n      assert( pExpr->u.zToken[1]=='\\'' );\n      z = &pExpr->u.zToken[2];\n      n = sqlite3Strlen30(z) - 1;\n      assert( z[n]=='\\'' );\n      zBlob = sqlite3HexToBlob(sqlite3VdbeDb(v), z, n);\n      sqlite3VdbeAddOp4(v, OP_Blob, n/2, target, 0, zBlob, P4_DYNAMIC);\n      break;\n    }\n#endif\n    case TK_VARIABLE: {\n      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n      assert( pExpr->u.zToken!=0 );\n      assert( pExpr->u.zToken[0]!=0 );\n      sqlite3VdbeAddOp2(v, OP_Variable, pExpr->iColumn, target);\n      if( pExpr->u.zToken[1]!=0 ){\n        sqlite3VdbeChangeP4(v, -1, pExpr->u.zToken, 0);\n      }\n      break;\n    }\n    case TK_REGISTER: {\n      inReg = pExpr->iTable;\n      break;\n    }\n    case TK_AS: {\n      inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);\n      break;\n    }\n#ifndef SQLITE_OMIT_CAST\n    case TK_CAST: {\n      /* Expressions of the form:   CAST(pLeft AS token) */\n      int aff, to_op;\n      inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);\n      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n      aff = sqlite3AffinityType(pExpr->u.zToken);\n      to_op = aff - SQLITE_AFF_TEXT + OP_ToText;\n      assert( to_op==OP_ToText    || aff!=SQLITE_AFF_TEXT    );\n      assert( to_op==OP_ToBlob    || aff!=SQLITE_AFF_NONE    );\n      assert( to_op==OP_ToNumeric || aff!=SQLITE_AFF_NUMERIC );\n      assert( to_op==OP_ToInt     || aff!=SQLITE_AFF_INTEGER );\n      assert( to_op==OP_ToReal    || aff!=SQLITE_AFF_REAL    );\n      testcase( to_op==OP_ToText );\n      testcase( to_op==OP_ToBlob );\n      testcase( to_op==OP_ToNumeric );\n      testcase( to_op==OP_ToInt );\n      testcase( to_op==OP_ToReal );\n      if( inReg!=target ){\n        sqlite3VdbeAddOp2(v, OP_SCopy, inReg, target);\n        inReg = target;\n      }\n      sqlite3VdbeAddOp1(v, to_op, inReg);\n      testcase( usedAsColumnCache(pParse, inReg, inReg) );\n      sqlite3ExprCacheAffinityChange(pParse, inReg, 1);\n      break;\n    }\n#endif /* SQLITE_OMIT_CAST */\n    case TK_LT:\n    case TK_LE:\n    case TK_GT:\n    case TK_GE:\n    case TK_NE:\n    case TK_EQ: {\n      assert( TK_LT==OP_Lt );\n      assert( TK_LE==OP_Le );\n      assert( TK_GT==OP_Gt );\n      assert( TK_GE==OP_Ge );\n      assert( TK_EQ==OP_Eq );\n      assert( TK_NE==OP_Ne );\n      testcase( op==TK_LT );\n      testcase( op==TK_LE );\n      testcase( op==TK_GT );\n      testcase( op==TK_GE );\n      testcase( op==TK_EQ );\n      testcase( op==TK_NE );\n      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n      r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);\n      codeCompare(pParse, pExpr->pLeft, pExpr->pRight, op,\n                  r1, r2, inReg, SQLITE_STOREP2);\n      testcase( regFree1==0 );\n      testcase( regFree2==0 );\n      break;\n    }\n    case TK_IS:\n    case TK_ISNOT: {\n      testcase( op==TK_IS );\n      testcase( op==TK_ISNOT );\n      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n      r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);\n      op = (op==TK_IS) ? TK_EQ : TK_NE;\n      codeCompare(pParse, pExpr->pLeft, pExpr->pRight, op,\n                  r1, r2, inReg, SQLITE_STOREP2 | SQLITE_NULLEQ);\n      testcase( regFree1==0 );\n      testcase( regFree2==0 );\n      break;\n    }\n    case TK_AND:\n    case TK_OR:\n    case TK_PLUS:\n    case TK_STAR:\n    case TK_MINUS:\n    case TK_REM:\n    case TK_BITAND:\n    case TK_BITOR:\n    case TK_SLASH:\n    case TK_LSHIFT:\n    case TK_RSHIFT: \n    case TK_CONCAT: {\n      assert( TK_AND==OP_And );\n      assert( TK_OR==OP_Or );\n      assert( TK_PLUS==OP_Add );\n      assert( TK_MINUS==OP_Subtract );\n      assert( TK_REM==OP_Remainder );\n      assert( TK_BITAND==OP_BitAnd );\n      assert( TK_BITOR==OP_BitOr );\n      assert( TK_SLASH==OP_Divide );\n      assert( TK_LSHIFT==OP_ShiftLeft );\n      assert( TK_RSHIFT==OP_ShiftRight );\n      assert( TK_CONCAT==OP_Concat );\n      testcase( op==TK_AND );\n      testcase( op==TK_OR );\n      testcase( op==TK_PLUS );\n      testcase( op==TK_MINUS );\n      testcase( op==TK_REM );\n      testcase( op==TK_BITAND );\n      testcase( op==TK_BITOR );\n      testcase( op==TK_SLASH );\n      testcase( op==TK_LSHIFT );\n      testcase( op==TK_RSHIFT );\n      testcase( op==TK_CONCAT );\n      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n      r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);\n      sqlite3VdbeAddOp3(v, op, r2, r1, target);\n      testcase( regFree1==0 );\n      testcase( regFree2==0 );\n      break;\n    }\n    case TK_UMINUS: {\n      Expr *pLeft = pExpr->pLeft;\n      assert( pLeft );\n      if( pLeft->op==TK_INTEGER ){\n        codeInteger(pParse, pLeft, 1, target);\n#ifndef SQLITE_OMIT_FLOATING_POINT\n      }else if( pLeft->op==TK_FLOAT ){\n        assert( !ExprHasProperty(pExpr, EP_IntValue) );\n        codeReal(v, pLeft->u.zToken, 1, target);\n#endif\n      }else{\n        regFree1 = r1 = sqlite3GetTempReg(pParse);\n        sqlite3VdbeAddOp2(v, OP_Integer, 0, r1);\n        r2 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree2);\n        sqlite3VdbeAddOp3(v, OP_Subtract, r2, r1, target);\n        testcase( regFree2==0 );\n      }\n      inReg = target;\n      break;\n    }\n    case TK_BITNOT:\n    case TK_NOT: {\n      assert( TK_BITNOT==OP_BitNot );\n      assert( TK_NOT==OP_Not );\n      testcase( op==TK_BITNOT );\n      testcase( op==TK_NOT );\n      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n      testcase( regFree1==0 );\n      inReg = target;\n      sqlite3VdbeAddOp2(v, op, r1, inReg);\n      break;\n    }\n    case TK_ISNULL:\n    case TK_NOTNULL: {\n      int addr;\n      assert( TK_ISNULL==OP_IsNull );\n      assert( TK_NOTNULL==OP_NotNull );\n      testcase( op==TK_ISNULL );\n      testcase( op==TK_NOTNULL );\n      sqlite3VdbeAddOp2(v, OP_Integer, 1, target);\n      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n      testcase( regFree1==0 );\n      addr = sqlite3VdbeAddOp1(v, op, r1);\n      sqlite3VdbeAddOp2(v, OP_AddImm, target, -1);\n      sqlite3VdbeJumpHere(v, addr);\n      break;\n    }\n    case TK_AGG_FUNCTION: {\n      AggInfo *pInfo = pExpr->pAggInfo;\n      if( pInfo==0 ){\n        assert( !ExprHasProperty(pExpr, EP_IntValue) );\n        sqlite3ErrorMsg(pParse, \"misuse of aggregate: %s()\", pExpr->u.zToken);\n      }else{\n        inReg = pInfo->aFunc[pExpr->iAgg].iMem;\n      }\n      break;\n    }\n    case TK_CONST_FUNC:\n    case TK_FUNCTION: {\n      ExprList *pFarg;       /* List of function arguments */\n      int nFarg;             /* Number of function arguments */\n      FuncDef *pDef;         /* The function definition object */\n      int nId;               /* Length of the function name in bytes */\n      const char *zId;       /* The function name */\n      int constMask = 0;     /* Mask of function arguments that are constant */\n      int i;                 /* Loop counter */\n      u8 enc = ENC(db);      /* The text encoding used by this database */\n      CollSeq *pColl = 0;    /* A collating sequence */\n\n      assert( !ExprHasProperty(pExpr, EP_xIsSelect) );\n      testcase( op==TK_CONST_FUNC );\n      testcase( op==TK_FUNCTION );\n      if( ExprHasAnyProperty(pExpr, EP_TokenOnly) ){\n        pFarg = 0;\n      }else{\n        pFarg = pExpr->x.pList;\n      }\n      nFarg = pFarg ? pFarg->nExpr : 0;\n      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n      zId = pExpr->u.zToken;\n      nId = sqlite3Strlen30(zId);\n      pDef = sqlite3FindFunction(db, zId, nId, nFarg, enc, 0);\n      if( pDef==0 ){\n        sqlite3ErrorMsg(pParse, \"unknown function: %.*s()\", nId, zId);\n        break;\n      }\n\n      /* Attempt a direct implementation of the built-in COALESCE() and\n      ** IFNULL() functions.  This avoids unnecessary evalation of\n      ** arguments past the first non-NULL argument.\n      */\n      if( pDef->flags & SQLITE_FUNC_COALESCE ){\n        int endCoalesce = sqlite3VdbeMakeLabel(v);\n        assert( nFarg>=2 );\n        sqlite3ExprCode(pParse, pFarg->a[0].pExpr, target);\n        for(i=1; i<nFarg; i++){\n          sqlite3VdbeAddOp2(v, OP_NotNull, target, endCoalesce);\n          sqlite3ExprCacheRemove(pParse, target, 1);\n          sqlite3ExprCachePush(pParse);\n          sqlite3ExprCode(pParse, pFarg->a[i].pExpr, target);\n          sqlite3ExprCachePop(pParse, 1);\n        }\n        sqlite3VdbeResolveLabel(v, endCoalesce);\n        break;\n      }\n\n\n      if( pFarg ){\n        r1 = sqlite3GetTempRange(pParse, nFarg);\n        sqlite3ExprCachePush(pParse);     /* Ticket 2ea2425d34be */\n        sqlite3ExprCodeExprList(pParse, pFarg, r1, 1);\n        sqlite3ExprCachePop(pParse, 1);   /* Ticket 2ea2425d34be */\n      }else{\n        r1 = 0;\n      }\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n      /* Possibly overload the function if the first argument is\n      ** a virtual table column.\n      **\n      ** For infix functions (LIKE, GLOB, REGEXP, and MATCH) use the\n      ** second argument, not the first, as the argument to test to\n      ** see if it is a column in a virtual table.  This is done because\n      ** the left operand of infix functions (the operand we want to\n      ** control overloading) ends up as the second argument to the\n      ** function.  The expression \"A glob B\" is equivalent to \n      ** \"glob(B,A).  We want to use the A in \"A glob B\" to test\n      ** for function overloading.  But we use the B term in \"glob(B,A)\".\n      */\n      if( nFarg>=2 && (pExpr->flags & EP_InfixFunc) ){\n        pDef = sqlite3VtabOverloadFunction(db, pDef, nFarg, pFarg->a[1].pExpr);\n      }else if( nFarg>0 ){\n        pDef = sqlite3VtabOverloadFunction(db, pDef, nFarg, pFarg->a[0].pExpr);\n      }\n#endif\n      for(i=0; i<nFarg; i++){\n        if( i<32 && sqlite3ExprIsConstant(pFarg->a[i].pExpr) ){\n          constMask |= (1<<i);\n        }\n        if( (pDef->flags & SQLITE_FUNC_NEEDCOLL)!=0 && !pColl ){\n          pColl = sqlite3ExprCollSeq(pParse, pFarg->a[i].pExpr);\n        }\n      }\n      if( pDef->flags & SQLITE_FUNC_NEEDCOLL ){\n        if( !pColl ) pColl = db->pDfltColl; \n        sqlite3VdbeAddOp4(v, OP_CollSeq, 0, 0, 0, (char *)pColl, P4_COLLSEQ);\n      }\n      sqlite3VdbeAddOp4(v, OP_Function, constMask, r1, target,\n                        (char*)pDef, P4_FUNCDEF);\n      sqlite3VdbeChangeP5(v, (u8)nFarg);\n      if( nFarg ){\n        sqlite3ReleaseTempRange(pParse, r1, nFarg);\n      }\n      break;\n    }\n#ifndef SQLITE_OMIT_SUBQUERY\n    case TK_EXISTS:\n    case TK_SELECT: {\n      testcase( op==TK_EXISTS );\n      testcase( op==TK_SELECT );\n      inReg = sqlite3CodeSubselect(pParse, pExpr, 0, 0);\n      break;\n    }\n    case TK_IN: {\n      int destIfFalse = sqlite3VdbeMakeLabel(v);\n      int destIfNull = sqlite3VdbeMakeLabel(v);\n      sqlite3VdbeAddOp2(v, OP_Null, 0, target);\n      sqlite3ExprCodeIN(pParse, pExpr, destIfFalse, destIfNull);\n      sqlite3VdbeAddOp2(v, OP_Integer, 1, target);\n      sqlite3VdbeResolveLabel(v, destIfFalse);\n      sqlite3VdbeAddOp2(v, OP_AddImm, target, 0);\n      sqlite3VdbeResolveLabel(v, destIfNull);\n      break;\n    }\n#endif /* SQLITE_OMIT_SUBQUERY */\n\n\n    /*\n    **    x BETWEEN y AND z\n    **\n    ** This is equivalent to\n    **\n    **    x>=y AND x<=z\n    **\n    ** X is stored in pExpr->pLeft.\n    ** Y is stored in pExpr->pList->a[0].pExpr.\n    ** Z is stored in pExpr->pList->a[1].pExpr.\n    */\n    case TK_BETWEEN: {\n      Expr *pLeft = pExpr->pLeft;\n      struct ExprList_item *pLItem = pExpr->x.pList->a;\n      Expr *pRight = pLItem->pExpr;\n\n      r1 = sqlite3ExprCodeTemp(pParse, pLeft, &regFree1);\n      r2 = sqlite3ExprCodeTemp(pParse, pRight, &regFree2);\n      testcase( regFree1==0 );\n      testcase( regFree2==0 );\n      r3 = sqlite3GetTempReg(pParse);\n      r4 = sqlite3GetTempReg(pParse);\n      codeCompare(pParse, pLeft, pRight, OP_Ge,\n                  r1, r2, r3, SQLITE_STOREP2);\n      pLItem++;\n      pRight = pLItem->pExpr;\n      sqlite3ReleaseTempReg(pParse, regFree2);\n      r2 = sqlite3ExprCodeTemp(pParse, pRight, &regFree2);\n      testcase( regFree2==0 );\n      codeCompare(pParse, pLeft, pRight, OP_Le, r1, r2, r4, SQLITE_STOREP2);\n      sqlite3VdbeAddOp3(v, OP_And, r3, r4, target);\n      sqlite3ReleaseTempReg(pParse, r3);\n      sqlite3ReleaseTempReg(pParse, r4);\n      break;\n    }\n    case TK_UPLUS: {\n      inReg = sqlite3ExprCodeTarget(pParse, pExpr->pLeft, target);\n      break;\n    }\n\n    case TK_TRIGGER: {\n      /* If the opcode is TK_TRIGGER, then the expression is a reference\n      ** to a column in the new.* or old.* pseudo-tables available to\n      ** trigger programs. In this case Expr.iTable is set to 1 for the\n      ** new.* pseudo-table, or 0 for the old.* pseudo-table. Expr.iColumn\n      ** is set to the column of the pseudo-table to read, or to -1 to\n      ** read the rowid field.\n      **\n      ** The expression is implemented using an OP_Param opcode. The p1\n      ** parameter is set to 0 for an old.rowid reference, or to (i+1)\n      ** to reference another column of the old.* pseudo-table, where \n      ** i is the index of the column. For a new.rowid reference, p1 is\n      ** set to (n+1), where n is the number of columns in each pseudo-table.\n      ** For a reference to any other column in the new.* pseudo-table, p1\n      ** is set to (n+2+i), where n and i are as defined previously. For\n      ** example, if the table on which triggers are being fired is\n      ** declared as:\n      **\n      **   CREATE TABLE t1(a, b);\n      **\n      ** Then p1 is interpreted as follows:\n      **\n      **   p1==0   ->    old.rowid     p1==3   ->    new.rowid\n      **   p1==1   ->    old.a         p1==4   ->    new.a\n      **   p1==2   ->    old.b         p1==5   ->    new.b       \n      */\n      Table *pTab = pExpr->pTab;\n      int p1 = pExpr->iTable * (pTab->nCol+1) + 1 + pExpr->iColumn;\n\n      assert( pExpr->iTable==0 || pExpr->iTable==1 );\n      assert( pExpr->iColumn>=-1 && pExpr->iColumn<pTab->nCol );\n      assert( pTab->iPKey<0 || pExpr->iColumn!=pTab->iPKey );\n      assert( p1>=0 && p1<(pTab->nCol*2+2) );\n\n      sqlite3VdbeAddOp2(v, OP_Param, p1, target);\n      VdbeComment((v, \"%s.%s -> $%d\",\n        (pExpr->iTable ? \"new\" : \"old\"),\n        (pExpr->iColumn<0 ? \"rowid\" : pExpr->pTab->aCol[pExpr->iColumn].zName),\n        target\n      ));\n\n#ifndef SQLITE_OMIT_FLOATING_POINT\n      /* If the column has REAL affinity, it may currently be stored as an\n      ** integer. Use OP_RealAffinity to make sure it is really real.  */\n      if( pExpr->iColumn>=0 \n       && pTab->aCol[pExpr->iColumn].affinity==SQLITE_AFF_REAL\n      ){\n        sqlite3VdbeAddOp1(v, OP_RealAffinity, target);\n      }\n#endif\n      break;\n    }\n\n\n    /*\n    ** Form A:\n    **   CASE x WHEN e1 THEN r1 WHEN e2 THEN r2 ... WHEN eN THEN rN ELSE y END\n    **\n    ** Form B:\n    **   CASE WHEN e1 THEN r1 WHEN e2 THEN r2 ... WHEN eN THEN rN ELSE y END\n    **\n    ** Form A is can be transformed into the equivalent form B as follows:\n    **   CASE WHEN x=e1 THEN r1 WHEN x=e2 THEN r2 ...\n    **        WHEN x=eN THEN rN ELSE y END\n    **\n    ** X (if it exists) is in pExpr->pLeft.\n    ** Y is in pExpr->pRight.  The Y is also optional.  If there is no\n    ** ELSE clause and no other term matches, then the result of the\n    ** exprssion is NULL.\n    ** Ei is in pExpr->pList->a[i*2] and Ri is pExpr->pList->a[i*2+1].\n    **\n    ** The result of the expression is the Ri for the first matching Ei,\n    ** or if there is no matching Ei, the ELSE term Y, or if there is\n    ** no ELSE term, NULL.\n    */\n    default: assert( op==TK_CASE ); {\n      int endLabel;                     /* GOTO label for end of CASE stmt */\n      int nextCase;                     /* GOTO label for next WHEN clause */\n      int nExpr;                        /* 2x number of WHEN terms */\n      int i;                            /* Loop counter */\n      ExprList *pEList;                 /* List of WHEN terms */\n      struct ExprList_item *aListelem;  /* Array of WHEN terms */\n      Expr opCompare;                   /* The X==Ei expression */\n      Expr cacheX;                      /* Cached expression X */\n      Expr *pX;                         /* The X expression */\n      Expr *pTest = 0;                  /* X==Ei (form A) or just Ei (form B) */\n      VVA_ONLY( int iCacheLevel = pParse->iCacheLevel; )\n\n      assert( !ExprHasProperty(pExpr, EP_xIsSelect) && pExpr->x.pList );\n      assert((pExpr->x.pList->nExpr % 2) == 0);\n      assert(pExpr->x.pList->nExpr > 0);\n      pEList = pExpr->x.pList;\n      aListelem = pEList->a;\n      nExpr = pEList->nExpr;\n      endLabel = sqlite3VdbeMakeLabel(v);\n      if( (pX = pExpr->pLeft)!=0 ){\n        cacheX = *pX;\n        testcase( pX->op==TK_COLUMN );\n        testcase( pX->op==TK_REGISTER );\n        cacheX.iTable = sqlite3ExprCodeTemp(pParse, pX, &regFree1);\n        testcase( regFree1==0 );\n        cacheX.op = TK_REGISTER;\n        opCompare.op = TK_EQ;\n        opCompare.pLeft = &cacheX;\n        pTest = &opCompare;\n        /* Ticket b351d95f9cd5ef17e9d9dbae18f5ca8611190001:\n        ** The value in regFree1 might get SCopy-ed into the file result.\n        ** So make sure that the regFree1 register is not reused for other\n        ** purposes and possibly overwritten.  */\n        regFree1 = 0;\n      }\n      for(i=0; i<nExpr; i=i+2){\n        sqlite3ExprCachePush(pParse);\n        if( pX ){\n          assert( pTest!=0 );\n          opCompare.pRight = aListelem[i].pExpr;\n        }else{\n          pTest = aListelem[i].pExpr;\n        }\n        nextCase = sqlite3VdbeMakeLabel(v);\n        testcase( pTest->op==TK_COLUMN );\n        sqlite3ExprIfFalse(pParse, pTest, nextCase, SQLITE_JUMPIFNULL);\n        testcase( aListelem[i+1].pExpr->op==TK_COLUMN );\n        testcase( aListelem[i+1].pExpr->op==TK_REGISTER );\n        sqlite3ExprCode(pParse, aListelem[i+1].pExpr, target);\n        sqlite3VdbeAddOp2(v, OP_Goto, 0, endLabel);\n        sqlite3ExprCachePop(pParse, 1);\n        sqlite3VdbeResolveLabel(v, nextCase);\n      }\n      if( pExpr->pRight ){\n        sqlite3ExprCachePush(pParse);\n        sqlite3ExprCode(pParse, pExpr->pRight, target);\n        sqlite3ExprCachePop(pParse, 1);\n      }else{\n        sqlite3VdbeAddOp2(v, OP_Null, 0, target);\n      }\n      assert( db->mallocFailed || pParse->nErr>0 \n           || pParse->iCacheLevel==iCacheLevel );\n      sqlite3VdbeResolveLabel(v, endLabel);\n      break;\n    }\n#ifndef SQLITE_OMIT_TRIGGER\n    case TK_RAISE: {\n      assert( pExpr->affinity==OE_Rollback \n           || pExpr->affinity==OE_Abort\n           || pExpr->affinity==OE_Fail\n           || pExpr->affinity==OE_Ignore\n      );\n      if( !pParse->pTriggerTab ){\n        sqlite3ErrorMsg(pParse,\n                       \"RAISE() may only be used within a trigger-program\");\n        return 0;\n      }\n      if( pExpr->affinity==OE_Abort ){\n        sqlite3MayAbort(pParse);\n      }\n      assert( !ExprHasProperty(pExpr, EP_IntValue) );\n      if( pExpr->affinity==OE_Ignore ){\n        sqlite3VdbeAddOp4(\n            v, OP_Halt, SQLITE_OK, OE_Ignore, 0, pExpr->u.zToken,0);\n      }else{\n        sqlite3HaltConstraint(pParse, pExpr->affinity, pExpr->u.zToken, 0);\n      }\n\n      break;\n    }\n#endif\n  }\n  sqlite3ReleaseTempReg(pParse, regFree1);\n  sqlite3ReleaseTempReg(pParse, regFree2);\n  return inReg;\n}\n\n/*\n** Generate code to evaluate an expression and store the results\n** into a register.  Return the register number where the results\n** are stored.\n**\n** If the register is a temporary register that can be deallocated,\n** then write its number into *pReg.  If the result register is not\n** a temporary, then set *pReg to zero.\n*/\nSQLITE_PRIVATE int sqlite3ExprCodeTemp(Parse *pParse, Expr *pExpr, int *pReg){\n  int r1 = sqlite3GetTempReg(pParse);\n  int r2 = sqlite3ExprCodeTarget(pParse, pExpr, r1);\n  if( r2==r1 ){\n    *pReg = r1;\n  }else{\n    sqlite3ReleaseTempReg(pParse, r1);\n    *pReg = 0;\n  }\n  return r2;\n}\n\n/*\n** Generate code that will evaluate expression pExpr and store the\n** results in register target.  The results are guaranteed to appear\n** in register target.\n*/\nSQLITE_PRIVATE int sqlite3ExprCode(Parse *pParse, Expr *pExpr, int target){\n  int inReg;\n\n  assert( target>0 && target<=pParse->nMem );\n  if( pExpr && pExpr->op==TK_REGISTER ){\n    sqlite3VdbeAddOp2(pParse->pVdbe, OP_Copy, pExpr->iTable, target);\n  }else{\n    inReg = sqlite3ExprCodeTarget(pParse, pExpr, target);\n    assert( pParse->pVdbe || pParse->db->mallocFailed );\n    if( inReg!=target && pParse->pVdbe ){\n      sqlite3VdbeAddOp2(pParse->pVdbe, OP_SCopy, inReg, target);\n    }\n  }\n  return target;\n}\n\n/*\n** Generate code that evalutes the given expression and puts the result\n** in register target.\n**\n** Also make a copy of the expression results into another \"cache\" register\n** and modify the expression so that the next time it is evaluated,\n** the result is a copy of the cache register.\n**\n** This routine is used for expressions that are used multiple \n** times.  They are evaluated once and the results of the expression\n** are reused.\n*/\nSQLITE_PRIVATE int sqlite3ExprCodeAndCache(Parse *pParse, Expr *pExpr, int target){\n  Vdbe *v = pParse->pVdbe;\n  int inReg;\n  inReg = sqlite3ExprCode(pParse, pExpr, target);\n  assert( target>0 );\n  /* This routine is called for terms to INSERT or UPDATE.  And the only\n  ** other place where expressions can be converted into TK_REGISTER is\n  ** in WHERE clause processing.  So as currently implemented, there is\n  ** no way for a TK_REGISTER to exist here.  But it seems prudent to\n  ** keep the ALWAYS() in case the conditions above change with future\n  ** modifications or enhancements. */\n  if( ALWAYS(pExpr->op!=TK_REGISTER) ){  \n    int iMem;\n    iMem = ++pParse->nMem;\n    sqlite3VdbeAddOp2(v, OP_Copy, inReg, iMem);\n    pExpr->iTable = iMem;\n    pExpr->op2 = pExpr->op;\n    pExpr->op = TK_REGISTER;\n  }\n  return inReg;\n}\n\n/*\n** Return TRUE if pExpr is an constant expression that is appropriate\n** for factoring out of a loop.  Appropriate expressions are:\n**\n**    *  Any expression that evaluates to two or more opcodes.\n**\n**    *  Any OP_Integer, OP_Real, OP_String, OP_Blob, OP_Null, \n**       or OP_Variable that does not need to be placed in a \n**       specific register.\n**\n** There is no point in factoring out single-instruction constant\n** expressions that need to be placed in a particular register.  \n** We could factor them out, but then we would end up adding an\n** OP_SCopy instruction to move the value into the correct register\n** later.  We might as well just use the original instruction and\n** avoid the OP_SCopy.\n*/\nstatic int isAppropriateForFactoring(Expr *p){\n  if( !sqlite3ExprIsConstantNotJoin(p) ){\n    return 0;  /* Only constant expressions are appropriate for factoring */\n  }\n  if( (p->flags & EP_FixedDest)==0 ){\n    return 1;  /* Any constant without a fixed destination is appropriate */\n  }\n  while( p->op==TK_UPLUS ) p = p->pLeft;\n  switch( p->op ){\n#ifndef SQLITE_OMIT_BLOB_LITERAL\n    case TK_BLOB:\n#endif\n    case TK_VARIABLE:\n    case TK_INTEGER:\n    case TK_FLOAT:\n    case TK_NULL:\n    case TK_STRING: {\n      testcase( p->op==TK_BLOB );\n      testcase( p->op==TK_VARIABLE );\n      testcase( p->op==TK_INTEGER );\n      testcase( p->op==TK_FLOAT );\n      testcase( p->op==TK_NULL );\n      testcase( p->op==TK_STRING );\n      /* Single-instruction constants with a fixed destination are\n      ** better done in-line.  If we factor them, they will just end\n      ** up generating an OP_SCopy to move the value to the destination\n      ** register. */\n      return 0;\n    }\n    case TK_UMINUS: {\n      if( p->pLeft->op==TK_FLOAT || p->pLeft->op==TK_INTEGER ){\n        return 0;\n      }\n      break;\n    }\n    default: {\n      break;\n    }\n  }\n  return 1;\n}\n\n/*\n** If pExpr is a constant expression that is appropriate for\n** factoring out of a loop, then evaluate the expression\n** into a register and convert the expression into a TK_REGISTER\n** expression.\n*/\nstatic int evalConstExpr(Walker *pWalker, Expr *pExpr){\n  Parse *pParse = pWalker->pParse;\n  switch( pExpr->op ){\n    case TK_IN:\n    case TK_REGISTER: {\n      return WRC_Prune;\n    }\n    case TK_FUNCTION:\n    case TK_AGG_FUNCTION:\n    case TK_CONST_FUNC: {\n      /* The arguments to a function have a fixed destination.\n      ** Mark them this way to avoid generated unneeded OP_SCopy\n      ** instructions. \n      */\n      ExprList *pList = pExpr->x.pList;\n      assert( !ExprHasProperty(pExpr, EP_xIsSelect) );\n      if( pList ){\n        int i = pList->nExpr;\n        struct ExprList_item *pItem = pList->a;\n        for(; i>0; i--, pItem++){\n          if( ALWAYS(pItem->pExpr) ) pItem->pExpr->flags |= EP_FixedDest;\n        }\n      }\n      break;\n    }\n  }\n  if( isAppropriateForFactoring(pExpr) ){\n    int r1 = ++pParse->nMem;\n    int r2;\n    r2 = sqlite3ExprCodeTarget(pParse, pExpr, r1);\n    if( NEVER(r1!=r2) ) sqlite3ReleaseTempReg(pParse, r1);\n    pExpr->op2 = pExpr->op;\n    pExpr->op = TK_REGISTER;\n    pExpr->iTable = r2;\n    return WRC_Prune;\n  }\n  return WRC_Continue;\n}\n\n/*\n** Preevaluate constant subexpressions within pExpr and store the\n** results in registers.  Modify pExpr so that the constant subexpresions\n** are TK_REGISTER opcodes that refer to the precomputed values.\n**\n** This routine is a no-op if the jump to the cookie-check code has\n** already occur.  Since the cookie-check jump is generated prior to\n** any other serious processing, this check ensures that there is no\n** way to accidently bypass the constant initializations.\n**\n** This routine is also a no-op if the SQLITE_FactorOutConst optimization\n** is disabled via the sqlite3_test_control(SQLITE_TESTCTRL_OPTIMIZATIONS)\n** interface.  This allows test logic to verify that the same answer is\n** obtained for queries regardless of whether or not constants are\n** precomputed into registers or if they are inserted in-line.\n*/\nSQLITE_PRIVATE void sqlite3ExprCodeConstants(Parse *pParse, Expr *pExpr){\n  Walker w;\n  if( pParse->cookieGoto ) return;\n  if( (pParse->db->flags & SQLITE_FactorOutConst)!=0 ) return;\n  w.xExprCallback = evalConstExpr;\n  w.xSelectCallback = 0;\n  w.pParse = pParse;\n  sqlite3WalkExpr(&w, pExpr);\n}\n\n\n/*\n** Generate code that pushes the value of every element of the given\n** expression list into a sequence of registers beginning at target.\n**\n** Return the number of elements evaluated.\n*/\nSQLITE_PRIVATE int sqlite3ExprCodeExprList(\n  Parse *pParse,     /* Parsing context */\n  ExprList *pList,   /* The expression list to be coded */\n  int target,        /* Where to write results */\n  int doHardCopy     /* Make a hard copy of every element */\n){\n  struct ExprList_item *pItem;\n  int i, n;\n  assert( pList!=0 );\n  assert( target>0 );\n  assert( pParse->pVdbe!=0 );  /* Never gets this far otherwise */\n  n = pList->nExpr;\n  for(pItem=pList->a, i=0; i<n; i++, pItem++){\n    Expr *pExpr = pItem->pExpr;\n    int inReg = sqlite3ExprCodeTarget(pParse, pExpr, target+i);\n    if( inReg!=target+i ){\n      sqlite3VdbeAddOp2(pParse->pVdbe, doHardCopy ? OP_Copy : OP_SCopy,\n                        inReg, target+i);\n    }\n  }\n  return n;\n}\n\n/*\n** Generate code for a BETWEEN operator.\n**\n**    x BETWEEN y AND z\n**\n** The above is equivalent to \n**\n**    x>=y AND x<=z\n**\n** Code it as such, taking care to do the common subexpression\n** elementation of x.\n*/\nstatic void exprCodeBetween(\n  Parse *pParse,    /* Parsing and code generating context */\n  Expr *pExpr,      /* The BETWEEN expression */\n  int dest,         /* Jump here if the jump is taken */\n  int jumpIfTrue,   /* Take the jump if the BETWEEN is true */\n  int jumpIfNull    /* Take the jump if the BETWEEN is NULL */\n){\n  Expr exprAnd;     /* The AND operator in  x>=y AND x<=z  */\n  Expr compLeft;    /* The  x>=y  term */\n  Expr compRight;   /* The  x<=z  term */\n  Expr exprX;       /* The  x  subexpression */\n  int regFree1 = 0; /* Temporary use register */\n\n  assert( !ExprHasProperty(pExpr, EP_xIsSelect) );\n  exprX = *pExpr->pLeft;\n  exprAnd.op = TK_AND;\n  exprAnd.pLeft = &compLeft;\n  exprAnd.pRight = &compRight;\n  compLeft.op = TK_GE;\n  compLeft.pLeft = &exprX;\n  compLeft.pRight = pExpr->x.pList->a[0].pExpr;\n  compRight.op = TK_LE;\n  compRight.pLeft = &exprX;\n  compRight.pRight = pExpr->x.pList->a[1].pExpr;\n  exprX.iTable = sqlite3ExprCodeTemp(pParse, &exprX, &regFree1);\n  exprX.op = TK_REGISTER;\n  if( jumpIfTrue ){\n    sqlite3ExprIfTrue(pParse, &exprAnd, dest, jumpIfNull);\n  }else{\n    sqlite3ExprIfFalse(pParse, &exprAnd, dest, jumpIfNull);\n  }\n  sqlite3ReleaseTempReg(pParse, regFree1);\n\n  /* Ensure adequate test coverage */\n  testcase( jumpIfTrue==0 && jumpIfNull==0 && regFree1==0 );\n  testcase( jumpIfTrue==0 && jumpIfNull==0 && regFree1!=0 );\n  testcase( jumpIfTrue==0 && jumpIfNull!=0 && regFree1==0 );\n  testcase( jumpIfTrue==0 && jumpIfNull!=0 && regFree1!=0 );\n  testcase( jumpIfTrue!=0 && jumpIfNull==0 && regFree1==0 );\n  testcase( jumpIfTrue!=0 && jumpIfNull==0 && regFree1!=0 );\n  testcase( jumpIfTrue!=0 && jumpIfNull!=0 && regFree1==0 );\n  testcase( jumpIfTrue!=0 && jumpIfNull!=0 && regFree1!=0 );\n}\n\n/*\n** Generate code for a boolean expression such that a jump is made\n** to the label \"dest\" if the expression is true but execution\n** continues straight thru if the expression is false.\n**\n** If the expression evaluates to NULL (neither true nor false), then\n** take the jump if the jumpIfNull flag is SQLITE_JUMPIFNULL.\n**\n** This code depends on the fact that certain token values (ex: TK_EQ)\n** are the same as opcode values (ex: OP_Eq) that implement the corresponding\n** operation.  Special comments in vdbe.c and the mkopcodeh.awk script in\n** the make process cause these values to align.  Assert()s in the code\n** below verify that the numbers are aligned correctly.\n*/\nSQLITE_PRIVATE void sqlite3ExprIfTrue(Parse *pParse, Expr *pExpr, int dest, int jumpIfNull){\n  Vdbe *v = pParse->pVdbe;\n  int op = 0;\n  int regFree1 = 0;\n  int regFree2 = 0;\n  int r1, r2;\n\n  assert( jumpIfNull==SQLITE_JUMPIFNULL || jumpIfNull==0 );\n  if( NEVER(v==0) )     return;  /* Existance of VDBE checked by caller */\n  if( NEVER(pExpr==0) ) return;  /* No way this can happen */\n  op = pExpr->op;\n  switch( op ){\n    case TK_AND: {\n      int d2 = sqlite3VdbeMakeLabel(v);\n      testcase( jumpIfNull==0 );\n      sqlite3ExprCachePush(pParse);\n      sqlite3ExprIfFalse(pParse, pExpr->pLeft, d2,jumpIfNull^SQLITE_JUMPIFNULL);\n      sqlite3ExprIfTrue(pParse, pExpr->pRight, dest, jumpIfNull);\n      sqlite3VdbeResolveLabel(v, d2);\n      sqlite3ExprCachePop(pParse, 1);\n      break;\n    }\n    case TK_OR: {\n      testcase( jumpIfNull==0 );\n      sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest, jumpIfNull);\n      sqlite3ExprIfTrue(pParse, pExpr->pRight, dest, jumpIfNull);\n      break;\n    }\n    case TK_NOT: {\n      testcase( jumpIfNull==0 );\n      sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest, jumpIfNull);\n      break;\n    }\n    case TK_LT:\n    case TK_LE:\n    case TK_GT:\n    case TK_GE:\n    case TK_NE:\n    case TK_EQ: {\n      assert( TK_LT==OP_Lt );\n      assert( TK_LE==OP_Le );\n      assert( TK_GT==OP_Gt );\n      assert( TK_GE==OP_Ge );\n      assert( TK_EQ==OP_Eq );\n      assert( TK_NE==OP_Ne );\n      testcase( op==TK_LT );\n      testcase( op==TK_LE );\n      testcase( op==TK_GT );\n      testcase( op==TK_GE );\n      testcase( op==TK_EQ );\n      testcase( op==TK_NE );\n      testcase( jumpIfNull==0 );\n      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n      r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);\n      codeCompare(pParse, pExpr->pLeft, pExpr->pRight, op,\n                  r1, r2, dest, jumpIfNull);\n      testcase( regFree1==0 );\n      testcase( regFree2==0 );\n      break;\n    }\n    case TK_IS:\n    case TK_ISNOT: {\n      testcase( op==TK_IS );\n      testcase( op==TK_ISNOT );\n      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n      r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);\n      op = (op==TK_IS) ? TK_EQ : TK_NE;\n      codeCompare(pParse, pExpr->pLeft, pExpr->pRight, op,\n                  r1, r2, dest, SQLITE_NULLEQ);\n      testcase( regFree1==0 );\n      testcase( regFree2==0 );\n      break;\n    }\n    case TK_ISNULL:\n    case TK_NOTNULL: {\n      assert( TK_ISNULL==OP_IsNull );\n      assert( TK_NOTNULL==OP_NotNull );\n      testcase( op==TK_ISNULL );\n      testcase( op==TK_NOTNULL );\n      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n      sqlite3VdbeAddOp2(v, op, r1, dest);\n      testcase( regFree1==0 );\n      break;\n    }\n    case TK_BETWEEN: {\n      testcase( jumpIfNull==0 );\n      exprCodeBetween(pParse, pExpr, dest, 1, jumpIfNull);\n      break;\n    }\n#ifndef SQLITE_OMIT_SUBQUERY\n    case TK_IN: {\n      int destIfFalse = sqlite3VdbeMakeLabel(v);\n      int destIfNull = jumpIfNull ? dest : destIfFalse;\n      sqlite3ExprCodeIN(pParse, pExpr, destIfFalse, destIfNull);\n      sqlite3VdbeAddOp2(v, OP_Goto, 0, dest);\n      sqlite3VdbeResolveLabel(v, destIfFalse);\n      break;\n    }\n#endif\n    default: {\n      r1 = sqlite3ExprCodeTemp(pParse, pExpr, &regFree1);\n      sqlite3VdbeAddOp3(v, OP_If, r1, dest, jumpIfNull!=0);\n      testcase( regFree1==0 );\n      testcase( jumpIfNull==0 );\n      break;\n    }\n  }\n  sqlite3ReleaseTempReg(pParse, regFree1);\n  sqlite3ReleaseTempReg(pParse, regFree2);  \n}\n\n/*\n** Generate code for a boolean expression such that a jump is made\n** to the label \"dest\" if the expression is false but execution\n** continues straight thru if the expression is true.\n**\n** If the expression evaluates to NULL (neither true nor false) then\n** jump if jumpIfNull is SQLITE_JUMPIFNULL or fall through if jumpIfNull\n** is 0.\n*/\nSQLITE_PRIVATE void sqlite3ExprIfFalse(Parse *pParse, Expr *pExpr, int dest, int jumpIfNull){\n  Vdbe *v = pParse->pVdbe;\n  int op = 0;\n  int regFree1 = 0;\n  int regFree2 = 0;\n  int r1, r2;\n\n  assert( jumpIfNull==SQLITE_JUMPIFNULL || jumpIfNull==0 );\n  if( NEVER(v==0) ) return; /* Existance of VDBE checked by caller */\n  if( pExpr==0 )    return;\n\n  /* The value of pExpr->op and op are related as follows:\n  **\n  **       pExpr->op            op\n  **       ---------          ----------\n  **       TK_ISNULL          OP_NotNull\n  **       TK_NOTNULL         OP_IsNull\n  **       TK_NE              OP_Eq\n  **       TK_EQ              OP_Ne\n  **       TK_GT              OP_Le\n  **       TK_LE              OP_Gt\n  **       TK_GE              OP_Lt\n  **       TK_LT              OP_Ge\n  **\n  ** For other values of pExpr->op, op is undefined and unused.\n  ** The value of TK_ and OP_ constants are arranged such that we\n  ** can compute the mapping above using the following expression.\n  ** Assert()s verify that the computation is correct.\n  */\n  op = ((pExpr->op+(TK_ISNULL&1))^1)-(TK_ISNULL&1);\n\n  /* Verify correct alignment of TK_ and OP_ constants\n  */\n  assert( pExpr->op!=TK_ISNULL || op==OP_NotNull );\n  assert( pExpr->op!=TK_NOTNULL || op==OP_IsNull );\n  assert( pExpr->op!=TK_NE || op==OP_Eq );\n  assert( pExpr->op!=TK_EQ || op==OP_Ne );\n  assert( pExpr->op!=TK_LT || op==OP_Ge );\n  assert( pExpr->op!=TK_LE || op==OP_Gt );\n  assert( pExpr->op!=TK_GT || op==OP_Le );\n  assert( pExpr->op!=TK_GE || op==OP_Lt );\n\n  switch( pExpr->op ){\n    case TK_AND: {\n      testcase( jumpIfNull==0 );\n      sqlite3ExprIfFalse(pParse, pExpr->pLeft, dest, jumpIfNull);\n      sqlite3ExprIfFalse(pParse, pExpr->pRight, dest, jumpIfNull);\n      break;\n    }\n    case TK_OR: {\n      int d2 = sqlite3VdbeMakeLabel(v);\n      testcase( jumpIfNull==0 );\n      sqlite3ExprCachePush(pParse);\n      sqlite3ExprIfTrue(pParse, pExpr->pLeft, d2, jumpIfNull^SQLITE_JUMPIFNULL);\n      sqlite3ExprIfFalse(pParse, pExpr->pRight, dest, jumpIfNull);\n      sqlite3VdbeResolveLabel(v, d2);\n      sqlite3ExprCachePop(pParse, 1);\n      break;\n    }\n    case TK_NOT: {\n      testcase( jumpIfNull==0 );\n      sqlite3ExprIfTrue(pParse, pExpr->pLeft, dest, jumpIfNull);\n      break;\n    }\n    case TK_LT:\n    case TK_LE:\n    case TK_GT:\n    case TK_GE:\n    case TK_NE:\n    case TK_EQ: {\n      testcase( op==TK_LT );\n      testcase( op==TK_LE );\n      testcase( op==TK_GT );\n      testcase( op==TK_GE );\n      testcase( op==TK_EQ );\n      testcase( op==TK_NE );\n      testcase( jumpIfNull==0 );\n      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n      r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);\n      codeCompare(pParse, pExpr->pLeft, pExpr->pRight, op,\n                  r1, r2, dest, jumpIfNull);\n      testcase( regFree1==0 );\n      testcase( regFree2==0 );\n      break;\n    }\n    case TK_IS:\n    case TK_ISNOT: {\n      testcase( pExpr->op==TK_IS );\n      testcase( pExpr->op==TK_ISNOT );\n      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n      r2 = sqlite3ExprCodeTemp(pParse, pExpr->pRight, &regFree2);\n      op = (pExpr->op==TK_IS) ? TK_NE : TK_EQ;\n      codeCompare(pParse, pExpr->pLeft, pExpr->pRight, op,\n                  r1, r2, dest, SQLITE_NULLEQ);\n      testcase( regFree1==0 );\n      testcase( regFree2==0 );\n      break;\n    }\n    case TK_ISNULL:\n    case TK_NOTNULL: {\n      testcase( op==TK_ISNULL );\n      testcase( op==TK_NOTNULL );\n      r1 = sqlite3ExprCodeTemp(pParse, pExpr->pLeft, &regFree1);\n      sqlite3VdbeAddOp2(v, op, r1, dest);\n      testcase( regFree1==0 );\n      break;\n    }\n    case TK_BETWEEN: {\n      testcase( jumpIfNull==0 );\n      exprCodeBetween(pParse, pExpr, dest, 0, jumpIfNull);\n      break;\n    }\n#ifndef SQLITE_OMIT_SUBQUERY\n    case TK_IN: {\n      if( jumpIfNull ){\n        sqlite3ExprCodeIN(pParse, pExpr, dest, dest);\n      }else{\n        int destIfNull = sqlite3VdbeMakeLabel(v);\n        sqlite3ExprCodeIN(pParse, pExpr, dest, destIfNull);\n        sqlite3VdbeResolveLabel(v, destIfNull);\n      }\n      break;\n    }\n#endif\n    default: {\n      r1 = sqlite3ExprCodeTemp(pParse, pExpr, &regFree1);\n      sqlite3VdbeAddOp3(v, OP_IfNot, r1, dest, jumpIfNull!=0);\n      testcase( regFree1==0 );\n      testcase( jumpIfNull==0 );\n      break;\n    }\n  }\n  sqlite3ReleaseTempReg(pParse, regFree1);\n  sqlite3ReleaseTempReg(pParse, regFree2);\n}\n\n/*\n** Do a deep comparison of two expression trees.  Return 0 if the two\n** expressions are completely identical.  Return 1 if they differ only\n** by a COLLATE operator at the top level.  Return 2 if there are differences\n** other than the top-level COLLATE operator.\n**\n** Sometimes this routine will return 2 even if the two expressions\n** really are equivalent.  If we cannot prove that the expressions are\n** identical, we return 2 just to be safe.  So if this routine\n** returns 2, then you do not really know for certain if the two\n** expressions are the same.  But if you get a 0 or 1 return, then you\n** can be sure the expressions are the same.  In the places where\n** this routine is used, it does not hurt to get an extra 2 - that\n** just might result in some slightly slower code.  But returning\n** an incorrect 0 or 1 could lead to a malfunction.\n*/\nSQLITE_PRIVATE int sqlite3ExprCompare(Expr *pA, Expr *pB){\n  if( pA==0||pB==0 ){\n    return pB==pA ? 0 : 2;\n  }\n  assert( !ExprHasAnyProperty(pA, EP_TokenOnly|EP_Reduced) );\n  assert( !ExprHasAnyProperty(pB, EP_TokenOnly|EP_Reduced) );\n  if( ExprHasProperty(pA, EP_xIsSelect) || ExprHasProperty(pB, EP_xIsSelect) ){\n    return 2;\n  }\n  if( (pA->flags & EP_Distinct)!=(pB->flags & EP_Distinct) ) return 2;\n  if( pA->op!=pB->op ) return 2;\n  if( sqlite3ExprCompare(pA->pLeft, pB->pLeft) ) return 2;\n  if( sqlite3ExprCompare(pA->pRight, pB->pRight) ) return 2;\n  if( sqlite3ExprListCompare(pA->x.pList, pB->x.pList) ) return 2;\n  if( pA->iTable!=pB->iTable || pA->iColumn!=pB->iColumn ) return 2;\n  if( ExprHasProperty(pA, EP_IntValue) ){\n    if( !ExprHasProperty(pB, EP_IntValue) || pA->u.iValue!=pB->u.iValue ){\n      return 2;\n    }\n  }else if( pA->op!=TK_COLUMN && pA->u.zToken ){\n    if( ExprHasProperty(pB, EP_IntValue) || NEVER(pB->u.zToken==0) ) return 2;\n    if( sqlite3StrICmp(pA->u.zToken,pB->u.zToken)!=0 ){\n      return 2;\n    }\n  }\n  if( (pA->flags & EP_ExpCollate)!=(pB->flags & EP_ExpCollate) ) return 1;\n  if( (pA->flags & EP_ExpCollate)!=0 && pA->pColl!=pB->pColl ) return 2;\n  return 0;\n}\n\n/*\n** Compare two ExprList objects.  Return 0 if they are identical and \n** non-zero if they differ in any way.\n**\n** This routine might return non-zero for equivalent ExprLists.  The\n** only consequence will be disabled optimizations.  But this routine\n** must never return 0 if the two ExprList objects are different, or\n** a malfunction will result.\n**\n** Two NULL pointers are considered to be the same.  But a NULL pointer\n** always differs from a non-NULL pointer.\n*/\nSQLITE_PRIVATE int sqlite3ExprListCompare(ExprList *pA, ExprList *pB){\n  int i;\n  if( pA==0 && pB==0 ) return 0;\n  if( pA==0 || pB==0 ) return 1;\n  if( pA->nExpr!=pB->nExpr ) return 1;\n  for(i=0; i<pA->nExpr; i++){\n    Expr *pExprA = pA->a[i].pExpr;\n    Expr *pExprB = pB->a[i].pExpr;\n    if( pA->a[i].sortOrder!=pB->a[i].sortOrder ) return 1;\n    if( sqlite3ExprCompare(pExprA, pExprB) ) return 1;\n  }\n  return 0;\n}\n\n/*\n** Add a new element to the pAggInfo->aCol[] array.  Return the index of\n** the new element.  Return a negative number if malloc fails.\n*/\nstatic int addAggInfoColumn(sqlite3 *db, AggInfo *pInfo){\n  int i;\n  pInfo->aCol = sqlite3ArrayAllocate(\n       db,\n       pInfo->aCol,\n       sizeof(pInfo->aCol[0]),\n       3,\n       &pInfo->nColumn,\n       &pInfo->nColumnAlloc,\n       &i\n  );\n  return i;\n}    \n\n/*\n** Add a new element to the pAggInfo->aFunc[] array.  Return the index of\n** the new element.  Return a negative number if malloc fails.\n*/\nstatic int addAggInfoFunc(sqlite3 *db, AggInfo *pInfo){\n  int i;\n  pInfo->aFunc = sqlite3ArrayAllocate(\n       db, \n       pInfo->aFunc,\n       sizeof(pInfo->aFunc[0]),\n       3,\n       &pInfo->nFunc,\n       &pInfo->nFuncAlloc,\n       &i\n  );\n  return i;\n}    \n\n/*\n** This is the xExprCallback for a tree walker.  It is used to\n** implement sqlite3ExprAnalyzeAggregates().  See sqlite3ExprAnalyzeAggregates\n** for additional information.\n*/\nstatic int analyzeAggregate(Walker *pWalker, Expr *pExpr){\n  int i;\n  NameContext *pNC = pWalker->u.pNC;\n  Parse *pParse = pNC->pParse;\n  SrcList *pSrcList = pNC->pSrcList;\n  AggInfo *pAggInfo = pNC->pAggInfo;\n\n  switch( pExpr->op ){\n    case TK_AGG_COLUMN:\n    case TK_COLUMN: {\n      testcase( pExpr->op==TK_AGG_COLUMN );\n      testcase( pExpr->op==TK_COLUMN );\n      /* Check to see if the column is in one of the tables in the FROM\n      ** clause of the aggregate query */\n      if( ALWAYS(pSrcList!=0) ){\n        struct SrcList_item *pItem = pSrcList->a;\n        for(i=0; i<pSrcList->nSrc; i++, pItem++){\n          struct AggInfo_col *pCol;\n          assert( !ExprHasAnyProperty(pExpr, EP_TokenOnly|EP_Reduced) );\n          if( pExpr->iTable==pItem->iCursor ){\n            /* If we reach this point, it means that pExpr refers to a table\n            ** that is in the FROM clause of the aggregate query.  \n            **\n            ** Make an entry for the column in pAggInfo->aCol[] if there\n            ** is not an entry there already.\n            */\n            int k;\n            pCol = pAggInfo->aCol;\n            for(k=0; k<pAggInfo->nColumn; k++, pCol++){\n              if( pCol->iTable==pExpr->iTable &&\n                  pCol->iColumn==pExpr->iColumn ){\n                break;\n              }\n            }\n            if( (k>=pAggInfo->nColumn)\n             && (k = addAggInfoColumn(pParse->db, pAggInfo))>=0 \n            ){\n              pCol = &pAggInfo->aCol[k];\n              pCol->pTab = pExpr->pTab;\n              pCol->iTable = pExpr->iTable;\n              pCol->iColumn = pExpr->iColumn;\n              pCol->iMem = ++pParse->nMem;\n              pCol->iSorterColumn = -1;\n              pCol->pExpr = pExpr;\n              if( pAggInfo->pGroupBy ){\n                int j, n;\n                ExprList *pGB = pAggInfo->pGroupBy;\n                struct ExprList_item *pTerm = pGB->a;\n                n = pGB->nExpr;\n                for(j=0; j<n; j++, pTerm++){\n                  Expr *pE = pTerm->pExpr;\n                  if( pE->op==TK_COLUMN && pE->iTable==pExpr->iTable &&\n                      pE->iColumn==pExpr->iColumn ){\n                    pCol->iSorterColumn = j;\n                    break;\n                  }\n                }\n              }\n              if( pCol->iSorterColumn<0 ){\n                pCol->iSorterColumn = pAggInfo->nSortingColumn++;\n              }\n            }\n            /* There is now an entry for pExpr in pAggInfo->aCol[] (either\n            ** because it was there before or because we just created it).\n            ** Convert the pExpr to be a TK_AGG_COLUMN referring to that\n            ** pAggInfo->aCol[] entry.\n            */\n            ExprSetIrreducible(pExpr);\n            pExpr->pAggInfo = pAggInfo;\n            pExpr->op = TK_AGG_COLUMN;\n            pExpr->iAgg = (i16)k;\n            break;\n          } /* endif pExpr->iTable==pItem->iCursor */\n        } /* end loop over pSrcList */\n      }\n      return WRC_Prune;\n    }\n    case TK_AGG_FUNCTION: {\n      /* The pNC->nDepth==0 test causes aggregate functions in subqueries\n      ** to be ignored */\n      if( pNC->nDepth==0 ){\n        /* Check to see if pExpr is a duplicate of another aggregate \n        ** function that is already in the pAggInfo structure\n        */\n        struct AggInfo_func *pItem = pAggInfo->aFunc;\n        for(i=0; i<pAggInfo->nFunc; i++, pItem++){\n          if( sqlite3ExprCompare(pItem->pExpr, pExpr)==0 ){\n            break;\n          }\n        }\n        if( i>=pAggInfo->nFunc ){\n          /* pExpr is original.  Make a new entry in pAggInfo->aFunc[]\n          */\n          u8 enc = ENC(pParse->db);\n          i = addAggInfoFunc(pParse->db, pAggInfo);\n          if( i>=0 ){\n            assert( !ExprHasProperty(pExpr, EP_xIsSelect) );\n            pItem = &pAggInfo->aFunc[i];\n            pItem->pExpr = pExpr;\n            pItem->iMem = ++pParse->nMem;\n            assert( !ExprHasProperty(pExpr, EP_IntValue) );\n            pItem->pFunc = sqlite3FindFunction(pParse->db,\n                   pExpr->u.zToken, sqlite3Strlen30(pExpr->u.zToken),\n                   pExpr->x.pList ? pExpr->x.pList->nExpr : 0, enc, 0);\n            if( pExpr->flags & EP_Distinct ){\n              pItem->iDistinct = pParse->nTab++;\n            }else{\n              pItem->iDistinct = -1;\n            }\n          }\n        }\n        /* Make pExpr point to the appropriate pAggInfo->aFunc[] entry\n        */\n        assert( !ExprHasAnyProperty(pExpr, EP_TokenOnly|EP_Reduced) );\n        ExprSetIrreducible(pExpr);\n        pExpr->iAgg = (i16)i;\n        pExpr->pAggInfo = pAggInfo;\n        return WRC_Prune;\n      }\n    }\n  }\n  return WRC_Continue;\n}\nstatic int analyzeAggregatesInSelect(Walker *pWalker, Select *pSelect){\n  NameContext *pNC = pWalker->u.pNC;\n  if( pNC->nDepth==0 ){\n    pNC->nDepth++;\n    sqlite3WalkSelect(pWalker, pSelect);\n    pNC->nDepth--;\n    return WRC_Prune;\n  }else{\n    return WRC_Continue;\n  }\n}\n\n/*\n** Analyze the given expression looking for aggregate functions and\n** for variables that need to be added to the pParse->aAgg[] array.\n** Make additional entries to the pParse->aAgg[] array as necessary.\n**\n** This routine should only be called after the expression has been\n** analyzed by sqlite3ResolveExprNames().\n*/\nSQLITE_PRIVATE void sqlite3ExprAnalyzeAggregates(NameContext *pNC, Expr *pExpr){\n  Walker w;\n  w.xExprCallback = analyzeAggregate;\n  w.xSelectCallback = analyzeAggregatesInSelect;\n  w.u.pNC = pNC;\n  assert( pNC->pSrcList!=0 );\n  sqlite3WalkExpr(&w, pExpr);\n}\n\n/*\n** Call sqlite3ExprAnalyzeAggregates() for every expression in an\n** expression list.  Return the number of errors.\n**\n** If an error is found, the analysis is cut short.\n*/\nSQLITE_PRIVATE void sqlite3ExprAnalyzeAggList(NameContext *pNC, ExprList *pList){\n  struct ExprList_item *pItem;\n  int i;\n  if( pList ){\n    for(pItem=pList->a, i=0; i<pList->nExpr; i++, pItem++){\n      sqlite3ExprAnalyzeAggregates(pNC, pItem->pExpr);\n    }\n  }\n}\n\n/*\n** Allocate a single new register for use to hold some intermediate result.\n*/\nSQLITE_PRIVATE int sqlite3GetTempReg(Parse *pParse){\n  if( pParse->nTempReg==0 ){\n    return ++pParse->nMem;\n  }\n  return pParse->aTempReg[--pParse->nTempReg];\n}\n\n/*\n** Deallocate a register, making available for reuse for some other\n** purpose.\n**\n** If a register is currently being used by the column cache, then\n** the dallocation is deferred until the column cache line that uses\n** the register becomes stale.\n*/\nSQLITE_PRIVATE void sqlite3ReleaseTempReg(Parse *pParse, int iReg){\n  if( iReg && pParse->nTempReg<ArraySize(pParse->aTempReg) ){\n    int i;\n    struct yColCache *p;\n    for(i=0, p=pParse->aColCache; i<SQLITE_N_COLCACHE; i++, p++){\n      if( p->iReg==iReg ){\n        p->tempReg = 1;\n        return;\n      }\n    }\n    pParse->aTempReg[pParse->nTempReg++] = iReg;\n  }\n}\n\n/*\n** Allocate or deallocate a block of nReg consecutive registers\n*/\nSQLITE_PRIVATE int sqlite3GetTempRange(Parse *pParse, int nReg){\n  int i, n;\n  i = pParse->iRangeReg;\n  n = pParse->nRangeReg;\n  if( nReg<=n ){\n    assert( !usedAsColumnCache(pParse, i, i+n-1) );\n    pParse->iRangeReg += nReg;\n    pParse->nRangeReg -= nReg;\n  }else{\n    i = pParse->nMem+1;\n    pParse->nMem += nReg;\n  }\n  return i;\n}\nSQLITE_PRIVATE void sqlite3ReleaseTempRange(Parse *pParse, int iReg, int nReg){\n  sqlite3ExprCacheRemove(pParse, iReg, nReg);\n  if( nReg>pParse->nRangeReg ){\n    pParse->nRangeReg = nReg;\n    pParse->iRangeReg = iReg;\n  }\n}\n\n/************** End of expr.c ************************************************/\n/************** Begin file alter.c *******************************************/\n/*\n** 2005 February 15\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains C code routines that used to generate VDBE code\n** that implements the ALTER TABLE command.\n*/\n\n/*\n** The code in this file only exists if we are not omitting the\n** ALTER TABLE logic from the build.\n*/\n#ifndef SQLITE_OMIT_ALTERTABLE\n\n\n/*\n** This function is used by SQL generated to implement the \n** ALTER TABLE command. The first argument is the text of a CREATE TABLE or\n** CREATE INDEX command. The second is a table name. The table name in \n** the CREATE TABLE or CREATE INDEX statement is replaced with the third\n** argument and the result returned. Examples:\n**\n** sqlite_rename_table('CREATE TABLE abc(a, b, c)', 'def')\n**     -> 'CREATE TABLE def(a, b, c)'\n**\n** sqlite_rename_table('CREATE INDEX i ON abc(a)', 'def')\n**     -> 'CREATE INDEX i ON def(a, b, c)'\n*/\nstatic void renameTableFunc(\n  sqlite3_context *context,\n  int NotUsed,\n  sqlite3_value **argv\n){\n  unsigned char const *zSql = sqlite3_value_text(argv[0]);\n  unsigned char const *zTableName = sqlite3_value_text(argv[1]);\n\n  int token;\n  Token tname;\n  unsigned char const *zCsr = zSql;\n  int len = 0;\n  char *zRet;\n\n  sqlite3 *db = sqlite3_context_db_handle(context);\n\n  UNUSED_PARAMETER(NotUsed);\n\n  /* The principle used to locate the table name in the CREATE TABLE \n  ** statement is that the table name is the first non-space token that\n  ** is immediately followed by a TK_LP or TK_USING token.\n  */\n  if( zSql ){\n    do {\n      if( !*zCsr ){\n        /* Ran out of input before finding an opening bracket. Return NULL. */\n        return;\n      }\n\n      /* Store the token that zCsr points to in tname. */\n      tname.z = (char*)zCsr;\n      tname.n = len;\n\n      /* Advance zCsr to the next token. Store that token type in 'token',\n      ** and its length in 'len' (to be used next iteration of this loop).\n      */\n      do {\n        zCsr += len;\n        len = sqlite3GetToken(zCsr, &token);\n      } while( token==TK_SPACE );\n      assert( len>0 );\n    } while( token!=TK_LP && token!=TK_USING );\n\n    zRet = sqlite3MPrintf(db, \"%.*s\\\"%w\\\"%s\", ((u8*)tname.z) - zSql, zSql, \n       zTableName, tname.z+tname.n);\n    sqlite3_result_text(context, zRet, -1, SQLITE_DYNAMIC);\n  }\n}\n\n/*\n** This C function implements an SQL user function that is used by SQL code\n** generated by the ALTER TABLE ... RENAME command to modify the definition\n** of any foreign key constraints that use the table being renamed as the \n** parent table. It is passed three arguments:\n**\n**   1) The complete text of the CREATE TABLE statement being modified,\n**   2) The old name of the table being renamed, and\n**   3) The new name of the table being renamed.\n**\n** It returns the new CREATE TABLE statement. For example:\n**\n**   sqlite_rename_parent('CREATE TABLE t1(a REFERENCES t2)', 't2', 't3')\n**       -> 'CREATE TABLE t1(a REFERENCES t3)'\n*/\n#ifndef SQLITE_OMIT_FOREIGN_KEY\nstatic void renameParentFunc(\n  sqlite3_context *context,\n  int NotUsed,\n  sqlite3_value **argv\n){\n  sqlite3 *db = sqlite3_context_db_handle(context);\n  char *zOutput = 0;\n  char *zResult;\n  unsigned char const *zInput = sqlite3_value_text(argv[0]);\n  unsigned char const *zOld = sqlite3_value_text(argv[1]);\n  unsigned char const *zNew = sqlite3_value_text(argv[2]);\n\n  unsigned const char *z;         /* Pointer to token */\n  int n;                          /* Length of token z */\n  int token;                      /* Type of token */\n\n  UNUSED_PARAMETER(NotUsed);\n  for(z=zInput; *z; z=z+n){\n    n = sqlite3GetToken(z, &token);\n    if( token==TK_REFERENCES ){\n      char *zParent;\n      do {\n        z += n;\n        n = sqlite3GetToken(z, &token);\n      }while( token==TK_SPACE );\n\n      zParent = sqlite3DbStrNDup(db, (const char *)z, n);\n      if( zParent==0 ) break;\n      sqlite3Dequote(zParent);\n      if( 0==sqlite3StrICmp((const char *)zOld, zParent) ){\n        char *zOut = sqlite3MPrintf(db, \"%s%.*s\\\"%w\\\"\", \n            (zOutput?zOutput:\"\"), z-zInput, zInput, (const char *)zNew\n        );\n        sqlite3DbFree(db, zOutput);\n        zOutput = zOut;\n        zInput = &z[n];\n      }\n      sqlite3DbFree(db, zParent);\n    }\n  }\n\n  zResult = sqlite3MPrintf(db, \"%s%s\", (zOutput?zOutput:\"\"), zInput), \n  sqlite3_result_text(context, zResult, -1, SQLITE_DYNAMIC);\n  sqlite3DbFree(db, zOutput);\n}\n#endif\n\n#ifndef SQLITE_OMIT_TRIGGER\n/* This function is used by SQL generated to implement the\n** ALTER TABLE command. The first argument is the text of a CREATE TRIGGER \n** statement. The second is a table name. The table name in the CREATE \n** TRIGGER statement is replaced with the third argument and the result \n** returned. This is analagous to renameTableFunc() above, except for CREATE\n** TRIGGER, not CREATE INDEX and CREATE TABLE.\n*/\nstatic void renameTriggerFunc(\n  sqlite3_context *context,\n  int NotUsed,\n  sqlite3_value **argv\n){\n  unsigned char const *zSql = sqlite3_value_text(argv[0]);\n  unsigned char const *zTableName = sqlite3_value_text(argv[1]);\n\n  int token;\n  Token tname;\n  int dist = 3;\n  unsigned char const *zCsr = zSql;\n  int len = 0;\n  char *zRet;\n  sqlite3 *db = sqlite3_context_db_handle(context);\n\n  UNUSED_PARAMETER(NotUsed);\n\n  /* The principle used to locate the table name in the CREATE TRIGGER \n  ** statement is that the table name is the first token that is immediatedly\n  ** preceded by either TK_ON or TK_DOT and immediatedly followed by one\n  ** of TK_WHEN, TK_BEGIN or TK_FOR.\n  */\n  if( zSql ){\n    do {\n\n      if( !*zCsr ){\n        /* Ran out of input before finding the table name. Return NULL. */\n        return;\n      }\n\n      /* Store the token that zCsr points to in tname. */\n      tname.z = (char*)zCsr;\n      tname.n = len;\n\n      /* Advance zCsr to the next token. Store that token type in 'token',\n      ** and its length in 'len' (to be used next iteration of this loop).\n      */\n      do {\n        zCsr += len;\n        len = sqlite3GetToken(zCsr, &token);\n      }while( token==TK_SPACE );\n      assert( len>0 );\n\n      /* Variable 'dist' stores the number of tokens read since the most\n      ** recent TK_DOT or TK_ON. This means that when a WHEN, FOR or BEGIN \n      ** token is read and 'dist' equals 2, the condition stated above\n      ** to be met.\n      **\n      ** Note that ON cannot be a database, table or column name, so\n      ** there is no need to worry about syntax like \n      ** \"CREATE TRIGGER ... ON ON.ON BEGIN ...\" etc.\n      */\n      dist++;\n      if( token==TK_DOT || token==TK_ON ){\n        dist = 0;\n      }\n    } while( dist!=2 || (token!=TK_WHEN && token!=TK_FOR && token!=TK_BEGIN) );\n\n    /* Variable tname now contains the token that is the old table-name\n    ** in the CREATE TRIGGER statement.\n    */\n    zRet = sqlite3MPrintf(db, \"%.*s\\\"%w\\\"%s\", ((u8*)tname.z) - zSql, zSql, \n       zTableName, tname.z+tname.n);\n    sqlite3_result_text(context, zRet, -1, SQLITE_DYNAMIC);\n  }\n}\n#endif   /* !SQLITE_OMIT_TRIGGER */\n\n/*\n** Register built-in functions used to help implement ALTER TABLE\n*/\nSQLITE_PRIVATE void sqlite3AlterFunctions(void){\n  static SQLITE_WSD FuncDef aAlterTableFuncs[] = {\n    FUNCTION(sqlite_rename_table,   2, 0, 0, renameTableFunc),\n#ifndef SQLITE_OMIT_TRIGGER\n    FUNCTION(sqlite_rename_trigger, 2, 0, 0, renameTriggerFunc),\n#endif\n#ifndef SQLITE_OMIT_FOREIGN_KEY\n    FUNCTION(sqlite_rename_parent,  3, 0, 0, renameParentFunc),\n#endif\n  };\n  int i;\n  FuncDefHash *pHash = &GLOBAL(FuncDefHash, sqlite3GlobalFunctions);\n  FuncDef *aFunc = (FuncDef*)&GLOBAL(FuncDef, aAlterTableFuncs);\n\n  for(i=0; i<ArraySize(aAlterTableFuncs); i++){\n    sqlite3FuncDefInsert(pHash, &aFunc[i]);\n  }\n}\n\n/*\n** This function is used to create the text of expressions of the form:\n**\n**   name=<constant1> OR name=<constant2> OR ...\n**\n** If argument zWhere is NULL, then a pointer string containing the text \n** \"name=<constant>\" is returned, where <constant> is the quoted version\n** of the string passed as argument zConstant. The returned buffer is\n** allocated using sqlite3DbMalloc(). It is the responsibility of the\n** caller to ensure that it is eventually freed.\n**\n** If argument zWhere is not NULL, then the string returned is \n** \"<where> OR name=<constant>\", where <where> is the contents of zWhere.\n** In this case zWhere is passed to sqlite3DbFree() before returning.\n** \n*/\nstatic char *whereOrName(sqlite3 *db, char *zWhere, char *zConstant){\n  char *zNew;\n  if( !zWhere ){\n    zNew = sqlite3MPrintf(db, \"name=%Q\", zConstant);\n  }else{\n    zNew = sqlite3MPrintf(db, \"%s OR name=%Q\", zWhere, zConstant);\n    sqlite3DbFree(db, zWhere);\n  }\n  return zNew;\n}\n\n#if !defined(SQLITE_OMIT_FOREIGN_KEY) && !defined(SQLITE_OMIT_TRIGGER)\n/*\n** Generate the text of a WHERE expression which can be used to select all\n** tables that have foreign key constraints that refer to table pTab (i.e.\n** constraints for which pTab is the parent table) from the sqlite_master\n** table.\n*/\nstatic char *whereForeignKeys(Parse *pParse, Table *pTab){\n  FKey *p;\n  char *zWhere = 0;\n  for(p=sqlite3FkReferences(pTab); p; p=p->pNextTo){\n    zWhere = whereOrName(pParse->db, zWhere, p->pFrom->zName);\n  }\n  return zWhere;\n}\n#endif\n\n/*\n** Generate the text of a WHERE expression which can be used to select all\n** temporary triggers on table pTab from the sqlite_temp_master table. If\n** table pTab has no temporary triggers, or is itself stored in the \n** temporary database, NULL is returned.\n*/\nstatic char *whereTempTriggers(Parse *pParse, Table *pTab){\n  Trigger *pTrig;\n  char *zWhere = 0;\n  const Schema *pTempSchema = pParse->db->aDb[1].pSchema; /* Temp db schema */\n\n  /* If the table is not located in the temp-db (in which case NULL is \n  ** returned, loop through the tables list of triggers. For each trigger\n  ** that is not part of the temp-db schema, add a clause to the WHERE \n  ** expression being built up in zWhere.\n  */\n  if( pTab->pSchema!=pTempSchema ){\n    sqlite3 *db = pParse->db;\n    for(pTrig=sqlite3TriggerList(pParse, pTab); pTrig; pTrig=pTrig->pNext){\n      if( pTrig->pSchema==pTempSchema ){\n        zWhere = whereOrName(db, zWhere, pTrig->zName);\n      }\n    }\n  }\n  if( zWhere ){\n    char *zNew = sqlite3MPrintf(pParse->db, \"type='trigger' AND (%s)\", zWhere);\n    sqlite3DbFree(pParse->db, zWhere);\n    zWhere = zNew;\n  }\n  return zWhere;\n}\n\n/*\n** Generate code to drop and reload the internal representation of table\n** pTab from the database, including triggers and temporary triggers.\n** Argument zName is the name of the table in the database schema at\n** the time the generated code is executed. This can be different from\n** pTab->zName if this function is being called to code part of an \n** \"ALTER TABLE RENAME TO\" statement.\n*/\nstatic void reloadTableSchema(Parse *pParse, Table *pTab, const char *zName){\n  Vdbe *v;\n  char *zWhere;\n  int iDb;                   /* Index of database containing pTab */\n#ifndef SQLITE_OMIT_TRIGGER\n  Trigger *pTrig;\n#endif\n\n  v = sqlite3GetVdbe(pParse);\n  if( NEVER(v==0) ) return;\n  assert( sqlite3BtreeHoldsAllMutexes(pParse->db) );\n  iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);\n  assert( iDb>=0 );\n\n#ifndef SQLITE_OMIT_TRIGGER\n  /* Drop any table triggers from the internal schema. */\n  for(pTrig=sqlite3TriggerList(pParse, pTab); pTrig; pTrig=pTrig->pNext){\n    int iTrigDb = sqlite3SchemaToIndex(pParse->db, pTrig->pSchema);\n    assert( iTrigDb==iDb || iTrigDb==1 );\n    sqlite3VdbeAddOp4(v, OP_DropTrigger, iTrigDb, 0, 0, pTrig->zName, 0);\n  }\n#endif\n\n  /* Drop the table and index from the internal schema.  */\n  sqlite3VdbeAddOp4(v, OP_DropTable, iDb, 0, 0, pTab->zName, 0);\n\n  /* Reload the table, index and permanent trigger schemas. */\n  zWhere = sqlite3MPrintf(pParse->db, \"tbl_name=%Q\", zName);\n  if( !zWhere ) return;\n  sqlite3VdbeAddOp4(v, OP_ParseSchema, iDb, 0, 0, zWhere, P4_DYNAMIC);\n\n#ifndef SQLITE_OMIT_TRIGGER\n  /* Now, if the table is not stored in the temp database, reload any temp \n  ** triggers. Don't use IN(...) in case SQLITE_OMIT_SUBQUERY is defined. \n  */\n  if( (zWhere=whereTempTriggers(pParse, pTab))!=0 ){\n    sqlite3VdbeAddOp4(v, OP_ParseSchema, 1, 0, 0, zWhere, P4_DYNAMIC);\n  }\n#endif\n}\n\n/*\n** Generate code to implement the \"ALTER TABLE xxx RENAME TO yyy\" \n** command. \n*/\nSQLITE_PRIVATE void sqlite3AlterRenameTable(\n  Parse *pParse,            /* Parser context. */\n  SrcList *pSrc,            /* The table to rename. */\n  Token *pName              /* The new table name. */\n){\n  int iDb;                  /* Database that contains the table */\n  char *zDb;                /* Name of database iDb */\n  Table *pTab;              /* Table being renamed */\n  char *zName = 0;          /* NULL-terminated version of pName */ \n  sqlite3 *db = pParse->db; /* Database connection */\n  int nTabName;             /* Number of UTF-8 characters in zTabName */\n  const char *zTabName;     /* Original name of the table */\n  Vdbe *v;\n#ifndef SQLITE_OMIT_TRIGGER\n  char *zWhere = 0;         /* Where clause to locate temp triggers */\n#endif\n  VTable *pVTab = 0;        /* Non-zero if this is a v-tab with an xRename() */\n  int savedDbFlags;         /* Saved value of db->flags */\n\n  savedDbFlags = db->flags;  \n  if( NEVER(db->mallocFailed) ) goto exit_rename_table;\n  assert( pSrc->nSrc==1 );\n  assert( sqlite3BtreeHoldsAllMutexes(pParse->db) );\n\n  pTab = sqlite3LocateTable(pParse, 0, pSrc->a[0].zName, pSrc->a[0].zDatabase);\n  if( !pTab ) goto exit_rename_table;\n  iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);\n  zDb = db->aDb[iDb].zName;\n  db->flags |= SQLITE_PreferBuiltin;\n\n  /* Get a NULL terminated version of the new table name. */\n  zName = sqlite3NameFromToken(db, pName);\n  if( !zName ) goto exit_rename_table;\n\n  /* Check that a table or index named 'zName' does not already exist\n  ** in database iDb. If so, this is an error.\n  */\n  if( sqlite3FindTable(db, zName, zDb) || sqlite3FindIndex(db, zName, zDb) ){\n    sqlite3ErrorMsg(pParse, \n        \"there is already another table or index with this name: %s\", zName);\n    goto exit_rename_table;\n  }\n\n  /* Make sure it is not a system table being altered, or a reserved name\n  ** that the table is being renamed to.\n  */\n  if( sqlite3Strlen30(pTab->zName)>6 \n   && 0==sqlite3StrNICmp(pTab->zName, \"sqlite_\", 7)\n  ){\n    sqlite3ErrorMsg(pParse, \"table %s may not be altered\", pTab->zName);\n    goto exit_rename_table;\n  }\n  if( SQLITE_OK!=sqlite3CheckObjectName(pParse, zName) ){\n    goto exit_rename_table;\n  }\n\n#ifndef SQLITE_OMIT_VIEW\n  if( pTab->pSelect ){\n    sqlite3ErrorMsg(pParse, \"view %s may not be altered\", pTab->zName);\n    goto exit_rename_table;\n  }\n#endif\n\n#ifndef SQLITE_OMIT_AUTHORIZATION\n  /* Invoke the authorization callback. */\n  if( sqlite3AuthCheck(pParse, SQLITE_ALTER_TABLE, zDb, pTab->zName, 0) ){\n    goto exit_rename_table;\n  }\n#endif\n\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  if( sqlite3ViewGetColumnNames(pParse, pTab) ){\n    goto exit_rename_table;\n  }\n  if( IsVirtual(pTab) ){\n    pVTab = sqlite3GetVTable(db, pTab);\n    if( pVTab->pVtab->pModule->xRename==0 ){\n      pVTab = 0;\n    }\n  }\n#endif\n\n  /* Begin a transaction and code the VerifyCookie for database iDb. \n  ** Then modify the schema cookie (since the ALTER TABLE modifies the\n  ** schema). Open a statement transaction if the table is a virtual\n  ** table.\n  */\n  v = sqlite3GetVdbe(pParse);\n  if( v==0 ){\n    goto exit_rename_table;\n  }\n  sqlite3BeginWriteOperation(pParse, pVTab!=0, iDb);\n  sqlite3ChangeCookie(pParse, iDb);\n\n  /* If this is a virtual table, invoke the xRename() function if\n  ** one is defined. The xRename() callback will modify the names\n  ** of any resources used by the v-table implementation (including other\n  ** SQLite tables) that are identified by the name of the virtual table.\n  */\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  if( pVTab ){\n    int i = ++pParse->nMem;\n    sqlite3VdbeAddOp4(v, OP_String8, 0, i, 0, zName, 0);\n    sqlite3VdbeAddOp4(v, OP_VRename, i, 0, 0,(const char*)pVTab, P4_VTAB);\n    sqlite3MayAbort(pParse);\n  }\n#endif\n\n  /* figure out how many UTF-8 characters are in zName */\n  zTabName = pTab->zName;\n  nTabName = sqlite3Utf8CharLen(zTabName, -1);\n\n#if !defined(SQLITE_OMIT_FOREIGN_KEY) && !defined(SQLITE_OMIT_TRIGGER)\n  if( db->flags&SQLITE_ForeignKeys ){\n    /* If foreign-key support is enabled, rewrite the CREATE TABLE \n    ** statements corresponding to all child tables of foreign key constraints\n    ** for which the renamed table is the parent table.  */\n    if( (zWhere=whereForeignKeys(pParse, pTab))!=0 ){\n      sqlite3NestedParse(pParse, \n          \"UPDATE \\\"%w\\\".%s SET \"\n              \"sql = sqlite_rename_parent(sql, %Q, %Q) \"\n              \"WHERE %s;\", zDb, SCHEMA_TABLE(iDb), zTabName, zName, zWhere);\n      sqlite3DbFree(db, zWhere);\n    }\n  }\n#endif\n\n  /* Modify the sqlite_master table to use the new table name. */\n  sqlite3NestedParse(pParse,\n      \"UPDATE %Q.%s SET \"\n#ifdef SQLITE_OMIT_TRIGGER\n          \"sql = sqlite_rename_table(sql, %Q), \"\n#else\n          \"sql = CASE \"\n            \"WHEN type = 'trigger' THEN sqlite_rename_trigger(sql, %Q)\"\n            \"ELSE sqlite_rename_table(sql, %Q) END, \"\n#endif\n          \"tbl_name = %Q, \"\n          \"name = CASE \"\n            \"WHEN type='table' THEN %Q \"\n            \"WHEN name LIKE 'sqlite_autoindex%%' AND type='index' THEN \"\n             \"'sqlite_autoindex_' || %Q || substr(name,%d+18) \"\n            \"ELSE name END \"\n      \"WHERE tbl_name=%Q AND \"\n          \"(type='table' OR type='index' OR type='trigger');\", \n      zDb, SCHEMA_TABLE(iDb), zName, zName, zName, \n#ifndef SQLITE_OMIT_TRIGGER\n      zName,\n#endif\n      zName, nTabName, zTabName\n  );\n\n#ifndef SQLITE_OMIT_AUTOINCREMENT\n  /* If the sqlite_sequence table exists in this database, then update \n  ** it with the new table name.\n  */\n  if( sqlite3FindTable(db, \"sqlite_sequence\", zDb) ){\n    sqlite3NestedParse(pParse,\n        \"UPDATE \\\"%w\\\".sqlite_sequence set name = %Q WHERE name = %Q\",\n        zDb, zName, pTab->zName);\n  }\n#endif\n\n#ifndef SQLITE_OMIT_TRIGGER\n  /* If there are TEMP triggers on this table, modify the sqlite_temp_master\n  ** table. Don't do this if the table being ALTERed is itself located in\n  ** the temp database.\n  */\n  if( (zWhere=whereTempTriggers(pParse, pTab))!=0 ){\n    sqlite3NestedParse(pParse, \n        \"UPDATE sqlite_temp_master SET \"\n            \"sql = sqlite_rename_trigger(sql, %Q), \"\n            \"tbl_name = %Q \"\n            \"WHERE %s;\", zName, zName, zWhere);\n    sqlite3DbFree(db, zWhere);\n  }\n#endif\n\n#if !defined(SQLITE_OMIT_FOREIGN_KEY) && !defined(SQLITE_OMIT_TRIGGER)\n  if( db->flags&SQLITE_ForeignKeys ){\n    FKey *p;\n    for(p=sqlite3FkReferences(pTab); p; p=p->pNextTo){\n      Table *pFrom = p->pFrom;\n      if( pFrom!=pTab ){\n        reloadTableSchema(pParse, p->pFrom, pFrom->zName);\n      }\n    }\n  }\n#endif\n\n  /* Drop and reload the internal table schema. */\n  reloadTableSchema(pParse, pTab, zName);\n\nexit_rename_table:\n  sqlite3SrcListDelete(db, pSrc);\n  sqlite3DbFree(db, zName);\n  db->flags = savedDbFlags;\n}\n\n\n/*\n** Generate code to make sure the file format number is at least minFormat.\n** The generated code will increase the file format number if necessary.\n*/\nSQLITE_PRIVATE void sqlite3MinimumFileFormat(Parse *pParse, int iDb, int minFormat){\n  Vdbe *v;\n  v = sqlite3GetVdbe(pParse);\n  /* The VDBE should have been allocated before this routine is called.\n  ** If that allocation failed, we would have quit before reaching this\n  ** point */\n  if( ALWAYS(v) ){\n    int r1 = sqlite3GetTempReg(pParse);\n    int r2 = sqlite3GetTempReg(pParse);\n    int j1;\n    sqlite3VdbeAddOp3(v, OP_ReadCookie, iDb, r1, BTREE_FILE_FORMAT);\n    sqlite3VdbeUsesBtree(v, iDb);\n    sqlite3VdbeAddOp2(v, OP_Integer, minFormat, r2);\n    j1 = sqlite3VdbeAddOp3(v, OP_Ge, r2, 0, r1);\n    sqlite3VdbeAddOp3(v, OP_SetCookie, iDb, BTREE_FILE_FORMAT, r2);\n    sqlite3VdbeJumpHere(v, j1);\n    sqlite3ReleaseTempReg(pParse, r1);\n    sqlite3ReleaseTempReg(pParse, r2);\n  }\n}\n\n/*\n** This function is called after an \"ALTER TABLE ... ADD\" statement\n** has been parsed. Argument pColDef contains the text of the new\n** column definition.\n**\n** The Table structure pParse->pNewTable was extended to include\n** the new column during parsing.\n*/\nSQLITE_PRIVATE void sqlite3AlterFinishAddColumn(Parse *pParse, Token *pColDef){\n  Table *pNew;              /* Copy of pParse->pNewTable */\n  Table *pTab;              /* Table being altered */\n  int iDb;                  /* Database number */\n  const char *zDb;          /* Database name */\n  const char *zTab;         /* Table name */\n  char *zCol;               /* Null-terminated column definition */\n  Column *pCol;             /* The new column */\n  Expr *pDflt;              /* Default value for the new column */\n  sqlite3 *db;              /* The database connection; */\n\n  db = pParse->db;\n  if( pParse->nErr || db->mallocFailed ) return;\n  pNew = pParse->pNewTable;\n  assert( pNew );\n\n  assert( sqlite3BtreeHoldsAllMutexes(db) );\n  iDb = sqlite3SchemaToIndex(db, pNew->pSchema);\n  zDb = db->aDb[iDb].zName;\n  zTab = &pNew->zName[16];  /* Skip the \"sqlite_altertab_\" prefix on the name */\n  pCol = &pNew->aCol[pNew->nCol-1];\n  pDflt = pCol->pDflt;\n  pTab = sqlite3FindTable(db, zTab, zDb);\n  assert( pTab );\n\n#ifndef SQLITE_OMIT_AUTHORIZATION\n  /* Invoke the authorization callback. */\n  if( sqlite3AuthCheck(pParse, SQLITE_ALTER_TABLE, zDb, pTab->zName, 0) ){\n    return;\n  }\n#endif\n\n  /* If the default value for the new column was specified with a \n  ** literal NULL, then set pDflt to 0. This simplifies checking\n  ** for an SQL NULL default below.\n  */\n  if( pDflt && pDflt->op==TK_NULL ){\n    pDflt = 0;\n  }\n\n  /* Check that the new column is not specified as PRIMARY KEY or UNIQUE.\n  ** If there is a NOT NULL constraint, then the default value for the\n  ** column must not be NULL.\n  */\n  if( pCol->isPrimKey ){\n    sqlite3ErrorMsg(pParse, \"Cannot add a PRIMARY KEY column\");\n    return;\n  }\n  if( pNew->pIndex ){\n    sqlite3ErrorMsg(pParse, \"Cannot add a UNIQUE column\");\n    return;\n  }\n  if( (db->flags&SQLITE_ForeignKeys) && pNew->pFKey && pDflt ){\n    sqlite3ErrorMsg(pParse, \n        \"Cannot add a REFERENCES column with non-NULL default value\");\n    return;\n  }\n  if( pCol->notNull && !pDflt ){\n    sqlite3ErrorMsg(pParse, \n        \"Cannot add a NOT NULL column with default value NULL\");\n    return;\n  }\n\n  /* Ensure the default expression is something that sqlite3ValueFromExpr()\n  ** can handle (i.e. not CURRENT_TIME etc.)\n  */\n  if( pDflt ){\n    sqlite3_value *pVal;\n    if( sqlite3ValueFromExpr(db, pDflt, SQLITE_UTF8, SQLITE_AFF_NONE, &pVal) ){\n      db->mallocFailed = 1;\n      return;\n    }\n    if( !pVal ){\n      sqlite3ErrorMsg(pParse, \"Cannot add a column with non-constant default\");\n      return;\n    }\n    sqlite3ValueFree(pVal);\n  }\n\n  /* Modify the CREATE TABLE statement. */\n  zCol = sqlite3DbStrNDup(db, (char*)pColDef->z, pColDef->n);\n  if( zCol ){\n    char *zEnd = &zCol[pColDef->n-1];\n    int savedDbFlags = db->flags;\n    while( zEnd>zCol && (*zEnd==';' || sqlite3Isspace(*zEnd)) ){\n      *zEnd-- = '\\0';\n    }\n    db->flags |= SQLITE_PreferBuiltin;\n    sqlite3NestedParse(pParse, \n        \"UPDATE \\\"%w\\\".%s SET \"\n          \"sql = substr(sql,1,%d) || ', ' || %Q || substr(sql,%d) \"\n        \"WHERE type = 'table' AND name = %Q\", \n      zDb, SCHEMA_TABLE(iDb), pNew->addColOffset, zCol, pNew->addColOffset+1,\n      zTab\n    );\n    sqlite3DbFree(db, zCol);\n    db->flags = savedDbFlags;\n  }\n\n  /* If the default value of the new column is NULL, then set the file\n  ** format to 2. If the default value of the new column is not NULL,\n  ** the file format becomes 3.\n  */\n  sqlite3MinimumFileFormat(pParse, iDb, pDflt ? 3 : 2);\n\n  /* Reload the schema of the modified table. */\n  reloadTableSchema(pParse, pTab, pTab->zName);\n}\n\n/*\n** This function is called by the parser after the table-name in\n** an \"ALTER TABLE <table-name> ADD\" statement is parsed. Argument \n** pSrc is the full-name of the table being altered.\n**\n** This routine makes a (partial) copy of the Table structure\n** for the table being altered and sets Parse.pNewTable to point\n** to it. Routines called by the parser as the column definition\n** is parsed (i.e. sqlite3AddColumn()) add the new Column data to \n** the copy. The copy of the Table structure is deleted by tokenize.c \n** after parsing is finished.\n**\n** Routine sqlite3AlterFinishAddColumn() will be called to complete\n** coding the \"ALTER TABLE ... ADD\" statement.\n*/\nSQLITE_PRIVATE void sqlite3AlterBeginAddColumn(Parse *pParse, SrcList *pSrc){\n  Table *pNew;\n  Table *pTab;\n  Vdbe *v;\n  int iDb;\n  int i;\n  int nAlloc;\n  sqlite3 *db = pParse->db;\n\n  /* Look up the table being altered. */\n  assert( pParse->pNewTable==0 );\n  assert( sqlite3BtreeHoldsAllMutexes(db) );\n  if( db->mallocFailed ) goto exit_begin_add_column;\n  pTab = sqlite3LocateTable(pParse, 0, pSrc->a[0].zName, pSrc->a[0].zDatabase);\n  if( !pTab ) goto exit_begin_add_column;\n\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  if( IsVirtual(pTab) ){\n    sqlite3ErrorMsg(pParse, \"virtual tables may not be altered\");\n    goto exit_begin_add_column;\n  }\n#endif\n\n  /* Make sure this is not an attempt to ALTER a view. */\n  if( pTab->pSelect ){\n    sqlite3ErrorMsg(pParse, \"Cannot add a column to a view\");\n    goto exit_begin_add_column;\n  }\n\n  assert( pTab->addColOffset>0 );\n  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n\n  /* Put a copy of the Table struct in Parse.pNewTable for the\n  ** sqlite3AddColumn() function and friends to modify.  But modify\n  ** the name by adding an \"sqlite_altertab_\" prefix.  By adding this\n  ** prefix, we insure that the name will not collide with an existing\n  ** table because user table are not allowed to have the \"sqlite_\"\n  ** prefix on their name.\n  */\n  pNew = (Table*)sqlite3DbMallocZero(db, sizeof(Table));\n  if( !pNew ) goto exit_begin_add_column;\n  pParse->pNewTable = pNew;\n  pNew->nRef = 1;\n  pNew->nCol = pTab->nCol;\n  assert( pNew->nCol>0 );\n  nAlloc = (((pNew->nCol-1)/8)*8)+8;\n  assert( nAlloc>=pNew->nCol && nAlloc%8==0 && nAlloc-pNew->nCol<8 );\n  pNew->aCol = (Column*)sqlite3DbMallocZero(db, sizeof(Column)*nAlloc);\n  pNew->zName = sqlite3MPrintf(db, \"sqlite_altertab_%s\", pTab->zName);\n  if( !pNew->aCol || !pNew->zName ){\n    db->mallocFailed = 1;\n    goto exit_begin_add_column;\n  }\n  memcpy(pNew->aCol, pTab->aCol, sizeof(Column)*pNew->nCol);\n  for(i=0; i<pNew->nCol; i++){\n    Column *pCol = &pNew->aCol[i];\n    pCol->zName = sqlite3DbStrDup(db, pCol->zName);\n    pCol->zColl = 0;\n    pCol->zType = 0;\n    pCol->pDflt = 0;\n    pCol->zDflt = 0;\n  }\n  pNew->pSchema = db->aDb[iDb].pSchema;\n  pNew->addColOffset = pTab->addColOffset;\n  pNew->nRef = 1;\n\n  /* Begin a transaction and increment the schema cookie.  */\n  sqlite3BeginWriteOperation(pParse, 0, iDb);\n  v = sqlite3GetVdbe(pParse);\n  if( !v ) goto exit_begin_add_column;\n  sqlite3ChangeCookie(pParse, iDb);\n\nexit_begin_add_column:\n  sqlite3SrcListDelete(db, pSrc);\n  return;\n}\n#endif  /* SQLITE_ALTER_TABLE */\n\n/************** End of alter.c ***********************************************/\n/************** Begin file analyze.c *****************************************/\n/*\n** 2005 July 8\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains code associated with the ANALYZE command.\n*/\n#ifndef SQLITE_OMIT_ANALYZE\n\n/*\n** This routine generates code that opens the sqlite_stat1 table for\n** writing with cursor iStatCur. If the library was built with the\n** SQLITE_ENABLE_STAT2 macro defined, then the sqlite_stat2 table is\n** opened for writing using cursor (iStatCur+1)\n**\n** If the sqlite_stat1 tables does not previously exist, it is created.\n** Similarly, if the sqlite_stat2 table does not exist and the library\n** is compiled with SQLITE_ENABLE_STAT2 defined, it is created. \n**\n** Argument zWhere may be a pointer to a buffer containing a table name,\n** or it may be a NULL pointer. If it is not NULL, then all entries in\n** the sqlite_stat1 and (if applicable) sqlite_stat2 tables associated\n** with the named table are deleted. If zWhere==0, then code is generated\n** to delete all stat table entries.\n*/\nstatic void openStatTable(\n  Parse *pParse,          /* Parsing context */\n  int iDb,                /* The database we are looking in */\n  int iStatCur,           /* Open the sqlite_stat1 table on this cursor */\n  const char *zWhere      /* Delete entries associated with this table */\n){\n  static const struct {\n    const char *zName;\n    const char *zCols;\n  } aTable[] = {\n    { \"sqlite_stat1\", \"tbl,idx,stat\" },\n#ifdef SQLITE_ENABLE_STAT2\n    { \"sqlite_stat2\", \"tbl,idx,sampleno,sample\" },\n#endif\n  };\n\n  int aRoot[] = {0, 0};\n  u8 aCreateTbl[] = {0, 0};\n\n  int i;\n  sqlite3 *db = pParse->db;\n  Db *pDb;\n  Vdbe *v = sqlite3GetVdbe(pParse);\n  if( v==0 ) return;\n  assert( sqlite3BtreeHoldsAllMutexes(db) );\n  assert( sqlite3VdbeDb(v)==db );\n  pDb = &db->aDb[iDb];\n\n  for(i=0; i<ArraySize(aTable); i++){\n    const char *zTab = aTable[i].zName;\n    Table *pStat;\n    if( (pStat = sqlite3FindTable(db, zTab, pDb->zName))==0 ){\n      /* The sqlite_stat[12] table does not exist. Create it. Note that a \n      ** side-effect of the CREATE TABLE statement is to leave the rootpage \n      ** of the new table in register pParse->regRoot. This is important \n      ** because the OpenWrite opcode below will be needing it. */\n      sqlite3NestedParse(pParse,\n          \"CREATE TABLE %Q.%s(%s)\", pDb->zName, zTab, aTable[i].zCols\n      );\n      aRoot[i] = pParse->regRoot;\n      aCreateTbl[i] = 1;\n    }else{\n      /* The table already exists. If zWhere is not NULL, delete all entries \n      ** associated with the table zWhere. If zWhere is NULL, delete the\n      ** entire contents of the table. */\n      aRoot[i] = pStat->tnum;\n      sqlite3TableLock(pParse, iDb, aRoot[i], 1, zTab);\n      if( zWhere ){\n        sqlite3NestedParse(pParse,\n           \"DELETE FROM %Q.%s WHERE tbl=%Q\", pDb->zName, zTab, zWhere\n        );\n      }else{\n        /* The sqlite_stat[12] table already exists.  Delete all rows. */\n        sqlite3VdbeAddOp2(v, OP_Clear, aRoot[i], iDb);\n      }\n    }\n  }\n\n  /* Open the sqlite_stat[12] tables for writing. */\n  for(i=0; i<ArraySize(aTable); i++){\n    sqlite3VdbeAddOp3(v, OP_OpenWrite, iStatCur+i, aRoot[i], iDb);\n    sqlite3VdbeChangeP4(v, -1, (char *)3, P4_INT32);\n    sqlite3VdbeChangeP5(v, aCreateTbl[i]);\n  }\n}\n\n/*\n** Generate code to do an analysis of all indices associated with\n** a single table.\n*/\nstatic void analyzeOneTable(\n  Parse *pParse,   /* Parser context */\n  Table *pTab,     /* Table whose indices are to be analyzed */\n  int iStatCur,    /* Index of VdbeCursor that writes the sqlite_stat1 table */\n  int iMem         /* Available memory locations begin here */\n){\n  sqlite3 *db = pParse->db;    /* Database handle */\n  Index *pIdx;                 /* An index to being analyzed */\n  int iIdxCur;                 /* Cursor open on index being analyzed */\n  Vdbe *v;                     /* The virtual machine being built up */\n  int i;                       /* Loop counter */\n  int topOfLoop;               /* The top of the loop */\n  int endOfLoop;               /* The end of the loop */\n  int addr = 0;                /* The address of an instruction */\n  int jZeroRows = 0;           /* Jump from here if number of rows is zero */\n  int iDb;                     /* Index of database containing pTab */\n  int regTabname = iMem++;     /* Register containing table name */\n  int regIdxname = iMem++;     /* Register containing index name */\n  int regSampleno = iMem++;    /* Register containing next sample number */\n  int regCol = iMem++;         /* Content of a column analyzed table */\n  int regRec = iMem++;         /* Register holding completed record */\n  int regTemp = iMem++;        /* Temporary use register */\n  int regRowid = iMem++;       /* Rowid for the inserted record */\n\n#ifdef SQLITE_ENABLE_STAT2\n  int regTemp2 = iMem++;       /* Temporary use register */\n  int regSamplerecno = iMem++; /* Index of next sample to record */\n  int regRecno = iMem++;       /* Current sample index */\n  int regLast = iMem++;        /* Index of last sample to record */\n  int regFirst = iMem++;       /* Index of first sample to record */\n#endif\n\n  v = sqlite3GetVdbe(pParse);\n  if( v==0 || NEVER(pTab==0) ){\n    return;\n  }\n  if( pTab->tnum==0 ){\n    /* Do not gather statistics on views or virtual tables */\n    return;\n  }\n  if( memcmp(pTab->zName, \"sqlite_\", 7)==0 ){\n    /* Do not gather statistics on system tables */\n    return;\n  }\n  assert( sqlite3BtreeHoldsAllMutexes(db) );\n  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n  assert( iDb>=0 );\n#ifndef SQLITE_OMIT_AUTHORIZATION\n  if( sqlite3AuthCheck(pParse, SQLITE_ANALYZE, pTab->zName, 0,\n      db->aDb[iDb].zName ) ){\n    return;\n  }\n#endif\n\n  /* Establish a read-lock on the table at the shared-cache level. */\n  sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);\n\n  iIdxCur = pParse->nTab++;\n  sqlite3VdbeAddOp4(v, OP_String8, 0, regTabname, 0, pTab->zName, 0);\n  for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){\n    int nCol = pIdx->nColumn;\n    KeyInfo *pKey = sqlite3IndexKeyinfo(pParse, pIdx);\n\n    if( iMem+1+(nCol*2)>pParse->nMem ){\n      pParse->nMem = iMem+1+(nCol*2);\n    }\n\n    /* Open a cursor to the index to be analyzed. */\n    assert( iDb==sqlite3SchemaToIndex(db, pIdx->pSchema) );\n    sqlite3VdbeAddOp4(v, OP_OpenRead, iIdxCur, pIdx->tnum, iDb,\n        (char *)pKey, P4_KEYINFO_HANDOFF);\n    VdbeComment((v, \"%s\", pIdx->zName));\n\n    /* Populate the register containing the index name. */\n    sqlite3VdbeAddOp4(v, OP_String8, 0, regIdxname, 0, pIdx->zName, 0);\n\n#ifdef SQLITE_ENABLE_STAT2\n\n    /* If this iteration of the loop is generating code to analyze the\n    ** first index in the pTab->pIndex list, then register regLast has\n    ** not been populated. In this case populate it now.  */\n    if( pTab->pIndex==pIdx ){\n      sqlite3VdbeAddOp2(v, OP_Integer, SQLITE_INDEX_SAMPLES, regSamplerecno);\n      sqlite3VdbeAddOp2(v, OP_Integer, SQLITE_INDEX_SAMPLES*2-1, regTemp);\n      sqlite3VdbeAddOp2(v, OP_Integer, SQLITE_INDEX_SAMPLES*2, regTemp2);\n\n      sqlite3VdbeAddOp2(v, OP_Count, iIdxCur, regLast);\n      sqlite3VdbeAddOp2(v, OP_Null, 0, regFirst);\n      addr = sqlite3VdbeAddOp3(v, OP_Lt, regSamplerecno, 0, regLast);\n      sqlite3VdbeAddOp3(v, OP_Divide, regTemp2, regLast, regFirst);\n      sqlite3VdbeAddOp3(v, OP_Multiply, regLast, regTemp, regLast);\n      sqlite3VdbeAddOp2(v, OP_AddImm, regLast, SQLITE_INDEX_SAMPLES*2-2);\n      sqlite3VdbeAddOp3(v, OP_Divide,  regTemp2, regLast, regLast);\n      sqlite3VdbeJumpHere(v, addr);\n    }\n\n    /* Zero the regSampleno and regRecno registers. */\n    sqlite3VdbeAddOp2(v, OP_Integer, 0, regSampleno);\n    sqlite3VdbeAddOp2(v, OP_Integer, 0, regRecno);\n    sqlite3VdbeAddOp2(v, OP_Copy, regFirst, regSamplerecno);\n#endif\n\n    /* The block of memory cells initialized here is used as follows.\n    **\n    **    iMem:                \n    **        The total number of rows in the table.\n    **\n    **    iMem+1 .. iMem+nCol: \n    **        Number of distinct entries in index considering the \n    **        left-most N columns only, where N is between 1 and nCol, \n    **        inclusive.\n    **\n    **    iMem+nCol+1 .. Mem+2*nCol:  \n    **        Previous value of indexed columns, from left to right.\n    **\n    ** Cells iMem through iMem+nCol are initialized to 0. The others are \n    ** initialized to contain an SQL NULL.\n    */\n    for(i=0; i<=nCol; i++){\n      sqlite3VdbeAddOp2(v, OP_Integer, 0, iMem+i);\n    }\n    for(i=0; i<nCol; i++){\n      sqlite3VdbeAddOp2(v, OP_Null, 0, iMem+nCol+i+1);\n    }\n\n    /* Start the analysis loop. This loop runs through all the entries in\n    ** the index b-tree.  */\n    endOfLoop = sqlite3VdbeMakeLabel(v);\n    sqlite3VdbeAddOp2(v, OP_Rewind, iIdxCur, endOfLoop);\n    topOfLoop = sqlite3VdbeCurrentAddr(v);\n    sqlite3VdbeAddOp2(v, OP_AddImm, iMem, 1);\n\n    for(i=0; i<nCol; i++){\n      CollSeq *pColl;\n      sqlite3VdbeAddOp3(v, OP_Column, iIdxCur, i, regCol);\n      if( i==0 ){\n#ifdef SQLITE_ENABLE_STAT2\n        /* Check if the record that cursor iIdxCur points to contains a\n        ** value that should be stored in the sqlite_stat2 table. If so,\n        ** store it.  */\n        int ne = sqlite3VdbeAddOp3(v, OP_Ne, regRecno, 0, regSamplerecno);\n        assert( regTabname+1==regIdxname \n             && regTabname+2==regSampleno\n             && regTabname+3==regCol\n        );\n        sqlite3VdbeChangeP5(v, SQLITE_JUMPIFNULL);\n        sqlite3VdbeAddOp4(v, OP_MakeRecord, regTabname, 4, regRec, \"aaab\", 0);\n        sqlite3VdbeAddOp2(v, OP_NewRowid, iStatCur+1, regRowid);\n        sqlite3VdbeAddOp3(v, OP_Insert, iStatCur+1, regRec, regRowid);\n\n        /* Calculate new values for regSamplerecno and regSampleno.\n        **\n        **   sampleno = sampleno + 1\n        **   samplerecno = samplerecno+(remaining records)/(remaining samples)\n        */\n        sqlite3VdbeAddOp2(v, OP_AddImm, regSampleno, 1);\n        sqlite3VdbeAddOp3(v, OP_Subtract, regRecno, regLast, regTemp);\n        sqlite3VdbeAddOp2(v, OP_AddImm, regTemp, -1);\n        sqlite3VdbeAddOp2(v, OP_Integer, SQLITE_INDEX_SAMPLES, regTemp2);\n        sqlite3VdbeAddOp3(v, OP_Subtract, regSampleno, regTemp2, regTemp2);\n        sqlite3VdbeAddOp3(v, OP_Divide, regTemp2, regTemp, regTemp);\n        sqlite3VdbeAddOp3(v, OP_Add, regSamplerecno, regTemp, regSamplerecno);\n\n        sqlite3VdbeJumpHere(v, ne);\n        sqlite3VdbeAddOp2(v, OP_AddImm, regRecno, 1);\n#endif\n\n        /* Always record the very first row */\n        sqlite3VdbeAddOp1(v, OP_IfNot, iMem+1);\n      }\n      assert( pIdx->azColl!=0 );\n      assert( pIdx->azColl[i]!=0 );\n      pColl = sqlite3LocateCollSeq(pParse, pIdx->azColl[i]);\n      sqlite3VdbeAddOp4(v, OP_Ne, regCol, 0, iMem+nCol+i+1,\n                       (char*)pColl, P4_COLLSEQ);\n      sqlite3VdbeChangeP5(v, SQLITE_NULLEQ);\n    }\n    if( db->mallocFailed ){\n      /* If a malloc failure has occurred, then the result of the expression \n      ** passed as the second argument to the call to sqlite3VdbeJumpHere() \n      ** below may be negative. Which causes an assert() to fail (or an\n      ** out-of-bounds write if SQLITE_DEBUG is not defined).  */\n      return;\n    }\n    sqlite3VdbeAddOp2(v, OP_Goto, 0, endOfLoop);\n    for(i=0; i<nCol; i++){\n      int addr2 = sqlite3VdbeCurrentAddr(v) - (nCol*2);\n      if( i==0 ){\n        sqlite3VdbeJumpHere(v, addr2-1);  /* Set jump dest for the OP_IfNot */\n      }\n      sqlite3VdbeJumpHere(v, addr2);      /* Set jump dest for the OP_Ne */\n      sqlite3VdbeAddOp2(v, OP_AddImm, iMem+i+1, 1);\n      sqlite3VdbeAddOp3(v, OP_Column, iIdxCur, i, iMem+nCol+i+1);\n    }\n\n    /* End of the analysis loop. */\n    sqlite3VdbeResolveLabel(v, endOfLoop);\n    sqlite3VdbeAddOp2(v, OP_Next, iIdxCur, topOfLoop);\n    sqlite3VdbeAddOp1(v, OP_Close, iIdxCur);\n\n    /* Store the results in sqlite_stat1.\n    **\n    ** The result is a single row of the sqlite_stat1 table.  The first\n    ** two columns are the names of the table and index.  The third column\n    ** is a string composed of a list of integer statistics about the\n    ** index.  The first integer in the list is the total number of entries\n    ** in the index.  There is one additional integer in the list for each\n    ** column of the table.  This additional integer is a guess of how many\n    ** rows of the table the index will select.  If D is the count of distinct\n    ** values and K is the total number of rows, then the integer is computed\n    ** as:\n    **\n    **        I = (K+D-1)/D\n    **\n    ** If K==0 then no entry is made into the sqlite_stat1 table.  \n    ** If K>0 then it is always the case the D>0 so division by zero\n    ** is never possible.\n    */\n    sqlite3VdbeAddOp2(v, OP_SCopy, iMem, regSampleno);\n    if( jZeroRows==0 ){\n      jZeroRows = sqlite3VdbeAddOp1(v, OP_IfNot, iMem);\n    }\n    for(i=0; i<nCol; i++){\n      sqlite3VdbeAddOp4(v, OP_String8, 0, regTemp, 0, \" \", 0);\n      sqlite3VdbeAddOp3(v, OP_Concat, regTemp, regSampleno, regSampleno);\n      sqlite3VdbeAddOp3(v, OP_Add, iMem, iMem+i+1, regTemp);\n      sqlite3VdbeAddOp2(v, OP_AddImm, regTemp, -1);\n      sqlite3VdbeAddOp3(v, OP_Divide, iMem+i+1, regTemp, regTemp);\n      sqlite3VdbeAddOp1(v, OP_ToInt, regTemp);\n      sqlite3VdbeAddOp3(v, OP_Concat, regTemp, regSampleno, regSampleno);\n    }\n    sqlite3VdbeAddOp4(v, OP_MakeRecord, regTabname, 3, regRec, \"aaa\", 0);\n    sqlite3VdbeAddOp2(v, OP_NewRowid, iStatCur, regRowid);\n    sqlite3VdbeAddOp3(v, OP_Insert, iStatCur, regRec, regRowid);\n    sqlite3VdbeChangeP5(v, OPFLAG_APPEND);\n  }\n\n  /* If the table has no indices, create a single sqlite_stat1 entry\n  ** containing NULL as the index name and the row count as the content.\n  */\n  if( pTab->pIndex==0 ){\n    sqlite3VdbeAddOp3(v, OP_OpenRead, iIdxCur, pTab->tnum, iDb);\n    VdbeComment((v, \"%s\", pTab->zName));\n    sqlite3VdbeAddOp2(v, OP_Count, iIdxCur, regSampleno);\n    sqlite3VdbeAddOp1(v, OP_Close, iIdxCur);\n  }else{\n    assert( jZeroRows>0 );\n    addr = sqlite3VdbeAddOp0(v, OP_Goto);\n    sqlite3VdbeJumpHere(v, jZeroRows);\n  }\n  sqlite3VdbeAddOp2(v, OP_Null, 0, regIdxname);\n  sqlite3VdbeAddOp4(v, OP_MakeRecord, regTabname, 3, regRec, \"aaa\", 0);\n  sqlite3VdbeAddOp2(v, OP_NewRowid, iStatCur, regRowid);\n  sqlite3VdbeAddOp3(v, OP_Insert, iStatCur, regRec, regRowid);\n  sqlite3VdbeChangeP5(v, OPFLAG_APPEND);\n  if( pParse->nMem<regRec ) pParse->nMem = regRec;\n  if( jZeroRows ){\n    sqlite3VdbeJumpHere(v, addr);\n  }\n}\n\n/*\n** Generate code that will cause the most recent index analysis to\n** be loaded into internal hash tables where is can be used.\n*/\nstatic void loadAnalysis(Parse *pParse, int iDb){\n  Vdbe *v = sqlite3GetVdbe(pParse);\n  if( v ){\n    sqlite3VdbeAddOp1(v, OP_LoadAnalysis, iDb);\n  }\n}\n\n/*\n** Generate code that will do an analysis of an entire database\n*/\nstatic void analyzeDatabase(Parse *pParse, int iDb){\n  sqlite3 *db = pParse->db;\n  Schema *pSchema = db->aDb[iDb].pSchema;    /* Schema of database iDb */\n  HashElem *k;\n  int iStatCur;\n  int iMem;\n\n  sqlite3BeginWriteOperation(pParse, 0, iDb);\n  iStatCur = pParse->nTab;\n  pParse->nTab += 2;\n  openStatTable(pParse, iDb, iStatCur, 0);\n  iMem = pParse->nMem+1;\n  for(k=sqliteHashFirst(&pSchema->tblHash); k; k=sqliteHashNext(k)){\n    Table *pTab = (Table*)sqliteHashData(k);\n    analyzeOneTable(pParse, pTab, iStatCur, iMem);\n  }\n  loadAnalysis(pParse, iDb);\n}\n\n/*\n** Generate code that will do an analysis of a single table in\n** a database.\n*/\nstatic void analyzeTable(Parse *pParse, Table *pTab){\n  int iDb;\n  int iStatCur;\n\n  assert( pTab!=0 );\n  assert( sqlite3BtreeHoldsAllMutexes(pParse->db) );\n  iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);\n  sqlite3BeginWriteOperation(pParse, 0, iDb);\n  iStatCur = pParse->nTab;\n  pParse->nTab += 2;\n  openStatTable(pParse, iDb, iStatCur, pTab->zName);\n  analyzeOneTable(pParse, pTab, iStatCur, pParse->nMem+1);\n  loadAnalysis(pParse, iDb);\n}\n\n/*\n** Generate code for the ANALYZE command.  The parser calls this routine\n** when it recognizes an ANALYZE command.\n**\n**        ANALYZE                            -- 1\n**        ANALYZE  <database>                -- 2\n**        ANALYZE  ?<database>.?<tablename>  -- 3\n**\n** Form 1 causes all indices in all attached databases to be analyzed.\n** Form 2 analyzes all indices the single database named.\n** Form 3 analyzes all indices associated with the named table.\n*/\nSQLITE_PRIVATE void sqlite3Analyze(Parse *pParse, Token *pName1, Token *pName2){\n  sqlite3 *db = pParse->db;\n  int iDb;\n  int i;\n  char *z, *zDb;\n  Table *pTab;\n  Token *pTableName;\n\n  /* Read the database schema. If an error occurs, leave an error message\n  ** and code in pParse and return NULL. */\n  assert( sqlite3BtreeHoldsAllMutexes(pParse->db) );\n  if( SQLITE_OK!=sqlite3ReadSchema(pParse) ){\n    return;\n  }\n\n  assert( pName2!=0 || pName1==0 );\n  if( pName1==0 ){\n    /* Form 1:  Analyze everything */\n    for(i=0; i<db->nDb; i++){\n      if( i==1 ) continue;  /* Do not analyze the TEMP database */\n      analyzeDatabase(pParse, i);\n    }\n  }else if( pName2->n==0 ){\n    /* Form 2:  Analyze the database or table named */\n    iDb = sqlite3FindDb(db, pName1);\n    if( iDb>=0 ){\n      analyzeDatabase(pParse, iDb);\n    }else{\n      z = sqlite3NameFromToken(db, pName1);\n      if( z ){\n        pTab = sqlite3LocateTable(pParse, 0, z, 0);\n        sqlite3DbFree(db, z);\n        if( pTab ){\n          analyzeTable(pParse, pTab);\n        }\n      }\n    }\n  }else{\n    /* Form 3: Analyze the fully qualified table name */\n    iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pTableName);\n    if( iDb>=0 ){\n      zDb = db->aDb[iDb].zName;\n      z = sqlite3NameFromToken(db, pTableName);\n      if( z ){\n        pTab = sqlite3LocateTable(pParse, 0, z, zDb);\n        sqlite3DbFree(db, z);\n        if( pTab ){\n          analyzeTable(pParse, pTab);\n        }\n      }\n    }   \n  }\n}\n\n/*\n** Used to pass information from the analyzer reader through to the\n** callback routine.\n*/\ntypedef struct analysisInfo analysisInfo;\nstruct analysisInfo {\n  sqlite3 *db;\n  const char *zDatabase;\n};\n\n/*\n** This callback is invoked once for each index when reading the\n** sqlite_stat1 table.  \n**\n**     argv[0] = name of the table\n**     argv[1] = name of the index (might be NULL)\n**     argv[2] = results of analysis - on integer for each column\n**\n** Entries for which argv[1]==NULL simply record the number of rows in\n** the table.\n*/\nstatic int analysisLoader(void *pData, int argc, char **argv, char **NotUsed){\n  analysisInfo *pInfo = (analysisInfo*)pData;\n  Index *pIndex;\n  Table *pTable;\n  int i, c, n;\n  unsigned int v;\n  const char *z;\n\n  assert( argc==3 );\n  UNUSED_PARAMETER2(NotUsed, argc);\n\n  if( argv==0 || argv[0]==0 || argv[2]==0 ){\n    return 0;\n  }\n  pTable = sqlite3FindTable(pInfo->db, argv[0], pInfo->zDatabase);\n  if( pTable==0 ){\n    return 0;\n  }\n  if( argv[1] ){\n    pIndex = sqlite3FindIndex(pInfo->db, argv[1], pInfo->zDatabase);\n  }else{\n    pIndex = 0;\n  }\n  n = pIndex ? pIndex->nColumn : 0;\n  z = argv[2];\n  for(i=0; *z && i<=n; i++){\n    v = 0;\n    while( (c=z[0])>='0' && c<='9' ){\n      v = v*10 + c - '0';\n      z++;\n    }\n    if( i==0 ) pTable->nRowEst = v;\n    if( pIndex==0 ) break;\n    pIndex->aiRowEst[i] = v;\n    if( *z==' ' ) z++;\n  }\n  return 0;\n}\n\n/*\n** If the Index.aSample variable is not NULL, delete the aSample[] array\n** and its contents.\n*/\nSQLITE_PRIVATE void sqlite3DeleteIndexSamples(sqlite3 *db, Index *pIdx){\n#ifdef SQLITE_ENABLE_STAT2\n  if( pIdx->aSample ){\n    int j;\n    for(j=0; j<SQLITE_INDEX_SAMPLES; j++){\n      IndexSample *p = &pIdx->aSample[j];\n      if( p->eType==SQLITE_TEXT || p->eType==SQLITE_BLOB ){\n        sqlite3DbFree(db, p->u.z);\n      }\n    }\n    sqlite3DbFree(db, pIdx->aSample);\n  }\n#else\n  UNUSED_PARAMETER(db);\n  UNUSED_PARAMETER(pIdx);\n#endif\n}\n\n/*\n** Load the content of the sqlite_stat1 and sqlite_stat2 tables. The\n** contents of sqlite_stat1 are used to populate the Index.aiRowEst[]\n** arrays. The contents of sqlite_stat2 are used to populate the\n** Index.aSample[] arrays.\n**\n** If the sqlite_stat1 table is not present in the database, SQLITE_ERROR\n** is returned. In this case, even if SQLITE_ENABLE_STAT2 was defined \n** during compilation and the sqlite_stat2 table is present, no data is \n** read from it.\n**\n** If SQLITE_ENABLE_STAT2 was defined during compilation and the \n** sqlite_stat2 table is not present in the database, SQLITE_ERROR is\n** returned. However, in this case, data is read from the sqlite_stat1\n** table (if it is present) before returning.\n**\n** If an OOM error occurs, this function always sets db->mallocFailed.\n** This means if the caller does not care about other errors, the return\n** code may be ignored.\n*/\nSQLITE_PRIVATE int sqlite3AnalysisLoad(sqlite3 *db, int iDb){\n  analysisInfo sInfo;\n  HashElem *i;\n  char *zSql;\n  int rc;\n\n  assert( iDb>=0 && iDb<db->nDb );\n  assert( db->aDb[iDb].pBt!=0 );\n  assert( sqlite3BtreeHoldsMutex(db->aDb[iDb].pBt) );\n\n  /* Clear any prior statistics */\n  for(i=sqliteHashFirst(&db->aDb[iDb].pSchema->idxHash);i;i=sqliteHashNext(i)){\n    Index *pIdx = sqliteHashData(i);\n    sqlite3DefaultRowEst(pIdx);\n    sqlite3DeleteIndexSamples(db, pIdx);\n    pIdx->aSample = 0;\n  }\n\n  /* Check to make sure the sqlite_stat1 table exists */\n  sInfo.db = db;\n  sInfo.zDatabase = db->aDb[iDb].zName;\n  if( sqlite3FindTable(db, \"sqlite_stat1\", sInfo.zDatabase)==0 ){\n    return SQLITE_ERROR;\n  }\n\n  /* Load new statistics out of the sqlite_stat1 table */\n  zSql = sqlite3MPrintf(db, \n      \"SELECT tbl, idx, stat FROM %Q.sqlite_stat1\", sInfo.zDatabase);\n  if( zSql==0 ){\n    rc = SQLITE_NOMEM;\n  }else{\n    rc = sqlite3_exec(db, zSql, analysisLoader, &sInfo, 0);\n    sqlite3DbFree(db, zSql);\n  }\n\n\n  /* Load the statistics from the sqlite_stat2 table. */\n#ifdef SQLITE_ENABLE_STAT2\n  if( rc==SQLITE_OK && !sqlite3FindTable(db, \"sqlite_stat2\", sInfo.zDatabase) ){\n    rc = SQLITE_ERROR;\n  }\n  if( rc==SQLITE_OK ){\n    sqlite3_stmt *pStmt = 0;\n\n    zSql = sqlite3MPrintf(db, \n        \"SELECT idx,sampleno,sample FROM %Q.sqlite_stat2\", sInfo.zDatabase);\n    if( !zSql ){\n      rc = SQLITE_NOMEM;\n    }else{\n      rc = sqlite3_prepare(db, zSql, -1, &pStmt, 0);\n      sqlite3DbFree(db, zSql);\n    }\n\n    if( rc==SQLITE_OK ){\n      while( sqlite3_step(pStmt)==SQLITE_ROW ){\n        char *zIndex;   /* Index name */\n        Index *pIdx;    /* Pointer to the index object */\n\n        zIndex = (char *)sqlite3_column_text(pStmt, 0);\n        pIdx = zIndex ? sqlite3FindIndex(db, zIndex, sInfo.zDatabase) : 0;\n        if( pIdx ){\n          int iSample = sqlite3_column_int(pStmt, 1);\n          if( iSample<SQLITE_INDEX_SAMPLES && iSample>=0 ){\n            int eType = sqlite3_column_type(pStmt, 2);\n\n            if( pIdx->aSample==0 ){\n              static const int sz = sizeof(IndexSample)*SQLITE_INDEX_SAMPLES;\n              pIdx->aSample = (IndexSample *)sqlite3DbMallocRaw(0, sz);\n              if( pIdx->aSample==0 ){\n                db->mallocFailed = 1;\n                break;\n              }\n              memset(pIdx->aSample, 0, sz);\n            }\n\n            assert( pIdx->aSample );\n            {\n              IndexSample *pSample = &pIdx->aSample[iSample];\n              pSample->eType = (u8)eType;\n              if( eType==SQLITE_INTEGER || eType==SQLITE_FLOAT ){\n                pSample->u.r = sqlite3_column_double(pStmt, 2);\n              }else if( eType==SQLITE_TEXT || eType==SQLITE_BLOB ){\n                const char *z = (const char *)(\n                    (eType==SQLITE_BLOB) ?\n                    sqlite3_column_blob(pStmt, 2):\n                    sqlite3_column_text(pStmt, 2)\n                );\n                int n = sqlite3_column_bytes(pStmt, 2);\n                if( n>24 ){\n                  n = 24;\n                }\n                pSample->nByte = (u8)n;\n                if( n < 1){\n                  pSample->u.z = 0;\n                }else{\n                  pSample->u.z = sqlite3DbStrNDup(0, z, n);\n                  if( pSample->u.z==0 ){\n                    db->mallocFailed = 1;\n                    break;\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n      rc = sqlite3_finalize(pStmt);\n    }\n  }\n#endif\n\n  if( rc==SQLITE_NOMEM ){\n    db->mallocFailed = 1;\n  }\n  return rc;\n}\n\n\n#endif /* SQLITE_OMIT_ANALYZE */\n\n/************** End of analyze.c *********************************************/\n/************** Begin file attach.c ******************************************/\n/*\n** 2003 April 6\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains code used to implement the ATTACH and DETACH commands.\n*/\n\n#ifndef SQLITE_OMIT_ATTACH\n/*\n** Resolve an expression that was part of an ATTACH or DETACH statement. This\n** is slightly different from resolving a normal SQL expression, because simple\n** identifiers are treated as strings, not possible column names or aliases.\n**\n** i.e. if the parser sees:\n**\n**     ATTACH DATABASE abc AS def\n**\n** it treats the two expressions as literal strings 'abc' and 'def' instead of\n** looking for columns of the same name.\n**\n** This only applies to the root node of pExpr, so the statement:\n**\n**     ATTACH DATABASE abc||def AS 'db2'\n**\n** will fail because neither abc or def can be resolved.\n*/\nstatic int resolveAttachExpr(NameContext *pName, Expr *pExpr)\n{\n  int rc = SQLITE_OK;\n  if( pExpr ){\n    if( pExpr->op!=TK_ID ){\n      rc = sqlite3ResolveExprNames(pName, pExpr);\n      if( rc==SQLITE_OK && !sqlite3ExprIsConstant(pExpr) ){\n        sqlite3ErrorMsg(pName->pParse, \"invalid name: \\\"%s\\\"\", pExpr->u.zToken);\n        return SQLITE_ERROR;\n      }\n    }else{\n      pExpr->op = TK_STRING;\n    }\n  }\n  return rc;\n}\n\n/*\n** An SQL user-function registered to do the work of an ATTACH statement. The\n** three arguments to the function come directly from an attach statement:\n**\n**     ATTACH DATABASE x AS y KEY z\n**\n**     SELECT sqlite_attach(x, y, z)\n**\n** If the optional \"KEY z\" syntax is omitted, an SQL NULL is passed as the\n** third argument.\n*/\nstatic void attachFunc(\n  sqlite3_context *context,\n  int NotUsed,\n  sqlite3_value **argv\n){\n  int i;\n  int rc = 0;\n  sqlite3 *db = sqlite3_context_db_handle(context);\n  const char *zName;\n  const char *zFile;\n  Db *aNew;\n  char *zErrDyn = 0;\n\n  UNUSED_PARAMETER(NotUsed);\n\n  zFile = (const char *)sqlite3_value_text(argv[0]);\n  zName = (const char *)sqlite3_value_text(argv[1]);\n  if( zFile==0 ) zFile = \"\";\n  if( zName==0 ) zName = \"\";\n\n  /* Check for the following errors:\n  **\n  **     * Too many attached databases,\n  **     * Transaction currently open\n  **     * Specified database name already being used.\n  */\n  if( db->nDb>=db->aLimit[SQLITE_LIMIT_ATTACHED]+2 ){\n    zErrDyn = sqlite3MPrintf(db, \"too many attached databases - max %d\", \n      db->aLimit[SQLITE_LIMIT_ATTACHED]\n    );\n    goto attach_error;\n  }\n  if( !db->autoCommit ){\n    zErrDyn = sqlite3MPrintf(db, \"cannot ATTACH database within transaction\");\n    goto attach_error;\n  }\n  for(i=0; i<db->nDb; i++){\n    char *z = db->aDb[i].zName;\n    assert( z && zName );\n    if( sqlite3StrICmp(z, zName)==0 ){\n      zErrDyn = sqlite3MPrintf(db, \"database %s is already in use\", zName);\n      goto attach_error;\n    }\n  }\n\n  /* Allocate the new entry in the db->aDb[] array and initialise the schema\n  ** hash tables.\n  */\n  if( db->aDb==db->aDbStatic ){\n    aNew = sqlite3DbMallocRaw(db, sizeof(db->aDb[0])*3 );\n    if( aNew==0 ) return;\n    memcpy(aNew, db->aDb, sizeof(db->aDb[0])*2);\n  }else{\n    aNew = sqlite3DbRealloc(db, db->aDb, sizeof(db->aDb[0])*(db->nDb+1) );\n    if( aNew==0 ) return;\n  }\n  db->aDb = aNew;\n  aNew = &db->aDb[db->nDb];\n  memset(aNew, 0, sizeof(*aNew));\n\n  /* Open the database file. If the btree is successfully opened, use\n  ** it to obtain the database schema. At this point the schema may\n  ** or may not be initialised.\n  */\n  rc = sqlite3BtreeOpen(zFile, db, &aNew->pBt, 0,\n                        db->openFlags | SQLITE_OPEN_MAIN_DB);\n  db->nDb++;\n  if( rc==SQLITE_CONSTRAINT ){\n    rc = SQLITE_ERROR;\n    zErrDyn = sqlite3MPrintf(db, \"database is already attached\");\n  }else if( rc==SQLITE_OK ){\n    Pager *pPager;\n    aNew->pSchema = sqlite3SchemaGet(db, aNew->pBt);\n    if( !aNew->pSchema ){\n      rc = SQLITE_NOMEM;\n    }else if( aNew->pSchema->file_format && aNew->pSchema->enc!=ENC(db) ){\n      zErrDyn = sqlite3MPrintf(db, \n        \"attached databases must use the same text encoding as main database\");\n      rc = SQLITE_ERROR;\n    }\n    pPager = sqlite3BtreePager(aNew->pBt);\n    sqlite3PagerLockingMode(pPager, db->dfltLockMode);\n    sqlite3BtreeSecureDelete(aNew->pBt,\n                             sqlite3BtreeSecureDelete(db->aDb[0].pBt,-1) );\n  }\n  aNew->safety_level = 3;\n  aNew->zName = sqlite3DbStrDup(db, zName);\n  if( rc==SQLITE_OK && aNew->zName==0 ){\n    rc = SQLITE_NOMEM;\n  }\n\n\n#if defined(SQLITE_HAS_CODEC) && !defined(SQLITE_HAS_CODEC_NO_ENCRYPTION)\n  if( rc==SQLITE_OK ){\n    extern int sqlite3CodecAttach(sqlite3*, int, const void*, int);\n    extern void sqlite3CodecGetKey(sqlite3*, int, void**, int*);\n    int nKey;\n    char *zKey;\n    int t = sqlite3_value_type(argv[2]);\n    switch( t ){\n      case SQLITE_INTEGER:\n      case SQLITE_FLOAT:\n        zErrDyn = sqlite3DbStrDup(db, \"Invalid key value\");\n        rc = SQLITE_ERROR;\n        break;\n        \n      case SQLITE_TEXT:\n      case SQLITE_BLOB:\n        nKey = sqlite3_value_bytes(argv[2]);\n        zKey = (char *)sqlite3_value_blob(argv[2]);\n        rc = sqlite3CodecAttach(db, db->nDb-1, zKey, nKey);\n        break;\n\n      case SQLITE_NULL:\n        /* No key specified.  Use the key from the main database */\n        sqlite3CodecGetKey(db, 0, (void**)&zKey, &nKey);\n        rc = sqlite3CodecAttach(db, db->nDb-1, zKey, nKey);\n        break;\n    }\n  }\n#endif\n\n  /* If the file was opened successfully, read the schema for the new database.\n  ** If this fails, or if opening the file failed, then close the file and \n  ** remove the entry from the db->aDb[] array. i.e. put everything back the way\n  ** we found it.\n  */\n  if( rc==SQLITE_OK ){\n    sqlite3BtreeEnterAll(db);\n    rc = sqlite3Init(db, &zErrDyn);\n    sqlite3BtreeLeaveAll(db);\n  }\n  if( rc ){\n    int iDb = db->nDb - 1;\n    assert( iDb>=2 );\n    if( db->aDb[iDb].pBt ){\n      sqlite3BtreeClose(db->aDb[iDb].pBt);\n      db->aDb[iDb].pBt = 0;\n      db->aDb[iDb].pSchema = 0;\n    }\n    sqlite3ResetInternalSchema(db, 0);\n    db->nDb = iDb;\n    if( rc==SQLITE_NOMEM || rc==SQLITE_IOERR_NOMEM ){\n      db->mallocFailed = 1;\n      sqlite3DbFree(db, zErrDyn);\n      zErrDyn = sqlite3MPrintf(db, \"out of memory\");\n    }else if( zErrDyn==0 ){\n      zErrDyn = sqlite3MPrintf(db, \"unable to open database: %s\", zFile);\n    }\n    goto attach_error;\n  }\n  \n  return;\n\nattach_error:\n  /* Return an error if we get here */\n  if( zErrDyn ){\n    sqlite3_result_error(context, zErrDyn, -1);\n    sqlite3DbFree(db, zErrDyn);\n  }\n  if( rc ) sqlite3_result_error_code(context, rc);\n}\n\n/*\n** An SQL user-function registered to do the work of an DETACH statement. The\n** three arguments to the function come directly from a detach statement:\n**\n**     DETACH DATABASE x\n**\n**     SELECT sqlite_detach(x)\n*/\nstatic void detachFunc(\n  sqlite3_context *context,\n  int NotUsed,\n  sqlite3_value **argv\n){\n  const char *zName = (const char *)sqlite3_value_text(argv[0]);\n  sqlite3 *db = sqlite3_context_db_handle(context);\n  int i;\n  Db *pDb = 0;\n  char zErr[128];\n\n  UNUSED_PARAMETER(NotUsed);\n\n  if( zName==0 ) zName = \"\";\n  for(i=0; i<db->nDb; i++){\n    pDb = &db->aDb[i];\n    if( pDb->pBt==0 ) continue;\n    if( sqlite3StrICmp(pDb->zName, zName)==0 ) break;\n  }\n\n  if( i>=db->nDb ){\n    sqlite3_snprintf(sizeof(zErr),zErr, \"no such database: %s\", zName);\n    goto detach_error;\n  }\n  if( i<2 ){\n    sqlite3_snprintf(sizeof(zErr),zErr, \"cannot detach database %s\", zName);\n    goto detach_error;\n  }\n  if( !db->autoCommit ){\n    sqlite3_snprintf(sizeof(zErr), zErr,\n                     \"cannot DETACH database within transaction\");\n    goto detach_error;\n  }\n  if( sqlite3BtreeIsInReadTrans(pDb->pBt) || sqlite3BtreeIsInBackup(pDb->pBt) ){\n    sqlite3_snprintf(sizeof(zErr),zErr, \"database %s is locked\", zName);\n    goto detach_error;\n  }\n\n  sqlite3BtreeClose(pDb->pBt);\n  pDb->pBt = 0;\n  pDb->pSchema = 0;\n  sqlite3ResetInternalSchema(db, 0);\n  return;\n\ndetach_error:\n  sqlite3_result_error(context, zErr, -1);\n}\n\n/*\n** This procedure generates VDBE code for a single invocation of either the\n** sqlite_detach() or sqlite_attach() SQL user functions.\n*/\nstatic void codeAttach(\n  Parse *pParse,       /* The parser context */\n  int type,            /* Either SQLITE_ATTACH or SQLITE_DETACH */\n  FuncDef const *pFunc,/* FuncDef wrapper for detachFunc() or attachFunc() */\n  Expr *pAuthArg,      /* Expression to pass to authorization callback */\n  Expr *pFilename,     /* Name of database file */\n  Expr *pDbname,       /* Name of the database to use internally */\n  Expr *pKey           /* Database key for encryption extension */\n){\n  int rc;\n  NameContext sName;\n  Vdbe *v;\n  sqlite3* db = pParse->db;\n  int regArgs;\n\n  memset(&sName, 0, sizeof(NameContext));\n  sName.pParse = pParse;\n\n  if( \n      SQLITE_OK!=(rc = resolveAttachExpr(&sName, pFilename)) ||\n      SQLITE_OK!=(rc = resolveAttachExpr(&sName, pDbname)) ||\n      SQLITE_OK!=(rc = resolveAttachExpr(&sName, pKey))\n  ){\n    pParse->nErr++;\n    goto attach_end;\n  }\n\n#ifndef SQLITE_OMIT_AUTHORIZATION\n  if( pAuthArg ){\n    char *zAuthArg;\n    if( pAuthArg->op==TK_STRING ){\n      zAuthArg = pAuthArg->u.zToken;\n    }else{\n      zAuthArg = 0;\n    }\n    rc = sqlite3AuthCheck(pParse, type, zAuthArg, 0, 0);\n    if(rc!=SQLITE_OK ){\n      goto attach_end;\n    }\n  }\n#endif /* SQLITE_OMIT_AUTHORIZATION */\n\n\n  v = sqlite3GetVdbe(pParse);\n  regArgs = sqlite3GetTempRange(pParse, 4);\n  sqlite3ExprCode(pParse, pFilename, regArgs);\n  sqlite3ExprCode(pParse, pDbname, regArgs+1);\n  sqlite3ExprCode(pParse, pKey, regArgs+2);\n\n  assert( v || db->mallocFailed );\n  if( v ){\n    sqlite3VdbeAddOp3(v, OP_Function, 0, regArgs+3-pFunc->nArg, regArgs+3);\n    assert( pFunc->nArg==-1 || (pFunc->nArg&0xff)==pFunc->nArg );\n    sqlite3VdbeChangeP5(v, (u8)(pFunc->nArg));\n    sqlite3VdbeChangeP4(v, -1, (char *)pFunc, P4_FUNCDEF);\n\n    /* Code an OP_Expire. For an ATTACH statement, set P1 to true (expire this\n    ** statement only). For DETACH, set it to false (expire all existing\n    ** statements).\n    */\n    sqlite3VdbeAddOp1(v, OP_Expire, (type==SQLITE_ATTACH));\n  }\n  \nattach_end:\n  sqlite3ExprDelete(db, pFilename);\n  sqlite3ExprDelete(db, pDbname);\n  sqlite3ExprDelete(db, pKey);\n}\n\n/*\n** Called by the parser to compile a DETACH statement.\n**\n**     DETACH pDbname\n*/\nSQLITE_PRIVATE void sqlite3Detach(Parse *pParse, Expr *pDbname){\n  static const FuncDef detach_func = {\n    1,                /* nArg */\n    SQLITE_UTF8,      /* iPrefEnc */\n    0,                /* flags */\n    0,                /* pUserData */\n    0,                /* pNext */\n    detachFunc,       /* xFunc */\n    0,                /* xStep */\n    0,                /* xFinalize */\n    \"sqlite_detach\",  /* zName */\n    0,                /* pHash */\n    0                 /* pDestructor */\n  };\n  codeAttach(pParse, SQLITE_DETACH, &detach_func, pDbname, 0, 0, pDbname);\n}\n\n/*\n** Called by the parser to compile an ATTACH statement.\n**\n**     ATTACH p AS pDbname KEY pKey\n*/\nSQLITE_PRIVATE void sqlite3Attach(Parse *pParse, Expr *p, Expr *pDbname, Expr *pKey){\n  static const FuncDef attach_func = {\n    3,                /* nArg */\n    SQLITE_UTF8,      /* iPrefEnc */\n    0,                /* flags */\n    0,                /* pUserData */\n    0,                /* pNext */\n    attachFunc,       /* xFunc */\n    0,                /* xStep */\n    0,                /* xFinalize */\n    \"sqlite_attach\",  /* zName */\n    0,                /* pHash */\n    0                 /* pDestructor */\n  };\n  codeAttach(pParse, SQLITE_ATTACH, &attach_func, p, p, pDbname, pKey);\n}\n#endif /* SQLITE_OMIT_ATTACH */\n\n/*\n** Initialize a DbFixer structure.  This routine must be called prior\n** to passing the structure to one of the sqliteFixAAAA() routines below.\n**\n** The return value indicates whether or not fixation is required.  TRUE\n** means we do need to fix the database references, FALSE means we do not.\n*/\nSQLITE_PRIVATE int sqlite3FixInit(\n  DbFixer *pFix,      /* The fixer to be initialized */\n  Parse *pParse,      /* Error messages will be written here */\n  int iDb,            /* This is the database that must be used */\n  const char *zType,  /* \"view\", \"trigger\", or \"index\" */\n  const Token *pName  /* Name of the view, trigger, or index */\n){\n  sqlite3 *db;\n\n  if( NEVER(iDb<0) || iDb==1 ) return 0;\n  db = pParse->db;\n  assert( db->nDb>iDb );\n  pFix->pParse = pParse;\n  pFix->zDb = db->aDb[iDb].zName;\n  pFix->zType = zType;\n  pFix->pName = pName;\n  return 1;\n}\n\n/*\n** The following set of routines walk through the parse tree and assign\n** a specific database to all table references where the database name\n** was left unspecified in the original SQL statement.  The pFix structure\n** must have been initialized by a prior call to sqlite3FixInit().\n**\n** These routines are used to make sure that an index, trigger, or\n** view in one database does not refer to objects in a different database.\n** (Exception: indices, triggers, and views in the TEMP database are\n** allowed to refer to anything.)  If a reference is explicitly made\n** to an object in a different database, an error message is added to\n** pParse->zErrMsg and these routines return non-zero.  If everything\n** checks out, these routines return 0.\n*/\nSQLITE_PRIVATE int sqlite3FixSrcList(\n  DbFixer *pFix,       /* Context of the fixation */\n  SrcList *pList       /* The Source list to check and modify */\n){\n  int i;\n  const char *zDb;\n  struct SrcList_item *pItem;\n\n  if( NEVER(pList==0) ) return 0;\n  zDb = pFix->zDb;\n  for(i=0, pItem=pList->a; i<pList->nSrc; i++, pItem++){\n    if( pItem->zDatabase==0 ){\n      pItem->zDatabase = sqlite3DbStrDup(pFix->pParse->db, zDb);\n    }else if( sqlite3StrICmp(pItem->zDatabase,zDb)!=0 ){\n      sqlite3ErrorMsg(pFix->pParse,\n         \"%s %T cannot reference objects in database %s\",\n         pFix->zType, pFix->pName, pItem->zDatabase);\n      return 1;\n    }\n#if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_TRIGGER)\n    if( sqlite3FixSelect(pFix, pItem->pSelect) ) return 1;\n    if( sqlite3FixExpr(pFix, pItem->pOn) ) return 1;\n#endif\n  }\n  return 0;\n}\n#if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_TRIGGER)\nSQLITE_PRIVATE int sqlite3FixSelect(\n  DbFixer *pFix,       /* Context of the fixation */\n  Select *pSelect      /* The SELECT statement to be fixed to one database */\n){\n  while( pSelect ){\n    if( sqlite3FixExprList(pFix, pSelect->pEList) ){\n      return 1;\n    }\n    if( sqlite3FixSrcList(pFix, pSelect->pSrc) ){\n      return 1;\n    }\n    if( sqlite3FixExpr(pFix, pSelect->pWhere) ){\n      return 1;\n    }\n    if( sqlite3FixExpr(pFix, pSelect->pHaving) ){\n      return 1;\n    }\n    pSelect = pSelect->pPrior;\n  }\n  return 0;\n}\nSQLITE_PRIVATE int sqlite3FixExpr(\n  DbFixer *pFix,     /* Context of the fixation */\n  Expr *pExpr        /* The expression to be fixed to one database */\n){\n  while( pExpr ){\n    if( ExprHasAnyProperty(pExpr, EP_TokenOnly) ) break;\n    if( ExprHasProperty(pExpr, EP_xIsSelect) ){\n      if( sqlite3FixSelect(pFix, pExpr->x.pSelect) ) return 1;\n    }else{\n      if( sqlite3FixExprList(pFix, pExpr->x.pList) ) return 1;\n    }\n    if( sqlite3FixExpr(pFix, pExpr->pRight) ){\n      return 1;\n    }\n    pExpr = pExpr->pLeft;\n  }\n  return 0;\n}\nSQLITE_PRIVATE int sqlite3FixExprList(\n  DbFixer *pFix,     /* Context of the fixation */\n  ExprList *pList    /* The expression to be fixed to one database */\n){\n  int i;\n  struct ExprList_item *pItem;\n  if( pList==0 ) return 0;\n  for(i=0, pItem=pList->a; i<pList->nExpr; i++, pItem++){\n    if( sqlite3FixExpr(pFix, pItem->pExpr) ){\n      return 1;\n    }\n  }\n  return 0;\n}\n#endif\n\n#ifndef SQLITE_OMIT_TRIGGER\nSQLITE_PRIVATE int sqlite3FixTriggerStep(\n  DbFixer *pFix,     /* Context of the fixation */\n  TriggerStep *pStep /* The trigger step be fixed to one database */\n){\n  while( pStep ){\n    if( sqlite3FixSelect(pFix, pStep->pSelect) ){\n      return 1;\n    }\n    if( sqlite3FixExpr(pFix, pStep->pWhere) ){\n      return 1;\n    }\n    if( sqlite3FixExprList(pFix, pStep->pExprList) ){\n      return 1;\n    }\n    pStep = pStep->pNext;\n  }\n  return 0;\n}\n#endif\n\n/************** End of attach.c **********************************************/\n/************** Begin file auth.c ********************************************/\n/*\n** 2003 January 11\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains code used to implement the sqlite3_set_authorizer()\n** API.  This facility is an optional feature of the library.  Embedded\n** systems that do not need this facility may omit it by recompiling\n** the library with -DSQLITE_OMIT_AUTHORIZATION=1\n*/\n\n/*\n** All of the code in this file may be omitted by defining a single\n** macro.\n*/\n#ifndef SQLITE_OMIT_AUTHORIZATION\n\n/*\n** Set or clear the access authorization function.\n**\n** The access authorization function is be called during the compilation\n** phase to verify that the user has read and/or write access permission on\n** various fields of the database.  The first argument to the auth function\n** is a copy of the 3rd argument to this routine.  The second argument\n** to the auth function is one of these constants:\n**\n**       SQLITE_CREATE_INDEX\n**       SQLITE_CREATE_TABLE\n**       SQLITE_CREATE_TEMP_INDEX\n**       SQLITE_CREATE_TEMP_TABLE\n**       SQLITE_CREATE_TEMP_TRIGGER\n**       SQLITE_CREATE_TEMP_VIEW\n**       SQLITE_CREATE_TRIGGER\n**       SQLITE_CREATE_VIEW\n**       SQLITE_DELETE\n**       SQLITE_DROP_INDEX\n**       SQLITE_DROP_TABLE\n**       SQLITE_DROP_TEMP_INDEX\n**       SQLITE_DROP_TEMP_TABLE\n**       SQLITE_DROP_TEMP_TRIGGER\n**       SQLITE_DROP_TEMP_VIEW\n**       SQLITE_DROP_TRIGGER\n**       SQLITE_DROP_VIEW\n**       SQLITE_INSERT\n**       SQLITE_PRAGMA\n**       SQLITE_READ\n**       SQLITE_SELECT\n**       SQLITE_TRANSACTION\n**       SQLITE_UPDATE\n**\n** The third and fourth arguments to the auth function are the name of\n** the table and the column that are being accessed.  The auth function\n** should return either SQLITE_OK, SQLITE_DENY, or SQLITE_IGNORE.  If\n** SQLITE_OK is returned, it means that access is allowed.  SQLITE_DENY\n** means that the SQL statement will never-run - the sqlite3_exec() call\n** will return with an error.  SQLITE_IGNORE means that the SQL statement\n** should run but attempts to read the specified column will return NULL\n** and attempts to write the column will be ignored.\n**\n** Setting the auth function to NULL disables this hook.  The default\n** setting of the auth function is NULL.\n*/\nSQLITE_API int sqlite3_set_authorizer(\n  sqlite3 *db,\n  int (*xAuth)(void*,int,const char*,const char*,const char*,const char*),\n  void *pArg\n){\n  sqlite3_mutex_enter(db->mutex);\n  db->xAuth = xAuth;\n  db->pAuthArg = pArg;\n  sqlite3ExpirePreparedStatements(db);\n  sqlite3_mutex_leave(db->mutex);\n  return SQLITE_OK;\n}\n\n/*\n** Write an error message into pParse->zErrMsg that explains that the\n** user-supplied authorization function returned an illegal value.\n*/\nstatic void sqliteAuthBadReturnCode(Parse *pParse){\n  sqlite3ErrorMsg(pParse, \"authorizer malfunction\");\n  pParse->rc = SQLITE_ERROR;\n}\n\n/*\n** Invoke the authorization callback for permission to read column zCol from\n** table zTab in database zDb. This function assumes that an authorization\n** callback has been registered (i.e. that sqlite3.xAuth is not NULL).\n**\n** If SQLITE_IGNORE is returned and pExpr is not NULL, then pExpr is changed\n** to an SQL NULL expression. Otherwise, if pExpr is NULL, then SQLITE_IGNORE\n** is treated as SQLITE_DENY. In this case an error is left in pParse.\n*/\nSQLITE_PRIVATE int sqlite3AuthReadCol(\n  Parse *pParse,                  /* The parser context */\n  const char *zTab,               /* Table name */\n  const char *zCol,               /* Column name */\n  int iDb                         /* Index of containing database. */\n){\n  sqlite3 *db = pParse->db;       /* Database handle */\n  char *zDb = db->aDb[iDb].zName; /* Name of attached database */\n  int rc;                         /* Auth callback return code */\n\n  rc = db->xAuth(db->pAuthArg, SQLITE_READ, zTab,zCol,zDb,pParse->zAuthContext);\n  if( rc==SQLITE_DENY ){\n    if( db->nDb>2 || iDb!=0 ){\n      sqlite3ErrorMsg(pParse, \"access to %s.%s.%s is prohibited\",zDb,zTab,zCol);\n    }else{\n      sqlite3ErrorMsg(pParse, \"access to %s.%s is prohibited\", zTab, zCol);\n    }\n    pParse->rc = SQLITE_AUTH;\n  }else if( rc!=SQLITE_IGNORE && rc!=SQLITE_OK ){\n    sqliteAuthBadReturnCode(pParse);\n  }\n  return rc;\n}\n\n/*\n** The pExpr should be a TK_COLUMN expression.  The table referred to\n** is in pTabList or else it is the NEW or OLD table of a trigger.  \n** Check to see if it is OK to read this particular column.\n**\n** If the auth function returns SQLITE_IGNORE, change the TK_COLUMN \n** instruction into a TK_NULL.  If the auth function returns SQLITE_DENY,\n** then generate an error.\n*/\nSQLITE_PRIVATE void sqlite3AuthRead(\n  Parse *pParse,        /* The parser context */\n  Expr *pExpr,          /* The expression to check authorization on */\n  Schema *pSchema,      /* The schema of the expression */\n  SrcList *pTabList     /* All table that pExpr might refer to */\n){\n  sqlite3 *db = pParse->db;\n  Table *pTab = 0;      /* The table being read */\n  const char *zCol;     /* Name of the column of the table */\n  int iSrc;             /* Index in pTabList->a[] of table being read */\n  int iDb;              /* The index of the database the expression refers to */\n  int iCol;             /* Index of column in table */\n\n  if( db->xAuth==0 ) return;\n  iDb = sqlite3SchemaToIndex(pParse->db, pSchema);\n  if( iDb<0 ){\n    /* An attempt to read a column out of a subquery or other\n    ** temporary table. */\n    return;\n  }\n\n  assert( pExpr->op==TK_COLUMN || pExpr->op==TK_TRIGGER );\n  if( pExpr->op==TK_TRIGGER ){\n    pTab = pParse->pTriggerTab;\n  }else{\n    assert( pTabList );\n    for(iSrc=0; ALWAYS(iSrc<pTabList->nSrc); iSrc++){\n      if( pExpr->iTable==pTabList->a[iSrc].iCursor ){\n        pTab = pTabList->a[iSrc].pTab;\n        break;\n      }\n    }\n  }\n  iCol = pExpr->iColumn;\n  if( NEVER(pTab==0) ) return;\n\n  if( iCol>=0 ){\n    assert( iCol<pTab->nCol );\n    zCol = pTab->aCol[iCol].zName;\n  }else if( pTab->iPKey>=0 ){\n    assert( pTab->iPKey<pTab->nCol );\n    zCol = pTab->aCol[pTab->iPKey].zName;\n  }else{\n    zCol = \"ROWID\";\n  }\n  assert( iDb>=0 && iDb<db->nDb );\n  if( SQLITE_IGNORE==sqlite3AuthReadCol(pParse, pTab->zName, zCol, iDb) ){\n    pExpr->op = TK_NULL;\n  }\n}\n\n/*\n** Do an authorization check using the code and arguments given.  Return\n** either SQLITE_OK (zero) or SQLITE_IGNORE or SQLITE_DENY.  If SQLITE_DENY\n** is returned, then the error count and error message in pParse are\n** modified appropriately.\n*/\nSQLITE_PRIVATE int sqlite3AuthCheck(\n  Parse *pParse,\n  int code,\n  const char *zArg1,\n  const char *zArg2,\n  const char *zArg3\n){\n  sqlite3 *db = pParse->db;\n  int rc;\n\n  /* Don't do any authorization checks if the database is initialising\n  ** or if the parser is being invoked from within sqlite3_declare_vtab.\n  */\n  if( db->init.busy || IN_DECLARE_VTAB ){\n    return SQLITE_OK;\n  }\n\n  if( db->xAuth==0 ){\n    return SQLITE_OK;\n  }\n  rc = db->xAuth(db->pAuthArg, code, zArg1, zArg2, zArg3, pParse->zAuthContext);\n  if( rc==SQLITE_DENY ){\n    sqlite3ErrorMsg(pParse, \"not authorized\");\n    pParse->rc = SQLITE_AUTH;\n  }else if( rc!=SQLITE_OK && rc!=SQLITE_IGNORE ){\n    rc = SQLITE_DENY;\n    sqliteAuthBadReturnCode(pParse);\n  }\n  return rc;\n}\n\n/*\n** Push an authorization context.  After this routine is called, the\n** zArg3 argument to authorization callbacks will be zContext until\n** popped.  Or if pParse==0, this routine is a no-op.\n*/\nSQLITE_PRIVATE void sqlite3AuthContextPush(\n  Parse *pParse,\n  AuthContext *pContext, \n  const char *zContext\n){\n  assert( pParse );\n  pContext->pParse = pParse;\n  pContext->zAuthContext = pParse->zAuthContext;\n  pParse->zAuthContext = zContext;\n}\n\n/*\n** Pop an authorization context that was previously pushed\n** by sqlite3AuthContextPush\n*/\nSQLITE_PRIVATE void sqlite3AuthContextPop(AuthContext *pContext){\n  if( pContext->pParse ){\n    pContext->pParse->zAuthContext = pContext->zAuthContext;\n    pContext->pParse = 0;\n  }\n}\n\n#endif /* SQLITE_OMIT_AUTHORIZATION */\n\n/************** End of auth.c ************************************************/\n/************** Begin file build.c *******************************************/\n/*\n** 2001 September 15\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains C code routines that are called by the SQLite parser\n** when syntax rules are reduced.  The routines in this file handle the\n** following kinds of SQL syntax:\n**\n**     CREATE TABLE\n**     DROP TABLE\n**     CREATE INDEX\n**     DROP INDEX\n**     creating ID lists\n**     BEGIN TRANSACTION\n**     COMMIT\n**     ROLLBACK\n*/\n\n/*\n** This routine is called when a new SQL statement is beginning to\n** be parsed.  Initialize the pParse structure as needed.\n*/\nSQLITE_PRIVATE void sqlite3BeginParse(Parse *pParse, int explainFlag){\n  pParse->explain = (u8)explainFlag;\n  pParse->nVar = 0;\n}\n\n#ifndef SQLITE_OMIT_SHARED_CACHE\n/*\n** The TableLock structure is only used by the sqlite3TableLock() and\n** codeTableLocks() functions.\n*/\nstruct TableLock {\n  int iDb;             /* The database containing the table to be locked */\n  int iTab;            /* The root page of the table to be locked */\n  u8 isWriteLock;      /* True for write lock.  False for a read lock */\n  const char *zName;   /* Name of the table */\n};\n\n/*\n** Record the fact that we want to lock a table at run-time.  \n**\n** The table to be locked has root page iTab and is found in database iDb.\n** A read or a write lock can be taken depending on isWritelock.\n**\n** This routine just records the fact that the lock is desired.  The\n** code to make the lock occur is generated by a later call to\n** codeTableLocks() which occurs during sqlite3FinishCoding().\n*/\nSQLITE_PRIVATE void sqlite3TableLock(\n  Parse *pParse,     /* Parsing context */\n  int iDb,           /* Index of the database containing the table to lock */\n  int iTab,          /* Root page number of the table to be locked */\n  u8 isWriteLock,    /* True for a write lock */\n  const char *zName  /* Name of the table to be locked */\n){\n  Parse *pToplevel = sqlite3ParseToplevel(pParse);\n  int i;\n  int nBytes;\n  TableLock *p;\n  assert( iDb>=0 );\n\n  for(i=0; i<pToplevel->nTableLock; i++){\n    p = &pToplevel->aTableLock[i];\n    if( p->iDb==iDb && p->iTab==iTab ){\n      p->isWriteLock = (p->isWriteLock || isWriteLock);\n      return;\n    }\n  }\n\n  nBytes = sizeof(TableLock) * (pToplevel->nTableLock+1);\n  pToplevel->aTableLock =\n      sqlite3DbReallocOrFree(pToplevel->db, pToplevel->aTableLock, nBytes);\n  if( pToplevel->aTableLock ){\n    p = &pToplevel->aTableLock[pToplevel->nTableLock++];\n    p->iDb = iDb;\n    p->iTab = iTab;\n    p->isWriteLock = isWriteLock;\n    p->zName = zName;\n  }else{\n    pToplevel->nTableLock = 0;\n    pToplevel->db->mallocFailed = 1;\n  }\n}\n\n/*\n** Code an OP_TableLock instruction for each table locked by the\n** statement (configured by calls to sqlite3TableLock()).\n*/\nstatic void codeTableLocks(Parse *pParse){\n  int i;\n  Vdbe *pVdbe; \n\n  pVdbe = sqlite3GetVdbe(pParse);\n  assert( pVdbe!=0 ); /* sqlite3GetVdbe cannot fail: VDBE already allocated */\n\n  for(i=0; i<pParse->nTableLock; i++){\n    TableLock *p = &pParse->aTableLock[i];\n    int p1 = p->iDb;\n    sqlite3VdbeAddOp4(pVdbe, OP_TableLock, p1, p->iTab, p->isWriteLock,\n                      p->zName, P4_STATIC);\n  }\n}\n#else\n  #define codeTableLocks(x)\n#endif\n\n/*\n** This routine is called after a single SQL statement has been\n** parsed and a VDBE program to execute that statement has been\n** prepared.  This routine puts the finishing touches on the\n** VDBE program and resets the pParse structure for the next\n** parse.\n**\n** Note that if an error occurred, it might be the case that\n** no VDBE code was generated.\n*/\nSQLITE_PRIVATE void sqlite3FinishCoding(Parse *pParse){\n  sqlite3 *db;\n  Vdbe *v;\n\n  db = pParse->db;\n  if( db->mallocFailed ) return;\n  if( pParse->nested ) return;\n  if( pParse->nErr ) return;\n\n  /* Begin by generating some termination code at the end of the\n  ** vdbe program\n  */\n  v = sqlite3GetVdbe(pParse);\n  assert( !pParse->isMultiWrite \n       || sqlite3VdbeAssertMayAbort(v, pParse->mayAbort));\n  if( v ){\n    sqlite3VdbeAddOp0(v, OP_Halt);\n\n    /* The cookie mask contains one bit for each database file open.\n    ** (Bit 0 is for main, bit 1 is for temp, and so forth.)  Bits are\n    ** set for each database that is used.  Generate code to start a\n    ** transaction on each used database and to verify the schema cookie\n    ** on each used database.\n    */\n    if( pParse->cookieGoto>0 ){\n      u32 mask;\n      int iDb;\n      sqlite3VdbeJumpHere(v, pParse->cookieGoto-1);\n      for(iDb=0, mask=1; iDb<db->nDb; mask<<=1, iDb++){\n        if( (mask & pParse->cookieMask)==0 ) continue;\n        sqlite3VdbeUsesBtree(v, iDb);\n        sqlite3VdbeAddOp2(v,OP_Transaction, iDb, (mask & pParse->writeMask)!=0);\n        if( db->init.busy==0 ){\n          sqlite3VdbeAddOp2(v,OP_VerifyCookie, iDb, pParse->cookieValue[iDb]);\n        }\n      }\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n      {\n        int i;\n        for(i=0; i<pParse->nVtabLock; i++){\n          char *vtab = (char *)sqlite3GetVTable(db, pParse->apVtabLock[i]);\n          sqlite3VdbeAddOp4(v, OP_VBegin, 0, 0, 0, vtab, P4_VTAB);\n        }\n        pParse->nVtabLock = 0;\n      }\n#endif\n\n      /* Once all the cookies have been verified and transactions opened, \n      ** obtain the required table-locks. This is a no-op unless the \n      ** shared-cache feature is enabled.\n      */\n      codeTableLocks(pParse);\n\n      /* Initialize any AUTOINCREMENT data structures required.\n      */\n      sqlite3AutoincrementBegin(pParse);\n\n      /* Finally, jump back to the beginning of the executable code. */\n      sqlite3VdbeAddOp2(v, OP_Goto, 0, pParse->cookieGoto);\n    }\n  }\n\n\n  /* Get the VDBE program ready for execution\n  */\n  if( v && ALWAYS(pParse->nErr==0) && !db->mallocFailed ){\n#ifdef SQLITE_DEBUG\n    FILE *trace = (db->flags & SQLITE_VdbeTrace)!=0 ? stdout : 0;\n    sqlite3VdbeTrace(v, trace);\n#endif\n    assert( pParse->iCacheLevel==0 );  /* Disables and re-enables match */\n    /* A minimum of one cursor is required if autoincrement is used\n    *  See ticket [a696379c1f08866] */\n    if( pParse->pAinc!=0 && pParse->nTab==0 ) pParse->nTab = 1;\n    sqlite3VdbeMakeReady(v, pParse->nVar, pParse->nMem,\n                         pParse->nTab, pParse->nMaxArg, pParse->explain,\n                         pParse->isMultiWrite && pParse->mayAbort);\n    pParse->rc = SQLITE_DONE;\n    pParse->colNamesSet = 0;\n  }else{\n    pParse->rc = SQLITE_ERROR;\n  }\n  pParse->nTab = 0;\n  pParse->nMem = 0;\n  pParse->nSet = 0;\n  pParse->nVar = 0;\n  pParse->cookieMask = 0;\n  pParse->cookieGoto = 0;\n}\n\n/*\n** Run the parser and code generator recursively in order to generate\n** code for the SQL statement given onto the end of the pParse context\n** currently under construction.  When the parser is run recursively\n** this way, the final OP_Halt is not appended and other initialization\n** and finalization steps are omitted because those are handling by the\n** outermost parser.\n**\n** Not everything is nestable.  This facility is designed to permit\n** INSERT, UPDATE, and DELETE operations against SQLITE_MASTER.  Use\n** care if you decide to try to use this routine for some other purposes.\n*/\nSQLITE_PRIVATE void sqlite3NestedParse(Parse *pParse, const char *zFormat, ...){\n  va_list ap;\n  char *zSql;\n  char *zErrMsg = 0;\n  sqlite3 *db = pParse->db;\n# define SAVE_SZ  (sizeof(Parse) - offsetof(Parse,nVar))\n  char saveBuf[SAVE_SZ];\n\n  if( pParse->nErr ) return;\n  assert( pParse->nested<10 );  /* Nesting should only be of limited depth */\n  va_start(ap, zFormat);\n  zSql = sqlite3VMPrintf(db, zFormat, ap);\n  va_end(ap);\n  if( zSql==0 ){\n    return;   /* A malloc must have failed */\n  }\n  pParse->nested++;\n  memcpy(saveBuf, &pParse->nVar, SAVE_SZ);\n  memset(&pParse->nVar, 0, SAVE_SZ);\n  sqlite3RunParser(pParse, zSql, &zErrMsg);\n  sqlite3DbFree(db, zErrMsg);\n  sqlite3DbFree(db, zSql);\n  memcpy(&pParse->nVar, saveBuf, SAVE_SZ);\n  pParse->nested--;\n}\n\n/*\n** Locate the in-memory structure that describes a particular database\n** table given the name of that table and (optionally) the name of the\n** database containing the table.  Return NULL if not found.\n**\n** If zDatabase is 0, all databases are searched for the table and the\n** first matching table is returned.  (No checking for duplicate table\n** names is done.)  The search order is TEMP first, then MAIN, then any\n** auxiliary databases added using the ATTACH command.\n**\n** See also sqlite3LocateTable().\n*/\nSQLITE_PRIVATE Table *sqlite3FindTable(sqlite3 *db, const char *zName, const char *zDatabase){\n  Table *p = 0;\n  int i;\n  int nName;\n  assert( zName!=0 );\n  nName = sqlite3Strlen30(zName);\n  for(i=OMIT_TEMPDB; i<db->nDb; i++){\n    int j = (i<2) ? i^1 : i;   /* Search TEMP before MAIN */\n    if( zDatabase!=0 && sqlite3StrICmp(zDatabase, db->aDb[j].zName) ) continue;\n    p = sqlite3HashFind(&db->aDb[j].pSchema->tblHash, zName, nName);\n    if( p ) break;\n  }\n  return p;\n}\n\n/*\n** Locate the in-memory structure that describes a particular database\n** table given the name of that table and (optionally) the name of the\n** database containing the table.  Return NULL if not found.  Also leave an\n** error message in pParse->zErrMsg.\n**\n** The difference between this routine and sqlite3FindTable() is that this\n** routine leaves an error message in pParse->zErrMsg where\n** sqlite3FindTable() does not.\n*/\nSQLITE_PRIVATE Table *sqlite3LocateTable(\n  Parse *pParse,         /* context in which to report errors */\n  int isView,            /* True if looking for a VIEW rather than a TABLE */\n  const char *zName,     /* Name of the table we are looking for */\n  const char *zDbase     /* Name of the database.  Might be NULL */\n){\n  Table *p;\n\n  /* Read the database schema. If an error occurs, leave an error message\n  ** and code in pParse and return NULL. */\n  if( SQLITE_OK!=sqlite3ReadSchema(pParse) ){\n    return 0;\n  }\n\n  p = sqlite3FindTable(pParse->db, zName, zDbase);\n  if( p==0 ){\n    const char *zMsg = isView ? \"no such view\" : \"no such table\";\n    if( zDbase ){\n      sqlite3ErrorMsg(pParse, \"%s: %s.%s\", zMsg, zDbase, zName);\n    }else{\n      sqlite3ErrorMsg(pParse, \"%s: %s\", zMsg, zName);\n    }\n    pParse->checkSchema = 1;\n  }\n  return p;\n}\n\n/*\n** Locate the in-memory structure that describes \n** a particular index given the name of that index\n** and the name of the database that contains the index.\n** Return NULL if not found.\n**\n** If zDatabase is 0, all databases are searched for the\n** table and the first matching index is returned.  (No checking\n** for duplicate index names is done.)  The search order is\n** TEMP first, then MAIN, then any auxiliary databases added\n** using the ATTACH command.\n*/\nSQLITE_PRIVATE Index *sqlite3FindIndex(sqlite3 *db, const char *zName, const char *zDb){\n  Index *p = 0;\n  int i;\n  int nName = sqlite3Strlen30(zName);\n  for(i=OMIT_TEMPDB; i<db->nDb; i++){\n    int j = (i<2) ? i^1 : i;  /* Search TEMP before MAIN */\n    Schema *pSchema = db->aDb[j].pSchema;\n    assert( pSchema );\n    if( zDb && sqlite3StrICmp(zDb, db->aDb[j].zName) ) continue;\n    p = sqlite3HashFind(&pSchema->idxHash, zName, nName);\n    if( p ) break;\n  }\n  return p;\n}\n\n/*\n** Reclaim the memory used by an index\n*/\nstatic void freeIndex(sqlite3 *db, Index *p){\n#ifndef SQLITE_OMIT_ANALYZE\n  sqlite3DeleteIndexSamples(db, p);\n#endif\n  sqlite3DbFree(db, p->zColAff);\n  sqlite3DbFree(db, p);\n}\n\n/*\n** For the index called zIdxName which is found in the database iDb,\n** unlike that index from its Table then remove the index from\n** the index hash table and free all memory structures associated\n** with the index.\n*/\nSQLITE_PRIVATE void sqlite3UnlinkAndDeleteIndex(sqlite3 *db, int iDb, const char *zIdxName){\n  Index *pIndex;\n  int len;\n  Hash *pHash = &db->aDb[iDb].pSchema->idxHash;\n\n  len = sqlite3Strlen30(zIdxName);\n  pIndex = sqlite3HashInsert(pHash, zIdxName, len, 0);\n  if( pIndex ){\n    if( pIndex->pTable->pIndex==pIndex ){\n      pIndex->pTable->pIndex = pIndex->pNext;\n    }else{\n      Index *p;\n      /* Justification of ALWAYS();  The index must be on the list of\n      ** indices. */\n      p = pIndex->pTable->pIndex;\n      while( ALWAYS(p) && p->pNext!=pIndex ){ p = p->pNext; }\n      if( ALWAYS(p && p->pNext==pIndex) ){\n        p->pNext = pIndex->pNext;\n      }\n    }\n    freeIndex(db, pIndex);\n  }\n  db->flags |= SQLITE_InternChanges;\n}\n\n/*\n** Erase all schema information from the in-memory hash tables of\n** a single database.  This routine is called to reclaim memory\n** before the database closes.  It is also called during a rollback\n** if there were schema changes during the transaction or if a\n** schema-cookie mismatch occurs.\n**\n** If iDb==0 then reset the internal schema tables for all database\n** files.  If iDb>=1 then reset the internal schema for only the\n** single file indicated.\n*/\nSQLITE_PRIVATE void sqlite3ResetInternalSchema(sqlite3 *db, int iDb){\n  int i, j;\n  assert( iDb>=0 && iDb<db->nDb );\n\n  if( iDb==0 ){\n    sqlite3BtreeEnterAll(db);\n  }\n  for(i=iDb; i<db->nDb; i++){\n    Db *pDb = &db->aDb[i];\n    if( pDb->pSchema ){\n      assert(i==1 || (pDb->pBt && sqlite3BtreeHoldsMutex(pDb->pBt)));\n      sqlite3SchemaFree(pDb->pSchema);\n    }\n    if( iDb>0 ) return;\n  }\n  assert( iDb==0 );\n  db->flags &= ~SQLITE_InternChanges;\n  sqlite3VtabUnlockList(db);\n  sqlite3BtreeLeaveAll(db);\n\n  /* If one or more of the auxiliary database files has been closed,\n  ** then remove them from the auxiliary database list.  We take the\n  ** opportunity to do this here since we have just deleted all of the\n  ** schema hash tables and therefore do not have to make any changes\n  ** to any of those tables.\n  */\n  for(i=j=2; i<db->nDb; i++){\n    struct Db *pDb = &db->aDb[i];\n    if( pDb->pBt==0 ){\n      sqlite3DbFree(db, pDb->zName);\n      pDb->zName = 0;\n      continue;\n    }\n    if( j<i ){\n      db->aDb[j] = db->aDb[i];\n    }\n    j++;\n  }\n  memset(&db->aDb[j], 0, (db->nDb-j)*sizeof(db->aDb[j]));\n  db->nDb = j;\n  if( db->nDb<=2 && db->aDb!=db->aDbStatic ){\n    memcpy(db->aDbStatic, db->aDb, 2*sizeof(db->aDb[0]));\n    sqlite3DbFree(db, db->aDb);\n    db->aDb = db->aDbStatic;\n  }\n}\n\n/*\n** This routine is called when a commit occurs.\n*/\nSQLITE_PRIVATE void sqlite3CommitInternalChanges(sqlite3 *db){\n  db->flags &= ~SQLITE_InternChanges;\n}\n\n/*\n** Delete memory allocated for the column names of a table or view (the\n** Table.aCol[] array).\n*/\nstatic void sqliteDeleteColumnNames(sqlite3 *db, Table *pTable){\n  int i;\n  Column *pCol;\n  assert( pTable!=0 );\n  if( (pCol = pTable->aCol)!=0 ){\n    for(i=0; i<pTable->nCol; i++, pCol++){\n      sqlite3DbFree(db, pCol->zName);\n      sqlite3ExprDelete(db, pCol->pDflt);\n      sqlite3DbFree(db, pCol->zDflt);\n      sqlite3DbFree(db, pCol->zType);\n      sqlite3DbFree(db, pCol->zColl);\n    }\n    sqlite3DbFree(db, pTable->aCol);\n  }\n}\n\n/*\n** Remove the memory data structures associated with the given\n** Table.  No changes are made to disk by this routine.\n**\n** This routine just deletes the data structure.  It does not unlink\n** the table data structure from the hash table.  But it does destroy\n** memory structures of the indices and foreign keys associated with \n** the table.\n*/\nSQLITE_PRIVATE void sqlite3DeleteTable(sqlite3 *db, Table *pTable){\n  Index *pIndex, *pNext;\n\n  assert( !pTable || pTable->nRef>0 );\n\n  /* Do not delete the table until the reference count reaches zero. */\n  if( !pTable ) return;\n  if( ((!db || db->pnBytesFreed==0) && (--pTable->nRef)>0) ) return;\n\n  /* Delete all indices associated with this table. */\n  for(pIndex = pTable->pIndex; pIndex; pIndex=pNext){\n    pNext = pIndex->pNext;\n    assert( pIndex->pSchema==pTable->pSchema );\n    if( !db || db->pnBytesFreed==0 ){\n      char *zName = pIndex->zName; \n      TESTONLY ( Index *pOld = ) sqlite3HashInsert(\n      &pIndex->pSchema->idxHash, zName, sqlite3Strlen30(zName), 0\n      );\n      assert( pOld==pIndex || pOld==0 );\n    }\n    freeIndex(db, pIndex);\n  }\n\n  /* Delete any foreign keys attached to this table. */\n  sqlite3FkDelete(db, pTable);\n\n  /* Delete the Table structure itself.\n  */\n  sqliteDeleteColumnNames(db, pTable);\n  sqlite3DbFree(db, pTable->zName);\n  sqlite3DbFree(db, pTable->zColAff);\n  sqlite3SelectDelete(db, pTable->pSelect);\n#ifndef SQLITE_OMIT_CHECK\n  sqlite3ExprDelete(db, pTable->pCheck);\n#endif\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  sqlite3VtabClear(db, pTable);\n#endif\n  sqlite3DbFree(db, pTable);\n}\n\n/*\n** Unlink the given table from the hash tables and the delete the\n** table structure with all its indices and foreign keys.\n*/\nSQLITE_PRIVATE void sqlite3UnlinkAndDeleteTable(sqlite3 *db, int iDb, const char *zTabName){\n  Table *p;\n  Db *pDb;\n\n  assert( db!=0 );\n  assert( iDb>=0 && iDb<db->nDb );\n  assert( zTabName );\n  testcase( zTabName[0]==0 );  /* Zero-length table names are allowed */\n  pDb = &db->aDb[iDb];\n  p = sqlite3HashInsert(&pDb->pSchema->tblHash, zTabName,\n                        sqlite3Strlen30(zTabName),0);\n  sqlite3DeleteTable(db, p);\n  db->flags |= SQLITE_InternChanges;\n}\n\n/*\n** Given a token, return a string that consists of the text of that\n** token.  Space to hold the returned string\n** is obtained from sqliteMalloc() and must be freed by the calling\n** function.\n**\n** Any quotation marks (ex:  \"name\", 'name', [name], or `name`) that\n** surround the body of the token are removed.\n**\n** Tokens are often just pointers into the original SQL text and so\n** are not \\000 terminated and are not persistent.  The returned string\n** is \\000 terminated and is persistent.\n*/\nSQLITE_PRIVATE char *sqlite3NameFromToken(sqlite3 *db, Token *pName){\n  char *zName;\n  if( pName ){\n    zName = sqlite3DbStrNDup(db, (char*)pName->z, pName->n);\n    sqlite3Dequote(zName);\n  }else{\n    zName = 0;\n  }\n  return zName;\n}\n\n/*\n** Open the sqlite_master table stored in database number iDb for\n** writing. The table is opened using cursor 0.\n*/\nSQLITE_PRIVATE void sqlite3OpenMasterTable(Parse *p, int iDb){\n  Vdbe *v = sqlite3GetVdbe(p);\n  sqlite3TableLock(p, iDb, MASTER_ROOT, 1, SCHEMA_TABLE(iDb));\n  sqlite3VdbeAddOp3(v, OP_OpenWrite, 0, MASTER_ROOT, iDb);\n  sqlite3VdbeChangeP4(v, -1, (char *)5, P4_INT32);  /* 5 column table */\n  if( p->nTab==0 ){\n    p->nTab = 1;\n  }\n}\n\n/*\n** Parameter zName points to a nul-terminated buffer containing the name\n** of a database (\"main\", \"temp\" or the name of an attached db). This\n** function returns the index of the named database in db->aDb[], or\n** -1 if the named db cannot be found.\n*/\nSQLITE_PRIVATE int sqlite3FindDbName(sqlite3 *db, const char *zName){\n  int i = -1;         /* Database number */\n  if( zName ){\n    Db *pDb;\n    int n = sqlite3Strlen30(zName);\n    for(i=(db->nDb-1), pDb=&db->aDb[i]; i>=0; i--, pDb--){\n      if( (!OMIT_TEMPDB || i!=1 ) && n==sqlite3Strlen30(pDb->zName) && \n          0==sqlite3StrICmp(pDb->zName, zName) ){\n        break;\n      }\n    }\n  }\n  return i;\n}\n\n/*\n** The token *pName contains the name of a database (either \"main\" or\n** \"temp\" or the name of an attached db). This routine returns the\n** index of the named database in db->aDb[], or -1 if the named db \n** does not exist.\n*/\nSQLITE_PRIVATE int sqlite3FindDb(sqlite3 *db, Token *pName){\n  int i;                               /* Database number */\n  char *zName;                         /* Name we are searching for */\n  zName = sqlite3NameFromToken(db, pName);\n  i = sqlite3FindDbName(db, zName);\n  sqlite3DbFree(db, zName);\n  return i;\n}\n\n/* The table or view or trigger name is passed to this routine via tokens\n** pName1 and pName2. If the table name was fully qualified, for example:\n**\n** CREATE TABLE xxx.yyy (...);\n** \n** Then pName1 is set to \"xxx\" and pName2 \"yyy\". On the other hand if\n** the table name is not fully qualified, i.e.:\n**\n** CREATE TABLE yyy(...);\n**\n** Then pName1 is set to \"yyy\" and pName2 is \"\".\n**\n** This routine sets the *ppUnqual pointer to point at the token (pName1 or\n** pName2) that stores the unqualified table name.  The index of the\n** database \"xxx\" is returned.\n*/\nSQLITE_PRIVATE int sqlite3TwoPartName(\n  Parse *pParse,      /* Parsing and code generating context */\n  Token *pName1,      /* The \"xxx\" in the name \"xxx.yyy\" or \"xxx\" */\n  Token *pName2,      /* The \"yyy\" in the name \"xxx.yyy\" */\n  Token **pUnqual     /* Write the unqualified object name here */\n){\n  int iDb;                    /* Database holding the object */\n  sqlite3 *db = pParse->db;\n\n  if( ALWAYS(pName2!=0) && pName2->n>0 ){\n    if( db->init.busy ) {\n      sqlite3ErrorMsg(pParse, \"corrupt database\");\n      pParse->nErr++;\n      return -1;\n    }\n    *pUnqual = pName2;\n    iDb = sqlite3FindDb(db, pName1);\n    if( iDb<0 ){\n      sqlite3ErrorMsg(pParse, \"unknown database %T\", pName1);\n      pParse->nErr++;\n      return -1;\n    }\n  }else{\n    assert( db->init.iDb==0 || db->init.busy );\n    iDb = db->init.iDb;\n    *pUnqual = pName1;\n  }\n  return iDb;\n}\n\n/*\n** This routine is used to check if the UTF-8 string zName is a legal\n** unqualified name for a new schema object (table, index, view or\n** trigger). All names are legal except those that begin with the string\n** \"sqlite_\" (in upper, lower or mixed case). This portion of the namespace\n** is reserved for internal use.\n*/\nSQLITE_PRIVATE int sqlite3CheckObjectName(Parse *pParse, const char *zName){\n  if( !pParse->db->init.busy && pParse->nested==0 \n          && (pParse->db->flags & SQLITE_WriteSchema)==0\n          && 0==sqlite3StrNICmp(zName, \"sqlite_\", 7) ){\n    sqlite3ErrorMsg(pParse, \"object name reserved for internal use: %s\", zName);\n    return SQLITE_ERROR;\n  }\n  return SQLITE_OK;\n}\n\n/*\n** Begin constructing a new table representation in memory.  This is\n** the first of several action routines that get called in response\n** to a CREATE TABLE statement.  In particular, this routine is called\n** after seeing tokens \"CREATE\" and \"TABLE\" and the table name. The isTemp\n** flag is true if the table should be stored in the auxiliary database\n** file instead of in the main database file.  This is normally the case\n** when the \"TEMP\" or \"TEMPORARY\" keyword occurs in between\n** CREATE and TABLE.\n**\n** The new table record is initialized and put in pParse->pNewTable.\n** As more of the CREATE TABLE statement is parsed, additional action\n** routines will be called to add more information to this record.\n** At the end of the CREATE TABLE statement, the sqlite3EndTable() routine\n** is called to complete the construction of the new table record.\n*/\nSQLITE_PRIVATE void sqlite3StartTable(\n  Parse *pParse,   /* Parser context */\n  Token *pName1,   /* First part of the name of the table or view */\n  Token *pName2,   /* Second part of the name of the table or view */\n  int isTemp,      /* True if this is a TEMP table */\n  int isView,      /* True if this is a VIEW */\n  int isVirtual,   /* True if this is a VIRTUAL table */\n  int noErr        /* Do nothing if table already exists */\n){\n  Table *pTable;\n  char *zName = 0; /* The name of the new table */\n  sqlite3 *db = pParse->db;\n  Vdbe *v;\n  int iDb;         /* Database number to create the table in */\n  Token *pName;    /* Unqualified name of the table to create */\n\n  /* The table or view name to create is passed to this routine via tokens\n  ** pName1 and pName2. If the table name was fully qualified, for example:\n  **\n  ** CREATE TABLE xxx.yyy (...);\n  ** \n  ** Then pName1 is set to \"xxx\" and pName2 \"yyy\". On the other hand if\n  ** the table name is not fully qualified, i.e.:\n  **\n  ** CREATE TABLE yyy(...);\n  **\n  ** Then pName1 is set to \"yyy\" and pName2 is \"\".\n  **\n  ** The call below sets the pName pointer to point at the token (pName1 or\n  ** pName2) that stores the unqualified table name. The variable iDb is\n  ** set to the index of the database that the table or view is to be\n  ** created in.\n  */\n  iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pName);\n  if( iDb<0 ) return;\n  if( !OMIT_TEMPDB && isTemp && pName2->n>0 && iDb!=1 ){\n    /* If creating a temp table, the name may not be qualified. Unless \n    ** the database name is \"temp\" anyway.  */\n    sqlite3ErrorMsg(pParse, \"temporary table name must be unqualified\");\n    return;\n  }\n  if( !OMIT_TEMPDB && isTemp ) iDb = 1;\n\n  pParse->sNameToken = *pName;\n  zName = sqlite3NameFromToken(db, pName);\n  if( zName==0 ) return;\n  if( SQLITE_OK!=sqlite3CheckObjectName(pParse, zName) ){\n    goto begin_table_error;\n  }\n  if( db->init.iDb==1 ) isTemp = 1;\n#ifndef SQLITE_OMIT_AUTHORIZATION\n  assert( (isTemp & 1)==isTemp );\n  {\n    int code;\n    char *zDb = db->aDb[iDb].zName;\n    if( sqlite3AuthCheck(pParse, SQLITE_INSERT, SCHEMA_TABLE(isTemp), 0, zDb) ){\n      goto begin_table_error;\n    }\n    if( isView ){\n      if( !OMIT_TEMPDB && isTemp ){\n        code = SQLITE_CREATE_TEMP_VIEW;\n      }else{\n        code = SQLITE_CREATE_VIEW;\n      }\n    }else{\n      if( !OMIT_TEMPDB && isTemp ){\n        code = SQLITE_CREATE_TEMP_TABLE;\n      }else{\n        code = SQLITE_CREATE_TABLE;\n      }\n    }\n    if( !isVirtual && sqlite3AuthCheck(pParse, code, zName, 0, zDb) ){\n      goto begin_table_error;\n    }\n  }\n#endif\n\n  /* Make sure the new table name does not collide with an existing\n  ** index or table name in the same database.  Issue an error message if\n  ** it does. The exception is if the statement being parsed was passed\n  ** to an sqlite3_declare_vtab() call. In that case only the column names\n  ** and types will be used, so there is no need to test for namespace\n  ** collisions.\n  */\n  if( !IN_DECLARE_VTAB ){\n    char *zDb = db->aDb[iDb].zName;\n    if( SQLITE_OK!=sqlite3ReadSchema(pParse) ){\n      goto begin_table_error;\n    }\n    pTable = sqlite3FindTable(db, zName, zDb);\n    if( pTable ){\n      if( !noErr ){\n        sqlite3ErrorMsg(pParse, \"table %T already exists\", pName);\n      }\n      goto begin_table_error;\n    }\n    if( sqlite3FindIndex(db, zName, zDb)!=0 ){\n      sqlite3ErrorMsg(pParse, \"there is already an index named %s\", zName);\n      goto begin_table_error;\n    }\n  }\n\n  pTable = sqlite3DbMallocZero(db, sizeof(Table));\n  if( pTable==0 ){\n    db->mallocFailed = 1;\n    pParse->rc = SQLITE_NOMEM;\n    pParse->nErr++;\n    goto begin_table_error;\n  }\n  pTable->zName = zName;\n  pTable->iPKey = -1;\n  pTable->pSchema = db->aDb[iDb].pSchema;\n  pTable->nRef = 1;\n  pTable->nRowEst = 1000000;\n  assert( pParse->pNewTable==0 );\n  pParse->pNewTable = pTable;\n\n  /* If this is the magic sqlite_sequence table used by autoincrement,\n  ** then record a pointer to this table in the main database structure\n  ** so that INSERT can find the table easily.\n  */\n#ifndef SQLITE_OMIT_AUTOINCREMENT\n  if( !pParse->nested && strcmp(zName, \"sqlite_sequence\")==0 ){\n    pTable->pSchema->pSeqTab = pTable;\n  }\n#endif\n\n  /* Begin generating the code that will insert the table record into\n  ** the SQLITE_MASTER table.  Note in particular that we must go ahead\n  ** and allocate the record number for the table entry now.  Before any\n  ** PRIMARY KEY or UNIQUE keywords are parsed.  Those keywords will cause\n  ** indices to be created and the table record must come before the \n  ** indices.  Hence, the record number for the table must be allocated\n  ** now.\n  */\n  if( !db->init.busy && (v = sqlite3GetVdbe(pParse))!=0 ){\n    int j1;\n    int fileFormat;\n    int reg1, reg2, reg3;\n    sqlite3BeginWriteOperation(pParse, 0, iDb);\n\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n    if( isVirtual ){\n      sqlite3VdbeAddOp0(v, OP_VBegin);\n    }\n#endif\n\n    /* If the file format and encoding in the database have not been set, \n    ** set them now.\n    */\n    reg1 = pParse->regRowid = ++pParse->nMem;\n    reg2 = pParse->regRoot = ++pParse->nMem;\n    reg3 = ++pParse->nMem;\n    sqlite3VdbeAddOp3(v, OP_ReadCookie, iDb, reg3, BTREE_FILE_FORMAT);\n    sqlite3VdbeUsesBtree(v, iDb);\n    j1 = sqlite3VdbeAddOp1(v, OP_If, reg3);\n    fileFormat = (db->flags & SQLITE_LegacyFileFmt)!=0 ?\n                  1 : SQLITE_MAX_FILE_FORMAT;\n    sqlite3VdbeAddOp2(v, OP_Integer, fileFormat, reg3);\n    sqlite3VdbeAddOp3(v, OP_SetCookie, iDb, BTREE_FILE_FORMAT, reg3);\n    sqlite3VdbeAddOp2(v, OP_Integer, ENC(db), reg3);\n    sqlite3VdbeAddOp3(v, OP_SetCookie, iDb, BTREE_TEXT_ENCODING, reg3);\n    sqlite3VdbeJumpHere(v, j1);\n\n    /* This just creates a place-holder record in the sqlite_master table.\n    ** The record created does not contain anything yet.  It will be replaced\n    ** by the real entry in code generated at sqlite3EndTable().\n    **\n    ** The rowid for the new entry is left in register pParse->regRowid.\n    ** The root page number of the new table is left in reg pParse->regRoot.\n    ** The rowid and root page number values are needed by the code that\n    ** sqlite3EndTable will generate.\n    */\n#if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_VIRTUALTABLE)\n    if( isView || isVirtual ){\n      sqlite3VdbeAddOp2(v, OP_Integer, 0, reg2);\n    }else\n#endif\n    {\n      sqlite3VdbeAddOp2(v, OP_CreateTable, iDb, reg2);\n    }\n    sqlite3OpenMasterTable(pParse, iDb);\n    sqlite3VdbeAddOp2(v, OP_NewRowid, 0, reg1);\n    sqlite3VdbeAddOp2(v, OP_Null, 0, reg3);\n    sqlite3VdbeAddOp3(v, OP_Insert, 0, reg3, reg1);\n    sqlite3VdbeChangeP5(v, OPFLAG_APPEND);\n    sqlite3VdbeAddOp0(v, OP_Close);\n  }\n\n  /* Normal (non-error) return. */\n  return;\n\n  /* If an error occurs, we jump here */\nbegin_table_error:\n  sqlite3DbFree(db, zName);\n  return;\n}\n\n/*\n** This macro is used to compare two strings in a case-insensitive manner.\n** It is slightly faster than calling sqlite3StrICmp() directly, but\n** produces larger code.\n**\n** WARNING: This macro is not compatible with the strcmp() family. It\n** returns true if the two strings are equal, otherwise false.\n*/\n#define STRICMP(x, y) (\\\nsqlite3UpperToLower[*(unsigned char *)(x)]==   \\\nsqlite3UpperToLower[*(unsigned char *)(y)]     \\\n&& sqlite3StrICmp((x)+1,(y)+1)==0 )\n\n/*\n** Add a new column to the table currently being constructed.\n**\n** The parser calls this routine once for each column declaration\n** in a CREATE TABLE statement.  sqlite3StartTable() gets called\n** first to get things going.  Then this routine is called for each\n** column.\n*/\nSQLITE_PRIVATE void sqlite3AddColumn(Parse *pParse, Token *pName){\n  Table *p;\n  int i;\n  char *z;\n  Column *pCol;\n  sqlite3 *db = pParse->db;\n  if( (p = pParse->pNewTable)==0 ) return;\n#if SQLITE_MAX_COLUMN\n  if( p->nCol+1>db->aLimit[SQLITE_LIMIT_COLUMN] ){\n    sqlite3ErrorMsg(pParse, \"too many columns on %s\", p->zName);\n    return;\n  }\n#endif\n  z = sqlite3NameFromToken(db, pName);\n  if( z==0 ) return;\n  for(i=0; i<p->nCol; i++){\n    if( STRICMP(z, p->aCol[i].zName) ){\n      sqlite3ErrorMsg(pParse, \"duplicate column name: %s\", z);\n      sqlite3DbFree(db, z);\n      return;\n    }\n  }\n  if( (p->nCol & 0x7)==0 ){\n    Column *aNew;\n    aNew = sqlite3DbRealloc(db,p->aCol,(p->nCol+8)*sizeof(p->aCol[0]));\n    if( aNew==0 ){\n      sqlite3DbFree(db, z);\n      return;\n    }\n    p->aCol = aNew;\n  }\n  pCol = &p->aCol[p->nCol];\n  memset(pCol, 0, sizeof(p->aCol[0]));\n  pCol->zName = z;\n \n  /* If there is no type specified, columns have the default affinity\n  ** 'NONE'. If there is a type specified, then sqlite3AddColumnType() will\n  ** be called next to set pCol->affinity correctly.\n  */\n  pCol->affinity = SQLITE_AFF_NONE;\n  p->nCol++;\n}\n\n/*\n** This routine is called by the parser while in the middle of\n** parsing a CREATE TABLE statement.  A \"NOT NULL\" constraint has\n** been seen on a column.  This routine sets the notNull flag on\n** the column currently under construction.\n*/\nSQLITE_PRIVATE void sqlite3AddNotNull(Parse *pParse, int onError){\n  Table *p;\n  p = pParse->pNewTable;\n  if( p==0 || NEVER(p->nCol<1) ) return;\n  p->aCol[p->nCol-1].notNull = (u8)onError;\n}\n\n/*\n** Scan the column type name zType (length nType) and return the\n** associated affinity type.\n**\n** This routine does a case-independent search of zType for the \n** substrings in the following table. If one of the substrings is\n** found, the corresponding affinity is returned. If zType contains\n** more than one of the substrings, entries toward the top of \n** the table take priority. For example, if zType is 'BLOBINT', \n** SQLITE_AFF_INTEGER is returned.\n**\n** Substring     | Affinity\n** --------------------------------\n** 'INT'         | SQLITE_AFF_INTEGER\n** 'CHAR'        | SQLITE_AFF_TEXT\n** 'CLOB'        | SQLITE_AFF_TEXT\n** 'TEXT'        | SQLITE_AFF_TEXT\n** 'BLOB'        | SQLITE_AFF_NONE\n** 'REAL'        | SQLITE_AFF_REAL\n** 'FLOA'        | SQLITE_AFF_REAL\n** 'DOUB'        | SQLITE_AFF_REAL\n**\n** If none of the substrings in the above table are found,\n** SQLITE_AFF_NUMERIC is returned.\n*/\nSQLITE_PRIVATE char sqlite3AffinityType(const char *zIn){\n  u32 h = 0;\n  char aff = SQLITE_AFF_NUMERIC;\n\n  if( zIn ) while( zIn[0] ){\n    h = (h<<8) + sqlite3UpperToLower[(*zIn)&0xff];\n    zIn++;\n    if( h==(('c'<<24)+('h'<<16)+('a'<<8)+'r') ){             /* CHAR */\n      aff = SQLITE_AFF_TEXT; \n    }else if( h==(('c'<<24)+('l'<<16)+('o'<<8)+'b') ){       /* CLOB */\n      aff = SQLITE_AFF_TEXT;\n    }else if( h==(('t'<<24)+('e'<<16)+('x'<<8)+'t') ){       /* TEXT */\n      aff = SQLITE_AFF_TEXT;\n    }else if( h==(('b'<<24)+('l'<<16)+('o'<<8)+'b')          /* BLOB */\n        && (aff==SQLITE_AFF_NUMERIC || aff==SQLITE_AFF_REAL) ){\n      aff = SQLITE_AFF_NONE;\n#ifndef SQLITE_OMIT_FLOATING_POINT\n    }else if( h==(('r'<<24)+('e'<<16)+('a'<<8)+'l')          /* REAL */\n        && aff==SQLITE_AFF_NUMERIC ){\n      aff = SQLITE_AFF_REAL;\n    }else if( h==(('f'<<24)+('l'<<16)+('o'<<8)+'a')          /* FLOA */\n        && aff==SQLITE_AFF_NUMERIC ){\n      aff = SQLITE_AFF_REAL;\n    }else if( h==(('d'<<24)+('o'<<16)+('u'<<8)+'b')          /* DOUB */\n        && aff==SQLITE_AFF_NUMERIC ){\n      aff = SQLITE_AFF_REAL;\n#endif\n    }else if( (h&0x00FFFFFF)==(('i'<<16)+('n'<<8)+'t') ){    /* INT */\n      aff = SQLITE_AFF_INTEGER;\n      break;\n    }\n  }\n\n  return aff;\n}\n\n/*\n** This routine is called by the parser while in the middle of\n** parsing a CREATE TABLE statement.  The pFirst token is the first\n** token in the sequence of tokens that describe the type of the\n** column currently under construction.   pLast is the last token\n** in the sequence.  Use this information to construct a string\n** that contains the typename of the column and store that string\n** in zType.\n*/ \nSQLITE_PRIVATE void sqlite3AddColumnType(Parse *pParse, Token *pType){\n  Table *p;\n  Column *pCol;\n\n  p = pParse->pNewTable;\n  if( p==0 || NEVER(p->nCol<1) ) return;\n  pCol = &p->aCol[p->nCol-1];\n  assert( pCol->zType==0 );\n  pCol->zType = sqlite3NameFromToken(pParse->db, pType);\n  pCol->affinity = sqlite3AffinityType(pCol->zType);\n}\n\n/*\n** The expression is the default value for the most recently added column\n** of the table currently under construction.\n**\n** Default value expressions must be constant.  Raise an exception if this\n** is not the case.\n**\n** This routine is called by the parser while in the middle of\n** parsing a CREATE TABLE statement.\n*/\nSQLITE_PRIVATE void sqlite3AddDefaultValue(Parse *pParse, ExprSpan *pSpan){\n  Table *p;\n  Column *pCol;\n  sqlite3 *db = pParse->db;\n  p = pParse->pNewTable;\n  if( p!=0 ){\n    pCol = &(p->aCol[p->nCol-1]);\n    if( !sqlite3ExprIsConstantOrFunction(pSpan->pExpr) ){\n      sqlite3ErrorMsg(pParse, \"default value of column [%s] is not constant\",\n          pCol->zName);\n    }else{\n      /* A copy of pExpr is used instead of the original, as pExpr contains\n      ** tokens that point to volatile memory. The 'span' of the expression\n      ** is required by pragma table_info.\n      */\n      sqlite3ExprDelete(db, pCol->pDflt);\n      pCol->pDflt = sqlite3ExprDup(db, pSpan->pExpr, EXPRDUP_REDUCE);\n      sqlite3DbFree(db, pCol->zDflt);\n      pCol->zDflt = sqlite3DbStrNDup(db, (char*)pSpan->zStart,\n                                     (int)(pSpan->zEnd - pSpan->zStart));\n    }\n  }\n  sqlite3ExprDelete(db, pSpan->pExpr);\n}\n\n/*\n** Designate the PRIMARY KEY for the table.  pList is a list of names \n** of columns that form the primary key.  If pList is NULL, then the\n** most recently added column of the table is the primary key.\n**\n** A table can have at most one primary key.  If the table already has\n** a primary key (and this is the second primary key) then create an\n** error.\n**\n** If the PRIMARY KEY is on a single column whose datatype is INTEGER,\n** then we will try to use that column as the rowid.  Set the Table.iPKey\n** field of the table under construction to be the index of the\n** INTEGER PRIMARY KEY column.  Table.iPKey is set to -1 if there is\n** no INTEGER PRIMARY KEY.\n**\n** If the key is not an INTEGER PRIMARY KEY, then create a unique\n** index for the key.  No index is created for INTEGER PRIMARY KEYs.\n*/\nSQLITE_PRIVATE void sqlite3AddPrimaryKey(\n  Parse *pParse,    /* Parsing context */\n  ExprList *pList,  /* List of field names to be indexed */\n  int onError,      /* What to do with a uniqueness conflict */\n  int autoInc,      /* True if the AUTOINCREMENT keyword is present */\n  int sortOrder     /* SQLITE_SO_ASC or SQLITE_SO_DESC */\n){\n  Table *pTab = pParse->pNewTable;\n  char *zType = 0;\n  int iCol = -1, i;\n  if( pTab==0 || IN_DECLARE_VTAB ) goto primary_key_exit;\n  if( pTab->tabFlags & TF_HasPrimaryKey ){\n    sqlite3ErrorMsg(pParse, \n      \"table \\\"%s\\\" has more than one primary key\", pTab->zName);\n    goto primary_key_exit;\n  }\n  pTab->tabFlags |= TF_HasPrimaryKey;\n  if( pList==0 ){\n    iCol = pTab->nCol - 1;\n    pTab->aCol[iCol].isPrimKey = 1;\n  }else{\n    for(i=0; i<pList->nExpr; i++){\n      for(iCol=0; iCol<pTab->nCol; iCol++){\n        if( sqlite3StrICmp(pList->a[i].zName, pTab->aCol[iCol].zName)==0 ){\n          break;\n        }\n      }\n      if( iCol<pTab->nCol ){\n        pTab->aCol[iCol].isPrimKey = 1;\n      }\n    }\n    if( pList->nExpr>1 ) iCol = -1;\n  }\n  if( iCol>=0 && iCol<pTab->nCol ){\n    zType = pTab->aCol[iCol].zType;\n  }\n  if( zType && sqlite3StrICmp(zType, \"INTEGER\")==0\n        && sortOrder==SQLITE_SO_ASC ){\n    pTab->iPKey = iCol;\n    pTab->keyConf = (u8)onError;\n    assert( autoInc==0 || autoInc==1 );\n    pTab->tabFlags |= autoInc*TF_Autoincrement;\n  }else if( autoInc ){\n#ifndef SQLITE_OMIT_AUTOINCREMENT\n    sqlite3ErrorMsg(pParse, \"AUTOINCREMENT is only allowed on an \"\n       \"INTEGER PRIMARY KEY\");\n#endif\n  }else{\n    Index *p;\n    p = sqlite3CreateIndex(pParse, 0, 0, 0, pList, onError, 0, 0, sortOrder, 0);\n    if( p ){\n      p->autoIndex = 2;\n    }\n    pList = 0;\n  }\n\nprimary_key_exit:\n  sqlite3ExprListDelete(pParse->db, pList);\n  return;\n}\n\n/*\n** Add a new CHECK constraint to the table currently under construction.\n*/\nSQLITE_PRIVATE void sqlite3AddCheckConstraint(\n  Parse *pParse,    /* Parsing context */\n  Expr *pCheckExpr  /* The check expression */\n){\n  sqlite3 *db = pParse->db;\n#ifndef SQLITE_OMIT_CHECK\n  Table *pTab = pParse->pNewTable;\n  if( pTab && !IN_DECLARE_VTAB ){\n    pTab->pCheck = sqlite3ExprAnd(db, pTab->pCheck, pCheckExpr);\n  }else\n#endif\n  {\n    sqlite3ExprDelete(db, pCheckExpr);\n  }\n}\n\n/*\n** Set the collation function of the most recently parsed table column\n** to the CollSeq given.\n*/\nSQLITE_PRIVATE void sqlite3AddCollateType(Parse *pParse, Token *pToken){\n  Table *p;\n  int i;\n  char *zColl;              /* Dequoted name of collation sequence */\n  sqlite3 *db;\n\n  if( (p = pParse->pNewTable)==0 ) return;\n  i = p->nCol-1;\n  db = pParse->db;\n  zColl = sqlite3NameFromToken(db, pToken);\n  if( !zColl ) return;\n\n  if( sqlite3LocateCollSeq(pParse, zColl) ){\n    Index *pIdx;\n    p->aCol[i].zColl = zColl;\n  \n    /* If the column is declared as \"<name> PRIMARY KEY COLLATE <type>\",\n    ** then an index may have been created on this column before the\n    ** collation type was added. Correct this if it is the case.\n    */\n    for(pIdx=p->pIndex; pIdx; pIdx=pIdx->pNext){\n      assert( pIdx->nColumn==1 );\n      if( pIdx->aiColumn[0]==i ){\n        pIdx->azColl[0] = p->aCol[i].zColl;\n      }\n    }\n  }else{\n    sqlite3DbFree(db, zColl);\n  }\n}\n\n/*\n** This function returns the collation sequence for database native text\n** encoding identified by the string zName, length nName.\n**\n** If the requested collation sequence is not available, or not available\n** in the database native encoding, the collation factory is invoked to\n** request it. If the collation factory does not supply such a sequence,\n** and the sequence is available in another text encoding, then that is\n** returned instead.\n**\n** If no versions of the requested collations sequence are available, or\n** another error occurs, NULL is returned and an error message written into\n** pParse.\n**\n** This routine is a wrapper around sqlite3FindCollSeq().  This routine\n** invokes the collation factory if the named collation cannot be found\n** and generates an error message.\n**\n** See also: sqlite3FindCollSeq(), sqlite3GetCollSeq()\n*/\nSQLITE_PRIVATE CollSeq *sqlite3LocateCollSeq(Parse *pParse, const char *zName){\n  sqlite3 *db = pParse->db;\n  u8 enc = ENC(db);\n  u8 initbusy = db->init.busy;\n  CollSeq *pColl;\n\n  pColl = sqlite3FindCollSeq(db, enc, zName, initbusy);\n  if( !initbusy && (!pColl || !pColl->xCmp) ){\n    pColl = sqlite3GetCollSeq(db, enc, pColl, zName);\n    if( !pColl ){\n      sqlite3ErrorMsg(pParse, \"no such collation sequence: %s\", zName);\n    }\n  }\n\n  return pColl;\n}\n\n\n/*\n** Generate code that will increment the schema cookie.\n**\n** The schema cookie is used to determine when the schema for the\n** database changes.  After each schema change, the cookie value\n** changes.  When a process first reads the schema it records the\n** cookie.  Thereafter, whenever it goes to access the database,\n** it checks the cookie to make sure the schema has not changed\n** since it was last read.\n**\n** This plan is not completely bullet-proof.  It is possible for\n** the schema to change multiple times and for the cookie to be\n** set back to prior value.  But schema changes are infrequent\n** and the probability of hitting the same cookie value is only\n** 1 chance in 2^32.  So we're safe enough.\n*/\nSQLITE_PRIVATE void sqlite3ChangeCookie(Parse *pParse, int iDb){\n  int r1 = sqlite3GetTempReg(pParse);\n  sqlite3 *db = pParse->db;\n  Vdbe *v = pParse->pVdbe;\n  sqlite3VdbeAddOp2(v, OP_Integer, db->aDb[iDb].pSchema->schema_cookie+1, r1);\n  sqlite3VdbeAddOp3(v, OP_SetCookie, iDb, BTREE_SCHEMA_VERSION, r1);\n  sqlite3ReleaseTempReg(pParse, r1);\n}\n\n/*\n** Measure the number of characters needed to output the given\n** identifier.  The number returned includes any quotes used\n** but does not include the null terminator.\n**\n** The estimate is conservative.  It might be larger that what is\n** really needed.\n*/\nstatic int identLength(const char *z){\n  int n;\n  for(n=0; *z; n++, z++){\n    if( *z=='\"' ){ n++; }\n  }\n  return n + 2;\n}\n\n/*\n** The first parameter is a pointer to an output buffer. The second \n** parameter is a pointer to an integer that contains the offset at\n** which to write into the output buffer. This function copies the\n** nul-terminated string pointed to by the third parameter, zSignedIdent,\n** to the specified offset in the buffer and updates *pIdx to refer\n** to the first byte after the last byte written before returning.\n** \n** If the string zSignedIdent consists entirely of alpha-numeric\n** characters, does not begin with a digit and is not an SQL keyword,\n** then it is copied to the output buffer exactly as it is. Otherwise,\n** it is quoted using double-quotes.\n*/\nstatic void identPut(char *z, int *pIdx, char *zSignedIdent){\n  unsigned char *zIdent = (unsigned char*)zSignedIdent;\n  int i, j, needQuote;\n  i = *pIdx;\n\n  for(j=0; zIdent[j]; j++){\n    if( !sqlite3Isalnum(zIdent[j]) && zIdent[j]!='_' ) break;\n  }\n  needQuote = sqlite3Isdigit(zIdent[0]) || sqlite3KeywordCode(zIdent, j)!=TK_ID;\n  if( !needQuote ){\n    needQuote = zIdent[j];\n  }\n\n  if( needQuote ) z[i++] = '\"';\n  for(j=0; zIdent[j]; j++){\n    z[i++] = zIdent[j];\n    if( zIdent[j]=='\"' ) z[i++] = '\"';\n  }\n  if( needQuote ) z[i++] = '\"';\n  z[i] = 0;\n  *pIdx = i;\n}\n\n/*\n** Generate a CREATE TABLE statement appropriate for the given\n** table.  Memory to hold the text of the statement is obtained\n** from sqliteMalloc() and must be freed by the calling function.\n*/\nstatic char *createTableStmt(sqlite3 *db, Table *p){\n  int i, k, n;\n  char *zStmt;\n  char *zSep, *zSep2, *zEnd;\n  Column *pCol;\n  n = 0;\n  for(pCol = p->aCol, i=0; i<p->nCol; i++, pCol++){\n    n += identLength(pCol->zName) + 5;\n  }\n  n += identLength(p->zName);\n  if( n<50 ){ \n    zSep = \"\";\n    zSep2 = \",\";\n    zEnd = \")\";\n  }else{\n    zSep = \"\\n  \";\n    zSep2 = \",\\n  \";\n    zEnd = \"\\n)\";\n  }\n  n += 35 + 6*p->nCol;\n  zStmt = sqlite3DbMallocRaw(0, n);\n  if( zStmt==0 ){\n    db->mallocFailed = 1;\n    return 0;\n  }\n  sqlite3_snprintf(n, zStmt, \"CREATE TABLE \");\n  k = sqlite3Strlen30(zStmt);\n  identPut(zStmt, &k, p->zName);\n  zStmt[k++] = '(';\n  for(pCol=p->aCol, i=0; i<p->nCol; i++, pCol++){\n    static const char * const azType[] = {\n        /* SQLITE_AFF_TEXT    */ \" TEXT\",\n        /* SQLITE_AFF_NONE    */ \"\",\n        /* SQLITE_AFF_NUMERIC */ \" NUM\",\n        /* SQLITE_AFF_INTEGER */ \" INT\",\n        /* SQLITE_AFF_REAL    */ \" REAL\"\n    };\n    int len;\n    const char *zType;\n\n    sqlite3_snprintf(n-k, &zStmt[k], zSep);\n    k += sqlite3Strlen30(&zStmt[k]);\n    zSep = zSep2;\n    identPut(zStmt, &k, pCol->zName);\n    assert( pCol->affinity-SQLITE_AFF_TEXT >= 0 );\n    assert( pCol->affinity-SQLITE_AFF_TEXT < sizeof(azType)/sizeof(azType[0]) );\n    testcase( pCol->affinity==SQLITE_AFF_TEXT );\n    testcase( pCol->affinity==SQLITE_AFF_NONE );\n    testcase( pCol->affinity==SQLITE_AFF_NUMERIC );\n    testcase( pCol->affinity==SQLITE_AFF_INTEGER );\n    testcase( pCol->affinity==SQLITE_AFF_REAL );\n    \n    zType = azType[pCol->affinity - SQLITE_AFF_TEXT];\n    len = sqlite3Strlen30(zType);\n    assert( pCol->affinity==SQLITE_AFF_NONE \n            || pCol->affinity==sqlite3AffinityType(zType) );\n    memcpy(&zStmt[k], zType, len);\n    k += len;\n    assert( k<=n );\n  }\n  sqlite3_snprintf(n-k, &zStmt[k], \"%s\", zEnd);\n  return zStmt;\n}\n\n/*\n** This routine is called to report the final \")\" that terminates\n** a CREATE TABLE statement.\n**\n** The table structure that other action routines have been building\n** is added to the internal hash tables, assuming no errors have\n** occurred.\n**\n** An entry for the table is made in the master table on disk, unless\n** this is a temporary table or db->init.busy==1.  When db->init.busy==1\n** it means we are reading the sqlite_master table because we just\n** connected to the database or because the sqlite_master table has\n** recently changed, so the entry for this table already exists in\n** the sqlite_master table.  We do not want to create it again.\n**\n** If the pSelect argument is not NULL, it means that this routine\n** was called to create a table generated from a \n** \"CREATE TABLE ... AS SELECT ...\" statement.  The column names of\n** the new table will match the result set of the SELECT.\n*/\nSQLITE_PRIVATE void sqlite3EndTable(\n  Parse *pParse,          /* Parse context */\n  Token *pCons,           /* The ',' token after the last column defn. */\n  Token *pEnd,            /* The final ')' token in the CREATE TABLE */\n  Select *pSelect         /* Select from a \"CREATE ... AS SELECT\" */\n){\n  Table *p;\n  sqlite3 *db = pParse->db;\n  int iDb;\n\n  if( (pEnd==0 && pSelect==0) || db->mallocFailed ){\n    return;\n  }\n  p = pParse->pNewTable;\n  if( p==0 ) return;\n\n  assert( !db->init.busy || !pSelect );\n\n  iDb = sqlite3SchemaToIndex(db, p->pSchema);\n\n#ifndef SQLITE_OMIT_CHECK\n  /* Resolve names in all CHECK constraint expressions.\n  */\n  if( p->pCheck ){\n    SrcList sSrc;                   /* Fake SrcList for pParse->pNewTable */\n    NameContext sNC;                /* Name context for pParse->pNewTable */\n\n    memset(&sNC, 0, sizeof(sNC));\n    memset(&sSrc, 0, sizeof(sSrc));\n    sSrc.nSrc = 1;\n    sSrc.a[0].zName = p->zName;\n    sSrc.a[0].pTab = p;\n    sSrc.a[0].iCursor = -1;\n    sNC.pParse = pParse;\n    sNC.pSrcList = &sSrc;\n    sNC.isCheck = 1;\n    if( sqlite3ResolveExprNames(&sNC, p->pCheck) ){\n      return;\n    }\n  }\n#endif /* !defined(SQLITE_OMIT_CHECK) */\n\n  /* If the db->init.busy is 1 it means we are reading the SQL off the\n  ** \"sqlite_master\" or \"sqlite_temp_master\" table on the disk.\n  ** So do not write to the disk again.  Extract the root page number\n  ** for the table from the db->init.newTnum field.  (The page number\n  ** should have been put there by the sqliteOpenCb routine.)\n  */\n  if( db->init.busy ){\n    p->tnum = db->init.newTnum;\n  }\n\n  /* If not initializing, then create a record for the new table\n  ** in the SQLITE_MASTER table of the database.\n  **\n  ** If this is a TEMPORARY table, write the entry into the auxiliary\n  ** file instead of into the main database file.\n  */\n  if( !db->init.busy ){\n    int n;\n    Vdbe *v;\n    char *zType;    /* \"view\" or \"table\" */\n    char *zType2;   /* \"VIEW\" or \"TABLE\" */\n    char *zStmt;    /* Text of the CREATE TABLE or CREATE VIEW statement */\n\n    v = sqlite3GetVdbe(pParse);\n    if( NEVER(v==0) ) return;\n\n    sqlite3VdbeAddOp1(v, OP_Close, 0);\n\n    /* \n    ** Initialize zType for the new view or table.\n    */\n    if( p->pSelect==0 ){\n      /* A regular table */\n      zType = \"table\";\n      zType2 = \"TABLE\";\n#ifndef SQLITE_OMIT_VIEW\n    }else{\n      /* A view */\n      zType = \"view\";\n      zType2 = \"VIEW\";\n#endif\n    }\n\n    /* If this is a CREATE TABLE xx AS SELECT ..., execute the SELECT\n    ** statement to populate the new table. The root-page number for the\n    ** new table is in register pParse->regRoot.\n    **\n    ** Once the SELECT has been coded by sqlite3Select(), it is in a\n    ** suitable state to query for the column names and types to be used\n    ** by the new table.\n    **\n    ** A shared-cache write-lock is not required to write to the new table,\n    ** as a schema-lock must have already been obtained to create it. Since\n    ** a schema-lock excludes all other database users, the write-lock would\n    ** be redundant.\n    */\n    if( pSelect ){\n      SelectDest dest;\n      Table *pSelTab;\n\n      assert(pParse->nTab==1);\n      sqlite3VdbeAddOp3(v, OP_OpenWrite, 1, pParse->regRoot, iDb);\n      sqlite3VdbeChangeP5(v, 1);\n      pParse->nTab = 2;\n      sqlite3SelectDestInit(&dest, SRT_Table, 1);\n      sqlite3Select(pParse, pSelect, &dest);\n      sqlite3VdbeAddOp1(v, OP_Close, 1);\n      if( pParse->nErr==0 ){\n        pSelTab = sqlite3ResultSetOfSelect(pParse, pSelect);\n        if( pSelTab==0 ) return;\n        assert( p->aCol==0 );\n        p->nCol = pSelTab->nCol;\n        p->aCol = pSelTab->aCol;\n        pSelTab->nCol = 0;\n        pSelTab->aCol = 0;\n        sqlite3DeleteTable(db, pSelTab);\n      }\n    }\n\n    /* Compute the complete text of the CREATE statement */\n    if( pSelect ){\n      zStmt = createTableStmt(db, p);\n    }else{\n      n = (int)(pEnd->z - pParse->sNameToken.z) + 1;\n      zStmt = sqlite3MPrintf(db, \n          \"CREATE %s %.*s\", zType2, n, pParse->sNameToken.z\n      );\n    }\n\n    /* A slot for the record has already been allocated in the \n    ** SQLITE_MASTER table.  We just need to update that slot with all\n    ** the information we've collected.\n    */\n    sqlite3NestedParse(pParse,\n      \"UPDATE %Q.%s \"\n         \"SET type='%s', name=%Q, tbl_name=%Q, rootpage=#%d, sql=%Q \"\n       \"WHERE rowid=#%d\",\n      db->aDb[iDb].zName, SCHEMA_TABLE(iDb),\n      zType,\n      p->zName,\n      p->zName,\n      pParse->regRoot,\n      zStmt,\n      pParse->regRowid\n    );\n    sqlite3DbFree(db, zStmt);\n    sqlite3ChangeCookie(pParse, iDb);\n\n#ifndef SQLITE_OMIT_AUTOINCREMENT\n    /* Check to see if we need to create an sqlite_sequence table for\n    ** keeping track of autoincrement keys.\n    */\n    if( p->tabFlags & TF_Autoincrement ){\n      Db *pDb = &db->aDb[iDb];\n      if( pDb->pSchema->pSeqTab==0 ){\n        sqlite3NestedParse(pParse,\n          \"CREATE TABLE %Q.sqlite_sequence(name,seq)\",\n          pDb->zName\n        );\n      }\n    }\n#endif\n\n    /* Reparse everything to update our internal data structures */\n    sqlite3VdbeAddOp4(v, OP_ParseSchema, iDb, 0, 0,\n        sqlite3MPrintf(db, \"tbl_name='%q'\",p->zName), P4_DYNAMIC);\n  }\n\n\n  /* Add the table to the in-memory representation of the database.\n  */\n  if( db->init.busy ){\n    Table *pOld;\n    Schema *pSchema = p->pSchema;\n    pOld = sqlite3HashInsert(&pSchema->tblHash, p->zName,\n                             sqlite3Strlen30(p->zName),p);\n    if( pOld ){\n      assert( p==pOld );  /* Malloc must have failed inside HashInsert() */\n      db->mallocFailed = 1;\n      return;\n    }\n    pParse->pNewTable = 0;\n    db->nTable++;\n    db->flags |= SQLITE_InternChanges;\n\n#ifndef SQLITE_OMIT_ALTERTABLE\n    if( !p->pSelect ){\n      const char *zName = (const char *)pParse->sNameToken.z;\n      int nName;\n      assert( !pSelect && pCons && pEnd );\n      if( pCons->z==0 ){\n        pCons = pEnd;\n      }\n      nName = (int)((const char *)pCons->z - zName);\n      p->addColOffset = 13 + sqlite3Utf8CharLen(zName, nName);\n    }\n#endif\n  }\n}\n\n#ifndef SQLITE_OMIT_VIEW\n/*\n** The parser calls this routine in order to create a new VIEW\n*/\nSQLITE_PRIVATE void sqlite3CreateView(\n  Parse *pParse,     /* The parsing context */\n  Token *pBegin,     /* The CREATE token that begins the statement */\n  Token *pName1,     /* The token that holds the name of the view */\n  Token *pName2,     /* The token that holds the name of the view */\n  Select *pSelect,   /* A SELECT statement that will become the new view */\n  int isTemp,        /* TRUE for a TEMPORARY view */\n  int noErr          /* Suppress error messages if VIEW already exists */\n){\n  Table *p;\n  int n;\n  const char *z;\n  Token sEnd;\n  DbFixer sFix;\n  Token *pName;\n  int iDb;\n  sqlite3 *db = pParse->db;\n\n  if( pParse->nVar>0 ){\n    sqlite3ErrorMsg(pParse, \"parameters are not allowed in views\");\n    sqlite3SelectDelete(db, pSelect);\n    return;\n  }\n  sqlite3StartTable(pParse, pName1, pName2, isTemp, 1, 0, noErr);\n  p = pParse->pNewTable;\n  if( p==0 || pParse->nErr ){\n    sqlite3SelectDelete(db, pSelect);\n    return;\n  }\n  sqlite3TwoPartName(pParse, pName1, pName2, &pName);\n  iDb = sqlite3SchemaToIndex(db, p->pSchema);\n  if( sqlite3FixInit(&sFix, pParse, iDb, \"view\", pName)\n    && sqlite3FixSelect(&sFix, pSelect)\n  ){\n    sqlite3SelectDelete(db, pSelect);\n    return;\n  }\n\n  /* Make a copy of the entire SELECT statement that defines the view.\n  ** This will force all the Expr.token.z values to be dynamically\n  ** allocated rather than point to the input string - which means that\n  ** they will persist after the current sqlite3_exec() call returns.\n  */\n  p->pSelect = sqlite3SelectDup(db, pSelect, EXPRDUP_REDUCE);\n  sqlite3SelectDelete(db, pSelect);\n  if( db->mallocFailed ){\n    return;\n  }\n  if( !db->init.busy ){\n    sqlite3ViewGetColumnNames(pParse, p);\n  }\n\n  /* Locate the end of the CREATE VIEW statement.  Make sEnd point to\n  ** the end.\n  */\n  sEnd = pParse->sLastToken;\n  if( ALWAYS(sEnd.z[0]!=0) && sEnd.z[0]!=';' ){\n    sEnd.z += sEnd.n;\n  }\n  sEnd.n = 0;\n  n = (int)(sEnd.z - pBegin->z);\n  z = pBegin->z;\n  while( ALWAYS(n>0) && sqlite3Isspace(z[n-1]) ){ n--; }\n  sEnd.z = &z[n-1];\n  sEnd.n = 1;\n\n  /* Use sqlite3EndTable() to add the view to the SQLITE_MASTER table */\n  sqlite3EndTable(pParse, 0, &sEnd, 0);\n  return;\n}\n#endif /* SQLITE_OMIT_VIEW */\n\n#if !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_VIRTUALTABLE)\n/*\n** The Table structure pTable is really a VIEW.  Fill in the names of\n** the columns of the view in the pTable structure.  Return the number\n** of errors.  If an error is seen leave an error message in pParse->zErrMsg.\n*/\nSQLITE_PRIVATE int sqlite3ViewGetColumnNames(Parse *pParse, Table *pTable){\n  Table *pSelTab;   /* A fake table from which we get the result set */\n  Select *pSel;     /* Copy of the SELECT that implements the view */\n  int nErr = 0;     /* Number of errors encountered */\n  int n;            /* Temporarily holds the number of cursors assigned */\n  sqlite3 *db = pParse->db;  /* Database connection for malloc errors */\n  int (*xAuth)(void*,int,const char*,const char*,const char*,const char*);\n\n  assert( pTable );\n\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  if( sqlite3VtabCallConnect(pParse, pTable) ){\n    return SQLITE_ERROR;\n  }\n  if( IsVirtual(pTable) ) return 0;\n#endif\n\n#ifndef SQLITE_OMIT_VIEW\n  /* A positive nCol means the columns names for this view are\n  ** already known.\n  */\n  if( pTable->nCol>0 ) return 0;\n\n  /* A negative nCol is a special marker meaning that we are currently\n  ** trying to compute the column names.  If we enter this routine with\n  ** a negative nCol, it means two or more views form a loop, like this:\n  **\n  **     CREATE VIEW one AS SELECT * FROM two;\n  **     CREATE VIEW two AS SELECT * FROM one;\n  **\n  ** Actually, the error above is now caught prior to reaching this point.\n  ** But the following test is still important as it does come up\n  ** in the following:\n  ** \n  **     CREATE TABLE main.ex1(a);\n  **     CREATE TEMP VIEW ex1 AS SELECT a FROM ex1;\n  **     SELECT * FROM temp.ex1;\n  */\n  if( pTable->nCol<0 ){\n    sqlite3ErrorMsg(pParse, \"view %s is circularly defined\", pTable->zName);\n    return 1;\n  }\n  assert( pTable->nCol>=0 );\n\n  /* If we get this far, it means we need to compute the table names.\n  ** Note that the call to sqlite3ResultSetOfSelect() will expand any\n  ** \"*\" elements in the results set of the view and will assign cursors\n  ** to the elements of the FROM clause.  But we do not want these changes\n  ** to be permanent.  So the computation is done on a copy of the SELECT\n  ** statement that defines the view.\n  */\n  assert( pTable->pSelect );\n  pSel = sqlite3SelectDup(db, pTable->pSelect, 0);\n  if( pSel ){\n    u8 enableLookaside = db->lookaside.bEnabled;\n    n = pParse->nTab;\n    sqlite3SrcListAssignCursors(pParse, pSel->pSrc);\n    pTable->nCol = -1;\n    db->lookaside.bEnabled = 0;\n#ifndef SQLITE_OMIT_AUTHORIZATION\n    xAuth = db->xAuth;\n    db->xAuth = 0;\n    pSelTab = sqlite3ResultSetOfSelect(pParse, pSel);\n    db->xAuth = xAuth;\n#else\n    pSelTab = sqlite3ResultSetOfSelect(pParse, pSel);\n#endif\n    db->lookaside.bEnabled = enableLookaside;\n    pParse->nTab = n;\n    if( pSelTab ){\n      assert( pTable->aCol==0 );\n      pTable->nCol = pSelTab->nCol;\n      pTable->aCol = pSelTab->aCol;\n      pSelTab->nCol = 0;\n      pSelTab->aCol = 0;\n      sqlite3DeleteTable(db, pSelTab);\n      pTable->pSchema->flags |= DB_UnresetViews;\n    }else{\n      pTable->nCol = 0;\n      nErr++;\n    }\n    sqlite3SelectDelete(db, pSel);\n  } else {\n    nErr++;\n  }\n#endif /* SQLITE_OMIT_VIEW */\n  return nErr;  \n}\n#endif /* !defined(SQLITE_OMIT_VIEW) || !defined(SQLITE_OMIT_VIRTUALTABLE) */\n\n#ifndef SQLITE_OMIT_VIEW\n/*\n** Clear the column names from every VIEW in database idx.\n*/\nstatic void sqliteViewResetAll(sqlite3 *db, int idx){\n  HashElem *i;\n  if( !DbHasProperty(db, idx, DB_UnresetViews) ) return;\n  for(i=sqliteHashFirst(&db->aDb[idx].pSchema->tblHash); i;i=sqliteHashNext(i)){\n    Table *pTab = sqliteHashData(i);\n    if( pTab->pSelect ){\n      sqliteDeleteColumnNames(db, pTab);\n      pTab->aCol = 0;\n      pTab->nCol = 0;\n    }\n  }\n  DbClearProperty(db, idx, DB_UnresetViews);\n}\n#else\n# define sqliteViewResetAll(A,B)\n#endif /* SQLITE_OMIT_VIEW */\n\n/*\n** This function is called by the VDBE to adjust the internal schema\n** used by SQLite when the btree layer moves a table root page. The\n** root-page of a table or index in database iDb has changed from iFrom\n** to iTo.\n**\n** Ticket #1728:  The symbol table might still contain information\n** on tables and/or indices that are the process of being deleted.\n** If you are unlucky, one of those deleted indices or tables might\n** have the same rootpage number as the real table or index that is\n** being moved.  So we cannot stop searching after the first match \n** because the first match might be for one of the deleted indices\n** or tables and not the table/index that is actually being moved.\n** We must continue looping until all tables and indices with\n** rootpage==iFrom have been converted to have a rootpage of iTo\n** in order to be certain that we got the right one.\n*/\n#ifndef SQLITE_OMIT_AUTOVACUUM\nSQLITE_PRIVATE void sqlite3RootPageMoved(Db *pDb, int iFrom, int iTo){\n  HashElem *pElem;\n  Hash *pHash;\n\n  pHash = &pDb->pSchema->tblHash;\n  for(pElem=sqliteHashFirst(pHash); pElem; pElem=sqliteHashNext(pElem)){\n    Table *pTab = sqliteHashData(pElem);\n    if( pTab->tnum==iFrom ){\n      pTab->tnum = iTo;\n    }\n  }\n  pHash = &pDb->pSchema->idxHash;\n  for(pElem=sqliteHashFirst(pHash); pElem; pElem=sqliteHashNext(pElem)){\n    Index *pIdx = sqliteHashData(pElem);\n    if( pIdx->tnum==iFrom ){\n      pIdx->tnum = iTo;\n    }\n  }\n}\n#endif\n\n/*\n** Write code to erase the table with root-page iTable from database iDb.\n** Also write code to modify the sqlite_master table and internal schema\n** if a root-page of another table is moved by the btree-layer whilst\n** erasing iTable (this can happen with an auto-vacuum database).\n*/ \nstatic void destroyRootPage(Parse *pParse, int iTable, int iDb){\n  Vdbe *v = sqlite3GetVdbe(pParse);\n  int r1 = sqlite3GetTempReg(pParse);\n  sqlite3VdbeAddOp3(v, OP_Destroy, iTable, r1, iDb);\n  sqlite3MayAbort(pParse);\n#ifndef SQLITE_OMIT_AUTOVACUUM\n  /* OP_Destroy stores an in integer r1. If this integer\n  ** is non-zero, then it is the root page number of a table moved to\n  ** location iTable. The following code modifies the sqlite_master table to\n  ** reflect this.\n  **\n  ** The \"#NNN\" in the SQL is a special constant that means whatever value\n  ** is in register NNN.  See grammar rules associated with the TK_REGISTER\n  ** token for additional information.\n  */\n  sqlite3NestedParse(pParse, \n     \"UPDATE %Q.%s SET rootpage=%d WHERE #%d AND rootpage=#%d\",\n     pParse->db->aDb[iDb].zName, SCHEMA_TABLE(iDb), iTable, r1, r1);\n#endif\n  sqlite3ReleaseTempReg(pParse, r1);\n}\n\n/*\n** Write VDBE code to erase table pTab and all associated indices on disk.\n** Code to update the sqlite_master tables and internal schema definitions\n** in case a root-page belonging to another table is moved by the btree layer\n** is also added (this can happen with an auto-vacuum database).\n*/\nstatic void destroyTable(Parse *pParse, Table *pTab){\n#ifdef SQLITE_OMIT_AUTOVACUUM\n  Index *pIdx;\n  int iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);\n  destroyRootPage(pParse, pTab->tnum, iDb);\n  for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){\n    destroyRootPage(pParse, pIdx->tnum, iDb);\n  }\n#else\n  /* If the database may be auto-vacuum capable (if SQLITE_OMIT_AUTOVACUUM\n  ** is not defined), then it is important to call OP_Destroy on the\n  ** table and index root-pages in order, starting with the numerically \n  ** largest root-page number. This guarantees that none of the root-pages\n  ** to be destroyed is relocated by an earlier OP_Destroy. i.e. if the\n  ** following were coded:\n  **\n  ** OP_Destroy 4 0\n  ** ...\n  ** OP_Destroy 5 0\n  **\n  ** and root page 5 happened to be the largest root-page number in the\n  ** database, then root page 5 would be moved to page 4 by the \n  ** \"OP_Destroy 4 0\" opcode. The subsequent \"OP_Destroy 5 0\" would hit\n  ** a free-list page.\n  */\n  int iTab = pTab->tnum;\n  int iDestroyed = 0;\n\n  while( 1 ){\n    Index *pIdx;\n    int iLargest = 0;\n\n    if( iDestroyed==0 || iTab<iDestroyed ){\n      iLargest = iTab;\n    }\n    for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){\n      int iIdx = pIdx->tnum;\n      assert( pIdx->pSchema==pTab->pSchema );\n      if( (iDestroyed==0 || (iIdx<iDestroyed)) && iIdx>iLargest ){\n        iLargest = iIdx;\n      }\n    }\n    if( iLargest==0 ){\n      return;\n    }else{\n      int iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);\n      destroyRootPage(pParse, iLargest, iDb);\n      iDestroyed = iLargest;\n    }\n  }\n#endif\n}\n\n/*\n** This routine is called to do the work of a DROP TABLE statement.\n** pName is the name of the table to be dropped.\n*/\nSQLITE_PRIVATE void sqlite3DropTable(Parse *pParse, SrcList *pName, int isView, int noErr){\n  Table *pTab;\n  Vdbe *v;\n  sqlite3 *db = pParse->db;\n  int iDb;\n\n  if( db->mallocFailed ){\n    goto exit_drop_table;\n  }\n  assert( pParse->nErr==0 );\n  assert( pName->nSrc==1 );\n  if( noErr ) db->suppressErr++;\n  pTab = sqlite3LocateTable(pParse, isView, \n                            pName->a[0].zName, pName->a[0].zDatabase);\n  if( noErr ) db->suppressErr--;\n\n  if( pTab==0 ){\n    goto exit_drop_table;\n  }\n  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n  assert( iDb>=0 && iDb<db->nDb );\n\n  /* If pTab is a virtual table, call ViewGetColumnNames() to ensure\n  ** it is initialized.\n  */\n  if( IsVirtual(pTab) && sqlite3ViewGetColumnNames(pParse, pTab) ){\n    goto exit_drop_table;\n  }\n#ifndef SQLITE_OMIT_AUTHORIZATION\n  {\n    int code;\n    const char *zTab = SCHEMA_TABLE(iDb);\n    const char *zDb = db->aDb[iDb].zName;\n    const char *zArg2 = 0;\n    if( sqlite3AuthCheck(pParse, SQLITE_DELETE, zTab, 0, zDb)){\n      goto exit_drop_table;\n    }\n    if( isView ){\n      if( !OMIT_TEMPDB && iDb==1 ){\n        code = SQLITE_DROP_TEMP_VIEW;\n      }else{\n        code = SQLITE_DROP_VIEW;\n      }\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n    }else if( IsVirtual(pTab) ){\n      code = SQLITE_DROP_VTABLE;\n      zArg2 = sqlite3GetVTable(db, pTab)->pMod->zName;\n#endif\n    }else{\n      if( !OMIT_TEMPDB && iDb==1 ){\n        code = SQLITE_DROP_TEMP_TABLE;\n      }else{\n        code = SQLITE_DROP_TABLE;\n      }\n    }\n    if( sqlite3AuthCheck(pParse, code, pTab->zName, zArg2, zDb) ){\n      goto exit_drop_table;\n    }\n    if( sqlite3AuthCheck(pParse, SQLITE_DELETE, pTab->zName, 0, zDb) ){\n      goto exit_drop_table;\n    }\n  }\n#endif\n  if( sqlite3StrNICmp(pTab->zName, \"sqlite_\", 7)==0 ){\n    sqlite3ErrorMsg(pParse, \"table %s may not be dropped\", pTab->zName);\n    goto exit_drop_table;\n  }\n\n#ifndef SQLITE_OMIT_VIEW\n  /* Ensure DROP TABLE is not used on a view, and DROP VIEW is not used\n  ** on a table.\n  */\n  if( isView && pTab->pSelect==0 ){\n    sqlite3ErrorMsg(pParse, \"use DROP TABLE to delete table %s\", pTab->zName);\n    goto exit_drop_table;\n  }\n  if( !isView && pTab->pSelect ){\n    sqlite3ErrorMsg(pParse, \"use DROP VIEW to delete view %s\", pTab->zName);\n    goto exit_drop_table;\n  }\n#endif\n\n  /* Generate code to remove the table from the master table\n  ** on disk.\n  */\n  v = sqlite3GetVdbe(pParse);\n  if( v ){\n    Trigger *pTrigger;\n    Db *pDb = &db->aDb[iDb];\n    sqlite3BeginWriteOperation(pParse, 1, iDb);\n\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n    if( IsVirtual(pTab) ){\n      sqlite3VdbeAddOp0(v, OP_VBegin);\n    }\n#endif\n    sqlite3FkDropTable(pParse, pName, pTab);\n\n    /* Drop all triggers associated with the table being dropped. Code\n    ** is generated to remove entries from sqlite_master and/or\n    ** sqlite_temp_master if required.\n    */\n    pTrigger = sqlite3TriggerList(pParse, pTab);\n    while( pTrigger ){\n      assert( pTrigger->pSchema==pTab->pSchema || \n          pTrigger->pSchema==db->aDb[1].pSchema );\n      sqlite3DropTriggerPtr(pParse, pTrigger);\n      pTrigger = pTrigger->pNext;\n    }\n\n#ifndef SQLITE_OMIT_AUTOINCREMENT\n    /* Remove any entries of the sqlite_sequence table associated with\n    ** the table being dropped. This is done before the table is dropped\n    ** at the btree level, in case the sqlite_sequence table needs to\n    ** move as a result of the drop (can happen in auto-vacuum mode).\n    */\n    if( pTab->tabFlags & TF_Autoincrement ){\n      sqlite3NestedParse(pParse,\n        \"DELETE FROM %s.sqlite_sequence WHERE name=%Q\",\n        pDb->zName, pTab->zName\n      );\n    }\n#endif\n\n    /* Drop all SQLITE_MASTER table and index entries that refer to the\n    ** table. The program name loops through the master table and deletes\n    ** every row that refers to a table of the same name as the one being\n    ** dropped. Triggers are handled seperately because a trigger can be\n    ** created in the temp database that refers to a table in another\n    ** database.\n    */\n    sqlite3NestedParse(pParse, \n        \"DELETE FROM %Q.%s WHERE tbl_name=%Q and type!='trigger'\",\n        pDb->zName, SCHEMA_TABLE(iDb), pTab->zName);\n\n    /* Drop any statistics from the sqlite_stat1 table, if it exists */\n    if( sqlite3FindTable(db, \"sqlite_stat1\", db->aDb[iDb].zName) ){\n      sqlite3NestedParse(pParse,\n        \"DELETE FROM %Q.sqlite_stat1 WHERE tbl=%Q\", pDb->zName, pTab->zName\n      );\n    }\n\n    if( !isView && !IsVirtual(pTab) ){\n      destroyTable(pParse, pTab);\n    }\n\n    /* Remove the table entry from SQLite's internal schema and modify\n    ** the schema cookie.\n    */\n    if( IsVirtual(pTab) ){\n      sqlite3VdbeAddOp4(v, OP_VDestroy, iDb, 0, 0, pTab->zName, 0);\n    }\n    sqlite3VdbeAddOp4(v, OP_DropTable, iDb, 0, 0, pTab->zName, 0);\n    sqlite3ChangeCookie(pParse, iDb);\n  }\n  sqliteViewResetAll(db, iDb);\n\nexit_drop_table:\n  sqlite3SrcListDelete(db, pName);\n}\n\n/*\n** This routine is called to create a new foreign key on the table\n** currently under construction.  pFromCol determines which columns\n** in the current table point to the foreign key.  If pFromCol==0 then\n** connect the key to the last column inserted.  pTo is the name of\n** the table referred to.  pToCol is a list of tables in the other\n** pTo table that the foreign key points to.  flags contains all\n** information about the conflict resolution algorithms specified\n** in the ON DELETE, ON UPDATE and ON INSERT clauses.\n**\n** An FKey structure is created and added to the table currently\n** under construction in the pParse->pNewTable field.\n**\n** The foreign key is set for IMMEDIATE processing.  A subsequent call\n** to sqlite3DeferForeignKey() might change this to DEFERRED.\n*/\nSQLITE_PRIVATE void sqlite3CreateForeignKey(\n  Parse *pParse,       /* Parsing context */\n  ExprList *pFromCol,  /* Columns in this table that point to other table */\n  Token *pTo,          /* Name of the other table */\n  ExprList *pToCol,    /* Columns in the other table */\n  int flags            /* Conflict resolution algorithms. */\n){\n  sqlite3 *db = pParse->db;\n#ifndef SQLITE_OMIT_FOREIGN_KEY\n  FKey *pFKey = 0;\n  FKey *pNextTo;\n  Table *p = pParse->pNewTable;\n  int nByte;\n  int i;\n  int nCol;\n  char *z;\n\n  assert( pTo!=0 );\n  if( p==0 || IN_DECLARE_VTAB ) goto fk_end;\n  if( pFromCol==0 ){\n    int iCol = p->nCol-1;\n    if( NEVER(iCol<0) ) goto fk_end;\n    if( pToCol && pToCol->nExpr!=1 ){\n      sqlite3ErrorMsg(pParse, \"foreign key on %s\"\n         \" should reference only one column of table %T\",\n         p->aCol[iCol].zName, pTo);\n      goto fk_end;\n    }\n    nCol = 1;\n  }else if( pToCol && pToCol->nExpr!=pFromCol->nExpr ){\n    sqlite3ErrorMsg(pParse,\n        \"number of columns in foreign key does not match the number of \"\n        \"columns in the referenced table\");\n    goto fk_end;\n  }else{\n    nCol = pFromCol->nExpr;\n  }\n  nByte = sizeof(*pFKey) + (nCol-1)*sizeof(pFKey->aCol[0]) + pTo->n + 1;\n  if( pToCol ){\n    for(i=0; i<pToCol->nExpr; i++){\n      nByte += sqlite3Strlen30(pToCol->a[i].zName) + 1;\n    }\n  }\n  pFKey = sqlite3DbMallocZero(db, nByte );\n  if( pFKey==0 ){\n    goto fk_end;\n  }\n  pFKey->pFrom = p;\n  pFKey->pNextFrom = p->pFKey;\n  z = (char*)&pFKey->aCol[nCol];\n  pFKey->zTo = z;\n  memcpy(z, pTo->z, pTo->n);\n  z[pTo->n] = 0;\n  sqlite3Dequote(z);\n  z += pTo->n+1;\n  pFKey->nCol = nCol;\n  if( pFromCol==0 ){\n    pFKey->aCol[0].iFrom = p->nCol-1;\n  }else{\n    for(i=0; i<nCol; i++){\n      int j;\n      for(j=0; j<p->nCol; j++){\n        if( sqlite3StrICmp(p->aCol[j].zName, pFromCol->a[i].zName)==0 ){\n          pFKey->aCol[i].iFrom = j;\n          break;\n        }\n      }\n      if( j>=p->nCol ){\n        sqlite3ErrorMsg(pParse, \n          \"unknown column \\\"%s\\\" in foreign key definition\", \n          pFromCol->a[i].zName);\n        goto fk_end;\n      }\n    }\n  }\n  if( pToCol ){\n    for(i=0; i<nCol; i++){\n      int n = sqlite3Strlen30(pToCol->a[i].zName);\n      pFKey->aCol[i].zCol = z;\n      memcpy(z, pToCol->a[i].zName, n);\n      z[n] = 0;\n      z += n+1;\n    }\n  }\n  pFKey->isDeferred = 0;\n  pFKey->aAction[0] = (u8)(flags & 0xff);            /* ON DELETE action */\n  pFKey->aAction[1] = (u8)((flags >> 8 ) & 0xff);    /* ON UPDATE action */\n\n  pNextTo = (FKey *)sqlite3HashInsert(&p->pSchema->fkeyHash, \n      pFKey->zTo, sqlite3Strlen30(pFKey->zTo), (void *)pFKey\n  );\n  if( pNextTo==pFKey ){\n    db->mallocFailed = 1;\n    goto fk_end;\n  }\n  if( pNextTo ){\n    assert( pNextTo->pPrevTo==0 );\n    pFKey->pNextTo = pNextTo;\n    pNextTo->pPrevTo = pFKey;\n  }\n\n  /* Link the foreign key to the table as the last step.\n  */\n  p->pFKey = pFKey;\n  pFKey = 0;\n\nfk_end:\n  sqlite3DbFree(db, pFKey);\n#endif /* !defined(SQLITE_OMIT_FOREIGN_KEY) */\n  sqlite3ExprListDelete(db, pFromCol);\n  sqlite3ExprListDelete(db, pToCol);\n}\n\n/*\n** This routine is called when an INITIALLY IMMEDIATE or INITIALLY DEFERRED\n** clause is seen as part of a foreign key definition.  The isDeferred\n** parameter is 1 for INITIALLY DEFERRED and 0 for INITIALLY IMMEDIATE.\n** The behavior of the most recently created foreign key is adjusted\n** accordingly.\n*/\nSQLITE_PRIVATE void sqlite3DeferForeignKey(Parse *pParse, int isDeferred){\n#ifndef SQLITE_OMIT_FOREIGN_KEY\n  Table *pTab;\n  FKey *pFKey;\n  if( (pTab = pParse->pNewTable)==0 || (pFKey = pTab->pFKey)==0 ) return;\n  assert( isDeferred==0 || isDeferred==1 ); /* EV: R-30323-21917 */\n  pFKey->isDeferred = (u8)isDeferred;\n#endif\n}\n\n/*\n** Generate code that will erase and refill index *pIdx.  This is\n** used to initialize a newly created index or to recompute the\n** content of an index in response to a REINDEX command.\n**\n** if memRootPage is not negative, it means that the index is newly\n** created.  The register specified by memRootPage contains the\n** root page number of the index.  If memRootPage is negative, then\n** the index already exists and must be cleared before being refilled and\n** the root page number of the index is taken from pIndex->tnum.\n*/\nstatic void sqlite3RefillIndex(Parse *pParse, Index *pIndex, int memRootPage){\n  Table *pTab = pIndex->pTable;  /* The table that is indexed */\n  int iTab = pParse->nTab++;     /* Btree cursor used for pTab */\n  int iIdx = pParse->nTab++;     /* Btree cursor used for pIndex */\n  int addr1;                     /* Address of top of loop */\n  int tnum;                      /* Root page of index */\n  Vdbe *v;                       /* Generate code into this virtual machine */\n  KeyInfo *pKey;                 /* KeyInfo for index */\n  int regIdxKey;                 /* Registers containing the index key */\n  int regRecord;                 /* Register holding assemblied index record */\n  sqlite3 *db = pParse->db;      /* The database connection */\n  int iDb = sqlite3SchemaToIndex(db, pIndex->pSchema);\n\n#ifndef SQLITE_OMIT_AUTHORIZATION\n  if( sqlite3AuthCheck(pParse, SQLITE_REINDEX, pIndex->zName, 0,\n      db->aDb[iDb].zName ) ){\n    return;\n  }\n#endif\n\n  /* Require a write-lock on the table to perform this operation */\n  sqlite3TableLock(pParse, iDb, pTab->tnum, 1, pTab->zName);\n\n  v = sqlite3GetVdbe(pParse);\n  if( v==0 ) return;\n  if( memRootPage>=0 ){\n    tnum = memRootPage;\n  }else{\n    tnum = pIndex->tnum;\n    sqlite3VdbeAddOp2(v, OP_Clear, tnum, iDb);\n  }\n  pKey = sqlite3IndexKeyinfo(pParse, pIndex);\n  sqlite3VdbeAddOp4(v, OP_OpenWrite, iIdx, tnum, iDb, \n                    (char *)pKey, P4_KEYINFO_HANDOFF);\n  if( memRootPage>=0 ){\n    sqlite3VdbeChangeP5(v, 1);\n  }\n  sqlite3OpenTable(pParse, iTab, iDb, pTab, OP_OpenRead);\n  addr1 = sqlite3VdbeAddOp2(v, OP_Rewind, iTab, 0);\n  regRecord = sqlite3GetTempReg(pParse);\n  regIdxKey = sqlite3GenerateIndexKey(pParse, pIndex, iTab, regRecord, 1);\n  if( pIndex->onError!=OE_None ){\n    const int regRowid = regIdxKey + pIndex->nColumn;\n    const int j2 = sqlite3VdbeCurrentAddr(v) + 2;\n    void * const pRegKey = SQLITE_INT_TO_PTR(regIdxKey);\n\n    /* The registers accessed by the OP_IsUnique opcode were allocated\n    ** using sqlite3GetTempRange() inside of the sqlite3GenerateIndexKey()\n    ** call above. Just before that function was freed they were released\n    ** (made available to the compiler for reuse) using \n    ** sqlite3ReleaseTempRange(). So in some ways having the OP_IsUnique\n    ** opcode use the values stored within seems dangerous. However, since\n    ** we can be sure that no other temp registers have been allocated\n    ** since sqlite3ReleaseTempRange() was called, it is safe to do so.\n    */\n    sqlite3VdbeAddOp4(v, OP_IsUnique, iIdx, j2, regRowid, pRegKey, P4_INT32);\n    sqlite3HaltConstraint(\n        pParse, OE_Abort, \"indexed columns are not unique\", P4_STATIC);\n  }\n  sqlite3VdbeAddOp2(v, OP_IdxInsert, iIdx, regRecord);\n  sqlite3VdbeChangeP5(v, OPFLAG_USESEEKRESULT);\n  sqlite3ReleaseTempReg(pParse, regRecord);\n  sqlite3VdbeAddOp2(v, OP_Next, iTab, addr1+1);\n  sqlite3VdbeJumpHere(v, addr1);\n  sqlite3VdbeAddOp1(v, OP_Close, iTab);\n  sqlite3VdbeAddOp1(v, OP_Close, iIdx);\n}\n\n/*\n** Create a new index for an SQL table.  pName1.pName2 is the name of the index \n** and pTblList is the name of the table that is to be indexed.  Both will \n** be NULL for a primary key or an index that is created to satisfy a\n** UNIQUE constraint.  If pTable and pIndex are NULL, use pParse->pNewTable\n** as the table to be indexed.  pParse->pNewTable is a table that is\n** currently being constructed by a CREATE TABLE statement.\n**\n** pList is a list of columns to be indexed.  pList will be NULL if this\n** is a primary key or unique-constraint on the most recent column added\n** to the table currently under construction.  \n**\n** If the index is created successfully, return a pointer to the new Index\n** structure. This is used by sqlite3AddPrimaryKey() to mark the index\n** as the tables primary key (Index.autoIndex==2).\n*/\nSQLITE_PRIVATE Index *sqlite3CreateIndex(\n  Parse *pParse,     /* All information about this parse */\n  Token *pName1,     /* First part of index name. May be NULL */\n  Token *pName2,     /* Second part of index name. May be NULL */\n  SrcList *pTblName, /* Table to index. Use pParse->pNewTable if 0 */\n  ExprList *pList,   /* A list of columns to be indexed */\n  int onError,       /* OE_Abort, OE_Ignore, OE_Replace, or OE_None */\n  Token *pStart,     /* The CREATE token that begins this statement */\n  Token *pEnd,       /* The \")\" that closes the CREATE INDEX statement */\n  int sortOrder,     /* Sort order of primary key when pList==NULL */\n  int ifNotExist     /* Omit error if index already exists */\n){\n  Index *pRet = 0;     /* Pointer to return */\n  Table *pTab = 0;     /* Table to be indexed */\n  Index *pIndex = 0;   /* The index to be created */\n  char *zName = 0;     /* Name of the index */\n  int nName;           /* Number of characters in zName */\n  int i, j;\n  Token nullId;        /* Fake token for an empty ID list */\n  DbFixer sFix;        /* For assigning database names to pTable */\n  int sortOrderMask;   /* 1 to honor DESC in index.  0 to ignore. */\n  sqlite3 *db = pParse->db;\n  Db *pDb;             /* The specific table containing the indexed database */\n  int iDb;             /* Index of the database that is being written */\n  Token *pName = 0;    /* Unqualified name of the index to create */\n  struct ExprList_item *pListItem; /* For looping over pList */\n  int nCol;\n  int nExtra = 0;\n  char *zExtra;\n\n  assert( pStart==0 || pEnd!=0 ); /* pEnd must be non-NULL if pStart is */\n  assert( pParse->nErr==0 );      /* Never called with prior errors */\n  if( db->mallocFailed || IN_DECLARE_VTAB ){\n    goto exit_create_index;\n  }\n  if( SQLITE_OK!=sqlite3ReadSchema(pParse) ){\n    goto exit_create_index;\n  }\n\n  /*\n  ** Find the table that is to be indexed.  Return early if not found.\n  */\n  if( pTblName!=0 ){\n\n    /* Use the two-part index name to determine the database \n    ** to search for the table. 'Fix' the table name to this db\n    ** before looking up the table.\n    */\n    assert( pName1 && pName2 );\n    iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pName);\n    if( iDb<0 ) goto exit_create_index;\n\n#ifndef SQLITE_OMIT_TEMPDB\n    /* If the index name was unqualified, check if the the table\n    ** is a temp table. If so, set the database to 1. Do not do this\n    ** if initialising a database schema.\n    */\n    if( !db->init.busy ){\n      pTab = sqlite3SrcListLookup(pParse, pTblName);\n      if( pName2->n==0 && pTab && pTab->pSchema==db->aDb[1].pSchema ){\n        iDb = 1;\n      }\n    }\n#endif\n\n    if( sqlite3FixInit(&sFix, pParse, iDb, \"index\", pName) &&\n        sqlite3FixSrcList(&sFix, pTblName)\n    ){\n      /* Because the parser constructs pTblName from a single identifier,\n      ** sqlite3FixSrcList can never fail. */\n      assert(0);\n    }\n    pTab = sqlite3LocateTable(pParse, 0, pTblName->a[0].zName, \n        pTblName->a[0].zDatabase);\n    if( !pTab || db->mallocFailed ) goto exit_create_index;\n    assert( db->aDb[iDb].pSchema==pTab->pSchema );\n  }else{\n    assert( pName==0 );\n    pTab = pParse->pNewTable;\n    if( !pTab ) goto exit_create_index;\n    iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n  }\n  pDb = &db->aDb[iDb];\n\n  assert( pTab!=0 );\n  assert( pParse->nErr==0 );\n  if( sqlite3StrNICmp(pTab->zName, \"sqlite_\", 7)==0 \n       && memcmp(&pTab->zName[7],\"altertab_\",9)!=0 ){\n    sqlite3ErrorMsg(pParse, \"table %s may not be indexed\", pTab->zName);\n    goto exit_create_index;\n  }\n#ifndef SQLITE_OMIT_VIEW\n  if( pTab->pSelect ){\n    sqlite3ErrorMsg(pParse, \"views may not be indexed\");\n    goto exit_create_index;\n  }\n#endif\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  if( IsVirtual(pTab) ){\n    sqlite3ErrorMsg(pParse, \"virtual tables may not be indexed\");\n    goto exit_create_index;\n  }\n#endif\n\n  /*\n  ** Find the name of the index.  Make sure there is not already another\n  ** index or table with the same name.  \n  **\n  ** Exception:  If we are reading the names of permanent indices from the\n  ** sqlite_master table (because some other process changed the schema) and\n  ** one of the index names collides with the name of a temporary table or\n  ** index, then we will continue to process this index.\n  **\n  ** If pName==0 it means that we are\n  ** dealing with a primary key or UNIQUE constraint.  We have to invent our\n  ** own name.\n  */\n  if( pName ){\n    zName = sqlite3NameFromToken(db, pName);\n    if( zName==0 ) goto exit_create_index;\n    if( SQLITE_OK!=sqlite3CheckObjectName(pParse, zName) ){\n      goto exit_create_index;\n    }\n    if( !db->init.busy ){\n      if( sqlite3FindTable(db, zName, 0)!=0 ){\n        sqlite3ErrorMsg(pParse, \"there is already a table named %s\", zName);\n        goto exit_create_index;\n      }\n    }\n    if( sqlite3FindIndex(db, zName, pDb->zName)!=0 ){\n      if( !ifNotExist ){\n        sqlite3ErrorMsg(pParse, \"index %s already exists\", zName);\n      }\n      goto exit_create_index;\n    }\n  }else{\n    int n;\n    Index *pLoop;\n    for(pLoop=pTab->pIndex, n=1; pLoop; pLoop=pLoop->pNext, n++){}\n    zName = sqlite3MPrintf(db, \"sqlite_autoindex_%s_%d\", pTab->zName, n);\n    if( zName==0 ){\n      goto exit_create_index;\n    }\n  }\n\n  /* Check for authorization to create an index.\n  */\n#ifndef SQLITE_OMIT_AUTHORIZATION\n  {\n    const char *zDb = pDb->zName;\n    if( sqlite3AuthCheck(pParse, SQLITE_INSERT, SCHEMA_TABLE(iDb), 0, zDb) ){\n      goto exit_create_index;\n    }\n    i = SQLITE_CREATE_INDEX;\n    if( !OMIT_TEMPDB && iDb==1 ) i = SQLITE_CREATE_TEMP_INDEX;\n    if( sqlite3AuthCheck(pParse, i, zName, pTab->zName, zDb) ){\n      goto exit_create_index;\n    }\n  }\n#endif\n\n  /* If pList==0, it means this routine was called to make a primary\n  ** key out of the last column added to the table under construction.\n  ** So create a fake list to simulate this.\n  */\n  if( pList==0 ){\n    nullId.z = pTab->aCol[pTab->nCol-1].zName;\n    nullId.n = sqlite3Strlen30((char*)nullId.z);\n    pList = sqlite3ExprListAppend(pParse, 0, 0);\n    if( pList==0 ) goto exit_create_index;\n    sqlite3ExprListSetName(pParse, pList, &nullId, 0);\n    pList->a[0].sortOrder = (u8)sortOrder;\n  }\n\n  /* Figure out how many bytes of space are required to store explicitly\n  ** specified collation sequence names.\n  */\n  for(i=0; i<pList->nExpr; i++){\n    Expr *pExpr = pList->a[i].pExpr;\n    if( pExpr ){\n      CollSeq *pColl = pExpr->pColl;\n      /* Either pColl!=0 or there was an OOM failure.  But if an OOM\n      ** failure we have quit before reaching this point. */\n      if( ALWAYS(pColl) ){\n        nExtra += (1 + sqlite3Strlen30(pColl->zName));\n      }\n    }\n  }\n\n  /* \n  ** Allocate the index structure. \n  */\n  nName = sqlite3Strlen30(zName);\n  nCol = pList->nExpr;\n  pIndex = sqlite3DbMallocZero(db, \n      sizeof(Index) +              /* Index structure  */\n      sizeof(int)*nCol +           /* Index.aiColumn   */\n      sizeof(int)*(nCol+1) +       /* Index.aiRowEst   */\n      sizeof(char *)*nCol +        /* Index.azColl     */\n      sizeof(u8)*nCol +            /* Index.aSortOrder */\n      nName + 1 +                  /* Index.zName      */\n      nExtra                       /* Collation sequence names */\n  );\n  if( db->mallocFailed ){\n    goto exit_create_index;\n  }\n  pIndex->azColl = (char**)(&pIndex[1]);\n  pIndex->aiColumn = (int *)(&pIndex->azColl[nCol]);\n  pIndex->aiRowEst = (unsigned *)(&pIndex->aiColumn[nCol]);\n  pIndex->aSortOrder = (u8 *)(&pIndex->aiRowEst[nCol+1]);\n  pIndex->zName = (char *)(&pIndex->aSortOrder[nCol]);\n  zExtra = (char *)(&pIndex->zName[nName+1]);\n  memcpy(pIndex->zName, zName, nName+1);\n  pIndex->pTable = pTab;\n  pIndex->nColumn = pList->nExpr;\n  pIndex->onError = (u8)onError;\n  pIndex->autoIndex = (u8)(pName==0);\n  pIndex->pSchema = db->aDb[iDb].pSchema;\n\n  /* Check to see if we should honor DESC requests on index columns\n  */\n  if( pDb->pSchema->file_format>=4 ){\n    sortOrderMask = -1;   /* Honor DESC */\n  }else{\n    sortOrderMask = 0;    /* Ignore DESC */\n  }\n\n  /* Scan the names of the columns of the table to be indexed and\n  ** load the column indices into the Index structure.  Report an error\n  ** if any column is not found.\n  **\n  ** TODO:  Add a test to make sure that the same column is not named\n  ** more than once within the same index.  Only the first instance of\n  ** the column will ever be used by the optimizer.  Note that using the\n  ** same column more than once cannot be an error because that would \n  ** break backwards compatibility - it needs to be a warning.\n  */\n  for(i=0, pListItem=pList->a; i<pList->nExpr; i++, pListItem++){\n    const char *zColName = pListItem->zName;\n    Column *pTabCol;\n    int requestedSortOrder;\n    char *zColl;                   /* Collation sequence name */\n\n    for(j=0, pTabCol=pTab->aCol; j<pTab->nCol; j++, pTabCol++){\n      if( sqlite3StrICmp(zColName, pTabCol->zName)==0 ) break;\n    }\n    if( j>=pTab->nCol ){\n      sqlite3ErrorMsg(pParse, \"table %s has no column named %s\",\n        pTab->zName, zColName);\n      pParse->checkSchema = 1;\n      goto exit_create_index;\n    }\n    pIndex->aiColumn[i] = j;\n    /* Justification of the ALWAYS(pListItem->pExpr->pColl):  Because of\n    ** the way the \"idxlist\" non-terminal is constructed by the parser,\n    ** if pListItem->pExpr is not null then either pListItem->pExpr->pColl\n    ** must exist or else there must have been an OOM error.  But if there\n    ** was an OOM error, we would never reach this point. */\n    if( pListItem->pExpr && ALWAYS(pListItem->pExpr->pColl) ){\n      int nColl;\n      zColl = pListItem->pExpr->pColl->zName;\n      nColl = sqlite3Strlen30(zColl) + 1;\n      assert( nExtra>=nColl );\n      memcpy(zExtra, zColl, nColl);\n      zColl = zExtra;\n      zExtra += nColl;\n      nExtra -= nColl;\n    }else{\n      zColl = pTab->aCol[j].zColl;\n      if( !zColl ){\n        zColl = db->pDfltColl->zName;\n      }\n    }\n    if( !db->init.busy && !sqlite3LocateCollSeq(pParse, zColl) ){\n      goto exit_create_index;\n    }\n    pIndex->azColl[i] = zColl;\n    requestedSortOrder = pListItem->sortOrder & sortOrderMask;\n    pIndex->aSortOrder[i] = (u8)requestedSortOrder;\n  }\n  sqlite3DefaultRowEst(pIndex);\n\n  if( pTab==pParse->pNewTable ){\n    /* This routine has been called to create an automatic index as a\n    ** result of a PRIMARY KEY or UNIQUE clause on a column definition, or\n    ** a PRIMARY KEY or UNIQUE clause following the column definitions.\n    ** i.e. one of:\n    **\n    ** CREATE TABLE t(x PRIMARY KEY, y);\n    ** CREATE TABLE t(x, y, UNIQUE(x, y));\n    **\n    ** Either way, check to see if the table already has such an index. If\n    ** so, don't bother creating this one. This only applies to\n    ** automatically created indices. Users can do as they wish with\n    ** explicit indices.\n    **\n    ** Two UNIQUE or PRIMARY KEY constraints are considered equivalent\n    ** (and thus suppressing the second one) even if they have different\n    ** sort orders.\n    **\n    ** If there are different collating sequences or if the columns of\n    ** the constraint occur in different orders, then the constraints are\n    ** considered distinct and both result in separate indices.\n    */\n    Index *pIdx;\n    for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){\n      int k;\n      assert( pIdx->onError!=OE_None );\n      assert( pIdx->autoIndex );\n      assert( pIndex->onError!=OE_None );\n\n      if( pIdx->nColumn!=pIndex->nColumn ) continue;\n      for(k=0; k<pIdx->nColumn; k++){\n        const char *z1;\n        const char *z2;\n        if( pIdx->aiColumn[k]!=pIndex->aiColumn[k] ) break;\n        z1 = pIdx->azColl[k];\n        z2 = pIndex->azColl[k];\n        if( z1!=z2 && sqlite3StrICmp(z1, z2) ) break;\n      }\n      if( k==pIdx->nColumn ){\n        if( pIdx->onError!=pIndex->onError ){\n          /* This constraint creates the same index as a previous\n          ** constraint specified somewhere in the CREATE TABLE statement.\n          ** However the ON CONFLICT clauses are different. If both this \n          ** constraint and the previous equivalent constraint have explicit\n          ** ON CONFLICT clauses this is an error. Otherwise, use the\n          ** explicitly specified behaviour for the index.\n          */\n          if( !(pIdx->onError==OE_Default || pIndex->onError==OE_Default) ){\n            sqlite3ErrorMsg(pParse, \n                \"conflicting ON CONFLICT clauses specified\", 0);\n          }\n          if( pIdx->onError==OE_Default ){\n            pIdx->onError = pIndex->onError;\n          }\n        }\n        goto exit_create_index;\n      }\n    }\n  }\n\n  /* Link the new Index structure to its table and to the other\n  ** in-memory database structures. \n  */\n  if( db->init.busy ){\n    Index *p;\n    p = sqlite3HashInsert(&pIndex->pSchema->idxHash, \n                          pIndex->zName, sqlite3Strlen30(pIndex->zName),\n                          pIndex);\n    if( p ){\n      assert( p==pIndex );  /* Malloc must have failed */\n      db->mallocFailed = 1;\n      goto exit_create_index;\n    }\n    db->flags |= SQLITE_InternChanges;\n    if( pTblName!=0 ){\n      pIndex->tnum = db->init.newTnum;\n    }\n  }\n\n  /* If the db->init.busy is 0 then create the index on disk.  This\n  ** involves writing the index into the master table and filling in the\n  ** index with the current table contents.\n  **\n  ** The db->init.busy is 0 when the user first enters a CREATE INDEX \n  ** command.  db->init.busy is 1 when a database is opened and \n  ** CREATE INDEX statements are read out of the master table.  In\n  ** the latter case the index already exists on disk, which is why\n  ** we don't want to recreate it.\n  **\n  ** If pTblName==0 it means this index is generated as a primary key\n  ** or UNIQUE constraint of a CREATE TABLE statement.  Since the table\n  ** has just been created, it contains no data and the index initialization\n  ** step can be skipped.\n  */\n  else{ /* if( db->init.busy==0 ) */\n    Vdbe *v;\n    char *zStmt;\n    int iMem = ++pParse->nMem;\n\n    v = sqlite3GetVdbe(pParse);\n    if( v==0 ) goto exit_create_index;\n\n\n    /* Create the rootpage for the index\n    */\n    sqlite3BeginWriteOperation(pParse, 1, iDb);\n    sqlite3VdbeAddOp2(v, OP_CreateIndex, iDb, iMem);\n\n    /* Gather the complete text of the CREATE INDEX statement into\n    ** the zStmt variable\n    */\n    if( pStart ){\n      assert( pEnd!=0 );\n      /* A named index with an explicit CREATE INDEX statement */\n      zStmt = sqlite3MPrintf(db, \"CREATE%s INDEX %.*s\",\n        onError==OE_None ? \"\" : \" UNIQUE\",\n        pEnd->z - pName->z + 1,\n        pName->z);\n    }else{\n      /* An automatic index created by a PRIMARY KEY or UNIQUE constraint */\n      /* zStmt = sqlite3MPrintf(\"\"); */\n      zStmt = 0;\n    }\n\n    /* Add an entry in sqlite_master for this index\n    */\n    sqlite3NestedParse(pParse, \n        \"INSERT INTO %Q.%s VALUES('index',%Q,%Q,#%d,%Q);\",\n        db->aDb[iDb].zName, SCHEMA_TABLE(iDb),\n        pIndex->zName,\n        pTab->zName,\n        iMem,\n        zStmt\n    );\n    sqlite3DbFree(db, zStmt);\n\n    /* Fill the index with data and reparse the schema. Code an OP_Expire\n    ** to invalidate all pre-compiled statements.\n    */\n    if( pTblName ){\n      sqlite3RefillIndex(pParse, pIndex, iMem);\n      sqlite3ChangeCookie(pParse, iDb);\n      sqlite3VdbeAddOp4(v, OP_ParseSchema, iDb, 0, 0,\n         sqlite3MPrintf(db, \"name='%q' AND type='index'\", pIndex->zName), \n         P4_DYNAMIC);\n      sqlite3VdbeAddOp1(v, OP_Expire, 0);\n    }\n  }\n\n  /* When adding an index to the list of indices for a table, make\n  ** sure all indices labeled OE_Replace come after all those labeled\n  ** OE_Ignore.  This is necessary for the correct constraint check\n  ** processing (in sqlite3GenerateConstraintChecks()) as part of\n  ** UPDATE and INSERT statements.  \n  */\n  if( db->init.busy || pTblName==0 ){\n    if( onError!=OE_Replace || pTab->pIndex==0\n         || pTab->pIndex->onError==OE_Replace){\n      pIndex->pNext = pTab->pIndex;\n      pTab->pIndex = pIndex;\n    }else{\n      Index *pOther = pTab->pIndex;\n      while( pOther->pNext && pOther->pNext->onError!=OE_Replace ){\n        pOther = pOther->pNext;\n      }\n      pIndex->pNext = pOther->pNext;\n      pOther->pNext = pIndex;\n    }\n    pRet = pIndex;\n    pIndex = 0;\n  }\n\n  /* Clean up before exiting */\nexit_create_index:\n  if( pIndex ){\n    sqlite3DbFree(db, pIndex->zColAff);\n    sqlite3DbFree(db, pIndex);\n  }\n  sqlite3ExprListDelete(db, pList);\n  sqlite3SrcListDelete(db, pTblName);\n  sqlite3DbFree(db, zName);\n  return pRet;\n}\n\n/*\n** Fill the Index.aiRowEst[] array with default information - information\n** to be used when we have not run the ANALYZE command.\n**\n** aiRowEst[0] is suppose to contain the number of elements in the index.\n** Since we do not know, guess 1 million.  aiRowEst[1] is an estimate of the\n** number of rows in the table that match any particular value of the\n** first column of the index.  aiRowEst[2] is an estimate of the number\n** of rows that match any particular combiniation of the first 2 columns\n** of the index.  And so forth.  It must always be the case that\n*\n**           aiRowEst[N]<=aiRowEst[N-1]\n**           aiRowEst[N]>=1\n**\n** Apart from that, we have little to go on besides intuition as to\n** how aiRowEst[] should be initialized.  The numbers generated here\n** are based on typical values found in actual indices.\n*/\nSQLITE_PRIVATE void sqlite3DefaultRowEst(Index *pIdx){\n  unsigned *a = pIdx->aiRowEst;\n  int i;\n  unsigned n;\n  assert( a!=0 );\n  a[0] = pIdx->pTable->nRowEst;\n  if( a[0]<10 ) a[0] = 10;\n  n = 10;\n  for(i=1; i<=pIdx->nColumn; i++){\n    a[i] = n;\n    if( n>5 ) n--;\n  }\n  if( pIdx->onError!=OE_None ){\n    a[pIdx->nColumn] = 1;\n  }\n}\n\n/*\n** This routine will drop an existing named index.  This routine\n** implements the DROP INDEX statement.\n*/\nSQLITE_PRIVATE void sqlite3DropIndex(Parse *pParse, SrcList *pName, int ifExists){\n  Index *pIndex;\n  Vdbe *v;\n  sqlite3 *db = pParse->db;\n  int iDb;\n\n  assert( pParse->nErr==0 );   /* Never called with prior errors */\n  if( db->mallocFailed ){\n    goto exit_drop_index;\n  }\n  assert( pName->nSrc==1 );\n  if( SQLITE_OK!=sqlite3ReadSchema(pParse) ){\n    goto exit_drop_index;\n  }\n  pIndex = sqlite3FindIndex(db, pName->a[0].zName, pName->a[0].zDatabase);\n  if( pIndex==0 ){\n    if( !ifExists ){\n      sqlite3ErrorMsg(pParse, \"no such index: %S\", pName, 0);\n    }\n    pParse->checkSchema = 1;\n    goto exit_drop_index;\n  }\n  if( pIndex->autoIndex ){\n    sqlite3ErrorMsg(pParse, \"index associated with UNIQUE \"\n      \"or PRIMARY KEY constraint cannot be dropped\", 0);\n    goto exit_drop_index;\n  }\n  iDb = sqlite3SchemaToIndex(db, pIndex->pSchema);\n#ifndef SQLITE_OMIT_AUTHORIZATION\n  {\n    int code = SQLITE_DROP_INDEX;\n    Table *pTab = pIndex->pTable;\n    const char *zDb = db->aDb[iDb].zName;\n    const char *zTab = SCHEMA_TABLE(iDb);\n    if( sqlite3AuthCheck(pParse, SQLITE_DELETE, zTab, 0, zDb) ){\n      goto exit_drop_index;\n    }\n    if( !OMIT_TEMPDB && iDb ) code = SQLITE_DROP_TEMP_INDEX;\n    if( sqlite3AuthCheck(pParse, code, pIndex->zName, pTab->zName, zDb) ){\n      goto exit_drop_index;\n    }\n  }\n#endif\n\n  /* Generate code to remove the index and from the master table */\n  v = sqlite3GetVdbe(pParse);\n  if( v ){\n    sqlite3BeginWriteOperation(pParse, 1, iDb);\n    sqlite3NestedParse(pParse,\n       \"DELETE FROM %Q.%s WHERE name=%Q AND type='index'\",\n       db->aDb[iDb].zName, SCHEMA_TABLE(iDb),\n       pIndex->zName\n    );\n    if( sqlite3FindTable(db, \"sqlite_stat1\", db->aDb[iDb].zName) ){\n      sqlite3NestedParse(pParse,\n        \"DELETE FROM %Q.sqlite_stat1 WHERE idx=%Q\",\n        db->aDb[iDb].zName, pIndex->zName\n      );\n    }\n    sqlite3ChangeCookie(pParse, iDb);\n    destroyRootPage(pParse, pIndex->tnum, iDb);\n    sqlite3VdbeAddOp4(v, OP_DropIndex, iDb, 0, 0, pIndex->zName, 0);\n  }\n\nexit_drop_index:\n  sqlite3SrcListDelete(db, pName);\n}\n\n/*\n** pArray is a pointer to an array of objects.  Each object in the\n** array is szEntry bytes in size.  This routine allocates a new\n** object on the end of the array.\n**\n** *pnEntry is the number of entries already in use.  *pnAlloc is\n** the previously allocated size of the array.  initSize is the\n** suggested initial array size allocation.\n**\n** The index of the new entry is returned in *pIdx.\n**\n** This routine returns a pointer to the array of objects.  This\n** might be the same as the pArray parameter or it might be a different\n** pointer if the array was resized.\n*/\nSQLITE_PRIVATE void *sqlite3ArrayAllocate(\n  sqlite3 *db,      /* Connection to notify of malloc failures */\n  void *pArray,     /* Array of objects.  Might be reallocated */\n  int szEntry,      /* Size of each object in the array */\n  int initSize,     /* Suggested initial allocation, in elements */\n  int *pnEntry,     /* Number of objects currently in use */\n  int *pnAlloc,     /* Current size of the allocation, in elements */\n  int *pIdx         /* Write the index of a new slot here */\n){\n  char *z;\n  if( *pnEntry >= *pnAlloc ){\n    void *pNew;\n    int newSize;\n    newSize = (*pnAlloc)*2 + initSize;\n    pNew = sqlite3DbRealloc(db, pArray, newSize*szEntry);\n    if( pNew==0 ){\n      *pIdx = -1;\n      return pArray;\n    }\n    *pnAlloc = sqlite3DbMallocSize(db, pNew)/szEntry;\n    pArray = pNew;\n  }\n  z = (char*)pArray;\n  memset(&z[*pnEntry * szEntry], 0, szEntry);\n  *pIdx = *pnEntry;\n  ++*pnEntry;\n  return pArray;\n}\n\n/*\n** Append a new element to the given IdList.  Create a new IdList if\n** need be.\n**\n** A new IdList is returned, or NULL if malloc() fails.\n*/\nSQLITE_PRIVATE IdList *sqlite3IdListAppend(sqlite3 *db, IdList *pList, Token *pToken){\n  int i;\n  if( pList==0 ){\n    pList = sqlite3DbMallocZero(db, sizeof(IdList) );\n    if( pList==0 ) return 0;\n    pList->nAlloc = 0;\n  }\n  pList->a = sqlite3ArrayAllocate(\n      db,\n      pList->a,\n      sizeof(pList->a[0]),\n      5,\n      &pList->nId,\n      &pList->nAlloc,\n      &i\n  );\n  if( i<0 ){\n    sqlite3IdListDelete(db, pList);\n    return 0;\n  }\n  pList->a[i].zName = sqlite3NameFromToken(db, pToken);\n  return pList;\n}\n\n/*\n** Delete an IdList.\n*/\nSQLITE_PRIVATE void sqlite3IdListDelete(sqlite3 *db, IdList *pList){\n  int i;\n  if( pList==0 ) return;\n  for(i=0; i<pList->nId; i++){\n    sqlite3DbFree(db, pList->a[i].zName);\n  }\n  sqlite3DbFree(db, pList->a);\n  sqlite3DbFree(db, pList);\n}\n\n/*\n** Return the index in pList of the identifier named zId.  Return -1\n** if not found.\n*/\nSQLITE_PRIVATE int sqlite3IdListIndex(IdList *pList, const char *zName){\n  int i;\n  if( pList==0 ) return -1;\n  for(i=0; i<pList->nId; i++){\n    if( sqlite3StrICmp(pList->a[i].zName, zName)==0 ) return i;\n  }\n  return -1;\n}\n\n/*\n** Expand the space allocated for the given SrcList object by\n** creating nExtra new slots beginning at iStart.  iStart is zero based.\n** New slots are zeroed.\n**\n** For example, suppose a SrcList initially contains two entries: A,B.\n** To append 3 new entries onto the end, do this:\n**\n**    sqlite3SrcListEnlarge(db, pSrclist, 3, 2);\n**\n** After the call above it would contain:  A, B, nil, nil, nil.\n** If the iStart argument had been 1 instead of 2, then the result\n** would have been:  A, nil, nil, nil, B.  To prepend the new slots,\n** the iStart value would be 0.  The result then would\n** be: nil, nil, nil, A, B.\n**\n** If a memory allocation fails the SrcList is unchanged.  The\n** db->mallocFailed flag will be set to true.\n*/\nSQLITE_PRIVATE SrcList *sqlite3SrcListEnlarge(\n  sqlite3 *db,       /* Database connection to notify of OOM errors */\n  SrcList *pSrc,     /* The SrcList to be enlarged */\n  int nExtra,        /* Number of new slots to add to pSrc->a[] */\n  int iStart         /* Index in pSrc->a[] of first new slot */\n){\n  int i;\n\n  /* Sanity checking on calling parameters */\n  assert( iStart>=0 );\n  assert( nExtra>=1 );\n  assert( pSrc!=0 );\n  assert( iStart<=pSrc->nSrc );\n\n  /* Allocate additional space if needed */\n  if( pSrc->nSrc+nExtra>pSrc->nAlloc ){\n    SrcList *pNew;\n    int nAlloc = pSrc->nSrc+nExtra;\n    int nGot;\n    pNew = sqlite3DbRealloc(db, pSrc,\n               sizeof(*pSrc) + (nAlloc-1)*sizeof(pSrc->a[0]) );\n    if( pNew==0 ){\n      assert( db->mallocFailed );\n      return pSrc;\n    }\n    pSrc = pNew;\n    nGot = (sqlite3DbMallocSize(db, pNew) - sizeof(*pSrc))/sizeof(pSrc->a[0])+1;\n    pSrc->nAlloc = (u16)nGot;\n  }\n\n  /* Move existing slots that come after the newly inserted slots\n  ** out of the way */\n  for(i=pSrc->nSrc-1; i>=iStart; i--){\n    pSrc->a[i+nExtra] = pSrc->a[i];\n  }\n  pSrc->nSrc += (i16)nExtra;\n\n  /* Zero the newly allocated slots */\n  memset(&pSrc->a[iStart], 0, sizeof(pSrc->a[0])*nExtra);\n  for(i=iStart; i<iStart+nExtra; i++){\n    pSrc->a[i].iCursor = -1;\n  }\n\n  /* Return a pointer to the enlarged SrcList */\n  return pSrc;\n}\n\n\n/*\n** Append a new table name to the given SrcList.  Create a new SrcList if\n** need be.  A new entry is created in the SrcList even if pTable is NULL.\n**\n** A SrcList is returned, or NULL if there is an OOM error.  The returned\n** SrcList might be the same as the SrcList that was input or it might be\n** a new one.  If an OOM error does occurs, then the prior value of pList\n** that is input to this routine is automatically freed.\n**\n** If pDatabase is not null, it means that the table has an optional\n** database name prefix.  Like this:  \"database.table\".  The pDatabase\n** points to the table name and the pTable points to the database name.\n** The SrcList.a[].zName field is filled with the table name which might\n** come from pTable (if pDatabase is NULL) or from pDatabase.  \n** SrcList.a[].zDatabase is filled with the database name from pTable,\n** or with NULL if no database is specified.\n**\n** In other words, if call like this:\n**\n**         sqlite3SrcListAppend(D,A,B,0);\n**\n** Then B is a table name and the database name is unspecified.  If called\n** like this:\n**\n**         sqlite3SrcListAppend(D,A,B,C);\n**\n** Then C is the table name and B is the database name.  If C is defined\n** then so is B.  In other words, we never have a case where:\n**\n**         sqlite3SrcListAppend(D,A,0,C);\n**\n** Both pTable and pDatabase are assumed to be quoted.  They are dequoted\n** before being added to the SrcList.\n*/\nSQLITE_PRIVATE SrcList *sqlite3SrcListAppend(\n  sqlite3 *db,        /* Connection to notify of malloc failures */\n  SrcList *pList,     /* Append to this SrcList. NULL creates a new SrcList */\n  Token *pTable,      /* Table to append */\n  Token *pDatabase    /* Database of the table */\n){\n  struct SrcList_item *pItem;\n  assert( pDatabase==0 || pTable!=0 );  /* Cannot have C without B */\n  if( pList==0 ){\n    pList = sqlite3DbMallocZero(db, sizeof(SrcList) );\n    if( pList==0 ) return 0;\n    pList->nAlloc = 1;\n  }\n  pList = sqlite3SrcListEnlarge(db, pList, 1, pList->nSrc);\n  if( db->mallocFailed ){\n    sqlite3SrcListDelete(db, pList);\n    return 0;\n  }\n  pItem = &pList->a[pList->nSrc-1];\n  if( pDatabase && pDatabase->z==0 ){\n    pDatabase = 0;\n  }\n  if( pDatabase ){\n    Token *pTemp = pDatabase;\n    pDatabase = pTable;\n    pTable = pTemp;\n  }\n  pItem->zName = sqlite3NameFromToken(db, pTable);\n  pItem->zDatabase = sqlite3NameFromToken(db, pDatabase);\n  return pList;\n}\n\n/*\n** Assign VdbeCursor index numbers to all tables in a SrcList\n*/\nSQLITE_PRIVATE void sqlite3SrcListAssignCursors(Parse *pParse, SrcList *pList){\n  int i;\n  struct SrcList_item *pItem;\n  assert(pList || pParse->db->mallocFailed );\n  if( pList ){\n    for(i=0, pItem=pList->a; i<pList->nSrc; i++, pItem++){\n      if( pItem->iCursor>=0 ) break;\n      pItem->iCursor = pParse->nTab++;\n      if( pItem->pSelect ){\n        sqlite3SrcListAssignCursors(pParse, pItem->pSelect->pSrc);\n      }\n    }\n  }\n}\n\n/*\n** Delete an entire SrcList including all its substructure.\n*/\nSQLITE_PRIVATE void sqlite3SrcListDelete(sqlite3 *db, SrcList *pList){\n  int i;\n  struct SrcList_item *pItem;\n  if( pList==0 ) return;\n  for(pItem=pList->a, i=0; i<pList->nSrc; i++, pItem++){\n    sqlite3DbFree(db, pItem->zDatabase);\n    sqlite3DbFree(db, pItem->zName);\n    sqlite3DbFree(db, pItem->zAlias);\n    sqlite3DbFree(db, pItem->zIndex);\n    sqlite3DeleteTable(db, pItem->pTab);\n    sqlite3SelectDelete(db, pItem->pSelect);\n    sqlite3ExprDelete(db, pItem->pOn);\n    sqlite3IdListDelete(db, pItem->pUsing);\n  }\n  sqlite3DbFree(db, pList);\n}\n\n/*\n** This routine is called by the parser to add a new term to the\n** end of a growing FROM clause.  The \"p\" parameter is the part of\n** the FROM clause that has already been constructed.  \"p\" is NULL\n** if this is the first term of the FROM clause.  pTable and pDatabase\n** are the name of the table and database named in the FROM clause term.\n** pDatabase is NULL if the database name qualifier is missing - the\n** usual case.  If the term has a alias, then pAlias points to the\n** alias token.  If the term is a subquery, then pSubquery is the\n** SELECT statement that the subquery encodes.  The pTable and\n** pDatabase parameters are NULL for subqueries.  The pOn and pUsing\n** parameters are the content of the ON and USING clauses.\n**\n** Return a new SrcList which encodes is the FROM with the new\n** term added.\n*/\nSQLITE_PRIVATE SrcList *sqlite3SrcListAppendFromTerm(\n  Parse *pParse,          /* Parsing context */\n  SrcList *p,             /* The left part of the FROM clause already seen */\n  Token *pTable,          /* Name of the table to add to the FROM clause */\n  Token *pDatabase,       /* Name of the database containing pTable */\n  Token *pAlias,          /* The right-hand side of the AS subexpression */\n  Select *pSubquery,      /* A subquery used in place of a table name */\n  Expr *pOn,              /* The ON clause of a join */\n  IdList *pUsing          /* The USING clause of a join */\n){\n  struct SrcList_item *pItem;\n  sqlite3 *db = pParse->db;\n  if( !p && (pOn || pUsing) ){\n    sqlite3ErrorMsg(pParse, \"a JOIN clause is required before %s\", \n      (pOn ? \"ON\" : \"USING\")\n    );\n    goto append_from_error;\n  }\n  p = sqlite3SrcListAppend(db, p, pTable, pDatabase);\n  if( p==0 || NEVER(p->nSrc==0) ){\n    goto append_from_error;\n  }\n  pItem = &p->a[p->nSrc-1];\n  assert( pAlias!=0 );\n  if( pAlias->n ){\n    pItem->zAlias = sqlite3NameFromToken(db, pAlias);\n  }\n  pItem->pSelect = pSubquery;\n  pItem->pOn = pOn;\n  pItem->pUsing = pUsing;\n  return p;\n\n append_from_error:\n  assert( p==0 );\n  sqlite3ExprDelete(db, pOn);\n  sqlite3IdListDelete(db, pUsing);\n  sqlite3SelectDelete(db, pSubquery);\n  return 0;\n}\n\n/*\n** Add an INDEXED BY or NOT INDEXED clause to the most recently added \n** element of the source-list passed as the second argument.\n*/\nSQLITE_PRIVATE void sqlite3SrcListIndexedBy(Parse *pParse, SrcList *p, Token *pIndexedBy){\n  assert( pIndexedBy!=0 );\n  if( p && ALWAYS(p->nSrc>0) ){\n    struct SrcList_item *pItem = &p->a[p->nSrc-1];\n    assert( pItem->notIndexed==0 && pItem->zIndex==0 );\n    if( pIndexedBy->n==1 && !pIndexedBy->z ){\n      /* A \"NOT INDEXED\" clause was supplied. See parse.y \n      ** construct \"indexed_opt\" for details. */\n      pItem->notIndexed = 1;\n    }else{\n      pItem->zIndex = sqlite3NameFromToken(pParse->db, pIndexedBy);\n    }\n  }\n}\n\n/*\n** When building up a FROM clause in the parser, the join operator\n** is initially attached to the left operand.  But the code generator\n** expects the join operator to be on the right operand.  This routine\n** Shifts all join operators from left to right for an entire FROM\n** clause.\n**\n** Example: Suppose the join is like this:\n**\n**           A natural cross join B\n**\n** The operator is \"natural cross join\".  The A and B operands are stored\n** in p->a[0] and p->a[1], respectively.  The parser initially stores the\n** operator with A.  This routine shifts that operator over to B.\n*/\nSQLITE_PRIVATE void sqlite3SrcListShiftJoinType(SrcList *p){\n  if( p ){\n    int i;\n    for(i=p->nSrc-1; i>0; i--){\n      p->a[i].jointype = p->a[i-1].jointype;\n    }\n    p->a[0].jointype = 0;\n  }\n}\n\n/*\n** Begin a transaction\n*/\nSQLITE_PRIVATE void sqlite3BeginTransaction(Parse *pParse, int type){\n  sqlite3 *db;\n  Vdbe *v;\n  int i;\n\n  assert( pParse!=0 );\n  db = pParse->db;\n  assert( db!=0 );\n/*  if( db->aDb[0].pBt==0 ) return; */\n  if( sqlite3AuthCheck(pParse, SQLITE_TRANSACTION, \"BEGIN\", 0, 0) ){\n    return;\n  }\n  v = sqlite3GetVdbe(pParse);\n  if( !v ) return;\n  if( type!=TK_DEFERRED ){\n    for(i=0; i<db->nDb; i++){\n      sqlite3VdbeAddOp2(v, OP_Transaction, i, (type==TK_EXCLUSIVE)+1);\n      sqlite3VdbeUsesBtree(v, i);\n    }\n  }\n  sqlite3VdbeAddOp2(v, OP_AutoCommit, 0, 0);\n}\n\n/*\n** Commit a transaction\n*/\nSQLITE_PRIVATE void sqlite3CommitTransaction(Parse *pParse){\n  sqlite3 *db;\n  Vdbe *v;\n\n  assert( pParse!=0 );\n  db = pParse->db;\n  assert( db!=0 );\n/*  if( db->aDb[0].pBt==0 ) return; */\n  if( sqlite3AuthCheck(pParse, SQLITE_TRANSACTION, \"COMMIT\", 0, 0) ){\n    return;\n  }\n  v = sqlite3GetVdbe(pParse);\n  if( v ){\n    sqlite3VdbeAddOp2(v, OP_AutoCommit, 1, 0);\n  }\n}\n\n/*\n** Rollback a transaction\n*/\nSQLITE_PRIVATE void sqlite3RollbackTransaction(Parse *pParse){\n  sqlite3 *db;\n  Vdbe *v;\n\n  assert( pParse!=0 );\n  db = pParse->db;\n  assert( db!=0 );\n/*  if( db->aDb[0].pBt==0 ) return; */\n  if( sqlite3AuthCheck(pParse, SQLITE_TRANSACTION, \"ROLLBACK\", 0, 0) ){\n    return;\n  }\n  v = sqlite3GetVdbe(pParse);\n  if( v ){\n    sqlite3VdbeAddOp2(v, OP_AutoCommit, 1, 1);\n  }\n}\n\n/*\n** This function is called by the parser when it parses a command to create,\n** release or rollback an SQL savepoint. \n*/\nSQLITE_PRIVATE void sqlite3Savepoint(Parse *pParse, int op, Token *pName){\n  char *zName = sqlite3NameFromToken(pParse->db, pName);\n  if( zName ){\n    Vdbe *v = sqlite3GetVdbe(pParse);\n#ifndef SQLITE_OMIT_AUTHORIZATION\n    static const char * const az[] = { \"BEGIN\", \"RELEASE\", \"ROLLBACK\" };\n    assert( !SAVEPOINT_BEGIN && SAVEPOINT_RELEASE==1 && SAVEPOINT_ROLLBACK==2 );\n#endif\n    if( !v || sqlite3AuthCheck(pParse, SQLITE_SAVEPOINT, az[op], zName, 0) ){\n      sqlite3DbFree(pParse->db, zName);\n      return;\n    }\n    sqlite3VdbeAddOp4(v, OP_Savepoint, op, 0, 0, zName, P4_DYNAMIC);\n  }\n}\n\n/*\n** Make sure the TEMP database is open and available for use.  Return\n** the number of errors.  Leave any error messages in the pParse structure.\n*/\nSQLITE_PRIVATE int sqlite3OpenTempDatabase(Parse *pParse){\n  sqlite3 *db = pParse->db;\n  if( db->aDb[1].pBt==0 && !pParse->explain ){\n    int rc;\n    Btree *pBt;\n    static const int flags = \n          SQLITE_OPEN_READWRITE |\n          SQLITE_OPEN_CREATE |\n          SQLITE_OPEN_EXCLUSIVE |\n          SQLITE_OPEN_DELETEONCLOSE |\n          SQLITE_OPEN_TEMP_DB;\n\n    rc = sqlite3BtreeOpen(0, db, &pBt, 0, flags);\n    if( rc!=SQLITE_OK ){\n      sqlite3ErrorMsg(pParse, \"unable to open a temporary database \"\n        \"file for storing temporary tables\");\n      pParse->rc = rc;\n      return 1;\n    }\n    db->aDb[1].pBt = pBt;\n    assert( db->aDb[1].pSchema );\n    if( SQLITE_NOMEM==sqlite3BtreeSetPageSize(pBt, db->nextPagesize, -1, 0) ){\n      db->mallocFailed = 1;\n      return 1;\n    }\n  }\n  return 0;\n}\n\n/*\n** Generate VDBE code that will verify the schema cookie and start\n** a read-transaction for all named database files.\n**\n** It is important that all schema cookies be verified and all\n** read transactions be started before anything else happens in\n** the VDBE program.  But this routine can be called after much other\n** code has been generated.  So here is what we do:\n**\n** The first time this routine is called, we code an OP_Goto that\n** will jump to a subroutine at the end of the program.  Then we\n** record every database that needs its schema verified in the\n** pParse->cookieMask field.  Later, after all other code has been\n** generated, the subroutine that does the cookie verifications and\n** starts the transactions will be coded and the OP_Goto P2 value\n** will be made to point to that subroutine.  The generation of the\n** cookie verification subroutine code happens in sqlite3FinishCoding().\n**\n** If iDb<0 then code the OP_Goto only - don't set flag to verify the\n** schema on any databases.  This can be used to position the OP_Goto\n** early in the code, before we know if any database tables will be used.\n*/\nSQLITE_PRIVATE void sqlite3CodeVerifySchema(Parse *pParse, int iDb){\n  Parse *pToplevel = sqlite3ParseToplevel(pParse);\n\n  if( pToplevel->cookieGoto==0 ){\n    Vdbe *v = sqlite3GetVdbe(pToplevel);\n    if( v==0 ) return;  /* This only happens if there was a prior error */\n    pToplevel->cookieGoto = sqlite3VdbeAddOp2(v, OP_Goto, 0, 0)+1;\n  }\n  if( iDb>=0 ){\n    sqlite3 *db = pToplevel->db;\n    int mask;\n\n    assert( iDb<db->nDb );\n    assert( db->aDb[iDb].pBt!=0 || iDb==1 );\n    assert( iDb<SQLITE_MAX_ATTACHED+2 );\n    mask = 1<<iDb;\n    if( (pToplevel->cookieMask & mask)==0 ){\n      pToplevel->cookieMask |= mask;\n      pToplevel->cookieValue[iDb] = db->aDb[iDb].pSchema->schema_cookie;\n      if( !OMIT_TEMPDB && iDb==1 ){\n        sqlite3OpenTempDatabase(pToplevel);\n      }\n    }\n  }\n}\n\n/*\n** Generate VDBE code that prepares for doing an operation that\n** might change the database.\n**\n** This routine starts a new transaction if we are not already within\n** a transaction.  If we are already within a transaction, then a checkpoint\n** is set if the setStatement parameter is true.  A checkpoint should\n** be set for operations that might fail (due to a constraint) part of\n** the way through and which will need to undo some writes without having to\n** rollback the whole transaction.  For operations where all constraints\n** can be checked before any changes are made to the database, it is never\n** necessary to undo a write and the checkpoint should not be set.\n*/\nSQLITE_PRIVATE void sqlite3BeginWriteOperation(Parse *pParse, int setStatement, int iDb){\n  Parse *pToplevel = sqlite3ParseToplevel(pParse);\n  sqlite3CodeVerifySchema(pParse, iDb);\n  pToplevel->writeMask |= 1<<iDb;\n  pToplevel->isMultiWrite |= setStatement;\n}\n\n/*\n** Indicate that the statement currently under construction might write\n** more than one entry (example: deleting one row then inserting another,\n** inserting multiple rows in a table, or inserting a row and index entries.)\n** If an abort occurs after some of these writes have completed, then it will\n** be necessary to undo the completed writes.\n*/\nSQLITE_PRIVATE void sqlite3MultiWrite(Parse *pParse){\n  Parse *pToplevel = sqlite3ParseToplevel(pParse);\n  pToplevel->isMultiWrite = 1;\n}\n\n/* \n** The code generator calls this routine if is discovers that it is\n** possible to abort a statement prior to completion.  In order to \n** perform this abort without corrupting the database, we need to make\n** sure that the statement is protected by a statement transaction.\n**\n** Technically, we only need to set the mayAbort flag if the\n** isMultiWrite flag was previously set.  There is a time dependency\n** such that the abort must occur after the multiwrite.  This makes\n** some statements involving the REPLACE conflict resolution algorithm\n** go a little faster.  But taking advantage of this time dependency\n** makes it more difficult to prove that the code is correct (in \n** particular, it prevents us from writing an effective\n** implementation of sqlite3AssertMayAbort()) and so we have chosen\n** to take the safe route and skip the optimization.\n*/\nSQLITE_PRIVATE void sqlite3MayAbort(Parse *pParse){\n  Parse *pToplevel = sqlite3ParseToplevel(pParse);\n  pToplevel->mayAbort = 1;\n}\n\n/*\n** Code an OP_Halt that causes the vdbe to return an SQLITE_CONSTRAINT\n** error. The onError parameter determines which (if any) of the statement\n** and/or current transaction is rolled back.\n*/\nSQLITE_PRIVATE void sqlite3HaltConstraint(Parse *pParse, int onError, char *p4, int p4type){\n  Vdbe *v = sqlite3GetVdbe(pParse);\n  if( onError==OE_Abort ){\n    sqlite3MayAbort(pParse);\n  }\n  sqlite3VdbeAddOp4(v, OP_Halt, SQLITE_CONSTRAINT, onError, 0, p4, p4type);\n}\n\n/*\n** Check to see if pIndex uses the collating sequence pColl.  Return\n** true if it does and false if it does not.\n*/\n#ifndef SQLITE_OMIT_REINDEX\nstatic int collationMatch(const char *zColl, Index *pIndex){\n  int i;\n  assert( zColl!=0 );\n  for(i=0; i<pIndex->nColumn; i++){\n    const char *z = pIndex->azColl[i];\n    assert( z!=0 );\n    if( 0==sqlite3StrICmp(z, zColl) ){\n      return 1;\n    }\n  }\n  return 0;\n}\n#endif\n\n/*\n** Recompute all indices of pTab that use the collating sequence pColl.\n** If pColl==0 then recompute all indices of pTab.\n*/\n#ifndef SQLITE_OMIT_REINDEX\nstatic void reindexTable(Parse *pParse, Table *pTab, char const *zColl){\n  Index *pIndex;              /* An index associated with pTab */\n\n  for(pIndex=pTab->pIndex; pIndex; pIndex=pIndex->pNext){\n    if( zColl==0 || collationMatch(zColl, pIndex) ){\n      int iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);\n      sqlite3BeginWriteOperation(pParse, 0, iDb);\n      sqlite3RefillIndex(pParse, pIndex, -1);\n    }\n  }\n}\n#endif\n\n/*\n** Recompute all indices of all tables in all databases where the\n** indices use the collating sequence pColl.  If pColl==0 then recompute\n** all indices everywhere.\n*/\n#ifndef SQLITE_OMIT_REINDEX\nstatic void reindexDatabases(Parse *pParse, char const *zColl){\n  Db *pDb;                    /* A single database */\n  int iDb;                    /* The database index number */\n  sqlite3 *db = pParse->db;   /* The database connection */\n  HashElem *k;                /* For looping over tables in pDb */\n  Table *pTab;                /* A table in the database */\n\n  for(iDb=0, pDb=db->aDb; iDb<db->nDb; iDb++, pDb++){\n    assert( pDb!=0 );\n    for(k=sqliteHashFirst(&pDb->pSchema->tblHash);  k; k=sqliteHashNext(k)){\n      pTab = (Table*)sqliteHashData(k);\n      reindexTable(pParse, pTab, zColl);\n    }\n  }\n}\n#endif\n\n/*\n** Generate code for the REINDEX command.\n**\n**        REINDEX                            -- 1\n**        REINDEX  <collation>               -- 2\n**        REINDEX  ?<database>.?<tablename>  -- 3\n**        REINDEX  ?<database>.?<indexname>  -- 4\n**\n** Form 1 causes all indices in all attached databases to be rebuilt.\n** Form 2 rebuilds all indices in all databases that use the named\n** collating function.  Forms 3 and 4 rebuild the named index or all\n** indices associated with the named table.\n*/\n#ifndef SQLITE_OMIT_REINDEX\nSQLITE_PRIVATE void sqlite3Reindex(Parse *pParse, Token *pName1, Token *pName2){\n  CollSeq *pColl;             /* Collating sequence to be reindexed, or NULL */\n  char *z;                    /* Name of a table or index */\n  const char *zDb;            /* Name of the database */\n  Table *pTab;                /* A table in the database */\n  Index *pIndex;              /* An index associated with pTab */\n  int iDb;                    /* The database index number */\n  sqlite3 *db = pParse->db;   /* The database connection */\n  Token *pObjName;            /* Name of the table or index to be reindexed */\n\n  /* Read the database schema. If an error occurs, leave an error message\n  ** and code in pParse and return NULL. */\n  if( SQLITE_OK!=sqlite3ReadSchema(pParse) ){\n    return;\n  }\n\n  if( pName1==0 ){\n    reindexDatabases(pParse, 0);\n    return;\n  }else if( NEVER(pName2==0) || pName2->z==0 ){\n    char *zColl;\n    assert( pName1->z );\n    zColl = sqlite3NameFromToken(pParse->db, pName1);\n    if( !zColl ) return;\n    pColl = sqlite3FindCollSeq(db, ENC(db), zColl, 0);\n    if( pColl ){\n      reindexDatabases(pParse, zColl);\n      sqlite3DbFree(db, zColl);\n      return;\n    }\n    sqlite3DbFree(db, zColl);\n  }\n  iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pObjName);\n  if( iDb<0 ) return;\n  z = sqlite3NameFromToken(db, pObjName);\n  if( z==0 ) return;\n  zDb = db->aDb[iDb].zName;\n  pTab = sqlite3FindTable(db, z, zDb);\n  if( pTab ){\n    reindexTable(pParse, pTab, 0);\n    sqlite3DbFree(db, z);\n    return;\n  }\n  pIndex = sqlite3FindIndex(db, z, zDb);\n  sqlite3DbFree(db, z);\n  if( pIndex ){\n    sqlite3BeginWriteOperation(pParse, 0, iDb);\n    sqlite3RefillIndex(pParse, pIndex, -1);\n    return;\n  }\n  sqlite3ErrorMsg(pParse, \"unable to identify the object to be reindexed\");\n}\n#endif\n\n/*\n** Return a dynamicly allocated KeyInfo structure that can be used\n** with OP_OpenRead or OP_OpenWrite to access database index pIdx.\n**\n** If successful, a pointer to the new structure is returned. In this case\n** the caller is responsible for calling sqlite3DbFree(db, ) on the returned \n** pointer. If an error occurs (out of memory or missing collation \n** sequence), NULL is returned and the state of pParse updated to reflect\n** the error.\n*/\nSQLITE_PRIVATE KeyInfo *sqlite3IndexKeyinfo(Parse *pParse, Index *pIdx){\n  int i;\n  int nCol = pIdx->nColumn;\n  int nBytes = sizeof(KeyInfo) + (nCol-1)*sizeof(CollSeq*) + nCol;\n  sqlite3 *db = pParse->db;\n  KeyInfo *pKey = (KeyInfo *)sqlite3DbMallocZero(db, nBytes);\n\n  if( pKey ){\n    pKey->db = pParse->db;\n    pKey->aSortOrder = (u8 *)&(pKey->aColl[nCol]);\n    assert( &pKey->aSortOrder[nCol]==&(((u8 *)pKey)[nBytes]) );\n    for(i=0; i<nCol; i++){\n      char *zColl = pIdx->azColl[i];\n      assert( zColl );\n      pKey->aColl[i] = sqlite3LocateCollSeq(pParse, zColl);\n      pKey->aSortOrder[i] = pIdx->aSortOrder[i];\n    }\n    pKey->nField = (u16)nCol;\n  }\n\n  if( pParse->nErr ){\n    sqlite3DbFree(db, pKey);\n    pKey = 0;\n  }\n  return pKey;\n}\n\n/************** End of build.c ***********************************************/\n/************** Begin file callback.c ****************************************/\n/*\n** 2005 May 23 \n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n**\n** This file contains functions used to access the internal hash tables\n** of user defined functions and collation sequences.\n*/\n\n\n/*\n** Invoke the 'collation needed' callback to request a collation sequence\n** in the encoding enc of name zName, length nName.\n*/\nstatic void callCollNeeded(sqlite3 *db, int enc, const char *zName){\n  assert( !db->xCollNeeded || !db->xCollNeeded16 );\n  if( db->xCollNeeded ){\n    char *zExternal = sqlite3DbStrDup(db, zName);\n    if( !zExternal ) return;\n    db->xCollNeeded(db->pCollNeededArg, db, enc, zExternal);\n    sqlite3DbFree(db, zExternal);\n  }\n#ifndef SQLITE_OMIT_UTF16\n  if( db->xCollNeeded16 ){\n    char const *zExternal;\n    sqlite3_value *pTmp = sqlite3ValueNew(db);\n    sqlite3ValueSetStr(pTmp, -1, zName, SQLITE_UTF8, SQLITE_STATIC);\n    zExternal = sqlite3ValueText(pTmp, SQLITE_UTF16NATIVE);\n    if( zExternal ){\n      db->xCollNeeded16(db->pCollNeededArg, db, (int)ENC(db), zExternal);\n    }\n    sqlite3ValueFree(pTmp);\n  }\n#endif\n}\n\n/*\n** This routine is called if the collation factory fails to deliver a\n** collation function in the best encoding but there may be other versions\n** of this collation function (for other text encodings) available. Use one\n** of these instead if they exist. Avoid a UTF-8 <-> UTF-16 conversion if\n** possible.\n*/\nstatic int synthCollSeq(sqlite3 *db, CollSeq *pColl){\n  CollSeq *pColl2;\n  char *z = pColl->zName;\n  int i;\n  static const u8 aEnc[] = { SQLITE_UTF16BE, SQLITE_UTF16LE, SQLITE_UTF8 };\n  for(i=0; i<3; i++){\n    pColl2 = sqlite3FindCollSeq(db, aEnc[i], z, 0);\n    if( pColl2->xCmp!=0 ){\n      memcpy(pColl, pColl2, sizeof(CollSeq));\n      pColl->xDel = 0;         /* Do not copy the destructor */\n      return SQLITE_OK;\n    }\n  }\n  return SQLITE_ERROR;\n}\n\n/*\n** This function is responsible for invoking the collation factory callback\n** or substituting a collation sequence of a different encoding when the\n** requested collation sequence is not available in the desired encoding.\n** \n** If it is not NULL, then pColl must point to the database native encoding \n** collation sequence with name zName, length nName.\n**\n** The return value is either the collation sequence to be used in database\n** db for collation type name zName, length nName, or NULL, if no collation\n** sequence can be found.\n**\n** See also: sqlite3LocateCollSeq(), sqlite3FindCollSeq()\n*/\nSQLITE_PRIVATE CollSeq *sqlite3GetCollSeq(\n  sqlite3* db,          /* The database connection */\n  u8 enc,               /* The desired encoding for the collating sequence */\n  CollSeq *pColl,       /* Collating sequence with native encoding, or NULL */\n  const char *zName     /* Collating sequence name */\n){\n  CollSeq *p;\n\n  p = pColl;\n  if( !p ){\n    p = sqlite3FindCollSeq(db, enc, zName, 0);\n  }\n  if( !p || !p->xCmp ){\n    /* No collation sequence of this type for this encoding is registered.\n    ** Call the collation factory to see if it can supply us with one.\n    */\n    callCollNeeded(db, enc, zName);\n    p = sqlite3FindCollSeq(db, enc, zName, 0);\n  }\n  if( p && !p->xCmp && synthCollSeq(db, p) ){\n    p = 0;\n  }\n  assert( !p || p->xCmp );\n  return p;\n}\n\n/*\n** This routine is called on a collation sequence before it is used to\n** check that it is defined. An undefined collation sequence exists when\n** a database is loaded that contains references to collation sequences\n** that have not been defined by sqlite3_create_collation() etc.\n**\n** If required, this routine calls the 'collation needed' callback to\n** request a definition of the collating sequence. If this doesn't work, \n** an equivalent collating sequence that uses a text encoding different\n** from the main database is substituted, if one is available.\n*/\nSQLITE_PRIVATE int sqlite3CheckCollSeq(Parse *pParse, CollSeq *pColl){\n  if( pColl ){\n    const char *zName = pColl->zName;\n    sqlite3 *db = pParse->db;\n    CollSeq *p = sqlite3GetCollSeq(db, ENC(db), pColl, zName);\n    if( !p ){\n      sqlite3ErrorMsg(pParse, \"no such collation sequence: %s\", zName);\n      pParse->nErr++;\n      return SQLITE_ERROR;\n    }\n    assert( p==pColl );\n  }\n  return SQLITE_OK;\n}\n\n\n\n/*\n** Locate and return an entry from the db.aCollSeq hash table. If the entry\n** specified by zName and nName is not found and parameter 'create' is\n** true, then create a new entry. Otherwise return NULL.\n**\n** Each pointer stored in the sqlite3.aCollSeq hash table contains an\n** array of three CollSeq structures. The first is the collation sequence\n** prefferred for UTF-8, the second UTF-16le, and the third UTF-16be.\n**\n** Stored immediately after the three collation sequences is a copy of\n** the collation sequence name. A pointer to this string is stored in\n** each collation sequence structure.\n*/\nstatic CollSeq *findCollSeqEntry(\n  sqlite3 *db,          /* Database connection */\n  const char *zName,    /* Name of the collating sequence */\n  int create            /* Create a new entry if true */\n){\n  CollSeq *pColl;\n  int nName = sqlite3Strlen30(zName);\n  pColl = sqlite3HashFind(&db->aCollSeq, zName, nName);\n\n  if( 0==pColl && create ){\n    pColl = sqlite3DbMallocZero(db, 3*sizeof(*pColl) + nName + 1 );\n    if( pColl ){\n      CollSeq *pDel = 0;\n      pColl[0].zName = (char*)&pColl[3];\n      pColl[0].enc = SQLITE_UTF8;\n      pColl[1].zName = (char*)&pColl[3];\n      pColl[1].enc = SQLITE_UTF16LE;\n      pColl[2].zName = (char*)&pColl[3];\n      pColl[2].enc = SQLITE_UTF16BE;\n      memcpy(pColl[0].zName, zName, nName);\n      pColl[0].zName[nName] = 0;\n      pDel = sqlite3HashInsert(&db->aCollSeq, pColl[0].zName, nName, pColl);\n\n      /* If a malloc() failure occurred in sqlite3HashInsert(), it will \n      ** return the pColl pointer to be deleted (because it wasn't added\n      ** to the hash table).\n      */\n      assert( pDel==0 || pDel==pColl );\n      if( pDel!=0 ){\n        db->mallocFailed = 1;\n        sqlite3DbFree(db, pDel);\n        pColl = 0;\n      }\n    }\n  }\n  return pColl;\n}\n\n/*\n** Parameter zName points to a UTF-8 encoded string nName bytes long.\n** Return the CollSeq* pointer for the collation sequence named zName\n** for the encoding 'enc' from the database 'db'.\n**\n** If the entry specified is not found and 'create' is true, then create a\n** new entry.  Otherwise return NULL.\n**\n** A separate function sqlite3LocateCollSeq() is a wrapper around\n** this routine.  sqlite3LocateCollSeq() invokes the collation factory\n** if necessary and generates an error message if the collating sequence\n** cannot be found.\n**\n** See also: sqlite3LocateCollSeq(), sqlite3GetCollSeq()\n*/\nSQLITE_PRIVATE CollSeq *sqlite3FindCollSeq(\n  sqlite3 *db,\n  u8 enc,\n  const char *zName,\n  int create\n){\n  CollSeq *pColl;\n  if( zName ){\n    pColl = findCollSeqEntry(db, zName, create);\n  }else{\n    pColl = db->pDfltColl;\n  }\n  assert( SQLITE_UTF8==1 && SQLITE_UTF16LE==2 && SQLITE_UTF16BE==3 );\n  assert( enc>=SQLITE_UTF8 && enc<=SQLITE_UTF16BE );\n  if( pColl ) pColl += enc-1;\n  return pColl;\n}\n\n/* During the search for the best function definition, this procedure\n** is called to test how well the function passed as the first argument\n** matches the request for a function with nArg arguments in a system\n** that uses encoding enc. The value returned indicates how well the\n** request is matched. A higher value indicates a better match.\n**\n** The returned value is always between 0 and 6, as follows:\n**\n** 0: Not a match, or if nArg<0 and the function is has no implementation.\n** 1: A variable arguments function that prefers UTF-8 when a UTF-16\n**    encoding is requested, or vice versa.\n** 2: A variable arguments function that uses UTF-16BE when UTF-16LE is\n**    requested, or vice versa.\n** 3: A variable arguments function using the same text encoding.\n** 4: A function with the exact number of arguments requested that\n**    prefers UTF-8 when a UTF-16 encoding is requested, or vice versa.\n** 5: A function with the exact number of arguments requested that\n**    prefers UTF-16LE when UTF-16BE is requested, or vice versa.\n** 6: An exact match.\n**\n*/\nstatic int matchQuality(FuncDef *p, int nArg, u8 enc){\n  int match = 0;\n  if( p->nArg==-1 || p->nArg==nArg \n   || (nArg==-1 && (p->xFunc!=0 || p->xStep!=0))\n  ){\n    match = 1;\n    if( p->nArg==nArg || nArg==-1 ){\n      match = 4;\n    }\n    if( enc==p->iPrefEnc ){\n      match += 2;\n    }\n    else if( (enc==SQLITE_UTF16LE && p->iPrefEnc==SQLITE_UTF16BE) ||\n             (enc==SQLITE_UTF16BE && p->iPrefEnc==SQLITE_UTF16LE) ){\n      match += 1;\n    }\n  }\n  return match;\n}\n\n/*\n** Search a FuncDefHash for a function with the given name.  Return\n** a pointer to the matching FuncDef if found, or 0 if there is no match.\n*/\nstatic FuncDef *functionSearch(\n  FuncDefHash *pHash,  /* Hash table to search */\n  int h,               /* Hash of the name */\n  const char *zFunc,   /* Name of function */\n  int nFunc            /* Number of bytes in zFunc */\n){\n  FuncDef *p;\n  for(p=pHash->a[h]; p; p=p->pHash){\n    if( sqlite3StrNICmp(p->zName, zFunc, nFunc)==0 && p->zName[nFunc]==0 ){\n      return p;\n    }\n  }\n  return 0;\n}\n\n/*\n** Insert a new FuncDef into a FuncDefHash hash table.\n*/\nSQLITE_PRIVATE void sqlite3FuncDefInsert(\n  FuncDefHash *pHash,  /* The hash table into which to insert */\n  FuncDef *pDef        /* The function definition to insert */\n){\n  FuncDef *pOther;\n  int nName = sqlite3Strlen30(pDef->zName);\n  u8 c1 = (u8)pDef->zName[0];\n  int h = (sqlite3UpperToLower[c1] + nName) % ArraySize(pHash->a);\n  pOther = functionSearch(pHash, h, pDef->zName, nName);\n  if( pOther ){\n    assert( pOther!=pDef && pOther->pNext!=pDef );\n    pDef->pNext = pOther->pNext;\n    pOther->pNext = pDef;\n  }else{\n    pDef->pNext = 0;\n    pDef->pHash = pHash->a[h];\n    pHash->a[h] = pDef;\n  }\n}\n  \n  \n\n/*\n** Locate a user function given a name, a number of arguments and a flag\n** indicating whether the function prefers UTF-16 over UTF-8.  Return a\n** pointer to the FuncDef structure that defines that function, or return\n** NULL if the function does not exist.\n**\n** If the createFlag argument is true, then a new (blank) FuncDef\n** structure is created and liked into the \"db\" structure if a\n** no matching function previously existed.  When createFlag is true\n** and the nArg parameter is -1, then only a function that accepts\n** any number of arguments will be returned.\n**\n** If createFlag is false and nArg is -1, then the first valid\n** function found is returned.  A function is valid if either xFunc\n** or xStep is non-zero.\n**\n** If createFlag is false, then a function with the required name and\n** number of arguments may be returned even if the eTextRep flag does not\n** match that requested.\n*/\nSQLITE_PRIVATE FuncDef *sqlite3FindFunction(\n  sqlite3 *db,       /* An open database */\n  const char *zName, /* Name of the function.  Not null-terminated */\n  int nName,         /* Number of characters in the name */\n  int nArg,          /* Number of arguments.  -1 means any number */\n  u8 enc,            /* Preferred text encoding */\n  int createFlag     /* Create new entry if true and does not otherwise exist */\n){\n  FuncDef *p;         /* Iterator variable */\n  FuncDef *pBest = 0; /* Best match found so far */\n  int bestScore = 0;  /* Score of best match */\n  int h;              /* Hash value */\n\n\n  assert( enc==SQLITE_UTF8 || enc==SQLITE_UTF16LE || enc==SQLITE_UTF16BE );\n  h = (sqlite3UpperToLower[(u8)zName[0]] + nName) % ArraySize(db->aFunc.a);\n\n  /* First search for a match amongst the application-defined functions.\n  */\n  p = functionSearch(&db->aFunc, h, zName, nName);\n  while( p ){\n    int score = matchQuality(p, nArg, enc);\n    if( score>bestScore ){\n      pBest = p;\n      bestScore = score;\n    }\n    p = p->pNext;\n  }\n\n  /* If no match is found, search the built-in functions.\n  **\n  ** If the SQLITE_PreferBuiltin flag is set, then search the built-in\n  ** functions even if a prior app-defined function was found.  And give\n  ** priority to built-in functions.\n  **\n  ** Except, if createFlag is true, that means that we are trying to\n  ** install a new function.  Whatever FuncDef structure is returned it will\n  ** have fields overwritten with new information appropriate for the\n  ** new function.  But the FuncDefs for built-in functions are read-only.\n  ** So we must not search for built-ins when creating a new function.\n  */ \n  if( !createFlag && (pBest==0 || (db->flags & SQLITE_PreferBuiltin)!=0) ){\n    FuncDefHash *pHash = &GLOBAL(FuncDefHash, sqlite3GlobalFunctions);\n    bestScore = 0;\n    p = functionSearch(pHash, h, zName, nName);\n    while( p ){\n      int score = matchQuality(p, nArg, enc);\n      if( score>bestScore ){\n        pBest = p;\n        bestScore = score;\n      }\n      p = p->pNext;\n    }\n  }\n\n  /* If the createFlag parameter is true and the search did not reveal an\n  ** exact match for the name, number of arguments and encoding, then add a\n  ** new entry to the hash table and return it.\n  */\n  if( createFlag && (bestScore<6 || pBest->nArg!=nArg) && \n      (pBest = sqlite3DbMallocZero(db, sizeof(*pBest)+nName+1))!=0 ){\n    pBest->zName = (char *)&pBest[1];\n    pBest->nArg = (u16)nArg;\n    pBest->iPrefEnc = enc;\n    memcpy(pBest->zName, zName, nName);\n    pBest->zName[nName] = 0;\n    sqlite3FuncDefInsert(&db->aFunc, pBest);\n  }\n\n  if( pBest && (pBest->xStep || pBest->xFunc || createFlag) ){\n    return pBest;\n  }\n  return 0;\n}\n\n/*\n** Free all resources held by the schema structure. The void* argument points\n** at a Schema struct. This function does not call sqlite3DbFree(db, ) on the \n** pointer itself, it just cleans up subsiduary resources (i.e. the contents\n** of the schema hash tables).\n**\n** The Schema.cache_size variable is not cleared.\n*/\nSQLITE_PRIVATE void sqlite3SchemaFree(void *p){\n  Hash temp1;\n  Hash temp2;\n  HashElem *pElem;\n  Schema *pSchema = (Schema *)p;\n\n  temp1 = pSchema->tblHash;\n  temp2 = pSchema->trigHash;\n  sqlite3HashInit(&pSchema->trigHash);\n  sqlite3HashClear(&pSchema->idxHash);\n  for(pElem=sqliteHashFirst(&temp2); pElem; pElem=sqliteHashNext(pElem)){\n    sqlite3DeleteTrigger(0, (Trigger*)sqliteHashData(pElem));\n  }\n  sqlite3HashClear(&temp2);\n  sqlite3HashInit(&pSchema->tblHash);\n  for(pElem=sqliteHashFirst(&temp1); pElem; pElem=sqliteHashNext(pElem)){\n    Table *pTab = sqliteHashData(pElem);\n    sqlite3DeleteTable(0, pTab);\n  }\n  sqlite3HashClear(&temp1);\n  sqlite3HashClear(&pSchema->fkeyHash);\n  pSchema->pSeqTab = 0;\n  pSchema->flags &= ~DB_SchemaLoaded;\n}\n\n/*\n** Find and return the schema associated with a BTree.  Create\n** a new one if necessary.\n*/\nSQLITE_PRIVATE Schema *sqlite3SchemaGet(sqlite3 *db, Btree *pBt){\n  Schema * p;\n  if( pBt ){\n    p = (Schema *)sqlite3BtreeSchema(pBt, sizeof(Schema), sqlite3SchemaFree);\n  }else{\n    p = (Schema *)sqlite3DbMallocZero(0, sizeof(Schema));\n  }\n  if( !p ){\n    db->mallocFailed = 1;\n  }else if ( 0==p->file_format ){\n    sqlite3HashInit(&p->tblHash);\n    sqlite3HashInit(&p->idxHash);\n    sqlite3HashInit(&p->trigHash);\n    sqlite3HashInit(&p->fkeyHash);\n    p->enc = SQLITE_UTF8;\n  }\n  return p;\n}\n\n/************** End of callback.c ********************************************/\n/************** Begin file delete.c ******************************************/\n/*\n** 2001 September 15\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains C code routines that are called by the parser\n** in order to generate code for DELETE FROM statements.\n*/\n\n/*\n** Look up every table that is named in pSrc.  If any table is not found,\n** add an error message to pParse->zErrMsg and return NULL.  If all tables\n** are found, return a pointer to the last table.\n*/\nSQLITE_PRIVATE Table *sqlite3SrcListLookup(Parse *pParse, SrcList *pSrc){\n  struct SrcList_item *pItem = pSrc->a;\n  Table *pTab;\n  assert( pItem && pSrc->nSrc==1 );\n  pTab = sqlite3LocateTable(pParse, 0, pItem->zName, pItem->zDatabase);\n  sqlite3DeleteTable(pParse->db, pItem->pTab);\n  pItem->pTab = pTab;\n  if( pTab ){\n    pTab->nRef++;\n  }\n  if( sqlite3IndexedByLookup(pParse, pItem) ){\n    pTab = 0;\n  }\n  return pTab;\n}\n\n/*\n** Check to make sure the given table is writable.  If it is not\n** writable, generate an error message and return 1.  If it is\n** writable return 0;\n*/\nSQLITE_PRIVATE int sqlite3IsReadOnly(Parse *pParse, Table *pTab, int viewOk){\n  /* A table is not writable under the following circumstances:\n  **\n  **   1) It is a virtual table and no implementation of the xUpdate method\n  **      has been provided, or\n  **   2) It is a system table (i.e. sqlite_master), this call is not\n  **      part of a nested parse and writable_schema pragma has not \n  **      been specified.\n  **\n  ** In either case leave an error message in pParse and return non-zero.\n  */\n  if( ( IsVirtual(pTab) \n     && sqlite3GetVTable(pParse->db, pTab)->pMod->pModule->xUpdate==0 )\n   || ( (pTab->tabFlags & TF_Readonly)!=0\n     && (pParse->db->flags & SQLITE_WriteSchema)==0\n     && pParse->nested==0 )\n  ){\n    sqlite3ErrorMsg(pParse, \"table %s may not be modified\", pTab->zName);\n    return 1;\n  }\n\n#ifndef SQLITE_OMIT_VIEW\n  if( !viewOk && pTab->pSelect ){\n    sqlite3ErrorMsg(pParse,\"cannot modify %s because it is a view\",pTab->zName);\n    return 1;\n  }\n#endif\n  return 0;\n}\n\n\n#if !defined(SQLITE_OMIT_VIEW) && !defined(SQLITE_OMIT_TRIGGER)\n/*\n** Evaluate a view and store its result in an ephemeral table.  The\n** pWhere argument is an optional WHERE clause that restricts the\n** set of rows in the view that are to be added to the ephemeral table.\n*/\nSQLITE_PRIVATE void sqlite3MaterializeView(\n  Parse *pParse,       /* Parsing context */\n  Table *pView,        /* View definition */\n  Expr *pWhere,        /* Optional WHERE clause to be added */\n  int iCur             /* Cursor number for ephemerial table */\n){\n  SelectDest dest;\n  Select *pDup;\n  sqlite3 *db = pParse->db;\n\n  pDup = sqlite3SelectDup(db, pView->pSelect, 0);\n  if( pWhere ){\n    SrcList *pFrom;\n    \n    pWhere = sqlite3ExprDup(db, pWhere, 0);\n    pFrom = sqlite3SrcListAppend(db, 0, 0, 0);\n    if( pFrom ){\n      assert( pFrom->nSrc==1 );\n      pFrom->a[0].zAlias = sqlite3DbStrDup(db, pView->zName);\n      pFrom->a[0].pSelect = pDup;\n      assert( pFrom->a[0].pOn==0 );\n      assert( pFrom->a[0].pUsing==0 );\n    }else{\n      sqlite3SelectDelete(db, pDup);\n    }\n    pDup = sqlite3SelectNew(pParse, 0, pFrom, pWhere, 0, 0, 0, 0, 0, 0);\n  }\n  sqlite3SelectDestInit(&dest, SRT_EphemTab, iCur);\n  sqlite3Select(pParse, pDup, &dest);\n  sqlite3SelectDelete(db, pDup);\n}\n#endif /* !defined(SQLITE_OMIT_VIEW) && !defined(SQLITE_OMIT_TRIGGER) */\n\n#if defined(SQLITE_ENABLE_UPDATE_DELETE_LIMIT) && !defined(SQLITE_OMIT_SUBQUERY)\n/*\n** Generate an expression tree to implement the WHERE, ORDER BY,\n** and LIMIT/OFFSET portion of DELETE and UPDATE statements.\n**\n**     DELETE FROM table_wxyz WHERE a<5 ORDER BY a LIMIT 1;\n**                            \\__________________________/\n**                               pLimitWhere (pInClause)\n*/\nSQLITE_PRIVATE Expr *sqlite3LimitWhere(\n  Parse *pParse,               /* The parser context */\n  SrcList *pSrc,               /* the FROM clause -- which tables to scan */\n  Expr *pWhere,                /* The WHERE clause.  May be null */\n  ExprList *pOrderBy,          /* The ORDER BY clause.  May be null */\n  Expr *pLimit,                /* The LIMIT clause.  May be null */\n  Expr *pOffset,               /* The OFFSET clause.  May be null */\n  char *zStmtType              /* Either DELETE or UPDATE.  For error messages. */\n){\n  Expr *pWhereRowid = NULL;    /* WHERE rowid .. */\n  Expr *pInClause = NULL;      /* WHERE rowid IN ( select ) */\n  Expr *pSelectRowid = NULL;   /* SELECT rowid ... */\n  ExprList *pEList = NULL;     /* Expression list contaning only pSelectRowid */\n  SrcList *pSelectSrc = NULL;  /* SELECT rowid FROM x ... (dup of pSrc) */\n  Select *pSelect = NULL;      /* Complete SELECT tree */\n\n  /* Check that there isn't an ORDER BY without a LIMIT clause.\n  */\n  if( pOrderBy && (pLimit == 0) ) {\n    sqlite3ErrorMsg(pParse, \"ORDER BY without LIMIT on %s\", zStmtType);\n    pParse->parseError = 1;\n    goto limit_where_cleanup_2;\n  }\n\n  /* We only need to generate a select expression if there\n  ** is a limit/offset term to enforce.\n  */\n  if( pLimit == 0 ) {\n    /* if pLimit is null, pOffset will always be null as well. */\n    assert( pOffset == 0 );\n    return pWhere;\n  }\n\n  /* Generate a select expression tree to enforce the limit/offset \n  ** term for the DELETE or UPDATE statement.  For example:\n  **   DELETE FROM table_a WHERE col1=1 ORDER BY col2 LIMIT 1 OFFSET 1\n  ** becomes:\n  **   DELETE FROM table_a WHERE rowid IN ( \n  **     SELECT rowid FROM table_a WHERE col1=1 ORDER BY col2 LIMIT 1 OFFSET 1\n  **   );\n  */\n\n  pSelectRowid = sqlite3PExpr(pParse, TK_ROW, 0, 0, 0);\n  if( pSelectRowid == 0 ) goto limit_where_cleanup_2;\n  pEList = sqlite3ExprListAppend(pParse, 0, pSelectRowid);\n  if( pEList == 0 ) goto limit_where_cleanup_2;\n\n  /* duplicate the FROM clause as it is needed by both the DELETE/UPDATE tree\n  ** and the SELECT subtree. */\n  pSelectSrc = sqlite3SrcListDup(pParse->db, pSrc, 0);\n  if( pSelectSrc == 0 ) {\n    sqlite3ExprListDelete(pParse->db, pEList);\n    goto limit_where_cleanup_2;\n  }\n\n  /* generate the SELECT expression tree. */\n  pSelect = sqlite3SelectNew(pParse,pEList,pSelectSrc,pWhere,0,0,\n                             pOrderBy,0,pLimit,pOffset);\n  if( pSelect == 0 ) return 0;\n\n  /* now generate the new WHERE rowid IN clause for the DELETE/UDPATE */\n  pWhereRowid = sqlite3PExpr(pParse, TK_ROW, 0, 0, 0);\n  if( pWhereRowid == 0 ) goto limit_where_cleanup_1;\n  pInClause = sqlite3PExpr(pParse, TK_IN, pWhereRowid, 0, 0);\n  if( pInClause == 0 ) goto limit_where_cleanup_1;\n\n  pInClause->x.pSelect = pSelect;\n  pInClause->flags |= EP_xIsSelect;\n  sqlite3ExprSetHeight(pParse, pInClause);\n  return pInClause;\n\n  /* something went wrong. clean up anything allocated. */\nlimit_where_cleanup_1:\n  sqlite3SelectDelete(pParse->db, pSelect);\n  return 0;\n\nlimit_where_cleanup_2:\n  sqlite3ExprDelete(pParse->db, pWhere);\n  sqlite3ExprListDelete(pParse->db, pOrderBy);\n  sqlite3ExprDelete(pParse->db, pLimit);\n  sqlite3ExprDelete(pParse->db, pOffset);\n  return 0;\n}\n#endif /* defined(SQLITE_ENABLE_UPDATE_DELETE_LIMIT) && !defined(SQLITE_OMIT_SUBQUERY) */\n\n/*\n** Generate code for a DELETE FROM statement.\n**\n**     DELETE FROM table_wxyz WHERE a<5 AND b NOT NULL;\n**                 \\________/       \\________________/\n**                  pTabList              pWhere\n*/\nSQLITE_PRIVATE void sqlite3DeleteFrom(\n  Parse *pParse,         /* The parser context */\n  SrcList *pTabList,     /* The table from which we should delete things */\n  Expr *pWhere           /* The WHERE clause.  May be null */\n){\n  Vdbe *v;               /* The virtual database engine */\n  Table *pTab;           /* The table from which records will be deleted */\n  const char *zDb;       /* Name of database holding pTab */\n  int end, addr = 0;     /* A couple addresses of generated code */\n  int i;                 /* Loop counter */\n  WhereInfo *pWInfo;     /* Information about the WHERE clause */\n  Index *pIdx;           /* For looping over indices of the table */\n  int iCur;              /* VDBE Cursor number for pTab */\n  sqlite3 *db;           /* Main database structure */\n  AuthContext sContext;  /* Authorization context */\n  NameContext sNC;       /* Name context to resolve expressions in */\n  int iDb;               /* Database number */\n  int memCnt = -1;       /* Memory cell used for change counting */\n  int rcauth;            /* Value returned by authorization callback */\n\n#ifndef SQLITE_OMIT_TRIGGER\n  int isView;                  /* True if attempting to delete from a view */\n  Trigger *pTrigger;           /* List of table triggers, if required */\n#endif\n\n  memset(&sContext, 0, sizeof(sContext));\n  db = pParse->db;\n  if( pParse->nErr || db->mallocFailed ){\n    goto delete_from_cleanup;\n  }\n  assert( pTabList->nSrc==1 );\n\n  /* Locate the table which we want to delete.  This table has to be\n  ** put in an SrcList structure because some of the subroutines we\n  ** will be calling are designed to work with multiple tables and expect\n  ** an SrcList* parameter instead of just a Table* parameter.\n  */\n  pTab = sqlite3SrcListLookup(pParse, pTabList);\n  if( pTab==0 )  goto delete_from_cleanup;\n\n  /* Figure out if we have any triggers and if the table being\n  ** deleted from is a view\n  */\n#ifndef SQLITE_OMIT_TRIGGER\n  pTrigger = sqlite3TriggersExist(pParse, pTab, TK_DELETE, 0, 0);\n  isView = pTab->pSelect!=0;\n#else\n# define pTrigger 0\n# define isView 0\n#endif\n#ifdef SQLITE_OMIT_VIEW\n# undef isView\n# define isView 0\n#endif\n\n  /* If pTab is really a view, make sure it has been initialized.\n  */\n  if( sqlite3ViewGetColumnNames(pParse, pTab) ){\n    goto delete_from_cleanup;\n  }\n\n  if( sqlite3IsReadOnly(pParse, pTab, (pTrigger?1:0)) ){\n    goto delete_from_cleanup;\n  }\n  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n  assert( iDb<db->nDb );\n  zDb = db->aDb[iDb].zName;\n  rcauth = sqlite3AuthCheck(pParse, SQLITE_DELETE, pTab->zName, 0, zDb);\n  assert( rcauth==SQLITE_OK || rcauth==SQLITE_DENY || rcauth==SQLITE_IGNORE );\n  if( rcauth==SQLITE_DENY ){\n    goto delete_from_cleanup;\n  }\n  assert(!isView || pTrigger);\n\n  /* Assign  cursor number to the table and all its indices.\n  */\n  assert( pTabList->nSrc==1 );\n  iCur = pTabList->a[0].iCursor = pParse->nTab++;\n  for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){\n    pParse->nTab++;\n  }\n\n  /* Start the view context\n  */\n  if( isView ){\n    sqlite3AuthContextPush(pParse, &sContext, pTab->zName);\n  }\n\n  /* Begin generating code.\n  */\n  v = sqlite3GetVdbe(pParse);\n  if( v==0 ){\n    goto delete_from_cleanup;\n  }\n  if( pParse->nested==0 ) sqlite3VdbeCountChanges(v);\n  sqlite3BeginWriteOperation(pParse, 1, iDb);\n\n  /* If we are trying to delete from a view, realize that view into\n  ** a ephemeral table.\n  */\n#if !defined(SQLITE_OMIT_VIEW) && !defined(SQLITE_OMIT_TRIGGER)\n  if( isView ){\n    sqlite3MaterializeView(pParse, pTab, pWhere, iCur);\n  }\n#endif\n\n  /* Resolve the column names in the WHERE clause.\n  */\n  memset(&sNC, 0, sizeof(sNC));\n  sNC.pParse = pParse;\n  sNC.pSrcList = pTabList;\n  if( sqlite3ResolveExprNames(&sNC, pWhere) ){\n    goto delete_from_cleanup;\n  }\n\n  /* Initialize the counter of the number of rows deleted, if\n  ** we are counting rows.\n  */\n  if( db->flags & SQLITE_CountRows ){\n    memCnt = ++pParse->nMem;\n    sqlite3VdbeAddOp2(v, OP_Integer, 0, memCnt);\n  }\n\n#ifndef SQLITE_OMIT_TRUNCATE_OPTIMIZATION\n  /* Special case: A DELETE without a WHERE clause deletes everything.\n  ** It is easier just to erase the whole table. Prior to version 3.6.5,\n  ** this optimization caused the row change count (the value returned by \n  ** API function sqlite3_count_changes) to be set incorrectly.  */\n  if( rcauth==SQLITE_OK && pWhere==0 && !pTrigger && !IsVirtual(pTab) \n   && 0==sqlite3FkRequired(pParse, pTab, 0, 0)\n  ){\n    assert( !isView );\n    sqlite3VdbeAddOp4(v, OP_Clear, pTab->tnum, iDb, memCnt,\n                      pTab->zName, P4_STATIC);\n    for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){\n      assert( pIdx->pSchema==pTab->pSchema );\n      sqlite3VdbeAddOp2(v, OP_Clear, pIdx->tnum, iDb);\n    }\n  }else\n#endif /* SQLITE_OMIT_TRUNCATE_OPTIMIZATION */\n  /* The usual case: There is a WHERE clause so we have to scan through\n  ** the table and pick which records to delete.\n  */\n  {\n    int iRowSet = ++pParse->nMem;   /* Register for rowset of rows to delete */\n    int iRowid = ++pParse->nMem;    /* Used for storing rowid values. */\n    int regRowid;                   /* Actual register containing rowids */\n\n    /* Collect rowids of every row to be deleted.\n    */\n    sqlite3VdbeAddOp2(v, OP_Null, 0, iRowSet);\n    pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere,0,WHERE_DUPLICATES_OK);\n    if( pWInfo==0 ) goto delete_from_cleanup;\n    regRowid = sqlite3ExprCodeGetColumn(pParse, pTab, -1, iCur, iRowid);\n    sqlite3VdbeAddOp2(v, OP_RowSetAdd, iRowSet, regRowid);\n    if( db->flags & SQLITE_CountRows ){\n      sqlite3VdbeAddOp2(v, OP_AddImm, memCnt, 1);\n    }\n    sqlite3WhereEnd(pWInfo);\n\n    /* Delete every item whose key was written to the list during the\n    ** database scan.  We have to delete items after the scan is complete\n    ** because deleting an item can change the scan order.  */\n    end = sqlite3VdbeMakeLabel(v);\n\n    /* Unless this is a view, open cursors for the table we are \n    ** deleting from and all its indices. If this is a view, then the\n    ** only effect this statement has is to fire the INSTEAD OF \n    ** triggers.  */\n    if( !isView ){\n      sqlite3OpenTableAndIndices(pParse, pTab, iCur, OP_OpenWrite);\n    }\n\n    addr = sqlite3VdbeAddOp3(v, OP_RowSetRead, iRowSet, end, iRowid);\n\n    /* Delete the row */\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n    if( IsVirtual(pTab) ){\n      const char *pVTab = (const char *)sqlite3GetVTable(db, pTab);\n      sqlite3VtabMakeWritable(pParse, pTab);\n      sqlite3VdbeAddOp4(v, OP_VUpdate, 0, 1, iRowid, pVTab, P4_VTAB);\n      sqlite3MayAbort(pParse);\n    }else\n#endif\n    {\n      int count = (pParse->nested==0);    /* True to count changes */\n      sqlite3GenerateRowDelete(pParse, pTab, iCur, iRowid, count, pTrigger, OE_Default);\n    }\n\n    /* End of the delete loop */\n    sqlite3VdbeAddOp2(v, OP_Goto, 0, addr);\n    sqlite3VdbeResolveLabel(v, end);\n\n    /* Close the cursors open on the table and its indexes. */\n    if( !isView && !IsVirtual(pTab) ){\n      for(i=1, pIdx=pTab->pIndex; pIdx; i++, pIdx=pIdx->pNext){\n        sqlite3VdbeAddOp2(v, OP_Close, iCur + i, pIdx->tnum);\n      }\n      sqlite3VdbeAddOp1(v, OP_Close, iCur);\n    }\n  }\n\n  /* Update the sqlite_sequence table by storing the content of the\n  ** maximum rowid counter values recorded while inserting into\n  ** autoincrement tables.\n  */\n  if( pParse->nested==0 && pParse->pTriggerTab==0 ){\n    sqlite3AutoincrementEnd(pParse);\n  }\n\n  /* Return the number of rows that were deleted. If this routine is \n  ** generating code because of a call to sqlite3NestedParse(), do not\n  ** invoke the callback function.\n  */\n  if( (db->flags&SQLITE_CountRows) && !pParse->nested && !pParse->pTriggerTab ){\n    sqlite3VdbeAddOp2(v, OP_ResultRow, memCnt, 1);\n    sqlite3VdbeSetNumCols(v, 1);\n    sqlite3VdbeSetColName(v, 0, COLNAME_NAME, \"rows deleted\", SQLITE_STATIC);\n  }\n\ndelete_from_cleanup:\n  sqlite3AuthContextPop(&sContext);\n  sqlite3SrcListDelete(db, pTabList);\n  sqlite3ExprDelete(db, pWhere);\n  return;\n}\n/* Make sure \"isView\" and other macros defined above are undefined. Otherwise\n** thely may interfere with compilation of other functions in this file\n** (or in another file, if this file becomes part of the amalgamation).  */\n#ifdef isView\n #undef isView\n#endif\n#ifdef pTrigger\n #undef pTrigger\n#endif\n\n/*\n** This routine generates VDBE code that causes a single row of a\n** single table to be deleted.\n**\n** The VDBE must be in a particular state when this routine is called.\n** These are the requirements:\n**\n**   1.  A read/write cursor pointing to pTab, the table containing the row\n**       to be deleted, must be opened as cursor number $iCur.\n**\n**   2.  Read/write cursors for all indices of pTab must be open as\n**       cursor number base+i for the i-th index.\n**\n**   3.  The record number of the row to be deleted must be stored in\n**       memory cell iRowid.\n**\n** This routine generates code to remove both the table record and all \n** index entries that point to that record.\n*/\nSQLITE_PRIVATE void sqlite3GenerateRowDelete(\n  Parse *pParse,     /* Parsing context */\n  Table *pTab,       /* Table containing the row to be deleted */\n  int iCur,          /* Cursor number for the table */\n  int iRowid,        /* Memory cell that contains the rowid to delete */\n  int count,         /* If non-zero, increment the row change counter */\n  Trigger *pTrigger, /* List of triggers to (potentially) fire */\n  int onconf         /* Default ON CONFLICT policy for triggers */\n){\n  Vdbe *v = pParse->pVdbe;        /* Vdbe */\n  int iOld = 0;                   /* First register in OLD.* array */\n  int iLabel;                     /* Label resolved to end of generated code */\n\n  /* Vdbe is guaranteed to have been allocated by this stage. */\n  assert( v );\n\n  /* Seek cursor iCur to the row to delete. If this row no longer exists \n  ** (this can happen if a trigger program has already deleted it), do\n  ** not attempt to delete it or fire any DELETE triggers.  */\n  iLabel = sqlite3VdbeMakeLabel(v);\n  sqlite3VdbeAddOp3(v, OP_NotExists, iCur, iLabel, iRowid);\n \n  /* If there are any triggers to fire, allocate a range of registers to\n  ** use for the old.* references in the triggers.  */\n  if( sqlite3FkRequired(pParse, pTab, 0, 0) || pTrigger ){\n    u32 mask;                     /* Mask of OLD.* columns in use */\n    int iCol;                     /* Iterator used while populating OLD.* */\n\n    /* TODO: Could use temporary registers here. Also could attempt to\n    ** avoid copying the contents of the rowid register.  */\n    mask = sqlite3TriggerColmask(\n        pParse, pTrigger, 0, 0, TRIGGER_BEFORE|TRIGGER_AFTER, pTab, onconf\n    );\n    mask |= sqlite3FkOldmask(pParse, pTab);\n    iOld = pParse->nMem+1;\n    pParse->nMem += (1 + pTab->nCol);\n\n    /* Populate the OLD.* pseudo-table register array. These values will be \n    ** used by any BEFORE and AFTER triggers that exist.  */\n    sqlite3VdbeAddOp2(v, OP_Copy, iRowid, iOld);\n    for(iCol=0; iCol<pTab->nCol; iCol++){\n      if( mask==0xffffffff || mask&(1<<iCol) ){\n        sqlite3ExprCodeGetColumnOfTable(v, pTab, iCur, iCol, iOld+iCol+1);\n      }\n    }\n\n    /* Invoke BEFORE DELETE trigger programs. */\n    sqlite3CodeRowTrigger(pParse, pTrigger, \n        TK_DELETE, 0, TRIGGER_BEFORE, pTab, iOld, onconf, iLabel\n    );\n\n    /* Seek the cursor to the row to be deleted again. It may be that\n    ** the BEFORE triggers coded above have already removed the row\n    ** being deleted. Do not attempt to delete the row a second time, and \n    ** do not fire AFTER triggers.  */\n    sqlite3VdbeAddOp3(v, OP_NotExists, iCur, iLabel, iRowid);\n\n    /* Do FK processing. This call checks that any FK constraints that\n    ** refer to this table (i.e. constraints attached to other tables) \n    ** are not violated by deleting this row.  */\n    sqlite3FkCheck(pParse, pTab, iOld, 0);\n  }\n\n  /* Delete the index and table entries. Skip this step if pTab is really\n  ** a view (in which case the only effect of the DELETE statement is to\n  ** fire the INSTEAD OF triggers).  */ \n  if( pTab->pSelect==0 ){\n    sqlite3GenerateRowIndexDelete(pParse, pTab, iCur, 0);\n    sqlite3VdbeAddOp2(v, OP_Delete, iCur, (count?OPFLAG_NCHANGE:0));\n    if( count ){\n      sqlite3VdbeChangeP4(v, -1, pTab->zName, P4_STATIC);\n    }\n  }\n\n  /* Do any ON CASCADE, SET NULL or SET DEFAULT operations required to\n  ** handle rows (possibly in other tables) that refer via a foreign key\n  ** to the row just deleted. */ \n  sqlite3FkActions(pParse, pTab, 0, iOld);\n\n  /* Invoke AFTER DELETE trigger programs. */\n  sqlite3CodeRowTrigger(pParse, pTrigger, \n      TK_DELETE, 0, TRIGGER_AFTER, pTab, iOld, onconf, iLabel\n  );\n\n  /* Jump here if the row had already been deleted before any BEFORE\n  ** trigger programs were invoked. Or if a trigger program throws a \n  ** RAISE(IGNORE) exception.  */\n  sqlite3VdbeResolveLabel(v, iLabel);\n}\n\n/*\n** This routine generates VDBE code that causes the deletion of all\n** index entries associated with a single row of a single table.\n**\n** The VDBE must be in a particular state when this routine is called.\n** These are the requirements:\n**\n**   1.  A read/write cursor pointing to pTab, the table containing the row\n**       to be deleted, must be opened as cursor number \"iCur\".\n**\n**   2.  Read/write cursors for all indices of pTab must be open as\n**       cursor number iCur+i for the i-th index.\n**\n**   3.  The \"iCur\" cursor must be pointing to the row that is to be\n**       deleted.\n*/\nSQLITE_PRIVATE void sqlite3GenerateRowIndexDelete(\n  Parse *pParse,     /* Parsing and code generating context */\n  Table *pTab,       /* Table containing the row to be deleted */\n  int iCur,          /* Cursor number for the table */\n  int *aRegIdx       /* Only delete if aRegIdx!=0 && aRegIdx[i]>0 */\n){\n  int i;\n  Index *pIdx;\n  int r1;\n\n  for(i=1, pIdx=pTab->pIndex; pIdx; i++, pIdx=pIdx->pNext){\n    if( aRegIdx!=0 && aRegIdx[i-1]==0 ) continue;\n    r1 = sqlite3GenerateIndexKey(pParse, pIdx, iCur, 0, 0);\n    sqlite3VdbeAddOp3(pParse->pVdbe, OP_IdxDelete, iCur+i, r1,pIdx->nColumn+1);\n  }\n}\n\n/*\n** Generate code that will assemble an index key and put it in register\n** regOut.  The key with be for index pIdx which is an index on pTab.\n** iCur is the index of a cursor open on the pTab table and pointing to\n** the entry that needs indexing.\n**\n** Return a register number which is the first in a block of\n** registers that holds the elements of the index key.  The\n** block of registers has already been deallocated by the time\n** this routine returns.\n*/\nSQLITE_PRIVATE int sqlite3GenerateIndexKey(\n  Parse *pParse,     /* Parsing context */\n  Index *pIdx,       /* The index for which to generate a key */\n  int iCur,          /* Cursor number for the pIdx->pTable table */\n  int regOut,        /* Write the new index key to this register */\n  int doMakeRec      /* Run the OP_MakeRecord instruction if true */\n){\n  Vdbe *v = pParse->pVdbe;\n  int j;\n  Table *pTab = pIdx->pTable;\n  int regBase;\n  int nCol;\n\n  nCol = pIdx->nColumn;\n  regBase = sqlite3GetTempRange(pParse, nCol+1);\n  sqlite3VdbeAddOp2(v, OP_Rowid, iCur, regBase+nCol);\n  for(j=0; j<nCol; j++){\n    int idx = pIdx->aiColumn[j];\n    if( idx==pTab->iPKey ){\n      sqlite3VdbeAddOp2(v, OP_SCopy, regBase+nCol, regBase+j);\n    }else{\n      sqlite3VdbeAddOp3(v, OP_Column, iCur, idx, regBase+j);\n      sqlite3ColumnDefault(v, pTab, idx, -1);\n    }\n  }\n  if( doMakeRec ){\n    sqlite3VdbeAddOp3(v, OP_MakeRecord, regBase, nCol+1, regOut);\n    sqlite3VdbeChangeP4(v, -1, sqlite3IndexAffinityStr(v, pIdx), 0);\n  }\n  sqlite3ReleaseTempRange(pParse, regBase, nCol+1);\n  return regBase;\n}\n\n/************** End of delete.c **********************************************/\n/************** Begin file func.c ********************************************/\n/*\n** 2002 February 23\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains the C functions that implement various SQL\n** functions of SQLite.  \n**\n** There is only one exported symbol in this file - the function\n** sqliteRegisterBuildinFunctions() found at the bottom of the file.\n** All other code has file scope.\n*/\n\n/*\n** Return the collating function associated with a function.\n*/\nstatic CollSeq *sqlite3GetFuncCollSeq(sqlite3_context *context){\n  return context->pColl;\n}\n\n/*\n** Implementation of the non-aggregate min() and max() functions\n*/\nstatic void minmaxFunc(\n  sqlite3_context *context,\n  int argc,\n  sqlite3_value **argv\n){\n  int i;\n  int mask;    /* 0 for min() or 0xffffffff for max() */\n  int iBest;\n  CollSeq *pColl;\n\n  assert( argc>1 );\n  mask = sqlite3_user_data(context)==0 ? 0 : -1;\n  pColl = sqlite3GetFuncCollSeq(context);\n  assert( pColl );\n  assert( mask==-1 || mask==0 );\n  iBest = 0;\n  if( sqlite3_value_type(argv[0])==SQLITE_NULL ) return;\n  for(i=1; i<argc; i++){\n    if( sqlite3_value_type(argv[i])==SQLITE_NULL ) return;\n    if( (sqlite3MemCompare(argv[iBest], argv[i], pColl)^mask)>=0 ){\n      testcase( mask==0 );\n      iBest = i;\n    }\n  }\n  sqlite3_result_value(context, argv[iBest]);\n}\n\n/*\n** Return the type of the argument.\n*/\nstatic void typeofFunc(\n  sqlite3_context *context,\n  int NotUsed,\n  sqlite3_value **argv\n){\n  const char *z = 0;\n  UNUSED_PARAMETER(NotUsed);\n  switch( sqlite3_value_type(argv[0]) ){\n    case SQLITE_INTEGER: z = \"integer\"; break;\n    case SQLITE_TEXT:    z = \"text\";    break;\n    case SQLITE_FLOAT:   z = \"real\";    break;\n    case SQLITE_BLOB:    z = \"blob\";    break;\n    default:             z = \"null\";    break;\n  }\n  sqlite3_result_text(context, z, -1, SQLITE_STATIC);\n}\n\n\n/*\n** Implementation of the length() function\n*/\nstatic void lengthFunc(\n  sqlite3_context *context,\n  int argc,\n  sqlite3_value **argv\n){\n  int len;\n\n  assert( argc==1 );\n  UNUSED_PARAMETER(argc);\n  switch( sqlite3_value_type(argv[0]) ){\n    case SQLITE_BLOB:\n    case SQLITE_INTEGER:\n    case SQLITE_FLOAT: {\n      sqlite3_result_int(context, sqlite3_value_bytes(argv[0]));\n      break;\n    }\n    case SQLITE_TEXT: {\n      const unsigned char *z = sqlite3_value_text(argv[0]);\n      if( z==0 ) return;\n      len = 0;\n      while( *z ){\n        len++;\n        SQLITE_SKIP_UTF8(z);\n      }\n      sqlite3_result_int(context, len);\n      break;\n    }\n    default: {\n      sqlite3_result_null(context);\n      break;\n    }\n  }\n}\n\n/*\n** Implementation of the abs() function.\n**\n** IMP: R-23979-26855 The abs(X) function returns the absolute value of\n** the numeric argument X. \n*/\nstatic void absFunc(sqlite3_context *context, int argc, sqlite3_value **argv){\n  assert( argc==1 );\n  UNUSED_PARAMETER(argc);\n  switch( sqlite3_value_type(argv[0]) ){\n    case SQLITE_INTEGER: {\n      i64 iVal = sqlite3_value_int64(argv[0]);\n      if( iVal<0 ){\n        if( (iVal<<1)==0 ){\n          /* IMP: R-35460-15084 If X is the integer -9223372036854775807 then\n          ** abs(X) throws an integer overflow error since there is no\n          ** equivalent positive 64-bit two complement value. */\n          sqlite3_result_error(context, \"integer overflow\", -1);\n          return;\n        }\n        iVal = -iVal;\n      } \n      sqlite3_result_int64(context, iVal);\n      break;\n    }\n    case SQLITE_NULL: {\n      /* IMP: R-37434-19929 Abs(X) returns NULL if X is NULL. */\n      sqlite3_result_null(context);\n      break;\n    }\n    default: {\n      /* Because sqlite3_value_double() returns 0.0 if the argument is not\n      ** something that can be converted into a number, we have:\n      ** IMP: R-57326-31541 Abs(X) return 0.0 if X is a string or blob that\n      ** cannot be converted to a numeric value. \n      */\n      double rVal = sqlite3_value_double(argv[0]);\n      if( rVal<0 ) rVal = -rVal;\n      sqlite3_result_double(context, rVal);\n      break;\n    }\n  }\n}\n\n/*\n** Implementation of the substr() function.\n**\n** substr(x,p1,p2)  returns p2 characters of x[] beginning with p1.\n** p1 is 1-indexed.  So substr(x,1,1) returns the first character\n** of x.  If x is text, then we actually count UTF-8 characters.\n** If x is a blob, then we count bytes.\n**\n** If p1 is negative, then we begin abs(p1) from the end of x[].\n**\n** If p2 is negative, return the p2 characters preceeding p1.\n*/\nstatic void substrFunc(\n  sqlite3_context *context,\n  int argc,\n  sqlite3_value **argv\n){\n  const unsigned char *z;\n  const unsigned char *z2;\n  int len;\n  int p0type;\n  i64 p1, p2;\n  int negP2 = 0;\n\n  assert( argc==3 || argc==2 );\n  if( sqlite3_value_type(argv[1])==SQLITE_NULL\n   || (argc==3 && sqlite3_value_type(argv[2])==SQLITE_NULL)\n  ){\n    return;\n  }\n  p0type = sqlite3_value_type(argv[0]);\n  p1 = sqlite3_value_int(argv[1]);\n  if( p0type==SQLITE_BLOB ){\n    len = sqlite3_value_bytes(argv[0]);\n    z = sqlite3_value_blob(argv[0]);\n    if( z==0 ) return;\n    assert( len==sqlite3_value_bytes(argv[0]) );\n  }else{\n    z = sqlite3_value_text(argv[0]);\n    if( z==0 ) return;\n    len = 0;\n    if( p1<0 ){\n      for(z2=z; *z2; len++){\n        SQLITE_SKIP_UTF8(z2);\n      }\n    }\n  }\n  if( argc==3 ){\n    p2 = sqlite3_value_int(argv[2]);\n    if( p2<0 ){\n      p2 = -p2;\n      negP2 = 1;\n    }\n  }else{\n    p2 = sqlite3_context_db_handle(context)->aLimit[SQLITE_LIMIT_LENGTH];\n  }\n  if( p1<0 ){\n    p1 += len;\n    if( p1<0 ){\n      p2 += p1;\n      if( p2<0 ) p2 = 0;\n      p1 = 0;\n    }\n  }else if( p1>0 ){\n    p1--;\n  }else if( p2>0 ){\n    p2--;\n  }\n  if( negP2 ){\n    p1 -= p2;\n    if( p1<0 ){\n      p2 += p1;\n      p1 = 0;\n    }\n  }\n  assert( p1>=0 && p2>=0 );\n  if( p0type!=SQLITE_BLOB ){\n    while( *z && p1 ){\n      SQLITE_SKIP_UTF8(z);\n      p1--;\n    }\n    for(z2=z; *z2 && p2; p2--){\n      SQLITE_SKIP_UTF8(z2);\n    }\n    sqlite3_result_text(context, (char*)z, (int)(z2-z), SQLITE_TRANSIENT);\n  }else{\n    if( p1+p2>len ){\n      p2 = len-p1;\n      if( p2<0 ) p2 = 0;\n    }\n    sqlite3_result_blob(context, (char*)&z[p1], (int)p2, SQLITE_TRANSIENT);\n  }\n}\n\n/*\n** Implementation of the round() function\n*/\n#ifndef SQLITE_OMIT_FLOATING_POINT\nstatic void roundFunc(sqlite3_context *context, int argc, sqlite3_value **argv){\n  int n = 0;\n  double r;\n  char *zBuf;\n  assert( argc==1 || argc==2 );\n  if( argc==2 ){\n    if( SQLITE_NULL==sqlite3_value_type(argv[1]) ) return;\n    n = sqlite3_value_int(argv[1]);\n    if( n>30 ) n = 30;\n    if( n<0 ) n = 0;\n  }\n  if( sqlite3_value_type(argv[0])==SQLITE_NULL ) return;\n  r = sqlite3_value_double(argv[0]);\n  /* If Y==0 and X will fit in a 64-bit int,\n  ** handle the rounding directly,\n  ** otherwise use printf.\n  */\n  if( n==0 && r>=0 && r<LARGEST_INT64-1 ){\n    r = (double)((sqlite_int64)(r+0.5));\n  }else if( n==0 && r<0 && (-r)<LARGEST_INT64-1 ){\n    r = -(double)((sqlite_int64)((-r)+0.5));\n  }else{\n    zBuf = sqlite3_mprintf(\"%.*f\",n,r);\n    if( zBuf==0 ){\n      sqlite3_result_error_nomem(context);\n      return;\n    }\n    sqlite3AtoF(zBuf, &r, sqlite3Strlen30(zBuf), SQLITE_UTF8);\n    sqlite3_free(zBuf);\n  }\n  sqlite3_result_double(context, r);\n}\n#endif\n\n/*\n** Allocate nByte bytes of space using sqlite3_malloc(). If the\n** allocation fails, call sqlite3_result_error_nomem() to notify\n** the database handle that malloc() has failed and return NULL.\n** If nByte is larger than the maximum string or blob length, then\n** raise an SQLITE_TOOBIG exception and return NULL.\n*/\nstatic void *contextMalloc(sqlite3_context *context, i64 nByte){\n  char *z;\n  sqlite3 *db = sqlite3_context_db_handle(context);\n  assert( nByte>0 );\n  testcase( nByte==db->aLimit[SQLITE_LIMIT_LENGTH] );\n  testcase( nByte==db->aLimit[SQLITE_LIMIT_LENGTH]+1 );\n  if( nByte>db->aLimit[SQLITE_LIMIT_LENGTH] ){\n    sqlite3_result_error_toobig(context);\n    z = 0;\n  }else{\n    z = sqlite3Malloc((int)nByte);\n    if( !z ){\n      sqlite3_result_error_nomem(context);\n    }\n  }\n  return z;\n}\n\n/*\n** Implementation of the upper() and lower() SQL functions.\n*/\nstatic void upperFunc(sqlite3_context *context, int argc, sqlite3_value **argv){\n  char *z1;\n  const char *z2;\n  int i, n;\n  UNUSED_PARAMETER(argc);\n  z2 = (char*)sqlite3_value_text(argv[0]);\n  n = sqlite3_value_bytes(argv[0]);\n  /* Verify that the call to _bytes() does not invalidate the _text() pointer */\n  assert( z2==(char*)sqlite3_value_text(argv[0]) );\n  if( z2 ){\n    z1 = contextMalloc(context, ((i64)n)+1);\n    if( z1 ){\n      memcpy(z1, z2, n+1);\n      for(i=0; z1[i]; i++){\n        z1[i] = (char)sqlite3Toupper(z1[i]);\n      }\n      sqlite3_result_text(context, z1, -1, sqlite3_free);\n    }\n  }\n}\nstatic void lowerFunc(sqlite3_context *context, int argc, sqlite3_value **argv){\n  u8 *z1;\n  const char *z2;\n  int i, n;\n  UNUSED_PARAMETER(argc);\n  z2 = (char*)sqlite3_value_text(argv[0]);\n  n = sqlite3_value_bytes(argv[0]);\n  /* Verify that the call to _bytes() does not invalidate the _text() pointer */\n  assert( z2==(char*)sqlite3_value_text(argv[0]) );\n  if( z2 ){\n    z1 = contextMalloc(context, ((i64)n)+1);\n    if( z1 ){\n      memcpy(z1, z2, n+1);\n      for(i=0; z1[i]; i++){\n        z1[i] = sqlite3Tolower(z1[i]);\n      }\n      sqlite3_result_text(context, (char *)z1, -1, sqlite3_free);\n    }\n  }\n}\n\n\n#if 0  /* This function is never used. */\n/*\n** The COALESCE() and IFNULL() functions used to be implemented as shown\n** here.  But now they are implemented as VDBE code so that unused arguments\n** do not have to be computed.  This legacy implementation is retained as\n** comment.\n*/\n/*\n** Implementation of the IFNULL(), NVL(), and COALESCE() functions.  \n** All three do the same thing.  They return the first non-NULL\n** argument.\n*/\nstatic void ifnullFunc(\n  sqlite3_context *context,\n  int argc,\n  sqlite3_value **argv\n){\n  int i;\n  for(i=0; i<argc; i++){\n    if( SQLITE_NULL!=sqlite3_value_type(argv[i]) ){\n      sqlite3_result_value(context, argv[i]);\n      break;\n    }\n  }\n}\n#endif /* NOT USED */\n#define ifnullFunc versionFunc   /* Substitute function - never called */\n\n/*\n** Implementation of random().  Return a random integer.  \n*/\nstatic void randomFunc(\n  sqlite3_context *context,\n  int NotUsed,\n  sqlite3_value **NotUsed2\n){\n  sqlite_int64 r;\n  UNUSED_PARAMETER2(NotUsed, NotUsed2);\n  sqlite3_randomness(sizeof(r), &r);\n  if( r<0 ){\n    /* We need to prevent a random number of 0x8000000000000000 \n    ** (or -9223372036854775808) since when you do abs() of that\n    ** number of you get the same value back again.  To do this\n    ** in a way that is testable, mask the sign bit off of negative\n    ** values, resulting in a positive value.  Then take the \n    ** 2s complement of that positive value.  The end result can\n    ** therefore be no less than -9223372036854775807.\n    */\n    r = -(r ^ (((sqlite3_int64)1)<<63));\n  }\n  sqlite3_result_int64(context, r);\n}\n\n/*\n** Implementation of randomblob(N).  Return a random blob\n** that is N bytes long.\n*/\nstatic void randomBlob(\n  sqlite3_context *context,\n  int argc,\n  sqlite3_value **argv\n){\n  int n;\n  unsigned char *p;\n  assert( argc==1 );\n  UNUSED_PARAMETER(argc);\n  n = sqlite3_value_int(argv[0]);\n  if( n<1 ){\n    n = 1;\n  }\n  p = contextMalloc(context, n);\n  if( p ){\n    sqlite3_randomness(n, p);\n    sqlite3_result_blob(context, (char*)p, n, sqlite3_free);\n  }\n}\n\n/*\n** Implementation of the last_insert_rowid() SQL function.  The return\n** value is the same as the sqlite3_last_insert_rowid() API function.\n*/\nstatic void last_insert_rowid(\n  sqlite3_context *context, \n  int NotUsed, \n  sqlite3_value **NotUsed2\n){\n  sqlite3 *db = sqlite3_context_db_handle(context);\n  UNUSED_PARAMETER2(NotUsed, NotUsed2);\n  /* IMP: R-51513-12026 The last_insert_rowid() SQL function is a\n  ** wrapper around the sqlite3_last_insert_rowid() C/C++ interface\n  ** function. */\n  sqlite3_result_int64(context, sqlite3_last_insert_rowid(db));\n}\n\n/*\n** Implementation of the changes() SQL function.\n**\n** IMP: R-62073-11209 The changes() SQL function is a wrapper\n** around the sqlite3_changes() C/C++ function and hence follows the same\n** rules for counting changes.\n*/\nstatic void changes(\n  sqlite3_context *context,\n  int NotUsed,\n  sqlite3_value **NotUsed2\n){\n  sqlite3 *db = sqlite3_context_db_handle(context);\n  UNUSED_PARAMETER2(NotUsed, NotUsed2);\n  sqlite3_result_int(context, sqlite3_changes(db));\n}\n\n/*\n** Implementation of the total_changes() SQL function.  The return value is\n** the same as the sqlite3_total_changes() API function.\n*/\nstatic void total_changes(\n  sqlite3_context *context,\n  int NotUsed,\n  sqlite3_value **NotUsed2\n){\n  sqlite3 *db = sqlite3_context_db_handle(context);\n  UNUSED_PARAMETER2(NotUsed, NotUsed2);\n  /* IMP: R-52756-41993 This function is a wrapper around the\n  ** sqlite3_total_changes() C/C++ interface. */\n  sqlite3_result_int(context, sqlite3_total_changes(db));\n}\n\n/*\n** A structure defining how to do GLOB-style comparisons.\n*/\nstruct compareInfo {\n  u8 matchAll;\n  u8 matchOne;\n  u8 matchSet;\n  u8 noCase;\n};\n\n/*\n** For LIKE and GLOB matching on EBCDIC machines, assume that every\n** character is exactly one byte in size.  Also, all characters are\n** able to participate in upper-case-to-lower-case mappings in EBCDIC\n** whereas only characters less than 0x80 do in ASCII.\n*/\n#if defined(SQLITE_EBCDIC)\n# define sqlite3Utf8Read(A,C)    (*(A++))\n# define GlogUpperToLower(A)     A = sqlite3UpperToLower[A]\n#else\n# define GlogUpperToLower(A)     if( A<0x80 ){ A = sqlite3UpperToLower[A]; }\n#endif\n\nstatic const struct compareInfo globInfo = { '*', '?', '[', 0 };\n/* The correct SQL-92 behavior is for the LIKE operator to ignore\n** case.  Thus  'a' LIKE 'A' would be true. */\nstatic const struct compareInfo likeInfoNorm = { '%', '_',   0, 1 };\n/* If SQLITE_CASE_SENSITIVE_LIKE is defined, then the LIKE operator\n** is case sensitive causing 'a' LIKE 'A' to be false */\nstatic const struct compareInfo likeInfoAlt = { '%', '_',   0, 0 };\n\n/*\n** Compare two UTF-8 strings for equality where the first string can\n** potentially be a \"glob\" expression.  Return true (1) if they\n** are the same and false (0) if they are different.\n**\n** Globbing rules:\n**\n**      '*'       Matches any sequence of zero or more characters.\n**\n**      '?'       Matches exactly one character.\n**\n**     [...]      Matches one character from the enclosed list of\n**                characters.\n**\n**     [^...]     Matches one character not in the enclosed list.\n**\n** With the [...] and [^...] matching, a ']' character can be included\n** in the list by making it the first character after '[' or '^'.  A\n** range of characters can be specified using '-'.  Example:\n** \"[a-z]\" matches any single lower-case letter.  To match a '-', make\n** it the last character in the list.\n**\n** This routine is usually quick, but can be N**2 in the worst case.\n**\n** Hints: to match '*' or '?', put them in \"[]\".  Like this:\n**\n**         abc[*]xyz        Matches \"abc*xyz\" only\n*/\nstatic int patternCompare(\n  const u8 *zPattern,              /* The glob pattern */\n  const u8 *zString,               /* The string to compare against the glob */\n  const struct compareInfo *pInfo, /* Information about how to do the compare */\n  const int esc                    /* The escape character */\n){\n  int c, c2;\n  int invert;\n  int seen;\n  u8 matchOne = pInfo->matchOne;\n  u8 matchAll = pInfo->matchAll;\n  u8 matchSet = pInfo->matchSet;\n  u8 noCase = pInfo->noCase; \n  int prevEscape = 0;     /* True if the previous character was 'escape' */\n\n  while( (c = sqlite3Utf8Read(zPattern,&zPattern))!=0 ){\n    if( !prevEscape && c==matchAll ){\n      while( (c=sqlite3Utf8Read(zPattern,&zPattern)) == matchAll\n               || c == matchOne ){\n        if( c==matchOne && sqlite3Utf8Read(zString, &zString)==0 ){\n          return 0;\n        }\n      }\n      if( c==0 ){\n        return 1;\n      }else if( c==esc ){\n        c = sqlite3Utf8Read(zPattern, &zPattern);\n        if( c==0 ){\n          return 0;\n        }\n      }else if( c==matchSet ){\n        assert( esc==0 );         /* This is GLOB, not LIKE */\n        assert( matchSet<0x80 );  /* '[' is a single-byte character */\n        while( *zString && patternCompare(&zPattern[-1],zString,pInfo,esc)==0 ){\n          SQLITE_SKIP_UTF8(zString);\n        }\n        return *zString!=0;\n      }\n      while( (c2 = sqlite3Utf8Read(zString,&zString))!=0 ){\n        if( noCase ){\n          GlogUpperToLower(c2);\n          GlogUpperToLower(c);\n          while( c2 != 0 && c2 != c ){\n            c2 = sqlite3Utf8Read(zString, &zString);\n            GlogUpperToLower(c2);\n          }\n        }else{\n          while( c2 != 0 && c2 != c ){\n            c2 = sqlite3Utf8Read(zString, &zString);\n          }\n        }\n        if( c2==0 ) return 0;\n        if( patternCompare(zPattern,zString,pInfo,esc) ) return 1;\n      }\n      return 0;\n    }else if( !prevEscape && c==matchOne ){\n      if( sqlite3Utf8Read(zString, &zString)==0 ){\n        return 0;\n      }\n    }else if( c==matchSet ){\n      int prior_c = 0;\n      assert( esc==0 );    /* This only occurs for GLOB, not LIKE */\n      seen = 0;\n      invert = 0;\n      c = sqlite3Utf8Read(zString, &zString);\n      if( c==0 ) return 0;\n      c2 = sqlite3Utf8Read(zPattern, &zPattern);\n      if( c2=='^' ){\n        invert = 1;\n        c2 = sqlite3Utf8Read(zPattern, &zPattern);\n      }\n      if( c2==']' ){\n        if( c==']' ) seen = 1;\n        c2 = sqlite3Utf8Read(zPattern, &zPattern);\n      }\n      while( c2 && c2!=']' ){\n        if( c2=='-' && zPattern[0]!=']' && zPattern[0]!=0 && prior_c>0 ){\n          c2 = sqlite3Utf8Read(zPattern, &zPattern);\n          if( c>=prior_c && c<=c2 ) seen = 1;\n          prior_c = 0;\n        }else{\n          if( c==c2 ){\n            seen = 1;\n          }\n          prior_c = c2;\n        }\n        c2 = sqlite3Utf8Read(zPattern, &zPattern);\n      }\n      if( c2==0 || (seen ^ invert)==0 ){\n        return 0;\n      }\n    }else if( esc==c && !prevEscape ){\n      prevEscape = 1;\n    }else{\n      c2 = sqlite3Utf8Read(zString, &zString);\n      if( noCase ){\n        GlogUpperToLower(c);\n        GlogUpperToLower(c2);\n      }\n      if( c!=c2 ){\n        return 0;\n      }\n      prevEscape = 0;\n    }\n  }\n  return *zString==0;\n}\n\n/*\n** Count the number of times that the LIKE operator (or GLOB which is\n** just a variation of LIKE) gets called.  This is used for testing\n** only.\n*/\n#ifdef SQLITE_TEST\nSQLITE_API int sqlite3_like_count = 0;\n#endif\n\n\n/*\n** Implementation of the like() SQL function.  This function implements\n** the build-in LIKE operator.  The first argument to the function is the\n** pattern and the second argument is the string.  So, the SQL statements:\n**\n**       A LIKE B\n**\n** is implemented as like(B,A).\n**\n** This same function (with a different compareInfo structure) computes\n** the GLOB operator.\n*/\nstatic void likeFunc(\n  sqlite3_context *context, \n  int argc, \n  sqlite3_value **argv\n){\n  const unsigned char *zA, *zB;\n  int escape = 0;\n  int nPat;\n  sqlite3 *db = sqlite3_context_db_handle(context);\n\n  zB = sqlite3_value_text(argv[0]);\n  zA = sqlite3_value_text(argv[1]);\n\n  /* Limit the length of the LIKE or GLOB pattern to avoid problems\n  ** of deep recursion and N*N behavior in patternCompare().\n  */\n  nPat = sqlite3_value_bytes(argv[0]);\n  testcase( nPat==db->aLimit[SQLITE_LIMIT_LIKE_PATTERN_LENGTH] );\n  testcase( nPat==db->aLimit[SQLITE_LIMIT_LIKE_PATTERN_LENGTH]+1 );\n  if( nPat > db->aLimit[SQLITE_LIMIT_LIKE_PATTERN_LENGTH] ){\n    sqlite3_result_error(context, \"LIKE or GLOB pattern too complex\", -1);\n    return;\n  }\n  assert( zB==sqlite3_value_text(argv[0]) );  /* Encoding did not change */\n\n  if( argc==3 ){\n    /* The escape character string must consist of a single UTF-8 character.\n    ** Otherwise, return an error.\n    */\n    const unsigned char *zEsc = sqlite3_value_text(argv[2]);\n    if( zEsc==0 ) return;\n    if( sqlite3Utf8CharLen((char*)zEsc, -1)!=1 ){\n      sqlite3_result_error(context, \n          \"ESCAPE expression must be a single character\", -1);\n      return;\n    }\n    escape = sqlite3Utf8Read(zEsc, &zEsc);\n  }\n  if( zA && zB ){\n    struct compareInfo *pInfo = sqlite3_user_data(context);\n#ifdef SQLITE_TEST\n    sqlite3_like_count++;\n#endif\n    \n    sqlite3_result_int(context, patternCompare(zB, zA, pInfo, escape));\n  }\n}\n\n/*\n** Implementation of the NULLIF(x,y) function.  The result is the first\n** argument if the arguments are different.  The result is NULL if the\n** arguments are equal to each other.\n*/\nstatic void nullifFunc(\n  sqlite3_context *context,\n  int NotUsed,\n  sqlite3_value **argv\n){\n  CollSeq *pColl = sqlite3GetFuncCollSeq(context);\n  UNUSED_PARAMETER(NotUsed);\n  if( sqlite3MemCompare(argv[0], argv[1], pColl)!=0 ){\n    sqlite3_result_value(context, argv[0]);\n  }\n}\n\n/*\n** Implementation of the sqlite_version() function.  The result is the version\n** of the SQLite library that is running.\n*/\nstatic void versionFunc(\n  sqlite3_context *context,\n  int NotUsed,\n  sqlite3_value **NotUsed2\n){\n  UNUSED_PARAMETER2(NotUsed, NotUsed2);\n  /* IMP: R-48699-48617 This function is an SQL wrapper around the\n  ** sqlite3_libversion() C-interface. */\n  sqlite3_result_text(context, sqlite3_libversion(), -1, SQLITE_STATIC);\n}\n\n/*\n** Implementation of the sqlite_source_id() function. The result is a string\n** that identifies the particular version of the source code used to build\n** SQLite.\n*/\nstatic void sourceidFunc(\n  sqlite3_context *context,\n  int NotUsed,\n  sqlite3_value **NotUsed2\n){\n  UNUSED_PARAMETER2(NotUsed, NotUsed2);\n  /* IMP: R-24470-31136 This function is an SQL wrapper around the\n  ** sqlite3_sourceid() C interface. */\n  sqlite3_result_text(context, sqlite3_sourceid(), -1, SQLITE_STATIC);\n}\n\n/*\n** Implementation of the sqlite_compileoption_used() function.\n** The result is an integer that identifies if the compiler option\n** was used to build SQLite.\n*/\n#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS\nstatic void compileoptionusedFunc(\n  sqlite3_context *context,\n  int argc,\n  sqlite3_value **argv\n){\n  const char *zOptName;\n  assert( argc==1 );\n  UNUSED_PARAMETER(argc);\n  /* IMP: R-39564-36305 The sqlite_compileoption_used() SQL\n  ** function is a wrapper around the sqlite3_compileoption_used() C/C++\n  ** function.\n  */\n  if( (zOptName = (const char*)sqlite3_value_text(argv[0]))!=0 ){\n    sqlite3_result_int(context, sqlite3_compileoption_used(zOptName));\n  }\n}\n#endif /* SQLITE_OMIT_COMPILEOPTION_DIAGS */\n\n/*\n** Implementation of the sqlite_compileoption_get() function. \n** The result is a string that identifies the compiler options \n** used to build SQLite.\n*/\n#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS\nstatic void compileoptiongetFunc(\n  sqlite3_context *context,\n  int argc,\n  sqlite3_value **argv\n){\n  int n;\n  assert( argc==1 );\n  UNUSED_PARAMETER(argc);\n  /* IMP: R-04922-24076 The sqlite_compileoption_get() SQL function\n  ** is a wrapper around the sqlite3_compileoption_get() C/C++ function.\n  */\n  n = sqlite3_value_int(argv[0]);\n  sqlite3_result_text(context, sqlite3_compileoption_get(n), -1, SQLITE_STATIC);\n}\n#endif /* SQLITE_OMIT_COMPILEOPTION_DIAGS */\n\n/* Array for converting from half-bytes (nybbles) into ASCII hex\n** digits. */\nstatic const char hexdigits[] = {\n  '0', '1', '2', '3', '4', '5', '6', '7',\n  '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' \n};\n\n/*\n** EXPERIMENTAL - This is not an official function.  The interface may\n** change.  This function may disappear.  Do not write code that depends\n** on this function.\n**\n** Implementation of the QUOTE() function.  This function takes a single\n** argument.  If the argument is numeric, the return value is the same as\n** the argument.  If the argument is NULL, the return value is the string\n** \"NULL\".  Otherwise, the argument is enclosed in single quotes with\n** single-quote escapes.\n*/\nstatic void quoteFunc(sqlite3_context *context, int argc, sqlite3_value **argv){\n  assert( argc==1 );\n  UNUSED_PARAMETER(argc);\n  switch( sqlite3_value_type(argv[0]) ){\n    case SQLITE_INTEGER:\n    case SQLITE_FLOAT: {\n      sqlite3_result_value(context, argv[0]);\n      break;\n    }\n    case SQLITE_BLOB: {\n      char *zText = 0;\n      char const *zBlob = sqlite3_value_blob(argv[0]);\n      int nBlob = sqlite3_value_bytes(argv[0]);\n      assert( zBlob==sqlite3_value_blob(argv[0]) ); /* No encoding change */\n      zText = (char *)contextMalloc(context, (2*(i64)nBlob)+4); \n      if( zText ){\n        int i;\n        for(i=0; i<nBlob; i++){\n          zText[(i*2)+2] = hexdigits[(zBlob[i]>>4)&0x0F];\n          zText[(i*2)+3] = hexdigits[(zBlob[i])&0x0F];\n        }\n        zText[(nBlob*2)+2] = '\\'';\n        zText[(nBlob*2)+3] = '\\0';\n        zText[0] = 'X';\n        zText[1] = '\\'';\n        sqlite3_result_text(context, zText, -1, SQLITE_TRANSIENT);\n        sqlite3_free(zText);\n      }\n      break;\n    }\n    case SQLITE_TEXT: {\n      int i,j;\n      u64 n;\n      const unsigned char *zArg = sqlite3_value_text(argv[0]);\n      char *z;\n\n      if( zArg==0 ) return;\n      for(i=0, n=0; zArg[i]; i++){ if( zArg[i]=='\\'' ) n++; }\n      z = contextMalloc(context, ((i64)i)+((i64)n)+3);\n      if( z ){\n        z[0] = '\\'';\n        for(i=0, j=1; zArg[i]; i++){\n          z[j++] = zArg[i];\n          if( zArg[i]=='\\'' ){\n            z[j++] = '\\'';\n          }\n        }\n        z[j++] = '\\'';\n        z[j] = 0;\n        sqlite3_result_text(context, z, j, sqlite3_free);\n      }\n      break;\n    }\n    default: {\n      assert( sqlite3_value_type(argv[0])==SQLITE_NULL );\n      sqlite3_result_text(context, \"NULL\", 4, SQLITE_STATIC);\n      break;\n    }\n  }\n}\n\n/*\n** The hex() function.  Interpret the argument as a blob.  Return\n** a hexadecimal rendering as text.\n*/\nstatic void hexFunc(\n  sqlite3_context *context,\n  int argc,\n  sqlite3_value **argv\n){\n  int i, n;\n  const unsigned char *pBlob;\n  char *zHex, *z;\n  assert( argc==1 );\n  UNUSED_PARAMETER(argc);\n  pBlob = sqlite3_value_blob(argv[0]);\n  n = sqlite3_value_bytes(argv[0]);\n  assert( pBlob==sqlite3_value_blob(argv[0]) );  /* No encoding change */\n  z = zHex = contextMalloc(context, ((i64)n)*2 + 1);\n  if( zHex ){\n    for(i=0; i<n; i++, pBlob++){\n      unsigned char c = *pBlob;\n      *(z++) = hexdigits[(c>>4)&0xf];\n      *(z++) = hexdigits[c&0xf];\n    }\n    *z = 0;\n    sqlite3_result_text(context, zHex, n*2, sqlite3_free);\n  }\n}\n\n/*\n** The zeroblob(N) function returns a zero-filled blob of size N bytes.\n*/\nstatic void zeroblobFunc(\n  sqlite3_context *context,\n  int argc,\n  sqlite3_value **argv\n){\n  i64 n;\n  sqlite3 *db = sqlite3_context_db_handle(context);\n  assert( argc==1 );\n  UNUSED_PARAMETER(argc);\n  n = sqlite3_value_int64(argv[0]);\n  testcase( n==db->aLimit[SQLITE_LIMIT_LENGTH] );\n  testcase( n==db->aLimit[SQLITE_LIMIT_LENGTH]+1 );\n  if( n>db->aLimit[SQLITE_LIMIT_LENGTH] ){\n    sqlite3_result_error_toobig(context);\n  }else{\n    sqlite3_result_zeroblob(context, (int)n); /* IMP: R-00293-64994 */\n  }\n}\n\n/*\n** The replace() function.  Three arguments are all strings: call\n** them A, B, and C. The result is also a string which is derived\n** from A by replacing every occurrence of B with C.  The match\n** must be exact.  Collating sequences are not used.\n*/\nstatic void replaceFunc(\n  sqlite3_context *context,\n  int argc,\n  sqlite3_value **argv\n){\n  const unsigned char *zStr;        /* The input string A */\n  const unsigned char *zPattern;    /* The pattern string B */\n  const unsigned char *zRep;        /* The replacement string C */\n  unsigned char *zOut;              /* The output */\n  int nStr;                /* Size of zStr */\n  int nPattern;            /* Size of zPattern */\n  int nRep;                /* Size of zRep */\n  i64 nOut;                /* Maximum size of zOut */\n  int loopLimit;           /* Last zStr[] that might match zPattern[] */\n  int i, j;                /* Loop counters */\n\n  assert( argc==3 );\n  UNUSED_PARAMETER(argc);\n  zStr = sqlite3_value_text(argv[0]);\n  if( zStr==0 ) return;\n  nStr = sqlite3_value_bytes(argv[0]);\n  assert( zStr==sqlite3_value_text(argv[0]) );  /* No encoding change */\n  zPattern = sqlite3_value_text(argv[1]);\n  if( zPattern==0 ){\n    assert( sqlite3_value_type(argv[1])==SQLITE_NULL\n            || sqlite3_context_db_handle(context)->mallocFailed );\n    return;\n  }\n  if( zPattern[0]==0 ){\n    assert( sqlite3_value_type(argv[1])!=SQLITE_NULL );\n    sqlite3_result_value(context, argv[0]);\n    return;\n  }\n  nPattern = sqlite3_value_bytes(argv[1]);\n  assert( zPattern==sqlite3_value_text(argv[1]) );  /* No encoding change */\n  zRep = sqlite3_value_text(argv[2]);\n  if( zRep==0 ) return;\n  nRep = sqlite3_value_bytes(argv[2]);\n  assert( zRep==sqlite3_value_text(argv[2]) );\n  nOut = nStr + 1;\n  assert( nOut<SQLITE_MAX_LENGTH );\n  zOut = contextMalloc(context, (i64)nOut);\n  if( zOut==0 ){\n    return;\n  }\n  loopLimit = nStr - nPattern;  \n  for(i=j=0; i<=loopLimit; i++){\n    if( zStr[i]!=zPattern[0] || memcmp(&zStr[i], zPattern, nPattern) ){\n      zOut[j++] = zStr[i];\n    }else{\n      u8 *zOld;\n      sqlite3 *db = sqlite3_context_db_handle(context);\n      nOut += nRep - nPattern;\n      testcase( nOut-1==db->aLimit[SQLITE_LIMIT_LENGTH] );\n      testcase( nOut-2==db->aLimit[SQLITE_LIMIT_LENGTH] );\n      if( nOut-1>db->aLimit[SQLITE_LIMIT_LENGTH] ){\n        sqlite3_result_error_toobig(context);\n        sqlite3_free(zOut);\n        return;\n      }\n      zOld = zOut;\n      zOut = sqlite3_realloc(zOut, (int)nOut);\n      if( zOut==0 ){\n        sqlite3_result_error_nomem(context);\n        sqlite3_free(zOld);\n        return;\n      }\n      memcpy(&zOut[j], zRep, nRep);\n      j += nRep;\n      i += nPattern-1;\n    }\n  }\n  assert( j+nStr-i+1==nOut );\n  memcpy(&zOut[j], &zStr[i], nStr-i);\n  j += nStr - i;\n  assert( j<=nOut );\n  zOut[j] = 0;\n  sqlite3_result_text(context, (char*)zOut, j, sqlite3_free);\n}\n\n/*\n** Implementation of the TRIM(), LTRIM(), and RTRIM() functions.\n** The userdata is 0x1 for left trim, 0x2 for right trim, 0x3 for both.\n*/\nstatic void trimFunc(\n  sqlite3_context *context,\n  int argc,\n  sqlite3_value **argv\n){\n  const unsigned char *zIn;         /* Input string */\n  const unsigned char *zCharSet;    /* Set of characters to trim */\n  int nIn;                          /* Number of bytes in input */\n  int flags;                        /* 1: trimleft  2: trimright  3: trim */\n  int i;                            /* Loop counter */\n  unsigned char *aLen = 0;          /* Length of each character in zCharSet */\n  unsigned char **azChar = 0;       /* Individual characters in zCharSet */\n  int nChar;                        /* Number of characters in zCharSet */\n\n  if( sqlite3_value_type(argv[0])==SQLITE_NULL ){\n    return;\n  }\n  zIn = sqlite3_value_text(argv[0]);\n  if( zIn==0 ) return;\n  nIn = sqlite3_value_bytes(argv[0]);\n  assert( zIn==sqlite3_value_text(argv[0]) );\n  if( argc==1 ){\n    static const unsigned char lenOne[] = { 1 };\n    static unsigned char * const azOne[] = { (u8*)\" \" };\n    nChar = 1;\n    aLen = (u8*)lenOne;\n    azChar = (unsigned char **)azOne;\n    zCharSet = 0;\n  }else if( (zCharSet = sqlite3_value_text(argv[1]))==0 ){\n    return;\n  }else{\n    const unsigned char *z;\n    for(z=zCharSet, nChar=0; *z; nChar++){\n      SQLITE_SKIP_UTF8(z);\n    }\n    if( nChar>0 ){\n      azChar = contextMalloc(context, ((i64)nChar)*(sizeof(char*)+1));\n      if( azChar==0 ){\n        return;\n      }\n      aLen = (unsigned char*)&azChar[nChar];\n      for(z=zCharSet, nChar=0; *z; nChar++){\n        azChar[nChar] = (unsigned char *)z;\n        SQLITE_SKIP_UTF8(z);\n        aLen[nChar] = (u8)(z - azChar[nChar]);\n      }\n    }\n  }\n  if( nChar>0 ){\n    flags = SQLITE_PTR_TO_INT(sqlite3_user_data(context));\n    if( flags & 1 ){\n      while( nIn>0 ){\n        int len = 0;\n        for(i=0; i<nChar; i++){\n          len = aLen[i];\n          if( len<=nIn && memcmp(zIn, azChar[i], len)==0 ) break;\n        }\n        if( i>=nChar ) break;\n        zIn += len;\n        nIn -= len;\n      }\n    }\n    if( flags & 2 ){\n      while( nIn>0 ){\n        int len = 0;\n        for(i=0; i<nChar; i++){\n          len = aLen[i];\n          if( len<=nIn && memcmp(&zIn[nIn-len],azChar[i],len)==0 ) break;\n        }\n        if( i>=nChar ) break;\n        nIn -= len;\n      }\n    }\n    if( zCharSet ){\n      sqlite3_free(azChar);\n    }\n  }\n  sqlite3_result_text(context, (char*)zIn, nIn, SQLITE_TRANSIENT);\n}\n\n\n/* IMP: R-25361-16150 This function is omitted from SQLite by default. It\n** is only available if the SQLITE_SOUNDEX compile-time option is used\n** when SQLite is built.\n*/\n#ifdef SQLITE_SOUNDEX\n/*\n** Compute the soundex encoding of a word.\n**\n** IMP: R-59782-00072 The soundex(X) function returns a string that is the\n** soundex encoding of the string X. \n*/\nstatic void soundexFunc(\n  sqlite3_context *context,\n  int argc,\n  sqlite3_value **argv\n){\n  char zResult[8];\n  const u8 *zIn;\n  int i, j;\n  static const unsigned char iCode[] = {\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n    0, 0, 1, 2, 3, 0, 1, 2, 0, 0, 2, 2, 4, 5, 5, 0,\n    1, 2, 6, 2, 3, 0, 1, 0, 2, 0, 2, 0, 0, 0, 0, 0,\n    0, 0, 1, 2, 3, 0, 1, 2, 0, 0, 2, 2, 4, 5, 5, 0,\n    1, 2, 6, 2, 3, 0, 1, 0, 2, 0, 2, 0, 0, 0, 0, 0,\n  };\n  assert( argc==1 );\n  zIn = (u8*)sqlite3_value_text(argv[0]);\n  if( zIn==0 ) zIn = (u8*)\"\";\n  for(i=0; zIn[i] && !sqlite3Isalpha(zIn[i]); i++){}\n  if( zIn[i] ){\n    u8 prevcode = iCode[zIn[i]&0x7f];\n    zResult[0] = sqlite3Toupper(zIn[i]);\n    for(j=1; j<4 && zIn[i]; i++){\n      int code = iCode[zIn[i]&0x7f];\n      if( code>0 ){\n        if( code!=prevcode ){\n          prevcode = code;\n          zResult[j++] = code + '0';\n        }\n      }else{\n        prevcode = 0;\n      }\n    }\n    while( j<4 ){\n      zResult[j++] = '0';\n    }\n    zResult[j] = 0;\n    sqlite3_result_text(context, zResult, 4, SQLITE_TRANSIENT);\n  }else{\n    /* IMP: R-64894-50321 The string \"?000\" is returned if the argument\n    ** is NULL or contains no ASCII alphabetic characters. */\n    sqlite3_result_text(context, \"?000\", 4, SQLITE_STATIC);\n  }\n}\n#endif /* SQLITE_SOUNDEX */\n\n#ifndef SQLITE_OMIT_LOAD_EXTENSION\n/*\n** A function that loads a shared-library extension then returns NULL.\n*/\nstatic void loadExt(sqlite3_context *context, int argc, sqlite3_value **argv){\n  const char *zFile = (const char *)sqlite3_value_text(argv[0]);\n  const char *zProc;\n  sqlite3 *db = sqlite3_context_db_handle(context);\n  char *zErrMsg = 0;\n\n  if( argc==2 ){\n    zProc = (const char *)sqlite3_value_text(argv[1]);\n  }else{\n    zProc = 0;\n  }\n  if( zFile && sqlite3_load_extension(db, zFile, zProc, &zErrMsg) ){\n    sqlite3_result_error(context, zErrMsg, -1);\n    sqlite3_free(zErrMsg);\n  }\n}\n#endif\n\n\n/*\n** An instance of the following structure holds the context of a\n** sum() or avg() aggregate computation.\n*/\ntypedef struct SumCtx SumCtx;\nstruct SumCtx {\n  double rSum;      /* Floating point sum */\n  i64 iSum;         /* Integer sum */   \n  i64 cnt;          /* Number of elements summed */\n  u8 overflow;      /* True if integer overflow seen */\n  u8 approx;        /* True if non-integer value was input to the sum */\n};\n\n/*\n** Routines used to compute the sum, average, and total.\n**\n** The SUM() function follows the (broken) SQL standard which means\n** that it returns NULL if it sums over no inputs.  TOTAL returns\n** 0.0 in that case.  In addition, TOTAL always returns a float where\n** SUM might return an integer if it never encounters a floating point\n** value.  TOTAL never fails, but SUM might through an exception if\n** it overflows an integer.\n*/\nstatic void sumStep(sqlite3_context *context, int argc, sqlite3_value **argv){\n  SumCtx *p;\n  int type;\n  assert( argc==1 );\n  UNUSED_PARAMETER(argc);\n  p = sqlite3_aggregate_context(context, sizeof(*p));\n  type = sqlite3_value_numeric_type(argv[0]);\n  if( p && type!=SQLITE_NULL ){\n    p->cnt++;\n    if( type==SQLITE_INTEGER ){\n      i64 v = sqlite3_value_int64(argv[0]);\n      p->rSum += v;\n      if( (p->approx|p->overflow)==0 && sqlite3AddInt64(&p->iSum, v) ){\n        p->overflow = 1;\n      }\n    }else{\n      p->rSum += sqlite3_value_double(argv[0]);\n      p->approx = 1;\n    }\n  }\n}\nstatic void sumFinalize(sqlite3_context *context){\n  SumCtx *p;\n  p = sqlite3_aggregate_context(context, 0);\n  if( p && p->cnt>0 ){\n    if( p->overflow ){\n      sqlite3_result_error(context,\"integer overflow\",-1);\n    }else if( p->approx ){\n      sqlite3_result_double(context, p->rSum);\n    }else{\n      sqlite3_result_int64(context, p->iSum);\n    }\n  }\n}\nstatic void avgFinalize(sqlite3_context *context){\n  SumCtx *p;\n  p = sqlite3_aggregate_context(context, 0);\n  if( p && p->cnt>0 ){\n    sqlite3_result_double(context, p->rSum/(double)p->cnt);\n  }\n}\nstatic void totalFinalize(sqlite3_context *context){\n  SumCtx *p;\n  p = sqlite3_aggregate_context(context, 0);\n  /* (double)0 In case of SQLITE_OMIT_FLOATING_POINT... */\n  sqlite3_result_double(context, p ? p->rSum : (double)0);\n}\n\n/*\n** The following structure keeps track of state information for the\n** count() aggregate function.\n*/\ntypedef struct CountCtx CountCtx;\nstruct CountCtx {\n  i64 n;\n};\n\n/*\n** Routines to implement the count() aggregate function.\n*/\nstatic void countStep(sqlite3_context *context, int argc, sqlite3_value **argv){\n  CountCtx *p;\n  p = sqlite3_aggregate_context(context, sizeof(*p));\n  if( (argc==0 || SQLITE_NULL!=sqlite3_value_type(argv[0])) && p ){\n    p->n++;\n  }\n\n#ifndef SQLITE_OMIT_DEPRECATED\n  /* The sqlite3_aggregate_count() function is deprecated.  But just to make\n  ** sure it still operates correctly, verify that its count agrees with our \n  ** internal count when using count(*) and when the total count can be\n  ** expressed as a 32-bit integer. */\n  assert( argc==1 || p==0 || p->n>0x7fffffff\n          || p->n==sqlite3_aggregate_count(context) );\n#endif\n}   \nstatic void countFinalize(sqlite3_context *context){\n  CountCtx *p;\n  p = sqlite3_aggregate_context(context, 0);\n  sqlite3_result_int64(context, p ? p->n : 0);\n}\n\n/*\n** Routines to implement min() and max() aggregate functions.\n*/\nstatic void minmaxStep(\n  sqlite3_context *context, \n  int NotUsed, \n  sqlite3_value **argv\n){\n  Mem *pArg  = (Mem *)argv[0];\n  Mem *pBest;\n  UNUSED_PARAMETER(NotUsed);\n\n  if( sqlite3_value_type(argv[0])==SQLITE_NULL ) return;\n  pBest = (Mem *)sqlite3_aggregate_context(context, sizeof(*pBest));\n  if( !pBest ) return;\n\n  if( pBest->flags ){\n    int max;\n    int cmp;\n    CollSeq *pColl = sqlite3GetFuncCollSeq(context);\n    /* This step function is used for both the min() and max() aggregates,\n    ** the only difference between the two being that the sense of the\n    ** comparison is inverted. For the max() aggregate, the\n    ** sqlite3_user_data() function returns (void *)-1. For min() it\n    ** returns (void *)db, where db is the sqlite3* database pointer.\n    ** Therefore the next statement sets variable 'max' to 1 for the max()\n    ** aggregate, or 0 for min().\n    */\n    max = sqlite3_user_data(context)!=0;\n    cmp = sqlite3MemCompare(pBest, pArg, pColl);\n    if( (max && cmp<0) || (!max && cmp>0) ){\n      sqlite3VdbeMemCopy(pBest, pArg);\n    }\n  }else{\n    sqlite3VdbeMemCopy(pBest, pArg);\n  }\n}\nstatic void minMaxFinalize(sqlite3_context *context){\n  sqlite3_value *pRes;\n  pRes = (sqlite3_value *)sqlite3_aggregate_context(context, 0);\n  if( pRes ){\n    if( ALWAYS(pRes->flags) ){\n      sqlite3_result_value(context, pRes);\n    }\n    sqlite3VdbeMemRelease(pRes);\n  }\n}\n\n/*\n** group_concat(EXPR, ?SEPARATOR?)\n*/\nstatic void groupConcatStep(\n  sqlite3_context *context,\n  int argc,\n  sqlite3_value **argv\n){\n  const char *zVal;\n  StrAccum *pAccum;\n  const char *zSep;\n  int nVal, nSep;\n  assert( argc==1 || argc==2 );\n  if( sqlite3_value_type(argv[0])==SQLITE_NULL ) return;\n  pAccum = (StrAccum*)sqlite3_aggregate_context(context, sizeof(*pAccum));\n\n  if( pAccum ){\n    sqlite3 *db = sqlite3_context_db_handle(context);\n    int firstTerm = pAccum->useMalloc==0;\n    pAccum->useMalloc = 2;\n    pAccum->mxAlloc = db->aLimit[SQLITE_LIMIT_LENGTH];\n    if( !firstTerm ){\n      if( argc==2 ){\n        zSep = (char*)sqlite3_value_text(argv[1]);\n        nSep = sqlite3_value_bytes(argv[1]);\n      }else{\n        zSep = \",\";\n        nSep = 1;\n      }\n      sqlite3StrAccumAppend(pAccum, zSep, nSep);\n    }\n    zVal = (char*)sqlite3_value_text(argv[0]);\n    nVal = sqlite3_value_bytes(argv[0]);\n    sqlite3StrAccumAppend(pAccum, zVal, nVal);\n  }\n}\nstatic void groupConcatFinalize(sqlite3_context *context){\n  StrAccum *pAccum;\n  pAccum = sqlite3_aggregate_context(context, 0);\n  if( pAccum ){\n    if( pAccum->tooBig ){\n      sqlite3_result_error_toobig(context);\n    }else if( pAccum->mallocFailed ){\n      sqlite3_result_error_nomem(context);\n    }else{    \n      sqlite3_result_text(context, sqlite3StrAccumFinish(pAccum), -1, \n                          sqlite3_free);\n    }\n  }\n}\n\n/*\n** This routine does per-connection function registration.  Most\n** of the built-in functions above are part of the global function set.\n** This routine only deals with those that are not global.\n*/\nSQLITE_PRIVATE void sqlite3RegisterBuiltinFunctions(sqlite3 *db){\n  int rc = sqlite3_overload_function(db, \"MATCH\", 2);\n  assert( rc==SQLITE_NOMEM || rc==SQLITE_OK );\n  if( rc==SQLITE_NOMEM ){\n    db->mallocFailed = 1;\n  }\n}\n\n/*\n** Set the LIKEOPT flag on the 2-argument function with the given name.\n*/\nstatic void setLikeOptFlag(sqlite3 *db, const char *zName, u8 flagVal){\n  FuncDef *pDef;\n  pDef = sqlite3FindFunction(db, zName, sqlite3Strlen30(zName),\n                             2, SQLITE_UTF8, 0);\n  if( ALWAYS(pDef) ){\n    pDef->flags = flagVal;\n  }\n}\n\n/*\n** Register the built-in LIKE and GLOB functions.  The caseSensitive\n** parameter determines whether or not the LIKE operator is case\n** sensitive.  GLOB is always case sensitive.\n*/\nSQLITE_PRIVATE void sqlite3RegisterLikeFunctions(sqlite3 *db, int caseSensitive){\n  struct compareInfo *pInfo;\n  if( caseSensitive ){\n    pInfo = (struct compareInfo*)&likeInfoAlt;\n  }else{\n    pInfo = (struct compareInfo*)&likeInfoNorm;\n  }\n  sqlite3CreateFunc(db, \"like\", 2, SQLITE_UTF8, pInfo, likeFunc, 0, 0, 0);\n  sqlite3CreateFunc(db, \"like\", 3, SQLITE_UTF8, pInfo, likeFunc, 0, 0, 0);\n  sqlite3CreateFunc(db, \"glob\", 2, SQLITE_UTF8, \n      (struct compareInfo*)&globInfo, likeFunc, 0, 0, 0);\n  setLikeOptFlag(db, \"glob\", SQLITE_FUNC_LIKE | SQLITE_FUNC_CASE);\n  setLikeOptFlag(db, \"like\", \n      caseSensitive ? (SQLITE_FUNC_LIKE | SQLITE_FUNC_CASE) : SQLITE_FUNC_LIKE);\n}\n\n/*\n** pExpr points to an expression which implements a function.  If\n** it is appropriate to apply the LIKE optimization to that function\n** then set aWc[0] through aWc[2] to the wildcard characters and\n** return TRUE.  If the function is not a LIKE-style function then\n** return FALSE.\n*/\nSQLITE_PRIVATE int sqlite3IsLikeFunction(sqlite3 *db, Expr *pExpr, int *pIsNocase, char *aWc){\n  FuncDef *pDef;\n  if( pExpr->op!=TK_FUNCTION \n   || !pExpr->x.pList \n   || pExpr->x.pList->nExpr!=2\n  ){\n    return 0;\n  }\n  assert( !ExprHasProperty(pExpr, EP_xIsSelect) );\n  pDef = sqlite3FindFunction(db, pExpr->u.zToken, \n                             sqlite3Strlen30(pExpr->u.zToken),\n                             2, SQLITE_UTF8, 0);\n  if( NEVER(pDef==0) || (pDef->flags & SQLITE_FUNC_LIKE)==0 ){\n    return 0;\n  }\n\n  /* The memcpy() statement assumes that the wildcard characters are\n  ** the first three statements in the compareInfo structure.  The\n  ** asserts() that follow verify that assumption\n  */\n  memcpy(aWc, pDef->pUserData, 3);\n  assert( (char*)&likeInfoAlt == (char*)&likeInfoAlt.matchAll );\n  assert( &((char*)&likeInfoAlt)[1] == (char*)&likeInfoAlt.matchOne );\n  assert( &((char*)&likeInfoAlt)[2] == (char*)&likeInfoAlt.matchSet );\n  *pIsNocase = (pDef->flags & SQLITE_FUNC_CASE)==0;\n  return 1;\n}\n\n/*\n** All all of the FuncDef structures in the aBuiltinFunc[] array above\n** to the global function hash table.  This occurs at start-time (as\n** a consequence of calling sqlite3_initialize()).\n**\n** After this routine runs\n*/\nSQLITE_PRIVATE void sqlite3RegisterGlobalFunctions(void){\n  /*\n  ** The following array holds FuncDef structures for all of the functions\n  ** defined in this file.\n  **\n  ** The array cannot be constant since changes are made to the\n  ** FuncDef.pHash elements at start-time.  The elements of this array\n  ** are read-only after initialization is complete.\n  */\n  static SQLITE_WSD FuncDef aBuiltinFunc[] = {\n    FUNCTION(ltrim,              1, 1, 0, trimFunc         ),\n    FUNCTION(ltrim,              2, 1, 0, trimFunc         ),\n    FUNCTION(rtrim,              1, 2, 0, trimFunc         ),\n    FUNCTION(rtrim,              2, 2, 0, trimFunc         ),\n    FUNCTION(trim,               1, 3, 0, trimFunc         ),\n    FUNCTION(trim,               2, 3, 0, trimFunc         ),\n    FUNCTION(min,               -1, 0, 1, minmaxFunc       ),\n    FUNCTION(min,                0, 0, 1, 0                ),\n    AGGREGATE(min,               1, 0, 1, minmaxStep,      minMaxFinalize ),\n    FUNCTION(max,               -1, 1, 1, minmaxFunc       ),\n    FUNCTION(max,                0, 1, 1, 0                ),\n    AGGREGATE(max,               1, 1, 1, minmaxStep,      minMaxFinalize ),\n    FUNCTION(typeof,             1, 0, 0, typeofFunc       ),\n    FUNCTION(length,             1, 0, 0, lengthFunc       ),\n    FUNCTION(substr,             2, 0, 0, substrFunc       ),\n    FUNCTION(substr,             3, 0, 0, substrFunc       ),\n    FUNCTION(abs,                1, 0, 0, absFunc          ),\n#ifndef SQLITE_OMIT_FLOATING_POINT\n    FUNCTION(round,              1, 0, 0, roundFunc        ),\n    FUNCTION(round,              2, 0, 0, roundFunc        ),\n#endif\n    FUNCTION(upper,              1, 0, 0, upperFunc        ),\n    FUNCTION(lower,              1, 0, 0, lowerFunc        ),\n    FUNCTION(coalesce,           1, 0, 0, 0                ),\n    FUNCTION(coalesce,           0, 0, 0, 0                ),\n/*  FUNCTION(coalesce,          -1, 0, 0, ifnullFunc       ), */\n    {-1,SQLITE_UTF8,SQLITE_FUNC_COALESCE,0,0,ifnullFunc,0,0,\"coalesce\",0,0},\n    FUNCTION(hex,                1, 0, 0, hexFunc          ),\n/*  FUNCTION(ifnull,             2, 0, 0, ifnullFunc       ), */\n    {2,SQLITE_UTF8,SQLITE_FUNC_COALESCE,0,0,ifnullFunc,0,0,\"ifnull\",0,0},\n    FUNCTION(random,             0, 0, 0, randomFunc       ),\n    FUNCTION(randomblob,         1, 0, 0, randomBlob       ),\n    FUNCTION(nullif,             2, 0, 1, nullifFunc       ),\n    FUNCTION(sqlite_version,     0, 0, 0, versionFunc      ),\n    FUNCTION(sqlite_source_id,   0, 0, 0, sourceidFunc     ),\n#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS\n    FUNCTION(sqlite_compileoption_used,1, 0, 0, compileoptionusedFunc  ),\n    FUNCTION(sqlite_compileoption_get, 1, 0, 0, compileoptiongetFunc  ),\n#endif /* SQLITE_OMIT_COMPILEOPTION_DIAGS */\n    FUNCTION(quote,              1, 0, 0, quoteFunc        ),\n    FUNCTION(last_insert_rowid,  0, 0, 0, last_insert_rowid),\n    FUNCTION(changes,            0, 0, 0, changes          ),\n    FUNCTION(total_changes,      0, 0, 0, total_changes    ),\n    FUNCTION(replace,            3, 0, 0, replaceFunc      ),\n    FUNCTION(zeroblob,           1, 0, 0, zeroblobFunc     ),\n  #ifdef SQLITE_SOUNDEX\n    FUNCTION(soundex,            1, 0, 0, soundexFunc      ),\n  #endif\n  #ifndef SQLITE_OMIT_LOAD_EXTENSION\n    FUNCTION(load_extension,     1, 0, 0, loadExt          ),\n    FUNCTION(load_extension,     2, 0, 0, loadExt          ),\n  #endif\n    AGGREGATE(sum,               1, 0, 0, sumStep,         sumFinalize    ),\n    AGGREGATE(total,             1, 0, 0, sumStep,         totalFinalize    ),\n    AGGREGATE(avg,               1, 0, 0, sumStep,         avgFinalize    ),\n /* AGGREGATE(count,             0, 0, 0, countStep,       countFinalize  ), */\n    {0,SQLITE_UTF8,SQLITE_FUNC_COUNT,0,0,0,countStep,countFinalize,\"count\",0,0},\n    AGGREGATE(count,             1, 0, 0, countStep,       countFinalize  ),\n    AGGREGATE(group_concat,      1, 0, 0, groupConcatStep, groupConcatFinalize),\n    AGGREGATE(group_concat,      2, 0, 0, groupConcatStep, groupConcatFinalize),\n  \n    LIKEFUNC(glob, 2, &globInfo, SQLITE_FUNC_LIKE|SQLITE_FUNC_CASE),\n  #ifdef SQLITE_CASE_SENSITIVE_LIKE\n    LIKEFUNC(like, 2, &likeInfoAlt, SQLITE_FUNC_LIKE|SQLITE_FUNC_CASE),\n    LIKEFUNC(like, 3, &likeInfoAlt, SQLITE_FUNC_LIKE|SQLITE_FUNC_CASE),\n  #else\n    LIKEFUNC(like, 2, &likeInfoNorm, SQLITE_FUNC_LIKE),\n    LIKEFUNC(like, 3, &likeInfoNorm, SQLITE_FUNC_LIKE),\n  #endif\n  };\n\n  int i;\n  FuncDefHash *pHash = &GLOBAL(FuncDefHash, sqlite3GlobalFunctions);\n  FuncDef *aFunc = (FuncDef*)&GLOBAL(FuncDef, aBuiltinFunc);\n\n  for(i=0; i<ArraySize(aBuiltinFunc); i++){\n    sqlite3FuncDefInsert(pHash, &aFunc[i]);\n  }\n  sqlite3RegisterDateTimeFunctions();\n#ifndef SQLITE_OMIT_ALTERTABLE\n  sqlite3AlterFunctions();\n#endif\n}\n\n/************** End of func.c ************************************************/\n/************** Begin file fkey.c ********************************************/\n/*\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains code used by the compiler to add foreign key\n** support to compiled SQL statements.\n*/\n\n#ifndef SQLITE_OMIT_FOREIGN_KEY\n#ifndef SQLITE_OMIT_TRIGGER\n\n/*\n** Deferred and Immediate FKs\n** --------------------------\n**\n** Foreign keys in SQLite come in two flavours: deferred and immediate.\n** If an immediate foreign key constraint is violated, SQLITE_CONSTRAINT\n** is returned and the current statement transaction rolled back. If a \n** deferred foreign key constraint is violated, no action is taken \n** immediately. However if the application attempts to commit the \n** transaction before fixing the constraint violation, the attempt fails.\n**\n** Deferred constraints are implemented using a simple counter associated\n** with the database handle. The counter is set to zero each time a \n** database transaction is opened. Each time a statement is executed \n** that causes a foreign key violation, the counter is incremented. Each\n** time a statement is executed that removes an existing violation from\n** the database, the counter is decremented. When the transaction is\n** committed, the commit fails if the current value of the counter is\n** greater than zero. This scheme has two big drawbacks:\n**\n**   * When a commit fails due to a deferred foreign key constraint, \n**     there is no way to tell which foreign constraint is not satisfied,\n**     or which row it is not satisfied for.\n**\n**   * If the database contains foreign key violations when the \n**     transaction is opened, this may cause the mechanism to malfunction.\n**\n** Despite these problems, this approach is adopted as it seems simpler\n** than the alternatives.\n**\n** INSERT operations:\n**\n**   I.1) For each FK for which the table is the child table, search\n**        the parent table for a match. If none is found increment the\n**        constraint counter.\n**\n**   I.2) For each FK for which the table is the parent table, \n**        search the child table for rows that correspond to the new\n**        row in the parent table. Decrement the counter for each row\n**        found (as the constraint is now satisfied).\n**\n** DELETE operations:\n**\n**   D.1) For each FK for which the table is the child table, \n**        search the parent table for a row that corresponds to the \n**        deleted row in the child table. If such a row is not found, \n**        decrement the counter.\n**\n**   D.2) For each FK for which the table is the parent table, search \n**        the child table for rows that correspond to the deleted row \n**        in the parent table. For each found increment the counter.\n**\n** UPDATE operations:\n**\n**   An UPDATE command requires that all 4 steps above are taken, but only\n**   for FK constraints for which the affected columns are actually \n**   modified (values must be compared at runtime).\n**\n** Note that I.1 and D.1 are very similar operations, as are I.2 and D.2.\n** This simplifies the implementation a bit.\n**\n** For the purposes of immediate FK constraints, the OR REPLACE conflict\n** resolution is considered to delete rows before the new row is inserted.\n** If a delete caused by OR REPLACE violates an FK constraint, an exception\n** is thrown, even if the FK constraint would be satisfied after the new \n** row is inserted.\n**\n** Immediate constraints are usually handled similarly. The only difference \n** is that the counter used is stored as part of each individual statement\n** object (struct Vdbe). If, after the statement has run, its immediate\n** constraint counter is greater than zero, it returns SQLITE_CONSTRAINT\n** and the statement transaction is rolled back. An exception is an INSERT\n** statement that inserts a single row only (no triggers). In this case,\n** instead of using a counter, an exception is thrown immediately if the\n** INSERT violates a foreign key constraint. This is necessary as such\n** an INSERT does not open a statement transaction.\n**\n** TODO: How should dropping a table be handled? How should renaming a \n** table be handled?\n**\n**\n** Query API Notes\n** ---------------\n**\n** Before coding an UPDATE or DELETE row operation, the code-generator\n** for those two operations needs to know whether or not the operation\n** requires any FK processing and, if so, which columns of the original\n** row are required by the FK processing VDBE code (i.e. if FKs were\n** implemented using triggers, which of the old.* columns would be \n** accessed). No information is required by the code-generator before\n** coding an INSERT operation. The functions used by the UPDATE/DELETE\n** generation code to query for this information are:\n**\n**   sqlite3FkRequired() - Test to see if FK processing is required.\n**   sqlite3FkOldmask()  - Query for the set of required old.* columns.\n**\n**\n** Externally accessible module functions\n** --------------------------------------\n**\n**   sqlite3FkCheck()    - Check for foreign key violations.\n**   sqlite3FkActions()  - Code triggers for ON UPDATE/ON DELETE actions.\n**   sqlite3FkDelete()   - Delete an FKey structure.\n*/\n\n/*\n** VDBE Calling Convention\n** -----------------------\n**\n** Example:\n**\n**   For the following INSERT statement:\n**\n**     CREATE TABLE t1(a, b INTEGER PRIMARY KEY, c);\n**     INSERT INTO t1 VALUES(1, 2, 3.1);\n**\n**   Register (x):        2    (type integer)\n**   Register (x+1):      1    (type integer)\n**   Register (x+2):      NULL (type NULL)\n**   Register (x+3):      3.1  (type real)\n*/\n\n/*\n** A foreign key constraint requires that the key columns in the parent\n** table are collectively subject to a UNIQUE or PRIMARY KEY constraint.\n** Given that pParent is the parent table for foreign key constraint pFKey, \n** search the schema a unique index on the parent key columns. \n**\n** If successful, zero is returned. If the parent key is an INTEGER PRIMARY \n** KEY column, then output variable *ppIdx is set to NULL. Otherwise, *ppIdx \n** is set to point to the unique index. \n** \n** If the parent key consists of a single column (the foreign key constraint\n** is not a composite foreign key), output variable *paiCol is set to NULL.\n** Otherwise, it is set to point to an allocated array of size N, where\n** N is the number of columns in the parent key. The first element of the\n** array is the index of the child table column that is mapped by the FK\n** constraint to the parent table column stored in the left-most column\n** of index *ppIdx. The second element of the array is the index of the\n** child table column that corresponds to the second left-most column of\n** *ppIdx, and so on.\n**\n** If the required index cannot be found, either because:\n**\n**   1) The named parent key columns do not exist, or\n**\n**   2) The named parent key columns do exist, but are not subject to a\n**      UNIQUE or PRIMARY KEY constraint, or\n**\n**   3) No parent key columns were provided explicitly as part of the\n**      foreign key definition, and the parent table does not have a\n**      PRIMARY KEY, or\n**\n**   4) No parent key columns were provided explicitly as part of the\n**      foreign key definition, and the PRIMARY KEY of the parent table \n**      consists of a a different number of columns to the child key in \n**      the child table.\n**\n** then non-zero is returned, and a \"foreign key mismatch\" error loaded\n** into pParse. If an OOM error occurs, non-zero is returned and the\n** pParse->db->mallocFailed flag is set.\n*/\nstatic int locateFkeyIndex(\n  Parse *pParse,                  /* Parse context to store any error in */\n  Table *pParent,                 /* Parent table of FK constraint pFKey */\n  FKey *pFKey,                    /* Foreign key to find index for */\n  Index **ppIdx,                  /* OUT: Unique index on parent table */\n  int **paiCol                    /* OUT: Map of index columns in pFKey */\n){\n  Index *pIdx = 0;                    /* Value to return via *ppIdx */\n  int *aiCol = 0;                     /* Value to return via *paiCol */\n  int nCol = pFKey->nCol;             /* Number of columns in parent key */\n  char *zKey = pFKey->aCol[0].zCol;   /* Name of left-most parent key column */\n\n  /* The caller is responsible for zeroing output parameters. */\n  assert( ppIdx && *ppIdx==0 );\n  assert( !paiCol || *paiCol==0 );\n  assert( pParse );\n\n  /* If this is a non-composite (single column) foreign key, check if it \n  ** maps to the INTEGER PRIMARY KEY of table pParent. If so, leave *ppIdx \n  ** and *paiCol set to zero and return early. \n  **\n  ** Otherwise, for a composite foreign key (more than one column), allocate\n  ** space for the aiCol array (returned via output parameter *paiCol).\n  ** Non-composite foreign keys do not require the aiCol array.\n  */\n  if( nCol==1 ){\n    /* The FK maps to the IPK if any of the following are true:\n    **\n    **   1) There is an INTEGER PRIMARY KEY column and the FK is implicitly \n    **      mapped to the primary key of table pParent, or\n    **   2) The FK is explicitly mapped to a column declared as INTEGER\n    **      PRIMARY KEY.\n    */\n    if( pParent->iPKey>=0 ){\n      if( !zKey ) return 0;\n      if( !sqlite3StrICmp(pParent->aCol[pParent->iPKey].zName, zKey) ) return 0;\n    }\n  }else if( paiCol ){\n    assert( nCol>1 );\n    aiCol = (int *)sqlite3DbMallocRaw(pParse->db, nCol*sizeof(int));\n    if( !aiCol ) return 1;\n    *paiCol = aiCol;\n  }\n\n  for(pIdx=pParent->pIndex; pIdx; pIdx=pIdx->pNext){\n    if( pIdx->nColumn==nCol && pIdx->onError!=OE_None ){ \n      /* pIdx is a UNIQUE index (or a PRIMARY KEY) and has the right number\n      ** of columns. If each indexed column corresponds to a foreign key\n      ** column of pFKey, then this index is a winner.  */\n\n      if( zKey==0 ){\n        /* If zKey is NULL, then this foreign key is implicitly mapped to \n        ** the PRIMARY KEY of table pParent. The PRIMARY KEY index may be \n        ** identified by the test (Index.autoIndex==2).  */\n        if( pIdx->autoIndex==2 ){\n          if( aiCol ){\n            int i;\n            for(i=0; i<nCol; i++) aiCol[i] = pFKey->aCol[i].iFrom;\n          }\n          break;\n        }\n      }else{\n        /* If zKey is non-NULL, then this foreign key was declared to\n        ** map to an explicit list of columns in table pParent. Check if this\n        ** index matches those columns. Also, check that the index uses\n        ** the default collation sequences for each column. */\n        int i, j;\n        for(i=0; i<nCol; i++){\n          int iCol = pIdx->aiColumn[i];     /* Index of column in parent tbl */\n          char *zDfltColl;                  /* Def. collation for column */\n          char *zIdxCol;                    /* Name of indexed column */\n\n          /* If the index uses a collation sequence that is different from\n          ** the default collation sequence for the column, this index is\n          ** unusable. Bail out early in this case.  */\n          zDfltColl = pParent->aCol[iCol].zColl;\n          if( !zDfltColl ){\n            zDfltColl = \"BINARY\";\n          }\n          if( sqlite3StrICmp(pIdx->azColl[i], zDfltColl) ) break;\n\n          zIdxCol = pParent->aCol[iCol].zName;\n          for(j=0; j<nCol; j++){\n            if( sqlite3StrICmp(pFKey->aCol[j].zCol, zIdxCol)==0 ){\n              if( aiCol ) aiCol[i] = pFKey->aCol[j].iFrom;\n              break;\n            }\n          }\n          if( j==nCol ) break;\n        }\n        if( i==nCol ) break;      /* pIdx is usable */\n      }\n    }\n  }\n\n  if( !pIdx ){\n    if( !pParse->disableTriggers ){\n      sqlite3ErrorMsg(pParse, \"foreign key mismatch\");\n    }\n    sqlite3DbFree(pParse->db, aiCol);\n    return 1;\n  }\n\n  *ppIdx = pIdx;\n  return 0;\n}\n\n/*\n** This function is called when a row is inserted into or deleted from the \n** child table of foreign key constraint pFKey. If an SQL UPDATE is executed \n** on the child table of pFKey, this function is invoked twice for each row\n** affected - once to \"delete\" the old row, and then again to \"insert\" the\n** new row.\n**\n** Each time it is called, this function generates VDBE code to locate the\n** row in the parent table that corresponds to the row being inserted into \n** or deleted from the child table. If the parent row can be found, no \n** special action is taken. Otherwise, if the parent row can *not* be\n** found in the parent table:\n**\n**   Operation | FK type   | Action taken\n**   --------------------------------------------------------------------------\n**   INSERT      immediate   Increment the \"immediate constraint counter\".\n**\n**   DELETE      immediate   Decrement the \"immediate constraint counter\".\n**\n**   INSERT      deferred    Increment the \"deferred constraint counter\".\n**\n**   DELETE      deferred    Decrement the \"deferred constraint counter\".\n**\n** These operations are identified in the comment at the top of this file \n** (fkey.c) as \"I.1\" and \"D.1\".\n*/\nstatic void fkLookupParent(\n  Parse *pParse,        /* Parse context */\n  int iDb,              /* Index of database housing pTab */\n  Table *pTab,          /* Parent table of FK pFKey */\n  Index *pIdx,          /* Unique index on parent key columns in pTab */\n  FKey *pFKey,          /* Foreign key constraint */\n  int *aiCol,           /* Map from parent key columns to child table columns */\n  int regData,          /* Address of array containing child table row */\n  int nIncr,            /* Increment constraint counter by this */\n  int isIgnore          /* If true, pretend pTab contains all NULL values */\n){\n  int i;                                    /* Iterator variable */\n  Vdbe *v = sqlite3GetVdbe(pParse);         /* Vdbe to add code to */\n  int iCur = pParse->nTab - 1;              /* Cursor number to use */\n  int iOk = sqlite3VdbeMakeLabel(v);        /* jump here if parent key found */\n\n  /* If nIncr is less than zero, then check at runtime if there are any\n  ** outstanding constraints to resolve. If there are not, there is no need\n  ** to check if deleting this row resolves any outstanding violations.\n  **\n  ** Check if any of the key columns in the child table row are NULL. If \n  ** any are, then the constraint is considered satisfied. No need to \n  ** search for a matching row in the parent table.  */\n  if( nIncr<0 ){\n    sqlite3VdbeAddOp2(v, OP_FkIfZero, pFKey->isDeferred, iOk);\n  }\n  for(i=0; i<pFKey->nCol; i++){\n    int iReg = aiCol[i] + regData + 1;\n    sqlite3VdbeAddOp2(v, OP_IsNull, iReg, iOk);\n  }\n\n  if( isIgnore==0 ){\n    if( pIdx==0 ){\n      /* If pIdx is NULL, then the parent key is the INTEGER PRIMARY KEY\n      ** column of the parent table (table pTab).  */\n      int iMustBeInt;               /* Address of MustBeInt instruction */\n      int regTemp = sqlite3GetTempReg(pParse);\n  \n      /* Invoke MustBeInt to coerce the child key value to an integer (i.e. \n      ** apply the affinity of the parent key). If this fails, then there\n      ** is no matching parent key. Before using MustBeInt, make a copy of\n      ** the value. Otherwise, the value inserted into the child key column\n      ** will have INTEGER affinity applied to it, which may not be correct.  */\n      sqlite3VdbeAddOp2(v, OP_SCopy, aiCol[0]+1+regData, regTemp);\n      iMustBeInt = sqlite3VdbeAddOp2(v, OP_MustBeInt, regTemp, 0);\n  \n      /* If the parent table is the same as the child table, and we are about\n      ** to increment the constraint-counter (i.e. this is an INSERT operation),\n      ** then check if the row being inserted matches itself. If so, do not\n      ** increment the constraint-counter.  */\n      if( pTab==pFKey->pFrom && nIncr==1 ){\n        sqlite3VdbeAddOp3(v, OP_Eq, regData, iOk, regTemp);\n      }\n  \n      sqlite3OpenTable(pParse, iCur, iDb, pTab, OP_OpenRead);\n      sqlite3VdbeAddOp3(v, OP_NotExists, iCur, 0, regTemp);\n      sqlite3VdbeAddOp2(v, OP_Goto, 0, iOk);\n      sqlite3VdbeJumpHere(v, sqlite3VdbeCurrentAddr(v)-2);\n      sqlite3VdbeJumpHere(v, iMustBeInt);\n      sqlite3ReleaseTempReg(pParse, regTemp);\n    }else{\n      int nCol = pFKey->nCol;\n      int regTemp = sqlite3GetTempRange(pParse, nCol);\n      int regRec = sqlite3GetTempReg(pParse);\n      KeyInfo *pKey = sqlite3IndexKeyinfo(pParse, pIdx);\n  \n      sqlite3VdbeAddOp3(v, OP_OpenRead, iCur, pIdx->tnum, iDb);\n      sqlite3VdbeChangeP4(v, -1, (char*)pKey, P4_KEYINFO_HANDOFF);\n      for(i=0; i<nCol; i++){\n        sqlite3VdbeAddOp2(v, OP_Copy, aiCol[i]+1+regData, regTemp+i);\n      }\n  \n      /* If the parent table is the same as the child table, and we are about\n      ** to increment the constraint-counter (i.e. this is an INSERT operation),\n      ** then check if the row being inserted matches itself. If so, do not\n      ** increment the constraint-counter.  */\n      if( pTab==pFKey->pFrom && nIncr==1 ){\n        int iJump = sqlite3VdbeCurrentAddr(v) + nCol + 1;\n        for(i=0; i<nCol; i++){\n          int iChild = aiCol[i]+1+regData;\n          int iParent = pIdx->aiColumn[i]+1+regData;\n          sqlite3VdbeAddOp3(v, OP_Ne, iChild, iJump, iParent);\n        }\n        sqlite3VdbeAddOp2(v, OP_Goto, 0, iOk);\n      }\n  \n      sqlite3VdbeAddOp3(v, OP_MakeRecord, regTemp, nCol, regRec);\n      sqlite3VdbeChangeP4(v, -1, sqlite3IndexAffinityStr(v, pIdx), 0);\n      sqlite3VdbeAddOp4Int(v, OP_Found, iCur, iOk, regRec, 0);\n  \n      sqlite3ReleaseTempReg(pParse, regRec);\n      sqlite3ReleaseTempRange(pParse, regTemp, nCol);\n    }\n  }\n\n  if( !pFKey->isDeferred && !pParse->pToplevel && !pParse->isMultiWrite ){\n    /* Special case: If this is an INSERT statement that will insert exactly\n    ** one row into the table, raise a constraint immediately instead of\n    ** incrementing a counter. This is necessary as the VM code is being\n    ** generated for will not open a statement transaction.  */\n    assert( nIncr==1 );\n    sqlite3HaltConstraint(\n        pParse, OE_Abort, \"foreign key constraint failed\", P4_STATIC\n    );\n  }else{\n    if( nIncr>0 && pFKey->isDeferred==0 ){\n      sqlite3ParseToplevel(pParse)->mayAbort = 1;\n    }\n    sqlite3VdbeAddOp2(v, OP_FkCounter, pFKey->isDeferred, nIncr);\n  }\n\n  sqlite3VdbeResolveLabel(v, iOk);\n  sqlite3VdbeAddOp1(v, OP_Close, iCur);\n}\n\n/*\n** This function is called to generate code executed when a row is deleted\n** from the parent table of foreign key constraint pFKey and, if pFKey is \n** deferred, when a row is inserted into the same table. When generating\n** code for an SQL UPDATE operation, this function may be called twice -\n** once to \"delete\" the old row and once to \"insert\" the new row.\n**\n** The code generated by this function scans through the rows in the child\n** table that correspond to the parent table row being deleted or inserted.\n** For each child row found, one of the following actions is taken:\n**\n**   Operation | FK type   | Action taken\n**   --------------------------------------------------------------------------\n**   DELETE      immediate   Increment the \"immediate constraint counter\".\n**                           Or, if the ON (UPDATE|DELETE) action is RESTRICT,\n**                           throw a \"foreign key constraint failed\" exception.\n**\n**   INSERT      immediate   Decrement the \"immediate constraint counter\".\n**\n**   DELETE      deferred    Increment the \"deferred constraint counter\".\n**                           Or, if the ON (UPDATE|DELETE) action is RESTRICT,\n**                           throw a \"foreign key constraint failed\" exception.\n**\n**   INSERT      deferred    Decrement the \"deferred constraint counter\".\n**\n** These operations are identified in the comment at the top of this file \n** (fkey.c) as \"I.2\" and \"D.2\".\n*/\nstatic void fkScanChildren(\n  Parse *pParse,                  /* Parse context */\n  SrcList *pSrc,                  /* SrcList containing the table to scan */\n  Table *pTab,\n  Index *pIdx,                    /* Foreign key index */\n  FKey *pFKey,                    /* Foreign key relationship */\n  int *aiCol,                     /* Map from pIdx cols to child table cols */\n  int regData,                    /* Referenced table data starts here */\n  int nIncr                       /* Amount to increment deferred counter by */\n){\n  sqlite3 *db = pParse->db;       /* Database handle */\n  int i;                          /* Iterator variable */\n  Expr *pWhere = 0;               /* WHERE clause to scan with */\n  NameContext sNameContext;       /* Context used to resolve WHERE clause */\n  WhereInfo *pWInfo;              /* Context used by sqlite3WhereXXX() */\n  int iFkIfZero = 0;              /* Address of OP_FkIfZero */\n  Vdbe *v = sqlite3GetVdbe(pParse);\n\n  assert( !pIdx || pIdx->pTable==pTab );\n\n  if( nIncr<0 ){\n    iFkIfZero = sqlite3VdbeAddOp2(v, OP_FkIfZero, pFKey->isDeferred, 0);\n  }\n\n  /* Create an Expr object representing an SQL expression like:\n  **\n  **   <parent-key1> = <child-key1> AND <parent-key2> = <child-key2> ...\n  **\n  ** The collation sequence used for the comparison should be that of\n  ** the parent key columns. The affinity of the parent key column should\n  ** be applied to each child key value before the comparison takes place.\n  */\n  for(i=0; i<pFKey->nCol; i++){\n    Expr *pLeft;                  /* Value from parent table row */\n    Expr *pRight;                 /* Column ref to child table */\n    Expr *pEq;                    /* Expression (pLeft = pRight) */\n    int iCol;                     /* Index of column in child table */ \n    const char *zCol;             /* Name of column in child table */\n\n    pLeft = sqlite3Expr(db, TK_REGISTER, 0);\n    if( pLeft ){\n      /* Set the collation sequence and affinity of the LHS of each TK_EQ\n      ** expression to the parent key column defaults.  */\n      if( pIdx ){\n        Column *pCol;\n        iCol = pIdx->aiColumn[i];\n        pCol = &pTab->aCol[iCol];\n        if( pTab->iPKey==iCol ) iCol = -1;\n        pLeft->iTable = regData+iCol+1;\n        pLeft->affinity = pCol->affinity;\n        pLeft->pColl = sqlite3LocateCollSeq(pParse, pCol->zColl);\n      }else{\n        pLeft->iTable = regData;\n        pLeft->affinity = SQLITE_AFF_INTEGER;\n      }\n    }\n    iCol = aiCol ? aiCol[i] : pFKey->aCol[0].iFrom;\n    assert( iCol>=0 );\n    zCol = pFKey->pFrom->aCol[iCol].zName;\n    pRight = sqlite3Expr(db, TK_ID, zCol);\n    pEq = sqlite3PExpr(pParse, TK_EQ, pLeft, pRight, 0);\n    pWhere = sqlite3ExprAnd(db, pWhere, pEq);\n  }\n\n  /* If the child table is the same as the parent table, and this scan\n  ** is taking place as part of a DELETE operation (operation D.2), omit the\n  ** row being deleted from the scan by adding ($rowid != rowid) to the WHERE \n  ** clause, where $rowid is the rowid of the row being deleted.  */\n  if( pTab==pFKey->pFrom && nIncr>0 ){\n    Expr *pEq;                    /* Expression (pLeft = pRight) */\n    Expr *pLeft;                  /* Value from parent table row */\n    Expr *pRight;                 /* Column ref to child table */\n    pLeft = sqlite3Expr(db, TK_REGISTER, 0);\n    pRight = sqlite3Expr(db, TK_COLUMN, 0);\n    if( pLeft && pRight ){\n      pLeft->iTable = regData;\n      pLeft->affinity = SQLITE_AFF_INTEGER;\n      pRight->iTable = pSrc->a[0].iCursor;\n      pRight->iColumn = -1;\n    }\n    pEq = sqlite3PExpr(pParse, TK_NE, pLeft, pRight, 0);\n    pWhere = sqlite3ExprAnd(db, pWhere, pEq);\n  }\n\n  /* Resolve the references in the WHERE clause. */\n  memset(&sNameContext, 0, sizeof(NameContext));\n  sNameContext.pSrcList = pSrc;\n  sNameContext.pParse = pParse;\n  sqlite3ResolveExprNames(&sNameContext, pWhere);\n\n  /* Create VDBE to loop through the entries in pSrc that match the WHERE\n  ** clause. If the constraint is not deferred, throw an exception for\n  ** each row found. Otherwise, for deferred constraints, increment the\n  ** deferred constraint counter by nIncr for each row selected.  */\n  pWInfo = sqlite3WhereBegin(pParse, pSrc, pWhere, 0, 0);\n  if( nIncr>0 && pFKey->isDeferred==0 ){\n    sqlite3ParseToplevel(pParse)->mayAbort = 1;\n  }\n  sqlite3VdbeAddOp2(v, OP_FkCounter, pFKey->isDeferred, nIncr);\n  if( pWInfo ){\n    sqlite3WhereEnd(pWInfo);\n  }\n\n  /* Clean up the WHERE clause constructed above. */\n  sqlite3ExprDelete(db, pWhere);\n  if( iFkIfZero ){\n    sqlite3VdbeJumpHere(v, iFkIfZero);\n  }\n}\n\n/*\n** This function returns a pointer to the head of a linked list of FK\n** constraints for which table pTab is the parent table. For example,\n** given the following schema:\n**\n**   CREATE TABLE t1(a PRIMARY KEY);\n**   CREATE TABLE t2(b REFERENCES t1(a);\n**\n** Calling this function with table \"t1\" as an argument returns a pointer\n** to the FKey structure representing the foreign key constraint on table\n** \"t2\". Calling this function with \"t2\" as the argument would return a\n** NULL pointer (as there are no FK constraints for which t2 is the parent\n** table).\n*/\nSQLITE_PRIVATE FKey *sqlite3FkReferences(Table *pTab){\n  int nName = sqlite3Strlen30(pTab->zName);\n  return (FKey *)sqlite3HashFind(&pTab->pSchema->fkeyHash, pTab->zName, nName);\n}\n\n/*\n** The second argument is a Trigger structure allocated by the \n** fkActionTrigger() routine. This function deletes the Trigger structure\n** and all of its sub-components.\n**\n** The Trigger structure or any of its sub-components may be allocated from\n** the lookaside buffer belonging to database handle dbMem.\n*/\nstatic void fkTriggerDelete(sqlite3 *dbMem, Trigger *p){\n  if( p ){\n    TriggerStep *pStep = p->step_list;\n    sqlite3ExprDelete(dbMem, pStep->pWhere);\n    sqlite3ExprListDelete(dbMem, pStep->pExprList);\n    sqlite3SelectDelete(dbMem, pStep->pSelect);\n    sqlite3ExprDelete(dbMem, p->pWhen);\n    sqlite3DbFree(dbMem, p);\n  }\n}\n\n/*\n** This function is called to generate code that runs when table pTab is\n** being dropped from the database. The SrcList passed as the second argument\n** to this function contains a single entry guaranteed to resolve to\n** table pTab.\n**\n** Normally, no code is required. However, if either\n**\n**   (a) The table is the parent table of a FK constraint, or\n**   (b) The table is the child table of a deferred FK constraint and it is\n**       determined at runtime that there are outstanding deferred FK \n**       constraint violations in the database,\n**\n** then the equivalent of \"DELETE FROM <tbl>\" is executed before dropping\n** the table from the database. Triggers are disabled while running this\n** DELETE, but foreign key actions are not.\n*/\nSQLITE_PRIVATE void sqlite3FkDropTable(Parse *pParse, SrcList *pName, Table *pTab){\n  sqlite3 *db = pParse->db;\n  if( (db->flags&SQLITE_ForeignKeys) && !IsVirtual(pTab) && !pTab->pSelect ){\n    int iSkip = 0;\n    Vdbe *v = sqlite3GetVdbe(pParse);\n\n    assert( v );                  /* VDBE has already been allocated */\n    if( sqlite3FkReferences(pTab)==0 ){\n      /* Search for a deferred foreign key constraint for which this table\n      ** is the child table. If one cannot be found, return without \n      ** generating any VDBE code. If one can be found, then jump over\n      ** the entire DELETE if there are no outstanding deferred constraints\n      ** when this statement is run.  */\n      FKey *p;\n      for(p=pTab->pFKey; p; p=p->pNextFrom){\n        if( p->isDeferred ) break;\n      }\n      if( !p ) return;\n      iSkip = sqlite3VdbeMakeLabel(v);\n      sqlite3VdbeAddOp2(v, OP_FkIfZero, 1, iSkip);\n    }\n\n    pParse->disableTriggers = 1;\n    sqlite3DeleteFrom(pParse, sqlite3SrcListDup(db, pName, 0), 0);\n    pParse->disableTriggers = 0;\n\n    /* If the DELETE has generated immediate foreign key constraint \n    ** violations, halt the VDBE and return an error at this point, before\n    ** any modifications to the schema are made. This is because statement\n    ** transactions are not able to rollback schema changes.  */\n    sqlite3VdbeAddOp2(v, OP_FkIfZero, 0, sqlite3VdbeCurrentAddr(v)+2);\n    sqlite3HaltConstraint(\n        pParse, OE_Abort, \"foreign key constraint failed\", P4_STATIC\n    );\n\n    if( iSkip ){\n      sqlite3VdbeResolveLabel(v, iSkip);\n    }\n  }\n}\n\n/*\n** This function is called when inserting, deleting or updating a row of\n** table pTab to generate VDBE code to perform foreign key constraint \n** processing for the operation.\n**\n** For a DELETE operation, parameter regOld is passed the index of the\n** first register in an array of (pTab->nCol+1) registers containing the\n** rowid of the row being deleted, followed by each of the column values\n** of the row being deleted, from left to right. Parameter regNew is passed\n** zero in this case.\n**\n** For an INSERT operation, regOld is passed zero and regNew is passed the\n** first register of an array of (pTab->nCol+1) registers containing the new\n** row data.\n**\n** For an UPDATE operation, this function is called twice. Once before\n** the original record is deleted from the table using the calling convention\n** described for DELETE. Then again after the original record is deleted\n** but before the new record is inserted using the INSERT convention. \n*/\nSQLITE_PRIVATE void sqlite3FkCheck(\n  Parse *pParse,                  /* Parse context */\n  Table *pTab,                    /* Row is being deleted from this table */ \n  int regOld,                     /* Previous row data is stored here */\n  int regNew                      /* New row data is stored here */\n){\n  sqlite3 *db = pParse->db;       /* Database handle */\n  FKey *pFKey;                    /* Used to iterate through FKs */\n  int iDb;                        /* Index of database containing pTab */\n  const char *zDb;                /* Name of database containing pTab */\n  int isIgnoreErrors = pParse->disableTriggers;\n\n  /* Exactly one of regOld and regNew should be non-zero. */\n  assert( (regOld==0)!=(regNew==0) );\n\n  /* If foreign-keys are disabled, this function is a no-op. */\n  if( (db->flags&SQLITE_ForeignKeys)==0 ) return;\n\n  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n  zDb = db->aDb[iDb].zName;\n\n  /* Loop through all the foreign key constraints for which pTab is the\n  ** child table (the table that the foreign key definition is part of).  */\n  for(pFKey=pTab->pFKey; pFKey; pFKey=pFKey->pNextFrom){\n    Table *pTo;                   /* Parent table of foreign key pFKey */\n    Index *pIdx = 0;              /* Index on key columns in pTo */\n    int *aiFree = 0;\n    int *aiCol;\n    int iCol;\n    int i;\n    int isIgnore = 0;\n\n    /* Find the parent table of this foreign key. Also find a unique index \n    ** on the parent key columns in the parent table. If either of these \n    ** schema items cannot be located, set an error in pParse and return \n    ** early.  */\n    if( pParse->disableTriggers ){\n      pTo = sqlite3FindTable(db, pFKey->zTo, zDb);\n    }else{\n      pTo = sqlite3LocateTable(pParse, 0, pFKey->zTo, zDb);\n    }\n    if( !pTo || locateFkeyIndex(pParse, pTo, pFKey, &pIdx, &aiFree) ){\n      if( !isIgnoreErrors || db->mallocFailed ) return;\n      continue;\n    }\n    assert( pFKey->nCol==1 || (aiFree && pIdx) );\n\n    if( aiFree ){\n      aiCol = aiFree;\n    }else{\n      iCol = pFKey->aCol[0].iFrom;\n      aiCol = &iCol;\n    }\n    for(i=0; i<pFKey->nCol; i++){\n      if( aiCol[i]==pTab->iPKey ){\n        aiCol[i] = -1;\n      }\n#ifndef SQLITE_OMIT_AUTHORIZATION\n      /* Request permission to read the parent key columns. If the \n      ** authorization callback returns SQLITE_IGNORE, behave as if any\n      ** values read from the parent table are NULL. */\n      if( db->xAuth ){\n        int rcauth;\n        char *zCol = pTo->aCol[pIdx ? pIdx->aiColumn[i] : pTo->iPKey].zName;\n        rcauth = sqlite3AuthReadCol(pParse, pTo->zName, zCol, iDb);\n        isIgnore = (rcauth==SQLITE_IGNORE);\n      }\n#endif\n    }\n\n    /* Take a shared-cache advisory read-lock on the parent table. Allocate \n    ** a cursor to use to search the unique index on the parent key columns \n    ** in the parent table.  */\n    sqlite3TableLock(pParse, iDb, pTo->tnum, 0, pTo->zName);\n    pParse->nTab++;\n\n    if( regOld!=0 ){\n      /* A row is being removed from the child table. Search for the parent.\n      ** If the parent does not exist, removing the child row resolves an \n      ** outstanding foreign key constraint violation. */\n      fkLookupParent(pParse, iDb, pTo, pIdx, pFKey, aiCol, regOld, -1,isIgnore);\n    }\n    if( regNew!=0 ){\n      /* A row is being added to the child table. If a parent row cannot\n      ** be found, adding the child row has violated the FK constraint. */ \n      fkLookupParent(pParse, iDb, pTo, pIdx, pFKey, aiCol, regNew, +1,isIgnore);\n    }\n\n    sqlite3DbFree(db, aiFree);\n  }\n\n  /* Loop through all the foreign key constraints that refer to this table */\n  for(pFKey = sqlite3FkReferences(pTab); pFKey; pFKey=pFKey->pNextTo){\n    Index *pIdx = 0;              /* Foreign key index for pFKey */\n    SrcList *pSrc;\n    int *aiCol = 0;\n\n    if( !pFKey->isDeferred && !pParse->pToplevel && !pParse->isMultiWrite ){\n      assert( regOld==0 && regNew!=0 );\n      /* Inserting a single row into a parent table cannot cause an immediate\n      ** foreign key violation. So do nothing in this case.  */\n      continue;\n    }\n\n    if( locateFkeyIndex(pParse, pTab, pFKey, &pIdx, &aiCol) ){\n      if( !isIgnoreErrors || db->mallocFailed ) return;\n      continue;\n    }\n    assert( aiCol || pFKey->nCol==1 );\n\n    /* Create a SrcList structure containing a single table (the table \n    ** the foreign key that refers to this table is attached to). This\n    ** is required for the sqlite3WhereXXX() interface.  */\n    pSrc = sqlite3SrcListAppend(db, 0, 0, 0);\n    if( pSrc ){\n      struct SrcList_item *pItem = pSrc->a;\n      pItem->pTab = pFKey->pFrom;\n      pItem->zName = pFKey->pFrom->zName;\n      pItem->pTab->nRef++;\n      pItem->iCursor = pParse->nTab++;\n  \n      if( regNew!=0 ){\n        fkScanChildren(pParse, pSrc, pTab, pIdx, pFKey, aiCol, regNew, -1);\n      }\n      if( regOld!=0 ){\n        /* If there is a RESTRICT action configured for the current operation\n        ** on the parent table of this FK, then throw an exception \n        ** immediately if the FK constraint is violated, even if this is a\n        ** deferred trigger. That's what RESTRICT means. To defer checking\n        ** the constraint, the FK should specify NO ACTION (represented\n        ** using OE_None). NO ACTION is the default.  */\n        fkScanChildren(pParse, pSrc, pTab, pIdx, pFKey, aiCol, regOld, 1);\n      }\n      pItem->zName = 0;\n      sqlite3SrcListDelete(db, pSrc);\n    }\n    sqlite3DbFree(db, aiCol);\n  }\n}\n\n#define COLUMN_MASK(x) (((x)>31) ? 0xffffffff : ((u32)1<<(x)))\n\n/*\n** This function is called before generating code to update or delete a \n** row contained in table pTab.\n*/\nSQLITE_PRIVATE u32 sqlite3FkOldmask(\n  Parse *pParse,                  /* Parse context */\n  Table *pTab                     /* Table being modified */\n){\n  u32 mask = 0;\n  if( pParse->db->flags&SQLITE_ForeignKeys ){\n    FKey *p;\n    int i;\n    for(p=pTab->pFKey; p; p=p->pNextFrom){\n      for(i=0; i<p->nCol; i++) mask |= COLUMN_MASK(p->aCol[i].iFrom);\n    }\n    for(p=sqlite3FkReferences(pTab); p; p=p->pNextTo){\n      Index *pIdx = 0;\n      locateFkeyIndex(pParse, pTab, p, &pIdx, 0);\n      if( pIdx ){\n        for(i=0; i<pIdx->nColumn; i++) mask |= COLUMN_MASK(pIdx->aiColumn[i]);\n      }\n    }\n  }\n  return mask;\n}\n\n/*\n** This function is called before generating code to update or delete a \n** row contained in table pTab. If the operation is a DELETE, then\n** parameter aChange is passed a NULL value. For an UPDATE, aChange points\n** to an array of size N, where N is the number of columns in table pTab.\n** If the i'th column is not modified by the UPDATE, then the corresponding \n** entry in the aChange[] array is set to -1. If the column is modified,\n** the value is 0 or greater. Parameter chngRowid is set to true if the\n** UPDATE statement modifies the rowid fields of the table.\n**\n** If any foreign key processing will be required, this function returns\n** true. If there is no foreign key related processing, this function \n** returns false.\n*/\nSQLITE_PRIVATE int sqlite3FkRequired(\n  Parse *pParse,                  /* Parse context */\n  Table *pTab,                    /* Table being modified */\n  int *aChange,                   /* Non-NULL for UPDATE operations */\n  int chngRowid                   /* True for UPDATE that affects rowid */\n){\n  if( pParse->db->flags&SQLITE_ForeignKeys ){\n    if( !aChange ){\n      /* A DELETE operation. Foreign key processing is required if the \n      ** table in question is either the child or parent table for any \n      ** foreign key constraint.  */\n      return (sqlite3FkReferences(pTab) || pTab->pFKey);\n    }else{\n      /* This is an UPDATE. Foreign key processing is only required if the\n      ** operation modifies one or more child or parent key columns. */\n      int i;\n      FKey *p;\n\n      /* Check if any child key columns are being modified. */\n      for(p=pTab->pFKey; p; p=p->pNextFrom){\n        for(i=0; i<p->nCol; i++){\n          int iChildKey = p->aCol[i].iFrom;\n          if( aChange[iChildKey]>=0 ) return 1;\n          if( iChildKey==pTab->iPKey && chngRowid ) return 1;\n        }\n      }\n\n      /* Check if any parent key columns are being modified. */\n      for(p=sqlite3FkReferences(pTab); p; p=p->pNextTo){\n        for(i=0; i<p->nCol; i++){\n          char *zKey = p->aCol[i].zCol;\n          int iKey;\n          for(iKey=0; iKey<pTab->nCol; iKey++){\n            Column *pCol = &pTab->aCol[iKey];\n            if( (zKey ? !sqlite3StrICmp(pCol->zName, zKey) : pCol->isPrimKey) ){\n              if( aChange[iKey]>=0 ) return 1;\n              if( iKey==pTab->iPKey && chngRowid ) return 1;\n            }\n          }\n        }\n      }\n    }\n  }\n  return 0;\n}\n\n/*\n** This function is called when an UPDATE or DELETE operation is being \n** compiled on table pTab, which is the parent table of foreign-key pFKey.\n** If the current operation is an UPDATE, then the pChanges parameter is\n** passed a pointer to the list of columns being modified. If it is a\n** DELETE, pChanges is passed a NULL pointer.\n**\n** It returns a pointer to a Trigger structure containing a trigger\n** equivalent to the ON UPDATE or ON DELETE action specified by pFKey.\n** If the action is \"NO ACTION\" or \"RESTRICT\", then a NULL pointer is\n** returned (these actions require no special handling by the triggers\n** sub-system, code for them is created by fkScanChildren()).\n**\n** For example, if pFKey is the foreign key and pTab is table \"p\" in \n** the following schema:\n**\n**   CREATE TABLE p(pk PRIMARY KEY);\n**   CREATE TABLE c(ck REFERENCES p ON DELETE CASCADE);\n**\n** then the returned trigger structure is equivalent to:\n**\n**   CREATE TRIGGER ... DELETE ON p BEGIN\n**     DELETE FROM c WHERE ck = old.pk;\n**   END;\n**\n** The returned pointer is cached as part of the foreign key object. It\n** is eventually freed along with the rest of the foreign key object by \n** sqlite3FkDelete().\n*/\nstatic Trigger *fkActionTrigger(\n  Parse *pParse,                  /* Parse context */\n  Table *pTab,                    /* Table being updated or deleted from */\n  FKey *pFKey,                    /* Foreign key to get action for */\n  ExprList *pChanges              /* Change-list for UPDATE, NULL for DELETE */\n){\n  sqlite3 *db = pParse->db;       /* Database handle */\n  int action;                     /* One of OE_None, OE_Cascade etc. */\n  Trigger *pTrigger;              /* Trigger definition to return */\n  int iAction = (pChanges!=0);    /* 1 for UPDATE, 0 for DELETE */\n\n  action = pFKey->aAction[iAction];\n  pTrigger = pFKey->apTrigger[iAction];\n\n  if( action!=OE_None && !pTrigger ){\n    u8 enableLookaside;           /* Copy of db->lookaside.bEnabled */\n    char const *zFrom;            /* Name of child table */\n    int nFrom;                    /* Length in bytes of zFrom */\n    Index *pIdx = 0;              /* Parent key index for this FK */\n    int *aiCol = 0;               /* child table cols -> parent key cols */\n    TriggerStep *pStep = 0;        /* First (only) step of trigger program */\n    Expr *pWhere = 0;             /* WHERE clause of trigger step */\n    ExprList *pList = 0;          /* Changes list if ON UPDATE CASCADE */\n    Select *pSelect = 0;          /* If RESTRICT, \"SELECT RAISE(...)\" */\n    int i;                        /* Iterator variable */\n    Expr *pWhen = 0;              /* WHEN clause for the trigger */\n\n    if( locateFkeyIndex(pParse, pTab, pFKey, &pIdx, &aiCol) ) return 0;\n    assert( aiCol || pFKey->nCol==1 );\n\n    for(i=0; i<pFKey->nCol; i++){\n      Token tOld = { \"old\", 3 };  /* Literal \"old\" token */\n      Token tNew = { \"new\", 3 };  /* Literal \"new\" token */\n      Token tFromCol;             /* Name of column in child table */\n      Token tToCol;               /* Name of column in parent table */\n      int iFromCol;               /* Idx of column in child table */\n      Expr *pEq;                  /* tFromCol = OLD.tToCol */\n\n      iFromCol = aiCol ? aiCol[i] : pFKey->aCol[0].iFrom;\n      assert( iFromCol>=0 );\n      tToCol.z = pIdx ? pTab->aCol[pIdx->aiColumn[i]].zName : \"oid\";\n      tFromCol.z = pFKey->pFrom->aCol[iFromCol].zName;\n\n      tToCol.n = sqlite3Strlen30(tToCol.z);\n      tFromCol.n = sqlite3Strlen30(tFromCol.z);\n\n      /* Create the expression \"OLD.zToCol = zFromCol\". It is important\n      ** that the \"OLD.zToCol\" term is on the LHS of the = operator, so\n      ** that the affinity and collation sequence associated with the\n      ** parent table are used for the comparison. */\n      pEq = sqlite3PExpr(pParse, TK_EQ,\n          sqlite3PExpr(pParse, TK_DOT, \n            sqlite3PExpr(pParse, TK_ID, 0, 0, &tOld),\n            sqlite3PExpr(pParse, TK_ID, 0, 0, &tToCol)\n          , 0),\n          sqlite3PExpr(pParse, TK_ID, 0, 0, &tFromCol)\n      , 0);\n      pWhere = sqlite3ExprAnd(db, pWhere, pEq);\n\n      /* For ON UPDATE, construct the next term of the WHEN clause.\n      ** The final WHEN clause will be like this:\n      **\n      **    WHEN NOT(old.col1 IS new.col1 AND ... AND old.colN IS new.colN)\n      */\n      if( pChanges ){\n        pEq = sqlite3PExpr(pParse, TK_IS,\n            sqlite3PExpr(pParse, TK_DOT, \n              sqlite3PExpr(pParse, TK_ID, 0, 0, &tOld),\n              sqlite3PExpr(pParse, TK_ID, 0, 0, &tToCol),\n              0),\n            sqlite3PExpr(pParse, TK_DOT, \n              sqlite3PExpr(pParse, TK_ID, 0, 0, &tNew),\n              sqlite3PExpr(pParse, TK_ID, 0, 0, &tToCol),\n              0),\n            0);\n        pWhen = sqlite3ExprAnd(db, pWhen, pEq);\n      }\n  \n      if( action!=OE_Restrict && (action!=OE_Cascade || pChanges) ){\n        Expr *pNew;\n        if( action==OE_Cascade ){\n          pNew = sqlite3PExpr(pParse, TK_DOT, \n            sqlite3PExpr(pParse, TK_ID, 0, 0, &tNew),\n            sqlite3PExpr(pParse, TK_ID, 0, 0, &tToCol)\n          , 0);\n        }else if( action==OE_SetDflt ){\n          Expr *pDflt = pFKey->pFrom->aCol[iFromCol].pDflt;\n          if( pDflt ){\n            pNew = sqlite3ExprDup(db, pDflt, 0);\n          }else{\n            pNew = sqlite3PExpr(pParse, TK_NULL, 0, 0, 0);\n          }\n        }else{\n          pNew = sqlite3PExpr(pParse, TK_NULL, 0, 0, 0);\n        }\n        pList = sqlite3ExprListAppend(pParse, pList, pNew);\n        sqlite3ExprListSetName(pParse, pList, &tFromCol, 0);\n      }\n    }\n    sqlite3DbFree(db, aiCol);\n\n    zFrom = pFKey->pFrom->zName;\n    nFrom = sqlite3Strlen30(zFrom);\n\n    if( action==OE_Restrict ){\n      Token tFrom;\n      Expr *pRaise; \n\n      tFrom.z = zFrom;\n      tFrom.n = nFrom;\n      pRaise = sqlite3Expr(db, TK_RAISE, \"foreign key constraint failed\");\n      if( pRaise ){\n        pRaise->affinity = OE_Abort;\n      }\n      pSelect = sqlite3SelectNew(pParse, \n          sqlite3ExprListAppend(pParse, 0, pRaise),\n          sqlite3SrcListAppend(db, 0, &tFrom, 0),\n          pWhere,\n          0, 0, 0, 0, 0, 0\n      );\n      pWhere = 0;\n    }\n\n    /* Disable lookaside memory allocation */\n    enableLookaside = db->lookaside.bEnabled;\n    db->lookaside.bEnabled = 0;\n\n    pTrigger = (Trigger *)sqlite3DbMallocZero(db, \n        sizeof(Trigger) +         /* struct Trigger */\n        sizeof(TriggerStep) +     /* Single step in trigger program */\n        nFrom + 1                 /* Space for pStep->target.z */\n    );\n    if( pTrigger ){\n      pStep = pTrigger->step_list = (TriggerStep *)&pTrigger[1];\n      pStep->target.z = (char *)&pStep[1];\n      pStep->target.n = nFrom;\n      memcpy((char *)pStep->target.z, zFrom, nFrom);\n  \n      pStep->pWhere = sqlite3ExprDup(db, pWhere, EXPRDUP_REDUCE);\n      pStep->pExprList = sqlite3ExprListDup(db, pList, EXPRDUP_REDUCE);\n      pStep->pSelect = sqlite3SelectDup(db, pSelect, EXPRDUP_REDUCE);\n      if( pWhen ){\n        pWhen = sqlite3PExpr(pParse, TK_NOT, pWhen, 0, 0);\n        pTrigger->pWhen = sqlite3ExprDup(db, pWhen, EXPRDUP_REDUCE);\n      }\n    }\n\n    /* Re-enable the lookaside buffer, if it was disabled earlier. */\n    db->lookaside.bEnabled = enableLookaside;\n\n    sqlite3ExprDelete(db, pWhere);\n    sqlite3ExprDelete(db, pWhen);\n    sqlite3ExprListDelete(db, pList);\n    sqlite3SelectDelete(db, pSelect);\n    if( db->mallocFailed==1 ){\n      fkTriggerDelete(db, pTrigger);\n      return 0;\n    }\n\n    switch( action ){\n      case OE_Restrict:\n        pStep->op = TK_SELECT; \n        break;\n      case OE_Cascade: \n        if( !pChanges ){ \n          pStep->op = TK_DELETE; \n          break; \n        }\n      default:\n        pStep->op = TK_UPDATE;\n    }\n    pStep->pTrig = pTrigger;\n    pTrigger->pSchema = pTab->pSchema;\n    pTrigger->pTabSchema = pTab->pSchema;\n    pFKey->apTrigger[iAction] = pTrigger;\n    pTrigger->op = (pChanges ? TK_UPDATE : TK_DELETE);\n  }\n\n  return pTrigger;\n}\n\n/*\n** This function is called when deleting or updating a row to implement\n** any required CASCADE, SET NULL or SET DEFAULT actions.\n*/\nSQLITE_PRIVATE void sqlite3FkActions(\n  Parse *pParse,                  /* Parse context */\n  Table *pTab,                    /* Table being updated or deleted from */\n  ExprList *pChanges,             /* Change-list for UPDATE, NULL for DELETE */\n  int regOld                      /* Address of array containing old row */\n){\n  /* If foreign-key support is enabled, iterate through all FKs that \n  ** refer to table pTab. If there is an action associated with the FK \n  ** for this operation (either update or delete), invoke the associated \n  ** trigger sub-program.  */\n  if( pParse->db->flags&SQLITE_ForeignKeys ){\n    FKey *pFKey;                  /* Iterator variable */\n    for(pFKey = sqlite3FkReferences(pTab); pFKey; pFKey=pFKey->pNextTo){\n      Trigger *pAction = fkActionTrigger(pParse, pTab, pFKey, pChanges);\n      if( pAction ){\n        sqlite3CodeRowTriggerDirect(pParse, pAction, pTab, regOld, OE_Abort, 0);\n      }\n    }\n  }\n}\n\n#endif /* ifndef SQLITE_OMIT_TRIGGER */\n\n/*\n** Free all memory associated with foreign key definitions attached to\n** table pTab. Remove the deleted foreign keys from the Schema.fkeyHash\n** hash table.\n*/\nSQLITE_PRIVATE void sqlite3FkDelete(sqlite3 *db, Table *pTab){\n  FKey *pFKey;                    /* Iterator variable */\n  FKey *pNext;                    /* Copy of pFKey->pNextFrom */\n\n  for(pFKey=pTab->pFKey; pFKey; pFKey=pNext){\n\n    /* Remove the FK from the fkeyHash hash table. */\n    if( !db || db->pnBytesFreed==0 ){\n      if( pFKey->pPrevTo ){\n        pFKey->pPrevTo->pNextTo = pFKey->pNextTo;\n      }else{\n        void *p = (void *)pFKey->pNextTo;\n        const char *z = (p ? pFKey->pNextTo->zTo : pFKey->zTo);\n        sqlite3HashInsert(&pTab->pSchema->fkeyHash, z, sqlite3Strlen30(z), p);\n      }\n      if( pFKey->pNextTo ){\n        pFKey->pNextTo->pPrevTo = pFKey->pPrevTo;\n      }\n    }\n\n    /* EV: R-30323-21917 Each foreign key constraint in SQLite is\n    ** classified as either immediate or deferred.\n    */\n    assert( pFKey->isDeferred==0 || pFKey->isDeferred==1 );\n\n    /* Delete any triggers created to implement actions for this FK. */\n#ifndef SQLITE_OMIT_TRIGGER\n    fkTriggerDelete(db, pFKey->apTrigger[0]);\n    fkTriggerDelete(db, pFKey->apTrigger[1]);\n#endif\n\n    pNext = pFKey->pNextFrom;\n    sqlite3DbFree(db, pFKey);\n  }\n}\n#endif /* ifndef SQLITE_OMIT_FOREIGN_KEY */\n\n/************** End of fkey.c ************************************************/\n/************** Begin file insert.c ******************************************/\n/*\n** 2001 September 15\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains C code routines that are called by the parser\n** to handle INSERT statements in SQLite.\n*/\n\n/*\n** Generate code that will open a table for reading.\n*/\nSQLITE_PRIVATE void sqlite3OpenTable(\n  Parse *p,       /* Generate code into this VDBE */\n  int iCur,       /* The cursor number of the table */\n  int iDb,        /* The database index in sqlite3.aDb[] */\n  Table *pTab,    /* The table to be opened */\n  int opcode      /* OP_OpenRead or OP_OpenWrite */\n){\n  Vdbe *v;\n  if( IsVirtual(pTab) ) return;\n  v = sqlite3GetVdbe(p);\n  assert( opcode==OP_OpenWrite || opcode==OP_OpenRead );\n  sqlite3TableLock(p, iDb, pTab->tnum, (opcode==OP_OpenWrite)?1:0, pTab->zName);\n  sqlite3VdbeAddOp3(v, opcode, iCur, pTab->tnum, iDb);\n  sqlite3VdbeChangeP4(v, -1, SQLITE_INT_TO_PTR(pTab->nCol), P4_INT32);\n  VdbeComment((v, \"%s\", pTab->zName));\n}\n\n/*\n** Return a pointer to the column affinity string associated with index\n** pIdx. A column affinity string has one character for each column in \n** the table, according to the affinity of the column:\n**\n**  Character      Column affinity\n**  ------------------------------\n**  'a'            TEXT\n**  'b'            NONE\n**  'c'            NUMERIC\n**  'd'            INTEGER\n**  'e'            REAL\n**\n** An extra 'b' is appended to the end of the string to cover the\n** rowid that appears as the last column in every index.\n**\n** Memory for the buffer containing the column index affinity string\n** is managed along with the rest of the Index structure. It will be\n** released when sqlite3DeleteIndex() is called.\n*/\nSQLITE_PRIVATE const char *sqlite3IndexAffinityStr(Vdbe *v, Index *pIdx){\n  if( !pIdx->zColAff ){\n    /* The first time a column affinity string for a particular index is\n    ** required, it is allocated and populated here. It is then stored as\n    ** a member of the Index structure for subsequent use.\n    **\n    ** The column affinity string will eventually be deleted by\n    ** sqliteDeleteIndex() when the Index structure itself is cleaned\n    ** up.\n    */\n    int n;\n    Table *pTab = pIdx->pTable;\n    sqlite3 *db = sqlite3VdbeDb(v);\n    pIdx->zColAff = (char *)sqlite3DbMallocRaw(0, pIdx->nColumn+2);\n    if( !pIdx->zColAff ){\n      db->mallocFailed = 1;\n      return 0;\n    }\n    for(n=0; n<pIdx->nColumn; n++){\n      pIdx->zColAff[n] = pTab->aCol[pIdx->aiColumn[n]].affinity;\n    }\n    pIdx->zColAff[n++] = SQLITE_AFF_NONE;\n    pIdx->zColAff[n] = 0;\n  }\n \n  return pIdx->zColAff;\n}\n\n/*\n** Set P4 of the most recently inserted opcode to a column affinity\n** string for table pTab. A column affinity string has one character\n** for each column indexed by the index, according to the affinity of the\n** column:\n**\n**  Character      Column affinity\n**  ------------------------------\n**  'a'            TEXT\n**  'b'            NONE\n**  'c'            NUMERIC\n**  'd'            INTEGER\n**  'e'            REAL\n*/\nSQLITE_PRIVATE void sqlite3TableAffinityStr(Vdbe *v, Table *pTab){\n  /* The first time a column affinity string for a particular table\n  ** is required, it is allocated and populated here. It is then \n  ** stored as a member of the Table structure for subsequent use.\n  **\n  ** The column affinity string will eventually be deleted by\n  ** sqlite3DeleteTable() when the Table structure itself is cleaned up.\n  */\n  if( !pTab->zColAff ){\n    char *zColAff;\n    int i;\n    sqlite3 *db = sqlite3VdbeDb(v);\n\n    zColAff = (char *)sqlite3DbMallocRaw(0, pTab->nCol+1);\n    if( !zColAff ){\n      db->mallocFailed = 1;\n      return;\n    }\n\n    for(i=0; i<pTab->nCol; i++){\n      zColAff[i] = pTab->aCol[i].affinity;\n    }\n    zColAff[pTab->nCol] = '\\0';\n\n    pTab->zColAff = zColAff;\n  }\n\n  sqlite3VdbeChangeP4(v, -1, pTab->zColAff, 0);\n}\n\n/*\n** Return non-zero if the table pTab in database iDb or any of its indices\n** have been opened at any point in the VDBE program beginning at location\n** iStartAddr throught the end of the program.  This is used to see if \n** a statement of the form  \"INSERT INTO <iDb, pTab> SELECT ...\" can \n** run without using temporary table for the results of the SELECT. \n*/\nstatic int readsTable(Parse *p, int iStartAddr, int iDb, Table *pTab){\n  Vdbe *v = sqlite3GetVdbe(p);\n  int i;\n  int iEnd = sqlite3VdbeCurrentAddr(v);\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  VTable *pVTab = IsVirtual(pTab) ? sqlite3GetVTable(p->db, pTab) : 0;\n#endif\n\n  for(i=iStartAddr; i<iEnd; i++){\n    VdbeOp *pOp = sqlite3VdbeGetOp(v, i);\n    assert( pOp!=0 );\n    if( pOp->opcode==OP_OpenRead && pOp->p3==iDb ){\n      Index *pIndex;\n      int tnum = pOp->p2;\n      if( tnum==pTab->tnum ){\n        return 1;\n      }\n      for(pIndex=pTab->pIndex; pIndex; pIndex=pIndex->pNext){\n        if( tnum==pIndex->tnum ){\n          return 1;\n        }\n      }\n    }\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n    if( pOp->opcode==OP_VOpen && pOp->p4.pVtab==pVTab ){\n      assert( pOp->p4.pVtab!=0 );\n      assert( pOp->p4type==P4_VTAB );\n      return 1;\n    }\n#endif\n  }\n  return 0;\n}\n\n#ifndef SQLITE_OMIT_AUTOINCREMENT\n/*\n** Locate or create an AutoincInfo structure associated with table pTab\n** which is in database iDb.  Return the register number for the register\n** that holds the maximum rowid.\n**\n** There is at most one AutoincInfo structure per table even if the\n** same table is autoincremented multiple times due to inserts within\n** triggers.  A new AutoincInfo structure is created if this is the\n** first use of table pTab.  On 2nd and subsequent uses, the original\n** AutoincInfo structure is used.\n**\n** Three memory locations are allocated:\n**\n**   (1)  Register to hold the name of the pTab table.\n**   (2)  Register to hold the maximum ROWID of pTab.\n**   (3)  Register to hold the rowid in sqlite_sequence of pTab\n**\n** The 2nd register is the one that is returned.  That is all the\n** insert routine needs to know about.\n*/\nstatic int autoIncBegin(\n  Parse *pParse,      /* Parsing context */\n  int iDb,            /* Index of the database holding pTab */\n  Table *pTab         /* The table we are writing to */\n){\n  int memId = 0;      /* Register holding maximum rowid */\n  if( pTab->tabFlags & TF_Autoincrement ){\n    Parse *pToplevel = sqlite3ParseToplevel(pParse);\n    AutoincInfo *pInfo;\n\n    pInfo = pToplevel->pAinc;\n    while( pInfo && pInfo->pTab!=pTab ){ pInfo = pInfo->pNext; }\n    if( pInfo==0 ){\n      pInfo = sqlite3DbMallocRaw(pParse->db, sizeof(*pInfo));\n      if( pInfo==0 ) return 0;\n      pInfo->pNext = pToplevel->pAinc;\n      pToplevel->pAinc = pInfo;\n      pInfo->pTab = pTab;\n      pInfo->iDb = iDb;\n      pToplevel->nMem++;                  /* Register to hold name of table */\n      pInfo->regCtr = ++pToplevel->nMem;  /* Max rowid register */\n      pToplevel->nMem++;                  /* Rowid in sqlite_sequence */\n    }\n    memId = pInfo->regCtr;\n  }\n  return memId;\n}\n\n/*\n** This routine generates code that will initialize all of the\n** register used by the autoincrement tracker.  \n*/\nSQLITE_PRIVATE void sqlite3AutoincrementBegin(Parse *pParse){\n  AutoincInfo *p;            /* Information about an AUTOINCREMENT */\n  sqlite3 *db = pParse->db;  /* The database connection */\n  Db *pDb;                   /* Database only autoinc table */\n  int memId;                 /* Register holding max rowid */\n  int addr;                  /* A VDBE address */\n  Vdbe *v = pParse->pVdbe;   /* VDBE under construction */\n\n  /* This routine is never called during trigger-generation.  It is\n  ** only called from the top-level */\n  assert( pParse->pTriggerTab==0 );\n  assert( pParse==sqlite3ParseToplevel(pParse) );\n\n  assert( v );   /* We failed long ago if this is not so */\n  for(p = pParse->pAinc; p; p = p->pNext){\n    pDb = &db->aDb[p->iDb];\n    memId = p->regCtr;\n    sqlite3OpenTable(pParse, 0, p->iDb, pDb->pSchema->pSeqTab, OP_OpenRead);\n    addr = sqlite3VdbeCurrentAddr(v);\n    sqlite3VdbeAddOp4(v, OP_String8, 0, memId-1, 0, p->pTab->zName, 0);\n    sqlite3VdbeAddOp2(v, OP_Rewind, 0, addr+9);\n    sqlite3VdbeAddOp3(v, OP_Column, 0, 0, memId);\n    sqlite3VdbeAddOp3(v, OP_Ne, memId-1, addr+7, memId);\n    sqlite3VdbeChangeP5(v, SQLITE_JUMPIFNULL);\n    sqlite3VdbeAddOp2(v, OP_Rowid, 0, memId+1);\n    sqlite3VdbeAddOp3(v, OP_Column, 0, 1, memId);\n    sqlite3VdbeAddOp2(v, OP_Goto, 0, addr+9);\n    sqlite3VdbeAddOp2(v, OP_Next, 0, addr+2);\n    sqlite3VdbeAddOp2(v, OP_Integer, 0, memId);\n    sqlite3VdbeAddOp0(v, OP_Close);\n  }\n}\n\n/*\n** Update the maximum rowid for an autoincrement calculation.\n**\n** This routine should be called when the top of the stack holds a\n** new rowid that is about to be inserted.  If that new rowid is\n** larger than the maximum rowid in the memId memory cell, then the\n** memory cell is updated.  The stack is unchanged.\n*/\nstatic void autoIncStep(Parse *pParse, int memId, int regRowid){\n  if( memId>0 ){\n    sqlite3VdbeAddOp2(pParse->pVdbe, OP_MemMax, memId, regRowid);\n  }\n}\n\n/*\n** This routine generates the code needed to write autoincrement\n** maximum rowid values back into the sqlite_sequence register.\n** Every statement that might do an INSERT into an autoincrement\n** table (either directly or through triggers) needs to call this\n** routine just before the \"exit\" code.\n*/\nSQLITE_PRIVATE void sqlite3AutoincrementEnd(Parse *pParse){\n  AutoincInfo *p;\n  Vdbe *v = pParse->pVdbe;\n  sqlite3 *db = pParse->db;\n\n  assert( v );\n  for(p = pParse->pAinc; p; p = p->pNext){\n    Db *pDb = &db->aDb[p->iDb];\n    int j1, j2, j3, j4, j5;\n    int iRec;\n    int memId = p->regCtr;\n\n    iRec = sqlite3GetTempReg(pParse);\n    sqlite3OpenTable(pParse, 0, p->iDb, pDb->pSchema->pSeqTab, OP_OpenWrite);\n    j1 = sqlite3VdbeAddOp1(v, OP_NotNull, memId+1);\n    j2 = sqlite3VdbeAddOp0(v, OP_Rewind);\n    j3 = sqlite3VdbeAddOp3(v, OP_Column, 0, 0, iRec);\n    j4 = sqlite3VdbeAddOp3(v, OP_Eq, memId-1, 0, iRec);\n    sqlite3VdbeAddOp2(v, OP_Next, 0, j3);\n    sqlite3VdbeJumpHere(v, j2);\n    sqlite3VdbeAddOp2(v, OP_NewRowid, 0, memId+1);\n    j5 = sqlite3VdbeAddOp0(v, OP_Goto);\n    sqlite3VdbeJumpHere(v, j4);\n    sqlite3VdbeAddOp2(v, OP_Rowid, 0, memId+1);\n    sqlite3VdbeJumpHere(v, j1);\n    sqlite3VdbeJumpHere(v, j5);\n    sqlite3VdbeAddOp3(v, OP_MakeRecord, memId-1, 2, iRec);\n    sqlite3VdbeAddOp3(v, OP_Insert, 0, iRec, memId+1);\n    sqlite3VdbeChangeP5(v, OPFLAG_APPEND);\n    sqlite3VdbeAddOp0(v, OP_Close);\n    sqlite3ReleaseTempReg(pParse, iRec);\n  }\n}\n#else\n/*\n** If SQLITE_OMIT_AUTOINCREMENT is defined, then the three routines\n** above are all no-ops\n*/\n# define autoIncBegin(A,B,C) (0)\n# define autoIncStep(A,B,C)\n#endif /* SQLITE_OMIT_AUTOINCREMENT */\n\n\n/* Forward declaration */\nstatic int xferOptimization(\n  Parse *pParse,        /* Parser context */\n  Table *pDest,         /* The table we are inserting into */\n  Select *pSelect,      /* A SELECT statement to use as the data source */\n  int onError,          /* How to handle constraint errors */\n  int iDbDest           /* The database of pDest */\n);\n\n/*\n** This routine is call to handle SQL of the following forms:\n**\n**    insert into TABLE (IDLIST) values(EXPRLIST)\n**    insert into TABLE (IDLIST) select\n**\n** The IDLIST following the table name is always optional.  If omitted,\n** then a list of all columns for the table is substituted.  The IDLIST\n** appears in the pColumn parameter.  pColumn is NULL if IDLIST is omitted.\n**\n** The pList parameter holds EXPRLIST in the first form of the INSERT\n** statement above, and pSelect is NULL.  For the second form, pList is\n** NULL and pSelect is a pointer to the select statement used to generate\n** data for the insert.\n**\n** The code generated follows one of four templates.  For a simple\n** select with data coming from a VALUES clause, the code executes\n** once straight down through.  Pseudo-code follows (we call this\n** the \"1st template\"):\n**\n**         open write cursor to <table> and its indices\n**         puts VALUES clause expressions onto the stack\n**         write the resulting record into <table>\n**         cleanup\n**\n** The three remaining templates assume the statement is of the form\n**\n**   INSERT INTO <table> SELECT ...\n**\n** If the SELECT clause is of the restricted form \"SELECT * FROM <table2>\" -\n** in other words if the SELECT pulls all columns from a single table\n** and there is no WHERE or LIMIT or GROUP BY or ORDER BY clauses, and\n** if <table2> and <table1> are distinct tables but have identical\n** schemas, including all the same indices, then a special optimization\n** is invoked that copies raw records from <table2> over to <table1>.\n** See the xferOptimization() function for the implementation of this\n** template.  This is the 2nd template.\n**\n**         open a write cursor to <table>\n**         open read cursor on <table2>\n**         transfer all records in <table2> over to <table>\n**         close cursors\n**         foreach index on <table>\n**           open a write cursor on the <table> index\n**           open a read cursor on the corresponding <table2> index\n**           transfer all records from the read to the write cursors\n**           close cursors\n**         end foreach\n**\n** The 3rd template is for when the second template does not apply\n** and the SELECT clause does not read from <table> at any time.\n** The generated code follows this template:\n**\n**         EOF <- 0\n**         X <- A\n**         goto B\n**      A: setup for the SELECT\n**         loop over the rows in the SELECT\n**           load values into registers R..R+n\n**           yield X\n**         end loop\n**         cleanup after the SELECT\n**         EOF <- 1\n**         yield X\n**         goto A\n**      B: open write cursor to <table> and its indices\n**      C: yield X\n**         if EOF goto D\n**         insert the select result into <table> from R..R+n\n**         goto C\n**      D: cleanup\n**\n** The 4th template is used if the insert statement takes its\n** values from a SELECT but the data is being inserted into a table\n** that is also read as part of the SELECT.  In the third form,\n** we have to use a intermediate table to store the results of\n** the select.  The template is like this:\n**\n**         EOF <- 0\n**         X <- A\n**         goto B\n**      A: setup for the SELECT\n**         loop over the tables in the SELECT\n**           load value into register R..R+n\n**           yield X\n**         end loop\n**         cleanup after the SELECT\n**         EOF <- 1\n**         yield X\n**         halt-error\n**      B: open temp table\n**      L: yield X\n**         if EOF goto M\n**         insert row from R..R+n into temp table\n**         goto L\n**      M: open write cursor to <table> and its indices\n**         rewind temp table\n**      C: loop over rows of intermediate table\n**           transfer values form intermediate table into <table>\n**         end loop\n**      D: cleanup\n*/\nSQLITE_PRIVATE void sqlite3Insert(\n  Parse *pParse,        /* Parser context */\n  SrcList *pTabList,    /* Name of table into which we are inserting */\n  ExprList *pList,      /* List of values to be inserted */\n  Select *pSelect,      /* A SELECT statement to use as the data source */\n  IdList *pColumn,      /* Column names corresponding to IDLIST. */\n  int onError           /* How to handle constraint errors */\n){\n  sqlite3 *db;          /* The main database structure */\n  Table *pTab;          /* The table to insert into.  aka TABLE */\n  char *zTab;           /* Name of the table into which we are inserting */\n  const char *zDb;      /* Name of the database holding this table */\n  int i, j, idx;        /* Loop counters */\n  Vdbe *v;              /* Generate code into this virtual machine */\n  Index *pIdx;          /* For looping over indices of the table */\n  int nColumn;          /* Number of columns in the data */\n  int nHidden = 0;      /* Number of hidden columns if TABLE is virtual */\n  int baseCur = 0;      /* VDBE Cursor number for pTab */\n  int keyColumn = -1;   /* Column that is the INTEGER PRIMARY KEY */\n  int endOfLoop;        /* Label for the end of the insertion loop */\n  int useTempTable = 0; /* Store SELECT results in intermediate table */\n  int srcTab = 0;       /* Data comes from this temporary cursor if >=0 */\n  int addrInsTop = 0;   /* Jump to label \"D\" */\n  int addrCont = 0;     /* Top of insert loop. Label \"C\" in templates 3 and 4 */\n  int addrSelect = 0;   /* Address of coroutine that implements the SELECT */\n  SelectDest dest;      /* Destination for SELECT on rhs of INSERT */\n  int iDb;              /* Index of database holding TABLE */\n  Db *pDb;              /* The database containing table being inserted into */\n  int appendFlag = 0;   /* True if the insert is likely to be an append */\n\n  /* Register allocations */\n  int regFromSelect = 0;/* Base register for data coming from SELECT */\n  int regAutoinc = 0;   /* Register holding the AUTOINCREMENT counter */\n  int regRowCount = 0;  /* Memory cell used for the row counter */\n  int regIns;           /* Block of regs holding rowid+data being inserted */\n  int regRowid;         /* registers holding insert rowid */\n  int regData;          /* register holding first column to insert */\n  int regEof = 0;       /* Register recording end of SELECT data */\n  int *aRegIdx = 0;     /* One register allocated to each index */\n\n#ifndef SQLITE_OMIT_TRIGGER\n  int isView;                 /* True if attempting to insert into a view */\n  Trigger *pTrigger;          /* List of triggers on pTab, if required */\n  int tmask;                  /* Mask of trigger times */\n#endif\n\n  db = pParse->db;\n  memset(&dest, 0, sizeof(dest));\n  if( pParse->nErr || db->mallocFailed ){\n    goto insert_cleanup;\n  }\n\n  /* Locate the table into which we will be inserting new information.\n  */\n  assert( pTabList->nSrc==1 );\n  zTab = pTabList->a[0].zName;\n  if( NEVER(zTab==0) ) goto insert_cleanup;\n  pTab = sqlite3SrcListLookup(pParse, pTabList);\n  if( pTab==0 ){\n    goto insert_cleanup;\n  }\n  iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n  assert( iDb<db->nDb );\n  pDb = &db->aDb[iDb];\n  zDb = pDb->zName;\n  if( sqlite3AuthCheck(pParse, SQLITE_INSERT, pTab->zName, 0, zDb) ){\n    goto insert_cleanup;\n  }\n\n  /* Figure out if we have any triggers and if the table being\n  ** inserted into is a view\n  */\n#ifndef SQLITE_OMIT_TRIGGER\n  pTrigger = sqlite3TriggersExist(pParse, pTab, TK_INSERT, 0, &tmask);\n  isView = pTab->pSelect!=0;\n#else\n# define pTrigger 0\n# define tmask 0\n# define isView 0\n#endif\n#ifdef SQLITE_OMIT_VIEW\n# undef isView\n# define isView 0\n#endif\n  assert( (pTrigger && tmask) || (pTrigger==0 && tmask==0) );\n\n  /* If pTab is really a view, make sure it has been initialized.\n  ** ViewGetColumnNames() is a no-op if pTab is not a view (or virtual \n  ** module table).\n  */\n  if( sqlite3ViewGetColumnNames(pParse, pTab) ){\n    goto insert_cleanup;\n  }\n\n  /* Ensure that:\n  *  (a) the table is not read-only, \n  *  (b) that if it is a view then ON INSERT triggers exist\n  */\n  if( sqlite3IsReadOnly(pParse, pTab, tmask) ){\n    goto insert_cleanup;\n  }\n\n  /* Allocate a VDBE\n  */\n  v = sqlite3GetVdbe(pParse);\n  if( v==0 ) goto insert_cleanup;\n  if( pParse->nested==0 ) sqlite3VdbeCountChanges(v);\n  sqlite3BeginWriteOperation(pParse, pSelect || pTrigger, iDb);\n\n#ifndef SQLITE_OMIT_XFER_OPT\n  /* If the statement is of the form\n  **\n  **       INSERT INTO <table1> SELECT * FROM <table2>;\n  **\n  ** Then special optimizations can be applied that make the transfer\n  ** very fast and which reduce fragmentation of indices.\n  **\n  ** This is the 2nd template.\n  */\n  if( pColumn==0 && xferOptimization(pParse, pTab, pSelect, onError, iDb) ){\n    assert( !pTrigger );\n    assert( pList==0 );\n    goto insert_end;\n  }\n#endif /* SQLITE_OMIT_XFER_OPT */\n\n  /* If this is an AUTOINCREMENT table, look up the sequence number in the\n  ** sqlite_sequence table and store it in memory cell regAutoinc.\n  */\n  regAutoinc = autoIncBegin(pParse, iDb, pTab);\n\n  /* Figure out how many columns of data are supplied.  If the data\n  ** is coming from a SELECT statement, then generate a co-routine that\n  ** produces a single row of the SELECT on each invocation.  The\n  ** co-routine is the common header to the 3rd and 4th templates.\n  */\n  if( pSelect ){\n    /* Data is coming from a SELECT.  Generate code to implement that SELECT\n    ** as a co-routine.  The code is common to both the 3rd and 4th\n    ** templates:\n    **\n    **         EOF <- 0\n    **         X <- A\n    **         goto B\n    **      A: setup for the SELECT\n    **         loop over the tables in the SELECT\n    **           load value into register R..R+n\n    **           yield X\n    **         end loop\n    **         cleanup after the SELECT\n    **         EOF <- 1\n    **         yield X\n    **         halt-error\n    **\n    ** On each invocation of the co-routine, it puts a single row of the\n    ** SELECT result into registers dest.iMem...dest.iMem+dest.nMem-1.\n    ** (These output registers are allocated by sqlite3Select().)  When\n    ** the SELECT completes, it sets the EOF flag stored in regEof.\n    */\n    int rc, j1;\n\n    regEof = ++pParse->nMem;\n    sqlite3VdbeAddOp2(v, OP_Integer, 0, regEof);      /* EOF <- 0 */\n    VdbeComment((v, \"SELECT eof flag\"));\n    sqlite3SelectDestInit(&dest, SRT_Coroutine, ++pParse->nMem);\n    addrSelect = sqlite3VdbeCurrentAddr(v)+2;\n    sqlite3VdbeAddOp2(v, OP_Integer, addrSelect-1, dest.iParm);\n    j1 = sqlite3VdbeAddOp2(v, OP_Goto, 0, 0);\n    VdbeComment((v, \"Jump over SELECT coroutine\"));\n\n    /* Resolve the expressions in the SELECT statement and execute it. */\n    rc = sqlite3Select(pParse, pSelect, &dest);\n    assert( pParse->nErr==0 || rc );\n    if( rc || NEVER(pParse->nErr) || db->mallocFailed ){\n      goto insert_cleanup;\n    }\n    sqlite3VdbeAddOp2(v, OP_Integer, 1, regEof);         /* EOF <- 1 */\n    sqlite3VdbeAddOp1(v, OP_Yield, dest.iParm);   /* yield X */\n    sqlite3VdbeAddOp2(v, OP_Halt, SQLITE_INTERNAL, OE_Abort);\n    VdbeComment((v, \"End of SELECT coroutine\"));\n    sqlite3VdbeJumpHere(v, j1);                          /* label B: */\n\n    regFromSelect = dest.iMem;\n    assert( pSelect->pEList );\n    nColumn = pSelect->pEList->nExpr;\n    assert( dest.nMem==nColumn );\n\n    /* Set useTempTable to TRUE if the result of the SELECT statement\n    ** should be written into a temporary table (template 4).  Set to\n    ** FALSE if each* row of the SELECT can be written directly into\n    ** the destination table (template 3).\n    **\n    ** A temp table must be used if the table being updated is also one\n    ** of the tables being read by the SELECT statement.  Also use a \n    ** temp table in the case of row triggers.\n    */\n    if( pTrigger || readsTable(pParse, addrSelect, iDb, pTab) ){\n      useTempTable = 1;\n    }\n\n    if( useTempTable ){\n      /* Invoke the coroutine to extract information from the SELECT\n      ** and add it to a transient table srcTab.  The code generated\n      ** here is from the 4th template:\n      **\n      **      B: open temp table\n      **      L: yield X\n      **         if EOF goto M\n      **         insert row from R..R+n into temp table\n      **         goto L\n      **      M: ...\n      */\n      int regRec;          /* Register to hold packed record */\n      int regTempRowid;    /* Register to hold temp table ROWID */\n      int addrTop;         /* Label \"L\" */\n      int addrIf;          /* Address of jump to M */\n\n      srcTab = pParse->nTab++;\n      regRec = sqlite3GetTempReg(pParse);\n      regTempRowid = sqlite3GetTempReg(pParse);\n      sqlite3VdbeAddOp2(v, OP_OpenEphemeral, srcTab, nColumn);\n      addrTop = sqlite3VdbeAddOp1(v, OP_Yield, dest.iParm);\n      addrIf = sqlite3VdbeAddOp1(v, OP_If, regEof);\n      sqlite3VdbeAddOp3(v, OP_MakeRecord, regFromSelect, nColumn, regRec);\n      sqlite3VdbeAddOp2(v, OP_NewRowid, srcTab, regTempRowid);\n      sqlite3VdbeAddOp3(v, OP_Insert, srcTab, regRec, regTempRowid);\n      sqlite3VdbeAddOp2(v, OP_Goto, 0, addrTop);\n      sqlite3VdbeJumpHere(v, addrIf);\n      sqlite3ReleaseTempReg(pParse, regRec);\n      sqlite3ReleaseTempReg(pParse, regTempRowid);\n    }\n  }else{\n    /* This is the case if the data for the INSERT is coming from a VALUES\n    ** clause\n    */\n    NameContext sNC;\n    memset(&sNC, 0, sizeof(sNC));\n    sNC.pParse = pParse;\n    srcTab = -1;\n    assert( useTempTable==0 );\n    nColumn = pList ? pList->nExpr : 0;\n    for(i=0; i<nColumn; i++){\n      if( sqlite3ResolveExprNames(&sNC, pList->a[i].pExpr) ){\n        goto insert_cleanup;\n      }\n    }\n  }\n\n  /* Make sure the number of columns in the source data matches the number\n  ** of columns to be inserted into the table.\n  */\n  if( IsVirtual(pTab) ){\n    for(i=0; i<pTab->nCol; i++){\n      nHidden += (IsHiddenColumn(&pTab->aCol[i]) ? 1 : 0);\n    }\n  }\n  if( pColumn==0 && nColumn && nColumn!=(pTab->nCol-nHidden) ){\n    sqlite3ErrorMsg(pParse, \n       \"table %S has %d columns but %d values were supplied\",\n       pTabList, 0, pTab->nCol-nHidden, nColumn);\n    goto insert_cleanup;\n  }\n  if( pColumn!=0 && nColumn!=pColumn->nId ){\n    sqlite3ErrorMsg(pParse, \"%d values for %d columns\", nColumn, pColumn->nId);\n    goto insert_cleanup;\n  }\n\n  /* If the INSERT statement included an IDLIST term, then make sure\n  ** all elements of the IDLIST really are columns of the table and \n  ** remember the column indices.\n  **\n  ** If the table has an INTEGER PRIMARY KEY column and that column\n  ** is named in the IDLIST, then record in the keyColumn variable\n  ** the index into IDLIST of the primary key column.  keyColumn is\n  ** the index of the primary key as it appears in IDLIST, not as\n  ** is appears in the original table.  (The index of the primary\n  ** key in the original table is pTab->iPKey.)\n  */\n  if( pColumn ){\n    for(i=0; i<pColumn->nId; i++){\n      pColumn->a[i].idx = -1;\n    }\n    for(i=0; i<pColumn->nId; i++){\n      for(j=0; j<pTab->nCol; j++){\n        if( sqlite3StrICmp(pColumn->a[i].zName, pTab->aCol[j].zName)==0 ){\n          pColumn->a[i].idx = j;\n          if( j==pTab->iPKey ){\n            keyColumn = i;\n          }\n          break;\n        }\n      }\n      if( j>=pTab->nCol ){\n        if( sqlite3IsRowid(pColumn->a[i].zName) ){\n          keyColumn = i;\n        }else{\n          sqlite3ErrorMsg(pParse, \"table %S has no column named %s\",\n              pTabList, 0, pColumn->a[i].zName);\n          pParse->checkSchema = 1;\n          goto insert_cleanup;\n        }\n      }\n    }\n  }\n\n  /* If there is no IDLIST term but the table has an integer primary\n  ** key, the set the keyColumn variable to the primary key column index\n  ** in the original table definition.\n  */\n  if( pColumn==0 && nColumn>0 ){\n    keyColumn = pTab->iPKey;\n  }\n    \n  /* Initialize the count of rows to be inserted\n  */\n  if( db->flags & SQLITE_CountRows ){\n    regRowCount = ++pParse->nMem;\n    sqlite3VdbeAddOp2(v, OP_Integer, 0, regRowCount);\n  }\n\n  /* If this is not a view, open the table and and all indices */\n  if( !isView ){\n    int nIdx;\n\n    baseCur = pParse->nTab;\n    nIdx = sqlite3OpenTableAndIndices(pParse, pTab, baseCur, OP_OpenWrite);\n    aRegIdx = sqlite3DbMallocRaw(db, sizeof(int)*(nIdx+1));\n    if( aRegIdx==0 ){\n      goto insert_cleanup;\n    }\n    for(i=0; i<nIdx; i++){\n      aRegIdx[i] = ++pParse->nMem;\n    }\n  }\n\n  /* This is the top of the main insertion loop */\n  if( useTempTable ){\n    /* This block codes the top of loop only.  The complete loop is the\n    ** following pseudocode (template 4):\n    **\n    **         rewind temp table\n    **      C: loop over rows of intermediate table\n    **           transfer values form intermediate table into <table>\n    **         end loop\n    **      D: ...\n    */\n    addrInsTop = sqlite3VdbeAddOp1(v, OP_Rewind, srcTab);\n    addrCont = sqlite3VdbeCurrentAddr(v);\n  }else if( pSelect ){\n    /* This block codes the top of loop only.  The complete loop is the\n    ** following pseudocode (template 3):\n    **\n    **      C: yield X\n    **         if EOF goto D\n    **         insert the select result into <table> from R..R+n\n    **         goto C\n    **      D: ...\n    */\n    addrCont = sqlite3VdbeAddOp1(v, OP_Yield, dest.iParm);\n    addrInsTop = sqlite3VdbeAddOp1(v, OP_If, regEof);\n  }\n\n  /* Allocate registers for holding the rowid of the new row,\n  ** the content of the new row, and the assemblied row record.\n  */\n  regRowid = regIns = pParse->nMem+1;\n  pParse->nMem += pTab->nCol + 1;\n  if( IsVirtual(pTab) ){\n    regRowid++;\n    pParse->nMem++;\n  }\n  regData = regRowid+1;\n\n  /* Run the BEFORE and INSTEAD OF triggers, if there are any\n  */\n  endOfLoop = sqlite3VdbeMakeLabel(v);\n  if( tmask & TRIGGER_BEFORE ){\n    int regCols = sqlite3GetTempRange(pParse, pTab->nCol+1);\n\n    /* build the NEW.* reference row.  Note that if there is an INTEGER\n    ** PRIMARY KEY into which a NULL is being inserted, that NULL will be\n    ** translated into a unique ID for the row.  But on a BEFORE trigger,\n    ** we do not know what the unique ID will be (because the insert has\n    ** not happened yet) so we substitute a rowid of -1\n    */\n    if( keyColumn<0 ){\n      sqlite3VdbeAddOp2(v, OP_Integer, -1, regCols);\n    }else{\n      int j1;\n      if( useTempTable ){\n        sqlite3VdbeAddOp3(v, OP_Column, srcTab, keyColumn, regCols);\n      }else{\n        assert( pSelect==0 );  /* Otherwise useTempTable is true */\n        sqlite3ExprCode(pParse, pList->a[keyColumn].pExpr, regCols);\n      }\n      j1 = sqlite3VdbeAddOp1(v, OP_NotNull, regCols);\n      sqlite3VdbeAddOp2(v, OP_Integer, -1, regCols);\n      sqlite3VdbeJumpHere(v, j1);\n      sqlite3VdbeAddOp1(v, OP_MustBeInt, regCols);\n    }\n\n    /* Cannot have triggers on a virtual table. If it were possible,\n    ** this block would have to account for hidden column.\n    */\n    assert( !IsVirtual(pTab) );\n\n    /* Create the new column data\n    */\n    for(i=0; i<pTab->nCol; i++){\n      if( pColumn==0 ){\n        j = i;\n      }else{\n        for(j=0; j<pColumn->nId; j++){\n          if( pColumn->a[j].idx==i ) break;\n        }\n      }\n      if( (!useTempTable && !pList) || (pColumn && j>=pColumn->nId) ){\n        sqlite3ExprCode(pParse, pTab->aCol[i].pDflt, regCols+i+1);\n      }else if( useTempTable ){\n        sqlite3VdbeAddOp3(v, OP_Column, srcTab, j, regCols+i+1); \n      }else{\n        assert( pSelect==0 ); /* Otherwise useTempTable is true */\n        sqlite3ExprCodeAndCache(pParse, pList->a[j].pExpr, regCols+i+1);\n      }\n    }\n\n    /* If this is an INSERT on a view with an INSTEAD OF INSERT trigger,\n    ** do not attempt any conversions before assembling the record.\n    ** If this is a real table, attempt conversions as required by the\n    ** table column affinities.\n    */\n    if( !isView ){\n      sqlite3VdbeAddOp2(v, OP_Affinity, regCols+1, pTab->nCol);\n      sqlite3TableAffinityStr(v, pTab);\n    }\n\n    /* Fire BEFORE or INSTEAD OF triggers */\n    sqlite3CodeRowTrigger(pParse, pTrigger, TK_INSERT, 0, TRIGGER_BEFORE, \n        pTab, regCols-pTab->nCol-1, onError, endOfLoop);\n\n    sqlite3ReleaseTempRange(pParse, regCols, pTab->nCol+1);\n  }\n\n  /* Push the record number for the new entry onto the stack.  The\n  ** record number is a randomly generate integer created by NewRowid\n  ** except when the table has an INTEGER PRIMARY KEY column, in which\n  ** case the record number is the same as that column. \n  */\n  if( !isView ){\n    if( IsVirtual(pTab) ){\n      /* The row that the VUpdate opcode will delete: none */\n      sqlite3VdbeAddOp2(v, OP_Null, 0, regIns);\n    }\n    if( keyColumn>=0 ){\n      if( useTempTable ){\n        sqlite3VdbeAddOp3(v, OP_Column, srcTab, keyColumn, regRowid);\n      }else if( pSelect ){\n        sqlite3VdbeAddOp2(v, OP_SCopy, regFromSelect+keyColumn, regRowid);\n      }else{\n        VdbeOp *pOp;\n        sqlite3ExprCode(pParse, pList->a[keyColumn].pExpr, regRowid);\n        pOp = sqlite3VdbeGetOp(v, -1);\n        if( ALWAYS(pOp) && pOp->opcode==OP_Null && !IsVirtual(pTab) ){\n          appendFlag = 1;\n          pOp->opcode = OP_NewRowid;\n          pOp->p1 = baseCur;\n          pOp->p2 = regRowid;\n          pOp->p3 = regAutoinc;\n        }\n      }\n      /* If the PRIMARY KEY expression is NULL, then use OP_NewRowid\n      ** to generate a unique primary key value.\n      */\n      if( !appendFlag ){\n        int j1;\n        if( !IsVirtual(pTab) ){\n          j1 = sqlite3VdbeAddOp1(v, OP_NotNull, regRowid);\n          sqlite3VdbeAddOp3(v, OP_NewRowid, baseCur, regRowid, regAutoinc);\n          sqlite3VdbeJumpHere(v, j1);\n        }else{\n          j1 = sqlite3VdbeCurrentAddr(v);\n          sqlite3VdbeAddOp2(v, OP_IsNull, regRowid, j1+2);\n        }\n        sqlite3VdbeAddOp1(v, OP_MustBeInt, regRowid);\n      }\n    }else if( IsVirtual(pTab) ){\n      sqlite3VdbeAddOp2(v, OP_Null, 0, regRowid);\n    }else{\n      sqlite3VdbeAddOp3(v, OP_NewRowid, baseCur, regRowid, regAutoinc);\n      appendFlag = 1;\n    }\n    autoIncStep(pParse, regAutoinc, regRowid);\n\n    /* Push onto the stack, data for all columns of the new entry, beginning\n    ** with the first column.\n    */\n    nHidden = 0;\n    for(i=0; i<pTab->nCol; i++){\n      int iRegStore = regRowid+1+i;\n      if( i==pTab->iPKey ){\n        /* The value of the INTEGER PRIMARY KEY column is always a NULL.\n        ** Whenever this column is read, the record number will be substituted\n        ** in its place.  So will fill this column with a NULL to avoid\n        ** taking up data space with information that will never be used. */\n        sqlite3VdbeAddOp2(v, OP_Null, 0, iRegStore);\n        continue;\n      }\n      if( pColumn==0 ){\n        if( IsHiddenColumn(&pTab->aCol[i]) ){\n          assert( IsVirtual(pTab) );\n          j = -1;\n          nHidden++;\n        }else{\n          j = i - nHidden;\n        }\n      }else{\n        for(j=0; j<pColumn->nId; j++){\n          if( pColumn->a[j].idx==i ) break;\n        }\n      }\n      if( j<0 || nColumn==0 || (pColumn && j>=pColumn->nId) ){\n        sqlite3ExprCode(pParse, pTab->aCol[i].pDflt, iRegStore);\n      }else if( useTempTable ){\n        sqlite3VdbeAddOp3(v, OP_Column, srcTab, j, iRegStore); \n      }else if( pSelect ){\n        sqlite3VdbeAddOp2(v, OP_SCopy, regFromSelect+j, iRegStore);\n      }else{\n        sqlite3ExprCode(pParse, pList->a[j].pExpr, iRegStore);\n      }\n    }\n\n    /* Generate code to check constraints and generate index keys and\n    ** do the insertion.\n    */\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n    if( IsVirtual(pTab) ){\n      const char *pVTab = (const char *)sqlite3GetVTable(db, pTab);\n      sqlite3VtabMakeWritable(pParse, pTab);\n      sqlite3VdbeAddOp4(v, OP_VUpdate, 1, pTab->nCol+2, regIns, pVTab, P4_VTAB);\n      sqlite3MayAbort(pParse);\n    }else\n#endif\n    {\n      int isReplace;    /* Set to true if constraints may cause a replace */\n      sqlite3GenerateConstraintChecks(pParse, pTab, baseCur, regIns, aRegIdx,\n          keyColumn>=0, 0, onError, endOfLoop, &isReplace\n      );\n      sqlite3FkCheck(pParse, pTab, 0, regIns);\n      sqlite3CompleteInsertion(\n          pParse, pTab, baseCur, regIns, aRegIdx, 0, appendFlag, isReplace==0\n      );\n    }\n  }\n\n  /* Update the count of rows that are inserted\n  */\n  if( (db->flags & SQLITE_CountRows)!=0 ){\n    sqlite3VdbeAddOp2(v, OP_AddImm, regRowCount, 1);\n  }\n\n  if( pTrigger ){\n    /* Code AFTER triggers */\n    sqlite3CodeRowTrigger(pParse, pTrigger, TK_INSERT, 0, TRIGGER_AFTER, \n        pTab, regData-2-pTab->nCol, onError, endOfLoop);\n  }\n\n  /* The bottom of the main insertion loop, if the data source\n  ** is a SELECT statement.\n  */\n  sqlite3VdbeResolveLabel(v, endOfLoop);\n  if( useTempTable ){\n    sqlite3VdbeAddOp2(v, OP_Next, srcTab, addrCont);\n    sqlite3VdbeJumpHere(v, addrInsTop);\n    sqlite3VdbeAddOp1(v, OP_Close, srcTab);\n  }else if( pSelect ){\n    sqlite3VdbeAddOp2(v, OP_Goto, 0, addrCont);\n    sqlite3VdbeJumpHere(v, addrInsTop);\n  }\n\n  if( !IsVirtual(pTab) && !isView ){\n    /* Close all tables opened */\n    sqlite3VdbeAddOp1(v, OP_Close, baseCur);\n    for(idx=1, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, idx++){\n      sqlite3VdbeAddOp1(v, OP_Close, idx+baseCur);\n    }\n  }\n\ninsert_end:\n  /* Update the sqlite_sequence table by storing the content of the\n  ** maximum rowid counter values recorded while inserting into\n  ** autoincrement tables.\n  */\n  if( pParse->nested==0 && pParse->pTriggerTab==0 ){\n    sqlite3AutoincrementEnd(pParse);\n  }\n\n  /*\n  ** Return the number of rows inserted. If this routine is \n  ** generating code because of a call to sqlite3NestedParse(), do not\n  ** invoke the callback function.\n  */\n  if( (db->flags&SQLITE_CountRows) && !pParse->nested && !pParse->pTriggerTab ){\n    sqlite3VdbeAddOp2(v, OP_ResultRow, regRowCount, 1);\n    sqlite3VdbeSetNumCols(v, 1);\n    sqlite3VdbeSetColName(v, 0, COLNAME_NAME, \"rows inserted\", SQLITE_STATIC);\n  }\n\ninsert_cleanup:\n  sqlite3SrcListDelete(db, pTabList);\n  sqlite3ExprListDelete(db, pList);\n  sqlite3SelectDelete(db, pSelect);\n  sqlite3IdListDelete(db, pColumn);\n  sqlite3DbFree(db, aRegIdx);\n}\n\n/* Make sure \"isView\" and other macros defined above are undefined. Otherwise\n** thely may interfere with compilation of other functions in this file\n** (or in another file, if this file becomes part of the amalgamation).  */\n#ifdef isView\n #undef isView\n#endif\n#ifdef pTrigger\n #undef pTrigger\n#endif\n#ifdef tmask\n #undef tmask\n#endif\n\n\n/*\n** Generate code to do constraint checks prior to an INSERT or an UPDATE.\n**\n** The input is a range of consecutive registers as follows:\n**\n**    1.  The rowid of the row after the update.\n**\n**    2.  The data in the first column of the entry after the update.\n**\n**    i.  Data from middle columns...\n**\n**    N.  The data in the last column of the entry after the update.\n**\n** The regRowid parameter is the index of the register containing (1).\n**\n** If isUpdate is true and rowidChng is non-zero, then rowidChng contains\n** the address of a register containing the rowid before the update takes\n** place. isUpdate is true for UPDATEs and false for INSERTs. If isUpdate\n** is false, indicating an INSERT statement, then a non-zero rowidChng \n** indicates that the rowid was explicitly specified as part of the\n** INSERT statement. If rowidChng is false, it means that  the rowid is\n** computed automatically in an insert or that the rowid value is not \n** modified by an update.\n**\n** The code generated by this routine store new index entries into\n** registers identified by aRegIdx[].  No index entry is created for\n** indices where aRegIdx[i]==0.  The order of indices in aRegIdx[] is\n** the same as the order of indices on the linked list of indices\n** attached to the table.\n**\n** This routine also generates code to check constraints.  NOT NULL,\n** CHECK, and UNIQUE constraints are all checked.  If a constraint fails,\n** then the appropriate action is performed.  There are five possible\n** actions: ROLLBACK, ABORT, FAIL, REPLACE, and IGNORE.\n**\n**  Constraint type  Action       What Happens\n**  ---------------  ----------   ----------------------------------------\n**  any              ROLLBACK     The current transaction is rolled back and\n**                                sqlite3_exec() returns immediately with a\n**                                return code of SQLITE_CONSTRAINT.\n**\n**  any              ABORT        Back out changes from the current command\n**                                only (do not do a complete rollback) then\n**                                cause sqlite3_exec() to return immediately\n**                                with SQLITE_CONSTRAINT.\n**\n**  any              FAIL         Sqlite_exec() returns immediately with a\n**                                return code of SQLITE_CONSTRAINT.  The\n**                                transaction is not rolled back and any\n**                                prior changes are retained.\n**\n**  any              IGNORE       The record number and data is popped from\n**                                the stack and there is an immediate jump\n**                                to label ignoreDest.\n**\n**  NOT NULL         REPLACE      The NULL value is replace by the default\n**                                value for that column.  If the default value\n**                                is NULL, the action is the same as ABORT.\n**\n**  UNIQUE           REPLACE      The other row that conflicts with the row\n**                                being inserted is removed.\n**\n**  CHECK            REPLACE      Illegal.  The results in an exception.\n**\n** Which action to take is determined by the overrideError parameter.\n** Or if overrideError==OE_Default, then the pParse->onError parameter\n** is used.  Or if pParse->onError==OE_Default then the onError value\n** for the constraint is used.\n**\n** The calling routine must open a read/write cursor for pTab with\n** cursor number \"baseCur\".  All indices of pTab must also have open\n** read/write cursors with cursor number baseCur+i for the i-th cursor.\n** Except, if there is no possibility of a REPLACE action then\n** cursors do not need to be open for indices where aRegIdx[i]==0.\n*/\nSQLITE_PRIVATE void sqlite3GenerateConstraintChecks(\n  Parse *pParse,      /* The parser context */\n  Table *pTab,        /* the table into which we are inserting */\n  int baseCur,        /* Index of a read/write cursor pointing at pTab */\n  int regRowid,       /* Index of the range of input registers */\n  int *aRegIdx,       /* Register used by each index.  0 for unused indices */\n  int rowidChng,      /* True if the rowid might collide with existing entry */\n  int isUpdate,       /* True for UPDATE, False for INSERT */\n  int overrideError,  /* Override onError to this if not OE_Default */\n  int ignoreDest,     /* Jump to this label on an OE_Ignore resolution */\n  int *pbMayReplace   /* OUT: Set to true if constraint may cause a replace */\n){\n  int i;              /* loop counter */\n  Vdbe *v;            /* VDBE under constrution */\n  int nCol;           /* Number of columns */\n  int onError;        /* Conflict resolution strategy */\n  int j1;             /* Addresss of jump instruction */\n  int j2 = 0, j3;     /* Addresses of jump instructions */\n  int regData;        /* Register containing first data column */\n  int iCur;           /* Table cursor number */\n  Index *pIdx;         /* Pointer to one of the indices */\n  int seenReplace = 0; /* True if REPLACE is used to resolve INT PK conflict */\n  int regOldRowid = (rowidChng && isUpdate) ? rowidChng : regRowid;\n\n  v = sqlite3GetVdbe(pParse);\n  assert( v!=0 );\n  assert( pTab->pSelect==0 );  /* This table is not a VIEW */\n  nCol = pTab->nCol;\n  regData = regRowid + 1;\n\n  /* Test all NOT NULL constraints.\n  */\n  for(i=0; i<nCol; i++){\n    if( i==pTab->iPKey ){\n      continue;\n    }\n    onError = pTab->aCol[i].notNull;\n    if( onError==OE_None ) continue;\n    if( overrideError!=OE_Default ){\n      onError = overrideError;\n    }else if( onError==OE_Default ){\n      onError = OE_Abort;\n    }\n    if( onError==OE_Replace && pTab->aCol[i].pDflt==0 ){\n      onError = OE_Abort;\n    }\n    assert( onError==OE_Rollback || onError==OE_Abort || onError==OE_Fail\n        || onError==OE_Ignore || onError==OE_Replace );\n    switch( onError ){\n      case OE_Abort:\n        sqlite3MayAbort(pParse);\n      case OE_Rollback:\n      case OE_Fail: {\n        char *zMsg;\n        sqlite3VdbeAddOp3(v, OP_HaltIfNull,\n                                  SQLITE_CONSTRAINT, onError, regData+i);\n        zMsg = sqlite3MPrintf(pParse->db, \"%s.%s may not be NULL\",\n                              pTab->zName, pTab->aCol[i].zName);\n        sqlite3VdbeChangeP4(v, -1, zMsg, P4_DYNAMIC);\n        break;\n      }\n      case OE_Ignore: {\n        sqlite3VdbeAddOp2(v, OP_IsNull, regData+i, ignoreDest);\n        break;\n      }\n      default: {\n        assert( onError==OE_Replace );\n        j1 = sqlite3VdbeAddOp1(v, OP_NotNull, regData+i);\n        sqlite3ExprCode(pParse, pTab->aCol[i].pDflt, regData+i);\n        sqlite3VdbeJumpHere(v, j1);\n        break;\n      }\n    }\n  }\n\n  /* Test all CHECK constraints\n  */\n#ifndef SQLITE_OMIT_CHECK\n  if( pTab->pCheck && (pParse->db->flags & SQLITE_IgnoreChecks)==0 ){\n    int allOk = sqlite3VdbeMakeLabel(v);\n    pParse->ckBase = regData;\n    sqlite3ExprIfTrue(pParse, pTab->pCheck, allOk, SQLITE_JUMPIFNULL);\n    onError = overrideError!=OE_Default ? overrideError : OE_Abort;\n    if( onError==OE_Ignore ){\n      sqlite3VdbeAddOp2(v, OP_Goto, 0, ignoreDest);\n    }else{\n      if( onError==OE_Replace ) onError = OE_Abort; /* IMP: R-15569-63625 */\n      sqlite3HaltConstraint(pParse, onError, 0, 0);\n    }\n    sqlite3VdbeResolveLabel(v, allOk);\n  }\n#endif /* !defined(SQLITE_OMIT_CHECK) */\n\n  /* If we have an INTEGER PRIMARY KEY, make sure the primary key\n  ** of the new record does not previously exist.  Except, if this\n  ** is an UPDATE and the primary key is not changing, that is OK.\n  */\n  if( rowidChng ){\n    onError = pTab->keyConf;\n    if( overrideError!=OE_Default ){\n      onError = overrideError;\n    }else if( onError==OE_Default ){\n      onError = OE_Abort;\n    }\n    \n    if( isUpdate ){\n      j2 = sqlite3VdbeAddOp3(v, OP_Eq, regRowid, 0, rowidChng);\n    }\n    j3 = sqlite3VdbeAddOp3(v, OP_NotExists, baseCur, 0, regRowid);\n    switch( onError ){\n      default: {\n        onError = OE_Abort;\n        /* Fall thru into the next case */\n      }\n      case OE_Rollback:\n      case OE_Abort:\n      case OE_Fail: {\n        sqlite3HaltConstraint(\n          pParse, onError, \"PRIMARY KEY must be unique\", P4_STATIC);\n        break;\n      }\n      case OE_Replace: {\n        /* If there are DELETE triggers on this table and the\n        ** recursive-triggers flag is set, call GenerateRowDelete() to\n        ** remove the conflicting row from the the table. This will fire\n        ** the triggers and remove both the table and index b-tree entries.\n        **\n        ** Otherwise, if there are no triggers or the recursive-triggers\n        ** flag is not set, but the table has one or more indexes, call \n        ** GenerateRowIndexDelete(). This removes the index b-tree entries \n        ** only. The table b-tree entry will be replaced by the new entry \n        ** when it is inserted.  \n        **\n        ** If either GenerateRowDelete() or GenerateRowIndexDelete() is called,\n        ** also invoke MultiWrite() to indicate that this VDBE may require\n        ** statement rollback (if the statement is aborted after the delete\n        ** takes place). Earlier versions called sqlite3MultiWrite() regardless,\n        ** but being more selective here allows statements like:\n        **\n        **   REPLACE INTO t(rowid) VALUES($newrowid)\n        **\n        ** to run without a statement journal if there are no indexes on the\n        ** table.\n        */\n        Trigger *pTrigger = 0;\n        if( pParse->db->flags&SQLITE_RecTriggers ){\n          pTrigger = sqlite3TriggersExist(pParse, pTab, TK_DELETE, 0, 0);\n        }\n        if( pTrigger || sqlite3FkRequired(pParse, pTab, 0, 0) ){\n          sqlite3MultiWrite(pParse);\n          sqlite3GenerateRowDelete(\n              pParse, pTab, baseCur, regRowid, 0, pTrigger, OE_Replace\n          );\n        }else if( pTab->pIndex ){\n          sqlite3MultiWrite(pParse);\n          sqlite3GenerateRowIndexDelete(pParse, pTab, baseCur, 0);\n        }\n        seenReplace = 1;\n        break;\n      }\n      case OE_Ignore: {\n        assert( seenReplace==0 );\n        sqlite3VdbeAddOp2(v, OP_Goto, 0, ignoreDest);\n        break;\n      }\n    }\n    sqlite3VdbeJumpHere(v, j3);\n    if( isUpdate ){\n      sqlite3VdbeJumpHere(v, j2);\n    }\n  }\n\n  /* Test all UNIQUE constraints by creating entries for each UNIQUE\n  ** index and making sure that duplicate entries do not already exist.\n  ** Add the new records to the indices as we go.\n  */\n  for(iCur=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, iCur++){\n    int regIdx;\n#ifndef SQLITE_OMIT_UNIQUE_ENFORCEMENT\n    int regR;\n#endif\n    if( aRegIdx[iCur]==0 ) continue;  /* Skip unused indices */\n\n    /* Create a key for accessing the index entry */\n    regIdx = sqlite3GetTempRange(pParse, pIdx->nColumn+1);\n    for(i=0; i<pIdx->nColumn; i++){\n      int idx = pIdx->aiColumn[i];\n      if( idx==pTab->iPKey ){\n        sqlite3VdbeAddOp2(v, OP_SCopy, regRowid, regIdx+i);\n      }else{\n        sqlite3VdbeAddOp2(v, OP_SCopy, regData+idx, regIdx+i);\n      }\n    }\n    sqlite3VdbeAddOp2(v, OP_SCopy, regRowid, regIdx+i);\n    sqlite3VdbeAddOp3(v, OP_MakeRecord, regIdx, pIdx->nColumn+1, aRegIdx[iCur]);\n    sqlite3VdbeChangeP4(v, -1, sqlite3IndexAffinityStr(v, pIdx), 0);\n    sqlite3ExprCacheAffinityChange(pParse, regIdx, pIdx->nColumn+1);\n\n#ifdef SQLITE_OMIT_UNIQUE_ENFORCEMENT\n    sqlite3ReleaseTempRange(pParse, regIdx, pIdx->nColumn+1);\n    continue;  /* Treat pIdx as if it is not a UNIQUE index */\n#else\n\n    /* Find out what action to take in case there is an indexing conflict */\n    onError = pIdx->onError;\n    if( onError==OE_None ){ \n      sqlite3ReleaseTempRange(pParse, regIdx, pIdx->nColumn+1);\n      continue;  /* pIdx is not a UNIQUE index */\n    }\n    if( overrideError!=OE_Default ){\n      onError = overrideError;\n    }else if( onError==OE_Default ){\n      onError = OE_Abort;\n    }\n    if( seenReplace ){\n      if( onError==OE_Ignore ) onError = OE_Replace;\n      else if( onError==OE_Fail ) onError = OE_Abort;\n    }\n    \n    /* Check to see if the new index entry will be unique */\n    regR = sqlite3GetTempReg(pParse);\n    sqlite3VdbeAddOp2(v, OP_SCopy, regOldRowid, regR);\n    j3 = sqlite3VdbeAddOp4(v, OP_IsUnique, baseCur+iCur+1, 0,\n                           regR, SQLITE_INT_TO_PTR(regIdx),\n                           P4_INT32);\n    sqlite3ReleaseTempRange(pParse, regIdx, pIdx->nColumn+1);\n\n    /* Generate code that executes if the new index entry is not unique */\n    assert( onError==OE_Rollback || onError==OE_Abort || onError==OE_Fail\n        || onError==OE_Ignore || onError==OE_Replace );\n    switch( onError ){\n      case OE_Rollback:\n      case OE_Abort:\n      case OE_Fail: {\n        int j;\n        StrAccum errMsg;\n        const char *zSep;\n        char *zErr;\n\n        sqlite3StrAccumInit(&errMsg, 0, 0, 200);\n        errMsg.db = pParse->db;\n        zSep = pIdx->nColumn>1 ? \"columns \" : \"column \";\n        for(j=0; j<pIdx->nColumn; j++){\n          char *zCol = pTab->aCol[pIdx->aiColumn[j]].zName;\n          sqlite3StrAccumAppend(&errMsg, zSep, -1);\n          zSep = \", \";\n          sqlite3StrAccumAppend(&errMsg, zCol, -1);\n        }\n        sqlite3StrAccumAppend(&errMsg,\n            pIdx->nColumn>1 ? \" are not unique\" : \" is not unique\", -1);\n        zErr = sqlite3StrAccumFinish(&errMsg);\n        sqlite3HaltConstraint(pParse, onError, zErr, 0);\n        sqlite3DbFree(errMsg.db, zErr);\n        break;\n      }\n      case OE_Ignore: {\n        assert( seenReplace==0 );\n        sqlite3VdbeAddOp2(v, OP_Goto, 0, ignoreDest);\n        break;\n      }\n      default: {\n        Trigger *pTrigger = 0;\n        assert( onError==OE_Replace );\n        sqlite3MultiWrite(pParse);\n        if( pParse->db->flags&SQLITE_RecTriggers ){\n          pTrigger = sqlite3TriggersExist(pParse, pTab, TK_DELETE, 0, 0);\n        }\n        sqlite3GenerateRowDelete(\n            pParse, pTab, baseCur, regR, 0, pTrigger, OE_Replace\n        );\n        seenReplace = 1;\n        break;\n      }\n    }\n    sqlite3VdbeJumpHere(v, j3);\n    sqlite3ReleaseTempReg(pParse, regR);\n#endif\n  }\n  \n  if( pbMayReplace ){\n    *pbMayReplace = seenReplace;\n  }\n}\n\n/*\n** This routine generates code to finish the INSERT or UPDATE operation\n** that was started by a prior call to sqlite3GenerateConstraintChecks.\n** A consecutive range of registers starting at regRowid contains the\n** rowid and the content to be inserted.\n**\n** The arguments to this routine should be the same as the first six\n** arguments to sqlite3GenerateConstraintChecks.\n*/\nSQLITE_PRIVATE void sqlite3CompleteInsertion(\n  Parse *pParse,      /* The parser context */\n  Table *pTab,        /* the table into which we are inserting */\n  int baseCur,        /* Index of a read/write cursor pointing at pTab */\n  int regRowid,       /* Range of content */\n  int *aRegIdx,       /* Register used by each index.  0 for unused indices */\n  int isUpdate,       /* True for UPDATE, False for INSERT */\n  int appendBias,     /* True if this is likely to be an append */\n  int useSeekResult   /* True to set the USESEEKRESULT flag on OP_[Idx]Insert */\n){\n  int i;\n  Vdbe *v;\n  int nIdx;\n  Index *pIdx;\n  u8 pik_flags;\n  int regData;\n  int regRec;\n\n  v = sqlite3GetVdbe(pParse);\n  assert( v!=0 );\n  assert( pTab->pSelect==0 );  /* This table is not a VIEW */\n  for(nIdx=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, nIdx++){}\n  for(i=nIdx-1; i>=0; i--){\n    if( aRegIdx[i]==0 ) continue;\n    sqlite3VdbeAddOp2(v, OP_IdxInsert, baseCur+i+1, aRegIdx[i]);\n    if( useSeekResult ){\n      sqlite3VdbeChangeP5(v, OPFLAG_USESEEKRESULT);\n    }\n  }\n  regData = regRowid + 1;\n  regRec = sqlite3GetTempReg(pParse);\n  sqlite3VdbeAddOp3(v, OP_MakeRecord, regData, pTab->nCol, regRec);\n  sqlite3TableAffinityStr(v, pTab);\n  sqlite3ExprCacheAffinityChange(pParse, regData, pTab->nCol);\n  if( pParse->nested ){\n    pik_flags = 0;\n  }else{\n    pik_flags = OPFLAG_NCHANGE;\n    pik_flags |= (isUpdate?OPFLAG_ISUPDATE:OPFLAG_LASTROWID);\n  }\n  if( appendBias ){\n    pik_flags |= OPFLAG_APPEND;\n  }\n  if( useSeekResult ){\n    pik_flags |= OPFLAG_USESEEKRESULT;\n  }\n  sqlite3VdbeAddOp3(v, OP_Insert, baseCur, regRec, regRowid);\n  if( !pParse->nested ){\n    sqlite3VdbeChangeP4(v, -1, pTab->zName, P4_STATIC);\n  }\n  sqlite3VdbeChangeP5(v, pik_flags);\n}\n\n/*\n** Generate code that will open cursors for a table and for all\n** indices of that table.  The \"baseCur\" parameter is the cursor number used\n** for the table.  Indices are opened on subsequent cursors.\n**\n** Return the number of indices on the table.\n*/\nSQLITE_PRIVATE int sqlite3OpenTableAndIndices(\n  Parse *pParse,   /* Parsing context */\n  Table *pTab,     /* Table to be opened */\n  int baseCur,     /* Cursor number assigned to the table */\n  int op           /* OP_OpenRead or OP_OpenWrite */\n){\n  int i;\n  int iDb;\n  Index *pIdx;\n  Vdbe *v;\n\n  if( IsVirtual(pTab) ) return 0;\n  iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);\n  v = sqlite3GetVdbe(pParse);\n  assert( v!=0 );\n  sqlite3OpenTable(pParse, baseCur, iDb, pTab, op);\n  for(i=1, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, i++){\n    KeyInfo *pKey = sqlite3IndexKeyinfo(pParse, pIdx);\n    assert( pIdx->pSchema==pTab->pSchema );\n    sqlite3VdbeAddOp4(v, op, i+baseCur, pIdx->tnum, iDb,\n                      (char*)pKey, P4_KEYINFO_HANDOFF);\n    VdbeComment((v, \"%s\", pIdx->zName));\n  }\n  if( pParse->nTab<baseCur+i ){\n    pParse->nTab = baseCur+i;\n  }\n  return i-1;\n}\n\n\n#ifdef SQLITE_TEST\n/*\n** The following global variable is incremented whenever the\n** transfer optimization is used.  This is used for testing\n** purposes only - to make sure the transfer optimization really\n** is happening when it is suppose to.\n*/\nSQLITE_API int sqlite3_xferopt_count;\n#endif /* SQLITE_TEST */\n\n\n#ifndef SQLITE_OMIT_XFER_OPT\n/*\n** Check to collation names to see if they are compatible.\n*/\nstatic int xferCompatibleCollation(const char *z1, const char *z2){\n  if( z1==0 ){\n    return z2==0;\n  }\n  if( z2==0 ){\n    return 0;\n  }\n  return sqlite3StrICmp(z1, z2)==0;\n}\n\n\n/*\n** Check to see if index pSrc is compatible as a source of data\n** for index pDest in an insert transfer optimization.  The rules\n** for a compatible index:\n**\n**    *   The index is over the same set of columns\n**    *   The same DESC and ASC markings occurs on all columns\n**    *   The same onError processing (OE_Abort, OE_Ignore, etc)\n**    *   The same collating sequence on each column\n*/\nstatic int xferCompatibleIndex(Index *pDest, Index *pSrc){\n  int i;\n  assert( pDest && pSrc );\n  assert( pDest->pTable!=pSrc->pTable );\n  if( pDest->nColumn!=pSrc->nColumn ){\n    return 0;   /* Different number of columns */\n  }\n  if( pDest->onError!=pSrc->onError ){\n    return 0;   /* Different conflict resolution strategies */\n  }\n  for(i=0; i<pSrc->nColumn; i++){\n    if( pSrc->aiColumn[i]!=pDest->aiColumn[i] ){\n      return 0;   /* Different columns indexed */\n    }\n    if( pSrc->aSortOrder[i]!=pDest->aSortOrder[i] ){\n      return 0;   /* Different sort orders */\n    }\n    if( !xferCompatibleCollation(pSrc->azColl[i],pDest->azColl[i]) ){\n      return 0;   /* Different collating sequences */\n    }\n  }\n\n  /* If no test above fails then the indices must be compatible */\n  return 1;\n}\n\n/*\n** Attempt the transfer optimization on INSERTs of the form\n**\n**     INSERT INTO tab1 SELECT * FROM tab2;\n**\n** This optimization is only attempted if\n**\n**    (1)  tab1 and tab2 have identical schemas including all the\n**         same indices and constraints\n**\n**    (2)  tab1 and tab2 are different tables\n**\n**    (3)  There must be no triggers on tab1\n**\n**    (4)  The result set of the SELECT statement is \"*\"\n**\n**    (5)  The SELECT statement has no WHERE, HAVING, ORDER BY, GROUP BY,\n**         or LIMIT clause.\n**\n**    (6)  The SELECT statement is a simple (not a compound) select that\n**         contains only tab2 in its FROM clause\n**\n** This method for implementing the INSERT transfers raw records from\n** tab2 over to tab1.  The columns are not decoded.  Raw records from\n** the indices of tab2 are transfered to tab1 as well.  In so doing,\n** the resulting tab1 has much less fragmentation.\n**\n** This routine returns TRUE if the optimization is attempted.  If any\n** of the conditions above fail so that the optimization should not\n** be attempted, then this routine returns FALSE.\n*/\nstatic int xferOptimization(\n  Parse *pParse,        /* Parser context */\n  Table *pDest,         /* The table we are inserting into */\n  Select *pSelect,      /* A SELECT statement to use as the data source */\n  int onError,          /* How to handle constraint errors */\n  int iDbDest           /* The database of pDest */\n){\n  ExprList *pEList;                /* The result set of the SELECT */\n  Table *pSrc;                     /* The table in the FROM clause of SELECT */\n  Index *pSrcIdx, *pDestIdx;       /* Source and destination indices */\n  struct SrcList_item *pItem;      /* An element of pSelect->pSrc */\n  int i;                           /* Loop counter */\n  int iDbSrc;                      /* The database of pSrc */\n  int iSrc, iDest;                 /* Cursors from source and destination */\n  int addr1, addr2;                /* Loop addresses */\n  int emptyDestTest;               /* Address of test for empty pDest */\n  int emptySrcTest;                /* Address of test for empty pSrc */\n  Vdbe *v;                         /* The VDBE we are building */\n  KeyInfo *pKey;                   /* Key information for an index */\n  int regAutoinc;                  /* Memory register used by AUTOINC */\n  int destHasUniqueIdx = 0;        /* True if pDest has a UNIQUE index */\n  int regData, regRowid;           /* Registers holding data and rowid */\n\n  if( pSelect==0 ){\n    return 0;   /* Must be of the form  INSERT INTO ... SELECT ... */\n  }\n  if( sqlite3TriggerList(pParse, pDest) ){\n    return 0;   /* tab1 must not have triggers */\n  }\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  if( pDest->tabFlags & TF_Virtual ){\n    return 0;   /* tab1 must not be a virtual table */\n  }\n#endif\n  if( onError==OE_Default ){\n    onError = OE_Abort;\n  }\n  if( onError!=OE_Abort && onError!=OE_Rollback ){\n    return 0;   /* Cannot do OR REPLACE or OR IGNORE or OR FAIL */\n  }\n  assert(pSelect->pSrc);   /* allocated even if there is no FROM clause */\n  if( pSelect->pSrc->nSrc!=1 ){\n    return 0;   /* FROM clause must have exactly one term */\n  }\n  if( pSelect->pSrc->a[0].pSelect ){\n    return 0;   /* FROM clause cannot contain a subquery */\n  }\n  if( pSelect->pWhere ){\n    return 0;   /* SELECT may not have a WHERE clause */\n  }\n  if( pSelect->pOrderBy ){\n    return 0;   /* SELECT may not have an ORDER BY clause */\n  }\n  /* Do not need to test for a HAVING clause.  If HAVING is present but\n  ** there is no ORDER BY, we will get an error. */\n  if( pSelect->pGroupBy ){\n    return 0;   /* SELECT may not have a GROUP BY clause */\n  }\n  if( pSelect->pLimit ){\n    return 0;   /* SELECT may not have a LIMIT clause */\n  }\n  assert( pSelect->pOffset==0 );  /* Must be so if pLimit==0 */\n  if( pSelect->pPrior ){\n    return 0;   /* SELECT may not be a compound query */\n  }\n  if( pSelect->selFlags & SF_Distinct ){\n    return 0;   /* SELECT may not be DISTINCT */\n  }\n  pEList = pSelect->pEList;\n  assert( pEList!=0 );\n  if( pEList->nExpr!=1 ){\n    return 0;   /* The result set must have exactly one column */\n  }\n  assert( pEList->a[0].pExpr );\n  if( pEList->a[0].pExpr->op!=TK_ALL ){\n    return 0;   /* The result set must be the special operator \"*\" */\n  }\n\n  /* At this point we have established that the statement is of the\n  ** correct syntactic form to participate in this optimization.  Now\n  ** we have to check the semantics.\n  */\n  pItem = pSelect->pSrc->a;\n  pSrc = sqlite3LocateTable(pParse, 0, pItem->zName, pItem->zDatabase);\n  if( pSrc==0 ){\n    return 0;   /* FROM clause does not contain a real table */\n  }\n  if( pSrc==pDest ){\n    return 0;   /* tab1 and tab2 may not be the same table */\n  }\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  if( pSrc->tabFlags & TF_Virtual ){\n    return 0;   /* tab2 must not be a virtual table */\n  }\n#endif\n  if( pSrc->pSelect ){\n    return 0;   /* tab2 may not be a view */\n  }\n  if( pDest->nCol!=pSrc->nCol ){\n    return 0;   /* Number of columns must be the same in tab1 and tab2 */\n  }\n  if( pDest->iPKey!=pSrc->iPKey ){\n    return 0;   /* Both tables must have the same INTEGER PRIMARY KEY */\n  }\n  for(i=0; i<pDest->nCol; i++){\n    if( pDest->aCol[i].affinity!=pSrc->aCol[i].affinity ){\n      return 0;    /* Affinity must be the same on all columns */\n    }\n    if( !xferCompatibleCollation(pDest->aCol[i].zColl, pSrc->aCol[i].zColl) ){\n      return 0;    /* Collating sequence must be the same on all columns */\n    }\n    if( pDest->aCol[i].notNull && !pSrc->aCol[i].notNull ){\n      return 0;    /* tab2 must be NOT NULL if tab1 is */\n    }\n  }\n  for(pDestIdx=pDest->pIndex; pDestIdx; pDestIdx=pDestIdx->pNext){\n    if( pDestIdx->onError!=OE_None ){\n      destHasUniqueIdx = 1;\n    }\n    for(pSrcIdx=pSrc->pIndex; pSrcIdx; pSrcIdx=pSrcIdx->pNext){\n      if( xferCompatibleIndex(pDestIdx, pSrcIdx) ) break;\n    }\n    if( pSrcIdx==0 ){\n      return 0;    /* pDestIdx has no corresponding index in pSrc */\n    }\n  }\n#ifndef SQLITE_OMIT_CHECK\n  if( pDest->pCheck && sqlite3ExprCompare(pSrc->pCheck, pDest->pCheck) ){\n    return 0;   /* Tables have different CHECK constraints.  Ticket #2252 */\n  }\n#endif\n\n  /* If we get this far, it means either:\n  **\n  **    *   We can always do the transfer if the table contains an\n  **        an integer primary key\n  **\n  **    *   We can conditionally do the transfer if the destination\n  **        table is empty.\n  */\n#ifdef SQLITE_TEST\n  sqlite3_xferopt_count++;\n#endif\n  iDbSrc = sqlite3SchemaToIndex(pParse->db, pSrc->pSchema);\n  v = sqlite3GetVdbe(pParse);\n  sqlite3CodeVerifySchema(pParse, iDbSrc);\n  iSrc = pParse->nTab++;\n  iDest = pParse->nTab++;\n  regAutoinc = autoIncBegin(pParse, iDbDest, pDest);\n  sqlite3OpenTable(pParse, iDest, iDbDest, pDest, OP_OpenWrite);\n  if( (pDest->iPKey<0 && pDest->pIndex!=0) || destHasUniqueIdx ){\n    /* If tables do not have an INTEGER PRIMARY KEY and there\n    ** are indices to be copied and the destination is not empty,\n    ** we have to disallow the transfer optimization because the\n    ** the rowids might change which will mess up indexing.\n    **\n    ** Or if the destination has a UNIQUE index and is not empty,\n    ** we also disallow the transfer optimization because we cannot\n    ** insure that all entries in the union of DEST and SRC will be\n    ** unique.\n    */\n    addr1 = sqlite3VdbeAddOp2(v, OP_Rewind, iDest, 0);\n    emptyDestTest = sqlite3VdbeAddOp2(v, OP_Goto, 0, 0);\n    sqlite3VdbeJumpHere(v, addr1);\n  }else{\n    emptyDestTest = 0;\n  }\n  sqlite3OpenTable(pParse, iSrc, iDbSrc, pSrc, OP_OpenRead);\n  emptySrcTest = sqlite3VdbeAddOp2(v, OP_Rewind, iSrc, 0);\n  regData = sqlite3GetTempReg(pParse);\n  regRowid = sqlite3GetTempReg(pParse);\n  if( pDest->iPKey>=0 ){\n    addr1 = sqlite3VdbeAddOp2(v, OP_Rowid, iSrc, regRowid);\n    addr2 = sqlite3VdbeAddOp3(v, OP_NotExists, iDest, 0, regRowid);\n    sqlite3HaltConstraint(\n        pParse, onError, \"PRIMARY KEY must be unique\", P4_STATIC);\n    sqlite3VdbeJumpHere(v, addr2);\n    autoIncStep(pParse, regAutoinc, regRowid);\n  }else if( pDest->pIndex==0 ){\n    addr1 = sqlite3VdbeAddOp2(v, OP_NewRowid, iDest, regRowid);\n  }else{\n    addr1 = sqlite3VdbeAddOp2(v, OP_Rowid, iSrc, regRowid);\n    assert( (pDest->tabFlags & TF_Autoincrement)==0 );\n  }\n  sqlite3VdbeAddOp2(v, OP_RowData, iSrc, regData);\n  sqlite3VdbeAddOp3(v, OP_Insert, iDest, regData, regRowid);\n  sqlite3VdbeChangeP5(v, OPFLAG_NCHANGE|OPFLAG_LASTROWID|OPFLAG_APPEND);\n  sqlite3VdbeChangeP4(v, -1, pDest->zName, 0);\n  sqlite3VdbeAddOp2(v, OP_Next, iSrc, addr1);\n  for(pDestIdx=pDest->pIndex; pDestIdx; pDestIdx=pDestIdx->pNext){\n    for(pSrcIdx=pSrc->pIndex; ALWAYS(pSrcIdx); pSrcIdx=pSrcIdx->pNext){\n      if( xferCompatibleIndex(pDestIdx, pSrcIdx) ) break;\n    }\n    assert( pSrcIdx );\n    sqlite3VdbeAddOp2(v, OP_Close, iSrc, 0);\n    sqlite3VdbeAddOp2(v, OP_Close, iDest, 0);\n    pKey = sqlite3IndexKeyinfo(pParse, pSrcIdx);\n    sqlite3VdbeAddOp4(v, OP_OpenRead, iSrc, pSrcIdx->tnum, iDbSrc,\n                      (char*)pKey, P4_KEYINFO_HANDOFF);\n    VdbeComment((v, \"%s\", pSrcIdx->zName));\n    pKey = sqlite3IndexKeyinfo(pParse, pDestIdx);\n    sqlite3VdbeAddOp4(v, OP_OpenWrite, iDest, pDestIdx->tnum, iDbDest,\n                      (char*)pKey, P4_KEYINFO_HANDOFF);\n    VdbeComment((v, \"%s\", pDestIdx->zName));\n    addr1 = sqlite3VdbeAddOp2(v, OP_Rewind, iSrc, 0);\n    sqlite3VdbeAddOp2(v, OP_RowKey, iSrc, regData);\n    sqlite3VdbeAddOp3(v, OP_IdxInsert, iDest, regData, 1);\n    sqlite3VdbeAddOp2(v, OP_Next, iSrc, addr1+1);\n    sqlite3VdbeJumpHere(v, addr1);\n  }\n  sqlite3VdbeJumpHere(v, emptySrcTest);\n  sqlite3ReleaseTempReg(pParse, regRowid);\n  sqlite3ReleaseTempReg(pParse, regData);\n  sqlite3VdbeAddOp2(v, OP_Close, iSrc, 0);\n  sqlite3VdbeAddOp2(v, OP_Close, iDest, 0);\n  if( emptyDestTest ){\n    sqlite3VdbeAddOp2(v, OP_Halt, SQLITE_OK, 0);\n    sqlite3VdbeJumpHere(v, emptyDestTest);\n    sqlite3VdbeAddOp2(v, OP_Close, iDest, 0);\n    return 0;\n  }else{\n    return 1;\n  }\n}\n#endif /* SQLITE_OMIT_XFER_OPT */\n\n/************** End of insert.c **********************************************/\n/************** Begin file legacy.c ******************************************/\n/*\n** 2001 September 15\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** Main file for the SQLite library.  The routines in this file\n** implement the programmer interface to the library.  Routines in\n** other files are for internal use by SQLite and should not be\n** accessed by users of the library.\n*/\n\n\n/*\n** Execute SQL code.  Return one of the SQLITE_ success/failure\n** codes.  Also write an error message into memory obtained from\n** malloc() and make *pzErrMsg point to that message.\n**\n** If the SQL is a query, then for each row in the query result\n** the xCallback() function is called.  pArg becomes the first\n** argument to xCallback().  If xCallback=NULL then no callback\n** is invoked, even for queries.\n*/\nSQLITE_API int sqlite3_exec(\n  sqlite3 *db,                /* The database on which the SQL executes */\n  const char *zSql,           /* The SQL to be executed */\n  sqlite3_callback xCallback, /* Invoke this callback routine */\n  void *pArg,                 /* First argument to xCallback() */\n  char **pzErrMsg             /* Write error messages here */\n){\n  int rc = SQLITE_OK;         /* Return code */\n  const char *zLeftover;      /* Tail of unprocessed SQL */\n  sqlite3_stmt *pStmt = 0;    /* The current SQL statement */\n  char **azCols = 0;          /* Names of result columns */\n  int nRetry = 0;             /* Number of retry attempts */\n  int callbackIsInit;         /* True if callback data is initialized */\n\n  if( !sqlite3SafetyCheckOk(db) ) return SQLITE_MISUSE_BKPT;\n  if( zSql==0 ) zSql = \"\";\n\n  sqlite3_mutex_enter(db->mutex);\n  sqlite3Error(db, SQLITE_OK, 0);\n  while( (rc==SQLITE_OK || (rc==SQLITE_SCHEMA && (++nRetry)<2)) && zSql[0] ){\n    int nCol;\n    char **azVals = 0;\n\n    pStmt = 0;\n    rc = sqlite3_prepare(db, zSql, -1, &pStmt, &zLeftover);\n    assert( rc==SQLITE_OK || pStmt==0 );\n    if( rc!=SQLITE_OK ){\n      continue;\n    }\n    if( !pStmt ){\n      /* this happens for a comment or white-space */\n      zSql = zLeftover;\n      continue;\n    }\n\n    callbackIsInit = 0;\n    nCol = sqlite3_column_count(pStmt);\n\n    while( 1 ){\n      int i;\n      rc = sqlite3_step(pStmt);\n\n      /* Invoke the callback function if required */\n      if( xCallback && (SQLITE_ROW==rc || \n          (SQLITE_DONE==rc && !callbackIsInit\n                           && db->flags&SQLITE_NullCallback)) ){\n        if( !callbackIsInit ){\n          azCols = sqlite3DbMallocZero(db, 2*nCol*sizeof(const char*) + 1);\n          if( azCols==0 ){\n            goto exec_out;\n          }\n          for(i=0; i<nCol; i++){\n            azCols[i] = (char *)sqlite3_column_name(pStmt, i);\n            /* sqlite3VdbeSetColName() installs column names as UTF8\n            ** strings so there is no way for sqlite3_column_name() to fail. */\n            assert( azCols[i]!=0 );\n          }\n          callbackIsInit = 1;\n        }\n        if( rc==SQLITE_ROW ){\n          azVals = &azCols[nCol];\n          for(i=0; i<nCol; i++){\n            azVals[i] = (char *)sqlite3_column_text(pStmt, i);\n            if( !azVals[i] && sqlite3_column_type(pStmt, i)!=SQLITE_NULL ){\n              db->mallocFailed = 1;\n              goto exec_out;\n            }\n          }\n        }\n        if( xCallback(pArg, nCol, azVals, azCols) ){\n          rc = SQLITE_ABORT;\n          sqlite3VdbeFinalize((Vdbe *)pStmt);\n          pStmt = 0;\n          sqlite3Error(db, SQLITE_ABORT, 0);\n          goto exec_out;\n        }\n      }\n\n      if( rc!=SQLITE_ROW ){\n        rc = sqlite3VdbeFinalize((Vdbe *)pStmt);\n        pStmt = 0;\n        if( rc!=SQLITE_SCHEMA ){\n          nRetry = 0;\n          zSql = zLeftover;\n          while( sqlite3Isspace(zSql[0]) ) zSql++;\n        }\n        break;\n      }\n    }\n\n    sqlite3DbFree(db, azCols);\n    azCols = 0;\n  }\n\nexec_out:\n  if( pStmt ) sqlite3VdbeFinalize((Vdbe *)pStmt);\n  sqlite3DbFree(db, azCols);\n\n  rc = sqlite3ApiExit(db, rc);\n  if( rc!=SQLITE_OK && ALWAYS(rc==sqlite3_errcode(db)) && pzErrMsg ){\n    int nErrMsg = 1 + sqlite3Strlen30(sqlite3_errmsg(db));\n    *pzErrMsg = sqlite3Malloc(nErrMsg);\n    if( *pzErrMsg ){\n      memcpy(*pzErrMsg, sqlite3_errmsg(db), nErrMsg);\n    }else{\n      rc = SQLITE_NOMEM;\n      sqlite3Error(db, SQLITE_NOMEM, 0);\n    }\n  }else if( pzErrMsg ){\n    *pzErrMsg = 0;\n  }\n\n  assert( (rc&db->errMask)==rc );\n  sqlite3_mutex_leave(db->mutex);\n  return rc;\n}\n\n/************** End of legacy.c **********************************************/\n/************** Begin file loadext.c *****************************************/\n/*\n** 2006 June 7\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains code used to dynamically load extensions into\n** the SQLite library.\n*/\n\n#ifndef SQLITE_CORE\n  #define SQLITE_CORE 1  /* Disable the API redefinition in sqlite3ext.h */\n#endif\n/************** Include sqlite3ext.h in the middle of loadext.c **************/\n/************** Begin file sqlite3ext.h **************************************/\n/*\n** 2006 June 7\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This header file defines the SQLite interface for use by\n** shared libraries that want to be imported as extensions into\n** an SQLite instance.  Shared libraries that intend to be loaded\n** as extensions by SQLite should #include this file instead of \n** sqlite3.h.\n*/\n#ifndef _SQLITE3EXT_H_\n#define _SQLITE3EXT_H_\n\ntypedef struct sqlite3_api_routines sqlite3_api_routines;\n\n/*\n** The following structure holds pointers to all of the SQLite API\n** routines.\n**\n** WARNING:  In order to maintain backwards compatibility, add new\n** interfaces to the end of this structure only.  If you insert new\n** interfaces in the middle of this structure, then older different\n** versions of SQLite will not be able to load each others' shared\n** libraries!\n*/\nstruct sqlite3_api_routines {\n  void * (*aggregate_context)(sqlite3_context*,int nBytes);\n  int  (*aggregate_count)(sqlite3_context*);\n  int  (*bind_blob)(sqlite3_stmt*,int,const void*,int n,void(*)(void*));\n  int  (*bind_double)(sqlite3_stmt*,int,double);\n  int  (*bind_int)(sqlite3_stmt*,int,int);\n  int  (*bind_int64)(sqlite3_stmt*,int,sqlite_int64);\n  int  (*bind_null)(sqlite3_stmt*,int);\n  int  (*bind_parameter_count)(sqlite3_stmt*);\n  int  (*bind_parameter_index)(sqlite3_stmt*,const char*zName);\n  const char * (*bind_parameter_name)(sqlite3_stmt*,int);\n  int  (*bind_text)(sqlite3_stmt*,int,const char*,int n,void(*)(void*));\n  int  (*bind_text16)(sqlite3_stmt*,int,const void*,int,void(*)(void*));\n  int  (*bind_value)(sqlite3_stmt*,int,const sqlite3_value*);\n  int  (*busy_handler)(sqlite3*,int(*)(void*,int),void*);\n  int  (*busy_timeout)(sqlite3*,int ms);\n  int  (*changes)(sqlite3*);\n  int  (*close)(sqlite3*);\n  int  (*collation_needed)(sqlite3*,void*,void(*)(void*,sqlite3*,int eTextRep,const char*));\n  int  (*collation_needed16)(sqlite3*,void*,void(*)(void*,sqlite3*,int eTextRep,const void*));\n  const void * (*column_blob)(sqlite3_stmt*,int iCol);\n  int  (*column_bytes)(sqlite3_stmt*,int iCol);\n  int  (*column_bytes16)(sqlite3_stmt*,int iCol);\n  int  (*column_count)(sqlite3_stmt*pStmt);\n  const char * (*column_database_name)(sqlite3_stmt*,int);\n  const void * (*column_database_name16)(sqlite3_stmt*,int);\n  const char * (*column_decltype)(sqlite3_stmt*,int i);\n  const void * (*column_decltype16)(sqlite3_stmt*,int);\n  double  (*column_double)(sqlite3_stmt*,int iCol);\n  int  (*column_int)(sqlite3_stmt*,int iCol);\n  sqlite_int64  (*column_int64)(sqlite3_stmt*,int iCol);\n  const char * (*column_name)(sqlite3_stmt*,int);\n  const void * (*column_name16)(sqlite3_stmt*,int);\n  const char * (*column_origin_name)(sqlite3_stmt*,int);\n  const void * (*column_origin_name16)(sqlite3_stmt*,int);\n  const char * (*column_table_name)(sqlite3_stmt*,int);\n  const void * (*column_table_name16)(sqlite3_stmt*,int);\n  const unsigned char * (*column_text)(sqlite3_stmt*,int iCol);\n  const void * (*column_text16)(sqlite3_stmt*,int iCol);\n  int  (*column_type)(sqlite3_stmt*,int iCol);\n  sqlite3_value* (*column_value)(sqlite3_stmt*,int iCol);\n  void * (*commit_hook)(sqlite3*,int(*)(void*),void*);\n  int  (*complete)(const char*sql);\n  int  (*complete16)(const void*sql);\n  int  (*create_collation)(sqlite3*,const char*,int,void*,int(*)(void*,int,const void*,int,const void*));\n  int  (*create_collation16)(sqlite3*,const void*,int,void*,int(*)(void*,int,const void*,int,const void*));\n  int  (*create_function)(sqlite3*,const char*,int,int,void*,void (*xFunc)(sqlite3_context*,int,sqlite3_value**),void (*xStep)(sqlite3_context*,int,sqlite3_value**),void (*xFinal)(sqlite3_context*));\n  int  (*create_function16)(sqlite3*,const void*,int,int,void*,void (*xFunc)(sqlite3_context*,int,sqlite3_value**),void (*xStep)(sqlite3_context*,int,sqlite3_value**),void (*xFinal)(sqlite3_context*));\n  int (*create_module)(sqlite3*,const char*,const sqlite3_module*,void*);\n  int  (*data_count)(sqlite3_stmt*pStmt);\n  sqlite3 * (*db_handle)(sqlite3_stmt*);\n  int (*declare_vtab)(sqlite3*,const char*);\n  int  (*enable_shared_cache)(int);\n  int  (*errcode)(sqlite3*db);\n  const char * (*errmsg)(sqlite3*);\n  const void * (*errmsg16)(sqlite3*);\n  int  (*exec)(sqlite3*,const char*,sqlite3_callback,void*,char**);\n  int  (*expired)(sqlite3_stmt*);\n  int  (*finalize)(sqlite3_stmt*pStmt);\n  void  (*free)(void*);\n  void  (*free_table)(char**result);\n  int  (*get_autocommit)(sqlite3*);\n  void * (*get_auxdata)(sqlite3_context*,int);\n  int  (*get_table)(sqlite3*,const char*,char***,int*,int*,char**);\n  int  (*global_recover)(void);\n  void  (*interruptx)(sqlite3*);\n  sqlite_int64  (*last_insert_rowid)(sqlite3*);\n  const char * (*libversion)(void);\n  int  (*libversion_number)(void);\n  void *(*malloc)(int);\n  char * (*mprintf)(const char*,...);\n  int  (*open)(const char*,sqlite3**);\n  int  (*open16)(const void*,sqlite3**);\n  int  (*prepare)(sqlite3*,const char*,int,sqlite3_stmt**,const char**);\n  int  (*prepare16)(sqlite3*,const void*,int,sqlite3_stmt**,const void**);\n  void * (*profile)(sqlite3*,void(*)(void*,const char*,sqlite_uint64),void*);\n  void  (*progress_handler)(sqlite3*,int,int(*)(void*),void*);\n  void *(*realloc)(void*,int);\n  int  (*reset)(sqlite3_stmt*pStmt);\n  void  (*result_blob)(sqlite3_context*,const void*,int,void(*)(void*));\n  void  (*result_double)(sqlite3_context*,double);\n  void  (*result_error)(sqlite3_context*,const char*,int);\n  void  (*result_error16)(sqlite3_context*,const void*,int);\n  void  (*result_int)(sqlite3_context*,int);\n  void  (*result_int64)(sqlite3_context*,sqlite_int64);\n  void  (*result_null)(sqlite3_context*);\n  void  (*result_text)(sqlite3_context*,const char*,int,void(*)(void*));\n  void  (*result_text16)(sqlite3_context*,const void*,int,void(*)(void*));\n  void  (*result_text16be)(sqlite3_context*,const void*,int,void(*)(void*));\n  void  (*result_text16le)(sqlite3_context*,const void*,int,void(*)(void*));\n  void  (*result_value)(sqlite3_context*,sqlite3_value*);\n  void * (*rollback_hook)(sqlite3*,void(*)(void*),void*);\n  int  (*set_authorizer)(sqlite3*,int(*)(void*,int,const char*,const char*,const char*,const char*),void*);\n  void  (*set_auxdata)(sqlite3_context*,int,void*,void (*)(void*));\n  char * (*snprintf)(int,char*,const char*,...);\n  int  (*step)(sqlite3_stmt*);\n  int  (*table_column_metadata)(sqlite3*,const char*,const char*,const char*,char const**,char const**,int*,int*,int*);\n  void  (*thread_cleanup)(void);\n  int  (*total_changes)(sqlite3*);\n  void * (*trace)(sqlite3*,void(*xTrace)(void*,const char*),void*);\n  int  (*transfer_bindings)(sqlite3_stmt*,sqlite3_stmt*);\n  void * (*update_hook)(sqlite3*,void(*)(void*,int ,char const*,char const*,sqlite_int64),void*);\n  void * (*user_data)(sqlite3_context*);\n  const void * (*value_blob)(sqlite3_value*);\n  int  (*value_bytes)(sqlite3_value*);\n  int  (*value_bytes16)(sqlite3_value*);\n  double  (*value_double)(sqlite3_value*);\n  int  (*value_int)(sqlite3_value*);\n  sqlite_int64  (*value_int64)(sqlite3_value*);\n  int  (*value_numeric_type)(sqlite3_value*);\n  const unsigned char * (*value_text)(sqlite3_value*);\n  const void * (*value_text16)(sqlite3_value*);\n  const void * (*value_text16be)(sqlite3_value*);\n  const void * (*value_text16le)(sqlite3_value*);\n  int  (*value_type)(sqlite3_value*);\n  char *(*vmprintf)(const char*,va_list);\n  /* Added ??? */\n  int (*overload_function)(sqlite3*, const char *zFuncName, int nArg);\n  /* Added by 3.3.13 */\n  int (*prepare_v2)(sqlite3*,const char*,int,sqlite3_stmt**,const char**);\n  int (*prepare16_v2)(sqlite3*,const void*,int,sqlite3_stmt**,const void**);\n  int (*clear_bindings)(sqlite3_stmt*);\n  /* Added by 3.4.1 */\n  int (*create_module_v2)(sqlite3*,const char*,const sqlite3_module*,void*,void (*xDestroy)(void *));\n  /* Added by 3.5.0 */\n  int (*bind_zeroblob)(sqlite3_stmt*,int,int);\n  int (*blob_bytes)(sqlite3_blob*);\n  int (*blob_close)(sqlite3_blob*);\n  int (*blob_open)(sqlite3*,const char*,const char*,const char*,sqlite3_int64,int,sqlite3_blob**);\n  int (*blob_read)(sqlite3_blob*,void*,int,int);\n  int (*blob_write)(sqlite3_blob*,const void*,int,int);\n  int (*create_collation_v2)(sqlite3*,const char*,int,void*,int(*)(void*,int,const void*,int,const void*),void(*)(void*));\n  int (*file_control)(sqlite3*,const char*,int,void*);\n  sqlite3_int64 (*memory_highwater)(int);\n  sqlite3_int64 (*memory_used)(void);\n  sqlite3_mutex *(*mutex_alloc)(int);\n  void (*mutex_enter)(sqlite3_mutex*);\n  void (*mutex_free)(sqlite3_mutex*);\n  void (*mutex_leave)(sqlite3_mutex*);\n  int (*mutex_try)(sqlite3_mutex*);\n  int (*open_v2)(const char*,sqlite3**,int,const char*);\n  int (*release_memory)(int);\n  void (*result_error_nomem)(sqlite3_context*);\n  void (*result_error_toobig)(sqlite3_context*);\n  int (*sleep)(int);\n  void (*soft_heap_limit)(int);\n  sqlite3_vfs *(*vfs_find)(const char*);\n  int (*vfs_register)(sqlite3_vfs*,int);\n  int (*vfs_unregister)(sqlite3_vfs*);\n  int (*xthreadsafe)(void);\n  void (*result_zeroblob)(sqlite3_context*,int);\n  void (*result_error_code)(sqlite3_context*,int);\n  int (*test_control)(int, ...);\n  void (*randomness)(int,void*);\n  sqlite3 *(*context_db_handle)(sqlite3_context*);\n  int (*extended_result_codes)(sqlite3*,int);\n  int (*limit)(sqlite3*,int,int);\n  sqlite3_stmt *(*next_stmt)(sqlite3*,sqlite3_stmt*);\n  const char *(*sql)(sqlite3_stmt*);\n  int (*status)(int,int*,int*,int);\n  int (*backup_finish)(sqlite3_backup*);\n  sqlite3_backup *(*backup_init)(sqlite3*,const char*,sqlite3*,const char*);\n  int (*backup_pagecount)(sqlite3_backup*);\n  int (*backup_remaining)(sqlite3_backup*);\n  int (*backup_step)(sqlite3_backup*,int);\n  const char *(*compileoption_get)(int);\n  int (*compileoption_used)(const char*);\n  int (*create_function_v2)(sqlite3*,const char*,int,int,void*,void (*xFunc)(sqlite3_context*,int,sqlite3_value**),void (*xStep)(sqlite3_context*,int,sqlite3_value**),void (*xFinal)(sqlite3_context*),void(*xDestroy)(void*));\n  int (*db_config)(sqlite3*,int,...);\n  sqlite3_mutex *(*db_mutex)(sqlite3*);\n  int (*db_status)(sqlite3*,int,int*,int*,int);\n  int (*extended_errcode)(sqlite3*);\n  void (*log)(int,const char*,...);\n  sqlite3_int64 (*soft_heap_limit64)(sqlite3_int64);\n  const char *(*sourceid)(void);\n  int (*stmt_status)(sqlite3_stmt*,int,int);\n  int (*strnicmp)(const char*,const char*,int);\n  int (*unlock_notify)(sqlite3*,void(*)(void**,int),void*);\n  int (*wal_autocheckpoint)(sqlite3*,int);\n  int (*wal_checkpoint)(sqlite3*,const char*);\n  void *(*wal_hook)(sqlite3*,int(*)(void*,sqlite3*,const char*,int),void*);\n};\n\n/*\n** The following macros redefine the API routines so that they are\n** redirected throught the global sqlite3_api structure.\n**\n** This header file is also used by the loadext.c source file\n** (part of the main SQLite library - not an extension) so that\n** it can get access to the sqlite3_api_routines structure\n** definition.  But the main library does not want to redefine\n** the API.  So the redefinition macros are only valid if the\n** SQLITE_CORE macros is undefined.\n*/\n#ifndef SQLITE_CORE\n#define sqlite3_aggregate_context      sqlite3_api->aggregate_context\n#ifndef SQLITE_OMIT_DEPRECATED\n#define sqlite3_aggregate_count        sqlite3_api->aggregate_count\n#endif\n#define sqlite3_bind_blob              sqlite3_api->bind_blob\n#define sqlite3_bind_double            sqlite3_api->bind_double\n#define sqlite3_bind_int               sqlite3_api->bind_int\n#define sqlite3_bind_int64             sqlite3_api->bind_int64\n#define sqlite3_bind_null              sqlite3_api->bind_null\n#define sqlite3_bind_parameter_count   sqlite3_api->bind_parameter_count\n#define sqlite3_bind_parameter_index   sqlite3_api->bind_parameter_index\n#define sqlite3_bind_parameter_name    sqlite3_api->bind_parameter_name\n#define sqlite3_bind_text              sqlite3_api->bind_text\n#define sqlite3_bind_text16            sqlite3_api->bind_text16\n#define sqlite3_bind_value             sqlite3_api->bind_value\n#define sqlite3_busy_handler           sqlite3_api->busy_handler\n#define sqlite3_busy_timeout           sqlite3_api->busy_timeout\n#define sqlite3_changes                sqlite3_api->changes\n#define sqlite3_close                  sqlite3_api->close\n#define sqlite3_collation_needed       sqlite3_api->collation_needed\n#define sqlite3_collation_needed16     sqlite3_api->collation_needed16\n#define sqlite3_column_blob            sqlite3_api->column_blob\n#define sqlite3_column_bytes           sqlite3_api->column_bytes\n#define sqlite3_column_bytes16         sqlite3_api->column_bytes16\n#define sqlite3_column_count           sqlite3_api->column_count\n#define sqlite3_column_database_name   sqlite3_api->column_database_name\n#define sqlite3_column_database_name16 sqlite3_api->column_database_name16\n#define sqlite3_column_decltype        sqlite3_api->column_decltype\n#define sqlite3_column_decltype16      sqlite3_api->column_decltype16\n#define sqlite3_column_double          sqlite3_api->column_double\n#define sqlite3_column_int             sqlite3_api->column_int\n#define sqlite3_column_int64           sqlite3_api->column_int64\n#define sqlite3_column_name            sqlite3_api->column_name\n#define sqlite3_column_name16          sqlite3_api->column_name16\n#define sqlite3_column_origin_name     sqlite3_api->column_origin_name\n#define sqlite3_column_origin_name16   sqlite3_api->column_origin_name16\n#define sqlite3_column_table_name      sqlite3_api->column_table_name\n#define sqlite3_column_table_name16    sqlite3_api->column_table_name16\n#define sqlite3_column_text            sqlite3_api->column_text\n#define sqlite3_column_text16          sqlite3_api->column_text16\n#define sqlite3_column_type            sqlite3_api->column_type\n#define sqlite3_column_value           sqlite3_api->column_value\n#define sqlite3_commit_hook            sqlite3_api->commit_hook\n#define sqlite3_complete               sqlite3_api->complete\n#define sqlite3_complete16             sqlite3_api->complete16\n#define sqlite3_create_collation       sqlite3_api->create_collation\n#define sqlite3_create_collation16     sqlite3_api->create_collation16\n#define sqlite3_create_function        sqlite3_api->create_function\n#define sqlite3_create_function16      sqlite3_api->create_function16\n#define sqlite3_create_module          sqlite3_api->create_module\n#define sqlite3_create_module_v2       sqlite3_api->create_module_v2\n#define sqlite3_data_count             sqlite3_api->data_count\n#define sqlite3_db_handle              sqlite3_api->db_handle\n#define sqlite3_declare_vtab           sqlite3_api->declare_vtab\n#define sqlite3_enable_shared_cache    sqlite3_api->enable_shared_cache\n#define sqlite3_errcode                sqlite3_api->errcode\n#define sqlite3_errmsg                 sqlite3_api->errmsg\n#define sqlite3_errmsg16               sqlite3_api->errmsg16\n#define sqlite3_exec                   sqlite3_api->exec\n#ifndef SQLITE_OMIT_DEPRECATED\n#define sqlite3_expired                sqlite3_api->expired\n#endif\n#define sqlite3_finalize               sqlite3_api->finalize\n#define sqlite3_free                   sqlite3_api->free\n#define sqlite3_free_table             sqlite3_api->free_table\n#define sqlite3_get_autocommit         sqlite3_api->get_autocommit\n#define sqlite3_get_auxdata            sqlite3_api->get_auxdata\n#define sqlite3_get_table              sqlite3_api->get_table\n#ifndef SQLITE_OMIT_DEPRECATED\n#define sqlite3_global_recover         sqlite3_api->global_recover\n#endif\n#define sqlite3_interrupt              sqlite3_api->interruptx\n#define sqlite3_last_insert_rowid      sqlite3_api->last_insert_rowid\n#define sqlite3_libversion             sqlite3_api->libversion\n#define sqlite3_libversion_number      sqlite3_api->libversion_number\n#define sqlite3_malloc                 sqlite3_api->malloc\n#define sqlite3_mprintf                sqlite3_api->mprintf\n#define sqlite3_open                   sqlite3_api->open\n#define sqlite3_open16                 sqlite3_api->open16\n#define sqlite3_prepare                sqlite3_api->prepare\n#define sqlite3_prepare16              sqlite3_api->prepare16\n#define sqlite3_prepare_v2             sqlite3_api->prepare_v2\n#define sqlite3_prepare16_v2           sqlite3_api->prepare16_v2\n#define sqlite3_profile                sqlite3_api->profile\n#define sqlite3_progress_handler       sqlite3_api->progress_handler\n#define sqlite3_realloc                sqlite3_api->realloc\n#define sqlite3_reset                  sqlite3_api->reset\n#define sqlite3_result_blob            sqlite3_api->result_blob\n#define sqlite3_result_double          sqlite3_api->result_double\n#define sqlite3_result_error           sqlite3_api->result_error\n#define sqlite3_result_error16         sqlite3_api->result_error16\n#define sqlite3_result_int             sqlite3_api->result_int\n#define sqlite3_result_int64           sqlite3_api->result_int64\n#define sqlite3_result_null            sqlite3_api->result_null\n#define sqlite3_result_text            sqlite3_api->result_text\n#define sqlite3_result_text16          sqlite3_api->result_text16\n#define sqlite3_result_text16be        sqlite3_api->result_text16be\n#define sqlite3_result_text16le        sqlite3_api->result_text16le\n#define sqlite3_result_value           sqlite3_api->result_value\n#define sqlite3_rollback_hook          sqlite3_api->rollback_hook\n#define sqlite3_set_authorizer         sqlite3_api->set_authorizer\n#define sqlite3_set_auxdata            sqlite3_api->set_auxdata\n#define sqlite3_snprintf               sqlite3_api->snprintf\n#define sqlite3_step                   sqlite3_api->step\n#define sqlite3_table_column_metadata  sqlite3_api->table_column_metadata\n#define sqlite3_thread_cleanup         sqlite3_api->thread_cleanup\n#define sqlite3_total_changes          sqlite3_api->total_changes\n#define sqlite3_trace                  sqlite3_api->trace\n#ifndef SQLITE_OMIT_DEPRECATED\n#define sqlite3_transfer_bindings      sqlite3_api->transfer_bindings\n#endif\n#define sqlite3_update_hook            sqlite3_api->update_hook\n#define sqlite3_user_data              sqlite3_api->user_data\n#define sqlite3_value_blob             sqlite3_api->value_blob\n#define sqlite3_value_bytes            sqlite3_api->value_bytes\n#define sqlite3_value_bytes16          sqlite3_api->value_bytes16\n#define sqlite3_value_double           sqlite3_api->value_double\n#define sqlite3_value_int              sqlite3_api->value_int\n#define sqlite3_value_int64            sqlite3_api->value_int64\n#define sqlite3_value_numeric_type     sqlite3_api->value_numeric_type\n#define sqlite3_value_text             sqlite3_api->value_text\n#define sqlite3_value_text16           sqlite3_api->value_text16\n#define sqlite3_value_text16be         sqlite3_api->value_text16be\n#define sqlite3_value_text16le         sqlite3_api->value_text16le\n#define sqlite3_value_type             sqlite3_api->value_type\n#define sqlite3_vmprintf               sqlite3_api->vmprintf\n#define sqlite3_overload_function      sqlite3_api->overload_function\n#define sqlite3_prepare_v2             sqlite3_api->prepare_v2\n#define sqlite3_prepare16_v2           sqlite3_api->prepare16_v2\n#define sqlite3_clear_bindings         sqlite3_api->clear_bindings\n#define sqlite3_bind_zeroblob          sqlite3_api->bind_zeroblob\n#define sqlite3_blob_bytes             sqlite3_api->blob_bytes\n#define sqlite3_blob_close             sqlite3_api->blob_close\n#define sqlite3_blob_open              sqlite3_api->blob_open\n#define sqlite3_blob_read              sqlite3_api->blob_read\n#define sqlite3_blob_write             sqlite3_api->blob_write\n#define sqlite3_create_collation_v2    sqlite3_api->create_collation_v2\n#define sqlite3_file_control           sqlite3_api->file_control\n#define sqlite3_memory_highwater       sqlite3_api->memory_highwater\n#define sqlite3_memory_used            sqlite3_api->memory_used\n#define sqlite3_mutex_alloc            sqlite3_api->mutex_alloc\n#define sqlite3_mutex_enter            sqlite3_api->mutex_enter\n#define sqlite3_mutex_free             sqlite3_api->mutex_free\n#define sqlite3_mutex_leave            sqlite3_api->mutex_leave\n#define sqlite3_mutex_try              sqlite3_api->mutex_try\n#define sqlite3_open_v2                sqlite3_api->open_v2\n#define sqlite3_release_memory         sqlite3_api->release_memory\n#define sqlite3_result_error_nomem     sqlite3_api->result_error_nomem\n#define sqlite3_result_error_toobig    sqlite3_api->result_error_toobig\n#define sqlite3_sleep                  sqlite3_api->sleep\n#define sqlite3_soft_heap_limit        sqlite3_api->soft_heap_limit\n#define sqlite3_vfs_find               sqlite3_api->vfs_find\n#define sqlite3_vfs_register           sqlite3_api->vfs_register\n#define sqlite3_vfs_unregister         sqlite3_api->vfs_unregister\n#define sqlite3_threadsafe             sqlite3_api->xthreadsafe\n#define sqlite3_result_zeroblob        sqlite3_api->result_zeroblob\n#define sqlite3_result_error_code      sqlite3_api->result_error_code\n#define sqlite3_test_control           sqlite3_api->test_control\n#define sqlite3_randomness             sqlite3_api->randomness\n#define sqlite3_context_db_handle      sqlite3_api->context_db_handle\n#define sqlite3_extended_result_codes  sqlite3_api->extended_result_codes\n#define sqlite3_limit                  sqlite3_api->limit\n#define sqlite3_next_stmt              sqlite3_api->next_stmt\n#define sqlite3_sql                    sqlite3_api->sql\n#define sqlite3_status                 sqlite3_api->status\n#define sqlite3_backup_finish          sqlite3_api->backup_finish\n#define sqlite3_backup_init            sqlite3_api->backup_init\n#define sqlite3_backup_pagecount       sqlite3_api->backup_pagecount\n#define sqlite3_backup_remaining       sqlite3_api->backup_remaining\n#define sqlite3_backup_step            sqlite3_api->backup_step\n#define sqlite3_compileoption_get      sqlite3_api->compileoption_get\n#define sqlite3_compileoption_used     sqlite3_api->compileoption_used\n#define sqlite3_create_function_v2     sqlite3_api->create_function_v2\n#define sqlite3_db_config              sqlite3_api->db_config\n#define sqlite3_db_mutex               sqlite3_api->db_mutex\n#define sqlite3_db_status              sqlite3_api->db_status\n#define sqlite3_extended_errcode       sqlite3_api->extended_errcode\n#define sqlite3_log                    sqlite3_api->log\n#define sqlite3_soft_heap_limit64      sqlite3_api->soft_heap_limit64\n#define sqlite3_sourceid               sqlite3_api->sourceid\n#define sqlite3_stmt_status            sqlite3_api->stmt_status\n#define sqlite3_strnicmp               sqlite3_api->strnicmp\n#define sqlite3_unlock_notify          sqlite3_api->unlock_notify\n#define sqlite3_wal_autocheckpoint     sqlite3_api->wal_autocheckpoint\n#define sqlite3_wal_checkpoint         sqlite3_api->wal_checkpoint\n#define sqlite3_wal_hook               sqlite3_api->wal_hook\n#endif /* SQLITE_CORE */\n\n#define SQLITE_EXTENSION_INIT1     const sqlite3_api_routines *sqlite3_api = 0;\n#define SQLITE_EXTENSION_INIT2(v)  sqlite3_api = v;\n\n#endif /* _SQLITE3EXT_H_ */\n\n/************** End of sqlite3ext.h ******************************************/\n/************** Continuing where we left off in loadext.c ********************/\n\n#ifndef SQLITE_OMIT_LOAD_EXTENSION\n\n/*\n** Some API routines are omitted when various features are\n** excluded from a build of SQLite.  Substitute a NULL pointer\n** for any missing APIs.\n*/\n#ifndef SQLITE_ENABLE_COLUMN_METADATA\n# define sqlite3_column_database_name   0\n# define sqlite3_column_database_name16 0\n# define sqlite3_column_table_name      0\n# define sqlite3_column_table_name16    0\n# define sqlite3_column_origin_name     0\n# define sqlite3_column_origin_name16   0\n# define sqlite3_table_column_metadata  0\n#endif\n\n#ifdef SQLITE_OMIT_AUTHORIZATION\n# define sqlite3_set_authorizer         0\n#endif\n\n#ifdef SQLITE_OMIT_UTF16\n# define sqlite3_bind_text16            0\n# define sqlite3_collation_needed16     0\n# define sqlite3_column_decltype16      0\n# define sqlite3_column_name16          0\n# define sqlite3_column_text16          0\n# define sqlite3_complete16             0\n# define sqlite3_create_collation16     0\n# define sqlite3_create_function16      0\n# define sqlite3_errmsg16               0\n# define sqlite3_open16                 0\n# define sqlite3_prepare16              0\n# define sqlite3_prepare16_v2           0\n# define sqlite3_result_error16         0\n# define sqlite3_result_text16          0\n# define sqlite3_result_text16be        0\n# define sqlite3_result_text16le        0\n# define sqlite3_value_text16           0\n# define sqlite3_value_text16be         0\n# define sqlite3_value_text16le         0\n# define sqlite3_column_database_name16 0\n# define sqlite3_column_table_name16    0\n# define sqlite3_column_origin_name16   0\n#endif\n\n#ifdef SQLITE_OMIT_COMPLETE\n# define sqlite3_complete 0\n# define sqlite3_complete16 0\n#endif\n\n#ifdef SQLITE_OMIT_PROGRESS_CALLBACK\n# define sqlite3_progress_handler 0\n#endif\n\n#ifdef SQLITE_OMIT_VIRTUALTABLE\n# define sqlite3_create_module 0\n# define sqlite3_create_module_v2 0\n# define sqlite3_declare_vtab 0\n#endif\n\n#ifdef SQLITE_OMIT_SHARED_CACHE\n# define sqlite3_enable_shared_cache 0\n#endif\n\n#ifdef SQLITE_OMIT_TRACE\n# define sqlite3_profile       0\n# define sqlite3_trace         0\n#endif\n\n#ifdef SQLITE_OMIT_GET_TABLE\n# define sqlite3_free_table    0\n# define sqlite3_get_table     0\n#endif\n\n#ifdef SQLITE_OMIT_INCRBLOB\n#define sqlite3_bind_zeroblob  0\n#define sqlite3_blob_bytes     0\n#define sqlite3_blob_close     0\n#define sqlite3_blob_open      0\n#define sqlite3_blob_read      0\n#define sqlite3_blob_write     0\n#endif\n\n/*\n** The following structure contains pointers to all SQLite API routines.\n** A pointer to this structure is passed into extensions when they are\n** loaded so that the extension can make calls back into the SQLite\n** library.\n**\n** When adding new APIs, add them to the bottom of this structure\n** in order to preserve backwards compatibility.\n**\n** Extensions that use newer APIs should first call the\n** sqlite3_libversion_number() to make sure that the API they\n** intend to use is supported by the library.  Extensions should\n** also check to make sure that the pointer to the function is\n** not NULL before calling it.\n*/\nstatic const sqlite3_api_routines sqlite3Apis = {\n  sqlite3_aggregate_context,\n#ifndef SQLITE_OMIT_DEPRECATED\n  sqlite3_aggregate_count,\n#else\n  0,\n#endif\n  sqlite3_bind_blob,\n  sqlite3_bind_double,\n  sqlite3_bind_int,\n  sqlite3_bind_int64,\n  sqlite3_bind_null,\n  sqlite3_bind_parameter_count,\n  sqlite3_bind_parameter_index,\n  sqlite3_bind_parameter_name,\n  sqlite3_bind_text,\n  sqlite3_bind_text16,\n  sqlite3_bind_value,\n  sqlite3_busy_handler,\n  sqlite3_busy_timeout,\n  sqlite3_changes,\n  sqlite3_close,\n  sqlite3_collation_needed,\n  sqlite3_collation_needed16,\n  sqlite3_column_blob,\n  sqlite3_column_bytes,\n  sqlite3_column_bytes16,\n  sqlite3_column_count,\n  sqlite3_column_database_name,\n  sqlite3_column_database_name16,\n  sqlite3_column_decltype,\n  sqlite3_column_decltype16,\n  sqlite3_column_double,\n  sqlite3_column_int,\n  sqlite3_column_int64,\n  sqlite3_column_name,\n  sqlite3_column_name16,\n  sqlite3_column_origin_name,\n  sqlite3_column_origin_name16,\n  sqlite3_column_table_name,\n  sqlite3_column_table_name16,\n  sqlite3_column_text,\n  sqlite3_column_text16,\n  sqlite3_column_type,\n  sqlite3_column_value,\n  sqlite3_commit_hook,\n  sqlite3_complete,\n  sqlite3_complete16,\n  sqlite3_create_collation,\n  sqlite3_create_collation16,\n  sqlite3_create_function,\n  sqlite3_create_function16,\n  sqlite3_create_module,\n  sqlite3_data_count,\n  sqlite3_db_handle,\n  sqlite3_declare_vtab,\n  sqlite3_enable_shared_cache,\n  sqlite3_errcode,\n  sqlite3_errmsg,\n  sqlite3_errmsg16,\n  sqlite3_exec,\n#ifndef SQLITE_OMIT_DEPRECATED\n  sqlite3_expired,\n#else\n  0,\n#endif\n  sqlite3_finalize,\n  sqlite3_free,\n  sqlite3_free_table,\n  sqlite3_get_autocommit,\n  sqlite3_get_auxdata,\n  sqlite3_get_table,\n  0,     /* Was sqlite3_global_recover(), but that function is deprecated */\n  sqlite3_interrupt,\n  sqlite3_last_insert_rowid,\n  sqlite3_libversion,\n  sqlite3_libversion_number,\n  sqlite3_malloc,\n  sqlite3_mprintf,\n  sqlite3_open,\n  sqlite3_open16,\n  sqlite3_prepare,\n  sqlite3_prepare16,\n  sqlite3_profile,\n  sqlite3_progress_handler,\n  sqlite3_realloc,\n  sqlite3_reset,\n  sqlite3_result_blob,\n  sqlite3_result_double,\n  sqlite3_result_error,\n  sqlite3_result_error16,\n  sqlite3_result_int,\n  sqlite3_result_int64,\n  sqlite3_result_null,\n  sqlite3_result_text,\n  sqlite3_result_text16,\n  sqlite3_result_text16be,\n  sqlite3_result_text16le,\n  sqlite3_result_value,\n  sqlite3_rollback_hook,\n  sqlite3_set_authorizer,\n  sqlite3_set_auxdata,\n  sqlite3_snprintf,\n  sqlite3_step,\n  sqlite3_table_column_metadata,\n#ifndef SQLITE_OMIT_DEPRECATED\n  sqlite3_thread_cleanup,\n#else\n  0,\n#endif\n  sqlite3_total_changes,\n  sqlite3_trace,\n#ifndef SQLITE_OMIT_DEPRECATED\n  sqlite3_transfer_bindings,\n#else\n  0,\n#endif\n  sqlite3_update_hook,\n  sqlite3_user_data,\n  sqlite3_value_blob,\n  sqlite3_value_bytes,\n  sqlite3_value_bytes16,\n  sqlite3_value_double,\n  sqlite3_value_int,\n  sqlite3_value_int64,\n  sqlite3_value_numeric_type,\n  sqlite3_value_text,\n  sqlite3_value_text16,\n  sqlite3_value_text16be,\n  sqlite3_value_text16le,\n  sqlite3_value_type,\n  sqlite3_vmprintf,\n  /*\n  ** The original API set ends here.  All extensions can call any\n  ** of the APIs above provided that the pointer is not NULL.  But\n  ** before calling APIs that follow, extension should check the\n  ** sqlite3_libversion_number() to make sure they are dealing with\n  ** a library that is new enough to support that API.\n  *************************************************************************\n  */\n  sqlite3_overload_function,\n\n  /*\n  ** Added after 3.3.13\n  */\n  sqlite3_prepare_v2,\n  sqlite3_prepare16_v2,\n  sqlite3_clear_bindings,\n\n  /*\n  ** Added for 3.4.1\n  */\n  sqlite3_create_module_v2,\n\n  /*\n  ** Added for 3.5.0\n  */\n  sqlite3_bind_zeroblob,\n  sqlite3_blob_bytes,\n  sqlite3_blob_close,\n  sqlite3_blob_open,\n  sqlite3_blob_read,\n  sqlite3_blob_write,\n  sqlite3_create_collation_v2,\n  sqlite3_file_control,\n  sqlite3_memory_highwater,\n  sqlite3_memory_used,\n#ifdef SQLITE_MUTEX_OMIT\n  0, \n  0, \n  0,\n  0,\n  0,\n#else\n  sqlite3_mutex_alloc,\n  sqlite3_mutex_enter,\n  sqlite3_mutex_free,\n  sqlite3_mutex_leave,\n  sqlite3_mutex_try,\n#endif\n  sqlite3_open_v2,\n  sqlite3_release_memory,\n  sqlite3_result_error_nomem,\n  sqlite3_result_error_toobig,\n  sqlite3_sleep,\n  sqlite3_soft_heap_limit,\n  sqlite3_vfs_find,\n  sqlite3_vfs_register,\n  sqlite3_vfs_unregister,\n\n  /*\n  ** Added for 3.5.8\n  */\n  sqlite3_threadsafe,\n  sqlite3_result_zeroblob,\n  sqlite3_result_error_code,\n  sqlite3_test_control,\n  sqlite3_randomness,\n  sqlite3_context_db_handle,\n\n  /*\n  ** Added for 3.6.0\n  */\n  sqlite3_extended_result_codes,\n  sqlite3_limit,\n  sqlite3_next_stmt,\n  sqlite3_sql,\n  sqlite3_status,\n\n  /*\n  ** Added for 3.7.4\n  */\n  sqlite3_backup_finish,\n  sqlite3_backup_init,\n  sqlite3_backup_pagecount,\n  sqlite3_backup_remaining,\n  sqlite3_backup_step,\n#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS\n  sqlite3_compileoption_get,\n  sqlite3_compileoption_used,\n#else\n  0,\n  0,\n#endif\n  sqlite3_create_function_v2,\n  sqlite3_db_config,\n  sqlite3_db_mutex,\n  sqlite3_db_status,\n  sqlite3_extended_errcode,\n  sqlite3_log,\n  sqlite3_soft_heap_limit64,\n  sqlite3_sourceid,\n  sqlite3_stmt_status,\n  sqlite3_strnicmp,\n#ifdef SQLITE_ENABLE_UNLOCK_NOTIFY\n  sqlite3_unlock_notify,\n#else\n  0,\n#endif\n#ifndef SQLITE_OMIT_WAL\n  sqlite3_wal_autocheckpoint,\n  sqlite3_wal_checkpoint,\n  sqlite3_wal_hook,\n#else\n  0,\n  0,\n  0,\n#endif\n};\n\n/*\n** Attempt to load an SQLite extension library contained in the file\n** zFile.  The entry point is zProc.  zProc may be 0 in which case a\n** default entry point name (sqlite3_extension_init) is used.  Use\n** of the default name is recommended.\n**\n** Return SQLITE_OK on success and SQLITE_ERROR if something goes wrong.\n**\n** If an error occurs and pzErrMsg is not 0, then fill *pzErrMsg with \n** error message text.  The calling function should free this memory\n** by calling sqlite3DbFree(db, ).\n*/\nstatic int sqlite3LoadExtension(\n  sqlite3 *db,          /* Load the extension into this database connection */\n  const char *zFile,    /* Name of the shared library containing extension */\n  const char *zProc,    /* Entry point.  Use \"sqlite3_extension_init\" if 0 */\n  char **pzErrMsg       /* Put error message here if not 0 */\n){\n  sqlite3_vfs *pVfs = db->pVfs;\n  void *handle;\n  int (*xInit)(sqlite3*,char**,const sqlite3_api_routines*);\n  char *zErrmsg = 0;\n  void **aHandle;\n  const int nMsg = 300;\n\n  if( pzErrMsg ) *pzErrMsg = 0;\n\n  /* Ticket #1863.  To avoid a creating security problems for older\n  ** applications that relink against newer versions of SQLite, the\n  ** ability to run load_extension is turned off by default.  One\n  ** must call sqlite3_enable_load_extension() to turn on extension\n  ** loading.  Otherwise you get the following error.\n  */\n  if( (db->flags & SQLITE_LoadExtension)==0 ){\n    if( pzErrMsg ){\n      *pzErrMsg = sqlite3_mprintf(\"not authorized\");\n    }\n    return SQLITE_ERROR;\n  }\n\n  if( zProc==0 ){\n    zProc = \"sqlite3_extension_init\";\n  }\n\n  handle = sqlite3OsDlOpen(pVfs, zFile);\n  if( handle==0 ){\n    if( pzErrMsg ){\n      *pzErrMsg = zErrmsg = sqlite3_malloc(nMsg);\n      if( zErrmsg ){\n        sqlite3_snprintf(nMsg, zErrmsg, \n            \"unable to open shared library [%s]\", zFile);\n        sqlite3OsDlError(pVfs, nMsg-1, zErrmsg);\n      }\n    }\n    return SQLITE_ERROR;\n  }\n  xInit = (int(*)(sqlite3*,char**,const sqlite3_api_routines*))\n                   sqlite3OsDlSym(pVfs, handle, zProc);\n  if( xInit==0 ){\n    if( pzErrMsg ){\n      *pzErrMsg = zErrmsg = sqlite3_malloc(nMsg);\n      if( zErrmsg ){\n        sqlite3_snprintf(nMsg, zErrmsg,\n            \"no entry point [%s] in shared library [%s]\", zProc,zFile);\n        sqlite3OsDlError(pVfs, nMsg-1, zErrmsg);\n      }\n      sqlite3OsDlClose(pVfs, handle);\n    }\n    return SQLITE_ERROR;\n  }else if( xInit(db, &zErrmsg, &sqlite3Apis) ){\n    if( pzErrMsg ){\n      *pzErrMsg = sqlite3_mprintf(\"error during initialization: %s\", zErrmsg);\n    }\n    sqlite3_free(zErrmsg);\n    sqlite3OsDlClose(pVfs, handle);\n    return SQLITE_ERROR;\n  }\n\n  /* Append the new shared library handle to the db->aExtension array. */\n  aHandle = sqlite3DbMallocZero(db, sizeof(handle)*(db->nExtension+1));\n  if( aHandle==0 ){\n    return SQLITE_NOMEM;\n  }\n  if( db->nExtension>0 ){\n    memcpy(aHandle, db->aExtension, sizeof(handle)*db->nExtension);\n  }\n  sqlite3DbFree(db, db->aExtension);\n  db->aExtension = aHandle;\n\n  db->aExtension[db->nExtension++] = handle;\n  return SQLITE_OK;\n}\nSQLITE_API int sqlite3_load_extension(\n  sqlite3 *db,          /* Load the extension into this database connection */\n  const char *zFile,    /* Name of the shared library containing extension */\n  const char *zProc,    /* Entry point.  Use \"sqlite3_extension_init\" if 0 */\n  char **pzErrMsg       /* Put error message here if not 0 */\n){\n  int rc;\n  sqlite3_mutex_enter(db->mutex);\n  rc = sqlite3LoadExtension(db, zFile, zProc, pzErrMsg);\n  rc = sqlite3ApiExit(db, rc);\n  sqlite3_mutex_leave(db->mutex);\n  return rc;\n}\n\n/*\n** Call this routine when the database connection is closing in order\n** to clean up loaded extensions\n*/\nSQLITE_PRIVATE void sqlite3CloseExtensions(sqlite3 *db){\n  int i;\n  assert( sqlite3_mutex_held(db->mutex) );\n  for(i=0; i<db->nExtension; i++){\n    sqlite3OsDlClose(db->pVfs, db->aExtension[i]);\n  }\n  sqlite3DbFree(db, db->aExtension);\n}\n\n/*\n** Enable or disable extension loading.  Extension loading is disabled by\n** default so as not to open security holes in older applications.\n*/\nSQLITE_API int sqlite3_enable_load_extension(sqlite3 *db, int onoff){\n  sqlite3_mutex_enter(db->mutex);\n  if( onoff ){\n    db->flags |= SQLITE_LoadExtension;\n  }else{\n    db->flags &= ~SQLITE_LoadExtension;\n  }\n  sqlite3_mutex_leave(db->mutex);\n  return SQLITE_OK;\n}\n\n#endif /* SQLITE_OMIT_LOAD_EXTENSION */\n\n/*\n** The auto-extension code added regardless of whether or not extension\n** loading is supported.  We need a dummy sqlite3Apis pointer for that\n** code if regular extension loading is not available.  This is that\n** dummy pointer.\n*/\n#ifdef SQLITE_OMIT_LOAD_EXTENSION\nstatic const sqlite3_api_routines sqlite3Apis = { 0 };\n#endif\n\n\n/*\n** The following object holds the list of automatically loaded\n** extensions.\n**\n** This list is shared across threads.  The SQLITE_MUTEX_STATIC_MASTER\n** mutex must be held while accessing this list.\n*/\ntypedef struct sqlite3AutoExtList sqlite3AutoExtList;\nstatic SQLITE_WSD struct sqlite3AutoExtList {\n  int nExt;              /* Number of entries in aExt[] */          \n  void (**aExt)(void);   /* Pointers to the extension init functions */\n} sqlite3Autoext = { 0, 0 };\n\n/* The \"wsdAutoext\" macro will resolve to the autoextension\n** state vector.  If writable static data is unsupported on the target,\n** we have to locate the state vector at run-time.  In the more common\n** case where writable static data is supported, wsdStat can refer directly\n** to the \"sqlite3Autoext\" state vector declared above.\n*/\n#ifdef SQLITE_OMIT_WSD\n# define wsdAutoextInit \\\n  sqlite3AutoExtList *x = &GLOBAL(sqlite3AutoExtList,sqlite3Autoext)\n# define wsdAutoext x[0]\n#else\n# define wsdAutoextInit\n# define wsdAutoext sqlite3Autoext\n#endif\n\n\n/*\n** Register a statically linked extension that is automatically\n** loaded by every new database connection.\n*/\nSQLITE_API int sqlite3_auto_extension(void (*xInit)(void)){\n  int rc = SQLITE_OK;\n#ifndef SQLITE_OMIT_AUTOINIT\n  rc = sqlite3_initialize();\n  if( rc ){\n    return rc;\n  }else\n#endif\n  {\n    int i;\n#if SQLITE_THREADSAFE\n    sqlite3_mutex *mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER);\n#endif\n    wsdAutoextInit;\n    sqlite3_mutex_enter(mutex);\n    for(i=0; i<wsdAutoext.nExt; i++){\n      if( wsdAutoext.aExt[i]==xInit ) break;\n    }\n    if( i==wsdAutoext.nExt ){\n      int nByte = (wsdAutoext.nExt+1)*sizeof(wsdAutoext.aExt[0]);\n      void (**aNew)(void);\n      aNew = sqlite3_realloc(wsdAutoext.aExt, nByte);\n      if( aNew==0 ){\n        rc = SQLITE_NOMEM;\n      }else{\n        wsdAutoext.aExt = aNew;\n        wsdAutoext.aExt[wsdAutoext.nExt] = xInit;\n        wsdAutoext.nExt++;\n      }\n    }\n    sqlite3_mutex_leave(mutex);\n    assert( (rc&0xff)==rc );\n    return rc;\n  }\n}\n\n/*\n** Reset the automatic extension loading mechanism.\n*/\nSQLITE_API void sqlite3_reset_auto_extension(void){\n#ifndef SQLITE_OMIT_AUTOINIT\n  if( sqlite3_initialize()==SQLITE_OK )\n#endif\n  {\n#if SQLITE_THREADSAFE\n    sqlite3_mutex *mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER);\n#endif\n    wsdAutoextInit;\n    sqlite3_mutex_enter(mutex);\n    sqlite3_free(wsdAutoext.aExt);\n    wsdAutoext.aExt = 0;\n    wsdAutoext.nExt = 0;\n    sqlite3_mutex_leave(mutex);\n  }\n}\n\n/*\n** Load all automatic extensions.\n**\n** If anything goes wrong, set an error in the database connection.\n*/\nSQLITE_PRIVATE void sqlite3AutoLoadExtensions(sqlite3 *db){\n  int i;\n  int go = 1;\n  int (*xInit)(sqlite3*,char**,const sqlite3_api_routines*);\n\n  wsdAutoextInit;\n  if( wsdAutoext.nExt==0 ){\n    /* Common case: early out without every having to acquire a mutex */\n    return;\n  }\n  for(i=0; go; i++){\n    char *zErrmsg;\n#if SQLITE_THREADSAFE\n    sqlite3_mutex *mutex = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER);\n#endif\n    sqlite3_mutex_enter(mutex);\n    if( i>=wsdAutoext.nExt ){\n      xInit = 0;\n      go = 0;\n    }else{\n      xInit = (int(*)(sqlite3*,char**,const sqlite3_api_routines*))\n              wsdAutoext.aExt[i];\n    }\n    sqlite3_mutex_leave(mutex);\n    zErrmsg = 0;\n    if( xInit && xInit(db, &zErrmsg, &sqlite3Apis) ){\n      sqlite3Error(db, SQLITE_ERROR,\n            \"automatic extension loading failed: %s\", zErrmsg);\n      go = 0;\n    }\n    sqlite3_free(zErrmsg);\n  }\n}\n\n/************** End of loadext.c *********************************************/\n/************** Begin file pragma.c ******************************************/\n/*\n** 2003 April 6\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains code used to implement the PRAGMA command.\n*/\n\n/* Ignore this whole file if pragmas are disabled\n*/\n#if !defined(SQLITE_OMIT_PRAGMA)\n\n/*\n** Interpret the given string as a safety level.  Return 0 for OFF,\n** 1 for ON or NORMAL and 2 for FULL.  Return 1 for an empty or \n** unrecognized string argument.\n**\n** Note that the values returned are one less that the values that\n** should be passed into sqlite3BtreeSetSafetyLevel().  The is done\n** to support legacy SQL code.  The safety level used to be boolean\n** and older scripts may have used numbers 0 for OFF and 1 for ON.\n*/\nstatic u8 getSafetyLevel(const char *z){\n                             /* 123456789 123456789 */\n  static const char zText[] = \"onoffalseyestruefull\";\n  static const u8 iOffset[] = {0, 1, 2, 4, 9, 12, 16};\n  static const u8 iLength[] = {2, 2, 3, 5, 3, 4, 4};\n  static const u8 iValue[] =  {1, 0, 0, 0, 1, 1, 2};\n  int i, n;\n  if( sqlite3Isdigit(*z) ){\n    return (u8)sqlite3Atoi(z);\n  }\n  n = sqlite3Strlen30(z);\n  for(i=0; i<ArraySize(iLength); i++){\n    if( iLength[i]==n && sqlite3StrNICmp(&zText[iOffset[i]],z,n)==0 ){\n      return iValue[i];\n    }\n  }\n  return 1;\n}\n\n/*\n** Interpret the given string as a boolean value.\n*/\nstatic u8 getBoolean(const char *z){\n  return getSafetyLevel(z)&1;\n}\n\n/*\n** Interpret the given string as a locking mode value.\n*/\nstatic int getLockingMode(const char *z){\n  if( z ){\n    if( 0==sqlite3StrICmp(z, \"exclusive\") ) return PAGER_LOCKINGMODE_EXCLUSIVE;\n    if( 0==sqlite3StrICmp(z, \"normal\") ) return PAGER_LOCKINGMODE_NORMAL;\n  }\n  return PAGER_LOCKINGMODE_QUERY;\n}\n\n#ifndef SQLITE_OMIT_AUTOVACUUM\n/*\n** Interpret the given string as an auto-vacuum mode value.\n**\n** The following strings, \"none\", \"full\" and \"incremental\" are \n** acceptable, as are their numeric equivalents: 0, 1 and 2 respectively.\n*/\nstatic int getAutoVacuum(const char *z){\n  int i;\n  if( 0==sqlite3StrICmp(z, \"none\") ) return BTREE_AUTOVACUUM_NONE;\n  if( 0==sqlite3StrICmp(z, \"full\") ) return BTREE_AUTOVACUUM_FULL;\n  if( 0==sqlite3StrICmp(z, \"incremental\") ) return BTREE_AUTOVACUUM_INCR;\n  i = sqlite3Atoi(z);\n  return (u8)((i>=0&&i<=2)?i:0);\n}\n#endif /* ifndef SQLITE_OMIT_AUTOVACUUM */\n\n#ifndef SQLITE_OMIT_PAGER_PRAGMAS\n/*\n** Interpret the given string as a temp db location. Return 1 for file\n** backed temporary databases, 2 for the Red-Black tree in memory database\n** and 0 to use the compile-time default.\n*/\nstatic int getTempStore(const char *z){\n  if( z[0]>='0' && z[0]<='2' ){\n    return z[0] - '0';\n  }else if( sqlite3StrICmp(z, \"file\")==0 ){\n    return 1;\n  }else if( sqlite3StrICmp(z, \"memory\")==0 ){\n    return 2;\n  }else{\n    return 0;\n  }\n}\n#endif /* SQLITE_PAGER_PRAGMAS */\n\n#ifndef SQLITE_OMIT_PAGER_PRAGMAS\n/*\n** Invalidate temp storage, either when the temp storage is changed\n** from default, or when 'file' and the temp_store_directory has changed\n*/\nstatic int invalidateTempStorage(Parse *pParse){\n  sqlite3 *db = pParse->db;\n  if( db->aDb[1].pBt!=0 ){\n    if( !db->autoCommit || sqlite3BtreeIsInReadTrans(db->aDb[1].pBt) ){\n      sqlite3ErrorMsg(pParse, \"temporary storage cannot be changed \"\n        \"from within a transaction\");\n      return SQLITE_ERROR;\n    }\n    sqlite3BtreeClose(db->aDb[1].pBt);\n    db->aDb[1].pBt = 0;\n    sqlite3ResetInternalSchema(db, 0);\n  }\n  return SQLITE_OK;\n}\n#endif /* SQLITE_PAGER_PRAGMAS */\n\n#ifndef SQLITE_OMIT_PAGER_PRAGMAS\n/*\n** If the TEMP database is open, close it and mark the database schema\n** as needing reloading.  This must be done when using the SQLITE_TEMP_STORE\n** or DEFAULT_TEMP_STORE pragmas.\n*/\nstatic int changeTempStorage(Parse *pParse, const char *zStorageType){\n  int ts = getTempStore(zStorageType);\n  sqlite3 *db = pParse->db;\n  if( db->temp_store==ts ) return SQLITE_OK;\n  if( invalidateTempStorage( pParse ) != SQLITE_OK ){\n    return SQLITE_ERROR;\n  }\n  db->temp_store = (u8)ts;\n  return SQLITE_OK;\n}\n#endif /* SQLITE_PAGER_PRAGMAS */\n\n/*\n** Generate code to return a single integer value.\n*/\nstatic void returnSingleInt(Parse *pParse, const char *zLabel, i64 value){\n  Vdbe *v = sqlite3GetVdbe(pParse);\n  int mem = ++pParse->nMem;\n  i64 *pI64 = sqlite3DbMallocRaw(pParse->db, sizeof(value));\n  if( pI64 ){\n    memcpy(pI64, &value, sizeof(value));\n  }\n  sqlite3VdbeAddOp4(v, OP_Int64, 0, mem, 0, (char*)pI64, P4_INT64);\n  sqlite3VdbeSetNumCols(v, 1);\n  sqlite3VdbeSetColName(v, 0, COLNAME_NAME, zLabel, SQLITE_STATIC);\n  sqlite3VdbeAddOp2(v, OP_ResultRow, mem, 1);\n}\n\n#ifndef SQLITE_OMIT_FLAG_PRAGMAS\n/*\n** Check to see if zRight and zLeft refer to a pragma that queries\n** or changes one of the flags in db->flags.  Return 1 if so and 0 if not.\n** Also, implement the pragma.\n*/\nstatic int flagPragma(Parse *pParse, const char *zLeft, const char *zRight){\n  static const struct sPragmaType {\n    const char *zName;  /* Name of the pragma */\n    int mask;           /* Mask for the db->flags value */\n  } aPragma[] = {\n    { \"full_column_names\",        SQLITE_FullColNames  },\n    { \"short_column_names\",       SQLITE_ShortColNames },\n    { \"count_changes\",            SQLITE_CountRows     },\n    { \"empty_result_callbacks\",   SQLITE_NullCallback  },\n    { \"legacy_file_format\",       SQLITE_LegacyFileFmt },\n    { \"fullfsync\",                SQLITE_FullFSync     },\n    { \"checkpoint_fullfsync\",     SQLITE_CkptFullFSync },\n    { \"reverse_unordered_selects\", SQLITE_ReverseOrder  },\n#ifndef SQLITE_OMIT_AUTOMATIC_INDEX\n    { \"automatic_index\",          SQLITE_AutoIndex     },\n#endif\n#ifdef SQLITE_DEBUG\n    { \"sql_trace\",                SQLITE_SqlTrace      },\n    { \"vdbe_listing\",             SQLITE_VdbeListing   },\n    { \"vdbe_trace\",               SQLITE_VdbeTrace     },\n#endif\n#ifndef SQLITE_OMIT_CHECK\n    { \"ignore_check_constraints\", SQLITE_IgnoreChecks  },\n#endif\n    /* The following is VERY experimental */\n    { \"writable_schema\",          SQLITE_WriteSchema|SQLITE_RecoveryMode },\n    { \"omit_readlock\",            SQLITE_NoReadlock    },\n\n    /* TODO: Maybe it shouldn't be possible to change the ReadUncommitted\n    ** flag if there are any active statements. */\n    { \"read_uncommitted\",         SQLITE_ReadUncommitted },\n    { \"recursive_triggers\",       SQLITE_RecTriggers },\n\n    /* This flag may only be set if both foreign-key and trigger support\n    ** are present in the build.  */\n#if !defined(SQLITE_OMIT_FOREIGN_KEY) && !defined(SQLITE_OMIT_TRIGGER)\n    { \"foreign_keys\",             SQLITE_ForeignKeys },\n#endif\n  };\n  int i;\n  const struct sPragmaType *p;\n  for(i=0, p=aPragma; i<ArraySize(aPragma); i++, p++){\n    if( sqlite3StrICmp(zLeft, p->zName)==0 ){\n      sqlite3 *db = pParse->db;\n      Vdbe *v;\n      v = sqlite3GetVdbe(pParse);\n      assert( v!=0 );  /* Already allocated by sqlite3Pragma() */\n      if( ALWAYS(v) ){\n        if( zRight==0 ){\n          returnSingleInt(pParse, p->zName, (db->flags & p->mask)!=0 );\n        }else{\n          int mask = p->mask;          /* Mask of bits to set or clear. */\n          if( db->autoCommit==0 ){\n            /* Foreign key support may not be enabled or disabled while not\n            ** in auto-commit mode.  */\n            mask &= ~(SQLITE_ForeignKeys);\n          }\n\n          if( getBoolean(zRight) ){\n            db->flags |= mask;\n          }else{\n            db->flags &= ~mask;\n          }\n\n          /* Many of the flag-pragmas modify the code generated by the SQL \n          ** compiler (eg. count_changes). So add an opcode to expire all\n          ** compiled SQL statements after modifying a pragma value.\n          */\n          sqlite3VdbeAddOp2(v, OP_Expire, 0, 0);\n        }\n      }\n\n      return 1;\n    }\n  }\n  return 0;\n}\n#endif /* SQLITE_OMIT_FLAG_PRAGMAS */\n\n/*\n** Return a human-readable name for a constraint resolution action.\n*/\n#ifndef SQLITE_OMIT_FOREIGN_KEY\nstatic const char *actionName(u8 action){\n  const char *zName;\n  switch( action ){\n    case OE_SetNull:  zName = \"SET NULL\";        break;\n    case OE_SetDflt:  zName = \"SET DEFAULT\";     break;\n    case OE_Cascade:  zName = \"CASCADE\";         break;\n    case OE_Restrict: zName = \"RESTRICT\";        break;\n    default:          zName = \"NO ACTION\";  \n                      assert( action==OE_None ); break;\n  }\n  return zName;\n}\n#endif\n\n\n/*\n** Parameter eMode must be one of the PAGER_JOURNALMODE_XXX constants\n** defined in pager.h. This function returns the associated lowercase\n** journal-mode name.\n*/\nSQLITE_PRIVATE const char *sqlite3JournalModename(int eMode){\n  static char * const azModeName[] = {\n    \"delete\", \"persist\", \"off\", \"truncate\", \"memory\"\n#ifndef SQLITE_OMIT_WAL\n     , \"wal\"\n#endif\n  };\n  assert( PAGER_JOURNALMODE_DELETE==0 );\n  assert( PAGER_JOURNALMODE_PERSIST==1 );\n  assert( PAGER_JOURNALMODE_OFF==2 );\n  assert( PAGER_JOURNALMODE_TRUNCATE==3 );\n  assert( PAGER_JOURNALMODE_MEMORY==4 );\n  assert( PAGER_JOURNALMODE_WAL==5 );\n  assert( eMode>=0 && eMode<=ArraySize(azModeName) );\n\n  if( eMode==ArraySize(azModeName) ) return 0;\n  return azModeName[eMode];\n}\n\n/*\n** Process a pragma statement.  \n**\n** Pragmas are of this form:\n**\n**      PRAGMA [database.]id [= value]\n**\n** The identifier might also be a string.  The value is a string, and\n** identifier, or a number.  If minusFlag is true, then the value is\n** a number that was preceded by a minus sign.\n**\n** If the left side is \"database.id\" then pId1 is the database name\n** and pId2 is the id.  If the left side is just \"id\" then pId1 is the\n** id and pId2 is any empty string.\n*/\nSQLITE_PRIVATE void sqlite3Pragma(\n  Parse *pParse, \n  Token *pId1,        /* First part of [database.]id field */\n  Token *pId2,        /* Second part of [database.]id field, or NULL */\n  Token *pValue,      /* Token for <value>, or NULL */\n  int minusFlag       /* True if a '-' sign preceded <value> */\n){\n  char *zLeft = 0;       /* Nul-terminated UTF-8 string <id> */\n  char *zRight = 0;      /* Nul-terminated UTF-8 string <value>, or NULL */\n  const char *zDb = 0;   /* The database name */\n  Token *pId;            /* Pointer to <id> token */\n  int iDb;               /* Database index for <database> */\n  sqlite3 *db = pParse->db;\n  Db *pDb;\n  Vdbe *v = pParse->pVdbe = sqlite3VdbeCreate(db);\n  if( v==0 ) return;\n  sqlite3VdbeRunOnlyOnce(v);\n  pParse->nMem = 2;\n\n  /* Interpret the [database.] part of the pragma statement. iDb is the\n  ** index of the database this pragma is being applied to in db.aDb[]. */\n  iDb = sqlite3TwoPartName(pParse, pId1, pId2, &pId);\n  if( iDb<0 ) return;\n  pDb = &db->aDb[iDb];\n\n  /* If the temp database has been explicitly named as part of the \n  ** pragma, make sure it is open. \n  */\n  if( iDb==1 && sqlite3OpenTempDatabase(pParse) ){\n    return;\n  }\n\n  zLeft = sqlite3NameFromToken(db, pId);\n  if( !zLeft ) return;\n  if( minusFlag ){\n    zRight = sqlite3MPrintf(db, \"-%T\", pValue);\n  }else{\n    zRight = sqlite3NameFromToken(db, pValue);\n  }\n\n  assert( pId2 );\n  zDb = pId2->n>0 ? pDb->zName : 0;\n  if( sqlite3AuthCheck(pParse, SQLITE_PRAGMA, zLeft, zRight, zDb) ){\n    goto pragma_out;\n  }\n \n#ifndef SQLITE_OMIT_PAGER_PRAGMAS\n  /*\n  **  PRAGMA [database.]default_cache_size\n  **  PRAGMA [database.]default_cache_size=N\n  **\n  ** The first form reports the current persistent setting for the\n  ** page cache size.  The value returned is the maximum number of\n  ** pages in the page cache.  The second form sets both the current\n  ** page cache size value and the persistent page cache size value\n  ** stored in the database file.\n  **\n  ** Older versions of SQLite would set the default cache size to a\n  ** negative number to indicate synchronous=OFF.  These days, synchronous\n  ** is always on by default regardless of the sign of the default cache\n  ** size.  But continue to take the absolute value of the default cache\n  ** size of historical compatibility.\n  */\n  if( sqlite3StrICmp(zLeft,\"default_cache_size\")==0 ){\n    static const VdbeOpList getCacheSize[] = {\n      { OP_Transaction, 0, 0,        0},                         /* 0 */\n      { OP_ReadCookie,  0, 1,        BTREE_DEFAULT_CACHE_SIZE},  /* 1 */\n      { OP_IfPos,       1, 7,        0},\n      { OP_Integer,     0, 2,        0},\n      { OP_Subtract,    1, 2,        1},\n      { OP_IfPos,       1, 7,        0},\n      { OP_Integer,     0, 1,        0},                         /* 6 */\n      { OP_ResultRow,   1, 1,        0},\n    };\n    int addr;\n    if( sqlite3ReadSchema(pParse) ) goto pragma_out;\n    sqlite3VdbeUsesBtree(v, iDb);\n    if( !zRight ){\n      sqlite3VdbeSetNumCols(v, 1);\n      sqlite3VdbeSetColName(v, 0, COLNAME_NAME, \"cache_size\", SQLITE_STATIC);\n      pParse->nMem += 2;\n      addr = sqlite3VdbeAddOpList(v, ArraySize(getCacheSize), getCacheSize);\n      sqlite3VdbeChangeP1(v, addr, iDb);\n      sqlite3VdbeChangeP1(v, addr+1, iDb);\n      sqlite3VdbeChangeP1(v, addr+6, SQLITE_DEFAULT_CACHE_SIZE);\n    }else{\n      int size = sqlite3AbsInt32(sqlite3Atoi(zRight));\n      sqlite3BeginWriteOperation(pParse, 0, iDb);\n      sqlite3VdbeAddOp2(v, OP_Integer, size, 1);\n      sqlite3VdbeAddOp3(v, OP_SetCookie, iDb, BTREE_DEFAULT_CACHE_SIZE, 1);\n      pDb->pSchema->cache_size = size;\n      sqlite3BtreeSetCacheSize(pDb->pBt, pDb->pSchema->cache_size);\n    }\n  }else\n\n  /*\n  **  PRAGMA [database.]page_size\n  **  PRAGMA [database.]page_size=N\n  **\n  ** The first form reports the current setting for the\n  ** database page size in bytes.  The second form sets the\n  ** database page size value.  The value can only be set if\n  ** the database has not yet been created.\n  */\n  if( sqlite3StrICmp(zLeft,\"page_size\")==0 ){\n    Btree *pBt = pDb->pBt;\n    assert( pBt!=0 );\n    if( !zRight ){\n      int size = ALWAYS(pBt) ? sqlite3BtreeGetPageSize(pBt) : 0;\n      returnSingleInt(pParse, \"page_size\", size);\n    }else{\n      /* Malloc may fail when setting the page-size, as there is an internal\n      ** buffer that the pager module resizes using sqlite3_realloc().\n      */\n      db->nextPagesize = sqlite3Atoi(zRight);\n      if( SQLITE_NOMEM==sqlite3BtreeSetPageSize(pBt, db->nextPagesize, -1, 0) ){\n        db->mallocFailed = 1;\n      }\n    }\n  }else\n\n  /*\n  **  PRAGMA [database.]secure_delete\n  **  PRAGMA [database.]secure_delete=ON/OFF\n  **\n  ** The first form reports the current setting for the\n  ** secure_delete flag.  The second form changes the secure_delete\n  ** flag setting and reports thenew value.\n  */\n  if( sqlite3StrICmp(zLeft,\"secure_delete\")==0 ){\n    Btree *pBt = pDb->pBt;\n    int b = -1;\n    assert( pBt!=0 );\n    if( zRight ){\n      b = getBoolean(zRight);\n    }\n    if( pId2->n==0 && b>=0 ){\n      int ii;\n      for(ii=0; ii<db->nDb; ii++){\n        sqlite3BtreeSecureDelete(db->aDb[ii].pBt, b);\n      }\n    }\n    b = sqlite3BtreeSecureDelete(pBt, b);\n    returnSingleInt(pParse, \"secure_delete\", b);\n  }else\n\n  /*\n  **  PRAGMA [database.]max_page_count\n  **  PRAGMA [database.]max_page_count=N\n  **\n  ** The first form reports the current setting for the\n  ** maximum number of pages in the database file.  The \n  ** second form attempts to change this setting.  Both\n  ** forms return the current setting.\n  **\n  **  PRAGMA [database.]page_count\n  **\n  ** Return the number of pages in the specified database.\n  */\n  if( sqlite3StrICmp(zLeft,\"page_count\")==0\n   || sqlite3StrICmp(zLeft,\"max_page_count\")==0\n  ){\n    int iReg;\n    if( sqlite3ReadSchema(pParse) ) goto pragma_out;\n    sqlite3CodeVerifySchema(pParse, iDb);\n    iReg = ++pParse->nMem;\n    if( zLeft[0]=='p' ){\n      sqlite3VdbeAddOp2(v, OP_Pagecount, iDb, iReg);\n    }else{\n      sqlite3VdbeAddOp3(v, OP_MaxPgcnt, iDb, iReg, sqlite3Atoi(zRight));\n    }\n    sqlite3VdbeAddOp2(v, OP_ResultRow, iReg, 1);\n    sqlite3VdbeSetNumCols(v, 1);\n    sqlite3VdbeSetColName(v, 0, COLNAME_NAME, zLeft, SQLITE_TRANSIENT);\n  }else\n\n  /*\n  **  PRAGMA [database.]locking_mode\n  **  PRAGMA [database.]locking_mode = (normal|exclusive)\n  */\n  if( sqlite3StrICmp(zLeft,\"locking_mode\")==0 ){\n    const char *zRet = \"normal\";\n    int eMode = getLockingMode(zRight);\n\n    if( pId2->n==0 && eMode==PAGER_LOCKINGMODE_QUERY ){\n      /* Simple \"PRAGMA locking_mode;\" statement. This is a query for\n      ** the current default locking mode (which may be different to\n      ** the locking-mode of the main database).\n      */\n      eMode = db->dfltLockMode;\n    }else{\n      Pager *pPager;\n      if( pId2->n==0 ){\n        /* This indicates that no database name was specified as part\n        ** of the PRAGMA command. In this case the locking-mode must be\n        ** set on all attached databases, as well as the main db file.\n        **\n        ** Also, the sqlite3.dfltLockMode variable is set so that\n        ** any subsequently attached databases also use the specified\n        ** locking mode.\n        */\n        int ii;\n        assert(pDb==&db->aDb[0]);\n        for(ii=2; ii<db->nDb; ii++){\n          pPager = sqlite3BtreePager(db->aDb[ii].pBt);\n          sqlite3PagerLockingMode(pPager, eMode);\n        }\n        db->dfltLockMode = (u8)eMode;\n      }\n      pPager = sqlite3BtreePager(pDb->pBt);\n      eMode = sqlite3PagerLockingMode(pPager, eMode);\n    }\n\n    assert(eMode==PAGER_LOCKINGMODE_NORMAL||eMode==PAGER_LOCKINGMODE_EXCLUSIVE);\n    if( eMode==PAGER_LOCKINGMODE_EXCLUSIVE ){\n      zRet = \"exclusive\";\n    }\n    sqlite3VdbeSetNumCols(v, 1);\n    sqlite3VdbeSetColName(v, 0, COLNAME_NAME, \"locking_mode\", SQLITE_STATIC);\n    sqlite3VdbeAddOp4(v, OP_String8, 0, 1, 0, zRet, 0);\n    sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 1);\n  }else\n\n  /*\n  **  PRAGMA [database.]journal_mode\n  **  PRAGMA [database.]journal_mode =\n  **                      (delete|persist|off|truncate|memory|wal|off)\n  */\n  if( sqlite3StrICmp(zLeft,\"journal_mode\")==0 ){\n    int eMode;        /* One of the PAGER_JOURNALMODE_XXX symbols */\n    int ii;           /* Loop counter */\n\n    /* Force the schema to be loaded on all databases.  This cases all\n    ** database files to be opened and the journal_modes set. */\n    if( sqlite3ReadSchema(pParse) ){\n      goto pragma_out;\n    }\n\n    sqlite3VdbeSetNumCols(v, 1);\n    sqlite3VdbeSetColName(v, 0, COLNAME_NAME, \"journal_mode\", SQLITE_STATIC);\n\n    if( zRight==0 ){\n      /* If there is no \"=MODE\" part of the pragma, do a query for the\n      ** current mode */\n      eMode = PAGER_JOURNALMODE_QUERY;\n    }else{\n      const char *zMode;\n      int n = sqlite3Strlen30(zRight);\n      for(eMode=0; (zMode = sqlite3JournalModename(eMode))!=0; eMode++){\n        if( sqlite3StrNICmp(zRight, zMode, n)==0 ) break;\n      }\n      if( !zMode ){\n        /* If the \"=MODE\" part does not match any known journal mode,\n        ** then do a query */\n        eMode = PAGER_JOURNALMODE_QUERY;\n      }\n    }\n    if( eMode==PAGER_JOURNALMODE_QUERY && pId2->n==0 ){\n      /* Convert \"PRAGMA journal_mode\" into \"PRAGMA main.journal_mode\" */\n      iDb = 0;\n      pId2->n = 1;\n    }\n    for(ii=db->nDb-1; ii>=0; ii--){\n      if( db->aDb[ii].pBt && (ii==iDb || pId2->n==0) ){\n        sqlite3VdbeUsesBtree(v, ii);\n        sqlite3VdbeAddOp3(v, OP_JournalMode, ii, 1, eMode);\n      }\n    }\n    sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 1);\n  }else\n\n  /*\n  **  PRAGMA [database.]journal_size_limit\n  **  PRAGMA [database.]journal_size_limit=N\n  **\n  ** Get or set the size limit on rollback journal files.\n  */\n  if( sqlite3StrICmp(zLeft,\"journal_size_limit\")==0 ){\n    Pager *pPager = sqlite3BtreePager(pDb->pBt);\n    i64 iLimit = -2;\n    if( zRight ){\n      sqlite3Atoi64(zRight, &iLimit, 1000000, SQLITE_UTF8);\n      if( iLimit<-1 ) iLimit = -1;\n    }\n    iLimit = sqlite3PagerJournalSizeLimit(pPager, iLimit);\n    returnSingleInt(pParse, \"journal_size_limit\", iLimit);\n  }else\n\n#endif /* SQLITE_OMIT_PAGER_PRAGMAS */\n\n  /*\n  **  PRAGMA [database.]auto_vacuum\n  **  PRAGMA [database.]auto_vacuum=N\n  **\n  ** Get or set the value of the database 'auto-vacuum' parameter.\n  ** The value is one of:  0 NONE 1 FULL 2 INCREMENTAL\n  */\n#ifndef SQLITE_OMIT_AUTOVACUUM\n  if( sqlite3StrICmp(zLeft,\"auto_vacuum\")==0 ){\n    Btree *pBt = pDb->pBt;\n    assert( pBt!=0 );\n    if( sqlite3ReadSchema(pParse) ){\n      goto pragma_out;\n    }\n    if( !zRight ){\n      int auto_vacuum;\n      if( ALWAYS(pBt) ){\n         auto_vacuum = sqlite3BtreeGetAutoVacuum(pBt);\n      }else{\n         auto_vacuum = SQLITE_DEFAULT_AUTOVACUUM;\n      }\n      returnSingleInt(pParse, \"auto_vacuum\", auto_vacuum);\n    }else{\n      int eAuto = getAutoVacuum(zRight);\n      assert( eAuto>=0 && eAuto<=2 );\n      db->nextAutovac = (u8)eAuto;\n      if( ALWAYS(eAuto>=0) ){\n        /* Call SetAutoVacuum() to set initialize the internal auto and\n        ** incr-vacuum flags. This is required in case this connection\n        ** creates the database file. It is important that it is created\n        ** as an auto-vacuum capable db.\n        */\n        int rc = sqlite3BtreeSetAutoVacuum(pBt, eAuto);\n        if( rc==SQLITE_OK && (eAuto==1 || eAuto==2) ){\n          /* When setting the auto_vacuum mode to either \"full\" or \n          ** \"incremental\", write the value of meta[6] in the database\n          ** file. Before writing to meta[6], check that meta[3] indicates\n          ** that this really is an auto-vacuum capable database.\n          */\n          static const VdbeOpList setMeta6[] = {\n            { OP_Transaction,    0,         1,                 0},    /* 0 */\n            { OP_ReadCookie,     0,         1,         BTREE_LARGEST_ROOT_PAGE},\n            { OP_If,             1,         0,                 0},    /* 2 */\n            { OP_Halt,           SQLITE_OK, OE_Abort,          0},    /* 3 */\n            { OP_Integer,        0,         1,                 0},    /* 4 */\n            { OP_SetCookie,      0,         BTREE_INCR_VACUUM, 1},    /* 5 */\n          };\n          int iAddr;\n          iAddr = sqlite3VdbeAddOpList(v, ArraySize(setMeta6), setMeta6);\n          sqlite3VdbeChangeP1(v, iAddr, iDb);\n          sqlite3VdbeChangeP1(v, iAddr+1, iDb);\n          sqlite3VdbeChangeP2(v, iAddr+2, iAddr+4);\n          sqlite3VdbeChangeP1(v, iAddr+4, eAuto-1);\n          sqlite3VdbeChangeP1(v, iAddr+5, iDb);\n          sqlite3VdbeUsesBtree(v, iDb);\n        }\n      }\n    }\n  }else\n#endif\n\n  /*\n  **  PRAGMA [database.]incremental_vacuum(N)\n  **\n  ** Do N steps of incremental vacuuming on a database.\n  */\n#ifndef SQLITE_OMIT_AUTOVACUUM\n  if( sqlite3StrICmp(zLeft,\"incremental_vacuum\")==0 ){\n    int iLimit, addr;\n    if( sqlite3ReadSchema(pParse) ){\n      goto pragma_out;\n    }\n    if( zRight==0 || !sqlite3GetInt32(zRight, &iLimit) || iLimit<=0 ){\n      iLimit = 0x7fffffff;\n    }\n    sqlite3BeginWriteOperation(pParse, 0, iDb);\n    sqlite3VdbeAddOp2(v, OP_Integer, iLimit, 1);\n    addr = sqlite3VdbeAddOp1(v, OP_IncrVacuum, iDb);\n    sqlite3VdbeAddOp1(v, OP_ResultRow, 1);\n    sqlite3VdbeAddOp2(v, OP_AddImm, 1, -1);\n    sqlite3VdbeAddOp2(v, OP_IfPos, 1, addr);\n    sqlite3VdbeJumpHere(v, addr);\n  }else\n#endif\n\n#ifndef SQLITE_OMIT_PAGER_PRAGMAS\n  /*\n  **  PRAGMA [database.]cache_size\n  **  PRAGMA [database.]cache_size=N\n  **\n  ** The first form reports the current local setting for the\n  ** page cache size.  The local setting can be different from\n  ** the persistent cache size value that is stored in the database\n  ** file itself.  The value returned is the maximum number of\n  ** pages in the page cache.  The second form sets the local\n  ** page cache size value.  It does not change the persistent\n  ** cache size stored on the disk so the cache size will revert\n  ** to its default value when the database is closed and reopened.\n  ** N should be a positive integer.\n  */\n  if( sqlite3StrICmp(zLeft,\"cache_size\")==0 ){\n    if( sqlite3ReadSchema(pParse) ) goto pragma_out;\n    if( !zRight ){\n      returnSingleInt(pParse, \"cache_size\", pDb->pSchema->cache_size);\n    }else{\n      int size = sqlite3AbsInt32(sqlite3Atoi(zRight));\n      pDb->pSchema->cache_size = size;\n      sqlite3BtreeSetCacheSize(pDb->pBt, pDb->pSchema->cache_size);\n    }\n  }else\n\n  /*\n  **   PRAGMA temp_store\n  **   PRAGMA temp_store = \"default\"|\"memory\"|\"file\"\n  **\n  ** Return or set the local value of the temp_store flag.  Changing\n  ** the local value does not make changes to the disk file and the default\n  ** value will be restored the next time the database is opened.\n  **\n  ** Note that it is possible for the library compile-time options to\n  ** override this setting\n  */\n  if( sqlite3StrICmp(zLeft, \"temp_store\")==0 ){\n    if( !zRight ){\n      returnSingleInt(pParse, \"temp_store\", db->temp_store);\n    }else{\n      changeTempStorage(pParse, zRight);\n    }\n  }else\n\n  /*\n  **   PRAGMA temp_store_directory\n  **   PRAGMA temp_store_directory = \"\"|\"directory_name\"\n  **\n  ** Return or set the local value of the temp_store_directory flag.  Changing\n  ** the value sets a specific directory to be used for temporary files.\n  ** Setting to a null string reverts to the default temporary directory search.\n  ** If temporary directory is changed, then invalidateTempStorage.\n  **\n  */\n  if( sqlite3StrICmp(zLeft, \"temp_store_directory\")==0 ){\n    if( !zRight ){\n      if( sqlite3_temp_directory ){\n        sqlite3VdbeSetNumCols(v, 1);\n        sqlite3VdbeSetColName(v, 0, COLNAME_NAME, \n            \"temp_store_directory\", SQLITE_STATIC);\n        sqlite3VdbeAddOp4(v, OP_String8, 0, 1, 0, sqlite3_temp_directory, 0);\n        sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 1);\n      }\n    }else{\n#ifndef SQLITE_OMIT_WSD\n      if( zRight[0] ){\n        int rc;\n        int res;\n        rc = sqlite3OsAccess(db->pVfs, zRight, SQLITE_ACCESS_READWRITE, &res);\n        if( rc!=SQLITE_OK || res==0 ){\n          sqlite3ErrorMsg(pParse, \"not a writable directory\");\n          goto pragma_out;\n        }\n      }\n      if( SQLITE_TEMP_STORE==0\n       || (SQLITE_TEMP_STORE==1 && db->temp_store<=1)\n       || (SQLITE_TEMP_STORE==2 && db->temp_store==1)\n      ){\n        invalidateTempStorage(pParse);\n      }\n      sqlite3_free(sqlite3_temp_directory);\n      if( zRight[0] ){\n        sqlite3_temp_directory = sqlite3_mprintf(\"%s\", zRight);\n      }else{\n        sqlite3_temp_directory = 0;\n      }\n#endif /* SQLITE_OMIT_WSD */\n    }\n  }else\n\n#if !defined(SQLITE_ENABLE_LOCKING_STYLE)\n#  if defined(__APPLE__)\n#    define SQLITE_ENABLE_LOCKING_STYLE 1\n#  else\n#    define SQLITE_ENABLE_LOCKING_STYLE 0\n#  endif\n#endif\n#if SQLITE_ENABLE_LOCKING_STYLE\n  /*\n   **   PRAGMA [database.]lock_proxy_file\n   **   PRAGMA [database.]lock_proxy_file = \":auto:\"|\"lock_file_path\"\n   **\n   ** Return or set the value of the lock_proxy_file flag.  Changing\n   ** the value sets a specific file to be used for database access locks.\n   **\n   */\n  if( sqlite3StrICmp(zLeft, \"lock_proxy_file\")==0 ){\n    if( !zRight ){\n      Pager *pPager = sqlite3BtreePager(pDb->pBt);\n      char *proxy_file_path = NULL;\n      sqlite3_file *pFile = sqlite3PagerFile(pPager);\n      sqlite3OsFileControl(pFile, SQLITE_GET_LOCKPROXYFILE, \n                           &proxy_file_path);\n      \n      if( proxy_file_path ){\n        sqlite3VdbeSetNumCols(v, 1);\n        sqlite3VdbeSetColName(v, 0, COLNAME_NAME, \n                              \"lock_proxy_file\", SQLITE_STATIC);\n        sqlite3VdbeAddOp4(v, OP_String8, 0, 1, 0, proxy_file_path, 0);\n        sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 1);\n      }\n    }else{\n      Pager *pPager = sqlite3BtreePager(pDb->pBt);\n      sqlite3_file *pFile = sqlite3PagerFile(pPager);\n      int res;\n      if( zRight[0] ){\n        res=sqlite3OsFileControl(pFile, SQLITE_SET_LOCKPROXYFILE, \n                                     zRight);\n      } else {\n        res=sqlite3OsFileControl(pFile, SQLITE_SET_LOCKPROXYFILE, \n                                     NULL);\n      }\n      if( res!=SQLITE_OK ){\n        sqlite3ErrorMsg(pParse, \"failed to set lock proxy file\");\n        goto pragma_out;\n      }\n    }\n  }else\n#endif /* SQLITE_ENABLE_LOCKING_STYLE */      \n    \n  /*\n  **   PRAGMA [database.]synchronous\n  **   PRAGMA [database.]synchronous=OFF|ON|NORMAL|FULL\n  **\n  ** Return or set the local value of the synchronous flag.  Changing\n  ** the local value does not make changes to the disk file and the\n  ** default value will be restored the next time the database is\n  ** opened.\n  */\n  if( sqlite3StrICmp(zLeft,\"synchronous\")==0 ){\n    if( sqlite3ReadSchema(pParse) ) goto pragma_out;\n    if( !zRight ){\n      returnSingleInt(pParse, \"synchronous\", pDb->safety_level-1);\n    }else{\n      if( !db->autoCommit ){\n        sqlite3ErrorMsg(pParse, \n            \"Safety level may not be changed inside a transaction\");\n      }else{\n        pDb->safety_level = getSafetyLevel(zRight)+1;\n      }\n    }\n  }else\n#endif /* SQLITE_OMIT_PAGER_PRAGMAS */\n\n#ifndef SQLITE_OMIT_FLAG_PRAGMAS\n  if( flagPragma(pParse, zLeft, zRight) ){\n    /* The flagPragma() subroutine also generates any necessary code\n    ** there is nothing more to do here */\n  }else\n#endif /* SQLITE_OMIT_FLAG_PRAGMAS */\n\n#ifndef SQLITE_OMIT_SCHEMA_PRAGMAS\n  /*\n  **   PRAGMA table_info(<table>)\n  **\n  ** Return a single row for each column of the named table. The columns of\n  ** the returned data set are:\n  **\n  ** cid:        Column id (numbered from left to right, starting at 0)\n  ** name:       Column name\n  ** type:       Column declaration type.\n  ** notnull:    True if 'NOT NULL' is part of column declaration\n  ** dflt_value: The default value for the column, if any.\n  */\n  if( sqlite3StrICmp(zLeft, \"table_info\")==0 && zRight ){\n    Table *pTab;\n    if( sqlite3ReadSchema(pParse) ) goto pragma_out;\n    pTab = sqlite3FindTable(db, zRight, zDb);\n    if( pTab ){\n      int i;\n      int nHidden = 0;\n      Column *pCol;\n      sqlite3VdbeSetNumCols(v, 6);\n      pParse->nMem = 6;\n      sqlite3VdbeSetColName(v, 0, COLNAME_NAME, \"cid\", SQLITE_STATIC);\n      sqlite3VdbeSetColName(v, 1, COLNAME_NAME, \"name\", SQLITE_STATIC);\n      sqlite3VdbeSetColName(v, 2, COLNAME_NAME, \"type\", SQLITE_STATIC);\n      sqlite3VdbeSetColName(v, 3, COLNAME_NAME, \"notnull\", SQLITE_STATIC);\n      sqlite3VdbeSetColName(v, 4, COLNAME_NAME, \"dflt_value\", SQLITE_STATIC);\n      sqlite3VdbeSetColName(v, 5, COLNAME_NAME, \"pk\", SQLITE_STATIC);\n      sqlite3ViewGetColumnNames(pParse, pTab);\n      for(i=0, pCol=pTab->aCol; i<pTab->nCol; i++, pCol++){\n        if( IsHiddenColumn(pCol) ){\n          nHidden++;\n          continue;\n        }\n        sqlite3VdbeAddOp2(v, OP_Integer, i-nHidden, 1);\n        sqlite3VdbeAddOp4(v, OP_String8, 0, 2, 0, pCol->zName, 0);\n        sqlite3VdbeAddOp4(v, OP_String8, 0, 3, 0,\n           pCol->zType ? pCol->zType : \"\", 0);\n        sqlite3VdbeAddOp2(v, OP_Integer, (pCol->notNull ? 1 : 0), 4);\n        if( pCol->zDflt ){\n          sqlite3VdbeAddOp4(v, OP_String8, 0, 5, 0, (char*)pCol->zDflt, 0);\n        }else{\n          sqlite3VdbeAddOp2(v, OP_Null, 0, 5);\n        }\n        sqlite3VdbeAddOp2(v, OP_Integer, pCol->isPrimKey, 6);\n        sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 6);\n      }\n    }\n  }else\n\n  if( sqlite3StrICmp(zLeft, \"index_info\")==0 && zRight ){\n    Index *pIdx;\n    Table *pTab;\n    if( sqlite3ReadSchema(pParse) ) goto pragma_out;\n    pIdx = sqlite3FindIndex(db, zRight, zDb);\n    if( pIdx ){\n      int i;\n      pTab = pIdx->pTable;\n      sqlite3VdbeSetNumCols(v, 3);\n      pParse->nMem = 3;\n      sqlite3VdbeSetColName(v, 0, COLNAME_NAME, \"seqno\", SQLITE_STATIC);\n      sqlite3VdbeSetColName(v, 1, COLNAME_NAME, \"cid\", SQLITE_STATIC);\n      sqlite3VdbeSetColName(v, 2, COLNAME_NAME, \"name\", SQLITE_STATIC);\n      for(i=0; i<pIdx->nColumn; i++){\n        int cnum = pIdx->aiColumn[i];\n        sqlite3VdbeAddOp2(v, OP_Integer, i, 1);\n        sqlite3VdbeAddOp2(v, OP_Integer, cnum, 2);\n        assert( pTab->nCol>cnum );\n        sqlite3VdbeAddOp4(v, OP_String8, 0, 3, 0, pTab->aCol[cnum].zName, 0);\n        sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 3);\n      }\n    }\n  }else\n\n  if( sqlite3StrICmp(zLeft, \"index_list\")==0 && zRight ){\n    Index *pIdx;\n    Table *pTab;\n    if( sqlite3ReadSchema(pParse) ) goto pragma_out;\n    pTab = sqlite3FindTable(db, zRight, zDb);\n    if( pTab ){\n      v = sqlite3GetVdbe(pParse);\n      pIdx = pTab->pIndex;\n      if( pIdx ){\n        int i = 0; \n        sqlite3VdbeSetNumCols(v, 3);\n        pParse->nMem = 3;\n        sqlite3VdbeSetColName(v, 0, COLNAME_NAME, \"seq\", SQLITE_STATIC);\n        sqlite3VdbeSetColName(v, 1, COLNAME_NAME, \"name\", SQLITE_STATIC);\n        sqlite3VdbeSetColName(v, 2, COLNAME_NAME, \"unique\", SQLITE_STATIC);\n        while(pIdx){\n          sqlite3VdbeAddOp2(v, OP_Integer, i, 1);\n          sqlite3VdbeAddOp4(v, OP_String8, 0, 2, 0, pIdx->zName, 0);\n          sqlite3VdbeAddOp2(v, OP_Integer, pIdx->onError!=OE_None, 3);\n          sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 3);\n          ++i;\n          pIdx = pIdx->pNext;\n        }\n      }\n    }\n  }else\n\n  if( sqlite3StrICmp(zLeft, \"database_list\")==0 ){\n    int i;\n    if( sqlite3ReadSchema(pParse) ) goto pragma_out;\n    sqlite3VdbeSetNumCols(v, 3);\n    pParse->nMem = 3;\n    sqlite3VdbeSetColName(v, 0, COLNAME_NAME, \"seq\", SQLITE_STATIC);\n    sqlite3VdbeSetColName(v, 1, COLNAME_NAME, \"name\", SQLITE_STATIC);\n    sqlite3VdbeSetColName(v, 2, COLNAME_NAME, \"file\", SQLITE_STATIC);\n    for(i=0; i<db->nDb; i++){\n      if( db->aDb[i].pBt==0 ) continue;\n      assert( db->aDb[i].zName!=0 );\n      sqlite3VdbeAddOp2(v, OP_Integer, i, 1);\n      sqlite3VdbeAddOp4(v, OP_String8, 0, 2, 0, db->aDb[i].zName, 0);\n      sqlite3VdbeAddOp4(v, OP_String8, 0, 3, 0,\n           sqlite3BtreeGetFilename(db->aDb[i].pBt), 0);\n      sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 3);\n    }\n  }else\n\n  if( sqlite3StrICmp(zLeft, \"collation_list\")==0 ){\n    int i = 0;\n    HashElem *p;\n    sqlite3VdbeSetNumCols(v, 2);\n    pParse->nMem = 2;\n    sqlite3VdbeSetColName(v, 0, COLNAME_NAME, \"seq\", SQLITE_STATIC);\n    sqlite3VdbeSetColName(v, 1, COLNAME_NAME, \"name\", SQLITE_STATIC);\n    for(p=sqliteHashFirst(&db->aCollSeq); p; p=sqliteHashNext(p)){\n      CollSeq *pColl = (CollSeq *)sqliteHashData(p);\n      sqlite3VdbeAddOp2(v, OP_Integer, i++, 1);\n      sqlite3VdbeAddOp4(v, OP_String8, 0, 2, 0, pColl->zName, 0);\n      sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 2);\n    }\n  }else\n#endif /* SQLITE_OMIT_SCHEMA_PRAGMAS */\n\n#ifndef SQLITE_OMIT_FOREIGN_KEY\n  if( sqlite3StrICmp(zLeft, \"foreign_key_list\")==0 && zRight ){\n    FKey *pFK;\n    Table *pTab;\n    if( sqlite3ReadSchema(pParse) ) goto pragma_out;\n    pTab = sqlite3FindTable(db, zRight, zDb);\n    if( pTab ){\n      v = sqlite3GetVdbe(pParse);\n      pFK = pTab->pFKey;\n      if( pFK ){\n        int i = 0; \n        sqlite3VdbeSetNumCols(v, 8);\n        pParse->nMem = 8;\n        sqlite3VdbeSetColName(v, 0, COLNAME_NAME, \"id\", SQLITE_STATIC);\n        sqlite3VdbeSetColName(v, 1, COLNAME_NAME, \"seq\", SQLITE_STATIC);\n        sqlite3VdbeSetColName(v, 2, COLNAME_NAME, \"table\", SQLITE_STATIC);\n        sqlite3VdbeSetColName(v, 3, COLNAME_NAME, \"from\", SQLITE_STATIC);\n        sqlite3VdbeSetColName(v, 4, COLNAME_NAME, \"to\", SQLITE_STATIC);\n        sqlite3VdbeSetColName(v, 5, COLNAME_NAME, \"on_update\", SQLITE_STATIC);\n        sqlite3VdbeSetColName(v, 6, COLNAME_NAME, \"on_delete\", SQLITE_STATIC);\n        sqlite3VdbeSetColName(v, 7, COLNAME_NAME, \"match\", SQLITE_STATIC);\n        while(pFK){\n          int j;\n          for(j=0; j<pFK->nCol; j++){\n            char *zCol = pFK->aCol[j].zCol;\n            char *zOnDelete = (char *)actionName(pFK->aAction[0]);\n            char *zOnUpdate = (char *)actionName(pFK->aAction[1]);\n            sqlite3VdbeAddOp2(v, OP_Integer, i, 1);\n            sqlite3VdbeAddOp2(v, OP_Integer, j, 2);\n            sqlite3VdbeAddOp4(v, OP_String8, 0, 3, 0, pFK->zTo, 0);\n            sqlite3VdbeAddOp4(v, OP_String8, 0, 4, 0,\n                              pTab->aCol[pFK->aCol[j].iFrom].zName, 0);\n            sqlite3VdbeAddOp4(v, zCol ? OP_String8 : OP_Null, 0, 5, 0, zCol, 0);\n            sqlite3VdbeAddOp4(v, OP_String8, 0, 6, 0, zOnUpdate, 0);\n            sqlite3VdbeAddOp4(v, OP_String8, 0, 7, 0, zOnDelete, 0);\n            sqlite3VdbeAddOp4(v, OP_String8, 0, 8, 0, \"NONE\", 0);\n            sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 8);\n          }\n          ++i;\n          pFK = pFK->pNextFrom;\n        }\n      }\n    }\n  }else\n#endif /* !defined(SQLITE_OMIT_FOREIGN_KEY) */\n\n#ifndef NDEBUG\n  if( sqlite3StrICmp(zLeft, \"parser_trace\")==0 ){\n    if( zRight ){\n      if( getBoolean(zRight) ){\n        sqlite3ParserTrace(stderr, \"parser: \");\n      }else{\n        sqlite3ParserTrace(0, 0);\n      }\n    }\n  }else\n#endif\n\n  /* Reinstall the LIKE and GLOB functions.  The variant of LIKE\n  ** used will be case sensitive or not depending on the RHS.\n  */\n  if( sqlite3StrICmp(zLeft, \"case_sensitive_like\")==0 ){\n    if( zRight ){\n      sqlite3RegisterLikeFunctions(db, getBoolean(zRight));\n    }\n  }else\n\n#ifndef SQLITE_INTEGRITY_CHECK_ERROR_MAX\n# define SQLITE_INTEGRITY_CHECK_ERROR_MAX 100\n#endif\n\n#ifndef SQLITE_OMIT_INTEGRITY_CHECK\n  /* Pragma \"quick_check\" is an experimental reduced version of \n  ** integrity_check designed to detect most database corruption\n  ** without most of the overhead of a full integrity-check.\n  */\n  if( sqlite3StrICmp(zLeft, \"integrity_check\")==0\n   || sqlite3StrICmp(zLeft, \"quick_check\")==0 \n  ){\n    int i, j, addr, mxErr;\n\n    /* Code that appears at the end of the integrity check.  If no error\n    ** messages have been generated, output OK.  Otherwise output the\n    ** error message\n    */\n    static const VdbeOpList endCode[] = {\n      { OP_AddImm,      1, 0,        0},    /* 0 */\n      { OP_IfNeg,       1, 0,        0},    /* 1 */\n      { OP_String8,     0, 3,        0},    /* 2 */\n      { OP_ResultRow,   3, 1,        0},\n    };\n\n    int isQuick = (zLeft[0]=='q');\n\n    /* Initialize the VDBE program */\n    if( sqlite3ReadSchema(pParse) ) goto pragma_out;\n    pParse->nMem = 6;\n    sqlite3VdbeSetNumCols(v, 1);\n    sqlite3VdbeSetColName(v, 0, COLNAME_NAME, \"integrity_check\", SQLITE_STATIC);\n\n    /* Set the maximum error count */\n    mxErr = SQLITE_INTEGRITY_CHECK_ERROR_MAX;\n    if( zRight ){\n      sqlite3GetInt32(zRight, &mxErr);\n      if( mxErr<=0 ){\n        mxErr = SQLITE_INTEGRITY_CHECK_ERROR_MAX;\n      }\n    }\n    sqlite3VdbeAddOp2(v, OP_Integer, mxErr, 1);  /* reg[1] holds errors left */\n\n    /* Do an integrity check on each database file */\n    for(i=0; i<db->nDb; i++){\n      HashElem *x;\n      Hash *pTbls;\n      int cnt = 0;\n\n      if( OMIT_TEMPDB && i==1 ) continue;\n\n      sqlite3CodeVerifySchema(pParse, i);\n      addr = sqlite3VdbeAddOp1(v, OP_IfPos, 1); /* Halt if out of errors */\n      sqlite3VdbeAddOp2(v, OP_Halt, 0, 0);\n      sqlite3VdbeJumpHere(v, addr);\n\n      /* Do an integrity check of the B-Tree\n      **\n      ** Begin by filling registers 2, 3, ... with the root pages numbers\n      ** for all tables and indices in the database.\n      */\n      pTbls = &db->aDb[i].pSchema->tblHash;\n      for(x=sqliteHashFirst(pTbls); x; x=sqliteHashNext(x)){\n        Table *pTab = sqliteHashData(x);\n        Index *pIdx;\n        sqlite3VdbeAddOp2(v, OP_Integer, pTab->tnum, 2+cnt);\n        cnt++;\n        for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){\n          sqlite3VdbeAddOp2(v, OP_Integer, pIdx->tnum, 2+cnt);\n          cnt++;\n        }\n      }\n\n      /* Make sure sufficient number of registers have been allocated */\n      if( pParse->nMem < cnt+4 ){\n        pParse->nMem = cnt+4;\n      }\n\n      /* Do the b-tree integrity checks */\n      sqlite3VdbeAddOp3(v, OP_IntegrityCk, 2, cnt, 1);\n      sqlite3VdbeChangeP5(v, (u8)i);\n      addr = sqlite3VdbeAddOp1(v, OP_IsNull, 2);\n      sqlite3VdbeAddOp4(v, OP_String8, 0, 3, 0,\n         sqlite3MPrintf(db, \"*** in database %s ***\\n\", db->aDb[i].zName),\n         P4_DYNAMIC);\n      sqlite3VdbeAddOp3(v, OP_Move, 2, 4, 1);\n      sqlite3VdbeAddOp3(v, OP_Concat, 4, 3, 2);\n      sqlite3VdbeAddOp2(v, OP_ResultRow, 2, 1);\n      sqlite3VdbeJumpHere(v, addr);\n\n      /* Make sure all the indices are constructed correctly.\n      */\n      for(x=sqliteHashFirst(pTbls); x && !isQuick; x=sqliteHashNext(x)){\n        Table *pTab = sqliteHashData(x);\n        Index *pIdx;\n        int loopTop;\n\n        if( pTab->pIndex==0 ) continue;\n        addr = sqlite3VdbeAddOp1(v, OP_IfPos, 1);  /* Stop if out of errors */\n        sqlite3VdbeAddOp2(v, OP_Halt, 0, 0);\n        sqlite3VdbeJumpHere(v, addr);\n        sqlite3OpenTableAndIndices(pParse, pTab, 1, OP_OpenRead);\n        sqlite3VdbeAddOp2(v, OP_Integer, 0, 2);  /* reg(2) will count entries */\n        loopTop = sqlite3VdbeAddOp2(v, OP_Rewind, 1, 0);\n        sqlite3VdbeAddOp2(v, OP_AddImm, 2, 1);   /* increment entry count */\n        for(j=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, j++){\n          int jmp2;\n          int r1;\n          static const VdbeOpList idxErr[] = {\n            { OP_AddImm,      1, -1,  0},\n            { OP_String8,     0,  3,  0},    /* 1 */\n            { OP_Rowid,       1,  4,  0},\n            { OP_String8,     0,  5,  0},    /* 3 */\n            { OP_String8,     0,  6,  0},    /* 4 */\n            { OP_Concat,      4,  3,  3},\n            { OP_Concat,      5,  3,  3},\n            { OP_Concat,      6,  3,  3},\n            { OP_ResultRow,   3,  1,  0},\n            { OP_IfPos,       1,  0,  0},    /* 9 */\n            { OP_Halt,        0,  0,  0},\n          };\n          r1 = sqlite3GenerateIndexKey(pParse, pIdx, 1, 3, 0);\n          jmp2 = sqlite3VdbeAddOp4Int(v, OP_Found, j+2, 0, r1, pIdx->nColumn+1);\n          addr = sqlite3VdbeAddOpList(v, ArraySize(idxErr), idxErr);\n          sqlite3VdbeChangeP4(v, addr+1, \"rowid \", P4_STATIC);\n          sqlite3VdbeChangeP4(v, addr+3, \" missing from index \", P4_STATIC);\n          sqlite3VdbeChangeP4(v, addr+4, pIdx->zName, P4_STATIC);\n          sqlite3VdbeJumpHere(v, addr+9);\n          sqlite3VdbeJumpHere(v, jmp2);\n        }\n        sqlite3VdbeAddOp2(v, OP_Next, 1, loopTop+1);\n        sqlite3VdbeJumpHere(v, loopTop);\n        for(j=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, j++){\n          static const VdbeOpList cntIdx[] = {\n             { OP_Integer,      0,  3,  0},\n             { OP_Rewind,       0,  0,  0},  /* 1 */\n             { OP_AddImm,       3,  1,  0},\n             { OP_Next,         0,  0,  0},  /* 3 */\n             { OP_Eq,           2,  0,  3},  /* 4 */\n             { OP_AddImm,       1, -1,  0},\n             { OP_String8,      0,  2,  0},  /* 6 */\n             { OP_String8,      0,  3,  0},  /* 7 */\n             { OP_Concat,       3,  2,  2},\n             { OP_ResultRow,    2,  1,  0},\n          };\n          addr = sqlite3VdbeAddOp1(v, OP_IfPos, 1);\n          sqlite3VdbeAddOp2(v, OP_Halt, 0, 0);\n          sqlite3VdbeJumpHere(v, addr);\n          addr = sqlite3VdbeAddOpList(v, ArraySize(cntIdx), cntIdx);\n          sqlite3VdbeChangeP1(v, addr+1, j+2);\n          sqlite3VdbeChangeP2(v, addr+1, addr+4);\n          sqlite3VdbeChangeP1(v, addr+3, j+2);\n          sqlite3VdbeChangeP2(v, addr+3, addr+2);\n          sqlite3VdbeJumpHere(v, addr+4);\n          sqlite3VdbeChangeP4(v, addr+6, \n                     \"wrong # of entries in index \", P4_STATIC);\n          sqlite3VdbeChangeP4(v, addr+7, pIdx->zName, P4_STATIC);\n        }\n      } \n    }\n    addr = sqlite3VdbeAddOpList(v, ArraySize(endCode), endCode);\n    sqlite3VdbeChangeP2(v, addr, -mxErr);\n    sqlite3VdbeJumpHere(v, addr+1);\n    sqlite3VdbeChangeP4(v, addr+2, \"ok\", P4_STATIC);\n  }else\n#endif /* SQLITE_OMIT_INTEGRITY_CHECK */\n\n#ifndef SQLITE_OMIT_UTF16\n  /*\n  **   PRAGMA encoding\n  **   PRAGMA encoding = \"utf-8\"|\"utf-16\"|\"utf-16le\"|\"utf-16be\"\n  **\n  ** In its first form, this pragma returns the encoding of the main\n  ** database. If the database is not initialized, it is initialized now.\n  **\n  ** The second form of this pragma is a no-op if the main database file\n  ** has not already been initialized. In this case it sets the default\n  ** encoding that will be used for the main database file if a new file\n  ** is created. If an existing main database file is opened, then the\n  ** default text encoding for the existing database is used.\n  ** \n  ** In all cases new databases created using the ATTACH command are\n  ** created to use the same default text encoding as the main database. If\n  ** the main database has not been initialized and/or created when ATTACH\n  ** is executed, this is done before the ATTACH operation.\n  **\n  ** In the second form this pragma sets the text encoding to be used in\n  ** new database files created using this database handle. It is only\n  ** useful if invoked immediately after the main database i\n  */\n  if( sqlite3StrICmp(zLeft, \"encoding\")==0 ){\n    static const struct EncName {\n      char *zName;\n      u8 enc;\n    } encnames[] = {\n      { \"UTF8\",     SQLITE_UTF8        },\n      { \"UTF-8\",    SQLITE_UTF8        },  /* Must be element [1] */\n      { \"UTF-16le\", SQLITE_UTF16LE     },  /* Must be element [2] */\n      { \"UTF-16be\", SQLITE_UTF16BE     },  /* Must be element [3] */\n      { \"UTF16le\",  SQLITE_UTF16LE     },\n      { \"UTF16be\",  SQLITE_UTF16BE     },\n      { \"UTF-16\",   0                  }, /* SQLITE_UTF16NATIVE */\n      { \"UTF16\",    0                  }, /* SQLITE_UTF16NATIVE */\n      { 0, 0 }\n    };\n    const struct EncName *pEnc;\n    if( !zRight ){    /* \"PRAGMA encoding\" */\n      if( sqlite3ReadSchema(pParse) ) goto pragma_out;\n      sqlite3VdbeSetNumCols(v, 1);\n      sqlite3VdbeSetColName(v, 0, COLNAME_NAME, \"encoding\", SQLITE_STATIC);\n      sqlite3VdbeAddOp2(v, OP_String8, 0, 1);\n      assert( encnames[SQLITE_UTF8].enc==SQLITE_UTF8 );\n      assert( encnames[SQLITE_UTF16LE].enc==SQLITE_UTF16LE );\n      assert( encnames[SQLITE_UTF16BE].enc==SQLITE_UTF16BE );\n      sqlite3VdbeChangeP4(v, -1, encnames[ENC(pParse->db)].zName, P4_STATIC);\n      sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 1);\n    }else{                        /* \"PRAGMA encoding = XXX\" */\n      /* Only change the value of sqlite.enc if the database handle is not\n      ** initialized. If the main database exists, the new sqlite.enc value\n      ** will be overwritten when the schema is next loaded. If it does not\n      ** already exists, it will be created to use the new encoding value.\n      */\n      if( \n        !(DbHasProperty(db, 0, DB_SchemaLoaded)) || \n        DbHasProperty(db, 0, DB_Empty) \n      ){\n        for(pEnc=&encnames[0]; pEnc->zName; pEnc++){\n          if( 0==sqlite3StrICmp(zRight, pEnc->zName) ){\n            ENC(pParse->db) = pEnc->enc ? pEnc->enc : SQLITE_UTF16NATIVE;\n            break;\n          }\n        }\n        if( !pEnc->zName ){\n          sqlite3ErrorMsg(pParse, \"unsupported encoding: %s\", zRight);\n        }\n      }\n    }\n  }else\n#endif /* SQLITE_OMIT_UTF16 */\n\n#ifndef SQLITE_OMIT_SCHEMA_VERSION_PRAGMAS\n  /*\n  **   PRAGMA [database.]schema_version\n  **   PRAGMA [database.]schema_version = <integer>\n  **\n  **   PRAGMA [database.]user_version\n  **   PRAGMA [database.]user_version = <integer>\n  **\n  ** The pragma's schema_version and user_version are used to set or get\n  ** the value of the schema-version and user-version, respectively. Both\n  ** the schema-version and the user-version are 32-bit signed integers\n  ** stored in the database header.\n  **\n  ** The schema-cookie is usually only manipulated internally by SQLite. It\n  ** is incremented by SQLite whenever the database schema is modified (by\n  ** creating or dropping a table or index). The schema version is used by\n  ** SQLite each time a query is executed to ensure that the internal cache\n  ** of the schema used when compiling the SQL query matches the schema of\n  ** the database against which the compiled query is actually executed.\n  ** Subverting this mechanism by using \"PRAGMA schema_version\" to modify\n  ** the schema-version is potentially dangerous and may lead to program\n  ** crashes or database corruption. Use with caution!\n  **\n  ** The user-version is not used internally by SQLite. It may be used by\n  ** applications for any purpose.\n  */\n  if( sqlite3StrICmp(zLeft, \"schema_version\")==0 \n   || sqlite3StrICmp(zLeft, \"user_version\")==0 \n   || sqlite3StrICmp(zLeft, \"freelist_count\")==0 \n  ){\n    int iCookie;   /* Cookie index. 1 for schema-cookie, 6 for user-cookie. */\n    sqlite3VdbeUsesBtree(v, iDb);\n    switch( zLeft[0] ){\n      case 'f': case 'F':\n        iCookie = BTREE_FREE_PAGE_COUNT;\n        break;\n      case 's': case 'S':\n        iCookie = BTREE_SCHEMA_VERSION;\n        break;\n      default:\n        iCookie = BTREE_USER_VERSION;\n        break;\n    }\n\n    if( zRight && iCookie!=BTREE_FREE_PAGE_COUNT ){\n      /* Write the specified cookie value */\n      static const VdbeOpList setCookie[] = {\n        { OP_Transaction,    0,  1,  0},    /* 0 */\n        { OP_Integer,        0,  1,  0},    /* 1 */\n        { OP_SetCookie,      0,  0,  1},    /* 2 */\n      };\n      int addr = sqlite3VdbeAddOpList(v, ArraySize(setCookie), setCookie);\n      sqlite3VdbeChangeP1(v, addr, iDb);\n      sqlite3VdbeChangeP1(v, addr+1, sqlite3Atoi(zRight));\n      sqlite3VdbeChangeP1(v, addr+2, iDb);\n      sqlite3VdbeChangeP2(v, addr+2, iCookie);\n    }else{\n      /* Read the specified cookie value */\n      static const VdbeOpList readCookie[] = {\n        { OP_Transaction,     0,  0,  0},    /* 0 */\n        { OP_ReadCookie,      0,  1,  0},    /* 1 */\n        { OP_ResultRow,       1,  1,  0}\n      };\n      int addr = sqlite3VdbeAddOpList(v, ArraySize(readCookie), readCookie);\n      sqlite3VdbeChangeP1(v, addr, iDb);\n      sqlite3VdbeChangeP1(v, addr+1, iDb);\n      sqlite3VdbeChangeP3(v, addr+1, iCookie);\n      sqlite3VdbeSetNumCols(v, 1);\n      sqlite3VdbeSetColName(v, 0, COLNAME_NAME, zLeft, SQLITE_TRANSIENT);\n    }\n  }else\n#endif /* SQLITE_OMIT_SCHEMA_VERSION_PRAGMAS */\n\n#ifndef SQLITE_OMIT_COMPILEOPTION_DIAGS\n  /*\n  **   PRAGMA compile_options\n  **\n  ** Return the names of all compile-time options used in this build,\n  ** one option per row.\n  */\n  if( sqlite3StrICmp(zLeft, \"compile_options\")==0 ){\n    int i = 0;\n    const char *zOpt;\n    sqlite3VdbeSetNumCols(v, 1);\n    pParse->nMem = 1;\n    sqlite3VdbeSetColName(v, 0, COLNAME_NAME, \"compile_option\", SQLITE_STATIC);\n    while( (zOpt = sqlite3_compileoption_get(i++))!=0 ){\n      sqlite3VdbeAddOp4(v, OP_String8, 0, 1, 0, zOpt, 0);\n      sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 1);\n    }\n  }else\n#endif /* SQLITE_OMIT_COMPILEOPTION_DIAGS */\n\n#ifndef SQLITE_OMIT_WAL\n  /*\n  **   PRAGMA [database.]wal_checkpoint = passive|full|restart\n  **\n  ** Checkpoint the database.\n  */\n  if( sqlite3StrICmp(zLeft, \"wal_checkpoint\")==0 ){\n    int iBt = (pId2->z?iDb:SQLITE_MAX_ATTACHED);\n    int eMode = SQLITE_CHECKPOINT_PASSIVE;\n    if( zRight ){\n      if( sqlite3StrICmp(zRight, \"full\")==0 ){\n        eMode = SQLITE_CHECKPOINT_FULL;\n      }else if( sqlite3StrICmp(zRight, \"restart\")==0 ){\n        eMode = SQLITE_CHECKPOINT_RESTART;\n      }\n    }\n    if( sqlite3ReadSchema(pParse) ) goto pragma_out;\n    sqlite3VdbeSetNumCols(v, 3);\n    pParse->nMem = 3;\n    sqlite3VdbeSetColName(v, 0, COLNAME_NAME, \"busy\", SQLITE_STATIC);\n    sqlite3VdbeSetColName(v, 1, COLNAME_NAME, \"log\", SQLITE_STATIC);\n    sqlite3VdbeSetColName(v, 2, COLNAME_NAME, \"checkpointed\", SQLITE_STATIC);\n\n    sqlite3VdbeAddOp3(v, OP_Checkpoint, iBt, eMode, 1);\n    sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 3);\n  }else\n\n  /*\n  **   PRAGMA wal_autocheckpoint\n  **   PRAGMA wal_autocheckpoint = N\n  **\n  ** Configure a database connection to automatically checkpoint a database\n  ** after accumulating N frames in the log. Or query for the current value\n  ** of N.\n  */\n  if( sqlite3StrICmp(zLeft, \"wal_autocheckpoint\")==0 ){\n    if( zRight ){\n      sqlite3_wal_autocheckpoint(db, sqlite3Atoi(zRight));\n    }\n    returnSingleInt(pParse, \"wal_autocheckpoint\", \n       db->xWalCallback==sqlite3WalDefaultHook ? \n           SQLITE_PTR_TO_INT(db->pWalArg) : 0);\n  }else\n#endif\n\n#if defined(SQLITE_DEBUG) || defined(SQLITE_TEST)\n  /*\n  ** Report the current state of file logs for all databases\n  */\n  if( sqlite3StrICmp(zLeft, \"lock_status\")==0 ){\n    static const char *const azLockName[] = {\n      \"unlocked\", \"shared\", \"reserved\", \"pending\", \"exclusive\"\n    };\n    int i;\n    sqlite3VdbeSetNumCols(v, 2);\n    pParse->nMem = 2;\n    sqlite3VdbeSetColName(v, 0, COLNAME_NAME, \"database\", SQLITE_STATIC);\n    sqlite3VdbeSetColName(v, 1, COLNAME_NAME, \"status\", SQLITE_STATIC);\n    for(i=0; i<db->nDb; i++){\n      Btree *pBt;\n      Pager *pPager;\n      const char *zState = \"unknown\";\n      int j;\n      if( db->aDb[i].zName==0 ) continue;\n      sqlite3VdbeAddOp4(v, OP_String8, 0, 1, 0, db->aDb[i].zName, P4_STATIC);\n      pBt = db->aDb[i].pBt;\n      if( pBt==0 || (pPager = sqlite3BtreePager(pBt))==0 ){\n        zState = \"closed\";\n      }else if( sqlite3_file_control(db, i ? db->aDb[i].zName : 0, \n                                     SQLITE_FCNTL_LOCKSTATE, &j)==SQLITE_OK ){\n         zState = azLockName[j];\n      }\n      sqlite3VdbeAddOp4(v, OP_String8, 0, 2, 0, zState, P4_STATIC);\n      sqlite3VdbeAddOp2(v, OP_ResultRow, 1, 2);\n    }\n\n  }else\n#endif\n\n#if defined(SQLITE_HAS_CODEC) && !defined(SQLITE_HAS_CODEC_NO_ENCRYPTION)\n  if( sqlite3StrICmp(zLeft, \"key\")==0 && zRight ){\n    sqlite3_key(db, zRight, sqlite3Strlen30(zRight));\n  }else\n  if( sqlite3StrICmp(zLeft, \"rekey\")==0 && zRight ){\n    sqlite3_rekey(db, zRight, sqlite3Strlen30(zRight));\n  }else\n  if( zRight && (sqlite3StrICmp(zLeft, \"hexkey\")==0 ||\n                 sqlite3StrICmp(zLeft, \"hexrekey\")==0) ){\n    int i, h1, h2;\n    char zKey[40];\n    for(i=0; (h1 = zRight[i])!=0 && (h2 = zRight[i+1])!=0; i+=2){\n      h1 += 9*(1&(h1>>6));\n      h2 += 9*(1&(h2>>6));\n      zKey[i/2] = (h2 & 0x0f) | ((h1 & 0xf)<<4);\n    }\n    if( (zLeft[3] & 0xf)==0xb ){\n      sqlite3_key(db, zKey, i/2);\n    }else{\n      sqlite3_rekey(db, zKey, i/2);\n    }\n  }else\n#endif\n#if (defined(SQLITE_HAS_CODEC) || defined(SQLITE_ENABLE_CEROD)) && !defined(SQLITE_HAS_CODEC_NO_ENCRYPTION)\n  if( sqlite3StrICmp(zLeft, \"activate_extensions\")==0 ){\n#ifdef SQLITE_HAS_CODEC\n    if( sqlite3StrNICmp(zRight, \"see-\", 4)==0 ){\n      sqlite3_activate_see(&zRight[4]);\n    }\n#endif\n#ifdef SQLITE_ENABLE_CEROD\n    if( sqlite3StrNICmp(zRight, \"cerod-\", 6)==0 ){\n      sqlite3_activate_cerod(&zRight[6]);\n    }\n#endif\n  }else\n#endif\n\n \n  {/* Empty ELSE clause */}\n\n  /*\n  ** Reset the safety level, in case the fullfsync flag or synchronous\n  ** setting changed.\n  */\n#ifndef SQLITE_OMIT_PAGER_PRAGMAS\n  if( db->autoCommit ){\n    sqlite3BtreeSetSafetyLevel(pDb->pBt, pDb->safety_level,\n               (db->flags&SQLITE_FullFSync)!=0,\n               (db->flags&SQLITE_CkptFullFSync)!=0);\n  }\n#endif\npragma_out:\n  sqlite3DbFree(db, zLeft);\n  sqlite3DbFree(db, zRight);\n}\n\n#endif /* SQLITE_OMIT_PRAGMA */\n\n/************** End of pragma.c **********************************************/\n/************** Begin file prepare.c *****************************************/\n/*\n** 2005 May 25\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains the implementation of the sqlite3_prepare()\n** interface, and routines that contribute to loading the database schema\n** from disk.\n*/\n\n/*\n** Fill the InitData structure with an error message that indicates\n** that the database is corrupt.\n*/\nstatic void corruptSchema(\n  InitData *pData,     /* Initialization context */\n  const char *zObj,    /* Object being parsed at the point of error */\n  const char *zExtra   /* Error information */\n){\n  sqlite3 *db = pData->db;\n  if( !db->mallocFailed && (db->flags & SQLITE_RecoveryMode)==0 ){\n    if( zObj==0 ) zObj = \"?\";\n    sqlite3SetString(pData->pzErrMsg, db,\n      \"malformed database schema (%s)\", zObj);\n    if( zExtra ){\n      *pData->pzErrMsg = sqlite3MAppendf(db, *pData->pzErrMsg, \n                                 \"%s - %s\", *pData->pzErrMsg, zExtra);\n    }\n  }\n  pData->rc = db->mallocFailed ? SQLITE_NOMEM : SQLITE_CORRUPT;\n}\n\n/*\n** This is the callback routine for the code that initializes the\n** database.  See sqlite3Init() below for additional information.\n** This routine is also called from the OP_ParseSchema opcode of the VDBE.\n**\n** Each callback contains the following information:\n**\n**     argv[0] = name of thing being created\n**     argv[1] = root page number for table or index. 0 for trigger or view.\n**     argv[2] = SQL text for the CREATE statement.\n**\n*/\nSQLITE_PRIVATE int sqlite3InitCallback(void *pInit, int argc, char **argv, char **NotUsed){\n  InitData *pData = (InitData*)pInit;\n  sqlite3 *db = pData->db;\n  int iDb = pData->iDb;\n\n  assert( argc==3 );\n  UNUSED_PARAMETER2(NotUsed, argc);\n  assert( sqlite3_mutex_held(db->mutex) );\n  DbClearProperty(db, iDb, DB_Empty);\n  if( db->mallocFailed ){\n    corruptSchema(pData, argv[0], 0);\n    return 1;\n  }\n\n  assert( iDb>=0 && iDb<db->nDb );\n  if( argv==0 ) return 0;   /* Might happen if EMPTY_RESULT_CALLBACKS are on */\n  if( argv[1]==0 ){\n    corruptSchema(pData, argv[0], 0);\n  }else if( argv[2] && argv[2][0] ){\n    /* Call the parser to process a CREATE TABLE, INDEX or VIEW.\n    ** But because db->init.busy is set to 1, no VDBE code is generated\n    ** or executed.  All the parser does is build the internal data\n    ** structures that describe the table, index, or view.\n    */\n    int rc;\n    sqlite3_stmt *pStmt;\n    TESTONLY(int rcp);            /* Return code from sqlite3_prepare() */\n\n    assert( db->init.busy );\n    db->init.iDb = iDb;\n    db->init.newTnum = sqlite3Atoi(argv[1]);\n    db->init.orphanTrigger = 0;\n    TESTONLY(rcp = ) sqlite3_prepare(db, argv[2], -1, &pStmt, 0);\n    rc = db->errCode;\n    assert( (rc&0xFF)==(rcp&0xFF) );\n    db->init.iDb = 0;\n    if( SQLITE_OK!=rc ){\n      if( db->init.orphanTrigger ){\n        assert( iDb==1 );\n      }else{\n        pData->rc = rc;\n        if( rc==SQLITE_NOMEM ){\n          db->mallocFailed = 1;\n        }else if( rc!=SQLITE_INTERRUPT && (rc&0xFF)!=SQLITE_LOCKED ){\n          corruptSchema(pData, argv[0], sqlite3_errmsg(db));\n        }\n      }\n    }\n    sqlite3_finalize(pStmt);\n  }else if( argv[0]==0 ){\n    corruptSchema(pData, 0, 0);\n  }else{\n    /* If the SQL column is blank it means this is an index that\n    ** was created to be the PRIMARY KEY or to fulfill a UNIQUE\n    ** constraint for a CREATE TABLE.  The index should have already\n    ** been created when we processed the CREATE TABLE.  All we have\n    ** to do here is record the root page number for that index.\n    */\n    Index *pIndex;\n    pIndex = sqlite3FindIndex(db, argv[0], db->aDb[iDb].zName);\n    if( pIndex==0 ){\n      /* This can occur if there exists an index on a TEMP table which\n      ** has the same name as another index on a permanent index.  Since\n      ** the permanent table is hidden by the TEMP table, we can also\n      ** safely ignore the index on the permanent table.\n      */\n      /* Do Nothing */;\n    }else if( sqlite3GetInt32(argv[1], &pIndex->tnum)==0 ){\n      corruptSchema(pData, argv[0], \"invalid rootpage\");\n    }\n  }\n  return 0;\n}\n\n/*\n** Attempt to read the database schema and initialize internal\n** data structures for a single database file.  The index of the\n** database file is given by iDb.  iDb==0 is used for the main\n** database.  iDb==1 should never be used.  iDb>=2 is used for\n** auxiliary databases.  Return one of the SQLITE_ error codes to\n** indicate success or failure.\n*/\nstatic int sqlite3InitOne(sqlite3 *db, int iDb, char **pzErrMsg){\n  int rc;\n  int i;\n  int size;\n  Table *pTab;\n  Db *pDb;\n  char const *azArg[4];\n  int meta[5];\n  InitData initData;\n  char const *zMasterSchema;\n  char const *zMasterName;\n  int openedTransaction = 0;\n\n  /*\n  ** The master database table has a structure like this\n  */\n  static const char master_schema[] = \n     \"CREATE TABLE sqlite_master(\\n\"\n     \"  type text,\\n\"\n     \"  name text,\\n\"\n     \"  tbl_name text,\\n\"\n     \"  rootpage integer,\\n\"\n     \"  sql text\\n\"\n     \")\"\n  ;\n#ifndef SQLITE_OMIT_TEMPDB\n  static const char temp_master_schema[] = \n     \"CREATE TEMP TABLE sqlite_temp_master(\\n\"\n     \"  type text,\\n\"\n     \"  name text,\\n\"\n     \"  tbl_name text,\\n\"\n     \"  rootpage integer,\\n\"\n     \"  sql text\\n\"\n     \")\"\n  ;\n#else\n  #define temp_master_schema 0\n#endif\n\n  assert( iDb>=0 && iDb<db->nDb );\n  assert( db->aDb[iDb].pSchema );\n  assert( sqlite3_mutex_held(db->mutex) );\n  assert( iDb==1 || sqlite3BtreeHoldsMutex(db->aDb[iDb].pBt) );\n\n  /* zMasterSchema and zInitScript are set to point at the master schema\n  ** and initialisation script appropriate for the database being\n  ** initialised. zMasterName is the name of the master table.\n  */\n  if( !OMIT_TEMPDB && iDb==1 ){\n    zMasterSchema = temp_master_schema;\n  }else{\n    zMasterSchema = master_schema;\n  }\n  zMasterName = SCHEMA_TABLE(iDb);\n\n  /* Construct the schema tables.  */\n  azArg[0] = zMasterName;\n  azArg[1] = \"1\";\n  azArg[2] = zMasterSchema;\n  azArg[3] = 0;\n  initData.db = db;\n  initData.iDb = iDb;\n  initData.rc = SQLITE_OK;\n  initData.pzErrMsg = pzErrMsg;\n  sqlite3InitCallback(&initData, 3, (char **)azArg, 0);\n  if( initData.rc ){\n    rc = initData.rc;\n    goto error_out;\n  }\n  pTab = sqlite3FindTable(db, zMasterName, db->aDb[iDb].zName);\n  if( ALWAYS(pTab) ){\n    pTab->tabFlags |= TF_Readonly;\n  }\n\n  /* Create a cursor to hold the database open\n  */\n  pDb = &db->aDb[iDb];\n  if( pDb->pBt==0 ){\n    if( !OMIT_TEMPDB && ALWAYS(iDb==1) ){\n      DbSetProperty(db, 1, DB_SchemaLoaded);\n    }\n    return SQLITE_OK;\n  }\n\n  /* If there is not already a read-only (or read-write) transaction opened\n  ** on the b-tree database, open one now. If a transaction is opened, it \n  ** will be closed before this function returns.  */\n  sqlite3BtreeEnter(pDb->pBt);\n  if( !sqlite3BtreeIsInReadTrans(pDb->pBt) ){\n    rc = sqlite3BtreeBeginTrans(pDb->pBt, 0);\n    if( rc!=SQLITE_OK ){\n      sqlite3SetString(pzErrMsg, db, \"%s\", sqlite3ErrStr(rc));\n      goto initone_error_out;\n    }\n    openedTransaction = 1;\n  }\n\n  /* Get the database meta information.\n  **\n  ** Meta values are as follows:\n  **    meta[0]   Schema cookie.  Changes with each schema change.\n  **    meta[1]   File format of schema layer.\n  **    meta[2]   Size of the page cache.\n  **    meta[3]   Largest rootpage (auto/incr_vacuum mode)\n  **    meta[4]   Db text encoding. 1:UTF-8 2:UTF-16LE 3:UTF-16BE\n  **    meta[5]   User version\n  **    meta[6]   Incremental vacuum mode\n  **    meta[7]   unused\n  **    meta[8]   unused\n  **    meta[9]   unused\n  **\n  ** Note: The #defined SQLITE_UTF* symbols in sqliteInt.h correspond to\n  ** the possible values of meta[4].\n  */\n  for(i=0; i<ArraySize(meta); i++){\n    sqlite3BtreeGetMeta(pDb->pBt, i+1, (u32 *)&meta[i]);\n  }\n  pDb->pSchema->schema_cookie = meta[BTREE_SCHEMA_VERSION-1];\n\n  /* If opening a non-empty database, check the text encoding. For the\n  ** main database, set sqlite3.enc to the encoding of the main database.\n  ** For an attached db, it is an error if the encoding is not the same\n  ** as sqlite3.enc.\n  */\n  if( meta[BTREE_TEXT_ENCODING-1] ){  /* text encoding */\n    if( iDb==0 ){\n      u8 encoding;\n      /* If opening the main database, set ENC(db). */\n      encoding = (u8)meta[BTREE_TEXT_ENCODING-1] & 3;\n      if( encoding==0 ) encoding = SQLITE_UTF8;\n      ENC(db) = encoding;\n      db->pDfltColl = sqlite3FindCollSeq(db, SQLITE_UTF8, \"BINARY\", 0);\n    }else{\n      /* If opening an attached database, the encoding much match ENC(db) */\n      if( meta[BTREE_TEXT_ENCODING-1]!=ENC(db) ){\n        sqlite3SetString(pzErrMsg, db, \"attached databases must use the same\"\n            \" text encoding as main database\");\n        rc = SQLITE_ERROR;\n        goto initone_error_out;\n      }\n    }\n  }else{\n    DbSetProperty(db, iDb, DB_Empty);\n  }\n  pDb->pSchema->enc = ENC(db);\n\n  if( pDb->pSchema->cache_size==0 ){\n    size = sqlite3AbsInt32(meta[BTREE_DEFAULT_CACHE_SIZE-1]);\n    if( size==0 ){ size = SQLITE_DEFAULT_CACHE_SIZE; }\n    pDb->pSchema->cache_size = size;\n    sqlite3BtreeSetCacheSize(pDb->pBt, pDb->pSchema->cache_size);\n  }\n\n  /*\n  ** file_format==1    Version 3.0.0.\n  ** file_format==2    Version 3.1.3.  // ALTER TABLE ADD COLUMN\n  ** file_format==3    Version 3.1.4.  // ditto but with non-NULL defaults\n  ** file_format==4    Version 3.3.0.  // DESC indices.  Boolean constants\n  */\n  pDb->pSchema->file_format = (u8)meta[BTREE_FILE_FORMAT-1];\n  if( pDb->pSchema->file_format==0 ){\n    pDb->pSchema->file_format = 1;\n  }\n  if( pDb->pSchema->file_format>SQLITE_MAX_FILE_FORMAT ){\n    sqlite3SetString(pzErrMsg, db, \"unsupported file format\");\n    rc = SQLITE_ERROR;\n    goto initone_error_out;\n  }\n\n  /* Ticket #2804:  When we open a database in the newer file format,\n  ** clear the legacy_file_format pragma flag so that a VACUUM will\n  ** not downgrade the database and thus invalidate any descending\n  ** indices that the user might have created.\n  */\n  if( iDb==0 && meta[BTREE_FILE_FORMAT-1]>=4 ){\n    db->flags &= ~SQLITE_LegacyFileFmt;\n  }\n\n  /* Read the schema information out of the schema tables\n  */\n  assert( db->init.busy );\n  {\n    char *zSql;\n    zSql = sqlite3MPrintf(db, \n        \"SELECT name, rootpage, sql FROM '%q'.%s ORDER BY rowid\",\n        db->aDb[iDb].zName, zMasterName);\n#ifndef SQLITE_OMIT_AUTHORIZATION\n    {\n      int (*xAuth)(void*,int,const char*,const char*,const char*,const char*);\n      xAuth = db->xAuth;\n      db->xAuth = 0;\n#endif\n      rc = sqlite3_exec(db, zSql, sqlite3InitCallback, &initData, 0);\n#ifndef SQLITE_OMIT_AUTHORIZATION\n      db->xAuth = xAuth;\n    }\n#endif\n    if( rc==SQLITE_OK ) rc = initData.rc;\n    sqlite3DbFree(db, zSql);\n#ifndef SQLITE_OMIT_ANALYZE\n    if( rc==SQLITE_OK ){\n      sqlite3AnalysisLoad(db, iDb);\n    }\n#endif\n  }\n  if( db->mallocFailed ){\n    rc = SQLITE_NOMEM;\n    sqlite3ResetInternalSchema(db, 0);\n  }\n  if( rc==SQLITE_OK || (db->flags&SQLITE_RecoveryMode)){\n    /* Black magic: If the SQLITE_RecoveryMode flag is set, then consider\n    ** the schema loaded, even if errors occurred. In this situation the \n    ** current sqlite3_prepare() operation will fail, but the following one\n    ** will attempt to compile the supplied statement against whatever subset\n    ** of the schema was loaded before the error occurred. The primary\n    ** purpose of this is to allow access to the sqlite_master table\n    ** even when its contents have been corrupted.\n    */\n    DbSetProperty(db, iDb, DB_SchemaLoaded);\n    rc = SQLITE_OK;\n  }\n\n  /* Jump here for an error that occurs after successfully allocating\n  ** curMain and calling sqlite3BtreeEnter(). For an error that occurs\n  ** before that point, jump to error_out.\n  */\ninitone_error_out:\n  if( openedTransaction ){\n    sqlite3BtreeCommit(pDb->pBt);\n  }\n  sqlite3BtreeLeave(pDb->pBt);\n\nerror_out:\n  if( rc==SQLITE_NOMEM || rc==SQLITE_IOERR_NOMEM ){\n    db->mallocFailed = 1;\n  }\n  return rc;\n}\n\n/*\n** Initialize all database files - the main database file, the file\n** used to store temporary tables, and any additional database files\n** created using ATTACH statements.  Return a success code.  If an\n** error occurs, write an error message into *pzErrMsg.\n**\n** After a database is initialized, the DB_SchemaLoaded bit is set\n** bit is set in the flags field of the Db structure. If the database\n** file was of zero-length, then the DB_Empty flag is also set.\n*/\nSQLITE_PRIVATE int sqlite3Init(sqlite3 *db, char **pzErrMsg){\n  int i, rc;\n  int commit_internal = !(db->flags&SQLITE_InternChanges);\n  \n  assert( sqlite3_mutex_held(db->mutex) );\n  rc = SQLITE_OK;\n  db->init.busy = 1;\n  for(i=0; rc==SQLITE_OK && i<db->nDb; i++){\n    if( DbHasProperty(db, i, DB_SchemaLoaded) || i==1 ) continue;\n    rc = sqlite3InitOne(db, i, pzErrMsg);\n    if( rc ){\n      sqlite3ResetInternalSchema(db, i);\n    }\n  }\n\n  /* Once all the other databases have been initialised, load the schema\n  ** for the TEMP database. This is loaded last, as the TEMP database\n  ** schema may contain references to objects in other databases.\n  */\n#ifndef SQLITE_OMIT_TEMPDB\n  if( rc==SQLITE_OK && ALWAYS(db->nDb>1)\n                    && !DbHasProperty(db, 1, DB_SchemaLoaded) ){\n    rc = sqlite3InitOne(db, 1, pzErrMsg);\n    if( rc ){\n      sqlite3ResetInternalSchema(db, 1);\n    }\n  }\n#endif\n\n  db->init.busy = 0;\n  if( rc==SQLITE_OK && commit_internal ){\n    sqlite3CommitInternalChanges(db);\n  }\n\n  return rc; \n}\n\n/*\n** This routine is a no-op if the database schema is already initialised.\n** Otherwise, the schema is loaded. An error code is returned.\n*/\nSQLITE_PRIVATE int sqlite3ReadSchema(Parse *pParse){\n  int rc = SQLITE_OK;\n  sqlite3 *db = pParse->db;\n  assert( sqlite3_mutex_held(db->mutex) );\n  if( !db->init.busy ){\n    rc = sqlite3Init(db, &pParse->zErrMsg);\n  }\n  if( rc!=SQLITE_OK ){\n    pParse->rc = rc;\n    pParse->nErr++;\n  }\n  return rc;\n}\n\n\n/*\n** Check schema cookies in all databases.  If any cookie is out\n** of date set pParse->rc to SQLITE_SCHEMA.  If all schema cookies\n** make no changes to pParse->rc.\n*/\nstatic void schemaIsValid(Parse *pParse){\n  sqlite3 *db = pParse->db;\n  int iDb;\n  int rc;\n  int cookie;\n\n  assert( pParse->checkSchema );\n  assert( sqlite3_mutex_held(db->mutex) );\n  for(iDb=0; iDb<db->nDb; iDb++){\n    int openedTransaction = 0;         /* True if a transaction is opened */\n    Btree *pBt = db->aDb[iDb].pBt;     /* Btree database to read cookie from */\n    if( pBt==0 ) continue;\n\n    /* If there is not already a read-only (or read-write) transaction opened\n    ** on the b-tree database, open one now. If a transaction is opened, it \n    ** will be closed immediately after reading the meta-value. */\n    if( !sqlite3BtreeIsInReadTrans(pBt) ){\n      rc = sqlite3BtreeBeginTrans(pBt, 0);\n      if( rc==SQLITE_NOMEM || rc==SQLITE_IOERR_NOMEM ){\n        db->mallocFailed = 1;\n      }\n      if( rc!=SQLITE_OK ) return;\n      openedTransaction = 1;\n    }\n\n    /* Read the schema cookie from the database. If it does not match the \n    ** value stored as part of the in-memory schema representation,\n    ** set Parse.rc to SQLITE_SCHEMA. */\n    sqlite3BtreeGetMeta(pBt, BTREE_SCHEMA_VERSION, (u32 *)&cookie);\n    if( cookie!=db->aDb[iDb].pSchema->schema_cookie ){\n      pParse->rc = SQLITE_SCHEMA;\n    }\n\n    /* Close the transaction, if one was opened. */\n    if( openedTransaction ){\n      sqlite3BtreeCommit(pBt);\n    }\n  }\n}\n\n/*\n** Convert a schema pointer into the iDb index that indicates\n** which database file in db->aDb[] the schema refers to.\n**\n** If the same database is attached more than once, the first\n** attached database is returned.\n*/\nSQLITE_PRIVATE int sqlite3SchemaToIndex(sqlite3 *db, Schema *pSchema){\n  int i = -1000000;\n\n  /* If pSchema is NULL, then return -1000000. This happens when code in \n  ** expr.c is trying to resolve a reference to a transient table (i.e. one\n  ** created by a sub-select). In this case the return value of this \n  ** function should never be used.\n  **\n  ** We return -1000000 instead of the more usual -1 simply because using\n  ** -1000000 as the incorrect index into db->aDb[] is much \n  ** more likely to cause a segfault than -1 (of course there are assert()\n  ** statements too, but it never hurts to play the odds).\n  */\n  assert( sqlite3_mutex_held(db->mutex) );\n  if( pSchema ){\n    for(i=0; ALWAYS(i<db->nDb); i++){\n      if( db->aDb[i].pSchema==pSchema ){\n        break;\n      }\n    }\n    assert( i>=0 && i<db->nDb );\n  }\n  return i;\n}\n\n/*\n** Compile the UTF-8 encoded SQL statement zSql into a statement handle.\n*/\nstatic int sqlite3Prepare(\n  sqlite3 *db,              /* Database handle. */\n  const char *zSql,         /* UTF-8 encoded SQL statement. */\n  int nBytes,               /* Length of zSql in bytes. */\n  int saveSqlFlag,          /* True to copy SQL text into the sqlite3_stmt */\n  Vdbe *pReprepare,         /* VM being reprepared */\n  sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */\n  const char **pzTail       /* OUT: End of parsed string */\n){\n  Parse *pParse;            /* Parsing context */\n  char *zErrMsg = 0;        /* Error message */\n  int rc = SQLITE_OK;       /* Result code */\n  int i;                    /* Loop counter */\n\n  /* Allocate the parsing context */\n  pParse = sqlite3StackAllocZero(db, sizeof(*pParse));\n  if( pParse==0 ){\n    rc = SQLITE_NOMEM;\n    goto end_prepare;\n  }\n  pParse->pReprepare = pReprepare;\n  assert( ppStmt && *ppStmt==0 );\n  assert( !db->mallocFailed );\n  assert( sqlite3_mutex_held(db->mutex) );\n\n  /* Check to verify that it is possible to get a read lock on all\n  ** database schemas.  The inability to get a read lock indicates that\n  ** some other database connection is holding a write-lock, which in\n  ** turn means that the other connection has made uncommitted changes\n  ** to the schema.\n  **\n  ** Were we to proceed and prepare the statement against the uncommitted\n  ** schema changes and if those schema changes are subsequently rolled\n  ** back and different changes are made in their place, then when this\n  ** prepared statement goes to run the schema cookie would fail to detect\n  ** the schema change.  Disaster would follow.\n  **\n  ** This thread is currently holding mutexes on all Btrees (because\n  ** of the sqlite3BtreeEnterAll() in sqlite3LockAndPrepare()) so it\n  ** is not possible for another thread to start a new schema change\n  ** while this routine is running.  Hence, we do not need to hold \n  ** locks on the schema, we just need to make sure nobody else is \n  ** holding them.\n  **\n  ** Note that setting READ_UNCOMMITTED overrides most lock detection,\n  ** but it does *not* override schema lock detection, so this all still\n  ** works even if READ_UNCOMMITTED is set.\n  */\n  for(i=0; i<db->nDb; i++) {\n    Btree *pBt = db->aDb[i].pBt;\n    if( pBt ){\n      assert( sqlite3BtreeHoldsMutex(pBt) );\n      rc = sqlite3BtreeSchemaLocked(pBt);\n      if( rc ){\n        const char *zDb = db->aDb[i].zName;\n        sqlite3Error(db, rc, \"database schema is locked: %s\", zDb);\n        testcase( db->flags & SQLITE_ReadUncommitted );\n        goto end_prepare;\n      }\n    }\n  }\n\n  sqlite3VtabUnlockList(db);\n\n  pParse->db = db;\n  pParse->nQueryLoop = (double)1;\n  if( nBytes>=0 && (nBytes==0 || zSql[nBytes-1]!=0) ){\n    char *zSqlCopy;\n    int mxLen = db->aLimit[SQLITE_LIMIT_SQL_LENGTH];\n    testcase( nBytes==mxLen );\n    testcase( nBytes==mxLen+1 );\n    if( nBytes>mxLen ){\n      sqlite3Error(db, SQLITE_TOOBIG, \"statement too long\");\n      rc = sqlite3ApiExit(db, SQLITE_TOOBIG);\n      goto end_prepare;\n    }\n    zSqlCopy = sqlite3DbStrNDup(db, zSql, nBytes);\n    if( zSqlCopy ){\n      sqlite3RunParser(pParse, zSqlCopy, &zErrMsg);\n      sqlite3DbFree(db, zSqlCopy);\n      pParse->zTail = &zSql[pParse->zTail-zSqlCopy];\n    }else{\n      pParse->zTail = &zSql[nBytes];\n    }\n  }else{\n    sqlite3RunParser(pParse, zSql, &zErrMsg);\n  }\n  assert( 1==(int)pParse->nQueryLoop );\n\n  if( db->mallocFailed ){\n    pParse->rc = SQLITE_NOMEM;\n  }\n  if( pParse->rc==SQLITE_DONE ) pParse->rc = SQLITE_OK;\n  if( pParse->checkSchema ){\n    schemaIsValid(pParse);\n  }\n  if( pParse->rc==SQLITE_SCHEMA ){\n    sqlite3ResetInternalSchema(db, 0);\n  }\n  if( db->mallocFailed ){\n    pParse->rc = SQLITE_NOMEM;\n  }\n  if( pzTail ){\n    *pzTail = pParse->zTail;\n  }\n  rc = pParse->rc;\n\n#ifndef SQLITE_OMIT_EXPLAIN\n  if( rc==SQLITE_OK && pParse->pVdbe && pParse->explain ){\n    static const char * const azColName[] = {\n       \"addr\", \"opcode\", \"p1\", \"p2\", \"p3\", \"p4\", \"p5\", \"comment\",\n       \"selectid\", \"order\", \"from\", \"detail\"\n    };\n    int iFirst, mx;\n    if( pParse->explain==2 ){\n      sqlite3VdbeSetNumCols(pParse->pVdbe, 4);\n      iFirst = 8;\n      mx = 12;\n    }else{\n      sqlite3VdbeSetNumCols(pParse->pVdbe, 8);\n      iFirst = 0;\n      mx = 8;\n    }\n    for(i=iFirst; i<mx; i++){\n      sqlite3VdbeSetColName(pParse->pVdbe, i-iFirst, COLNAME_NAME,\n                            azColName[i], SQLITE_STATIC);\n    }\n  }\n#endif\n\n  assert( db->init.busy==0 || saveSqlFlag==0 );\n  if( db->init.busy==0 ){\n    Vdbe *pVdbe = pParse->pVdbe;\n    sqlite3VdbeSetSql(pVdbe, zSql, (int)(pParse->zTail-zSql), saveSqlFlag);\n  }\n  if( pParse->pVdbe && (rc!=SQLITE_OK || db->mallocFailed) ){\n    sqlite3VdbeFinalize(pParse->pVdbe);\n    assert(!(*ppStmt));\n  }else{\n    *ppStmt = (sqlite3_stmt*)pParse->pVdbe;\n  }\n\n  if( zErrMsg ){\n    sqlite3Error(db, rc, \"%s\", zErrMsg);\n    sqlite3DbFree(db, zErrMsg);\n  }else{\n    sqlite3Error(db, rc, 0);\n  }\n\n  /* Delete any TriggerPrg structures allocated while parsing this statement. */\n  while( pParse->pTriggerPrg ){\n    TriggerPrg *pT = pParse->pTriggerPrg;\n    pParse->pTriggerPrg = pT->pNext;\n    sqlite3DbFree(db, pT);\n  }\n\nend_prepare:\n\n  sqlite3StackFree(db, pParse);\n  rc = sqlite3ApiExit(db, rc);\n  assert( (rc&db->errMask)==rc );\n  return rc;\n}\nstatic int sqlite3LockAndPrepare(\n  sqlite3 *db,              /* Database handle. */\n  const char *zSql,         /* UTF-8 encoded SQL statement. */\n  int nBytes,               /* Length of zSql in bytes. */\n  int saveSqlFlag,          /* True to copy SQL text into the sqlite3_stmt */\n  Vdbe *pOld,               /* VM being reprepared */\n  sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */\n  const char **pzTail       /* OUT: End of parsed string */\n){\n  int rc;\n  assert( ppStmt!=0 );\n  *ppStmt = 0;\n  if( !sqlite3SafetyCheckOk(db) ){\n    return SQLITE_MISUSE_BKPT;\n  }\n  sqlite3_mutex_enter(db->mutex);\n  sqlite3BtreeEnterAll(db);\n  rc = sqlite3Prepare(db, zSql, nBytes, saveSqlFlag, pOld, ppStmt, pzTail);\n  if( rc==SQLITE_SCHEMA ){\n    sqlite3_finalize(*ppStmt);\n    rc = sqlite3Prepare(db, zSql, nBytes, saveSqlFlag, pOld, ppStmt, pzTail);\n  }\n  sqlite3BtreeLeaveAll(db);\n  sqlite3_mutex_leave(db->mutex);\n  return rc;\n}\n\n/*\n** Rerun the compilation of a statement after a schema change.\n**\n** If the statement is successfully recompiled, return SQLITE_OK. Otherwise,\n** if the statement cannot be recompiled because another connection has\n** locked the sqlite3_master table, return SQLITE_LOCKED. If any other error\n** occurs, return SQLITE_SCHEMA.\n*/\nSQLITE_PRIVATE int sqlite3Reprepare(Vdbe *p){\n  int rc;\n  sqlite3_stmt *pNew;\n  const char *zSql;\n  sqlite3 *db;\n\n  assert( sqlite3_mutex_held(sqlite3VdbeDb(p)->mutex) );\n  zSql = sqlite3_sql((sqlite3_stmt *)p);\n  assert( zSql!=0 );  /* Reprepare only called for prepare_v2() statements */\n  db = sqlite3VdbeDb(p);\n  assert( sqlite3_mutex_held(db->mutex) );\n  rc = sqlite3LockAndPrepare(db, zSql, -1, 0, p, &pNew, 0);\n  if( rc ){\n    if( rc==SQLITE_NOMEM ){\n      db->mallocFailed = 1;\n    }\n    assert( pNew==0 );\n    return rc;\n  }else{\n    assert( pNew!=0 );\n  }\n  sqlite3VdbeSwap((Vdbe*)pNew, p);\n  sqlite3TransferBindings(pNew, (sqlite3_stmt*)p);\n  sqlite3VdbeResetStepResult((Vdbe*)pNew);\n  sqlite3VdbeFinalize((Vdbe*)pNew);\n  return SQLITE_OK;\n}\n\n\n/*\n** Two versions of the official API.  Legacy and new use.  In the legacy\n** version, the original SQL text is not saved in the prepared statement\n** and so if a schema change occurs, SQLITE_SCHEMA is returned by\n** sqlite3_step().  In the new version, the original SQL text is retained\n** and the statement is automatically recompiled if an schema change\n** occurs.\n*/\nSQLITE_API int sqlite3_prepare(\n  sqlite3 *db,              /* Database handle. */\n  const char *zSql,         /* UTF-8 encoded SQL statement. */\n  int nBytes,               /* Length of zSql in bytes. */\n  sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */\n  const char **pzTail       /* OUT: End of parsed string */\n){\n  int rc;\n  rc = sqlite3LockAndPrepare(db,zSql,nBytes,0,0,ppStmt,pzTail);\n  assert( rc==SQLITE_OK || ppStmt==0 || *ppStmt==0 );  /* VERIFY: F13021 */\n  return rc;\n}\nSQLITE_API int sqlite3_prepare_v2(\n  sqlite3 *db,              /* Database handle. */\n  const char *zSql,         /* UTF-8 encoded SQL statement. */\n  int nBytes,               /* Length of zSql in bytes. */\n  sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */\n  const char **pzTail       /* OUT: End of parsed string */\n){\n  int rc;\n  rc = sqlite3LockAndPrepare(db,zSql,nBytes,1,0,ppStmt,pzTail);\n  assert( rc==SQLITE_OK || ppStmt==0 || *ppStmt==0 );  /* VERIFY: F13021 */\n  return rc;\n}\n\n\n#ifndef SQLITE_OMIT_UTF16\n/*\n** Compile the UTF-16 encoded SQL statement zSql into a statement handle.\n*/\nstatic int sqlite3Prepare16(\n  sqlite3 *db,              /* Database handle. */ \n  const void *zSql,         /* UTF-16 encoded SQL statement. */\n  int nBytes,               /* Length of zSql in bytes. */\n  int saveSqlFlag,          /* True to save SQL text into the sqlite3_stmt */\n  sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */\n  const void **pzTail       /* OUT: End of parsed string */\n){\n  /* This function currently works by first transforming the UTF-16\n  ** encoded string to UTF-8, then invoking sqlite3_prepare(). The\n  ** tricky bit is figuring out the pointer to return in *pzTail.\n  */\n  char *zSql8;\n  const char *zTail8 = 0;\n  int rc = SQLITE_OK;\n\n  assert( ppStmt );\n  *ppStmt = 0;\n  if( !sqlite3SafetyCheckOk(db) ){\n    return SQLITE_MISUSE_BKPT;\n  }\n  sqlite3_mutex_enter(db->mutex);\n  zSql8 = sqlite3Utf16to8(db, zSql, nBytes, SQLITE_UTF16NATIVE);\n  if( zSql8 ){\n    rc = sqlite3LockAndPrepare(db, zSql8, -1, saveSqlFlag, 0, ppStmt, &zTail8);\n  }\n\n  if( zTail8 && pzTail ){\n    /* If sqlite3_prepare returns a tail pointer, we calculate the\n    ** equivalent pointer into the UTF-16 string by counting the unicode\n    ** characters between zSql8 and zTail8, and then returning a pointer\n    ** the same number of characters into the UTF-16 string.\n    */\n    int chars_parsed = sqlite3Utf8CharLen(zSql8, (int)(zTail8-zSql8));\n    *pzTail = (u8 *)zSql + sqlite3Utf16ByteLen(zSql, chars_parsed);\n  }\n  sqlite3DbFree(db, zSql8); \n  rc = sqlite3ApiExit(db, rc);\n  sqlite3_mutex_leave(db->mutex);\n  return rc;\n}\n\n/*\n** Two versions of the official API.  Legacy and new use.  In the legacy\n** version, the original SQL text is not saved in the prepared statement\n** and so if a schema change occurs, SQLITE_SCHEMA is returned by\n** sqlite3_step().  In the new version, the original SQL text is retained\n** and the statement is automatically recompiled if an schema change\n** occurs.\n*/\nSQLITE_API int sqlite3_prepare16(\n  sqlite3 *db,              /* Database handle. */ \n  const void *zSql,         /* UTF-16 encoded SQL statement. */\n  int nBytes,               /* Length of zSql in bytes. */\n  sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */\n  const void **pzTail       /* OUT: End of parsed string */\n){\n  int rc;\n  rc = sqlite3Prepare16(db,zSql,nBytes,0,ppStmt,pzTail);\n  assert( rc==SQLITE_OK || ppStmt==0 || *ppStmt==0 );  /* VERIFY: F13021 */\n  return rc;\n}\nSQLITE_API int sqlite3_prepare16_v2(\n  sqlite3 *db,              /* Database handle. */ \n  const void *zSql,         /* UTF-16 encoded SQL statement. */\n  int nBytes,               /* Length of zSql in bytes. */\n  sqlite3_stmt **ppStmt,    /* OUT: A pointer to the prepared statement */\n  const void **pzTail       /* OUT: End of parsed string */\n){\n  int rc;\n  rc = sqlite3Prepare16(db,zSql,nBytes,1,ppStmt,pzTail);\n  assert( rc==SQLITE_OK || ppStmt==0 || *ppStmt==0 );  /* VERIFY: F13021 */\n  return rc;\n}\n\n#endif /* SQLITE_OMIT_UTF16 */\n\n/************** End of prepare.c *********************************************/\n/************** Begin file select.c ******************************************/\n/*\n** 2001 September 15\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains C code routines that are called by the parser\n** to handle SELECT statements in SQLite.\n*/\n\n\n/*\n** Delete all the content of a Select structure but do not deallocate\n** the select structure itself.\n*/\nstatic void clearSelect(sqlite3 *db, Select *p){\n  sqlite3ExprListDelete(db, p->pEList);\n  sqlite3SrcListDelete(db, p->pSrc);\n  sqlite3ExprDelete(db, p->pWhere);\n  sqlite3ExprListDelete(db, p->pGroupBy);\n  sqlite3ExprDelete(db, p->pHaving);\n  sqlite3ExprListDelete(db, p->pOrderBy);\n  sqlite3SelectDelete(db, p->pPrior);\n  sqlite3ExprDelete(db, p->pLimit);\n  sqlite3ExprDelete(db, p->pOffset);\n}\n\n/*\n** Initialize a SelectDest structure.\n*/\nSQLITE_PRIVATE void sqlite3SelectDestInit(SelectDest *pDest, int eDest, int iParm){\n  pDest->eDest = (u8)eDest;\n  pDest->iParm = iParm;\n  pDest->affinity = 0;\n  pDest->iMem = 0;\n  pDest->nMem = 0;\n}\n\n\n/*\n** Allocate a new Select structure and return a pointer to that\n** structure.\n*/\nSQLITE_PRIVATE Select *sqlite3SelectNew(\n  Parse *pParse,        /* Parsing context */\n  ExprList *pEList,     /* which columns to include in the result */\n  SrcList *pSrc,        /* the FROM clause -- which tables to scan */\n  Expr *pWhere,         /* the WHERE clause */\n  ExprList *pGroupBy,   /* the GROUP BY clause */\n  Expr *pHaving,        /* the HAVING clause */\n  ExprList *pOrderBy,   /* the ORDER BY clause */\n  int isDistinct,       /* true if the DISTINCT keyword is present */\n  Expr *pLimit,         /* LIMIT value.  NULL means not used */\n  Expr *pOffset         /* OFFSET value.  NULL means no offset */\n){\n  Select *pNew;\n  Select standin;\n  sqlite3 *db = pParse->db;\n  pNew = sqlite3DbMallocZero(db, sizeof(*pNew) );\n  assert( db->mallocFailed || !pOffset || pLimit ); /* OFFSET implies LIMIT */\n  if( pNew==0 ){\n    pNew = &standin;\n    memset(pNew, 0, sizeof(*pNew));\n  }\n  if( pEList==0 ){\n    pEList = sqlite3ExprListAppend(pParse, 0, sqlite3Expr(db,TK_ALL,0));\n  }\n  pNew->pEList = pEList;\n  pNew->pSrc = pSrc;\n  pNew->pWhere = pWhere;\n  pNew->pGroupBy = pGroupBy;\n  pNew->pHaving = pHaving;\n  pNew->pOrderBy = pOrderBy;\n  pNew->selFlags = isDistinct ? SF_Distinct : 0;\n  pNew->op = TK_SELECT;\n  pNew->pLimit = pLimit;\n  pNew->pOffset = pOffset;\n  assert( pOffset==0 || pLimit!=0 );\n  pNew->addrOpenEphm[0] = -1;\n  pNew->addrOpenEphm[1] = -1;\n  pNew->addrOpenEphm[2] = -1;\n  if( db->mallocFailed ) {\n    clearSelect(db, pNew);\n    if( pNew!=&standin ) sqlite3DbFree(db, pNew);\n    pNew = 0;\n  }\n  return pNew;\n}\n\n/*\n** Delete the given Select structure and all of its substructures.\n*/\nSQLITE_PRIVATE void sqlite3SelectDelete(sqlite3 *db, Select *p){\n  if( p ){\n    clearSelect(db, p);\n    sqlite3DbFree(db, p);\n  }\n}\n\n/*\n** Given 1 to 3 identifiers preceeding the JOIN keyword, determine the\n** type of join.  Return an integer constant that expresses that type\n** in terms of the following bit values:\n**\n**     JT_INNER\n**     JT_CROSS\n**     JT_OUTER\n**     JT_NATURAL\n**     JT_LEFT\n**     JT_RIGHT\n**\n** A full outer join is the combination of JT_LEFT and JT_RIGHT.\n**\n** If an illegal or unsupported join type is seen, then still return\n** a join type, but put an error in the pParse structure.\n*/\nSQLITE_PRIVATE int sqlite3JoinType(Parse *pParse, Token *pA, Token *pB, Token *pC){\n  int jointype = 0;\n  Token *apAll[3];\n  Token *p;\n                             /*   0123456789 123456789 123456789 123 */\n  static const char zKeyText[] = \"naturaleftouterightfullinnercross\";\n  static const struct {\n    u8 i;        /* Beginning of keyword text in zKeyText[] */\n    u8 nChar;    /* Length of the keyword in characters */\n    u8 code;     /* Join type mask */\n  } aKeyword[] = {\n    /* natural */ { 0,  7, JT_NATURAL                },\n    /* left    */ { 6,  4, JT_LEFT|JT_OUTER          },\n    /* outer   */ { 10, 5, JT_OUTER                  },\n    /* right   */ { 14, 5, JT_RIGHT|JT_OUTER         },\n    /* full    */ { 19, 4, JT_LEFT|JT_RIGHT|JT_OUTER },\n    /* inner   */ { 23, 5, JT_INNER                  },\n    /* cross   */ { 28, 5, JT_INNER|JT_CROSS         },\n  };\n  int i, j;\n  apAll[0] = pA;\n  apAll[1] = pB;\n  apAll[2] = pC;\n  for(i=0; i<3 && apAll[i]; i++){\n    p = apAll[i];\n    for(j=0; j<ArraySize(aKeyword); j++){\n      if( p->n==aKeyword[j].nChar \n          && sqlite3StrNICmp((char*)p->z, &zKeyText[aKeyword[j].i], p->n)==0 ){\n        jointype |= aKeyword[j].code;\n        break;\n      }\n    }\n    testcase( j==0 || j==1 || j==2 || j==3 || j==4 || j==5 || j==6 );\n    if( j>=ArraySize(aKeyword) ){\n      jointype |= JT_ERROR;\n      break;\n    }\n  }\n  if(\n     (jointype & (JT_INNER|JT_OUTER))==(JT_INNER|JT_OUTER) ||\n     (jointype & JT_ERROR)!=0\n  ){\n    const char *zSp = \" \";\n    assert( pB!=0 );\n    if( pC==0 ){ zSp++; }\n    sqlite3ErrorMsg(pParse, \"unknown or unsupported join type: \"\n       \"%T %T%s%T\", pA, pB, zSp, pC);\n    jointype = JT_INNER;\n  }else if( (jointype & JT_OUTER)!=0 \n         && (jointype & (JT_LEFT|JT_RIGHT))!=JT_LEFT ){\n    sqlite3ErrorMsg(pParse, \n      \"RIGHT and FULL OUTER JOINs are not currently supported\");\n    jointype = JT_INNER;\n  }\n  return jointype;\n}\n\n/*\n** Return the index of a column in a table.  Return -1 if the column\n** is not contained in the table.\n*/\nstatic int columnIndex(Table *pTab, const char *zCol){\n  int i;\n  for(i=0; i<pTab->nCol; i++){\n    if( sqlite3StrICmp(pTab->aCol[i].zName, zCol)==0 ) return i;\n  }\n  return -1;\n}\n\n/*\n** Search the first N tables in pSrc, from left to right, looking for a\n** table that has a column named zCol.  \n**\n** When found, set *piTab and *piCol to the table index and column index\n** of the matching column and return TRUE.\n**\n** If not found, return FALSE.\n*/\nstatic int tableAndColumnIndex(\n  SrcList *pSrc,       /* Array of tables to search */\n  int N,               /* Number of tables in pSrc->a[] to search */\n  const char *zCol,    /* Name of the column we are looking for */\n  int *piTab,          /* Write index of pSrc->a[] here */\n  int *piCol           /* Write index of pSrc->a[*piTab].pTab->aCol[] here */\n){\n  int i;               /* For looping over tables in pSrc */\n  int iCol;            /* Index of column matching zCol */\n\n  assert( (piTab==0)==(piCol==0) );  /* Both or neither are NULL */\n  for(i=0; i<N; i++){\n    iCol = columnIndex(pSrc->a[i].pTab, zCol);\n    if( iCol>=0 ){\n      if( piTab ){\n        *piTab = i;\n        *piCol = iCol;\n      }\n      return 1;\n    }\n  }\n  return 0;\n}\n\n/*\n** This function is used to add terms implied by JOIN syntax to the\n** WHERE clause expression of a SELECT statement. The new term, which\n** is ANDed with the existing WHERE clause, is of the form:\n**\n**    (tab1.col1 = tab2.col2)\n**\n** where tab1 is the iSrc'th table in SrcList pSrc and tab2 is the \n** (iSrc+1)'th. Column col1 is column iColLeft of tab1, and col2 is\n** column iColRight of tab2.\n*/\nstatic void addWhereTerm(\n  Parse *pParse,                  /* Parsing context */\n  SrcList *pSrc,                  /* List of tables in FROM clause */\n  int iLeft,                      /* Index of first table to join in pSrc */\n  int iColLeft,                   /* Index of column in first table */\n  int iRight,                     /* Index of second table in pSrc */\n  int iColRight,                  /* Index of column in second table */\n  int isOuterJoin,                /* True if this is an OUTER join */\n  Expr **ppWhere                  /* IN/OUT: The WHERE clause to add to */\n){\n  sqlite3 *db = pParse->db;\n  Expr *pE1;\n  Expr *pE2;\n  Expr *pEq;\n\n  assert( iLeft<iRight );\n  assert( pSrc->nSrc>iRight );\n  assert( pSrc->a[iLeft].pTab );\n  assert( pSrc->a[iRight].pTab );\n\n  pE1 = sqlite3CreateColumnExpr(db, pSrc, iLeft, iColLeft);\n  pE2 = sqlite3CreateColumnExpr(db, pSrc, iRight, iColRight);\n\n  pEq = sqlite3PExpr(pParse, TK_EQ, pE1, pE2, 0);\n  if( pEq && isOuterJoin ){\n    ExprSetProperty(pEq, EP_FromJoin);\n    assert( !ExprHasAnyProperty(pEq, EP_TokenOnly|EP_Reduced) );\n    ExprSetIrreducible(pEq);\n    pEq->iRightJoinTable = (i16)pE2->iTable;\n  }\n  *ppWhere = sqlite3ExprAnd(db, *ppWhere, pEq);\n}\n\n/*\n** Set the EP_FromJoin property on all terms of the given expression.\n** And set the Expr.iRightJoinTable to iTable for every term in the\n** expression.\n**\n** The EP_FromJoin property is used on terms of an expression to tell\n** the LEFT OUTER JOIN processing logic that this term is part of the\n** join restriction specified in the ON or USING clause and not a part\n** of the more general WHERE clause.  These terms are moved over to the\n** WHERE clause during join processing but we need to remember that they\n** originated in the ON or USING clause.\n**\n** The Expr.iRightJoinTable tells the WHERE clause processing that the\n** expression depends on table iRightJoinTable even if that table is not\n** explicitly mentioned in the expression.  That information is needed\n** for cases like this:\n**\n**    SELECT * FROM t1 LEFT JOIN t2 ON t1.a=t2.b AND t1.x=5\n**\n** The where clause needs to defer the handling of the t1.x=5\n** term until after the t2 loop of the join.  In that way, a\n** NULL t2 row will be inserted whenever t1.x!=5.  If we do not\n** defer the handling of t1.x=5, it will be processed immediately\n** after the t1 loop and rows with t1.x!=5 will never appear in\n** the output, which is incorrect.\n*/\nstatic void setJoinExpr(Expr *p, int iTable){\n  while( p ){\n    ExprSetProperty(p, EP_FromJoin);\n    assert( !ExprHasAnyProperty(p, EP_TokenOnly|EP_Reduced) );\n    ExprSetIrreducible(p);\n    p->iRightJoinTable = (i16)iTable;\n    setJoinExpr(p->pLeft, iTable);\n    p = p->pRight;\n  } \n}\n\n/*\n** This routine processes the join information for a SELECT statement.\n** ON and USING clauses are converted into extra terms of the WHERE clause.\n** NATURAL joins also create extra WHERE clause terms.\n**\n** The terms of a FROM clause are contained in the Select.pSrc structure.\n** The left most table is the first entry in Select.pSrc.  The right-most\n** table is the last entry.  The join operator is held in the entry to\n** the left.  Thus entry 0 contains the join operator for the join between\n** entries 0 and 1.  Any ON or USING clauses associated with the join are\n** also attached to the left entry.\n**\n** This routine returns the number of errors encountered.\n*/\nstatic int sqliteProcessJoin(Parse *pParse, Select *p){\n  SrcList *pSrc;                  /* All tables in the FROM clause */\n  int i, j;                       /* Loop counters */\n  struct SrcList_item *pLeft;     /* Left table being joined */\n  struct SrcList_item *pRight;    /* Right table being joined */\n\n  pSrc = p->pSrc;\n  pLeft = &pSrc->a[0];\n  pRight = &pLeft[1];\n  for(i=0; i<pSrc->nSrc-1; i++, pRight++, pLeft++){\n    Table *pLeftTab = pLeft->pTab;\n    Table *pRightTab = pRight->pTab;\n    int isOuter;\n\n    if( NEVER(pLeftTab==0 || pRightTab==0) ) continue;\n    isOuter = (pRight->jointype & JT_OUTER)!=0;\n\n    /* When the NATURAL keyword is present, add WHERE clause terms for\n    ** every column that the two tables have in common.\n    */\n    if( pRight->jointype & JT_NATURAL ){\n      if( pRight->pOn || pRight->pUsing ){\n        sqlite3ErrorMsg(pParse, \"a NATURAL join may not have \"\n           \"an ON or USING clause\", 0);\n        return 1;\n      }\n      for(j=0; j<pRightTab->nCol; j++){\n        char *zName;   /* Name of column in the right table */\n        int iLeft;     /* Matching left table */\n        int iLeftCol;  /* Matching column in the left table */\n\n        zName = pRightTab->aCol[j].zName;\n        if( tableAndColumnIndex(pSrc, i+1, zName, &iLeft, &iLeftCol) ){\n          addWhereTerm(pParse, pSrc, iLeft, iLeftCol, i+1, j,\n                       isOuter, &p->pWhere);\n        }\n      }\n    }\n\n    /* Disallow both ON and USING clauses in the same join\n    */\n    if( pRight->pOn && pRight->pUsing ){\n      sqlite3ErrorMsg(pParse, \"cannot have both ON and USING \"\n        \"clauses in the same join\");\n      return 1;\n    }\n\n    /* Add the ON clause to the end of the WHERE clause, connected by\n    ** an AND operator.\n    */\n    if( pRight->pOn ){\n      if( isOuter ) setJoinExpr(pRight->pOn, pRight->iCursor);\n      p->pWhere = sqlite3ExprAnd(pParse->db, p->pWhere, pRight->pOn);\n      pRight->pOn = 0;\n    }\n\n    /* Create extra terms on the WHERE clause for each column named\n    ** in the USING clause.  Example: If the two tables to be joined are \n    ** A and B and the USING clause names X, Y, and Z, then add this\n    ** to the WHERE clause:    A.X=B.X AND A.Y=B.Y AND A.Z=B.Z\n    ** Report an error if any column mentioned in the USING clause is\n    ** not contained in both tables to be joined.\n    */\n    if( pRight->pUsing ){\n      IdList *pList = pRight->pUsing;\n      for(j=0; j<pList->nId; j++){\n        char *zName;     /* Name of the term in the USING clause */\n        int iLeft;       /* Table on the left with matching column name */\n        int iLeftCol;    /* Column number of matching column on the left */\n        int iRightCol;   /* Column number of matching column on the right */\n\n        zName = pList->a[j].zName;\n        iRightCol = columnIndex(pRightTab, zName);\n        if( iRightCol<0\n         || !tableAndColumnIndex(pSrc, i+1, zName, &iLeft, &iLeftCol)\n        ){\n          sqlite3ErrorMsg(pParse, \"cannot join using column %s - column \"\n            \"not present in both tables\", zName);\n          return 1;\n        }\n        addWhereTerm(pParse, pSrc, iLeft, iLeftCol, i+1, iRightCol,\n                     isOuter, &p->pWhere);\n      }\n    }\n  }\n  return 0;\n}\n\n/*\n** Insert code into \"v\" that will push the record on the top of the\n** stack into the sorter.\n*/\nstatic void pushOntoSorter(\n  Parse *pParse,         /* Parser context */\n  ExprList *pOrderBy,    /* The ORDER BY clause */\n  Select *pSelect,       /* The whole SELECT statement */\n  int regData            /* Register holding data to be sorted */\n){\n  Vdbe *v = pParse->pVdbe;\n  int nExpr = pOrderBy->nExpr;\n  int regBase = sqlite3GetTempRange(pParse, nExpr+2);\n  int regRecord = sqlite3GetTempReg(pParse);\n  sqlite3ExprCacheClear(pParse);\n  sqlite3ExprCodeExprList(pParse, pOrderBy, regBase, 0);\n  sqlite3VdbeAddOp2(v, OP_Sequence, pOrderBy->iECursor, regBase+nExpr);\n  sqlite3ExprCodeMove(pParse, regData, regBase+nExpr+1, 1);\n  sqlite3VdbeAddOp3(v, OP_MakeRecord, regBase, nExpr + 2, regRecord);\n  sqlite3VdbeAddOp2(v, OP_IdxInsert, pOrderBy->iECursor, regRecord);\n  sqlite3ReleaseTempReg(pParse, regRecord);\n  sqlite3ReleaseTempRange(pParse, regBase, nExpr+2);\n  if( pSelect->iLimit ){\n    int addr1, addr2;\n    int iLimit;\n    if( pSelect->iOffset ){\n      iLimit = pSelect->iOffset+1;\n    }else{\n      iLimit = pSelect->iLimit;\n    }\n    addr1 = sqlite3VdbeAddOp1(v, OP_IfZero, iLimit);\n    sqlite3VdbeAddOp2(v, OP_AddImm, iLimit, -1);\n    addr2 = sqlite3VdbeAddOp0(v, OP_Goto);\n    sqlite3VdbeJumpHere(v, addr1);\n    sqlite3VdbeAddOp1(v, OP_Last, pOrderBy->iECursor);\n    sqlite3VdbeAddOp1(v, OP_Delete, pOrderBy->iECursor);\n    sqlite3VdbeJumpHere(v, addr2);\n  }\n}\n\n/*\n** Add code to implement the OFFSET\n*/\nstatic void codeOffset(\n  Vdbe *v,          /* Generate code into this VM */\n  Select *p,        /* The SELECT statement being coded */\n  int iContinue     /* Jump here to skip the current record */\n){\n  if( p->iOffset && iContinue!=0 ){\n    int addr;\n    sqlite3VdbeAddOp2(v, OP_AddImm, p->iOffset, -1);\n    addr = sqlite3VdbeAddOp1(v, OP_IfNeg, p->iOffset);\n    sqlite3VdbeAddOp2(v, OP_Goto, 0, iContinue);\n    VdbeComment((v, \"skip OFFSET records\"));\n    sqlite3VdbeJumpHere(v, addr);\n  }\n}\n\n/*\n** Add code that will check to make sure the N registers starting at iMem\n** form a distinct entry.  iTab is a sorting index that holds previously\n** seen combinations of the N values.  A new entry is made in iTab\n** if the current N values are new.\n**\n** A jump to addrRepeat is made and the N+1 values are popped from the\n** stack if the top N elements are not distinct.\n*/\nstatic void codeDistinct(\n  Parse *pParse,     /* Parsing and code generating context */\n  int iTab,          /* A sorting index used to test for distinctness */\n  int addrRepeat,    /* Jump to here if not distinct */\n  int N,             /* Number of elements */\n  int iMem           /* First element */\n){\n  Vdbe *v;\n  int r1;\n\n  v = pParse->pVdbe;\n  r1 = sqlite3GetTempReg(pParse);\n  sqlite3VdbeAddOp4Int(v, OP_Found, iTab, addrRepeat, iMem, N);\n  sqlite3VdbeAddOp3(v, OP_MakeRecord, iMem, N, r1);\n  sqlite3VdbeAddOp2(v, OP_IdxInsert, iTab, r1);\n  sqlite3ReleaseTempReg(pParse, r1);\n}\n\n#ifndef SQLITE_OMIT_SUBQUERY\n/*\n** Generate an error message when a SELECT is used within a subexpression\n** (example:  \"a IN (SELECT * FROM table)\") but it has more than 1 result\n** column.  We do this in a subroutine because the error used to occur\n** in multiple places.  (The error only occurs in one place now, but we\n** retain the subroutine to minimize code disruption.)\n*/\nstatic int checkForMultiColumnSelectError(\n  Parse *pParse,       /* Parse context. */\n  SelectDest *pDest,   /* Destination of SELECT results */\n  int nExpr            /* Number of result columns returned by SELECT */\n){\n  int eDest = pDest->eDest;\n  if( nExpr>1 && (eDest==SRT_Mem || eDest==SRT_Set) ){\n    sqlite3ErrorMsg(pParse, \"only a single result allowed for \"\n       \"a SELECT that is part of an expression\");\n    return 1;\n  }else{\n    return 0;\n  }\n}\n#endif\n\n/*\n** This routine generates the code for the inside of the inner loop\n** of a SELECT.\n**\n** If srcTab and nColumn are both zero, then the pEList expressions\n** are evaluated in order to get the data for this row.  If nColumn>0\n** then data is pulled from srcTab and pEList is used only to get the\n** datatypes for each column.\n*/\nstatic void selectInnerLoop(\n  Parse *pParse,          /* The parser context */\n  Select *p,              /* The complete select statement being coded */\n  ExprList *pEList,       /* List of values being extracted */\n  int srcTab,             /* Pull data from this table */\n  int nColumn,            /* Number of columns in the source table */\n  ExprList *pOrderBy,     /* If not NULL, sort results using this key */\n  int distinct,           /* If >=0, make sure results are distinct */\n  SelectDest *pDest,      /* How to dispose of the results */\n  int iContinue,          /* Jump here to continue with next row */\n  int iBreak              /* Jump here to break out of the inner loop */\n){\n  Vdbe *v = pParse->pVdbe;\n  int i;\n  int hasDistinct;        /* True if the DISTINCT keyword is present */\n  int regResult;              /* Start of memory holding result set */\n  int eDest = pDest->eDest;   /* How to dispose of results */\n  int iParm = pDest->iParm;   /* First argument to disposal method */\n  int nResultCol;             /* Number of result columns */\n\n  assert( v );\n  if( NEVER(v==0) ) return;\n  assert( pEList!=0 );\n  hasDistinct = distinct>=0;\n  if( pOrderBy==0 && !hasDistinct ){\n    codeOffset(v, p, iContinue);\n  }\n\n  /* Pull the requested columns.\n  */\n  if( nColumn>0 ){\n    nResultCol = nColumn;\n  }else{\n    nResultCol = pEList->nExpr;\n  }\n  if( pDest->iMem==0 ){\n    pDest->iMem = pParse->nMem+1;\n    pDest->nMem = nResultCol;\n    pParse->nMem += nResultCol;\n  }else{ \n    assert( pDest->nMem==nResultCol );\n  }\n  regResult = pDest->iMem;\n  if( nColumn>0 ){\n    for(i=0; i<nColumn; i++){\n      sqlite3VdbeAddOp3(v, OP_Column, srcTab, i, regResult+i);\n    }\n  }else if( eDest!=SRT_Exists ){\n    /* If the destination is an EXISTS(...) expression, the actual\n    ** values returned by the SELECT are not required.\n    */\n    sqlite3ExprCacheClear(pParse);\n    sqlite3ExprCodeExprList(pParse, pEList, regResult, eDest==SRT_Output);\n  }\n  nColumn = nResultCol;\n\n  /* If the DISTINCT keyword was present on the SELECT statement\n  ** and this row has been seen before, then do not make this row\n  ** part of the result.\n  */\n  if( hasDistinct ){\n    assert( pEList!=0 );\n    assert( pEList->nExpr==nColumn );\n    codeDistinct(pParse, distinct, iContinue, nColumn, regResult);\n    if( pOrderBy==0 ){\n      codeOffset(v, p, iContinue);\n    }\n  }\n\n  switch( eDest ){\n    /* In this mode, write each query result to the key of the temporary\n    ** table iParm.\n    */\n#ifndef SQLITE_OMIT_COMPOUND_SELECT\n    case SRT_Union: {\n      int r1;\n      r1 = sqlite3GetTempReg(pParse);\n      sqlite3VdbeAddOp3(v, OP_MakeRecord, regResult, nColumn, r1);\n      sqlite3VdbeAddOp2(v, OP_IdxInsert, iParm, r1);\n      sqlite3ReleaseTempReg(pParse, r1);\n      break;\n    }\n\n    /* Construct a record from the query result, but instead of\n    ** saving that record, use it as a key to delete elements from\n    ** the temporary table iParm.\n    */\n    case SRT_Except: {\n      sqlite3VdbeAddOp3(v, OP_IdxDelete, iParm, regResult, nColumn);\n      break;\n    }\n#endif\n\n    /* Store the result as data using a unique key.\n    */\n    case SRT_Table:\n    case SRT_EphemTab: {\n      int r1 = sqlite3GetTempReg(pParse);\n      testcase( eDest==SRT_Table );\n      testcase( eDest==SRT_EphemTab );\n      sqlite3VdbeAddOp3(v, OP_MakeRecord, regResult, nColumn, r1);\n      if( pOrderBy ){\n        pushOntoSorter(pParse, pOrderBy, p, r1);\n      }else{\n        int r2 = sqlite3GetTempReg(pParse);\n        sqlite3VdbeAddOp2(v, OP_NewRowid, iParm, r2);\n        sqlite3VdbeAddOp3(v, OP_Insert, iParm, r1, r2);\n        sqlite3VdbeChangeP5(v, OPFLAG_APPEND);\n        sqlite3ReleaseTempReg(pParse, r2);\n      }\n      sqlite3ReleaseTempReg(pParse, r1);\n      break;\n    }\n\n#ifndef SQLITE_OMIT_SUBQUERY\n    /* If we are creating a set for an \"expr IN (SELECT ...)\" construct,\n    ** then there should be a single item on the stack.  Write this\n    ** item into the set table with bogus data.\n    */\n    case SRT_Set: {\n      assert( nColumn==1 );\n      p->affinity = sqlite3CompareAffinity(pEList->a[0].pExpr, pDest->affinity);\n      if( pOrderBy ){\n        /* At first glance you would think we could optimize out the\n        ** ORDER BY in this case since the order of entries in the set\n        ** does not matter.  But there might be a LIMIT clause, in which\n        ** case the order does matter */\n        pushOntoSorter(pParse, pOrderBy, p, regResult);\n      }else{\n        int r1 = sqlite3GetTempReg(pParse);\n        sqlite3VdbeAddOp4(v, OP_MakeRecord, regResult, 1, r1, &p->affinity, 1);\n        sqlite3ExprCacheAffinityChange(pParse, regResult, 1);\n        sqlite3VdbeAddOp2(v, OP_IdxInsert, iParm, r1);\n        sqlite3ReleaseTempReg(pParse, r1);\n      }\n      break;\n    }\n\n    /* If any row exist in the result set, record that fact and abort.\n    */\n    case SRT_Exists: {\n      sqlite3VdbeAddOp2(v, OP_Integer, 1, iParm);\n      /* The LIMIT clause will terminate the loop for us */\n      break;\n    }\n\n    /* If this is a scalar select that is part of an expression, then\n    ** store the results in the appropriate memory cell and break out\n    ** of the scan loop.\n    */\n    case SRT_Mem: {\n      assert( nColumn==1 );\n      if( pOrderBy ){\n        pushOntoSorter(pParse, pOrderBy, p, regResult);\n      }else{\n        sqlite3ExprCodeMove(pParse, regResult, iParm, 1);\n        /* The LIMIT clause will jump out of the loop for us */\n      }\n      break;\n    }\n#endif /* #ifndef SQLITE_OMIT_SUBQUERY */\n\n    /* Send the data to the callback function or to a subroutine.  In the\n    ** case of a subroutine, the subroutine itself is responsible for\n    ** popping the data from the stack.\n    */\n    case SRT_Coroutine:\n    case SRT_Output: {\n      testcase( eDest==SRT_Coroutine );\n      testcase( eDest==SRT_Output );\n      if( pOrderBy ){\n        int r1 = sqlite3GetTempReg(pParse);\n        sqlite3VdbeAddOp3(v, OP_MakeRecord, regResult, nColumn, r1);\n        pushOntoSorter(pParse, pOrderBy, p, r1);\n        sqlite3ReleaseTempReg(pParse, r1);\n      }else if( eDest==SRT_Coroutine ){\n        sqlite3VdbeAddOp1(v, OP_Yield, pDest->iParm);\n      }else{\n        sqlite3VdbeAddOp2(v, OP_ResultRow, regResult, nColumn);\n        sqlite3ExprCacheAffinityChange(pParse, regResult, nColumn);\n      }\n      break;\n    }\n\n#if !defined(SQLITE_OMIT_TRIGGER)\n    /* Discard the results.  This is used for SELECT statements inside\n    ** the body of a TRIGGER.  The purpose of such selects is to call\n    ** user-defined functions that have side effects.  We do not care\n    ** about the actual results of the select.\n    */\n    default: {\n      assert( eDest==SRT_Discard );\n      break;\n    }\n#endif\n  }\n\n  /* Jump to the end of the loop if the LIMIT is reached.  Except, if\n  ** there is a sorter, in which case the sorter has already limited\n  ** the output for us.\n  */\n  if( pOrderBy==0 && p->iLimit ){\n    sqlite3VdbeAddOp3(v, OP_IfZero, p->iLimit, iBreak, -1);\n  }\n}\n\n/*\n** Given an expression list, generate a KeyInfo structure that records\n** the collating sequence for each expression in that expression list.\n**\n** If the ExprList is an ORDER BY or GROUP BY clause then the resulting\n** KeyInfo structure is appropriate for initializing a virtual index to\n** implement that clause.  If the ExprList is the result set of a SELECT\n** then the KeyInfo structure is appropriate for initializing a virtual\n** index to implement a DISTINCT test.\n**\n** Space to hold the KeyInfo structure is obtain from malloc.  The calling\n** function is responsible for seeing that this structure is eventually\n** freed.  Add the KeyInfo structure to the P4 field of an opcode using\n** P4_KEYINFO_HANDOFF is the usual way of dealing with this.\n*/\nstatic KeyInfo *keyInfoFromExprList(Parse *pParse, ExprList *pList){\n  sqlite3 *db = pParse->db;\n  int nExpr;\n  KeyInfo *pInfo;\n  struct ExprList_item *pItem;\n  int i;\n\n  nExpr = pList->nExpr;\n  pInfo = sqlite3DbMallocZero(db, sizeof(*pInfo) + nExpr*(sizeof(CollSeq*)+1) );\n  if( pInfo ){\n    pInfo->aSortOrder = (u8*)&pInfo->aColl[nExpr];\n    pInfo->nField = (u16)nExpr;\n    pInfo->enc = ENC(db);\n    pInfo->db = db;\n    for(i=0, pItem=pList->a; i<nExpr; i++, pItem++){\n      CollSeq *pColl;\n      pColl = sqlite3ExprCollSeq(pParse, pItem->pExpr);\n      if( !pColl ){\n        pColl = db->pDfltColl;\n      }\n      pInfo->aColl[i] = pColl;\n      pInfo->aSortOrder[i] = pItem->sortOrder;\n    }\n  }\n  return pInfo;\n}\n\n#ifndef SQLITE_OMIT_COMPOUND_SELECT\n/*\n** Name of the connection operator, used for error messages.\n*/\nstatic const char *selectOpName(int id){\n  char *z;\n  switch( id ){\n    case TK_ALL:       z = \"UNION ALL\";   break;\n    case TK_INTERSECT: z = \"INTERSECT\";   break;\n    case TK_EXCEPT:    z = \"EXCEPT\";      break;\n    default:           z = \"UNION\";       break;\n  }\n  return z;\n}\n#endif /* SQLITE_OMIT_COMPOUND_SELECT */\n\n#ifndef SQLITE_OMIT_EXPLAIN\n/*\n** Unless an \"EXPLAIN QUERY PLAN\" command is being processed, this function\n** is a no-op. Otherwise, it adds a single row of output to the EQP result,\n** where the caption is of the form:\n**\n**   \"USE TEMP B-TREE FOR xxx\"\n**\n** where xxx is one of \"DISTINCT\", \"ORDER BY\" or \"GROUP BY\". Exactly which\n** is determined by the zUsage argument.\n*/\nstatic void explainTempTable(Parse *pParse, const char *zUsage){\n  if( pParse->explain==2 ){\n    Vdbe *v = pParse->pVdbe;\n    char *zMsg = sqlite3MPrintf(pParse->db, \"USE TEMP B-TREE FOR %s\", zUsage);\n    sqlite3VdbeAddOp4(v, OP_Explain, pParse->iSelectId, 0, 0, zMsg, P4_DYNAMIC);\n  }\n}\n\n/*\n** Unless an \"EXPLAIN QUERY PLAN\" command is being processed, this function\n** is a no-op. Otherwise, it adds a single row of output to the EQP result,\n** where the caption is of one of the two forms:\n**\n**   \"COMPOSITE SUBQUERIES iSub1 and iSub2 (op)\"\n**   \"COMPOSITE SUBQUERIES iSub1 and iSub2 USING TEMP B-TREE (op)\"\n**\n** where iSub1 and iSub2 are the integers passed as the corresponding\n** function parameters, and op is the text representation of the parameter\n** of the same name. The parameter \"op\" must be one of TK_UNION, TK_EXCEPT,\n** TK_INTERSECT or TK_ALL. The first form is used if argument bUseTmp is \n** false, or the second form if it is true.\n*/\nstatic void explainComposite(\n  Parse *pParse,                  /* Parse context */\n  int op,                         /* One of TK_UNION, TK_EXCEPT etc. */\n  int iSub1,                      /* Subquery id 1 */\n  int iSub2,                      /* Subquery id 2 */\n  int bUseTmp                     /* True if a temp table was used */\n){\n  assert( op==TK_UNION || op==TK_EXCEPT || op==TK_INTERSECT || op==TK_ALL );\n  if( pParse->explain==2 ){\n    Vdbe *v = pParse->pVdbe;\n    char *zMsg = sqlite3MPrintf(\n        pParse->db, \"COMPOUND SUBQUERIES %d AND %d %s(%s)\", iSub1, iSub2,\n        bUseTmp?\"USING TEMP B-TREE \":\"\", selectOpName(op)\n    );\n    sqlite3VdbeAddOp4(v, OP_Explain, pParse->iSelectId, 0, 0, zMsg, P4_DYNAMIC);\n  }\n}\n\n/*\n** Assign expression b to lvalue a. A second, no-op, version of this macro\n** is provided when SQLITE_OMIT_EXPLAIN is defined. This allows the code\n** in sqlite3Select() to assign values to structure member variables that\n** only exist if SQLITE_OMIT_EXPLAIN is not defined without polluting the\n** code with #ifndef directives.\n*/\n# define explainSetInteger(a, b) a = b\n\n#else\n/* No-op versions of the explainXXX() functions and macros. */\n# define explainTempTable(y,z)\n# define explainComposite(v,w,x,y,z)\n# define explainSetInteger(y,z)\n#endif\n\n/*\n** If the inner loop was generated using a non-null pOrderBy argument,\n** then the results were placed in a sorter.  After the loop is terminated\n** we need to run the sorter and output the results.  The following\n** routine generates the code needed to do that.\n*/\nstatic void generateSortTail(\n  Parse *pParse,    /* Parsing context */\n  Select *p,        /* The SELECT statement */\n  Vdbe *v,          /* Generate code into this VDBE */\n  int nColumn,      /* Number of columns of data */\n  SelectDest *pDest /* Write the sorted results here */\n){\n  int addrBreak = sqlite3VdbeMakeLabel(v);     /* Jump here to exit loop */\n  int addrContinue = sqlite3VdbeMakeLabel(v);  /* Jump here for next cycle */\n  int addr;\n  int iTab;\n  int pseudoTab = 0;\n  ExprList *pOrderBy = p->pOrderBy;\n\n  int eDest = pDest->eDest;\n  int iParm = pDest->iParm;\n\n  int regRow;\n  int regRowid;\n\n  iTab = pOrderBy->iECursor;\n  regRow = sqlite3GetTempReg(pParse);\n  if( eDest==SRT_Output || eDest==SRT_Coroutine ){\n    pseudoTab = pParse->nTab++;\n    sqlite3VdbeAddOp3(v, OP_OpenPseudo, pseudoTab, regRow, nColumn);\n    regRowid = 0;\n  }else{\n    regRowid = sqlite3GetTempReg(pParse);\n  }\n  addr = 1 + sqlite3VdbeAddOp2(v, OP_Sort, iTab, addrBreak);\n  codeOffset(v, p, addrContinue);\n  sqlite3VdbeAddOp3(v, OP_Column, iTab, pOrderBy->nExpr + 1, regRow);\n  switch( eDest ){\n    case SRT_Table:\n    case SRT_EphemTab: {\n      testcase( eDest==SRT_Table );\n      testcase( eDest==SRT_EphemTab );\n      sqlite3VdbeAddOp2(v, OP_NewRowid, iParm, regRowid);\n      sqlite3VdbeAddOp3(v, OP_Insert, iParm, regRow, regRowid);\n      sqlite3VdbeChangeP5(v, OPFLAG_APPEND);\n      break;\n    }\n#ifndef SQLITE_OMIT_SUBQUERY\n    case SRT_Set: {\n      assert( nColumn==1 );\n      sqlite3VdbeAddOp4(v, OP_MakeRecord, regRow, 1, regRowid, &p->affinity, 1);\n      sqlite3ExprCacheAffinityChange(pParse, regRow, 1);\n      sqlite3VdbeAddOp2(v, OP_IdxInsert, iParm, regRowid);\n      break;\n    }\n    case SRT_Mem: {\n      assert( nColumn==1 );\n      sqlite3ExprCodeMove(pParse, regRow, iParm, 1);\n      /* The LIMIT clause will terminate the loop for us */\n      break;\n    }\n#endif\n    default: {\n      int i;\n      assert( eDest==SRT_Output || eDest==SRT_Coroutine ); \n      testcase( eDest==SRT_Output );\n      testcase( eDest==SRT_Coroutine );\n      for(i=0; i<nColumn; i++){\n        assert( regRow!=pDest->iMem+i );\n        sqlite3VdbeAddOp3(v, OP_Column, pseudoTab, i, pDest->iMem+i);\n        if( i==0 ){\n          sqlite3VdbeChangeP5(v, OPFLAG_CLEARCACHE);\n        }\n      }\n      if( eDest==SRT_Output ){\n        sqlite3VdbeAddOp2(v, OP_ResultRow, pDest->iMem, nColumn);\n        sqlite3ExprCacheAffinityChange(pParse, pDest->iMem, nColumn);\n      }else{\n        sqlite3VdbeAddOp1(v, OP_Yield, pDest->iParm);\n      }\n      break;\n    }\n  }\n  sqlite3ReleaseTempReg(pParse, regRow);\n  sqlite3ReleaseTempReg(pParse, regRowid);\n\n  /* The bottom of the loop\n  */\n  sqlite3VdbeResolveLabel(v, addrContinue);\n  sqlite3VdbeAddOp2(v, OP_Next, iTab, addr);\n  sqlite3VdbeResolveLabel(v, addrBreak);\n  if( eDest==SRT_Output || eDest==SRT_Coroutine ){\n    sqlite3VdbeAddOp2(v, OP_Close, pseudoTab, 0);\n  }\n}\n\n/*\n** Return a pointer to a string containing the 'declaration type' of the\n** expression pExpr. The string may be treated as static by the caller.\n**\n** The declaration type is the exact datatype definition extracted from the\n** original CREATE TABLE statement if the expression is a column. The\n** declaration type for a ROWID field is INTEGER. Exactly when an expression\n** is considered a column can be complex in the presence of subqueries. The\n** result-set expression in all of the following SELECT statements is \n** considered a column by this function.\n**\n**   SELECT col FROM tbl;\n**   SELECT (SELECT col FROM tbl;\n**   SELECT (SELECT col FROM tbl);\n**   SELECT abc FROM (SELECT col AS abc FROM tbl);\n** \n** The declaration type for any expression other than a column is NULL.\n*/\nstatic const char *columnType(\n  NameContext *pNC, \n  Expr *pExpr,\n  const char **pzOriginDb,\n  const char **pzOriginTab,\n  const char **pzOriginCol\n){\n  char const *zType = 0;\n  char const *zOriginDb = 0;\n  char const *zOriginTab = 0;\n  char const *zOriginCol = 0;\n  int j;\n  if( NEVER(pExpr==0) || pNC->pSrcList==0 ) return 0;\n\n  switch( pExpr->op ){\n    case TK_AGG_COLUMN:\n    case TK_COLUMN: {\n      /* The expression is a column. Locate the table the column is being\n      ** extracted from in NameContext.pSrcList. This table may be real\n      ** database table or a subquery.\n      */\n      Table *pTab = 0;            /* Table structure column is extracted from */\n      Select *pS = 0;             /* Select the column is extracted from */\n      int iCol = pExpr->iColumn;  /* Index of column in pTab */\n      testcase( pExpr->op==TK_AGG_COLUMN );\n      testcase( pExpr->op==TK_COLUMN );\n      while( pNC && !pTab ){\n        SrcList *pTabList = pNC->pSrcList;\n        for(j=0;j<pTabList->nSrc && pTabList->a[j].iCursor!=pExpr->iTable;j++);\n        if( j<pTabList->nSrc ){\n          pTab = pTabList->a[j].pTab;\n          pS = pTabList->a[j].pSelect;\n        }else{\n          pNC = pNC->pNext;\n        }\n      }\n\n      if( pTab==0 ){\n        /* At one time, code such as \"SELECT new.x\" within a trigger would\n        ** cause this condition to run.  Since then, we have restructured how\n        ** trigger code is generated and so this condition is no longer \n        ** possible. However, it can still be true for statements like\n        ** the following:\n        **\n        **   CREATE TABLE t1(col INTEGER);\n        **   SELECT (SELECT t1.col) FROM FROM t1;\n        **\n        ** when columnType() is called on the expression \"t1.col\" in the \n        ** sub-select. In this case, set the column type to NULL, even\n        ** though it should really be \"INTEGER\".\n        **\n        ** This is not a problem, as the column type of \"t1.col\" is never\n        ** used. When columnType() is called on the expression \n        ** \"(SELECT t1.col)\", the correct type is returned (see the TK_SELECT\n        ** branch below.  */\n        break;\n      }\n\n      assert( pTab && pExpr->pTab==pTab );\n      if( pS ){\n        /* The \"table\" is actually a sub-select or a view in the FROM clause\n        ** of the SELECT statement. Return the declaration type and origin\n        ** data for the result-set column of the sub-select.\n        */\n        if( iCol>=0 && ALWAYS(iCol<pS->pEList->nExpr) ){\n          /* If iCol is less than zero, then the expression requests the\n          ** rowid of the sub-select or view. This expression is legal (see \n          ** test case misc2.2.2) - it always evaluates to NULL.\n          */\n          NameContext sNC;\n          Expr *p = pS->pEList->a[iCol].pExpr;\n          sNC.pSrcList = pS->pSrc;\n          sNC.pNext = pNC;\n          sNC.pParse = pNC->pParse;\n          zType = columnType(&sNC, p, &zOriginDb, &zOriginTab, &zOriginCol); \n        }\n      }else if( ALWAYS(pTab->pSchema) ){\n        /* A real table */\n        assert( !pS );\n        if( iCol<0 ) iCol = pTab->iPKey;\n        assert( iCol==-1 || (iCol>=0 && iCol<pTab->nCol) );\n        if( iCol<0 ){\n          zType = \"INTEGER\";\n          zOriginCol = \"rowid\";\n        }else{\n          zType = pTab->aCol[iCol].zType;\n          zOriginCol = pTab->aCol[iCol].zName;\n        }\n        zOriginTab = pTab->zName;\n        if( pNC->pParse ){\n          int iDb = sqlite3SchemaToIndex(pNC->pParse->db, pTab->pSchema);\n          zOriginDb = pNC->pParse->db->aDb[iDb].zName;\n        }\n      }\n      break;\n    }\n#ifndef SQLITE_OMIT_SUBQUERY\n    case TK_SELECT: {\n      /* The expression is a sub-select. Return the declaration type and\n      ** origin info for the single column in the result set of the SELECT\n      ** statement.\n      */\n      NameContext sNC;\n      Select *pS = pExpr->x.pSelect;\n      Expr *p = pS->pEList->a[0].pExpr;\n      assert( ExprHasProperty(pExpr, EP_xIsSelect) );\n      sNC.pSrcList = pS->pSrc;\n      sNC.pNext = pNC;\n      sNC.pParse = pNC->pParse;\n      zType = columnType(&sNC, p, &zOriginDb, &zOriginTab, &zOriginCol); \n      break;\n    }\n#endif\n  }\n  \n  if( pzOriginDb ){\n    assert( pzOriginTab && pzOriginCol );\n    *pzOriginDb = zOriginDb;\n    *pzOriginTab = zOriginTab;\n    *pzOriginCol = zOriginCol;\n  }\n  return zType;\n}\n\n/*\n** Generate code that will tell the VDBE the declaration types of columns\n** in the result set.\n*/\nstatic void generateColumnTypes(\n  Parse *pParse,      /* Parser context */\n  SrcList *pTabList,  /* List of tables */\n  ExprList *pEList    /* Expressions defining the result set */\n){\n#ifndef SQLITE_OMIT_DECLTYPE\n  Vdbe *v = pParse->pVdbe;\n  int i;\n  NameContext sNC;\n  sNC.pSrcList = pTabList;\n  sNC.pParse = pParse;\n  for(i=0; i<pEList->nExpr; i++){\n    Expr *p = pEList->a[i].pExpr;\n    const char *zType;\n#ifdef SQLITE_ENABLE_COLUMN_METADATA\n    const char *zOrigDb = 0;\n    const char *zOrigTab = 0;\n    const char *zOrigCol = 0;\n    zType = columnType(&sNC, p, &zOrigDb, &zOrigTab, &zOrigCol);\n\n    /* The vdbe must make its own copy of the column-type and other \n    ** column specific strings, in case the schema is reset before this\n    ** virtual machine is deleted.\n    */\n    sqlite3VdbeSetColName(v, i, COLNAME_DATABASE, zOrigDb, SQLITE_TRANSIENT);\n    sqlite3VdbeSetColName(v, i, COLNAME_TABLE, zOrigTab, SQLITE_TRANSIENT);\n    sqlite3VdbeSetColName(v, i, COLNAME_COLUMN, zOrigCol, SQLITE_TRANSIENT);\n#else\n    zType = columnType(&sNC, p, 0, 0, 0);\n#endif\n    sqlite3VdbeSetColName(v, i, COLNAME_DECLTYPE, zType, SQLITE_TRANSIENT);\n  }\n#endif /* SQLITE_OMIT_DECLTYPE */\n}\n\n/*\n** Generate code that will tell the VDBE the names of columns\n** in the result set.  This information is used to provide the\n** azCol[] values in the callback.\n*/\nstatic void generateColumnNames(\n  Parse *pParse,      /* Parser context */\n  SrcList *pTabList,  /* List of tables */\n  ExprList *pEList    /* Expressions defining the result set */\n){\n  Vdbe *v = pParse->pVdbe;\n  int i, j;\n  sqlite3 *db = pParse->db;\n  int fullNames, shortNames;\n\n#ifndef SQLITE_OMIT_EXPLAIN\n  /* If this is an EXPLAIN, skip this step */\n  if( pParse->explain ){\n    return;\n  }\n#endif\n\n  if( pParse->colNamesSet || NEVER(v==0) || db->mallocFailed ) return;\n  pParse->colNamesSet = 1;\n  fullNames = (db->flags & SQLITE_FullColNames)!=0;\n  shortNames = (db->flags & SQLITE_ShortColNames)!=0;\n  sqlite3VdbeSetNumCols(v, pEList->nExpr);\n  for(i=0; i<pEList->nExpr; i++){\n    Expr *p;\n    p = pEList->a[i].pExpr;\n    if( NEVER(p==0) ) continue;\n    if( pEList->a[i].zName ){\n      char *zName = pEList->a[i].zName;\n      sqlite3VdbeSetColName(v, i, COLNAME_NAME, zName, SQLITE_TRANSIENT);\n    }else if( (p->op==TK_COLUMN || p->op==TK_AGG_COLUMN) && pTabList ){\n      Table *pTab;\n      char *zCol;\n      int iCol = p->iColumn;\n      for(j=0; ALWAYS(j<pTabList->nSrc); j++){\n        if( pTabList->a[j].iCursor==p->iTable ) break;\n      }\n      assert( j<pTabList->nSrc );\n      pTab = pTabList->a[j].pTab;\n      if( iCol<0 ) iCol = pTab->iPKey;\n      assert( iCol==-1 || (iCol>=0 && iCol<pTab->nCol) );\n      if( iCol<0 ){\n        zCol = \"rowid\";\n      }else{\n        zCol = pTab->aCol[iCol].zName;\n      }\n      if( !shortNames && !fullNames ){\n        sqlite3VdbeSetColName(v, i, COLNAME_NAME, \n            sqlite3DbStrDup(db, pEList->a[i].zSpan), SQLITE_DYNAMIC);\n      }else if( fullNames ){\n        char *zName = 0;\n        zName = sqlite3MPrintf(db, \"%s.%s\", pTab->zName, zCol);\n        sqlite3VdbeSetColName(v, i, COLNAME_NAME, zName, SQLITE_DYNAMIC);\n      }else{\n        sqlite3VdbeSetColName(v, i, COLNAME_NAME, zCol, SQLITE_TRANSIENT);\n      }\n    }else{\n      sqlite3VdbeSetColName(v, i, COLNAME_NAME, \n          sqlite3DbStrDup(db, pEList->a[i].zSpan), SQLITE_DYNAMIC);\n    }\n  }\n  generateColumnTypes(pParse, pTabList, pEList);\n}\n\n/*\n** Given a an expression list (which is really the list of expressions\n** that form the result set of a SELECT statement) compute appropriate\n** column names for a table that would hold the expression list.\n**\n** All column names will be unique.\n**\n** Only the column names are computed.  Column.zType, Column.zColl,\n** and other fields of Column are zeroed.\n**\n** Return SQLITE_OK on success.  If a memory allocation error occurs,\n** store NULL in *paCol and 0 in *pnCol and return SQLITE_NOMEM.\n*/\nstatic int selectColumnsFromExprList(\n  Parse *pParse,          /* Parsing context */\n  ExprList *pEList,       /* Expr list from which to derive column names */\n  int *pnCol,             /* Write the number of columns here */\n  Column **paCol          /* Write the new column list here */\n){\n  sqlite3 *db = pParse->db;   /* Database connection */\n  int i, j;                   /* Loop counters */\n  int cnt;                    /* Index added to make the name unique */\n  Column *aCol, *pCol;        /* For looping over result columns */\n  int nCol;                   /* Number of columns in the result set */\n  Expr *p;                    /* Expression for a single result column */\n  char *zName;                /* Column name */\n  int nName;                  /* Size of name in zName[] */\n\n  *pnCol = nCol = pEList->nExpr;\n  aCol = *paCol = sqlite3DbMallocZero(db, sizeof(aCol[0])*nCol);\n  if( aCol==0 ) return SQLITE_NOMEM;\n  for(i=0, pCol=aCol; i<nCol; i++, pCol++){\n    /* Get an appropriate name for the column\n    */\n    p = pEList->a[i].pExpr;\n    assert( p->pRight==0 || ExprHasProperty(p->pRight, EP_IntValue)\n               || p->pRight->u.zToken==0 || p->pRight->u.zToken[0]!=0 );\n    if( (zName = pEList->a[i].zName)!=0 ){\n      /* If the column contains an \"AS <name>\" phrase, use <name> as the name */\n      zName = sqlite3DbStrDup(db, zName);\n    }else{\n      Expr *pColExpr = p;  /* The expression that is the result column name */\n      Table *pTab;         /* Table associated with this expression */\n      while( pColExpr->op==TK_DOT ) pColExpr = pColExpr->pRight;\n      if( pColExpr->op==TK_COLUMN && ALWAYS(pColExpr->pTab!=0) ){\n        /* For columns use the column name name */\n        int iCol = pColExpr->iColumn;\n        pTab = pColExpr->pTab;\n        if( iCol<0 ) iCol = pTab->iPKey;\n        zName = sqlite3MPrintf(db, \"%s\",\n                 iCol>=0 ? pTab->aCol[iCol].zName : \"rowid\");\n      }else if( pColExpr->op==TK_ID ){\n        assert( !ExprHasProperty(pColExpr, EP_IntValue) );\n        zName = sqlite3MPrintf(db, \"%s\", pColExpr->u.zToken);\n      }else{\n        /* Use the original text of the column expression as its name */\n        zName = sqlite3MPrintf(db, \"%s\", pEList->a[i].zSpan);\n      }\n    }\n    if( db->mallocFailed ){\n      sqlite3DbFree(db, zName);\n      break;\n    }\n\n    /* Make sure the column name is unique.  If the name is not unique,\n    ** append a integer to the name so that it becomes unique.\n    */\n    nName = sqlite3Strlen30(zName);\n    for(j=cnt=0; j<i; j++){\n      if( sqlite3StrICmp(aCol[j].zName, zName)==0 ){\n        char *zNewName;\n        zName[nName] = 0;\n        zNewName = sqlite3MPrintf(db, \"%s:%d\", zName, ++cnt);\n        sqlite3DbFree(db, zName);\n        zName = zNewName;\n        j = -1;\n        if( zName==0 ) break;\n      }\n    }\n    pCol->zName = zName;\n  }\n  if( db->mallocFailed ){\n    for(j=0; j<i; j++){\n      sqlite3DbFree(db, aCol[j].zName);\n    }\n    sqlite3DbFree(db, aCol);\n    *paCol = 0;\n    *pnCol = 0;\n    return SQLITE_NOMEM;\n  }\n  return SQLITE_OK;\n}\n\n/*\n** Add type and collation information to a column list based on\n** a SELECT statement.\n** \n** The column list presumably came from selectColumnNamesFromExprList().\n** The column list has only names, not types or collations.  This\n** routine goes through and adds the types and collations.\n**\n** This routine requires that all identifiers in the SELECT\n** statement be resolved.\n*/\nstatic void selectAddColumnTypeAndCollation(\n  Parse *pParse,        /* Parsing contexts */\n  int nCol,             /* Number of columns */\n  Column *aCol,         /* List of columns */\n  Select *pSelect       /* SELECT used to determine types and collations */\n){\n  sqlite3 *db = pParse->db;\n  NameContext sNC;\n  Column *pCol;\n  CollSeq *pColl;\n  int i;\n  Expr *p;\n  struct ExprList_item *a;\n\n  assert( pSelect!=0 );\n  assert( (pSelect->selFlags & SF_Resolved)!=0 );\n  assert( nCol==pSelect->pEList->nExpr || db->mallocFailed );\n  if( db->mallocFailed ) return;\n  memset(&sNC, 0, sizeof(sNC));\n  sNC.pSrcList = pSelect->pSrc;\n  a = pSelect->pEList->a;\n  for(i=0, pCol=aCol; i<nCol; i++, pCol++){\n    p = a[i].pExpr;\n    pCol->zType = sqlite3DbStrDup(db, columnType(&sNC, p, 0, 0, 0));\n    pCol->affinity = sqlite3ExprAffinity(p);\n    if( pCol->affinity==0 ) pCol->affinity = SQLITE_AFF_NONE;\n    pColl = sqlite3ExprCollSeq(pParse, p);\n    if( pColl ){\n      pCol->zColl = sqlite3DbStrDup(db, pColl->zName);\n    }\n  }\n}\n\n/*\n** Given a SELECT statement, generate a Table structure that describes\n** the result set of that SELECT.\n*/\nSQLITE_PRIVATE Table *sqlite3ResultSetOfSelect(Parse *pParse, Select *pSelect){\n  Table *pTab;\n  sqlite3 *db = pParse->db;\n  int savedFlags;\n\n  savedFlags = db->flags;\n  db->flags &= ~SQLITE_FullColNames;\n  db->flags |= SQLITE_ShortColNames;\n  sqlite3SelectPrep(pParse, pSelect, 0);\n  if( pParse->nErr ) return 0;\n  while( pSelect->pPrior ) pSelect = pSelect->pPrior;\n  db->flags = savedFlags;\n  pTab = sqlite3DbMallocZero(db, sizeof(Table) );\n  if( pTab==0 ){\n    return 0;\n  }\n  /* The sqlite3ResultSetOfSelect() is only used n contexts where lookaside\n  ** is disabled */\n  assert( db->lookaside.bEnabled==0 );\n  pTab->nRef = 1;\n  pTab->zName = 0;\n  pTab->nRowEst = 1000000;\n  selectColumnsFromExprList(pParse, pSelect->pEList, &pTab->nCol, &pTab->aCol);\n  selectAddColumnTypeAndCollation(pParse, pTab->nCol, pTab->aCol, pSelect);\n  pTab->iPKey = -1;\n  if( db->mallocFailed ){\n    sqlite3DeleteTable(db, pTab);\n    return 0;\n  }\n  return pTab;\n}\n\n/*\n** Get a VDBE for the given parser context.  Create a new one if necessary.\n** If an error occurs, return NULL and leave a message in pParse.\n*/\nSQLITE_PRIVATE Vdbe *sqlite3GetVdbe(Parse *pParse){\n  Vdbe *v = pParse->pVdbe;\n  if( v==0 ){\n    v = pParse->pVdbe = sqlite3VdbeCreate(pParse->db);\n#ifndef SQLITE_OMIT_TRACE\n    if( v ){\n      sqlite3VdbeAddOp0(v, OP_Trace);\n    }\n#endif\n  }\n  return v;\n}\n\n\n/*\n** Compute the iLimit and iOffset fields of the SELECT based on the\n** pLimit and pOffset expressions.  pLimit and pOffset hold the expressions\n** that appear in the original SQL statement after the LIMIT and OFFSET\n** keywords.  Or NULL if those keywords are omitted. iLimit and iOffset \n** are the integer memory register numbers for counters used to compute \n** the limit and offset.  If there is no limit and/or offset, then \n** iLimit and iOffset are negative.\n**\n** This routine changes the values of iLimit and iOffset only if\n** a limit or offset is defined by pLimit and pOffset.  iLimit and\n** iOffset should have been preset to appropriate default values\n** (usually but not always -1) prior to calling this routine.\n** Only if pLimit!=0 or pOffset!=0 do the limit registers get\n** redefined.  The UNION ALL operator uses this property to force\n** the reuse of the same limit and offset registers across multiple\n** SELECT statements.\n*/\nstatic void computeLimitRegisters(Parse *pParse, Select *p, int iBreak){\n  Vdbe *v = 0;\n  int iLimit = 0;\n  int iOffset;\n  int addr1, n;\n  if( p->iLimit ) return;\n\n  /* \n  ** \"LIMIT -1\" always shows all rows.  There is some\n  ** contraversy about what the correct behavior should be.\n  ** The current implementation interprets \"LIMIT 0\" to mean\n  ** no rows.\n  */\n  sqlite3ExprCacheClear(pParse);\n  assert( p->pOffset==0 || p->pLimit!=0 );\n  if( p->pLimit ){\n    p->iLimit = iLimit = ++pParse->nMem;\n    v = sqlite3GetVdbe(pParse);\n    if( NEVER(v==0) ) return;  /* VDBE should have already been allocated */\n    if( sqlite3ExprIsInteger(p->pLimit, &n) ){\n      sqlite3VdbeAddOp2(v, OP_Integer, n, iLimit);\n      VdbeComment((v, \"LIMIT counter\"));\n      if( n==0 ){\n        sqlite3VdbeAddOp2(v, OP_Goto, 0, iBreak);\n      }else{\n        if( p->nSelectRow > (double)n ) p->nSelectRow = (double)n;\n      }\n    }else{\n      sqlite3ExprCode(pParse, p->pLimit, iLimit);\n      sqlite3VdbeAddOp1(v, OP_MustBeInt, iLimit);\n      VdbeComment((v, \"LIMIT counter\"));\n      sqlite3VdbeAddOp2(v, OP_IfZero, iLimit, iBreak);\n    }\n    if( p->pOffset ){\n      p->iOffset = iOffset = ++pParse->nMem;\n      pParse->nMem++;   /* Allocate an extra register for limit+offset */\n      sqlite3ExprCode(pParse, p->pOffset, iOffset);\n      sqlite3VdbeAddOp1(v, OP_MustBeInt, iOffset);\n      VdbeComment((v, \"OFFSET counter\"));\n      addr1 = sqlite3VdbeAddOp1(v, OP_IfPos, iOffset);\n      sqlite3VdbeAddOp2(v, OP_Integer, 0, iOffset);\n      sqlite3VdbeJumpHere(v, addr1);\n      sqlite3VdbeAddOp3(v, OP_Add, iLimit, iOffset, iOffset+1);\n      VdbeComment((v, \"LIMIT+OFFSET\"));\n      addr1 = sqlite3VdbeAddOp1(v, OP_IfPos, iLimit);\n      sqlite3VdbeAddOp2(v, OP_Integer, -1, iOffset+1);\n      sqlite3VdbeJumpHere(v, addr1);\n    }\n  }\n}\n\n#ifndef SQLITE_OMIT_COMPOUND_SELECT\n/*\n** Return the appropriate collating sequence for the iCol-th column of\n** the result set for the compound-select statement \"p\".  Return NULL if\n** the column has no default collating sequence.\n**\n** The collating sequence for the compound select is taken from the\n** left-most term of the select that has a collating sequence.\n*/\nstatic CollSeq *multiSelectCollSeq(Parse *pParse, Select *p, int iCol){\n  CollSeq *pRet;\n  if( p->pPrior ){\n    pRet = multiSelectCollSeq(pParse, p->pPrior, iCol);\n  }else{\n    pRet = 0;\n  }\n  assert( iCol>=0 );\n  if( pRet==0 && iCol<p->pEList->nExpr ){\n    pRet = sqlite3ExprCollSeq(pParse, p->pEList->a[iCol].pExpr);\n  }\n  return pRet;\n}\n#endif /* SQLITE_OMIT_COMPOUND_SELECT */\n\n/* Forward reference */\nstatic int multiSelectOrderBy(\n  Parse *pParse,        /* Parsing context */\n  Select *p,            /* The right-most of SELECTs to be coded */\n  SelectDest *pDest     /* What to do with query results */\n);\n\n\n#ifndef SQLITE_OMIT_COMPOUND_SELECT\n/*\n** This routine is called to process a compound query form from\n** two or more separate queries using UNION, UNION ALL, EXCEPT, or\n** INTERSECT\n**\n** \"p\" points to the right-most of the two queries.  the query on the\n** left is p->pPrior.  The left query could also be a compound query\n** in which case this routine will be called recursively. \n**\n** The results of the total query are to be written into a destination\n** of type eDest with parameter iParm.\n**\n** Example 1:  Consider a three-way compound SQL statement.\n**\n**     SELECT a FROM t1 UNION SELECT b FROM t2 UNION SELECT c FROM t3\n**\n** This statement is parsed up as follows:\n**\n**     SELECT c FROM t3\n**      |\n**      `----->  SELECT b FROM t2\n**                |\n**                `------>  SELECT a FROM t1\n**\n** The arrows in the diagram above represent the Select.pPrior pointer.\n** So if this routine is called with p equal to the t3 query, then\n** pPrior will be the t2 query.  p->op will be TK_UNION in this case.\n**\n** Notice that because of the way SQLite parses compound SELECTs, the\n** individual selects always group from left to right.\n*/\nstatic int multiSelect(\n  Parse *pParse,        /* Parsing context */\n  Select *p,            /* The right-most of SELECTs to be coded */\n  SelectDest *pDest     /* What to do with query results */\n){\n  int rc = SQLITE_OK;   /* Success code from a subroutine */\n  Select *pPrior;       /* Another SELECT immediately to our left */\n  Vdbe *v;              /* Generate code to this VDBE */\n  SelectDest dest;      /* Alternative data destination */\n  Select *pDelete = 0;  /* Chain of simple selects to delete */\n  sqlite3 *db;          /* Database connection */\n#ifndef SQLITE_OMIT_EXPLAIN\n  int iSub1;            /* EQP id of left-hand query */\n  int iSub2;            /* EQP id of right-hand query */\n#endif\n\n  /* Make sure there is no ORDER BY or LIMIT clause on prior SELECTs.  Only\n  ** the last (right-most) SELECT in the series may have an ORDER BY or LIMIT.\n  */\n  assert( p && p->pPrior );  /* Calling function guarantees this much */\n  db = pParse->db;\n  pPrior = p->pPrior;\n  assert( pPrior->pRightmost!=pPrior );\n  assert( pPrior->pRightmost==p->pRightmost );\n  dest = *pDest;\n  if( pPrior->pOrderBy ){\n    sqlite3ErrorMsg(pParse,\"ORDER BY clause should come after %s not before\",\n      selectOpName(p->op));\n    rc = 1;\n    goto multi_select_end;\n  }\n  if( pPrior->pLimit ){\n    sqlite3ErrorMsg(pParse,\"LIMIT clause should come after %s not before\",\n      selectOpName(p->op));\n    rc = 1;\n    goto multi_select_end;\n  }\n\n  v = sqlite3GetVdbe(pParse);\n  assert( v!=0 );  /* The VDBE already created by calling function */\n\n  /* Create the destination temporary table if necessary\n  */\n  if( dest.eDest==SRT_EphemTab ){\n    assert( p->pEList );\n    sqlite3VdbeAddOp2(v, OP_OpenEphemeral, dest.iParm, p->pEList->nExpr);\n    sqlite3VdbeChangeP5(v, BTREE_UNORDERED);\n    dest.eDest = SRT_Table;\n  }\n\n  /* Make sure all SELECTs in the statement have the same number of elements\n  ** in their result sets.\n  */\n  assert( p->pEList && pPrior->pEList );\n  if( p->pEList->nExpr!=pPrior->pEList->nExpr ){\n    sqlite3ErrorMsg(pParse, \"SELECTs to the left and right of %s\"\n      \" do not have the same number of result columns\", selectOpName(p->op));\n    rc = 1;\n    goto multi_select_end;\n  }\n\n  /* Compound SELECTs that have an ORDER BY clause are handled separately.\n  */\n  if( p->pOrderBy ){\n    return multiSelectOrderBy(pParse, p, pDest);\n  }\n\n  /* Generate code for the left and right SELECT statements.\n  */\n  switch( p->op ){\n    case TK_ALL: {\n      int addr = 0;\n      int nLimit;\n      assert( !pPrior->pLimit );\n      pPrior->pLimit = p->pLimit;\n      pPrior->pOffset = p->pOffset;\n      explainSetInteger(iSub1, pParse->iNextSelectId);\n      rc = sqlite3Select(pParse, pPrior, &dest);\n      p->pLimit = 0;\n      p->pOffset = 0;\n      if( rc ){\n        goto multi_select_end;\n      }\n      p->pPrior = 0;\n      p->iLimit = pPrior->iLimit;\n      p->iOffset = pPrior->iOffset;\n      if( p->iLimit ){\n        addr = sqlite3VdbeAddOp1(v, OP_IfZero, p->iLimit);\n        VdbeComment((v, \"Jump ahead if LIMIT reached\"));\n      }\n      explainSetInteger(iSub2, pParse->iNextSelectId);\n      rc = sqlite3Select(pParse, p, &dest);\n      testcase( rc!=SQLITE_OK );\n      pDelete = p->pPrior;\n      p->pPrior = pPrior;\n      p->nSelectRow += pPrior->nSelectRow;\n      if( pPrior->pLimit\n       && sqlite3ExprIsInteger(pPrior->pLimit, &nLimit)\n       && p->nSelectRow > (double)nLimit \n      ){\n        p->nSelectRow = (double)nLimit;\n      }\n      if( addr ){\n        sqlite3VdbeJumpHere(v, addr);\n      }\n      break;\n    }\n    case TK_EXCEPT:\n    case TK_UNION: {\n      int unionTab;    /* Cursor number of the temporary table holding result */\n      u8 op = 0;       /* One of the SRT_ operations to apply to self */\n      int priorOp;     /* The SRT_ operation to apply to prior selects */\n      Expr *pLimit, *pOffset; /* Saved values of p->nLimit and p->nOffset */\n      int addr;\n      SelectDest uniondest;\n\n      testcase( p->op==TK_EXCEPT );\n      testcase( p->op==TK_UNION );\n      priorOp = SRT_Union;\n      if( dest.eDest==priorOp && ALWAYS(!p->pLimit &&!p->pOffset) ){\n        /* We can reuse a temporary table generated by a SELECT to our\n        ** right.\n        */\n        assert( p->pRightmost!=p );  /* Can only happen for leftward elements\n                                     ** of a 3-way or more compound */\n        assert( p->pLimit==0 );      /* Not allowed on leftward elements */\n        assert( p->pOffset==0 );     /* Not allowed on leftward elements */\n        unionTab = dest.iParm;\n      }else{\n        /* We will need to create our own temporary table to hold the\n        ** intermediate results.\n        */\n        unionTab = pParse->nTab++;\n        assert( p->pOrderBy==0 );\n        addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, unionTab, 0);\n        assert( p->addrOpenEphm[0] == -1 );\n        p->addrOpenEphm[0] = addr;\n        p->pRightmost->selFlags |= SF_UsesEphemeral;\n        assert( p->pEList );\n      }\n\n      /* Code the SELECT statements to our left\n      */\n      assert( !pPrior->pOrderBy );\n      sqlite3SelectDestInit(&uniondest, priorOp, unionTab);\n      explainSetInteger(iSub1, pParse->iNextSelectId);\n      rc = sqlite3Select(pParse, pPrior, &uniondest);\n      if( rc ){\n        goto multi_select_end;\n      }\n\n      /* Code the current SELECT statement\n      */\n      if( p->op==TK_EXCEPT ){\n        op = SRT_Except;\n      }else{\n        assert( p->op==TK_UNION );\n        op = SRT_Union;\n      }\n      p->pPrior = 0;\n      pLimit = p->pLimit;\n      p->pLimit = 0;\n      pOffset = p->pOffset;\n      p->pOffset = 0;\n      uniondest.eDest = op;\n      explainSetInteger(iSub2, pParse->iNextSelectId);\n      rc = sqlite3Select(pParse, p, &uniondest);\n      testcase( rc!=SQLITE_OK );\n      /* Query flattening in sqlite3Select() might refill p->pOrderBy.\n      ** Be sure to delete p->pOrderBy, therefore, to avoid a memory leak. */\n      sqlite3ExprListDelete(db, p->pOrderBy);\n      pDelete = p->pPrior;\n      p->pPrior = pPrior;\n      p->pOrderBy = 0;\n      if( p->op==TK_UNION ) p->nSelectRow += pPrior->nSelectRow;\n      sqlite3ExprDelete(db, p->pLimit);\n      p->pLimit = pLimit;\n      p->pOffset = pOffset;\n      p->iLimit = 0;\n      p->iOffset = 0;\n\n      /* Convert the data in the temporary table into whatever form\n      ** it is that we currently need.\n      */\n      assert( unionTab==dest.iParm || dest.eDest!=priorOp );\n      if( dest.eDest!=priorOp ){\n        int iCont, iBreak, iStart;\n        assert( p->pEList );\n        if( dest.eDest==SRT_Output ){\n          Select *pFirst = p;\n          while( pFirst->pPrior ) pFirst = pFirst->pPrior;\n          generateColumnNames(pParse, 0, pFirst->pEList);\n        }\n        iBreak = sqlite3VdbeMakeLabel(v);\n        iCont = sqlite3VdbeMakeLabel(v);\n        computeLimitRegisters(pParse, p, iBreak);\n        sqlite3VdbeAddOp2(v, OP_Rewind, unionTab, iBreak);\n        iStart = sqlite3VdbeCurrentAddr(v);\n        selectInnerLoop(pParse, p, p->pEList, unionTab, p->pEList->nExpr,\n                        0, -1, &dest, iCont, iBreak);\n        sqlite3VdbeResolveLabel(v, iCont);\n        sqlite3VdbeAddOp2(v, OP_Next, unionTab, iStart);\n        sqlite3VdbeResolveLabel(v, iBreak);\n        sqlite3VdbeAddOp2(v, OP_Close, unionTab, 0);\n      }\n      break;\n    }\n    default: assert( p->op==TK_INTERSECT ); {\n      int tab1, tab2;\n      int iCont, iBreak, iStart;\n      Expr *pLimit, *pOffset;\n      int addr;\n      SelectDest intersectdest;\n      int r1;\n\n      /* INTERSECT is different from the others since it requires\n      ** two temporary tables.  Hence it has its own case.  Begin\n      ** by allocating the tables we will need.\n      */\n      tab1 = pParse->nTab++;\n      tab2 = pParse->nTab++;\n      assert( p->pOrderBy==0 );\n\n      addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, tab1, 0);\n      assert( p->addrOpenEphm[0] == -1 );\n      p->addrOpenEphm[0] = addr;\n      p->pRightmost->selFlags |= SF_UsesEphemeral;\n      assert( p->pEList );\n\n      /* Code the SELECTs to our left into temporary table \"tab1\".\n      */\n      sqlite3SelectDestInit(&intersectdest, SRT_Union, tab1);\n      explainSetInteger(iSub1, pParse->iNextSelectId);\n      rc = sqlite3Select(pParse, pPrior, &intersectdest);\n      if( rc ){\n        goto multi_select_end;\n      }\n\n      /* Code the current SELECT into temporary table \"tab2\"\n      */\n      addr = sqlite3VdbeAddOp2(v, OP_OpenEphemeral, tab2, 0);\n      assert( p->addrOpenEphm[1] == -1 );\n      p->addrOpenEphm[1] = addr;\n      p->pPrior = 0;\n      pLimit = p->pLimit;\n      p->pLimit = 0;\n      pOffset = p->pOffset;\n      p->pOffset = 0;\n      intersectdest.iParm = tab2;\n      explainSetInteger(iSub2, pParse->iNextSelectId);\n      rc = sqlite3Select(pParse, p, &intersectdest);\n      testcase( rc!=SQLITE_OK );\n      pDelete = p->pPrior;\n      p->pPrior = pPrior;\n      if( p->nSelectRow>pPrior->nSelectRow ) p->nSelectRow = pPrior->nSelectRow;\n      sqlite3ExprDelete(db, p->pLimit);\n      p->pLimit = pLimit;\n      p->pOffset = pOffset;\n\n      /* Generate code to take the intersection of the two temporary\n      ** tables.\n      */\n      assert( p->pEList );\n      if( dest.eDest==SRT_Output ){\n        Select *pFirst = p;\n        while( pFirst->pPrior ) pFirst = pFirst->pPrior;\n        generateColumnNames(pParse, 0, pFirst->pEList);\n      }\n      iBreak = sqlite3VdbeMakeLabel(v);\n      iCont = sqlite3VdbeMakeLabel(v);\n      computeLimitRegisters(pParse, p, iBreak);\n      sqlite3VdbeAddOp2(v, OP_Rewind, tab1, iBreak);\n      r1 = sqlite3GetTempReg(pParse);\n      iStart = sqlite3VdbeAddOp2(v, OP_RowKey, tab1, r1);\n      sqlite3VdbeAddOp4Int(v, OP_NotFound, tab2, iCont, r1, 0);\n      sqlite3ReleaseTempReg(pParse, r1);\n      selectInnerLoop(pParse, p, p->pEList, tab1, p->pEList->nExpr,\n                      0, -1, &dest, iCont, iBreak);\n      sqlite3VdbeResolveLabel(v, iCont);\n      sqlite3VdbeAddOp2(v, OP_Next, tab1, iStart);\n      sqlite3VdbeResolveLabel(v, iBreak);\n      sqlite3VdbeAddOp2(v, OP_Close, tab2, 0);\n      sqlite3VdbeAddOp2(v, OP_Close, tab1, 0);\n      break;\n    }\n  }\n\n  explainComposite(pParse, p->op, iSub1, iSub2, p->op!=TK_ALL);\n\n  /* Compute collating sequences used by \n  ** temporary tables needed to implement the compound select.\n  ** Attach the KeyInfo structure to all temporary tables.\n  **\n  ** This section is run by the right-most SELECT statement only.\n  ** SELECT statements to the left always skip this part.  The right-most\n  ** SELECT might also skip this part if it has no ORDER BY clause and\n  ** no temp tables are required.\n  */\n  if( p->selFlags & SF_UsesEphemeral ){\n    int i;                        /* Loop counter */\n    KeyInfo *pKeyInfo;            /* Collating sequence for the result set */\n    Select *pLoop;                /* For looping through SELECT statements */\n    CollSeq **apColl;             /* For looping through pKeyInfo->aColl[] */\n    int nCol;                     /* Number of columns in result set */\n\n    assert( p->pRightmost==p );\n    nCol = p->pEList->nExpr;\n    pKeyInfo = sqlite3DbMallocZero(db,\n                       sizeof(*pKeyInfo)+nCol*(sizeof(CollSeq*) + 1));\n    if( !pKeyInfo ){\n      rc = SQLITE_NOMEM;\n      goto multi_select_end;\n    }\n\n    pKeyInfo->enc = ENC(db);\n    pKeyInfo->nField = (u16)nCol;\n\n    for(i=0, apColl=pKeyInfo->aColl; i<nCol; i++, apColl++){\n      *apColl = multiSelectCollSeq(pParse, p, i);\n      if( 0==*apColl ){\n        *apColl = db->pDfltColl;\n      }\n    }\n\n    for(pLoop=p; pLoop; pLoop=pLoop->pPrior){\n      for(i=0; i<2; i++){\n        int addr = pLoop->addrOpenEphm[i];\n        if( addr<0 ){\n          /* If [0] is unused then [1] is also unused.  So we can\n          ** always safely abort as soon as the first unused slot is found */\n          assert( pLoop->addrOpenEphm[1]<0 );\n          break;\n        }\n        sqlite3VdbeChangeP2(v, addr, nCol);\n        sqlite3VdbeChangeP4(v, addr, (char*)pKeyInfo, P4_KEYINFO);\n        pLoop->addrOpenEphm[i] = -1;\n      }\n    }\n    sqlite3DbFree(db, pKeyInfo);\n  }\n\nmulti_select_end:\n  pDest->iMem = dest.iMem;\n  pDest->nMem = dest.nMem;\n  sqlite3SelectDelete(db, pDelete);\n  return rc;\n}\n#endif /* SQLITE_OMIT_COMPOUND_SELECT */\n\n/*\n** Code an output subroutine for a coroutine implementation of a\n** SELECT statment.\n**\n** The data to be output is contained in pIn->iMem.  There are\n** pIn->nMem columns to be output.  pDest is where the output should\n** be sent.\n**\n** regReturn is the number of the register holding the subroutine\n** return address.\n**\n** If regPrev>0 then it is the first register in a vector that\n** records the previous output.  mem[regPrev] is a flag that is false\n** if there has been no previous output.  If regPrev>0 then code is\n** generated to suppress duplicates.  pKeyInfo is used for comparing\n** keys.\n**\n** If the LIMIT found in p->iLimit is reached, jump immediately to\n** iBreak.\n*/\nstatic int generateOutputSubroutine(\n  Parse *pParse,          /* Parsing context */\n  Select *p,              /* The SELECT statement */\n  SelectDest *pIn,        /* Coroutine supplying data */\n  SelectDest *pDest,      /* Where to send the data */\n  int regReturn,          /* The return address register */\n  int regPrev,            /* Previous result register.  No uniqueness if 0 */\n  KeyInfo *pKeyInfo,      /* For comparing with previous entry */\n  int p4type,             /* The p4 type for pKeyInfo */\n  int iBreak              /* Jump here if we hit the LIMIT */\n){\n  Vdbe *v = pParse->pVdbe;\n  int iContinue;\n  int addr;\n\n  addr = sqlite3VdbeCurrentAddr(v);\n  iContinue = sqlite3VdbeMakeLabel(v);\n\n  /* Suppress duplicates for UNION, EXCEPT, and INTERSECT \n  */\n  if( regPrev ){\n    int j1, j2;\n    j1 = sqlite3VdbeAddOp1(v, OP_IfNot, regPrev);\n    j2 = sqlite3VdbeAddOp4(v, OP_Compare, pIn->iMem, regPrev+1, pIn->nMem,\n                              (char*)pKeyInfo, p4type);\n    sqlite3VdbeAddOp3(v, OP_Jump, j2+2, iContinue, j2+2);\n    sqlite3VdbeJumpHere(v, j1);\n    sqlite3ExprCodeCopy(pParse, pIn->iMem, regPrev+1, pIn->nMem);\n    sqlite3VdbeAddOp2(v, OP_Integer, 1, regPrev);\n  }\n  if( pParse->db->mallocFailed ) return 0;\n\n  /* Suppress the the first OFFSET entries if there is an OFFSET clause\n  */\n  codeOffset(v, p, iContinue);\n\n  switch( pDest->eDest ){\n    /* Store the result as data using a unique key.\n    */\n    case SRT_Table:\n    case SRT_EphemTab: {\n      int r1 = sqlite3GetTempReg(pParse);\n      int r2 = sqlite3GetTempReg(pParse);\n      testcase( pDest->eDest==SRT_Table );\n      testcase( pDest->eDest==SRT_EphemTab );\n      sqlite3VdbeAddOp3(v, OP_MakeRecord, pIn->iMem, pIn->nMem, r1);\n      sqlite3VdbeAddOp2(v, OP_NewRowid, pDest->iParm, r2);\n      sqlite3VdbeAddOp3(v, OP_Insert, pDest->iParm, r1, r2);\n      sqlite3VdbeChangeP5(v, OPFLAG_APPEND);\n      sqlite3ReleaseTempReg(pParse, r2);\n      sqlite3ReleaseTempReg(pParse, r1);\n      break;\n    }\n\n#ifndef SQLITE_OMIT_SUBQUERY\n    /* If we are creating a set for an \"expr IN (SELECT ...)\" construct,\n    ** then there should be a single item on the stack.  Write this\n    ** item into the set table with bogus data.\n    */\n    case SRT_Set: {\n      int r1;\n      assert( pIn->nMem==1 );\n      p->affinity = \n         sqlite3CompareAffinity(p->pEList->a[0].pExpr, pDest->affinity);\n      r1 = sqlite3GetTempReg(pParse);\n      sqlite3VdbeAddOp4(v, OP_MakeRecord, pIn->iMem, 1, r1, &p->affinity, 1);\n      sqlite3ExprCacheAffinityChange(pParse, pIn->iMem, 1);\n      sqlite3VdbeAddOp2(v, OP_IdxInsert, pDest->iParm, r1);\n      sqlite3ReleaseTempReg(pParse, r1);\n      break;\n    }\n\n#if 0  /* Never occurs on an ORDER BY query */\n    /* If any row exist in the result set, record that fact and abort.\n    */\n    case SRT_Exists: {\n      sqlite3VdbeAddOp2(v, OP_Integer, 1, pDest->iParm);\n      /* The LIMIT clause will terminate the loop for us */\n      break;\n    }\n#endif\n\n    /* If this is a scalar select that is part of an expression, then\n    ** store the results in the appropriate memory cell and break out\n    ** of the scan loop.\n    */\n    case SRT_Mem: {\n      assert( pIn->nMem==1 );\n      sqlite3ExprCodeMove(pParse, pIn->iMem, pDest->iParm, 1);\n      /* The LIMIT clause will jump out of the loop for us */\n      break;\n    }\n#endif /* #ifndef SQLITE_OMIT_SUBQUERY */\n\n    /* The results are stored in a sequence of registers\n    ** starting at pDest->iMem.  Then the co-routine yields.\n    */\n    case SRT_Coroutine: {\n      if( pDest->iMem==0 ){\n        pDest->iMem = sqlite3GetTempRange(pParse, pIn->nMem);\n        pDest->nMem = pIn->nMem;\n      }\n      sqlite3ExprCodeMove(pParse, pIn->iMem, pDest->iMem, pDest->nMem);\n      sqlite3VdbeAddOp1(v, OP_Yield, pDest->iParm);\n      break;\n    }\n\n    /* If none of the above, then the result destination must be\n    ** SRT_Output.  This routine is never called with any other\n    ** destination other than the ones handled above or SRT_Output.\n    **\n    ** For SRT_Output, results are stored in a sequence of registers.  \n    ** Then the OP_ResultRow opcode is used to cause sqlite3_step() to\n    ** return the next row of result.\n    */\n    default: {\n      assert( pDest->eDest==SRT_Output );\n      sqlite3VdbeAddOp2(v, OP_ResultRow, pIn->iMem, pIn->nMem);\n      sqlite3ExprCacheAffinityChange(pParse, pIn->iMem, pIn->nMem);\n      break;\n    }\n  }\n\n  /* Jump to the end of the loop if the LIMIT is reached.\n  */\n  if( p->iLimit ){\n    sqlite3VdbeAddOp3(v, OP_IfZero, p->iLimit, iBreak, -1);\n  }\n\n  /* Generate the subroutine return\n  */\n  sqlite3VdbeResolveLabel(v, iContinue);\n  sqlite3VdbeAddOp1(v, OP_Return, regReturn);\n\n  return addr;\n}\n\n/*\n** Alternative compound select code generator for cases when there\n** is an ORDER BY clause.\n**\n** We assume a query of the following form:\n**\n**      <selectA>  <operator>  <selectB>  ORDER BY <orderbylist>\n**\n** <operator> is one of UNION ALL, UNION, EXCEPT, or INTERSECT.  The idea\n** is to code both <selectA> and <selectB> with the ORDER BY clause as\n** co-routines.  Then run the co-routines in parallel and merge the results\n** into the output.  In addition to the two coroutines (called selectA and\n** selectB) there are 7 subroutines:\n**\n**    outA:    Move the output of the selectA coroutine into the output\n**             of the compound query.\n**\n**    outB:    Move the output of the selectB coroutine into the output\n**             of the compound query.  (Only generated for UNION and\n**             UNION ALL.  EXCEPT and INSERTSECT never output a row that\n**             appears only in B.)\n**\n**    AltB:    Called when there is data from both coroutines and A<B.\n**\n**    AeqB:    Called when there is data from both coroutines and A==B.\n**\n**    AgtB:    Called when there is data from both coroutines and A>B.\n**\n**    EofA:    Called when data is exhausted from selectA.\n**\n**    EofB:    Called when data is exhausted from selectB.\n**\n** The implementation of the latter five subroutines depend on which \n** <operator> is used:\n**\n**\n**             UNION ALL         UNION            EXCEPT          INTERSECT\n**          -------------  -----------------  --------------  -----------------\n**   AltB:   outA, nextA      outA, nextA       outA, nextA         nextA\n**\n**   AeqB:   outA, nextA         nextA             nextA         outA, nextA\n**\n**   AgtB:   outB, nextB      outB, nextB          nextB            nextB\n**\n**   EofA:   outB, nextB      outB, nextB          halt             halt\n**\n**   EofB:   outA, nextA      outA, nextA       outA, nextA         halt\n**\n** In the AltB, AeqB, and AgtB subroutines, an EOF on A following nextA\n** causes an immediate jump to EofA and an EOF on B following nextB causes\n** an immediate jump to EofB.  Within EofA and EofB, and EOF on entry or\n** following nextX causes a jump to the end of the select processing.\n**\n** Duplicate removal in the UNION, EXCEPT, and INTERSECT cases is handled\n** within the output subroutine.  The regPrev register set holds the previously\n** output value.  A comparison is made against this value and the output\n** is skipped if the next results would be the same as the previous.\n**\n** The implementation plan is to implement the two coroutines and seven\n** subroutines first, then put the control logic at the bottom.  Like this:\n**\n**          goto Init\n**     coA: coroutine for left query (A)\n**     coB: coroutine for right query (B)\n**    outA: output one row of A\n**    outB: output one row of B (UNION and UNION ALL only)\n**    EofA: ...\n**    EofB: ...\n**    AltB: ...\n**    AeqB: ...\n**    AgtB: ...\n**    Init: initialize coroutine registers\n**          yield coA\n**          if eof(A) goto EofA\n**          yield coB\n**          if eof(B) goto EofB\n**    Cmpr: Compare A, B\n**          Jump AltB, AeqB, AgtB\n**     End: ...\n**\n** We call AltB, AeqB, AgtB, EofA, and EofB \"subroutines\" but they are not\n** actually called using Gosub and they do not Return.  EofA and EofB loop\n** until all data is exhausted then jump to the \"end\" labe.  AltB, AeqB,\n** and AgtB jump to either L2 or to one of EofA or EofB.\n*/\n#ifndef SQLITE_OMIT_COMPOUND_SELECT\nstatic int multiSelectOrderBy(\n  Parse *pParse,        /* Parsing context */\n  Select *p,            /* The right-most of SELECTs to be coded */\n  SelectDest *pDest     /* What to do with query results */\n){\n  int i, j;             /* Loop counters */\n  Select *pPrior;       /* Another SELECT immediately to our left */\n  Vdbe *v;              /* Generate code to this VDBE */\n  SelectDest destA;     /* Destination for coroutine A */\n  SelectDest destB;     /* Destination for coroutine B */\n  int regAddrA;         /* Address register for select-A coroutine */\n  int regEofA;          /* Flag to indicate when select-A is complete */\n  int regAddrB;         /* Address register for select-B coroutine */\n  int regEofB;          /* Flag to indicate when select-B is complete */\n  int addrSelectA;      /* Address of the select-A coroutine */\n  int addrSelectB;      /* Address of the select-B coroutine */\n  int regOutA;          /* Address register for the output-A subroutine */\n  int regOutB;          /* Address register for the output-B subroutine */\n  int addrOutA;         /* Address of the output-A subroutine */\n  int addrOutB = 0;     /* Address of the output-B subroutine */\n  int addrEofA;         /* Address of the select-A-exhausted subroutine */\n  int addrEofB;         /* Address of the select-B-exhausted subroutine */\n  int addrAltB;         /* Address of the A<B subroutine */\n  int addrAeqB;         /* Address of the A==B subroutine */\n  int addrAgtB;         /* Address of the A>B subroutine */\n  int regLimitA;        /* Limit register for select-A */\n  int regLimitB;        /* Limit register for select-A */\n  int regPrev;          /* A range of registers to hold previous output */\n  int savedLimit;       /* Saved value of p->iLimit */\n  int savedOffset;      /* Saved value of p->iOffset */\n  int labelCmpr;        /* Label for the start of the merge algorithm */\n  int labelEnd;         /* Label for the end of the overall SELECT stmt */\n  int j1;               /* Jump instructions that get retargetted */\n  int op;               /* One of TK_ALL, TK_UNION, TK_EXCEPT, TK_INTERSECT */\n  KeyInfo *pKeyDup = 0; /* Comparison information for duplicate removal */\n  KeyInfo *pKeyMerge;   /* Comparison information for merging rows */\n  sqlite3 *db;          /* Database connection */\n  ExprList *pOrderBy;   /* The ORDER BY clause */\n  int nOrderBy;         /* Number of terms in the ORDER BY clause */\n  int *aPermute;        /* Mapping from ORDER BY terms to result set columns */\n#ifndef SQLITE_OMIT_EXPLAIN\n  int iSub1;            /* EQP id of left-hand query */\n  int iSub2;            /* EQP id of right-hand query */\n#endif\n\n  assert( p->pOrderBy!=0 );\n  assert( pKeyDup==0 ); /* \"Managed\" code needs this.  Ticket #3382. */\n  db = pParse->db;\n  v = pParse->pVdbe;\n  assert( v!=0 );       /* Already thrown the error if VDBE alloc failed */\n  labelEnd = sqlite3VdbeMakeLabel(v);\n  labelCmpr = sqlite3VdbeMakeLabel(v);\n\n\n  /* Patch up the ORDER BY clause\n  */\n  op = p->op;  \n  pPrior = p->pPrior;\n  assert( pPrior->pOrderBy==0 );\n  pOrderBy = p->pOrderBy;\n  assert( pOrderBy );\n  nOrderBy = pOrderBy->nExpr;\n\n  /* For operators other than UNION ALL we have to make sure that\n  ** the ORDER BY clause covers every term of the result set.  Add\n  ** terms to the ORDER BY clause as necessary.\n  */\n  if( op!=TK_ALL ){\n    for(i=1; db->mallocFailed==0 && i<=p->pEList->nExpr; i++){\n      struct ExprList_item *pItem;\n      for(j=0, pItem=pOrderBy->a; j<nOrderBy; j++, pItem++){\n        assert( pItem->iCol>0 );\n        if( pItem->iCol==i ) break;\n      }\n      if( j==nOrderBy ){\n        Expr *pNew = sqlite3Expr(db, TK_INTEGER, 0);\n        if( pNew==0 ) return SQLITE_NOMEM;\n        pNew->flags |= EP_IntValue;\n        pNew->u.iValue = i;\n        pOrderBy = sqlite3ExprListAppend(pParse, pOrderBy, pNew);\n        pOrderBy->a[nOrderBy++].iCol = (u16)i;\n      }\n    }\n  }\n\n  /* Compute the comparison permutation and keyinfo that is used with\n  ** the permutation used to determine if the next\n  ** row of results comes from selectA or selectB.  Also add explicit\n  ** collations to the ORDER BY clause terms so that when the subqueries\n  ** to the right and the left are evaluated, they use the correct\n  ** collation.\n  */\n  aPermute = sqlite3DbMallocRaw(db, sizeof(int)*nOrderBy);\n  if( aPermute ){\n    struct ExprList_item *pItem;\n    for(i=0, pItem=pOrderBy->a; i<nOrderBy; i++, pItem++){\n      assert( pItem->iCol>0  && pItem->iCol<=p->pEList->nExpr );\n      aPermute[i] = pItem->iCol - 1;\n    }\n    pKeyMerge =\n      sqlite3DbMallocRaw(db, sizeof(*pKeyMerge)+nOrderBy*(sizeof(CollSeq*)+1));\n    if( pKeyMerge ){\n      pKeyMerge->aSortOrder = (u8*)&pKeyMerge->aColl[nOrderBy];\n      pKeyMerge->nField = (u16)nOrderBy;\n      pKeyMerge->enc = ENC(db);\n      for(i=0; i<nOrderBy; i++){\n        CollSeq *pColl;\n        Expr *pTerm = pOrderBy->a[i].pExpr;\n        if( pTerm->flags & EP_ExpCollate ){\n          pColl = pTerm->pColl;\n        }else{\n          pColl = multiSelectCollSeq(pParse, p, aPermute[i]);\n          pTerm->flags |= EP_ExpCollate;\n          pTerm->pColl = pColl;\n        }\n        pKeyMerge->aColl[i] = pColl;\n        pKeyMerge->aSortOrder[i] = pOrderBy->a[i].sortOrder;\n      }\n    }\n  }else{\n    pKeyMerge = 0;\n  }\n\n  /* Reattach the ORDER BY clause to the query.\n  */\n  p->pOrderBy = pOrderBy;\n  pPrior->pOrderBy = sqlite3ExprListDup(pParse->db, pOrderBy, 0);\n\n  /* Allocate a range of temporary registers and the KeyInfo needed\n  ** for the logic that removes duplicate result rows when the\n  ** operator is UNION, EXCEPT, or INTERSECT (but not UNION ALL).\n  */\n  if( op==TK_ALL ){\n    regPrev = 0;\n  }else{\n    int nExpr = p->pEList->nExpr;\n    assert( nOrderBy>=nExpr || db->mallocFailed );\n    regPrev = sqlite3GetTempRange(pParse, nExpr+1);\n    sqlite3VdbeAddOp2(v, OP_Integer, 0, regPrev);\n    pKeyDup = sqlite3DbMallocZero(db,\n                  sizeof(*pKeyDup) + nExpr*(sizeof(CollSeq*)+1) );\n    if( pKeyDup ){\n      pKeyDup->aSortOrder = (u8*)&pKeyDup->aColl[nExpr];\n      pKeyDup->nField = (u16)nExpr;\n      pKeyDup->enc = ENC(db);\n      for(i=0; i<nExpr; i++){\n        pKeyDup->aColl[i] = multiSelectCollSeq(pParse, p, i);\n        pKeyDup->aSortOrder[i] = 0;\n      }\n    }\n  }\n \n  /* Separate the left and the right query from one another\n  */\n  p->pPrior = 0;\n  sqlite3ResolveOrderGroupBy(pParse, p, p->pOrderBy, \"ORDER\");\n  if( pPrior->pPrior==0 ){\n    sqlite3ResolveOrderGroupBy(pParse, pPrior, pPrior->pOrderBy, \"ORDER\");\n  }\n\n  /* Compute the limit registers */\n  computeLimitRegisters(pParse, p, labelEnd);\n  if( p->iLimit && op==TK_ALL ){\n    regLimitA = ++pParse->nMem;\n    regLimitB = ++pParse->nMem;\n    sqlite3VdbeAddOp2(v, OP_Copy, p->iOffset ? p->iOffset+1 : p->iLimit,\n                                  regLimitA);\n    sqlite3VdbeAddOp2(v, OP_Copy, regLimitA, regLimitB);\n  }else{\n    regLimitA = regLimitB = 0;\n  }\n  sqlite3ExprDelete(db, p->pLimit);\n  p->pLimit = 0;\n  sqlite3ExprDelete(db, p->pOffset);\n  p->pOffset = 0;\n\n  regAddrA = ++pParse->nMem;\n  regEofA = ++pParse->nMem;\n  regAddrB = ++pParse->nMem;\n  regEofB = ++pParse->nMem;\n  regOutA = ++pParse->nMem;\n  regOutB = ++pParse->nMem;\n  sqlite3SelectDestInit(&destA, SRT_Coroutine, regAddrA);\n  sqlite3SelectDestInit(&destB, SRT_Coroutine, regAddrB);\n\n  /* Jump past the various subroutines and coroutines to the main\n  ** merge loop\n  */\n  j1 = sqlite3VdbeAddOp0(v, OP_Goto);\n  addrSelectA = sqlite3VdbeCurrentAddr(v);\n\n\n  /* Generate a coroutine to evaluate the SELECT statement to the\n  ** left of the compound operator - the \"A\" select.\n  */\n  VdbeNoopComment((v, \"Begin coroutine for left SELECT\"));\n  pPrior->iLimit = regLimitA;\n  explainSetInteger(iSub1, pParse->iNextSelectId);\n  sqlite3Select(pParse, pPrior, &destA);\n  sqlite3VdbeAddOp2(v, OP_Integer, 1, regEofA);\n  sqlite3VdbeAddOp1(v, OP_Yield, regAddrA);\n  VdbeNoopComment((v, \"End coroutine for left SELECT\"));\n\n  /* Generate a coroutine to evaluate the SELECT statement on \n  ** the right - the \"B\" select\n  */\n  addrSelectB = sqlite3VdbeCurrentAddr(v);\n  VdbeNoopComment((v, \"Begin coroutine for right SELECT\"));\n  savedLimit = p->iLimit;\n  savedOffset = p->iOffset;\n  p->iLimit = regLimitB;\n  p->iOffset = 0;  \n  explainSetInteger(iSub2, pParse->iNextSelectId);\n  sqlite3Select(pParse, p, &destB);\n  p->iLimit = savedLimit;\n  p->iOffset = savedOffset;\n  sqlite3VdbeAddOp2(v, OP_Integer, 1, regEofB);\n  sqlite3VdbeAddOp1(v, OP_Yield, regAddrB);\n  VdbeNoopComment((v, \"End coroutine for right SELECT\"));\n\n  /* Generate a subroutine that outputs the current row of the A\n  ** select as the next output row of the compound select.\n  */\n  VdbeNoopComment((v, \"Output routine for A\"));\n  addrOutA = generateOutputSubroutine(pParse,\n                 p, &destA, pDest, regOutA,\n                 regPrev, pKeyDup, P4_KEYINFO_HANDOFF, labelEnd);\n  \n  /* Generate a subroutine that outputs the current row of the B\n  ** select as the next output row of the compound select.\n  */\n  if( op==TK_ALL || op==TK_UNION ){\n    VdbeNoopComment((v, \"Output routine for B\"));\n    addrOutB = generateOutputSubroutine(pParse,\n                 p, &destB, pDest, regOutB,\n                 regPrev, pKeyDup, P4_KEYINFO_STATIC, labelEnd);\n  }\n\n  /* Generate a subroutine to run when the results from select A\n  ** are exhausted and only data in select B remains.\n  */\n  VdbeNoopComment((v, \"eof-A subroutine\"));\n  if( op==TK_EXCEPT || op==TK_INTERSECT ){\n    addrEofA = sqlite3VdbeAddOp2(v, OP_Goto, 0, labelEnd);\n  }else{  \n    addrEofA = sqlite3VdbeAddOp2(v, OP_If, regEofB, labelEnd);\n    sqlite3VdbeAddOp2(v, OP_Gosub, regOutB, addrOutB);\n    sqlite3VdbeAddOp1(v, OP_Yield, regAddrB);\n    sqlite3VdbeAddOp2(v, OP_Goto, 0, addrEofA);\n    p->nSelectRow += pPrior->nSelectRow;\n  }\n\n  /* Generate a subroutine to run when the results from select B\n  ** are exhausted and only data in select A remains.\n  */\n  if( op==TK_INTERSECT ){\n    addrEofB = addrEofA;\n    if( p->nSelectRow > pPrior->nSelectRow ) p->nSelectRow = pPrior->nSelectRow;\n  }else{  \n    VdbeNoopComment((v, \"eof-B subroutine\"));\n    addrEofB = sqlite3VdbeAddOp2(v, OP_If, regEofA, labelEnd);\n    sqlite3VdbeAddOp2(v, OP_Gosub, regOutA, addrOutA);\n    sqlite3VdbeAddOp1(v, OP_Yield, regAddrA);\n    sqlite3VdbeAddOp2(v, OP_Goto, 0, addrEofB);\n  }\n\n  /* Generate code to handle the case of A<B\n  */\n  VdbeNoopComment((v, \"A-lt-B subroutine\"));\n  addrAltB = sqlite3VdbeAddOp2(v, OP_Gosub, regOutA, addrOutA);\n  sqlite3VdbeAddOp1(v, OP_Yield, regAddrA);\n  sqlite3VdbeAddOp2(v, OP_If, regEofA, addrEofA);\n  sqlite3VdbeAddOp2(v, OP_Goto, 0, labelCmpr);\n\n  /* Generate code to handle the case of A==B\n  */\n  if( op==TK_ALL ){\n    addrAeqB = addrAltB;\n  }else if( op==TK_INTERSECT ){\n    addrAeqB = addrAltB;\n    addrAltB++;\n  }else{\n    VdbeNoopComment((v, \"A-eq-B subroutine\"));\n    addrAeqB =\n    sqlite3VdbeAddOp1(v, OP_Yield, regAddrA);\n    sqlite3VdbeAddOp2(v, OP_If, regEofA, addrEofA);\n    sqlite3VdbeAddOp2(v, OP_Goto, 0, labelCmpr);\n  }\n\n  /* Generate code to handle the case of A>B\n  */\n  VdbeNoopComment((v, \"A-gt-B subroutine\"));\n  addrAgtB = sqlite3VdbeCurrentAddr(v);\n  if( op==TK_ALL || op==TK_UNION ){\n    sqlite3VdbeAddOp2(v, OP_Gosub, regOutB, addrOutB);\n  }\n  sqlite3VdbeAddOp1(v, OP_Yield, regAddrB);\n  sqlite3VdbeAddOp2(v, OP_If, regEofB, addrEofB);\n  sqlite3VdbeAddOp2(v, OP_Goto, 0, labelCmpr);\n\n  /* This code runs once to initialize everything.\n  */\n  sqlite3VdbeJumpHere(v, j1);\n  sqlite3VdbeAddOp2(v, OP_Integer, 0, regEofA);\n  sqlite3VdbeAddOp2(v, OP_Integer, 0, regEofB);\n  sqlite3VdbeAddOp2(v, OP_Gosub, regAddrA, addrSelectA);\n  sqlite3VdbeAddOp2(v, OP_Gosub, regAddrB, addrSelectB);\n  sqlite3VdbeAddOp2(v, OP_If, regEofA, addrEofA);\n  sqlite3VdbeAddOp2(v, OP_If, regEofB, addrEofB);\n\n  /* Implement the main merge loop\n  */\n  sqlite3VdbeResolveLabel(v, labelCmpr);\n  sqlite3VdbeAddOp4(v, OP_Permutation, 0, 0, 0, (char*)aPermute, P4_INTARRAY);\n  sqlite3VdbeAddOp4(v, OP_Compare, destA.iMem, destB.iMem, nOrderBy,\n                         (char*)pKeyMerge, P4_KEYINFO_HANDOFF);\n  sqlite3VdbeAddOp3(v, OP_Jump, addrAltB, addrAeqB, addrAgtB);\n\n  /* Release temporary registers\n  */\n  if( regPrev ){\n    sqlite3ReleaseTempRange(pParse, regPrev, nOrderBy+1);\n  }\n\n  /* Jump to the this point in order to terminate the query.\n  */\n  sqlite3VdbeResolveLabel(v, labelEnd);\n\n  /* Set the number of output columns\n  */\n  if( pDest->eDest==SRT_Output ){\n    Select *pFirst = pPrior;\n    while( pFirst->pPrior ) pFirst = pFirst->pPrior;\n    generateColumnNames(pParse, 0, pFirst->pEList);\n  }\n\n  /* Reassembly the compound query so that it will be freed correctly\n  ** by the calling function */\n  if( p->pPrior ){\n    sqlite3SelectDelete(db, p->pPrior);\n  }\n  p->pPrior = pPrior;\n\n  /*** TBD:  Insert subroutine calls to close cursors on incomplete\n  **** subqueries ****/\n  explainComposite(pParse, p->op, iSub1, iSub2, 0);\n  return SQLITE_OK;\n}\n#endif\n\n#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)\n/* Forward Declarations */\nstatic void substExprList(sqlite3*, ExprList*, int, ExprList*);\nstatic void substSelect(sqlite3*, Select *, int, ExprList *);\n\n/*\n** Scan through the expression pExpr.  Replace every reference to\n** a column in table number iTable with a copy of the iColumn-th\n** entry in pEList.  (But leave references to the ROWID column \n** unchanged.)\n**\n** This routine is part of the flattening procedure.  A subquery\n** whose result set is defined by pEList appears as entry in the\n** FROM clause of a SELECT such that the VDBE cursor assigned to that\n** FORM clause entry is iTable.  This routine make the necessary \n** changes to pExpr so that it refers directly to the source table\n** of the subquery rather the result set of the subquery.\n*/\nstatic Expr *substExpr(\n  sqlite3 *db,        /* Report malloc errors to this connection */\n  Expr *pExpr,        /* Expr in which substitution occurs */\n  int iTable,         /* Table to be substituted */\n  ExprList *pEList    /* Substitute expressions */\n){\n  if( pExpr==0 ) return 0;\n  if( pExpr->op==TK_COLUMN && pExpr->iTable==iTable ){\n    if( pExpr->iColumn<0 ){\n      pExpr->op = TK_NULL;\n    }else{\n      Expr *pNew;\n      assert( pEList!=0 && pExpr->iColumn<pEList->nExpr );\n      assert( pExpr->pLeft==0 && pExpr->pRight==0 );\n      pNew = sqlite3ExprDup(db, pEList->a[pExpr->iColumn].pExpr, 0);\n      if( pNew && pExpr->pColl ){\n        pNew->pColl = pExpr->pColl;\n      }\n      sqlite3ExprDelete(db, pExpr);\n      pExpr = pNew;\n    }\n  }else{\n    pExpr->pLeft = substExpr(db, pExpr->pLeft, iTable, pEList);\n    pExpr->pRight = substExpr(db, pExpr->pRight, iTable, pEList);\n    if( ExprHasProperty(pExpr, EP_xIsSelect) ){\n      substSelect(db, pExpr->x.pSelect, iTable, pEList);\n    }else{\n      substExprList(db, pExpr->x.pList, iTable, pEList);\n    }\n  }\n  return pExpr;\n}\nstatic void substExprList(\n  sqlite3 *db,         /* Report malloc errors here */\n  ExprList *pList,     /* List to scan and in which to make substitutes */\n  int iTable,          /* Table to be substituted */\n  ExprList *pEList     /* Substitute values */\n){\n  int i;\n  if( pList==0 ) return;\n  for(i=0; i<pList->nExpr; i++){\n    pList->a[i].pExpr = substExpr(db, pList->a[i].pExpr, iTable, pEList);\n  }\n}\nstatic void substSelect(\n  sqlite3 *db,         /* Report malloc errors here */\n  Select *p,           /* SELECT statement in which to make substitutions */\n  int iTable,          /* Table to be replaced */\n  ExprList *pEList     /* Substitute values */\n){\n  SrcList *pSrc;\n  struct SrcList_item *pItem;\n  int i;\n  if( !p ) return;\n  substExprList(db, p->pEList, iTable, pEList);\n  substExprList(db, p->pGroupBy, iTable, pEList);\n  substExprList(db, p->pOrderBy, iTable, pEList);\n  p->pHaving = substExpr(db, p->pHaving, iTable, pEList);\n  p->pWhere = substExpr(db, p->pWhere, iTable, pEList);\n  substSelect(db, p->pPrior, iTable, pEList);\n  pSrc = p->pSrc;\n  assert( pSrc );  /* Even for (SELECT 1) we have: pSrc!=0 but pSrc->nSrc==0 */\n  if( ALWAYS(pSrc) ){\n    for(i=pSrc->nSrc, pItem=pSrc->a; i>0; i--, pItem++){\n      substSelect(db, pItem->pSelect, iTable, pEList);\n    }\n  }\n}\n#endif /* !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW) */\n\n#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)\n/*\n** This routine attempts to flatten subqueries in order to speed\n** execution.  It returns 1 if it makes changes and 0 if no flattening\n** occurs.\n**\n** To understand the concept of flattening, consider the following\n** query:\n**\n**     SELECT a FROM (SELECT x+y AS a FROM t1 WHERE z<100) WHERE a>5\n**\n** The default way of implementing this query is to execute the\n** subquery first and store the results in a temporary table, then\n** run the outer query on that temporary table.  This requires two\n** passes over the data.  Furthermore, because the temporary table\n** has no indices, the WHERE clause on the outer query cannot be\n** optimized.\n**\n** This routine attempts to rewrite queries such as the above into\n** a single flat select, like this:\n**\n**     SELECT x+y AS a FROM t1 WHERE z<100 AND a>5\n**\n** The code generated for this simpification gives the same result\n** but only has to scan the data once.  And because indices might \n** exist on the table t1, a complete scan of the data might be\n** avoided.\n**\n** Flattening is only attempted if all of the following are true:\n**\n**   (1)  The subquery and the outer query do not both use aggregates.\n**\n**   (2)  The subquery is not an aggregate or the outer query is not a join.\n**\n**   (3)  The subquery is not the right operand of a left outer join\n**        (Originally ticket #306.  Strengthened by ticket #3300)\n**\n**   (4)  The subquery is not DISTINCT.\n**\n**  (**)  At one point restrictions (4) and (5) defined a subset of DISTINCT\n**        sub-queries that were excluded from this optimization. Restriction \n**        (4) has since been expanded to exclude all DISTINCT subqueries.\n**\n**   (6)  The subquery does not use aggregates or the outer query is not\n**        DISTINCT.\n**\n**   (7)  The subquery has a FROM clause.\n**\n**   (8)  The subquery does not use LIMIT or the outer query is not a join.\n**\n**   (9)  The subquery does not use LIMIT or the outer query does not use\n**        aggregates.\n**\n**  (10)  The subquery does not use aggregates or the outer query does not\n**        use LIMIT.\n**\n**  (11)  The subquery and the outer query do not both have ORDER BY clauses.\n**\n**  (**)  Not implemented.  Subsumed into restriction (3).  Was previously\n**        a separate restriction deriving from ticket #350.\n**\n**  (13)  The subquery and outer query do not both use LIMIT.\n**\n**  (14)  The subquery does not use OFFSET.\n**\n**  (15)  The outer query is not part of a compound select or the\n**        subquery does not have a LIMIT clause.\n**        (See ticket #2339 and ticket [02a8e81d44]).\n**\n**  (16)  The outer query is not an aggregate or the subquery does\n**        not contain ORDER BY.  (Ticket #2942)  This used to not matter\n**        until we introduced the group_concat() function.  \n**\n**  (17)  The sub-query is not a compound select, or it is a UNION ALL \n**        compound clause made up entirely of non-aggregate queries, and \n**        the parent query:\n**\n**          * is not itself part of a compound select,\n**          * is not an aggregate or DISTINCT query, and\n**          * has no other tables or sub-selects in the FROM clause.\n**\n**        The parent and sub-query may contain WHERE clauses. Subject to\n**        rules (11), (13) and (14), they may also contain ORDER BY,\n**        LIMIT and OFFSET clauses.\n**\n**  (18)  If the sub-query is a compound select, then all terms of the\n**        ORDER by clause of the parent must be simple references to \n**        columns of the sub-query.\n**\n**  (19)  The subquery does not use LIMIT or the outer query does not\n**        have a WHERE clause.\n**\n**  (20)  If the sub-query is a compound select, then it must not use\n**        an ORDER BY clause.  Ticket #3773.  We could relax this constraint\n**        somewhat by saying that the terms of the ORDER BY clause must\n**        appear as unmodified result columns in the outer query.  But\n**        have other optimizations in mind to deal with that case.\n**\n**  (21)  The subquery does not use LIMIT or the outer query is not\n**        DISTINCT.  (See ticket [752e1646fc]).\n**\n** In this routine, the \"p\" parameter is a pointer to the outer query.\n** The subquery is p->pSrc->a[iFrom].  isAgg is true if the outer query\n** uses aggregates and subqueryIsAgg is true if the subquery uses aggregates.\n**\n** If flattening is not attempted, this routine is a no-op and returns 0.\n** If flattening is attempted this routine returns 1.\n**\n** All of the expression analysis must occur on both the outer query and\n** the subquery before this routine runs.\n*/\nstatic int flattenSubquery(\n  Parse *pParse,       /* Parsing context */\n  Select *p,           /* The parent or outer SELECT statement */\n  int iFrom,           /* Index in p->pSrc->a[] of the inner subquery */\n  int isAgg,           /* True if outer SELECT uses aggregate functions */\n  int subqueryIsAgg    /* True if the subquery uses aggregate functions */\n){\n  const char *zSavedAuthContext = pParse->zAuthContext;\n  Select *pParent;\n  Select *pSub;       /* The inner query or \"subquery\" */\n  Select *pSub1;      /* Pointer to the rightmost select in sub-query */\n  SrcList *pSrc;      /* The FROM clause of the outer query */\n  SrcList *pSubSrc;   /* The FROM clause of the subquery */\n  ExprList *pList;    /* The result set of the outer query */\n  int iParent;        /* VDBE cursor number of the pSub result set temp table */\n  int i;              /* Loop counter */\n  Expr *pWhere;                    /* The WHERE clause */\n  struct SrcList_item *pSubitem;   /* The subquery */\n  sqlite3 *db = pParse->db;\n\n  /* Check to see if flattening is permitted.  Return 0 if not.\n  */\n  assert( p!=0 );\n  assert( p->pPrior==0 );  /* Unable to flatten compound queries */\n  if( db->flags & SQLITE_QueryFlattener ) return 0;\n  pSrc = p->pSrc;\n  assert( pSrc && iFrom>=0 && iFrom<pSrc->nSrc );\n  pSubitem = &pSrc->a[iFrom];\n  iParent = pSubitem->iCursor;\n  pSub = pSubitem->pSelect;\n  assert( pSub!=0 );\n  if( isAgg && subqueryIsAgg ) return 0;                 /* Restriction (1)  */\n  if( subqueryIsAgg && pSrc->nSrc>1 ) return 0;          /* Restriction (2)  */\n  pSubSrc = pSub->pSrc;\n  assert( pSubSrc );\n  /* Prior to version 3.1.2, when LIMIT and OFFSET had to be simple constants,\n  ** not arbitrary expresssions, we allowed some combining of LIMIT and OFFSET\n  ** because they could be computed at compile-time.  But when LIMIT and OFFSET\n  ** became arbitrary expressions, we were forced to add restrictions (13)\n  ** and (14). */\n  if( pSub->pLimit && p->pLimit ) return 0;              /* Restriction (13) */\n  if( pSub->pOffset ) return 0;                          /* Restriction (14) */\n  if( p->pRightmost && pSub->pLimit ){\n    return 0;                                            /* Restriction (15) */\n  }\n  if( pSubSrc->nSrc==0 ) return 0;                       /* Restriction (7)  */\n  if( pSub->selFlags & SF_Distinct ) return 0;           /* Restriction (5)  */\n  if( pSub->pLimit && (pSrc->nSrc>1 || isAgg) ){\n     return 0;         /* Restrictions (8)(9) */\n  }\n  if( (p->selFlags & SF_Distinct)!=0 && subqueryIsAgg ){\n     return 0;         /* Restriction (6)  */\n  }\n  if( p->pOrderBy && pSub->pOrderBy ){\n     return 0;                                           /* Restriction (11) */\n  }\n  if( isAgg && pSub->pOrderBy ) return 0;                /* Restriction (16) */\n  if( pSub->pLimit && p->pWhere ) return 0;              /* Restriction (19) */\n  if( pSub->pLimit && (p->selFlags & SF_Distinct)!=0 ){\n     return 0;         /* Restriction (21) */\n  }\n\n  /* OBSOLETE COMMENT 1:\n  ** Restriction 3:  If the subquery is a join, make sure the subquery is \n  ** not used as the right operand of an outer join.  Examples of why this\n  ** is not allowed:\n  **\n  **         t1 LEFT OUTER JOIN (t2 JOIN t3)\n  **\n  ** If we flatten the above, we would get\n  **\n  **         (t1 LEFT OUTER JOIN t2) JOIN t3\n  **\n  ** which is not at all the same thing.\n  **\n  ** OBSOLETE COMMENT 2:\n  ** Restriction 12:  If the subquery is the right operand of a left outer\n  ** join, make sure the subquery has no WHERE clause.\n  ** An examples of why this is not allowed:\n  **\n  **         t1 LEFT OUTER JOIN (SELECT * FROM t2 WHERE t2.x>0)\n  **\n  ** If we flatten the above, we would get\n  **\n  **         (t1 LEFT OUTER JOIN t2) WHERE t2.x>0\n  **\n  ** But the t2.x>0 test will always fail on a NULL row of t2, which\n  ** effectively converts the OUTER JOIN into an INNER JOIN.\n  **\n  ** THIS OVERRIDES OBSOLETE COMMENTS 1 AND 2 ABOVE:\n  ** Ticket #3300 shows that flattening the right term of a LEFT JOIN\n  ** is fraught with danger.  Best to avoid the whole thing.  If the\n  ** subquery is the right term of a LEFT JOIN, then do not flatten.\n  */\n  if( (pSubitem->jointype & JT_OUTER)!=0 ){\n    return 0;\n  }\n\n  /* Restriction 17: If the sub-query is a compound SELECT, then it must\n  ** use only the UNION ALL operator. And none of the simple select queries\n  ** that make up the compound SELECT are allowed to be aggregate or distinct\n  ** queries.\n  */\n  if( pSub->pPrior ){\n    if( pSub->pOrderBy ){\n      return 0;  /* Restriction 20 */\n    }\n    if( isAgg || (p->selFlags & SF_Distinct)!=0 || pSrc->nSrc!=1 ){\n      return 0;\n    }\n    for(pSub1=pSub; pSub1; pSub1=pSub1->pPrior){\n      testcase( (pSub1->selFlags & (SF_Distinct|SF_Aggregate))==SF_Distinct );\n      testcase( (pSub1->selFlags & (SF_Distinct|SF_Aggregate))==SF_Aggregate );\n      if( (pSub1->selFlags & (SF_Distinct|SF_Aggregate))!=0\n       || (pSub1->pPrior && pSub1->op!=TK_ALL) \n       || NEVER(pSub1->pSrc==0) || pSub1->pSrc->nSrc!=1\n      ){\n        return 0;\n      }\n    }\n\n    /* Restriction 18. */\n    if( p->pOrderBy ){\n      int ii;\n      for(ii=0; ii<p->pOrderBy->nExpr; ii++){\n        if( p->pOrderBy->a[ii].iCol==0 ) return 0;\n      }\n    }\n  }\n\n  /***** If we reach this point, flattening is permitted. *****/\n\n  /* Authorize the subquery */\n  pParse->zAuthContext = pSubitem->zName;\n  sqlite3AuthCheck(pParse, SQLITE_SELECT, 0, 0, 0);\n  pParse->zAuthContext = zSavedAuthContext;\n\n  /* If the sub-query is a compound SELECT statement, then (by restrictions\n  ** 17 and 18 above) it must be a UNION ALL and the parent query must \n  ** be of the form:\n  **\n  **     SELECT <expr-list> FROM (<sub-query>) <where-clause> \n  **\n  ** followed by any ORDER BY, LIMIT and/or OFFSET clauses. This block\n  ** creates N-1 copies of the parent query without any ORDER BY, LIMIT or \n  ** OFFSET clauses and joins them to the left-hand-side of the original\n  ** using UNION ALL operators. In this case N is the number of simple\n  ** select statements in the compound sub-query.\n  **\n  ** Example:\n  **\n  **     SELECT a+1 FROM (\n  **        SELECT x FROM tab\n  **        UNION ALL\n  **        SELECT y FROM tab\n  **        UNION ALL\n  **        SELECT abs(z*2) FROM tab2\n  **     ) WHERE a!=5 ORDER BY 1\n  **\n  ** Transformed into:\n  **\n  **     SELECT x+1 FROM tab WHERE x+1!=5\n  **     UNION ALL\n  **     SELECT y+1 FROM tab WHERE y+1!=5\n  **     UNION ALL\n  **     SELECT abs(z*2)+1 FROM tab2 WHERE abs(z*2)+1!=5\n  **     ORDER BY 1\n  **\n  ** We call this the \"compound-subquery flattening\".\n  */\n  for(pSub=pSub->pPrior; pSub; pSub=pSub->pPrior){\n    Select *pNew;\n    ExprList *pOrderBy = p->pOrderBy;\n    Expr *pLimit = p->pLimit;\n    Select *pPrior = p->pPrior;\n    p->pOrderBy = 0;\n    p->pSrc = 0;\n    p->pPrior = 0;\n    p->pLimit = 0;\n    pNew = sqlite3SelectDup(db, p, 0);\n    p->pLimit = pLimit;\n    p->pOrderBy = pOrderBy;\n    p->pSrc = pSrc;\n    p->op = TK_ALL;\n    p->pRightmost = 0;\n    if( pNew==0 ){\n      pNew = pPrior;\n    }else{\n      pNew->pPrior = pPrior;\n      pNew->pRightmost = 0;\n    }\n    p->pPrior = pNew;\n    if( db->mallocFailed ) return 1;\n  }\n\n  /* Begin flattening the iFrom-th entry of the FROM clause \n  ** in the outer query.\n  */\n  pSub = pSub1 = pSubitem->pSelect;\n\n  /* Delete the transient table structure associated with the\n  ** subquery\n  */\n  sqlite3DbFree(db, pSubitem->zDatabase);\n  sqlite3DbFree(db, pSubitem->zName);\n  sqlite3DbFree(db, pSubitem->zAlias);\n  pSubitem->zDatabase = 0;\n  pSubitem->zName = 0;\n  pSubitem->zAlias = 0;\n  pSubitem->pSelect = 0;\n\n  /* Defer deleting the Table object associated with the\n  ** subquery until code generation is\n  ** complete, since there may still exist Expr.pTab entries that\n  ** refer to the subquery even after flattening.  Ticket #3346.\n  **\n  ** pSubitem->pTab is always non-NULL by test restrictions and tests above.\n  */\n  if( ALWAYS(pSubitem->pTab!=0) ){\n    Table *pTabToDel = pSubitem->pTab;\n    if( pTabToDel->nRef==1 ){\n      Parse *pToplevel = sqlite3ParseToplevel(pParse);\n      pTabToDel->pNextZombie = pToplevel->pZombieTab;\n      pToplevel->pZombieTab = pTabToDel;\n    }else{\n      pTabToDel->nRef--;\n    }\n    pSubitem->pTab = 0;\n  }\n\n  /* The following loop runs once for each term in a compound-subquery\n  ** flattening (as described above).  If we are doing a different kind\n  ** of flattening - a flattening other than a compound-subquery flattening -\n  ** then this loop only runs once.\n  **\n  ** This loop moves all of the FROM elements of the subquery into the\n  ** the FROM clause of the outer query.  Before doing this, remember\n  ** the cursor number for the original outer query FROM element in\n  ** iParent.  The iParent cursor will never be used.  Subsequent code\n  ** will scan expressions looking for iParent references and replace\n  ** those references with expressions that resolve to the subquery FROM\n  ** elements we are now copying in.\n  */\n  for(pParent=p; pParent; pParent=pParent->pPrior, pSub=pSub->pPrior){\n    int nSubSrc;\n    u8 jointype = 0;\n    pSubSrc = pSub->pSrc;     /* FROM clause of subquery */\n    nSubSrc = pSubSrc->nSrc;  /* Number of terms in subquery FROM clause */\n    pSrc = pParent->pSrc;     /* FROM clause of the outer query */\n\n    if( pSrc ){\n      assert( pParent==p );  /* First time through the loop */\n      jointype = pSubitem->jointype;\n    }else{\n      assert( pParent!=p );  /* 2nd and subsequent times through the loop */\n      pSrc = pParent->pSrc = sqlite3SrcListAppend(db, 0, 0, 0);\n      if( pSrc==0 ){\n        assert( db->mallocFailed );\n        break;\n      }\n    }\n\n    /* The subquery uses a single slot of the FROM clause of the outer\n    ** query.  If the subquery has more than one element in its FROM clause,\n    ** then expand the outer query to make space for it to hold all elements\n    ** of the subquery.\n    **\n    ** Example:\n    **\n    **    SELECT * FROM tabA, (SELECT * FROM sub1, sub2), tabB;\n    **\n    ** The outer query has 3 slots in its FROM clause.  One slot of the\n    ** outer query (the middle slot) is used by the subquery.  The next\n    ** block of code will expand the out query to 4 slots.  The middle\n    ** slot is expanded to two slots in order to make space for the\n    ** two elements in the FROM clause of the subquery.\n    */\n    if( nSubSrc>1 ){\n      pParent->pSrc = pSrc = sqlite3SrcListEnlarge(db, pSrc, nSubSrc-1,iFrom+1);\n      if( db->mallocFailed ){\n        break;\n      }\n    }\n\n    /* Transfer the FROM clause terms from the subquery into the\n    ** outer query.\n    */\n    for(i=0; i<nSubSrc; i++){\n      sqlite3IdListDelete(db, pSrc->a[i+iFrom].pUsing);\n      pSrc->a[i+iFrom] = pSubSrc->a[i];\n      memset(&pSubSrc->a[i], 0, sizeof(pSubSrc->a[i]));\n    }\n    pSrc->a[iFrom].jointype = jointype;\n  \n    /* Now begin substituting subquery result set expressions for \n    ** references to the iParent in the outer query.\n    ** \n    ** Example:\n    **\n    **   SELECT a+5, b*10 FROM (SELECT x*3 AS a, y+10 AS b FROM t1) WHERE a>b;\n    **   \\                     \\_____________ subquery __________/          /\n    **    \\_____________________ outer query ______________________________/\n    **\n    ** We look at every expression in the outer query and every place we see\n    ** \"a\" we substitute \"x*3\" and every place we see \"b\" we substitute \"y+10\".\n    */\n    pList = pParent->pEList;\n    for(i=0; i<pList->nExpr; i++){\n      if( pList->a[i].zName==0 ){\n        const char *zSpan = pList->a[i].zSpan;\n        if( ALWAYS(zSpan) ){\n          pList->a[i].zName = sqlite3DbStrDup(db, zSpan);\n        }\n      }\n    }\n    substExprList(db, pParent->pEList, iParent, pSub->pEList);\n    if( isAgg ){\n      substExprList(db, pParent->pGroupBy, iParent, pSub->pEList);\n      pParent->pHaving = substExpr(db, pParent->pHaving, iParent, pSub->pEList);\n    }\n    if( pSub->pOrderBy ){\n      assert( pParent->pOrderBy==0 );\n      pParent->pOrderBy = pSub->pOrderBy;\n      pSub->pOrderBy = 0;\n    }else if( pParent->pOrderBy ){\n      substExprList(db, pParent->pOrderBy, iParent, pSub->pEList);\n    }\n    if( pSub->pWhere ){\n      pWhere = sqlite3ExprDup(db, pSub->pWhere, 0);\n    }else{\n      pWhere = 0;\n    }\n    if( subqueryIsAgg ){\n      assert( pParent->pHaving==0 );\n      pParent->pHaving = pParent->pWhere;\n      pParent->pWhere = pWhere;\n      pParent->pHaving = substExpr(db, pParent->pHaving, iParent, pSub->pEList);\n      pParent->pHaving = sqlite3ExprAnd(db, pParent->pHaving, \n                                  sqlite3ExprDup(db, pSub->pHaving, 0));\n      assert( pParent->pGroupBy==0 );\n      pParent->pGroupBy = sqlite3ExprListDup(db, pSub->pGroupBy, 0);\n    }else{\n      pParent->pWhere = substExpr(db, pParent->pWhere, iParent, pSub->pEList);\n      pParent->pWhere = sqlite3ExprAnd(db, pParent->pWhere, pWhere);\n    }\n  \n    /* The flattened query is distinct if either the inner or the\n    ** outer query is distinct. \n    */\n    pParent->selFlags |= pSub->selFlags & SF_Distinct;\n  \n    /*\n    ** SELECT ... FROM (SELECT ... LIMIT a OFFSET b) LIMIT x OFFSET y;\n    **\n    ** One is tempted to try to add a and b to combine the limits.  But this\n    ** does not work if either limit is negative.\n    */\n    if( pSub->pLimit ){\n      pParent->pLimit = pSub->pLimit;\n      pSub->pLimit = 0;\n    }\n  }\n\n  /* Finially, delete what is left of the subquery and return\n  ** success.\n  */\n  sqlite3SelectDelete(db, pSub1);\n\n  return 1;\n}\n#endif /* !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW) */\n\n/*\n** Analyze the SELECT statement passed as an argument to see if it\n** is a min() or max() query. Return WHERE_ORDERBY_MIN or WHERE_ORDERBY_MAX if \n** it is, or 0 otherwise. At present, a query is considered to be\n** a min()/max() query if:\n**\n**   1. There is a single object in the FROM clause.\n**\n**   2. There is a single expression in the result set, and it is\n**      either min(x) or max(x), where x is a column reference.\n*/\nstatic u8 minMaxQuery(Select *p){\n  Expr *pExpr;\n  ExprList *pEList = p->pEList;\n\n  if( pEList->nExpr!=1 ) return WHERE_ORDERBY_NORMAL;\n  pExpr = pEList->a[0].pExpr;\n  if( pExpr->op!=TK_AGG_FUNCTION ) return 0;\n  if( NEVER(ExprHasProperty(pExpr, EP_xIsSelect)) ) return 0;\n  pEList = pExpr->x.pList;\n  if( pEList==0 || pEList->nExpr!=1 ) return 0;\n  if( pEList->a[0].pExpr->op!=TK_AGG_COLUMN ) return WHERE_ORDERBY_NORMAL;\n  assert( !ExprHasProperty(pExpr, EP_IntValue) );\n  if( sqlite3StrICmp(pExpr->u.zToken,\"min\")==0 ){\n    return WHERE_ORDERBY_MIN;\n  }else if( sqlite3StrICmp(pExpr->u.zToken,\"max\")==0 ){\n    return WHERE_ORDERBY_MAX;\n  }\n  return WHERE_ORDERBY_NORMAL;\n}\n\n/*\n** The select statement passed as the first argument is an aggregate query.\n** The second argment is the associated aggregate-info object. This \n** function tests if the SELECT is of the form:\n**\n**   SELECT count(*) FROM <tbl>\n**\n** where table is a database table, not a sub-select or view. If the query\n** does match this pattern, then a pointer to the Table object representing\n** <tbl> is returned. Otherwise, 0 is returned.\n*/\nstatic Table *isSimpleCount(Select *p, AggInfo *pAggInfo){\n  Table *pTab;\n  Expr *pExpr;\n\n  assert( !p->pGroupBy );\n\n  if( p->pWhere || p->pEList->nExpr!=1 \n   || p->pSrc->nSrc!=1 || p->pSrc->a[0].pSelect\n  ){\n    return 0;\n  }\n  pTab = p->pSrc->a[0].pTab;\n  pExpr = p->pEList->a[0].pExpr;\n  assert( pTab && !pTab->pSelect && pExpr );\n\n  if( IsVirtual(pTab) ) return 0;\n  if( pExpr->op!=TK_AGG_FUNCTION ) return 0;\n  if( (pAggInfo->aFunc[0].pFunc->flags&SQLITE_FUNC_COUNT)==0 ) return 0;\n  if( pExpr->flags&EP_Distinct ) return 0;\n\n  return pTab;\n}\n\n/*\n** If the source-list item passed as an argument was augmented with an\n** INDEXED BY clause, then try to locate the specified index. If there\n** was such a clause and the named index cannot be found, return \n** SQLITE_ERROR and leave an error in pParse. Otherwise, populate \n** pFrom->pIndex and return SQLITE_OK.\n*/\nSQLITE_PRIVATE int sqlite3IndexedByLookup(Parse *pParse, struct SrcList_item *pFrom){\n  if( pFrom->pTab && pFrom->zIndex ){\n    Table *pTab = pFrom->pTab;\n    char *zIndex = pFrom->zIndex;\n    Index *pIdx;\n    for(pIdx=pTab->pIndex; \n        pIdx && sqlite3StrICmp(pIdx->zName, zIndex); \n        pIdx=pIdx->pNext\n    );\n    if( !pIdx ){\n      sqlite3ErrorMsg(pParse, \"no such index: %s\", zIndex, 0);\n      pParse->checkSchema = 1;\n      return SQLITE_ERROR;\n    }\n    pFrom->pIndex = pIdx;\n  }\n  return SQLITE_OK;\n}\n\n/*\n** This routine is a Walker callback for \"expanding\" a SELECT statement.\n** \"Expanding\" means to do the following:\n**\n**    (1)  Make sure VDBE cursor numbers have been assigned to every\n**         element of the FROM clause.\n**\n**    (2)  Fill in the pTabList->a[].pTab fields in the SrcList that \n**         defines FROM clause.  When views appear in the FROM clause,\n**         fill pTabList->a[].pSelect with a copy of the SELECT statement\n**         that implements the view.  A copy is made of the view's SELECT\n**         statement so that we can freely modify or delete that statement\n**         without worrying about messing up the presistent representation\n**         of the view.\n**\n**    (3)  Add terms to the WHERE clause to accomodate the NATURAL keyword\n**         on joins and the ON and USING clause of joins.\n**\n**    (4)  Scan the list of columns in the result set (pEList) looking\n**         for instances of the \"*\" operator or the TABLE.* operator.\n**         If found, expand each \"*\" to be every column in every table\n**         and TABLE.* to be every column in TABLE.\n**\n*/\nstatic int selectExpander(Walker *pWalker, Select *p){\n  Parse *pParse = pWalker->pParse;\n  int i, j, k;\n  SrcList *pTabList;\n  ExprList *pEList;\n  struct SrcList_item *pFrom;\n  sqlite3 *db = pParse->db;\n\n  if( db->mallocFailed  ){\n    return WRC_Abort;\n  }\n  if( NEVER(p->pSrc==0) || (p->selFlags & SF_Expanded)!=0 ){\n    return WRC_Prune;\n  }\n  p->selFlags |= SF_Expanded;\n  pTabList = p->pSrc;\n  pEList = p->pEList;\n\n  /* Make sure cursor numbers have been assigned to all entries in\n  ** the FROM clause of the SELECT statement.\n  */\n  sqlite3SrcListAssignCursors(pParse, pTabList);\n\n  /* Look up every table named in the FROM clause of the select.  If\n  ** an entry of the FROM clause is a subquery instead of a table or view,\n  ** then create a transient table structure to describe the subquery.\n  */\n  for(i=0, pFrom=pTabList->a; i<pTabList->nSrc; i++, pFrom++){\n    Table *pTab;\n    if( pFrom->pTab!=0 ){\n      /* This statement has already been prepared.  There is no need\n      ** to go further. */\n      assert( i==0 );\n      return WRC_Prune;\n    }\n    if( pFrom->zName==0 ){\n#ifndef SQLITE_OMIT_SUBQUERY\n      Select *pSel = pFrom->pSelect;\n      /* A sub-query in the FROM clause of a SELECT */\n      assert( pSel!=0 );\n      assert( pFrom->pTab==0 );\n      sqlite3WalkSelect(pWalker, pSel);\n      pFrom->pTab = pTab = sqlite3DbMallocZero(db, sizeof(Table));\n      if( pTab==0 ) return WRC_Abort;\n      pTab->nRef = 1;\n      pTab->zName = sqlite3MPrintf(db, \"sqlite_subquery_%p_\", (void*)pTab);\n      while( pSel->pPrior ){ pSel = pSel->pPrior; }\n      selectColumnsFromExprList(pParse, pSel->pEList, &pTab->nCol, &pTab->aCol);\n      pTab->iPKey = -1;\n      pTab->nRowEst = 1000000;\n      pTab->tabFlags |= TF_Ephemeral;\n#endif\n    }else{\n      /* An ordinary table or view name in the FROM clause */\n      assert( pFrom->pTab==0 );\n      pFrom->pTab = pTab = \n        sqlite3LocateTable(pParse,0,pFrom->zName,pFrom->zDatabase);\n      if( pTab==0 ) return WRC_Abort;\n      pTab->nRef++;\n#if !defined(SQLITE_OMIT_VIEW) || !defined (SQLITE_OMIT_VIRTUALTABLE)\n      if( pTab->pSelect || IsVirtual(pTab) ){\n        /* We reach here if the named table is a really a view */\n        if( sqlite3ViewGetColumnNames(pParse, pTab) ) return WRC_Abort;\n        assert( pFrom->pSelect==0 );\n        pFrom->pSelect = sqlite3SelectDup(db, pTab->pSelect, 0);\n        sqlite3WalkSelect(pWalker, pFrom->pSelect);\n      }\n#endif\n    }\n\n    /* Locate the index named by the INDEXED BY clause, if any. */\n    if( sqlite3IndexedByLookup(pParse, pFrom) ){\n      return WRC_Abort;\n    }\n  }\n\n  /* Process NATURAL keywords, and ON and USING clauses of joins.\n  */\n  if( db->mallocFailed || sqliteProcessJoin(pParse, p) ){\n    return WRC_Abort;\n  }\n\n  /* For every \"*\" that occurs in the column list, insert the names of\n  ** all columns in all tables.  And for every TABLE.* insert the names\n  ** of all columns in TABLE.  The parser inserted a special expression\n  ** with the TK_ALL operator for each \"*\" that it found in the column list.\n  ** The following code just has to locate the TK_ALL expressions and expand\n  ** each one to the list of all columns in all tables.\n  **\n  ** The first loop just checks to see if there are any \"*\" operators\n  ** that need expanding.\n  */\n  for(k=0; k<pEList->nExpr; k++){\n    Expr *pE = pEList->a[k].pExpr;\n    if( pE->op==TK_ALL ) break;\n    assert( pE->op!=TK_DOT || pE->pRight!=0 );\n    assert( pE->op!=TK_DOT || (pE->pLeft!=0 && pE->pLeft->op==TK_ID) );\n    if( pE->op==TK_DOT && pE->pRight->op==TK_ALL ) break;\n  }\n  if( k<pEList->nExpr ){\n    /*\n    ** If we get here it means the result set contains one or more \"*\"\n    ** operators that need to be expanded.  Loop through each expression\n    ** in the result set and expand them one by one.\n    */\n    struct ExprList_item *a = pEList->a;\n    ExprList *pNew = 0;\n    int flags = pParse->db->flags;\n    int longNames = (flags & SQLITE_FullColNames)!=0\n                      && (flags & SQLITE_ShortColNames)==0;\n\n    for(k=0; k<pEList->nExpr; k++){\n      Expr *pE = a[k].pExpr;\n      assert( pE->op!=TK_DOT || pE->pRight!=0 );\n      if( pE->op!=TK_ALL && (pE->op!=TK_DOT || pE->pRight->op!=TK_ALL) ){\n        /* This particular expression does not need to be expanded.\n        */\n        pNew = sqlite3ExprListAppend(pParse, pNew, a[k].pExpr);\n        if( pNew ){\n          pNew->a[pNew->nExpr-1].zName = a[k].zName;\n          pNew->a[pNew->nExpr-1].zSpan = a[k].zSpan;\n          a[k].zName = 0;\n          a[k].zSpan = 0;\n        }\n        a[k].pExpr = 0;\n      }else{\n        /* This expression is a \"*\" or a \"TABLE.*\" and needs to be\n        ** expanded. */\n        int tableSeen = 0;      /* Set to 1 when TABLE matches */\n        char *zTName;            /* text of name of TABLE */\n        if( pE->op==TK_DOT ){\n          assert( pE->pLeft!=0 );\n          assert( !ExprHasProperty(pE->pLeft, EP_IntValue) );\n          zTName = pE->pLeft->u.zToken;\n        }else{\n          zTName = 0;\n        }\n        for(i=0, pFrom=pTabList->a; i<pTabList->nSrc; i++, pFrom++){\n          Table *pTab = pFrom->pTab;\n          char *zTabName = pFrom->zAlias;\n          if( zTabName==0 ){\n            zTabName = pTab->zName;\n          }\n          if( db->mallocFailed ) break;\n          if( zTName && sqlite3StrICmp(zTName, zTabName)!=0 ){\n            continue;\n          }\n          tableSeen = 1;\n          for(j=0; j<pTab->nCol; j++){\n            Expr *pExpr, *pRight;\n            char *zName = pTab->aCol[j].zName;\n            char *zColname;  /* The computed column name */\n            char *zToFree;   /* Malloced string that needs to be freed */\n            Token sColname;  /* Computed column name as a token */\n\n            /* If a column is marked as 'hidden' (currently only possible\n            ** for virtual tables), do not include it in the expanded\n            ** result-set list.\n            */\n            if( IsHiddenColumn(&pTab->aCol[j]) ){\n              assert(IsVirtual(pTab));\n              continue;\n            }\n\n            if( i>0 && zTName==0 ){\n              if( (pFrom->jointype & JT_NATURAL)!=0\n                && tableAndColumnIndex(pTabList, i, zName, 0, 0)\n              ){\n                /* In a NATURAL join, omit the join columns from the \n                ** table to the right of the join */\n                continue;\n              }\n              if( sqlite3IdListIndex(pFrom->pUsing, zName)>=0 ){\n                /* In a join with a USING clause, omit columns in the\n                ** using clause from the table on the right. */\n                continue;\n              }\n            }\n            pRight = sqlite3Expr(db, TK_ID, zName);\n            zColname = zName;\n            zToFree = 0;\n            if( longNames || pTabList->nSrc>1 ){\n              Expr *pLeft;\n              pLeft = sqlite3Expr(db, TK_ID, zTabName);\n              pExpr = sqlite3PExpr(pParse, TK_DOT, pLeft, pRight, 0);\n              if( longNames ){\n                zColname = sqlite3MPrintf(db, \"%s.%s\", zTabName, zName);\n                zToFree = zColname;\n              }\n            }else{\n              pExpr = pRight;\n            }\n            pNew = sqlite3ExprListAppend(pParse, pNew, pExpr);\n            sColname.z = zColname;\n            sColname.n = sqlite3Strlen30(zColname);\n            sqlite3ExprListSetName(pParse, pNew, &sColname, 0);\n            sqlite3DbFree(db, zToFree);\n          }\n        }\n        if( !tableSeen ){\n          if( zTName ){\n            sqlite3ErrorMsg(pParse, \"no such table: %s\", zTName);\n          }else{\n            sqlite3ErrorMsg(pParse, \"no tables specified\");\n          }\n        }\n      }\n    }\n    sqlite3ExprListDelete(db, pEList);\n    p->pEList = pNew;\n  }\n#if SQLITE_MAX_COLUMN\n  if( p->pEList && p->pEList->nExpr>db->aLimit[SQLITE_LIMIT_COLUMN] ){\n    sqlite3ErrorMsg(pParse, \"too many columns in result set\");\n  }\n#endif\n  return WRC_Continue;\n}\n\n/*\n** No-op routine for the parse-tree walker.\n**\n** When this routine is the Walker.xExprCallback then expression trees\n** are walked without any actions being taken at each node.  Presumably,\n** when this routine is used for Walker.xExprCallback then \n** Walker.xSelectCallback is set to do something useful for every \n** subquery in the parser tree.\n*/\nstatic int exprWalkNoop(Walker *NotUsed, Expr *NotUsed2){\n  UNUSED_PARAMETER2(NotUsed, NotUsed2);\n  return WRC_Continue;\n}\n\n/*\n** This routine \"expands\" a SELECT statement and all of its subqueries.\n** For additional information on what it means to \"expand\" a SELECT\n** statement, see the comment on the selectExpand worker callback above.\n**\n** Expanding a SELECT statement is the first step in processing a\n** SELECT statement.  The SELECT statement must be expanded before\n** name resolution is performed.\n**\n** If anything goes wrong, an error message is written into pParse.\n** The calling function can detect the problem by looking at pParse->nErr\n** and/or pParse->db->mallocFailed.\n*/\nstatic void sqlite3SelectExpand(Parse *pParse, Select *pSelect){\n  Walker w;\n  w.xSelectCallback = selectExpander;\n  w.xExprCallback = exprWalkNoop;\n  w.pParse = pParse;\n  sqlite3WalkSelect(&w, pSelect);\n}\n\n\n#ifndef SQLITE_OMIT_SUBQUERY\n/*\n** This is a Walker.xSelectCallback callback for the sqlite3SelectTypeInfo()\n** interface.\n**\n** For each FROM-clause subquery, add Column.zType and Column.zColl\n** information to the Table structure that represents the result set\n** of that subquery.\n**\n** The Table structure that represents the result set was constructed\n** by selectExpander() but the type and collation information was omitted\n** at that point because identifiers had not yet been resolved.  This\n** routine is called after identifier resolution.\n*/\nstatic int selectAddSubqueryTypeInfo(Walker *pWalker, Select *p){\n  Parse *pParse;\n  int i;\n  SrcList *pTabList;\n  struct SrcList_item *pFrom;\n\n  assert( p->selFlags & SF_Resolved );\n  if( (p->selFlags & SF_HasTypeInfo)==0 ){\n    p->selFlags |= SF_HasTypeInfo;\n    pParse = pWalker->pParse;\n    pTabList = p->pSrc;\n    for(i=0, pFrom=pTabList->a; i<pTabList->nSrc; i++, pFrom++){\n      Table *pTab = pFrom->pTab;\n      if( ALWAYS(pTab!=0) && (pTab->tabFlags & TF_Ephemeral)!=0 ){\n        /* A sub-query in the FROM clause of a SELECT */\n        Select *pSel = pFrom->pSelect;\n        assert( pSel );\n        while( pSel->pPrior ) pSel = pSel->pPrior;\n        selectAddColumnTypeAndCollation(pParse, pTab->nCol, pTab->aCol, pSel);\n      }\n    }\n  }\n  return WRC_Continue;\n}\n#endif\n\n\n/*\n** This routine adds datatype and collating sequence information to\n** the Table structures of all FROM-clause subqueries in a\n** SELECT statement.\n**\n** Use this routine after name resolution.\n*/\nstatic void sqlite3SelectAddTypeInfo(Parse *pParse, Select *pSelect){\n#ifndef SQLITE_OMIT_SUBQUERY\n  Walker w;\n  w.xSelectCallback = selectAddSubqueryTypeInfo;\n  w.xExprCallback = exprWalkNoop;\n  w.pParse = pParse;\n  sqlite3WalkSelect(&w, pSelect);\n#endif\n}\n\n\n/*\n** This routine sets of a SELECT statement for processing.  The\n** following is accomplished:\n**\n**     *  VDBE Cursor numbers are assigned to all FROM-clause terms.\n**     *  Ephemeral Table objects are created for all FROM-clause subqueries.\n**     *  ON and USING clauses are shifted into WHERE statements\n**     *  Wildcards \"*\" and \"TABLE.*\" in result sets are expanded.\n**     *  Identifiers in expression are matched to tables.\n**\n** This routine acts recursively on all subqueries within the SELECT.\n*/\nSQLITE_PRIVATE void sqlite3SelectPrep(\n  Parse *pParse,         /* The parser context */\n  Select *p,             /* The SELECT statement being coded. */\n  NameContext *pOuterNC  /* Name context for container */\n){\n  sqlite3 *db;\n  if( NEVER(p==0) ) return;\n  db = pParse->db;\n  if( p->selFlags & SF_HasTypeInfo ) return;\n  sqlite3SelectExpand(pParse, p);\n  if( pParse->nErr || db->mallocFailed ) return;\n  sqlite3ResolveSelectNames(pParse, p, pOuterNC);\n  if( pParse->nErr || db->mallocFailed ) return;\n  sqlite3SelectAddTypeInfo(pParse, p);\n}\n\n/*\n** Reset the aggregate accumulator.\n**\n** The aggregate accumulator is a set of memory cells that hold\n** intermediate results while calculating an aggregate.  This\n** routine simply stores NULLs in all of those memory cells.\n*/\nstatic void resetAccumulator(Parse *pParse, AggInfo *pAggInfo){\n  Vdbe *v = pParse->pVdbe;\n  int i;\n  struct AggInfo_func *pFunc;\n  if( pAggInfo->nFunc+pAggInfo->nColumn==0 ){\n    return;\n  }\n  for(i=0; i<pAggInfo->nColumn; i++){\n    sqlite3VdbeAddOp2(v, OP_Null, 0, pAggInfo->aCol[i].iMem);\n  }\n  for(pFunc=pAggInfo->aFunc, i=0; i<pAggInfo->nFunc; i++, pFunc++){\n    sqlite3VdbeAddOp2(v, OP_Null, 0, pFunc->iMem);\n    if( pFunc->iDistinct>=0 ){\n      Expr *pE = pFunc->pExpr;\n      assert( !ExprHasProperty(pE, EP_xIsSelect) );\n      if( pE->x.pList==0 || pE->x.pList->nExpr!=1 ){\n        sqlite3ErrorMsg(pParse, \"DISTINCT aggregates must have exactly one \"\n           \"argument\");\n        pFunc->iDistinct = -1;\n      }else{\n        KeyInfo *pKeyInfo = keyInfoFromExprList(pParse, pE->x.pList);\n        sqlite3VdbeAddOp4(v, OP_OpenEphemeral, pFunc->iDistinct, 0, 0,\n                          (char*)pKeyInfo, P4_KEYINFO_HANDOFF);\n      }\n    }\n  }\n}\n\n/*\n** Invoke the OP_AggFinalize opcode for every aggregate function\n** in the AggInfo structure.\n*/\nstatic void finalizeAggFunctions(Parse *pParse, AggInfo *pAggInfo){\n  Vdbe *v = pParse->pVdbe;\n  int i;\n  struct AggInfo_func *pF;\n  for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++){\n    ExprList *pList = pF->pExpr->x.pList;\n    assert( !ExprHasProperty(pF->pExpr, EP_xIsSelect) );\n    sqlite3VdbeAddOp4(v, OP_AggFinal, pF->iMem, pList ? pList->nExpr : 0, 0,\n                      (void*)pF->pFunc, P4_FUNCDEF);\n  }\n}\n\n/*\n** Update the accumulator memory cells for an aggregate based on\n** the current cursor position.\n*/\nstatic void updateAccumulator(Parse *pParse, AggInfo *pAggInfo){\n  Vdbe *v = pParse->pVdbe;\n  int i;\n  struct AggInfo_func *pF;\n  struct AggInfo_col *pC;\n\n  pAggInfo->directMode = 1;\n  sqlite3ExprCacheClear(pParse);\n  for(i=0, pF=pAggInfo->aFunc; i<pAggInfo->nFunc; i++, pF++){\n    int nArg;\n    int addrNext = 0;\n    int regAgg;\n    ExprList *pList = pF->pExpr->x.pList;\n    assert( !ExprHasProperty(pF->pExpr, EP_xIsSelect) );\n    if( pList ){\n      nArg = pList->nExpr;\n      regAgg = sqlite3GetTempRange(pParse, nArg);\n      sqlite3ExprCodeExprList(pParse, pList, regAgg, 1);\n    }else{\n      nArg = 0;\n      regAgg = 0;\n    }\n    if( pF->iDistinct>=0 ){\n      addrNext = sqlite3VdbeMakeLabel(v);\n      assert( nArg==1 );\n      codeDistinct(pParse, pF->iDistinct, addrNext, 1, regAgg);\n    }\n    if( pF->pFunc->flags & SQLITE_FUNC_NEEDCOLL ){\n      CollSeq *pColl = 0;\n      struct ExprList_item *pItem;\n      int j;\n      assert( pList!=0 );  /* pList!=0 if pF->pFunc has NEEDCOLL */\n      for(j=0, pItem=pList->a; !pColl && j<nArg; j++, pItem++){\n        pColl = sqlite3ExprCollSeq(pParse, pItem->pExpr);\n      }\n      if( !pColl ){\n        pColl = pParse->db->pDfltColl;\n      }\n      sqlite3VdbeAddOp4(v, OP_CollSeq, 0, 0, 0, (char *)pColl, P4_COLLSEQ);\n    }\n    sqlite3VdbeAddOp4(v, OP_AggStep, 0, regAgg, pF->iMem,\n                      (void*)pF->pFunc, P4_FUNCDEF);\n    sqlite3VdbeChangeP5(v, (u8)nArg);\n    sqlite3ExprCacheAffinityChange(pParse, regAgg, nArg);\n    sqlite3ReleaseTempRange(pParse, regAgg, nArg);\n    if( addrNext ){\n      sqlite3VdbeResolveLabel(v, addrNext);\n      sqlite3ExprCacheClear(pParse);\n    }\n  }\n\n  /* Before populating the accumulator registers, clear the column cache.\n  ** Otherwise, if any of the required column values are already present \n  ** in registers, sqlite3ExprCode() may use OP_SCopy to copy the value\n  ** to pC->iMem. But by the time the value is used, the original register\n  ** may have been used, invalidating the underlying buffer holding the\n  ** text or blob value. See ticket [883034dcb5].\n  **\n  ** Another solution would be to change the OP_SCopy used to copy cached\n  ** values to an OP_Copy.\n  */\n  sqlite3ExprCacheClear(pParse);\n  for(i=0, pC=pAggInfo->aCol; i<pAggInfo->nAccumulator; i++, pC++){\n    sqlite3ExprCode(pParse, pC->pExpr, pC->iMem);\n  }\n  pAggInfo->directMode = 0;\n  sqlite3ExprCacheClear(pParse);\n}\n\n/*\n** Add a single OP_Explain instruction to the VDBE to explain a simple\n** count(*) query (\"SELECT count(*) FROM pTab\").\n*/\n#ifndef SQLITE_OMIT_EXPLAIN\nstatic void explainSimpleCount(\n  Parse *pParse,                  /* Parse context */\n  Table *pTab,                    /* Table being queried */\n  Index *pIdx                     /* Index used to optimize scan, or NULL */\n){\n  if( pParse->explain==2 ){\n    char *zEqp = sqlite3MPrintf(pParse->db, \"SCAN TABLE %s %s%s(~%d rows)\",\n        pTab->zName, \n        pIdx ? \"USING COVERING INDEX \" : \"\",\n        pIdx ? pIdx->zName : \"\",\n        pTab->nRowEst\n    );\n    sqlite3VdbeAddOp4(\n        pParse->pVdbe, OP_Explain, pParse->iSelectId, 0, 0, zEqp, P4_DYNAMIC\n    );\n  }\n}\n#else\n# define explainSimpleCount(a,b,c)\n#endif\n\n/*\n** Generate code for the SELECT statement given in the p argument.  \n**\n** The results are distributed in various ways depending on the\n** contents of the SelectDest structure pointed to by argument pDest\n** as follows:\n**\n**     pDest->eDest    Result\n**     ------------    -------------------------------------------\n**     SRT_Output      Generate a row of output (using the OP_ResultRow\n**                     opcode) for each row in the result set.\n**\n**     SRT_Mem         Only valid if the result is a single column.\n**                     Store the first column of the first result row\n**                     in register pDest->iParm then abandon the rest\n**                     of the query.  This destination implies \"LIMIT 1\".\n**\n**     SRT_Set         The result must be a single column.  Store each\n**                     row of result as the key in table pDest->iParm. \n**                     Apply the affinity pDest->affinity before storing\n**                     results.  Used to implement \"IN (SELECT ...)\".\n**\n**     SRT_Union       Store results as a key in a temporary table pDest->iParm.\n**\n**     SRT_Except      Remove results from the temporary table pDest->iParm.\n**\n**     SRT_Table       Store results in temporary table pDest->iParm.\n**                     This is like SRT_EphemTab except that the table\n**                     is assumed to already be open.\n**\n**     SRT_EphemTab    Create an temporary table pDest->iParm and store\n**                     the result there. The cursor is left open after\n**                     returning.  This is like SRT_Table except that\n**                     this destination uses OP_OpenEphemeral to create\n**                     the table first.\n**\n**     SRT_Coroutine   Generate a co-routine that returns a new row of\n**                     results each time it is invoked.  The entry point\n**                     of the co-routine is stored in register pDest->iParm.\n**\n**     SRT_Exists      Store a 1 in memory cell pDest->iParm if the result\n**                     set is not empty.\n**\n**     SRT_Discard     Throw the results away.  This is used by SELECT\n**                     statements within triggers whose only purpose is\n**                     the side-effects of functions.\n**\n** This routine returns the number of errors.  If any errors are\n** encountered, then an appropriate error message is left in\n** pParse->zErrMsg.\n**\n** This routine does NOT free the Select structure passed in.  The\n** calling function needs to do that.\n*/\nSQLITE_PRIVATE int sqlite3Select(\n  Parse *pParse,         /* The parser context */\n  Select *p,             /* The SELECT statement being coded. */\n  SelectDest *pDest      /* What to do with the query results */\n){\n  int i, j;              /* Loop counters */\n  WhereInfo *pWInfo;     /* Return from sqlite3WhereBegin() */\n  Vdbe *v;               /* The virtual machine under construction */\n  int isAgg;             /* True for select lists like \"count(*)\" */\n  ExprList *pEList;      /* List of columns to extract. */\n  SrcList *pTabList;     /* List of tables to select from */\n  Expr *pWhere;          /* The WHERE clause.  May be NULL */\n  ExprList *pOrderBy;    /* The ORDER BY clause.  May be NULL */\n  ExprList *pGroupBy;    /* The GROUP BY clause.  May be NULL */\n  Expr *pHaving;         /* The HAVING clause.  May be NULL */\n  int isDistinct;        /* True if the DISTINCT keyword is present */\n  int distinct;          /* Table to use for the distinct set */\n  int rc = 1;            /* Value to return from this function */\n  int addrSortIndex;     /* Address of an OP_OpenEphemeral instruction */\n  AggInfo sAggInfo;      /* Information used by aggregate queries */\n  int iEnd;              /* Address of the end of the query */\n  sqlite3 *db;           /* The database connection */\n\n#ifndef SQLITE_OMIT_EXPLAIN\n  int iRestoreSelectId = pParse->iSelectId;\n  pParse->iSelectId = pParse->iNextSelectId++;\n#endif\n\n  db = pParse->db;\n  if( p==0 || db->mallocFailed || pParse->nErr ){\n    return 1;\n  }\n  if( sqlite3AuthCheck(pParse, SQLITE_SELECT, 0, 0, 0) ) return 1;\n  memset(&sAggInfo, 0, sizeof(sAggInfo));\n\n  if( IgnorableOrderby(pDest) ){\n    assert(pDest->eDest==SRT_Exists || pDest->eDest==SRT_Union || \n           pDest->eDest==SRT_Except || pDest->eDest==SRT_Discard);\n    /* If ORDER BY makes no difference in the output then neither does\n    ** DISTINCT so it can be removed too. */\n    sqlite3ExprListDelete(db, p->pOrderBy);\n    p->pOrderBy = 0;\n    p->selFlags &= ~SF_Distinct;\n  }\n  sqlite3SelectPrep(pParse, p, 0);\n  pOrderBy = p->pOrderBy;\n  pTabList = p->pSrc;\n  pEList = p->pEList;\n  if( pParse->nErr || db->mallocFailed ){\n    goto select_end;\n  }\n  isAgg = (p->selFlags & SF_Aggregate)!=0;\n  assert( pEList!=0 );\n\n  /* Begin generating code.\n  */\n  v = sqlite3GetVdbe(pParse);\n  if( v==0 ) goto select_end;\n\n  /* If writing to memory or generating a set\n  ** only a single column may be output.\n  */\n#ifndef SQLITE_OMIT_SUBQUERY\n  if( checkForMultiColumnSelectError(pParse, pDest, pEList->nExpr) ){\n    goto select_end;\n  }\n#endif\n\n  /* Generate code for all sub-queries in the FROM clause\n  */\n#if !defined(SQLITE_OMIT_SUBQUERY) || !defined(SQLITE_OMIT_VIEW)\n  for(i=0; !p->pPrior && i<pTabList->nSrc; i++){\n    struct SrcList_item *pItem = &pTabList->a[i];\n    SelectDest dest;\n    Select *pSub = pItem->pSelect;\n    int isAggSub;\n\n    if( pSub==0 || pItem->isPopulated ) continue;\n\n    /* Increment Parse.nHeight by the height of the largest expression\n    ** tree refered to by this, the parent select. The child select\n    ** may contain expression trees of at most\n    ** (SQLITE_MAX_EXPR_DEPTH-Parse.nHeight) height. This is a bit\n    ** more conservative than necessary, but much easier than enforcing\n    ** an exact limit.\n    */\n    pParse->nHeight += sqlite3SelectExprHeight(p);\n\n    /* Check to see if the subquery can be absorbed into the parent. */\n    isAggSub = (pSub->selFlags & SF_Aggregate)!=0;\n    if( flattenSubquery(pParse, p, i, isAgg, isAggSub) ){\n      if( isAggSub ){\n        isAgg = 1;\n        p->selFlags |= SF_Aggregate;\n      }\n      i = -1;\n    }else{\n      sqlite3SelectDestInit(&dest, SRT_EphemTab, pItem->iCursor);\n      assert( pItem->isPopulated==0 );\n      explainSetInteger(pItem->iSelectId, (u8)pParse->iNextSelectId);\n      sqlite3Select(pParse, pSub, &dest);\n      pItem->isPopulated = 1;\n      pItem->pTab->nRowEst = (unsigned)pSub->nSelectRow;\n    }\n    if( /*pParse->nErr ||*/ db->mallocFailed ){\n      goto select_end;\n    }\n    pParse->nHeight -= sqlite3SelectExprHeight(p);\n    pTabList = p->pSrc;\n    if( !IgnorableOrderby(pDest) ){\n      pOrderBy = p->pOrderBy;\n    }\n  }\n  pEList = p->pEList;\n#endif\n  pWhere = p->pWhere;\n  pGroupBy = p->pGroupBy;\n  pHaving = p->pHaving;\n  isDistinct = (p->selFlags & SF_Distinct)!=0;\n\n#ifndef SQLITE_OMIT_COMPOUND_SELECT\n  /* If there is are a sequence of queries, do the earlier ones first.\n  */\n  if( p->pPrior ){\n    if( p->pRightmost==0 ){\n      Select *pLoop, *pRight = 0;\n      int cnt = 0;\n      int mxSelect;\n      for(pLoop=p; pLoop; pLoop=pLoop->pPrior, cnt++){\n        pLoop->pRightmost = p;\n        pLoop->pNext = pRight;\n        pRight = pLoop;\n      }\n      mxSelect = db->aLimit[SQLITE_LIMIT_COMPOUND_SELECT];\n      if( mxSelect && cnt>mxSelect ){\n        sqlite3ErrorMsg(pParse, \"too many terms in compound SELECT\");\n        goto select_end;\n      }\n    }\n    rc = multiSelect(pParse, p, pDest);\n    explainSetInteger(pParse->iSelectId, iRestoreSelectId);\n    return rc;\n  }\n#endif\n\n  /* If possible, rewrite the query to use GROUP BY instead of DISTINCT.\n  ** GROUP BY might use an index, DISTINCT never does.\n  */\n  assert( p->pGroupBy==0 || (p->selFlags & SF_Aggregate)!=0 );\n  if( (p->selFlags & (SF_Distinct|SF_Aggregate))==SF_Distinct ){\n    p->pGroupBy = sqlite3ExprListDup(db, p->pEList, 0);\n    pGroupBy = p->pGroupBy;\n    p->selFlags &= ~SF_Distinct;\n  }\n\n  /* If there is both a GROUP BY and an ORDER BY clause and they are\n  ** identical, then disable the ORDER BY clause since the GROUP BY\n  ** will cause elements to come out in the correct order.  This is\n  ** an optimization - the correct answer should result regardless.\n  ** Use the SQLITE_GroupByOrder flag with SQLITE_TESTCTRL_OPTIMIZER\n  ** to disable this optimization for testing purposes.\n  */\n  if( sqlite3ExprListCompare(p->pGroupBy, pOrderBy)==0\n         && (db->flags & SQLITE_GroupByOrder)==0 ){\n    pOrderBy = 0;\n  }\n\n  /* If there is an ORDER BY clause, then this sorting\n  ** index might end up being unused if the data can be \n  ** extracted in pre-sorted order.  If that is the case, then the\n  ** OP_OpenEphemeral instruction will be changed to an OP_Noop once\n  ** we figure out that the sorting index is not needed.  The addrSortIndex\n  ** variable is used to facilitate that change.\n  */\n  if( pOrderBy ){\n    KeyInfo *pKeyInfo;\n    pKeyInfo = keyInfoFromExprList(pParse, pOrderBy);\n    pOrderBy->iECursor = pParse->nTab++;\n    p->addrOpenEphm[2] = addrSortIndex =\n      sqlite3VdbeAddOp4(v, OP_OpenEphemeral,\n                           pOrderBy->iECursor, pOrderBy->nExpr+2, 0,\n                           (char*)pKeyInfo, P4_KEYINFO_HANDOFF);\n  }else{\n    addrSortIndex = -1;\n  }\n\n  /* If the output is destined for a temporary table, open that table.\n  */\n  if( pDest->eDest==SRT_EphemTab ){\n    sqlite3VdbeAddOp2(v, OP_OpenEphemeral, pDest->iParm, pEList->nExpr);\n  }\n\n  /* Set the limiter.\n  */\n  iEnd = sqlite3VdbeMakeLabel(v);\n  p->nSelectRow = (double)LARGEST_INT64;\n  computeLimitRegisters(pParse, p, iEnd);\n\n  /* Open a virtual index to use for the distinct set.\n  */\n  if( p->selFlags & SF_Distinct ){\n    KeyInfo *pKeyInfo;\n    assert( isAgg || pGroupBy );\n    distinct = pParse->nTab++;\n    pKeyInfo = keyInfoFromExprList(pParse, p->pEList);\n    sqlite3VdbeAddOp4(v, OP_OpenEphemeral, distinct, 0, 0,\n                        (char*)pKeyInfo, P4_KEYINFO_HANDOFF);\n    sqlite3VdbeChangeP5(v, BTREE_UNORDERED);\n  }else{\n    distinct = -1;\n  }\n\n  /* Aggregate and non-aggregate queries are handled differently */\n  if( !isAgg && pGroupBy==0 ){\n    /* This case is for non-aggregate queries\n    ** Begin the database scan\n    */\n    pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, &pOrderBy, 0);\n    if( pWInfo==0 ) goto select_end;\n    if( pWInfo->nRowOut < p->nSelectRow ) p->nSelectRow = pWInfo->nRowOut;\n\n    /* If sorting index that was created by a prior OP_OpenEphemeral \n    ** instruction ended up not being needed, then change the OP_OpenEphemeral\n    ** into an OP_Noop.\n    */\n    if( addrSortIndex>=0 && pOrderBy==0 ){\n      sqlite3VdbeChangeToNoop(v, addrSortIndex, 1);\n      p->addrOpenEphm[2] = -1;\n    }\n\n    /* Use the standard inner loop\n    */\n    assert(!isDistinct);\n    selectInnerLoop(pParse, p, pEList, 0, 0, pOrderBy, -1, pDest,\n                    pWInfo->iContinue, pWInfo->iBreak);\n\n    /* End the database scan loop.\n    */\n    sqlite3WhereEnd(pWInfo);\n  }else{\n    /* This is the processing for aggregate queries */\n    NameContext sNC;    /* Name context for processing aggregate information */\n    int iAMem;          /* First Mem address for storing current GROUP BY */\n    int iBMem;          /* First Mem address for previous GROUP BY */\n    int iUseFlag;       /* Mem address holding flag indicating that at least\n                        ** one row of the input to the aggregator has been\n                        ** processed */\n    int iAbortFlag;     /* Mem address which causes query abort if positive */\n    int groupBySort;    /* Rows come from source in GROUP BY order */\n    int addrEnd;        /* End of processing for this SELECT */\n\n    /* Remove any and all aliases between the result set and the\n    ** GROUP BY clause.\n    */\n    if( pGroupBy ){\n      int k;                        /* Loop counter */\n      struct ExprList_item *pItem;  /* For looping over expression in a list */\n\n      for(k=p->pEList->nExpr, pItem=p->pEList->a; k>0; k--, pItem++){\n        pItem->iAlias = 0;\n      }\n      for(k=pGroupBy->nExpr, pItem=pGroupBy->a; k>0; k--, pItem++){\n        pItem->iAlias = 0;\n      }\n      if( p->nSelectRow>(double)100 ) p->nSelectRow = (double)100;\n    }else{\n      p->nSelectRow = (double)1;\n    }\n\n \n    /* Create a label to jump to when we want to abort the query */\n    addrEnd = sqlite3VdbeMakeLabel(v);\n\n    /* Convert TK_COLUMN nodes into TK_AGG_COLUMN and make entries in\n    ** sAggInfo for all TK_AGG_FUNCTION nodes in expressions of the\n    ** SELECT statement.\n    */\n    memset(&sNC, 0, sizeof(sNC));\n    sNC.pParse = pParse;\n    sNC.pSrcList = pTabList;\n    sNC.pAggInfo = &sAggInfo;\n    sAggInfo.nSortingColumn = pGroupBy ? pGroupBy->nExpr+1 : 0;\n    sAggInfo.pGroupBy = pGroupBy;\n    sqlite3ExprAnalyzeAggList(&sNC, pEList);\n    sqlite3ExprAnalyzeAggList(&sNC, pOrderBy);\n    if( pHaving ){\n      sqlite3ExprAnalyzeAggregates(&sNC, pHaving);\n    }\n    sAggInfo.nAccumulator = sAggInfo.nColumn;\n    for(i=0; i<sAggInfo.nFunc; i++){\n      assert( !ExprHasProperty(sAggInfo.aFunc[i].pExpr, EP_xIsSelect) );\n      sqlite3ExprAnalyzeAggList(&sNC, sAggInfo.aFunc[i].pExpr->x.pList);\n    }\n    if( db->mallocFailed ) goto select_end;\n\n    /* Processing for aggregates with GROUP BY is very different and\n    ** much more complex than aggregates without a GROUP BY.\n    */\n    if( pGroupBy ){\n      KeyInfo *pKeyInfo;  /* Keying information for the group by clause */\n      int j1;             /* A-vs-B comparision jump */\n      int addrOutputRow;  /* Start of subroutine that outputs a result row */\n      int regOutputRow;   /* Return address register for output subroutine */\n      int addrSetAbort;   /* Set the abort flag and return */\n      int addrTopOfLoop;  /* Top of the input loop */\n      int addrSortingIdx; /* The OP_OpenEphemeral for the sorting index */\n      int addrReset;      /* Subroutine for resetting the accumulator */\n      int regReset;       /* Return address register for reset subroutine */\n\n      /* If there is a GROUP BY clause we might need a sorting index to\n      ** implement it.  Allocate that sorting index now.  If it turns out\n      ** that we do not need it after all, the OpenEphemeral instruction\n      ** will be converted into a Noop.  \n      */\n      sAggInfo.sortingIdx = pParse->nTab++;\n      pKeyInfo = keyInfoFromExprList(pParse, pGroupBy);\n      addrSortingIdx = sqlite3VdbeAddOp4(v, OP_OpenEphemeral, \n          sAggInfo.sortingIdx, sAggInfo.nSortingColumn, \n          0, (char*)pKeyInfo, P4_KEYINFO_HANDOFF);\n\n      /* Initialize memory locations used by GROUP BY aggregate processing\n      */\n      iUseFlag = ++pParse->nMem;\n      iAbortFlag = ++pParse->nMem;\n      regOutputRow = ++pParse->nMem;\n      addrOutputRow = sqlite3VdbeMakeLabel(v);\n      regReset = ++pParse->nMem;\n      addrReset = sqlite3VdbeMakeLabel(v);\n      iAMem = pParse->nMem + 1;\n      pParse->nMem += pGroupBy->nExpr;\n      iBMem = pParse->nMem + 1;\n      pParse->nMem += pGroupBy->nExpr;\n      sqlite3VdbeAddOp2(v, OP_Integer, 0, iAbortFlag);\n      VdbeComment((v, \"clear abort flag\"));\n      sqlite3VdbeAddOp2(v, OP_Integer, 0, iUseFlag);\n      VdbeComment((v, \"indicate accumulator empty\"));\n\n      /* Begin a loop that will extract all source rows in GROUP BY order.\n      ** This might involve two separate loops with an OP_Sort in between, or\n      ** it might be a single loop that uses an index to extract information\n      ** in the right order to begin with.\n      */\n      sqlite3VdbeAddOp2(v, OP_Gosub, regReset, addrReset);\n      pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, &pGroupBy, 0);\n      if( pWInfo==0 ) goto select_end;\n      if( pGroupBy==0 ){\n        /* The optimizer is able to deliver rows in group by order so\n        ** we do not have to sort.  The OP_OpenEphemeral table will be\n        ** cancelled later because we still need to use the pKeyInfo\n        */\n        pGroupBy = p->pGroupBy;\n        groupBySort = 0;\n      }else{\n        /* Rows are coming out in undetermined order.  We have to push\n        ** each row into a sorting index, terminate the first loop,\n        ** then loop over the sorting index in order to get the output\n        ** in sorted order\n        */\n        int regBase;\n        int regRecord;\n        int nCol;\n        int nGroupBy;\n\n        explainTempTable(pParse, \n            isDistinct && !(p->selFlags&SF_Distinct)?\"DISTINCT\":\"GROUP BY\");\n\n        groupBySort = 1;\n        nGroupBy = pGroupBy->nExpr;\n        nCol = nGroupBy + 1;\n        j = nGroupBy+1;\n        for(i=0; i<sAggInfo.nColumn; i++){\n          if( sAggInfo.aCol[i].iSorterColumn>=j ){\n            nCol++;\n            j++;\n          }\n        }\n        regBase = sqlite3GetTempRange(pParse, nCol);\n        sqlite3ExprCacheClear(pParse);\n        sqlite3ExprCodeExprList(pParse, pGroupBy, regBase, 0);\n        sqlite3VdbeAddOp2(v, OP_Sequence, sAggInfo.sortingIdx,regBase+nGroupBy);\n        j = nGroupBy+1;\n        for(i=0; i<sAggInfo.nColumn; i++){\n          struct AggInfo_col *pCol = &sAggInfo.aCol[i];\n          if( pCol->iSorterColumn>=j ){\n            int r1 = j + regBase;\n            int r2;\n\n            r2 = sqlite3ExprCodeGetColumn(pParse, \n                               pCol->pTab, pCol->iColumn, pCol->iTable, r1);\n            if( r1!=r2 ){\n              sqlite3VdbeAddOp2(v, OP_SCopy, r2, r1);\n            }\n            j++;\n          }\n        }\n        regRecord = sqlite3GetTempReg(pParse);\n        sqlite3VdbeAddOp3(v, OP_MakeRecord, regBase, nCol, regRecord);\n        sqlite3VdbeAddOp2(v, OP_IdxInsert, sAggInfo.sortingIdx, regRecord);\n        sqlite3ReleaseTempReg(pParse, regRecord);\n        sqlite3ReleaseTempRange(pParse, regBase, nCol);\n        sqlite3WhereEnd(pWInfo);\n        sqlite3VdbeAddOp2(v, OP_Sort, sAggInfo.sortingIdx, addrEnd);\n        VdbeComment((v, \"GROUP BY sort\"));\n        sAggInfo.useSortingIdx = 1;\n        sqlite3ExprCacheClear(pParse);\n      }\n\n      /* Evaluate the current GROUP BY terms and store in b0, b1, b2...\n      ** (b0 is memory location iBMem+0, b1 is iBMem+1, and so forth)\n      ** Then compare the current GROUP BY terms against the GROUP BY terms\n      ** from the previous row currently stored in a0, a1, a2...\n      */\n      addrTopOfLoop = sqlite3VdbeCurrentAddr(v);\n      sqlite3ExprCacheClear(pParse);\n      for(j=0; j<pGroupBy->nExpr; j++){\n        if( groupBySort ){\n          sqlite3VdbeAddOp3(v, OP_Column, sAggInfo.sortingIdx, j, iBMem+j);\n        }else{\n          sAggInfo.directMode = 1;\n          sqlite3ExprCode(pParse, pGroupBy->a[j].pExpr, iBMem+j);\n        }\n      }\n      sqlite3VdbeAddOp4(v, OP_Compare, iAMem, iBMem, pGroupBy->nExpr,\n                          (char*)pKeyInfo, P4_KEYINFO);\n      j1 = sqlite3VdbeCurrentAddr(v);\n      sqlite3VdbeAddOp3(v, OP_Jump, j1+1, 0, j1+1);\n\n      /* Generate code that runs whenever the GROUP BY changes.\n      ** Changes in the GROUP BY are detected by the previous code\n      ** block.  If there were no changes, this block is skipped.\n      **\n      ** This code copies current group by terms in b0,b1,b2,...\n      ** over to a0,a1,a2.  It then calls the output subroutine\n      ** and resets the aggregate accumulator registers in preparation\n      ** for the next GROUP BY batch.\n      */\n      sqlite3ExprCodeMove(pParse, iBMem, iAMem, pGroupBy->nExpr);\n      sqlite3VdbeAddOp2(v, OP_Gosub, regOutputRow, addrOutputRow);\n      VdbeComment((v, \"output one row\"));\n      sqlite3VdbeAddOp2(v, OP_IfPos, iAbortFlag, addrEnd);\n      VdbeComment((v, \"check abort flag\"));\n      sqlite3VdbeAddOp2(v, OP_Gosub, regReset, addrReset);\n      VdbeComment((v, \"reset accumulator\"));\n\n      /* Update the aggregate accumulators based on the content of\n      ** the current row\n      */\n      sqlite3VdbeJumpHere(v, j1);\n      updateAccumulator(pParse, &sAggInfo);\n      sqlite3VdbeAddOp2(v, OP_Integer, 1, iUseFlag);\n      VdbeComment((v, \"indicate data in accumulator\"));\n\n      /* End of the loop\n      */\n      if( groupBySort ){\n        sqlite3VdbeAddOp2(v, OP_Next, sAggInfo.sortingIdx, addrTopOfLoop);\n      }else{\n        sqlite3WhereEnd(pWInfo);\n        sqlite3VdbeChangeToNoop(v, addrSortingIdx, 1);\n      }\n\n      /* Output the final row of result\n      */\n      sqlite3VdbeAddOp2(v, OP_Gosub, regOutputRow, addrOutputRow);\n      VdbeComment((v, \"output final row\"));\n\n      /* Jump over the subroutines\n      */\n      sqlite3VdbeAddOp2(v, OP_Goto, 0, addrEnd);\n\n      /* Generate a subroutine that outputs a single row of the result\n      ** set.  This subroutine first looks at the iUseFlag.  If iUseFlag\n      ** is less than or equal to zero, the subroutine is a no-op.  If\n      ** the processing calls for the query to abort, this subroutine\n      ** increments the iAbortFlag memory location before returning in\n      ** order to signal the caller to abort.\n      */\n      addrSetAbort = sqlite3VdbeCurrentAddr(v);\n      sqlite3VdbeAddOp2(v, OP_Integer, 1, iAbortFlag);\n      VdbeComment((v, \"set abort flag\"));\n      sqlite3VdbeAddOp1(v, OP_Return, regOutputRow);\n      sqlite3VdbeResolveLabel(v, addrOutputRow);\n      addrOutputRow = sqlite3VdbeCurrentAddr(v);\n      sqlite3VdbeAddOp2(v, OP_IfPos, iUseFlag, addrOutputRow+2);\n      VdbeComment((v, \"Groupby result generator entry point\"));\n      sqlite3VdbeAddOp1(v, OP_Return, regOutputRow);\n      finalizeAggFunctions(pParse, &sAggInfo);\n      sqlite3ExprIfFalse(pParse, pHaving, addrOutputRow+1, SQLITE_JUMPIFNULL);\n      selectInnerLoop(pParse, p, p->pEList, 0, 0, pOrderBy,\n                      distinct, pDest,\n                      addrOutputRow+1, addrSetAbort);\n      sqlite3VdbeAddOp1(v, OP_Return, regOutputRow);\n      VdbeComment((v, \"end groupby result generator\"));\n\n      /* Generate a subroutine that will reset the group-by accumulator\n      */\n      sqlite3VdbeResolveLabel(v, addrReset);\n      resetAccumulator(pParse, &sAggInfo);\n      sqlite3VdbeAddOp1(v, OP_Return, regReset);\n     \n    } /* endif pGroupBy.  Begin aggregate queries without GROUP BY: */\n    else {\n      ExprList *pDel = 0;\n#ifndef SQLITE_OMIT_BTREECOUNT\n      Table *pTab;\n      if( (pTab = isSimpleCount(p, &sAggInfo))!=0 ){\n        /* If isSimpleCount() returns a pointer to a Table structure, then\n        ** the SQL statement is of the form:\n        **\n        **   SELECT count(*) FROM <tbl>\n        **\n        ** where the Table structure returned represents table <tbl>.\n        **\n        ** This statement is so common that it is optimized specially. The\n        ** OP_Count instruction is executed either on the intkey table that\n        ** contains the data for table <tbl> or on one of its indexes. It\n        ** is better to execute the op on an index, as indexes are almost\n        ** always spread across less pages than their corresponding tables.\n        */\n        const int iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);\n        const int iCsr = pParse->nTab++;     /* Cursor to scan b-tree */\n        Index *pIdx;                         /* Iterator variable */\n        KeyInfo *pKeyInfo = 0;               /* Keyinfo for scanned index */\n        Index *pBest = 0;                    /* Best index found so far */\n        int iRoot = pTab->tnum;              /* Root page of scanned b-tree */\n\n        sqlite3CodeVerifySchema(pParse, iDb);\n        sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);\n\n        /* Search for the index that has the least amount of columns. If\n        ** there is such an index, and it has less columns than the table\n        ** does, then we can assume that it consumes less space on disk and\n        ** will therefore be cheaper to scan to determine the query result.\n        ** In this case set iRoot to the root page number of the index b-tree\n        ** and pKeyInfo to the KeyInfo structure required to navigate the\n        ** index.\n        **\n        ** In practice the KeyInfo structure will not be used. It is only \n        ** passed to keep OP_OpenRead happy.\n        */\n        for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){\n          if( !pBest || pIdx->nColumn<pBest->nColumn ){\n            pBest = pIdx;\n          }\n        }\n        if( pBest && pBest->nColumn<pTab->nCol ){\n          iRoot = pBest->tnum;\n          pKeyInfo = sqlite3IndexKeyinfo(pParse, pBest);\n        }\n\n        /* Open a read-only cursor, execute the OP_Count, close the cursor. */\n        sqlite3VdbeAddOp3(v, OP_OpenRead, iCsr, iRoot, iDb);\n        if( pKeyInfo ){\n          sqlite3VdbeChangeP4(v, -1, (char *)pKeyInfo, P4_KEYINFO_HANDOFF);\n        }\n        sqlite3VdbeAddOp2(v, OP_Count, iCsr, sAggInfo.aFunc[0].iMem);\n        sqlite3VdbeAddOp1(v, OP_Close, iCsr);\n        explainSimpleCount(pParse, pTab, pBest);\n      }else\n#endif /* SQLITE_OMIT_BTREECOUNT */\n      {\n        /* Check if the query is of one of the following forms:\n        **\n        **   SELECT min(x) FROM ...\n        **   SELECT max(x) FROM ...\n        **\n        ** If it is, then ask the code in where.c to attempt to sort results\n        ** as if there was an \"ORDER ON x\" or \"ORDER ON x DESC\" clause. \n        ** If where.c is able to produce results sorted in this order, then\n        ** add vdbe code to break out of the processing loop after the \n        ** first iteration (since the first iteration of the loop is \n        ** guaranteed to operate on the row with the minimum or maximum \n        ** value of x, the only row required).\n        **\n        ** A special flag must be passed to sqlite3WhereBegin() to slightly\n        ** modify behaviour as follows:\n        **\n        **   + If the query is a \"SELECT min(x)\", then the loop coded by\n        **     where.c should not iterate over any values with a NULL value\n        **     for x.\n        **\n        **   + The optimizer code in where.c (the thing that decides which\n        **     index or indices to use) should place a different priority on \n        **     satisfying the 'ORDER BY' clause than it does in other cases.\n        **     Refer to code and comments in where.c for details.\n        */\n        ExprList *pMinMax = 0;\n        u8 flag = minMaxQuery(p);\n        if( flag ){\n          assert( !ExprHasProperty(p->pEList->a[0].pExpr, EP_xIsSelect) );\n          pMinMax = sqlite3ExprListDup(db, p->pEList->a[0].pExpr->x.pList,0);\n          pDel = pMinMax;\n          if( pMinMax && !db->mallocFailed ){\n            pMinMax->a[0].sortOrder = flag!=WHERE_ORDERBY_MIN ?1:0;\n            pMinMax->a[0].pExpr->op = TK_COLUMN;\n          }\n        }\n  \n        /* This case runs if the aggregate has no GROUP BY clause.  The\n        ** processing is much simpler since there is only a single row\n        ** of output.\n        */\n        resetAccumulator(pParse, &sAggInfo);\n        pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere, &pMinMax, flag);\n        if( pWInfo==0 ){\n          sqlite3ExprListDelete(db, pDel);\n          goto select_end;\n        }\n        updateAccumulator(pParse, &sAggInfo);\n        if( !pMinMax && flag ){\n          sqlite3VdbeAddOp2(v, OP_Goto, 0, pWInfo->iBreak);\n          VdbeComment((v, \"%s() by index\",\n                (flag==WHERE_ORDERBY_MIN?\"min\":\"max\")));\n        }\n        sqlite3WhereEnd(pWInfo);\n        finalizeAggFunctions(pParse, &sAggInfo);\n      }\n\n      pOrderBy = 0;\n      sqlite3ExprIfFalse(pParse, pHaving, addrEnd, SQLITE_JUMPIFNULL);\n      selectInnerLoop(pParse, p, p->pEList, 0, 0, 0, -1, \n                      pDest, addrEnd, addrEnd);\n      sqlite3ExprListDelete(db, pDel);\n    }\n    sqlite3VdbeResolveLabel(v, addrEnd);\n    \n  } /* endif aggregate query */\n\n  if( distinct>=0 ){\n    explainTempTable(pParse, \"DISTINCT\");\n  }\n\n  /* If there is an ORDER BY clause, then we need to sort the results\n  ** and send them to the callback one by one.\n  */\n  if( pOrderBy ){\n    explainTempTable(pParse, \"ORDER BY\");\n    generateSortTail(pParse, p, v, pEList->nExpr, pDest);\n  }\n\n  /* Jump here to skip this query\n  */\n  sqlite3VdbeResolveLabel(v, iEnd);\n\n  /* The SELECT was successfully coded.   Set the return code to 0\n  ** to indicate no errors.\n  */\n  rc = 0;\n\n  /* Control jumps to here if an error is encountered above, or upon\n  ** successful coding of the SELECT.\n  */\nselect_end:\n  explainSetInteger(pParse->iSelectId, iRestoreSelectId);\n\n  /* Identify column names if results of the SELECT are to be output.\n  */\n  if( rc==SQLITE_OK && pDest->eDest==SRT_Output ){\n    generateColumnNames(pParse, pTabList, pEList);\n  }\n\n  sqlite3DbFree(db, sAggInfo.aCol);\n  sqlite3DbFree(db, sAggInfo.aFunc);\n  return rc;\n}\n\n#if defined(SQLITE_DEBUG)\n/*\n*******************************************************************************\n** The following code is used for testing and debugging only.  The code\n** that follows does not appear in normal builds.\n**\n** These routines are used to print out the content of all or part of a \n** parse structures such as Select or Expr.  Such printouts are useful\n** for helping to understand what is happening inside the code generator\n** during the execution of complex SELECT statements.\n**\n** These routine are not called anywhere from within the normal\n** code base.  Then are intended to be called from within the debugger\n** or from temporary \"printf\" statements inserted for debugging.\n*/\nSQLITE_PRIVATE void sqlite3PrintExpr(Expr *p){\n  if( !ExprHasProperty(p, EP_IntValue) && p->u.zToken ){\n    sqlite3DebugPrintf(\"(%s\", p->u.zToken);\n  }else{\n    sqlite3DebugPrintf(\"(%d\", p->op);\n  }\n  if( p->pLeft ){\n    sqlite3DebugPrintf(\" \");\n    sqlite3PrintExpr(p->pLeft);\n  }\n  if( p->pRight ){\n    sqlite3DebugPrintf(\" \");\n    sqlite3PrintExpr(p->pRight);\n  }\n  sqlite3DebugPrintf(\")\");\n}\nSQLITE_PRIVATE void sqlite3PrintExprList(ExprList *pList){\n  int i;\n  for(i=0; i<pList->nExpr; i++){\n    sqlite3PrintExpr(pList->a[i].pExpr);\n    if( i<pList->nExpr-1 ){\n      sqlite3DebugPrintf(\", \");\n    }\n  }\n}\nSQLITE_PRIVATE void sqlite3PrintSelect(Select *p, int indent){\n  sqlite3DebugPrintf(\"%*sSELECT(%p) \", indent, \"\", p);\n  sqlite3PrintExprList(p->pEList);\n  sqlite3DebugPrintf(\"\\n\");\n  if( p->pSrc ){\n    char *zPrefix;\n    int i;\n    zPrefix = \"FROM\";\n    for(i=0; i<p->pSrc->nSrc; i++){\n      struct SrcList_item *pItem = &p->pSrc->a[i];\n      sqlite3DebugPrintf(\"%*s \", indent+6, zPrefix);\n      zPrefix = \"\";\n      if( pItem->pSelect ){\n        sqlite3DebugPrintf(\"(\\n\");\n        sqlite3PrintSelect(pItem->pSelect, indent+10);\n        sqlite3DebugPrintf(\"%*s)\", indent+8, \"\");\n      }else if( pItem->zName ){\n        sqlite3DebugPrintf(\"%s\", pItem->zName);\n      }\n      if( pItem->pTab ){\n        sqlite3DebugPrintf(\"(table: %s)\", pItem->pTab->zName);\n      }\n      if( pItem->zAlias ){\n        sqlite3DebugPrintf(\" AS %s\", pItem->zAlias);\n      }\n      if( i<p->pSrc->nSrc-1 ){\n        sqlite3DebugPrintf(\",\");\n      }\n      sqlite3DebugPrintf(\"\\n\");\n    }\n  }\n  if( p->pWhere ){\n    sqlite3DebugPrintf(\"%*s WHERE \", indent, \"\");\n    sqlite3PrintExpr(p->pWhere);\n    sqlite3DebugPrintf(\"\\n\");\n  }\n  if( p->pGroupBy ){\n    sqlite3DebugPrintf(\"%*s GROUP BY \", indent, \"\");\n    sqlite3PrintExprList(p->pGroupBy);\n    sqlite3DebugPrintf(\"\\n\");\n  }\n  if( p->pHaving ){\n    sqlite3DebugPrintf(\"%*s HAVING \", indent, \"\");\n    sqlite3PrintExpr(p->pHaving);\n    sqlite3DebugPrintf(\"\\n\");\n  }\n  if( p->pOrderBy ){\n    sqlite3DebugPrintf(\"%*s ORDER BY \", indent, \"\");\n    sqlite3PrintExprList(p->pOrderBy);\n    sqlite3DebugPrintf(\"\\n\");\n  }\n}\n/* End of the structure debug printing code\n*****************************************************************************/\n#endif /* defined(SQLITE_TEST) || defined(SQLITE_DEBUG) */\n\n/************** End of select.c **********************************************/\n/************** Begin file table.c *******************************************/\n/*\n** 2001 September 15\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains the sqlite3_get_table() and sqlite3_free_table()\n** interface routines.  These are just wrappers around the main\n** interface routine of sqlite3_exec().\n**\n** These routines are in a separate files so that they will not be linked\n** if they are not used.\n*/\n\n#ifndef SQLITE_OMIT_GET_TABLE\n\n/*\n** This structure is used to pass data from sqlite3_get_table() through\n** to the callback function is uses to build the result.\n*/\ntypedef struct TabResult {\n  char **azResult;   /* Accumulated output */\n  char *zErrMsg;     /* Error message text, if an error occurs */\n  int nAlloc;        /* Slots allocated for azResult[] */\n  int nRow;          /* Number of rows in the result */\n  int nColumn;       /* Number of columns in the result */\n  int nData;         /* Slots used in azResult[].  (nRow+1)*nColumn */\n  int rc;            /* Return code from sqlite3_exec() */\n} TabResult;\n\n/*\n** This routine is called once for each row in the result table.  Its job\n** is to fill in the TabResult structure appropriately, allocating new\n** memory as necessary.\n*/\nstatic int sqlite3_get_table_cb(void *pArg, int nCol, char **argv, char **colv){\n  TabResult *p = (TabResult*)pArg;  /* Result accumulator */\n  int need;                         /* Slots needed in p->azResult[] */\n  int i;                            /* Loop counter */\n  char *z;                          /* A single column of result */\n\n  /* Make sure there is enough space in p->azResult to hold everything\n  ** we need to remember from this invocation of the callback.\n  */\n  if( p->nRow==0 && argv!=0 ){\n    need = nCol*2;\n  }else{\n    need = nCol;\n  }\n  if( p->nData + need > p->nAlloc ){\n    char **azNew;\n    p->nAlloc = p->nAlloc*2 + need;\n    azNew = sqlite3_realloc( p->azResult, sizeof(char*)*p->nAlloc );\n    if( azNew==0 ) goto malloc_failed;\n    p->azResult = azNew;\n  }\n\n  /* If this is the first row, then generate an extra row containing\n  ** the names of all columns.\n  */\n  if( p->nRow==0 ){\n    p->nColumn = nCol;\n    for(i=0; i<nCol; i++){\n      z = sqlite3_mprintf(\"%s\", colv[i]);\n      if( z==0 ) goto malloc_failed;\n      p->azResult[p->nData++] = z;\n    }\n  }else if( p->nColumn!=nCol ){\n    sqlite3_free(p->zErrMsg);\n    p->zErrMsg = sqlite3_mprintf(\n       \"sqlite3_get_table() called with two or more incompatible queries\"\n    );\n    p->rc = SQLITE_ERROR;\n    return 1;\n  }\n\n  /* Copy over the row data\n  */\n  if( argv!=0 ){\n    for(i=0; i<nCol; i++){\n      if( argv[i]==0 ){\n        z = 0;\n      }else{\n        int n = sqlite3Strlen30(argv[i])+1;\n        z = sqlite3_malloc( n );\n        if( z==0 ) goto malloc_failed;\n        memcpy(z, argv[i], n);\n      }\n      p->azResult[p->nData++] = z;\n    }\n    p->nRow++;\n  }\n  return 0;\n\nmalloc_failed:\n  p->rc = SQLITE_NOMEM;\n  return 1;\n}\n\n/*\n** Query the database.  But instead of invoking a callback for each row,\n** malloc() for space to hold the result and return the entire results\n** at the conclusion of the call.\n**\n** The result that is written to ***pazResult is held in memory obtained\n** from malloc().  But the caller cannot free this memory directly.  \n** Instead, the entire table should be passed to sqlite3_free_table() when\n** the calling procedure is finished using it.\n*/\nSQLITE_API int sqlite3_get_table(\n  sqlite3 *db,                /* The database on which the SQL executes */\n  const char *zSql,           /* The SQL to be executed */\n  char ***pazResult,          /* Write the result table here */\n  int *pnRow,                 /* Write the number of rows in the result here */\n  int *pnColumn,              /* Write the number of columns of result here */\n  char **pzErrMsg             /* Write error messages here */\n){\n  int rc;\n  TabResult res;\n\n  *pazResult = 0;\n  if( pnColumn ) *pnColumn = 0;\n  if( pnRow ) *pnRow = 0;\n  if( pzErrMsg ) *pzErrMsg = 0;\n  res.zErrMsg = 0;\n  res.nRow = 0;\n  res.nColumn = 0;\n  res.nData = 1;\n  res.nAlloc = 20;\n  res.rc = SQLITE_OK;\n  res.azResult = sqlite3_malloc(sizeof(char*)*res.nAlloc );\n  if( res.azResult==0 ){\n     db->errCode = SQLITE_NOMEM;\n     return SQLITE_NOMEM;\n  }\n  res.azResult[0] = 0;\n  rc = sqlite3_exec(db, zSql, sqlite3_get_table_cb, &res, pzErrMsg);\n  assert( sizeof(res.azResult[0])>= sizeof(res.nData) );\n  res.azResult[0] = SQLITE_INT_TO_PTR(res.nData);\n  if( (rc&0xff)==SQLITE_ABORT ){\n    sqlite3_free_table(&res.azResult[1]);\n    if( res.zErrMsg ){\n      if( pzErrMsg ){\n        sqlite3_free(*pzErrMsg);\n        *pzErrMsg = sqlite3_mprintf(\"%s\",res.zErrMsg);\n      }\n      sqlite3_free(res.zErrMsg);\n    }\n    db->errCode = res.rc;  /* Assume 32-bit assignment is atomic */\n    return res.rc;\n  }\n  sqlite3_free(res.zErrMsg);\n  if( rc!=SQLITE_OK ){\n    sqlite3_free_table(&res.azResult[1]);\n    return rc;\n  }\n  if( res.nAlloc>res.nData ){\n    char **azNew;\n    azNew = sqlite3_realloc( res.azResult, sizeof(char*)*res.nData );\n    if( azNew==0 ){\n      sqlite3_free_table(&res.azResult[1]);\n      db->errCode = SQLITE_NOMEM;\n      return SQLITE_NOMEM;\n    }\n    res.azResult = azNew;\n  }\n  *pazResult = &res.azResult[1];\n  if( pnColumn ) *pnColumn = res.nColumn;\n  if( pnRow ) *pnRow = res.nRow;\n  return rc;\n}\n\n/*\n** This routine frees the space the sqlite3_get_table() malloced.\n*/\nSQLITE_API void sqlite3_free_table(\n  char **azResult            /* Result returned from from sqlite3_get_table() */\n){\n  if( azResult ){\n    int i, n;\n    azResult--;\n    assert( azResult!=0 );\n    n = SQLITE_PTR_TO_INT(azResult[0]);\n    for(i=1; i<n; i++){ if( azResult[i] ) sqlite3_free(azResult[i]); }\n    sqlite3_free(azResult);\n  }\n}\n\n#endif /* SQLITE_OMIT_GET_TABLE */\n\n/************** End of table.c ***********************************************/\n/************** Begin file trigger.c *****************************************/\n/*\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains the implementation for TRIGGERs\n*/\n\n#ifndef SQLITE_OMIT_TRIGGER\n/*\n** Delete a linked list of TriggerStep structures.\n*/\nSQLITE_PRIVATE void sqlite3DeleteTriggerStep(sqlite3 *db, TriggerStep *pTriggerStep){\n  while( pTriggerStep ){\n    TriggerStep * pTmp = pTriggerStep;\n    pTriggerStep = pTriggerStep->pNext;\n\n    sqlite3ExprDelete(db, pTmp->pWhere);\n    sqlite3ExprListDelete(db, pTmp->pExprList);\n    sqlite3SelectDelete(db, pTmp->pSelect);\n    sqlite3IdListDelete(db, pTmp->pIdList);\n\n    sqlite3DbFree(db, pTmp);\n  }\n}\n\n/*\n** Given table pTab, return a list of all the triggers attached to \n** the table. The list is connected by Trigger.pNext pointers.\n**\n** All of the triggers on pTab that are in the same database as pTab\n** are already attached to pTab->pTrigger.  But there might be additional\n** triggers on pTab in the TEMP schema.  This routine prepends all\n** TEMP triggers on pTab to the beginning of the pTab->pTrigger list\n** and returns the combined list.\n**\n** To state it another way:  This routine returns a list of all triggers\n** that fire off of pTab.  The list will include any TEMP triggers on\n** pTab as well as the triggers lised in pTab->pTrigger.\n*/\nSQLITE_PRIVATE Trigger *sqlite3TriggerList(Parse *pParse, Table *pTab){\n  Schema * const pTmpSchema = pParse->db->aDb[1].pSchema;\n  Trigger *pList = 0;                  /* List of triggers to return */\n\n  if( pParse->disableTriggers ){\n    return 0;\n  }\n\n  if( pTmpSchema!=pTab->pSchema ){\n    HashElem *p;\n    for(p=sqliteHashFirst(&pTmpSchema->trigHash); p; p=sqliteHashNext(p)){\n      Trigger *pTrig = (Trigger *)sqliteHashData(p);\n      if( pTrig->pTabSchema==pTab->pSchema\n       && 0==sqlite3StrICmp(pTrig->table, pTab->zName) \n      ){\n        pTrig->pNext = (pList ? pList : pTab->pTrigger);\n        pList = pTrig;\n      }\n    }\n  }\n\n  return (pList ? pList : pTab->pTrigger);\n}\n\n/*\n** This is called by the parser when it sees a CREATE TRIGGER statement\n** up to the point of the BEGIN before the trigger actions.  A Trigger\n** structure is generated based on the information available and stored\n** in pParse->pNewTrigger.  After the trigger actions have been parsed, the\n** sqlite3FinishTrigger() function is called to complete the trigger\n** construction process.\n*/\nSQLITE_PRIVATE void sqlite3BeginTrigger(\n  Parse *pParse,      /* The parse context of the CREATE TRIGGER statement */\n  Token *pName1,      /* The name of the trigger */\n  Token *pName2,      /* The name of the trigger */\n  int tr_tm,          /* One of TK_BEFORE, TK_AFTER, TK_INSTEAD */\n  int op,             /* One of TK_INSERT, TK_UPDATE, TK_DELETE */\n  IdList *pColumns,   /* column list if this is an UPDATE OF trigger */\n  SrcList *pTableName,/* The name of the table/view the trigger applies to */\n  Expr *pWhen,        /* WHEN clause */\n  int isTemp,         /* True if the TEMPORARY keyword is present */\n  int noErr           /* Suppress errors if the trigger already exists */\n){\n  Trigger *pTrigger = 0;  /* The new trigger */\n  Table *pTab;            /* Table that the trigger fires off of */\n  char *zName = 0;        /* Name of the trigger */\n  sqlite3 *db = pParse->db;  /* The database connection */\n  int iDb;                /* The database to store the trigger in */\n  Token *pName;           /* The unqualified db name */\n  DbFixer sFix;           /* State vector for the DB fixer */\n  int iTabDb;             /* Index of the database holding pTab */\n\n  assert( pName1!=0 );   /* pName1->z might be NULL, but not pName1 itself */\n  assert( pName2!=0 );\n  assert( op==TK_INSERT || op==TK_UPDATE || op==TK_DELETE );\n  assert( op>0 && op<0xff );\n  if( isTemp ){\n    /* If TEMP was specified, then the trigger name may not be qualified. */\n    if( pName2->n>0 ){\n      sqlite3ErrorMsg(pParse, \"temporary trigger may not have qualified name\");\n      goto trigger_cleanup;\n    }\n    iDb = 1;\n    pName = pName1;\n  }else{\n    /* Figure out the db that the the trigger will be created in */\n    iDb = sqlite3TwoPartName(pParse, pName1, pName2, &pName);\n    if( iDb<0 ){\n      goto trigger_cleanup;\n    }\n  }\n\n  /* If the trigger name was unqualified, and the table is a temp table,\n  ** then set iDb to 1 to create the trigger in the temporary database.\n  ** If sqlite3SrcListLookup() returns 0, indicating the table does not\n  ** exist, the error is caught by the block below.\n  */\n  if( !pTableName || db->mallocFailed ){\n    goto trigger_cleanup;\n  }\n  pTab = sqlite3SrcListLookup(pParse, pTableName);\n  if( db->init.busy==0 && pName2->n==0 && pTab\n        && pTab->pSchema==db->aDb[1].pSchema ){\n    iDb = 1;\n  }\n\n  /* Ensure the table name matches database name and that the table exists */\n  if( db->mallocFailed ) goto trigger_cleanup;\n  assert( pTableName->nSrc==1 );\n  if( sqlite3FixInit(&sFix, pParse, iDb, \"trigger\", pName) && \n      sqlite3FixSrcList(&sFix, pTableName) ){\n    goto trigger_cleanup;\n  }\n  pTab = sqlite3SrcListLookup(pParse, pTableName);\n  if( !pTab ){\n    /* The table does not exist. */\n    if( db->init.iDb==1 ){\n      /* Ticket #3810.\n      ** Normally, whenever a table is dropped, all associated triggers are\n      ** dropped too.  But if a TEMP trigger is created on a non-TEMP table\n      ** and the table is dropped by a different database connection, the\n      ** trigger is not visible to the database connection that does the\n      ** drop so the trigger cannot be dropped.  This results in an\n      ** \"orphaned trigger\" - a trigger whose associated table is missing.\n      */\n      db->init.orphanTrigger = 1;\n    }\n    goto trigger_cleanup;\n  }\n  if( IsVirtual(pTab) ){\n    sqlite3ErrorMsg(pParse, \"cannot create triggers on virtual tables\");\n    goto trigger_cleanup;\n  }\n\n  /* Check that the trigger name is not reserved and that no trigger of the\n  ** specified name exists */\n  zName = sqlite3NameFromToken(db, pName);\n  if( !zName || SQLITE_OK!=sqlite3CheckObjectName(pParse, zName) ){\n    goto trigger_cleanup;\n  }\n  if( sqlite3HashFind(&(db->aDb[iDb].pSchema->trigHash),\n                      zName, sqlite3Strlen30(zName)) ){\n    if( !noErr ){\n      sqlite3ErrorMsg(pParse, \"trigger %T already exists\", pName);\n    }\n    goto trigger_cleanup;\n  }\n\n  /* Do not create a trigger on a system table */\n  if( sqlite3StrNICmp(pTab->zName, \"sqlite_\", 7)==0 ){\n    sqlite3ErrorMsg(pParse, \"cannot create trigger on system table\");\n    pParse->nErr++;\n    goto trigger_cleanup;\n  }\n\n  /* INSTEAD of triggers are only for views and views only support INSTEAD\n  ** of triggers.\n  */\n  if( pTab->pSelect && tr_tm!=TK_INSTEAD ){\n    sqlite3ErrorMsg(pParse, \"cannot create %s trigger on view: %S\", \n        (tr_tm == TK_BEFORE)?\"BEFORE\":\"AFTER\", pTableName, 0);\n    goto trigger_cleanup;\n  }\n  if( !pTab->pSelect && tr_tm==TK_INSTEAD ){\n    sqlite3ErrorMsg(pParse, \"cannot create INSTEAD OF\"\n        \" trigger on table: %S\", pTableName, 0);\n    goto trigger_cleanup;\n  }\n  iTabDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n\n#ifndef SQLITE_OMIT_AUTHORIZATION\n  {\n    int code = SQLITE_CREATE_TRIGGER;\n    const char *zDb = db->aDb[iTabDb].zName;\n    const char *zDbTrig = isTemp ? db->aDb[1].zName : zDb;\n    if( iTabDb==1 || isTemp ) code = SQLITE_CREATE_TEMP_TRIGGER;\n    if( sqlite3AuthCheck(pParse, code, zName, pTab->zName, zDbTrig) ){\n      goto trigger_cleanup;\n    }\n    if( sqlite3AuthCheck(pParse, SQLITE_INSERT, SCHEMA_TABLE(iTabDb),0,zDb)){\n      goto trigger_cleanup;\n    }\n  }\n#endif\n\n  /* INSTEAD OF triggers can only appear on views and BEFORE triggers\n  ** cannot appear on views.  So we might as well translate every\n  ** INSTEAD OF trigger into a BEFORE trigger.  It simplifies code\n  ** elsewhere.\n  */\n  if (tr_tm == TK_INSTEAD){\n    tr_tm = TK_BEFORE;\n  }\n\n  /* Build the Trigger object */\n  pTrigger = (Trigger*)sqlite3DbMallocZero(db, sizeof(Trigger));\n  if( pTrigger==0 ) goto trigger_cleanup;\n  pTrigger->zName = zName;\n  zName = 0;\n  pTrigger->table = sqlite3DbStrDup(db, pTableName->a[0].zName);\n  pTrigger->pSchema = db->aDb[iDb].pSchema;\n  pTrigger->pTabSchema = pTab->pSchema;\n  pTrigger->op = (u8)op;\n  pTrigger->tr_tm = tr_tm==TK_BEFORE ? TRIGGER_BEFORE : TRIGGER_AFTER;\n  pTrigger->pWhen = sqlite3ExprDup(db, pWhen, EXPRDUP_REDUCE);\n  pTrigger->pColumns = sqlite3IdListDup(db, pColumns);\n  assert( pParse->pNewTrigger==0 );\n  pParse->pNewTrigger = pTrigger;\n\ntrigger_cleanup:\n  sqlite3DbFree(db, zName);\n  sqlite3SrcListDelete(db, pTableName);\n  sqlite3IdListDelete(db, pColumns);\n  sqlite3ExprDelete(db, pWhen);\n  if( !pParse->pNewTrigger ){\n    sqlite3DeleteTrigger(db, pTrigger);\n  }else{\n    assert( pParse->pNewTrigger==pTrigger );\n  }\n}\n\n/*\n** This routine is called after all of the trigger actions have been parsed\n** in order to complete the process of building the trigger.\n*/\nSQLITE_PRIVATE void sqlite3FinishTrigger(\n  Parse *pParse,          /* Parser context */\n  TriggerStep *pStepList, /* The triggered program */\n  Token *pAll             /* Token that describes the complete CREATE TRIGGER */\n){\n  Trigger *pTrig = pParse->pNewTrigger;   /* Trigger being finished */\n  char *zName;                            /* Name of trigger */\n  sqlite3 *db = pParse->db;               /* The database */\n  DbFixer sFix;                           /* Fixer object */\n  int iDb;                                /* Database containing the trigger */\n  Token nameToken;                        /* Trigger name for error reporting */\n\n  pParse->pNewTrigger = 0;\n  if( NEVER(pParse->nErr) || !pTrig ) goto triggerfinish_cleanup;\n  zName = pTrig->zName;\n  iDb = sqlite3SchemaToIndex(pParse->db, pTrig->pSchema);\n  pTrig->step_list = pStepList;\n  while( pStepList ){\n    pStepList->pTrig = pTrig;\n    pStepList = pStepList->pNext;\n  }\n  nameToken.z = pTrig->zName;\n  nameToken.n = sqlite3Strlen30(nameToken.z);\n  if( sqlite3FixInit(&sFix, pParse, iDb, \"trigger\", &nameToken) \n          && sqlite3FixTriggerStep(&sFix, pTrig->step_list) ){\n    goto triggerfinish_cleanup;\n  }\n\n  /* if we are not initializing,\n  ** build the sqlite_master entry\n  */\n  if( !db->init.busy ){\n    Vdbe *v;\n    char *z;\n\n    /* Make an entry in the sqlite_master table */\n    v = sqlite3GetVdbe(pParse);\n    if( v==0 ) goto triggerfinish_cleanup;\n    sqlite3BeginWriteOperation(pParse, 0, iDb);\n    z = sqlite3DbStrNDup(db, (char*)pAll->z, pAll->n);\n    sqlite3NestedParse(pParse,\n       \"INSERT INTO %Q.%s VALUES('trigger',%Q,%Q,0,'CREATE TRIGGER %q')\",\n       db->aDb[iDb].zName, SCHEMA_TABLE(iDb), zName,\n       pTrig->table, z);\n    sqlite3DbFree(db, z);\n    sqlite3ChangeCookie(pParse, iDb);\n    sqlite3VdbeAddOp4(v, OP_ParseSchema, iDb, 0, 0, sqlite3MPrintf(\n        db, \"type='trigger' AND name='%q'\", zName), P4_DYNAMIC\n    );\n  }\n\n  if( db->init.busy ){\n    Trigger *pLink = pTrig;\n    Hash *pHash = &db->aDb[iDb].pSchema->trigHash;\n    pTrig = sqlite3HashInsert(pHash, zName, sqlite3Strlen30(zName), pTrig);\n    if( pTrig ){\n      db->mallocFailed = 1;\n    }else if( pLink->pSchema==pLink->pTabSchema ){\n      Table *pTab;\n      int n = sqlite3Strlen30(pLink->table);\n      pTab = sqlite3HashFind(&pLink->pTabSchema->tblHash, pLink->table, n);\n      assert( pTab!=0 );\n      pLink->pNext = pTab->pTrigger;\n      pTab->pTrigger = pLink;\n    }\n  }\n\ntriggerfinish_cleanup:\n  sqlite3DeleteTrigger(db, pTrig);\n  assert( !pParse->pNewTrigger );\n  sqlite3DeleteTriggerStep(db, pStepList);\n}\n\n/*\n** Turn a SELECT statement (that the pSelect parameter points to) into\n** a trigger step.  Return a pointer to a TriggerStep structure.\n**\n** The parser calls this routine when it finds a SELECT statement in\n** body of a TRIGGER.  \n*/\nSQLITE_PRIVATE TriggerStep *sqlite3TriggerSelectStep(sqlite3 *db, Select *pSelect){\n  TriggerStep *pTriggerStep = sqlite3DbMallocZero(db, sizeof(TriggerStep));\n  if( pTriggerStep==0 ) {\n    sqlite3SelectDelete(db, pSelect);\n    return 0;\n  }\n  pTriggerStep->op = TK_SELECT;\n  pTriggerStep->pSelect = pSelect;\n  pTriggerStep->orconf = OE_Default;\n  return pTriggerStep;\n}\n\n/*\n** Allocate space to hold a new trigger step.  The allocated space\n** holds both the TriggerStep object and the TriggerStep.target.z string.\n**\n** If an OOM error occurs, NULL is returned and db->mallocFailed is set.\n*/\nstatic TriggerStep *triggerStepAllocate(\n  sqlite3 *db,                /* Database connection */\n  u8 op,                      /* Trigger opcode */\n  Token *pName                /* The target name */\n){\n  TriggerStep *pTriggerStep;\n\n  pTriggerStep = sqlite3DbMallocZero(db, sizeof(TriggerStep) + pName->n);\n  if( pTriggerStep ){\n    char *z = (char*)&pTriggerStep[1];\n    memcpy(z, pName->z, pName->n);\n    pTriggerStep->target.z = z;\n    pTriggerStep->target.n = pName->n;\n    pTriggerStep->op = op;\n  }\n  return pTriggerStep;\n}\n\n/*\n** Build a trigger step out of an INSERT statement.  Return a pointer\n** to the new trigger step.\n**\n** The parser calls this routine when it sees an INSERT inside the\n** body of a trigger.\n*/\nSQLITE_PRIVATE TriggerStep *sqlite3TriggerInsertStep(\n  sqlite3 *db,        /* The database connection */\n  Token *pTableName,  /* Name of the table into which we insert */\n  IdList *pColumn,    /* List of columns in pTableName to insert into */\n  ExprList *pEList,   /* The VALUE clause: a list of values to be inserted */\n  Select *pSelect,    /* A SELECT statement that supplies values */\n  u8 orconf           /* The conflict algorithm (OE_Abort, OE_Replace, etc.) */\n){\n  TriggerStep *pTriggerStep;\n\n  assert(pEList == 0 || pSelect == 0);\n  assert(pEList != 0 || pSelect != 0 || db->mallocFailed);\n\n  pTriggerStep = triggerStepAllocate(db, TK_INSERT, pTableName);\n  if( pTriggerStep ){\n    pTriggerStep->pSelect = sqlite3SelectDup(db, pSelect, EXPRDUP_REDUCE);\n    pTriggerStep->pIdList = pColumn;\n    pTriggerStep->pExprList = sqlite3ExprListDup(db, pEList, EXPRDUP_REDUCE);\n    pTriggerStep->orconf = orconf;\n  }else{\n    sqlite3IdListDelete(db, pColumn);\n  }\n  sqlite3ExprListDelete(db, pEList);\n  sqlite3SelectDelete(db, pSelect);\n\n  return pTriggerStep;\n}\n\n/*\n** Construct a trigger step that implements an UPDATE statement and return\n** a pointer to that trigger step.  The parser calls this routine when it\n** sees an UPDATE statement inside the body of a CREATE TRIGGER.\n*/\nSQLITE_PRIVATE TriggerStep *sqlite3TriggerUpdateStep(\n  sqlite3 *db,         /* The database connection */\n  Token *pTableName,   /* Name of the table to be updated */\n  ExprList *pEList,    /* The SET clause: list of column and new values */\n  Expr *pWhere,        /* The WHERE clause */\n  u8 orconf            /* The conflict algorithm. (OE_Abort, OE_Ignore, etc) */\n){\n  TriggerStep *pTriggerStep;\n\n  pTriggerStep = triggerStepAllocate(db, TK_UPDATE, pTableName);\n  if( pTriggerStep ){\n    pTriggerStep->pExprList = sqlite3ExprListDup(db, pEList, EXPRDUP_REDUCE);\n    pTriggerStep->pWhere = sqlite3ExprDup(db, pWhere, EXPRDUP_REDUCE);\n    pTriggerStep->orconf = orconf;\n  }\n  sqlite3ExprListDelete(db, pEList);\n  sqlite3ExprDelete(db, pWhere);\n  return pTriggerStep;\n}\n\n/*\n** Construct a trigger step that implements a DELETE statement and return\n** a pointer to that trigger step.  The parser calls this routine when it\n** sees a DELETE statement inside the body of a CREATE TRIGGER.\n*/\nSQLITE_PRIVATE TriggerStep *sqlite3TriggerDeleteStep(\n  sqlite3 *db,            /* Database connection */\n  Token *pTableName,      /* The table from which rows are deleted */\n  Expr *pWhere            /* The WHERE clause */\n){\n  TriggerStep *pTriggerStep;\n\n  pTriggerStep = triggerStepAllocate(db, TK_DELETE, pTableName);\n  if( pTriggerStep ){\n    pTriggerStep->pWhere = sqlite3ExprDup(db, pWhere, EXPRDUP_REDUCE);\n    pTriggerStep->orconf = OE_Default;\n  }\n  sqlite3ExprDelete(db, pWhere);\n  return pTriggerStep;\n}\n\n/* \n** Recursively delete a Trigger structure\n*/\nSQLITE_PRIVATE void sqlite3DeleteTrigger(sqlite3 *db, Trigger *pTrigger){\n  if( pTrigger==0 ) return;\n  sqlite3DeleteTriggerStep(db, pTrigger->step_list);\n  sqlite3DbFree(db, pTrigger->zName);\n  sqlite3DbFree(db, pTrigger->table);\n  sqlite3ExprDelete(db, pTrigger->pWhen);\n  sqlite3IdListDelete(db, pTrigger->pColumns);\n  sqlite3DbFree(db, pTrigger);\n}\n\n/*\n** This function is called to drop a trigger from the database schema. \n**\n** This may be called directly from the parser and therefore identifies\n** the trigger by name.  The sqlite3DropTriggerPtr() routine does the\n** same job as this routine except it takes a pointer to the trigger\n** instead of the trigger name.\n**/\nSQLITE_PRIVATE void sqlite3DropTrigger(Parse *pParse, SrcList *pName, int noErr){\n  Trigger *pTrigger = 0;\n  int i;\n  const char *zDb;\n  const char *zName;\n  int nName;\n  sqlite3 *db = pParse->db;\n\n  if( db->mallocFailed ) goto drop_trigger_cleanup;\n  if( SQLITE_OK!=sqlite3ReadSchema(pParse) ){\n    goto drop_trigger_cleanup;\n  }\n\n  assert( pName->nSrc==1 );\n  zDb = pName->a[0].zDatabase;\n  zName = pName->a[0].zName;\n  nName = sqlite3Strlen30(zName);\n  for(i=OMIT_TEMPDB; i<db->nDb; i++){\n    int j = (i<2) ? i^1 : i;  /* Search TEMP before MAIN */\n    if( zDb && sqlite3StrICmp(db->aDb[j].zName, zDb) ) continue;\n    pTrigger = sqlite3HashFind(&(db->aDb[j].pSchema->trigHash), zName, nName);\n    if( pTrigger ) break;\n  }\n  if( !pTrigger ){\n    if( !noErr ){\n      sqlite3ErrorMsg(pParse, \"no such trigger: %S\", pName, 0);\n    }\n    pParse->checkSchema = 1;\n    goto drop_trigger_cleanup;\n  }\n  sqlite3DropTriggerPtr(pParse, pTrigger);\n\ndrop_trigger_cleanup:\n  sqlite3SrcListDelete(db, pName);\n}\n\n/*\n** Return a pointer to the Table structure for the table that a trigger\n** is set on.\n*/\nstatic Table *tableOfTrigger(Trigger *pTrigger){\n  int n = sqlite3Strlen30(pTrigger->table);\n  return sqlite3HashFind(&pTrigger->pTabSchema->tblHash, pTrigger->table, n);\n}\n\n\n/*\n** Drop a trigger given a pointer to that trigger. \n*/\nSQLITE_PRIVATE void sqlite3DropTriggerPtr(Parse *pParse, Trigger *pTrigger){\n  Table   *pTable;\n  Vdbe *v;\n  sqlite3 *db = pParse->db;\n  int iDb;\n\n  iDb = sqlite3SchemaToIndex(pParse->db, pTrigger->pSchema);\n  assert( iDb>=0 && iDb<db->nDb );\n  pTable = tableOfTrigger(pTrigger);\n  assert( pTable );\n  assert( pTable->pSchema==pTrigger->pSchema || iDb==1 );\n#ifndef SQLITE_OMIT_AUTHORIZATION\n  {\n    int code = SQLITE_DROP_TRIGGER;\n    const char *zDb = db->aDb[iDb].zName;\n    const char *zTab = SCHEMA_TABLE(iDb);\n    if( iDb==1 ) code = SQLITE_DROP_TEMP_TRIGGER;\n    if( sqlite3AuthCheck(pParse, code, pTrigger->zName, pTable->zName, zDb) ||\n      sqlite3AuthCheck(pParse, SQLITE_DELETE, zTab, 0, zDb) ){\n      return;\n    }\n  }\n#endif\n\n  /* Generate code to destroy the database record of the trigger.\n  */\n  assert( pTable!=0 );\n  if( (v = sqlite3GetVdbe(pParse))!=0 ){\n    int base;\n    static const VdbeOpList dropTrigger[] = {\n      { OP_Rewind,     0, ADDR(9),  0},\n      { OP_String8,    0, 1,        0}, /* 1 */\n      { OP_Column,     0, 1,        2},\n      { OP_Ne,         2, ADDR(8),  1},\n      { OP_String8,    0, 1,        0}, /* 4: \"trigger\" */\n      { OP_Column,     0, 0,        2},\n      { OP_Ne,         2, ADDR(8),  1},\n      { OP_Delete,     0, 0,        0},\n      { OP_Next,       0, ADDR(1),  0}, /* 8 */\n    };\n\n    sqlite3BeginWriteOperation(pParse, 0, iDb);\n    sqlite3OpenMasterTable(pParse, iDb);\n    base = sqlite3VdbeAddOpList(v,  ArraySize(dropTrigger), dropTrigger);\n    sqlite3VdbeChangeP4(v, base+1, pTrigger->zName, 0);\n    sqlite3VdbeChangeP4(v, base+4, \"trigger\", P4_STATIC);\n    sqlite3ChangeCookie(pParse, iDb);\n    sqlite3VdbeAddOp2(v, OP_Close, 0, 0);\n    sqlite3VdbeAddOp4(v, OP_DropTrigger, iDb, 0, 0, pTrigger->zName, 0);\n    if( pParse->nMem<3 ){\n      pParse->nMem = 3;\n    }\n  }\n}\n\n/*\n** Remove a trigger from the hash tables of the sqlite* pointer.\n*/\nSQLITE_PRIVATE void sqlite3UnlinkAndDeleteTrigger(sqlite3 *db, int iDb, const char *zName){\n  Hash *pHash = &(db->aDb[iDb].pSchema->trigHash);\n  Trigger *pTrigger;\n  pTrigger = sqlite3HashInsert(pHash, zName, sqlite3Strlen30(zName), 0);\n  if( ALWAYS(pTrigger) ){\n    if( pTrigger->pSchema==pTrigger->pTabSchema ){\n      Table *pTab = tableOfTrigger(pTrigger);\n      Trigger **pp;\n      for(pp=&pTab->pTrigger; *pp!=pTrigger; pp=&((*pp)->pNext));\n      *pp = (*pp)->pNext;\n    }\n    sqlite3DeleteTrigger(db, pTrigger);\n    db->flags |= SQLITE_InternChanges;\n  }\n}\n\n/*\n** pEList is the SET clause of an UPDATE statement.  Each entry\n** in pEList is of the format <id>=<expr>.  If any of the entries\n** in pEList have an <id> which matches an identifier in pIdList,\n** then return TRUE.  If pIdList==NULL, then it is considered a\n** wildcard that matches anything.  Likewise if pEList==NULL then\n** it matches anything so always return true.  Return false only\n** if there is no match.\n*/\nstatic int checkColumnOverlap(IdList *pIdList, ExprList *pEList){\n  int e;\n  if( pIdList==0 || NEVER(pEList==0) ) return 1;\n  for(e=0; e<pEList->nExpr; e++){\n    if( sqlite3IdListIndex(pIdList, pEList->a[e].zName)>=0 ) return 1;\n  }\n  return 0; \n}\n\n/*\n** Return a list of all triggers on table pTab if there exists at least\n** one trigger that must be fired when an operation of type 'op' is \n** performed on the table, and, if that operation is an UPDATE, if at\n** least one of the columns in pChanges is being modified.\n*/\nSQLITE_PRIVATE Trigger *sqlite3TriggersExist(\n  Parse *pParse,          /* Parse context */\n  Table *pTab,            /* The table the contains the triggers */\n  int op,                 /* one of TK_DELETE, TK_INSERT, TK_UPDATE */\n  ExprList *pChanges,     /* Columns that change in an UPDATE statement */\n  int *pMask              /* OUT: Mask of TRIGGER_BEFORE|TRIGGER_AFTER */\n){\n  int mask = 0;\n  Trigger *pList = sqlite3TriggerList(pParse, pTab);\n  Trigger *p;\n  assert( pList==0 || IsVirtual(pTab)==0 );\n  for(p=pList; p; p=p->pNext){\n    if( p->op==op && checkColumnOverlap(p->pColumns, pChanges) ){\n      mask |= p->tr_tm;\n    }\n  }\n  if( pMask ){\n    *pMask = mask;\n  }\n  return (mask ? pList : 0);\n}\n\n/*\n** Convert the pStep->target token into a SrcList and return a pointer\n** to that SrcList.\n**\n** This routine adds a specific database name, if needed, to the target when\n** forming the SrcList.  This prevents a trigger in one database from\n** referring to a target in another database.  An exception is when the\n** trigger is in TEMP in which case it can refer to any other database it\n** wants.\n*/\nstatic SrcList *targetSrcList(\n  Parse *pParse,       /* The parsing context */\n  TriggerStep *pStep   /* The trigger containing the target token */\n){\n  int iDb;             /* Index of the database to use */\n  SrcList *pSrc;       /* SrcList to be returned */\n\n  pSrc = sqlite3SrcListAppend(pParse->db, 0, &pStep->target, 0);\n  if( pSrc ){\n    assert( pSrc->nSrc>0 );\n    assert( pSrc->a!=0 );\n    iDb = sqlite3SchemaToIndex(pParse->db, pStep->pTrig->pSchema);\n    if( iDb==0 || iDb>=2 ){\n      sqlite3 *db = pParse->db;\n      assert( iDb<pParse->db->nDb );\n      pSrc->a[pSrc->nSrc-1].zDatabase = sqlite3DbStrDup(db, db->aDb[iDb].zName);\n    }\n  }\n  return pSrc;\n}\n\n/*\n** Generate VDBE code for the statements inside the body of a single \n** trigger.\n*/\nstatic int codeTriggerProgram(\n  Parse *pParse,            /* The parser context */\n  TriggerStep *pStepList,   /* List of statements inside the trigger body */\n  int orconf                /* Conflict algorithm. (OE_Abort, etc) */  \n){\n  TriggerStep *pStep;\n  Vdbe *v = pParse->pVdbe;\n  sqlite3 *db = pParse->db;\n\n  assert( pParse->pTriggerTab && pParse->pToplevel );\n  assert( pStepList );\n  assert( v!=0 );\n  for(pStep=pStepList; pStep; pStep=pStep->pNext){\n    /* Figure out the ON CONFLICT policy that will be used for this step\n    ** of the trigger program. If the statement that caused this trigger\n    ** to fire had an explicit ON CONFLICT, then use it. Otherwise, use\n    ** the ON CONFLICT policy that was specified as part of the trigger\n    ** step statement. Example:\n    **\n    **   CREATE TRIGGER AFTER INSERT ON t1 BEGIN;\n    **     INSERT OR REPLACE INTO t2 VALUES(new.a, new.b);\n    **   END;\n    **\n    **   INSERT INTO t1 ... ;            -- insert into t2 uses REPLACE policy\n    **   INSERT OR IGNORE INTO t1 ... ;  -- insert into t2 uses IGNORE policy\n    */\n    pParse->eOrconf = (orconf==OE_Default)?pStep->orconf:(u8)orconf;\n\n    switch( pStep->op ){\n      case TK_UPDATE: {\n        sqlite3Update(pParse, \n          targetSrcList(pParse, pStep),\n          sqlite3ExprListDup(db, pStep->pExprList, 0), \n          sqlite3ExprDup(db, pStep->pWhere, 0), \n          pParse->eOrconf\n        );\n        break;\n      }\n      case TK_INSERT: {\n        sqlite3Insert(pParse, \n          targetSrcList(pParse, pStep),\n          sqlite3ExprListDup(db, pStep->pExprList, 0), \n          sqlite3SelectDup(db, pStep->pSelect, 0), \n          sqlite3IdListDup(db, pStep->pIdList), \n          pParse->eOrconf\n        );\n        break;\n      }\n      case TK_DELETE: {\n        sqlite3DeleteFrom(pParse, \n          targetSrcList(pParse, pStep),\n          sqlite3ExprDup(db, pStep->pWhere, 0)\n        );\n        break;\n      }\n      default: assert( pStep->op==TK_SELECT ); {\n        SelectDest sDest;\n        Select *pSelect = sqlite3SelectDup(db, pStep->pSelect, 0);\n        sqlite3SelectDestInit(&sDest, SRT_Discard, 0);\n        sqlite3Select(pParse, pSelect, &sDest);\n        sqlite3SelectDelete(db, pSelect);\n        break;\n      }\n    } \n    if( pStep->op!=TK_SELECT ){\n      sqlite3VdbeAddOp0(v, OP_ResetCount);\n    }\n  }\n\n  return 0;\n}\n\n#ifdef SQLITE_DEBUG\n/*\n** This function is used to add VdbeComment() annotations to a VDBE\n** program. It is not used in production code, only for debugging.\n*/\nstatic const char *onErrorText(int onError){\n  switch( onError ){\n    case OE_Abort:    return \"abort\";\n    case OE_Rollback: return \"rollback\";\n    case OE_Fail:     return \"fail\";\n    case OE_Replace:  return \"replace\";\n    case OE_Ignore:   return \"ignore\";\n    case OE_Default:  return \"default\";\n  }\n  return \"n/a\";\n}\n#endif\n\n/*\n** Parse context structure pFrom has just been used to create a sub-vdbe\n** (trigger program). If an error has occurred, transfer error information\n** from pFrom to pTo.\n*/\nstatic void transferParseError(Parse *pTo, Parse *pFrom){\n  assert( pFrom->zErrMsg==0 || pFrom->nErr );\n  assert( pTo->zErrMsg==0 || pTo->nErr );\n  if( pTo->nErr==0 ){\n    pTo->zErrMsg = pFrom->zErrMsg;\n    pTo->nErr = pFrom->nErr;\n  }else{\n    sqlite3DbFree(pFrom->db, pFrom->zErrMsg);\n  }\n}\n\n/*\n** Create and populate a new TriggerPrg object with a sub-program \n** implementing trigger pTrigger with ON CONFLICT policy orconf.\n*/\nstatic TriggerPrg *codeRowTrigger(\n  Parse *pParse,       /* Current parse context */\n  Trigger *pTrigger,   /* Trigger to code */\n  Table *pTab,         /* The table pTrigger is attached to */\n  int orconf           /* ON CONFLICT policy to code trigger program with */\n){\n  Parse *pTop = sqlite3ParseToplevel(pParse);\n  sqlite3 *db = pParse->db;   /* Database handle */\n  TriggerPrg *pPrg;           /* Value to return */\n  Expr *pWhen = 0;            /* Duplicate of trigger WHEN expression */\n  Vdbe *v;                    /* Temporary VM */\n  NameContext sNC;            /* Name context for sub-vdbe */\n  SubProgram *pProgram = 0;   /* Sub-vdbe for trigger program */\n  Parse *pSubParse;           /* Parse context for sub-vdbe */\n  int iEndTrigger = 0;        /* Label to jump to if WHEN is false */\n\n  assert( pTrigger->zName==0 || pTab==tableOfTrigger(pTrigger) );\n  assert( pTop->pVdbe );\n\n  /* Allocate the TriggerPrg and SubProgram objects. To ensure that they\n  ** are freed if an error occurs, link them into the Parse.pTriggerPrg \n  ** list of the top-level Parse object sooner rather than later.  */\n  pPrg = sqlite3DbMallocZero(db, sizeof(TriggerPrg));\n  if( !pPrg ) return 0;\n  pPrg->pNext = pTop->pTriggerPrg;\n  pTop->pTriggerPrg = pPrg;\n  pPrg->pProgram = pProgram = sqlite3DbMallocZero(db, sizeof(SubProgram));\n  if( !pProgram ) return 0;\n  sqlite3VdbeLinkSubProgram(pTop->pVdbe, pProgram);\n  pPrg->pTrigger = pTrigger;\n  pPrg->orconf = orconf;\n  pPrg->aColmask[0] = 0xffffffff;\n  pPrg->aColmask[1] = 0xffffffff;\n\n  /* Allocate and populate a new Parse context to use for coding the \n  ** trigger sub-program.  */\n  pSubParse = sqlite3StackAllocZero(db, sizeof(Parse));\n  if( !pSubParse ) return 0;\n  memset(&sNC, 0, sizeof(sNC));\n  sNC.pParse = pSubParse;\n  pSubParse->db = db;\n  pSubParse->pTriggerTab = pTab;\n  pSubParse->pToplevel = pTop;\n  pSubParse->zAuthContext = pTrigger->zName;\n  pSubParse->eTriggerOp = pTrigger->op;\n  pSubParse->nQueryLoop = pParse->nQueryLoop;\n\n  v = sqlite3GetVdbe(pSubParse);\n  if( v ){\n    VdbeComment((v, \"Start: %s.%s (%s %s%s%s ON %s)\", \n      pTrigger->zName, onErrorText(orconf),\n      (pTrigger->tr_tm==TRIGGER_BEFORE ? \"BEFORE\" : \"AFTER\"),\n        (pTrigger->op==TK_UPDATE ? \"UPDATE\" : \"\"),\n        (pTrigger->op==TK_INSERT ? \"INSERT\" : \"\"),\n        (pTrigger->op==TK_DELETE ? \"DELETE\" : \"\"),\n      pTab->zName\n    ));\n#ifndef SQLITE_OMIT_TRACE\n    sqlite3VdbeChangeP4(v, -1, \n      sqlite3MPrintf(db, \"-- TRIGGER %s\", pTrigger->zName), P4_DYNAMIC\n    );\n#endif\n\n    /* If one was specified, code the WHEN clause. If it evaluates to false\n    ** (or NULL) the sub-vdbe is immediately halted by jumping to the \n    ** OP_Halt inserted at the end of the program.  */\n    if( pTrigger->pWhen ){\n      pWhen = sqlite3ExprDup(db, pTrigger->pWhen, 0);\n      if( SQLITE_OK==sqlite3ResolveExprNames(&sNC, pWhen) \n       && db->mallocFailed==0 \n      ){\n        iEndTrigger = sqlite3VdbeMakeLabel(v);\n        sqlite3ExprIfFalse(pSubParse, pWhen, iEndTrigger, SQLITE_JUMPIFNULL);\n      }\n      sqlite3ExprDelete(db, pWhen);\n    }\n\n    /* Code the trigger program into the sub-vdbe. */\n    codeTriggerProgram(pSubParse, pTrigger->step_list, orconf);\n\n    /* Insert an OP_Halt at the end of the sub-program. */\n    if( iEndTrigger ){\n      sqlite3VdbeResolveLabel(v, iEndTrigger);\n    }\n    sqlite3VdbeAddOp0(v, OP_Halt);\n    VdbeComment((v, \"End: %s.%s\", pTrigger->zName, onErrorText(orconf)));\n\n    transferParseError(pParse, pSubParse);\n    if( db->mallocFailed==0 ){\n      pProgram->aOp = sqlite3VdbeTakeOpArray(v, &pProgram->nOp, &pTop->nMaxArg);\n    }\n    pProgram->nMem = pSubParse->nMem;\n    pProgram->nCsr = pSubParse->nTab;\n    pProgram->token = (void *)pTrigger;\n    pPrg->aColmask[0] = pSubParse->oldmask;\n    pPrg->aColmask[1] = pSubParse->newmask;\n    sqlite3VdbeDelete(v);\n  }\n\n  assert( !pSubParse->pAinc       && !pSubParse->pZombieTab );\n  assert( !pSubParse->pTriggerPrg && !pSubParse->nMaxArg );\n  sqlite3StackFree(db, pSubParse);\n\n  return pPrg;\n}\n    \n/*\n** Return a pointer to a TriggerPrg object containing the sub-program for\n** trigger pTrigger with default ON CONFLICT algorithm orconf. If no such\n** TriggerPrg object exists, a new object is allocated and populated before\n** being returned.\n*/\nstatic TriggerPrg *getRowTrigger(\n  Parse *pParse,       /* Current parse context */\n  Trigger *pTrigger,   /* Trigger to code */\n  Table *pTab,         /* The table trigger pTrigger is attached to */\n  int orconf           /* ON CONFLICT algorithm. */\n){\n  Parse *pRoot = sqlite3ParseToplevel(pParse);\n  TriggerPrg *pPrg;\n\n  assert( pTrigger->zName==0 || pTab==tableOfTrigger(pTrigger) );\n\n  /* It may be that this trigger has already been coded (or is in the\n  ** process of being coded). If this is the case, then an entry with\n  ** a matching TriggerPrg.pTrigger field will be present somewhere\n  ** in the Parse.pTriggerPrg list. Search for such an entry.  */\n  for(pPrg=pRoot->pTriggerPrg; \n      pPrg && (pPrg->pTrigger!=pTrigger || pPrg->orconf!=orconf); \n      pPrg=pPrg->pNext\n  );\n\n  /* If an existing TriggerPrg could not be located, create a new one. */\n  if( !pPrg ){\n    pPrg = codeRowTrigger(pParse, pTrigger, pTab, orconf);\n  }\n\n  return pPrg;\n}\n\n/*\n** Generate code for the trigger program associated with trigger p on \n** table pTab. The reg, orconf and ignoreJump parameters passed to this\n** function are the same as those described in the header function for\n** sqlite3CodeRowTrigger()\n*/\nSQLITE_PRIVATE void sqlite3CodeRowTriggerDirect(\n  Parse *pParse,       /* Parse context */\n  Trigger *p,          /* Trigger to code */\n  Table *pTab,         /* The table to code triggers from */\n  int reg,             /* Reg array containing OLD.* and NEW.* values */\n  int orconf,          /* ON CONFLICT policy */\n  int ignoreJump       /* Instruction to jump to for RAISE(IGNORE) */\n){\n  Vdbe *v = sqlite3GetVdbe(pParse); /* Main VM */\n  TriggerPrg *pPrg;\n  pPrg = getRowTrigger(pParse, p, pTab, orconf);\n  assert( pPrg || pParse->nErr || pParse->db->mallocFailed );\n\n  /* Code the OP_Program opcode in the parent VDBE. P4 of the OP_Program \n  ** is a pointer to the sub-vdbe containing the trigger program.  */\n  if( pPrg ){\n    int bRecursive = (p->zName && 0==(pParse->db->flags&SQLITE_RecTriggers));\n\n    sqlite3VdbeAddOp3(v, OP_Program, reg, ignoreJump, ++pParse->nMem);\n    sqlite3VdbeChangeP4(v, -1, (const char *)pPrg->pProgram, P4_SUBPROGRAM);\n    VdbeComment(\n        (v, \"Call: %s.%s\", (p->zName?p->zName:\"fkey\"), onErrorText(orconf)));\n\n    /* Set the P5 operand of the OP_Program instruction to non-zero if\n    ** recursive invocation of this trigger program is disallowed. Recursive\n    ** invocation is disallowed if (a) the sub-program is really a trigger,\n    ** not a foreign key action, and (b) the flag to enable recursive triggers\n    ** is clear.  */\n    sqlite3VdbeChangeP5(v, (u8)bRecursive);\n  }\n}\n\n/*\n** This is called to code the required FOR EACH ROW triggers for an operation\n** on table pTab. The operation to code triggers for (INSERT, UPDATE or DELETE)\n** is given by the op paramater. The tr_tm parameter determines whether the\n** BEFORE or AFTER triggers are coded. If the operation is an UPDATE, then\n** parameter pChanges is passed the list of columns being modified.\n**\n** If there are no triggers that fire at the specified time for the specified\n** operation on pTab, this function is a no-op.\n**\n** The reg argument is the address of the first in an array of registers \n** that contain the values substituted for the new.* and old.* references\n** in the trigger program. If N is the number of columns in table pTab\n** (a copy of pTab->nCol), then registers are populated as follows:\n**\n**   Register       Contains\n**   ------------------------------------------------------\n**   reg+0          OLD.rowid\n**   reg+1          OLD.* value of left-most column of pTab\n**   ...            ...\n**   reg+N          OLD.* value of right-most column of pTab\n**   reg+N+1        NEW.rowid\n**   reg+N+2        OLD.* value of left-most column of pTab\n**   ...            ...\n**   reg+N+N+1      NEW.* value of right-most column of pTab\n**\n** For ON DELETE triggers, the registers containing the NEW.* values will\n** never be accessed by the trigger program, so they are not allocated or \n** populated by the caller (there is no data to populate them with anyway). \n** Similarly, for ON INSERT triggers the values stored in the OLD.* registers\n** are never accessed, and so are not allocated by the caller. So, for an\n** ON INSERT trigger, the value passed to this function as parameter reg\n** is not a readable register, although registers (reg+N) through \n** (reg+N+N+1) are.\n**\n** Parameter orconf is the default conflict resolution algorithm for the\n** trigger program to use (REPLACE, IGNORE etc.). Parameter ignoreJump\n** is the instruction that control should jump to if a trigger program\n** raises an IGNORE exception.\n*/\nSQLITE_PRIVATE void sqlite3CodeRowTrigger(\n  Parse *pParse,       /* Parse context */\n  Trigger *pTrigger,   /* List of triggers on table pTab */\n  int op,              /* One of TK_UPDATE, TK_INSERT, TK_DELETE */\n  ExprList *pChanges,  /* Changes list for any UPDATE OF triggers */\n  int tr_tm,           /* One of TRIGGER_BEFORE, TRIGGER_AFTER */\n  Table *pTab,         /* The table to code triggers from */\n  int reg,             /* The first in an array of registers (see above) */\n  int orconf,          /* ON CONFLICT policy */\n  int ignoreJump       /* Instruction to jump to for RAISE(IGNORE) */\n){\n  Trigger *p;          /* Used to iterate through pTrigger list */\n\n  assert( op==TK_UPDATE || op==TK_INSERT || op==TK_DELETE );\n  assert( tr_tm==TRIGGER_BEFORE || tr_tm==TRIGGER_AFTER );\n  assert( (op==TK_UPDATE)==(pChanges!=0) );\n\n  for(p=pTrigger; p; p=p->pNext){\n\n    /* Sanity checking:  The schema for the trigger and for the table are\n    ** always defined.  The trigger must be in the same schema as the table\n    ** or else it must be a TEMP trigger. */\n    assert( p->pSchema!=0 );\n    assert( p->pTabSchema!=0 );\n    assert( p->pSchema==p->pTabSchema \n         || p->pSchema==pParse->db->aDb[1].pSchema );\n\n    /* Determine whether we should code this trigger */\n    if( p->op==op \n     && p->tr_tm==tr_tm \n     && checkColumnOverlap(p->pColumns, pChanges)\n    ){\n      sqlite3CodeRowTriggerDirect(pParse, p, pTab, reg, orconf, ignoreJump);\n    }\n  }\n}\n\n/*\n** Triggers may access values stored in the old.* or new.* pseudo-table. \n** This function returns a 32-bit bitmask indicating which columns of the \n** old.* or new.* tables actually are used by triggers. This information \n** may be used by the caller, for example, to avoid having to load the entire\n** old.* record into memory when executing an UPDATE or DELETE command.\n**\n** Bit 0 of the returned mask is set if the left-most column of the\n** table may be accessed using an [old|new].<col> reference. Bit 1 is set if\n** the second leftmost column value is required, and so on. If there\n** are more than 32 columns in the table, and at least one of the columns\n** with an index greater than 32 may be accessed, 0xffffffff is returned.\n**\n** It is not possible to determine if the old.rowid or new.rowid column is \n** accessed by triggers. The caller must always assume that it is.\n**\n** Parameter isNew must be either 1 or 0. If it is 0, then the mask returned\n** applies to the old.* table. If 1, the new.* table.\n**\n** Parameter tr_tm must be a mask with one or both of the TRIGGER_BEFORE\n** and TRIGGER_AFTER bits set. Values accessed by BEFORE triggers are only\n** included in the returned mask if the TRIGGER_BEFORE bit is set in the\n** tr_tm parameter. Similarly, values accessed by AFTER triggers are only\n** included in the returned mask if the TRIGGER_AFTER bit is set in tr_tm.\n*/\nSQLITE_PRIVATE u32 sqlite3TriggerColmask(\n  Parse *pParse,       /* Parse context */\n  Trigger *pTrigger,   /* List of triggers on table pTab */\n  ExprList *pChanges,  /* Changes list for any UPDATE OF triggers */\n  int isNew,           /* 1 for new.* ref mask, 0 for old.* ref mask */\n  int tr_tm,           /* Mask of TRIGGER_BEFORE|TRIGGER_AFTER */\n  Table *pTab,         /* The table to code triggers from */\n  int orconf           /* Default ON CONFLICT policy for trigger steps */\n){\n  const int op = pChanges ? TK_UPDATE : TK_DELETE;\n  u32 mask = 0;\n  Trigger *p;\n\n  assert( isNew==1 || isNew==0 );\n  for(p=pTrigger; p; p=p->pNext){\n    if( p->op==op && (tr_tm&p->tr_tm)\n     && checkColumnOverlap(p->pColumns,pChanges)\n    ){\n      TriggerPrg *pPrg;\n      pPrg = getRowTrigger(pParse, p, pTab, orconf);\n      if( pPrg ){\n        mask |= pPrg->aColmask[isNew];\n      }\n    }\n  }\n\n  return mask;\n}\n\n#endif /* !defined(SQLITE_OMIT_TRIGGER) */\n\n/************** End of trigger.c *********************************************/\n/************** Begin file update.c ******************************************/\n/*\n** 2001 September 15\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains C code routines that are called by the parser\n** to handle UPDATE statements.\n*/\n\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n/* Forward declaration */\nstatic void updateVirtualTable(\n  Parse *pParse,       /* The parsing context */\n  SrcList *pSrc,       /* The virtual table to be modified */\n  Table *pTab,         /* The virtual table */\n  ExprList *pChanges,  /* The columns to change in the UPDATE statement */\n  Expr *pRowidExpr,    /* Expression used to recompute the rowid */\n  int *aXRef,          /* Mapping from columns of pTab to entries in pChanges */\n  Expr *pWhere         /* WHERE clause of the UPDATE statement */\n);\n#endif /* SQLITE_OMIT_VIRTUALTABLE */\n\n/*\n** The most recently coded instruction was an OP_Column to retrieve the\n** i-th column of table pTab. This routine sets the P4 parameter of the \n** OP_Column to the default value, if any.\n**\n** The default value of a column is specified by a DEFAULT clause in the \n** column definition. This was either supplied by the user when the table\n** was created, or added later to the table definition by an ALTER TABLE\n** command. If the latter, then the row-records in the table btree on disk\n** may not contain a value for the column and the default value, taken\n** from the P4 parameter of the OP_Column instruction, is returned instead.\n** If the former, then all row-records are guaranteed to include a value\n** for the column and the P4 value is not required.\n**\n** Column definitions created by an ALTER TABLE command may only have \n** literal default values specified: a number, null or a string. (If a more\n** complicated default expression value was provided, it is evaluated \n** when the ALTER TABLE is executed and one of the literal values written\n** into the sqlite_master table.)\n**\n** Therefore, the P4 parameter is only required if the default value for\n** the column is a literal number, string or null. The sqlite3ValueFromExpr()\n** function is capable of transforming these types of expressions into\n** sqlite3_value objects.\n**\n** If parameter iReg is not negative, code an OP_RealAffinity instruction\n** on register iReg. This is used when an equivalent integer value is \n** stored in place of an 8-byte floating point value in order to save \n** space.\n*/\nSQLITE_PRIVATE void sqlite3ColumnDefault(Vdbe *v, Table *pTab, int i, int iReg){\n  assert( pTab!=0 );\n  if( !pTab->pSelect ){\n    sqlite3_value *pValue;\n    u8 enc = ENC(sqlite3VdbeDb(v));\n    Column *pCol = &pTab->aCol[i];\n    VdbeComment((v, \"%s.%s\", pTab->zName, pCol->zName));\n    assert( i<pTab->nCol );\n    sqlite3ValueFromExpr(sqlite3VdbeDb(v), pCol->pDflt, enc, \n                         pCol->affinity, &pValue);\n    if( pValue ){\n      sqlite3VdbeChangeP4(v, -1, (const char *)pValue, P4_MEM);\n    }\n#ifndef SQLITE_OMIT_FLOATING_POINT\n    if( iReg>=0 && pTab->aCol[i].affinity==SQLITE_AFF_REAL ){\n      sqlite3VdbeAddOp1(v, OP_RealAffinity, iReg);\n    }\n#endif\n  }\n}\n\n/*\n** Process an UPDATE statement.\n**\n**   UPDATE OR IGNORE table_wxyz SET a=b, c=d WHERE e<5 AND f NOT NULL;\n**          \\_______/ \\________/     \\______/       \\________________/\n*            onError   pTabList      pChanges             pWhere\n*/\nSQLITE_PRIVATE void sqlite3Update(\n  Parse *pParse,         /* The parser context */\n  SrcList *pTabList,     /* The table in which we should change things */\n  ExprList *pChanges,    /* Things to be changed */\n  Expr *pWhere,          /* The WHERE clause.  May be null */\n  int onError            /* How to handle constraint errors */\n){\n  int i, j;              /* Loop counters */\n  Table *pTab;           /* The table to be updated */\n  int addr = 0;          /* VDBE instruction address of the start of the loop */\n  WhereInfo *pWInfo;     /* Information about the WHERE clause */\n  Vdbe *v;               /* The virtual database engine */\n  Index *pIdx;           /* For looping over indices */\n  int nIdx;              /* Number of indices that need updating */\n  int iCur;              /* VDBE Cursor number of pTab */\n  sqlite3 *db;           /* The database structure */\n  int *aRegIdx = 0;      /* One register assigned to each index to be updated */\n  int *aXRef = 0;        /* aXRef[i] is the index in pChanges->a[] of the\n                         ** an expression for the i-th column of the table.\n                         ** aXRef[i]==-1 if the i-th column is not changed. */\n  int chngRowid;         /* True if the record number is being changed */\n  Expr *pRowidExpr = 0;  /* Expression defining the new record number */\n  int openAll = 0;       /* True if all indices need to be opened */\n  AuthContext sContext;  /* The authorization context */\n  NameContext sNC;       /* The name-context to resolve expressions in */\n  int iDb;               /* Database containing the table being updated */\n  int okOnePass;         /* True for one-pass algorithm without the FIFO */\n  int hasFK;             /* True if foreign key processing is required */\n\n#ifndef SQLITE_OMIT_TRIGGER\n  int isView;            /* True when updating a view (INSTEAD OF trigger) */\n  Trigger *pTrigger;     /* List of triggers on pTab, if required */\n  int tmask;             /* Mask of TRIGGER_BEFORE|TRIGGER_AFTER */\n#endif\n  int newmask;           /* Mask of NEW.* columns accessed by BEFORE triggers */\n\n  /* Register Allocations */\n  int regRowCount = 0;   /* A count of rows changed */\n  int regOldRowid;       /* The old rowid */\n  int regNewRowid;       /* The new rowid */\n  int regNew;\n  int regOld = 0;\n  int regRowSet = 0;     /* Rowset of rows to be updated */\n\n  memset(&sContext, 0, sizeof(sContext));\n  db = pParse->db;\n  if( pParse->nErr || db->mallocFailed ){\n    goto update_cleanup;\n  }\n  assert( pTabList->nSrc==1 );\n\n  /* Locate the table which we want to update. \n  */\n  pTab = sqlite3SrcListLookup(pParse, pTabList);\n  if( pTab==0 ) goto update_cleanup;\n  iDb = sqlite3SchemaToIndex(pParse->db, pTab->pSchema);\n\n  /* Figure out if we have any triggers and if the table being\n  ** updated is a view.\n  */\n#ifndef SQLITE_OMIT_TRIGGER\n  pTrigger = sqlite3TriggersExist(pParse, pTab, TK_UPDATE, pChanges, &tmask);\n  isView = pTab->pSelect!=0;\n  assert( pTrigger || tmask==0 );\n#else\n# define pTrigger 0\n# define isView 0\n# define tmask 0\n#endif\n#ifdef SQLITE_OMIT_VIEW\n# undef isView\n# define isView 0\n#endif\n\n  if( sqlite3ViewGetColumnNames(pParse, pTab) ){\n    goto update_cleanup;\n  }\n  if( sqlite3IsReadOnly(pParse, pTab, tmask) ){\n    goto update_cleanup;\n  }\n  aXRef = sqlite3DbMallocRaw(db, sizeof(int) * pTab->nCol );\n  if( aXRef==0 ) goto update_cleanup;\n  for(i=0; i<pTab->nCol; i++) aXRef[i] = -1;\n\n  /* Allocate a cursors for the main database table and for all indices.\n  ** The index cursors might not be used, but if they are used they\n  ** need to occur right after the database cursor.  So go ahead and\n  ** allocate enough space, just in case.\n  */\n  pTabList->a[0].iCursor = iCur = pParse->nTab++;\n  for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){\n    pParse->nTab++;\n  }\n\n  /* Initialize the name-context */\n  memset(&sNC, 0, sizeof(sNC));\n  sNC.pParse = pParse;\n  sNC.pSrcList = pTabList;\n\n  /* Resolve the column names in all the expressions of the\n  ** of the UPDATE statement.  Also find the column index\n  ** for each column to be updated in the pChanges array.  For each\n  ** column to be updated, make sure we have authorization to change\n  ** that column.\n  */\n  chngRowid = 0;\n  for(i=0; i<pChanges->nExpr; i++){\n    if( sqlite3ResolveExprNames(&sNC, pChanges->a[i].pExpr) ){\n      goto update_cleanup;\n    }\n    for(j=0; j<pTab->nCol; j++){\n      if( sqlite3StrICmp(pTab->aCol[j].zName, pChanges->a[i].zName)==0 ){\n        if( j==pTab->iPKey ){\n          chngRowid = 1;\n          pRowidExpr = pChanges->a[i].pExpr;\n        }\n        aXRef[j] = i;\n        break;\n      }\n    }\n    if( j>=pTab->nCol ){\n      if( sqlite3IsRowid(pChanges->a[i].zName) ){\n        chngRowid = 1;\n        pRowidExpr = pChanges->a[i].pExpr;\n      }else{\n        sqlite3ErrorMsg(pParse, \"no such column: %s\", pChanges->a[i].zName);\n        pParse->checkSchema = 1;\n        goto update_cleanup;\n      }\n    }\n#ifndef SQLITE_OMIT_AUTHORIZATION\n    {\n      int rc;\n      rc = sqlite3AuthCheck(pParse, SQLITE_UPDATE, pTab->zName,\n                           pTab->aCol[j].zName, db->aDb[iDb].zName);\n      if( rc==SQLITE_DENY ){\n        goto update_cleanup;\n      }else if( rc==SQLITE_IGNORE ){\n        aXRef[j] = -1;\n      }\n    }\n#endif\n  }\n\n  hasFK = sqlite3FkRequired(pParse, pTab, aXRef, chngRowid);\n\n  /* Allocate memory for the array aRegIdx[].  There is one entry in the\n  ** array for each index associated with table being updated.  Fill in\n  ** the value with a register number for indices that are to be used\n  ** and with zero for unused indices.\n  */\n  for(nIdx=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, nIdx++){}\n  if( nIdx>0 ){\n    aRegIdx = sqlite3DbMallocRaw(db, sizeof(Index*) * nIdx );\n    if( aRegIdx==0 ) goto update_cleanup;\n  }\n  for(j=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, j++){\n    int reg;\n    if( chngRowid ){\n      reg = ++pParse->nMem;\n    }else{\n      reg = 0;\n      for(i=0; i<pIdx->nColumn; i++){\n        if( aXRef[pIdx->aiColumn[i]]>=0 ){\n          reg = ++pParse->nMem;\n          break;\n        }\n      }\n    }\n    aRegIdx[j] = reg;\n  }\n\n  /* Begin generating code. */\n  v = sqlite3GetVdbe(pParse);\n  if( v==0 ) goto update_cleanup;\n  if( pParse->nested==0 ) sqlite3VdbeCountChanges(v);\n  sqlite3BeginWriteOperation(pParse, 1, iDb);\n\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  /* Virtual tables must be handled separately */\n  if( IsVirtual(pTab) ){\n    updateVirtualTable(pParse, pTabList, pTab, pChanges, pRowidExpr, aXRef,\n                       pWhere);\n    pWhere = 0;\n    pTabList = 0;\n    goto update_cleanup;\n  }\n#endif\n\n  /* Allocate required registers. */\n  regOldRowid = regNewRowid = ++pParse->nMem;\n  if( pTrigger || hasFK ){\n    regOld = pParse->nMem + 1;\n    pParse->nMem += pTab->nCol;\n  }\n  if( chngRowid || pTrigger || hasFK ){\n    regNewRowid = ++pParse->nMem;\n  }\n  regNew = pParse->nMem + 1;\n  pParse->nMem += pTab->nCol;\n\n  /* Start the view context. */\n  if( isView ){\n    sqlite3AuthContextPush(pParse, &sContext, pTab->zName);\n  }\n\n  /* If we are trying to update a view, realize that view into\n  ** a ephemeral table.\n  */\n#if !defined(SQLITE_OMIT_VIEW) && !defined(SQLITE_OMIT_TRIGGER)\n  if( isView ){\n    sqlite3MaterializeView(pParse, pTab, pWhere, iCur);\n  }\n#endif\n\n  /* Resolve the column names in all the expressions in the\n  ** WHERE clause.\n  */\n  if( sqlite3ResolveExprNames(&sNC, pWhere) ){\n    goto update_cleanup;\n  }\n\n  /* Begin the database scan\n  */\n  sqlite3VdbeAddOp2(v, OP_Null, 0, regOldRowid);\n  pWInfo = sqlite3WhereBegin(pParse, pTabList, pWhere,0, WHERE_ONEPASS_DESIRED);\n  if( pWInfo==0 ) goto update_cleanup;\n  okOnePass = pWInfo->okOnePass;\n\n  /* Remember the rowid of every item to be updated.\n  */\n  sqlite3VdbeAddOp2(v, OP_Rowid, iCur, regOldRowid);\n  if( !okOnePass ){\n    regRowSet = ++pParse->nMem;\n    sqlite3VdbeAddOp2(v, OP_RowSetAdd, regRowSet, regOldRowid);\n  }\n\n  /* End the database scan loop.\n  */\n  sqlite3WhereEnd(pWInfo);\n\n  /* Initialize the count of updated rows\n  */\n  if( (db->flags & SQLITE_CountRows) && !pParse->pTriggerTab ){\n    regRowCount = ++pParse->nMem;\n    sqlite3VdbeAddOp2(v, OP_Integer, 0, regRowCount);\n  }\n\n  if( !isView ){\n    /* \n    ** Open every index that needs updating.  Note that if any\n    ** index could potentially invoke a REPLACE conflict resolution \n    ** action, then we need to open all indices because we might need\n    ** to be deleting some records.\n    */\n    if( !okOnePass ) sqlite3OpenTable(pParse, iCur, iDb, pTab, OP_OpenWrite); \n    if( onError==OE_Replace ){\n      openAll = 1;\n    }else{\n      openAll = 0;\n      for(pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext){\n        if( pIdx->onError==OE_Replace ){\n          openAll = 1;\n          break;\n        }\n      }\n    }\n    for(i=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, i++){\n      if( openAll || aRegIdx[i]>0 ){\n        KeyInfo *pKey = sqlite3IndexKeyinfo(pParse, pIdx);\n        sqlite3VdbeAddOp4(v, OP_OpenWrite, iCur+i+1, pIdx->tnum, iDb,\n                       (char*)pKey, P4_KEYINFO_HANDOFF);\n        assert( pParse->nTab>iCur+i+1 );\n      }\n    }\n  }\n\n  /* Top of the update loop */\n  if( okOnePass ){\n    int a1 = sqlite3VdbeAddOp1(v, OP_NotNull, regOldRowid);\n    addr = sqlite3VdbeAddOp0(v, OP_Goto);\n    sqlite3VdbeJumpHere(v, a1);\n  }else{\n    addr = sqlite3VdbeAddOp3(v, OP_RowSetRead, regRowSet, 0, regOldRowid);\n  }\n\n  /* Make cursor iCur point to the record that is being updated. If\n  ** this record does not exist for some reason (deleted by a trigger,\n  ** for example, then jump to the next iteration of the RowSet loop.  */\n  sqlite3VdbeAddOp3(v, OP_NotExists, iCur, addr, regOldRowid);\n\n  /* If the record number will change, set register regNewRowid to\n  ** contain the new value. If the record number is not being modified,\n  ** then regNewRowid is the same register as regOldRowid, which is\n  ** already populated.  */\n  assert( chngRowid || pTrigger || hasFK || regOldRowid==regNewRowid );\n  if( chngRowid ){\n    sqlite3ExprCode(pParse, pRowidExpr, regNewRowid);\n    sqlite3VdbeAddOp1(v, OP_MustBeInt, regNewRowid);\n  }\n\n  /* If there are triggers on this table, populate an array of registers \n  ** with the required old.* column data.  */\n  if( hasFK || pTrigger ){\n    u32 oldmask = (hasFK ? sqlite3FkOldmask(pParse, pTab) : 0);\n    oldmask |= sqlite3TriggerColmask(pParse, \n        pTrigger, pChanges, 0, TRIGGER_BEFORE|TRIGGER_AFTER, pTab, onError\n    );\n    for(i=0; i<pTab->nCol; i++){\n      if( aXRef[i]<0 || oldmask==0xffffffff || (i<32 && (oldmask & (1<<i))) ){\n        sqlite3ExprCodeGetColumnOfTable(v, pTab, iCur, i, regOld+i);\n      }else{\n        sqlite3VdbeAddOp2(v, OP_Null, 0, regOld+i);\n      }\n    }\n    if( chngRowid==0 ){\n      sqlite3VdbeAddOp2(v, OP_Copy, regOldRowid, regNewRowid);\n    }\n  }\n\n  /* Populate the array of registers beginning at regNew with the new\n  ** row data. This array is used to check constaints, create the new\n  ** table and index records, and as the values for any new.* references\n  ** made by triggers.\n  **\n  ** If there are one or more BEFORE triggers, then do not populate the\n  ** registers associated with columns that are (a) not modified by\n  ** this UPDATE statement and (b) not accessed by new.* references. The\n  ** values for registers not modified by the UPDATE must be reloaded from \n  ** the database after the BEFORE triggers are fired anyway (as the trigger \n  ** may have modified them). So not loading those that are not going to\n  ** be used eliminates some redundant opcodes.\n  */\n  newmask = sqlite3TriggerColmask(\n      pParse, pTrigger, pChanges, 1, TRIGGER_BEFORE, pTab, onError\n  );\n  for(i=0; i<pTab->nCol; i++){\n    if( i==pTab->iPKey ){\n      sqlite3VdbeAddOp2(v, OP_Null, 0, regNew+i);\n    }else{\n      j = aXRef[i];\n      if( j>=0 ){\n        sqlite3ExprCode(pParse, pChanges->a[j].pExpr, regNew+i);\n      }else if( 0==(tmask&TRIGGER_BEFORE) || i>31 || (newmask&(1<<i)) ){\n        /* This branch loads the value of a column that will not be changed \n        ** into a register. This is done if there are no BEFORE triggers, or\n        ** if there are one or more BEFORE triggers that use this value via\n        ** a new.* reference in a trigger program.\n        */\n        testcase( i==31 );\n        testcase( i==32 );\n        sqlite3VdbeAddOp3(v, OP_Column, iCur, i, regNew+i);\n        sqlite3ColumnDefault(v, pTab, i, regNew+i);\n      }\n    }\n  }\n\n  /* Fire any BEFORE UPDATE triggers. This happens before constraints are\n  ** verified. One could argue that this is wrong.\n  */\n  if( tmask&TRIGGER_BEFORE ){\n    sqlite3VdbeAddOp2(v, OP_Affinity, regNew, pTab->nCol);\n    sqlite3TableAffinityStr(v, pTab);\n    sqlite3CodeRowTrigger(pParse, pTrigger, TK_UPDATE, pChanges, \n        TRIGGER_BEFORE, pTab, regOldRowid, onError, addr);\n\n    /* The row-trigger may have deleted the row being updated. In this\n    ** case, jump to the next row. No updates or AFTER triggers are \n    ** required. This behaviour - what happens when the row being updated\n    ** is deleted or renamed by a BEFORE trigger - is left undefined in the\n    ** documentation.\n    */\n    sqlite3VdbeAddOp3(v, OP_NotExists, iCur, addr, regOldRowid);\n\n    /* If it did not delete it, the row-trigger may still have modified \n    ** some of the columns of the row being updated. Load the values for \n    ** all columns not modified by the update statement into their \n    ** registers in case this has happened.\n    */\n    for(i=0; i<pTab->nCol; i++){\n      if( aXRef[i]<0 && i!=pTab->iPKey ){\n        sqlite3VdbeAddOp3(v, OP_Column, iCur, i, regNew+i);\n        sqlite3ColumnDefault(v, pTab, i, regNew+i);\n      }\n    }\n  }\n\n  if( !isView ){\n    int j1;                       /* Address of jump instruction */\n\n    /* Do constraint checks. */\n    sqlite3GenerateConstraintChecks(pParse, pTab, iCur, regNewRowid,\n        aRegIdx, (chngRowid?regOldRowid:0), 1, onError, addr, 0);\n\n    /* Do FK constraint checks. */\n    if( hasFK ){\n      sqlite3FkCheck(pParse, pTab, regOldRowid, 0);\n    }\n\n    /* Delete the index entries associated with the current record.  */\n    j1 = sqlite3VdbeAddOp3(v, OP_NotExists, iCur, 0, regOldRowid);\n    sqlite3GenerateRowIndexDelete(pParse, pTab, iCur, aRegIdx);\n  \n    /* If changing the record number, delete the old record.  */\n    if( hasFK || chngRowid ){\n      sqlite3VdbeAddOp2(v, OP_Delete, iCur, 0);\n    }\n    sqlite3VdbeJumpHere(v, j1);\n\n    if( hasFK ){\n      sqlite3FkCheck(pParse, pTab, 0, regNewRowid);\n    }\n  \n    /* Insert the new index entries and the new record. */\n    sqlite3CompleteInsertion(pParse, pTab, iCur, regNewRowid, aRegIdx, 1, 0, 0);\n\n    /* Do any ON CASCADE, SET NULL or SET DEFAULT operations required to\n    ** handle rows (possibly in other tables) that refer via a foreign key\n    ** to the row just updated. */ \n    if( hasFK ){\n      sqlite3FkActions(pParse, pTab, pChanges, regOldRowid);\n    }\n  }\n\n  /* Increment the row counter \n  */\n  if( (db->flags & SQLITE_CountRows) && !pParse->pTriggerTab){\n    sqlite3VdbeAddOp2(v, OP_AddImm, regRowCount, 1);\n  }\n\n  sqlite3CodeRowTrigger(pParse, pTrigger, TK_UPDATE, pChanges, \n      TRIGGER_AFTER, pTab, regOldRowid, onError, addr);\n\n  /* Repeat the above with the next record to be updated, until\n  ** all record selected by the WHERE clause have been updated.\n  */\n  sqlite3VdbeAddOp2(v, OP_Goto, 0, addr);\n  sqlite3VdbeJumpHere(v, addr);\n\n  /* Close all tables */\n  for(i=0, pIdx=pTab->pIndex; pIdx; pIdx=pIdx->pNext, i++){\n    if( openAll || aRegIdx[i]>0 ){\n      sqlite3VdbeAddOp2(v, OP_Close, iCur+i+1, 0);\n    }\n  }\n  sqlite3VdbeAddOp2(v, OP_Close, iCur, 0);\n\n  /* Update the sqlite_sequence table by storing the content of the\n  ** maximum rowid counter values recorded while inserting into\n  ** autoincrement tables.\n  */\n  if( pParse->nested==0 && pParse->pTriggerTab==0 ){\n    sqlite3AutoincrementEnd(pParse);\n  }\n\n  /*\n  ** Return the number of rows that were changed. If this routine is \n  ** generating code because of a call to sqlite3NestedParse(), do not\n  ** invoke the callback function.\n  */\n  if( (db->flags&SQLITE_CountRows) && !pParse->pTriggerTab && !pParse->nested ){\n    sqlite3VdbeAddOp2(v, OP_ResultRow, regRowCount, 1);\n    sqlite3VdbeSetNumCols(v, 1);\n    sqlite3VdbeSetColName(v, 0, COLNAME_NAME, \"rows updated\", SQLITE_STATIC);\n  }\n\nupdate_cleanup:\n  sqlite3AuthContextPop(&sContext);\n  sqlite3DbFree(db, aRegIdx);\n  sqlite3DbFree(db, aXRef);\n  sqlite3SrcListDelete(db, pTabList);\n  sqlite3ExprListDelete(db, pChanges);\n  sqlite3ExprDelete(db, pWhere);\n  return;\n}\n/* Make sure \"isView\" and other macros defined above are undefined. Otherwise\n** thely may interfere with compilation of other functions in this file\n** (or in another file, if this file becomes part of the amalgamation).  */\n#ifdef isView\n #undef isView\n#endif\n#ifdef pTrigger\n #undef pTrigger\n#endif\n\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n/*\n** Generate code for an UPDATE of a virtual table.\n**\n** The strategy is that we create an ephemerial table that contains\n** for each row to be changed:\n**\n**   (A)  The original rowid of that row.\n**   (B)  The revised rowid for the row. (note1)\n**   (C)  The content of every column in the row.\n**\n** Then we loop over this ephemeral table and for each row in\n** the ephermeral table call VUpdate.\n**\n** When finished, drop the ephemeral table.\n**\n** (note1) Actually, if we know in advance that (A) is always the same\n** as (B) we only store (A), then duplicate (A) when pulling\n** it out of the ephemeral table before calling VUpdate.\n*/\nstatic void updateVirtualTable(\n  Parse *pParse,       /* The parsing context */\n  SrcList *pSrc,       /* The virtual table to be modified */\n  Table *pTab,         /* The virtual table */\n  ExprList *pChanges,  /* The columns to change in the UPDATE statement */\n  Expr *pRowid,        /* Expression used to recompute the rowid */\n  int *aXRef,          /* Mapping from columns of pTab to entries in pChanges */\n  Expr *pWhere         /* WHERE clause of the UPDATE statement */\n){\n  Vdbe *v = pParse->pVdbe;  /* Virtual machine under construction */\n  ExprList *pEList = 0;     /* The result set of the SELECT statement */\n  Select *pSelect = 0;      /* The SELECT statement */\n  Expr *pExpr;              /* Temporary expression */\n  int ephemTab;             /* Table holding the result of the SELECT */\n  int i;                    /* Loop counter */\n  int addr;                 /* Address of top of loop */\n  int iReg;                 /* First register in set passed to OP_VUpdate */\n  sqlite3 *db = pParse->db; /* Database connection */\n  const char *pVTab = (const char*)sqlite3GetVTable(db, pTab);\n  SelectDest dest;\n\n  /* Construct the SELECT statement that will find the new values for\n  ** all updated rows. \n  */\n  pEList = sqlite3ExprListAppend(pParse, 0, sqlite3Expr(db, TK_ID, \"_rowid_\"));\n  if( pRowid ){\n    pEList = sqlite3ExprListAppend(pParse, pEList,\n                                   sqlite3ExprDup(db, pRowid, 0));\n  }\n  assert( pTab->iPKey<0 );\n  for(i=0; i<pTab->nCol; i++){\n    if( aXRef[i]>=0 ){\n      pExpr = sqlite3ExprDup(db, pChanges->a[aXRef[i]].pExpr, 0);\n    }else{\n      pExpr = sqlite3Expr(db, TK_ID, pTab->aCol[i].zName);\n    }\n    pEList = sqlite3ExprListAppend(pParse, pEList, pExpr);\n  }\n  pSelect = sqlite3SelectNew(pParse, pEList, pSrc, pWhere, 0, 0, 0, 0, 0, 0);\n  \n  /* Create the ephemeral table into which the update results will\n  ** be stored.\n  */\n  assert( v );\n  ephemTab = pParse->nTab++;\n  sqlite3VdbeAddOp2(v, OP_OpenEphemeral, ephemTab, pTab->nCol+1+(pRowid!=0));\n  sqlite3VdbeChangeP5(v, BTREE_UNORDERED);\n\n  /* fill the ephemeral table \n  */\n  sqlite3SelectDestInit(&dest, SRT_Table, ephemTab);\n  sqlite3Select(pParse, pSelect, &dest);\n\n  /* Generate code to scan the ephemeral table and call VUpdate. */\n  iReg = ++pParse->nMem;\n  pParse->nMem += pTab->nCol+1;\n  addr = sqlite3VdbeAddOp2(v, OP_Rewind, ephemTab, 0);\n  sqlite3VdbeAddOp3(v, OP_Column,  ephemTab, 0, iReg);\n  sqlite3VdbeAddOp3(v, OP_Column, ephemTab, (pRowid?1:0), iReg+1);\n  for(i=0; i<pTab->nCol; i++){\n    sqlite3VdbeAddOp3(v, OP_Column, ephemTab, i+1+(pRowid!=0), iReg+2+i);\n  }\n  sqlite3VtabMakeWritable(pParse, pTab);\n  sqlite3VdbeAddOp4(v, OP_VUpdate, 0, pTab->nCol+2, iReg, pVTab, P4_VTAB);\n  sqlite3MayAbort(pParse);\n  sqlite3VdbeAddOp2(v, OP_Next, ephemTab, addr+1);\n  sqlite3VdbeJumpHere(v, addr);\n  sqlite3VdbeAddOp2(v, OP_Close, ephemTab, 0);\n\n  /* Cleanup */\n  sqlite3SelectDelete(db, pSelect);  \n}\n#endif /* SQLITE_OMIT_VIRTUALTABLE */\n\n/************** End of update.c **********************************************/\n/************** Begin file vacuum.c ******************************************/\n/*\n** 2003 April 6\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains code used to implement the VACUUM command.\n**\n** Most of the code in this file may be omitted by defining the\n** SQLITE_OMIT_VACUUM macro.\n*/\n\n#if !defined(SQLITE_OMIT_VACUUM) && !defined(SQLITE_OMIT_ATTACH)\n/*\n** Finalize a prepared statement.  If there was an error, store the\n** text of the error message in *pzErrMsg.  Return the result code.\n*/\nstatic int vacuumFinalize(sqlite3 *db, sqlite3_stmt *pStmt, char **pzErrMsg){\n  int rc;\n  rc = sqlite3VdbeFinalize((Vdbe*)pStmt);\n  if( rc ){\n    sqlite3SetString(pzErrMsg, db, sqlite3_errmsg(db));\n  }\n  return rc;\n}\n\n/*\n** Execute zSql on database db. Return an error code.\n*/\nstatic int execSql(sqlite3 *db, char **pzErrMsg, const char *zSql){\n  sqlite3_stmt *pStmt;\n  VVA_ONLY( int rc; )\n  if( !zSql ){\n    return SQLITE_NOMEM;\n  }\n  if( SQLITE_OK!=sqlite3_prepare(db, zSql, -1, &pStmt, 0) ){\n    sqlite3SetString(pzErrMsg, db, sqlite3_errmsg(db));\n    return sqlite3_errcode(db);\n  }\n  VVA_ONLY( rc = ) sqlite3_step(pStmt);\n  assert( rc!=SQLITE_ROW );\n  return vacuumFinalize(db, pStmt, pzErrMsg);\n}\n\n/*\n** Execute zSql on database db. The statement returns exactly\n** one column. Execute this as SQL on the same database.\n*/\nstatic int execExecSql(sqlite3 *db, char **pzErrMsg, const char *zSql){\n  sqlite3_stmt *pStmt;\n  int rc;\n\n  rc = sqlite3_prepare(db, zSql, -1, &pStmt, 0);\n  if( rc!=SQLITE_OK ) return rc;\n\n  while( SQLITE_ROW==sqlite3_step(pStmt) ){\n    rc = execSql(db, pzErrMsg, (char*)sqlite3_column_text(pStmt, 0));\n    if( rc!=SQLITE_OK ){\n      vacuumFinalize(db, pStmt, pzErrMsg);\n      return rc;\n    }\n  }\n\n  return vacuumFinalize(db, pStmt, pzErrMsg);\n}\n\n/*\n** The non-standard VACUUM command is used to clean up the database,\n** collapse free space, etc.  It is modelled after the VACUUM command\n** in PostgreSQL.\n**\n** In version 1.0.x of SQLite, the VACUUM command would call\n** gdbm_reorganize() on all the database tables.  But beginning\n** with 2.0.0, SQLite no longer uses GDBM so this command has\n** become a no-op.\n*/\nSQLITE_PRIVATE void sqlite3Vacuum(Parse *pParse){\n  Vdbe *v = sqlite3GetVdbe(pParse);\n  if( v ){\n    sqlite3VdbeAddOp2(v, OP_Vacuum, 0, 0);\n  }\n  return;\n}\n\n/*\n** This routine implements the OP_Vacuum opcode of the VDBE.\n*/\nSQLITE_PRIVATE int sqlite3RunVacuum(char **pzErrMsg, sqlite3 *db){\n  int rc = SQLITE_OK;     /* Return code from service routines */\n  Btree *pMain;           /* The database being vacuumed */\n  Btree *pTemp;           /* The temporary database we vacuum into */\n  char *zSql = 0;         /* SQL statements */\n  int saved_flags;        /* Saved value of the db->flags */\n  int saved_nChange;      /* Saved value of db->nChange */\n  int saved_nTotalChange; /* Saved value of db->nTotalChange */\n  void (*saved_xTrace)(void*,const char*);  /* Saved db->xTrace */\n  Db *pDb = 0;            /* Database to detach at end of vacuum */\n  int isMemDb;            /* True if vacuuming a :memory: database */\n  int nRes;               /* Bytes of reserved space at the end of each page */\n  int nDb;                /* Number of attached databases */\n\n  if( !db->autoCommit ){\n    sqlite3SetString(pzErrMsg, db, \"cannot VACUUM from within a transaction\");\n    return SQLITE_ERROR;\n  }\n  if( db->activeVdbeCnt>1 ){\n    sqlite3SetString(pzErrMsg, db,\"cannot VACUUM - SQL statements in progress\");\n    return SQLITE_ERROR;\n  }\n\n  /* Save the current value of the database flags so that it can be \n  ** restored before returning. Then set the writable-schema flag, and\n  ** disable CHECK and foreign key constraints.  */\n  saved_flags = db->flags;\n  saved_nChange = db->nChange;\n  saved_nTotalChange = db->nTotalChange;\n  saved_xTrace = db->xTrace;\n  db->flags |= SQLITE_WriteSchema | SQLITE_IgnoreChecks | SQLITE_PreferBuiltin;\n  db->flags &= ~(SQLITE_ForeignKeys | SQLITE_ReverseOrder);\n  db->xTrace = 0;\n\n  pMain = db->aDb[0].pBt;\n  isMemDb = sqlite3PagerIsMemdb(sqlite3BtreePager(pMain));\n\n  /* Attach the temporary database as 'vacuum_db'. The synchronous pragma\n  ** can be set to 'off' for this file, as it is not recovered if a crash\n  ** occurs anyway. The integrity of the database is maintained by a\n  ** (possibly synchronous) transaction opened on the main database before\n  ** sqlite3BtreeCopyFile() is called.\n  **\n  ** An optimisation would be to use a non-journaled pager.\n  ** (Later:) I tried setting \"PRAGMA vacuum_db.journal_mode=OFF\" but\n  ** that actually made the VACUUM run slower.  Very little journalling\n  ** actually occurs when doing a vacuum since the vacuum_db is initially\n  ** empty.  Only the journal header is written.  Apparently it takes more\n  ** time to parse and run the PRAGMA to turn journalling off than it does\n  ** to write the journal header file.\n  */\n  nDb = db->nDb;\n  if( sqlite3TempInMemory(db) ){\n    zSql = \"ATTACH ':memory:' AS vacuum_db;\";\n  }else{\n    zSql = \"ATTACH '' AS vacuum_db;\";\n  }\n  rc = execSql(db, pzErrMsg, zSql);\n  if( db->nDb>nDb ){\n    pDb = &db->aDb[db->nDb-1];\n    assert( strcmp(pDb->zName,\"vacuum_db\")==0 );\n  }\n  if( rc!=SQLITE_OK ) goto end_of_vacuum;\n  pTemp = db->aDb[db->nDb-1].pBt;\n\n  /* The call to execSql() to attach the temp database has left the file\n  ** locked (as there was more than one active statement when the transaction\n  ** to read the schema was concluded. Unlock it here so that this doesn't\n  ** cause problems for the call to BtreeSetPageSize() below.  */\n  sqlite3BtreeCommit(pTemp);\n\n  nRes = sqlite3BtreeGetReserve(pMain);\n\n  /* A VACUUM cannot change the pagesize of an encrypted database. */\n#if defined(SQLITE_HAS_CODEC) && !defined(SQLITE_HAS_CODEC_NO_ENCRYPTION)\n  if( db->nextPagesize ){\n    extern void sqlite3CodecGetKey(sqlite3*, int, void**, int*);\n    int nKey;\n    char *zKey;\n    sqlite3CodecGetKey(db, 0, (void**)&zKey, &nKey);\n    if( nKey ) db->nextPagesize = 0;\n  }\n#endif\n\n  /* Do not attempt to change the page size for a WAL database */\n  if( sqlite3PagerGetJournalMode(sqlite3BtreePager(pMain))\n                                               ==PAGER_JOURNALMODE_WAL ){\n    db->nextPagesize = 0;\n  }\n\n  if( sqlite3BtreeSetPageSize(pTemp, sqlite3BtreeGetPageSize(pMain), nRes, 0)\n   || (!isMemDb && sqlite3BtreeSetPageSize(pTemp, db->nextPagesize, nRes, 0))\n   || NEVER(db->mallocFailed)\n  ){\n    rc = SQLITE_NOMEM;\n    goto end_of_vacuum;\n  }\n  rc = execSql(db, pzErrMsg, \"PRAGMA vacuum_db.synchronous=OFF\");\n  if( rc!=SQLITE_OK ){\n    goto end_of_vacuum;\n  }\n\n#ifndef SQLITE_OMIT_AUTOVACUUM\n  sqlite3BtreeSetAutoVacuum(pTemp, db->nextAutovac>=0 ? db->nextAutovac :\n                                           sqlite3BtreeGetAutoVacuum(pMain));\n#endif\n\n  /* Begin a transaction */\n  rc = execSql(db, pzErrMsg, \"BEGIN EXCLUSIVE;\");\n  if( rc!=SQLITE_OK ) goto end_of_vacuum;\n\n  /* Query the schema of the main database. Create a mirror schema\n  ** in the temporary database.\n  */\n  rc = execExecSql(db, pzErrMsg,\n      \"SELECT 'CREATE TABLE vacuum_db.' || substr(sql,14) \"\n      \"  FROM sqlite_master WHERE type='table' AND name!='sqlite_sequence'\"\n      \"   AND rootpage>0\"\n  );\n  if( rc!=SQLITE_OK ) goto end_of_vacuum;\n  rc = execExecSql(db, pzErrMsg,\n      \"SELECT 'CREATE INDEX vacuum_db.' || substr(sql,14)\"\n      \"  FROM sqlite_master WHERE sql LIKE 'CREATE INDEX %' \");\n  if( rc!=SQLITE_OK ) goto end_of_vacuum;\n  rc = execExecSql(db, pzErrMsg,\n      \"SELECT 'CREATE UNIQUE INDEX vacuum_db.' || substr(sql,21) \"\n      \"  FROM sqlite_master WHERE sql LIKE 'CREATE UNIQUE INDEX %'\");\n  if( rc!=SQLITE_OK ) goto end_of_vacuum;\n\n  /* Loop through the tables in the main database. For each, do\n  ** an \"INSERT INTO vacuum_db.xxx SELECT * FROM main.xxx;\" to copy\n  ** the contents to the temporary database.\n  */\n  rc = execExecSql(db, pzErrMsg,\n      \"SELECT 'INSERT INTO vacuum_db.' || quote(name) \"\n      \"|| ' SELECT * FROM main.' || quote(name) || ';'\"\n      \"FROM main.sqlite_master \"\n      \"WHERE type = 'table' AND name!='sqlite_sequence' \"\n      \"  AND rootpage>0\"\n  );\n  if( rc!=SQLITE_OK ) goto end_of_vacuum;\n\n  /* Copy over the sequence table\n  */\n  rc = execExecSql(db, pzErrMsg,\n      \"SELECT 'DELETE FROM vacuum_db.' || quote(name) || ';' \"\n      \"FROM vacuum_db.sqlite_master WHERE name='sqlite_sequence' \"\n  );\n  if( rc!=SQLITE_OK ) goto end_of_vacuum;\n  rc = execExecSql(db, pzErrMsg,\n      \"SELECT 'INSERT INTO vacuum_db.' || quote(name) \"\n      \"|| ' SELECT * FROM main.' || quote(name) || ';' \"\n      \"FROM vacuum_db.sqlite_master WHERE name=='sqlite_sequence';\"\n  );\n  if( rc!=SQLITE_OK ) goto end_of_vacuum;\n\n\n  /* Copy the triggers, views, and virtual tables from the main database\n  ** over to the temporary database.  None of these objects has any\n  ** associated storage, so all we have to do is copy their entries\n  ** from the SQLITE_MASTER table.\n  */\n  rc = execSql(db, pzErrMsg,\n      \"INSERT INTO vacuum_db.sqlite_master \"\n      \"  SELECT type, name, tbl_name, rootpage, sql\"\n      \"    FROM main.sqlite_master\"\n      \"   WHERE type='view' OR type='trigger'\"\n      \"      OR (type='table' AND rootpage=0)\"\n  );\n  if( rc ) goto end_of_vacuum;\n\n  /* At this point, unless the main db was completely empty, there is now a\n  ** transaction open on the vacuum database, but not on the main database.\n  ** Open a btree level transaction on the main database. This allows a\n  ** call to sqlite3BtreeCopyFile(). The main database btree level\n  ** transaction is then committed, so the SQL level never knows it was\n  ** opened for writing. This way, the SQL transaction used to create the\n  ** temporary database never needs to be committed.\n  */\n  {\n    u32 meta;\n    int i;\n\n    /* This array determines which meta meta values are preserved in the\n    ** vacuum.  Even entries are the meta value number and odd entries\n    ** are an increment to apply to the meta value after the vacuum.\n    ** The increment is used to increase the schema cookie so that other\n    ** connections to the same database will know to reread the schema.\n    */\n    static const unsigned char aCopy[] = {\n       BTREE_SCHEMA_VERSION,     1,  /* Add one to the old schema cookie */\n       BTREE_DEFAULT_CACHE_SIZE, 0,  /* Preserve the default page cache size */\n       BTREE_TEXT_ENCODING,      0,  /* Preserve the text encoding */\n       BTREE_USER_VERSION,       0,  /* Preserve the user version */\n    };\n\n    assert( 1==sqlite3BtreeIsInTrans(pTemp) );\n    assert( 1==sqlite3BtreeIsInTrans(pMain) );\n\n    /* Copy Btree meta values */\n    for(i=0; i<ArraySize(aCopy); i+=2){\n      /* GetMeta() and UpdateMeta() cannot fail in this context because\n      ** we already have page 1 loaded into cache and marked dirty. */\n      sqlite3BtreeGetMeta(pMain, aCopy[i], &meta);\n      rc = sqlite3BtreeUpdateMeta(pTemp, aCopy[i], meta+aCopy[i+1]);\n      if( NEVER(rc!=SQLITE_OK) ) goto end_of_vacuum;\n    }\n\n    rc = sqlite3BtreeCopyFile(pMain, pTemp);\n    if( rc!=SQLITE_OK ) goto end_of_vacuum;\n    rc = sqlite3BtreeCommit(pTemp);\n    if( rc!=SQLITE_OK ) goto end_of_vacuum;\n#ifndef SQLITE_OMIT_AUTOVACUUM\n    sqlite3BtreeSetAutoVacuum(pMain, sqlite3BtreeGetAutoVacuum(pTemp));\n#endif\n  }\n\n  assert( rc==SQLITE_OK );\n  rc = sqlite3BtreeSetPageSize(pMain, sqlite3BtreeGetPageSize(pTemp), nRes,1);\n\nend_of_vacuum:\n  /* Restore the original value of db->flags */\n  db->flags = saved_flags;\n  db->nChange = saved_nChange;\n  db->nTotalChange = saved_nTotalChange;\n  db->xTrace = saved_xTrace;\n  sqlite3BtreeSetPageSize(pMain, -1, -1, 1);\n\n  /* Currently there is an SQL level transaction open on the vacuum\n  ** database. No locks are held on any other files (since the main file\n  ** was committed at the btree level). So it safe to end the transaction\n  ** by manually setting the autoCommit flag to true and detaching the\n  ** vacuum database. The vacuum_db journal file is deleted when the pager\n  ** is closed by the DETACH.\n  */\n  db->autoCommit = 1;\n\n  if( pDb ){\n    sqlite3BtreeClose(pDb->pBt);\n    pDb->pBt = 0;\n    pDb->pSchema = 0;\n  }\n\n  sqlite3ResetInternalSchema(db, 0);\n\n  return rc;\n}\n#endif  /* SQLITE_OMIT_VACUUM && SQLITE_OMIT_ATTACH */\n\n/************** End of vacuum.c **********************************************/\n/************** Begin file vtab.c ********************************************/\n/*\n** 2006 June 10\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains code used to help implement virtual tables.\n*/\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n\n/*\n** The actual function that does the work of creating a new module.\n** This function implements the sqlite3_create_module() and\n** sqlite3_create_module_v2() interfaces.\n*/\nstatic int createModule(\n  sqlite3 *db,                    /* Database in which module is registered */\n  const char *zName,              /* Name assigned to this module */\n  const sqlite3_module *pModule,  /* The definition of the module */\n  void *pAux,                     /* Context pointer for xCreate/xConnect */\n  void (*xDestroy)(void *)        /* Module destructor function */\n){\n  int rc, nName;\n  Module *pMod;\n\n  sqlite3_mutex_enter(db->mutex);\n  nName = sqlite3Strlen30(zName);\n  pMod = (Module *)sqlite3DbMallocRaw(db, sizeof(Module) + nName + 1);\n  if( pMod ){\n    Module *pDel;\n    char *zCopy = (char *)(&pMod[1]);\n    memcpy(zCopy, zName, nName+1);\n    pMod->zName = zCopy;\n    pMod->pModule = pModule;\n    pMod->pAux = pAux;\n    pMod->xDestroy = xDestroy;\n    pDel = (Module *)sqlite3HashInsert(&db->aModule, zCopy, nName, (void*)pMod);\n    if( pDel && pDel->xDestroy ){\n      pDel->xDestroy(pDel->pAux);\n    }\n    sqlite3DbFree(db, pDel);\n    if( pDel==pMod ){\n      db->mallocFailed = 1;\n    }\n    sqlite3ResetInternalSchema(db, 0);\n  }else if( xDestroy ){\n    xDestroy(pAux);\n  }\n  rc = sqlite3ApiExit(db, SQLITE_OK);\n  sqlite3_mutex_leave(db->mutex);\n  return rc;\n}\n\n\n/*\n** External API function used to create a new virtual-table module.\n*/\nSQLITE_API int sqlite3_create_module(\n  sqlite3 *db,                    /* Database in which module is registered */\n  const char *zName,              /* Name assigned to this module */\n  const sqlite3_module *pModule,  /* The definition of the module */\n  void *pAux                      /* Context pointer for xCreate/xConnect */\n){\n  return createModule(db, zName, pModule, pAux, 0);\n}\n\n/*\n** External API function used to create a new virtual-table module.\n*/\nSQLITE_API int sqlite3_create_module_v2(\n  sqlite3 *db,                    /* Database in which module is registered */\n  const char *zName,              /* Name assigned to this module */\n  const sqlite3_module *pModule,  /* The definition of the module */\n  void *pAux,                     /* Context pointer for xCreate/xConnect */\n  void (*xDestroy)(void *)        /* Module destructor function */\n){\n  return createModule(db, zName, pModule, pAux, xDestroy);\n}\n\n/*\n** Lock the virtual table so that it cannot be disconnected.\n** Locks nest.  Every lock should have a corresponding unlock.\n** If an unlock is omitted, resources leaks will occur.  \n**\n** If a disconnect is attempted while a virtual table is locked,\n** the disconnect is deferred until all locks have been removed.\n*/\nSQLITE_PRIVATE void sqlite3VtabLock(VTable *pVTab){\n  pVTab->nRef++;\n}\n\n\n/*\n** pTab is a pointer to a Table structure representing a virtual-table.\n** Return a pointer to the VTable object used by connection db to access \n** this virtual-table, if one has been created, or NULL otherwise.\n*/\nSQLITE_PRIVATE VTable *sqlite3GetVTable(sqlite3 *db, Table *pTab){\n  VTable *pVtab;\n  assert( IsVirtual(pTab) );\n  for(pVtab=pTab->pVTable; pVtab && pVtab->db!=db; pVtab=pVtab->pNext);\n  return pVtab;\n}\n\n/*\n** Decrement the ref-count on a virtual table object. When the ref-count\n** reaches zero, call the xDisconnect() method to delete the object.\n*/\nSQLITE_PRIVATE void sqlite3VtabUnlock(VTable *pVTab){\n  sqlite3 *db = pVTab->db;\n\n  assert( db );\n  assert( pVTab->nRef>0 );\n  assert( sqlite3SafetyCheckOk(db) );\n\n  pVTab->nRef--;\n  if( pVTab->nRef==0 ){\n    sqlite3_vtab *p = pVTab->pVtab;\n    if( p ){\n      p->pModule->xDisconnect(p);\n    }\n    sqlite3DbFree(db, pVTab);\n  }\n}\n\n/*\n** Table p is a virtual table. This function moves all elements in the\n** p->pVTable list to the sqlite3.pDisconnect lists of their associated\n** database connections to be disconnected at the next opportunity. \n** Except, if argument db is not NULL, then the entry associated with\n** connection db is left in the p->pVTable list.\n*/\nstatic VTable *vtabDisconnectAll(sqlite3 *db, Table *p){\n  VTable *pRet = 0;\n  VTable *pVTable = p->pVTable;\n  p->pVTable = 0;\n\n  /* Assert that the mutex (if any) associated with the BtShared database \n  ** that contains table p is held by the caller. See header comments \n  ** above function sqlite3VtabUnlockList() for an explanation of why\n  ** this makes it safe to access the sqlite3.pDisconnect list of any\n  ** database connection that may have an entry in the p->pVTable list.  */\n  assert( db==0 ||\n    sqlite3BtreeHoldsMutex(db->aDb[sqlite3SchemaToIndex(db, p->pSchema)].pBt) \n  );\n\n  while( pVTable ){\n    sqlite3 *db2 = pVTable->db;\n    VTable *pNext = pVTable->pNext;\n    assert( db2 );\n    if( db2==db ){\n      pRet = pVTable;\n      p->pVTable = pRet;\n      pRet->pNext = 0;\n    }else{\n      pVTable->pNext = db2->pDisconnect;\n      db2->pDisconnect = pVTable;\n    }\n    pVTable = pNext;\n  }\n\n  assert( !db || pRet );\n  return pRet;\n}\n\n\n/*\n** Disconnect all the virtual table objects in the sqlite3.pDisconnect list.\n**\n** This function may only be called when the mutexes associated with all\n** shared b-tree databases opened using connection db are held by the \n** caller. This is done to protect the sqlite3.pDisconnect list. The\n** sqlite3.pDisconnect list is accessed only as follows:\n**\n**   1) By this function. In this case, all BtShared mutexes and the mutex\n**      associated with the database handle itself must be held.\n**\n**   2) By function vtabDisconnectAll(), when it adds a VTable entry to\n**      the sqlite3.pDisconnect list. In this case either the BtShared mutex\n**      associated with the database the virtual table is stored in is held\n**      or, if the virtual table is stored in a non-sharable database, then\n**      the database handle mutex is held.\n**\n** As a result, a sqlite3.pDisconnect cannot be accessed simultaneously \n** by multiple threads. It is thread-safe.\n*/\nSQLITE_PRIVATE void sqlite3VtabUnlockList(sqlite3 *db){\n  VTable *p = db->pDisconnect;\n  db->pDisconnect = 0;\n\n  assert( sqlite3BtreeHoldsAllMutexes(db) );\n  assert( sqlite3_mutex_held(db->mutex) );\n\n  if( p ){\n    sqlite3ExpirePreparedStatements(db);\n    do {\n      VTable *pNext = p->pNext;\n      sqlite3VtabUnlock(p);\n      p = pNext;\n    }while( p );\n  }\n}\n\n/*\n** Clear any and all virtual-table information from the Table record.\n** This routine is called, for example, just before deleting the Table\n** record.\n**\n** Since it is a virtual-table, the Table structure contains a pointer\n** to the head of a linked list of VTable structures. Each VTable \n** structure is associated with a single sqlite3* user of the schema.\n** The reference count of the VTable structure associated with database \n** connection db is decremented immediately (which may lead to the \n** structure being xDisconnected and free). Any other VTable structures\n** in the list are moved to the sqlite3.pDisconnect list of the associated \n** database connection.\n*/\nSQLITE_PRIVATE void sqlite3VtabClear(sqlite3 *db, Table *p){\n  if( !db || db->pnBytesFreed==0 ) vtabDisconnectAll(0, p);\n  if( p->azModuleArg ){\n    int i;\n    for(i=0; i<p->nModuleArg; i++){\n      sqlite3DbFree(db, p->azModuleArg[i]);\n    }\n    sqlite3DbFree(db, p->azModuleArg);\n  }\n}\n\n/*\n** Add a new module argument to pTable->azModuleArg[].\n** The string is not copied - the pointer is stored.  The\n** string will be freed automatically when the table is\n** deleted.\n*/\nstatic void addModuleArgument(sqlite3 *db, Table *pTable, char *zArg){\n  int i = pTable->nModuleArg++;\n  int nBytes = sizeof(char *)*(1+pTable->nModuleArg);\n  char **azModuleArg;\n  azModuleArg = sqlite3DbRealloc(db, pTable->azModuleArg, nBytes);\n  if( azModuleArg==0 ){\n    int j;\n    for(j=0; j<i; j++){\n      sqlite3DbFree(db, pTable->azModuleArg[j]);\n    }\n    sqlite3DbFree(db, zArg);\n    sqlite3DbFree(db, pTable->azModuleArg);\n    pTable->nModuleArg = 0;\n  }else{\n    azModuleArg[i] = zArg;\n    azModuleArg[i+1] = 0;\n  }\n  pTable->azModuleArg = azModuleArg;\n}\n\n/*\n** The parser calls this routine when it first sees a CREATE VIRTUAL TABLE\n** statement.  The module name has been parsed, but the optional list\n** of parameters that follow the module name are still pending.\n*/\nSQLITE_PRIVATE void sqlite3VtabBeginParse(\n  Parse *pParse,        /* Parsing context */\n  Token *pName1,        /* Name of new table, or database name */\n  Token *pName2,        /* Name of new table or NULL */\n  Token *pModuleName    /* Name of the module for the virtual table */\n){\n  int iDb;              /* The database the table is being created in */\n  Table *pTable;        /* The new virtual table */\n  sqlite3 *db;          /* Database connection */\n\n  sqlite3StartTable(pParse, pName1, pName2, 0, 0, 1, 0);\n  pTable = pParse->pNewTable;\n  if( pTable==0 ) return;\n  assert( 0==pTable->pIndex );\n\n  db = pParse->db;\n  iDb = sqlite3SchemaToIndex(db, pTable->pSchema);\n  assert( iDb>=0 );\n\n  pTable->tabFlags |= TF_Virtual;\n  pTable->nModuleArg = 0;\n  addModuleArgument(db, pTable, sqlite3NameFromToken(db, pModuleName));\n  addModuleArgument(db, pTable, sqlite3DbStrDup(db, db->aDb[iDb].zName));\n  addModuleArgument(db, pTable, sqlite3DbStrDup(db, pTable->zName));\n  pParse->sNameToken.n = (int)(&pModuleName->z[pModuleName->n] - pName1->z);\n\n#ifndef SQLITE_OMIT_AUTHORIZATION\n  /* Creating a virtual table invokes the authorization callback twice.\n  ** The first invocation, to obtain permission to INSERT a row into the\n  ** sqlite_master table, has already been made by sqlite3StartTable().\n  ** The second call, to obtain permission to create the table, is made now.\n  */\n  if( pTable->azModuleArg ){\n    sqlite3AuthCheck(pParse, SQLITE_CREATE_VTABLE, pTable->zName, \n            pTable->azModuleArg[0], pParse->db->aDb[iDb].zName);\n  }\n#endif\n}\n\n/*\n** This routine takes the module argument that has been accumulating\n** in pParse->zArg[] and appends it to the list of arguments on the\n** virtual table currently under construction in pParse->pTable.\n*/\nstatic void addArgumentToVtab(Parse *pParse){\n  if( pParse->sArg.z && ALWAYS(pParse->pNewTable) ){\n    const char *z = (const char*)pParse->sArg.z;\n    int n = pParse->sArg.n;\n    sqlite3 *db = pParse->db;\n    addModuleArgument(db, pParse->pNewTable, sqlite3DbStrNDup(db, z, n));\n  }\n}\n\n/*\n** The parser calls this routine after the CREATE VIRTUAL TABLE statement\n** has been completely parsed.\n*/\nSQLITE_PRIVATE void sqlite3VtabFinishParse(Parse *pParse, Token *pEnd){\n  Table *pTab = pParse->pNewTable;  /* The table being constructed */\n  sqlite3 *db = pParse->db;         /* The database connection */\n\n  if( pTab==0 ) return;\n  addArgumentToVtab(pParse);\n  pParse->sArg.z = 0;\n  if( pTab->nModuleArg<1 ) return;\n  \n  /* If the CREATE VIRTUAL TABLE statement is being entered for the\n  ** first time (in other words if the virtual table is actually being\n  ** created now instead of just being read out of sqlite_master) then\n  ** do additional initialization work and store the statement text\n  ** in the sqlite_master table.\n  */\n  if( !db->init.busy ){\n    char *zStmt;\n    char *zWhere;\n    int iDb;\n    Vdbe *v;\n\n    /* Compute the complete text of the CREATE VIRTUAL TABLE statement */\n    if( pEnd ){\n      pParse->sNameToken.n = (int)(pEnd->z - pParse->sNameToken.z) + pEnd->n;\n    }\n    zStmt = sqlite3MPrintf(db, \"CREATE VIRTUAL TABLE %T\", &pParse->sNameToken);\n\n    /* A slot for the record has already been allocated in the \n    ** SQLITE_MASTER table.  We just need to update that slot with all\n    ** the information we've collected.  \n    **\n    ** The VM register number pParse->regRowid holds the rowid of an\n    ** entry in the sqlite_master table tht was created for this vtab\n    ** by sqlite3StartTable().\n    */\n    iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n    sqlite3NestedParse(pParse,\n      \"UPDATE %Q.%s \"\n         \"SET type='table', name=%Q, tbl_name=%Q, rootpage=0, sql=%Q \"\n       \"WHERE rowid=#%d\",\n      db->aDb[iDb].zName, SCHEMA_TABLE(iDb),\n      pTab->zName,\n      pTab->zName,\n      zStmt,\n      pParse->regRowid\n    );\n    sqlite3DbFree(db, zStmt);\n    v = sqlite3GetVdbe(pParse);\n    sqlite3ChangeCookie(pParse, iDb);\n\n    sqlite3VdbeAddOp2(v, OP_Expire, 0, 0);\n    zWhere = sqlite3MPrintf(db, \"name='%q' AND type='table'\", pTab->zName);\n    sqlite3VdbeAddOp4(v, OP_ParseSchema, iDb, 1, 0, zWhere, P4_DYNAMIC);\n    sqlite3VdbeAddOp4(v, OP_VCreate, iDb, 0, 0, \n                         pTab->zName, sqlite3Strlen30(pTab->zName) + 1);\n  }\n\n  /* If we are rereading the sqlite_master table create the in-memory\n  ** record of the table. The xConnect() method is not called until\n  ** the first time the virtual table is used in an SQL statement. This\n  ** allows a schema that contains virtual tables to be loaded before\n  ** the required virtual table implementations are registered.  */\n  else {\n    Table *pOld;\n    Schema *pSchema = pTab->pSchema;\n    const char *zName = pTab->zName;\n    int nName = sqlite3Strlen30(zName);\n    pOld = sqlite3HashInsert(&pSchema->tblHash, zName, nName, pTab);\n    if( pOld ){\n      db->mallocFailed = 1;\n      assert( pTab==pOld );  /* Malloc must have failed inside HashInsert() */\n      return;\n    }\n    pParse->pNewTable = 0;\n  }\n}\n\n/*\n** The parser calls this routine when it sees the first token\n** of an argument to the module name in a CREATE VIRTUAL TABLE statement.\n*/\nSQLITE_PRIVATE void sqlite3VtabArgInit(Parse *pParse){\n  addArgumentToVtab(pParse);\n  pParse->sArg.z = 0;\n  pParse->sArg.n = 0;\n}\n\n/*\n** The parser calls this routine for each token after the first token\n** in an argument to the module name in a CREATE VIRTUAL TABLE statement.\n*/\nSQLITE_PRIVATE void sqlite3VtabArgExtend(Parse *pParse, Token *p){\n  Token *pArg = &pParse->sArg;\n  if( pArg->z==0 ){\n    pArg->z = p->z;\n    pArg->n = p->n;\n  }else{\n    assert(pArg->z < p->z);\n    pArg->n = (int)(&p->z[p->n] - pArg->z);\n  }\n}\n\n/*\n** Invoke a virtual table constructor (either xCreate or xConnect). The\n** pointer to the function to invoke is passed as the fourth parameter\n** to this procedure.\n*/\nstatic int vtabCallConstructor(\n  sqlite3 *db, \n  Table *pTab,\n  Module *pMod,\n  int (*xConstruct)(sqlite3*,void*,int,const char*const*,sqlite3_vtab**,char**),\n  char **pzErr\n){\n  VTable *pVTable;\n  int rc;\n  const char *const*azArg = (const char *const*)pTab->azModuleArg;\n  int nArg = pTab->nModuleArg;\n  char *zErr = 0;\n  char *zModuleName = sqlite3MPrintf(db, \"%s\", pTab->zName);\n\n  if( !zModuleName ){\n    return SQLITE_NOMEM;\n  }\n\n  pVTable = sqlite3DbMallocZero(db, sizeof(VTable));\n  if( !pVTable ){\n    sqlite3DbFree(db, zModuleName);\n    return SQLITE_NOMEM;\n  }\n  pVTable->db = db;\n  pVTable->pMod = pMod;\n\n  assert( !db->pVTab );\n  assert( xConstruct );\n  db->pVTab = pTab;\n\n  /* Invoke the virtual table constructor */\n  rc = xConstruct(db, pMod->pAux, nArg, azArg, &pVTable->pVtab, &zErr);\n  if( rc==SQLITE_NOMEM ) db->mallocFailed = 1;\n\n  if( SQLITE_OK!=rc ){\n    if( zErr==0 ){\n      *pzErr = sqlite3MPrintf(db, \"vtable constructor failed: %s\", zModuleName);\n    }else {\n      *pzErr = sqlite3MPrintf(db, \"%s\", zErr);\n      sqlite3_free(zErr);\n    }\n    sqlite3DbFree(db, pVTable);\n  }else if( ALWAYS(pVTable->pVtab) ){\n    /* Justification of ALWAYS():  A correct vtab constructor must allocate\n    ** the sqlite3_vtab object if successful.  */\n    pVTable->pVtab->pModule = pMod->pModule;\n    pVTable->nRef = 1;\n    if( db->pVTab ){\n      const char *zFormat = \"vtable constructor did not declare schema: %s\";\n      *pzErr = sqlite3MPrintf(db, zFormat, pTab->zName);\n      sqlite3VtabUnlock(pVTable);\n      rc = SQLITE_ERROR;\n    }else{\n      int iCol;\n      /* If everything went according to plan, link the new VTable structure\n      ** into the linked list headed by pTab->pVTable. Then loop through the \n      ** columns of the table to see if any of them contain the token \"hidden\".\n      ** If so, set the Column.isHidden flag and remove the token from\n      ** the type string.  */\n      pVTable->pNext = pTab->pVTable;\n      pTab->pVTable = pVTable;\n\n      for(iCol=0; iCol<pTab->nCol; iCol++){\n        char *zType = pTab->aCol[iCol].zType;\n        int nType;\n        int i = 0;\n        if( !zType ) continue;\n        nType = sqlite3Strlen30(zType);\n        if( sqlite3StrNICmp(\"hidden\", zType, 6)||(zType[6] && zType[6]!=' ') ){\n          for(i=0; i<nType; i++){\n            if( (0==sqlite3StrNICmp(\" hidden\", &zType[i], 7))\n             && (zType[i+7]=='\\0' || zType[i+7]==' ')\n            ){\n              i++;\n              break;\n            }\n          }\n        }\n        if( i<nType ){\n          int j;\n          int nDel = 6 + (zType[i+6] ? 1 : 0);\n          for(j=i; (j+nDel)<=nType; j++){\n            zType[j] = zType[j+nDel];\n          }\n          if( zType[i]=='\\0' && i>0 ){\n            assert(zType[i-1]==' ');\n            zType[i-1] = '\\0';\n          }\n          pTab->aCol[iCol].isHidden = 1;\n        }\n      }\n    }\n  }\n\n  sqlite3DbFree(db, zModuleName);\n  db->pVTab = 0;\n  return rc;\n}\n\n/*\n** This function is invoked by the parser to call the xConnect() method\n** of the virtual table pTab. If an error occurs, an error code is returned \n** and an error left in pParse.\n**\n** This call is a no-op if table pTab is not a virtual table.\n*/\nSQLITE_PRIVATE int sqlite3VtabCallConnect(Parse *pParse, Table *pTab){\n  sqlite3 *db = pParse->db;\n  const char *zMod;\n  Module *pMod;\n  int rc;\n\n  assert( pTab );\n  if( (pTab->tabFlags & TF_Virtual)==0 || sqlite3GetVTable(db, pTab) ){\n    return SQLITE_OK;\n  }\n\n  /* Locate the required virtual table module */\n  zMod = pTab->azModuleArg[0];\n  pMod = (Module*)sqlite3HashFind(&db->aModule, zMod, sqlite3Strlen30(zMod));\n\n  if( !pMod ){\n    const char *zModule = pTab->azModuleArg[0];\n    sqlite3ErrorMsg(pParse, \"no such module: %s\", zModule);\n    rc = SQLITE_ERROR;\n  }else{\n    char *zErr = 0;\n    rc = vtabCallConstructor(db, pTab, pMod, pMod->pModule->xConnect, &zErr);\n    if( rc!=SQLITE_OK ){\n      sqlite3ErrorMsg(pParse, \"%s\", zErr);\n    }\n    sqlite3DbFree(db, zErr);\n  }\n\n  return rc;\n}\n\n/*\n** Add the virtual table pVTab to the array sqlite3.aVTrans[].\n*/\nstatic int addToVTrans(sqlite3 *db, VTable *pVTab){\n  const int ARRAY_INCR = 5;\n\n  /* Grow the sqlite3.aVTrans array if required */\n  if( (db->nVTrans%ARRAY_INCR)==0 ){\n    VTable **aVTrans;\n    int nBytes = sizeof(sqlite3_vtab *) * (db->nVTrans + ARRAY_INCR);\n    aVTrans = sqlite3DbRealloc(db, (void *)db->aVTrans, nBytes);\n    if( !aVTrans ){\n      return SQLITE_NOMEM;\n    }\n    memset(&aVTrans[db->nVTrans], 0, sizeof(sqlite3_vtab *)*ARRAY_INCR);\n    db->aVTrans = aVTrans;\n  }\n\n  /* Add pVtab to the end of sqlite3.aVTrans */\n  db->aVTrans[db->nVTrans++] = pVTab;\n  sqlite3VtabLock(pVTab);\n  return SQLITE_OK;\n}\n\n/*\n** This function is invoked by the vdbe to call the xCreate method\n** of the virtual table named zTab in database iDb. \n**\n** If an error occurs, *pzErr is set to point an an English language\n** description of the error and an SQLITE_XXX error code is returned.\n** In this case the caller must call sqlite3DbFree(db, ) on *pzErr.\n*/\nSQLITE_PRIVATE int sqlite3VtabCallCreate(sqlite3 *db, int iDb, const char *zTab, char **pzErr){\n  int rc = SQLITE_OK;\n  Table *pTab;\n  Module *pMod;\n  const char *zMod;\n\n  pTab = sqlite3FindTable(db, zTab, db->aDb[iDb].zName);\n  assert( pTab && (pTab->tabFlags & TF_Virtual)!=0 && !pTab->pVTable );\n\n  /* Locate the required virtual table module */\n  zMod = pTab->azModuleArg[0];\n  pMod = (Module*)sqlite3HashFind(&db->aModule, zMod, sqlite3Strlen30(zMod));\n\n  /* If the module has been registered and includes a Create method, \n  ** invoke it now. If the module has not been registered, return an \n  ** error. Otherwise, do nothing.\n  */\n  if( !pMod ){\n    *pzErr = sqlite3MPrintf(db, \"no such module: %s\", zMod);\n    rc = SQLITE_ERROR;\n  }else{\n    rc = vtabCallConstructor(db, pTab, pMod, pMod->pModule->xCreate, pzErr);\n  }\n\n  /* Justification of ALWAYS():  The xConstructor method is required to\n  ** create a valid sqlite3_vtab if it returns SQLITE_OK. */\n  if( rc==SQLITE_OK && ALWAYS(sqlite3GetVTable(db, pTab)) ){\n      rc = addToVTrans(db, sqlite3GetVTable(db, pTab));\n  }\n\n  return rc;\n}\n\n/*\n** This function is used to set the schema of a virtual table.  It is only\n** valid to call this function from within the xCreate() or xConnect() of a\n** virtual table module.\n*/\nSQLITE_API int sqlite3_declare_vtab(sqlite3 *db, const char *zCreateTable){\n  Parse *pParse;\n\n  int rc = SQLITE_OK;\n  Table *pTab;\n  char *zErr = 0;\n\n  sqlite3_mutex_enter(db->mutex);\n  pTab = db->pVTab;\n  if( !pTab ){\n    sqlite3Error(db, SQLITE_MISUSE, 0);\n    sqlite3_mutex_leave(db->mutex);\n    return SQLITE_MISUSE_BKPT;\n  }\n  assert( (pTab->tabFlags & TF_Virtual)!=0 );\n\n  pParse = sqlite3StackAllocZero(db, sizeof(*pParse));\n  if( pParse==0 ){\n    rc = SQLITE_NOMEM;\n  }else{\n    pParse->declareVtab = 1;\n    pParse->db = db;\n    pParse->nQueryLoop = 1;\n  \n    if( SQLITE_OK==sqlite3RunParser(pParse, zCreateTable, &zErr) \n     && pParse->pNewTable\n     && !db->mallocFailed\n     && !pParse->pNewTable->pSelect\n     && (pParse->pNewTable->tabFlags & TF_Virtual)==0\n    ){\n      if( !pTab->aCol ){\n        pTab->aCol = pParse->pNewTable->aCol;\n        pTab->nCol = pParse->pNewTable->nCol;\n        pParse->pNewTable->nCol = 0;\n        pParse->pNewTable->aCol = 0;\n      }\n      db->pVTab = 0;\n    }else{\n      sqlite3Error(db, SQLITE_ERROR, (zErr ? \"%s\" : 0), zErr);\n      sqlite3DbFree(db, zErr);\n      rc = SQLITE_ERROR;\n    }\n    pParse->declareVtab = 0;\n  \n    if( pParse->pVdbe ){\n      sqlite3VdbeFinalize(pParse->pVdbe);\n    }\n    sqlite3DeleteTable(db, pParse->pNewTable);\n    sqlite3StackFree(db, pParse);\n  }\n\n  assert( (rc&0xff)==rc );\n  rc = sqlite3ApiExit(db, rc);\n  sqlite3_mutex_leave(db->mutex);\n  return rc;\n}\n\n/*\n** This function is invoked by the vdbe to call the xDestroy method\n** of the virtual table named zTab in database iDb. This occurs\n** when a DROP TABLE is mentioned.\n**\n** This call is a no-op if zTab is not a virtual table.\n*/\nSQLITE_PRIVATE int sqlite3VtabCallDestroy(sqlite3 *db, int iDb, const char *zTab){\n  int rc = SQLITE_OK;\n  Table *pTab;\n\n  pTab = sqlite3FindTable(db, zTab, db->aDb[iDb].zName);\n  if( ALWAYS(pTab!=0 && pTab->pVTable!=0) ){\n    VTable *p = vtabDisconnectAll(db, pTab);\n\n    assert( rc==SQLITE_OK );\n    rc = p->pMod->pModule->xDestroy(p->pVtab);\n\n    /* Remove the sqlite3_vtab* from the aVTrans[] array, if applicable */\n    if( rc==SQLITE_OK ){\n      assert( pTab->pVTable==p && p->pNext==0 );\n      p->pVtab = 0;\n      pTab->pVTable = 0;\n      sqlite3VtabUnlock(p);\n    }\n  }\n\n  return rc;\n}\n\n/*\n** This function invokes either the xRollback or xCommit method\n** of each of the virtual tables in the sqlite3.aVTrans array. The method\n** called is identified by the second argument, \"offset\", which is\n** the offset of the method to call in the sqlite3_module structure.\n**\n** The array is cleared after invoking the callbacks. \n*/\nstatic void callFinaliser(sqlite3 *db, int offset){\n  int i;\n  if( db->aVTrans ){\n    for(i=0; i<db->nVTrans; i++){\n      VTable *pVTab = db->aVTrans[i];\n      sqlite3_vtab *p = pVTab->pVtab;\n      if( p ){\n        int (*x)(sqlite3_vtab *);\n        x = *(int (**)(sqlite3_vtab *))((char *)p->pModule + offset);\n        if( x ) x(p);\n      }\n      sqlite3VtabUnlock(pVTab);\n    }\n    sqlite3DbFree(db, db->aVTrans);\n    db->nVTrans = 0;\n    db->aVTrans = 0;\n  }\n}\n\n/*\n** Invoke the xSync method of all virtual tables in the sqlite3.aVTrans\n** array. Return the error code for the first error that occurs, or\n** SQLITE_OK if all xSync operations are successful.\n**\n** Set *pzErrmsg to point to a buffer that should be released using \n** sqlite3DbFree() containing an error message, if one is available.\n*/\nSQLITE_PRIVATE int sqlite3VtabSync(sqlite3 *db, char **pzErrmsg){\n  int i;\n  int rc = SQLITE_OK;\n  VTable **aVTrans = db->aVTrans;\n\n  db->aVTrans = 0;\n  for(i=0; rc==SQLITE_OK && i<db->nVTrans; i++){\n    int (*x)(sqlite3_vtab *);\n    sqlite3_vtab *pVtab = aVTrans[i]->pVtab;\n    if( pVtab && (x = pVtab->pModule->xSync)!=0 ){\n      rc = x(pVtab);\n      sqlite3DbFree(db, *pzErrmsg);\n      *pzErrmsg = sqlite3DbStrDup(db, pVtab->zErrMsg);\n      sqlite3_free(pVtab->zErrMsg);\n    }\n  }\n  db->aVTrans = aVTrans;\n  return rc;\n}\n\n/*\n** Invoke the xRollback method of all virtual tables in the \n** sqlite3.aVTrans array. Then clear the array itself.\n*/\nSQLITE_PRIVATE int sqlite3VtabRollback(sqlite3 *db){\n  callFinaliser(db, offsetof(sqlite3_module,xRollback));\n  return SQLITE_OK;\n}\n\n/*\n** Invoke the xCommit method of all virtual tables in the \n** sqlite3.aVTrans array. Then clear the array itself.\n*/\nSQLITE_PRIVATE int sqlite3VtabCommit(sqlite3 *db){\n  callFinaliser(db, offsetof(sqlite3_module,xCommit));\n  return SQLITE_OK;\n}\n\n/*\n** If the virtual table pVtab supports the transaction interface\n** (xBegin/xRollback/xCommit and optionally xSync) and a transaction is\n** not currently open, invoke the xBegin method now.\n**\n** If the xBegin call is successful, place the sqlite3_vtab pointer\n** in the sqlite3.aVTrans array.\n*/\nSQLITE_PRIVATE int sqlite3VtabBegin(sqlite3 *db, VTable *pVTab){\n  int rc = SQLITE_OK;\n  const sqlite3_module *pModule;\n\n  /* Special case: If db->aVTrans is NULL and db->nVTrans is greater\n  ** than zero, then this function is being called from within a\n  ** virtual module xSync() callback. It is illegal to write to \n  ** virtual module tables in this case, so return SQLITE_LOCKED.\n  */\n  if( sqlite3VtabInSync(db) ){\n    return SQLITE_LOCKED;\n  }\n  if( !pVTab ){\n    return SQLITE_OK;\n  } \n  pModule = pVTab->pVtab->pModule;\n\n  if( pModule->xBegin ){\n    int i;\n\n\n    /* If pVtab is already in the aVTrans array, return early */\n    for(i=0; i<db->nVTrans; i++){\n      if( db->aVTrans[i]==pVTab ){\n        return SQLITE_OK;\n      }\n    }\n\n    /* Invoke the xBegin method */\n    rc = pModule->xBegin(pVTab->pVtab);\n    if( rc==SQLITE_OK ){\n      rc = addToVTrans(db, pVTab);\n    }\n  }\n  return rc;\n}\n\n/*\n** The first parameter (pDef) is a function implementation.  The\n** second parameter (pExpr) is the first argument to this function.\n** If pExpr is a column in a virtual table, then let the virtual\n** table implementation have an opportunity to overload the function.\n**\n** This routine is used to allow virtual table implementations to\n** overload MATCH, LIKE, GLOB, and REGEXP operators.\n**\n** Return either the pDef argument (indicating no change) or a \n** new FuncDef structure that is marked as ephemeral using the\n** SQLITE_FUNC_EPHEM flag.\n*/\nSQLITE_PRIVATE FuncDef *sqlite3VtabOverloadFunction(\n  sqlite3 *db,    /* Database connection for reporting malloc problems */\n  FuncDef *pDef,  /* Function to possibly overload */\n  int nArg,       /* Number of arguments to the function */\n  Expr *pExpr     /* First argument to the function */\n){\n  Table *pTab;\n  sqlite3_vtab *pVtab;\n  sqlite3_module *pMod;\n  void (*xFunc)(sqlite3_context*,int,sqlite3_value**) = 0;\n  void *pArg = 0;\n  FuncDef *pNew;\n  int rc = 0;\n  char *zLowerName;\n  unsigned char *z;\n\n\n  /* Check to see the left operand is a column in a virtual table */\n  if( NEVER(pExpr==0) ) return pDef;\n  if( pExpr->op!=TK_COLUMN ) return pDef;\n  pTab = pExpr->pTab;\n  if( NEVER(pTab==0) ) return pDef;\n  if( (pTab->tabFlags & TF_Virtual)==0 ) return pDef;\n  pVtab = sqlite3GetVTable(db, pTab)->pVtab;\n  assert( pVtab!=0 );\n  assert( pVtab->pModule!=0 );\n  pMod = (sqlite3_module *)pVtab->pModule;\n  if( pMod->xFindFunction==0 ) return pDef;\n \n  /* Call the xFindFunction method on the virtual table implementation\n  ** to see if the implementation wants to overload this function \n  */\n  zLowerName = sqlite3DbStrDup(db, pDef->zName);\n  if( zLowerName ){\n    for(z=(unsigned char*)zLowerName; *z; z++){\n      *z = sqlite3UpperToLower[*z];\n    }\n    rc = pMod->xFindFunction(pVtab, nArg, zLowerName, &xFunc, &pArg);\n    sqlite3DbFree(db, zLowerName);\n  }\n  if( rc==0 ){\n    return pDef;\n  }\n\n  /* Create a new ephemeral function definition for the overloaded\n  ** function */\n  pNew = sqlite3DbMallocZero(db, sizeof(*pNew)\n                             + sqlite3Strlen30(pDef->zName) + 1);\n  if( pNew==0 ){\n    return pDef;\n  }\n  *pNew = *pDef;\n  pNew->zName = (char *)&pNew[1];\n  memcpy(pNew->zName, pDef->zName, sqlite3Strlen30(pDef->zName)+1);\n  pNew->xFunc = xFunc;\n  pNew->pUserData = pArg;\n  pNew->flags |= SQLITE_FUNC_EPHEM;\n  return pNew;\n}\n\n/*\n** Make sure virtual table pTab is contained in the pParse->apVirtualLock[]\n** array so that an OP_VBegin will get generated for it.  Add pTab to the\n** array if it is missing.  If pTab is already in the array, this routine\n** is a no-op.\n*/\nSQLITE_PRIVATE void sqlite3VtabMakeWritable(Parse *pParse, Table *pTab){\n  Parse *pToplevel = sqlite3ParseToplevel(pParse);\n  int i, n;\n  Table **apVtabLock;\n\n  assert( IsVirtual(pTab) );\n  for(i=0; i<pToplevel->nVtabLock; i++){\n    if( pTab==pToplevel->apVtabLock[i] ) return;\n  }\n  n = (pToplevel->nVtabLock+1)*sizeof(pToplevel->apVtabLock[0]);\n  apVtabLock = sqlite3_realloc(pToplevel->apVtabLock, n);\n  if( apVtabLock ){\n    pToplevel->apVtabLock = apVtabLock;\n    pToplevel->apVtabLock[pToplevel->nVtabLock++] = pTab;\n  }else{\n    pToplevel->db->mallocFailed = 1;\n  }\n}\n\n#endif /* SQLITE_OMIT_VIRTUALTABLE */\n\n/************** End of vtab.c ************************************************/\n/************** Begin file where.c *******************************************/\n/*\n** 2001 September 15\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This module contains C code that generates VDBE code used to process\n** the WHERE clause of SQL statements.  This module is responsible for\n** generating the code that loops through a table looking for applicable\n** rows.  Indices are selected and used to speed the search when doing\n** so is applicable.  Because this module is responsible for selecting\n** indices, you might also think of this module as the \"query optimizer\".\n*/\n\n\n/*\n** Trace output macros\n*/\n#if defined(SQLITE_TEST) || defined(SQLITE_DEBUG)\nSQLITE_PRIVATE int sqlite3WhereTrace = 0;\n#endif\n#if defined(SQLITE_TEST) && defined(SQLITE_DEBUG)\n# define WHERETRACE(X)  if(sqlite3WhereTrace) sqlite3DebugPrintf X\n#else\n# define WHERETRACE(X)\n#endif\n\n/* Forward reference\n*/\ntypedef struct WhereClause WhereClause;\ntypedef struct WhereMaskSet WhereMaskSet;\ntypedef struct WhereOrInfo WhereOrInfo;\ntypedef struct WhereAndInfo WhereAndInfo;\ntypedef struct WhereCost WhereCost;\n\n/*\n** The query generator uses an array of instances of this structure to\n** help it analyze the subexpressions of the WHERE clause.  Each WHERE\n** clause subexpression is separated from the others by AND operators,\n** usually, or sometimes subexpressions separated by OR.\n**\n** All WhereTerms are collected into a single WhereClause structure.  \n** The following identity holds:\n**\n**        WhereTerm.pWC->a[WhereTerm.idx] == WhereTerm\n**\n** When a term is of the form:\n**\n**              X <op> <expr>\n**\n** where X is a column name and <op> is one of certain operators,\n** then WhereTerm.leftCursor and WhereTerm.u.leftColumn record the\n** cursor number and column number for X.  WhereTerm.eOperator records\n** the <op> using a bitmask encoding defined by WO_xxx below.  The\n** use of a bitmask encoding for the operator allows us to search\n** quickly for terms that match any of several different operators.\n**\n** A WhereTerm might also be two or more subterms connected by OR:\n**\n**         (t1.X <op> <expr>) OR (t1.Y <op> <expr>) OR ....\n**\n** In this second case, wtFlag as the TERM_ORINFO set and eOperator==WO_OR\n** and the WhereTerm.u.pOrInfo field points to auxiliary information that\n** is collected about the\n**\n** If a term in the WHERE clause does not match either of the two previous\n** categories, then eOperator==0.  The WhereTerm.pExpr field is still set\n** to the original subexpression content and wtFlags is set up appropriately\n** but no other fields in the WhereTerm object are meaningful.\n**\n** When eOperator!=0, prereqRight and prereqAll record sets of cursor numbers,\n** but they do so indirectly.  A single WhereMaskSet structure translates\n** cursor number into bits and the translated bit is stored in the prereq\n** fields.  The translation is used in order to maximize the number of\n** bits that will fit in a Bitmask.  The VDBE cursor numbers might be\n** spread out over the non-negative integers.  For example, the cursor\n** numbers might be 3, 8, 9, 10, 20, 23, 41, and 45.  The WhereMaskSet\n** translates these sparse cursor numbers into consecutive integers\n** beginning with 0 in order to make the best possible use of the available\n** bits in the Bitmask.  So, in the example above, the cursor numbers\n** would be mapped into integers 0 through 7.\n**\n** The number of terms in a join is limited by the number of bits\n** in prereqRight and prereqAll.  The default is 64 bits, hence SQLite\n** is only able to process joins with 64 or fewer tables.\n*/\ntypedef struct WhereTerm WhereTerm;\nstruct WhereTerm {\n  Expr *pExpr;            /* Pointer to the subexpression that is this term */\n  int iParent;            /* Disable pWC->a[iParent] when this term disabled */\n  int leftCursor;         /* Cursor number of X in \"X <op> <expr>\" */\n  union {\n    int leftColumn;         /* Column number of X in \"X <op> <expr>\" */\n    WhereOrInfo *pOrInfo;   /* Extra information if eOperator==WO_OR */\n    WhereAndInfo *pAndInfo; /* Extra information if eOperator==WO_AND */\n  } u;\n  u16 eOperator;          /* A WO_xx value describing <op> */\n  u8 wtFlags;             /* TERM_xxx bit flags.  See below */\n  u8 nChild;              /* Number of children that must disable us */\n  WhereClause *pWC;       /* The clause this term is part of */\n  Bitmask prereqRight;    /* Bitmask of tables used by pExpr->pRight */\n  Bitmask prereqAll;      /* Bitmask of tables referenced by pExpr */\n};\n\n/*\n** Allowed values of WhereTerm.wtFlags\n*/\n#define TERM_DYNAMIC    0x01   /* Need to call sqlite3ExprDelete(db, pExpr) */\n#define TERM_VIRTUAL    0x02   /* Added by the optimizer.  Do not code */\n#define TERM_CODED      0x04   /* This term is already coded */\n#define TERM_COPIED     0x08   /* Has a child */\n#define TERM_ORINFO     0x10   /* Need to free the WhereTerm.u.pOrInfo object */\n#define TERM_ANDINFO    0x20   /* Need to free the WhereTerm.u.pAndInfo obj */\n#define TERM_OR_OK      0x40   /* Used during OR-clause processing */\n#ifdef SQLITE_ENABLE_STAT2\n#  define TERM_VNULL    0x80   /* Manufactured x>NULL or x<=NULL term */\n#else\n#  define TERM_VNULL    0x00   /* Disabled if not using stat2 */\n#endif\n\n/*\n** An instance of the following structure holds all information about a\n** WHERE clause.  Mostly this is a container for one or more WhereTerms.\n*/\nstruct WhereClause {\n  Parse *pParse;           /* The parser context */\n  WhereMaskSet *pMaskSet;  /* Mapping of table cursor numbers to bitmasks */\n  Bitmask vmask;           /* Bitmask identifying virtual table cursors */\n  u8 op;                   /* Split operator.  TK_AND or TK_OR */\n  int nTerm;               /* Number of terms */\n  int nSlot;               /* Number of entries in a[] */\n  WhereTerm *a;            /* Each a[] describes a term of the WHERE cluase */\n#if defined(SQLITE_SMALL_STACK)\n  WhereTerm aStatic[1];    /* Initial static space for a[] */\n#else\n  WhereTerm aStatic[8];    /* Initial static space for a[] */\n#endif\n};\n\n/*\n** A WhereTerm with eOperator==WO_OR has its u.pOrInfo pointer set to\n** a dynamically allocated instance of the following structure.\n*/\nstruct WhereOrInfo {\n  WhereClause wc;          /* Decomposition into subterms */\n  Bitmask indexable;       /* Bitmask of all indexable tables in the clause */\n};\n\n/*\n** A WhereTerm with eOperator==WO_AND has its u.pAndInfo pointer set to\n** a dynamically allocated instance of the following structure.\n*/\nstruct WhereAndInfo {\n  WhereClause wc;          /* The subexpression broken out */\n};\n\n/*\n** An instance of the following structure keeps track of a mapping\n** between VDBE cursor numbers and bits of the bitmasks in WhereTerm.\n**\n** The VDBE cursor numbers are small integers contained in \n** SrcList_item.iCursor and Expr.iTable fields.  For any given WHERE \n** clause, the cursor numbers might not begin with 0 and they might\n** contain gaps in the numbering sequence.  But we want to make maximum\n** use of the bits in our bitmasks.  This structure provides a mapping\n** from the sparse cursor numbers into consecutive integers beginning\n** with 0.\n**\n** If WhereMaskSet.ix[A]==B it means that The A-th bit of a Bitmask\n** corresponds VDBE cursor number B.  The A-th bit of a bitmask is 1<<A.\n**\n** For example, if the WHERE clause expression used these VDBE\n** cursors:  4, 5, 8, 29, 57, 73.  Then the  WhereMaskSet structure\n** would map those cursor numbers into bits 0 through 5.\n**\n** Note that the mapping is not necessarily ordered.  In the example\n** above, the mapping might go like this:  4->3, 5->1, 8->2, 29->0,\n** 57->5, 73->4.  Or one of 719 other combinations might be used. It\n** does not really matter.  What is important is that sparse cursor\n** numbers all get mapped into bit numbers that begin with 0 and contain\n** no gaps.\n*/\nstruct WhereMaskSet {\n  int n;                        /* Number of assigned cursor values */\n  int ix[BMS];                  /* Cursor assigned to each bit */\n};\n\n/*\n** A WhereCost object records a lookup strategy and the estimated\n** cost of pursuing that strategy.\n*/\nstruct WhereCost {\n  WherePlan plan;    /* The lookup strategy */\n  double rCost;      /* Overall cost of pursuing this search strategy */\n  Bitmask used;      /* Bitmask of cursors used by this plan */\n};\n\n/*\n** Bitmasks for the operators that indices are able to exploit.  An\n** OR-ed combination of these values can be used when searching for\n** terms in the where clause.\n*/\n#define WO_IN     0x001\n#define WO_EQ     0x002\n#define WO_LT     (WO_EQ<<(TK_LT-TK_EQ))\n#define WO_LE     (WO_EQ<<(TK_LE-TK_EQ))\n#define WO_GT     (WO_EQ<<(TK_GT-TK_EQ))\n#define WO_GE     (WO_EQ<<(TK_GE-TK_EQ))\n#define WO_MATCH  0x040\n#define WO_ISNULL 0x080\n#define WO_OR     0x100       /* Two or more OR-connected terms */\n#define WO_AND    0x200       /* Two or more AND-connected terms */\n#define WO_NOOP   0x800       /* This term does not restrict search space */\n\n#define WO_ALL    0xfff       /* Mask of all possible WO_* values */\n#define WO_SINGLE 0x0ff       /* Mask of all non-compound WO_* values */\n\n/*\n** Value for wsFlags returned by bestIndex() and stored in\n** WhereLevel.wsFlags.  These flags determine which search\n** strategies are appropriate.\n**\n** The least significant 12 bits is reserved as a mask for WO_ values above.\n** The WhereLevel.wsFlags field is usually set to WO_IN|WO_EQ|WO_ISNULL.\n** But if the table is the right table of a left join, WhereLevel.wsFlags\n** is set to WO_IN|WO_EQ.  The WhereLevel.wsFlags field can then be used as\n** the \"op\" parameter to findTerm when we are resolving equality constraints.\n** ISNULL constraints will then not be used on the right table of a left\n** join.  Tickets #2177 and #2189.\n*/\n#define WHERE_ROWID_EQ     0x00001000  /* rowid=EXPR or rowid IN (...) */\n#define WHERE_ROWID_RANGE  0x00002000  /* rowid<EXPR and/or rowid>EXPR */\n#define WHERE_COLUMN_EQ    0x00010000  /* x=EXPR or x IN (...) or x IS NULL */\n#define WHERE_COLUMN_RANGE 0x00020000  /* x<EXPR and/or x>EXPR */\n#define WHERE_COLUMN_IN    0x00040000  /* x IN (...) */\n#define WHERE_COLUMN_NULL  0x00080000  /* x IS NULL */\n#define WHERE_INDEXED      0x000f0000  /* Anything that uses an index */\n#define WHERE_NOT_FULLSCAN 0x100f3000  /* Does not do a full table scan */\n#define WHERE_IN_ABLE      0x000f1000  /* Able to support an IN operator */\n#define WHERE_TOP_LIMIT    0x00100000  /* x<EXPR or x<=EXPR constraint */\n#define WHERE_BTM_LIMIT    0x00200000  /* x>EXPR or x>=EXPR constraint */\n#define WHERE_BOTH_LIMIT   0x00300000  /* Both x>EXPR and x<EXPR */\n#define WHERE_IDX_ONLY     0x00800000  /* Use index only - omit table */\n#define WHERE_ORDERBY      0x01000000  /* Output will appear in correct order */\n#define WHERE_REVERSE      0x02000000  /* Scan in reverse order */\n#define WHERE_UNIQUE       0x04000000  /* Selects no more than one row */\n#define WHERE_VIRTUALTABLE 0x08000000  /* Use virtual-table processing */\n#define WHERE_MULTI_OR     0x10000000  /* OR using multiple indices */\n#define WHERE_TEMP_INDEX   0x20000000  /* Uses an ephemeral index */\n\n/*\n** Initialize a preallocated WhereClause structure.\n*/\nstatic void whereClauseInit(\n  WhereClause *pWC,        /* The WhereClause to be initialized */\n  Parse *pParse,           /* The parsing context */\n  WhereMaskSet *pMaskSet   /* Mapping from table cursor numbers to bitmasks */\n){\n  pWC->pParse = pParse;\n  pWC->pMaskSet = pMaskSet;\n  pWC->nTerm = 0;\n  pWC->nSlot = ArraySize(pWC->aStatic);\n  pWC->a = pWC->aStatic;\n  pWC->vmask = 0;\n}\n\n/* Forward reference */\nstatic void whereClauseClear(WhereClause*);\n\n/*\n** Deallocate all memory associated with a WhereOrInfo object.\n*/\nstatic void whereOrInfoDelete(sqlite3 *db, WhereOrInfo *p){\n  whereClauseClear(&p->wc);\n  sqlite3DbFree(db, p);\n}\n\n/*\n** Deallocate all memory associated with a WhereAndInfo object.\n*/\nstatic void whereAndInfoDelete(sqlite3 *db, WhereAndInfo *p){\n  whereClauseClear(&p->wc);\n  sqlite3DbFree(db, p);\n}\n\n/*\n** Deallocate a WhereClause structure.  The WhereClause structure\n** itself is not freed.  This routine is the inverse of whereClauseInit().\n*/\nstatic void whereClauseClear(WhereClause *pWC){\n  int i;\n  WhereTerm *a;\n  sqlite3 *db = pWC->pParse->db;\n  for(i=pWC->nTerm-1, a=pWC->a; i>=0; i--, a++){\n    if( a->wtFlags & TERM_DYNAMIC ){\n      sqlite3ExprDelete(db, a->pExpr);\n    }\n    if( a->wtFlags & TERM_ORINFO ){\n      whereOrInfoDelete(db, a->u.pOrInfo);\n    }else if( a->wtFlags & TERM_ANDINFO ){\n      whereAndInfoDelete(db, a->u.pAndInfo);\n    }\n  }\n  if( pWC->a!=pWC->aStatic ){\n    sqlite3DbFree(db, pWC->a);\n  }\n}\n\n/*\n** Add a single new WhereTerm entry to the WhereClause object pWC.\n** The new WhereTerm object is constructed from Expr p and with wtFlags.\n** The index in pWC->a[] of the new WhereTerm is returned on success.\n** 0 is returned if the new WhereTerm could not be added due to a memory\n** allocation error.  The memory allocation failure will be recorded in\n** the db->mallocFailed flag so that higher-level functions can detect it.\n**\n** This routine will increase the size of the pWC->a[] array as necessary.\n**\n** If the wtFlags argument includes TERM_DYNAMIC, then responsibility\n** for freeing the expression p is assumed by the WhereClause object pWC.\n** This is true even if this routine fails to allocate a new WhereTerm.\n**\n** WARNING:  This routine might reallocate the space used to store\n** WhereTerms.  All pointers to WhereTerms should be invalidated after\n** calling this routine.  Such pointers may be reinitialized by referencing\n** the pWC->a[] array.\n*/\nstatic int whereClauseInsert(WhereClause *pWC, Expr *p, u8 wtFlags){\n  WhereTerm *pTerm;\n  int idx;\n  testcase( wtFlags & TERM_VIRTUAL );  /* EV: R-00211-15100 */\n  if( pWC->nTerm>=pWC->nSlot ){\n    WhereTerm *pOld = pWC->a;\n    sqlite3 *db = pWC->pParse->db;\n    pWC->a = sqlite3DbMallocRaw(db, sizeof(pWC->a[0])*pWC->nSlot*2 );\n    if( pWC->a==0 ){\n      if( wtFlags & TERM_DYNAMIC ){\n        sqlite3ExprDelete(db, p);\n      }\n      pWC->a = pOld;\n      return 0;\n    }\n    memcpy(pWC->a, pOld, sizeof(pWC->a[0])*pWC->nTerm);\n    if( pOld!=pWC->aStatic ){\n      sqlite3DbFree(db, pOld);\n    }\n    pWC->nSlot = sqlite3DbMallocSize(db, pWC->a)/sizeof(pWC->a[0]);\n  }\n  pTerm = &pWC->a[idx = pWC->nTerm++];\n  pTerm->pExpr = p;\n  pTerm->wtFlags = wtFlags;\n  pTerm->pWC = pWC;\n  pTerm->iParent = -1;\n  return idx;\n}\n\n/*\n** This routine identifies subexpressions in the WHERE clause where\n** each subexpression is separated by the AND operator or some other\n** operator specified in the op parameter.  The WhereClause structure\n** is filled with pointers to subexpressions.  For example:\n**\n**    WHERE  a=='hello' AND coalesce(b,11)<10 AND (c+12!=d OR c==22)\n**           \\________/     \\_______________/     \\________________/\n**            slot[0]            slot[1]               slot[2]\n**\n** The original WHERE clause in pExpr is unaltered.  All this routine\n** does is make slot[] entries point to substructure within pExpr.\n**\n** In the previous sentence and in the diagram, \"slot[]\" refers to\n** the WhereClause.a[] array.  The slot[] array grows as needed to contain\n** all terms of the WHERE clause.\n*/\nstatic void whereSplit(WhereClause *pWC, Expr *pExpr, int op){\n  pWC->op = (u8)op;\n  if( pExpr==0 ) return;\n  if( pExpr->op!=op ){\n    whereClauseInsert(pWC, pExpr, 0);\n  }else{\n    whereSplit(pWC, pExpr->pLeft, op);\n    whereSplit(pWC, pExpr->pRight, op);\n  }\n}\n\n/*\n** Initialize an expression mask set (a WhereMaskSet object)\n*/\n#define initMaskSet(P)  memset(P, 0, sizeof(*P))\n\n/*\n** Return the bitmask for the given cursor number.  Return 0 if\n** iCursor is not in the set.\n*/\nstatic Bitmask getMask(WhereMaskSet *pMaskSet, int iCursor){\n  int i;\n  assert( pMaskSet->n<=sizeof(Bitmask)*8 );\n  for(i=0; i<pMaskSet->n; i++){\n    if( pMaskSet->ix[i]==iCursor ){\n      return ((Bitmask)1)<<i;\n    }\n  }\n  return 0;\n}\n\n/*\n** Create a new mask for cursor iCursor.\n**\n** There is one cursor per table in the FROM clause.  The number of\n** tables in the FROM clause is limited by a test early in the\n** sqlite3WhereBegin() routine.  So we know that the pMaskSet->ix[]\n** array will never overflow.\n*/\nstatic void createMask(WhereMaskSet *pMaskSet, int iCursor){\n  assert( pMaskSet->n < ArraySize(pMaskSet->ix) );\n  pMaskSet->ix[pMaskSet->n++] = iCursor;\n}\n\n/*\n** This routine walks (recursively) an expression tree and generates\n** a bitmask indicating which tables are used in that expression\n** tree.\n**\n** In order for this routine to work, the calling function must have\n** previously invoked sqlite3ResolveExprNames() on the expression.  See\n** the header comment on that routine for additional information.\n** The sqlite3ResolveExprNames() routines looks for column names and\n** sets their opcodes to TK_COLUMN and their Expr.iTable fields to\n** the VDBE cursor number of the table.  This routine just has to\n** translate the cursor numbers into bitmask values and OR all\n** the bitmasks together.\n*/\nstatic Bitmask exprListTableUsage(WhereMaskSet*, ExprList*);\nstatic Bitmask exprSelectTableUsage(WhereMaskSet*, Select*);\nstatic Bitmask exprTableUsage(WhereMaskSet *pMaskSet, Expr *p){\n  Bitmask mask = 0;\n  if( p==0 ) return 0;\n  if( p->op==TK_COLUMN ){\n    mask = getMask(pMaskSet, p->iTable);\n    return mask;\n  }\n  mask = exprTableUsage(pMaskSet, p->pRight);\n  mask |= exprTableUsage(pMaskSet, p->pLeft);\n  if( ExprHasProperty(p, EP_xIsSelect) ){\n    mask |= exprSelectTableUsage(pMaskSet, p->x.pSelect);\n  }else{\n    mask |= exprListTableUsage(pMaskSet, p->x.pList);\n  }\n  return mask;\n}\nstatic Bitmask exprListTableUsage(WhereMaskSet *pMaskSet, ExprList *pList){\n  int i;\n  Bitmask mask = 0;\n  if( pList ){\n    for(i=0; i<pList->nExpr; i++){\n      mask |= exprTableUsage(pMaskSet, pList->a[i].pExpr);\n    }\n  }\n  return mask;\n}\nstatic Bitmask exprSelectTableUsage(WhereMaskSet *pMaskSet, Select *pS){\n  Bitmask mask = 0;\n  while( pS ){\n    mask |= exprListTableUsage(pMaskSet, pS->pEList);\n    mask |= exprListTableUsage(pMaskSet, pS->pGroupBy);\n    mask |= exprListTableUsage(pMaskSet, pS->pOrderBy);\n    mask |= exprTableUsage(pMaskSet, pS->pWhere);\n    mask |= exprTableUsage(pMaskSet, pS->pHaving);\n    pS = pS->pPrior;\n  }\n  return mask;\n}\n\n/*\n** Return TRUE if the given operator is one of the operators that is\n** allowed for an indexable WHERE clause term.  The allowed operators are\n** \"=\", \"<\", \">\", \"<=\", \">=\", and \"IN\".\n**\n** IMPLEMENTATION-OF: R-59926-26393 To be usable by an index a term must be\n** of one of the following forms: column = expression column > expression\n** column >= expression column < expression column <= expression\n** expression = column expression > column expression >= column\n** expression < column expression <= column column IN\n** (expression-list) column IN (subquery) column IS NULL\n*/\nstatic int allowedOp(int op){\n  assert( TK_GT>TK_EQ && TK_GT<TK_GE );\n  assert( TK_LT>TK_EQ && TK_LT<TK_GE );\n  assert( TK_LE>TK_EQ && TK_LE<TK_GE );\n  assert( TK_GE==TK_EQ+4 );\n  return op==TK_IN || (op>=TK_EQ && op<=TK_GE) || op==TK_ISNULL;\n}\n\n/*\n** Swap two objects of type TYPE.\n*/\n#define SWAP(TYPE,A,B) {TYPE t=A; A=B; B=t;}\n\n/*\n** Commute a comparison operator.  Expressions of the form \"X op Y\"\n** are converted into \"Y op X\".\n**\n** If a collation sequence is associated with either the left or right\n** side of the comparison, it remains associated with the same side after\n** the commutation. So \"Y collate NOCASE op X\" becomes \n** \"X collate NOCASE op Y\". This is because any collation sequence on\n** the left hand side of a comparison overrides any collation sequence \n** attached to the right. For the same reason the EP_ExpCollate flag\n** is not commuted.\n*/\nstatic void exprCommute(Parse *pParse, Expr *pExpr){\n  u16 expRight = (pExpr->pRight->flags & EP_ExpCollate);\n  u16 expLeft = (pExpr->pLeft->flags & EP_ExpCollate);\n  assert( allowedOp(pExpr->op) && pExpr->op!=TK_IN );\n  pExpr->pRight->pColl = sqlite3ExprCollSeq(pParse, pExpr->pRight);\n  pExpr->pLeft->pColl = sqlite3ExprCollSeq(pParse, pExpr->pLeft);\n  SWAP(CollSeq*,pExpr->pRight->pColl,pExpr->pLeft->pColl);\n  pExpr->pRight->flags = (pExpr->pRight->flags & ~EP_ExpCollate) | expLeft;\n  pExpr->pLeft->flags = (pExpr->pLeft->flags & ~EP_ExpCollate) | expRight;\n  SWAP(Expr*,pExpr->pRight,pExpr->pLeft);\n  if( pExpr->op>=TK_GT ){\n    assert( TK_LT==TK_GT+2 );\n    assert( TK_GE==TK_LE+2 );\n    assert( TK_GT>TK_EQ );\n    assert( TK_GT<TK_LE );\n    assert( pExpr->op>=TK_GT && pExpr->op<=TK_GE );\n    pExpr->op = ((pExpr->op-TK_GT)^2)+TK_GT;\n  }\n}\n\n/*\n** Translate from TK_xx operator to WO_xx bitmask.\n*/\nstatic u16 operatorMask(int op){\n  u16 c;\n  assert( allowedOp(op) );\n  if( op==TK_IN ){\n    c = WO_IN;\n  }else if( op==TK_ISNULL ){\n    c = WO_ISNULL;\n  }else{\n    assert( (WO_EQ<<(op-TK_EQ)) < 0x7fff );\n    c = (u16)(WO_EQ<<(op-TK_EQ));\n  }\n  assert( op!=TK_ISNULL || c==WO_ISNULL );\n  assert( op!=TK_IN || c==WO_IN );\n  assert( op!=TK_EQ || c==WO_EQ );\n  assert( op!=TK_LT || c==WO_LT );\n  assert( op!=TK_LE || c==WO_LE );\n  assert( op!=TK_GT || c==WO_GT );\n  assert( op!=TK_GE || c==WO_GE );\n  return c;\n}\n\n/*\n** Search for a term in the WHERE clause that is of the form \"X <op> <expr>\"\n** where X is a reference to the iColumn of table iCur and <op> is one of\n** the WO_xx operator codes specified by the op parameter.\n** Return a pointer to the term.  Return 0 if not found.\n*/\nstatic WhereTerm *findTerm(\n  WhereClause *pWC,     /* The WHERE clause to be searched */\n  int iCur,             /* Cursor number of LHS */\n  int iColumn,          /* Column number of LHS */\n  Bitmask notReady,     /* RHS must not overlap with this mask */\n  u32 op,               /* Mask of WO_xx values describing operator */\n  Index *pIdx           /* Must be compatible with this index, if not NULL */\n){\n  WhereTerm *pTerm;\n  int k;\n  assert( iCur>=0 );\n  op &= WO_ALL;\n  for(pTerm=pWC->a, k=pWC->nTerm; k; k--, pTerm++){\n    if( pTerm->leftCursor==iCur\n       && (pTerm->prereqRight & notReady)==0\n       && pTerm->u.leftColumn==iColumn\n       && (pTerm->eOperator & op)!=0\n    ){\n      if( pIdx && pTerm->eOperator!=WO_ISNULL ){\n        Expr *pX = pTerm->pExpr;\n        CollSeq *pColl;\n        char idxaff;\n        int j;\n        Parse *pParse = pWC->pParse;\n\n        idxaff = pIdx->pTable->aCol[iColumn].affinity;\n        if( !sqlite3IndexAffinityOk(pX, idxaff) ) continue;\n\n        /* Figure out the collation sequence required from an index for\n        ** it to be useful for optimising expression pX. Store this\n        ** value in variable pColl.\n        */\n        assert(pX->pLeft);\n        pColl = sqlite3BinaryCompareCollSeq(pParse, pX->pLeft, pX->pRight);\n        assert(pColl || pParse->nErr);\n\n        for(j=0; pIdx->aiColumn[j]!=iColumn; j++){\n          if( NEVER(j>=pIdx->nColumn) ) return 0;\n        }\n        if( pColl && sqlite3StrICmp(pColl->zName, pIdx->azColl[j]) ) continue;\n      }\n      return pTerm;\n    }\n  }\n  return 0;\n}\n\n/* Forward reference */\nstatic void exprAnalyze(SrcList*, WhereClause*, int);\n\n/*\n** Call exprAnalyze on all terms in a WHERE clause.  \n**\n**\n*/\nstatic void exprAnalyzeAll(\n  SrcList *pTabList,       /* the FROM clause */\n  WhereClause *pWC         /* the WHERE clause to be analyzed */\n){\n  int i;\n  for(i=pWC->nTerm-1; i>=0; i--){\n    exprAnalyze(pTabList, pWC, i);\n  }\n}\n\n#ifndef SQLITE_OMIT_LIKE_OPTIMIZATION\n/*\n** Check to see if the given expression is a LIKE or GLOB operator that\n** can be optimized using inequality constraints.  Return TRUE if it is\n** so and false if not.\n**\n** In order for the operator to be optimizible, the RHS must be a string\n** literal that does not begin with a wildcard.  \n*/\nstatic int isLikeOrGlob(\n  Parse *pParse,    /* Parsing and code generating context */\n  Expr *pExpr,      /* Test this expression */\n  Expr **ppPrefix,  /* Pointer to TK_STRING expression with pattern prefix */\n  int *pisComplete, /* True if the only wildcard is % in the last character */\n  int *pnoCase      /* True if uppercase is equivalent to lowercase */\n){\n  const char *z = 0;         /* String on RHS of LIKE operator */\n  Expr *pRight, *pLeft;      /* Right and left size of LIKE operator */\n  ExprList *pList;           /* List of operands to the LIKE operator */\n  int c;                     /* One character in z[] */\n  int cnt;                   /* Number of non-wildcard prefix characters */\n  char wc[3];                /* Wildcard characters */\n  sqlite3 *db = pParse->db;  /* Database connection */\n  sqlite3_value *pVal = 0;\n  int op;                    /* Opcode of pRight */\n\n  if( !sqlite3IsLikeFunction(db, pExpr, pnoCase, wc) ){\n    return 0;\n  }\n#ifdef SQLITE_EBCDIC\n  if( *pnoCase ) return 0;\n#endif\n  pList = pExpr->x.pList;\n  pLeft = pList->a[1].pExpr;\n  if( pLeft->op!=TK_COLUMN || sqlite3ExprAffinity(pLeft)!=SQLITE_AFF_TEXT ){\n    /* IMP: R-02065-49465 The left-hand side of the LIKE or GLOB operator must\n    ** be the name of an indexed column with TEXT affinity. */\n    return 0;\n  }\n  assert( pLeft->iColumn!=(-1) ); /* Because IPK never has AFF_TEXT */\n\n  pRight = pList->a[0].pExpr;\n  op = pRight->op;\n  if( op==TK_REGISTER ){\n    op = pRight->op2;\n  }\n  if( op==TK_VARIABLE ){\n    Vdbe *pReprepare = pParse->pReprepare;\n    int iCol = pRight->iColumn;\n    pVal = sqlite3VdbeGetValue(pReprepare, iCol, SQLITE_AFF_NONE);\n    if( pVal && sqlite3_value_type(pVal)==SQLITE_TEXT ){\n      z = (char *)sqlite3_value_text(pVal);\n    }\n    sqlite3VdbeSetVarmask(pParse->pVdbe, iCol); /* IMP: R-23257-02778 */\n    assert( pRight->op==TK_VARIABLE || pRight->op==TK_REGISTER );\n  }else if( op==TK_STRING ){\n    z = pRight->u.zToken;\n  }\n  if( z ){\n    cnt = 0;\n    while( (c=z[cnt])!=0 && c!=wc[0] && c!=wc[1] && c!=wc[2] ){\n      cnt++;\n    }\n    if( cnt!=0 && 255!=(u8)z[cnt-1] ){\n      Expr *pPrefix;\n      *pisComplete = c==wc[0] && z[cnt+1]==0;\n      pPrefix = sqlite3Expr(db, TK_STRING, z);\n      if( pPrefix ) pPrefix->u.zToken[cnt] = 0;\n      *ppPrefix = pPrefix;\n      if( op==TK_VARIABLE ){\n        Vdbe *v = pParse->pVdbe;\n        sqlite3VdbeSetVarmask(v, pRight->iColumn); /* IMP: R-23257-02778 */\n        if( *pisComplete && pRight->u.zToken[1] ){\n          /* If the rhs of the LIKE expression is a variable, and the current\n          ** value of the variable means there is no need to invoke the LIKE\n          ** function, then no OP_Variable will be added to the program.\n          ** This causes problems for the sqlite3_bind_parameter_name()\n          ** API. To workaround them, add a dummy OP_Variable here.\n          */ \n          int r1 = sqlite3GetTempReg(pParse);\n          sqlite3ExprCodeTarget(pParse, pRight, r1);\n          sqlite3VdbeChangeP3(v, sqlite3VdbeCurrentAddr(v)-1, 0);\n          sqlite3ReleaseTempReg(pParse, r1);\n        }\n      }\n    }else{\n      z = 0;\n    }\n  }\n\n  sqlite3ValueFree(pVal);\n  return (z!=0);\n}\n#endif /* SQLITE_OMIT_LIKE_OPTIMIZATION */\n\n\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n/*\n** Check to see if the given expression is of the form\n**\n**         column MATCH expr\n**\n** If it is then return TRUE.  If not, return FALSE.\n*/\nstatic int isMatchOfColumn(\n  Expr *pExpr      /* Test this expression */\n){\n  ExprList *pList;\n\n  if( pExpr->op!=TK_FUNCTION ){\n    return 0;\n  }\n  if( sqlite3StrICmp(pExpr->u.zToken,\"match\")!=0 ){\n    return 0;\n  }\n  pList = pExpr->x.pList;\n  if( pList->nExpr!=2 ){\n    return 0;\n  }\n  if( pList->a[1].pExpr->op != TK_COLUMN ){\n    return 0;\n  }\n  return 1;\n}\n#endif /* SQLITE_OMIT_VIRTUALTABLE */\n\n/*\n** If the pBase expression originated in the ON or USING clause of\n** a join, then transfer the appropriate markings over to derived.\n*/\nstatic void transferJoinMarkings(Expr *pDerived, Expr *pBase){\n  pDerived->flags |= pBase->flags & EP_FromJoin;\n  pDerived->iRightJoinTable = pBase->iRightJoinTable;\n}\n\n#if !defined(SQLITE_OMIT_OR_OPTIMIZATION) && !defined(SQLITE_OMIT_SUBQUERY)\n/*\n** Analyze a term that consists of two or more OR-connected\n** subterms.  So in:\n**\n**     ... WHERE  (a=5) AND (b=7 OR c=9 OR d=13) AND (d=13)\n**                          ^^^^^^^^^^^^^^^^^^^^\n**\n** This routine analyzes terms such as the middle term in the above example.\n** A WhereOrTerm object is computed and attached to the term under\n** analysis, regardless of the outcome of the analysis.  Hence:\n**\n**     WhereTerm.wtFlags   |=  TERM_ORINFO\n**     WhereTerm.u.pOrInfo  =  a dynamically allocated WhereOrTerm object\n**\n** The term being analyzed must have two or more of OR-connected subterms.\n** A single subterm might be a set of AND-connected sub-subterms.\n** Examples of terms under analysis:\n**\n**     (A)     t1.x=t2.y OR t1.x=t2.z OR t1.y=15 OR t1.z=t3.a+5\n**     (B)     x=expr1 OR expr2=x OR x=expr3\n**     (C)     t1.x=t2.y OR (t1.x=t2.z AND t1.y=15)\n**     (D)     x=expr1 OR (y>11 AND y<22 AND z LIKE '*hello*')\n**     (E)     (p.a=1 AND q.b=2 AND r.c=3) OR (p.x=4 AND q.y=5 AND r.z=6)\n**\n** CASE 1:\n**\n** If all subterms are of the form T.C=expr for some single column of C\n** a single table T (as shown in example B above) then create a new virtual\n** term that is an equivalent IN expression.  In other words, if the term\n** being analyzed is:\n**\n**      x = expr1  OR  expr2 = x  OR  x = expr3\n**\n** then create a new virtual term like this:\n**\n**      x IN (expr1,expr2,expr3)\n**\n** CASE 2:\n**\n** If all subterms are indexable by a single table T, then set\n**\n**     WhereTerm.eOperator              =  WO_OR\n**     WhereTerm.u.pOrInfo->indexable  |=  the cursor number for table T\n**\n** A subterm is \"indexable\" if it is of the form\n** \"T.C <op> <expr>\" where C is any column of table T and \n** <op> is one of \"=\", \"<\", \"<=\", \">\", \">=\", \"IS NULL\", or \"IN\".\n** A subterm is also indexable if it is an AND of two or more\n** subsubterms at least one of which is indexable.  Indexable AND \n** subterms have their eOperator set to WO_AND and they have\n** u.pAndInfo set to a dynamically allocated WhereAndTerm object.\n**\n** From another point of view, \"indexable\" means that the subterm could\n** potentially be used with an index if an appropriate index exists.\n** This analysis does not consider whether or not the index exists; that\n** is something the bestIndex() routine will determine.  This analysis\n** only looks at whether subterms appropriate for indexing exist.\n**\n** All examples A through E above all satisfy case 2.  But if a term\n** also statisfies case 1 (such as B) we know that the optimizer will\n** always prefer case 1, so in that case we pretend that case 2 is not\n** satisfied.\n**\n** It might be the case that multiple tables are indexable.  For example,\n** (E) above is indexable on tables P, Q, and R.\n**\n** Terms that satisfy case 2 are candidates for lookup by using\n** separate indices to find rowids for each subterm and composing\n** the union of all rowids using a RowSet object.  This is similar\n** to \"bitmap indices\" in other database engines.\n**\n** OTHERWISE:\n**\n** If neither case 1 nor case 2 apply, then leave the eOperator set to\n** zero.  This term is not useful for search.\n*/\nstatic void exprAnalyzeOrTerm(\n  SrcList *pSrc,            /* the FROM clause */\n  WhereClause *pWC,         /* the complete WHERE clause */\n  int idxTerm               /* Index of the OR-term to be analyzed */\n){\n  Parse *pParse = pWC->pParse;            /* Parser context */\n  sqlite3 *db = pParse->db;               /* Database connection */\n  WhereTerm *pTerm = &pWC->a[idxTerm];    /* The term to be analyzed */\n  Expr *pExpr = pTerm->pExpr;             /* The expression of the term */\n  WhereMaskSet *pMaskSet = pWC->pMaskSet; /* Table use masks */\n  int i;                                  /* Loop counters */\n  WhereClause *pOrWc;       /* Breakup of pTerm into subterms */\n  WhereTerm *pOrTerm;       /* A Sub-term within the pOrWc */\n  WhereOrInfo *pOrInfo;     /* Additional information associated with pTerm */\n  Bitmask chngToIN;         /* Tables that might satisfy case 1 */\n  Bitmask indexable;        /* Tables that are indexable, satisfying case 2 */\n\n  /*\n  ** Break the OR clause into its separate subterms.  The subterms are\n  ** stored in a WhereClause structure containing within the WhereOrInfo\n  ** object that is attached to the original OR clause term.\n  */\n  assert( (pTerm->wtFlags & (TERM_DYNAMIC|TERM_ORINFO|TERM_ANDINFO))==0 );\n  assert( pExpr->op==TK_OR );\n  pTerm->u.pOrInfo = pOrInfo = sqlite3DbMallocZero(db, sizeof(*pOrInfo));\n  if( pOrInfo==0 ) return;\n  pTerm->wtFlags |= TERM_ORINFO;\n  pOrWc = &pOrInfo->wc;\n  whereClauseInit(pOrWc, pWC->pParse, pMaskSet);\n  whereSplit(pOrWc, pExpr, TK_OR);\n  exprAnalyzeAll(pSrc, pOrWc);\n  if( db->mallocFailed ) return;\n  assert( pOrWc->nTerm>=2 );\n\n  /*\n  ** Compute the set of tables that might satisfy cases 1 or 2.\n  */\n  indexable = ~(Bitmask)0;\n  chngToIN = ~(pWC->vmask);\n  for(i=pOrWc->nTerm-1, pOrTerm=pOrWc->a; i>=0 && indexable; i--, pOrTerm++){\n    if( (pOrTerm->eOperator & WO_SINGLE)==0 ){\n      WhereAndInfo *pAndInfo;\n      assert( pOrTerm->eOperator==0 );\n      assert( (pOrTerm->wtFlags & (TERM_ANDINFO|TERM_ORINFO))==0 );\n      chngToIN = 0;\n      pAndInfo = sqlite3DbMallocRaw(db, sizeof(*pAndInfo));\n      if( pAndInfo ){\n        WhereClause *pAndWC;\n        WhereTerm *pAndTerm;\n        int j;\n        Bitmask b = 0;\n        pOrTerm->u.pAndInfo = pAndInfo;\n        pOrTerm->wtFlags |= TERM_ANDINFO;\n        pOrTerm->eOperator = WO_AND;\n        pAndWC = &pAndInfo->wc;\n        whereClauseInit(pAndWC, pWC->pParse, pMaskSet);\n        whereSplit(pAndWC, pOrTerm->pExpr, TK_AND);\n        exprAnalyzeAll(pSrc, pAndWC);\n        testcase( db->mallocFailed );\n        if( !db->mallocFailed ){\n          for(j=0, pAndTerm=pAndWC->a; j<pAndWC->nTerm; j++, pAndTerm++){\n            assert( pAndTerm->pExpr );\n            if( allowedOp(pAndTerm->pExpr->op) ){\n              b |= getMask(pMaskSet, pAndTerm->leftCursor);\n            }\n          }\n        }\n        indexable &= b;\n      }\n    }else if( pOrTerm->wtFlags & TERM_COPIED ){\n      /* Skip this term for now.  We revisit it when we process the\n      ** corresponding TERM_VIRTUAL term */\n    }else{\n      Bitmask b;\n      b = getMask(pMaskSet, pOrTerm->leftCursor);\n      if( pOrTerm->wtFlags & TERM_VIRTUAL ){\n        WhereTerm *pOther = &pOrWc->a[pOrTerm->iParent];\n        b |= getMask(pMaskSet, pOther->leftCursor);\n      }\n      indexable &= b;\n      if( pOrTerm->eOperator!=WO_EQ ){\n        chngToIN = 0;\n      }else{\n        chngToIN &= b;\n      }\n    }\n  }\n\n  /*\n  ** Record the set of tables that satisfy case 2.  The set might be\n  ** empty.\n  */\n  pOrInfo->indexable = indexable;\n  pTerm->eOperator = indexable==0 ? 0 : WO_OR;\n\n  /*\n  ** chngToIN holds a set of tables that *might* satisfy case 1.  But\n  ** we have to do some additional checking to see if case 1 really\n  ** is satisfied.\n  **\n  ** chngToIN will hold either 0, 1, or 2 bits.  The 0-bit case means\n  ** that there is no possibility of transforming the OR clause into an\n  ** IN operator because one or more terms in the OR clause contain\n  ** something other than == on a column in the single table.  The 1-bit\n  ** case means that every term of the OR clause is of the form\n  ** \"table.column=expr\" for some single table.  The one bit that is set\n  ** will correspond to the common table.  We still need to check to make\n  ** sure the same column is used on all terms.  The 2-bit case is when\n  ** the all terms are of the form \"table1.column=table2.column\".  It\n  ** might be possible to form an IN operator with either table1.column\n  ** or table2.column as the LHS if either is common to every term of\n  ** the OR clause.\n  **\n  ** Note that terms of the form \"table.column1=table.column2\" (the\n  ** same table on both sizes of the ==) cannot be optimized.\n  */\n  if( chngToIN ){\n    int okToChngToIN = 0;     /* True if the conversion to IN is valid */\n    int iColumn = -1;         /* Column index on lhs of IN operator */\n    int iCursor = -1;         /* Table cursor common to all terms */\n    int j = 0;                /* Loop counter */\n\n    /* Search for a table and column that appears on one side or the\n    ** other of the == operator in every subterm.  That table and column\n    ** will be recorded in iCursor and iColumn.  There might not be any\n    ** such table and column.  Set okToChngToIN if an appropriate table\n    ** and column is found but leave okToChngToIN false if not found.\n    */\n    for(j=0; j<2 && !okToChngToIN; j++){\n      pOrTerm = pOrWc->a;\n      for(i=pOrWc->nTerm-1; i>=0; i--, pOrTerm++){\n        assert( pOrTerm->eOperator==WO_EQ );\n        pOrTerm->wtFlags &= ~TERM_OR_OK;\n        if( pOrTerm->leftCursor==iCursor ){\n          /* This is the 2-bit case and we are on the second iteration and\n          ** current term is from the first iteration.  So skip this term. */\n          assert( j==1 );\n          continue;\n        }\n        if( (chngToIN & getMask(pMaskSet, pOrTerm->leftCursor))==0 ){\n          /* This term must be of the form t1.a==t2.b where t2 is in the\n          ** chngToIN set but t1 is not.  This term will be either preceeded\n          ** or follwed by an inverted copy (t2.b==t1.a).  Skip this term \n          ** and use its inversion. */\n          testcase( pOrTerm->wtFlags & TERM_COPIED );\n          testcase( pOrTerm->wtFlags & TERM_VIRTUAL );\n          assert( pOrTerm->wtFlags & (TERM_COPIED|TERM_VIRTUAL) );\n          continue;\n        }\n        iColumn = pOrTerm->u.leftColumn;\n        iCursor = pOrTerm->leftCursor;\n        break;\n      }\n      if( i<0 ){\n        /* No candidate table+column was found.  This can only occur\n        ** on the second iteration */\n        assert( j==1 );\n        assert( (chngToIN&(chngToIN-1))==0 );\n        assert( chngToIN==getMask(pMaskSet, iCursor) );\n        break;\n      }\n      testcase( j==1 );\n\n      /* We have found a candidate table and column.  Check to see if that\n      ** table and column is common to every term in the OR clause */\n      okToChngToIN = 1;\n      for(; i>=0 && okToChngToIN; i--, pOrTerm++){\n        assert( pOrTerm->eOperator==WO_EQ );\n        if( pOrTerm->leftCursor!=iCursor ){\n          pOrTerm->wtFlags &= ~TERM_OR_OK;\n        }else if( pOrTerm->u.leftColumn!=iColumn ){\n          okToChngToIN = 0;\n        }else{\n          int affLeft, affRight;\n          /* If the right-hand side is also a column, then the affinities\n          ** of both right and left sides must be such that no type\n          ** conversions are required on the right.  (Ticket #2249)\n          */\n          affRight = sqlite3ExprAffinity(pOrTerm->pExpr->pRight);\n          affLeft = sqlite3ExprAffinity(pOrTerm->pExpr->pLeft);\n          if( affRight!=0 && affRight!=affLeft ){\n            okToChngToIN = 0;\n          }else{\n            pOrTerm->wtFlags |= TERM_OR_OK;\n          }\n        }\n      }\n    }\n\n    /* At this point, okToChngToIN is true if original pTerm satisfies\n    ** case 1.  In that case, construct a new virtual term that is \n    ** pTerm converted into an IN operator.\n    **\n    ** EV: R-00211-15100\n    */\n    if( okToChngToIN ){\n      Expr *pDup;            /* A transient duplicate expression */\n      ExprList *pList = 0;   /* The RHS of the IN operator */\n      Expr *pLeft = 0;       /* The LHS of the IN operator */\n      Expr *pNew;            /* The complete IN operator */\n\n      for(i=pOrWc->nTerm-1, pOrTerm=pOrWc->a; i>=0; i--, pOrTerm++){\n        if( (pOrTerm->wtFlags & TERM_OR_OK)==0 ) continue;\n        assert( pOrTerm->eOperator==WO_EQ );\n        assert( pOrTerm->leftCursor==iCursor );\n        assert( pOrTerm->u.leftColumn==iColumn );\n        pDup = sqlite3ExprDup(db, pOrTerm->pExpr->pRight, 0);\n        pList = sqlite3ExprListAppend(pWC->pParse, pList, pDup);\n        pLeft = pOrTerm->pExpr->pLeft;\n      }\n      assert( pLeft!=0 );\n      pDup = sqlite3ExprDup(db, pLeft, 0);\n      pNew = sqlite3PExpr(pParse, TK_IN, pDup, 0, 0);\n      if( pNew ){\n        int idxNew;\n        transferJoinMarkings(pNew, pExpr);\n        assert( !ExprHasProperty(pNew, EP_xIsSelect) );\n        pNew->x.pList = pList;\n        idxNew = whereClauseInsert(pWC, pNew, TERM_VIRTUAL|TERM_DYNAMIC);\n        testcase( idxNew==0 );\n        exprAnalyze(pSrc, pWC, idxNew);\n        pTerm = &pWC->a[idxTerm];\n        pWC->a[idxNew].iParent = idxTerm;\n        pTerm->nChild = 1;\n      }else{\n        sqlite3ExprListDelete(db, pList);\n      }\n      pTerm->eOperator = WO_NOOP;  /* case 1 trumps case 2 */\n    }\n  }\n}\n#endif /* !SQLITE_OMIT_OR_OPTIMIZATION && !SQLITE_OMIT_SUBQUERY */\n\n\n/*\n** The input to this routine is an WhereTerm structure with only the\n** \"pExpr\" field filled in.  The job of this routine is to analyze the\n** subexpression and populate all the other fields of the WhereTerm\n** structure.\n**\n** If the expression is of the form \"<expr> <op> X\" it gets commuted\n** to the standard form of \"X <op> <expr>\".\n**\n** If the expression is of the form \"X <op> Y\" where both X and Y are\n** columns, then the original expression is unchanged and a new virtual\n** term of the form \"Y <op> X\" is added to the WHERE clause and\n** analyzed separately.  The original term is marked with TERM_COPIED\n** and the new term is marked with TERM_DYNAMIC (because it's pExpr\n** needs to be freed with the WhereClause) and TERM_VIRTUAL (because it\n** is a commuted copy of a prior term.)  The original term has nChild=1\n** and the copy has idxParent set to the index of the original term.\n*/\nstatic void exprAnalyze(\n  SrcList *pSrc,            /* the FROM clause */\n  WhereClause *pWC,         /* the WHERE clause */\n  int idxTerm               /* Index of the term to be analyzed */\n){\n  WhereTerm *pTerm;                /* The term to be analyzed */\n  WhereMaskSet *pMaskSet;          /* Set of table index masks */\n  Expr *pExpr;                     /* The expression to be analyzed */\n  Bitmask prereqLeft;              /* Prerequesites of the pExpr->pLeft */\n  Bitmask prereqAll;               /* Prerequesites of pExpr */\n  Bitmask extraRight = 0;          /* Extra dependencies on LEFT JOIN */\n  Expr *pStr1 = 0;                 /* RHS of LIKE/GLOB operator */\n  int isComplete = 0;              /* RHS of LIKE/GLOB ends with wildcard */\n  int noCase = 0;                  /* LIKE/GLOB distinguishes case */\n  int op;                          /* Top-level operator.  pExpr->op */\n  Parse *pParse = pWC->pParse;     /* Parsing context */\n  sqlite3 *db = pParse->db;        /* Database connection */\n\n  if( db->mallocFailed ){\n    return;\n  }\n  pTerm = &pWC->a[idxTerm];\n  pMaskSet = pWC->pMaskSet;\n  pExpr = pTerm->pExpr;\n  prereqLeft = exprTableUsage(pMaskSet, pExpr->pLeft);\n  op = pExpr->op;\n  if( op==TK_IN ){\n    assert( pExpr->pRight==0 );\n    if( ExprHasProperty(pExpr, EP_xIsSelect) ){\n      pTerm->prereqRight = exprSelectTableUsage(pMaskSet, pExpr->x.pSelect);\n    }else{\n      pTerm->prereqRight = exprListTableUsage(pMaskSet, pExpr->x.pList);\n    }\n  }else if( op==TK_ISNULL ){\n    pTerm->prereqRight = 0;\n  }else{\n    pTerm->prereqRight = exprTableUsage(pMaskSet, pExpr->pRight);\n  }\n  prereqAll = exprTableUsage(pMaskSet, pExpr);\n  if( ExprHasProperty(pExpr, EP_FromJoin) ){\n    Bitmask x = getMask(pMaskSet, pExpr->iRightJoinTable);\n    prereqAll |= x;\n    extraRight = x-1;  /* ON clause terms may not be used with an index\n                       ** on left table of a LEFT JOIN.  Ticket #3015 */\n  }\n  pTerm->prereqAll = prereqAll;\n  pTerm->leftCursor = -1;\n  pTerm->iParent = -1;\n  pTerm->eOperator = 0;\n  if( allowedOp(op) && (pTerm->prereqRight & prereqLeft)==0 ){\n    Expr *pLeft = pExpr->pLeft;\n    Expr *pRight = pExpr->pRight;\n    if( pLeft->op==TK_COLUMN ){\n      pTerm->leftCursor = pLeft->iTable;\n      pTerm->u.leftColumn = pLeft->iColumn;\n      pTerm->eOperator = operatorMask(op);\n    }\n    if( pRight && pRight->op==TK_COLUMN ){\n      WhereTerm *pNew;\n      Expr *pDup;\n      if( pTerm->leftCursor>=0 ){\n        int idxNew;\n        pDup = sqlite3ExprDup(db, pExpr, 0);\n        if( db->mallocFailed ){\n          sqlite3ExprDelete(db, pDup);\n          return;\n        }\n        idxNew = whereClauseInsert(pWC, pDup, TERM_VIRTUAL|TERM_DYNAMIC);\n        if( idxNew==0 ) return;\n        pNew = &pWC->a[idxNew];\n        pNew->iParent = idxTerm;\n        pTerm = &pWC->a[idxTerm];\n        pTerm->nChild = 1;\n        pTerm->wtFlags |= TERM_COPIED;\n      }else{\n        pDup = pExpr;\n        pNew = pTerm;\n      }\n      exprCommute(pParse, pDup);\n      pLeft = pDup->pLeft;\n      pNew->leftCursor = pLeft->iTable;\n      pNew->u.leftColumn = pLeft->iColumn;\n      testcase( (prereqLeft | extraRight) != prereqLeft );\n      pNew->prereqRight = prereqLeft | extraRight;\n      pNew->prereqAll = prereqAll;\n      pNew->eOperator = operatorMask(pDup->op);\n    }\n  }\n\n#ifndef SQLITE_OMIT_BETWEEN_OPTIMIZATION\n  /* If a term is the BETWEEN operator, create two new virtual terms\n  ** that define the range that the BETWEEN implements.  For example:\n  **\n  **      a BETWEEN b AND c\n  **\n  ** is converted into:\n  **\n  **      (a BETWEEN b AND c) AND (a>=b) AND (a<=c)\n  **\n  ** The two new terms are added onto the end of the WhereClause object.\n  ** The new terms are \"dynamic\" and are children of the original BETWEEN\n  ** term.  That means that if the BETWEEN term is coded, the children are\n  ** skipped.  Or, if the children are satisfied by an index, the original\n  ** BETWEEN term is skipped.\n  */\n  else if( pExpr->op==TK_BETWEEN && pWC->op==TK_AND ){\n    ExprList *pList = pExpr->x.pList;\n    int i;\n    static const u8 ops[] = {TK_GE, TK_LE};\n    assert( pList!=0 );\n    assert( pList->nExpr==2 );\n    for(i=0; i<2; i++){\n      Expr *pNewExpr;\n      int idxNew;\n      pNewExpr = sqlite3PExpr(pParse, ops[i], \n                             sqlite3ExprDup(db, pExpr->pLeft, 0),\n                             sqlite3ExprDup(db, pList->a[i].pExpr, 0), 0);\n      idxNew = whereClauseInsert(pWC, pNewExpr, TERM_VIRTUAL|TERM_DYNAMIC);\n      testcase( idxNew==0 );\n      exprAnalyze(pSrc, pWC, idxNew);\n      pTerm = &pWC->a[idxTerm];\n      pWC->a[idxNew].iParent = idxTerm;\n    }\n    pTerm->nChild = 2;\n  }\n#endif /* SQLITE_OMIT_BETWEEN_OPTIMIZATION */\n\n#if !defined(SQLITE_OMIT_OR_OPTIMIZATION) && !defined(SQLITE_OMIT_SUBQUERY)\n  /* Analyze a term that is composed of two or more subterms connected by\n  ** an OR operator.\n  */\n  else if( pExpr->op==TK_OR ){\n    assert( pWC->op==TK_AND );\n    exprAnalyzeOrTerm(pSrc, pWC, idxTerm);\n    pTerm = &pWC->a[idxTerm];\n  }\n#endif /* SQLITE_OMIT_OR_OPTIMIZATION */\n\n#ifndef SQLITE_OMIT_LIKE_OPTIMIZATION\n  /* Add constraints to reduce the search space on a LIKE or GLOB\n  ** operator.\n  **\n  ** A like pattern of the form \"x LIKE 'abc%'\" is changed into constraints\n  **\n  **          x>='abc' AND x<'abd' AND x LIKE 'abc%'\n  **\n  ** The last character of the prefix \"abc\" is incremented to form the\n  ** termination condition \"abd\".\n  */\n  if( pWC->op==TK_AND \n   && isLikeOrGlob(pParse, pExpr, &pStr1, &isComplete, &noCase)\n  ){\n    Expr *pLeft;       /* LHS of LIKE/GLOB operator */\n    Expr *pStr2;       /* Copy of pStr1 - RHS of LIKE/GLOB operator */\n    Expr *pNewExpr1;\n    Expr *pNewExpr2;\n    int idxNew1;\n    int idxNew2;\n    CollSeq *pColl;    /* Collating sequence to use */\n\n    pLeft = pExpr->x.pList->a[1].pExpr;\n    pStr2 = sqlite3ExprDup(db, pStr1, 0);\n    if( !db->mallocFailed ){\n      u8 c, *pC;       /* Last character before the first wildcard */\n      pC = (u8*)&pStr2->u.zToken[sqlite3Strlen30(pStr2->u.zToken)-1];\n      c = *pC;\n      if( noCase ){\n        /* The point is to increment the last character before the first\n        ** wildcard.  But if we increment '@', that will push it into the\n        ** alphabetic range where case conversions will mess up the \n        ** inequality.  To avoid this, make sure to also run the full\n        ** LIKE on all candidate expressions by clearing the isComplete flag\n        */\n        if( c=='A'-1 ) isComplete = 0;   /* EV: R-64339-08207 */\n\n\n        c = sqlite3UpperToLower[c];\n      }\n      *pC = c + 1;\n    }\n    pColl = sqlite3FindCollSeq(db, SQLITE_UTF8, noCase ? \"NOCASE\" : \"BINARY\",0);\n    pNewExpr1 = sqlite3PExpr(pParse, TK_GE, \n                     sqlite3ExprSetColl(sqlite3ExprDup(db,pLeft,0), pColl),\n                     pStr1, 0);\n    idxNew1 = whereClauseInsert(pWC, pNewExpr1, TERM_VIRTUAL|TERM_DYNAMIC);\n    testcase( idxNew1==0 );\n    exprAnalyze(pSrc, pWC, idxNew1);\n    pNewExpr2 = sqlite3PExpr(pParse, TK_LT,\n                     sqlite3ExprSetColl(sqlite3ExprDup(db,pLeft,0), pColl),\n                     pStr2, 0);\n    idxNew2 = whereClauseInsert(pWC, pNewExpr2, TERM_VIRTUAL|TERM_DYNAMIC);\n    testcase( idxNew2==0 );\n    exprAnalyze(pSrc, pWC, idxNew2);\n    pTerm = &pWC->a[idxTerm];\n    if( isComplete ){\n      pWC->a[idxNew1].iParent = idxTerm;\n      pWC->a[idxNew2].iParent = idxTerm;\n      pTerm->nChild = 2;\n    }\n  }\n#endif /* SQLITE_OMIT_LIKE_OPTIMIZATION */\n\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  /* Add a WO_MATCH auxiliary term to the constraint set if the\n  ** current expression is of the form:  column MATCH expr.\n  ** This information is used by the xBestIndex methods of\n  ** virtual tables.  The native query optimizer does not attempt\n  ** to do anything with MATCH functions.\n  */\n  if( isMatchOfColumn(pExpr) ){\n    int idxNew;\n    Expr *pRight, *pLeft;\n    WhereTerm *pNewTerm;\n    Bitmask prereqColumn, prereqExpr;\n\n    pRight = pExpr->x.pList->a[0].pExpr;\n    pLeft = pExpr->x.pList->a[1].pExpr;\n    prereqExpr = exprTableUsage(pMaskSet, pRight);\n    prereqColumn = exprTableUsage(pMaskSet, pLeft);\n    if( (prereqExpr & prereqColumn)==0 ){\n      Expr *pNewExpr;\n      pNewExpr = sqlite3PExpr(pParse, TK_MATCH, \n                              0, sqlite3ExprDup(db, pRight, 0), 0);\n      idxNew = whereClauseInsert(pWC, pNewExpr, TERM_VIRTUAL|TERM_DYNAMIC);\n      testcase( idxNew==0 );\n      pNewTerm = &pWC->a[idxNew];\n      pNewTerm->prereqRight = prereqExpr;\n      pNewTerm->leftCursor = pLeft->iTable;\n      pNewTerm->u.leftColumn = pLeft->iColumn;\n      pNewTerm->eOperator = WO_MATCH;\n      pNewTerm->iParent = idxTerm;\n      pTerm = &pWC->a[idxTerm];\n      pTerm->nChild = 1;\n      pTerm->wtFlags |= TERM_COPIED;\n      pNewTerm->prereqAll = pTerm->prereqAll;\n    }\n  }\n#endif /* SQLITE_OMIT_VIRTUALTABLE */\n\n#ifdef SQLITE_ENABLE_STAT2\n  /* When sqlite_stat2 histogram data is available an operator of the\n  ** form \"x IS NOT NULL\" can sometimes be evaluated more efficiently\n  ** as \"x>NULL\" if x is not an INTEGER PRIMARY KEY.  So construct a\n  ** virtual term of that form.\n  **\n  ** Note that the virtual term must be tagged with TERM_VNULL.  This\n  ** TERM_VNULL tag will suppress the not-null check at the beginning\n  ** of the loop.  Without the TERM_VNULL flag, the not-null check at\n  ** the start of the loop will prevent any results from being returned.\n  */\n  if( pExpr->op==TK_NOTNULL && pExpr->pLeft->iColumn>=0 ){\n    Expr *pNewExpr;\n    Expr *pLeft = pExpr->pLeft;\n    int idxNew;\n    WhereTerm *pNewTerm;\n\n    pNewExpr = sqlite3PExpr(pParse, TK_GT,\n                            sqlite3ExprDup(db, pLeft, 0),\n                            sqlite3PExpr(pParse, TK_NULL, 0, 0, 0), 0);\n\n    idxNew = whereClauseInsert(pWC, pNewExpr,\n                              TERM_VIRTUAL|TERM_DYNAMIC|TERM_VNULL);\n    if( idxNew ){\n      pNewTerm = &pWC->a[idxNew];\n      pNewTerm->prereqRight = 0;\n      pNewTerm->leftCursor = pLeft->iTable;\n      pNewTerm->u.leftColumn = pLeft->iColumn;\n      pNewTerm->eOperator = WO_GT;\n      pNewTerm->iParent = idxTerm;\n      pTerm = &pWC->a[idxTerm];\n      pTerm->nChild = 1;\n      pTerm->wtFlags |= TERM_COPIED;\n      pNewTerm->prereqAll = pTerm->prereqAll;\n    }\n  }\n#endif /* SQLITE_ENABLE_STAT2 */\n\n  /* Prevent ON clause terms of a LEFT JOIN from being used to drive\n  ** an index for tables to the left of the join.\n  */\n  pTerm->prereqRight |= extraRight;\n}\n\n/*\n** Return TRUE if any of the expressions in pList->a[iFirst...] contain\n** a reference to any table other than the iBase table.\n*/\nstatic int referencesOtherTables(\n  ExprList *pList,          /* Search expressions in ths list */\n  WhereMaskSet *pMaskSet,   /* Mapping from tables to bitmaps */\n  int iFirst,               /* Be searching with the iFirst-th expression */\n  int iBase                 /* Ignore references to this table */\n){\n  Bitmask allowed = ~getMask(pMaskSet, iBase);\n  while( iFirst<pList->nExpr ){\n    if( (exprTableUsage(pMaskSet, pList->a[iFirst++].pExpr)&allowed)!=0 ){\n      return 1;\n    }\n  }\n  return 0;\n}\n\n\n/*\n** This routine decides if pIdx can be used to satisfy the ORDER BY\n** clause.  If it can, it returns 1.  If pIdx cannot satisfy the\n** ORDER BY clause, this routine returns 0.\n**\n** pOrderBy is an ORDER BY clause from a SELECT statement.  pTab is the\n** left-most table in the FROM clause of that same SELECT statement and\n** the table has a cursor number of \"base\".  pIdx is an index on pTab.\n**\n** nEqCol is the number of columns of pIdx that are used as equality\n** constraints.  Any of these columns may be missing from the ORDER BY\n** clause and the match can still be a success.\n**\n** All terms of the ORDER BY that match against the index must be either\n** ASC or DESC.  (Terms of the ORDER BY clause past the end of a UNIQUE\n** index do not need to satisfy this constraint.)  The *pbRev value is\n** set to 1 if the ORDER BY clause is all DESC and it is set to 0 if\n** the ORDER BY clause is all ASC.\n*/\nstatic int isSortingIndex(\n  Parse *pParse,          /* Parsing context */\n  WhereMaskSet *pMaskSet, /* Mapping from table cursor numbers to bitmaps */\n  Index *pIdx,            /* The index we are testing */\n  int base,               /* Cursor number for the table to be sorted */\n  ExprList *pOrderBy,     /* The ORDER BY clause */\n  int nEqCol,             /* Number of index columns with == constraints */\n  int wsFlags,            /* Index usages flags */\n  int *pbRev              /* Set to 1 if ORDER BY is DESC */\n){\n  int i, j;                       /* Loop counters */\n  int sortOrder = 0;              /* XOR of index and ORDER BY sort direction */\n  int nTerm;                      /* Number of ORDER BY terms */\n  struct ExprList_item *pTerm;    /* A term of the ORDER BY clause */\n  sqlite3 *db = pParse->db;\n\n  assert( pOrderBy!=0 );\n  nTerm = pOrderBy->nExpr;\n  assert( nTerm>0 );\n\n  /* Argument pIdx must either point to a 'real' named index structure, \n  ** or an index structure allocated on the stack by bestBtreeIndex() to\n  ** represent the rowid index that is part of every table.  */\n  assert( pIdx->zName || (pIdx->nColumn==1 && pIdx->aiColumn[0]==-1) );\n\n  /* Match terms of the ORDER BY clause against columns of\n  ** the index.\n  **\n  ** Note that indices have pIdx->nColumn regular columns plus\n  ** one additional column containing the rowid.  The rowid column\n  ** of the index is also allowed to match against the ORDER BY\n  ** clause.\n  */\n  for(i=j=0, pTerm=pOrderBy->a; j<nTerm && i<=pIdx->nColumn; i++){\n    Expr *pExpr;       /* The expression of the ORDER BY pTerm */\n    CollSeq *pColl;    /* The collating sequence of pExpr */\n    int termSortOrder; /* Sort order for this term */\n    int iColumn;       /* The i-th column of the index.  -1 for rowid */\n    int iSortOrder;    /* 1 for DESC, 0 for ASC on the i-th index term */\n    const char *zColl; /* Name of the collating sequence for i-th index term */\n\n    pExpr = pTerm->pExpr;\n    if( pExpr->op!=TK_COLUMN || pExpr->iTable!=base ){\n      /* Can not use an index sort on anything that is not a column in the\n      ** left-most table of the FROM clause */\n      break;\n    }\n    pColl = sqlite3ExprCollSeq(pParse, pExpr);\n    if( !pColl ){\n      pColl = db->pDfltColl;\n    }\n    if( pIdx->zName && i<pIdx->nColumn ){\n      iColumn = pIdx->aiColumn[i];\n      if( iColumn==pIdx->pTable->iPKey ){\n        iColumn = -1;\n      }\n      iSortOrder = pIdx->aSortOrder[i];\n      zColl = pIdx->azColl[i];\n    }else{\n      iColumn = -1;\n      iSortOrder = 0;\n      zColl = pColl->zName;\n    }\n    if( pExpr->iColumn!=iColumn || sqlite3StrICmp(pColl->zName, zColl) ){\n      /* Term j of the ORDER BY clause does not match column i of the index */\n      if( i<nEqCol ){\n        /* If an index column that is constrained by == fails to match an\n        ** ORDER BY term, that is OK.  Just ignore that column of the index\n        */\n        continue;\n      }else if( i==pIdx->nColumn ){\n        /* Index column i is the rowid.  All other terms match. */\n        break;\n      }else{\n        /* If an index column fails to match and is not constrained by ==\n        ** then the index cannot satisfy the ORDER BY constraint.\n        */\n        return 0;\n      }\n    }\n    assert( pIdx->aSortOrder!=0 || iColumn==-1 );\n    assert( pTerm->sortOrder==0 || pTerm->sortOrder==1 );\n    assert( iSortOrder==0 || iSortOrder==1 );\n    termSortOrder = iSortOrder ^ pTerm->sortOrder;\n    if( i>nEqCol ){\n      if( termSortOrder!=sortOrder ){\n        /* Indices can only be used if all ORDER BY terms past the\n        ** equality constraints are all either DESC or ASC. */\n        return 0;\n      }\n    }else{\n      sortOrder = termSortOrder;\n    }\n    j++;\n    pTerm++;\n    if( iColumn<0 && !referencesOtherTables(pOrderBy, pMaskSet, j, base) ){\n      /* If the indexed column is the primary key and everything matches\n      ** so far and none of the ORDER BY terms to the right reference other\n      ** tables in the join, then we are assured that the index can be used \n      ** to sort because the primary key is unique and so none of the other\n      ** columns will make any difference\n      */\n      j = nTerm;\n    }\n  }\n\n  *pbRev = sortOrder!=0;\n  if( j>=nTerm ){\n    /* All terms of the ORDER BY clause are covered by this index so\n    ** this index can be used for sorting. */\n    return 1;\n  }\n  if( pIdx->onError!=OE_None && i==pIdx->nColumn\n      && (wsFlags & WHERE_COLUMN_NULL)==0\n      && !referencesOtherTables(pOrderBy, pMaskSet, j, base) ){\n    /* All terms of this index match some prefix of the ORDER BY clause\n    ** and the index is UNIQUE and no terms on the tail of the ORDER BY\n    ** clause reference other tables in a join.  If this is all true then\n    ** the order by clause is superfluous.  Not that if the matching\n    ** condition is IS NULL then the result is not necessarily unique\n    ** even on a UNIQUE index, so disallow those cases. */\n    return 1;\n  }\n  return 0;\n}\n\n/*\n** Prepare a crude estimate of the logarithm of the input value.\n** The results need not be exact.  This is only used for estimating\n** the total cost of performing operations with O(logN) or O(NlogN)\n** complexity.  Because N is just a guess, it is no great tragedy if\n** logN is a little off.\n*/\nstatic double estLog(double N){\n  double logN = 1;\n  double x = 10;\n  while( N>x ){\n    logN += 1;\n    x *= 10;\n  }\n  return logN;\n}\n\n/*\n** Two routines for printing the content of an sqlite3_index_info\n** structure.  Used for testing and debugging only.  If neither\n** SQLITE_TEST or SQLITE_DEBUG are defined, then these routines\n** are no-ops.\n*/\n#if !defined(SQLITE_OMIT_VIRTUALTABLE) && defined(SQLITE_DEBUG)\nstatic void TRACE_IDX_INPUTS(sqlite3_index_info *p){\n  int i;\n  if( !sqlite3WhereTrace ) return;\n  for(i=0; i<p->nConstraint; i++){\n    sqlite3DebugPrintf(\"  constraint[%d]: col=%d termid=%d op=%d usabled=%d\\n\",\n       i,\n       p->aConstraint[i].iColumn,\n       p->aConstraint[i].iTermOffset,\n       p->aConstraint[i].op,\n       p->aConstraint[i].usable);\n  }\n  for(i=0; i<p->nOrderBy; i++){\n    sqlite3DebugPrintf(\"  orderby[%d]: col=%d desc=%d\\n\",\n       i,\n       p->aOrderBy[i].iColumn,\n       p->aOrderBy[i].desc);\n  }\n}\nstatic void TRACE_IDX_OUTPUTS(sqlite3_index_info *p){\n  int i;\n  if( !sqlite3WhereTrace ) return;\n  for(i=0; i<p->nConstraint; i++){\n    sqlite3DebugPrintf(\"  usage[%d]: argvIdx=%d omit=%d\\n\",\n       i,\n       p->aConstraintUsage[i].argvIndex,\n       p->aConstraintUsage[i].omit);\n  }\n  sqlite3DebugPrintf(\"  idxNum=%d\\n\", p->idxNum);\n  sqlite3DebugPrintf(\"  idxStr=%s\\n\", p->idxStr);\n  sqlite3DebugPrintf(\"  orderByConsumed=%d\\n\", p->orderByConsumed);\n  sqlite3DebugPrintf(\"  estimatedCost=%g\\n\", p->estimatedCost);\n}\n#else\n#define TRACE_IDX_INPUTS(A)\n#define TRACE_IDX_OUTPUTS(A)\n#endif\n\n/* \n** Required because bestIndex() is called by bestOrClauseIndex() \n*/\nstatic void bestIndex(\n    Parse*, WhereClause*, struct SrcList_item*,\n    Bitmask, Bitmask, ExprList*, WhereCost*);\n\n/*\n** This routine attempts to find an scanning strategy that can be used \n** to optimize an 'OR' expression that is part of a WHERE clause. \n**\n** The table associated with FROM clause term pSrc may be either a\n** regular B-Tree table or a virtual table.\n*/\nstatic void bestOrClauseIndex(\n  Parse *pParse,              /* The parsing context */\n  WhereClause *pWC,           /* The WHERE clause */\n  struct SrcList_item *pSrc,  /* The FROM clause term to search */\n  Bitmask notReady,           /* Mask of cursors not available for indexing */\n  Bitmask notValid,           /* Cursors not available for any purpose */\n  ExprList *pOrderBy,         /* The ORDER BY clause */\n  WhereCost *pCost            /* Lowest cost query plan */\n){\n#ifndef SQLITE_OMIT_OR_OPTIMIZATION\n  const int iCur = pSrc->iCursor;   /* The cursor of the table to be accessed */\n  const Bitmask maskSrc = getMask(pWC->pMaskSet, iCur);  /* Bitmask for pSrc */\n  WhereTerm * const pWCEnd = &pWC->a[pWC->nTerm];        /* End of pWC->a[] */\n  WhereTerm *pTerm;                 /* A single term of the WHERE clause */\n\n  /* No OR-clause optimization allowed if the INDEXED BY or NOT INDEXED clauses\n  ** are used */\n  if( pSrc->notIndexed || pSrc->pIndex!=0 ){\n    return;\n  }\n\n  /* Search the WHERE clause terms for a usable WO_OR term. */\n  for(pTerm=pWC->a; pTerm<pWCEnd; pTerm++){\n    if( pTerm->eOperator==WO_OR \n     && ((pTerm->prereqAll & ~maskSrc) & notReady)==0\n     && (pTerm->u.pOrInfo->indexable & maskSrc)!=0 \n    ){\n      WhereClause * const pOrWC = &pTerm->u.pOrInfo->wc;\n      WhereTerm * const pOrWCEnd = &pOrWC->a[pOrWC->nTerm];\n      WhereTerm *pOrTerm;\n      int flags = WHERE_MULTI_OR;\n      double rTotal = 0;\n      double nRow = 0;\n      Bitmask used = 0;\n\n      for(pOrTerm=pOrWC->a; pOrTerm<pOrWCEnd; pOrTerm++){\n        WhereCost sTermCost;\n        WHERETRACE((\"... Multi-index OR testing for term %d of %d....\\n\", \n          (pOrTerm - pOrWC->a), (pTerm - pWC->a)\n        ));\n        if( pOrTerm->eOperator==WO_AND ){\n          WhereClause *pAndWC = &pOrTerm->u.pAndInfo->wc;\n          bestIndex(pParse, pAndWC, pSrc, notReady, notValid, 0, &sTermCost);\n        }else if( pOrTerm->leftCursor==iCur ){\n          WhereClause tempWC;\n          tempWC.pParse = pWC->pParse;\n          tempWC.pMaskSet = pWC->pMaskSet;\n          tempWC.op = TK_AND;\n          tempWC.a = pOrTerm;\n          tempWC.nTerm = 1;\n          bestIndex(pParse, &tempWC, pSrc, notReady, notValid, 0, &sTermCost);\n        }else{\n          continue;\n        }\n        rTotal += sTermCost.rCost;\n        nRow += sTermCost.plan.nRow;\n        used |= sTermCost.used;\n        if( rTotal>=pCost->rCost ) break;\n      }\n\n      /* If there is an ORDER BY clause, increase the scan cost to account \n      ** for the cost of the sort. */\n      if( pOrderBy!=0 ){\n        WHERETRACE((\"... sorting increases OR cost %.9g to %.9g\\n\",\n                    rTotal, rTotal+nRow*estLog(nRow)));\n        rTotal += nRow*estLog(nRow);\n      }\n\n      /* If the cost of scanning using this OR term for optimization is\n      ** less than the current cost stored in pCost, replace the contents\n      ** of pCost. */\n      WHERETRACE((\"... multi-index OR cost=%.9g nrow=%.9g\\n\", rTotal, nRow));\n      if( rTotal<pCost->rCost ){\n        pCost->rCost = rTotal;\n        pCost->used = used;\n        pCost->plan.nRow = nRow;\n        pCost->plan.wsFlags = flags;\n        pCost->plan.u.pTerm = pTerm;\n      }\n    }\n  }\n#endif /* SQLITE_OMIT_OR_OPTIMIZATION */\n}\n\n#ifndef SQLITE_OMIT_AUTOMATIC_INDEX\n/*\n** Return TRUE if the WHERE clause term pTerm is of a form where it\n** could be used with an index to access pSrc, assuming an appropriate\n** index existed.\n*/\nstatic int termCanDriveIndex(\n  WhereTerm *pTerm,              /* WHERE clause term to check */\n  struct SrcList_item *pSrc,     /* Table we are trying to access */\n  Bitmask notReady               /* Tables in outer loops of the join */\n){\n  char aff;\n  if( pTerm->leftCursor!=pSrc->iCursor ) return 0;\n  if( pTerm->eOperator!=WO_EQ ) return 0;\n  if( (pTerm->prereqRight & notReady)!=0 ) return 0;\n  aff = pSrc->pTab->aCol[pTerm->u.leftColumn].affinity;\n  if( !sqlite3IndexAffinityOk(pTerm->pExpr, aff) ) return 0;\n  return 1;\n}\n#endif\n\n#ifndef SQLITE_OMIT_AUTOMATIC_INDEX\n/*\n** If the query plan for pSrc specified in pCost is a full table scan\n** and indexing is allows (if there is no NOT INDEXED clause) and it\n** possible to construct a transient index that would perform better\n** than a full table scan even when the cost of constructing the index\n** is taken into account, then alter the query plan to use the\n** transient index.\n*/\nstatic void bestAutomaticIndex(\n  Parse *pParse,              /* The parsing context */\n  WhereClause *pWC,           /* The WHERE clause */\n  struct SrcList_item *pSrc,  /* The FROM clause term to search */\n  Bitmask notReady,           /* Mask of cursors that are not available */\n  WhereCost *pCost            /* Lowest cost query plan */\n){\n  double nTableRow;           /* Rows in the input table */\n  double logN;                /* log(nTableRow) */\n  double costTempIdx;         /* per-query cost of the transient index */\n  WhereTerm *pTerm;           /* A single term of the WHERE clause */\n  WhereTerm *pWCEnd;          /* End of pWC->a[] */\n  Table *pTable;              /* Table tht might be indexed */\n\n  if( (pParse->db->flags & SQLITE_AutoIndex)==0 ){\n    /* Automatic indices are disabled at run-time */\n    return;\n  }\n  if( (pCost->plan.wsFlags & WHERE_NOT_FULLSCAN)!=0 ){\n    /* We already have some kind of index in use for this query. */\n    return;\n  }\n  if( pSrc->notIndexed ){\n    /* The NOT INDEXED clause appears in the SQL. */\n    return;\n  }\n\n  assert( pParse->nQueryLoop >= (double)1 );\n  pTable = pSrc->pTab;\n  nTableRow = pTable->nRowEst;\n  logN = estLog(nTableRow);\n  costTempIdx = 2*logN*(nTableRow/pParse->nQueryLoop + 1);\n  if( costTempIdx>=pCost->rCost ){\n    /* The cost of creating the transient table would be greater than\n    ** doing the full table scan */\n    return;\n  }\n\n  /* Search for any equality comparison term */\n  pWCEnd = &pWC->a[pWC->nTerm];\n  for(pTerm=pWC->a; pTerm<pWCEnd; pTerm++){\n    if( termCanDriveIndex(pTerm, pSrc, notReady) ){\n      WHERETRACE((\"auto-index reduces cost from %.1f to %.1f\\n\",\n                    pCost->rCost, costTempIdx));\n      pCost->rCost = costTempIdx;\n      pCost->plan.nRow = logN + 1;\n      pCost->plan.wsFlags = WHERE_TEMP_INDEX;\n      pCost->used = pTerm->prereqRight;\n      break;\n    }\n  }\n}\n#else\n# define bestAutomaticIndex(A,B,C,D,E)  /* no-op */\n#endif /* SQLITE_OMIT_AUTOMATIC_INDEX */\n\n\n#ifndef SQLITE_OMIT_AUTOMATIC_INDEX\n/*\n** Generate code to construct the Index object for an automatic index\n** and to set up the WhereLevel object pLevel so that the code generator\n** makes use of the automatic index.\n*/\nstatic void constructAutomaticIndex(\n  Parse *pParse,              /* The parsing context */\n  WhereClause *pWC,           /* The WHERE clause */\n  struct SrcList_item *pSrc,  /* The FROM clause term to get the next index */\n  Bitmask notReady,           /* Mask of cursors that are not available */\n  WhereLevel *pLevel          /* Write new index here */\n){\n  int nColumn;                /* Number of columns in the constructed index */\n  WhereTerm *pTerm;           /* A single term of the WHERE clause */\n  WhereTerm *pWCEnd;          /* End of pWC->a[] */\n  int nByte;                  /* Byte of memory needed for pIdx */\n  Index *pIdx;                /* Object describing the transient index */\n  Vdbe *v;                    /* Prepared statement under construction */\n  int regIsInit;              /* Register set by initialization */\n  int addrInit;               /* Address of the initialization bypass jump */\n  Table *pTable;              /* The table being indexed */\n  KeyInfo *pKeyinfo;          /* Key information for the index */   \n  int addrTop;                /* Top of the index fill loop */\n  int regRecord;              /* Register holding an index record */\n  int n;                      /* Column counter */\n  int i;                      /* Loop counter */\n  int mxBitCol;               /* Maximum column in pSrc->colUsed */\n  CollSeq *pColl;             /* Collating sequence to on a column */\n  Bitmask idxCols;            /* Bitmap of columns used for indexing */\n  Bitmask extraCols;          /* Bitmap of additional columns */\n\n  /* Generate code to skip over the creation and initialization of the\n  ** transient index on 2nd and subsequent iterations of the loop. */\n  v = pParse->pVdbe;\n  assert( v!=0 );\n  regIsInit = ++pParse->nMem;\n  addrInit = sqlite3VdbeAddOp1(v, OP_If, regIsInit);\n  sqlite3VdbeAddOp2(v, OP_Integer, 1, regIsInit);\n\n  /* Count the number of columns that will be added to the index\n  ** and used to match WHERE clause constraints */\n  nColumn = 0;\n  pTable = pSrc->pTab;\n  pWCEnd = &pWC->a[pWC->nTerm];\n  idxCols = 0;\n  for(pTerm=pWC->a; pTerm<pWCEnd; pTerm++){\n    if( termCanDriveIndex(pTerm, pSrc, notReady) ){\n      int iCol = pTerm->u.leftColumn;\n      Bitmask cMask = iCol>=BMS ? ((Bitmask)1)<<(BMS-1) : ((Bitmask)1)<<iCol;\n      testcase( iCol==BMS );\n      testcase( iCol==BMS-1 );\n      if( (idxCols & cMask)==0 ){\n        nColumn++;\n        idxCols |= cMask;\n      }\n    }\n  }\n  assert( nColumn>0 );\n  pLevel->plan.nEq = nColumn;\n\n  /* Count the number of additional columns needed to create a\n  ** covering index.  A \"covering index\" is an index that contains all\n  ** columns that are needed by the query.  With a covering index, the\n  ** original table never needs to be accessed.  Automatic indices must\n  ** be a covering index because the index will not be updated if the\n  ** original table changes and the index and table cannot both be used\n  ** if they go out of sync.\n  */\n  extraCols = pSrc->colUsed & (~idxCols | (((Bitmask)1)<<(BMS-1)));\n  mxBitCol = (pTable->nCol >= BMS-1) ? BMS-1 : pTable->nCol;\n  testcase( pTable->nCol==BMS-1 );\n  testcase( pTable->nCol==BMS-2 );\n  for(i=0; i<mxBitCol; i++){\n    if( extraCols & (((Bitmask)1)<<i) ) nColumn++;\n  }\n  if( pSrc->colUsed & (((Bitmask)1)<<(BMS-1)) ){\n    nColumn += pTable->nCol - BMS + 1;\n  }\n  pLevel->plan.wsFlags |= WHERE_COLUMN_EQ | WHERE_IDX_ONLY | WO_EQ;\n\n  /* Construct the Index object to describe this index */\n  nByte = sizeof(Index);\n  nByte += nColumn*sizeof(int);     /* Index.aiColumn */\n  nByte += nColumn*sizeof(char*);   /* Index.azColl */\n  nByte += nColumn;                 /* Index.aSortOrder */\n  pIdx = sqlite3DbMallocZero(pParse->db, nByte);\n  if( pIdx==0 ) return;\n  pLevel->plan.u.pIdx = pIdx;\n  pIdx->azColl = (char**)&pIdx[1];\n  pIdx->aiColumn = (int*)&pIdx->azColl[nColumn];\n  pIdx->aSortOrder = (u8*)&pIdx->aiColumn[nColumn];\n  pIdx->zName = \"auto-index\";\n  pIdx->nColumn = nColumn;\n  pIdx->pTable = pTable;\n  n = 0;\n  idxCols = 0;\n  for(pTerm=pWC->a; pTerm<pWCEnd; pTerm++){\n    if( termCanDriveIndex(pTerm, pSrc, notReady) ){\n      int iCol = pTerm->u.leftColumn;\n      Bitmask cMask = iCol>=BMS ? ((Bitmask)1)<<(BMS-1) : ((Bitmask)1)<<iCol;\n      if( (idxCols & cMask)==0 ){\n        Expr *pX = pTerm->pExpr;\n        idxCols |= cMask;\n        pIdx->aiColumn[n] = pTerm->u.leftColumn;\n        pColl = sqlite3BinaryCompareCollSeq(pParse, pX->pLeft, pX->pRight);\n        pIdx->azColl[n] = ALWAYS(pColl) ? pColl->zName : \"BINARY\";\n        n++;\n      }\n    }\n  }\n  assert( (u32)n==pLevel->plan.nEq );\n\n  /* Add additional columns needed to make the automatic index into\n  ** a covering index */\n  for(i=0; i<mxBitCol; i++){\n    if( extraCols & (((Bitmask)1)<<i) ){\n      pIdx->aiColumn[n] = i;\n      pIdx->azColl[n] = \"BINARY\";\n      n++;\n    }\n  }\n  if( pSrc->colUsed & (((Bitmask)1)<<(BMS-1)) ){\n    for(i=BMS-1; i<pTable->nCol; i++){\n      pIdx->aiColumn[n] = i;\n      pIdx->azColl[n] = \"BINARY\";\n      n++;\n    }\n  }\n  assert( n==nColumn );\n\n  /* Create the automatic index */\n  pKeyinfo = sqlite3IndexKeyinfo(pParse, pIdx);\n  assert( pLevel->iIdxCur>=0 );\n  sqlite3VdbeAddOp4(v, OP_OpenAutoindex, pLevel->iIdxCur, nColumn+1, 0,\n                    (char*)pKeyinfo, P4_KEYINFO_HANDOFF);\n  VdbeComment((v, \"for %s\", pTable->zName));\n\n  /* Fill the automatic index with content */\n  addrTop = sqlite3VdbeAddOp1(v, OP_Rewind, pLevel->iTabCur);\n  regRecord = sqlite3GetTempReg(pParse);\n  sqlite3GenerateIndexKey(pParse, pIdx, pLevel->iTabCur, regRecord, 1);\n  sqlite3VdbeAddOp2(v, OP_IdxInsert, pLevel->iIdxCur, regRecord);\n  sqlite3VdbeChangeP5(v, OPFLAG_USESEEKRESULT);\n  sqlite3VdbeAddOp2(v, OP_Next, pLevel->iTabCur, addrTop+1);\n  sqlite3VdbeChangeP5(v, SQLITE_STMTSTATUS_AUTOINDEX);\n  sqlite3VdbeJumpHere(v, addrTop);\n  sqlite3ReleaseTempReg(pParse, regRecord);\n  \n  /* Jump here when skipping the initialization */\n  sqlite3VdbeJumpHere(v, addrInit);\n}\n#endif /* SQLITE_OMIT_AUTOMATIC_INDEX */\n\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n/*\n** Allocate and populate an sqlite3_index_info structure. It is the \n** responsibility of the caller to eventually release the structure\n** by passing the pointer returned by this function to sqlite3_free().\n*/\nstatic sqlite3_index_info *allocateIndexInfo(\n  Parse *pParse, \n  WhereClause *pWC,\n  struct SrcList_item *pSrc,\n  ExprList *pOrderBy\n){\n  int i, j;\n  int nTerm;\n  struct sqlite3_index_constraint *pIdxCons;\n  struct sqlite3_index_orderby *pIdxOrderBy;\n  struct sqlite3_index_constraint_usage *pUsage;\n  WhereTerm *pTerm;\n  int nOrderBy;\n  sqlite3_index_info *pIdxInfo;\n\n  WHERETRACE((\"Recomputing index info for %s...\\n\", pSrc->pTab->zName));\n\n  /* Count the number of possible WHERE clause constraints referring\n  ** to this virtual table */\n  for(i=nTerm=0, pTerm=pWC->a; i<pWC->nTerm; i++, pTerm++){\n    if( pTerm->leftCursor != pSrc->iCursor ) continue;\n    assert( (pTerm->eOperator&(pTerm->eOperator-1))==0 );\n    testcase( pTerm->eOperator==WO_IN );\n    testcase( pTerm->eOperator==WO_ISNULL );\n    if( pTerm->eOperator & (WO_IN|WO_ISNULL) ) continue;\n    nTerm++;\n  }\n\n  /* If the ORDER BY clause contains only columns in the current \n  ** virtual table then allocate space for the aOrderBy part of\n  ** the sqlite3_index_info structure.\n  */\n  nOrderBy = 0;\n  if( pOrderBy ){\n    for(i=0; i<pOrderBy->nExpr; i++){\n      Expr *pExpr = pOrderBy->a[i].pExpr;\n      if( pExpr->op!=TK_COLUMN || pExpr->iTable!=pSrc->iCursor ) break;\n    }\n    if( i==pOrderBy->nExpr ){\n      nOrderBy = pOrderBy->nExpr;\n    }\n  }\n\n  /* Allocate the sqlite3_index_info structure\n  */\n  pIdxInfo = sqlite3DbMallocZero(pParse->db, sizeof(*pIdxInfo)\n                           + (sizeof(*pIdxCons) + sizeof(*pUsage))*nTerm\n                           + sizeof(*pIdxOrderBy)*nOrderBy );\n  if( pIdxInfo==0 ){\n    sqlite3ErrorMsg(pParse, \"out of memory\");\n    /* (double)0 In case of SQLITE_OMIT_FLOATING_POINT... */\n    return 0;\n  }\n\n  /* Initialize the structure.  The sqlite3_index_info structure contains\n  ** many fields that are declared \"const\" to prevent xBestIndex from\n  ** changing them.  We have to do some funky casting in order to\n  ** initialize those fields.\n  */\n  pIdxCons = (struct sqlite3_index_constraint*)&pIdxInfo[1];\n  pIdxOrderBy = (struct sqlite3_index_orderby*)&pIdxCons[nTerm];\n  pUsage = (struct sqlite3_index_constraint_usage*)&pIdxOrderBy[nOrderBy];\n  *(int*)&pIdxInfo->nConstraint = nTerm;\n  *(int*)&pIdxInfo->nOrderBy = nOrderBy;\n  *(struct sqlite3_index_constraint**)&pIdxInfo->aConstraint = pIdxCons;\n  *(struct sqlite3_index_orderby**)&pIdxInfo->aOrderBy = pIdxOrderBy;\n  *(struct sqlite3_index_constraint_usage**)&pIdxInfo->aConstraintUsage =\n                                                                   pUsage;\n\n  for(i=j=0, pTerm=pWC->a; i<pWC->nTerm; i++, pTerm++){\n    if( pTerm->leftCursor != pSrc->iCursor ) continue;\n    assert( (pTerm->eOperator&(pTerm->eOperator-1))==0 );\n    testcase( pTerm->eOperator==WO_IN );\n    testcase( pTerm->eOperator==WO_ISNULL );\n    if( pTerm->eOperator & (WO_IN|WO_ISNULL) ) continue;\n    pIdxCons[j].iColumn = pTerm->u.leftColumn;\n    pIdxCons[j].iTermOffset = i;\n    pIdxCons[j].op = (u8)pTerm->eOperator;\n    /* The direct assignment in the previous line is possible only because\n    ** the WO_ and SQLITE_INDEX_CONSTRAINT_ codes are identical.  The\n    ** following asserts verify this fact. */\n    assert( WO_EQ==SQLITE_INDEX_CONSTRAINT_EQ );\n    assert( WO_LT==SQLITE_INDEX_CONSTRAINT_LT );\n    assert( WO_LE==SQLITE_INDEX_CONSTRAINT_LE );\n    assert( WO_GT==SQLITE_INDEX_CONSTRAINT_GT );\n    assert( WO_GE==SQLITE_INDEX_CONSTRAINT_GE );\n    assert( WO_MATCH==SQLITE_INDEX_CONSTRAINT_MATCH );\n    assert( pTerm->eOperator & (WO_EQ|WO_LT|WO_LE|WO_GT|WO_GE|WO_MATCH) );\n    j++;\n  }\n  for(i=0; i<nOrderBy; i++){\n    Expr *pExpr = pOrderBy->a[i].pExpr;\n    pIdxOrderBy[i].iColumn = pExpr->iColumn;\n    pIdxOrderBy[i].desc = pOrderBy->a[i].sortOrder;\n  }\n\n  return pIdxInfo;\n}\n\n/*\n** The table object reference passed as the second argument to this function\n** must represent a virtual table. This function invokes the xBestIndex()\n** method of the virtual table with the sqlite3_index_info pointer passed\n** as the argument.\n**\n** If an error occurs, pParse is populated with an error message and a\n** non-zero value is returned. Otherwise, 0 is returned and the output\n** part of the sqlite3_index_info structure is left populated.\n**\n** Whether or not an error is returned, it is the responsibility of the\n** caller to eventually free p->idxStr if p->needToFreeIdxStr indicates\n** that this is required.\n*/\nstatic int vtabBestIndex(Parse *pParse, Table *pTab, sqlite3_index_info *p){\n  sqlite3_vtab *pVtab = sqlite3GetVTable(pParse->db, pTab)->pVtab;\n  int i;\n  int rc;\n\n  WHERETRACE((\"xBestIndex for %s\\n\", pTab->zName));\n  TRACE_IDX_INPUTS(p);\n  rc = pVtab->pModule->xBestIndex(pVtab, p);\n  TRACE_IDX_OUTPUTS(p);\n\n  if( rc!=SQLITE_OK ){\n    if( rc==SQLITE_NOMEM ){\n      pParse->db->mallocFailed = 1;\n    }else if( !pVtab->zErrMsg ){\n      sqlite3ErrorMsg(pParse, \"%s\", sqlite3ErrStr(rc));\n    }else{\n      sqlite3ErrorMsg(pParse, \"%s\", pVtab->zErrMsg);\n    }\n  }\n  sqlite3_free(pVtab->zErrMsg);\n  pVtab->zErrMsg = 0;\n\n  for(i=0; i<p->nConstraint; i++){\n    if( !p->aConstraint[i].usable && p->aConstraintUsage[i].argvIndex>0 ){\n      sqlite3ErrorMsg(pParse, \n          \"table %s: xBestIndex returned an invalid plan\", pTab->zName);\n    }\n  }\n\n  return pParse->nErr;\n}\n\n\n/*\n** Compute the best index for a virtual table.\n**\n** The best index is computed by the xBestIndex method of the virtual\n** table module.  This routine is really just a wrapper that sets up\n** the sqlite3_index_info structure that is used to communicate with\n** xBestIndex.\n**\n** In a join, this routine might be called multiple times for the\n** same virtual table.  The sqlite3_index_info structure is created\n** and initialized on the first invocation and reused on all subsequent\n** invocations.  The sqlite3_index_info structure is also used when\n** code is generated to access the virtual table.  The whereInfoDelete() \n** routine takes care of freeing the sqlite3_index_info structure after\n** everybody has finished with it.\n*/\nstatic void bestVirtualIndex(\n  Parse *pParse,                  /* The parsing context */\n  WhereClause *pWC,               /* The WHERE clause */\n  struct SrcList_item *pSrc,      /* The FROM clause term to search */\n  Bitmask notReady,               /* Mask of cursors not available for index */\n  Bitmask notValid,               /* Cursors not valid for any purpose */\n  ExprList *pOrderBy,             /* The order by clause */\n  WhereCost *pCost,               /* Lowest cost query plan */\n  sqlite3_index_info **ppIdxInfo  /* Index information passed to xBestIndex */\n){\n  Table *pTab = pSrc->pTab;\n  sqlite3_index_info *pIdxInfo;\n  struct sqlite3_index_constraint *pIdxCons;\n  struct sqlite3_index_constraint_usage *pUsage;\n  WhereTerm *pTerm;\n  int i, j;\n  int nOrderBy;\n  double rCost;\n\n  /* Make sure wsFlags is initialized to some sane value. Otherwise, if the \n  ** malloc in allocateIndexInfo() fails and this function returns leaving\n  ** wsFlags in an uninitialized state, the caller may behave unpredictably.\n  */\n  memset(pCost, 0, sizeof(*pCost));\n  pCost->plan.wsFlags = WHERE_VIRTUALTABLE;\n\n  /* If the sqlite3_index_info structure has not been previously\n  ** allocated and initialized, then allocate and initialize it now.\n  */\n  pIdxInfo = *ppIdxInfo;\n  if( pIdxInfo==0 ){\n    *ppIdxInfo = pIdxInfo = allocateIndexInfo(pParse, pWC, pSrc, pOrderBy);\n  }\n  if( pIdxInfo==0 ){\n    return;\n  }\n\n  /* At this point, the sqlite3_index_info structure that pIdxInfo points\n  ** to will have been initialized, either during the current invocation or\n  ** during some prior invocation.  Now we just have to customize the\n  ** details of pIdxInfo for the current invocation and pass it to\n  ** xBestIndex.\n  */\n\n  /* The module name must be defined. Also, by this point there must\n  ** be a pointer to an sqlite3_vtab structure. Otherwise\n  ** sqlite3ViewGetColumnNames() would have picked up the error. \n  */\n  assert( pTab->azModuleArg && pTab->azModuleArg[0] );\n  assert( sqlite3GetVTable(pParse->db, pTab) );\n\n  /* Set the aConstraint[].usable fields and initialize all \n  ** output variables to zero.\n  **\n  ** aConstraint[].usable is true for constraints where the right-hand\n  ** side contains only references to tables to the left of the current\n  ** table.  In other words, if the constraint is of the form:\n  **\n  **           column = expr\n  **\n  ** and we are evaluating a join, then the constraint on column is \n  ** only valid if all tables referenced in expr occur to the left\n  ** of the table containing column.\n  **\n  ** The aConstraints[] array contains entries for all constraints\n  ** on the current table.  That way we only have to compute it once\n  ** even though we might try to pick the best index multiple times.\n  ** For each attempt at picking an index, the order of tables in the\n  ** join might be different so we have to recompute the usable flag\n  ** each time.\n  */\n  pIdxCons = *(struct sqlite3_index_constraint**)&pIdxInfo->aConstraint;\n  pUsage = pIdxInfo->aConstraintUsage;\n  for(i=0; i<pIdxInfo->nConstraint; i++, pIdxCons++){\n    j = pIdxCons->iTermOffset;\n    pTerm = &pWC->a[j];\n    pIdxCons->usable = (pTerm->prereqRight&notReady) ? 0 : 1;\n  }\n  memset(pUsage, 0, sizeof(pUsage[0])*pIdxInfo->nConstraint);\n  if( pIdxInfo->needToFreeIdxStr ){\n    sqlite3_free(pIdxInfo->idxStr);\n  }\n  pIdxInfo->idxStr = 0;\n  pIdxInfo->idxNum = 0;\n  pIdxInfo->needToFreeIdxStr = 0;\n  pIdxInfo->orderByConsumed = 0;\n  /* ((double)2) In case of SQLITE_OMIT_FLOATING_POINT... */\n  pIdxInfo->estimatedCost = SQLITE_BIG_DBL / ((double)2);\n  nOrderBy = pIdxInfo->nOrderBy;\n  if( !pOrderBy ){\n    pIdxInfo->nOrderBy = 0;\n  }\n\n  if( vtabBestIndex(pParse, pTab, pIdxInfo) ){\n    return;\n  }\n\n  pIdxCons = *(struct sqlite3_index_constraint**)&pIdxInfo->aConstraint;\n  for(i=0; i<pIdxInfo->nConstraint; i++){\n    if( pUsage[i].argvIndex>0 ){\n      pCost->used |= pWC->a[pIdxCons[i].iTermOffset].prereqRight;\n    }\n  }\n\n  /* If there is an ORDER BY clause, and the selected virtual table index\n  ** does not satisfy it, increase the cost of the scan accordingly. This\n  ** matches the processing for non-virtual tables in bestBtreeIndex().\n  */\n  rCost = pIdxInfo->estimatedCost;\n  if( pOrderBy && pIdxInfo->orderByConsumed==0 ){\n    rCost += estLog(rCost)*rCost;\n  }\n\n  /* The cost is not allowed to be larger than SQLITE_BIG_DBL (the\n  ** inital value of lowestCost in this loop. If it is, then the\n  ** (cost<lowestCost) test below will never be true.\n  ** \n  ** Use \"(double)2\" instead of \"2.0\" in case OMIT_FLOATING_POINT \n  ** is defined.\n  */\n  if( (SQLITE_BIG_DBL/((double)2))<rCost ){\n    pCost->rCost = (SQLITE_BIG_DBL/((double)2));\n  }else{\n    pCost->rCost = rCost;\n  }\n  pCost->plan.u.pVtabIdx = pIdxInfo;\n  if( pIdxInfo->orderByConsumed ){\n    pCost->plan.wsFlags |= WHERE_ORDERBY;\n  }\n  pCost->plan.nEq = 0;\n  pIdxInfo->nOrderBy = nOrderBy;\n\n  /* Try to find a more efficient access pattern by using multiple indexes\n  ** to optimize an OR expression within the WHERE clause. \n  */\n  bestOrClauseIndex(pParse, pWC, pSrc, notReady, notValid, pOrderBy, pCost);\n}\n#endif /* SQLITE_OMIT_VIRTUALTABLE */\n\n/*\n** Argument pIdx is a pointer to an index structure that has an array of\n** SQLITE_INDEX_SAMPLES evenly spaced samples of the first indexed column\n** stored in Index.aSample. These samples divide the domain of values stored\n** the index into (SQLITE_INDEX_SAMPLES+1) regions.\n** Region 0 contains all values less than the first sample value. Region\n** 1 contains values between the first and second samples.  Region 2 contains\n** values between samples 2 and 3.  And so on.  Region SQLITE_INDEX_SAMPLES\n** contains values larger than the last sample.\n**\n** If the index contains many duplicates of a single value, then it is\n** possible that two or more adjacent samples can hold the same value.\n** When that is the case, the smallest possible region code is returned\n** when roundUp is false and the largest possible region code is returned\n** when roundUp is true.\n**\n** If successful, this function determines which of the regions value \n** pVal lies in, sets *piRegion to the region index (a value between 0\n** and SQLITE_INDEX_SAMPLES+1, inclusive) and returns SQLITE_OK.\n** Or, if an OOM occurs while converting text values between encodings,\n** SQLITE_NOMEM is returned and *piRegion is undefined.\n*/\n#ifdef SQLITE_ENABLE_STAT2\nstatic int whereRangeRegion(\n  Parse *pParse,              /* Database connection */\n  Index *pIdx,                /* Index to consider domain of */\n  sqlite3_value *pVal,        /* Value to consider */\n  int roundUp,                /* Return largest valid region if true */\n  int *piRegion               /* OUT: Region of domain in which value lies */\n){\n  assert( roundUp==0 || roundUp==1 );\n  if( ALWAYS(pVal) ){\n    IndexSample *aSample = pIdx->aSample;\n    int i = 0;\n    int eType = sqlite3_value_type(pVal);\n\n    if( eType==SQLITE_INTEGER || eType==SQLITE_FLOAT ){\n      double r = sqlite3_value_double(pVal);\n      for(i=0; i<SQLITE_INDEX_SAMPLES; i++){\n        if( aSample[i].eType==SQLITE_NULL ) continue;\n        if( aSample[i].eType>=SQLITE_TEXT ) break;\n        if( roundUp ){\n          if( aSample[i].u.r>r ) break;\n        }else{\n          if( aSample[i].u.r>=r ) break;\n        }\n      }\n    }else if( eType==SQLITE_NULL ){\n      i = 0;\n      if( roundUp ){\n        while( i<SQLITE_INDEX_SAMPLES && aSample[i].eType==SQLITE_NULL ) i++;\n      }\n    }else{ \n      sqlite3 *db = pParse->db;\n      CollSeq *pColl;\n      const u8 *z;\n      int n;\n\n      /* pVal comes from sqlite3ValueFromExpr() so the type cannot be NULL */\n      assert( eType==SQLITE_TEXT || eType==SQLITE_BLOB );\n\n      if( eType==SQLITE_BLOB ){\n        z = (const u8 *)sqlite3_value_blob(pVal);\n        pColl = db->pDfltColl;\n        assert( pColl->enc==SQLITE_UTF8 );\n      }else{\n        pColl = sqlite3GetCollSeq(db, SQLITE_UTF8, 0, *pIdx->azColl);\n        if( pColl==0 ){\n          sqlite3ErrorMsg(pParse, \"no such collation sequence: %s\",\n                          *pIdx->azColl);\n          return SQLITE_ERROR;\n        }\n        z = (const u8 *)sqlite3ValueText(pVal, pColl->enc);\n        if( !z ){\n          return SQLITE_NOMEM;\n        }\n        assert( z && pColl && pColl->xCmp );\n      }\n      n = sqlite3ValueBytes(pVal, pColl->enc);\n\n      for(i=0; i<SQLITE_INDEX_SAMPLES; i++){\n        int c;\n        int eSampletype = aSample[i].eType;\n        if( eSampletype==SQLITE_NULL || eSampletype<eType ) continue;\n        if( (eSampletype!=eType) ) break;\n#ifndef SQLITE_OMIT_UTF16\n        if( pColl->enc!=SQLITE_UTF8 ){\n          int nSample;\n          char *zSample = sqlite3Utf8to16(\n              db, pColl->enc, aSample[i].u.z, aSample[i].nByte, &nSample\n          );\n          if( !zSample ){\n            assert( db->mallocFailed );\n            return SQLITE_NOMEM;\n          }\n          c = pColl->xCmp(pColl->pUser, nSample, zSample, n, z);\n          sqlite3DbFree(db, zSample);\n        }else\n#endif\n        {\n          c = pColl->xCmp(pColl->pUser, aSample[i].nByte, aSample[i].u.z, n, z);\n        }\n        if( c-roundUp>=0 ) break;\n      }\n    }\n\n    assert( i>=0 && i<=SQLITE_INDEX_SAMPLES );\n    *piRegion = i;\n  }\n  return SQLITE_OK;\n}\n#endif   /* #ifdef SQLITE_ENABLE_STAT2 */\n\n/*\n** If expression pExpr represents a literal value, set *pp to point to\n** an sqlite3_value structure containing the same value, with affinity\n** aff applied to it, before returning. It is the responsibility of the \n** caller to eventually release this structure by passing it to \n** sqlite3ValueFree().\n**\n** If the current parse is a recompile (sqlite3Reprepare()) and pExpr\n** is an SQL variable that currently has a non-NULL value bound to it,\n** create an sqlite3_value structure containing this value, again with\n** affinity aff applied to it, instead.\n**\n** If neither of the above apply, set *pp to NULL.\n**\n** If an error occurs, return an error code. Otherwise, SQLITE_OK.\n*/\n#ifdef SQLITE_ENABLE_STAT2\nstatic int valueFromExpr(\n  Parse *pParse, \n  Expr *pExpr, \n  u8 aff, \n  sqlite3_value **pp\n){\n  if( pExpr->op==TK_VARIABLE\n   || (pExpr->op==TK_REGISTER && pExpr->op2==TK_VARIABLE)\n  ){\n    int iVar = pExpr->iColumn;\n    sqlite3VdbeSetVarmask(pParse->pVdbe, iVar); /* IMP: R-23257-02778 */\n    *pp = sqlite3VdbeGetValue(pParse->pReprepare, iVar, aff);\n    return SQLITE_OK;\n  }\n  return sqlite3ValueFromExpr(pParse->db, pExpr, SQLITE_UTF8, aff, pp);\n}\n#endif\n\n/*\n** This function is used to estimate the number of rows that will be visited\n** by scanning an index for a range of values. The range may have an upper\n** bound, a lower bound, or both. The WHERE clause terms that set the upper\n** and lower bounds are represented by pLower and pUpper respectively. For\n** example, assuming that index p is on t1(a):\n**\n**   ... FROM t1 WHERE a > ? AND a < ? ...\n**                    |_____|   |_____|\n**                       |         |\n**                     pLower    pUpper\n**\n** If either of the upper or lower bound is not present, then NULL is passed in\n** place of the corresponding WhereTerm.\n**\n** The nEq parameter is passed the index of the index column subject to the\n** range constraint. Or, equivalently, the number of equality constraints\n** optimized by the proposed index scan. For example, assuming index p is\n** on t1(a, b), and the SQL query is:\n**\n**   ... FROM t1 WHERE a = ? AND b > ? AND b < ? ...\n**\n** then nEq should be passed the value 1 (as the range restricted column,\n** b, is the second left-most column of the index). Or, if the query is:\n**\n**   ... FROM t1 WHERE a > ? AND a < ? ...\n**\n** then nEq should be passed 0.\n**\n** The returned value is an integer between 1 and 100, inclusive. A return\n** value of 1 indicates that the proposed range scan is expected to visit\n** approximately 1/100th (1%) of the rows selected by the nEq equality\n** constraints (if any). A return value of 100 indicates that it is expected\n** that the range scan will visit every row (100%) selected by the equality\n** constraints.\n**\n** In the absence of sqlite_stat2 ANALYZE data, each range inequality\n** reduces the search space by 3/4ths.  Hence a single constraint (x>?)\n** results in a return of 25 and a range constraint (x>? AND x<?) results\n** in a return of 6.\n*/\nstatic int whereRangeScanEst(\n  Parse *pParse,       /* Parsing & code generating context */\n  Index *p,            /* The index containing the range-compared column; \"x\" */\n  int nEq,             /* index into p->aCol[] of the range-compared column */\n  WhereTerm *pLower,   /* Lower bound on the range. ex: \"x>123\" Might be NULL */\n  WhereTerm *pUpper,   /* Upper bound on the range. ex: \"x<455\" Might be NULL */\n  int *piEst           /* OUT: Return value */\n){\n  int rc = SQLITE_OK;\n\n#ifdef SQLITE_ENABLE_STAT2\n\n  if( nEq==0 && p->aSample ){\n    sqlite3_value *pLowerVal = 0;\n    sqlite3_value *pUpperVal = 0;\n    int iEst;\n    int iLower = 0;\n    int iUpper = SQLITE_INDEX_SAMPLES;\n    int roundUpUpper = 0;\n    int roundUpLower = 0;\n    u8 aff = p->pTable->aCol[p->aiColumn[0]].affinity;\n\n    if( pLower ){\n      Expr *pExpr = pLower->pExpr->pRight;\n      rc = valueFromExpr(pParse, pExpr, aff, &pLowerVal);\n      assert( pLower->eOperator==WO_GT || pLower->eOperator==WO_GE );\n      roundUpLower = (pLower->eOperator==WO_GT) ?1:0;\n    }\n    if( rc==SQLITE_OK && pUpper ){\n      Expr *pExpr = pUpper->pExpr->pRight;\n      rc = valueFromExpr(pParse, pExpr, aff, &pUpperVal);\n      assert( pUpper->eOperator==WO_LT || pUpper->eOperator==WO_LE );\n      roundUpUpper = (pUpper->eOperator==WO_LE) ?1:0;\n    }\n\n    if( rc!=SQLITE_OK || (pLowerVal==0 && pUpperVal==0) ){\n      sqlite3ValueFree(pLowerVal);\n      sqlite3ValueFree(pUpperVal);\n      goto range_est_fallback;\n    }else if( pLowerVal==0 ){\n      rc = whereRangeRegion(pParse, p, pUpperVal, roundUpUpper, &iUpper);\n      if( pLower ) iLower = iUpper/2;\n    }else if( pUpperVal==0 ){\n      rc = whereRangeRegion(pParse, p, pLowerVal, roundUpLower, &iLower);\n      if( pUpper ) iUpper = (iLower + SQLITE_INDEX_SAMPLES + 1)/2;\n    }else{\n      rc = whereRangeRegion(pParse, p, pUpperVal, roundUpUpper, &iUpper);\n      if( rc==SQLITE_OK ){\n        rc = whereRangeRegion(pParse, p, pLowerVal, roundUpLower, &iLower);\n      }\n    }\n    WHERETRACE((\"range scan regions: %d..%d\\n\", iLower, iUpper));\n\n    iEst = iUpper - iLower;\n    testcase( iEst==SQLITE_INDEX_SAMPLES );\n    assert( iEst<=SQLITE_INDEX_SAMPLES );\n    if( iEst<1 ){\n      *piEst = 50/SQLITE_INDEX_SAMPLES;\n    }else{\n      *piEst = (iEst*100)/SQLITE_INDEX_SAMPLES;\n    }\n    sqlite3ValueFree(pLowerVal);\n    sqlite3ValueFree(pUpperVal);\n    return rc;\n  }\nrange_est_fallback:\n#else\n  UNUSED_PARAMETER(pParse);\n  UNUSED_PARAMETER(p);\n  UNUSED_PARAMETER(nEq);\n#endif\n  assert( pLower || pUpper );\n  *piEst = 100;\n  if( pLower && (pLower->wtFlags & TERM_VNULL)==0 ) *piEst /= 4;\n  if( pUpper ) *piEst /= 4;\n  return rc;\n}\n\n#ifdef SQLITE_ENABLE_STAT2\n/*\n** Estimate the number of rows that will be returned based on\n** an equality constraint x=VALUE and where that VALUE occurs in\n** the histogram data.  This only works when x is the left-most\n** column of an index and sqlite_stat2 histogram data is available\n** for that index.  When pExpr==NULL that means the constraint is\n** \"x IS NULL\" instead of \"x=VALUE\".\n**\n** Write the estimated row count into *pnRow and return SQLITE_OK. \n** If unable to make an estimate, leave *pnRow unchanged and return\n** non-zero.\n**\n** This routine can fail if it is unable to load a collating sequence\n** required for string comparison, or if unable to allocate memory\n** for a UTF conversion required for comparison.  The error is stored\n** in the pParse structure.\n*/\nint whereEqualScanEst(\n  Parse *pParse,       /* Parsing & code generating context */\n  Index *p,            /* The index whose left-most column is pTerm */\n  Expr *pExpr,         /* Expression for VALUE in the x=VALUE constraint */\n  double *pnRow        /* Write the revised row estimate here */\n){\n  sqlite3_value *pRhs = 0;  /* VALUE on right-hand side of pTerm */\n  int iLower, iUpper;       /* Range of histogram regions containing pRhs */\n  u8 aff;                   /* Column affinity */\n  int rc;                   /* Subfunction return code */\n  double nRowEst;           /* New estimate of the number of rows */\n\n  assert( p->aSample!=0 );\n  aff = p->pTable->aCol[p->aiColumn[0]].affinity;\n  if( pExpr ){\n    rc = valueFromExpr(pParse, pExpr, aff, &pRhs);\n    if( rc ) goto whereEqualScanEst_cancel;\n  }else{\n    pRhs = sqlite3ValueNew(pParse->db);\n  }\n  if( pRhs==0 ) return SQLITE_NOTFOUND;\n  rc = whereRangeRegion(pParse, p, pRhs, 0, &iLower);\n  if( rc ) goto whereEqualScanEst_cancel;\n  rc = whereRangeRegion(pParse, p, pRhs, 1, &iUpper);\n  if( rc ) goto whereEqualScanEst_cancel;\n  WHERETRACE((\"equality scan regions: %d..%d\\n\", iLower, iUpper));\n  if( iLower>=iUpper ){\n    nRowEst = p->aiRowEst[0]/(SQLITE_INDEX_SAMPLES*2);\n    if( nRowEst<*pnRow ) *pnRow = nRowEst;\n  }else{\n    nRowEst = (iUpper-iLower)*p->aiRowEst[0]/SQLITE_INDEX_SAMPLES;\n    *pnRow = nRowEst;\n  }\n\nwhereEqualScanEst_cancel:\n  sqlite3ValueFree(pRhs);\n  return rc;\n}\n#endif /* defined(SQLITE_ENABLE_STAT2) */\n\n#ifdef SQLITE_ENABLE_STAT2\n/*\n** Estimate the number of rows that will be returned based on\n** an IN constraint where the right-hand side of the IN operator\n** is a list of values.  Example:\n**\n**        WHERE x IN (1,2,3,4)\n**\n** Write the estimated row count into *pnRow and return SQLITE_OK. \n** If unable to make an estimate, leave *pnRow unchanged and return\n** non-zero.\n**\n** This routine can fail if it is unable to load a collating sequence\n** required for string comparison, or if unable to allocate memory\n** for a UTF conversion required for comparison.  The error is stored\n** in the pParse structure.\n*/\nint whereInScanEst(\n  Parse *pParse,       /* Parsing & code generating context */\n  Index *p,            /* The index whose left-most column is pTerm */\n  ExprList *pList,     /* The value list on the RHS of \"x IN (v1,v2,v3,...)\" */\n  double *pnRow        /* Write the revised row estimate here */\n){\n  sqlite3_value *pVal = 0;  /* One value from list */\n  int iLower, iUpper;       /* Range of histogram regions containing pRhs */\n  u8 aff;                   /* Column affinity */\n  int rc = SQLITE_OK;       /* Subfunction return code */\n  double nRowEst;           /* New estimate of the number of rows */\n  int nSpan = 0;            /* Number of histogram regions spanned */\n  int nSingle = 0;          /* Histogram regions hit by a single value */\n  int nNotFound = 0;        /* Count of values that are not constants */\n  int i;                               /* Loop counter */\n  u8 aSpan[SQLITE_INDEX_SAMPLES+1];    /* Histogram regions that are spanned */\n  u8 aSingle[SQLITE_INDEX_SAMPLES+1];  /* Histogram regions hit once */\n\n  assert( p->aSample!=0 );\n  aff = p->pTable->aCol[p->aiColumn[0]].affinity;\n  memset(aSpan, 0, sizeof(aSpan));\n  memset(aSingle, 0, sizeof(aSingle));\n  for(i=0; i<pList->nExpr; i++){\n    sqlite3ValueFree(pVal);\n    rc = valueFromExpr(pParse, pList->a[i].pExpr, aff, &pVal);\n    if( rc ) break;\n    if( pVal==0 || sqlite3_value_type(pVal)==SQLITE_NULL ){\n      nNotFound++;\n      continue;\n    }\n    rc = whereRangeRegion(pParse, p, pVal, 0, &iLower);\n    if( rc ) break;\n    rc = whereRangeRegion(pParse, p, pVal, 1, &iUpper);\n    if( rc ) break;\n    if( iLower>=iUpper ){\n      aSingle[iLower] = 1;\n    }else{\n      assert( iLower>=0 && iUpper<=SQLITE_INDEX_SAMPLES );\n      while( iLower<iUpper ) aSpan[iLower++] = 1;\n    }\n  }\n  if( rc==SQLITE_OK ){\n    for(i=nSpan=0; i<=SQLITE_INDEX_SAMPLES; i++){\n      if( aSpan[i] ){\n        nSpan++;\n      }else if( aSingle[i] ){\n        nSingle++;\n      }\n    }\n    nRowEst = (nSpan*2+nSingle)*p->aiRowEst[0]/(2*SQLITE_INDEX_SAMPLES)\n               + nNotFound*p->aiRowEst[1];\n    if( nRowEst > p->aiRowEst[0] ) nRowEst = p->aiRowEst[0];\n    *pnRow = nRowEst;\n    WHERETRACE((\"IN row estimate: nSpan=%d, nSingle=%d, nNotFound=%d, est=%g\\n\",\n                 nSpan, nSingle, nNotFound, nRowEst));\n  }\n  sqlite3ValueFree(pVal);\n  return rc;\n}\n#endif /* defined(SQLITE_ENABLE_STAT2) */\n\n\n/*\n** Find the best query plan for accessing a particular table.  Write the\n** best query plan and its cost into the WhereCost object supplied as the\n** last parameter.\n**\n** The lowest cost plan wins.  The cost is an estimate of the amount of\n** CPU and disk I/O needed to process the requested result.\n** Factors that influence cost include:\n**\n**    *  The estimated number of rows that will be retrieved.  (The\n**       fewer the better.)\n**\n**    *  Whether or not sorting must occur.\n**\n**    *  Whether or not there must be separate lookups in the\n**       index and in the main table.\n**\n** If there was an INDEXED BY clause (pSrc->pIndex) attached to the table in\n** the SQL statement, then this function only considers plans using the \n** named index. If no such plan is found, then the returned cost is\n** SQLITE_BIG_DBL. If a plan is found that uses the named index, \n** then the cost is calculated in the usual way.\n**\n** If a NOT INDEXED clause (pSrc->notIndexed!=0) was attached to the table \n** in the SELECT statement, then no indexes are considered. However, the \n** selected plan may still take advantage of the built-in rowid primary key\n** index.\n*/\nstatic void bestBtreeIndex(\n  Parse *pParse,              /* The parsing context */\n  WhereClause *pWC,           /* The WHERE clause */\n  struct SrcList_item *pSrc,  /* The FROM clause term to search */\n  Bitmask notReady,           /* Mask of cursors not available for indexing */\n  Bitmask notValid,           /* Cursors not available for any purpose */\n  ExprList *pOrderBy,         /* The ORDER BY clause */\n  WhereCost *pCost            /* Lowest cost query plan */\n){\n  int iCur = pSrc->iCursor;   /* The cursor of the table to be accessed */\n  Index *pProbe;              /* An index we are evaluating */\n  Index *pIdx;                /* Copy of pProbe, or zero for IPK index */\n  int eqTermMask;             /* Current mask of valid equality operators */\n  int idxEqTermMask;          /* Index mask of valid equality operators */\n  Index sPk;                  /* A fake index object for the primary key */\n  unsigned int aiRowEstPk[2]; /* The aiRowEst[] value for the sPk index */\n  int aiColumnPk = -1;        /* The aColumn[] value for the sPk index */\n  int wsFlagMask;             /* Allowed flags in pCost->plan.wsFlag */\n\n  /* Initialize the cost to a worst-case value */\n  memset(pCost, 0, sizeof(*pCost));\n  pCost->rCost = SQLITE_BIG_DBL;\n\n  /* If the pSrc table is the right table of a LEFT JOIN then we may not\n  ** use an index to satisfy IS NULL constraints on that table.  This is\n  ** because columns might end up being NULL if the table does not match -\n  ** a circumstance which the index cannot help us discover.  Ticket #2177.\n  */\n  if( pSrc->jointype & JT_LEFT ){\n    idxEqTermMask = WO_EQ|WO_IN;\n  }else{\n    idxEqTermMask = WO_EQ|WO_IN|WO_ISNULL;\n  }\n\n  if( pSrc->pIndex ){\n    /* An INDEXED BY clause specifies a particular index to use */\n    pIdx = pProbe = pSrc->pIndex;\n    wsFlagMask = ~(WHERE_ROWID_EQ|WHERE_ROWID_RANGE);\n    eqTermMask = idxEqTermMask;\n  }else{\n    /* There is no INDEXED BY clause.  Create a fake Index object in local\n    ** variable sPk to represent the rowid primary key index.  Make this\n    ** fake index the first in a chain of Index objects with all of the real\n    ** indices to follow */\n    Index *pFirst;                  /* First of real indices on the table */\n    memset(&sPk, 0, sizeof(Index));\n    sPk.nColumn = 1;\n    sPk.aiColumn = &aiColumnPk;\n    sPk.aiRowEst = aiRowEstPk;\n    sPk.onError = OE_Replace;\n    sPk.pTable = pSrc->pTab;\n    aiRowEstPk[0] = pSrc->pTab->nRowEst;\n    aiRowEstPk[1] = 1;\n    pFirst = pSrc->pTab->pIndex;\n    if( pSrc->notIndexed==0 ){\n      /* The real indices of the table are only considered if the\n      ** NOT INDEXED qualifier is omitted from the FROM clause */\n      sPk.pNext = pFirst;\n    }\n    pProbe = &sPk;\n    wsFlagMask = ~(\n        WHERE_COLUMN_IN|WHERE_COLUMN_EQ|WHERE_COLUMN_NULL|WHERE_COLUMN_RANGE\n    );\n    eqTermMask = WO_EQ|WO_IN;\n    pIdx = 0;\n  }\n\n  /* Loop over all indices looking for the best one to use\n  */\n  for(; pProbe; pIdx=pProbe=pProbe->pNext){\n    const unsigned int * const aiRowEst = pProbe->aiRowEst;\n    double cost;                /* Cost of using pProbe */\n    double nRow;                /* Estimated number of rows in result set */\n    double log10N;              /* base-10 logarithm of nRow (inexact) */\n    int rev;                    /* True to scan in reverse order */\n    int wsFlags = 0;\n    Bitmask used = 0;\n\n    /* The following variables are populated based on the properties of\n    ** index being evaluated. They are then used to determine the expected\n    ** cost and number of rows returned.\n    **\n    **  nEq: \n    **    Number of equality terms that can be implemented using the index.\n    **    In other words, the number of initial fields in the index that\n    **    are used in == or IN or NOT NULL constraints of the WHERE clause.\n    **\n    **  nInMul:  \n    **    The \"in-multiplier\". This is an estimate of how many seek operations \n    **    SQLite must perform on the index in question. For example, if the \n    **    WHERE clause is:\n    **\n    **      WHERE a IN (1, 2, 3) AND b IN (4, 5, 6)\n    **\n    **    SQLite must perform 9 lookups on an index on (a, b), so nInMul is \n    **    set to 9. Given the same schema and either of the following WHERE \n    **    clauses:\n    **\n    **      WHERE a =  1\n    **      WHERE a >= 2\n    **\n    **    nInMul is set to 1.\n    **\n    **    If there exists a WHERE term of the form \"x IN (SELECT ...)\", then \n    **    the sub-select is assumed to return 25 rows for the purposes of \n    **    determining nInMul.\n    **\n    **  bInEst:  \n    **    Set to true if there was at least one \"x IN (SELECT ...)\" term used \n    **    in determining the value of nInMul.  Note that the RHS of the\n    **    IN operator must be a SELECT, not a value list, for this variable\n    **    to be true.\n    **\n    **  estBound:\n    **    An estimate on the amount of the table that must be searched.  A\n    **    value of 100 means the entire table is searched.  Range constraints\n    **    might reduce this to a value less than 100 to indicate that only\n    **    a fraction of the table needs searching.  In the absence of\n    **    sqlite_stat2 ANALYZE data, a single inequality reduces the search\n    **    space to 1/4rd its original size.  So an x>? constraint reduces\n    **    estBound to 25.  Two constraints (x>? AND x<?) reduce estBound to 6.\n    **\n    **  bSort:   \n    **    Boolean. True if there is an ORDER BY clause that will require an \n    **    external sort (i.e. scanning the index being evaluated will not \n    **    correctly order records).\n    **\n    **  bLookup: \n    **    Boolean. True if a table lookup is required for each index entry\n    **    visited.  In other words, true if this is not a covering index.\n    **    This is always false for the rowid primary key index of a table.\n    **    For other indexes, it is true unless all the columns of the table\n    **    used by the SELECT statement are present in the index (such an\n    **    index is sometimes described as a covering index).\n    **    For example, given the index on (a, b), the second of the following \n    **    two queries requires table b-tree lookups in order to find the value\n    **    of column c, but the first does not because columns a and b are\n    **    both available in the index.\n    **\n    **             SELECT a, b    FROM tbl WHERE a = 1;\n    **             SELECT a, b, c FROM tbl WHERE a = 1;\n    */\n    int nEq;                      /* Number of == or IN terms matching index */\n    int bInEst = 0;               /* True if \"x IN (SELECT...)\" seen */\n    int nInMul = 1;               /* Number of distinct equalities to lookup */\n    int estBound = 100;           /* Estimated reduction in search space */\n    int nBound = 0;               /* Number of range constraints seen */\n    int bSort = 0;                /* True if external sort required */\n    int bLookup = 0;              /* True if not a covering index */\n    WhereTerm *pTerm;             /* A single term of the WHERE clause */\n#ifdef SQLITE_ENABLE_STAT2\n    WhereTerm *pFirstTerm = 0;    /* First term matching the index */\n#endif\n\n    /* Determine the values of nEq and nInMul */\n    for(nEq=0; nEq<pProbe->nColumn; nEq++){\n      int j = pProbe->aiColumn[nEq];\n      pTerm = findTerm(pWC, iCur, j, notReady, eqTermMask, pIdx);\n      if( pTerm==0 ) break;\n      wsFlags |= (WHERE_COLUMN_EQ|WHERE_ROWID_EQ);\n      if( pTerm->eOperator & WO_IN ){\n        Expr *pExpr = pTerm->pExpr;\n        wsFlags |= WHERE_COLUMN_IN;\n        if( ExprHasProperty(pExpr, EP_xIsSelect) ){\n          /* \"x IN (SELECT ...)\":  Assume the SELECT returns 25 rows */\n          nInMul *= 25;\n          bInEst = 1;\n        }else if( ALWAYS(pExpr->x.pList && pExpr->x.pList->nExpr) ){\n          /* \"x IN (value, value, ...)\" */\n          nInMul *= pExpr->x.pList->nExpr;\n        }\n      }else if( pTerm->eOperator & WO_ISNULL ){\n        wsFlags |= WHERE_COLUMN_NULL;\n      }\n#ifdef SQLITE_ENABLE_STAT2\n      if( nEq==0 && pProbe->aSample ) pFirstTerm = pTerm;\n#endif\n      used |= pTerm->prereqRight;\n    }\n\n    /* Determine the value of estBound. */\n    if( nEq<pProbe->nColumn ){\n      int j = pProbe->aiColumn[nEq];\n      if( findTerm(pWC, iCur, j, notReady, WO_LT|WO_LE|WO_GT|WO_GE, pIdx) ){\n        WhereTerm *pTop = findTerm(pWC, iCur, j, notReady, WO_LT|WO_LE, pIdx);\n        WhereTerm *pBtm = findTerm(pWC, iCur, j, notReady, WO_GT|WO_GE, pIdx);\n        whereRangeScanEst(pParse, pProbe, nEq, pBtm, pTop, &estBound);\n        if( pTop ){\n          nBound = 1;\n          wsFlags |= WHERE_TOP_LIMIT;\n          used |= pTop->prereqRight;\n        }\n        if( pBtm ){\n          nBound++;\n          wsFlags |= WHERE_BTM_LIMIT;\n          used |= pBtm->prereqRight;\n        }\n        wsFlags |= (WHERE_COLUMN_RANGE|WHERE_ROWID_RANGE);\n      }\n    }else if( pProbe->onError!=OE_None ){\n      testcase( wsFlags & WHERE_COLUMN_IN );\n      testcase( wsFlags & WHERE_COLUMN_NULL );\n      if( (wsFlags & (WHERE_COLUMN_IN|WHERE_COLUMN_NULL))==0 ){\n        wsFlags |= WHERE_UNIQUE;\n      }\n    }\n\n    /* If there is an ORDER BY clause and the index being considered will\n    ** naturally scan rows in the required order, set the appropriate flags\n    ** in wsFlags. Otherwise, if there is an ORDER BY clause but the index\n    ** will scan rows in a different order, set the bSort variable.  */\n    if( pOrderBy ){\n      if( (wsFlags & WHERE_COLUMN_IN)==0\n        && isSortingIndex(pParse, pWC->pMaskSet, pProbe, iCur, pOrderBy,\n                          nEq, wsFlags, &rev)\n      ){\n        wsFlags |= WHERE_ROWID_RANGE|WHERE_COLUMN_RANGE|WHERE_ORDERBY;\n        wsFlags |= (rev ? WHERE_REVERSE : 0);\n      }else{\n        bSort = 1;\n      }\n    }\n\n    /* If currently calculating the cost of using an index (not the IPK\n    ** index), determine if all required column data may be obtained without \n    ** using the main table (i.e. if the index is a covering\n    ** index for this query). If it is, set the WHERE_IDX_ONLY flag in\n    ** wsFlags. Otherwise, set the bLookup variable to true.  */\n    if( pIdx && wsFlags ){\n      Bitmask m = pSrc->colUsed;\n      int j;\n      for(j=0; j<pIdx->nColumn; j++){\n        int x = pIdx->aiColumn[j];\n        if( x<BMS-1 ){\n          m &= ~(((Bitmask)1)<<x);\n        }\n      }\n      if( m==0 ){\n        wsFlags |= WHERE_IDX_ONLY;\n      }else{\n        bLookup = 1;\n      }\n    }\n\n    /*\n    ** Estimate the number of rows of output.  For an \"x IN (SELECT...)\"\n    ** constraint, do not let the estimate exceed half the rows in the table.\n    */\n    nRow = (double)(aiRowEst[nEq] * nInMul);\n    if( bInEst && nRow*2>aiRowEst[0] ){\n      nRow = aiRowEst[0]/2;\n      nInMul = (int)(nRow / aiRowEst[nEq]);\n    }\n\n#ifdef SQLITE_ENABLE_STAT2\n    /* If the constraint is of the form x=VALUE and histogram\n    ** data is available for column x, then it might be possible\n    ** to get a better estimate on the number of rows based on\n    ** VALUE and how common that value is according to the histogram.\n    */\n    if( nRow>(double)1 && nEq==1 && pFirstTerm!=0 ){\n      if( pFirstTerm->eOperator & (WO_EQ|WO_ISNULL) ){\n        testcase( pFirstTerm->eOperator==WO_EQ );\n        testcase( pFirstTerm->pOperator==WO_ISNULL );\n        whereEqualScanEst(pParse, pProbe, pFirstTerm->pExpr->pRight, &nRow);\n      }else if( pFirstTerm->eOperator==WO_IN && bInEst==0 ){\n        whereInScanEst(pParse, pProbe, pFirstTerm->pExpr->x.pList, &nRow);\n      }\n    }\n#endif /* SQLITE_ENABLE_STAT2 */\n\n    /* Adjust the number of output rows and downward to reflect rows\n    ** that are excluded by range constraints.\n    */\n    nRow = (nRow * (double)estBound) / (double)100;\n    if( nRow<1 ) nRow = 1;\n\n    /* Experiments run on real SQLite databases show that the time needed\n    ** to do a binary search to locate a row in a table or index is roughly\n    ** log10(N) times the time to move from one row to the next row within\n    ** a table or index.  The actual times can vary, with the size of\n    ** records being an important factor.  Both moves and searches are\n    ** slower with larger records, presumably because fewer records fit\n    ** on one page and hence more pages have to be fetched.\n    **\n    ** The ANALYZE command and the sqlite_stat1 and sqlite_stat2 tables do\n    ** not give us data on the relative sizes of table and index records.\n    ** So this computation assumes table records are about twice as big\n    ** as index records\n    */\n    if( (wsFlags & WHERE_NOT_FULLSCAN)==0 ){\n      /* The cost of a full table scan is a number of move operations equal\n      ** to the number of rows in the table.\n      **\n      ** We add an additional 4x penalty to full table scans.  This causes\n      ** the cost function to err on the side of choosing an index over\n      ** choosing a full scan.  This 4x full-scan penalty is an arguable\n      ** decision and one which we expect to revisit in the future.  But\n      ** it seems to be working well enough at the moment.\n      */\n      cost = aiRowEst[0]*4;\n    }else{\n      log10N = estLog(aiRowEst[0]);\n      cost = nRow;\n      if( pIdx ){\n        if( bLookup ){\n          /* For an index lookup followed by a table lookup:\n          **    nInMul index searches to find the start of each index range\n          **  + nRow steps through the index\n          **  + nRow table searches to lookup the table entry using the rowid\n          */\n          cost += (nInMul + nRow)*log10N;\n        }else{\n          /* For a covering index:\n          **     nInMul index searches to find the initial entry \n          **   + nRow steps through the index\n          */\n          cost += nInMul*log10N;\n        }\n      }else{\n        /* For a rowid primary key lookup:\n        **    nInMult table searches to find the initial entry for each range\n        **  + nRow steps through the table\n        */\n        cost += nInMul*log10N;\n      }\n    }\n\n    /* Add in the estimated cost of sorting the result.  Actual experimental\n    ** measurements of sorting performance in SQLite show that sorting time\n    ** adds C*N*log10(N) to the cost, where N is the number of rows to be \n    ** sorted and C is a factor between 1.95 and 4.3.  We will split the\n    ** difference and select C of 3.0.\n    */\n    if( bSort ){\n      cost += nRow*estLog(nRow)*3;\n    }\n\n    /**** Cost of using this index has now been computed ****/\n\n    /* If there are additional constraints on this table that cannot\n    ** be used with the current index, but which might lower the number\n    ** of output rows, adjust the nRow value accordingly.  This only \n    ** matters if the current index is the least costly, so do not bother\n    ** with this step if we already know this index will not be chosen.\n    ** Also, never reduce the output row count below 2 using this step.\n    **\n    ** It is critical that the notValid mask be used here instead of\n    ** the notReady mask.  When computing an \"optimal\" index, the notReady\n    ** mask will only have one bit set - the bit for the current table.\n    ** The notValid mask, on the other hand, always has all bits set for\n    ** tables that are not in outer loops.  If notReady is used here instead\n    ** of notValid, then a optimal index that depends on inner joins loops\n    ** might be selected even when there exists an optimal index that has\n    ** no such dependency.\n    */\n    if( nRow>2 && cost<=pCost->rCost ){\n      int k;                       /* Loop counter */\n      int nSkipEq = nEq;           /* Number of == constraints to skip */\n      int nSkipRange = nBound;     /* Number of < constraints to skip */\n      Bitmask thisTab;             /* Bitmap for pSrc */\n\n      thisTab = getMask(pWC->pMaskSet, iCur);\n      for(pTerm=pWC->a, k=pWC->nTerm; nRow>2 && k; k--, pTerm++){\n        if( pTerm->wtFlags & TERM_VIRTUAL ) continue;\n        if( (pTerm->prereqAll & notValid)!=thisTab ) continue;\n        if( pTerm->eOperator & (WO_EQ|WO_IN|WO_ISNULL) ){\n          if( nSkipEq ){\n            /* Ignore the first nEq equality matches since the index\n            ** has already accounted for these */\n            nSkipEq--;\n          }else{\n            /* Assume each additional equality match reduces the result\n            ** set size by a factor of 10 */\n            nRow /= 10;\n          }\n        }else if( pTerm->eOperator & (WO_LT|WO_LE|WO_GT|WO_GE) ){\n          if( nSkipRange ){\n            /* Ignore the first nSkipRange range constraints since the index\n            ** has already accounted for these */\n            nSkipRange--;\n          }else{\n            /* Assume each additional range constraint reduces the result\n            ** set size by a factor of 3.  Indexed range constraints reduce\n            ** the search space by a larger factor: 4.  We make indexed range\n            ** more selective intentionally because of the subjective \n            ** observation that indexed range constraints really are more\n            ** selective in practice, on average. */\n            nRow /= 3;\n          }\n        }else if( pTerm->eOperator!=WO_NOOP ){\n          /* Any other expression lowers the output row count by half */\n          nRow /= 2;\n        }\n      }\n      if( nRow<2 ) nRow = 2;\n    }\n\n\n    WHERETRACE((\n      \"%s(%s): nEq=%d nInMul=%d estBound=%d bSort=%d bLookup=%d wsFlags=0x%x\\n\"\n      \"         notReady=0x%llx log10N=%.1f nRow=%.1f cost=%.1f used=0x%llx\\n\",\n      pSrc->pTab->zName, (pIdx ? pIdx->zName : \"ipk\"), \n      nEq, nInMul, estBound, bSort, bLookup, wsFlags,\n      notReady, log10N, nRow, cost, used\n    ));\n\n    /* If this index is the best we have seen so far, then record this\n    ** index and its cost in the pCost structure.\n    */\n    if( (!pIdx || wsFlags)\n     && (cost<pCost->rCost || (cost<=pCost->rCost && nRow<pCost->plan.nRow))\n    ){\n      pCost->rCost = cost;\n      pCost->used = used;\n      pCost->plan.nRow = nRow;\n      pCost->plan.wsFlags = (wsFlags&wsFlagMask);\n      pCost->plan.nEq = nEq;\n      pCost->plan.u.pIdx = pIdx;\n    }\n\n    /* If there was an INDEXED BY clause, then only that one index is\n    ** considered. */\n    if( pSrc->pIndex ) break;\n\n    /* Reset masks for the next index in the loop */\n    wsFlagMask = ~(WHERE_ROWID_EQ|WHERE_ROWID_RANGE);\n    eqTermMask = idxEqTermMask;\n  }\n\n  /* If there is no ORDER BY clause and the SQLITE_ReverseOrder flag\n  ** is set, then reverse the order that the index will be scanned\n  ** in. This is used for application testing, to help find cases\n  ** where application behaviour depends on the (undefined) order that\n  ** SQLite outputs rows in in the absence of an ORDER BY clause.  */\n  if( !pOrderBy && pParse->db->flags & SQLITE_ReverseOrder ){\n    pCost->plan.wsFlags |= WHERE_REVERSE;\n  }\n\n  assert( pOrderBy || (pCost->plan.wsFlags&WHERE_ORDERBY)==0 );\n  assert( pCost->plan.u.pIdx==0 || (pCost->plan.wsFlags&WHERE_ROWID_EQ)==0 );\n  assert( pSrc->pIndex==0 \n       || pCost->plan.u.pIdx==0 \n       || pCost->plan.u.pIdx==pSrc->pIndex \n  );\n\n  WHERETRACE((\"best index is: %s\\n\", \n    ((pCost->plan.wsFlags & WHERE_NOT_FULLSCAN)==0 ? \"none\" : \n         pCost->plan.u.pIdx ? pCost->plan.u.pIdx->zName : \"ipk\")\n  ));\n  \n  bestOrClauseIndex(pParse, pWC, pSrc, notReady, notValid, pOrderBy, pCost);\n  bestAutomaticIndex(pParse, pWC, pSrc, notReady, pCost);\n  pCost->plan.wsFlags |= eqTermMask;\n}\n\n/*\n** Find the query plan for accessing table pSrc->pTab. Write the\n** best query plan and its cost into the WhereCost object supplied \n** as the last parameter. This function may calculate the cost of\n** both real and virtual table scans.\n*/\nstatic void bestIndex(\n  Parse *pParse,              /* The parsing context */\n  WhereClause *pWC,           /* The WHERE clause */\n  struct SrcList_item *pSrc,  /* The FROM clause term to search */\n  Bitmask notReady,           /* Mask of cursors not available for indexing */\n  Bitmask notValid,           /* Cursors not available for any purpose */\n  ExprList *pOrderBy,         /* The ORDER BY clause */\n  WhereCost *pCost            /* Lowest cost query plan */\n){\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  if( IsVirtual(pSrc->pTab) ){\n    sqlite3_index_info *p = 0;\n    bestVirtualIndex(pParse, pWC, pSrc, notReady, notValid, pOrderBy, pCost,&p);\n    if( p->needToFreeIdxStr ){\n      sqlite3_free(p->idxStr);\n    }\n    sqlite3DbFree(pParse->db, p);\n  }else\n#endif\n  {\n    bestBtreeIndex(pParse, pWC, pSrc, notReady, notValid, pOrderBy, pCost);\n  }\n}\n\n/*\n** Disable a term in the WHERE clause.  Except, do not disable the term\n** if it controls a LEFT OUTER JOIN and it did not originate in the ON\n** or USING clause of that join.\n**\n** Consider the term t2.z='ok' in the following queries:\n**\n**   (1)  SELECT * FROM t1 LEFT JOIN t2 ON t1.a=t2.x WHERE t2.z='ok'\n**   (2)  SELECT * FROM t1 LEFT JOIN t2 ON t1.a=t2.x AND t2.z='ok'\n**   (3)  SELECT * FROM t1, t2 WHERE t1.a=t2.x AND t2.z='ok'\n**\n** The t2.z='ok' is disabled in the in (2) because it originates\n** in the ON clause.  The term is disabled in (3) because it is not part\n** of a LEFT OUTER JOIN.  In (1), the term is not disabled.\n**\n** IMPLEMENTATION-OF: R-24597-58655 No tests are done for terms that are\n** completely satisfied by indices.\n**\n** Disabling a term causes that term to not be tested in the inner loop\n** of the join.  Disabling is an optimization.  When terms are satisfied\n** by indices, we disable them to prevent redundant tests in the inner\n** loop.  We would get the correct results if nothing were ever disabled,\n** but joins might run a little slower.  The trick is to disable as much\n** as we can without disabling too much.  If we disabled in (1), we'd get\n** the wrong answer.  See ticket #813.\n*/\nstatic void disableTerm(WhereLevel *pLevel, WhereTerm *pTerm){\n  if( pTerm\n      && (pTerm->wtFlags & TERM_CODED)==0\n      && (pLevel->iLeftJoin==0 || ExprHasProperty(pTerm->pExpr, EP_FromJoin))\n  ){\n    pTerm->wtFlags |= TERM_CODED;\n    if( pTerm->iParent>=0 ){\n      WhereTerm *pOther = &pTerm->pWC->a[pTerm->iParent];\n      if( (--pOther->nChild)==0 ){\n        disableTerm(pLevel, pOther);\n      }\n    }\n  }\n}\n\n/*\n** Code an OP_Affinity opcode to apply the column affinity string zAff\n** to the n registers starting at base. \n**\n** As an optimization, SQLITE_AFF_NONE entries (which are no-ops) at the\n** beginning and end of zAff are ignored.  If all entries in zAff are\n** SQLITE_AFF_NONE, then no code gets generated.\n**\n** This routine makes its own copy of zAff so that the caller is free\n** to modify zAff after this routine returns.\n*/\nstatic void codeApplyAffinity(Parse *pParse, int base, int n, char *zAff){\n  Vdbe *v = pParse->pVdbe;\n  if( zAff==0 ){\n    assert( pParse->db->mallocFailed );\n    return;\n  }\n  assert( v!=0 );\n\n  /* Adjust base and n to skip over SQLITE_AFF_NONE entries at the beginning\n  ** and end of the affinity string.\n  */\n  while( n>0 && zAff[0]==SQLITE_AFF_NONE ){\n    n--;\n    base++;\n    zAff++;\n  }\n  while( n>1 && zAff[n-1]==SQLITE_AFF_NONE ){\n    n--;\n  }\n\n  /* Code the OP_Affinity opcode if there is anything left to do. */\n  if( n>0 ){\n    sqlite3VdbeAddOp2(v, OP_Affinity, base, n);\n    sqlite3VdbeChangeP4(v, -1, zAff, n);\n    sqlite3ExprCacheAffinityChange(pParse, base, n);\n  }\n}\n\n\n/*\n** Generate code for a single equality term of the WHERE clause.  An equality\n** term can be either X=expr or X IN (...).   pTerm is the term to be \n** coded.\n**\n** The current value for the constraint is left in register iReg.\n**\n** For a constraint of the form X=expr, the expression is evaluated and its\n** result is left on the stack.  For constraints of the form X IN (...)\n** this routine sets up a loop that will iterate over all values of X.\n*/\nstatic int codeEqualityTerm(\n  Parse *pParse,      /* The parsing context */\n  WhereTerm *pTerm,   /* The term of the WHERE clause to be coded */\n  WhereLevel *pLevel, /* When level of the FROM clause we are working on */\n  int iTarget         /* Attempt to leave results in this register */\n){\n  Expr *pX = pTerm->pExpr;\n  Vdbe *v = pParse->pVdbe;\n  int iReg;                  /* Register holding results */\n\n  assert( iTarget>0 );\n  if( pX->op==TK_EQ ){\n    iReg = sqlite3ExprCodeTarget(pParse, pX->pRight, iTarget);\n  }else if( pX->op==TK_ISNULL ){\n    iReg = iTarget;\n    sqlite3VdbeAddOp2(v, OP_Null, 0, iReg);\n#ifndef SQLITE_OMIT_SUBQUERY\n  }else{\n    int eType;\n    int iTab;\n    struct InLoop *pIn;\n\n    assert( pX->op==TK_IN );\n    iReg = iTarget;\n    eType = sqlite3FindInIndex(pParse, pX, 0);\n    iTab = pX->iTable;\n    sqlite3VdbeAddOp2(v, OP_Rewind, iTab, 0);\n    assert( pLevel->plan.wsFlags & WHERE_IN_ABLE );\n    if( pLevel->u.in.nIn==0 ){\n      pLevel->addrNxt = sqlite3VdbeMakeLabel(v);\n    }\n    pLevel->u.in.nIn++;\n    pLevel->u.in.aInLoop =\n       sqlite3DbReallocOrFree(pParse->db, pLevel->u.in.aInLoop,\n                              sizeof(pLevel->u.in.aInLoop[0])*pLevel->u.in.nIn);\n    pIn = pLevel->u.in.aInLoop;\n    if( pIn ){\n      pIn += pLevel->u.in.nIn - 1;\n      pIn->iCur = iTab;\n      if( eType==IN_INDEX_ROWID ){\n        pIn->addrInTop = sqlite3VdbeAddOp2(v, OP_Rowid, iTab, iReg);\n      }else{\n        pIn->addrInTop = sqlite3VdbeAddOp3(v, OP_Column, iTab, 0, iReg);\n      }\n      sqlite3VdbeAddOp1(v, OP_IsNull, iReg);\n    }else{\n      pLevel->u.in.nIn = 0;\n    }\n#endif\n  }\n  disableTerm(pLevel, pTerm);\n  return iReg;\n}\n\n/*\n** Generate code that will evaluate all == and IN constraints for an\n** index.\n**\n** For example, consider table t1(a,b,c,d,e,f) with index i1(a,b,c).\n** Suppose the WHERE clause is this:  a==5 AND b IN (1,2,3) AND c>5 AND c<10\n** The index has as many as three equality constraints, but in this\n** example, the third \"c\" value is an inequality.  So only two \n** constraints are coded.  This routine will generate code to evaluate\n** a==5 and b IN (1,2,3).  The current values for a and b will be stored\n** in consecutive registers and the index of the first register is returned.\n**\n** In the example above nEq==2.  But this subroutine works for any value\n** of nEq including 0.  If nEq==0, this routine is nearly a no-op.\n** The only thing it does is allocate the pLevel->iMem memory cell and\n** compute the affinity string.\n**\n** This routine always allocates at least one memory cell and returns\n** the index of that memory cell. The code that\n** calls this routine will use that memory cell to store the termination\n** key value of the loop.  If one or more IN operators appear, then\n** this routine allocates an additional nEq memory cells for internal\n** use.\n**\n** Before returning, *pzAff is set to point to a buffer containing a\n** copy of the column affinity string of the index allocated using\n** sqlite3DbMalloc(). Except, entries in the copy of the string associated\n** with equality constraints that use NONE affinity are set to\n** SQLITE_AFF_NONE. This is to deal with SQL such as the following:\n**\n**   CREATE TABLE t1(a TEXT PRIMARY KEY, b);\n**   SELECT ... FROM t1 AS t2, t1 WHERE t1.a = t2.b;\n**\n** In the example above, the index on t1(a) has TEXT affinity. But since\n** the right hand side of the equality constraint (t2.b) has NONE affinity,\n** no conversion should be attempted before using a t2.b value as part of\n** a key to search the index. Hence the first byte in the returned affinity\n** string in this example would be set to SQLITE_AFF_NONE.\n*/\nstatic int codeAllEqualityTerms(\n  Parse *pParse,        /* Parsing context */\n  WhereLevel *pLevel,   /* Which nested loop of the FROM we are coding */\n  WhereClause *pWC,     /* The WHERE clause */\n  Bitmask notReady,     /* Which parts of FROM have not yet been coded */\n  int nExtraReg,        /* Number of extra registers to allocate */\n  char **pzAff          /* OUT: Set to point to affinity string */\n){\n  int nEq = pLevel->plan.nEq;   /* The number of == or IN constraints to code */\n  Vdbe *v = pParse->pVdbe;      /* The vm under construction */\n  Index *pIdx;                  /* The index being used for this loop */\n  int iCur = pLevel->iTabCur;   /* The cursor of the table */\n  WhereTerm *pTerm;             /* A single constraint term */\n  int j;                        /* Loop counter */\n  int regBase;                  /* Base register */\n  int nReg;                     /* Number of registers to allocate */\n  char *zAff;                   /* Affinity string to return */\n\n  /* This module is only called on query plans that use an index. */\n  assert( pLevel->plan.wsFlags & WHERE_INDEXED );\n  pIdx = pLevel->plan.u.pIdx;\n\n  /* Figure out how many memory cells we will need then allocate them.\n  */\n  regBase = pParse->nMem + 1;\n  nReg = pLevel->plan.nEq + nExtraReg;\n  pParse->nMem += nReg;\n\n  zAff = sqlite3DbStrDup(pParse->db, sqlite3IndexAffinityStr(v, pIdx));\n  if( !zAff ){\n    pParse->db->mallocFailed = 1;\n  }\n\n  /* Evaluate the equality constraints\n  */\n  assert( pIdx->nColumn>=nEq );\n  for(j=0; j<nEq; j++){\n    int r1;\n    int k = pIdx->aiColumn[j];\n    pTerm = findTerm(pWC, iCur, k, notReady, pLevel->plan.wsFlags, pIdx);\n    if( NEVER(pTerm==0) ) break;\n    /* The following true for indices with redundant columns. \n    ** Ex: CREATE INDEX i1 ON t1(a,b,a); SELECT * FROM t1 WHERE a=0 AND b=0; */\n    testcase( (pTerm->wtFlags & TERM_CODED)!=0 );\n    testcase( pTerm->wtFlags & TERM_VIRTUAL ); /* EV: R-30575-11662 */\n    r1 = codeEqualityTerm(pParse, pTerm, pLevel, regBase+j);\n    if( r1!=regBase+j ){\n      if( nReg==1 ){\n        sqlite3ReleaseTempReg(pParse, regBase);\n        regBase = r1;\n      }else{\n        sqlite3VdbeAddOp2(v, OP_SCopy, r1, regBase+j);\n      }\n    }\n    testcase( pTerm->eOperator & WO_ISNULL );\n    testcase( pTerm->eOperator & WO_IN );\n    if( (pTerm->eOperator & (WO_ISNULL|WO_IN))==0 ){\n      Expr *pRight = pTerm->pExpr->pRight;\n      sqlite3ExprCodeIsNullJump(v, pRight, regBase+j, pLevel->addrBrk);\n      if( zAff ){\n        if( sqlite3CompareAffinity(pRight, zAff[j])==SQLITE_AFF_NONE ){\n          zAff[j] = SQLITE_AFF_NONE;\n        }\n        if( sqlite3ExprNeedsNoAffinityChange(pRight, zAff[j]) ){\n          zAff[j] = SQLITE_AFF_NONE;\n        }\n      }\n    }\n  }\n  *pzAff = zAff;\n  return regBase;\n}\n\n#ifndef SQLITE_OMIT_EXPLAIN\n/*\n** This routine is a helper for explainIndexRange() below\n**\n** pStr holds the text of an expression that we are building up one term\n** at a time.  This routine adds a new term to the end of the expression.\n** Terms are separated by AND so add the \"AND\" text for second and subsequent\n** terms only.\n*/\nstatic void explainAppendTerm(\n  StrAccum *pStr,             /* The text expression being built */\n  int iTerm,                  /* Index of this term.  First is zero */\n  const char *zColumn,        /* Name of the column */\n  const char *zOp             /* Name of the operator */\n){\n  if( iTerm ) sqlite3StrAccumAppend(pStr, \" AND \", 5);\n  sqlite3StrAccumAppend(pStr, zColumn, -1);\n  sqlite3StrAccumAppend(pStr, zOp, 1);\n  sqlite3StrAccumAppend(pStr, \"?\", 1);\n}\n\n/*\n** Argument pLevel describes a strategy for scanning table pTab. This \n** function returns a pointer to a string buffer containing a description\n** of the subset of table rows scanned by the strategy in the form of an\n** SQL expression. Or, if all rows are scanned, NULL is returned.\n**\n** For example, if the query:\n**\n**   SELECT * FROM t1 WHERE a=1 AND b>2;\n**\n** is run and there is an index on (a, b), then this function returns a\n** string similar to:\n**\n**   \"a=? AND b>?\"\n**\n** The returned pointer points to memory obtained from sqlite3DbMalloc().\n** It is the responsibility of the caller to free the buffer when it is\n** no longer required.\n*/\nstatic char *explainIndexRange(sqlite3 *db, WhereLevel *pLevel, Table *pTab){\n  WherePlan *pPlan = &pLevel->plan;\n  Index *pIndex = pPlan->u.pIdx;\n  int nEq = pPlan->nEq;\n  int i, j;\n  Column *aCol = pTab->aCol;\n  int *aiColumn = pIndex->aiColumn;\n  StrAccum txt;\n\n  if( nEq==0 && (pPlan->wsFlags & (WHERE_BTM_LIMIT|WHERE_TOP_LIMIT))==0 ){\n    return 0;\n  }\n  sqlite3StrAccumInit(&txt, 0, 0, SQLITE_MAX_LENGTH);\n  txt.db = db;\n  sqlite3StrAccumAppend(&txt, \" (\", 2);\n  for(i=0; i<nEq; i++){\n    explainAppendTerm(&txt, i, aCol[aiColumn[i]].zName, \"=\");\n  }\n\n  j = i;\n  if( pPlan->wsFlags&WHERE_BTM_LIMIT ){\n    explainAppendTerm(&txt, i++, aCol[aiColumn[j]].zName, \">\");\n  }\n  if( pPlan->wsFlags&WHERE_TOP_LIMIT ){\n    explainAppendTerm(&txt, i, aCol[aiColumn[j]].zName, \"<\");\n  }\n  sqlite3StrAccumAppend(&txt, \")\", 1);\n  return sqlite3StrAccumFinish(&txt);\n}\n\n/*\n** This function is a no-op unless currently processing an EXPLAIN QUERY PLAN\n** command. If the query being compiled is an EXPLAIN QUERY PLAN, a single\n** record is added to the output to describe the table scan strategy in \n** pLevel.\n*/\nstatic void explainOneScan(\n  Parse *pParse,                  /* Parse context */\n  SrcList *pTabList,              /* Table list this loop refers to */\n  WhereLevel *pLevel,             /* Scan to write OP_Explain opcode for */\n  int iLevel,                     /* Value for \"level\" column of output */\n  int iFrom,                      /* Value for \"from\" column of output */\n  u16 wctrlFlags                  /* Flags passed to sqlite3WhereBegin() */\n){\n  if( pParse->explain==2 ){\n    u32 flags = pLevel->plan.wsFlags;\n    struct SrcList_item *pItem = &pTabList->a[pLevel->iFrom];\n    Vdbe *v = pParse->pVdbe;      /* VM being constructed */\n    sqlite3 *db = pParse->db;     /* Database handle */\n    char *zMsg;                   /* Text to add to EQP output */\n    sqlite3_int64 nRow;           /* Expected number of rows visited by scan */\n    int iId = pParse->iSelectId;  /* Select id (left-most output column) */\n    int isSearch;                 /* True for a SEARCH. False for SCAN. */\n\n    if( (flags&WHERE_MULTI_OR) || (wctrlFlags&WHERE_ONETABLE_ONLY) ) return;\n\n    isSearch = (pLevel->plan.nEq>0)\n             || (flags&(WHERE_BTM_LIMIT|WHERE_TOP_LIMIT))!=0\n             || (wctrlFlags&(WHERE_ORDERBY_MIN|WHERE_ORDERBY_MAX));\n\n    zMsg = sqlite3MPrintf(db, \"%s\", isSearch?\"SEARCH\":\"SCAN\");\n    if( pItem->pSelect ){\n      zMsg = sqlite3MAppendf(db, zMsg, \"%s SUBQUERY %d\", zMsg,pItem->iSelectId);\n    }else{\n      zMsg = sqlite3MAppendf(db, zMsg, \"%s TABLE %s\", zMsg, pItem->zName);\n    }\n\n    if( pItem->zAlias ){\n      zMsg = sqlite3MAppendf(db, zMsg, \"%s AS %s\", zMsg, pItem->zAlias);\n    }\n    if( (flags & WHERE_INDEXED)!=0 ){\n      char *zWhere = explainIndexRange(db, pLevel, pItem->pTab);\n      zMsg = sqlite3MAppendf(db, zMsg, \"%s USING %s%sINDEX%s%s%s\", zMsg, \n          ((flags & WHERE_TEMP_INDEX)?\"AUTOMATIC \":\"\"),\n          ((flags & WHERE_IDX_ONLY)?\"COVERING \":\"\"),\n          ((flags & WHERE_TEMP_INDEX)?\"\":\" \"),\n          ((flags & WHERE_TEMP_INDEX)?\"\": pLevel->plan.u.pIdx->zName),\n          zWhere\n      );\n      sqlite3DbFree(db, zWhere);\n    }else if( flags & (WHERE_ROWID_EQ|WHERE_ROWID_RANGE) ){\n      zMsg = sqlite3MAppendf(db, zMsg, \"%s USING INTEGER PRIMARY KEY\", zMsg);\n\n      if( flags&WHERE_ROWID_EQ ){\n        zMsg = sqlite3MAppendf(db, zMsg, \"%s (rowid=?)\", zMsg);\n      }else if( (flags&WHERE_BOTH_LIMIT)==WHERE_BOTH_LIMIT ){\n        zMsg = sqlite3MAppendf(db, zMsg, \"%s (rowid>? AND rowid<?)\", zMsg);\n      }else if( flags&WHERE_BTM_LIMIT ){\n        zMsg = sqlite3MAppendf(db, zMsg, \"%s (rowid>?)\", zMsg);\n      }else if( flags&WHERE_TOP_LIMIT ){\n        zMsg = sqlite3MAppendf(db, zMsg, \"%s (rowid<?)\", zMsg);\n      }\n    }\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n    else if( (flags & WHERE_VIRTUALTABLE)!=0 ){\n      sqlite3_index_info *pVtabIdx = pLevel->plan.u.pVtabIdx;\n      zMsg = sqlite3MAppendf(db, zMsg, \"%s VIRTUAL TABLE INDEX %d:%s\", zMsg,\n                  pVtabIdx->idxNum, pVtabIdx->idxStr);\n    }\n#endif\n    if( wctrlFlags&(WHERE_ORDERBY_MIN|WHERE_ORDERBY_MAX) ){\n      testcase( wctrlFlags & WHERE_ORDERBY_MIN );\n      nRow = 1;\n    }else{\n      nRow = (sqlite3_int64)pLevel->plan.nRow;\n    }\n    zMsg = sqlite3MAppendf(db, zMsg, \"%s (~%lld rows)\", zMsg, nRow);\n    sqlite3VdbeAddOp4(v, OP_Explain, iId, iLevel, iFrom, zMsg, P4_DYNAMIC);\n  }\n}\n#else\n#define explainOneScan(u,v,w,x,y,z)\n#endif /* SQLITE_OMIT_EXPLAIN */\n\n\n/*\n** Generate code for the start of the iLevel-th loop in the WHERE clause\n** implementation described by pWInfo.\n*/\nstatic Bitmask codeOneLoopStart(\n  WhereInfo *pWInfo,   /* Complete information about the WHERE clause */\n  int iLevel,          /* Which level of pWInfo->a[] should be coded */\n  u16 wctrlFlags,      /* One of the WHERE_* flags defined in sqliteInt.h */\n  Bitmask notReady     /* Which tables are currently available */\n){\n  int j, k;            /* Loop counters */\n  int iCur;            /* The VDBE cursor for the table */\n  int addrNxt;         /* Where to jump to continue with the next IN case */\n  int omitTable;       /* True if we use the index only */\n  int bRev;            /* True if we need to scan in reverse order */\n  WhereLevel *pLevel;  /* The where level to be coded */\n  WhereClause *pWC;    /* Decomposition of the entire WHERE clause */\n  WhereTerm *pTerm;               /* A WHERE clause term */\n  Parse *pParse;                  /* Parsing context */\n  Vdbe *v;                        /* The prepared stmt under constructions */\n  struct SrcList_item *pTabItem;  /* FROM clause term being coded */\n  int addrBrk;                    /* Jump here to break out of the loop */\n  int addrCont;                   /* Jump here to continue with next cycle */\n  int iRowidReg = 0;        /* Rowid is stored in this register, if not zero */\n  int iReleaseReg = 0;      /* Temp register to free before returning */\n\n  pParse = pWInfo->pParse;\n  v = pParse->pVdbe;\n  pWC = pWInfo->pWC;\n  pLevel = &pWInfo->a[iLevel];\n  pTabItem = &pWInfo->pTabList->a[pLevel->iFrom];\n  iCur = pTabItem->iCursor;\n  bRev = (pLevel->plan.wsFlags & WHERE_REVERSE)!=0;\n  omitTable = (pLevel->plan.wsFlags & WHERE_IDX_ONLY)!=0 \n           && (wctrlFlags & WHERE_FORCE_TABLE)==0;\n\n  /* Create labels for the \"break\" and \"continue\" instructions\n  ** for the current loop.  Jump to addrBrk to break out of a loop.\n  ** Jump to cont to go immediately to the next iteration of the\n  ** loop.\n  **\n  ** When there is an IN operator, we also have a \"addrNxt\" label that\n  ** means to continue with the next IN value combination.  When\n  ** there are no IN operators in the constraints, the \"addrNxt\" label\n  ** is the same as \"addrBrk\".\n  */\n  addrBrk = pLevel->addrBrk = pLevel->addrNxt = sqlite3VdbeMakeLabel(v);\n  addrCont = pLevel->addrCont = sqlite3VdbeMakeLabel(v);\n\n  /* If this is the right table of a LEFT OUTER JOIN, allocate and\n  ** initialize a memory cell that records if this table matches any\n  ** row of the left table of the join.\n  */\n  if( pLevel->iFrom>0 && (pTabItem[0].jointype & JT_LEFT)!=0 ){\n    pLevel->iLeftJoin = ++pParse->nMem;\n    sqlite3VdbeAddOp2(v, OP_Integer, 0, pLevel->iLeftJoin);\n    VdbeComment((v, \"init LEFT JOIN no-match flag\"));\n  }\n\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  if(  (pLevel->plan.wsFlags & WHERE_VIRTUALTABLE)!=0 ){\n    /* Case 0:  The table is a virtual-table.  Use the VFilter and VNext\n    **          to access the data.\n    */\n    int iReg;   /* P3 Value for OP_VFilter */\n    sqlite3_index_info *pVtabIdx = pLevel->plan.u.pVtabIdx;\n    int nConstraint = pVtabIdx->nConstraint;\n    struct sqlite3_index_constraint_usage *aUsage =\n                                                pVtabIdx->aConstraintUsage;\n    const struct sqlite3_index_constraint *aConstraint =\n                                                pVtabIdx->aConstraint;\n\n    sqlite3ExprCachePush(pParse);\n    iReg = sqlite3GetTempRange(pParse, nConstraint+2);\n    for(j=1; j<=nConstraint; j++){\n      for(k=0; k<nConstraint; k++){\n        if( aUsage[k].argvIndex==j ){\n          int iTerm = aConstraint[k].iTermOffset;\n          sqlite3ExprCode(pParse, pWC->a[iTerm].pExpr->pRight, iReg+j+1);\n          break;\n        }\n      }\n      if( k==nConstraint ) break;\n    }\n    sqlite3VdbeAddOp2(v, OP_Integer, pVtabIdx->idxNum, iReg);\n    sqlite3VdbeAddOp2(v, OP_Integer, j-1, iReg+1);\n    sqlite3VdbeAddOp4(v, OP_VFilter, iCur, addrBrk, iReg, pVtabIdx->idxStr,\n                      pVtabIdx->needToFreeIdxStr ? P4_MPRINTF : P4_STATIC);\n    pVtabIdx->needToFreeIdxStr = 0;\n    for(j=0; j<nConstraint; j++){\n      if( aUsage[j].omit ){\n        int iTerm = aConstraint[j].iTermOffset;\n        disableTerm(pLevel, &pWC->a[iTerm]);\n      }\n    }\n    pLevel->op = OP_VNext;\n    pLevel->p1 = iCur;\n    pLevel->p2 = sqlite3VdbeCurrentAddr(v);\n    sqlite3ReleaseTempRange(pParse, iReg, nConstraint+2);\n    sqlite3ExprCachePop(pParse, 1);\n  }else\n#endif /* SQLITE_OMIT_VIRTUALTABLE */\n\n  if( pLevel->plan.wsFlags & WHERE_ROWID_EQ ){\n    /* Case 1:  We can directly reference a single row using an\n    **          equality comparison against the ROWID field.  Or\n    **          we reference multiple rows using a \"rowid IN (...)\"\n    **          construct.\n    */\n    iReleaseReg = sqlite3GetTempReg(pParse);\n    pTerm = findTerm(pWC, iCur, -1, notReady, WO_EQ|WO_IN, 0);\n    assert( pTerm!=0 );\n    assert( pTerm->pExpr!=0 );\n    assert( pTerm->leftCursor==iCur );\n    assert( omitTable==0 );\n    testcase( pTerm->wtFlags & TERM_VIRTUAL ); /* EV: R-30575-11662 */\n    iRowidReg = codeEqualityTerm(pParse, pTerm, pLevel, iReleaseReg);\n    addrNxt = pLevel->addrNxt;\n    sqlite3VdbeAddOp2(v, OP_MustBeInt, iRowidReg, addrNxt);\n    sqlite3VdbeAddOp3(v, OP_NotExists, iCur, addrNxt, iRowidReg);\n    sqlite3ExprCacheStore(pParse, iCur, -1, iRowidReg);\n    VdbeComment((v, \"pk\"));\n    pLevel->op = OP_Noop;\n  }else if( pLevel->plan.wsFlags & WHERE_ROWID_RANGE ){\n    /* Case 2:  We have an inequality comparison against the ROWID field.\n    */\n    int testOp = OP_Noop;\n    int start;\n    int memEndValue = 0;\n    WhereTerm *pStart, *pEnd;\n\n    assert( omitTable==0 );\n    pStart = findTerm(pWC, iCur, -1, notReady, WO_GT|WO_GE, 0);\n    pEnd = findTerm(pWC, iCur, -1, notReady, WO_LT|WO_LE, 0);\n    if( bRev ){\n      pTerm = pStart;\n      pStart = pEnd;\n      pEnd = pTerm;\n    }\n    if( pStart ){\n      Expr *pX;             /* The expression that defines the start bound */\n      int r1, rTemp;        /* Registers for holding the start boundary */\n\n      /* The following constant maps TK_xx codes into corresponding \n      ** seek opcodes.  It depends on a particular ordering of TK_xx\n      */\n      const u8 aMoveOp[] = {\n           /* TK_GT */  OP_SeekGt,\n           /* TK_LE */  OP_SeekLe,\n           /* TK_LT */  OP_SeekLt,\n           /* TK_GE */  OP_SeekGe\n      };\n      assert( TK_LE==TK_GT+1 );      /* Make sure the ordering.. */\n      assert( TK_LT==TK_GT+2 );      /*  ... of the TK_xx values... */\n      assert( TK_GE==TK_GT+3 );      /*  ... is correcct. */\n\n      testcase( pStart->wtFlags & TERM_VIRTUAL ); /* EV: R-30575-11662 */\n      pX = pStart->pExpr;\n      assert( pX!=0 );\n      assert( pStart->leftCursor==iCur );\n      r1 = sqlite3ExprCodeTemp(pParse, pX->pRight, &rTemp);\n      sqlite3VdbeAddOp3(v, aMoveOp[pX->op-TK_GT], iCur, addrBrk, r1);\n      VdbeComment((v, \"pk\"));\n      sqlite3ExprCacheAffinityChange(pParse, r1, 1);\n      sqlite3ReleaseTempReg(pParse, rTemp);\n      disableTerm(pLevel, pStart);\n    }else{\n      sqlite3VdbeAddOp2(v, bRev ? OP_Last : OP_Rewind, iCur, addrBrk);\n    }\n    if( pEnd ){\n      Expr *pX;\n      pX = pEnd->pExpr;\n      assert( pX!=0 );\n      assert( pEnd->leftCursor==iCur );\n      testcase( pEnd->wtFlags & TERM_VIRTUAL ); /* EV: R-30575-11662 */\n      memEndValue = ++pParse->nMem;\n      sqlite3ExprCode(pParse, pX->pRight, memEndValue);\n      if( pX->op==TK_LT || pX->op==TK_GT ){\n        testOp = bRev ? OP_Le : OP_Ge;\n      }else{\n        testOp = bRev ? OP_Lt : OP_Gt;\n      }\n      disableTerm(pLevel, pEnd);\n    }\n    start = sqlite3VdbeCurrentAddr(v);\n    pLevel->op = bRev ? OP_Prev : OP_Next;\n    pLevel->p1 = iCur;\n    pLevel->p2 = start;\n    if( pStart==0 && pEnd==0 ){\n      pLevel->p5 = SQLITE_STMTSTATUS_FULLSCAN_STEP;\n    }else{\n      assert( pLevel->p5==0 );\n    }\n    if( testOp!=OP_Noop ){\n      iRowidReg = iReleaseReg = sqlite3GetTempReg(pParse);\n      sqlite3VdbeAddOp2(v, OP_Rowid, iCur, iRowidReg);\n      sqlite3ExprCacheStore(pParse, iCur, -1, iRowidReg);\n      sqlite3VdbeAddOp3(v, testOp, memEndValue, addrBrk, iRowidReg);\n      sqlite3VdbeChangeP5(v, SQLITE_AFF_NUMERIC | SQLITE_JUMPIFNULL);\n    }\n  }else if( pLevel->plan.wsFlags & (WHERE_COLUMN_RANGE|WHERE_COLUMN_EQ) ){\n    /* Case 3: A scan using an index.\n    **\n    **         The WHERE clause may contain zero or more equality \n    **         terms (\"==\" or \"IN\" operators) that refer to the N\n    **         left-most columns of the index. It may also contain\n    **         inequality constraints (>, <, >= or <=) on the indexed\n    **         column that immediately follows the N equalities. Only \n    **         the right-most column can be an inequality - the rest must\n    **         use the \"==\" and \"IN\" operators. For example, if the \n    **         index is on (x,y,z), then the following clauses are all \n    **         optimized:\n    **\n    **            x=5\n    **            x=5 AND y=10\n    **            x=5 AND y<10\n    **            x=5 AND y>5 AND y<10\n    **            x=5 AND y=5 AND z<=10\n    **\n    **         The z<10 term of the following cannot be used, only\n    **         the x=5 term:\n    **\n    **            x=5 AND z<10\n    **\n    **         N may be zero if there are inequality constraints.\n    **         If there are no inequality constraints, then N is at\n    **         least one.\n    **\n    **         This case is also used when there are no WHERE clause\n    **         constraints but an index is selected anyway, in order\n    **         to force the output order to conform to an ORDER BY.\n    */  \n    static const u8 aStartOp[] = {\n      0,\n      0,\n      OP_Rewind,           /* 2: (!start_constraints && startEq &&  !bRev) */\n      OP_Last,             /* 3: (!start_constraints && startEq &&   bRev) */\n      OP_SeekGt,           /* 4: (start_constraints  && !startEq && !bRev) */\n      OP_SeekLt,           /* 5: (start_constraints  && !startEq &&  bRev) */\n      OP_SeekGe,           /* 6: (start_constraints  &&  startEq && !bRev) */\n      OP_SeekLe            /* 7: (start_constraints  &&  startEq &&  bRev) */\n    };\n    static const u8 aEndOp[] = {\n      OP_Noop,             /* 0: (!end_constraints) */\n      OP_IdxGE,            /* 1: (end_constraints && !bRev) */\n      OP_IdxLT             /* 2: (end_constraints && bRev) */\n    };\n    int nEq = pLevel->plan.nEq;  /* Number of == or IN terms */\n    int isMinQuery = 0;          /* If this is an optimized SELECT min(x).. */\n    int regBase;                 /* Base register holding constraint values */\n    int r1;                      /* Temp register */\n    WhereTerm *pRangeStart = 0;  /* Inequality constraint at range start */\n    WhereTerm *pRangeEnd = 0;    /* Inequality constraint at range end */\n    int startEq;                 /* True if range start uses ==, >= or <= */\n    int endEq;                   /* True if range end uses ==, >= or <= */\n    int start_constraints;       /* Start of range is constrained */\n    int nConstraint;             /* Number of constraint terms */\n    Index *pIdx;                 /* The index we will be using */\n    int iIdxCur;                 /* The VDBE cursor for the index */\n    int nExtraReg = 0;           /* Number of extra registers needed */\n    int op;                      /* Instruction opcode */\n    char *zStartAff;             /* Affinity for start of range constraint */\n    char *zEndAff;               /* Affinity for end of range constraint */\n\n    pIdx = pLevel->plan.u.pIdx;\n    iIdxCur = pLevel->iIdxCur;\n    k = pIdx->aiColumn[nEq];     /* Column for inequality constraints */\n\n    /* If this loop satisfies a sort order (pOrderBy) request that \n    ** was passed to this function to implement a \"SELECT min(x) ...\" \n    ** query, then the caller will only allow the loop to run for\n    ** a single iteration. This means that the first row returned\n    ** should not have a NULL value stored in 'x'. If column 'x' is\n    ** the first one after the nEq equality constraints in the index,\n    ** this requires some special handling.\n    */\n    if( (wctrlFlags&WHERE_ORDERBY_MIN)!=0\n     && (pLevel->plan.wsFlags&WHERE_ORDERBY)\n     && (pIdx->nColumn>nEq)\n    ){\n      /* assert( pOrderBy->nExpr==1 ); */\n      /* assert( pOrderBy->a[0].pExpr->iColumn==pIdx->aiColumn[nEq] ); */\n      isMinQuery = 1;\n      nExtraReg = 1;\n    }\n\n    /* Find any inequality constraint terms for the start and end \n    ** of the range. \n    */\n    if( pLevel->plan.wsFlags & WHERE_TOP_LIMIT ){\n      pRangeEnd = findTerm(pWC, iCur, k, notReady, (WO_LT|WO_LE), pIdx);\n      nExtraReg = 1;\n    }\n    if( pLevel->plan.wsFlags & WHERE_BTM_LIMIT ){\n      pRangeStart = findTerm(pWC, iCur, k, notReady, (WO_GT|WO_GE), pIdx);\n      nExtraReg = 1;\n    }\n\n    /* Generate code to evaluate all constraint terms using == or IN\n    ** and store the values of those terms in an array of registers\n    ** starting at regBase.\n    */\n    regBase = codeAllEqualityTerms(\n        pParse, pLevel, pWC, notReady, nExtraReg, &zStartAff\n    );\n    zEndAff = sqlite3DbStrDup(pParse->db, zStartAff);\n    addrNxt = pLevel->addrNxt;\n\n    /* If we are doing a reverse order scan on an ascending index, or\n    ** a forward order scan on a descending index, interchange the \n    ** start and end terms (pRangeStart and pRangeEnd).\n    */\n    if( nEq<pIdx->nColumn && bRev==(pIdx->aSortOrder[nEq]==SQLITE_SO_ASC) ){\n      SWAP(WhereTerm *, pRangeEnd, pRangeStart);\n    }\n\n    testcase( pRangeStart && pRangeStart->eOperator & WO_LE );\n    testcase( pRangeStart && pRangeStart->eOperator & WO_GE );\n    testcase( pRangeEnd && pRangeEnd->eOperator & WO_LE );\n    testcase( pRangeEnd && pRangeEnd->eOperator & WO_GE );\n    startEq = !pRangeStart || pRangeStart->eOperator & (WO_LE|WO_GE);\n    endEq =   !pRangeEnd || pRangeEnd->eOperator & (WO_LE|WO_GE);\n    start_constraints = pRangeStart || nEq>0;\n\n    /* Seek the index cursor to the start of the range. */\n    nConstraint = nEq;\n    if( pRangeStart ){\n      Expr *pRight = pRangeStart->pExpr->pRight;\n      sqlite3ExprCode(pParse, pRight, regBase+nEq);\n      if( (pRangeStart->wtFlags & TERM_VNULL)==0 ){\n        sqlite3ExprCodeIsNullJump(v, pRight, regBase+nEq, addrNxt);\n      }\n      if( zStartAff ){\n        if( sqlite3CompareAffinity(pRight, zStartAff[nEq])==SQLITE_AFF_NONE){\n          /* Since the comparison is to be performed with no conversions\n          ** applied to the operands, set the affinity to apply to pRight to \n          ** SQLITE_AFF_NONE.  */\n          zStartAff[nEq] = SQLITE_AFF_NONE;\n        }\n        if( sqlite3ExprNeedsNoAffinityChange(pRight, zStartAff[nEq]) ){\n          zStartAff[nEq] = SQLITE_AFF_NONE;\n        }\n      }  \n      nConstraint++;\n      testcase( pRangeStart->wtFlags & TERM_VIRTUAL ); /* EV: R-30575-11662 */\n    }else if( isMinQuery ){\n      sqlite3VdbeAddOp2(v, OP_Null, 0, regBase+nEq);\n      nConstraint++;\n      startEq = 0;\n      start_constraints = 1;\n    }\n    codeApplyAffinity(pParse, regBase, nConstraint, zStartAff);\n    op = aStartOp[(start_constraints<<2) + (startEq<<1) + bRev];\n    assert( op!=0 );\n    testcase( op==OP_Rewind );\n    testcase( op==OP_Last );\n    testcase( op==OP_SeekGt );\n    testcase( op==OP_SeekGe );\n    testcase( op==OP_SeekLe );\n    testcase( op==OP_SeekLt );\n    sqlite3VdbeAddOp4Int(v, op, iIdxCur, addrNxt, regBase, nConstraint);\n\n    /* Load the value for the inequality constraint at the end of the\n    ** range (if any).\n    */\n    nConstraint = nEq;\n    if( pRangeEnd ){\n      Expr *pRight = pRangeEnd->pExpr->pRight;\n      sqlite3ExprCacheRemove(pParse, regBase+nEq, 1);\n      sqlite3ExprCode(pParse, pRight, regBase+nEq);\n      if( (pRangeEnd->wtFlags & TERM_VNULL)==0 ){\n        sqlite3ExprCodeIsNullJump(v, pRight, regBase+nEq, addrNxt);\n      }\n      if( zEndAff ){\n        if( sqlite3CompareAffinity(pRight, zEndAff[nEq])==SQLITE_AFF_NONE){\n          /* Since the comparison is to be performed with no conversions\n          ** applied to the operands, set the affinity to apply to pRight to \n          ** SQLITE_AFF_NONE.  */\n          zEndAff[nEq] = SQLITE_AFF_NONE;\n        }\n        if( sqlite3ExprNeedsNoAffinityChange(pRight, zEndAff[nEq]) ){\n          zEndAff[nEq] = SQLITE_AFF_NONE;\n        }\n      }  \n      codeApplyAffinity(pParse, regBase, nEq+1, zEndAff);\n      nConstraint++;\n      testcase( pRangeEnd->wtFlags & TERM_VIRTUAL ); /* EV: R-30575-11662 */\n    }\n    sqlite3DbFree(pParse->db, zStartAff);\n    sqlite3DbFree(pParse->db, zEndAff);\n\n    /* Top of the loop body */\n    pLevel->p2 = sqlite3VdbeCurrentAddr(v);\n\n    /* Check if the index cursor is past the end of the range. */\n    op = aEndOp[(pRangeEnd || nEq) * (1 + bRev)];\n    testcase( op==OP_Noop );\n    testcase( op==OP_IdxGE );\n    testcase( op==OP_IdxLT );\n    if( op!=OP_Noop ){\n      sqlite3VdbeAddOp4Int(v, op, iIdxCur, addrNxt, regBase, nConstraint);\n      sqlite3VdbeChangeP5(v, endEq!=bRev ?1:0);\n    }\n\n    /* If there are inequality constraints, check that the value\n    ** of the table column that the inequality contrains is not NULL.\n    ** If it is, jump to the next iteration of the loop.\n    */\n    r1 = sqlite3GetTempReg(pParse);\n    testcase( pLevel->plan.wsFlags & WHERE_BTM_LIMIT );\n    testcase( pLevel->plan.wsFlags & WHERE_TOP_LIMIT );\n    if( (pLevel->plan.wsFlags & (WHERE_BTM_LIMIT|WHERE_TOP_LIMIT))!=0 ){\n      sqlite3VdbeAddOp3(v, OP_Column, iIdxCur, nEq, r1);\n      sqlite3VdbeAddOp2(v, OP_IsNull, r1, addrCont);\n    }\n    sqlite3ReleaseTempReg(pParse, r1);\n\n    /* Seek the table cursor, if required */\n    disableTerm(pLevel, pRangeStart);\n    disableTerm(pLevel, pRangeEnd);\n    if( !omitTable ){\n      iRowidReg = iReleaseReg = sqlite3GetTempReg(pParse);\n      sqlite3VdbeAddOp2(v, OP_IdxRowid, iIdxCur, iRowidReg);\n      sqlite3ExprCacheStore(pParse, iCur, -1, iRowidReg);\n      sqlite3VdbeAddOp2(v, OP_Seek, iCur, iRowidReg);  /* Deferred seek */\n    }\n\n    /* Record the instruction used to terminate the loop. Disable \n    ** WHERE clause terms made redundant by the index range scan.\n    */\n    if( pLevel->plan.wsFlags & WHERE_UNIQUE ){\n      pLevel->op = OP_Noop;\n    }else if( bRev ){\n      pLevel->op = OP_Prev;\n    }else{\n      pLevel->op = OP_Next;\n    }\n    pLevel->p1 = iIdxCur;\n  }else\n\n#ifndef SQLITE_OMIT_OR_OPTIMIZATION\n  if( pLevel->plan.wsFlags & WHERE_MULTI_OR ){\n    /* Case 4:  Two or more separately indexed terms connected by OR\n    **\n    ** Example:\n    **\n    **   CREATE TABLE t1(a,b,c,d);\n    **   CREATE INDEX i1 ON t1(a);\n    **   CREATE INDEX i2 ON t1(b);\n    **   CREATE INDEX i3 ON t1(c);\n    **\n    **   SELECT * FROM t1 WHERE a=5 OR b=7 OR (c=11 AND d=13)\n    **\n    ** In the example, there are three indexed terms connected by OR.\n    ** The top of the loop looks like this:\n    **\n    **          Null       1                # Zero the rowset in reg 1\n    **\n    ** Then, for each indexed term, the following. The arguments to\n    ** RowSetTest are such that the rowid of the current row is inserted\n    ** into the RowSet. If it is already present, control skips the\n    ** Gosub opcode and jumps straight to the code generated by WhereEnd().\n    **\n    **        sqlite3WhereBegin(<term>)\n    **          RowSetTest                  # Insert rowid into rowset\n    **          Gosub      2 A\n    **        sqlite3WhereEnd()\n    **\n    ** Following the above, code to terminate the loop. Label A, the target\n    ** of the Gosub above, jumps to the instruction right after the Goto.\n    **\n    **          Null       1                # Zero the rowset in reg 1\n    **          Goto       B                # The loop is finished.\n    **\n    **       A: <loop body>                 # Return data, whatever.\n    **\n    **          Return     2                # Jump back to the Gosub\n    **\n    **       B: <after the loop>\n    **\n    */\n    WhereClause *pOrWc;    /* The OR-clause broken out into subterms */\n    SrcList *pOrTab;       /* Shortened table list or OR-clause generation */\n\n    int regReturn = ++pParse->nMem;           /* Register used with OP_Gosub */\n    int regRowset = 0;                        /* Register for RowSet object */\n    int regRowid = 0;                         /* Register holding rowid */\n    int iLoopBody = sqlite3VdbeMakeLabel(v);  /* Start of loop body */\n    int iRetInit;                             /* Address of regReturn init */\n    int untestedTerms = 0;             /* Some terms not completely tested */\n    int ii;\n   \n    pTerm = pLevel->plan.u.pTerm;\n    assert( pTerm!=0 );\n    assert( pTerm->eOperator==WO_OR );\n    assert( (pTerm->wtFlags & TERM_ORINFO)!=0 );\n    pOrWc = &pTerm->u.pOrInfo->wc;\n    pLevel->op = OP_Return;\n    pLevel->p1 = regReturn;\n\n    /* Set up a new SrcList ni pOrTab containing the table being scanned\n    ** by this loop in the a[0] slot and all notReady tables in a[1..] slots.\n    ** This becomes the SrcList in the recursive call to sqlite3WhereBegin().\n    */\n    if( pWInfo->nLevel>1 ){\n      int nNotReady;                 /* The number of notReady tables */\n      struct SrcList_item *origSrc;     /* Original list of tables */\n      nNotReady = pWInfo->nLevel - iLevel - 1;\n      pOrTab = sqlite3StackAllocRaw(pParse->db,\n                            sizeof(*pOrTab)+ nNotReady*sizeof(pOrTab->a[0]));\n      if( pOrTab==0 ) return notReady;\n      pOrTab->nAlloc = (i16)(nNotReady + 1);\n      pOrTab->nSrc = pOrTab->nAlloc;\n      memcpy(pOrTab->a, pTabItem, sizeof(*pTabItem));\n      origSrc = pWInfo->pTabList->a;\n      for(k=1; k<=nNotReady; k++){\n        memcpy(&pOrTab->a[k], &origSrc[pLevel[k].iFrom], sizeof(pOrTab->a[k]));\n      }\n    }else{\n      pOrTab = pWInfo->pTabList;\n    }\n\n    /* Initialize the rowset register to contain NULL. An SQL NULL is \n    ** equivalent to an empty rowset.\n    **\n    ** Also initialize regReturn to contain the address of the instruction \n    ** immediately following the OP_Return at the bottom of the loop. This\n    ** is required in a few obscure LEFT JOIN cases where control jumps\n    ** over the top of the loop into the body of it. In this case the \n    ** correct response for the end-of-loop code (the OP_Return) is to \n    ** fall through to the next instruction, just as an OP_Next does if\n    ** called on an uninitialized cursor.\n    */\n    if( (wctrlFlags & WHERE_DUPLICATES_OK)==0 ){\n      regRowset = ++pParse->nMem;\n      regRowid = ++pParse->nMem;\n      sqlite3VdbeAddOp2(v, OP_Null, 0, regRowset);\n    }\n    iRetInit = sqlite3VdbeAddOp2(v, OP_Integer, 0, regReturn);\n\n    for(ii=0; ii<pOrWc->nTerm; ii++){\n      WhereTerm *pOrTerm = &pOrWc->a[ii];\n      if( pOrTerm->leftCursor==iCur || pOrTerm->eOperator==WO_AND ){\n        WhereInfo *pSubWInfo;          /* Info for single OR-term scan */\n        /* Loop through table entries that match term pOrTerm. */\n        pSubWInfo = sqlite3WhereBegin(pParse, pOrTab, pOrTerm->pExpr, 0,\n                        WHERE_OMIT_OPEN | WHERE_OMIT_CLOSE |\n                        WHERE_FORCE_TABLE | WHERE_ONETABLE_ONLY);\n        if( pSubWInfo ){\n          explainOneScan(\n              pParse, pOrTab, &pSubWInfo->a[0], iLevel, pLevel->iFrom, 0\n          );\n          if( (wctrlFlags & WHERE_DUPLICATES_OK)==0 ){\n            int iSet = ((ii==pOrWc->nTerm-1)?-1:ii);\n            int r;\n            r = sqlite3ExprCodeGetColumn(pParse, pTabItem->pTab, -1, iCur, \n                                         regRowid);\n            sqlite3VdbeAddOp4Int(v, OP_RowSetTest, regRowset,\n                                 sqlite3VdbeCurrentAddr(v)+2, r, iSet);\n          }\n          sqlite3VdbeAddOp2(v, OP_Gosub, regReturn, iLoopBody);\n\n          /* The pSubWInfo->untestedTerms flag means that this OR term\n          ** contained one or more AND term from a notReady table.  The\n          ** terms from the notReady table could not be tested and will\n          ** need to be tested later.\n          */\n          if( pSubWInfo->untestedTerms ) untestedTerms = 1;\n\n          /* Finish the loop through table entries that match term pOrTerm. */\n          sqlite3WhereEnd(pSubWInfo);\n        }\n      }\n    }\n    sqlite3VdbeChangeP1(v, iRetInit, sqlite3VdbeCurrentAddr(v));\n    sqlite3VdbeAddOp2(v, OP_Goto, 0, pLevel->addrBrk);\n    sqlite3VdbeResolveLabel(v, iLoopBody);\n\n    if( pWInfo->nLevel>1 ) sqlite3StackFree(pParse->db, pOrTab);\n    if( !untestedTerms ) disableTerm(pLevel, pTerm);\n  }else\n#endif /* SQLITE_OMIT_OR_OPTIMIZATION */\n\n  {\n    /* Case 5:  There is no usable index.  We must do a complete\n    **          scan of the entire table.\n    */\n    static const u8 aStep[] = { OP_Next, OP_Prev };\n    static const u8 aStart[] = { OP_Rewind, OP_Last };\n    assert( bRev==0 || bRev==1 );\n    assert( omitTable==0 );\n    pLevel->op = aStep[bRev];\n    pLevel->p1 = iCur;\n    pLevel->p2 = 1 + sqlite3VdbeAddOp2(v, aStart[bRev], iCur, addrBrk);\n    pLevel->p5 = SQLITE_STMTSTATUS_FULLSCAN_STEP;\n  }\n  notReady &= ~getMask(pWC->pMaskSet, iCur);\n\n  /* Insert code to test every subexpression that can be completely\n  ** computed using the current set of tables.\n  **\n  ** IMPLEMENTATION-OF: R-49525-50935 Terms that cannot be satisfied through\n  ** the use of indices become tests that are evaluated against each row of\n  ** the relevant input tables.\n  */\n  for(pTerm=pWC->a, j=pWC->nTerm; j>0; j--, pTerm++){\n    Expr *pE;\n    testcase( pTerm->wtFlags & TERM_VIRTUAL ); /* IMP: R-30575-11662 */\n    testcase( pTerm->wtFlags & TERM_CODED );\n    if( pTerm->wtFlags & (TERM_VIRTUAL|TERM_CODED) ) continue;\n    if( (pTerm->prereqAll & notReady)!=0 ){\n      testcase( pWInfo->untestedTerms==0\n               && (pWInfo->wctrlFlags & WHERE_ONETABLE_ONLY)!=0 );\n      pWInfo->untestedTerms = 1;\n      continue;\n    }\n    pE = pTerm->pExpr;\n    assert( pE!=0 );\n    if( pLevel->iLeftJoin && !ExprHasProperty(pE, EP_FromJoin) ){\n      continue;\n    }\n    sqlite3ExprIfFalse(pParse, pE, addrCont, SQLITE_JUMPIFNULL);\n    pTerm->wtFlags |= TERM_CODED;\n  }\n\n  /* For a LEFT OUTER JOIN, generate code that will record the fact that\n  ** at least one row of the right table has matched the left table.  \n  */\n  if( pLevel->iLeftJoin ){\n    pLevel->addrFirst = sqlite3VdbeCurrentAddr(v);\n    sqlite3VdbeAddOp2(v, OP_Integer, 1, pLevel->iLeftJoin);\n    VdbeComment((v, \"record LEFT JOIN hit\"));\n    sqlite3ExprCacheClear(pParse);\n    for(pTerm=pWC->a, j=0; j<pWC->nTerm; j++, pTerm++){\n      testcase( pTerm->wtFlags & TERM_VIRTUAL );  /* IMP: R-30575-11662 */\n      testcase( pTerm->wtFlags & TERM_CODED );\n      if( pTerm->wtFlags & (TERM_VIRTUAL|TERM_CODED) ) continue;\n      if( (pTerm->prereqAll & notReady)!=0 ){\n        assert( pWInfo->untestedTerms );\n        continue;\n      }\n      assert( pTerm->pExpr );\n      sqlite3ExprIfFalse(pParse, pTerm->pExpr, addrCont, SQLITE_JUMPIFNULL);\n      pTerm->wtFlags |= TERM_CODED;\n    }\n  }\n  sqlite3ReleaseTempReg(pParse, iReleaseReg);\n\n  return notReady;\n}\n\n#if defined(SQLITE_TEST)\n/*\n** The following variable holds a text description of query plan generated\n** by the most recent call to sqlite3WhereBegin().  Each call to WhereBegin\n** overwrites the previous.  This information is used for testing and\n** analysis only.\n*/\nSQLITE_API char sqlite3_query_plan[BMS*2*40];  /* Text of the join */\nstatic int nQPlan = 0;              /* Next free slow in _query_plan[] */\n\n#endif /* SQLITE_TEST */\n\n\n/*\n** Free a WhereInfo structure\n*/\nstatic void whereInfoFree(sqlite3 *db, WhereInfo *pWInfo){\n  if( ALWAYS(pWInfo) ){\n    int i;\n    for(i=0; i<pWInfo->nLevel; i++){\n      sqlite3_index_info *pInfo = pWInfo->a[i].pIdxInfo;\n      if( pInfo ){\n        /* assert( pInfo->needToFreeIdxStr==0 || db->mallocFailed ); */\n        if( pInfo->needToFreeIdxStr ){\n          sqlite3_free(pInfo->idxStr);\n        }\n        sqlite3DbFree(db, pInfo);\n      }\n      if( pWInfo->a[i].plan.wsFlags & WHERE_TEMP_INDEX ){\n        Index *pIdx = pWInfo->a[i].plan.u.pIdx;\n        if( pIdx ){\n          sqlite3DbFree(db, pIdx->zColAff);\n          sqlite3DbFree(db, pIdx);\n        }\n      }\n    }\n    whereClauseClear(pWInfo->pWC);\n    sqlite3DbFree(db, pWInfo);\n  }\n}\n\n\n/*\n** Generate the beginning of the loop used for WHERE clause processing.\n** The return value is a pointer to an opaque structure that contains\n** information needed to terminate the loop.  Later, the calling routine\n** should invoke sqlite3WhereEnd() with the return value of this function\n** in order to complete the WHERE clause processing.\n**\n** If an error occurs, this routine returns NULL.\n**\n** The basic idea is to do a nested loop, one loop for each table in\n** the FROM clause of a select.  (INSERT and UPDATE statements are the\n** same as a SELECT with only a single table in the FROM clause.)  For\n** example, if the SQL is this:\n**\n**       SELECT * FROM t1, t2, t3 WHERE ...;\n**\n** Then the code generated is conceptually like the following:\n**\n**      foreach row1 in t1 do       \\    Code generated\n**        foreach row2 in t2 do      |-- by sqlite3WhereBegin()\n**          foreach row3 in t3 do   /\n**            ...\n**          end                     \\    Code generated\n**        end                        |-- by sqlite3WhereEnd()\n**      end                         /\n**\n** Note that the loops might not be nested in the order in which they\n** appear in the FROM clause if a different order is better able to make\n** use of indices.  Note also that when the IN operator appears in\n** the WHERE clause, it might result in additional nested loops for\n** scanning through all values on the right-hand side of the IN.\n**\n** There are Btree cursors associated with each table.  t1 uses cursor\n** number pTabList->a[0].iCursor.  t2 uses the cursor pTabList->a[1].iCursor.\n** And so forth.  This routine generates code to open those VDBE cursors\n** and sqlite3WhereEnd() generates the code to close them.\n**\n** The code that sqlite3WhereBegin() generates leaves the cursors named\n** in pTabList pointing at their appropriate entries.  The [...] code\n** can use OP_Column and OP_Rowid opcodes on these cursors to extract\n** data from the various tables of the loop.\n**\n** If the WHERE clause is empty, the foreach loops must each scan their\n** entire tables.  Thus a three-way join is an O(N^3) operation.  But if\n** the tables have indices and there are terms in the WHERE clause that\n** refer to those indices, a complete table scan can be avoided and the\n** code will run much faster.  Most of the work of this routine is checking\n** to see if there are indices that can be used to speed up the loop.\n**\n** Terms of the WHERE clause are also used to limit which rows actually\n** make it to the \"...\" in the middle of the loop.  After each \"foreach\",\n** terms of the WHERE clause that use only terms in that loop and outer\n** loops are evaluated and if false a jump is made around all subsequent\n** inner loops (or around the \"...\" if the test occurs within the inner-\n** most loop)\n**\n** OUTER JOINS\n**\n** An outer join of tables t1 and t2 is conceptally coded as follows:\n**\n**    foreach row1 in t1 do\n**      flag = 0\n**      foreach row2 in t2 do\n**        start:\n**          ...\n**          flag = 1\n**      end\n**      if flag==0 then\n**        move the row2 cursor to a null row\n**        goto start\n**      fi\n**    end\n**\n** ORDER BY CLAUSE PROCESSING\n**\n** *ppOrderBy is a pointer to the ORDER BY clause of a SELECT statement,\n** if there is one.  If there is no ORDER BY clause or if this routine\n** is called from an UPDATE or DELETE statement, then ppOrderBy is NULL.\n**\n** If an index can be used so that the natural output order of the table\n** scan is correct for the ORDER BY clause, then that index is used and\n** *ppOrderBy is set to NULL.  This is an optimization that prevents an\n** unnecessary sort of the result set if an index appropriate for the\n** ORDER BY clause already exists.\n**\n** If the where clause loops cannot be arranged to provide the correct\n** output order, then the *ppOrderBy is unchanged.\n*/\nSQLITE_PRIVATE WhereInfo *sqlite3WhereBegin(\n  Parse *pParse,        /* The parser context */\n  SrcList *pTabList,    /* A list of all tables to be scanned */\n  Expr *pWhere,         /* The WHERE clause */\n  ExprList **ppOrderBy, /* An ORDER BY clause, or NULL */\n  u16 wctrlFlags        /* One of the WHERE_* flags defined in sqliteInt.h */\n){\n  int i;                     /* Loop counter */\n  int nByteWInfo;            /* Num. bytes allocated for WhereInfo struct */\n  int nTabList;              /* Number of elements in pTabList */\n  WhereInfo *pWInfo;         /* Will become the return value of this function */\n  Vdbe *v = pParse->pVdbe;   /* The virtual database engine */\n  Bitmask notReady;          /* Cursors that are not yet positioned */\n  WhereMaskSet *pMaskSet;    /* The expression mask set */\n  WhereClause *pWC;               /* Decomposition of the WHERE clause */\n  struct SrcList_item *pTabItem;  /* A single entry from pTabList */\n  WhereLevel *pLevel;             /* A single level in the pWInfo list */\n  int iFrom;                      /* First unused FROM clause element */\n  int andFlags;              /* AND-ed combination of all pWC->a[].wtFlags */\n  sqlite3 *db;               /* Database connection */\n\n  /* The number of tables in the FROM clause is limited by the number of\n  ** bits in a Bitmask \n  */\n  testcase( pTabList->nSrc==BMS );\n  if( pTabList->nSrc>BMS ){\n    sqlite3ErrorMsg(pParse, \"at most %d tables in a join\", BMS);\n    return 0;\n  }\n\n  /* This function normally generates a nested loop for all tables in \n  ** pTabList.  But if the WHERE_ONETABLE_ONLY flag is set, then we should\n  ** only generate code for the first table in pTabList and assume that\n  ** any cursors associated with subsequent tables are uninitialized.\n  */\n  nTabList = (wctrlFlags & WHERE_ONETABLE_ONLY) ? 1 : pTabList->nSrc;\n\n  /* Allocate and initialize the WhereInfo structure that will become the\n  ** return value. A single allocation is used to store the WhereInfo\n  ** struct, the contents of WhereInfo.a[], the WhereClause structure\n  ** and the WhereMaskSet structure. Since WhereClause contains an 8-byte\n  ** field (type Bitmask) it must be aligned on an 8-byte boundary on\n  ** some architectures. Hence the ROUND8() below.\n  */\n  db = pParse->db;\n  nByteWInfo = ROUND8(sizeof(WhereInfo)+(nTabList-1)*sizeof(WhereLevel));\n  pWInfo = sqlite3DbMallocZero(db, \n      nByteWInfo + \n      sizeof(WhereClause) +\n      sizeof(WhereMaskSet)\n  );\n  if( db->mallocFailed ){\n    sqlite3DbFree(db, pWInfo);\n    pWInfo = 0;\n    goto whereBeginError;\n  }\n  pWInfo->nLevel = nTabList;\n  pWInfo->pParse = pParse;\n  pWInfo->pTabList = pTabList;\n  pWInfo->iBreak = sqlite3VdbeMakeLabel(v);\n  pWInfo->pWC = pWC = (WhereClause *)&((u8 *)pWInfo)[nByteWInfo];\n  pWInfo->wctrlFlags = wctrlFlags;\n  pWInfo->savedNQueryLoop = pParse->nQueryLoop;\n  pMaskSet = (WhereMaskSet*)&pWC[1];\n\n  /* Split the WHERE clause into separate subexpressions where each\n  ** subexpression is separated by an AND operator.\n  */\n  initMaskSet(pMaskSet);\n  whereClauseInit(pWC, pParse, pMaskSet);\n  sqlite3ExprCodeConstants(pParse, pWhere);\n  whereSplit(pWC, pWhere, TK_AND);   /* IMP: R-15842-53296 */\n    \n  /* Special case: a WHERE clause that is constant.  Evaluate the\n  ** expression and either jump over all of the code or fall thru.\n  */\n  if( pWhere && (nTabList==0 || sqlite3ExprIsConstantNotJoin(pWhere)) ){\n    sqlite3ExprIfFalse(pParse, pWhere, pWInfo->iBreak, SQLITE_JUMPIFNULL);\n    pWhere = 0;\n  }\n\n  /* Assign a bit from the bitmask to every term in the FROM clause.\n  **\n  ** When assigning bitmask values to FROM clause cursors, it must be\n  ** the case that if X is the bitmask for the N-th FROM clause term then\n  ** the bitmask for all FROM clause terms to the left of the N-th term\n  ** is (X-1).   An expression from the ON clause of a LEFT JOIN can use\n  ** its Expr.iRightJoinTable value to find the bitmask of the right table\n  ** of the join.  Subtracting one from the right table bitmask gives a\n  ** bitmask for all tables to the left of the join.  Knowing the bitmask\n  ** for all tables to the left of a left join is important.  Ticket #3015.\n  **\n  ** Configure the WhereClause.vmask variable so that bits that correspond\n  ** to virtual table cursors are set. This is used to selectively disable \n  ** the OR-to-IN transformation in exprAnalyzeOrTerm(). It is not helpful \n  ** with virtual tables.\n  **\n  ** Note that bitmasks are created for all pTabList->nSrc tables in\n  ** pTabList, not just the first nTabList tables.  nTabList is normally\n  ** equal to pTabList->nSrc but might be shortened to 1 if the\n  ** WHERE_ONETABLE_ONLY flag is set.\n  */\n  assert( pWC->vmask==0 && pMaskSet->n==0 );\n  for(i=0; i<pTabList->nSrc; i++){\n    createMask(pMaskSet, pTabList->a[i].iCursor);\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n    if( ALWAYS(pTabList->a[i].pTab) && IsVirtual(pTabList->a[i].pTab) ){\n      pWC->vmask |= ((Bitmask)1 << i);\n    }\n#endif\n  }\n#ifndef NDEBUG\n  {\n    Bitmask toTheLeft = 0;\n    for(i=0; i<pTabList->nSrc; i++){\n      Bitmask m = getMask(pMaskSet, pTabList->a[i].iCursor);\n      assert( (m-1)==toTheLeft );\n      toTheLeft |= m;\n    }\n  }\n#endif\n\n  /* Analyze all of the subexpressions.  Note that exprAnalyze() might\n  ** add new virtual terms onto the end of the WHERE clause.  We do not\n  ** want to analyze these virtual terms, so start analyzing at the end\n  ** and work forward so that the added virtual terms are never processed.\n  */\n  exprAnalyzeAll(pTabList, pWC);\n  if( db->mallocFailed ){\n    goto whereBeginError;\n  }\n\n  /* Chose the best index to use for each table in the FROM clause.\n  **\n  ** This loop fills in the following fields:\n  **\n  **   pWInfo->a[].pIdx      The index to use for this level of the loop.\n  **   pWInfo->a[].wsFlags   WHERE_xxx flags associated with pIdx\n  **   pWInfo->a[].nEq       The number of == and IN constraints\n  **   pWInfo->a[].iFrom     Which term of the FROM clause is being coded\n  **   pWInfo->a[].iTabCur   The VDBE cursor for the database table\n  **   pWInfo->a[].iIdxCur   The VDBE cursor for the index\n  **   pWInfo->a[].pTerm     When wsFlags==WO_OR, the OR-clause term\n  **\n  ** This loop also figures out the nesting order of tables in the FROM\n  ** clause.\n  */\n  notReady = ~(Bitmask)0;\n  andFlags = ~0;\n  WHERETRACE((\"*** Optimizer Start ***\\n\"));\n  for(i=iFrom=0, pLevel=pWInfo->a; i<nTabList; i++, pLevel++){\n    WhereCost bestPlan;         /* Most efficient plan seen so far */\n    Index *pIdx;                /* Index for FROM table at pTabItem */\n    int j;                      /* For looping over FROM tables */\n    int bestJ = -1;             /* The value of j */\n    Bitmask m;                  /* Bitmask value for j or bestJ */\n    int isOptimal;              /* Iterator for optimal/non-optimal search */\n    int nUnconstrained;         /* Number tables without INDEXED BY */\n    Bitmask notIndexed;         /* Mask of tables that cannot use an index */\n\n    memset(&bestPlan, 0, sizeof(bestPlan));\n    bestPlan.rCost = SQLITE_BIG_DBL;\n    WHERETRACE((\"*** Begin search for loop %d ***\\n\", i));\n\n    /* Loop through the remaining entries in the FROM clause to find the\n    ** next nested loop. The loop tests all FROM clause entries\n    ** either once or twice. \n    **\n    ** The first test is always performed if there are two or more entries\n    ** remaining and never performed if there is only one FROM clause entry\n    ** to choose from.  The first test looks for an \"optimal\" scan.  In\n    ** this context an optimal scan is one that uses the same strategy\n    ** for the given FROM clause entry as would be selected if the entry\n    ** were used as the innermost nested loop.  In other words, a table\n    ** is chosen such that the cost of running that table cannot be reduced\n    ** by waiting for other tables to run first.  This \"optimal\" test works\n    ** by first assuming that the FROM clause is on the inner loop and finding\n    ** its query plan, then checking to see if that query plan uses any\n    ** other FROM clause terms that are notReady.  If no notReady terms are\n    ** used then the \"optimal\" query plan works.\n    **\n    ** Note that the WhereCost.nRow parameter for an optimal scan might\n    ** not be as small as it would be if the table really were the innermost\n    ** join.  The nRow value can be reduced by WHERE clause constraints\n    ** that do not use indices.  But this nRow reduction only happens if the\n    ** table really is the innermost join.  \n    **\n    ** The second loop iteration is only performed if no optimal scan\n    ** strategies were found by the first iteration. This second iteration\n    ** is used to search for the lowest cost scan overall.\n    **\n    ** Previous versions of SQLite performed only the second iteration -\n    ** the next outermost loop was always that with the lowest overall\n    ** cost. However, this meant that SQLite could select the wrong plan\n    ** for scripts such as the following:\n    **   \n    **   CREATE TABLE t1(a, b); \n    **   CREATE TABLE t2(c, d);\n    **   SELECT * FROM t2, t1 WHERE t2.rowid = t1.a;\n    **\n    ** The best strategy is to iterate through table t1 first. However it\n    ** is not possible to determine this with a simple greedy algorithm.\n    ** Since the cost of a linear scan through table t2 is the same \n    ** as the cost of a linear scan through table t1, a simple greedy \n    ** algorithm may choose to use t2 for the outer loop, which is a much\n    ** costlier approach.\n    */\n    nUnconstrained = 0;\n    notIndexed = 0;\n    for(isOptimal=(iFrom<nTabList-1); isOptimal>=0 && bestJ<0; isOptimal--){\n      Bitmask mask;             /* Mask of tables not yet ready */\n      for(j=iFrom, pTabItem=&pTabList->a[j]; j<nTabList; j++, pTabItem++){\n        int doNotReorder;    /* True if this table should not be reordered */\n        WhereCost sCost;     /* Cost information from best[Virtual]Index() */\n        ExprList *pOrderBy;  /* ORDER BY clause for index to optimize */\n  \n        doNotReorder =  (pTabItem->jointype & (JT_LEFT|JT_CROSS))!=0;\n        if( j!=iFrom && doNotReorder ) break;\n        m = getMask(pMaskSet, pTabItem->iCursor);\n        if( (m & notReady)==0 ){\n          if( j==iFrom ) iFrom++;\n          continue;\n        }\n        mask = (isOptimal ? m : notReady);\n        pOrderBy = ((i==0 && ppOrderBy )?*ppOrderBy:0);\n        if( pTabItem->pIndex==0 ) nUnconstrained++;\n  \n        WHERETRACE((\"=== trying table %d with isOptimal=%d ===\\n\",\n                    j, isOptimal));\n        assert( pTabItem->pTab );\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n        if( IsVirtual(pTabItem->pTab) ){\n          sqlite3_index_info **pp = &pWInfo->a[j].pIdxInfo;\n          bestVirtualIndex(pParse, pWC, pTabItem, mask, notReady, pOrderBy,\n                           &sCost, pp);\n        }else \n#endif\n        {\n          bestBtreeIndex(pParse, pWC, pTabItem, mask, notReady, pOrderBy,\n                         &sCost);\n        }\n        assert( isOptimal || (sCost.used&notReady)==0 );\n\n        /* If an INDEXED BY clause is present, then the plan must use that\n        ** index if it uses any index at all */\n        assert( pTabItem->pIndex==0 \n                  || (sCost.plan.wsFlags & WHERE_NOT_FULLSCAN)==0\n                  || sCost.plan.u.pIdx==pTabItem->pIndex );\n\n        if( isOptimal && (sCost.plan.wsFlags & WHERE_NOT_FULLSCAN)==0 ){\n          notIndexed |= m;\n        }\n\n        /* Conditions under which this table becomes the best so far:\n        **\n        **   (1) The table must not depend on other tables that have not\n        **       yet run.\n        **\n        **   (2) A full-table-scan plan cannot supercede indexed plan unless\n        **       the full-table-scan is an \"optimal\" plan as defined above.\n        **\n        **   (3) All tables have an INDEXED BY clause or this table lacks an\n        **       INDEXED BY clause or this table uses the specific\n        **       index specified by its INDEXED BY clause.  This rule ensures\n        **       that a best-so-far is always selected even if an impossible\n        **       combination of INDEXED BY clauses are given.  The error\n        **       will be detected and relayed back to the application later.\n        **       The NEVER() comes about because rule (2) above prevents\n        **       An indexable full-table-scan from reaching rule (3).\n        **\n        **   (4) The plan cost must be lower than prior plans or else the\n        **       cost must be the same and the number of rows must be lower.\n        */\n        if( (sCost.used&notReady)==0                       /* (1) */\n            && (bestJ<0 || (notIndexed&m)!=0               /* (2) */\n                || (bestPlan.plan.wsFlags & WHERE_NOT_FULLSCAN)==0\n                || (sCost.plan.wsFlags & WHERE_NOT_FULLSCAN)!=0)\n            && (nUnconstrained==0 || pTabItem->pIndex==0   /* (3) */\n                || NEVER((sCost.plan.wsFlags & WHERE_NOT_FULLSCAN)!=0))\n            && (bestJ<0 || sCost.rCost<bestPlan.rCost      /* (4) */\n                || (sCost.rCost<=bestPlan.rCost \n                 && sCost.plan.nRow<bestPlan.plan.nRow))\n        ){\n          WHERETRACE((\"=== table %d is best so far\"\n                      \" with cost=%g and nRow=%g\\n\",\n                      j, sCost.rCost, sCost.plan.nRow));\n          bestPlan = sCost;\n          bestJ = j;\n        }\n        if( doNotReorder ) break;\n      }\n    }\n    assert( bestJ>=0 );\n    assert( notReady & getMask(pMaskSet, pTabList->a[bestJ].iCursor) );\n    WHERETRACE((\"*** Optimizer selects table %d for loop %d\"\n                \" with cost=%g and nRow=%g\\n\",\n                bestJ, pLevel-pWInfo->a, bestPlan.rCost, bestPlan.plan.nRow));\n    if( (bestPlan.plan.wsFlags & WHERE_ORDERBY)!=0 ){\n      *ppOrderBy = 0;\n    }\n    andFlags &= bestPlan.plan.wsFlags;\n    pLevel->plan = bestPlan.plan;\n    testcase( bestPlan.plan.wsFlags & WHERE_INDEXED );\n    testcase( bestPlan.plan.wsFlags & WHERE_TEMP_INDEX );\n    if( bestPlan.plan.wsFlags & (WHERE_INDEXED|WHERE_TEMP_INDEX) ){\n      pLevel->iIdxCur = pParse->nTab++;\n    }else{\n      pLevel->iIdxCur = -1;\n    }\n    notReady &= ~getMask(pMaskSet, pTabList->a[bestJ].iCursor);\n    pLevel->iFrom = (u8)bestJ;\n    if( bestPlan.plan.nRow>=(double)1 ){\n      pParse->nQueryLoop *= bestPlan.plan.nRow;\n    }\n\n    /* Check that if the table scanned by this loop iteration had an\n    ** INDEXED BY clause attached to it, that the named index is being\n    ** used for the scan. If not, then query compilation has failed.\n    ** Return an error.\n    */\n    pIdx = pTabList->a[bestJ].pIndex;\n    if( pIdx ){\n      if( (bestPlan.plan.wsFlags & WHERE_INDEXED)==0 ){\n        sqlite3ErrorMsg(pParse, \"cannot use index: %s\", pIdx->zName);\n        goto whereBeginError;\n      }else{\n        /* If an INDEXED BY clause is used, the bestIndex() function is\n        ** guaranteed to find the index specified in the INDEXED BY clause\n        ** if it find an index at all. */\n        assert( bestPlan.plan.u.pIdx==pIdx );\n      }\n    }\n  }\n  WHERETRACE((\"*** Optimizer Finished ***\\n\"));\n  if( pParse->nErr || db->mallocFailed ){\n    goto whereBeginError;\n  }\n\n  /* If the total query only selects a single row, then the ORDER BY\n  ** clause is irrelevant.\n  */\n  if( (andFlags & WHERE_UNIQUE)!=0 && ppOrderBy ){\n    *ppOrderBy = 0;\n  }\n\n  /* If the caller is an UPDATE or DELETE statement that is requesting\n  ** to use a one-pass algorithm, determine if this is appropriate.\n  ** The one-pass algorithm only works if the WHERE clause constraints\n  ** the statement to update a single row.\n  */\n  assert( (wctrlFlags & WHERE_ONEPASS_DESIRED)==0 || pWInfo->nLevel==1 );\n  if( (wctrlFlags & WHERE_ONEPASS_DESIRED)!=0 && (andFlags & WHERE_UNIQUE)!=0 ){\n    pWInfo->okOnePass = 1;\n    pWInfo->a[0].plan.wsFlags &= ~WHERE_IDX_ONLY;\n  }\n\n  /* Open all tables in the pTabList and any indices selected for\n  ** searching those tables.\n  */\n  sqlite3CodeVerifySchema(pParse, -1); /* Insert the cookie verifier Goto */\n  notReady = ~(Bitmask)0;\n  pWInfo->nRowOut = (double)1;\n  for(i=0, pLevel=pWInfo->a; i<nTabList; i++, pLevel++){\n    Table *pTab;     /* Table to open */\n    int iDb;         /* Index of database containing table/index */\n\n    pTabItem = &pTabList->a[pLevel->iFrom];\n    pTab = pTabItem->pTab;\n    pLevel->iTabCur = pTabItem->iCursor;\n    pWInfo->nRowOut *= pLevel->plan.nRow;\n    iDb = sqlite3SchemaToIndex(db, pTab->pSchema);\n    if( (pTab->tabFlags & TF_Ephemeral)!=0 || pTab->pSelect ){\n      /* Do nothing */\n    }else\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n    if( (pLevel->plan.wsFlags & WHERE_VIRTUALTABLE)!=0 ){\n      const char *pVTab = (const char *)sqlite3GetVTable(db, pTab);\n      int iCur = pTabItem->iCursor;\n      sqlite3VdbeAddOp4(v, OP_VOpen, iCur, 0, 0, pVTab, P4_VTAB);\n    }else\n#endif\n    if( (pLevel->plan.wsFlags & WHERE_IDX_ONLY)==0\n         && (wctrlFlags & WHERE_OMIT_OPEN)==0 ){\n      int op = pWInfo->okOnePass ? OP_OpenWrite : OP_OpenRead;\n      sqlite3OpenTable(pParse, pTabItem->iCursor, iDb, pTab, op);\n      testcase( pTab->nCol==BMS-1 );\n      testcase( pTab->nCol==BMS );\n      if( !pWInfo->okOnePass && pTab->nCol<BMS ){\n        Bitmask b = pTabItem->colUsed;\n        int n = 0;\n        for(; b; b=b>>1, n++){}\n        sqlite3VdbeChangeP4(v, sqlite3VdbeCurrentAddr(v)-1, \n                            SQLITE_INT_TO_PTR(n), P4_INT32);\n        assert( n<=pTab->nCol );\n      }\n    }else{\n      sqlite3TableLock(pParse, iDb, pTab->tnum, 0, pTab->zName);\n    }\n#ifndef SQLITE_OMIT_AUTOMATIC_INDEX\n    if( (pLevel->plan.wsFlags & WHERE_TEMP_INDEX)!=0 ){\n      constructAutomaticIndex(pParse, pWC, pTabItem, notReady, pLevel);\n    }else\n#endif\n    if( (pLevel->plan.wsFlags & WHERE_INDEXED)!=0 ){\n      Index *pIx = pLevel->plan.u.pIdx;\n      KeyInfo *pKey = sqlite3IndexKeyinfo(pParse, pIx);\n      int iIdxCur = pLevel->iIdxCur;\n      assert( pIx->pSchema==pTab->pSchema );\n      assert( iIdxCur>=0 );\n      sqlite3VdbeAddOp4(v, OP_OpenRead, iIdxCur, pIx->tnum, iDb,\n                        (char*)pKey, P4_KEYINFO_HANDOFF);\n      VdbeComment((v, \"%s\", pIx->zName));\n    }\n    sqlite3CodeVerifySchema(pParse, iDb);\n    notReady &= ~getMask(pWC->pMaskSet, pTabItem->iCursor);\n  }\n  pWInfo->iTop = sqlite3VdbeCurrentAddr(v);\n  if( db->mallocFailed ) goto whereBeginError;\n\n  /* Generate the code to do the search.  Each iteration of the for\n  ** loop below generates code for a single nested loop of the VM\n  ** program.\n  */\n  notReady = ~(Bitmask)0;\n  for(i=0; i<nTabList; i++){\n    pLevel = &pWInfo->a[i];\n    explainOneScan(pParse, pTabList, pLevel, i, pLevel->iFrom, wctrlFlags);\n    notReady = codeOneLoopStart(pWInfo, i, wctrlFlags, notReady);\n    pWInfo->iContinue = pLevel->addrCont;\n  }\n\n#ifdef SQLITE_TEST  /* For testing and debugging use only */\n  /* Record in the query plan information about the current table\n  ** and the index used to access it (if any).  If the table itself\n  ** is not used, its name is just '{}'.  If no index is used\n  ** the index is listed as \"{}\".  If the primary key is used the\n  ** index name is '*'.\n  */\n  for(i=0; i<nTabList; i++){\n    char *z;\n    int n;\n    pLevel = &pWInfo->a[i];\n    pTabItem = &pTabList->a[pLevel->iFrom];\n    z = pTabItem->zAlias;\n    if( z==0 ) z = pTabItem->pTab->zName;\n    n = sqlite3Strlen30(z);\n    if( n+nQPlan < sizeof(sqlite3_query_plan)-10 ){\n      if( pLevel->plan.wsFlags & WHERE_IDX_ONLY ){\n        memcpy(&sqlite3_query_plan[nQPlan], \"{}\", 2);\n        nQPlan += 2;\n      }else{\n        memcpy(&sqlite3_query_plan[nQPlan], z, n);\n        nQPlan += n;\n      }\n      sqlite3_query_plan[nQPlan++] = ' ';\n    }\n    testcase( pLevel->plan.wsFlags & WHERE_ROWID_EQ );\n    testcase( pLevel->plan.wsFlags & WHERE_ROWID_RANGE );\n    if( pLevel->plan.wsFlags & (WHERE_ROWID_EQ|WHERE_ROWID_RANGE) ){\n      memcpy(&sqlite3_query_plan[nQPlan], \"* \", 2);\n      nQPlan += 2;\n    }else if( (pLevel->plan.wsFlags & WHERE_INDEXED)!=0 ){\n      n = sqlite3Strlen30(pLevel->plan.u.pIdx->zName);\n      if( n+nQPlan < sizeof(sqlite3_query_plan)-2 ){\n        memcpy(&sqlite3_query_plan[nQPlan], pLevel->plan.u.pIdx->zName, n);\n        nQPlan += n;\n        sqlite3_query_plan[nQPlan++] = ' ';\n      }\n    }else{\n      memcpy(&sqlite3_query_plan[nQPlan], \"{} \", 3);\n      nQPlan += 3;\n    }\n  }\n  while( nQPlan>0 && sqlite3_query_plan[nQPlan-1]==' ' ){\n    sqlite3_query_plan[--nQPlan] = 0;\n  }\n  sqlite3_query_plan[nQPlan] = 0;\n  nQPlan = 0;\n#endif /* SQLITE_TEST // Testing and debugging use only */\n\n  /* Record the continuation address in the WhereInfo structure.  Then\n  ** clean up and return.\n  */\n  return pWInfo;\n\n  /* Jump here if malloc fails */\nwhereBeginError:\n  if( pWInfo ){\n    pParse->nQueryLoop = pWInfo->savedNQueryLoop;\n    whereInfoFree(db, pWInfo);\n  }\n  return 0;\n}\n\n/*\n** Generate the end of the WHERE loop.  See comments on \n** sqlite3WhereBegin() for additional information.\n*/\nSQLITE_PRIVATE void sqlite3WhereEnd(WhereInfo *pWInfo){\n  Parse *pParse = pWInfo->pParse;\n  Vdbe *v = pParse->pVdbe;\n  int i;\n  WhereLevel *pLevel;\n  SrcList *pTabList = pWInfo->pTabList;\n  sqlite3 *db = pParse->db;\n\n  /* Generate loop termination code.\n  */\n  sqlite3ExprCacheClear(pParse);\n  for(i=pWInfo->nLevel-1; i>=0; i--){\n    pLevel = &pWInfo->a[i];\n    sqlite3VdbeResolveLabel(v, pLevel->addrCont);\n    if( pLevel->op!=OP_Noop ){\n      sqlite3VdbeAddOp2(v, pLevel->op, pLevel->p1, pLevel->p2);\n      sqlite3VdbeChangeP5(v, pLevel->p5);\n    }\n    if( pLevel->plan.wsFlags & WHERE_IN_ABLE && pLevel->u.in.nIn>0 ){\n      struct InLoop *pIn;\n      int j;\n      sqlite3VdbeResolveLabel(v, pLevel->addrNxt);\n      for(j=pLevel->u.in.nIn, pIn=&pLevel->u.in.aInLoop[j-1]; j>0; j--, pIn--){\n        sqlite3VdbeJumpHere(v, pIn->addrInTop+1);\n        sqlite3VdbeAddOp2(v, OP_Next, pIn->iCur, pIn->addrInTop);\n        sqlite3VdbeJumpHere(v, pIn->addrInTop-1);\n      }\n      sqlite3DbFree(db, pLevel->u.in.aInLoop);\n    }\n    sqlite3VdbeResolveLabel(v, pLevel->addrBrk);\n    if( pLevel->iLeftJoin ){\n      int addr;\n      addr = sqlite3VdbeAddOp1(v, OP_IfPos, pLevel->iLeftJoin);\n      assert( (pLevel->plan.wsFlags & WHERE_IDX_ONLY)==0\n           || (pLevel->plan.wsFlags & WHERE_INDEXED)!=0 );\n      if( (pLevel->plan.wsFlags & WHERE_IDX_ONLY)==0 ){\n        sqlite3VdbeAddOp1(v, OP_NullRow, pTabList->a[i].iCursor);\n      }\n      if( pLevel->iIdxCur>=0 ){\n        sqlite3VdbeAddOp1(v, OP_NullRow, pLevel->iIdxCur);\n      }\n      if( pLevel->op==OP_Return ){\n        sqlite3VdbeAddOp2(v, OP_Gosub, pLevel->p1, pLevel->addrFirst);\n      }else{\n        sqlite3VdbeAddOp2(v, OP_Goto, 0, pLevel->addrFirst);\n      }\n      sqlite3VdbeJumpHere(v, addr);\n    }\n  }\n\n  /* The \"break\" point is here, just past the end of the outer loop.\n  ** Set it.\n  */\n  sqlite3VdbeResolveLabel(v, pWInfo->iBreak);\n\n  /* Close all of the cursors that were opened by sqlite3WhereBegin.\n  */\n  assert( pWInfo->nLevel==1 || pWInfo->nLevel==pTabList->nSrc );\n  for(i=0, pLevel=pWInfo->a; i<pWInfo->nLevel; i++, pLevel++){\n    struct SrcList_item *pTabItem = &pTabList->a[pLevel->iFrom];\n    Table *pTab = pTabItem->pTab;\n    assert( pTab!=0 );\n    if( (pTab->tabFlags & TF_Ephemeral)==0\n     && pTab->pSelect==0\n     && (pWInfo->wctrlFlags & WHERE_OMIT_CLOSE)==0\n    ){\n      int ws = pLevel->plan.wsFlags;\n      if( !pWInfo->okOnePass && (ws & WHERE_IDX_ONLY)==0 ){\n        sqlite3VdbeAddOp1(v, OP_Close, pTabItem->iCursor);\n      }\n      if( (ws & WHERE_INDEXED)!=0 && (ws & WHERE_TEMP_INDEX)==0 ){\n        sqlite3VdbeAddOp1(v, OP_Close, pLevel->iIdxCur);\n      }\n    }\n\n    /* If this scan uses an index, make code substitutions to read data\n    ** from the index in preference to the table. Sometimes, this means\n    ** the table need never be read from. This is a performance boost,\n    ** as the vdbe level waits until the table is read before actually\n    ** seeking the table cursor to the record corresponding to the current\n    ** position in the index.\n    ** \n    ** Calls to the code generator in between sqlite3WhereBegin and\n    ** sqlite3WhereEnd will have created code that references the table\n    ** directly.  This loop scans all that code looking for opcodes\n    ** that reference the table and converts them into opcodes that\n    ** reference the index.\n    */\n    if( (pLevel->plan.wsFlags & WHERE_INDEXED)!=0 && !db->mallocFailed){\n      int k, j, last;\n      VdbeOp *pOp;\n      Index *pIdx = pLevel->plan.u.pIdx;\n\n      assert( pIdx!=0 );\n      pOp = sqlite3VdbeGetOp(v, pWInfo->iTop);\n      last = sqlite3VdbeCurrentAddr(v);\n      for(k=pWInfo->iTop; k<last; k++, pOp++){\n        if( pOp->p1!=pLevel->iTabCur ) continue;\n        if( pOp->opcode==OP_Column ){\n          for(j=0; j<pIdx->nColumn; j++){\n            if( pOp->p2==pIdx->aiColumn[j] ){\n              pOp->p2 = j;\n              pOp->p1 = pLevel->iIdxCur;\n              break;\n            }\n          }\n          assert( (pLevel->plan.wsFlags & WHERE_IDX_ONLY)==0\n               || j<pIdx->nColumn );\n        }else if( pOp->opcode==OP_Rowid ){\n          pOp->p1 = pLevel->iIdxCur;\n          pOp->opcode = OP_IdxRowid;\n        }\n      }\n    }\n  }\n\n  /* Final cleanup\n  */\n  pParse->nQueryLoop = pWInfo->savedNQueryLoop;\n  whereInfoFree(db, pWInfo);\n  return;\n}\n\n/************** End of where.c ***********************************************/\n/************** Begin file parse.c *******************************************/\n/* Driver template for the LEMON parser generator.\n** The author disclaims copyright to this source code.\n**\n** This version of \"lempar.c\" is modified, slightly, for use by SQLite.\n** The only modifications are the addition of a couple of NEVER()\n** macros to disable tests that are needed in the case of a general\n** LALR(1) grammar but which are always false in the\n** specific grammar used by SQLite.\n*/\n/* First off, code is included that follows the \"include\" declaration\n** in the input grammar file. */\n\n\n/*\n** Disable all error recovery processing in the parser push-down\n** automaton.\n*/\n#define YYNOERRORRECOVERY 1\n\n/*\n** Make yytestcase() the same as testcase()\n*/\n#define yytestcase(X) testcase(X)\n\n/*\n** An instance of this structure holds information about the\n** LIMIT clause of a SELECT statement.\n*/\nstruct LimitVal {\n  Expr *pLimit;    /* The LIMIT expression.  NULL if there is no limit */\n  Expr *pOffset;   /* The OFFSET expression.  NULL if there is none */\n};\n\n/*\n** An instance of this structure is used to store the LIKE,\n** GLOB, NOT LIKE, and NOT GLOB operators.\n*/\nstruct LikeOp {\n  Token eOperator;  /* \"like\" or \"glob\" or \"regexp\" */\n  int not;         /* True if the NOT keyword is present */\n};\n\n/*\n** An instance of the following structure describes the event of a\n** TRIGGER.  \"a\" is the event type, one of TK_UPDATE, TK_INSERT,\n** TK_DELETE, or TK_INSTEAD.  If the event is of the form\n**\n**      UPDATE ON (a,b,c)\n**\n** Then the \"b\" IdList records the list \"a,b,c\".\n*/\nstruct TrigEvent { int a; IdList * b; };\n\n/*\n** An instance of this structure holds the ATTACH key and the key type.\n*/\nstruct AttachKey { int type;  Token key; };\n\n\n  /* This is a utility routine used to set the ExprSpan.zStart and\n  ** ExprSpan.zEnd values of pOut so that the span covers the complete\n  ** range of text beginning with pStart and going to the end of pEnd.\n  */\n  static void spanSet(ExprSpan *pOut, Token *pStart, Token *pEnd){\n    pOut->zStart = pStart->z;\n    pOut->zEnd = &pEnd->z[pEnd->n];\n  }\n\n  /* Construct a new Expr object from a single identifier.  Use the\n  ** new Expr to populate pOut.  Set the span of pOut to be the identifier\n  ** that created the expression.\n  */\n  static void spanExpr(ExprSpan *pOut, Parse *pParse, int op, Token *pValue){\n    pOut->pExpr = sqlite3PExpr(pParse, op, 0, 0, pValue);\n    pOut->zStart = pValue->z;\n    pOut->zEnd = &pValue->z[pValue->n];\n  }\n\n  /* This routine constructs a binary expression node out of two ExprSpan\n  ** objects and uses the result to populate a new ExprSpan object.\n  */\n  static void spanBinaryExpr(\n    ExprSpan *pOut,     /* Write the result here */\n    Parse *pParse,      /* The parsing context.  Errors accumulate here */\n    int op,             /* The binary operation */\n    ExprSpan *pLeft,    /* The left operand */\n    ExprSpan *pRight    /* The right operand */\n  ){\n    pOut->pExpr = sqlite3PExpr(pParse, op, pLeft->pExpr, pRight->pExpr, 0);\n    pOut->zStart = pLeft->zStart;\n    pOut->zEnd = pRight->zEnd;\n  }\n\n  /* Construct an expression node for a unary postfix operator\n  */\n  static void spanUnaryPostfix(\n    ExprSpan *pOut,        /* Write the new expression node here */\n    Parse *pParse,         /* Parsing context to record errors */\n    int op,                /* The operator */\n    ExprSpan *pOperand,    /* The operand */\n    Token *pPostOp         /* The operand token for setting the span */\n  ){\n    pOut->pExpr = sqlite3PExpr(pParse, op, pOperand->pExpr, 0, 0);\n    pOut->zStart = pOperand->zStart;\n    pOut->zEnd = &pPostOp->z[pPostOp->n];\n  }                           \n\n  /* A routine to convert a binary TK_IS or TK_ISNOT expression into a\n  ** unary TK_ISNULL or TK_NOTNULL expression. */\n  static void binaryToUnaryIfNull(Parse *pParse, Expr *pY, Expr *pA, int op){\n    sqlite3 *db = pParse->db;\n    if( db->mallocFailed==0 && pY->op==TK_NULL ){\n      pA->op = (u8)op;\n      sqlite3ExprDelete(db, pA->pRight);\n      pA->pRight = 0;\n    }\n  }\n\n  /* Construct an expression node for a unary prefix operator\n  */\n  static void spanUnaryPrefix(\n    ExprSpan *pOut,        /* Write the new expression node here */\n    Parse *pParse,         /* Parsing context to record errors */\n    int op,                /* The operator */\n    ExprSpan *pOperand,    /* The operand */\n    Token *pPreOp         /* The operand token for setting the span */\n  ){\n    pOut->pExpr = sqlite3PExpr(pParse, op, pOperand->pExpr, 0, 0);\n    pOut->zStart = pPreOp->z;\n    pOut->zEnd = pOperand->zEnd;\n  }\n/* Next is all token values, in a form suitable for use by makeheaders.\n** This section will be null unless lemon is run with the -m switch.\n*/\n/* \n** These constants (all generated automatically by the parser generator)\n** specify the various kinds of tokens (terminals) that the parser\n** understands. \n**\n** Each symbol here is a terminal symbol in the grammar.\n*/\n/* Make sure the INTERFACE macro is defined.\n*/\n#ifndef INTERFACE\n# define INTERFACE 1\n#endif\n/* The next thing included is series of defines which control\n** various aspects of the generated parser.\n**    YYCODETYPE         is the data type used for storing terminal\n**                       and nonterminal numbers.  \"unsigned char\" is\n**                       used if there are fewer than 250 terminals\n**                       and nonterminals.  \"int\" is used otherwise.\n**    YYNOCODE           is a number of type YYCODETYPE which corresponds\n**                       to no legal terminal or nonterminal number.  This\n**                       number is used to fill in empty slots of the hash \n**                       table.\n**    YYFALLBACK         If defined, this indicates that one or more tokens\n**                       have fall-back values which should be used if the\n**                       original value of the token will not parse.\n**    YYACTIONTYPE       is the data type used for storing terminal\n**                       and nonterminal numbers.  \"unsigned char\" is\n**                       used if there are fewer than 250 rules and\n**                       states combined.  \"int\" is used otherwise.\n**    sqlite3ParserTOKENTYPE     is the data type used for minor tokens given \n**                       directly to the parser from the tokenizer.\n**    YYMINORTYPE        is the data type used for all minor tokens.\n**                       This is typically a union of many types, one of\n**                       which is sqlite3ParserTOKENTYPE.  The entry in the union\n**                       for base tokens is called \"yy0\".\n**    YYSTACKDEPTH       is the maximum depth of the parser's stack.  If\n**                       zero the stack is dynamically sized using realloc()\n**    sqlite3ParserARG_SDECL     A static variable declaration for the %extra_argument\n**    sqlite3ParserARG_PDECL     A parameter declaration for the %extra_argument\n**    sqlite3ParserARG_STORE     Code to store %extra_argument into yypParser\n**    sqlite3ParserARG_FETCH     Code to extract %extra_argument from yypParser\n**    YYNSTATE           the combined number of states.\n**    YYNRULE            the number of rules in the grammar\n**    YYERRORSYMBOL      is the code number of the error symbol.  If not\n**                       defined, then do no error processing.\n*/\n#define YYCODETYPE unsigned char\n#define YYNOCODE 253\n#define YYACTIONTYPE unsigned short int\n#define YYWILDCARD 67\n#define sqlite3ParserTOKENTYPE Token\ntypedef union {\n  int yyinit;\n  sqlite3ParserTOKENTYPE yy0;\n  int yy4;\n  struct TrigEvent yy90;\n  ExprSpan yy118;\n  TriggerStep* yy203;\n  u8 yy210;\n  struct {int value; int mask;} yy215;\n  SrcList* yy259;\n  struct LimitVal yy292;\n  Expr* yy314;\n  ExprList* yy322;\n  struct LikeOp yy342;\n  IdList* yy384;\n  Select* yy387;\n} YYMINORTYPE;\n#ifndef YYSTACKDEPTH\n#define YYSTACKDEPTH 100\n#endif\n#define sqlite3ParserARG_SDECL Parse *pParse;\n#define sqlite3ParserARG_PDECL ,Parse *pParse\n#define sqlite3ParserARG_FETCH Parse *pParse = yypParser->pParse\n#define sqlite3ParserARG_STORE yypParser->pParse = pParse\n#define YYNSTATE 630\n#define YYNRULE 329\n#define YYFALLBACK 1\n#define YY_NO_ACTION      (YYNSTATE+YYNRULE+2)\n#define YY_ACCEPT_ACTION  (YYNSTATE+YYNRULE+1)\n#define YY_ERROR_ACTION   (YYNSTATE+YYNRULE)\n\n/* The yyzerominor constant is used to initialize instances of\n** YYMINORTYPE objects to zero. */\nstatic const YYMINORTYPE yyzerominor = { 0 };\n\n/* Define the yytestcase() macro to be a no-op if is not already defined\n** otherwise.\n**\n** Applications can choose to define yytestcase() in the %include section\n** to a macro that can assist in verifying code coverage.  For production\n** code the yytestcase() macro should be turned off.  But it is useful\n** for testing.\n*/\n#ifndef yytestcase\n# define yytestcase(X)\n#endif\n\n\n/* Next are the tables used to determine what action to take based on the\n** current state and lookahead token.  These tables are used to implement\n** functions that take a state number and lookahead value and return an\n** action integer.  \n**\n** Suppose the action integer is N.  Then the action is determined as\n** follows\n**\n**   0 <= N < YYNSTATE                  Shift N.  That is, push the lookahead\n**                                      token onto the stack and goto state N.\n**\n**   YYNSTATE <= N < YYNSTATE+YYNRULE   Reduce by rule N-YYNSTATE.\n**\n**   N == YYNSTATE+YYNRULE              A syntax error has occurred.\n**\n**   N == YYNSTATE+YYNRULE+1            The parser accepts its input.\n**\n**   N == YYNSTATE+YYNRULE+2            No such action.  Denotes unused\n**                                      slots in the yy_action[] table.\n**\n** The action table is constructed as a single large table named yy_action[].\n** Given state S and lookahead X, the action is computed as\n**\n**      yy_action[ yy_shift_ofst[S] + X ]\n**\n** If the index value yy_shift_ofst[S]+X is out of range or if the value\n** yy_lookahead[yy_shift_ofst[S]+X] is not equal to X or if yy_shift_ofst[S]\n** is equal to YY_SHIFT_USE_DFLT, it means that the action is not in the table\n** and that yy_default[S] should be used instead.  \n**\n** The formula above is for computing the action when the lookahead is\n** a terminal symbol.  If the lookahead is a non-terminal (as occurs after\n** a reduce action) then the yy_reduce_ofst[] array is used in place of\n** the yy_shift_ofst[] array and YY_REDUCE_USE_DFLT is used in place of\n** YY_SHIFT_USE_DFLT.\n**\n** The following are the tables generated in this section:\n**\n**  yy_action[]        A single table containing all actions.\n**  yy_lookahead[]     A table containing the lookahead for each entry in\n**                     yy_action.  Used to detect hash collisions.\n**  yy_shift_ofst[]    For each state, the offset into yy_action for\n**                     shifting terminals.\n**  yy_reduce_ofst[]   For each state, the offset into yy_action for\n**                     shifting non-terminals after a reduce.\n**  yy_default[]       Default action for each state.\n*/\n#define YY_ACTTAB_COUNT (1557)\nstatic const YYACTIONTYPE yy_action[] = {\n /*     0 */   313,  960,  186,  419,    2,  172,  627,  597,   55,   55,\n /*    10 */    55,   55,   48,   53,   53,   53,   53,   52,   52,   51,\n /*    20 */    51,   51,   50,  238,  302,  283,  623,  622,  516,  515,\n /*    30 */   590,  584,   55,   55,   55,   55,  282,   53,   53,   53,\n /*    40 */    53,   52,   52,   51,   51,   51,   50,  238,    6,   56,\n /*    50 */    57,   47,  582,  581,  583,  583,   54,   54,   55,   55,\n /*    60 */    55,   55,  608,   53,   53,   53,   53,   52,   52,   51,\n /*    70 */    51,   51,   50,  238,  313,  597,  409,  330,  579,  579,\n /*    80 */    32,   53,   53,   53,   53,   52,   52,   51,   51,   51,\n /*    90 */    50,  238,  330,  217,  620,  619,  166,  411,  624,  382,\n /*   100 */   379,  378,    7,  491,  590,  584,  200,  199,  198,   58,\n /*   110 */   377,  300,  414,  621,  481,   66,  623,  622,  621,  580,\n /*   120 */   254,  601,   94,   56,   57,   47,  582,  581,  583,  583,\n /*   130 */    54,   54,   55,   55,   55,   55,  671,   53,   53,   53,\n /*   140 */    53,   52,   52,   51,   51,   51,   50,  238,  313,  532,\n /*   150 */   226,  506,  507,  133,  177,  139,  284,  385,  279,  384,\n /*   160 */   169,  197,  342,  398,  251,  226,  253,  275,  388,  167,\n /*   170 */   139,  284,  385,  279,  384,  169,  570,  236,  590,  584,\n /*   180 */   672,  240,  275,  157,  620,  619,  554,  437,   51,   51,\n /*   190 */    51,   50,  238,  343,  439,  553,  438,   56,   57,   47,\n /*   200 */   582,  581,  583,  583,   54,   54,   55,   55,   55,   55,\n /*   210 */   465,   53,   53,   53,   53,   52,   52,   51,   51,   51,\n /*   220 */    50,  238,  313,  390,   52,   52,   51,   51,   51,   50,\n /*   230 */   238,  391,  166,  491,  566,  382,  379,  378,  409,  440,\n /*   240 */   579,  579,  252,  440,  607,   66,  377,  513,  621,   49,\n /*   250 */    46,  147,  590,  584,  621,   16,  466,  189,  621,  441,\n /*   260 */   442,  673,  526,  441,  340,  577,  595,   64,  194,  482,\n /*   270 */   434,   56,   57,   47,  582,  581,  583,  583,   54,   54,\n /*   280 */    55,   55,   55,   55,   30,   53,   53,   53,   53,   52,\n /*   290 */    52,   51,   51,   51,   50,  238,  313,  593,  593,  593,\n /*   300 */   387,  578,  606,  493,  259,  351,  258,  411,    1,  623,\n /*   310 */   622,  496,  623,  622,   65,  240,  623,  622,  597,  443,\n /*   320 */   237,  239,  414,  341,  237,  602,  590,  584,   18,  603,\n /*   330 */   166,  601,   87,  382,  379,  378,   67,  623,  622,   38,\n /*   340 */   623,  622,  176,  270,  377,   56,   57,   47,  582,  581,\n /*   350 */   583,  583,   54,   54,   55,   55,   55,   55,  175,   53,\n /*   360 */    53,   53,   53,   52,   52,   51,   51,   51,   50,  238,\n /*   370 */   313,  396,  233,  411,  531,  565,  317,  620,  619,   44,\n /*   380 */   620,  619,  240,  206,  620,  619,  597,  266,  414,  268,\n /*   390 */   409,  597,  579,  579,  352,  184,  505,  601,   73,  533,\n /*   400 */   590,  584,  466,  548,  190,  620,  619,  576,  620,  619,\n /*   410 */   547,  383,  551,   35,  332,  575,  574,  600,  504,   56,\n /*   420 */    57,   47,  582,  581,  583,  583,   54,   54,   55,   55,\n /*   430 */    55,   55,  567,   53,   53,   53,   53,   52,   52,   51,\n /*   440 */    51,   51,   50,  238,  313,  411,  561,  561,  528,  364,\n /*   450 */   259,  351,  258,  183,  361,  549,  524,  374,  411,  597,\n /*   460 */   414,  240,  560,  560,  409,  604,  579,  579,  328,  601,\n /*   470 */    93,  623,  622,  414,  590,  584,  237,  564,  559,  559,\n /*   480 */   520,  402,  601,   87,  409,  210,  579,  579,  168,  421,\n /*   490 */   950,  519,  950,   56,   57,   47,  582,  581,  583,  583,\n /*   500 */    54,   54,   55,   55,   55,   55,  192,   53,   53,   53,\n /*   510 */    53,   52,   52,   51,   51,   51,   50,  238,  313,  600,\n /*   520 */   293,  563,  511,  234,  357,  146,  475,  475,  367,  411,\n /*   530 */   562,  411,  358,  542,  425,  171,  411,  215,  144,  620,\n /*   540 */   619,  544,  318,  353,  414,  203,  414,  275,  590,  584,\n /*   550 */   549,  414,  174,  601,   94,  601,   79,  558,  471,   61,\n /*   560 */   601,   79,  421,  949,  350,  949,   34,   56,   57,   47,\n /*   570 */   582,  581,  583,  583,   54,   54,   55,   55,   55,   55,\n /*   580 */   535,   53,   53,   53,   53,   52,   52,   51,   51,   51,\n /*   590 */    50,  238,  313,  307,  424,  394,  272,   49,   46,  147,\n /*   600 */   349,  322,    4,  411,  491,  312,  321,  425,  568,  492,\n /*   610 */   216,  264,  407,  575,  574,  429,   66,  549,  414,  621,\n /*   620 */   540,  602,  590,  584,   13,  603,  621,  601,   72,   12,\n /*   630 */   618,  617,  616,  202,  210,  621,  546,  469,  422,  319,\n /*   640 */   148,   56,   57,   47,  582,  581,  583,  583,   54,   54,\n /*   650 */    55,   55,   55,   55,  338,   53,   53,   53,   53,   52,\n /*   660 */    52,   51,   51,   51,   50,  238,  313,  600,  600,  411,\n /*   670 */    39,   21,   37,  170,  237,  875,  411,  572,  572,  201,\n /*   680 */   144,  473,  538,  331,  414,  474,  143,  146,  630,  628,\n /*   690 */   334,  414,  353,  601,   68,  168,  590,  584,  132,  365,\n /*   700 */   601,   96,  307,  423,  530,  336,   49,   46,  147,  568,\n /*   710 */   406,  216,  549,  360,  529,   56,   57,   47,  582,  581,\n /*   720 */   583,  583,   54,   54,   55,   55,   55,   55,  411,   53,\n /*   730 */    53,   53,   53,   52,   52,   51,   51,   51,   50,  238,\n /*   740 */   313,  411,  605,  414,  484,  510,  172,  422,  597,  318,\n /*   750 */   496,  485,  601,   99,  411,  142,  414,  411,  231,  411,\n /*   760 */   540,  411,  359,  629,    2,  601,   97,  426,  308,  414,\n /*   770 */   590,  584,  414,   20,  414,  621,  414,  621,  601,  106,\n /*   780 */   503,  601,  105,  601,  108,  601,  109,  204,   28,   56,\n /*   790 */    57,   47,  582,  581,  583,  583,   54,   54,   55,   55,\n /*   800 */    55,   55,  411,   53,   53,   53,   53,   52,   52,   51,\n /*   810 */    51,   51,   50,  238,  313,  411,  597,  414,  411,  276,\n /*   820 */   214,  600,  411,  366,  213,  381,  601,  134,  274,  500,\n /*   830 */   414,  167,  130,  414,  621,  411,  354,  414,  376,  601,\n /*   840 */   135,  129,  601,  100,  590,  584,  601,  104,  522,  521,\n /*   850 */   414,  621,  224,  273,  600,  167,  327,  282,  600,  601,\n /*   860 */   103,  468,  521,   56,   57,   47,  582,  581,  583,  583,\n /*   870 */    54,   54,   55,   55,   55,   55,  411,   53,   53,   53,\n /*   880 */    53,   52,   52,   51,   51,   51,   50,  238,  313,  411,\n /*   890 */    27,  414,  411,  375,  276,  167,  359,  544,   50,  238,\n /*   900 */   601,   95,  128,  223,  414,  411,  165,  414,  411,  621,\n /*   910 */   411,  621,  612,  601,  102,  372,  601,   76,  590,  584,\n /*   920 */   414,  570,  236,  414,  470,  414,  167,  621,  188,  601,\n /*   930 */    98,  225,  601,  138,  601,  137,  232,   56,   45,   47,\n /*   940 */   582,  581,  583,  583,   54,   54,   55,   55,   55,   55,\n /*   950 */   411,   53,   53,   53,   53,   52,   52,   51,   51,   51,\n /*   960 */    50,  238,  313,  276,  276,  414,  411,  276,  544,  459,\n /*   970 */   359,  171,  209,  479,  601,  136,  628,  334,  621,  621,\n /*   980 */   125,  414,  621,  368,  411,  621,  257,  540,  589,  588,\n /*   990 */   601,   75,  590,  584,  458,  446,   23,   23,  124,  414,\n /*  1000 */   326,  325,  621,  427,  324,  309,  600,  288,  601,   92,\n /*  1010 */   586,  585,   57,   47,  582,  581,  583,  583,   54,   54,\n /*  1020 */    55,   55,   55,   55,  411,   53,   53,   53,   53,   52,\n /*  1030 */    52,   51,   51,   51,   50,  238,  313,  587,  411,  414,\n /*  1040 */   411,  207,  611,  476,  171,  472,  160,  123,  601,   91,\n /*  1050 */   323,  261,   15,  414,  464,  414,  411,  621,  411,  354,\n /*  1060 */   222,  411,  601,   74,  601,   90,  590,  584,  159,  264,\n /*  1070 */   158,  414,  461,  414,  621,  600,  414,  121,  120,   25,\n /*  1080 */   601,   89,  601,  101,  621,  601,   88,   47,  582,  581,\n /*  1090 */   583,  583,   54,   54,   55,   55,   55,   55,  544,   53,\n /*  1100 */    53,   53,   53,   52,   52,   51,   51,   51,   50,  238,\n /*  1110 */    43,  405,  263,    3,  610,  264,  140,  415,  622,   24,\n /*  1120 */   410,   11,  456,  594,  118,  155,  219,  452,  408,  621,\n /*  1130 */   621,  621,  156,   43,  405,  621,    3,  286,  621,  113,\n /*  1140 */   415,  622,  111,  445,  411,  400,  557,  403,  545,   10,\n /*  1150 */   411,  408,  264,  110,  205,  436,  541,  566,  453,  414,\n /*  1160 */   621,  621,   63,  621,  435,  414,  411,  621,  601,   94,\n /*  1170 */   403,  621,  411,  337,  601,   86,  150,   40,   41,  534,\n /*  1180 */   566,  414,  242,  264,   42,  413,  412,  414,  600,  595,\n /*  1190 */   601,   85,  191,  333,  107,  451,  601,   84,  621,  539,\n /*  1200 */    40,   41,  420,  230,  411,  149,  316,   42,  413,  412,\n /*  1210 */   398,  127,  595,  315,  621,  399,  278,  625,  181,  414,\n /*  1220 */   593,  593,  593,  592,  591,   14,  450,  411,  601,   71,\n /*  1230 */   240,  621,   43,  405,  264,    3,  615,  180,  264,  415,\n /*  1240 */   622,  614,  414,  593,  593,  593,  592,  591,   14,  621,\n /*  1250 */   408,  601,   70,  621,  417,   33,  405,  613,    3,  411,\n /*  1260 */   264,  411,  415,  622,  418,  626,  178,  509,    8,  403,\n /*  1270 */   241,  416,  126,  408,  414,  621,  414,  449,  208,  566,\n /*  1280 */   240,  221,  621,  601,   83,  601,   82,  599,  297,  277,\n /*  1290 */   296,   30,  403,   31,  395,  264,  295,  397,  489,   40,\n /*  1300 */    41,  411,  566,  220,  621,  294,   42,  413,  412,  271,\n /*  1310 */   621,  595,  600,  621,   59,   60,  414,  269,  267,  623,\n /*  1320 */   622,   36,   40,   41,  621,  601,   81,  598,  235,   42,\n /*  1330 */   413,  412,  621,  621,  595,  265,  344,  411,  248,  556,\n /*  1340 */   173,  185,  593,  593,  593,  592,  591,   14,  218,   29,\n /*  1350 */   621,  543,  414,  305,  304,  303,  179,  301,  411,  566,\n /*  1360 */   454,  601,   80,  289,  335,  593,  593,  593,  592,  591,\n /*  1370 */    14,  411,  287,  414,  151,  392,  246,  260,  411,  196,\n /*  1380 */   195,  523,  601,   69,  411,  245,  414,  526,  537,  285,\n /*  1390 */   389,  595,  621,  414,  536,  601,   17,  362,  153,  414,\n /*  1400 */   466,  463,  601,   78,  154,  414,  462,  152,  601,   77,\n /*  1410 */   355,  255,  621,  455,  601,    9,  621,  386,  444,  517,\n /*  1420 */   247,  621,  593,  593,  593,  621,  621,  244,  621,  243,\n /*  1430 */   430,  518,  292,  621,  329,  621,  145,  393,  280,  513,\n /*  1440 */   291,  131,  621,  514,  621,  621,  311,  621,  259,  346,\n /*  1450 */   249,  621,  621,  229,  314,  621,  228,  512,  227,  240,\n /*  1460 */   494,  488,  310,  164,  487,  486,  373,  480,  163,  262,\n /*  1470 */   369,  371,  162,   26,  212,  478,  477,  161,  141,  363,\n /*  1480 */   467,  122,  339,  187,  119,  348,  347,  117,  116,  115,\n /*  1490 */   114,  112,  182,  457,  320,   22,  433,  432,  448,   19,\n /*  1500 */   609,  431,  428,   62,  193,  596,  573,  298,  555,  552,\n /*  1510 */   571,  404,  290,  380,  498,  510,  495,  306,  281,  499,\n /*  1520 */   250,    5,  497,  460,  345,  447,  569,  550,  238,  299,\n /*  1530 */   527,  525,  508,  961,  502,  501,  961,  401,  961,  211,\n /*  1540 */   490,  356,  256,  961,  483,  961,  961,  961,  961,  961,\n /*  1550 */   961,  961,  961,  961,  961,  961,  370,\n};\nstatic const YYCODETYPE yy_lookahead[] = {\n /*     0 */    19,  142,  143,  144,  145,   24,    1,   26,   77,   78,\n /*    10 */    79,   80,   81,   82,   83,   84,   85,   86,   87,   88,\n /*    20 */    89,   90,   91,   92,   15,   98,   26,   27,    7,    8,\n /*    30 */    49,   50,   77,   78,   79,   80,  109,   82,   83,   84,\n /*    40 */    85,   86,   87,   88,   89,   90,   91,   92,   22,   68,\n /*    50 */    69,   70,   71,   72,   73,   74,   75,   76,   77,   78,\n /*    60 */    79,   80,   23,   82,   83,   84,   85,   86,   87,   88,\n /*    70 */    89,   90,   91,   92,   19,   94,  112,   19,  114,  115,\n /*    80 */    25,   82,   83,   84,   85,   86,   87,   88,   89,   90,\n /*    90 */    91,   92,   19,   22,   94,   95,   96,  150,  150,   99,\n /*   100 */   100,  101,   76,  150,   49,   50,  105,  106,  107,   54,\n /*   110 */   110,  158,  165,  165,  161,  162,   26,   27,  165,  113,\n /*   120 */    16,  174,  175,   68,   69,   70,   71,   72,   73,   74,\n /*   130 */    75,   76,   77,   78,   79,   80,  118,   82,   83,   84,\n /*   140 */    85,   86,   87,   88,   89,   90,   91,   92,   19,   23,\n /*   150 */    92,   97,   98,   24,   96,   97,   98,   99,  100,  101,\n /*   160 */   102,   25,   97,  216,   60,   92,   62,  109,  221,   25,\n /*   170 */    97,   98,   99,  100,  101,  102,   86,   87,   49,   50,\n /*   180 */   118,  116,  109,   25,   94,   95,   32,   97,   88,   89,\n /*   190 */    90,   91,   92,  128,  104,   41,  106,   68,   69,   70,\n /*   200 */    71,   72,   73,   74,   75,   76,   77,   78,   79,   80,\n /*   210 */    11,   82,   83,   84,   85,   86,   87,   88,   89,   90,\n /*   220 */    91,   92,   19,   19,   86,   87,   88,   89,   90,   91,\n /*   230 */    92,   27,   96,  150,   66,   99,  100,  101,  112,  150,\n /*   240 */   114,  115,  138,  150,  161,  162,  110,  103,  165,  222,\n /*   250 */   223,  224,   49,   50,  165,   22,   57,   24,  165,  170,\n /*   260 */   171,  118,   94,  170,  171,   23,   98,   25,  185,  186,\n /*   270 */   243,   68,   69,   70,   71,   72,   73,   74,   75,   76,\n /*   280 */    77,   78,   79,   80,  126,   82,   83,   84,   85,   86,\n /*   290 */    87,   88,   89,   90,   91,   92,   19,  129,  130,  131,\n /*   300 */    88,   23,  172,  173,  105,  106,  107,  150,   22,   26,\n /*   310 */    27,  181,   26,   27,   22,  116,   26,   27,   26,  230,\n /*   320 */   231,  197,  165,  230,  231,  113,   49,   50,  204,  117,\n /*   330 */    96,  174,  175,   99,  100,  101,   22,   26,   27,  136,\n /*   340 */    26,   27,  118,   16,  110,   68,   69,   70,   71,   72,\n /*   350 */    73,   74,   75,   76,   77,   78,   79,   80,  118,   82,\n /*   360 */    83,   84,   85,   86,   87,   88,   89,   90,   91,   92,\n /*   370 */    19,  214,  215,  150,   23,   23,  155,   94,   95,   22,\n /*   380 */    94,   95,  116,  160,   94,   95,   94,   60,  165,   62,\n /*   390 */   112,   26,  114,  115,  128,   23,   36,  174,  175,   88,\n /*   400 */    49,   50,   57,  120,   22,   94,   95,   23,   94,   95,\n /*   410 */   120,   51,   25,  136,  169,  170,  171,  194,   58,   68,\n /*   420 */    69,   70,   71,   72,   73,   74,   75,   76,   77,   78,\n /*   430 */    79,   80,   23,   82,   83,   84,   85,   86,   87,   88,\n /*   440 */    89,   90,   91,   92,   19,  150,   12,   12,   23,  228,\n /*   450 */   105,  106,  107,   23,  233,   25,  165,   19,  150,   94,\n /*   460 */   165,  116,   28,   28,  112,  174,  114,  115,  108,  174,\n /*   470 */   175,   26,   27,  165,   49,   50,  231,   11,   44,   44,\n /*   480 */    46,   46,  174,  175,  112,  160,  114,  115,   50,   22,\n /*   490 */    23,   57,   25,   68,   69,   70,   71,   72,   73,   74,\n /*   500 */    75,   76,   77,   78,   79,   80,  119,   82,   83,   84,\n /*   510 */    85,   86,   87,   88,   89,   90,   91,   92,   19,  194,\n /*   520 */   225,   23,   23,  215,   19,   95,  105,  106,  107,  150,\n /*   530 */    23,  150,   27,   23,   67,   25,  150,  206,  207,   94,\n /*   540 */    95,  166,  104,  218,  165,   22,  165,  109,   49,   50,\n /*   550 */   120,  165,   25,  174,  175,  174,  175,   23,   21,  234,\n /*   560 */   174,  175,   22,   23,  239,   25,   25,   68,   69,   70,\n /*   570 */    71,   72,   73,   74,   75,   76,   77,   78,   79,   80,\n /*   580 */   205,   82,   83,   84,   85,   86,   87,   88,   89,   90,\n /*   590 */    91,   92,   19,   22,   23,  216,   23,  222,  223,  224,\n /*   600 */    63,  220,   35,  150,  150,  163,  220,   67,  166,  167,\n /*   610 */   168,  150,  169,  170,  171,  161,  162,   25,  165,  165,\n /*   620 */   150,  113,   49,   50,   25,  117,  165,  174,  175,   35,\n /*   630 */     7,    8,    9,  160,  160,  165,  120,  100,   67,  247,\n /*   640 */   248,   68,   69,   70,   71,   72,   73,   74,   75,   76,\n /*   650 */    77,   78,   79,   80,  193,   82,   83,   84,   85,   86,\n /*   660 */    87,   88,   89,   90,   91,   92,   19,  194,  194,  150,\n /*   670 */   135,   24,  137,   35,  231,  138,  150,  129,  130,  206,\n /*   680 */   207,   30,   27,  213,  165,   34,  118,   95,    0,    1,\n /*   690 */     2,  165,  218,  174,  175,   50,   49,   50,   22,   48,\n /*   700 */   174,  175,   22,   23,   23,  244,  222,  223,  224,  166,\n /*   710 */   167,  168,  120,  239,   23,   68,   69,   70,   71,   72,\n /*   720 */    73,   74,   75,   76,   77,   78,   79,   80,  150,   82,\n /*   730 */    83,   84,   85,   86,   87,   88,   89,   90,   91,   92,\n /*   740 */    19,  150,  173,  165,  181,  182,   24,   67,   26,  104,\n /*   750 */   181,  188,  174,  175,  150,   39,  165,  150,   52,  150,\n /*   760 */   150,  150,  150,  144,  145,  174,  175,  249,  250,  165,\n /*   770 */    49,   50,  165,   52,  165,  165,  165,  165,  174,  175,\n /*   780 */    29,  174,  175,  174,  175,  174,  175,  160,   22,   68,\n /*   790 */    69,   70,   71,   72,   73,   74,   75,   76,   77,   78,\n /*   800 */    79,   80,  150,   82,   83,   84,   85,   86,   87,   88,\n /*   810 */    89,   90,   91,   92,   19,  150,   94,  165,  150,  150,\n /*   820 */   160,  194,  150,  213,  160,   52,  174,  175,   23,   23,\n /*   830 */   165,   25,   22,  165,  165,  150,  150,  165,   52,  174,\n /*   840 */   175,   22,  174,  175,   49,   50,  174,  175,  190,  191,\n /*   850 */   165,  165,  240,   23,  194,   25,  187,  109,  194,  174,\n /*   860 */   175,  190,  191,   68,   69,   70,   71,   72,   73,   74,\n /*   870 */    75,   76,   77,   78,   79,   80,  150,   82,   83,   84,\n /*   880 */    85,   86,   87,   88,   89,   90,   91,   92,   19,  150,\n /*   890 */    22,  165,  150,   23,  150,   25,  150,  166,   91,   92,\n /*   900 */   174,  175,   22,  217,  165,  150,  102,  165,  150,  165,\n /*   910 */   150,  165,  150,  174,  175,   19,  174,  175,   49,   50,\n /*   920 */   165,   86,   87,  165,   23,  165,   25,  165,   24,  174,\n /*   930 */   175,  187,  174,  175,  174,  175,  205,   68,   69,   70,\n /*   940 */    71,   72,   73,   74,   75,   76,   77,   78,   79,   80,\n /*   950 */   150,   82,   83,   84,   85,   86,   87,   88,   89,   90,\n /*   960 */    91,   92,   19,  150,  150,  165,  150,  150,  166,   23,\n /*   970 */   150,   25,  160,   20,  174,  175,    1,    2,  165,  165,\n /*   980 */   104,  165,  165,   43,  150,  165,  240,  150,   49,   50,\n /*   990 */   174,  175,   49,   50,   23,   23,   25,   25,   53,  165,\n /*  1000 */   187,  187,  165,   23,  187,   25,  194,  205,  174,  175,\n /*  1010 */    71,   72,   69,   70,   71,   72,   73,   74,   75,   76,\n /*  1020 */    77,   78,   79,   80,  150,   82,   83,   84,   85,   86,\n /*  1030 */    87,   88,   89,   90,   91,   92,   19,   98,  150,  165,\n /*  1040 */   150,  160,  150,   59,   25,   53,  104,   22,  174,  175,\n /*  1050 */   213,  138,    5,  165,    1,  165,  150,  165,  150,  150,\n /*  1060 */   240,  150,  174,  175,  174,  175,   49,   50,  118,  150,\n /*  1070 */    35,  165,   27,  165,  165,  194,  165,  108,  127,   76,\n /*  1080 */   174,  175,  174,  175,  165,  174,  175,   70,   71,   72,\n /*  1090 */    73,   74,   75,   76,   77,   78,   79,   80,  166,   82,\n /*  1100 */    83,   84,   85,   86,   87,   88,   89,   90,   91,   92,\n /*  1110 */    19,   20,  193,   22,  150,  150,  150,   26,   27,   76,\n /*  1120 */   150,   22,    1,  150,  119,  121,  217,   20,   37,  165,\n /*  1130 */   165,  165,   16,   19,   20,  165,   22,  205,  165,  119,\n /*  1140 */    26,   27,  108,  128,  150,  150,  150,   56,  150,   22,\n /*  1150 */   150,   37,  150,  127,  160,   23,  150,   66,  193,  165,\n /*  1160 */   165,  165,   16,  165,   23,  165,  150,  165,  174,  175,\n /*  1170 */    56,  165,  150,   65,  174,  175,   15,   86,   87,   88,\n /*  1180 */    66,  165,  140,  150,   93,   94,   95,  165,  194,   98,\n /*  1190 */   174,  175,   22,    3,  164,  193,  174,  175,  165,  150,\n /*  1200 */    86,   87,    4,  180,  150,  248,  251,   93,   94,   95,\n /*  1210 */   216,  180,   98,  251,  165,  221,  150,  149,    6,  165,\n /*  1220 */   129,  130,  131,  132,  133,  134,  193,  150,  174,  175,\n /*  1230 */   116,  165,   19,   20,  150,   22,  149,  151,  150,   26,\n /*  1240 */    27,  149,  165,  129,  130,  131,  132,  133,  134,  165,\n /*  1250 */    37,  174,  175,  165,  149,   19,   20,   13,   22,  150,\n /*  1260 */   150,  150,   26,   27,  146,  147,  151,  150,   25,   56,\n /*  1270 */   152,  159,  154,   37,  165,  165,  165,  193,  160,   66,\n /*  1280 */   116,  193,  165,  174,  175,  174,  175,  194,  199,  150,\n /*  1290 */   200,  126,   56,  124,  123,  150,  201,  122,  150,   86,\n /*  1300 */    87,  150,   66,  193,  165,  202,   93,   94,   95,  150,\n /*  1310 */   165,   98,  194,  165,  125,   22,  165,  150,  150,   26,\n /*  1320 */    27,  135,   86,   87,  165,  174,  175,  203,  226,   93,\n /*  1330 */    94,   95,  165,  165,   98,  150,  218,  150,  193,  157,\n /*  1340 */   118,  157,  129,  130,  131,  132,  133,  134,    5,  104,\n /*  1350 */   165,  211,  165,   10,   11,   12,   13,   14,  150,   66,\n /*  1360 */    17,  174,  175,  210,  246,  129,  130,  131,  132,  133,\n /*  1370 */   134,  150,  210,  165,   31,  121,   33,  150,  150,   86,\n /*  1380 */    87,  176,  174,  175,  150,   42,  165,   94,  211,  210,\n /*  1390 */   150,   98,  165,  165,  211,  174,  175,  150,   55,  165,\n /*  1400 */    57,  150,  174,  175,   61,  165,  150,   64,  174,  175,\n /*  1410 */   150,  150,  165,  150,  174,  175,  165,  104,  150,  184,\n /*  1420 */   150,  165,  129,  130,  131,  165,  165,  150,  165,  150,\n /*  1430 */   150,  176,  150,  165,   47,  165,  150,  150,  176,  103,\n /*  1440 */   150,   22,  165,  178,  165,  165,  179,  165,  105,  106,\n /*  1450 */   107,  165,  165,  229,  111,  165,   92,  176,  229,  116,\n /*  1460 */   184,  176,  179,  156,  176,  176,   18,  157,  156,  237,\n /*  1470 */    45,  157,  156,  135,  157,  157,  238,  156,   68,  157,\n /*  1480 */   189,  189,  139,  219,   22,  157,   18,  192,  192,  192,\n /*  1490 */   192,  189,  219,  199,  157,  242,   40,  157,  199,  242,\n /*  1500 */   153,  157,   38,  245,  196,  166,  232,  198,  177,  177,\n /*  1510 */   232,  227,  209,  178,  166,  182,  166,  148,  177,  177,\n /*  1520 */   209,  196,  177,  199,  209,  199,  166,  208,   92,  195,\n /*  1530 */   174,  174,  183,  252,  183,  183,  252,  191,  252,  235,\n /*  1540 */   186,  241,  241,  252,  186,  252,  252,  252,  252,  252,\n /*  1550 */   252,  252,  252,  252,  252,  252,  236,\n};\n#define YY_SHIFT_USE_DFLT (-74)\n#define YY_SHIFT_COUNT (418)\n#define YY_SHIFT_MIN   (-73)\n#define YY_SHIFT_MAX   (1468)\nstatic const short yy_shift_ofst[] = {\n /*     0 */   975, 1114, 1343, 1114, 1213, 1213,   90,   90,    0,  -19,\n /*    10 */  1213, 1213, 1213, 1213, 1213,  345,  445,  721, 1091, 1213,\n /*    20 */  1213, 1213, 1213, 1213, 1213, 1213, 1213, 1213, 1213, 1213,\n /*    30 */  1213, 1213, 1213, 1213, 1213, 1213, 1213, 1213, 1213, 1213,\n /*    40 */  1213, 1213, 1213, 1213, 1213, 1213, 1213, 1236, 1213, 1213,\n /*    50 */  1213, 1213, 1213, 1213, 1213, 1213, 1213, 1213, 1213, 1213,\n /*    60 */  1213,  199,  445,  445,  835,  835,  365, 1164,   55,  647,\n /*    70 */   573,  499,  425,  351,  277,  203,  129,  795,  795,  795,\n /*    80 */   795,  795,  795,  795,  795,  795,  795,  795,  795,  795,\n /*    90 */   795,  795,  795,  795,  795,  869,  795,  943, 1017, 1017,\n /*   100 */   -69,  -45,  -45,  -45,  -45,  -45,   -1,   58,  138,  100,\n /*   110 */   445,  445,  445,  445,  445,  445,  445,  445,  445,  445,\n /*   120 */   445,  445,  445,  445,  445,  445,  537,  438,  445,  445,\n /*   130 */   445,  445,  445,  365,  807, 1436,  -74,  -74,  -74, 1293,\n /*   140 */    73,  434,  434,  311,  314,  290,  283,  286,  540,  467,\n /*   150 */   445,  445,  445,  445,  445,  445,  445,  445,  445,  445,\n /*   160 */   445,  445,  445,  445,  445,  445,  445,  445,  445,  445,\n /*   170 */   445,  445,  445,  445,  445,  445,  445,  445,  445,  445,\n /*   180 */   445,  445,   65,  722,  722,  722,  688,  266, 1164, 1164,\n /*   190 */  1164,  -74,  -74,  -74,  136,  168,  168,  234,  360,  360,\n /*   200 */   360,  430,  372,  435,  352,  278,  126,  -36,  -36,  -36,\n /*   210 */   -36,  421,  651,  -36,  -36,  592,  292,  212,  623,  158,\n /*   220 */   204,  204,  505,  158,  505,  144,  365,  154,  365,  154,\n /*   230 */   645,  154,  204,  154,  154,  535,  548,  548,  365,  387,\n /*   240 */   508,  233, 1464, 1222, 1222, 1456, 1456, 1222, 1462, 1410,\n /*   250 */  1165, 1468, 1468, 1468, 1468, 1222, 1165, 1462, 1410, 1410,\n /*   260 */  1222, 1448, 1338, 1425, 1222, 1222, 1448, 1222, 1448, 1222,\n /*   270 */  1448, 1419, 1313, 1313, 1313, 1387, 1364, 1364, 1419, 1313,\n /*   280 */  1336, 1313, 1387, 1313, 1313, 1254, 1245, 1254, 1245, 1254,\n /*   290 */  1245, 1222, 1222, 1186, 1189, 1175, 1169, 1171, 1165, 1164,\n /*   300 */  1243, 1244, 1244, 1212, 1212, 1212, 1212,  -74,  -74,  -74,\n /*   310 */   -74,  -74,  -74,  939,  104,  680,  571,  327,    1,  980,\n /*   320 */    26,  972,  971,  946,  901,  870,  830,  806,   54,   21,\n /*   330 */   -73,  510,  242, 1198, 1190, 1170, 1042, 1161, 1108, 1146,\n /*   340 */  1141, 1132, 1015, 1127, 1026, 1034, 1020, 1107, 1004, 1116,\n /*   350 */  1121, 1005, 1099,  951, 1043, 1003,  969, 1045, 1035,  950,\n /*   360 */  1053, 1047, 1025,  942,  913,  992, 1019,  945,  984,  940,\n /*   370 */   876,  904,  953,  896,  748,  804,  880,  786,  868,  819,\n /*   380 */   805,  810,  773,  751,  766,  706,  716,  691,  681,  568,\n /*   390 */   655,  638,  676,  516,  541,  594,  599,  567,  541,  534,\n /*   400 */   507,  527,  498,  523,  466,  382,  409,  384,  357,    6,\n /*   410 */   240,  224,  143,   62,   18,   71,   39,    9,    5,\n};\n#define YY_REDUCE_USE_DFLT (-142)\n#define YY_REDUCE_COUNT (312)\n#define YY_REDUCE_MIN   (-141)\n#define YY_REDUCE_MAX   (1369)\nstatic const short yy_reduce_ofst[] = {\n /*     0 */  -141,  994, 1118,  223,  157,  -53,   93,   89,   83,  375,\n /*    10 */   386,  381,  379,  308,  295,  325,  -47,   27, 1240, 1234,\n /*    20 */  1228, 1221, 1208, 1187, 1151, 1111, 1109, 1077, 1054, 1022,\n /*    30 */  1016, 1000,  911,  908,  906,  890,  888,  874,  834,  816,\n /*    40 */   800,  760,  758,  755,  742,  739,  726,  685,  672,  668,\n /*    50 */   665,  652,  611,  609,  607,  604,  591,  578,  526,  519,\n /*    60 */   453,  474,  454,  461,  443,  245,  442,  473,  484,  484,\n /*    70 */   484,  484,  484,  484,  484,  484,  484,  484,  484,  484,\n /*    80 */   484,  484,  484,  484,  484,  484,  484,  484,  484,  484,\n /*    90 */   484,  484,  484,  484,  484,  484,  484,  484,  484,  484,\n /*   100 */   484,  484,  484,  484,  484,  484,  484,  130,  484,  484,\n /*   110 */  1145,  909, 1110, 1088, 1084, 1033, 1002,  965,  820,  837,\n /*   120 */   746,  686,  612,  817,  610,  919,  221,  563,  814,  813,\n /*   130 */   744,  669,  470,  543,  484,  484,  484,  484,  484,  291,\n /*   140 */   569,  671,  658,  970, 1290, 1287, 1286, 1282,  518,  518,\n /*   150 */  1280, 1279, 1277, 1270, 1268, 1263, 1261, 1260, 1256, 1251,\n /*   160 */  1247, 1227, 1185, 1168, 1167, 1159, 1148, 1139, 1117, 1066,\n /*   170 */  1049, 1006,  998,  996,  995,  973,  970,  966,  964,  892,\n /*   180 */   762,  -52,  881,  932,  802,  731,  619,  812,  664,  660,\n /*   190 */   627,  392,  331,  124, 1358, 1357, 1356, 1354, 1352, 1351,\n /*   200 */  1349, 1319, 1334, 1346, 1334, 1334, 1334, 1334, 1334, 1334,\n /*   210 */  1334, 1320, 1304, 1334, 1334, 1319, 1360, 1325, 1369, 1326,\n /*   220 */  1315, 1311, 1301, 1324, 1300, 1335, 1350, 1345, 1348, 1342,\n /*   230 */  1333, 1341, 1303, 1332, 1331, 1284, 1278, 1274, 1339, 1309,\n /*   240 */  1308, 1347, 1258, 1344, 1340, 1257, 1253, 1337, 1273, 1302,\n /*   250 */  1299, 1298, 1297, 1296, 1295, 1328, 1294, 1264, 1292, 1291,\n /*   260 */  1322, 1321, 1238, 1232, 1318, 1317, 1316, 1314, 1312, 1310,\n /*   270 */  1307, 1283, 1289, 1288, 1285, 1276, 1229, 1224, 1267, 1281,\n /*   280 */  1265, 1262, 1235, 1255, 1205, 1183, 1179, 1177, 1162, 1140,\n /*   290 */  1153, 1184, 1182, 1102, 1124, 1103, 1095, 1090, 1089, 1093,\n /*   300 */  1112, 1115, 1086, 1105, 1092, 1087, 1068,  962,  955,  957,\n /*   310 */  1031, 1023, 1030,\n};\nstatic const YYACTIONTYPE yy_default[] = {\n /*     0 */   635,  870,  959,  959,  959,  870,  899,  899,  959,  759,\n /*    10 */   959,  959,  959,  959,  868,  959,  959,  933,  959,  959,\n /*    20 */   959,  959,  959,  959,  959,  959,  959,  959,  959,  959,\n /*    30 */   959,  959,  959,  959,  959,  959,  959,  959,  959,  959,\n /*    40 */   959,  959,  959,  959,  959,  959,  959,  959,  959,  959,\n /*    50 */   959,  959,  959,  959,  959,  959,  959,  959,  959,  959,\n /*    60 */   959,  959,  959,  959,  899,  899,  674,  763,  794,  959,\n /*    70 */   959,  959,  959,  959,  959,  959,  959,  932,  934,  809,\n /*    80 */   808,  802,  801,  912,  774,  799,  792,  785,  796,  871,\n /*    90 */   864,  865,  863,  867,  872,  959,  795,  831,  848,  830,\n /*   100 */   842,  847,  854,  846,  843,  833,  832,  666,  834,  835,\n /*   110 */   959,  959,  959,  959,  959,  959,  959,  959,  959,  959,\n /*   120 */   959,  959,  959,  959,  959,  959,  661,  728,  959,  959,\n /*   130 */   959,  959,  959,  959,  836,  837,  851,  850,  849,  959,\n /*   140 */   959,  959,  959,  959,  959,  959,  959,  959,  959,  959,\n /*   150 */   959,  939,  937,  959,  883,  959,  959,  959,  959,  959,\n /*   160 */   959,  959,  959,  959,  959,  959,  959,  959,  959,  959,\n /*   170 */   959,  959,  959,  959,  959,  959,  959,  959,  959,  959,\n /*   180 */   959,  641,  959,  759,  759,  759,  635,  959,  959,  959,\n /*   190 */   959,  951,  763,  753,  719,  959,  959,  959,  959,  959,\n /*   200 */   959,  959,  959,  959,  959,  959,  959,  804,  742,  922,\n /*   210 */   924,  959,  905,  740,  663,  761,  676,  751,  643,  798,\n /*   220 */   776,  776,  917,  798,  917,  700,  959,  788,  959,  788,\n /*   230 */   697,  788,  776,  788,  788,  866,  959,  959,  959,  760,\n /*   240 */   751,  959,  944,  767,  767,  936,  936,  767,  810,  732,\n /*   250 */   798,  739,  739,  739,  739,  767,  798,  810,  732,  732,\n /*   260 */   767,  658,  911,  909,  767,  767,  658,  767,  658,  767,\n /*   270 */   658,  876,  730,  730,  730,  715,  880,  880,  876,  730,\n /*   280 */   700,  730,  715,  730,  730,  780,  775,  780,  775,  780,\n /*   290 */   775,  767,  767,  959,  793,  781,  791,  789,  798,  959,\n /*   300 */   718,  651,  651,  640,  640,  640,  640,  956,  956,  951,\n /*   310 */   702,  702,  684,  959,  959,  959,  959,  959,  959,  959,\n /*   320 */   885,  959,  959,  959,  959,  959,  959,  959,  959,  959,\n /*   330 */   959,  959,  959,  959,  636,  946,  959,  959,  943,  959,\n /*   340 */   959,  959,  959,  959,  959,  959,  959,  959,  959,  959,\n /*   350 */   959,  959,  959,  959,  959,  959,  959,  959,  959,  915,\n /*   360 */   959,  959,  959,  959,  959,  959,  908,  907,  959,  959,\n /*   370 */   959,  959,  959,  959,  959,  959,  959,  959,  959,  959,\n /*   380 */   959,  959,  959,  959,  959,  959,  959,  959,  959,  959,\n /*   390 */   959,  959,  959,  959,  790,  959,  782,  959,  869,  959,\n /*   400 */   959,  959,  959,  959,  959,  959,  959,  959,  959,  745,\n /*   410 */   819,  959,  818,  822,  817,  668,  959,  649,  959,  632,\n /*   420 */   637,  955,  958,  957,  954,  953,  952,  947,  945,  942,\n /*   430 */   941,  940,  938,  935,  931,  889,  887,  894,  893,  892,\n /*   440 */   891,  890,  888,  886,  884,  805,  803,  800,  797,  930,\n /*   450 */   882,  741,  738,  737,  657,  948,  914,  923,  921,  811,\n /*   460 */   920,  919,  918,  916,  913,  900,  807,  806,  733,  874,\n /*   470 */   873,  660,  904,  903,  902,  906,  910,  901,  769,  659,\n /*   480 */   656,  665,  722,  721,  729,  727,  726,  725,  724,  723,\n /*   490 */   720,  667,  675,  686,  714,  699,  698,  879,  881,  878,\n /*   500 */   877,  707,  706,  712,  711,  710,  709,  708,  705,  704,\n /*   510 */   703,  696,  695,  701,  694,  717,  716,  713,  693,  736,\n /*   520 */   735,  734,  731,  692,  691,  690,  822,  689,  688,  828,\n /*   530 */   827,  815,  858,  756,  755,  754,  766,  765,  778,  777,\n /*   540 */   813,  812,  779,  764,  758,  757,  773,  772,  771,  770,\n /*   550 */   762,  752,  784,  787,  786,  783,  860,  768,  857,  929,\n /*   560 */   928,  927,  926,  925,  862,  861,  829,  826,  679,  680,\n /*   570 */   898,  896,  897,  895,  682,  681,  678,  677,  859,  747,\n /*   580 */   746,  855,  852,  844,  840,  856,  853,  845,  841,  839,\n /*   590 */   838,  824,  823,  821,  820,  816,  825,  670,  748,  744,\n /*   600 */   743,  814,  750,  749,  687,  685,  683,  664,  662,  655,\n /*   610 */   653,  652,  654,  650,  648,  647,  646,  645,  644,  673,\n /*   620 */   672,  671,  669,  668,  642,  639,  638,  634,  633,  631,\n};\n\n/* The next table maps tokens into fallback tokens.  If a construct\n** like the following:\n** \n**      %fallback ID X Y Z.\n**\n** appears in the grammar, then ID becomes a fallback token for X, Y,\n** and Z.  Whenever one of the tokens X, Y, or Z is input to the parser\n** but it does not parse, the type of the token is changed to ID and\n** the parse is retried before an error is thrown.\n*/\n#ifdef YYFALLBACK\nstatic const YYCODETYPE yyFallback[] = {\n    0,  /*          $ => nothing */\n    0,  /*       SEMI => nothing */\n   26,  /*    EXPLAIN => ID */\n   26,  /*      QUERY => ID */\n   26,  /*       PLAN => ID */\n   26,  /*      BEGIN => ID */\n    0,  /* TRANSACTION => nothing */\n   26,  /*   DEFERRED => ID */\n   26,  /*  IMMEDIATE => ID */\n   26,  /*  EXCLUSIVE => ID */\n    0,  /*     COMMIT => nothing */\n   26,  /*        END => ID */\n   26,  /*   ROLLBACK => ID */\n   26,  /*  SAVEPOINT => ID */\n   26,  /*    RELEASE => ID */\n    0,  /*         TO => nothing */\n    0,  /*      TABLE => nothing */\n    0,  /*     CREATE => nothing */\n   26,  /*         IF => ID */\n    0,  /*        NOT => nothing */\n    0,  /*     EXISTS => nothing */\n   26,  /*       TEMP => ID */\n    0,  /*         LP => nothing */\n    0,  /*         RP => nothing */\n    0,  /*         AS => nothing */\n    0,  /*      COMMA => nothing */\n    0,  /*         ID => nothing */\n    0,  /*    INDEXED => nothing */\n   26,  /*      ABORT => ID */\n   26,  /*     ACTION => ID */\n   26,  /*      AFTER => ID */\n   26,  /*    ANALYZE => ID */\n   26,  /*        ASC => ID */\n   26,  /*     ATTACH => ID */\n   26,  /*     BEFORE => ID */\n   26,  /*         BY => ID */\n   26,  /*    CASCADE => ID */\n   26,  /*       CAST => ID */\n   26,  /*   COLUMNKW => ID */\n   26,  /*   CONFLICT => ID */\n   26,  /*   DATABASE => ID */\n   26,  /*       DESC => ID */\n   26,  /*     DETACH => ID */\n   26,  /*       EACH => ID */\n   26,  /*       FAIL => ID */\n   26,  /*        FOR => ID */\n   26,  /*     IGNORE => ID */\n   26,  /*  INITIALLY => ID */\n   26,  /*    INSTEAD => ID */\n   26,  /*    LIKE_KW => ID */\n   26,  /*      MATCH => ID */\n   26,  /*         NO => ID */\n   26,  /*        KEY => ID */\n   26,  /*         OF => ID */\n   26,  /*     OFFSET => ID */\n   26,  /*     PRAGMA => ID */\n   26,  /*      RAISE => ID */\n   26,  /*    REPLACE => ID */\n   26,  /*   RESTRICT => ID */\n   26,  /*        ROW => ID */\n   26,  /*    TRIGGER => ID */\n   26,  /*     VACUUM => ID */\n   26,  /*       VIEW => ID */\n   26,  /*    VIRTUAL => ID */\n   26,  /*    REINDEX => ID */\n   26,  /*     RENAME => ID */\n   26,  /*   CTIME_KW => ID */\n};\n#endif /* YYFALLBACK */\n\n/* The following structure represents a single element of the\n** parser's stack.  Information stored includes:\n**\n**   +  The state number for the parser at this level of the stack.\n**\n**   +  The value of the token stored at this level of the stack.\n**      (In other words, the \"major\" token.)\n**\n**   +  The semantic value stored at this level of the stack.  This is\n**      the information used by the action routines in the grammar.\n**      It is sometimes called the \"minor\" token.\n*/\nstruct yyStackEntry {\n  YYACTIONTYPE stateno;  /* The state-number */\n  YYCODETYPE major;      /* The major token value.  This is the code\n                         ** number for the token at this stack level */\n  YYMINORTYPE minor;     /* The user-supplied minor token value.  This\n                         ** is the value of the token  */\n};\ntypedef struct yyStackEntry yyStackEntry;\n\n/* The state of the parser is completely contained in an instance of\n** the following structure */\nstruct yyParser {\n  int yyidx;                    /* Index of top element in stack */\n#ifdef YYTRACKMAXSTACKDEPTH\n  int yyidxMax;                 /* Maximum value of yyidx */\n#endif\n  int yyerrcnt;                 /* Shifts left before out of the error */\n  sqlite3ParserARG_SDECL                /* A place to hold %extra_argument */\n#if YYSTACKDEPTH<=0\n  int yystksz;                  /* Current side of the stack */\n  yyStackEntry *yystack;        /* The parser's stack */\n#else\n  yyStackEntry yystack[YYSTACKDEPTH];  /* The parser's stack */\n#endif\n};\ntypedef struct yyParser yyParser;\n\n#ifndef NDEBUG\nstatic FILE *yyTraceFILE = 0;\nstatic char *yyTracePrompt = 0;\n#endif /* NDEBUG */\n\n#ifndef NDEBUG\n/* \n** Turn parser tracing on by giving a stream to which to write the trace\n** and a prompt to preface each trace message.  Tracing is turned off\n** by making either argument NULL \n**\n** Inputs:\n** <ul>\n** <li> A FILE* to which trace output should be written.\n**      If NULL, then tracing is turned off.\n** <li> A prefix string written at the beginning of every\n**      line of trace output.  If NULL, then tracing is\n**      turned off.\n** </ul>\n**\n** Outputs:\n** None.\n*/\nSQLITE_PRIVATE void sqlite3ParserTrace(FILE *TraceFILE, char *zTracePrompt){\n  yyTraceFILE = TraceFILE;\n  yyTracePrompt = zTracePrompt;\n  if( yyTraceFILE==0 ) yyTracePrompt = 0;\n  else if( yyTracePrompt==0 ) yyTraceFILE = 0;\n}\n#endif /* NDEBUG */\n\n#ifndef NDEBUG\n/* For tracing shifts, the names of all terminals and nonterminals\n** are required.  The following table supplies these names */\nstatic const char *const yyTokenName[] = { \n  \"$\",             \"SEMI\",          \"EXPLAIN\",       \"QUERY\",       \n  \"PLAN\",          \"BEGIN\",         \"TRANSACTION\",   \"DEFERRED\",    \n  \"IMMEDIATE\",     \"EXCLUSIVE\",     \"COMMIT\",        \"END\",         \n  \"ROLLBACK\",      \"SAVEPOINT\",     \"RELEASE\",       \"TO\",          \n  \"TABLE\",         \"CREATE\",        \"IF\",            \"NOT\",         \n  \"EXISTS\",        \"TEMP\",          \"LP\",            \"RP\",          \n  \"AS\",            \"COMMA\",         \"ID\",            \"INDEXED\",     \n  \"ABORT\",         \"ACTION\",        \"AFTER\",         \"ANALYZE\",     \n  \"ASC\",           \"ATTACH\",        \"BEFORE\",        \"BY\",          \n  \"CASCADE\",       \"CAST\",          \"COLUMNKW\",      \"CONFLICT\",    \n  \"DATABASE\",      \"DESC\",          \"DETACH\",        \"EACH\",        \n  \"FAIL\",          \"FOR\",           \"IGNORE\",        \"INITIALLY\",   \n  \"INSTEAD\",       \"LIKE_KW\",       \"MATCH\",         \"NO\",          \n  \"KEY\",           \"OF\",            \"OFFSET\",        \"PRAGMA\",      \n  \"RAISE\",         \"REPLACE\",       \"RESTRICT\",      \"ROW\",         \n  \"TRIGGER\",       \"VACUUM\",        \"VIEW\",          \"VIRTUAL\",     \n  \"REINDEX\",       \"RENAME\",        \"CTIME_KW\",      \"ANY\",         \n  \"OR\",            \"AND\",           \"IS\",            \"BETWEEN\",     \n  \"IN\",            \"ISNULL\",        \"NOTNULL\",       \"NE\",          \n  \"EQ\",            \"GT\",            \"LE\",            \"LT\",          \n  \"GE\",            \"ESCAPE\",        \"BITAND\",        \"BITOR\",       \n  \"LSHIFT\",        \"RSHIFT\",        \"PLUS\",          \"MINUS\",       \n  \"STAR\",          \"SLASH\",         \"REM\",           \"CONCAT\",      \n  \"COLLATE\",       \"BITNOT\",        \"STRING\",        \"JOIN_KW\",     \n  \"CONSTRAINT\",    \"DEFAULT\",       \"NULL\",          \"PRIMARY\",     \n  \"UNIQUE\",        \"CHECK\",         \"REFERENCES\",    \"AUTOINCR\",    \n  \"ON\",            \"INSERT\",        \"DELETE\",        \"UPDATE\",      \n  \"SET\",           \"DEFERRABLE\",    \"FOREIGN\",       \"DROP\",        \n  \"UNION\",         \"ALL\",           \"EXCEPT\",        \"INTERSECT\",   \n  \"SELECT\",        \"DISTINCT\",      \"DOT\",           \"FROM\",        \n  \"JOIN\",          \"USING\",         \"ORDER\",         \"GROUP\",       \n  \"HAVING\",        \"LIMIT\",         \"WHERE\",         \"INTO\",        \n  \"VALUES\",        \"INTEGER\",       \"FLOAT\",         \"BLOB\",        \n  \"REGISTER\",      \"VARIABLE\",      \"CASE\",          \"WHEN\",        \n  \"THEN\",          \"ELSE\",          \"INDEX\",         \"ALTER\",       \n  \"ADD\",           \"error\",         \"input\",         \"cmdlist\",     \n  \"ecmd\",          \"explain\",       \"cmdx\",          \"cmd\",         \n  \"transtype\",     \"trans_opt\",     \"nm\",            \"savepoint_opt\",\n  \"create_table\",  \"create_table_args\",  \"createkw\",      \"temp\",        \n  \"ifnotexists\",   \"dbnm\",          \"columnlist\",    \"conslist_opt\",\n  \"select\",        \"column\",        \"columnid\",      \"type\",        \n  \"carglist\",      \"id\",            \"ids\",           \"typetoken\",   \n  \"typename\",      \"signed\",        \"plus_num\",      \"minus_num\",   \n  \"carg\",          \"ccons\",         \"term\",          \"expr\",        \n  \"onconf\",        \"sortorder\",     \"autoinc\",       \"idxlist_opt\", \n  \"refargs\",       \"defer_subclause\",  \"refarg\",        \"refact\",      \n  \"init_deferred_pred_opt\",  \"conslist\",      \"tcons\",         \"idxlist\",     \n  \"defer_subclause_opt\",  \"orconf\",        \"resolvetype\",   \"raisetype\",   \n  \"ifexists\",      \"fullname\",      \"oneselect\",     \"multiselect_op\",\n  \"distinct\",      \"selcollist\",    \"from\",          \"where_opt\",   \n  \"groupby_opt\",   \"having_opt\",    \"orderby_opt\",   \"limit_opt\",   \n  \"sclp\",          \"as\",            \"seltablist\",    \"stl_prefix\",  \n  \"joinop\",        \"indexed_opt\",   \"on_opt\",        \"using_opt\",   \n  \"joinop2\",       \"inscollist\",    \"sortlist\",      \"sortitem\",    \n  \"nexprlist\",     \"setlist\",       \"insert_cmd\",    \"inscollist_opt\",\n  \"itemlist\",      \"exprlist\",      \"likeop\",        \"between_op\",  \n  \"in_op\",         \"case_operand\",  \"case_exprlist\",  \"case_else\",   \n  \"uniqueflag\",    \"collate\",       \"nmnum\",         \"plus_opt\",    \n  \"number\",        \"trigger_decl\",  \"trigger_cmd_list\",  \"trigger_time\",\n  \"trigger_event\",  \"foreach_clause\",  \"when_clause\",   \"trigger_cmd\", \n  \"trnm\",          \"tridxby\",       \"database_kw_opt\",  \"key_opt\",     \n  \"add_column_fullname\",  \"kwcolumn_opt\",  \"create_vtab\",   \"vtabarglist\", \n  \"vtabarg\",       \"vtabargtoken\",  \"lp\",            \"anylist\",     \n};\n#endif /* NDEBUG */\n\n#ifndef NDEBUG\n/* For tracing reduce actions, the names of all rules are required.\n*/\nstatic const char *const yyRuleName[] = {\n /*   0 */ \"input ::= cmdlist\",\n /*   1 */ \"cmdlist ::= cmdlist ecmd\",\n /*   2 */ \"cmdlist ::= ecmd\",\n /*   3 */ \"ecmd ::= SEMI\",\n /*   4 */ \"ecmd ::= explain cmdx SEMI\",\n /*   5 */ \"explain ::=\",\n /*   6 */ \"explain ::= EXPLAIN\",\n /*   7 */ \"explain ::= EXPLAIN QUERY PLAN\",\n /*   8 */ \"cmdx ::= cmd\",\n /*   9 */ \"cmd ::= BEGIN transtype trans_opt\",\n /*  10 */ \"trans_opt ::=\",\n /*  11 */ \"trans_opt ::= TRANSACTION\",\n /*  12 */ \"trans_opt ::= TRANSACTION nm\",\n /*  13 */ \"transtype ::=\",\n /*  14 */ \"transtype ::= DEFERRED\",\n /*  15 */ \"transtype ::= IMMEDIATE\",\n /*  16 */ \"transtype ::= EXCLUSIVE\",\n /*  17 */ \"cmd ::= COMMIT trans_opt\",\n /*  18 */ \"cmd ::= END trans_opt\",\n /*  19 */ \"cmd ::= ROLLBACK trans_opt\",\n /*  20 */ \"savepoint_opt ::= SAVEPOINT\",\n /*  21 */ \"savepoint_opt ::=\",\n /*  22 */ \"cmd ::= SAVEPOINT nm\",\n /*  23 */ \"cmd ::= RELEASE savepoint_opt nm\",\n /*  24 */ \"cmd ::= ROLLBACK trans_opt TO savepoint_opt nm\",\n /*  25 */ \"cmd ::= create_table create_table_args\",\n /*  26 */ \"create_table ::= createkw temp TABLE ifnotexists nm dbnm\",\n /*  27 */ \"createkw ::= CREATE\",\n /*  28 */ \"ifnotexists ::=\",\n /*  29 */ \"ifnotexists ::= IF NOT EXISTS\",\n /*  30 */ \"temp ::= TEMP\",\n /*  31 */ \"temp ::=\",\n /*  32 */ \"create_table_args ::= LP columnlist conslist_opt RP\",\n /*  33 */ \"create_table_args ::= AS select\",\n /*  34 */ \"columnlist ::= columnlist COMMA column\",\n /*  35 */ \"columnlist ::= column\",\n /*  36 */ \"column ::= columnid type carglist\",\n /*  37 */ \"columnid ::= nm\",\n /*  38 */ \"id ::= ID\",\n /*  39 */ \"id ::= INDEXED\",\n /*  40 */ \"ids ::= ID|STRING\",\n /*  41 */ \"nm ::= id\",\n /*  42 */ \"nm ::= STRING\",\n /*  43 */ \"nm ::= JOIN_KW\",\n /*  44 */ \"type ::=\",\n /*  45 */ \"type ::= typetoken\",\n /*  46 */ \"typetoken ::= typename\",\n /*  47 */ \"typetoken ::= typename LP signed RP\",\n /*  48 */ \"typetoken ::= typename LP signed COMMA signed RP\",\n /*  49 */ \"typename ::= ids\",\n /*  50 */ \"typename ::= typename ids\",\n /*  51 */ \"signed ::= plus_num\",\n /*  52 */ \"signed ::= minus_num\",\n /*  53 */ \"carglist ::= carglist carg\",\n /*  54 */ \"carglist ::=\",\n /*  55 */ \"carg ::= CONSTRAINT nm ccons\",\n /*  56 */ \"carg ::= ccons\",\n /*  57 */ \"ccons ::= DEFAULT term\",\n /*  58 */ \"ccons ::= DEFAULT LP expr RP\",\n /*  59 */ \"ccons ::= DEFAULT PLUS term\",\n /*  60 */ \"ccons ::= DEFAULT MINUS term\",\n /*  61 */ \"ccons ::= DEFAULT id\",\n /*  62 */ \"ccons ::= NULL onconf\",\n /*  63 */ \"ccons ::= NOT NULL onconf\",\n /*  64 */ \"ccons ::= PRIMARY KEY sortorder onconf autoinc\",\n /*  65 */ \"ccons ::= UNIQUE onconf\",\n /*  66 */ \"ccons ::= CHECK LP expr RP\",\n /*  67 */ \"ccons ::= REFERENCES nm idxlist_opt refargs\",\n /*  68 */ \"ccons ::= defer_subclause\",\n /*  69 */ \"ccons ::= COLLATE ids\",\n /*  70 */ \"autoinc ::=\",\n /*  71 */ \"autoinc ::= AUTOINCR\",\n /*  72 */ \"refargs ::=\",\n /*  73 */ \"refargs ::= refargs refarg\",\n /*  74 */ \"refarg ::= MATCH nm\",\n /*  75 */ \"refarg ::= ON INSERT refact\",\n /*  76 */ \"refarg ::= ON DELETE refact\",\n /*  77 */ \"refarg ::= ON UPDATE refact\",\n /*  78 */ \"refact ::= SET NULL\",\n /*  79 */ \"refact ::= SET DEFAULT\",\n /*  80 */ \"refact ::= CASCADE\",\n /*  81 */ \"refact ::= RESTRICT\",\n /*  82 */ \"refact ::= NO ACTION\",\n /*  83 */ \"defer_subclause ::= NOT DEFERRABLE init_deferred_pred_opt\",\n /*  84 */ \"defer_subclause ::= DEFERRABLE init_deferred_pred_opt\",\n /*  85 */ \"init_deferred_pred_opt ::=\",\n /*  86 */ \"init_deferred_pred_opt ::= INITIALLY DEFERRED\",\n /*  87 */ \"init_deferred_pred_opt ::= INITIALLY IMMEDIATE\",\n /*  88 */ \"conslist_opt ::=\",\n /*  89 */ \"conslist_opt ::= COMMA conslist\",\n /*  90 */ \"conslist ::= conslist COMMA tcons\",\n /*  91 */ \"conslist ::= conslist tcons\",\n /*  92 */ \"conslist ::= tcons\",\n /*  93 */ \"tcons ::= CONSTRAINT nm\",\n /*  94 */ \"tcons ::= PRIMARY KEY LP idxlist autoinc RP onconf\",\n /*  95 */ \"tcons ::= UNIQUE LP idxlist RP onconf\",\n /*  96 */ \"tcons ::= CHECK LP expr RP onconf\",\n /*  97 */ \"tcons ::= FOREIGN KEY LP idxlist RP REFERENCES nm idxlist_opt refargs defer_subclause_opt\",\n /*  98 */ \"defer_subclause_opt ::=\",\n /*  99 */ \"defer_subclause_opt ::= defer_subclause\",\n /* 100 */ \"onconf ::=\",\n /* 101 */ \"onconf ::= ON CONFLICT resolvetype\",\n /* 102 */ \"orconf ::=\",\n /* 103 */ \"orconf ::= OR resolvetype\",\n /* 104 */ \"resolvetype ::= raisetype\",\n /* 105 */ \"resolvetype ::= IGNORE\",\n /* 106 */ \"resolvetype ::= REPLACE\",\n /* 107 */ \"cmd ::= DROP TABLE ifexists fullname\",\n /* 108 */ \"ifexists ::= IF EXISTS\",\n /* 109 */ \"ifexists ::=\",\n /* 110 */ \"cmd ::= createkw temp VIEW ifnotexists nm dbnm AS select\",\n /* 111 */ \"cmd ::= DROP VIEW ifexists fullname\",\n /* 112 */ \"cmd ::= select\",\n /* 113 */ \"select ::= oneselect\",\n /* 114 */ \"select ::= select multiselect_op oneselect\",\n /* 115 */ \"multiselect_op ::= UNION\",\n /* 116 */ \"multiselect_op ::= UNION ALL\",\n /* 117 */ \"multiselect_op ::= EXCEPT|INTERSECT\",\n /* 118 */ \"oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt\",\n /* 119 */ \"distinct ::= DISTINCT\",\n /* 120 */ \"distinct ::= ALL\",\n /* 121 */ \"distinct ::=\",\n /* 122 */ \"sclp ::= selcollist COMMA\",\n /* 123 */ \"sclp ::=\",\n /* 124 */ \"selcollist ::= sclp expr as\",\n /* 125 */ \"selcollist ::= sclp STAR\",\n /* 126 */ \"selcollist ::= sclp nm DOT STAR\",\n /* 127 */ \"as ::= AS nm\",\n /* 128 */ \"as ::= ids\",\n /* 129 */ \"as ::=\",\n /* 130 */ \"from ::=\",\n /* 131 */ \"from ::= FROM seltablist\",\n /* 132 */ \"stl_prefix ::= seltablist joinop\",\n /* 133 */ \"stl_prefix ::=\",\n /* 134 */ \"seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt\",\n /* 135 */ \"seltablist ::= stl_prefix LP select RP as on_opt using_opt\",\n /* 136 */ \"seltablist ::= stl_prefix LP seltablist RP as on_opt using_opt\",\n /* 137 */ \"dbnm ::=\",\n /* 138 */ \"dbnm ::= DOT nm\",\n /* 139 */ \"fullname ::= nm dbnm\",\n /* 140 */ \"joinop ::= COMMA|JOIN\",\n /* 141 */ \"joinop ::= JOIN_KW JOIN\",\n /* 142 */ \"joinop ::= JOIN_KW nm JOIN\",\n /* 143 */ \"joinop ::= JOIN_KW nm nm JOIN\",\n /* 144 */ \"on_opt ::= ON expr\",\n /* 145 */ \"on_opt ::=\",\n /* 146 */ \"indexed_opt ::=\",\n /* 147 */ \"indexed_opt ::= INDEXED BY nm\",\n /* 148 */ \"indexed_opt ::= NOT INDEXED\",\n /* 149 */ \"using_opt ::= USING LP inscollist RP\",\n /* 150 */ \"using_opt ::=\",\n /* 151 */ \"orderby_opt ::=\",\n /* 152 */ \"orderby_opt ::= ORDER BY sortlist\",\n /* 153 */ \"sortlist ::= sortlist COMMA sortitem sortorder\",\n /* 154 */ \"sortlist ::= sortitem sortorder\",\n /* 155 */ \"sortitem ::= expr\",\n /* 156 */ \"sortorder ::= ASC\",\n /* 157 */ \"sortorder ::= DESC\",\n /* 158 */ \"sortorder ::=\",\n /* 159 */ \"groupby_opt ::=\",\n /* 160 */ \"groupby_opt ::= GROUP BY nexprlist\",\n /* 161 */ \"having_opt ::=\",\n /* 162 */ \"having_opt ::= HAVING expr\",\n /* 163 */ \"limit_opt ::=\",\n /* 164 */ \"limit_opt ::= LIMIT expr\",\n /* 165 */ \"limit_opt ::= LIMIT expr OFFSET expr\",\n /* 166 */ \"limit_opt ::= LIMIT expr COMMA expr\",\n /* 167 */ \"cmd ::= DELETE FROM fullname indexed_opt where_opt\",\n /* 168 */ \"where_opt ::=\",\n /* 169 */ \"where_opt ::= WHERE expr\",\n /* 170 */ \"cmd ::= UPDATE orconf fullname indexed_opt SET setlist where_opt\",\n /* 171 */ \"setlist ::= setlist COMMA nm EQ expr\",\n /* 172 */ \"setlist ::= nm EQ expr\",\n /* 173 */ \"cmd ::= insert_cmd INTO fullname inscollist_opt VALUES LP itemlist RP\",\n /* 174 */ \"cmd ::= insert_cmd INTO fullname inscollist_opt select\",\n /* 175 */ \"cmd ::= insert_cmd INTO fullname inscollist_opt DEFAULT VALUES\",\n /* 176 */ \"insert_cmd ::= INSERT orconf\",\n /* 177 */ \"insert_cmd ::= REPLACE\",\n /* 178 */ \"itemlist ::= itemlist COMMA expr\",\n /* 179 */ \"itemlist ::= expr\",\n /* 180 */ \"inscollist_opt ::=\",\n /* 181 */ \"inscollist_opt ::= LP inscollist RP\",\n /* 182 */ \"inscollist ::= inscollist COMMA nm\",\n /* 183 */ \"inscollist ::= nm\",\n /* 184 */ \"expr ::= term\",\n /* 185 */ \"expr ::= LP expr RP\",\n /* 186 */ \"term ::= NULL\",\n /* 187 */ \"expr ::= id\",\n /* 188 */ \"expr ::= JOIN_KW\",\n /* 189 */ \"expr ::= nm DOT nm\",\n /* 190 */ \"expr ::= nm DOT nm DOT nm\",\n /* 191 */ \"term ::= INTEGER|FLOAT|BLOB\",\n /* 192 */ \"term ::= STRING\",\n /* 193 */ \"expr ::= REGISTER\",\n /* 194 */ \"expr ::= VARIABLE\",\n /* 195 */ \"expr ::= expr COLLATE ids\",\n /* 196 */ \"expr ::= CAST LP expr AS typetoken RP\",\n /* 197 */ \"expr ::= ID LP distinct exprlist RP\",\n /* 198 */ \"expr ::= ID LP STAR RP\",\n /* 199 */ \"term ::= CTIME_KW\",\n /* 200 */ \"expr ::= expr AND expr\",\n /* 201 */ \"expr ::= expr OR expr\",\n /* 202 */ \"expr ::= expr LT|GT|GE|LE expr\",\n /* 203 */ \"expr ::= expr EQ|NE expr\",\n /* 204 */ \"expr ::= expr BITAND|BITOR|LSHIFT|RSHIFT expr\",\n /* 205 */ \"expr ::= expr PLUS|MINUS expr\",\n /* 206 */ \"expr ::= expr STAR|SLASH|REM expr\",\n /* 207 */ \"expr ::= expr CONCAT expr\",\n /* 208 */ \"likeop ::= LIKE_KW\",\n /* 209 */ \"likeop ::= NOT LIKE_KW\",\n /* 210 */ \"likeop ::= MATCH\",\n /* 211 */ \"likeop ::= NOT MATCH\",\n /* 212 */ \"expr ::= expr likeop expr\",\n /* 213 */ \"expr ::= expr likeop expr ESCAPE expr\",\n /* 214 */ \"expr ::= expr ISNULL|NOTNULL\",\n /* 215 */ \"expr ::= expr NOT NULL\",\n /* 216 */ \"expr ::= expr IS expr\",\n /* 217 */ \"expr ::= expr IS NOT expr\",\n /* 218 */ \"expr ::= NOT expr\",\n /* 219 */ \"expr ::= BITNOT expr\",\n /* 220 */ \"expr ::= MINUS expr\",\n /* 221 */ \"expr ::= PLUS expr\",\n /* 222 */ \"between_op ::= BETWEEN\",\n /* 223 */ \"between_op ::= NOT BETWEEN\",\n /* 224 */ \"expr ::= expr between_op expr AND expr\",\n /* 225 */ \"in_op ::= IN\",\n /* 226 */ \"in_op ::= NOT IN\",\n /* 227 */ \"expr ::= expr in_op LP exprlist RP\",\n /* 228 */ \"expr ::= LP select RP\",\n /* 229 */ \"expr ::= expr in_op LP select RP\",\n /* 230 */ \"expr ::= expr in_op nm dbnm\",\n /* 231 */ \"expr ::= EXISTS LP select RP\",\n /* 232 */ \"expr ::= CASE case_operand case_exprlist case_else END\",\n /* 233 */ \"case_exprlist ::= case_exprlist WHEN expr THEN expr\",\n /* 234 */ \"case_exprlist ::= WHEN expr THEN expr\",\n /* 235 */ \"case_else ::= ELSE expr\",\n /* 236 */ \"case_else ::=\",\n /* 237 */ \"case_operand ::= expr\",\n /* 238 */ \"case_operand ::=\",\n /* 239 */ \"exprlist ::= nexprlist\",\n /* 240 */ \"exprlist ::=\",\n /* 241 */ \"nexprlist ::= nexprlist COMMA expr\",\n /* 242 */ \"nexprlist ::= expr\",\n /* 243 */ \"cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP idxlist RP\",\n /* 244 */ \"uniqueflag ::= UNIQUE\",\n /* 245 */ \"uniqueflag ::=\",\n /* 246 */ \"idxlist_opt ::=\",\n /* 247 */ \"idxlist_opt ::= LP idxlist RP\",\n /* 248 */ \"idxlist ::= idxlist COMMA nm collate sortorder\",\n /* 249 */ \"idxlist ::= nm collate sortorder\",\n /* 250 */ \"collate ::=\",\n /* 251 */ \"collate ::= COLLATE ids\",\n /* 252 */ \"cmd ::= DROP INDEX ifexists fullname\",\n /* 253 */ \"cmd ::= VACUUM\",\n /* 254 */ \"cmd ::= VACUUM nm\",\n /* 255 */ \"cmd ::= PRAGMA nm dbnm\",\n /* 256 */ \"cmd ::= PRAGMA nm dbnm EQ nmnum\",\n /* 257 */ \"cmd ::= PRAGMA nm dbnm LP nmnum RP\",\n /* 258 */ \"cmd ::= PRAGMA nm dbnm EQ minus_num\",\n /* 259 */ \"cmd ::= PRAGMA nm dbnm LP minus_num RP\",\n /* 260 */ \"nmnum ::= plus_num\",\n /* 261 */ \"nmnum ::= nm\",\n /* 262 */ \"nmnum ::= ON\",\n /* 263 */ \"nmnum ::= DELETE\",\n /* 264 */ \"nmnum ::= DEFAULT\",\n /* 265 */ \"plus_num ::= plus_opt number\",\n /* 266 */ \"minus_num ::= MINUS number\",\n /* 267 */ \"number ::= INTEGER|FLOAT\",\n /* 268 */ \"plus_opt ::= PLUS\",\n /* 269 */ \"plus_opt ::=\",\n /* 270 */ \"cmd ::= createkw trigger_decl BEGIN trigger_cmd_list END\",\n /* 271 */ \"trigger_decl ::= temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON fullname foreach_clause when_clause\",\n /* 272 */ \"trigger_time ::= BEFORE\",\n /* 273 */ \"trigger_time ::= AFTER\",\n /* 274 */ \"trigger_time ::= INSTEAD OF\",\n /* 275 */ \"trigger_time ::=\",\n /* 276 */ \"trigger_event ::= DELETE|INSERT\",\n /* 277 */ \"trigger_event ::= UPDATE\",\n /* 278 */ \"trigger_event ::= UPDATE OF inscollist\",\n /* 279 */ \"foreach_clause ::=\",\n /* 280 */ \"foreach_clause ::= FOR EACH ROW\",\n /* 281 */ \"when_clause ::=\",\n /* 282 */ \"when_clause ::= WHEN expr\",\n /* 283 */ \"trigger_cmd_list ::= trigger_cmd_list trigger_cmd SEMI\",\n /* 284 */ \"trigger_cmd_list ::= trigger_cmd SEMI\",\n /* 285 */ \"trnm ::= nm\",\n /* 286 */ \"trnm ::= nm DOT nm\",\n /* 287 */ \"tridxby ::=\",\n /* 288 */ \"tridxby ::= INDEXED BY nm\",\n /* 289 */ \"tridxby ::= NOT INDEXED\",\n /* 290 */ \"trigger_cmd ::= UPDATE orconf trnm tridxby SET setlist where_opt\",\n /* 291 */ \"trigger_cmd ::= insert_cmd INTO trnm inscollist_opt VALUES LP itemlist RP\",\n /* 292 */ \"trigger_cmd ::= insert_cmd INTO trnm inscollist_opt select\",\n /* 293 */ \"trigger_cmd ::= DELETE FROM trnm tridxby where_opt\",\n /* 294 */ \"trigger_cmd ::= select\",\n /* 295 */ \"expr ::= RAISE LP IGNORE RP\",\n /* 296 */ \"expr ::= RAISE LP raisetype COMMA nm RP\",\n /* 297 */ \"raisetype ::= ROLLBACK\",\n /* 298 */ \"raisetype ::= ABORT\",\n /* 299 */ \"raisetype ::= FAIL\",\n /* 300 */ \"cmd ::= DROP TRIGGER ifexists fullname\",\n /* 301 */ \"cmd ::= ATTACH database_kw_opt expr AS expr key_opt\",\n /* 302 */ \"cmd ::= DETACH database_kw_opt expr\",\n /* 303 */ \"key_opt ::=\",\n /* 304 */ \"key_opt ::= KEY expr\",\n /* 305 */ \"database_kw_opt ::= DATABASE\",\n /* 306 */ \"database_kw_opt ::=\",\n /* 307 */ \"cmd ::= REINDEX\",\n /* 308 */ \"cmd ::= REINDEX nm dbnm\",\n /* 309 */ \"cmd ::= ANALYZE\",\n /* 310 */ \"cmd ::= ANALYZE nm dbnm\",\n /* 311 */ \"cmd ::= ALTER TABLE fullname RENAME TO nm\",\n /* 312 */ \"cmd ::= ALTER TABLE add_column_fullname ADD kwcolumn_opt column\",\n /* 313 */ \"add_column_fullname ::= fullname\",\n /* 314 */ \"kwcolumn_opt ::=\",\n /* 315 */ \"kwcolumn_opt ::= COLUMNKW\",\n /* 316 */ \"cmd ::= create_vtab\",\n /* 317 */ \"cmd ::= create_vtab LP vtabarglist RP\",\n /* 318 */ \"create_vtab ::= createkw VIRTUAL TABLE nm dbnm USING nm\",\n /* 319 */ \"vtabarglist ::= vtabarg\",\n /* 320 */ \"vtabarglist ::= vtabarglist COMMA vtabarg\",\n /* 321 */ \"vtabarg ::=\",\n /* 322 */ \"vtabarg ::= vtabarg vtabargtoken\",\n /* 323 */ \"vtabargtoken ::= ANY\",\n /* 324 */ \"vtabargtoken ::= lp anylist RP\",\n /* 325 */ \"lp ::= LP\",\n /* 326 */ \"anylist ::=\",\n /* 327 */ \"anylist ::= anylist LP anylist RP\",\n /* 328 */ \"anylist ::= anylist ANY\",\n};\n#endif /* NDEBUG */\n\n\n#if YYSTACKDEPTH<=0\n/*\n** Try to increase the size of the parser stack.\n*/\nstatic void yyGrowStack(yyParser *p){\n  int newSize;\n  yyStackEntry *pNew;\n\n  newSize = p->yystksz*2 + 100;\n  pNew = realloc(p->yystack, newSize*sizeof(pNew[0]));\n  if( pNew ){\n    p->yystack = pNew;\n    p->yystksz = newSize;\n#ifndef NDEBUG\n    if( yyTraceFILE ){\n      fprintf(yyTraceFILE,\"%sStack grows to %d entries!\\n\",\n              yyTracePrompt, p->yystksz);\n    }\n#endif\n  }\n}\n#endif\n\n/* \n** This function allocates a new parser.\n** The only argument is a pointer to a function which works like\n** malloc.\n**\n** Inputs:\n** A pointer to the function used to allocate memory.\n**\n** Outputs:\n** A pointer to a parser.  This pointer is used in subsequent calls\n** to sqlite3Parser and sqlite3ParserFree.\n*/\nSQLITE_PRIVATE void *sqlite3ParserAlloc(void *(*mallocProc)(size_t)){\n  yyParser *pParser;\n  pParser = (yyParser*)(*mallocProc)( (size_t)sizeof(yyParser) );\n  if( pParser ){\n    pParser->yyidx = -1;\n#ifdef YYTRACKMAXSTACKDEPTH\n    pParser->yyidxMax = 0;\n#endif\n#if YYSTACKDEPTH<=0\n    pParser->yystack = NULL;\n    pParser->yystksz = 0;\n    yyGrowStack(pParser);\n#endif\n  }\n  return pParser;\n}\n\n/* The following function deletes the value associated with a\n** symbol.  The symbol can be either a terminal or nonterminal.\n** \"yymajor\" is the symbol code, and \"yypminor\" is a pointer to\n** the value.\n*/\nstatic void yy_destructor(\n  yyParser *yypParser,    /* The parser */\n  YYCODETYPE yymajor,     /* Type code for object to destroy */\n  YYMINORTYPE *yypminor   /* The object to be destroyed */\n){\n  sqlite3ParserARG_FETCH;\n  switch( yymajor ){\n    /* Here is inserted the actions which take place when a\n    ** terminal or non-terminal is destroyed.  This can happen\n    ** when the symbol is popped from the stack during a\n    ** reduce or during error processing or when a parser is \n    ** being destroyed before it is finished parsing.\n    **\n    ** Note: during a reduce, the only symbols destroyed are those\n    ** which appear on the RHS of the rule, but which are not used\n    ** inside the C code.\n    */\n    case 160: /* select */\n    case 194: /* oneselect */\n{\nsqlite3SelectDelete(pParse->db, (yypminor->yy387));\n}\n      break;\n    case 174: /* term */\n    case 175: /* expr */\n{\nsqlite3ExprDelete(pParse->db, (yypminor->yy118).pExpr);\n}\n      break;\n    case 179: /* idxlist_opt */\n    case 187: /* idxlist */\n    case 197: /* selcollist */\n    case 200: /* groupby_opt */\n    case 202: /* orderby_opt */\n    case 204: /* sclp */\n    case 214: /* sortlist */\n    case 216: /* nexprlist */\n    case 217: /* setlist */\n    case 220: /* itemlist */\n    case 221: /* exprlist */\n    case 226: /* case_exprlist */\n{\nsqlite3ExprListDelete(pParse->db, (yypminor->yy322));\n}\n      break;\n    case 193: /* fullname */\n    case 198: /* from */\n    case 206: /* seltablist */\n    case 207: /* stl_prefix */\n{\nsqlite3SrcListDelete(pParse->db, (yypminor->yy259));\n}\n      break;\n    case 199: /* where_opt */\n    case 201: /* having_opt */\n    case 210: /* on_opt */\n    case 215: /* sortitem */\n    case 225: /* case_operand */\n    case 227: /* case_else */\n    case 238: /* when_clause */\n    case 243: /* key_opt */\n{\nsqlite3ExprDelete(pParse->db, (yypminor->yy314));\n}\n      break;\n    case 211: /* using_opt */\n    case 213: /* inscollist */\n    case 219: /* inscollist_opt */\n{\nsqlite3IdListDelete(pParse->db, (yypminor->yy384));\n}\n      break;\n    case 234: /* trigger_cmd_list */\n    case 239: /* trigger_cmd */\n{\nsqlite3DeleteTriggerStep(pParse->db, (yypminor->yy203));\n}\n      break;\n    case 236: /* trigger_event */\n{\nsqlite3IdListDelete(pParse->db, (yypminor->yy90).b);\n}\n      break;\n    default:  break;   /* If no destructor action specified: do nothing */\n  }\n}\n\n/*\n** Pop the parser's stack once.\n**\n** If there is a destructor routine associated with the token which\n** is popped from the stack, then call it.\n**\n** Return the major token number for the symbol popped.\n*/\nstatic int yy_pop_parser_stack(yyParser *pParser){\n  YYCODETYPE yymajor;\n  yyStackEntry *yytos = &pParser->yystack[pParser->yyidx];\n\n  /* There is no mechanism by which the parser stack can be popped below\n  ** empty in SQLite.  */\n  if( NEVER(pParser->yyidx<0) ) return 0;\n#ifndef NDEBUG\n  if( yyTraceFILE && pParser->yyidx>=0 ){\n    fprintf(yyTraceFILE,\"%sPopping %s\\n\",\n      yyTracePrompt,\n      yyTokenName[yytos->major]);\n  }\n#endif\n  yymajor = yytos->major;\n  yy_destructor(pParser, yymajor, &yytos->minor);\n  pParser->yyidx--;\n  return yymajor;\n}\n\n/* \n** Deallocate and destroy a parser.  Destructors are all called for\n** all stack elements before shutting the parser down.\n**\n** Inputs:\n** <ul>\n** <li>  A pointer to the parser.  This should be a pointer\n**       obtained from sqlite3ParserAlloc.\n** <li>  A pointer to a function used to reclaim memory obtained\n**       from malloc.\n** </ul>\n*/\nSQLITE_PRIVATE void sqlite3ParserFree(\n  void *p,                    /* The parser to be deleted */\n  void (*freeProc)(void*)     /* Function used to reclaim memory */\n){\n  yyParser *pParser = (yyParser*)p;\n  /* In SQLite, we never try to destroy a parser that was not successfully\n  ** created in the first place. */\n  if( NEVER(pParser==0) ) return;\n  while( pParser->yyidx>=0 ) yy_pop_parser_stack(pParser);\n#if YYSTACKDEPTH<=0\n  free(pParser->yystack);\n#endif\n  (*freeProc)((void*)pParser);\n}\n\n/*\n** Return the peak depth of the stack for a parser.\n*/\n#ifdef YYTRACKMAXSTACKDEPTH\nSQLITE_PRIVATE int sqlite3ParserStackPeak(void *p){\n  yyParser *pParser = (yyParser*)p;\n  return pParser->yyidxMax;\n}\n#endif\n\n/*\n** Find the appropriate action for a parser given the terminal\n** look-ahead token iLookAhead.\n**\n** If the look-ahead token is YYNOCODE, then check to see if the action is\n** independent of the look-ahead.  If it is, return the action, otherwise\n** return YY_NO_ACTION.\n*/\nstatic int yy_find_shift_action(\n  yyParser *pParser,        /* The parser */\n  YYCODETYPE iLookAhead     /* The look-ahead token */\n){\n  int i;\n  int stateno = pParser->yystack[pParser->yyidx].stateno;\n \n  if( stateno>YY_SHIFT_COUNT\n   || (i = yy_shift_ofst[stateno])==YY_SHIFT_USE_DFLT ){\n    return yy_default[stateno];\n  }\n  assert( iLookAhead!=YYNOCODE );\n  i += iLookAhead;\n  if( i<0 || i>=YY_ACTTAB_COUNT || yy_lookahead[i]!=iLookAhead ){\n    if( iLookAhead>0 ){\n#ifdef YYFALLBACK\n      YYCODETYPE iFallback;            /* Fallback token */\n      if( iLookAhead<sizeof(yyFallback)/sizeof(yyFallback[0])\n             && (iFallback = yyFallback[iLookAhead])!=0 ){\n#ifndef NDEBUG\n        if( yyTraceFILE ){\n          fprintf(yyTraceFILE, \"%sFALLBACK %s => %s\\n\",\n             yyTracePrompt, yyTokenName[iLookAhead], yyTokenName[iFallback]);\n        }\n#endif\n        return yy_find_shift_action(pParser, iFallback);\n      }\n#endif\n#ifdef YYWILDCARD\n      {\n        int j = i - iLookAhead + YYWILDCARD;\n        if( \n#if YY_SHIFT_MIN+YYWILDCARD<0\n          j>=0 &&\n#endif\n#if YY_SHIFT_MAX+YYWILDCARD>=YY_ACTTAB_COUNT\n          j<YY_ACTTAB_COUNT &&\n#endif\n          yy_lookahead[j]==YYWILDCARD\n        ){\n#ifndef NDEBUG\n          if( yyTraceFILE ){\n            fprintf(yyTraceFILE, \"%sWILDCARD %s => %s\\n\",\n               yyTracePrompt, yyTokenName[iLookAhead], yyTokenName[YYWILDCARD]);\n          }\n#endif /* NDEBUG */\n          return yy_action[j];\n        }\n      }\n#endif /* YYWILDCARD */\n    }\n    return yy_default[stateno];\n  }else{\n    return yy_action[i];\n  }\n}\n\n/*\n** Find the appropriate action for a parser given the non-terminal\n** look-ahead token iLookAhead.\n**\n** If the look-ahead token is YYNOCODE, then check to see if the action is\n** independent of the look-ahead.  If it is, return the action, otherwise\n** return YY_NO_ACTION.\n*/\nstatic int yy_find_reduce_action(\n  int stateno,              /* Current state number */\n  YYCODETYPE iLookAhead     /* The look-ahead token */\n){\n  int i;\n#ifdef YYERRORSYMBOL\n  if( stateno>YY_REDUCE_COUNT ){\n    return yy_default[stateno];\n  }\n#else\n  assert( stateno<=YY_REDUCE_COUNT );\n#endif\n  i = yy_reduce_ofst[stateno];\n  assert( i!=YY_REDUCE_USE_DFLT );\n  assert( iLookAhead!=YYNOCODE );\n  i += iLookAhead;\n#ifdef YYERRORSYMBOL\n  if( i<0 || i>=YY_ACTTAB_COUNT || yy_lookahead[i]!=iLookAhead ){\n    return yy_default[stateno];\n  }\n#else\n  assert( i>=0 && i<YY_ACTTAB_COUNT );\n  assert( yy_lookahead[i]==iLookAhead );\n#endif\n  return yy_action[i];\n}\n\n/*\n** The following routine is called if the stack overflows.\n*/\nstatic void yyStackOverflow(yyParser *yypParser, YYMINORTYPE *yypMinor){\n   sqlite3ParserARG_FETCH;\n   yypParser->yyidx--;\n#ifndef NDEBUG\n   if( yyTraceFILE ){\n     fprintf(yyTraceFILE,\"%sStack Overflow!\\n\",yyTracePrompt);\n   }\n#endif\n   while( yypParser->yyidx>=0 ) yy_pop_parser_stack(yypParser);\n   /* Here code is inserted which will execute if the parser\n   ** stack every overflows */\n\n  UNUSED_PARAMETER(yypMinor); /* Silence some compiler warnings */\n  sqlite3ErrorMsg(pParse, \"parser stack overflow\");\n  pParse->parseError = 1;\n   sqlite3ParserARG_STORE; /* Suppress warning about unused %extra_argument var */\n}\n\n/*\n** Perform a shift action.\n*/\nstatic void yy_shift(\n  yyParser *yypParser,          /* The parser to be shifted */\n  int yyNewState,               /* The new state to shift in */\n  int yyMajor,                  /* The major token to shift in */\n  YYMINORTYPE *yypMinor         /* Pointer to the minor token to shift in */\n){\n  yyStackEntry *yytos;\n  yypParser->yyidx++;\n#ifdef YYTRACKMAXSTACKDEPTH\n  if( yypParser->yyidx>yypParser->yyidxMax ){\n    yypParser->yyidxMax = yypParser->yyidx;\n  }\n#endif\n#if YYSTACKDEPTH>0 \n  if( yypParser->yyidx>=YYSTACKDEPTH ){\n    yyStackOverflow(yypParser, yypMinor);\n    return;\n  }\n#else\n  if( yypParser->yyidx>=yypParser->yystksz ){\n    yyGrowStack(yypParser);\n    if( yypParser->yyidx>=yypParser->yystksz ){\n      yyStackOverflow(yypParser, yypMinor);\n      return;\n    }\n  }\n#endif\n  yytos = &yypParser->yystack[yypParser->yyidx];\n  yytos->stateno = (YYACTIONTYPE)yyNewState;\n  yytos->major = (YYCODETYPE)yyMajor;\n  yytos->minor = *yypMinor;\n#ifndef NDEBUG\n  if( yyTraceFILE && yypParser->yyidx>0 ){\n    int i;\n    fprintf(yyTraceFILE,\"%sShift %d\\n\",yyTracePrompt,yyNewState);\n    fprintf(yyTraceFILE,\"%sStack:\",yyTracePrompt);\n    for(i=1; i<=yypParser->yyidx; i++)\n      fprintf(yyTraceFILE,\" %s\",yyTokenName[yypParser->yystack[i].major]);\n    fprintf(yyTraceFILE,\"\\n\");\n  }\n#endif\n}\n\n/* The following table contains information about every rule that\n** is used during the reduce.\n*/\nstatic const struct {\n  YYCODETYPE lhs;         /* Symbol on the left-hand side of the rule */\n  unsigned char nrhs;     /* Number of right-hand side symbols in the rule */\n} yyRuleInfo[] = {\n  { 142, 1 },\n  { 143, 2 },\n  { 143, 1 },\n  { 144, 1 },\n  { 144, 3 },\n  { 145, 0 },\n  { 145, 1 },\n  { 145, 3 },\n  { 146, 1 },\n  { 147, 3 },\n  { 149, 0 },\n  { 149, 1 },\n  { 149, 2 },\n  { 148, 0 },\n  { 148, 1 },\n  { 148, 1 },\n  { 148, 1 },\n  { 147, 2 },\n  { 147, 2 },\n  { 147, 2 },\n  { 151, 1 },\n  { 151, 0 },\n  { 147, 2 },\n  { 147, 3 },\n  { 147, 5 },\n  { 147, 2 },\n  { 152, 6 },\n  { 154, 1 },\n  { 156, 0 },\n  { 156, 3 },\n  { 155, 1 },\n  { 155, 0 },\n  { 153, 4 },\n  { 153, 2 },\n  { 158, 3 },\n  { 158, 1 },\n  { 161, 3 },\n  { 162, 1 },\n  { 165, 1 },\n  { 165, 1 },\n  { 166, 1 },\n  { 150, 1 },\n  { 150, 1 },\n  { 150, 1 },\n  { 163, 0 },\n  { 163, 1 },\n  { 167, 1 },\n  { 167, 4 },\n  { 167, 6 },\n  { 168, 1 },\n  { 168, 2 },\n  { 169, 1 },\n  { 169, 1 },\n  { 164, 2 },\n  { 164, 0 },\n  { 172, 3 },\n  { 172, 1 },\n  { 173, 2 },\n  { 173, 4 },\n  { 173, 3 },\n  { 173, 3 },\n  { 173, 2 },\n  { 173, 2 },\n  { 173, 3 },\n  { 173, 5 },\n  { 173, 2 },\n  { 173, 4 },\n  { 173, 4 },\n  { 173, 1 },\n  { 173, 2 },\n  { 178, 0 },\n  { 178, 1 },\n  { 180, 0 },\n  { 180, 2 },\n  { 182, 2 },\n  { 182, 3 },\n  { 182, 3 },\n  { 182, 3 },\n  { 183, 2 },\n  { 183, 2 },\n  { 183, 1 },\n  { 183, 1 },\n  { 183, 2 },\n  { 181, 3 },\n  { 181, 2 },\n  { 184, 0 },\n  { 184, 2 },\n  { 184, 2 },\n  { 159, 0 },\n  { 159, 2 },\n  { 185, 3 },\n  { 185, 2 },\n  { 185, 1 },\n  { 186, 2 },\n  { 186, 7 },\n  { 186, 5 },\n  { 186, 5 },\n  { 186, 10 },\n  { 188, 0 },\n  { 188, 1 },\n  { 176, 0 },\n  { 176, 3 },\n  { 189, 0 },\n  { 189, 2 },\n  { 190, 1 },\n  { 190, 1 },\n  { 190, 1 },\n  { 147, 4 },\n  { 192, 2 },\n  { 192, 0 },\n  { 147, 8 },\n  { 147, 4 },\n  { 147, 1 },\n  { 160, 1 },\n  { 160, 3 },\n  { 195, 1 },\n  { 195, 2 },\n  { 195, 1 },\n  { 194, 9 },\n  { 196, 1 },\n  { 196, 1 },\n  { 196, 0 },\n  { 204, 2 },\n  { 204, 0 },\n  { 197, 3 },\n  { 197, 2 },\n  { 197, 4 },\n  { 205, 2 },\n  { 205, 1 },\n  { 205, 0 },\n  { 198, 0 },\n  { 198, 2 },\n  { 207, 2 },\n  { 207, 0 },\n  { 206, 7 },\n  { 206, 7 },\n  { 206, 7 },\n  { 157, 0 },\n  { 157, 2 },\n  { 193, 2 },\n  { 208, 1 },\n  { 208, 2 },\n  { 208, 3 },\n  { 208, 4 },\n  { 210, 2 },\n  { 210, 0 },\n  { 209, 0 },\n  { 209, 3 },\n  { 209, 2 },\n  { 211, 4 },\n  { 211, 0 },\n  { 202, 0 },\n  { 202, 3 },\n  { 214, 4 },\n  { 214, 2 },\n  { 215, 1 },\n  { 177, 1 },\n  { 177, 1 },\n  { 177, 0 },\n  { 200, 0 },\n  { 200, 3 },\n  { 201, 0 },\n  { 201, 2 },\n  { 203, 0 },\n  { 203, 2 },\n  { 203, 4 },\n  { 203, 4 },\n  { 147, 5 },\n  { 199, 0 },\n  { 199, 2 },\n  { 147, 7 },\n  { 217, 5 },\n  { 217, 3 },\n  { 147, 8 },\n  { 147, 5 },\n  { 147, 6 },\n  { 218, 2 },\n  { 218, 1 },\n  { 220, 3 },\n  { 220, 1 },\n  { 219, 0 },\n  { 219, 3 },\n  { 213, 3 },\n  { 213, 1 },\n  { 175, 1 },\n  { 175, 3 },\n  { 174, 1 },\n  { 175, 1 },\n  { 175, 1 },\n  { 175, 3 },\n  { 175, 5 },\n  { 174, 1 },\n  { 174, 1 },\n  { 175, 1 },\n  { 175, 1 },\n  { 175, 3 },\n  { 175, 6 },\n  { 175, 5 },\n  { 175, 4 },\n  { 174, 1 },\n  { 175, 3 },\n  { 175, 3 },\n  { 175, 3 },\n  { 175, 3 },\n  { 175, 3 },\n  { 175, 3 },\n  { 175, 3 },\n  { 175, 3 },\n  { 222, 1 },\n  { 222, 2 },\n  { 222, 1 },\n  { 222, 2 },\n  { 175, 3 },\n  { 175, 5 },\n  { 175, 2 },\n  { 175, 3 },\n  { 175, 3 },\n  { 175, 4 },\n  { 175, 2 },\n  { 175, 2 },\n  { 175, 2 },\n  { 175, 2 },\n  { 223, 1 },\n  { 223, 2 },\n  { 175, 5 },\n  { 224, 1 },\n  { 224, 2 },\n  { 175, 5 },\n  { 175, 3 },\n  { 175, 5 },\n  { 175, 4 },\n  { 175, 4 },\n  { 175, 5 },\n  { 226, 5 },\n  { 226, 4 },\n  { 227, 2 },\n  { 227, 0 },\n  { 225, 1 },\n  { 225, 0 },\n  { 221, 1 },\n  { 221, 0 },\n  { 216, 3 },\n  { 216, 1 },\n  { 147, 11 },\n  { 228, 1 },\n  { 228, 0 },\n  { 179, 0 },\n  { 179, 3 },\n  { 187, 5 },\n  { 187, 3 },\n  { 229, 0 },\n  { 229, 2 },\n  { 147, 4 },\n  { 147, 1 },\n  { 147, 2 },\n  { 147, 3 },\n  { 147, 5 },\n  { 147, 6 },\n  { 147, 5 },\n  { 147, 6 },\n  { 230, 1 },\n  { 230, 1 },\n  { 230, 1 },\n  { 230, 1 },\n  { 230, 1 },\n  { 170, 2 },\n  { 171, 2 },\n  { 232, 1 },\n  { 231, 1 },\n  { 231, 0 },\n  { 147, 5 },\n  { 233, 11 },\n  { 235, 1 },\n  { 235, 1 },\n  { 235, 2 },\n  { 235, 0 },\n  { 236, 1 },\n  { 236, 1 },\n  { 236, 3 },\n  { 237, 0 },\n  { 237, 3 },\n  { 238, 0 },\n  { 238, 2 },\n  { 234, 3 },\n  { 234, 2 },\n  { 240, 1 },\n  { 240, 3 },\n  { 241, 0 },\n  { 241, 3 },\n  { 241, 2 },\n  { 239, 7 },\n  { 239, 8 },\n  { 239, 5 },\n  { 239, 5 },\n  { 239, 1 },\n  { 175, 4 },\n  { 175, 6 },\n  { 191, 1 },\n  { 191, 1 },\n  { 191, 1 },\n  { 147, 4 },\n  { 147, 6 },\n  { 147, 3 },\n  { 243, 0 },\n  { 243, 2 },\n  { 242, 1 },\n  { 242, 0 },\n  { 147, 1 },\n  { 147, 3 },\n  { 147, 1 },\n  { 147, 3 },\n  { 147, 6 },\n  { 147, 6 },\n  { 244, 1 },\n  { 245, 0 },\n  { 245, 1 },\n  { 147, 1 },\n  { 147, 4 },\n  { 246, 7 },\n  { 247, 1 },\n  { 247, 3 },\n  { 248, 0 },\n  { 248, 2 },\n  { 249, 1 },\n  { 249, 3 },\n  { 250, 1 },\n  { 251, 0 },\n  { 251, 4 },\n  { 251, 2 },\n};\n\nstatic void yy_accept(yyParser*);  /* Forward Declaration */\n\n/*\n** Perform a reduce action and the shift that must immediately\n** follow the reduce.\n*/\nstatic void yy_reduce(\n  yyParser *yypParser,         /* The parser */\n  int yyruleno                 /* Number of the rule by which to reduce */\n){\n  int yygoto;                     /* The next state */\n  int yyact;                      /* The next action */\n  YYMINORTYPE yygotominor;        /* The LHS of the rule reduced */\n  yyStackEntry *yymsp;            /* The top of the parser's stack */\n  int yysize;                     /* Amount to pop the stack */\n  sqlite3ParserARG_FETCH;\n  yymsp = &yypParser->yystack[yypParser->yyidx];\n#ifndef NDEBUG\n  if( yyTraceFILE && yyruleno>=0 \n        && yyruleno<(int)(sizeof(yyRuleName)/sizeof(yyRuleName[0])) ){\n    fprintf(yyTraceFILE, \"%sReduce [%s].\\n\", yyTracePrompt,\n      yyRuleName[yyruleno]);\n  }\n#endif /* NDEBUG */\n\n  /* Silence complaints from purify about yygotominor being uninitialized\n  ** in some cases when it is copied into the stack after the following\n  ** switch.  yygotominor is uninitialized when a rule reduces that does\n  ** not set the value of its left-hand side nonterminal.  Leaving the\n  ** value of the nonterminal uninitialized is utterly harmless as long\n  ** as the value is never used.  So really the only thing this code\n  ** accomplishes is to quieten purify.  \n  **\n  ** 2007-01-16:  The wireshark project (www.wireshark.org) reports that\n  ** without this code, their parser segfaults.  I'm not sure what there\n  ** parser is doing to make this happen.  This is the second bug report\n  ** from wireshark this week.  Clearly they are stressing Lemon in ways\n  ** that it has not been previously stressed...  (SQLite ticket #2172)\n  */\n  /*memset(&yygotominor, 0, sizeof(yygotominor));*/\n  yygotominor = yyzerominor;\n\n\n  switch( yyruleno ){\n  /* Beginning here are the reduction cases.  A typical example\n  ** follows:\n  **   case 0:\n  **  #line <lineno> <grammarfile>\n  **     { ... }           // User supplied code\n  **  #line <lineno> <thisfile>\n  **     break;\n  */\n      case 5: /* explain ::= */\n{ sqlite3BeginParse(pParse, 0); }\n        break;\n      case 6: /* explain ::= EXPLAIN */\n{ sqlite3BeginParse(pParse, 1); }\n        break;\n      case 7: /* explain ::= EXPLAIN QUERY PLAN */\n{ sqlite3BeginParse(pParse, 2); }\n        break;\n      case 8: /* cmdx ::= cmd */\n{ sqlite3FinishCoding(pParse); }\n        break;\n      case 9: /* cmd ::= BEGIN transtype trans_opt */\n{sqlite3BeginTransaction(pParse, yymsp[-1].minor.yy4);}\n        break;\n      case 13: /* transtype ::= */\n{yygotominor.yy4 = TK_DEFERRED;}\n        break;\n      case 14: /* transtype ::= DEFERRED */\n      case 15: /* transtype ::= IMMEDIATE */ yytestcase(yyruleno==15);\n      case 16: /* transtype ::= EXCLUSIVE */ yytestcase(yyruleno==16);\n      case 115: /* multiselect_op ::= UNION */ yytestcase(yyruleno==115);\n      case 117: /* multiselect_op ::= EXCEPT|INTERSECT */ yytestcase(yyruleno==117);\n{yygotominor.yy4 = yymsp[0].major;}\n        break;\n      case 17: /* cmd ::= COMMIT trans_opt */\n      case 18: /* cmd ::= END trans_opt */ yytestcase(yyruleno==18);\n{sqlite3CommitTransaction(pParse);}\n        break;\n      case 19: /* cmd ::= ROLLBACK trans_opt */\n{sqlite3RollbackTransaction(pParse);}\n        break;\n      case 22: /* cmd ::= SAVEPOINT nm */\n{\n  sqlite3Savepoint(pParse, SAVEPOINT_BEGIN, &yymsp[0].minor.yy0);\n}\n        break;\n      case 23: /* cmd ::= RELEASE savepoint_opt nm */\n{\n  sqlite3Savepoint(pParse, SAVEPOINT_RELEASE, &yymsp[0].minor.yy0);\n}\n        break;\n      case 24: /* cmd ::= ROLLBACK trans_opt TO savepoint_opt nm */\n{\n  sqlite3Savepoint(pParse, SAVEPOINT_ROLLBACK, &yymsp[0].minor.yy0);\n}\n        break;\n      case 26: /* create_table ::= createkw temp TABLE ifnotexists nm dbnm */\n{\n   sqlite3StartTable(pParse,&yymsp[-1].minor.yy0,&yymsp[0].minor.yy0,yymsp[-4].minor.yy4,0,0,yymsp[-2].minor.yy4);\n}\n        break;\n      case 27: /* createkw ::= CREATE */\n{\n  pParse->db->lookaside.bEnabled = 0;\n  yygotominor.yy0 = yymsp[0].minor.yy0;\n}\n        break;\n      case 28: /* ifnotexists ::= */\n      case 31: /* temp ::= */ yytestcase(yyruleno==31);\n      case 70: /* autoinc ::= */ yytestcase(yyruleno==70);\n      case 83: /* defer_subclause ::= NOT DEFERRABLE init_deferred_pred_opt */ yytestcase(yyruleno==83);\n      case 85: /* init_deferred_pred_opt ::= */ yytestcase(yyruleno==85);\n      case 87: /* init_deferred_pred_opt ::= INITIALLY IMMEDIATE */ yytestcase(yyruleno==87);\n      case 98: /* defer_subclause_opt ::= */ yytestcase(yyruleno==98);\n      case 109: /* ifexists ::= */ yytestcase(yyruleno==109);\n      case 120: /* distinct ::= ALL */ yytestcase(yyruleno==120);\n      case 121: /* distinct ::= */ yytestcase(yyruleno==121);\n      case 222: /* between_op ::= BETWEEN */ yytestcase(yyruleno==222);\n      case 225: /* in_op ::= IN */ yytestcase(yyruleno==225);\n{yygotominor.yy4 = 0;}\n        break;\n      case 29: /* ifnotexists ::= IF NOT EXISTS */\n      case 30: /* temp ::= TEMP */ yytestcase(yyruleno==30);\n      case 71: /* autoinc ::= AUTOINCR */ yytestcase(yyruleno==71);\n      case 86: /* init_deferred_pred_opt ::= INITIALLY DEFERRED */ yytestcase(yyruleno==86);\n      case 108: /* ifexists ::= IF EXISTS */ yytestcase(yyruleno==108);\n      case 119: /* distinct ::= DISTINCT */ yytestcase(yyruleno==119);\n      case 223: /* between_op ::= NOT BETWEEN */ yytestcase(yyruleno==223);\n      case 226: /* in_op ::= NOT IN */ yytestcase(yyruleno==226);\n{yygotominor.yy4 = 1;}\n        break;\n      case 32: /* create_table_args ::= LP columnlist conslist_opt RP */\n{\n  sqlite3EndTable(pParse,&yymsp[-1].minor.yy0,&yymsp[0].minor.yy0,0);\n}\n        break;\n      case 33: /* create_table_args ::= AS select */\n{\n  sqlite3EndTable(pParse,0,0,yymsp[0].minor.yy387);\n  sqlite3SelectDelete(pParse->db, yymsp[0].minor.yy387);\n}\n        break;\n      case 36: /* column ::= columnid type carglist */\n{\n  yygotominor.yy0.z = yymsp[-2].minor.yy0.z;\n  yygotominor.yy0.n = (int)(pParse->sLastToken.z-yymsp[-2].minor.yy0.z) + pParse->sLastToken.n;\n}\n        break;\n      case 37: /* columnid ::= nm */\n{\n  sqlite3AddColumn(pParse,&yymsp[0].minor.yy0);\n  yygotominor.yy0 = yymsp[0].minor.yy0;\n}\n        break;\n      case 38: /* id ::= ID */\n      case 39: /* id ::= INDEXED */ yytestcase(yyruleno==39);\n      case 40: /* ids ::= ID|STRING */ yytestcase(yyruleno==40);\n      case 41: /* nm ::= id */ yytestcase(yyruleno==41);\n      case 42: /* nm ::= STRING */ yytestcase(yyruleno==42);\n      case 43: /* nm ::= JOIN_KW */ yytestcase(yyruleno==43);\n      case 46: /* typetoken ::= typename */ yytestcase(yyruleno==46);\n      case 49: /* typename ::= ids */ yytestcase(yyruleno==49);\n      case 127: /* as ::= AS nm */ yytestcase(yyruleno==127);\n      case 128: /* as ::= ids */ yytestcase(yyruleno==128);\n      case 138: /* dbnm ::= DOT nm */ yytestcase(yyruleno==138);\n      case 147: /* indexed_opt ::= INDEXED BY nm */ yytestcase(yyruleno==147);\n      case 251: /* collate ::= COLLATE ids */ yytestcase(yyruleno==251);\n      case 260: /* nmnum ::= plus_num */ yytestcase(yyruleno==260);\n      case 261: /* nmnum ::= nm */ yytestcase(yyruleno==261);\n      case 262: /* nmnum ::= ON */ yytestcase(yyruleno==262);\n      case 263: /* nmnum ::= DELETE */ yytestcase(yyruleno==263);\n      case 264: /* nmnum ::= DEFAULT */ yytestcase(yyruleno==264);\n      case 265: /* plus_num ::= plus_opt number */ yytestcase(yyruleno==265);\n      case 266: /* minus_num ::= MINUS number */ yytestcase(yyruleno==266);\n      case 267: /* number ::= INTEGER|FLOAT */ yytestcase(yyruleno==267);\n      case 285: /* trnm ::= nm */ yytestcase(yyruleno==285);\n{yygotominor.yy0 = yymsp[0].minor.yy0;}\n        break;\n      case 45: /* type ::= typetoken */\n{sqlite3AddColumnType(pParse,&yymsp[0].minor.yy0);}\n        break;\n      case 47: /* typetoken ::= typename LP signed RP */\n{\n  yygotominor.yy0.z = yymsp[-3].minor.yy0.z;\n  yygotominor.yy0.n = (int)(&yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n] - yymsp[-3].minor.yy0.z);\n}\n        break;\n      case 48: /* typetoken ::= typename LP signed COMMA signed RP */\n{\n  yygotominor.yy0.z = yymsp[-5].minor.yy0.z;\n  yygotominor.yy0.n = (int)(&yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n] - yymsp[-5].minor.yy0.z);\n}\n        break;\n      case 50: /* typename ::= typename ids */\n{yygotominor.yy0.z=yymsp[-1].minor.yy0.z; yygotominor.yy0.n=yymsp[0].minor.yy0.n+(int)(yymsp[0].minor.yy0.z-yymsp[-1].minor.yy0.z);}\n        break;\n      case 57: /* ccons ::= DEFAULT term */\n      case 59: /* ccons ::= DEFAULT PLUS term */ yytestcase(yyruleno==59);\n{sqlite3AddDefaultValue(pParse,&yymsp[0].minor.yy118);}\n        break;\n      case 58: /* ccons ::= DEFAULT LP expr RP */\n{sqlite3AddDefaultValue(pParse,&yymsp[-1].minor.yy118);}\n        break;\n      case 60: /* ccons ::= DEFAULT MINUS term */\n{\n  ExprSpan v;\n  v.pExpr = sqlite3PExpr(pParse, TK_UMINUS, yymsp[0].minor.yy118.pExpr, 0, 0);\n  v.zStart = yymsp[-1].minor.yy0.z;\n  v.zEnd = yymsp[0].minor.yy118.zEnd;\n  sqlite3AddDefaultValue(pParse,&v);\n}\n        break;\n      case 61: /* ccons ::= DEFAULT id */\n{\n  ExprSpan v;\n  spanExpr(&v, pParse, TK_STRING, &yymsp[0].minor.yy0);\n  sqlite3AddDefaultValue(pParse,&v);\n}\n        break;\n      case 63: /* ccons ::= NOT NULL onconf */\n{sqlite3AddNotNull(pParse, yymsp[0].minor.yy4);}\n        break;\n      case 64: /* ccons ::= PRIMARY KEY sortorder onconf autoinc */\n{sqlite3AddPrimaryKey(pParse,0,yymsp[-1].minor.yy4,yymsp[0].minor.yy4,yymsp[-2].minor.yy4);}\n        break;\n      case 65: /* ccons ::= UNIQUE onconf */\n{sqlite3CreateIndex(pParse,0,0,0,0,yymsp[0].minor.yy4,0,0,0,0);}\n        break;\n      case 66: /* ccons ::= CHECK LP expr RP */\n{sqlite3AddCheckConstraint(pParse,yymsp[-1].minor.yy118.pExpr);}\n        break;\n      case 67: /* ccons ::= REFERENCES nm idxlist_opt refargs */\n{sqlite3CreateForeignKey(pParse,0,&yymsp[-2].minor.yy0,yymsp[-1].minor.yy322,yymsp[0].minor.yy4);}\n        break;\n      case 68: /* ccons ::= defer_subclause */\n{sqlite3DeferForeignKey(pParse,yymsp[0].minor.yy4);}\n        break;\n      case 69: /* ccons ::= COLLATE ids */\n{sqlite3AddCollateType(pParse, &yymsp[0].minor.yy0);}\n        break;\n      case 72: /* refargs ::= */\n{ yygotominor.yy4 = OE_None*0x0101; /* EV: R-19803-45884 */}\n        break;\n      case 73: /* refargs ::= refargs refarg */\n{ yygotominor.yy4 = (yymsp[-1].minor.yy4 & ~yymsp[0].minor.yy215.mask) | yymsp[0].minor.yy215.value; }\n        break;\n      case 74: /* refarg ::= MATCH nm */\n      case 75: /* refarg ::= ON INSERT refact */ yytestcase(yyruleno==75);\n{ yygotominor.yy215.value = 0;     yygotominor.yy215.mask = 0x000000; }\n        break;\n      case 76: /* refarg ::= ON DELETE refact */\n{ yygotominor.yy215.value = yymsp[0].minor.yy4;     yygotominor.yy215.mask = 0x0000ff; }\n        break;\n      case 77: /* refarg ::= ON UPDATE refact */\n{ yygotominor.yy215.value = yymsp[0].minor.yy4<<8;  yygotominor.yy215.mask = 0x00ff00; }\n        break;\n      case 78: /* refact ::= SET NULL */\n{ yygotominor.yy4 = OE_SetNull;  /* EV: R-33326-45252 */}\n        break;\n      case 79: /* refact ::= SET DEFAULT */\n{ yygotominor.yy4 = OE_SetDflt;  /* EV: R-33326-45252 */}\n        break;\n      case 80: /* refact ::= CASCADE */\n{ yygotominor.yy4 = OE_Cascade;  /* EV: R-33326-45252 */}\n        break;\n      case 81: /* refact ::= RESTRICT */\n{ yygotominor.yy4 = OE_Restrict; /* EV: R-33326-45252 */}\n        break;\n      case 82: /* refact ::= NO ACTION */\n{ yygotominor.yy4 = OE_None;     /* EV: R-33326-45252 */}\n        break;\n      case 84: /* defer_subclause ::= DEFERRABLE init_deferred_pred_opt */\n      case 99: /* defer_subclause_opt ::= defer_subclause */ yytestcase(yyruleno==99);\n      case 101: /* onconf ::= ON CONFLICT resolvetype */ yytestcase(yyruleno==101);\n      case 104: /* resolvetype ::= raisetype */ yytestcase(yyruleno==104);\n{yygotominor.yy4 = yymsp[0].minor.yy4;}\n        break;\n      case 88: /* conslist_opt ::= */\n{yygotominor.yy0.n = 0; yygotominor.yy0.z = 0;}\n        break;\n      case 89: /* conslist_opt ::= COMMA conslist */\n{yygotominor.yy0 = yymsp[-1].minor.yy0;}\n        break;\n      case 94: /* tcons ::= PRIMARY KEY LP idxlist autoinc RP onconf */\n{sqlite3AddPrimaryKey(pParse,yymsp[-3].minor.yy322,yymsp[0].minor.yy4,yymsp[-2].minor.yy4,0);}\n        break;\n      case 95: /* tcons ::= UNIQUE LP idxlist RP onconf */\n{sqlite3CreateIndex(pParse,0,0,0,yymsp[-2].minor.yy322,yymsp[0].minor.yy4,0,0,0,0);}\n        break;\n      case 96: /* tcons ::= CHECK LP expr RP onconf */\n{sqlite3AddCheckConstraint(pParse,yymsp[-2].minor.yy118.pExpr);}\n        break;\n      case 97: /* tcons ::= FOREIGN KEY LP idxlist RP REFERENCES nm idxlist_opt refargs defer_subclause_opt */\n{\n    sqlite3CreateForeignKey(pParse, yymsp[-6].minor.yy322, &yymsp[-3].minor.yy0, yymsp[-2].minor.yy322, yymsp[-1].minor.yy4);\n    sqlite3DeferForeignKey(pParse, yymsp[0].minor.yy4);\n}\n        break;\n      case 100: /* onconf ::= */\n{yygotominor.yy4 = OE_Default;}\n        break;\n      case 102: /* orconf ::= */\n{yygotominor.yy210 = OE_Default;}\n        break;\n      case 103: /* orconf ::= OR resolvetype */\n{yygotominor.yy210 = (u8)yymsp[0].minor.yy4;}\n        break;\n      case 105: /* resolvetype ::= IGNORE */\n{yygotominor.yy4 = OE_Ignore;}\n        break;\n      case 106: /* resolvetype ::= REPLACE */\n{yygotominor.yy4 = OE_Replace;}\n        break;\n      case 107: /* cmd ::= DROP TABLE ifexists fullname */\n{\n  sqlite3DropTable(pParse, yymsp[0].minor.yy259, 0, yymsp[-1].minor.yy4);\n}\n        break;\n      case 110: /* cmd ::= createkw temp VIEW ifnotexists nm dbnm AS select */\n{\n  sqlite3CreateView(pParse, &yymsp[-7].minor.yy0, &yymsp[-3].minor.yy0, &yymsp[-2].minor.yy0, yymsp[0].minor.yy387, yymsp[-6].minor.yy4, yymsp[-4].minor.yy4);\n}\n        break;\n      case 111: /* cmd ::= DROP VIEW ifexists fullname */\n{\n  sqlite3DropTable(pParse, yymsp[0].minor.yy259, 1, yymsp[-1].minor.yy4);\n}\n        break;\n      case 112: /* cmd ::= select */\n{\n  SelectDest dest = {SRT_Output, 0, 0, 0, 0};\n  sqlite3Select(pParse, yymsp[0].minor.yy387, &dest);\n  sqlite3SelectDelete(pParse->db, yymsp[0].minor.yy387);\n}\n        break;\n      case 113: /* select ::= oneselect */\n{yygotominor.yy387 = yymsp[0].minor.yy387;}\n        break;\n      case 114: /* select ::= select multiselect_op oneselect */\n{\n  if( yymsp[0].minor.yy387 ){\n    yymsp[0].minor.yy387->op = (u8)yymsp[-1].minor.yy4;\n    yymsp[0].minor.yy387->pPrior = yymsp[-2].minor.yy387;\n  }else{\n    sqlite3SelectDelete(pParse->db, yymsp[-2].minor.yy387);\n  }\n  yygotominor.yy387 = yymsp[0].minor.yy387;\n}\n        break;\n      case 116: /* multiselect_op ::= UNION ALL */\n{yygotominor.yy4 = TK_ALL;}\n        break;\n      case 118: /* oneselect ::= SELECT distinct selcollist from where_opt groupby_opt having_opt orderby_opt limit_opt */\n{\n  yygotominor.yy387 = sqlite3SelectNew(pParse,yymsp[-6].minor.yy322,yymsp[-5].minor.yy259,yymsp[-4].minor.yy314,yymsp[-3].minor.yy322,yymsp[-2].minor.yy314,yymsp[-1].minor.yy322,yymsp[-7].minor.yy4,yymsp[0].minor.yy292.pLimit,yymsp[0].minor.yy292.pOffset);\n}\n        break;\n      case 122: /* sclp ::= selcollist COMMA */\n      case 247: /* idxlist_opt ::= LP idxlist RP */ yytestcase(yyruleno==247);\n{yygotominor.yy322 = yymsp[-1].minor.yy322;}\n        break;\n      case 123: /* sclp ::= */\n      case 151: /* orderby_opt ::= */ yytestcase(yyruleno==151);\n      case 159: /* groupby_opt ::= */ yytestcase(yyruleno==159);\n      case 240: /* exprlist ::= */ yytestcase(yyruleno==240);\n      case 246: /* idxlist_opt ::= */ yytestcase(yyruleno==246);\n{yygotominor.yy322 = 0;}\n        break;\n      case 124: /* selcollist ::= sclp expr as */\n{\n   yygotominor.yy322 = sqlite3ExprListAppend(pParse, yymsp[-2].minor.yy322, yymsp[-1].minor.yy118.pExpr);\n   if( yymsp[0].minor.yy0.n>0 ) sqlite3ExprListSetName(pParse, yygotominor.yy322, &yymsp[0].minor.yy0, 1);\n   sqlite3ExprListSetSpan(pParse,yygotominor.yy322,&yymsp[-1].minor.yy118);\n}\n        break;\n      case 125: /* selcollist ::= sclp STAR */\n{\n  Expr *p = sqlite3Expr(pParse->db, TK_ALL, 0);\n  yygotominor.yy322 = sqlite3ExprListAppend(pParse, yymsp[-1].minor.yy322, p);\n}\n        break;\n      case 126: /* selcollist ::= sclp nm DOT STAR */\n{\n  Expr *pRight = sqlite3PExpr(pParse, TK_ALL, 0, 0, &yymsp[0].minor.yy0);\n  Expr *pLeft = sqlite3PExpr(pParse, TK_ID, 0, 0, &yymsp[-2].minor.yy0);\n  Expr *pDot = sqlite3PExpr(pParse, TK_DOT, pLeft, pRight, 0);\n  yygotominor.yy322 = sqlite3ExprListAppend(pParse,yymsp[-3].minor.yy322, pDot);\n}\n        break;\n      case 129: /* as ::= */\n{yygotominor.yy0.n = 0;}\n        break;\n      case 130: /* from ::= */\n{yygotominor.yy259 = sqlite3DbMallocZero(pParse->db, sizeof(*yygotominor.yy259));}\n        break;\n      case 131: /* from ::= FROM seltablist */\n{\n  yygotominor.yy259 = yymsp[0].minor.yy259;\n  sqlite3SrcListShiftJoinType(yygotominor.yy259);\n}\n        break;\n      case 132: /* stl_prefix ::= seltablist joinop */\n{\n   yygotominor.yy259 = yymsp[-1].minor.yy259;\n   if( ALWAYS(yygotominor.yy259 && yygotominor.yy259->nSrc>0) ) yygotominor.yy259->a[yygotominor.yy259->nSrc-1].jointype = (u8)yymsp[0].minor.yy4;\n}\n        break;\n      case 133: /* stl_prefix ::= */\n{yygotominor.yy259 = 0;}\n        break;\n      case 134: /* seltablist ::= stl_prefix nm dbnm as indexed_opt on_opt using_opt */\n{\n  yygotominor.yy259 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-6].minor.yy259,&yymsp[-5].minor.yy0,&yymsp[-4].minor.yy0,&yymsp[-3].minor.yy0,0,yymsp[-1].minor.yy314,yymsp[0].minor.yy384);\n  sqlite3SrcListIndexedBy(pParse, yygotominor.yy259, &yymsp[-2].minor.yy0);\n}\n        break;\n      case 135: /* seltablist ::= stl_prefix LP select RP as on_opt using_opt */\n{\n    yygotominor.yy259 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-6].minor.yy259,0,0,&yymsp[-2].minor.yy0,yymsp[-4].minor.yy387,yymsp[-1].minor.yy314,yymsp[0].minor.yy384);\n  }\n        break;\n      case 136: /* seltablist ::= stl_prefix LP seltablist RP as on_opt using_opt */\n{\n    if( yymsp[-6].minor.yy259==0 && yymsp[-2].minor.yy0.n==0 && yymsp[-1].minor.yy314==0 && yymsp[0].minor.yy384==0 ){\n      yygotominor.yy259 = yymsp[-4].minor.yy259;\n    }else{\n      Select *pSubquery;\n      sqlite3SrcListShiftJoinType(yymsp[-4].minor.yy259);\n      pSubquery = sqlite3SelectNew(pParse,0,yymsp[-4].minor.yy259,0,0,0,0,0,0,0);\n      yygotominor.yy259 = sqlite3SrcListAppendFromTerm(pParse,yymsp[-6].minor.yy259,0,0,&yymsp[-2].minor.yy0,pSubquery,yymsp[-1].minor.yy314,yymsp[0].minor.yy384);\n    }\n  }\n        break;\n      case 137: /* dbnm ::= */\n      case 146: /* indexed_opt ::= */ yytestcase(yyruleno==146);\n{yygotominor.yy0.z=0; yygotominor.yy0.n=0;}\n        break;\n      case 139: /* fullname ::= nm dbnm */\n{yygotominor.yy259 = sqlite3SrcListAppend(pParse->db,0,&yymsp[-1].minor.yy0,&yymsp[0].minor.yy0);}\n        break;\n      case 140: /* joinop ::= COMMA|JOIN */\n{ yygotominor.yy4 = JT_INNER; }\n        break;\n      case 141: /* joinop ::= JOIN_KW JOIN */\n{ yygotominor.yy4 = sqlite3JoinType(pParse,&yymsp[-1].minor.yy0,0,0); }\n        break;\n      case 142: /* joinop ::= JOIN_KW nm JOIN */\n{ yygotominor.yy4 = sqlite3JoinType(pParse,&yymsp[-2].minor.yy0,&yymsp[-1].minor.yy0,0); }\n        break;\n      case 143: /* joinop ::= JOIN_KW nm nm JOIN */\n{ yygotominor.yy4 = sqlite3JoinType(pParse,&yymsp[-3].minor.yy0,&yymsp[-2].minor.yy0,&yymsp[-1].minor.yy0); }\n        break;\n      case 144: /* on_opt ::= ON expr */\n      case 155: /* sortitem ::= expr */ yytestcase(yyruleno==155);\n      case 162: /* having_opt ::= HAVING expr */ yytestcase(yyruleno==162);\n      case 169: /* where_opt ::= WHERE expr */ yytestcase(yyruleno==169);\n      case 235: /* case_else ::= ELSE expr */ yytestcase(yyruleno==235);\n      case 237: /* case_operand ::= expr */ yytestcase(yyruleno==237);\n{yygotominor.yy314 = yymsp[0].minor.yy118.pExpr;}\n        break;\n      case 145: /* on_opt ::= */\n      case 161: /* having_opt ::= */ yytestcase(yyruleno==161);\n      case 168: /* where_opt ::= */ yytestcase(yyruleno==168);\n      case 236: /* case_else ::= */ yytestcase(yyruleno==236);\n      case 238: /* case_operand ::= */ yytestcase(yyruleno==238);\n{yygotominor.yy314 = 0;}\n        break;\n      case 148: /* indexed_opt ::= NOT INDEXED */\n{yygotominor.yy0.z=0; yygotominor.yy0.n=1;}\n        break;\n      case 149: /* using_opt ::= USING LP inscollist RP */\n      case 181: /* inscollist_opt ::= LP inscollist RP */ yytestcase(yyruleno==181);\n{yygotominor.yy384 = yymsp[-1].minor.yy384;}\n        break;\n      case 150: /* using_opt ::= */\n      case 180: /* inscollist_opt ::= */ yytestcase(yyruleno==180);\n{yygotominor.yy384 = 0;}\n        break;\n      case 152: /* orderby_opt ::= ORDER BY sortlist */\n      case 160: /* groupby_opt ::= GROUP BY nexprlist */ yytestcase(yyruleno==160);\n      case 239: /* exprlist ::= nexprlist */ yytestcase(yyruleno==239);\n{yygotominor.yy322 = yymsp[0].minor.yy322;}\n        break;\n      case 153: /* sortlist ::= sortlist COMMA sortitem sortorder */\n{\n  yygotominor.yy322 = sqlite3ExprListAppend(pParse,yymsp[-3].minor.yy322,yymsp[-1].minor.yy314);\n  if( yygotominor.yy322 ) yygotominor.yy322->a[yygotominor.yy322->nExpr-1].sortOrder = (u8)yymsp[0].minor.yy4;\n}\n        break;\n      case 154: /* sortlist ::= sortitem sortorder */\n{\n  yygotominor.yy322 = sqlite3ExprListAppend(pParse,0,yymsp[-1].minor.yy314);\n  if( yygotominor.yy322 && ALWAYS(yygotominor.yy322->a) ) yygotominor.yy322->a[0].sortOrder = (u8)yymsp[0].minor.yy4;\n}\n        break;\n      case 156: /* sortorder ::= ASC */\n      case 158: /* sortorder ::= */ yytestcase(yyruleno==158);\n{yygotominor.yy4 = SQLITE_SO_ASC;}\n        break;\n      case 157: /* sortorder ::= DESC */\n{yygotominor.yy4 = SQLITE_SO_DESC;}\n        break;\n      case 163: /* limit_opt ::= */\n{yygotominor.yy292.pLimit = 0; yygotominor.yy292.pOffset = 0;}\n        break;\n      case 164: /* limit_opt ::= LIMIT expr */\n{yygotominor.yy292.pLimit = yymsp[0].minor.yy118.pExpr; yygotominor.yy292.pOffset = 0;}\n        break;\n      case 165: /* limit_opt ::= LIMIT expr OFFSET expr */\n{yygotominor.yy292.pLimit = yymsp[-2].minor.yy118.pExpr; yygotominor.yy292.pOffset = yymsp[0].minor.yy118.pExpr;}\n        break;\n      case 166: /* limit_opt ::= LIMIT expr COMMA expr */\n{yygotominor.yy292.pOffset = yymsp[-2].minor.yy118.pExpr; yygotominor.yy292.pLimit = yymsp[0].minor.yy118.pExpr;}\n        break;\n      case 167: /* cmd ::= DELETE FROM fullname indexed_opt where_opt */\n{\n  sqlite3SrcListIndexedBy(pParse, yymsp[-2].minor.yy259, &yymsp[-1].minor.yy0);\n  sqlite3DeleteFrom(pParse,yymsp[-2].minor.yy259,yymsp[0].minor.yy314);\n}\n        break;\n      case 170: /* cmd ::= UPDATE orconf fullname indexed_opt SET setlist where_opt */\n{\n  sqlite3SrcListIndexedBy(pParse, yymsp[-4].minor.yy259, &yymsp[-3].minor.yy0);\n  sqlite3ExprListCheckLength(pParse,yymsp[-1].minor.yy322,\"set list\"); \n  sqlite3Update(pParse,yymsp[-4].minor.yy259,yymsp[-1].minor.yy322,yymsp[0].minor.yy314,yymsp[-5].minor.yy210);\n}\n        break;\n      case 171: /* setlist ::= setlist COMMA nm EQ expr */\n{\n  yygotominor.yy322 = sqlite3ExprListAppend(pParse, yymsp[-4].minor.yy322, yymsp[0].minor.yy118.pExpr);\n  sqlite3ExprListSetName(pParse, yygotominor.yy322, &yymsp[-2].minor.yy0, 1);\n}\n        break;\n      case 172: /* setlist ::= nm EQ expr */\n{\n  yygotominor.yy322 = sqlite3ExprListAppend(pParse, 0, yymsp[0].minor.yy118.pExpr);\n  sqlite3ExprListSetName(pParse, yygotominor.yy322, &yymsp[-2].minor.yy0, 1);\n}\n        break;\n      case 173: /* cmd ::= insert_cmd INTO fullname inscollist_opt VALUES LP itemlist RP */\n{sqlite3Insert(pParse, yymsp[-5].minor.yy259, yymsp[-1].minor.yy322, 0, yymsp[-4].minor.yy384, yymsp[-7].minor.yy210);}\n        break;\n      case 174: /* cmd ::= insert_cmd INTO fullname inscollist_opt select */\n{sqlite3Insert(pParse, yymsp[-2].minor.yy259, 0, yymsp[0].minor.yy387, yymsp[-1].minor.yy384, yymsp[-4].minor.yy210);}\n        break;\n      case 175: /* cmd ::= insert_cmd INTO fullname inscollist_opt DEFAULT VALUES */\n{sqlite3Insert(pParse, yymsp[-3].minor.yy259, 0, 0, yymsp[-2].minor.yy384, yymsp[-5].minor.yy210);}\n        break;\n      case 176: /* insert_cmd ::= INSERT orconf */\n{yygotominor.yy210 = yymsp[0].minor.yy210;}\n        break;\n      case 177: /* insert_cmd ::= REPLACE */\n{yygotominor.yy210 = OE_Replace;}\n        break;\n      case 178: /* itemlist ::= itemlist COMMA expr */\n      case 241: /* nexprlist ::= nexprlist COMMA expr */ yytestcase(yyruleno==241);\n{yygotominor.yy322 = sqlite3ExprListAppend(pParse,yymsp[-2].minor.yy322,yymsp[0].minor.yy118.pExpr);}\n        break;\n      case 179: /* itemlist ::= expr */\n      case 242: /* nexprlist ::= expr */ yytestcase(yyruleno==242);\n{yygotominor.yy322 = sqlite3ExprListAppend(pParse,0,yymsp[0].minor.yy118.pExpr);}\n        break;\n      case 182: /* inscollist ::= inscollist COMMA nm */\n{yygotominor.yy384 = sqlite3IdListAppend(pParse->db,yymsp[-2].minor.yy384,&yymsp[0].minor.yy0);}\n        break;\n      case 183: /* inscollist ::= nm */\n{yygotominor.yy384 = sqlite3IdListAppend(pParse->db,0,&yymsp[0].minor.yy0);}\n        break;\n      case 184: /* expr ::= term */\n{yygotominor.yy118 = yymsp[0].minor.yy118;}\n        break;\n      case 185: /* expr ::= LP expr RP */\n{yygotominor.yy118.pExpr = yymsp[-1].minor.yy118.pExpr; spanSet(&yygotominor.yy118,&yymsp[-2].minor.yy0,&yymsp[0].minor.yy0);}\n        break;\n      case 186: /* term ::= NULL */\n      case 191: /* term ::= INTEGER|FLOAT|BLOB */ yytestcase(yyruleno==191);\n      case 192: /* term ::= STRING */ yytestcase(yyruleno==192);\n{spanExpr(&yygotominor.yy118, pParse, yymsp[0].major, &yymsp[0].minor.yy0);}\n        break;\n      case 187: /* expr ::= id */\n      case 188: /* expr ::= JOIN_KW */ yytestcase(yyruleno==188);\n{spanExpr(&yygotominor.yy118, pParse, TK_ID, &yymsp[0].minor.yy0);}\n        break;\n      case 189: /* expr ::= nm DOT nm */\n{\n  Expr *temp1 = sqlite3PExpr(pParse, TK_ID, 0, 0, &yymsp[-2].minor.yy0);\n  Expr *temp2 = sqlite3PExpr(pParse, TK_ID, 0, 0, &yymsp[0].minor.yy0);\n  yygotominor.yy118.pExpr = sqlite3PExpr(pParse, TK_DOT, temp1, temp2, 0);\n  spanSet(&yygotominor.yy118,&yymsp[-2].minor.yy0,&yymsp[0].minor.yy0);\n}\n        break;\n      case 190: /* expr ::= nm DOT nm DOT nm */\n{\n  Expr *temp1 = sqlite3PExpr(pParse, TK_ID, 0, 0, &yymsp[-4].minor.yy0);\n  Expr *temp2 = sqlite3PExpr(pParse, TK_ID, 0, 0, &yymsp[-2].minor.yy0);\n  Expr *temp3 = sqlite3PExpr(pParse, TK_ID, 0, 0, &yymsp[0].minor.yy0);\n  Expr *temp4 = sqlite3PExpr(pParse, TK_DOT, temp2, temp3, 0);\n  yygotominor.yy118.pExpr = sqlite3PExpr(pParse, TK_DOT, temp1, temp4, 0);\n  spanSet(&yygotominor.yy118,&yymsp[-4].minor.yy0,&yymsp[0].minor.yy0);\n}\n        break;\n      case 193: /* expr ::= REGISTER */\n{\n  /* When doing a nested parse, one can include terms in an expression\n  ** that look like this:   #1 #2 ...  These terms refer to registers\n  ** in the virtual machine.  #N is the N-th register. */\n  if( pParse->nested==0 ){\n    sqlite3ErrorMsg(pParse, \"near \\\"%T\\\": syntax error\", &yymsp[0].minor.yy0);\n    yygotominor.yy118.pExpr = 0;\n  }else{\n    yygotominor.yy118.pExpr = sqlite3PExpr(pParse, TK_REGISTER, 0, 0, &yymsp[0].minor.yy0);\n    if( yygotominor.yy118.pExpr ) sqlite3GetInt32(&yymsp[0].minor.yy0.z[1], &yygotominor.yy118.pExpr->iTable);\n  }\n  spanSet(&yygotominor.yy118, &yymsp[0].minor.yy0, &yymsp[0].minor.yy0);\n}\n        break;\n      case 194: /* expr ::= VARIABLE */\n{\n  spanExpr(&yygotominor.yy118, pParse, TK_VARIABLE, &yymsp[0].minor.yy0);\n  sqlite3ExprAssignVarNumber(pParse, yygotominor.yy118.pExpr);\n  spanSet(&yygotominor.yy118, &yymsp[0].minor.yy0, &yymsp[0].minor.yy0);\n}\n        break;\n      case 195: /* expr ::= expr COLLATE ids */\n{\n  yygotominor.yy118.pExpr = sqlite3ExprSetCollByToken(pParse, yymsp[-2].minor.yy118.pExpr, &yymsp[0].minor.yy0);\n  yygotominor.yy118.zStart = yymsp[-2].minor.yy118.zStart;\n  yygotominor.yy118.zEnd = &yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n];\n}\n        break;\n      case 196: /* expr ::= CAST LP expr AS typetoken RP */\n{\n  yygotominor.yy118.pExpr = sqlite3PExpr(pParse, TK_CAST, yymsp[-3].minor.yy118.pExpr, 0, &yymsp[-1].minor.yy0);\n  spanSet(&yygotominor.yy118,&yymsp[-5].minor.yy0,&yymsp[0].minor.yy0);\n}\n        break;\n      case 197: /* expr ::= ID LP distinct exprlist RP */\n{\n  if( yymsp[-1].minor.yy322 && yymsp[-1].minor.yy322->nExpr>pParse->db->aLimit[SQLITE_LIMIT_FUNCTION_ARG] ){\n    sqlite3ErrorMsg(pParse, \"too many arguments on function %T\", &yymsp[-4].minor.yy0);\n  }\n  yygotominor.yy118.pExpr = sqlite3ExprFunction(pParse, yymsp[-1].minor.yy322, &yymsp[-4].minor.yy0);\n  spanSet(&yygotominor.yy118,&yymsp[-4].minor.yy0,&yymsp[0].minor.yy0);\n  if( yymsp[-2].minor.yy4 && yygotominor.yy118.pExpr ){\n    yygotominor.yy118.pExpr->flags |= EP_Distinct;\n  }\n}\n        break;\n      case 198: /* expr ::= ID LP STAR RP */\n{\n  yygotominor.yy118.pExpr = sqlite3ExprFunction(pParse, 0, &yymsp[-3].minor.yy0);\n  spanSet(&yygotominor.yy118,&yymsp[-3].minor.yy0,&yymsp[0].minor.yy0);\n}\n        break;\n      case 199: /* term ::= CTIME_KW */\n{\n  /* The CURRENT_TIME, CURRENT_DATE, and CURRENT_TIMESTAMP values are\n  ** treated as functions that return constants */\n  yygotominor.yy118.pExpr = sqlite3ExprFunction(pParse, 0,&yymsp[0].minor.yy0);\n  if( yygotominor.yy118.pExpr ){\n    yygotominor.yy118.pExpr->op = TK_CONST_FUNC;  \n  }\n  spanSet(&yygotominor.yy118, &yymsp[0].minor.yy0, &yymsp[0].minor.yy0);\n}\n        break;\n      case 200: /* expr ::= expr AND expr */\n      case 201: /* expr ::= expr OR expr */ yytestcase(yyruleno==201);\n      case 202: /* expr ::= expr LT|GT|GE|LE expr */ yytestcase(yyruleno==202);\n      case 203: /* expr ::= expr EQ|NE expr */ yytestcase(yyruleno==203);\n      case 204: /* expr ::= expr BITAND|BITOR|LSHIFT|RSHIFT expr */ yytestcase(yyruleno==204);\n      case 205: /* expr ::= expr PLUS|MINUS expr */ yytestcase(yyruleno==205);\n      case 206: /* expr ::= expr STAR|SLASH|REM expr */ yytestcase(yyruleno==206);\n      case 207: /* expr ::= expr CONCAT expr */ yytestcase(yyruleno==207);\n{spanBinaryExpr(&yygotominor.yy118,pParse,yymsp[-1].major,&yymsp[-2].minor.yy118,&yymsp[0].minor.yy118);}\n        break;\n      case 208: /* likeop ::= LIKE_KW */\n      case 210: /* likeop ::= MATCH */ yytestcase(yyruleno==210);\n{yygotominor.yy342.eOperator = yymsp[0].minor.yy0; yygotominor.yy342.not = 0;}\n        break;\n      case 209: /* likeop ::= NOT LIKE_KW */\n      case 211: /* likeop ::= NOT MATCH */ yytestcase(yyruleno==211);\n{yygotominor.yy342.eOperator = yymsp[0].minor.yy0; yygotominor.yy342.not = 1;}\n        break;\n      case 212: /* expr ::= expr likeop expr */\n{\n  ExprList *pList;\n  pList = sqlite3ExprListAppend(pParse,0, yymsp[0].minor.yy118.pExpr);\n  pList = sqlite3ExprListAppend(pParse,pList, yymsp[-2].minor.yy118.pExpr);\n  yygotominor.yy118.pExpr = sqlite3ExprFunction(pParse, pList, &yymsp[-1].minor.yy342.eOperator);\n  if( yymsp[-1].minor.yy342.not ) yygotominor.yy118.pExpr = sqlite3PExpr(pParse, TK_NOT, yygotominor.yy118.pExpr, 0, 0);\n  yygotominor.yy118.zStart = yymsp[-2].minor.yy118.zStart;\n  yygotominor.yy118.zEnd = yymsp[0].minor.yy118.zEnd;\n  if( yygotominor.yy118.pExpr ) yygotominor.yy118.pExpr->flags |= EP_InfixFunc;\n}\n        break;\n      case 213: /* expr ::= expr likeop expr ESCAPE expr */\n{\n  ExprList *pList;\n  pList = sqlite3ExprListAppend(pParse,0, yymsp[-2].minor.yy118.pExpr);\n  pList = sqlite3ExprListAppend(pParse,pList, yymsp[-4].minor.yy118.pExpr);\n  pList = sqlite3ExprListAppend(pParse,pList, yymsp[0].minor.yy118.pExpr);\n  yygotominor.yy118.pExpr = sqlite3ExprFunction(pParse, pList, &yymsp[-3].minor.yy342.eOperator);\n  if( yymsp[-3].minor.yy342.not ) yygotominor.yy118.pExpr = sqlite3PExpr(pParse, TK_NOT, yygotominor.yy118.pExpr, 0, 0);\n  yygotominor.yy118.zStart = yymsp[-4].minor.yy118.zStart;\n  yygotominor.yy118.zEnd = yymsp[0].minor.yy118.zEnd;\n  if( yygotominor.yy118.pExpr ) yygotominor.yy118.pExpr->flags |= EP_InfixFunc;\n}\n        break;\n      case 214: /* expr ::= expr ISNULL|NOTNULL */\n{spanUnaryPostfix(&yygotominor.yy118,pParse,yymsp[0].major,&yymsp[-1].minor.yy118,&yymsp[0].minor.yy0);}\n        break;\n      case 215: /* expr ::= expr NOT NULL */\n{spanUnaryPostfix(&yygotominor.yy118,pParse,TK_NOTNULL,&yymsp[-2].minor.yy118,&yymsp[0].minor.yy0);}\n        break;\n      case 216: /* expr ::= expr IS expr */\n{\n  spanBinaryExpr(&yygotominor.yy118,pParse,TK_IS,&yymsp[-2].minor.yy118,&yymsp[0].minor.yy118);\n  binaryToUnaryIfNull(pParse, yymsp[0].minor.yy118.pExpr, yygotominor.yy118.pExpr, TK_ISNULL);\n}\n        break;\n      case 217: /* expr ::= expr IS NOT expr */\n{\n  spanBinaryExpr(&yygotominor.yy118,pParse,TK_ISNOT,&yymsp[-3].minor.yy118,&yymsp[0].minor.yy118);\n  binaryToUnaryIfNull(pParse, yymsp[0].minor.yy118.pExpr, yygotominor.yy118.pExpr, TK_NOTNULL);\n}\n        break;\n      case 218: /* expr ::= NOT expr */\n      case 219: /* expr ::= BITNOT expr */ yytestcase(yyruleno==219);\n{spanUnaryPrefix(&yygotominor.yy118,pParse,yymsp[-1].major,&yymsp[0].minor.yy118,&yymsp[-1].minor.yy0);}\n        break;\n      case 220: /* expr ::= MINUS expr */\n{spanUnaryPrefix(&yygotominor.yy118,pParse,TK_UMINUS,&yymsp[0].minor.yy118,&yymsp[-1].minor.yy0);}\n        break;\n      case 221: /* expr ::= PLUS expr */\n{spanUnaryPrefix(&yygotominor.yy118,pParse,TK_UPLUS,&yymsp[0].minor.yy118,&yymsp[-1].minor.yy0);}\n        break;\n      case 224: /* expr ::= expr between_op expr AND expr */\n{\n  ExprList *pList = sqlite3ExprListAppend(pParse,0, yymsp[-2].minor.yy118.pExpr);\n  pList = sqlite3ExprListAppend(pParse,pList, yymsp[0].minor.yy118.pExpr);\n  yygotominor.yy118.pExpr = sqlite3PExpr(pParse, TK_BETWEEN, yymsp[-4].minor.yy118.pExpr, 0, 0);\n  if( yygotominor.yy118.pExpr ){\n    yygotominor.yy118.pExpr->x.pList = pList;\n  }else{\n    sqlite3ExprListDelete(pParse->db, pList);\n  } \n  if( yymsp[-3].minor.yy4 ) yygotominor.yy118.pExpr = sqlite3PExpr(pParse, TK_NOT, yygotominor.yy118.pExpr, 0, 0);\n  yygotominor.yy118.zStart = yymsp[-4].minor.yy118.zStart;\n  yygotominor.yy118.zEnd = yymsp[0].minor.yy118.zEnd;\n}\n        break;\n      case 227: /* expr ::= expr in_op LP exprlist RP */\n{\n    if( yymsp[-1].minor.yy322==0 ){\n      /* Expressions of the form\n      **\n      **      expr1 IN ()\n      **      expr1 NOT IN ()\n      **\n      ** simplify to constants 0 (false) and 1 (true), respectively,\n      ** regardless of the value of expr1.\n      */\n      yygotominor.yy118.pExpr = sqlite3PExpr(pParse, TK_INTEGER, 0, 0, &sqlite3IntTokens[yymsp[-3].minor.yy4]);\n      sqlite3ExprDelete(pParse->db, yymsp[-4].minor.yy118.pExpr);\n    }else{\n      yygotominor.yy118.pExpr = sqlite3PExpr(pParse, TK_IN, yymsp[-4].minor.yy118.pExpr, 0, 0);\n      if( yygotominor.yy118.pExpr ){\n        yygotominor.yy118.pExpr->x.pList = yymsp[-1].minor.yy322;\n        sqlite3ExprSetHeight(pParse, yygotominor.yy118.pExpr);\n      }else{\n        sqlite3ExprListDelete(pParse->db, yymsp[-1].minor.yy322);\n      }\n      if( yymsp[-3].minor.yy4 ) yygotominor.yy118.pExpr = sqlite3PExpr(pParse, TK_NOT, yygotominor.yy118.pExpr, 0, 0);\n    }\n    yygotominor.yy118.zStart = yymsp[-4].minor.yy118.zStart;\n    yygotominor.yy118.zEnd = &yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n];\n  }\n        break;\n      case 228: /* expr ::= LP select RP */\n{\n    yygotominor.yy118.pExpr = sqlite3PExpr(pParse, TK_SELECT, 0, 0, 0);\n    if( yygotominor.yy118.pExpr ){\n      yygotominor.yy118.pExpr->x.pSelect = yymsp[-1].minor.yy387;\n      ExprSetProperty(yygotominor.yy118.pExpr, EP_xIsSelect);\n      sqlite3ExprSetHeight(pParse, yygotominor.yy118.pExpr);\n    }else{\n      sqlite3SelectDelete(pParse->db, yymsp[-1].minor.yy387);\n    }\n    yygotominor.yy118.zStart = yymsp[-2].minor.yy0.z;\n    yygotominor.yy118.zEnd = &yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n];\n  }\n        break;\n      case 229: /* expr ::= expr in_op LP select RP */\n{\n    yygotominor.yy118.pExpr = sqlite3PExpr(pParse, TK_IN, yymsp[-4].minor.yy118.pExpr, 0, 0);\n    if( yygotominor.yy118.pExpr ){\n      yygotominor.yy118.pExpr->x.pSelect = yymsp[-1].minor.yy387;\n      ExprSetProperty(yygotominor.yy118.pExpr, EP_xIsSelect);\n      sqlite3ExprSetHeight(pParse, yygotominor.yy118.pExpr);\n    }else{\n      sqlite3SelectDelete(pParse->db, yymsp[-1].minor.yy387);\n    }\n    if( yymsp[-3].minor.yy4 ) yygotominor.yy118.pExpr = sqlite3PExpr(pParse, TK_NOT, yygotominor.yy118.pExpr, 0, 0);\n    yygotominor.yy118.zStart = yymsp[-4].minor.yy118.zStart;\n    yygotominor.yy118.zEnd = &yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n];\n  }\n        break;\n      case 230: /* expr ::= expr in_op nm dbnm */\n{\n    SrcList *pSrc = sqlite3SrcListAppend(pParse->db, 0,&yymsp[-1].minor.yy0,&yymsp[0].minor.yy0);\n    yygotominor.yy118.pExpr = sqlite3PExpr(pParse, TK_IN, yymsp[-3].minor.yy118.pExpr, 0, 0);\n    if( yygotominor.yy118.pExpr ){\n      yygotominor.yy118.pExpr->x.pSelect = sqlite3SelectNew(pParse, 0,pSrc,0,0,0,0,0,0,0);\n      ExprSetProperty(yygotominor.yy118.pExpr, EP_xIsSelect);\n      sqlite3ExprSetHeight(pParse, yygotominor.yy118.pExpr);\n    }else{\n      sqlite3SrcListDelete(pParse->db, pSrc);\n    }\n    if( yymsp[-2].minor.yy4 ) yygotominor.yy118.pExpr = sqlite3PExpr(pParse, TK_NOT, yygotominor.yy118.pExpr, 0, 0);\n    yygotominor.yy118.zStart = yymsp[-3].minor.yy118.zStart;\n    yygotominor.yy118.zEnd = yymsp[0].minor.yy0.z ? &yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n] : &yymsp[-1].minor.yy0.z[yymsp[-1].minor.yy0.n];\n  }\n        break;\n      case 231: /* expr ::= EXISTS LP select RP */\n{\n    Expr *p = yygotominor.yy118.pExpr = sqlite3PExpr(pParse, TK_EXISTS, 0, 0, 0);\n    if( p ){\n      p->x.pSelect = yymsp[-1].minor.yy387;\n      ExprSetProperty(p, EP_xIsSelect);\n      sqlite3ExprSetHeight(pParse, p);\n    }else{\n      sqlite3SelectDelete(pParse->db, yymsp[-1].minor.yy387);\n    }\n    yygotominor.yy118.zStart = yymsp[-3].minor.yy0.z;\n    yygotominor.yy118.zEnd = &yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n];\n  }\n        break;\n      case 232: /* expr ::= CASE case_operand case_exprlist case_else END */\n{\n  yygotominor.yy118.pExpr = sqlite3PExpr(pParse, TK_CASE, yymsp[-3].minor.yy314, yymsp[-1].minor.yy314, 0);\n  if( yygotominor.yy118.pExpr ){\n    yygotominor.yy118.pExpr->x.pList = yymsp[-2].minor.yy322;\n    sqlite3ExprSetHeight(pParse, yygotominor.yy118.pExpr);\n  }else{\n    sqlite3ExprListDelete(pParse->db, yymsp[-2].minor.yy322);\n  }\n  yygotominor.yy118.zStart = yymsp[-4].minor.yy0.z;\n  yygotominor.yy118.zEnd = &yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n];\n}\n        break;\n      case 233: /* case_exprlist ::= case_exprlist WHEN expr THEN expr */\n{\n  yygotominor.yy322 = sqlite3ExprListAppend(pParse,yymsp[-4].minor.yy322, yymsp[-2].minor.yy118.pExpr);\n  yygotominor.yy322 = sqlite3ExprListAppend(pParse,yygotominor.yy322, yymsp[0].minor.yy118.pExpr);\n}\n        break;\n      case 234: /* case_exprlist ::= WHEN expr THEN expr */\n{\n  yygotominor.yy322 = sqlite3ExprListAppend(pParse,0, yymsp[-2].minor.yy118.pExpr);\n  yygotominor.yy322 = sqlite3ExprListAppend(pParse,yygotominor.yy322, yymsp[0].minor.yy118.pExpr);\n}\n        break;\n      case 243: /* cmd ::= createkw uniqueflag INDEX ifnotexists nm dbnm ON nm LP idxlist RP */\n{\n  sqlite3CreateIndex(pParse, &yymsp[-6].minor.yy0, &yymsp[-5].minor.yy0, \n                     sqlite3SrcListAppend(pParse->db,0,&yymsp[-3].minor.yy0,0), yymsp[-1].minor.yy322, yymsp[-9].minor.yy4,\n                      &yymsp[-10].minor.yy0, &yymsp[0].minor.yy0, SQLITE_SO_ASC, yymsp[-7].minor.yy4);\n}\n        break;\n      case 244: /* uniqueflag ::= UNIQUE */\n      case 298: /* raisetype ::= ABORT */ yytestcase(yyruleno==298);\n{yygotominor.yy4 = OE_Abort;}\n        break;\n      case 245: /* uniqueflag ::= */\n{yygotominor.yy4 = OE_None;}\n        break;\n      case 248: /* idxlist ::= idxlist COMMA nm collate sortorder */\n{\n  Expr *p = 0;\n  if( yymsp[-1].minor.yy0.n>0 ){\n    p = sqlite3Expr(pParse->db, TK_COLUMN, 0);\n    sqlite3ExprSetCollByToken(pParse, p, &yymsp[-1].minor.yy0);\n  }\n  yygotominor.yy322 = sqlite3ExprListAppend(pParse,yymsp[-4].minor.yy322, p);\n  sqlite3ExprListSetName(pParse,yygotominor.yy322,&yymsp[-2].minor.yy0,1);\n  sqlite3ExprListCheckLength(pParse, yygotominor.yy322, \"index\");\n  if( yygotominor.yy322 ) yygotominor.yy322->a[yygotominor.yy322->nExpr-1].sortOrder = (u8)yymsp[0].minor.yy4;\n}\n        break;\n      case 249: /* idxlist ::= nm collate sortorder */\n{\n  Expr *p = 0;\n  if( yymsp[-1].minor.yy0.n>0 ){\n    p = sqlite3PExpr(pParse, TK_COLUMN, 0, 0, 0);\n    sqlite3ExprSetCollByToken(pParse, p, &yymsp[-1].minor.yy0);\n  }\n  yygotominor.yy322 = sqlite3ExprListAppend(pParse,0, p);\n  sqlite3ExprListSetName(pParse, yygotominor.yy322, &yymsp[-2].minor.yy0, 1);\n  sqlite3ExprListCheckLength(pParse, yygotominor.yy322, \"index\");\n  if( yygotominor.yy322 ) yygotominor.yy322->a[yygotominor.yy322->nExpr-1].sortOrder = (u8)yymsp[0].minor.yy4;\n}\n        break;\n      case 250: /* collate ::= */\n{yygotominor.yy0.z = 0; yygotominor.yy0.n = 0;}\n        break;\n      case 252: /* cmd ::= DROP INDEX ifexists fullname */\n{sqlite3DropIndex(pParse, yymsp[0].minor.yy259, yymsp[-1].minor.yy4);}\n        break;\n      case 253: /* cmd ::= VACUUM */\n      case 254: /* cmd ::= VACUUM nm */ yytestcase(yyruleno==254);\n{sqlite3Vacuum(pParse);}\n        break;\n      case 255: /* cmd ::= PRAGMA nm dbnm */\n{sqlite3Pragma(pParse,&yymsp[-1].minor.yy0,&yymsp[0].minor.yy0,0,0);}\n        break;\n      case 256: /* cmd ::= PRAGMA nm dbnm EQ nmnum */\n{sqlite3Pragma(pParse,&yymsp[-3].minor.yy0,&yymsp[-2].minor.yy0,&yymsp[0].minor.yy0,0);}\n        break;\n      case 257: /* cmd ::= PRAGMA nm dbnm LP nmnum RP */\n{sqlite3Pragma(pParse,&yymsp[-4].minor.yy0,&yymsp[-3].minor.yy0,&yymsp[-1].minor.yy0,0);}\n        break;\n      case 258: /* cmd ::= PRAGMA nm dbnm EQ minus_num */\n{sqlite3Pragma(pParse,&yymsp[-3].minor.yy0,&yymsp[-2].minor.yy0,&yymsp[0].minor.yy0,1);}\n        break;\n      case 259: /* cmd ::= PRAGMA nm dbnm LP minus_num RP */\n{sqlite3Pragma(pParse,&yymsp[-4].minor.yy0,&yymsp[-3].minor.yy0,&yymsp[-1].minor.yy0,1);}\n        break;\n      case 270: /* cmd ::= createkw trigger_decl BEGIN trigger_cmd_list END */\n{\n  Token all;\n  all.z = yymsp[-3].minor.yy0.z;\n  all.n = (int)(yymsp[0].minor.yy0.z - yymsp[-3].minor.yy0.z) + yymsp[0].minor.yy0.n;\n  sqlite3FinishTrigger(pParse, yymsp[-1].minor.yy203, &all);\n}\n        break;\n      case 271: /* trigger_decl ::= temp TRIGGER ifnotexists nm dbnm trigger_time trigger_event ON fullname foreach_clause when_clause */\n{\n  sqlite3BeginTrigger(pParse, &yymsp[-7].minor.yy0, &yymsp[-6].minor.yy0, yymsp[-5].minor.yy4, yymsp[-4].minor.yy90.a, yymsp[-4].minor.yy90.b, yymsp[-2].minor.yy259, yymsp[0].minor.yy314, yymsp[-10].minor.yy4, yymsp[-8].minor.yy4);\n  yygotominor.yy0 = (yymsp[-6].minor.yy0.n==0?yymsp[-7].minor.yy0:yymsp[-6].minor.yy0);\n}\n        break;\n      case 272: /* trigger_time ::= BEFORE */\n      case 275: /* trigger_time ::= */ yytestcase(yyruleno==275);\n{ yygotominor.yy4 = TK_BEFORE; }\n        break;\n      case 273: /* trigger_time ::= AFTER */\n{ yygotominor.yy4 = TK_AFTER;  }\n        break;\n      case 274: /* trigger_time ::= INSTEAD OF */\n{ yygotominor.yy4 = TK_INSTEAD;}\n        break;\n      case 276: /* trigger_event ::= DELETE|INSERT */\n      case 277: /* trigger_event ::= UPDATE */ yytestcase(yyruleno==277);\n{yygotominor.yy90.a = yymsp[0].major; yygotominor.yy90.b = 0;}\n        break;\n      case 278: /* trigger_event ::= UPDATE OF inscollist */\n{yygotominor.yy90.a = TK_UPDATE; yygotominor.yy90.b = yymsp[0].minor.yy384;}\n        break;\n      case 281: /* when_clause ::= */\n      case 303: /* key_opt ::= */ yytestcase(yyruleno==303);\n{ yygotominor.yy314 = 0; }\n        break;\n      case 282: /* when_clause ::= WHEN expr */\n      case 304: /* key_opt ::= KEY expr */ yytestcase(yyruleno==304);\n{ yygotominor.yy314 = yymsp[0].minor.yy118.pExpr; }\n        break;\n      case 283: /* trigger_cmd_list ::= trigger_cmd_list trigger_cmd SEMI */\n{\n  assert( yymsp[-2].minor.yy203!=0 );\n  yymsp[-2].minor.yy203->pLast->pNext = yymsp[-1].minor.yy203;\n  yymsp[-2].minor.yy203->pLast = yymsp[-1].minor.yy203;\n  yygotominor.yy203 = yymsp[-2].minor.yy203;\n}\n        break;\n      case 284: /* trigger_cmd_list ::= trigger_cmd SEMI */\n{ \n  assert( yymsp[-1].minor.yy203!=0 );\n  yymsp[-1].minor.yy203->pLast = yymsp[-1].minor.yy203;\n  yygotominor.yy203 = yymsp[-1].minor.yy203;\n}\n        break;\n      case 286: /* trnm ::= nm DOT nm */\n{\n  yygotominor.yy0 = yymsp[0].minor.yy0;\n  sqlite3ErrorMsg(pParse, \n        \"qualified table names are not allowed on INSERT, UPDATE, and DELETE \"\n        \"statements within triggers\");\n}\n        break;\n      case 288: /* tridxby ::= INDEXED BY nm */\n{\n  sqlite3ErrorMsg(pParse,\n        \"the INDEXED BY clause is not allowed on UPDATE or DELETE statements \"\n        \"within triggers\");\n}\n        break;\n      case 289: /* tridxby ::= NOT INDEXED */\n{\n  sqlite3ErrorMsg(pParse,\n        \"the NOT INDEXED clause is not allowed on UPDATE or DELETE statements \"\n        \"within triggers\");\n}\n        break;\n      case 290: /* trigger_cmd ::= UPDATE orconf trnm tridxby SET setlist where_opt */\n{ yygotominor.yy203 = sqlite3TriggerUpdateStep(pParse->db, &yymsp[-4].minor.yy0, yymsp[-1].minor.yy322, yymsp[0].minor.yy314, yymsp[-5].minor.yy210); }\n        break;\n      case 291: /* trigger_cmd ::= insert_cmd INTO trnm inscollist_opt VALUES LP itemlist RP */\n{yygotominor.yy203 = sqlite3TriggerInsertStep(pParse->db, &yymsp[-5].minor.yy0, yymsp[-4].minor.yy384, yymsp[-1].minor.yy322, 0, yymsp[-7].minor.yy210);}\n        break;\n      case 292: /* trigger_cmd ::= insert_cmd INTO trnm inscollist_opt select */\n{yygotominor.yy203 = sqlite3TriggerInsertStep(pParse->db, &yymsp[-2].minor.yy0, yymsp[-1].minor.yy384, 0, yymsp[0].minor.yy387, yymsp[-4].minor.yy210);}\n        break;\n      case 293: /* trigger_cmd ::= DELETE FROM trnm tridxby where_opt */\n{yygotominor.yy203 = sqlite3TriggerDeleteStep(pParse->db, &yymsp[-2].minor.yy0, yymsp[0].minor.yy314);}\n        break;\n      case 294: /* trigger_cmd ::= select */\n{yygotominor.yy203 = sqlite3TriggerSelectStep(pParse->db, yymsp[0].minor.yy387); }\n        break;\n      case 295: /* expr ::= RAISE LP IGNORE RP */\n{\n  yygotominor.yy118.pExpr = sqlite3PExpr(pParse, TK_RAISE, 0, 0, 0); \n  if( yygotominor.yy118.pExpr ){\n    yygotominor.yy118.pExpr->affinity = OE_Ignore;\n  }\n  yygotominor.yy118.zStart = yymsp[-3].minor.yy0.z;\n  yygotominor.yy118.zEnd = &yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n];\n}\n        break;\n      case 296: /* expr ::= RAISE LP raisetype COMMA nm RP */\n{\n  yygotominor.yy118.pExpr = sqlite3PExpr(pParse, TK_RAISE, 0, 0, &yymsp[-1].minor.yy0); \n  if( yygotominor.yy118.pExpr ) {\n    yygotominor.yy118.pExpr->affinity = (char)yymsp[-3].minor.yy4;\n  }\n  yygotominor.yy118.zStart = yymsp[-5].minor.yy0.z;\n  yygotominor.yy118.zEnd = &yymsp[0].minor.yy0.z[yymsp[0].minor.yy0.n];\n}\n        break;\n      case 297: /* raisetype ::= ROLLBACK */\n{yygotominor.yy4 = OE_Rollback;}\n        break;\n      case 299: /* raisetype ::= FAIL */\n{yygotominor.yy4 = OE_Fail;}\n        break;\n      case 300: /* cmd ::= DROP TRIGGER ifexists fullname */\n{\n  sqlite3DropTrigger(pParse,yymsp[0].minor.yy259,yymsp[-1].minor.yy4);\n}\n        break;\n      case 301: /* cmd ::= ATTACH database_kw_opt expr AS expr key_opt */\n{\n  sqlite3Attach(pParse, yymsp[-3].minor.yy118.pExpr, yymsp[-1].minor.yy118.pExpr, yymsp[0].minor.yy314);\n}\n        break;\n      case 302: /* cmd ::= DETACH database_kw_opt expr */\n{\n  sqlite3Detach(pParse, yymsp[0].minor.yy118.pExpr);\n}\n        break;\n      case 307: /* cmd ::= REINDEX */\n{sqlite3Reindex(pParse, 0, 0);}\n        break;\n      case 308: /* cmd ::= REINDEX nm dbnm */\n{sqlite3Reindex(pParse, &yymsp[-1].minor.yy0, &yymsp[0].minor.yy0);}\n        break;\n      case 309: /* cmd ::= ANALYZE */\n{sqlite3Analyze(pParse, 0, 0);}\n        break;\n      case 310: /* cmd ::= ANALYZE nm dbnm */\n{sqlite3Analyze(pParse, &yymsp[-1].minor.yy0, &yymsp[0].minor.yy0);}\n        break;\n      case 311: /* cmd ::= ALTER TABLE fullname RENAME TO nm */\n{\n  sqlite3AlterRenameTable(pParse,yymsp[-3].minor.yy259,&yymsp[0].minor.yy0);\n}\n        break;\n      case 312: /* cmd ::= ALTER TABLE add_column_fullname ADD kwcolumn_opt column */\n{\n  sqlite3AlterFinishAddColumn(pParse, &yymsp[0].minor.yy0);\n}\n        break;\n      case 313: /* add_column_fullname ::= fullname */\n{\n  pParse->db->lookaside.bEnabled = 0;\n  sqlite3AlterBeginAddColumn(pParse, yymsp[0].minor.yy259);\n}\n        break;\n      case 316: /* cmd ::= create_vtab */\n{sqlite3VtabFinishParse(pParse,0);}\n        break;\n      case 317: /* cmd ::= create_vtab LP vtabarglist RP */\n{sqlite3VtabFinishParse(pParse,&yymsp[0].minor.yy0);}\n        break;\n      case 318: /* create_vtab ::= createkw VIRTUAL TABLE nm dbnm USING nm */\n{\n    sqlite3VtabBeginParse(pParse, &yymsp[-3].minor.yy0, &yymsp[-2].minor.yy0, &yymsp[0].minor.yy0);\n}\n        break;\n      case 321: /* vtabarg ::= */\n{sqlite3VtabArgInit(pParse);}\n        break;\n      case 323: /* vtabargtoken ::= ANY */\n      case 324: /* vtabargtoken ::= lp anylist RP */ yytestcase(yyruleno==324);\n      case 325: /* lp ::= LP */ yytestcase(yyruleno==325);\n{sqlite3VtabArgExtend(pParse,&yymsp[0].minor.yy0);}\n        break;\n      default:\n      /* (0) input ::= cmdlist */ yytestcase(yyruleno==0);\n      /* (1) cmdlist ::= cmdlist ecmd */ yytestcase(yyruleno==1);\n      /* (2) cmdlist ::= ecmd */ yytestcase(yyruleno==2);\n      /* (3) ecmd ::= SEMI */ yytestcase(yyruleno==3);\n      /* (4) ecmd ::= explain cmdx SEMI */ yytestcase(yyruleno==4);\n      /* (10) trans_opt ::= */ yytestcase(yyruleno==10);\n      /* (11) trans_opt ::= TRANSACTION */ yytestcase(yyruleno==11);\n      /* (12) trans_opt ::= TRANSACTION nm */ yytestcase(yyruleno==12);\n      /* (20) savepoint_opt ::= SAVEPOINT */ yytestcase(yyruleno==20);\n      /* (21) savepoint_opt ::= */ yytestcase(yyruleno==21);\n      /* (25) cmd ::= create_table create_table_args */ yytestcase(yyruleno==25);\n      /* (34) columnlist ::= columnlist COMMA column */ yytestcase(yyruleno==34);\n      /* (35) columnlist ::= column */ yytestcase(yyruleno==35);\n      /* (44) type ::= */ yytestcase(yyruleno==44);\n      /* (51) signed ::= plus_num */ yytestcase(yyruleno==51);\n      /* (52) signed ::= minus_num */ yytestcase(yyruleno==52);\n      /* (53) carglist ::= carglist carg */ yytestcase(yyruleno==53);\n      /* (54) carglist ::= */ yytestcase(yyruleno==54);\n      /* (55) carg ::= CONSTRAINT nm ccons */ yytestcase(yyruleno==55);\n      /* (56) carg ::= ccons */ yytestcase(yyruleno==56);\n      /* (62) ccons ::= NULL onconf */ yytestcase(yyruleno==62);\n      /* (90) conslist ::= conslist COMMA tcons */ yytestcase(yyruleno==90);\n      /* (91) conslist ::= conslist tcons */ yytestcase(yyruleno==91);\n      /* (92) conslist ::= tcons */ yytestcase(yyruleno==92);\n      /* (93) tcons ::= CONSTRAINT nm */ yytestcase(yyruleno==93);\n      /* (268) plus_opt ::= PLUS */ yytestcase(yyruleno==268);\n      /* (269) plus_opt ::= */ yytestcase(yyruleno==269);\n      /* (279) foreach_clause ::= */ yytestcase(yyruleno==279);\n      /* (280) foreach_clause ::= FOR EACH ROW */ yytestcase(yyruleno==280);\n      /* (287) tridxby ::= */ yytestcase(yyruleno==287);\n      /* (305) database_kw_opt ::= DATABASE */ yytestcase(yyruleno==305);\n      /* (306) database_kw_opt ::= */ yytestcase(yyruleno==306);\n      /* (314) kwcolumn_opt ::= */ yytestcase(yyruleno==314);\n      /* (315) kwcolumn_opt ::= COLUMNKW */ yytestcase(yyruleno==315);\n      /* (319) vtabarglist ::= vtabarg */ yytestcase(yyruleno==319);\n      /* (320) vtabarglist ::= vtabarglist COMMA vtabarg */ yytestcase(yyruleno==320);\n      /* (322) vtabarg ::= vtabarg vtabargtoken */ yytestcase(yyruleno==322);\n      /* (326) anylist ::= */ yytestcase(yyruleno==326);\n      /* (327) anylist ::= anylist LP anylist RP */ yytestcase(yyruleno==327);\n      /* (328) anylist ::= anylist ANY */ yytestcase(yyruleno==328);\n        break;\n  };\n  yygoto = yyRuleInfo[yyruleno].lhs;\n  yysize = yyRuleInfo[yyruleno].nrhs;\n  yypParser->yyidx -= yysize;\n  yyact = yy_find_reduce_action(yymsp[-yysize].stateno,(YYCODETYPE)yygoto);\n  if( yyact < YYNSTATE ){\n#ifdef NDEBUG\n    /* If we are not debugging and the reduce action popped at least\n    ** one element off the stack, then we can push the new element back\n    ** onto the stack here, and skip the stack overflow test in yy_shift().\n    ** That gives a significant speed improvement. */\n    if( yysize ){\n      yypParser->yyidx++;\n      yymsp -= yysize-1;\n      yymsp->stateno = (YYACTIONTYPE)yyact;\n      yymsp->major = (YYCODETYPE)yygoto;\n      yymsp->minor = yygotominor;\n    }else\n#endif\n    {\n      yy_shift(yypParser,yyact,yygoto,&yygotominor);\n    }\n  }else{\n    assert( yyact == YYNSTATE + YYNRULE + 1 );\n    yy_accept(yypParser);\n  }\n}\n\n/*\n** The following code executes when the parse fails\n*/\n#ifndef YYNOERRORRECOVERY\nstatic void yy_parse_failed(\n  yyParser *yypParser           /* The parser */\n){\n  sqlite3ParserARG_FETCH;\n#ifndef NDEBUG\n  if( yyTraceFILE ){\n    fprintf(yyTraceFILE,\"%sFail!\\n\",yyTracePrompt);\n  }\n#endif\n  while( yypParser->yyidx>=0 ) yy_pop_parser_stack(yypParser);\n  /* Here code is inserted which will be executed whenever the\n  ** parser fails */\n  sqlite3ParserARG_STORE; /* Suppress warning about unused %extra_argument variable */\n}\n#endif /* YYNOERRORRECOVERY */\n\n/*\n** The following code executes when a syntax error first occurs.\n*/\nstatic void yy_syntax_error(\n  yyParser *yypParser,           /* The parser */\n  int yymajor,                   /* The major type of the error token */\n  YYMINORTYPE yyminor            /* The minor type of the error token */\n){\n  sqlite3ParserARG_FETCH;\n#define TOKEN (yyminor.yy0)\n\n  UNUSED_PARAMETER(yymajor);  /* Silence some compiler warnings */\n  assert( TOKEN.z[0] );  /* The tokenizer always gives us a token */\n  sqlite3ErrorMsg(pParse, \"near \\\"%T\\\": syntax error\", &TOKEN);\n  pParse->parseError = 1;\n  sqlite3ParserARG_STORE; /* Suppress warning about unused %extra_argument variable */\n}\n\n/*\n** The following is executed when the parser accepts\n*/\nstatic void yy_accept(\n  yyParser *yypParser           /* The parser */\n){\n  sqlite3ParserARG_FETCH;\n#ifndef NDEBUG\n  if( yyTraceFILE ){\n    fprintf(yyTraceFILE,\"%sAccept!\\n\",yyTracePrompt);\n  }\n#endif\n  while( yypParser->yyidx>=0 ) yy_pop_parser_stack(yypParser);\n  /* Here code is inserted which will be executed whenever the\n  ** parser accepts */\n  sqlite3ParserARG_STORE; /* Suppress warning about unused %extra_argument variable */\n}\n\n/* The main parser program.\n** The first argument is a pointer to a structure obtained from\n** \"sqlite3ParserAlloc\" which describes the current state of the parser.\n** The second argument is the major token number.  The third is\n** the minor token.  The fourth optional argument is whatever the\n** user wants (and specified in the grammar) and is available for\n** use by the action routines.\n**\n** Inputs:\n** <ul>\n** <li> A pointer to the parser (an opaque structure.)\n** <li> The major token number.\n** <li> The minor token number.\n** <li> An option argument of a grammar-specified type.\n** </ul>\n**\n** Outputs:\n** None.\n*/\nSQLITE_PRIVATE void sqlite3Parser(\n  void *yyp,                   /* The parser */\n  int yymajor,                 /* The major token code number */\n  sqlite3ParserTOKENTYPE yyminor       /* The value for the token */\n  sqlite3ParserARG_PDECL               /* Optional %extra_argument parameter */\n){\n  YYMINORTYPE yyminorunion;\n  int yyact;            /* The parser action. */\n  int yyendofinput;     /* True if we are at the end of input */\n#ifdef YYERRORSYMBOL\n  int yyerrorhit = 0;   /* True if yymajor has invoked an error */\n#endif\n  yyParser *yypParser;  /* The parser */\n\n  /* (re)initialize the parser, if necessary */\n  yypParser = (yyParser*)yyp;\n  if( yypParser->yyidx<0 ){\n#if YYSTACKDEPTH<=0\n    if( yypParser->yystksz <=0 ){\n      /*memset(&yyminorunion, 0, sizeof(yyminorunion));*/\n      yyminorunion = yyzerominor;\n      yyStackOverflow(yypParser, &yyminorunion);\n      return;\n    }\n#endif\n    yypParser->yyidx = 0;\n    yypParser->yyerrcnt = -1;\n    yypParser->yystack[0].stateno = 0;\n    yypParser->yystack[0].major = 0;\n  }\n  yyminorunion.yy0 = yyminor;\n  yyendofinput = (yymajor==0);\n  sqlite3ParserARG_STORE;\n\n#ifndef NDEBUG\n  if( yyTraceFILE ){\n    fprintf(yyTraceFILE,\"%sInput %s\\n\",yyTracePrompt,yyTokenName[yymajor]);\n  }\n#endif\n\n  do{\n    yyact = yy_find_shift_action(yypParser,(YYCODETYPE)yymajor);\n    if( yyact<YYNSTATE ){\n      assert( !yyendofinput );  /* Impossible to shift the $ token */\n      yy_shift(yypParser,yyact,yymajor,&yyminorunion);\n      yypParser->yyerrcnt--;\n      yymajor = YYNOCODE;\n    }else if( yyact < YYNSTATE + YYNRULE ){\n      yy_reduce(yypParser,yyact-YYNSTATE);\n    }else{\n      assert( yyact == YY_ERROR_ACTION );\n#ifdef YYERRORSYMBOL\n      int yymx;\n#endif\n#ifndef NDEBUG\n      if( yyTraceFILE ){\n        fprintf(yyTraceFILE,\"%sSyntax Error!\\n\",yyTracePrompt);\n      }\n#endif\n#ifdef YYERRORSYMBOL\n      /* A syntax error has occurred.\n      ** The response to an error depends upon whether or not the\n      ** grammar defines an error token \"ERROR\".  \n      **\n      ** This is what we do if the grammar does define ERROR:\n      **\n      **  * Call the %syntax_error function.\n      **\n      **  * Begin popping the stack until we enter a state where\n      **    it is legal to shift the error symbol, then shift\n      **    the error symbol.\n      **\n      **  * Set the error count to three.\n      **\n      **  * Begin accepting and shifting new tokens.  No new error\n      **    processing will occur until three tokens have been\n      **    shifted successfully.\n      **\n      */\n      if( yypParser->yyerrcnt<0 ){\n        yy_syntax_error(yypParser,yymajor,yyminorunion);\n      }\n      yymx = yypParser->yystack[yypParser->yyidx].major;\n      if( yymx==YYERRORSYMBOL || yyerrorhit ){\n#ifndef NDEBUG\n        if( yyTraceFILE ){\n          fprintf(yyTraceFILE,\"%sDiscard input token %s\\n\",\n             yyTracePrompt,yyTokenName[yymajor]);\n        }\n#endif\n        yy_destructor(yypParser, (YYCODETYPE)yymajor,&yyminorunion);\n        yymajor = YYNOCODE;\n      }else{\n         while(\n          yypParser->yyidx >= 0 &&\n          yymx != YYERRORSYMBOL &&\n          (yyact = yy_find_reduce_action(\n                        yypParser->yystack[yypParser->yyidx].stateno,\n                        YYERRORSYMBOL)) >= YYNSTATE\n        ){\n          yy_pop_parser_stack(yypParser);\n        }\n        if( yypParser->yyidx < 0 || yymajor==0 ){\n          yy_destructor(yypParser,(YYCODETYPE)yymajor,&yyminorunion);\n          yy_parse_failed(yypParser);\n          yymajor = YYNOCODE;\n        }else if( yymx!=YYERRORSYMBOL ){\n          YYMINORTYPE u2;\n          u2.YYERRSYMDT = 0;\n          yy_shift(yypParser,yyact,YYERRORSYMBOL,&u2);\n        }\n      }\n      yypParser->yyerrcnt = 3;\n      yyerrorhit = 1;\n#elif defined(YYNOERRORRECOVERY)\n      /* If the YYNOERRORRECOVERY macro is defined, then do not attempt to\n      ** do any kind of error recovery.  Instead, simply invoke the syntax\n      ** error routine and continue going as if nothing had happened.\n      **\n      ** Applications can set this macro (for example inside %include) if\n      ** they intend to abandon the parse upon the first syntax error seen.\n      */\n      yy_syntax_error(yypParser,yymajor,yyminorunion);\n      yy_destructor(yypParser,(YYCODETYPE)yymajor,&yyminorunion);\n      yymajor = YYNOCODE;\n      \n#else  /* YYERRORSYMBOL is not defined */\n      /* This is what we do if the grammar does not define ERROR:\n      **\n      **  * Report an error message, and throw away the input token.\n      **\n      **  * If the input token is $, then fail the parse.\n      **\n      ** As before, subsequent error messages are suppressed until\n      ** three input tokens have been successfully shifted.\n      */\n      if( yypParser->yyerrcnt<=0 ){\n        yy_syntax_error(yypParser,yymajor,yyminorunion);\n      }\n      yypParser->yyerrcnt = 3;\n      yy_destructor(yypParser,(YYCODETYPE)yymajor,&yyminorunion);\n      if( yyendofinput ){\n        yy_parse_failed(yypParser);\n      }\n      yymajor = YYNOCODE;\n#endif\n    }\n  }while( yymajor!=YYNOCODE && yypParser->yyidx>=0 );\n  return;\n}\n\n/************** End of parse.c ***********************************************/\n/************** Begin file tokenize.c ****************************************/\n/*\n** 2001 September 15\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** An tokenizer for SQL\n**\n** This file contains C code that splits an SQL input string up into\n** individual tokens and sends those tokens one-by-one over to the\n** parser for analysis.\n*/\n\n/*\n** The charMap() macro maps alphabetic characters into their\n** lower-case ASCII equivalent.  On ASCII machines, this is just\n** an upper-to-lower case map.  On EBCDIC machines we also need\n** to adjust the encoding.  Only alphabetic characters and underscores\n** need to be translated.\n*/\n#ifdef SQLITE_ASCII\n# define charMap(X) sqlite3UpperToLower[(unsigned char)X]\n#endif\n#ifdef SQLITE_EBCDIC\n# define charMap(X) ebcdicToAscii[(unsigned char)X]\nconst unsigned char ebcdicToAscii[] = {\n/* 0   1   2   3   4   5   6   7   8   9   A   B   C   D   E   F */\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  /* 0x */\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  /* 1x */\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  /* 2x */\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  /* 3x */\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  /* 4x */\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  /* 5x */\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0, 95,  0,  0,  /* 6x */\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  /* 7x */\n   0, 97, 98, 99,100,101,102,103,104,105,  0,  0,  0,  0,  0,  0,  /* 8x */\n   0,106,107,108,109,110,111,112,113,114,  0,  0,  0,  0,  0,  0,  /* 9x */\n   0,  0,115,116,117,118,119,120,121,122,  0,  0,  0,  0,  0,  0,  /* Ax */\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  /* Bx */\n   0, 97, 98, 99,100,101,102,103,104,105,  0,  0,  0,  0,  0,  0,  /* Cx */\n   0,106,107,108,109,110,111,112,113,114,  0,  0,  0,  0,  0,  0,  /* Dx */\n   0,  0,115,116,117,118,119,120,121,122,  0,  0,  0,  0,  0,  0,  /* Ex */\n   0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  /* Fx */\n};\n#endif\n\n/*\n** The sqlite3KeywordCode function looks up an identifier to determine if\n** it is a keyword.  If it is a keyword, the token code of that keyword is \n** returned.  If the input is not a keyword, TK_ID is returned.\n**\n** The implementation of this routine was generated by a program,\n** mkkeywordhash.h, located in the tool subdirectory of the distribution.\n** The output of the mkkeywordhash.c program is written into a file\n** named keywordhash.h and then included into this source file by\n** the #include below.\n*/\n/************** Include keywordhash.h in the middle of tokenize.c ************/\n/************** Begin file keywordhash.h *************************************/\n/***** This file contains automatically generated code ******\n**\n** The code in this file has been automatically generated by\n**\n**   sqlite/tool/mkkeywordhash.c\n**\n** The code in this file implements a function that determines whether\n** or not a given identifier is really an SQL keyword.  The same thing\n** might be implemented more directly using a hand-written hash table.\n** But by using this automatically generated code, the size of the code\n** is substantially reduced.  This is important for embedded applications\n** on platforms with limited memory.\n*/\n/* Hash score: 175 */\nstatic int keywordCode(const char *z, int n){\n  /* zText[] encodes 811 bytes of keywords in 541 bytes */\n  /*   REINDEXEDESCAPEACHECKEYBEFOREIGNOREGEXPLAINSTEADDATABASELECT       */\n  /*   ABLEFTHENDEFERRABLELSEXCEPTRANSACTIONATURALTERAISEXCLUSIVE         */\n  /*   XISTSAVEPOINTERSECTRIGGEREFERENCESCONSTRAINTOFFSETEMPORARY         */\n  /*   UNIQUERYATTACHAVINGROUPDATEBEGINNERELEASEBETWEENOTNULLIKE          */\n  /*   CASCADELETECASECOLLATECREATECURRENT_DATEDETACHIMMEDIATEJOIN        */\n  /*   SERTMATCHPLANALYZEPRAGMABORTVALUESVIRTUALIMITWHENWHERENAME         */\n  /*   AFTEREPLACEANDEFAULTAUTOINCREMENTCASTCOLUMNCOMMITCONFLICTCROSS     */\n  /*   CURRENT_TIMESTAMPRIMARYDEFERREDISTINCTDROPFAILFROMFULLGLOBYIF      */\n  /*   ISNULLORDERESTRICTOUTERIGHTROLLBACKROWUNIONUSINGVACUUMVIEW         */\n  /*   INITIALLY                                                          */\n  static const char zText[540] = {\n    'R','E','I','N','D','E','X','E','D','E','S','C','A','P','E','A','C','H',\n    'E','C','K','E','Y','B','E','F','O','R','E','I','G','N','O','R','E','G',\n    'E','X','P','L','A','I','N','S','T','E','A','D','D','A','T','A','B','A',\n    'S','E','L','E','C','T','A','B','L','E','F','T','H','E','N','D','E','F',\n    'E','R','R','A','B','L','E','L','S','E','X','C','E','P','T','R','A','N',\n    'S','A','C','T','I','O','N','A','T','U','R','A','L','T','E','R','A','I',\n    'S','E','X','C','L','U','S','I','V','E','X','I','S','T','S','A','V','E',\n    'P','O','I','N','T','E','R','S','E','C','T','R','I','G','G','E','R','E',\n    'F','E','R','E','N','C','E','S','C','O','N','S','T','R','A','I','N','T',\n    'O','F','F','S','E','T','E','M','P','O','R','A','R','Y','U','N','I','Q',\n    'U','E','R','Y','A','T','T','A','C','H','A','V','I','N','G','R','O','U',\n    'P','D','A','T','E','B','E','G','I','N','N','E','R','E','L','E','A','S',\n    'E','B','E','T','W','E','E','N','O','T','N','U','L','L','I','K','E','C',\n    'A','S','C','A','D','E','L','E','T','E','C','A','S','E','C','O','L','L',\n    'A','T','E','C','R','E','A','T','E','C','U','R','R','E','N','T','_','D',\n    'A','T','E','D','E','T','A','C','H','I','M','M','E','D','I','A','T','E',\n    'J','O','I','N','S','E','R','T','M','A','T','C','H','P','L','A','N','A',\n    'L','Y','Z','E','P','R','A','G','M','A','B','O','R','T','V','A','L','U',\n    'E','S','V','I','R','T','U','A','L','I','M','I','T','W','H','E','N','W',\n    'H','E','R','E','N','A','M','E','A','F','T','E','R','E','P','L','A','C',\n    'E','A','N','D','E','F','A','U','L','T','A','U','T','O','I','N','C','R',\n    'E','M','E','N','T','C','A','S','T','C','O','L','U','M','N','C','O','M',\n    'M','I','T','C','O','N','F','L','I','C','T','C','R','O','S','S','C','U',\n    'R','R','E','N','T','_','T','I','M','E','S','T','A','M','P','R','I','M',\n    'A','R','Y','D','E','F','E','R','R','E','D','I','S','T','I','N','C','T',\n    'D','R','O','P','F','A','I','L','F','R','O','M','F','U','L','L','G','L',\n    'O','B','Y','I','F','I','S','N','U','L','L','O','R','D','E','R','E','S',\n    'T','R','I','C','T','O','U','T','E','R','I','G','H','T','R','O','L','L',\n    'B','A','C','K','R','O','W','U','N','I','O','N','U','S','I','N','G','V',\n    'A','C','U','U','M','V','I','E','W','I','N','I','T','I','A','L','L','Y',\n  };\n  static const unsigned char aHash[127] = {\n      72, 101, 114,  70,   0,  45,   0,   0,  78,   0,  73,   0,   0,\n      42,  12,  74,  15,   0, 113,  81,  50, 108,   0,  19,   0,   0,\n     118,   0, 116, 111,   0,  22,  89,   0,   9,   0,   0,  66,  67,\n       0,  65,   6,   0,  48,  86,  98,   0, 115,  97,   0,   0,  44,\n       0,  99,  24,   0,  17,   0, 119,  49,  23,   0,   5, 106,  25,\n      92,   0,   0, 121, 102,  56, 120,  53,  28,  51,   0,  87,   0,\n      96,  26,   0,  95,   0,   0,   0,  91,  88,  93,  84, 105,  14,\n      39, 104,   0,  77,   0,  18,  85, 107,  32,   0, 117,  76, 109,\n      58,  46,  80,   0,   0,  90,  40,   0, 112,   0,  36,   0,   0,\n      29,   0,  82,  59,  60,   0,  20,  57,   0,  52,\n  };\n  static const unsigned char aNext[121] = {\n       0,   0,   0,   0,   4,   0,   0,   0,   0,   0,   0,   0,   0,\n       0,   2,   0,   0,   0,   0,   0,   0,  13,   0,   0,   0,   0,\n       0,   7,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,\n       0,   0,   0,   0,  33,   0,  21,   0,   0,   0,  43,   3,  47,\n       0,   0,   0,   0,  30,   0,  54,   0,  38,   0,   0,   0,   1,\n      62,   0,   0,  63,   0,  41,   0,   0,   0,   0,   0,   0,   0,\n      61,   0,   0,   0,   0,  31,  55,  16,  34,  10,   0,   0,   0,\n       0,   0,   0,   0,  11,  68,  75,   0,   8,   0, 100,  94,   0,\n     103,   0,  83,   0,  71,   0,   0, 110,  27,  37,  69,  79,   0,\n      35,  64,   0,   0,\n  };\n  static const unsigned char aLen[121] = {\n       7,   7,   5,   4,   6,   4,   5,   3,   6,   7,   3,   6,   6,\n       7,   7,   3,   8,   2,   6,   5,   4,   4,   3,  10,   4,   6,\n      11,   6,   2,   7,   5,   5,   9,   6,   9,   9,   7,  10,  10,\n       4,   6,   2,   3,   9,   4,   2,   6,   5,   6,   6,   5,   6,\n       5,   5,   7,   7,   7,   3,   2,   4,   4,   7,   3,   6,   4,\n       7,   6,  12,   6,   9,   4,   6,   5,   4,   7,   6,   5,   6,\n       7,   5,   4,   5,   6,   5,   7,   3,   7,  13,   2,   2,   4,\n       6,   6,   8,   5,  17,  12,   7,   8,   8,   2,   4,   4,   4,\n       4,   4,   2,   2,   6,   5,   8,   5,   5,   8,   3,   5,   5,\n       6,   4,   9,   3,\n  };\n  static const unsigned short int aOffset[121] = {\n       0,   2,   2,   8,   9,  14,  16,  20,  23,  25,  25,  29,  33,\n      36,  41,  46,  48,  53,  54,  59,  62,  65,  67,  69,  78,  81,\n      86,  91,  95,  96, 101, 105, 109, 117, 122, 128, 136, 142, 152,\n     159, 162, 162, 165, 167, 167, 171, 176, 179, 184, 189, 194, 197,\n     203, 206, 210, 217, 223, 223, 223, 226, 229, 233, 234, 238, 244,\n     248, 255, 261, 273, 279, 288, 290, 296, 301, 303, 310, 315, 320,\n     326, 332, 337, 341, 344, 350, 354, 361, 363, 370, 372, 374, 383,\n     387, 393, 399, 407, 412, 412, 428, 435, 442, 443, 450, 454, 458,\n     462, 466, 469, 471, 473, 479, 483, 491, 495, 500, 508, 511, 516,\n     521, 527, 531, 536,\n  };\n  static const unsigned char aCode[121] = {\n    TK_REINDEX,    TK_INDEXED,    TK_INDEX,      TK_DESC,       TK_ESCAPE,     \n    TK_EACH,       TK_CHECK,      TK_KEY,        TK_BEFORE,     TK_FOREIGN,    \n    TK_FOR,        TK_IGNORE,     TK_LIKE_KW,    TK_EXPLAIN,    TK_INSTEAD,    \n    TK_ADD,        TK_DATABASE,   TK_AS,         TK_SELECT,     TK_TABLE,      \n    TK_JOIN_KW,    TK_THEN,       TK_END,        TK_DEFERRABLE, TK_ELSE,       \n    TK_EXCEPT,     TK_TRANSACTION,TK_ACTION,     TK_ON,         TK_JOIN_KW,    \n    TK_ALTER,      TK_RAISE,      TK_EXCLUSIVE,  TK_EXISTS,     TK_SAVEPOINT,  \n    TK_INTERSECT,  TK_TRIGGER,    TK_REFERENCES, TK_CONSTRAINT, TK_INTO,       \n    TK_OFFSET,     TK_OF,         TK_SET,        TK_TEMP,       TK_TEMP,       \n    TK_OR,         TK_UNIQUE,     TK_QUERY,      TK_ATTACH,     TK_HAVING,     \n    TK_GROUP,      TK_UPDATE,     TK_BEGIN,      TK_JOIN_KW,    TK_RELEASE,    \n    TK_BETWEEN,    TK_NOTNULL,    TK_NOT,        TK_NO,         TK_NULL,       \n    TK_LIKE_KW,    TK_CASCADE,    TK_ASC,        TK_DELETE,     TK_CASE,       \n    TK_COLLATE,    TK_CREATE,     TK_CTIME_KW,   TK_DETACH,     TK_IMMEDIATE,  \n    TK_JOIN,       TK_INSERT,     TK_MATCH,      TK_PLAN,       TK_ANALYZE,    \n    TK_PRAGMA,     TK_ABORT,      TK_VALUES,     TK_VIRTUAL,    TK_LIMIT,      \n    TK_WHEN,       TK_WHERE,      TK_RENAME,     TK_AFTER,      TK_REPLACE,    \n    TK_AND,        TK_DEFAULT,    TK_AUTOINCR,   TK_TO,         TK_IN,         \n    TK_CAST,       TK_COLUMNKW,   TK_COMMIT,     TK_CONFLICT,   TK_JOIN_KW,    \n    TK_CTIME_KW,   TK_CTIME_KW,   TK_PRIMARY,    TK_DEFERRED,   TK_DISTINCT,   \n    TK_IS,         TK_DROP,       TK_FAIL,       TK_FROM,       TK_JOIN_KW,    \n    TK_LIKE_KW,    TK_BY,         TK_IF,         TK_ISNULL,     TK_ORDER,      \n    TK_RESTRICT,   TK_JOIN_KW,    TK_JOIN_KW,    TK_ROLLBACK,   TK_ROW,        \n    TK_UNION,      TK_USING,      TK_VACUUM,     TK_VIEW,       TK_INITIALLY,  \n    TK_ALL,        \n  };\n  int h, i;\n  if( n<2 ) return TK_ID;\n  h = ((charMap(z[0])*4) ^\n      (charMap(z[n-1])*3) ^\n      n) % 127;\n  for(i=((int)aHash[h])-1; i>=0; i=((int)aNext[i])-1){\n    if( aLen[i]==n && sqlite3StrNICmp(&zText[aOffset[i]],z,n)==0 ){\n      testcase( i==0 ); /* REINDEX */\n      testcase( i==1 ); /* INDEXED */\n      testcase( i==2 ); /* INDEX */\n      testcase( i==3 ); /* DESC */\n      testcase( i==4 ); /* ESCAPE */\n      testcase( i==5 ); /* EACH */\n      testcase( i==6 ); /* CHECK */\n      testcase( i==7 ); /* KEY */\n      testcase( i==8 ); /* BEFORE */\n      testcase( i==9 ); /* FOREIGN */\n      testcase( i==10 ); /* FOR */\n      testcase( i==11 ); /* IGNORE */\n      testcase( i==12 ); /* REGEXP */\n      testcase( i==13 ); /* EXPLAIN */\n      testcase( i==14 ); /* INSTEAD */\n      testcase( i==15 ); /* ADD */\n      testcase( i==16 ); /* DATABASE */\n      testcase( i==17 ); /* AS */\n      testcase( i==18 ); /* SELECT */\n      testcase( i==19 ); /* TABLE */\n      testcase( i==20 ); /* LEFT */\n      testcase( i==21 ); /* THEN */\n      testcase( i==22 ); /* END */\n      testcase( i==23 ); /* DEFERRABLE */\n      testcase( i==24 ); /* ELSE */\n      testcase( i==25 ); /* EXCEPT */\n      testcase( i==26 ); /* TRANSACTION */\n      testcase( i==27 ); /* ACTION */\n      testcase( i==28 ); /* ON */\n      testcase( i==29 ); /* NATURAL */\n      testcase( i==30 ); /* ALTER */\n      testcase( i==31 ); /* RAISE */\n      testcase( i==32 ); /* EXCLUSIVE */\n      testcase( i==33 ); /* EXISTS */\n      testcase( i==34 ); /* SAVEPOINT */\n      testcase( i==35 ); /* INTERSECT */\n      testcase( i==36 ); /* TRIGGER */\n      testcase( i==37 ); /* REFERENCES */\n      testcase( i==38 ); /* CONSTRAINT */\n      testcase( i==39 ); /* INTO */\n      testcase( i==40 ); /* OFFSET */\n      testcase( i==41 ); /* OF */\n      testcase( i==42 ); /* SET */\n      testcase( i==43 ); /* TEMPORARY */\n      testcase( i==44 ); /* TEMP */\n      testcase( i==45 ); /* OR */\n      testcase( i==46 ); /* UNIQUE */\n      testcase( i==47 ); /* QUERY */\n      testcase( i==48 ); /* ATTACH */\n      testcase( i==49 ); /* HAVING */\n      testcase( i==50 ); /* GROUP */\n      testcase( i==51 ); /* UPDATE */\n      testcase( i==52 ); /* BEGIN */\n      testcase( i==53 ); /* INNER */\n      testcase( i==54 ); /* RELEASE */\n      testcase( i==55 ); /* BETWEEN */\n      testcase( i==56 ); /* NOTNULL */\n      testcase( i==57 ); /* NOT */\n      testcase( i==58 ); /* NO */\n      testcase( i==59 ); /* NULL */\n      testcase( i==60 ); /* LIKE */\n      testcase( i==61 ); /* CASCADE */\n      testcase( i==62 ); /* ASC */\n      testcase( i==63 ); /* DELETE */\n      testcase( i==64 ); /* CASE */\n      testcase( i==65 ); /* COLLATE */\n      testcase( i==66 ); /* CREATE */\n      testcase( i==67 ); /* CURRENT_DATE */\n      testcase( i==68 ); /* DETACH */\n      testcase( i==69 ); /* IMMEDIATE */\n      testcase( i==70 ); /* JOIN */\n      testcase( i==71 ); /* INSERT */\n      testcase( i==72 ); /* MATCH */\n      testcase( i==73 ); /* PLAN */\n      testcase( i==74 ); /* ANALYZE */\n      testcase( i==75 ); /* PRAGMA */\n      testcase( i==76 ); /* ABORT */\n      testcase( i==77 ); /* VALUES */\n      testcase( i==78 ); /* VIRTUAL */\n      testcase( i==79 ); /* LIMIT */\n      testcase( i==80 ); /* WHEN */\n      testcase( i==81 ); /* WHERE */\n      testcase( i==82 ); /* RENAME */\n      testcase( i==83 ); /* AFTER */\n      testcase( i==84 ); /* REPLACE */\n      testcase( i==85 ); /* AND */\n      testcase( i==86 ); /* DEFAULT */\n      testcase( i==87 ); /* AUTOINCREMENT */\n      testcase( i==88 ); /* TO */\n      testcase( i==89 ); /* IN */\n      testcase( i==90 ); /* CAST */\n      testcase( i==91 ); /* COLUMN */\n      testcase( i==92 ); /* COMMIT */\n      testcase( i==93 ); /* CONFLICT */\n      testcase( i==94 ); /* CROSS */\n      testcase( i==95 ); /* CURRENT_TIMESTAMP */\n      testcase( i==96 ); /* CURRENT_TIME */\n      testcase( i==97 ); /* PRIMARY */\n      testcase( i==98 ); /* DEFERRED */\n      testcase( i==99 ); /* DISTINCT */\n      testcase( i==100 ); /* IS */\n      testcase( i==101 ); /* DROP */\n      testcase( i==102 ); /* FAIL */\n      testcase( i==103 ); /* FROM */\n      testcase( i==104 ); /* FULL */\n      testcase( i==105 ); /* GLOB */\n      testcase( i==106 ); /* BY */\n      testcase( i==107 ); /* IF */\n      testcase( i==108 ); /* ISNULL */\n      testcase( i==109 ); /* ORDER */\n      testcase( i==110 ); /* RESTRICT */\n      testcase( i==111 ); /* OUTER */\n      testcase( i==112 ); /* RIGHT */\n      testcase( i==113 ); /* ROLLBACK */\n      testcase( i==114 ); /* ROW */\n      testcase( i==115 ); /* UNION */\n      testcase( i==116 ); /* USING */\n      testcase( i==117 ); /* VACUUM */\n      testcase( i==118 ); /* VIEW */\n      testcase( i==119 ); /* INITIALLY */\n      testcase( i==120 ); /* ALL */\n      return aCode[i];\n    }\n  }\n  return TK_ID;\n}\nSQLITE_PRIVATE int sqlite3KeywordCode(const unsigned char *z, int n){\n  return keywordCode((char*)z, n);\n}\n#define SQLITE_N_KEYWORD 121\n\n/************** End of keywordhash.h *****************************************/\n/************** Continuing where we left off in tokenize.c *******************/\n\n\n/*\n** If X is a character that can be used in an identifier then\n** IdChar(X) will be true.  Otherwise it is false.\n**\n** For ASCII, any character with the high-order bit set is\n** allowed in an identifier.  For 7-bit characters, \n** sqlite3IsIdChar[X] must be 1.\n**\n** For EBCDIC, the rules are more complex but have the same\n** end result.\n**\n** Ticket #1066.  the SQL standard does not allow '$' in the\n** middle of identifiers.  But many SQL implementations do. \n** SQLite will allow '$' in identifiers for compatibility.\n** But the feature is undocumented.\n*/\n#ifdef SQLITE_ASCII\n#define IdChar(C)  ((sqlite3CtypeMap[(unsigned char)C]&0x46)!=0)\n#endif\n#ifdef SQLITE_EBCDIC\nSQLITE_PRIVATE const char sqlite3IsEbcdicIdChar[] = {\n/* x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 xA xB xC xD xE xF */\n    0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,  /* 4x */\n    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 0, 0, 0,  /* 5x */\n    0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0,  /* 6x */\n    0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0,  /* 7x */\n    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 0,  /* 8x */\n    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 0,  /* 9x */\n    1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0,  /* Ax */\n    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  /* Bx */\n    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,  /* Cx */\n    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,  /* Dx */\n    0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1,  /* Ex */\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 0,  /* Fx */\n};\n#define IdChar(C)  (((c=C)>=0x42 && sqlite3IsEbcdicIdChar[c-0x40]))\n#endif\n\n\n/*\n** Return the length of the token that begins at z[0]. \n** Store the token type in *tokenType before returning.\n*/\nSQLITE_PRIVATE int sqlite3GetToken(const unsigned char *z, int *tokenType){\n  int i, c;\n  switch( *z ){\n    case ' ': case '\\t': case '\\n': case '\\f': case '\\r': {\n      testcase( z[0]==' ' );\n      testcase( z[0]=='\\t' );\n      testcase( z[0]=='\\n' );\n      testcase( z[0]=='\\f' );\n      testcase( z[0]=='\\r' );\n      for(i=1; sqlite3Isspace(z[i]); i++){}\n      *tokenType = TK_SPACE;\n      return i;\n    }\n    case '-': {\n      if( z[1]=='-' ){\n        /* IMP: R-15891-05542 -- syntax diagram for comments */\n        for(i=2; (c=z[i])!=0 && c!='\\n'; i++){}\n        *tokenType = TK_SPACE;   /* IMP: R-22934-25134 */\n        return i;\n      }\n      *tokenType = TK_MINUS;\n      return 1;\n    }\n    case '(': {\n      *tokenType = TK_LP;\n      return 1;\n    }\n    case ')': {\n      *tokenType = TK_RP;\n      return 1;\n    }\n    case ';': {\n      *tokenType = TK_SEMI;\n      return 1;\n    }\n    case '+': {\n      *tokenType = TK_PLUS;\n      return 1;\n    }\n    case '*': {\n      *tokenType = TK_STAR;\n      return 1;\n    }\n    case '/': {\n      if( z[1]!='*' || z[2]==0 ){\n        *tokenType = TK_SLASH;\n        return 1;\n      }\n      /* IMP: R-15891-05542 -- syntax diagram for comments */\n      for(i=3, c=z[2]; (c!='*' || z[i]!='/') && (c=z[i])!=0; i++){}\n      if( c ) i++;\n      *tokenType = TK_SPACE;   /* IMP: R-22934-25134 */\n      return i;\n    }\n    case '%': {\n      *tokenType = TK_REM;\n      return 1;\n    }\n    case '=': {\n      *tokenType = TK_EQ;\n      return 1 + (z[1]=='=');\n    }\n    case '<': {\n      if( (c=z[1])=='=' ){\n        *tokenType = TK_LE;\n        return 2;\n      }else if( c=='>' ){\n        *tokenType = TK_NE;\n        return 2;\n      }else if( c=='<' ){\n        *tokenType = TK_LSHIFT;\n        return 2;\n      }else{\n        *tokenType = TK_LT;\n        return 1;\n      }\n    }\n    case '>': {\n      if( (c=z[1])=='=' ){\n        *tokenType = TK_GE;\n        return 2;\n      }else if( c=='>' ){\n        *tokenType = TK_RSHIFT;\n        return 2;\n      }else{\n        *tokenType = TK_GT;\n        return 1;\n      }\n    }\n    case '!': {\n      if( z[1]!='=' ){\n        *tokenType = TK_ILLEGAL;\n        return 2;\n      }else{\n        *tokenType = TK_NE;\n        return 2;\n      }\n    }\n    case '|': {\n      if( z[1]!='|' ){\n        *tokenType = TK_BITOR;\n        return 1;\n      }else{\n        *tokenType = TK_CONCAT;\n        return 2;\n      }\n    }\n    case ',': {\n      *tokenType = TK_COMMA;\n      return 1;\n    }\n    case '&': {\n      *tokenType = TK_BITAND;\n      return 1;\n    }\n    case '~': {\n      *tokenType = TK_BITNOT;\n      return 1;\n    }\n    case '`':\n    case '\\'':\n    case '\"': {\n      int delim = z[0];\n      testcase( delim=='`' );\n      testcase( delim=='\\'' );\n      testcase( delim=='\"' );\n      for(i=1; (c=z[i])!=0; i++){\n        if( c==delim ){\n          if( z[i+1]==delim ){\n            i++;\n          }else{\n            break;\n          }\n        }\n      }\n      if( c=='\\'' ){\n        *tokenType = TK_STRING;\n        return i+1;\n      }else if( c!=0 ){\n        *tokenType = TK_ID;\n        return i+1;\n      }else{\n        *tokenType = TK_ILLEGAL;\n        return i;\n      }\n    }\n    case '.': {\n#ifndef SQLITE_OMIT_FLOATING_POINT\n      if( !sqlite3Isdigit(z[1]) )\n#endif\n      {\n        *tokenType = TK_DOT;\n        return 1;\n      }\n      /* If the next character is a digit, this is a floating point\n      ** number that begins with \".\".  Fall thru into the next case */\n    }\n    case '0': case '1': case '2': case '3': case '4':\n    case '5': case '6': case '7': case '8': case '9': {\n      testcase( z[0]=='0' );  testcase( z[0]=='1' );  testcase( z[0]=='2' );\n      testcase( z[0]=='3' );  testcase( z[0]=='4' );  testcase( z[0]=='5' );\n      testcase( z[0]=='6' );  testcase( z[0]=='7' );  testcase( z[0]=='8' );\n      testcase( z[0]=='9' );\n      *tokenType = TK_INTEGER;\n      for(i=0; sqlite3Isdigit(z[i]); i++){}\n#ifndef SQLITE_OMIT_FLOATING_POINT\n      if( z[i]=='.' ){\n        i++;\n        while( sqlite3Isdigit(z[i]) ){ i++; }\n        *tokenType = TK_FLOAT;\n      }\n      if( (z[i]=='e' || z[i]=='E') &&\n           ( sqlite3Isdigit(z[i+1]) \n            || ((z[i+1]=='+' || z[i+1]=='-') && sqlite3Isdigit(z[i+2]))\n           )\n      ){\n        i += 2;\n        while( sqlite3Isdigit(z[i]) ){ i++; }\n        *tokenType = TK_FLOAT;\n      }\n#endif\n      while( IdChar(z[i]) ){\n        *tokenType = TK_ILLEGAL;\n        i++;\n      }\n      return i;\n    }\n    case '[': {\n      for(i=1, c=z[0]; c!=']' && (c=z[i])!=0; i++){}\n      *tokenType = c==']' ? TK_ID : TK_ILLEGAL;\n      return i;\n    }\n    case '?': {\n      *tokenType = TK_VARIABLE;\n      for(i=1; sqlite3Isdigit(z[i]); i++){}\n      return i;\n    }\n    case '#': {\n      for(i=1; sqlite3Isdigit(z[i]); i++){}\n      if( i>1 ){\n        /* Parameters of the form #NNN (where NNN is a number) are used\n        ** internally by sqlite3NestedParse.  */\n        *tokenType = TK_REGISTER;\n        return i;\n      }\n      /* Fall through into the next case if the '#' is not followed by\n      ** a digit. Try to match #AAAA where AAAA is a parameter name. */\n    }\n#ifndef SQLITE_OMIT_TCL_VARIABLE\n    case '$':\n#endif\n    case '@':  /* For compatibility with MS SQL Server */\n    case ':': {\n      int n = 0;\n      testcase( z[0]=='$' );  testcase( z[0]=='@' );  testcase( z[0]==':' );\n      *tokenType = TK_VARIABLE;\n      for(i=1; (c=z[i])!=0; i++){\n        if( IdChar(c) ){\n          n++;\n#ifndef SQLITE_OMIT_TCL_VARIABLE\n        }else if( c=='(' && n>0 ){\n          do{\n            i++;\n          }while( (c=z[i])!=0 && !sqlite3Isspace(c) && c!=')' );\n          if( c==')' ){\n            i++;\n          }else{\n            *tokenType = TK_ILLEGAL;\n          }\n          break;\n        }else if( c==':' && z[i+1]==':' ){\n          i++;\n#endif\n        }else{\n          break;\n        }\n      }\n      if( n==0 ) *tokenType = TK_ILLEGAL;\n      return i;\n    }\n#ifndef SQLITE_OMIT_BLOB_LITERAL\n    case 'x': case 'X': {\n      testcase( z[0]=='x' ); testcase( z[0]=='X' );\n      if( z[1]=='\\'' ){\n        *tokenType = TK_BLOB;\n        for(i=2; (c=z[i])!=0 && c!='\\''; i++){\n          if( !sqlite3Isxdigit(c) ){\n            *tokenType = TK_ILLEGAL;\n          }\n        }\n        if( i%2 || !c ) *tokenType = TK_ILLEGAL;\n        if( c ) i++;\n        return i;\n      }\n      /* Otherwise fall through to the next case */\n    }\n#endif\n    default: {\n      if( !IdChar(*z) ){\n        break;\n      }\n      for(i=1; IdChar(z[i]); i++){}\n      *tokenType = keywordCode((char*)z, i);\n      return i;\n    }\n  }\n  *tokenType = TK_ILLEGAL;\n  return 1;\n}\n\n/*\n** Run the parser on the given SQL string.  The parser structure is\n** passed in.  An SQLITE_ status code is returned.  If an error occurs\n** then an and attempt is made to write an error message into \n** memory obtained from sqlite3_malloc() and to make *pzErrMsg point to that\n** error message.\n*/\nSQLITE_PRIVATE int sqlite3RunParser(Parse *pParse, const char *zSql, char **pzErrMsg){\n  int nErr = 0;                   /* Number of errors encountered */\n  int i;                          /* Loop counter */\n  void *pEngine;                  /* The LEMON-generated LALR(1) parser */\n  int tokenType;                  /* type of the next token */\n  int lastTokenParsed = -1;       /* type of the previous token */\n  u8 enableLookaside;             /* Saved value of db->lookaside.bEnabled */\n  sqlite3 *db = pParse->db;       /* The database connection */\n  int mxSqlLen;                   /* Max length of an SQL string */\n\n\n  mxSqlLen = db->aLimit[SQLITE_LIMIT_SQL_LENGTH];\n  if( db->activeVdbeCnt==0 ){\n    db->u1.isInterrupted = 0;\n  }\n  pParse->rc = SQLITE_OK;\n  pParse->zTail = zSql;\n  i = 0;\n  assert( pzErrMsg!=0 );\n  pEngine = sqlite3ParserAlloc((void*(*)(size_t))sqlite3Malloc);\n  if( pEngine==0 ){\n    db->mallocFailed = 1;\n    return SQLITE_NOMEM;\n  }\n  assert( pParse->pNewTable==0 );\n  assert( pParse->pNewTrigger==0 );\n  assert( pParse->nVar==0 );\n  assert( pParse->nVarExpr==0 );\n  assert( pParse->nVarExprAlloc==0 );\n  assert( pParse->apVarExpr==0 );\n  enableLookaside = db->lookaside.bEnabled;\n  if( db->lookaside.pStart ) db->lookaside.bEnabled = 1;\n  while( !db->mallocFailed && zSql[i]!=0 ){\n    assert( i>=0 );\n    pParse->sLastToken.z = &zSql[i];\n    pParse->sLastToken.n = sqlite3GetToken((unsigned char*)&zSql[i],&tokenType);\n    i += pParse->sLastToken.n;\n    if( i>mxSqlLen ){\n      pParse->rc = SQLITE_TOOBIG;\n      break;\n    }\n    switch( tokenType ){\n      case TK_SPACE: {\n        if( db->u1.isInterrupted ){\n          sqlite3ErrorMsg(pParse, \"interrupt\");\n          pParse->rc = SQLITE_INTERRUPT;\n          goto abort_parse;\n        }\n        break;\n      }\n      case TK_ILLEGAL: {\n        sqlite3DbFree(db, *pzErrMsg);\n        *pzErrMsg = sqlite3MPrintf(db, \"unrecognized token: \\\"%T\\\"\",\n                        &pParse->sLastToken);\n        nErr++;\n        goto abort_parse;\n      }\n      case TK_SEMI: {\n        pParse->zTail = &zSql[i];\n        /* Fall thru into the default case */\n      }\n      default: {\n        sqlite3Parser(pEngine, tokenType, pParse->sLastToken, pParse);\n        lastTokenParsed = tokenType;\n        if( pParse->rc!=SQLITE_OK ){\n          goto abort_parse;\n        }\n        break;\n      }\n    }\n  }\nabort_parse:\n  if( zSql[i]==0 && nErr==0 && pParse->rc==SQLITE_OK ){\n    if( lastTokenParsed!=TK_SEMI ){\n      sqlite3Parser(pEngine, TK_SEMI, pParse->sLastToken, pParse);\n      pParse->zTail = &zSql[i];\n    }\n    sqlite3Parser(pEngine, 0, pParse->sLastToken, pParse);\n  }\n#ifdef YYTRACKMAXSTACKDEPTH\n  sqlite3StatusSet(SQLITE_STATUS_PARSER_STACK,\n      sqlite3ParserStackPeak(pEngine)\n  );\n#endif /* YYDEBUG */\n  sqlite3ParserFree(pEngine, sqlite3_free);\n  db->lookaside.bEnabled = enableLookaside;\n  if( db->mallocFailed ){\n    pParse->rc = SQLITE_NOMEM;\n  }\n  if( pParse->rc!=SQLITE_OK && pParse->rc!=SQLITE_DONE && pParse->zErrMsg==0 ){\n    sqlite3SetString(&pParse->zErrMsg, db, \"%s\", sqlite3ErrStr(pParse->rc));\n  }\n  assert( pzErrMsg!=0 );\n  if( pParse->zErrMsg ){\n    *pzErrMsg = pParse->zErrMsg;\n    sqlite3_log(pParse->rc, \"%s\", *pzErrMsg);\n    pParse->zErrMsg = 0;\n    nErr++;\n  }\n  if( pParse->pVdbe && pParse->nErr>0 && pParse->nested==0 ){\n    sqlite3VdbeDelete(pParse->pVdbe);\n    pParse->pVdbe = 0;\n  }\n#ifndef SQLITE_OMIT_SHARED_CACHE\n  if( pParse->nested==0 ){\n    sqlite3DbFree(db, pParse->aTableLock);\n    pParse->aTableLock = 0;\n    pParse->nTableLock = 0;\n  }\n#endif\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  sqlite3_free(pParse->apVtabLock);\n#endif\n\n  if( !IN_DECLARE_VTAB ){\n    /* If the pParse->declareVtab flag is set, do not delete any table \n    ** structure built up in pParse->pNewTable. The calling code (see vtab.c)\n    ** will take responsibility for freeing the Table structure.\n    */\n    sqlite3DeleteTable(db, pParse->pNewTable);\n  }\n\n  sqlite3DeleteTrigger(db, pParse->pNewTrigger);\n  sqlite3DbFree(db, pParse->apVarExpr);\n  sqlite3DbFree(db, pParse->aAlias);\n  while( pParse->pAinc ){\n    AutoincInfo *p = pParse->pAinc;\n    pParse->pAinc = p->pNext;\n    sqlite3DbFree(db, p);\n  }\n  while( pParse->pZombieTab ){\n    Table *p = pParse->pZombieTab;\n    pParse->pZombieTab = p->pNextZombie;\n    sqlite3DeleteTable(db, p);\n  }\n  if( nErr>0 && pParse->rc==SQLITE_OK ){\n    pParse->rc = SQLITE_ERROR;\n  }\n  return nErr;\n}\n\n/************** End of tokenize.c ********************************************/\n/************** Begin file complete.c ****************************************/\n/*\n** 2001 September 15\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** An tokenizer for SQL\n**\n** This file contains C code that implements the sqlite3_complete() API.\n** This code used to be part of the tokenizer.c source file.  But by\n** separating it out, the code will be automatically omitted from\n** static links that do not use it.\n*/\n#ifndef SQLITE_OMIT_COMPLETE\n\n/*\n** This is defined in tokenize.c.  We just have to import the definition.\n*/\n#ifndef SQLITE_AMALGAMATION\n#ifdef SQLITE_ASCII\n#define IdChar(C)  ((sqlite3CtypeMap[(unsigned char)C]&0x46)!=0)\n#endif\n#ifdef SQLITE_EBCDIC\nSQLITE_PRIVATE const char sqlite3IsEbcdicIdChar[];\n#define IdChar(C)  (((c=C)>=0x42 && sqlite3IsEbcdicIdChar[c-0x40]))\n#endif\n#endif /* SQLITE_AMALGAMATION */\n\n\n/*\n** Token types used by the sqlite3_complete() routine.  See the header\n** comments on that procedure for additional information.\n*/\n#define tkSEMI    0\n#define tkWS      1\n#define tkOTHER   2\n#ifndef SQLITE_OMIT_TRIGGER\n#define tkEXPLAIN 3\n#define tkCREATE  4\n#define tkTEMP    5\n#define tkTRIGGER 6\n#define tkEND     7\n#endif\n\n/*\n** Return TRUE if the given SQL string ends in a semicolon.\n**\n** Special handling is require for CREATE TRIGGER statements.\n** Whenever the CREATE TRIGGER keywords are seen, the statement\n** must end with \";END;\".\n**\n** This implementation uses a state machine with 8 states:\n**\n**   (0) INVALID   We have not yet seen a non-whitespace character.\n**\n**   (1) START     At the beginning or end of an SQL statement.  This routine\n**                 returns 1 if it ends in the START state and 0 if it ends\n**                 in any other state.\n**\n**   (2) NORMAL    We are in the middle of statement which ends with a single\n**                 semicolon.\n**\n**   (3) EXPLAIN   The keyword EXPLAIN has been seen at the beginning of \n**                 a statement.\n**\n**   (4) CREATE    The keyword CREATE has been seen at the beginning of a\n**                 statement, possibly preceeded by EXPLAIN and/or followed by\n**                 TEMP or TEMPORARY\n**\n**   (5) TRIGGER   We are in the middle of a trigger definition that must be\n**                 ended by a semicolon, the keyword END, and another semicolon.\n**\n**   (6) SEMI      We've seen the first semicolon in the \";END;\" that occurs at\n**                 the end of a trigger definition.\n**\n**   (7) END       We've seen the \";END\" of the \";END;\" that occurs at the end\n**                 of a trigger difinition.\n**\n** Transitions between states above are determined by tokens extracted\n** from the input.  The following tokens are significant:\n**\n**   (0) tkSEMI      A semicolon.\n**   (1) tkWS        Whitespace.\n**   (2) tkOTHER     Any other SQL token.\n**   (3) tkEXPLAIN   The \"explain\" keyword.\n**   (4) tkCREATE    The \"create\" keyword.\n**   (5) tkTEMP      The \"temp\" or \"temporary\" keyword.\n**   (6) tkTRIGGER   The \"trigger\" keyword.\n**   (7) tkEND       The \"end\" keyword.\n**\n** Whitespace never causes a state transition and is always ignored.\n** This means that a SQL string of all whitespace is invalid.\n**\n** If we compile with SQLITE_OMIT_TRIGGER, all of the computation needed\n** to recognize the end of a trigger can be omitted.  All we have to do\n** is look for a semicolon that is not part of an string or comment.\n*/\nSQLITE_API int sqlite3_complete(const char *zSql){\n  u8 state = 0;   /* Current state, using numbers defined in header comment */\n  u8 token;       /* Value of the next token */\n\n#ifndef SQLITE_OMIT_TRIGGER\n  /* A complex statement machine used to detect the end of a CREATE TRIGGER\n  ** statement.  This is the normal case.\n  */\n  static const u8 trans[8][8] = {\n                     /* Token:                                                */\n     /* State:       **  SEMI  WS  OTHER  EXPLAIN  CREATE  TEMP  TRIGGER  END */\n     /* 0 INVALID: */ {    1,  0,     2,       3,      4,    2,       2,   2, },\n     /* 1   START: */ {    1,  1,     2,       3,      4,    2,       2,   2, },\n     /* 2  NORMAL: */ {    1,  2,     2,       2,      2,    2,       2,   2, },\n     /* 3 EXPLAIN: */ {    1,  3,     3,       2,      4,    2,       2,   2, },\n     /* 4  CREATE: */ {    1,  4,     2,       2,      2,    4,       5,   2, },\n     /* 5 TRIGGER: */ {    6,  5,     5,       5,      5,    5,       5,   5, },\n     /* 6    SEMI: */ {    6,  6,     5,       5,      5,    5,       5,   7, },\n     /* 7     END: */ {    1,  7,     5,       5,      5,    5,       5,   5, },\n  };\n#else\n  /* If triggers are not supported by this compile then the statement machine\n  ** used to detect the end of a statement is much simplier\n  */\n  static const u8 trans[3][3] = {\n                     /* Token:           */\n     /* State:       **  SEMI  WS  OTHER */\n     /* 0 INVALID: */ {    1,  0,     2, },\n     /* 1   START: */ {    1,  1,     2, },\n     /* 2  NORMAL: */ {    1,  2,     2, },\n  };\n#endif /* SQLITE_OMIT_TRIGGER */\n\n  while( *zSql ){\n    switch( *zSql ){\n      case ';': {  /* A semicolon */\n        token = tkSEMI;\n        break;\n      }\n      case ' ':\n      case '\\r':\n      case '\\t':\n      case '\\n':\n      case '\\f': {  /* White space is ignored */\n        token = tkWS;\n        break;\n      }\n      case '/': {   /* C-style comments */\n        if( zSql[1]!='*' ){\n          token = tkOTHER;\n          break;\n        }\n        zSql += 2;\n        while( zSql[0] && (zSql[0]!='*' || zSql[1]!='/') ){ zSql++; }\n        if( zSql[0]==0 ) return 0;\n        zSql++;\n        token = tkWS;\n        break;\n      }\n      case '-': {   /* SQL-style comments from \"--\" to end of line */\n        if( zSql[1]!='-' ){\n          token = tkOTHER;\n          break;\n        }\n        while( *zSql && *zSql!='\\n' ){ zSql++; }\n        if( *zSql==0 ) return state==1;\n        token = tkWS;\n        break;\n      }\n      case '[': {   /* Microsoft-style identifiers in [...] */\n        zSql++;\n        while( *zSql && *zSql!=']' ){ zSql++; }\n        if( *zSql==0 ) return 0;\n        token = tkOTHER;\n        break;\n      }\n      case '`':     /* Grave-accent quoted symbols used by MySQL */\n      case '\"':     /* single- and double-quoted strings */\n      case '\\'': {\n        int c = *zSql;\n        zSql++;\n        while( *zSql && *zSql!=c ){ zSql++; }\n        if( *zSql==0 ) return 0;\n        token = tkOTHER;\n        break;\n      }\n      default: {\n#ifdef SQLITE_EBCDIC\n        unsigned char c;\n#endif\n        if( IdChar((u8)*zSql) ){\n          /* Keywords and unquoted identifiers */\n          int nId;\n          for(nId=1; IdChar(zSql[nId]); nId++){}\n#ifdef SQLITE_OMIT_TRIGGER\n          token = tkOTHER;\n#else\n          switch( *zSql ){\n            case 'c': case 'C': {\n              if( nId==6 && sqlite3StrNICmp(zSql, \"create\", 6)==0 ){\n                token = tkCREATE;\n              }else{\n                token = tkOTHER;\n              }\n              break;\n            }\n            case 't': case 'T': {\n              if( nId==7 && sqlite3StrNICmp(zSql, \"trigger\", 7)==0 ){\n                token = tkTRIGGER;\n              }else if( nId==4 && sqlite3StrNICmp(zSql, \"temp\", 4)==0 ){\n                token = tkTEMP;\n              }else if( nId==9 && sqlite3StrNICmp(zSql, \"temporary\", 9)==0 ){\n                token = tkTEMP;\n              }else{\n                token = tkOTHER;\n              }\n              break;\n            }\n            case 'e':  case 'E': {\n              if( nId==3 && sqlite3StrNICmp(zSql, \"end\", 3)==0 ){\n                token = tkEND;\n              }else\n#ifndef SQLITE_OMIT_EXPLAIN\n              if( nId==7 && sqlite3StrNICmp(zSql, \"explain\", 7)==0 ){\n                token = tkEXPLAIN;\n              }else\n#endif\n              {\n                token = tkOTHER;\n              }\n              break;\n            }\n            default: {\n              token = tkOTHER;\n              break;\n            }\n          }\n#endif /* SQLITE_OMIT_TRIGGER */\n          zSql += nId-1;\n        }else{\n          /* Operators and special symbols */\n          token = tkOTHER;\n        }\n        break;\n      }\n    }\n    state = trans[state][token];\n    zSql++;\n  }\n  return state==1;\n}\n\n#ifndef SQLITE_OMIT_UTF16\n/*\n** This routine is the same as the sqlite3_complete() routine described\n** above, except that the parameter is required to be UTF-16 encoded, not\n** UTF-8.\n*/\nSQLITE_API int sqlite3_complete16(const void *zSql){\n  sqlite3_value *pVal;\n  char const *zSql8;\n  int rc = SQLITE_NOMEM;\n\n#ifndef SQLITE_OMIT_AUTOINIT\n  rc = sqlite3_initialize();\n  if( rc ) return rc;\n#endif\n  pVal = sqlite3ValueNew(0);\n  sqlite3ValueSetStr(pVal, -1, zSql, SQLITE_UTF16NATIVE, SQLITE_STATIC);\n  zSql8 = sqlite3ValueText(pVal, SQLITE_UTF8);\n  if( zSql8 ){\n    rc = sqlite3_complete(zSql8);\n  }else{\n    rc = SQLITE_NOMEM;\n  }\n  sqlite3ValueFree(pVal);\n  return sqlite3ApiExit(0, rc);\n}\n#endif /* SQLITE_OMIT_UTF16 */\n#endif /* SQLITE_OMIT_COMPLETE */\n\n/************** End of complete.c ********************************************/\n/************** Begin file main.c ********************************************/\n/*\n** 2001 September 15\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** Main file for the SQLite library.  The routines in this file\n** implement the programmer interface to the library.  Routines in\n** other files are for internal use by SQLite and should not be\n** accessed by users of the library.\n*/\n\n#ifdef SQLITE_ENABLE_FTS3\n/************** Include fts3.h in the middle of main.c ***********************/\n/************** Begin file fts3.h ********************************************/\n/*\n** 2006 Oct 10\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n******************************************************************************\n**\n** This header file is used by programs that want to link against the\n** FTS3 library.  All it does is declare the sqlite3Fts3Init() interface.\n*/\n\n#if 0\nextern \"C\" {\n#endif  /* __cplusplus */\n\nSQLITE_PRIVATE int sqlite3Fts3Init(sqlite3 *db);\n\n#if 0\n}  /* extern \"C\" */\n#endif  /* __cplusplus */\n\n/************** End of fts3.h ************************************************/\n/************** Continuing where we left off in main.c ***********************/\n#endif\n#ifdef SQLITE_ENABLE_RTREE\n/************** Include rtree.h in the middle of main.c **********************/\n/************** Begin file rtree.h *******************************************/\n/*\n** 2008 May 26\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n******************************************************************************\n**\n** This header file is used by programs that want to link against the\n** RTREE library.  All it does is declare the sqlite3RtreeInit() interface.\n*/\n\n#if 0\nextern \"C\" {\n#endif  /* __cplusplus */\n\nSQLITE_PRIVATE int sqlite3RtreeInit(sqlite3 *db);\n\n#if 0\n}  /* extern \"C\" */\n#endif  /* __cplusplus */\n\n/************** End of rtree.h ***********************************************/\n/************** Continuing where we left off in main.c ***********************/\n#endif\n#ifdef SQLITE_ENABLE_ICU\n/************** Include sqliteicu.h in the middle of main.c ******************/\n/************** Begin file sqliteicu.h ***************************************/\n/*\n** 2008 May 26\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n******************************************************************************\n**\n** This header file is used by programs that want to link against the\n** ICU extension.  All it does is declare the sqlite3IcuInit() interface.\n*/\n\n#if 0\nextern \"C\" {\n#endif  /* __cplusplus */\n\nSQLITE_PRIVATE int sqlite3IcuInit(sqlite3 *db);\n\n#if 0\n}  /* extern \"C\" */\n#endif  /* __cplusplus */\n\n\n/************** End of sqliteicu.h *******************************************/\n/************** Continuing where we left off in main.c ***********************/\n#endif\n\n//#ifndef SQLITE_AMALGAMATION\n/* IMPLEMENTATION-OF: R-46656-45156 The sqlite3_version[] string constant\n** contains the text of SQLITE_VERSION macro. \n*/\nSQLITE_API const char sqlite3_version[] = SQLITE_VERSION;\n//#endif\n\n/* IMPLEMENTATION-OF: R-53536-42575 The sqlite3_libversion() function returns\n** a pointer to the to the sqlite3_version[] string constant. \n*/\nSQLITE_API const char *sqlite3_libversion(void){ return sqlite3_version; }\n\n/* IMPLEMENTATION-OF: R-63124-39300 The sqlite3_sourceid() function returns a\n** pointer to a string constant whose value is the same as the\n** SQLITE_SOURCE_ID C preprocessor macro. \n*/\nSQLITE_API const char *sqlite3_sourceid(void){ return SQLITE_SOURCE_ID; }\n\n/* IMPLEMENTATION-OF: R-35210-63508 The sqlite3_libversion_number() function\n** returns an integer equal to SQLITE_VERSION_NUMBER.\n*/\nSQLITE_API int sqlite3_libversion_number(void){ return SQLITE_VERSION_NUMBER; }\n\n/* IMPLEMENTATION-OF: R-54823-41343 The sqlite3_threadsafe() function returns\n** zero if and only if SQLite was compiled mutexing code omitted due to\n** the SQLITE_THREADSAFE compile-time option being set to 0.\n*/\nSQLITE_API int sqlite3_threadsafe(void){ return SQLITE_THREADSAFE; }\n\n#if !defined(SQLITE_OMIT_TRACE) && defined(SQLITE_ENABLE_IOTRACE)\n/*\n** If the following function pointer is not NULL and if\n** SQLITE_ENABLE_IOTRACE is enabled, then messages describing\n** I/O active are written using this function.  These messages\n** are intended for debugging activity only.\n*/\nSQLITE_PRIVATE void (*sqlite3IoTrace)(const char*, ...) = 0;\n#endif\n\n/*\n** If the following global variable points to a string which is the\n** name of a directory, then that directory will be used to store\n** temporary files.\n**\n** See also the \"PRAGMA temp_store_directory\" SQL command.\n*/\nSQLITE_API char *sqlite3_temp_directory = 0;\n\n/*\n** Initialize SQLite.  \n**\n** This routine must be called to initialize the memory allocation,\n** VFS, and mutex subsystems prior to doing any serious work with\n** SQLite.  But as long as you do not compile with SQLITE_OMIT_AUTOINIT\n** this routine will be called automatically by key routines such as\n** sqlite3_open().  \n**\n** This routine is a no-op except on its very first call for the process,\n** or for the first call after a call to sqlite3_shutdown.\n**\n** The first thread to call this routine runs the initialization to\n** completion.  If subsequent threads call this routine before the first\n** thread has finished the initialization process, then the subsequent\n** threads must block until the first thread finishes with the initialization.\n**\n** The first thread might call this routine recursively.  Recursive\n** calls to this routine should not block, of course.  Otherwise the\n** initialization process would never complete.\n**\n** Let X be the first thread to enter this routine.  Let Y be some other\n** thread.  Then while the initial invocation of this routine by X is\n** incomplete, it is required that:\n**\n**    *  Calls to this routine from Y must block until the outer-most\n**       call by X completes.\n**\n**    *  Recursive calls to this routine from thread X return immediately\n**       without blocking.\n*/\nSQLITE_API int sqlite3_initialize(void){\n  sqlite3_mutex *pMaster;                      /* The main static mutex */\n  int rc;                                      /* Result code */\n\n#ifdef SQLITE_OMIT_WSD\n  rc = sqlite3_wsd_init(4096, 24);\n  if( rc!=SQLITE_OK ){\n    return rc;\n  }\n#endif\n\n  /* If SQLite is already completely initialized, then this call\n  ** to sqlite3_initialize() should be a no-op.  But the initialization\n  ** must be complete.  So isInit must not be set until the very end\n  ** of this routine.\n  */\n  if( sqlite3GlobalConfig.isInit ) return SQLITE_OK;\n\n  /* Make sure the mutex subsystem is initialized.  If unable to \n  ** initialize the mutex subsystem, return early with the error.\n  ** If the system is so sick that we are unable to allocate a mutex,\n  ** there is not much SQLite is going to be able to do.\n  **\n  ** The mutex subsystem must take care of serializing its own\n  ** initialization.\n  */\n  rc = sqlite3MutexInit();\n  if( rc ) return rc;\n\n  /* Initialize the malloc() system and the recursive pInitMutex mutex.\n  ** This operation is protected by the STATIC_MASTER mutex.  Note that\n  ** MutexAlloc() is called for a static mutex prior to initializing the\n  ** malloc subsystem - this implies that the allocation of a static\n  ** mutex must not require support from the malloc subsystem.\n  */\n  pMaster = sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER);\n  sqlite3_mutex_enter(pMaster);\n  sqlite3GlobalConfig.isMutexInit = 1;\n  if( !sqlite3GlobalConfig.isMallocInit ){\n    rc = sqlite3MallocInit();\n  }\n  if( rc==SQLITE_OK ){\n    sqlite3GlobalConfig.isMallocInit = 1;\n    if( !sqlite3GlobalConfig.pInitMutex ){\n      sqlite3GlobalConfig.pInitMutex =\n           sqlite3MutexAlloc(SQLITE_MUTEX_RECURSIVE);\n      if( sqlite3GlobalConfig.bCoreMutex && !sqlite3GlobalConfig.pInitMutex ){\n        rc = SQLITE_NOMEM;\n      }\n    }\n  }\n  if( rc==SQLITE_OK ){\n    sqlite3GlobalConfig.nRefInitMutex++;\n  }\n  sqlite3_mutex_leave(pMaster);\n\n  /* If rc is not SQLITE_OK at this point, then either the malloc\n  ** subsystem could not be initialized or the system failed to allocate\n  ** the pInitMutex mutex. Return an error in either case.  */\n  if( rc!=SQLITE_OK ){\n    return rc;\n  }\n\n  /* Do the rest of the initialization under the recursive mutex so\n  ** that we will be able to handle recursive calls into\n  ** sqlite3_initialize().  The recursive calls normally come through\n  ** sqlite3_os_init() when it invokes sqlite3_vfs_register(), but other\n  ** recursive calls might also be possible.\n  **\n  ** IMPLEMENTATION-OF: R-00140-37445 SQLite automatically serializes calls\n  ** to the xInit method, so the xInit method need not be threadsafe.\n  **\n  ** The following mutex is what serializes access to the appdef pcache xInit\n  ** methods.  The sqlite3_pcache_methods.xInit() all is embedded in the\n  ** call to sqlite3PcacheInitialize().\n  */\n  sqlite3_mutex_enter(sqlite3GlobalConfig.pInitMutex);\n  if( sqlite3GlobalConfig.isInit==0 && sqlite3GlobalConfig.inProgress==0 ){\n    FuncDefHash *pHash = &GLOBAL(FuncDefHash, sqlite3GlobalFunctions);\n    sqlite3GlobalConfig.inProgress = 1;\n    memset(pHash, 0, sizeof(sqlite3GlobalFunctions));\n    sqlite3RegisterGlobalFunctions();\n    if( sqlite3GlobalConfig.isPCacheInit==0 ){\n      rc = sqlite3PcacheInitialize();\n    }\n    if( rc==SQLITE_OK ){\n      sqlite3GlobalConfig.isPCacheInit = 1;\n      rc = sqlite3OsInit();\n    }\n    if( rc==SQLITE_OK ){\n      sqlite3PCacheBufferSetup( sqlite3GlobalConfig.pPage, \n          sqlite3GlobalConfig.szPage, sqlite3GlobalConfig.nPage);\n      sqlite3GlobalConfig.isInit = 1;\n    }\n    sqlite3GlobalConfig.inProgress = 0;\n  }\n  sqlite3_mutex_leave(sqlite3GlobalConfig.pInitMutex);\n\n  /* Go back under the static mutex and clean up the recursive\n  ** mutex to prevent a resource leak.\n  */\n  sqlite3_mutex_enter(pMaster);\n  sqlite3GlobalConfig.nRefInitMutex--;\n  if( sqlite3GlobalConfig.nRefInitMutex<=0 ){\n    assert( sqlite3GlobalConfig.nRefInitMutex==0 );\n    sqlite3_mutex_free(sqlite3GlobalConfig.pInitMutex);\n    sqlite3GlobalConfig.pInitMutex = 0;\n  }\n  sqlite3_mutex_leave(pMaster);\n\n  /* The following is just a sanity check to make sure SQLite has\n  ** been compiled correctly.  It is important to run this code, but\n  ** we don't want to run it too often and soak up CPU cycles for no\n  ** reason.  So we run it once during initialization.\n  */\n#ifndef NDEBUG\n#ifndef SQLITE_OMIT_FLOATING_POINT\n  /* This section of code's only \"output\" is via assert() statements. */\n  if ( rc==SQLITE_OK ){\n    u64 x = (((u64)1)<<63)-1;\n    double y;\n    assert(sizeof(x)==8);\n    assert(sizeof(x)==sizeof(y));\n    memcpy(&y, &x, 8);\n    assert( sqlite3IsNaN(y) );\n  }\n#endif\n#endif\n\n  return rc;\n}\n\n/*\n** Undo the effects of sqlite3_initialize().  Must not be called while\n** there are outstanding database connections or memory allocations or\n** while any part of SQLite is otherwise in use in any thread.  This\n** routine is not threadsafe.  But it is safe to invoke this routine\n** on when SQLite is already shut down.  If SQLite is already shut down\n** when this routine is invoked, then this routine is a harmless no-op.\n*/\nSQLITE_API int sqlite3_shutdown(void){\n  if( sqlite3GlobalConfig.isInit ){\n    sqlite3_os_end();\n    sqlite3_reset_auto_extension();\n    sqlite3GlobalConfig.isInit = 0;\n  }\n  if( sqlite3GlobalConfig.isPCacheInit ){\n    sqlite3PcacheShutdown();\n    sqlite3GlobalConfig.isPCacheInit = 0;\n  }\n  if( sqlite3GlobalConfig.isMallocInit ){\n    sqlite3MallocEnd();\n    sqlite3GlobalConfig.isMallocInit = 0;\n  }\n  if( sqlite3GlobalConfig.isMutexInit ){\n    sqlite3MutexEnd();\n    sqlite3GlobalConfig.isMutexInit = 0;\n  }\n\n  return SQLITE_OK;\n}\n\n/*\n** This API allows applications to modify the global configuration of\n** the SQLite library at run-time.\n**\n** This routine should only be called when there are no outstanding\n** database connections or memory allocations.  This routine is not\n** threadsafe.  Failure to heed these warnings can lead to unpredictable\n** behavior.\n*/\nSQLITE_API int sqlite3_config(int op, ...){\n  va_list ap;\n  int rc = SQLITE_OK;\n\n  /* sqlite3_config() shall return SQLITE_MISUSE if it is invoked while\n  ** the SQLite library is in use. */\n  if( sqlite3GlobalConfig.isInit ) return SQLITE_MISUSE_BKPT;\n\n  va_start(ap, op);\n  switch( op ){\n\n    /* Mutex configuration options are only available in a threadsafe\n    ** compile. \n    */\n#if defined(SQLITE_THREADSAFE) && SQLITE_THREADSAFE>0\n    case SQLITE_CONFIG_SINGLETHREAD: {\n      /* Disable all mutexing */\n      sqlite3GlobalConfig.bCoreMutex = 0;\n      sqlite3GlobalConfig.bFullMutex = 0;\n      break;\n    }\n    case SQLITE_CONFIG_MULTITHREAD: {\n      /* Disable mutexing of database connections */\n      /* Enable mutexing of core data structures */\n      sqlite3GlobalConfig.bCoreMutex = 1;\n      sqlite3GlobalConfig.bFullMutex = 0;\n      break;\n    }\n    case SQLITE_CONFIG_SERIALIZED: {\n      /* Enable all mutexing */\n      sqlite3GlobalConfig.bCoreMutex = 1;\n      sqlite3GlobalConfig.bFullMutex = 1;\n      break;\n    }\n    case SQLITE_CONFIG_MUTEX: {\n      /* Specify an alternative mutex implementation */\n      sqlite3GlobalConfig.mutex = *va_arg(ap, sqlite3_mutex_methods*);\n      break;\n    }\n    case SQLITE_CONFIG_GETMUTEX: {\n      /* Retrieve the current mutex implementation */\n      *va_arg(ap, sqlite3_mutex_methods*) = sqlite3GlobalConfig.mutex;\n      break;\n    }\n#endif\n\n\n    case SQLITE_CONFIG_MALLOC: {\n      /* Specify an alternative malloc implementation */\n      sqlite3GlobalConfig.m = *va_arg(ap, sqlite3_mem_methods*);\n      break;\n    }\n    case SQLITE_CONFIG_GETMALLOC: {\n      /* Retrieve the current malloc() implementation */\n      if( sqlite3GlobalConfig.m.xMalloc==0 ) sqlite3MemSetDefault();\n      *va_arg(ap, sqlite3_mem_methods*) = sqlite3GlobalConfig.m;\n      break;\n    }\n    case SQLITE_CONFIG_MEMSTATUS: {\n      /* Enable or disable the malloc status collection */\n      sqlite3GlobalConfig.bMemstat = va_arg(ap, int);\n      break;\n    }\n    case SQLITE_CONFIG_SCRATCH: {\n      /* Designate a buffer for scratch memory space */\n      sqlite3GlobalConfig.pScratch = va_arg(ap, void*);\n      sqlite3GlobalConfig.szScratch = va_arg(ap, int);\n      sqlite3GlobalConfig.nScratch = va_arg(ap, int);\n      break;\n    }\n    case SQLITE_CONFIG_PAGECACHE: {\n      /* Designate a buffer for page cache memory space */\n      sqlite3GlobalConfig.pPage = va_arg(ap, void*);\n      sqlite3GlobalConfig.szPage = va_arg(ap, int);\n      sqlite3GlobalConfig.nPage = va_arg(ap, int);\n      break;\n    }\n\n    case SQLITE_CONFIG_PCACHE: {\n      /* Specify an alternative page cache implementation */\n      sqlite3GlobalConfig.pcache = *va_arg(ap, sqlite3_pcache_methods*);\n      break;\n    }\n\n    case SQLITE_CONFIG_GETPCACHE: {\n      if( sqlite3GlobalConfig.pcache.xInit==0 ){\n        sqlite3PCacheSetDefault();\n      }\n      *va_arg(ap, sqlite3_pcache_methods*) = sqlite3GlobalConfig.pcache;\n      break;\n    }\n\n#if defined(SQLITE_ENABLE_MEMSYS3) || defined(SQLITE_ENABLE_MEMSYS5)\n    case SQLITE_CONFIG_HEAP: {\n      /* Designate a buffer for heap memory space */\n      sqlite3GlobalConfig.pHeap = va_arg(ap, void*);\n      sqlite3GlobalConfig.nHeap = va_arg(ap, int);\n      sqlite3GlobalConfig.mnReq = va_arg(ap, int);\n\n      if( sqlite3GlobalConfig.mnReq<1 ){\n        sqlite3GlobalConfig.mnReq = 1;\n      }else if( sqlite3GlobalConfig.mnReq>(1<<12) ){\n        /* cap min request size at 2^12 */\n        sqlite3GlobalConfig.mnReq = (1<<12);\n      }\n\n      if( sqlite3GlobalConfig.pHeap==0 ){\n        /* If the heap pointer is NULL, then restore the malloc implementation\n        ** back to NULL pointers too.  This will cause the malloc to go\n        ** back to its default implementation when sqlite3_initialize() is\n        ** run.\n        */\n        memset(&sqlite3GlobalConfig.m, 0, sizeof(sqlite3GlobalConfig.m));\n      }else{\n        /* The heap pointer is not NULL, then install one of the\n        ** mem5.c/mem3.c methods. If neither ENABLE_MEMSYS3 nor\n        ** ENABLE_MEMSYS5 is defined, return an error.\n        */\n#ifdef SQLITE_ENABLE_MEMSYS3\n        sqlite3GlobalConfig.m = *sqlite3MemGetMemsys3();\n#endif\n#ifdef SQLITE_ENABLE_MEMSYS5\n        sqlite3GlobalConfig.m = *sqlite3MemGetMemsys5();\n#endif\n      }\n      break;\n    }\n#endif\n\n    case SQLITE_CONFIG_LOOKASIDE: {\n      sqlite3GlobalConfig.szLookaside = va_arg(ap, int);\n      sqlite3GlobalConfig.nLookaside = va_arg(ap, int);\n      break;\n    }\n    \n    /* Record a pointer to the logger funcction and its first argument.\n    ** The default is NULL.  Logging is disabled if the function pointer is\n    ** NULL.\n    */\n    case SQLITE_CONFIG_LOG: {\n      /* MSVC is picky about pulling func ptrs from va lists.\n      ** http://support.microsoft.com/kb/47961\n      ** sqlite3GlobalConfig.xLog = va_arg(ap, void(*)(void*,int,const char*));\n      */\n      typedef void(*LOGFUNC_t)(void*,int,const char*);\n      sqlite3GlobalConfig.xLog = va_arg(ap, LOGFUNC_t);\n      sqlite3GlobalConfig.pLogArg = va_arg(ap, void*);\n      break;\n    }\n\n    default: {\n      rc = SQLITE_ERROR;\n      break;\n    }\n  }\n  va_end(ap);\n  return rc;\n}\n\n/*\n** Set up the lookaside buffers for a database connection.\n** Return SQLITE_OK on success.  \n** If lookaside is already active, return SQLITE_BUSY.\n**\n** The sz parameter is the number of bytes in each lookaside slot.\n** The cnt parameter is the number of slots.  If pStart is NULL the\n** space for the lookaside memory is obtained from sqlite3_malloc().\n** If pStart is not NULL then it is sz*cnt bytes of memory to use for\n** the lookaside memory.\n*/\nstatic int setupLookaside(sqlite3 *db, void *pBuf, int sz, int cnt){\n  void *pStart;\n  if( db->lookaside.nOut ){\n    return SQLITE_BUSY;\n  }\n  /* Free any existing lookaside buffer for this handle before\n  ** allocating a new one so we don't have to have space for \n  ** both at the same time.\n  */\n  if( db->lookaside.bMalloced ){\n    sqlite3_free(db->lookaside.pStart);\n  }\n  /* The size of a lookaside slot needs to be larger than a pointer\n  ** to be useful.\n  */\n  if( sz<=(int)sizeof(LookasideSlot*) ) sz = 0;\n  if( cnt<0 ) cnt = 0;\n  if( sz==0 || cnt==0 ){\n    sz = 0;\n    pStart = 0;\n  }else if( pBuf==0 ){\n    sz = ROUNDDOWN8(sz); /* IMP: R-33038-09382 */\n    sqlite3BeginBenignMalloc();\n    pStart = sqlite3Malloc( sz*cnt );  /* IMP: R-61949-35727 */\n    sqlite3EndBenignMalloc();\n  }else{\n    sz = ROUNDDOWN8(sz); /* IMP: R-33038-09382 */\n    pStart = pBuf;\n  }\n  db->lookaside.pStart = pStart;\n  db->lookaside.pFree = 0;\n  db->lookaside.sz = (u16)sz;\n  if( pStart ){\n    int i;\n    LookasideSlot *p;\n    assert( sz > (int)sizeof(LookasideSlot*) );\n    p = (LookasideSlot*)pStart;\n    for(i=cnt-1; i>=0; i--){\n      p->pNext = db->lookaside.pFree;\n      db->lookaside.pFree = p;\n      p = (LookasideSlot*)&((u8*)p)[sz];\n    }\n    db->lookaside.pEnd = p;\n    db->lookaside.bEnabled = 1;\n    db->lookaside.bMalloced = pBuf==0 ?1:0;\n  }else{\n    db->lookaside.pEnd = 0;\n    db->lookaside.bEnabled = 0;\n    db->lookaside.bMalloced = 0;\n  }\n  return SQLITE_OK;\n}\n\n/*\n** Return the mutex associated with a database connection.\n*/\nSQLITE_API sqlite3_mutex *sqlite3_db_mutex(sqlite3 *db){\n  return db->mutex;\n}\n\n/*\n** Configuration settings for an individual database connection\n*/\nSQLITE_API int sqlite3_db_config(sqlite3 *db, int op, ...){\n  va_list ap;\n  int rc;\n  va_start(ap, op);\n  switch( op ){\n    case SQLITE_DBCONFIG_LOOKASIDE: {\n      void *pBuf = va_arg(ap, void*); /* IMP: R-21112-12275 */\n      int sz = va_arg(ap, int);       /* IMP: R-47871-25994 */\n      int cnt = va_arg(ap, int);      /* IMP: R-04460-53386 */\n      rc = setupLookaside(db, pBuf, sz, cnt);\n      break;\n    }\n    default: {\n      rc = SQLITE_ERROR; /* IMP: R-42790-23372 */\n      break;\n    }\n  }\n  va_end(ap);\n  return rc;\n}\n\n\n/*\n** Return true if the buffer z[0..n-1] contains all spaces.\n*/\nstatic int allSpaces(const char *z, int n){\n  while( n>0 && z[n-1]==' ' ){ n--; }\n  return n==0;\n}\n\n/*\n** This is the default collating function named \"BINARY\" which is always\n** available.\n**\n** If the padFlag argument is not NULL then space padding at the end\n** of strings is ignored.  This implements the RTRIM collation.\n*/\nstatic int binCollFunc(\n  void *padFlag,\n  int nKey1, const void *pKey1,\n  int nKey2, const void *pKey2\n){\n  int rc, n;\n  n = nKey1<nKey2 ? nKey1 : nKey2;\n  rc = memcmp(pKey1, pKey2, n);\n  if( rc==0 ){\n    if( padFlag\n     && allSpaces(((char*)pKey1)+n, nKey1-n)\n     && allSpaces(((char*)pKey2)+n, nKey2-n)\n    ){\n      /* Leave rc unchanged at 0 */\n    }else{\n      rc = nKey1 - nKey2;\n    }\n  }\n  return rc;\n}\n\n/*\n** Another built-in collating sequence: NOCASE. \n**\n** This collating sequence is intended to be used for \"case independant\n** comparison\". SQLite's knowledge of upper and lower case equivalents\n** extends only to the 26 characters used in the English language.\n**\n** At the moment there is only a UTF-8 implementation.\n*/\nstatic int nocaseCollatingFunc(\n  void *NotUsed,\n  int nKey1, const void *pKey1,\n  int nKey2, const void *pKey2\n){\n  int r = sqlite3StrNICmp(\n      (const char *)pKey1, (const char *)pKey2, (nKey1<nKey2)?nKey1:nKey2);\n  UNUSED_PARAMETER(NotUsed);\n  if( 0==r ){\n    r = nKey1-nKey2;\n  }\n  return r;\n}\n\n/*\n** Return the ROWID of the most recent insert\n*/\nSQLITE_API sqlite_int64 sqlite3_last_insert_rowid(sqlite3 *db){\n  return db->lastRowid;\n}\n\n/*\n** Return the number of changes in the most recent call to sqlite3_exec().\n*/\nSQLITE_API int sqlite3_changes(sqlite3 *db){\n  return db->nChange;\n}\n\n/*\n** Return the number of changes since the database handle was opened.\n*/\nSQLITE_API int sqlite3_total_changes(sqlite3 *db){\n  return db->nTotalChange;\n}\n\n/*\n** Close all open savepoints. This function only manipulates fields of the\n** database handle object, it does not close any savepoints that may be open\n** at the b-tree/pager level.\n*/\nSQLITE_PRIVATE void sqlite3CloseSavepoints(sqlite3 *db){\n  while( db->pSavepoint ){\n    Savepoint *pTmp = db->pSavepoint;\n    db->pSavepoint = pTmp->pNext;\n    sqlite3DbFree(db, pTmp);\n  }\n  db->nSavepoint = 0;\n  db->nStatement = 0;\n  db->isTransactionSavepoint = 0;\n}\n\n/*\n** Invoke the destructor function associated with FuncDef p, if any. Except,\n** if this is not the last copy of the function, do not invoke it. Multiple\n** copies of a single function are created when create_function() is called\n** with SQLITE_ANY as the encoding.\n*/\nstatic void functionDestroy(sqlite3 *db, FuncDef *p){\n  FuncDestructor *pDestructor = p->pDestructor;\n  if( pDestructor ){\n    pDestructor->nRef--;\n    if( pDestructor->nRef==0 ){\n      pDestructor->xDestroy(pDestructor->pUserData);\n      sqlite3DbFree(db, pDestructor);\n    }\n  }\n}\n\n/*\n** Close an existing SQLite database\n*/\nSQLITE_API int sqlite3_close(sqlite3 *db){\n  HashElem *i;                    /* Hash table iterator */\n  int j;\n\n  if( !db ){\n    return SQLITE_OK;\n  }\n  if( !sqlite3SafetyCheckSickOrOk(db) ){\n    return SQLITE_MISUSE_BKPT;\n  }\n  sqlite3_mutex_enter(db->mutex);\n\n  sqlite3ResetInternalSchema(db, 0);\n\n  /* If a transaction is open, the ResetInternalSchema() call above\n  ** will not have called the xDisconnect() method on any virtual\n  ** tables in the db->aVTrans[] array. The following sqlite3VtabRollback()\n  ** call will do so. We need to do this before the check for active\n  ** SQL statements below, as the v-table implementation may be storing\n  ** some prepared statements internally.\n  */\n  sqlite3VtabRollback(db);\n\n  /* If there are any outstanding VMs, return SQLITE_BUSY. */\n  if( db->pVdbe ){\n    sqlite3Error(db, SQLITE_BUSY, \n        \"unable to close due to unfinalised statements\");\n    sqlite3_mutex_leave(db->mutex);\n    return SQLITE_BUSY;\n  }\n  assert( sqlite3SafetyCheckSickOrOk(db) );\n\n  for(j=0; j<db->nDb; j++){\n    Btree *pBt = db->aDb[j].pBt;\n    if( pBt && sqlite3BtreeIsInBackup(pBt) ){\n      sqlite3Error(db, SQLITE_BUSY, \n          \"unable to close due to unfinished backup operation\");\n      sqlite3_mutex_leave(db->mutex);\n      return SQLITE_BUSY;\n    }\n  }\n\n  /* Free any outstanding Savepoint structures. */\n  sqlite3CloseSavepoints(db);\n\n  for(j=0; j<db->nDb; j++){\n    struct Db *pDb = &db->aDb[j];\n    if( pDb->pBt ){\n      sqlite3BtreeClose(pDb->pBt);\n      pDb->pBt = 0;\n      if( j!=1 ){\n        pDb->pSchema = 0;\n      }\n    }\n  }\n  sqlite3ResetInternalSchema(db, 0);\n\n  /* Tell the code in notify.c that the connection no longer holds any\n  ** locks and does not require any further unlock-notify callbacks.\n  */\n  sqlite3ConnectionClosed(db);\n\n  assert( db->nDb<=2 );\n  assert( db->aDb==db->aDbStatic );\n  for(j=0; j<ArraySize(db->aFunc.a); j++){\n    FuncDef *pNext, *pHash, *p;\n    for(p=db->aFunc.a[j]; p; p=pHash){\n      pHash = p->pHash;\n      while( p ){\n        functionDestroy(db, p);\n        pNext = p->pNext;\n        sqlite3DbFree(db, p);\n        p = pNext;\n      }\n    }\n  }\n  for(i=sqliteHashFirst(&db->aCollSeq); i; i=sqliteHashNext(i)){\n    CollSeq *pColl = (CollSeq *)sqliteHashData(i);\n    /* Invoke any destructors registered for collation sequence user data. */\n    for(j=0; j<3; j++){\n      if( pColl[j].xDel ){\n        pColl[j].xDel(pColl[j].pUser);\n      }\n    }\n    sqlite3DbFree(db, pColl);\n  }\n  sqlite3HashClear(&db->aCollSeq);\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  for(i=sqliteHashFirst(&db->aModule); i; i=sqliteHashNext(i)){\n    Module *pMod = (Module *)sqliteHashData(i);\n    if( pMod->xDestroy ){\n      pMod->xDestroy(pMod->pAux);\n    }\n    sqlite3DbFree(db, pMod);\n  }\n  sqlite3HashClear(&db->aModule);\n#endif\n\n  sqlite3Error(db, SQLITE_OK, 0); /* Deallocates any cached error strings. */\n  if( db->pErr ){\n    sqlite3ValueFree(db->pErr);\n  }\n  sqlite3CloseExtensions(db);\n\n  db->magic = SQLITE_MAGIC_ERROR;\n\n  /* The temp-database schema is allocated differently from the other schema\n  ** objects (using sqliteMalloc() directly, instead of sqlite3BtreeSchema()).\n  ** So it needs to be freed here. Todo: Why not roll the temp schema into\n  ** the same sqliteMalloc() as the one that allocates the database \n  ** structure?\n  */\n  sqlite3DbFree(db, db->aDb[1].pSchema);\n  sqlite3_mutex_leave(db->mutex);\n  db->magic = SQLITE_MAGIC_CLOSED;\n  sqlite3_mutex_free(db->mutex);\n  assert( db->lookaside.nOut==0 );  /* Fails on a lookaside memory leak */\n  if( db->lookaside.bMalloced ){\n    sqlite3_free(db->lookaside.pStart);\n  }\n  sqlite3_free(db);\n  return SQLITE_OK;\n}\n\n/*\n** Rollback all database files.\n*/\nSQLITE_PRIVATE void sqlite3RollbackAll(sqlite3 *db){\n  int i;\n  int inTrans = 0;\n  assert( sqlite3_mutex_held(db->mutex) );\n  sqlite3BeginBenignMalloc();\n  for(i=0; i<db->nDb; i++){\n    if( db->aDb[i].pBt ){\n      if( sqlite3BtreeIsInTrans(db->aDb[i].pBt) ){\n        inTrans = 1;\n      }\n      sqlite3BtreeRollback(db->aDb[i].pBt);\n      db->aDb[i].inTrans = 0;\n    }\n  }\n  sqlite3VtabRollback(db);\n  sqlite3EndBenignMalloc();\n\n  if( db->flags&SQLITE_InternChanges ){\n    sqlite3ExpirePreparedStatements(db);\n    sqlite3ResetInternalSchema(db, 0);\n  }\n\n  /* Any deferred constraint violations have now been resolved. */\n  db->nDeferredCons = 0;\n\n  /* If one has been configured, invoke the rollback-hook callback */\n  if( db->xRollbackCallback && (inTrans || !db->autoCommit) ){\n    db->xRollbackCallback(db->pRollbackArg);\n  }\n}\n\n/*\n** Return a static string that describes the kind of error specified in the\n** argument.\n*/\nSQLITE_PRIVATE const char *sqlite3ErrStr(int rc){\n  static const char* const aMsg[] = {\n    /* SQLITE_OK          */ \"not an error\",\n    /* SQLITE_ERROR       */ \"SQL logic error or missing database\",\n    /* SQLITE_INTERNAL    */ 0,\n    /* SQLITE_PERM        */ \"access permission denied\",\n    /* SQLITE_ABORT       */ \"callback requested query abort\",\n    /* SQLITE_BUSY        */ \"database is locked\",\n    /* SQLITE_LOCKED      */ \"database table is locked\",\n    /* SQLITE_NOMEM       */ \"out of memory\",\n    /* SQLITE_READONLY    */ \"attempt to write a readonly database\",\n    /* SQLITE_INTERRUPT   */ \"interrupted\",\n    /* SQLITE_IOERR       */ \"disk I/O error\",\n    /* SQLITE_CORRUPT     */ \"database disk image is malformed\",\n    /* SQLITE_NOTFOUND    */ \"unknown operation\",\n    /* SQLITE_FULL        */ \"database or disk is full\",\n    /* SQLITE_CANTOPEN    */ \"unable to open database file\",\n    /* SQLITE_PROTOCOL    */ \"locking protocol\",\n    /* SQLITE_EMPTY       */ \"table contains no data\",\n    /* SQLITE_SCHEMA      */ \"database schema has changed\",\n    /* SQLITE_TOOBIG      */ \"string or blob too big\",\n    /* SQLITE_CONSTRAINT  */ \"constraint failed\",\n    /* SQLITE_MISMATCH    */ \"datatype mismatch\",\n    /* SQLITE_MISUSE      */ \"library routine called out of sequence\",\n    /* SQLITE_NOLFS       */ \"large file support is disabled\",\n    /* SQLITE_AUTH        */ \"authorization denied\",\n    /* SQLITE_FORMAT      */ \"auxiliary database format error\",\n    /* SQLITE_RANGE       */ \"bind or column index out of range\",\n    /* SQLITE_NOTADB      */ \"file is encrypted or is not a database\",\n  };\n  rc &= 0xff;\n  if( ALWAYS(rc>=0) && rc<(int)(sizeof(aMsg)/sizeof(aMsg[0])) && aMsg[rc]!=0 ){\n    return aMsg[rc];\n  }else{\n    return \"unknown error\";\n  }\n}\n\n/*\n** This routine implements a busy callback that sleeps and tries\n** again until a timeout value is reached.  The timeout value is\n** an integer number of milliseconds passed in as the first\n** argument.\n*/\nstatic int sqliteDefaultBusyCallback(\n void *ptr,               /* Database connection */\n int count                /* Number of times table has been busy */\n){\n#if SQLITE_OS_WIN || (defined(HAVE_USLEEP) && HAVE_USLEEP)\n  static const u8 delays[] =\n     { 1, 2, 5, 10, 15, 20, 25, 25,  25,  50,  50, 100 };\n  static const u8 totals[] =\n     { 0, 1, 3,  8, 18, 33, 53, 78, 103, 128, 178, 228 };\n# define NDELAY (sizeof(delays)/sizeof(delays[0]))\n  sqlite3 *db = (sqlite3 *)ptr;\n  int timeout = db->busyTimeout;\n  int delay, prior;\n\n  assert( count>=0 );\n  if( count < NDELAY ){\n    delay = delays[count];\n    prior = totals[count];\n  }else{\n    delay = delays[NDELAY-1];\n    prior = totals[NDELAY-1] + delay*(count-(NDELAY-1));\n  }\n  if( prior + delay > timeout ){\n    delay = timeout - prior;\n    if( delay<=0 ) return 0;\n  }\n  sqlite3OsSleep(db->pVfs, delay*1000);\n  return 1;\n#else\n  sqlite3 *db = (sqlite3 *)ptr;\n  int timeout = ((sqlite3 *)ptr)->busyTimeout;\n  if( (count+1)*1000 > timeout ){\n    return 0;\n  }\n  sqlite3OsSleep(db->pVfs, 1000000);\n  return 1;\n#endif\n}\n\n/*\n** Invoke the given busy handler.\n**\n** This routine is called when an operation failed with a lock.\n** If this routine returns non-zero, the lock is retried.  If it\n** returns 0, the operation aborts with an SQLITE_BUSY error.\n*/\nSQLITE_PRIVATE int sqlite3InvokeBusyHandler(BusyHandler *p){\n  int rc;\n  if( NEVER(p==0) || p->xFunc==0 || p->nBusy<0 ) return 0;\n  rc = p->xFunc(p->pArg, p->nBusy);\n  if( rc==0 ){\n    p->nBusy = -1;\n  }else{\n    p->nBusy++;\n  }\n  return rc; \n}\n\n/*\n** This routine sets the busy callback for an Sqlite database to the\n** given callback function with the given argument.\n*/\nSQLITE_API int sqlite3_busy_handler(\n  sqlite3 *db,\n  int (*xBusy)(void*,int),\n  void *pArg\n){\n  sqlite3_mutex_enter(db->mutex);\n  db->busyHandler.xFunc = xBusy;\n  db->busyHandler.pArg = pArg;\n  db->busyHandler.nBusy = 0;\n  sqlite3_mutex_leave(db->mutex);\n  return SQLITE_OK;\n}\n\n#ifndef SQLITE_OMIT_PROGRESS_CALLBACK\n/*\n** This routine sets the progress callback for an Sqlite database to the\n** given callback function with the given argument. The progress callback will\n** be invoked every nOps opcodes.\n*/\nSQLITE_API void sqlite3_progress_handler(\n  sqlite3 *db, \n  int nOps,\n  int (*xProgress)(void*), \n  void *pArg\n){\n  sqlite3_mutex_enter(db->mutex);\n  if( nOps>0 ){\n    db->xProgress = xProgress;\n    db->nProgressOps = nOps;\n    db->pProgressArg = pArg;\n  }else{\n    db->xProgress = 0;\n    db->nProgressOps = 0;\n    db->pProgressArg = 0;\n  }\n  sqlite3_mutex_leave(db->mutex);\n}\n#endif\n\n\n/*\n** This routine installs a default busy handler that waits for the\n** specified number of milliseconds before returning 0.\n*/\nSQLITE_API int sqlite3_busy_timeout(sqlite3 *db, int ms){\n  if( ms>0 ){\n    db->busyTimeout = ms;\n    sqlite3_busy_handler(db, sqliteDefaultBusyCallback, (void*)db);\n  }else{\n    sqlite3_busy_handler(db, 0, 0);\n  }\n  return SQLITE_OK;\n}\n\n/*\n** Cause any pending operation to stop at its earliest opportunity.\n*/\nSQLITE_API void sqlite3_interrupt(sqlite3 *db){\n  db->u1.isInterrupted = 1;\n}\n\n\n/*\n** This function is exactly the same as sqlite3_create_function(), except\n** that it is designed to be called by internal code. The difference is\n** that if a malloc() fails in sqlite3_create_function(), an error code\n** is returned and the mallocFailed flag cleared. \n*/\nSQLITE_PRIVATE int sqlite3CreateFunc(\n  sqlite3 *db,\n  const char *zFunctionName,\n  int nArg,\n  int enc,\n  void *pUserData,\n  void (*xFunc)(sqlite3_context*,int,sqlite3_value **),\n  void (*xStep)(sqlite3_context*,int,sqlite3_value **),\n  void (*xFinal)(sqlite3_context*),\n  FuncDestructor *pDestructor\n){\n  FuncDef *p;\n  int nName;\n\n  assert( sqlite3_mutex_held(db->mutex) );\n  if( zFunctionName==0 ||\n      (xFunc && (xFinal || xStep)) || \n      (!xFunc && (xFinal && !xStep)) ||\n      (!xFunc && (!xFinal && xStep)) ||\n      (nArg<-1 || nArg>SQLITE_MAX_FUNCTION_ARG) ||\n      (255<(nName = sqlite3Strlen30( zFunctionName))) ){\n    return SQLITE_MISUSE_BKPT;\n  }\n  \n#ifndef SQLITE_OMIT_UTF16\n  /* If SQLITE_UTF16 is specified as the encoding type, transform this\n  ** to one of SQLITE_UTF16LE or SQLITE_UTF16BE using the\n  ** SQLITE_UTF16NATIVE macro. SQLITE_UTF16 is not used internally.\n  **\n  ** If SQLITE_ANY is specified, add three versions of the function\n  ** to the hash table.\n  */\n  if( enc==SQLITE_UTF16 ){\n    enc = SQLITE_UTF16NATIVE;\n  }else if( enc==SQLITE_ANY ){\n    int rc;\n    rc = sqlite3CreateFunc(db, zFunctionName, nArg, SQLITE_UTF8,\n         pUserData, xFunc, xStep, xFinal, pDestructor);\n    if( rc==SQLITE_OK ){\n      rc = sqlite3CreateFunc(db, zFunctionName, nArg, SQLITE_UTF16LE,\n          pUserData, xFunc, xStep, xFinal, pDestructor);\n    }\n    if( rc!=SQLITE_OK ){\n      return rc;\n    }\n    enc = SQLITE_UTF16BE;\n  }\n#else\n  enc = SQLITE_UTF8;\n#endif\n  \n  /* Check if an existing function is being overridden or deleted. If so,\n  ** and there are active VMs, then return SQLITE_BUSY. If a function\n  ** is being overridden/deleted but there are no active VMs, allow the\n  ** operation to continue but invalidate all precompiled statements.\n  */\n  p = sqlite3FindFunction(db, zFunctionName, nName, nArg, (u8)enc, 0);\n  if( p && p->iPrefEnc==enc && p->nArg==nArg ){\n    if( db->activeVdbeCnt ){\n      sqlite3Error(db, SQLITE_BUSY, \n        \"unable to delete/modify user-function due to active statements\");\n      assert( !db->mallocFailed );\n      return SQLITE_BUSY;\n    }else{\n      sqlite3ExpirePreparedStatements(db);\n    }\n  }\n\n  p = sqlite3FindFunction(db, zFunctionName, nName, nArg, (u8)enc, 1);\n  assert(p || db->mallocFailed);\n  if( !p ){\n    return SQLITE_NOMEM;\n  }\n\n  /* If an older version of the function with a configured destructor is\n  ** being replaced invoke the destructor function here. */\n  functionDestroy(db, p);\n\n  if( pDestructor ){\n    pDestructor->nRef++;\n  }\n  p->pDestructor = pDestructor;\n  p->flags = 0;\n  p->xFunc = xFunc;\n  p->xStep = xStep;\n  p->xFinalize = xFinal;\n  p->pUserData = pUserData;\n  p->nArg = (u16)nArg;\n  return SQLITE_OK;\n}\n\n/*\n** Create new user functions.\n*/\nSQLITE_API int sqlite3_create_function(\n  sqlite3 *db,\n  const char *zFunc,\n  int nArg,\n  int enc,\n  void *p,\n  void (*xFunc)(sqlite3_context*,int,sqlite3_value **),\n  void (*xStep)(sqlite3_context*,int,sqlite3_value **),\n  void (*xFinal)(sqlite3_context*)\n){\n  return sqlite3_create_function_v2(db, zFunc, nArg, enc, p, xFunc, xStep,\n                                    xFinal, 0);\n}\n\nSQLITE_API int sqlite3_create_function_v2(\n  sqlite3 *db,\n  const char *zFunc,\n  int nArg,\n  int enc,\n  void *p,\n  void (*xFunc)(sqlite3_context*,int,sqlite3_value **),\n  void (*xStep)(sqlite3_context*,int,sqlite3_value **),\n  void (*xFinal)(sqlite3_context*),\n  void (*xDestroy)(void *)\n){\n  int rc = SQLITE_ERROR;\n  FuncDestructor *pArg = 0;\n  sqlite3_mutex_enter(db->mutex);\n  if( xDestroy ){\n    pArg = (FuncDestructor *)sqlite3DbMallocZero(db, sizeof(FuncDestructor));\n    if( !pArg ){\n      xDestroy(p);\n      goto out;\n    }\n    pArg->xDestroy = xDestroy;\n    pArg->pUserData = p;\n  }\n  rc = sqlite3CreateFunc(db, zFunc, nArg, enc, p, xFunc, xStep, xFinal, pArg);\n  if( pArg && pArg->nRef==0 ){\n    assert( rc!=SQLITE_OK );\n    xDestroy(p);\n    sqlite3DbFree(db, pArg);\n  }\n\n out:\n  rc = sqlite3ApiExit(db, rc);\n  sqlite3_mutex_leave(db->mutex);\n  return rc;\n}\n\n#ifndef SQLITE_OMIT_UTF16\nSQLITE_API int sqlite3_create_function16(\n  sqlite3 *db,\n  const void *zFunctionName,\n  int nArg,\n  int eTextRep,\n  void *p,\n  void (*xFunc)(sqlite3_context*,int,sqlite3_value**),\n  void (*xStep)(sqlite3_context*,int,sqlite3_value**),\n  void (*xFinal)(sqlite3_context*)\n){\n  int rc;\n  char *zFunc8;\n  sqlite3_mutex_enter(db->mutex);\n  assert( !db->mallocFailed );\n  zFunc8 = sqlite3Utf16to8(db, zFunctionName, -1, SQLITE_UTF16NATIVE);\n  rc = sqlite3CreateFunc(db, zFunc8, nArg, eTextRep, p, xFunc, xStep, xFinal,0);\n  sqlite3DbFree(db, zFunc8);\n  rc = sqlite3ApiExit(db, rc);\n  sqlite3_mutex_leave(db->mutex);\n  return rc;\n}\n#endif\n\n\n/*\n** Declare that a function has been overloaded by a virtual table.\n**\n** If the function already exists as a regular global function, then\n** this routine is a no-op.  If the function does not exist, then create\n** a new one that always throws a run-time error.  \n**\n** When virtual tables intend to provide an overloaded function, they\n** should call this routine to make sure the global function exists.\n** A global function must exist in order for name resolution to work\n** properly.\n*/\nSQLITE_API int sqlite3_overload_function(\n  sqlite3 *db,\n  const char *zName,\n  int nArg\n){\n  int nName = sqlite3Strlen30(zName);\n  int rc;\n  sqlite3_mutex_enter(db->mutex);\n  if( sqlite3FindFunction(db, zName, nName, nArg, SQLITE_UTF8, 0)==0 ){\n    sqlite3CreateFunc(db, zName, nArg, SQLITE_UTF8,\n                      0, sqlite3InvalidFunction, 0, 0, 0);\n  }\n  rc = sqlite3ApiExit(db, SQLITE_OK);\n  sqlite3_mutex_leave(db->mutex);\n  return rc;\n}\n\n#ifndef SQLITE_OMIT_TRACE\n/*\n** Register a trace function.  The pArg from the previously registered trace\n** is returned.  \n**\n** A NULL trace function means that no tracing is executes.  A non-NULL\n** trace is a pointer to a function that is invoked at the start of each\n** SQL statement.\n*/\nSQLITE_API void *sqlite3_trace(sqlite3 *db, void (*xTrace)(void*,const char*), void *pArg){\n  void *pOld;\n  sqlite3_mutex_enter(db->mutex);\n  pOld = db->pTraceArg;\n  db->xTrace = xTrace;\n  db->pTraceArg = pArg;\n  sqlite3_mutex_leave(db->mutex);\n  return pOld;\n}\n/*\n** Register a profile function.  The pArg from the previously registered \n** profile function is returned.  \n**\n** A NULL profile function means that no profiling is executes.  A non-NULL\n** profile is a pointer to a function that is invoked at the conclusion of\n** each SQL statement that is run.\n*/\nSQLITE_API void *sqlite3_profile(\n  sqlite3 *db,\n  void (*xProfile)(void*,const char*,sqlite_uint64),\n  void *pArg\n){\n  void *pOld;\n  sqlite3_mutex_enter(db->mutex);\n  pOld = db->pProfileArg;\n  db->xProfile = xProfile;\n  db->pProfileArg = pArg;\n  sqlite3_mutex_leave(db->mutex);\n  return pOld;\n}\n#endif /* SQLITE_OMIT_TRACE */\n\n/*** EXPERIMENTAL ***\n**\n** Register a function to be invoked when a transaction comments.\n** If the invoked function returns non-zero, then the commit becomes a\n** rollback.\n*/\nSQLITE_API void *sqlite3_commit_hook(\n  sqlite3 *db,              /* Attach the hook to this database */\n  int (*xCallback)(void*),  /* Function to invoke on each commit */\n  void *pArg                /* Argument to the function */\n){\n  void *pOld;\n  sqlite3_mutex_enter(db->mutex);\n  pOld = db->pCommitArg;\n  db->xCommitCallback = xCallback;\n  db->pCommitArg = pArg;\n  sqlite3_mutex_leave(db->mutex);\n  return pOld;\n}\n\n/*\n** Register a callback to be invoked each time a row is updated,\n** inserted or deleted using this database connection.\n*/\nSQLITE_API void *sqlite3_update_hook(\n  sqlite3 *db,              /* Attach the hook to this database */\n  void (*xCallback)(void*,int,char const *,char const *,sqlite_int64),\n  void *pArg                /* Argument to the function */\n){\n  void *pRet;\n  sqlite3_mutex_enter(db->mutex);\n  pRet = db->pUpdateArg;\n  db->xUpdateCallback = xCallback;\n  db->pUpdateArg = pArg;\n  sqlite3_mutex_leave(db->mutex);\n  return pRet;\n}\n\n/*\n** Register a callback to be invoked each time a transaction is rolled\n** back by this database connection.\n*/\nSQLITE_API void *sqlite3_rollback_hook(\n  sqlite3 *db,              /* Attach the hook to this database */\n  void (*xCallback)(void*), /* Callback function */\n  void *pArg                /* Argument to the function */\n){\n  void *pRet;\n  sqlite3_mutex_enter(db->mutex);\n  pRet = db->pRollbackArg;\n  db->xRollbackCallback = xCallback;\n  db->pRollbackArg = pArg;\n  sqlite3_mutex_leave(db->mutex);\n  return pRet;\n}\n\n#ifndef SQLITE_OMIT_WAL\n/*\n** The sqlite3_wal_hook() callback registered by sqlite3_wal_autocheckpoint().\n** Invoke sqlite3_wal_checkpoint if the number of frames in the log file\n** is greater than sqlite3.pWalArg cast to an integer (the value configured by\n** wal_autocheckpoint()).\n*/ \nSQLITE_PRIVATE int sqlite3WalDefaultHook(\n  void *pClientData,     /* Argument */\n  sqlite3 *db,           /* Connection */\n  const char *zDb,       /* Database */\n  int nFrame             /* Size of WAL */\n){\n  if( nFrame>=SQLITE_PTR_TO_INT(pClientData) ){\n    sqlite3BeginBenignMalloc();\n    sqlite3_wal_checkpoint(db, zDb);\n    sqlite3EndBenignMalloc();\n  }\n  return SQLITE_OK;\n}\n#endif /* SQLITE_OMIT_WAL */\n\n/*\n** Configure an sqlite3_wal_hook() callback to automatically checkpoint\n** a database after committing a transaction if there are nFrame or\n** more frames in the log file. Passing zero or a negative value as the\n** nFrame parameter disables automatic checkpoints entirely.\n**\n** The callback registered by this function replaces any existing callback\n** registered using sqlite3_wal_hook(). Likewise, registering a callback\n** using sqlite3_wal_hook() disables the automatic checkpoint mechanism\n** configured by this function.\n*/\nSQLITE_API int sqlite3_wal_autocheckpoint(sqlite3 *db, int nFrame){\n#ifdef SQLITE_OMIT_WAL\n  UNUSED_PARAMETER(db);\n  UNUSED_PARAMETER(nFrame);\n#else\n  if( nFrame>0 ){\n    sqlite3_wal_hook(db, sqlite3WalDefaultHook, SQLITE_INT_TO_PTR(nFrame));\n  }else{\n    sqlite3_wal_hook(db, 0, 0);\n  }\n#endif\n  return SQLITE_OK;\n}\n\n/*\n** Register a callback to be invoked each time a transaction is written\n** into the write-ahead-log by this database connection.\n*/\nSQLITE_API void *sqlite3_wal_hook(\n  sqlite3 *db,                    /* Attach the hook to this db handle */\n  int(*xCallback)(void *, sqlite3*, const char*, int),\n  void *pArg                      /* First argument passed to xCallback() */\n){\n#ifndef SQLITE_OMIT_WAL\n  void *pRet;\n  sqlite3_mutex_enter(db->mutex);\n  pRet = db->pWalArg;\n  db->xWalCallback = xCallback;\n  db->pWalArg = pArg;\n  sqlite3_mutex_leave(db->mutex);\n  return pRet;\n#else\n  return 0;\n#endif\n}\n\n/*\n** Checkpoint database zDb.\n*/\nSQLITE_API int sqlite3_wal_checkpoint_v2(\n  sqlite3 *db,                    /* Database handle */\n  const char *zDb,                /* Name of attached database (or NULL) */\n  int eMode,                      /* SQLITE_CHECKPOINT_* value */\n  int *pnLog,                     /* OUT: Size of WAL log in frames */\n  int *pnCkpt                     /* OUT: Total number of frames checkpointed */\n){\n#ifdef SQLITE_OMIT_WAL\n  return SQLITE_OK;\n#else\n  int rc;                         /* Return code */\n  int iDb = SQLITE_MAX_ATTACHED;  /* sqlite3.aDb[] index of db to checkpoint */\n\n  /* Initialize the output variables to -1 in case an error occurs. */\n  if( pnLog ) *pnLog = -1;\n  if( pnCkpt ) *pnCkpt = -1;\n\n  assert( SQLITE_CHECKPOINT_FULL>SQLITE_CHECKPOINT_PASSIVE );\n  assert( SQLITE_CHECKPOINT_FULL<SQLITE_CHECKPOINT_RESTART );\n  assert( SQLITE_CHECKPOINT_PASSIVE+2==SQLITE_CHECKPOINT_RESTART );\n  if( eMode<SQLITE_CHECKPOINT_PASSIVE || eMode>SQLITE_CHECKPOINT_RESTART ){\n    return SQLITE_MISUSE;\n  }\n\n  sqlite3_mutex_enter(db->mutex);\n  if( zDb && zDb[0] ){\n    iDb = sqlite3FindDbName(db, zDb);\n  }\n  if( iDb<0 ){\n    rc = SQLITE_ERROR;\n    sqlite3Error(db, SQLITE_ERROR, \"unknown database: %s\", zDb);\n  }else{\n    rc = sqlite3Checkpoint(db, iDb, eMode, pnLog, pnCkpt);\n    sqlite3Error(db, rc, 0);\n  }\n  rc = sqlite3ApiExit(db, rc);\n  sqlite3_mutex_leave(db->mutex);\n  return rc;\n#endif\n}\n\n\n/*\n** Checkpoint database zDb. If zDb is NULL, or if the buffer zDb points\n** to contains a zero-length string, all attached databases are \n** checkpointed.\n*/\nSQLITE_API int sqlite3_wal_checkpoint(sqlite3 *db, const char *zDb){\n  return sqlite3_wal_checkpoint_v2(db, zDb, SQLITE_CHECKPOINT_PASSIVE, 0, 0);\n}\n\n#ifndef SQLITE_OMIT_WAL\n/*\n** Run a checkpoint on database iDb. This is a no-op if database iDb is\n** not currently open in WAL mode.\n**\n** If a transaction is open on the database being checkpointed, this \n** function returns SQLITE_LOCKED and a checkpoint is not attempted. If \n** an error occurs while running the checkpoint, an SQLite error code is \n** returned (i.e. SQLITE_IOERR). Otherwise, SQLITE_OK.\n**\n** The mutex on database handle db should be held by the caller. The mutex\n** associated with the specific b-tree being checkpointed is taken by\n** this function while the checkpoint is running.\n**\n** If iDb is passed SQLITE_MAX_ATTACHED, then all attached databases are\n** checkpointed. If an error is encountered it is returned immediately -\n** no attempt is made to checkpoint any remaining databases.\n**\n** Parameter eMode is one of SQLITE_CHECKPOINT_PASSIVE, FULL or RESTART.\n*/\nSQLITE_PRIVATE int sqlite3Checkpoint(sqlite3 *db, int iDb, int eMode, int *pnLog, int *pnCkpt){\n  int rc = SQLITE_OK;             /* Return code */\n  int i;                          /* Used to iterate through attached dbs */\n  int bBusy = 0;                  /* True if SQLITE_BUSY has been encountered */\n\n  assert( sqlite3_mutex_held(db->mutex) );\n  assert( !pnLog || *pnLog==-1 );\n  assert( !pnCkpt || *pnCkpt==-1 );\n\n  for(i=0; i<db->nDb && rc==SQLITE_OK; i++){\n    if( i==iDb || iDb==SQLITE_MAX_ATTACHED ){\n      rc = sqlite3BtreeCheckpoint(db->aDb[i].pBt, eMode, pnLog, pnCkpt);\n      pnLog = 0;\n      pnCkpt = 0;\n      if( rc==SQLITE_BUSY ){\n        bBusy = 1;\n        rc = SQLITE_OK;\n      }\n    }\n  }\n\n  return (rc==SQLITE_OK && bBusy) ? SQLITE_BUSY : rc;\n}\n#endif /* SQLITE_OMIT_WAL */\n\n/*\n** This function returns true if main-memory should be used instead of\n** a temporary file for transient pager files and statement journals.\n** The value returned depends on the value of db->temp_store (runtime\n** parameter) and the compile time value of SQLITE_TEMP_STORE. The\n** following table describes the relationship between these two values\n** and this functions return value.\n**\n**   SQLITE_TEMP_STORE     db->temp_store     Location of temporary database\n**   -----------------     --------------     ------------------------------\n**   0                     any                file      (return 0)\n**   1                     1                  file      (return 0)\n**   1                     2                  memory    (return 1)\n**   1                     0                  file      (return 0)\n**   2                     1                  file      (return 0)\n**   2                     2                  memory    (return 1)\n**   2                     0                  memory    (return 1)\n**   3                     any                memory    (return 1)\n*/\nSQLITE_PRIVATE int sqlite3TempInMemory(const sqlite3 *db){\n#if SQLITE_TEMP_STORE==1\n  return ( db->temp_store==2 );\n#endif\n#if SQLITE_TEMP_STORE==2\n  return ( db->temp_store!=1 );\n#endif\n#if SQLITE_TEMP_STORE==3\n  return 1;\n#endif\n#if SQLITE_TEMP_STORE<1 || SQLITE_TEMP_STORE>3\n  return 0;\n#endif\n}\n\n/*\n** Return UTF-8 encoded English language explanation of the most recent\n** error.\n*/\nSQLITE_API const char *sqlite3_errmsg(sqlite3 *db){\n  const char *z;\n  if( !db ){\n    return sqlite3ErrStr(SQLITE_NOMEM);\n  }\n  if( !sqlite3SafetyCheckSickOrOk(db) ){\n    return sqlite3ErrStr(SQLITE_MISUSE_BKPT);\n  }\n  sqlite3_mutex_enter(db->mutex);\n  if( db->mallocFailed ){\n    z = sqlite3ErrStr(SQLITE_NOMEM);\n  }else{\n    z = (char*)sqlite3_value_text(db->pErr);\n    assert( !db->mallocFailed );\n    if( z==0 ){\n      z = sqlite3ErrStr(db->errCode);\n    }\n  }\n  sqlite3_mutex_leave(db->mutex);\n  return z;\n}\n\n#ifndef SQLITE_OMIT_UTF16\n/*\n** Return UTF-16 encoded English language explanation of the most recent\n** error.\n*/\nSQLITE_API const void *sqlite3_errmsg16(sqlite3 *db){\n  static const u16 outOfMem[] = {\n    'o', 'u', 't', ' ', 'o', 'f', ' ', 'm', 'e', 'm', 'o', 'r', 'y', 0\n  };\n  static const u16 misuse[] = {\n    'l', 'i', 'b', 'r', 'a', 'r', 'y', ' ', \n    'r', 'o', 'u', 't', 'i', 'n', 'e', ' ', \n    'c', 'a', 'l', 'l', 'e', 'd', ' ', \n    'o', 'u', 't', ' ', \n    'o', 'f', ' ', \n    's', 'e', 'q', 'u', 'e', 'n', 'c', 'e', 0\n  };\n\n  const void *z;\n  if( !db ){\n    return (void *)outOfMem;\n  }\n  if( !sqlite3SafetyCheckSickOrOk(db) ){\n    return (void *)misuse;\n  }\n  sqlite3_mutex_enter(db->mutex);\n  if( db->mallocFailed ){\n    z = (void *)outOfMem;\n  }else{\n    z = sqlite3_value_text16(db->pErr);\n    if( z==0 ){\n      sqlite3ValueSetStr(db->pErr, -1, sqlite3ErrStr(db->errCode),\n           SQLITE_UTF8, SQLITE_STATIC);\n      z = sqlite3_value_text16(db->pErr);\n    }\n    /* A malloc() may have failed within the call to sqlite3_value_text16()\n    ** above. If this is the case, then the db->mallocFailed flag needs to\n    ** be cleared before returning. Do this directly, instead of via\n    ** sqlite3ApiExit(), to avoid setting the database handle error message.\n    */\n    db->mallocFailed = 0;\n  }\n  sqlite3_mutex_leave(db->mutex);\n  return z;\n}\n#endif /* SQLITE_OMIT_UTF16 */\n\n/*\n** Return the most recent error code generated by an SQLite routine. If NULL is\n** passed to this function, we assume a malloc() failed during sqlite3_open().\n*/\nSQLITE_API int sqlite3_errcode(sqlite3 *db){\n  if( db && !sqlite3SafetyCheckSickOrOk(db) ){\n    return SQLITE_MISUSE_BKPT;\n  }\n  if( !db || db->mallocFailed ){\n    return SQLITE_NOMEM;\n  }\n  return db->errCode & db->errMask;\n}\nSQLITE_API int sqlite3_extended_errcode(sqlite3 *db){\n  if( db && !sqlite3SafetyCheckSickOrOk(db) ){\n    return SQLITE_MISUSE_BKPT;\n  }\n  if( !db || db->mallocFailed ){\n    return SQLITE_NOMEM;\n  }\n  return db->errCode;\n}\n\n/*\n** Create a new collating function for database \"db\".  The name is zName\n** and the encoding is enc.\n*/\nstatic int createCollation(\n  sqlite3* db,\n  const char *zName, \n  u8 enc,\n  u8 collType,\n  void* pCtx,\n  int(*xCompare)(void*,int,const void*,int,const void*),\n  void(*xDel)(void*)\n){\n  CollSeq *pColl;\n  int enc2;\n  int nName = sqlite3Strlen30(zName);\n  \n  assert( sqlite3_mutex_held(db->mutex) );\n\n  /* If SQLITE_UTF16 is specified as the encoding type, transform this\n  ** to one of SQLITE_UTF16LE or SQLITE_UTF16BE using the\n  ** SQLITE_UTF16NATIVE macro. SQLITE_UTF16 is not used internally.\n  */\n  enc2 = enc;\n  testcase( enc2==SQLITE_UTF16 );\n  testcase( enc2==SQLITE_UTF16_ALIGNED );\n  if( enc2==SQLITE_UTF16 || enc2==SQLITE_UTF16_ALIGNED ){\n    enc2 = SQLITE_UTF16NATIVE;\n  }\n  if( enc2<SQLITE_UTF8 || enc2>SQLITE_UTF16BE ){\n    return SQLITE_MISUSE_BKPT;\n  }\n\n  /* Check if this call is removing or replacing an existing collation \n  ** sequence. If so, and there are active VMs, return busy. If there\n  ** are no active VMs, invalidate any pre-compiled statements.\n  */\n  pColl = sqlite3FindCollSeq(db, (u8)enc2, zName, 0);\n  if( pColl && pColl->xCmp ){\n    if( db->activeVdbeCnt ){\n      sqlite3Error(db, SQLITE_BUSY, \n        \"unable to delete/modify collation sequence due to active statements\");\n      return SQLITE_BUSY;\n    }\n    sqlite3ExpirePreparedStatements(db);\n\n    /* If collation sequence pColl was created directly by a call to\n    ** sqlite3_create_collation, and not generated by synthCollSeq(),\n    ** then any copies made by synthCollSeq() need to be invalidated.\n    ** Also, collation destructor - CollSeq.xDel() - function may need\n    ** to be called.\n    */ \n    if( (pColl->enc & ~SQLITE_UTF16_ALIGNED)==enc2 ){\n      CollSeq *aColl = sqlite3HashFind(&db->aCollSeq, zName, nName);\n      int j;\n      for(j=0; j<3; j++){\n        CollSeq *p = &aColl[j];\n        if( p->enc==pColl->enc ){\n          if( p->xDel ){\n            p->xDel(p->pUser);\n          }\n          p->xCmp = 0;\n        }\n      }\n    }\n  }\n\n  pColl = sqlite3FindCollSeq(db, (u8)enc2, zName, 1);\n  if( pColl==0 ) return SQLITE_NOMEM;\n  pColl->xCmp = xCompare;\n  pColl->pUser = pCtx;\n  pColl->xDel = xDel;\n  pColl->enc = (u8)(enc2 | (enc & SQLITE_UTF16_ALIGNED));\n  pColl->type = collType;\n  sqlite3Error(db, SQLITE_OK, 0);\n  return SQLITE_OK;\n}\n\n\n/*\n** This array defines hard upper bounds on limit values.  The\n** initializer must be kept in sync with the SQLITE_LIMIT_*\n** #defines in sqlite3.h.\n*/\nstatic const int aHardLimit[] = {\n  SQLITE_MAX_LENGTH,\n  SQLITE_MAX_SQL_LENGTH,\n  SQLITE_MAX_COLUMN,\n  SQLITE_MAX_EXPR_DEPTH,\n  SQLITE_MAX_COMPOUND_SELECT,\n  SQLITE_MAX_VDBE_OP,\n  SQLITE_MAX_FUNCTION_ARG,\n  SQLITE_MAX_ATTACHED,\n  SQLITE_MAX_LIKE_PATTERN_LENGTH,\n  SQLITE_MAX_VARIABLE_NUMBER,\n  SQLITE_MAX_TRIGGER_DEPTH,\n};\n\n/*\n** Make sure the hard limits are set to reasonable values\n*/\n#if SQLITE_MAX_LENGTH<100\n# error SQLITE_MAX_LENGTH must be at least 100\n#endif\n#if SQLITE_MAX_SQL_LENGTH<100\n# error SQLITE_MAX_SQL_LENGTH must be at least 100\n#endif\n#if SQLITE_MAX_SQL_LENGTH>SQLITE_MAX_LENGTH\n# error SQLITE_MAX_SQL_LENGTH must not be greater than SQLITE_MAX_LENGTH\n#endif\n#if SQLITE_MAX_COMPOUND_SELECT<2\n# error SQLITE_MAX_COMPOUND_SELECT must be at least 2\n#endif\n#if SQLITE_MAX_VDBE_OP<40\n# error SQLITE_MAX_VDBE_OP must be at least 40\n#endif\n#if SQLITE_MAX_FUNCTION_ARG<0 || SQLITE_MAX_FUNCTION_ARG>1000\n# error SQLITE_MAX_FUNCTION_ARG must be between 0 and 1000\n#endif\n#if SQLITE_MAX_ATTACHED<0 || SQLITE_MAX_ATTACHED>30\n# error SQLITE_MAX_ATTACHED must be between 0 and 30\n#endif\n#if SQLITE_MAX_LIKE_PATTERN_LENGTH<1\n# error SQLITE_MAX_LIKE_PATTERN_LENGTH must be at least 1\n#endif\n#if SQLITE_MAX_COLUMN>32767\n# error SQLITE_MAX_COLUMN must not exceed 32767\n#endif\n#if SQLITE_MAX_TRIGGER_DEPTH<1\n# error SQLITE_MAX_TRIGGER_DEPTH must be at least 1\n#endif\n\n\n/*\n** Change the value of a limit.  Report the old value.\n** If an invalid limit index is supplied, report -1.\n** Make no changes but still report the old value if the\n** new limit is negative.\n**\n** A new lower limit does not shrink existing constructs.\n** It merely prevents new constructs that exceed the limit\n** from forming.\n*/\nSQLITE_API int sqlite3_limit(sqlite3 *db, int limitId, int newLimit){\n  int oldLimit;\n\n\n  /* EVIDENCE-OF: R-30189-54097 For each limit category SQLITE_LIMIT_NAME\n  ** there is a hard upper bound set at compile-time by a C preprocessor\n  ** macro called SQLITE_MAX_NAME. (The \"_LIMIT_\" in the name is changed to\n  ** \"_MAX_\".)\n  */\n  assert( aHardLimit[SQLITE_LIMIT_LENGTH]==SQLITE_MAX_LENGTH );\n  assert( aHardLimit[SQLITE_LIMIT_SQL_LENGTH]==SQLITE_MAX_SQL_LENGTH );\n  assert( aHardLimit[SQLITE_LIMIT_COLUMN]==SQLITE_MAX_COLUMN );\n  assert( aHardLimit[SQLITE_LIMIT_EXPR_DEPTH]==SQLITE_MAX_EXPR_DEPTH );\n  assert( aHardLimit[SQLITE_LIMIT_COMPOUND_SELECT]==SQLITE_MAX_COMPOUND_SELECT);\n  assert( aHardLimit[SQLITE_LIMIT_VDBE_OP]==SQLITE_MAX_VDBE_OP );\n  assert( aHardLimit[SQLITE_LIMIT_FUNCTION_ARG]==SQLITE_MAX_FUNCTION_ARG );\n  assert( aHardLimit[SQLITE_LIMIT_ATTACHED]==SQLITE_MAX_ATTACHED );\n  assert( aHardLimit[SQLITE_LIMIT_LIKE_PATTERN_LENGTH]==\n                                               SQLITE_MAX_LIKE_PATTERN_LENGTH );\n  assert( aHardLimit[SQLITE_LIMIT_VARIABLE_NUMBER]==SQLITE_MAX_VARIABLE_NUMBER);\n  assert( aHardLimit[SQLITE_LIMIT_TRIGGER_DEPTH]==SQLITE_MAX_TRIGGER_DEPTH );\n  assert( SQLITE_LIMIT_TRIGGER_DEPTH==(SQLITE_N_LIMIT-1) );\n\n\n  if( limitId<0 || limitId>=SQLITE_N_LIMIT ){\n    return -1;\n  }\n  oldLimit = db->aLimit[limitId];\n  if( newLimit>=0 ){                   /* IMP: R-52476-28732 */\n    if( newLimit>aHardLimit[limitId] ){\n      newLimit = aHardLimit[limitId];  /* IMP: R-51463-25634 */\n    }\n    db->aLimit[limitId] = newLimit;\n  }\n  return oldLimit;                     /* IMP: R-53341-35419 */\n}\n\n/*\n** This routine does the work of opening a database on behalf of\n** sqlite3_open() and sqlite3_open16(). The database filename \"zFilename\"  \n** is UTF-8 encoded.\n*/\nstatic int openDatabase(\n  const char *zFilename, /* Database filename UTF-8 encoded */\n  sqlite3 **ppDb,        /* OUT: Returned database handle */\n  unsigned flags,        /* Operational flags */\n  const char *zVfs       /* Name of the VFS to use */\n){\n  sqlite3 *db;\n  int rc;\n  int isThreadsafe;\n\n  *ppDb = 0;\n#ifndef SQLITE_OMIT_AUTOINIT\n  rc = sqlite3_initialize();\n  if( rc ) return rc;\n#endif\n\n  /* Only allow sensible combinations of bits in the flags argument.  \n  ** Throw an error if any non-sense combination is used.  If we\n  ** do not block illegal combinations here, it could trigger\n  ** assert() statements in deeper layers.  Sensible combinations\n  ** are:\n  **\n  **  1:  SQLITE_OPEN_READONLY\n  **  2:  SQLITE_OPEN_READWRITE\n  **  6:  SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE\n  */\n  assert( SQLITE_OPEN_READONLY  == 0x01 );\n  assert( SQLITE_OPEN_READWRITE == 0x02 );\n  assert( SQLITE_OPEN_CREATE    == 0x04 );\n  testcase( (1<<(flags&7))==0x02 ); /* READONLY */\n  testcase( (1<<(flags&7))==0x04 ); /* READWRITE */\n  testcase( (1<<(flags&7))==0x40 ); /* READWRITE | CREATE */\n  if( ((1<<(flags&7)) & 0x46)==0 ) return SQLITE_MISUSE;\n\n  if( sqlite3GlobalConfig.bCoreMutex==0 ){\n    isThreadsafe = 0;\n  }else if( flags & SQLITE_OPEN_NOMUTEX ){\n    isThreadsafe = 0;\n  }else if( flags & SQLITE_OPEN_FULLMUTEX ){\n    isThreadsafe = 1;\n  }else{\n    isThreadsafe = sqlite3GlobalConfig.bFullMutex;\n  }\n  if( flags & SQLITE_OPEN_PRIVATECACHE ){\n    flags &= ~SQLITE_OPEN_SHAREDCACHE;\n  }else if( sqlite3GlobalConfig.sharedCacheEnabled ){\n    flags |= SQLITE_OPEN_SHAREDCACHE;\n  }\n\n  /* Remove harmful bits from the flags parameter\n  **\n  ** The SQLITE_OPEN_NOMUTEX and SQLITE_OPEN_FULLMUTEX flags were\n  ** dealt with in the previous code block.  Besides these, the only\n  ** valid input flags for sqlite3_open_v2() are SQLITE_OPEN_READONLY,\n  ** SQLITE_OPEN_READWRITE, SQLITE_OPEN_CREATE, SQLITE_OPEN_SHAREDCACHE,\n  ** SQLITE_OPEN_PRIVATECACHE, SQLITE_OPEN_READAHEAD, and some reserved bits.\n  ** Silently mask off all other flags.\n  */\n  flags &=  ~( SQLITE_OPEN_DELETEONCLOSE |\n               SQLITE_OPEN_EXCLUSIVE |\n               SQLITE_OPEN_MAIN_DB |\n               SQLITE_OPEN_TEMP_DB | \n               SQLITE_OPEN_TRANSIENT_DB | \n               SQLITE_OPEN_MAIN_JOURNAL | \n               SQLITE_OPEN_TEMP_JOURNAL | \n               SQLITE_OPEN_SUBJOURNAL | \n               SQLITE_OPEN_MASTER_JOURNAL |\n               SQLITE_OPEN_NOMUTEX |\n               SQLITE_OPEN_FULLMUTEX |\n               SQLITE_OPEN_WAL\n             );\n\n  /* Allocate the sqlite data structure */\n  db = sqlite3MallocZero( sizeof(sqlite3) );\n  if( db==0 ) goto opendb_out;\n  if( isThreadsafe ){\n    db->mutex = sqlite3MutexAlloc(SQLITE_MUTEX_RECURSIVE);\n    if( db->mutex==0 ){\n      sqlite3_free(db);\n      db = 0;\n      goto opendb_out;\n    }\n  }\n  sqlite3_mutex_enter(db->mutex);\n  db->errMask = 0xff;\n  db->nDb = 2;\n  db->magic = SQLITE_MAGIC_BUSY;\n  db->aDb = db->aDbStatic;\n\n  assert( sizeof(db->aLimit)==sizeof(aHardLimit) );\n  memcpy(db->aLimit, aHardLimit, sizeof(db->aLimit));\n  db->autoCommit = 1;\n  db->nextAutovac = -1;\n  db->nextPagesize = 0;\n  db->flags |= SQLITE_ShortColNames | SQLITE_AutoIndex\n#if SQLITE_DEFAULT_FILE_FORMAT<4\n                 | SQLITE_LegacyFileFmt\n#endif\n#ifdef SQLITE_ENABLE_LOAD_EXTENSION\n                 | SQLITE_LoadExtension\n#endif\n#if SQLITE_DEFAULT_RECURSIVE_TRIGGERS\n                 | SQLITE_RecTriggers\n#endif\n#if defined(SQLITE_DEFAULT_FOREIGN_KEYS) && SQLITE_DEFAULT_FOREIGN_KEYS\n                 | SQLITE_ForeignKeys\n#endif\n      ;\n  sqlite3HashInit(&db->aCollSeq);\n#ifndef SQLITE_OMIT_VIRTUALTABLE\n  sqlite3HashInit(&db->aModule);\n#endif\n\n  db->pVfs = sqlite3_vfs_find(zVfs);\n  if( !db->pVfs ){\n    rc = SQLITE_ERROR;\n    sqlite3Error(db, rc, \"no such vfs: %s\", zVfs);\n    goto opendb_out;\n  }\n\n  /* Add the default collation sequence BINARY. BINARY works for both UTF-8\n  ** and UTF-16, so add a version for each to avoid any unnecessary\n  ** conversions. The only error that can occur here is a malloc() failure.\n  */\n  createCollation(db, \"BINARY\", SQLITE_UTF8, SQLITE_COLL_BINARY, 0,\n                  binCollFunc, 0);\n  createCollation(db, \"BINARY\", SQLITE_UTF16BE, SQLITE_COLL_BINARY, 0,\n                  binCollFunc, 0);\n  createCollation(db, \"BINARY\", SQLITE_UTF16LE, SQLITE_COLL_BINARY, 0,\n                  binCollFunc, 0);\n  createCollation(db, \"RTRIM\", SQLITE_UTF8, SQLITE_COLL_USER, (void*)1,\n                  binCollFunc, 0);\n  if( db->mallocFailed ){\n    goto opendb_out;\n  }\n  db->pDfltColl = sqlite3FindCollSeq(db, SQLITE_UTF8, \"BINARY\", 0);\n  assert( db->pDfltColl!=0 );\n\n  /* Also add a UTF-8 case-insensitive collation sequence. */\n  createCollation(db, \"NOCASE\", SQLITE_UTF8, SQLITE_COLL_NOCASE, 0,\n                  nocaseCollatingFunc, 0);\n\n  /* Open the backend database driver */\n  db->openFlags = flags;\n  rc = sqlite3BtreeOpen(zFilename, db, &db->aDb[0].pBt, 0,\n                        flags | SQLITE_OPEN_MAIN_DB);\n  if( rc!=SQLITE_OK ){\n    if( rc==SQLITE_IOERR_NOMEM ){\n      rc = SQLITE_NOMEM;\n    }\n    sqlite3Error(db, rc, 0);\n    goto opendb_out;\n  }\n  db->aDb[0].pSchema = sqlite3SchemaGet(db, db->aDb[0].pBt);\n  db->aDb[1].pSchema = sqlite3SchemaGet(db, 0);\n\n\n  /* The default safety_level for the main database is 'full'; for the temp\n  ** database it is 'NONE'. This matches the pager layer defaults.  \n  */\n  db->aDb[0].zName = \"main\";\n  db->aDb[0].safety_level = 3;\n  db->aDb[1].zName = \"temp\";\n  db->aDb[1].safety_level = 1;\n\n  db->magic = SQLITE_MAGIC_OPEN;\n  if( db->mallocFailed ){\n    goto opendb_out;\n  }\n\n  /* Register all built-in functions, but do not attempt to read the\n  ** database schema yet. This is delayed until the first time the database\n  ** is accessed.\n  */\n  sqlite3Error(db, SQLITE_OK, 0);\n  sqlite3RegisterBuiltinFunctions(db);\n\n  /* Load automatic extensions - extensions that have been registered\n  ** using the sqlite3_automatic_extension() API.\n  */\n  sqlite3AutoLoadExtensions(db);\n  rc = sqlite3_errcode(db);\n  if( rc!=SQLITE_OK ){\n    goto opendb_out;\n  }\n\n#ifdef SQLITE_ENABLE_FTS1\n  if( !db->mallocFailed ){\n    extern int sqlite3Fts1Init(sqlite3*);\n    rc = sqlite3Fts1Init(db);\n  }\n#endif\n\n#ifdef SQLITE_ENABLE_FTS2\n  if( !db->mallocFailed && rc==SQLITE_OK ){\n    extern int sqlite3Fts2Init(sqlite3*);\n    rc = sqlite3Fts2Init(db);\n  }\n#endif\n\n#ifdef SQLITE_ENABLE_FTS3\n  if( !db->mallocFailed && rc==SQLITE_OK ){\n    rc = sqlite3Fts3Init(db);\n  }\n#endif\n\n#ifdef SQLITE_ENABLE_ICU\n  if( !db->mallocFailed && rc==SQLITE_OK ){\n    rc = sqlite3IcuInit(db);\n  }\n#endif\n\n#ifdef SQLITE_ENABLE_RTREE\n  if( !db->mallocFailed && rc==SQLITE_OK){\n    rc = sqlite3RtreeInit(db);\n  }\n#endif\n\n  sqlite3Error(db, rc, 0);\n\n  /* -DSQLITE_DEFAULT_LOCKING_MODE=1 makes EXCLUSIVE the default locking\n  ** mode.  -DSQLITE_DEFAULT_LOCKING_MODE=0 make NORMAL the default locking\n  ** mode.  Doing nothing at all also makes NORMAL the default.\n  */\n#ifdef SQLITE_DEFAULT_LOCKING_MODE\n  db->dfltLockMode = SQLITE_DEFAULT_LOCKING_MODE;\n  sqlite3PagerLockingMode(sqlite3BtreePager(db->aDb[0].pBt),\n                          SQLITE_DEFAULT_LOCKING_MODE);\n#endif\n\n  /* Enable the lookaside-malloc subsystem */\n  setupLookaside(db, 0, sqlite3GlobalConfig.szLookaside,\n                        sqlite3GlobalConfig.nLookaside);\n\n  sqlite3_wal_autocheckpoint(db, SQLITE_DEFAULT_WAL_AUTOCHECKPOINT);\n\nopendb_out:\n  if( db ){\n    assert( db->mutex!=0 || isThreadsafe==0 || sqlite3GlobalConfig.bFullMutex==0 );\n    sqlite3_mutex_leave(db->mutex);\n  }\n  rc = sqlite3_errcode(db);\n  if( rc==SQLITE_NOMEM ){\n    sqlite3_close(db);\n    db = 0;\n  }else if( rc!=SQLITE_OK ){\n    db->magic = SQLITE_MAGIC_SICK;\n  }\n  *ppDb = db;\n  return sqlite3ApiExit(0, rc);\n}\n\n/*\n** Open a new database handle.\n*/\nSQLITE_API int sqlite3_open(\n  const char *zFilename, \n  sqlite3 **ppDb \n){\n  return openDatabase(zFilename, ppDb,\n                      SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE, 0);\n}\nSQLITE_API int sqlite3_open_v2(\n  const char *filename,   /* Database filename (UTF-8) */\n  sqlite3 **ppDb,         /* OUT: SQLite db handle */\n  int flags,              /* Flags */\n  const char *zVfs        /* Name of VFS module to use */\n){\n  return openDatabase(filename, ppDb, flags, zVfs);\n}\n\n#ifndef SQLITE_OMIT_UTF16\n/*\n** Open a new database handle.\n*/\nSQLITE_API int sqlite3_open16(\n  const void *zFilename, \n  sqlite3 **ppDb\n){\n  char const *zFilename8;   /* zFilename encoded in UTF-8 instead of UTF-16 */\n  sqlite3_value *pVal;\n  int rc;\n\n  assert( zFilename );\n  assert( ppDb );\n  *ppDb = 0;\n#ifndef SQLITE_OMIT_AUTOINIT\n  rc = sqlite3_initialize();\n  if( rc ) return rc;\n#endif\n  pVal = sqlite3ValueNew(0);\n  sqlite3ValueSetStr(pVal, -1, zFilename, SQLITE_UTF16NATIVE, SQLITE_STATIC);\n  zFilename8 = sqlite3ValueText(pVal, SQLITE_UTF8);\n  if( zFilename8 ){\n    rc = openDatabase(zFilename8, ppDb,\n                      SQLITE_OPEN_READWRITE | SQLITE_OPEN_CREATE, 0);\n    assert( *ppDb || rc==SQLITE_NOMEM );\n    if( rc==SQLITE_OK && !DbHasProperty(*ppDb, 0, DB_SchemaLoaded) ){\n      ENC(*ppDb) = SQLITE_UTF16NATIVE;\n    }\n  }else{\n    rc = SQLITE_NOMEM;\n  }\n  sqlite3ValueFree(pVal);\n\n  return sqlite3ApiExit(0, rc);\n}\n#endif /* SQLITE_OMIT_UTF16 */\n\n/*\n** Register a new collation sequence with the database handle db.\n*/\nSQLITE_API int sqlite3_create_collation(\n  sqlite3* db, \n  const char *zName, \n  int enc, \n  void* pCtx,\n  int(*xCompare)(void*,int,const void*,int,const void*)\n){\n  int rc;\n  sqlite3_mutex_enter(db->mutex);\n  assert( !db->mallocFailed );\n  rc = createCollation(db, zName, (u8)enc, SQLITE_COLL_USER, pCtx, xCompare, 0);\n  rc = sqlite3ApiExit(db, rc);\n  sqlite3_mutex_leave(db->mutex);\n  return rc;\n}\n\n/*\n** Register a new collation sequence with the database handle db.\n*/\nSQLITE_API int sqlite3_create_collation_v2(\n  sqlite3* db, \n  const char *zName, \n  int enc, \n  void* pCtx,\n  int(*xCompare)(void*,int,const void*,int,const void*),\n  void(*xDel)(void*)\n){\n  int rc;\n  sqlite3_mutex_enter(db->mutex);\n  assert( !db->mallocFailed );\n  rc = createCollation(db, zName, (u8)enc, SQLITE_COLL_USER, pCtx, xCompare, xDel);\n  rc = sqlite3ApiExit(db, rc);\n  sqlite3_mutex_leave(db->mutex);\n  return rc;\n}\n\n#ifndef SQLITE_OMIT_UTF16\n/*\n** Register a new collation sequence with the database handle db.\n*/\nSQLITE_API int sqlite3_create_collation16(\n  sqlite3* db, \n  const void *zName,\n  int enc, \n  void* pCtx,\n  int(*xCompare)(void*,int,const void*,int,const void*)\n){\n  int rc = SQLITE_OK;\n  char *zName8;\n  sqlite3_mutex_enter(db->mutex);\n  assert( !db->mallocFailed );\n  zName8 = sqlite3Utf16to8(db, zName, -1, SQLITE_UTF16NATIVE);\n  if( zName8 ){\n    rc = createCollation(db, zName8, (u8)enc, SQLITE_COLL_USER, pCtx, xCompare, 0);\n    sqlite3DbFree(db, zName8);\n  }\n  rc = sqlite3ApiExit(db, rc);\n  sqlite3_mutex_leave(db->mutex);\n  return rc;\n}\n#endif /* SQLITE_OMIT_UTF16 */\n\n/*\n** Register a collation sequence factory callback with the database handle\n** db. Replace any previously installed collation sequence factory.\n*/\nSQLITE_API int sqlite3_collation_needed(\n  sqlite3 *db, \n  void *pCollNeededArg, \n  void(*xCollNeeded)(void*,sqlite3*,int eTextRep,const char*)\n){\n  sqlite3_mutex_enter(db->mutex);\n  db->xCollNeeded = xCollNeeded;\n  db->xCollNeeded16 = 0;\n  db->pCollNeededArg = pCollNeededArg;\n  sqlite3_mutex_leave(db->mutex);\n  return SQLITE_OK;\n}\n\n#ifndef SQLITE_OMIT_UTF16\n/*\n** Register a collation sequence factory callback with the database handle\n** db. Replace any previously installed collation sequence factory.\n*/\nSQLITE_API int sqlite3_collation_needed16(\n  sqlite3 *db, \n  void *pCollNeededArg, \n  void(*xCollNeeded16)(void*,sqlite3*,int eTextRep,const void*)\n){\n  sqlite3_mutex_enter(db->mutex);\n  db->xCollNeeded = 0;\n  db->xCollNeeded16 = xCollNeeded16;\n  db->pCollNeededArg = pCollNeededArg;\n  sqlite3_mutex_leave(db->mutex);\n  return SQLITE_OK;\n}\n#endif /* SQLITE_OMIT_UTF16 */\n\n#ifndef SQLITE_OMIT_DEPRECATED\n/*\n** This function is now an anachronism. It used to be used to recover from a\n** malloc() failure, but SQLite now does this automatically.\n*/\nSQLITE_API int sqlite3_global_recover(void){\n  return SQLITE_OK;\n}\n#endif\n\n/*\n** Test to see whether or not the database connection is in autocommit\n** mode.  Return TRUE if it is and FALSE if not.  Autocommit mode is on\n** by default.  Autocommit is disabled by a BEGIN statement and reenabled\n** by the next COMMIT or ROLLBACK.\n**\n******* THIS IS AN EXPERIMENTAL API AND IS SUBJECT TO CHANGE ******\n*/\nSQLITE_API int sqlite3_get_autocommit(sqlite3 *db){\n  return db->autoCommit;\n}\n\n/*\n** The following routines are subtitutes for constants SQLITE_CORRUPT,\n** SQLITE_MISUSE, SQLITE_CANTOPEN, SQLITE_IOERR and possibly other error\n** constants.  They server two purposes:\n**\n**   1.  Serve as a convenient place to set a breakpoint in a debugger\n**       to detect when version error conditions occurs.\n**\n**   2.  Invoke sqlite3_log() to provide the source code location where\n**       a low-level error is first detected.\n*/\nSQLITE_PRIVATE int sqlite3CorruptError(int lineno){\n  testcase( sqlite3GlobalConfig.xLog!=0 );\n  printf(\"database corruption line %d\\n\", lineno);\n  sqlite3_log(SQLITE_CORRUPT,\n              \"database corruption at line %d of [%.10s]\",\n              lineno, 20+sqlite3_sourceid());\n  return SQLITE_CORRUPT;\n}\nSQLITE_PRIVATE int sqlite3MisuseError(int lineno){\n  testcase( sqlite3GlobalConfig.xLog!=0 );\n  sqlite3_log(SQLITE_MISUSE, \n              \"misuse at line %d of [%.10s]\",\n              lineno, 20+sqlite3_sourceid());\n  return SQLITE_MISUSE;\n}\nSQLITE_PRIVATE int sqlite3CantopenError(int lineno){\n  testcase( sqlite3GlobalConfig.xLog!=0 );\n  sqlite3_log(SQLITE_CANTOPEN, \n              \"cannot open file at line %d of [%.10s]\",\n              lineno, 20+sqlite3_sourceid());\n  return SQLITE_CANTOPEN;\n}\n\n\n#ifndef SQLITE_OMIT_DEPRECATED\n/*\n** This is a convenience routine that makes sure that all thread-specific\n** data for this thread has been deallocated.\n**\n** SQLite no longer uses thread-specific data so this routine is now a\n** no-op.  It is retained for historical compatibility.\n*/\nSQLITE_API void sqlite3_thread_cleanup(void){\n}\n#endif\n\n/*\n** Return meta information about a specific column of a database table.\n** See comment in sqlite3.h (sqlite.h.in) for details.\n*/\n#ifdef SQLITE_ENABLE_COLUMN_METADATA\nSQLITE_API int sqlite3_table_column_metadata(\n  sqlite3 *db,                /* Connection handle */\n  const char *zDbName,        /* Database name or NULL */\n  const char *zTableName,     /* Table name */\n  const char *zColumnName,    /* Column name */\n  char const **pzDataType,    /* OUTPUT: Declared data type */\n  char const **pzCollSeq,     /* OUTPUT: Collation sequence name */\n  int *pNotNull,              /* OUTPUT: True if NOT NULL constraint exists */\n  int *pPrimaryKey,           /* OUTPUT: True if column part of PK */\n  int *pAutoinc               /* OUTPUT: True if column is auto-increment */\n){\n  int rc;\n  char *zErrMsg = 0;\n  Table *pTab = 0;\n  Column *pCol = 0;\n  int iCol;\n\n  char const *zDataType = 0;\n  char const *zCollSeq = 0;\n  int notnull = 0;\n  int primarykey = 0;\n  int autoinc = 0;\n\n  /* Ensure the database schema has been loaded */\n  sqlite3_mutex_enter(db->mutex);\n  sqlite3BtreeEnterAll(db);\n  rc = sqlite3Init(db, &zErrMsg);\n  if( SQLITE_OK!=rc ){\n    goto error_out;\n  }\n\n  /* Locate the table in question */\n  pTab = sqlite3FindTable(db, zTableName, zDbName);\n  if( !pTab || pTab->pSelect ){\n    pTab = 0;\n    goto error_out;\n  }\n\n  /* Find the column for which info is requested */\n  if( sqlite3IsRowid(zColumnName) ){\n    iCol = pTab->iPKey;\n    if( iCol>=0 ){\n      pCol = &pTab->aCol[iCol];\n    }\n  }else{\n    for(iCol=0; iCol<pTab->nCol; iCol++){\n      pCol = &pTab->aCol[iCol];\n      if( 0==sqlite3StrICmp(pCol->zName, zColumnName) ){\n        break;\n      }\n    }\n    if( iCol==pTab->nCol ){\n      pTab = 0;\n      goto error_out;\n    }\n  }\n\n  /* The following block stores the meta information that will be returned\n  ** to the caller in local variables zDataType, zCollSeq, notnull, primarykey\n  ** and autoinc. At this point there are two possibilities:\n  ** \n  **     1. The specified column name was rowid\", \"oid\" or \"_rowid_\" \n  **        and there is no explicitly declared IPK column. \n  **\n  **     2. The table is not a view and the column name identified an \n  **        explicitly declared column. Copy meta information from *pCol.\n  */ \n  if( pCol ){\n    zDataType = pCol->zType;\n    zCollSeq = pCol->zColl;\n    notnull = pCol->notNull!=0;\n    primarykey  = pCol->isPrimKey!=0;\n    autoinc = pTab->iPKey==iCol && (pTab->tabFlags & TF_Autoincrement)!=0;\n  }else{\n    zDataType = \"INTEGER\";\n    primarykey = 1;\n  }\n  if( !zCollSeq ){\n    zCollSeq = \"BINARY\";\n  }\n\nerror_out:\n  sqlite3BtreeLeaveAll(db);\n\n  /* Whether the function call succeeded or failed, set the output parameters\n  ** to whatever their local counterparts contain. If an error did occur,\n  ** this has the effect of zeroing all output parameters.\n  */\n  if( pzDataType ) *pzDataType = zDataType;\n  if( pzCollSeq ) *pzCollSeq = zCollSeq;\n  if( pNotNull ) *pNotNull = notnull;\n  if( pPrimaryKey ) *pPrimaryKey = primarykey;\n  if( pAutoinc ) *pAutoinc = autoinc;\n\n  if( SQLITE_OK==rc && !pTab ){\n    sqlite3DbFree(db, zErrMsg);\n    zErrMsg = sqlite3MPrintf(db, \"no such table column: %s.%s\", zTableName,\n        zColumnName);\n    rc = SQLITE_ERROR;\n  }\n  sqlite3Error(db, rc, (zErrMsg?\"%s\":0), zErrMsg);\n  sqlite3DbFree(db, zErrMsg);\n  rc = sqlite3ApiExit(db, rc);\n  sqlite3_mutex_leave(db->mutex);\n  return rc;\n}\n#endif\n\n/*\n** Sleep for a little while.  Return the amount of time slept.\n*/\nSQLITE_API int sqlite3_sleep(int ms){\n  sqlite3_vfs *pVfs;\n  int rc;\n  pVfs = sqlite3_vfs_find(0);\n  if( pVfs==0 ) return 0;\n\n  /* This function works in milliseconds, but the underlying OsSleep() \n  ** API uses microseconds. Hence the 1000's.\n  */\n  rc = (sqlite3OsSleep(pVfs, 1000*ms)/1000);\n  return rc;\n}\n\n/*\n** Enable or disable the extended result codes.\n*/\nSQLITE_API int sqlite3_extended_result_codes(sqlite3 *db, int onoff){\n  sqlite3_mutex_enter(db->mutex);\n  db->errMask = onoff ? 0xffffffff : 0xff;\n  sqlite3_mutex_leave(db->mutex);\n  return SQLITE_OK;\n}\n\n/*\n** Invoke the xFileControl method on a particular database.\n*/\nSQLITE_API int sqlite3_file_control(sqlite3 *db, const char *zDbName, int op, void *pArg){\n  int rc = SQLITE_ERROR;\n  int iDb;\n  sqlite3_mutex_enter(db->mutex);\n  if( zDbName==0 ){\n    iDb = 0;\n  }else{\n    for(iDb=0; iDb<db->nDb; iDb++){\n      if( strcmp(db->aDb[iDb].zName, zDbName)==0 ) break;\n    }\n  }\n  if( iDb<db->nDb ){\n    Btree *pBtree = db->aDb[iDb].pBt;\n    if( pBtree ){\n      Pager *pPager;\n      sqlite3_file *fd;\n      sqlite3BtreeEnter(pBtree);\n      pPager = sqlite3BtreePager(pBtree);\n      assert( pPager!=0 );\n      fd = sqlite3PagerFile(pPager);\n      assert( fd!=0 );\n      if( op==SQLITE_FCNTL_FILE_POINTER ){\n        *(sqlite3_file**)pArg = fd;\n        rc = SQLITE_OK;\n      }else if( fd->pMethods ){\n        rc = sqlite3OsFileControl(fd, op, pArg);\n      }else{\n        rc = SQLITE_NOTFOUND;\n      }\n      sqlite3BtreeLeave(pBtree);\n    }\n  }\n  sqlite3_mutex_leave(db->mutex);\n  return rc;   \n}\n\n/*\n** Interface to the testing logic.\n*/\nSQLITE_API int sqlite3_test_control(int op, ...){\n  int rc = 0;\n#ifndef SQLITE_OMIT_BUILTIN_TEST\n  va_list ap;\n  va_start(ap, op);\n  switch( op ){\n\n    /*\n    ** Save the current state of the PRNG.\n    */\n    case SQLITE_TESTCTRL_PRNG_SAVE: {\n      sqlite3PrngSaveState();\n      break;\n    }\n\n    /*\n    ** Restore the state of the PRNG to the last state saved using\n    ** PRNG_SAVE.  If PRNG_SAVE has never before been called, then\n    ** this verb acts like PRNG_RESET.\n    */\n    case SQLITE_TESTCTRL_PRNG_RESTORE: {\n      sqlite3PrngRestoreState();\n      break;\n    }\n\n    /*\n    ** Reset the PRNG back to its uninitialized state.  The next call\n    ** to sqlite3_randomness() will reseed the PRNG using a single call\n    ** to the xRandomness method of the default VFS.\n    */\n    case SQLITE_TESTCTRL_PRNG_RESET: {\n      sqlite3PrngResetState();\n      break;\n    }\n\n    /*\n    **  sqlite3_test_control(BITVEC_TEST, size, program)\n    **\n    ** Run a test against a Bitvec object of size.  The program argument\n    ** is an array of integers that defines the test.  Return -1 on a\n    ** memory allocation error, 0 on success, or non-zero for an error.\n    ** See the sqlite3BitvecBuiltinTest() for additional information.\n    */\n    case SQLITE_TESTCTRL_BITVEC_TEST: {\n      int sz = va_arg(ap, int);\n      int *aProg = va_arg(ap, int*);\n      rc = sqlite3BitvecBuiltinTest(sz, aProg);\n      break;\n    }\n\n    /*\n    **  sqlite3_test_control(BENIGN_MALLOC_HOOKS, xBegin, xEnd)\n    **\n    ** Register hooks to call to indicate which malloc() failures \n    ** are benign.\n    */\n    case SQLITE_TESTCTRL_BENIGN_MALLOC_HOOKS: {\n      typedef void (*void_function)(void);\n      void_function xBenignBegin;\n      void_function xBenignEnd;\n      xBenignBegin = va_arg(ap, void_function);\n      xBenignEnd = va_arg(ap, void_function);\n      sqlite3BenignMallocHooks(xBenignBegin, xBenignEnd);\n      break;\n    }\n\n    /*\n    **  sqlite3_test_control(SQLITE_TESTCTRL_PENDING_BYTE, unsigned int X)\n    **\n    ** Set the PENDING byte to the value in the argument, if X>0.\n    ** Make no changes if X==0.  Return the value of the pending byte\n    ** as it existing before this routine was called.\n    **\n    ** IMPORTANT:  Changing the PENDING byte from 0x40000000 results in\n    ** an incompatible database file format.  Changing the PENDING byte\n    ** while any database connection is open results in undefined and\n    ** dileterious behavior.\n    */\n    case SQLITE_TESTCTRL_PENDING_BYTE: {\n      rc = PENDING_BYTE;\n#ifndef SQLITE_OMIT_WSD\n      {\n        unsigned int newVal = va_arg(ap, unsigned int);\n        if( newVal ) sqlite3PendingByte = newVal;\n      }\n#endif\n      break;\n    }\n\n    /*\n    **  sqlite3_test_control(SQLITE_TESTCTRL_ASSERT, int X)\n    **\n    ** This action provides a run-time test to see whether or not\n    ** assert() was enabled at compile-time.  If X is true and assert()\n    ** is enabled, then the return value is true.  If X is true and\n    ** assert() is disabled, then the return value is zero.  If X is\n    ** false and assert() is enabled, then the assertion fires and the\n    ** process aborts.  If X is false and assert() is disabled, then the\n    ** return value is zero.\n    */\n    case SQLITE_TESTCTRL_ASSERT: {\n      volatile int x = 0;\n      assert( (x = va_arg(ap,int))!=0 );\n      rc = x;\n      break;\n    }\n\n\n    /*\n    **  sqlite3_test_control(SQLITE_TESTCTRL_ALWAYS, int X)\n    **\n    ** This action provides a run-time test to see how the ALWAYS and\n    ** NEVER macros were defined at compile-time.\n    **\n    ** The return value is ALWAYS(X).  \n    **\n    ** The recommended test is X==2.  If the return value is 2, that means\n    ** ALWAYS() and NEVER() are both no-op pass-through macros, which is the\n    ** default setting.  If the return value is 1, then ALWAYS() is either\n    ** hard-coded to true or else it asserts if its argument is false.\n    ** The first behavior (hard-coded to true) is the case if\n    ** SQLITE_TESTCTRL_ASSERT shows that assert() is disabled and the second\n    ** behavior (assert if the argument to ALWAYS() is false) is the case if\n    ** SQLITE_TESTCTRL_ASSERT shows that assert() is enabled.\n    **\n    ** The run-time test procedure might look something like this:\n    **\n    **    if( sqlite3_test_control(SQLITE_TESTCTRL_ALWAYS, 2)==2 ){\n    **      // ALWAYS() and NEVER() are no-op pass-through macros\n    **    }else if( sqlite3_test_control(SQLITE_TESTCTRL_ASSERT, 1) ){\n    **      // ALWAYS(x) asserts that x is true. NEVER(x) asserts x is false.\n    **    }else{\n    **      // ALWAYS(x) is a constant 1.  NEVER(x) is a constant 0.\n    **    }\n    */\n    case SQLITE_TESTCTRL_ALWAYS: {\n      int x = va_arg(ap,int);\n      rc = ALWAYS(x);\n      break;\n    }\n\n    /*   sqlite3_test_control(SQLITE_TESTCTRL_RESERVE, sqlite3 *db, int N)\n    **\n    ** Set the nReserve size to N for the main database on the database\n    ** connection db.\n    */\n    case SQLITE_TESTCTRL_RESERVE: {\n      sqlite3 *db = va_arg(ap, sqlite3*);\n      int x = va_arg(ap,int);\n      sqlite3_mutex_enter(db->mutex);\n      sqlite3BtreeSetPageSize(db->aDb[0].pBt, 0, x, 0);\n      sqlite3_mutex_leave(db->mutex);\n      break;\n    }\n\n    /*  sqlite3_test_control(SQLITE_TESTCTRL_OPTIMIZATIONS, sqlite3 *db, int N)\n    **\n    ** Enable or disable various optimizations for testing purposes.  The \n    ** argument N is a bitmask of optimizations to be disabled.  For normal\n    ** operation N should be 0.  The idea is that a test program (like the\n    ** SQL Logic Test or SLT test module) can run the same SQL multiple times\n    ** with various optimizations disabled to verify that the same answer\n    ** is obtained in every case.\n    */\n    case SQLITE_TESTCTRL_OPTIMIZATIONS: {\n      sqlite3 *db = va_arg(ap, sqlite3*);\n      int x = va_arg(ap,int);\n      db->flags = (x & SQLITE_OptMask) | (db->flags & ~SQLITE_OptMask);\n      break;\n    }\n\n#ifdef SQLITE_N_KEYWORD\n    /* sqlite3_test_control(SQLITE_TESTCTRL_ISKEYWORD, const char *zWord)\n    **\n    ** If zWord is a keyword recognized by the parser, then return the\n    ** number of keywords.  Or if zWord is not a keyword, return 0.\n    ** \n    ** This test feature is only available in the amalgamation since\n    ** the SQLITE_N_KEYWORD macro is not defined in this file if SQLite\n    ** is built using separate source files.\n    */\n    case SQLITE_TESTCTRL_ISKEYWORD: {\n      const char *zWord = va_arg(ap, const char*);\n      int n = sqlite3Strlen30(zWord);\n      rc = (sqlite3KeywordCode((u8*)zWord, n)!=TK_ID) ? SQLITE_N_KEYWORD : 0;\n      break;\n    }\n#endif \n\n    /* sqlite3_test_control(SQLITE_TESTCTRL_PGHDRSZ)\n    **\n    ** Return the size of a pcache header in bytes.\n    */\n    case SQLITE_TESTCTRL_PGHDRSZ: {\n      rc = sizeof(PgHdr);\n      break;\n    }\n\n    /* sqlite3_test_control(SQLITE_TESTCTRL_SCRATCHMALLOC, sz, &pNew, pFree);\n    **\n    ** Pass pFree into sqlite3ScratchFree(). \n    ** If sz>0 then allocate a scratch buffer into pNew.  \n    */\n    case SQLITE_TESTCTRL_SCRATCHMALLOC: {\n      void *pFree, **ppNew;\n      int sz;\n      sz = va_arg(ap, int);\n      ppNew = va_arg(ap, void**);\n      pFree = va_arg(ap, void*);\n      if( sz ) *ppNew = sqlite3ScratchMalloc(sz);\n      sqlite3ScratchFree(pFree);\n      break;\n    }\n\n  }\n  va_end(ap);\n#endif /* SQLITE_OMIT_BUILTIN_TEST */\n  return rc;\n}\n\n/************** End of main.c ************************************************/\n/************** Begin file notify.c ******************************************/\n/*\n** 2009 March 3\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n**\n** This file contains the implementation of the sqlite3_unlock_notify()\n** API method and its associated functionality.\n*/\n\n/* Omit this entire file if SQLITE_ENABLE_UNLOCK_NOTIFY is not defined. */\n#ifdef SQLITE_ENABLE_UNLOCK_NOTIFY\n\n/*\n** Public interfaces:\n**\n**   sqlite3ConnectionBlocked()\n**   sqlite3ConnectionUnlocked()\n**   sqlite3ConnectionClosed()\n**   sqlite3_unlock_notify()\n*/\n\n#define assertMutexHeld() \\\n  assert( sqlite3_mutex_held(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER)) )\n\n/*\n** Head of a linked list of all sqlite3 objects created by this process\n** for which either sqlite3.pBlockingConnection or sqlite3.pUnlockConnection\n** is not NULL. This variable may only accessed while the STATIC_MASTER\n** mutex is held.\n*/\nstatic sqlite3 *SQLITE_WSD sqlite3BlockedList = 0;\n\n#ifndef NDEBUG\n/*\n** This function is a complex assert() that verifies the following \n** properties of the blocked connections list:\n**\n**   1) Each entry in the list has a non-NULL value for either \n**      pUnlockConnection or pBlockingConnection, or both.\n**\n**   2) All entries in the list that share a common value for \n**      xUnlockNotify are grouped together.\n**\n**   3) If the argument db is not NULL, then none of the entries in the\n**      blocked connections list have pUnlockConnection or pBlockingConnection\n**      set to db. This is used when closing connection db.\n*/\nstatic void checkListProperties(sqlite3 *db){\n  sqlite3 *p;\n  for(p=sqlite3BlockedList; p; p=p->pNextBlocked){\n    int seen = 0;\n    sqlite3 *p2;\n\n    /* Verify property (1) */\n    assert( p->pUnlockConnection || p->pBlockingConnection );\n\n    /* Verify property (2) */\n    for(p2=sqlite3BlockedList; p2!=p; p2=p2->pNextBlocked){\n      if( p2->xUnlockNotify==p->xUnlockNotify ) seen = 1;\n      assert( p2->xUnlockNotify==p->xUnlockNotify || !seen );\n      assert( db==0 || p->pUnlockConnection!=db );\n      assert( db==0 || p->pBlockingConnection!=db );\n    }\n  }\n}\n#else\n# define checkListProperties(x)\n#endif\n\n/*\n** Remove connection db from the blocked connections list. If connection\n** db is not currently a part of the list, this function is a no-op.\n*/\nstatic void removeFromBlockedList(sqlite3 *db){\n  sqlite3 **pp;\n  assertMutexHeld();\n  for(pp=&sqlite3BlockedList; *pp; pp = &(*pp)->pNextBlocked){\n    if( *pp==db ){\n      *pp = (*pp)->pNextBlocked;\n      break;\n    }\n  }\n}\n\n/*\n** Add connection db to the blocked connections list. It is assumed\n** that it is not already a part of the list.\n*/\nstatic void addToBlockedList(sqlite3 *db){\n  sqlite3 **pp;\n  assertMutexHeld();\n  for(\n    pp=&sqlite3BlockedList; \n    *pp && (*pp)->xUnlockNotify!=db->xUnlockNotify; \n    pp=&(*pp)->pNextBlocked\n  );\n  db->pNextBlocked = *pp;\n  *pp = db;\n}\n\n/*\n** Obtain the STATIC_MASTER mutex.\n*/\nstatic void enterMutex(void){\n  sqlite3_mutex_enter(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER));\n  checkListProperties(0);\n}\n\n/*\n** Release the STATIC_MASTER mutex.\n*/\nstatic void leaveMutex(void){\n  assertMutexHeld();\n  checkListProperties(0);\n  sqlite3_mutex_leave(sqlite3MutexAlloc(SQLITE_MUTEX_STATIC_MASTER));\n}\n\n/*\n** Register an unlock-notify callback.\n**\n** This is called after connection \"db\" has attempted some operation\n** but has received an SQLITE_LOCKED error because another connection\n** (call it pOther) in the same process was busy using the same shared\n** cache.  pOther is found by looking at db->pBlockingConnection.\n**\n** If there is no blocking connection, the callback is invoked immediately,\n** before this routine returns.\n**\n** If pOther is already blocked on db, then report SQLITE_LOCKED, to indicate\n** a deadlock.\n**\n** Otherwise, make arrangements to invoke xNotify when pOther drops\n** its locks.\n**\n** Each call to this routine overrides any prior callbacks registered\n** on the same \"db\".  If xNotify==0 then any prior callbacks are immediately\n** cancelled.\n*/\nSQLITE_API int sqlite3_unlock_notify(\n  sqlite3 *db,\n  void (*xNotify)(void **, int),\n  void *pArg\n){\n  int rc = SQLITE_OK;\n\n  sqlite3_mutex_enter(db->mutex);\n  enterMutex();\n\n  if( xNotify==0 ){\n    removeFromBlockedList(db);\n    db->pBlockingConnection = 0;\n    db->pUnlockConnection = 0;\n    db->xUnlockNotify = 0;\n    db->pUnlockArg = 0;\n  }else if( 0==db->pBlockingConnection ){\n    /* The blocking transaction has been concluded. Or there never was a \n    ** blocking transaction. In either case, invoke the notify callback\n    ** immediately. \n    */\n    xNotify(&pArg, 1);\n  }else{\n    sqlite3 *p;\n\n    for(p=db->pBlockingConnection; p && p!=db; p=p->pUnlockConnection){}\n    if( p ){\n      rc = SQLITE_LOCKED;              /* Deadlock detected. */\n    }else{\n      db->pUnlockConnection = db->pBlockingConnection;\n      db->xUnlockNotify = xNotify;\n      db->pUnlockArg = pArg;\n      removeFromBlockedList(db);\n      addToBlockedList(db);\n    }\n  }\n\n  leaveMutex();\n  assert( !db->mallocFailed );\n  sqlite3Error(db, rc, (rc?\"database is deadlocked\":0));\n  sqlite3_mutex_leave(db->mutex);\n  return rc;\n}\n\n/*\n** This function is called while stepping or preparing a statement \n** associated with connection db. The operation will return SQLITE_LOCKED\n** to the user because it requires a lock that will not be available\n** until connection pBlocker concludes its current transaction.\n*/\nSQLITE_PRIVATE void sqlite3ConnectionBlocked(sqlite3 *db, sqlite3 *pBlocker){\n  enterMutex();\n  if( db->pBlockingConnection==0 && db->pUnlockConnection==0 ){\n    addToBlockedList(db);\n  }\n  db->pBlockingConnection = pBlocker;\n  leaveMutex();\n}\n\n/*\n** This function is called when\n** the transaction opened by database db has just finished. Locks held \n** by database connection db have been released.\n**\n** This function loops through each entry in the blocked connections\n** list and does the following:\n**\n**   1) If the sqlite3.pBlockingConnection member of a list entry is\n**      set to db, then set pBlockingConnection=0.\n**\n**   2) If the sqlite3.pUnlockConnection member of a list entry is\n**      set to db, then invoke the configured unlock-notify callback and\n**      set pUnlockConnection=0.\n**\n**   3) If the two steps above mean that pBlockingConnection==0 and\n**      pUnlockConnection==0, remove the entry from the blocked connections\n**      list.\n*/\nSQLITE_PRIVATE void sqlite3ConnectionUnlocked(sqlite3 *db){\n  void (*xUnlockNotify)(void **, int) = 0; /* Unlock-notify cb to invoke */\n  int nArg = 0;                            /* Number of entries in aArg[] */\n  sqlite3 **pp;                            /* Iterator variable */\n  void **aArg;               /* Arguments to the unlock callback */\n  void **aDyn = 0;           /* Dynamically allocated space for aArg[] */\n  void *aStatic[16];         /* Starter space for aArg[].  No malloc required */\n\n  aArg = aStatic;\n  enterMutex();         /* Enter STATIC_MASTER mutex */\n\n  /* This loop runs once for each entry in the blocked-connections list. */\n  for(pp=&sqlite3BlockedList; *pp; /* no-op */ ){\n    sqlite3 *p = *pp;\n\n    /* Step 1. */\n    if( p->pBlockingConnection==db ){\n      p->pBlockingConnection = 0;\n    }\n\n    /* Step 2. */\n    if( p->pUnlockConnection==db ){\n      assert( p->xUnlockNotify );\n      if( p->xUnlockNotify!=xUnlockNotify && nArg!=0 ){\n        xUnlockNotify(aArg, nArg);\n        nArg = 0;\n      }\n\n      sqlite3BeginBenignMalloc();\n      assert( aArg==aDyn || (aDyn==0 && aArg==aStatic) );\n      assert( nArg<=(int)ArraySize(aStatic) || aArg==aDyn );\n      if( (!aDyn && nArg==(int)ArraySize(aStatic))\n       || (aDyn && nArg==(int)(sqlite3MallocSize(aDyn)/sizeof(void*)))\n      ){\n        /* The aArg[] array needs to grow. */\n        void **pNew = (void **)sqlite3Malloc(nArg*sizeof(void *)*2);\n        if( pNew ){\n          memcpy(pNew, aArg, nArg*sizeof(void *));\n          sqlite3_free(aDyn);\n          aDyn = aArg = pNew;\n        }else{\n          /* This occurs when the array of context pointers that need to\n          ** be passed to the unlock-notify callback is larger than the\n          ** aStatic[] array allocated on the stack and the attempt to \n          ** allocate a larger array from the heap has failed.\n          **\n          ** This is a difficult situation to handle. Returning an error\n          ** code to the caller is insufficient, as even if an error code\n          ** is returned the transaction on connection db will still be\n          ** closed and the unlock-notify callbacks on blocked connections\n          ** will go unissued. This might cause the application to wait\n          ** indefinitely for an unlock-notify callback that will never \n          ** arrive.\n          **\n          ** Instead, invoke the unlock-notify callback with the context\n          ** array already accumulated. We can then clear the array and\n          ** begin accumulating any further context pointers without \n          ** requiring any dynamic allocation. This is sub-optimal because\n          ** it means that instead of one callback with a large array of\n          ** context pointers the application will receive two or more\n          ** callbacks with smaller arrays of context pointers, which will\n          ** reduce the applications ability to prioritize multiple \n          ** connections. But it is the best that can be done under the\n          ** circumstances.\n          */\n          xUnlockNotify(aArg, nArg);\n          nArg = 0;\n        }\n      }\n      sqlite3EndBenignMalloc();\n\n      aArg[nArg++] = p->pUnlockArg;\n      xUnlockNotify = p->xUnlockNotify;\n      p->pUnlockConnection = 0;\n      p->xUnlockNotify = 0;\n      p->pUnlockArg = 0;\n    }\n\n    /* Step 3. */\n    if( p->pBlockingConnection==0 && p->pUnlockConnection==0 ){\n      /* Remove connection p from the blocked connections list. */\n      *pp = p->pNextBlocked;\n      p->pNextBlocked = 0;\n    }else{\n      pp = &p->pNextBlocked;\n    }\n  }\n\n  if( nArg!=0 ){\n    xUnlockNotify(aArg, nArg);\n  }\n  sqlite3_free(aDyn);\n  leaveMutex();         /* Leave STATIC_MASTER mutex */\n}\n\n/*\n** This is called when the database connection passed as an argument is \n** being closed. The connection is removed from the blocked list.\n*/\nSQLITE_PRIVATE void sqlite3ConnectionClosed(sqlite3 *db){\n  sqlite3ConnectionUnlocked(db);\n  enterMutex();\n  removeFromBlockedList(db);\n  checkListProperties(db);\n  leaveMutex();\n}\n#endif\n\n/************** End of notify.c **********************************************/\n/************** Begin file fts3.c ********************************************/\n/*\n** 2006 Oct 10\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n******************************************************************************\n**\n** This is an SQLite module implementing full-text search.\n*/\n\n/*\n** The code in this file is only compiled if:\n**\n**     * The FTS3 module is being built as an extension\n**       (in which case SQLITE_CORE is not defined), or\n**\n**     * The FTS3 module is being built into the core of\n**       SQLite (in which case SQLITE_ENABLE_FTS3 is defined).\n*/\n\n/* The full-text index is stored in a series of b+tree (-like)\n** structures called segments which map terms to doclists.  The\n** structures are like b+trees in layout, but are constructed from the\n** bottom up in optimal fashion and are not updatable.  Since trees\n** are built from the bottom up, things will be described from the\n** bottom up.\n**\n**\n**** Varints ****\n** The basic unit of encoding is a variable-length integer called a\n** varint.  We encode variable-length integers in little-endian order\n** using seven bits * per byte as follows:\n**\n** KEY:\n**         A = 0xxxxxxx    7 bits of data and one flag bit\n**         B = 1xxxxxxx    7 bits of data and one flag bit\n**\n**  7 bits - A\n** 14 bits - BA\n** 21 bits - BBA\n** and so on.\n**\n** This is similar in concept to how sqlite encodes \"varints\" but\n** the encoding is not the same.  SQLite varints are big-endian\n** are are limited to 9 bytes in length whereas FTS3 varints are\n** little-endian and can be up to 10 bytes in length (in theory).\n**\n** Example encodings:\n**\n**     1:    0x01\n**   127:    0x7f\n**   128:    0x81 0x00\n**\n**\n**** Document lists ****\n** A doclist (document list) holds a docid-sorted list of hits for a\n** given term.  Doclists hold docids and associated token positions.\n** A docid is the unique integer identifier for a single document.\n** A position is the index of a word within the document.  The first \n** word of the document has a position of 0.\n**\n** FTS3 used to optionally store character offsets using a compile-time\n** option.  But that functionality is no longer supported.\n**\n** A doclist is stored like this:\n**\n** array {\n**   varint docid;\n**   array {                (position list for column 0)\n**     varint position;     (2 more than the delta from previous position)\n**   }\n**   array {\n**     varint POS_COLUMN;   (marks start of position list for new column)\n**     varint column;       (index of new column)\n**     array {\n**       varint position;   (2 more than the delta from previous position)\n**     }\n**   }\n**   varint POS_END;        (marks end of positions for this document.\n** }\n**\n** Here, array { X } means zero or more occurrences of X, adjacent in\n** memory.  A \"position\" is an index of a token in the token stream\n** generated by the tokenizer. Note that POS_END and POS_COLUMN occur \n** in the same logical place as the position element, and act as sentinals\n** ending a position list array.  POS_END is 0.  POS_COLUMN is 1.\n** The positions numbers are not stored literally but rather as two more\n** than the difference from the prior position, or the just the position plus\n** 2 for the first position.  Example:\n**\n**   label:       A B C D E  F  G H   I  J K\n**   value:     123 5 9 1 1 14 35 0 234 72 0\n**\n** The 123 value is the first docid.  For column zero in this document\n** there are two matches at positions 3 and 10 (5-2 and 9-2+3).  The 1\n** at D signals the start of a new column; the 1 at E indicates that the\n** new column is column number 1.  There are two positions at 12 and 45\n** (14-2 and 35-2+12).  The 0 at H indicate the end-of-document.  The\n** 234 at I is the next docid.  It has one position 72 (72-2) and then\n** terminates with the 0 at K.\n**\n** A \"position-list\" is the list of positions for multiple columns for\n** a single docid.  A \"column-list\" is the set of positions for a single\n** column.  Hence, a position-list consists of one or more column-lists,\n** a document record consists of a docid followed by a position-list and\n** a doclist consists of one or more document records.\n**\n** A bare doclist omits the position information, becoming an \n** array of varint-encoded docids.\n**\n**** Segment leaf nodes ****\n** Segment leaf nodes store terms and doclists, ordered by term.  Leaf\n** nodes are written using LeafWriter, and read using LeafReader (to\n** iterate through a single leaf node's data) and LeavesReader (to\n** iterate through a segment's entire leaf layer).  Leaf nodes have\n** the format:\n**\n** varint iHeight;             (height from leaf level, always 0)\n** varint nTerm;               (length of first term)\n** char pTerm[nTerm];          (content of first term)\n** varint nDoclist;            (length of term's associated doclist)\n** char pDoclist[nDoclist];    (content of doclist)\n** array {\n**                             (further terms are delta-encoded)\n**   varint nPrefix;           (length of prefix shared with previous term)\n**   varint nSuffix;           (length of unshared suffix)\n**   char pTermSuffix[nSuffix];(unshared suffix of next term)\n**   varint nDoclist;          (length of term's associated doclist)\n**   char pDoclist[nDoclist];  (content of doclist)\n** }\n**\n** Here, array { X } means zero or more occurrences of X, adjacent in\n** memory.\n**\n** Leaf nodes are broken into blocks which are stored contiguously in\n** the %_segments table in sorted order.  This means that when the end\n** of a node is reached, the next term is in the node with the next\n** greater node id.\n**\n** New data is spilled to a new leaf node when the current node\n** exceeds LEAF_MAX bytes (default 2048).  New data which itself is\n** larger than STANDALONE_MIN (default 1024) is placed in a standalone\n** node (a leaf node with a single term and doclist).  The goal of\n** these settings is to pack together groups of small doclists while\n** making it efficient to directly access large doclists.  The\n** assumption is that large doclists represent terms which are more\n** likely to be query targets.\n**\n** TODO(shess) It may be useful for blocking decisions to be more\n** dynamic.  For instance, it may make more sense to have a 2.5k leaf\n** node rather than splitting into 2k and .5k nodes.  My intuition is\n** that this might extend through 2x or 4x the pagesize.\n**\n**\n**** Segment interior nodes ****\n** Segment interior nodes store blockids for subtree nodes and terms\n** to describe what data is stored by the each subtree.  Interior\n** nodes are written using InteriorWriter, and read using\n** InteriorReader.  InteriorWriters are created as needed when\n** SegmentWriter creates new leaf nodes, or when an interior node\n** itself grows too big and must be split.  The format of interior\n** nodes:\n**\n** varint iHeight;           (height from leaf level, always >0)\n** varint iBlockid;          (block id of node's leftmost subtree)\n** optional {\n**   varint nTerm;           (length of first term)\n**   char pTerm[nTerm];      (content of first term)\n**   array {\n**                                (further terms are delta-encoded)\n**     varint nPrefix;            (length of shared prefix with previous term)\n**     varint nSuffix;            (length of unshared suffix)\n**     char pTermSuffix[nSuffix]; (unshared suffix of next term)\n**   }\n** }\n**\n** Here, optional { X } means an optional element, while array { X }\n** means zero or more occurrences of X, adjacent in memory.\n**\n** An interior node encodes n terms separating n+1 subtrees.  The\n** subtree blocks are contiguous, so only the first subtree's blockid\n** is encoded.  The subtree at iBlockid will contain all terms less\n** than the first term encoded (or all terms if no term is encoded).\n** Otherwise, for terms greater than or equal to pTerm[i] but less\n** than pTerm[i+1], the subtree for that term will be rooted at\n** iBlockid+i.  Interior nodes only store enough term data to\n** distinguish adjacent children (if the rightmost term of the left\n** child is \"something\", and the leftmost term of the right child is\n** \"wicked\", only \"w\" is stored).\n**\n** New data is spilled to a new interior node at the same height when\n** the current node exceeds INTERIOR_MAX bytes (default 2048).\n** INTERIOR_MIN_TERMS (default 7) keeps large terms from monopolizing\n** interior nodes and making the tree too skinny.  The interior nodes\n** at a given height are naturally tracked by interior nodes at\n** height+1, and so on.\n**\n**\n**** Segment directory ****\n** The segment directory in table %_segdir stores meta-information for\n** merging and deleting segments, and also the root node of the\n** segment's tree.\n**\n** The root node is the top node of the segment's tree after encoding\n** the entire segment, restricted to ROOT_MAX bytes (default 1024).\n** This could be either a leaf node or an interior node.  If the top\n** node requires more than ROOT_MAX bytes, it is flushed to %_segments\n** and a new root interior node is generated (which should always fit\n** within ROOT_MAX because it only needs space for 2 varints, the\n** height and the blockid of the previous root).\n**\n** The meta-information in the segment directory is:\n**   level               - segment level (see below)\n**   idx                 - index within level\n**                       - (level,idx uniquely identify a segment)\n**   start_block         - first leaf node\n**   leaves_end_block    - last leaf node\n**   end_block           - last block (including interior nodes)\n**   root                - contents of root node\n**\n** If the root node is a leaf node, then start_block,\n** leaves_end_block, and end_block are all 0.\n**\n**\n**** Segment merging ****\n** To amortize update costs, segments are grouped into levels and\n** merged in batches.  Each increase in level represents exponentially\n** more documents.\n**\n** New documents (actually, document updates) are tokenized and\n** written individually (using LeafWriter) to a level 0 segment, with\n** incrementing idx.  When idx reaches MERGE_COUNT (default 16), all\n** level 0 segments are merged into a single level 1 segment.  Level 1\n** is populated like level 0, and eventually MERGE_COUNT level 1\n** segments are merged to a single level 2 segment (representing\n** MERGE_COUNT^2 updates), and so on.\n**\n** A segment merge traverses all segments at a given level in\n** parallel, performing a straightforward sorted merge.  Since segment\n** leaf nodes are written in to the %_segments table in order, this\n** merge traverses the underlying sqlite disk structures efficiently.\n** After the merge, all segment blocks from the merged level are\n** deleted.\n**\n** MERGE_COUNT controls how often we merge segments.  16 seems to be\n** somewhat of a sweet spot for insertion performance.  32 and 64 show\n** very similar performance numbers to 16 on insertion, though they're\n** a tiny bit slower (perhaps due to more overhead in merge-time\n** sorting).  8 is about 20% slower than 16, 4 about 50% slower than\n** 16, 2 about 66% slower than 16.\n**\n** At query time, high MERGE_COUNT increases the number of segments\n** which need to be scanned and merged.  For instance, with 100k docs\n** inserted:\n**\n**    MERGE_COUNT   segments\n**       16           25\n**        8           12\n**        4           10\n**        2            6\n**\n** This appears to have only a moderate impact on queries for very\n** frequent terms (which are somewhat dominated by segment merge\n** costs), and infrequent and non-existent terms still seem to be fast\n** even with many segments.\n**\n** TODO(shess) That said, it would be nice to have a better query-side\n** argument for MERGE_COUNT of 16.  Also, it is possible/likely that\n** optimizations to things like doclist merging will swing the sweet\n** spot around.\n**\n**\n**\n**** Handling of deletions and updates ****\n** Since we're using a segmented structure, with no docid-oriented\n** index into the term index, we clearly cannot simply update the term\n** index when a document is deleted or updated.  For deletions, we\n** write an empty doclist (varint(docid) varint(POS_END)), for updates\n** we simply write the new doclist.  Segment merges overwrite older\n** data for a particular docid with newer data, so deletes or updates\n** will eventually overtake the earlier data and knock it out.  The\n** query logic likewise merges doclists so that newer data knocks out\n** older data.\n**\n** TODO(shess) Provide a VACUUM type operation to clear out all\n** deletions and duplications.  This would basically be a forced merge\n** into a single segment.\n*/\n\n#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS3)\n\n#if defined(SQLITE_ENABLE_FTS3) && !defined(SQLITE_CORE)\n# define SQLITE_CORE 1\n#endif\n\n/************** Include fts3Int.h in the middle of fts3.c ********************/\n/************** Begin file fts3Int.h *****************************************/\n/*\n** 2009 Nov 12\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n******************************************************************************\n**\n*/\n\n#ifndef _FTSINT_H\n#define _FTSINT_H\n\n#if !defined(NDEBUG) && !defined(SQLITE_DEBUG) \n# define NDEBUG 1\n#endif\n\n/************** Include fts3_tokenizer.h in the middle of fts3Int.h **********/\n/************** Begin file fts3_tokenizer.h **********************************/\n/*\n** 2006 July 10\n**\n** The author disclaims copyright to this source code.\n**\n*************************************************************************\n** Defines the interface to tokenizers used by fulltext-search.  There\n** are three basic components:\n**\n** sqlite3_tokenizer_module is a singleton defining the tokenizer\n** interface functions.  This is essentially the class structure for\n** tokenizers.\n**\n** sqlite3_tokenizer is used to define a particular tokenizer, perhaps\n** including customization information defined at creation time.\n**\n** sqlite3_tokenizer_cursor is generated by a tokenizer to generate\n** tokens from a particular input.\n*/\n#ifndef _FTS3_TOKENIZER_H_\n#define _FTS3_TOKENIZER_H_\n\n/* TODO(shess) Only used for SQLITE_OK and SQLITE_DONE at this time.\n** If tokenizers are to be allowed to call sqlite3_*() functions, then\n** we will need a way to register the API consistently.\n*/\n\n/*\n** Structures used by the tokenizer interface. When a new tokenizer\n** implementation is registered, the caller provides a pointer to\n** an sqlite3_tokenizer_module containing pointers to the callback\n** functions that make up an implementation.\n**\n** When an fts3 table is created, it passes any arguments passed to\n** the tokenizer clause of the CREATE VIRTUAL TABLE statement to the\n** sqlite3_tokenizer_module.xCreate() function of the requested tokenizer\n** implementation. The xCreate() function in turn returns an \n** sqlite3_tokenizer structure representing the specific tokenizer to\n** be used for the fts3 table (customized by the tokenizer clause arguments).\n**\n** To tokenize an input buffer, the sqlite3_tokenizer_module.xOpen()\n** method is called. It returns an sqlite3_tokenizer_cursor object\n** that may be used to tokenize a specific input buffer based on\n** the tokenization rules supplied by a specific sqlite3_tokenizer\n** object.\n*/\ntypedef struct sqlite3_tokenizer_module sqlite3_tokenizer_module;\ntypedef struct sqlite3_tokenizer sqlite3_tokenizer;\ntypedef struct sqlite3_tokenizer_cursor sqlite3_tokenizer_cursor;\n\nstruct sqlite3_tokenizer_module {\n\n  /*\n  ** Structure version. Should always be set to 0.\n  */\n  int iVersion;\n\n  /*\n  ** Create a new tokenizer. The values in the argv[] array are the\n  ** arguments passed to the \"tokenizer\" clause of the CREATE VIRTUAL\n  ** TABLE statement that created the fts3 table. For example, if\n  ** the following SQL is executed:\n  **\n  **   CREATE .. USING fts3( ... , tokenizer <tokenizer-name> arg1 arg2)\n  **\n  ** then argc is set to 2, and the argv[] array contains pointers\n  ** to the strings \"arg1\" and \"arg2\".\n  **\n  ** This method should return either SQLITE_OK (0), or an SQLite error \n  ** code. If SQLITE_OK is returned, then *ppTokenizer should be set\n  ** to point at the newly created tokenizer structure. The generic\n  ** sqlite3_tokenizer.pModule variable should not be initialised by\n  ** this callback. The caller will do so.\n  */\n  int (*xCreate)(\n    int argc,                           /* Size of argv array */\n    const char *const*argv,             /* Tokenizer argument strings */\n    sqlite3_tokenizer **ppTokenizer     /* OUT: Created tokenizer */\n  );\n\n  /*\n  ** Destroy an existing tokenizer. The fts3 module calls this method\n  ** exactly once for each successful call to xCreate().\n  */\n  int (*xDestroy)(sqlite3_tokenizer *pTokenizer);\n\n  /*\n  ** Create a tokenizer cursor to tokenize an input buffer. The caller\n  ** is responsible for ensuring that the input buffer remains valid\n  ** until the cursor is closed (using the xClose() method). \n  */\n  int (*xOpen)(\n    sqlite3_tokenizer *pTokenizer,       /* Tokenizer object */\n    const char *pInput, int nBytes,      /* Input buffer */\n    sqlite3_tokenizer_cursor **ppCursor  /* OUT: Created tokenizer cursor */\n  );\n\n  /*\n  ** Destroy an existing tokenizer cursor. The fts3 module calls this \n  ** method exactly once for each successful call to xOpen().\n  */\n  int (*xClose)(sqlite3_tokenizer_cursor *pCursor);\n\n  /*\n  ** Retrieve the next token from the tokenizer cursor pCursor. This\n  ** method should either return SQLITE_OK and set the values of the\n  ** \"OUT\" variables identified below, or SQLITE_DONE to indicate that\n  ** the end of the buffer has been reached, or an SQLite error code.\n  **\n  ** *ppToken should be set to point at a buffer containing the \n  ** normalized version of the token (i.e. after any case-folding and/or\n  ** stemming has been performed). *pnBytes should be set to the length\n  ** of this buffer in bytes. The input text that generated the token is\n  ** identified by the byte offsets returned in *piStartOffset and\n  ** *piEndOffset. *piStartOffset should be set to the index of the first\n  ** byte of the token in the input buffer. *piEndOffset should be set\n  ** to the index of the first byte just past the end of the token in\n  ** the input buffer.\n  **\n  ** The buffer *ppToken is set to point at is managed by the tokenizer\n  ** implementation. It is only required to be valid until the next call\n  ** to xNext() or xClose(). \n  */\n  /* TODO(shess) current implementation requires pInput to be\n  ** nul-terminated.  This should either be fixed, or pInput/nBytes\n  ** should be converted to zInput.\n  */\n  int (*xNext)(\n    sqlite3_tokenizer_cursor *pCursor,   /* Tokenizer cursor */\n    const char **ppToken, int *pnBytes,  /* OUT: Normalized text for token */\n    int *piStartOffset,  /* OUT: Byte offset of token in input buffer */\n    int *piEndOffset,    /* OUT: Byte offset of end of token in input buffer */\n    int *piPosition      /* OUT: Number of tokens returned before this one */\n  );\n};\n\nstruct sqlite3_tokenizer {\n  const sqlite3_tokenizer_module *pModule;  /* The module for this tokenizer */\n  /* Tokenizer implementations will typically add additional fields */\n};\n\nstruct sqlite3_tokenizer_cursor {\n  sqlite3_tokenizer *pTokenizer;       /* Tokenizer for this cursor. */\n  /* Tokenizer implementations will typically add additional fields */\n};\n\nint fts3_global_term_cnt(int iTerm, int iCol);\nint fts3_term_cnt(int iTerm, int iCol);\n\n\n#endif /* _FTS3_TOKENIZER_H_ */\n\n/************** End of fts3_tokenizer.h **************************************/\n/************** Continuing where we left off in fts3Int.h ********************/\n/************** Include fts3_hash.h in the middle of fts3Int.h ***************/\n/************** Begin file fts3_hash.h ***************************************/\n/*\n** 2001 September 22\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This is the header file for the generic hash-table implemenation\n** used in SQLite.  We've modified it slightly to serve as a standalone\n** hash table implementation for the full-text indexing module.\n**\n*/\n#ifndef _FTS3_HASH_H_\n#define _FTS3_HASH_H_\n\n/* Forward declarations of structures. */\ntypedef struct Fts3Hash Fts3Hash;\ntypedef struct Fts3HashElem Fts3HashElem;\n\n/* A complete hash table is an instance of the following structure.\n** The internals of this structure are intended to be opaque -- client\n** code should not attempt to access or modify the fields of this structure\n** directly.  Change this structure only by using the routines below.\n** However, many of the \"procedures\" and \"functions\" for modifying and\n** accessing this structure are really macros, so we can't really make\n** this structure opaque.\n*/\nstruct Fts3Hash {\n  char keyClass;          /* HASH_INT, _POINTER, _STRING, _BINARY */\n  char copyKey;           /* True if copy of key made on insert */\n  int count;              /* Number of entries in this table */\n  Fts3HashElem *first;    /* The first element of the array */\n  int htsize;             /* Number of buckets in the hash table */\n  struct _fts3ht {        /* the hash table */\n    int count;               /* Number of entries with this hash */\n    Fts3HashElem *chain;     /* Pointer to first entry with this hash */\n  } *ht;\n};\n\n/* Each element in the hash table is an instance of the following \n** structure.  All elements are stored on a single doubly-linked list.\n**\n** Again, this structure is intended to be opaque, but it can't really\n** be opaque because it is used by macros.\n*/\nstruct Fts3HashElem {\n  Fts3HashElem *next, *prev; /* Next and previous elements in the table */\n  void *data;                /* Data associated with this element */\n  void *pKey; int nKey;      /* Key associated with this element */\n};\n\n/*\n** There are 2 different modes of operation for a hash table:\n**\n**   FTS3_HASH_STRING        pKey points to a string that is nKey bytes long\n**                           (including the null-terminator, if any).  Case\n**                           is respected in comparisons.\n**\n**   FTS3_HASH_BINARY        pKey points to binary data nKey bytes long. \n**                           memcmp() is used to compare keys.\n**\n** A copy of the key is made if the copyKey parameter to fts3HashInit is 1.  \n*/\n#define FTS3_HASH_STRING    1\n#define FTS3_HASH_BINARY    2\n\n/*\n** Access routines.  To delete, insert a NULL pointer.\n*/\nSQLITE_PRIVATE void sqlite3Fts3HashInit(Fts3Hash *pNew, char keyClass, char copyKey);\nSQLITE_PRIVATE void *sqlite3Fts3HashInsert(Fts3Hash*, const void *pKey, int nKey, void *pData);\nSQLITE_PRIVATE void *sqlite3Fts3HashFind(const Fts3Hash*, const void *pKey, int nKey);\nSQLITE_PRIVATE void sqlite3Fts3HashClear(Fts3Hash*);\nSQLITE_PRIVATE Fts3HashElem *sqlite3Fts3HashFindElem(const Fts3Hash *, const void *, int);\n\n/*\n** Shorthand for the functions above\n*/\n#define fts3HashInit     sqlite3Fts3HashInit\n#define fts3HashInsert   sqlite3Fts3HashInsert\n#define fts3HashFind     sqlite3Fts3HashFind\n#define fts3HashClear    sqlite3Fts3HashClear\n#define fts3HashFindElem sqlite3Fts3HashFindElem\n\n/*\n** Macros for looping over all elements of a hash table.  The idiom is\n** like this:\n**\n**   Fts3Hash h;\n**   Fts3HashElem *p;\n**   ...\n**   for(p=fts3HashFirst(&h); p; p=fts3HashNext(p)){\n**     SomeStructure *pData = fts3HashData(p);\n**     // do something with pData\n**   }\n*/\n#define fts3HashFirst(H)  ((H)->first)\n#define fts3HashNext(E)   ((E)->next)\n#define fts3HashData(E)   ((E)->data)\n#define fts3HashKey(E)    ((E)->pKey)\n#define fts3HashKeysize(E) ((E)->nKey)\n\n/*\n** Number of entries in a hash table\n*/\n#define fts3HashCount(H)  ((H)->count)\n\n#endif /* _FTS3_HASH_H_ */\n\n/************** End of fts3_hash.h *******************************************/\n/************** Continuing where we left off in fts3Int.h ********************/\n\n/*\n** This constant controls how often segments are merged. Once there are\n** FTS3_MERGE_COUNT segments of level N, they are merged into a single\n** segment of level N+1.\n*/\n#define FTS3_MERGE_COUNT 16\n\n/*\n** This is the maximum amount of data (in bytes) to store in the \n** Fts3Table.pendingTerms hash table. Normally, the hash table is\n** populated as documents are inserted/updated/deleted in a transaction\n** and used to create a new segment when the transaction is committed.\n** However if this limit is reached midway through a transaction, a new \n** segment is created and the hash table cleared immediately.\n*/\n#define FTS3_MAX_PENDING_DATA (1*1024*1024)\n\n/*\n** Macro to return the number of elements in an array. SQLite has a\n** similar macro called ArraySize(). Use a different name to avoid\n** a collision when building an amalgamation with built-in FTS3.\n*/\n#define SizeofArray(X) ((int)(sizeof(X)/sizeof(X[0])))\n\n/*\n** Maximum length of a varint encoded integer. The varint format is different\n** from that used by SQLite, so the maximum length is 10, not 9.\n*/\n#define FTS3_VARINT_MAX 10\n\n/*\n** The testcase() macro is only used by the amalgamation.  If undefined,\n** make it a no-op.\n*/\n#ifndef testcase\n# define testcase(X)\n#endif\n\n/*\n** Terminator values for position-lists and column-lists.\n*/\n#define POS_COLUMN  (1)     /* Column-list terminator */\n#define POS_END     (0)     /* Position-list terminator */ \n\n/*\n** This section provides definitions to allow the\n** FTS3 extension to be compiled outside of the \n** amalgamation.\n*/\n#ifndef SQLITE_AMALGAMATION\n/*\n** Macros indicating that conditional expressions are always true or\n** false.\n*/\n#ifdef SQLITE_COVERAGE_TEST\n# define ALWAYS(x) (1)\n# define NEVER(X)  (0)\n#else\n# define ALWAYS(x) (x)\n# define NEVER(X)  (x)\n#endif\n\n/*\n** Internal types used by SQLite.\n*/\ntypedef unsigned char u8;         /* 1-byte (or larger) unsigned integer */\ntypedef short int i16;            /* 2-byte (or larger) signed integer */\ntypedef unsigned int u32;         /* 4-byte unsigned integer */\ntypedef sqlite3_uint64 u64;       /* 8-byte unsigned integer */\n/*\n** Macro used to suppress compiler warnings for unused parameters.\n*/\n#define UNUSED_PARAMETER(x) (void)(x)\n#endif\n\ntypedef struct Fts3Table Fts3Table;\ntypedef struct Fts3Cursor Fts3Cursor;\ntypedef struct Fts3Expr Fts3Expr;\ntypedef struct Fts3Phrase Fts3Phrase;\ntypedef struct Fts3PhraseToken Fts3PhraseToken;\n\ntypedef struct Fts3SegFilter Fts3SegFilter;\ntypedef struct Fts3DeferredToken Fts3DeferredToken;\ntypedef struct Fts3SegReader Fts3SegReader;\ntypedef struct Fts3SegReaderCursor Fts3SegReaderCursor;\n\n/*\n** A connection to a fulltext index is an instance of the following\n** structure. The xCreate and xConnect methods create an instance\n** of this structure and xDestroy and xDisconnect free that instance.\n** All other methods receive a pointer to the structure as one of their\n** arguments.\n*/\nstruct Fts3Table {\n  sqlite3_vtab base;              /* Base class used by SQLite core */\n  sqlite3 *db;                    /* The database connection */\n  const char *zDb;                /* logical database name */\n  const char *zName;              /* virtual table name */\n  int nColumn;                    /* number of named columns in virtual table */\n  char **azColumn;                /* column names.  malloced */\n  sqlite3_tokenizer *pTokenizer;  /* tokenizer for inserts and queries */\n\n  /* Precompiled statements used by the implementation. Each of these \n  ** statements is run and reset within a single virtual table API call. \n  */\n  sqlite3_stmt *aStmt[24];\n\n  char *zReadExprlist;\n  char *zWriteExprlist;\n\n  int nNodeSize;                  /* Soft limit for node size */\n  u8 bHasStat;                    /* True if %_stat table exists */\n  u8 bHasDocsize;                 /* True if %_docsize table exists */\n  int nPgsz;                      /* Page size for host database */\n  char *zSegmentsTbl;             /* Name of %_segments table */\n  sqlite3_blob *pSegments;        /* Blob handle open on %_segments table */\n\n  /* The following hash table is used to buffer pending index updates during\n  ** transactions. Variable nPendingData estimates the memory size of the \n  ** pending data, including hash table overhead, but not malloc overhead. \n  ** When nPendingData exceeds nMaxPendingData, the buffer is flushed \n  ** automatically. Variable iPrevDocid is the docid of the most recently\n  ** inserted record.\n  */\n  int nMaxPendingData;\n  int nPendingData;\n  sqlite_int64 iPrevDocid;\n  Fts3Hash pendingTerms;\n};\n\n/*\n** When the core wants to read from the virtual table, it creates a\n** virtual table cursor (an instance of the following structure) using\n** the xOpen method. Cursors are destroyed using the xClose method.\n*/\nstruct Fts3Cursor {\n  sqlite3_vtab_cursor base;       /* Base class used by SQLite core */\n  i16 eSearch;                    /* Search strategy (see below) */\n  u8 isEof;                       /* True if at End Of Results */\n  u8 isRequireSeek;               /* True if must seek pStmt to %_content row */\n  sqlite3_stmt *pStmt;            /* Prepared statement in use by the cursor */\n  Fts3Expr *pExpr;                /* Parsed MATCH query string */\n  int nPhrase;                    /* Number of matchable phrases in query */\n  Fts3DeferredToken *pDeferred;   /* Deferred search tokens, if any */\n  sqlite3_int64 iPrevId;          /* Previous id read from aDoclist */\n  char *pNextId;                  /* Pointer into the body of aDoclist */\n  char *aDoclist;                 /* List of docids for full-text queries */\n  int nDoclist;                   /* Size of buffer at aDoclist */\n  int eEvalmode;                  /* An FTS3_EVAL_XX constant */\n  int nRowAvg;                    /* Average size of database rows, in pages */\n\n  int isMatchinfoNeeded;          /* True when aMatchinfo[] needs filling in */\n  u32 *aMatchinfo;                /* Information about most recent match */\n  int nMatchinfo;                 /* Number of elements in aMatchinfo[] */\n  char *zMatchinfo;               /* Matchinfo specification */\n};\n\n#define FTS3_EVAL_FILTER    0\n#define FTS3_EVAL_NEXT      1\n#define FTS3_EVAL_MATCHINFO 2\n\n/*\n** The Fts3Cursor.eSearch member is always set to one of the following.\n** Actualy, Fts3Cursor.eSearch can be greater than or equal to\n** FTS3_FULLTEXT_SEARCH.  If so, then Fts3Cursor.eSearch - 2 is the index\n** of the column to be searched.  For example, in\n**\n**     CREATE VIRTUAL TABLE ex1 USING fts3(a,b,c,d);\n**     SELECT docid FROM ex1 WHERE b MATCH 'one two three';\n** \n** Because the LHS of the MATCH operator is 2nd column \"b\",\n** Fts3Cursor.eSearch will be set to FTS3_FULLTEXT_SEARCH+1.  (+0 for a,\n** +1 for b, +2 for c, +3 for d.)  If the LHS of MATCH were \"ex1\" \n** indicating that all columns should be searched,\n** then eSearch would be set to FTS3_FULLTEXT_SEARCH+4.\n*/\n#define FTS3_FULLSCAN_SEARCH 0    /* Linear scan of %_content table */\n#define FTS3_DOCID_SEARCH    1    /* Lookup by rowid on %_content table */\n#define FTS3_FULLTEXT_SEARCH 2    /* Full-text index search */\n\n/*\n** A \"phrase\" is a sequence of one or more tokens that must match in\n** sequence.  A single token is the base case and the most common case.\n** For a sequence of tokens contained in double-quotes (i.e. \"one two three\")\n** nToken will be the number of tokens in the string.\n**\n** The nDocMatch and nMatch variables contain data that may be used by the\n** matchinfo() function. They are populated when the full-text index is \n** queried for hits on the phrase. If one or more tokens in the phrase\n** are deferred, the nDocMatch and nMatch variables are populated based\n** on the assumption that the \n*/\nstruct Fts3PhraseToken {\n  char *z;                        /* Text of the token */\n  int n;                          /* Number of bytes in buffer z */\n  int isPrefix;                   /* True if token ends with a \"*\" character */\n  int bFulltext;                  /* True if full-text index was used */\n  Fts3SegReaderCursor *pSegcsr;   /* Segment-reader for this token */\n  Fts3DeferredToken *pDeferred;   /* Deferred token object for this token */\n};\n\nstruct Fts3Phrase {\n  /* Variables populated by fts3_expr.c when parsing a MATCH expression */\n  int nToken;                /* Number of tokens in the phrase */\n  int iColumn;               /* Index of column this phrase must match */\n  int isNot;                 /* Phrase prefixed by unary not (-) operator */\n  Fts3PhraseToken aToken[1]; /* One entry for each token in the phrase */\n};\n\n/*\n** A tree of these objects forms the RHS of a MATCH operator.\n**\n** If Fts3Expr.eType is either FTSQUERY_NEAR or FTSQUERY_PHRASE and isLoaded\n** is true, then aDoclist points to a malloced buffer, size nDoclist bytes, \n** containing the results of the NEAR or phrase query in FTS3 doclist\n** format. As usual, the initial \"Length\" field found in doclists stored\n** on disk is omitted from this buffer.\n**\n** Variable pCurrent always points to the start of a docid field within\n** aDoclist. Since the doclist is usually scanned in docid order, this can\n** be used to accelerate seeking to the required docid within the doclist.\n*/\nstruct Fts3Expr {\n  int eType;                 /* One of the FTSQUERY_XXX values defined below */\n  int nNear;                 /* Valid if eType==FTSQUERY_NEAR */\n  Fts3Expr *pParent;         /* pParent->pLeft==this or pParent->pRight==this */\n  Fts3Expr *pLeft;           /* Left operand */\n  Fts3Expr *pRight;          /* Right operand */\n  Fts3Phrase *pPhrase;       /* Valid if eType==FTSQUERY_PHRASE */\n\n  int isLoaded;              /* True if aDoclist/nDoclist are initialized. */\n  char *aDoclist;            /* Buffer containing doclist */\n  int nDoclist;              /* Size of aDoclist in bytes */\n\n  sqlite3_int64 iCurrent;\n  char *pCurrent;\n};\n\n/*\n** Candidate values for Fts3Query.eType. Note that the order of the first\n** four values is in order of precedence when parsing expressions. For \n** example, the following:\n**\n**   \"a OR b AND c NOT d NEAR e\"\n**\n** is equivalent to:\n**\n**   \"a OR (b AND (c NOT (d NEAR e)))\"\n*/\n#define FTSQUERY_NEAR   1\n#define FTSQUERY_NOT    2\n#define FTSQUERY_AND    3\n#define FTSQUERY_OR     4\n#define FTSQUERY_PHRASE 5\n\n\n/* fts3_write.c */\nSQLITE_PRIVATE int sqlite3Fts3UpdateMethod(sqlite3_vtab*,int,sqlite3_value**,sqlite3_int64*);\nSQLITE_PRIVATE int sqlite3Fts3PendingTermsFlush(Fts3Table *);\nSQLITE_PRIVATE void sqlite3Fts3PendingTermsClear(Fts3Table *);\nSQLITE_PRIVATE int sqlite3Fts3Optimize(Fts3Table *);\nSQLITE_PRIVATE int sqlite3Fts3SegReaderNew(int, sqlite3_int64,\n  sqlite3_int64, sqlite3_int64, const char *, int, Fts3SegReader**);\nSQLITE_PRIVATE int sqlite3Fts3SegReaderPending(Fts3Table*,const char*,int,int,Fts3SegReader**);\nSQLITE_PRIVATE void sqlite3Fts3SegReaderFree(Fts3SegReader *);\nSQLITE_PRIVATE int sqlite3Fts3SegReaderCost(Fts3Cursor *, Fts3SegReader *, int *);\nSQLITE_PRIVATE int sqlite3Fts3AllSegdirs(Fts3Table*, int, sqlite3_stmt **);\nSQLITE_PRIVATE int sqlite3Fts3ReadLock(Fts3Table *);\nSQLITE_PRIVATE int sqlite3Fts3ReadBlock(Fts3Table*, sqlite3_int64, char **, int*);\n\nSQLITE_PRIVATE int sqlite3Fts3SelectDoctotal(Fts3Table *, sqlite3_stmt **);\nSQLITE_PRIVATE int sqlite3Fts3SelectDocsize(Fts3Table *, sqlite3_int64, sqlite3_stmt **);\n\nSQLITE_PRIVATE void sqlite3Fts3FreeDeferredTokens(Fts3Cursor *);\nSQLITE_PRIVATE int sqlite3Fts3DeferToken(Fts3Cursor *, Fts3PhraseToken *, int);\nSQLITE_PRIVATE int sqlite3Fts3CacheDeferredDoclists(Fts3Cursor *);\nSQLITE_PRIVATE void sqlite3Fts3FreeDeferredDoclists(Fts3Cursor *);\nSQLITE_PRIVATE char *sqlite3Fts3DeferredDoclist(Fts3DeferredToken *, int *);\nSQLITE_PRIVATE void sqlite3Fts3SegmentsClose(Fts3Table *);\n\n#define FTS3_SEGCURSOR_PENDING -1\n#define FTS3_SEGCURSOR_ALL     -2\n\nSQLITE_PRIVATE int sqlite3Fts3SegReaderStart(Fts3Table*, Fts3SegReaderCursor*, Fts3SegFilter*);\nSQLITE_PRIVATE int sqlite3Fts3SegReaderStep(Fts3Table *, Fts3SegReaderCursor *);\nSQLITE_PRIVATE void sqlite3Fts3SegReaderFinish(Fts3SegReaderCursor *);\nSQLITE_PRIVATE int sqlite3Fts3SegReaderCursor(\n    Fts3Table *, int, const char *, int, int, int, Fts3SegReaderCursor *);\n\n/* Flags allowed as part of the 4th argument to SegmentReaderIterate() */\n#define FTS3_SEGMENT_REQUIRE_POS   0x00000001\n#define FTS3_SEGMENT_IGNORE_EMPTY  0x00000002\n#define FTS3_SEGMENT_COLUMN_FILTER 0x00000004\n#define FTS3_SEGMENT_PREFIX        0x00000008\n#define FTS3_SEGMENT_SCAN          0x00000010\n\n/* Type passed as 4th argument to SegmentReaderIterate() */\nstruct Fts3SegFilter {\n  const char *zTerm;\n  int nTerm;\n  int iCol;\n  int flags;\n};\n\nstruct Fts3SegReaderCursor {\n  /* Used internally by sqlite3Fts3SegReaderXXX() calls */\n  Fts3SegReader **apSegment;      /* Array of Fts3SegReader objects */\n  int nSegment;                   /* Size of apSegment array */\n  int nAdvance;                   /* How many seg-readers to advance */\n  Fts3SegFilter *pFilter;         /* Pointer to filter object */\n  char *aBuffer;                  /* Buffer to merge doclists in */\n  int nBuffer;                    /* Allocated size of aBuffer[] in bytes */\n\n  /* Cost of running this iterator. Used by fts3.c only. */\n  int nCost;\n\n  /* Output values. Valid only after Fts3SegReaderStep() returns SQLITE_ROW. */\n  char *zTerm;                    /* Pointer to term buffer */\n  int nTerm;                      /* Size of zTerm in bytes */\n  char *aDoclist;                 /* Pointer to doclist buffer */\n  int nDoclist;                   /* Size of aDoclist[] in bytes */\n};\n\n/* fts3.c */\nSQLITE_PRIVATE int sqlite3Fts3PutVarint(char *, sqlite3_int64);\nSQLITE_PRIVATE int sqlite3Fts3GetVarint(const char *, sqlite_int64 *);\nSQLITE_PRIVATE int sqlite3Fts3GetVarint32(const char *, int *);\nSQLITE_PRIVATE int sqlite3Fts3VarintLen(sqlite3_uint64);\nSQLITE_PRIVATE void sqlite3Fts3Dequote(char *);\n\nSQLITE_PRIVATE char *sqlite3Fts3FindPositions(Fts3Expr *, sqlite3_int64, int);\nSQLITE_PRIVATE int sqlite3Fts3ExprLoadDoclist(Fts3Cursor *, Fts3Expr *);\nSQLITE_PRIVATE int sqlite3Fts3ExprLoadFtDoclist(Fts3Cursor *, Fts3Expr *, char **, int *);\nSQLITE_PRIVATE int sqlite3Fts3ExprNearTrim(Fts3Expr *, Fts3Expr *, int);\n\n/* fts3_tokenizer.c */\nSQLITE_PRIVATE const char *sqlite3Fts3NextToken(const char *, int *);\nSQLITE_PRIVATE int sqlite3Fts3InitHashTable(sqlite3 *, Fts3Hash *, const char *);\nSQLITE_PRIVATE int sqlite3Fts3InitTokenizer(Fts3Hash *pHash, const char *, \n    sqlite3_tokenizer **, char **\n);\nSQLITE_PRIVATE int sqlite3Fts3IsIdChar(char);\n\n/* fts3_snippet.c */\nSQLITE_PRIVATE void sqlite3Fts3Offsets(sqlite3_context*, Fts3Cursor*);\nSQLITE_PRIVATE void sqlite3Fts3Snippet(sqlite3_context *, Fts3Cursor *, const char *,\n  const char *, const char *, int, int\n);\nSQLITE_PRIVATE void sqlite3Fts3Matchinfo(sqlite3_context *, Fts3Cursor *, const char *);\n\n/* fts3_expr.c */\nSQLITE_PRIVATE int sqlite3Fts3ExprParse(sqlite3_tokenizer *, \n  char **, int, int, const char *, int, Fts3Expr **\n);\nSQLITE_PRIVATE void sqlite3Fts3ExprFree(Fts3Expr *);\n#ifdef SQLITE_TEST\nSQLITE_PRIVATE int sqlite3Fts3ExprInitTestInterface(sqlite3 *db);\n#endif\n\n/* fts3_aux.c */\nSQLITE_PRIVATE int sqlite3Fts3InitAux(sqlite3 *db);\n\n#endif /* _FTSINT_H */\n\n/************** End of fts3Int.h *********************************************/\n/************** Continuing where we left off in fts3.c ***********************/\n\n\n#ifndef SQLITE_CORE \n  SQLITE_EXTENSION_INIT1\n#endif\n\n/* \n** Write a 64-bit variable-length integer to memory starting at p[0].\n** The length of data written will be between 1 and FTS3_VARINT_MAX bytes.\n** The number of bytes written is returned.\n*/\nSQLITE_PRIVATE int sqlite3Fts3PutVarint(char *p, sqlite_int64 v){\n  unsigned char *q = (unsigned char *) p;\n  sqlite_uint64 vu = v;\n  do{\n    *q++ = (unsigned char) ((vu & 0x7f) | 0x80);\n    vu >>= 7;\n  }while( vu!=0 );\n  q[-1] &= 0x7f;  /* turn off high bit in final byte */\n  assert( q - (unsigned char *)p <= FTS3_VARINT_MAX );\n  return (int) (q - (unsigned char *)p);\n}\n\n/* \n** Read a 64-bit variable-length integer from memory starting at p[0].\n** Return the number of bytes read, or 0 on error.\n** The value is stored in *v.\n*/\nSQLITE_PRIVATE int sqlite3Fts3GetVarint(const char *p, sqlite_int64 *v){\n  const unsigned char *q = (const unsigned char *) p;\n  sqlite_uint64 x = 0, y = 1;\n  while( (*q&0x80)==0x80 && q-(unsigned char *)p<FTS3_VARINT_MAX ){\n    x += y * (*q++ & 0x7f);\n    y <<= 7;\n  }\n  x += y * (*q++);\n  *v = (sqlite_int64) x;\n  return (int) (q - (unsigned char *)p);\n}\n\n/*\n** Similar to sqlite3Fts3GetVarint(), except that the output is truncated to a\n** 32-bit integer before it is returned.\n*/\nSQLITE_PRIVATE int sqlite3Fts3GetVarint32(const char *p, int *pi){\n sqlite_int64 i;\n int ret = sqlite3Fts3GetVarint(p, &i);\n *pi = (int) i;\n return ret;\n}\n\n/*\n** Return the number of bytes required to encode v as a varint\n*/\nSQLITE_PRIVATE int sqlite3Fts3VarintLen(sqlite3_uint64 v){\n  int i = 0;\n  do{\n    i++;\n    v >>= 7;\n  }while( v!=0 );\n  return i;\n}\n\n/*\n** Convert an SQL-style quoted string into a normal string by removing\n** the quote characters.  The conversion is done in-place.  If the\n** input does not begin with a quote character, then this routine\n** is a no-op.\n**\n** Examples:\n**\n**     \"abc\"   becomes   abc\n**     'xyz'   becomes   xyz\n**     [pqr]   becomes   pqr\n**     `mno`   becomes   mno\n**\n*/\nSQLITE_PRIVATE void sqlite3Fts3Dequote(char *z){\n  char quote;                     /* Quote character (if any ) */\n\n  quote = z[0];\n  if( quote=='[' || quote=='\\'' || quote=='\"' || quote=='`' ){\n    int iIn = 1;                  /* Index of next byte to read from input */\n    int iOut = 0;                 /* Index of next byte to write to output */\n\n    /* If the first byte was a '[', then the close-quote character is a ']' */\n    if( quote=='[' ) quote = ']';  \n\n    while( ALWAYS(z[iIn]) ){\n      if( z[iIn]==quote ){\n        if( z[iIn+1]!=quote ) break;\n        z[iOut++] = quote;\n        iIn += 2;\n      }else{\n        z[iOut++] = z[iIn++];\n      }\n    }\n    z[iOut] = '\\0';\n  }\n}\n\n/*\n** Read a single varint from the doclist at *pp and advance *pp to point\n** to the first byte past the end of the varint.  Add the value of the varint\n** to *pVal.\n*/\nstatic void fts3GetDeltaVarint(char **pp, sqlite3_int64 *pVal){\n  sqlite3_int64 iVal;\n  *pp += sqlite3Fts3GetVarint(*pp, &iVal);\n  *pVal += iVal;\n}\n\n/*\n** As long as *pp has not reached its end (pEnd), then do the same\n** as fts3GetDeltaVarint(): read a single varint and add it to *pVal.\n** But if we have reached the end of the varint, just set *pp=0 and\n** leave *pVal unchanged.\n*/\nstatic void fts3GetDeltaVarint2(char **pp, char *pEnd, sqlite3_int64 *pVal){\n  if( *pp>=pEnd ){\n    *pp = 0;\n  }else{\n    fts3GetDeltaVarint(pp, pVal);\n  }\n}\n\n/*\n** The xDisconnect() virtual table method.\n*/\nstatic int fts3DisconnectMethod(sqlite3_vtab *pVtab){\n  Fts3Table *p = (Fts3Table *)pVtab;\n  int i;\n\n  assert( p->nPendingData==0 );\n  assert( p->pSegments==0 );\n\n  /* Free any prepared statements held */\n  for(i=0; i<SizeofArray(p->aStmt); i++){\n    sqlite3_finalize(p->aStmt[i]);\n  }\n  sqlite3_free(p->zSegmentsTbl);\n  sqlite3_free(p->zReadExprlist);\n  sqlite3_free(p->zWriteExprlist);\n\n  /* Invoke the tokenizer destructor to free the tokenizer. */\n  p->pTokenizer->pModule->xDestroy(p->pTokenizer);\n\n  sqlite3_free(p);\n  return SQLITE_OK;\n}\n\n/*\n** Construct one or more SQL statements from the format string given\n** and then evaluate those statements. The success code is written\n** into *pRc.\n**\n** If *pRc is initially non-zero then this routine is a no-op.\n*/\nstatic void fts3DbExec(\n  int *pRc,              /* Success code */\n  sqlite3 *db,           /* Database in which to run SQL */\n  const char *zFormat,   /* Format string for SQL */\n  ...                    /* Arguments to the format string */\n){\n  va_list ap;\n  char *zSql;\n  if( *pRc ) return;\n  va_start(ap, zFormat);\n  zSql = sqlite3_vmprintf(zFormat, ap);\n  va_end(ap);\n  if( zSql==0 ){\n    *pRc = SQLITE_NOMEM;\n  }else{\n    *pRc = sqlite3_exec(db, zSql, 0, 0, 0);\n    sqlite3_free(zSql);\n  }\n}\n\n/*\n** The xDestroy() virtual table method.\n*/\nstatic int fts3DestroyMethod(sqlite3_vtab *pVtab){\n  int rc = SQLITE_OK;              /* Return code */\n  Fts3Table *p = (Fts3Table *)pVtab;\n  sqlite3 *db = p->db;\n\n  /* Drop the shadow tables */\n  fts3DbExec(&rc, db, \"DROP TABLE IF EXISTS %Q.'%q_content'\", p->zDb, p->zName);\n  fts3DbExec(&rc, db, \"DROP TABLE IF EXISTS %Q.'%q_segments'\", p->zDb,p->zName);\n  fts3DbExec(&rc, db, \"DROP TABLE IF EXISTS %Q.'%q_segdir'\", p->zDb, p->zName);\n  fts3DbExec(&rc, db, \"DROP TABLE IF EXISTS %Q.'%q_docsize'\", p->zDb, p->zName);\n  fts3DbExec(&rc, db, \"DROP TABLE IF EXISTS %Q.'%q_stat'\", p->zDb, p->zName);\n\n  /* If everything has worked, invoke fts3DisconnectMethod() to free the\n  ** memory associated with the Fts3Table structure and return SQLITE_OK.\n  ** Otherwise, return an SQLite error code.\n  */\n  return (rc==SQLITE_OK ? fts3DisconnectMethod(pVtab) : rc);\n}\n\n\n/*\n** Invoke sqlite3_declare_vtab() to declare the schema for the FTS3 table\n** passed as the first argument. This is done as part of the xConnect()\n** and xCreate() methods.\n**\n** If *pRc is non-zero when this function is called, it is a no-op. \n** Otherwise, if an error occurs, an SQLite error code is stored in *pRc\n** before returning.\n*/\nstatic void fts3DeclareVtab(int *pRc, Fts3Table *p){\n  if( *pRc==SQLITE_OK ){\n    int i;                        /* Iterator variable */\n    int rc;                       /* Return code */\n    char *zSql;                   /* SQL statement passed to declare_vtab() */\n    char *zCols;                  /* List of user defined columns */\n\n    /* Create a list of user columns for the virtual table */\n    zCols = sqlite3_mprintf(\"%Q, \", p->azColumn[0]);\n    for(i=1; zCols && i<p->nColumn; i++){\n      zCols = sqlite3_mprintf(\"%z%Q, \", zCols, p->azColumn[i]);\n    }\n\n    /* Create the whole \"CREATE TABLE\" statement to pass to SQLite */\n    zSql = sqlite3_mprintf(\n        \"CREATE TABLE x(%s %Q HIDDEN, docid HIDDEN)\", zCols, p->zName\n    );\n    if( !zCols || !zSql ){\n      rc = SQLITE_NOMEM;\n    }else{\n      rc = sqlite3_declare_vtab(p->db, zSql);\n    }\n\n    sqlite3_free(zSql);\n    sqlite3_free(zCols);\n    *pRc = rc;\n  }\n}\n\n/*\n** Create the backing store tables (%_content, %_segments and %_segdir)\n** required by the FTS3 table passed as the only argument. This is done\n** as part of the vtab xCreate() method.\n**\n** If the p->bHasDocsize boolean is true (indicating that this is an\n** FTS4 table, not an FTS3 table) then also create the %_docsize and\n** %_stat tables required by FTS4.\n*/\nstatic int fts3CreateTables(Fts3Table *p){\n  int rc = SQLITE_OK;             /* Return code */\n  int i;                          /* Iterator variable */\n  char *zContentCols;             /* Columns of %_content table */\n  sqlite3 *db = p->db;            /* The database connection */\n\n  /* Create a list of user columns for the content table */\n  zContentCols = sqlite3_mprintf(\"docid INTEGER PRIMARY KEY\");\n  for(i=0; zContentCols && i<p->nColumn; i++){\n    char *z = p->azColumn[i];\n    zContentCols = sqlite3_mprintf(\"%z, 'c%d%q'\", zContentCols, i, z);\n  }\n  if( zContentCols==0 ) rc = SQLITE_NOMEM;\n\n  /* Create the content table */\n  fts3DbExec(&rc, db, \n     \"CREATE TABLE %Q.'%q_content'(%s)\",\n     p->zDb, p->zName, zContentCols\n  );\n  sqlite3_free(zContentCols);\n  /* Create other tables */\n  fts3DbExec(&rc, db, \n      \"CREATE TABLE %Q.'%q_segments'(blockid INTEGER PRIMARY KEY, block BLOB);\",\n      p->zDb, p->zName\n  );\n  fts3DbExec(&rc, db, \n      \"CREATE TABLE %Q.'%q_segdir'(\"\n        \"level INTEGER,\"\n        \"idx INTEGER,\"\n        \"start_block INTEGER,\"\n        \"leaves_end_block INTEGER,\"\n        \"end_block INTEGER,\"\n        \"root BLOB,\"\n        \"PRIMARY KEY(level, idx)\"\n      \");\",\n      p->zDb, p->zName\n  );\n  if( p->bHasDocsize ){\n    fts3DbExec(&rc, db, \n        \"CREATE TABLE %Q.'%q_docsize'(docid INTEGER PRIMARY KEY, size BLOB);\",\n        p->zDb, p->zName\n    );\n  }\n  if( p->bHasStat ){\n    fts3DbExec(&rc, db, \n        \"CREATE TABLE %Q.'%q_stat'(id INTEGER PRIMARY KEY, value BLOB);\",\n        p->zDb, p->zName\n    );\n  }\n  return rc;\n}\n\n/*\n** Store the current database page-size in bytes in p->nPgsz.\n**\n** If *pRc is non-zero when this function is called, it is a no-op. \n** Otherwise, if an error occurs, an SQLite error code is stored in *pRc\n** before returning.\n*/\nstatic void fts3DatabasePageSize(int *pRc, Fts3Table *p){\n  if( *pRc==SQLITE_OK ){\n    int rc;                       /* Return code */\n    char *zSql;                   /* SQL text \"PRAGMA %Q.page_size\" */\n    sqlite3_stmt *pStmt;          /* Compiled \"PRAGMA %Q.page_size\" statement */\n  \n    zSql = sqlite3_mprintf(\"PRAGMA %Q.page_size\", p->zDb);\n    if( !zSql ){\n      rc = SQLITE_NOMEM;\n    }else{\n      rc = sqlite3_prepare(p->db, zSql, -1, &pStmt, 0);\n      if( rc==SQLITE_OK ){\n        sqlite3_step(pStmt);\n        p->nPgsz = sqlite3_column_int(pStmt, 0);\n        rc = sqlite3_finalize(pStmt);\n      }\n    }\n    assert( p->nPgsz>0 || rc!=SQLITE_OK );\n    sqlite3_free(zSql);\n    *pRc = rc;\n  }\n}\n\n/*\n** \"Special\" FTS4 arguments are column specifications of the following form:\n**\n**   <key> = <value>\n**\n** There may not be whitespace surrounding the \"=\" character. The <value> \n** term may be quoted, but the <key> may not.\n*/\nstatic int fts3IsSpecialColumn(\n  const char *z, \n  int *pnKey,\n  char **pzValue\n){\n  char *zValue;\n  const char *zCsr = z;\n\n  while( *zCsr!='=' ){\n    if( *zCsr=='\\0' ) return 0;\n    zCsr++;\n  }\n\n  *pnKey = (int)(zCsr-z);\n  zValue = sqlite3_mprintf(\"%s\", &zCsr[1]);\n  if( zValue ){\n    sqlite3Fts3Dequote(zValue);\n  }\n  *pzValue = zValue;\n  return 1;\n}\n\n/*\n** Append the output of a printf() style formatting to an existing string.\n*/\nstatic void fts3Appendf(\n  int *pRc,                       /* IN/OUT: Error code */\n  char **pz,                      /* IN/OUT: Pointer to string buffer */\n  const char *zFormat,            /* Printf format string to append */\n  ...                             /* Arguments for printf format string */\n){\n  if( *pRc==SQLITE_OK ){\n    va_list ap;\n    char *z;\n    va_start(ap, zFormat);\n    z = sqlite3_vmprintf(zFormat, ap);\n    if( z && *pz ){\n      char *z2 = sqlite3_mprintf(\"%s%s\", *pz, z);\n      sqlite3_free(z);\n      z = z2;\n    }\n    if( z==0 ) *pRc = SQLITE_NOMEM;\n    sqlite3_free(*pz);\n    *pz = z;\n  }\n}\n\n/*\n** Return a copy of input string zInput enclosed in double-quotes (\") and\n** with all double quote characters escaped. For example:\n**\n**     fts3QuoteId(\"un \\\"zip\\\"\")   ->    \"un \\\"\\\"zip\\\"\\\"\"\n**\n** The pointer returned points to memory obtained from sqlite3_malloc(). It\n** is the callers responsibility to call sqlite3_free() to release this\n** memory.\n*/\nstatic char *fts3QuoteId(char const *zInput){\n  int nRet;\n  char *zRet;\n  nRet = 2 + strlen(zInput)*2 + 1;\n  zRet = sqlite3_malloc(nRet);\n  if( zRet ){\n    int i;\n    char *z = zRet;\n    *(z++) = '\"';\n    for(i=0; zInput[i]; i++){\n      if( zInput[i]=='\"' ) *(z++) = '\"';\n      *(z++) = zInput[i];\n    }\n    *(z++) = '\"';\n    *(z++) = '\\0';\n  }\n  return zRet;\n}\n\n/*\n** Return a list of comma separated SQL expressions that could be used\n** in a SELECT statement such as the following:\n**\n**     SELECT <list of expressions> FROM %_content AS x ...\n**\n** to return the docid, followed by each column of text data in order\n** from left to write. If parameter zFunc is not NULL, then instead of\n** being returned directly each column of text data is passed to an SQL\n** function named zFunc first. For example, if zFunc is \"unzip\" and the\n** table has the three user-defined columns \"a\", \"b\", and \"c\", the following\n** string is returned:\n**\n**     \"docid, unzip(x.'a'), unzip(x.'b'), unzip(x.'c')\"\n**\n** The pointer returned points to a buffer allocated by sqlite3_malloc(). It\n** is the responsibility of the caller to eventually free it.\n**\n** If *pRc is not SQLITE_OK when this function is called, it is a no-op (and\n** a NULL pointer is returned). Otherwise, if an OOM error is encountered\n** by this function, NULL is returned and *pRc is set to SQLITE_NOMEM. If\n** no error occurs, *pRc is left unmodified.\n*/\nstatic char *fts3ReadExprList(Fts3Table *p, const char *zFunc, int *pRc){\n  char *zRet = 0;\n  char *zFree = 0;\n  char *zFunction;\n  int i;\n\n  if( !zFunc ){\n    zFunction = \"\";\n  }else{\n    zFree = zFunction = fts3QuoteId(zFunc);\n  }\n  fts3Appendf(pRc, &zRet, \"docid\");\n  for(i=0; i<p->nColumn; i++){\n    fts3Appendf(pRc, &zRet, \",%s(x.'c%d%q')\", zFunction, i, p->azColumn[i]);\n  }\n  sqlite3_free(zFree);\n  return zRet;\n}\n\n/*\n** Return a list of N comma separated question marks, where N is the number\n** of columns in the %_content table (one for the docid plus one for each\n** user-defined text column).\n**\n** If argument zFunc is not NULL, then all but the first question mark\n** is preceded by zFunc and an open bracket, and followed by a closed\n** bracket. For example, if zFunc is \"zip\" and the FTS3 table has three \n** user-defined text columns, the following string is returned:\n**\n**     \"?, zip(?), zip(?), zip(?)\"\n**\n** The pointer returned points to a buffer allocated by sqlite3_malloc(). It\n** is the responsibility of the caller to eventually free it.\n**\n** If *pRc is not SQLITE_OK when this function is called, it is a no-op (and\n** a NULL pointer is returned). Otherwise, if an OOM error is encountered\n** by this function, NULL is returned and *pRc is set to SQLITE_NOMEM. If\n** no error occurs, *pRc is left unmodified.\n*/\nstatic char *fts3WriteExprList(Fts3Table *p, const char *zFunc, int *pRc){\n  char *zRet = 0;\n  char *zFree = 0;\n  char *zFunction;\n  int i;\n\n  if( !zFunc ){\n    zFunction = \"\";\n  }else{\n    zFree = zFunction = fts3QuoteId(zFunc);\n  }\n  fts3Appendf(pRc, &zRet, \"?\");\n  for(i=0; i<p->nColumn; i++){\n    fts3Appendf(pRc, &zRet, \",%s(?)\", zFunction);\n  }\n  sqlite3_free(zFree);\n  return zRet;\n}\n\n/*\n** This function is the implementation of both the xConnect and xCreate\n** methods of the FTS3 virtual table.\n**\n** The argv[] array contains the following:\n**\n**   argv[0]   -> module name  (\"fts3\" or \"fts4\")\n**   argv[1]   -> database name\n**   argv[2]   -> table name\n**   argv[...] -> \"column name\" and other module argument fields.\n*/\nstatic int fts3InitVtab(\n  int isCreate,                   /* True for xCreate, false for xConnect */\n  sqlite3 *db,                    /* The SQLite database connection */\n  void *pAux,                     /* Hash table containing tokenizers */\n  int argc,                       /* Number of elements in argv array */\n  const char * const *argv,       /* xCreate/xConnect argument array */\n  sqlite3_vtab **ppVTab,          /* Write the resulting vtab structure here */\n  char **pzErr                    /* Write any error message here */\n){\n  Fts3Hash *pHash = (Fts3Hash *)pAux;\n  Fts3Table *p = 0;               /* Pointer to allocated vtab */\n  int rc = SQLITE_OK;             /* Return code */\n  int i;                          /* Iterator variable */\n  int nByte;                      /* Size of allocation used for *p */\n  int iCol;                       /* Column index */\n  int nString = 0;                /* Bytes required to hold all column names */\n  int nCol = 0;                   /* Number of columns in the FTS table */\n  char *zCsr;                     /* Space for holding column names */\n  int nDb;                        /* Bytes required to hold database name */\n  int nName;                      /* Bytes required to hold table name */\n  int isFts4 = (argv[0][3]=='4'); /* True for FTS4, false for FTS3 */\n  int bNoDocsize = 0;             /* True to omit %_docsize table */\n  const char **aCol;              /* Array of column names */\n  sqlite3_tokenizer *pTokenizer = 0;        /* Tokenizer for this table */\n\n  char *zCompress = 0;\n  char *zUncompress = 0;\n\n  assert( strlen(argv[0])==4 );\n  assert( (sqlite3_strnicmp(argv[0], \"fts4\", 4)==0 && isFts4)\n       || (sqlite3_strnicmp(argv[0], \"fts3\", 4)==0 && !isFts4)\n  );\n\n  nDb = (int)strlen(argv[1]) + 1;\n  nName = (int)strlen(argv[2]) + 1;\n\n  aCol = (const char **)sqlite3_malloc(sizeof(const char *) * (argc-2) );\n  if( !aCol ) return SQLITE_NOMEM;\n  memset((void *)aCol, 0, sizeof(const char *) * (argc-2));\n\n  /* Loop through all of the arguments passed by the user to the FTS3/4\n  ** module (i.e. all the column names and special arguments). This loop\n  ** does the following:\n  **\n  **   + Figures out the number of columns the FTSX table will have, and\n  **     the number of bytes of space that must be allocated to store copies\n  **     of the column names.\n  **\n  **   + If there is a tokenizer specification included in the arguments,\n  **     initializes the tokenizer pTokenizer.\n  */\n  for(i=3; rc==SQLITE_OK && i<argc; i++){\n    char const *z = argv[i];\n    int nKey;\n    char *zVal;\n\n    /* Check if this is a tokenizer specification */\n    if( !pTokenizer \n     && strlen(z)>8\n     && 0==sqlite3_strnicmp(z, \"tokenize\", 8) \n     && 0==sqlite3Fts3IsIdChar(z[8])\n    ){\n      rc = sqlite3Fts3InitTokenizer(pHash, &z[9], &pTokenizer, pzErr);\n    }\n\n    /* Check if it is an FTS4 special argument. */\n    else if( isFts4 && fts3IsSpecialColumn(z, &nKey, &zVal) ){\n      if( !zVal ){\n        rc = SQLITE_NOMEM;\n        goto fts3_init_out;\n      }\n      if( nKey==9 && 0==sqlite3_strnicmp(z, \"matchinfo\", 9) ){\n        if( strlen(zVal)==4 && 0==sqlite3_strnicmp(zVal, \"fts3\", 4) ){\n          bNoDocsize = 1;\n        }else{\n          *pzErr = sqlite3_mprintf(\"unrecognized matchinfo: %s\", zVal);\n          rc = SQLITE_ERROR;\n        }\n      }else if( nKey==8 && 0==sqlite3_strnicmp(z, \"compress\", 8) ){\n        zCompress = zVal;\n        zVal = 0;\n      }else if( nKey==10 && 0==sqlite3_strnicmp(z, \"uncompress\", 10) ){\n        zUncompress = zVal;\n        zVal = 0;\n      }else{\n        *pzErr = sqlite3_mprintf(\"unrecognized parameter: %s\", z);\n        rc = SQLITE_ERROR;\n      }\n      sqlite3_free(zVal);\n    }\n\n    /* Otherwise, the argument is a column name. */\n    else {\n      nString += (int)(strlen(z) + 1);\n      aCol[nCol++] = z;\n    }\n  }\n  if( rc!=SQLITE_OK ) goto fts3_init_out;\n\n  if( nCol==0 ){\n    assert( nString==0 );\n    aCol[0] = \"content\";\n    nString = 8;\n    nCol = 1;\n  }\n\n  if( pTokenizer==0 ){\n    rc = sqlite3Fts3InitTokenizer(pHash, \"simple\", &pTokenizer, pzErr);\n    if( rc!=SQLITE_OK ) goto fts3_init_out;\n  }\n  assert( pTokenizer );\n\n\n  /* Allocate and populate the Fts3Table structure. */\n  nByte = sizeof(Fts3Table) +              /* Fts3Table */\n          nCol * sizeof(char *) +              /* azColumn */\n          nName +                              /* zName */\n          nDb +                                /* zDb */\n          nString;                             /* Space for azColumn strings */\n  p = (Fts3Table*)sqlite3_malloc(nByte);\n  if( p==0 ){\n    rc = SQLITE_NOMEM;\n    goto fts3_init_out;\n  }\n  memset(p, 0, nByte);\n  p->db = db;\n  p->nColumn = nCol;\n  p->nPendingData = 0;\n  p->azColumn = (char **)&p[1];\n  p->pTokenizer = pTokenizer;\n  p->nNodeSize = 1000;\n  p->nMaxPendingData = FTS3_MAX_PENDING_DATA;\n  p->bHasDocsize = (isFts4 && bNoDocsize==0);\n  p->bHasStat = isFts4;\n  fts3HashInit(&p->pendingTerms, FTS3_HASH_STRING, 1);\n\n  /* Fill in the zName and zDb fields of the vtab structure. */\n  zCsr = (char *)&p->azColumn[nCol];\n  p->zName = zCsr;\n  memcpy(zCsr, argv[2], nName);\n  zCsr += nName;\n  p->zDb = zCsr;\n  memcpy(zCsr, argv[1], nDb);\n  zCsr += nDb;\n\n  /* Fill in the azColumn array */\n  for(iCol=0; iCol<nCol; iCol++){\n    char *z; \n    int n;\n    z = (char *)sqlite3Fts3NextToken(aCol[iCol], &n);\n    memcpy(zCsr, z, n);\n    zCsr[n] = '\\0';\n    sqlite3Fts3Dequote(zCsr);\n    p->azColumn[iCol] = zCsr;\n    zCsr += n+1;\n    assert( zCsr <= &((char *)p)[nByte] );\n  }\n\n  if( (zCompress==0)!=(zUncompress==0) ){\n    char const *zMiss = (zCompress==0 ? \"compress\" : \"uncompress\");\n    rc = SQLITE_ERROR;\n    *pzErr = sqlite3_mprintf(\"missing %s parameter in fts4 constructor\", zMiss);\n  }\n  p->zReadExprlist = fts3ReadExprList(p, zUncompress, &rc);\n  p->zWriteExprlist = fts3WriteExprList(p, zCompress, &rc);\n  if( rc!=SQLITE_OK ) goto fts3_init_out;\n\n  /* If this is an xCreate call, create the underlying tables in the \n  ** database. TODO: For xConnect(), it could verify that said tables exist.\n  */\n  if( isCreate ){\n    rc = fts3CreateTables(p);\n  }\n\n  /* Figure out the page-size for the database. This is required in order to\n  ** estimate the cost of loading large doclists from the database (see \n  ** function sqlite3Fts3SegReaderCost() for details).\n  */\n  fts3DatabasePageSize(&rc, p);\n\n  /* Declare the table schema to SQLite. */\n  fts3DeclareVtab(&rc, p);\n\nfts3_init_out:\n  sqlite3_free(zCompress);\n  sqlite3_free(zUncompress);\n  sqlite3_free((void *)aCol);\n  if( rc!=SQLITE_OK ){\n    if( p ){\n      fts3DisconnectMethod((sqlite3_vtab *)p);\n    }else if( pTokenizer ){\n      pTokenizer->pModule->xDestroy(pTokenizer);\n    }\n  }else{\n    *ppVTab = &p->base;\n  }\n  return rc;\n}\n\n/*\n** The xConnect() and xCreate() methods for the virtual table. All the\n** work is done in function fts3InitVtab().\n*/\nstatic int fts3ConnectMethod(\n  sqlite3 *db,                    /* Database connection */\n  void *pAux,                     /* Pointer to tokenizer hash table */\n  int argc,                       /* Number of elements in argv array */\n  const char * const *argv,       /* xCreate/xConnect argument array */\n  sqlite3_vtab **ppVtab,          /* OUT: New sqlite3_vtab object */\n  char **pzErr                    /* OUT: sqlite3_malloc'd error message */\n){\n  return fts3InitVtab(0, db, pAux, argc, argv, ppVtab, pzErr);\n}\nstatic int fts3CreateMethod(\n  sqlite3 *db,                    /* Database connection */\n  void *pAux,                     /* Pointer to tokenizer hash table */\n  int argc,                       /* Number of elements in argv array */\n  const char * const *argv,       /* xCreate/xConnect argument array */\n  sqlite3_vtab **ppVtab,          /* OUT: New sqlite3_vtab object */\n  char **pzErr                    /* OUT: sqlite3_malloc'd error message */\n){\n  return fts3InitVtab(1, db, pAux, argc, argv, ppVtab, pzErr);\n}\n\n/* \n** Implementation of the xBestIndex method for FTS3 tables. There\n** are three possible strategies, in order of preference:\n**\n**   1. Direct lookup by rowid or docid. \n**   2. Full-text search using a MATCH operator on a non-docid column.\n**   3. Linear scan of %_content table.\n*/\nstatic int fts3BestIndexMethod(sqlite3_vtab *pVTab, sqlite3_index_info *pInfo){\n  Fts3Table *p = (Fts3Table *)pVTab;\n  int i;                          /* Iterator variable */\n  int iCons = -1;                 /* Index of constraint to use */\n\n  /* By default use a full table scan. This is an expensive option,\n  ** so search through the constraints to see if a more efficient \n  ** strategy is possible.\n  */\n  pInfo->idxNum = FTS3_FULLSCAN_SEARCH;\n  pInfo->estimatedCost = 500000;\n  for(i=0; i<pInfo->nConstraint; i++){\n    struct sqlite3_index_constraint *pCons = &pInfo->aConstraint[i];\n    if( pCons->usable==0 ) continue;\n\n    /* A direct lookup on the rowid or docid column. Assign a cost of 1.0. */\n    if( pCons->op==SQLITE_INDEX_CONSTRAINT_EQ \n     && (pCons->iColumn<0 || pCons->iColumn==p->nColumn+1 )\n    ){\n      pInfo->idxNum = FTS3_DOCID_SEARCH;\n      pInfo->estimatedCost = 1.0;\n      iCons = i;\n    }\n\n    /* A MATCH constraint. Use a full-text search.\n    **\n    ** If there is more than one MATCH constraint available, use the first\n    ** one encountered. If there is both a MATCH constraint and a direct\n    ** rowid/docid lookup, prefer the MATCH strategy. This is done even \n    ** though the rowid/docid lookup is faster than a MATCH query, selecting\n    ** it would lead to an \"unable to use function MATCH in the requested \n    ** context\" error.\n    */\n    if( pCons->op==SQLITE_INDEX_CONSTRAINT_MATCH \n     && pCons->iColumn>=0 && pCons->iColumn<=p->nColumn\n    ){\n      pInfo->idxNum = FTS3_FULLTEXT_SEARCH + pCons->iColumn;\n      pInfo->estimatedCost = 2.0;\n      iCons = i;\n      break;\n    }\n  }\n\n  if( iCons>=0 ){\n    pInfo->aConstraintUsage[iCons].argvIndex = 1;\n    pInfo->aConstraintUsage[iCons].omit = 1;\n  } \n  return SQLITE_OK;\n}\n\n/*\n** Implementation of xOpen method.\n*/\nstatic int fts3OpenMethod(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCsr){\n  sqlite3_vtab_cursor *pCsr;               /* Allocated cursor */\n\n  UNUSED_PARAMETER(pVTab);\n\n  /* Allocate a buffer large enough for an Fts3Cursor structure. If the\n  ** allocation succeeds, zero it and return SQLITE_OK. Otherwise, \n  ** if the allocation fails, return SQLITE_NOMEM.\n  */\n  *ppCsr = pCsr = (sqlite3_vtab_cursor *)sqlite3_malloc(sizeof(Fts3Cursor));\n  if( !pCsr ){\n    return SQLITE_NOMEM;\n  }\n  memset(pCsr, 0, sizeof(Fts3Cursor));\n  return SQLITE_OK;\n}\n\n/*\n** Close the cursor.  For additional information see the documentation\n** on the xClose method of the virtual table interface.\n*/\nstatic int fts3CloseMethod(sqlite3_vtab_cursor *pCursor){\n  Fts3Cursor *pCsr = (Fts3Cursor *)pCursor;\n  assert( ((Fts3Table *)pCsr->base.pVtab)->pSegments==0 );\n  sqlite3_finalize(pCsr->pStmt);\n  sqlite3Fts3ExprFree(pCsr->pExpr);\n  sqlite3Fts3FreeDeferredTokens(pCsr);\n  sqlite3_free(pCsr->aDoclist);\n  sqlite3_free(pCsr->aMatchinfo);\n  sqlite3_free(pCsr);\n  return SQLITE_OK;\n}\n\n/*\n** Position the pCsr->pStmt statement so that it is on the row\n** of the %_content table that contains the last match.  Return\n** SQLITE_OK on success.  \n*/\nstatic int fts3CursorSeek(sqlite3_context *pContext, Fts3Cursor *pCsr){\n  if( pCsr->isRequireSeek ){\n    pCsr->isRequireSeek = 0;\n    sqlite3_bind_int64(pCsr->pStmt, 1, pCsr->iPrevId);\n    if( SQLITE_ROW==sqlite3_step(pCsr->pStmt) ){\n      return SQLITE_OK;\n    }else{\n      int rc = sqlite3_reset(pCsr->pStmt);\n      if( rc==SQLITE_OK ){\n        /* If no row was found and no error has occured, then the %_content\n        ** table is missing a row that is present in the full-text index.\n        ** The data structures are corrupt.\n        */\n        rc = SQLITE_CORRUPT;\n      }\n      pCsr->isEof = 1;\n      if( pContext ){\n        sqlite3_result_error_code(pContext, rc);\n      }\n      return rc;\n    }\n  }else{\n    return SQLITE_OK;\n  }\n}\n\n/*\n** This function is used to process a single interior node when searching\n** a b-tree for a term or term prefix. The node data is passed to this \n** function via the zNode/nNode parameters. The term to search for is\n** passed in zTerm/nTerm.\n**\n** If piFirst is not NULL, then this function sets *piFirst to the blockid\n** of the child node that heads the sub-tree that may contain the term.\n**\n** If piLast is not NULL, then *piLast is set to the right-most child node\n** that heads a sub-tree that may contain a term for which zTerm/nTerm is\n** a prefix.\n**\n** If an OOM error occurs, SQLITE_NOMEM is returned. Otherwise, SQLITE_OK.\n*/\nstatic int fts3ScanInteriorNode(\n  const char *zTerm,              /* Term to select leaves for */\n  int nTerm,                      /* Size of term zTerm in bytes */\n  const char *zNode,              /* Buffer containing segment interior node */\n  int nNode,                      /* Size of buffer at zNode */\n  sqlite3_int64 *piFirst,         /* OUT: Selected child node */\n  sqlite3_int64 *piLast           /* OUT: Selected child node */\n){\n  int rc = SQLITE_OK;             /* Return code */\n  const char *zCsr = zNode;       /* Cursor to iterate through node */\n  const char *zEnd = &zCsr[nNode];/* End of interior node buffer */\n  char *zBuffer = 0;              /* Buffer to load terms into */\n  int nAlloc = 0;                 /* Size of allocated buffer */\n  int isFirstTerm = 1;            /* True when processing first term on page */\n  sqlite3_int64 iChild;           /* Block id of child node to descend to */\n\n  /* Skip over the 'height' varint that occurs at the start of every \n  ** interior node. Then load the blockid of the left-child of the b-tree\n  ** node into variable iChild.  \n  **\n  ** Even if the data structure on disk is corrupted, this (reading two\n  ** varints from the buffer) does not risk an overread. If zNode is a\n  ** root node, then the buffer comes from a SELECT statement. SQLite does\n  ** not make this guarantee explicitly, but in practice there are always\n  ** either more than 20 bytes of allocated space following the nNode bytes of\n  ** contents, or two zero bytes. Or, if the node is read from the %_segments\n  ** table, then there are always 20 bytes of zeroed padding following the\n  ** nNode bytes of content (see sqlite3Fts3ReadBlock() for details).\n  */\n  zCsr += sqlite3Fts3GetVarint(zCsr, &iChild);\n  zCsr += sqlite3Fts3GetVarint(zCsr, &iChild);\n  if( zCsr>zEnd ){\n    return SQLITE_CORRUPT;\n  }\n  \n  while( zCsr<zEnd && (piFirst || piLast) ){\n    int cmp;                      /* memcmp() result */\n    int nSuffix;                  /* Size of term suffix */\n    int nPrefix = 0;              /* Size of term prefix */\n    int nBuffer;                  /* Total term size */\n  \n    /* Load the next term on the node into zBuffer. Use realloc() to expand\n    ** the size of zBuffer if required.  */\n    if( !isFirstTerm ){\n      zCsr += sqlite3Fts3GetVarint32(zCsr, &nPrefix);\n    }\n    isFirstTerm = 0;\n    zCsr += sqlite3Fts3GetVarint32(zCsr, &nSuffix);\n    \n    if( nPrefix<0 || nSuffix<0 || &zCsr[nSuffix]>zEnd ){\n      rc = SQLITE_CORRUPT;\n      goto finish_scan;\n    }\n    if( nPrefix+nSuffix>nAlloc ){\n      char *zNew;\n      nAlloc = (nPrefix+nSuffix) * 2;\n      zNew = (char *)sqlite3_realloc(zBuffer, nAlloc);\n      if( !zNew ){\n        rc = SQLITE_NOMEM;\n        goto finish_scan;\n      }\n      zBuffer = zNew;\n    }\n    memcpy(&zBuffer[nPrefix], zCsr, nSuffix);\n    nBuffer = nPrefix + nSuffix;\n    zCsr += nSuffix;\n\n    /* Compare the term we are searching for with the term just loaded from\n    ** the interior node. If the specified term is greater than or equal\n    ** to the term from the interior node, then all terms on the sub-tree \n    ** headed by node iChild are smaller than zTerm. No need to search \n    ** iChild.\n    **\n    ** If the interior node term is larger than the specified term, then\n    ** the tree headed by iChild may contain the specified term.\n    */\n    cmp = memcmp(zTerm, zBuffer, (nBuffer>nTerm ? nTerm : nBuffer));\n    if( piFirst && (cmp<0 || (cmp==0 && nBuffer>nTerm)) ){\n      *piFirst = iChild;\n      piFirst = 0;\n    }\n\n    if( piLast && cmp<0 ){\n      *piLast = iChild;\n      piLast = 0;\n    }\n\n    iChild++;\n  };\n\n  if( piFirst ) *piFirst = iChild;\n  if( piLast ) *piLast = iChild;\n\n finish_scan:\n  sqlite3_free(zBuffer);\n  return rc;\n}\n\n\n/*\n** The buffer pointed to by argument zNode (size nNode bytes) contains an\n** interior node of a b-tree segment. The zTerm buffer (size nTerm bytes)\n** contains a term. This function searches the sub-tree headed by the zNode\n** node for the range of leaf nodes that may contain the specified term\n** or terms for which the specified term is a prefix.\n**\n** If piLeaf is not NULL, then *piLeaf is set to the blockid of the \n** left-most leaf node in the tree that may contain the specified term.\n** If piLeaf2 is not NULL, then *piLeaf2 is set to the blockid of the\n** right-most leaf node that may contain a term for which the specified\n** term is a prefix.\n**\n** It is possible that the range of returned leaf nodes does not contain \n** the specified term or any terms for which it is a prefix. However, if the \n** segment does contain any such terms, they are stored within the identified\n** range. Because this function only inspects interior segment nodes (and\n** never loads leaf nodes into memory), it is not possible to be sure.\n**\n** If an error occurs, an error code other than SQLITE_OK is returned.\n*/ \nstatic int fts3SelectLeaf(\n  Fts3Table *p,                   /* Virtual table handle */\n  const char *zTerm,              /* Term to select leaves for */\n  int nTerm,                      /* Size of term zTerm in bytes */\n  const char *zNode,              /* Buffer containing segment interior node */\n  int nNode,                      /* Size of buffer at zNode */\n  sqlite3_int64 *piLeaf,          /* Selected leaf node */\n  sqlite3_int64 *piLeaf2          /* Selected leaf node */\n){\n  int rc;                         /* Return code */\n  int iHeight;                    /* Height of this node in tree */\n\n  assert( piLeaf || piLeaf2 );\n\n  sqlite3Fts3GetVarint32(zNode, &iHeight);\n  rc = fts3ScanInteriorNode(zTerm, nTerm, zNode, nNode, piLeaf, piLeaf2);\n  assert( !piLeaf2 || !piLeaf || rc!=SQLITE_OK || (*piLeaf<=*piLeaf2) );\n\n  if( rc==SQLITE_OK && iHeight>1 ){\n    char *zBlob = 0;              /* Blob read from %_segments table */\n    int nBlob;                    /* Size of zBlob in bytes */\n\n    if( piLeaf && piLeaf2 && (*piLeaf!=*piLeaf2) ){\n      rc = sqlite3Fts3ReadBlock(p, *piLeaf, &zBlob, &nBlob);\n      if( rc==SQLITE_OK ){\n        rc = fts3SelectLeaf(p, zTerm, nTerm, zBlob, nBlob, piLeaf, 0);\n      }\n      sqlite3_free(zBlob);\n      piLeaf = 0;\n      zBlob = 0;\n    }\n\n    if( rc==SQLITE_OK ){\n      rc = sqlite3Fts3ReadBlock(p, piLeaf ? *piLeaf : *piLeaf2, &zBlob, &nBlob);\n    }\n    if( rc==SQLITE_OK ){\n      rc = fts3SelectLeaf(p, zTerm, nTerm, zBlob, nBlob, piLeaf, piLeaf2);\n    }\n    sqlite3_free(zBlob);\n  }\n\n  return rc;\n}\n\n/*\n** This function is used to create delta-encoded serialized lists of FTS3 \n** varints. Each call to this function appends a single varint to a list.\n*/\nstatic void fts3PutDeltaVarint(\n  char **pp,                      /* IN/OUT: Output pointer */\n  sqlite3_int64 *piPrev,          /* IN/OUT: Previous value written to list */\n  sqlite3_int64 iVal              /* Write this value to the list */\n){\n  assert( iVal-*piPrev > 0 || (*piPrev==0 && iVal==0) );\n  *pp += sqlite3Fts3PutVarint(*pp, iVal-*piPrev);\n  *piPrev = iVal;\n}\n\n/*\n** When this function is called, *ppPoslist is assumed to point to the \n** start of a position-list. After it returns, *ppPoslist points to the\n** first byte after the position-list.\n**\n** A position list is list of positions (delta encoded) and columns for \n** a single document record of a doclist.  So, in other words, this\n** routine advances *ppPoslist so that it points to the next docid in\n** the doclist, or to the first byte past the end of the doclist.\n**\n** If pp is not NULL, then the contents of the position list are copied\n** to *pp. *pp is set to point to the first byte past the last byte copied\n** before this function returns.\n*/\nstatic void fts3PoslistCopy(char **pp, char **ppPoslist){\n  char *pEnd = *ppPoslist;\n  char c = 0;\n\n  /* The end of a position list is marked by a zero encoded as an FTS3 \n  ** varint. A single POS_END (0) byte. Except, if the 0 byte is preceded by\n  ** a byte with the 0x80 bit set, then it is not a varint 0, but the tail\n  ** of some other, multi-byte, value.\n  **\n  ** The following while-loop moves pEnd to point to the first byte that is not \n  ** immediately preceded by a byte with the 0x80 bit set. Then increments\n  ** pEnd once more so that it points to the byte immediately following the\n  ** last byte in the position-list.\n  */\n  while( *pEnd | c ){\n    c = *pEnd++ & 0x80;\n    testcase( c!=0 && (*pEnd)==0 );\n  }\n  pEnd++;  /* Advance past the POS_END terminator byte */\n\n  if( pp ){\n    int n = (int)(pEnd - *ppPoslist);\n    char *p = *pp;\n    memcpy(p, *ppPoslist, n);\n    p += n;\n    *pp = p;\n  }\n  *ppPoslist = pEnd;\n}\n\n/*\n** When this function is called, *ppPoslist is assumed to point to the \n** start of a column-list. After it returns, *ppPoslist points to the\n** to the terminator (POS_COLUMN or POS_END) byte of the column-list.\n**\n** A column-list is list of delta-encoded positions for a single column\n** within a single document within a doclist.\n**\n** The column-list is terminated either by a POS_COLUMN varint (1) or\n** a POS_END varint (0).  This routine leaves *ppPoslist pointing to\n** the POS_COLUMN or POS_END that terminates the column-list.\n**\n** If pp is not NULL, then the contents of the column-list are copied\n** to *pp. *pp is set to point to the first byte past the last byte copied\n** before this function returns.  The POS_COLUMN or POS_END terminator\n** is not copied into *pp.\n*/\nstatic void fts3ColumnlistCopy(char **pp, char **ppPoslist){\n  char *pEnd = *ppPoslist;\n  char c = 0;\n\n  /* A column-list is terminated by either a 0x01 or 0x00 byte that is\n  ** not part of a multi-byte varint.\n  */\n  while( 0xFE & (*pEnd | c) ){\n    c = *pEnd++ & 0x80;\n    testcase( c!=0 && ((*pEnd)&0xfe)==0 );\n  }\n  if( pp ){\n    int n = (int)(pEnd - *ppPoslist);\n    char *p = *pp;\n    memcpy(p, *ppPoslist, n);\n    p += n;\n    *pp = p;\n  }\n  *ppPoslist = pEnd;\n}\n\n/*\n** Value used to signify the end of an position-list. This is safe because\n** it is not possible to have a document with 2^31 terms.\n*/\n#define POSITION_LIST_END 0x7fffffff\n\n/*\n** This function is used to help parse position-lists. When this function is\n** called, *pp may point to the start of the next varint in the position-list\n** being parsed, or it may point to 1 byte past the end of the position-list\n** (in which case **pp will be a terminator bytes POS_END (0) or\n** (1)).\n**\n** If *pp points past the end of the current position-list, set *pi to \n** POSITION_LIST_END and return. Otherwise, read the next varint from *pp,\n** increment the current value of *pi by the value read, and set *pp to\n** point to the next value before returning.\n**\n** Before calling this routine *pi must be initialized to the value of\n** the previous position, or zero if we are reading the first position\n** in the position-list.  Because positions are delta-encoded, the value\n** of the previous position is needed in order to compute the value of\n** the next position.\n*/\nstatic void fts3ReadNextPos(\n  char **pp,                    /* IN/OUT: Pointer into position-list buffer */\n  sqlite3_int64 *pi             /* IN/OUT: Value read from position-list */\n){\n  if( (**pp)&0xFE ){\n    fts3GetDeltaVarint(pp, pi);\n    *pi -= 2;\n  }else{\n    *pi = POSITION_LIST_END;\n  }\n}\n\n/*\n** If parameter iCol is not 0, write an POS_COLUMN (1) byte followed by\n** the value of iCol encoded as a varint to *pp.   This will start a new\n** column list.\n**\n** Set *pp to point to the byte just after the last byte written before \n** returning (do not modify it if iCol==0). Return the total number of bytes\n** written (0 if iCol==0).\n*/\nstatic int fts3PutColNumber(char **pp, int iCol){\n  int n = 0;                      /* Number of bytes written */\n  if( iCol ){\n    char *p = *pp;                /* Output pointer */\n    n = 1 + sqlite3Fts3PutVarint(&p[1], iCol);\n    *p = 0x01;\n    *pp = &p[n];\n  }\n  return n;\n}\n\n/*\n** Compute the union of two position lists.  The output written\n** into *pp contains all positions of both *pp1 and *pp2 in sorted\n** order and with any duplicates removed.  All pointers are\n** updated appropriately.   The caller is responsible for insuring\n** that there is enough space in *pp to hold the complete output.\n*/\nstatic void fts3PoslistMerge(\n  char **pp,                      /* Output buffer */\n  char **pp1,                     /* Left input list */\n  char **pp2                      /* Right input list */\n){\n  char *p = *pp;\n  char *p1 = *pp1;\n  char *p2 = *pp2;\n\n  while( *p1 || *p2 ){\n    int iCol1;         /* The current column index in pp1 */\n    int iCol2;         /* The current column index in pp2 */\n\n    if( *p1==POS_COLUMN ) sqlite3Fts3GetVarint32(&p1[1], &iCol1);\n    else if( *p1==POS_END ) iCol1 = POSITION_LIST_END;\n    else iCol1 = 0;\n\n    if( *p2==POS_COLUMN ) sqlite3Fts3GetVarint32(&p2[1], &iCol2);\n    else if( *p2==POS_END ) iCol2 = POSITION_LIST_END;\n    else iCol2 = 0;\n\n    if( iCol1==iCol2 ){\n      sqlite3_int64 i1 = 0;       /* Last position from pp1 */\n      sqlite3_int64 i2 = 0;       /* Last position from pp2 */\n      sqlite3_int64 iPrev = 0;\n      int n = fts3PutColNumber(&p, iCol1);\n      p1 += n;\n      p2 += n;\n\n      /* At this point, both p1 and p2 point to the start of column-lists\n      ** for the same column (the column with index iCol1 and iCol2).\n      ** A column-list is a list of non-negative delta-encoded varints, each \n      ** incremented by 2 before being stored. Each list is terminated by a\n      ** POS_END (0) or POS_COLUMN (1). The following block merges the two lists\n      ** and writes the results to buffer p. p is left pointing to the byte\n      ** after the list written. No terminator (POS_END or POS_COLUMN) is\n      ** written to the output.\n      */\n      fts3GetDeltaVarint(&p1, &i1);\n      fts3GetDeltaVarint(&p2, &i2);\n      do {\n        fts3PutDeltaVarint(&p, &iPrev, (i1<i2) ? i1 : i2); \n        iPrev -= 2;\n        if( i1==i2 ){\n          fts3ReadNextPos(&p1, &i1);\n          fts3ReadNextPos(&p2, &i2);\n        }else if( i1<i2 ){\n          fts3ReadNextPos(&p1, &i1);\n        }else{\n          fts3ReadNextPos(&p2, &i2);\n        }\n      }while( i1!=POSITION_LIST_END || i2!=POSITION_LIST_END );\n    }else if( iCol1<iCol2 ){\n      p1 += fts3PutColNumber(&p, iCol1);\n      fts3ColumnlistCopy(&p, &p1);\n    }else{\n      p2 += fts3PutColNumber(&p, iCol2);\n      fts3ColumnlistCopy(&p, &p2);\n    }\n  }\n\n  *p++ = POS_END;\n  *pp = p;\n  *pp1 = p1 + 1;\n  *pp2 = p2 + 1;\n}\n\n/*\n** nToken==1 searches for adjacent positions.\n**\n** This function is used to merge two position lists into one. When it is\n** called, *pp1 and *pp2 must both point to position lists. A position-list is\n** the part of a doclist that follows each document id. For example, if a row\n** contains:\n**\n**     'a b c'|'x y z'|'a b b a'\n**\n** Then the position list for this row for token 'b' would consist of:\n**\n**     0x02 0x01 0x02 0x03 0x03 0x00\n**\n** When this function returns, both *pp1 and *pp2 are left pointing to the\n** byte following the 0x00 terminator of their respective position lists.\n**\n** If isSaveLeft is 0, an entry is added to the output position list for \n** each position in *pp2 for which there exists one or more positions in\n** *pp1 so that (pos(*pp2)>pos(*pp1) && pos(*pp2)-pos(*pp1)<=nToken). i.e.\n** when the *pp1 token appears before the *pp2 token, but not more than nToken\n** slots before it.\n*/\nstatic int fts3PoslistPhraseMerge(\n  char **pp,                      /* IN/OUT: Preallocated output buffer */\n  int nToken,                     /* Maximum difference in token positions */\n  int isSaveLeft,                 /* Save the left position */\n  int isExact,                    /* If *pp1 is exactly nTokens before *pp2 */\n  char **pp1,                     /* IN/OUT: Left input list */\n  char **pp2                      /* IN/OUT: Right input list */\n){\n  char *p = (pp ? *pp : 0);\n  char *p1 = *pp1;\n  char *p2 = *pp2;\n  int iCol1 = 0;\n  int iCol2 = 0;\n\n  /* Never set both isSaveLeft and isExact for the same invocation. */\n  assert( isSaveLeft==0 || isExact==0 );\n\n  assert( *p1!=0 && *p2!=0 );\n  if( *p1==POS_COLUMN ){ \n    p1++;\n    p1 += sqlite3Fts3GetVarint32(p1, &iCol1);\n  }\n  if( *p2==POS_COLUMN ){ \n    p2++;\n    p2 += sqlite3Fts3GetVarint32(p2, &iCol2);\n  }\n\n  while( 1 ){\n    if( iCol1==iCol2 ){\n      char *pSave = p;\n      sqlite3_int64 iPrev = 0;\n      sqlite3_int64 iPos1 = 0;\n      sqlite3_int64 iPos2 = 0;\n\n      if( pp && iCol1 ){\n        *p++ = POS_COLUMN;\n        p += sqlite3Fts3PutVarint(p, iCol1);\n      }\n\n      assert( *p1!=POS_END && *p1!=POS_COLUMN );\n      assert( *p2!=POS_END && *p2!=POS_COLUMN );\n      fts3GetDeltaVarint(&p1, &iPos1); iPos1 -= 2;\n      fts3GetDeltaVarint(&p2, &iPos2); iPos2 -= 2;\n\n      while( 1 ){\n        if( iPos2==iPos1+nToken \n         || (isExact==0 && iPos2>iPos1 && iPos2<=iPos1+nToken) \n        ){\n          sqlite3_int64 iSave;\n          if( !pp ){\n            fts3PoslistCopy(0, &p2);\n            fts3PoslistCopy(0, &p1);\n            *pp1 = p1;\n            *pp2 = p2;\n            return 1;\n          }\n          iSave = isSaveLeft ? iPos1 : iPos2;\n          fts3PutDeltaVarint(&p, &iPrev, iSave+2); iPrev -= 2;\n          pSave = 0;\n        }\n        if( (!isSaveLeft && iPos2<=(iPos1+nToken)) || iPos2<=iPos1 ){\n          if( (*p2&0xFE)==0 ) break;\n          fts3GetDeltaVarint(&p2, &iPos2); iPos2 -= 2;\n        }else{\n          if( (*p1&0xFE)==0 ) break;\n          fts3GetDeltaVarint(&p1, &iPos1); iPos1 -= 2;\n        }\n      }\n\n      if( pSave ){\n        assert( pp && p );\n        p = pSave;\n      }\n\n      fts3ColumnlistCopy(0, &p1);\n      fts3ColumnlistCopy(0, &p2);\n      assert( (*p1&0xFE)==0 && (*p2&0xFE)==0 );\n      if( 0==*p1 || 0==*p2 ) break;\n\n      p1++;\n      p1 += sqlite3Fts3GetVarint32(p1, &iCol1);\n      p2++;\n      p2 += sqlite3Fts3GetVarint32(p2, &iCol2);\n    }\n\n    /* Advance pointer p1 or p2 (whichever corresponds to the smaller of\n    ** iCol1 and iCol2) so that it points to either the 0x00 that marks the\n    ** end of the position list, or the 0x01 that precedes the next \n    ** column-number in the position list. \n    */\n    else if( iCol1<iCol2 ){\n      fts3ColumnlistCopy(0, &p1);\n      if( 0==*p1 ) break;\n      p1++;\n      p1 += sqlite3Fts3GetVarint32(p1, &iCol1);\n    }else{\n      fts3ColumnlistCopy(0, &p2);\n      if( 0==*p2 ) break;\n      p2++;\n      p2 += sqlite3Fts3GetVarint32(p2, &iCol2);\n    }\n  }\n\n  fts3PoslistCopy(0, &p2);\n  fts3PoslistCopy(0, &p1);\n  *pp1 = p1;\n  *pp2 = p2;\n  if( !pp || *pp==p ){\n    return 0;\n  }\n  *p++ = 0x00;\n  *pp = p;\n  return 1;\n}\n\n/*\n** Merge two position-lists as required by the NEAR operator.\n*/\nstatic int fts3PoslistNearMerge(\n  char **pp,                      /* Output buffer */\n  char *aTmp,                     /* Temporary buffer space */\n  int nRight,                     /* Maximum difference in token positions */\n  int nLeft,                      /* Maximum difference in token positions */\n  char **pp1,                     /* IN/OUT: Left input list */\n  char **pp2                      /* IN/OUT: Right input list */\n){\n  char *p1 = *pp1;\n  char *p2 = *pp2;\n\n  if( !pp ){\n    if( fts3PoslistPhraseMerge(0, nRight, 0, 0, pp1, pp2) ) return 1;\n    *pp1 = p1;\n    *pp2 = p2;\n    return fts3PoslistPhraseMerge(0, nLeft, 0, 0, pp2, pp1);\n  }else{\n    char *pTmp1 = aTmp;\n    char *pTmp2;\n    char *aTmp2;\n    int res = 1;\n\n    fts3PoslistPhraseMerge(&pTmp1, nRight, 0, 0, pp1, pp2);\n    aTmp2 = pTmp2 = pTmp1;\n    *pp1 = p1;\n    *pp2 = p2;\n    fts3PoslistPhraseMerge(&pTmp2, nLeft, 1, 0, pp2, pp1);\n    if( pTmp1!=aTmp && pTmp2!=aTmp2 ){\n      fts3PoslistMerge(pp, &aTmp, &aTmp2);\n    }else if( pTmp1!=aTmp ){\n      fts3PoslistCopy(pp, &aTmp);\n    }else if( pTmp2!=aTmp2 ){\n      fts3PoslistCopy(pp, &aTmp2);\n    }else{\n      res = 0;\n    }\n\n    return res;\n  }\n}\n\n/*\n** Values that may be used as the first parameter to fts3DoclistMerge().\n*/\n#define MERGE_NOT        2        /* D + D -> D */\n#define MERGE_AND        3        /* D + D -> D */\n#define MERGE_OR         4        /* D + D -> D */\n#define MERGE_POS_OR     5        /* P + P -> P */\n#define MERGE_PHRASE     6        /* P + P -> D */\n#define MERGE_POS_PHRASE 7        /* P + P -> P */\n#define MERGE_NEAR       8        /* P + P -> D */\n#define MERGE_POS_NEAR   9        /* P + P -> P */\n\n/*\n** Merge the two doclists passed in buffer a1 (size n1 bytes) and a2\n** (size n2 bytes). The output is written to pre-allocated buffer aBuffer,\n** which is guaranteed to be large enough to hold the results. The number\n** of bytes written to aBuffer is stored in *pnBuffer before returning.\n**\n** If successful, SQLITE_OK is returned. Otherwise, if a malloc error\n** occurs while allocating a temporary buffer as part of the merge operation,\n** SQLITE_NOMEM is returned.\n*/\nstatic int fts3DoclistMerge(\n  int mergetype,                  /* One of the MERGE_XXX constants */\n  int nParam1,                    /* Used by MERGE_NEAR and MERGE_POS_NEAR */\n  int nParam2,                    /* Used by MERGE_NEAR and MERGE_POS_NEAR */\n  char *aBuffer,                  /* Pre-allocated output buffer */\n  int *pnBuffer,                  /* OUT: Bytes written to aBuffer */\n  char *a1,                       /* Buffer containing first doclist */\n  int n1,                         /* Size of buffer a1 */\n  char *a2,                       /* Buffer containing second doclist */\n  int n2,                         /* Size of buffer a2 */\n  int *pnDoc                      /* OUT: Number of docids in output */\n){\n  sqlite3_int64 i1 = 0;\n  sqlite3_int64 i2 = 0;\n  sqlite3_int64 iPrev = 0;\n\n  char *p = aBuffer;\n  char *p1 = a1;\n  char *p2 = a2;\n  char *pEnd1 = &a1[n1];\n  char *pEnd2 = &a2[n2];\n  int nDoc = 0;\n\n  assert( mergetype==MERGE_OR     || mergetype==MERGE_POS_OR \n       || mergetype==MERGE_AND    || mergetype==MERGE_NOT\n       || mergetype==MERGE_PHRASE || mergetype==MERGE_POS_PHRASE\n       || mergetype==MERGE_NEAR   || mergetype==MERGE_POS_NEAR\n  );\n\n  if( !aBuffer ){\n    *pnBuffer = 0;\n    return SQLITE_NOMEM;\n  }\n\n  /* Read the first docid from each doclist */\n  fts3GetDeltaVarint2(&p1, pEnd1, &i1);\n  fts3GetDeltaVarint2(&p2, pEnd2, &i2);\n\n  switch( mergetype ){\n    case MERGE_OR:\n    case MERGE_POS_OR:\n      while( p1 || p2 ){\n        if( p2 && p1 && i1==i2 ){\n          fts3PutDeltaVarint(&p, &iPrev, i1);\n          if( mergetype==MERGE_POS_OR ) fts3PoslistMerge(&p, &p1, &p2);\n          fts3GetDeltaVarint2(&p1, pEnd1, &i1);\n          fts3GetDeltaVarint2(&p2, pEnd2, &i2);\n        }else if( !p2 || (p1 && i1<i2) ){\n          fts3PutDeltaVarint(&p, &iPrev, i1);\n          if( mergetype==MERGE_POS_OR ) fts3PoslistCopy(&p, &p1);\n          fts3GetDeltaVarint2(&p1, pEnd1, &i1);\n        }else{\n          fts3PutDeltaVarint(&p, &iPrev, i2);\n          if( mergetype==MERGE_POS_OR ) fts3PoslistCopy(&p, &p2);\n          fts3GetDeltaVarint2(&p2, pEnd2, &i2);\n        }\n      }\n      break;\n\n    case MERGE_AND:\n      while( p1 && p2 ){\n        if( i1==i2 ){\n          fts3PutDeltaVarint(&p, &iPrev, i1);\n          fts3GetDeltaVarint2(&p1, pEnd1, &i1);\n          fts3GetDeltaVarint2(&p2, pEnd2, &i2);\n          nDoc++;\n        }else if( i1<i2 ){\n          fts3GetDeltaVarint2(&p1, pEnd1, &i1);\n        }else{\n          fts3GetDeltaVarint2(&p2, pEnd2, &i2);\n        }\n      }\n      break;\n\n    case MERGE_NOT:\n      while( p1 ){\n        if( p2 && i1==i2 ){\n          fts3GetDeltaVarint2(&p1, pEnd1, &i1);\n          fts3GetDeltaVarint2(&p2, pEnd2, &i2);\n        }else if( !p2 || i1<i2 ){\n          fts3PutDeltaVarint(&p, &iPrev, i1);\n          fts3GetDeltaVarint2(&p1, pEnd1, &i1);\n        }else{\n          fts3GetDeltaVarint2(&p2, pEnd2, &i2);\n        }\n      }\n      break;\n\n    case MERGE_POS_PHRASE:\n    case MERGE_PHRASE: {\n      char **ppPos = (mergetype==MERGE_PHRASE ? 0 : &p);\n      while( p1 && p2 ){\n        if( i1==i2 ){\n          char *pSave = p;\n          sqlite3_int64 iPrevSave = iPrev;\n          fts3PutDeltaVarint(&p, &iPrev, i1);\n          if( 0==fts3PoslistPhraseMerge(ppPos, nParam1, 0, 1, &p1, &p2) ){\n            p = pSave;\n            iPrev = iPrevSave;\n          }else{\n            nDoc++;\n          }\n          fts3GetDeltaVarint2(&p1, pEnd1, &i1);\n          fts3GetDeltaVarint2(&p2, pEnd2, &i2);\n        }else if( i1<i2 ){\n          fts3PoslistCopy(0, &p1);\n          fts3GetDeltaVarint2(&p1, pEnd1, &i1);\n        }else{\n          fts3PoslistCopy(0, &p2);\n          fts3GetDeltaVarint2(&p2, pEnd2, &i2);\n        }\n      }\n      break;\n    }\n\n    default: assert( mergetype==MERGE_POS_NEAR || mergetype==MERGE_NEAR ); {\n      char *aTmp = 0;\n      char **ppPos = 0;\n\n      if( mergetype==MERGE_POS_NEAR ){\n        ppPos = &p;\n        aTmp = sqlite3_malloc(2*(n1+n2+1));\n        if( !aTmp ){\n          return SQLITE_NOMEM;\n        }\n      }\n\n      while( p1 && p2 ){\n        if( i1==i2 ){\n          char *pSave = p;\n          sqlite3_int64 iPrevSave = iPrev;\n          fts3PutDeltaVarint(&p, &iPrev, i1);\n\n          if( !fts3PoslistNearMerge(ppPos, aTmp, nParam1, nParam2, &p1, &p2) ){\n            iPrev = iPrevSave;\n            p = pSave;\n          }\n\n          fts3GetDeltaVarint2(&p1, pEnd1, &i1);\n          fts3GetDeltaVarint2(&p2, pEnd2, &i2);\n        }else if( i1<i2 ){\n          fts3PoslistCopy(0, &p1);\n          fts3GetDeltaVarint2(&p1, pEnd1, &i1);\n        }else{\n          fts3PoslistCopy(0, &p2);\n          fts3GetDeltaVarint2(&p2, pEnd2, &i2);\n        }\n      }\n      sqlite3_free(aTmp);\n      break;\n    }\n  }\n\n  if( pnDoc ) *pnDoc = nDoc;\n  *pnBuffer = (int)(p-aBuffer);\n  return SQLITE_OK;\n}\n\n/* \n** A pointer to an instance of this structure is used as the context \n** argument to sqlite3Fts3SegReaderIterate()\n*/\ntypedef struct TermSelect TermSelect;\nstruct TermSelect {\n  int isReqPos;\n  char *aaOutput[16];             /* Malloc'd output buffer */\n  int anOutput[16];               /* Size of output in bytes */\n};\n\n/*\n** Merge all doclists in the TermSelect.aaOutput[] array into a single\n** doclist stored in TermSelect.aaOutput[0]. If successful, delete all\n** other doclists (except the aaOutput[0] one) and return SQLITE_OK.\n**\n** If an OOM error occurs, return SQLITE_NOMEM. In this case it is\n** the responsibility of the caller to free any doclists left in the\n** TermSelect.aaOutput[] array.\n*/\nstatic int fts3TermSelectMerge(TermSelect *pTS){\n  int mergetype = (pTS->isReqPos ? MERGE_POS_OR : MERGE_OR);\n  char *aOut = 0;\n  int nOut = 0;\n  int i;\n\n  /* Loop through the doclists in the aaOutput[] array. Merge them all\n  ** into a single doclist.\n  */\n  for(i=0; i<SizeofArray(pTS->aaOutput); i++){\n    if( pTS->aaOutput[i] ){\n      if( !aOut ){\n        aOut = pTS->aaOutput[i];\n        nOut = pTS->anOutput[i];\n        pTS->aaOutput[i] = 0;\n      }else{\n        int nNew = nOut + pTS->anOutput[i];\n        char *aNew = sqlite3_malloc(nNew);\n        if( !aNew ){\n          sqlite3_free(aOut);\n          return SQLITE_NOMEM;\n        }\n        fts3DoclistMerge(mergetype, 0, 0,\n            aNew, &nNew, pTS->aaOutput[i], pTS->anOutput[i], aOut, nOut, 0\n        );\n        sqlite3_free(pTS->aaOutput[i]);\n        sqlite3_free(aOut);\n        pTS->aaOutput[i] = 0;\n        aOut = aNew;\n        nOut = nNew;\n      }\n    }\n  }\n\n  pTS->aaOutput[0] = aOut;\n  pTS->anOutput[0] = nOut;\n  return SQLITE_OK;\n}\n\n/*\n** This function is used as the sqlite3Fts3SegReaderIterate() callback when\n** querying the full-text index for a doclist associated with a term or\n** term-prefix.\n*/\nstatic int fts3TermSelectCb(\n  Fts3Table *p,                   /* Virtual table object */\n  void *pContext,                 /* Pointer to TermSelect structure */\n  char *zTerm,\n  int nTerm,\n  char *aDoclist,\n  int nDoclist\n){\n  TermSelect *pTS = (TermSelect *)pContext;\n\n  UNUSED_PARAMETER(p);\n  UNUSED_PARAMETER(zTerm);\n  UNUSED_PARAMETER(nTerm);\n\n  if( pTS->aaOutput[0]==0 ){\n    /* If this is the first term selected, copy the doclist to the output\n    ** buffer using memcpy(). TODO: Add a way to transfer control of the\n    ** aDoclist buffer from the caller so as to avoid the memcpy().\n    */\n    pTS->aaOutput[0] = sqlite3_malloc(nDoclist);\n    pTS->anOutput[0] = nDoclist;\n    if( pTS->aaOutput[0] ){\n      memcpy(pTS->aaOutput[0], aDoclist, nDoclist);\n    }else{\n      return SQLITE_NOMEM;\n    }\n  }else{\n    int mergetype = (pTS->isReqPos ? MERGE_POS_OR : MERGE_OR);\n    char *aMerge = aDoclist;\n    int nMerge = nDoclist;\n    int iOut;\n\n    for(iOut=0; iOut<SizeofArray(pTS->aaOutput); iOut++){\n      char *aNew;\n      int nNew;\n      if( pTS->aaOutput[iOut]==0 ){\n        assert( iOut>0 );\n        pTS->aaOutput[iOut] = aMerge;\n        pTS->anOutput[iOut] = nMerge;\n        break;\n      }\n\n      nNew = nMerge + pTS->anOutput[iOut];\n      aNew = sqlite3_malloc(nNew);\n      if( !aNew ){\n        if( aMerge!=aDoclist ){\n          sqlite3_free(aMerge);\n        }\n        return SQLITE_NOMEM;\n      }\n      fts3DoclistMerge(mergetype, 0, 0, aNew, &nNew, \n          pTS->aaOutput[iOut], pTS->anOutput[iOut], aMerge, nMerge, 0\n      );\n\n      if( iOut>0 ) sqlite3_free(aMerge);\n      sqlite3_free(pTS->aaOutput[iOut]);\n      pTS->aaOutput[iOut] = 0;\n\n      aMerge = aNew;\n      nMerge = nNew;\n      if( (iOut+1)==SizeofArray(pTS->aaOutput) ){\n        pTS->aaOutput[iOut] = aMerge;\n        pTS->anOutput[iOut] = nMerge;\n      }\n    }\n  }\n  return SQLITE_OK;\n}\n\nstatic int fts3DeferredTermSelect(\n  Fts3DeferredToken *pToken,      /* Phrase token */\n  int isTermPos,                  /* True to include positions */\n  int *pnOut,                     /* OUT: Size of list */\n  char **ppOut                    /* OUT: Body of list */\n){\n  char *aSource;\n  int nSource;\n\n  aSource = sqlite3Fts3DeferredDoclist(pToken, &nSource);\n  if( !aSource ){\n    *pnOut = 0;\n    *ppOut = 0;\n  }else if( isTermPos ){\n    *ppOut = sqlite3_malloc(nSource);\n    if( !*ppOut ) return SQLITE_NOMEM;\n    memcpy(*ppOut, aSource, nSource);\n    *pnOut = nSource;\n  }else{\n    sqlite3_int64 docid;\n    *pnOut = sqlite3Fts3GetVarint(aSource, &docid);\n    *ppOut = sqlite3_malloc(*pnOut);\n    if( !*ppOut ) return SQLITE_NOMEM;\n    sqlite3Fts3PutVarint(*ppOut, docid);\n  }\n\n  return SQLITE_OK;\n}\n\nSQLITE_PRIVATE int sqlite3Fts3SegReaderCursor(\n  Fts3Table *p,                   /* FTS3 table handle */\n  int iLevel,                     /* Level of segments to scan */\n  const char *zTerm,              /* Term to query for */\n  int nTerm,                      /* Size of zTerm in bytes */\n  int isPrefix,                   /* True for a prefix search */\n  int isScan,                     /* True to scan from zTerm to EOF */\n  Fts3SegReaderCursor *pCsr       /* Cursor object to populate */\n){\n  int rc = SQLITE_OK;\n  int rc2;\n  int iAge = 0;\n  sqlite3_stmt *pStmt = 0;\n  Fts3SegReader *pPending = 0;\n\n  assert( iLevel==FTS3_SEGCURSOR_ALL \n      ||  iLevel==FTS3_SEGCURSOR_PENDING \n      ||  iLevel>=0\n  );\n  assert( FTS3_SEGCURSOR_PENDING<0 );\n  assert( FTS3_SEGCURSOR_ALL<0 );\n  assert( iLevel==FTS3_SEGCURSOR_ALL || (zTerm==0 && isPrefix==1) );\n  assert( isPrefix==0 || isScan==0 );\n\n\n  memset(pCsr, 0, sizeof(Fts3SegReaderCursor));\n\n  /* If iLevel is less than 0, include a seg-reader for the pending-terms. */\n  assert( isScan==0 || fts3HashCount(&p->pendingTerms)==0 );\n  if( iLevel<0 && isScan==0 ){\n    rc = sqlite3Fts3SegReaderPending(p, zTerm, nTerm, isPrefix, &pPending);\n    if( rc==SQLITE_OK && pPending ){\n      int nByte = (sizeof(Fts3SegReader *) * 16);\n      pCsr->apSegment = (Fts3SegReader **)sqlite3_malloc(nByte);\n      if( pCsr->apSegment==0 ){\n        rc = SQLITE_NOMEM;\n      }else{\n        pCsr->apSegment[0] = pPending;\n        pCsr->nSegment = 1;\n        pPending = 0;\n      }\n    }\n  }\n\n  if( iLevel!=FTS3_SEGCURSOR_PENDING ){\n    if( rc==SQLITE_OK ){\n      rc = sqlite3Fts3AllSegdirs(p, iLevel, &pStmt);\n    }\n    while( rc==SQLITE_OK && SQLITE_ROW==(rc = sqlite3_step(pStmt)) ){\n\n      /* Read the values returned by the SELECT into local variables. */\n      sqlite3_int64 iStartBlock = sqlite3_column_int64(pStmt, 1);\n      sqlite3_int64 iLeavesEndBlock = sqlite3_column_int64(pStmt, 2);\n      sqlite3_int64 iEndBlock = sqlite3_column_int64(pStmt, 3);\n      int nRoot = sqlite3_column_bytes(pStmt, 4);\n      char const *zRoot = sqlite3_column_blob(pStmt, 4);\n\n      /* If nSegment is a multiple of 16 the array needs to be extended. */\n      if( (pCsr->nSegment%16)==0 ){\n        Fts3SegReader **apNew;\n        int nByte = (pCsr->nSegment + 16)*sizeof(Fts3SegReader*);\n        apNew = (Fts3SegReader **)sqlite3_realloc(pCsr->apSegment, nByte);\n        if( !apNew ){\n          rc = SQLITE_NOMEM;\n          goto finished;\n        }\n        pCsr->apSegment = apNew;\n      }\n\n      /* If zTerm is not NULL, and this segment is not stored entirely on its\n      ** root node, the range of leaves scanned can be reduced. Do this. */\n      if( iStartBlock && zTerm ){\n        sqlite3_int64 *pi = (isPrefix ? &iLeavesEndBlock : 0);\n        rc = fts3SelectLeaf(p, zTerm, nTerm, zRoot, nRoot, &iStartBlock, pi);\n        if( rc!=SQLITE_OK ) goto finished;\n        if( isPrefix==0 && isScan==0 ) iLeavesEndBlock = iStartBlock;\n      }\n \n      rc = sqlite3Fts3SegReaderNew(iAge, iStartBlock, iLeavesEndBlock,\n          iEndBlock, zRoot, nRoot, &pCsr->apSegment[pCsr->nSegment]\n      );\n      if( rc!=SQLITE_OK ) goto finished;\n      pCsr->nSegment++;\n      iAge++;\n    }\n  }\n\n finished:\n  rc2 = sqlite3_reset(pStmt);\n  if( rc==SQLITE_DONE ) rc = rc2;\n  sqlite3Fts3SegReaderFree(pPending);\n\n  return rc;\n}\n\n\nstatic int fts3TermSegReaderCursor(\n  Fts3Cursor *pCsr,               /* Virtual table cursor handle */\n  const char *zTerm,              /* Term to query for */\n  int nTerm,                      /* Size of zTerm in bytes */\n  int isPrefix,                   /* True for a prefix search */\n  Fts3SegReaderCursor **ppSegcsr  /* OUT: Allocated seg-reader cursor */\n){\n  Fts3SegReaderCursor *pSegcsr;   /* Object to allocate and return */\n  int rc = SQLITE_NOMEM;          /* Return code */\n\n  pSegcsr = sqlite3_malloc(sizeof(Fts3SegReaderCursor));\n  if( pSegcsr ){\n    Fts3Table *p = (Fts3Table *)pCsr->base.pVtab;\n    int i;\n    int nCost = 0;\n    rc = sqlite3Fts3SegReaderCursor(\n        p, FTS3_SEGCURSOR_ALL, zTerm, nTerm, isPrefix, 0, pSegcsr);\n  \n    for(i=0; rc==SQLITE_OK && i<pSegcsr->nSegment; i++){\n      rc = sqlite3Fts3SegReaderCost(pCsr, pSegcsr->apSegment[i], &nCost);\n    }\n    pSegcsr->nCost = nCost;\n  }\n\n  *ppSegcsr = pSegcsr;\n  return rc;\n}\n\nstatic void fts3SegReaderCursorFree(Fts3SegReaderCursor *pSegcsr){\n  sqlite3Fts3SegReaderFinish(pSegcsr);\n  sqlite3_free(pSegcsr);\n}\n\n/*\n** This function retreives the doclist for the specified term (or term\n** prefix) from the database. \n**\n** The returned doclist may be in one of two formats, depending on the \n** value of parameter isReqPos. If isReqPos is zero, then the doclist is\n** a sorted list of delta-compressed docids (a bare doclist). If isReqPos\n** is non-zero, then the returned list is in the same format as is stored \n** in the database without the found length specifier at the start of on-disk\n** doclists.\n*/\nstatic int fts3TermSelect(\n  Fts3Table *p,                   /* Virtual table handle */\n  Fts3PhraseToken *pTok,          /* Token to query for */\n  int iColumn,                    /* Column to query (or -ve for all columns) */\n  int isReqPos,                   /* True to include position lists in output */\n  int *pnOut,                     /* OUT: Size of buffer at *ppOut */\n  char **ppOut                    /* OUT: Malloced result buffer */\n){\n  int rc;                         /* Return code */\n  Fts3SegReaderCursor *pSegcsr;   /* Seg-reader cursor for this term */\n  TermSelect tsc;                 /* Context object for fts3TermSelectCb() */\n  Fts3SegFilter filter;           /* Segment term filter configuration */\n\n  pSegcsr = pTok->pSegcsr;\n  memset(&tsc, 0, sizeof(TermSelect));\n  tsc.isReqPos = isReqPos;\n\n  filter.flags = FTS3_SEGMENT_IGNORE_EMPTY \n        | (pTok->isPrefix ? FTS3_SEGMENT_PREFIX : 0)\n        | (isReqPos ? FTS3_SEGMENT_REQUIRE_POS : 0)\n        | (iColumn<p->nColumn ? FTS3_SEGMENT_COLUMN_FILTER : 0);\n  filter.iCol = iColumn;\n  filter.zTerm = pTok->z;\n  filter.nTerm = pTok->n;\n\n  rc = sqlite3Fts3SegReaderStart(p, pSegcsr, &filter);\n  while( SQLITE_OK==rc\n      && SQLITE_ROW==(rc = sqlite3Fts3SegReaderStep(p, pSegcsr)) \n  ){\n    rc = fts3TermSelectCb(p, (void *)&tsc, \n        pSegcsr->zTerm, pSegcsr->nTerm, pSegcsr->aDoclist, pSegcsr->nDoclist\n    );\n  }\n\n  if( rc==SQLITE_OK ){\n    rc = fts3TermSelectMerge(&tsc);\n  }\n  if( rc==SQLITE_OK ){\n    *ppOut = tsc.aaOutput[0];\n    *pnOut = tsc.anOutput[0];\n  }else{\n    int i;\n    for(i=0; i<SizeofArray(tsc.aaOutput); i++){\n      sqlite3_free(tsc.aaOutput[i]);\n    }\n  }\n\n  fts3SegReaderCursorFree(pSegcsr);\n  pTok->pSegcsr = 0;\n  return rc;\n}\n\n/*\n** This function counts the total number of docids in the doclist stored\n** in buffer aList[], size nList bytes.\n**\n** If the isPoslist argument is true, then it is assumed that the doclist\n** contains a position-list following each docid. Otherwise, it is assumed\n** that the doclist is simply a list of docids stored as delta encoded \n** varints.\n*/\nstatic int fts3DoclistCountDocids(int isPoslist, char *aList, int nList){\n  int nDoc = 0;                   /* Return value */\n  if( aList ){\n    char *aEnd = &aList[nList];   /* Pointer to one byte after EOF */\n    char *p = aList;              /* Cursor */\n    if( !isPoslist ){\n      /* The number of docids in the list is the same as the number of \n      ** varints. In FTS3 a varint consists of a single byte with the 0x80 \n      ** bit cleared and zero or more bytes with the 0x80 bit set. So to\n      ** count the varints in the buffer, just count the number of bytes\n      ** with the 0x80 bit clear.  */\n      while( p<aEnd ) nDoc += (((*p++)&0x80)==0);\n    }else{\n      while( p<aEnd ){\n        nDoc++;\n        while( (*p++)&0x80 );     /* Skip docid varint */\n        fts3PoslistCopy(0, &p);   /* Skip over position list */\n      }\n    }\n  }\n\n  return nDoc;\n}\n\n/*\n** Call sqlite3Fts3DeferToken() for each token in the expression pExpr.\n*/\nstatic int fts3DeferExpression(Fts3Cursor *pCsr, Fts3Expr *pExpr){\n  int rc = SQLITE_OK;\n  if( pExpr ){\n    rc = fts3DeferExpression(pCsr, pExpr->pLeft);\n    if( rc==SQLITE_OK ){\n      rc = fts3DeferExpression(pCsr, pExpr->pRight);\n    }\n    if( pExpr->eType==FTSQUERY_PHRASE ){\n      int iCol = pExpr->pPhrase->iColumn;\n      int i;\n      for(i=0; rc==SQLITE_OK && i<pExpr->pPhrase->nToken; i++){\n        Fts3PhraseToken *pToken = &pExpr->pPhrase->aToken[i];\n        if( pToken->pDeferred==0 ){\n          rc = sqlite3Fts3DeferToken(pCsr, pToken, iCol);\n        }\n      }\n    }\n  }\n  return rc;\n}\n\n/*\n** This function removes the position information from a doclist. When\n** called, buffer aList (size *pnList bytes) contains a doclist that includes\n** position information. This function removes the position information so\n** that aList contains only docids, and adjusts *pnList to reflect the new\n** (possibly reduced) size of the doclist.\n*/\nstatic void fts3DoclistStripPositions(\n  char *aList,                    /* IN/OUT: Buffer containing doclist */\n  int *pnList                     /* IN/OUT: Size of doclist in bytes */\n){\n  if( aList ){\n    char *aEnd = &aList[*pnList]; /* Pointer to one byte after EOF */\n    char *p = aList;              /* Input cursor */\n    char *pOut = aList;           /* Output cursor */\n  \n    while( p<aEnd ){\n      sqlite3_int64 delta;\n      p += sqlite3Fts3GetVarint(p, &delta);\n      fts3PoslistCopy(0, &p);\n      pOut += sqlite3Fts3PutVarint(pOut, delta);\n    }\n\n    *pnList = (int)(pOut - aList);\n  }\n}\n\n/* \n** Return a DocList corresponding to the phrase *pPhrase.\n**\n** If this function returns SQLITE_OK, but *pnOut is set to a negative value,\n** then no tokens in the phrase were looked up in the full-text index. This\n** is only possible when this function is called from within xFilter(). The\n** caller should assume that all documents match the phrase. The actual\n** filtering will take place in xNext().\n*/\nstatic int fts3PhraseSelect(\n  Fts3Cursor *pCsr,               /* Virtual table cursor handle */\n  Fts3Phrase *pPhrase,            /* Phrase to return a doclist for */\n  int isReqPos,                   /* True if output should contain positions */\n  char **paOut,                   /* OUT: Pointer to malloc'd result buffer */\n  int *pnOut                      /* OUT: Size of buffer at *paOut */\n){\n  char *pOut = 0;\n  int nOut = 0;\n  int rc = SQLITE_OK;\n  int ii;\n  int iCol = pPhrase->iColumn;\n  int isTermPos = (pPhrase->nToken>1 || isReqPos);\n  Fts3Table *p = (Fts3Table *)pCsr->base.pVtab;\n  int isFirst = 1;\n\n  int iPrevTok = 0;\n  int nDoc = 0;\n\n  /* If this is an xFilter() evaluation, create a segment-reader for each\n  ** phrase token. Or, if this is an xNext() or snippet/offsets/matchinfo\n  ** evaluation, only create segment-readers if there are no Fts3DeferredToken\n  ** objects attached to the phrase-tokens.\n  */\n  for(ii=0; ii<pPhrase->nToken; ii++){\n    Fts3PhraseToken *pTok = &pPhrase->aToken[ii];\n    if( pTok->pSegcsr==0 ){\n      if( (pCsr->eEvalmode==FTS3_EVAL_FILTER)\n       || (pCsr->eEvalmode==FTS3_EVAL_NEXT && pCsr->pDeferred==0) \n       || (pCsr->eEvalmode==FTS3_EVAL_MATCHINFO && pTok->bFulltext) \n      ){\n        rc = fts3TermSegReaderCursor(\n            pCsr, pTok->z, pTok->n, pTok->isPrefix, &pTok->pSegcsr\n        );\n        if( rc!=SQLITE_OK ) return rc;\n      }\n    }\n  }\n\n  for(ii=0; ii<pPhrase->nToken; ii++){\n    Fts3PhraseToken *pTok;        /* Token to find doclist for */\n    int iTok = 0;                 /* The token being queried this iteration */\n    char *pList = 0;              /* Pointer to token doclist */\n    int nList = 0;                /* Size of buffer at pList */\n\n    /* Select a token to process. If this is an xFilter() call, then tokens \n    ** are processed in order from least to most costly. Otherwise, tokens \n    ** are processed in the order in which they occur in the phrase.\n    */\n    if( pCsr->eEvalmode==FTS3_EVAL_MATCHINFO ){\n      assert( isReqPos );\n      iTok = ii;\n      pTok = &pPhrase->aToken[iTok];\n      if( pTok->bFulltext==0 ) continue;\n    }else if( pCsr->eEvalmode==FTS3_EVAL_NEXT || isReqPos ){\n      iTok = ii;\n      pTok = &pPhrase->aToken[iTok];\n    }else{\n      int nMinCost = 0x7FFFFFFF;\n      int jj;\n\n      /* Find the remaining token with the lowest cost. */\n      for(jj=0; jj<pPhrase->nToken; jj++){\n        Fts3SegReaderCursor *pSegcsr = pPhrase->aToken[jj].pSegcsr;\n        if( pSegcsr && pSegcsr->nCost<nMinCost ){\n          iTok = jj;\n          nMinCost = pSegcsr->nCost;\n        }\n      }\n      pTok = &pPhrase->aToken[iTok];\n\n      /* This branch is taken if it is determined that loading the doclist\n      ** for the next token would require more IO than loading all documents\n      ** currently identified by doclist pOut/nOut. No further doclists will\n      ** be loaded from the full-text index for this phrase.\n      */\n      if( nMinCost>nDoc && ii>0 ){\n        rc = fts3DeferExpression(pCsr, pCsr->pExpr);\n        break;\n      }\n    }\n\n    if( pCsr->eEvalmode==FTS3_EVAL_NEXT && pTok->pDeferred ){\n      rc = fts3DeferredTermSelect(pTok->pDeferred, isTermPos, &nList, &pList);\n    }else{\n      if( pTok->pSegcsr ){\n        rc = fts3TermSelect(p, pTok, iCol, isTermPos, &nList, &pList);\n      }\n      pTok->bFulltext = 1;\n    }\n    assert( rc!=SQLITE_OK || pCsr->eEvalmode || pTok->pSegcsr==0 );\n    if( rc!=SQLITE_OK ) break;\n\n    if( isFirst ){\n      pOut = pList;\n      nOut = nList;\n      if( pCsr->eEvalmode==FTS3_EVAL_FILTER && pPhrase->nToken>1 ){\n        nDoc = fts3DoclistCountDocids(1, pOut, nOut);\n      }\n      isFirst = 0;\n      iPrevTok = iTok;\n    }else{\n      /* Merge the new term list and the current output. */\n      char *aLeft, *aRight;\n      int nLeft, nRight;\n      int nDist;\n      int mt;\n\n      /* If this is the final token of the phrase, and positions were not\n      ** requested by the caller, use MERGE_PHRASE instead of POS_PHRASE.\n      ** This drops the position information from the output list.\n      */\n      mt = MERGE_POS_PHRASE;\n      if( ii==pPhrase->nToken-1 && !isReqPos ) mt = MERGE_PHRASE;\n\n      assert( iPrevTok!=iTok );\n      if( iPrevTok<iTok ){\n        aLeft = pOut;\n        nLeft = nOut;\n        aRight = pList;\n        nRight = nList;\n        nDist = iTok-iPrevTok;\n        iPrevTok = iTok;\n      }else{\n        aRight = pOut;\n        nRight = nOut;\n        aLeft = pList;\n        nLeft = nList;\n        nDist = iPrevTok-iTok;\n      }\n      pOut = aRight;\n      fts3DoclistMerge(\n          mt, nDist, 0, pOut, &nOut, aLeft, nLeft, aRight, nRight, &nDoc\n      );\n      sqlite3_free(aLeft);\n    }\n    assert( nOut==0 || pOut!=0 );\n  }\n\n  if( rc==SQLITE_OK ){\n    if( ii!=pPhrase->nToken ){\n      assert( pCsr->eEvalmode==FTS3_EVAL_FILTER && isReqPos==0 );\n      fts3DoclistStripPositions(pOut, &nOut);\n    }\n    *paOut = pOut;\n    *pnOut = nOut;\n  }else{\n    sqlite3_free(pOut);\n  }\n  return rc;\n}\n\n/*\n** This function merges two doclists according to the requirements of a\n** NEAR operator.\n**\n** Both input doclists must include position information. The output doclist \n** includes position information if the first argument to this function\n** is MERGE_POS_NEAR, or does not if it is MERGE_NEAR.\n*/\nstatic int fts3NearMerge(\n  int mergetype,                  /* MERGE_POS_NEAR or MERGE_NEAR */\n  int nNear,                      /* Parameter to NEAR operator */\n  int nTokenLeft,                 /* Number of tokens in LHS phrase arg */\n  char *aLeft,                    /* Doclist for LHS (incl. positions) */\n  int nLeft,                      /* Size of LHS doclist in bytes */\n  int nTokenRight,                /* As nTokenLeft */\n  char *aRight,                   /* As aLeft */\n  int nRight,                     /* As nRight */\n  char **paOut,                   /* OUT: Results of merge (malloced) */\n  int *pnOut                      /* OUT: Sized of output buffer */\n){\n  char *aOut;                     /* Buffer to write output doclist to */\n  int rc;                         /* Return code */\n\n  assert( mergetype==MERGE_POS_NEAR || MERGE_NEAR );\n\n  aOut = sqlite3_malloc(nLeft+nRight+1);\n  if( aOut==0 ){\n    rc = SQLITE_NOMEM;\n  }else{\n    rc = fts3DoclistMerge(mergetype, nNear+nTokenRight, nNear+nTokenLeft, \n      aOut, pnOut, aLeft, nLeft, aRight, nRight, 0\n    );\n    if( rc!=SQLITE_OK ){\n      sqlite3_free(aOut);\n      aOut = 0;\n    }\n  }\n\n  *paOut = aOut;\n  return rc;\n}\n\n/*\n** This function is used as part of the processing for the snippet() and\n** offsets() functions.\n**\n** Both pLeft and pRight are expression nodes of type FTSQUERY_PHRASE. Both\n** have their respective doclists (including position information) loaded\n** in Fts3Expr.aDoclist/nDoclist. This function removes all entries from\n** each doclist that are not within nNear tokens of a corresponding entry\n** in the other doclist.\n*/\nSQLITE_PRIVATE int sqlite3Fts3ExprNearTrim(Fts3Expr *pLeft, Fts3Expr *pRight, int nNear){\n  int rc;                         /* Return code */\n\n  assert( pLeft->eType==FTSQUERY_PHRASE );\n  assert( pRight->eType==FTSQUERY_PHRASE );\n  assert( pLeft->isLoaded && pRight->isLoaded );\n\n  if( pLeft->aDoclist==0 || pRight->aDoclist==0 ){\n    sqlite3_free(pLeft->aDoclist);\n    sqlite3_free(pRight->aDoclist);\n    pRight->aDoclist = 0;\n    pLeft->aDoclist = 0;\n    rc = SQLITE_OK;\n  }else{\n    char *aOut;                   /* Buffer in which to assemble new doclist */\n    int nOut;                     /* Size of buffer aOut in bytes */\n\n    rc = fts3NearMerge(MERGE_POS_NEAR, nNear, \n        pLeft->pPhrase->nToken, pLeft->aDoclist, pLeft->nDoclist,\n        pRight->pPhrase->nToken, pRight->aDoclist, pRight->nDoclist,\n        &aOut, &nOut\n    );\n    if( rc!=SQLITE_OK ) return rc;\n    sqlite3_free(pRight->aDoclist);\n    pRight->aDoclist = aOut;\n    pRight->nDoclist = nOut;\n\n    rc = fts3NearMerge(MERGE_POS_NEAR, nNear, \n        pRight->pPhrase->nToken, pRight->aDoclist, pRight->nDoclist,\n        pLeft->pPhrase->nToken, pLeft->aDoclist, pLeft->nDoclist,\n        &aOut, &nOut\n    );\n    sqlite3_free(pLeft->aDoclist);\n    pLeft->aDoclist = aOut;\n    pLeft->nDoclist = nOut;\n  }\n  return rc;\n}\n\n\n/*\n** Allocate an Fts3SegReaderArray for each token in the expression pExpr. \n** The allocated objects are stored in the Fts3PhraseToken.pArray member\n** variables of each token structure.\n*/\nstatic int fts3ExprAllocateSegReaders(\n  Fts3Cursor *pCsr,               /* FTS3 table */\n  Fts3Expr *pExpr,                /* Expression to create seg-readers for */\n  int *pnExpr                     /* OUT: Number of AND'd expressions */\n){\n  int rc = SQLITE_OK;             /* Return code */\n\n  assert( pCsr->eEvalmode==FTS3_EVAL_FILTER );\n  if( pnExpr && pExpr->eType!=FTSQUERY_AND ){\n    (*pnExpr)++;\n    pnExpr = 0;\n  }\n\n  if( pExpr->eType==FTSQUERY_PHRASE ){\n    Fts3Phrase *pPhrase = pExpr->pPhrase;\n    int ii;\n\n    for(ii=0; rc==SQLITE_OK && ii<pPhrase->nToken; ii++){\n      Fts3PhraseToken *pTok = &pPhrase->aToken[ii];\n      if( pTok->pSegcsr==0 ){\n        rc = fts3TermSegReaderCursor(\n            pCsr, pTok->z, pTok->n, pTok->isPrefix, &pTok->pSegcsr\n        );\n      }\n    }\n  }else{ \n    rc = fts3ExprAllocateSegReaders(pCsr, pExpr->pLeft, pnExpr);\n    if( rc==SQLITE_OK ){\n      rc = fts3ExprAllocateSegReaders(pCsr, pExpr->pRight, pnExpr);\n    }\n  }\n  return rc;\n}\n\n/*\n** Free the Fts3SegReaderArray objects associated with each token in the\n** expression pExpr. In other words, this function frees the resources\n** allocated by fts3ExprAllocateSegReaders().\n*/\nstatic void fts3ExprFreeSegReaders(Fts3Expr *pExpr){\n  if( pExpr ){\n    Fts3Phrase *pPhrase = pExpr->pPhrase;\n    if( pPhrase ){\n      int kk;\n      for(kk=0; kk<pPhrase->nToken; kk++){\n        fts3SegReaderCursorFree(pPhrase->aToken[kk].pSegcsr);\n        pPhrase->aToken[kk].pSegcsr = 0;\n      }\n    }\n    fts3ExprFreeSegReaders(pExpr->pLeft);\n    fts3ExprFreeSegReaders(pExpr->pRight);\n  }\n}\n\n/*\n** Return the sum of the costs of all tokens in the expression pExpr. This\n** function must be called after Fts3SegReaderArrays have been allocated\n** for all tokens using fts3ExprAllocateSegReaders().\n*/\nstatic int fts3ExprCost(Fts3Expr *pExpr){\n  int nCost;                      /* Return value */\n  if( pExpr->eType==FTSQUERY_PHRASE ){\n    Fts3Phrase *pPhrase = pExpr->pPhrase;\n    int ii;\n    nCost = 0;\n    for(ii=0; ii<pPhrase->nToken; ii++){\n      Fts3SegReaderCursor *pSegcsr = pPhrase->aToken[ii].pSegcsr;\n      if( pSegcsr ) nCost += pSegcsr->nCost;\n    }\n  }else{\n    nCost = fts3ExprCost(pExpr->pLeft) + fts3ExprCost(pExpr->pRight);\n  }\n  return nCost;\n}\n\n/*\n** The following is a helper function (and type) for fts3EvalExpr(). It\n** must be called after Fts3SegReaders have been allocated for every token\n** in the expression. See the context it is called from in fts3EvalExpr()\n** for further explanation.\n*/\ntypedef struct ExprAndCost ExprAndCost;\nstruct ExprAndCost {\n  Fts3Expr *pExpr;\n  int nCost;\n};\nstatic void fts3ExprAssignCosts(\n  Fts3Expr *pExpr,                /* Expression to create seg-readers for */\n  ExprAndCost **ppExprCost        /* OUT: Write to *ppExprCost */\n){\n  if( pExpr->eType==FTSQUERY_AND ){\n    fts3ExprAssignCosts(pExpr->pLeft, ppExprCost);\n    fts3ExprAssignCosts(pExpr->pRight, ppExprCost);\n  }else{\n    (*ppExprCost)->pExpr = pExpr;\n    (*ppExprCost)->nCost = fts3ExprCost(pExpr);\n    (*ppExprCost)++;\n  }\n}\n\n/*\n** Evaluate the full-text expression pExpr against FTS3 table pTab. Store\n** the resulting doclist in *paOut and *pnOut. This routine mallocs for\n** the space needed to store the output. The caller is responsible for\n** freeing the space when it has finished.\n**\n** This function is called in two distinct contexts:\n**\n**   * From within the virtual table xFilter() method. In this case, the\n**     output doclist contains entries for all rows in the table, based on\n**     data read from the full-text index.\n**\n**     In this case, if the query expression contains one or more tokens that \n**     are very common, then the returned doclist may contain a superset of \n**     the documents that actually match the expression.\n**\n**   * From within the virtual table xNext() method. This call is only made\n**     if the call from within xFilter() found that there were very common \n**     tokens in the query expression and did return a superset of the \n**     matching documents. In this case the returned doclist contains only\n**     entries that correspond to the current row of the table. Instead of\n**     reading the data for each token from the full-text index, the data is\n**     already available in-memory in the Fts3PhraseToken.pDeferred structures.\n**     See fts3EvalDeferred() for how it gets there.\n**\n** In the first case above, Fts3Cursor.doDeferred==0. In the second (if it is\n** required) Fts3Cursor.doDeferred==1.\n**\n** If the SQLite invokes the snippet(), offsets() or matchinfo() function\n** as part of a SELECT on an FTS3 table, this function is called on each\n** individual phrase expression in the query. If there were very common tokens\n** found in the xFilter() call, then this function is called once for phrase\n** for each row visited, and the returned doclist contains entries for the\n** current row only. Otherwise, if there were no very common tokens, then this\n** function is called once only for each phrase in the query and the returned\n** doclist contains entries for all rows of the table.\n**\n** Fts3Cursor.doDeferred==1 when this function is called on phrases as a\n** result of a snippet(), offsets() or matchinfo() invocation.\n*/\nstatic int fts3EvalExpr(\n  Fts3Cursor *p,                  /* Virtual table cursor handle */\n  Fts3Expr *pExpr,                /* Parsed fts3 expression */\n  char **paOut,                   /* OUT: Pointer to malloc'd result buffer */\n  int *pnOut,                     /* OUT: Size of buffer at *paOut */\n  int isReqPos                    /* Require positions in output buffer */\n){\n  int rc = SQLITE_OK;             /* Return code */\n\n  /* Zero the output parameters. */\n  *paOut = 0;\n  *pnOut = 0;\n\n  if( pExpr ){\n    assert( pExpr->eType==FTSQUERY_NEAR   || pExpr->eType==FTSQUERY_OR     \n         || pExpr->eType==FTSQUERY_AND    || pExpr->eType==FTSQUERY_NOT\n         || pExpr->eType==FTSQUERY_PHRASE\n    );\n    assert( pExpr->eType==FTSQUERY_PHRASE || isReqPos==0 );\n\n    if( pExpr->eType==FTSQUERY_PHRASE ){\n      rc = fts3PhraseSelect(p, pExpr->pPhrase,\n          isReqPos || (pExpr->pParent && pExpr->pParent->eType==FTSQUERY_NEAR),\n          paOut, pnOut\n      );\n      fts3ExprFreeSegReaders(pExpr);\n    }else if( p->eEvalmode==FTS3_EVAL_FILTER && pExpr->eType==FTSQUERY_AND ){\n      ExprAndCost *aExpr = 0;     /* Array of AND'd expressions and costs */\n      int nExpr = 0;              /* Size of aExpr[] */\n      char *aRet = 0;             /* Doclist to return to caller */\n      int nRet = 0;               /* Length of aRet[] in bytes */\n      int nDoc = 0x7FFFFFFF;\n\n      assert( !isReqPos );\n\n      rc = fts3ExprAllocateSegReaders(p, pExpr, &nExpr);\n      if( rc==SQLITE_OK ){\n        assert( nExpr>1 );\n        aExpr = sqlite3_malloc(sizeof(ExprAndCost) * nExpr);\n        if( !aExpr ) rc = SQLITE_NOMEM;\n      }\n      if( rc==SQLITE_OK ){\n        int ii;                   /* Used to iterate through expressions */\n\n        fts3ExprAssignCosts(pExpr, &aExpr);\n        aExpr -= nExpr;\n        for(ii=0; ii<nExpr; ii++){\n          char *aNew;\n          int nNew;\n          int jj;\n          ExprAndCost *pBest = 0;\n  \n          for(jj=0; jj<nExpr; jj++){\n            ExprAndCost *pCand = &aExpr[jj];\n            if( pCand->pExpr && (pBest==0 || pCand->nCost<pBest->nCost) ){\n              pBest = pCand;\n            }\n          }\n  \n          if( pBest->nCost>nDoc ){\n            rc = fts3DeferExpression(p, p->pExpr);\n            break;\n          }else{\n            rc = fts3EvalExpr(p, pBest->pExpr, &aNew, &nNew, 0);\n            if( rc!=SQLITE_OK ) break;\n            pBest->pExpr = 0;\n            if( ii==0 ){\n              aRet = aNew;\n              nRet = nNew;\n              nDoc = fts3DoclistCountDocids(0, aRet, nRet);\n            }else{\n              fts3DoclistMerge(\n                  MERGE_AND, 0, 0, aRet, &nRet, aRet, nRet, aNew, nNew, &nDoc\n              );\n              sqlite3_free(aNew);\n            }\n          }\n        }\n      }\n\n      if( rc==SQLITE_OK ){\n        *paOut = aRet;\n        *pnOut = nRet;\n      }else{\n        assert( *paOut==0 );\n        sqlite3_free(aRet);\n      }\n      sqlite3_free(aExpr);\n      fts3ExprFreeSegReaders(pExpr);\n\n    }else{\n      char *aLeft;\n      char *aRight;\n      int nLeft;\n      int nRight;\n\n      assert( pExpr->eType==FTSQUERY_NEAR \n           || pExpr->eType==FTSQUERY_OR\n           || pExpr->eType==FTSQUERY_NOT\n           || (pExpr->eType==FTSQUERY_AND && p->eEvalmode==FTS3_EVAL_NEXT)\n      );\n\n      if( 0==(rc = fts3EvalExpr(p, pExpr->pRight, &aRight, &nRight, isReqPos))\n       && 0==(rc = fts3EvalExpr(p, pExpr->pLeft, &aLeft, &nLeft, isReqPos))\n      ){\n        switch( pExpr->eType ){\n          case FTSQUERY_NEAR: {\n            Fts3Expr *pLeft;\n            Fts3Expr *pRight;\n            int mergetype = MERGE_NEAR;\n            if( pExpr->pParent && pExpr->pParent->eType==FTSQUERY_NEAR ){\n              mergetype = MERGE_POS_NEAR;\n            }\n            pLeft = pExpr->pLeft;\n            while( pLeft->eType==FTSQUERY_NEAR ){ \n              pLeft=pLeft->pRight;\n            }\n            pRight = pExpr->pRight;\n            assert( pRight->eType==FTSQUERY_PHRASE );\n            assert( pLeft->eType==FTSQUERY_PHRASE );\n\n            rc = fts3NearMerge(mergetype, pExpr->nNear, \n                pLeft->pPhrase->nToken, aLeft, nLeft,\n                pRight->pPhrase->nToken, aRight, nRight,\n                paOut, pnOut\n            );\n            sqlite3_free(aLeft);\n            break;\n          }\n\n          case FTSQUERY_OR: {\n            /* Allocate a buffer for the output. The maximum size is the\n            ** sum of the sizes of the two input buffers. The +1 term is\n            ** so that a buffer of zero bytes is never allocated - this can\n            ** cause fts3DoclistMerge() to incorrectly return SQLITE_NOMEM.\n            */\n            char *aBuffer = sqlite3_malloc(nRight+nLeft+1);\n            rc = fts3DoclistMerge(MERGE_OR, 0, 0, aBuffer, pnOut,\n                aLeft, nLeft, aRight, nRight, 0\n            );\n            *paOut = aBuffer;\n            sqlite3_free(aLeft);\n            break;\n          }\n\n          default: {\n            assert( FTSQUERY_NOT==MERGE_NOT && FTSQUERY_AND==MERGE_AND );\n            fts3DoclistMerge(pExpr->eType, 0, 0, aLeft, pnOut,\n                aLeft, nLeft, aRight, nRight, 0\n            );\n            *paOut = aLeft;\n            break;\n          }\n        }\n      }\n      sqlite3_free(aRight);\n    }\n  }\n\n  assert( rc==SQLITE_OK || *paOut==0 );\n  return rc;\n}\n\n/*\n** This function is called from within xNext() for each row visited by\n** an FTS3 query. If evaluating the FTS3 query expression within xFilter()\n** was able to determine the exact set of matching rows, this function sets\n** *pbRes to true and returns SQLITE_IO immediately.\n**\n** Otherwise, if evaluating the query expression within xFilter() returned a\n** superset of the matching documents instead of an exact set (this happens\n** when the query includes very common tokens and it is deemed too expensive to\n** load their doclists from disk), this function tests if the current row\n** really does match the FTS3 query.\n**\n** If an error occurs, an SQLite error code is returned. Otherwise, SQLITE_OK\n** is returned and *pbRes is set to true if the current row matches the\n** FTS3 query (and should be included in the results returned to SQLite), or\n** false otherwise.\n*/\nstatic int fts3EvalDeferred(\n  Fts3Cursor *pCsr,               /* FTS3 cursor pointing at row to test */\n  int *pbRes                      /* OUT: Set to true if row is a match */\n){\n  int rc = SQLITE_OK;\n  if( pCsr->pDeferred==0 ){\n    *pbRes = 1;\n  }else{\n    rc = fts3CursorSeek(0, pCsr);\n    if( rc==SQLITE_OK ){\n      sqlite3Fts3FreeDeferredDoclists(pCsr);\n      rc = sqlite3Fts3CacheDeferredDoclists(pCsr);\n    }\n    if( rc==SQLITE_OK ){\n      char *a = 0;\n      int n = 0;\n      rc = fts3EvalExpr(pCsr, pCsr->pExpr, &a, &n, 0);\n      assert( n>=0 );\n      *pbRes = (n>0);\n      sqlite3_free(a);\n    }\n  }\n  return rc;\n}\n\n/*\n** Advance the cursor to the next row in the %_content table that\n** matches the search criteria.  For a MATCH search, this will be\n** the next row that matches. For a full-table scan, this will be\n** simply the next row in the %_content table.  For a docid lookup,\n** this routine simply sets the EOF flag.\n**\n** Return SQLITE_OK if nothing goes wrong.  SQLITE_OK is returned\n** even if we reach end-of-file.  The fts3EofMethod() will be called\n** subsequently to determine whether or not an EOF was hit.\n*/\nstatic int fts3NextMethod(sqlite3_vtab_cursor *pCursor){\n  int res;\n  int rc = SQLITE_OK;             /* Return code */\n  Fts3Cursor *pCsr = (Fts3Cursor *)pCursor;\n\n  pCsr->eEvalmode = FTS3_EVAL_NEXT;\n  do {\n    if( pCsr->aDoclist==0 ){\n      if( SQLITE_ROW!=sqlite3_step(pCsr->pStmt) ){\n        pCsr->isEof = 1;\n        rc = sqlite3_reset(pCsr->pStmt);\n        break;\n      }\n      pCsr->iPrevId = sqlite3_column_int64(pCsr->pStmt, 0);\n    }else{\n      if( pCsr->pNextId>=&pCsr->aDoclist[pCsr->nDoclist] ){\n        pCsr->isEof = 1;\n        break;\n      }\n      sqlite3_reset(pCsr->pStmt);\n      fts3GetDeltaVarint(&pCsr->pNextId, &pCsr->iPrevId);\n      pCsr->isRequireSeek = 1;\n      pCsr->isMatchinfoNeeded = 1;\n    }\n  }while( SQLITE_OK==(rc = fts3EvalDeferred(pCsr, &res)) && res==0 );\n\n  return rc;\n}\n\n/*\n** This is the xFilter interface for the virtual table.  See\n** the virtual table xFilter method documentation for additional\n** information.\n**\n** If idxNum==FTS3_FULLSCAN_SEARCH then do a full table scan against\n** the %_content table.\n**\n** If idxNum==FTS3_DOCID_SEARCH then do a docid lookup for a single entry\n** in the %_content table.\n**\n** If idxNum>=FTS3_FULLTEXT_SEARCH then use the full text index.  The\n** column on the left-hand side of the MATCH operator is column\n** number idxNum-FTS3_FULLTEXT_SEARCH, 0 indexed.  argv[0] is the right-hand\n** side of the MATCH operator.\n*/\nstatic int fts3FilterMethod(\n  sqlite3_vtab_cursor *pCursor,   /* The cursor used for this query */\n  int idxNum,                     /* Strategy index */\n  const char *idxStr,             /* Unused */\n  int nVal,                       /* Number of elements in apVal */\n  sqlite3_value **apVal           /* Arguments for the indexing scheme */\n){\n  const char *azSql[] = {\n    \"SELECT %s FROM %Q.'%q_content' AS x WHERE docid = ?\", /* non-full-scan */\n    \"SELECT %s FROM %Q.'%q_content' AS x \",                /* full-scan */\n  };\n  int rc;                         /* Return code */\n  char *zSql;                     /* SQL statement used to access %_content */\n  Fts3Table *p = (Fts3Table *)pCursor->pVtab;\n  Fts3Cursor *pCsr = (Fts3Cursor *)pCursor;\n\n  UNUSED_PARAMETER(idxStr);\n  UNUSED_PARAMETER(nVal);\n\n  assert( idxNum>=0 && idxNum<=(FTS3_FULLTEXT_SEARCH+p->nColumn) );\n  assert( nVal==0 || nVal==1 );\n  assert( (nVal==0)==(idxNum==FTS3_FULLSCAN_SEARCH) );\n  assert( p->pSegments==0 );\n\n  /* In case the cursor has been used before, clear it now. */\n  sqlite3_finalize(pCsr->pStmt);\n  sqlite3_free(pCsr->aDoclist);\n  sqlite3Fts3ExprFree(pCsr->pExpr);\n  memset(&pCursor[1], 0, sizeof(Fts3Cursor)-sizeof(sqlite3_vtab_cursor));\n\n  if( idxNum!=FTS3_DOCID_SEARCH && idxNum!=FTS3_FULLSCAN_SEARCH ){\n    int iCol = idxNum-FTS3_FULLTEXT_SEARCH;\n    const char *zQuery = (const char *)sqlite3_value_text(apVal[0]);\n\n    if( zQuery==0 && sqlite3_value_type(apVal[0])!=SQLITE_NULL ){\n      return SQLITE_NOMEM;\n    }\n\n    rc = sqlite3Fts3ExprParse(p->pTokenizer, p->azColumn, p->nColumn, \n        iCol, zQuery, -1, &pCsr->pExpr\n    );\n    if( rc!=SQLITE_OK ){\n      if( rc==SQLITE_ERROR ){\n        p->base.zErrMsg = sqlite3_mprintf(\"malformed MATCH expression: [%s]\",\n                                          zQuery);\n      }\n      return rc;\n    }\n\n    rc = sqlite3Fts3ReadLock(p);\n    if( rc!=SQLITE_OK ) return rc;\n\n    rc = fts3EvalExpr(pCsr, pCsr->pExpr, &pCsr->aDoclist, &pCsr->nDoclist, 0);\n    sqlite3Fts3SegmentsClose(p);\n    if( rc!=SQLITE_OK ) return rc;\n    pCsr->pNextId = pCsr->aDoclist;\n    pCsr->iPrevId = 0;\n  }\n\n  /* Compile a SELECT statement for this cursor. For a full-table-scan, the\n  ** statement loops through all rows of the %_content table. For a\n  ** full-text query or docid lookup, the statement retrieves a single\n  ** row by docid.\n  */\n  zSql = (char *)azSql[idxNum==FTS3_FULLSCAN_SEARCH];\n  zSql = sqlite3_mprintf(zSql, p->zReadExprlist, p->zDb, p->zName);\n  if( !zSql ){\n    rc = SQLITE_NOMEM;\n  }else{\n    rc = sqlite3_prepare_v2(p->db, zSql, -1, &pCsr->pStmt, 0);\n    sqlite3_free(zSql);\n  }\n  if( rc==SQLITE_OK && idxNum==FTS3_DOCID_SEARCH ){\n    rc = sqlite3_bind_value(pCsr->pStmt, 1, apVal[0]);\n  }\n  pCsr->eSearch = (i16)idxNum;\n\n  if( rc!=SQLITE_OK ) return rc;\n  return fts3NextMethod(pCursor);\n}\n\n/* \n** This is the xEof method of the virtual table. SQLite calls this \n** routine to find out if it has reached the end of a result set.\n*/\nstatic int fts3EofMethod(sqlite3_vtab_cursor *pCursor){\n  return ((Fts3Cursor *)pCursor)->isEof;\n}\n\n/* \n** This is the xRowid method. The SQLite core calls this routine to\n** retrieve the rowid for the current row of the result set. fts3\n** exposes %_content.docid as the rowid for the virtual table. The\n** rowid should be written to *pRowid.\n*/\nstatic int fts3RowidMethod(sqlite3_vtab_cursor *pCursor, sqlite_int64 *pRowid){\n  Fts3Cursor *pCsr = (Fts3Cursor *) pCursor;\n  if( pCsr->aDoclist ){\n    *pRowid = pCsr->iPrevId;\n  }else{\n    /* This branch runs if the query is implemented using a full-table scan\n    ** (not using the full-text index). In this case grab the rowid from the\n    ** SELECT statement.\n    */\n    assert( pCsr->isRequireSeek==0 );\n    *pRowid = sqlite3_column_int64(pCsr->pStmt, 0);\n  }\n  return SQLITE_OK;\n}\n\n/* \n** This is the xColumn method, called by SQLite to request a value from\n** the row that the supplied cursor currently points to.\n*/\nstatic int fts3ColumnMethod(\n  sqlite3_vtab_cursor *pCursor,   /* Cursor to retrieve value from */\n  sqlite3_context *pContext,      /* Context for sqlite3_result_xxx() calls */\n  int iCol                        /* Index of column to read value from */\n){\n  int rc;                         /* Return Code */\n  Fts3Cursor *pCsr = (Fts3Cursor *) pCursor;\n  Fts3Table *p = (Fts3Table *)pCursor->pVtab;\n\n  /* The column value supplied by SQLite must be in range. */\n  assert( iCol>=0 && iCol<=p->nColumn+1 );\n\n  if( iCol==p->nColumn+1 ){\n    /* This call is a request for the \"docid\" column. Since \"docid\" is an \n    ** alias for \"rowid\", use the xRowid() method to obtain the value.\n    */\n    sqlite3_int64 iRowid;\n    rc = fts3RowidMethod(pCursor, &iRowid);\n    sqlite3_result_int64(pContext, iRowid);\n  }else if( iCol==p->nColumn ){\n    /* The extra column whose name is the same as the table.\n    ** Return a blob which is a pointer to the cursor.\n    */\n    sqlite3_result_blob(pContext, &pCsr, sizeof(pCsr), SQLITE_TRANSIENT);\n    rc = SQLITE_OK;\n  }else{\n    rc = fts3CursorSeek(0, pCsr);\n    if( rc==SQLITE_OK ){\n      sqlite3_result_value(pContext, sqlite3_column_value(pCsr->pStmt, iCol+1));\n    }\n  }\n  return rc;\n}\n\n/* \n** This function is the implementation of the xUpdate callback used by \n** FTS3 virtual tables. It is invoked by SQLite each time a row is to be\n** inserted, updated or deleted.\n*/\nstatic int fts3UpdateMethod(\n  sqlite3_vtab *pVtab,            /* Virtual table handle */\n  int nArg,                       /* Size of argument array */\n  sqlite3_value **apVal,          /* Array of arguments */\n  sqlite_int64 *pRowid            /* OUT: The affected (or effected) rowid */\n){\n  return sqlite3Fts3UpdateMethod(pVtab, nArg, apVal, pRowid);\n}\n\n/*\n** Implementation of xSync() method. Flush the contents of the pending-terms\n** hash-table to the database.\n*/\nstatic int fts3SyncMethod(sqlite3_vtab *pVtab){\n  int rc = sqlite3Fts3PendingTermsFlush((Fts3Table *)pVtab);\n  sqlite3Fts3SegmentsClose((Fts3Table *)pVtab);\n  return rc;\n}\n\n/*\n** Implementation of xBegin() method. This is a no-op.\n*/\nstatic int fts3BeginMethod(sqlite3_vtab *pVtab){\n  UNUSED_PARAMETER(pVtab);\n  assert( ((Fts3Table *)pVtab)->nPendingData==0 );\n  return SQLITE_OK;\n}\n\n/*\n** Implementation of xCommit() method. This is a no-op. The contents of\n** the pending-terms hash-table have already been flushed into the database\n** by fts3SyncMethod().\n*/\nstatic int fts3CommitMethod(sqlite3_vtab *pVtab){\n  UNUSED_PARAMETER(pVtab);\n  assert( ((Fts3Table *)pVtab)->nPendingData==0 );\n  return SQLITE_OK;\n}\n\n/*\n** Implementation of xRollback(). Discard the contents of the pending-terms\n** hash-table. Any changes made to the database are reverted by SQLite.\n*/\nstatic int fts3RollbackMethod(sqlite3_vtab *pVtab){\n  sqlite3Fts3PendingTermsClear((Fts3Table *)pVtab);\n  return SQLITE_OK;\n}\n\n/*\n** Load the doclist associated with expression pExpr to pExpr->aDoclist.\n** The loaded doclist contains positions as well as the document ids.\n** This is used by the matchinfo(), snippet() and offsets() auxillary\n** functions.\n*/\nSQLITE_PRIVATE int sqlite3Fts3ExprLoadDoclist(Fts3Cursor *pCsr, Fts3Expr *pExpr){\n  int rc;\n  assert( pExpr->eType==FTSQUERY_PHRASE && pExpr->pPhrase );\n  assert( pCsr->eEvalmode==FTS3_EVAL_NEXT );\n  rc = fts3EvalExpr(pCsr, pExpr, &pExpr->aDoclist, &pExpr->nDoclist, 1);\n  return rc;\n}\n\nSQLITE_PRIVATE int sqlite3Fts3ExprLoadFtDoclist(\n  Fts3Cursor *pCsr, \n  Fts3Expr *pExpr,\n  char **paDoclist,\n  int *pnDoclist\n){\n  int rc;\n  assert( pCsr->eEvalmode==FTS3_EVAL_NEXT );\n  assert( pExpr->eType==FTSQUERY_PHRASE && pExpr->pPhrase );\n  pCsr->eEvalmode = FTS3_EVAL_MATCHINFO;\n  rc = fts3EvalExpr(pCsr, pExpr, paDoclist, pnDoclist, 1);\n  pCsr->eEvalmode = FTS3_EVAL_NEXT;\n  return rc;\n}\n\n/*\n** After ExprLoadDoclist() (see above) has been called, this function is\n** used to iterate/search through the position lists that make up the doclist\n** stored in pExpr->aDoclist.\n*/\nSQLITE_PRIVATE char *sqlite3Fts3FindPositions(\n  Fts3Expr *pExpr,                /* Access this expressions doclist */\n  sqlite3_int64 iDocid,           /* Docid associated with requested pos-list */\n  int iCol                        /* Column of requested pos-list */\n){\n  assert( pExpr->isLoaded );\n  if( pExpr->aDoclist ){\n    char *pEnd = &pExpr->aDoclist[pExpr->nDoclist];\n    char *pCsr;\n\n    if( pExpr->pCurrent==0 ){\n      pExpr->pCurrent = pExpr->aDoclist;\n      pExpr->iCurrent = 0;\n      pExpr->pCurrent += sqlite3Fts3GetVarint(pExpr->pCurrent,&pExpr->iCurrent);\n    }\n    pCsr = pExpr->pCurrent;\n    assert( pCsr );\n\n    while( pCsr<pEnd ){\n      if( pExpr->iCurrent<iDocid ){\n        fts3PoslistCopy(0, &pCsr);\n        if( pCsr<pEnd ){\n          fts3GetDeltaVarint(&pCsr, &pExpr->iCurrent);\n        }\n        pExpr->pCurrent = pCsr;\n      }else{\n        if( pExpr->iCurrent==iDocid ){\n          int iThis = 0;\n          if( iCol<0 ){\n            /* If iCol is negative, return a pointer to the start of the\n            ** position-list (instead of a pointer to the start of a list\n            ** of offsets associated with a specific column).\n            */\n            return pCsr;\n          }\n          while( iThis<iCol ){\n            fts3ColumnlistCopy(0, &pCsr);\n            if( *pCsr==0x00 ) return 0;\n            pCsr++;\n            pCsr += sqlite3Fts3GetVarint32(pCsr, &iThis);\n          }\n          if( iCol==iThis && (*pCsr&0xFE) ) return pCsr;\n        }\n        return 0;\n      }\n    }\n  }\n\n  return 0;\n}\n\n/*\n** Helper function used by the implementation of the overloaded snippet(),\n** offsets() and optimize() SQL functions.\n**\n** If the value passed as the third argument is a blob of size\n** sizeof(Fts3Cursor*), then the blob contents are copied to the \n** output variable *ppCsr and SQLITE_OK is returned. Otherwise, an error\n** message is written to context pContext and SQLITE_ERROR returned. The\n** string passed via zFunc is used as part of the error message.\n*/\nstatic int fts3FunctionArg(\n  sqlite3_context *pContext,      /* SQL function call context */\n  const char *zFunc,              /* Function name */\n  sqlite3_value *pVal,            /* argv[0] passed to function */\n  Fts3Cursor **ppCsr              /* OUT: Store cursor handle here */\n){\n  Fts3Cursor *pRet;\n  if( sqlite3_value_type(pVal)!=SQLITE_BLOB \n   || sqlite3_value_bytes(pVal)!=sizeof(Fts3Cursor *)\n  ){\n    char *zErr = sqlite3_mprintf(\"illegal first argument to %s\", zFunc);\n    sqlite3_result_error(pContext, zErr, -1);\n    sqlite3_free(zErr);\n    return SQLITE_ERROR;\n  }\n  memcpy(&pRet, sqlite3_value_blob(pVal), sizeof(Fts3Cursor *));\n  *ppCsr = pRet;\n  return SQLITE_OK;\n}\n\n/*\n** Implementation of the snippet() function for FTS3\n*/\nstatic void fts3SnippetFunc(\n  sqlite3_context *pContext,      /* SQLite function call context */\n  int nVal,                       /* Size of apVal[] array */\n  sqlite3_value **apVal           /* Array of arguments */\n){\n  Fts3Cursor *pCsr;               /* Cursor handle passed through apVal[0] */\n  const char *zStart = \"<b>\";\n  const char *zEnd = \"</b>\";\n  const char *zEllipsis = \"<b>...</b>\";\n  int iCol = -1;\n  int nToken = 15;                /* Default number of tokens in snippet */\n\n  /* There must be at least one argument passed to this function (otherwise\n  ** the non-overloaded version would have been called instead of this one).\n  */\n  assert( nVal>=1 );\n\n  if( nVal>6 ){\n    sqlite3_result_error(pContext, \n        \"wrong number of arguments to function snippet()\", -1);\n    return;\n  }\n  if( fts3FunctionArg(pContext, \"snippet\", apVal[0], &pCsr) ) return;\n\n  switch( nVal ){\n    case 6: nToken = sqlite3_value_int(apVal[5]);\n    case 5: iCol = sqlite3_value_int(apVal[4]);\n    case 4: zEllipsis = (const char*)sqlite3_value_text(apVal[3]);\n    case 3: zEnd = (const char*)sqlite3_value_text(apVal[2]);\n    case 2: zStart = (const char*)sqlite3_value_text(apVal[1]);\n  }\n  if( !zEllipsis || !zEnd || !zStart ){\n    sqlite3_result_error_nomem(pContext);\n  }else if( SQLITE_OK==fts3CursorSeek(pContext, pCsr) ){\n    sqlite3Fts3Snippet(pContext, pCsr, zStart, zEnd, zEllipsis, iCol, nToken);\n  }\n}\n\n/*\n** Implementation of the offsets() function for FTS3\n*/\nstatic void fts3OffsetsFunc(\n  sqlite3_context *pContext,      /* SQLite function call context */\n  int nVal,                       /* Size of argument array */\n  sqlite3_value **apVal           /* Array of arguments */\n){\n  Fts3Cursor *pCsr;               /* Cursor handle passed through apVal[0] */\n\n  UNUSED_PARAMETER(nVal);\n\n  assert( nVal==1 );\n  if( fts3FunctionArg(pContext, \"offsets\", apVal[0], &pCsr) ) return;\n  assert( pCsr );\n  if( SQLITE_OK==fts3CursorSeek(pContext, pCsr) ){\n    sqlite3Fts3Offsets(pContext, pCsr);\n  }\n}\n\n/* \n** Implementation of the special optimize() function for FTS3. This \n** function merges all segments in the database to a single segment.\n** Example usage is:\n**\n**   SELECT optimize(t) FROM t LIMIT 1;\n**\n** where 't' is the name of an FTS3 table.\n*/\nstatic void fts3OptimizeFunc(\n  sqlite3_context *pContext,      /* SQLite function call context */\n  int nVal,                       /* Size of argument array */\n  sqlite3_value **apVal           /* Array of arguments */\n){\n  int rc;                         /* Return code */\n  Fts3Table *p;                   /* Virtual table handle */\n  Fts3Cursor *pCursor;            /* Cursor handle passed through apVal[0] */\n\n  UNUSED_PARAMETER(nVal);\n\n  assert( nVal==1 );\n  if( fts3FunctionArg(pContext, \"optimize\", apVal[0], &pCursor) ) return;\n  p = (Fts3Table *)pCursor->base.pVtab;\n  assert( p );\n\n  rc = sqlite3Fts3Optimize(p);\n\n  switch( rc ){\n    case SQLITE_OK:\n      sqlite3_result_text(pContext, \"Index optimized\", -1, SQLITE_STATIC);\n      break;\n    case SQLITE_DONE:\n      sqlite3_result_text(pContext, \"Index already optimal\", -1, SQLITE_STATIC);\n      break;\n    default:\n      sqlite3_result_error_code(pContext, rc);\n      break;\n  }\n}\n\n/*\n** Implementation of the matchinfo() function for FTS3\n*/\nstatic void fts3MatchinfoFunc(\n  sqlite3_context *pContext,      /* SQLite function call context */\n  int nVal,                       /* Size of argument array */\n  sqlite3_value **apVal           /* Array of arguments */\n){\n  Fts3Cursor *pCsr;               /* Cursor handle passed through apVal[0] */\n  assert( nVal==1 || nVal==2 );\n  if( SQLITE_OK==fts3FunctionArg(pContext, \"matchinfo\", apVal[0], &pCsr) ){\n    const char *zArg = 0;\n    if( nVal>1 ){\n      zArg = (const char *)sqlite3_value_text(apVal[1]);\n    }\n    sqlite3Fts3Matchinfo(pContext, pCsr, zArg);\n  }\n}\n\n/*\n** This routine implements the xFindFunction method for the FTS3\n** virtual table.\n*/\nstatic int fts3FindFunctionMethod(\n  sqlite3_vtab *pVtab,            /* Virtual table handle */\n  int nArg,                       /* Number of SQL function arguments */\n  const char *zName,              /* Name of SQL function */\n  void (**pxFunc)(sqlite3_context*,int,sqlite3_value**), /* OUT: Result */\n  void **ppArg                    /* Unused */\n){\n  struct Overloaded {\n    const char *zName;\n    void (*xFunc)(sqlite3_context*,int,sqlite3_value**);\n  } aOverload[] = {\n    { \"snippet\", fts3SnippetFunc },\n    { \"offsets\", fts3OffsetsFunc },\n    { \"optimize\", fts3OptimizeFunc },\n    { \"matchinfo\", fts3MatchinfoFunc },\n  };\n  int i;                          /* Iterator variable */\n\n  UNUSED_PARAMETER(pVtab);\n  UNUSED_PARAMETER(nArg);\n  UNUSED_PARAMETER(ppArg);\n\n  for(i=0; i<SizeofArray(aOverload); i++){\n    if( strcmp(zName, aOverload[i].zName)==0 ){\n      *pxFunc = aOverload[i].xFunc;\n      return 1;\n    }\n  }\n\n  /* No function of the specified name was found. Return 0. */\n  return 0;\n}\n\n/*\n** Implementation of FTS3 xRename method. Rename an fts3 table.\n*/\nstatic int fts3RenameMethod(\n  sqlite3_vtab *pVtab,            /* Virtual table handle */\n  const char *zName               /* New name of table */\n){\n  Fts3Table *p = (Fts3Table *)pVtab;\n  sqlite3 *db = p->db;            /* Database connection */\n  int rc;                         /* Return Code */\n\n  rc = sqlite3Fts3PendingTermsFlush(p);\n  if( rc!=SQLITE_OK ){\n    return rc;\n  }\n\n  fts3DbExec(&rc, db,\n    \"ALTER TABLE %Q.'%q_content'  RENAME TO '%q_content';\",\n    p->zDb, p->zName, zName\n  );\n  if( p->bHasDocsize ){\n    fts3DbExec(&rc, db,\n      \"ALTER TABLE %Q.'%q_docsize'  RENAME TO '%q_docsize';\",\n      p->zDb, p->zName, zName\n    );\n  }\n  if( p->bHasStat ){\n    fts3DbExec(&rc, db,\n      \"ALTER TABLE %Q.'%q_stat'  RENAME TO '%q_stat';\",\n      p->zDb, p->zName, zName\n    );\n  }\n  fts3DbExec(&rc, db,\n    \"ALTER TABLE %Q.'%q_segments' RENAME TO '%q_segments';\",\n    p->zDb, p->zName, zName\n  );\n  fts3DbExec(&rc, db,\n    \"ALTER TABLE %Q.'%q_segdir'   RENAME TO '%q_segdir';\",\n    p->zDb, p->zName, zName\n  );\n  return rc;\n}\n\nstatic const sqlite3_module fts3Module = {\n  /* iVersion      */ 0,\n  /* xCreate       */ fts3CreateMethod,\n  /* xConnect      */ fts3ConnectMethod,\n  /* xBestIndex    */ fts3BestIndexMethod,\n  /* xDisconnect   */ fts3DisconnectMethod,\n  /* xDestroy      */ fts3DestroyMethod,\n  /* xOpen         */ fts3OpenMethod,\n  /* xClose        */ fts3CloseMethod,\n  /* xFilter       */ fts3FilterMethod,\n  /* xNext         */ fts3NextMethod,\n  /* xEof          */ fts3EofMethod,\n  /* xColumn       */ fts3ColumnMethod,\n  /* xRowid        */ fts3RowidMethod,\n  /* xUpdate       */ fts3UpdateMethod,\n  /* xBegin        */ fts3BeginMethod,\n  /* xSync         */ fts3SyncMethod,\n  /* xCommit       */ fts3CommitMethod,\n  /* xRollback     */ fts3RollbackMethod,\n  /* xFindFunction */ fts3FindFunctionMethod,\n  /* xRename */       fts3RenameMethod,\n};\n\n/*\n** This function is registered as the module destructor (called when an\n** FTS3 enabled database connection is closed). It frees the memory\n** allocated for the tokenizer hash table.\n*/\nstatic void hashDestroy(void *p){\n  Fts3Hash *pHash = (Fts3Hash *)p;\n  sqlite3Fts3HashClear(pHash);\n  sqlite3_free(pHash);\n}\n\n/*\n** The fts3 built-in tokenizers - \"simple\", \"porter\" and \"icu\"- are \n** implemented in files fts3_tokenizer1.c, fts3_porter.c and fts3_icu.c\n** respectively. The following three forward declarations are for functions\n** declared in these files used to retrieve the respective implementations.\n**\n** Calling sqlite3Fts3SimpleTokenizerModule() sets the value pointed\n** to by the argument to point to the \"simple\" tokenizer implementation.\n** And so on.\n*/\nSQLITE_PRIVATE void sqlite3Fts3SimpleTokenizerModule(sqlite3_tokenizer_module const**ppModule);\nSQLITE_PRIVATE void sqlite3Fts3PorterTokenizerModule(sqlite3_tokenizer_module const**ppModule);\n#ifdef SQLITE_ENABLE_ICU\nSQLITE_PRIVATE void sqlite3Fts3IcuTokenizerModule(sqlite3_tokenizer_module const**ppModule);\n#endif\n\n/*\n** Initialise the fts3 extension. If this extension is built as part\n** of the sqlite library, then this function is called directly by\n** SQLite. If fts3 is built as a dynamically loadable extension, this\n** function is called by the sqlite3_extension_init() entry point.\n*/\nSQLITE_PRIVATE int sqlite3Fts3Init(sqlite3 *db){\n  int rc = SQLITE_OK;\n  Fts3Hash *pHash = 0;\n  const sqlite3_tokenizer_module *pSimple = 0;\n  const sqlite3_tokenizer_module *pPorter = 0;\n\n#ifdef SQLITE_ENABLE_ICU\n  const sqlite3_tokenizer_module *pIcu = 0;\n  sqlite3Fts3IcuTokenizerModule(&pIcu);\n#endif\n\n  rc = sqlite3Fts3InitAux(db);\n  if( rc!=SQLITE_OK ) return rc;\n\n  sqlite3Fts3SimpleTokenizerModule(&pSimple);\n  sqlite3Fts3PorterTokenizerModule(&pPorter);\n\n  /* Allocate and initialise the hash-table used to store tokenizers. */\n  pHash = sqlite3_malloc(sizeof(Fts3Hash));\n  if( !pHash ){\n    rc = SQLITE_NOMEM;\n  }else{\n    sqlite3Fts3HashInit(pHash, FTS3_HASH_STRING, 1);\n  }\n\n  /* Load the built-in tokenizers into the hash table */\n  if( rc==SQLITE_OK ){\n    if( sqlite3Fts3HashInsert(pHash, \"simple\", 7, (void *)pSimple)\n     || sqlite3Fts3HashInsert(pHash, \"porter\", 7, (void *)pPorter) \n#ifdef SQLITE_ENABLE_ICU\n     || (pIcu && sqlite3Fts3HashInsert(pHash, \"icu\", 4, (void *)pIcu))\n#endif\n    ){\n      rc = SQLITE_NOMEM;\n    }\n  }\n\n#ifdef SQLITE_TEST\n  if( rc==SQLITE_OK ){\n    rc = sqlite3Fts3ExprInitTestInterface(db);\n  }\n#endif\n\n  /* Create the virtual table wrapper around the hash-table and overload \n  ** the two scalar functions. If this is successful, register the\n  ** module with sqlite.\n  */\n  if( SQLITE_OK==rc \n   && SQLITE_OK==(rc = sqlite3Fts3InitHashTable(db, pHash, \"fts3_tokenizer\"))\n   && SQLITE_OK==(rc = sqlite3_overload_function(db, \"snippet\", -1))\n   && SQLITE_OK==(rc = sqlite3_overload_function(db, \"offsets\", 1))\n   && SQLITE_OK==(rc = sqlite3_overload_function(db, \"matchinfo\", 1))\n   && SQLITE_OK==(rc = sqlite3_overload_function(db, \"matchinfo\", 2))\n   && SQLITE_OK==(rc = sqlite3_overload_function(db, \"optimize\", 1))\n  ){\n    rc = sqlite3_create_module_v2(\n        db, \"fts3\", &fts3Module, (void *)pHash, hashDestroy\n    );\n    if( rc==SQLITE_OK ){\n      rc = sqlite3_create_module_v2(\n          db, \"fts4\", &fts3Module, (void *)pHash, 0\n      );\n    }\n    return rc;\n  }\n\n  /* An error has occurred. Delete the hash table and return the error code. */\n  assert( rc!=SQLITE_OK );\n  if( pHash ){\n    sqlite3Fts3HashClear(pHash);\n    sqlite3_free(pHash);\n  }\n  return rc;\n}\n\n#if !SQLITE_CORE\nSQLITE_API int sqlite3_extension_init(\n  sqlite3 *db, \n  char **pzErrMsg,\n  const sqlite3_api_routines *pApi\n){\n  SQLITE_EXTENSION_INIT2(pApi)\n  return sqlite3Fts3Init(db);\n}\n#endif\n\n#endif\n\n/************** End of fts3.c ************************************************/\n/************** Begin file fts3_aux.c ****************************************/\n/*\n** 2011 Jan 27\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n******************************************************************************\n**\n*/\n\n#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS3)\n\n\ntypedef struct Fts3auxTable Fts3auxTable;\ntypedef struct Fts3auxCursor Fts3auxCursor;\n\nstruct Fts3auxTable {\n  sqlite3_vtab base;              /* Base class used by SQLite core */\n  Fts3Table *pFts3Tab;\n};\n\nstruct Fts3auxCursor {\n  sqlite3_vtab_cursor base;       /* Base class used by SQLite core */\n  Fts3SegReaderCursor csr;        /* Must be right after \"base\" */\n  Fts3SegFilter filter;\n  char *zStop;\n  int nStop;                      /* Byte-length of string zStop */\n  int isEof;                      /* True if cursor is at EOF */\n  sqlite3_int64 iRowid;           /* Current rowid */\n\n  int iCol;                       /* Current value of 'col' column */\n  int nStat;                      /* Size of aStat[] array */\n  struct Fts3auxColstats {\n    sqlite3_int64 nDoc;           /* 'documents' values for current csr row */\n    sqlite3_int64 nOcc;           /* 'occurrences' values for current csr row */\n  } *aStat;\n};\n\n/*\n** Schema of the terms table.\n*/\n#define FTS3_TERMS_SCHEMA \"CREATE TABLE x(term, col, documents, occurrences)\"\n\n/*\n** This function does all the work for both the xConnect and xCreate methods.\n** These tables have no persistent representation of their own, so xConnect\n** and xCreate are identical operations.\n*/\nstatic int fts3auxConnectMethod(\n  sqlite3 *db,                    /* Database connection */\n  void *pUnused,                  /* Unused */\n  int argc,                       /* Number of elements in argv array */\n  const char * const *argv,       /* xCreate/xConnect argument array */\n  sqlite3_vtab **ppVtab,          /* OUT: New sqlite3_vtab object */\n  char **pzErr                    /* OUT: sqlite3_malloc'd error message */\n){\n  char const *zDb;                /* Name of database (e.g. \"main\") */\n  char const *zFts3;              /* Name of fts3 table */\n  int nDb;                        /* Result of strlen(zDb) */\n  int nFts3;                      /* Result of strlen(zFts3) */\n  int nByte;                      /* Bytes of space to allocate here */\n  int rc;                         /* value returned by declare_vtab() */\n  Fts3auxTable *p;                /* Virtual table object to return */\n\n  /* The user should specify a single argument - the name of an fts3 table. */\n  if( argc!=4 ){\n    *pzErr = sqlite3_mprintf(\n        \"wrong number of arguments to fts4aux constructor\"\n    );\n    return SQLITE_ERROR;\n  }\n\n  zDb = argv[1]; \n  nDb = strlen(zDb);\n  zFts3 = argv[3];\n  nFts3 = strlen(zFts3);\n\n  rc = sqlite3_declare_vtab(db, FTS3_TERMS_SCHEMA);\n  if( rc!=SQLITE_OK ) return rc;\n\n  nByte = sizeof(Fts3auxTable) + sizeof(Fts3Table) + nDb + nFts3 + 2;\n  p = (Fts3auxTable *)sqlite3_malloc(nByte);\n  if( !p ) return SQLITE_NOMEM;\n  memset(p, 0, nByte);\n\n  p->pFts3Tab = (Fts3Table *)&p[1];\n  p->pFts3Tab->zDb = (char *)&p->pFts3Tab[1];\n  p->pFts3Tab->zName = &p->pFts3Tab->zDb[nDb+1];\n  p->pFts3Tab->db = db;\n\n  memcpy((char *)p->pFts3Tab->zDb, zDb, nDb);\n  memcpy((char *)p->pFts3Tab->zName, zFts3, nFts3);\n  sqlite3Fts3Dequote((char *)p->pFts3Tab->zName);\n\n  *ppVtab = (sqlite3_vtab *)p;\n  return SQLITE_OK;\n}\n\n/*\n** This function does the work for both the xDisconnect and xDestroy methods.\n** These tables have no persistent representation of their own, so xDisconnect\n** and xDestroy are identical operations.\n*/\nstatic int fts3auxDisconnectMethod(sqlite3_vtab *pVtab){\n  Fts3auxTable *p = (Fts3auxTable *)pVtab;\n  Fts3Table *pFts3 = p->pFts3Tab;\n  int i;\n\n  /* Free any prepared statements held */\n  for(i=0; i<SizeofArray(pFts3->aStmt); i++){\n    sqlite3_finalize(pFts3->aStmt[i]);\n  }\n  sqlite3_free(pFts3->zSegmentsTbl);\n  sqlite3_free(p);\n  return SQLITE_OK;\n}\n\n#define FTS4AUX_EQ_CONSTRAINT 1\n#define FTS4AUX_GE_CONSTRAINT 2\n#define FTS4AUX_LE_CONSTRAINT 4\n\n/*\n** xBestIndex - Analyze a WHERE and ORDER BY clause.\n*/\nstatic int fts3auxBestIndexMethod(\n  sqlite3_vtab *pVTab, \n  sqlite3_index_info *pInfo\n){\n  int i;\n  int iEq = -1;\n  int iGe = -1;\n  int iLe = -1;\n\n  /* This vtab delivers always results in \"ORDER BY term ASC\" order. */\n  if( pInfo->nOrderBy==1 \n   && pInfo->aOrderBy[0].iColumn==0 \n   && pInfo->aOrderBy[0].desc==0\n  ){\n    pInfo->orderByConsumed = 1;\n  }\n\n  /* Search for equality and range constraints on the \"term\" column. */\n  for(i=0; i<pInfo->nConstraint; i++){\n    if( pInfo->aConstraint[i].usable && pInfo->aConstraint[i].iColumn==0 ){\n      int op = pInfo->aConstraint[i].op;\n      if( op==SQLITE_INDEX_CONSTRAINT_EQ ) iEq = i;\n      if( op==SQLITE_INDEX_CONSTRAINT_LT ) iLe = i;\n      if( op==SQLITE_INDEX_CONSTRAINT_LE ) iLe = i;\n      if( op==SQLITE_INDEX_CONSTRAINT_GT ) iGe = i;\n      if( op==SQLITE_INDEX_CONSTRAINT_GE ) iGe = i;\n    }\n  }\n\n  if( iEq>=0 ){\n    pInfo->idxNum = FTS4AUX_EQ_CONSTRAINT;\n    pInfo->aConstraintUsage[iEq].argvIndex = 1;\n    pInfo->estimatedCost = 5;\n  }else{\n    pInfo->idxNum = 0;\n    pInfo->estimatedCost = 20000;\n    if( iGe>=0 ){\n      pInfo->idxNum += FTS4AUX_GE_CONSTRAINT;\n      pInfo->aConstraintUsage[iGe].argvIndex = 1;\n      pInfo->estimatedCost /= 2;\n    }\n    if( iLe>=0 ){\n      pInfo->idxNum += FTS4AUX_LE_CONSTRAINT;\n      pInfo->aConstraintUsage[iLe].argvIndex = 1 + (iGe>=0);\n      pInfo->estimatedCost /= 2;\n    }\n  }\n\n  return SQLITE_OK;\n}\n\n/*\n** xOpen - Open a cursor.\n*/\nstatic int fts3auxOpenMethod(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCsr){\n  Fts3auxCursor *pCsr;            /* Pointer to cursor object to return */\n\n  pCsr = (Fts3auxCursor *)sqlite3_malloc(sizeof(Fts3auxCursor));\n  if( !pCsr ) return SQLITE_NOMEM;\n  memset(pCsr, 0, sizeof(Fts3auxCursor));\n\n  *ppCsr = (sqlite3_vtab_cursor *)pCsr;\n  return SQLITE_OK;\n}\n\n/*\n** xClose - Close a cursor.\n*/\nstatic int fts3auxCloseMethod(sqlite3_vtab_cursor *pCursor){\n  Fts3Table *pFts3 = ((Fts3auxTable *)pCursor->pVtab)->pFts3Tab;\n  Fts3auxCursor *pCsr = (Fts3auxCursor *)pCursor;\n\n  sqlite3Fts3SegmentsClose(pFts3);\n  sqlite3Fts3SegReaderFinish(&pCsr->csr);\n  sqlite3_free((void *)pCsr->filter.zTerm);\n  sqlite3_free(pCsr->zStop);\n  sqlite3_free(pCsr->aStat);\n  sqlite3_free(pCsr);\n  return SQLITE_OK;\n}\n\nstatic int fts3auxGrowStatArray(Fts3auxCursor *pCsr, int nSize){\n  if( nSize>pCsr->nStat ){\n    struct Fts3auxColstats *aNew;\n    aNew = (struct Fts3auxColstats *)sqlite3_realloc(pCsr->aStat, \n        sizeof(struct Fts3auxColstats) * nSize\n    );\n    if( aNew==0 ) return SQLITE_NOMEM;\n    memset(&aNew[pCsr->nStat], 0, \n        sizeof(struct Fts3auxColstats) * (nSize - pCsr->nStat)\n    );\n    pCsr->aStat = aNew;\n    pCsr->nStat = nSize;\n  }\n  return SQLITE_OK;\n}\n\n/*\n** xNext - Advance the cursor to the next row, if any.\n*/\nstatic int fts3auxNextMethod(sqlite3_vtab_cursor *pCursor){\n  Fts3auxCursor *pCsr = (Fts3auxCursor *)pCursor;\n  Fts3Table *pFts3 = ((Fts3auxTable *)pCursor->pVtab)->pFts3Tab;\n  int rc;\n\n  /* Increment our pretend rowid value. */\n  pCsr->iRowid++;\n\n  for(pCsr->iCol++; pCsr->iCol<pCsr->nStat; pCsr->iCol++){\n    if( pCsr->aStat[pCsr->iCol].nDoc>0 ) return SQLITE_OK;\n  }\n\n  rc = sqlite3Fts3SegReaderStep(pFts3, &pCsr->csr);\n  if( rc==SQLITE_ROW ){\n    int i = 0;\n    int nDoclist = pCsr->csr.nDoclist;\n    char *aDoclist = pCsr->csr.aDoclist;\n    int iCol;\n\n    int eState = 0;\n\n    if( pCsr->zStop ){\n      int n = (pCsr->nStop<pCsr->csr.nTerm) ? pCsr->nStop : pCsr->csr.nTerm;\n      int mc = memcmp(pCsr->zStop, pCsr->csr.zTerm, n);\n      if( mc<0 || (mc==0 && pCsr->csr.nTerm>pCsr->nStop) ){\n        pCsr->isEof = 1;\n        return SQLITE_OK;\n      }\n    }\n\n    if( fts3auxGrowStatArray(pCsr, 2) ) return SQLITE_NOMEM;\n    memset(pCsr->aStat, 0, sizeof(struct Fts3auxColstats) * pCsr->nStat);\n    iCol = 0;\n\n    while( i<nDoclist ){\n      sqlite3_int64 v = 0;\n\n      i += sqlite3Fts3GetVarint(&aDoclist[i], &v);\n      switch( eState ){\n        /* State 0. In this state the integer just read was a docid. */\n        case 0:\n          pCsr->aStat[0].nDoc++;\n          eState = 1;\n          iCol = 0;\n          break;\n\n        /* State 1. In this state we are expecting either a 1, indicating\n        ** that the following integer will be a column number, or the\n        ** start of a position list for column 0.  \n        ** \n        ** The only difference between state 1 and state 2 is that if the\n        ** integer encountered in state 1 is not 0 or 1, then we need to\n        ** increment the column 0 \"nDoc\" count for this term.\n        */\n        case 1:\n          assert( iCol==0 );\n          if( v>1 ){\n            pCsr->aStat[1].nDoc++;\n          }\n          eState = 2;\n          /* fall through */\n\n        case 2:\n          if( v==0 ){       /* 0x00. Next integer will be a docid. */\n            eState = 0;\n          }else if( v==1 ){ /* 0x01. Next integer will be a column number. */\n            eState = 3;\n          }else{            /* 2 or greater. A position. */\n            pCsr->aStat[iCol+1].nOcc++;\n            pCsr->aStat[0].nOcc++;\n          }\n          break;\n\n        /* State 3. The integer just read is a column number. */\n        default: assert( eState==3 );\n          iCol = (int)v;\n          if( fts3auxGrowStatArray(pCsr, iCol+2) ) return SQLITE_NOMEM;\n          pCsr->aStat[iCol+1].nDoc++;\n          eState = 2;\n          break;\n      }\n    }\n\n    pCsr->iCol = 0;\n    rc = SQLITE_OK;\n  }else{\n    pCsr->isEof = 1;\n  }\n  return rc;\n}\n\n/*\n** xFilter - Initialize a cursor to point at the start of its data.\n*/\nstatic int fts3auxFilterMethod(\n  sqlite3_vtab_cursor *pCursor,   /* The cursor used for this query */\n  int idxNum,                     /* Strategy index */\n  const char *idxStr,             /* Unused */\n  int nVal,                       /* Number of elements in apVal */\n  sqlite3_value **apVal           /* Arguments for the indexing scheme */\n){\n  Fts3auxCursor *pCsr = (Fts3auxCursor *)pCursor;\n  Fts3Table *pFts3 = ((Fts3auxTable *)pCursor->pVtab)->pFts3Tab;\n  int rc;\n  int isScan;\n\n  assert( idxStr==0 );\n  assert( idxNum==FTS4AUX_EQ_CONSTRAINT || idxNum==0\n       || idxNum==FTS4AUX_LE_CONSTRAINT || idxNum==FTS4AUX_GE_CONSTRAINT\n       || idxNum==(FTS4AUX_LE_CONSTRAINT|FTS4AUX_GE_CONSTRAINT)\n  );\n  isScan = (idxNum!=FTS4AUX_EQ_CONSTRAINT);\n\n  /* In case this cursor is being reused, close and zero it. */\n  testcase(pCsr->filter.zTerm);\n  sqlite3Fts3SegReaderFinish(&pCsr->csr);\n  sqlite3_free((void *)pCsr->filter.zTerm);\n  sqlite3_free(pCsr->aStat);\n  memset(&pCsr->csr, 0, ((u8*)&pCsr[1]) - (u8*)&pCsr->csr);\n\n  pCsr->filter.flags = FTS3_SEGMENT_REQUIRE_POS|FTS3_SEGMENT_IGNORE_EMPTY;\n  if( isScan ) pCsr->filter.flags |= FTS3_SEGMENT_SCAN;\n\n  if( idxNum&(FTS4AUX_EQ_CONSTRAINT|FTS4AUX_GE_CONSTRAINT) ){\n    const unsigned char *zStr = sqlite3_value_text(apVal[0]);\n    if( zStr ){\n      pCsr->filter.zTerm = sqlite3_mprintf(\"%s\", zStr);\n      pCsr->filter.nTerm = sqlite3_value_bytes(apVal[0]);\n      if( pCsr->filter.zTerm==0 ) return SQLITE_NOMEM;\n    }\n  }\n  if( idxNum&FTS4AUX_LE_CONSTRAINT ){\n    int iIdx = (idxNum&FTS4AUX_GE_CONSTRAINT) ? 1 : 0;\n    pCsr->zStop = sqlite3_mprintf(\"%s\", sqlite3_value_text(apVal[iIdx]));\n    pCsr->nStop = sqlite3_value_bytes(apVal[iIdx]);\n    if( pCsr->zStop==0 ) return SQLITE_NOMEM;\n  }\n\n  rc = sqlite3Fts3SegReaderCursor(pFts3, FTS3_SEGCURSOR_ALL,\n      pCsr->filter.zTerm, pCsr->filter.nTerm, 0, isScan, &pCsr->csr\n  );\n  if( rc==SQLITE_OK ){\n    rc = sqlite3Fts3SegReaderStart(pFts3, &pCsr->csr, &pCsr->filter);\n  }\n\n  if( rc==SQLITE_OK ) rc = fts3auxNextMethod(pCursor);\n  return rc;\n}\n\n/*\n** xEof - Return true if the cursor is at EOF, or false otherwise.\n*/\nstatic int fts3auxEofMethod(sqlite3_vtab_cursor *pCursor){\n  Fts3auxCursor *pCsr = (Fts3auxCursor *)pCursor;\n  return pCsr->isEof;\n}\n\n/*\n** xColumn - Return a column value.\n*/\nstatic int fts3auxColumnMethod(\n  sqlite3_vtab_cursor *pCursor,   /* Cursor to retrieve value from */\n  sqlite3_context *pContext,      /* Context for sqlite3_result_xxx() calls */\n  int iCol                        /* Index of column to read value from */\n){\n  Fts3auxCursor *p = (Fts3auxCursor *)pCursor;\n\n  assert( p->isEof==0 );\n  if( iCol==0 ){        /* Column \"term\" */\n    sqlite3_result_text(pContext, p->csr.zTerm, p->csr.nTerm, SQLITE_TRANSIENT);\n  }else if( iCol==1 ){  /* Column \"col\" */\n    if( p->iCol ){\n      sqlite3_result_int(pContext, p->iCol-1);\n    }else{\n      sqlite3_result_text(pContext, \"*\", -1, SQLITE_STATIC);\n    }\n  }else if( iCol==2 ){  /* Column \"documents\" */\n    sqlite3_result_int64(pContext, p->aStat[p->iCol].nDoc);\n  }else{                /* Column \"occurrences\" */\n    sqlite3_result_int64(pContext, p->aStat[p->iCol].nOcc);\n  }\n\n  return SQLITE_OK;\n}\n\n/*\n** xRowid - Return the current rowid for the cursor.\n*/\nstatic int fts3auxRowidMethod(\n  sqlite3_vtab_cursor *pCursor,   /* Cursor to retrieve value from */\n  sqlite_int64 *pRowid            /* OUT: Rowid value */\n){\n  Fts3auxCursor *pCsr = (Fts3auxCursor *)pCursor;\n  *pRowid = pCsr->iRowid;\n  return SQLITE_OK;\n}\n\n/*\n** Register the fts3aux module with database connection db. Return SQLITE_OK\n** if successful or an error code if sqlite3_create_module() fails.\n*/\nSQLITE_PRIVATE int sqlite3Fts3InitAux(sqlite3 *db){\n  static const sqlite3_module fts3aux_module = {\n     0,                           /* iVersion      */\n     fts3auxConnectMethod,        /* xCreate       */\n     fts3auxConnectMethod,        /* xConnect      */\n     fts3auxBestIndexMethod,      /* xBestIndex    */\n     fts3auxDisconnectMethod,     /* xDisconnect   */\n     fts3auxDisconnectMethod,     /* xDestroy      */\n     fts3auxOpenMethod,           /* xOpen         */\n     fts3auxCloseMethod,          /* xClose        */\n     fts3auxFilterMethod,         /* xFilter       */\n     fts3auxNextMethod,           /* xNext         */\n     fts3auxEofMethod,            /* xEof          */\n     fts3auxColumnMethod,         /* xColumn       */\n     fts3auxRowidMethod,          /* xRowid        */\n     0,                           /* xUpdate       */\n     0,                           /* xBegin        */\n     0,                           /* xSync         */\n     0,                           /* xCommit       */\n     0,                           /* xRollback     */\n     0,                           /* xFindFunction */\n     0                            /* xRename       */\n  };\n  int rc;                         /* Return code */\n\n  rc = sqlite3_create_module(db, \"fts4aux\", &fts3aux_module, 0);\n  return rc;\n}\n\n#endif /* !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS3) */\n\n/************** End of fts3_aux.c ********************************************/\n/************** Begin file fts3_expr.c ***************************************/\n/*\n** 2008 Nov 28\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n******************************************************************************\n**\n** This module contains code that implements a parser for fts3 query strings\n** (the right-hand argument to the MATCH operator). Because the supported \n** syntax is relatively simple, the whole tokenizer/parser system is\n** hand-coded. \n*/\n#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS3)\n\n/*\n** By default, this module parses the legacy syntax that has been \n** traditionally used by fts3. Or, if SQLITE_ENABLE_FTS3_PARENTHESIS\n** is defined, then it uses the new syntax. The differences between\n** the new and the old syntaxes are:\n**\n**  a) The new syntax supports parenthesis. The old does not.\n**\n**  b) The new syntax supports the AND and NOT operators. The old does not.\n**\n**  c) The old syntax supports the \"-\" token qualifier. This is not \n**     supported by the new syntax (it is replaced by the NOT operator).\n**\n**  d) When using the old syntax, the OR operator has a greater precedence\n**     than an implicit AND. When using the new, both implicity and explicit\n**     AND operators have a higher precedence than OR.\n**\n** If compiled with SQLITE_TEST defined, then this module exports the\n** symbol \"int sqlite3_fts3_enable_parentheses\". Setting this variable\n** to zero causes the module to use the old syntax. If it is set to \n** non-zero the new syntax is activated. This is so both syntaxes can\n** be tested using a single build of testfixture.\n**\n** The following describes the syntax supported by the fts3 MATCH\n** operator in a similar format to that used by the lemon parser\n** generator. This module does not use actually lemon, it uses a\n** custom parser.\n**\n**   query ::= andexpr (OR andexpr)*.\n**\n**   andexpr ::= notexpr (AND? notexpr)*.\n**\n**   notexpr ::= nearexpr (NOT nearexpr|-TOKEN)*.\n**   notexpr ::= LP query RP.\n**\n**   nearexpr ::= phrase (NEAR distance_opt nearexpr)*.\n**\n**   distance_opt ::= .\n**   distance_opt ::= / INTEGER.\n**\n**   phrase ::= TOKEN.\n**   phrase ::= COLUMN:TOKEN.\n**   phrase ::= \"TOKEN TOKEN TOKEN...\".\n*/\n\n#ifdef SQLITE_TEST\nSQLITE_API int sqlite3_fts3_enable_parentheses = 0;\n#else\n# ifdef SQLITE_ENABLE_FTS3_PARENTHESIS \n#  define sqlite3_fts3_enable_parentheses 1\n# else\n#  define sqlite3_fts3_enable_parentheses 0\n# endif\n#endif\n\n/*\n** Default span for NEAR operators.\n*/\n#define SQLITE_FTS3_DEFAULT_NEAR_PARAM 10\n\n\ntypedef struct ParseContext ParseContext;\nstruct ParseContext {\n  sqlite3_tokenizer *pTokenizer;      /* Tokenizer module */\n  const char **azCol;                 /* Array of column names for fts3 table */\n  int nCol;                           /* Number of entries in azCol[] */\n  int iDefaultCol;                    /* Default column to query */\n  sqlite3_context *pCtx;              /* Write error message here */\n  int nNest;                          /* Number of nested brackets */\n};\n\n/*\n** This function is equivalent to the standard isspace() function. \n**\n** The standard isspace() can be awkward to use safely, because although it\n** is defined to accept an argument of type int, its behaviour when passed\n** an integer that falls outside of the range of the unsigned char type\n** is undefined (and sometimes, \"undefined\" means segfault). This wrapper\n** is defined to accept an argument of type char, and always returns 0 for\n** any values that fall outside of the range of the unsigned char type (i.e.\n** negative values).\n*/\nstatic int fts3isspace(char c){\n  return c==' ' || c=='\\t' || c=='\\n' || c=='\\r' || c=='\\v' || c=='\\f';\n}\n\n/*\n** Allocate nByte bytes of memory using sqlite3_malloc(). If successful,\n** zero the memory before returning a pointer to it. If unsuccessful, \n** return NULL.\n*/\nstatic void *fts3MallocZero(int nByte){\n  void *pRet = sqlite3_malloc(nByte);\n  if( pRet ) memset(pRet, 0, nByte);\n  return pRet;\n}\n\n\n/*\n** Extract the next token from buffer z (length n) using the tokenizer\n** and other information (column names etc.) in pParse. Create an Fts3Expr\n** structure of type FTSQUERY_PHRASE containing a phrase consisting of this\n** single token and set *ppExpr to point to it. If the end of the buffer is\n** reached before a token is found, set *ppExpr to zero. It is the\n** responsibility of the caller to eventually deallocate the allocated \n** Fts3Expr structure (if any) by passing it to sqlite3_free().\n**\n** Return SQLITE_OK if successful, or SQLITE_NOMEM if a memory allocation\n** fails.\n*/\nstatic int getNextToken(\n  ParseContext *pParse,                   /* fts3 query parse context */\n  int iCol,                               /* Value for Fts3Phrase.iColumn */\n  const char *z, int n,                   /* Input string */\n  Fts3Expr **ppExpr,                      /* OUT: expression */\n  int *pnConsumed                         /* OUT: Number of bytes consumed */\n){\n  sqlite3_tokenizer *pTokenizer = pParse->pTokenizer;\n  sqlite3_tokenizer_module const *pModule = pTokenizer->pModule;\n  int rc;\n  sqlite3_tokenizer_cursor *pCursor;\n  Fts3Expr *pRet = 0;\n  int nConsumed = 0;\n\n  rc = pModule->xOpen(pTokenizer, z, n, &pCursor);\n  if( rc==SQLITE_OK ){\n    const char *zToken;\n    int nToken, iStart, iEnd, iPosition;\n    int nByte;                               /* total space to allocate */\n\n    pCursor->pTokenizer = pTokenizer;\n    rc = pModule->xNext(pCursor, &zToken, &nToken, &iStart, &iEnd, &iPosition);\n\n    if( rc==SQLITE_OK ){\n      nByte = sizeof(Fts3Expr) + sizeof(Fts3Phrase) + nToken;\n      pRet = (Fts3Expr *)fts3MallocZero(nByte);\n      if( !pRet ){\n        rc = SQLITE_NOMEM;\n      }else{\n        pRet->eType = FTSQUERY_PHRASE;\n        pRet->pPhrase = (Fts3Phrase *)&pRet[1];\n        pRet->pPhrase->nToken = 1;\n        pRet->pPhrase->iColumn = iCol;\n        pRet->pPhrase->aToken[0].n = nToken;\n        pRet->pPhrase->aToken[0].z = (char *)&pRet->pPhrase[1];\n        memcpy(pRet->pPhrase->aToken[0].z, zToken, nToken);\n\n        if( iEnd<n && z[iEnd]=='*' ){\n          pRet->pPhrase->aToken[0].isPrefix = 1;\n          iEnd++;\n        }\n        if( !sqlite3_fts3_enable_parentheses && iStart>0 && z[iStart-1]=='-' ){\n          pRet->pPhrase->isNot = 1;\n        }\n      }\n      nConsumed = iEnd;\n    }\n\n    pModule->xClose(pCursor);\n  }\n  \n  *pnConsumed = nConsumed;\n  *ppExpr = pRet;\n  return rc;\n}\n\n\n/*\n** Enlarge a memory allocation.  If an out-of-memory allocation occurs,\n** then free the old allocation.\n*/\nstatic void *fts3ReallocOrFree(void *pOrig, int nNew){\n  void *pRet = sqlite3_realloc(pOrig, nNew);\n  if( !pRet ){\n    sqlite3_free(pOrig);\n  }\n  return pRet;\n}\n\n/*\n** Buffer zInput, length nInput, contains the contents of a quoted string\n** that appeared as part of an fts3 query expression. Neither quote character\n** is included in the buffer. This function attempts to tokenize the entire\n** input buffer and create an Fts3Expr structure of type FTSQUERY_PHRASE \n** containing the results.\n**\n** If successful, SQLITE_OK is returned and *ppExpr set to point at the\n** allocated Fts3Expr structure. Otherwise, either SQLITE_NOMEM (out of memory\n** error) or SQLITE_ERROR (tokenization error) is returned and *ppExpr set\n** to 0.\n*/\nstatic int getNextString(\n  ParseContext *pParse,                   /* fts3 query parse context */\n  const char *zInput, int nInput,         /* Input string */\n  Fts3Expr **ppExpr                       /* OUT: expression */\n){\n  sqlite3_tokenizer *pTokenizer = pParse->pTokenizer;\n  sqlite3_tokenizer_module const *pModule = pTokenizer->pModule;\n  int rc;\n  Fts3Expr *p = 0;\n  sqlite3_tokenizer_cursor *pCursor = 0;\n  char *zTemp = 0;\n  int nTemp = 0;\n\n  rc = pModule->xOpen(pTokenizer, zInput, nInput, &pCursor);\n  if( rc==SQLITE_OK ){\n    int ii;\n    pCursor->pTokenizer = pTokenizer;\n    for(ii=0; rc==SQLITE_OK; ii++){\n      const char *zToken;\n      int nToken, iBegin, iEnd, iPos;\n      rc = pModule->xNext(pCursor, &zToken, &nToken, &iBegin, &iEnd, &iPos);\n      if( rc==SQLITE_OK ){\n        int nByte = sizeof(Fts3Expr) + sizeof(Fts3Phrase);\n        p = fts3ReallocOrFree(p, nByte+ii*sizeof(Fts3PhraseToken));\n        zTemp = fts3ReallocOrFree(zTemp, nTemp + nToken);\n        if( !p || !zTemp ){\n          goto no_mem;\n        }\n        if( ii==0 ){\n          memset(p, 0, nByte);\n          p->pPhrase = (Fts3Phrase *)&p[1];\n        }\n        p->pPhrase = (Fts3Phrase *)&p[1];\n        memset(&p->pPhrase->aToken[ii], 0, sizeof(Fts3PhraseToken));\n        p->pPhrase->nToken = ii+1;\n        p->pPhrase->aToken[ii].n = nToken;\n        memcpy(&zTemp[nTemp], zToken, nToken);\n        nTemp += nToken;\n        if( iEnd<nInput && zInput[iEnd]=='*' ){\n          p->pPhrase->aToken[ii].isPrefix = 1;\n        }else{\n          p->pPhrase->aToken[ii].isPrefix = 0;\n        }\n      }\n    }\n\n    pModule->xClose(pCursor);\n    pCursor = 0;\n  }\n\n  if( rc==SQLITE_DONE ){\n    int jj;\n    char *zNew = NULL;\n    int nNew = 0;\n    int nByte = sizeof(Fts3Expr) + sizeof(Fts3Phrase);\n    nByte += (p?(p->pPhrase->nToken-1):0) * sizeof(Fts3PhraseToken);\n    p = fts3ReallocOrFree(p, nByte + nTemp);\n    if( !p ){\n      goto no_mem;\n    }\n    if( zTemp ){\n      zNew = &(((char *)p)[nByte]);\n      memcpy(zNew, zTemp, nTemp);\n    }else{\n      memset(p, 0, nByte+nTemp);\n    }\n    p->pPhrase = (Fts3Phrase *)&p[1];\n    for(jj=0; jj<p->pPhrase->nToken; jj++){\n      p->pPhrase->aToken[jj].z = &zNew[nNew];\n      nNew += p->pPhrase->aToken[jj].n;\n    }\n    sqlite3_free(zTemp);\n    p->eType = FTSQUERY_PHRASE;\n    p->pPhrase->iColumn = pParse->iDefaultCol;\n    rc = SQLITE_OK;\n  }\n\n  *ppExpr = p;\n  return rc;\nno_mem:\n\n  if( pCursor ){\n    pModule->xClose(pCursor);\n  }\n  sqlite3_free(zTemp);\n  sqlite3_free(p);\n  *ppExpr = 0;\n  return SQLITE_NOMEM;\n}\n\n/*\n** Function getNextNode(), which is called by fts3ExprParse(), may itself\n** call fts3ExprParse(). So this forward declaration is required.\n*/\nstatic int fts3ExprParse(ParseContext *, const char *, int, Fts3Expr **, int *);\n\n/*\n** The output variable *ppExpr is populated with an allocated Fts3Expr \n** structure, or set to 0 if the end of the input buffer is reached.\n**\n** Returns an SQLite error code. SQLITE_OK if everything works, SQLITE_NOMEM\n** if a malloc failure occurs, or SQLITE_ERROR if a parse error is encountered.\n** If SQLITE_ERROR is returned, pContext is populated with an error message.\n*/\nstatic int getNextNode(\n  ParseContext *pParse,                   /* fts3 query parse context */\n  const char *z, int n,                   /* Input string */\n  Fts3Expr **ppExpr,                      /* OUT: expression */\n  int *pnConsumed                         /* OUT: Number of bytes consumed */\n){\n  static const struct Fts3Keyword {\n    char *z;                              /* Keyword text */\n    unsigned char n;                      /* Length of the keyword */\n    unsigned char parenOnly;              /* Only valid in paren mode */\n    unsigned char eType;                  /* Keyword code */\n  } aKeyword[] = {\n    { \"OR\" ,  2, 0, FTSQUERY_OR   },\n    { \"AND\",  3, 1, FTSQUERY_AND  },\n    { \"NOT\",  3, 1, FTSQUERY_NOT  },\n    { \"NEAR\", 4, 0, FTSQUERY_NEAR }\n  };\n  int ii;\n  int iCol;\n  int iColLen;\n  int rc;\n  Fts3Expr *pRet = 0;\n\n  const char *zInput = z;\n  int nInput = n;\n\n  /* Skip over any whitespace before checking for a keyword, an open or\n  ** close bracket, or a quoted string. \n  */\n  while( nInput>0 && fts3isspace(*zInput) ){\n    nInput--;\n    zInput++;\n  }\n  if( nInput==0 ){\n    return SQLITE_DONE;\n  }\n\n  /* See if we are dealing with a keyword. */\n  for(ii=0; ii<(int)(sizeof(aKeyword)/sizeof(struct Fts3Keyword)); ii++){\n    const struct Fts3Keyword *pKey = &aKeyword[ii];\n\n    if( (pKey->parenOnly & ~sqlite3_fts3_enable_parentheses)!=0 ){\n      continue;\n    }\n\n    if( nInput>=pKey->n && 0==memcmp(zInput, pKey->z, pKey->n) ){\n      int nNear = SQLITE_FTS3_DEFAULT_NEAR_PARAM;\n      int nKey = pKey->n;\n      char cNext;\n\n      /* If this is a \"NEAR\" keyword, check for an explicit nearness. */\n      if( pKey->eType==FTSQUERY_NEAR ){\n        assert( nKey==4 );\n        if( zInput[4]=='/' && zInput[5]>='0' && zInput[5]<='9' ){\n          nNear = 0;\n          for(nKey=5; zInput[nKey]>='0' && zInput[nKey]<='9'; nKey++){\n            nNear = nNear * 10 + (zInput[nKey] - '0');\n          }\n        }\n      }\n\n      /* At this point this is probably a keyword. But for that to be true,\n      ** the next byte must contain either whitespace, an open or close\n      ** parenthesis, a quote character, or EOF. \n      */\n      cNext = zInput[nKey];\n      if( fts3isspace(cNext) \n       || cNext=='\"' || cNext=='(' || cNext==')' || cNext==0\n      ){\n        pRet = (Fts3Expr *)fts3MallocZero(sizeof(Fts3Expr));\n        if( !pRet ){\n          return SQLITE_NOMEM;\n        }\n        pRet->eType = pKey->eType;\n        pRet->nNear = nNear;\n        *ppExpr = pRet;\n        *pnConsumed = (int)((zInput - z) + nKey);\n        return SQLITE_OK;\n      }\n\n      /* Turns out that wasn't a keyword after all. This happens if the\n      ** user has supplied a token such as \"ORacle\". Continue.\n      */\n    }\n  }\n\n  /* Check for an open bracket. */\n  if( sqlite3_fts3_enable_parentheses ){\n    if( *zInput=='(' ){\n      int nConsumed;\n      pParse->nNest++;\n      rc = fts3ExprParse(pParse, &zInput[1], nInput-1, ppExpr, &nConsumed);\n      if( rc==SQLITE_OK && !*ppExpr ){\n        rc = SQLITE_DONE;\n      }\n      *pnConsumed = (int)((zInput - z) + 1 + nConsumed);\n      return rc;\n    }\n  \n    /* Check for a close bracket. */\n    if( *zInput==')' ){\n      pParse->nNest--;\n      *pnConsumed = (int)((zInput - z) + 1);\n      return SQLITE_DONE;\n    }\n  }\n\n  /* See if we are dealing with a quoted phrase. If this is the case, then\n  ** search for the closing quote and pass the whole string to getNextString()\n  ** for processing. This is easy to do, as fts3 has no syntax for escaping\n  ** a quote character embedded in a string.\n  */\n  if( *zInput=='\"' ){\n    for(ii=1; ii<nInput && zInput[ii]!='\"'; ii++);\n    *pnConsumed = (int)((zInput - z) + ii + 1);\n    if( ii==nInput ){\n      return SQLITE_ERROR;\n    }\n    return getNextString(pParse, &zInput[1], ii-1, ppExpr);\n  }\n\n\n  /* If control flows to this point, this must be a regular token, or \n  ** the end of the input. Read a regular token using the sqlite3_tokenizer\n  ** interface. Before doing so, figure out if there is an explicit\n  ** column specifier for the token. \n  **\n  ** TODO: Strangely, it is not possible to associate a column specifier\n  ** with a quoted phrase, only with a single token. Not sure if this was\n  ** an implementation artifact or an intentional decision when fts3 was\n  ** first implemented. Whichever it was, this module duplicates the \n  ** limitation.\n  */\n  iCol = pParse->iDefaultCol;\n  iColLen = 0;\n  for(ii=0; ii<pParse->nCol; ii++){\n    const char *zStr = pParse->azCol[ii];\n    int nStr = (int)strlen(zStr);\n    if( nInput>nStr && zInput[nStr]==':' \n     && sqlite3_strnicmp(zStr, zInput, nStr)==0 \n    ){\n      iCol = ii;\n      iColLen = (int)((zInput - z) + nStr + 1);\n      break;\n    }\n  }\n  rc = getNextToken(pParse, iCol, &z[iColLen], n-iColLen, ppExpr, pnConsumed);\n  *pnConsumed += iColLen;\n  return rc;\n}\n\n/*\n** The argument is an Fts3Expr structure for a binary operator (any type\n** except an FTSQUERY_PHRASE). Return an integer value representing the\n** precedence of the operator. Lower values have a higher precedence (i.e.\n** group more tightly). For example, in the C language, the == operator\n** groups more tightly than ||, and would therefore have a higher precedence.\n**\n** When using the new fts3 query syntax (when SQLITE_ENABLE_FTS3_PARENTHESIS\n** is defined), the order of the operators in precedence from highest to\n** lowest is:\n**\n**   NEAR\n**   NOT\n**   AND (including implicit ANDs)\n**   OR\n**\n** Note that when using the old query syntax, the OR operator has a higher\n** precedence than the AND operator.\n*/\nstatic int opPrecedence(Fts3Expr *p){\n  assert( p->eType!=FTSQUERY_PHRASE );\n  if( sqlite3_fts3_enable_parentheses ){\n    return p->eType;\n  }else if( p->eType==FTSQUERY_NEAR ){\n    return 1;\n  }else if( p->eType==FTSQUERY_OR ){\n    return 2;\n  }\n  assert( p->eType==FTSQUERY_AND );\n  return 3;\n}\n\n/*\n** Argument ppHead contains a pointer to the current head of a query \n** expression tree being parsed. pPrev is the expression node most recently\n** inserted into the tree. This function adds pNew, which is always a binary\n** operator node, into the expression tree based on the relative precedence\n** of pNew and the existing nodes of the tree. This may result in the head\n** of the tree changing, in which case *ppHead is set to the new root node.\n*/\nstatic void insertBinaryOperator(\n  Fts3Expr **ppHead,       /* Pointer to the root node of a tree */\n  Fts3Expr *pPrev,         /* Node most recently inserted into the tree */\n  Fts3Expr *pNew           /* New binary node to insert into expression tree */\n){\n  Fts3Expr *pSplit = pPrev;\n  while( pSplit->pParent && opPrecedence(pSplit->pParent)<=opPrecedence(pNew) ){\n    pSplit = pSplit->pParent;\n  }\n\n  if( pSplit->pParent ){\n    assert( pSplit->pParent->pRight==pSplit );\n    pSplit->pParent->pRight = pNew;\n    pNew->pParent = pSplit->pParent;\n  }else{\n    *ppHead = pNew;\n  }\n  pNew->pLeft = pSplit;\n  pSplit->pParent = pNew;\n}\n\n/*\n** Parse the fts3 query expression found in buffer z, length n. This function\n** returns either when the end of the buffer is reached or an unmatched \n** closing bracket - ')' - is encountered.\n**\n** If successful, SQLITE_OK is returned, *ppExpr is set to point to the\n** parsed form of the expression and *pnConsumed is set to the number of\n** bytes read from buffer z. Otherwise, *ppExpr is set to 0 and SQLITE_NOMEM\n** (out of memory error) or SQLITE_ERROR (parse error) is returned.\n*/\nstatic int fts3ExprParse(\n  ParseContext *pParse,                   /* fts3 query parse context */\n  const char *z, int n,                   /* Text of MATCH query */\n  Fts3Expr **ppExpr,                      /* OUT: Parsed query structure */\n  int *pnConsumed                         /* OUT: Number of bytes consumed */\n){\n  Fts3Expr *pRet = 0;\n  Fts3Expr *pPrev = 0;\n  Fts3Expr *pNotBranch = 0;               /* Only used in legacy parse mode */\n  int nIn = n;\n  const char *zIn = z;\n  int rc = SQLITE_OK;\n  int isRequirePhrase = 1;\n\n  while( rc==SQLITE_OK ){\n    Fts3Expr *p = 0;\n    int nByte = 0;\n    rc = getNextNode(pParse, zIn, nIn, &p, &nByte);\n    if( rc==SQLITE_OK ){\n      int isPhrase;\n\n      if( !sqlite3_fts3_enable_parentheses \n       && p->eType==FTSQUERY_PHRASE && p->pPhrase->isNot \n      ){\n        /* Create an implicit NOT operator. */\n        Fts3Expr *pNot = fts3MallocZero(sizeof(Fts3Expr));\n        if( !pNot ){\n          sqlite3Fts3ExprFree(p);\n          rc = SQLITE_NOMEM;\n          goto exprparse_out;\n        }\n        pNot->eType = FTSQUERY_NOT;\n        pNot->pRight = p;\n        if( pNotBranch ){\n          pNot->pLeft = pNotBranch;\n        }\n        pNotBranch = pNot;\n        p = pPrev;\n      }else{\n        int eType = p->eType;\n        assert( eType!=FTSQUERY_PHRASE || !p->pPhrase->isNot );\n        isPhrase = (eType==FTSQUERY_PHRASE || p->pLeft);\n\n        /* The isRequirePhrase variable is set to true if a phrase or\n        ** an expression contained in parenthesis is required. If a\n        ** binary operator (AND, OR, NOT or NEAR) is encounted when\n        ** isRequirePhrase is set, this is a syntax error.\n        */\n        if( !isPhrase && isRequirePhrase ){\n          sqlite3Fts3ExprFree(p);\n          rc = SQLITE_ERROR;\n          goto exprparse_out;\n        }\n  \n        if( isPhrase && !isRequirePhrase ){\n          /* Insert an implicit AND operator. */\n          Fts3Expr *pAnd;\n          assert( pRet && pPrev );\n          pAnd = fts3MallocZero(sizeof(Fts3Expr));\n          if( !pAnd ){\n            sqlite3Fts3ExprFree(p);\n            rc = SQLITE_NOMEM;\n            goto exprparse_out;\n          }\n          pAnd->eType = FTSQUERY_AND;\n          insertBinaryOperator(&pRet, pPrev, pAnd);\n          pPrev = pAnd;\n        }\n\n        /* This test catches attempts to make either operand of a NEAR\n        ** operator something other than a phrase. For example, either of\n        ** the following:\n        **\n        **    (bracketed expression) NEAR phrase\n        **    phrase NEAR (bracketed expression)\n        **\n        ** Return an error in either case.\n        */\n        if( pPrev && (\n            (eType==FTSQUERY_NEAR && !isPhrase && pPrev->eType!=FTSQUERY_PHRASE)\n         || (eType!=FTSQUERY_PHRASE && isPhrase && pPrev->eType==FTSQUERY_NEAR)\n        )){\n          sqlite3Fts3ExprFree(p);\n          rc = SQLITE_ERROR;\n          goto exprparse_out;\n        }\n  \n        if( isPhrase ){\n          if( pRet ){\n            assert( pPrev && pPrev->pLeft && pPrev->pRight==0 );\n            pPrev->pRight = p;\n            p->pParent = pPrev;\n          }else{\n            pRet = p;\n          }\n        }else{\n          insertBinaryOperator(&pRet, pPrev, p);\n        }\n        isRequirePhrase = !isPhrase;\n      }\n      assert( nByte>0 );\n    }\n    assert( rc!=SQLITE_OK || (nByte>0 && nByte<=nIn) );\n    nIn -= nByte;\n    zIn += nByte;\n    pPrev = p;\n  }\n\n  if( rc==SQLITE_DONE && pRet && isRequirePhrase ){\n    rc = SQLITE_ERROR;\n  }\n\n  if( rc==SQLITE_DONE ){\n    rc = SQLITE_OK;\n    if( !sqlite3_fts3_enable_parentheses && pNotBranch ){\n      if( !pRet ){\n        rc = SQLITE_ERROR;\n      }else{\n        Fts3Expr *pIter = pNotBranch;\n        while( pIter->pLeft ){\n          pIter = pIter->pLeft;\n        }\n        pIter->pLeft = pRet;\n        pRet = pNotBranch;\n      }\n    }\n  }\n  *pnConsumed = n - nIn;\n\nexprparse_out:\n  if( rc!=SQLITE_OK ){\n    sqlite3Fts3ExprFree(pRet);\n    sqlite3Fts3ExprFree(pNotBranch);\n    pRet = 0;\n  }\n  *ppExpr = pRet;\n  return rc;\n}\n\n/*\n** Parameters z and n contain a pointer to and length of a buffer containing\n** an fts3 query expression, respectively. This function attempts to parse the\n** query expression and create a tree of Fts3Expr structures representing the\n** parsed expression. If successful, *ppExpr is set to point to the head\n** of the parsed expression tree and SQLITE_OK is returned. If an error\n** occurs, either SQLITE_NOMEM (out-of-memory error) or SQLITE_ERROR (parse\n** error) is returned and *ppExpr is set to 0.\n**\n** If parameter n is a negative number, then z is assumed to point to a\n** nul-terminated string and the length is determined using strlen().\n**\n** The first parameter, pTokenizer, is passed the fts3 tokenizer module to\n** use to normalize query tokens while parsing the expression. The azCol[]\n** array, which is assumed to contain nCol entries, should contain the names\n** of each column in the target fts3 table, in order from left to right. \n** Column names must be nul-terminated strings.\n**\n** The iDefaultCol parameter should be passed the index of the table column\n** that appears on the left-hand-side of the MATCH operator (the default\n** column to match against for tokens for which a column name is not explicitly\n** specified as part of the query string), or -1 if tokens may by default\n** match any table column.\n*/\nSQLITE_PRIVATE int sqlite3Fts3ExprParse(\n  sqlite3_tokenizer *pTokenizer,      /* Tokenizer module */\n  char **azCol,                       /* Array of column names for fts3 table */\n  int nCol,                           /* Number of entries in azCol[] */\n  int iDefaultCol,                    /* Default column to query */\n  const char *z, int n,               /* Text of MATCH query */\n  Fts3Expr **ppExpr                   /* OUT: Parsed query structure */\n){\n  int nParsed;\n  int rc;\n  ParseContext sParse;\n  sParse.pTokenizer = pTokenizer;\n  sParse.azCol = (const char **)azCol;\n  sParse.nCol = nCol;\n  sParse.iDefaultCol = iDefaultCol;\n  sParse.nNest = 0;\n  if( z==0 ){\n    *ppExpr = 0;\n    return SQLITE_OK;\n  }\n  if( n<0 ){\n    n = (int)strlen(z);\n  }\n  rc = fts3ExprParse(&sParse, z, n, ppExpr, &nParsed);\n\n  /* Check for mismatched parenthesis */\n  if( rc==SQLITE_OK && sParse.nNest ){\n    rc = SQLITE_ERROR;\n    sqlite3Fts3ExprFree(*ppExpr);\n    *ppExpr = 0;\n  }\n\n  return rc;\n}\n\n/*\n** Free a parsed fts3 query expression allocated by sqlite3Fts3ExprParse().\n*/\nSQLITE_PRIVATE void sqlite3Fts3ExprFree(Fts3Expr *p){\n  if( p ){\n    sqlite3Fts3ExprFree(p->pLeft);\n    sqlite3Fts3ExprFree(p->pRight);\n    sqlite3_free(p->aDoclist);\n    sqlite3_free(p);\n  }\n}\n\n/****************************************************************************\n*****************************************************************************\n** Everything after this point is just test code.\n*/\n\n#ifdef SQLITE_TEST\n\n\n/*\n** Function to query the hash-table of tokenizers (see README.tokenizers).\n*/\nstatic int queryTestTokenizer(\n  sqlite3 *db, \n  const char *zName,  \n  const sqlite3_tokenizer_module **pp\n){\n  int rc;\n  sqlite3_stmt *pStmt;\n  const char zSql[] = \"SELECT fts3_tokenizer(?)\";\n\n  *pp = 0;\n  rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);\n  if( rc!=SQLITE_OK ){\n    return rc;\n  }\n\n  sqlite3_bind_text(pStmt, 1, zName, -1, SQLITE_STATIC);\n  if( SQLITE_ROW==sqlite3_step(pStmt) ){\n    if( sqlite3_column_type(pStmt, 0)==SQLITE_BLOB ){\n      memcpy((void *)pp, sqlite3_column_blob(pStmt, 0), sizeof(*pp));\n    }\n  }\n\n  return sqlite3_finalize(pStmt);\n}\n\n/*\n** Return a pointer to a buffer containing a text representation of the\n** expression passed as the first argument. The buffer is obtained from\n** sqlite3_malloc(). It is the responsibility of the caller to use \n** sqlite3_free() to release the memory. If an OOM condition is encountered,\n** NULL is returned.\n**\n** If the second argument is not NULL, then its contents are prepended to \n** the returned expression text and then freed using sqlite3_free().\n*/\nstatic char *exprToString(Fts3Expr *pExpr, char *zBuf){\n  switch( pExpr->eType ){\n    case FTSQUERY_PHRASE: {\n      Fts3Phrase *pPhrase = pExpr->pPhrase;\n      int i;\n      zBuf = sqlite3_mprintf(\n          \"%zPHRASE %d %d\", zBuf, pPhrase->iColumn, pPhrase->isNot);\n      for(i=0; zBuf && i<pPhrase->nToken; i++){\n        zBuf = sqlite3_mprintf(\"%z %.*s%s\", zBuf, \n            pPhrase->aToken[i].n, pPhrase->aToken[i].z,\n            (pPhrase->aToken[i].isPrefix?\"+\":\"\")\n        );\n      }\n      return zBuf;\n    }\n\n    case FTSQUERY_NEAR:\n      zBuf = sqlite3_mprintf(\"%zNEAR/%d \", zBuf, pExpr->nNear);\n      break;\n    case FTSQUERY_NOT:\n      zBuf = sqlite3_mprintf(\"%zNOT \", zBuf);\n      break;\n    case FTSQUERY_AND:\n      zBuf = sqlite3_mprintf(\"%zAND \", zBuf);\n      break;\n    case FTSQUERY_OR:\n      zBuf = sqlite3_mprintf(\"%zOR \", zBuf);\n      break;\n  }\n\n  if( zBuf ) zBuf = sqlite3_mprintf(\"%z{\", zBuf);\n  if( zBuf ) zBuf = exprToString(pExpr->pLeft, zBuf);\n  if( zBuf ) zBuf = sqlite3_mprintf(\"%z} {\", zBuf);\n\n  if( zBuf ) zBuf = exprToString(pExpr->pRight, zBuf);\n  if( zBuf ) zBuf = sqlite3_mprintf(\"%z}\", zBuf);\n\n  return zBuf;\n}\n\n/*\n** This is the implementation of a scalar SQL function used to test the \n** expression parser. It should be called as follows:\n**\n**   fts3_exprtest(<tokenizer>, <expr>, <column 1>, ...);\n**\n** The first argument, <tokenizer>, is the name of the fts3 tokenizer used\n** to parse the query expression (see README.tokenizers). The second argument\n** is the query expression to parse. Each subsequent argument is the name\n** of a column of the fts3 table that the query expression may refer to.\n** For example:\n**\n**   SELECT fts3_exprtest('simple', 'Bill col2:Bloggs', 'col1', 'col2');\n*/\nstatic void fts3ExprTest(\n  sqlite3_context *context,\n  int argc,\n  sqlite3_value **argv\n){\n  sqlite3_tokenizer_module const *pModule = 0;\n  sqlite3_tokenizer *pTokenizer = 0;\n  int rc;\n  char **azCol = 0;\n  const char *zExpr;\n  int nExpr;\n  int nCol;\n  int ii;\n  Fts3Expr *pExpr;\n  char *zBuf = 0;\n  sqlite3 *db = sqlite3_context_db_handle(context);\n\n  if( argc<3 ){\n    sqlite3_result_error(context, \n        \"Usage: fts3_exprtest(tokenizer, expr, col1, ...\", -1\n    );\n    return;\n  }\n\n  rc = queryTestTokenizer(db,\n                          (const char *)sqlite3_value_text(argv[0]), &pModule);\n  if( rc==SQLITE_NOMEM ){\n    sqlite3_result_error_nomem(context);\n    goto exprtest_out;\n  }else if( !pModule ){\n    sqlite3_result_error(context, \"No such tokenizer module\", -1);\n    goto exprtest_out;\n  }\n\n  rc = pModule->xCreate(0, 0, &pTokenizer);\n  assert( rc==SQLITE_NOMEM || rc==SQLITE_OK );\n  if( rc==SQLITE_NOMEM ){\n    sqlite3_result_error_nomem(context);\n    goto exprtest_out;\n  }\n  pTokenizer->pModule = pModule;\n\n  zExpr = (const char *)sqlite3_value_text(argv[1]);\n  nExpr = sqlite3_value_bytes(argv[1]);\n  nCol = argc-2;\n  azCol = (char **)sqlite3_malloc(nCol*sizeof(char *));\n  if( !azCol ){\n    sqlite3_result_error_nomem(context);\n    goto exprtest_out;\n  }\n  for(ii=0; ii<nCol; ii++){\n    azCol[ii] = (char *)sqlite3_value_text(argv[ii+2]);\n  }\n\n  rc = sqlite3Fts3ExprParse(\n      pTokenizer, azCol, nCol, nCol, zExpr, nExpr, &pExpr\n  );\n  if( rc!=SQLITE_OK && rc!=SQLITE_NOMEM ){\n    sqlite3_result_error(context, \"Error parsing expression\", -1);\n  }else if( rc==SQLITE_NOMEM || !(zBuf = exprToString(pExpr, 0)) ){\n    sqlite3_result_error_nomem(context);\n  }else{\n    sqlite3_result_text(context, zBuf, -1, SQLITE_TRANSIENT);\n    sqlite3_free(zBuf);\n  }\n\n  sqlite3Fts3ExprFree(pExpr);\n\nexprtest_out:\n  if( pModule && pTokenizer ){\n    rc = pModule->xDestroy(pTokenizer);\n  }\n  sqlite3_free(azCol);\n}\n\n/*\n** Register the query expression parser test function fts3_exprtest() \n** with database connection db. \n*/\nSQLITE_PRIVATE int sqlite3Fts3ExprInitTestInterface(sqlite3* db){\n  return sqlite3_create_function(\n      db, \"fts3_exprtest\", -1, SQLITE_UTF8, 0, fts3ExprTest, 0, 0\n  );\n}\n\n#endif\n#endif /* !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS3) */\n\n/************** End of fts3_expr.c *******************************************/\n/************** Begin file fts3_hash.c ***************************************/\n/*\n** 2001 September 22\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This is the implementation of generic hash-tables used in SQLite.\n** We've modified it slightly to serve as a standalone hash table\n** implementation for the full-text indexing module.\n*/\n\n/*\n** The code in this file is only compiled if:\n**\n**     * The FTS3 module is being built as an extension\n**       (in which case SQLITE_CORE is not defined), or\n**\n**     * The FTS3 module is being built into the core of\n**       SQLite (in which case SQLITE_ENABLE_FTS3 is defined).\n*/\n#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS3)\n\n\n\n/*\n** Malloc and Free functions\n*/\nstatic void *fts3HashMalloc(int n){\n  void *p = sqlite3_malloc(n);\n  if( p ){\n    memset(p, 0, n);\n  }\n  return p;\n}\nstatic void fts3HashFree(void *p){\n  sqlite3_free(p);\n}\n\n/* Turn bulk memory into a hash table object by initializing the\n** fields of the Hash structure.\n**\n** \"pNew\" is a pointer to the hash table that is to be initialized.\n** keyClass is one of the constants \n** FTS3_HASH_BINARY or FTS3_HASH_STRING.  The value of keyClass \n** determines what kind of key the hash table will use.  \"copyKey\" is\n** true if the hash table should make its own private copy of keys and\n** false if it should just use the supplied pointer.\n*/\nSQLITE_PRIVATE void sqlite3Fts3HashInit(Fts3Hash *pNew, char keyClass, char copyKey){\n  assert( pNew!=0 );\n  assert( keyClass>=FTS3_HASH_STRING && keyClass<=FTS3_HASH_BINARY );\n  pNew->keyClass = keyClass;\n  pNew->copyKey = copyKey;\n  pNew->first = 0;\n  pNew->count = 0;\n  pNew->htsize = 0;\n  pNew->ht = 0;\n}\n\n/* Remove all entries from a hash table.  Reclaim all memory.\n** Call this routine to delete a hash table or to reset a hash table\n** to the empty state.\n*/\nSQLITE_PRIVATE void sqlite3Fts3HashClear(Fts3Hash *pH){\n  Fts3HashElem *elem;         /* For looping over all elements of the table */\n\n  assert( pH!=0 );\n  elem = pH->first;\n  pH->first = 0;\n  fts3HashFree(pH->ht);\n  pH->ht = 0;\n  pH->htsize = 0;\n  while( elem ){\n    Fts3HashElem *next_elem = elem->next;\n    if( pH->copyKey && elem->pKey ){\n      fts3HashFree(elem->pKey);\n    }\n    fts3HashFree(elem);\n    elem = next_elem;\n  }\n  pH->count = 0;\n}\n\n/*\n** Hash and comparison functions when the mode is FTS3_HASH_STRING\n*/\nstatic int fts3StrHash(const void *pKey, int nKey){\n  const char *z = (const char *)pKey;\n  int h = 0;\n  if( nKey<=0 ) nKey = (int) strlen(z);\n  while( nKey > 0  ){\n    h = (h<<3) ^ h ^ *z++;\n    nKey--;\n  }\n  return h & 0x7fffffff;\n}\nstatic int fts3StrCompare(const void *pKey1, int n1, const void *pKey2, int n2){\n  if( n1!=n2 ) return 1;\n  return strncmp((const char*)pKey1,(const char*)pKey2,n1);\n}\n\n/*\n** Hash and comparison functions when the mode is FTS3_HASH_BINARY\n*/\nstatic int fts3BinHash(const void *pKey, int nKey){\n  int h = 0;\n  const char *z = (const char *)pKey;\n  while( nKey-- > 0 ){\n    h = (h<<3) ^ h ^ *(z++);\n  }\n  return h & 0x7fffffff;\n}\nstatic int fts3BinCompare(const void *pKey1, int n1, const void *pKey2, int n2){\n  if( n1!=n2 ) return 1;\n  return memcmp(pKey1,pKey2,n1);\n}\n\n/*\n** Return a pointer to the appropriate hash function given the key class.\n**\n** The C syntax in this function definition may be unfamilar to some \n** programmers, so we provide the following additional explanation:\n**\n** The name of the function is \"ftsHashFunction\".  The function takes a\n** single parameter \"keyClass\".  The return value of ftsHashFunction()\n** is a pointer to another function.  Specifically, the return value\n** of ftsHashFunction() is a pointer to a function that takes two parameters\n** with types \"const void*\" and \"int\" and returns an \"int\".\n*/\nstatic int (*ftsHashFunction(int keyClass))(const void*,int){\n  if( keyClass==FTS3_HASH_STRING ){\n    return &fts3StrHash;\n  }else{\n    assert( keyClass==FTS3_HASH_BINARY );\n    return &fts3BinHash;\n  }\n}\n\n/*\n** Return a pointer to the appropriate hash function given the key class.\n**\n** For help in interpreted the obscure C code in the function definition,\n** see the header comment on the previous function.\n*/\nstatic int (*ftsCompareFunction(int keyClass))(const void*,int,const void*,int){\n  if( keyClass==FTS3_HASH_STRING ){\n    return &fts3StrCompare;\n  }else{\n    assert( keyClass==FTS3_HASH_BINARY );\n    return &fts3BinCompare;\n  }\n}\n\n/* Link an element into the hash table\n*/\nstatic void fts3HashInsertElement(\n  Fts3Hash *pH,            /* The complete hash table */\n  struct _fts3ht *pEntry,  /* The entry into which pNew is inserted */\n  Fts3HashElem *pNew       /* The element to be inserted */\n){\n  Fts3HashElem *pHead;     /* First element already in pEntry */\n  pHead = pEntry->chain;\n  if( pHead ){\n    pNew->next = pHead;\n    pNew->prev = pHead->prev;\n    if( pHead->prev ){ pHead->prev->next = pNew; }\n    else             { pH->first = pNew; }\n    pHead->prev = pNew;\n  }else{\n    pNew->next = pH->first;\n    if( pH->first ){ pH->first->prev = pNew; }\n    pNew->prev = 0;\n    pH->first = pNew;\n  }\n  pEntry->count++;\n  pEntry->chain = pNew;\n}\n\n\n/* Resize the hash table so that it cantains \"new_size\" buckets.\n** \"new_size\" must be a power of 2.  The hash table might fail \n** to resize if sqliteMalloc() fails.\n**\n** Return non-zero if a memory allocation error occurs.\n*/\nstatic int fts3Rehash(Fts3Hash *pH, int new_size){\n  struct _fts3ht *new_ht;          /* The new hash table */\n  Fts3HashElem *elem, *next_elem;  /* For looping over existing elements */\n  int (*xHash)(const void*,int);   /* The hash function */\n\n  assert( (new_size & (new_size-1))==0 );\n  new_ht = (struct _fts3ht *)fts3HashMalloc( new_size*sizeof(struct _fts3ht) );\n  if( new_ht==0 ) return 1;\n  fts3HashFree(pH->ht);\n  pH->ht = new_ht;\n  pH->htsize = new_size;\n  xHash = ftsHashFunction(pH->keyClass);\n  for(elem=pH->first, pH->first=0; elem; elem = next_elem){\n    int h = (*xHash)(elem->pKey, elem->nKey) & (new_size-1);\n    next_elem = elem->next;\n    fts3HashInsertElement(pH, &new_ht[h], elem);\n  }\n  return 0;\n}\n\n/* This function (for internal use only) locates an element in an\n** hash table that matches the given key.  The hash for this key has\n** already been computed and is passed as the 4th parameter.\n*/\nstatic Fts3HashElem *fts3FindElementByHash(\n  const Fts3Hash *pH, /* The pH to be searched */\n  const void *pKey,   /* The key we are searching for */\n  int nKey,\n  int h               /* The hash for this key. */\n){\n  Fts3HashElem *elem;            /* Used to loop thru the element list */\n  int count;                     /* Number of elements left to test */\n  int (*xCompare)(const void*,int,const void*,int);  /* comparison function */\n\n  if( pH->ht ){\n    struct _fts3ht *pEntry = &pH->ht[h];\n    elem = pEntry->chain;\n    count = pEntry->count;\n    xCompare = ftsCompareFunction(pH->keyClass);\n    while( count-- && elem ){\n      if( (*xCompare)(elem->pKey,elem->nKey,pKey,nKey)==0 ){ \n        return elem;\n      }\n      elem = elem->next;\n    }\n  }\n  return 0;\n}\n\n/* Remove a single entry from the hash table given a pointer to that\n** element and a hash on the element's key.\n*/\nstatic void fts3RemoveElementByHash(\n  Fts3Hash *pH,         /* The pH containing \"elem\" */\n  Fts3HashElem* elem,   /* The element to be removed from the pH */\n  int h                 /* Hash value for the element */\n){\n  struct _fts3ht *pEntry;\n  if( elem->prev ){\n    elem->prev->next = elem->next; \n  }else{\n    pH->first = elem->next;\n  }\n  if( elem->next ){\n    elem->next->prev = elem->prev;\n  }\n  pEntry = &pH->ht[h];\n  if( pEntry->chain==elem ){\n    pEntry->chain = elem->next;\n  }\n  pEntry->count--;\n  if( pEntry->count<=0 ){\n    pEntry->chain = 0;\n  }\n  if( pH->copyKey && elem->pKey ){\n    fts3HashFree(elem->pKey);\n  }\n  fts3HashFree( elem );\n  pH->count--;\n  if( pH->count<=0 ){\n    assert( pH->first==0 );\n    assert( pH->count==0 );\n    fts3HashClear(pH);\n  }\n}\n\nSQLITE_PRIVATE Fts3HashElem *sqlite3Fts3HashFindElem(\n  const Fts3Hash *pH, \n  const void *pKey, \n  int nKey\n){\n  int h;                          /* A hash on key */\n  int (*xHash)(const void*,int);  /* The hash function */\n\n  if( pH==0 || pH->ht==0 ) return 0;\n  xHash = ftsHashFunction(pH->keyClass);\n  assert( xHash!=0 );\n  h = (*xHash)(pKey,nKey);\n  assert( (pH->htsize & (pH->htsize-1))==0 );\n  return fts3FindElementByHash(pH,pKey,nKey, h & (pH->htsize-1));\n}\n\n/* \n** Attempt to locate an element of the hash table pH with a key\n** that matches pKey,nKey.  Return the data for this element if it is\n** found, or NULL if there is no match.\n*/\nSQLITE_PRIVATE void *sqlite3Fts3HashFind(const Fts3Hash *pH, const void *pKey, int nKey){\n  Fts3HashElem *pElem;            /* The element that matches key (if any) */\n\n  pElem = sqlite3Fts3HashFindElem(pH, pKey, nKey);\n  return pElem ? pElem->data : 0;\n}\n\n/* Insert an element into the hash table pH.  The key is pKey,nKey\n** and the data is \"data\".\n**\n** If no element exists with a matching key, then a new\n** element is created.  A copy of the key is made if the copyKey\n** flag is set.  NULL is returned.\n**\n** If another element already exists with the same key, then the\n** new data replaces the old data and the old data is returned.\n** The key is not copied in this instance.  If a malloc fails, then\n** the new data is returned and the hash table is unchanged.\n**\n** If the \"data\" parameter to this function is NULL, then the\n** element corresponding to \"key\" is removed from the hash table.\n*/\nSQLITE_PRIVATE void *sqlite3Fts3HashInsert(\n  Fts3Hash *pH,        /* The hash table to insert into */\n  const void *pKey,    /* The key */\n  int nKey,            /* Number of bytes in the key */\n  void *data           /* The data */\n){\n  int hraw;                 /* Raw hash value of the key */\n  int h;                    /* the hash of the key modulo hash table size */\n  Fts3HashElem *elem;       /* Used to loop thru the element list */\n  Fts3HashElem *new_elem;   /* New element added to the pH */\n  int (*xHash)(const void*,int);  /* The hash function */\n\n  assert( pH!=0 );\n  xHash = ftsHashFunction(pH->keyClass);\n  assert( xHash!=0 );\n  hraw = (*xHash)(pKey, nKey);\n  assert( (pH->htsize & (pH->htsize-1))==0 );\n  h = hraw & (pH->htsize-1);\n  elem = fts3FindElementByHash(pH,pKey,nKey,h);\n  if( elem ){\n    void *old_data = elem->data;\n    if( data==0 ){\n      fts3RemoveElementByHash(pH,elem,h);\n    }else{\n      elem->data = data;\n    }\n    return old_data;\n  }\n  if( data==0 ) return 0;\n  if( (pH->htsize==0 && fts3Rehash(pH,8))\n   || (pH->count>=pH->htsize && fts3Rehash(pH, pH->htsize*2))\n  ){\n    pH->count = 0;\n    return data;\n  }\n  assert( pH->htsize>0 );\n  new_elem = (Fts3HashElem*)fts3HashMalloc( sizeof(Fts3HashElem) );\n  if( new_elem==0 ) return data;\n  if( pH->copyKey && pKey!=0 ){\n    new_elem->pKey = fts3HashMalloc( nKey );\n    if( new_elem->pKey==0 ){\n      fts3HashFree(new_elem);\n      return data;\n    }\n    memcpy((void*)new_elem->pKey, pKey, nKey);\n  }else{\n    new_elem->pKey = (void*)pKey;\n  }\n  new_elem->nKey = nKey;\n  pH->count++;\n  assert( pH->htsize>0 );\n  assert( (pH->htsize & (pH->htsize-1))==0 );\n  h = hraw & (pH->htsize-1);\n  fts3HashInsertElement(pH, &pH->ht[h], new_elem);\n  new_elem->data = data;\n  return 0;\n}\n\n#endif /* !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS3) */\n\n/************** End of fts3_hash.c *******************************************/\n/************** Begin file fts3_porter.c *************************************/\n/*\n** 2006 September 30\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** Implementation of the full-text-search tokenizer that implements\n** a Porter stemmer.\n*/\n\n/*\n** The code in this file is only compiled if:\n**\n**     * The FTS3 module is being built as an extension\n**       (in which case SQLITE_CORE is not defined), or\n**\n**     * The FTS3 module is being built into the core of\n**       SQLite (in which case SQLITE_ENABLE_FTS3 is defined).\n*/\n#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS3)\n\n\n\n\n/*\n** Class derived from sqlite3_tokenizer\n*/\ntypedef struct porter_tokenizer {\n  sqlite3_tokenizer base;      /* Base class */\n} porter_tokenizer;\n\n/*\n** Class derived from sqlit3_tokenizer_cursor\n*/\ntypedef struct porter_tokenizer_cursor {\n  sqlite3_tokenizer_cursor base;\n  const char *zInput;          /* input we are tokenizing */\n  int nInput;                  /* size of the input */\n  int iOffset;                 /* current position in zInput */\n  int iToken;                  /* index of next token to be returned */\n  char *zToken;                /* storage for current token */\n  int nAllocated;              /* space allocated to zToken buffer */\n} porter_tokenizer_cursor;\n\n\n/*\n** Create a new tokenizer instance.\n*/\nstatic int porterCreate(\n  int argc, const char * const *argv,\n  sqlite3_tokenizer **ppTokenizer\n){\n  porter_tokenizer *t;\n\n  UNUSED_PARAMETER(argc);\n  UNUSED_PARAMETER(argv);\n\n  t = (porter_tokenizer *) sqlite3_malloc(sizeof(*t));\n  if( t==NULL ) return SQLITE_NOMEM;\n  memset(t, 0, sizeof(*t));\n  *ppTokenizer = &t->base;\n  return SQLITE_OK;\n}\n\n/*\n** Destroy a tokenizer\n*/\nstatic int porterDestroy(sqlite3_tokenizer *pTokenizer){\n  sqlite3_free(pTokenizer);\n  return SQLITE_OK;\n}\n\n/*\n** Prepare to begin tokenizing a particular string.  The input\n** string to be tokenized is zInput[0..nInput-1].  A cursor\n** used to incrementally tokenize this string is returned in \n** *ppCursor.\n*/\nstatic int porterOpen(\n  sqlite3_tokenizer *pTokenizer,         /* The tokenizer */\n  const char *zInput, int nInput,        /* String to be tokenized */\n  sqlite3_tokenizer_cursor **ppCursor    /* OUT: Tokenization cursor */\n){\n  porter_tokenizer_cursor *c;\n\n  UNUSED_PARAMETER(pTokenizer);\n\n  c = (porter_tokenizer_cursor *) sqlite3_malloc(sizeof(*c));\n  if( c==NULL ) return SQLITE_NOMEM;\n\n  c->zInput = zInput;\n  if( zInput==0 ){\n    c->nInput = 0;\n  }else if( nInput<0 ){\n    c->nInput = (int)strlen(zInput);\n  }else{\n    c->nInput = nInput;\n  }\n  c->iOffset = 0;                 /* start tokenizing at the beginning */\n  c->iToken = 0;\n  c->zToken = NULL;               /* no space allocated, yet. */\n  c->nAllocated = 0;\n\n  *ppCursor = &c->base;\n  return SQLITE_OK;\n}\n\n/*\n** Close a tokenization cursor previously opened by a call to\n** porterOpen() above.\n*/\nstatic int porterClose(sqlite3_tokenizer_cursor *pCursor){\n  porter_tokenizer_cursor *c = (porter_tokenizer_cursor *) pCursor;\n  sqlite3_free(c->zToken);\n  sqlite3_free(c);\n  return SQLITE_OK;\n}\n/*\n** Vowel or consonant\n*/\nstatic const char cType[] = {\n   0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0,\n   1, 1, 1, 2, 1\n};\n\n/*\n** isConsonant() and isVowel() determine if their first character in\n** the string they point to is a consonant or a vowel, according\n** to Porter ruls.  \n**\n** A consonate is any letter other than 'a', 'e', 'i', 'o', or 'u'.\n** 'Y' is a consonant unless it follows another consonant,\n** in which case it is a vowel.\n**\n** In these routine, the letters are in reverse order.  So the 'y' rule\n** is that 'y' is a consonant unless it is followed by another\n** consonent.\n*/\nstatic int isVowel(const char*);\nstatic int isConsonant(const char *z){\n  int j;\n  char x = *z;\n  if( x==0 ) return 0;\n  assert( x>='a' && x<='z' );\n  j = cType[x-'a'];\n  if( j<2 ) return j;\n  return z[1]==0 || isVowel(z + 1);\n}\nstatic int isVowel(const char *z){\n  int j;\n  char x = *z;\n  if( x==0 ) return 0;\n  assert( x>='a' && x<='z' );\n  j = cType[x-'a'];\n  if( j<2 ) return 1-j;\n  return isConsonant(z + 1);\n}\n\n/*\n** Let any sequence of one or more vowels be represented by V and let\n** C be sequence of one or more consonants.  Then every word can be\n** represented as:\n**\n**           [C] (VC){m} [V]\n**\n** In prose:  A word is an optional consonant followed by zero or\n** vowel-consonant pairs followed by an optional vowel.  \"m\" is the\n** number of vowel consonant pairs.  This routine computes the value\n** of m for the first i bytes of a word.\n**\n** Return true if the m-value for z is 1 or more.  In other words,\n** return true if z contains at least one vowel that is followed\n** by a consonant.\n**\n** In this routine z[] is in reverse order.  So we are really looking\n** for an instance of of a consonant followed by a vowel.\n*/\nstatic int m_gt_0(const char *z){\n  while( isVowel(z) ){ z++; }\n  if( *z==0 ) return 0;\n  while( isConsonant(z) ){ z++; }\n  return *z!=0;\n}\n\n/* Like mgt0 above except we are looking for a value of m which is\n** exactly 1\n*/\nstatic int m_eq_1(const char *z){\n  while( isVowel(z) ){ z++; }\n  if( *z==0 ) return 0;\n  while( isConsonant(z) ){ z++; }\n  if( *z==0 ) return 0;\n  while( isVowel(z) ){ z++; }\n  if( *z==0 ) return 1;\n  while( isConsonant(z) ){ z++; }\n  return *z==0;\n}\n\n/* Like mgt0 above except we are looking for a value of m>1 instead\n** or m>0\n*/\nstatic int m_gt_1(const char *z){\n  while( isVowel(z) ){ z++; }\n  if( *z==0 ) return 0;\n  while( isConsonant(z) ){ z++; }\n  if( *z==0 ) return 0;\n  while( isVowel(z) ){ z++; }\n  if( *z==0 ) return 0;\n  while( isConsonant(z) ){ z++; }\n  return *z!=0;\n}\n\n/*\n** Return TRUE if there is a vowel anywhere within z[0..n-1]\n*/\nstatic int hasVowel(const char *z){\n  while( isConsonant(z) ){ z++; }\n  return *z!=0;\n}\n\n/*\n** Return TRUE if the word ends in a double consonant.\n**\n** The text is reversed here. So we are really looking at\n** the first two characters of z[].\n*/\nstatic int doubleConsonant(const char *z){\n  return isConsonant(z) && z[0]==z[1];\n}\n\n/*\n** Return TRUE if the word ends with three letters which\n** are consonant-vowel-consonent and where the final consonant\n** is not 'w', 'x', or 'y'.\n**\n** The word is reversed here.  So we are really checking the\n** first three letters and the first one cannot be in [wxy].\n*/\nstatic int star_oh(const char *z){\n  return\n    isConsonant(z) &&\n    z[0]!='w' && z[0]!='x' && z[0]!='y' &&\n    isVowel(z+1) &&\n    isConsonant(z+2);\n}\n\n/*\n** If the word ends with zFrom and xCond() is true for the stem\n** of the word that preceeds the zFrom ending, then change the \n** ending to zTo.\n**\n** The input word *pz and zFrom are both in reverse order.  zTo\n** is in normal order. \n**\n** Return TRUE if zFrom matches.  Return FALSE if zFrom does not\n** match.  Not that TRUE is returned even if xCond() fails and\n** no substitution occurs.\n*/\nstatic int stem(\n  char **pz,             /* The word being stemmed (Reversed) */\n  const char *zFrom,     /* If the ending matches this... (Reversed) */\n  const char *zTo,       /* ... change the ending to this (not reversed) */\n  int (*xCond)(const char*)   /* Condition that must be true */\n){\n  char *z = *pz;\n  while( *zFrom && *zFrom==*z ){ z++; zFrom++; }\n  if( *zFrom!=0 ) return 0;\n  if( xCond && !xCond(z) ) return 1;\n  while( *zTo ){\n    *(--z) = *(zTo++);\n  }\n  *pz = z;\n  return 1;\n}\n\n/*\n** This is the fallback stemmer used when the porter stemmer is\n** inappropriate.  The input word is copied into the output with\n** US-ASCII case folding.  If the input word is too long (more\n** than 20 bytes if it contains no digits or more than 6 bytes if\n** it contains digits) then word is truncated to 20 or 6 bytes\n** by taking 10 or 3 bytes from the beginning and end.\n*/\nstatic void copy_stemmer(const char *zIn, int nIn, char *zOut, int *pnOut){\n  int i, mx, j;\n  int hasDigit = 0;\n  for(i=0; i<nIn; i++){\n    char c = zIn[i];\n    if( c>='A' && c<='Z' ){\n      zOut[i] = c - 'A' + 'a';\n    }else{\n      if( c>='0' && c<='9' ) hasDigit = 1;\n      zOut[i] = c;\n    }\n  }\n  mx = hasDigit ? 3 : 10;\n  if( nIn>mx*2 ){\n    for(j=mx, i=nIn-mx; i<nIn; i++, j++){\n      zOut[j] = zOut[i];\n    }\n    i = j;\n  }\n  zOut[i] = 0;\n  *pnOut = i;\n}\n\n\n/*\n** Stem the input word zIn[0..nIn-1].  Store the output in zOut.\n** zOut is at least big enough to hold nIn bytes.  Write the actual\n** size of the output word (exclusive of the '\\0' terminator) into *pnOut.\n**\n** Any upper-case characters in the US-ASCII character set ([A-Z])\n** are converted to lower case.  Upper-case UTF characters are\n** unchanged.\n**\n** Words that are longer than about 20 bytes are stemmed by retaining\n** a few bytes from the beginning and the end of the word.  If the\n** word contains digits, 3 bytes are taken from the beginning and\n** 3 bytes from the end.  For long words without digits, 10 bytes\n** are taken from each end.  US-ASCII case folding still applies.\n** \n** If the input word contains not digits but does characters not \n** in [a-zA-Z] then no stemming is attempted and this routine just \n** copies the input into the input into the output with US-ASCII\n** case folding.\n**\n** Stemming never increases the length of the word.  So there is\n** no chance of overflowing the zOut buffer.\n*/\nstatic void porter_stemmer(const char *zIn, int nIn, char *zOut, int *pnOut){\n  int i, j;\n  char zReverse[28];\n  char *z, *z2;\n  if( nIn<3 || nIn>=(int)sizeof(zReverse)-7 ){\n    /* The word is too big or too small for the porter stemmer.\n    ** Fallback to the copy stemmer */\n    copy_stemmer(zIn, nIn, zOut, pnOut);\n    return;\n  }\n  for(i=0, j=sizeof(zReverse)-6; i<nIn; i++, j--){\n    char c = zIn[i];\n    if( c>='A' && c<='Z' ){\n      zReverse[j] = c + 'a' - 'A';\n    }else if( c>='a' && c<='z' ){\n      zReverse[j] = c;\n    }else{\n      /* The use of a character not in [a-zA-Z] means that we fallback\n      ** to the copy stemmer */\n      copy_stemmer(zIn, nIn, zOut, pnOut);\n      return;\n    }\n  }\n  memset(&zReverse[sizeof(zReverse)-5], 0, 5);\n  z = &zReverse[j+1];\n\n\n  /* Step 1a */\n  if( z[0]=='s' ){\n    if(\n     !stem(&z, \"sess\", \"ss\", 0) &&\n     !stem(&z, \"sei\", \"i\", 0)  &&\n     !stem(&z, \"ss\", \"ss\", 0)\n    ){\n      z++;\n    }\n  }\n\n  /* Step 1b */  \n  z2 = z;\n  if( stem(&z, \"dee\", \"ee\", m_gt_0) ){\n    /* Do nothing.  The work was all in the test */\n  }else if( \n     (stem(&z, \"gni\", \"\", hasVowel) || stem(&z, \"de\", \"\", hasVowel))\n      && z!=z2\n  ){\n     if( stem(&z, \"ta\", \"ate\", 0) ||\n         stem(&z, \"lb\", \"ble\", 0) ||\n         stem(&z, \"zi\", \"ize\", 0) ){\n       /* Do nothing.  The work was all in the test */\n     }else if( doubleConsonant(z) && (*z!='l' && *z!='s' && *z!='z') ){\n       z++;\n     }else if( m_eq_1(z) && star_oh(z) ){\n       *(--z) = 'e';\n     }\n  }\n\n  /* Step 1c */\n  if( z[0]=='y' && hasVowel(z+1) ){\n    z[0] = 'i';\n  }\n\n  /* Step 2 */\n  switch( z[1] ){\n   case 'a':\n     stem(&z, \"lanoita\", \"ate\", m_gt_0) ||\n     stem(&z, \"lanoit\", \"tion\", m_gt_0);\n     break;\n   case 'c':\n     stem(&z, \"icne\", \"ence\", m_gt_0) ||\n     stem(&z, \"icna\", \"ance\", m_gt_0);\n     break;\n   case 'e':\n     stem(&z, \"rezi\", \"ize\", m_gt_0);\n     break;\n   case 'g':\n     stem(&z, \"igol\", \"log\", m_gt_0);\n     break;\n   case 'l':\n     stem(&z, \"ilb\", \"ble\", m_gt_0) ||\n     stem(&z, \"illa\", \"al\", m_gt_0) ||\n     stem(&z, \"iltne\", \"ent\", m_gt_0) ||\n     stem(&z, \"ile\", \"e\", m_gt_0) ||\n     stem(&z, \"ilsuo\", \"ous\", m_gt_0);\n     break;\n   case 'o':\n     stem(&z, \"noitazi\", \"ize\", m_gt_0) ||\n     stem(&z, \"noita\", \"ate\", m_gt_0) ||\n     stem(&z, \"rota\", \"ate\", m_gt_0);\n     break;\n   case 's':\n     stem(&z, \"msila\", \"al\", m_gt_0) ||\n     stem(&z, \"ssenevi\", \"ive\", m_gt_0) ||\n     stem(&z, \"ssenluf\", \"ful\", m_gt_0) ||\n     stem(&z, \"ssensuo\", \"ous\", m_gt_0);\n     break;\n   case 't':\n     stem(&z, \"itila\", \"al\", m_gt_0) ||\n     stem(&z, \"itivi\", \"ive\", m_gt_0) ||\n     stem(&z, \"itilib\", \"ble\", m_gt_0);\n     break;\n  }\n\n  /* Step 3 */\n  switch( z[0] ){\n   case 'e':\n     stem(&z, \"etaci\", \"ic\", m_gt_0) ||\n     stem(&z, \"evita\", \"\", m_gt_0)   ||\n     stem(&z, \"ezila\", \"al\", m_gt_0);\n     break;\n   case 'i':\n     stem(&z, \"itici\", \"ic\", m_gt_0);\n     break;\n   case 'l':\n     stem(&z, \"laci\", \"ic\", m_gt_0) ||\n     stem(&z, \"luf\", \"\", m_gt_0);\n     break;\n   case 's':\n     stem(&z, \"ssen\", \"\", m_gt_0);\n     break;\n  }\n\n  /* Step 4 */\n  switch( z[1] ){\n   case 'a':\n     if( z[0]=='l' && m_gt_1(z+2) ){\n       z += 2;\n     }\n     break;\n   case 'c':\n     if( z[0]=='e' && z[2]=='n' && (z[3]=='a' || z[3]=='e')  && m_gt_1(z+4)  ){\n       z += 4;\n     }\n     break;\n   case 'e':\n     if( z[0]=='r' && m_gt_1(z+2) ){\n       z += 2;\n     }\n     break;\n   case 'i':\n     if( z[0]=='c' && m_gt_1(z+2) ){\n       z += 2;\n     }\n     break;\n   case 'l':\n     if( z[0]=='e' && z[2]=='b' && (z[3]=='a' || z[3]=='i') && m_gt_1(z+4) ){\n       z += 4;\n     }\n     break;\n   case 'n':\n     if( z[0]=='t' ){\n       if( z[2]=='a' ){\n         if( m_gt_1(z+3) ){\n           z += 3;\n         }\n       }else if( z[2]=='e' ){\n         stem(&z, \"tneme\", \"\", m_gt_1) ||\n         stem(&z, \"tnem\", \"\", m_gt_1) ||\n         stem(&z, \"tne\", \"\", m_gt_1);\n       }\n     }\n     break;\n   case 'o':\n     if( z[0]=='u' ){\n       if( m_gt_1(z+2) ){\n         z += 2;\n       }\n     }else if( z[3]=='s' || z[3]=='t' ){\n       stem(&z, \"noi\", \"\", m_gt_1);\n     }\n     break;\n   case 's':\n     if( z[0]=='m' && z[2]=='i' && m_gt_1(z+3) ){\n       z += 3;\n     }\n     break;\n   case 't':\n     stem(&z, \"eta\", \"\", m_gt_1) ||\n     stem(&z, \"iti\", \"\", m_gt_1);\n     break;\n   case 'u':\n     if( z[0]=='s' && z[2]=='o' && m_gt_1(z+3) ){\n       z += 3;\n     }\n     break;\n   case 'v':\n   case 'z':\n     if( z[0]=='e' && z[2]=='i' && m_gt_1(z+3) ){\n       z += 3;\n     }\n     break;\n  }\n\n  /* Step 5a */\n  if( z[0]=='e' ){\n    if( m_gt_1(z+1) ){\n      z++;\n    }else if( m_eq_1(z+1) && !star_oh(z+1) ){\n      z++;\n    }\n  }\n\n  /* Step 5b */\n  if( m_gt_1(z) && z[0]=='l' && z[1]=='l' ){\n    z++;\n  }\n\n  /* z[] is now the stemmed word in reverse order.  Flip it back\n  ** around into forward order and return.\n  */\n  *pnOut = i = (int)strlen(z);\n  zOut[i] = 0;\n  while( *z ){\n    zOut[--i] = *(z++);\n  }\n}\n\n/*\n** Characters that can be part of a token.  We assume any character\n** whose value is greater than 0x80 (any UTF character) can be\n** part of a token.  In other words, delimiters all must have\n** values of 0x7f or lower.\n*/\nstatic const char porterIdChar[] = {\n/* x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 xA xB xC xD xE xF */\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,  /* 3x */\n    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  /* 4x */\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1,  /* 5x */\n    0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  /* 6x */\n    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,  /* 7x */\n};\n#define isDelim(C) (((ch=C)&0x80)==0 && (ch<0x30 || !porterIdChar[ch-0x30]))\n\n/*\n** Extract the next token from a tokenization cursor.  The cursor must\n** have been opened by a prior call to porterOpen().\n*/\nstatic int porterNext(\n  sqlite3_tokenizer_cursor *pCursor,  /* Cursor returned by porterOpen */\n  const char **pzToken,               /* OUT: *pzToken is the token text */\n  int *pnBytes,                       /* OUT: Number of bytes in token */\n  int *piStartOffset,                 /* OUT: Starting offset of token */\n  int *piEndOffset,                   /* OUT: Ending offset of token */\n  int *piPosition                     /* OUT: Position integer of token */\n){\n  porter_tokenizer_cursor *c = (porter_tokenizer_cursor *) pCursor;\n  const char *z = c->zInput;\n\n  while( c->iOffset<c->nInput ){\n    int iStartOffset, ch;\n\n    /* Scan past delimiter characters */\n    while( c->iOffset<c->nInput && isDelim(z[c->iOffset]) ){\n      c->iOffset++;\n    }\n\n    /* Count non-delimiter characters. */\n    iStartOffset = c->iOffset;\n    while( c->iOffset<c->nInput && !isDelim(z[c->iOffset]) ){\n      c->iOffset++;\n    }\n\n    if( c->iOffset>iStartOffset ){\n      int n = c->iOffset-iStartOffset;\n      if( n>c->nAllocated ){\n        char *pNew;\n        c->nAllocated = n+20;\n        pNew = sqlite3_realloc(c->zToken, c->nAllocated);\n        if( !pNew ) return SQLITE_NOMEM;\n        c->zToken = pNew;\n      }\n      porter_stemmer(&z[iStartOffset], n, c->zToken, pnBytes);\n      *pzToken = c->zToken;\n      *piStartOffset = iStartOffset;\n      *piEndOffset = c->iOffset;\n      *piPosition = c->iToken++;\n      return SQLITE_OK;\n    }\n  }\n  return SQLITE_DONE;\n}\n\n/*\n** The set of routines that implement the porter-stemmer tokenizer\n*/\nstatic const sqlite3_tokenizer_module porterTokenizerModule = {\n  0,\n  porterCreate,\n  porterDestroy,\n  porterOpen,\n  porterClose,\n  porterNext,\n};\n\n/*\n** Allocate a new porter tokenizer.  Return a pointer to the new\n** tokenizer in *ppModule\n*/\nSQLITE_PRIVATE void sqlite3Fts3PorterTokenizerModule(\n  sqlite3_tokenizer_module const**ppModule\n){\n  *ppModule = &porterTokenizerModule;\n}\n\n#endif /* !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS3) */\n\n/************** End of fts3_porter.c *****************************************/\n/************** Begin file fts3_tokenizer.c **********************************/\n/*\n** 2007 June 22\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n******************************************************************************\n**\n** This is part of an SQLite module implementing full-text search.\n** This particular file implements the generic tokenizer interface.\n*/\n\n/*\n** The code in this file is only compiled if:\n**\n**     * The FTS3 module is being built as an extension\n**       (in which case SQLITE_CORE is not defined), or\n**\n**     * The FTS3 module is being built into the core of\n**       SQLite (in which case SQLITE_ENABLE_FTS3 is defined).\n*/\n#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS3)\n\n#ifndef SQLITE_CORE\n  SQLITE_EXTENSION_INIT1\n#endif\n\n\n/*\n** Implementation of the SQL scalar function for accessing the underlying \n** hash table. This function may be called as follows:\n**\n**   SELECT <function-name>(<key-name>);\n**   SELECT <function-name>(<key-name>, <pointer>);\n**\n** where <function-name> is the name passed as the second argument\n** to the sqlite3Fts3InitHashTable() function (e.g. 'fts3_tokenizer').\n**\n** If the <pointer> argument is specified, it must be a blob value\n** containing a pointer to be stored as the hash data corresponding\n** to the string <key-name>. If <pointer> is not specified, then\n** the string <key-name> must already exist in the has table. Otherwise,\n** an error is returned.\n**\n** Whether or not the <pointer> argument is specified, the value returned\n** is a blob containing the pointer stored as the hash data corresponding\n** to string <key-name> (after the hash-table is updated, if applicable).\n*/\nstatic void scalarFunc(\n  sqlite3_context *context,\n  int argc,\n  sqlite3_value **argv\n){\n  Fts3Hash *pHash;\n  void *pPtr = 0;\n  const unsigned char *zName;\n  int nName;\n\n  assert( argc==1 || argc==2 );\n\n  pHash = (Fts3Hash *)sqlite3_user_data(context);\n\n  zName = sqlite3_value_text(argv[0]);\n  nName = sqlite3_value_bytes(argv[0])+1;\n\n  if( argc==2 ){\n    void *pOld;\n    int n = sqlite3_value_bytes(argv[1]);\n    if( n!=sizeof(pPtr) ){\n      sqlite3_result_error(context, \"argument type mismatch\", -1);\n      return;\n    }\n    pPtr = *(void **)sqlite3_value_blob(argv[1]);\n    pOld = sqlite3Fts3HashInsert(pHash, (void *)zName, nName, pPtr);\n    if( pOld==pPtr ){\n      sqlite3_result_error(context, \"out of memory\", -1);\n      return;\n    }\n  }else{\n    pPtr = sqlite3Fts3HashFind(pHash, zName, nName);\n    if( !pPtr ){\n      char *zErr = sqlite3_mprintf(\"unknown tokenizer: %s\", zName);\n      sqlite3_result_error(context, zErr, -1);\n      sqlite3_free(zErr);\n      return;\n    }\n  }\n\n  sqlite3_result_blob(context, (void *)&pPtr, sizeof(pPtr), SQLITE_TRANSIENT);\n}\n\nSQLITE_PRIVATE int sqlite3Fts3IsIdChar(char c){\n  static const char isFtsIdChar[] = {\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  /* 0x */\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  /* 1x */\n      0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  /* 2x */\n      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,  /* 3x */\n      0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  /* 4x */\n      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1,  /* 5x */\n      0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  /* 6x */\n      1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,  /* 7x */\n  };\n  return (c&0x80 || isFtsIdChar[(int)(c)]);\n}\n\nSQLITE_PRIVATE const char *sqlite3Fts3NextToken(const char *zStr, int *pn){\n  const char *z1;\n  const char *z2 = 0;\n\n  /* Find the start of the next token. */\n  z1 = zStr;\n  while( z2==0 ){\n    char c = *z1;\n    switch( c ){\n      case '\\0': return 0;        /* No more tokens here */\n      case '\\'':\n      case '\"':\n      case '`': {\n        z2 = z1;\n        while( *++z2 && (*z2!=c || *++z2==c) );\n        break;\n      }\n      case '[':\n        z2 = &z1[1];\n        while( *z2 && z2[0]!=']' ) z2++;\n        if( *z2 ) z2++;\n        break;\n\n      default:\n        if( sqlite3Fts3IsIdChar(*z1) ){\n          z2 = &z1[1];\n          while( sqlite3Fts3IsIdChar(*z2) ) z2++;\n        }else{\n          z1++;\n        }\n    }\n  }\n\n  *pn = (int)(z2-z1);\n  return z1;\n}\n\nSQLITE_PRIVATE int sqlite3Fts3InitTokenizer(\n  Fts3Hash *pHash,                /* Tokenizer hash table */\n  const char *zArg,               /* Tokenizer name */\n  sqlite3_tokenizer **ppTok,      /* OUT: Tokenizer (if applicable) */\n  char **pzErr                    /* OUT: Set to malloced error message */\n){\n  int rc;\n  char *z = (char *)zArg;\n  int n;\n  char *zCopy;\n  char *zEnd;                     /* Pointer to nul-term of zCopy */\n  sqlite3_tokenizer_module *m;\n\n  zCopy = sqlite3_mprintf(\"%s\", zArg);\n  if( !zCopy ) return SQLITE_NOMEM;\n  zEnd = &zCopy[strlen(zCopy)];\n\n  z = (char *)sqlite3Fts3NextToken(zCopy, &n);\n  z[n] = '\\0';\n  sqlite3Fts3Dequote(z);\n\n  m = (sqlite3_tokenizer_module *)sqlite3Fts3HashFind(pHash,z,(int)strlen(z)+1);\n  if( !m ){\n    *pzErr = sqlite3_mprintf(\"unknown tokenizer: %s\", z);\n    rc = SQLITE_ERROR;\n  }else{\n    char const **aArg = 0;\n    int iArg = 0;\n    z = &z[n+1];\n    while( z<zEnd && (NULL!=(z = (char *)sqlite3Fts3NextToken(z, &n))) ){\n      int nNew = sizeof(char *)*(iArg+1);\n      char const **aNew = (const char **)sqlite3_realloc((void *)aArg, nNew);\n      if( !aNew ){\n        sqlite3_free(zCopy);\n        sqlite3_free((void *)aArg);\n        return SQLITE_NOMEM;\n      }\n      aArg = aNew;\n      aArg[iArg++] = z;\n      z[n] = '\\0';\n      sqlite3Fts3Dequote(z);\n      z = &z[n+1];\n    }\n    rc = m->xCreate(iArg, aArg, ppTok);\n    assert( rc!=SQLITE_OK || *ppTok );\n    if( rc!=SQLITE_OK ){\n      *pzErr = sqlite3_mprintf(\"unknown tokenizer\");\n    }else{\n      (*ppTok)->pModule = m; \n    }\n    sqlite3_free((void *)aArg);\n  }\n\n  sqlite3_free(zCopy);\n  return rc;\n}\n\n\n#ifdef SQLITE_TEST\n\n\n/*\n** Implementation of a special SQL scalar function for testing tokenizers \n** designed to be used in concert with the Tcl testing framework. This\n** function must be called with two arguments:\n**\n**   SELECT <function-name>(<key-name>, <input-string>);\n**   SELECT <function-name>(<key-name>, <pointer>);\n**\n** where <function-name> is the name passed as the second argument\n** to the sqlite3Fts3InitHashTable() function (e.g. 'fts3_tokenizer')\n** concatenated with the string '_test' (e.g. 'fts3_tokenizer_test').\n**\n** The return value is a string that may be interpreted as a Tcl\n** list. For each token in the <input-string>, three elements are\n** added to the returned list. The first is the token position, the \n** second is the token text (folded, stemmed, etc.) and the third is the\n** substring of <input-string> associated with the token. For example, \n** using the built-in \"simple\" tokenizer:\n**\n**   SELECT fts_tokenizer_test('simple', 'I don't see how');\n**\n** will return the string:\n**\n**   \"{0 i I 1 dont don't 2 see see 3 how how}\"\n**   \n*/\nstatic void testFunc(\n  sqlite3_context *context,\n  int argc,\n  sqlite3_value **argv\n){\n  Fts3Hash *pHash;\n  sqlite3_tokenizer_module *p;\n  sqlite3_tokenizer *pTokenizer = 0;\n  sqlite3_tokenizer_cursor *pCsr = 0;\n\n  const char *zErr = 0;\n\n  const char *zName;\n  int nName;\n  const char *zInput;\n  int nInput;\n\n  const char *zArg = 0;\n\n  const char *zToken;\n  int nToken;\n  int iStart;\n  int iEnd;\n  int iPos;\n\n  Tcl_Obj *pRet;\n\n  assert( argc==2 || argc==3 );\n\n  nName = sqlite3_value_bytes(argv[0]);\n  zName = (const char *)sqlite3_value_text(argv[0]);\n  nInput = sqlite3_value_bytes(argv[argc-1]);\n  zInput = (const char *)sqlite3_value_text(argv[argc-1]);\n\n  if( argc==3 ){\n    zArg = (const char *)sqlite3_value_text(argv[1]);\n  }\n\n  pHash = (Fts3Hash *)sqlite3_user_data(context);\n  p = (sqlite3_tokenizer_module *)sqlite3Fts3HashFind(pHash, zName, nName+1);\n\n  if( !p ){\n    char *zErr = sqlite3_mprintf(\"unknown tokenizer: %s\", zName);\n    sqlite3_result_error(context, zErr, -1);\n    sqlite3_free(zErr);\n    return;\n  }\n\n  pRet = Tcl_NewObj();\n  Tcl_IncrRefCount(pRet);\n\n  if( SQLITE_OK!=p->xCreate(zArg ? 1 : 0, &zArg, &pTokenizer) ){\n    zErr = \"error in xCreate()\";\n    goto finish;\n  }\n  pTokenizer->pModule = p;\n  if( SQLITE_OK!=p->xOpen(pTokenizer, zInput, nInput, &pCsr) ){\n    zErr = \"error in xOpen()\";\n    goto finish;\n  }\n  pCsr->pTokenizer = pTokenizer;\n\n  while( SQLITE_OK==p->xNext(pCsr, &zToken, &nToken, &iStart, &iEnd, &iPos) ){\n    Tcl_ListObjAppendElement(0, pRet, Tcl_NewIntObj(iPos));\n    Tcl_ListObjAppendElement(0, pRet, Tcl_NewStringObj(zToken, nToken));\n    zToken = &zInput[iStart];\n    nToken = iEnd-iStart;\n    Tcl_ListObjAppendElement(0, pRet, Tcl_NewStringObj(zToken, nToken));\n  }\n\n  if( SQLITE_OK!=p->xClose(pCsr) ){\n    zErr = \"error in xClose()\";\n    goto finish;\n  }\n  if( SQLITE_OK!=p->xDestroy(pTokenizer) ){\n    zErr = \"error in xDestroy()\";\n    goto finish;\n  }\n\nfinish:\n  if( zErr ){\n    sqlite3_result_error(context, zErr, -1);\n  }else{\n    sqlite3_result_text(context, Tcl_GetString(pRet), -1, SQLITE_TRANSIENT);\n  }\n  Tcl_DecrRefCount(pRet);\n}\n\nstatic\nint registerTokenizer(\n  sqlite3 *db, \n  char *zName, \n  const sqlite3_tokenizer_module *p\n){\n  int rc;\n  sqlite3_stmt *pStmt;\n  const char zSql[] = \"SELECT fts3_tokenizer(?, ?)\";\n\n  rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);\n  if( rc!=SQLITE_OK ){\n    return rc;\n  }\n\n  sqlite3_bind_text(pStmt, 1, zName, -1, SQLITE_STATIC);\n  sqlite3_bind_blob(pStmt, 2, &p, sizeof(p), SQLITE_STATIC);\n  sqlite3_step(pStmt);\n\n  return sqlite3_finalize(pStmt);\n}\n\nstatic\nint queryTokenizer(\n  sqlite3 *db, \n  char *zName,  \n  const sqlite3_tokenizer_module **pp\n){\n  int rc;\n  sqlite3_stmt *pStmt;\n  const char zSql[] = \"SELECT fts3_tokenizer(?)\";\n\n  *pp = 0;\n  rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);\n  if( rc!=SQLITE_OK ){\n    return rc;\n  }\n\n  sqlite3_bind_text(pStmt, 1, zName, -1, SQLITE_STATIC);\n  if( SQLITE_ROW==sqlite3_step(pStmt) ){\n    if( sqlite3_column_type(pStmt, 0)==SQLITE_BLOB ){\n      memcpy((void *)pp, sqlite3_column_blob(pStmt, 0), sizeof(*pp));\n    }\n  }\n\n  return sqlite3_finalize(pStmt);\n}\n\nSQLITE_PRIVATE void sqlite3Fts3SimpleTokenizerModule(sqlite3_tokenizer_module const**ppModule);\n\n/*\n** Implementation of the scalar function fts3_tokenizer_internal_test().\n** This function is used for testing only, it is not included in the\n** build unless SQLITE_TEST is defined.\n**\n** The purpose of this is to test that the fts3_tokenizer() function\n** can be used as designed by the C-code in the queryTokenizer and\n** registerTokenizer() functions above. These two functions are repeated\n** in the README.tokenizer file as an example, so it is important to\n** test them.\n**\n** To run the tests, evaluate the fts3_tokenizer_internal_test() scalar\n** function with no arguments. An assert() will fail if a problem is\n** detected. i.e.:\n**\n**     SELECT fts3_tokenizer_internal_test();\n**\n*/\nstatic void intTestFunc(\n  sqlite3_context *context,\n  int argc,\n  sqlite3_value **argv\n){\n  int rc;\n  const sqlite3_tokenizer_module *p1;\n  const sqlite3_tokenizer_module *p2;\n  sqlite3 *db = (sqlite3 *)sqlite3_user_data(context);\n\n  UNUSED_PARAMETER(argc);\n  UNUSED_PARAMETER(argv);\n\n  /* Test the query function */\n  sqlite3Fts3SimpleTokenizerModule(&p1);\n  rc = queryTokenizer(db, \"simple\", &p2);\n  assert( rc==SQLITE_OK );\n  assert( p1==p2 );\n  rc = queryTokenizer(db, \"nosuchtokenizer\", &p2);\n  assert( rc==SQLITE_ERROR );\n  assert( p2==0 );\n  assert( 0==strcmp(sqlite3_errmsg(db), \"unknown tokenizer: nosuchtokenizer\") );\n\n  /* Test the storage function */\n  rc = registerTokenizer(db, \"nosuchtokenizer\", p1);\n  assert( rc==SQLITE_OK );\n  rc = queryTokenizer(db, \"nosuchtokenizer\", &p2);\n  assert( rc==SQLITE_OK );\n  assert( p2==p1 );\n\n  sqlite3_result_text(context, \"ok\", -1, SQLITE_STATIC);\n}\n\n#endif\n\n/*\n** Set up SQL objects in database db used to access the contents of\n** the hash table pointed to by argument pHash. The hash table must\n** been initialised to use string keys, and to take a private copy \n** of the key when a value is inserted. i.e. by a call similar to:\n**\n**    sqlite3Fts3HashInit(pHash, FTS3_HASH_STRING, 1);\n**\n** This function adds a scalar function (see header comment above\n** scalarFunc() in this file for details) and, if ENABLE_TABLE is\n** defined at compilation time, a temporary virtual table (see header \n** comment above struct HashTableVtab) to the database schema. Both \n** provide read/write access to the contents of *pHash.\n**\n** The third argument to this function, zName, is used as the name\n** of both the scalar and, if created, the virtual table.\n*/\nSQLITE_PRIVATE int sqlite3Fts3InitHashTable(\n  sqlite3 *db, \n  Fts3Hash *pHash, \n  const char *zName\n){\n  int rc = SQLITE_OK;\n  void *p = (void *)pHash;\n  const int any = SQLITE_ANY;\n\n#ifdef SQLITE_TEST\n  char *zTest = 0;\n  char *zTest2 = 0;\n  void *pdb = (void *)db;\n  zTest = sqlite3_mprintf(\"%s_test\", zName);\n  zTest2 = sqlite3_mprintf(\"%s_internal_test\", zName);\n  if( !zTest || !zTest2 ){\n    rc = SQLITE_NOMEM;\n  }\n#endif\n\n  if( SQLITE_OK==rc ){\n    rc = sqlite3_create_function(db, zName, 1, any, p, scalarFunc, 0, 0);\n  }\n  if( SQLITE_OK==rc ){\n    rc = sqlite3_create_function(db, zName, 2, any, p, scalarFunc, 0, 0);\n  }\n#ifdef SQLITE_TEST\n  if( SQLITE_OK==rc ){\n    rc = sqlite3_create_function(db, zTest, 2, any, p, testFunc, 0, 0);\n  }\n  if( SQLITE_OK==rc ){\n    rc = sqlite3_create_function(db, zTest, 3, any, p, testFunc, 0, 0);\n  }\n  if( SQLITE_OK==rc ){\n    rc = sqlite3_create_function(db, zTest2, 0, any, pdb, intTestFunc, 0, 0);\n  }\n#endif\n\n#ifdef SQLITE_TEST\n  sqlite3_free(zTest);\n  sqlite3_free(zTest2);\n#endif\n\n  return rc;\n}\n\n#endif /* !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS3) */\n\n/************** End of fts3_tokenizer.c **************************************/\n/************** Begin file fts3_tokenizer1.c *********************************/\n/*\n** 2006 Oct 10\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n******************************************************************************\n**\n** Implementation of the \"simple\" full-text-search tokenizer.\n*/\n\n/*\n** The code in this file is only compiled if:\n**\n**     * The FTS3 module is being built as an extension\n**       (in which case SQLITE_CORE is not defined), or\n**\n**     * The FTS3 module is being built into the core of\n**       SQLite (in which case SQLITE_ENABLE_FTS3 is defined).\n*/\n#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS3)\n\n\n\n\ntypedef struct simple_tokenizer {\n  sqlite3_tokenizer base;\n  char delim[128];             /* flag ASCII delimiters */\n} simple_tokenizer;\n\ntypedef struct simple_tokenizer_cursor {\n  sqlite3_tokenizer_cursor base;\n  const char *pInput;          /* input we are tokenizing */\n  int nBytes;                  /* size of the input */\n  int iOffset;                 /* current position in pInput */\n  int iToken;                  /* index of next token to be returned */\n  char *pToken;                /* storage for current token */\n  int nTokenAllocated;         /* space allocated to zToken buffer */\n} simple_tokenizer_cursor;\n\n\nstatic int simpleDelim(simple_tokenizer *t, unsigned char c){\n  return c<0x80 && t->delim[c];\n}\nstatic int fts3_isalnum(int x){\n  return (x>='0' && x<='9') || (x>='A' && x<='Z') || (x>='a' && x<='z');\n}\n\n/*\n** Create a new tokenizer instance.\n*/\nstatic int simpleCreate(\n  int argc, const char * const *argv,\n  sqlite3_tokenizer **ppTokenizer\n){\n  simple_tokenizer *t;\n\n  t = (simple_tokenizer *) sqlite3_malloc(sizeof(*t));\n  if( t==NULL ) return SQLITE_NOMEM;\n  memset(t, 0, sizeof(*t));\n\n  /* TODO(shess) Delimiters need to remain the same from run to run,\n  ** else we need to reindex.  One solution would be a meta-table to\n  ** track such information in the database, then we'd only want this\n  ** information on the initial create.\n  */\n  if( argc>1 ){\n    int i, n = (int)strlen(argv[1]);\n    for(i=0; i<n; i++){\n      unsigned char ch = argv[1][i];\n      /* We explicitly don't support UTF-8 delimiters for now. */\n      if( ch>=0x80 ){\n        sqlite3_free(t);\n        return SQLITE_ERROR;\n      }\n      t->delim[ch] = 1;\n    }\n  } else {\n    /* Mark non-alphanumeric ASCII characters as delimiters */\n    int i;\n    for(i=1; i<0x80; i++){\n      t->delim[i] = !fts3_isalnum(i) ? -1 : 0;\n    }\n  }\n\n  *ppTokenizer = &t->base;\n  return SQLITE_OK;\n}\n\n/*\n** Destroy a tokenizer\n*/\nstatic int simpleDestroy(sqlite3_tokenizer *pTokenizer){\n  sqlite3_free(pTokenizer);\n  return SQLITE_OK;\n}\n\n/*\n** Prepare to begin tokenizing a particular string.  The input\n** string to be tokenized is pInput[0..nBytes-1].  A cursor\n** used to incrementally tokenize this string is returned in \n** *ppCursor.\n*/\nstatic int simpleOpen(\n  sqlite3_tokenizer *pTokenizer,         /* The tokenizer */\n  const char *pInput, int nBytes,        /* String to be tokenized */\n  sqlite3_tokenizer_cursor **ppCursor    /* OUT: Tokenization cursor */\n){\n  simple_tokenizer_cursor *c;\n\n  UNUSED_PARAMETER(pTokenizer);\n\n  c = (simple_tokenizer_cursor *) sqlite3_malloc(sizeof(*c));\n  if( c==NULL ) return SQLITE_NOMEM;\n\n  c->pInput = pInput;\n  if( pInput==0 ){\n    c->nBytes = 0;\n  }else if( nBytes<0 ){\n    c->nBytes = (int)strlen(pInput);\n  }else{\n    c->nBytes = nBytes;\n  }\n  c->iOffset = 0;                 /* start tokenizing at the beginning */\n  c->iToken = 0;\n  c->pToken = NULL;               /* no space allocated, yet. */\n  c->nTokenAllocated = 0;\n\n  *ppCursor = &c->base;\n  return SQLITE_OK;\n}\n\n/*\n** Close a tokenization cursor previously opened by a call to\n** simpleOpen() above.\n*/\nstatic int simpleClose(sqlite3_tokenizer_cursor *pCursor){\n  simple_tokenizer_cursor *c = (simple_tokenizer_cursor *) pCursor;\n  sqlite3_free(c->pToken);\n  sqlite3_free(c);\n  return SQLITE_OK;\n}\n\n/*\n** Extract the next token from a tokenization cursor.  The cursor must\n** have been opened by a prior call to simpleOpen().\n*/\nstatic int simpleNext(\n  sqlite3_tokenizer_cursor *pCursor,  /* Cursor returned by simpleOpen */\n  const char **ppToken,               /* OUT: *ppToken is the token text */\n  int *pnBytes,                       /* OUT: Number of bytes in token */\n  int *piStartOffset,                 /* OUT: Starting offset of token */\n  int *piEndOffset,                   /* OUT: Ending offset of token */\n  int *piPosition                     /* OUT: Position integer of token */\n){\n  simple_tokenizer_cursor *c = (simple_tokenizer_cursor *) pCursor;\n  simple_tokenizer *t = (simple_tokenizer *) pCursor->pTokenizer;\n  unsigned char *p = (unsigned char *)c->pInput;\n\n  while( c->iOffset<c->nBytes ){\n    int iStartOffset;\n\n    /* Scan past delimiter characters */\n    while( c->iOffset<c->nBytes && simpleDelim(t, p[c->iOffset]) ){\n      c->iOffset++;\n    }\n\n    /* Count non-delimiter characters. */\n    iStartOffset = c->iOffset;\n    while( c->iOffset<c->nBytes && !simpleDelim(t, p[c->iOffset]) ){\n      c->iOffset++;\n    }\n\n    if( c->iOffset>iStartOffset ){\n      int i, n = c->iOffset-iStartOffset;\n      if( n>c->nTokenAllocated ){\n        char *pNew;\n        c->nTokenAllocated = n+20;\n        pNew = sqlite3_realloc(c->pToken, c->nTokenAllocated);\n        if( !pNew ) return SQLITE_NOMEM;\n        c->pToken = pNew;\n      }\n      for(i=0; i<n; i++){\n        /* TODO(shess) This needs expansion to handle UTF-8\n        ** case-insensitivity.\n        */\n        unsigned char ch = p[iStartOffset+i];\n        c->pToken[i] = (char)((ch>='A' && ch<='Z') ? ch-'A'+'a' : ch);\n      }\n      *ppToken = c->pToken;\n      *pnBytes = n;\n      *piStartOffset = iStartOffset;\n      *piEndOffset = c->iOffset;\n      *piPosition = c->iToken++;\n\n      return SQLITE_OK;\n    }\n  }\n  return SQLITE_DONE;\n}\n\n/*\n** The set of routines that implement the simple tokenizer\n*/\nstatic const sqlite3_tokenizer_module simpleTokenizerModule = {\n  0,\n  simpleCreate,\n  simpleDestroy,\n  simpleOpen,\n  simpleClose,\n  simpleNext,\n};\n\n/*\n** Allocate a new simple tokenizer.  Return a pointer to the new\n** tokenizer in *ppModule\n*/\nSQLITE_PRIVATE void sqlite3Fts3SimpleTokenizerModule(\n  sqlite3_tokenizer_module const**ppModule\n){\n  *ppModule = &simpleTokenizerModule;\n}\n\n#endif /* !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS3) */\n\n/************** End of fts3_tokenizer1.c *************************************/\n/************** Begin file fts3_write.c **************************************/\n/*\n** 2009 Oct 23\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n******************************************************************************\n**\n** This file is part of the SQLite FTS3 extension module. Specifically,\n** this file contains code to insert, update and delete rows from FTS3\n** tables. It also contains code to merge FTS3 b-tree segments. Some\n** of the sub-routines used to merge segments are also used by the query \n** code in fts3.c.\n*/\n\n#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS3)\n\n\n/*\n** When full-text index nodes are loaded from disk, the buffer that they\n** are loaded into has the following number of bytes of padding at the end \n** of it. i.e. if a full-text index node is 900 bytes in size, then a buffer\n** of 920 bytes is allocated for it.\n**\n** This means that if we have a pointer into a buffer containing node data,\n** it is always safe to read up to two varints from it without risking an\n** overread, even if the node data is corrupted.\n*/\n#define FTS3_NODE_PADDING (FTS3_VARINT_MAX*2)\n\ntypedef struct PendingList PendingList;\ntypedef struct SegmentNode SegmentNode;\ntypedef struct SegmentWriter SegmentWriter;\n\n/*\n** Data structure used while accumulating terms in the pending-terms hash\n** table. The hash table entry maps from term (a string) to a malloc'd\n** instance of this structure.\n*/\nstruct PendingList {\n  int nData;\n  char *aData;\n  int nSpace;\n  sqlite3_int64 iLastDocid;\n  sqlite3_int64 iLastCol;\n  sqlite3_int64 iLastPos;\n};\n\n\n/*\n** Each cursor has a (possibly empty) linked list of the following objects.\n*/\nstruct Fts3DeferredToken {\n  Fts3PhraseToken *pToken;        /* Pointer to corresponding expr token */\n  int iCol;                       /* Column token must occur in */\n  Fts3DeferredToken *pNext;       /* Next in list of deferred tokens */\n  PendingList *pList;             /* Doclist is assembled here */\n};\n\n/*\n** An instance of this structure is used to iterate through the terms on\n** a contiguous set of segment b-tree leaf nodes. Although the details of\n** this structure are only manipulated by code in this file, opaque handles\n** of type Fts3SegReader* are also used by code in fts3.c to iterate through\n** terms when querying the full-text index. See functions:\n**\n**   sqlite3Fts3SegReaderNew()\n**   sqlite3Fts3SegReaderFree()\n**   sqlite3Fts3SegReaderCost()\n**   sqlite3Fts3SegReaderIterate()\n**\n** Methods used to manipulate Fts3SegReader structures:\n**\n**   fts3SegReaderNext()\n**   fts3SegReaderFirstDocid()\n**   fts3SegReaderNextDocid()\n*/\nstruct Fts3SegReader {\n  int iIdx;                       /* Index within level, or 0x7FFFFFFF for PT */\n\n  sqlite3_int64 iStartBlock;      /* Rowid of first leaf block to traverse */\n  sqlite3_int64 iLeafEndBlock;    /* Rowid of final leaf block to traverse */\n  sqlite3_int64 iEndBlock;        /* Rowid of final block in segment (or 0) */\n  sqlite3_int64 iCurrentBlock;    /* Current leaf block (or 0) */\n\n  char *aNode;                    /* Pointer to node data (or NULL) */\n  int nNode;                      /* Size of buffer at aNode (or 0) */\n  Fts3HashElem **ppNextElem;\n\n  /* Variables set by fts3SegReaderNext(). These may be read directly\n  ** by the caller. They are valid from the time SegmentReaderNew() returns\n  ** until SegmentReaderNext() returns something other than SQLITE_OK\n  ** (i.e. SQLITE_DONE).\n  */\n  int nTerm;                      /* Number of bytes in current term */\n  char *zTerm;                    /* Pointer to current term */\n  int nTermAlloc;                 /* Allocated size of zTerm buffer */\n  char *aDoclist;                 /* Pointer to doclist of current entry */\n  int nDoclist;                   /* Size of doclist in current entry */\n\n  /* The following variables are used to iterate through the current doclist */\n  char *pOffsetList;\n  sqlite3_int64 iDocid;\n};\n\n#define fts3SegReaderIsPending(p) ((p)->ppNextElem!=0)\n#define fts3SegReaderIsRootOnly(p) ((p)->aNode==(char *)&(p)[1])\n\n/*\n** An instance of this structure is used to create a segment b-tree in the\n** database. The internal details of this type are only accessed by the\n** following functions:\n**\n**   fts3SegWriterAdd()\n**   fts3SegWriterFlush()\n**   fts3SegWriterFree()\n*/\nstruct SegmentWriter {\n  SegmentNode *pTree;             /* Pointer to interior tree structure */\n  sqlite3_int64 iFirst;           /* First slot in %_segments written */\n  sqlite3_int64 iFree;            /* Next free slot in %_segments */\n  char *zTerm;                    /* Pointer to previous term buffer */\n  int nTerm;                      /* Number of bytes in zTerm */\n  int nMalloc;                    /* Size of malloc'd buffer at zMalloc */\n  char *zMalloc;                  /* Malloc'd space (possibly) used for zTerm */\n  int nSize;                      /* Size of allocation at aData */\n  int nData;                      /* Bytes of data in aData */\n  char *aData;                    /* Pointer to block from malloc() */\n};\n\n/*\n** Type SegmentNode is used by the following three functions to create\n** the interior part of the segment b+-tree structures (everything except\n** the leaf nodes). These functions and type are only ever used by code\n** within the fts3SegWriterXXX() family of functions described above.\n**\n**   fts3NodeAddTerm()\n**   fts3NodeWrite()\n**   fts3NodeFree()\n*/\nstruct SegmentNode {\n  SegmentNode *pParent;           /* Parent node (or NULL for root node) */\n  SegmentNode *pRight;            /* Pointer to right-sibling */\n  SegmentNode *pLeftmost;         /* Pointer to left-most node of this depth */\n  int nEntry;                     /* Number of terms written to node so far */\n  char *zTerm;                    /* Pointer to previous term buffer */\n  int nTerm;                      /* Number of bytes in zTerm */\n  int nMalloc;                    /* Size of malloc'd buffer at zMalloc */\n  char *zMalloc;                  /* Malloc'd space (possibly) used for zTerm */\n  int nData;                      /* Bytes of valid data so far */\n  char *aData;                    /* Node data */\n};\n\n/*\n** Valid values for the second argument to fts3SqlStmt().\n*/\n#define SQL_DELETE_CONTENT             0\n#define SQL_IS_EMPTY                   1\n#define SQL_DELETE_ALL_CONTENT         2 \n#define SQL_DELETE_ALL_SEGMENTS        3\n#define SQL_DELETE_ALL_SEGDIR          4\n#define SQL_DELETE_ALL_DOCSIZE         5\n#define SQL_DELETE_ALL_STAT            6\n#define SQL_SELECT_CONTENT_BY_ROWID    7\n#define SQL_NEXT_SEGMENT_INDEX         8\n#define SQL_INSERT_SEGMENTS            9\n#define SQL_NEXT_SEGMENTS_ID          10\n#define SQL_INSERT_SEGDIR             11\n#define SQL_SELECT_LEVEL              12\n#define SQL_SELECT_ALL_LEVEL          13\n#define SQL_SELECT_LEVEL_COUNT        14\n#define SQL_SELECT_SEGDIR_COUNT_MAX   15\n#define SQL_DELETE_SEGDIR_BY_LEVEL    16\n#define SQL_DELETE_SEGMENTS_RANGE     17\n#define SQL_CONTENT_INSERT            18\n#define SQL_DELETE_DOCSIZE            19\n#define SQL_REPLACE_DOCSIZE           20\n#define SQL_SELECT_DOCSIZE            21\n#define SQL_SELECT_DOCTOTAL           22\n#define SQL_REPLACE_DOCTOTAL          23\n\n/*\n** This function is used to obtain an SQLite prepared statement handle\n** for the statement identified by the second argument. If successful,\n** *pp is set to the requested statement handle and SQLITE_OK returned.\n** Otherwise, an SQLite error code is returned and *pp is set to 0.\n**\n** If argument apVal is not NULL, then it must point to an array with\n** at least as many entries as the requested statement has bound \n** parameters. The values are bound to the statements parameters before\n** returning.\n*/\nstatic int fts3SqlStmt(\n  Fts3Table *p,                   /* Virtual table handle */\n  int eStmt,                      /* One of the SQL_XXX constants above */\n  sqlite3_stmt **pp,              /* OUT: Statement handle */\n  sqlite3_value **apVal           /* Values to bind to statement */\n){\n  const char *azSql[] = {\n/* 0  */  \"DELETE FROM %Q.'%q_content' WHERE rowid = ?\",\n/* 1  */  \"SELECT NOT EXISTS(SELECT docid FROM %Q.'%q_content' WHERE rowid!=?)\",\n/* 2  */  \"DELETE FROM %Q.'%q_content'\",\n/* 3  */  \"DELETE FROM %Q.'%q_segments'\",\n/* 4  */  \"DELETE FROM %Q.'%q_segdir'\",\n/* 5  */  \"DELETE FROM %Q.'%q_docsize'\",\n/* 6  */  \"DELETE FROM %Q.'%q_stat'\",\n/* 7  */  \"SELECT %s FROM %Q.'%q_content' AS x WHERE rowid=?\",\n/* 8  */  \"SELECT (SELECT max(idx) FROM %Q.'%q_segdir' WHERE level = ?) + 1\",\n/* 9  */  \"INSERT INTO %Q.'%q_segments'(blockid, block) VALUES(?, ?)\",\n/* 10 */  \"SELECT coalesce((SELECT max(blockid) FROM %Q.'%q_segments') + 1, 1)\",\n/* 11 */  \"INSERT INTO %Q.'%q_segdir' VALUES(?,?,?,?,?,?)\",\n\n          /* Return segments in order from oldest to newest.*/ \n/* 12 */  \"SELECT idx, start_block, leaves_end_block, end_block, root \"\n            \"FROM %Q.'%q_segdir' WHERE level = ? ORDER BY idx ASC\",\n/* 13 */  \"SELECT idx, start_block, leaves_end_block, end_block, root \"\n            \"FROM %Q.'%q_segdir' ORDER BY level DESC, idx ASC\",\n\n/* 14 */  \"SELECT count(*) FROM %Q.'%q_segdir' WHERE level = ?\",\n/* 15 */  \"SELECT count(*), max(level) FROM %Q.'%q_segdir'\",\n\n/* 16 */  \"DELETE FROM %Q.'%q_segdir' WHERE level = ?\",\n/* 17 */  \"DELETE FROM %Q.'%q_segments' WHERE blockid BETWEEN ? AND ?\",\n/* 18 */  \"INSERT INTO %Q.'%q_content' VALUES(%s)\",\n/* 19 */  \"DELETE FROM %Q.'%q_docsize' WHERE docid = ?\",\n/* 20 */  \"REPLACE INTO %Q.'%q_docsize' VALUES(?,?)\",\n/* 21 */  \"SELECT size FROM %Q.'%q_docsize' WHERE docid=?\",\n/* 22 */  \"SELECT value FROM %Q.'%q_stat' WHERE id=0\",\n/* 23 */  \"REPLACE INTO %Q.'%q_stat' VALUES(0,?)\",\n  };\n  int rc = SQLITE_OK;\n  sqlite3_stmt *pStmt;\n\n  assert( SizeofArray(azSql)==SizeofArray(p->aStmt) );\n  assert( eStmt<SizeofArray(azSql) && eStmt>=0 );\n  \n  pStmt = p->aStmt[eStmt];\n  if( !pStmt ){\n    char *zSql;\n    if( eStmt==SQL_CONTENT_INSERT ){\n      zSql = sqlite3_mprintf(azSql[eStmt], p->zDb, p->zName, p->zWriteExprlist);\n    }else if( eStmt==SQL_SELECT_CONTENT_BY_ROWID ){\n      zSql = sqlite3_mprintf(azSql[eStmt], p->zReadExprlist, p->zDb, p->zName);\n    }else{\n      zSql = sqlite3_mprintf(azSql[eStmt], p->zDb, p->zName);\n    }\n    if( !zSql ){\n      rc = SQLITE_NOMEM;\n    }else{\n      rc = sqlite3_prepare_v2(p->db, zSql, -1, &pStmt, NULL);\n      sqlite3_free(zSql);\n      assert( rc==SQLITE_OK || pStmt==0 );\n      p->aStmt[eStmt] = pStmt;\n    }\n  }\n  if( apVal ){\n    int i;\n    int nParam = sqlite3_bind_parameter_count(pStmt);\n    for(i=0; rc==SQLITE_OK && i<nParam; i++){\n      rc = sqlite3_bind_value(pStmt, i+1, apVal[i]);\n    }\n  }\n  *pp = pStmt;\n  return rc;\n}\n\nstatic int fts3SelectDocsize(\n  Fts3Table *pTab,                /* FTS3 table handle */\n  int eStmt,                      /* Either SQL_SELECT_DOCSIZE or DOCTOTAL */\n  sqlite3_int64 iDocid,           /* Docid to bind for SQL_SELECT_DOCSIZE */\n  sqlite3_stmt **ppStmt           /* OUT: Statement handle */\n){\n  sqlite3_stmt *pStmt = 0;        /* Statement requested from fts3SqlStmt() */\n  int rc;                         /* Return code */\n\n  assert( eStmt==SQL_SELECT_DOCSIZE || eStmt==SQL_SELECT_DOCTOTAL );\n\n  rc = fts3SqlStmt(pTab, eStmt, &pStmt, 0);\n  if( rc==SQLITE_OK ){\n    if( eStmt==SQL_SELECT_DOCSIZE ){\n      sqlite3_bind_int64(pStmt, 1, iDocid);\n    }\n    rc = sqlite3_step(pStmt);\n    if( rc!=SQLITE_ROW || sqlite3_column_type(pStmt, 0)!=SQLITE_BLOB ){\n      rc = sqlite3_reset(pStmt);\n      if( rc==SQLITE_OK ) rc = SQLITE_CORRUPT;\n      pStmt = 0;\n    }else{\n      rc = SQLITE_OK;\n    }\n  }\n\n  *ppStmt = pStmt;\n  return rc;\n}\n\nSQLITE_PRIVATE int sqlite3Fts3SelectDoctotal(\n  Fts3Table *pTab,                /* Fts3 table handle */\n  sqlite3_stmt **ppStmt           /* OUT: Statement handle */\n){\n  return fts3SelectDocsize(pTab, SQL_SELECT_DOCTOTAL, 0, ppStmt);\n}\n\nSQLITE_PRIVATE int sqlite3Fts3SelectDocsize(\n  Fts3Table *pTab,                /* Fts3 table handle */\n  sqlite3_int64 iDocid,           /* Docid to read size data for */\n  sqlite3_stmt **ppStmt           /* OUT: Statement handle */\n){\n  return fts3SelectDocsize(pTab, SQL_SELECT_DOCSIZE, iDocid, ppStmt);\n}\n\n/*\n** Similar to fts3SqlStmt(). Except, after binding the parameters in\n** array apVal[] to the SQL statement identified by eStmt, the statement\n** is executed.\n**\n** Returns SQLITE_OK if the statement is successfully executed, or an\n** SQLite error code otherwise.\n*/\nstatic void fts3SqlExec(\n  int *pRC,                /* Result code */\n  Fts3Table *p,            /* The FTS3 table */\n  int eStmt,               /* Index of statement to evaluate */\n  sqlite3_value **apVal    /* Parameters to bind */\n){\n  sqlite3_stmt *pStmt;\n  int rc;\n  if( *pRC ) return;\n  rc = fts3SqlStmt(p, eStmt, &pStmt, apVal); \n  if( rc==SQLITE_OK ){\n    sqlite3_step(pStmt);\n    rc = sqlite3_reset(pStmt);\n  }\n  *pRC = rc;\n}\n\n\n/*\n** This function ensures that the caller has obtained a shared-cache\n** table-lock on the %_content table. This is required before reading\n** data from the fts3 table. If this lock is not acquired first, then\n** the caller may end up holding read-locks on the %_segments and %_segdir\n** tables, but no read-lock on the %_content table. If this happens \n** a second connection will be able to write to the fts3 table, but\n** attempting to commit those writes might return SQLITE_LOCKED or\n** SQLITE_LOCKED_SHAREDCACHE (because the commit attempts to obtain \n** write-locks on the %_segments and %_segdir ** tables). \n**\n** We try to avoid this because if FTS3 returns any error when committing\n** a transaction, the whole transaction will be rolled back. And this is\n** not what users expect when they get SQLITE_LOCKED_SHAREDCACHE. It can\n** still happen if the user reads data directly from the %_segments or\n** %_segdir tables instead of going through FTS3 though.\n*/\nSQLITE_PRIVATE int sqlite3Fts3ReadLock(Fts3Table *p){\n  int rc;                         /* Return code */\n  sqlite3_stmt *pStmt;            /* Statement used to obtain lock */\n\n  rc = fts3SqlStmt(p, SQL_SELECT_CONTENT_BY_ROWID, &pStmt, 0);\n  if( rc==SQLITE_OK ){\n    sqlite3_bind_null(pStmt, 1);\n    sqlite3_step(pStmt);\n    rc = sqlite3_reset(pStmt);\n  }\n  return rc;\n}\n\n/*\n** Set *ppStmt to a statement handle that may be used to iterate through\n** all rows in the %_segdir table, from oldest to newest. If successful,\n** return SQLITE_OK. If an error occurs while preparing the statement, \n** return an SQLite error code.\n**\n** There is only ever one instance of this SQL statement compiled for\n** each FTS3 table.\n**\n** The statement returns the following columns from the %_segdir table:\n**\n**   0: idx\n**   1: start_block\n**   2: leaves_end_block\n**   3: end_block\n**   4: root\n*/\nSQLITE_PRIVATE int sqlite3Fts3AllSegdirs(Fts3Table *p, int iLevel, sqlite3_stmt **ppStmt){\n  int rc;\n  sqlite3_stmt *pStmt = 0;\n  if( iLevel<0 ){\n    rc = fts3SqlStmt(p, SQL_SELECT_ALL_LEVEL, &pStmt, 0);\n  }else{\n    rc = fts3SqlStmt(p, SQL_SELECT_LEVEL, &pStmt, 0);\n    if( rc==SQLITE_OK ) sqlite3_bind_int(pStmt, 1, iLevel);\n  }\n  *ppStmt = pStmt;\n  return rc;\n}\n\n\n/*\n** Append a single varint to a PendingList buffer. SQLITE_OK is returned\n** if successful, or an SQLite error code otherwise.\n**\n** This function also serves to allocate the PendingList structure itself.\n** For example, to create a new PendingList structure containing two\n** varints:\n**\n**   PendingList *p = 0;\n**   fts3PendingListAppendVarint(&p, 1);\n**   fts3PendingListAppendVarint(&p, 2);\n*/\nstatic int fts3PendingListAppendVarint(\n  PendingList **pp,               /* IN/OUT: Pointer to PendingList struct */\n  sqlite3_int64 i                 /* Value to append to data */\n){\n  PendingList *p = *pp;\n\n  /* Allocate or grow the PendingList as required. */\n  if( !p ){\n    p = sqlite3_malloc(sizeof(*p) + 100);\n    if( !p ){\n      return SQLITE_NOMEM;\n    }\n    p->nSpace = 100;\n    p->aData = (char *)&p[1];\n    p->nData = 0;\n  }\n  else if( p->nData+FTS3_VARINT_MAX+1>p->nSpace ){\n    int nNew = p->nSpace * 2;\n    p = sqlite3_realloc(p, sizeof(*p) + nNew);\n    if( !p ){\n      sqlite3_free(*pp);\n      *pp = 0;\n      return SQLITE_NOMEM;\n    }\n    p->nSpace = nNew;\n    p->aData = (char *)&p[1];\n  }\n\n  /* Append the new serialized varint to the end of the list. */\n  p->nData += sqlite3Fts3PutVarint(&p->aData[p->nData], i);\n  p->aData[p->nData] = '\\0';\n  *pp = p;\n  return SQLITE_OK;\n}\n\n/*\n** Add a docid/column/position entry to a PendingList structure. Non-zero\n** is returned if the structure is sqlite3_realloced as part of adding\n** the entry. Otherwise, zero.\n**\n** If an OOM error occurs, *pRc is set to SQLITE_NOMEM before returning.\n** Zero is always returned in this case. Otherwise, if no OOM error occurs,\n** it is set to SQLITE_OK.\n*/\nstatic int fts3PendingListAppend(\n  PendingList **pp,               /* IN/OUT: PendingList structure */\n  sqlite3_int64 iDocid,           /* Docid for entry to add */\n  sqlite3_int64 iCol,             /* Column for entry to add */\n  sqlite3_int64 iPos,             /* Position of term for entry to add */\n  int *pRc                        /* OUT: Return code */\n){\n  PendingList *p = *pp;\n  int rc = SQLITE_OK;\n\n  assert( !p || p->iLastDocid<=iDocid );\n\n  if( !p || p->iLastDocid!=iDocid ){\n    sqlite3_int64 iDelta = iDocid - (p ? p->iLastDocid : 0);\n    if( p ){\n      assert( p->nData<p->nSpace );\n      assert( p->aData[p->nData]==0 );\n      p->nData++;\n    }\n    if( SQLITE_OK!=(rc = fts3PendingListAppendVarint(&p, iDelta)) ){\n      goto pendinglistappend_out;\n    }\n    p->iLastCol = -1;\n    p->iLastPos = 0;\n    p->iLastDocid = iDocid;\n  }\n  if( iCol>0 && p->iLastCol!=iCol ){\n    if( SQLITE_OK!=(rc = fts3PendingListAppendVarint(&p, 1))\n     || SQLITE_OK!=(rc = fts3PendingListAppendVarint(&p, iCol))\n    ){\n      goto pendinglistappend_out;\n    }\n    p->iLastCol = iCol;\n    p->iLastPos = 0;\n  }\n  if( iCol>=0 ){\n    assert( iPos>p->iLastPos || (iPos==0 && p->iLastPos==0) );\n    rc = fts3PendingListAppendVarint(&p, 2+iPos-p->iLastPos);\n    if( rc==SQLITE_OK ){\n      p->iLastPos = iPos;\n    }\n  }\n\n pendinglistappend_out:\n  *pRc = rc;\n  if( p!=*pp ){\n    *pp = p;\n    return 1;\n  }\n  return 0;\n}\n\n/*\n** Tokenize the nul-terminated string zText and add all tokens to the\n** pending-terms hash-table. The docid used is that currently stored in\n** p->iPrevDocid, and the column is specified by argument iCol.\n**\n** If successful, SQLITE_OK is returned. Otherwise, an SQLite error code.\n*/\nstatic int fts3PendingTermsAdd(\n  Fts3Table *p,                   /* Table into which text will be inserted */\n  const char *zText,              /* Text of document to be inserted */\n  int iCol,                       /* Column into which text is being inserted */\n  u32 *pnWord                     /* OUT: Number of tokens inserted */\n){\n  int rc;\n  int iStart;\n  int iEnd;\n  int iPos;\n  int nWord = 0;\n\n  char const *zToken;\n  int nToken;\n\n  sqlite3_tokenizer *pTokenizer = p->pTokenizer;\n  sqlite3_tokenizer_module const *pModule = pTokenizer->pModule;\n  sqlite3_tokenizer_cursor *pCsr;\n  int (*xNext)(sqlite3_tokenizer_cursor *pCursor,\n      const char**,int*,int*,int*,int*);\n\n  assert( pTokenizer && pModule );\n\n  rc = pModule->xOpen(pTokenizer, zText, -1, &pCsr);\n  if( rc!=SQLITE_OK ){\n    return rc;\n  }\n  pCsr->pTokenizer = pTokenizer;\n\n  xNext = pModule->xNext;\n  while( SQLITE_OK==rc\n      && SQLITE_OK==(rc = xNext(pCsr, &zToken, &nToken, &iStart, &iEnd, &iPos))\n  ){\n    PendingList *pList;\n \n    if( iPos>=nWord ) nWord = iPos+1;\n\n    /* Positions cannot be negative; we use -1 as a terminator internally.\n    ** Tokens must have a non-zero length.\n    */\n    if( iPos<0 || !zToken || nToken<=0 ){\n      rc = SQLITE_ERROR;\n      break;\n    }\n\n    pList = (PendingList *)fts3HashFind(&p->pendingTerms, zToken, nToken);\n    if( pList ){\n      p->nPendingData -= (pList->nData + nToken + sizeof(Fts3HashElem));\n    }\n    if( fts3PendingListAppend(&pList, p->iPrevDocid, iCol, iPos, &rc) ){\n      if( pList==fts3HashInsert(&p->pendingTerms, zToken, nToken, pList) ){\n        /* Malloc failed while inserting the new entry. This can only \n        ** happen if there was no previous entry for this token.\n        */\n        assert( 0==fts3HashFind(&p->pendingTerms, zToken, nToken) );\n        sqlite3_free(pList);\n        rc = SQLITE_NOMEM;\n      }\n    }\n    if( rc==SQLITE_OK ){\n      p->nPendingData += (pList->nData + nToken + sizeof(Fts3HashElem));\n    }\n  }\n\n  pModule->xClose(pCsr);\n  *pnWord = nWord;\n  return (rc==SQLITE_DONE ? SQLITE_OK : rc);\n}\n\n/* \n** Calling this function indicates that subsequent calls to \n** fts3PendingTermsAdd() are to add term/position-list pairs for the\n** contents of the document with docid iDocid.\n*/\nstatic int fts3PendingTermsDocid(Fts3Table *p, sqlite_int64 iDocid){\n  /* TODO(shess) Explore whether partially flushing the buffer on\n  ** forced-flush would provide better performance.  I suspect that if\n  ** we ordered the doclists by size and flushed the largest until the\n  ** buffer was half empty, that would let the less frequent terms\n  ** generate longer doclists.\n  */\n  if( iDocid<=p->iPrevDocid || p->nPendingData>p->nMaxPendingData ){\n    int rc = sqlite3Fts3PendingTermsFlush(p);\n    if( rc!=SQLITE_OK ) return rc;\n  }\n  p->iPrevDocid = iDocid;\n  return SQLITE_OK;\n}\n\n/*\n** Discard the contents of the pending-terms hash table. \n*/\nSQLITE_PRIVATE void sqlite3Fts3PendingTermsClear(Fts3Table *p){\n  Fts3HashElem *pElem;\n  for(pElem=fts3HashFirst(&p->pendingTerms); pElem; pElem=fts3HashNext(pElem)){\n    sqlite3_free(fts3HashData(pElem));\n  }\n  fts3HashClear(&p->pendingTerms);\n  p->nPendingData = 0;\n}\n\n/*\n** This function is called by the xUpdate() method as part of an INSERT\n** operation. It adds entries for each term in the new record to the\n** pendingTerms hash table.\n**\n** Argument apVal is the same as the similarly named argument passed to\n** fts3InsertData(). Parameter iDocid is the docid of the new row.\n*/\nstatic int fts3InsertTerms(Fts3Table *p, sqlite3_value **apVal, u32 *aSz){\n  int i;                          /* Iterator variable */\n  for(i=2; i<p->nColumn+2; i++){\n    const char *zText = (const char *)sqlite3_value_text(apVal[i]);\n    if( zText ){\n      int rc = fts3PendingTermsAdd(p, zText, i-2, &aSz[i-2]);\n      if( rc!=SQLITE_OK ){\n        return rc;\n      }\n    }\n    aSz[p->nColumn] += sqlite3_value_bytes(apVal[i]);\n  }\n  return SQLITE_OK;\n}\n\n/*\n** This function is called by the xUpdate() method for an INSERT operation.\n** The apVal parameter is passed a copy of the apVal argument passed by\n** SQLite to the xUpdate() method. i.e:\n**\n**   apVal[0]                Not used for INSERT.\n**   apVal[1]                rowid\n**   apVal[2]                Left-most user-defined column\n**   ...\n**   apVal[p->nColumn+1]     Right-most user-defined column\n**   apVal[p->nColumn+2]     Hidden column with same name as table\n**   apVal[p->nColumn+3]     Hidden \"docid\" column (alias for rowid)\n*/\nstatic int fts3InsertData(\n  Fts3Table *p,                   /* Full-text table */\n  sqlite3_value **apVal,          /* Array of values to insert */\n  sqlite3_int64 *piDocid          /* OUT: Docid for row just inserted */\n){\n  int rc;                         /* Return code */\n  sqlite3_stmt *pContentInsert;   /* INSERT INTO %_content VALUES(...) */\n\n  /* Locate the statement handle used to insert data into the %_content\n  ** table. The SQL for this statement is:\n  **\n  **   INSERT INTO %_content VALUES(?, ?, ?, ...)\n  **\n  ** The statement features N '?' variables, where N is the number of user\n  ** defined columns in the FTS3 table, plus one for the docid field.\n  */\n  rc = fts3SqlStmt(p, SQL_CONTENT_INSERT, &pContentInsert, &apVal[1]);\n  if( rc!=SQLITE_OK ){\n    return rc;\n  }\n\n  /* There is a quirk here. The users INSERT statement may have specified\n  ** a value for the \"rowid\" field, for the \"docid\" field, or for both.\n  ** Which is a problem, since \"rowid\" and \"docid\" are aliases for the\n  ** same value. For example:\n  **\n  **   INSERT INTO fts3tbl(rowid, docid) VALUES(1, 2);\n  **\n  ** In FTS3, this is an error. It is an error to specify non-NULL values\n  ** for both docid and some other rowid alias.\n  */\n  if( SQLITE_NULL!=sqlite3_value_type(apVal[3+p->nColumn]) ){\n    if( SQLITE_NULL==sqlite3_value_type(apVal[0])\n     && SQLITE_NULL!=sqlite3_value_type(apVal[1])\n    ){\n      /* A rowid/docid conflict. */\n      return SQLITE_ERROR;\n    }\n    rc = sqlite3_bind_value(pContentInsert, 1, apVal[3+p->nColumn]);\n    if( rc!=SQLITE_OK ) return rc;\n  }\n\n  /* Execute the statement to insert the record. Set *piDocid to the \n  ** new docid value. \n  */\n  sqlite3_step(pContentInsert);\n  rc = sqlite3_reset(pContentInsert);\n\n  *piDocid = sqlite3_last_insert_rowid(p->db);\n  return rc;\n}\n\n\n\n/*\n** Remove all data from the FTS3 table. Clear the hash table containing\n** pending terms.\n*/\nstatic int fts3DeleteAll(Fts3Table *p){\n  int rc = SQLITE_OK;             /* Return code */\n\n  /* Discard the contents of the pending-terms hash table. */\n  sqlite3Fts3PendingTermsClear(p);\n\n  /* Delete everything from the %_content, %_segments and %_segdir tables. */\n  fts3SqlExec(&rc, p, SQL_DELETE_ALL_CONTENT, 0);\n  fts3SqlExec(&rc, p, SQL_DELETE_ALL_SEGMENTS, 0);\n  fts3SqlExec(&rc, p, SQL_DELETE_ALL_SEGDIR, 0);\n  if( p->bHasDocsize ){\n    fts3SqlExec(&rc, p, SQL_DELETE_ALL_DOCSIZE, 0);\n  }\n  if( p->bHasStat ){\n    fts3SqlExec(&rc, p, SQL_DELETE_ALL_STAT, 0);\n  }\n  return rc;\n}\n\n/*\n** The first element in the apVal[] array is assumed to contain the docid\n** (an integer) of a row about to be deleted. Remove all terms from the\n** full-text index.\n*/\nstatic void fts3DeleteTerms( \n  int *pRC,               /* Result code */\n  Fts3Table *p,           /* The FTS table to delete from */\n  sqlite3_value **apVal,  /* apVal[] contains the docid to be deleted */\n  u32 *aSz                /* Sizes of deleted document written here */\n){\n  int rc;\n  sqlite3_stmt *pSelect;\n\n  if( *pRC ) return;\n  rc = fts3SqlStmt(p, SQL_SELECT_CONTENT_BY_ROWID, &pSelect, apVal);\n  if( rc==SQLITE_OK ){\n    if( SQLITE_ROW==sqlite3_step(pSelect) ){\n      int i;\n      for(i=1; i<=p->nColumn; i++){\n        const char *zText = (const char *)sqlite3_column_text(pSelect, i);\n        rc = fts3PendingTermsAdd(p, zText, -1, &aSz[i-1]);\n        if( rc!=SQLITE_OK ){\n          sqlite3_reset(pSelect);\n          *pRC = rc;\n          return;\n        }\n        aSz[p->nColumn] += sqlite3_column_bytes(pSelect, i);\n      }\n    }\n    rc = sqlite3_reset(pSelect);\n  }else{\n    sqlite3_reset(pSelect);\n  }\n  *pRC = rc;\n}\n\n/*\n** Forward declaration to account for the circular dependency between\n** functions fts3SegmentMerge() and fts3AllocateSegdirIdx().\n*/\nstatic int fts3SegmentMerge(Fts3Table *, int);\n\n/* \n** This function allocates a new level iLevel index in the segdir table.\n** Usually, indexes are allocated within a level sequentially starting\n** with 0, so the allocated index is one greater than the value returned\n** by:\n**\n**   SELECT max(idx) FROM %_segdir WHERE level = :iLevel\n**\n** However, if there are already FTS3_MERGE_COUNT indexes at the requested\n** level, they are merged into a single level (iLevel+1) segment and the \n** allocated index is 0.\n**\n** If successful, *piIdx is set to the allocated index slot and SQLITE_OK\n** returned. Otherwise, an SQLite error code is returned.\n*/\nstatic int fts3AllocateSegdirIdx(Fts3Table *p, int iLevel, int *piIdx){\n  int rc;                         /* Return Code */\n  sqlite3_stmt *pNextIdx;         /* Query for next idx at level iLevel */\n  int iNext = 0;                  /* Result of query pNextIdx */\n\n  /* Set variable iNext to the next available segdir index at level iLevel. */\n  rc = fts3SqlStmt(p, SQL_NEXT_SEGMENT_INDEX, &pNextIdx, 0);\n  if( rc==SQLITE_OK ){\n    sqlite3_bind_int(pNextIdx, 1, iLevel);\n    if( SQLITE_ROW==sqlite3_step(pNextIdx) ){\n      iNext = sqlite3_column_int(pNextIdx, 0);\n    }\n    rc = sqlite3_reset(pNextIdx);\n  }\n\n  if( rc==SQLITE_OK ){\n    /* If iNext is FTS3_MERGE_COUNT, indicating that level iLevel is already\n    ** full, merge all segments in level iLevel into a single iLevel+1\n    ** segment and allocate (newly freed) index 0 at level iLevel. Otherwise,\n    ** if iNext is less than FTS3_MERGE_COUNT, allocate index iNext.\n    */\n    if( iNext>=FTS3_MERGE_COUNT ){\n      rc = fts3SegmentMerge(p, iLevel);\n      *piIdx = 0;\n    }else{\n      *piIdx = iNext;\n    }\n  }\n\n  return rc;\n}\n\n/*\n** The %_segments table is declared as follows:\n**\n**   CREATE TABLE %_segments(blockid INTEGER PRIMARY KEY, block BLOB)\n**\n** This function reads data from a single row of the %_segments table. The\n** specific row is identified by the iBlockid parameter. If paBlob is not\n** NULL, then a buffer is allocated using sqlite3_malloc() and populated\n** with the contents of the blob stored in the \"block\" column of the \n** identified table row is. Whether or not paBlob is NULL, *pnBlob is set\n** to the size of the blob in bytes before returning.\n**\n** If an error occurs, or the table does not contain the specified row,\n** an SQLite error code is returned. Otherwise, SQLITE_OK is returned. If\n** paBlob is non-NULL, then it is the responsibility of the caller to\n** eventually free the returned buffer.\n**\n** This function may leave an open sqlite3_blob* handle in the\n** Fts3Table.pSegments variable. This handle is reused by subsequent calls\n** to this function. The handle may be closed by calling the\n** sqlite3Fts3SegmentsClose() function. Reusing a blob handle is a handy\n** performance improvement, but the blob handle should always be closed\n** before control is returned to the user (to prevent a lock being held\n** on the database file for longer than necessary). Thus, any virtual table\n** method (xFilter etc.) that may directly or indirectly call this function\n** must call sqlite3Fts3SegmentsClose() before returning.\n*/\nSQLITE_PRIVATE int sqlite3Fts3ReadBlock(\n  Fts3Table *p,                   /* FTS3 table handle */\n  sqlite3_int64 iBlockid,         /* Access the row with blockid=$iBlockid */\n  char **paBlob,                  /* OUT: Blob data in malloc'd buffer */\n  int *pnBlob                     /* OUT: Size of blob data */\n){\n  int rc;                         /* Return code */\n\n  /* pnBlob must be non-NULL. paBlob may be NULL or non-NULL. */\n  assert( pnBlob);\n\n  if( p->pSegments ){\n    rc = sqlite3_blob_reopen(p->pSegments, iBlockid);\n  }else{\n    if( 0==p->zSegmentsTbl ){\n      p->zSegmentsTbl = sqlite3_mprintf(\"%s_segments\", p->zName);\n      if( 0==p->zSegmentsTbl ) return SQLITE_NOMEM;\n    }\n    rc = sqlite3_blob_open(\n       p->db, p->zDb, p->zSegmentsTbl, \"block\", iBlockid, 0, &p->pSegments\n    );\n  }\n\n  if( rc==SQLITE_OK ){\n    int nByte = sqlite3_blob_bytes(p->pSegments);\n    if( paBlob ){\n      char *aByte = sqlite3_malloc(nByte + FTS3_NODE_PADDING);\n      if( !aByte ){\n        rc = SQLITE_NOMEM;\n      }else{\n        rc = sqlite3_blob_read(p->pSegments, aByte, nByte, 0);\n        memset(&aByte[nByte], 0, FTS3_NODE_PADDING);\n        if( rc!=SQLITE_OK ){\n          sqlite3_free(aByte);\n          aByte = 0;\n        }\n      }\n      *paBlob = aByte;\n    }\n    *pnBlob = nByte;\n  }\n\n  return rc;\n}\n\n/*\n** Close the blob handle at p->pSegments, if it is open. See comments above\n** the sqlite3Fts3ReadBlock() function for details.\n*/\nSQLITE_PRIVATE void sqlite3Fts3SegmentsClose(Fts3Table *p){\n  sqlite3_blob_close(p->pSegments);\n  p->pSegments = 0;\n}\n\n/*\n** Move the iterator passed as the first argument to the next term in the\n** segment. If successful, SQLITE_OK is returned. If there is no next term,\n** SQLITE_DONE. Otherwise, an SQLite error code.\n*/\nstatic int fts3SegReaderNext(Fts3Table *p, Fts3SegReader *pReader){\n  char *pNext;                    /* Cursor variable */\n  int nPrefix;                    /* Number of bytes in term prefix */\n  int nSuffix;                    /* Number of bytes in term suffix */\n\n  if( !pReader->aDoclist ){\n    pNext = pReader->aNode;\n  }else{\n    pNext = &pReader->aDoclist[pReader->nDoclist];\n  }\n\n  if( !pNext || pNext>=&pReader->aNode[pReader->nNode] ){\n    int rc;                       /* Return code from Fts3ReadBlock() */\n\n    if( fts3SegReaderIsPending(pReader) ){\n      Fts3HashElem *pElem = *(pReader->ppNextElem);\n      if( pElem==0 ){\n        pReader->aNode = 0;\n      }else{\n        PendingList *pList = (PendingList *)fts3HashData(pElem);\n        pReader->zTerm = (char *)fts3HashKey(pElem);\n        pReader->nTerm = fts3HashKeysize(pElem);\n        pReader->nNode = pReader->nDoclist = pList->nData + 1;\n        pReader->aNode = pReader->aDoclist = pList->aData;\n        pReader->ppNextElem++;\n        assert( pReader->aNode );\n      }\n      return SQLITE_OK;\n    }\n\n    if( !fts3SegReaderIsRootOnly(pReader) ){\n      sqlite3_free(pReader->aNode);\n    }\n    pReader->aNode = 0;\n\n    /* If iCurrentBlock>=iLeafEndBlock, this is an EOF condition. All leaf \n    ** blocks have already been traversed.  */\n    assert( pReader->iCurrentBlock<=pReader->iLeafEndBlock );\n    if( pReader->iCurrentBlock>=pReader->iLeafEndBlock ){\n      return SQLITE_OK;\n    }\n\n    rc = sqlite3Fts3ReadBlock(\n        p, ++pReader->iCurrentBlock, &pReader->aNode, &pReader->nNode\n    );\n    if( rc!=SQLITE_OK ) return rc;\n    pNext = pReader->aNode;\n  }\n  \n  /* Because of the FTS3_NODE_PADDING bytes of padding, the following is \n  ** safe (no risk of overread) even if the node data is corrupted.  \n  */\n  pNext += sqlite3Fts3GetVarint32(pNext, &nPrefix);\n  pNext += sqlite3Fts3GetVarint32(pNext, &nSuffix);\n  if( nPrefix<0 || nSuffix<=0 \n   || &pNext[nSuffix]>&pReader->aNode[pReader->nNode] \n  ){\n    return SQLITE_CORRUPT;\n  }\n\n  if( nPrefix+nSuffix>pReader->nTermAlloc ){\n    int nNew = (nPrefix+nSuffix)*2;\n    char *zNew = sqlite3_realloc(pReader->zTerm, nNew);\n    if( !zNew ){\n      return SQLITE_NOMEM;\n    }\n    pReader->zTerm = zNew;\n    pReader->nTermAlloc = nNew;\n  }\n  memcpy(&pReader->zTerm[nPrefix], pNext, nSuffix);\n  pReader->nTerm = nPrefix+nSuffix;\n  pNext += nSuffix;\n  pNext += sqlite3Fts3GetVarint32(pNext, &pReader->nDoclist);\n  pReader->aDoclist = pNext;\n  pReader->pOffsetList = 0;\n\n  /* Check that the doclist does not appear to extend past the end of the\n  ** b-tree node. And that the final byte of the doclist is 0x00. If either \n  ** of these statements is untrue, then the data structure is corrupt.\n  */\n  if( &pReader->aDoclist[pReader->nDoclist]>&pReader->aNode[pReader->nNode] \n   || pReader->aDoclist[pReader->nDoclist-1]\n  ){\n    return SQLITE_CORRUPT;\n  }\n  return SQLITE_OK;\n}\n\n/*\n** Set the SegReader to point to the first docid in the doclist associated\n** with the current term.\n*/\nstatic void fts3SegReaderFirstDocid(Fts3SegReader *pReader){\n  int n;\n  assert( pReader->aDoclist );\n  assert( !pReader->pOffsetList );\n  n = sqlite3Fts3GetVarint(pReader->aDoclist, &pReader->iDocid);\n  pReader->pOffsetList = &pReader->aDoclist[n];\n}\n\n/*\n** Advance the SegReader to point to the next docid in the doclist\n** associated with the current term.\n** \n** If arguments ppOffsetList and pnOffsetList are not NULL, then \n** *ppOffsetList is set to point to the first column-offset list\n** in the doclist entry (i.e. immediately past the docid varint).\n** *pnOffsetList is set to the length of the set of column-offset\n** lists, not including the nul-terminator byte. For example:\n*/\nstatic void fts3SegReaderNextDocid(\n  Fts3SegReader *pReader,\n  char **ppOffsetList,\n  int *pnOffsetList\n){\n  char *p = pReader->pOffsetList;\n  char c = 0;\n\n  /* Pointer p currently points at the first byte of an offset list. The\n  ** following two lines advance it to point one byte past the end of\n  ** the same offset list.\n  */\n  while( *p | c ) c = *p++ & 0x80;\n  p++;\n\n  /* If required, populate the output variables with a pointer to and the\n  ** size of the previous offset-list.\n  */\n  if( ppOffsetList ){\n    *ppOffsetList = pReader->pOffsetList;\n    *pnOffsetList = (int)(p - pReader->pOffsetList - 1);\n  }\n\n  /* If there are no more entries in the doclist, set pOffsetList to\n  ** NULL. Otherwise, set Fts3SegReader.iDocid to the next docid and\n  ** Fts3SegReader.pOffsetList to point to the next offset list before\n  ** returning.\n  */\n  if( p>=&pReader->aDoclist[pReader->nDoclist] ){\n    pReader->pOffsetList = 0;\n  }else{\n    sqlite3_int64 iDelta;\n    pReader->pOffsetList = p + sqlite3Fts3GetVarint(p, &iDelta);\n    pReader->iDocid += iDelta;\n  }\n}\n\n/*\n** This function is called to estimate the amount of data that will be \n** loaded from the disk If SegReaderIterate() is called on this seg-reader,\n** in units of average document size.\n** \n** This can be used as follows: If the caller has a small doclist that \n** contains references to N documents, and is considering merging it with\n** a large doclist (size X \"average documents\"), it may opt not to load\n** the large doclist if X>N.\n*/\nSQLITE_PRIVATE int sqlite3Fts3SegReaderCost(\n  Fts3Cursor *pCsr,               /* FTS3 cursor handle */\n  Fts3SegReader *pReader,         /* Segment-reader handle */\n  int *pnCost                     /* IN/OUT: Number of bytes read */\n){\n  Fts3Table *p = (Fts3Table*)pCsr->base.pVtab;\n  int rc = SQLITE_OK;             /* Return code */\n  int nCost = 0;                  /* Cost in bytes to return */\n  int pgsz = p->nPgsz;            /* Database page size */\n\n  /* If this seg-reader is reading the pending-terms table, or if all data\n  ** for the segment is stored on the root page of the b-tree, then the cost\n  ** is zero. In this case all required data is already in main memory.\n  */\n  if( p->bHasStat \n   && !fts3SegReaderIsPending(pReader) \n   && !fts3SegReaderIsRootOnly(pReader) \n  ){\n    int nBlob = 0;\n    sqlite3_int64 iBlock;\n\n    if( pCsr->nRowAvg==0 ){\n      /* The average document size, which is required to calculate the cost\n      ** of each doclist, has not yet been determined. Read the required \n      ** data from the %_stat table to calculate it.\n      **\n      ** Entry 0 of the %_stat table is a blob containing (nCol+1) FTS3 \n      ** varints, where nCol is the number of columns in the FTS3 table.\n      ** The first varint is the number of documents currently stored in\n      ** the table. The following nCol varints contain the total amount of\n      ** data stored in all rows of each column of the table, from left\n      ** to right.\n      */\n      sqlite3_stmt *pStmt;\n      sqlite3_int64 nDoc = 0;\n      sqlite3_int64 nByte = 0;\n      const char *pEnd;\n      const char *a;\n\n      rc = sqlite3Fts3SelectDoctotal(p, &pStmt);\n      if( rc!=SQLITE_OK ) return rc;\n      a = sqlite3_column_blob(pStmt, 0);\n      assert( a );\n\n      pEnd = &a[sqlite3_column_bytes(pStmt, 0)];\n      a += sqlite3Fts3GetVarint(a, &nDoc);\n      while( a<pEnd ){\n        a += sqlite3Fts3GetVarint(a, &nByte);\n      }\n      if( nDoc==0 || nByte==0 ){\n        sqlite3_reset(pStmt);\n        return SQLITE_CORRUPT;\n      }\n\n      pCsr->nRowAvg = (int)(((nByte / nDoc) + pgsz) / pgsz);\n      assert( pCsr->nRowAvg>0 ); \n      rc = sqlite3_reset(pStmt);\n      if( rc!=SQLITE_OK ) return rc;\n    }\n\n    /* Assume that a blob flows over onto overflow pages if it is larger\n    ** than (pgsz-35) bytes in size (the file-format documentation\n    ** confirms this).\n    */\n    for(iBlock=pReader->iStartBlock; iBlock<=pReader->iLeafEndBlock; iBlock++){\n      rc = sqlite3Fts3ReadBlock(p, iBlock, 0, &nBlob);\n      if( rc!=SQLITE_OK ) break;\n      if( (nBlob+35)>pgsz ){\n        int nOvfl = (nBlob + 34)/pgsz;\n        nCost += ((nOvfl + pCsr->nRowAvg - 1)/pCsr->nRowAvg);\n      }\n    }\n  }\n\n  *pnCost += nCost;\n  return rc;\n}\n\n/*\n** Free all allocations associated with the iterator passed as the \n** second argument.\n*/\nSQLITE_PRIVATE void sqlite3Fts3SegReaderFree(Fts3SegReader *pReader){\n  if( pReader && !fts3SegReaderIsPending(pReader) ){\n    sqlite3_free(pReader->zTerm);\n    if( !fts3SegReaderIsRootOnly(pReader) ){\n      sqlite3_free(pReader->aNode);\n    }\n  }\n  sqlite3_free(pReader);\n}\n\n/*\n** Allocate a new SegReader object.\n*/\nSQLITE_PRIVATE int sqlite3Fts3SegReaderNew(\n  int iAge,                       /* Segment \"age\". */\n  sqlite3_int64 iStartLeaf,       /* First leaf to traverse */\n  sqlite3_int64 iEndLeaf,         /* Final leaf to traverse */\n  sqlite3_int64 iEndBlock,        /* Final block of segment */\n  const char *zRoot,              /* Buffer containing root node */\n  int nRoot,                      /* Size of buffer containing root node */\n  Fts3SegReader **ppReader        /* OUT: Allocated Fts3SegReader */\n){\n  int rc = SQLITE_OK;             /* Return code */\n  Fts3SegReader *pReader;         /* Newly allocated SegReader object */\n  int nExtra = 0;                 /* Bytes to allocate segment root node */\n\n  assert( iStartLeaf<=iEndLeaf );\n  if( iStartLeaf==0 ){\n    nExtra = nRoot + FTS3_NODE_PADDING;\n  }\n\n  pReader = (Fts3SegReader *)sqlite3_malloc(sizeof(Fts3SegReader) + nExtra);\n  if( !pReader ){\n    return SQLITE_NOMEM;\n  }\n  memset(pReader, 0, sizeof(Fts3SegReader));\n  pReader->iIdx = iAge;\n  pReader->iStartBlock = iStartLeaf;\n  pReader->iLeafEndBlock = iEndLeaf;\n  pReader->iEndBlock = iEndBlock;\n\n  if( nExtra ){\n    /* The entire segment is stored in the root node. */\n    pReader->aNode = (char *)&pReader[1];\n    pReader->nNode = nRoot;\n    memcpy(pReader->aNode, zRoot, nRoot);\n    memset(&pReader->aNode[nRoot], 0, FTS3_NODE_PADDING);\n  }else{\n    pReader->iCurrentBlock = iStartLeaf-1;\n  }\n\n  if( rc==SQLITE_OK ){\n    *ppReader = pReader;\n  }else{\n    sqlite3Fts3SegReaderFree(pReader);\n  }\n  return rc;\n}\n\n/*\n** This is a comparison function used as a qsort() callback when sorting\n** an array of pending terms by term. This occurs as part of flushing\n** the contents of the pending-terms hash table to the database.\n*/\nstatic int fts3CompareElemByTerm(const void *lhs, const void *rhs){\n  char *z1 = fts3HashKey(*(Fts3HashElem **)lhs);\n  char *z2 = fts3HashKey(*(Fts3HashElem **)rhs);\n  int n1 = fts3HashKeysize(*(Fts3HashElem **)lhs);\n  int n2 = fts3HashKeysize(*(Fts3HashElem **)rhs);\n\n  int n = (n1<n2 ? n1 : n2);\n  int c = memcmp(z1, z2, n);\n  if( c==0 ){\n    c = n1 - n2;\n  }\n  return c;\n}\n\n/*\n** This function is used to allocate an Fts3SegReader that iterates through\n** a subset of the terms stored in the Fts3Table.pendingTerms array.\n*/\nSQLITE_PRIVATE int sqlite3Fts3SegReaderPending(\n  Fts3Table *p,                   /* Virtual table handle */\n  const char *zTerm,              /* Term to search for */\n  int nTerm,                      /* Size of buffer zTerm */\n  int isPrefix,                   /* True for a term-prefix query */\n  Fts3SegReader **ppReader        /* OUT: SegReader for pending-terms */\n){\n  Fts3SegReader *pReader = 0;     /* Fts3SegReader object to return */\n  Fts3HashElem **aElem = 0;       /* Array of term hash entries to scan */\n  int nElem = 0;                  /* Size of array at aElem */\n  int rc = SQLITE_OK;             /* Return Code */\n\n  if( isPrefix ){\n    int nAlloc = 0;               /* Size of allocated array at aElem */\n    Fts3HashElem *pE = 0;         /* Iterator variable */\n\n    for(pE=fts3HashFirst(&p->pendingTerms); pE; pE=fts3HashNext(pE)){\n      char *zKey = (char *)fts3HashKey(pE);\n      int nKey = fts3HashKeysize(pE);\n      if( nTerm==0 || (nKey>=nTerm && 0==memcmp(zKey, zTerm, nTerm)) ){\n        if( nElem==nAlloc ){\n          Fts3HashElem **aElem2;\n          nAlloc += 16;\n          aElem2 = (Fts3HashElem **)sqlite3_realloc(\n              aElem, nAlloc*sizeof(Fts3HashElem *)\n          );\n          if( !aElem2 ){\n            rc = SQLITE_NOMEM;\n            nElem = 0;\n            break;\n          }\n          aElem = aElem2;\n        }\n        aElem[nElem++] = pE;\n      }\n    }\n\n    /* If more than one term matches the prefix, sort the Fts3HashElem\n    ** objects in term order using qsort(). This uses the same comparison\n    ** callback as is used when flushing terms to disk.\n    */\n    if( nElem>1 ){\n      qsort(aElem, nElem, sizeof(Fts3HashElem *), fts3CompareElemByTerm);\n    }\n\n  }else{\n    Fts3HashElem *pE = fts3HashFindElem(&p->pendingTerms, zTerm, nTerm);\n    if( pE ){\n      aElem = &pE;\n      nElem = 1;\n    }\n  }\n\n  if( nElem>0 ){\n    int nByte = sizeof(Fts3SegReader) + (nElem+1)*sizeof(Fts3HashElem *);\n    pReader = (Fts3SegReader *)sqlite3_malloc(nByte);\n    if( !pReader ){\n      rc = SQLITE_NOMEM;\n    }else{\n      memset(pReader, 0, nByte);\n      pReader->iIdx = 0x7FFFFFFF;\n      pReader->ppNextElem = (Fts3HashElem **)&pReader[1];\n      memcpy(pReader->ppNextElem, aElem, nElem*sizeof(Fts3HashElem *));\n    }\n  }\n\n  if( isPrefix ){\n    sqlite3_free(aElem);\n  }\n  *ppReader = pReader;\n  return rc;\n}\n\n/*\n** Compare the entries pointed to by two Fts3SegReader structures. \n** Comparison is as follows:\n**\n**   1) EOF is greater than not EOF.\n**\n**   2) The current terms (if any) are compared using memcmp(). If one\n**      term is a prefix of another, the longer term is considered the\n**      larger.\n**\n**   3) By segment age. An older segment is considered larger.\n*/\nstatic int fts3SegReaderCmp(Fts3SegReader *pLhs, Fts3SegReader *pRhs){\n  int rc;\n  if( pLhs->aNode && pRhs->aNode ){\n    int rc2 = pLhs->nTerm - pRhs->nTerm;\n    if( rc2<0 ){\n      rc = memcmp(pLhs->zTerm, pRhs->zTerm, pLhs->nTerm);\n    }else{\n      rc = memcmp(pLhs->zTerm, pRhs->zTerm, pRhs->nTerm);\n    }\n    if( rc==0 ){\n      rc = rc2;\n    }\n  }else{\n    rc = (pLhs->aNode==0) - (pRhs->aNode==0);\n  }\n  if( rc==0 ){\n    rc = pRhs->iIdx - pLhs->iIdx;\n  }\n  assert( rc!=0 );\n  return rc;\n}\n\n/*\n** A different comparison function for SegReader structures. In this\n** version, it is assumed that each SegReader points to an entry in\n** a doclist for identical terms. Comparison is made as follows:\n**\n**   1) EOF (end of doclist in this case) is greater than not EOF.\n**\n**   2) By current docid.\n**\n**   3) By segment age. An older segment is considered larger.\n*/\nstatic int fts3SegReaderDoclistCmp(Fts3SegReader *pLhs, Fts3SegReader *pRhs){\n  int rc = (pLhs->pOffsetList==0)-(pRhs->pOffsetList==0);\n  if( rc==0 ){\n    if( pLhs->iDocid==pRhs->iDocid ){\n      rc = pRhs->iIdx - pLhs->iIdx;\n    }else{\n      rc = (pLhs->iDocid > pRhs->iDocid) ? 1 : -1;\n    }\n  }\n  assert( pLhs->aNode && pRhs->aNode );\n  return rc;\n}\n\n/*\n** Compare the term that the Fts3SegReader object passed as the first argument\n** points to with the term specified by arguments zTerm and nTerm. \n**\n** If the pSeg iterator is already at EOF, return 0. Otherwise, return\n** -ve if the pSeg term is less than zTerm/nTerm, 0 if the two terms are\n** equal, or +ve if the pSeg term is greater than zTerm/nTerm.\n*/\nstatic int fts3SegReaderTermCmp(\n  Fts3SegReader *pSeg,            /* Segment reader object */\n  const char *zTerm,              /* Term to compare to */\n  int nTerm                       /* Size of term zTerm in bytes */\n){\n  int res = 0;\n  if( pSeg->aNode ){\n    if( pSeg->nTerm>nTerm ){\n      res = memcmp(pSeg->zTerm, zTerm, nTerm);\n    }else{\n      res = memcmp(pSeg->zTerm, zTerm, pSeg->nTerm);\n    }\n    if( res==0 ){\n      res = pSeg->nTerm-nTerm;\n    }\n  }\n  return res;\n}\n\n/*\n** Argument apSegment is an array of nSegment elements. It is known that\n** the final (nSegment-nSuspect) members are already in sorted order\n** (according to the comparison function provided). This function shuffles\n** the array around until all entries are in sorted order.\n*/\nstatic void fts3SegReaderSort(\n  Fts3SegReader **apSegment,                     /* Array to sort entries of */\n  int nSegment,                                  /* Size of apSegment array */\n  int nSuspect,                                  /* Unsorted entry count */\n  int (*xCmp)(Fts3SegReader *, Fts3SegReader *)  /* Comparison function */\n){\n  int i;                          /* Iterator variable */\n\n  assert( nSuspect<=nSegment );\n\n  if( nSuspect==nSegment ) nSuspect--;\n  for(i=nSuspect-1; i>=0; i--){\n    int j;\n    for(j=i; j<(nSegment-1); j++){\n      Fts3SegReader *pTmp;\n      if( xCmp(apSegment[j], apSegment[j+1])<0 ) break;\n      pTmp = apSegment[j+1];\n      apSegment[j+1] = apSegment[j];\n      apSegment[j] = pTmp;\n    }\n  }\n\n#ifndef NDEBUG\n  /* Check that the list really is sorted now. */\n  for(i=0; i<(nSuspect-1); i++){\n    assert( xCmp(apSegment[i], apSegment[i+1])<0 );\n  }\n#endif\n}\n\n/* \n** Insert a record into the %_segments table.\n*/\nstatic int fts3WriteSegment(\n  Fts3Table *p,                   /* Virtual table handle */\n  sqlite3_int64 iBlock,           /* Block id for new block */\n  char *z,                        /* Pointer to buffer containing block data */\n  int n                           /* Size of buffer z in bytes */\n){\n  sqlite3_stmt *pStmt;\n  int rc = fts3SqlStmt(p, SQL_INSERT_SEGMENTS, &pStmt, 0);\n  if( rc==SQLITE_OK ){\n    sqlite3_bind_int64(pStmt, 1, iBlock);\n    sqlite3_bind_blob(pStmt, 2, z, n, SQLITE_STATIC);\n    sqlite3_step(pStmt);\n    rc = sqlite3_reset(pStmt);\n  }\n  return rc;\n}\n\n/* \n** Insert a record into the %_segdir table.\n*/\nstatic int fts3WriteSegdir(\n  Fts3Table *p,                   /* Virtual table handle */\n  int iLevel,                     /* Value for \"level\" field */\n  int iIdx,                       /* Value for \"idx\" field */\n  sqlite3_int64 iStartBlock,      /* Value for \"start_block\" field */\n  sqlite3_int64 iLeafEndBlock,    /* Value for \"leaves_end_block\" field */\n  sqlite3_int64 iEndBlock,        /* Value for \"end_block\" field */\n  char *zRoot,                    /* Blob value for \"root\" field */\n  int nRoot                       /* Number of bytes in buffer zRoot */\n){\n  sqlite3_stmt *pStmt;\n  int rc = fts3SqlStmt(p, SQL_INSERT_SEGDIR, &pStmt, 0);\n  if( rc==SQLITE_OK ){\n    sqlite3_bind_int(pStmt, 1, iLevel);\n    sqlite3_bind_int(pStmt, 2, iIdx);\n    sqlite3_bind_int64(pStmt, 3, iStartBlock);\n    sqlite3_bind_int64(pStmt, 4, iLeafEndBlock);\n    sqlite3_bind_int64(pStmt, 5, iEndBlock);\n    sqlite3_bind_blob(pStmt, 6, zRoot, nRoot, SQLITE_STATIC);\n    sqlite3_step(pStmt);\n    rc = sqlite3_reset(pStmt);\n  }\n  return rc;\n}\n\n/*\n** Return the size of the common prefix (if any) shared by zPrev and\n** zNext, in bytes. For example, \n**\n**   fts3PrefixCompress(\"abc\", 3, \"abcdef\", 6)   // returns 3\n**   fts3PrefixCompress(\"abX\", 3, \"abcdef\", 6)   // returns 2\n**   fts3PrefixCompress(\"abX\", 3, \"Xbcdef\", 6)   // returns 0\n*/\nstatic int fts3PrefixCompress(\n  const char *zPrev,              /* Buffer containing previous term */\n  int nPrev,                      /* Size of buffer zPrev in bytes */\n  const char *zNext,              /* Buffer containing next term */\n  int nNext                       /* Size of buffer zNext in bytes */\n){\n  int n;\n  UNUSED_PARAMETER(nNext);\n  for(n=0; n<nPrev && zPrev[n]==zNext[n]; n++);\n  return n;\n}\n\n/*\n** Add term zTerm to the SegmentNode. It is guaranteed that zTerm is larger\n** (according to memcmp) than the previous term.\n*/\nstatic int fts3NodeAddTerm(\n  Fts3Table *p,                   /* Virtual table handle */\n  SegmentNode **ppTree,           /* IN/OUT: SegmentNode handle */ \n  int isCopyTerm,                 /* True if zTerm/nTerm is transient */\n  const char *zTerm,              /* Pointer to buffer containing term */\n  int nTerm                       /* Size of term in bytes */\n){\n  SegmentNode *pTree = *ppTree;\n  int rc;\n  SegmentNode *pNew;\n\n  /* First try to append the term to the current node. Return early if \n  ** this is possible.\n  */\n  if( pTree ){\n    int nData = pTree->nData;     /* Current size of node in bytes */\n    int nReq = nData;             /* Required space after adding zTerm */\n    int nPrefix;                  /* Number of bytes of prefix compression */\n    int nSuffix;                  /* Suffix length */\n\n    nPrefix = fts3PrefixCompress(pTree->zTerm, pTree->nTerm, zTerm, nTerm);\n    nSuffix = nTerm-nPrefix;\n\n    nReq += sqlite3Fts3VarintLen(nPrefix)+sqlite3Fts3VarintLen(nSuffix)+nSuffix;\n    if( nReq<=p->nNodeSize || !pTree->zTerm ){\n\n      if( nReq>p->nNodeSize ){\n        /* An unusual case: this is the first term to be added to the node\n        ** and the static node buffer (p->nNodeSize bytes) is not large\n        ** enough. Use a separately malloced buffer instead This wastes\n        ** p->nNodeSize bytes, but since this scenario only comes about when\n        ** the database contain two terms that share a prefix of almost 2KB, \n        ** this is not expected to be a serious problem. \n        */\n        assert( pTree->aData==(char *)&pTree[1] );\n        pTree->aData = (char *)sqlite3_malloc(nReq);\n        if( !pTree->aData ){\n          return SQLITE_NOMEM;\n        }\n      }\n\n      if( pTree->zTerm ){\n        /* There is no prefix-length field for first term in a node */\n        nData += sqlite3Fts3PutVarint(&pTree->aData[nData], nPrefix);\n      }\n\n      nData += sqlite3Fts3PutVarint(&pTree->aData[nData], nSuffix);\n      memcpy(&pTree->aData[nData], &zTerm[nPrefix], nSuffix);\n      pTree->nData = nData + nSuffix;\n      pTree->nEntry++;\n\n      if( isCopyTerm ){\n        if( pTree->nMalloc<nTerm ){\n          char *zNew = sqlite3_realloc(pTree->zMalloc, nTerm*2);\n          if( !zNew ){\n            return SQLITE_NOMEM;\n          }\n          pTree->nMalloc = nTerm*2;\n          pTree->zMalloc = zNew;\n        }\n        pTree->zTerm = pTree->zMalloc;\n        memcpy(pTree->zTerm, zTerm, nTerm);\n        pTree->nTerm = nTerm;\n      }else{\n        pTree->zTerm = (char *)zTerm;\n        pTree->nTerm = nTerm;\n      }\n      return SQLITE_OK;\n    }\n  }\n\n  /* If control flows to here, it was not possible to append zTerm to the\n  ** current node. Create a new node (a right-sibling of the current node).\n  ** If this is the first node in the tree, the term is added to it.\n  **\n  ** Otherwise, the term is not added to the new node, it is left empty for\n  ** now. Instead, the term is inserted into the parent of pTree. If pTree \n  ** has no parent, one is created here.\n  */\n  pNew = (SegmentNode *)sqlite3_malloc(sizeof(SegmentNode) + p->nNodeSize);\n  if( !pNew ){\n    return SQLITE_NOMEM;\n  }\n  memset(pNew, 0, sizeof(SegmentNode));\n  pNew->nData = 1 + FTS3_VARINT_MAX;\n  pNew->aData = (char *)&pNew[1];\n\n  if( pTree ){\n    SegmentNode *pParent = pTree->pParent;\n    rc = fts3NodeAddTerm(p, &pParent, isCopyTerm, zTerm, nTerm);\n    if( pTree->pParent==0 ){\n      pTree->pParent = pParent;\n    }\n    pTree->pRight = pNew;\n    pNew->pLeftmost = pTree->pLeftmost;\n    pNew->pParent = pParent;\n    pNew->zMalloc = pTree->zMalloc;\n    pNew->nMalloc = pTree->nMalloc;\n    pTree->zMalloc = 0;\n  }else{\n    pNew->pLeftmost = pNew;\n    rc = fts3NodeAddTerm(p, &pNew, isCopyTerm, zTerm, nTerm); \n  }\n\n  *ppTree = pNew;\n  return rc;\n}\n\n/*\n** Helper function for fts3NodeWrite().\n*/\nstatic int fts3TreeFinishNode(\n  SegmentNode *pTree, \n  int iHeight, \n  sqlite3_int64 iLeftChild\n){\n  int nStart;\n  assert( iHeight>=1 && iHeight<128 );\n  nStart = FTS3_VARINT_MAX - sqlite3Fts3VarintLen(iLeftChild);\n  pTree->aData[nStart] = (char)iHeight;\n  sqlite3Fts3PutVarint(&pTree->aData[nStart+1], iLeftChild);\n  return nStart;\n}\n\n/*\n** Write the buffer for the segment node pTree and all of its peers to the\n** database. Then call this function recursively to write the parent of \n** pTree and its peers to the database. \n**\n** Except, if pTree is a root node, do not write it to the database. Instead,\n** set output variables *paRoot and *pnRoot to contain the root node.\n**\n** If successful, SQLITE_OK is returned and output variable *piLast is\n** set to the largest blockid written to the database (or zero if no\n** blocks were written to the db). Otherwise, an SQLite error code is \n** returned.\n*/\nstatic int fts3NodeWrite(\n  Fts3Table *p,                   /* Virtual table handle */\n  SegmentNode *pTree,             /* SegmentNode handle */\n  int iHeight,                    /* Height of this node in tree */\n  sqlite3_int64 iLeaf,            /* Block id of first leaf node */\n  sqlite3_int64 iFree,            /* Block id of next free slot in %_segments */\n  sqlite3_int64 *piLast,          /* OUT: Block id of last entry written */\n  char **paRoot,                  /* OUT: Data for root node */\n  int *pnRoot                     /* OUT: Size of root node in bytes */\n){\n  int rc = SQLITE_OK;\n\n  if( !pTree->pParent ){\n    /* Root node of the tree. */\n    int nStart = fts3TreeFinishNode(pTree, iHeight, iLeaf);\n    *piLast = iFree-1;\n    *pnRoot = pTree->nData - nStart;\n    *paRoot = &pTree->aData[nStart];\n  }else{\n    SegmentNode *pIter;\n    sqlite3_int64 iNextFree = iFree;\n    sqlite3_int64 iNextLeaf = iLeaf;\n    for(pIter=pTree->pLeftmost; pIter && rc==SQLITE_OK; pIter=pIter->pRight){\n      int nStart = fts3TreeFinishNode(pIter, iHeight, iNextLeaf);\n      int nWrite = pIter->nData - nStart;\n  \n      rc = fts3WriteSegment(p, iNextFree, &pIter->aData[nStart], nWrite);\n      iNextFree++;\n      iNextLeaf += (pIter->nEntry+1);\n    }\n    if( rc==SQLITE_OK ){\n      assert( iNextLeaf==iFree );\n      rc = fts3NodeWrite(\n          p, pTree->pParent, iHeight+1, iFree, iNextFree, piLast, paRoot, pnRoot\n      );\n    }\n  }\n\n  return rc;\n}\n\n/*\n** Free all memory allocations associated with the tree pTree.\n*/\nstatic void fts3NodeFree(SegmentNode *pTree){\n  if( pTree ){\n    SegmentNode *p = pTree->pLeftmost;\n    fts3NodeFree(p->pParent);\n    while( p ){\n      SegmentNode *pRight = p->pRight;\n      if( p->aData!=(char *)&p[1] ){\n        sqlite3_free(p->aData);\n      }\n      assert( pRight==0 || p->zMalloc==0 );\n      sqlite3_free(p->zMalloc);\n      sqlite3_free(p);\n      p = pRight;\n    }\n  }\n}\n\n/*\n** Add a term to the segment being constructed by the SegmentWriter object\n** *ppWriter. When adding the first term to a segment, *ppWriter should\n** be passed NULL. This function will allocate a new SegmentWriter object\n** and return it via the input/output variable *ppWriter in this case.\n**\n** If successful, SQLITE_OK is returned. Otherwise, an SQLite error code.\n*/\nstatic int fts3SegWriterAdd(\n  Fts3Table *p,                   /* Virtual table handle */\n  SegmentWriter **ppWriter,       /* IN/OUT: SegmentWriter handle */ \n  int isCopyTerm,                 /* True if buffer zTerm must be copied */\n  const char *zTerm,              /* Pointer to buffer containing term */\n  int nTerm,                      /* Size of term in bytes */\n  const char *aDoclist,           /* Pointer to buffer containing doclist */\n  int nDoclist                    /* Size of doclist in bytes */\n){\n  int nPrefix;                    /* Size of term prefix in bytes */\n  int nSuffix;                    /* Size of term suffix in bytes */\n  int nReq;                       /* Number of bytes required on leaf page */\n  int nData;\n  SegmentWriter *pWriter = *ppWriter;\n\n  if( !pWriter ){\n    int rc;\n    sqlite3_stmt *pStmt;\n\n    /* Allocate the SegmentWriter structure */\n    pWriter = (SegmentWriter *)sqlite3_malloc(sizeof(SegmentWriter));\n    if( !pWriter ) return SQLITE_NOMEM;\n    memset(pWriter, 0, sizeof(SegmentWriter));\n    *ppWriter = pWriter;\n\n    /* Allocate a buffer in which to accumulate data */\n    pWriter->aData = (char *)sqlite3_malloc(p->nNodeSize);\n    if( !pWriter->aData ) return SQLITE_NOMEM;\n    pWriter->nSize = p->nNodeSize;\n\n    /* Find the next free blockid in the %_segments table */\n    rc = fts3SqlStmt(p, SQL_NEXT_SEGMENTS_ID, &pStmt, 0);\n    if( rc!=SQLITE_OK ) return rc;\n    if( SQLITE_ROW==sqlite3_step(pStmt) ){\n      pWriter->iFree = sqlite3_column_int64(pStmt, 0);\n      pWriter->iFirst = pWriter->iFree;\n    }\n    rc = sqlite3_reset(pStmt);\n    if( rc!=SQLITE_OK ) return rc;\n  }\n  nData = pWriter->nData;\n\n  nPrefix = fts3PrefixCompress(pWriter->zTerm, pWriter->nTerm, zTerm, nTerm);\n  nSuffix = nTerm-nPrefix;\n\n  /* Figure out how many bytes are required by this new entry */\n  nReq = sqlite3Fts3VarintLen(nPrefix) +    /* varint containing prefix size */\n    sqlite3Fts3VarintLen(nSuffix) +         /* varint containing suffix size */\n    nSuffix +                               /* Term suffix */\n    sqlite3Fts3VarintLen(nDoclist) +        /* Size of doclist */\n    nDoclist;                               /* Doclist data */\n\n  if( nData>0 && nData+nReq>p->nNodeSize ){\n    int rc;\n\n    /* The current leaf node is full. Write it out to the database. */\n    rc = fts3WriteSegment(p, pWriter->iFree++, pWriter->aData, nData);\n    if( rc!=SQLITE_OK ) return rc;\n\n    /* Add the current term to the interior node tree. The term added to\n    ** the interior tree must:\n    **\n    **   a) be greater than the largest term on the leaf node just written\n    **      to the database (still available in pWriter->zTerm), and\n    **\n    **   b) be less than or equal to the term about to be added to the new\n    **      leaf node (zTerm/nTerm).\n    **\n    ** In other words, it must be the prefix of zTerm 1 byte longer than\n    ** the common prefix (if any) of zTerm and pWriter->zTerm.\n    */\n    assert( nPrefix<nTerm );\n    rc = fts3NodeAddTerm(p, &pWriter->pTree, isCopyTerm, zTerm, nPrefix+1);\n    if( rc!=SQLITE_OK ) return rc;\n\n    nData = 0;\n    pWriter->nTerm = 0;\n\n    nPrefix = 0;\n    nSuffix = nTerm;\n    nReq = 1 +                              /* varint containing prefix size */\n      sqlite3Fts3VarintLen(nTerm) +         /* varint containing suffix size */\n      nTerm +                               /* Term suffix */\n      sqlite3Fts3VarintLen(nDoclist) +      /* Size of doclist */\n      nDoclist;                             /* Doclist data */\n  }\n\n  /* If the buffer currently allocated is too small for this entry, realloc\n  ** the buffer to make it large enough.\n  */\n  if( nReq>pWriter->nSize ){\n    char *aNew = sqlite3_realloc(pWriter->aData, nReq);\n    if( !aNew ) return SQLITE_NOMEM;\n    pWriter->aData = aNew;\n    pWriter->nSize = nReq;\n  }\n  assert( nData+nReq<=pWriter->nSize );\n\n  /* Append the prefix-compressed term and doclist to the buffer. */\n  nData += sqlite3Fts3PutVarint(&pWriter->aData[nData], nPrefix);\n  nData += sqlite3Fts3PutVarint(&pWriter->aData[nData], nSuffix);\n  memcpy(&pWriter->aData[nData], &zTerm[nPrefix], nSuffix);\n  nData += nSuffix;\n  nData += sqlite3Fts3PutVarint(&pWriter->aData[nData], nDoclist);\n  memcpy(&pWriter->aData[nData], aDoclist, nDoclist);\n  pWriter->nData = nData + nDoclist;\n\n  /* Save the current term so that it can be used to prefix-compress the next.\n  ** If the isCopyTerm parameter is true, then the buffer pointed to by\n  ** zTerm is transient, so take a copy of the term data. Otherwise, just\n  ** store a copy of the pointer.\n  */\n  if( isCopyTerm ){\n    if( nTerm>pWriter->nMalloc ){\n      char *zNew = sqlite3_realloc(pWriter->zMalloc, nTerm*2);\n      if( !zNew ){\n        return SQLITE_NOMEM;\n      }\n      pWriter->nMalloc = nTerm*2;\n      pWriter->zMalloc = zNew;\n      pWriter->zTerm = zNew;\n    }\n    assert( pWriter->zTerm==pWriter->zMalloc );\n    memcpy(pWriter->zTerm, zTerm, nTerm);\n  }else{\n    pWriter->zTerm = (char *)zTerm;\n  }\n  pWriter->nTerm = nTerm;\n\n  return SQLITE_OK;\n}\n\n/*\n** Flush all data associated with the SegmentWriter object pWriter to the\n** database. This function must be called after all terms have been added\n** to the segment using fts3SegWriterAdd(). If successful, SQLITE_OK is\n** returned. Otherwise, an SQLite error code.\n*/\nstatic int fts3SegWriterFlush(\n  Fts3Table *p,                   /* Virtual table handle */\n  SegmentWriter *pWriter,         /* SegmentWriter to flush to the db */\n  int iLevel,                     /* Value for 'level' column of %_segdir */\n  int iIdx                        /* Value for 'idx' column of %_segdir */\n){\n  int rc;                         /* Return code */\n  if( pWriter->pTree ){\n    sqlite3_int64 iLast = 0;      /* Largest block id written to database */\n    sqlite3_int64 iLastLeaf;      /* Largest leaf block id written to db */\n    char *zRoot = NULL;           /* Pointer to buffer containing root node */\n    int nRoot = 0;                /* Size of buffer zRoot */\n\n    iLastLeaf = pWriter->iFree;\n    rc = fts3WriteSegment(p, pWriter->iFree++, pWriter->aData, pWriter->nData);\n    if( rc==SQLITE_OK ){\n      rc = fts3NodeWrite(p, pWriter->pTree, 1,\n          pWriter->iFirst, pWriter->iFree, &iLast, &zRoot, &nRoot);\n    }\n    if( rc==SQLITE_OK ){\n      rc = fts3WriteSegdir(\n          p, iLevel, iIdx, pWriter->iFirst, iLastLeaf, iLast, zRoot, nRoot);\n    }\n  }else{\n    /* The entire tree fits on the root node. Write it to the segdir table. */\n    rc = fts3WriteSegdir(\n        p, iLevel, iIdx, 0, 0, 0, pWriter->aData, pWriter->nData);\n  }\n  return rc;\n}\n\n/*\n** Release all memory held by the SegmentWriter object passed as the \n** first argument.\n*/\nstatic void fts3SegWriterFree(SegmentWriter *pWriter){\n  if( pWriter ){\n    sqlite3_free(pWriter->aData);\n    sqlite3_free(pWriter->zMalloc);\n    fts3NodeFree(pWriter->pTree);\n    sqlite3_free(pWriter);\n  }\n}\n\n/*\n** The first value in the apVal[] array is assumed to contain an integer.\n** This function tests if there exist any documents with docid values that\n** are different from that integer. i.e. if deleting the document with docid\n** apVal[0] would mean the FTS3 table were empty.\n**\n** If successful, *pisEmpty is set to true if the table is empty except for\n** document apVal[0], or false otherwise, and SQLITE_OK is returned. If an\n** error occurs, an SQLite error code is returned.\n*/\nstatic int fts3IsEmpty(Fts3Table *p, sqlite3_value **apVal, int *pisEmpty){\n  sqlite3_stmt *pStmt;\n  int rc;\n  rc = fts3SqlStmt(p, SQL_IS_EMPTY, &pStmt, apVal);\n  if( rc==SQLITE_OK ){\n    if( SQLITE_ROW==sqlite3_step(pStmt) ){\n      *pisEmpty = sqlite3_column_int(pStmt, 0);\n    }\n    rc = sqlite3_reset(pStmt);\n  }\n  return rc;\n}\n\n/*\n** Set *pnSegment to the total number of segments in the database. Set\n** *pnMax to the largest segment level in the database (segment levels\n** are stored in the 'level' column of the %_segdir table).\n**\n** Return SQLITE_OK if successful, or an SQLite error code if not.\n*/\nstatic int fts3SegmentCountMax(Fts3Table *p, int *pnSegment, int *pnMax){\n  sqlite3_stmt *pStmt;\n  int rc;\n\n  rc = fts3SqlStmt(p, SQL_SELECT_SEGDIR_COUNT_MAX, &pStmt, 0);\n  if( rc!=SQLITE_OK ) return rc;\n  if( SQLITE_ROW==sqlite3_step(pStmt) ){\n    *pnSegment = sqlite3_column_int(pStmt, 0);\n    *pnMax = sqlite3_column_int(pStmt, 1);\n  }\n  return sqlite3_reset(pStmt);\n}\n\n/*\n** This function is used after merging multiple segments into a single large\n** segment to delete the old, now redundant, segment b-trees. Specifically,\n** it:\n** \n**   1) Deletes all %_segments entries for the segments associated with \n**      each of the SegReader objects in the array passed as the third \n**      argument, and\n**\n**   2) deletes all %_segdir entries with level iLevel, or all %_segdir\n**      entries regardless of level if (iLevel<0).\n**\n** SQLITE_OK is returned if successful, otherwise an SQLite error code.\n*/\nstatic int fts3DeleteSegdir(\n  Fts3Table *p,                   /* Virtual table handle */\n  int iLevel,                     /* Level of %_segdir entries to delete */\n  Fts3SegReader **apSegment,      /* Array of SegReader objects */\n  int nReader                     /* Size of array apSegment */\n){\n  int rc;                         /* Return Code */\n  int i;                          /* Iterator variable */\n  sqlite3_stmt *pDelete;          /* SQL statement to delete rows */\n\n  rc = fts3SqlStmt(p, SQL_DELETE_SEGMENTS_RANGE, &pDelete, 0);\n  for(i=0; rc==SQLITE_OK && i<nReader; i++){\n    Fts3SegReader *pSegment = apSegment[i];\n    if( pSegment->iStartBlock ){\n      sqlite3_bind_int64(pDelete, 1, pSegment->iStartBlock);\n      sqlite3_bind_int64(pDelete, 2, pSegment->iEndBlock);\n      sqlite3_step(pDelete);\n      rc = sqlite3_reset(pDelete);\n    }\n  }\n  if( rc!=SQLITE_OK ){\n    return rc;\n  }\n\n  if( iLevel==FTS3_SEGCURSOR_ALL ){\n    fts3SqlExec(&rc, p, SQL_DELETE_ALL_SEGDIR, 0);\n  }else if( iLevel==FTS3_SEGCURSOR_PENDING ){\n    sqlite3Fts3PendingTermsClear(p);\n  }else{\n    assert( iLevel>=0 );\n    rc = fts3SqlStmt(p, SQL_DELETE_SEGDIR_BY_LEVEL, &pDelete, 0);\n    if( rc==SQLITE_OK ){\n      sqlite3_bind_int(pDelete, 1, iLevel);\n      sqlite3_step(pDelete);\n      rc = sqlite3_reset(pDelete);\n    }\n  }\n\n  return rc;\n}\n\n/*\n** When this function is called, buffer *ppList (size *pnList bytes) contains \n** a position list that may (or may not) feature multiple columns. This\n** function adjusts the pointer *ppList and the length *pnList so that they\n** identify the subset of the position list that corresponds to column iCol.\n**\n** If there are no entries in the input position list for column iCol, then\n** *pnList is set to zero before returning.\n*/\nstatic void fts3ColumnFilter(\n  int iCol,                       /* Column to filter on */\n  char **ppList,                  /* IN/OUT: Pointer to position list */\n  int *pnList                     /* IN/OUT: Size of buffer *ppList in bytes */\n){\n  char *pList = *ppList;\n  int nList = *pnList;\n  char *pEnd = &pList[nList];\n  int iCurrent = 0;\n  char *p = pList;\n\n  assert( iCol>=0 );\n  while( 1 ){\n    char c = 0;\n    while( p<pEnd && (c | *p)&0xFE ) c = *p++ & 0x80;\n  \n    if( iCol==iCurrent ){\n      nList = (int)(p - pList);\n      break;\n    }\n\n    nList -= (int)(p - pList);\n    pList = p;\n    if( nList==0 ){\n      break;\n    }\n    p = &pList[1];\n    p += sqlite3Fts3GetVarint32(p, &iCurrent);\n  }\n\n  *ppList = pList;\n  *pnList = nList;\n}\n\nSQLITE_PRIVATE int sqlite3Fts3SegReaderStart(\n  Fts3Table *p,                   /* Virtual table handle */\n  Fts3SegReaderCursor *pCsr,      /* Cursor object */\n  Fts3SegFilter *pFilter          /* Restrictions on range of iteration */\n){\n  int i;\n\n  /* Initialize the cursor object */\n  pCsr->pFilter = pFilter;\n\n  /* If the Fts3SegFilter defines a specific term (or term prefix) to search \n  ** for, then advance each segment iterator until it points to a term of\n  ** equal or greater value than the specified term. This prevents many\n  ** unnecessary merge/sort operations for the case where single segment\n  ** b-tree leaf nodes contain more than one term.\n  */\n  for(i=0; i<pCsr->nSegment; i++){\n    int nTerm = pFilter->nTerm;\n    const char *zTerm = pFilter->zTerm;\n    Fts3SegReader *pSeg = pCsr->apSegment[i];\n    do {\n      int rc = fts3SegReaderNext(p, pSeg);\n      if( rc!=SQLITE_OK ) return rc;\n    }while( zTerm && fts3SegReaderTermCmp(pSeg, zTerm, nTerm)<0 );\n  }\n  fts3SegReaderSort(\n      pCsr->apSegment, pCsr->nSegment, pCsr->nSegment, fts3SegReaderCmp);\n\n  return SQLITE_OK;\n}\n\nSQLITE_PRIVATE int sqlite3Fts3SegReaderStep(\n  Fts3Table *p,                   /* Virtual table handle */\n  Fts3SegReaderCursor *pCsr       /* Cursor object */\n){\n  int rc = SQLITE_OK;\n\n  int isIgnoreEmpty =  (pCsr->pFilter->flags & FTS3_SEGMENT_IGNORE_EMPTY);\n  int isRequirePos =   (pCsr->pFilter->flags & FTS3_SEGMENT_REQUIRE_POS);\n  int isColFilter =    (pCsr->pFilter->flags & FTS3_SEGMENT_COLUMN_FILTER);\n  int isPrefix =       (pCsr->pFilter->flags & FTS3_SEGMENT_PREFIX);\n  int isScan =         (pCsr->pFilter->flags & FTS3_SEGMENT_SCAN);\n\n  Fts3SegReader **apSegment = pCsr->apSegment;\n  int nSegment = pCsr->nSegment;\n  Fts3SegFilter *pFilter = pCsr->pFilter;\n\n  if( pCsr->nSegment==0 ) return SQLITE_OK;\n\n  do {\n    int nMerge;\n    int i;\n  \n    /* Advance the first pCsr->nAdvance entries in the apSegment[] array\n    ** forward. Then sort the list in order of current term again.  \n    */\n    for(i=0; i<pCsr->nAdvance; i++){\n      rc = fts3SegReaderNext(p, apSegment[i]);\n      if( rc!=SQLITE_OK ) return rc;\n    }\n    fts3SegReaderSort(apSegment, nSegment, pCsr->nAdvance, fts3SegReaderCmp);\n    pCsr->nAdvance = 0;\n\n    /* If all the seg-readers are at EOF, we're finished. return SQLITE_OK. */\n    assert( rc==SQLITE_OK );\n    if( apSegment[0]->aNode==0 ) break;\n\n    pCsr->nTerm = apSegment[0]->nTerm;\n    pCsr->zTerm = apSegment[0]->zTerm;\n\n    /* If this is a prefix-search, and if the term that apSegment[0] points\n    ** to does not share a suffix with pFilter->zTerm/nTerm, then all \n    ** required callbacks have been made. In this case exit early.\n    **\n    ** Similarly, if this is a search for an exact match, and the first term\n    ** of segment apSegment[0] is not a match, exit early.\n    */\n    if( pFilter->zTerm && !isScan ){\n      if( pCsr->nTerm<pFilter->nTerm \n       || (!isPrefix && pCsr->nTerm>pFilter->nTerm)\n       || memcmp(pCsr->zTerm, pFilter->zTerm, pFilter->nTerm) \n      ){\n        break;\n      }\n    }\n\n    nMerge = 1;\n    while( nMerge<nSegment \n        && apSegment[nMerge]->aNode\n        && apSegment[nMerge]->nTerm==pCsr->nTerm \n        && 0==memcmp(pCsr->zTerm, apSegment[nMerge]->zTerm, pCsr->nTerm)\n    ){\n      nMerge++;\n    }\n\n    assert( isIgnoreEmpty || (isRequirePos && !isColFilter) );\n    if( nMerge==1 && !isIgnoreEmpty ){\n      pCsr->aDoclist = apSegment[0]->aDoclist;\n      pCsr->nDoclist = apSegment[0]->nDoclist;\n      rc = SQLITE_ROW;\n    }else{\n      int nDoclist = 0;           /* Size of doclist */\n      sqlite3_int64 iPrev = 0;    /* Previous docid stored in doclist */\n\n      /* The current term of the first nMerge entries in the array\n      ** of Fts3SegReader objects is the same. The doclists must be merged\n      ** and a single term returned with the merged doclist.\n      */\n      for(i=0; i<nMerge; i++){\n        fts3SegReaderFirstDocid(apSegment[i]);\n      }\n      fts3SegReaderSort(apSegment, nMerge, nMerge, fts3SegReaderDoclistCmp);\n      while( apSegment[0]->pOffsetList ){\n        int j;                    /* Number of segments that share a docid */\n        char *pList;\n        int nList;\n        int nByte;\n        sqlite3_int64 iDocid = apSegment[0]->iDocid;\n        fts3SegReaderNextDocid(apSegment[0], &pList, &nList);\n        j = 1;\n        while( j<nMerge\n            && apSegment[j]->pOffsetList\n            && apSegment[j]->iDocid==iDocid\n        ){\n          fts3SegReaderNextDocid(apSegment[j], 0, 0);\n          j++;\n        }\n\n        if( isColFilter ){\n          fts3ColumnFilter(pFilter->iCol, &pList, &nList);\n        }\n\n        if( !isIgnoreEmpty || nList>0 ){\n          nByte = sqlite3Fts3VarintLen(iDocid-iPrev) + (isRequirePos?nList+1:0);\n          if( nDoclist+nByte>pCsr->nBuffer ){\n            char *aNew;\n            pCsr->nBuffer = (nDoclist+nByte)*2;\n            aNew = sqlite3_realloc(pCsr->aBuffer, pCsr->nBuffer);\n            if( !aNew ){\n              return SQLITE_NOMEM;\n            }\n            pCsr->aBuffer = aNew;\n          }\n          nDoclist += sqlite3Fts3PutVarint(\n              &pCsr->aBuffer[nDoclist], iDocid-iPrev\n          );\n          iPrev = iDocid;\n          if( isRequirePos ){\n            memcpy(&pCsr->aBuffer[nDoclist], pList, nList);\n            nDoclist += nList;\n            pCsr->aBuffer[nDoclist++] = '\\0';\n          }\n        }\n\n        fts3SegReaderSort(apSegment, nMerge, j, fts3SegReaderDoclistCmp);\n      }\n      if( nDoclist>0 ){\n        pCsr->aDoclist = pCsr->aBuffer;\n        pCsr->nDoclist = nDoclist;\n        rc = SQLITE_ROW;\n      }\n    }\n    pCsr->nAdvance = nMerge;\n  }while( rc==SQLITE_OK );\n\n  return rc;\n}\n\nSQLITE_PRIVATE void sqlite3Fts3SegReaderFinish(\n  Fts3SegReaderCursor *pCsr       /* Cursor object */\n){\n  if( pCsr ){\n    int i;\n    for(i=0; i<pCsr->nSegment; i++){\n      sqlite3Fts3SegReaderFree(pCsr->apSegment[i]);\n    }\n    sqlite3_free(pCsr->apSegment);\n    sqlite3_free(pCsr->aBuffer);\n\n    pCsr->nSegment = 0;\n    pCsr->apSegment = 0;\n    pCsr->aBuffer = 0;\n  }\n}\n\n/*\n** Merge all level iLevel segments in the database into a single \n** iLevel+1 segment. Or, if iLevel<0, merge all segments into a\n** single segment with a level equal to the numerically largest level \n** currently present in the database.\n**\n** If this function is called with iLevel<0, but there is only one\n** segment in the database, SQLITE_DONE is returned immediately. \n** Otherwise, if successful, SQLITE_OK is returned. If an error occurs, \n** an SQLite error code is returned.\n*/\nstatic int fts3SegmentMerge(Fts3Table *p, int iLevel){\n  int rc;                         /* Return code */\n  int iIdx = 0;                   /* Index of new segment */\n  int iNewLevel = 0;              /* Level to create new segment at */\n  SegmentWriter *pWriter = 0;     /* Used to write the new, merged, segment */\n  Fts3SegFilter filter;           /* Segment term filter condition */\n  Fts3SegReaderCursor csr;        /* Cursor to iterate through level(s) */\n\n  rc = sqlite3Fts3SegReaderCursor(p, iLevel, 0, 0, 1, 0, &csr);\n  if( rc!=SQLITE_OK || csr.nSegment==0 ) goto finished;\n\n  if( iLevel==FTS3_SEGCURSOR_ALL ){\n    /* This call is to merge all segments in the database to a single\n    ** segment. The level of the new segment is equal to the the numerically \n    ** greatest segment level currently present in the database. The index\n    ** of the new segment is always 0.  */\n    int nDummy; /* TODO: Remove this */\n    if( csr.nSegment==1 ){\n      rc = SQLITE_DONE;\n      goto finished;\n    }\n    rc = fts3SegmentCountMax(p, &nDummy, &iNewLevel);\n  }else{\n    /* This call is to merge all segments at level iLevel. Find the next\n    ** available segment index at level iLevel+1. The call to\n    ** fts3AllocateSegdirIdx() will merge the segments at level iLevel+1 to \n    ** a single iLevel+2 segment if necessary.  */\n    iNewLevel = iLevel+1;\n    rc = fts3AllocateSegdirIdx(p, iNewLevel, &iIdx);\n  }\n  if( rc!=SQLITE_OK ) goto finished;\n  assert( csr.nSegment>0 );\n  assert( iNewLevel>=0 );\n\n  memset(&filter, 0, sizeof(Fts3SegFilter));\n  filter.flags = FTS3_SEGMENT_REQUIRE_POS;\n  filter.flags |= (iLevel==FTS3_SEGCURSOR_ALL ? FTS3_SEGMENT_IGNORE_EMPTY : 0);\n\n  rc = sqlite3Fts3SegReaderStart(p, &csr, &filter);\n  while( SQLITE_OK==rc ){\n    rc = sqlite3Fts3SegReaderStep(p, &csr);\n    if( rc!=SQLITE_ROW ) break;\n    rc = fts3SegWriterAdd(p, &pWriter, 1, \n        csr.zTerm, csr.nTerm, csr.aDoclist, csr.nDoclist);\n  }\n  if( rc!=SQLITE_OK ) goto finished;\n  assert( pWriter );\n\n  rc = fts3DeleteSegdir(p, iLevel, csr.apSegment, csr.nSegment);\n  if( rc!=SQLITE_OK ) goto finished;\n  rc = fts3SegWriterFlush(p, pWriter, iNewLevel, iIdx);\n\n finished:\n  fts3SegWriterFree(pWriter);\n  sqlite3Fts3SegReaderFinish(&csr);\n  return rc;\n}\n\n\n/* \n** Flush the contents of pendingTerms to a level 0 segment.\n*/\nSQLITE_PRIVATE int sqlite3Fts3PendingTermsFlush(Fts3Table *p){\n  return fts3SegmentMerge(p, FTS3_SEGCURSOR_PENDING);\n}\n\n/*\n** Encode N integers as varints into a blob.\n*/\nstatic void fts3EncodeIntArray(\n  int N,             /* The number of integers to encode */\n  u32 *a,            /* The integer values */\n  char *zBuf,        /* Write the BLOB here */\n  int *pNBuf         /* Write number of bytes if zBuf[] used here */\n){\n  int i, j;\n  for(i=j=0; i<N; i++){\n    j += sqlite3Fts3PutVarint(&zBuf[j], (sqlite3_int64)a[i]);\n  }\n  *pNBuf = j;\n}\n\n/*\n** Decode a blob of varints into N integers\n*/\nstatic void fts3DecodeIntArray(\n  int N,             /* The number of integers to decode */\n  u32 *a,            /* Write the integer values */\n  const char *zBuf,  /* The BLOB containing the varints */\n  int nBuf           /* size of the BLOB */\n){\n  int i, j;\n  UNUSED_PARAMETER(nBuf);\n  for(i=j=0; i<N; i++){\n    sqlite3_int64 x;\n    j += sqlite3Fts3GetVarint(&zBuf[j], &x);\n    assert(j<=nBuf);\n    a[i] = (u32)(x & 0xffffffff);\n  }\n}\n\n/*\n** Insert the sizes (in tokens) for each column of the document\n** with docid equal to p->iPrevDocid.  The sizes are encoded as\n** a blob of varints.\n*/\nstatic void fts3InsertDocsize(\n  int *pRC,         /* Result code */\n  Fts3Table *p,     /* Table into which to insert */\n  u32 *aSz          /* Sizes of each column */\n){\n  char *pBlob;             /* The BLOB encoding of the document size */\n  int nBlob;               /* Number of bytes in the BLOB */\n  sqlite3_stmt *pStmt;     /* Statement used to insert the encoding */\n  int rc;                  /* Result code from subfunctions */\n\n  if( *pRC ) return;\n  pBlob = sqlite3_malloc( 10*p->nColumn );\n  if( pBlob==0 ){\n    *pRC = SQLITE_NOMEM;\n    return;\n  }\n  fts3EncodeIntArray(p->nColumn, aSz, pBlob, &nBlob);\n  rc = fts3SqlStmt(p, SQL_REPLACE_DOCSIZE, &pStmt, 0);\n  if( rc ){\n    sqlite3_free(pBlob);\n    *pRC = rc;\n    return;\n  }\n  sqlite3_bind_int64(pStmt, 1, p->iPrevDocid);\n  sqlite3_bind_blob(pStmt, 2, pBlob, nBlob, sqlite3_free);\n  sqlite3_step(pStmt);\n  *pRC = sqlite3_reset(pStmt);\n}\n\n/*\n** Record 0 of the %_stat table contains a blob consisting of N varints,\n** where N is the number of user defined columns in the fts3 table plus\n** two. If nCol is the number of user defined columns, then values of the \n** varints are set as follows:\n**\n**   Varint 0:       Total number of rows in the table.\n**\n**   Varint 1..nCol: For each column, the total number of tokens stored in\n**                   the column for all rows of the table.\n**\n**   Varint 1+nCol:  The total size, in bytes, of all text values in all\n**                   columns of all rows of the table.\n**\n*/\nstatic void fts3UpdateDocTotals(\n  int *pRC,                       /* The result code */\n  Fts3Table *p,                   /* Table being updated */\n  u32 *aSzIns,                    /* Size increases */\n  u32 *aSzDel,                    /* Size decreases */\n  int nChng                       /* Change in the number of documents */\n){\n  char *pBlob;             /* Storage for BLOB written into %_stat */\n  int nBlob;               /* Size of BLOB written into %_stat */\n  u32 *a;                  /* Array of integers that becomes the BLOB */\n  sqlite3_stmt *pStmt;     /* Statement for reading and writing */\n  int i;                   /* Loop counter */\n  int rc;                  /* Result code from subfunctions */\n\n  const int nStat = p->nColumn+2;\n\n  if( *pRC ) return;\n  a = sqlite3_malloc( (sizeof(u32)+10)*nStat );\n  if( a==0 ){\n    *pRC = SQLITE_NOMEM;\n    return;\n  }\n  pBlob = (char*)&a[nStat];\n  rc = fts3SqlStmt(p, SQL_SELECT_DOCTOTAL, &pStmt, 0);\n  if( rc ){\n    sqlite3_free(a);\n    *pRC = rc;\n    return;\n  }\n  if( sqlite3_step(pStmt)==SQLITE_ROW ){\n    fts3DecodeIntArray(nStat, a,\n         sqlite3_column_blob(pStmt, 0),\n         sqlite3_column_bytes(pStmt, 0));\n  }else{\n    memset(a, 0, sizeof(u32)*(nStat) );\n  }\n  sqlite3_reset(pStmt);\n  if( nChng<0 && a[0]<(u32)(-nChng) ){\n    a[0] = 0;\n  }else{\n    a[0] += nChng;\n  }\n  for(i=0; i<p->nColumn+1; i++){\n    u32 x = a[i+1];\n    if( x+aSzIns[i] < aSzDel[i] ){\n      x = 0;\n    }else{\n      x = x + aSzIns[i] - aSzDel[i];\n    }\n    a[i+1] = x;\n  }\n  fts3EncodeIntArray(nStat, a, pBlob, &nBlob);\n  rc = fts3SqlStmt(p, SQL_REPLACE_DOCTOTAL, &pStmt, 0);\n  if( rc ){\n    sqlite3_free(a);\n    *pRC = rc;\n    return;\n  }\n  sqlite3_bind_blob(pStmt, 1, pBlob, nBlob, SQLITE_STATIC);\n  sqlite3_step(pStmt);\n  *pRC = sqlite3_reset(pStmt);\n  sqlite3_free(a);\n}\n\n/*\n** Handle a 'special' INSERT of the form:\n**\n**   \"INSERT INTO tbl(tbl) VALUES(<expr>)\"\n**\n** Argument pVal contains the result of <expr>. Currently the only \n** meaningful value to insert is the text 'optimize'.\n*/\nstatic int fts3SpecialInsert(Fts3Table *p, sqlite3_value *pVal){\n  int rc;                         /* Return Code */\n  const char *zVal = (const char *)sqlite3_value_text(pVal);\n  int nVal = sqlite3_value_bytes(pVal);\n\n  if( !zVal ){\n    return SQLITE_NOMEM;\n  }else if( nVal==8 && 0==sqlite3_strnicmp(zVal, \"optimize\", 8) ){\n    rc = fts3SegmentMerge(p, FTS3_SEGCURSOR_ALL);\n    if( rc==SQLITE_DONE ){\n      rc = SQLITE_OK;\n    }else{\n      sqlite3Fts3PendingTermsClear(p);\n    }\n#ifdef SQLITE_TEST\n  }else if( nVal>9 && 0==sqlite3_strnicmp(zVal, \"nodesize=\", 9) ){\n    p->nNodeSize = atoi(&zVal[9]);\n    rc = SQLITE_OK;\n  }else if( nVal>11 && 0==sqlite3_strnicmp(zVal, \"maxpending=\", 9) ){\n    p->nMaxPendingData = atoi(&zVal[11]);\n    rc = SQLITE_OK;\n#endif\n  }else{\n    rc = SQLITE_ERROR;\n  }\n\n  sqlite3Fts3SegmentsClose(p);\n  return rc;\n}\n\n/*\n** Return the deferred doclist associated with deferred token pDeferred.\n** This function assumes that sqlite3Fts3CacheDeferredDoclists() has already\n** been called to allocate and populate the doclist.\n*/\nSQLITE_PRIVATE char *sqlite3Fts3DeferredDoclist(Fts3DeferredToken *pDeferred, int *pnByte){\n  if( pDeferred->pList ){\n    *pnByte = pDeferred->pList->nData;\n    return pDeferred->pList->aData;\n  }\n  *pnByte = 0;\n  return 0;\n}\n\n/*\n** Helper fucntion for FreeDeferredDoclists(). This function removes all\n** references to deferred doclists from within the tree of Fts3Expr \n** structures headed by \n*/\nstatic void fts3DeferredDoclistClear(Fts3Expr *pExpr){\n  if( pExpr ){\n    fts3DeferredDoclistClear(pExpr->pLeft);\n    fts3DeferredDoclistClear(pExpr->pRight);\n    if( pExpr->isLoaded ){\n      sqlite3_free(pExpr->aDoclist);\n      pExpr->isLoaded = 0;\n      pExpr->aDoclist = 0;\n      pExpr->nDoclist = 0;\n      pExpr->pCurrent = 0;\n      pExpr->iCurrent = 0;\n    }\n  }\n}\n\n/*\n** Delete all cached deferred doclists. Deferred doclists are cached\n** (allocated) by the sqlite3Fts3CacheDeferredDoclists() function.\n*/\nSQLITE_PRIVATE void sqlite3Fts3FreeDeferredDoclists(Fts3Cursor *pCsr){\n  Fts3DeferredToken *pDef;\n  for(pDef=pCsr->pDeferred; pDef; pDef=pDef->pNext){\n    sqlite3_free(pDef->pList);\n    pDef->pList = 0;\n  }\n  if( pCsr->pDeferred ){\n    fts3DeferredDoclistClear(pCsr->pExpr);\n  }\n}\n\n/*\n** Free all entries in the pCsr->pDeffered list. Entries are added to \n** this list using sqlite3Fts3DeferToken().\n*/\nSQLITE_PRIVATE void sqlite3Fts3FreeDeferredTokens(Fts3Cursor *pCsr){\n  Fts3DeferredToken *pDef;\n  Fts3DeferredToken *pNext;\n  for(pDef=pCsr->pDeferred; pDef; pDef=pNext){\n    pNext = pDef->pNext;\n    sqlite3_free(pDef->pList);\n    sqlite3_free(pDef);\n  }\n  pCsr->pDeferred = 0;\n}\n\n/*\n** Generate deferred-doclists for all tokens in the pCsr->pDeferred list\n** based on the row that pCsr currently points to.\n**\n** A deferred-doclist is like any other doclist with position information\n** included, except that it only contains entries for a single row of the\n** table, not for all rows.\n*/\nSQLITE_PRIVATE int sqlite3Fts3CacheDeferredDoclists(Fts3Cursor *pCsr){\n  int rc = SQLITE_OK;             /* Return code */\n  if( pCsr->pDeferred ){\n    int i;                        /* Used to iterate through table columns */\n    sqlite3_int64 iDocid;         /* Docid of the row pCsr points to */\n    Fts3DeferredToken *pDef;      /* Used to iterate through deferred tokens */\n  \n    Fts3Table *p = (Fts3Table *)pCsr->base.pVtab;\n    sqlite3_tokenizer *pT = p->pTokenizer;\n    sqlite3_tokenizer_module const *pModule = pT->pModule;\n   \n    assert( pCsr->isRequireSeek==0 );\n    iDocid = sqlite3_column_int64(pCsr->pStmt, 0);\n  \n    for(i=0; i<p->nColumn && rc==SQLITE_OK; i++){\n      const char *zText = (const char *)sqlite3_column_text(pCsr->pStmt, i+1);\n      sqlite3_tokenizer_cursor *pTC = 0;\n  \n      rc = pModule->xOpen(pT, zText, -1, &pTC);\n      while( rc==SQLITE_OK ){\n        char const *zToken;       /* Buffer containing token */\n        int nToken;               /* Number of bytes in token */\n        int iDum1, iDum2;         /* Dummy variables */\n        int iPos;                 /* Position of token in zText */\n  \n        pTC->pTokenizer = pT;\n        rc = pModule->xNext(pTC, &zToken, &nToken, &iDum1, &iDum2, &iPos);\n        for(pDef=pCsr->pDeferred; pDef && rc==SQLITE_OK; pDef=pDef->pNext){\n          Fts3PhraseToken *pPT = pDef->pToken;\n          if( (pDef->iCol>=p->nColumn || pDef->iCol==i)\n           && (pPT->n==nToken || (pPT->isPrefix && pPT->n<nToken))\n           && (0==memcmp(zToken, pPT->z, pPT->n))\n          ){\n            fts3PendingListAppend(&pDef->pList, iDocid, i, iPos, &rc);\n          }\n        }\n      }\n      if( pTC ) pModule->xClose(pTC);\n      if( rc==SQLITE_DONE ) rc = SQLITE_OK;\n    }\n  \n    for(pDef=pCsr->pDeferred; pDef && rc==SQLITE_OK; pDef=pDef->pNext){\n      if( pDef->pList ){\n        rc = fts3PendingListAppendVarint(&pDef->pList, 0);\n      }\n    }\n  }\n\n  return rc;\n}\n\n/*\n** Add an entry for token pToken to the pCsr->pDeferred list.\n*/\nSQLITE_PRIVATE int sqlite3Fts3DeferToken(\n  Fts3Cursor *pCsr,               /* Fts3 table cursor */\n  Fts3PhraseToken *pToken,        /* Token to defer */\n  int iCol                        /* Column that token must appear in (or -1) */\n){\n  Fts3DeferredToken *pDeferred;\n  pDeferred = sqlite3_malloc(sizeof(*pDeferred));\n  if( !pDeferred ){\n    return SQLITE_NOMEM;\n  }\n  memset(pDeferred, 0, sizeof(*pDeferred));\n  pDeferred->pToken = pToken;\n  pDeferred->pNext = pCsr->pDeferred; \n  pDeferred->iCol = iCol;\n  pCsr->pDeferred = pDeferred;\n\n  assert( pToken->pDeferred==0 );\n  pToken->pDeferred = pDeferred;\n\n  return SQLITE_OK;\n}\n\n\n/*\n** This function does the work for the xUpdate method of FTS3 virtual\n** tables.\n*/\nSQLITE_PRIVATE int sqlite3Fts3UpdateMethod(\n  sqlite3_vtab *pVtab,            /* FTS3 vtab object */\n  int nArg,                       /* Size of argument array */\n  sqlite3_value **apVal,          /* Array of arguments */\n  sqlite_int64 *pRowid            /* OUT: The affected (or effected) rowid */\n){\n  Fts3Table *p = (Fts3Table *)pVtab;\n  int rc = SQLITE_OK;             /* Return Code */\n  int isRemove = 0;               /* True for an UPDATE or DELETE */\n  sqlite3_int64 iRemove = 0;      /* Rowid removed by UPDATE or DELETE */\n  u32 *aSzIns;                    /* Sizes of inserted documents */\n  u32 *aSzDel;                    /* Sizes of deleted documents */\n  int nChng = 0;                  /* Net change in number of documents */\n\n  assert( p->pSegments==0 );\n\n  /* Allocate space to hold the change in document sizes */\n  aSzIns = sqlite3_malloc( sizeof(aSzIns[0])*(p->nColumn+1)*2 );\n  if( aSzIns==0 ) return SQLITE_NOMEM;\n  aSzDel = &aSzIns[p->nColumn+1];\n  memset(aSzIns, 0, sizeof(aSzIns[0])*(p->nColumn+1)*2);\n\n  /* If this is a DELETE or UPDATE operation, remove the old record. */\n  if( sqlite3_value_type(apVal[0])!=SQLITE_NULL ){\n    int isEmpty = 0;\n    rc = fts3IsEmpty(p, apVal, &isEmpty);\n    if( rc==SQLITE_OK ){\n      if( isEmpty ){\n        /* Deleting this row means the whole table is empty. In this case\n        ** delete the contents of all three tables and throw away any\n        ** data in the pendingTerms hash table.\n        */\n        rc = fts3DeleteAll(p);\n      }else{\n        isRemove = 1;\n        iRemove = sqlite3_value_int64(apVal[0]);\n        rc = fts3PendingTermsDocid(p, iRemove);\n        fts3DeleteTerms(&rc, p, apVal, aSzDel);\n        fts3SqlExec(&rc, p, SQL_DELETE_CONTENT, apVal);\n        if( p->bHasDocsize ){\n          fts3SqlExec(&rc, p, SQL_DELETE_DOCSIZE, apVal);\n        }\n        nChng--;\n      }\n    }\n  }else if( sqlite3_value_type(apVal[p->nColumn+2])!=SQLITE_NULL ){\n    sqlite3_free(aSzIns);\n    return fts3SpecialInsert(p, apVal[p->nColumn+2]);\n  }\n  \n  /* If this is an INSERT or UPDATE operation, insert the new record. */\n  if( nArg>1 && rc==SQLITE_OK ){\n    rc = fts3InsertData(p, apVal, pRowid);\n    if( rc==SQLITE_OK && (!isRemove || *pRowid!=iRemove) ){\n      rc = fts3PendingTermsDocid(p, *pRowid);\n    }\n    if( rc==SQLITE_OK ){\n      rc = fts3InsertTerms(p, apVal, aSzIns);\n    }\n    if( p->bHasDocsize ){\n      fts3InsertDocsize(&rc, p, aSzIns);\n    }\n    nChng++;\n  }\n\n  if( p->bHasStat ){\n    fts3UpdateDocTotals(&rc, p, aSzIns, aSzDel, nChng);\n  }\n\n  sqlite3_free(aSzIns);\n  sqlite3Fts3SegmentsClose(p);\n  return rc;\n}\n\n/* \n** Flush any data in the pending-terms hash table to disk. If successful,\n** merge all segments in the database (including the new segment, if \n** there was any data to flush) into a single segment. \n*/\nSQLITE_PRIVATE int sqlite3Fts3Optimize(Fts3Table *p){\n  int rc;\n  rc = sqlite3_exec(p->db, \"SAVEPOINT fts3\", 0, 0, 0);\n  if( rc==SQLITE_OK ){\n    rc = fts3SegmentMerge(p, FTS3_SEGCURSOR_ALL);\n    if( rc==SQLITE_OK ){\n      rc = sqlite3_exec(p->db, \"RELEASE fts3\", 0, 0, 0);\n      if( rc==SQLITE_OK ){\n        sqlite3Fts3PendingTermsClear(p);\n      }\n    }else{\n      sqlite3_exec(p->db, \"ROLLBACK TO fts3\", 0, 0, 0);\n      sqlite3_exec(p->db, \"RELEASE fts3\", 0, 0, 0);\n    }\n  }\n  sqlite3Fts3SegmentsClose(p);\n  return rc;\n}\n\n#endif\n\n/************** End of fts3_write.c ******************************************/\n/************** Begin file fts3_snippet.c ************************************/\n/*\n** 2009 Oct 23\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n******************************************************************************\n*/\n\n#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS3)\n\n\n/*\n** Characters that may appear in the second argument to matchinfo().\n*/\n#define FTS3_MATCHINFO_NPHRASE   'p'        /* 1 value */\n#define FTS3_MATCHINFO_NCOL      'c'        /* 1 value */\n#define FTS3_MATCHINFO_NDOC      'n'        /* 1 value */\n#define FTS3_MATCHINFO_AVGLENGTH 'a'        /* nCol values */\n#define FTS3_MATCHINFO_LENGTH    'l'        /* nCol values */\n#define FTS3_MATCHINFO_LCS       's'        /* nCol values */\n#define FTS3_MATCHINFO_HITS      'x'        /* 3*nCol*nPhrase values */\n\n/*\n** The default value for the second argument to matchinfo(). \n*/\n#define FTS3_MATCHINFO_DEFAULT   \"pcx\"\n\n\n/*\n** Used as an fts3ExprIterate() context when loading phrase doclists to\n** Fts3Expr.aDoclist[]/nDoclist.\n*/\ntypedef struct LoadDoclistCtx LoadDoclistCtx;\nstruct LoadDoclistCtx {\n  Fts3Cursor *pCsr;               /* FTS3 Cursor */\n  int nPhrase;                    /* Number of phrases seen so far */\n  int nToken;                     /* Number of tokens seen so far */\n};\n\n/*\n** The following types are used as part of the implementation of the \n** fts3BestSnippet() routine.\n*/\ntypedef struct SnippetIter SnippetIter;\ntypedef struct SnippetPhrase SnippetPhrase;\ntypedef struct SnippetFragment SnippetFragment;\n\nstruct SnippetIter {\n  Fts3Cursor *pCsr;               /* Cursor snippet is being generated from */\n  int iCol;                       /* Extract snippet from this column */\n  int nSnippet;                   /* Requested snippet length (in tokens) */\n  int nPhrase;                    /* Number of phrases in query */\n  SnippetPhrase *aPhrase;         /* Array of size nPhrase */\n  int iCurrent;                   /* First token of current snippet */\n};\n\nstruct SnippetPhrase {\n  int nToken;                     /* Number of tokens in phrase */\n  char *pList;                    /* Pointer to start of phrase position list */\n  int iHead;                      /* Next value in position list */\n  char *pHead;                    /* Position list data following iHead */\n  int iTail;                      /* Next value in trailing position list */\n  char *pTail;                    /* Position list data following iTail */\n};\n\nstruct SnippetFragment {\n  int iCol;                       /* Column snippet is extracted from */\n  int iPos;                       /* Index of first token in snippet */\n  u64 covered;                    /* Mask of query phrases covered */\n  u64 hlmask;                     /* Mask of snippet terms to highlight */\n};\n\n/*\n** This type is used as an fts3ExprIterate() context object while \n** accumulating the data returned by the matchinfo() function.\n*/\ntypedef struct MatchInfo MatchInfo;\nstruct MatchInfo {\n  Fts3Cursor *pCursor;            /* FTS3 Cursor */\n  int nCol;                       /* Number of columns in table */\n  int nPhrase;                    /* Number of matchable phrases in query */\n  sqlite3_int64 nDoc;             /* Number of docs in database */\n  u32 *aMatchinfo;                /* Pre-allocated buffer */\n};\n\n\n\n/*\n** The snippet() and offsets() functions both return text values. An instance\n** of the following structure is used to accumulate those values while the\n** functions are running. See fts3StringAppend() for details.\n*/\ntypedef struct StrBuffer StrBuffer;\nstruct StrBuffer {\n  char *z;                        /* Pointer to buffer containing string */\n  int n;                          /* Length of z in bytes (excl. nul-term) */\n  int nAlloc;                     /* Allocated size of buffer z in bytes */\n};\n\n\n/*\n** This function is used to help iterate through a position-list. A position\n** list is a list of unique integers, sorted from smallest to largest. Each\n** element of the list is represented by an FTS3 varint that takes the value\n** of the difference between the current element and the previous one plus\n** two. For example, to store the position-list:\n**\n**     4 9 113\n**\n** the three varints:\n**\n**     6 7 106\n**\n** are encoded.\n**\n** When this function is called, *pp points to the start of an element of\n** the list. *piPos contains the value of the previous entry in the list.\n** After it returns, *piPos contains the value of the next element of the\n** list and *pp is advanced to the following varint.\n*/\nstatic void fts3GetDeltaPosition(char **pp, int *piPos){\n  int iVal;\n  *pp += sqlite3Fts3GetVarint32(*pp, &iVal);\n  *piPos += (iVal-2);\n}\n\n/*\n** Helper function for fts3ExprIterate() (see below).\n*/\nstatic int fts3ExprIterate2(\n  Fts3Expr *pExpr,                /* Expression to iterate phrases of */\n  int *piPhrase,                  /* Pointer to phrase counter */\n  int (*x)(Fts3Expr*,int,void*),  /* Callback function to invoke for phrases */\n  void *pCtx                      /* Second argument to pass to callback */\n){\n  int rc;                         /* Return code */\n  int eType = pExpr->eType;       /* Type of expression node pExpr */\n\n  if( eType!=FTSQUERY_PHRASE ){\n    assert( pExpr->pLeft && pExpr->pRight );\n    rc = fts3ExprIterate2(pExpr->pLeft, piPhrase, x, pCtx);\n    if( rc==SQLITE_OK && eType!=FTSQUERY_NOT ){\n      rc = fts3ExprIterate2(pExpr->pRight, piPhrase, x, pCtx);\n    }\n  }else{\n    rc = x(pExpr, *piPhrase, pCtx);\n    (*piPhrase)++;\n  }\n  return rc;\n}\n\n/*\n** Iterate through all phrase nodes in an FTS3 query, except those that\n** are part of a sub-tree that is the right-hand-side of a NOT operator.\n** For each phrase node found, the supplied callback function is invoked.\n**\n** If the callback function returns anything other than SQLITE_OK, \n** the iteration is abandoned and the error code returned immediately.\n** Otherwise, SQLITE_OK is returned after a callback has been made for\n** all eligible phrase nodes.\n*/\nstatic int fts3ExprIterate(\n  Fts3Expr *pExpr,                /* Expression to iterate phrases of */\n  int (*x)(Fts3Expr*,int,void*),  /* Callback function to invoke for phrases */\n  void *pCtx                      /* Second argument to pass to callback */\n){\n  int iPhrase = 0;                /* Variable used as the phrase counter */\n  return fts3ExprIterate2(pExpr, &iPhrase, x, pCtx);\n}\n\n/*\n** The argument to this function is always a phrase node. Its doclist \n** (Fts3Expr.aDoclist[]) and the doclists associated with all phrase nodes\n** to the left of this one in the query tree have already been loaded.\n**\n** If this phrase node is part of a series of phrase nodes joined by \n** NEAR operators (and is not the left-most of said series), then elements are\n** removed from the phrases doclist consistent with the NEAR restriction. If\n** required, elements may be removed from the doclists of phrases to the\n** left of this one that are part of the same series of NEAR operator \n** connected phrases.\n**\n** If an OOM error occurs, SQLITE_NOMEM is returned. Otherwise, SQLITE_OK.\n*/\nstatic int fts3ExprNearTrim(Fts3Expr *pExpr){\n  int rc = SQLITE_OK;\n  Fts3Expr *pParent = pExpr->pParent;\n\n  assert( pExpr->eType==FTSQUERY_PHRASE );\n  while( rc==SQLITE_OK\n   && pParent \n   && pParent->eType==FTSQUERY_NEAR \n   && pParent->pRight==pExpr \n  ){\n    /* This expression (pExpr) is the right-hand-side of a NEAR operator. \n    ** Find the expression to the left of the same operator.\n    */\n    int nNear = pParent->nNear;\n    Fts3Expr *pLeft = pParent->pLeft;\n\n    if( pLeft->eType!=FTSQUERY_PHRASE ){\n      assert( pLeft->eType==FTSQUERY_NEAR );\n      assert( pLeft->pRight->eType==FTSQUERY_PHRASE );\n      pLeft = pLeft->pRight;\n    }\n\n    rc = sqlite3Fts3ExprNearTrim(pLeft, pExpr, nNear);\n\n    pExpr = pLeft;\n    pParent = pExpr->pParent;\n  }\n\n  return rc;\n}\n\n/*\n** This is an fts3ExprIterate() callback used while loading the doclists\n** for each phrase into Fts3Expr.aDoclist[]/nDoclist. See also\n** fts3ExprLoadDoclists().\n*/\nstatic int fts3ExprLoadDoclistsCb(Fts3Expr *pExpr, int iPhrase, void *ctx){\n  int rc = SQLITE_OK;\n  LoadDoclistCtx *p = (LoadDoclistCtx *)ctx;\n\n  UNUSED_PARAMETER(iPhrase);\n\n  p->nPhrase++;\n  p->nToken += pExpr->pPhrase->nToken;\n\n  if( pExpr->isLoaded==0 ){\n    rc = sqlite3Fts3ExprLoadDoclist(p->pCsr, pExpr);\n    pExpr->isLoaded = 1;\n    if( rc==SQLITE_OK ){\n      rc = fts3ExprNearTrim(pExpr);\n    }\n  }\n\n  return rc;\n}\n\n/*\n** Load the doclists for each phrase in the query associated with FTS3 cursor\n** pCsr. \n**\n** If pnPhrase is not NULL, then *pnPhrase is set to the number of matchable \n** phrases in the expression (all phrases except those directly or \n** indirectly descended from the right-hand-side of a NOT operator). If \n** pnToken is not NULL, then it is set to the number of tokens in all\n** matchable phrases of the expression.\n*/\nstatic int fts3ExprLoadDoclists(\n  Fts3Cursor *pCsr,               /* Fts3 cursor for current query */\n  int *pnPhrase,                  /* OUT: Number of phrases in query */\n  int *pnToken                    /* OUT: Number of tokens in query */\n){\n  int rc;                         /* Return Code */\n  LoadDoclistCtx sCtx = {0,0,0};  /* Context for fts3ExprIterate() */\n  sCtx.pCsr = pCsr;\n  rc = fts3ExprIterate(pCsr->pExpr, fts3ExprLoadDoclistsCb, (void *)&sCtx);\n  if( pnPhrase ) *pnPhrase = sCtx.nPhrase;\n  if( pnToken ) *pnToken = sCtx.nToken;\n  return rc;\n}\n\nstatic int fts3ExprPhraseCountCb(Fts3Expr *pExpr, int iPhrase, void *ctx){\n  (*(int *)ctx)++;\n  UNUSED_PARAMETER(pExpr);\n  UNUSED_PARAMETER(iPhrase);\n  return SQLITE_OK;\n}\nstatic int fts3ExprPhraseCount(Fts3Expr *pExpr){\n  int nPhrase = 0;\n  (void)fts3ExprIterate(pExpr, fts3ExprPhraseCountCb, (void *)&nPhrase);\n  return nPhrase;\n}\n\n/*\n** Advance the position list iterator specified by the first two \n** arguments so that it points to the first element with a value greater\n** than or equal to parameter iNext.\n*/\nstatic void fts3SnippetAdvance(char **ppIter, int *piIter, int iNext){\n  char *pIter = *ppIter;\n  if( pIter ){\n    int iIter = *piIter;\n\n    while( iIter<iNext ){\n      if( 0==(*pIter & 0xFE) ){\n        iIter = -1;\n        pIter = 0;\n        break;\n      }\n      fts3GetDeltaPosition(&pIter, &iIter);\n    }\n\n    *piIter = iIter;\n    *ppIter = pIter;\n  }\n}\n\n/*\n** Advance the snippet iterator to the next candidate snippet.\n*/\nstatic int fts3SnippetNextCandidate(SnippetIter *pIter){\n  int i;                          /* Loop counter */\n\n  if( pIter->iCurrent<0 ){\n    /* The SnippetIter object has just been initialized. The first snippet\n    ** candidate always starts at offset 0 (even if this candidate has a\n    ** score of 0.0).\n    */\n    pIter->iCurrent = 0;\n\n    /* Advance the 'head' iterator of each phrase to the first offset that\n    ** is greater than or equal to (iNext+nSnippet).\n    */\n    for(i=0; i<pIter->nPhrase; i++){\n      SnippetPhrase *pPhrase = &pIter->aPhrase[i];\n      fts3SnippetAdvance(&pPhrase->pHead, &pPhrase->iHead, pIter->nSnippet);\n    }\n  }else{\n    int iStart;\n    int iEnd = 0x7FFFFFFF;\n\n    for(i=0; i<pIter->nPhrase; i++){\n      SnippetPhrase *pPhrase = &pIter->aPhrase[i];\n      if( pPhrase->pHead && pPhrase->iHead<iEnd ){\n        iEnd = pPhrase->iHead;\n      }\n    }\n    if( iEnd==0x7FFFFFFF ){\n      return 1;\n    }\n\n    pIter->iCurrent = iStart = iEnd - pIter->nSnippet + 1;\n    for(i=0; i<pIter->nPhrase; i++){\n      SnippetPhrase *pPhrase = &pIter->aPhrase[i];\n      fts3SnippetAdvance(&pPhrase->pHead, &pPhrase->iHead, iEnd+1);\n      fts3SnippetAdvance(&pPhrase->pTail, &pPhrase->iTail, iStart);\n    }\n  }\n\n  return 0;\n}\n\n/*\n** Retrieve information about the current candidate snippet of snippet \n** iterator pIter.\n*/\nstatic void fts3SnippetDetails(\n  SnippetIter *pIter,             /* Snippet iterator */\n  u64 mCovered,                   /* Bitmask of phrases already covered */\n  int *piToken,                   /* OUT: First token of proposed snippet */\n  int *piScore,                   /* OUT: \"Score\" for this snippet */\n  u64 *pmCover,                   /* OUT: Bitmask of phrases covered */\n  u64 *pmHighlight                /* OUT: Bitmask of terms to highlight */\n){\n  int iStart = pIter->iCurrent;   /* First token of snippet */\n  int iScore = 0;                 /* Score of this snippet */\n  int i;                          /* Loop counter */\n  u64 mCover = 0;                 /* Mask of phrases covered by this snippet */\n  u64 mHighlight = 0;             /* Mask of tokens to highlight in snippet */\n\n  for(i=0; i<pIter->nPhrase; i++){\n    SnippetPhrase *pPhrase = &pIter->aPhrase[i];\n    if( pPhrase->pTail ){\n      char *pCsr = pPhrase->pTail;\n      int iCsr = pPhrase->iTail;\n\n      while( iCsr<(iStart+pIter->nSnippet) ){\n        int j;\n        u64 mPhrase = (u64)1 << i;\n        u64 mPos = (u64)1 << (iCsr - iStart);\n        assert( iCsr>=iStart );\n        if( (mCover|mCovered)&mPhrase ){\n          iScore++;\n        }else{\n          iScore += 1000;\n        }\n        mCover |= mPhrase;\n\n        for(j=0; j<pPhrase->nToken; j++){\n          mHighlight |= (mPos>>j);\n        }\n\n        if( 0==(*pCsr & 0x0FE) ) break;\n        fts3GetDeltaPosition(&pCsr, &iCsr);\n      }\n    }\n  }\n\n  /* Set the output variables before returning. */\n  *piToken = iStart;\n  *piScore = iScore;\n  *pmCover = mCover;\n  *pmHighlight = mHighlight;\n}\n\n/*\n** This function is an fts3ExprIterate() callback used by fts3BestSnippet().\n** Each invocation populates an element of the SnippetIter.aPhrase[] array.\n*/\nstatic int fts3SnippetFindPositions(Fts3Expr *pExpr, int iPhrase, void *ctx){\n  SnippetIter *p = (SnippetIter *)ctx;\n  SnippetPhrase *pPhrase = &p->aPhrase[iPhrase];\n  char *pCsr;\n\n  pPhrase->nToken = pExpr->pPhrase->nToken;\n\n  pCsr = sqlite3Fts3FindPositions(pExpr, p->pCsr->iPrevId, p->iCol);\n  if( pCsr ){\n    int iFirst = 0;\n    pPhrase->pList = pCsr;\n    fts3GetDeltaPosition(&pCsr, &iFirst);\n    pPhrase->pHead = pCsr;\n    pPhrase->pTail = pCsr;\n    pPhrase->iHead = iFirst;\n    pPhrase->iTail = iFirst;\n  }else{\n    assert( pPhrase->pList==0 && pPhrase->pHead==0 && pPhrase->pTail==0 );\n  }\n\n  return SQLITE_OK;\n}\n\n/*\n** Select the fragment of text consisting of nFragment contiguous tokens \n** from column iCol that represent the \"best\" snippet. The best snippet\n** is the snippet with the highest score, where scores are calculated\n** by adding:\n**\n**   (a) +1 point for each occurence of a matchable phrase in the snippet.\n**\n**   (b) +1000 points for the first occurence of each matchable phrase in \n**       the snippet for which the corresponding mCovered bit is not set.\n**\n** The selected snippet parameters are stored in structure *pFragment before\n** returning. The score of the selected snippet is stored in *piScore\n** before returning.\n*/\nstatic int fts3BestSnippet(\n  int nSnippet,                   /* Desired snippet length */\n  Fts3Cursor *pCsr,               /* Cursor to create snippet for */\n  int iCol,                       /* Index of column to create snippet from */\n  u64 mCovered,                   /* Mask of phrases already covered */\n  u64 *pmSeen,                    /* IN/OUT: Mask of phrases seen */\n  SnippetFragment *pFragment,     /* OUT: Best snippet found */\n  int *piScore                    /* OUT: Score of snippet pFragment */\n){\n  int rc;                         /* Return Code */\n  int nList;                      /* Number of phrases in expression */\n  SnippetIter sIter;              /* Iterates through snippet candidates */\n  int nByte;                      /* Number of bytes of space to allocate */\n  int iBestScore = -1;            /* Best snippet score found so far */\n  int i;                          /* Loop counter */\n\n  memset(&sIter, 0, sizeof(sIter));\n\n  /* Iterate through the phrases in the expression to count them. The same\n  ** callback makes sure the doclists are loaded for each phrase.\n  */\n  rc = fts3ExprLoadDoclists(pCsr, &nList, 0);\n  if( rc!=SQLITE_OK ){\n    return rc;\n  }\n\n  /* Now that it is known how many phrases there are, allocate and zero\n  ** the required space using malloc().\n  */\n  nByte = sizeof(SnippetPhrase) * nList;\n  sIter.aPhrase = (SnippetPhrase *)sqlite3_malloc(nByte);\n  if( !sIter.aPhrase ){\n    return SQLITE_NOMEM;\n  }\n  memset(sIter.aPhrase, 0, nByte);\n\n  /* Initialize the contents of the SnippetIter object. Then iterate through\n  ** the set of phrases in the expression to populate the aPhrase[] array.\n  */\n  sIter.pCsr = pCsr;\n  sIter.iCol = iCol;\n  sIter.nSnippet = nSnippet;\n  sIter.nPhrase = nList;\n  sIter.iCurrent = -1;\n  (void)fts3ExprIterate(pCsr->pExpr, fts3SnippetFindPositions, (void *)&sIter);\n\n  /* Set the *pmSeen output variable. */\n  for(i=0; i<nList; i++){\n    if( sIter.aPhrase[i].pHead ){\n      *pmSeen |= (u64)1 << i;\n    }\n  }\n\n  /* Loop through all candidate snippets. Store the best snippet in \n  ** *pFragment. Store its associated 'score' in iBestScore.\n  */\n  pFragment->iCol = iCol;\n  while( !fts3SnippetNextCandidate(&sIter) ){\n    int iPos;\n    int iScore;\n    u64 mCover;\n    u64 mHighlight;\n    fts3SnippetDetails(&sIter, mCovered, &iPos, &iScore, &mCover, &mHighlight);\n    assert( iScore>=0 );\n    if( iScore>iBestScore ){\n      pFragment->iPos = iPos;\n      pFragment->hlmask = mHighlight;\n      pFragment->covered = mCover;\n      iBestScore = iScore;\n    }\n  }\n\n  sqlite3_free(sIter.aPhrase);\n  *piScore = iBestScore;\n  return SQLITE_OK;\n}\n\n\n/*\n** Append a string to the string-buffer passed as the first argument.\n**\n** If nAppend is negative, then the length of the string zAppend is\n** determined using strlen().\n*/\nstatic int fts3StringAppend(\n  StrBuffer *pStr,                /* Buffer to append to */\n  const char *zAppend,            /* Pointer to data to append to buffer */\n  int nAppend                     /* Size of zAppend in bytes (or -1) */\n){\n  if( nAppend<0 ){\n    nAppend = (int)strlen(zAppend);\n  }\n\n  /* If there is insufficient space allocated at StrBuffer.z, use realloc()\n  ** to grow the buffer until so that it is big enough to accomadate the\n  ** appended data.\n  */\n  if( pStr->n+nAppend+1>=pStr->nAlloc ){\n    int nAlloc = pStr->nAlloc+nAppend+100;\n    char *zNew = sqlite3_realloc(pStr->z, nAlloc);\n    if( !zNew ){\n      return SQLITE_NOMEM;\n    }\n    pStr->z = zNew;\n    pStr->nAlloc = nAlloc;\n  }\n\n  /* Append the data to the string buffer. */\n  memcpy(&pStr->z[pStr->n], zAppend, nAppend);\n  pStr->n += nAppend;\n  pStr->z[pStr->n] = '\\0';\n\n  return SQLITE_OK;\n}\n\n/*\n** The fts3BestSnippet() function often selects snippets that end with a\n** query term. That is, the final term of the snippet is always a term\n** that requires highlighting. For example, if 'X' is a highlighted term\n** and '.' is a non-highlighted term, BestSnippet() may select:\n**\n**     ........X.....X\n**\n** This function \"shifts\" the beginning of the snippet forward in the \n** document so that there are approximately the same number of \n** non-highlighted terms to the right of the final highlighted term as there\n** are to the left of the first highlighted term. For example, to this:\n**\n**     ....X.....X....\n**\n** This is done as part of extracting the snippet text, not when selecting\n** the snippet. Snippet selection is done based on doclists only, so there\n** is no way for fts3BestSnippet() to know whether or not the document \n** actually contains terms that follow the final highlighted term. \n*/\nstatic int fts3SnippetShift(\n  Fts3Table *pTab,                /* FTS3 table snippet comes from */\n  int nSnippet,                   /* Number of tokens desired for snippet */\n  const char *zDoc,               /* Document text to extract snippet from */\n  int nDoc,                       /* Size of buffer zDoc in bytes */\n  int *piPos,                     /* IN/OUT: First token of snippet */\n  u64 *pHlmask                    /* IN/OUT: Mask of tokens to highlight */\n){\n  u64 hlmask = *pHlmask;          /* Local copy of initial highlight-mask */\n\n  if( hlmask ){\n    int nLeft;                    /* Tokens to the left of first highlight */\n    int nRight;                   /* Tokens to the right of last highlight */\n    int nDesired;                 /* Ideal number of tokens to shift forward */\n\n    for(nLeft=0; !(hlmask & ((u64)1 << nLeft)); nLeft++);\n    for(nRight=0; !(hlmask & ((u64)1 << (nSnippet-1-nRight))); nRight++);\n    nDesired = (nLeft-nRight)/2;\n\n    /* Ideally, the start of the snippet should be pushed forward in the\n    ** document nDesired tokens. This block checks if there are actually\n    ** nDesired tokens to the right of the snippet. If so, *piPos and\n    ** *pHlMask are updated to shift the snippet nDesired tokens to the\n    ** right. Otherwise, the snippet is shifted by the number of tokens\n    ** available.\n    */\n    if( nDesired>0 ){\n      int nShift;                 /* Number of tokens to shift snippet by */\n      int iCurrent = 0;           /* Token counter */\n      int rc;                     /* Return Code */\n      sqlite3_tokenizer_module *pMod;\n      sqlite3_tokenizer_cursor *pC;\n      pMod = (sqlite3_tokenizer_module *)pTab->pTokenizer->pModule;\n\n      /* Open a cursor on zDoc/nDoc. Check if there are (nSnippet+nDesired)\n      ** or more tokens in zDoc/nDoc.\n      */\n      rc = pMod->xOpen(pTab->pTokenizer, zDoc, nDoc, &pC);\n      if( rc!=SQLITE_OK ){\n        return rc;\n      }\n      pC->pTokenizer = pTab->pTokenizer;\n      while( rc==SQLITE_OK && iCurrent<(nSnippet+nDesired) ){\n        const char *ZDUMMY; int DUMMY1, DUMMY2, DUMMY3;\n        rc = pMod->xNext(pC, &ZDUMMY, &DUMMY1, &DUMMY2, &DUMMY3, &iCurrent);\n      }\n      pMod->xClose(pC);\n      if( rc!=SQLITE_OK && rc!=SQLITE_DONE ){ return rc; }\n\n      nShift = (rc==SQLITE_DONE)+iCurrent-nSnippet;\n      assert( nShift<=nDesired );\n      if( nShift>0 ){\n        *piPos += nShift;\n        *pHlmask = hlmask >> nShift;\n      }\n    }\n  }\n  return SQLITE_OK;\n}\n\n/*\n** Extract the snippet text for fragment pFragment from cursor pCsr and\n** append it to string buffer pOut.\n*/\nstatic int fts3SnippetText(\n  Fts3Cursor *pCsr,               /* FTS3 Cursor */\n  SnippetFragment *pFragment,     /* Snippet to extract */\n  int iFragment,                  /* Fragment number */\n  int isLast,                     /* True for final fragment in snippet */\n  int nSnippet,                   /* Number of tokens in extracted snippet */\n  const char *zOpen,              /* String inserted before highlighted term */\n  const char *zClose,             /* String inserted after highlighted term */\n  const char *zEllipsis,          /* String inserted between snippets */\n  StrBuffer *pOut                 /* Write output here */\n){\n  Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;\n  int rc;                         /* Return code */\n  const char *zDoc;               /* Document text to extract snippet from */\n  int nDoc;                       /* Size of zDoc in bytes */\n  int iCurrent = 0;               /* Current token number of document */\n  int iEnd = 0;                   /* Byte offset of end of current token */\n  int isShiftDone = 0;            /* True after snippet is shifted */\n  int iPos = pFragment->iPos;     /* First token of snippet */\n  u64 hlmask = pFragment->hlmask; /* Highlight-mask for snippet */\n  int iCol = pFragment->iCol+1;   /* Query column to extract text from */\n  sqlite3_tokenizer_module *pMod; /* Tokenizer module methods object */\n  sqlite3_tokenizer_cursor *pC;   /* Tokenizer cursor open on zDoc/nDoc */\n  const char *ZDUMMY;             /* Dummy argument used with tokenizer */\n  int DUMMY1;                     /* Dummy argument used with tokenizer */\n  \n  zDoc = (const char *)sqlite3_column_text(pCsr->pStmt, iCol);\n  if( zDoc==0 ){\n    if( sqlite3_column_type(pCsr->pStmt, iCol)!=SQLITE_NULL ){\n      return SQLITE_NOMEM;\n    }\n    return SQLITE_OK;\n  }\n  nDoc = sqlite3_column_bytes(pCsr->pStmt, iCol);\n\n  /* Open a token cursor on the document. */\n  pMod = (sqlite3_tokenizer_module *)pTab->pTokenizer->pModule;\n  rc = pMod->xOpen(pTab->pTokenizer, zDoc, nDoc, &pC);\n  if( rc!=SQLITE_OK ){\n    return rc;\n  }\n  pC->pTokenizer = pTab->pTokenizer;\n\n  while( rc==SQLITE_OK ){\n    int iBegin;                   /* Offset in zDoc of start of token */\n    int iFin;                     /* Offset in zDoc of end of token */\n    int isHighlight;              /* True for highlighted terms */\n\n    rc = pMod->xNext(pC, &ZDUMMY, &DUMMY1, &iBegin, &iFin, &iCurrent);\n    if( rc!=SQLITE_OK ){\n      if( rc==SQLITE_DONE ){\n        /* Special case - the last token of the snippet is also the last token\n        ** of the column. Append any punctuation that occurred between the end\n        ** of the previous token and the end of the document to the output. \n        ** Then break out of the loop. */\n        rc = fts3StringAppend(pOut, &zDoc[iEnd], -1);\n      }\n      break;\n    }\n    if( iCurrent<iPos ){ continue; }\n\n    if( !isShiftDone ){\n      int n = nDoc - iBegin;\n      rc = fts3SnippetShift(pTab, nSnippet, &zDoc[iBegin], n, &iPos, &hlmask);\n      isShiftDone = 1;\n\n      /* Now that the shift has been done, check if the initial \"...\" are\n      ** required. They are required if (a) this is not the first fragment,\n      ** or (b) this fragment does not begin at position 0 of its column. \n      */\n      if( rc==SQLITE_OK && (iPos>0 || iFragment>0) ){\n        rc = fts3StringAppend(pOut, zEllipsis, -1);\n      }\n      if( rc!=SQLITE_OK || iCurrent<iPos ) continue;\n    }\n\n    if( iCurrent>=(iPos+nSnippet) ){\n      if( isLast ){\n        rc = fts3StringAppend(pOut, zEllipsis, -1);\n      }\n      break;\n    }\n\n    /* Set isHighlight to true if this term should be highlighted. */\n    isHighlight = (hlmask & ((u64)1 << (iCurrent-iPos)))!=0;\n\n    if( iCurrent>iPos ) rc = fts3StringAppend(pOut, &zDoc[iEnd], iBegin-iEnd);\n    if( rc==SQLITE_OK && isHighlight ) rc = fts3StringAppend(pOut, zOpen, -1);\n    if( rc==SQLITE_OK ) rc = fts3StringAppend(pOut, &zDoc[iBegin], iFin-iBegin);\n    if( rc==SQLITE_OK && isHighlight ) rc = fts3StringAppend(pOut, zClose, -1);\n\n    iEnd = iFin;\n  }\n\n  pMod->xClose(pC);\n  return rc;\n}\n\n\n/*\n** This function is used to count the entries in a column-list (a \n** delta-encoded list of term offsets within a single column of a single \n** row). When this function is called, *ppCollist should point to the\n** beginning of the first varint in the column-list (the varint that\n** contains the position of the first matching term in the column data).\n** Before returning, *ppCollist is set to point to the first byte after\n** the last varint in the column-list (either the 0x00 signifying the end\n** of the position-list, or the 0x01 that precedes the column number of\n** the next column in the position-list).\n**\n** The number of elements in the column-list is returned.\n*/\nstatic int fts3ColumnlistCount(char **ppCollist){\n  char *pEnd = *ppCollist;\n  char c = 0;\n  int nEntry = 0;\n\n  /* A column-list is terminated by either a 0x01 or 0x00. */\n  while( 0xFE & (*pEnd | c) ){\n    c = *pEnd++ & 0x80;\n    if( !c ) nEntry++;\n  }\n\n  *ppCollist = pEnd;\n  return nEntry;\n}\n\nstatic void fts3LoadColumnlistCounts(char **pp, u32 *aOut, int isGlobal){\n  char *pCsr = *pp;\n  while( *pCsr ){\n    int nHit;\n    sqlite3_int64 iCol = 0;\n    if( *pCsr==0x01 ){\n      pCsr++;\n      pCsr += sqlite3Fts3GetVarint(pCsr, &iCol);\n    }\n    nHit = fts3ColumnlistCount(&pCsr);\n    assert( nHit>0 );\n    if( isGlobal ){\n      aOut[iCol*3+1]++;\n    }\n    aOut[iCol*3] += nHit;\n  }\n  pCsr++;\n  *pp = pCsr;\n}\n\n/*\n** fts3ExprIterate() callback used to collect the \"global\" matchinfo stats\n** for a single query. \n**\n** fts3ExprIterate() callback to load the 'global' elements of a\n** FTS3_MATCHINFO_HITS matchinfo array. The global stats are those elements \n** of the matchinfo array that are constant for all rows returned by the \n** current query.\n**\n** Argument pCtx is actually a pointer to a struct of type MatchInfo. This\n** function populates Matchinfo.aMatchinfo[] as follows:\n**\n**   for(iCol=0; iCol<nCol; iCol++){\n**     aMatchinfo[3*iPhrase*nCol + 3*iCol + 1] = X;\n**     aMatchinfo[3*iPhrase*nCol + 3*iCol + 2] = Y;\n**   }\n**\n** where X is the number of matches for phrase iPhrase is column iCol of all\n** rows of the table. Y is the number of rows for which column iCol contains\n** at least one instance of phrase iPhrase.\n**\n** If the phrase pExpr consists entirely of deferred tokens, then all X and\n** Y values are set to nDoc, where nDoc is the number of documents in the \n** file system. This is done because the full-text index doclist is required\n** to calculate these values properly, and the full-text index doclist is\n** not available for deferred tokens.\n*/\nstatic int fts3ExprGlobalHitsCb(\n  Fts3Expr *pExpr,                /* Phrase expression node */\n  int iPhrase,                    /* Phrase number (numbered from zero) */\n  void *pCtx                      /* Pointer to MatchInfo structure */\n){\n  MatchInfo *p = (MatchInfo *)pCtx;\n  Fts3Cursor *pCsr = p->pCursor;\n  char *pIter;\n  char *pEnd;\n  char *pFree = 0;\n  u32 *aOut = &p->aMatchinfo[3*iPhrase*p->nCol];\n\n  assert( pExpr->isLoaded );\n  assert( pExpr->eType==FTSQUERY_PHRASE );\n\n  if( pCsr->pDeferred ){\n    Fts3Phrase *pPhrase = pExpr->pPhrase;\n    int ii;\n    for(ii=0; ii<pPhrase->nToken; ii++){\n      if( pPhrase->aToken[ii].bFulltext ) break;\n    }\n    if( ii<pPhrase->nToken ){\n      int nFree = 0;\n      int rc = sqlite3Fts3ExprLoadFtDoclist(pCsr, pExpr, &pFree, &nFree);\n      if( rc!=SQLITE_OK ) return rc;\n      pIter = pFree;\n      pEnd = &pFree[nFree];\n    }else{\n      int iCol;                   /* Column index */\n      for(iCol=0; iCol<p->nCol; iCol++){\n        aOut[iCol*3 + 1] = (u32)p->nDoc;\n        aOut[iCol*3 + 2] = (u32)p->nDoc;\n      }\n      return SQLITE_OK;\n    }\n  }else{\n    pIter = pExpr->aDoclist;\n    pEnd = &pExpr->aDoclist[pExpr->nDoclist];\n  }\n\n  /* Fill in the global hit count matrix row for this phrase. */\n  while( pIter<pEnd ){\n    while( *pIter++ & 0x80 );      /* Skip past docid. */\n    fts3LoadColumnlistCounts(&pIter, &aOut[1], 1);\n  }\n\n  sqlite3_free(pFree);\n  return SQLITE_OK;\n}\n\n/*\n** fts3ExprIterate() callback used to collect the \"local\" part of the\n** FTS3_MATCHINFO_HITS array. The local stats are those elements of the \n** array that are different for each row returned by the query.\n*/\nstatic int fts3ExprLocalHitsCb(\n  Fts3Expr *pExpr,                /* Phrase expression node */\n  int iPhrase,                    /* Phrase number */\n  void *pCtx                      /* Pointer to MatchInfo structure */\n){\n  MatchInfo *p = (MatchInfo *)pCtx;\n\n  if( pExpr->aDoclist ){\n    char *pCsr;\n    int iStart = iPhrase * p->nCol * 3;\n    int i;\n\n    for(i=0; i<p->nCol; i++) p->aMatchinfo[iStart+i*3] = 0;\n\n    pCsr = sqlite3Fts3FindPositions(pExpr, p->pCursor->iPrevId, -1);\n    if( pCsr ){\n      fts3LoadColumnlistCounts(&pCsr, &p->aMatchinfo[iStart], 0);\n    }\n  }\n\n  return SQLITE_OK;\n}\n\nstatic int fts3MatchinfoCheck(\n  Fts3Table *pTab, \n  char cArg,\n  char **pzErr\n){\n  if( (cArg==FTS3_MATCHINFO_NPHRASE)\n   || (cArg==FTS3_MATCHINFO_NCOL)\n   || (cArg==FTS3_MATCHINFO_NDOC && pTab->bHasStat)\n   || (cArg==FTS3_MATCHINFO_AVGLENGTH && pTab->bHasStat)\n   || (cArg==FTS3_MATCHINFO_LENGTH && pTab->bHasDocsize)\n   || (cArg==FTS3_MATCHINFO_LCS)\n   || (cArg==FTS3_MATCHINFO_HITS)\n  ){\n    return SQLITE_OK;\n  }\n  *pzErr = sqlite3_mprintf(\"unrecognized matchinfo request: %c\", cArg);\n  return SQLITE_ERROR;\n}\n\nstatic int fts3MatchinfoSize(MatchInfo *pInfo, char cArg){\n  int nVal;                       /* Number of integers output by cArg */\n\n  switch( cArg ){\n    case FTS3_MATCHINFO_NDOC:\n    case FTS3_MATCHINFO_NPHRASE: \n    case FTS3_MATCHINFO_NCOL: \n      nVal = 1;\n      break;\n\n    case FTS3_MATCHINFO_AVGLENGTH:\n    case FTS3_MATCHINFO_LENGTH:\n    case FTS3_MATCHINFO_LCS:\n      nVal = pInfo->nCol;\n      break;\n\n    default:\n      assert( cArg==FTS3_MATCHINFO_HITS );\n      nVal = pInfo->nCol * pInfo->nPhrase * 3;\n      break;\n  }\n\n  return nVal;\n}\n\nstatic int fts3MatchinfoSelectDoctotal(\n  Fts3Table *pTab,\n  sqlite3_stmt **ppStmt,\n  sqlite3_int64 *pnDoc,\n  const char **paLen\n){\n  sqlite3_stmt *pStmt;\n  const char *a;\n  sqlite3_int64 nDoc;\n\n  if( !*ppStmt ){\n    int rc = sqlite3Fts3SelectDoctotal(pTab, ppStmt);\n    if( rc!=SQLITE_OK ) return rc;\n  }\n  pStmt = *ppStmt;\n  assert( sqlite3_data_count(pStmt)==1 );\n\n  a = sqlite3_column_blob(pStmt, 0);\n  a += sqlite3Fts3GetVarint(a, &nDoc);\n  if( nDoc==0 ) return SQLITE_CORRUPT;\n  *pnDoc = (u32)nDoc;\n\n  if( paLen ) *paLen = a;\n  return SQLITE_OK;\n}\n\n/*\n** An instance of the following structure is used to store state while \n** iterating through a multi-column position-list corresponding to the\n** hits for a single phrase on a single row in order to calculate the\n** values for a matchinfo() FTS3_MATCHINFO_LCS request.\n*/\ntypedef struct LcsIterator LcsIterator;\nstruct LcsIterator {\n  Fts3Expr *pExpr;                /* Pointer to phrase expression */\n  char *pRead;                    /* Cursor used to iterate through aDoclist */\n  int iPosOffset;                 /* Tokens count up to end of this phrase */\n  int iCol;                       /* Current column number */\n  int iPos;                       /* Current position */\n};\n\n/* \n** If LcsIterator.iCol is set to the following value, the iterator has\n** finished iterating through all offsets for all columns.\n*/\n#define LCS_ITERATOR_FINISHED 0x7FFFFFFF;\n\nstatic int fts3MatchinfoLcsCb(\n  Fts3Expr *pExpr,                /* Phrase expression node */\n  int iPhrase,                    /* Phrase number (numbered from zero) */\n  void *pCtx                      /* Pointer to MatchInfo structure */\n){\n  LcsIterator *aIter = (LcsIterator *)pCtx;\n  aIter[iPhrase].pExpr = pExpr;\n  return SQLITE_OK;\n}\n\n/*\n** Advance the iterator passed as an argument to the next position. Return\n** 1 if the iterator is at EOF or if it now points to the start of the\n** position list for the next column.\n*/\nstatic int fts3LcsIteratorAdvance(LcsIterator *pIter){\n  char *pRead = pIter->pRead;\n  sqlite3_int64 iRead;\n  int rc = 0;\n\n  pRead += sqlite3Fts3GetVarint(pRead, &iRead);\n  if( iRead==0 ){\n    pIter->iCol = LCS_ITERATOR_FINISHED;\n    rc = 1;\n  }else{\n    if( iRead==1 ){\n      pRead += sqlite3Fts3GetVarint(pRead, &iRead);\n      pIter->iCol = (int)iRead;\n      pIter->iPos = pIter->iPosOffset;\n      pRead += sqlite3Fts3GetVarint(pRead, &iRead);\n      rc = 1;\n    }\n    pIter->iPos += (int)(iRead-2);\n  }\n\n  pIter->pRead = pRead;\n  return rc;\n}\n  \n/*\n** This function implements the FTS3_MATCHINFO_LCS matchinfo() flag. \n**\n** If the call is successful, the longest-common-substring lengths for each\n** column are written into the first nCol elements of the pInfo->aMatchinfo[] \n** array before returning. SQLITE_OK is returned in this case.\n**\n** Otherwise, if an error occurs, an SQLite error code is returned and the\n** data written to the first nCol elements of pInfo->aMatchinfo[] is \n** undefined.\n*/\nstatic int fts3MatchinfoLcs(Fts3Cursor *pCsr, MatchInfo *pInfo){\n  LcsIterator *aIter;\n  int i;\n  int iCol;\n  int nToken = 0;\n\n  /* Allocate and populate the array of LcsIterator objects. The array\n  ** contains one element for each matchable phrase in the query.\n  **/\n  aIter = sqlite3_malloc(sizeof(LcsIterator) * pCsr->nPhrase);\n  if( !aIter ) return SQLITE_NOMEM;\n  memset(aIter, 0, sizeof(LcsIterator) * pCsr->nPhrase);\n  (void)fts3ExprIterate(pCsr->pExpr, fts3MatchinfoLcsCb, (void*)aIter);\n  for(i=0; i<pInfo->nPhrase; i++){\n    LcsIterator *pIter = &aIter[i];\n    nToken -= pIter->pExpr->pPhrase->nToken;\n    pIter->iPosOffset = nToken;\n    pIter->pRead = sqlite3Fts3FindPositions(pIter->pExpr, pCsr->iPrevId, -1);\n    if( pIter->pRead ){\n      pIter->iPos = pIter->iPosOffset;\n      fts3LcsIteratorAdvance(&aIter[i]);\n    }else{\n      pIter->iCol = LCS_ITERATOR_FINISHED;\n    }\n  }\n\n  for(iCol=0; iCol<pInfo->nCol; iCol++){\n    int nLcs = 0;                 /* LCS value for this column */\n    int nLive = 0;                /* Number of iterators in aIter not at EOF */\n\n    /* Loop through the iterators in aIter[]. Set nLive to the number of\n    ** iterators that point to a position-list corresponding to column iCol.\n    */\n    for(i=0; i<pInfo->nPhrase; i++){\n      assert( aIter[i].iCol>=iCol );\n      if( aIter[i].iCol==iCol ) nLive++;\n    }\n\n    /* The following loop runs until all iterators in aIter[] have finished\n    ** iterating through positions in column iCol. Exactly one of the \n    ** iterators is advanced each time the body of the loop is run.\n    */\n    while( nLive>0 ){\n      LcsIterator *pAdv = 0;      /* The iterator to advance by one position */\n      int nThisLcs = 0;           /* LCS for the current iterator positions */\n\n      for(i=0; i<pInfo->nPhrase; i++){\n        LcsIterator *pIter = &aIter[i];\n        if( iCol!=pIter->iCol ){  \n          /* This iterator is already at EOF for this column. */\n          nThisLcs = 0;\n        }else{\n          if( pAdv==0 || pIter->iPos<pAdv->iPos ){\n            pAdv = pIter;\n          }\n          if( nThisLcs==0 || pIter->iPos==pIter[-1].iPos ){\n            nThisLcs++;\n          }else{\n            nThisLcs = 1;\n          }\n          if( nThisLcs>nLcs ) nLcs = nThisLcs;\n        }\n      }\n      if( fts3LcsIteratorAdvance(pAdv) ) nLive--;\n    }\n\n    pInfo->aMatchinfo[iCol] = nLcs;\n  }\n\n  sqlite3_free(aIter);\n  return SQLITE_OK;\n}\n\n/*\n** Populate the buffer pInfo->aMatchinfo[] with an array of integers to\n** be returned by the matchinfo() function. Argument zArg contains the \n** format string passed as the second argument to matchinfo (or the\n** default value \"pcx\" if no second argument was specified). The format\n** string has already been validated and the pInfo->aMatchinfo[] array\n** is guaranteed to be large enough for the output.\n**\n** If bGlobal is true, then populate all fields of the matchinfo() output.\n** If it is false, then assume that those fields that do not change between\n** rows (i.e. FTS3_MATCHINFO_NPHRASE, NCOL, NDOC, AVGLENGTH and part of HITS)\n** have already been populated.\n**\n** Return SQLITE_OK if successful, or an SQLite error code if an error \n** occurs. If a value other than SQLITE_OK is returned, the state the\n** pInfo->aMatchinfo[] buffer is left in is undefined.\n*/\nstatic int fts3MatchinfoValues(\n  Fts3Cursor *pCsr,               /* FTS3 cursor object */\n  int bGlobal,                    /* True to grab the global stats */\n  MatchInfo *pInfo,               /* Matchinfo context object */\n  const char *zArg                /* Matchinfo format string */\n){\n  int rc = SQLITE_OK;\n  int i;\n  Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;\n  sqlite3_stmt *pSelect = 0;\n\n  for(i=0; rc==SQLITE_OK && zArg[i]; i++){\n\n    switch( zArg[i] ){\n      case FTS3_MATCHINFO_NPHRASE:\n        if( bGlobal ) pInfo->aMatchinfo[0] = pInfo->nPhrase;\n        break;\n\n      case FTS3_MATCHINFO_NCOL:\n        if( bGlobal ) pInfo->aMatchinfo[0] = pInfo->nCol;\n        break;\n        \n      case FTS3_MATCHINFO_NDOC:\n        if( bGlobal ){\n          sqlite3_int64 nDoc;\n          rc = fts3MatchinfoSelectDoctotal(pTab, &pSelect, &nDoc, 0);\n          pInfo->aMatchinfo[0] = (u32)nDoc;\n        }\n        break;\n\n      case FTS3_MATCHINFO_AVGLENGTH: \n        if( bGlobal ){\n          sqlite3_int64 nDoc;     /* Number of rows in table */\n          const char *a;          /* Aggregate column length array */\n\n          rc = fts3MatchinfoSelectDoctotal(pTab, &pSelect, &nDoc, &a);\n          if( rc==SQLITE_OK ){\n            int iCol;\n            for(iCol=0; iCol<pInfo->nCol; iCol++){\n              u32 iVal;\n              sqlite3_int64 nToken;\n              a += sqlite3Fts3GetVarint(a, &nToken);\n              iVal = (u32)(((u32)(nToken&0xffffffff)+nDoc/2)/nDoc);\n              pInfo->aMatchinfo[iCol] = iVal;\n            }\n          }\n        }\n        break;\n\n      case FTS3_MATCHINFO_LENGTH: {\n        sqlite3_stmt *pSelectDocsize = 0;\n        rc = sqlite3Fts3SelectDocsize(pTab, pCsr->iPrevId, &pSelectDocsize);\n        if( rc==SQLITE_OK ){\n          int iCol;\n          const char *a = sqlite3_column_blob(pSelectDocsize, 0);\n          for(iCol=0; iCol<pInfo->nCol; iCol++){\n            sqlite3_int64 nToken;\n            a += sqlite3Fts3GetVarint(a, &nToken);\n            pInfo->aMatchinfo[iCol] = (u32)nToken;\n          }\n        }\n        sqlite3_reset(pSelectDocsize);\n        break;\n      }\n\n      case FTS3_MATCHINFO_LCS:\n        rc = fts3ExprLoadDoclists(pCsr, 0, 0);\n        if( rc==SQLITE_OK ){\n          rc = fts3MatchinfoLcs(pCsr, pInfo);\n        }\n        break;\n\n      default: {\n        Fts3Expr *pExpr;\n        assert( zArg[i]==FTS3_MATCHINFO_HITS );\n        pExpr = pCsr->pExpr;\n        rc = fts3ExprLoadDoclists(pCsr, 0, 0);\n        if( rc!=SQLITE_OK ) break;\n        if( bGlobal ){\n          if( pCsr->pDeferred ){\n            rc = fts3MatchinfoSelectDoctotal(pTab, &pSelect, &pInfo->nDoc, 0);\n            if( rc!=SQLITE_OK ) break;\n          }\n          rc = fts3ExprIterate(pExpr, fts3ExprGlobalHitsCb,(void*)pInfo);\n          if( rc!=SQLITE_OK ) break;\n        }\n        (void)fts3ExprIterate(pExpr, fts3ExprLocalHitsCb,(void*)pInfo);\n        break;\n      }\n    }\n\n    pInfo->aMatchinfo += fts3MatchinfoSize(pInfo, zArg[i]);\n  }\n\n  sqlite3_reset(pSelect);\n  return rc;\n}\n\n\n/*\n** Populate pCsr->aMatchinfo[] with data for the current row. The \n** 'matchinfo' data is an array of 32-bit unsigned integers (C type u32).\n*/\nstatic int fts3GetMatchinfo(\n  Fts3Cursor *pCsr,               /* FTS3 Cursor object */\n  const char *zArg                /* Second argument to matchinfo() function */\n){\n  MatchInfo sInfo;\n  Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;\n  int rc = SQLITE_OK;\n  int bGlobal = 0;                /* Collect 'global' stats as well as local */\n\n  memset(&sInfo, 0, sizeof(MatchInfo));\n  sInfo.pCursor = pCsr;\n  sInfo.nCol = pTab->nColumn;\n\n  /* If there is cached matchinfo() data, but the format string for the \n  ** cache does not match the format string for this request, discard \n  ** the cached data. */\n  if( pCsr->zMatchinfo && strcmp(pCsr->zMatchinfo, zArg) ){\n    assert( pCsr->aMatchinfo );\n    sqlite3_free(pCsr->aMatchinfo);\n    pCsr->zMatchinfo = 0;\n    pCsr->aMatchinfo = 0;\n  }\n\n  /* If Fts3Cursor.aMatchinfo[] is NULL, then this is the first time the\n  ** matchinfo function has been called for this query. In this case \n  ** allocate the array used to accumulate the matchinfo data and\n  ** initialize those elements that are constant for every row.\n  */\n  if( pCsr->aMatchinfo==0 ){\n    int nMatchinfo = 0;           /* Number of u32 elements in match-info */\n    int nArg;                     /* Bytes in zArg */\n    int i;                        /* Used to iterate through zArg */\n\n    /* Determine the number of phrases in the query */\n    pCsr->nPhrase = fts3ExprPhraseCount(pCsr->pExpr);\n    sInfo.nPhrase = pCsr->nPhrase;\n\n    /* Determine the number of integers in the buffer returned by this call. */\n    for(i=0; zArg[i]; i++){\n      nMatchinfo += fts3MatchinfoSize(&sInfo, zArg[i]);\n    }\n\n    /* Allocate space for Fts3Cursor.aMatchinfo[] and Fts3Cursor.zMatchinfo. */\n    nArg = (int)strlen(zArg);\n    pCsr->aMatchinfo = (u32 *)sqlite3_malloc(sizeof(u32)*nMatchinfo + nArg + 1);\n    if( !pCsr->aMatchinfo ) return SQLITE_NOMEM;\n\n    pCsr->zMatchinfo = (char *)&pCsr->aMatchinfo[nMatchinfo];\n    pCsr->nMatchinfo = nMatchinfo;\n    memcpy(pCsr->zMatchinfo, zArg, nArg+1);\n    memset(pCsr->aMatchinfo, 0, sizeof(u32)*nMatchinfo);\n    pCsr->isMatchinfoNeeded = 1;\n    bGlobal = 1;\n  }\n\n  sInfo.aMatchinfo = pCsr->aMatchinfo;\n  sInfo.nPhrase = pCsr->nPhrase;\n  if( pCsr->isMatchinfoNeeded ){\n    rc = fts3MatchinfoValues(pCsr, bGlobal, &sInfo, zArg);\n    pCsr->isMatchinfoNeeded = 0;\n  }\n\n  return rc;\n}\n\n/*\n** Implementation of snippet() function.\n*/\nSQLITE_PRIVATE void sqlite3Fts3Snippet(\n  sqlite3_context *pCtx,          /* SQLite function call context */\n  Fts3Cursor *pCsr,               /* Cursor object */\n  const char *zStart,             /* Snippet start text - \"<b>\" */\n  const char *zEnd,               /* Snippet end text - \"</b>\" */\n  const char *zEllipsis,          /* Snippet ellipsis text - \"<b>...</b>\" */\n  int iCol,                       /* Extract snippet from this column */\n  int nToken                      /* Approximate number of tokens in snippet */\n){\n  Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;\n  int rc = SQLITE_OK;\n  int i;\n  StrBuffer res = {0, 0, 0};\n\n  /* The returned text includes up to four fragments of text extracted from\n  ** the data in the current row. The first iteration of the for(...) loop\n  ** below attempts to locate a single fragment of text nToken tokens in \n  ** size that contains at least one instance of all phrases in the query\n  ** expression that appear in the current row. If such a fragment of text\n  ** cannot be found, the second iteration of the loop attempts to locate\n  ** a pair of fragments, and so on.\n  */\n  int nSnippet = 0;               /* Number of fragments in this snippet */\n  SnippetFragment aSnippet[4];    /* Maximum of 4 fragments per snippet */\n  int nFToken = -1;               /* Number of tokens in each fragment */\n\n  if( !pCsr->pExpr ){\n    sqlite3_result_text(pCtx, \"\", 0, SQLITE_STATIC);\n    return;\n  }\n\n  for(nSnippet=1; 1; nSnippet++){\n\n    int iSnip;                    /* Loop counter 0..nSnippet-1 */\n    u64 mCovered = 0;             /* Bitmask of phrases covered by snippet */\n    u64 mSeen = 0;                /* Bitmask of phrases seen by BestSnippet() */\n\n    if( nToken>=0 ){\n      nFToken = (nToken+nSnippet-1) / nSnippet;\n    }else{\n      nFToken = -1 * nToken;\n    }\n\n    for(iSnip=0; iSnip<nSnippet; iSnip++){\n      int iBestScore = -1;        /* Best score of columns checked so far */\n      int iRead;                  /* Used to iterate through columns */\n      SnippetFragment *pFragment = &aSnippet[iSnip];\n\n      memset(pFragment, 0, sizeof(*pFragment));\n\n      /* Loop through all columns of the table being considered for snippets.\n      ** If the iCol argument to this function was negative, this means all\n      ** columns of the FTS3 table. Otherwise, only column iCol is considered.\n      */\n      for(iRead=0; iRead<pTab->nColumn; iRead++){\n        SnippetFragment sF = {0, 0, 0, 0};\n        int iS;\n        if( iCol>=0 && iRead!=iCol ) continue;\n\n        /* Find the best snippet of nFToken tokens in column iRead. */\n        rc = fts3BestSnippet(nFToken, pCsr, iRead, mCovered, &mSeen, &sF, &iS);\n        if( rc!=SQLITE_OK ){\n          goto snippet_out;\n        }\n        if( iS>iBestScore ){\n          *pFragment = sF;\n          iBestScore = iS;\n        }\n      }\n\n      mCovered |= pFragment->covered;\n    }\n\n    /* If all query phrases seen by fts3BestSnippet() are present in at least\n    ** one of the nSnippet snippet fragments, break out of the loop.\n    */\n    assert( (mCovered&mSeen)==mCovered );\n    if( mSeen==mCovered || nSnippet==SizeofArray(aSnippet) ) break;\n  }\n\n  assert( nFToken>0 );\n\n  for(i=0; i<nSnippet && rc==SQLITE_OK; i++){\n    rc = fts3SnippetText(pCsr, &aSnippet[i], \n        i, (i==nSnippet-1), nFToken, zStart, zEnd, zEllipsis, &res\n    );\n  }\n\n snippet_out:\n  sqlite3Fts3SegmentsClose(pTab);\n  if( rc!=SQLITE_OK ){\n    sqlite3_result_error_code(pCtx, rc);\n    sqlite3_free(res.z);\n  }else{\n    sqlite3_result_text(pCtx, res.z, -1, sqlite3_free);\n  }\n}\n\n\ntypedef struct TermOffset TermOffset;\ntypedef struct TermOffsetCtx TermOffsetCtx;\n\nstruct TermOffset {\n  char *pList;                    /* Position-list */\n  int iPos;                       /* Position just read from pList */\n  int iOff;                       /* Offset of this term from read positions */\n};\n\nstruct TermOffsetCtx {\n  int iCol;                       /* Column of table to populate aTerm for */\n  int iTerm;\n  sqlite3_int64 iDocid;\n  TermOffset *aTerm;\n};\n\n/*\n** This function is an fts3ExprIterate() callback used by sqlite3Fts3Offsets().\n*/\nstatic int fts3ExprTermOffsetInit(Fts3Expr *pExpr, int iPhrase, void *ctx){\n  TermOffsetCtx *p = (TermOffsetCtx *)ctx;\n  int nTerm;                      /* Number of tokens in phrase */\n  int iTerm;                      /* For looping through nTerm phrase terms */\n  char *pList;                    /* Pointer to position list for phrase */\n  int iPos = 0;                   /* First position in position-list */\n\n  UNUSED_PARAMETER(iPhrase);\n  pList = sqlite3Fts3FindPositions(pExpr, p->iDocid, p->iCol);\n  nTerm = pExpr->pPhrase->nToken;\n  if( pList ){\n    fts3GetDeltaPosition(&pList, &iPos);\n    assert( iPos>=0 );\n  }\n\n  for(iTerm=0; iTerm<nTerm; iTerm++){\n    TermOffset *pT = &p->aTerm[p->iTerm++];\n    pT->iOff = nTerm-iTerm-1;\n    pT->pList = pList;\n    pT->iPos = iPos;\n  }\n\n  return SQLITE_OK;\n}\n\n/*\n** Implementation of offsets() function.\n*/\nSQLITE_PRIVATE void sqlite3Fts3Offsets(\n  sqlite3_context *pCtx,          /* SQLite function call context */\n  Fts3Cursor *pCsr                /* Cursor object */\n){\n  Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;\n  sqlite3_tokenizer_module const *pMod = pTab->pTokenizer->pModule;\n  const char *ZDUMMY;             /* Dummy argument used with xNext() */\n  int NDUMMY;                     /* Dummy argument used with xNext() */\n  int rc;                         /* Return Code */\n  int nToken;                     /* Number of tokens in query */\n  int iCol;                       /* Column currently being processed */\n  StrBuffer res = {0, 0, 0};      /* Result string */\n  TermOffsetCtx sCtx;             /* Context for fts3ExprTermOffsetInit() */\n\n  if( !pCsr->pExpr ){\n    sqlite3_result_text(pCtx, \"\", 0, SQLITE_STATIC);\n    return;\n  }\n\n  memset(&sCtx, 0, sizeof(sCtx));\n  assert( pCsr->isRequireSeek==0 );\n\n  /* Count the number of terms in the query */\n  rc = fts3ExprLoadDoclists(pCsr, 0, &nToken);\n  if( rc!=SQLITE_OK ) goto offsets_out;\n\n  /* Allocate the array of TermOffset iterators. */\n  sCtx.aTerm = (TermOffset *)sqlite3_malloc(sizeof(TermOffset)*nToken);\n  if( 0==sCtx.aTerm ){\n    rc = SQLITE_NOMEM;\n    goto offsets_out;\n  }\n  sCtx.iDocid = pCsr->iPrevId;\n\n  /* Loop through the table columns, appending offset information to \n  ** string-buffer res for each column.\n  */\n  for(iCol=0; iCol<pTab->nColumn; iCol++){\n    sqlite3_tokenizer_cursor *pC; /* Tokenizer cursor */\n    int iStart;\n    int iEnd;\n    int iCurrent;\n    const char *zDoc;\n    int nDoc;\n\n    /* Initialize the contents of sCtx.aTerm[] for column iCol. There is \n    ** no way that this operation can fail, so the return code from\n    ** fts3ExprIterate() can be discarded.\n    */\n    sCtx.iCol = iCol;\n    sCtx.iTerm = 0;\n    (void)fts3ExprIterate(pCsr->pExpr, fts3ExprTermOffsetInit, (void *)&sCtx);\n\n    /* Retreive the text stored in column iCol. If an SQL NULL is stored \n    ** in column iCol, jump immediately to the next iteration of the loop.\n    ** If an OOM occurs while retrieving the data (this can happen if SQLite\n    ** needs to transform the data from utf-16 to utf-8), return SQLITE_NOMEM \n    ** to the caller. \n    */\n    zDoc = (const char *)sqlite3_column_text(pCsr->pStmt, iCol+1);\n    nDoc = sqlite3_column_bytes(pCsr->pStmt, iCol+1);\n    if( zDoc==0 ){\n      if( sqlite3_column_type(pCsr->pStmt, iCol+1)==SQLITE_NULL ){\n        continue;\n      }\n      rc = SQLITE_NOMEM;\n      goto offsets_out;\n    }\n\n    /* Initialize a tokenizer iterator to iterate through column iCol. */\n    rc = pMod->xOpen(pTab->pTokenizer, zDoc, nDoc, &pC);\n    if( rc!=SQLITE_OK ) goto offsets_out;\n    pC->pTokenizer = pTab->pTokenizer;\n\n    rc = pMod->xNext(pC, &ZDUMMY, &NDUMMY, &iStart, &iEnd, &iCurrent);\n    while( rc==SQLITE_OK ){\n      int i;                      /* Used to loop through terms */\n      int iMinPos = 0x7FFFFFFF;   /* Position of next token */\n      TermOffset *pTerm = 0;      /* TermOffset associated with next token */\n\n      for(i=0; i<nToken; i++){\n        TermOffset *pT = &sCtx.aTerm[i];\n        if( pT->pList && (pT->iPos-pT->iOff)<iMinPos ){\n          iMinPos = pT->iPos-pT->iOff;\n          pTerm = pT;\n        }\n      }\n\n      if( !pTerm ){\n        /* All offsets for this column have been gathered. */\n        break;\n      }else{\n        assert( iCurrent<=iMinPos );\n        if( 0==(0xFE&*pTerm->pList) ){\n          pTerm->pList = 0;\n        }else{\n          fts3GetDeltaPosition(&pTerm->pList, &pTerm->iPos);\n        }\n        while( rc==SQLITE_OK && iCurrent<iMinPos ){\n          rc = pMod->xNext(pC, &ZDUMMY, &NDUMMY, &iStart, &iEnd, &iCurrent);\n        }\n        if( rc==SQLITE_OK ){\n          char aBuffer[64];\n          sqlite3_snprintf(sizeof(aBuffer), aBuffer, \n              \"%d %d %d %d \", iCol, pTerm-sCtx.aTerm, iStart, iEnd-iStart\n          );\n          rc = fts3StringAppend(&res, aBuffer, -1);\n        }else if( rc==SQLITE_DONE ){\n          rc = SQLITE_CORRUPT;\n        }\n      }\n    }\n    if( rc==SQLITE_DONE ){\n      rc = SQLITE_OK;\n    }\n\n    pMod->xClose(pC);\n    if( rc!=SQLITE_OK ) goto offsets_out;\n  }\n\n offsets_out:\n  sqlite3_free(sCtx.aTerm);\n  assert( rc!=SQLITE_DONE );\n  sqlite3Fts3SegmentsClose(pTab);\n  if( rc!=SQLITE_OK ){\n    sqlite3_result_error_code(pCtx,  rc);\n    sqlite3_free(res.z);\n  }else{\n    sqlite3_result_text(pCtx, res.z, res.n-1, sqlite3_free);\n  }\n  return;\n}\n\n/*\n** Implementation of matchinfo() function.\n*/\nSQLITE_PRIVATE void sqlite3Fts3Matchinfo(\n  sqlite3_context *pContext,      /* Function call context */\n  Fts3Cursor *pCsr,               /* FTS3 table cursor */\n  const char *zArg                /* Second arg to matchinfo() function */\n){\n  Fts3Table *pTab = (Fts3Table *)pCsr->base.pVtab;\n  int rc;\n  int i;\n  const char *zFormat;\n\n  if( zArg ){\n    for(i=0; zArg[i]; i++){\n      char *zErr = 0;\n      if( fts3MatchinfoCheck(pTab, zArg[i], &zErr) ){\n        sqlite3_result_error(pContext, zErr, -1);\n        sqlite3_free(zErr);\n        return;\n      }\n    }\n    zFormat = zArg;\n  }else{\n    zFormat = FTS3_MATCHINFO_DEFAULT;\n  }\n\n  if( !pCsr->pExpr ){\n    sqlite3_result_blob(pContext, \"\", 0, SQLITE_STATIC);\n    return;\n  }\n\n  /* Retrieve matchinfo() data. */\n  rc = fts3GetMatchinfo(pCsr, zFormat);\n  sqlite3Fts3SegmentsClose(pTab);\n\n  if( rc!=SQLITE_OK ){\n    sqlite3_result_error_code(pContext, rc);\n  }else{\n    int n = pCsr->nMatchinfo * sizeof(u32);\n    sqlite3_result_blob(pContext, pCsr->aMatchinfo, n, SQLITE_TRANSIENT);\n  }\n}\n\n#endif\n\n/************** End of fts3_snippet.c ****************************************/\n/************** Begin file rtree.c *******************************************/\n/*\n** 2001 September 15\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file contains code for implementations of the r-tree and r*-tree\n** algorithms packaged as an SQLite virtual table module.\n*/\n\n/*\n** Database Format of R-Tree Tables\n** --------------------------------\n**\n** The data structure for a single virtual r-tree table is stored in three \n** native SQLite tables declared as follows. In each case, the '%' character\n** in the table name is replaced with the user-supplied name of the r-tree\n** table.\n**\n**   CREATE TABLE %_node(nodeno INTEGER PRIMARY KEY, data BLOB)\n**   CREATE TABLE %_parent(nodeno INTEGER PRIMARY KEY, parentnode INTEGER)\n**   CREATE TABLE %_rowid(rowid INTEGER PRIMARY KEY, nodeno INTEGER)\n**\n** The data for each node of the r-tree structure is stored in the %_node\n** table. For each node that is not the root node of the r-tree, there is\n** an entry in the %_parent table associating the node with its parent.\n** And for each row of data in the table, there is an entry in the %_rowid\n** table that maps from the entries rowid to the id of the node that it\n** is stored on.\n**\n** The root node of an r-tree always exists, even if the r-tree table is\n** empty. The nodeno of the root node is always 1. All other nodes in the\n** table must be the same size as the root node. The content of each node\n** is formatted as follows:\n**\n**   1. If the node is the root node (node 1), then the first 2 bytes\n**      of the node contain the tree depth as a big-endian integer.\n**      For non-root nodes, the first 2 bytes are left unused.\n**\n**   2. The next 2 bytes contain the number of entries currently \n**      stored in the node.\n**\n**   3. The remainder of the node contains the node entries. Each entry\n**      consists of a single 8-byte integer followed by an even number\n**      of 4-byte coordinates. For leaf nodes the integer is the rowid\n**      of a record. For internal nodes it is the node number of a\n**      child page.\n*/\n\n#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_RTREE)\n\n/*\n** This file contains an implementation of a couple of different variants\n** of the r-tree algorithm. See the README file for further details. The \n** same data-structure is used for all, but the algorithms for insert and\n** delete operations vary. The variants used are selected at compile time \n** by defining the following symbols:\n*/\n\n/* Either, both or none of the following may be set to activate \n** r*tree variant algorithms.\n*/\n#define VARIANT_RSTARTREE_CHOOSESUBTREE 0\n#define VARIANT_RSTARTREE_REINSERT      1\n\n/* \n** Exactly one of the following must be set to 1.\n*/\n#define VARIANT_GUTTMAN_QUADRATIC_SPLIT 0\n#define VARIANT_GUTTMAN_LINEAR_SPLIT    0\n#define VARIANT_RSTARTREE_SPLIT         1\n\n#define VARIANT_GUTTMAN_SPLIT \\\n        (VARIANT_GUTTMAN_LINEAR_SPLIT||VARIANT_GUTTMAN_QUADRATIC_SPLIT)\n\n#if VARIANT_GUTTMAN_QUADRATIC_SPLIT\n  #define PickNext QuadraticPickNext\n  #define PickSeeds QuadraticPickSeeds\n  #define AssignCells splitNodeGuttman\n#endif\n#if VARIANT_GUTTMAN_LINEAR_SPLIT\n  #define PickNext LinearPickNext\n  #define PickSeeds LinearPickSeeds\n  #define AssignCells splitNodeGuttman\n#endif\n#if VARIANT_RSTARTREE_SPLIT\n  #define AssignCells splitNodeStartree\n#endif\n\n#if !defined(NDEBUG) && !defined(SQLITE_DEBUG) \n# define NDEBUG 1\n#endif\n\n#ifndef SQLITE_CORE\n  SQLITE_EXTENSION_INIT1\n#else\n#endif\n\n\n#ifndef SQLITE_AMALGAMATION\n#include \"sqlite3rtree.h\"\ntypedef sqlite3_int64 i64;\ntypedef unsigned char u8;\ntypedef unsigned int u32;\n#endif\n\n/*  The following macro is used to suppress compiler warnings.\n*/\n#ifndef UNUSED_PARAMETER\n# define UNUSED_PARAMETER(x) (void)(x)\n#endif\n\ntypedef struct Rtree Rtree;\ntypedef struct RtreeCursor RtreeCursor;\ntypedef struct RtreeNode RtreeNode;\ntypedef struct RtreeCell RtreeCell;\ntypedef struct RtreeConstraint RtreeConstraint;\ntypedef struct RtreeMatchArg RtreeMatchArg;\ntypedef struct RtreeGeomCallback RtreeGeomCallback;\ntypedef union RtreeCoord RtreeCoord;\n\n/* The rtree may have between 1 and RTREE_MAX_DIMENSIONS dimensions. */\n#define RTREE_MAX_DIMENSIONS 5\n\n/* Size of hash table Rtree.aHash. This hash table is not expected to\n** ever contain very many entries, so a fixed number of buckets is \n** used.\n*/\n#define HASHSIZE 128\n\n/* \n** An rtree virtual-table object.\n*/\nstruct Rtree {\n  sqlite3_vtab base;\n  sqlite3 *db;                /* Host database connection */\n  int iNodeSize;              /* Size in bytes of each node in the node table */\n  int nDim;                   /* Number of dimensions */\n  int nBytesPerCell;          /* Bytes consumed per cell */\n  int iDepth;                 /* Current depth of the r-tree structure */\n  char *zDb;                  /* Name of database containing r-tree table */\n  char *zName;                /* Name of r-tree table */ \n  RtreeNode *aHash[HASHSIZE]; /* Hash table of in-memory nodes. */ \n  int nBusy;                  /* Current number of users of this structure */\n\n  /* List of nodes removed during a CondenseTree operation. List is\n  ** linked together via the pointer normally used for hash chains -\n  ** RtreeNode.pNext. RtreeNode.iNode stores the depth of the sub-tree \n  ** headed by the node (leaf nodes have RtreeNode.iNode==0).\n  */\n  RtreeNode *pDeleted;\n  int iReinsertHeight;        /* Height of sub-trees Reinsert() has run on */\n\n  /* Statements to read/write/delete a record from xxx_node */\n  sqlite3_stmt *pReadNode;\n  sqlite3_stmt *pWriteNode;\n  sqlite3_stmt *pDeleteNode;\n\n  /* Statements to read/write/delete a record from xxx_rowid */\n  sqlite3_stmt *pReadRowid;\n  sqlite3_stmt *pWriteRowid;\n  sqlite3_stmt *pDeleteRowid;\n\n  /* Statements to read/write/delete a record from xxx_parent */\n  sqlite3_stmt *pReadParent;\n  sqlite3_stmt *pWriteParent;\n  sqlite3_stmt *pDeleteParent;\n\n  int eCoordType;\n};\n\n/* Possible values for eCoordType: */\n#define RTREE_COORD_REAL32 0\n#define RTREE_COORD_INT32  1\n\n/*\n** The minimum number of cells allowed for a node is a third of the \n** maximum. In Gutman's notation:\n**\n**     m = M/3\n**\n** If an R*-tree \"Reinsert\" operation is required, the same number of\n** cells are removed from the overfull node and reinserted into the tree.\n*/\n#define RTREE_MINCELLS(p) ((((p)->iNodeSize-4)/(p)->nBytesPerCell)/3)\n#define RTREE_REINSERT(p) RTREE_MINCELLS(p)\n#define RTREE_MAXCELLS 51\n\n/*\n** The smallest possible node-size is (512-64)==448 bytes. And the largest\n** supported cell size is 48 bytes (8 byte rowid + ten 4 byte coordinates).\n** Therefore all non-root nodes must contain at least 3 entries. Since \n** 2^40 is greater than 2^64, an r-tree structure always has a depth of\n** 40 or less.\n*/\n#define RTREE_MAX_DEPTH 40\n\n/* \n** An rtree cursor object.\n*/\nstruct RtreeCursor {\n  sqlite3_vtab_cursor base;\n  RtreeNode *pNode;                 /* Node cursor is currently pointing at */\n  int iCell;                        /* Index of current cell in pNode */\n  int iStrategy;                    /* Copy of idxNum search parameter */\n  int nConstraint;                  /* Number of entries in aConstraint */\n  RtreeConstraint *aConstraint;     /* Search constraints. */\n};\n\nunion RtreeCoord {\n  float f;\n  int i;\n};\n\n/*\n** The argument is an RtreeCoord. Return the value stored within the RtreeCoord\n** formatted as a double. This macro assumes that local variable pRtree points\n** to the Rtree structure associated with the RtreeCoord.\n*/\n#define DCOORD(coord) (                           \\\n  (pRtree->eCoordType==RTREE_COORD_REAL32) ?      \\\n    ((double)coord.f) :                           \\\n    ((double)coord.i)                             \\\n)\n\n/*\n** A search constraint.\n*/\nstruct RtreeConstraint {\n  int iCoord;                     /* Index of constrained coordinate */\n  int op;                         /* Constraining operation */\n  double rValue;                  /* Constraint value. */\n  int (*xGeom)(sqlite3_rtree_geometry *, int, double *, int *);\n  sqlite3_rtree_geometry *pGeom;  /* Constraint callback argument for a MATCH */\n};\n\n/* Possible values for RtreeConstraint.op */\n#define RTREE_EQ    0x41\n#define RTREE_LE    0x42\n#define RTREE_LT    0x43\n#define RTREE_GE    0x44\n#define RTREE_GT    0x45\n#define RTREE_MATCH 0x46\n\n/* \n** An rtree structure node.\n*/\nstruct RtreeNode {\n  RtreeNode *pParent;               /* Parent node */\n  i64 iNode;\n  int nRef;\n  int isDirty;\n  u8 *zData;\n  RtreeNode *pNext;                 /* Next node in this hash chain */\n};\n#define NCELL(pNode) readInt16(&(pNode)->zData[2])\n\n/* \n** Structure to store a deserialized rtree record.\n*/\nstruct RtreeCell {\n  i64 iRowid;\n  RtreeCoord aCoord[RTREE_MAX_DIMENSIONS*2];\n};\n\n\n/*\n** Value for the first field of every RtreeMatchArg object. The MATCH\n** operator tests that the first field of a blob operand matches this\n** value to avoid operating on invalid blobs (which could cause a segfault).\n*/\n#define RTREE_GEOMETRY_MAGIC 0x891245AB\n\n/*\n** An instance of this structure must be supplied as a blob argument to\n** the right-hand-side of an SQL MATCH operator used to constrain an\n** r-tree query.\n*/\nstruct RtreeMatchArg {\n  u32 magic;                      /* Always RTREE_GEOMETRY_MAGIC */\n  int (*xGeom)(sqlite3_rtree_geometry *, int, double *, int *);\n  void *pContext;\n  int nParam;\n  double aParam[1];\n};\n\n/*\n** When a geometry callback is created (see sqlite3_rtree_geometry_callback),\n** a single instance of the following structure is allocated. It is used\n** as the context for the user-function created by by s_r_g_c(). The object\n** is eventually deleted by the destructor mechanism provided by\n** sqlite3_create_function_v2() (which is called by s_r_g_c() to create\n** the geometry callback function).\n*/\nstruct RtreeGeomCallback {\n  int (*xGeom)(sqlite3_rtree_geometry *, int, double *, int *);\n  void *pContext;\n};\n\n#ifndef MAX\n# define MAX(x,y) ((x) < (y) ? (y) : (x))\n#endif\n#ifndef MIN\n# define MIN(x,y) ((x) > (y) ? (y) : (x))\n#endif\n\n/*\n** Functions to deserialize a 16 bit integer, 32 bit real number and\n** 64 bit integer. The deserialized value is returned.\n*/\nstatic int readInt16(u8 *p){\n  return (p[0]<<8) + p[1];\n}\nstatic void readCoord(u8 *p, RtreeCoord *pCoord){\n  u32 i = (\n    (((u32)p[0]) << 24) + \n    (((u32)p[1]) << 16) + \n    (((u32)p[2]) <<  8) + \n    (((u32)p[3]) <<  0)\n  );\n  *(u32 *)pCoord = i;\n}\nstatic i64 readInt64(u8 *p){\n  return (\n    (((i64)p[0]) << 56) + \n    (((i64)p[1]) << 48) + \n    (((i64)p[2]) << 40) + \n    (((i64)p[3]) << 32) + \n    (((i64)p[4]) << 24) + \n    (((i64)p[5]) << 16) + \n    (((i64)p[6]) <<  8) + \n    (((i64)p[7]) <<  0)\n  );\n}\n\n/*\n** Functions to serialize a 16 bit integer, 32 bit real number and\n** 64 bit integer. The value returned is the number of bytes written\n** to the argument buffer (always 2, 4 and 8 respectively).\n*/\nstatic int writeInt16(u8 *p, int i){\n  p[0] = (i>> 8)&0xFF;\n  p[1] = (i>> 0)&0xFF;\n  return 2;\n}\nstatic int writeCoord(u8 *p, RtreeCoord *pCoord){\n  u32 i;\n  assert( sizeof(RtreeCoord)==4 );\n  assert( sizeof(u32)==4 );\n  i = *(u32 *)pCoord;\n  p[0] = (i>>24)&0xFF;\n  p[1] = (i>>16)&0xFF;\n  p[2] = (i>> 8)&0xFF;\n  p[3] = (i>> 0)&0xFF;\n  return 4;\n}\nstatic int writeInt64(u8 *p, i64 i){\n  p[0] = (i>>56)&0xFF;\n  p[1] = (i>>48)&0xFF;\n  p[2] = (i>>40)&0xFF;\n  p[3] = (i>>32)&0xFF;\n  p[4] = (i>>24)&0xFF;\n  p[5] = (i>>16)&0xFF;\n  p[6] = (i>> 8)&0xFF;\n  p[7] = (i>> 0)&0xFF;\n  return 8;\n}\n\n/*\n** Increment the reference count of node p.\n*/\nstatic void nodeReference(RtreeNode *p){\n  if( p ){\n    p->nRef++;\n  }\n}\n\n/*\n** Clear the content of node p (set all bytes to 0x00).\n*/\nstatic void nodeZero(Rtree *pRtree, RtreeNode *p){\n  memset(&p->zData[2], 0, pRtree->iNodeSize-2);\n  p->isDirty = 1;\n}\n\n/*\n** Given a node number iNode, return the corresponding key to use\n** in the Rtree.aHash table.\n*/\nstatic int nodeHash(i64 iNode){\n  return (\n    (iNode>>56) ^ (iNode>>48) ^ (iNode>>40) ^ (iNode>>32) ^ \n    (iNode>>24) ^ (iNode>>16) ^ (iNode>> 8) ^ (iNode>> 0)\n  ) % HASHSIZE;\n}\n\n/*\n** Search the node hash table for node iNode. If found, return a pointer\n** to it. Otherwise, return 0.\n*/\nstatic RtreeNode *nodeHashLookup(Rtree *pRtree, i64 iNode){\n  RtreeNode *p;\n  for(p=pRtree->aHash[nodeHash(iNode)]; p && p->iNode!=iNode; p=p->pNext);\n  return p;\n}\n\n/*\n** Add node pNode to the node hash table.\n*/\nstatic void nodeHashInsert(Rtree *pRtree, RtreeNode *pNode){\n  int iHash;\n  assert( pNode->pNext==0 );\n  iHash = nodeHash(pNode->iNode);\n  pNode->pNext = pRtree->aHash[iHash];\n  pRtree->aHash[iHash] = pNode;\n}\n\n/*\n** Remove node pNode from the node hash table.\n*/\nstatic void nodeHashDelete(Rtree *pRtree, RtreeNode *pNode){\n  RtreeNode **pp;\n  if( pNode->iNode!=0 ){\n    pp = &pRtree->aHash[nodeHash(pNode->iNode)];\n    for( ; (*pp)!=pNode; pp = &(*pp)->pNext){ assert(*pp); }\n    *pp = pNode->pNext;\n    pNode->pNext = 0;\n  }\n}\n\n/*\n** Allocate and return new r-tree node. Initially, (RtreeNode.iNode==0),\n** indicating that node has not yet been assigned a node number. It is\n** assigned a node number when nodeWrite() is called to write the\n** node contents out to the database.\n*/\nstatic RtreeNode *nodeNew(Rtree *pRtree, RtreeNode *pParent){\n  RtreeNode *pNode;\n  pNode = (RtreeNode *)sqlite3_malloc(sizeof(RtreeNode) + pRtree->iNodeSize);\n  if( pNode ){\n    memset(pNode, 0, sizeof(RtreeNode) + pRtree->iNodeSize);\n    pNode->zData = (u8 *)&pNode[1];\n    pNode->nRef = 1;\n    pNode->pParent = pParent;\n    pNode->isDirty = 1;\n    nodeReference(pParent);\n  }\n  return pNode;\n}\n\n/*\n** Obtain a reference to an r-tree node.\n*/\nstatic int\nnodeAcquire(\n  Rtree *pRtree,             /* R-tree structure */\n  i64 iNode,                 /* Node number to load */\n  RtreeNode *pParent,        /* Either the parent node or NULL */\n  RtreeNode **ppNode         /* OUT: Acquired node */\n){\n  int rc;\n  int rc2 = SQLITE_OK;\n  RtreeNode *pNode;\n\n  /* Check if the requested node is already in the hash table. If so,\n  ** increase its reference count and return it.\n  */\n  if( (pNode = nodeHashLookup(pRtree, iNode)) ){\n    assert( !pParent || !pNode->pParent || pNode->pParent==pParent );\n    if( pParent && !pNode->pParent ){\n      nodeReference(pParent);\n      pNode->pParent = pParent;\n    }\n    pNode->nRef++;\n    *ppNode = pNode;\n    return SQLITE_OK;\n  }\n\n  sqlite3_bind_int64(pRtree->pReadNode, 1, iNode);\n  rc = sqlite3_step(pRtree->pReadNode);\n  if( rc==SQLITE_ROW ){\n    const u8 *zBlob = sqlite3_column_blob(pRtree->pReadNode, 0);\n    if( pRtree->iNodeSize==sqlite3_column_bytes(pRtree->pReadNode, 0) ){\n      pNode = (RtreeNode *)sqlite3_malloc(sizeof(RtreeNode)+pRtree->iNodeSize);\n      if( !pNode ){\n        rc2 = SQLITE_NOMEM;\n      }else{\n        pNode->pParent = pParent;\n        pNode->zData = (u8 *)&pNode[1];\n        pNode->nRef = 1;\n        pNode->iNode = iNode;\n        pNode->isDirty = 0;\n        pNode->pNext = 0;\n        memcpy(pNode->zData, zBlob, pRtree->iNodeSize);\n        nodeReference(pParent);\n      }\n    }\n  }\n  rc = sqlite3_reset(pRtree->pReadNode);\n  if( rc==SQLITE_OK ) rc = rc2;\n\n  /* If the root node was just loaded, set pRtree->iDepth to the height\n  ** of the r-tree structure. A height of zero means all data is stored on\n  ** the root node. A height of one means the children of the root node\n  ** are the leaves, and so on. If the depth as specified on the root node\n  ** is greater than RTREE_MAX_DEPTH, the r-tree structure must be corrupt.\n  */\n  if( pNode && iNode==1 ){\n    pRtree->iDepth = readInt16(pNode->zData);\n    if( pRtree->iDepth>RTREE_MAX_DEPTH ){\n      rc = SQLITE_CORRUPT;\n    }\n  }\n\n  /* If no error has occurred so far, check if the \"number of entries\"\n  ** field on the node is too large. If so, set the return code to \n  ** SQLITE_CORRUPT.\n  */\n  if( pNode && rc==SQLITE_OK ){\n    if( NCELL(pNode)>((pRtree->iNodeSize-4)/pRtree->nBytesPerCell) ){\n      rc = SQLITE_CORRUPT;\n    }\n  }\n\n  if( rc==SQLITE_OK ){\n    if( pNode!=0 ){\n      nodeHashInsert(pRtree, pNode);\n    }else{\n      rc = SQLITE_CORRUPT;\n    }\n    *ppNode = pNode;\n  }else{\n    sqlite3_free(pNode);\n    *ppNode = 0;\n  }\n\n  return rc;\n}\n\n/*\n** Overwrite cell iCell of node pNode with the contents of pCell.\n*/\nstatic void nodeOverwriteCell(\n  Rtree *pRtree, \n  RtreeNode *pNode,  \n  RtreeCell *pCell, \n  int iCell\n){\n  int ii;\n  u8 *p = &pNode->zData[4 + pRtree->nBytesPerCell*iCell];\n  p += writeInt64(p, pCell->iRowid);\n  for(ii=0; ii<(pRtree->nDim*2); ii++){\n    p += writeCoord(p, &pCell->aCoord[ii]);\n  }\n  pNode->isDirty = 1;\n}\n\n/*\n** Remove cell the cell with index iCell from node pNode.\n*/\nstatic void nodeDeleteCell(Rtree *pRtree, RtreeNode *pNode, int iCell){\n  u8 *pDst = &pNode->zData[4 + pRtree->nBytesPerCell*iCell];\n  u8 *pSrc = &pDst[pRtree->nBytesPerCell];\n  int nByte = (NCELL(pNode) - iCell - 1) * pRtree->nBytesPerCell;\n  memmove(pDst, pSrc, nByte);\n  writeInt16(&pNode->zData[2], NCELL(pNode)-1);\n  pNode->isDirty = 1;\n}\n\n/*\n** Insert the contents of cell pCell into node pNode. If the insert\n** is successful, return SQLITE_OK.\n**\n** If there is not enough free space in pNode, return SQLITE_FULL.\n*/\nstatic int\nnodeInsertCell(\n  Rtree *pRtree, \n  RtreeNode *pNode, \n  RtreeCell *pCell \n){\n  int nCell;                    /* Current number of cells in pNode */\n  int nMaxCell;                 /* Maximum number of cells for pNode */\n\n  nMaxCell = (pRtree->iNodeSize-4)/pRtree->nBytesPerCell;\n  nCell = NCELL(pNode);\n\n  assert( nCell<=nMaxCell );\n  if( nCell<nMaxCell ){\n    nodeOverwriteCell(pRtree, pNode, pCell, nCell);\n    writeInt16(&pNode->zData[2], nCell+1);\n    pNode->isDirty = 1;\n  }\n\n  return (nCell==nMaxCell);\n}\n\n/*\n** If the node is dirty, write it out to the database.\n*/\nstatic int\nnodeWrite(Rtree *pRtree, RtreeNode *pNode){\n  int rc = SQLITE_OK;\n  if( pNode->isDirty ){\n    sqlite3_stmt *p = pRtree->pWriteNode;\n    if( pNode->iNode ){\n      sqlite3_bind_int64(p, 1, pNode->iNode);\n    }else{\n      sqlite3_bind_null(p, 1);\n    }\n    sqlite3_bind_blob(p, 2, pNode->zData, pRtree->iNodeSize, SQLITE_STATIC);\n    sqlite3_step(p);\n    pNode->isDirty = 0;\n    rc = sqlite3_reset(p);\n    if( pNode->iNode==0 && rc==SQLITE_OK ){\n      pNode->iNode = sqlite3_last_insert_rowid(pRtree->db);\n      nodeHashInsert(pRtree, pNode);\n    }\n  }\n  return rc;\n}\n\n/*\n** Release a reference to a node. If the node is dirty and the reference\n** count drops to zero, the node data is written to the database.\n*/\nstatic int\nnodeRelease(Rtree *pRtree, RtreeNode *pNode){\n  int rc = SQLITE_OK;\n  if( pNode ){\n    assert( pNode->nRef>0 );\n    pNode->nRef--;\n    if( pNode->nRef==0 ){\n      if( pNode->iNode==1 ){\n        pRtree->iDepth = -1;\n      }\n      if( pNode->pParent ){\n        rc = nodeRelease(pRtree, pNode->pParent);\n      }\n      if( rc==SQLITE_OK ){\n        rc = nodeWrite(pRtree, pNode);\n      }\n      nodeHashDelete(pRtree, pNode);\n      sqlite3_free(pNode);\n    }\n  }\n  return rc;\n}\n\n/*\n** Return the 64-bit integer value associated with cell iCell of\n** node pNode. If pNode is a leaf node, this is a rowid. If it is\n** an internal node, then the 64-bit integer is a child page number.\n*/\nstatic i64 nodeGetRowid(\n  Rtree *pRtree, \n  RtreeNode *pNode, \n  int iCell\n){\n  assert( iCell<NCELL(pNode) );\n  return readInt64(&pNode->zData[4 + pRtree->nBytesPerCell*iCell]);\n}\n\n/*\n** Return coordinate iCoord from cell iCell in node pNode.\n*/\nstatic void nodeGetCoord(\n  Rtree *pRtree, \n  RtreeNode *pNode, \n  int iCell,\n  int iCoord,\n  RtreeCoord *pCoord           /* Space to write result to */\n){\n  readCoord(&pNode->zData[12 + pRtree->nBytesPerCell*iCell + 4*iCoord], pCoord);\n}\n\n/*\n** Deserialize cell iCell of node pNode. Populate the structure pointed\n** to by pCell with the results.\n*/\nstatic void nodeGetCell(\n  Rtree *pRtree, \n  RtreeNode *pNode, \n  int iCell,\n  RtreeCell *pCell\n){\n  int ii;\n  pCell->iRowid = nodeGetRowid(pRtree, pNode, iCell);\n  for(ii=0; ii<pRtree->nDim*2; ii++){\n    nodeGetCoord(pRtree, pNode, iCell, ii, &pCell->aCoord[ii]);\n  }\n}\n\n\n/* Forward declaration for the function that does the work of\n** the virtual table module xCreate() and xConnect() methods.\n*/\nstatic int rtreeInit(\n  sqlite3 *, void *, int, const char *const*, sqlite3_vtab **, char **, int\n);\n\n/* \n** Rtree virtual table module xCreate method.\n*/\nstatic int rtreeCreate(\n  sqlite3 *db,\n  void *pAux,\n  int argc, const char *const*argv,\n  sqlite3_vtab **ppVtab,\n  char **pzErr\n){\n  return rtreeInit(db, pAux, argc, argv, ppVtab, pzErr, 1);\n}\n\n/* \n** Rtree virtual table module xConnect method.\n*/\nstatic int rtreeConnect(\n  sqlite3 *db,\n  void *pAux,\n  int argc, const char *const*argv,\n  sqlite3_vtab **ppVtab,\n  char **pzErr\n){\n  return rtreeInit(db, pAux, argc, argv, ppVtab, pzErr, 0);\n}\n\n/*\n** Increment the r-tree reference count.\n*/\nstatic void rtreeReference(Rtree *pRtree){\n  pRtree->nBusy++;\n}\n\n/*\n** Decrement the r-tree reference count. When the reference count reaches\n** zero the structure is deleted.\n*/\nstatic void rtreeRelease(Rtree *pRtree){\n  pRtree->nBusy--;\n  if( pRtree->nBusy==0 ){\n    sqlite3_finalize(pRtree->pReadNode);\n    sqlite3_finalize(pRtree->pWriteNode);\n    sqlite3_finalize(pRtree->pDeleteNode);\n    sqlite3_finalize(pRtree->pReadRowid);\n    sqlite3_finalize(pRtree->pWriteRowid);\n    sqlite3_finalize(pRtree->pDeleteRowid);\n    sqlite3_finalize(pRtree->pReadParent);\n    sqlite3_finalize(pRtree->pWriteParent);\n    sqlite3_finalize(pRtree->pDeleteParent);\n    sqlite3_free(pRtree);\n  }\n}\n\n/* \n** Rtree virtual table module xDisconnect method.\n*/\nstatic int rtreeDisconnect(sqlite3_vtab *pVtab){\n  rtreeRelease((Rtree *)pVtab);\n  return SQLITE_OK;\n}\n\n/* \n** Rtree virtual table module xDestroy method.\n*/\nstatic int rtreeDestroy(sqlite3_vtab *pVtab){\n  Rtree *pRtree = (Rtree *)pVtab;\n  int rc;\n  char *zCreate = sqlite3_mprintf(\n    \"DROP TABLE '%q'.'%q_node';\"\n    \"DROP TABLE '%q'.'%q_rowid';\"\n    \"DROP TABLE '%q'.'%q_parent';\",\n    pRtree->zDb, pRtree->zName, \n    pRtree->zDb, pRtree->zName,\n    pRtree->zDb, pRtree->zName\n  );\n  if( !zCreate ){\n    rc = SQLITE_NOMEM;\n  }else{\n    rc = sqlite3_exec(pRtree->db, zCreate, 0, 0, 0);\n    sqlite3_free(zCreate);\n  }\n  if( rc==SQLITE_OK ){\n    rtreeRelease(pRtree);\n  }\n\n  return rc;\n}\n\n/* \n** Rtree virtual table module xOpen method.\n*/\nstatic int rtreeOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor){\n  int rc = SQLITE_NOMEM;\n  RtreeCursor *pCsr;\n\n  pCsr = (RtreeCursor *)sqlite3_malloc(sizeof(RtreeCursor));\n  if( pCsr ){\n    memset(pCsr, 0, sizeof(RtreeCursor));\n    pCsr->base.pVtab = pVTab;\n    rc = SQLITE_OK;\n  }\n  *ppCursor = (sqlite3_vtab_cursor *)pCsr;\n\n  return rc;\n}\n\n\n/*\n** Free the RtreeCursor.aConstraint[] array and its contents.\n*/\nstatic void freeCursorConstraints(RtreeCursor *pCsr){\n  if( pCsr->aConstraint ){\n    int i;                        /* Used to iterate through constraint array */\n    for(i=0; i<pCsr->nConstraint; i++){\n      sqlite3_rtree_geometry *pGeom = pCsr->aConstraint[i].pGeom;\n      if( pGeom ){\n        if( pGeom->xDelUser ) pGeom->xDelUser(pGeom->pUser);\n        sqlite3_free(pGeom);\n      }\n    }\n    sqlite3_free(pCsr->aConstraint);\n    pCsr->aConstraint = 0;\n  }\n}\n\n/* \n** Rtree virtual table module xClose method.\n*/\nstatic int rtreeClose(sqlite3_vtab_cursor *cur){\n  Rtree *pRtree = (Rtree *)(cur->pVtab);\n  int rc;\n  RtreeCursor *pCsr = (RtreeCursor *)cur;\n  freeCursorConstraints(pCsr);\n  rc = nodeRelease(pRtree, pCsr->pNode);\n  sqlite3_free(pCsr);\n  return rc;\n}\n\n/*\n** Rtree virtual table module xEof method.\n**\n** Return non-zero if the cursor does not currently point to a valid \n** record (i.e if the scan has finished), or zero otherwise.\n*/\nstatic int rtreeEof(sqlite3_vtab_cursor *cur){\n  RtreeCursor *pCsr = (RtreeCursor *)cur;\n  return (pCsr->pNode==0);\n}\n\n/*\n** The r-tree constraint passed as the second argument to this function is\n** guaranteed to be a MATCH constraint.\n*/\nstatic int testRtreeGeom(\n  Rtree *pRtree,                  /* R-Tree object */\n  RtreeConstraint *pConstraint,   /* MATCH constraint to test */\n  RtreeCell *pCell,               /* Cell to test */\n  int *pbRes                      /* OUT: Test result */\n){\n  int i;\n  double aCoord[RTREE_MAX_DIMENSIONS*2];\n  int nCoord = pRtree->nDim*2;\n\n  assert( pConstraint->op==RTREE_MATCH );\n  assert( pConstraint->pGeom );\n\n  for(i=0; i<nCoord; i++){\n    aCoord[i] = DCOORD(pCell->aCoord[i]);\n  }\n  return pConstraint->xGeom(pConstraint->pGeom, nCoord, aCoord, pbRes);\n}\n\n/* \n** Cursor pCursor currently points to a cell in a non-leaf page.\n** Set *pbEof to true if the sub-tree headed by the cell is filtered\n** (excluded) by the constraints in the pCursor->aConstraint[] \n** array, or false otherwise.\n**\n** Return SQLITE_OK if successful or an SQLite error code if an error\n** occurs within a geometry callback.\n*/\nstatic int testRtreeCell(Rtree *pRtree, RtreeCursor *pCursor, int *pbEof){\n  RtreeCell cell;\n  int ii;\n  int bRes = 0;\n  int rc = SQLITE_OK;\n\n  nodeGetCell(pRtree, pCursor->pNode, pCursor->iCell, &cell);\n  for(ii=0; bRes==0 && ii<pCursor->nConstraint; ii++){\n    RtreeConstraint *p = &pCursor->aConstraint[ii];\n    double cell_min = DCOORD(cell.aCoord[(p->iCoord>>1)*2]);\n    double cell_max = DCOORD(cell.aCoord[(p->iCoord>>1)*2+1]);\n\n    assert(p->op==RTREE_LE || p->op==RTREE_LT || p->op==RTREE_GE \n        || p->op==RTREE_GT || p->op==RTREE_EQ || p->op==RTREE_MATCH\n    );\n\n    switch( p->op ){\n      case RTREE_LE: case RTREE_LT: \n        bRes = p->rValue<cell_min; \n        break;\n\n      case RTREE_GE: case RTREE_GT: \n        bRes = p->rValue>cell_max; \n        break;\n\n      case RTREE_EQ:\n        bRes = (p->rValue>cell_max || p->rValue<cell_min);\n        break;\n\n      default: {\n        assert( p->op==RTREE_MATCH );\n        rc = testRtreeGeom(pRtree, p, &cell, &bRes);\n        bRes = !bRes;\n        break;\n      }\n    }\n  }\n\n  *pbEof = bRes;\n  return rc;\n}\n\n/* \n** Test if the cell that cursor pCursor currently points to\n** would be filtered (excluded) by the constraints in the \n** pCursor->aConstraint[] array. If so, set *pbEof to true before\n** returning. If the cell is not filtered (excluded) by the constraints,\n** set pbEof to zero.\n**\n** Return SQLITE_OK if successful or an SQLite error code if an error\n** occurs within a geometry callback.\n**\n** This function assumes that the cell is part of a leaf node.\n*/\nstatic int testRtreeEntry(Rtree *pRtree, RtreeCursor *pCursor, int *pbEof){\n  RtreeCell cell;\n  int ii;\n  *pbEof = 0;\n\n  nodeGetCell(pRtree, pCursor->pNode, pCursor->iCell, &cell);\n  for(ii=0; ii<pCursor->nConstraint; ii++){\n    RtreeConstraint *p = &pCursor->aConstraint[ii];\n    double coord = DCOORD(cell.aCoord[p->iCoord]);\n    int res;\n    assert(p->op==RTREE_LE || p->op==RTREE_LT || p->op==RTREE_GE \n        || p->op==RTREE_GT || p->op==RTREE_EQ || p->op==RTREE_MATCH\n    );\n    switch( p->op ){\n      case RTREE_LE: res = (coord<=p->rValue); break;\n      case RTREE_LT: res = (coord<p->rValue);  break;\n      case RTREE_GE: res = (coord>=p->rValue); break;\n      case RTREE_GT: res = (coord>p->rValue);  break;\n      case RTREE_EQ: res = (coord==p->rValue); break;\n      default: {\n        int rc;\n        assert( p->op==RTREE_MATCH );\n        rc = testRtreeGeom(pRtree, p, &cell, &res);\n        if( rc!=SQLITE_OK ){\n          return rc;\n        }\n        break;\n      }\n    }\n\n    if( !res ){\n      *pbEof = 1;\n      return SQLITE_OK;\n    }\n  }\n\n  return SQLITE_OK;\n}\n\n/*\n** Cursor pCursor currently points at a node that heads a sub-tree of\n** height iHeight (if iHeight==0, then the node is a leaf). Descend\n** to point to the left-most cell of the sub-tree that matches the \n** configured constraints.\n*/\nstatic int descendToCell(\n  Rtree *pRtree, \n  RtreeCursor *pCursor, \n  int iHeight,\n  int *pEof                 /* OUT: Set to true if cannot descend */\n){\n  int isEof;\n  int rc;\n  int ii;\n  RtreeNode *pChild;\n  sqlite3_int64 iRowid;\n\n  RtreeNode *pSavedNode = pCursor->pNode;\n  int iSavedCell = pCursor->iCell;\n\n  assert( iHeight>=0 );\n\n  if( iHeight==0 ){\n    rc = testRtreeEntry(pRtree, pCursor, &isEof);\n  }else{\n    rc = testRtreeCell(pRtree, pCursor, &isEof);\n  }\n  if( rc!=SQLITE_OK || isEof || iHeight==0 ){\n    goto descend_to_cell_out;\n  }\n\n  iRowid = nodeGetRowid(pRtree, pCursor->pNode, pCursor->iCell);\n  rc = nodeAcquire(pRtree, iRowid, pCursor->pNode, &pChild);\n  if( rc!=SQLITE_OK ){\n    goto descend_to_cell_out;\n  }\n\n  nodeRelease(pRtree, pCursor->pNode);\n  pCursor->pNode = pChild;\n  isEof = 1;\n  for(ii=0; isEof && ii<NCELL(pChild); ii++){\n    pCursor->iCell = ii;\n    rc = descendToCell(pRtree, pCursor, iHeight-1, &isEof);\n    if( rc!=SQLITE_OK ){\n      goto descend_to_cell_out;\n    }\n  }\n\n  if( isEof ){\n    assert( pCursor->pNode==pChild );\n    nodeReference(pSavedNode);\n    nodeRelease(pRtree, pChild);\n    pCursor->pNode = pSavedNode;\n    pCursor->iCell = iSavedCell;\n  }\n\ndescend_to_cell_out:\n  *pEof = isEof;\n  return rc;\n}\n\n/*\n** One of the cells in node pNode is guaranteed to have a 64-bit \n** integer value equal to iRowid. Return the index of this cell.\n*/\nstatic int nodeRowidIndex(\n  Rtree *pRtree, \n  RtreeNode *pNode, \n  i64 iRowid,\n  int *piIndex\n){\n  int ii;\n  int nCell = NCELL(pNode);\n  for(ii=0; ii<nCell; ii++){\n    if( nodeGetRowid(pRtree, pNode, ii)==iRowid ){\n      *piIndex = ii;\n      return SQLITE_OK;\n    }\n  }\n  return SQLITE_CORRUPT;\n}\n\n/*\n** Return the index of the cell containing a pointer to node pNode\n** in its parent. If pNode is the root node, return -1.\n*/\nstatic int nodeParentIndex(Rtree *pRtree, RtreeNode *pNode, int *piIndex){\n  RtreeNode *pParent = pNode->pParent;\n  if( pParent ){\n    return nodeRowidIndex(pRtree, pParent, pNode->iNode, piIndex);\n  }\n  *piIndex = -1;\n  return SQLITE_OK;\n}\n\n/* \n** Rtree virtual table module xNext method.\n*/\nstatic int rtreeNext(sqlite3_vtab_cursor *pVtabCursor){\n  Rtree *pRtree = (Rtree *)(pVtabCursor->pVtab);\n  RtreeCursor *pCsr = (RtreeCursor *)pVtabCursor;\n  int rc = SQLITE_OK;\n\n  /* RtreeCursor.pNode must not be NULL. If is is NULL, then this cursor is\n  ** already at EOF. It is against the rules to call the xNext() method of\n  ** a cursor that has already reached EOF.\n  */\n  assert( pCsr->pNode );\n\n  if( pCsr->iStrategy==1 ){\n    /* This \"scan\" is a direct lookup by rowid. There is no next entry. */\n    nodeRelease(pRtree, pCsr->pNode);\n    pCsr->pNode = 0;\n  }else{\n    /* Move to the next entry that matches the configured constraints. */\n    int iHeight = 0;\n    while( pCsr->pNode ){\n      RtreeNode *pNode = pCsr->pNode;\n      int nCell = NCELL(pNode);\n      for(pCsr->iCell++; pCsr->iCell<nCell; pCsr->iCell++){\n        int isEof;\n        rc = descendToCell(pRtree, pCsr, iHeight, &isEof);\n        if( rc!=SQLITE_OK || !isEof ){\n          return rc;\n        }\n      }\n      pCsr->pNode = pNode->pParent;\n      rc = nodeParentIndex(pRtree, pNode, &pCsr->iCell);\n      if( rc!=SQLITE_OK ){\n        return rc;\n      }\n      nodeReference(pCsr->pNode);\n      nodeRelease(pRtree, pNode);\n      iHeight++;\n    }\n  }\n\n  return rc;\n}\n\n/* \n** Rtree virtual table module xRowid method.\n*/\nstatic int rtreeRowid(sqlite3_vtab_cursor *pVtabCursor, sqlite_int64 *pRowid){\n  Rtree *pRtree = (Rtree *)pVtabCursor->pVtab;\n  RtreeCursor *pCsr = (RtreeCursor *)pVtabCursor;\n\n  assert(pCsr->pNode);\n  *pRowid = nodeGetRowid(pRtree, pCsr->pNode, pCsr->iCell);\n\n  return SQLITE_OK;\n}\n\n/* \n** Rtree virtual table module xColumn method.\n*/\nstatic int rtreeColumn(sqlite3_vtab_cursor *cur, sqlite3_context *ctx, int i){\n  Rtree *pRtree = (Rtree *)cur->pVtab;\n  RtreeCursor *pCsr = (RtreeCursor *)cur;\n\n  if( i==0 ){\n    i64 iRowid = nodeGetRowid(pRtree, pCsr->pNode, pCsr->iCell);\n    sqlite3_result_int64(ctx, iRowid);\n  }else{\n    RtreeCoord c;\n    nodeGetCoord(pRtree, pCsr->pNode, pCsr->iCell, i-1, &c);\n    if( pRtree->eCoordType==RTREE_COORD_REAL32 ){\n      sqlite3_result_double(ctx, c.f);\n    }else{\n      assert( pRtree->eCoordType==RTREE_COORD_INT32 );\n      sqlite3_result_int(ctx, c.i);\n    }\n  }\n\n  return SQLITE_OK;\n}\n\n/* \n** Use nodeAcquire() to obtain the leaf node containing the record with \n** rowid iRowid. If successful, set *ppLeaf to point to the node and\n** return SQLITE_OK. If there is no such record in the table, set\n** *ppLeaf to 0 and return SQLITE_OK. If an error occurs, set *ppLeaf\n** to zero and return an SQLite error code.\n*/\nstatic int findLeafNode(Rtree *pRtree, i64 iRowid, RtreeNode **ppLeaf){\n  int rc;\n  *ppLeaf = 0;\n  sqlite3_bind_int64(pRtree->pReadRowid, 1, iRowid);\n  if( sqlite3_step(pRtree->pReadRowid)==SQLITE_ROW ){\n    i64 iNode = sqlite3_column_int64(pRtree->pReadRowid, 0);\n    rc = nodeAcquire(pRtree, iNode, 0, ppLeaf);\n    sqlite3_reset(pRtree->pReadRowid);\n  }else{\n    rc = sqlite3_reset(pRtree->pReadRowid);\n  }\n  return rc;\n}\n\n/*\n** This function is called to configure the RtreeConstraint object passed\n** as the second argument for a MATCH constraint. The value passed as the\n** first argument to this function is the right-hand operand to the MATCH\n** operator.\n*/\nstatic int deserializeGeometry(sqlite3_value *pValue, RtreeConstraint *pCons){\n  RtreeMatchArg *p;\n  sqlite3_rtree_geometry *pGeom;\n  int nBlob;\n\n  /* Check that value is actually a blob. */\n  if( !sqlite3_value_type(pValue)==SQLITE_BLOB ) return SQLITE_ERROR;\n\n  /* Check that the blob is roughly the right size. */\n  nBlob = sqlite3_value_bytes(pValue);\n  if( nBlob<(int)sizeof(RtreeMatchArg) \n   || ((nBlob-sizeof(RtreeMatchArg))%sizeof(double))!=0\n  ){\n    return SQLITE_ERROR;\n  }\n\n  pGeom = (sqlite3_rtree_geometry *)sqlite3_malloc(\n      sizeof(sqlite3_rtree_geometry) + nBlob\n  );\n  if( !pGeom ) return SQLITE_NOMEM;\n  memset(pGeom, 0, sizeof(sqlite3_rtree_geometry));\n  p = (RtreeMatchArg *)&pGeom[1];\n\n  memcpy(p, sqlite3_value_blob(pValue), nBlob);\n  if( p->magic!=RTREE_GEOMETRY_MAGIC \n   || nBlob!=(int)(sizeof(RtreeMatchArg) + (p->nParam-1)*sizeof(double))\n  ){\n    sqlite3_free(pGeom);\n    return SQLITE_ERROR;\n  }\n\n  pGeom->pContext = p->pContext;\n  pGeom->nParam = p->nParam;\n  pGeom->aParam = p->aParam;\n\n  pCons->xGeom = p->xGeom;\n  pCons->pGeom = pGeom;\n  return SQLITE_OK;\n}\n\n/* \n** Rtree virtual table module xFilter method.\n*/\nstatic int rtreeFilter(\n  sqlite3_vtab_cursor *pVtabCursor, \n  int idxNum, const char *idxStr,\n  int argc, sqlite3_value **argv\n){\n  Rtree *pRtree = (Rtree *)pVtabCursor->pVtab;\n  RtreeCursor *pCsr = (RtreeCursor *)pVtabCursor;\n\n  RtreeNode *pRoot = 0;\n  int ii;\n  int rc = SQLITE_OK;\n\n  rtreeReference(pRtree);\n\n  freeCursorConstraints(pCsr);\n  pCsr->iStrategy = idxNum;\n\n  if( idxNum==1 ){\n    /* Special case - lookup by rowid. */\n    RtreeNode *pLeaf;        /* Leaf on which the required cell resides */\n    i64 iRowid = sqlite3_value_int64(argv[0]);\n    rc = findLeafNode(pRtree, iRowid, &pLeaf);\n    pCsr->pNode = pLeaf; \n    if( pLeaf ){\n      assert( rc==SQLITE_OK );\n      rc = nodeRowidIndex(pRtree, pLeaf, iRowid, &pCsr->iCell);\n    }\n  }else{\n    /* Normal case - r-tree scan. Set up the RtreeCursor.aConstraint array \n    ** with the configured constraints. \n    */\n    if( argc>0 ){\n      pCsr->aConstraint = sqlite3_malloc(sizeof(RtreeConstraint)*argc);\n      pCsr->nConstraint = argc;\n      if( !pCsr->aConstraint ){\n        rc = SQLITE_NOMEM;\n      }else{\n        memset(pCsr->aConstraint, 0, sizeof(RtreeConstraint)*argc);\n        assert( (idxStr==0 && argc==0) || strlen(idxStr)==argc*2 );\n        for(ii=0; ii<argc; ii++){\n          RtreeConstraint *p = &pCsr->aConstraint[ii];\n          p->op = idxStr[ii*2];\n          p->iCoord = idxStr[ii*2+1]-'a';\n          if( p->op==RTREE_MATCH ){\n            /* A MATCH operator. The right-hand-side must be a blob that\n            ** can be cast into an RtreeMatchArg object. One created using\n            ** an sqlite3_rtree_geometry_callback() SQL user function.\n            */\n            rc = deserializeGeometry(argv[ii], p);\n            if( rc!=SQLITE_OK ){\n              break;\n            }\n          }else{\n            p->rValue = sqlite3_value_double(argv[ii]);\n          }\n        }\n      }\n    }\n  \n    if( rc==SQLITE_OK ){\n      pCsr->pNode = 0;\n      rc = nodeAcquire(pRtree, 1, 0, &pRoot);\n    }\n    if( rc==SQLITE_OK ){\n      int isEof = 1;\n      int nCell = NCELL(pRoot);\n      pCsr->pNode = pRoot;\n      for(pCsr->iCell=0; rc==SQLITE_OK && pCsr->iCell<nCell; pCsr->iCell++){\n        assert( pCsr->pNode==pRoot );\n        rc = descendToCell(pRtree, pCsr, pRtree->iDepth, &isEof);\n        if( !isEof ){\n          break;\n        }\n      }\n      if( rc==SQLITE_OK && isEof ){\n        assert( pCsr->pNode==pRoot );\n        nodeRelease(pRtree, pRoot);\n        pCsr->pNode = 0;\n      }\n      assert( rc!=SQLITE_OK || !pCsr->pNode || pCsr->iCell<NCELL(pCsr->pNode) );\n    }\n  }\n\n  rtreeRelease(pRtree);\n  return rc;\n}\n\n/*\n** Rtree virtual table module xBestIndex method. There are three\n** table scan strategies to choose from (in order from most to \n** least desirable):\n**\n**   idxNum     idxStr        Strategy\n**   ------------------------------------------------\n**     1        Unused        Direct lookup by rowid.\n**     2        See below     R-tree query or full-table scan.\n**   ------------------------------------------------\n**\n** If strategy 1 is used, then idxStr is not meaningful. If strategy\n** 2 is used, idxStr is formatted to contain 2 bytes for each \n** constraint used. The first two bytes of idxStr correspond to \n** the constraint in sqlite3_index_info.aConstraintUsage[] with\n** (argvIndex==1) etc.\n**\n** The first of each pair of bytes in idxStr identifies the constraint\n** operator as follows:\n**\n**   Operator    Byte Value\n**   ----------------------\n**      =        0x41 ('A')\n**     <=        0x42 ('B')\n**      <        0x43 ('C')\n**     >=        0x44 ('D')\n**      >        0x45 ('E')\n**   MATCH       0x46 ('F')\n**   ----------------------\n**\n** The second of each pair of bytes identifies the coordinate column\n** to which the constraint applies. The leftmost coordinate column\n** is 'a', the second from the left 'b' etc.\n*/\nstatic int rtreeBestIndex(sqlite3_vtab *tab, sqlite3_index_info *pIdxInfo){\n  int rc = SQLITE_OK;\n  int ii, cCol;\n\n  int iIdx = 0;\n  char zIdxStr[RTREE_MAX_DIMENSIONS*8+1];\n  memset(zIdxStr, 0, sizeof(zIdxStr));\n  UNUSED_PARAMETER(tab);\n\n  assert( pIdxInfo->idxStr==0 );\n  for(ii=0; ii<pIdxInfo->nConstraint; ii++){\n    struct sqlite3_index_constraint *p = &pIdxInfo->aConstraint[ii];\n\n    if( p->usable && p->iColumn==0 && p->op==SQLITE_INDEX_CONSTRAINT_EQ ){\n      /* We have an equality constraint on the rowid. Use strategy 1. */\n      int jj;\n      for(jj=0; jj<ii; jj++){\n        pIdxInfo->aConstraintUsage[jj].argvIndex = 0;\n        pIdxInfo->aConstraintUsage[jj].omit = 0;\n      }\n      pIdxInfo->idxNum = 1;\n      pIdxInfo->aConstraintUsage[ii].argvIndex = 1;\n      pIdxInfo->aConstraintUsage[jj].omit = 1;\n\n      /* This strategy involves a two rowid lookups on an B-Tree structures\n      ** and then a linear search of an R-Tree node. This should be \n      ** considered almost as quick as a direct rowid lookup (for which \n      ** sqlite uses an internal cost of 0.0).\n      */ \n      pIdxInfo->estimatedCost = 10.0;\n      return SQLITE_OK;\n    }\n\n    if( p->usable && (p->iColumn>0 || p->op==SQLITE_INDEX_CONSTRAINT_MATCH) ){\n      int j, opmsk;\n      static const unsigned char compatible[] = { 0, 0, 1, 1, 2, 2 };\n      u8 op = 0;\n      switch( p->op ){\n        case SQLITE_INDEX_CONSTRAINT_EQ: op = RTREE_EQ; break;\n        case SQLITE_INDEX_CONSTRAINT_GT: op = RTREE_GT; break;\n        case SQLITE_INDEX_CONSTRAINT_LE: op = RTREE_LE; break;\n        case SQLITE_INDEX_CONSTRAINT_LT: op = RTREE_LT; break;\n        case SQLITE_INDEX_CONSTRAINT_GE: op = RTREE_GE; break;\n        default:\n          assert( p->op==SQLITE_INDEX_CONSTRAINT_MATCH );\n          op = RTREE_MATCH; \n          break;\n      }\n      assert( op!=0 );\n\n      /* Make sure this particular constraint has not been used before.\n      ** If it has been used before, ignore it.\n      **\n      ** A <= or < can be used if there is a prior >= or >.\n      ** A >= or > can be used if there is a prior < or <=.\n      ** A <= or < is disqualified if there is a prior <=, <, or ==.\n      ** A >= or > is disqualified if there is a prior >=, >, or ==.\n      ** A == is disqualifed if there is any prior constraint.\n      */\n      assert( compatible[RTREE_EQ & 7]==0 );\n      assert( compatible[RTREE_LT & 7]==1 );\n      assert( compatible[RTREE_LE & 7]==1 );\n      assert( compatible[RTREE_GT & 7]==2 );\n      assert( compatible[RTREE_GE & 7]==2 );\n      cCol = p->iColumn - 1 + 'a';\n      opmsk = compatible[op & 7];\n      for(j=0; j<iIdx; j+=2){\n        if( zIdxStr[j+1]==cCol && (compatible[zIdxStr[j] & 7] & opmsk)!=0 ){\n          op = 0;\n          break;\n        }\n      }\n      if( op ){\n        assert( iIdx<sizeof(zIdxStr)-1 );\n        zIdxStr[iIdx++] = op;\n        zIdxStr[iIdx++] = cCol;\n        pIdxInfo->aConstraintUsage[ii].argvIndex = (iIdx/2);\n        pIdxInfo->aConstraintUsage[ii].omit = 1;\n      }\n    }\n  }\n\n  pIdxInfo->idxNum = 2;\n  pIdxInfo->needToFreeIdxStr = 1;\n  if( iIdx>0 && 0==(pIdxInfo->idxStr = sqlite3_mprintf(\"%s\", zIdxStr)) ){\n    return SQLITE_NOMEM;\n  }\n  assert( iIdx>=0 );\n  pIdxInfo->estimatedCost = (2000000.0 / (double)(iIdx + 1));\n  return rc;\n}\n\n/*\n** Return the N-dimensional volumn of the cell stored in *p.\n*/\nstatic float cellArea(Rtree *pRtree, RtreeCell *p){\n  float area = 1.0;\n  int ii;\n  for(ii=0; ii<(pRtree->nDim*2); ii+=2){\n    area = area * (DCOORD(p->aCoord[ii+1]) - DCOORD(p->aCoord[ii]));\n  }\n  return area;\n}\n\n/*\n** Return the margin length of cell p. The margin length is the sum\n** of the objects size in each dimension.\n*/\nstatic float cellMargin(Rtree *pRtree, RtreeCell *p){\n  float margin = 0.0;\n  int ii;\n  for(ii=0; ii<(pRtree->nDim*2); ii+=2){\n    margin += (DCOORD(p->aCoord[ii+1]) - DCOORD(p->aCoord[ii]));\n  }\n  return margin;\n}\n\n/*\n** Store the union of cells p1 and p2 in p1.\n*/\nstatic void cellUnion(Rtree *pRtree, RtreeCell *p1, RtreeCell *p2){\n  int ii;\n  if( pRtree->eCoordType==RTREE_COORD_REAL32 ){\n    for(ii=0; ii<(pRtree->nDim*2); ii+=2){\n      p1->aCoord[ii].f = MIN(p1->aCoord[ii].f, p2->aCoord[ii].f);\n      p1->aCoord[ii+1].f = MAX(p1->aCoord[ii+1].f, p2->aCoord[ii+1].f);\n    }\n  }else{\n    for(ii=0; ii<(pRtree->nDim*2); ii+=2){\n      p1->aCoord[ii].i = MIN(p1->aCoord[ii].i, p2->aCoord[ii].i);\n      p1->aCoord[ii+1].i = MAX(p1->aCoord[ii+1].i, p2->aCoord[ii+1].i);\n    }\n  }\n}\n\n/*\n** Return true if the area covered by p2 is a subset of the area covered\n** by p1. False otherwise.\n*/\nstatic int cellContains(Rtree *pRtree, RtreeCell *p1, RtreeCell *p2){\n  int ii;\n  int isInt = (pRtree->eCoordType==RTREE_COORD_INT32);\n  for(ii=0; ii<(pRtree->nDim*2); ii+=2){\n    RtreeCoord *a1 = &p1->aCoord[ii];\n    RtreeCoord *a2 = &p2->aCoord[ii];\n    if( (!isInt && (a2[0].f<a1[0].f || a2[1].f>a1[1].f)) \n     || ( isInt && (a2[0].i<a1[0].i || a2[1].i>a1[1].i)) \n    ){\n      return 0;\n    }\n  }\n  return 1;\n}\n\n/*\n** Return the amount cell p would grow by if it were unioned with pCell.\n*/\nstatic float cellGrowth(Rtree *pRtree, RtreeCell *p, RtreeCell *pCell){\n  float area;\n  RtreeCell cell;\n  memcpy(&cell, p, sizeof(RtreeCell));\n  area = cellArea(pRtree, &cell);\n  cellUnion(pRtree, &cell, pCell);\n  return (cellArea(pRtree, &cell)-area);\n}\n\n#if VARIANT_RSTARTREE_CHOOSESUBTREE || VARIANT_RSTARTREE_SPLIT\nstatic float cellOverlap(\n  Rtree *pRtree, \n  RtreeCell *p, \n  RtreeCell *aCell, \n  int nCell, \n  int iExclude\n){\n  int ii;\n  float overlap = 0.0;\n  for(ii=0; ii<nCell; ii++){\n#if VARIANT_RSTARTREE_CHOOSESUBTREE\n    if( ii!=iExclude )\n#else\n    assert( iExclude==-1 );\n    UNUSED_PARAMETER(iExclude);\n#endif\n    {\n      int jj;\n      float o = 1.0;\n      for(jj=0; jj<(pRtree->nDim*2); jj+=2){\n        double x1;\n        double x2;\n\n        x1 = MAX(DCOORD(p->aCoord[jj]), DCOORD(aCell[ii].aCoord[jj]));\n        x2 = MIN(DCOORD(p->aCoord[jj+1]), DCOORD(aCell[ii].aCoord[jj+1]));\n\n        if( x2<x1 ){\n          o = 0.0;\n          break;\n        }else{\n          o = o * (x2-x1);\n        }\n      }\n      overlap += o;\n    }\n  }\n  return overlap;\n}\n#endif\n\n#if VARIANT_RSTARTREE_CHOOSESUBTREE\nstatic float cellOverlapEnlargement(\n  Rtree *pRtree, \n  RtreeCell *p, \n  RtreeCell *pInsert, \n  RtreeCell *aCell, \n  int nCell, \n  int iExclude\n){\n  float before;\n  float after;\n  before = cellOverlap(pRtree, p, aCell, nCell, iExclude);\n  cellUnion(pRtree, p, pInsert);\n  after = cellOverlap(pRtree, p, aCell, nCell, iExclude);\n  return after-before;\n}\n#endif\n\n\n/*\n** This function implements the ChooseLeaf algorithm from Gutman[84].\n** ChooseSubTree in r*tree terminology.\n*/\nstatic int ChooseLeaf(\n  Rtree *pRtree,               /* Rtree table */\n  RtreeCell *pCell,            /* Cell to insert into rtree */\n  int iHeight,                 /* Height of sub-tree rooted at pCell */\n  RtreeNode **ppLeaf           /* OUT: Selected leaf page */\n){\n  int rc;\n  int ii;\n  RtreeNode *pNode;\n  rc = nodeAcquire(pRtree, 1, 0, &pNode);\n\n  for(ii=0; rc==SQLITE_OK && ii<(pRtree->iDepth-iHeight); ii++){\n    int iCell;\n    sqlite3_int64 iBest;\n\n    float fMinGrowth;\n    float fMinArea;\n    float fMinOverlap;\n\n    int nCell = NCELL(pNode);\n    RtreeCell cell;\n    RtreeNode *pChild;\n\n    RtreeCell *aCell = 0;\n\n#if VARIANT_RSTARTREE_CHOOSESUBTREE\n    if( ii==(pRtree->iDepth-1) ){\n      int jj;\n      aCell = sqlite3_malloc(sizeof(RtreeCell)*nCell);\n      if( !aCell ){\n        rc = SQLITE_NOMEM;\n        nodeRelease(pRtree, pNode);\n        pNode = 0;\n        continue;\n      }\n      for(jj=0; jj<nCell; jj++){\n        nodeGetCell(pRtree, pNode, jj, &aCell[jj]);\n      }\n    }\n#endif\n\n    /* Select the child node which will be enlarged the least if pCell\n    ** is inserted into it. Resolve ties by choosing the entry with\n    ** the smallest area.\n    */\n    for(iCell=0; iCell<nCell; iCell++){\n      int bBest = 0;\n      float growth;\n      float area;\n      float overlap = 0.0;\n      nodeGetCell(pRtree, pNode, iCell, &cell);\n      growth = cellGrowth(pRtree, &cell, pCell);\n      area = cellArea(pRtree, &cell);\n\n#if VARIANT_RSTARTREE_CHOOSESUBTREE\n      if( ii==(pRtree->iDepth-1) ){\n        overlap = cellOverlapEnlargement(pRtree,&cell,pCell,aCell,nCell,iCell);\n      }\n      if( (iCell==0) \n       || (overlap<fMinOverlap) \n       || (overlap==fMinOverlap && growth<fMinGrowth)\n       || (overlap==fMinOverlap && growth==fMinGrowth && area<fMinArea)\n      ){\n        bBest = 1;\n      }\n#else\n      if( iCell==0||growth<fMinGrowth||(growth==fMinGrowth && area<fMinArea) ){\n        bBest = 1;\n      }\n#endif\n      if( bBest ){\n        fMinOverlap = overlap;\n        fMinGrowth = growth;\n        fMinArea = area;\n        iBest = cell.iRowid;\n      }\n    }\n\n    sqlite3_free(aCell);\n    rc = nodeAcquire(pRtree, iBest, pNode, &pChild);\n    nodeRelease(pRtree, pNode);\n    pNode = pChild;\n  }\n\n  *ppLeaf = pNode;\n  return rc;\n}\n\n/*\n** A cell with the same content as pCell has just been inserted into\n** the node pNode. This function updates the bounding box cells in\n** all ancestor elements.\n*/\nstatic int AdjustTree(\n  Rtree *pRtree,                    /* Rtree table */\n  RtreeNode *pNode,                 /* Adjust ancestry of this node. */\n  RtreeCell *pCell                  /* This cell was just inserted */\n){\n  RtreeNode *p = pNode;\n  while( p->pParent ){\n    RtreeNode *pParent = p->pParent;\n    RtreeCell cell;\n    int iCell;\n\n    if( nodeParentIndex(pRtree, p, &iCell) ){\n      return SQLITE_CORRUPT;\n    }\n\n    nodeGetCell(pRtree, pParent, iCell, &cell);\n    if( !cellContains(pRtree, &cell, pCell) ){\n      cellUnion(pRtree, &cell, pCell);\n      nodeOverwriteCell(pRtree, pParent, &cell, iCell);\n    }\n \n    p = pParent;\n  }\n  return SQLITE_OK;\n}\n\n/*\n** Write mapping (iRowid->iNode) to the <rtree>_rowid table.\n*/\nstatic int rowidWrite(Rtree *pRtree, sqlite3_int64 iRowid, sqlite3_int64 iNode){\n  sqlite3_bind_int64(pRtree->pWriteRowid, 1, iRowid);\n  sqlite3_bind_int64(pRtree->pWriteRowid, 2, iNode);\n  sqlite3_step(pRtree->pWriteRowid);\n  return sqlite3_reset(pRtree->pWriteRowid);\n}\n\n/*\n** Write mapping (iNode->iPar) to the <rtree>_parent table.\n*/\nstatic int parentWrite(Rtree *pRtree, sqlite3_int64 iNode, sqlite3_int64 iPar){\n  sqlite3_bind_int64(pRtree->pWriteParent, 1, iNode);\n  sqlite3_bind_int64(pRtree->pWriteParent, 2, iPar);\n  sqlite3_step(pRtree->pWriteParent);\n  return sqlite3_reset(pRtree->pWriteParent);\n}\n\nstatic int rtreeInsertCell(Rtree *, RtreeNode *, RtreeCell *, int);\n\n#if VARIANT_GUTTMAN_LINEAR_SPLIT\n/*\n** Implementation of the linear variant of the PickNext() function from\n** Guttman[84].\n*/\nstatic RtreeCell *LinearPickNext(\n  Rtree *pRtree,\n  RtreeCell *aCell, \n  int nCell, \n  RtreeCell *pLeftBox, \n  RtreeCell *pRightBox,\n  int *aiUsed\n){\n  int ii;\n  for(ii=0; aiUsed[ii]; ii++);\n  aiUsed[ii] = 1;\n  return &aCell[ii];\n}\n\n/*\n** Implementation of the linear variant of the PickSeeds() function from\n** Guttman[84].\n*/\nstatic void LinearPickSeeds(\n  Rtree *pRtree,\n  RtreeCell *aCell, \n  int nCell, \n  int *piLeftSeed, \n  int *piRightSeed\n){\n  int i;\n  int iLeftSeed = 0;\n  int iRightSeed = 1;\n  float maxNormalInnerWidth = 0.0;\n\n  /* Pick two \"seed\" cells from the array of cells. The algorithm used\n  ** here is the LinearPickSeeds algorithm from Gutman[1984]. The \n  ** indices of the two seed cells in the array are stored in local\n  ** variables iLeftSeek and iRightSeed.\n  */\n  for(i=0; i<pRtree->nDim; i++){\n    float x1 = DCOORD(aCell[0].aCoord[i*2]);\n    float x2 = DCOORD(aCell[0].aCoord[i*2+1]);\n    float x3 = x1;\n    float x4 = x2;\n    int jj;\n\n    int iCellLeft = 0;\n    int iCellRight = 0;\n\n    for(jj=1; jj<nCell; jj++){\n      float left = DCOORD(aCell[jj].aCoord[i*2]);\n      float right = DCOORD(aCell[jj].aCoord[i*2+1]);\n\n      if( left<x1 ) x1 = left;\n      if( right>x4 ) x4 = right;\n      if( left>x3 ){\n        x3 = left;\n        iCellRight = jj;\n      }\n      if( right<x2 ){\n        x2 = right;\n        iCellLeft = jj;\n      }\n    }\n\n    if( x4!=x1 ){\n      float normalwidth = (x3 - x2) / (x4 - x1);\n      if( normalwidth>maxNormalInnerWidth ){\n        iLeftSeed = iCellLeft;\n        iRightSeed = iCellRight;\n      }\n    }\n  }\n\n  *piLeftSeed = iLeftSeed;\n  *piRightSeed = iRightSeed;\n}\n#endif /* VARIANT_GUTTMAN_LINEAR_SPLIT */\n\n#if VARIANT_GUTTMAN_QUADRATIC_SPLIT\n/*\n** Implementation of the quadratic variant of the PickNext() function from\n** Guttman[84].\n*/\nstatic RtreeCell *QuadraticPickNext(\n  Rtree *pRtree,\n  RtreeCell *aCell, \n  int nCell, \n  RtreeCell *pLeftBox, \n  RtreeCell *pRightBox,\n  int *aiUsed\n){\n  #define FABS(a) ((a)<0.0?-1.0*(a):(a))\n\n  int iSelect = -1;\n  float fDiff;\n  int ii;\n  for(ii=0; ii<nCell; ii++){\n    if( aiUsed[ii]==0 ){\n      float left = cellGrowth(pRtree, pLeftBox, &aCell[ii]);\n      float right = cellGrowth(pRtree, pLeftBox, &aCell[ii]);\n      float diff = FABS(right-left);\n      if( iSelect<0 || diff>fDiff ){\n        fDiff = diff;\n        iSelect = ii;\n      }\n    }\n  }\n  aiUsed[iSelect] = 1;\n  return &aCell[iSelect];\n}\n\n/*\n** Implementation of the quadratic variant of the PickSeeds() function from\n** Guttman[84].\n*/\nstatic void QuadraticPickSeeds(\n  Rtree *pRtree,\n  RtreeCell *aCell, \n  int nCell, \n  int *piLeftSeed, \n  int *piRightSeed\n){\n  int ii;\n  int jj;\n\n  int iLeftSeed = 0;\n  int iRightSeed = 1;\n  float fWaste = 0.0;\n\n  for(ii=0; ii<nCell; ii++){\n    for(jj=ii+1; jj<nCell; jj++){\n      float right = cellArea(pRtree, &aCell[jj]);\n      float growth = cellGrowth(pRtree, &aCell[ii], &aCell[jj]);\n      float waste = growth - right;\n\n      if( waste>fWaste ){\n        iLeftSeed = ii;\n        iRightSeed = jj;\n        fWaste = waste;\n      }\n    }\n  }\n\n  *piLeftSeed = iLeftSeed;\n  *piRightSeed = iRightSeed;\n}\n#endif /* VARIANT_GUTTMAN_QUADRATIC_SPLIT */\n\n/*\n** Arguments aIdx, aDistance and aSpare all point to arrays of size\n** nIdx. The aIdx array contains the set of integers from 0 to \n** (nIdx-1) in no particular order. This function sorts the values\n** in aIdx according to the indexed values in aDistance. For\n** example, assuming the inputs:\n**\n**   aIdx      = { 0,   1,   2,   3 }\n**   aDistance = { 5.0, 2.0, 7.0, 6.0 }\n**\n** this function sets the aIdx array to contain:\n**\n**   aIdx      = { 0,   1,   2,   3 }\n**\n** The aSpare array is used as temporary working space by the\n** sorting algorithm.\n*/\nstatic void SortByDistance(\n  int *aIdx, \n  int nIdx, \n  float *aDistance, \n  int *aSpare\n){\n  if( nIdx>1 ){\n    int iLeft = 0;\n    int iRight = 0;\n\n    int nLeft = nIdx/2;\n    int nRight = nIdx-nLeft;\n    int *aLeft = aIdx;\n    int *aRight = &aIdx[nLeft];\n\n    SortByDistance(aLeft, nLeft, aDistance, aSpare);\n    SortByDistance(aRight, nRight, aDistance, aSpare);\n\n    memcpy(aSpare, aLeft, sizeof(int)*nLeft);\n    aLeft = aSpare;\n\n    while( iLeft<nLeft || iRight<nRight ){\n      if( iLeft==nLeft ){\n        aIdx[iLeft+iRight] = aRight[iRight];\n        iRight++;\n      }else if( iRight==nRight ){\n        aIdx[iLeft+iRight] = aLeft[iLeft];\n        iLeft++;\n      }else{\n        float fLeft = aDistance[aLeft[iLeft]];\n        float fRight = aDistance[aRight[iRight]];\n        if( fLeft<fRight ){\n          aIdx[iLeft+iRight] = aLeft[iLeft];\n          iLeft++;\n        }else{\n          aIdx[iLeft+iRight] = aRight[iRight];\n          iRight++;\n        }\n      }\n    }\n\n#if 0\n    /* Check that the sort worked */\n    {\n      int jj;\n      for(jj=1; jj<nIdx; jj++){\n        float left = aDistance[aIdx[jj-1]];\n        float right = aDistance[aIdx[jj]];\n        assert( left<=right );\n      }\n    }\n#endif\n  }\n}\n\n/*\n** Arguments aIdx, aCell and aSpare all point to arrays of size\n** nIdx. The aIdx array contains the set of integers from 0 to \n** (nIdx-1) in no particular order. This function sorts the values\n** in aIdx according to dimension iDim of the cells in aCell. The\n** minimum value of dimension iDim is considered first, the\n** maximum used to break ties.\n**\n** The aSpare array is used as temporary working space by the\n** sorting algorithm.\n*/\nstatic void SortByDimension(\n  Rtree *pRtree,\n  int *aIdx, \n  int nIdx, \n  int iDim, \n  RtreeCell *aCell, \n  int *aSpare\n){\n  if( nIdx>1 ){\n\n    int iLeft = 0;\n    int iRight = 0;\n\n    int nLeft = nIdx/2;\n    int nRight = nIdx-nLeft;\n    int *aLeft = aIdx;\n    int *aRight = &aIdx[nLeft];\n\n    SortByDimension(pRtree, aLeft, nLeft, iDim, aCell, aSpare);\n    SortByDimension(pRtree, aRight, nRight, iDim, aCell, aSpare);\n\n    memcpy(aSpare, aLeft, sizeof(int)*nLeft);\n    aLeft = aSpare;\n    while( iLeft<nLeft || iRight<nRight ){\n      double xleft1 = DCOORD(aCell[aLeft[iLeft]].aCoord[iDim*2]);\n      double xleft2 = DCOORD(aCell[aLeft[iLeft]].aCoord[iDim*2+1]);\n      double xright1 = DCOORD(aCell[aRight[iRight]].aCoord[iDim*2]);\n      double xright2 = DCOORD(aCell[aRight[iRight]].aCoord[iDim*2+1]);\n      if( (iLeft!=nLeft) && ((iRight==nRight)\n       || (xleft1<xright1)\n       || (xleft1==xright1 && xleft2<xright2)\n      )){\n        aIdx[iLeft+iRight] = aLeft[iLeft];\n        iLeft++;\n      }else{\n        aIdx[iLeft+iRight] = aRight[iRight];\n        iRight++;\n      }\n    }\n\n#if 0\n    /* Check that the sort worked */\n    {\n      int jj;\n      for(jj=1; jj<nIdx; jj++){\n        float xleft1 = aCell[aIdx[jj-1]].aCoord[iDim*2];\n        float xleft2 = aCell[aIdx[jj-1]].aCoord[iDim*2+1];\n        float xright1 = aCell[aIdx[jj]].aCoord[iDim*2];\n        float xright2 = aCell[aIdx[jj]].aCoord[iDim*2+1];\n        assert( xleft1<=xright1 && (xleft1<xright1 || xleft2<=xright2) );\n      }\n    }\n#endif\n  }\n}\n\n#if VARIANT_RSTARTREE_SPLIT\n/*\n** Implementation of the R*-tree variant of SplitNode from Beckman[1990].\n*/\nstatic int splitNodeStartree(\n  Rtree *pRtree,\n  RtreeCell *aCell,\n  int nCell,\n  RtreeNode *pLeft,\n  RtreeNode *pRight,\n  RtreeCell *pBboxLeft,\n  RtreeCell *pBboxRight\n){\n  int **aaSorted;\n  int *aSpare;\n  int ii;\n\n  int iBestDim;\n  int iBestSplit;\n  float fBestMargin;\n\n  int nByte = (pRtree->nDim+1)*(sizeof(int*)+nCell*sizeof(int));\n\n  aaSorted = (int **)sqlite3_malloc(nByte);\n  if( !aaSorted ){\n    return SQLITE_NOMEM;\n  }\n\n  aSpare = &((int *)&aaSorted[pRtree->nDim])[pRtree->nDim*nCell];\n  memset(aaSorted, 0, nByte);\n  for(ii=0; ii<pRtree->nDim; ii++){\n    int jj;\n    aaSorted[ii] = &((int *)&aaSorted[pRtree->nDim])[ii*nCell];\n    for(jj=0; jj<nCell; jj++){\n      aaSorted[ii][jj] = jj;\n    }\n    SortByDimension(pRtree, aaSorted[ii], nCell, ii, aCell, aSpare);\n  }\n\n  for(ii=0; ii<pRtree->nDim; ii++){\n    float margin = 0.0;\n    float fBestOverlap;\n    float fBestArea;\n    int iBestLeft;\n    int nLeft;\n\n    for(\n      nLeft=RTREE_MINCELLS(pRtree); \n      nLeft<=(nCell-RTREE_MINCELLS(pRtree)); \n      nLeft++\n    ){\n      RtreeCell left;\n      RtreeCell right;\n      int kk;\n      float overlap;\n      float area;\n\n      memcpy(&left, &aCell[aaSorted[ii][0]], sizeof(RtreeCell));\n      memcpy(&right, &aCell[aaSorted[ii][nCell-1]], sizeof(RtreeCell));\n      for(kk=1; kk<(nCell-1); kk++){\n        if( kk<nLeft ){\n          cellUnion(pRtree, &left, &aCell[aaSorted[ii][kk]]);\n        }else{\n          cellUnion(pRtree, &right, &aCell[aaSorted[ii][kk]]);\n        }\n      }\n      margin += cellMargin(pRtree, &left);\n      margin += cellMargin(pRtree, &right);\n      overlap = cellOverlap(pRtree, &left, &right, 1, -1);\n      area = cellArea(pRtree, &left) + cellArea(pRtree, &right);\n      if( (nLeft==RTREE_MINCELLS(pRtree))\n       || (overlap<fBestOverlap)\n       || (overlap==fBestOverlap && area<fBestArea)\n      ){\n        iBestLeft = nLeft;\n        fBestOverlap = overlap;\n        fBestArea = area;\n      }\n    }\n\n    if( ii==0 || margin<fBestMargin ){\n      iBestDim = ii;\n      fBestMargin = margin;\n      iBestSplit = iBestLeft;\n    }\n  }\n\n  memcpy(pBboxLeft, &aCell[aaSorted[iBestDim][0]], sizeof(RtreeCell));\n  memcpy(pBboxRight, &aCell[aaSorted[iBestDim][iBestSplit]], sizeof(RtreeCell));\n  for(ii=0; ii<nCell; ii++){\n    RtreeNode *pTarget = (ii<iBestSplit)?pLeft:pRight;\n    RtreeCell *pBbox = (ii<iBestSplit)?pBboxLeft:pBboxRight;\n    RtreeCell *pCell = &aCell[aaSorted[iBestDim][ii]];\n    nodeInsertCell(pRtree, pTarget, pCell);\n    cellUnion(pRtree, pBbox, pCell);\n  }\n\n  sqlite3_free(aaSorted);\n  return SQLITE_OK;\n}\n#endif\n\n#if VARIANT_GUTTMAN_SPLIT\n/*\n** Implementation of the regular R-tree SplitNode from Guttman[1984].\n*/\nstatic int splitNodeGuttman(\n  Rtree *pRtree,\n  RtreeCell *aCell,\n  int nCell,\n  RtreeNode *pLeft,\n  RtreeNode *pRight,\n  RtreeCell *pBboxLeft,\n  RtreeCell *pBboxRight\n){\n  int iLeftSeed = 0;\n  int iRightSeed = 1;\n  int *aiUsed;\n  int i;\n\n  aiUsed = sqlite3_malloc(sizeof(int)*nCell);\n  if( !aiUsed ){\n    return SQLITE_NOMEM;\n  }\n  memset(aiUsed, 0, sizeof(int)*nCell);\n\n  PickSeeds(pRtree, aCell, nCell, &iLeftSeed, &iRightSeed);\n\n  memcpy(pBboxLeft, &aCell[iLeftSeed], sizeof(RtreeCell));\n  memcpy(pBboxRight, &aCell[iRightSeed], sizeof(RtreeCell));\n  nodeInsertCell(pRtree, pLeft, &aCell[iLeftSeed]);\n  nodeInsertCell(pRtree, pRight, &aCell[iRightSeed]);\n  aiUsed[iLeftSeed] = 1;\n  aiUsed[iRightSeed] = 1;\n\n  for(i=nCell-2; i>0; i--){\n    RtreeCell *pNext;\n    pNext = PickNext(pRtree, aCell, nCell, pBboxLeft, pBboxRight, aiUsed);\n    float diff =  \n      cellGrowth(pRtree, pBboxLeft, pNext) - \n      cellGrowth(pRtree, pBboxRight, pNext)\n    ;\n    if( (RTREE_MINCELLS(pRtree)-NCELL(pRight)==i)\n     || (diff>0.0 && (RTREE_MINCELLS(pRtree)-NCELL(pLeft)!=i))\n    ){\n      nodeInsertCell(pRtree, pRight, pNext);\n      cellUnion(pRtree, pBboxRight, pNext);\n    }else{\n      nodeInsertCell(pRtree, pLeft, pNext);\n      cellUnion(pRtree, pBboxLeft, pNext);\n    }\n  }\n\n  sqlite3_free(aiUsed);\n  return SQLITE_OK;\n}\n#endif\n\nstatic int updateMapping(\n  Rtree *pRtree, \n  i64 iRowid, \n  RtreeNode *pNode, \n  int iHeight\n){\n  int (*xSetMapping)(Rtree *, sqlite3_int64, sqlite3_int64);\n  xSetMapping = ((iHeight==0)?rowidWrite:parentWrite);\n  if( iHeight>0 ){\n    RtreeNode *pChild = nodeHashLookup(pRtree, iRowid);\n    if( pChild ){\n      nodeRelease(pRtree, pChild->pParent);\n      nodeReference(pNode);\n      pChild->pParent = pNode;\n    }\n  }\n  return xSetMapping(pRtree, iRowid, pNode->iNode);\n}\n\nstatic int SplitNode(\n  Rtree *pRtree,\n  RtreeNode *pNode,\n  RtreeCell *pCell,\n  int iHeight\n){\n  int i;\n  int newCellIsRight = 0;\n\n  int rc = SQLITE_OK;\n  int nCell = NCELL(pNode);\n  RtreeCell *aCell;\n  int *aiUsed;\n\n  RtreeNode *pLeft = 0;\n  RtreeNode *pRight = 0;\n\n  RtreeCell leftbbox;\n  RtreeCell rightbbox;\n\n  /* Allocate an array and populate it with a copy of pCell and \n  ** all cells from node pLeft. Then zero the original node.\n  */\n  aCell = sqlite3_malloc((sizeof(RtreeCell)+sizeof(int))*(nCell+1));\n  if( !aCell ){\n    rc = SQLITE_NOMEM;\n    goto splitnode_out;\n  }\n  aiUsed = (int *)&aCell[nCell+1];\n  memset(aiUsed, 0, sizeof(int)*(nCell+1));\n  for(i=0; i<nCell; i++){\n    nodeGetCell(pRtree, pNode, i, &aCell[i]);\n  }\n  nodeZero(pRtree, pNode);\n  memcpy(&aCell[nCell], pCell, sizeof(RtreeCell));\n  nCell++;\n\n  if( pNode->iNode==1 ){\n    pRight = nodeNew(pRtree, pNode);\n    pLeft = nodeNew(pRtree, pNode);\n    pRtree->iDepth++;\n    pNode->isDirty = 1;\n    writeInt16(pNode->zData, pRtree->iDepth);\n  }else{\n    pLeft = pNode;\n    pRight = nodeNew(pRtree, pLeft->pParent);\n    nodeReference(pLeft);\n  }\n\n  if( !pLeft || !pRight ){\n    rc = SQLITE_NOMEM;\n    goto splitnode_out;\n  }\n\n  memset(pLeft->zData, 0, pRtree->iNodeSize);\n  memset(pRight->zData, 0, pRtree->iNodeSize);\n\n  rc = AssignCells(pRtree, aCell, nCell, pLeft, pRight, &leftbbox, &rightbbox);\n  if( rc!=SQLITE_OK ){\n    goto splitnode_out;\n  }\n\n  /* Ensure both child nodes have node numbers assigned to them by calling\n  ** nodeWrite(). Node pRight always needs a node number, as it was created\n  ** by nodeNew() above. But node pLeft sometimes already has a node number.\n  ** In this case avoid the all to nodeWrite().\n  */\n  if( SQLITE_OK!=(rc = nodeWrite(pRtree, pRight))\n   || (0==pLeft->iNode && SQLITE_OK!=(rc = nodeWrite(pRtree, pLeft)))\n  ){\n    goto splitnode_out;\n  }\n\n  rightbbox.iRowid = pRight->iNode;\n  leftbbox.iRowid = pLeft->iNode;\n\n  if( pNode->iNode==1 ){\n    rc = rtreeInsertCell(pRtree, pLeft->pParent, &leftbbox, iHeight+1);\n    if( rc!=SQLITE_OK ){\n      goto splitnode_out;\n    }\n  }else{\n    RtreeNode *pParent = pLeft->pParent;\n    int iCell;\n    rc = nodeParentIndex(pRtree, pLeft, &iCell);\n    if( rc==SQLITE_OK ){\n      nodeOverwriteCell(pRtree, pParent, &leftbbox, iCell);\n      rc = AdjustTree(pRtree, pParent, &leftbbox);\n    }\n    if( rc!=SQLITE_OK ){\n      goto splitnode_out;\n    }\n  }\n  if( (rc = rtreeInsertCell(pRtree, pRight->pParent, &rightbbox, iHeight+1)) ){\n    goto splitnode_out;\n  }\n\n  for(i=0; i<NCELL(pRight); i++){\n    i64 iRowid = nodeGetRowid(pRtree, pRight, i);\n    rc = updateMapping(pRtree, iRowid, pRight, iHeight);\n    if( iRowid==pCell->iRowid ){\n      newCellIsRight = 1;\n    }\n    if( rc!=SQLITE_OK ){\n      goto splitnode_out;\n    }\n  }\n  if( pNode->iNode==1 ){\n    for(i=0; i<NCELL(pLeft); i++){\n      i64 iRowid = nodeGetRowid(pRtree, pLeft, i);\n      rc = updateMapping(pRtree, iRowid, pLeft, iHeight);\n      if( rc!=SQLITE_OK ){\n        goto splitnode_out;\n      }\n    }\n  }else if( newCellIsRight==0 ){\n    rc = updateMapping(pRtree, pCell->iRowid, pLeft, iHeight);\n  }\n\n  if( rc==SQLITE_OK ){\n    rc = nodeRelease(pRtree, pRight);\n    pRight = 0;\n  }\n  if( rc==SQLITE_OK ){\n    rc = nodeRelease(pRtree, pLeft);\n    pLeft = 0;\n  }\n\nsplitnode_out:\n  nodeRelease(pRtree, pRight);\n  nodeRelease(pRtree, pLeft);\n  sqlite3_free(aCell);\n  return rc;\n}\n\n/*\n** If node pLeaf is not the root of the r-tree and its pParent pointer is \n** still NULL, load all ancestor nodes of pLeaf into memory and populate\n** the pLeaf->pParent chain all the way up to the root node.\n**\n** This operation is required when a row is deleted (or updated - an update\n** is implemented as a delete followed by an insert). SQLite provides the\n** rowid of the row to delete, which can be used to find the leaf on which\n** the entry resides (argument pLeaf). Once the leaf is located, this \n** function is called to determine its ancestry.\n*/\nstatic int fixLeafParent(Rtree *pRtree, RtreeNode *pLeaf){\n  int rc = SQLITE_OK;\n  RtreeNode *pChild = pLeaf;\n  while( rc==SQLITE_OK && pChild->iNode!=1 && pChild->pParent==0 ){\n    int rc2 = SQLITE_OK;          /* sqlite3_reset() return code */\n    sqlite3_bind_int64(pRtree->pReadParent, 1, pChild->iNode);\n    rc = sqlite3_step(pRtree->pReadParent);\n    if( rc==SQLITE_ROW ){\n      RtreeNode *pTest;           /* Used to test for reference loops */\n      i64 iNode;                  /* Node number of parent node */\n\n      /* Before setting pChild->pParent, test that we are not creating a\n      ** loop of references (as we would if, say, pChild==pParent). We don't\n      ** want to do this as it leads to a memory leak when trying to delete\n      ** the referenced counted node structures.\n      */\n      iNode = sqlite3_column_int64(pRtree->pReadParent, 0);\n      for(pTest=pLeaf; pTest && pTest->iNode!=iNode; pTest=pTest->pParent);\n      if( !pTest ){\n        rc2 = nodeAcquire(pRtree, iNode, 0, &pChild->pParent);\n      }\n    }\n    rc = sqlite3_reset(pRtree->pReadParent);\n    if( rc==SQLITE_OK ) rc = rc2;\n    if( rc==SQLITE_OK && !pChild->pParent ) rc = SQLITE_CORRUPT;\n    pChild = pChild->pParent;\n  }\n  return rc;\n}\n\nstatic int deleteCell(Rtree *, RtreeNode *, int, int);\n\nstatic int removeNode(Rtree *pRtree, RtreeNode *pNode, int iHeight){\n  int rc;\n  int rc2;\n  RtreeNode *pParent;\n  int iCell;\n\n  assert( pNode->nRef==1 );\n\n  /* Remove the entry in the parent cell. */\n  rc = nodeParentIndex(pRtree, pNode, &iCell);\n  if( rc==SQLITE_OK ){\n    pParent = pNode->pParent;\n    pNode->pParent = 0;\n    rc = deleteCell(pRtree, pParent, iCell, iHeight+1);\n  }\n  rc2 = nodeRelease(pRtree, pParent);\n  if( rc==SQLITE_OK ){\n    rc = rc2;\n  }\n  if( rc!=SQLITE_OK ){\n    return rc;\n  }\n\n  /* Remove the xxx_node entry. */\n  sqlite3_bind_int64(pRtree->pDeleteNode, 1, pNode->iNode);\n  sqlite3_step(pRtree->pDeleteNode);\n  if( SQLITE_OK!=(rc = sqlite3_reset(pRtree->pDeleteNode)) ){\n    return rc;\n  }\n\n  /* Remove the xxx_parent entry. */\n  sqlite3_bind_int64(pRtree->pDeleteParent, 1, pNode->iNode);\n  sqlite3_step(pRtree->pDeleteParent);\n  if( SQLITE_OK!=(rc = sqlite3_reset(pRtree->pDeleteParent)) ){\n    return rc;\n  }\n  \n  /* Remove the node from the in-memory hash table and link it into\n  ** the Rtree.pDeleted list. Its contents will be re-inserted later on.\n  */\n  nodeHashDelete(pRtree, pNode);\n  pNode->iNode = iHeight;\n  pNode->pNext = pRtree->pDeleted;\n  pNode->nRef++;\n  pRtree->pDeleted = pNode;\n\n  return SQLITE_OK;\n}\n\nstatic int fixBoundingBox(Rtree *pRtree, RtreeNode *pNode){\n  RtreeNode *pParent = pNode->pParent;\n  int rc = SQLITE_OK; \n  if( pParent ){\n    int ii; \n    int nCell = NCELL(pNode);\n    RtreeCell box;                            /* Bounding box for pNode */\n    nodeGetCell(pRtree, pNode, 0, &box);\n    for(ii=1; ii<nCell; ii++){\n      RtreeCell cell;\n      nodeGetCell(pRtree, pNode, ii, &cell);\n      cellUnion(pRtree, &box, &cell);\n    }\n    box.iRowid = pNode->iNode;\n    rc = nodeParentIndex(pRtree, pNode, &ii);\n    if( rc==SQLITE_OK ){\n      nodeOverwriteCell(pRtree, pParent, &box, ii);\n      rc = fixBoundingBox(pRtree, pParent);\n    }\n  }\n  return rc;\n}\n\n/*\n** Delete the cell at index iCell of node pNode. After removing the\n** cell, adjust the r-tree data structure if required.\n*/\nstatic int deleteCell(Rtree *pRtree, RtreeNode *pNode, int iCell, int iHeight){\n  RtreeNode *pParent;\n  int rc;\n\n  if( SQLITE_OK!=(rc = fixLeafParent(pRtree, pNode)) ){\n    return rc;\n  }\n\n  /* Remove the cell from the node. This call just moves bytes around\n  ** the in-memory node image, so it cannot fail.\n  */\n  nodeDeleteCell(pRtree, pNode, iCell);\n\n  /* If the node is not the tree root and now has less than the minimum\n  ** number of cells, remove it from the tree. Otherwise, update the\n  ** cell in the parent node so that it tightly contains the updated\n  ** node.\n  */\n  pParent = pNode->pParent;\n  assert( pParent || pNode->iNode==1 );\n  if( pParent ){\n    if( NCELL(pNode)<RTREE_MINCELLS(pRtree) ){\n      rc = removeNode(pRtree, pNode, iHeight);\n    }else{\n      rc = fixBoundingBox(pRtree, pNode);\n    }\n  }\n\n  return rc;\n}\n\nstatic int Reinsert(\n  Rtree *pRtree, \n  RtreeNode *pNode, \n  RtreeCell *pCell, \n  int iHeight\n){\n  int *aOrder;\n  int *aSpare;\n  RtreeCell *aCell;\n  float *aDistance;\n  int nCell;\n  float aCenterCoord[RTREE_MAX_DIMENSIONS];\n  int iDim;\n  int ii;\n  int rc = SQLITE_OK;\n\n  memset(aCenterCoord, 0, sizeof(float)*RTREE_MAX_DIMENSIONS);\n\n  nCell = NCELL(pNode)+1;\n\n  /* Allocate the buffers used by this operation. The allocation is\n  ** relinquished before this function returns.\n  */\n  aCell = (RtreeCell *)sqlite3_malloc(nCell * (\n    sizeof(RtreeCell) +         /* aCell array */\n    sizeof(int)       +         /* aOrder array */\n    sizeof(int)       +         /* aSpare array */\n    sizeof(float)               /* aDistance array */\n  ));\n  if( !aCell ){\n    return SQLITE_NOMEM;\n  }\n  aOrder    = (int *)&aCell[nCell];\n  aSpare    = (int *)&aOrder[nCell];\n  aDistance = (float *)&aSpare[nCell];\n\n  for(ii=0; ii<nCell; ii++){\n    if( ii==(nCell-1) ){\n      memcpy(&aCell[ii], pCell, sizeof(RtreeCell));\n    }else{\n      nodeGetCell(pRtree, pNode, ii, &aCell[ii]);\n    }\n    aOrder[ii] = ii;\n    for(iDim=0; iDim<pRtree->nDim; iDim++){\n      aCenterCoord[iDim] += DCOORD(aCell[ii].aCoord[iDim*2]);\n      aCenterCoord[iDim] += DCOORD(aCell[ii].aCoord[iDim*2+1]);\n    }\n  }\n  for(iDim=0; iDim<pRtree->nDim; iDim++){\n    aCenterCoord[iDim] = aCenterCoord[iDim]/((float)nCell*2.0);\n  }\n\n  for(ii=0; ii<nCell; ii++){\n    aDistance[ii] = 0.0;\n    for(iDim=0; iDim<pRtree->nDim; iDim++){\n      float coord = DCOORD(aCell[ii].aCoord[iDim*2+1]) - \n          DCOORD(aCell[ii].aCoord[iDim*2]);\n      aDistance[ii] += (coord-aCenterCoord[iDim])*(coord-aCenterCoord[iDim]);\n    }\n  }\n\n  SortByDistance(aOrder, nCell, aDistance, aSpare);\n  nodeZero(pRtree, pNode);\n\n  for(ii=0; rc==SQLITE_OK && ii<(nCell-(RTREE_MINCELLS(pRtree)+1)); ii++){\n    RtreeCell *p = &aCell[aOrder[ii]];\n    nodeInsertCell(pRtree, pNode, p);\n    if( p->iRowid==pCell->iRowid ){\n      if( iHeight==0 ){\n        rc = rowidWrite(pRtree, p->iRowid, pNode->iNode);\n      }else{\n        rc = parentWrite(pRtree, p->iRowid, pNode->iNode);\n      }\n    }\n  }\n  if( rc==SQLITE_OK ){\n    rc = fixBoundingBox(pRtree, pNode);\n  }\n  for(; rc==SQLITE_OK && ii<nCell; ii++){\n    /* Find a node to store this cell in. pNode->iNode currently contains\n    ** the height of the sub-tree headed by the cell.\n    */\n    RtreeNode *pInsert;\n    RtreeCell *p = &aCell[aOrder[ii]];\n    rc = ChooseLeaf(pRtree, p, iHeight, &pInsert);\n    if( rc==SQLITE_OK ){\n      int rc2;\n      rc = rtreeInsertCell(pRtree, pInsert, p, iHeight);\n      rc2 = nodeRelease(pRtree, pInsert);\n      if( rc==SQLITE_OK ){\n        rc = rc2;\n      }\n    }\n  }\n\n  sqlite3_free(aCell);\n  return rc;\n}\n\n/*\n** Insert cell pCell into node pNode. Node pNode is the head of a \n** subtree iHeight high (leaf nodes have iHeight==0).\n*/\nstatic int rtreeInsertCell(\n  Rtree *pRtree,\n  RtreeNode *pNode,\n  RtreeCell *pCell,\n  int iHeight\n){\n  int rc = SQLITE_OK;\n  if( iHeight>0 ){\n    RtreeNode *pChild = nodeHashLookup(pRtree, pCell->iRowid);\n    if( pChild ){\n      nodeRelease(pRtree, pChild->pParent);\n      nodeReference(pNode);\n      pChild->pParent = pNode;\n    }\n  }\n  if( nodeInsertCell(pRtree, pNode, pCell) ){\n#if VARIANT_RSTARTREE_REINSERT\n    if( iHeight<=pRtree->iReinsertHeight || pNode->iNode==1){\n      rc = SplitNode(pRtree, pNode, pCell, iHeight);\n    }else{\n      pRtree->iReinsertHeight = iHeight;\n      rc = Reinsert(pRtree, pNode, pCell, iHeight);\n    }\n#else\n    rc = SplitNode(pRtree, pNode, pCell, iHeight);\n#endif\n  }else{\n    rc = AdjustTree(pRtree, pNode, pCell);\n    if( rc==SQLITE_OK ){\n      if( iHeight==0 ){\n        rc = rowidWrite(pRtree, pCell->iRowid, pNode->iNode);\n      }else{\n        rc = parentWrite(pRtree, pCell->iRowid, pNode->iNode);\n      }\n    }\n  }\n  return rc;\n}\n\nstatic int reinsertNodeContent(Rtree *pRtree, RtreeNode *pNode){\n  int ii;\n  int rc = SQLITE_OK;\n  int nCell = NCELL(pNode);\n\n  for(ii=0; rc==SQLITE_OK && ii<nCell; ii++){\n    RtreeNode *pInsert;\n    RtreeCell cell;\n    nodeGetCell(pRtree, pNode, ii, &cell);\n\n    /* Find a node to store this cell in. pNode->iNode currently contains\n    ** the height of the sub-tree headed by the cell.\n    */\n    rc = ChooseLeaf(pRtree, &cell, pNode->iNode, &pInsert);\n    if( rc==SQLITE_OK ){\n      int rc2;\n      rc = rtreeInsertCell(pRtree, pInsert, &cell, pNode->iNode);\n      rc2 = nodeRelease(pRtree, pInsert);\n      if( rc==SQLITE_OK ){\n        rc = rc2;\n      }\n    }\n  }\n  return rc;\n}\n\n/*\n** Select a currently unused rowid for a new r-tree record.\n*/\nstatic int newRowid(Rtree *pRtree, i64 *piRowid){\n  int rc;\n  sqlite3_bind_null(pRtree->pWriteRowid, 1);\n  sqlite3_bind_null(pRtree->pWriteRowid, 2);\n  sqlite3_step(pRtree->pWriteRowid);\n  rc = sqlite3_reset(pRtree->pWriteRowid);\n  *piRowid = sqlite3_last_insert_rowid(pRtree->db);\n  return rc;\n}\n\n/*\n** The xUpdate method for rtree module virtual tables.\n*/\nstatic int rtreeUpdate(\n  sqlite3_vtab *pVtab, \n  int nData, \n  sqlite3_value **azData, \n  sqlite_int64 *pRowid\n){\n  Rtree *pRtree = (Rtree *)pVtab;\n  int rc = SQLITE_OK;\n\n  rtreeReference(pRtree);\n\n  assert(nData>=1);\n\n  /* If azData[0] is not an SQL NULL value, it is the rowid of a\n  ** record to delete from the r-tree table. The following block does\n  ** just that.\n  */\n  if( sqlite3_value_type(azData[0])!=SQLITE_NULL ){\n    i64 iDelete;                /* The rowid to delete */\n    RtreeNode *pLeaf;           /* Leaf node containing record iDelete */\n    int iCell;                  /* Index of iDelete cell in pLeaf */\n    RtreeNode *pRoot;\n\n    /* Obtain a reference to the root node to initialise Rtree.iDepth */\n    rc = nodeAcquire(pRtree, 1, 0, &pRoot);\n\n    /* Obtain a reference to the leaf node that contains the entry \n    ** about to be deleted. \n    */\n    if( rc==SQLITE_OK ){\n      iDelete = sqlite3_value_int64(azData[0]);\n      rc = findLeafNode(pRtree, iDelete, &pLeaf);\n    }\n\n    /* Delete the cell in question from the leaf node. */\n    if( rc==SQLITE_OK ){\n      int rc2;\n      rc = nodeRowidIndex(pRtree, pLeaf, iDelete, &iCell);\n      if( rc==SQLITE_OK ){\n        rc = deleteCell(pRtree, pLeaf, iCell, 0);\n      }\n      rc2 = nodeRelease(pRtree, pLeaf);\n      if( rc==SQLITE_OK ){\n        rc = rc2;\n      }\n    }\n\n    /* Delete the corresponding entry in the <rtree>_rowid table. */\n    if( rc==SQLITE_OK ){\n      sqlite3_bind_int64(pRtree->pDeleteRowid, 1, iDelete);\n      sqlite3_step(pRtree->pDeleteRowid);\n      rc = sqlite3_reset(pRtree->pDeleteRowid);\n    }\n\n    /* Check if the root node now has exactly one child. If so, remove\n    ** it, schedule the contents of the child for reinsertion and \n    ** reduce the tree height by one.\n    **\n    ** This is equivalent to copying the contents of the child into\n    ** the root node (the operation that Gutman's paper says to perform \n    ** in this scenario).\n    */\n    if( rc==SQLITE_OK && pRtree->iDepth>0 && NCELL(pRoot)==1 ){\n      int rc2;\n      RtreeNode *pChild;\n      i64 iChild = nodeGetRowid(pRtree, pRoot, 0);\n      rc = nodeAcquire(pRtree, iChild, pRoot, &pChild);\n      if( rc==SQLITE_OK ){\n        rc = removeNode(pRtree, pChild, pRtree->iDepth-1);\n      }\n      rc2 = nodeRelease(pRtree, pChild);\n      if( rc==SQLITE_OK ) rc = rc2;\n      if( rc==SQLITE_OK ){\n        pRtree->iDepth--;\n        writeInt16(pRoot->zData, pRtree->iDepth);\n        pRoot->isDirty = 1;\n      }\n    }\n\n    /* Re-insert the contents of any underfull nodes removed from the tree. */\n    for(pLeaf=pRtree->pDeleted; pLeaf; pLeaf=pRtree->pDeleted){\n      if( rc==SQLITE_OK ){\n        rc = reinsertNodeContent(pRtree, pLeaf);\n      }\n      pRtree->pDeleted = pLeaf->pNext;\n      sqlite3_free(pLeaf);\n    }\n\n    /* Release the reference to the root node. */\n    if( rc==SQLITE_OK ){\n      rc = nodeRelease(pRtree, pRoot);\n    }else{\n      nodeRelease(pRtree, pRoot);\n    }\n  }\n\n  /* If the azData[] array contains more than one element, elements\n  ** (azData[2]..azData[argc-1]) contain a new record to insert into\n  ** the r-tree structure.\n  */\n  if( rc==SQLITE_OK && nData>1 ){\n    /* Insert a new record into the r-tree */\n    RtreeCell cell;\n    int ii;\n    RtreeNode *pLeaf;\n\n    /* Populate the cell.aCoord[] array. The first coordinate is azData[3]. */\n    assert( nData==(pRtree->nDim*2 + 3) );\n    if( pRtree->eCoordType==RTREE_COORD_REAL32 ){\n      for(ii=0; ii<(pRtree->nDim*2); ii+=2){\n        cell.aCoord[ii].f = (float)sqlite3_value_double(azData[ii+3]);\n        cell.aCoord[ii+1].f = (float)sqlite3_value_double(azData[ii+4]);\n        if( cell.aCoord[ii].f>cell.aCoord[ii+1].f ){\n          rc = SQLITE_CONSTRAINT;\n          goto constraint;\n        }\n      }\n    }else{\n      for(ii=0; ii<(pRtree->nDim*2); ii+=2){\n        cell.aCoord[ii].i = sqlite3_value_int(azData[ii+3]);\n        cell.aCoord[ii+1].i = sqlite3_value_int(azData[ii+4]);\n        if( cell.aCoord[ii].i>cell.aCoord[ii+1].i ){\n          rc = SQLITE_CONSTRAINT;\n          goto constraint;\n        }\n      }\n    }\n\n    /* Figure out the rowid of the new row. */\n    if( sqlite3_value_type(azData[2])==SQLITE_NULL ){\n      rc = newRowid(pRtree, &cell.iRowid);\n    }else{\n      cell.iRowid = sqlite3_value_int64(azData[2]);\n      sqlite3_bind_int64(pRtree->pReadRowid, 1, cell.iRowid);\n      if( SQLITE_ROW==sqlite3_step(pRtree->pReadRowid) ){\n        sqlite3_reset(pRtree->pReadRowid);\n        rc = SQLITE_CONSTRAINT;\n        goto constraint;\n      }\n      rc = sqlite3_reset(pRtree->pReadRowid);\n    }\n    *pRowid = cell.iRowid;\n\n    if( rc==SQLITE_OK ){\n      rc = ChooseLeaf(pRtree, &cell, 0, &pLeaf);\n    }\n    if( rc==SQLITE_OK ){\n      int rc2;\n      pRtree->iReinsertHeight = -1;\n      rc = rtreeInsertCell(pRtree, pLeaf, &cell, 0);\n      rc2 = nodeRelease(pRtree, pLeaf);\n      if( rc==SQLITE_OK ){\n        rc = rc2;\n      }\n    }\n  }\n\nconstraint:\n  rtreeRelease(pRtree);\n  return rc;\n}\n\n/*\n** The xRename method for rtree module virtual tables.\n*/\nstatic int rtreeRename(sqlite3_vtab *pVtab, const char *zNewName){\n  Rtree *pRtree = (Rtree *)pVtab;\n  int rc = SQLITE_NOMEM;\n  char *zSql = sqlite3_mprintf(\n    \"ALTER TABLE %Q.'%q_node'   RENAME TO \\\"%w_node\\\";\"\n    \"ALTER TABLE %Q.'%q_parent' RENAME TO \\\"%w_parent\\\";\"\n    \"ALTER TABLE %Q.'%q_rowid'  RENAME TO \\\"%w_rowid\\\";\"\n    , pRtree->zDb, pRtree->zName, zNewName \n    , pRtree->zDb, pRtree->zName, zNewName \n    , pRtree->zDb, pRtree->zName, zNewName\n  );\n  if( zSql ){\n    rc = sqlite3_exec(pRtree->db, zSql, 0, 0, 0);\n    sqlite3_free(zSql);\n  }\n  return rc;\n}\n\nstatic sqlite3_module rtreeModule = {\n  0,                         /* iVersion */\n  rtreeCreate,                /* xCreate - create a table */\n  rtreeConnect,               /* xConnect - connect to an existing table */\n  rtreeBestIndex,             /* xBestIndex - Determine search strategy */\n  rtreeDisconnect,            /* xDisconnect - Disconnect from a table */\n  rtreeDestroy,               /* xDestroy - Drop a table */\n  rtreeOpen,                  /* xOpen - open a cursor */\n  rtreeClose,                 /* xClose - close a cursor */\n  rtreeFilter,                /* xFilter - configure scan constraints */\n  rtreeNext,                  /* xNext - advance a cursor */\n  rtreeEof,                   /* xEof */\n  rtreeColumn,                /* xColumn - read data */\n  rtreeRowid,                 /* xRowid - read data */\n  rtreeUpdate,                /* xUpdate - write data */\n  0,                          /* xBegin - begin transaction */\n  0,                          /* xSync - sync transaction */\n  0,                          /* xCommit - commit transaction */\n  0,                          /* xRollback - rollback transaction */\n  0,                          /* xFindFunction - function overloading */\n  rtreeRename                 /* xRename - rename the table */\n};\n\nstatic int rtreeSqlInit(\n  Rtree *pRtree, \n  sqlite3 *db, \n  const char *zDb, \n  const char *zPrefix, \n  int isCreate\n){\n  int rc = SQLITE_OK;\n\n  #define N_STATEMENT 9\n  static const char *azSql[N_STATEMENT] = {\n    /* Read and write the xxx_node table */\n    \"SELECT data FROM '%q'.'%q_node' WHERE nodeno = :1\",\n    \"INSERT OR REPLACE INTO '%q'.'%q_node' VALUES(:1, :2)\",\n    \"DELETE FROM '%q'.'%q_node' WHERE nodeno = :1\",\n\n    /* Read and write the xxx_rowid table */\n    \"SELECT nodeno FROM '%q'.'%q_rowid' WHERE rowid = :1\",\n    \"INSERT OR REPLACE INTO '%q'.'%q_rowid' VALUES(:1, :2)\",\n    \"DELETE FROM '%q'.'%q_rowid' WHERE rowid = :1\",\n\n    /* Read and write the xxx_parent table */\n    \"SELECT parentnode FROM '%q'.'%q_parent' WHERE nodeno = :1\",\n    \"INSERT OR REPLACE INTO '%q'.'%q_parent' VALUES(:1, :2)\",\n    \"DELETE FROM '%q'.'%q_parent' WHERE nodeno = :1\"\n  };\n  sqlite3_stmt **appStmt[N_STATEMENT];\n  int i;\n\n  pRtree->db = db;\n\n  if( isCreate ){\n    char *zCreate = sqlite3_mprintf(\n\"CREATE TABLE \\\"%w\\\".\\\"%w_node\\\"(nodeno INTEGER PRIMARY KEY, data BLOB);\"\n\"CREATE TABLE \\\"%w\\\".\\\"%w_rowid\\\"(rowid INTEGER PRIMARY KEY, nodeno INTEGER);\"\n\"CREATE TABLE \\\"%w\\\".\\\"%w_parent\\\"(nodeno INTEGER PRIMARY KEY, parentnode INTEGER);\"\n\"INSERT INTO '%q'.'%q_node' VALUES(1, zeroblob(%d))\",\n      zDb, zPrefix, zDb, zPrefix, zDb, zPrefix, zDb, zPrefix, pRtree->iNodeSize\n    );\n    if( !zCreate ){\n      return SQLITE_NOMEM;\n    }\n    rc = sqlite3_exec(db, zCreate, 0, 0, 0);\n    sqlite3_free(zCreate);\n    if( rc!=SQLITE_OK ){\n      return rc;\n    }\n  }\n\n  appStmt[0] = &pRtree->pReadNode;\n  appStmt[1] = &pRtree->pWriteNode;\n  appStmt[2] = &pRtree->pDeleteNode;\n  appStmt[3] = &pRtree->pReadRowid;\n  appStmt[4] = &pRtree->pWriteRowid;\n  appStmt[5] = &pRtree->pDeleteRowid;\n  appStmt[6] = &pRtree->pReadParent;\n  appStmt[7] = &pRtree->pWriteParent;\n  appStmt[8] = &pRtree->pDeleteParent;\n\n  for(i=0; i<N_STATEMENT && rc==SQLITE_OK; i++){\n    char *zSql = sqlite3_mprintf(azSql[i], zDb, zPrefix);\n    if( zSql ){\n      rc = sqlite3_prepare_v2(db, zSql, -1, appStmt[i], 0); \n    }else{\n      rc = SQLITE_NOMEM;\n    }\n    sqlite3_free(zSql);\n  }\n\n  return rc;\n}\n\n/*\n** The second argument to this function contains the text of an SQL statement\n** that returns a single integer value. The statement is compiled and executed\n** using database connection db. If successful, the integer value returned\n** is written to *piVal and SQLITE_OK returned. Otherwise, an SQLite error\n** code is returned and the value of *piVal after returning is not defined.\n*/\nstatic int getIntFromStmt(sqlite3 *db, const char *zSql, int *piVal){\n  int rc = SQLITE_NOMEM;\n  if( zSql ){\n    sqlite3_stmt *pStmt = 0;\n    rc = sqlite3_prepare_v2(db, zSql, -1, &pStmt, 0);\n    if( rc==SQLITE_OK ){\n      if( SQLITE_ROW==sqlite3_step(pStmt) ){\n        *piVal = sqlite3_column_int(pStmt, 0);\n      }\n      rc = sqlite3_finalize(pStmt);\n    }\n  }\n  return rc;\n}\n\n/*\n** This function is called from within the xConnect() or xCreate() method to\n** determine the node-size used by the rtree table being created or connected\n** to. If successful, pRtree->iNodeSize is populated and SQLITE_OK returned.\n** Otherwise, an SQLite error code is returned.\n**\n** If this function is being called as part of an xConnect(), then the rtree\n** table already exists. In this case the node-size is determined by inspecting\n** the root node of the tree.\n**\n** Otherwise, for an xCreate(), use 64 bytes less than the database page-size. \n** This ensures that each node is stored on a single database page. If the \n** database page-size is so large that more than RTREE_MAXCELLS entries \n** would fit in a single node, use a smaller node-size.\n*/\nstatic int getNodeSize(\n  sqlite3 *db,                    /* Database handle */\n  Rtree *pRtree,                  /* Rtree handle */\n  int isCreate                    /* True for xCreate, false for xConnect */\n){\n  int rc;\n  char *zSql;\n  if( isCreate ){\n    int iPageSize;\n    zSql = sqlite3_mprintf(\"PRAGMA %Q.page_size\", pRtree->zDb);\n    rc = getIntFromStmt(db, zSql, &iPageSize);\n    if( rc==SQLITE_OK ){\n      pRtree->iNodeSize = iPageSize-64;\n      if( (4+pRtree->nBytesPerCell*RTREE_MAXCELLS)<pRtree->iNodeSize ){\n        pRtree->iNodeSize = 4+pRtree->nBytesPerCell*RTREE_MAXCELLS;\n      }\n    }\n  }else{\n    zSql = sqlite3_mprintf(\n        \"SELECT length(data) FROM '%q'.'%q_node' WHERE nodeno = 1\",\n        pRtree->zDb, pRtree->zName\n    );\n    rc = getIntFromStmt(db, zSql, &pRtree->iNodeSize);\n  }\n\n  sqlite3_free(zSql);\n  return rc;\n}\n\n/* \n** This function is the implementation of both the xConnect and xCreate\n** methods of the r-tree virtual table.\n**\n**   argv[0]   -> module name\n**   argv[1]   -> database name\n**   argv[2]   -> table name\n**   argv[...] -> column names...\n*/\nstatic int rtreeInit(\n  sqlite3 *db,                        /* Database connection */\n  void *pAux,                         /* One of the RTREE_COORD_* constants */\n  int argc, const char *const*argv,   /* Parameters to CREATE TABLE statement */\n  sqlite3_vtab **ppVtab,              /* OUT: New virtual table */\n  char **pzErr,                       /* OUT: Error message, if any */\n  int isCreate                        /* True for xCreate, false for xConnect */\n){\n  int rc = SQLITE_OK;\n  Rtree *pRtree;\n  int nDb;              /* Length of string argv[1] */\n  int nName;            /* Length of string argv[2] */\n  int eCoordType = (pAux ? RTREE_COORD_INT32 : RTREE_COORD_REAL32);\n\n  const char *aErrMsg[] = {\n    0,                                                    /* 0 */\n    \"Wrong number of columns for an rtree table\",         /* 1 */\n    \"Too few columns for an rtree table\",                 /* 2 */\n    \"Too many columns for an rtree table\"                 /* 3 */\n  };\n\n  int iErr = (argc<6) ? 2 : argc>(RTREE_MAX_DIMENSIONS*2+4) ? 3 : argc%2;\n  if( aErrMsg[iErr] ){\n    *pzErr = sqlite3_mprintf(\"%s\", aErrMsg[iErr]);\n    return SQLITE_ERROR;\n  }\n\n  /* Allocate the sqlite3_vtab structure */\n  nDb = strlen(argv[1]);\n  nName = strlen(argv[2]);\n  pRtree = (Rtree *)sqlite3_malloc(sizeof(Rtree)+nDb+nName+2);\n  if( !pRtree ){\n    return SQLITE_NOMEM;\n  }\n  memset(pRtree, 0, sizeof(Rtree)+nDb+nName+2);\n  pRtree->nBusy = 1;\n  pRtree->base.pModule = &rtreeModule;\n  pRtree->zDb = (char *)&pRtree[1];\n  pRtree->zName = &pRtree->zDb[nDb+1];\n  pRtree->nDim = (argc-4)/2;\n  pRtree->nBytesPerCell = 8 + pRtree->nDim*4*2;\n  pRtree->eCoordType = eCoordType;\n  memcpy(pRtree->zDb, argv[1], nDb);\n  memcpy(pRtree->zName, argv[2], nName);\n\n  /* Figure out the node size to use. */\n  rc = getNodeSize(db, pRtree, isCreate);\n\n  /* Create/Connect to the underlying relational database schema. If\n  ** that is successful, call sqlite3_declare_vtab() to configure\n  ** the r-tree table schema.\n  */\n  if( rc==SQLITE_OK ){\n    if( (rc = rtreeSqlInit(pRtree, db, argv[1], argv[2], isCreate)) ){\n      *pzErr = sqlite3_mprintf(\"%s\", sqlite3_errmsg(db));\n    }else{\n      char *zSql = sqlite3_mprintf(\"CREATE TABLE x(%s\", argv[3]);\n      char *zTmp;\n      int ii;\n      for(ii=4; zSql && ii<argc; ii++){\n        zTmp = zSql;\n        zSql = sqlite3_mprintf(\"%s, %s\", zTmp, argv[ii]);\n        sqlite3_free(zTmp);\n      }\n      if( zSql ){\n        zTmp = zSql;\n        zSql = sqlite3_mprintf(\"%s);\", zTmp);\n        sqlite3_free(zTmp);\n      }\n      if( !zSql ){\n        rc = SQLITE_NOMEM;\n      }else if( SQLITE_OK!=(rc = sqlite3_declare_vtab(db, zSql)) ){\n        *pzErr = sqlite3_mprintf(\"%s\", sqlite3_errmsg(db));\n      }\n      sqlite3_free(zSql);\n    }\n  }\n\n  if( rc==SQLITE_OK ){\n    *ppVtab = (sqlite3_vtab *)pRtree;\n  }else{\n    rtreeRelease(pRtree);\n  }\n  return rc;\n}\n\n\n/*\n** Implementation of a scalar function that decodes r-tree nodes to\n** human readable strings. This can be used for debugging and analysis.\n**\n** The scalar function takes two arguments, a blob of data containing\n** an r-tree node, and the number of dimensions the r-tree indexes.\n** For a two-dimensional r-tree structure called \"rt\", to deserialize\n** all nodes, a statement like:\n**\n**   SELECT rtreenode(2, data) FROM rt_node;\n**\n** The human readable string takes the form of a Tcl list with one\n** entry for each cell in the r-tree node. Each entry is itself a\n** list, containing the 8-byte rowid/pageno followed by the \n** <num-dimension>*2 coordinates.\n*/\nstatic void rtreenode(sqlite3_context *ctx, int nArg, sqlite3_value **apArg){\n  char *zText = 0;\n  RtreeNode node;\n  Rtree tree;\n  int ii;\n\n  UNUSED_PARAMETER(nArg);\n  memset(&node, 0, sizeof(RtreeNode));\n  memset(&tree, 0, sizeof(Rtree));\n  tree.nDim = sqlite3_value_int(apArg[0]);\n  tree.nBytesPerCell = 8 + 8 * tree.nDim;\n  node.zData = (u8 *)sqlite3_value_blob(apArg[1]);\n\n  for(ii=0; ii<NCELL(&node); ii++){\n    char zCell[512];\n    int nCell = 0;\n    RtreeCell cell;\n    int jj;\n\n    nodeGetCell(&tree, &node, ii, &cell);\n    sqlite3_snprintf(512-nCell,&zCell[nCell],\"%lld\", cell.iRowid);\n    nCell = strlen(zCell);\n    for(jj=0; jj<tree.nDim*2; jj++){\n      sqlite3_snprintf(512-nCell,&zCell[nCell],\" %f\",(double)cell.aCoord[jj].f);\n      nCell = strlen(zCell);\n    }\n\n    if( zText ){\n      char *zTextNew = sqlite3_mprintf(\"%s {%s}\", zText, zCell);\n      sqlite3_free(zText);\n      zText = zTextNew;\n    }else{\n      zText = sqlite3_mprintf(\"{%s}\", zCell);\n    }\n  }\n  \n  sqlite3_result_text(ctx, zText, -1, sqlite3_free);\n}\n\nstatic void rtreedepth(sqlite3_context *ctx, int nArg, sqlite3_value **apArg){\n  UNUSED_PARAMETER(nArg);\n  if( sqlite3_value_type(apArg[0])!=SQLITE_BLOB \n   || sqlite3_value_bytes(apArg[0])<2\n  ){\n    sqlite3_result_error(ctx, \"Invalid argument to rtreedepth()\", -1); \n  }else{\n    u8 *zBlob = (u8 *)sqlite3_value_blob(apArg[0]);\n    sqlite3_result_int(ctx, readInt16(zBlob));\n  }\n}\n\n/*\n** Register the r-tree module with database handle db. This creates the\n** virtual table module \"rtree\" and the debugging/analysis scalar \n** function \"rtreenode\".\n*/\nSQLITE_PRIVATE int sqlite3RtreeInit(sqlite3 *db){\n  const int utf8 = SQLITE_UTF8;\n  int rc;\n\n  rc = sqlite3_create_function(db, \"rtreenode\", 2, utf8, 0, rtreenode, 0, 0);\n  if( rc==SQLITE_OK ){\n    rc = sqlite3_create_function(db, \"rtreedepth\", 1, utf8, 0,rtreedepth, 0, 0);\n  }\n  if( rc==SQLITE_OK ){\n    void *c = (void *)RTREE_COORD_REAL32;\n    rc = sqlite3_create_module_v2(db, \"rtree\", &rtreeModule, c, 0);\n  }\n  if( rc==SQLITE_OK ){\n    void *c = (void *)RTREE_COORD_INT32;\n    rc = sqlite3_create_module_v2(db, \"rtree_i32\", &rtreeModule, c, 0);\n  }\n\n  return rc;\n}\n\n/*\n** A version of sqlite3_free() that can be used as a callback. This is used\n** in two places - as the destructor for the blob value returned by the\n** invocation of a geometry function, and as the destructor for the geometry\n** functions themselves.\n*/\nstatic void doSqlite3Free(void *p){\n  sqlite3_free(p);\n}\n\n/*\n** Each call to sqlite3_rtree_geometry_callback() creates an ordinary SQLite\n** scalar user function. This C function is the callback used for all such\n** registered SQL functions.\n**\n** The scalar user functions return a blob that is interpreted by r-tree\n** table MATCH operators.\n*/\nstatic void geomCallback(sqlite3_context *ctx, int nArg, sqlite3_value **aArg){\n  RtreeGeomCallback *pGeomCtx = (RtreeGeomCallback *)sqlite3_user_data(ctx);\n  RtreeMatchArg *pBlob;\n  int nBlob;\n\n  nBlob = sizeof(RtreeMatchArg) + (nArg-1)*sizeof(double);\n  pBlob = (RtreeMatchArg *)sqlite3_malloc(nBlob);\n  if( !pBlob ){\n    sqlite3_result_error_nomem(ctx);\n  }else{\n    int i;\n    pBlob->magic = RTREE_GEOMETRY_MAGIC;\n    pBlob->xGeom = pGeomCtx->xGeom;\n    pBlob->pContext = pGeomCtx->pContext;\n    pBlob->nParam = nArg;\n    for(i=0; i<nArg; i++){\n      pBlob->aParam[i] = sqlite3_value_double(aArg[i]);\n    }\n    sqlite3_result_blob(ctx, pBlob, nBlob, doSqlite3Free);\n  }\n}\n\n/*\n** Register a new geometry function for use with the r-tree MATCH operator.\n*/\nSQLITE_API int sqlite3_rtree_geometry_callback(\n  sqlite3 *db,\n  const char *zGeom,\n  int (*xGeom)(sqlite3_rtree_geometry *, int, double *, int *),\n  void *pContext\n){\n  RtreeGeomCallback *pGeomCtx;      /* Context object for new user-function */\n\n  /* Allocate and populate the context object. */\n  pGeomCtx = (RtreeGeomCallback *)sqlite3_malloc(sizeof(RtreeGeomCallback));\n  if( !pGeomCtx ) return SQLITE_NOMEM;\n  pGeomCtx->xGeom = xGeom;\n  pGeomCtx->pContext = pContext;\n\n  /* Create the new user-function. Register a destructor function to delete\n  ** the context object when it is no longer required.  */\n  return sqlite3_create_function_v2(db, zGeom, -1, SQLITE_ANY, \n      (void *)pGeomCtx, geomCallback, 0, 0, doSqlite3Free\n  );\n}\n\n#if !SQLITE_CORE\nSQLITE_API int sqlite3_extension_init(\n  sqlite3 *db,\n  char **pzErrMsg,\n  const sqlite3_api_routines *pApi\n){\n  SQLITE_EXTENSION_INIT2(pApi)\n  return sqlite3RtreeInit(db);\n}\n#endif\n\n#endif\n\n/************** End of rtree.c ***********************************************/\n/************** Begin file icu.c *********************************************/\n/*\n** 2007 May 6\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** $Id: icu.c,v 1.7 2007/12/13 21:54:11 drh Exp $\n**\n** This file implements an integration between the ICU library \n** (\"International Components for Unicode\", an open-source library \n** for handling unicode data) and SQLite. The integration uses \n** ICU to provide the following to SQLite:\n**\n**   * An implementation of the SQL regexp() function (and hence REGEXP\n**     operator) using the ICU uregex_XX() APIs.\n**\n**   * Implementations of the SQL scalar upper() and lower() functions\n**     for case mapping.\n**\n**   * Integration of ICU and SQLite collation seqences.\n**\n**   * An implementation of the LIKE operator that uses ICU to \n**     provide case-independent matching.\n*/\n\n#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_ICU)\n\n/* Include ICU headers */\n#include <unicode/utypes.h>\n#include <unicode/uregex.h>\n#include <unicode/ustring.h>\n#include <unicode/ucol.h>\n\n\n#ifndef SQLITE_CORE\n  SQLITE_EXTENSION_INIT1\n#else\n#endif\n\n/*\n** Maximum length (in bytes) of the pattern in a LIKE or GLOB\n** operator.\n*/\n#ifndef SQLITE_MAX_LIKE_PATTERN_LENGTH\n# define SQLITE_MAX_LIKE_PATTERN_LENGTH 50000\n#endif\n\n/*\n** Version of sqlite3_free() that is always a function, never a macro.\n*/\nstatic void xFree(void *p){\n  sqlite3_free(p);\n}\n\n/*\n** Compare two UTF-8 strings for equality where the first string is\n** a \"LIKE\" expression. Return true (1) if they are the same and \n** false (0) if they are different.\n*/\nstatic int icuLikeCompare(\n  const uint8_t *zPattern,   /* LIKE pattern */\n  const uint8_t *zString,    /* The UTF-8 string to compare against */\n  const UChar32 uEsc         /* The escape character */\n){\n  static const int MATCH_ONE = (UChar32)'_';\n  static const int MATCH_ALL = (UChar32)'%';\n\n  int iPattern = 0;       /* Current byte index in zPattern */\n  int iString = 0;        /* Current byte index in zString */\n\n  int prevEscape = 0;     /* True if the previous character was uEsc */\n\n  while( zPattern[iPattern]!=0 ){\n\n    /* Read (and consume) the next character from the input pattern. */\n    UChar32 uPattern;\n    U8_NEXT_UNSAFE(zPattern, iPattern, uPattern);\n    assert(uPattern!=0);\n\n    /* There are now 4 possibilities:\n    **\n    **     1. uPattern is an unescaped match-all character \"%\",\n    **     2. uPattern is an unescaped match-one character \"_\",\n    **     3. uPattern is an unescaped escape character, or\n    **     4. uPattern is to be handled as an ordinary character\n    */\n    if( !prevEscape && uPattern==MATCH_ALL ){\n      /* Case 1. */\n      uint8_t c;\n\n      /* Skip any MATCH_ALL or MATCH_ONE characters that follow a\n      ** MATCH_ALL. For each MATCH_ONE, skip one character in the \n      ** test string.\n      */\n      while( (c=zPattern[iPattern]) == MATCH_ALL || c == MATCH_ONE ){\n        if( c==MATCH_ONE ){\n          if( zString[iString]==0 ) return 0;\n          U8_FWD_1_UNSAFE(zString, iString);\n        }\n        iPattern++;\n      }\n\n      if( zPattern[iPattern]==0 ) return 1;\n\n      while( zString[iString] ){\n        if( icuLikeCompare(&zPattern[iPattern], &zString[iString], uEsc) ){\n          return 1;\n        }\n        U8_FWD_1_UNSAFE(zString, iString);\n      }\n      return 0;\n\n    }else if( !prevEscape && uPattern==MATCH_ONE ){\n      /* Case 2. */\n      if( zString[iString]==0 ) return 0;\n      U8_FWD_1_UNSAFE(zString, iString);\n\n    }else if( !prevEscape && uPattern==uEsc){\n      /* Case 3. */\n      prevEscape = 1;\n\n    }else{\n      /* Case 4. */\n      UChar32 uString;\n      U8_NEXT_UNSAFE(zString, iString, uString);\n      uString = u_foldCase(uString, U_FOLD_CASE_DEFAULT);\n      uPattern = u_foldCase(uPattern, U_FOLD_CASE_DEFAULT);\n      if( uString!=uPattern ){\n        return 0;\n      }\n      prevEscape = 0;\n    }\n  }\n\n  return zString[iString]==0;\n}\n\n/*\n** Implementation of the like() SQL function.  This function implements\n** the build-in LIKE operator.  The first argument to the function is the\n** pattern and the second argument is the string.  So, the SQL statements:\n**\n**       A LIKE B\n**\n** is implemented as like(B, A). If there is an escape character E, \n**\n**       A LIKE B ESCAPE E\n**\n** is mapped to like(B, A, E).\n*/\nstatic void icuLikeFunc(\n  sqlite3_context *context, \n  int argc, \n  sqlite3_value **argv\n){\n  const unsigned char *zA = sqlite3_value_text(argv[0]);\n  const unsigned char *zB = sqlite3_value_text(argv[1]);\n  UChar32 uEsc = 0;\n\n  /* Limit the length of the LIKE or GLOB pattern to avoid problems\n  ** of deep recursion and N*N behavior in patternCompare().\n  */\n  if( sqlite3_value_bytes(argv[0])>SQLITE_MAX_LIKE_PATTERN_LENGTH ){\n    sqlite3_result_error(context, \"LIKE or GLOB pattern too complex\", -1);\n    return;\n  }\n\n\n  if( argc==3 ){\n    /* The escape character string must consist of a single UTF-8 character.\n    ** Otherwise, return an error.\n    */\n    int nE= sqlite3_value_bytes(argv[2]);\n    const unsigned char *zE = sqlite3_value_text(argv[2]);\n    int i = 0;\n    if( zE==0 ) return;\n    U8_NEXT(zE, i, nE, uEsc);\n    if( i!=nE){\n      sqlite3_result_error(context, \n          \"ESCAPE expression must be a single character\", -1);\n      return;\n    }\n  }\n\n  if( zA && zB ){\n    sqlite3_result_int(context, icuLikeCompare(zA, zB, uEsc));\n  }\n}\n\n/*\n** This function is called when an ICU function called from within\n** the implementation of an SQL scalar function returns an error.\n**\n** The scalar function context passed as the first argument is \n** loaded with an error message based on the following two args.\n*/\nstatic void icuFunctionError(\n  sqlite3_context *pCtx,       /* SQLite scalar function context */\n  const char *zName,           /* Name of ICU function that failed */\n  UErrorCode e                 /* Error code returned by ICU function */\n){\n  char zBuf[128];\n  sqlite3_snprintf(128, zBuf, \"ICU error: %s(): %s\", zName, u_errorName(e));\n  zBuf[127] = '\\0';\n  sqlite3_result_error(pCtx, zBuf, -1);\n}\n\n/*\n** Function to delete compiled regexp objects. Registered as\n** a destructor function with sqlite3_set_auxdata().\n*/\nstatic void icuRegexpDelete(void *p){\n  URegularExpression *pExpr = (URegularExpression *)p;\n  uregex_close(pExpr);\n}\n\n/*\n** Implementation of SQLite REGEXP operator. This scalar function takes\n** two arguments. The first is a regular expression pattern to compile\n** the second is a string to match against that pattern. If either \n** argument is an SQL NULL, then NULL Is returned. Otherwise, the result\n** is 1 if the string matches the pattern, or 0 otherwise.\n**\n** SQLite maps the regexp() function to the regexp() operator such\n** that the following two are equivalent:\n**\n**     zString REGEXP zPattern\n**     regexp(zPattern, zString)\n**\n** Uses the following ICU regexp APIs:\n**\n**     uregex_open()\n**     uregex_matches()\n**     uregex_close()\n*/\nstatic void icuRegexpFunc(sqlite3_context *p, int nArg, sqlite3_value **apArg){\n  UErrorCode status = U_ZERO_ERROR;\n  URegularExpression *pExpr;\n  UBool res;\n  const UChar *zString = sqlite3_value_text16(apArg[1]);\n\n  /* If the left hand side of the regexp operator is NULL, \n  ** then the result is also NULL. \n  */\n  if( !zString ){\n    return;\n  }\n\n  pExpr = sqlite3_get_auxdata(p, 0);\n  if( !pExpr ){\n    const UChar *zPattern = sqlite3_value_text16(apArg[0]);\n    if( !zPattern ){\n      return;\n    }\n    pExpr = uregex_open(zPattern, -1, 0, 0, &status);\n\n    if( U_SUCCESS(status) ){\n      sqlite3_set_auxdata(p, 0, pExpr, icuRegexpDelete);\n    }else{\n      assert(!pExpr);\n      icuFunctionError(p, \"uregex_open\", status);\n      return;\n    }\n  }\n\n  /* Configure the text that the regular expression operates on. */\n  uregex_setText(pExpr, zString, -1, &status);\n  if( !U_SUCCESS(status) ){\n    icuFunctionError(p, \"uregex_setText\", status);\n    return;\n  }\n\n  /* Attempt the match */\n  res = uregex_matches(pExpr, 0, &status);\n  if( !U_SUCCESS(status) ){\n    icuFunctionError(p, \"uregex_matches\", status);\n    return;\n  }\n\n  /* Set the text that the regular expression operates on to a NULL\n  ** pointer. This is not really necessary, but it is tidier than \n  ** leaving the regular expression object configured with an invalid\n  ** pointer after this function returns.\n  */\n  uregex_setText(pExpr, 0, 0, &status);\n\n  /* Return 1 or 0. */\n  sqlite3_result_int(p, res ? 1 : 0);\n}\n\n/*\n** Implementations of scalar functions for case mapping - upper() and \n** lower(). Function upper() converts its input to upper-case (ABC).\n** Function lower() converts to lower-case (abc).\n**\n** ICU provides two types of case mapping, \"general\" case mapping and\n** \"language specific\". Refer to ICU documentation for the differences\n** between the two.\n**\n** To utilise \"general\" case mapping, the upper() or lower() scalar \n** functions are invoked with one argument:\n**\n**     upper('ABC') -> 'abc'\n**     lower('abc') -> 'ABC'\n**\n** To access ICU \"language specific\" case mapping, upper() or lower()\n** should be invoked with two arguments. The second argument is the name\n** of the locale to use. Passing an empty string (\"\") or SQL NULL value\n** as the second argument is the same as invoking the 1 argument version\n** of upper() or lower().\n**\n**     lower('I', 'en_us') -> 'i'\n**     lower('I', 'tr_tr') -> '\u0131' (small dotless i)\n**\n** http://www.icu-project.org/userguide/posix.html#case_mappings\n*/\nstatic void icuCaseFunc16(sqlite3_context *p, int nArg, sqlite3_value **apArg){\n  const UChar *zInput;\n  UChar *zOutput;\n  int nInput;\n  int nOutput;\n\n  UErrorCode status = U_ZERO_ERROR;\n  const char *zLocale = 0;\n\n  assert(nArg==1 || nArg==2);\n  if( nArg==2 ){\n    zLocale = (const char *)sqlite3_value_text(apArg[1]);\n  }\n\n  zInput = sqlite3_value_text16(apArg[0]);\n  if( !zInput ){\n    return;\n  }\n  nInput = sqlite3_value_bytes16(apArg[0]);\n\n  nOutput = nInput * 2 + 2;\n  zOutput = sqlite3_malloc(nOutput);\n  if( !zOutput ){\n    return;\n  }\n\n  if( sqlite3_user_data(p) ){\n    u_strToUpper(zOutput, nOutput/2, zInput, nInput/2, zLocale, &status);\n  }else{\n    u_strToLower(zOutput, nOutput/2, zInput, nInput/2, zLocale, &status);\n  }\n\n  if( !U_SUCCESS(status) ){\n    icuFunctionError(p, \"u_strToLower()/u_strToUpper\", status);\n    return;\n  }\n\n  sqlite3_result_text16(p, zOutput, -1, xFree);\n}\n\n/*\n** Collation sequence destructor function. The pCtx argument points to\n** a UCollator structure previously allocated using ucol_open().\n*/\nstatic void icuCollationDel(void *pCtx){\n  UCollator *p = (UCollator *)pCtx;\n  ucol_close(p);\n}\n\n/*\n** Collation sequence comparison function. The pCtx argument points to\n** a UCollator structure previously allocated using ucol_open().\n*/\nstatic int icuCollationColl(\n  void *pCtx,\n  int nLeft,\n  const void *zLeft,\n  int nRight,\n  const void *zRight\n){\n  UCollationResult res;\n  UCollator *p = (UCollator *)pCtx;\n  res = ucol_strcoll(p, (UChar *)zLeft, nLeft/2, (UChar *)zRight, nRight/2);\n  switch( res ){\n    case UCOL_LESS:    return -1;\n    case UCOL_GREATER: return +1;\n    case UCOL_EQUAL:   return 0;\n  }\n  assert(!\"Unexpected return value from ucol_strcoll()\");\n  return 0;\n}\n\n/*\n** Implementation of the scalar function icu_load_collation().\n**\n** This scalar function is used to add ICU collation based collation \n** types to an SQLite database connection. It is intended to be called\n** as follows:\n**\n**     SELECT icu_load_collation(<locale>, <collation-name>);\n**\n** Where <locale> is a string containing an ICU locale identifier (i.e.\n** \"en_AU\", \"tr_TR\" etc.) and <collation-name> is the name of the\n** collation sequence to create.\n*/\nstatic void icuLoadCollation(\n  sqlite3_context *p, \n  int nArg, \n  sqlite3_value **apArg\n){\n  sqlite3 *db = (sqlite3 *)sqlite3_user_data(p);\n  UErrorCode status = U_ZERO_ERROR;\n  const char *zLocale;      /* Locale identifier - (eg. \"jp_JP\") */\n  const char *zName;        /* SQL Collation sequence name (eg. \"japanese\") */\n  UCollator *pUCollator;    /* ICU library collation object */\n  int rc;                   /* Return code from sqlite3_create_collation_x() */\n\n  assert(nArg==2);\n  zLocale = (const char *)sqlite3_value_text(apArg[0]);\n  zName = (const char *)sqlite3_value_text(apArg[1]);\n\n  if( !zLocale || !zName ){\n    return;\n  }\n\n  pUCollator = ucol_open(zLocale, &status);\n  if( !U_SUCCESS(status) ){\n    icuFunctionError(p, \"ucol_open\", status);\n    return;\n  }\n  assert(p);\n\n  rc = sqlite3_create_collation_v2(db, zName, SQLITE_UTF16, (void *)pUCollator, \n      icuCollationColl, icuCollationDel\n  );\n  if( rc!=SQLITE_OK ){\n    ucol_close(pUCollator);\n    sqlite3_result_error(p, \"Error registering collation function\", -1);\n  }\n}\n\n/*\n** Register the ICU extension functions with database db.\n*/\nSQLITE_PRIVATE int sqlite3IcuInit(sqlite3 *db){\n  struct IcuScalar {\n    const char *zName;                        /* Function name */\n    int nArg;                                 /* Number of arguments */\n    int enc;                                  /* Optimal text encoding */\n    void *pContext;                           /* sqlite3_user_data() context */\n    void (*xFunc)(sqlite3_context*,int,sqlite3_value**);\n  } scalars[] = {\n    {\"regexp\", 2, SQLITE_ANY,          0, icuRegexpFunc},\n\n    {\"lower\",  1, SQLITE_UTF16,        0, icuCaseFunc16},\n    {\"lower\",  2, SQLITE_UTF16,        0, icuCaseFunc16},\n    {\"upper\",  1, SQLITE_UTF16, (void*)1, icuCaseFunc16},\n    {\"upper\",  2, SQLITE_UTF16, (void*)1, icuCaseFunc16},\n\n    {\"lower\",  1, SQLITE_UTF8,         0, icuCaseFunc16},\n    {\"lower\",  2, SQLITE_UTF8,         0, icuCaseFunc16},\n    {\"upper\",  1, SQLITE_UTF8,  (void*)1, icuCaseFunc16},\n    {\"upper\",  2, SQLITE_UTF8,  (void*)1, icuCaseFunc16},\n\n    {\"like\",   2, SQLITE_UTF8,         0, icuLikeFunc},\n    {\"like\",   3, SQLITE_UTF8,         0, icuLikeFunc},\n\n    {\"icu_load_collation\",  2, SQLITE_UTF8, (void*)db, icuLoadCollation},\n  };\n\n  int rc = SQLITE_OK;\n  int i;\n\n  for(i=0; rc==SQLITE_OK && i<(sizeof(scalars)/sizeof(struct IcuScalar)); i++){\n    struct IcuScalar *p = &scalars[i];\n    rc = sqlite3_create_function(\n        db, p->zName, p->nArg, p->enc, p->pContext, p->xFunc, 0, 0\n    );\n  }\n\n  return rc;\n}\n\n#if !SQLITE_CORE\nSQLITE_API int sqlite3_extension_init(\n  sqlite3 *db, \n  char **pzErrMsg,\n  const sqlite3_api_routines *pApi\n){\n  SQLITE_EXTENSION_INIT2(pApi)\n  return sqlite3IcuInit(db);\n}\n#endif\n\n#endif\n\n/************** End of icu.c *************************************************/\n/************** Begin file fts3_icu.c ****************************************/\n/*\n** 2007 June 22\n**\n** The author disclaims copyright to this source code.  In place of\n** a legal notice, here is a blessing:\n**\n**    May you do good and not evil.\n**    May you find forgiveness for yourself and forgive others.\n**    May you share freely, never taking more than you give.\n**\n*************************************************************************\n** This file implements a tokenizer for fts3 based on the ICU library.\n** \n** $Id: fts3_icu.c,v 1.3 2008/09/01 18:34:20 danielk1977 Exp $\n*/\n\n#if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS3)\n#ifdef SQLITE_ENABLE_ICU\n\n\n#include <unicode/ubrk.h>\n#include <unicode/utf16.h>\n\ntypedef struct IcuTokenizer IcuTokenizer;\ntypedef struct IcuCursor IcuCursor;\n\nstruct IcuTokenizer {\n  sqlite3_tokenizer base;\n  char *zLocale;\n};\n\nstruct IcuCursor {\n  sqlite3_tokenizer_cursor base;\n\n  UBreakIterator *pIter;      /* ICU break-iterator object */\n  int nChar;                  /* Number of UChar elements in pInput */\n  UChar *aChar;               /* Copy of input using utf-16 encoding */\n  int *aOffset;               /* Offsets of each character in utf-8 input */\n\n  int nBuffer;\n  char *zBuffer;\n\n  int iToken;\n};\n\n/*\n** Create a new tokenizer instance.\n*/\nstatic int icuCreate(\n  int argc,                            /* Number of entries in argv[] */\n  const char * const *argv,            /* Tokenizer creation arguments */\n  sqlite3_tokenizer **ppTokenizer      /* OUT: Created tokenizer */\n){\n  IcuTokenizer *p;\n  int n = 0;\n\n  if( argc>0 ){\n    n = strlen(argv[0])+1;\n  }\n  p = (IcuTokenizer *)sqlite3_malloc(sizeof(IcuTokenizer)+n);\n  if( !p ){\n    return SQLITE_NOMEM;\n  }\n  memset(p, 0, sizeof(IcuTokenizer));\n\n  if( n ){\n    p->zLocale = (char *)&p[1];\n    memcpy(p->zLocale, argv[0], n);\n  }\n\n  *ppTokenizer = (sqlite3_tokenizer *)p;\n\n  return SQLITE_OK;\n}\n\n/*\n** Destroy a tokenizer\n*/\nstatic int icuDestroy(sqlite3_tokenizer *pTokenizer){\n  IcuTokenizer *p = (IcuTokenizer *)pTokenizer;\n  sqlite3_free(p);\n  return SQLITE_OK;\n}\n\n/*\n** Prepare to begin tokenizing a particular string.  The input\n** string to be tokenized is pInput[0..nBytes-1].  A cursor\n** used to incrementally tokenize this string is returned in \n** *ppCursor.\n*/\nstatic int icuOpen(\n  sqlite3_tokenizer *pTokenizer,         /* The tokenizer */\n  const char *zInput,                    /* Input string */\n  int nInput,                            /* Length of zInput in bytes */\n  sqlite3_tokenizer_cursor **ppCursor    /* OUT: Tokenization cursor */\n){\n  IcuTokenizer *p = (IcuTokenizer *)pTokenizer;\n  IcuCursor *pCsr;\n\n  const int32_t opt = U_FOLD_CASE_DEFAULT;\n  UErrorCode status = U_ZERO_ERROR;\n  int nChar;\n\n  UChar32 c;\n  int iInput = 0;\n  int iOut = 0;\n\n  *ppCursor = 0;\n\n  if( nInput<0 ){\n    nInput = strlen(zInput);\n  }\n  nChar = nInput+1;\n  pCsr = (IcuCursor *)sqlite3_malloc(\n      sizeof(IcuCursor) +                /* IcuCursor */\n      nChar * sizeof(UChar) +            /* IcuCursor.aChar[] */\n      (nChar+1) * sizeof(int)            /* IcuCursor.aOffset[] */\n  );\n  if( !pCsr ){\n    return SQLITE_NOMEM;\n  }\n  memset(pCsr, 0, sizeof(IcuCursor));\n  pCsr->aChar = (UChar *)&pCsr[1];\n  pCsr->aOffset = (int *)&pCsr->aChar[nChar];\n\n  pCsr->aOffset[iOut] = iInput;\n  U8_NEXT(zInput, iInput, nInput, c); \n  while( c>0 ){\n    int isError = 0;\n    c = u_foldCase(c, opt);\n    U16_APPEND(pCsr->aChar, iOut, nChar, c, isError);\n    if( isError ){\n      sqlite3_free(pCsr);\n      return SQLITE_ERROR;\n    }\n    pCsr->aOffset[iOut] = iInput;\n\n    if( iInput<nInput ){\n      U8_NEXT(zInput, iInput, nInput, c);\n    }else{\n      c = 0;\n    }\n  }\n\n  pCsr->pIter = ubrk_open(UBRK_WORD, p->zLocale, pCsr->aChar, iOut, &status);\n  if( !U_SUCCESS(status) ){\n    sqlite3_free(pCsr);\n    return SQLITE_ERROR;\n  }\n  pCsr->nChar = iOut;\n\n  ubrk_first(pCsr->pIter);\n  *ppCursor = (sqlite3_tokenizer_cursor *)pCsr;\n  return SQLITE_OK;\n}\n\n/*\n** Close a tokenization cursor previously opened by a call to icuOpen().\n*/\nstatic int icuClose(sqlite3_tokenizer_cursor *pCursor){\n  IcuCursor *pCsr = (IcuCursor *)pCursor;\n  ubrk_close(pCsr->pIter);\n  sqlite3_free(pCsr->zBuffer);\n  sqlite3_free(pCsr);\n  return SQLITE_OK;\n}\n\n/*\n** Extract the next token from a tokenization cursor.\n*/\nstatic int icuNext(\n  sqlite3_tokenizer_cursor *pCursor,  /* Cursor returned by simpleOpen */\n  const char **ppToken,               /* OUT: *ppToken is the token text */\n  int *pnBytes,                       /* OUT: Number of bytes in token */\n  int *piStartOffset,                 /* OUT: Starting offset of token */\n  int *piEndOffset,                   /* OUT: Ending offset of token */\n  int *piPosition                     /* OUT: Position integer of token */\n){\n  IcuCursor *pCsr = (IcuCursor *)pCursor;\n\n  int iStart = 0;\n  int iEnd = 0;\n  int nByte = 0;\n\n  while( iStart==iEnd ){\n    UChar32 c;\n\n    iStart = ubrk_current(pCsr->pIter);\n    iEnd = ubrk_next(pCsr->pIter);\n    if( iEnd==UBRK_DONE ){\n      return SQLITE_DONE;\n    }\n\n    while( iStart<iEnd ){\n      int iWhite = iStart;\n      U8_NEXT(pCsr->aChar, iWhite, pCsr->nChar, c);\n      if( u_isspace(c) ){\n        iStart = iWhite;\n      }else{\n        break;\n      }\n    }\n    assert(iStart<=iEnd);\n  }\n\n  do {\n    UErrorCode status = U_ZERO_ERROR;\n    if( nByte ){\n      char *zNew = sqlite3_realloc(pCsr->zBuffer, nByte);\n      if( !zNew ){\n        return SQLITE_NOMEM;\n      }\n      pCsr->zBuffer = zNew;\n      pCsr->nBuffer = nByte;\n    }\n\n    u_strToUTF8(\n        pCsr->zBuffer, pCsr->nBuffer, &nByte,    /* Output vars */\n        &pCsr->aChar[iStart], iEnd-iStart,       /* Input vars */\n        &status                                  /* Output success/failure */\n    );\n  } while( nByte>pCsr->nBuffer );\n\n  *ppToken = pCsr->zBuffer;\n  *pnBytes = nByte;\n  *piStartOffset = pCsr->aOffset[iStart];\n  *piEndOffset = pCsr->aOffset[iEnd];\n  *piPosition = pCsr->iToken++;\n\n  return SQLITE_OK;\n}\n\n/*\n** The set of routines that implement the simple tokenizer\n*/\nstatic const sqlite3_tokenizer_module icuTokenizerModule = {\n  0,                           /* iVersion */\n  icuCreate,                   /* xCreate  */\n  icuDestroy,                  /* xCreate  */\n  icuOpen,                     /* xOpen    */\n  icuClose,                    /* xClose   */\n  icuNext,                     /* xNext    */\n};\n\n/*\n** Set *ppModule to point at the implementation of the ICU tokenizer.\n*/\nSQLITE_PRIVATE void sqlite3Fts3IcuTokenizerModule(\n  sqlite3_tokenizer_module const**ppModule\n){\n  *ppModule = &icuTokenizerModule;\n}\n\n#endif /* defined(SQLITE_ENABLE_ICU) */\n#endif /* !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS3) */\n\n/************** End of fts3_icu.c ********************************************/\n\nSQLITE_PRIVATE Pgno ptrmapPageno(BtShared *pBt, Pgno pgno);\n\n// TODO:  Do something to read and initialize the database in case\n// the client did not prior to calling this.  \nint tryReadEveryDbPage(sqlite3 *db, Pgno start, Pgno *pBadPage, int *pBadPageType, int *pBadPageZero) {\n  Btree *pBt = db->aDb[0].pBt;\n  // Get the pager, from there we can read every page in the db file\n  Pager *pPager = sqlite3BtreePager(pBt);\n\n  // Logical database size and also the highest actual page number.\n  // (the name sounds like btree last page but it's for the entire DB).\n  Pgno lastPage = sqlite3BtreeLastPage(pBt);\n\n  // Buffer for page data to be written to, if necessary\n  u8 *pageBuf = (u8 *)malloc(pPager->pageSize);\n \n  PgHdr page;\n  page.pPager = pPager;\n  page.pExtra = NULL;\n  page.pDirty = NULL;\n\n  // Calculate the page number that includes the \"pending\" byte so it can be skipped\n  // as that page is never written or read directly by SQLite and is never handled\n  // by the pager codec.\n  Pgno skip = (PENDING_BYTE / pPager->pageSize) + 1;\n  int rc = SQLITE_OK;\n\n  for(page.pgno = start; page.pgno <= lastPage; ++page.pgno) {\n    if(page.pgno == skip)\n      continue;\n\n    page.flags = 0;\n    page.pData = pageBuf;\n    rc = readDbPage(&page);\n\n    // If page was read but is corrupt then set *pBadPageZero and *pBadPageType.\n    if(rc == SQLITE_CORRUPT) {\n      // Check if page is all null bytes\n      const u8 *pdata = (const u8 *)page.pData;\n      if(pdata != NULL) {\n        *pBadPageZero = 1;\n        int i;\n        for(i = 0; i < pPager->pageSize; ++i)\n          if(pdata[i] != 0) {\n            *pBadPageZero = 0;\n            break;\n        }\n      }\n      else\n        *pBadPageZero = -1;\n\n      // Get page type\n      *pBadPageType = -1;  // Unknown\n      PgHdr ptrMap;\n      ptrMap.pPager = pPager;\n      ptrMap.pExtra = NULL;\n      ptrMap.pDirty = NULL;\n      ptrMap.pgno = PTRMAP_PAGENO(pBt->pBt, page.pgno);\n      // If the ptrmap page is not 0 and not the bad page then we can get the bad page's\n      // expected type IF the map page is successfully read.\n      if(ptrMap.pgno != 0 && ptrMap.pgno != page.pgno) {\n        ptrMap.flags = 0;\n        ptrMap.pData = pageBuf;  //reuse pageBuf because we're done looking at bad page data\n        int rc2 = readDbPage(&ptrMap);\n\n        if(rc2 == SQLITE_OK) {\n          int offset = PTRMAP_PTROFFSET(ptrMap.pgno, page.pgno);\n          *pBadPageType = *(((u8 *)ptrMap.pData) + offset);\n        }\n        \n        // xReleaseZeroCopy for pointer map page if necessary\n        if(ptrMap.flags & PGHDR_ZERO_COPY)\n          unpinZeroCopy(&ptrMap);\n      }\n    }\n\n    // xReleaseZeroCopy for checked page if necessary.\n    if(page.flags & PGHDR_ZERO_COPY)\n      unpinZeroCopy(&page);\n\n    // If any error occurred then set *pBadPage to the bad page number and return the error.\n    if(rc != SQLITE_OK) {\n      *pBadPage = page.pgno;\n      break;\n    }\n  }\n\n  free(pageBuf);\n  return rc;\n}\n"
    },
    "skipped": [
        "/tmp/vanessa/spack-stage/spack-stage-foundationdb-6.2.24-ivypaqw232so4ki6gkkpzsm3swadt3su/spack-src/packaging/foundationdb.ico",
        "/tmp/vanessa/spack-stage/spack-stage-foundationdb-6.2.24-ivypaqw232so4ki6gkkpzsm3swadt3su/spack-src/packaging/msi/art/dialog.xcf",
        "/tmp/vanessa/spack-stage/spack-stage-foundationdb-6.2.24-ivypaqw232so4ki6gkkpzsm3swadt3su/spack-src/packaging/msi/art/banner.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-foundationdb-6.2.24-ivypaqw232so4ki6gkkpzsm3swadt3su/spack-src/packaging/msi/art/dialog.jpg",
        "/tmp/vanessa/spack-stage/spack-stage-foundationdb-6.2.24-ivypaqw232so4ki6gkkpzsm3swadt3su/spack-src/packaging/msi/art/banner.xcf",
        "/tmp/vanessa/spack-stage/spack-stage-foundationdb-6.2.24-ivypaqw232so4ki6gkkpzsm3swadt3su/spack-src/packaging/msi/art/favicon-60.png",
        "/tmp/vanessa/spack-stage/spack-stage-foundationdb-6.2.24-ivypaqw232so4ki6gkkpzsm3swadt3su/spack-src/packaging/osx/resources/logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-foundationdb-6.2.24-ivypaqw232so4ki6gkkpzsm3swadt3su/spack-src/documentation/FDB_logo.png",
        "/tmp/vanessa/spack-stage/spack-stage-foundationdb-6.2.24-ivypaqw232so4ki6gkkpzsm3swadt3su/spack-src/documentation/sphinx/source/images/scaling.png",
        "/tmp/vanessa/spack-stage/spack-stage-foundationdb-6.2.24-ivypaqw232so4ki6gkkpzsm3swadt3su/spack-src/documentation/sphinx/source/images/Architecture.png",
        "/tmp/vanessa/spack-stage/spack-stage-foundationdb-6.2.24-ivypaqw232so4ki6gkkpzsm3swadt3su/spack-src/documentation/sphinx/source/images/latency.png",
        "/tmp/vanessa/spack-stage/spack-stage-foundationdb-6.2.24-ivypaqw232so4ki6gkkpzsm3swadt3su/spack-src/documentation/sphinx/source/images/concurrency.png",
        "/tmp/vanessa/spack-stage/spack-stage-foundationdb-6.2.24-ivypaqw232so4ki6gkkpzsm3swadt3su/spack-src/documentation/sphinx/source/images/throughput.png",
        "/tmp/vanessa/spack-stage/spack-stage-foundationdb-6.2.24-ivypaqw232so4ki6gkkpzsm3swadt3su/spack-src/documentation/sphinx/source/images/Architecture.pdf",
        "/tmp/vanessa/spack-stage/spack-stage-foundationdb-6.2.24-ivypaqw232so4ki6gkkpzsm3swadt3su/spack-src/documentation/sphinx/source/images/AP_Partition.png",
        "/tmp/vanessa/spack-stage/spack-stage-foundationdb-6.2.24-ivypaqw232so4ki6gkkpzsm3swadt3su/spack-src/documentation/sphinx/source/images/FDB_Partition.png",
        "/tmp/vanessa/spack-stage/spack-stage-foundationdb-6.2.24-ivypaqw232so4ki6gkkpzsm3swadt3su/spack-src/bindings/go/src/fdb/tuple/testdata/tuples.golden",
        "/tmp/vanessa/spack-stage/spack-stage-foundationdb-6.2.24-ivypaqw232so4ki6gkkpzsm3swadt3su/spack-src/fdbrpc/libcoroutine/bsd_license.txt"
    ],
    "total_files": 1350
}